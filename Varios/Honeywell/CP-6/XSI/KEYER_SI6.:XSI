/*M* KEYER - Plus card munger */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* */
/**/
KEYER:  PROC MAIN;
/**/
/**/
/* Include files */
/**/
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE B_MICROPS_C;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE KEYER_C1;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
 
 
/**/
/* External data */
/**/
DCL B$JIT$ PTR SYMREF READONLY;
DCL B$TCB$ PTR SYMREF READONLY;
DCL OPTLIST UBIN SYMREF;
 
 
/**/
/* DCBs */
/**/
DCL M$SI DCB;
DCL M$UI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$OUT DCB;
DCL MSTD DCB;
DCL M$LIST DCB;
DCL MPROJ DCB;
 
 
/**/
/* External routines */
/**/
DCL X$PARSE ENTRY(1) ALTRET;
 
 
/**/
/* Data */
/**/
DCL WORK_BUF(0:255) UBIN STATIC;
DCL 1 ELINE STATIC,
      2 * CHAR(4) INIT(' '),
      2 INTEGER CHAR(5),
      2 PT CHAR(1),
      2 FRACT CHAR(3),
      2 * CHAR(1) INIT(' '),
      2 BUF CHAR(121);
DCL EBUF(0:79) UBIN STATIC;
DCL EBUFC REDEF EBUF CHAR(320);
DCL LISTBUF CHAR(256) STATIC;
DCL INBUF CHAR(256) STATIC;
DCL INSIZE UBIN STATIC;
DCL INBUFSAV CHAR(256) STATIC;
DCL INSIZESAV UBIN STATIC;
DCL STDBUF CHAR(80) STATIC;
DCL PROJBUF CHAR(80) STATIC;
DCL IKEYC CHAR(256) STATIC;
DCL 1 IKEY REDEF IKEYC,
      2 CNT UBIN(9) UNAL,
      2 VAL UBIN(27) UNAL,
      2 * CHAR(252);
DCL 1 IKEYSAVE STATIC,
      2 * UBIN(9) UNAL,
      2 VAL UBIN(27) UNAL;
DCL 1 OKEY STATIC,
      2 CNT UBIN(9) UNAL INIT(3),
      2 VAL UBIN(27) UNAL;
DCL LAST_FILE CHAR(31) STATIC;
DCL 1 FNAME STATIC,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL VAL_STAR# STATIC UBIN INIT(1);
DCL 1 VAL_STAR(0:500) STATIC,
      2 LEN UBIN INIT(0*0),
      2 TXT CHAR(6) INIT(' '*0),
      2 W BIT(1) INIT('1'B,'0'B*0);
DCL COMLEN UBIN STATIC;
DCL COMTXT CHAR(40) STATIC;
DCL R1 SBIN STATIC;
DCL R2 SBIN STATIC;
DCL R1SAVE SBIN STATIC;
DCL R2SAVE SBIN STATIC;
DCL M$SI$ PTR STATIC;
DCL M$OUT$ PTR STATIC;
DCL MSTD$ PTR STATIC;
DCL M$LIST$ PTR STATIC;
DCL MPROJ$ PTR STATIC;
DCL COMPFLG BIT(1) STATIC;
DCL FIXFLG BIT(1) STATIC;
DCL REKEYFLG BIT(1) STATIC;
DCL VALFLG BIT(36) STATIC;
DCL LIMITFLG BIT(1) STATIC;
DCL LIST_FLG BIT(1) STATIC;
DCL STD_FLG BIT(1) STATIC;
DCL PLUSFLG BIT(1) STATIC;
DCL PLUS_ERR BIT(1) STATIC;
DCL VAL_ERR BIT(1) STATIC;
DCL CREATE_FLG BIT(1) STATIC;
DCL END_FLG BIT(1) STATIC;
DCL MULT_FILE_FLG BIT(1) STATIC;
DCL HEADER_FLG BIT(1) STATIC;
DCL SQZ_FLG BIT(1) STATIC;
DCL LIMFLG BIT(1) STATIC;
DCL LIMIGNOREFLG BIT(1) STATIC;
DCL SEL_FLG BIT(1) STATIC;
DCL LIMCHK_FLG BIT(1) STATIC;
DCL OUFLG BIT(1) STATIC;
DCL SELECT_FLAG BIT(1) STATIC;
DCL REKEY BIT(1) STATIC;
DCL BADKEYCNT SBIN STATIC;
DCL FOUND_PLUS BIT(1) STATIC;
DCL FIRST_NOT_PLUS BIT(1) STATIC;
DCL SELNAKED BIT(1) STATIC;
DCL ERRCNT SBIN STATIC;
DCL WARNCNT SBIN STATIC;
DCL RECCNT SBIN STATIC;
DCL PLUSCNT SBIN STATIC;
DCL FILECNT SBIN STATIC;
DCL 1 ERRCODE STATIC,
      2 * BIT(19),
      2 CODE UBIN(14) UNAL,
      2 * BIT(3);
DCL LAST_ERR SBIN STATIC;
DCL THIS_ERR SBIN STATIC;
DCL INCR UBIN STATIC;
DCL ADD_INITIALS CHAR(4) STATIC;
DCL ADD_STAR CHAR(6) STATIC;
DCL ADD_STAR_SIZE UBIN STATIC;
DCL CUR_DATE CHAR(8) STATIC;
DCL SRCHIX SBIN STATIC;
DCL SRCHRX SBIN STATIC;
%EQU SRCH_LIM=39;
DCL 1 SRCHR(0:%SRCH_LIM) STATIC,
      2 L SBIN,
      2 H SBIN;
DCL 1 SRCHI(0:%SRCH_LIM) STATIC,
      2 INITIAL CHAR(4);
DCL SRCHIFND(0:%SRCH_LIM) BIT(1) UNAL STATIC;
DCL SRCHRFND(0:%SRCH_LIM) BIT(1) UNAL STATIC;
DCL PTR$ PTR STATIC;
DCL P$ PTR STATIC;
DCL I SBIN STATIC;
DCL J SBIN STATIC;
DCL K SBIN STATIC;
DCL CNT UBIN STATIC;
DCL TCNT UBIN STATIC;
DCL STR5 CHAR(5) STATIC;
DCL STR6 CHAR(6) STATIC;
DCL FID_NAME CHAR(32) STATIC;
DCL FID_ACCT CHAR(8) STATIC;
DCL FID_PASS CHAR(8) STATIC;
DCL 1 LISTKEY STATIC,
      2 * UBIN(9) UNAL INIT(31),
      2 C CHAR(31);
DCL 1 EMSG STATIC,
      2 CNT CHAR(5),
      2 * CHAR(0) INIT(' errors, '),
      2 WARN CHAR(5),
      2 * CHAR(0) INIT(' warnings');
DCL 1 STATMSG STATIC,
      2 RECS CHAR(5),
      2 * CHAR(0) INIT(' records, '),
      2 PLUS CHAR(5),
      2 * CHAR(0) INIT(' plus cards');
DCL 1 FILEMSG STATIC,
      2 CNT CHAR(5),
      2 * CHAR(0) INIT(' files');
%P_PCB (NAME=P_PCB,R=OPTLIST,W=WORK_BUF,WSZ="SIZEW(WORK_BUF)",OUTDCB=M$DO);
/**/
DCL PLUSX UBIN STATIC;
DCL 1 PLUS(0:1023) STATIC,
      2 R1 SBIN HALF UNAL,
      2 R2 SBIN HALF UNAL,
      2 VAL UBIN;
 
 
/**/
/* Based structures */
/**/
%B$EXCFR;
%B$TCB (STCLASS="BASED(B$TCB$)");
%F$DCB;
%PARSE$OUT (STCLASS=BASED);
%PARSE$SYM (STCLASS=BASED);
 
 
/**/
/* Fpts */
/**/
%FPT_READ (DCB=M$SI,BUF=INBUF,KEY=IKEY,KEYR=YES);
%FPT_CORRES (DCB1=M$DO,DCB2=M$LO);
%FPT_ERRMSG (CODE=ERRCODE,BUF=EBUF,DCB=M$SI,OUTDCB1=M$DO);
%FPT_WRITE (FPTN=FPT_WR_LO,DCB=M$LO);
%FPT_OPEN (FPTN=FPT_OPN_IN,DCB=M$SI,FUN=IN,ASN=FILE);
%FPT_OPEN (FPTN=FPT_OPN_SET_IN,DCB=M$SI,SETDCB=YES,NAME=FNAME);
%FPT_OPEN (FPTN=FPT_OPN_SET_OUT,DCB=M$OUT,SETDCB=YES,ASN=FILE,FUN=CREATE,
          ACS=DIRECT,ORG=KEYED,IXTNSIZE=4,XTNSIZE=4);
%FPT_CLOSE (FPTN=FPT_CLS_SI,DCB=M$SI);
%FPT_CLOSE (FPTN=FPT_CLS_OUT,DCB=M$OUT,DISP=SAVE,RELG=YES);
%FPT_CLOSE (FPTN=FPT_CLS_OUT_REL,DCB=M$OUT);
%FPT_TIME (DEST=LOCAL,SOURCE=CLOCK,DATE=CUR_DATE);
%FPT_OPEN (FPTN=FPT_OPN_STD,DCB=MSTD,FUN=IN,ASN=FILE,NAME=FID_NAME,
           ACCT=FID_ACCT,PASS=FID_PASS);
%FPT_OPEN (FPTN=FPT_OPN_LIST,DCB=M$LIST,FUN=IN,ASN=FILE,NAME=FID_NAME,
           ACCT=FID_ACCT,PASS=FID_PASS);
%FPT_FID (FPTN=FPT_FID_STD,ACCT=FID_ACCT,ASN=FPT_OPN_STD.V.ASN#,
          NAME=FID_NAME,PASS=FID_PASS,RES=FPT_OPN_STD.V.RES#);
%FPT_FID (FPTN=FPT_FID_LIST,ACCT=FID_ACCT,ASN=FPT_OPN_LIST.V.ASN#,
          NAME=FID_NAME,PASS=FID_PASS,RES=FPT_OPN_LIST.V.RES#);
%FPT_READ (FPTN=FPT_RD_STD,DCB=MSTD,BUF=STDBUF);
%FPT_READ (FPTN=FPT_RD_LIST,DCB=M$LIST,KEY=LISTKEY,KEYS=YES,BUF=LISTBUF);
%FPT_WRITE (FPTN=FPT_WR_OUT,DCB=M$OUT,BUF=INBUF,KEY=OKEY,ONEWKEY=NO,
            NEWKEY=YES);
%FPT_PRECORD (FPTN=FPT_PREC,DCB=M$SI);
%FPT_DEVICE (DCB=M$LO,PAGE=YES);
%FPT_OPEN(FPTN=FPT_OPN_PROJ,
          DCB=MPROJ,
          FUN=IN,
          ASN=FILE,
          NAME=FID_NAME,
          ACCT=FID_ACCT,
          PASS=FID_PASS);
%FPT_FID(FPTN=FPT_FID_PROJ,
         ACCT=FID_ACCT,
         ASN=FPT_OPN_PROJ.V.ASN#,
         NAME=FID_NAME,
         PASS=FID_PASS,
         RES=FPT_OPN_PROJ.V.RES#);
%FPT_READ(FPTN=FPT_RD_PROJ,
          DCB=MPROJ,
          BUF=PROJBUF);
 
 
/**/
/* Constant */
/**/
DCL INCRTBL(0:6) UBIN CONSTANT INIT(100,50,20,10,5,2,1);
DCL MOPSTR(0:2) BIT(9) CONSTANT INIT(%MVZB4,%SES10,%MVC1);
DCL 1 UC_XLATE_TBL CONSTANT ALIGNED,
      2 *(0:511) BIT(9) UNAL INIT(
        '000'O,'001'O,'002'O,'003'O,'004'O,'005'O,'006'O,'007'O,
        '010'O,'011'O,'012'O,'013'O,'014'O,'015'O,'016'O,'017'O,
        '020'O,'021'O,'022'O,'023'O,'024'O,'025'O,'026'O,'027'O,
        '030'O,'031'O,'032'O,'033'O,'034'O,'035'O,'036'O,'037'O,
        '040'O,'041'O,'042'O,'043'O,'044'O,'045'O,'046'O,'047'O,
        '050'O,'051'O,'052'O,'053'O,'054'O,'055'O,'056'O,'057'O,
        '060'O,'061'O,'062'O,'063'O,'064'O,'065'O,'066'O,'067'O,
        '070'O,'071'O,'072'O,'073'O,'074'O,'075'O,'076'O,'077'O,
        '100'O,'101'O,'102'O,'103'O,'104'O,'105'O,'106'O,'107'O,
        '110'O,'111'O,'112'O,'113'O,'114'O,'115'O,'116'O,'117'O,
        '120'O,'121'O,'122'O,'123'O,'124'O,'125'O,'126'O,'127'O,
        '130'O,'131'O,'132'O,'133'O,'134'O,'135'O,'136'O,'137'O,
        '140'O,'101'O,'102'O,'103'O,'104'O,'105'O,'106'O,'107'O,
        '110'O,'111'O,'112'O,'113'O,'114'O,'115'O,'116'O,'117'O,
        '120'O,'121'O,'122'O,'123'O,'124'O,'125'O,'126'O,'127'O,
        '130'O,'131'O,'132'O,'173'O,'174'O,'175'O,'176'O,'177'O,
        '200'O,'201'O,'202'O,'203'O,'204'O,'205'O,'206'O,'207'O,
        '210'O,'211'O,'212'O,'213'O,'214'O,'215'O,'216'O,'217'O,
        '220'O,'221'O,'222'O,'223'O,'224'O,'225'O,'226'O,'227'O,
        '230'O,'231'O,'232'O,'233'O,'234'O,'235'O,'236'O,'237'O,
        '240'O,'241'O,'242'O,'243'O,'244'O,'245'O,'246'O,'247'O,
        '250'O,'251'O,'252'O,'253'O,'254'O,'255'O,'256'O,'257'O,
        '260'O,'261'O,'262'O,'263'O,'264'O,'265'O,'266'O,'267'O,
        '270'O,'271'O,'272'O,'273'O,'274'O,'275'O,'276'O,'277'O,
        '300'O,'301'O,'302'O,'303'O,'304'O,'305'O,'306'O,'307'O,
        '310'O,'311'O,'312'O,'313'O,'314'O,'315'O,'316'O,'317'O,
        '320'O,'321'O,'322'O,'323'O,'324'O,'325'O,'326'O,'327'O,
        '330'O,'331'O,'332'O,'333'O,'334'O,'335'O,'336'O,'337'O,
        '340'O,'341'O,'342'O,'343'O,'344'O,'345'O,'346'O,'347'O,
        '350'O,'351'O,'352'O,'353'O,'354'O,'355'O,'356'O,'357'O,
        '360'O,'361'O,'362'O,'363'O,'364'O,'365'O,'366'O,'367'O,
        '370'O,'371'O,'372'O,'373'O,'374'O,'375'O,'376'O,'377'O,
        '400'O,'401'O,'402'O,'403'O,'404'O,'405'O,'406'O,'407'O,
        '410'O,'411'O,'412'O,'413'O,'414'O,'415'O,'416'O,'417'O,
        '420'O,'421'O,'422'O,'423'O,'424'O,'425'O,'426'O,'427'O,
        '430'O,'431'O,'432'O,'433'O,'434'O,'435'O,'436'O,'437'O,
        '440'O,'441'O,'442'O,'443'O,'444'O,'445'O,'446'O,'447'O,
        '450'O,'451'O,'452'O,'453'O,'454'O,'455'O,'456'O,'457'O,
        '460'O,'461'O,'462'O,'463'O,'464'O,'465'O,'466'O,'467'O,
        '470'O,'471'O,'472'O,'473'O,'474'O,'475'O,'476'O,'477'O,
        '500'O,'501'O,'502'O,'503'O,'504'O,'505'O,'506'O,'507'O,
        '510'O,'511'O,'512'O,'513'O,'514'O,'515'O,'516'O,'517'O,
        '520'O,'521'O,'522'O,'523'O,'524'O,'525'O,'526'O,'527'O,
        '530'O,'531'O,'532'O,'533'O,'534'O,'535'O,'536'O,'537'O,
        '540'O,'541'O,'542'O,'543'O,'544'O,'545'O,'546'O,'547'O,
        '550'O,'551'O,'552'O,'553'O,'554'O,'555'O,'556'O,'557'O,
        '560'O,'561'O,'562'O,'563'O,'564'O,'565'O,'566'O,'567'O,
        '570'O,'571'O,'572'O,'573'O,'574'O,'575'O,'576'O,'577'O,
        '600'O,'601'O,'602'O,'603'O,'604'O,'605'O,'606'O,'607'O,
        '610'O,'611'O,'612'O,'613'O,'614'O,'615'O,'616'O,'617'O,
        '620'O,'621'O,'622'O,'623'O,'624'O,'625'O,'626'O,'627'O,
        '630'O,'631'O,'632'O,'633'O,'634'O,'635'O,'636'O,'637'O,
        '640'O,'641'O,'642'O,'643'O,'644'O,'645'O,'646'O,'647'O,
        '650'O,'651'O,'652'O,'653'O,'654'O,'655'O,'656'O,'657'O,
        '660'O,'661'O,'662'O,'663'O,'664'O,'665'O,'666'O,'667'O,
        '670'O,'671'O,'672'O,'673'O,'674'O,'675'O,'676'O,'677'O,
        '700'O,'701'O,'702'O,'703'O,'704'O,'705'O,'706'O,'707'O,
        '710'O,'711'O,'712'O,'713'O,'714'O,'715'O,'716'O,'717'O,
        '720'O,'721'O,'722'O,'723'O,'724'O,'725'O,'726'O,'727'O,
        '730'O,'731'O,'732'O,'733'O,'734'O,'735'O,'736'O,'737'O,
        '740'O,'741'O,'742'O,'743'O,'744'O,'745'O,'746'O,'747'O,
        '750'O,'751'O,'752'O,'753'O,'754'O,'755'O,'756'O,'757'O,
        '760'O,'761'O,'762'O,'763'O,'764'O,'765'O,'766'O,'767'O,
        '770'O,'771'O,'772'O,'773'O,'774'O,'775'O,'776'O,'777'O);
 
 
/**/
/* Error messages */
/**/
DCL MSG_MISSING CHAR(0) CONSTANT
    INIT('  * Missing item on plus card:');
DCL MSG_PLUSBAD CHAR(0) CONSTANT
    INIT('*** Illegal plus-card format:');
DCL MSG_STARBAD CHAR(0) CONSTANT
    INIT(' ** Illegal star number:');
DCL MSG_NOFIRSTPLUS CHAR(0) CONSTANT
    INIT(' ** First record of file is not a plus-card record');
DCL MSG_SI CHAR(0) CONSTANT
    INIT('*** Error reading input file');
DCL MSG_STD CHAR(0) CONSTANT
    INIT('*** Error reading standard file');
DCL MSG_OPN_SI CHAR(0) CONSTANT
    INIT('*** Error opening input file');
DCL MSG_LIST_FID CHAR(0) CONSTANT
    INIT('*** Illegal LISTfile FID');
DCL MSG_STD_FID CHAR(0) CONSTANT
    INIT('*** Illegal STDfile FID');
DCL MSG_NOPLUS CHAR(0) CONSTANT
    INIT('  * Warning - no plus-card records in this file');
DCL MSG_LISTERR CHAR(0) CONSTANT
    INIT('  * Error reading list file');
DCL MSG_OPN_LIST CHAR(0) CONSTANT
    INIT('*** Error opening list file');
DCL MSG_OPN_STD CHAR(0) CONSTANT
    INIT('*** Error opening standard file');
DCL MSG_WRERR CHAR(0) CONSTANT
    INIT('*** Error writing file, file not created');
DCL MSG_MUSTREKEY CHAR(0) CONSTANT
    INIT('*** Source not keyed, must rekey to create a file');
DCL 1 MSG_BADKEY STATIC,
      2 * CHAR(0) INIT('  * Warning - source file key outside plus range: +'),
      2 V1 CHAR(5),
      2 V2 CHAR(6);
DCL MSG_MOREBADKEY CHAR(0) CONSTANT
    INIT('         Rest of update packet not printed');
DCL MSG_TOOMANYUPD CHAR(0) CONSTANT
    INIT('*** Too many updates to fit at ');
DCL MSG_EXTINT CHAR(0) CONSTANT
    INIT('  * Warning - updates extend beyond end of plus range');
DCL MSG_BADINERR CHAR(0) CONSTANT
    INIT('*** Unexpected input error - aborting');
DCL MSG_LIMIGNORE CHAR(0) CONSTANT
    INIT('  * Warning - LIMIT option ignored at ');
DCL MSG_PLUSEND CHAR(0) CONSTANT
    INIT('+END  KEYER supplied');
DCL 1 MSG_OVERLAP STATIC,
      2 * CHAR(0) INIT('*** Plus-card overlap with record at '),
      2 V1 CHAR(5),
      2 * CHAR(1) INIT('.'),
      2 V2 CHAR(3);
DCL MSG_SELNOTFND CHAR(0) CONSTANT
    INIT('  * The following SELECT items not found:');
DCL 1 MSG_INCRIGNORE STATIC,
      2 * CHAR(0) INIT('  * Warning - INCR ignored at '),
      2 V CHAR(5);
DCL MSG_PROJ_FID CHAR(0) CONSTANT
    INIT('*** Illegal project Fid');
DCL MSG_PROJ CHAR(0) CONSTANT
    INIT('*** Error reading project file');
DCL MSG_OPN_PROJ CHAR(0) CONSTANT
    INIT('*** Error opening project file');
 
 
/**/
/* Error code EQUs */
/**/
%EQU ERR_NOINIT=1;
/* Numbers 1-7 are reserved for validation errors */
%EQU ERR_NODATE=2;
%EQU ERR_NOSTAR=4;
/**/
%EQU ERR_PLUSBAD=8;
%EQU ERR_STARBAD=9;
%EQU ERR_BADKEY=10;
%EQU ERR_EXTINT=11;
%EQU ERR_TOOMANYUPD=12;
 
 
/**/
/* EQUs for VALIDATE and VALFLG */
/**/
%EQU VAL_DATE='4'O;
%EQU VAL_INIT='2'O;
%EQU VAL_STAR='1'O;
%EQU VAL_ALL='7'O;
 
        SRCHRFND='0'B;
        SRCHIFND='0'B;
        COMPFLG='0'B;
        FIXFLG='0'B;
        REKEYFLG='1'B;
        VALFLG=%VAL_INIT;
        LIMITFLG='0'B;
        LIST_FLG='0'B;
        STD_FLG='0'B;
        PLUS_ERR='0'B;
        VAL_ERR='0'B;
        SEL_FLG='0'B;
        SELNAKED='0'B;
        OUFLG='1'B;
        LIMCHK_FLG='1'B;
        MULT_FILE_FLG='0'B;
        ERRCNT=0;
        WARNCNT=0;
        FILECNT=0;
        SRCHIX=0;
        SRCHRX=0;
        INCR=0;
        THIS_ERR=-1;
        LAST_ERR=0;
        COMLEN=0;
        VAL_STAR#=0;
        ADD_INITIALS=SUBSTR(B$JIT.ACCN,0,3);
        M$SI$=DCBADDR(DCBNUM(M$SI));
        M$OUT$=DCBADDR(DCBNUM(M$OUT));
        MSTD$=DCBADDR(DCBNUM(MSTD));
        M$LIST$=DCBADDR(DCBNUM(M$LIST));
        MPROJ$=DCBADDR(DCBNUM(MPROJ));
/**/
        P_PCB.TEXT$=PINCRC(ADDR(B$JIT.CCBUF),B$JIT.CCDISP);
        P_PCB.NCHARS=B$JIT.CCARS-B$JIT.CCDISP;
        CALL X$PARSE(P_PCB) ALTRET(SYNTAX_ERR);
/**/
        DO I= 0 TO P_PCB.OUT$->OUT$BLK.NSUBLKS-1;
           PTR$=P_PCB.OUT$->OUT$BLK.SUBLK$(I);
           DO CASE(PTR$->OUT$BLK.CODE);
            CASE(%NOUOPT);
              OUFLG='0'B;
            CASE(%COMPOPT);
              COMPFLG='1'B;
            CASE(%STAROPT);
              ADD_STAR=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
              ADD_STAR_SIZE=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
              CALL M$TIME(FPT_TIME);
              FIXFLG='1'B;
            CASE(%INITOPT);
              ADD_INITIALS=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
            CASE(%NRKOPT);
              REKEYFLG='0'B;
            CASE(%NULLOPT);
            CASE(%NVOPT);
              VALFLG='0'B;
            CASE(%LIMITOPT);
              LIMITFLG='1'B;
            CASE(%NLIMCHKOPT);
              LIMCHK_FLG='0'B;
            CASE(%INCROPT);
              CALL CHARBIN(INCR,
                PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
              DO CASE(PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT);
               CASE(1);
                 INCR=INCR*100;
               CASE(2);
                 INCR=INCR*10;
               END;
            CASE(%COMOPT);
              COMTXT=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
              COMLEN=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
            CASE(%ENDOPT);
              IF PTR$->OUT$BLK.NSUBLKS=0 THEN
                 LAST_FILE='zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
              ELSE
                 LAST_FILE=PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
              MULT_FILE_FLG='1'B;
              FPT_OPN_IN.V.OPER.NXTF#='1'B;
              FPT_OPN_IN.V.OPER.THISF#='1'B;
            CASE(%LISTOPT);
              FPT_FID_LIST.TEXTFID_=VECTOR(PTR$->OUT$BLK.SUBLK$(0)->
                OUT$SYM.TEXT);
              CALL M$FID(FPT_FID_LIST) ALTRET(BAD_LIST_FID);
              CALL M$OPEN(FPT_OPN_LIST) ALTRET(OPN_LIST_ERR);
              LIST_FLG='1'B;
            CASE(%STDOPT);
              FPT_FID_STD.TEXTFID_=VECTOR(PTR$->OUT$BLK.SUBLK$(0)->
                OUT$SYM.TEXT);
              CALL M$FID(FPT_FID_STD) ALTRET(BAD_STD_FID);
              CALL M$OPEN(FPT_OPN_STD) ALTRET(OPN_STD_ERR);
              STD_FLG='1'B;
              MULT_FILE_FLG='1'B;
            CASE(%VALOPT);
              IF PTR$->OUT$BLK.NSUBLKS=0 THEN
                 VALFLG=%VAL_ALL;
              ELSE DO;
                 VALFLG='0'B;
                 DO J = 0 TO PTR$->OUT$BLK.NSUBLKS-1;
                    DO CASE(PTR$->OUT$BLK.SUBLK$(J)->OUT$BLK.CODE);
                     CASE(%VINIT);
                       VALFLG=VALFLG|%VAL_INIT;
                     CASE(%VSTAR);
                       VALFLG=VALFLG|%VAL_STAR;
                     CASE(%VDATE);
                       VALFLG=VALFLG|%VAL_DATE;
                     CASE(%VALL);
                       VALFLG=%VAL_ALL;
                     END;
                    END;
                 END;
            CASE(%SELOPT);
              DO J = 0 TO PTR$->OUT$BLK.NSUBLKS-1;
                 DO CASE(PTR$->OUT$BLK.SUBLK$(J)->OUT$BLK.CODE);
                  CASE(%INITIAL);
                    SRCHI.INITIAL(SRCHIX)=PTR$->OUT$BLK.SUBLK$(J)->
                      OUT$SYM.TEXT;
                    SRCHIX=SRCHIX+1;
                  CASE(%UPDATE);
                    CALL CHARBIN(SRCHR.L(SRCHRX),
                      PTR$->OUT$BLK.SUBLK$(J)->OUT$SYM.TEXT);
                    SRCHR.H(SRCHRX)=SRCHR.L(SRCHRX);
                    SRCHRX=SRCHRX+1;
                  CASE(%RANGE);
                    CALL CHARBIN(SRCHR.L(SRCHRX),
                      PTR$->OUT$BLK.SUBLK$(J)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
                    CALL CHARBIN(SRCHR.H(SRCHRX),
                      PTR$->OUT$BLK.SUBLK$(J)->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT);
                    SRCHRX=SRCHRX+1;
                  CASE(%NAKED);
                    SELNAKED='1'B;
                  END;
                 END;
              SEL_FLG='1'B;
            CASE(%TXTSTAROPT);
              DO J = 0 TO PTR$->OUT$BLK.NSUBLKS-1;
                 STR6=PTR$->OUT$BLK.SUBLK$(J)->OUT$SYM.TEXT;
                 K=PTR$->OUT$BLK.SUBLK$(J)->OUT$SYM.COUNT;
                 IF SUBSTR(STR6,K-1,1)='?' THEN DO;
                    K=K-1;
                    VAL_STAR.W(VAL_STAR#)='1'B;
                    END;
                 ELSE
                    VAL_STAR.W(VAL_STAR#)='0'B;
                 VAL_STAR.LEN(VAL_STAR#)=K;
                 VAL_STAR.TXT(VAL_STAR#)=STR6;
                 VAL_STAR#=VAL_STAR#+1;
                 END;
            CASE(%PROJOPT);
              FPT_FID_PROJ.TEXTFID_=VECTOR(PTR$->OUT$BLK.SUBLK$(0)
                ->OUT$SYM.TEXT);
              CALL M$FID(FPT_FID_PROJ) ALTRET(BAD_PROJ_FID);
              CALL M$OPEN(FPT_OPN_PROJ) ALTRET(OPN_PROJ_ERR);
              DO WHILE ('1'B);
                 CALL M$READ(FPT_RD_PROJ) ALTRET(PROJ_ERR);
                 K=MPROJ$->F$DCB.ARS#;
                 CALL INDEX1(J,' ',SUBSTR(PROJBUF,0,K));
                 CALL XLATE (VAL_STAR.TXT(VAL_STAR#),UC_XLATE_TBL,SUBSTR(PROJBUF,0,J));
                 VAL_STAR.LEN(VAL_STAR#)=J;
                 VAL_STAR#=VAL_STAR#+1;
                 END;                   /* DO WHILE                           */
PROJ_ERR:     ;
              IF B$TCB.ALT$->B$EXCFR.ERR.CODE~=%E$EOF THEN
              DO;
                 ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
                 CALL ERROR(MSG_PROJ,SIZEC(MSG_PROJ));
                 CALL PRINT_ERR_MSG(DCBNUM(MPROJ));
                 CALL M$XXX;
                 END;
            CASE(ELSE);
              CALL M$XXX;
            END;
           END;
/**/
        IF NOT STD_FLG THEN DO;
           FNAME=M$SI$->F$DCB.NAME#;
           CALL INDEX1(I,'?',FNAME.C);
           IF I<FNAME.L THEN DO;        /* Wild-carded name                   */
              FNAME.L=I;
              MULT_FILE_FLG='1'B;
              CALL M$OPEN(FPT_OPN_SET_IN);
              FPT_OPN_IN.V.OPER.NXTF#='1'B;
              FPT_OPN_IN.V.OPER.THISF#='1'B;
              LAST_FILE=FNAME.C;
              CALL INSERT(LAST_FILE,FNAME.L,,'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz');
              END;
           END;
        ELSE
           FPT_OPN_IN.V.OPER.NXTF# = '0'B;
/**/
/**/
FILE_LOOP: ;
        IF (B$JIT.PRFLAGS.OU OR NOT MULT_FILE_FLG) AND OUFLG THEN
           CREATE_FLG='1'B;
        ELSE
           CREATE_FLG='0'B;
        FPT_WR_OUT.BUF_=VECTOR(INBUF);
        FOUND_PLUS='0'B;
        FIRST_NOT_PLUS='0'B;
        HEADER_FLG='0'B;
        END_FLG='0'B;
        PLUS_ERR='0'B;
        BADKEYCNT=2;
        LAST_ERR=0;
        PLUSX=0;
        THIS_ERR=-1;
        R1=0;
        R2=0;
        RECCNT=0; PLUSCNT=0;
        IF STD_FLG THEN DO;
           CALL M$READ(FPT_RD_STD) ALTRET(STD_ERR);
           I=MSTD$->F$DCB.ARS#;
           CALL INDEX1(J,' ',SUBSTR(STDBUF,0,I));
           FNAME.C=SUBSTR(STDBUF,0,J);
           FNAME.L=J;
           CALL M$OPEN(FPT_OPN_SET_IN);
           END;
        CALL M$OPEN(FPT_OPN_IN) ALTRET(OPN_ERR);
        FPT_OPN_SET_OUT.NAME_=VECTOR(M$SI$->F$DCB.NAME#);
        IF MULT_FILE_FLG AND NOT STD_FLG THEN DO;
           IF M$SI$->F$DCB.NAME#.C>LAST_FILE THEN
              GOTO DONE;
           END;
        ELSE
           IF M$OUT$->F$DCB.NAME#.L~=0 AND M$OUT$->F$DCB.NAME#.C~='*G' AND NOT STD_FLG THEN
              FPT_OPN_SET_OUT.NAME_=VECTOR(NIL);
        CALL M$OPEN(FPT_OPN_SET_OUT);
        FILECNT=FILECNT+1;
/**/
/**/
NXTREC: ;
        IF END_FLG THEN
           GOTO END_FILE;
        CALL GETREC ALTRET(END_FILE);
        RECCNT=RECCNT+1;
/**/
        IF NOT PLUSFLG THEN DO;
           IF NOT FOUND_PLUS THEN DO;
              FIRST_NOT_PLUS='1'B;
              BADKEYCNT=-1;
              END;
           GOTO NOT_PLUS;
           END;
        ELSE DO;
           FOUND_PLUS='1'B;
           PLUSCNT=PLUSCNT+1;
           IF SUBSTR(INBUF,1,1)='*' THEN
              GOTO NOT_PLUS;
           END;
/**/
        CALL DECODE(R1,R2);
/**/
VAL_PLUS :
        CALL VALIDATE(R1,R2);
        CALL VAL_DATA(R1,R2,VALFLG);
        IF BADKEYCNT~=2 THEN DO;
           LAST_ERR=0;
           BADKEYCNT=2;
           END;
/**/
NOT_PLUS: ;
        IF IKEY.CNT~=3 AND CREATE_FLG AND NOT REKEYFLG THEN DO;
           CREATE_FLG='0'B;
           THIS_ERR=-1;
           CALL ERROR(MSG_MUSTREKEY,SIZEC(MSG_MUSTREKEY));
           GOTO NXTREC;
           END;
/**/
        CALL VALKEY(R1,R2);
/**/
/**/
        IF NOT CREATE_FLG OR PLUS_ERR THEN
           GOTO NXTREC;
        IF NOT REKEYFLG OR NOT SELECT_FLAG THEN DO;
           OKEY.VAL=IKEY.VAL;
           FPT_WR_OUT.BUF_.BOUND=INSIZE-1;
           CALL M$WRITE(FPT_WR_OUT) ALTRET(WR_ERR);
           GOTO NXTREC;
           END;
        IKEYSAVE=IKEY;
        R1SAVE=R1;
        R2SAVE=R2;
        R1=100000;
        R2=-1;
        CNT=1;
        INBUFSAV=INBUF;
        INSIZESAV=INSIZE;
        FPT_PREC.V.N#=-1;
/**/
NOT_PLUS_LOOP: ;
        IF END_FLG THEN
           GOTO END_SRC;
        CALL GETREC ALTRET(END_SRC);
        FPT_PREC.V.N#=FPT_PREC.V.N#-1;
        RECCNT=RECCNT+1;
        IF NOT PLUSFLG THEN DO;
           CNT=CNT+1;
           CALL VALKEY(R1SAVE,R2SAVE);
           GOTO NOT_PLUS_LOOP;
           END;
        PLUSCNT=PLUSCNT+1;
/**/
        CALL DECODE(R1,R2);
/**/
END_SRC: ;
        IF CNT>1 THEN DO;
           LIMFLG=LIMITFLG;
           LIMIGNOREFLG='0'B;
SQZ:       ;
           IF R2SAVE<0 OR LIMFLG THEN DO;
              I=1000;                   /* Size of interval                   */
              J=R1SAVE;
              END;
           ELSE DO;
              IF R1=R2SAVE AND R2SAVE>R1SAVE THEN
                 K=R2SAVE-1;
              ELSE
                 K=R2SAVE;
              I=(K-R1SAVE+1)*1000;
              J=K;
              END;
           SQZ_FLG='0'B;
SQZ_UPD:   ;
           I=I/CNT;                     /* Maximum interval                   */
           K=0;
           DO WHILE(K<SIZEW(INCRTBL));
              IF I>=INCRTBL(K) THEN DO;
                 IF I>INCRTBL(K) THEN
                    I=INCRTBL(K);
                 K=SIZEW(INCRTBL);
                 END;
              ELSE
                 K=K+1;
              END;
           IF INCR~=0 THEN
              IF I>INCR THEN
                 I=INCR;
              ELSE
                 IF I<INCR THEN DO;
                    CALL BINCHAR(MSG_INCRIGNORE.V,R1SAVE);
                    THIS_ERR=-1;
                    CALL WARN(MSG_INCRIGNORE,SIZEC(MSG_INCRIGNORE));
                    END;
           IF I=0 THEN DO;              /* Won't fit                          */
              IF LIMFLG THEN DO;
                 LIMFLG='0'B;           /* Try again without limit            */
                 LIMIGNOREFLG='1'B;
                 GOTO SQZ;
                 END;
              J=J+1;                    /* Try to expand interval             */
              SQZ_FLG='1'B;
              IF J>=R1 THEN DO;
                 EBUFC=MSG_TOOMANYUPD;
                 CALL BINCHAR(STR5,R1SAVE);
                 CALL INSERT(EBUFC,SIZEC(MSG_TOOMANYUPD),,STR5);
                 THIS_ERR=%ERR_TOOMANYUPD;
                 CALL ERROR(EBUFC,SIZEC(MSG_TOOMANYUPD)+5);
                 CREATE_FLG='0'B;
                 GOTO NOT_PLUS;
                 END;
              I=(J-R1SAVE+1)*1000;
              GOTO SQZ_UPD;
              END;
           IF SQZ_FLG THEN DO;
              THIS_ERR=%ERR_EXTINT;
              CALL BINCHAR(STR5,R1SAVE);
              EBUFC=MSG_EXTINT;
              CALL INSERT(EBUFC,SIZEC(MSG_EXTINT),,STR5);
              CALL WARN(EBUFC,SIZEC(MSG_EXTINT)+5);
              END;
           IF LIMIGNOREFLG THEN DO;
              THIS_ERR=-1;
              CALL BINCHAR(STR5,R1SAVE);
              EBUFC=MSG_LIMIGNORE;
              CALL INSERT(EBUFC,SIZEC(MSG_LIMIGNORE),,STR5);
              CALL WARN(EBUFC,SIZEC(MSG_LIMIGNORE)+5);
              END;
           END;
        ELSE
           I=0;
/**/
        IF R1SAVE<100000 THEN
           OKEY.VAL=R1SAVE*1000;
        ELSE
           OKEY.VAL=99998000;
        CALL M$PRECORD(FPT_PREC) ALTRET(BAD_IN_ERR);
        TCNT=CNT;
        DO WHILE(CNT>0);
           CALL GETREC ALTRET(BAD_IN_ERR);
           IF CNT=TCNT THEN DO;
              INBUF=INBUFSAV;
              INSIZE=INSIZESAV;
              END;
           FPT_WR_OUT.BUF_.BOUND=INSIZE-1;
           CALL M$WRITE(FPT_WR_OUT) ALTRET(WR_ERR);
           OKEY.VAL=OKEY.VAL+I;
           CNT=CNT-1;
           END;
        IF END_FLG THEN
           GOTO END_FILE;
        CALL GETREC ALTRET(END_FILE);
        GOTO VAL_PLUS;
/**/
END_FILE: ;
        IF CREATE_FLG AND NOT END_FLG THEN DO;
           FPT_WR_OUT.BUF_=VECTOR(MSG_PLUSEND);
           OKEY.VAL=99998000;
           CALL M$WRITE(FPT_WR_OUT) ALTRET(WR_ERR);
           END;
        CALL M$CLOSE(FPT_CLS_SI);
        IF NOT CREATE_FLG OR PLUS_ERR THEN
           CALL M$CLOSE(FPT_CLS_OUT_REL);
        ELSE
           CALL M$CLOSE(FPT_CLS_OUT);
        THIS_ERR=-1;
        IF FIRST_NOT_PLUS THEN
           IF FOUND_PLUS THEN DO;
              CALL ERROR(MSG_NOFIRSTPLUS,SIZEC(MSG_NOFIRSTPLUS));
              END;
           ELSE
              CALL WARN(MSG_NOPLUS,SIZEC(MSG_NOPLUS));
END_FILE_5:
        IF MULT_FILE_FLG THEN DO;
           FPT_OPN_IN.V.OPER.THISF#='0'B;
           GOTO FILE_LOOP;
           END;
/**/
        CALL BINCHAR(STR5,RECCNT);
        CALL EDITSTR(STATMSG.RECS,,,MOPSTR,STR5);
        CALL BINCHAR(STR5,PLUSCNT);
        CALL EDITSTR(STATMSG.PLUS,,,MOPSTR,STR5);
        CALL PRNT(STATMSG,SIZEC(STATMSG));
/**/
DONE:   ;
        THIS_ERR=-1;
        HEADER_FLG='0'B;
        IF SRCHIX~=0 THEN
        DO I=0 TO SRCHIX-1;
           IF NOT SRCHIFND(I) THEN DO;
              IF NOT HEADER_FLG THEN DO;
                 HEADER_FLG='1'B;
                 CALL WARN(MSG_SELNOTFND,SIZEC(MSG_SELNOTFND));
                 END;
              CALL WARN(SRCHI.INITIAL(I),SIZEC(SRCHI.INITIAL(0)));
              END;
           END;
        IF SRCHRX~=0 THEN
        DO I=0 TO SRCHRX-1;
           IF NOT SRCHRFND(I) THEN DO;
              IF NOT HEADER_FLG THEN DO;
                 HEADER_FLG='1'B;
                 CALL WARN(MSG_SELNOTFND,SIZEC(MSG_SELNOTFND));
                 END;
              CALL BINCHAR(STR5,SRCHR.L(I));
              CALL WARN(STR5,SIZEC(STR5));
              END;
           END;
        IF MULT_FILE_FLG THEN DO;
           CALL BINCHAR(STR5,FILECNT);
           CALL EDITSTR(FILEMSG.CNT,,,MOPSTR,STR5);
           CALL PRNT(FILEMSG,SIZEC(FILEMSG));
           END;
        IF ERRCNT~=0 OR WARNCNT~=0 THEN DO;
           CALL PRNT(' ',1);
           CALL BINCHAR(STR5,ERRCNT);
           CALL EDITSTR(EMSG.CNT,,,MOPSTR,STR5);
           CALL BINCHAR(STR5,WARNCNT);
           CALL EDITSTR(EMSG.WARN,,,MOPSTR,STR5);
           CALL PRNT(EMSG,SIZEC(EMSG));
           END;
        CALL M$EXIT;
/**/
OPN_ERR: ;
        IF B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$FDEOF THEN
           GOTO DONE;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        THIS_ERR=-1;
        CALL ERROR(MSG_OPN_SI,SIZEC(MSG_OPN_SI));
        CALL PRINT_ERR_MSG(DCBNUM(M$SI));
        IF (ERRCODE.CODE=%E$FILEBUSY OR ERRCODE.CODE=%E$NOACCESS OR
          ERRCODE.CODE=%E$NOFILE) AND MULT_FILE_FLG THEN
           GOTO END_FILE_5;
        CALL M$XXX;
/**/
STD_ERR: ;
        IF B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$EOF THEN
           GOTO DONE;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(DCBNUM(MSTD));
        CALL PRNT(MSG_STD,SIZEC(MSG_STD));
        CALL M$XXX;
/**/
BAD_LIST_FID: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(0);
        CALL PRNT(MSG_LIST_FID,SIZEC(MSG_LIST_FID));
        CALL M$XXX;
/**/
BAD_STD_FID: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(0);
        CALL PRNT(MSG_STD_FID,SIZEC(MSG_STD_FID));
        CALL M$XXX;
/**/
OPN_LIST_ERR: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(DCBNUM(M$LIST));
        CALL PRNT(MSG_OPN_LIST,SIZEC(MSG_OPN_LIST));
        CALL M$XXX;
/**/
OPN_STD_ERR: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(DCBNUM(MSTD));
        THIS_ERR=-1;
        CALL PRNT(MSG_OPN_STD,SIZEC(MSG_OPN_STD));
        CALL M$XXX;
/**/
WR_ERR: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        THIS_ERR=-1;
        CALL ERROR(MSG_WRERR,SIZEC(MSG_WRERR));
        CALL PRINT_ERR_MSG(DCBNUM(M$OUT));
        CREATE_FLG='0'B;
        GOTO END_FILE;
/**/
BAD_IN_ERR: ;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        THIS_ERR=-1;
        CALL ERROR(MSG_BADINERR,SIZEC(MSG_BADINERR));
        CALL PRINT_ERR_MSG(DCBNUM(M$SI));
        CALL M$XXX;
/**/
SYNTAX_ERR: ;
        EBUFC=' ';
        I=P_PCB.HI_CHAR+B$JIT.CCDISP;
        CALL INSERT(EBUFC,I,1,'^');
        CALL PRNT(EBUFC,I+1);
        ERRCODE=P_PCB.ERROR;
        CALL PRINT_ERR_MSG(0);
        CALL M$XXX;
BAD_PROJ_FID:;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(0);
        CALL PRNT(MSG_PROJ_FID,SIZEC(MSG_PROJ_FID));
        CALL M$XXX;
OPN_PROJ_ERR:;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(DCBNUM(MPROJ));
        CALL PRNT(MSG_OPN_PROJ,SIZEC(MSG_OPN_PROJ));
        CALL M$XXX;
%EJECT;
/**/
/* VALKEY - Validate that key of input record is OK */
/**/
VALKEY: PROC(R1,R2);
/**/
DCL R1 SBIN;
DCL R2 SBIN;
 
 
        IF IKEY.CNT~=3 THEN
           RETURN;
        I=IKEY.VAL/1000;
        IF (I<R1 OR (R2>=0 AND I>R2) OR (R2<0 AND I>R1)) AND
          BADKEYCNT>=0 AND NOT END_FLG AND LIMCHK_FLG THEN DO;
           IF BADKEYCNT>0 THEN DO;
              THIS_ERR=%ERR_BADKEY;
              CALL BINCHAR(MSG_BADKEY.V1,R1);
              IF R2<0 THEN
                 MSG_BADKEY.V2=' ';
              ELSE DO;
                 CALL BINCHAR(STR5,R2);
                 CALL CONCAT(MSG_BADKEY.V2,',',STR5);
                 END;
              CALL WARN(MSG_BADKEY,SIZEC(MSG_BADKEY));
              CALL DISPLINE;
              END;
           ELSE DO;
              THIS_ERR=-1;
              CALL ERROR(MSG_MOREBADKEY,SIZEC(MSG_MOREBADKEY));
              END;
           BADKEYCNT=BADKEYCNT-1;
           END;
        RETURN;
/**/
END VALKEY;
%EJECT;
/**/
/* Get next record */
/**/
GETREC: PROC ALTRET;
/**/
        CALL M$READ(FPT_READ) ALTRET(RD_ERR);
        INSIZE=DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#;
        IF INSIZE>0 AND SUBSTR(INBUF,0,1)='+' THEN
           PLUSFLG='1'B;
        ELSE
           PLUSFLG='0'B;
        RETURN;
/**/
RD_ERR: ;
        IF B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$EOF THEN
           ALTRETURN;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        THIS_ERR=-1;
        CALL ERROR(MSG_SI,SIZEC(MSG_SI));
        CALL PRINT_ERR_MSG(DCBNUM(M$SI));
        ALTRETURN;
/**/
END GETREC;
%EJECT;
/**/
/* DECODE - Validate syntax of plus card */
/**/
DECODE: PROC(R1,R2);
/**/
/* Parameters */
/**/
DCL R1 SBIN;
DCL R2 SBIN;
 
 
/**/
/* Local auto */
/**/
DCL I UBIN;
DCL J UBIN;
DCL K UBIN;
 
 
        IF INSIZE<2 THEN
           GOTO PLUS_BAD;
        CALL INDEX1(I,' ',SUBSTR(INBUF,1,INSIZE-1));
        IF I=0 THEN
           GOTO PLUS_BAD;
        CALL INDEX1(J,',',SUBSTR(INBUF,1,I));
        IF J<I THEN DO;
           IF I-J-1<=0 THEN
              GOTO PLUS_BAD;
           DO K=J+2 TO I;
              IF SUBSTR(INBUF,K,1)<'0' OR SUBSTR(INBUF,K,1)>'9' THEN
                 GOTO PLUS_BAD;
              END;
           CALL CHARBIN(R2,SUBSTR(INBUF,J+2,I-J-1));
           END;
        ELSE DO;
           IF SUBSTR(INBUF,1,J)='END' THEN DO;
              R1=99998; R2=-1;
              RETURN;
              END;
           R2=-1;
           END;
        DO K=1 TO J;
           IF SUBSTR(INBUF,K,1)<'0' OR SUBSTR(INBUF,K,1)>'9' THEN
              GOTO PLUS_BAD;
           END;
        CALL CHARBIN(R1,SUBSTR(INBUF,1,J));
        IF R2>=0 AND R2<R1 THEN
           GOTO PLUS_BAD;
/**/
        RETURN;
/**/
PLUS_BAD: ;
        THIS_ERR=%ERR_PLUSBAD;
        CALL ERROR(MSG_PLUSBAD,SIZEC(MSG_PLUSBAD));
        CALL DISPLINE;
        PLUS_ERR='1'B;
        RETURN;
/**/
END DECODE;
/**/
%EJECT;
/**/
/* Validate data on plus card */
/**/
VAL_DATA: PROC(R1,R2,VALIDATE);
/**/
DCL R1 SBIN;
DCL R2 SBIN;
DCL VALIDATE BIT(36) ALIGNED;
/**/
/**/
/* Local auto */
/**/
DCL I UBIN;
DCL J UBIN;
DCL K UBIN;
DCL L UBIN;
DCL CHR CHAR(1);
DCL DATE BIT(1) ALIGNED;
DCL STAR BIT(1) ALIGNED;
DCL INITIALS BIT(1) ALIGNED;
DCL COMMENT BIT(1) ALIGNED;
DCL TMP_ERR UBIN;
 
 
        SELECT_FLAG=(SEL_FLG='0'B);
        IF R1>99997 THEN DO;
           END_FLG='1'B;
           RETURN;
           END;
        IF SRCHRX~=0 THEN
        DO K=0 TO SRCHRX-1;
           IF R1>=SRCHR.L(K) AND R1<=SRCHR.H(K) THEN DO;
              SELECT_FLAG='1'B;
              SRCHRFND(K)='1'B;
              GOTO DEC2;
              END;
           END;
/**/
DEC2:
        DATE='0'B;
        INITIALS='0'B;
        STAR='0'B;
        COMMENT='0'B;
        CALL INDEX1(I,' ',SUBSTR(INBUF,0,INSIZE));
        I=I+1;                          /* Point past blank                   */
/**/
LOOP:   ;
        DO WHILE(I<INSIZE);
           IF SUBSTR(INBUF,I,1)~=' ' THEN
              GOTO GOTONE;
           I=I+1;
           END;
/**/
DONE:   ;
        TMP_ERR=THIS_ERR;
        THIS_ERR=0;
        IF (DATE&INITIALS&STAR)='0'B THEN DO;
           IF (DATE|INITIALS|STAR)='0'B AND SELNAKED THEN
              SELECT_FLAG='1'B;
           IF NOT SELECT_FLAG THEN
              RETURN;
           EBUFC=MSG_MISSING;
           I=SIZEC(MSG_MISSING);
           IF FIXFLG THEN
              CALL INSERT(INBUF,INSIZE,,' ');
           IF NOT INITIALS THEN DO;
              IF NOT FIXFLG AND VALIDATE&%VAL_INIT THEN DO;
                 CALL INSERT(EBUFC,I,10,'  Initials');
                 I=I+10;
                 THIS_ERR=THIS_ERR+%ERR_NOINIT;
                 END;
              ELSE
                 IF FIXFLG THEN DO;
                    IF INSIZE<13 THEN
                       J=13;
                    ELSE
                       J=INSIZE+1;
                    CALL INSERT(INBUF,J,4,ADD_INITIALS);
                    INSIZE=J+4;
                    END;
              END;
           IF NOT DATE THEN DO;
              IF NOT FIXFLG AND VALIDATE&%VAL_DATE THEN DO;
                 CALL INSERT(EBUFC,I,6,'  Date');
                 I=I+6;
                 THIS_ERR=THIS_ERR+%ERR_NODATE;
                 END;
              ELSE
                 IF FIXFLG THEN DO;
                    IF INSIZE<18 THEN
                       J=18;
                    ELSE
                       J=INSIZE+1;
                    CALL INSERT(INBUF,J,8,CUR_DATE);
                    INSIZE=J+8;
                    END;
              END;
           IF NOT STAR THEN DO;
              IF NOT FIXFLG AND VALIDATE&%VAL_STAR THEN DO;
                 CALL INSERT(EBUFC,I,8,'  Star #');
                 I=I+8;
                 THIS_ERR=THIS_ERR+%ERR_NOSTAR;
                 END;
              ELSE
                 IF FIXFLG THEN DO;
                    IF INSIZE<27 THEN
                       J=27;
                    ELSE
                       J=INSIZE+1;
                    CALL INSERT(INBUF,J,1+ADD_STAR_SIZE,'#',ADD_STAR);
                    INSIZE=J+1+ADD_STAR_SIZE;
                    END;
              END;
           END;
        IF NOT COMMENT AND COMLEN~=0 AND SELECT_FLAG THEN DO;
           CALL INSERT(INBUF,INSIZE,COMLEN+4,'  "',
             SUBSTR(COMTXT,0,COMLEN),'"');
           INSIZE=INSIZE+COMLEN+4;
           END;
        IF THIS_ERR~=0 THEN DO;
           CALL WARN(EBUFC,I);
           CALL DISPLINE;
           VAL_ERR='1'B;
           END;
        ELSE
           THIS_ERR=TMP_ERR;
        RETURN;
/**/
GOTONE: ;
        J=I;
        CALL INDEX1(I,' ',SUBSTR(INBUF,J,INSIZE-J));
        CALL INDEX1(K,',',SUBSTR(INBUF,J,INSIZE-J));
        IF K<I THEN
           I=K;
        I=I+J;
        IF SUBSTR(INBUF,J,1)='#' THEN DO; /* STAR                             */
GOTSTAR:   ;
           K=J+1;
NXTSTARCHAR: ;
           J=J+1;
           IF J>=INSIZE THEN
              CHR=' ';
           ELSE
              CHR=SUBSTR(INBUF,J,1);
           IF CHR='?' OR J-K>6 THEN
              GOTO BADSTAR;
           IF CHR='#' OR CHR=' ' OR CHR=',' THEN DO;
              IF J=K THEN
                 GOTO BADSTAR;
              IF SUBSTR(INBUF,K,1)<'0' OR SUBSTR(INBUF,K,1)>'9' THEN DO;
                 IF VAL_STAR#~=0 THEN
                 DO L=0 TO VAL_STAR#-1;
                    IF J-K>=VAL_STAR.LEN(L) THEN
                    DO;
                       CALL XLATE (SUBSTR(PROJBUF,0,VAL_STAR.LEN(L)),UC_XLATE_TBL,SUBSTR(INBUF,K,VAL_STAR.LEN(L)));
                       IF SUBSTR(PROJBUF,0,VAL_STAR.LEN(L)) =
                         SUBSTR(VAL_STAR.TXT(L),0,VAL_STAR.LEN(L)) THEN
                          IF VAL_STAR.LEN(L)=J-K OR VAL_STAR.W(L) THEN
                             GOTO VALEND;
                       END;
                    END;
                 GOTO BADSTAR;
                 END;
VALEND:       IF CHR=' ' THEN
                 GOTO STARDONE;
              ELSE
                 GOTO GOTSTAR;
              END;
           GOTO NXTSTARCHAR;
BADSTAR:   ;
           IF NOT VALIDATE&%VAL_STAR THEN
              GOTO NXTFIELD;
           THIS_ERR=%ERR_STARBAD;
           CALL ERROR(MSG_STARBAD,SIZEC(MSG_STARBAD));
           CALL DISPLINE;
           VAL_ERR='1'B;
           RETURN;
STARDONE:  ;
           IF J=K THEN
              GOTO BADSTAR;
           I=J;
           STAR='1'B;
           GOTO NXTFIELD;
           END;
/**/
        IF SUBSTR(INBUF,J,1)='"' THEN DO;
           CALL INDEX1(I,'"',SUBSTR(INBUF,J,INSIZE-J));
           I=I+J;
           COMMENT='1'B;
           GOTO NXTFIELD;
           END;
/**/
        DO WHILE(J<I);
           CHR=SUBSTR(INBUF,J,1);
           IF CHR~='/' AND CHR~='-' AND
             (CHR<'0' OR CHR>'9') THEN
              GOTO NOT_DATE;
           J=J+1;
           END;
        DATE='1'B;
        GOTO NXTFIELD;
/**/
NOT_DATE:
        DO K=J TO I-1;
           IF SUBSTR(INBUF,K,1)='/' THEN
              GOTO GOTINITL;
           IF SUBSTR(INBUF,K,1)<'A' OR SUBSTR(INBUF,K,1)>'z' THEN
              GOTO NXTFIELD;            /* Not initials                       */
           END;
        K=I;
GOTINITL:
        IF K-J>4 OR K-J<2 THEN
           GOTO NXTFIELD;
        INITIALS='1'B;
        IF SRCHIX~=0 AND NOT SELECT_FLAG THEN
        DO L=0 TO SRCHIX-1;
           IF SRCHI.INITIAL(L)=SUBSTR(INBUF,J,K-J) THEN DO;
              SELECT_FLAG='1'B;
              SRCHIFND(L)='1'B;
              END;
           END;
        IF K<I THEN DO;
           J=K+1;
           GOTO NOT_DATE;
           END;
/**/
NXTFIELD: ;
        I=I+1;
        GOTO LOOP;
END VAL_DATA;
%EJECT;
/**/
/* VALIDATE - Make sure that plus card range doesn't overlap */
/**/
VALIDATE: PROC(R1,TR2);
/**/
DCL R1 SBIN;
DCL TR2 SBIN;
/**/
DCL R2 SBIN;
DCL I UBIN;
DCL J UBIN;
/**/
        IF TR2<0 THEN
           R2=R1;
        ELSE
           R2=TR2;
/**/
        IF PLUSX=0 THEN
           GOTO ADD_END;
        IF R1>=PLUS.R2(PLUSX-1) AND R1>PLUS.R1(PLUSX-1) THEN DO;
ADD_END:   PLUS.R1(PLUSX)=R1;
           PLUS.R2(PLUSX)=R2;
           PLUS.VAL(PLUSX)=IKEY.VAL;
           PLUSX=PLUSX+1;
           RETURN;
           END;
/**/
        DO I=0 TO PLUSX-1;
           IF R1>=PLUS.R1(I) THEN
              IF R1<PLUS.R2(I) OR (R1=PLUS.R2(I) AND
                (R1=PLUS.R1(I) OR TR2>=0)) THEN
                 GOTO PLUS_BAD;
              ELSE;
           ELSE DO;
              IF R2>=PLUS.R1(I) THEN
                 GOTO PLUS_BAD;
              J=PLUSX;
              DO WHILE(J>I);
                 PLUS(J)=PLUS(J-1);
                 J=J-1;
                 END;
              PLUS.R1(I)=R1;
              PLUS.R2(I)=R2;
              PLUS.VAL(I)=IKEY.VAL;
              PLUSX=PLUSX+1;
              RETURN;
              END;
           END;
        CALL M$XXX;
/**/
PLUS_BAD:
        THIS_ERR=-1;
        CALL BINCHAR(MSG_OVERLAP.V1,PLUS.VAL(I)/1000);
        CALL BINCHAR(MSG_OVERLAP.V2,PLUS.VAL(I)-((PLUS.VAL(I)/1000)*1000));
        CALL ERROR(MSG_OVERLAP,SIZEC(MSG_OVERLAP));
        CALL DISPLINE;
        CREATE_FLG='0'B;
        PLUS_ERR='1'B;
        RETURN;
/**/
END VALIDATE;
%EJECT;
/**/
/* ERROR - Print an error message */
/**/
ERROR:  PROC(MSG,SIZ);
/**/
DCL MSG CHAR(4);
DCL SIZ UBIN;
/**/
DCL EBUF CHAR(80) STATIC;
DCL LAST_OWNER CHAR(20) STATIC INIT(' ');
/**/
        ERRCNT=ERRCNT+1;
        GOTO COMMON;
/**/
WARN:   ENTRY(MSG,SIZ);
/**/
        WARNCNT=WARNCNT+1;
/**/
COMMON:
        IF THIS_ERR=LAST_ERR THEN
           RETURN;
        IF MULT_FILE_FLG AND NOT HEADER_FLG THEN DO;
           I=M$SI$->F$DCB.NAME#.L;
           EBUF=M$SI$->F$DCB.NAME#.C;
           CALL INSERT(EBUF,I,,'.',M$SI$->F$DCB.ACCT#);
           IF LIST_FLG THEN DO;
              LISTKEY.C=SUBSTR(EBUF,0,I);
              CALL M$READ(FPT_RD_LIST) ALTRET(RD_ERR);
              J=M$LIST$->F$DCB.ARS#;
              CALL INDEX1(K,' ',SUBSTR(LISTBUF,0,J));
              K=K+1;
              DO WHILE(K<J AND SUBSTR(LISTBUF,K,1)=' ');
                 K=K+1;
                 END;
              J=J-1;
              DO WHILE(J>=K AND SUBSTR(LISTBUF,J,1)=' ');
                 J=J-1;
                 END;
              IF J>=K THEN DO;
                 J=J-K+1;
                 CALL INSERT(EBUF,40,,SUBSTR(LISTBUF,K,J));
                 END;
              ELSE DO;
                 CALL INSERT(EBUF,40,,'** No owner **');
                 J=14;
                 END;
END_LIST:
              IF SUBSTR(EBUF,40,20)=LAST_OWNER THEN
                 CALL PRNT(' ',1);
              ELSE DO;
                 CALL M$DEVICE(FPT_DEVICE);
                 LAST_OWNER=SUBSTR(EBUF,40,20);
                 END;
              I=40+J;
              END;
HEADER_DONE: ;
           CALL PRNT(EBUF,I);
           HEADER_FLG='1'B;
           END;
        CALL PRNT(MSG,SIZ);
        LAST_ERR=THIS_ERR;
        IF LAST_ERR=-1 THEN
           LAST_ERR=0;
        THIS_ERR=-1;
        RETURN;
/**/
RD_ERR: ;
        IF B$TCB.ALT$->B$EXCFR.ERR.CODE=%E$NOKEY THEN DO;
           CALL INSERT(EBUF,40,,'** No LISTfile record **');
           J=24;
           GOTO END_LIST;
           END;
        ERRCODE=B$TCB.ALT$->B$EXCFR.ERR;
        CALL PRINT_ERR_MSG(DCBNUM(M$LIST));
        CALL PRNT(MSG_LISTERR,SIZEC(MSG_LISTERR));
        GOTO HEADER_DONE;
END ERROR;
/**/
/**/
PRNT:   PROC(MSG,SIZ);
/**/
DCL MSG CHAR(4);
DCL SIZ UBIN;
/**/
        FPT_WR_LO.BUF_.BUF$=ADDR(MSG);
        FPT_WR_LO.BUF_.BOUND=SIZ-1;
        CALL M$WRITE(FPT_WR_LO);
/**/
SAME:   ;
        RETURN;
END PRNT;
%EJECT;
/**/
/* DISPLINE - Display last input line */
/**/
DISPLINE: PROC;
/**/
DCL RECNUM UBIN;
/**/
        IF INSIZE~=0 THEN DO;
           ELINE.BUF=INBUF;
           IF IKEY.CNT=0 THEN DO;
              RECNUM=IKEY.VAL;
              ELINE.PT=' ';
              ELINE.FRACT=' ';
              END;
           ELSE DO;
              RECNUM=IKEY.VAL/1000;
              ELINE.PT='.';
              CALL BINCHAR(ELINE.FRACT,IKEY.VAL-(RECNUM*1000));
              END;
           CALL BINCHAR(STR5,RECNUM);
           CALL EDITSTR(ELINE.INTEGER,,,MOPSTR,STR5);
           CALL PRNT(ELINE,INSIZE+14);
           END;
        RETURN;
END DISPLINE;
%EJECT;
/**/
/* PRINT_ERR_MSG - Prints last error message received */
/**/
PRINT_ERR_MSG: PROC(DCB#);
/**/
DCL DCB# UBIN;
/**/
        FPT_ERRMSG.V.DCB#=DCB#;
        CALL M$CORRES(FPT_CORRES) ALTRET(SAME);
        FPT_ERRMSG.V.OUTDCB2#=DCBNUM(M$LO);
SAME:   ;
        CALL M$ERRMSG(FPT_ERRMSG);
        RETURN;
END PRINT_ERR_MSG;
END KEYER;
