/*M* FILER_SI4 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,IND=3 */
/*********************************************************************/
/*
***   EV_GET_VALUE   24 AUG 77   (PRY)   CONVERTS VALUE TO DESCRIPTOR
***   AND ASSOCIATED BLOCK.
*/
 
EV_GET_VALUE: PROC( VAL_DESC$#, VAL_BLK_IX# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/***   DEALLOCATE A DESCRIPTOR AND ASSOCIATED BLOCK   ***/
DCL   UT_DEALLOC_BUF         ENTRY(1);
 
/***   SPLIT OFF UNUSED AREA FROM A USED BLOCK   ***/
DCL   AM_SPLIT_BLK           ENTRY(2);
 
/***   ALLOCATE A BLOCK OF BLOCK SPACE   ***/
DCL   AM_ALLOC_BLK           ENTRY(3);
 
/***   DEALLOCATE A BLOCK   ***/
DCL   AM_DEALLOC_BLK         ENTRY(1);
 
/***   GET A VALUE DESCRIPTOR   ***/
DCL   EV_GET_VALUE_DESC      ENTRY(1);
 
/***   CONVERT DECIMAL STRING TO 36 BIT VALUE   ***/
DCL   EV_DECIMAL             ENTRY;
 
/***   CONVERT BASED STRING TO N BIT VALUE   ***/
DCL   EV_BASED               ENTRY(2);
 
/***   CONVERT TEXT STRING TO N BIT VALUE   ***/
DCL   EV_TEXT                ENTRY;
 
/***   CONVERT TEXTC STRING TO N+1 BIT VALUE   ***/
DCL   EV_TEXTC               ENTRY;
 
/***   CONVERT Z_REGISTER STRING TO 36 BIT VALUE   ***/
DCL   EV_Z_REG               ENTRY;
 
 
/***   CONVERT BUFFER VALUE STRING TO VALUE   ***/
DCL   EV_BUF                 ENTRY;
 
 
/***   INTERPRET VALUE MODIFIER AND MODIFY VALUE WIDTH   ***/
DCL   EV_MODIFY_VAL_WIDTH    ENTRY(1);
 
/***   CONVERT BUFFER REFERENCE TO SIZE   ***/
DCL   EV_BUFFER_SIZE              ENTRY;
 
/***************
***   PARAMETERS:
*/
DCL   VAL_DESC$#        PTR       ALIGNED;
                                        /* RETURNED POINTER TO DESCRIPTOR     */
DCL   VAL_BLK_IX#       SBIN WORD ALIGNED;
                                        /* RETURNED IX OF VALUE BLOCK         */
 
/***************
***   LOCALS:
*/
DCL   VAL_STRT          SBIN WORD ALIGNED   AUTO;
                                   /* SAVES START OF CURRENT PART OF VALUE    */
DCL   BLK_SIZE  SBIN WORD ALIGNED AUTO; /* SIZE OF VALUE BLOCK                */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* IX OF VALUE BLOCK                  */
DCL  EVALUATING SBIN WORD ALIGNED AUTO; /* CONTROLS EVALUATION LOOP           */
DCL  LOCAL_TEMP SBIN WORD ALIGNED AUTO; /* USED FOR RETURNED ARGS             */
 
/***************
***   FIRST WE MUST GET A VALUE DESCRIPTOR.
*/
   CALL EV_GET_VALUE_DESC( LOCAL_TEMP ); /* GET IX OF DESCRIPTOR              */
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF ALLOC PROBLEMS           */
 
/*
***   INITIALIZE CURRENT VALUE VALUES.
*/
   DWIDTH = 0;                          /* NO WIDTH YET                       */
   DESC$  = PINCRW( DATA_BASE$, LOCAL_TEMP );
                                        /* POINT TO CURRENT DESCRIPTOR        */
/*
***   GET A BLOCK FOR THE VALUE TO COME.
*/
   BLK_SIZE = 3;                        /* SIZE OF VALUE BLOCK                */
   CALL AM_ALLOC_BLK( DESC$, BLK_SIZE, LOCAL_TEMP );
               /* ALLOCATE A 3 WORD BLOCK AND ASSOCIATE DESCRIPTOR (ASSUME    */
                         /* A LONGER THAN ONE WORD VALUE TO AVOID EXPANSIONS) */
   IF VAL_FAULT ~= 0                    /* ALLOC PROBLEMS?                    */
    THEN DO;                            /* YES                                */
      BLK_SIZE = 1;                     /* ONLY NEED ONE TO START VALUE       */
      CALL AM_ALLOC_BLK( DESC$, BLK_SIZE, LOCAL_TEMP );
      IF VAL_FAULT ~= 0                 /* GET IT?                            */
       THEN DO;                         /* NO                                 */
         DESC$ -> BUF.TYPE = BT_UNUSED; /* 'DEALLOC' DESC                     */
         RETURN;
         END;
      END;
 
/*
***   BEGIN VALUE CONVERSION.
*/
   EVALUATING                = 1;
   DFLT_DT                = DT_MACHINE; /* DEFAULT DISPLAY IS MACHINE         */
 
   DO WHILE (EVALUATING = 1);
      CALL UT_IGNORE_BLANKS;            /* IGNORE LEADING BLANKS              */
      VAL_STRT  = DWIDTH;
                              /* SAVE THE START POSITION OF THE NEXT VALUE    */
      LOCAL_TEMP = DFLT_DT;             /* SAVE THE DEFAULT DISPLAY TYPE      */
      DFLT_DT    = DT_MACHINE;          /* ASSUME DEFAULT DISPLAY IS MACHINE  */
      IF CHARX <= CHARX_MAX             /* POSSIBLE FOR VALUE TO FOLLOW?      */
       THEN DO;                         /* YES                                */
         IF C >= CT_0 AND C <= CT_9     /* DECIMAL?                           */
          THEN CALL EV_DECIMAL;
          ELSE
            IF C = CT_DOLLAR            /* '$'? (DECIMAL)                     */
             THEN DO;
               CALL UT_INC_CHARX;
               CALL EV_DECIMAL;
               END;
             ELSE
               IF C = CT_SQUOTE         /* ''''? (TEXT)                       */
                THEN CALL EV_TEXT;
                ELSE
                  IF C = CT_DQUOTE      /* '"'? (TEXTC)                       */
                   THEN CALL EV_TEXTC;
                   ELSE
                     IF C = CT_POUND    /* '#'? (BASED)                       */
                      THEN CALL EV_BASED( DFLT_BASE, DFLT_BASE_WIDTH );
                      ELSE
                        IF C = CT_PERCENT /* '%'? (BUFFER SIZE)               */
                         THEN CALL EV_BUFFER_SIZE;
                         ELSE
                           IF C = CT_PERIOD /* '.'? (MACHINE DEFAULT)         */
                            THEN CALL EV_BASED( 8, 3 );
                            ELSE
                              IF C = CT_Z /* 'Z'? (Z-REGISTER)                */
                               THEN CALL EV_Z_REG;
                               ELSE
                                 IF C = CT_LBRACKET /* '['? (BUFFER)          */
                                  THEN CALL EV_BUF;
                                  ELSE DO; /* NEXT CHAR DOES NOT BEGIN A VALUE */
                                    EVALUATING = 0;
                                    DFLT_DT = LOCAL_TEMP; /* RESTORE DEFAULT DISPLAY */
                                    END;
               /*
               ***   WE HAVE A VALUE IF NO FAULTS OCCURRED.
               */
         IF VAL_FAULT ~= 0              /* PROBLEMS?                          */
          THEN DO;                      /* YES                                */
            CALL UT_DEALLOC_BUF( DESC$ );
                                        /* FREE VALUE                         */
            RETURN;
            END;
               /*
               ***   NO ERRORS WERE DETECTED. CHECK IF WIDTH MODIFIER FOLLOWS..
               */
         CALL UT_IGNORE_BLANKS;
         IF CHARX <= CHARX_MAX  AND  (C = CT_LPAREN OR C = CT_LBRACE)
                                        /* POSSIBLE FOR MODIFIER TO FOLLOW?   */
          THEN DO;                      /* MODIFIER FOLLOWS                   */
            CALL EV_MODIFY_VAL_WIDTH( VAL_STRT );
            IF VAL_FAULT ~= 0           /* PROBLEMS?                          */
             THEN DO;                   /* YES                                */
               CALL UT_DEALLOC_BUF( DESC$ );
                                        /* FREE VALUE                         */
               RETURN;
               END;
            END;
         END;
       ELSE DO;                         /* NEXT CHAR DOES NOT EXIST           */
         EVALUATING = 0;
         DFLT_DT    = LOCAL_TEMP;       /* RESTORE DEFAULT DISPLAY            */
         END;
      END;
/***************
***   CONVERSION OF VALUE WITH NO ERRORS.
*/
   BLK_IX   = DESC$ -> BUF.IX;          /* GET IX OF BLOCK                    */
   BLK_SIZE = (DWIDTH + 35) / 36 + 3;   /* CALC SIZE OF BLOCK                 */
   CALL AM_SPLIT_BLK( BLK_IX, BLK_SIZE );
                                        /* SPLIT OFF ANY UNUSED WORDS         */
   VAL_BLK_IX# = BLK_IX;                /* RETURN BLOCK IX                    */
   VAL_DESC$#  = DESC$;                 /* AND POINTER TO DESC                */
 
   RETURN;
 
END EV_GET_VALUE;
 
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/**********************************************************************/
/*
***   UT_IDENTIFY_BUFFER   30 AUG 77   (PRY)   IDENTIFIES BUFFER
***   NAME EXPRESSION.
*/
 
UT_IDENTIFY_BUFFER: PROC( BUF$#, BIX# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE FILER_II3;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
 
/***************
***   PARAMETERS:
*/
DCL   BUF$#             PTR       ALIGNED;
                                   /* RETURNED POINTER TO BUFFER DESCRIPTOR   */
DCL   BIX#           SBIN WORD ALIGNED; /* INDEX OF DESCRIPTOR                */
 
/***************
***   DETERMINE IF ACTUAL BUFFER NAME OR Z-REG BUFFER NAME.
*/
   CALL UT_IGNORE_BLANKS;
   IF CHARX > CHARX_MAX                 /* NAME POSSIBLE?                     */
    THEN DO;                            /* NO                                 */
      VAL_FAULT = 1;
                    /*E* 1V UT_IDENTIFY_BUFFER: EXPECTED BUFFER NAME MISSING  */
      RETURN;
      END;
 
   IF C >= CT_A AND C <= CT_Z           /* ALPHA CHAR?                        */
    THEN C = C - CT_A;                  /* YES: CONVERT TO DESCRIPTOR IX      */
    ELSE DO;                            /* NOT AN ALPHA CHAR                  */
      IF C = CT_ASTERISK                /* ASTERISK '*'?                      */
       THEN DO;                         /* YES                                */
         CALL UT_INC_CHARX;             /* GET 'Z'                            */
         CALL UT_IGNORE_BLANKS;
         IF CHARX > CHARX_MAX  OR  C ~= CT_Z
                                        /* NEXT CHAR OBTAINED IS 'Z'?         */
          THEN DO;                      /* NO: NO Z-REG NAME                  */
            VAL_FAULT = 2;
          /*E* 2V UT_IDENTIFY_BUFFER: EXPECTED Z_REGISTER 'Z' MISSING         */
            RETURN;
            END;
          ELSE DO;                      /* GOT THE Z; NOW GET THE NAME        */
            CALL UT_INC_CHARX;          /* SKIP OVER Z                        */
            IF CHARX <= CHARX_MAX  AND  C >= CT_A AND C <= CT_Z
                                        /* POSSIBLE FOR ALPHA NAME TO FOLLOW? */
             THEN DO;                   /* YES                                */
                                        /* CONVERT NAME IN Z_REG TO IX        */
               C = Z_REG$ -> WORD#(C-CT_A) - CT_A;
               IF C > 25  OR  C < 0
                                        /* Z_REG CONTAINED A BUFFER NAME?     */
                THEN DO;                /* NOPE                               */
                  VAL_FAULT = 4;
 /*E* 4V UT_IDENTIFY_BUFFER: Z_REGISTER DOES NOT CONTAIN A BUFFER NAME        */
                  RETURN;
                  END;
               END;
             ELSE DO;                   /* Z_REG NAME MISSING                 */
               VAL_FAULT = 3;
          /*E* 3V UT_IDENTIFY_BUFFER: EXPECTED Z-REGISTER NAME MISSING        */
               RETURN;
               END;
            END;
         END;
       ELSE DO;                         /* NOT BUFFER NAME OR ASTERISK        */
         VAL_FAULT = 1;
         RETURN;
         END;
      END;
/*
***   RETURN DESIRED VALUES.
*/
   BIX#  = C;                           /* RETURN DESCRIPTOR INDEX            */
   IF C ~= CT_X - CT_A THEN NOT_X_ONLY = 1;
   BUF$# = PINCRW( STRT_BUF_DESC$, C*BUF_DESC_SIZE );
                                        /* RETURN POINTER TO DESCRIPTOR       */
   CALL UT_INC_CHARX;                   /* SKIP OVER BUFFER OR Z-REG NAME     */
 
   VAL_FAULT = 0;                       /* INDICATE ALL'S WELL                */
   RETURN;
 
END UT_IDENTIFY_BUFFER;
 
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/**********************************************************************/
/*
***   UT_IGNORE_BLANKS   24 AUG 77   (PRY)   STARTING WITH THE CURRENT
***   CHARACTER, BLANKS ARE SKIPPED UNTIL THE NEXT NON-BLANK OR END
***   OF STRING IS ENCOUNTERED.
*/
 
UT_IGNORE_BLANKS: PROC NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
/*** GET THE NEXT CHARACTER ***/
DCL   UT_INC_CHARX      ENTRY;
 
 
/***************
***   GET CURRENT CHAR; IGNORE CHARS WHILE BLANK AND NOT END OF STRING.
*/
   C = STRING$ -> BUF.BLK$ -> UBIN9#(CHARX);
   IF C = CT_CR THEN C = CT_SEMI_COLON;
                                        /* CHANGE CRS                         */
                                        /* GET THE CURRENT CHAR               */
   DO WHILE (CHARX <= CHARX_MAX  AND  C = CT_SPACE);
      CALL UT_INC_CHARX;
      END;
 
   RETURN;
 
END UT_IGNORE_BLANKS;
 
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/**********************************************************************/
/*
***   UT_INC_CHARX   24 AUG 77   (PRY)   INCREMENT CURRENT CHAR
***   INDEX.  GET NEXT CHARACTER FROM CURRENT STRING.
*/
 
UT_INC_CHARX: PROC NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***************
***
*/
   CHARX = CHARX + 1;                   /* INCREMENT CHAR INDEX               */
   CHAR$ = PINCRC( STRING$ -> BUF.BLK$, CHARX );
                                        /* INCREMENT CHAR POINTER             */
   C     = CHAR$ -> UBN9#;              /* GET CURRENT CHAR                   */
   IF PREV_C = CT_CR                    /* COUNT CRS                          */
    THEN DO;
      CR_CHARX = CHARX;                 /* SAVE CHAR INDEX                    */
      CR_COUNT = CR_COUNT + 1;
      END;
   PREV_C = C;                          /* SAVE CHAR                          */
   IF C = CT_CR                         /* CR?                                */
    THEN C = CT_SEMI_COLON;             /* YES: TREAT AS SEMI COLON           */
 
   RETURN;
 
END UT_INC_CHARX;
 
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/********************************************************************/
/**
***   UT_INC_IGNORE   10 OCT 77   (PRY)   INCREMENT THAT CHARACTER
***   INDEX AND IGNORE BLANKS.
**/
 
UT_INC_IGNORE: PROC NOAUTO;
 
/***   INCREMENT THE CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
/********************
***
**/
   CALL UT_INC_CHARX;
   CALL UT_IGNORE_BLANKS;
 
   RETURN;
END UT_INC_IGNORE;
/********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/*
***   EV_INCREASE_WIDTH   29 AUG 77   (PRY)   INCREASES WIDTH OF CURRENT VALUE.
*/
 
EV_INCREASE_WIDTH: PROC( NBR_BITS# );
%INCLUDE FILER_II5;
 
/***   GIVE A BUFFER A NEW SIZE   ***/
DCL   UT_NEW_SIZE            ENTRY(2);
 
 
/***************
***   PARAMETERS:
*/
DCL   NBR_BITS#      SBIN WORD ALIGNED; /* NUMBER OF BITS TO ADD              */
 
/***************
***   LOCALS:
*/
DCL   NEW_DWIDTH        SBIN WORD ALIGNED   AUTO;
                                        /* USED TO CALC NEW VALUE SIZE        */
 
/***************
***   CALCULATE NEW SIZE OF VALUE.
*/
   NEW_DWIDTH = DWIDTH + NBR_BITS#;     /* CALC NECESSARY SIZE IN BITS        */
   CALL UT_NEW_SIZE( DESC$, NEW_DWIDTH );
                                        /* INCREASE SIZE OF CURRENT VALUE     */
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF ERROR                    */
/*
***   INCREASE RECORDED WIDTH OF VALUE.
*/
   DWIDTH             = NEW_DWIDTH;     /* INCREASE GLOBAL WIDTH              */
 
   RETURN;
 
END EV_INCREASE_WIDTH;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/*
***   UT_INDICATE_COMPACTION 18 AUG 77 (PRY) ALL BUFFER/VALUE
***   DESCRIPTORS POINTING TO BLOCKS BETWEEN THE ARGUMENT BLOCK
***   BLOCK INDICES ARE MODIFIED TO REFLECT POSSIBLE MOVEMENT OF
***   THE ASSOCIATED BLOCK.
*/
 
UT_INDICATE_COMPACTION: PROC( LOW_IX#, HIGH_IX# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   LOW_IX#           SBIN WORD ALIGNED;
                                        /* IX OF LOWEST BLOCK COMPACTED       */
DCL   HIGH_IX#       SBIN WORD ALIGNED; /* IX OF HIGHEST FOOTER               */
 
/***************
***   LOCALS:
*/
DCL   BUF$              PTR       ALIGNED   AUTO;
                              /* POINTER TO DESCRIPTOR ASSOCIATED WITH BLOCK  */
DCL   BID               SBIN WORD ALIGNED   AUTO;
                                        /* BUFFER ID OF ASSOCIATED DESCRIPTOR */
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTER TO CURRENT BLOCK           */
DCL   LOW_IX    SBIN WORD ALIGNED AUTO; /* LOCALIZES LOW_IX#                  */
DCL   HIGH_IX   SBIN WORD ALIGNED AUTO; /* LOCALIZES HIGH_IX#                 */
 
/***************
***   LOCALIZE.
*/
   HIGH_IX = HIGH_IX#;
   LOW_IX  = LOW_IX#;
/*
***   FOR EACH USED BLOCK, CHANGE THE ASSOCIATED DESCRIPTOR.
*/
   DO WHILE (LOW_IX <= HIGH_IX);
      BLK_PTR$ = PINCRW( DATA_BASE$, LOW_IX );
                                        /* POINT TO CURRENT BLOCK             */
      BID      = BLK_PTR$ -> BLK.ID;
                                        /* GET ID OF ASSOCIATED DESC          */
      IF BID < SPL_BUF_ID               /* BLOCK IN USE?                      */
       THEN DO;                         /* YES: MODIFY DESCRIPTOR             */
         BUF$             = PINCRW( STRT_BUF_DESC$, BID*BUF_DESC_SIZE );
                                        /* POINT TO ASSOCIATED DESCRIPTOR     */
         BUF$ -> BUF.IX   = LOW_IX;     /* CORRECT BLK IX                     */
         BUF$ -> BUF.BLK$ = PINCRW( DATA_BASE$, LOW_IX+1 );
                                        /* CORRECT DATA POINTER               */
         END;
      LOW_IX = LOW_IX + BLK_PTR$ -> BLK.SIZE;
                                        /* TRY NEXT BLOCK                     */
      END;
 
   RETURN;
 
END UT_INDICATE_COMPACTION;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/**********************************************************************/
/*
***   UT_INIT_ALL   31 AUG 77   (PRY)   GETS AND SETS UP DATA AREA.
*/
 
UT_INIT_ALL: PROC;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE CP_6;
%INCLUDE F$JIT_C;
DCL B$JIT$ PTR SYMREF;
DCL M$SI DCB;
   %F$DCB(DCBN=F$DCB);
/***    EVENT HANDLER ROUTINE ***/
DCL      UT_EVENT_HANDLER    ENTRY     ASYNC;
/***   INTERRUPT HANDLER ROUTINE   ***/
DCL      UT_INT_HANDLER      ENTRY     ASYNC;
/***   GET DYNAMIC PAGES   ***/
DCL   AM_GET_PAGES           ENTRY(1);
 
/***   CREATE NEW VALUE DESCRIPTORS   ***/
DCL   EV_NEW_VALUE_DESCS     ENTRY(2);
 
/********************
***   FPTS.
**/
%FPT_OPEN (FPTN=SI_OPN_FPT,DCB=M$SI,FUN=IN,STCLASS=CONSTANT);
%FPT_INT (FPTN=INT_CON_FPT,UENTRY=UT_INT_HANDLER,STCLASS=CONSTANT);
%FPT_EVENT(FPTN=EVENT_CON_FPT,UENTRY=UT_EVENT_HANDLER,STCLASS=CONSTANT);
%FPT_PROMPT(FPTN=PROMPT_SET_FPT,PROMPT=THE_PROMPT,VFC=NO,STCLASS=CONSTANT);
DCL THE_PROMPT CHAR(1) CONSTANT INIT(BINASC(0));
/***************
***   LOCALS:
*/
DCL   NBR_PAGES         SBIN WORD ALIGNED   AUTO;
                         /* USED TO CALC NUMBER OF PAGES INITIALLY NEEDED     */
DCL  LOCAL_TEMP SBIN WORD ALIGNED AUTO; /* TARGET FOR RETURNED ARG            */
 
/********************
***   HANDLE INTS, EVENTS.
**/
   CALL M$INT( INT_CON_FPT );
   CALL M$EVENT(EVENT_CON_FPT);
   CALL M$PROMPT( PROMPT_SET_FPT );
/********************
***   CALCULATE VARIOUS INDICES.
*/
   OUT_BUF_IX        = 0;               /* RESERVE ROOM FOR FPT               */
   Z_REG_IX          = OUT_BUF_IX + 35; /* 35 OUTPUT BUFFER WORDS             */
   STRT_BUF_DESC_IX  = Z_REG_IX + 26;   /* 26 Z_REGISTERS                     */
   STRT_VAL_DESC_IX  = STRT_BUF_DESC_IX + (26*BUF_DESC_SIZE);
                                        /* 26 BUFFER DESCRIPTORS              */
   STRT_BLK_IX       = STRT_VAL_DESC_IX + (20*BUF_DESC_SIZE);
                                        /* INITIALLY 20 VALUE DESCRIPTORS     */
   END_BLK_IX        = STRT_BLK_IX + 2; /* FIRST BLOCK HAS 2 WORDS            */
   LOWEST_DEALLOC_IX = END_BLK_IX;
                                        /* INIT COMPACTION PARAMETER          */
   NBR_PAGES         = (END_BLK_IX + 1024) / 1024;
                                        /* CALC NUMBER OF PAGES TO GET        */
   NBR_PAGES_USED    = 0;               /* NO PAGES IN USE YET                */
   LAST_FREE_IX      = -1;              /* IX LAST WORD OF LAST PAGE USED     */
   READ_FILE         = 0;               /* INITIALLY READ COMMANDS FROM UC    */
   UPSHIFT_FLAG       = 0;              /* INITIALLY DON'T UPSHIFT            */
   ECHO_XEQ_FLAG      = 0;              /* Initially don't echo               */
   IF LOCAL_PAGES = 0                   /* IS M$MDP WORKING TODAY?            */
    THEN CALL AM_GET_PAGES( NBR_PAGES ); /* YES                               */
    ELSE DO;                            /* NO: FAKE IT                        */
      FPT_RESULTS.DATA$ = ADDR( FREE_PAGES );
                                        /* RETURN PTR TO FREE PAGE            */
      CALL AM_GET_PAGES( NBR_PAGES );
      END;
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF PROBLEMS                 */
/*
***   SET UP THE DESCRIPTORS.
*/
   DATA_BASE$      = FPT_RESULTS.DATA$;
                                        /* SAVE POINTER TO STORAGE REGION     */
   END_VAL_DESC_IX = STRT_BUF_DESC_IX - BUF_DESC_SIZE;
                         /* FOOL ROUTINE: MAKE IT SET UP BUFFER DESCS ALSO    */
   CALL EV_NEW_VALUE_DESCS( 26+20, LOCAL_TEMP );
                                        /* SET UP THE DESCRIPTORS             */
/*
***   SET UP FIXED POINTERS.
*/
   OUT_BUF$       = PINCRW( DATA_BASE$, OUT_BUF_IX );
   Z_REG$         = PINCRW( DATA_BASE$, Z_REG_IX );
   STRT_BUF_DESC$ = PINCRW( DATA_BASE$, STRT_BUF_DESC_IX );
   X_CMND_BUF$    = PINCRW( STRT_BUF_DESC$, (CT_X-CT_A)*BUF_DESC_SIZE );
                                   /* CALC POINTER TO X BUFFER DESCRIPTOR     */
   Y_FPT_BUF$     = PINCRW( X_CMND_BUF$, BUF_DESC_SIZE );
                                   /* CALC POINTER TO Y BUFFER DESCRIPTOR     */
   ZX$            = PINCRW( Z_REG$, CT_X-CT_A );
   ZY$            = PINCRW( ZX$, 1 );
   ZZ$            = PINCRW( ZX$, 2 );
                                   /* CALC POINTERS TO Z-REGISTERS X ,Y AND Z */
   ZX$ -> WRD#    = 0;                  /* INITIALIZE JIT.ERROR TO 0          */
   ZY$ -> WRD#    = 0;                  /* INITIALIZE TO NO EXECUTE OPTIONS   */
   ZZ$ -> WRD#    = 0;                  /* INITIALIZE TO NO EVENT NUMBER      */
/*
***   SET UP THE BLOCK SPACE.
*/
   TPTR1$                    = PINCRW( DATA_BASE$, STRT_BLK_IX );
                                   /* POINT TO FIRST BLOCK OF BLOCK SPACE     */
   TPTR1$ -> BLK.ID          = SPL_BUF_ID;
                                        /* SPECIAL BLOCK GETS SPECIAL ID      */
   TPTR1$ -> BLK.SIZE        = 2;       /* ONLY TWO WORDS LONG                */
   TPTR1$ -> BLK_FTR.ID      = SPL_BUF_ID;
   TPTR1$ -> BLK_FTR.NUNUSED = 0;       /* NOTHING UNUSED                     */
   TPTR1$                    = PINCRW( DATA_BASE$, END_BLK_IX );
                                        /* POINT TO END BLOCK                 */
   TPTR1$ -> BLK             = END_BLK; /* SET IT UP                          */
/*
***   COMPUTE TWO'S POWERS AND MASKS.
*/
   TEMP1 = 1;
   DO TIX1=0 TO 34;
      TWO_POWER(TIX1) = TEMP1;
      MASKR(TIX1)     = TEMP1 - 1;
      TEMP1           = TEMP1 * 2;
      END;
   TPTR1$      = ADDR( TWO_POWER(35) ); /* SET OVERFLOW VALUES                */
   TPTR1$ -> BT36# = '400000000000'O;
   TPTR1$          = ADDR( MASKR(35) );
   TPTR1$ -> BT36# = '377777777777'O;
   MASKR(36)       = -1;                /* FULL MASK                          */
   DFLT_BASE       = 2;
   DFLT_BASE_WIDTH = 1;            /* INITIAL BASED VALUE CONVERSION PARAMS   */
   CALL M$OPEN( SI_OPN_FPT ) ALTRET(JUSTRET);
   IF B$JIT$->B$JIT.MODE = %M_BATCH#
     OR DCBADDR(DCBNUM(M$SI))->F$DCB.DDEV.XEQ#
    THEN ECHO = 1;
    ELSE ECHO = 0;
JUSTRET: ;
 
   RETURN;
 
END UT_INIT_ALL;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***      UT_EVENT_HANDLER    14 AUG 78      (GWJ)  EVENT HANDLER.
**/
UT_EVENT_HANDLER: PROC ASYNC;
%INCLUDE FILER_II4;
%INCLUDE FILER_II5;
%INCLUDE CP_6;
/****    OUTPUT CHARACTERS ****/
DCL UT_OUTPUT_CHARS     ENTRY(2);
/****    DISPLAY NUMERIC ****/
DCL UT_DISPLAY          ENTRY(3);
/****    CLEAR BUFFER ****/
DCL UT_FLUSH_BUF        ENTRY;
/*****************************
**/
%B$TCB;
%B$NWIO;
DCL B$TCB$    PTR    SYMREF;
%SUB B$NWIO=B$TCB$->B$TCB.STK$->B$NWIO;
/*****************************
***      CALL ROUTINES AND PRINT MESSAGE TO USER.
**/
   TEMP1 = B$NWIO.EVID;
   IF TEMP1 >= 37 THEN TEMP1 = 36;
   TEMP2 = 36 - TEMP1;
   ZZ$ -> BIT#(TEMP2)='1'B;
   IF NOT ZY$->BT36#
    THEN DO;
      CALL UT_OUTPUT_CHARS('EVENT ',6);
      CALL UT_DISPLAY(ADDR(B$NWIO.EVID),36,-DT_DECIMAL);
      CALL UT_FLUSH_BUF;
      END;
   RETURN;
 
UT_INT_HANDLER: ENTRY ASYNC;
 
   CALL UT_OUTPUT_CHARS(' (BRK!)',7);
   CALL UT_FLUSH_BUF;
   BRK_FLAG = 1;                        /* INDICATE THAT BREAK HAS BEEN HIT   */
   RETURN;
END UT_EVENT_HANDLER;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   UT_JUNK_CHK   28 SEP 77   (PRY)   CHECKS IF ANY EXTRANEOUS
***   INFORMATION APPEARS IN THE COMMAND.
**/
 
UT_JUNK_CHK: PROC;
 
/***   IGNORE BLANKS   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
/********************
***   IGNORE ANY LEADING BLANKS; COMMAND MUST END WITH ';'
***   OR BUFFER END.
**/
   CALL UT_IGNORE_BLANKS;
   IF CHARX <= CHARX_MAX  AND  C ~= CT_SEMI_COLON
    THEN VAL_FAULT = 30;                /* JUNK FOLLOWS                       */
                    /*E* 30V UT_JUNK_CHK: EXTRANEOUS JUNK SHOULDN'T BE THERE  */
 
   RETURN;
 
END UT_JUNK_CHK;
 
/************************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/**********************************************************************/
/*
***   UT_LOOKUP   19 AUG 77   (PRY)   LOOKS UP CURRENT NAME
***   IN TABLE CONFIGURATION DESCRIBED BY PTR TABLE
***   POINTED TO BY PTR_TBL$#. RETURNS INDEX WHERE NAME WAS FOUND
***   IF FOUND, OTHERWISE -1 IN TBL_IX#.
*/
 
UT_LOOKUP: PROC ( PTR_TBL$#, TBL_IX#, NO_CHANGE# ) NOAUTO;
%INCLUDE CP_6;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE FILER_II1;
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   DISPLAY AN ITEM IN SPECIFIED FORMAT   ***/
DCL   UT_DISPLAY             ENTRY(3);
 
/***   EXPAND OR CONTRACT A BUFFER   ***/
DCL   UT_NEW_SIZE            ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
/***  WRITE THE OUTPUT BUFFER   ***/
DCL   UT_WRITE_BUF           ENTRY(2);
 
/***   OUTPUT A SINGLE CHARACTER   ***/
DCL   UT_OUTPUT_CHAR         ENTRY(1);
 
/***   GET USER INPUT   ***/
DCL   UT_READ_BUF            ENTRY(4);
/********************
***   PARAMETERS:
*/
DCL   PTR_TBL$#         PTR    ALIGNED; /* POINTER TO POINTER TABLE           */
DCL   TBL_IX#        SBIN WORD ALIGNED; /* RETURNED IX OR -1                  */
DCL NO_CHANGE# SBIN WORD ALIGNED; /* If present, indicates corrected
                                        name is not to be changed   */
 
/***************
***   LOCALS:
*/
DCL   PTR_TBL$        PTR ALIGNED AUTO; /* LOCALIZES PTR_TBL$#                */
DCL   NAM_IX            SBIN WORD ALIGNED   AUTO;
                                        /* USED TO SEARCH NAME TABLE          */
DCL LOOK_STATE SBIN WORD ALIGNED AUTO;  /* What state of looking for name     */
%EQU LOOKFOR=0;
%EQU LOOKFOR#=1;
%EQU LOOKFORNOW=2;
%EQU LOOKFOR#NOW=3;
%EQU LOOKFOREND=4;
DCL   LOW_LIM   SBIN WORD ALIGNED AUTO; /* SAVES LOW  TABLE LIMIT             */
DCL   HIGH_LIM  SBIN WORD ALIGNED AUTO; /* SAVES HIGH TABLE LIMIT             */
DCL   NAM_SIZ   SBIN WORD ALIGNED AUTO; /* LOCALIZES LENGTH OF NAME           */
DCL   NAM_IX$         PTR ALIGNED AUTO; /* POINTER TO IX TABLE                */
DCL   NAM_CONT$       PTR ALIGNED AUTO; /* POINTER TO CONT TABLE              */
DCL   CHARIX    SBIN WORD ALIGNED AUTO; /* INDEXES NAME CHARACTERS            */
DCL   CONTIX            SBIN WORD ALIGNED   AUTO;
                              /* INDEXES NAME TABLE CONTINUATION CHARACTERS   */
DCL   NAM4              SBIN WORD ALIGNED   AUTO;
                         /* HOLDS FIRST 4 CHARS OF NAME FOR WORD COMPARISONS  */
DCL   NAM_TBL$        PTR ALIGNED AUTO; /* POINTS TO NAME TABLE               */
DCL   NAM_LIX$          PTR       ALIGNED   AUTO;
                                        /* POINTS TO LIMIT INDEX TABLE        */
 
 /***********
  *** Other data:
  **/
 
%FPT_PROMPT( FPTN=QUESPROMPT, STCLASS=CONSTANT, PROMPT=QMBL );
DCL QMBL CHAR(2) CONSTANT INIT( '? ' );
 
/***************
***   LOCALIZE.
*/
   PTR_TBL$ = PTR_TBL$#;                /* LOCALIZE PARM                      */
   NAM_TBL$ = PTR_TBL$ -> PTR_TBL.TBL;  /* GET NAME TABLE POINTER             */
   NAM_LIX$ = PTR_TBL$ -> PTR_TBL.LIX;  /* GET LIX TABLE POINTER              */
   NAM_SIZ  = CRNT_NAME.LENGTH;         /* GET # CHARS IN TEXTC NAME          */
   IF CRNT_NAME.CHR(NAM_SIZ-1) = ASCBIN('#')
    THEN LOOK_STATE = %LOOKFOR#;
    ELSE LOOK_STATE = %LOOKFOR;
 
 /***
  *** Different states control addition/deletion of # at name end.
  ***/
 
   DO WHILE(LOOK_STATE ~= %LOOKFOREND);
 
/*
***   IF THE LENGTH OF THE NAME IS LONGER THAN ANY IN
***   THE TABLE, IT CAN'T POSSIBLY BE IN THE TABLE.
*/
      LOW_LIM   = TBL_IX# + 1;          /* GET BEGIN SEARCH LIMIT             */
      NAM_IX$ = PTR_TBL$ -> PTR_TBL.IX; /* GET POINTER TO IX TABLE            */
      NAM_CONT$ = PTR_TBL$ -> PTR_TBL.CONT;
                                        /* GET POINTER TO CONT TABLE          */
      IF NAM_SIZ > NAM_LIX$ -> HLF#
                                   /* GREATER THAN LONGEST NAME  IN TABLE?    */
       THEN DO;                         /* YES                                */
         GOTO CORRECT_NAME;             /* Try to correct the name            */
         END;
 
/*
***   GET SEARCH BOUNDS FROM LIMIT INDEX VECTOR.
*/
      NAM_IX = NAM_LIX$ -> HALF#(NAM_SIZ); /* GET LOW SEARCH BOUND            */
      IF LOW_LIM > NAM_IX THEN NAM_IX = LOW_LIM; /* START SEARCH AT ARGUMENT INDEX */
      HIGH_LIM = NAM_LIX$ -> HALF#(NAM_SIZ+1); /* GET HIGH SEARCH BOUND       */
 
/*
***   INITIALIZE SEARCH:  BLANK FILL NAME WORD IF NECESSARY.
*/
      NAM4 = CRNT_NAME$ -> WORD#(1);    /* GET FIRST WORD OF NAME             */
      IF NAM_SIZ < 4                    /* NEEDS BLANK FILL?                  */
       THEN DO;                         /* YES                                */
         TPTR1$ = ADDR(NAM4);
         DO TIX1=NAM_SIZ TO 3;
            TPTR1$ -> UBIN9#(TIX1) = CT_SPACE;
            END;
         END;
 
/*
***   SEARCH FOR NAME: (1) THE FIRST FOUR CHARACTERS OF THE
***   NAME (BLANK FILL IS USED IF NECESSARY) MUST MATCH AN
***   ENTRY IN THE NAME TABLE POINTED TO BY NAM_TBL$;
***   (2) THE REST OF THE NAME IS THEN COMPARED TO THE REST OF
***   THE NAME TABLE ENTRY.
*/
 
      TPTR2$ = PINCRC( CRNT_NAME$, 8 ); /* POINT TO SECOND WORD OF NAME       */
      TEMP1 = NAM_SIZ - 4;    /* NBR CHRS TO COMPARE AFTER 1ST WD MATCHES     */
      DO WHILE (NAM_IX < HIGH_LIM);     /* TRY TO FIND FIRST 4 CHARS OF NAME  */
         IF NAM_TBL$ -> WORD#(NAM_IX) = NAM4 /* MATCH?                        */
          THEN DO;                      /* YES: NOW CHECK REST OF NAME        */
               /*
               ***   IF THE NAME IS LESS THAN 5 CHARACTERS,
               ***   WE FOUND A MATCH.
               */
            IF TEMP1 < 1                /* ANY MORE TO COMPARE?               */
             THEN DO;                   /* NO--MATCH                          */
               TBL_IX# = NAM_IX;        /* RETURN IX WHERE FOUND              */
               RETURN;
               END;
              /*
              ***   TABLE NAME CONTINUATION MUST MATCH THE REST OF NAME.
              */
            TPTR1$ = PINCRC( NAM_CONT$, NAM_IX$ -> HALF#(NAM_IX) );
                                        /* POINT TO CONTINUATION              */
            IF TPTR1$ -> CHARS = TPTR2$ -> CHARS /* REST MATCHES?             */
             THEN DO;                   /* YES!                               */
               TBL_IX# = NAM_IX;        /* RETURN IX WHERE FOUND              */
               RETURN;
               END;
            END;
 
         NAM_IX    = NAM_IX + 1;        /* NO: TRY NEXT TABLE ENTRY           */
         END;
/*
***   NAME WAS NOT FOUND.
*/
CORRECT_NAME: ;
      DO CASE(LOOK_STATE);              /* What now                           */
       CASE(%LOOKFOR);
         CRNT_NAME.CHR(NAM_SIZ) = ASCBIN('#');
         NAM_SIZ = NAM_SIZ + 1;
         CRNT_NAME.LENGTH = NAM_SIZ;
         LOOK_STATE = %LOOKFOR#NOW;
       CASE(%LOOKFOR#);
         NAM_SIZ = NAM_SIZ - 1;
         CRNT_NAME.LENGTH = NAM_SIZ;
         LOOK_STATE = %LOOKFORNOW;
       CASE(%LOOKFOR#NOW);
         NAM_SIZ = NAM_SIZ - 1;
         CRNT_NAME.LENGTH = NAM_SIZ;
         LOOK_STATE = %LOOKFOREND;
       CASE(%LOOKFORNOW);
         NAM_SIZ = NAM_SIZ + 1;
         CRNT_NAME.LENGTH = NAM_SIZ;
         LOOK_STATE = %LOOKFOREND;
       END;
      END;
   CALL UT_CORRECT_NAME;                /* TRY TO CORRECT THE NAME            */
   RETURN;
 
/*********************************************************************/
/*********************************************************************/
/**
***   UT_CORRECT_NAME   30 SEP 77   (PRY)   TRY TO CORRECT THE NAME.
**/
 
UT_CORRECT_NAME: PROC;
 
/********************
***   LOCALS:
**/
DCL   ND_SUCCESS        SBIN WORD ALIGNED   AUTO;
                                        /* FLAG FOR MATCHING NON-DIAG         */
DCL   LD_SUCCESS        SBIN WORD ALIGNED   AUTO;
                                        /* FLAG FOR MATCHING LEFT DIAGONAL    */
DCL   RD_SUCCESS        SBIN WORD ALIGNED   AUTO;
                                        /* FLAG FOR MATCHING RIGHT DIAGONAL   */
DCL   ND#CONSEC         SBIN WORD ALIGNED   AUTO;
                                   /* NUMBER OF CONSECUTIVE NON-DIAG MATCHES  */
DCL   LD#CONSEC         SBIN WORD ALIGNED   AUTO;
                                        /* # OF CONSEC LEFT-DIAG MATCHES      */
DCL   RD#CONSEC         SBIN WORD ALIGNED   AUTO;
                                        /* # OF CONSEC RIGHT-DIAG MATCHES     */
DCL   ND#               SBIN WORD ALIGNED   AUTO;
                                        /* NUMBER OF MATCHING NON-DIAGS       */
DCL   LD#       SBIN WORD ALIGNED AUTO; /* # OF MATCHING L DIAGS              */
DCL   RD#       SBIN WORD ALIGNED AUTO; /* # OF MATCHING R DIAGS              */
DCL 1 TEST_NAME ALIGNED AUTO,           /* TEXTC TEST NAME                    */
      2 LENGTH SBIN WORD UNAL,
      2 CHR(0:79) UBIN(9) UNAL,
      2 CHRS REDEF CHR CHAR(80) UNAL;
DCL CHRS# CHAR(80) BASED;
DCL   MAX_LIX_IX        SBIN WORD ALIGNED   AUTO;
                                        /* LENGTH OF LONGEST POSSIBLE NAME    */
DCL  NAM_LIX_IX SBIN WORD ALIGNED AUTO; /* CURRENT LIX IX                     */
DCL   ANSBUF(0:3) UBIN(9) ALIGNED AUTO; /* ANSWER BUFFER                      */
DCL   ANSBUF$         PTR ALIGNED AUTO; /* POINTER TO ABOVE                   */
DCL   ANSSIZE   SBIN WORD ALIGNED AUTO; /* NUMBER OF CHARS IN REPLY           */
DCL   LCL_PTR$        PTR ALIGNED AUTO; /* LOCAL POINTER                      */
DCL   NEW_WIDTH         SBIN WORD ALIGNED   AUTO;
                                        /* NEW WIDTH OF CURRENT BUFFER        */
DCL   LEN_DIF   SBIN WORD ALIGNED AUTO; /* DIFFERENCE IN CHARS                */
 
/********************
***   SEE IF POSSIBLE TO CORRECT THE NAME.
**/
   MAX_LIX_IX = NAM_LIX$ -> HLF#;
                                   /* GET LENGTH OF LONGEST POSSIBLE NAME     */
   IF NAM_SIZ < 2  OR  NAM_SIZ > MAX_LIX_IX + 1
                         /* DON'T TRY TO CORRECT NAME IF TOO SMALL OR LARGE   */
    THEN DO;
      TBL_IX# = -1;                     /* NAME NOT CORRECTABLE               */
      RETURN;
      END;
 
/********************
***   SEARCH LIMITS ARE BOUNDED BY THE NAME LENGTH -1 TO THE NAME
***   LENGTH + 1.
**/
   NAM_LIX_IX = NAM_SIZ - 1;            /* GET LOW LIX IX                     */
   IF NAM_SIZ < MAX_LIX_IX              /* CALC HIGH LIX SEARCH LIMIT         */
    THEN MAX_LIX_IX = NAM_SIZ + 2;
                                        /* SEARCH ENTIRELY WITHIN TABLE       */
    ELSE MAX_LIX_IX = MAX_LIX_IX + 1;
                                        /* TRUNCATE SEARCH TO TABLE LIMITS    */
 
/********************
***   SEARCH NAME TABLE FOR APPROXIMATELY MATCHING NAME.
**/
   DO WHILE (NAM_LIX_IX < MAX_LIX_IX);  /* DO WHILE WITHIN BOUNDS             */
      NAM_IX   = NAM_LIX$ -> HALF#(NAM_LIX_IX);
                                        /* GET LOW LIMIT                      */
      IF LOW_LIM > NAM_IX THEN NAM_IX = LOW_LIM;
                              /* DON'T BEGIN SEARCH BELOW SPECIFIED LIMIT     */
      HIGH_LIM = NAM_LIX$ -> HALF#(NAM_LIX_IX+1);
                                        /* GET HIGH LIMIT                     */
      TEST_NAME.LENGTH = NAM_LIX_IX;    /* SET LENGTH OF NAME                 */
      DO WHILE (NAM_IX < HIGH_LIM);
              /**
              ***   CONSTRUCT A TEMPORARY NAME.
              **/
         TPTR1$ = ADDR(TEST_NAME.CHR);  /* POINT TO CHARS                     */
         TPTR1$ -> WRD# = NAM_TBL$ -> WORD#(NAM_IX);
                                        /* GET FIRST FOUR CHARS OF NAME       */
         CONTIX = NAM_IX$ -> HALF#(NAM_IX);
                                        /* GET IX OF CONTINUATION             */
         DO CHARIX=4 TO NAM_LIX_IX-1;
            TEST_NAME.CHR(CHARIX) = NAM_CONT$ -> UBIN9#(CONTIX);
            CONTIX = CONTIX + 1;
            END;
         DO CHARIX=NAM_LIX_IX TO NAM_SIZ+2;
            TEST_NAME.CHR(CHARIX) = 0;
                                        /* UNMATCHING CHAR                    */
            END;
              /**
              ***   COMPARE THE TEST NAME WITH THE CURRENT NAME.
              **/
         ND_SUCCESS = 0;                /* INITIALLY FALSE                    */
         LD_SUCCESS = 0;
         RD_SUCCESS = 0;
         ND#CONSEC  = 0;                /* INITIALLY NONE                     */
         LD#CONSEC  = 0;
         RD#CONSEC  = 0;
         ND#        = 0;
         LD#        = 0;
         RD#        = 0;
         TEMP1 = 0;                     /* INIT PREVIOUS CHAR                 */
         DO TIX1=0 TO NAM_SIZ-1;        /* COMPARE CHARS                      */
            TEMP2 = CRNT_NAME.CHR(TIX1);
                                        /* GET NEXT CHAR TO COMPARE           */
            IF TEMP2 = TEST_NAME.CHR(TIX1)
                                        /* CHECK NON-DIAGONAL                 */
             THEN DO;                   /* MATCH                              */
               ND# = ND# + 1;           /* COUNT MATCH                        */
               IF ND_SUCCESS = 1        /* CONSECUTIVE?                       */
                THEN ND#CONSEC = ND#CONSEC + 1;
                                        /* YES                                */
                ELSE ND_SUCCESS = 1;
                                        /* NO                                 */
               END;
             ELSE ND_SUCCESS = 0;       /* NO MATCH                           */
            IF TEMP2 = TEST_NAME.CHR(TIX1-1)
                                        /* CHECK LEFT-DIAGONAL                */
             THEN DO;                   /* MATCH                              */
               IF TEMP1 = TEST_NAME.CHR(TIX1)
                                        /* TRANSPOSITION?                     */
                THEN DO;                /* YES:                               */
                  ND#CONSEC = ND#CONSEC + 1;
                  ND_SUCCESS = 1;
                                        /* TREAT AS CONSECUTIVE NON-DIAG      */
                  END;
               LD# = LD# + 1;           /* COUNT MATCH                        */
               IF LD_SUCCESS = 1        /* CONSECUTIVE?                       */
                THEN LD#CONSEC = LD#CONSEC + 1;
                                        /* YES                                */
                ELSE LD_SUCCESS = 1;
                                        /* NO                                 */
               END;
             ELSE LD_SUCCESS = 0;       /* NO MATCH                           */
            IF TEMP2 = TEST_NAME.CHR(TIX1+1)
                                        /* CHECK RIGHT-DIAGONAL               */
             THEN DO;                   /* MATCH                              */
               RD# = RD# + 1;           /* COUNT MATCH                        */
               IF RD_SUCCESS = 1        /* CONSECUTIVE?                       */
                THEN RD#CONSEC = RD#CONSEC + 1;
                                        /* YES                                */
                ELSE RD_SUCCESS = 1;
                                        /* NO                                 */
               END;
             ELSE RD_SUCCESS = 0;       /* NO MATCH                           */
            TEMP1 = TEMP2;              /* SAVE PREVIOUS CHAR                 */
            END;
              /**
              ***   IF MATCH IS CLOSE ENOUGH, ASK USER IF NAME
              ***   IS PROPER SELECTION.
              **/
         IF BRK_FLAG ~= 0               /* STOP SEARCHING IF BREAK HIT        */
          THEN DO;
            TBL_IX# = -1;               /* ASSUME NOT FOUND                   */
            RETURN;
            END;
         TEMP1 = NAM_SIZ / 2 - 1;
         IF (ND#CONSEC+RD#CONSEC+LD#CONSEC >= NAM_SIZ-((NAM_SIZ/4)+1))
           AND
           (ND# >= TEMP1 OR RD# >= TEMP1 OR LD# > TEMP1)
          THEN DO;                      /* SURE IS                            */
            TBL_IX# = NAM_IX;           /* RETURN TABLE IX                    */
        /* IF THE FOUND NAME MATCHES THE CURRENT NAME EXCEPT FOR
        AN EXTRA POUND SIGN (#) ON EITHER, CONSIDER THE NAME FOUND. */
            IF NAM_SIZ > NAM_LIX_IX
              AND CRNT_NAME.CHR(NAM_SIZ-1) = CT_POUND
              AND ND# = NAM_LIX_IX
                                        /* CURRENT NAME HAS EXTRA #           */
              OR NAM_LIX_IX > NAM_SIZ
              AND TEST_NAME.CHR(NAM_LIX_IX-1) = CT_POUND
              AND ND# = NAM_SIZ
                                        /* TEST NAME HAS EXTRA #              */
              OR NAM_SIZ = 5
              AND ND# = 4
              AND SUBSTR(TEST_NAME.CHRS,0,5) = 'F$DCB'
              AND CRNT_NAME.CHR(0) = CT_M
                                        /* ACCEPT M$DCB FOR F$DCB             */
              OR ND#+LD# = NAM_LIX_IX
              AND SUBSTR(TEST_NAME.CHRS,0,4) = 'FPT_'
              AND (CRNT_NAME.CHR(4)= CT_S OR CRNT_NAME.CHR(4)= CT_G
              OR CRNT_NAME.CHR(4)= CT_R)
              AND SUBSTR(TEST_NAME.CHRS,4,NAM_LIX_IX-4) =
              SUBSTR(ADDR(CRNT_NAME.CHR)->CHRS#,5,NAM_SIZ-5)
             THEN DO;                   /* FPT_x if FPT_Sx, FPT_Rx or FPT_Gx  */
               CALL UT_CHANGE_NAME;
               RETURN;
               END;
            CALL UT_FLUSH_BUF;
            CALL UT_OUTPUT_CHARS( 'Don''t you mean ', 15 );
            LCL_PTR$ = PINCRC( ADDR(TEST_NAME), 3 );
                                        /* USE OLD LIX PTR AS TEMP            */
            CALL UT_DISPLAY( LCL_PTR$, 2592, DT_TEXTC );
                                        /* TELL OF SUBSTITUTION               */
            CALL UT_OUTPUT_CHARS( ' instead of ', 12 );
            LCL_PTR$ = PINCRC( CRNT_NAME$, 3 );
            CALL UT_DISPLAY( LCL_PTR$, 2592, DT_TEXTC );
            CALL M$PROMPT( QUESPROMPT ) ALTRET(SOWHAT);
SOWHAT:     ;
            CALL UT_WRITE_BUF( OUT_BUF$, OUT_CHARX );
                                        /* FLUSH THE BUFFER WITH NO CR        */
            OUT_CHARX = 0;              /* RESET OUTPUT CHAR COUNT            */
            ANSBUF$ = ADDR( ANSBUF );   /* GET ADDRESS OF ANSWER BUFFER       */
            CALL UT_READ_BUF(  ANSBUF$, 4, ANSSIZE, 0 );
                                        /* GET REPLY FROM UC                  */
            IF ANSSIZE > 0  AND  ANSBUF(0) = CT_Y
                                        /* YES?                               */
             THEN DO;                   /* YES                                */
               CALL UT_CHANGE_NAME;
               RETURN;
               END;
             ELSE DO;                   /* REPLY IS NEGATIVE OR NOTHING       */
               IF ANSSIZE <= 0  OR  ANSBUF(0) ~= CT_N
                THEN DO;                /* NO ANSWER--QUIT LOOKING            */
                  TBL_IX# = -1;
                  RETURN;
                  END;
               END;
            END;
         NAM_IX = NAM_IX + 1;           /* TRY NEXT NAME                      */
         END;
      NAM_LIX_IX = NAM_LIX_IX + 1;      /* TRY NEXT GROUP OF NAMES            */
      END;
 
   TBL_IX# = -1;                        /* CAN'T FIND CORRECTION              */
   RETURN;
/*********************************************************************/
/**
***   UT_CHANGE_NAME   30 SEP 77 (MOVED 20 JUL 78) CHANGES THE
***   NAME TO THE FOUND NAME.
**/
UT_CHANGE_NAME: PROC;
/********************
***   IF ENOUGH ROOM, SUBSTITUTE THE FOUND NAME FOR THE
***   USER GIVEN NAME.
**/
 
   IF ADDR(NO_CHANGE#) ~= ADDR(NIL) THEN RETURN; /* Not to be changed         */
   LEN_DIF = TEST_NAME.LENGTH - CRNT_NAME.LENGTH;
                                   /* CALC DIFFERENCE BETWEEN NAME LENGTHS    */
   IF LEN_DIF > 0
    THEN DO;                            /* NEED TO EXPAND COMMAND BUFFER?     */
      NEW_WIDTH = STRING$ -> BUF.WIDTH + 9 * LEN_DIF;
                                        /* CALC NEW DESIRED WIDTH OF BUFFER   */
      CALL UT_NEW_SIZE( STRING$, NEW_WIDTH );
                                        /* EXPAND IT                          */
      IF VAL_FAULT ~=0
                                        /* EXPANSION ERROR?                   */
       THEN DO;                         /* CAN'T SUBSTITUTE                   */
         VAL_FAULT = 0;
                                        /* IGNORE ERROR                       */
         CALL UT_OUTPUT_CHARS( ' (can''t substitute)', 19 );
         CALL UT_OUTPUT_CHAR( CT_CR );
                                   /* TELL USER THAT WORD WON'T BE REPLACED   */
         RETURN;
         END;
      TPTR1$ = STRING$ -> BUF.BLK$;
                                        /* GET POINTER TO BUFFER DATA         */
      TPTR2$ = PINCRC( TPTR1$, LEN_DIF );
                                        /* POINT TO TARGET AREA               */
      TIX1   = CHARX_MAX;
                                        /* INDEX CURRENT LAST CHAR            */
      DO WHILE (TIX1 >= CHARX );
                                        /* MOVE REAR OF BUFFER CONTENTS BACK  */
         TPTR2$ -> UBIN9#(TIX1) = TPTR1$ -> UBIN9#(TIX1);
         TIX1 = TIX1 - 1;
         END;
      CHARX_MAX = CHARX_MAX + LEN_DIF;
                                   /* REFLECT MOVE IN CHARX AND CHARX_MAX     */
      CHARX     = CHARX + LEN_DIF;
      END;
    ELSE LEN_DIF = 0;                   /* DON'T CHANGE LOC OF FIRST CHAR     */
   TPTR1$ = PINCRC( STRING$ -> BUF.BLK$,
     CHARX-CRNT_NAME.LENGTH-LEN_DIF );
                                        /* POINT TO FIRST CHAR OF NAME        */
   DO TIX1=0 TO TEST_NAME.LENGTH-1;
                                        /* REPLACE NAME                       */
      TPTR1$ -> UBIN9#(TIX1) = TEST_NAME.CHR(TIX1);
      END;
   DO TIX1=TEST_NAME.LENGTH TO CRNT_NAME.LENGTH-1;
                                        /* BLANK FILL IF NECESSARY            */
      TPTR1$ -> UBIN9#(TIX1) = CT_SPACE;
      END;
   RETURN;
END UT_CHANGE_NAME;
 
END UT_CORRECT_NAME;
 
END UT_LOOKUP;
 
/**********************************************************************/
