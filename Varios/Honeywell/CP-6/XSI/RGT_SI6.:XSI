/*M*     RGT  READ  GCOS  TAPES  */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*P*  THIS PROGRAM READS GCOS SOURCE TAPES AND
      SEPARATES THE SOURCE AND OBJECT MODULES
      INTO INDIVIDUAL FILES ON CP-6
      CODE CONVERISION IS DONE FOR BCD FILES
      AND DECOMPRESSION FOR COMPRESSED FILES
      THE INPUT TAPE IS READ THRU  M$SI
      THE OUTPUT FILES ARE THRU    M$OU
      ANY COMMENTARY IS THRU       M$LO
THERE ARE FOUR OPTIONS AVAILABLE ON THE COMMAND LINE
1) APPEND    ALLOWS FOR THE SPLITTING OF COBOL INCLUDE
             FILES INTO CP-6 FILES OF THE APPEND NAME
             THE DATA IS EXPECTED TO BE BRACKETED BY
             APPEND <INCLUDE NAME>  STARTING IN COL 1
             AND BY *END*  STARTING IN COL 1.
2) NOCOM     PREVENTS RGT FROM COMPRESSING OUT THE TRAILING BLANKS
3) PARTIAL   RGT WILL INCLUDE THE LAST BLANK AFTER THE NONE BLANK DATA
4) NOSLIT   DO NOT SPLIT INPUT BY $ CARDS
EXAMPLE -
  !RGT.X FT#1234 (APPEND,NOCOM)
THIS EXAMPLE WILL SPLIT THE COBOL INCLUDE FILES (INPUT TO GCOS SRCLIB)
INTO INDIVIDUAL CP-6 FILES WITH THE SAME NAME AS ON THE APPEND
DIRECTIVE AND WITH NO COMPRESSION OF THE RECORDS
*/
RGT:     PROC MAIN;
/*
    BRING IN THE INCLUDE FILES AND INIT THE FPTS
*/
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
/*  SYMREF ANY DCBS NOT DECLARED  */
DCL M$LO DCB;
%M$DCB(DCBN=M$SI,FUN=IN,ORG=FREE,ASN=DEVICE);
%FPT_OPEN(FPTN=SI_OPN,ORG=FREE,DCB=M$SI);
%FPT_READ(FPTN=SI_RD,DCB=M$SI,BUF=IN_BLOCK,BIN=YES);
%FPT_CLOSE(FPTN=SI_CLS,DCB=M$SI);
%M$DCB(DCBN=M$OU,ASN=FILE,NAME='RGT000',FUN=CREATE,CTG=YES);
%FPT_OPEN(FPTN=OU_OPN,FUN=CREATE,CTG=YES,ORG=KEYED,
          NAME=OU_NAME,DCB=M$OU);
%VLP_NAME(FPTN=OU_NAME,NAME='RGT000',LEN=31);
%FPT_WRITE(FPTN=OU_WR,DCB=M$OU,BUF=OT_IMAGE,KEY=OU_KEY);
%FPT_WRITE(FPTN=OT_WR,DCB=M$OU,BUF=OT_BUFFER,KEY=OU_KEY);
%FPT_CLOSE(FPTN=OU_CLS,DCB=M$OU);
%FPT_WRITE(FPTN=LO_WR,DCB=M$LO,BUF=HERE_RGT);
%EJECT;
/*       DECLARE STATIC VARIABLES AND INIT  */
DCL HERE_RGT       CHAR(12) STATIC INIT('RGT A01 HERE');
DCL 1 RGT_FILE     STATIC,
       2  RGT_NAME  CHAR(3)   INIT('RGT'),
       2  RGT_FILE_ID    CHAR(3);
DCL RGT_CHR REDEF RGT_FILE   CHAR(6);
DCL RGT_FILE_SEQ        UBIN HALF  STATIC INIT(0);
DCL 1 OU_KEY STATIC,
       2  LEN            UBIN(9) UNAL INIT(BITBIN('3'O)),
       2  ACTUAL_KEY     UBIN(27) UNAL INIT(0);
DCL 1 MODULE_MSG  STATIC,
       2  MODULE_TEXT    CHAR(25) INIT
         ('# OF MODULES PROCESSED = '),
       2  MOD_CNT   CHAR(4),
       2  *         CHAR(22) INIT('   LAST MODULE NAME = '),
       2  MOD_NAME  CHAR(6);
DCL 1 FILE_MSG STATIC,
       2 PROC_MSG  CHAR(8) INIT('        '),
       2 FILE_NAME CHAR(8) INIT('        ');
DCL  COBOL              CHAR(6) INIT('COBOL') STATIC;
DCL  FORTRAN            CHAR(6) INIT('FORTRA') STATIC;
DCL  GMAP               CHAR(6) INIT('GMAP') STATIC;
DCL  PL1                CHAR(6) INIT('PL1') STATIC;
DCL  RPG2               CHAR(6) INIT('RPG2') STATIC;
DCL  ALGOL              CHAR(6) INIT('ALGOL') STATIC;
DCL  CBL74              CHAR(6) INIT('CBL74') STATIC;
DCL  CBL68              CHAR(6) INIT('CBL68') STATIC;
DCL  IDS2               CHAR(6) INIT('IDS2') STATIC;
DCL  DKEND              CHAR(6) INIT('DKEND') STATIC;
DCL  ENDEDIT            CHAR(6) INIT('ENDEDI') STATIC;
DCL  OBJECT             CHAR(6) INIT('OBJECT') STATIC;
DCL  UPDATE             CHAR(6) INIT('UPDATE') STATIC;
DCL  ALTER              CHAR(6) INIT('ALTER')  STATIC;
DCL  APPEND             CHAR(6) INIT('#!$&)(') STATIC;
DCL  STAR_END_STAR        CHAR(5) INIT('!#$&<') STATIC;
/*  BOTH APPEND AND STAR_END_STAR ARE SET TO 'APPEND'
    AND '*END*' BY INITIALIZATION UPON RECOGONITION
    OF THE APPEND OPTION
*/
DCL LBL       UBIN WORD STATIC INIT(BITBIN('272520200600'O));
DCL EOF       UBIN WORD STATIC INIT(BITBIN('202546262020'O));
DCL EOR       UBIN WORD STATIC INIT(BITBIN('202546512020'O));
DCL   FIRST_ALTER   BIT(1)  STATIC INIT(%NO#);
/*  FIRST_ALTER IS A SWITCH USED TO INDICATE THE FIRST ALTER OF A MODULE
    SO THE FILE OF THAT NAME CAN BE OPENED  */
DCL BCD_BLANK      UBIN(6)  STATIC INIT(BITBIN('20'O));
DCL ASCII_BLANK    CHAR(1)  STATIC INIT(' ');
DCL CMPRS     BIT(1) STATIC INIT(%NO#);
/*  CMPRS IS A FLAG INDICATING IF WE ARE PROCESSING
    A COMPRESSED DECK */
DCL A_CMPRS   BIT(1) STATIC INIT(%NO#);
/*  A_CMPRS IS THE ASCII COMPRESS FLAG
*/
DCL  OUTPUT_FILE   BIT(1) STATIC INIT(%NO#);
/*  OUTPUT_FILE IS A FLAG INDICATING IF A THE OUTPUT FILE
    HAS BEEN OPENED  IT REALLY INDICATES FIRST TIME PROCCESSING
*/
DCL  EOF_FLAG           BIT(1)  STATIC  INIT(%NO#);
/*  EOF INDICATES THAT A VALID EOF (OF SOME TYPE) WAS
        DETECTED ON THE LAST PHYSICAL READ AND THAT
        ON THE NEXT LOGICAL READ WRAP_UP IS TO BE CALLED
*/
DCL DKEND_FLAG     BIT(1) STATIC INIT(%NO#);
/*  DKEND_FLAG INDICATES IF A DKEND CARD AND THERE FOR
    AN OBJECT DECK HAS BEEN ENCOUNTERED
    THIS AFFECTS TERMINATION IN THAT IF AN OBJECT
    DECK HAS BEEN ENCOUNTERED ONLYT THE FIRST
    PHYSICAL FILE WILL BE PROCESSED
*/
DCL  REC_CMPRS     BIT(1) STATIC INIT(%YES#);
/*  REC_CMPRS  IS A FLAG CONTROLLING THE COMPRESSION OF TRAILING
    BLANKS OF THE RECORD  DEFAULT IS TO COMPRESS THE BLANKS OUT
    THE OPTION  NOCOM  CHANGES THE FLAG TO %NO# AND NO
    COMPRESSION OCCURS
*/
DCL REC_PARTIAL    BIT(1) STATIC INIT(%NO#);
/*  REC_PARTIAL  IS A FLAG CONTROLLING THE COMPRESSION OF
    TRAILING BLANKS   IT IS SET BY THE PARTIAL
    OPTION ON THE COMMAND LINE AND DEFAULTS TO %NO# (NO PARTIAL)
    IF INVOKED COMPRESSION TAKES PLACE BUT IS NODIFIED SUCH
    THAT THE LAST BLANK AFTER THE DATA IS LEFT IN THE RECORD
*/
DCL BLANK_YES      BIT(1) STATIC INIT(%NO#);
/*  BLANK_YES  IS A FLAG INDICATING IF AT LEAST 1
    BLANK WAS COMPRESSED.  IT IS USED IN COMJUNCTION WITH THE
    PARTIAL COMPRESSION FLAG
*/
DCL  DOLLAR     CHAR(7) STATIC INIT('$');
/* THE FOLLOWING TABLE IS THE BCD TO ASCII
    TRANSLITERATIN TABLE FOR THE XLATE ROUTINE
*/
DCL BCD_ASCII_TABLE  (0:63) STATIC CHAR(1) INIT
    ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     '[', '#', '@', ':', '>', '?', ' ', 'A', 'B', 'C',
     'D', 'E', 'F', 'G', 'H', 'I', '&', '.', ']', '(',
     '<', '\', '^', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
     'Q', 'R', '-', '$', '*', ')', ';', '''', '+', '/',
     'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', ',',
     '%', '=', '"', '!');
/*       ERROR    MESSAGES   */
DCL BAD_GCS_LBL    CHAR(18) STATIC INIT('NO EOF AFTER LABEL');
DCL NOT_GCS_TAPE   CHAR(18) STATIC INIT('INVALID TAPE LABEL');
DCL TWO_EOFS       CHAR(34) STATIC INIT
    ('TWO EOFS ENCOUNTERED IN SUCCESSION');
%EJECT;
/*
         INPUT BLOCK DEFINITION
    THE 1ST 1/2 WORD IS THE BLOCK SERIAL #  THIS IS NOT CHECKED
    THE 2ND 1/2 WORD IS THE NUMBER OF WORDS IN THE BLOCK
    SUBSEQUENT WORDS DEFINE INDIVIDUAL RECORDS AND ARE OF THE  FORM
    <RCW><DATA WORDS>
    THE 1ST 1/2 OF THE RCW IS THE NUMBER OF WORDS IN THE RECORD
    BITS 26-29 OF THE RCW DEFINE THE TYPE OF DATA IN THE RECORD
         SEE THE GMAP POCKET GUIDE OR THE FILE AND
         RECORD CONTROL NAMUAL FOR A MORE DETAILED
         DESCRIPTION
*/
DCL 1  IN_BLOCK  STATIC,
       2  BLK_CNT   UBIN(18) UNAL,
       2  BLK_SIZE  UBIN(18) UNAL,
       2  WORDS (0:318) UBIN(36),
       2  RCW (0:318) REDEF WORDS,
          3  RCW_WD      UBIN(18) UNAL,
          3  RCW_POS     UBIN(6) UNAL,
          3  RCW_MC      UBIN(6) UNAL,
          3  RCW_RC      UBIN(6) UNAL,
       2  IN_TYPE  (0:318) REDEF WORDS,
          3  TYPE_CARD        UBIN(12) UNAL,
          3  *           UBIN(24) UNAL,
       2  IN_CHAR_ASCII (0:1275) REDEF WORDS CHAR(1),
       2  IN_CHAR  (0:1913)  REDEF WORDS UBIN(6) UNAL;
DCL 1  IN_LBL  REDEF IN_BLOCK,
       2  IN_ID     UBIN WORD,
       2  IN_F1 (0:3)    UBIN WORD,
       2  IN_PTL         UBIN WORD,
       2  IN_F2 (0:313)  UBIN WORD;
DCL 1   IN_IMAGE                STATIC,
       2   IN_COLS1_72              CHAR(72)  UNAL,
       2   IN_COLS73_80,
          3    IN_MODULE          CHAR(4)  UNAL,
          3    IN_TRANSMITTAL      CHAR(4)  UNAL,
       2   IN_REST           CHAR(176)  UNAL;
DCL   IN_IMAGE_CHAR    REDEF  IN_IMAGE    CHAR(256);
%EJECT;
/*  OT_IMAGE IS THE OUTPUT RECORD IN ASCII */
DCL 1  OT_IMAGE  STATIC,
       2  OT_DLR_CARD         CHAR(7),
       2  OT_CARD_TYPE        CHAR(6),
       2  OT_REST_P1          CHAR(59),
       2  OT_MODULE_NAME      CHAR(4),
       2  OT_REST_P2          CHAR(180);
DCL OT_TRANS REDEF OT_IMAGE  CHAR(256);
DCL 1  OT_ALTERS REDEF OT_IMAGE,
       2  A_COL1  CHAR(1) UNAL,
       2  A_COLS2_64  CHAR(63)  UNAL,
       2  A_COLS65_77  CHAR(13)  UNAL,
       2  A_REST  CHAR(179)  UNAL;
/*   CTRS USED FOR CALCULATING ALTER NUM FOR INSERTING*/
/*  (ONE LESS THAN GCOS INSERTED ALTERS)  */
DCL 1 OT_COBOL_COPY    REDEF OT_IMAGE,
       2 *                   CHAR(7),
       2 APPEND_NAME           CHAR(32),
       2  *                   CHAR(217);
DCL 1 OT_END REDEF OT_IMAGE,
       2  OT_END_STAR         CHAR(5),
       2  *                   CHAR(251);
DCL OT_PLUS_END CHAR(4) STATIC INIT ('+END');
DCL OT_BUFFER CHAR(256) STATIC;
%EJECT;
DCL  CTRIN  UBIN WORD STATIC;
DCL  CTROUT  CHAR(5)  UNAL STATIC;
DCL  BINCTR  UBIN WORD  STATIC;
DCL RCW_OFF        UBIN HALF STATIC;
DCL CUR_CHR        UBIN HALF STATIC;
DCL FILLBLK        UBIN HALF STATIC;
DCL NO_CHAR        UBIN HALF STATIC;
DCL    H_COMMA_SRCH  CHAR(11) UNAL;
DCL  1 H_COMMA_STR (0:10) REDEF H_COMMA_SRCH BIT (9) UNAL;
DCL 1 I SBIN WORD;
DCL 1 NUMERIC_ANS BIT(1) STATIC INIT(%NO#);
DCL 1  H_ALTER  CHAR(79)  UNAL;
DCL 1  OLD_ALTER  REDEF  H_ALTER,
       2  OA1  CHAR(71)  UNAL,
       2   OA2   ,
          3  OA_MODULE_NAME  CHAR(4)  UNAL,
          3  OA_TRANSMITTAL  CHAR(4)  UNAL,
       2   OA3  REDEF OA2   CHAR(8)  UNAL;
DCL FLDA      UBIN  STATIC;             /* TOTAL FIELD SIZE                   */
DCL FLDB      UBIN  STATIC;             /* # CHARS IN FILE                    */
/*  X_CARD IS THE BCD RECORD TO BE CONVERTED AFTER
    BEING EXTRACTED FROM THE BLOCK
*/
DCL X_CHR     (0:255) UBIN BYTE UNAL;
DCL X_CHAR_ASCII (0:255) REDEF X_CHR CHAR(1);
DCL X_ALPHA    REDEF X_CHR CHAR(256);
DCL X_TTL     SBIN;                     /* TOTAL CHARS IN RECORD              */
DCL X_INDX    SBIN;
DCL LOOP_CNTL UBIN HALF;
DCL END_LP    UBIN  HALF;
/*  DECLARE POINTER FOR STACKS BLOCKS AND ALTRETS
*/
DCL B$TCB$    PTR SYMREF;
DCL B$JIT$    PTR SYMREF;
%B$TCB;
%B$ALT;
/*  CREATE A MACRO FOR SENDING MESSAGE TO TERMINAL */
%MACRO  SND_MSG(MSG=NIL);
         LO_WR.BUF_.BUF$ = ADDR(MSG);
         LO_WR.BUF_.BOUND=SIZEV(MSG);
         CALL M$WRITE(LO_WR);
%MEND;
%EJECT;
/*
              INITIALIZATION
INITIALIZATION READ THE LABEL VERIFIES THAT
IT STARTS WITH GE  60 AND IS FOLLOWED BY A TAPE MARK
AFTER THE LABEL HAS BEEN VERIFIED THE COMMAND LINE IS SCANNED
FOR THE OPTIONS 'APPEND' 'NOCOM' OR 'PARTIAL' AND THE
APPROPRIATE FLAGS SET
*/
INITIALIZATION:
         CALL M$WRITE(LO_WR);
         CALL M$OPEN(SI_OPN);
         CALL M$READ(SI_RD);
         IF IN_LBL.IN_ID ~= LBL THEN
            DO;
            %SND_MSG(MSG=NOT_GCS_TAPE);
            CALL M$ERR;
            END;
         CALL M$READ(SI_RD) ALTRET(INIT_ERROR);
         %SND_MSG(MSG=BAD_GCS_LBL);
         CALL M$ERR;
/*  THE INIT_ERROR ROUTINE CHECKS FOR
    AN EOF HAVING OCCURED ON THE 2ND READ
    IF SO THEN PROCESSING CONTINUES
    OTHERWISE A MESSAGE IS PRINTED AND THE
    JOB ERRED
*/
INIT_ERROR:
         IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~=%E$EOF THEN
            DO;
            %SND_MSG(MSG=BAD_GCS_LBL);
            CALL M$ERR;
            END;
         CALL M$READ(SI_RD);
         RCW_OFF = 0;
         CALL INDEX(X_INDX, 'APPEND', B$JIT$->B$JIT.CCBUF);
         IF X_INDX < B$JIT$->B$JIT.CCARS THEN
            DO;
            APPEND = 'APPEND';
            STAR_END_STAR = '*END*';
            END;
         CALL INDEX(X_INDX, 'NOCOM', B$JIT$->B$JIT.CCBUF);
         IF X_INDX < B$JIT$->B$JIT.CCARS THEN REC_CMPRS =%NO#;
         CALL INDEX(X_INDX, 'PARTIAL', B$JIT$->B$JIT.CCBUF);
         IF X_INDX < B$JIT$->B$JIT.CCARS THEN REC_PARTIAL =%YES#;
         CALL INDEX(X_INDX, 'NOSPLIT', B$JIT$->B$JIT.CCBUF);
         IF X_INDX < B$JIT$->B$JIT.CCARS THEN DOLLAR = '#$%&';
%EJECT;
/*
         IN_REC  REQUESTS THE NEXT ASCII RECORD FROM GET_RECORD
DETERMINES IF IT IS A GCOS CONTROL CARD AND WHAT TYPE
OF CONTROL CARD IT IS
IF IT IS A LANGUAGE CARD IT CLOSES THE CURRENT CP-6
FILE AND OPENS A NEW ONE WITH THE NEW MODULE NAME OR
RGTNNN (NNN IS THE MODULE SEQUENCE ON THE TAPE) IF THE
MODULE NAME IS BLANK OR ZEROS
IF IT IS A CONTROL CARD BUT NOT A LANGUAGE CARD IT IGNORES IT
UNLESS IT IS AN ENDEDIT OR DKEND CARD
    ENDEDIT CAUSES JOB TERMINATION
    DKEND   SETS THE DKEND_FLAG INDICATING AN OBJECT DECK
ALL OTHER RECORDS ARE ASSUMED DATA AND ARE WRITTEN TO THE FILE
IF THE APPEND OPTION WAS SPECIFIED ON THE COMMAND LINE
INITIALIZATION WILL HAVE SET THE APPEND AND STAR_END_STAR
VARIABLES TO THE CORRECT VALUES.  THIS WILL CAUSE THE
INPUT FILE TO BE SPLIT INTO CP-6 FILES FOR EACH
BLOCK OF INPUT DATA DELIMITED BY 'APPEND ' AND '*END*'
THE FILE NAME IS DETERMINED FROM THE 'APPEND' LINE AND
THE *END* IS IGNORED.
THE APPEND OPTION IS FOR THE IMPORTING OF COBOL
INCLUDE FILES
*/
IN_REC:
         CALL GET_RECORD;
         OU_WR.BUF_.BOUND = X_TTL;
         OU_KEY.ACTUAL_KEY = OU_KEY.ACTUAL_KEY + 1000;
         IF OT_IMAGE.OT_DLR_CARD ~= DOLLAR AND
          OT_IMAGE.OT_DLR_CARD ~= APPEND AND
          OT_END.OT_END_STAR  ~= STAR_END_STAR THEN
            DO;
            CALL M$WRITE(OU_WR);
            GOTO IN_REC;
            END;
/*      MUST BE A $ OR APPEND OR *END*           */
         IN_IMAGE_CHAR = OT_TRANS;
         IF OT_IMAGE.OT_DLR_CARD ~= DOLLAR THEN
            DO;
            H_ALTER = SUBSTR(OT_IMAGE.OT_REST_P1,2);
            OLD_ALTER.OA3 = OT_IMAGE.OT_MODULE_NAME;
            CALL CONCAT
             (OT_IMAGE.OT_MODULE_NAME,'/*',IN_IMAGE.IN_COLS73_80.IN_TRANSMITTAL,'*/');
            OT_IMAGE.OT_REST_P2 = ' ';
            CALL M$WRITE(OU_WR);
            GOTO IN_REC;
            END;
%EJECT;
/*       MUST BE A $ CARD       */
         IF OT_IMAGE.OT_CARD_TYPE = DKEND THEN /* SKIP $      DKEND           */
            DO;
            DKEND_FLAG =%YES#;
            GOTO IN_REC;
            END;
         IF OT_IMAGE.OT_CARD_TYPE = ENDEDIT THEN CALL WRAP_UP;
         IF OT_IMAGE.OT_CARD_TYPE = UPDATE THEN
           DO;
            FIRST_ALTER =%YES#;
            GOTO IN_REC;
            END;
         IF OT_IMAGE.OT_CARD_TYPE = ALTER THEN
           DO;
           CALL ALTER_TO_PLUS;
           GOTO IN_REC;
           END;
         IF OT_IMAGE.OT_CARD_TYPE ~= CBL74 AND /* IGNORE UNKNOWN $     PROCS  */
          OT_IMAGE.OT_CARD_TYPE ~= CBL68       AND
          OT_IMAGE.OT_CARD_TYPE ~= COBOL       AND
          OT_IMAGE.OT_CARD_TYPE ~= IDS2        AND
          OT_IMAGE.OT_CARD_TYPE ~= FORTRAN     AND
          OT_IMAGE.OT_CARD_TYPE ~= PL1         AND
          OT_IMAGE.OT_CARD_TYPE ~= GMAP        AND
          OT_IMAGE.OT_CARD_TYPE ~= ALGOL       AND
          OT_IMAGE.OT_DLR_CARD  ~= APPEND      AND
          OT_IMAGE.OT_CARD_TYPE ~= OBJECT THEN GOTO IN_REC;
         CALL NEW_FILE;
         GOTO IN_REC;
%EJECT;
ALTER_TO_PLUS: PROC;
         OT_ALTERS.A_COL1 = '+';
         H_ALTER = SUBSTR(OT_IMAGE.OT_REST_P1,2);
         H_COMMA_SRCH = H_ALTER;
         CALL INDEX1(CTRIN,',',H_COMMA_SRCH)ALTRET(NOCOMMA);
M_A_NEXT:
         OT_ALTERS.A_COLS2_64 = H_ALTER;
         CALL CONCAT
          (OT_ALTERS.A_COLS65_77,
          '/*',
          OT_IMAGE.OT_MODULE_NAME,
          '#',
          IN_IMAGE.IN_COLS73_80.IN_TRANSMITTAL,
          '*/');
         OT_ALTERS.A_REST = ' ';
         CALL M$WRITE(OU_WR);
         RETURN;
NOCOMMA:
         CALL INDEX1(CTRIN,' ',H_COMMA_SRCH);
         CALL NUMERIC;
         IF NUMERIC_ANS THEN
           DO;
           CALL CHARBIN(BINCTR,SUBSTR(H_COMMA_SRCH,0,CTRIN));
           BINCTR = BINCTR-1;
           CALL BINCHAR(CTROUT,BINCTR);
           CALL INSERT(H_ALTER,,5,CTROUT);
           END;
         GOTO M_A_NEXT;
END ALTER_TO_PLUS;
%EJECT;
NUMERIC: PROC;
         NUMERIC_ANS = %YES#;
         DO I = 0 TO CTRIN-1;
         IF H_COMMA_STR(I) < '060'O OR
            H_COMMA_STR(I) > '071'O THEN NUMERIC_ANS = %NO#;
         END;
         RETURN;
END NUMERIC;
%EJECT;
/*
    THE GET_RECORD ROUTINE DEBLOCKS THE BUFFER
DECOMPRESSES THE RECORD IF NECESSARY
MOVES THE 6 BIT DATA TO 9 BIT CHAR AND XLATES
OR IT MOVE THE ASCII DATA OR OBJECT DATA AS 9 BIT BYTES
    TO 9 BIT ASCII CHARS
AND RETURNS THE ASCII RECORD
*/
%MACRO  BLK_UP;
         IN_BLOCK.BLK_SIZE = IN_BLOCK.BLK_SIZE - (IN_BLOCK.RCW.RCW_WD
          (RCW_OFF) + 1);
         IF IN_BLOCK.BLK_SIZE = 0 THEN CALL GET_BLOCK;
         ELSE RCW_OFF = RCW_OFF + IN_BLOCK.RCW.RCW_WD(RCW_OFF) + 1;
         IF IN_BLOCK.WORDS(RCW_OFF) = BITBIN('000000170000'O) THEN
            CALL GET_BLOCK;
%MEND;
/*
*/
GET_RECORD:  PROC;
         IF EOF_FLAG THEN CALL WRAP_UP;
         X_INDX = 0;
         IF CMPRS THEN GOTO DECOMPRESS;
NXTREC:
         DO CASE(IN_BLOCK.RCW.RCW_MC(RCW_OFF));
          CASE(8);
            %BLK_UP;
            GOTO NXTREC;                /* IGNORE TSS RECORD                  */
          CASE(0, 2, 3);
           DO;
           CALL MOVE_BCD;
           RETURN;
           END;
          CASE(1);
            IF IN_BLOCK.IN_TYPE.TYPE_CARD(RCW_OFF + 1) =BITBIN('5005'O)
            THEN GOTO START_DECOMPRESS;
            ELSE DO;
               IF IN_BLOCK.IN_TYPE.TYPE_CARD(RCW_OFF+1) =
                BITBIN('5015'O) THEN
                  DO;
                  A_CMPRS =%YES#;
                  GOTO START_DECOMPRESS;
                  END;
               END;
          END;
         CALL MOVE_ASCII;
         RETURN;
%EJECT;
/*
COMPRESSED DECK FORMAT IS DESCRIBED IN THE GMAP POCKET GUIDE IN FULL
     1ST WORD IS BINARY AND COMPRESSED INDICATOR
     2ND WORD IS CHECKSUM  (NOT CHECKED)
     3RD TO 24TH WORD ARE DATA
     25TH TO27TH ARE HOLLERITH SEQUENCE OR ZEROS (NOT CHECKED)
DATA IS OF THE FORM -
<FIELDA><FIELDB><DATA>
WHERE <FIELD A> IS LENGTH OF THE FIELD WITH 3 EXCEPTIONS
              1 -  = 0 => CONTINUE DECOMPRESSION ON NEXT CARD
              2 -   = 77 (OCTAL) => END OF LOGICAL CARD
              3 -  = 76  (OCTAL) => END OF DECK
      <FIELD B> IS # OF NON BLANK CHARS
<DATA> ARE THE NON BLANK CHARS
*/
START_DECOMPRESS:
         CMPRS =%YES#;
         IF A_CMPRS THEN CUR_CHR = (RCW_OFF + 3) * 4 - 1;
         ELSE CUR_CHR = (RCW_OFF + 3) * 6 - 1;
DECOMPRESS:
         CUR_CHR = CUR_CHR + 1;
NXT_FLD:
         IF A_CMPRS THEN CALL CHARBIN(FLDA, IN_BLOCK.IN_CHAR_ASCII(CUR_CHR));
         ELSE FLDA = IN_BLOCK.IN_CHAR(CUR_CHR);
         IF FLDA = 0 THEN
            DO;
            %BLK_UP;
            GOTO START_DECOMPRESS;
            END;
         IF FLDA = 63 THEN
            DO;
            IF X_INDX = 0 THEN
               DO;
               X_TTL = 0;
               IF A_CMPRS THEN X_CHAR_ASCII(0) = ASCII_BLANK;
               ELSE X_CHR(0) = BCD_BLANK;
               END;
            ELSE X_TTL = X_INDX - 1;
            IF A_CMPRS THEN
              DO;
               CALL ASCII_TRUNC;
               RETURN;
              END;
            ELSE
              DO;
              CALL BCD_TRUNC;
              RETURN;
              END;
            END;
         IF FLDA = 62 THEN
            DO;
            %BLK_UP;
            CMPRS =%NO#;
            A_CMPRS =%NO#;
            GOTO NXTREC;
            END;
         CUR_CHR = CUR_CHR + 1;
         IF A_CMPRS THEN CALL CHARBIN(FLDB, IN_BLOCK.IN_CHAR_ASCII(CUR_CHR));
         ELSE FLDB = IN_BLOCK.IN_CHAR(CUR_CHR);
         FILLBLK = FLDA - FLDB;
         DO WHILE (FILLBLK > 0);
            IF A_CMPRS THEN X_CHAR_ASCII(X_INDX) = ASCII_BLANK;
            ELSE X_CHR(X_INDX) = BCD_BLANK;
            FILLBLK = FILLBLK - 1;
            X_INDX = X_INDX + 1;
            END;
         END_LP = X_INDX + FLDB - 1;
         DO LOOP_CNTL = X_INDX TO END_LP;
            CUR_CHR = CUR_CHR + 1;
            IF A_CMPRS THEN X_CHAR_ASCII(LOOP_CNTL) =
                IN_BLOCK.IN_CHAR_ASCII(CUR_CHR);
            ELSE X_CHR(LOOP_CNTL) = IN_BLOCK.IN_CHAR(CUR_CHR);
            END;
         CUR_CHR = CUR_CHR + 1;
         X_INDX = X_INDX + FLDB;
         GOTO NXT_FLD;
END GET_RECORD;
%EJECT;
/*  ALL OTHER MEDIA CODES ARE ASSUMED ASCII
THIS INCLUDES TRUE OBJECT DECKS
*/
MOVE_ASCII: PROC;
         X_TTL = IN_BLOCK.RCW.RCW_WD(RCW_OFF) * 4 - 1;
         IF IN_BLOCK.RCW.RCW_POS(RCW_OFF) = BITBIN('60'O)
         THEN X_TTL = X_TTL - 1;
         ELSE IF IN_BLOCK.RCW.RCW_POS(RCW_OFF) = BITBIN('40'O)
            THEN X_TTL = X_TTL - 2;
            ELSE IF IN_BLOCK.RCW.RCW_POS(RCW_OFF) = BITBIN('20'O)
               THEN X_TTL = X_TTL - 3;
         CUR_CHR = (RCW_OFF + 1) * 4 ;
         DO X_INDX = 0 TO X_TTL;
            X_CHAR_ASCII(X_INDX) = IN_BLOCK.IN_CHAR_ASCII(CUR_CHR +X_INDX);
            END;
           CALL ASCII_TRUNC;
           RETURN;
END MOVE_ASCII;
%EJECT;
MOVE_BCD: PROC;
/* SET # OF CHARS - MEDIA CODE 2 CAN ONLY HAVE 79
EVEN THOUGH RCW SAYS 84
*/
         IF IN_BLOCK.RCW.RCW_MC(RCW_OFF) = 2 THEN X_TTL = 79;
         ELSE X_TTL = IN_BLOCK.RCW.RCW_WD(RCW_OFF) * 6 - 1;
         CUR_CHR = (RCW_OFF + 1) * 6;
         DO X_INDX = 0 TO X_TTL;
            X_CHR(X_INDX) = IN_BLOCK.IN_CHAR(CUR_CHR + X_INDX);
            END;
         CALL BCD_TRUNC;
         RETURN;
END MOVE_BCD;
%EJECT;
ASCII_TRUNC: PROC;
         OT_TRANS = X_ALPHA;
/*  THE FOLLOWING CODE DOES THE COMPRESSION OF THE TRAILING BLANKS
    UNLESS THE  NOCOM  OPTION WAS ON THE COMMAND LINE
    IN WHICH CASE THE CODES IS BYPASSED
    THE BLANK_YES  FLAG IS SET IF A T LEASE ONE BLANK WAS
    ENCOUNTERED
    IF THE PARTIAL  OPTION WAS ON THE COMMAND LINE AND
    BLANK_YES =%YES# THEN THE LAST BLANK AFTER THE
    NONE BLANK DATA IS INCLUDED IN THE RECORD
*/
/*   SCAN BACKWARDS FROM X_TTL TO FIND THE LENGTH OF THE
     RECORD WITH NO TRAILING BLANKS.
*/
         IF ~REC_CMPRS THEN GOTO AFTER_ASCII_CMPRS;
         IF IN_BLOCK.RCW.RCW_MC(RCW_OFF) ~= 1 THEN
            DO;
            X_INDX = 1;
            IF APPEND = 'APPEND' THEN X_TTL = 71;
            BLANK_YES =%NO#;
            DO WHILE (X_INDX > 0);
               IF X_CHAR_ASCII(X_TTL) ~= ' ' THEN X_INDX = 0;
               ELSE DO;
                  X_TTL = X_TTL - 1;
                  BLANK_YES =%YES#;
                  END;
               IF X_TTL <= 0 THEN
                  DO;
                  X_TTL = 0;
                  X_INDX = 0;
                  END;
               END;
            IF REC_PARTIAL AND BLANK_YES THEN X_TTL = X_TTL + 1;
            END;
AFTER_ASCII_CMPRS:
         %BLK_UP;
         RETURN;
END ASCII_TRUNC;
%EJECT;
BCD_TRUNC: PROC;
         CALL XLATE(OT_TRANS,BCD_ASCII_TABLE, X_ALPHA);
/*
THE FOLLOWING CODE SCANS BACKWARDS TO DETERMINE THE
NON_BLANK LENGTH OF THE RECORD
IF THE MEDIA CODE IS 2 OR THE FILE IS COMPRESSED AND
THERE ARE MORE THAN 72 CHARACTERS THE SCAN WILL START IN
CARD COL 72
THE  NOCOM  OPTION ON THE COMMAND LINE CAUSES THE BYPASS OF THE CODE AND
THE PARTIAL OPTION CAUSES ICLUSION OF THE LAST BLANK
AFTER THE DATA
*/
         IF ~REC_CMPRS THEN GOTO AFTER_BCD_CMPRS;
         IF IN_BLOCK.RCW.RCW_MC(RCW_OFF) = 2 OR
          (CMPRS AND X_TTL > 71) THEN X_TTL = 71;
         X_INDX = 1;
         BLANK_YES =%NO#;
         DO WHILE(X_INDX > 0);
            IF X_CHR(X_TTL) ~= BCD_BLANK THEN X_INDX = 0;
            ELSE DO;
               X_TTL = X_TTL - 1;
               BLANK_YES =%YES#;
               END;
            IF X_TTL <= 0 THEN
               DO;
               X_TTL   = 0;
               X_INDX  = 0;
               END;
            END;
         IF REC_PARTIAL AND BLANK_YES THEN X_TTL = X_TTL + 1;
AFTER_BCD_CMPRS:
         IF ~ CMPRS THEN
            DO;
            %BLK_UP;
            END;
         RETURN;
END BCD_TRUNC;
%EJECT;
/*  THE GET BLOCK ROUTINE GETS ALL PHYSICAL BLOCKS
AFTER THE INITIAL READS BY INITIALIZATION AND CHECKS
ALL EOFS
WHEN AN EOF IS ENCOUNTERED THE NEXT BLOCK IS READ
IF AN OBJECT DECK HAS BEEN ENCOUNTERED, PROCESSING IS TERMINATED.
NORMALLY.  THIS IS NECESSARY AS A FILEDIT OBJECT TAPE
CONTAINS THE FILE OF CHANGES AS THE SECOND PHYSICAL FILE
AND WE DON'T WANT IT
IF AN EOF LABEL IS READ IT IS IGNORED
IF AN EOR LABEL IS READ PROCESSING IS TERMINATED
IF A GE 600 LABEL IS READ WORD 6 IS CHECKED FOR ZEROS IF IT IS
ZEROS THEN PROCESSING IS TERMINATED OTHER WISE THE LABEL IS
IGNORED    IF NO LABELS ARE READ THEN A DATA BLOCK IS ASSUMED
*/
GET_BLOCK: PROC;
GET_BLK_INTERNAL:
         CALL M$READ(SI_RD) ALTRET(SI_READ_ERROR);
         RCW_OFF = 0;
         RETURN;
SI_READ_ERROR:
         IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~=%E$EOF
         THEN CALL M$MERC;
         IF DKEND_FLAG THEN EOF_FLAG =%YES#;
         CALL M$READ(SI_RD) ALTRET(SI_SECOND_ERROR);
         IF IN_LBL.IN_ID = EOF THEN GOTO GET_BLK_INTERNAL;
         IF IN_LBL.IN_ID = EOR THEN EOF_FLAG =%YES#;
         IF IN_LBL.IN_ID = LBL THEN
            IF IN_LBL.IN_PTL = 0 THEN EOF_FLAG =%YES#;
            ELSE GOTO GET_BLK_INTERNAL;
         RCW_OFF = 0;
         RETURN;
SI_SECOND_ERROR:
         IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# =%E$BLNKTP
         THEN CALL WRAP_UP;
         IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~=%E$EOF
         THEN CALL M$MERC;
         %SND_MSG(MSG=TWO_EOFS);
         CALL WRAP_UP;
END GET_BLOCK;
%EJECT;
/*      MUST BE ONE OF THE ABOVE PROCESSOR CARDS           */
NEW_FILE: PROC;
         IF FIRST_ALTER THEN
           DO;
           OT_BUFFER = ' ';
           OT_BUFFER = OT_PLUS_END;
           CALL M$WRITE(OT_WR);         /*  WRITE LAST +END CARD              */
           OT_IMAGE.OT_DLR_CARD = '+END';
           CALL M$WRITE(OU_WR);         /*  WRITE LAST +END CARD              */
           END;
         IF OUTPUT_FILE THEN CALL M$CLOSE(OU_CLS);
         OUTPUT_FILE =%YES#;
         FIRST_ALTER=%NO#;
         RGT_FILE_SEQ = RGT_FILE_SEQ + 1;
         OU_KEY.ACTUAL_KEY = 0;
/*
    SET MODULE NAME AND LENGTH OF NAME
*/
         IF OT_IMAGE.OT_DLR_CARD ~= APPEND THEN
            DO;
            IF OT_IMAGE.OT_MODULE_NAME = ' ' OR
             OT_IMAGE.OT_MODULE_NAME = '0000' THEN
               DO;
               CALL BINCHAR(RGT_FILE.RGT_FILE_ID, RGT_FILE_SEQ);
               OU_NAME.NAME# = RGT_CHR;
               OU_NAME.L#    = SIZEC(RGT_CHR);
               END;
            ELSE
               DO;
               CALL INDEX1(X_INDX, ASCII_BLANK, OT_IMAGE.OT_MODULE_NAME);
               OU_NAME.NAME# = OT_IMAGE.OT_MODULE_NAME;
               OU_NAME.L#    = X_INDX;
               END;
            END;
         ELSE
            DO;
/*          $      APPEND                               */
            CALL INDEX1(X_INDX, ASCII_BLANK, OT_COBOL_COPY.APPEND_NAME);
            OU_NAME.NAME# = OT_COBOL_COPY.APPEND_NAME;
            OU_NAME.L#    = X_INDX;
            END;
         CALL M$OPEN(OU_OPN);
         FILE_MSG.FILE_NAME = OU_NAME.NAME#;
         FILE_MSG.PROC_MSG = OT_IMAGE.OT_CARD_TYPE;
         LO_WR.BUF_.BUF$=ADDR(FILE_MSG);
         LO_WR.BUF_.BOUND=SIZEV(FILE_MSG);
         CALL M$WRITE (LO_WR);
         RETURN;
END NEW_FILE;
%EJECT;
/*
    THE WRAP UP ROUTINE CLOSES THE INPUT AND LAST
OUTPUT FILE AND PRINTS THE MESSAGE STATING HOW MANY
MODULES WERE PROCESSED
*/
WRAP_UP: PROC;
         CALL M$CLOSE(SI_CLS);
         CALL M$CLOSE(OU_CLS);
         MODULE_MSG.MOD_NAME = OU_NAME.NAME#;
         CALL BINCHAR(MODULE_MSG.MOD_CNT, RGT_FILE_SEQ);
         %SND_MSG(MSG=MODULE_MSG);
         CALL M$EXIT;
END WRAP_UP;
END RGT;
