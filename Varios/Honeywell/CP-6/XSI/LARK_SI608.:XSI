/*M* LARK_SI608 LARK_LARKETTE_CMDS commands to run LARKETTE station */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*P*
   NAME:          LARK_LARKETTE_CMDS
   PURPOSE:       Contains the commands related to use of LARKETTE
*/
%EJECT ;
/*T*/
/*F*
   NAME:          LARK_DEFINESTA_CMD
   PURPOSE:       Process the DEFINESTA command
   DESCRIPTION:   This module receives the parse tree for a DEFINESTA command
                  and initializes the selected information for the selected
                  LARKETTE station.
*/
/*D*
   NAME:          LARK_DEFINESTA_CMD
   CALL:          CALL LARK_DEFINESTA_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_ABNORMAL_LARKETTE_MESSAGE
                  LARK_CGINFO_WITH_DATASEG
                  LARK_CHECK_AUEVENT
                  LARK_CHECK_NWIO_ERRORS
                  LARK_CLOSE_TEMPSTATION
                  LARK_INTERNAL_ERROR
                  LARK_OPEN_TEMPSTATION
                  LARK_RELEASE_DATA_SEGMENT
                  LARK_REPORT_PMME_ERROR
                  LARK_REPORT_SUBCMD_ERROR
                  LARK_READ_MESSAGE
                  LARK_WRITE_MESSAGE
   INTPUT:        PARSE$OUT
   OUTPUT:        FUNCTION structure
   DESCRIPTION:   DEFINESTA_CMD syntax =
                     'DEF/[INE]STATION' ;
                     STATION ;
                     DEFINESTA_OPTION_LIST
*/
 
%EJECT ;
LARK_DEFINESTA_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
%INCLUDE F$CP6V_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XU_PERR_C ;
%INCLUDE XUF_ENTRY ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_ABNORMAL_LARKETTE_MESSAGE ;
%LARK_CGINFO_WITH_DATASEG ;
%LARK_CHECK_AUEVENT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_OPEN_TEMPSTATION ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_SUBCMD_ERROR ;
%LARK_READ_MESSAGE ;
%LARK_WRITE_MESSAGE ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME           = P_OUT$BLK,
         STCLASS        = "" ) ;
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_LENGTH#-3
   MESSAGE0:      An unacceptable message length has been specified
   MESSAGE1:      The minimum length is 8 bytes;  the maximum length is 4096 bytes
   DESCRIPTION:   User must select a value of 8-4096 bytes.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMOPS#-3
   MESSAGE0:      An unacceptable number of operations has been specified
   MESSAGE1:      Choose a number greater than 0
   MESSAGE2:      The station is required to do at least one operation
   DESCRIPTION:   Must do at least one operation.
*/
 
/*E*
   ERROR:         LAR-E$LARK_CMD_NOT_PERFORMED#-3
   MESSAGE0:      The command just given was not performed
   MESSAGE1:      See accompanying error messages for an explanation
   DESCRIPTION:   Various reasons exist for why an operation can not be completed.
*/
 
/*E*
   ERROR:         LAR-E$LARK_CONTROL_PARMS_USELESS#-3
   MESSAGE0:      Specification of control parameters for a currently running station is useless
   MESSAGE1:      Control parameters are only used during the startup of a new ghost
   DESCRIPTION:   The control parms are only used for the call to M$GJOB.
*/
 
/*E*
   ERROR:         LAR-E$LARK_NO_LARKETTE_CONTROL_STA#-3
   MESSAGE0:      A new function station cannot be started without a corresponding control station
   MESSAGE1:      A station must be specified within the CONTROL option
   DESCRIPTION:   Each LARKETTE has a function station and a control station.
                  The control station is used to communicate with LARK.
*/
 
/*E*
   ERROR:         LAR-E$LARK_NO_LARK_DCBSTATION#-3
   MESSAGE0:      This command cannot be performed without an open LARK user DCB station
   MESSAGE1:      Use the OPEN command to provide a LARK user DCB station
   DESCRIPTION:   LARK needs a control station to communicate with LARKETTE
*/
 
/*E*
   ERROR:         LAR-E$LARK_NOT_IMPLEMENTED#-3
   MESSAGE0:      This capability is not implemented;  this paramater will be ignored
   MESSAGE1:      LARKETTE is not currently set up to do this
   DESCRIPTION:   Catchall error for parameters that, if allowed to be used,
                  would mess LARKETTE up.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_CGINFO ;
%LARK_PARSEBLKS ;
%LARK_NAMELIST ;
%LARKETTE_CONTROL_BUFFER ( NAME = WRITE_CONTROL_BUFFER ) ;
%LARKETTE_FUNCTION ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_GJOB
          ( FPTN                 = FPT_GJOB,
            STCLASS              = CONSTANT,
            ACCT                 = VLP$ACCT,
            NAME                 = VLP$NAME,
            PASS                 = VLP$PASS,
            RESULTS              = VLR$GJOB,
            SLEAZE               = NO,
            TPU                  = NO ) ;
 
%FPT_GJOB
          ( FPTN                 = FPTGJOB,
            STCLASS              = AUTO ) ;
 
%FPT$READ_V ;
 
%FPT_READ
          ( FPTN                 = FPT_READ,
            STCLASS              = CONSTANT ) ;
 
%FPT_UNFID
          ( FPTN                 = FPT_UNFID,
            STCLASS              = CONSTANT,
            DCB                  = M$CTRLCG,
            LEN                  = FID_LEN ) ;
 
%FPT_UNFID
          ( FPTN                 = FPTUNFID,
            STCLASS              = AUTO ) ;
 
%FPT_WAIT
          ( FPTN                 = FPT_WAIT,
            STCLASS              = CONSTANT,
            UNITS                = 2 ) ;
 
%FPT_WAIT
          ( FPTN                 = FPTWAIT,
            STCLASS              = AUTO ) ;
 
%FPT$WRITE_V ;
 
%FPT_WRITE
          ( FPTN                 = FPT_WRITE,
            STCLASS              = CONSTANT ) ;
 
%VLP_ACCT
          ( FPTN                 = VLP$ACCT,
            STCLASS              = STATIC ) ;
 
%VLP_NAME
          ( FPTN                 = VLP$NAME,
            STCLASS              = STATIC,
            LEN                  = 31 ) ;
 
%VLP_PASS
          ( FPTN                 = VLP$PASS,
            STCLASS              = STATIC ) ;
 
%VLP_SETSTA
          ( FPTN                 = VLP_SETSTA,
            STCLASS              = CONSTANT ) ;
 
%VLP_SETSTA
          ( FPTN                 = VLP$SETSTA,
            STCLASS              = BASED ) ;
 
%VLP_STATION
          ( FPTN                 = VLP_STATION,
            STCLASS              = CONSTANT ) ;
 
%VLP_STATION
          ( FPTN                 = VLP$STATION,
            STCLASS              = BASED ) ;
 
%VLR_GJOB
          ( FPTN                 = VLR$GJOB,
            STCLASS              = STATIC ) ;
 
%EQU        READ                 = 1 ;
%EQU        WRITE                = 2 ;
 
/*
   Local data
*/
 
DCL         B$TCB$               PTR SYMREF ;
DCL         BLK$                 PTR ;
DCL         CCBUF$               PTR ;
DCL         CCBUF                CHAR ( CCBUF_LEN ) BASED ;
DCL         CCBUF_LEN            UBIN ;
DCL         DONE                 BIT ( 1 ) UNAL ;
DCL         FID_LEN              UBIN STATIC ;
DCL         NEW_GHOST            BIT ( 1 ) UNAL ;
DCL         I                    SBIN ;
DCL         STA$                 PTR ;
DCL         STA_IDX              SBIN ;
DCL         SUBLK$               PTR ;
DCL         SYM$                 PTR ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %DEFINESTA_CMD ) OR ( P_OUT$BLK.NSUBLKS ~= 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
/*
   Make sure a control station is open in LARK.
*/
 
IF NOT M$CTRLCG$->F$DCB.FCD# THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_LARK_DCBSTATION#,
                                3 ) ;
   GOTO ALT ;
END ;
 
/*
   Processing the function station name parameter.
*/
 
NEW_GHOST = %FALSE ;
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
IF ( BLK$->OUT$SYM.CODE ~= %STATION ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT;
END ; ELSE DO ;
   NEW_GHOST = %TRUE ;
   STA_IDX = 0 ;
   DO WHILE ( STA_IDX < NAMELIST_CT ) AND ( BLK$->OUT$SYM.TEXT ~= NAMELIST.FUNCTION_STA# ( STA_IDX ) ) ;
      STA_IDX = STA_IDX + 1 ;
   END ;
   IF ( STA_IDX = NAMELIST_CT ) THEN DO ;
      STA_IDX = 0 ;
      DO WHILE ( STA_IDX < NAMELIST_CT ) AND ( NAMELIST.FUNCTION_STA# ( STA_IDX ) ~= ' ' ) ;
         STA_IDX = STA_IDX + 1 ;
      END ;
      NAMELIST.FUNCTION_STA# ( STA_IDX ) = BLK$->OUT$SYM.TEXT ;
      NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ;
      NAMELIST.GHOST_SYSID# ( STA_IDX ) = 0 ;
      IF ( STA_IDX = NAMELIST_CT ) THEN DO ;
         NAMELIST_CT = NAMELIST_CT + 1 ;
      END ;
   END ;
END ;
 
/*
   Initializing the ghost job startup structure (if NEW_GHOST = true ).
*/
 
FPTGJOB = FPT_GJOB ;
FPTGJOB.V_ = VECTOR ( FPTGJOB.V ) ;
 
/*
   Initializing the FUNCTION structure.
*/
 
FUNCTION.READ.MAXLEN# = 1024 ;
FUNCTION.READ.NUMOPS# = 1 ;
FUNCTION.READ.FREQ# = 0 ;
FUNCTION.READ.MSGFILE# = ' ' ;
FUNCTION.READ.NEWMSGFILE# = %NO# ;
FUNCTION.READ.ERR_ABORT# = %NO# ;
FUNCTION.READ.FLAG# = %NO# ;
FUNCTION.WRITE.MINLEN# = 1024 ;
FUNCTION.WRITE.MAXLEN# = 1024 ;
FUNCTION.WRITE.NUMOPS# = 1 ;
FUNCTION.WRITE.FREQ# = 0 ;
FUNCTION.WRITE.MSGFILE# = ' ' ;
FUNCTION.WRITE.ERR_ABORT# = %NO# ;
FUNCTION.WRITE.FLAG# = %NO# ;
FUNCTION.ADMIN = '0'B ;
FUNCTION.ADMIN.ACTIVATE# = %NO# ;
FUNCTION.ADMIN.AU# = %NO# ;
FUNCTION.ADMIN.COMP_ABORT# = %YES# ;
FUNCTION.ADMIN.COMP_DISC# = %YES# ;
FUNCTION.ADMIN.COMP_NEWDEF#  = %YES# ;
FUNCTION.READ_V = FPT_READ.V ;
FUNCTION.WRITE_V = FPT_WRITE.V ;
FUNCTION.READ_STATION = VLP_STATION ;
FUNCTION.WRITE_STATION = VLP_STATION ;
FUNCTION.SETSTA = VLP_SETSTA ;
FUNCTION.SETSTA.MYSTATION# = NAMELIST.FUNCTION_STA# ( STA_IDX ) ;
VLP$ACCT.ACCT# = ' ' ;
VLP$NAME.NAME# = ' ' ;
VLP$PASS.PASS# = ' ' ;
 
/*
   Processing the DEFINESTA_OPTION_LIST.
*/
 
BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
 
DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
   DO SELECT SUBLK$->OUT$BLK.CODE ;
      SELECT ( %ADMIN_OPT ) ;
         CALL ADMIN_DEFINESTA
               ALTRET ( ALT ) ;
 
      SELECT ( %CONTROL_OPT ) ;
         CALL CONTROL_DEFINESTA
               ALTRET ( ALT ) ;
 
      SELECT ( %READ_OPT ) ;
         CALL READ_DEFINESTA
               ALTRET ( ALT ) ;
 
      SELECT ( %READ_STATION_OPT ) ;
         CALL STATION_DEFINESTA ( %READ )
               ALTRET ( ALT ) ;
 
      SELECT ( %SETSTA_OPT ) ;
         CALL SETSTA_DEFINESTA
               ALTRET ( ALT ) ;
 
      SELECT ( %WRITE_OPT ) ;
         CALL WRITE_DEFINESTA
               ALTRET ( ALT ) ;
 
      SELECT ( %WRITE_STATION_OPT ) ;
         CALL STATION_DEFINESTA ( %WRITE )
               ALTRET ( ALT ) ;
 
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
 
   END ;
END ;
 
/*
   Start up a new LARKETTE ghost if one isn't already running.
*/
 
IF NEW_GHOST THEN DO ;
   IF ( NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ) THEN DO ;
      CALL GENERATE_CONTROL_STATION ( NAMELIST.CONTROL_STA# ( STA_IDX ) ) ;
   END ;
   IF NOT DEBUG THEN DO ;
      CALL INIT_CCBUF
            ALTRET ( ALT ) ;
      FPTGJOB.CCBUF_ = VECTOR ( CCBUF$->CCBUF ) ;
      IF VLP$ACCT.ACCT# = ' 'THEN DO ;
         FPTGJOB.ACCT_ = VECTOR ( NIL ) ;
      END ;
      IF VLP$NAME.NAME# = ' ' THEN DO ;
         FPTGJOB.NAME_ = VECTOR ( NIL ) ;
      END ;
      IF VLP$PASS.PASS# = ' ' THEN DO ;
         FPTGJOB.PASS_ = VECTOR ( NIL ) ;
      END ;
      CALL M$GJOB ( FPTGJOB )
            WHENALTRETURN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             M$CTRLCG_DCBNUM ) ;
               NAMELIST.FUNCTION_STA# ( STA_IDX ) = ' ' ;
               NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ;
               IF ( STA_IDX = ( NAMELIST_CT - 1 ) ) THEN DO ;
                  NAMELIST_CT = NAMELIST_CT - 1 ;
               END ;
               GOTO ALT ;
            END ;
      NAMELIST.GHOST_SYSID# ( STA_IDX ) = VLR$GJOB.SYSID ;
   END ;
 
   /*
      Make sure LARKETTE control station is connected to the comgroup before
      attempting to write a message to him (in case WAS=NO).
   */
   CALL LARK_OPEN_TEMPSTATION ( %FALSE )
         WHENALTRETURN DO ;
            GOTO ALT ;
         END ;
   DONE = %FALSE ;
   FPTWAIT = FPT_WAIT ;
   FPTWAIT.V_ = VECTOR ( FPTWAIT.V ) ;
   DO UNTIL DONE ;
      CALL M$WAIT ( FPTWAIT )
            WHENALTRETURN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             M$CTRLCG_DCBNUM ) ;
               CALL LARK_INTERNAL_ERROR ;
            END ;
      CALL LARK_CGINFO_WITH_DATASEG
            WHENALTRETURN DO ;
               GOTO ALT ;
            END ;
      STA$ = VBASE ( BITVECT ( FPT$CGINFO.STALIST_ ) ) ;
      I = 0 ;
      DO WHILE ( I < STA$->VLP_CGSTAL_CGINFO.FOUND# ) AND
         ( NAMELIST.CONTROL_STA# ( STA_IDX ) ~= STA$->VLP_CGSTAL_CGINFO.LIST.NAME# ( I ) ) ;
         I = I + 1 ;
      END ;
      IF ( I < STA$->VLP_CGSTAL_CGINFO.FOUND# ) THEN DO ;
         DONE = %TRUE ;
         CALL LARK_CLOSE_TEMPSTATION ;
      END ;
   END ;
 
END ;
 
/*
   Sending the function header and function block to LARKETTE.
*/
 
WRITE_CONTROL_BUFFER.CODE = %FUNCTION_BLK_HEADER ;
WRITE_CONTROL_BUFFER.STATION = NAMELIST.FUNCTION_STA# ( STA_IDX ) ;
VLP$STATION_CONTROL.STATION# = NAMELIST.CONTROL_STA# ( STA_IDX ) ;
CALL LARK_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                          VECTOR ( VLP$STATION_CONTROL ),
                          VECTOR ( WRITE_CONTROL_BUFFER ) )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_CMD_ERROR ( %E$LARK_CMD_NOT_PERFORMED#,
                                      3 ) ;
         GOTO ALT ;
      END ;
VLP$STATION_CONTROL.MSGTYP# = %FUNCTION_MSGTYP ;
CALL LARK_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                          VECTOR ( VLP$STATION_CONTROL ),
                          VECTOR ( FUNCTION ) )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_CMD_ERROR ( %E$LARK_CMD_NOT_PERFORMED#,
                                      3 ) ;
         GOTO ALT ;
      END ;
VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
 
/*
   Read for the result of this command.
*/
 
DONE = %NO# ;
DO UNTIL DONE ;
/*N*
   Should use EOFTIME=10 on all CONTROL station reads to avoid hanging on read.
*/
   CALL M$CHECK ( FPT$CHECK_NWIO )
         WHENALTRETURN DO ;
            IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$LD ) THEN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             M$CTRLCG_DCBNUM ) ;
               GOTO ALT ;
            END ;
         END ;
   CALL LARK_CHECK_NWIO_ERRORS
         ALTRET ( ALT ) ;
   IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
      CALL LARK_CHECK_AUEVENT
            ALTRET ( ALT ) ;
   END ; ELSE DO ;
      DO SELECT CONTROL_BUFFER.CODE ;
         SELECT ( %DEFINED_STATION ) ;
            DONE = %YES# ;
         SELECT ( %STATUS_ABORT_HEADER, %COMMAND_ERROR_RETURN, ELSE ) ;
            CALL LARK_ABNORMAL_LARKETTE_MESSAGE
                  ALTRET ( ALT ) ;
            IF ( CONTROL_BUFFER.CODE = %COMMAND_ERROR_RETURN ) OR ( STA_IDX >= NAMELIST_CT ) OR
                  ( NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ) THEN DO ;
               DONE = %YES# ;
            END ;
      END ;
   END ;
   VLP$STATION_CONTROL.STATION# = '?' ;
   CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                            VECTOR ( VLP$STATION_CONTROL ),
                            VECTOR ( CONTROL_BUFFER ) )
         WHENALTRETURN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
%EJECT ;
/*I*
   NAME:          GETCMD_SUB_ERROR
   PURPOSE:       To handle an error returned by XUG$GETCMD
   CALL:          CALL GETCMD_SUB_ERROR
   DESCRIPTION:   Reports the parser error and aborts.
*/
 
%EJECT ;
GETCMD_SUB_ERROR : PROC ;
 
CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
CALL XUG$ERRPTR ( XUG$GETCMD_SUB ) ;
XUG$GETCMD_SUB.ERRDCB# = DCBNUM ( NIL ) ;
XUG$GETCMD_SUB.ERR_CODE = XUG$GETCMD_SUB.ERR# ;
CALL XUG$ERRMSG ( XUG$GETCMD_SUB ) ;
CALL LARK_INTERNAL_ERROR ;
 
RETURN;
 
END GETCMD_SUB_ERROR ;
 
%EJECT ;
/*I*
   NAME:          GENERATE_CONTROL_STATION
   PURPOSE:       Generate a unique 8 character station name
   CALL:          CALL GENERATE_CONTROL_STATION ( STATION )
   DESCRIPTION:   Returns a unique LARKETTE control station name.
*/
 
%EJECT ;
GENERATE_CONTROL_STATION : PROC ( STATION ) ;
 
   DCL   STATION                 CHAR ( 8 ) ;
 
STATION = '$CON' ;
CALL BINCHAR ( SUBSTR ( STATION,
                        4,
                        4 ),
               CONTROL_STATIONX ) ;
CONTROL_STATIONX = CONTROL_STATIONX + 1 ;
 
RETURN;
 
END GENERATE_CONTROL_STATION ;
 
%EJECT ;
/*I*
   NAME:          INIT_CCBUF
   PURPOSE:       Set up the CCBUF to invoke LARKETTE when the ghost is started.
   CALL:          CALL INIT_CCBUF
   DESCRIPTION:   Places !LARKETTE.X (comgroup_fid,larkette_control,lark_control)
                  in the CCBUF.
*/
 
%EJECT ;
INIT_CCBUF : PROC ALTRET ;
 
   DCL   PTR$                    PTR ;
   DCL   LARKETTE                CHAR ( 0 ) CONSTANT INIT ( '!LARKETTE.X    (' ) ;
 
CCBUF$ = VLP$VECTOR_CGINFO_DATASEG.PTR$ ;
CCBUF_LEN = SIZEC ( LARKETTE ) ;
CCBUF$->CCBUF = LARKETTE ;
PTR$ = PINCRC ( CCBUF$,
                CCBUF_LEN ) ;
CCBUF_LEN = VLP$VECTOR_CGINFO_DATASEG.W1.VSIZE# - CCBUF_LEN ;
FPTUNFID = FPT_UNFID ;
FPTUNFID.V_ = VECTOR ( FPTUNFID.V ) ;
FPTUNFID.TEXTFID_ = VECTOR ( PTR$->CCBUF ) ;
CALL M$UNFID ( FPTUNFID )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CTRLCG_DCBNUM ) ;
         GOTO ALT ;
      END ;
CCBUF_LEN = SIZEC ( LARKETTE ) + FID_LEN + 19 ;
PTR$ = PINCRC ( PTR$,
                FID_LEN ) ;
CALL CONCAT ( PTR$->CCBUF,
              ',',
              NAMELIST.CONTROL_STA# ( STA_IDX ),
              ',',
              VLP$SETSTA_CONTROL.MYSTATION#,
              ')' ) ;
RETURN ;
 
ALT:
   ALTRETURN ;
 
END INIT_CCBUF ;
 
%EJECT ;
/*I*
   NAME:          ADMIN_DEFINESTA
   PURPOSE:       To define the ADMIN parameters for the LARKETTE station.
   CALL:          CALL ADMIN_DEFINESTA
   DESCRIPTION:   Defines the selected ADMIN parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
ADMIN_DEFINESTA : PROC ALTRET ;
 
   DCL   ADMIN_DEFINESTA_PARMS   SBIN SYMREF ;
   DCL   ADMIN_PROMPT            CHAR ( 0 ) CONSTANT INIT ( 'ADMIN PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   TEMP_YES_NO             BIT ( 1 ) ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( ADMIN_DEFINESTA_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( ADMIN_PROMPT ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %ADMIN_ACTIVATE_PARM ) ;
            FUNCTION.ADMIN.ACTIVATE# = TEMP_YES_NO ;
         SELECT ( %ADMIN_AU_PARM ) ;
            FUNCTION.ADMIN.AU# = TEMP_YES_NO ;
         SELECT ( %ADMIN_ABORTCOMP_PARM ) ;
            FUNCTION.ADMIN.COMP_ABORT# = TEMP_YES_NO ;
         SELECT ( %ADMIN_DISCCOMP_PARM ) ;
            FUNCTION.ADMIN.COMP_DISC# = TEMP_YES_NO ;
         SELECT ( %ADMIN_NEWDEFCOMP_PARM ) ;
            FUNCTION.ADMIN.COMP_NEWDEF# = TEMP_YES_NO ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
 
ALT:
   ALTRETURN ;
 
END ADMIN_DEFINESTA ;
 
%EJECT ;
/*I*
   NAME:          CONTROL_DEFINESTA
   PURPOSE:       To define the CONTROL parameters for the LARKETTE station.
   CALL:          CALL CONTROL_DEFINESTA
   DESCRIPTION:   Defines the selected CONTROL parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
CONTROL_DEFINESTA : PROC ALTRET ;
 
   DCL   CONTROL_DEFINESTA_PARMS SBIN SYMREF ;
   DCL   CONTROL_PROMPT          CHAR ( 0 ) CONSTANT INIT ( 'CONTROL PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( CONTROL_DEFINESTA_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( CONTROL_PROMPT ) ;
 
IF NOT NEW_GHOST THEN DO;
   CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_CONTROL_PARMS_USELESS#,
                                   3 ) ;
   ZEXIT = %TRUE ;
END ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %CONTROL_ACCT_PARM ) ;
            VLP$ACCT.ACCT# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %CONTROL_NAME_PARM ) ;
            VLP$NAME.L# = SYM$->OUT$SYM.COUNT ;
            VLP$NAME.NAME# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %CONTROL_PASS_PARM ) ;
            VLP$PASS.PASS# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %CONTROL_STATION_PARM ) ;
            NAMELIST.CONTROL_STA# ( STA_IDX ) = SYM$->OUT$SYM.TEXT ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END CONTROL_DEFINESTA ;
 
%EJECT ;
/*I*
   NAME:          READ_DEFINESTA
   PURPOSE:       To define the READ parameters for the LARKETTE station.
   CALL:          CALL READ_DEFINESTA
   DESCRIPTION:   Defines the selected READ parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
READ_DEFINESTA : PROC ALTRET ;
 
   DCL   READ$                   PTR ;
   DCL   READ_DEFINESTA_PARMS    SBIN SYMREF ;
   DCL   READ_PROMPT             CHAR ( 0 ) CONSTANT INIT ( 'READ PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   TEMP_NUM                SBIN ;
   DCL   TEMP_YES_NO             BIT ( 1 ) ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( READ_DEFINESTA_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( READ_PROMPT ) ;
READ$ = ADDR ( FUNCTION.READ_V ) ;
FUNCTION.READ.FLAG# = %YES# ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %LENGTH, %NUMOPS, %NUMSECONDS ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSG_FID ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %RW_ABORTERR_PARM ) ;
            FUNCTION.READ.ERR_ABORT# = TEMP_YES_NO ;
         SELECT ( %RW_BIN_PARM ) ;
            READ$->FPT$READ_V.DVBYTE.BIN = TEMP_YES_NO ;
         SELECT ( %RW_CONT_PARM ) ;
/*N*
            READ$->FPT$READ_V.DVBYTE.CONT = TEMP_YES_NO ;
*/
            IF ( TEMP_YES_NO = %YES# ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_NOT_IMPLEMENTED#,
                                               3 ) ;
            END ;
            READ$->FPT$READ_V.DVBYTE.CONT = %NO# ;
         SELECT ( %RW_FREQUENCY_PARM ) ;
            FUNCTION.READ.FREQ# = TEMP_NUM ;
         SELECT ( %RW_LENGTHMAX_PARM ) ;
            IF ( TEMP_NUM < 8 ) OR ( TEMP_NUM > 4096 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_LENGTH#,
                                               3 ) ;
            END ; ELSE DO ;
               FUNCTION.READ.MAXLEN# = TEMP_NUM ;
            END ;
         SELECT ( %RW_MSGFILE_PARM ) ;
            FUNCTION.READ.MSGFILE# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %RW_NEWMSGFILE_PARM ) ;
            FUNCTION.READ.NEWMSGFILE# = TEMP_YES_NO ;
         SELECT ( %RW_NUMOPS_PARM ) ;
            IF ( TEMP_NUM < 1 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMOPS#,
                                               3 ) ;
            END ; ELSE DO ;
               FUNCTION.READ.NUMOPS# = TEMP_NUM ;
            END ;
         SELECT ( %RW_TRANS_PARM ) ;
            READ$->FPT$READ_V.DVBYTE.TRANS = TEMP_YES_NO ;
         SELECT ( %RW_WAIT_PARM ) ;
/*N*
            READ$->FPT$READ_V.WAIT = TEMP_YES_NO ;
*/
            IF ( TEMP_YES_NO = %NO# ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_NOT_IMPLEMENTED#,
                                               3 ) ;
            END ;
            READ$->FPT$READ_V.WAIT = %YES# ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END READ_DEFINESTA ;
 
%EJECT ;
/*I*
   NAME:          WRITE_DEFINESTA
   PURPOSE:       To define the WRITE parameters for the LARKETTE station.
   CALL:          CALL WRITE_DEFINESTA
   DESCRIPTION:   Defines the selected WRITE parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
WRITE_DEFINESTA : PROC ALTRET ;
 
   DCL   WRITE$                  PTR ;
   DCL   WRITE_DEFINESTA_PARMS   SBIN SYMREF ;
   DCL   WRITE_PROMPT            CHAR ( 0 ) CONSTANT INIT ( 'WRITE PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   TEMP_NUM                SBIN ;
   DCL   TEMP_YES_NO             BIT ( 1 ) ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( WRITE_DEFINESTA_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( WRITE_PROMPT ) ;
WRITE$ = ADDR ( FUNCTION.WRITE_V ) ;
FUNCTION.WRITE.FLAG# = %YES# ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %LENGTH, %NUMOPS, %NUMSECONDS ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSG_FID ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %RW_ABORTERR_PARM ) ;
            FUNCTION.WRITE.ERR_ABORT# = TEMP_YES_NO ;
         SELECT ( %RW_BIN_PARM ) ;
            WRITE$->FPT$WRITE_V.DVBYTE.BIN = TEMP_YES_NO ;
         SELECT ( %RW_CONT_PARM ) ;
/*N*
            WRITE$->FPT$WRITE_V.DVBYTE.CONT = TEMP_YES_NO ;
*/
            IF ( TEMP_YES_NO = %YES# ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_NOT_IMPLEMENTED#,
                                               3) ;
            END ;
            WRITE$->FPT$WRITE_V.DVBYTE.CONT = %NO# ;
         SELECT ( %RW_FREQUENCY_PARM ) ;
            FUNCTION.WRITE.FREQ# = TEMP_NUM ;
         SELECT ( %RW_LENGTHMIN_PARM ) ;
/*N*
            IF ( TEMP_NUM < 8 ) OR ( TEMP_NUM > 4096 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_LENGTH#,
                                               3 ) ;
            END ; ELSE DO ;
               FUNCTION.WRITE.MINLEN# = TEMP_NUM ;
            END ;
*/
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_NOT_IMPLEMENTED#,
                                            3 ) ;
         SELECT ( %RW_LENGTHMAX_PARM ) ;
            IF ( TEMP_NUM < 8 ) OR ( TEMP_NUM > 4096 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_LENGTH#,
                                               3 ) ;
            END ; ELSE DO ;
               FUNCTION.WRITE.MAXLEN# = TEMP_NUM ;
            END ;
         SELECT ( %RW_MSGFILE_PARM ) ;
            FUNCTION.WRITE.MSGFILE# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %RW_NUMOPS_PARM ) ;
            FUNCTION.WRITE.NUMOPS# = TEMP_NUM ;
         SELECT ( %RW_TRANS_PARM ) ;
            WRITE$->FPT$WRITE_V.DVBYTE.TRANS = TEMP_YES_NO ;
         SELECT ( %RW_VFC_PARM ) ;
            WRITE$->FPT$WRITE_V.DVBYTE.VFC = TEMP_YES_NO ;
         SELECT ( %RW_WAIT_PARM ) ;
/*N*
            WRITE$->FPT$WRITE_V.WAIT = TEMP_YES_NO ;
*/
            IF ( TEMP_YES_NO = %NO# ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_NOT_IMPLEMENTED#,
                                               3 ) ;
            END ;
            WRITE$->FPT$WRITE_V.WAIT = %YES# ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END WRITE_DEFINESTA ;
 
%EJECT ;
/*I*
   NAME:          SETSTA_DEFINESTA
   PURPOSE:       To define the SETSTA parameters for the LARKETTE station.
   CALL:          CALL SETSTA_DEFINESTA
   DESCRIPTION:   Defines the selected SETSTA parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
SETSTA_DEFINESTA : PROC ALTRET ;
 
   DCL   SETSTA$                 PTR ;
   DCL   SETSTA_DEFINESTA_PARMS  SBIN SYMREF ;
   DCL   SETSTA_PROMPT           CHAR ( 0 ) CONSTANT INIT ( 'SETSTA PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   TEMP_NUM                SBIN ;
   DCL   TEMP_YES_NO             BIT ( 1 ) ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( SETSTA_DEFINESTA_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( SETSTA_PROMPT ) ;
SETSTA$ = ADDR ( FUNCTION.SETSTA ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %NUMSECONDS ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSGTYPE, %STATION ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %SETSTA_ALLABSENT_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.ALLABSENT# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ALLDCBS_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.ALLDCBS# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ALLTRMS_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.ALLTRMS# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ANYDCB_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.ANYDCB# = TEMP_YES_NO ;
         SELECT ( %SETSTA_DIRONLY_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.DIRONLY# = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFNONE_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.EOFNONE# = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFONE_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.EOFONE# = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFTIME_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.EOFTIME# = TEMP_NUM ;
         SELECT ( %SETSTA_ILATCH_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.ILATCH# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ILOCK_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.ILOCK# = TEMP_YES_NO ;
         SELECT ( %SETSTA_IMSGTYP_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.IMSGTYP# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %SETSTA_ISTATION_PARM ) ;
            SETSTA$->VLP$SETSTA.ISTA.ISTATION# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %SETSTA_OLATCH_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.OLATCH# = TEMP_YES_NO ;
         SELECT ( %SETSTA_OLOCK_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.OLOCK# = TEMP_YES_NO ;
         SELECT ( %SETSTA_OMSGTYP_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.OMSGTYP# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %SETSTA_OSTATION_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.OSTATION# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %SETSTA_WAS_PARM ) ;
            SETSTA$->VLP$SETSTA.OSTA.WAS# = TEMP_YES_NO ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END SETSTA_DEFINESTA ;
 
%EJECT ;
/*I*
   NAME:          STATION_DEFINESTA
   PURPOSE:       To define the STATION parameters for the LARKETTE station.
   CALL:          CALL STATION_DEFINESTA ( READ_WRITE )
   PARAMETER:     READ_WRITE signals whether this is the read- or write-station
                     structure
   DESCRIPTION:   Defines the selected STATION parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
STATION_DEFINESTA : PROC ( READ_WRITE ) ALTRET ;
 
   DCL   READ_WRITE              UBIN ;
   DCL   STATION$                PTR ;
   DCL   STATION_DEFINESTA_PARMS SBIN SYMREF ;
   DCL   READ_STATION_PROMPT     CHAR ( 0 ) CONSTANT INIT ( 'RSTATION PARMS>' ) ;
   DCL   WRITE_STATION_PROMPT    CHAR ( 0 ) CONSTANT INIT ( 'WSTATION PARMS>' ) ;
   DCL   SYM$                    PTR ;
   DCL   TEMP_NUM                SBIN ;
   DCL   TEMP_YES_NO             BIT ( 1 ) ;
   DCL   ZEXIT                   BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( STATION_DEFINESTA_PARMS ) ;
IF ( READ_WRITE = %READ ) THEN DO ;
   XUG$GETCMD_SUB.PROMPT_ = VECTOR ( READ_STATION_PROMPT ) ;
   STATION$ = ADDR ( FUNCTION.READ_STATION ) ;
END ; ELSE DO ;
   XUG$GETCMD_SUB.PROMPT_ = VECTOR ( WRITE_STATION_PROMPT ) ;
   STATION$ = ADDR ( FUNCTION.WRITE_STATION ) ;
END ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %NUMSECONDS ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSGTYPE_WILDC, %STATION_WILDC ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO SELECT ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         SELECT ( %SETSTA_ALLABSENT_PARM ) ;
            STATION$->VLP$STATION.CTL.ALLABSENT# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ALLDCBS_PARM ) ;
            STATION$->VLP$STATION.CTL.ALLDCBS# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ALLTRMS_PARM ) ;
            STATION$->VLP$STATION.CTL.ALLTRMS# = TEMP_YES_NO ;
         SELECT ( %SETSTA_ANYDCB_PARM ) ;
            STATION$->VLP$STATION.CTL.ANYDCB# = TEMP_YES_NO ;
         SELECT ( %SETSTA_DIRONLY_PARM ) ;
            STATION$->VLP$STATION.CTL.DIRONLY# = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFNONE_PARM ) ;
            STATION$->VLP$STATION.CTL.EOFNONE# = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFONE_PARM ) ;
            STATION$->VLP$STATION.CTL.EOFONE = TEMP_YES_NO ;
         SELECT ( %SETSTA_EOFTIME_PARM ) ;
            STATION$->VLP$STATION.EOFTIME# = TEMP_NUM ;
         SELECT ( %STATION_LATCH_PARM ) ;
            STATION$->VLP$STATION.CTL.LATCH# = TEMP_YES_NO ;
         SELECT ( %STATION_LOCK_PARM ) ;
            STATION$->VLP$STATION.CTL.LOCK = TEMP_YES_NO ;
         SELECT ( %STATION_MSGTYP_PARM ) ;
            STATION$->VLP$STATION.MSGTYP# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %STATION_STATION_PARM ) ;
            STATION$->VLP$STATION.STATION# = SYM$->OUT$SYM.TEXT ;
         SELECT ( %SETSTA_WAS_PARM ) ;
            STATION$->VLP$STATION.CTL.WAS# = TEMP_YES_NO ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END STATION_DEFINESTA ;
 
END LARK_DEFINESTA_CMD ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*F*
   NAME:          LARK_GENERICSTA_CMD
   PURPOSE:       Process the GENERICSTA command
   DESCRIPTION:   This module receives the parse tree for a GENERICSTA command
                  and sends the appropriate command to the selected LARKETTE
                  station.
*/
/*D*
   NAME:          LARK_GENERICSTA_CMD
   CALL:          CALL LARK_GENERICSTA_CMD ( PARSE$OUT, STATION_CMD )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
                  STATION_CMD identifies the particular command to be sent to
                     LARKETTE
   INTERFACE:     LARK_ABNORMAL_LARKETTE_MESSAGE
                  LARK_CHECK_AUEVENT
                  LARK_CHECK_NWIO_ERRORS
                  LARK_INTERNAL_ERROR
                  LARK_REPORT_PMME_ERROR
                  LARK_REPORT_CMD_ERROR
                  LARK_READ_MESSAGE
                  LARK_WRITE_MESSAGE
   INTPUT:        PARSE$OUT
   DESCRIPTION:   ??????STA_CMD syntax =
                     '???/[????]STATION' ;
                     STATION ;
*/
/*D*
   ENTRY:         LARK_GENERICSTA_NOPARSE_CMD
   CALL:          CALL LARK_GENERICSTA_NOPARSE_CMD ( , STATION_CMD, STA_IDX )
   PARAMETERS:    STATION_CMD identifies the particular command to be sent to
                     LARKETTE
                  STA_IDX is the index of the station in the name list
   DESCRIPTION:   This entry receives a command and station index and then sends
                  the command to the selected LARKETTE station.  No parsing is
                  done.
*/
 
%EJECT ;
LARK_GENERICSTA_CMD : PROC ( P_OUT$BLK, STATION_CMD, STA_IDX ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUF_ENTRY ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_ABNORMAL_LARKETTE_MESSAGE ;
%LARK_CHECK_AUEVENT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_CMD_ERROR ;
%LARK_READ_MESSAGE ;
%LARK_WRITE_MESSAGE ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME           = P_OUT$BLK,
         STCLASS        = "" ) ;
 
DCL      STATION_CMD    SBIN ;
DCL      STA_IDX        SBIN ;
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_NO_DEF_FOR_STA#-3
   MESSAGE0:      The station has not been defined
   MESSAGE1:      You must define the station parameters using DEFINESTATION
   DESCRIPTION:   The FUNCTION structure must be defined first.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_CGINFO ;
%LARK_NAMELIST ;
%LARK_PARSEBLKS ;
%LARKETTE_CONTROL_BUFFER ( NAME = WRITE_CONTROL_BUFFER ) ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
/*
   Local data
*/
 
DCL         B$TCB$               PTR SYMREF ;
DCL         BLK$                 PTR ;
DCL         DONE                 BIT ( 1 ) ;
DCL         I                    SBIN ;
 
%EJECT ;
IF ( P_OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO SELECT P_OUT$BLK.CODE ;
   SELECT ( %ABORTSTA_CMD, %CONNECTSTA_CMD, %DISCONNECTSTA_CMD, %RESUMESTA_CMD, %SUSPENDSTA_CMD ) ;
   SELECT ( ELSE ) ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
END ;
 
/*
   Processing the station name parameter.
*/
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
IF ( BLK$->OUT$SYM.CODE ~= %STATION ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT;
END ; ELSE DO ;
   I = 0 ;
   DO WHILE ( I < NAMELIST_CT ) AND ( BLK$->OUT$SYM.TEXT ~= NAMELIST.FUNCTION_STA# ( I ) ) ;
      I = I + 1 ;
   END ;
   IF ( I = NAMELIST_CT ) THEN DO ;
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_DEF_FOR_STA#,
                                   3 ) ;
      GOTO ALT ;
   END ;
END ;
 
GOTO CONTINUE_CMD ;
 
%EJECT ;
LARK_GENERICSTA_NOPARSE_CMD : ENTRY ( P_OUT$BLK, STATION_CMD, STA_IDX ) ALTRET ;
 
I = STA_IDX ;
 
CONTINUE_CMD: ;
 
/*
   Make sure a control station is open in LARK.
*/
 
IF NOT M$CTRLCG$->F$DCB.FCD# THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_LARK_DCBSTATION#,
                                3 ) ;
   GOTO ALT ;
END ;
 
/*
   Send the appropriate station message to LARKETTE.
*/
 
WRITE_CONTROL_BUFFER.CODE = STATION_CMD ;
WRITE_CONTROL_BUFFER.STATION = NAMELIST.FUNCTION_STA# ( I ) ;
VLP$STATION_CONTROL.STATION# = NAMELIST.CONTROL_STA# ( I ) ;
CALL LARK_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                          VECTOR ( VLP$STATION_CONTROL ),
                          VECTOR ( WRITE_CONTROL_BUFFER ) )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_CMD_ERROR ( %E$LARK_CMD_NOT_PERFORMED#,
                                      3 ) ;
         GOTO ALT ;
      END ;
 
/*
   Read for the result of this command.
*/
 
DONE = %NO# ;
DO UNTIL DONE ;
   CALL M$CHECK ( FPT$CHECK_NWIO )
         WHENALTRETURN DO ;
            IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$LD ) THEN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             M$CTRLCG_DCBNUM ) ;
               GOTO ALT ;
            END ;
         END ;
   CALL LARK_CHECK_NWIO_ERRORS
         ALTRET ( ALT ) ;
   IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
      CALL LARK_CHECK_AUEVENT
            ALTRET ( ALT ) ;
   END ; ELSE DO ;
      DO SELECT CONTROL_BUFFER.CODE ;
         SELECT ( %CONNECTED_STATION, %DISCONNECTED_STATION, %RESUMED_STATION, %SUSPENDED_STATION ) ;
            DONE = %YES# ;
         SELECT ( %STATUS_ABORT_HEADER, %COMMAND_ERROR_RETURN, ELSE ) ;
            CALL LARK_ABNORMAL_LARKETTE_MESSAGE
                  ALTRET ( ALT ) ;
            IF ( CONTROL_BUFFER.CODE = %COMMAND_ERROR_RETURN ) OR ( I >= NAMELIST_CT ) OR
                  ( NAMELIST.CONTROL_STA# ( I ) = ' ' ) THEN DO ;
               DONE = %YES# ;
            END ;
      END ;
   END ;
   VLP$STATION_CONTROL.STATION# = '?' ;
   CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                            VECTOR ( VLP$STATION_CONTROL ),
                            VECTOR ( CONTROL_BUFFER ) )
         WHENALTRETURN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_GENERICSTA_CMD ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*F*
   NAME:          LARK_STATUSOFSTA_CMD
   PURPOSE:       Process the STATUSOFSTA command
   DESCRIPTION:   This module receives the parse tree for a STATUSOFSTA command
                  and sends the appropriate command to the selected LARKETTE
                  station.
*/
/*D*
   NAME:          LARK_STATUSOFSTA_CMD
   CALL:          CALL LARK_STATUSOFSTA_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_ABNORMAL_LARKETTE_MESSAGE
                  LARK_CHECK_AUEVENT
                  LARK_CHECK_NWIO_ERRORS
                  LARK_DISPLAY_STATUS
                  LARK_INTERNAL_ERROR
                  LARK_REPORT_PMME_ERROR
                  LARK_REPORT_CMD_ERROR
                  LARK_READ_MESSAGE
                  LARK_WRITE_MESSAGE
   INTPUT:        PARSE$OUT
   DESCRIPTION:   STATUSOFSTA_CMD syntax =
                     'STA/[TUSOF]STATION' ;
                     STATION ;
*/
 
%EJECT ;
LARK_STATUSOFSTA_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUF_ENTRY ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_ABNORMAL_LARKETTE_MESSAGE ;
%LARK_CHECK_AUEVENT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_DISPLAY_STATUS ;
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_CMD_ERROR ;
%LARK_READ_MESSAGE ;
%LARK_WRITE_MESSAGE ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME           = P_OUT$BLK,
         STCLASS        = "" ) ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_NAMELIST ;
%LARK_PARSEBLKS ;
%LARKETTE_CONTROL_BUFFER ( NAME = WRITE_CONTROL_BUFFER ) ;
%LARKETTE_STATUS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
/*
   Local data
*/
 
DCL         B$TCB$               PTR SYMREF ;
DCL         BLK$                 PTR ;
DCL         DONE                 BIT ( 1 ) ;
DCL         NOSTAT               BIT ( 1 ) ;
DCL         STA_IDX              SBIN ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %STATUSOFSTA_CMD ) OR ( P_OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
/*
   Processing the station name parameter.
*/
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
IF ( BLK$->OUT$SYM.CODE ~= %STATION ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT;
END ; ELSE DO ;
   STA_IDX = 0 ;
   DO WHILE ( STA_IDX < NAMELIST_CT ) AND ( BLK$->OUT$SYM.TEXT ~= NAMELIST.FUNCTION_STA# ( STA_IDX ) ) ;
      STA_IDX = STA_IDX + 1 ;
   END ;
   IF ( STA_IDX = NAMELIST_CT ) THEN DO ;
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_DEF_FOR_STA#,
                                   3 ) ;
      GOTO ALT ;
   END ;
END ;
 
/*
   Make sure a control station is open in LARK.
*/
 
IF NOT M$CTRLCG$->F$DCB.FCD# THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_NO_LARK_DCBSTATION#,
                                3 ) ;
   GOTO ALT ;
END ;
 
/*
   Send the appropriate station message to LARKETTE.
*/
 
WRITE_CONTROL_BUFFER.CODE = %STATUS_REQUEST ;
WRITE_CONTROL_BUFFER.STATION = NAMELIST.FUNCTION_STA# ( STA_IDX ) ;
VLP$STATION_CONTROL.STATION# = NAMELIST.CONTROL_STA# ( STA_IDX ) ;
CALL LARK_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                          VECTOR ( VLP$STATION_CONTROL ),
                          VECTOR ( WRITE_CONTROL_BUFFER ) )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_CMD_ERROR ( %E$LARK_CMD_NOT_PERFORMED#,
                                      3 ) ;
         GOTO ALT ;
      END ;
 
/*
   Read for the result of this command.
*/
 
DONE = %NO# ;
NOSTAT = %NO# ;
DO UNTIL DONE OR NOSTAT ;
   CALL M$CHECK ( FPT$CHECK_NWIO )
         WHENALTRETURN DO ;
            IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$LD ) THEN DO ;
               CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                             M$CTRLCG_DCBNUM ) ;
               GOTO ALT ;
            END ;
         END ;
   CALL LARK_CHECK_NWIO_ERRORS
         ALTRET ( ALT ) ;
   IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
      CALL LARK_CHECK_AUEVENT
            ALTRET ( ALT ) ;
   END ; ELSE DO ;
      DO SELECT CONTROL_BUFFER.CODE ;
         SELECT ( %STATUS_REPORT_HEADER ) ;
            DONE = %YES# ;
         SELECT ( %STATUS_ABORT_HEADER, %COMMAND_ERROR_RETURN, ELSE ) ;
            CALL LARK_ABNORMAL_LARKETTE_MESSAGE
                  ALTRET ( ALT ) ;
            IF ( CONTROL_BUFFER.CODE = %COMMAND_ERROR_RETURN ) OR ( STA_IDX >= NAMELIST_CT ) OR
                  ( NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ) THEN DO ;
               NOSTAT = %YES# ;
            END ;
      END ;
   END ;
   IF DONE THEN DO ;
      DONE = %NO# ;
      DO UNTIL DONE ;
         VLP$STATION_CONTROL.MSGTYP# = %STATUS_MSGTYP ;
         VLP$STATION_CONTROL.STATION# = CONTROL_BUFFER.STATION ;
         CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                                  VECTOR ( VLP$STATION_CONTROL ),
                                  VECTOR ( STATUS ) )
               WHENALTRETURN DO ;
                  GOTO ALT ;
               END ;
         CALL M$CHECK ( FPT$CHECK_NWIO )
               WHENALTRETURN DO ;
                  IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$LD ) THEN DO ;
                     CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                   M$CTRLCG_DCBNUM ) ;
                     GOTO ALT ;
                  END ;
               END ;
         CALL LARK_CHECK_NWIO_ERRORS
               ALTRET ( ALT ) ;
         IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
            CALL LARK_CHECK_AUEVENT
                  ALTRET ( ALT ) ;
         END ; ELSE DO ;
            DONE = %YES# ;
         END ;
      END ;
      VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
      CALL LARK_DISPLAY_STATUS ;
   END ;
   VLP$STATION_CONTROL.STATION# = '?' ;
   CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                            VECTOR ( VLP$STATION_CONTROL ),
                            VECTOR ( CONTROL_BUFFER ) )
         WHENALTRETURN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_STATUSOFSTA_CMD ;
