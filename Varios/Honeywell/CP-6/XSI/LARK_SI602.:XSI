/*M* LARK_SI602 LARK_MISC  LARK external support routines */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*P*
   NAME:          LARK_MISC
   PURPOSE:       Contains routines common to multiple commands.
*/
%EJECT ;
/*T*/
/*F*
   NAME:          LARK_ABNORMAL_LARKETTE_MESSAGE
   PURPOSE:       To handle unexpected messages from LARKETTE
   DESCRIPTION:   Takes care of message received that wasn't the exact response
                  expected from LARKETTE.  This message may or may not be related
                  to the last command issued to LARKETTE by LARK.
*/
/*D*
   NAME:          LARK_ABNORMAL_LARKETTE_MESSAGE
   CALL:          CALL LARK_ABNORMAL_LARKETTE_MESSAGE
   INPUT:         CONTROL_BUFFER
   INTERFACE:     LARK_CHECK_AUEVENT
                  LARK_CHECK_NWIO_ERRORS
                  LARK_DISPLAY_STATUS
                  LARK_INTERNAL_ERROR
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_NWIO_ERROR
                  LARK_REPORT_PMME_ERROR
                  LARK_READ_MESSAGE
   DESCRIPTION:   The messages handled by this routine fall into two classes:
                  those sent as a reason why the command given could not be
                  executed and those reporting possibly unrelated events occurring
                  with that LARKETTE station or other functioning LARKETTE's.
*/
 
%EJECT ;
LARK_ABNORMAL_LARKETTE_MESSAGE : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Entries
*/
 
%LARK_CHECK_AUEVENT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_DISPLAY_STATUS ;
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_NWIO_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_READ_MESSAGE ;
 
/*
   Parameter
*/
 
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_LARKETTE_INTERNAL_ERROR#-3
   MESSAGE0:      LARKETTE encountered an unexpected condition
   MESSAGE1:      LARKETTE has aborted
   DESCRIPTION:   LARKETTE encountered a PMME error or NWIO error.
*/
 
/*E*
   ERROR:         LAR-E$LARK_LARKETTE_SAID_GOODBYE#-3
   MESSAGE0:      LARKETTE exited
   MESSAGE1:      LARKETTE has completed within his defined operation or was aborted
   DESCRIPTION:   LARKETTE completed or had an IO error with ERR_ABORT = yes.
                  Or, he was aborted by the LARK user.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STATION_OPEN_FAILED#-3
   MESSAGE0:      The open of the functional station failed
   MESSAGE1:      The functional station specified was not allowed to connect to the comgroup
   DESCRIPTION:   The M$OPEN for the functional station altreturned.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_NOT_CONNECTED#-3
   MESSAGE0:      The station specified is not connected
   MESSAGE1:      This command is not allowed unless the station is connected
   DESCRIPTION:   Station must be connected for some commands.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_NOT_DEFINED#-3
   MESSAGE0:      The station specified has not been defined
   MESSAGE1:      This command is not allowed unless the station is defined
   DESCRIPTION:   Station must be defined before anything can be done.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_NOT_DISCONNECTED#-3
   MESSAGE0:      The station specified is connected
   MESSAGE1:      This command is not allowed unless the station is disconnected
   DESCRIPTION:   Station must be disconnected for some commands.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_NOT_RESUMED#-3
   MESSAGE0:      The station specified is not currently operating
   MESSAGE1:      This command is not allowed unless the station is running
   DESCRIPTION:   Station must be running to be suspended.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_NOT_SUSPENDED#-3
   MESSAGE0:      The station specified is not currently suspended
   MESSAGE1:      This command is not allowed unless the station is suspended
   DESCRIPTION:   Station must be suspended for some commands.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_NAMELIST ;
%LARKETTE_STATUS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_CHECK
          ( FPTN              = FPT_CHECK_NWIO,
            STCLASS           = CONSTANT,
            DCB               = M$CTRLCG ) ;
 
/*
   Local data
*/
 
DCL         B$TCB$            PTR SYMREF ;
DCL         DONE              BIT ( 1 ) ;
DCL         STA_IDX           SBIN ;
 
%EJECT ;
DO CASE CONTROL_BUFFER.CODE ;
   CASE ( %COMMAND_ERROR_RETURN ) ;
      /*
         Response to the command just sent from LARK to LARKETTE.  This is the
         reason that this command did not get executed.
      */
      DO CASE CONTROL_BUFFER.COMMAND.ERR# ;
         CASE ( %NOT_CONNECTED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STA_NOT_CONNECTED#,
                                         3 ) ;
         CASE ( %NOT_DEFINED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STA_NOT_DEFINED#,
                                         3 ) ;
         CASE ( %NOT_DISCONNECTED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STA_NOT_DISCONNECTED#,
                                         3 ) ;
         CASE ( %NOT_RESUMED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STA_NOT_RESUMED#,
                                         3 ) ;
         CASE ( %NOT_SUSPENDED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STA_NOT_SUSPENDED#,
                                         3 ) ;
         CASE ( %NOT_OPENED ) ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_STATION_OPEN_FAILED#,
                                         3 ) ;
         CASE ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END;
 
   CASE ( %NWIO_ERROR_RETURN, %PMME_ERROR_RETURN ) ;
      /*
         This error has occurred in one of the running LARKETTE's.  This one is
         sent directly before the LARKETTE in which it occurred aborts (basically
         because of some internal LARKETTE error).
      */
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_LARKETTE_INTERNAL_ERROR#,
                                   3 ) ;
      IF ( CONTROL_BUFFER.CODE = %NWIO_ERROR_RETURN ) THEN DO ;
         CALL LARK_REPORT_NWIO_ERROR ( CONTROL_BUFFER.NWIO ) ;
      END ; ELSE DO ;
         CALL LARK_REPORT_PMME_ERROR ( CONTROL_BUFFER.PMME.ERR#,
                                       M$CTRLCG_DCBNUM ) ;
      END ;
      STA_IDX = 0 ;
      DO WHILE ( STA_IDX < NAMELIST_CT ) AND
            ( NAMELIST.CONTROL_STA# ( STA_IDX ) ~= CONTROL_BUFFER.STATION ) ;
         STA_IDX = STA_IDX + 1 ;
      END ;
      IF ( STA_IDX = NAMELIST_CT ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ;
      NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ;
      NAMELIST.FUNCTION_STA# ( STA_IDX ) = ' ' ;
      IF ( STA_IDX = ( NAMELIST_CT - 1 ) ) THEN DO ;
         NAMELIST_CT = NAMELIST_CT - 1 ;
      END ;
 
   CASE ( %STATUS_ABORT_HEADER ) ;
      /*
         LARKETTE decided that he was finished according to the function definition
         given him.  Or, he may have been aborted by the LARK user.
         He aborts after sending this information.
      */
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_LARKETTE_SAID_GOODBYE#,
                                   3 ) ;
      DONE = %NO# ;
      DO UNTIL DONE ;
         VLP$STATION_CONTROL.MSGTYP# = %STATUS_MSGTYP ;
         VLP$STATION_CONTROL.STATION# = CONTROL_BUFFER.STATION ;
         CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                                  VECTOR ( VLP$STATION_CONTROL ),
                                  VECTOR ( STATUS ) )
               WHENALTRETURN DO ;
                  GOTO ALT ;
               END ;
         CALL M$CHECK ( FPT_CHECK_NWIO )
               WHENALTRETURN DO ;
                  IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$LD ) THEN DO ;
                     CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                   M$CTRLCG_DCBNUM ) ;
                     GOTO ALT ;
                  END ;
               END ;
         CALL LARK_CHECK_NWIO_ERRORS
               ALTRET ( ALT ) ;
         IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
            CALL LARK_CHECK_AUEVENT
                  ALTRET ( ALT ) ;
         END ; ELSE DO ;
            DONE = %YES# ;
         END ;
      END ;
      VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
      CALL LARK_DISPLAY_STATUS ;
 
      STA_IDX = 0 ;
      DO WHILE ( STA_IDX < NAMELIST_CT ) AND
            ( NAMELIST.CONTROL_STA# ( STA_IDX ) ~= STATUS.CONTROL.STATION# ) ;
         STA_IDX = STA_IDX + 1 ;
      END ;
      IF ( STA_IDX = NAMELIST_CT ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ; ELSE DO ;
         NAMELIST.FUNCTION_STA# ( STA_IDX ) = ' ' ;
         NAMELIST.CONTROL_STA# ( STA_IDX ) = ' ' ;
         IF ( STA_IDX = ( NAMELIST_CT - 1 ) ) THEN DO ;
            NAMELIST_CT = NAMELIST_CT - 1 ;
         END ;
      END ;
 
   CASE ( %DISCONNECTED_STATION, %CONNECTED_STATION ) ;
/*N*
         The only time we should get here is when a LARKETTE functional station
         completes its task and disconnects.  (The CONNECT and DISCONNECT
         commands wait for this response before they complete.)  Should probably
         keep track of this information somewhere.
*/
 
   CASE ( ELSE ) ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
 
   END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_ABNORMAL_LARKETTE_MESSAGE ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*F*
   NAME:          LARK_BREAK_HANDLER
   PURPOSE:       To provide break key control
   DESCRIPTION:   Entered asynchronously when the user hits the
                  break key.  Primarily intended to allow the user to
                  get out of PAUSE mode before time expires
*/
/*D*
   NAME:          LARK_BREAK_HANDLER
   CALL:          CALL LARK_BREAK_HANDLER
   OUTPUT:        NONE
   INTERFACE:     NONE
   DESCRIPTION:   Entered asynchronously when the user hits the
                  break key.  Primarily intended to allow the user to
                  get out of PAUSE mode before time expires
*/
%EJECT ;
LARK_BREAK_HANDLER : PROC ASYNC ;
 
                                                 /* The symdef for this is */
                                                 /* in LARK_PAUSE_CMD. This*/
                                                 /* flag tells that routine*/
                                                 /* that the break key has */
                                                 /* been hit               */
DCL BREAK_HIT# BIT ( 1 ) SYMREF ;
 
BREAK_HIT# = '1'B ;
 
RETURN ;
 
END LARK_BREAK_HANDLER ;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT ;
/*F*
   NAME:          LARK_CGINFO_WITH_DATASEG
   PURPOSE:       To perform the M$CGINFO call for DISPLAY and MODIFY
   DESCRIPTION:   Sets up a data segment for the CGINFO data and then
                  calls CGINFO.
*/
/*D*
   NAME:          LARK_CGINFO_WITH_DATASEG
   CALL:          CALL LARK_CGINFO_WITH_DATASEG
   OUTPUT:        FPT$CGINFO
   INTERFACE:     LARK_GET_DATA_SEGMENT
                  LARK_INTERNAL_ERROR
                  LARK_REPORT_PMME_ERROR
                  LARK_SIZE_DATA_SEGMENT
   DESCRIPTION:   Uses the data segment set up for the CGINFO data.  Calls M$CGINFO
                  three times:  (1) fixed size data plus either the TYPLIST
                  or the STALIST, depending on how the anonymous queue is ordered;
                  (2) the QLIST plus the previous corresponding TYPLIST or
                  STALIST; and finally (3) the TYPLIST, if the queue is ordered
                  by station, otherwise the STALIST.  The data
                  segment is expanded as necessary on each of the calls
                  until the PMME is performed successfully.  Reports errors
                  if any occur and ALTRETS.
*/
%EJECT ;
LARK_CGINFO_WITH_DATASEG : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
%EJECT ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_GET_DATA_SEGMENT ;
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_SIZE_DATA_SEGMENT ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_CGINFO ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_CGINFO
       ( FPTN                    = FPT_CGINFO,
         STCLASS                 = CONSTANT,
         DCB                     = M$CG,
         STAFC                   = DUMP,
         TYPFC                   = DUMP ) ;
 
%FPT_CGINFO
       ( FPTN                    = FPTCGINFO_TEMP,
         STCLASS                 = AUTO ) ;
 
%VLP_VECTOR
       ( FPTN                    = VLP_VECTOR_TEMP,
         STCLASS                 = CONSTANT ) ;
 
%VLP_VECTOR
       ( FPTN                    = VLPVECTOR_TEMP,
         STCLASS                 = AUTO ) ;
 
/*
   Local data
*/
 
DCL         INITIAL_DATASEG_SIZE SBIN CONSTANT INIT ( 1024 ) ;
 
DCL         B$TCB$               PTR SYMREF ;
DCL         CURRENT_DATASEG_SIZE SBIN ;
DCL         FOUND                SBIN ;
DCL         SIZE                 SBIN ;
DCL         TEMP$                PTR ;
 
%EJECT ;
 
/*
   Determine the size of the allocated data segment.
*/
 
FOUND = 0 ;
CALL LARK_SIZE_DATA_SEGMENT ( VLP$VECTOR_CGINFO_DATASEG,
                              CURRENT_DATASEG_SIZE )
      ALTRET ( ALT ) ;
IF ( CURRENT_DATASEG_SIZE < INITIAL_DATASEG_SIZE ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
TEMP$ = VLP$VECTOR_CGINFO_DATASEG.PTR$ ;
 
/*
   Setting up the vectors within the data segment for the fixed size parameters.
*/
 
FPT$CGINFO = FPT_CGINFO ;
FPT$CGINFO.V_ = VECTOR ( FPT$CGINFO.V ) ;
FPT$CGINFO.CGCP_ = VECTOR ( TEMP$->VLP_CGCP_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLP_CGCP_CGINFO ) ) ;
FPT$CGINFO.HOLDSTA_ = VECTOR ( TEMP$->VLP_HOLDSTA_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLP_HOLDSTA_CGINFO ) ) ;
FPT$CGINFO.JRNLFID_ = VECTOR ( TEMP$->VLP_JRNLFID_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLP_JRNLFID_CGINFO ) ) ;
FPT$CGINFO.JRNLSTA_ = VECTOR ( TEMP$->VLP_JRNLSTA_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLP_JRNLSTA_CGINFO ) ) ;
FPT$CGINFO.SETSTA_ = VECTOR ( TEMP$->VLP_SETSTA_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLP_SETSTA_CGINFO ) ) ;
FPT$CGINFO.STATS_ = VECTOR ( TEMP$->VLR_STATS_CGINFO ) ;
TEMP$ = PINCRW ( TEMP$,
                 SIZEW ( VLR_STATS_CGINFO ) ) ;
 
/*
   Initialize a temporary CGINFO structure now for the second call to M$CGINFO.
   The first time it is used, it will contain vectors for the QLIST and the
   corresponding TYPLIST or STALIST.  The vector for the TYPLIST or STALIST
   is placed in this structure after the first call to M$CGINFO using FPT$CGINFO
   is done.
*/
 
FPTCGINFO_TEMP = FPT_CGINFO ;
FPTCGINFO_TEMP.V_ = VECTOR ( FPTCGINFO_TEMP.V ) ;
 
/*
   The first CGINFO call is done using the FPT$CGINFO structure (which
   will ultimately hold vectors for all the information) getting the
   fixed size info plus the STALIST or TYPLIST, depending on the ordering
   of the anonymous queue.  The second call is done using the temporary
   CGINFO structure and gets information for the QLIST and the corresponding
   TYP- or STA-LIST which was already returned.  This is done because
   ComGroups is not smart enough to return only the QLIST.  Also, the
   space provided for the QLIST must hold at least as many items as the
   corresponding list.  For this reason, the first call acts to get the
   size of the TYP- or STA-LIST, and the second call then treats that
   item as having a fixed size, leaving the rest of the data segment for
   the QLIST so it can hold as many or more items.  The last call gets
   the other list.
*/
 
IF M$CG$->F$DCB.QISS# THEN DO ;
   CALL STALIST_CGINFO ( FPT$CGINFO )
         ALTRET ( ALT ) ;
   FPTCGINFO_TEMP.STALIST_ = FPT$CGINFO.STALIST_ ;
   CALL QLIST_CGINFO ( FPTCGINFO_TEMP )
         ALTRET ( ALT ) ;
   FPTCGINFO_TEMP = FPT_CGINFO ;
   FPTCGINFO_TEMP.V_ = VECTOR ( FPTCGINFO_TEMP.V ) ;
   CALL TYPLIST_CGINFO ( FPTCGINFO_TEMP )
         ALTRET ( ALT ) ;
END ; ELSE DO ;
   CALL TYPLIST_CGINFO ( FPT$CGINFO )
         ALTRET ( ALT ) ;
   FPTCGINFO_TEMP.TYPLIST_ = FPT$CGINFO.TYPLIST_ ;
   CALL QLIST_CGINFO ( FPTCGINFO_TEMP )
         ALTRET ( ALT ) ;
   FPTCGINFO_TEMP = FPT_CGINFO ;
   FPTCGINFO_TEMP.V_ = VECTOR ( FPTCGINFO_TEMP.V ) ;
   CALL STALIST_CGINFO ( FPTCGINFO_TEMP )
         ALTRET ( ALT ) ;
END ;
RETURN ;
 
ALT:
   ALTRETURN ;
 
%EJECT ;
/*I*
   NAME:          CGINFO_WITH_DATASEG_EXPANSION
   PURPOSE:       To make a CGINFO call with the provided data segment,
                  expanding the segment if the call ALTRET's due to lack of
                  space
   CALL:          CALL CGINFO_WITH_DATASEG_EXPANSION ( CGINFO,
                                                       CGINFO_LIST_ )
   PARAMETERS:    CGINFO is the structure containing vectors for the requested info
                  CGINFO_LIST_ is the vector of the STA, TYP, or Q LIST
   INPUT:         CGINFO
   OUTPUT:        CGINFO_LIST_
   INTERFACE:     LARK_GET_DATA_SEGMENT
                  LARK_REPORT_PMME_ERROR
                  LARK_RELEASE_DATA_SEGMENT
   DESCRIPTION:   Makes the CGINFO call and, if necessary, expands the
                  data segment and the TYPLIST, STALIST, or QLIST vector.
*/
 
%EJECT ;
CGINFO_WITH_DATASEG_EXPANSION : PROC ( CGINFO, CGINFO_LIST_ ) ALTRET ;
 
/*
   Parameters
*/
 
%FPT_CGINFO
       ( FPTN                    = CGINFO,
         STCLASS                 = "" ) ;
 
DCL      CGINFO_LIST_            VECTOR PARAM ;
 
DCL      GOODINFO                BIT ( 1 ) ;
 
%EJECT ;
GOODINFO = %FALSE ;
 
/*
   If the pointer is past the end of the data segment, a "negative" value
   has been placed in the bound.  Check for a large value since the bound
   is a ubin value.  Also, ComGroups assumes that if you supply a vector
   smaller than the size of one item, the request for the info wasn't made
   and doesn't return an error or value for found.
*/
 
IF ( VBOUND ( CGINFO_LIST_ ) >= ( CURRENT_DATASEG_SIZE * 4 ) ) OR
   ( VBOUND ( CGINFO_LIST_ ) <= ( SIZEC ( VLP_CGSTAL_CGINFO.LIST ( 0 ) ) + 4 ) ) THEN DO ;
   CALL LARK_GET_DATA_SEGMENT ( VLP$VECTOR_CGINFO_DATASEG,
                                INITIAL_DATASEG_SIZE )
         ALTRET ( ALT ) ;
   CURRENT_DATASEG_SIZE = CURRENT_DATASEG_SIZE + INITIAL_DATASEG_SIZE ;
   VBOUND ( CGINFO_LIST_ ) = ( CURRENT_DATASEG_SIZE -
         POFFW ( VBASE ( CGINFO_LIST_ ),
                 VLP$VECTOR_CGINFO_DATASEG.PTR$ ) )
         * 4 - 1 ;
END ;
 
DO UNTIL GOODINFO ;
   CALL M$CGINFO ( CGINFO )
         WHENRETURN DO ;
            GOODINFO = %TRUE ;
         END ;
         WHENALTRETURN DO ;
            DO SELECT ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ) ;
               SELECT ( %E$CGISLS, %E$CGITLS, %E$CGIQLS ) ;
                  CALL LARK_GET_DATA_SEGMENT ( VLP$VECTOR_CGINFO_DATASEG,
                                               INITIAL_DATASEG_SIZE )
                        ALTRET ( ALT ) ;
                  CURRENT_DATASEG_SIZE = CURRENT_DATASEG_SIZE + INITIAL_DATASEG_SIZE ;
                  VBOUND ( CGINFO_LIST_ ) = VBOUND ( CGINFO_LIST_ ) +
                        INITIAL_DATASEG_SIZE * 4 ;
               SELECT ( ELSE ) ;
                  CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                               M$CG_DCBNUM ) ;
                  GOTO ALT ;
            END ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END CGINFO_WITH_DATASEG_EXPANSION ;
 
%EJECT ;
/*I*
   NAME:          TYPLIST_CGINFO
   PURPOSE:       To set up a vector for the TYPLIST from the space remaining
                  in the data segment, then call M$CGINFO, and finally put
                  a vector framing the used space in FPT$CGINFO
   CALL:          CALL TYPLIST_CGINFO ( CGINFO )
   PARAMETERS:    CGINFO is the structure in which to place the TYPLIST
                     vector to use when making the M$CGINFO call
   INPUT:         CGINFO
   OUTPUT:        FPT$CGINFO
                  FOUND
                  TEMP$
   INTERFACE:     CGINFO_WITH_DATASEG_EXPANSION
   DESCRIPTION:   Forms a vector of the space remaining in the data segment.
                  Calls the appropriate routine to get the CGINFO.  (Other
                  vectors may have been placed in the CGINFO structure
                  which will also be used in the information call.)
                  Uses the number of items returned in TYPLIST to form a vector
                  framing the used space.  Increments the pointer in the data
                  segment to the next available position and returns the
                  number of items found in the list.
*/
 
%EJECT ;
TYPLIST_CGINFO : PROC ( CGINFO ) ALTRET ;
 
/*
   Parameters
*/
 
%FPT_CGINFO
       ( FPTN                    = CGINFO,
         STCLASS                 = "" ) ;
 
%EJECT ;
VLPVECTOR_TEMP = VLP_VECTOR_TEMP ;
VLPVECTOR_TEMP.PTR$ = TEMP$ ;
VLPVECTOR_TEMP.W1.VSIZE# = ( CURRENT_DATASEG_SIZE -
      POFFW ( TEMP$,
              VLP$VECTOR_CGINFO_DATASEG.PTR$ ) )
      * 4 - 1 ;
CGINFO.TYPLIST_ = VLPVECTOR_TEMP ;
CALL CGINFO_WITH_DATASEG_EXPANSION ( CGINFO,
                                     CGINFO.TYPLIST_ )
      ALTRET ( ALT ) ;
SIZE = TEMP$->VLP_CGTYPL_CGINFO.FOUND# * SIZEW ( VLP_CGTYPL_CGINFO.LIST ( 0 ) ) + 1 ;
VLPVECTOR_TEMP.W1.VSIZE# = SIZE * 4 - 1 ;
FPT$CGINFO.TYPLIST_ = VLPVECTOR_TEMP ;
FOUND = TEMP$->VLP_CGTYPL_CGINFO.FOUND# ;
TEMP$ = PINCRW ( TEMP$,
                 SIZE ) ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END TYPLIST_CGINFO ;
 
%EJECT ;
/*I
   NAME:          STALIST_CGINFO ;
   PURPOSE:       To set up a vector for the STALIST from the space remaining
                  in the data segment, then call M$CGINFO, and finally put
                  a vector framing the used space in FPT$CGINFO
   CALL:          CALL STALIST_CGINFO ( CGINFO )
   PARAMETERS:    CGINFO is the structure in which to place the STALIST
                     vector to use when making the M$CGINFO call
   INPUT:         CGINFO
   OUTPUT:        FPT$CGINFO
                  FOUND
                  TEMP$
   INTERFACE:     CGINFO_WITH_DATASEG_EXPANSION
   DESCRIPTION:   Forms a vector of the space remaining in the data segment.
                  Calls the appropriate routine to get the CGINFO.  (Other
                  vectors may have been placed in the CGINFO structure
                  which will also be used in the information call.)
                  Uses the number of items returned in STALIST to form a vector
                  framing the used space.  Increments the pointer in the data
                  segment to the next available position and returns the
                  number of items found in the list.
 
*/
 
%EJECT ;
STALIST_CGINFO : PROC ( CGINFO ) ALTRET ;
 
/*
   Parameters
*/
 
%FPT_CGINFO
       ( FPTN                    = CGINFO,
         STCLASS                 = "" ) ;
 
%EJECT ;
 
VLPVECTOR_TEMP = VLP_VECTOR_TEMP ;
VLPVECTOR_TEMP.PTR$ = TEMP$ ;
VLPVECTOR_TEMP.W1.VSIZE# = ( CURRENT_DATASEG_SIZE -
      POFFW ( TEMP$,
              VLP$VECTOR_CGINFO_DATASEG.PTR$ ) )
      * 4 - 1 ;
CGINFO.STALIST_ = VLPVECTOR_TEMP ;
CALL CGINFO_WITH_DATASEG_EXPANSION ( CGINFO,
                                     CGINFO.STALIST_ )
      ALTRET ( ALT ) ;
SIZE = TEMP$->VLP_CGSTAL_CGINFO.FOUND# * SIZEW ( VLP_CGSTAL_CGINFO.LIST ( 0 ) ) + 1 ;
VLPVECTOR_TEMP.W1.VSIZE# = SIZE * 4 - 1 ;
FPT$CGINFO.STALIST_ = VLPVECTOR_TEMP ;
FOUND = TEMP$->VLP_CGSTAL_CGINFO.FOUND# ;
TEMP$ = PINCRW ( TEMP$,
                 SIZE ) ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END STALIST_CGINFO ;
 
%EJECT ;
/*I*
   NAME:          QLIST_CGINFO
   PURPOSE:       To set up a vector for the QLIST from the space remaining
                  in the data segment, then call M$CGINFO, and finally put
                  a vector framing the used space in FPT$CGINFO
   CALL:          CALL QLIST_CGINFO ( CGINFO )
   PARAMETERS:    CGINFO is the structure in which to place the QLIST
                     vector to use when making the M$CGINFO call (it already
                     contains a vector for the corresponding TYP- or STA-LIST)
   INPUT:         CGINFO
                  FOUND
   OUTPUT:        FPT$CGINFO
                  TEMP$
   INTERFACE:     CGINFO_WITH_DATASEG_EXPANSION
   DESCRIPTION:   Forms a vector of the space remaining in the data segment.
                  Calls the appropriate routine to get the CGINFO.  (The
                  vector for the corresponding list has already been placed in
                  the structure.)
                  Uses the value in found as the number of items to form a vector
                  framing the used space.  Increments the pointer in the data
                  segment to the next available position and returns the
 
*/
 
%EJECT ;
QLIST_CGINFO : PROC ( CGINFO ) ALTRET ;
 
/*
   Parameters
*/
 
%FPT_CGINFO
       ( FPTN                    = CGINFO,
         STCLASS                 = "" ) ;
 
%EJECT ;
 
/*
   This call must be made getting both the QLIST and corresponding TYPLIST
   or STALIST.  The number of items that will fit in the QLIST must be at
   least as large as the number in the corrsponding list.
*/
 
VLPVECTOR_TEMP = VLP_VECTOR_TEMP ;
VLPVECTOR_TEMP.PTR$ = TEMP$ ;
VLPVECTOR_TEMP.W1.VSIZE# = ( CURRENT_DATASEG_SIZE -
      POFFW ( TEMP$,
              VLP$VECTOR_CGINFO_DATASEG.PTR$ ) )
      * 4 - 1 ;
CGINFO.QLIST_ = VLPVECTOR_TEMP ;
CALL CGINFO_WITH_DATASEG_EXPANSION ( CGINFO,
                                     CGINFO.QLIST_ )
      ALTRET ( ALT ) ;
SIZE = FOUND * SIZEW ( VLP_CGQL_CGINFO.LIST ( 0 ) ) ;
VLPVECTOR_TEMP.W1.VSIZE# = SIZE * 4 - 1 ;
FPT$CGINFO.QLIST_ = VLPVECTOR_TEMP ;
TEMP$ = PINCRW ( TEMP$,
                 SIZE ) ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END QLIST_CGINFO ;
 
END LARK_CGINFO_WITH_DATASEG ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_CHECK_AUEVENT
   PURPOSE:       Processes a *AUEV message
   DESCRIPTION:   Makes sure that we should be receiving an AU event and
                  handles it appropriately.
*/
/*I*
   NAME:          LARK_CHECK_AUEVENT
   CALL:          CALL LARK_CHECK_AUEVENT
   INPUT:         CONTROL_NWIO
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_FIND_SLOT
   DESCRIPTION:   Handles a *AUEV message, if one has been received.  First
                  we make sure that we are connected to the comgroup as the
                  AU station.  Then the AU event is announced.
*/
 
%EJECT ;
LARK_CHECK_AUEVENT : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUF_ENTRY;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_FIND_SLOT ;
 
 
/*
   Structures
*/
 
%F$DCB ;
%B$TCB ;
%B$ALT ;
 
%LARK_GLOBALS ;
%LARK_CGINFO;
 
%LARK_FPRGLIST ;
 
%EQU_CG ;
%B$CGAURD ;
%FPT_CLOSE ( FPTN    = CLOSE_FPRG,
             DISP    = RELEASE,
             STCLASS = STATIC ) ;
 
%FPT_ACTIVATE ( FPTN = FPT_DEACTIVATE,
                DCB  = M$CTRLCG ) ;
 
%F_FDS
       (NAME       = FDS,
        BUF        = LOBUF,
        DCB        = M$LO);
%EJECT ;
DCL FMT00   CHAR(0) CONSTANT INIT
('DCB station %A has connected to the comgroup');
DCL FMT01   CHAR(0) CONSTANT INIT ('DCB station %A requests to be activated');
DCL FMT02   CHAR(0) CONSTANT INIT ('DCB station %A has left the comgroup');
DCL FMT03   CHAR(0) CONSTANT INIT
 ('TERMINAL station %A has connected and is active');
DCL FMT04   CHAR(0) CONSTANT INIT
 ('TERMINAL station %A has connected and requests to be activated');
DCL FMT05   CHAR(0) CONSTANT INIT ('TERMINAL station %A has left the comgroup');
DCL FMT06   CHAR(0) CONSTANT INIT
 ('TERMINAL station %A has just pressed <BREAK>');
DCL FMT07   CHAR(0) CONSTANT INIT
 ('TERMINAL station %A has just pressed <CTRL-Y>');
DCL FMT08   CHAR(0) CONSTANT INIT ('TERMINAL station %A is RDY for input');
DCL FMT09   CHAR(0) CONSTANT INIT ('DCB station %A has done an UNLATCH RERUN');
DCL FMT10   CHAR(0) CONSTANT INIT ('DCB station %A has done an UNLATCH HOLD');
DCL FMT11   CHAR(0) CONSTANT INIT ('DCB station %A has done an UNLATCH DELETE');
DCL FMT12   CHAR(0) CONSTANT INIT
 ('Comgroup is low on Memory.  Please adjust MAXPG and DATAPGS');
DCL FMT13   CHAR(0) CONSTANT INIT
 ('Comgroup is low on Disk Space.  Please MOD (SIZE) the comgroup');
DCL FMT14   CHAR(0) CONSTANT INIT
 ('This code, %D is reserved for System Comgroups.  Please report in STARLOG');
DCL FMT15   CHAR(0) CONSTANT INIT
 ('The way LARK is implemented, you should never see this, %A');
DCL FMT16   CHAR(0) CONSTANT INIT
 ('Message %D with Extension(spawn info) %D has been processed and deleted');
DCL FMT17   CHAR(0) CONSTANT INIT
 ('TERMINAL station %A is requesting to be DEACTIVATEd with DSCGO=YES');
DCL FMT18   CHAR(0) CONSTANT INIT
 ('FPRG at station %A has terminated properly');
DCL FMT19   CHAR(0) CONSTANT INIT
 ('FPRG at station %A has aborted for unknown reasons');
DCL FMT20   CHAR(0) CONSTANT INIT
 ('FPRG at station %A has called M$LDTRC successfully');
 
DCL TXT00   CHAR(0) CONSTANT INIT ('FWCG');
%EJECT
/*
   Local data
*/
 
DCL BUFFER$ PTR ;
DCL SLOT SBIN ;
DCL     LOBUF                CHAR(80) STATIC INIT (' ');
DCL     PARAM1               CHAR(8);
DCL     PARAM2               SBIN;
DCL     CGCP$                PTR;
DCL     JRNLSTA$             PTR;
DCL B$TCB$ PTR SYMREF ;
 
BUFFER$ = ADDR ( CONTROL_BUFFER ) ;
CGCP$ = VBASE ( BITVECT ( FPT$CGINFO.CGCP_ ));
JRNLSTA$ = VBASE ( BITVECT ( FPT$CGINFO.JRNLSTA_ ));
PARAM1 = BUFFER$ -> B$CGAURD.STATION;
PARAM2 = BUFFER$ -> B$CGAURD.EVENT;
 
IF NOT M$CTRLCG$->F$DCB.AU# THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
 
CALL LARK_FIND_SLOT( BUFFER$ -> B$CGAURD.STATION, SLOT)
   WHENRETURN DO;
      GOTO HANDLE_FPRG_EVNT;
   END;
 
 
 
/* Guarenteed that it is not a LARK started FPRG */
 
    /* Ignore LARK internal stations $l$a$r$k and $CONxxxx  */
IF (PARAM1 = VLP$SETSTA_LARK.MYSTATION#) OR
   (SUBSTR(PARAM1,0,4) = '$CON')
   THEN RETURN;
 
IF RPT_AU_EVNT( PARAM2 ) THEN
   DO CASE ( PARAM2 ) ;
      CASE (%CG_DOPN#);
        /* If DCB needs permission to OPEN to this comgroup
           send REQUEST ACTIVATION message else say he has connected */
        IF (NOT CGCP$ -> VLP_CGCP_CGINFO.DCBCONAU#) AND
           (JRNLSTA$ -> VLP_JRNLSTA_CGINFO.STATION# ~= PARAM1)
           THEN  CALL X$WRITE(FDS, VECTOR(FMT01), VECTOR(PARAM1));
           ELSE  CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(PARAM1));
      CASE (%CG_DCLS#);
        CALL X$WRITE(FDS, VECTOR(FMT02), VECTOR(PARAM1));
      CASE (%CG_TCON#);
        IF (NOT CGCP$ -> VLP_CGCP_CGINFO.TERMCONAU#)
           THEN CALL X$WRITE(FDS, VECTOR(FMT04), VECTOR(PARAM1));
           ELSE CALL X$WRITE(FDS, VECTOR(FMT03), VECTOR(PARAM1));
      CASE (%CG_TDSC#);
        CALL X$WRITE(FDS, VECTOR(FMT05), VECTOR(PARAM1));
      CASE (%CG_TBRK#);
         DO CASE (BUFFER$ -> B$CGAURD.INFO) ;
            CASE (%CG_TBRK_BRK#);
              CALL X$WRITE(FDS, VECTOR(FMT06), VECTOR(PARAM1));
            CASE (%CG_TBRK_EC#);
              CALL X$WRITE(FDS, VECTOR(FMT07), VECTOR(PARAM1));
            CASE (%CG_TBRK_RDY#);
              CALL X$WRITE(FDS, VECTOR(FMT08), VECTOR(PARAM1));
            END;
      CASE (%CG_UNLR#);
        CALL X$WRITE(FDS, VECTOR(FMT09), VECTOR(PARAM1));
      CASE (%CG_UNLH#);
        CALL X$WRITE(FDS, VECTOR(FMT10), VECTOR(PARAM1));
      CASE (%CG_UNLD#);
        CALL X$WRITE(FDS, VECTOR(FMT11), VECTOR(PARAM1));
      CASE (%CG_WARN#);
         DO CASE (BUFFER$ -> B$CGAURD.INFO) ;
            CASE (%CG_WARN_MEM#);
              CALL X$WRITE(FDS, VECTOR(FMT12));
            CASE (%CG_WARN_DISK#);
              CALL X$WRITE(FDS, VECTOR(FMT13));
            END;
      CASE (%CG_STDSC#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_STHLD#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_SFERR#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_STERR#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_SFEXT#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_SFSPA#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_STOKN#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_STACK#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_AUCON#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_AUDCON#);
        CALL X$WRITE(FDS, VECTOR(FMT14), VECTOR(PARAM2)) ;
      CASE (%CG_FWCG#);
        CALL X$WRITE(FDS, VECTOR(FMT15), VECTOR(TXT00)) ;
      CASE (%CG_JNLD#);
        CALL X$WRITE(FDS, VECTOR(FMT16),
                          VECTOR(BUFFER$ -> B$CGAURD.MID.MSGID),
                          VECTOR(BUFFER$ -> B$CGAURD.MID.MSGIDXT));
      CASE (%CG_TDRQ#);
        CALL X$WRITE(FDS, VECTOR(FMT17), VECTOR(PARAM1)) ;
      CASE (%CG_FPEXIT#);
        CALL X$WRITE(FDS, VECTOR(FMT18), VECTOR(PARAM1)) ;
      CASE (%CG_FPABORT#);
        CALL X$WRITE(FDS, VECTOR(FMT19), VECTOR(PARAM1)) ;
      CASE (%CG_FPLDTRC#);
        CALL X$WRITE(FDS, VECTOR(FMT20), VECTOR(PARAM1)) ;
   END; /* CASE */
RETURN;
 
HANDLE_FPRG_EVNT: ;
 
DO SELECT ( BUFFER$ -> B$CGAURD.EVENT )  ;
   SELECT ( %CG_FPEXIT#, %CG_FPABORT#, %CG_FPLDTRC#, %CG_TDSC# ) ;
                                                   /* Mark this slot free */
      FPRGLIST.ACTIVE# ( SLOT ) = %FALSE ;
      FPRGLIST.IN_USE# ( SLOT ) = %FALSE ;
 
      IF ~ FPRGLIST.DEVPRES# ( SLOT ) THEN DO ;
                                                  /* Regardless of how it*/
                                                  /* started, there is an*/
                                                  /* open dcb, so we must*/
                                                  /* close it            */
           CLOSE_FPRG.V.DCB# = FPRGLIST.DCB# ( SLOT ) ;
           CALL M$CLOSE ( CLOSE_FPRG ) WHENALTRETURN DO ;
                IF ( B$TCB$->B$TCB.ALT$->B$ALT.CODE ~= %E$DCBCLOSED ) THEN DO ;
                    CALL LARK_INTERNAL_ERROR ;
                    GOTO ALT ;
                END ;
           END ;
       END ;
       FPRGLIST_CT = FPRGLIST_CT - 1 ;
   SELECT (  %CG_TDRQ# ) ;
                                                   /* Mark this slot free */
      FPRGLIST.ACTIVE# ( SLOT ) = %FALSE ;
      FPRGLIST.IN_USE# ( SLOT ) = %FALSE ;
 
                                                   /* Give the station     */
                                                   /* permission to        */
                                                   /* disconnect           */
      FPT_DEACTIVATE.V.DSCGO# = %YES# ;
      FPT_DEACTIVATE.STATION_ = VECTOR ( FPRGLIST.STATION# ( SLOT ) ) ;
      CALL M$DEACTIVATE ( FPT_DEACTIVATE ) ALTRET ( ALT ) ;
 
      IF ~ FPRGLIST.DEVPRES# ( SLOT ) THEN DO ;
           CLOSE_FPRG.V.DCB# = FPRGLIST.DCB# ( SLOT ) ;
           CALL M$CLOSE ( CLOSE_FPRG ) WHENALTRETURN DO ;
                IF ( B$TCB$->B$TCB.ALT$->B$ALT.CODE ~= %E$DCBCLOSED ) THEN DO ;
                    CALL LARK_INTERNAL_ERROR ;
                    GOTO ALT ;
                END ;
                END ;
       END ;
      FPRGLIST_CT = FPRGLIST_CT - 1 ;
   SELECT ( %CG_TCON# ) ;
      FPRGLIST.ACTIVE# ( SLOT ) = %TRUE ;
 
   SELECT ( ELSE ) ;
END ;
 
 
   RETURN ;
 
ALT: ;
   ALTRETURN ;
 
END LARK_CHECK_AUEVENT ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_FIND_SLOT
   PURPOSE:       Finds the slot in FPRG list associated with a station
   DESCRIPTION:   Looks for an entry in the FPRG list corresponding
                  to a specified station and returns the slot number
*/
/*I*
   NAME:          LARK_FIND_SLOT
   CALL:          CALL LARK_FIND_SLOT ( STATION, SLOT )
   INPUT:         STATION
                  LARK_GLOBALS
                  LARK_FPRGLIST
*/
%EJECT ;
 
LARK_FIND_SLOT : PROC ( STATION, SLOT ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Structures
*/
%LARK_GLOBALS ;
%LARK_FPRGLIST ;
 
/*
   Parameters
*/
DCL STATION CHAR ( 8 ) ;
DCL SLOT    SBIN ;
/*
   Local data
*/
DCL FOUND BIT ( 1 ) ;
 
 
SLOT  = -1 ;
FOUND = %FALSE ;
 
DO UNTIL ( FOUND OR (SLOT = (%MAX_FPRGS - 1))) ;
   SLOT = SLOT + 1 ;
   FOUND = ( FPRGLIST.STATION# ( SLOT ) = STATION ) &
           FPRGLIST.IN_USE# ( SLOT ) ;
END ;
 
IF NOT FOUND THEN DO ;
   GOTO ALT ;
END ;
 
 
RETURN ;
 
ALT: ;
    ALTRETURN ;
 
END LARK_FIND_SLOT ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*F*
   NAME:          LARK_CHECK_NWIO
   PURPOSE:       Processes an unexpected message from LARKETTE
   DESCRIPTION:   Validates the IO event (if one has occurred), processes
                  the message, and issues another read.
*/
/*I*
   NAME:          LARK_CHECK_NWIO
   CALL:          CALL LARK_CHECK_NWIO
   INPUT:         CONTROL_NWIO
   INTERFACE:     LARK_ABNORMAL_LARKETTE_MESSAGE
                  LARK_CHECK_AUEVENT
                  LARK_CHECK_NWIO_ERRORS
                  LARK_INTERNAL_ERROR
                  LARK_READ_MESSAGE
   DESCRIPTION:   Handles a no-wait IO message, if one has been reported via
                  an event.  First the NWIO error conditions are checked.
                  Then the message is taken care of and another no-wait read
                  is issued.
*/
 
%EJECT ;
LARK_CHECK_NWIO : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_ABNORMAL_LARKETTE_MESSAGE ;
%LARK_CHECK_AUEVENT ;
%LARK_CHECK_NWIO_ERRORS ;
%LARK_INTERNAL_ERROR ;
%LARK_READ_MESSAGE ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%EJECT ;
IF CONTROL_NWIO.COMPLETE THEN DO ;
   CALL LARK_CHECK_NWIO_ERRORS
         ALTRET ( ALT ) ;
   IF ( CONTROL_NWIO.CGPARM.MSGTYP# = '*AUEV' ) THEN DO ;
      CALL LARK_CHECK_AUEVENT
            ALTRET ( ALT ) ;
   END ; ELSE DO ;
      CALL LARK_ABNORMAL_LARKETTE_MESSAGE
            ALTRET ( ALT ) ;
   END ;
   VLP$STATION_CONTROL.STATION# = '?' ;
   CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                            VECTOR ( VLP$STATION_CONTROL ),
                            VECTOR ( CONTROL_BUFFER ) )
         WHENALTRETURN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_CHECK_NWIO ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_CHECK_NWIO_ERRORS
   PURPOSE:       Validates the no-wait IO event
   DESCRIPTION:   Checks to make sure the IO event occurred without reporting
                  the message, and issues another read.
*/
/*I*
   NAME:          LARK_CHECK_NWIO_ERRORS
   CALL:          CALL LARK_CHECK_NWIO_ERRORS
   INPUT:         CONTROL_NWIO
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_REPORT_NWIO_ERROR
   DESCRIPTION:   Validates a no-wait IO message, if one has been reported via
                  an event by checking the NWIO error conditions.  Resets the
                  complete flag so that we will catch the next event.
*/
 
%EJECT ;
LARK_CHECK_NWIO_ERRORS : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_REPORT_NWIO_ERROR ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%EJECT ;
IF CONTROL_NWIO.COMPLETE THEN DO ;
   CONTROL_NWIO.COMPLETE = %NO# ;
   IF ( CONTROL_NWIO.EVID ~= %CONTROL_EVENT ) OR ( ( CONTROL_NWIO.ERR.ERR# ~= 0 ) AND
      ( CONTROL_NWIO.ERR.ERR# ~= %E$LD ) ) THEN DO ;
      CALL LARK_REPORT_NWIO_ERROR ( CONTROL_NWIO ) ;
      GOTO ALT ;
   END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_CHECK_NWIO_ERRORS ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_CLOSE_TEMPSTATION
   PURPOSE:       Close LARK's temporary station
   DESCRIPTION:   Closes the temporary station.
*/
/*D*
   NAME:          LARK_CLOSE_TEMPSTATION
   CALL:          CALL LARK_CLOSE_TEMPSTATION
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Closes the station that is open thru M$CG.
*/
 
%EJECT ;
LARK_CLOSE_TEMPSTATION : PROC ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_CLOSE
       ( FPTN                 = FPT_CLOSE_CG,
         STCLASS              = CONSTANT,
         DCB                  = M$CG ) ;
 
%FPT_CLOSE
       ( FPTN                 = FPTCLOSE_CG,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
DCL      B$TCB$               PTR SYMREF ;
 
%EJECT ;
FPTCLOSE_CG = FPT_CLOSE_CG ;
FPTCLOSE_CG.V_ = VECTOR ( FPTCLOSE_CG.V ) ;
CALL M$CLOSE ( FPTCLOSE_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_CLOSE_TEMPSTATION ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*F*
   NAME:          LARK_CONTROL_NWIO
   PURPOSE:       To store status on completion of a no-wait IO
   DESCRIPTION:   Gets information from the TCB on completion of a no-wait
                  IO.
*/
/*D*
   NAME:          LARK_CONTROL_NWIO
   CALL:          ASYNC routine entered on completion of IO
   OUTPUT:        CONTROL_NWIO
   DESCRIPTION:   Stores information from the TCB and sets flag to signal
                  completion of an IO.
*/
 
%EJECT;
LARK_CONTROL_NWIO : PROC ASYNC ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C62 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$TCB ;
%B$NWIO ;
 
DCL B$NWIO$             PTR ;
DCL B$TCB$              PTR SYMREF ;
 
%EJECT ;
DO INHIBIT ;
   B$NWIO$ = B$TCB$->B$TCB.STK$ ;
   CONTROL_NWIO.COMPLETE = %YES# ;
   CONTROL_NWIO.EVID = B$NWIO$->B$NWIO.EVID ;
   CONTROL_NWIO.ERR = B$NWIO$->B$NWIO.ERR ;
   CONTROL_NWIO.TYC = B$NWIO$->B$NWIO.TYC ;
   CONTROL_NWIO.CGPARM = B$NWIO$->B$NWIO.CGPARM ;
END ;
 
RETURN ;
 
END LARK_CONTROL_NWIO ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_DISPLAY_STATUS
   PURPOSE:       To report the status information from LARKETTE.
   DESCRIPTION:   Prints all information pertaining to the status of a
                  given LARKETTE.
*/
/*D*
   NAME:          LARK_DISPLAY_STATUS
   CALL:          CALL LARK_DISPLAY_STATUS
   INTERFACE:     LARK_REPORT_PMME_ERROR
   INPUT:         STATUS$
   DESCRIPTION:   Prints the information in the STATUS block sent from LARKETTE.
*/
 
%EJECT ;
LARK_DISPLAY_STATUS : PROC ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
 
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XU_FORMAT_C ;
%INCLUDE XUF_ENTRY ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARKETTE_STATUS ;
 
%F_FDS
       ( NAME                 = FDS,
         BUF                  = LOBUF,
         DCB                  = M$LO ) ;
 
/*
   Formats
*/
 
DCL      FMT01                CONSTANT CHAR(0) INIT ('%2(%1/%0A%)') ;
DCL      FMT02                CONSTANT CHAR(0) INIT ('%8A %8A| %8A %12A%4(%8D %)') ;
DCL      FMT03                CONSTANT CHAR(0) INIT ('%0A') ;
DCL      TXT01                CONSTANT CHAR(0) INIT ('LARKETTE Status Report') ;
DCL      TXT02                CONSTANT CHAR(0) INIT
         ('Control  Abt Con | Function Con Def Ssp ReadsAtt ReadErrs WriteAtt WritErrs');
DCL      TXT03                CONSTANT CHAR(0) INIT
         ('Last error received by function station:') ;
 
/*
   Local data
*/
 
DCL      LOBUF                STATIC CHAR ( 80 ) INIT ( ' ' ) ;
DCL      YNS1                 CHAR ( 8 ) ;
DCL   1  YN1                  ( 0:1 ) REDEF YNS1,
         2  V                 CHAR ( 4 ) ;
DCL      YNS2                 CHAR ( 12 ) ;
DCL   1  YN2                  ( 0:2 ) REDEF YNS2,
         2  V                 CHAR ( 4 ) ;
 
%EJECT ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT01 ),
               VECTOR ( TXT01 ),
               VECTOR ( TXT02 ) ) ;
YNS1 = ' NO  NO ' ;
YNS2 = ' NO  NO  NO ' ;
IF STATUS.CONTROL.ABORTED# THEN
   YN1.V ( 0 ) = 'YES ' ;
IF STATUS.CONTROL.CONNECTED# THEN
   YN1.V ( 1 ) = 'YES ' ;
IF STATUS.FUNCTION.CONNECTED# THEN
   YN2.V ( 0 ) = 'YES ' ;
IF STATUS.FUNCTION.DEFINED# THEN
   YN2.V ( 1 ) = 'YES ' ;
IF STATUS.FUNCTION.SUSPENDED# THEN
   YN2.V ( 2 ) = 'YES ' ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT02 ),
               VECTOR ( STATUS.CONTROL.STATION# ),
               VECTOR ( YNS1 ),
               VECTOR ( STATUS.FUNCTION.STATION# ),
               VECTOR ( YNS2 ),
               VECTOR ( STATUS.FUNCTION.READS# ),
               VECTOR ( STATUS.FUNCTION.READ_ERRS# ),
               VECTOR ( STATUS.FUNCTION.WRITES# ),
               VECTOR ( STATUS.FUNCTION.WRITE_ERRS# ) ) ;
 
IF ( STATUS.FUNCTION.ERRCODE.ERR# ~= 0 ) THEN DO ;
   CALL X$WRITE ( FDS,
                  VECTOR ( FMT03 ),
                  VECTOR ( TXT03 ) ) ;
   CALL LARK_REPORT_PMME_ERROR ( STATUS.FUNCTION.ERRCODE,
                                 0 ) ;
END ;
 
END LARK_DISPLAY_STATUS ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_FREECMD_POST_PROCESSOR
   PURPOSE:       To cleanup after taking care of an XUG free (built-in) command
   DESCRIPTION:   Re-issues a control no-wait read if it was aborted by the
                  branch off to the free command.
*/
/*D*
   NAME:          LARK_FREECMD_POST_PROCESSOR
   CALL:          CALL LARK_FREECMD_POST_PROCESSOR
   NOTE:          This routine is called by XUG on return from processing a
                  free command
   DESCRIPTION:   Checks the no-wait function count in the DCB to see if this
                  transfer off to the free command cancelled our control
                  no-wait read.  The free command pre-processor ensures that a
                  no-wait read was outstanding before the call.  If the read was
                  cancelled, a new read is issued.
*/
 
%EJECT ;
LARK_FREECMD_POST_PROCESSOR : PROC ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
%LARK_READ_MESSAGE ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
DCL      B$TCB$                     PTR SYMREF ;
 
%EJECT ;
   DO INHIBIT ;
      IF CONTROL_READ_OUT AND ( M$CTRLCG$->F$DCB.FCN.CNT( 0 ) = 0 ) THEN DO ;
/*N*
         Currently we do not get the event from the terminated no-wait read
         until we do another read and it is satisfied.  At that time, both the
         EOF error and the message that satisfied the read are delivered via
         an event.  This screws up things royally.  See star 30919.
*/
         IF ( CONTROL_NWIO.COMPLETE AND ( CONTROL_NWIO.ERR.ERR# = %E$EOF ) ) OR
            NOT CONTROL_NWIO.COMPLETE THEN DO ;
            CONTROL_NWIO.COMPLETE = %NO# ;
            CALL LARK_READ_MESSAGE ( VECTOR ( FPT$READ_CONTROL.V ),
                                     VECTOR ( VLP$STATION_CONTROL ),
                                     VECTOR ( CONTROL_BUFFER ) )
                  WHENALTRETURN DO ;
                     CALL LARK_INTERNAL_ERROR ;
                  END ;
         END ;
      END ;
   END ;
 
RETURN ;
 
END LARK_FREECMD_POST_PROCESSOR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_FREECMD_PRE_PROCESSOR
   PURPOSE:       To check to see if a control no-wait read is outstanding
   DESCRIPTION:   Sets or resets the CONTROL_READ_OUT flag depending on whether
                  or not a read is outstanding.
*/
/*D*
   NAME:          LARK_FREECMD_PRE_PROCESSOR
   CALL:          CALL LARK_FREECMD_PRE_PROCESSOR
   NOTE:          This routine is called by XUG on before processing a
                  free command
   DESCRIPTION:   Checks the no-wait function count in the DCB to see if there
                  is a control no-wait read outstanding
*/
 
%EJECT ;
LARK_FREECMD_PRE_PROCESSOR : PROC ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%F$DCB ;
 
%EJECT ;
   DO INHIBIT ;
      IF ( M$CTRLCG$->F$DCB.FCN.CNT( 0 ) > 0 ) THEN DO ;
         CONTROL_READ_OUT = %YES# ;
      END ; ELSE DO ;
         CONTROL_READ_OUT = %NO# ;
      END ;
   END ;
 
RETURN ;
 
END LARK_FREECMD_PRE_PROCESSOR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_GET_DATA_SEGMENT
   PURPOSE:       To get or expand a data segment
   DESCRIPTION:   Allocates or expands a data segment.
*/
/*D*
   NAME:          LARK_GET_DATA_SEGMENT
   CALL:          CALL LARK_GET_DATA_SEGMENT ( VLPVECTOR_DATASEG,
                                              SEGSIZE )
   PARAMETERS:    VLPVECTOR_DATASEG vectors the data segment, or is NIL
                  SEGSIZE is the number of words to get or add to the data
                     segment
   INPUT:         SEGSIZE
                  VLPVECTOR_DATASEG
   OUTPUT:        VLPVECTOR_DATASEG
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Uses M$GDS to allocate or expand a data segment.  If
                  the vector supplied is NIL, then new segment is allocated.
*/
 
%EJECT ;
LARK_GET_DATA_SEGMENT : PROC ( VLPVECTOR_DATASEG, SEGSIZE ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Parameters
*/
 
%VLP_VECTOR
       ( FPTN                       = VLPVECTOR_DATASEG,
         STCLASS                    = "" ) ;
 
DCL      SEGSIZE                    SBIN ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_GDS
       ( FPTN                       = FPT_GDS,
         STCLASS                    = CONSTANT,
         PROTECTION                 = DSWRITE ) ;
 
%FPT_GDS
       ( FPTN                       = FPTGDS,
         STCLASS                    = AUTO ) ;
 
DCL      B$TCB$                     PTR SYMREF ;
 
%EJECT ;
   FPTGDS = FPT_GDS ;
   FPTGDS.V_ = VECTOR ( FPTGDS.V ) ;
   FPTGDS.RESULTS_ = VECTOR ( VLPVECTOR_DATASEG ) ;
   FPTGDS.V.SEGSIZE# = SEGSIZE ;
   CALL M$GDS ( FPTGDS )
         WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                         M$CG_DCBNUM ) ;
            GOTO ALT ;
         END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_GET_DATA_SEGMENT ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_INTERNAL_ERROR
   PURPOSE:       Report internal errors (bugs).
   DESCRIPTION:   Outputs a catch-all message for any internal errors which
                  might occur.
*/
/*D*
   NAME:          LARK_INTERNAL_ERROR
   CALL:          CALL LARK_INTERNAL_ERROR
   OUTPUT:        Sets LARK_QUIT to stop program execution.
   DESCRIPTION:   Uses XUG$ERRMSG to issue the internal error message and sets
                  flag to indicate program end.
*/
 
%EJECT ;
LARK_INTERNAL_ERROR : PROC ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
%INCLUDE XU_PERR_C ;
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_INTERNAL_ERR#-7
   MESSAGE0:      LARK internal error occurred... aborting
   MESSAGE1:      A bug exists!
   DESCRIPTION:   This error message is the catch-all message for
                  all internal errors.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
DCL         LARK_QUIT          BIT ( 1 ) SYMREF ;
 
%EJECT ;
VLP$ERRCODE_LARK.ERR# = %E$LARK_INTERNAL_ERR# ;
VLP$ERRCODE_LARK.SEV = 7 ;
XUG$GETCMD_.ERR_CODE = VLP$ERRCODE_LARK ;
XUG$GETCMD_.ERRMFID$ = ADDR ( VLP$NAME_RU ) ;
XUG$GETCMD_.ERRDCB# = DCBNUM ( NIL ) ;
CALL XUG$SETERRMSG ( XUG$GETCMD_ ) ;
CALL XUG$ERRMSG ( XUG$GETCMD_ ) ;
LARK_QUIT = %TRUE ;
 
END LARK_INTERNAL_ERROR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*F*
   NAME:          LARK_OCTALSTRING_BITSTRING
   PURPOSE:       Converts a character string of octal digits to the equivalent
                  bitstring.
   DESCRIPTION:   Returns a right-justified bitstring of up to 36 bits in length.
*/
/*D*
   NAME:          LARK_OCTALSTRING_BITSTRING
   CALL:          CALL LARK_OCTALSTRING_BITSTRING ( OCTALSTRING, COUNT, BITSTRING, LEN )
   PARAMETERS:    OCTALSTRING is the character string of octal digits
                  COUNT is the number of characters in the OCTALSTRING string
                  BITSTRING will hold the converted value
                  LEN is the length of BIT(3)'s in the bitstring (for right justification)
   INPUTS:        OCTALSTRING
                  COUNT
                  LEN
   OUTPUT:        BITSTRING
   DESCRIPTION:   Grabs the low order three bits from each octal character and
                  stuffs them in the bitstring in the appropriate spot.
*/
 
%EJECT ;
LARK_OCTALSTRING_BITSTRING : PROC ( OCTALSTRING, COUNT, BITSTRING, LEN ) ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
/*
   Parameters
*/
 
DCL   1  OCTALSTRING          CALIGNED,
         2  CH                ( 0:11 ) CALIGNED,
            3  *              BIT ( 6 ) UNAL,
            3  OCT            BIT ( 3 ) UNAL ;
DCL      COUNT                UBIN ( 9 ) WALIGNED ;
DCL   1  BITSTRING            HALIGNED,
         2  OCTAL             ( 0:11 ) BIT ( 3 ) UNAL ;
DCL      LEN                  UBIN ;
 
/*
   Local variables
*/
 
DCL      I                    UBIN ;
DCL      OFFSET               UBIN ;
 
%EJECT ;
OFFSET = LEN - COUNT ;
DO I = 0 TO ( COUNT - 1 ) ;
   BITSTRING.OCTAL ( I + OFFSET ) = OCTALSTRING.CH.OCT ( I ) ;
END ;
DO I = 0 TO ( OFFSET - 1 ) ;
   BITSTRING.OCTAL ( I ) = '000'B ;
END ;
 
END LARK_OCTALSTRING_BITSTRING ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_OPEN_TEMPSTATION
   PURPOSE:       Open LARK's temporary station thru DCB M$CG
   DESCRIPTION:   Opens the temporary station, specifying whether or not it
                  should be the AU.
*/
/*D*
   NAME:          LARK_OPEN_TEMPSTATION
   CALL:          CALL LARK_OPEN_TEMPSTATION ( AU )
   PARAMETERS:    AU indicates whether or not the station should be opened as
                     the AU station
   INTERFACE:     LARK_REPORT_PMME_ERROR
   INPUT:         AU
                  VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   Open the temporary station to the previously specified
                  comgroup.  If AU is specified, open as the AU station.
                  Make sure that this is a comgroup file before doing the actual
                  open because a virtual segment error is returned instead of
                  the 'not a comgroup' error because of the SETSTA
                  specification.
*/
 
%EJECT ;
LARK_OPEN_TEMPSTATION : PROC ( AU ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
DCL      AU                BIT ( 1 ) ALIGNED ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_OPEN
       ( FPTN                 = FPT_OPEN_CG,
         STCLASS              = CONSTANT,
         ASN                  = COMGROUP,
         DCB                  = M$CG,
         FUN                  = UPDATE,
         JRNLBYPASS           = YES,
         SCRUB                = YES,
         SHARE                = ALL ) ;
 
%FPT_OPEN
       ( FPTN                 = FPTOPEN_CG,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
DCL      B$TCB$               PTR SYMREF ;
 
%EJECT ;
FPTOPEN_CG = FPT_OPEN_CG ;
FPTOPEN_CG.V_ = VECTOR ( FPTOPEN_CG.V ) ;
IF (M$CTRLCG$->F$DCB.FCD#) AND (M$CTRLCG$->F$DCB.AU#)
   THEN
      FPTOPEN_CG.V.AU#='0'B;  /* ALLOW ONLY ONE AU */
   ELSE
      FPTOPEN_CG.V.AU#= AU ;
FPTOPEN_CG.V.OPER.TEST# = %YES# ;
FPTOPEN_CG.ACCT_ = VECTOR ( VLP$ACCT_CG ) ;
FPTOPEN_CG.NAME_ = VECTOR ( VLP$NAME_CG ) ;
FPTOPEN_CG.PASS_ = VECTOR ( VLP$PASS_CG ) ;
FPTOPEN_CG.SN_ = VECTOR ( VLP$SN_CG ) ;
FPTOPEN_CG.WSN_ = VECTOR ( VLP$WSN_CG ) ;
CALL M$OPEN ( FPTOPEN_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
FPTOPEN_CG.V.OPER.TEST# = %NO# ;
FPTOPEN_CG.SETSTA_ = VECTOR ( VLP$SETSTA_LARK ) ;
CALL M$OPEN ( FPTOPEN_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_OPEN_TEMPSTATION ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*F*
   NAME:          LARK_PROCESS_FID
   PURPOSE:       Process the provided FID.
   DESCRIPTION:   Calls M$FID using the provided FID to obtain the
                  name, account, and password.
*/
/*D*
   NAME:          LARK_PROCESS_FID
   CALL:          CALL LARK_PROCESS_FID ( TEXTFID_VECTOR )
   PARAMETERS:    TEXTFID_ is the vector for the FID to be broken down
   INPUT:         TEXTFID_
   OUTPUT:        VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   INTERFACE:     LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Calls M$FID using the provided FID to obtain the
                  name, account, and password, which are global.
*/
 
%EJECT ;
LARK_PROCESS_FID : PROC ( TEXTFID_ ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_CMD_ERROR ;
 
/*
   Parameters
*/
 
DCL      TEXTFID_             VECTOR ;
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_WILDCARD_IN_FID#-3
   MESSAGE0:      A "?" cannot be included as part of the comgroup FID
   MESSAGE1:      The comgroup FID cannot use any wildcarding
   DESCRIPTION:   If FID contains "?" or user typed a "?" directly following
                  the FID with no spaces between them, it is not accepted.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_FID
       ( FPTN                 = FPT_FID_CG,
         STCLASS              = CONSTANT ) ;
 
%FPT_FID
       ( FPTN                 = FPTFID_CG,
         STCLASS              = AUTO ) ;
 
DCL      B$TCB$               PTR SYMREF ;
DCL      FID_JUNK_AREA        CHAR ( 12 ) ;
DCL      TEXTFID_BASE         CHAR ( TEXTFID_LEN ) BASED ;
DCL      TEXTFID_INDEX        SBIN WORD ;
DCL      TEXTFID_LEN          SBIN WORD ;
 
%EJECT ;
/*
   Checking to make sure "?" does not exist in specified FID.
*/
 
TEXTFID_LEN = VBOUND ( TEXTFID_ ) + 1 ;
CALL INDEX ( TEXTFID_INDEX,
             '?',
             VBASE ( TEXTFID_ ) -> TEXTFID_BASE )
      WHENRETURN DO ;
         CALL LARK_REPORT_CMD_ERROR ( %E$LARK_WILDCARD_IN_FID#,
                                     3 ) ;
         GOTO ALT ;
      END ;
 
/*
   Processing the FID.
*/
 
FPTFID_CG = FPT_FID_CG ;
FPTFID_CG.V_ = VECTOR ( FPTFID_CG.V ) ;
FPTFID_CG.TEXTFID_ = TEXTFID_ ;
FPTFID_CG.ACCT_ = VECTOR ( VLP$ACCT_CG ) ;
VLP$NAME_CG.L# = 31 ;
FPTFID_CG.NAME_ = VECTOR ( VLP$NAME_CG ) ;
FPTFID_CG.PASS_ = VECTOR ( VLP$PASS_CG ) ;
FPTFID_CG.SN_ = VECTOR ( VLP$SN_CG ) ;
FPTFID_CG.WSN_ = VECTOR ( VLP$WSN_CG ) ;
FPTFID_CG.ASN_ = VECTOR ( FID_JUNK_AREA ) ;
FPTFID_CG.RES_ = VECTOR ( FID_JUNK_AREA ) ;
FPTFID_CG.RESULTS_ = VECTOR ( FID_JUNK_AREA ) ;
CALL M$FID ( FPTFID_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT : ;
   ALTRETURN ;
 
END LARK_PROCESS_FID ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*F*
   NAME:          LARK_READ_MESSAGE
   PURPOSE:       To read a message through the active comgroup
   DESCRIPTION:   Reads a message using the supplied information.
*/
/*D*
   NAME:          LARK_READ_MESSAGE
   CALL:          CALL LARK_READ_MESSAGE ( READV_, STATION_, BUFFER_ )
   PARAMETERS:    READV_ is FPT_READ.V_
                  STATION_ is FPT_READ.STATION_
                  BUFFER_ is FPT_READ.BUF_ (will hold data to be read)
   INPUT:         READV_
                  STATION_
                  BUFFER_
   OUTPUT:        BUFFER of data
                  ALTRETs if error occurs on READ operation
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Generic routine to read through the comgroup and handle
                  errors that might occur.
*/
 
%EJECT ;
LARK_READ_MESSAGE : PROC ( READV_, STATION_, BUFFER_ ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE F$CP6V_C ;
 
%INCLUDE LARK_C62 ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
DCL      READV_         VECTOR ;
DCL      STATION_       VECTOR ;
DCL      BUFFER_        VECTOR ;
 
/*
   Structures
*/
 
%B$ALT ;
 
%B$TCB ;
 
%FPT$READ_V ;
 
%FPT_READ
       ( FPTN           = FPT_READ,
         STCLASS        = CONSTANT ) ;
 
%FPT_READ
       ( FPTN           = FPTREAD,
         STCLASS        = AUTO ) ;
 
DCL      B$TCB$         PTR SYMREF ;
DCL      READV$         PTR ;
 
%EJECT ;
FPTREAD = FPT_READ ;
FPTREAD.V_ = READV_ ;
FPTREAD.STATION_ = STATION_ ;
FPTREAD.BUF_ = BUFFER_ ;
CALL M$READ ( FPTREAD )
      WHENALTRETURN DO ;
         READV$ = VBASE ( READV_ ) ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       READV$->FPT$READ_V.DCB# ) ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_READ_MESSAGE ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_RELEASE_DATA_SEGMENT
   PURPOSE:       To release the supplied data segment if it has been
                  allocated
   DESCRIPTION:   Releases allocated data segment.
*/
/*D*
   NAME:          LARK_RELEASE_DATA_SEGMENT
   CALL:          CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_DATASEG )
   PARAMETERS:    VLPVECTOR_DATASEG vectors the data segment, or is NIL
   INPUT:         VLPVECTOR_DATASEG
   OUTPUT:        VLPVECTOR_DATASEG
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   If the vector supplied is not NIL, the data segment
                  is freed;  if it is, nothing is done.
                  Uses M$FDS to determine the size of the data segment
                  and then calls M$FDS to release the segment.
*/
 
%EJECT ;
LARK_RELEASE_DATA_SEGMENT : PROC ( VLPVECTOR_DATASEG ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Parameters
*/
 
%VLP_VECTOR
       ( FPTN                       = VLPVECTOR_DATASEG,
         STCLASS                    = "" ) ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_FDS
       ( FPTN                       = FPT_FDS,
         STCLASS                    = CONSTANT ) ;
 
%FPT_FDS
       ( FPTN                       = FPTFDS,
         STCLASS                    = AUTO ) ;
 
DCL      B$TCB$                     PTR SYMREF ;
 
%EJECT ;
IF ( VLPVECTOR_DATASEG ~= VECTOR ( NIL ) ) THEN DO ;
   FPTFDS = FPT_FDS ;
   FPTFDS.V_ = VECTOR ( FPTFDS.V ) ;
   FPTFDS.RESULTS_ = VECTOR ( VLPVECTOR_DATASEG ) ;
   CALL M$FDS ( FPTFDS )
         WHENRETURN DO ;
            FPTFDS.V.SEGSIZE# = ( VLPVECTOR_DATASEG.W1.VSIZE# + 1 ) / 4 ;
            CALL M$FDS ( FPTFDS )
                  WHENALTRETURN DO ;
                     CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                   M$CG_DCBNUM ) ;
                     GOTO ALT ;
                  END ;
         END ;
         WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                          M$CG_DCBNUM ) ;
            GOTO ALT ;
         END ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_RELEASE_DATA_SEGMENT ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_REPORT_CMD_ERROR
   PURPOSE:       Reports the provided error for the commands.
   DESCRIPTION:   Calls error message routines to report error.
*/
/*I*
   NAME:          LARK_REPORT_CMD_ERROR
   CALL:          CALL LARK_REPORT_CMD_ERROR ( ERR_CODE, ERR_SEV )
   PARAMETERS:    ERR_CODE is the error code of the LARK error
                  ERR_SEV is the severity of the error
   INPUT:         ERR_CODE
                  ERR_SEV
   DESCRIPTION:   Calls XUG_SETERRMSG and XUG_ERRMSG after setting the
                  appropriate parameters in the XUG$GETCMD_ structure which
                  is used for first level commands.  The error message
                  will be located in the run unit error message file.
*/
 
%EJECT ;
LARK_REPORT_CMD_ERROR : PROC ( ERR_CODE, ERR_SEV ) ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Parameters
*/
 
DCL      ERR_CODE                UBIN WORD ;
DCL      ERR_SEV                 UBIN WORD ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%EJECT ;
VLP$ERRCODE_LARK.ERR# = ERR_CODE ;
VLP$ERRCODE_LARK.SEV = ERR_SEV ;
XUG$GETCMD_.ERRMFID$ = ADDR ( VLP$NAME_RU ) ;
XUG$GETCMD_.ERRDCB# = DCBNUM ( NIL ) ;
XUG$GETCMD_.ERR_CODE = VLP$ERRCODE_LARK ;
CALL XUG$SETERRMSG ( XUG$GETCMD_ ) ;
CALL XUG$ERRMSG ( XUG$GETCMD_ ) ;
 
END LARK_REPORT_CMD_ERROR ;
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_REPORT_NWIO_ERROR
   PURPOSE:       To report the appropriate NWIO error.
   DESCRIPTION:   Prints all information about the NWIO error.
*/
/*D*
   NAME:          LARK_REPORT_NWIO_ERROR
   CALL:          CALL LARK_REPORT_NWIO_ERROR ( NWIO_INFO )
   PARAMETER:     NWIO_INFO contains information about the no-wait IO error
   INPUT:         NWIO_INFO
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Prints the information in NWIO_INFO and reports the error
                  message, if non-zero.
*/
 
%EJECT ;
LARK_REPORT_NWIO_ERROR : PROC ( NWIO_INFO ) ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XU_FORMAT_C ;
%INCLUDE XUF_ENTRY ;
 
/*
   Parameters
*/
 
DCL   1  NWIO_INFO,
         2  COMPLETE          BIT ( 1 ) ALIGNED,
         2  EVID              UBIN WORD,
         2  ERR               BIT ( 36 ),
         2  TYC               BIT ( 36 ) ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%F_FDS
       ( NAME                 = FDS,
         BUF                  = LOBUF,
         DCB                  = M$LO ) ;
 
/*
   Formats
*/
 
DCL      FMT01                CONSTANT CHAR(0) INIT ('%2(%1/%0A%)') ;
DCL      FMT02                CONSTANT CHAR(0) INIT ('%8D %12O') ;
DCL      TXT01                CONSTANT CHAR(0) INIT ('No-wait Read Error') ;
DCL      TXT02                CONSTANT CHAR(0) INIT ('  EvID         TYC') ;
 
/*
   Local data
*/
 
DCL      LOBUF                STATIC CHAR ( 80 ) INIT ( ' ' ) ;
 
%EJECT ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT01 ),
               VECTOR ( TXT01 ),
               VECTOR ( TXT02 ) ) ;
CALL X$WRITE ( FDS,
               VECTOR ( FMT02 ),
               VECTOR ( NWIO_INFO.EVID ),
               VECTOR ( NWIO_INFO.TYC ) ) ;
IF ( BITBIN ( NWIO_INFO.ERR ) ~= 0 ) THEN DO ;
   CALL LARK_REPORT_PMME_ERROR ( NWIO_INFO.ERR,
                                 M$CTRLCG_DCBNUM ) ;
END ;
 
END LARK_REPORT_NWIO_ERROR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_REPORT_PMME_ERROR
   PURPOSE:       To report the appropriate PMME error.
   DESCRIPTION:   Uses the XUG services to report the error.
*/
/*D*
   NAME:          LARK_REPORT_PMME_ERROR
   CALL:          CALL LARK_REPORT_PMME_ERROR ( PMME_ERR_CODE, ERR_DCBNUM )
   PARAMETERS:    PMME_ERR_CODE is the error code in B$ALT.ERR
                  ERR_DCBNUM is the number of the DCB on which the error
                        occurred
   INPUT:         PMME_ERR_CODE
                  ERR_DCBNUM
   DESCRIPTION:   Calls XUG_SETERRMSG and XUG_ERRMSG after setting the
                  appropriate parameters.  Also closes all open DCB's.
                  The error message will be located in the default error
                  message file.
*/
 
%EJECT ;
LARK_REPORT_PMME_ERROR : PROC ( PMME_ERR_CODE, ERR_DCBNUM ) ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Parameters
*/
 
%VLP_ERRCODE
       ( FPTN                    = PMME_ERR_CODE,
         STCLASS                 = "" ) ;
 
DCL      ERR_DCBNUM              UBIN ( 18 ) HALIGNED ;
 
/*
   Entries
*/
 
%LARK_INTERNAL_ERROR ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%F$DCB ;
 
%FPT_CLOSE
       ( FPTN                    = FPT_CLOSE,
         STCLASS                 = CONSTANT,
         DCB                     = M$CG,
         DISP                    = SAVE ) ;
 
%FPT_CLOSE
       ( FPTN                    = FPTCLOSE,
         STCLASS                 = AUTO ) ;
 
 
%EJECT ;
XUG$GETCMD_.ERRMFID$ = ADDR ( NIL ) ;
XUG$GETCMD_.ERRDCB# = ERR_DCBNUM ;
XUG$GETCMD_.ERR_CODE = PMME_ERR_CODE ;
CALL XUG$SETERRMSG ( XUG$GETCMD_ ) ;
CALL XUG$ERRMSG ( XUG$GETCMD_ ) ;
IF ( ERR_DCBNUM = M$CG_DCBNUM ) AND M$CG$->F$DCB.FCD# THEN DO ;
   FPTCLOSE = FPT_CLOSE ;
   FPTCLOSE.V_ = VECTOR ( FPTCLOSE.V ) ;
   CALL M$CLOSE ( FPTCLOSE )
         WHENALTRETURN DO ;
            CALL LARK_INTERNAL_ERROR ;
         END ;
END ;
 
END LARK_REPORT_PMME_ERROR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_REPORT_SUBCMD_ERROR
   PURPOSE:       Reports the provided error for the subcommands.
   DESCRIPTION:   Calls error message routines to report error.
*/
/*I*
   NAME:          LARK_REPORT_SUBCMD_ERROR
   CALL:          CALL LARK_REPORT_SUBCMD_ERROR ( ERR_CODE, ERR_SEV )
   PARAMETERS:    ERR_CODE is the error code of the LARK error
                  ERR_SEV is the severity of the error
   INPUT:         ERR_CODE
                  ERR_SEV
   DESCRIPTION:   Calls XUG_SETERRMSG and XUG_ERRMSG after setting the
                  appropriate parameters in the XUG$GETCMD_SUB structure,
                  which is used for second level commands.  The error message
                  will be located in the run unit error message file.
*/
 
%EJECT ;
LARK_REPORT_SUBCMD_ERROR : PROC ( ERR_CODE, ERR_SEV ) ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Parameters
*/
 
DCL      ERR_CODE                UBIN WORD ;
DCL      ERR_SEV                 UBIN WORD ;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%EJECT ;
VLP$ERRCODE_LARK.ERR# = ERR_CODE ;
VLP$ERRCODE_LARK.SEV = ERR_SEV ;
XUG$GETCMD_SUB.ERRMFID$ = ADDR ( VLP$NAME_RU ) ;
XUG$GETCMD_SUB.ERRDCB# = DCBNUM ( NIL ) ;
XUG$GETCMD_SUB.ERR_CODE = VLP$ERRCODE_LARK ;
CALL XUG$SETERRMSG ( XUG$GETCMD_SUB ) ;
CALL XUG$ERRMSG ( XUG$GETCMD_SUB ) ;
 
END LARK_REPORT_SUBCMD_ERROR ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*F*
   NAME:          LARK_SIZE_DATA_SEGMENT
   PURPOSE:       To supply the size of the given data segment
   DESCRIPTION:   Gets size of allocated data segment.
*/
/*D*
   NAME:          LARK_SIZE_DATA_SEGMENT
   CALL:          CALL LARK_SIZE_DATA_SEGMENT ( VLPVECTOR_DATASEG,
                                                DATASEG_SIZE )
   PARAMETERS:    VLPVECTOR_DATASEG vectors the data segment, or is NIL
   INPUT:         VLPVECTOR_DATASEG
   OUTPUT:        DATASEG_SIZE
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   If the vector supplied is not NIL, the data segment
                  size is supplied; otherwise zero is returned.
                  Uses M$GDS to determine the size of the data segment.
*/
 
%EJECT ;
LARK_SIZE_DATA_SEGMENT : PROC ( VLPVECTOR_DATASEG, DATASEG_SIZE ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
 
/*
   Parameters
*/
 
%VLP_VECTOR
       ( FPTN                       = VLPVECTOR_DATASEG,
         STCLASS                    = "" ) ;
 
DCL      DATASEG_SIZE               SBIN ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR;
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_GDS
       ( FPTN                       = FPT_GDS,
         STCLASS                    = CONSTANT ) ;
 
%FPT_GDS
       ( FPTN                       = FPTGDS,
         STCLASS                    = AUTO ) ;
 
DCL      B$TCB$                     PTR SYMREF ;
 
%EJECT ;
IF ( VLPVECTOR_DATASEG ~= VECTOR ( NIL ) ) THEN DO ;
   FPTGDS = FPT_GDS ;
   FPTGDS.V_ = VECTOR ( FPTGDS.V ) ;
   FPTGDS.RESULTS_ = VECTOR ( VLPVECTOR_DATASEG ) ;
   CALL M$GDS ( FPTGDS )
         WHENRETURN DO ;
            DATASEG_SIZE = ( VLPVECTOR_DATASEG.W1.VSIZE# + 1 ) / 4 ;
         END ;
         WHENALTRETURN DO ;
            CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                          M$CG_DCBNUM ) ;
            GOTO ALT ;
         END ;
END ; ELSE DO ;
   DATASEG_SIZE = 0 ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_SIZE_DATA_SEGMENT ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*F*
   NAME:          LARK_WRITE_MESSAGE
   PURPOSE:       To write a message through the active comgroup
   DESCRIPTION:   Writes a message using the supplied information.
*/
/*D*
   NAME:          LARK_WRITE_MESSAGE
   CALL:          CALL LARK_WRITE_MESSAGE ( WRITEV_, STATION_, BUFFER_ )
   PARAMETERS:    WRITEV_ is FPT_WRITE.V_
                  STATION_ is FPT_WRITE.STATION_
                  BUFFER_ is FPT_WRITE.BUF_ (data to be written)
   INPUT:         WRITEV_
                  STATION_
                  BUFFER_
   OUTPUT:        ALTRETs if error occurs on WRITE operation
   INTERFACE:     LARK_REPORT_PMME_ERROR
   DESCRIPTION:   Generic routine to write through the comgroup and handle
                  errors that might occur.
*/
 
%EJECT ;
LARK_WRITE_MESSAGE : PROC ( WRITEV_, STATION_, BUFFER_ ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE F$CP6V_C ;
 
%INCLUDE LARK_C62 ;
 
/*
   Entries
*/
 
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
DCL      WRITEV_        VECTOR ;
DCL      STATION_       VECTOR ;
DCL      BUFFER_        VECTOR ;
 
/*
   Structures
*/
 
%B$ALT ;
 
%B$TCB ;
 
%FPT$WRITE_V ;
 
%FPT_WRITE
       ( FPTN           = FPT_WRITE,
         STCLASS        = CONSTANT ) ;
 
%FPT_WRITE
       ( FPTN           = FPTWRITE,
         STCLASS        = AUTO ) ;
 
DCL      B$TCB$         PTR SYMREF ;
DCL      WRITEV$        PTR ;
 
%EJECT ;
FPTWRITE = FPT_WRITE ;
FPTWRITE.V_ = WRITEV_ ;
FPTWRITE.STATION_ = STATION_ ;
FPTWRITE.BUF_ = BUFFER_ ;
CALL M$WRITE ( FPTWRITE )
      WHENALTRETURN DO ;
         WRITEV$ = VBASE ( WRITEV_ ) ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       WRITEV$->FPT$WRITE_V.DCB# ) ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_WRITE_MESSAGE ;
