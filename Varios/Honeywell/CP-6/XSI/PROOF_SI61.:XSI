/*M* PROOF - a document proofreader */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
PROOF: PROC MAIN NOAUTO;
 
/* ********************************************************************\
*                                                                      *
*   PROOF is a document proofreader.  It "reads" a document and breaks *
*   it up into "words" consisting of contiguous strings of letters and *
*   numbers, both upper and lower case, and hyphens (-) and quotes     *
*   (').  Each word is then compared with properly-spelled words in a  *
*   dictionary; matches are discarded and the remaining "words" are    *
*   sorted into alphabetic order and printed along with the line       *
*   references on which they appear (either line numbers or EDIT       *
*   keys).                                                             *
*                                                                      *
*   PROOF runs on-line or in batch and automatically adjusts for the   *
*   user's line width.  PROOF is invoked by the IBEX command           *
*                                                                      *
*       !PROOF.X doc-name[,dict-name][ ON,LP[@station]][(options)]     *
*                                                                      *
*   where "doc-name" is the name of the TEXT document to be scanned    *
*   and LP[@station] is the (optional) output device for the cross-    *
*   reference printout.                                                *
*                                                                      *
*   For a list of legal options, see PROOF_HELP.X.                     *
*                                                                      *
*   The dictionary is permanently defined as PROOF_DIC.X  and may not  *
*   be changed by the user.                                            *
*                                                                      *
*   Input is not restricted to TEXT files; however, it must contain    *
*   printable ASCII graphics in records less than 257 bytes long.      *
*                                                                      *
\******************************************************************** */
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   %INCLUDEs                                                          *
*                                                                      *
\******************************************************************** */
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE ZL_MACRO_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
%INCLUDE PROOF_C61;
 
/* ********************************************************************\
*                                                                      *
*   FPTs                                                               *
*                                                                      *
\******************************************************************** */
 
%FPT_OPEN(FPTN=OPEN_LO,
          DCB=M$LO,
          FUN=CREATE,
          EXIST=OLDFILE);
 
%FPT_OPEN(FPTN=OPEN_SI,
          DCB=M$SI,
          FUN=IN);
 
%FPT_OPEN(FPTN=OPEN_DICT,
          DCB=F$DICT,
          FUN=IN,
          SHARE=IN,
          ASN=FILE,
          NAME=NAME_DICT,
          ACCT=ACCT_DICT);
 
%FPT_OPEN(FPTN=OPEN_ALT,
          DCB=F$ALT,
          FUN=IN,
          SHARE=IN);
 
%FPT_OPEN(FPTN=OPEN_XREF,
          DCB=F$XREF,
          FUN=CREATE,
          NAME=NAME_XREF,
          ASN=FILE,
          EXIST=NEWFILE);
 
%FPT_OPEN(FPTN=OPEN_TF,
          DCB=F$TF,
          FUN=CREATE,
          NAME=NAME_TF,
          ASN=FILE,
          EXIST=NEWFILE);
 
%VLP_NAME(FPTN=NAME_DICT,
          LEN=9,
          NAME="'PROOF_DIC'");
 
%VLP_NAME(FPTN=NAME_XREF,
          LEN=10,
          NAME="'*PROOFXREF'");
 
%VLP_NAME(FPTN=NAME_TF,
          LEN=9,
          NAME="'*SORTCMDS'");
 
%VLP_ACCT(FPTN=ACCT_DICT,
          ACCT="'X       '");
 
%FPT_READ(FPTN=READ_SI,
          DCB=M$SI,
          BUF=SIBUF,
          KEY=KEYBUF,
          KEYR=YES);
 
%FPT_PRECORD(FPTN=PRECORD_DICT,
          DCB=F$DICT,
          KEY=KEYBUF,
          KEYR=YES,
          KEYS=YES);
 
%FPT_PRECORD(FPTN=PRECORD_ALT,
          DCB=F$ALT,
          KEY=KEYBUF,
          KEYR=YES,
          KEYS=YES);
 
%FPT_READ(FPTN=READ_XREF,
          DCB=F$XREF,
          BUF=X);
 
%FPT_WRITE(FPTN=WRITE_ME,
           DCB=M$ME,
           BUF=MEBUF);
 
%FPT_WRITE(FPTN=WRITE_LO,
           DCB=M$LO,
           BUF=LOBUF);
 
%FPT_WRITE(FPTN=WRITE_DO,
           DCB=M$DO,
           BUF=LOBUF);
 
%FPT_WRITE(FPTN=WRITE_XREF,
           DCB=F$XREF,
           BUF=X);
 
%FPT_WRITE(FPTN=WRITE_TF,
           DCB=F$TF,
           BUF=SIBUF);
 
%FPT_CLOSE(FPTN=CLOSE_SI,
           DCB=M$SI,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_LO,
           DCB=M$LO,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_DICT,
           DCB=F$DICT,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_ALT,
           DCB=F$ALT,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_XREF,
           DCB=F$XREF,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_TF,
           DCB=F$TF,
           DISP=SAVE);
 
%FPT_ERRMSG(BUF=LOBUF,
            OUTDCB1=M$LO,
            SUBFN=YES,
            SUBAC=YES,
            SUBDC=YES,
            SUBSN=YES,
            SUBMESS=YES);
 
%FPT_DEVICE(FPTN=PAGE_LO,
            DCB=M$LO,
            HDR=VLP_HDR,
            PAGE=YES);
 
%FPT_ERRMSG(FPTN=PROOF_ERR,
            BUF=WORK_AREA,
            OUTDCB1=M$DO);
%VLP_HDR(HEADERHEIGHT=2,
         TITLE='                                                            ',
         COUNT=57,
         LEN=60);
 
    DCL 1 OVR_HDR REDEF VLP_HDR,
          2 * UNAL                     CHAR(5),
          2 DOWX UNAL                  CHAR(4),
          2 DATX UNAL                  CHAR(9),
          2 TIMX UNAL                  CHAR(11),
          2 FNAM UNAL                  CHAR(32),
          2 * UNAL                     CHAR(7);
 
%FPT_TIME(SOURCE=CLOCK,
          DEST=LOCAL,
          DAY=OVR_HDR.DOWX,
          DATE=OVR_HDR.DATX,
          TIME=OVR_HDR.TIMX);
 
%FPT_INT(UENTRY=YOUCALLD);
 
%FPT_LINK(NAME=NAME_SORT,
          CMD=CMD_SORT,
          ACCT=ACCT_SYS);
 
%VLP_NAME(FPTN=NAME_SORT,
          LEN=4,
          NAME="'SORT'");
 
%VLP_ACCT(FPTN=ACCT_SYS,
          ACCT="':SYS'");
 
%FPT_YC(CMD=SIBUF);
 
%FPT_CMDVAR(FPTN=FPT_CMDVAR,
            FUN=FETCH,
            NAME=SORT$STAT_NAME,
            VALUE=VALUE_ERRORS);
%VLP_NAME(FPTN=VALUE_ERRORS,
          NAME='ERRORS');
%VLP_NAME(FPTN=SORT$STAT_NAME,
          NAME='SORT$STAT');
 
%P_PCB(NAME=PROOF_PCB,
      R=PROOF_CMD,
      W=WORK_AREA,
      WSZ="SIZEW(WORK_AREA)");
%PARSE$OUT(STCLASS=BASED);
%PARSE$SYM(STCLASS=BASED);
 
DCL   WORK_AREA(0:1023)                UBIN(36)  STATIC;
DCL   PROOF_CMD                        BIT(36)   SYMREF;
%F$DCB(DCBN=DUMMY);
 
%B$TCB;
 
%B$ALT;
 
%EJECT;
DCL   1  KEYWORD(0:99)                STATIC    CALIGNED,
         2  TEXT                       CHAR(31),
         2  TALLY                      UBIN(9)   CALIGNED;
DCL   1  WRD                           STATIC    CALIGNED,
         2  TEXT                       CHAR(31),
         2  TALLY                      UBIN(9)   CALIGNED;
DCL   XREF_EOF                         BIT(1)    STATIC;
DCL   N                                UBIN(9)   STATIC;
DCL   INX                              SBIN      STATIC;
DCL   TALLY                            CHAR(5)   STATIC;
DCL   IX                               SBIN      STATIC;
DCL   LASTWORD                         CHAR(31)  STATIC;
DCL   FINAL                            SBIN      STATIC SYMDEF;
DCL   FINALTALLY                       UBIN      STATIC;
DCL   KEYWORD#                         UBIN      STATIC;
DCL   LIMIT                            UBIN      STATIC;
 
%EQU  TRUE  =  '1'B;
%EQU  FALSE =  '0'B;
%EQU  SPACE =  ' ';
%SUB  FOREVER  =  "WHILE('1'B)";
%SUB  LEFT_DELIM = '{';
%SUB  INTRO = '\';
 
/* ********************************************************************\
*                                                                      *
*   Working storage.                                                   *
*                                                                      *
\******************************************************************** */
 
    DCL M$SI                           DCB;
    DCL M$LO                           DCB;
    DCL M$DO                           DCB;
    DCL M$ME                           DCB;
    DCL F$DICT                         DCB;
    DCL F$ALT                          DCB;
    DCL F$XREF                         DCB;
    DCL F$TF                           DCB;
 
    DCL 1 NO_SPCHARS CONSTANT,
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _'),
          2 * CHAR(32) INIT(' abcdefghijklmnopqrstuvwxyz     '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _'),
          2 * CHAR(32) INIT(' abcdefghijklmnopqrstuvwxyz     '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _'),
          2 * CHAR(32) INIT(' abcdefghijklmnopqrstuvwxyz     '),
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _'),
          2 * CHAR(32) INIT(' abcdefghijklmnopqrstuvwxyz     ');
 
    DCL 1 ALL_NUMBERS CONSTANT,
          2 *(0:31) UNAL BIT(9) INIT('123'O*32),
          2 *(0:31) UNAL BIT(9) INIT('123'O*3,'000'O*3,'123'O,'000'O,
            '123'O*5,'000'O,'123'O*2,'000'O*10,'123'O*6),
          2 *(0:31) UNAL BIT(9) INIT('000'O,'123'O*30,'000'O),
          2 *(0:31) UNAL BIT(9) INIT('123'O*32);
 
    DCL 1 UPPERS CONSTANT,
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _'),
          2 * CHAR(32) INIT(' ABCDEFGHIJKLMNOPQRSTUVWXYZ     ');
 
    DCL 1 LOWERS CONSTANT,
          2 * CHAR(32) INIT('                                '),
          2 * CHAR(32) INIT('   #$% ''     -  0123456789      '),
          2 * CHAR(32) INIT('@abcdefghijklmnopqrstuvwxyz    _'),
          2 * CHAR(32) INIT(' abcdefghijklmnopqrstuvwxyz     ');
 
    DCL LOBUF STATIC                   CHAR(266);
 
    DCL SIBUF STATIC                   CHAR(256);
 
    DCL MEBUF STATIC                   CHAR(80);
 
    DCL 1 X STATIC,
          2 XWORD UNAL                 CHAR(31),
          2 XREF UNAL                  CHAR(9);
 
    DCL 1 OLDBUF STATIC,
          2 L UNAL                     UBIN BYTE,
          2 C UNAL                     CHAR(31);
 
    DCL 1 KEYBUF STATIC,
          2 L UNAL                     UBIN BYTE,
          2 C UNAL                     CHAR(31);
 
    DCL OVERKEY (0:31) REDEF KEYBUF UBIN BYTE UNAL;
 
    DCL DICTBUF STATIC                 CHAR(256);
 
    DCL TWORD STATIC    CHAR(31);
    DCL AWORD STATIC                   CHAR(31);
    DCL 1 W REDEF AWORD,
          2 FRST UNAL                  CHAR(1),
          2 REST UNAL                  CHAR(30);
 
    DCL BWORD STATIC                   CHAR(31);
 
    DCL 1 B REDEF BWORD,
          2 FRST UNAL       CHAR(1),
          2 REST UNAL       CHAR(30);
 
    DCL CWORD STATIC                   CHAR(31);
 
    DCL RECCNT STATIC                  SBIN;
    DCL 1 TEXT REDEF RECCNT,
          2 * UNAL                     CHAR(1),
          2 KEY UNAL                   CHAR(3);
 
    DCL LINEREF STATIC                 CHAR(9);
    DCL 1 EDIT REDEF LINEREF,
          2 INTG UNAL                  CHAR(5),
          2 PER UNAL                   CHAR(1),
          2 FRAC UNAL                  CHAR(3);
 
    DCL B$JIT$ SYMREF                  PTR;
    DCL B$TCB$ SYMREF                  PTR;
    DCL M$SIPTR                        PTR;
    DCL M$LOPTR                        PTR;
    DCL YOUCALLD                       ENTRY ASYNC;
DCL   X$PARSE                          ENTRY(1)  ALTRET;
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
    DCL Z                              SBIN;
    DCL LEN                            SBIN;
    DCL ARS                            SBIN;
    DCL MAX                            SBIN;
    DCL WLEN                           SBIN;
    DCL CNTWRDS                        SBIN;
    DCL CNTDICT STATIC                 SBIN INIT(174);
    DCL CNTREFS                        SBIN;
 
    DCL CHL                            CHAR(1);
    DCL CHM                            CHAR(1);
    DCL CHR                            CHAR(1);
    DCL VARSTG BASED UNAL              CHAR(LEN);
 
    DCL KEYED_FILE                     BIT(1);
    DCL ERRMSG_FILE                    BIT(1);
 
    DCL 1 OPT,
          2 LS                         BIT(1),
          2 ALT                        BIT(1),
          2 AO                         BIT(1),
          2 PO                         BIT(1),
          2 NR                         BIT(1),
          2 ID                         BIT(1),
          2 TC                         BIT(1),
          2 KW                         BIT(1),
          2 PCT                        BIT(1),
          2 TEX                        BIT(1);
 
DCL   PCT_FACTOR                       UBIN      STATIC;
      /* Percentage x 100 that user gave on WF=.nn option */
 
    DCL BROKEN SYMREF                  BIT(1);
 
    DCL ENCTXT                         CHAR(6);
    DCL 1 ENC REDEF ENCTXT,
          2 * UNAL                     CHAR(1),
          2 FCG1 UNAL                  UBIN(6),
          2 FCG2 UNAL                  UBIN(6),
          2 FCG3 UNAL                  UBIN(6),
          2 MON UNAL                   BIT(1),
          2 CODE UNAL                  UBIN(14),
          2 SEV UNAL                   UBIN(3),
          2 LIN UNAL                   UBIN BYTE;
 
    DCL DECTXT STATIC                  CHAR(16) INIT('FCG-MCODE#-S/LIN');
    DCL 1 DEC REDEF DECTXT,
          2 FCG1 UNAL                  CHAR(1),
          2 FCG2 UNAL                  CHAR(1),
          2 FCG3 UNAL                  CHAR(1),
          2 * UNAL                     CHAR(1),
          2 MON UNAL                   CHAR(1),
          2 CODE UNAL                  CHAR(5),
          2 * UNAL                     CHAR(1),
          2 SEV UNAL                   CHAR(1),
          2 * UNAL                     CHAR(1),
          2 LIN UNAL                   CHAR(3);
 
    DCL SIX2NINE(0:63) UNAL CONSTANT      CHAR(1) INIT
        ('@','A','B','C','D','E','F','G',
         'H','I','J','K','L','M','N','O',
         'P','Q','R','S','T','U','V','W',
         'X','Y','Z','[','\',']','^','_',
         '`','a','b','c','d','e','f','g',
         'h','i','j','k','l','m','n','o',
         '0','1','2','3','4','5','6','7',
         '8','9',':',';','<','=','>','?');
 
    DCL 1 CMD_SORT CONSTANT,
          2 * UNAL                     UBIN BYTE INIT(79),
          2 * UNAL                     CHAR(79) INIT
            ('SORT *PROOFXREF OVER *PROOFXREF (SI=*SORTCMDS)');
 
%EJECT;
/* *******************************************************************
*                                                                    *
*   To accelerate PROOF's performance, the S table may be            *
*   initialized with default words.  A judicious selection of        *
*   "pre-defined" words placed into S can result in a considerable   *
*   reduction in PROOF execution time, since these words do not      *
*   have to be looked up in the disk dictionary.  To tailor the      *
*   default dictionary for your installation, do the following:      *
*                                                                    *
*   1) Determine the words to be placed in the default list.  A      *
*      good way to do this is to use PROOF to scan a very large,     *
*      typical document (10,000 words or more) using the ID option   *
*      and assigning the output to a file.  This will give you a     *
*      list of words and the frequency of their use.  Select the     *
*      most frequently-used words (likely candidates are THE, AN,    *
*      A, AND, and so on).  You will likely find that 50% of the     *
*      words in your documents are made up of 100 or fewer words.    *
*      DON'T GO OVERBOARD!  Try to select words which represent      *
*      at least 1% of the words in the document; that is, the        *
*      default list should probably be no larger than 100 words      *
*      or so.  An overlong list will INCREASE execution time.        *
*                                                                    *
*   2) Sort the list of words into DESCENDING alphabetic order.      *
*      The words should be in ALL CAPITALS.                          *
*                                                                    *
*   3) Enter your list of words into the INIT clause of the S        *
*      table (you cannot enter more than 2048 words).  Note that     *
*      this table is built from entry 2047 downward, so you will     *
*      have to adjust the first entry's repeat count such that       *
*      the repeat count plus the number of words you enter is        *
*      equal to 2048.                                                *
*                                                                    *
*   4) Change the INIT clause for HWM to 2047 minus the number       *
*      of words you've entered.  E.g., if you entered 10 words,      *
*      change this value to 2037.                                    *
*                                                                    *
*   5) Find the entry in the BSSV vector which exceeds the number    *
*      of words you are entering by at least one.  Enter the         *
*      index to this entry in the INIT clause for CBSIX.  Don't      *
*      forget that the first entry in a PL-6 vector is numbered      *
*      zero.  Example:  You entered 10 words; the BSSV entry that    *
*      exceeds 10 is 15, which is the #3 entry (counting from 0).    *
*      CBSIX would be INITed to 3.                                   *
*                                                                    *
*   6) Change the INIT clause for CBSSV to the value of              *
*      BSSV(CBSIX).  For the example above, CBSSV would be           *
*      INITed to 15.                                                 *
*                                                                    *
*   7) Change the INIT clause for CNTDICT to the number of words     *
*      you entered.                                                  *
*                                                                    *
*   8) Recompile and reload PROOF.                                   *
*                                                                    *
******************************************************************* */
 
    DCL BSSV(0:11) CONSTANT            SBIN INIT
        (1,3,7,15,31,63,127,255,1023,2047,4095,8191);
 
    DCL CBSIX STATIC                   SBIN INIT(7);
    DCL CBSSV STATIC                   SBIN INIT(255);
    DCL HWM STATIC                     SBIN INIT(1873);
 
    DCL 1 S(0:2047) STATIC,
          2 SWORD UNAL                 CHAR(31) INIT(
            ' '*1874,
            'your',
            'you',
            'would',
            'words',
            'with',
            'will',
            'who',
            'which',
            'where',
            'when',
            'were',
            'we',
            'way',
            'water',
            'was',
            'very',
            'value',
            'user',
            'used',
            'use',
            'update',
            'up',
            'type',
            'two',
            'to',
            'time',
            'through',
            'this',
            'they',
            'these',
            'there',
            'then',
            'them',
            'their',
            'the',
            'that',
            'than',
            'text',
            'systems',
            'system',
            'syntax',
            'string',
            'start',
            'specifies',
            'specified',
            'source',
            'some',
            'so',
            'she',
            'set',
            'send',
            'see',
            'same',
            'said',
            'running',
            'run',
            'records',
            'record',
            'read',
            'program',
            'printed',
            'print',
            'people',
            'patch',
            'over',
            'output',
            'out',
            'other',
            'or',
            'options',
            'option',
            'only',
            'one',
            'on',
            'of',
            'number',
            'now',
            'note',
            'not',
            'node',
            'no',
            'new',
            'name',
            'my',
            'must',
            'move',
            'most',
            'more',
            'messages',
            'message',
            'may',
            'many',
            'make',
            'mail',
            'made',
            'long',
            'little',
            'list',
            'lines',
            'line',
            'like',
            'length',
            'know',
            'key',
            'just',
            'job',
            'it',
            'is',
            'into',
            'input',
            'information',
            'in',
            'if',
            'i',
            'how',
            'honeywell',
            'his',
            'him',
            'her',
            'help',
            'he',
            'have',
            'has',
            'had',
            'from',
            'format',
            'form',
            'for',
            'following',
            'first',
            'find',
            'files',
            'file',
            'field',
            'error',
            'end',
            'either',
            'each',
            'down',
            'do',
            'display',
            'did',
            'destination',
            'default',
            'data',
            'current',
            'cp-6',
            'could',
            'copyright',
            'comments',
            'comment',
            'commands',
            'command',
            'characters',
            'character',
            'can',
            'call',
            'by',
            'but',
            'been',
            'be',
            'available',
            'at',
            'as',
            'are',
            'any',
            'and',
            'an',
            'also',
            'all',
            'after',
            'account',
            'about',
            'a'),
          2 SFLAG UNAL                 CHAR(1) INIT('D'*2048);
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Initialization.                                                    *
*                                                                      *
\******************************************************************** */
 
      XREF_EOF = %FALSE;
      FINAL = -1;
      DO INX = 0 TO 99;
         KEYWORD.TEXT(INX) = %SPACE;
         KEYWORD.TALLY(INX) = 0;
         END;
 
    CALL STORE_SORT$STAT;                     /* Do a !LET SORT$STAT='ERRORS' */
    BROKEN='0'B;
    CALL M$INT(FPT_INT);
    M$SIPTR=DCBADDR(DCBNUM(M$SI));
    M$LOPTR=DCBADDR(DCBNUM(M$LO));
    RECCNT=0;
    CNTWRDS=0;
    CNTREFS=0;
    OPT='0'B;
      OPT.TC=%TRUE;
      OPT.KW = %FALSE;
    ERRMSG_FILE='0'B;
    CALL M$TIME(FPT_TIME);
    CALL INSERT(OVR_HDR.TIMX,5,6,' ');
 
    CALL M$OPEN(OPEN_LO);
    CALL M$OPEN(OPEN_SI) ALTRET(SIERROR);
    CALL M$OPEN(OPEN_XREF) ALTRET(XREFERROR);
    IF M$LOPTR->DUMMY.DDEV.LP# OR M$LOPTR->DUMMY.DDEV.IC# THEN
        MAX=M$LOPTR->DUMMY.WIDTH#;
    ELSE
        MAX=266;
    IF MAX<36 THEN
        MAX=36;
    IF M$SIPTR->DUMMY.ORG#=%KEYED# THEN
        KEYED_FILE='1'B;
    ELSE
        KEYED_FILE='0'B;
    OVR_HDR.FNAM=SUBSTR(M$SIPTR->DUMMY.NAME#.C,0,M$SIPTR->DUMMY.NAME#.L);
      PROOF_PCB.TEXT$ = ADDR(B$JIT.CCBUF);
      PROOF_PCB.NCHARS = B$JIT.CCARS;
      CALL X$PARSE(PROOF_PCB)
      WHENALTRETURN DO;
         PROOF_ERR.CODE_ = VECTOR(PROOF_PCB.ERROR);
         CALL M$ERRMSG(PROOF_ERR);
         CALL M$ERR;
         END;
      DO N=0 TO (PROOF_PCB.OUT$->OUT$BLK.NSUBLKS - 1);
         DO CASE(PROOF_PCB.OUT$->OUT$BLK.SUBLK$(N)->OUT$BLK.CODE);
            CASE(%PRIMARY);
               OPT.PO = %TRUE;
            CASE(%ALTERNATE);
               OPT.AO = %TRUE;
            CASE(%WORDFREQ);
               OPT.KW = %TRUE;
               CALL CHARBIN(LIMIT,PROOF_PCB.OUT$->OUT$BLK.SUBLK$(N)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
            CASE(%WORDPCT);
               OPT.PCT = %TRUE;
               OPT.KW = %TRUE;
               CALL CHARBIN(PCT_FACTOR,PROOF_PCB.OUT$->OUT$BLK.SUBLK$(N)
               ->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
            CASE(%REF);
               OPT.NR = %FALSE;
            CASE(%NOREF);
               OPT.NR = %TRUE;
            CASE(%LIST);
               OPT.LS = %TRUE;
            CASE(%NOLIST);
               OPT.LS = %FALSE;
            CASE(%TEXT);
               OPT.TC = %TRUE;
            CASE(%NOTEXT);
               OPT.TC = %FALSE;
            CASE(%INVERT);
               OPT.ID = %TRUE;
            CASE(%NOINVERT);
               OPT.ID = %FALSE;
            CASE(%TEXMODE);
               OPT.TEX = %TRUE;
            CASE(%NOTEXMODE);
               OPT.TEX = %FALSE;
         END;
      END;
 
OPEN_FILES:
    IF B$JIT.PRFLAGS.UI THEN
        OPT.ALT='1'B;
    IF OPT.PO THEN
        OPT.ALT='0'B;
    ELSE IF OPT.ALT THEN
        CALL M$OPEN(OPEN_ALT) ALTRET(ALTERROR);
    ELSE DO;
        OPT.ALT='1'B;
        OPEN_ALT.NAME_=VECTOR(NAME_DICT);
        OPEN_ALT.ACCT_=VECTOR(B$JIT$->B$JIT.FACCN);
        OPEN_ALT.V.ASN#=%FILE#;
        OPEN_ALT.V.RES#='DP  ';
        CALL M$OPEN(OPEN_ALT) ALTRET(ALTLOCAL);
    END;
    DO WHILE('0'B);
 
ALTLOCAL:
        IF OPT.AO THEN
            GOTO ALTERROR;
        OPT.ALT='0'B;
    END;
    IF NOT OPT.AO THEN
        CALL M$OPEN(OPEN_DICT) ALTRET(DICTERROR);
    MEBUF='PROOF C00 here, using';
    I=22;
    IF DCBADDR(DCBNUM(F$DICT))->DUMMY.FCD# THEN DO;
        CALL INSERT(MEBUF,22,11,'PROOF_DIC.X');
        I=I+12;
    END;
    IF DCBADDR(DCBNUM(F$ALT))->DUMMY.FCD# THEN DO;
        IF I>22 THEN DO;
            CALL INSERT(MEBUF,34,3,'and');
            I=I+4;
        END;
        CALL INSERT(MEBUF,I,,SUBSTR(DCBADDR(DCBNUM(F$ALT))->DUMMY.NAME#.C,
            0,DCBADDR(DCBNUM(F$ALT))->DUMMY.NAME#.L),'.',DCBADDR(DCBNUM
            (F$ALT))->DUMMY.ACCT#);
    END;
    CALL M$WRITE(WRITE_ME);
    IF OPT.LS AND M$LOPTR->DUMMY.DDEV.LP# THEN
        CALL M$DEVICE(PAGE_LO);
    IF OPT.AO THEN DO;
        HWM=2047;
        CBSIX=0;
        CBSSV=BSSV(0);
        CNTDICT=0;
    END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Read document and print on M$LO if LS specified.                   *
*                                                                      *
\******************************************************************** */
 
READ_DOC:
    DO WHILE('1'B);
        IF BROKEN THEN DO;
            IF ERRMSG_FILE THEN DO;
                ENCTXT=LINEREF;
                DEC.FCG1=SIX2NINE(ENC.FCG1);
                DEC.FCG2=SIX2NINE(ENC.FCG2);
                DEC.FCG3=SIX2NINE(ENC.FCG3);
                IF ENC.MON THEN
                    DEC.MON='M';
                ELSE
                    DEC.MON='0';
                CALL BINCHAR(DEC.CODE,ENC.CODE);
                CALL BINCHAR(DEC.SEV,ENC.SEV);
                CALL BINCHAR(DEC.LIN,ENC.LIN);
                CALL CONCAT(LOBUF,DECTXT,' was the last record read.');
            END;
            ELSE
                CALL CONCAT(LOBUF,LINEREF,' was the last record read.');
            CALL M$WRITE(WRITE_DO);
            BROKEN='0'B;
        END;
        CALL M$READ(READ_SI) ALTRET(SIERROR);
        IF KEYED_FILE AND KEYBUF.L=5 THEN DO;
            KEYED_FILE='0'B;
            ERRMSG_FILE='1'B;
        END;
        RECCNT=RECCNT+1;
        IF KEYED_FILE THEN DO;
            TEXT.KEY=KEYBUF.C;
            CALL BINCHAR(EDIT.INTG,RECCNT/1000);
            CALL BINCHAR(EDIT.FRAC,MOD(RECCNT,1000));
            EDIT.PER='.';
        END;
        ELSE IF ERRMSG_FILE THEN
            CALL CONCAT(LINEREF,BINASC(511),SUBSTR(KEYBUF.C,0,5));
        ELSE
            CALL BINCHAR(LINEREF,RECCNT);
        I=0;
        DO WHILE(SUBSTR(LINEREF,I,1)='0');
            CALL INSERT(LINEREF,I,1,' ');
            I=I+1;
        END;
        ARS=M$SIPTR->DUMMY.ARS#;
        IF M$SIPTR->DUMMY.DVBYTE.VFC# THEN
            CALL INSERT(SIBUF,0,1,' ');
        IF B$JIT$->B$JIT.PRFLAGS.LIST AND OPT.LS THEN DO;
            I=0;
            IF ERRMSG_FILE THEN DO;
                ENCTXT=LINEREF;
                DEC.FCG1=SIX2NINE(ENC.FCG1);
                DEC.FCG2=SIX2NINE(ENC.FCG2);
                DEC.FCG3=SIX2NINE(ENC.FCG3);
                IF ENC.MON THEN
                    DEC.MON='M';
                ELSE
                    DEC.MON='0';
                CALL BINCHAR(DEC.CODE,ENC.CODE);
                CALL BINCHAR(DEC.SEV,ENC.SEV);
                CALL BINCHAR(DEC.LIN,ENC.LIN);
                CALL CONCAT(LOBUF,DECTXT,' ',SUBSTR(SIBUF,0,ARS));
                Z=ARS+17;
            END;
            ELSE DO;
                CALL CONCAT(LOBUF,LINEREF,' ',SUBSTR(SIBUF,0,ARS));
                Z=ARS+10;
            END;
            DO WHILE(I<Z);
                IF Z-I>MAX THEN DO;
                    WRITE_LO.BUF_.BUF$=PINCRC(ADDR(LOBUF),I);
                    WRITE_LO.BUF_.BOUND=MAX-1;
                    CALL M$WRITE(WRITE_LO);
                    I=I+MAX+ARS-Z;
                    CALL INSERT(LOBUF,I,Z-ARS,' ');
                END;
                ELSE DO;
                    WRITE_LO.BUF_.BUF$=PINCRC(ADDR(LOBUF),I);
                    WRITE_LO.BUF_.BOUND=Z-I;
                    CALL M$WRITE(WRITE_LO);
                    I=Z;
                END;
            END;
        END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Discard embedded TEXT commands ("." in column 1); then break up    *
*   line into "words", looking up each in a memory table.  If the      *
*   word is not found in the table, it is added to the table and read  *
*   by key from the dictionary.  If it is found in the dictionary, no  *
*   further processing is done; otherwise, the word is flagged as      *
*   "interesting" and all future references to this word are written   *
*   to the cross-reference table file.                                 *
*                                                                      *
\******************************************************************** */
 
        IF SUBSTR(SIBUF,0,1)='.' THEN DO;
            IF OPT.TC THEN DO;
                CALL INDEX(I,' ',SUBSTR(SIBUF,0,ARS),0);
                SUBSTR(SIBUF,0,I)=' ';
            END;
            ELSE DO;
                SIBUF=' ';
            END;
        END;
        IF OPT.TEX THEN DO;
         I = 0;
         DO WHILE(I <= ARS - 1);
           IF SUBSTR(SIBUF,I,1) = INTRO
           THEN DO;
             K = I + 1;
             DO WHILE(K <= ARS - 1)AND(SUBSTR(SIBUF,K,1) ~= %SPACE)
                  AND(SUBSTR(SIBUF,K,1) ~= LEFT_DELIM);
               K = K + 1;
             END;
             SUBSTR(SIBUF,I,K-I) = ' ';
             IF K = ARS
             THEN I = K;
             ELSE I = K + 1;
           END;
           ELSE
             I = I + 1;
         END; /* do while not end of line */
        END;   /* if TEX option given */
        I=1;
        DO WHILE(I<ARS-1);
            CHM=SUBSTR(SIBUF,I,1);
            IF CHM=BITASC('010'O) THEN DO;
                CHL=SUBSTR(SIBUF,I-1,1);
                CHR=SUBSTR(SIBUF,I+1,1);
                IF CHR='_' THEN
                    ;
                ELSE IF CHL='_' THEN
                    CALL INSERT(SIBUF,I-1,1,CHR);
                ELSE IF (CHL>='0' AND CHL<='9') OR (CHL>='A' AND
                    CHL<='Z') OR (CHL>='a' AND CHL<='z') THEN
                    ;
                ELSE IF (CHR>='0' AND CHR<='9') OR (CHR>='A' AND
                    CHR<='Z') OR (CHR>='a' AND CHR<='z') THEN
                    CALL INSERT(SIBUF,I-1,1,CHR);
                IF I<ARS-2 THEN
                    CALL INSERT(SIBUF,I,ARS-I-2,SUBSTR(SIBUF,I+2,
                        ARS-I-2));
                ARS=ARS-2;
            END;
            ELSE
                I=I+1;
        END;
        CALL XLATE(SIBUF,NO_SPCHARS,SUBSTR(SIBUF,0,ARS));
        I=0;
        DO WHILE(I<ARS);
            DO WHILE(I<ARS AND (SUBSTR(SIBUF,I,1)=' ' OR
                SUBSTR(SIBUF,I,1)='-'));
                I=I+1;
            END;
            IF I<ARS THEN DO;
                CALL INDEX(J,' ',SIBUF,I);
                K=I;
                DO WHILE(K<J);
                    CALL INDEX(K,'-',SIBUF,K);
                    IF K<J AND SUBSTR(SIBUF,K+1,1)='-' THEN
                        J=K;
                    ELSE
                        K=K+1;
                END;
            END;
            ELSE
                J=I;
            IF I<J THEN DO;
                DO WHILE(I<J AND SUBSTR(SIBUF,I,1)='''' AND SUBSTR(SIBUF,
                    J-1,1)='''');
                    I=I+1;
                    J=J-1;
                END;
                DO WHILE(SUBSTR(SIBUF,I,1)='''');
                    I=I+1;
                END;
                DO WHILE(I<J AND SUBSTR(SIBUF,J-1,1)='''');
                    J=J-1;
                END;
            END;
            IF I<J THEN DO;
                CNTWRDS=CNTWRDS+1;
                WLEN=J-I;
                IF WLEN>31 THEN
                    WLEN=31;
                AWORD=SUBSTR(SIBUF,I,WLEN);
                CWORD=AWORD;
                I=J;
                CALL SEARCH(J,K,ALL_NUMBERS,SUBSTR(AWORD,0,WLEN))
                    ALTRET(NEXT_WORD);
                BWORD = AWORD;
                K=(CBSSV+1)/2;
                J=2048-K;
                DO WHILE(K>0);
                    K=K/2;
                    IF J>HWM AND AWORD=S.SWORD(J) THEN
                        K=0;
                    ELSE
                        IF J<=HWM OR AWORD<S.SWORD(J) THEN
                            J=J+K;
                        ELSE
                            J=J-K;
                END;
                IF J<=HWM THEN
                    J=HWM;
                ELSE
                    IF AWORD>S.SWORD(J) THEN
                        J=J-1;
                IF J=HWM OR AWORD~=S.SWORD(J) THEN DO;
                    LEN=(J-HWM)*LENGTHC(S(0));
                    IF LEN>0 THEN
                        ADDR(S(HWM))->VARSTG=PINCRC(ADDR(S(HWM)),
                            LENGTHC(S(0)))->VARSTG;
                    HWM=HWM-1;
                    IF HWM<1 THEN
                        HWM=0;
                    IF 2047-HWM>=CBSSV THEN DO;
                        CBSIX=CBSIX+1;
                        CBSSV=BSSV(CBSIX);
                    END;
                    S.SWORD(J)=AWORD;
                    S.SFLAG(J)='U';
                    CALL XLATE(AWORD,LOWERS,AWORD);
                    IF AWORD~=BWORD THEN DO;
                      CALL XLATE(W.FRST,UPPERS,W.FRST);
                      IF AWORD=BWORD THEN
                        CALL XLATE(AWORD,LOWERS,AWORD);
                      ELSE DO;
                        CALL XLATE(AWORD,UPPERS,AWORD);
                        IF AWORD=BWORD THEN
                          CALL XLATE(AWORD,LOWERS,AWORD);
                        ELSE AWORD = BWORD;
                        END;
                      END;
                    KEYBUF.C=AWORD;
                    CALL INDEX(K,' ',KEYBUF.C,0);
                    KEYBUF.L=K;
                    DICTBUF=' ';
                    IF NOT OPT.AO THEN DO;
                        OLDBUF = KEYBUF;
                        CALL M$PRECORD(PRECORD_DICT) ALTRET(DICTERROR);
ZONT1:                  S.SFLAG(J)='D';
                        CNTDICT=CNTDICT+1;
                    END;
                    ELSE DO;
 
DICTNRF:
                        OLDBUF = KEYBUF;
                        CALL M$PRECORD(PRECORD_ALT) ALTRET(ALTERROR);
ZONT2:                  S.SFLAG(J)='D';
                        CNTDICT=CNTDICT+1;
                    END;
                END;
 
ALTNRF:
                IF (S.SFLAG(J)='U' AND NOT OPT.ID) OR
                    (S.SFLAG(J)~='U' AND OPT.ID) THEN DO;
                    X.XWORD=CWORD;
                    X.XREF=LINEREF;
                    CALL M$WRITE(WRITE_XREF) ALTRET(XREFERROR);
                    CNTREFS=CNTREFS+1;
                END;
 
NEXT_WORD:
            END;
        END;
    END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   The document has been read.  Now sort the cross-reference file     *
*   into alphabetic order by linking to SORT.                          *
*                                                                      *
\******************************************************************** */
 
SIEOF:
    CALL INDEX1R(WLEN,' ',LINEREF);
    IF WLEN>8 THEN
        WLEN=-1;
    IF WLEN=8 THEN
        WLEN=-8;
    WLEN=9-WLEN;
    CALL M$CLOSE(CLOSE_SI);
    CALL M$CLOSE(CLOSE_XREF);
    IF DCBADDR(DCBNUM(F$DICT))->DUMMY.FCD# THEN
        CALL M$CLOSE(CLOSE_DICT);
    IF DCBADDR(DCBNUM(F$ALT))->DUMMY.FCD# THEN
        CALL M$CLOSE(CLOSE_ALT);
    IF M$LOPTR->DUMMY.DDEV.LP# THEN
        CALL M$DEVICE(PAGE_LO);
    WRITE_LO.BUF_.BOUND=79;
    LOBUF=' ';
    CALL M$WRITE(WRITE_DO);
    LOBUF='This document contains:';
    CALL M$WRITE(WRITE_DO);
    CALL BINCHAR(LINEREF,CNTWRDS);
    I=0;
    DO WHILE(SUBSTR(LINEREF,I,1)='0' AND I<8);
        CALL INSERT(LINEREF,I,1,' ');
        I=I+1;
    END;
    CALL CONCAT(LOBUF,LINEREF,' word(s)');
    CALL M$WRITE(WRITE_DO);
    IF OPT.AO THEN DO;
        CALL BINCHAR(LINEREF,2047-HWM);
        I=0;
        DO WHILE(SUBSTR(LINEREF,I,1)='0' AND I<8);
            CALL INSERT(LINEREF,I,1,' ');
            I=I+1;
        END;
        CALL CONCAT(LOBUF,LINEREF,' different word(s)');
        CALL M$WRITE(WRITE_DO);
    END;
    CALL BINCHAR(LINEREF,2047-HWM-CNTDICT);
      IF (OPT.PCT) THEN
          LIMIT = (PCT_FACTOR * (2047-HWM-CNTDICT))/10;
    I=0;
    DO WHILE(SUBSTR(LINEREF,I,1)='0' AND I<8);
        CALL INSERT(LINEREF,I,1,' ');
        I=I+1;
    END;
    CALL CONCAT(LOBUF,LINEREF,' word(s) not in the dictionary (undefined)');
    CALL M$WRITE(WRITE_DO);
    CALL BINCHAR(LINEREF,CNTREFS);
    I=0;
    DO WHILE(SUBSTR(LINEREF,I,1)='0' AND I<8);
        CALL INSERT(LINEREF,I,1,' ');
        I=I+1;
    END;
    CALL CONCAT(LOBUF,LINEREF,' reference(s) to undefined word(s)');
    CALL M$WRITE(WRITE_DO);
    CALL M$CLOSE(CLOSE_LO);
    IF CNTREFS~=0 THEN DO;
        CALL M$OPEN(OPEN_TF) ALTRET(TF_ERROR);
        WRITE_TF.BUF_.BOUND=79;
        SIBUF='REC INLEN=40,MEMORY=32';
        CALL M$WRITE(WRITE_TF) ALTRET(TF_ERROR);
        SIBUF='KEY (S=1,L=31,R=1,X=AA),(S=1,L=31,R=2)';
        CALL M$WRITE(WRITE_TF) ALTRET(TF_ERROR);
        SIBUF='XLATE AA,S=97,C=''ABCDEFGHIJKLMNOPQRSTUVWXYZ''';
        CALL M$WRITE(WRITE_TF) ALTRET(TF_ERROR);
        SIBUF='END';
        CALL M$WRITE(WRITE_TF) ALTRET(TF_ERROR);
        CALL M$CLOSE(CLOSE_TF) ALTRET(TF_ERROR);
        CALL M$LINK(FPT_LINK) ALTRET(WRITE_ERROR);
    END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Now print the sorted references in alphabetic order.               *
*                                                                      *
\******************************************************************** */
 
    CALL M$OPEN(OPEN_LO);
    OPEN_XREF.V.FUN#=%IN#;
    CLOSE_XREF.V.DISP#=%SCRATCH#;
    CALL M$OPEN(OPEN_XREF) ALTRET(XREFERROR);
    WRITE_LO.BUF_.BUF$=ADDR(LOBUF);
    RECCNT=0;
    AWORD=' ';
    I=0;
    IF M$LOPTR->DUMMY.DDEV.LP# OR M$LOPTR->DUMMY.DDEV.IC# THEN DO;
        CALL M$DEVICE(PAGE_LO);
        MAX=M$LOPTR->DUMMY.WIDTH#;
        LOBUF=' ';
        WRITE_LO.BUF_.BOUND=0;
        CALL M$WRITE(WRITE_LO);
        CALL M$WRITE(WRITE_LO);
    END;
    ELSE
        MAX=266;
    IF MAX<36 THEN
        MAX=36;
      LASTWORD = %SPACE;
      WRD.TALLY = 1;
 
    DO WHILE('1'B);
        CALL M$READ(READ_XREF) ALTRET(XREFERROR);
      IF (X.XWORD = LASTWORD) THEN
         WRD.TALLY = WRD.TALLY + 1;
      ELSE DO;
         IF (LASTWORD ~= %SPACE) THEN DO;
            WRD.TEXT = LASTWORD;
            CALL INSERT_KEYWORD(WRD);
            WRD.TALLY = 1;
            END;
         END;
         LASTWORD = X.XWORD;
        IF X.XWORD~=AWORD THEN DO;
            IF I>0 AND NOT OPT.NR AND NOT OPT.KW THEN DO;
                WRITE_LO.BUF_.BOUND=WLEN*I+4;
                CALL M$WRITE(WRITE_LO);
            END;
            LOBUF=X.XWORD;
            IF (~OPT.KW) THEN DO;
               WRITE_LO.BUF_.BOUND=31;
               CALL M$WRITE(WRITE_LO);
               END;
            AWORD=X.XWORD;
            LOBUF=' ';
            I=0;
        END;
        IF WLEN*(I+1)+5>MAX THEN DO;
            IF NOT OPT.NR AND NOT OPT.KW THEN DO;
                WRITE_LO.BUF_.BOUND=WLEN*I+4;
                CALL M$WRITE(WRITE_LO);
            END;
            LOBUF=' ';
            I=0;
        END;
        IF WLEN~=17 THEN
            CALL INSERT(LOBUF,WLEN*I+5,WLEN,SUBSTR(X.XREF,10-WLEN,WLEN-1));
        ELSE DO;
            ENCTXT=X.XREF;
            DEC.FCG1=SIX2NINE(ENC.FCG1);
            DEC.FCG2=SIX2NINE(ENC.FCG2);
            DEC.FCG3=SIX2NINE(ENC.FCG3);
            IF ENC.MON THEN
                DEC.MON='M';
            ELSE
                DEC.MON='0';
            CALL BINCHAR(DEC.CODE,ENC.CODE);
            CALL BINCHAR(DEC.SEV,ENC.SEV);
            CALL BINCHAR(DEC.LIN,ENC.LIN);
            CALL INSERT(LOBUF,WLEN*I+5,WLEN,DECTXT);
        END;
        I=I+1;
        RECCNT=RECCNT+1;
    END;
 
XREFEOF:
    IF I>0 AND NOT OPT.NR AND NOT OPT.KW THEN DO;
        WRITE_LO.BUF_.BOUND=WLEN*I+4;
        CALL M$WRITE(WRITE_LO);
    END;
      IF (OPT.KW) THEN DO;
         WRD.TEXT = LASTWORD;
         CALL INSERT_KEYWORD(WRD);
         END;
 
            FINALTALLY = KEYWORD.TALLY(99);
            INX = 99;
KEY:  DO WHILE(OPT.KW);
         IF ((KEYWORD.TALLY(INX)<FINALTALLY) OR (KEYWORD.TALLY(INX)>1) OR (INX=-1)) THEN DO;
            FINAL = INX;
            EXIT KEY;
            END;
         ELSE
            INX = INX - 1;
         END KEY;
      IF ((~OPT.KW) OR (FINAL=-1)) THEN GOTO NOTKW;
      INX = 0;
      KEYWORD# = 1;
      WRITE_LO.BUF_.BOUND = 80;
      LOBUF ='PROOF Word Frequency Listing';
      CALL M$WRITE(WRITE_LO);
      LOBUF = ' ';
      CALL M$WRITE(WRITE_LO);
KEYWORD: DO WHILE ((KEYWORD# <= LIMIT) AND (INX <= FINAL) AND (LIMIT>0));
            CALL BINCHAR(TALLY,KEYWORD.TALLY(INX));
            CALL CONCAT(LOBUF,TALLY,' ',KEYWORD.TEXT(INX));
            CALL  M$WRITE(WRITE_LO);
            KEYWORD# = KEYWORD# + 1;
            INX = INX +1;
            END;
NOTKW:
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Close files and EOJ.                                               *
*                                                                      *
\******************************************************************** */
 
    IF RECCNT=0 THEN DO;
        LOBUF='No misspelled words in this document.';
        CALL M$WRITE(WRITE_DO);
    END;
    LOBUF=' ';
    WRITE_DO.BUF_.BOUND=0;
    CALL M$WRITE(WRITE_DO);
    CALL M$WRITE(WRITE_DO);
    CALL M$CLOSE(CLOSE_LO);
    CALL M$CLOSE(CLOSE_XREF);
    CALL DELETE_SORT$STAT;                    /* !LET DEL SORT$STAT           */
    RETURN;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Error handlers.                                                    *
*                                                                      *
\******************************************************************** */
 
SIERROR:
    IF M$SIPTR->DUMMY.TYC.EOF# OR M$SIPTR->DUMMY.TYC.EOD# THEN
        GOTO SIEOF;
    FPT_ERRMSG.V.DCB#=DCBNUM(M$SI);
    GOTO WRITE_ERROR;
 
DICTERROR:
    IF AWORD=SUBSTR(KEYBUF.C,0,KEYBUF.L-1)    AND
      (((B.FRST<='z' AND B.FRST>=' ') AND (OVERKEY(KEYBUF.L)=1))
         OR (OVERKEY(KEYBUF.L)=0)) THEN GOTO ZONT1;
    TWORD = AWORD;
    CALL XLATE(AWORD,UPPERS,AWORD);
    IF (AWORD=CWORD) AND (OVERKEY(KEYBUF.L)=2) THEN
      GOTO ZONT1;
    AWORD = TWORD;
    KEYBUF = OLDBUF;
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#=%E$NOKEY THEN
        IF OPT.ALT THEN
            GOTO DICTNRF;
        ELSE
            GOTO ALTNRF;
    FPT_ERRMSG.V.DCB#=DCBNUM(F$DICT);
    GOTO WRITE_ERROR;
 
ALTERROR:
    IF AWORD=SUBSTR(KEYBUF.C,0,KEYBUF.L-1)    AND
      (((B.FRST<='z' AND B.FRST>=' ') AND (OVERKEY(KEYBUF.L)=1))
         OR (OVERKEY(KEYBUF.L)=0)) THEN GOTO ZONT2;
    CALL XLATE(AWORD,UPPERS,AWORD);
    IF (AWORD=CWORD) AND (OVERKEY(KEYBUF.L)=2) THEN
      GOTO ZONT1;
    KEYBUF = OLDBUF;
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#=%E$NOKEY THEN
        GOTO ALTNRF;
    FPT_ERRMSG.V.DCB#=DCBNUM(F$ALT);
    GOTO WRITE_ERROR;
 
XREFERROR:
    IF DCBADDR(DCBNUM(F$XREF))->DUMMY.TYC.EOF# OR
        DCBADDR(DCBNUM(F$DICT))->DUMMY.TYC.EOD# THEN
        GOTO XREFEOF;
    FPT_ERRMSG.V.DCB#=DCBNUM(F$DICT);
    GOTO WRITE_ERROR;
 
TF_ERROR:
    FPT_ERRMSG.V.DCB#=DCBNUM(F$TF);
    GOTO WRITE_ERROR;
 
WRITE_ERROR:
    FPT_ERRMSG.CODE_=VECTOR(B$TCB$->B$TCB.ALT$->B$ALT.ERR);
    CALL M$ERRMSG(FPT_ERRMSG);
    RETURN;
%EJECT;
INSERT_KEYWORD:   PROC(WRD);
 
DCL   INSERTED                         BIT(1);
DCL   FINAL                            SBIN      SYMREF;
DCL   1  WRD               CALIGNED,
         2  TEXT           CHAR(31),
         2  TALLY          UBIN(9)     CALIGNED;
 
      INSERTED = %FALSE;
FIND: DO INX = 0 TO FINAL;
         IF (KEYWORD.TALLY(INX) < WRD.TALLY) THEN DO;
            IF (FINAL<99) THEN
               FINAL = FINAL + 1;
            DO IX = FINAL - 1 DOWNTO INX;
               KEYWORD(IX+1) = KEYWORD(IX);
               END;
            KEYWORD(INX) = WRD;
            INSERTED = %TRUE;
            EXIT FIND;
            END;
         END FIND;
         IF ((~INSERTED) AND (FINAL<99))THEN DO;
            FINAL = FINAL + 1;
            KEYWORD(FINAL) = WRD;
            INSERTED = %TRUE;
            END;
END INSERT_KEYWORD;
%EJECT;
MUCK_WITH_SORT$STAT: PROC;
 
STORE_SORT$STAT: ENTRY;
 
    /*
       See if they have already done a !LET on the SORT$STAT command
       variable.  If so, don't muck with it anymore!  Otherwise, give
       it a value of 'ERRORS' so SORT will only say something if there
       are errors.  Just before PROOF is going to quit, he CALLs
       DELETE_SORT$STAT and simulates a !LET DEL SORT$STAT if PROOF
       thinks he gave SORT$STAT it's value in the first place!
    */
    CALL M$CMDVAR( FPT_CMDVAR )  ALTRET( STOR_SORT$STAT );
    GOTO RE_TURN;
 
STOR_SORT$STAT:
    FPT_CMDVAR.V.FUN# = 1;                    /* FUN=STORE                    */
    VALUE_ERRORS.L#= LENGTHC('ERRORS');
    VALUE_ERRORS.NAME#= 'ERRORS';
    CALL M$CMDVAR( FPT_CMDVAR )  ALTRET( RE_TURN );/* !LET SORT$STAT='ERRORS' */
    GOTO RE_TURN;
 
DELETE_SORT$STAT: ENTRY;
 
    /*
       If the last thing we did with FPT_CMDVAR was a STORE (meaning we DID
       give SORT$STAT a value previously), we now need to DELETE the SORT$STAT
       command variable so as to not screw up any subsequent SORTs (i.e. get
       it out of SORTs!).
    */
    IF FPT_CMDVAR.V.FUN#=1 /* STORE */ THEN DO;
       FPT_CMDVAR.V.FUN#=3; /* DELETE */
       CALL M$CMDVAR( FPT_CMDVAR )  ALTRET( RE_TURN );
       END;
 
RE_TURN:
    RETURN;
 
END MUCK_WITH_SORT$STAT;
 
END PROOF;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
YOUCALLD: PROC ASYNC;
%INCLUDE CP_6;
%FPT_TRMPRG(RSTBRK=YES);
    DCL BROKEN STATIC SYMDEF                  BIT(1);
    BROKEN='1'B;
    CALL M$TRMPRG(FPT_TRMPRG);
    RETURN;
END;
