/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
TCOPY: PROC MAIN;
/*
       TCOPY is a semi-blind tape-to-tape copy and verify routine.
       Input is through M$EI, output through M$EO; options are entered
       on the command line, as per standard CP-6 syntax.
 
       Andrew E. Birner, 27 Dec '82
       (312) 391-7926
 
       Zenith Radio Corporation
       Scientific Computer Services
       1000 Milwauke Avenue
       Glenview, Illinois  60025
*/
/********************************************************************
*                                                                   *
* This program  is a gratuitous contribution and  is offered as is. *
* Zenith  makes  no  representations  or  warranties  of  any kind, *
* express  or  implied,  relating  to  freedom  from  infringement, *
* accuracy,  error-freedom  or   performance,  and  shall  have  no *
* liability  or responsibility  to users  for damages  of any kind, *
* including special, indirect or consequential damages, arising out *
* of  or resulting  from use,  modification or  reproduction of the *
* program.                                                          *
*                                                                   *
* No  warranty  is  made  by  the  contributor  as to the accuracy, *
* maintenance, and functioning of the program and related material. *
* No  responsibility is  assumed by  the contributor  in connection *
* therewith.                                                        *
*                                                                   *
********************************************************************/
%EJECT;
       %CP6$ENTS;
       %INCLUDE TCOPY_C63;
       %INCLUDE TCOPY_C64;
       %INCLUDE TCOPY_C62;
       %INCLUDE B_ERRORS_C;
       %INCLUDE CP_6_SUBS;
 
       %SET WORK_SIZE = 200;
 
         /*  Buffer space (Data segments 3 & 4)  */
 
       DCL DS3_EI_BUF$ PTR STATIC INIT (ADDR(NIL));
       DCL EI_BUF (0:0) CHAR(1024) BASED (DS3_EI_BUF$);
 
       DCL DS4_EO_BUF$ PTR STATIC INIT (ADDR(NIL));
       DCL EO_BUF (0:0) CHAR(1024) BASED (DS4_EO_BUF$);
 
       %VLP_VECTOR;
       %FPT_GDS (FREE=YES, PROTECTION=DSWRITE, RESULTS=VLP_VECTOR,
                 SEGSIZE=8192);
 
       %FPT_GDS (FPTN=EXTEND_EI, FREE=YES, RESULTS=READ_EI.BUF_,
                 SEGSIZE=4096);
       %FPT_GDS (FPTN=EXTEND_EO, FREE=YES, RESULTS=READ_EO.BUF_,
                 SEGSIZE=4096);
 
       %LBL_VOL1 (STCLASS="BASED (DS3_EI_BUF$)");
       %LBL_TYPE1 (STCLASS="BASED (DS3_EI_BUF$)");
       %LBL_TYPE2 (STCLASS="BASED (DS3_EI_BUF$)");
 
       DCL LABEL_ID CHAR(3) BASED (DS3_EI_BUF$);
 
       DCL 1 STAR_REC BASED (DS3_EI_BUF$) ALIGNED,
             2 * UBIN,
             2 SN_OFFSET UBIN HALF;
 
         /*  External routines used by TCOPY  */
 
       DCL ERROUT ENTRY(6);
       DCL ERRPRNT ENTRY(4);
 
%EJECT;
 
         /*  Tape I/O stuff */
 
       DCL M$EI DCB;
       DCL M$EI$ PTR;
 
       DCL M$EO DCB;
       DCL M$EO$ PTR;
 
       DCL M$STAR DCB;
 
       %F$DCB;
 
       %FPT_OPEN (FPTN=OPEN_EI, DCB=M$EI, FUN=IN, ASN=DEVICE, ORG=FREE, CVOL=YES, RES='FT');
       %FPT_OPEN (FPTN=OPEN_EO, DCB=M$EO, FUN=CREATE, ASN=DEVICE, ORG=FREE, CVOL=YES, RES='FT');
       %FPT_OPEN (FPTN=OPEN_STAR, DCB=M$STAR, NAME=STAR_A, FUN=IN, ASN=FILE, ORG=KEYED);
 
       %VLP_NAME (FPTN=STAR_A, NAME='*A');
 
       %FPT_CLOSE (FPTN=CLOSE_EI, DCB=M$EI, POS=REM, NOMARKS=YES);
       %FPT_CLOSE (FPTN=CLOSE_EO, DCB=M$EO, POS=REM, NOMARKS=YES);
       %FPT_CLOSE (FPTN=CLOSE_STAR, DCB=M$STAR, DISP=SAVE);
 
       %FPT_CVOL (FPTN=CVOL_EI, DCB=M$EI);
       %FPT_CVOL (FPTN=CVOL_EO, DCB=M$EO);
 
       %FPT_REW (FPTN=REW_EI, DCB=M$EI);
       %FPT_REW (FPTN=REW_EO, DCB=M$EO);
 
       %FPT_READ (FPTN=READ_EI, DCB=M$EI);
       %FPT_READ (FPTN=READ_EO, DCB=M$EO);
       %FPT_READ (FPTN=READ_STAR, DCB=M$STAR, KEYS=YES, KEY=STAR_KEY);
 
       DCL 1 STAR_KEY STATIC,
             2 LEN# UBIN BYTE UNAL,
             2 TEXT# CHAR(4);
 
       %FPT_WEOF (FPTN=WEOF_EO, DCB=M$EO);
 
       %FPT_PRECORD (FPTN=BKSPC_EI, DCB=M$EI, N=-1);
 
       %FPT_WRITE (FPTN=WRITE_EO, DCB=M$EO);
 
       %VLP_SN (FPTN=EI_SN, N=100, SN="' '");
       %VLP_SN (FPTN=EO_SN, N=100, SN="'TCPY  '");
       %VLP_SN (FPTN=STAR_SN, N=1, STCLASS="BASED (STAR_SN$)");
       DCL STAR_SN$ PTR STATIC;
 
%EJECT;
 
         /*  Output stuff  */
 
       DCL EI_FID CHAR(128) STATIC INIT (' ');
       DCL EO_FID CHAR(128) STATIC INIT (' ');
 
       %FPT_UNFID (FPTN=UNFID_EI, SN=EI_SN, TEXTFID=EI_FID);
       %FPT_UNFID (FPTN=UNFID_EO, SN=EO_SN, TEXTFID=EO_FID);
 
         /*  Formatter Stuff  */
 
       %INCLUDE XU_FORMAT_C;
       %INCLUDE XUF_ENTRY;
 
       DCL LO_BUF CHAR(256) STATIC INIT (' ');
 
       %F_FDS (BUF=LO_BUF, DCB=M$LO);
       DCL FDS_DCB UBIN;
 
       DCL TCOPY_IN_FMT CHAR(0) STATIC INIT (
         '%Va* TCOPY here . . .%2/');
 
       DCL SOURCE_FMT CHAR(0) STATIC INIT (
         '%VA*  Source/Master  tapeset: %A');
 
       DCL DEST_FMT CHAR(0) STATIC INIT (
         '%VA*  Dest/Duplicate tapeset: %A');
 
       DCL OPN_FMT CHAR(0) STATIC INIT (
         '%Va*  Operation: %15.0LA');
 
       DCL COUNT_FMT CHAR(0) STATIC INIT (
         '%Vb* TCOPY done; %D blocks, %D ANS File Sections, %D reels encountered.%3/');
 
       DCL VOL1_FMT CHAR(0) STATIC INIT (
         '%Vb**  VOL1 -- Volume Id: %6A  Owner: %14A  Access: %1A  Std vers: %1A');
 
       DCL LBL1_FMT CHAR(0) STATIC INIT (
         '%Vb**  %3A1 -- File Id: %17A    Fileset Id: %6A  File seq #:  %4A%/
%Va%13-Generation: %4A, version %2A      Access: %1A %63-File sect #: %4A%/
%Va%13-Created:%3A/%3A  Expires:%3A/%3A  System: %13A%/
%36N(%Va%13-Block Count: %6A%)');
 
       DCL LBL2_FMT CHAR(0) STATIC INIT (
         '%Vb**  %3A2 -- Format: %A  Block len: %5A  Record len: %5A  Buffer offset: %2A');
 
       DCL LBL_TYPES (0:2) CHAR(3) STATIC INIT ('HDR', 'EOV', 'EOF');
 
       DCL OPNS (0:2) CHAR(15) STATIC INIT (
         'Copy', 'Verify', 'Copy and Verify');
 
%EJECT;
 
         /*  More format strings . . .  */
 
       DCL BEGIN_FMT CHAR(0) STATIC INIT (
         '%Vb*** Begin %A');
 
       DCL CVOL_FMT CHAR(0) STATIC INIT (
         '%Vb** Volume %D:  EISN is #%6A, EOSN is #%6A');
 
       DCL END_FMT CHAR(0) STATIC INIT (
         '%Vb*** End %A');
 
       DCL VRFY_OK_FMT CHAR(0) STATIC INIT (
         '%Vb**** Verify successful; no errors.');
 
%EJECT;
 
         /*  Vector structures for Label Formats  */
 
       DCL 1 V DALIGNED,
             2 VOL1,
               3 VOLID_ BIT (72),
               3 OWNER_ BIT (72),
               3 ACCESS_ BIT (72),
               3 LSV_ BIT (72),
             2 TYP1,
               3 LBLID_ BIT (72),
               3 FILEID_ BIT (72),
               3 FSETID_ BIT (72),
               3 FSN_ BIT (72),
               3 GEN_ BIT (72),
               3 VERS_ BIT (72),
               3 ACCESS_ BIT (72),
               3 FSECTNO_ BIT (72),
               3 CREATE_ BIT (72),
               3 EXPIRE_ BIT (72),
               3 SYSTEM_ BIT (72),
               3 FMT_BLKCNT_ BIT (72),
               3 BLOCKCNT_ BIT (72),
             2 TYP2,
               3 LBLID_ BIT (72),
               3 FORMAT_ BIT (72),
               3 BLKL_ BIT (72),
               3 RECL_ BIT (72),
               3 BUFOFFSET_ BIT (72);
 
%EJECT;
 
         /*  Interrupt Control  */
 
/*     DCL INT_SNARE ENTRY ASYNC OPTIONAL; */
/*     %FPT_INT (UENTRY=INT_SNARE);        */
 
         /* Parser Stuff */
 
       DCL OPTIONS UBIN SYMREF;
       DCL X$PARSE ENTRY (1) ALTRET;
       DCL WORK_AREA (0:%(WORK_SIZE-1)) UBIN STATIC INIT (0*0);
 
       %INCLUDE XU_MACRO_C;
       %INCLUDE XU_SUBS_C;
       %INCLUDE XU_PERR_C;
       %INCLUDE TCOPY_CN1;
 
       %P_PCB (R=OPTIONS, W=WORK_AREA, WSZ=%WORK_SIZE,
               C=YES, CNTU=NO);
 
       DCL ROOT$ PTR STATIC SYMDEF;
       %PARSE$OUT (STCLASS="BASED (ROOT$)");
       %PARSE$SYM (STCLASS="BASED");
 
       DCL OPT$ PTR;
       DCL SUB$ PTR;
       DCL I UBIN;
 
       DCL POS_OPT UBIN STATIC INIT (%REM#);
 
%EJECT;
 
         /*  Misc storage  */
 
       DCL 1 FLAGS STATIC,
             2 VOL1 BIT(1) UNAL INIT ('0'B),
             2 LABEL BIT(1) UNAL INIT ('0'B),
             2 ASN_ERR BIT(1) UNAL INIT ('0'B),
             2 ANS_FILE BIT(1) UNAL INIT ('0'B),
             2 OPMSG_SENT BIT(1) UNAL INIT ('0'B);
 
       DCL 1 OPTS STATIC,
             2 CPVY,
               3 VERIFY BIT(1) UNAL INIT ('1'B),
               3 COPY BIT(1) UNAL INIT ('1'B),
             2 PRINT,
               3 VERIFY BIT(1) UNAL INIT ('0'B),
               3 COPY BIT(1) UNAL INIT ('0'B),
               3 DEFAULT BIT(1) UNAL INIT ('0'B),
             2 NEW_SN,
               3 VOLID BIT(1) UNAL INIT ('0'B),
               3 FSETID BIT(1) UNAL INIT ('0'B);
 
       DCL 1 FLG REDEF OPTS,
             2 CPVY UBIN(2) UNAL,
             2 MISC BIT(5) UNAL;
 
       DCL FMT_BLKCNT UBIN STATIC INIT (0);
 
       DCL POINTER UBIN;
       DCL EI_ARS UBIN STATIC INIT (0);
       DCL EI_ASN REDEF EI_ARS UBIN;
       DCL EO_ARS UBIN STATIC INIT (0);
       DCL EO_ASN REDEF EO_ARS UBIN;
 
       DCL REC_CNT UBIN;
       DCL REC_CNT@BOT UBIN;
 
       DCL FSECT_CNT UBIN;
       DCL FSECT_CNT@BOT UBIN;
 
       DCL EOF_CNT UBIN;
       DCL VOL_CNT UBIN;
 
       DCL RES_TYP CHAR(2);
 
%EJECT;
 
       %SUB FOREVER = "WHILE '1'B; /* Forever! */";
       %SUB NEVER = "WHILE '0'B; /* Never! */";
       %SUB ALTRET_ERR# = "B$TCB.ALT$->B$ALT.ERR.ERR#";
 
       %SET EXIT = 0;
       %SET ERR  = 1;
       %SET XXX  = 2;
 
%EJECT;
 
         /*  Diagnostic Message Stuff  */
 
       DCL M$DO DCB;
       DCL M$LO DCB;
 
       %VLP_ERRCODE (FPTN=TCOPY_ERRCODE, FCG=YZ, MID=T, MON='0'B);
 
       %INCLUDE TCOPY_C61;
 
/*     %FPT_KEYIN (DCB=M$EO, WHO=D, MESS=REMOUNT_KEYIN1); causes sua */
       %FPT_KEYIN (WHO=W, WSN='LOCAL', OCTYPE=DEVICE);
 
       DCL REMOUNT_KEYIN1 CHAR(0) STATIC INIT (
         'TCOPY/  Operator: Please re-mount FT#xxxxxx with a longer');
 
       DCL REMOUNT_KEYIN2 CHAR(0) STATIC INIT (
         'TCOPY/  reel; if not possible, please ERROR this Job.');
 
       DCL MOUNT_KEYIN1 CHAR(0) STATIC INIT (
         'TCPY/  **********************************************');
 
       DCL MOUNT_KEYIN2 CHAR(0) STATIC INIT (
         'TCPY/  *                                            *');
 
       DCL MOUNT_KEYIN3 CHAR(0) STATIC INIT (
         'TCPY/  *     < *  T C O P Y  -- nnn  Reel(s)  * >   *');
 
       DCL REELCNT_FMT CHAR(0) STATIC INIT(
         '%3.9D');
 
       %FPT_EXIT;
 
%EJECT;
START:
/*     CALL M$INT (FPT_INT) ALTRET (ALT_ERRMSG);  */
 
         /*  Parse options, if any, from command line  */
 
       IF SUBSTR(B$JIT.CCBUF, B$JIT.CCDISP) ~= ' ' THEN DO;
         P_PCB.TEXT$ = PINCRC(ADDR(B$JIT.CCBUF), (B$JIT.CCDISP - 1));
         P_PCB.NCHARS = 1 + B$JIT.CCARS - B$JIT.CCDISP;
         CALL X$PARSE (P_PCB) ALTRET (BAD_CMD_LINE);
 
         ROOT$ = P_PCB.OUT$;
 
         DO I = 0 TO OUT$BLK.NSUBLKS - 1;
           OPT$ = OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0);
           DO CASE OPT$->OUT$BLK.CODE;
 
             CASE (%SN);
               SUB$ = OPT$->OUT$BLK.SUBLK$(1);
               DO CASE SUB$->OUT$BLK.CODE;
 
                 CASE (%OLD);
                   OPTS.NEW_SN = '00'B;
 
                 CASE (%NEW);
                   OPTS.NEW_SN = '10'B;
 
                 CASE (%CP6);
                   OPTS.NEW_SN = '11'B;
 
                 CASE (ELSE);
                   GOTO BAD_TREE;
               END;
 
             CASE (%PRINT);
               IF OPT$->OUT$BLK.NSUBLKS = 2 THEN DO;
                 OPTS.PRINT.DEFAULT = '0'B;
                 SUB$ = OPT$->OUT$BLK.SUBLK$(1);
                 CALL DKODE_CPVY (SUB$, OPTS.PRINT) ALTRET (BAD_TREE);
                END; ELSE  IF OPT$->OUT$BLK.NSUBLKS = 1 THEN DO;
                 OPTS.PRINT.DEFAULT = '1'B;
                END; ELSE DO;
                 GOTO BAD_TREE;
               END;
 
             CASE (%CPVY);
               CALL DKODE_CPVY (OPT$, OPTS.CPVY) ALTRET (BAD_TREE);
 
             CASE (%POS);
               POS_OPT = OPT$->OUT$BLK.SUBLK$(1)->OUT$SYM.CODE;
 
             CASE (ELSE);
               GOTO BAD_TREE;
 
           END;
 
         END;
 
%EJECT;
 
         DO NEVER;
BAD_TREE:        /*  CASE (ELSE) clauses come here . . .  */
           TCOPY_ERRCODE.ERR# = E$BAD_PARSE_TREE;
           TCOPY_ERRCODE.SEV = 0;
           CALL ERROUT (TCOPY_ERRCODE, 0, 4, 0, %XXX);
         END;
 
        END; ELSE DO;  /*  Default: CPVY, no PRINT, SN(OLD), POS(REM)  */
         OPTS.CPVY = '11'B;
         OPTS.PRINT = '00'B;
         OPTS.NEW_SN = '00'B;
         POS_OPT = %REM#;
       END;
 
       IF  OPTS.PRINT.DEFAULT  THEN DO;  /*  PRINT w/o '(mode)'  */
         OPTS.PRINT.COPY = OPTS.CPVY.COPY;
         OPTS.PRINT.VERIFY = OPTS.CPVY.VERIFY & ~OPTS.CPVY.COPY;
       END;
 
       DO NEVER;
BAD_CMD_LINE:    /*  X$PARSE  altrets here . . .  */
         IF P_PCB.ERROR.CODE = %E$SYNERR THEN DO;
           TCOPY_ERRCODE.ERR# = E$TCOPY_SYNERR;
           TCOPY_ERRCODE.SEV = 0;
           POINTER = P_PCB.HI_CHAR + B$JIT.CCDISP + 1;
           CALL ERROUT (TCOPY_ERRCODE, 0, 2, POINTER, %EXIT, 2);
          END; ELSE DO;
           CALL ERROUT (P_PCB.ERROR, 0, 4, 0, %XXX);
         END;
       END;
 
         /*  Parsing error messages  */
 
/*E*
ERROR: YZT-E$BAD_PARSE_TREE-A
MESSAGE: TCOPY Internal Error -- Parse Tree is Malformed!
         Please report this error to Scientific Computing Services.
DESCRIPTION:
         We wound up at a "CASE (ELSE)" somewhere in our Options
         parsing; hence, the parse tree linked with this routine
         is not the correct one.
*/
 
/*E*
ERROR: YZT-E$TCOPY_SYNERR-A
MESSAGE0: Syntax error in TCOPY options list!
MESSAGE1: You have entered one or more unrecognizable or conflicting
          options; please consult your TCOPY reference guide and
          re-type the line.
*/
 
%EJECT;
 
         /*  Do we have DCBs set?  */
 
       M$EI$ = DCBADDR(DCBNUM(M$EI));
       M$EO$ = DCBADDR(DCBNUM(M$EO));
 
       IF ~M$EI$->F$DCB.AMR# THEN DO;
         TCOPY_ERRCODE.SEV = 0;
         TCOPY_ERRCODE.ERR# = E$NO_SETS;
         POINTER = 0;
         CALL ERROUT (TCOPY_ERRCODE, 0, 4, POINTER, %ERR);
       END;
/*E*
ERROR:  YZT-E$NO_SETS-A
MESSAGE0: No source tape(s) specified for TCOPY!
MESSAGE1: M$EI must be set to the source tape(s);
          M$EO may be set to the destination tapes (if it is not,
            FT#TCPY00#...#TCPYnn will be assumed, where 'nn' is the
            number of reels specified for M$EI less 1).
MESSAGE2: DCBS may be set via IBEX "SET" commands, or command-line
          assignment, as:
 
            !SET M$EI source
          [ !SET M$EO destination ]
            !TCOPY  [ (options) ]
 
              or
 
            !TCOPY source [ OVER destination ]  [ (options) ]
 
          See the IBEX "SET" and "rununit" commands in the Programmers'
          Reference Manual for further information.
 
DESCRIPTION:
          The user has failed to tell us what tapes to use;
          so we nails 'im.
 
*/
 
%EJECT;
 
         /*  Make sure we have Magnetic Tape here . . .  */
 
       FLAGS.ASN_ERR = '0'B;
 
       RES_TYP = M$EI$->F$DCB.RESNT.TYP;
       IF ~( RES_TYP = 'FT' | RES_TYP = 'MT' | RES_TYP = 'LT' ) THEN DO;
         FLAGS.ASN_ERR = '1'B;
         TCOPY_ERRCODE.ERR# = E$NOT_TAPE;
         TCOPY_ERRCODE.SEV = 0;
         CALL ERRPRNT (TCOPY_ERRCODE, DCBNUM(M$EI), 4, 0);
       END;
 
       IF M$EO$->F$DCB.AMR# THEN DO;
         RES_TYP = M$EO$->F$DCB.RESNT.TYP;
         IF ~( RES_TYP = 'FT' | RES_TYP = 'MT' | RES_TYP = 'LT' ) THEN DO;
           FLAGS.ASN_ERR = '1'B;
           TCOPY_ERRCODE.ERR# = E$NOT_TAPE;
           TCOPY_ERRCODE.SEV = 0;
           CALL ERRPRNT (TCOPY_ERRCODE, DCBNUM(M$EO), 4, 0);
         END;
       END;
 
       IF FLAGS.ASN_ERR THEN DO;
         TCOPY_ERRCODE.SEV = 1;
         FPT_EXIT.CODE_ = VECTOR(TCOPY_ERRCODE);
         FPT_EXIT.V.STEPCC# = 4;
         CALL M$ERR (FPT_EXIT);
       END;
 
/*E*
ERROR: YZT-E$NOT_TAPE-A
MESSAGE0: %DC (%UF) does not refer to Magnetic Tape!
MESSAGE1: TCOPY works only from tape to tape; no other source
          or destination is legal.  M$EI and M$EO must both be set
          to FT#nnnnnn[#mmmmmm . . .] for TCOPY to work.
 
DESCRIPTION:
          Fatal error; user has tried a non-tape TCOPY operation.
*/
 
%EJECT;
 
         /*  Get DS3 for our input buffer . . .  */
 
       VLP_VECTOR.PTR$ = ADDR(NIL);
       CALL M$GDS (FPT_GDS) ALTRET (ALT_ERRMSG);
 
       DS3_EI_BUF$ = VLP_VECTOR.PTR$;
       READ_EI.BUF_ = VLP_VECTOR;
       WRITE_EO.BUF_ = VLP_VECTOR;
 
       IF  OPTS.CPVY.VERIFY  THEN DO;
         VLP_VECTOR = VECTOR(NIL);
         CALL M$GDS (FPT_GDS) ALTRET (ALT_ERRMSG);
         DS4_EO_BUF$ = VLP_VECTOR.PTR$;
         READ_EO.BUF_ = VLP_VECTOR;
       END;
 
%EJECT;
 
         /*  Print header info; get and echo serial number lists.  */
 
       CALL X$WRITE (F_FDS, VECTOR(TCOPY_IN_FMT));
 
         /*  Open M$STAR to *A, get Assign/Merge rec for M$EI  */
 
       CALL M$OPEN (OPEN_STAR) ALTRET ( ALT_ERRMSG );
       READ_STAR.BUF_ = READ_EI.BUF_;
 
       IF  B$JIT.PRFLAGS.SI  THEN DO;
         STAR_KEY.LEN# = 2;
         STAR_KEY.TEXT# = '#1';
        END; ELSE DO;
         STAR_KEY.LEN# = 4;
         STAR_KEY.TEXT# = 'M$EI';
       END;
       CALL M$READ (READ_STAR) ALTRET ( ALT_ERRMSG );
 
       STAR_SN$ = PINCRW (DS3_EI_BUF$, STAR_REC.SN_OFFSET);
       DO EI_SN.NUM# = 0 TO (STAR_SN.NUM# - 1);
         EI_SN.SN#(EI_SN.NUM#) = STAR_SN.SN#(EI_SN.NUM#);
       END;
       EI_SN.NUM# = STAR_SN.NUM#;
 
       UNFID_EI.ASN_ = VECTOR(M$EI$->F$DCB.ASN#);
       UNFID_EI.RES_ = VECTOR(M$EI$->F$DCB.RES#);
       CALL M$UNFID (UNFID_EI) ALTRET ( ALT_ERRMSG );
 
       CALL X$WRITE (F_FDS, VECTOR(SOURCE_FMT), VECTOR(EI_FID));
 
%EJECT;
 
         /*  Get (or build, if defaulted) EO_SN list; echo to user.  */
 
       IF ~M$EO$->F$DCB.AMR# THEN DO;
         DO EO_SN.NUM# = 0 TO (EI_SN.NUM# - 1);
           CALL BINCHAR(SUBSTR(EO_SN.SN#(EO_SN.NUM#),4), EO_SN.NUM#);
         END;
         EO_SN.NUM# = EI_SN.NUM#;
         OPEN_EO.SN_ = VECTOR(EO_SN);
 
         UNFID_EO.ASN_ = VECTOR(OPEN_EO.V.ASN#);
         UNFID_EO.RES_ = VECTOR(OPEN_EO.V.RES#);
        END; ELSE DO;
         IF  B$JIT.PRFLAGS.OU  THEN DO;
           STAR_KEY.LEN# = 2;
           STAR_KEY.TEXT# = '#3';
          END; ELSE DO;
           STAR_KEY.LEN# = 4;
           STAR_KEY.TEXT# = 'M$EO';
         END;
         CALL M$READ (READ_STAR) ALTRET ( ALT_ERRMSG );
 
         STAR_SN$ = PINCRW (DS3_EI_BUF$, STAR_REC.SN_OFFSET);
         DO EO_SN.NUM# = 0 TO (STAR_SN.NUM# - 1);
           EO_SN.SN#(EO_SN.NUM#) = STAR_SN.SN#(EO_SN.NUM#);
         END;
         EO_SN.NUM# = STAR_SN.NUM#;
 
         UNFID_EO.ASN_ = VECTOR(M$EO$->F$DCB.ASN#);
         UNFID_EO.RES_ = VECTOR(M$EO$->F$DCB.RES#);
       END;
 
       CALL M$UNFID (UNFID_EO) ALTRET ( ALT_ERRMSG );
       CALL X$WRITE (F_FDS, VECTOR(DEST_FMT), VECTOR(EO_FID));
 
       CALL M$CLOSE (CLOSE_STAR) ALTRET ( ALT_ERRMSG );
 
%EJECT;
 
         /*  Too few M$EO reels?  */
 
       IF EO_SN.NUM# < EI_SN.NUM# THEN DO;
         TCOPY_ERRCODE.SEV = 0;
         TCOPY_ERRCODE.ERR# = E$TOO_FEW_DEST_REELS;
         CALL ERROUT (TCOPY_ERRCODE, 0, 3, 0, %ERR);
       END;
 
         /*  Inform Operator of the requirements of this job.  */
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN1);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN2);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FDS_DCB = F_FDS.DCB#;
       F_FDS.DCB# = 0;
       CALL X$WRITE (F_FDS, VECTOR(REELCNT_FMT),
                            VECTOR(EI_SN.NUM#));
       SUBSTR(MOUNT_KEYIN3,32,3) = SUBSTR(LO_BUF,1,3);
       F_FDS.DCB# = FDS_DCB;
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN3);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN2);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN3);
       CALL CONCAT (SUBSTR(MOUNT_KEYIN3,11,41), 'From:  ', EI_FID);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
       CALL CONCAT (SUBSTR(MOUNT_KEYIN3,11,41), 'To:    ', EO_FID);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN2);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FPT_KEYIN.MESS_ = VECTOR(MOUNT_KEYIN1);
       CALL M$KEYIN (FPT_KEYIN) ALTRET ( ALT_ERRMSG );
 
       FLAGS.OPMSG_SENT = '1'B;
/*E*
ERROR: YZT-E$TOO_FEW_DEST_REELS-A
MESSAGE0: Too few destination reels specified!
MESSAGE1: TCOPY copies blindly from one tapeset to another; hence
          there must be at least as many reels in the destination
          (M$EO) tapeset as there are in the source (M$EI) tapeset.
DESCRIPTION:
          The user has tried to shrink his tapeset.
*/
 
%EJECT;
 
         /*  Open both tape DCBs.  */
 
       CALL M$OPEN (OPEN_EI) ALTRET ( ALT_ERRMSG );
 
       IF  OPTS.CPVY.VERIFY & ~OPTS.CPVY.COPY  THEN DO;
         OPEN_EO.V.FUN# = %IN#;
        END; ELSE DO;
         OPEN_EO.V.FUN# = %CREATE#;
       END;
 
       CALL M$OPEN (OPEN_EO) ALTRET ( ALT_ERRMSG );
 
         /*  Echo choice of operation(s).  */
 
       CALL X$WRITE (F_FDS, VECTOR(OPN_FMT), VECTOR(OPNS(FLG.CPVY - 1)));
 
         /*  Set up vectors for Label Output  */
 
       V.VOL1.VOLID_ = VECTOR(LBL_VOL1.VOLID#);
       V.VOL1.OWNER_ = VECTOR(LBL_VOL1.OWNER#);
       V.VOL1.ACCESS_ = VECTOR(LBL_VOL1.ACCESS#);
       V.VOL1.LSV_ = VECTOR(LBL_VOL1.LSV#);
 
       V.TYP1.LBLID_ = VECTOR(LBL_TYPE1.LBLID#);
       V.TYP1.FILEID_ = VECTOR(LBL_TYPE1.FILEID#);
       V.TYP1.FSETID_ = VECTOR(LBL_TYPE1.FSETID#);
       V.TYP1.FSN_ = VECTOR(LBL_TYPE1.FSN#);
       V.TYP1.GEN_ = VECTOR(LBL_TYPE1.GEN#);
       V.TYP1.VERS_ = VECTOR(LBL_TYPE1.VERS#);
       V.TYP1.ACCESS_ = VECTOR(LBL_TYPE1.ACCESS#);
       V.TYP1.FSECTNO_ = VECTOR(LBL_TYPE1.FSECTNO#);
       V.TYP1.CREATE_ = VECTOR(LBL_TYPE1.CREATE#);
       V.TYP1.EXPIRE_ = VECTOR(LBL_TYPE1.EXPIRE#);
       V.TYP1.SYSTEM_ = VECTOR(LBL_TYPE1.SYSTEM#);
       V.TYP1.FMT_BLKCNT_ = VECTOR(FMT_BLKCNT);
       V.TYP1.BLOCKCNT_ = VECTOR(LBL_TYPE1.BLOCKCNT#);
 
       V.TYP2.LBLID_ = VECTOR(LBL_TYPE2.LBLID#);
       V.TYP2.FORMAT_ = VECTOR(LBL_TYPE2.FORMAT#);
       V.TYP2.BLKL_ = VECTOR(LBL_TYPE2.BLKL#);
       V.TYP2.RECL_ = VECTOR(LBL_TYPE2.RECL#);
       V.TYP2.BUFOFFSET_ = VECTOR(LBL_TYPE2.BUFOFFSET#);
 
%EJECT;
 
         /*  Copy Operation  */
 
COPY_PART:
       IF OPTS.CPVY.COPY THEN DO;
         FLAGS.ANS_FILE = '0'B;
         FLAGS.VOL1 = '0'B;
 
         EOF_CNT = 0;
         VOL_CNT = 1;
 
         REC_CNT = 0;
         REC_CNT@BOT = 0;
 
         FSECT_CNT = 0;
         FSECT_CNT@BOT = 0;
 
         CALL X$WRITE (F_FDS, VECTOR(CVOL_FMT),
                              VECTOR(VOL_CNT),
                              VECTOR(M$EI$->F$DCB.PSN#),
                              VECTOR(M$EO$->F$DCB.PSN#));
         CALL X$WRITE (F_FDS, VECTOR(BEGIN_FMT), VECTOR(OPNS(0)));
 
         DO FOREVER;
           CALL M$READ (READ_EI) ALTRET (COPY_EI_ERR);
 
           DO NEVER;
COPY_EI_ERR:
             DO CASE ALTRET_ERR#;
 
               CASE (%E$EOF);  /*  Tape mark hit  */
                 EOF_CNT = EOF_CNT + 1;
                 CALL M$WEOF (WEOF_EO) ALTRET (COPY_EO_ERR);
 
                 IF ~FLAGS.ANS_FILE & (EOF_CNT = 2) THEN DO;
                   GOTO COPY_VOL_CHNG;
                 END;
 
                 GOTO COPY_LOOP_END;
 
%EJECT;
 
               CASE (%E$EOT);  /*  End of tape hit  */
COPY_VOL_CHNG:
                 CALL X$WRITE (F_FDS, VECTOR(END_FMT),
                                      VECTOR(OPNS(0)));
                 IF OPTS.CPVY.VERIFY THEN DO;
                   CALL X$WRITE (F_FDS, VECTOR(BEGIN_FMT),
                                        VECTOR(OPNS(1)));
                   CALL VRFY ALTRET (RETRY_REEL);
                   CALL X$WRITE (F_FDS, VECTOR(END_FMT),
                                        VECTOR(OPNS(1)));
 
                   DO NEVER;
RETRY_REEL:          IF B$JIT.MODE = %M_INT# THEN DO;  /*  If online  */
                       /*  Insert retry logic here . . .  */
                     END;
                   END;
                 END;
 
                 CALL M$CVOL (CVOL_EI) ALTRET (COPY_DONE);
                 CALL M$CVOL (CVOL_EO) ALTRET (ALT_ERRMSG);
                 VOL_CNT = VOL_CNT + 1;
 
                 CALL X$WRITE (F_FDS, VECTOR(CVOL_FMT),
                                      VECTOR(VOL_CNT),
                                      VECTOR(M$EI$->F$DCB.PSN#),
                                      VECTOR(M$EO$->F$DCB.PSN#));
                 GOTO COPY_LOOP_END;
 
               CASE (%E$LD);  /*  Buffer too small; extend it  */
/*
                   This will never happen -- TFM does not return
                   E$LD errors on tape.
 
                 CALL ERRPRNT (ALTRET_ERR, ALTRET_DCB#, 2);
                 CALL M$GDS (EXTEND_EI) ALTRET (ALT_ERRMSG);
                 IF  EXTEND_EI.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
                   EXTEND_EI.V.SEGSIZE# = EXTEND_EI.V.SEGSIZE# * 2;
                  END; ELSE DO;
                   EXTEND_EI.V.SEGSIZE# = %BITBIN ('777777'O);
                 END;
                 CALL M$PRECORD (BKSPC_EI) ALTRET (ALT_ERRMSG);
 
                 IF OPTS.CPVY.VERIFY THEN DO;
                   CALL M$GDS (EXTEND_EO) ALTRET (ALT_ERRMSG);
                   IF  EXTEND_EO.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
                     EXTEND_EO.V.SEGSIZE# = EXTEND_EO.V.SEGSIZE# * 2;
                    END; ELSE DO;
                     EXTEND_EO.V.SEGSIZE# = %BITBIN ('777777'O);
                   END;
                 END;
 
                 GOTO COPY_LOOP_END;
 */
               CASE (ELSE);
                 GOTO ALT_ERRMSG;
 
             END;
 
           END;
 
%EJECT;
           EI_ARS = M$EI$->F$DCB.ARS#;
           IF   EI_ARS = READ_EI.BUF_.BOUND + 1  THEN DO;
             TCOPY_ERRCODE.ERR# = E$HAD_TO_EXTEND;
             CALL ERRPRNT (TCOPY_ERRCODE, DCBNUM(M$EI), 2);
             CALL M$GDS (EXTEND_EI) ALTRET (ALT_ERRMSG);
             IF  EXTEND_EI.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
               EXTEND_EI.V.SEGSIZE# = EXTEND_EI.V.SEGSIZE# * 2;
              END; ELSE DO;
               EXTEND_EI.V.SEGSIZE# = %BITBIN ('777777'O);
             END;
             CALL M$PRECORD (BKSPC_EI) ALTRET (ALT_ERRMSG);
 
             IF OPTS.CPVY.VERIFY THEN DO;
               CALL M$GDS (EXTEND_EO) ALTRET (ALT_ERRMSG);
               IF  EXTEND_EO.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
                 EXTEND_EO.V.SEGSIZE# = EXTEND_EO.V.SEGSIZE# * 2;
                END; ELSE DO;
                 EXTEND_EO.V.SEGSIZE# = %BITBIN ('777777'O);
               END;
             END;
 
             GOTO COPY_LOOP_END;
           END;
 
/*E*
ERROR:   YZT-E$HAD_TO_EXTEND-C
MESSAGE0: TCOPY had to extend its buffers to accomodate the record
          just read on DCB %DC.
DESCRIPTION:
          The record read matched the buffer size exactly; this indicates
          that perhaps the record was longer than the buffer size.
          (TFM does not return the E$LD error on tapes.)
*/
%EJECT;
 
           EOF_CNT = 0;
           WRITE_EO.BUF_.BOUND = EI_ARS - 1;
 
           IF EI_ARS = 80 THEN DO;  /*  This may be a tape label  */
             FLAGS.LABEL = '0'B;
             IF LABEL_ID = 'VOL' & LBL_VOL1.LBLNO# = '1' THEN DO;
               FLAGS.VOL1 = '1'B;
               FLAGS.LABEL = '1'B;
               IF OPTS.NEW_SN.VOLID THEN DO;
                 LBL_VOL1.VOLID# = M$EO$->F$DCB.PSN#;
               END;
               F_FDS.FMT_ = VECTOR(VOL1_FMT);
               F_FDS.VECTR$ = ADDR(V.VOL1);
               F_FDS.NVECS# = 4;
              END; ELSE IF LABEL_ID = 'HDR' | LABEL_ID = 'EOF' | LABEL_ID = 'EOV' THEN DO;
               FLAGS.LABEL = '1'B;
               IF LBL_VOL1.LBLNO# = '1' THEN DO;
                 F_FDS.FMT_ = VECTOR(LBL1_FMT);
                 F_FDS.VECTR$ = ADDR(V.TYP1);
                 IF OPTS.NEW_SN.FSETID THEN DO;
                   IF LBL_TYPE1.FSETID# = EI_SN.SN#(0) THEN DO;
                     LBL_TYPE1.FSETID# = EO_SN.SN#(0);
                    END; ELSE IF LBL_TYPE1.FSETID# = EI_SN.SN#(VOL_CNT - 1) THEN DO;
                     LBL_TYPE1.FSETID# = EO_SN.SN#(VOL_CNT - 1);
                   END;
                 END;
                 IF LABEL_ID ~= 'HDR' THEN DO;
                   FMT_BLKCNT = 1;
                   F_FDS.NVECS# = 13;
                   IF LABEL_ID = 'EOF' THEN DO;
                     FSECT_CNT = FSECT_CNT + 1;
                   END;
                  END; ELSE DO;
                   FLAGS.ANS_FILE = '1'B;
                   FMT_BLKCNT = 0;
                   F_FDS.NVECS# = 12;
                 END;
                END; ELSE IF LBL_VOL1.LBLNO# = '2' THEN DO;
                 IF LABEL_ID = 'EOF' THEN DO;
                   FLAGS.ANS_FILE = '0'B;
                 END;
                 F_FDS.FMT_ = VECTOR(LBL2_FMT);
                 F_FDS.VECTR$ = ADDR(V.TYP2);
                 F_FDS.NVECS# = 5;
               END;
             END;
 
             IF FLAGS.LABEL & OPTS.PRINT.COPY THEN DO;
               CALL X$FORMAT (F_FDS);
             END;
 
           END;
 
%EJECT;
 
           CALL M$WRITE (WRITE_EO) ALTRET (COPY_EO_ERR);
 
           DO NEVER;
COPY_EO_ERR:
             DO CASE ALTRET_ERR#;
 
               CASE (%E$EOT);
/*E*
ERROR: YZT-E$REEL_TOO_SHORT-C
MESSAGE: Current output reel (#%SN) is too short;
         requesting longer tape from Operator.
DESCRIPTION:
         User/Operator has given us an output reel that is shorter
         than the corresponding input reel; we ask for a longer reel
         and go back to the beginning of this reel on M$EI.
*/
                 TCOPY_ERRCODE.ERR# = E$REEL_TOO_SHORT;
                 TCOPY_ERRCODE.SEV = 0;
                 CALL ERRPRNT (TCOPY_ERRCODE, ALTRET_DCB#, 3);
 
                 SUBSTR(REMOUNT_KEYIN1,37,6) = M$EO$->F$DCB.PSN#;
                 FPT_KEYIN.MESS_ = VECTOR(REMOUNT_KEYIN1);
                 CALL M$KEYIN (FPT_KEYIN) ALTRET (ALT_ERRMSG);
                 FPT_KEYIN.MESS_ = VECTOR(REMOUNT_KEYIN2);
                 CALL M$KEYIN (FPT_KEYIN) ALTRET (ALT_ERRMSG);
 
                 CLOSE_EO.V.POS# = %REM#;
                 OPEN_EO.V.VOL# = M$EO$->F$DCB.VOL#;
                 CALL M$CLOSE (CLOSE_EO) ALTRET (ALT_ERRMSG);
                 CALL M$OPEN (OPEN_EO) ALTRET (ALT_ERRMSG);
 
                 CALL M$REW (REW_EI) ALTRET (ALT_ERRMSG);
                 REC_CNT = REC_CNT@BOT;
                 FSECT_CNT = FSECT_CNT@BOT;
 
                 GOTO COPY_LOOP_END;
 
               CASE (ELSE);
                 GOTO ALT_ERRMSG;
 
             END;
           END;
 
           REC_CNT = REC_CNT + 1;
 
COPY_LOOP_END:
         END;
 
           /*  End of Copy logic . . .  */
 
COPY_DONE:
       END;
 
%EJECT;
 
           /*  Handle verify with no prior copy . . .  */
 
VRFY_PART:
       IF ~OPTS.CPVY.COPY & OPTS.CPVY.VERIFY THEN DO;
         FLAGS.ANS_FILE = '0'B;
         FLAGS.VOL1 = '0'B;
 
         EOF_CNT = 0;
         VOL_CNT = 1;
 
         REC_CNT = 0;
         FSECT_CNT = 0;
 
         CALL X$WRITE (F_FDS, VECTOR(CVOL_FMT),
                              VECTOR(VOL_CNT),
                              VECTOR(M$EI$->F$DCB.PSN#),
                              VECTOR(M$EO$->F$DCB.PSN#));
 
         DO FOREVER;
           CALL X$WRITE (F_FDS, VECTOR(BEGIN_FMT),
                                VECTOR(OPNS(2)));
           CALL VRFY;
           CALL X$WRITE (F_FDS, VECTOR(END_FMT),
                                VECTOR(OPNS(2)));
 
           CALL M$CVOL (CVOL_EI) ALTRET (VRFY_DONE);
           CALL M$CVOL (CVOL_EO) ALTRET (ALT_ERRMSG);
 
           VOL_CNT = VOL_CNT + 1;
           CALL X$WRITE (F_FDS, VECTOR(CVOL_FMT),
                                VECTOR(VOL_CNT),
                                VECTOR(M$EI$->F$DCB.PSN#),
                                VECTOR(M$EO$->F$DCB.PSN#));
         END;
 
VRFY_DONE:
       END;
 
%EJECT;
 
         /*  We're done; hence we go away . . .  */
 
       CLOSE_EI.V.POS# = POS_OPT;
       CLOSE_EO.V.POS# = POS_OPT;
 
       CALL M$CLOSE (CLOSE_EI) ALTRET (ALT_ERRMSG);
       CALL M$CLOSE (CLOSE_EO) ALTRET (ALT_ERRMSG);
 
       CALL X$WRITE (F_FDS, VECTOR(COUNT_FMT), VECTOR(REC_CNT),
                     VECTOR(FSECT_CNT), VECTOR(VOL_CNT));
 
       CALL M$EXIT;
 
%EJECT;
         /*  Error routines (Altret destinations)  */
 
ALT_ERRMSG:
       CLOSE_EI.V.POS# = %PTV#;
       CLOSE_EO.V.POS# = %PTV#;
 
       CALL M$CLOSE (CLOSE_EI);
       CALL M$CLOSE (CLOSE_EO);
 
       POINTER = 0;
       CALL ERROUT (ALTRET_ERR, ALTRET_DCB#, 4, POINTER, %ERR);
 
%EJECT;
VRFY:    PROC ALTRET;
 
         /*
             VRFY is an internal proc used to verify the just-written
             reel of the destination (M$EO) tapeset against the
             corresponding reel of the master (M$EI) tapeset.
 
         */
 
         %VLP_ERRCODE (FPTN=VRFY_ERR);
         %VLP_ERRCODE (SEV=7, FCG=YZ, MID=T, MON='0'B);
 
         DCL EI_RECNO UBIN;
         DCL NBUFS UBIN;
         DCL SHORT UBIN;
         DCL ERR_DCB UBIN;
         DCL EI_EOF_CNT UBIN;
         DCL EO_EOF_CNT UBIN;
         DCL I UBIN;
 
 
         DCL CHECK_DATA BIT(1) UNAL;
         DCL EOF_ON_EI BIT(1) UNAL;
         DCL EOF_ON_EO BIT(1) UNAL;
         DCL EI_LOG_EOT BIT(1) UNAL;
         DCL EI_PHYS_EOT BIT(1) UNAL;
         DCL EO_LOG_EOT BIT(1) UNAL;
         DCL EO_PHYS_EOT BIT(1) UNAL;
 
           /*  Start by zeroing it all out:  */
START:
         VRFY_ERR = VLP_ERRCODE;
 
         EI_RECNO = 0;
         FLAGS.ANS_FILE  = '0'B;
         EOF_ON_EI  = '0'B;
         EOF_ON_EO  = '0'B;
         EI_LOG_EOT  = '0'B;
         EI_PHYS_EOT  = '0'B;
         EO_LOG_EOT  = '0'B;
         EO_PHYS_EOT  = '0'B;
 
           /*  Get back to the beginning  */
 
         CALL M$REW (REW_EI) ALTRET (GO_ALTRET);
         CALL M$REW (REW_EO) ALTRET (GO_ALTRET);
 
%EJECT;
           /*  Loop through the reel:  */
 
         DO WHILE ~(EI_PHYS_EOT | EI_LOG_EOT);
 
           ERR_DCB = DCBNUM(M$EI);
           CALL M$READ (READ_EI) ALTRET (EI_ALTRET);
           EOF_ON_EI = '0'B;
           EI_EOF_CNT = 0;
 
           DO NEVER;
EI_ALTRET:   DO CASE ALTRET_ERR#;
 
               CASE (%E$EOT);
                 EI_PHYS_EOT = '1'B;
 
               CASE (%E$EOF);
                 EI_EOF_CNT = EI_EOF_CNT + 1;
                 EOF_ON_EI = '1'B;
                 IF ~FLAGS.ANS_FILE & EI_EOF_CNT = 2 THEN DO;
                   EI_LOG_EOT = '1'B;
                 END;
 
               CASE (%E$LD);
/*
                   This will never happen; check record size, instead.
 
                 CALL ERRPRNT (ALTRET_ERR, ALTRET_DCB#, 2);
                 CALL M$GDS (EXTEND_EI) ALTRET (GO_ALTRET);
                 IF  EXTEND_EI.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
                   EXTEND_EI.V.SEGSIZE# = EXTEND_EI.V.SEGSIZE# * 2;
                  END; ELSE DO;
                   EXTEND_EI.V.SEGSIZE# = %BITBIN ('777777'O);
                 END;
                 CALL M$GDS (EXTEND_EO) ALTRET (GO_ALTRET);
                 IF  EXTEND_EO.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
                   EXTEND_EO.V.SEGSIZE# = EXTEND_EO.V.SEGSIZE# * 2;
                  END; ELSE DO;
                   EXTEND_EO.V.SEGSIZE# = %BITBIN ('777777'O);
                 END;
                 CALL M$PRECORD (BKSPC_EI) ALTRET (GO_ALTRET);
                 GOTO VRFY_LOOP_END;
*/
 
               CASE (ELSE);
                 CALL ERROUT (ALTRET_ERR, ERR_DCB, 4);
                 VRFY_ERR.ERR# = E$READ_ERROR;
                 GOTO ERR_EXIT;
 
             END;  /* DO CASE */
 
           END;  /* DO NEVER */
 
           EI_ARS = M$EI$->F$DCB.ARS#;
           IF  EI_ARS = READ_EI.BUF_.BOUND + 1  THEN DO;
             VRFY_ERR.ERR# = E$HAD_TO_EXTEND;
             CALL ERRPRNT (VRFY_ERR, DCBNUM(M$EI), 2);
             CALL M$GDS (EXTEND_EI) ALTRET (GO_ALTRET);
             IF  EXTEND_EI.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
               EXTEND_EI.V.SEGSIZE# = EXTEND_EI.V.SEGSIZE# * 2;
              END; ELSE DO;
               EXTEND_EI.V.SEGSIZE# = %BITBIN ('777777'O);
             END;
             CALL M$GDS (EXTEND_EO) ALTRET (GO_ALTRET);
             IF  EXTEND_EO.V.SEGSIZE# < %BITBIN ('400000'O)  THEN DO;
               EXTEND_EO.V.SEGSIZE# = EXTEND_EO.V.SEGSIZE# * 2;
              END; ELSE DO;
               EXTEND_EO.V.SEGSIZE# = %BITBIN ('777777'O);
             END;
             CALL M$PRECORD (BKSPC_EI) ALTRET (GO_ALTRET);
             GOTO VRFY_LOOP_END;
           END;
 
%EJECT;
 
           CHECK_DATA = '1'B;
           ERR_DCB = DCBNUM(M$EO);
           CALL M$READ (READ_EO) ALTRET (EO_ALTRET);
           EOF_ON_EO = '0'B;
           EO_EOF_CNT = 0;
 
           DO NEVER;
EO_ALTRET:   DO CASE ALTRET_ERR#;
 
               CASE (%E$EOT);
                 IF ~EI_PHYS_EOT THEN DO;
                   VRFY_ERR.ERR# = E$EARLY_EOT;
                   GOTO ERR_EXIT;
                  END; ELSE DO;
                   CHECK_DATA = '0'B;
                 END;
 
               CASE (%E$EOF);
                 EO_EOF_CNT = EO_EOF_CNT + 1;
                 IF EI_EOF_CNT ~= EO_EOF_CNT THEN DO;
                   VRFY_ERR.ERR# = E$EXTRA_EO_EOF;
                   GOTO ERR_EXIT;
                  END; ELSE DO;
                   CHECK_DATA = '0'B;
                 END;
 
               CASE (%E$LD);
                 VRFY_ERR.ERR# = E$DATA_ERROR;
                 GOTO ERR_EXIT;
 
               CASE (ELSE);
                 CALL ERROUT (ALTRET_ERR, ERR_DCB, 4);
                 VRFY_ERR.ERR# = E$READ_ERROR;
                 GOTO ERR_EXIT;
 
             END;  /* DO CASE */
 
           END;  /* DO NEVER */
 
%EJECT;
 
             /*  Check for a match:  */
 
           IF CHECK_DATA THEN DO;
 
             ERR_DCB = 0;
 
             IF EI_EOF_CNT ~= 0 THEN DO;
               VRFY_ERR.ERR# = E$NO_EO_EOF;
               GOTO ERR_EXIT;
             END;
 
             EI_ARS = M$EI$->F$DCB.ARS#;
             EO_ARS = M$EO$->F$DCB.ARS#;
             IF EI_ARS ~= EO_ARS THEN DO;
               VRFY_ERR.ERR# = E$DATA_ERROR;
               GOTO ERR_EXIT;
             END;
 
             FLAGS.LABEL = '0'B;
             IF EI_ARS = 80 THEN DO;  /*  This may be a tape label  */
               IF LABEL_ID = 'VOL' & LBL_VOL1.LBLNO# = '1' THEN DO;
                 FLAGS.VOL1 = '1'B;
                 FLAGS.LABEL = '1'B;
                 IF OPTS.NEW_SN.VOLID THEN DO;
                   LBL_VOL1.VOLID# = DS4_EO_BUF$->LBL_VOL1.VOLID#;
                 END;
                 F_FDS.FMT_ = VECTOR(VOL1_FMT);
                 F_FDS.VECTR$ = ADDR(V.VOL1);
                 F_FDS.NVECS# = 4;
                END; ELSE IF LABEL_ID = 'HDR' | LABEL_ID = 'EOF' | LABEL_ID = 'EOV' THEN DO;
                 FLAGS.LABEL = '1'B;
                 IF LBL_VOL1.LBLNO# = '1' THEN DO;
                   F_FDS.FMT_ = VECTOR(LBL1_FMT);
                   F_FDS.VECTR$ = ADDR(V.TYP1);
                   IF OPTS.NEW_SN.FSETID THEN DO;
                     LBL_TYPE1.FSETID# = DS4_EO_BUF$->LBL_TYPE1.FSETID#;
                   END;
                   IF LABEL_ID ~= 'HDR' THEN DO;
                     FMT_BLKCNT = 1;
                     F_FDS.NVECS# = 13;
                     IF LABEL_ID = 'EOF' & ~OPTS.CPVY.COPY THEN DO;
                       FSECT_CNT = FSECT_CNT + 1;
                     END;
                    END; ELSE DO;
                     FLAGS.ANS_FILE = '1'B;
                     FMT_BLKCNT = 0;
                     F_FDS.NVECS# = 12;
                   END;
                  END; ELSE IF LBL_VOL1.LBLNO# = '2' THEN DO;
                   IF LABEL_ID = 'EOF' THEN DO;
                     FLAGS.ANS_FILE = '0'B;
                   END;
                   F_FDS.FMT_ = VECTOR(LBL2_FMT);
                   F_FDS.VECTR$ = ADDR(V.TYP2);
                   F_FDS.NVECS# = 5;
                 END;
               END;
             END;
 
             NBUFS = EI_ARS/1024;
             SHORT = EI_ARS - NBUFS*1024 - 1;
 
             DO I = 0 TO (NBUFS - 1);
               IF EI_BUF(I) ~= EO_BUF(I) THEN DO;
                 VRFY_ERR.ERR# = E$DATA_ERROR;
                 GOTO ERR_EXIT;
               END;
             END;
 
             IF  SHORT < 1024  THEN DO;
               IF SUBSTR(EI_BUF(NBUFS),0,SHORT) ~= SUBSTR(EO_BUF(NBUFS),0,SHORT) THEN DO;
                 VRFY_ERR.ERR# = E$DATA_ERROR;
                 GOTO ERR_EXIT;
               END;
             END;
 
             IF FLAGS.LABEL & OPTS.PRINT.VERIFY THEN DO;
               CALL X$FORMAT (F_FDS);
             END;
 
           END;  /* CHECK_DATA  */
 
VRFY_LOOP_END:
         END;  /* VRFY LOOP */
 
%EJECT;
 
           /*  Exit from verify  -  Reel is Okay  */
 
         CALL X$WRITE (F_FDS, VECTOR(VRFY_OK_FMT));
         RETURN;
 
GO_ALTRET:
         VRFY_ERR = ALTRET_ERR;
         ERR_DCB = ALTRET_DCB#;
 
ERR_EXIT:
         CALL ERRPRNT (VRFY_ERR, ERR_DCB);
         ALTRETURN;
 
%EJECT;
 
         /*  Error definitions for VRFY  */
 
/*E*
ERROR: YZT-E$NO_EO_EOF-C
MESSAGE: Missing tape mark on this reel of destination tapeset!
         Skipping to next reel (if any).
*/
 
/*E*
ERROR: YZT-E$EXTRA_EO_EOF-C
MESSAGE: Extraneous tape mark on this reel of destination tapeset!
         Skipping to next reel (if any).
*/
 
/*E*
ERROR: YZT-E$DATA_ERROR-C
MESSAGE: Data record on M$EI does not match corresponding record
         on M$EO!  Skipping to next reel (if any).
*/
 
/*E*
ERROR: YZT-E$READ_ERROR-C
MESSAGE: Error attempting to read %DC; skipping to next reel (if any).
*/
 
/*E*
ERROR: YZT-E$EARLY_EOT-C
MESSAGE: Premature end of tape (E$EOT) on %DC;
         skipping to next reel of tapeset (if any).
*/
 
END      VRFY;
 
%EJECT;
 
DKODE_CPVY:  PROC (NODE$, RESULT) ALTRET;
/*
       This routine stores sets flags in RESULT based on which sub-
       nodes are present in the sub-tree we have been passed.
*/
         DCL NODE$ PTR;
         DCL 1 RESULT,
               2 VERIFY BIT(1) UNAL,
               2 COPY BIT(1) UNAL;
 
         DCL I UBIN;
         DCL SUB$ PTR;
 
START:
         RESULT = '00'B;
 
         DO I = 0 TO NODE$->OUT$BLK.NSUBLKS - 1;
           SUB$ = NODE$->OUT$BLK.SUBLK$(I);
           DO CASE SUB$->OUT$BLK.NDTYPE;
 
             CASE (%LITERAL#); /* This must be 'CP/VY' */
               RESULT = '11'B;
 
             CASE (%RALTERN#);
               SUB$ = SUB$->OUT$BLK.SUBLK$(0);
               DO CASE SUB$->OUT$BLK.CODE;
 
                 CASE (%COPY);
                   RESULT.COPY = '1'B;
 
                 CASE (%VERIFY, %VRFY);
                   RESULT.VERIFY = '1'B;
 
                 CASE (ELSE);
                   ALTRETURN;
 
               END;
 
             CASE (ELSE);
               ALTRETURN;
 
           END;
 
         END;
 
         RETURN;
 
END    DKODE_CPVY;
 
END    TCOPY;
