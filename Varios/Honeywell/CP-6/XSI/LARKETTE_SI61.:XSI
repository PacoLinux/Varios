/*M* LARKETTE_SI61 LARKETTE comgroup station for LARK */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARKETTE
   PURPOSE:       Start up a station for LARK
   DESCRIPTION:   This module starts up a station for LARK and receives
                  commands from LARK which tell it what to do while connected
                  to the comgroup.
*/
/*D*
   NAME:          LARKETTE
   INVOKATION:    LARKETTE.X (cg_fid,control_station,lark_station)
   PARAMETERS:    CG_FID is the comgroup FID for the comgroup that LARK
                     and LARKETTE are communicating through and will be
                     used by LARKETTE's functional station
                  CONTROL_STATION is the name of the station which will
                     communicate with LARK from LARKETTE
                  LARK_STATION is the name of the station which communicates
                     with LARKETTE from LARK
   INTERFACE:     LARKETTE_CONTROL_NWIO
                  LARKETTE_GIVE_UP
                  LARKETTE_GET_DATA_SEGMENT
                  LARKETTE_RELEASE_DATA_SEGMENT
                  LARKETTE_RETURN_PMME_ERROR
                  LARKETTE_READ_MESSAGE
                  LARKETTE_WRITE_MESSAGE
   INTPUT:
   DESCRIPTION:   The invokation of this processor as a ghost job supplies
                  the comgroup to connect to and the station names of the
                  control and lark stations.  The control station
                  performs no-wait reads to receive instructions as
                  to the duties to be carried out by the functional station.
                  The control station also can receive instructions to
                  suspend and start the functional station, abort the
                  ghost user, and return status regarding the functional
                  station's progress.
                  The functional station will read and/or write messages
                  having various characteristics defined by the structures
                  passed to LARKETTE from LARK via the connecting comgroup.
*/
 
%EJECT ;
LARKETTE : PROC MAIN ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARKETTE_C61 ;
%INCLUDE LARKETTE_C62 ;
 
%INCLUDE XUX$INTERFACE_M ;
%INCLUDE XU_PERR_C ;
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARKETTE_CONTROL_NWIO ;
%LARKETTE_GIVE_UP ;
%LARKETTE_GET_DATA_SEGMENT ;
%LARKETTE_RELEASE_DATA_SEGMENT ;
%LARKETTE_RETURN_COMMAND_ERROR ;
%LARKETTE_RETURN_NWIO_ERROR ;
%LARKETTE_RETURN_PMME_ERROR ;
%LARKETTE_READ_MESSAGE ;
%LARKETTE_READ_MESSAGE_ERR_RET ;
%LARKETTE_WRITE_MESSAGE ;
%LARKETTE_WRITE_MESSAGE_ERR_RET ;
 
DCL      XUX$GETLINE                ENTRY ( 1 ) ALTRET ;
DCL      XUX$CLEANUP                ENTRY ALTRET ;
 
/*
   Structures
*/
 
%B$ALT ;
 
%INCLUDE B$JIT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_CHECK
       ( FPTN           = FPT_CHECK_NWIO,
         STCLASS        = CONSTANT,
         DCB            = M$CG_CONTROL ) ;
 
%FPT_EVENT
       ( FPTN           = FPT_EVENT_CONTROL,
         STCLASS        = CONSTANT,
         UENTRY         = LARKETTE_CONTROL_NWIO ) ;
 
%FPT_EVENT
       ( FPTN           = FPTEVENT_CONTROL,
         STCLASS        = AUTO ) ;
 
%FPT_FID
       ( FPTN           = FPT_FID_CG,
         STCLASS        = CONSTANT,
         ACCT           = VLP$ACCT_CG,
         NAME           = VLP$NAME_CG,
         PASS           = VLP$PASS_CG,
         SN             = VLP$SN_CG,
         WSN            = VLP$WSN_CG ) ;
 
%FPT_FID
       ( FPTN           = FPTFID,
         STCLASS        = AUTO ) ;
 
%FPT_READ
       ( FPTN           = FPT_READ_CONTROL,
         STCLASS        = CONSTANT,
         DCB            = M$CG_CONTROL,
         EVENT          = %CONTROL_EVENT,
         WAIT           = NO ) ;
 
%FPT_READ
       ( FPTN           = FPT_READ_MSG,
         STCLASS        = CONSTANT,
         DCB            = M$MSG_RD ) ;
 
%FPT_READ
       ( FPTN           = FPTREAD_MSG,
         STCLASS        = AUTO ) ;
 
%FPT_WAIT
       ( FPTN           = FPT_WAIT,
         STCLASS        = CONSTANT,
         UETIME         = UNEXP_TIME ) ;
 
%FPT_WAIT
       ( FPTN           = FPTWAIT,
         STCLASS        = AUTO ) ;
 
%FPT_WRITE
       ( FPTN           = FPT_WRITE_MSG,
         STCLASS        = CONSTANT,
         DCB            = M$MSG_WR ) ;
 
%FPT_WRITE
       ( FPTN           = FPTWRITE_MSG,
         STCLASS        = AUTO ) ;
 
%VLP_ACCT
       ( FPTN           = VLP$ACCT_CG,
         STCLASS        = STATIC ) ;
 
%VLP_ERRCODE
       ( FPTN           = VLPERRCODE,
         STCLASS        = AUTO ) ;
 
%VLP_NAME
       ( FPTN           = VLP$NAME_CG,
         STCLASS        = STATIC,
         LEN            = 31 ) ;
 
%VLP_PASS
       ( FPTN           = VLP$PASS_CG,
         STCLASS        = STATIC ) ;
 
%VLP_SETSTA
       ( FPTN           = VLP_SETSTA_CG,
         STCLASS        = CONSTANT ) ;
 
%VLP_SETSTA
       ( FPTN           = VLPSETSTA_CG,
         STCLASS        = AUTO ) ;
 
%VLP_SN
       ( FPTN           = VLP$SN_CG,
         STCLASS        = STATIC ) ;
 
%VLP_STATION
       ( FPTN           = VLP_STATION_CONTROL,
         STCLASS        = CONSTANT,
         DIRONLY        = YES,
         MSGTYP         = "%CONTROL_MSGTYP" ) ;
 
%VLP_WSN
       ( FPTN           = VLP$WSN_CG,
         STCLASS        = STATIC ) ;
 
%XUX$PARAM_NO_PARSE
       ( NAME           = XUX_CCBUF,
         STCLASS        = CONSTANT,
         DISP_ONLY      = YES ) ;
 
%XUX$PARAM_NO_PARSE
       ( NAME           = XUXCCBUF,
         STCLASS        = AUTO ) ;
 
%LARKETTE_CONTROL_BUFFER ;
%LARKETTE_FUNCTION ;
%LARKETTE_STATUS ;
 
/*
   Global data
*/
 
%FPT_WRITE
       ( FPTN           = FPT$WRITE_CONTROL,
         STCLASS        = STATIC SYMDEF,
         DCB            = M$CG_CONTROL ) ;
 
%VLP_STATION
       ( FPTN           = VLP$STATION_CONTROL,
         STCLASS        = STATIC SYMDEF ) ;
 
DCL      1  CONTROL_NWIO STATIC SYMDEF,
            2  COMPLETE BIT ( 1 ) ALIGNED,
            2  EVID     UBIN WORD,
            2  ERR      BIT ( 36 ),
            2  TYC      BIT ( 36 ) ;
 
%EQU     READ           = 1 ;
%EQU     WRITE          = 2 ;
 
DCL      UNEXP_TIME     UBIN STATIC ;
 
/*
   Local data
*/
 
DCL      B$JIT$         PTR SYMREF ;
DCL      B$TCB$         PTR SYMREF ;
DCL      FUNCTION$      PTR ;
DCL      FUNCTION_BUF$  PTR ;
DCL      FUNCTION_BUF   BASED ( FUNCTION_BUF$ ) CHAR ( FUNCTION_BUFL ) ;
DCL      FUNCTION_BUFL  SBIN ;
DCL      DATA_SEG_      VECTOR ;
DCL      M$CG_CONTROL   DCB ;
DCL      M$CG_SLAVE     DCB ;
DCL      M$MSG_RD       DCB ;
DCL      M$MSG_WR       DCB ;
DCL      POS1           SBIN ;
DCL      POS2           SBIN ;
DCL      POS3           SBIN ;
DCL      STATUS$        PTR ;
 
%EJECT ;
DATA_SEG_ = VECTOR ( NIL ) ;
 
/*
   Make sure we've been started by LARK as a ghost.
*/
 
IF ( B$JIT$->B$JIT.MODE ~= %M_GHOST# ) THEN DO ;
   CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
END ;
 
/*
   Get a data segment to store function information.
   This segment is used temporarily to process the CCBUF information.
*/
 
CALL LARKETTE_GET_DATA_SEGMENT ( DATA_SEG_,
                                 %SIZE_DATA_SEG_BLOCK,
                                 STATUS.CONTROL.STATION# )
      WHENALTRETURN DO ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
 
/*
   Setting up the data segment pointers.
*/
 
FUNCTION$ = VBASE ( DATA_SEG_ ) ;
STATUS$ = PINCRW ( FUNCTION$,
                   SIZEW ( FUNCTION ) ) ;
FUNCTION_BUF$ = PINCRW ( STATUS$,
                         SIZEW ( STATUS ) ) ;
 
/*
   Get the information out of the CCBUF.
*/
 
XUXCCBUF = XUX_CCBUF ;
FUNCTION_BUFL = 120 ;
XUXCCBUF.BUFFER_ = VECTOR ( FUNCTION_BUF ) ;
DO UNTIL ( XUXCCBUF.CMD_LEN > 0 ) ;
   CALL XUX$GETLINE ( XUXCCBUF )
         WHENALTRETURN DO ;
            CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
         END ;
END ;
CALL XUX$CLEANUP ;
 
CALL INDEX1 ( POS1,
              ',',
              FUNCTION_BUF,
              1 ) ;
CALL INDEX1 ( POS2,
              ',',
              FUNCTION_BUF,
              POS1 + 1 ) ;
CALL INDEX1 ( POS3,
              ')',
              FUNCTION_BUF,
              POS2 + 1 ) ;
 
/*
   Initializing the status structure.
*/
 
STATUS.CONTROL.STATION# = SUBSTR ( FUNCTION_BUF,
                                   POS1 + 1,
                                   POS2 - ( POS1 + 1 ) ) ;
STATUS.CONTROL.ABORTED# = %NO# ;
STATUS.CONTROL.CONNECTED# = %NO# ;
STATUS.FUNCTION.CONNECTED# = %NO# ;
STATUS.FUNCTION.DEFINED# = %NO# ;
STATUS.FUNCTION.SUSPENDED# = %YES# ;
STATUS.LARK.STATION# = SUBSTR ( FUNCTION_BUF,
                                POS2 + 1,
                                POS3 - ( POS2 + 1 ) ) ;
 
/*
   Processing the FID.
*/
 
FPTFID = FPT_FID_CG ;
FPTFID.V_ = VECTOR ( FPTFID.V ) ;
FPTFID.TEXTFID_ = VECTOR ( SUBSTR ( FUNCTION_BUF,
                                       1,
                                       POS1 - 1 ) ) ;
FPTFID.ASN_ = VECTOR ( CONTROL_BUFFER ) ;
FPTFID.RES_ = VECTOR ( CONTROL_BUFFER ) ;
FPTFID.RESULTS_ = VECTOR ( CONTROL_BUFFER ) ;
CALL M$FID ( FPTFID )
      WHENALTRETURN DO ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
 
/*
   Set up the control station info.  The "default" message type is
   CONTROL_MSGTYP.
*/
 
VLP$STATION_CONTROL = VLP_STATION_CONTROL ;
VLP$STATION_CONTROL.STATION# = STATUS.LARK.STATION# ;
 
/*
   Open the control station to receive information describing the
   function to be performed by the slave station.
   Send a message to LARK telling him the control station is connected.
*/
 
VLPSETSTA_CG = VLP_SETSTA_CG ;
VLPSETSTA_CG.MYSTATION# = STATUS.CONTROL.STATION# ;
CALL CONNECT_STATION ( '        ',   /* STATUS.CONTROL.STATION#, */
                       DCBNUM ( M$CG_CONTROL ),
                       %NO#,
                       VECTOR ( VLPSETSTA_CG ) )
      WHENALTRETURN DO ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
STATUS.CONTROL.CONNECTED# = %YES# ;
 
/*
   Establish the entry for the no-wait IO event processing routine LARKETTE_CONTROL_NWIO.
*/
 
FPTEVENT_CONTROL = FPT_EVENT_CONTROL ;
FPTEVENT_CONTROL.V_ = VECTOR ( FPTEVENT_CONTROL.V ) ;
CALL M$EVENT ( FPTEVENT_CONTROL )
      WHENALTRETURN DO ;
         CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                           STATUS.CONTROL.STATION# ) ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
 
FPTWAIT = FPT_WAIT ;
FPTWAIT.V_ = VECTOR ( FPTWAIT.V ) ;
 
/*
   Start a no-wait read.
*/
 
CALL LARKETTE_READ_MESSAGE ( VECTOR ( FPT_READ_CONTROL.V ),
                             VECTOR ( VLP$STATION_CONTROL ),
                             VECTOR ( CONTROL_BUFFER ),
                             STATUS.CONTROL.STATION# )
      WHENALTRETURN DO ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
 
DO WHILE NOT STATUS.CONTROL.ABORTED# ;
 
   /*
      Read the information from LARK describing the function to be performed
      by the slave.  Can't start the operation of the functional station until
      he's defined and connected.
   */
 
   DO UNTIL STATUS.FUNCTION.DEFINED# AND STATUS.FUNCTION.CONNECTED# ;
      CALL M$CHECK ( FPT_CHECK_NWIO )
            WHENALTRETURN DO ;
               CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                 STATUS.CONTROL.STATION# ) ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
      CALL PROCESS_CONTROL_COMMAND ;
      CALL LARKETTE_READ_MESSAGE ( VECTOR ( FPT_READ_CONTROL.V ),
                                   VECTOR ( VLP$STATION_CONTROL ),
                                   VECTOR ( CONTROL_BUFFER ),
                                   STATUS.CONTROL.STATION# )
            WHENALTRETURN DO ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
   END ;
 
   /*
      Perform the described function.  If this function is not performed
      completely or if LARKETTE is to abort on completion of the function,
      the status bits are set accordingly.
   */
 
   IF FUNCTION.READ.FLAG# THEN DO ;
      CALL PERFORM_READS ;
   END ; ELSE IF FUNCTION.WRITE.FLAG# THEN DO ;
      CALL PERFORM_WRITES ;
   END ; ELSE DO ;
      STATUS.CONTROL.ABORTED# = FUNCTION.ADMIN.COMP_ABORT# ;
   END ;
 
   /*
      If the function is completed and the control station is to be left
      looping in LARKETTE waiting for further instructions, close the function
      station until those instructions are received; if it has been specified
      to not disconnect the station, it gets suspended.
   */
 
   IF STATUS.FUNCTION.CONNECTED# AND NOT STATUS.CONTROL.ABORTED# AND
         FUNCTION.ADMIN.COMP_DISC# THEN DO ;
      CALL DISCONNECT_STATION ( STATUS.FUNCTION.STATION#,
                                DCBNUM ( M$CG_SLAVE ) ) ;
      STATUS.FUNCTION.CONNECTED# = %NO# ;
   END ;
 
   /*
      If the NEWDEF flag isn't set, then the station can be reconnected
      to do the same function again.
   */
 
   IF FUNCTION.ADMIN.COMP_NEWDEF# THEN DO ;
      STATUS.FUNCTION.DEFINED# = %NO# ;
   END ;
 
   /*
      No matter how the flags are set, the station always will be suspended at
      the completion of its task.
   */
 
   STATUS.FUNCTION.SUSPENDED# = %YES# ;
 
END ;
 
/*
   LARKETTE has made the decision to issue the ABORT sequence.  One of the following
   cases is true:
      1)  normal completion has occurred and COMP_ABORT = YES
      2)  functional station IO error has occurred and ERR_ABORT = YES
   LARKETTE sends an abort status header and block, disconnects the stations,
    and quits.
*/
 
CONTROL_BUFFER.CODE = %ABORT_LARKETTE ;
CALL PROCESS_CONTROL_COMMAND ;
 
/*
   Doesn't return!!!
*/
 
%EJECT ;
/*I*
   NAME:          CHECK_NWIO
   PURPOSE:       To process a no-wait read, if one has completed
   CALL:          CALL CHECK_NWIO
   INPUT:         CONTROL_NWIO which is filled with information concerning
                     a completed read by the ASYNC routine for no-wait IO
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_READ_MESSAGE
                  LARKETTE_RETURN_NWIO_ERROR
                  PROCESS_CONTROL_COMMAND
   DESCRIPTION:   Processes a no-wait read completion by checking to see if
                  any errors have occurred (aborts if any have), carries out
                  the operation, and issues another read.
*/
 
%EJECT ;
CHECK_NWIO : PROC ;
 
%EJECT ;
   IF CONTROL_NWIO.COMPLETE THEN DO ;
      IF ( CONTROL_NWIO.EVID ~= %CONTROL_EVENT ) OR ( BITBIN ( CONTROL_NWIO.ERR ) ~= 0 ) THEN DO ;
         CALL LARKETTE_RETURN_NWIO_ERROR ( CONTROL_NWIO,
                                           STATUS.CONTROL.STATION# ) ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
      END ;
      CALL PROCESS_CONTROL_COMMAND ;
      CALL LARKETTE_READ_MESSAGE ( VECTOR ( FPT_READ_CONTROL.V ),
                                   VECTOR ( VLP$STATION_CONTROL ),
                                   VECTOR ( CONTROL_BUFFER ),
                                   STATUS.CONTROL.STATION# )
            WHENALTRETURN DO ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
   END ;
 
   RETURN ;
 
END CHECK_NWIO ;
 
%EJECT ;
/*I*
   NAME:          CLOSE_MSGFILE
   PURPOSE:       To close the specified messagefile.  This file was used either
                  as a source of messages or a place to put them when received.
   CALL:          CALL CLOSE_RD_MSGFILE ( READ_WRITE )
   PARAMETER:     READ_WRITE specifies which message file is being closed
   INPUT:         FUNCTION block passed from LARK
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_RETURN_PMME_ERROR
   DESCRIPTION    Closes the RD or WR message file.
*/
 
%EJECT ;
CLOSE_MSGFILE : PROC ( READ_WRITE ) ;
 
DCL      READ_WRITE     UBIN ;
 
%FPT_CLOSE
       ( FPTN           = FPT_CLOSE_MSG,
         STCLASS        = CONSTANT,
         DISP           = SAVE ) ;
 
%FPT_CLOSE
       ( FPTN           = FPTCLOSE_MSG,
         STCLASS        = AUTO ) ;
 
%EJECT ;
   FPTCLOSE_MSG = FPT_CLOSE_MSG ;
   FPTCLOSE_MSG.V_ = VECTOR ( FPTCLOSE_MSG.V ) ;
   IF ( READ_WRITE = %READ ) THEN DO ;
      FPTCLOSE_MSG.V.DCB# = DCBNUM ( M$MSG_RD ) ;
   END ; ELSE DO ;
      FPTCLOSE_MSG.V.DCB# = DCBNUM ( M$MSG_WR ) ;
   END ;
   CALL M$CLOSE ( FPTCLOSE_MSG )
         WHENALTRETURN DO ;
            CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                              STATUS.CONTROL.STATION# ) ;
         END ;
 
 
   RETURN ;
 
END CLOSE_MSGFILE ;
 
%EJECT ;
/*I*
   NAME:          CONNECT_STATION
   PURPOSE:       To open the DCB and then send a connect message to LARK.
   CALL:          CALL CONNECT_STATION ( CONN_STATION,
                                         CONN_DCBNUM,
                                         CONN_AUFLAG,
                                         CONN_SETSTA_ )
   PARAMETERS:    CONN_STATION is the station name of the station to connect
                  CONN_DCBNUM is the DCBNUM of the station to connect
                  CONN_AUFLAG signals if this station is to be the AU
                  CONN_SETSTA_ provides the vector of the SETSTA to be used
   INPUT:         CONN_STATION
                  CONN_DCBNUM
                  CONN_AUFLAG
                  CONN_SETSTA_
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_RETURN_PMME_ERROR
                  LARKETTE_WRITE_MESSAGE
   DESCRIPTION:   Opens the station and then sends a connect message to
                  LARK if the station isn't blank.   If the open ALTRETs,
                  this routine ALTRET's.  If the other ALTRETs, LARKETTE is
                  automatically aborted.
*/
 
%EJECT ;
 
CONNECT_STATION : PROC ( CONN_STATION, CONN_DCBNUM, CONN_AUFLAG, CONN_SETSTA_ ) ALTRET ;
 
/*
   Parameters
*/
 
DCL      CONN_STATION   CHAR ( 8 ) ;
DCL      CONN_DCBNUM    UBIN ;
DCL      CONN_AUFLAG    BIT ( 1 ) ;
DCL      CONN_SETSTA_   VECTOR ;
 
/*
   Structures
*/
 
%FPT_OPEN
       ( FPTN           = FPT_OPEN_CG,
         STCLASS        = CONSTANT,
         ACCT           = VLP$ACCT_CG,
         ASN            = COMGROUP,
         FUN            = UPDATE,
         NAME           = VLP$NAME_CG,
         PASS           = VLP$PASS_CG,
         SCRUB          = YES,
         SHARE          = ALL,
         SN             = VLP$SN_CG,
         WSN            = VLP$WSN_CG ) ;
 
%FPT_OPEN
       ( FPTN           = FPTOPEN_CG,
         STCLASS        = AUTO ) ;
 
%EJECT ;
   FPTOPEN_CG = FPT_OPEN_CG ;
   FPTOPEN_CG.V_ = VECTOR ( FPTOPEN_CG.V ) ;
   FPTOPEN_CG.SETSTA_ = CONN_SETSTA_ ;
   FPTOPEN_CG.V.DCB# = CONN_DCBNUM ;
   FPTOPEN_CG.V.AU# = CONN_AUFLAG ;
   CALL M$OPEN ( FPTOPEN_CG )
         ALTRET ( ALT ) ;
 
   IF ( CONN_STATION ~= ' ' ) THEN DO ;
      CONTROL_BUFFER.CODE = %CONNECTED_STATION ;
      CONTROL_BUFFER.STATION = CONN_STATION ;
      CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                    VECTOR ( VLP$STATION_CONTROL ),
                                    VECTOR ( CONTROL_BUFFER ),
                                    STATUS.CONTROL.STATION# )
            WHENALTRETURN DO ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
   END ;
 
   RETURN ;
 
   ALT: ;
      ALTRETURN ;
END CONNECT_STATION ;
 
%EJECT ;
/*I*
   NAME:          DISCONNECT_STATION
   PURPOSE:       To send a disconnect message to LARK and then close the DCB.
   CALL:          CALL DISCONNECT_STATION ( DISC_STATION,
                                            DISC_DCBNUM )
   PARAMETERS:    DISC_STATION is the station name of the station to disconnect
                  DISC_DCBNUM is the DCBNUM of the station to disconnect
   INPUT:         DISC_STATION
                  DISC_DCBNUM
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_RETURN_PMME_ERROR
                  LARKETTE_WRITE_MESSAGE
   DESCRIPTION:   Sends a disconnect message to LARK if station name is not blank
                  and then closes the station.  If these calls ALTRET, this routine
                  automatically aborts LARKETTE.
*/
 
%EJECT ;
 
DISCONNECT_STATION : PROC ( DISC_STATION, DISC_DCBNUM ) ;
 
/*
   Parameters
*/
 
DCL      DISC_STATION   CHAR ( 8 ) ;
DCL      DISC_DCBNUM    UBIN ;
 
/*
   Structures
*/
 
%FPT_CLOSE
       ( FPTN           = FPT_CLOSE_CG,
         STCLASS        = CONSTANT ) ;
 
%FPT_CLOSE
       ( FPTN           = FPTCLOSE_CG,
         STCLASS        = AUTO ) ;
 
%EJECT ;
   IF ( DISC_STATION ~= ' ' ) THEN DO ;
      CONTROL_BUFFER.CODE = %DISCONNECTED_STATION ;
      CONTROL_BUFFER.STATION = DISC_STATION ;
      CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                    VECTOR ( VLP$STATION_CONTROL ),
                                    VECTOR ( CONTROL_BUFFER ),
                                    STATUS.CONTROL.STATION# )
            WHENALTRETURN DO ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
   END ;
   FPTCLOSE_CG = FPT_CLOSE_CG ;
   FPTCLOSE_CG.V_ = VECTOR ( FPTCLOSE_CG.V ) ;
   FPTCLOSE_CG.V.DCB# = DISC_DCBNUM ;
   CALL M$CLOSE ( FPTCLOSE_CG )
         WHENALTRETURN DO ;
            CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                              STATUS.CONTROL.STATION# ) ;
            CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
         END ;
 
   RETURN ;
 
END DISCONNECT_STATION ;
 
%EJECT ;
/*I*
   NAME:          GENERATE_MESSAGE
*/
 
%EJECT ;
GENERATE_MESSAGE : PROC ( MSGFILE, EOF ) ;
 
DCL      EOF            BIT ( 1 ) ;
DCL      MSGFILE        BIT ( 1 ) ;
 
   IF MSGFILE THEN DO ;
      FUNCTION_BUFL = FUNCTION.WRITE.MAXLEN# ;
      FUNCTION_BUF = ' ' ;
      CALL M$READ ( FPTREAD_MSG )
            WHENRETURN DO ;
               FUNCTION_BUFL = DCBADDR ( DCBNUM ( M$MSG_RD ) )->F$DCB.ARS# ;
            END ;
            WHENALTRETURN DO ;
               IF ( B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF ) THEN DO ;
                  EOF = %YES# ;
               END ; ELSE DO ;
                  CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                    STATUS.CONTROL.STATION# ) ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
            END ;
   END ; ELSE DO ;
      FUNCTION_BUF = ' ' ;
      CALL BINCHAR ( SUBSTR ( FUNCTION_BUF,
                              0,
                              8 ),
                     STATUS.FUNCTION.WRITES# ) ;
      SUBSTR ( FUNCTION_BUF,
               FUNCTION_BUFL - 1,
               1 )                = '*' ;
   END ;
 
   RETURN ;
 
END GENERATE_MESSAGE ;
 
%EJECT ;
/*I*
   NAME:          OPEN_MSGFILE
   PURPOSE:       To open the specified messagefile.  This file is used either
                  as a source of messages or a place to put them when received.
                  sent to some station.
   CALL:          CALL OPEN_RD_MSGFILE ( READ_WRITE )
   PARAMETER:     READ_WRITE specifies which message file is being opened
   INPUT:         FUNCTION block passed from LARK
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_RETURN_PMME_ERROR
   DESCRIPTION    Opens the RD or WR message file after calling M$FID.
*/
 
%EJECT ;
OPEN_MSGFILE : PROC ( READ_WRITE ) ;
 
DCL      READ_WRITE     UBIN ;
 
%FPT_FID
       ( FPTN           = FPT_FID_MSG,
         STCLASS        = CONSTANT,
         ACCT           = VLP$ACCT_MSG,
         NAME           = VLP$NAME_MSG,
         PASS           = VLP$PASS_MSG,
         SN             = VLP$SN_MSG ) ;
 
%FPT_OPEN
       ( FPTN           = FPT_OPEN_MSG,
         STCLASS        = CONSTANT,
         ACCT           = VLP$ACCT_MSG,
         ASN            = FILE,
         FUN            = IN,
         NAME           = VLP$NAME_MSG,
         PASS           = VLP$PASS_MSG,
         ORG            = CONSEC,
         SCRUB          = YES,
         SN             = VLP$SN_MSG ) ;
 
%FPT_OPEN
       ( FPTN           = FPTOPEN_MSG,
         STCLASS        = AUTO ) ;
 
%VLP_ACCT
       ( FPTN           = VLP$ACCT_MSG,
         STCLASS        = STATIC ) ;
 
%VLP_NAME
       ( FPTN           = VLP$NAME_MSG,
         STCLASS        = STATIC,
         LEN            = 31 ) ;
 
%VLP_PASS
       ( FPTN           = VLP$PASS_MSG,
         STCLASS        = STATIC ) ;
 
%VLP_SN
       ( FPTN           = VLP$SN_MSG,
         STCLASS        = STATIC ) ;
 
%EJECT ;
   FPTFID = FPT_FID_MSG ;
   FPTFID.V_ = VECTOR ( FPTFID.V ) ;
   IF ( READ_WRITE = %WRITE ) THEN DO ;
      FPTFID.TEXTFID_ = VECTOR ( FUNCTION.READ.MSGFILE# ) ;
   END ; ELSE DO ;
      FPTFID.TEXTFID_ = VECTOR ( FUNCTION.WRITE.MSGFILE# ) ;
   END ;
   FUNCTION_BUFL = 100 ;
   FPTFID.ASN_ = VECTOR ( FUNCTION_BUF ) ;
   FPTFID.RES_ = VECTOR ( FUNCTION_BUF ) ;
   FPTFID.RESULTS_ = VECTOR ( FUNCTION_BUF ) ;
   FPTFID.WSN_ = VECTOR ( FUNCTION_BUF ) ;
   CALL M$FID ( FPTFID )
         WHENALTRETURN DO ;
            CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                              STATUS.CONTROL.STATION# ) ;
            CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
         END ;
   FPTOPEN_MSG = FPT_OPEN_MSG ;
   FPTOPEN_MSG.V_ = VECTOR ( FPTOPEN_MSG.V ) ;
   IF ( READ_WRITE = %READ ) THEN DO ;
      FPTOPEN_MSG.V.DCB# = DCBNUM ( M$MSG_RD ) ;
   END ; ELSE DO ;
      FPTOPEN_MSG.V.DCB# = DCBNUM ( M$MSG_WR ) ;
      FPTOPEN_MSG.V.CTG# = %YES# ;
      IF FUNCTION.READ.NEWMSGFILE# THEN DO ;
         FPTOPEN_MSG.V.EXIST# = %NEWFILE# ;
      END ; ELSE DO ;
         FPTOPEN_MSG.V.EXIST# = %ERROR# ;
      END ;
      FPTOPEN_MSG.V.FUN# = %CREATE# ;
   END ;
   CALL M$OPEN ( FPTOPEN_MSG )
         WHENALTRETURN DO ;
            CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                              STATUS.CONTROL.STATION# ) ;
            CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
         END ;
   IF ( READ_WRITE = %WRITE ) THEN DO ;
      FUNCTION_BUFL = FUNCTION.READ.MAXLEN# ;
      FPTWRITE_MSG = FPT_WRITE_MSG ;
      FPTWRITE_MSG.V_ = VECTOR ( FPTWRITE_MSG.V ) ;
      FPTWRITE_MSG.BUF_ = VECTOR ( FUNCTION_BUF ) ;
   END ; ELSE DO ;
      FUNCTION_BUFL = FUNCTION.WRITE.MAXLEN# ;
      FPTREAD_MSG = FPT_READ_MSG ;
      FPTREAD_MSG.V_ = VECTOR ( FPTREAD_MSG.V ) ;
      FPTREAD_MSG.BUF_ = VECTOR ( FUNCTION_BUF ) ;
   END ;
 
   RETURN ;
 
END OPEN_MSGFILE ;
 
%EJECT ;
/*I*
   NAME:          PERFORM_READS
   PURPOSE:       To do the functional station reads as defined
   CALL:          CALL PERFORM_READS
   INPUT:         FUNCTION block passed from LARK
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_READ_MESSAGE
                  LARKETTE_RETURN_PMME_ERROR
                  CHECK_NWIO
                  OPEN_MSGFILE
                  SINGLE_READ
   DESCRIPTION:   Performs the reads for the functional station by looping
                  through the number to do and waiting inbetween to provide
                  the requested frequency.  If a message file has been specified,
                  each message is written to it.  Checks before each read to see
                  if any control messages have been sent from LARK and processes
                  them.  If no EOFTIME has been specified, it is set to 5 seconds
                  to prevent being hung forever on a wait read.  At the completion
                  of the read, if an EOF error is returned, any control messages
                  are processed and then the read is issued again.
                  If the functional station is suspended, it loops waiting
                  for a control command.  If the functional station is disconnected,
                  it quits performing reads and returns.  If an error occurs on
                  a read operation and the ERR_ABORT flag is set, the  control
                  station ABORT flag is set and it returns.  Also, upon completion,
                  if the COMP_ABORT flag is set, the control station ABORT flag is
                  set.
*/
 
%EJECT ;
PERFORM_READS : PROC ;
 
DCL      I              SBIN ;
DCL      DONE           BIT ( 1 ) ;
DCL      FORCE_TIMEOUT  BIT ( 1 ) ;
DCL      MSGFILE        BIT ( 1 ) ;
 
%EJECT ;
   FUNCTION_BUFL = FUNCTION.READ.MAXLEN# ;
   MSGFILE = ( FUNCTION.READ.MSGFILE# ~= ' ' ) ;
   IF MSGFILE THEN DO ;
      CALL OPEN_MSGFILE ( %WRITE ) ;
   END ;
   IF ( FUNCTION.READ_STATION.EOFTIME# = 0 ) AND ( FUNCTION.SETSTA.ISTA.EOFTIME# = 0 ) THEN DO ;
      FORCE_TIMEOUT = %YES# ;
      FUNCTION.READ_STATION.EOFTIME# = 5 ;
   END; ELSE DO ;
      FORCE_TIMEOUT = %NO# ;
   END ;
   DO I = 1 TO FUNCTION.READ.NUMOPS# ;
      CALL SINGLE_READ ( MSGFILE,
                         FORCE_TIMEOUT )
            ALTRET ( FLAGS_SET ) ;
      IF ( FUNCTION.READ.FREQ# > 0 ) THEN DO ;
         FPTWAIT.V.UNITS# = FUNCTION.READ.FREQ# ;
         DONE = %NO# ;
         DO UNTIL DONE ;
            CALL M$WAIT ( FPTWAIT )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                       STATUS.CONTROL.STATION# ) ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
            IF ( UNEXP_TIME > 0 ) THEN DO ;
               CALL CHECK_NWIO ;
               FPTWAIT.V.UNITS# = UNEXP_TIME ;
            END ; ELSE DO ;
               DONE = %YES# ;
            END ;
         END ;
      END ;
   END ;
   CALL CHECK_NWIO ;
   IF FUNCTION.ADMIN.COMP_ABORT# THEN DO ;
      STATUS.CONTROL.ABORTED# = %YES# ;
   END ;
 
   FLAGS_SET: ;
 
   IF MSGFILE THEN DO ;
      CALL CLOSE_MSGFILE ( %WRITE ) ;
   END ;
 
   RETURN ;
 
END PERFORM_READS ;
 
%EJECT ;
/*I*
   NAME:          PERFORM_WRITES
   PURPOSE:       To do the functional station writes as defined
   CALL:          CALL PERFORM_WRITES
   INPUT:         FUNCTION block passed from LARK
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_WRITE_MESSAGE
                  LARKETTE_RETURN_PMME_ERROR
                  CHECK_NWIO
   DESCRIPTION:   Performs numbered writes for the functional station by looping
                  through the number to do and waiting inbetween to provide
                  the requested frequency.  If a message file has been specified,
                  the message to be written is obtained from that file; otherwise,
                  a numbered message is generated.  Checks before each write to see
                  if any control messages have been sent from LARK and processes
                  them.  If the functional station is suspended, it loops waiting
                  for a control command.  If the functional station is disconnected,
                  it quits performing writes and returns.  If an error occurs on
                  a write operation and the ERR_ABORT flag is set, the  control
                  station ABORT flag is set and it returns.  Also, upon completion,
                  if the COMP_ABORT flag is set, the control station ABORT flag is
                  set.
*/
 
%EJECT ;
PERFORM_WRITES : PROC ;
 
DCL      I              SBIN ;
DCL      DONE           BIT ( 1 ) ;
DCL      EOF            BIT ( 1 ) ;
DCL      MSGFILE        BIT ( 1 ) ;
 
%EJECT ;
   FUNCTION_BUFL = FUNCTION.WRITE.MAXLEN# ;
   MSGFILE = ( FUNCTION.WRITE.MSGFILE# ~= ' ' ) ;
   EOF = %NO# ;
   IF MSGFILE THEN DO ;
      CALL OPEN_MSGFILE ( %READ ) ;
   END ;
 
   CALL GENERATE_MESSAGE ( MSGFILE, EOF ) ;
   IF MSGFILE AND ( FUNCTION.WRITE.NUMOPS# = 0 ) THEN DO ;
      FUNCTION.WRITE.NUMOPS# = 999999999 ;
   END ;
   I = 1 ;
   DO WHILE ( I <= FUNCTION.WRITE.NUMOPS# ) AND NOT EOF ;
      CALL SINGLE_WRITE ( MSGFILE )
            ALTRET ( FLAGS_SET ) ;
      I = I + 1 ;
      CALL GENERATE_MESSAGE ( MSGFILE, EOF ) ;
      IF ( FUNCTION.WRITE.FREQ# > 0 ) THEN DO ;
         FPTWAIT.V.UNITS# = FUNCTION.WRITE.FREQ# ;
         DONE = %NO# ;
         DO UNTIL DONE ;
            CALL M$WAIT ( FPTWAIT )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                       STATUS.CONTROL.STATION# ) ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
            IF ( UNEXP_TIME > 0 ) THEN DO ;
               CALL CHECK_NWIO ;
               FPTWAIT.V.UNITS# = UNEXP_TIME ;
            END ; ELSE DO ;
               DONE = %YES# ;
            END ;
         END ;
      END ;
   END ;
   CALL CHECK_NWIO ;
   IF FUNCTION.ADMIN.COMP_ABORT# THEN DO ;
      STATUS.CONTROL.ABORTED# = %YES# ;
   END ;
 
   FLAGS_SET: ;
 
   IF MSGFILE THEN DO ;
      CALL CLOSE_MSGFILE ( %READ ) ;
   END ;
 
   RETURN ;
 
END PERFORM_WRITES ;
 
%EJECT ;
/*I*
   NAME:          PROCESS_CONTROL_COMMAND
   PURPOSE:       To process a control command from LARK
   CALL:          CALL PROCESS_CONTROL_COMMAND
   INPUT:         CONTROL_NWIO
   INTERFACE:     LARKETTE_GIVE_UP
                  LARKETTE_READ_MESSAGE
                  LARKETTE_RETURN_PMME_ERROR
                  LARKETTE_WRITE_MESSAGE
                  DISCONNECT_STATION
   DESCRIPTION:   Performs the various commands that LARK sends.  Doesn't
                  return from the ABORT command.
                  Sends the result of each command back to LARKETTE.
*/
 
%EJECT ;
PROCESS_CONTROL_COMMAND : PROC ;
 
%EJECT ;
   DO CASE CONTROL_BUFFER.CODE ;
 
      CASE ( %ABORT_LARKETTE ) ;
         /*
            Send the status abort header and the status block.
            Close the function and control stations and abort LARKETTE.
         */
         CONTROL_BUFFER.CODE = %STATUS_ABORT_HEADER ;
         CONTROL_BUFFER.STATION = STATUS.CONTROL.STATION# ;
         CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                       VECTOR ( VLP$STATION_CONTROL ),
                                       VECTOR ( CONTROL_BUFFER ),
                                       STATUS.CONTROL.STATION# )
               WHENALTRETURN DO ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
         VLP$STATION_CONTROL.MSGTYP# = %STATUS_MSGTYP ;
         CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                       VECTOR ( VLP$STATION_CONTROL ),
                                       VECTOR ( STATUS ),
                                       STATUS.CONTROL.STATION# )
               WHENALTRETURN DO ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
         VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
 
         IF STATUS.FUNCTION.CONNECTED# THEN DO ;
            CALL DISCONNECT_STATION ( '        ',
                                      DCBNUM ( M$CG_SLAVE ) ) ;
         END ;
         CALL DISCONNECT_STATION ( '        ',
                                   DCBNUM ( M$CG_CONTROL ) ) ;
         CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
 
      CASE ( %CONNECT_STATION ) ;
         /*
            Open the slave station.  It shouldn't be open so if it is, M$OPEN
            will ALTRET.  The FID is already set up in the FPT.  Also send a
            connect message to LARK.
         */
/*N*
            The code to allow LARKETTE to act as an AU is nonexistent at this
            time.
*/
         IF STATUS.FUNCTION.DEFINED# AND NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
            CALL CONNECT_STATION ( CONTROL_BUFFER.STATION,
                                   DCBNUM ( M$CG_SLAVE ),
                                   FUNCTION.ADMIN.AU#,
                                   VECTOR ( FUNCTION.SETSTA ) )
               WHENRETURN DO ;
                  STATUS.FUNCTION.CONNECTED# = %YES# ;
               END ;
               WHENALTRETURN DO ;
                  CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_OPENED,
                                                       STATUS.CONTROL.STATION# ) ;
               END ;
         END ; ELSE IF NOT STATUS.FUNCTION.DEFINED# THEN DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_DEFINED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ; ELSE DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_DISCONNECTED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ;
 
      CASE ( %DISCONNECT_STATION ) ;
         /*
            Update status information for the functional station.
            Send disconnect message to LARK and close function station.
         */
         IF STATUS.FUNCTION.CONNECTED# THEN DO ;
            CALL DISCONNECT_STATION ( CONTROL_BUFFER.STATION,
                                      DCBNUM ( M$CG_SLAVE ) ) ;
            STATUS.FUNCTION.CONNECTED# = %NO# ;
            STATUS.FUNCTION.DEFINED# = %NO# ;
            STATUS.FUNCTION.SUSPENDED# = %YES# ;
         END ; ELSE DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_CONNECTED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ;
 
      CASE ( %FUNCTION_BLK_HEADER ) ;
         /*
            Read for the function block.
         */
/*N*
            Was previously modified to allow DEFINE to a connected, suspended
            station.  However, if function is changed from READ<->WRITE,
            we don't continue correctly.  There are probably times that it
            would be useful to change the FUNCTION definition with the station
            connected, so this should be considered.
*/
         IF NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
            VLP$STATION_CONTROL.MSGTYP# = %FUNCTION_MSGTYP ;
            CALL LARKETTE_READ_MESSAGE ( VECTOR ( FPT_READ_CONTROL.V ),
                                         VECTOR ( VLP$STATION_CONTROL ),
                                         VECTOR ( FUNCTION ),
                                         STATUS.CONTROL.STATION# )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
            CALL M$CHECK ( FPT_CHECK_NWIO )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                       STATUS.CONTROL.STATION# ) ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
            VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
            /*
               Set up the status block.
            */
            STATUS.FUNCTION.DEFINED# = %YES# ;
            STATUS.FUNCTION.STATION# = FUNCTION.SETSTA.MYSTATION# ;
            STATUS.FUNCTION.READS# = 0 ;
            STATUS.FUNCTION.READ_ERRS# = 0 ;
            STATUS.FUNCTION.WRITES# = 0 ;
            STATUS.FUNCTION.WRITE_ERRS# = 0 ;
            STATUS.FUNCTION.ERRCODE = '0'B ;
            FUNCTION.READ_V.DCB# = DCBNUM ( M$CG_SLAVE ) ;
            FUNCTION.WRITE_V.DCB# = DCBNUM ( M$CG_SLAVE ) ;
            CONTROL_BUFFER.CODE = %DEFINED_STATION ;
            CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                          VECTOR ( VLP$STATION_CONTROL ),
                                          VECTOR ( CONTROL_BUFFER ),
                                          STATUS.CONTROL.STATION# )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
         END ; ELSE DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_DISCONNECTED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ;
 
      CASE ( %RESUME_STATION ) ;
         IF STATUS.FUNCTION.SUSPENDED# AND STATUS.FUNCTION.CONNECTED# THEN DO ;
            STATUS.FUNCTION.SUSPENDED# = %NO# ;
            CONTROL_BUFFER.CODE = %RESUMED_STATION ;
            CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                          VECTOR ( VLP$STATION_CONTROL ),
                                          VECTOR ( CONTROL_BUFFER ),
                                          STATUS.CONTROL.STATION# )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
         END ; ELSE IF NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_CONNECTED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ; ELSE DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_SUSPENDED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ;
 
      CASE ( %STATUS_REQUEST ) ;
         /*
            Send LARK a status block header and the status block.
         */
         CONTROL_BUFFER.CODE = %STATUS_REPORT_HEADER ;
         CONTROL_BUFFER.STATION = STATUS.CONTROL.STATION# ;
         CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                       VECTOR ( VLP$STATION_CONTROL ),
                                       VECTOR ( CONTROL_BUFFER ),
                                       STATUS.CONTROL.STATION# )
               WHENALTRETURN DO ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
         VLP$STATION_CONTROL.MSGTYP# = %STATUS_MSGTYP ;
         CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                       VECTOR ( VLP$STATION_CONTROL ),
                                       VECTOR ( STATUS ),
                                       STATUS.CONTROL.STATION# )
               WHENALTRETURN DO ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
         VLP$STATION_CONTROL.MSGTYP# = %CONTROL_MSGTYP ;
 
      CASE ( %SUSPEND_STATION ) ;
         IF NOT STATUS.FUNCTION.SUSPENDED# AND STATUS.FUNCTION.CONNECTED# THEN DO ;
            STATUS.FUNCTION.SUSPENDED# = %YES# ;
            CONTROL_BUFFER.CODE = %SUSPENDED_STATION ;
            CALL LARKETTE_WRITE_MESSAGE ( VECTOR ( FPT$WRITE_CONTROL.V ),
                                          VECTOR ( VLP$STATION_CONTROL ),
                                          VECTOR ( CONTROL_BUFFER ),
                                          STATUS.CONTROL.STATION# )
                  WHENALTRETURN DO ;
                     CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                  END ;
         END ; ELSE IF NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_CONNECTED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ; ELSE DO ;
            CALL LARKETTE_RETURN_COMMAND_ERROR ( %NOT_RESUMED,
                                                 STATUS.CONTROL.STATION# ) ;
         END ;
 
   END ;
 
   CONTROL_NWIO.COMPLETE = %NO# ;
 
   RETURN ;
 
END PROCESS_CONTROL_COMMAND ;
 
%EJECT ;
/*I*
   NAME:          SINGLE_READ
   PURPOSE:       Perform one read.
   CALL:          CALL SINGLE_READ ( MSGFILE, FORCE_TIMEOUT )
   PARAMETER:     MSGFILE indicates whether or not a message file exists
                  FORCE_TIMEOUT indicates whether or not EOFTIME is being forced
   INPUT:         MSGFILE
                  FORCE_TIMEOUT
   INTERFACE:     CHECK_NWIO
                  LARKETTE_GIVE_UP
                  LARKETTE_READ_MESSAGE
                  LARKETTE_RETURN_PMME_ERROR
   DESCRIPTION:   Performs a single read for the functional station.  If the
                  FORCE_TIMEOUT pararmeter is set, this read may timeout and
                  be re-issued several times.  This provides a mechanism by
                  which control messages can be processed so the station is
                  not hung reading (which prevents LARK from aborting it).  This
                  routine ALTRET's if the station becomes disconnected or if
                  his task has been aborted.  If a message file has been
                  provided, the received message is written to it.
*/
 
%EJECT ;
SINGLE_READ : PROC ( MSGFILE, FORCE_TIMEOUT ) ALTRET ;
 
DCL      FORCE_TIMEOUT        BIT ( 1 ) ;
DCL      MSGFILE              BIT ( 1 ) ;
 
DCL      DONE                 BIT ( 1 ) ;
DCL      READ_COUNTED         BIT ( 1 ) ;
 
   READ_COUNTED = %NO# ;
   DONE = %NO# ;
   DO UNTIL DONE ;
      CALL CHECK_NWIO ;
      DO WHILE STATUS.FUNCTION.SUSPENDED# AND STATUS.FUNCTION.CONNECTED# ;
         CALL M$CHECK ( FPT_CHECK_NWIO )
               WHENALTRETURN DO ;
                  CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                    STATUS.CONTROL.STATION# ) ;
                  CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
               END ;
         CALL CHECK_NWIO ;
      END ;
      IF NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
         GOTO ALT ;
      END ;
      IF NOT READ_COUNTED THEN DO ;
         STATUS.FUNCTION.READS# = STATUS.FUNCTION.READS# + 1 ;
         READ_COUNTED = %YES# ;
      END ;
      FUNCTION_BUF = ' ' ;
      CALL LARKETTE_READ_MESSAGE_ERR_RET ( VECTOR ( FUNCTION.READ_V ),
                                           VECTOR ( FUNCTION.READ_STATION ),
                                           VECTOR ( FUNCTION_BUF ),
                                           '        ',
                                           VLPERRCODE )
            WHENRETURN DO ;
               DONE = %YES# ;
               IF MSGFILE THEN DO ;
                  FPTWRITE_MSG.BUF_ = VECTOR ( FUNCTION_BUF ) ;
                  IF ( DCBADDR ( DCBNUM ( M$CG_SLAVE ) )->F$DCB.ARS# > 0 ) THEN DO ;
                     FPTWRITE_MSG.BUF_.BOUND = DCBADDR ( DCBNUM ( M$CG_SLAVE ) )->F$DCB.ARS# - 1 ;
                  END ; ELSE DO ;
                     FPTWRITE_MSG.BUF_ = VECTOR ( NIL ) ;
                  END ;
                  CALL M$WRITE ( FPTWRITE_MSG )
                        WHENALTRETURN DO ;
                           CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                             STATUS.CONTROL.STATION# ) ;
                           CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
                        END ;
               END ;
            END ;
            WHENALTRETURN DO ;
               IF NOT FORCE_TIMEOUT OR ( VLPERRCODE.ERR# ~= %E$EOF ) THEN DO ;
                  DONE = %YES# ;
                  STATUS.FUNCTION.ERRCODE = VLPERRCODE ;
                  STATUS.FUNCTION.READ_ERRS# = STATUS.FUNCTION.READ_ERRS# + 1 ;
                  IF FUNCTION.READ.ERR_ABORT# THEN DO ;
                     STATUS.CONTROL.ABORTED# = %YES# ;
                     GOTO ALT ;
                  END ;
               END ;
            END ;
   END ;
 
   RETURN ;
 
   ALT: ;
      ALTRETURN ;
 
END SINGLE_READ ;
 
%EJECT ;
/*I*
   NAME:          SINGLE_WRITE
   PURPOSE:       Perform one write
   CALL:          CALL SINGLE_WRITE ( MSGFILE )
   PARAMETER:     MSGFILE indicates whether or not a message file exists
   INPUT:
   INTERFACE:     CHECK_NWIO
                  LARKETTE_GIVE_UP
                  LARKETTE_RETURN_PMME_ERROR
                  LARKETTE_WRITE_MESSAGE
   DESCRIPTION:   Performs a single write for the functional station.  This
                  routine ALTRET's if the station becomes disconnected or if
                  his task has been aborted.
*/
 
%EJECT ;
SINGLE_WRITE : PROC ( MSGFILE ) ALTRET ;
 
DCL      BUF_              VECTOR ;
DCL      MSGFILE           BIT ( 1 ) ;
 
   CALL CHECK_NWIO ;
   DO WHILE STATUS.FUNCTION.SUSPENDED# AND STATUS.FUNCTION.CONNECTED# ;
      CALL M$CHECK ( FPT_CHECK_NWIO )
            WHENALTRETURN DO ;
               CALL LARKETTE_RETURN_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                 STATUS.CONTROL.STATION# ) ;
               CALL LARKETTE_GIVE_UP ( DATA_SEG_ ) ;
            END ;
      CALL CHECK_NWIO ;
   END ;
   IF NOT STATUS.FUNCTION.CONNECTED# THEN DO ;
      GOTO ALT ;
   END ;
   STATUS.FUNCTION.WRITES# = STATUS.FUNCTION.WRITES# + 1 ;
   IF ( FUNCTION_BUFL = 0 ) THEN DO ;
      BUF_ = VECTOR ( NIL ) ;
   END ; ELSE DO ;
      BUF_ = VECTOR ( FUNCTION_BUF ) ;
   END ;
   CALL LARKETTE_WRITE_MESSAGE_ERR_RET ( VECTOR ( FUNCTION.WRITE_V ),
                                         VECTOR ( FUNCTION.WRITE_STATION ),
                                         BUF_,
                                         '        ',
                                         VLPERRCODE )
         WHENALTRETURN DO ;
            STATUS.FUNCTION.ERRCODE = VLPERRCODE ;
            STATUS.FUNCTION.WRITE_ERRS# = STATUS.FUNCTION.WRITE_ERRS# + 1 ;
            IF FUNCTION.WRITE.ERR_ABORT# THEN DO ;
               STATUS.CONTROL.ABORTED# = %YES# ;
               GOTO ALT ;
            END ;
         END ;
 
   RETURN ;
 
   ALT: ;
      ALTRETURN ;
 
END SINGLE_WRITE ;
 
END LARKETTE ;
