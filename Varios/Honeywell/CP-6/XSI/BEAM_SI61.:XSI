/*M* BEAM.X main program */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DMR,PLM=5,IND=5,CTI=5,SDI=5,MCL=10,CSI=0,ECI=0 */
BEAM: PROC MAIN NOAUTO;
/* ********************************************************************\
*                                                                      *
*   BEAM transports files between CP-6 systems.  Destination wsn       *
*   definitions must have JE as a device defined, and output sent      *
*   to JE@wsn must enter the input symbiont to be run as a job.        *
*                                                                      *
*   Command syntax:                                                    *
*                                                                      *
*       !BEAM name[.[acct][.pass]][ how name[.[acct][.pass]]] @wsn     *
*                                                                      *
*   "name", "acct", and "pass" have their usual meanings.  "how" is    *
*   one of "TO", "ON", "OVER", or "INTO".  "wsn", which is required,   *
*   represents the workstation name of the destination.  Note that     *
*   "@" in front of "wsn" must be preceeded by a space.                *
*                                                                      *
*   Rules:                                                             *
*                                                                      *
*   1.  The user must be authorized as a logon account at the          *
*       destination.  This avoids security conflicts.                  *
*   2.  If "how" is omitted, "TO" is assumed.                          *
*   3.  If the destination fid is omitted, the source name is used.    *
*   4.  The user must have FMSEC or write access to create or          *
*       update a file in the destination account if it is different    *
*       from the source account.                                       *
*   5.  All disk file types and most tape file types may be            *
*       BEAMed, regardless of their contents.                          *
*                                                                      *
*   For large files, transport via tape is faster and more reliable,   *
*   since a file of 1,000 granules would take 40 minutes or more to    *
*   transmit at 19.2kb.                                                *
*                                                                      *
\******************************************************************** */
%EJECT;
/* ********************************************************************\
*                                                                      *
*   %INCLUDEs                                                          *
*                                                                      *
\******************************************************************** */
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE XU_TRANS;                      /* Contains XLATE table macros.       */
%EQU BAUDRATE=19200;     /* Set BAUDRATE to speed of transmission in bits     */
 
/* ********************************************************************\
*                                                                      *
*   FPTS                                                               *
*                                                                      *
\******************************************************************** */
 
%FPT_FID(FPTN=FID_INP,
         ACCT=ACCT_INP,
         ASN=OPEN_INP.V.ASN#,
         NAME=NAME_INP,
         PASS=PASS_INP,
         RES=OPEN_INP.V.RES#,
         RESULTS=RESULTS_INP,
         TEXTFID=INPFID,
         SN=SN_INP);
 
%FPT_FID(FPTN=FID_OUT,
         ACCT=ACCT_OUT,
         ASN=ASN_OUT,
         NAME=NAME_OUT,
         PASS=PASS_OUT,
         RES=RES_OUT,
         RESULTS=RESULTS_OUT,
         TEXTFID=OUTFID,
         SN=SN_OUT);
 
%VLR_FID(FPTN=RESULTS_INP);
 
%VLR_FID(FPTN=RESULTS_OUT);
 
%FPT_OPEN(FPTN=OPEN_INP,
          NAME=NAME_INP,
          PASS=PASS_INP,
          SN=SN_INP,
          FPARAM=FPARAMT,
          ACCT=ACCT_INP,
          DCB=F$INP,
          SCRUB=YES,
          FUN=IN,
          ACS=SEQUEN);
 
%FPT_OPEN(FPTN=OPEN_OUT,
          DCB=F$OUT,
          SCRUB=YES,
          FUN=CREATE,
          WSN=WHERE,
          ASN=DEVICE,
          RES="'JE  '");
 
%FPT_OPEN(FPTN=OPEN_DO,
          DCB=M$DO,
          FUN=CREATE);
 
%FPT_OPEN(FPTN=OPEN_LO,
          DCB=M$LO,
          FUN=CREATE);
 
%FPT_WRITE(FPTN=WRITE_OUT,
           DCB=F$OUT,
           BUF=SOBUF);
 
%FPT_WRITE(FPTN=WRITE_LO,
           DCB=M$LO,
           BUF=SOBUF);
 
%FPT_READ(FPTN=READ_INP,
          DCB=F$INP,
          BUF=INBUF);
 
%FPT_READ(FPTN=READ_ME,
          DCB=M$ME,
          BUF=SOBUF);
 
%FPT_CLOSE(FPTN=CLOSE_INP,
           DCB=F$INP,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_OUT,
           DCB=F$OUT,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_DO,
           DCB=M$DO,
           DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSE_LO,
           DCB=M$LO,
           DISP=SAVE);
 
%FPT_ERRMSG(FPTN=SYS_ERR,
            BUF=SIBUF,
            CODE=ERRCODE,
            OUTDCB1=M$DO,
            SUBFN=YES,
            SUBAC=YES,
            SUBDC=NO,
            SUBSN=NO,
            RESULTS=VLR_ERRMSG,
            SUBMESS=YES);
 
%FPT_ERRMSG(FPTN=PRG_ERR,
            BUF=SIBUF,
            CODE=ERRCODE,
            FILENAME=WHATNAME,
            FILEACCT=WHATACCT,
            OUTDCB1=M$DO,
            INCLCODE=NO,
            SUBFN=NO,
            SUBAC=NO,
            SUBSN=NO,
            SUBDC=NO,
            RESULTS=VLR_ERRMSG,
            SUBMESS=YES);
 
%VLR_ERRMSG;
 
%VLP_NAME(FPTN=WHATNAME,
          LEN=31,
          NAME='                               ');
 
%VLP_ACCT(FPTN=WHATACCT,
          ACCT="':SYS    '");
 
%FPT_CORRES(FPTN=LOEQDO,
            DCB1=M$DO,
            DCB2=M$LO);
 
%FPT_TIME(DEST=EXT,
          SOURCE=UTS,
          TIME=TIMEBUF,
          TSTAMP=SECONDS);
 
%FPT_TRMCTL(FPTN=ECHO_OFF,
            TRMCTL=VLP_OFF);
 
%VLP_TRMCTL(FPTN=VLP_OFF,
            DISPINPUT=NO);
 
%FPT_TRMCTL(FPTN=ECHO_ON,
            TRMCTL=VLP_ON);
 
%VLP_TRMCTL(FPTN=VLP_ON,
            DISPINPUT=YES);
 
%F$DCB(DCBN=DUMMY);
 
%B$TCB;
 
%B$EXCFR;
 
%B$ALT;
 
 
%XU_LC2UC(TBLN=TBL_LC2UC,
          STCLASS=CONSTANT);
 
/* ********************************************************************\
*                                                                      *
*   DCBs                                                               *
*                                                                      *
\******************************************************************** */
 
DCL F$INP                          DCB;
DCL F$OUT                          DCB;
DCL M$LO                           DCB;
DCL M$DO                           DCB;
DCL M$ME                           DCB;
DCL M$LM                           DCB;
 
/* ********************************************************************\
*                                                                      *
*   Working Storage.                                                   *
*                                                                      *
\******************************************************************** */
 
DCL ALT_OUT                        BIT(72);
DCL B$JIT$ SYMREF                  PTR;
DCL B$TCB$ SYMREF                  PTR;
 
DCL FPARAMT STATIC                 CHAR(4096);
DCL SIBUF STATIC                   CHAR(256);
DCL SOBUF STATIC                   CHAR(80);
DCL INPFID STATIC                  CHAR(64);
DCL OUTFID STATIC                  CHAR(64);
DCL SN_INP STATIC                  CHAR(52);
DCL SN_OUT STATIC                  CHAR(52);
DCL NAME_INP STATIC                CHAR(32);
DCL NAME_OUT STATIC                CHAR(32);
DCL SYSID STATIC                   CHAR(12);
DCL TIMEBUF STATIC                 CHAR(11);
DCL USERACCN                       CHAR(8);
DCL USERNAME                       CHAR(12);
DCL USERPASS STATIC                CHAR(9);
DCL PASS_INP STATIC                CHAR(8);
DCL PASS_OUT STATIC                CHAR(8);
DCL ACCT_INP STATIC                CHAR(8);
DCL ACCT_OUT STATIC                CHAR(8);
DCL WHERE STATIC                   CHAR(8);
DCL RES_OUT STATIC                 CHAR(4);
DCL WORK                           CHAR(4);
DCL HOW                            CHAR(4);
DCL RANREL STATIC                  CHAR(4);
 
DCL ARS                            SBIN;
DCL I                              SBIN;
DCL J                              SBIN;
DCL OUTPTR                         SBIN;
DCL INPPTR                         SBIN;
DCL INPLIM                         SBIN;
DCL RECCNT                         SBIN;
DCL SECONDS STATIC                 SBIN;
DCL FILEORG                        SBIN;
DCL BINMODE                        SBIN;
DCL ERRCODE STATIC                 SBIN;
DCL SYSCODE REDEF ERRCODE          BIT(36);
 
DCL ASN_OUT STATIC                 UBIN(9);
DCL DVBYTE                         BIT(9);
DCL CHBYTE REDEF DVBYTE            CHAR(1);
 
DCL 1 FM$FIT BASED ALIGNED,
         2 CODES(0:31),
              3 CODE               UBIN(5) UNAL,
              3 *                  BIT(1) UNAL,
              3 NAW                UBIN(10) UNAL,
              3 NDW                UBIN(10) UNAL,
              3 ITEMX              UBIN(10) UNAL;
 
DCL 1 CODE03 BASED ALIGNED,
         2 ORG                     UBIN(9) UNAL,
         2 UGRANS                  UBIN(27) UNAL,
         2 DESC,
              3 DELF               BIT(1),
              3 NOLIST             BIT(1),
              3 BUF                BIT(1),
              3 TPB                BIT(1),
              3 BAD                BIT(1),
              3 *                  BIT(4),
              3 BUPM               BIT(1),
              3 NBUF               BIT(1),
              3 QS                 BIT(1),
              3 *                  BIT(6),
         2 TYPE                    CHAR(2) UNAL,
         2 NRECS                   SBIN,
         2 RCSZ                    UBIN(9) UNAL,
         2 NGAVAL                  UBIN(27) UNAL,
         2 COMP                    BIT(1),
         2 *                       BIT(8) UNAL,
         2 LDA                     UBIN(27) UNAL,
         2 XTNSIZE                 UBIN(18) UNAL,
         2 RECL                    UBIN HALF UNAL,
         2 NSTAMP                  UBIN;
 
DCL 1 INBUF STATIC,
         2 *                       CHAR(8192),
         2 *                       CHAR(8192),
         2 *                       CHAR(8192),
         2 *                       CHAR(8192);
 
DCL 1 KEYBUF STATIC,
         2 L UNAL                  UBIN(9),
         2 C UNAL                  CHAR(255);
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Fetch and decode command.                                          *
*                                                                      *
\******************************************************************** */
 
     WHATACCT.ACCT#=DCBADDR(DCBNUM(M$LM))->DUMMY.ACCT#;
     IF WHATACCT.ACCT#<='        ' THEN
          WHATACCT.ACCT#=':SYS    ';
     WHATNAME=DCBADDR(DCBNUM(M$LM))->DUMMY.NAME#;
     ERRCODE=0;
     CALL M$OPEN(OPEN_LO);
     IF NOT DCBADDR(DCBNUM(M$DO))->DUMMY.FCD# THEN
          CALL M$OPEN(OPEN_DO);
     CALL M$CORRES(LOEQDO) ALTRET(LOISDO);
     SYS_ERR.V.OUTDCB2#=DCBNUM(M$LO);
     PRG_ERR.V.OUTDCB2#=DCBNUM(M$LO);
 
LOISDO:
     ARS=B$JIT$->B$JIT.CCARS;
     SIBUF=SUBSTR(B$JIT$->B$JIT.CCBUF,0,ARS);
     CALL INDEX1(I,' ',SIBUF,1) ALTRET(ERR_NIF);
     DO WHILE(I<ARS AND SUBSTR(SIBUF,I,1)=' ');
          I=I+1;
        END;
     IF I>=ARS THEN
          GOTO ERR_NIF;
     CALL INDEX1(J,' ',SIBUF,I) ALTRET(ERR_NIF);
     INPFID=SUBSTR(SIBUF,I,J-I);
     OUTFID=INPFID;
     HOW=' TO ';
     I=J;
     DO WHILE(I<ARS AND SUBSTR(SIBUF,I,1)=' ');
          I=I+1;
        END;
     IF I>=ARS THEN
          IF INPFID='HELP' OR INPFID='help' THEN
               GOTO ERR_HLP;
          ELSE
               GOTO ERR_NWS;
     CALL INDEX1(J,' ',SIBUF,I) ALTRET(ERR_NWS);
     IF SUBSTR(SIBUF,I,1)='@' THEN
          GOTO GOTWSN;
     HOW = SUBSTR(SIBUF,I,J-I);
     CALL XLATE(HOW,TBL_LC2UC,HOW); /* Translate TO/OVER/INTO/ON to uppercase. */
     IF HOW ~= 'OVER' AND HOW ~= 'INTO' AND HOW ~= 'TO' AND HOW ~= 'ON' THEN
          GOTO ERR_HOW;
     I=J;
     DO WHILE(I<ARS AND SUBSTR(SIBUF,I,1)=' ');
          I=I+1;
        END;
     IF I>=ARS THEN
          GOTO ERR_NWS;
     CALL INDEX1(J,' ',SIBUF,I) ALTRET(ERR_NWS);
     IF SUBSTR(SIBUF,I,1)='@' THEN
          GOTO GOTWSN;
     OUTFID=SUBSTR(SIBUF,I,J-I);
     I=J;
     DO WHILE(I<ARS AND SUBSTR(SIBUF,I,1)=' ');
          I=I+1;
        END;
     IF I>=ARS THEN
          GOTO ERR_NWS;
     CALL INDEX1(J,' ',SIBUF,I) ALTRET(ERR_NWS);
     IF SUBSTR(SIBUF,I,1)~='@' THEN
          GOTO ERR_NWS;
 
GOTWSN:
     I=I+1;
     IF I>=J THEN
          GOTO ERR_NWS;
     WHERE=SUBSTR(SIBUF,I,J-I);
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Decode FIDs and open files...and away we go!                       *
*                                                                      *
\******************************************************************** */
 
     CALL M$FID(FID_INP) ALTRET(ERR_BIF);
     CALL M$FID(FID_OUT) ALTRET(ERR_BOF);
     CALL M$OPEN(OPEN_INP) ALTRET(ERR_INP);
     CALL M$OPEN(OPEN_OUT) ALTRET(ERR_OUT);
     REMEMBER ERR_OUT IN ALT_OUT;
     RECCNT=3;
     CALL INDEX1(I,'.',INPFID,0);
     CALL CONCAT(SOBUF,'..BEAMing ',SUBSTR(INPFID,0,I));
     CALL M$WRITE(WRITE_LO);
     DO J=1 TO ADDR(FPARAMT)->FM$FIT.CODES.CODE(0);
          IF ADDR(FPARAMT)->FM$FIT.CODES.CODE(J)=3 THEN
               GOTO GOT_CD3;
        END;
     GOTO ERR_FIT;
 
GOT_CD3:
     FILEORG=PINCRW(ADDR(FPARAMT),ADDR(FPARAMT)->FM$FIT.CODES.ITEMX(J))
          ->CODE03.ORG;
     SECONDS=4915200/%BAUDRATE*PINCRW(ADDR(FPARAMT),ADDR(FPARAMT)->
          FM$FIT.CODES.ITEMX(J))->CODE03.UGRANS;
     IF SECONDS>180000 /* .5 HOURS */ THEN
          GOTO ERR_WTB;
     IF B$JIT$->B$JIT.MODE=%M_INT# AND SECONDS>90000 /* .25 HOURS */ THEN DO;
          SOBUF='Hmmm...I estimate this file may take >15 minutes to BEAM.';
          CALL M$WRITE(WRITE_LO);
          IF NOT (B$JIT.CPFLAGS1 & %CP_CFREAD#)
          THEN
          DO;
 
ASK_AGAIN:
               SOBUF='Are you sure you want to do this?';
               CALL M$WRITE(WRITE_LO);
               SOBUF=' ';
               CALL M$READ(READ_ME)
               WHENALTRETURN DO;
                    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$EOF
                    THEN
                         GOTO ASK_AGAIN;
                    SOBUF='Y';
                  END;
               IF SOBUF='N' OR SOBUF='NO' OR SOBUF='no' OR SOBUF='n' THEN
                    GOTO ABORTIT;
               IF SOBUF~='Y' AND SOBUF~='YES' AND SOBUF~='y' AND SOBUF~='yes' THEN
                    GOTO ASK_AGAIN;
             END;
        END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Write boilerplate to output "file", then copy FPARAM table.        *
*                                                                      *
\******************************************************************** */
 
GET_NAME_ACCT:
     CALL CONCAT(SOBUF,'Enter account,name to run under @',WHERE,
          ' or CR for JIT account,name.');
     CALL M$WRITE(WRITE_LO);
     SOBUF=' ';
     CALL M$READ(READ_ME);
     IF SOBUF=' ' THEN DO;
          USERACCN=B$JIT$->B$JIT.ACCN;
          USERNAME=B$JIT$->B$JIT.UNAME;
        END;
     ELSE DO;
          IF DCBADDR(DCBNUM(M$ME))->DUMMY.ARS#<3 OR DCBADDR(DCBNUM(M$ME))->
               DUMMY.ARS#>21 THEN
               GOTO GET_NAME_ACCT;
          CALL INDEX1(I,',',SOBUF,0) ALTRET(GET_NAME_ACCT);
          IF I<1 OR I>8 THEN
               GOTO GET_NAME_ACCT;
          USERACCN=SUBSTR(SOBUF,0,I);
          USERNAME=SUBSTR(SOBUF,I+1,12);
        END;
 
GET_PASS:
     IF B$JIT$->B$JIT.MODE=%M_INT# THEN DO;
          CALL CONCAT(SOBUF,'Please enter your password @',WHERE,' (echo is off)');
          CALL M$WRITE(WRITE_LO);
          CALL M$STRMCTL(ECHO_OFF);
        END;
     SOBUF=' ';
     CALL M$READ(READ_ME);
     IF B$JIT$->B$JIT.MODE=%M_INT# AND DCBADDR(DCBNUM(M$ME))->DUMMY.ARS#>8 THEN
          GOTO GET_PASS;
     IF B$JIT$->B$JIT.MODE=%M_INT# THEN
          CALL M$STRMCTL(ECHO_ON);
     IF SOBUF=' ' THEN
          USERPASS=' ';
     ELSE
          CALL CONCAT(USERPASS,',',SUBSTR(SOBUF,0,8));
     CALL CONCAT(SOBUF,'!JOB ',USERACCN);
     CALL INDEX1(I,' ',SOBUF,5);
     CALL INSERT(SOBUF,I,,',',USERNAME);
     CALL INDEX1(I,' ',SOBUF,I);
     CALL INSERT(SOBUF,I,,USERPASS);
     CALL INDEX1(I,' ',SOBUF,I);
     CALL INSERT(SOBUF,I,,' RERUN                       "');
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     IF RESULTS_OUT.ACCT AND ACCT_OUT ~= ' ' THEN
          USERACCN=ACCT_OUT;
     SECONDS=%BAUDRATE*SECONDS/36000+1500; /*WAS 70200*/
     CALL M$TIME(FPT_TIME);
     CALL CONCAT(SOBUF,'!RESOURCE MEM=16,NHPSN,TIME=',SUBSTR(TIMEBUF,3,5),
          ',ACC(',USERACCN,')');
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     CALL CONCAT(SOBUF,'!MAEB.X  CR ',HOW,' ',OUTFID);
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     SOBUF='F';
     OUTPTR=1;
     INPLIM=ADDR(FPARAMT)->FM$FIT.CODES.NAW(0)*4;
     CALL REFORM(FPARAMT,INPLIM,'@') ALTRET(ERR_INT);
     IF OUTPTR>1 THEN
          CALL STUFF;
     SOBUF='D';
     OUTPTR=1;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   The type of processing called for depends on the file's ORG.       *
*   CONSEC, UR, INDEXED, and TERMINAL files need only be copied        *
*   to F$OUT with variable-length records; maximum input record        *
*   size is 32K.  KEYED files are also variable-length records         *
*   of 32K or less, but the key of each record must be fetched and     *
*   transmitted.  A RANDOM file has fixed-length records of 4092       *
*   bytes, but has "keys", too.  Finally, a RELATIVE file has          *
*   fixed-length records of CODE03.RECL bytes and keys.  All           *
*   other file organizations are illegal.                              *
*                                                                      *
\******************************************************************** */
 
     DO CASE(FILEORG);
 
     CASE(1,4,6,8) /* CONSEC, UR, INDEXED, TERMINAL */;
        ;
 
     CASE(2) /* KEYED */;
 
        READ_INP.V.KEYR#='1'B;
        READ_INP.KEY_=VECTOR(KEYBUF);
 
     CASE(3) /* RANDOM */;
 
        READ_INP.V.KEYR#='1'B;
        READ_INP.KEY_=VECTOR(RANREL);
        READ_INP.BUF_.BOUND=4091;
 
     CASE(5) /* RELATIVE */;
 
        READ_INP.V.KEYR#='1'B;
        READ_INP.KEY_=VECTOR(RANREL);
        READ_INP.BUF_.BOUND=PINCRW(ADDR(FPARAMT),ADDR(FPARAMT)->
             FM$FIT.CODES.ITEMX(J))->CODE03.RECL-1;
 
     CASE(7) /* IDS */;
 
        READ_INP.V.KEYR#='1'B;
        READ_INP.KEY_=VECTOR(RANREL);
        READ_INP.BUF_.BOUND=4095;
        READ_INP.V.FULL#='1'B;
 
     CASE(ELSE) /* All other codes are illegal! */;
 
        GOTO ERR_UFT;
 
     END;
 
READ_DATA:
     DO WHILE('1'B);
          CALL M$READ(READ_INP) ALTRET(ERR_INP);
          ARS=DCBADDR(DCBNUM(F$INP))->DUMMY.ARS#;
          IF FILEORG=2 THEN DO;
               INPLIM=KEYBUF.L;
               CALL REFORM(SUBSTR(KEYBUF.C,0,INPLIM),INPLIM,' ')
                    ALTRET(ERR_INT);
             END;
          ELSE IF FILEORG=3 OR FILEORG=5 OR FILEORG=7 THEN DO;
                    INPLIM=4;
                    CALL REFORM(RANREL,INPLIM,' ') ALTRET (ERR_INT);
                  END;
               ELSE IF FILEORG=4 THEN DO;
                         DVBYTE=DCBADDR(DCBNUM(F$INP))->DUMMY.DVBYTE;
                         CALL REFORM(CHBYTE,1,' ');
                       END;
          CALL REFORM(INBUF,ARS,'@') ALTRET(ERR_INT);
        END;
 
EOFSI:
     IF OUTPTR>1 THEN
          CALL STUFF;
     SOBUF='!IF STEPCC>0 THEN GOTO DONE';
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     SOBUF='!SET M$LL NO';
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     SOBUF='!LDEV LP01,ERASE,REM';
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     SOBUF='!DONE: OFF NONE';
     CALL M$WRITE(WRITE_OUT) ALTRET(ERR_OUT);
     CALL M$CLOSE(CLOSE_OUT);
     CALL M$CLOSE(CLOSE_INP);
     SECONDS=(672000/%BAUDRATE*RECCNT+9)/10;
     CALL BINCHAR(WORK,RECCNT);
     I=0;
     DO WHILE(SUBSTR(WORK,I,1)='0');
          I=I+1;
        END;
     CALL CONCAT(SOBUF,SUBSTR(WORK,I,4-I),' records');
     IF RECCNT=1 THEN
          J=8;
     ELSE
          J=12-I;
     CALL M$TIME(FPT_TIME);
     I=0;
     DO WHILE(SUBSTR(TIMEBUF,I,1)='0' OR SUBSTR(TIMEBUF,I,1)=':');
          I=I+1;
        END;
     CALL INSERT(SOBUF,J,,' in transmission; approximate time is ',
          SUBSTR(TIMEBUF,I,11-I));
     CALL M$WRITE(WRITE_LO);
     SYSID=SUBSTR(DCBADDR(DCBNUM(F$OUT))->DUMMY.NAME#.C,3,12);
     I=0;
     DO WHILE(SUBSTR(SYSID,I,1)='0');
          I=I+1;
        END;
     J=6;
     DO WHILE(SUBSTR(SYSID,J,1)='0' AND J<11);
          J=J+1;
        END;
     CALL CONCAT(SOBUF,'Your SYSID (on this machine) is ',SUBSTR(SYSID,I,6-I),
          '-',SUBSTR(SYSID,J,12-J),'.');
     CALL M$WRITE(WRITE_LO);
     CALL M$CLOSE(CLOSE_LO);
     CALL M$CLOSE(CLOSE_DO);
     RETURN;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   REFORM reformats BFR of length LEN into output format, supplying   *
*   control bytes as required.  CCH is the base control byte, and is   *
*   used to indicate whether the record is data ('@' or greater) or    *
*   a key (less than '@').  Formats are as follows:                    *
*                                                                      *
*   Col Contents                                                       *
*   --- --------                                                       *
*     1 'F' if this is an FPARAM table; otherwise 'D'                  *
*     2 Number of significant data bytes in this record plus '040'O    *
*       (range is 1 to 78).                                            *
*   3-n Data and/or key bytes, each field is preceeded by a control    *
*       sequence of one to three bytes:                                *
*                                                                      *
*   Keys longer than 15 bytes (long keys):                             *
*                                                                      *
*        0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8                           *
*       +-----------------+-----------------+                          *
*       |0 0|0 1|1|0 0|Len|0 0|  Len+'40'O  |                          *
*       +-----------------+-----------------+                          *
*             ^  ^      ^            ^                                 *
*             |  |      |            +-Low order 6 bits of key length  *
*             |  |      +-High order 2 bits of key length              *
*             |  +-Indicates long key                                  *
*             +-Indicates key follows                                  *
*                                                                      *
*   Keys of length 1 to 15 bytes (short keys):                         *
*                                                                      *
*        0 1 2 3 4 5 6 7 8                                             *
*       +-----------------+                                            *
*       |0 0|0 1|0|  Len  |                                            *
*       +-----------------+                                            *
*             ^  ^    ^                                                *
*             |  |    +-Key length                                     *
*             |  +-Indicates short key                                 *
*             +-Indicates key follows                                  *
*                                                                      *
*   Data longer than 512 bytes (long data):                            *
*                                                                      *
*        0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8         *
*       +-----------------+-----------------+-----------------+        *
*       |0 0|1|b|0 0| Len |0 0|  Len+'40'O  |0 0|  Len+'40'O  |        *
*       +-----------------+-----------------+-----------------+        *
*            ^ ^  ^    ^             ^                 ^               *
*            | |  |    |             |                 +-Low order 6   *
*            | |  |    |             |                   bits of data  *
*            | |  |    |             |                   length        *
*            | |  |    |             +-Middle 6 bits of data length    *
*            | |  |    +-High order 3 bits of data length              *
*            | |  +-Indicates long data                                *
*            | +-If set, data are encoded, otherwise clear             *
*            +-Indicates data follows                                  *
*                                                                      *
*   Data of length 16 to 512 bytes (medium data):                      *
*                                                                      *
*        0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8                           *
*       +-----------------+-----------------+                          *
*       |0 0|1|b|0 1| Len |0 0|  Len+'40'O  |                          *
*       +-----------------+-----------------+                          *
*            ^ ^  ^    ^             ^                                 *
*            | |  |    |             +-Low order 6 bits of data length *
*            | |  |    +-High order 3 bits of data length              *
*            | |  +-Indicates medium data                              *
*            | +-If set, data are encoded, otherwise clear             *
*            +-Indicates data follows                                  *
*                                                                      *
*   Data of length 1 to 15 bytes (short data):                         *
*                                                                      *
*        0 1 2 3 4 5 6 7 8                                             *
*       +-----------------+                                            *
*       |0 0|1|b|1|  Len  |                                            *
*       +-----------------+                                            *
*            ^ ^ ^    ^                                                *
*            | | |    +-Data length                                    *
*            | | +-Indicates short data                                *
*            | +-If set, data are encoded, otherwise clear             *
*            +-Indicates data follows                                  *
*                                                                      *
*   Note:  The length fields of all data control words represent       *
*   the length of the data minus one; zero length records are          *
*   indicated by the special code of '137'O (underscore).              *
*                                                                      *
*   Keys are always encoded.  If the "b" bit is set, the data that     *
*   follows are encoded, otherwise, the data are transmitted "as is".  *
*   "as is" data contains only printable 95-character set ASCII        *
*   graphics (range '040'O to '176'O).  The format for encoded data    *
*   is as follows:                                                     *
*                                                                      *
*        0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8         *
*       +-----------------+-----------------+-----------------+        *
*       |0 0| Data+'40'O  |0 0| Data+'40'O  |0 0| Data+'40'O  |        *
*       +-----------------+-----------------+-----------------+        *
*                  ^                 ^                 ^               *
*                  |                 |                 +-Low order 6   *
*                  |                 |                   bits of 2nd   *
*                  |                 |                   byte          *
*                  |                 +-Low order 3 bits of 1st byte    *
*                  |                   shifted left 3 bits plus high   *
*                  |                   order 3 bits of 2nd byte        *
*                  +-High order 6 bits of 1st byte                     *
*                                                                      *
*   If the record has an odd number of bytes, the last byte contains   *
*   zeros.                                                             *
*                                                                      *
\******************************************************************** */
 
REFORM: PROC(BFR,LEN,CCH) ALTRET;
DCL LEN                            SBIN;
DCL BFR                            CHAR(LEN);
DCL CCH                            CHAR(1);
DCL I                              SBIN;
DCL J                              SBIN;
DCL 1 BADCHARS CONSTANT ALIGNED,
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('000'O*32),
         2 *(0:31) BIT(9) UNAL INIT('000'O*32),
         2 *(0:31) BIT(9) UNAL INIT('000'O*31,'111'O),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32),
         2 *(0:31) BIT(9) UNAL INIT('111'O*32);
 
     INPPTR=0;
     IF CCH<'@' THEN DO;
          IF LEN<1 OR LEN>255 THEN
               ALTRETURN;
          IF LEN<16 THEN DO;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(LEN+32));
             END;
          ELSE DO;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(LEN/64+48));
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(LEN,64)+32));
             END;
          BINMODE=32;
        END;
     ELSE DO;
          IF LEN<0 OR LEN>32768 THEN
               ALTRETURN;
          IF LEN=0 THEN DO;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,'_');
             END;
          ELSE DO;
               CALL SEARCH(I,J,BADCHARS,SUBSTR(BFR,0,LEN));
               IF J>0 THEN
                    BINMODE=32;
               ELSE
                    BINMODE=0;
               J=LEN-1;
               IF LEN<16 THEN DO;
                    OUTPTR=OUTPTR+1;
                    IF OUTPTR>79 THEN
                         CALL STUFF;
                    CALL INSERT(SOBUF,OUTPTR,1,BINASC(BINMODE+J+80));
                  END;
               ELSE IF LEN<513 THEN DO;
                         OUTPTR=OUTPTR+1;
                         IF OUTPTR>79 THEN
                              CALL STUFF;
                         CALL INSERT(SOBUF,OUTPTR,1,BINASC(BINMODE+J/64+72));
                         OUTPTR=OUTPTR+1;
                         IF OUTPTR>79 THEN
                              CALL STUFF;
                         CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(J,64)+32));
                       END;
                    ELSE DO;
                         OUTPTR=OUTPTR+1;
                         IF OUTPTR>79 THEN
                              CALL STUFF;
                         CALL INSERT(SOBUF,OUTPTR,1,BINASC(BINMODE+J/4096+64));
                         OUTPTR=OUTPTR+1;
                         IF OUTPTR>79 THEN
                              CALL STUFF;
                         CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(J,4096)/64+32));
                         OUTPTR=OUTPTR+1;
                         IF OUTPTR>79 THEN
                              CALL STUFF;
                         CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(J,64)+32));
                       END;
             END;
        END;
     IF BINMODE>0 THEN DO;
          J=LEN/2;
          DO I=1 TO J;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(ASCBIN(SUBSTR(BFR,INPPTR,1))/8
                    +32));
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(ASCBIN(SUBSTR(BFR,INPPTR,1)),
                    8)*8+32+ASCBIN(SUBSTR(BFR,INPPTR+1,1))/64));
               INPPTR=INPPTR+1;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(ASCBIN(SUBSTR(BFR,INPPTR,
                    1)),64)+32));
               INPPTR=INPPTR+1;
             END;
          IF 2*J~=LEN THEN DO;
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(ASCBIN(SUBSTR(BFR,INPPTR,
                    1))/8+32));
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(MOD(ASCBIN(SUBSTR(BFR,INPPTR,
                    1)),8)*8+32));
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               CALL INSERT(SOBUF,OUTPTR,1,BINASC(32));
               INPPTR=INPPTR+1;
             END;
        END;
     ELSE DO;
          I=0;
          DO WHILE(I<LEN);
               OUTPTR=OUTPTR+1;
               IF OUTPTR>79 THEN
                    CALL STUFF;
               IF LEN-I<=80-OUTPTR THEN DO;
                    J=LEN-I;
                    CALL INSERT(SOBUF,OUTPTR,J,SUBSTR(BFR,I,J));
                    OUTPTR=OUTPTR+J-1;
                    I=LEN;
                  END;
               ELSE DO;
                    J=80-OUTPTR;
                    CALL INSERT(SOBUF,OUTPTR,J,SUBSTR(BFR,I,J));
                    OUTPTR=79;
                    I=I+J;
                  END;
             END;
          INPPTR=LEN;
        END;
     RETURN;
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   STUFF writes out SOBUF, clears it (except column 1) and resets     *
*   OUTPTR to point to column 2, or the next column available for      *
*   data.  If OUTPTR exceeds 79 upon entry, it is set to 79.           *
*   STUFF also computes the record length byte (column 1).  If an      *
*   error occurs on the write we unwind to the output error handler.   *
*                                                                      *
\******************************************************************** */
 
STUFF: PROC;
     IF OUTPTR>79 THEN
          OUTPTR=79;
     CALL INSERT(SOBUF,1,1,BINASC(OUTPTR+31));
     CALL M$WRITE(WRITE_OUT) ALTRET(BAD_OUT);
     CALL INSERT(SOBUF,1,79,' ');
     OUTPTR=2;
     RECCNT=RECCNT+1;
     RETURN;
 
BAD_OUT:
     UNWIND TO ALT_OUT;
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Error handlers.                                                    *
*                                                                      *
\******************************************************************** */
 
ERR_WTB:
          /*E*   ERROR:   -10-4
               MESSAGE:  On second thought...this file is too big to BEAM!
                         Use a tape to transport a file this big!
          */
     ERRCODE=ERRCODE+1;
 
ERR_NIF:
          /*E*   ERROR:    -9-4
               MESSAGE:  No input file named!
                         What do you want me to BEAM?
                         Type BEAM HELP for help information.
          */
     ERRCODE=ERRCODE+1;
 
ERR_NWS:
          /*E*   ERROR:    -8-4
               MESSAGE:  No workstation named!
                         You must say BEAM fid ... @workstation
          */
     ERRCODE=ERRCODE+1;
 
ERR_HOW:
          /*E*   ERROR:    -7-4
               MESSAGE:  "how" clause missing or misspelled.
                         Syntax is BEAM fid {ON|TO|OVER|INTO} ...
          */
     ERRCODE=ERRCODE+1;
 
ERR_BIF:
          /*E*   ERROR:    -6-4
               MESSAGE:  Input FID is illegal (sez M$FID).
                         Syntax is name[.[account][.password]]
          */
     ERRCODE=ERRCODE+1;
 
ERR_BOF:
          /*E*   ERROR:    -5-4
               MESSAGE:  Output FID is illegal (sez m$FID).
                         Syntax is name[.[account][.password]]
          */
     ERRCODE=ERRCODE+1;
 
ERR_INT:
          /*E*   ERROR:    -4-4
               MESSAGE:  This is an internal bug.  You should not see this.
                         Help me! Help me! Help me! Help me!
          */
     ERRCODE=ERRCODE+1;
 
ERR_FIT:
          /*E*   ERROR:    -3-4
               MESSAGE:  Huh? Your FIT does not have a CODE03 entry.
                         I cannot BEAM a file unless I know what kind it is.
          */
     ERRCODE=ERRCODE+1;
 
ERR_UFT:
          /*E*   ERROR:    -2-4
               MESSAGE:  Sorry, can't BEAM that kind of file.
                         I can't do tape-type files.
          */
     ERRCODE=ERRCODE+1;
 
ERR_HLP:
          /*E*   ERROR:    -1-4
               MESSAGE:  BEAM may be used to transport files from one CP-6
                         system to another, provided the proper workstation
                         definitions have been created.  To transmit a file
                         to workstation "REMOTE", the user types:
 
                         BEAM file @REMOTE
 
                         This is the simplest form.  The full command syntax
                         is:
 
                         BEAM fid1[ how fid2] @wsn
 
                         "fid1" and "fid2" are CP-6 file identifiers of the
                         form name[.[account][.password]].  "how" is one of
                         ON, TO, OVER, or INTO.  If "how" is specified, the
                         destination fid is required.  The workstation field
                         ("@wsn") must consist of a valid workstation name
                         preceeded by the remote designator "@" without an
                         intervening space, and it must be separated from
                         the text preceeding it by at least one space.
 
                         All disk file types are BEAMable; however,
                         since lengthy files may take an excessive amount
                         of time to transmit (a 1,000 granule file takes
                         about 45 minutes to BEAM at 19.2KB), the user is
                         cautioned against BEAMing without thinking.
 
                         The INTO adverb must be used with care, as it is
                         not valid with all file types.
 
                         Since BEAM builds a jobstream containing the file
                         to be transmitted, the user must be authorized to
                         run a job in his logon account at the destination.
                         If a different account is specified on the output
                         fid, the user must have FMSEC privilege or write
                         access to that account on the destination machine.
 
                         BEAM cannot detect if the file has been sent or if
                         the jobstream has been successfully run at the
                         destination.  The user at the destination machine
                         must check file creation/modification dates and/or
                         the job printout for error messages.
 
                         I will now exit to IBEX.  Enter your command again
                         to BEAM a file.
          */
     ERRCODE=ERRCODE+1;
 
     ERRCODE=ERRCODE*8+4;
     CALL M$ERRMSG(PRG_ERR);
 
ABORTIT:
     IF DCBADDR(DCBNUM(F$INP))->DUMMY.FCD# THEN
          CALL M$CLOSE(CLOSE_INP);
     IF DCBADDR(DCBNUM(F$OUT))->DUMMY.FCD# THEN DO;
          CLOSE_OUT.V.DISP#=1;
          CALL M$CLOSE(CLOSE_OUT);
        END;
     CALL M$CLOSE(CLOSE_LO);
     CALL M$CLOSE(CLOSE_DO);
     RETURN;
 
ERR_INP:                                /* Error on input file                */
     IF DCBADDR(DCBNUM(F$INP))->DUMMY.TYC.EOF# OR
          DCBADDR(DCBNUM(F$INP))->DUMMY.TYC.EOD# THEN
          GOTO EOFSI;
     SYS_ERR.V.DCB#=DCBNUM(F$INP);
     SYSCODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     IF SYSCODE='061511400112'O OR /* FMI-M00009-2 (Unwritten RAN granule) */
          SYSCODE='062427400112'O THEN  /* FTW-M00009-2 (Rec never written)   */
          GOTO READ_DATA;
     CALL M$ERRMSG(SYS_ERR);
     GOTO ABORTIT;
 
ERR_OUT:                                /* Error on output file               */
     SYS_ERR.V.DCB#=DCBNUM(F$OUT);
     SYSCODE=B$TCB$->B$TCB.ALT$->B$EXCFR.ERR;
     CALL M$ERRMSG(SYS_ERR);
     GOTO ABORTIT;
 
END;
