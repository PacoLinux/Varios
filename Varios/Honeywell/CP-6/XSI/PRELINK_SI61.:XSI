/*M* PRELINK - Combine multiple object units */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
PRELINK: PROC MAIN;
 
/*P*  NAME: PRELINK
      PURPOSE: PRELINK combines multiple object units into a single object
               unit, catenating the contents of similarly-flavored control
               sections and adjusting all affected linker directives as
               necessary.
*/
 
%INCLUDE B_ERRORS_C;
%INCLUDE B$OBJECT_C;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE RU_DATA_MANAGER_ENTRIES;
%INCLUDE NK_VFC_C;
%INCLUDE XUO$ENTRIES;
%INCLUDE PRELINK_C61;
 
%SUB BOOLEAN = "BIT (1)";
%SUB FOREVER="WHILE '1'B";
 
%SET LISTDIR = '0'B;
 
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$OU DCB;
 
DCL B$TCB$ PTR SYMREF READONLY;
%EJECT;
             /* Monitor service FPTs & data structures */
 
%B$ALT;
%B$TCB (STCLASS="BASED(B$TCB$)");
 
%F$DCB;
 
%FPT_OPEN  (FPTN=OPEN_SI,
            DCB=M$SI,
            FUN=IN,
            ACS=DIRECT);
 
%FPT_PRECORD  (FPTN=POSITION_SI,
               DCB=M$SI);
 
%FPT_READ  (FPTN=READ_SI,
            DCB=M$SI);
 
%FPT_CLOSE (FPTN=CLOSE_SI,
            DCB=M$SI);
 
%FPT_OPEN  (FPTN=OPEN_LO,
            DCB=M$LO,
            FUN=CREATE,
            DISP=NAMED);
 
%FPT_WRITE (FPTN=WRITE_LO,
            DCB=M$LO,
            BUF=LO_BUFFER,
            VFC=YES);
 
%FPT_CLOSE (FPTN=CLOSE_LO,
            DCB=M$LO,
            DISP=SAVE);
 
%EJECT;
/*            IDL-built data structures for PreLink's internal data         */
%OU (STCLASS=STATIC);
%PACKIT (STCLASS=STATIC);
%SPACE 1;
%P_NAME (STCLASS=STATIC);
%SPACE 1;
DCL 1 ASL_NAME,
      2 COUNT UBIN BYTE CALIGNED,
      2 TEXT CHAR (31);
%SPACE 1;
DCL 1 B_VERSION SYMREF READONLY,
      2 LEN UBIN BYTE CALIGNED,
      2 TEXT CHAR (B_VERSION.LEN);
%SPACE 1;
DCL 1 LIBRARY_NAME,
      2 COUNT UBIN BYTE CALIGNED,
      2 TEXT CHAR (31);
%SPACE 1;
DCL 1 LO_BUFFER STATIC,
      2 VFC CHAR (1),
      2 TEXT CHAR (140);
%SPACE 1;
DCL 1 VERSION_INFO STATIC,
      2 LETTER CHAR (1) INIT ('?'),
      2 NUMBER UBIN BYTE CALIGNED INIT (0);
%SPACE 1;
DCL LO_OFFSET UBIN WORD;
DCL LO_WIDTH UBIN WORD;
DCL M$LO$ PTR;
DCL M$OU$ PTR;
DCL M$SI$ PTR;
DCL NUMBER_OF_OUS_PROCESSED UBIN WORD;
DCL OU_IS_OPEN BOOLEAN STATIC INIT (%NO#);
DCL WORK_BUFFER (0:1023) UBIN WORD AUTO;
%EJECT;
        /*          Object-unit data structures, etc.            */
 
%B$RECORDSUBS;
%COMPILERIDSUBS;
%B$SECTIONSUBS;
%SUB_CST;
%SUB_LINKFLAGS;
%B$RELOCSUBS;
%SPACE 1;
%B$HEADKEY (STCLASS=STATIC);
%B$OUKEY (STCLASS=STATIC);
%B$PRGRELKEY (STCLASS=STATIC);
%B$OUHEAD (STCLASS=STATIC);
%B$DNAME (STCLASS="BASED(DNAME$)");
%B$SECTION (STCLASS="BASED(SECTION$)");
%B$EDEF (STCLASS="BASED(EDEF$)");
%B$EREF (STCLASS="BASED(EREF$)");
%B$SDEF (STCLASS="BASED(SDEF$)");
%B$SREF (STCLASS="BASED(SREF$)");
%B$SEGDEF (STCLASS="BASED(SEGDEF$)");
%B$SEGREF (STCLASS="BASED(SEGREF$)");
%B$RELOC1 (STCLASS="BASED(RELOC$)");
%B$RELOC2 (STCLASS="BASED(RELOC$)");
%SPACE 1;
DCL DNAME$ PTR;
DCL SECTION$ PTR;
DCL EDEF$ PTR;
DCL EREF$ PTR;
DCL SDEF$ PTR;
DCL SREF$ PTR;
DCL SEGDEF$ PTR;
DCL SEGREF$ PTR;
DCL PRGM$ PTR;
DCL RELOC$ PTR;
%EJECT;
   /*          References to miscellaneous external service routines       */
 
DCL ERROR_HANDLER ENTRY (2);
DCL GETMEM ENTRY (2);
DCL LOOKUP_COMPARER ENTRY (2) ALTRET;
DCL LOOKUP_HASHER ENTRY (3);
DCL MEMINIT ENTRY;
DCL NAME_COMPARER ENTRY (2) ALTRET;
DCL NAME_HASHER ENTRY (3);
DCL RELMEM ENTRY (1);
DCL SYMBOL_COMPARER ENTRY (2) ALTRET;
DCL SYMBOL_HASHER ENTRY (3);
%EJECT;
   CALL INITIALIZE;
   CALL PROCESS_OUS;
   CALL TERMINATE;
%EJECT;
INITIALIZE: PROC;
 
DCL I UBIN WORD;
 
   CALL MEMINIT;
   CALL RUI$INIT (ENTADDR(GETMEM), ENTADDR(RELMEM));
   CALL M$OPEN (OPEN_SI);
   CALL M$OPEN (OPEN_LO);
 
   M$LO$ = DCBADDR(DCBNUM(M$LO));
   M$OU$ = DCBADDR(DCBNUM(M$OU));
   M$SI$ = DCBADDR(DCBNUM(M$SI));
 
   LO_WIDTH = M$LO$ -> F$DCB.WIDTH#;
 
   LO_WIDTH = MINIMUM(LO_WIDTH, LENGTHC(LO_BUFFER.TEXT));
 
   IF LO_WIDTH < 40
     THEN
      LO_WIDTH = 72;
 
   IF B_VERSION.LEN = 0
     THEN
      LO_BUFFER.TEXT = 'PreLink here';
     ELSE
      CALL CONCAT (LO_BUFFER.TEXT, 'PreLink ', B_VERSION.TEXT, ' here');
 
   CALL INDEX (I, '  ', LO_BUFFER.TEXT);
 
   LO_BUFFER.VFC = %VFC_S1A;
   WRITE_LO.BUF_.BOUND = I;
 
   CALL M$WRITE (WRITE_LO);
 
   LO_OFFSET = 0;
 
   IF B_VERSION.LEN > 0
     THEN DO;
 
      VERSION_INFO.LETTER = SUBSTR (B_VERSION.TEXT, 0, 1);
 
      DO I = 1 TO B_VERSION.LEN - 1;
 
         IF SUBSTR(B_VERSION.TEXT, I, 1) < '0'
          OR SUBSTR(B_VERSION.TEXT, I, 1) > '9'
           THEN
            EXIT;
 
         VERSION_INFO.NUMBER = VERSION_INFO.NUMBER * 10 +
          ASCBIN(SUBSTR(B_VERSION.TEXT, I, 1)) - ASCBIN('0');
 
         END;
 
      END;
 
   PACKIT.SECTION_COUNT = 0;
   PACKIT.SEVERITY_LEVEL = 0;
 
   CALL ESTABLISH_NAME_SET (PACKIT.DEFINED_NAMES$);
   CALL ESTABLISH_NAME_SET (PACKIT.REFERENCED_NAMES$);
 
   CALL ESTABLISH_SYMBOL_SET (PACKIT.SYMREFS$);
   CALL ESTABLISH_SYMBOL_SET (PACKIT.ENTREFS$);
   CALL ESTABLISH_SYMBOL_SET (PACKIT.SEGDEFS$);
   CALL ESTABLISH_SYMBOL_SET (PACKIT.SEGREFS$);
 
   DO I = 0 TO SIZEW(PACKIT.SECTIONS$) - 1;
 
      PACKIT.SECTIONS$(I) = ADDR(NIL);
 
      END;
 
   DO I = 0 TO SIZEW(OU.SECTIONS$) - 1;
 
      OU.SECTIONS$(I) = ADDR(NIL);
 
      END;
 
   NUMBER_OF_OUS_PROCESSED = 0;
   OU.SECTION_COUNT = 0;
 
   CALL ESTABLISH_LOOKUP_TABLE (OU.DEFINED_NAMES);
   CALL ESTABLISH_LOOKUP_TABLE (OU.REFERENCED_NAMES);
   CALL ESTABLISH_LOOKUP_TABLE (OU.SYMREFS);
   CALL ESTABLISH_LOOKUP_TABLE (OU.ENTREFS);
   CALL ESTABLISH_LOOKUP_TABLE (OU.SEGDEFS);
   CALL ESTABLISH_LOOKUP_TABLE (OU.SEGREFS);
 
   RETURN;
 
END INITIALIZE;
%SPACE 2;
ESTABLISH_NAME_SET: PROC (SET$);
 
DCL SET$ PTR;
 
   CALL RUS$NEW_PTR_SET (SET$, 100, ENTADDR(NAME_HASHER),
    ENTADDR(NAME_COMPARER));
 
   RETURN;
 
END ESTABLISH_NAME_SET;
%SPACE 2;
ESTABLISH_SYMBOL_SET: PROC (SET$);
 
DCL SET$ PTR;
 
   CALL RUS$NEW_PTR_SET (SET$, 100, ENTADDR(SYMBOL_HASHER),
    ENTADDR(SYMBOL_COMPARER));
 
   RETURN;
 
END ESTABLISH_SYMBOL_SET;
%SPACE 2;
ESTABLISH_LOOKUP_TABLE: PROC (LOOKUP_TABLE);
 
%LOOKUP_TABLE (STCLASS=PARAM);
 
   CALL RUS$NEW_PTR_SET (LOOKUP_TABLE.ENTRIES$, 100,
    ENTADDR(LOOKUP_HASHER), ENTADDR(LOOKUP_COMPARER));
 
   RETURN;
 
END ESTABLISH_LOOKUP_TABLE;
%EJECT;
PROCESS_OUS: PROC;
 
   B$HEADKEY.KEYSIZ = 1;
   POSITION_SI.V.N# = 0;   /* set up to position to first OU head record */
 
LOOP_ON_OU: DO FOREVER;
 
      POSITION_SI.KEY_ = VECTOR (B$HEADKEY);
      POSITION_SI.V.KEYS# = %YES#;
      POSITION_SI.V.KEYR# = %NO#;
 
      CALL M$PRECORD (POSITION_SI) ALTRET (IGNORE_ALTRET_ON_POSITION);
 
IGNORE_ALTRET_ON_POSITION:
 
      READ_SI.BUF_ = VECTOR (B$OUHEAD);
      READ_SI.KEY_ = VECTOR (B$HEADKEY);
      READ_SI.V.KEYS# = %NO#;
      READ_SI.V.KEYR# = %YES#;
 
      CALL M$READ (READ_SI)
       WHENALTRETURN DO;
 
         EXIT LOOP_ON_OU;
 
         END;
 
      IF B$HEADKEY.HFLAG ~= ASCBIT('"')
        THEN
         EXIT LOOP_ON_OU;
 
      CALL PROCESS_THIS_OU;
 
      POSITION_SI.V.N# = 1;
 
      END LOOP_ON_OU;
 
   RETURN;
 
END PROCESS_OUS;
%EJECT;
PROCESS_THIS_OU: PROC;
 
DCL TAB_COLUMN SBIN WORD;
 
   IF LO_OFFSET = 0
     THEN
      TAB_COLUMN = 0;
     ELSE
      TAB_COLUMN = ((LO_OFFSET + 12) / 10) * 10;
 
   IF TAB_COLUMN + B$HEADKEY.KEYSIZ - 1 >= LO_WIDTH
     THEN DO;
 
      LO_BUFFER.VFC = %VFC_S1B;
      LO_OFFSET = 0;
      TAB_COLUMN = 0;
      LO_BUFFER.TEXT = B$HEADKEY.TEXT;
 
      END;
 
     ELSE DO;
 
      LO_BUFFER.VFC = %VFC_EXT;
      LO_BUFFER.TEXT = ' ';
      SUBSTR (LO_BUFFER.TEXT, TAB_COLUMN - LO_OFFSET) = B$HEADKEY.TEXT;
 
      END;
 
   WRITE_LO.BUF_.BOUND = B$HEADKEY.KEYSIZ + TAB_COLUMN - LO_OFFSET - 1;
 
   CALL M$WRITE (WRITE_LO);
 
   LO_OFFSET = LO_OFFSET + WRITE_LO.BUF_.BOUND + 1;
   NUMBER_OF_OUS_PROCESSED = NUMBER_OF_OUS_PROCESSED + 1;
 
   IF NOT OU_IS_OPEN
     THEN
      CALL OPEN_OBJECT_UNIT;
 
   PACKIT.SEVERITY_LEVEL = MAXIMUM (PACKIT.SEVERITY_LEVEL, B$OUHEAD.SEVLEV);
 
   CALL SWEEP_NAMES (%TYPDNAM, PACKIT.DEFINED_NAMES$,
    OU.DEFINED_NAMES, ENTADDR (XUO$DNAME));
 
   CALL SWEEP_NAMES (%TYPRNAM, PACKIT.REFERENCED_NAMES$,
    OU.REFERENCED_NAMES, ENTADDR(XUO$RNAME));
 
   CALL ALLOCATE_CONTROL_SECTIONS;
 
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPEDEF, OU.DEFINED_NAMES);
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPEREF, OU.REFERENCED_NAMES,
    PACKIT.ENTREFS$, OU.ENTREFS);
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPSDEF, OU.DEFINED_NAMES);
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPSREF, OU.REFERENCED_NAMES,
    PACKIT.SYMREFS$, OU.SYMREFS);
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPSEGDEF, OU.DEFINED_NAMES,
    PACKIT.SEGDEFS$, OU.SEGDEFS);
   CALL GENERATE_EXTERNAL_ENTRIES (%TYPSEGREF, OU.REFERENCED_NAMES,
    PACKIT.SEGREFS$, OU.SEGREFS);
 
   CALL SET_START_ADDRESS;
 
   CALL CONVERT_PROGRAM_AND_RELOC;
 
   CALL CLEAR_LOOKUP_TABLE (OU.DEFINED_NAMES);
   CALL CLEAR_LOOKUP_TABLE (OU.REFERENCED_NAMES);
   CALL CLEAR_LOOKUP_TABLE (OU.SYMREFS);
   CALL CLEAR_LOOKUP_TABLE (OU.ENTREFS);
   CALL CLEAR_LOOKUP_TABLE (OU.SEGDEFS);
   CALL CLEAR_LOOKUP_TABLE (OU.SEGREFS);
 
   RETURN;
 
END PROCESS_THIS_OU;
%EJECT;
SET_START_ADDRESS: PROC;
 
DCL START_OFFSET SBIN WORD;
DCL START_OPERAND SBIN WORD;
DCL START_OPERAND_TYPE SBIN WORD;
 
   IF B$OUHEAD.START.OPNDTYP ~= 0
     THEN DO;
 
      START_OPERAND = B$OUHEAD.START.OPERAND;
      START_OPERAND_TYPE = B$OUHEAD.START.OPNDTYP;
 
      CALL CONVERT_RELOCATION_DIRECTIVE (START_OPERAND, START_OPERAND_TYPE,
       START_OFFSET);
 
      START_OFFSET = START_OFFSET + B$OUHEAD.START.OFFSET;
 
      CALL XUO$HEADSTART (START_OPERAND_TYPE, START_OPERAND, START_OFFSET);
 
      END;
 
   RETURN;
 
END SET_START_ADDRESS;
%EJECT;
OPEN_OBJECT_UNIT: PROC;
 
   LIBRARY_NAME.COUNT = B$OUHEAD.LNAMSIZ;
   LIBRARY_NAME.TEXT  = B$OUHEAD.LNAM;
 
   ASL_NAME.COUNT = B$OUHEAD.ASLNAMSIZ;
   ASL_NAME.TEXT  = B$OUHEAD.ASLNAM;
 
   P_NAME.COUNT = M$OU$ -> F$DCB.NAME#.L;
   P_NAME.TEXT = M$OU$ -> F$DCB.NAME#.C;
 
   CALL XUO$BUFINIT (1024 /* words in Defined Names record */,
                     1024 /* words in Referenced Names record */,
                     511 /* Permit ultimate number of control sections */,
                     1024/SIZEW(B$EDEF) /* # entries in Entdef record */,
                     1024/SIZEW(B$EREF) /* # entries in Entref record */,
                     1024/SIZEW(B$SDEF) /* # entries in Symdef record */,
                     1024/SIZEW(B$SREF) /* # entries in Symref record */,
                     1024/SIZEW(B$SEGDEF) /* # entries in Segdef record */,
                     1024/SIZEW(B$SEGREF) /* # entries in Segref record */,
                        /* take default Program buffer size */,
                        /* take default Relocation buffer size */,
                     0 /* minimum logical-block size;  no schema */,
                     0 /* minimum internal-entry size;  no schema */,
                     0 /* minimum executable-statement size;  no schema */,
                     0 /* minimum variable-definition size;  no schema */,
                     0 /* minimum debug-name size;  no schema */,
                     10 /* maximum number of program/reloc buffers */ );
 
   CALL XUO$OUINIT (DCBNUM(M$OU) /* DCB to write object unit through */,
                    %YES# /* Close DCB when OUTERM is called */,
                    %NO# /* No debug schema anyhow */,
                    %PL6ID /* PRELINK looks like PL-6, for what it's worth */,
                    VERSION_INFO /* Version information from B_VERSION */,
                    LIBRARY_NAME /* Shared library name from first OU */,
                    /*default*/ /* Pick up a new UTS for this OU */,
                    ENTADDR(ERROR_HANDLER) /* Handler for OU errors */,
                    /*default*/ /* Default word size (36 bits) */,
                    %YES# /* "Trust me" - 'cause input OUs were trusted */,
                    ASL_NAME /* Alternate Shared Library name from 1st OU */)
       ALTRET (FATAL_XUO_ERROR);
 
   CALL XUO$HEADNAME (P_NAME);
 
   OU_IS_OPEN = %YES#;
 
   RETURN;
 
FATAL_XUO_ERROR: CALL M$ERR;
 
END OPEN_OBJECT_UNIT;
%EJECT;
DEFINE_TYPED_OUTPUT_SECTION: PROC (TYPE, INIT_TO_ZERO);
 
DCL TYPE UBIN WORD;
DCL INIT_TO_ZERO BIT (1);
 
DCL SECTION_NAME_POINTER UBIN WORD;
 
   P_NAME.TEXT = M$OU$ -> F$DCB.NAME#.C;
   P_NAME.COUNT = M$OU$ -> F$DCB.NAME#.L;
 
   CALL ENTER_DNAME (P_NAME, SECTION_NAME_POINTER);
 
   CALL CREATE_SECTION (PACKIT.SECTIONS$(PACKIT.SECTION_COUNT),
    SECTION_NAME_POINTER, TYPE, %EIGHTBOUNDSECTION, INIT_TO_ZERO,
    ~INIT_TO_ZERO, %NO#);
 
   PACKIT.SECTION_COUNT = PACKIT.SECTION_COUNT + 1;
 
   RETURN;
 
END DEFINE_TYPED_OUTPUT_SECTION;
%EJECT;
CREATE_SECTION: PROC (SECTION$, NAME_POINTER, TYPE, ALIGNMENT,
 INIT_TO_ZERO, INIT_TO_UTS, IS_IN_SEGMENT, SEGMENT_NAME_POINTER);
 
DCL SECTION$ PTR;
DCL NAME_POINTER SBIN WORD;
DCL TYPE UBIN WORD;
DCL ALIGNMENT UBIN WORD;
DCL INIT_TO_ZERO BOOLEAN;
DCL INIT_TO_UTS BOOLEAN;
DCL IS_IN_SEGMENT BOOLEAN;
DCL SEGMENT_NAME_POINTER SBIN WORD;
 
DCL 1 INITIALIZATION_INFO,
      2 INIT_TO_ZERO BOOLEAN,
      2 INIT_TO_UTS BOOLEAN,
      2 IS_IN_SEGMENT BOOLEAN;
 
DCL SECTION_NUMBER UBIN WORD;
 
%SECTION   (STCLASS="BASED(SECTION$)");
 
   INITIALIZATION_INFO.INIT_TO_ZERO  = INIT_TO_ZERO;
   INITIALIZATION_INFO.INIT_TO_UTS   = INIT_TO_UTS;
   INITIALIZATION_INFO.IS_IN_SEGMENT = IS_IN_SEGMENT;
 
   IF IS_IN_SEGMENT
    THEN
      CALL XUO$SECTBUILD (TYPE, NAME_POINTER, SECTION_NUMBER,
       INITIALIZATION_INFO, ALIGNMENT, SEGMENT_NAME_POINTER)
       ALTRET (FATAL_XUO_ERROR);
    ELSE
      CALL XUO$SECTBUILD (TYPE, NAME_POINTER, SECTION_NUMBER,
       INITIALIZATION_INFO, ALIGNMENT) ALTRET (FATAL_XUO_ERROR);
 
   CALL GETMEM (SECTION$, SIZEW(SECTION));
 
   SECTION.NAME_POINTER = NAME_POINTER;
   SECTION.NUMBER = SECTION_NUMBER;
   SECTION.SIZE = 0;
   SECTION.HIGHEST_OFFSET_INITIALIZED = -1;
   SECTION.CONTAINED_IN$ = SECTION$;
   SECTION.CONTAINED_AT = 0;
   SECTION.TYPE# = TYPE;
   SECTION.ALIGNMENT# = ALIGNMENT;
   SECTION.INIT_TO_ZERO = INIT_TO_ZERO;
 
   IF IS_IN_SEGMENT
     THEN
      SECTION.SEGMENT_NAME_POINTER = SEGMENT_NAME_POINTER;
     ELSE
      SECTION.SEGMENT_NAME_POINTER = -1;
 
   RETURN;
 
FATAL_XUO_ERROR: CALL M$ERR;
 
END CREATE_SECTION;
%EJECT;
SWEEP_NAMES: PROC (RECORD_TYPE, NAME_SET$, LOOKUP_TABLE, DEFINER$$);
 
DCL RECORD_TYPE UBIN;
DCL NAME_SET$ PTR;
%LOOKUP_TABLE   (STCLASS=PARAM);
DCL DEFINER$$ EPTR;
 
%LOOKUP_ENTRY (STCLASS="BASED(LOOKUP_ENTRY$)");
%P_NAME (STCLASS=AUTO);
 
DCL ENTRY_OFFSET UBIN;
DCL EXTERNAL_NAME$ PTR;
DCL LOOKUP_ENTRY$ PTR;
DCL NAME_POINTER UBIN;
DCL RECORD_NUMBER UBIN;
DCL WORD_COUNT UBIN;
 
   READ_SI.BUF_ = VECTOR (WORK_BUFFER);
   READ_SI.KEY_ = VECTOR (B$OUKEY);
   READ_SI.V.KEYS# = %YES#;
   READ_SI.V.KEYR# = %NO#;
 
   B$OUKEY.NOTHD = '777'O;
   B$OUKEY.UTS = B$OUHEAD.UTS;
   B$OUKEY.TYPE = RECORD_TYPE;
 
   RECORD_NUMBER = 0;
   NAME_POINTER = 0;
 
PROCESS_NAME_RECORDS: DO FOREVER;
 
      B$OUKEY.PAGE = RECORD_NUMBER;
 
      CALL M$READ (READ_SI)
       WHENALTRETURN DO;
 
         IF B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$NOKEY
           THEN
            EXIT PROCESS_NAME_RECORDS;
           ELSE
            CALL ERROR_HANDLER (B$TCB.ALT$ -> B$ALT.ERR, DCBNUM(M$SI));
 
         END;
 
      WORD_COUNT = (M$SI$ -> F$DCB.ARS# + 3) / 4;
      ENTRY_OFFSET = 0;
 
      DO WHILE (ENTRY_OFFSET < WORD_COUNT);
 
         DNAME$ = ADDR(WORK_BUFFER(ENTRY_OFFSET));
 
         IF B$DNAME.COUNT > 0
           THEN DO;
 
            P_NAME.COUNT = B$DNAME.COUNT;
            P_NAME.TEXT = B$DNAME.TEXT;
 
            CALL ENTER_NAME (P_NAME, NAME_SET$, DEFINER$$, EXTERNAL_NAME$);
            CALL GETMEM (LOOKUP_ENTRY$, SIZEW(LOOKUP_ENTRY));
 
            LOOKUP_ENTRY.LOOKUP_INDEX = NAME_POINTER;
            LOOKUP_ENTRY.ENTRY$ = EXTERNAL_NAME$;
 
            CALL RUS$FAST_INSERT (LOOKUP_TABLE.ENTRIES$, LOOKUP_ENTRY);
 
            END;
 
         ENTRY_OFFSET = ENTRY_OFFSET + SIZEW(B$DNAME);
         NAME_POINTER = NAME_POINTER + SIZEW(B$DNAME);
 
         END;
 
      RECORD_NUMBER = RECORD_NUMBER + 1;
 
      END PROCESS_NAME_RECORDS;
 
   RETURN;
 
END SWEEP_NAMES;
%EJECT;
ENTER_DNAME: PROC (P_NAME, NAME_POINTER);
 
%P_NAME (STCLASS=PARAM);
DCL NAME_POINTER SBIN WORD;
 
%EXTERNAL_NAME (STCLASS="BASED(EXTERNAL_NAME$)");
DCL EXTERNAL_NAME$ PTR;
 
   CALL ENTER_NAME (P_NAME, PACKIT.DEFINED_NAMES$,
    ENTADDR (XUO$DNAME), EXTERNAL_NAME$);
 
   CALL EMIT_NAME (EXTERNAL_NAME);
 
   NAME_POINTER = EXTERNAL_NAME.NAME_POINTER;
 
   RETURN;
 
END ENTER_DNAME;
%SPACE 2;
ENTER_RNAME: PROC (P_NAME, NAME_POINTER);
 
%P_NAME (STCLASS=PARAM);
DCL NAME_POINTER SBIN WORD;
 
%EXTERNAL_NAME (STCLASS="BASED(EXTERNAL_NAME$)");
DCL EXTERNAL_NAME$ PTR;
 
   CALL ENTER_NAME (P_NAME, PACKIT.REFERENCED_NAMES$,
    ENTADDR (XUO$RNAME), EXTERNAL_NAME$);
 
   CALL EMIT_NAME (EXTERNAL_NAME);
 
   NAME_POINTER = EXTERNAL_NAME.NAME_POINTER;
 
   RETURN;
 
END ENTER_RNAME;
%EJECT;
ENTER_NAME: PROC (P_NAME, NAME_SET$, DEFINER$$, EXTERNAL_NAME$);
 
%P_NAME (STCLASS=PARAM);
DCL NAME_SET$ PTR;
DCL DEFINER$$ EPTR;
DCL EXTERNAL_NAME$ PTR;
 
%EXTERNAL_NAME   (STCLASS="BASED(EXTERNAL_NAME$)");
%EXTERNAL_NAME   (NAME=TEMP_NAME, STCLASS=AUTO);
 
   TEMP_NAME.P_NAME = P_NAME;
 
   CALL RUS$IS_MEMBER (NAME_SET$, TEMP_NAME, EXTERNAL_NAME$)
     WHENALTRETURN DO;
 
      CALL GETMEM (EXTERNAL_NAME$, SIZEW(ADDR(TEMP_NAME) -> EXTERNAL_NAME));
 
      EXTERNAL_NAME.P_NAME.COUNT = P_NAME.COUNT;
      EXTERNAL_NAME.P_NAME.TEXT  = P_NAME.TEXT;
      EXTERNAL_NAME.NAME_POINTER = -1;
      EXTERNAL_NAME.DEFINER$$ = DEFINER$$;
 
      CALL RUS$FAST_INSERT (NAME_SET$, EXTERNAL_NAME);
 
      END;
 
   RETURN;
 
END ENTER_NAME;
%EJECT;
EMIT_NAME: PROC (EXTERNAL_NAME);
 
%EXTERNAL_NAME (STCLASS=PARAM);
 
   IF EXTERNAL_NAME.NAME_POINTER = -1
     THEN
      CALL EXTERNAL_NAME.DEFINER$$ (EXTERNAL_NAME.P_NAME,
       EXTERNAL_NAME.NAME_POINTER);
 
   RETURN;
 
END EMIT_NAME;
%EJECT;
ALLOCATE_CONTROL_SECTIONS: PROC;
 
DCL INIT_TO_ZERO BOOLEAN;
DCL INIT_TO_UTS BOOLEAN;
DCL INPUT_SECTION$ PTR;
DCL NAMED_SECTION BOOLEAN;
DCL OUTPUT_SECTION$ PTR;
DCL OUTSECT SBIN WORD;
DCL SECTION_COUNT SBIN WORD;
DCL SECTNUM SBIN WORD;
 
%SECTION (NAME=INPUT_SECTION, STCLASS="BASED(INPUT_SECTION$)");
%SECTION (NAME=OUTPUT_SECTION, STCLASS="BASED(OUTPUT_SECTION$)");
 
   READ_SI.BUF_ = VECTOR (WORK_BUFFER);
   READ_SI.KEY_ = VECTOR (B$OUKEY);
   READ_SI.V.KEYS# = %YES#;
   READ_SI.V.KEYR# = %NO#;
 
   B$OUKEY.NOTHD = '777'O;
   B$OUKEY.UTS = B$OUHEAD.UTS;
   B$OUKEY.TYPE = %TYPSECT;
   B$OUKEY.PAGE = 0;
 
   CALL M$READ (READ_SI);
 
   SECTION_COUNT = ((M$SI$ -> F$DCB.ARS# + 3) / 4) / SIZEW(B$SECTION);
   OU.SECTION_COUNT = SECTION_COUNT;
 
PROCESS_INPUT_SECTIONS: DO SECTNUM = 0 TO SECTION_COUNT - 1;
 
      SECTION$ = PINCRW(ADDR(WORK_BUFFER), SECTNUM * SIZEW(B$SECTION));
 
      IF OU.SECTIONS$(SECTNUM) = ADDR(NIL)
        THEN DO;
 
         CALL GETMEM (INPUT_SECTION$, SIZEW(INPUT_SECTION));
 
         OU.SECTIONS$(SECTNUM) = INPUT_SECTION$;
 
         END;
 
        ELSE
         INPUT_SECTION$ = OU.SECTIONS$(SECTNUM);
 
      INPUT_SECTION.NUMBER = SECTNUM;
      INPUT_SECTION.SIZE = B$SECTION.SIZE;
      INPUT_SECTION.TYPE# = B$SECTION.TYPE;
      INPUT_SECTION.ALIGNMENT# = B$SECTION.BOUND;
      INPUT_SECTION.INIT_TO_ZERO = B$SECTION.INITZERO;
      INPUT_SECTION.CONTAINED_IN$ = ADDR(NIL);
      INPUT_SECTION.CONTAINED_AT = 0;
 
      INIT_TO_ZERO = B$SECTION.INITZERO;
      INIT_TO_UTS = B$SECTION.INITUTS;
 
      DO CASE (INPUT_SECTION.TYPE#);
 
       CASE (%DATASECTION, %CODESECTION, %ROSECTION, %UCOMSECTION);
 
         IF B$SECTION.SEGMENT
           THEN
            NAMED_SECTION = %YES#;
           ELSE
            NAMED_SECTION = %NO#;
 
       CASE (%RLCOMSECTION, %LCOMSECTION, %RORLCOMSECTION, %ROLCOMSECTION,
        %DCBSECTION);
 
         NAMED_SECTION = %YES#;
 
       CASE (ELSE);
 
         CALL M$ERR;
 
       END;
 
      IF NAMED_SECTION
       THEN DO;
 
         INPUT_SECTION.NAME_POINTER = B$SECTION.NPOINTER;
 
         CALL CONVERT_NAME_POINTER (OU.DEFINED_NAMES,
          INPUT_SECTION.NAME_POINTER);
 
         END;
 
        ELSE
         INPUT_SECTION.NAME_POINTER = -1;
 
      IF B$SECTION.SEGMENT
        THEN DO;
 
         INPUT_SECTION.SEGMENT_NAME_POINTER = B$SECTION.SEG_NPOINTER;
 
         CALL CONVERT_NAME_POINTER (OU.DEFINED_NAMES,
          INPUT_SECTION.SEGMENT_NAME_POINTER);
 
         END;
 
        ELSE
         INPUT_SECTION.SEGMENT_NAME_POINTER = -1;
 
      OU.SECTIONS$(SECTNUM) = INPUT_SECTION$;
 
SETUP_SECTION: DO;
 
LOOP_ON_SECTIONS: DO OUTSECT = 0 TO PACKIT.SECTION_COUNT - 1;
 
            OUTPUT_SECTION$ = PACKIT.SECTIONS$(OUTSECT);
 
            IF INPUT_SECTION.TYPE# = OUTPUT_SECTION.TYPE#
             AND (INPUT_SECTION.NAME_POINTER = OUTPUT_SECTION.NAME_POINTER OR
                  INPUT_SECTION.NAME_POINTER = -1)
             AND INPUT_SECTION.SEGMENT_NAME_POINTER =
                 OUTPUT_SECTION.SEGMENT_NAME_POINTER
             AND (INPUT_SECTION.INIT_TO_ZERO = OUTPUT_SECTION.INIT_TO_ZERO)
              THEN
PUT_IT_IN_HERE: DO;
 
               CALL PLACE_WITHIN_SECTION (INPUT_SECTION, OUTPUT_SECTION)
                 WHENRETURN DO;
 
                  EXIT SETUP_SECTION;
 
                  END;
 
               END PUT_IT_IN_HERE;
 
            END LOOP_ON_SECTIONS;
 
         IF INPUT_SECTION.SEGMENT_NAME_POINTER = -1
          AND INPUT_SECTION.NAME_POINTER = -1
          AND INPUT_SECTION.ALIGNMENT# ~= %PAGEBOUNDSECTION
           THEN
BUILD_A_NORMAL_SECTION: DO;
 
            DO CASE (INPUT_SECTION.TYPE#);
 
              CASE (%DATASECTION, %CODESECTION, %ROSECTION);
 
               CALL DEFINE_TYPED_OUTPUT_SECTION (INPUT_SECTION.TYPE#,
                INPUT_SECTION.INIT_TO_ZERO);
 
               OUTPUT_SECTION$ = PACKIT.SECTIONS$(PACKIT.SECTION_COUNT-1);
 
               CALL PLACE_WITHIN_SECTION (INPUT_SECTION, OUTPUT_SECTION);
 
               EXIT SETUP_SECTION;
 
              CASE (ELSE);
 
              END;
 
            END BUILD_A_NORMAL_SECTION;
 
         IF INPUT_SECTION.SEGMENT_NAME_POINTER = -1
           THEN
            CALL CREATE_SECTION (OUTPUT_SECTION$, INPUT_SECTION.NAME_POINTER,
             INPUT_SECTION.TYPE#, INPUT_SECTION.ALIGNMENT#, INIT_TO_ZERO,
             INIT_TO_UTS, %NO#);
           ELSE
            CALL CREATE_SECTION (OUTPUT_SECTION$, INPUT_SECTION.NAME_POINTER,
             INPUT_SECTION.TYPE#, INPUT_SECTION.ALIGNMENT#, INIT_TO_ZERO,
             INIT_TO_UTS, %YES#, INPUT_SECTION.SEGMENT_NAME_POINTER);
 
         INPUT_SECTION.CONTAINED_IN$ = OUTPUT_SECTION$;
         INPUT_SECTION.CONTAINED_AT = 0;
         OUTPUT_SECTION.SIZE = INPUT_SECTION.SIZE;
 
         PACKIT.SECTIONS$(PACKIT.SECTION_COUNT) = OUTPUT_SECTION$;
         PACKIT.SECTION_COUNT = PACKIT.SECTION_COUNT + 1;
 
         END SETUP_SECTION;
 
      END PROCESS_INPUT_SECTIONS;
 
   RETURN;
 
END ALLOCATE_CONTROL_SECTIONS;
%EJECT;
PLACE_WITHIN_SECTION: PROC (INPUT_SECTION, OUTPUT_SECTION) ALTRET;
 
%SECTION (NAME=INPUT_SECTION, STCLASS=PARAM);
%SECTION (NAME=OUTPUT_SECTION, STCLASS=PARAM);
 
   DO CASE (INPUT_SECTION.TYPE#);
 
    CASE (%DATASECTION, %CODESECTION, %ROSECTION);
 
      DO CASE (INPUT_SECTION.ALIGNMENT#);
 
       CASE (%EVENBOUNDSECTION);
 
         INPUT_SECTION.CONTAINED_AT = ((OUTPUT_SECTION.SIZE + 1) / 2) * 2;
 
       CASE (%ODDBOUNDSECTION);
 
         INPUT_SECTION.CONTAINED_AT = (OUTPUT_SECTION.SIZE / 2) * 2 + 1;
 
       CASE (%EIGHTBOUNDSECTION);
 
         INPUT_SECTION.CONTAINED_AT = ((OUTPUT_SECTION.SIZE + 7) / 8) * 8;
 
       CASE (%PAGEBOUNDSECTION);
 
         ALTRETURN;
 
       END;
 
      INPUT_SECTION.CONTAINED_IN$ = ADDR(OUTPUT_SECTION);
      OUTPUT_SECTION.SIZE = INPUT_SECTION.CONTAINED_AT + INPUT_SECTION.SIZE;
 
    CASE (%UCOMSECTION, %LCOMSECTION, %RLCOMSECTION,
     %ROLCOMSECTION, %RORLCOMSECTION, %DCBSECTION);
 
      INPUT_SECTION.CONTAINED_IN$ = ADDR(OUTPUT_SECTION);
      INPUT_SECTION.CONTAINED_AT = 0;
 
      OUTPUT_SECTION.SIZE = MAXIMUM(OUTPUT_SECTION.SIZE, INPUT_SECTION.SIZE);
 
    END;
 
   RETURN;
 
END PLACE_WITHIN_SECTION;
%EJECT;
GENERATE_EXTERNAL_ENTRIES: PROC (TYPE, NAME_TABLE, ENTRY_SET$, LOOKUP_TABLE);
 
%LOOKUP_TABLE (NAME=NAME_TABLE, STCLASS=PARAM);
DCL TYPE UBIN WORD;
DCL ENTRY_SET$ PTR;
%LOOKUP_TABLE (STCLASS=PARAM);
 
DCL ALTRETS BOOLEAN;
DCL CALLING_SEQUENCE_TYPE UBIN WORD;
DCL CHECK BOOLEAN;
DCL ENTRY_NUMBER SBIN WORD;
DCL ENTRY_OFFSET SBIN WORD;
DCL ENTRY_SIZE SBIN WORD;
DCL EXTERNAL_NAME$ PTR;
DCL EXTERNAL_SYMBOL$ PTR;
DCL IS_CONSTANT BOOLEAN;
DCL LOOKUP_ENTRY$ PTR;
DCL NEW_ENTRY_NUMBER SBIN WORD;
DCL NPARAM UBIN WORD;
DCL NAME_POINTER SBIN WORD;
DCL OFFSET UBIN WORD;
DCL PRIMARY BOOLEAN;
DCL READ_ONLY BOOLEAN;
DCL SECONDARY BOOLEAN;
DCL SECTNUM UBIN WORD;
DCL VALUE SBIN WORD;
DCL WORD_COUNT SBIN WORD;
 
%EXTERNAL_SYMBOL (STCLASS="BASED(EXTERNAL_SYMBOL$)");
%LOOKUP_ENTRY    (STCLASS="BASED(LOOKUP_ENTRY$)");
 
   READ_SI.BUF_ = VECTOR (WORK_BUFFER);
   READ_SI.KEY_ = VECTOR (B$OUKEY);
   READ_SI.V.KEYS# = %YES#;
   READ_SI.V.KEYR# = %NO#;
 
   B$OUKEY.NOTHD = '777'O;
   B$OUKEY.UTS = B$OUHEAD.UTS;
   B$OUKEY.TYPE = TYPE;
   B$OUKEY.PAGE = 0;
 
   ENTRY_NUMBER = 0;
 
RECORD_LOOP: DO UNTIL B$OUKEY.PAGE = 0;
 
      CALL M$READ (READ_SI)
        WHENALTRETURN DO;
 
         IF B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$NOKEY
           THEN
            EXIT RECORD_LOOP;
           ELSE
            CALL ERROR_HANDLER (B$TCB.ALT$ -> B$ALT.ERR, DCBNUM(M$SI));
 
         END;
 
      WORD_COUNT = (M$SI$ -> F$DCB.ARS# + 3) / 4;
      ENTRY_OFFSET = 0;
 
      DO WHILE (ENTRY_OFFSET < WORD_COUNT);
 
         DO CASE (TYPE);
 
          CASE (%TYPEDEF);
 
            EDEF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            SECTNUM = B$EDEF.OU.SECTNUM;
            OFFSET = B$EDEF.OU.OFFSET;
            NAME_POINTER = B$EDEF.NPOINTER;
            PRIMARY = B$EDEF.PRI;
            ALTRETS = B$EDEF.ALT;
            CHECK = B$EDEF.CHECK;
            CALLING_SEQUENCE_TYPE = B$EDEF.CST;
            NPARAM = B$EDEF.NPARAM;
 
            CALL CONVERT_SECTION_AND_OFFSET (SECTNUM, OFFSET);
            CALL CONVERT_NAME_POINTER (NAME_TABLE, NAME_POINTER);
 
            CALL XUO$EDEF (SECTNUM, OFFSET, NAME_POINTER, PRIMARY, ALTRETS,
             CHECK, CALLING_SEQUENCE_TYPE, NPARAM);
 
            ENTRY_SIZE = SIZEW(B$EDEF);
 
          CASE (%TYPEREF);
 
            EREF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            NAME_POINTER = B$EREF.NPOINTER;
 
            CALL SEARCH_FOR_EXISTING_ENTRY (NAME_POINTER, NAME_TABLE,
             ENTRY_SET$, EXTERNAL_NAME$, EXTERNAL_SYMBOL$)
              WHENALTRETURN DO;
 
               SECONDARY = B$EREF.SREF;
               ALTRETS = B$EREF.ALT;
               CHECK = B$EREF.CHECK;
               CALLING_SEQUENCE_TYPE = B$EREF.CST;
               NPARAM = B$EREF.NPARAM;
 
               CALL XUO$EREF (NAME_POINTER, SECONDARY, ALTRETS, CHECK,
                CALLING_SEQUENCE_TYPE, NPARAM, NEW_ENTRY_NUMBER);
 
               END;
 
            ENTRY_SIZE = SIZEW(B$EREF);
 
          CASE (%TYPSDEF);
 
            SDEF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            NAME_POINTER = B$SDEF.NPOINTER;
            IS_CONSTANT = B$SDEF.CONSTNT;
 
            CALL CONVERT_NAME_POINTER (NAME_TABLE, NAME_POINTER);
 
            IF IS_CONSTANT
              THEN DO;
 
               VALUE = B$SDEF.VALUE;
 
               CALL XUO$SDEF_CONST (NAME_POINTER, VALUE);
 
               END;
 
              ELSE DO;
 
               SECTNUM = B$SDEF.AD.OU.SECTNUM;
               OFFSET = B$SDEF.AD.OU.OFFSET;
 
               CALL CONVERT_SECTION_AND_OFFSET (SECTNUM, OFFSET);
 
               CALL XUO$SDEF (NAME_POINTER, SECTNUM, OFFSET);
 
               END;
 
            ENTRY_SIZE = SIZEW(B$SDEF);
 
          CASE (%TYPSREF);
 
            SREF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            NAME_POINTER = B$SREF.NPOINTER;
 
            CALL SEARCH_FOR_EXISTING_ENTRY (NAME_POINTER, NAME_TABLE,
             ENTRY_SET$, EXTERNAL_NAME$, EXTERNAL_SYMBOL$)
              WHENALTRETURN DO;
 
               SECONDARY = B$SREF.SREF;
               READ_ONLY = B$SREF.READ_ONLY;
 
               CALL XUO$SREF (NAME_POINTER, SECONDARY, NEW_ENTRY_NUMBER,
                READ_ONLY);
 
               END;
 
            ENTRY_SIZE = SIZEW(B$SREF);
 
          CASE (%TYPSEGDEF);
 
            SEGDEF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            NAME_POINTER = B$SEGDEF.NPOINTER;
            IS_CONSTANT = B$SEGDEF.CONSTNT;
 
            CALL CONVERT_NAME_POINTER (NAME_TABLE, NAME_POINTER);
 
            IF IS_CONSTANT
              THEN DO;
 
               VALUE = B$SEGDEF.VALUE;
 
               CALL XUO$SEGDEF_CONST (NAME_POINTER, VALUE);
 
               END;
 
              ELSE DO;
 
               SECTNUM = B$SEGDEF.AD.OU.SECTNUM;
               OFFSET = B$SEGDEF.AD.OU.OFFSET;
 
               CALL CONVERT_SECTION_AND_OFFSET (SECTNUM, OFFSET);
 
               CALL XUO$SEGDEF (NAME_POINTER, SECTNUM, OFFSET);
 
               END;
 
            ENTRY_SIZE = SIZEW(B$SEGDEF);
 
          CASE (%TYPSEGREF);
 
            SEGREF$ = PINCRW(ADDR(WORK_BUFFER), ENTRY_OFFSET);
 
            NAME_POINTER = B$SEGREF.NPOINTER;
 
            CALL SEARCH_FOR_EXISTING_ENTRY (NAME_POINTER, NAME_TABLE,
             ENTRY_SET$, EXTERNAL_NAME$, EXTERNAL_SYMBOL$)
              WHENALTRETURN DO;
 
               SECONDARY = B$SEGREF.SREF;
               READ_ONLY = B$SEGREF.READ_ONLY;
 
               CALL XUO$SEGREF (NAME_POINTER, NEW_ENTRY_NUMBER, '0000'B,
                SECONDARY, READ_ONLY);
 
               END;
 
            ENTRY_SIZE = SIZEW(B$SEGREF);
 
          END;
 
         IF ADDR(ENTRY_SET$) ~= ADDR(NIL)
           THEN DO;
 
            IF EXTERNAL_SYMBOL$ = ADDR(NIL)
              THEN DO;
 
               CALL GETMEM (EXTERNAL_SYMBOL$, SIZEW(EXTERNAL_SYMBOL));
 
               EXTERNAL_SYMBOL.NAME$ = EXTERNAL_NAME$;
               EXTERNAL_SYMBOL.INDEX_INTO_TYPE = NEW_ENTRY_NUMBER;
 
               CALL RUS$FAST_INSERT (ENTRY_SET$, EXTERNAL_SYMBOL);
 
               END;
 
            CALL GETMEM (LOOKUP_ENTRY$, SIZEW (LOOKUP_ENTRY));
 
            LOOKUP_ENTRY.LOOKUP_INDEX = ENTRY_NUMBER;
            LOOKUP_ENTRY.ENTRY$ = EXTERNAL_SYMBOL$;
 
            CALL RUS$FAST_INSERT (LOOKUP_TABLE.ENTRIES$, LOOKUP_ENTRY);
 
            END;
 
         ENTRY_NUMBER = ENTRY_NUMBER + 1;
         ENTRY_OFFSET = ENTRY_OFFSET + ENTRY_SIZE;
 
         END;
 
      B$OUKEY.PAGE = B$OUKEY.PAGE + 1;
 
      END;
 
   RETURN;
 
END GENERATE_EXTERNAL_ENTRIES;
%EJECT;
CONVERT_PROGRAM_AND_RELOC: PROC;
 
DCL ADJUSTMENT_VALUE SBIN WORD;
DCL DATA_BUFFER (0:1023) SBIN WORD;
DCL DATA_BUFFER_BASE SBIN WORD;
DCL DATA_BUFFER_OFFSET SBIN WORD;
DCL DATA_BUFFER_SIZE SBIN WORD;
DCL DISP SBIN WORD;
DCL ENDING_BIT UBIN WORD;
DCL EVALUATION_OPERATOR SBIN WORD;
DCL EVALUATION_VALUE SBIN WORD;
DCL FILLER_INSTRUCTION BIT (36) CONSTANT INIT ('000000002000'O); /* derail */
DCL INFINITE SBIN WORD CONSTANT INIT (%BITBIN('377777777777'O));
DCL INPUT_SECTION$ PTR;
DCL INPUT_SECTION_LOCATION SBIN;
DCL MAY_HAVE_NEW_ORIGIN BOOLEAN;
DCL NEXT_RECORD_BASE SBIN WORD;
DCL NEXT_RECORD_SIZE SBIN WORD;
DCL NEXT_RECORD_TYPE SBIN WORD;
DCL OPERAND SBIN WORD;
DCL OPERAND_TYPE SBIN WORD;
DCL OUTPUT_SECTION$ PTR;
DCL OUTPUT_SECTNUM SBIN WORD;
DCL OUTPUT_OFFSET SBIN WORD;
DCL RELOCATION_DIRECTIVE_SIZE SBIN WORD;
DCL RELOC_BUFFER (0:1023) SBIN WORD;
DCL RELOC_OPERATOR SBIN WORD;
DCL RELOC_BUFFER_BASE SBIN WORD;
DCL RELOC_BUFFER_OFFSET SBIN WORD;
DCL RELOC_BUFFER_SIZE SBIN WORD;
DCL SECTION_RECORDS_EXHAUSTED BOOLEAN;
DCL SECTNUM SBIN WORD;
DCL STARTING_BIT UBIN WORD;
DCL UPPER_LIMIT_OF_RELOCS SBIN WORD;
 
%SECTION (NAME=INPUT_SECTION, STCLASS="BASED(INPUT_SECTION$)");
%SECTION (NAME=OUTPUT_SECTION, STCLASS="BASED(OUTPUT_SECTION$)");
 
DCL START_BIT (0:4) UBIN WORD CONSTANT INIT ( 0, 18, 24,  3,  0);
DCL END_BIT   (0:4) UBIN WORD CONSTANT INIT (17, 35, 35, 17, 35);
%SPACE 3;
   POSITION_SI.KEY_ = VECTOR (B$PRGRELKEY);
   POSITION_SI.V.KEYS# = %YES#;
   POSITION_SI.V.KEYR# = %YES#;
   POSITION_SI.V.N# = 0;
 
   READ_SI.BUF_ = VECTOR (WORK_BUFFER);
   READ_SI.KEY_ = VECTOR (B$PRGRELKEY);
   READ_SI.V.KEYS# = %NO#;
   READ_SI.V.KEYR# = %YES#;
 
   DO SECTNUM = 0 TO OU.SECTION_COUNT - 1;
 
      CALL CONVERT_ONE_SECTION;
 
      END;
 
   RETURN;
%SPACE 3;
CONVERT_ONE_SECTION: PROC;
 
   B$PRGRELKEY.KEYSIZ = LENGTHC(B$PRGRELKEY.NOTHD) + LENGTHC(B$PRGRELKEY.UTS) +
    LENGTHC(B$PRGRELKEY.TYPE) + LENGTHC(B$PRGRELKEY.SECTNUM);
 
   B$PRGRELKEY.NOTHD = '777'O;
   B$PRGRELKEY.UTS = B$OUHEAD.UTS;
   B$PRGRELKEY.TYPE = %TYPPROG;
   B$PRGRELKEY.SECTNUM = SECTNUM;
 
   CALL M$PRECORD (POSITION_SI)
     WHENALTRETURN DO;
 
      IF B$TCB.ALT$ -> B$ALT.ERR.CODE ~= %E$NOKEY
        THEN
         CALL ERROR_HANDLER (B$TCB.ALT$ -> B$ALT.ERR, DCBNUM(M$SI));
 
      IF B$PRGRELKEY.KEYSIZ = 0 OR B$PRGRELKEY.SECTNUM ~= SECTNUM
        THEN
         RETURN; /* nothing for this control section */
 
      END;
 
   INPUT_SECTION$ = OU.SECTIONS$(SECTNUM);
   OUTPUT_SECTION$ = INPUT_SECTION.CONTAINED_IN$;
   OUTPUT_OFFSET = INPUT_SECTION.CONTAINED_AT;
   OUTPUT_SECTNUM = OUTPUT_SECTION.NUMBER;
 
   MAY_HAVE_NEW_ORIGIN = %NO#;
   SECTION_RECORDS_EXHAUSTED = %NO#;
   DATA_BUFFER_SIZE = -1;
   DATA_BUFFER_OFFSET = 0;
   RELOC_BUFFER_SIZE = -1;
   RELOC_BUFFER_OFFSET = 0;
   UPPER_LIMIT_OF_RELOCS = INFINITE;
 
   CALL READ_NEXT_PROGRAM_RECORD;
 
   IF NEXT_RECORD_TYPE = %SUBTYPPROG
     THEN
      CALL LOAD_DATA_BUFFER;
 
   IF NEXT_RECORD_TYPE = %SUBTYPREL
     THEN
      CALL LOAD_RELOC_BUFFER;
 
   DO WHILE DATA_BUFFER_OFFSET < DATA_BUFFER_SIZE
    OR RELOC_BUFFER_OFFSET < RELOC_BUFFER_SIZE;
 
      IF DATA_BUFFER_OFFSET < DATA_BUFFER_SIZE
        THEN DO;
 
         IF MAY_HAVE_NEW_ORIGIN
           THEN DO;
 
            MAY_HAVE_NEW_ORIGIN = %NO#;
 
            IF OUTPUT_SECTION.TYPE# = %CODESECTION
              THEN
               DO WHILE OUTPUT_SECTION.HIGHEST_OFFSET_INITIALIZED + 1 <
                OUTPUT_OFFSET + DATA_BUFFER_BASE + DATA_BUFFER_OFFSET;
 
               OUTPUT_SECTION.HIGHEST_OFFSET_INITIALIZED =
                OUTPUT_SECTION.HIGHEST_OFFSET_INITIALIZED + 1;
 
               CALL XUO$PRGM (OUTPUT_SECTNUM,
                OUTPUT_SECTION.HIGHEST_OFFSET_INITIALIZED, FILLER_INSTRUCTION);
 
               END;
 
            END;
 
         INPUT_SECTION_LOCATION = DATA_BUFFER_BASE + DATA_BUFFER_OFFSET;
 
         CALL XUO$PRGM (OUTPUT_SECTNUM, OUTPUT_OFFSET + INPUT_SECTION_LOCATION,
          DATA_BUFFER(DATA_BUFFER_OFFSET)) ALTRET (FATAL_XUO_ERROR);
 
         OUTPUT_SECTION.HIGHEST_OFFSET_INITIALIZED = OUTPUT_OFFSET +
          INPUT_SECTION_LOCATION;
 
         DATA_BUFFER_OFFSET = DATA_BUFFER_OFFSET + 1;
 
         IF DATA_BUFFER_OFFSET < DATA_BUFFER_SIZE
           THEN
            UPPER_LIMIT_OF_RELOCS = INPUT_SECTION_LOCATION;
           ELSE
            IF NEXT_RECORD_TYPE ~= %SUBTYPPROG
              THEN
               UPPER_LIMIT_OF_RELOCS = INFINITE;
              ELSE
               CALL LOAD_DATA_BUFFER;
 
         END;
 
OUTPUT_RELOCS: DO WHILE RELOC_BUFFER_OFFSET < RELOC_BUFFER_SIZE;
 
         RELOC$ = PINCRW(ADDR(RELOC_BUFFER), RELOC_BUFFER_OFFSET);
 
         IF B$RELOC1.OPNDTYP ~= 0 /* one-word directive */
           THEN DO;
 
            IF B$RELOC1.OP
              THEN
               RELOC_OPERATOR = %RELOCOPSUB;
              ELSE
               RELOC_OPERATOR = %RELOCOPADD;
 
            DISP = RELOC_BUFFER_BASE + B$RELOC1.DISP;
            STARTING_BIT = START_BIT (B$RELOC1.FIELD);
            ENDING_BIT = END_BIT (B$RELOC1.FIELD);
            OPERAND = B$RELOC1.OPERAND;
            OPERAND_TYPE = B$RELOC1.OPNDTYP;
            EVALUATION_OPERATOR = %EVALOPIGNORE;
            EVALUATION_VALUE = 0;
 
            RELOCATION_DIRECTIVE_SIZE = 1;
 
            END;
 
           ELSE DO;
 
            DISP = RELOC_BUFFER_BASE + B$RELOC2.DISP;
            STARTING_BIT = B$RELOC2.STBIT;
            ENDING_BIT = B$RELOC2.ENDBIT;
            OPERAND = B$RELOC2.OPERAND;
            OPERAND_TYPE = B$RELOC2.OPNDTYP;
            RELOC_OPERATOR = B$RELOC2.RELOCOP;
            EVALUATION_OPERATOR = B$RELOC2.EVALOP;
 
            IF EVALUATION_OPERATOR = %EVALOPIGNORE
              THEN DO;
 
               EVALUATION_VALUE = 0;
               RELOCATION_DIRECTIVE_SIZE = 2;
 
               END;
 
              ELSE DO;
 
               EVALUATION_VALUE = B$RELOC2.VALUE;
               RELOCATION_DIRECTIVE_SIZE = 3;
 
               END;
 
            END;
 
         IF DISP > UPPER_LIMIT_OF_RELOCS
           THEN
            EXIT OUTPUT_RELOCS;
 
         CALL CONVERT_RELOCATION_DIRECTIVE (OPERAND, OPERAND_TYPE,
          ADJUSTMENT_VALUE);
 
         IF ADJUSTMENT_VALUE ~= 0
           THEN
            DO CASE (EVALUATION_OPERATOR);
 
             CASE (%EVALOPIGNORE);
 
               EVALUATION_OPERATOR = %EVALOPADD;
               EVALUATION_VALUE = ADJUSTMENT_VALUE;
               ADJUSTMENT_VALUE = 0;
 
             CASE (%EVALOPADD);
 
               EVALUATION_VALUE = EVALUATION_VALUE + ADJUSTMENT_VALUE;
               ADJUSTMENT_VALUE = 0;
 
             CASE (%EVALOPSUB);
 
               EVALUATION_VALUE = EVALUATION_VALUE - ADJUSTMENT_VALUE;
               ADJUSTMENT_VALUE = 0;
 
             CASE (ELSE);
 
             END;
 
         CALL XUO$RELOC (OUTPUT_SECTNUM, OUTPUT_OFFSET + DISP, OPERAND_TYPE,
          OPERAND, RELOC_OPERATOR, STARTING_BIT, ENDING_BIT,
          EVALUATION_OPERATOR, EVALUATION_VALUE) ALTRET (FATAL_XUO_ERROR);
 
         IF ADJUSTMENT_VALUE ~= 0
           THEN
            CALL XUO$RELOC (OUTPUT_SECTNUM, OUTPUT_OFFSET + DISP, %OPERCONST,
             ADJUSTMENT_VALUE, %RELOCOPADD, STARTING_BIT, ENDING_BIT)
              ALTRET (FATAL_XUO_ERROR);
 
         RELOC_BUFFER_OFFSET = RELOC_BUFFER_OFFSET + RELOCATION_DIRECTIVE_SIZE;
 
         END OUTPUT_RELOCS;
 
LOAD_FOLLOWON: DO WHILE RELOC_BUFFER_OFFSET >= RELOC_BUFFER_SIZE;
 
         DO CASE (NEXT_RECORD_TYPE);
 
          CASE (%SUBTYPPROG);
 
            IF DATA_BUFFER_OFFSET >= DATA_BUFFER_SIZE
              THEN
               CALL LOAD_DATA_BUFFER;
              ELSE
               EXIT LOAD_FOLLOWON;
 
          CASE (%SUBTYPREL);
 
            CALL LOAD_RELOC_BUFFER;
 
          CASE (ELSE);
 
            EXIT LOAD_FOLLOWON;
 
          END;
 
         END LOAD_FOLLOWON;
 
      END;
 
   RETURN;
 
FATAL_XUO_ERROR: CALL M$ERR;
 
END CONVERT_ONE_SECTION;
%SPACE 3;
READ_NEXT_PROGRAM_RECORD: PROC;
 
   IF SECTION_RECORDS_EXHAUSTED
     THEN
      RETURN;
 
   CALL M$READ (READ_SI)
     WHENALTRETURN DO;
 
      DO CASE  (B$TCB.ALT$ -> B$ALT.ERR.CODE);
 
       CASE (%E$EOF);
 
         SECTION_RECORDS_EXHAUSTED = %YES#;
         NEXT_RECORD_TYPE = -1;
 
         RETURN;
 
       CASE (%E$LD);
 
         IF B$PRGRELKEY.TYPE = %TYPPROG
           THEN
            CALL ERROR_HANDLER (B$TCB.ALT$ -> B$ALT.ERR, DCBNUM(M$SI));
 
         SECTION_RECORDS_EXHAUSTED = %YES#;
         NEXT_RECORD_TYPE = -1;
 
         RETURN;
 
       CASE (ELSE);
 
         CALL ERROR_HANDLER (B$TCB.ALT$ -> B$ALT.ERR, DCBNUM(M$SI));
 
       END;
 
      END;
 
   IF B$PRGRELKEY.UTS ~= B$OUHEAD.UTS
    OR B$PRGRELKEY.TYPE ~= %TYPPROG
    OR B$PRGRELKEY.SECTNUM ~= SECTNUM
     THEN DO;
 
      SECTION_RECORDS_EXHAUSTED = %YES#;
      NEXT_RECORD_TYPE = -1;
 
      RETURN;
 
      END;
 
   NEXT_RECORD_TYPE = B$PRGRELKEY.SUBTYPE;
   NEXT_RECORD_BASE = B$PRGRELKEY.OFFSET;
   NEXT_RECORD_SIZE = (M$SI$ -> F$DCB.ARS# + 3) / 4;
 
   RETURN;
 
END READ_NEXT_PROGRAM_RECORD;
%SPACE 3;
LOAD_DATA_BUFFER: PROC;
 
   DATA_BUFFER = WORK_BUFFER;
   DATA_BUFFER_SIZE = NEXT_RECORD_SIZE;
   DATA_BUFFER_BASE = NEXT_RECORD_BASE;
   DATA_BUFFER_OFFSET = 0;
 
   UPPER_LIMIT_OF_RELOCS = DATA_BUFFER_BASE - 1;
 
   MAY_HAVE_NEW_ORIGIN = %YES#;
 
   CALL READ_NEXT_PROGRAM_RECORD;
 
   RETURN;
 
LOAD_RELOC_BUFFER: ENTRY;
 
   RELOC_BUFFER = WORK_BUFFER;
   RELOC_BUFFER_SIZE = NEXT_RECORD_SIZE;
   RELOC_BUFFER_BASE = NEXT_RECORD_BASE;
   RELOC_BUFFER_OFFSET = 0;
 
   CALL READ_NEXT_PROGRAM_RECORD;
 
   RETURN;
 
END LOAD_DATA_BUFFER;
%SPACE 3;
END CONVERT_PROGRAM_AND_RELOC;
%EJECT;
CONVERT_NAME_POINTER: PROC (LOOKUP_TABLE, NAME_POINTER);
 
%LOOKUP_TABLE (STCLASS=PARAM);
DCL NAME_POINTER SBIN WORD;
 
%LOOKUP_ENTRY (STCLASS="BASED(LOOKUP_ENTRY$)");
%LOOKUP_ENTRY (NAME=TEMP_LOOKUP_ENTRY, STCLASS=AUTO);
%EXTERNAL_NAME (STCLASS=BASED);
 
DCL LOOKUP_ENTRY$ PTR;
 
   IF NAME_POINTER < 0
     THEN
      RETURN;
 
   TEMP_LOOKUP_ENTRY.LOOKUP_INDEX = NAME_POINTER;
 
   CALL RUS$IS_MEMBER (LOOKUP_TABLE.ENTRIES$, TEMP_LOOKUP_ENTRY,
    LOOKUP_ENTRY$) ALTRET (REQUIRED_MEMBER_MISSING);
 
   CALL EMIT_NAME (LOOKUP_ENTRY.ENTRY$ -> EXTERNAL_NAME);
 
   NAME_POINTER = LOOKUP_ENTRY.ENTRY$ -> EXTERNAL_NAME.NAME_POINTER;
 
   RETURN;
 
REQUIRED_MEMBER_MISSING:
 
   CALL M$ERR;
 
END CONVERT_NAME_POINTER;
%EJECT;
CONVERT_SECTION_AND_OFFSET: PROC (SECTNUM, OFFSET);
 
DCL SECTNUM UBIN WORD;
DCL OFFSET UBIN WORD;
 
%SECTION   (STCLASS=BASED);
 
   OFFSET = OFFSET + OU.SECTIONS$(SECTNUM) -> SECTION.CONTAINED_AT;
 
   SECTNUM = OU.SECTIONS$(SECTNUM) -> SECTION.CONTAINED_IN$ -> SECTION.NUMBER;
 
   RETURN;
 
END CONVERT_SECTION_AND_OFFSET;
%EJECT;
CONVERT_EXTERNAL_SYMBOL: PROC (LOOKUP_TABLE, SYMBOL_INDEX);
 
%LOOKUP_TABLE (STCLASS=PARAM);
DCL SYMBOL_INDEX UBIN WORD;
 
%EXTERNAL_SYMBOL (STCLASS=BASED);
%LOOKUP_ENTRY (NAME=LOOKUP_ENTRY, STCLASS="BASED(LOOKUP_ENTRY$)");
%LOOKUP_ENTRY (NAME=TEMP_LOOKUP_ENTRY, STCLASS=AUTO);
 
DCL LOOKUP_ENTRY$ PTR;
 
   TEMP_LOOKUP_ENTRY.LOOKUP_INDEX = SYMBOL_INDEX;
 
   CALL RUS$IS_MEMBER (LOOKUP_TABLE.ENTRIES$, TEMP_LOOKUP_ENTRY,
    LOOKUP_ENTRY$) ALTRET (REQUIRED_MEMBER_MISSING);
 
   SYMBOL_INDEX = LOOKUP_ENTRY.ENTRY$ -> EXTERNAL_SYMBOL.INDEX_INTO_TYPE;
 
   RETURN;
 
REQUIRED_MEMBER_MISSING:
 
   CALL M$ERR;
 
END CONVERT_EXTERNAL_SYMBOL;
%EJECT;
CONVERT_RELOCATION_DIRECTIVE: PROC (OPERAND, OPERAND_TYPE, OUTPUT_OFFSET);
 
DCL OPERAND SBIN WORD;
DCL OPERAND_TYPE SBIN WORD;
DCL OUTPUT_OFFSET SBIN WORD;
 
   OUTPUT_OFFSET = 0;
 
   DO CASE (OPERAND_TYPE);
 
    CASE (%OPERSECT);
 
      CALL CONVERT_SECTION_AND_OFFSET (OPERAND, OUTPUT_OFFSET);
 
    CASE (%OPEREREF);
 
      CALL CONVERT_EXTERNAL_SYMBOL (OU.ENTREFS, OPERAND);
 
    CASE (%OPERSREF);
 
      CALL CONVERT_EXTERNAL_SYMBOL (OU.SYMREFS, OPERAND);
 
    CASE (%OPERSEGID);
 
      CALL CONVERT_EXTERNAL_SYMBOL (OU.SEGDEFS, OPERAND);
 
    CASE (%OPERSEGREF);
 
      CALL CONVERT_EXTERNAL_SYMBOL (OU.SEGREFS, OPERAND);
 
    CASE (%OPERCONST);
 
    CASE (ELSE);
 
      CALL M$ERR;
 
    END;
 
   RETURN;
 
END CONVERT_RELOCATION_DIRECTIVE;
%EJECT;
CLEAR_LOOKUP_TABLE: PROC (LOOKUP_TABLE);
 
%LOOKUP_TABLE (STCLASS=PARAM);
 
DCL LOOKUP_ENTRY$ PTR;
 
%LOOKUP_ENTRY (STCLASS="BASED(LOOKUP_ENTRY$)");
 
RELEASE_LOOKUP_ENTRIES: DO FOREVER;
 
      CALL RUS$GET_MEMBER (LOOKUP_TABLE.ENTRIES$, LOOKUP_ENTRY$)
       WHENALTRETURN DO;
 
         EXIT RELEASE_LOOKUP_ENTRIES;
 
         END;
 
      CALL RUS$DELETE (LOOKUP_TABLE.ENTRIES$, LOOKUP_ENTRY);
 
      CALL RELMEM (LOOKUP_ENTRY$);
 
      END;
 
   RETURN;
 
END CLEAR_LOOKUP_TABLE;
%EJECT;
SEARCH_FOR_EXISTING_ENTRY: PROC (NAME_POINTER, NAME_TABLE, ENTRY_SET$,
   EXTERNAL_NAME$, EXTERNAL_SYMBOL$) ALTRET;
 
DCL NAME_POINTER SBIN WORD;
%LOOKUP_TABLE (NAME=NAME_TABLE, STCLASS=PARAM);
DCL ENTRY_SET$ PTR;
DCL EXTERNAL_NAME$ PTR;
DCL EXTERNAL_SYMBOL$ PTR;
 
DCL LOOKUP_ENTRY$ PTR;
 
%EXTERNAL_NAME   (NAME=EXTERNAL_NAME, STCLASS="BASED(EXTERNAL_NAME$)");
%EXTERNAL_SYMBOL (NAME=EXTERNAL_SYMBOL, STCLASS="BASED(EXTERNAL_SYMBOL$)");
%EXTERNAL_SYMBOL (NAME=TEMP_EXTERNAL_SYMBOL, STCLASS=AUTO);
%LOOKUP_ENTRY (NAME=LOOKUP_ENTRY, STCLASS="BASED(LOOKUP_ENTRY$)");
%LOOKUP_ENTRY (NAME=TEMP_LOOKUP_ENTRY, STCLASS=AUTO);
 
   TEMP_LOOKUP_ENTRY.LOOKUP_INDEX = NAME_POINTER;
 
   CALL RUS$IS_MEMBER (NAME_TABLE.ENTRIES$, TEMP_LOOKUP_ENTRY, LOOKUP_ENTRY$)
    ALTRET (REQUIRED_MEMBER_MISSING);
 
   EXTERNAL_NAME$ = LOOKUP_ENTRY.ENTRY$;
 
   CALL EMIT_NAME (EXTERNAL_NAME);
 
   NAME_POINTER = EXTERNAL_NAME.NAME_POINTER;
 
   TEMP_EXTERNAL_SYMBOL.NAME$ = EXTERNAL_NAME$;
 
   CALL RUS$IS_MEMBER (ENTRY_SET$, TEMP_EXTERNAL_SYMBOL, EXTERNAL_SYMBOL$)
     WHENRETURN DO;
 
      RETURN;
 
      END;
 
     WHENALTRETURN DO;
 
      EXTERNAL_SYMBOL$ = ADDR(NIL);
 
      ALTRETURN;
 
      END;
 
REQUIRED_MEMBER_MISSING:
 
   CALL M$ERR;
 
END SEARCH_FOR_EXISTING_ENTRY;
%EJECT;
TERMINATE: PROC;
 
DCL I SBIN;
DCL OU_COUNT_STRING CHAR (3);
DCL SECTNUM UBIN WORD;
DCL SEV_LEVEL_STRING CHAR (2);
 
%SECTION (STCLASS=BASED);
 
   CALL M$CLOSE (CLOSE_SI);
 
   IF OU_IS_OPEN
     THEN DO;
 
      DO SECTNUM = 0 TO PACKIT.SECTION_COUNT + 1;
 
         CALL XUO$SECTSIZE (SECTNUM, PACKIT.SECTIONS$(SECTNUM) ->
          SECTION.SIZE);
 
         END;
 
      CALL XUO$HEAD_SEVERITY (PACKIT.SEVERITY_LEVEL);
      CALL XUO$OUTERM;
 
      END;
 
   IF NUMBER_OF_OUS_PROCESSED = 0
     THEN DO;
 
      LO_BUFFER.VFC = %VFC_S1A;
      LO_BUFFER.TEXT = 'No valid object units found in the input file.';
 
      END;
 
     ELSE DO;
 
      LO_BUFFER.VFC = %VFC_TRANSITION1;
 
      CALL BINCHAR (OU_COUNT_STRING, NUMBER_OF_OUS_PROCESSED);
      CALL BINCHAR (SEV_LEVEL_STRING, PACKIT.SEVERITY_LEVEL);
 
      CALL CONCAT (LO_BUFFER.TEXT, '... ', OU_COUNT_STRING,
       ' object units processed; severity level = ', SEV_LEVEL_STRING);
 
      END;
 
   CALL INDEX (I, '  ', LO_BUFFER.TEXT);
 
   WRITE_LO.BUF_.BOUND = I;
 
   CALL M$WRITE (WRITE_LO);
   CALL M$CLOSE (CLOSE_LO);
 
   CALL M$EXIT;
 
END TERMINATE;
%SPACE 3;
END PRELINK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
MEMORY_MANAGER: PROC (MEM$, MEMSIZ);
 
/*P*  NAME:    MEMORY_MANAGER
      PURPOSE: This routine contains entry points to get and release memory,
               and to initialize the memory pool.
*/
 
/*D*  NAME:    MEMORY_MANAGER
      DESCRIPTION: This ECU contains routines which can be used to acquire
               blocks of memory of a certain specified size, and then later
               return the blocks to the free-memory pool as necessary.
               Memory blocks are stored in a single CP-6 data segment, of up
               to 256k words.
*/
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XUM_MACRO_C;
 
DCL MEM$ PTR;
DCL MEMSIZ UBIN WORD;
 
DCL X$ALLOCATE ENTRY (1) ALTRET;
DCL X$DEALLOCATE ENTRY (1) ALTRET;
 
%FPT_GDS   (FPTN=GET_A_PAGE,
            SEGSIZE=1024,
            RESULTS=MEMORY_VECTOR);
 
%XUM_MCB   (NAME=MCB, STCLASS=STATIC);
 
DCL MEMORY_VECTOR VECTOR STATIC INIT (VECTOR(NIL));
 
%EJECT;
MEMINIT: ENTRY;
 
/*D*  ENTRY    MEMINIT
      CALL:    CALL MEMINIT;
      DESCRIPTION: Acquires one page of data segment memory, and initializes
                   the free-memory control block to frame that one page.
*/
 
   CALL M$GDS (GET_A_PAGE);
 
   MCB.WKSZ = GET_A_PAGE.V.SEGSIZE#;
   MCB.TYPE = 1; /* Allocation requests are in words, not bytes */
   MCB.SEGMENT_BASE$ = VBASE(MEMORY_VECTOR);
   MCB.HI_SEGMENT$ = VBASE(MEMORY_VECTOR);
 
   RETURN;
 
%EJECT;
GETMEM: ENTRY (MEM$, MEMSIZ);
 
/*D*  ENTRY:   GETMEM
      CALL:    CALL GETMEM (block$, words);
      DESCRIPTION: Acquires a block of memory of the indicated size, and
               returns a pointer to it.  Will expand the memory pool if
               a large-enough block is not initially available.
*/
 
   MEM$ = ADDR(NIL);
   MCB.SIZE = MEMSIZ;
 
   DO UNTIL MEM$ ~= ADDR(NIL);
 
      CALL X$ALLOCATE (MCB)
        WHENRETURN DO;
 
         MEM$ = MCB.ADDRESS$;
 
         END;
 
        WHENALTRETURN DO;
 
         CALL M$GDS (GET_A_PAGE);
 
         MCB.WKSZ = (VBOUND(MEMORY_VECTOR) + 1) / 4;
 
         END;
 
      END;
 
   RETURN;
 
%EJECT;
RELMEM: ENTRY (MEM$);
 
/*D*  ENTRY:   RELMEM
      CALL:    CALL RELMEM (block$);
      DESCRIPTION: Returns a block of memory to the free pool.
*/
 
   MCB.ADDRESS$ = MEM$;
 
   CALL X$DEALLOCATE (MCB)
    WHENALTRETURN DO;
 
      CALL M$ERR;
 
      END;
 
   MEM$ = ADDR(NIL);
 
   RETURN;
 
END MEMORY_MANAGER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
NAME_HASHER: PROC (EXTERNAL_NAME, HASHLIMIT, HASHVALUE);
 
%INCLUDE PRELINK_C61;
 
%EXTERNAL_NAME (STCLASS=PARAM);
DCL HASHLIMIT UBIN WORD;
DCL HASHVALUE UBIN WORD;
 
DCL I UBIN WORD;
 
   HASHVALUE = 0;
 
   DO I = 0 TO EXTERNAL_NAME.P_NAME.COUNT - 1;
 
      HASHVALUE = HASHVALUE + ASCBIN(SUBSTR(EXTERNAL_NAME.P_NAME.TEXT, I, 1));
 
      END;
 
   HASHVALUE = MOD (HASHVALUE, HASHLIMIT) + 1;
 
   RETURN;
 
END NAME_HASHER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
NAME_COMPARER: PROC (NAME1, NAME2) ALTRET;
 
%INCLUDE PRELINK_C61;
 
%EXTERNAL_NAME (NAME=NAME1, STCLASS=PARAM);
%EXTERNAL_NAME (NAME=NAME2, STCLASS=PARAM);
 
   IF NAME1.P_NAME.TEXT = NAME2.P_NAME.TEXT
     THEN
      RETURN;
     ELSE
      ALTRETURN;
 
END NAME_COMPARER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
SYMBOL_HASHER: PROC (EXTERNAL_SYMBOL, HASHLIMIT, HASHVALUE);
 
%INCLUDE PRELINK_C61;
 
%EXTERNAL_SYMBOL (STCLASS=PARAM);
DCL HASHLIMIT UBIN WORD;
DCL HASHVALUE UBIN WORD;
 
%EXTERNAL_NAME (STCLASS=BASED);
 
DCL NAME_HASHER ENTRY (3);
 
   CALL NAME_HASHER (EXTERNAL_SYMBOL.NAME$ -> EXTERNAL_NAME,
    HASHLIMIT, HASHVALUE);
 
   RETURN;
 
END SYMBOL_HASHER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
SYMBOL_COMPARER: PROC (SYMBOL1, SYMBOL2) ALTRET;
 
%INCLUDE PRELINK_C61;
 
%EXTERNAL_SYMBOL (NAME=SYMBOL1, STCLASS=PARAM);
%EXTERNAL_SYMBOL (NAME=SYMBOL2, STCLASS=PARAM);
 
   IF SYMBOL1.NAME$ = SYMBOL2.NAME$
     THEN
      RETURN;
     ELSE
      ALTRETURN;
 
END SYMBOL_COMPARER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
LOOKUP_HASHER: PROC (LOOKUP_ENTRY, HASHLIMIT, HASHVALUE);
 
%INCLUDE PRELINK_C61;
 
%LOOKUP_ENTRY (STCLASS=PARAM);
DCL HASHLIMIT UBIN;
DCL HASHVALUE UBIN;
 
DCL PRODUCT SBIN WORD;
 
   PRODUCT = LOOKUP_ENTRY.LOOKUP_INDEX * (LOOKUP_ENTRY.LOOKUP_INDEX + 1) *
    (LOOKUP_ENTRY.LOOKUP_INDEX + 2);
 
   IF PRODUCT < 0
     THEN
      PRODUCT = -1 - PRODUCT;
 
   HASHVALUE = MOD (PRODUCT, HASHLIMIT) + 1;
 
   RETURN;
 
END LOOKUP_HASHER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
LOOKUP_COMPARER: PROC (LOOKUP1, LOOKUP2) ALTRET;
 
%INCLUDE PRELINK_C61;
 
%LOOKUP_ENTRY (NAME=LOOKUP1, STCLASS=PARAM);
%LOOKUP_ENTRY (NAME=LOOKUP2, STCLASS=PARAM);
 
   IF LOOKUP1.LOOKUP_INDEX = LOOKUP2.LOOKUP_INDEX
     THEN
      RETURN;
     ELSE
      ALTRETURN;
 
END LOOKUP_COMPARER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
ERROR_HANDLER: PROC (ERROR_CODE, ERROR_DCB);
 
DCL ERROR_CODE BIT (36) PARAM;
DCL ERROR_DCB UBIN WORD PARAM;
 
DCL ERROR_BUFFER CHAR (120);
 
DCL 1 MY_ERROR_CODE AUTO,
      2 FCG BIT (12),
      2 MID BIT (6),
      2 MON BIT (1),
      2 CODE UBIN (14) UNAL,
      2 SEV UBIN (3) UNAL;
 
DCL M$DO DCB;
DCL M$OU DCB;
 
%INCLUDE CP_6;
%INCLUDE NK_VFC_C;
 
%FPT_ERR (STEPCC=ERROR);
 
%FPT_ERRMSG   (OUTDCB1=M$DO, INCLCODE=NO, VFC=%VFC_TRANSITION1);
%VLR_ERRMSG   (STCLASS=AUTO);
 
   MY_ERROR_CODE = ERROR_CODE;
 
   MY_ERROR_CODE.SEV = 0;
 
   FPT_ERRMSG.BUF_ = VECTOR (ERROR_BUFFER);
   FPT_ERRMSG.CODE_ = VECTOR (MY_ERROR_CODE);
   FPT_ERRMSG.RESULTS_ = VECTOR (VLR_ERRMSG);
 
   IF ADDR (ERROR_DCB) = ADDR(NIL)
     THEN
      FPT_ERRMSG.V.DCB# = DCBNUM(M$OU);
     ELSE
      FPT_ERRMSG.V.DCB# = ERROR_DCB;
 
   CALL M$ERRMSG (FPT_ERRMSG) ALTRET (ERROR_IT);
 
ERROR_IT:
 
   FPT_ERR.CODE_ = VECTOR(MY_ERROR_CODE);
 
   MY_ERROR_CODE.SEV = MINIMUM (VLR_ERRMSG.CODEUSED.SEV + 1, 7);
 
   CALL M$ERR (FPT_ERR);
 
END ERROR_HANDLER;
