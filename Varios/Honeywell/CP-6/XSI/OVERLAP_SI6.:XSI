/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DDA */
OVERLAP: PROC MAIN;
 
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;                       /* For WILD_COMPARE macro              */
/* CLUDE OVERLAP_C1; */
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE XUH_MACRO_C;
%EJECT;
%LIST;
%INCLUDE OVERLAP_C1;
%PLIST;
%EJECT;
/**/
/* SUBs */
/**/
 
%EQU NUM_KEYWORDS            = 24;
 
%SUB A_O_I_M##               = 1;
%SUB ATTRIBUTE##             = 2;
%SUB BLANK##                 = 3;
%SUB BWZ##                   = 4;
%SUB CLASS##                 = 5;
%SUB CONSTANT##              = 6;
%SUB DEFAULT##               = 7;
%SUB ENTRY_REQUIRED##        = 8;
%SUB ENTRY_OPTIONAL##        = 9;
%SUB ERROR_MESSAGE##         = 10;
%SUB FILL##                  = 11;
%SUB INPUT##                 = 12;
%SUB I_O##                   = 13;
%SUB OUTPUT###               = 14;
%SUB JUST##                  = 15;
%SUB JUSTIFIED##             = 16;
%SUB MINIMUM##               = 17;
%SUB PIC##                   = 18;
%SUB PICTURE##               = 19;
%SUB POS##                   = 20;
%SUB POSITION##              = 21;
%SUB PROMPT##                = 22;
%SUB REPEATS##               = 23;
%SUB USAGE##                 = 24;
%EJECT;
/**/
/* SUBs used to access the PCB */
/**/
 
%SUB BLK1_NSUBLKS = "BLK1$->P_OUT.NSUBLKS";
%SUB BLK1_SUBLK$  = "BLK1$->P_OUT.SUBLK$";
 
%SUB BLK2_NSUBLKS = "BLK2$->P_OUT.NSUBLKS";
%SUB BLK2_SUBLK$  = "BLK2$->P_OUT.SUBLK$";
%SUB BLK2_CODE    = "BLK2$->P_SYM.CODE";
%SUB BLK2_COUNT   = "BLK2$->P_SYM.COUNT";
%SUB BLK2_TEXT    = "SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)";
 
%SUB BLK3_NSUBLKS = "BLK3$->P_OUT.NSUBLKS";
%SUB BLK3_SUBLK$  = "BLK3$->P_OUT.SUBLK$";
%SUB BLK3_CODE    = "BLK3$->P_SYM.CODE";
%SUB BLK3_COUNT   = "BLK3$->P_SYM.COUNT";
%SUB BLK3_TEXT    = "SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)";
 
%SUB BLK4_NSUBLKS = "BLK4$->P_OUT.NSUBLKS";
%SUB BLK4_SUBLK$  = "BLK4$->P_OUT.SUBLK$";
%SUB BLK4_CODE    = "BLK4$->P_SYM.CODE";
%SUB BLK4_COUNT   = "BLK4$->P_SYM.COUNT";
%SUB BLK4_TEXT    = "SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT)";
%EJECT;
/**************\
*              *
*   FPL FPTs   *
*              *
\**************/
 
%M$DCB       (DCBN                     = FPL,
              ASN=FILE,
              FUN=IN );
 
%FPT_OPEN    (FPTN                     = OPEN_FPL,
              ACCT=FPL_ACCT,
              DCB=FPL,
              NAME=FPL_NAME,
              PASS=FPL_PASS,
              SN=FPL_SN );
%VLP_ACCT    (FPTN                     = FPL_ACCT );
%VLP_NAME    (FPTN                     = FPL_NAME );
%VLP_PASS    (FPTN                     = FPL_PASS );
%VLP_SN      (FPTN                     = FPL_SN,
              N=1 );
 
%FPT_READ    (FPTN                     = READ_FPL,
              BUF=FPL_BUF,
              DCB=FPL,
              KEY=FPL_KEY,
              KEYR=YES );
 
%FPT_FID     (FPTN                     = FID_FPL,
              ACCT=FPL_ACCT,
              ASN=OPEN_FPL.V.ASN#,
              NAME=FPL_NAME,
              PASS=FPL_PASS,
              RES=OPEN_FPL.V.RES#,
              SN=FPL_SN,
              TEXTFID=FID_STRING );
 
%FPT_UNFID   (FPTN                     = UNFID_FPL,
              DCB=FPL,
              LEN=FPL_FID_LEN,
              TEXTFID=FPL_FID );
%EJECT;
/***************\
*               *
*   M$LO FPTs   *
*               *
\***************/
 
%M$DCB       (DCBN                     = M$LO,
              ASN=DEVICE,
              FUN=CREATE,
              RES='ME  ' );
 
%FPT_DEVICE  (FPTN                     = NEW_LO_PAGE,
              DCB=M$LO,
              PAGE=YES );
 
%FPT_UNFID   (FPTN                     = UNFID_LO,
              DCB=M$LO,
              TEXTFID=PREV_LO_FID );
 
%FPT_OPEN    (FPTN                     = OPEN_LO,
              ACCT=LO_ACCT,
              DCB=M$LO,
              NAME=LO_NAME,
              PASS=LO_PASS,
              SN=LO_SN,
              WSN=LO_WSN );
%VLP_ACCT    (FPTN                     = LO_ACCT );
%VLP_NAME    (FPTN                     = LO_NAME );
%VLP_PASS    (FPTN                     = LO_PASS );
%VLP_SN      (FPTN                     = LO_SN,
              N=1 );
%VLP_WSN     (FPTN                     = LO_WSN );
 
%FPT_FID     (FPTN                     = FID_LO,
              ACCT=LO_ACCT,
              ASN=OPEN_LO.V.ASN#,
              NAME=LO_NAME,
              PASS=LO_PASS,
              RES=OPEN_LO.V.RES#,
              SN=LO_SN,
              TEXTFID=FID_STRING,
              WSN=LO_WSN );
%EJECT;
/***************\
*               *
*   M$ME FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = OPEN_ME,
              ASN=DEVICE,
              DCB=M$ME,
              FUN=CREATE,
              ORG=TERMINAL,
              RES='ME  ' );
%EJECT;
/*******************\
*                   *
*   M$SCREEN FPTs   *
*                   *
\*******************/
 
%M$DCB       (DCBN                     = M$SCREEN,
              ACS=DIRECT,
              ASN=FILE,
              CTG=YES,
              EXIST=NEWFILE,
              FUN=CREATE,
              NAME='*SCREEN',
              ORG=KEYED );
 
%FPT_READ    (FPTN                     = READ_SCREEN,
              BUF=REC,
              DCB=M$SCREEN,
              KEY=KEY,
              KEYS=YES );
 
%FPT_READ    (FPTN                     = READS_SCREEN,
              BUF=REC,
              DCB=M$SCREEN,
              KEY=KEY,
              KEYR=YES );
 
%FPT_WRITE   (FPTN                     = WRITE_SCREEN,
              BUF=REC,
              DCB=M$SCREEN,
              KEY=KEY,
              ONEWKEY=YES );
 
%FPT_PFIL    (FPTN                     = BOF_SCREEN,
              BOF=YES,
              DCB=M$SCREEN );
%EJECT;
/***************\
*               *
*   M$SI FPTs   *
*               *
\***************/
 
%M$DCB       (DCBN                     = M$SI,
              ASN=DEVICE,
              FUN=IN,
              RES='ME  ' );
 
%FPT_OPEN    (FPTN                     = OPEN_SI,
              ACCT=SI_ACCT,
              DCB=M$SI,
              NAME=SI_NAME,
              PASS=SI_PASS,
              SN=SI_SN );
%VLP_ACCT    (FPTN                     = SI_ACCT );
%VLP_NAME    (FPTN                     = SI_NAME );
%VLP_PASS    (FPTN                     = SI_PASS );
%VLP_SN      (FPTN                     = SI_SN,
              N=1 );
 
%FPT_FID     (FPTN                     = FID_SI,
              ACCT=SI_ACCT,
              ASN=OPEN_SI.V.ASN#,
              NAME=SI_NAME,
              PASS=SI_PASS,
              RES=OPEN_SI.V.RES#,
              SN=SI_SN,
              TEXTFID=FID_STRING );
%EJECT;
/*****************\
*                 *
*   M$WORK FPTs   *
*                 *
\*****************/
 
%M$DCB       (DCBN                     = M$WORK,
              ACS=DIRECT,
              ASN=FILE,
              FUN=CREATE,
              NAME='*WORK',
              ORG=KEYED );
 
%FPT_READ    (FPTN                     = READ_WORK,
              BUF=REC2,
              DCB=M$WORK,
              KEY=KEY2,
              KEYS=YES );
 
%FPT_READ    (FPTN                     = READS_WORK,
              BUF=REC2,
              DCB=M$WORK,
              KEY=KEY2,
              KEYR=YES );
 
%FPT_WRITE   (FPTN                     = WRITE_WORK,
              BUF=REC2,
              DCB=M$WORK,
              KEY=KEY2,
              ONEWKEY=YES );
 
%FPT_PFIL    (FPTN                     = BOF_WORK,
              BOF=YES,
              DCB=M$WORK );
%EJECT;
/************************\
*                        *
*   MISCELLANEOUS FPTs   *
*                        *
\************************/
 
%FPT_CORRES  (FPTN                     = CORRES );
 
%FPT_CLOSE   (FPTN                     = CLOSEF );
 
%FPT_OPEN    (FPTN                     = OPENF );
 
%FPT_DEVICE  (FPTN                     = DEVICEF );
 
%FPT_WRITE   (FPTN                     = WRITEF );
 
%FPT_GDS     (FPTN                     = GDS,
              RESULTS=GDS_,
              SEGSIZE=1024 );
%VLP_VECTOR  (FPTN                     = GDS_ );
 
%FPT_ERRMSG  (FPTN                     = ERRMSG,
              BUF=ERR_BUF,
              CODE=ERRCODE,
              OUTDCB1=M$ME );
%VLP_ERRCODE (FPTN                     = ERRCODE,
              STCLASS=STATIC );
 
%FPT_EXIT    (FPTN                     = SET_STEPCC,
              STEPCC=OK );
 
%FPT_INT     (FPTN                     = BREAK_CNTRL,
              UENTRY=XUR$BREAK );
%EJECT;
/**************************************************\
*                                                  *
*   XUR$GETCMD, X$PARSE & XUF$FORMAT macro stuff   *
*                                                  *
\**************************************************/
 
%XUR_INIT    (NAME=                    XUR_INIT,
              ABORT=LEE$ABORT,
              STCLASS=STATIC,
              PCB=P_PCB );
 
%P$PCB       (NAME=                    P_PCB,
              STCLASS=STATIC );
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS=BASED );
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS=BASED );
 
%F_FDS       (NAME                     = F_FDS,
              BUF=ME_BUF,
              DCB=M$ME,
              STCLASS=STATIC );
 
%XUH_PARAM;
%EJECT;
/**/
/* BITs */
/**/
 
DCL ADJACENT_OK              BIT(1)    STATIC INIT(%NO#);
DCL ANY_ERRORS               BIT(1);
DCL CCBUF_CMD                BIT(1);
DCL DOING_A_REPEAT           BIT(1)    STATIC INIT(%NO#);
DCL DONE                     BIT(1)    STATIC INIT(%NO#);
DCL FILE_HAD_ERRORS          BIT(1);
DCL FIRST_FRAME              BIT(1);
DCL FIRST_LINE#              BIT(1)    STATIC INIT(%NO#);
DCL FLAGS                    BIT(36);
DCL FLAG(0:35) REDEF FLAGS   BIT(1);
DCL FRAME_NOT_RIGHT          BIT(1)    STATIC INIT(%NO#);
DCL IN_A_LITERAL             BIT(1)    STATIC INIT(%NO#);
DCL ITS_A_FD                 BIT(1)    STATIC INIT(%NO#);
DCL LONEME                   BIT(1);
DCL OVERLAP$UNWIND           BIT(72)   STATIC  SYMDEF;
DCL UNSORTED                 BIT(1);
%EJECT;
/**/
/* CHARacter scalars */
/**/
 
DCL CHR                      CHAR(1);
DCL   CHRU REDEF CHR         UBIN(9)   UNAL;
DCL DESIRED_FRAME            CHAR(31);
DCL ERR_BUF                  CHAR(120) STATIC;
DCL FID_STRING               CHAR(80)  STATIC;
DCL FORM_LABEL1              CHAR(132) STATIC INIT(
    '            1         2         3         4         5         6         7         8         9         0         1         2');
DCL FORM_LABEL2              CHAR(132) STATIC INIT(
    '   123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789');
DCL FPL_BUF                  CHAR(80)  STATIC;
DCL FPL_FID                  CHAR(80)  STATIC;
DCL GREETING                 CHAR(0) STATIC INIT('OVERLAP B02 here (1/25/84)');
DCL INT8                     CHAR(8);
DCL INT9                     CHAR(9);
DCL INT10                    CHAR(10);
DCL LO_BUF                   CHAR(132) STATIC;
DCL LO_FID                   CHAR(80)  STATIC;
DCL ME_BUF                   CHAR(132) STATIC;
DCL OUTPUT_WARNING           CHAR(0)   STATIC INIT(
    'Warning: OVERLAPs primary output (M$LO) is externally SET to ');
DCL PICTURE                  CHAR(80);
DCL PREV_LO_FID              CHAR(80)  STATIC;
DCL PROGRAM_ID               CHAR(30);
DCL PROMPT                   CHAR(1)   STATIC INIT('<');
DCL QUESTION(0:79)           CHAR(1)   STATIC INIT('?'*0);
DCL   QUESTIONS REDEF QUESTION CHAR(80);
DCL TMP_FD_NAME              CHAR(31);
DCL TOKEN_DELIM              CHAR(1);
DCL TOKEN                    CHAR(80);
DCL   TOKENU(0:79) REDEF TOKEN UBIN(9) UNAL;
DCL XUR_BUF                  CHAR(4096)       STATIC;
%EJECT;
/**/
/* CHARacter arrays */
/**/
 
DCL KEYWORD(0:%(NUM_KEYWORDS-1)) CHAR(15) STATIC INIT(
    'A-O-I-M',
    'ATTRIBUTE',
    'BLANK',
    'BWZ',
    'CLASS',
    'CONSTANT',
    'DEFAULT',
    'ENTRY-REQUIRED',
    'ENTRY-OPTIONAL',
    'ERROR-MESSAGE',
    'FILL',
    'INPUT',
    'I-O',
    'OUTPUT',
    'JUST',
    'JUSTIFIED',
    'MINIMUM',
    'PIC',
    'PICTURE',
    'POS',
    'POSITION',
    'PROMPT',
    'REPEATS',
    'USAGE');
%EJECT;
/**/
/* DCBs */
/**/
 
DCL M$ME                     DCB;
 
 
/**/
/* ENTRYs */
/**/
 
DCL LEE$ABORT                ENTRY;
DCL X$WRITE                  ENTRY(22);
%INCLUDE XUR_ENTRY;
 
 
/**/
/* EPTR */
/**/
 
DCL XUR_ABORT                EPTR    STATIC SYMDEF INIT(ENTADDR(LEE$ABORT));
%EJECT;
/**/
/* PTR items */
/**/
 
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL BLK1$                    PTR;
DCL  PERRCODE REDEF BLK1$    BIT(36);
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL BLK5$                    PTR;
DCL FPL$                     PTR STATIC;
DCL M$LO$                    PTR;
DCL M$ME$                    PTR;
DCL M$SI$                    PTR;
%EJECT;
/**/
/* SBIN items, listed alphabetically */
/**/
 
DCL ADJACENT_CNT             SBIN;
DCL BRK_CNT                  SBIN;
DCL CMD#                     SBIN;
DCL CMD_NUM                  SBIN;
DCL COL#(0:199)              SBIN;
DCL CONT_COL                 SBIN;
DCL ERRORS_THIS_LINE         SBIN;
DCL FIRST_LEVEL#             SBIN;
DCL FPL_ARS                  SBIN      STATIC INIT(0);
DCL FPL_CNT                  SBIN      STATIC INIT(0);
DCL FPL_POS                  SBIN;
DCL FPL_FID_LEN              SBIN      STATIC;
DCL LO_FID_LEN               SBIN      STATIC;
DCL HIGH_LINE#               SBIN;
DCL HIGHEST_COLUMN#          SBIN;
DCL HIGHEST_LINE#            SBIN      STATIC INIT(987);
DCL I                        SBIN;
DCL INDX                     SBIN;
DCL J                        SBIN;
DCL K                        SBIN;
DCL L                        SBIN;
DCL M                        SBIN;
DCL N                        SBIN;
DCL O                        SBIN;
DCL P                        SBIN;
DCL Q                        SBIN;
DCL S                        SBIN;
DCL LINE#S(0:299)            SBIN      STATIC INIT(1*0);
DCL 1 LINE#S_TBL REDEF LINE#S,
      2 *(0:299)             SBIN;
DCL LINE1                    SBIN;
DCL LINE2                    SBIN;
DCL LINE_BIAS                SBIN;
DCL LOW_LINE#                SBIN;
DCL LOWEST_COLUMN#           SBIN;
DCL LOWEST_LINE#             SBIN;
DCL KEYWORD#                 SBIN;
DCL LEVEL#                   SBIN;
DCL M$LO#                    SBIN      STATIC INIT(DCBNUM(M$LO));
DCL M$ME#                    SBIN      STATIC INIT(DCBNUM(M$ME));
DCL M$SCREEN#                SBIN      STATIC INIT(DCBNUM(M$SCREEN));
DCL M$SI#                    SBIN      STATIC INIT(DCBNUM(M$SI));
DCL MAX_LENGTH               SBIN;
DCL MAX_WIDTH                SBIN;
DCL ME_INDX                  SBIN;
DCL NUM_CMDS                 SBIN;
DCL NUM_FDS                  SBIN      STATIC INIT(0);
DCL NUM_FRAMES               SBIN      STATIC INIT(0);
DCL NUM_REQUESTS             SBIN      STATIC INIT(0);
DCL ORIGIN_COLUMN#           SBIN;
DCL ORIGIN_LINE#             SBIN;
DCL OVERLAP_CNT              SBIN      STATIC INIT(0);
DCL OVERLAP_NODES            SBIN      SYMREF;
DCL PAREN_POS                SBIN;
DCL PIC_POS                  SBIN;
DCL REP_CNT                  SBIN;
DCL R_CNT                    SBIN      STATIC INIT(0);
DCL TABLEVAL                 SBIN;
DCL TMP                      SBIN;
DCL TMP_ORIGIN_COLUMN#       SBIN;
DCL TMP_ORIGIN_LINE#         SBIN;
DCL TOKEN_LEN                SBIN;
DCL TOKEN_POS                SBIN;
DCL WIDTH                    SBIN;
DCL X                        SBIN;
%EJECT;
/**/
/* FORMATter formats and VECTORs */
/**/
 
DCL FORMAT1                  CHAR(0)   STATIC INIT(
    '.. OVERLAPping fields were detected in %D place');
DCL FORMAT2                  CHAR(0)   STATIC INIT(
    '.. OVERLAPping fields were detected in %D places');
DCL FORMAT3                  CHAR(0)   STATIC INIT(
    '.. Adjacent fields too close together were detected in %D place');
DCL FORMAT4                  CHAR(0)   STATIC INIT(
    '.. Adjacent fields too close together were detected in %D places');
DCL FORMAT5                  CHAR(0)   STATIC INIT(
    '%2D> %>A (%A) overlaps %>A (%A) at columns %D-%D');
DCL FORMAT6                  CHAR(0)   STATIC INIT(
    '%2D> %>A (%A) is adjacent to %>A (%A) at columns %D-%D');
DCL FORMAT7                  CHAR(0)   STATIC INIT(
    ' ');
DCL FORMAT8                  CHAR(0)   STATIC INIT(
    ' ');
%EJECT;
/**/
/* VECTORs */
/**/
 
DCL FMT1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT1));
DCL FMT2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT2));
DCL FMT3_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT3));
DCL FMT4_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT4));
DCL FMT5_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT5));
DCL FMT6_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT6));
DCL FMT7_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT7));
DCL FMT8_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT8));
 
DCL VEC1_                    BIT(72)        DALIGNED;
DCL VEC2_                    BIT(72)        DALIGNED;
DCL VEC3_                    BIT(72)        DALIGNED;
DCL VEC4_                    BIT(72)        DALIGNED;
DCL VEC5_                    BIT(72)        DALIGNED;
DCL VEC6_                    BIT(72)        DALIGNED;
DCL VEC7_                    BIT(72)        DALIGNED;
%EJECT;
/**/
/* STRUCTUREs */
/**/
 
DCL 1 SKIP_BLANKS STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 BLANK                UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(95)  UNAL   INIT(' ');
 
DCL 1 SKIP_DIGITS  STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 DIGITS(0:9)          UBIN(9)   UNAL   INIT(0*0),
      2 *                    CHAR(70)  UNAL   INIT(' ');
DCL DIGITS(0:127) REDEF SKIP_DIGITS UBIN(9) UNAL;
 
DCL 1 SKIP_ZEROS STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 ZERO                 UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(79)  UNAL   INIT(' ');
 
DCL 1 DELIM,
      2 *                    CHAR(128);
DCL DELIMS(0:127) REDEF DELIM UBIN(9)  UNAL;
 
DCL 1 DELIMIT_MOST  STATIC,                               /*  Bytes  */
      2 *                    CHAR(32)  UNAL   INIT(' '),  /* 000-031 */
      2 BLANK                UBIN(9)   UNAL   INIT(0),    /* 032     */
      2 *                    CHAR(11)  UNAL   INIT(' '),  /* 033-043 */
      2 COMMA                UBIN(9)   UNAL   INIT(0),    /* 044     */
      2 *                    CHAR(1)   UNAL   INIT(' '),  /* 045     */
      2 PERIOD               UBIN(9)   UNAL   INIT(0),    /* 046     */
      2 *                    CHAR(12)  UNAL   INIT(' '),  /* 047-058 */
      2 SEMI_COLON           UBIN(9)   UNAL   INIT(0),    /* 059     */
      2 *                    CHAR(68)  UNAL   INIT(' ');  /* 060-127 */
 
DCL 1 DELIMIT_LITERALS  STATIC,
      2 *                    CHAR(34)  UNAL   INIT(' '),  /* 000-033 */
      2 DOUBLE_QUOTE         UBIN(9)   UNAL   INIT(0),    /* 034     */
      2 *                    CHAR(93)  UNAL   INIT(' ');  /* 035-127 */
 
DCL 1 DELIMIT_PICS    STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),  /* 000-031 */
      2 BLANK                UBIN(9)   UNAL   INIT(0),    /* 032     */
      2 *                    CHAR(26)  UNAL   INIT(' '),  /* 033-058 */
      2 SEMI_COLON           UBIN(9)   UNAL   INIT(0),    /* 059     */
      2 *                    CHAR(68)  UNAL   INIT(' ');  /* 060-127 */
 
DCL 1 FPL_KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 EDIT                 UBIN(27)  UNAL,
      2 *                    CHAR(252) UNAL;
 
DCL 1 KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(33),
      2 LINE#                CHAR(02)  UNAL,
      2 FRAME                CHAR(31)  UNAL,
      2 *                    CHAR(222) UNAL;
 
DCL 1 KEY2  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(2),
      2 LINE#                CHAR(02)  UNAL;
 
DCL 1 TEMP  STATIC,
      2 FRAME                CHAR(32),
      2 EDIT_KEY             UBIN,
      2 LEVEL#               UBIN,
      2 FIELD_LEN            UBIN,
      2 FIELD_NAME           CHAR(32),
      2 PIC_LEN              UBIN,
      2 PICTURE              CHAR(80),
      2 LINE#                UBIN,
      2 COLUMN#              UBIN,
      2 REPEAT#              UBIN,
      2 SEPARATED#           UBIN;
 
DCL 1 R(0:199),
      2 FRAME                CHAR(32),
      2 EDIT_KEY             UBIN,
      2 LEVEL#               UBIN,
      2 FIELD_LEN            UBIN,
      2 FIELD_NAME           CHAR(32),
      2 PIC_LEN              UBIN,
      2 PICTURE              CHAR(80),
      2 LINE#                UBIN,
      2 COLUMN#              UBIN,
      2 REPEAT#              UBIN,
      2 SEPARATED#           UBIN;
 
DCL 1 INITIALIZED_TEMP  STATIC,
      2 FRAME                CHAR(32)  INIT(' '),
      2 EDIT_KEY             UBIN      INIT(0),
      2 LEVEL#               UBIN      INIT(0),
      2 FIELD_LEN            UBIN      INIT(0),
      2 FIELD_NAME           CHAR(32)  INIT(' '),
      2 PIC_LEN              UBIN      INIT(0),
      2 PICTURE              CHAR(80)  INIT(' '),
      2 LINE#                UBIN      INIT(0),
      2 COLUMN#              UBIN      INIT(0),
      2 REPEAT#              UBIN      INIT(0),
      2 SEPARATED#           UBIN      INIT(1);
 
 
DCL 1 REC  STATIC,
      2 NUM_FIELDS           UBIN(9)   UNAL,
      2 V(0:40),
        3 EDIT_KEY           UBIN(27)  UNAL,
        3 COLUMN             UBIN(9)   UNAL,
        3 FRAME              CHAR(31)  UNAL,
        3 FIELD_LEN          UBIN(9)   UNAL,
        3 FIELD_NAME         CHAR(31)  UNAL,
        3 PIC_LEN            UBIN(9)   UNAL,
        3 PIC_END            UBIN(9)   UNAL,
        3 PICTURE            CHAR(80)  UNAL;
 
DCL 1 REC2  STATIC,
      2 NUM_FIELDS           UBIN(9)   UNAL,
      2 V(0:40),
        3 EDIT_KEY           UBIN(27)  UNAL,
        3 COLUMN             UBIN(9)   UNAL,
        3 FRAME              CHAR(31)  UNAL,
        3 FIELD_LEN          UBIN(9)   UNAL,
        3 FIELD_NAME         CHAR(31)  UNAL,
        3 PIC_LEN            UBIN(9)   UNAL,
        3 PIC_END            UBIN(9)   UNAL,
        3 PICTURE            CHAR(80)  UNAL;
 
DCL 1 FRAME,
      2 LEN                  UBIN,
      2 NAME                 CHAR(31);
 
DCL 1 FDS(0:199),
      2 LEN                  UBIN(9)   UNAL,
      2 NAME                 CHAR(31)  UNAL,
      2 FIRST_FRAME          SBIN(9)   UNAL,
      2 NUM_FRAMES           UBIN(9)   UNAL;
 
DCL 1 FRAMES(0:299),
      2 LEN                  UBIN(9)   UNAL,
      2 FD_INDX              SBIN(9)   UNAL,
      2 NAME                 CHAR(31)  UNAL;
 
DCL 1 REQUEST(0:299),
      2 FD_INDX              SBIN(9)   UNAL,
      2 FRAME_INDX           SBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 NAME                 CHAR(31)  UNAL;
%EJECT;
START:
    REMEMBER BREAK_HIT IN OVERLAP$UNWIND;
    CALL LEE$INIT  ALTRET( CALL_ERRMSG );
    CALL PARSE_CCBUF;
    DELIM= DELIMIT_MOST;  /* Tell GET_TOKEN to stop on Periods, Commas or blks*/
    IF FPL$->F$DCB.AMR# THEN DO;
         CALL LEE$OPEN( DCBNUM(FPL) )  ALTRET( COULDNT_OPEN );
         CALL PROCESS_FPL_SOURCE  ALTRET( HERE_WE_GO );
         DO WHILE('0'B);
COULDNT_OPEN:
           CALL LEE$MONERR;
           END;
         END;
 
HERE_WE_GO:
    DO WHILE( NOT DONE );
      CALL GET_A_CMD ALTRET( NEXT_CMD );
      DO CASE( CMD# );
        CASE( ADJACENT_OK## );
          ADJACENT_OK= %YES#;
        CASE( ALL_HELP## );
          CALL XUR$ALLMSG( XUH_PARAM )  ALTRET( HELP_ERR );
          DO WHILE('0'B);
HELP_ERR:
           END;
        CASE( CLEAR## );
          NUM_REQUESTS= 0;
        CASE( CHECK## );
          CALL DO_CHECK;
        CASE( END## );
          DONE= %YES#;
        CASE( HELP## );
          XUH_PARAM.HELP$= BLK2$->P_OUT.SUBLK$(0)->P_SYM.TEXTC$;
          CALL XUR$HELP(XUH_PARAM) ALTRET( HELP_ERR );
        CASE( LIST## );
          CALL DO_LIST;
        CASE( MAX_LENGTH## );
 
        CASE( MAX_WIDTH## );
 
        CASE( MORE_HELP## );
          CALL XUR$MOREMSG( XUH_PARAM )  ALTRET( HELP_ERR );
        CASE( NO_ADJACENT## );
          ADJACENT_OK= %NO#;
        CASE( NULL## );
 
        CASE( OUTPUT## );
          CALL DO_OUTPUT;
        CASE( PRINT## );
          CALL PRINT_FRAME;
        CASE( PRINT_CHECK## );
          CALL PRINT_FRAME;
        CASE( PRINT_IF## );
          CALL PRINT_FRAME;
        CASE( READ## );
          CALL DO_READ;
        CASE( SELECT## );
          /* Already been done in PARSE phase */
        CASE( USE## );
          CALL DO_USE  ALTRET( NEXT_CMD );
          CALL LEE$CLOSE( M$SCREEN#,%RELEASE# );
          CALL LEE$OPEN( M$SCREEN# );
          CALL PROCESS_FPL_SOURCE  ALTRET( NEXT_CMD );
        CASE( WIDTH## );
          /* Already been done in PARSE phase */
        CASE( ELSE );
          ME_BUF= '.. X$PARSE knew of a command that OVERLAP never heard of!';
          CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
        END;
      DO WHILE('0'B);
BREAK_HIT:
        NUM_CMDS= 0;
        END;
NEXT_CMD:
      END;
 
ALL_DONE:
    CALL LEE$CLOSE( DCBNUM(FPL) );
    IF DCBADDR(M$SCREEN#)->F$DCB.AMR# THEN
         CALL LEE$CLOSE( M$SCREEN#,%SAVE# );
    ELSE CALL LEE$CLOSE( M$SCREEN#,%RELEASE# );
    IF DCBADDR(DCBNUM(M$WORK))->F$DCB.AMR# THEN
         CALL LEE$CLOSE( DCBNUM(M$WORK),%SAVE# );
    ELSE CALL LEE$CLOSE( DCBNUM(M$WORK),%RELEASE# );
    CALL LEE$CLOSE( M$SI# );
    CALL LEE$CLOSE( M$LO# );
    CALL LEE$CLOSE( M$ME# );
    IF FILE_HAD_ERRORS THEN
         SET_STEPCC.V.STEPCC#= 4;
    CALL M$EXIT( SET_STEPCC );
 
CALL_ERRMSG:
    CALL LEE$MONERR;
    CALL M$XXX;
%EJECT;
DO_CHECK: PROC  ALTRET;
 
    ANY_ERRORS= %NO#;
    ADJACENT_CNT= 0;
    OVERLAP_CNT= 0;
    CALL M$PFIL( BOF_WORK );
    DO WHILE('1'B);
      CALL M$READ( READS_WORK )  ALTRET( EOF_HIT );
      CALL CHARBIN( I,KEY2.LINE# );
      DO J=1 TO REC2.NUM_FIELDS-1;
        IF REC2.V.PIC_END(J-1) >= REC2.V.COLUMN(J) THEN
             CALL PUT_FMT5_OR_6( OVERLAP_CNT,FMT5_ );
        ELSE IF REC2.V.PIC_END(J-1)+1 = REC2.V.COLUMN(J)  AND
                NOT ADJACENT_OK  THEN
                  CALL PUT_FMT5_OR_6( ADJACENT_CNT,FMT6_ );
        END;
      END;
EOF_HIT:
    KEY2.LEN= LENGTHC(KEY2.LINE#);
    CALL PUT_ERROR_CNTS;
    RETURN;
 
END DO_CHECK;
%EJECT;
DO_LIST: PROC;
 
    DO I=1 TO NUM_FDS;
      IF FDS.NUM_FRAMES(I) > 1 THEN DO;
           CALL CONCAT( ME_BUF,'Form ',
                               SUBSTR(FDS.NAME(I),0,FDS.LEN(I)),
                               ' in program ',
                               PROGRAM_ID );
           CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
           SUBSTR(ME_BUF,ME_INDX+1)= ' contains frames:';
           CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
           ME_BUF= ' ';
           ME_INDX= 4;
           DO J=FDS.FIRST_FRAME(I) TO FDS.FIRST_FRAME(I)+FDS.NUM_FRAMES(I)-1;
             IF ME_INDX+FRAMES.LEN(J)+LENGTHC(',') >= 80 THEN DO;
                  CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
                  ME_BUF= ' ';
                  ME_INDX= 4;
                  END;
             SUBSTR(ME_BUF,ME_INDX)= FRAMES.NAME(J);
             CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
             IF J < FDS.FIRST_FRAME(I)+FDS.NUM_FRAMES(I)-1 THEN DO;
                  SUBSTR(ME_BUF,ME_INDX+1)= ', ';
                  ME_INDX= ME_INDX + LENGTHC(', ');
                  END;
             END;
           CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
           END;
      ELSE DO;
           CALL CONCAT( ME_BUF,'Form ',
                               SUBSTR(FDS.NAME(I),0,FDS.LEN(I)),
                               ' in program ',
                               PROGRAM_ID );
           CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
           CALL INSERT( ME_BUF,ME_INDX+1,,' contains frame ',
                                          FRAMES.NAME(FDS.FIRST_FRAME(I)) );
           CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
           END;
      END;
    RETURN;
 
END DO_LIST;
%EJECT;
DO_OUTPUT: PROC;
 
    OPEN_LO.V.EXIST#= %ERROR#;     /* By default, don't clobber existing file */
    DO I=0 TO BLK2_NSUBLKS-1;
      BLK3$= BLK2_SUBLK$(I);
      DO CASE( BLK3_CODE );
        CASE( ON##,
              TO## );
          /* Done by default above */
        CASE( OVER## );
          OPEN_LO.V.EXIST#= %NEWFILE#;
        CASE( INTO## );
          OPEN_LO.V.EXIST#= %OLDFILE#;
        CASE( AFID## );
          FID_STRING= BLK3_TEXT;
        END;
      END;
 
    FID_LO.V.SCRUB= '111111'B;          /* Scrub: NAME,ACCT,PASS,SN,WSN & RES */
    CALL M$FID( FID_LO )  ALTRET( CALL_ERRMSG );
    CALL LEE$CLOSE( M$LO# );
    CALL M$OPEN( OPEN_LO )  ALTRET( REOPEN_LO );
    PREV_LO_FID= FID_STRING;
    CALL LEE$CORRES( M$LO#,M$ME#,LONEME );
    GOTO RET;
 
REOPEN_LO:
    CALL LEE$MONERR;
    FID_STRING= PREV_LO_FID;
    CALL M$FID( FID_LO )  ALTRET( CALL_ERRMSG );
    OPEN_LO.V.EXIST#= %OLDFILE#;
    CALL M$OPEN( OPEN_LO )  ALTRET( CALL_ERRMSG );
    GOTO RET;
 
CALL_ERRMSG:
    CALL LEE$MONERR;
RET:
    RETURN;
 
END DO_OUTPUT;
%EJECT;
PRINT_FRAME: PROC  ALTRET;
 
    ANY_ERRORS= %NO#;
    OVERLAP_CNT= 0;
    ADJACENT_CNT= 0;
    IF CMD# ~= PRINT_IF## THEN
         CALL PUT_FRAME_LIST('1'B);
    IF M$LO$->F$DCB.WIDTH# > 80 THEN
         ME_BUF= SUBSTR(FORM_LABEL2,0,M$LO$->F$DCB.WIDTH#);
    ELSE ME_BUF= SUBSTR(FORM_LABEL2,0,80);
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
    DO I=1 TO HIGHEST_LINE#;
      ERRORS_THIS_LINE= 0;
      IF LINE#S(I) = 0 THEN
           GOTO NEXT_LINE;
      KEY2.LEN= LENGTHC(KEY2.LINE#);
      CALL BINCHAR( KEY2.LINE#,I );
      CALL CONCAT( ME_BUF,KEY2.LINE#,'>' );
      CALL M$READ( READ_WORK )  ALTRET( PUT_A_LINE );
      SUBSTR(ME_BUF,REC2.V.COLUMN(0))= REC2.V.PICTURE(0);
      DO J=1 TO REC2.NUM_FIELDS-1;
        IF REC2.V.PIC_END(J-1) >= REC2.V.COLUMN(J) THEN DO;
             OVERLAP_CNT= OVERLAP_CNT + 1;
             ERRORS_THIS_LINE= ERRORS_THIS_LINE + 1;
             K= (REC2.V.PIC_END(J-1)+1) - REC2.V.COLUMN(J);
             SUBSTR(ME_BUF,REC2.V.COLUMN(J),K)= QUESTIONS;
             SUBSTR(ME_BUF,REC2.V.COLUMN(J)+K)= SUBSTR(REC2.V.PICTURE(J),K);
             END;
        ELSE IF REC2.V.PIC_END(J-1)+1 = REC2.V.COLUMN(J)  AND
                NOT ADJACENT_OK THEN DO;
                  ADJACENT_CNT= ADJACENT_CNT + 1;
                  ERRORS_THIS_LINE= ERRORS_THIS_LINE + 1;
                  SUBSTR(ME_BUF,REC2.V.COLUMN(J)-1,2)= '><';
                  SUBSTR(ME_BUF,REC2.V.COLUMN(J)+1)=SUBSTR(REC2.V.PICTURE(J),1);
                  END;
             ELSE SUBSTR(ME_BUF,REC2.V.COLUMN(J),REC2.V.PIC_LEN(J))=
                                                              REC2.V.PICTURE(J);
        END;
PUT_A_LINE:
      IF CMD# ~= PRINT_IF##  OR
         ERRORS_THIS_LINE > 0 THEN
           CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
NEXT_LINE:
      END;
    IF M$LO$->F$DCB.WIDTH# > 80 THEN
         ME_BUF= SUBSTR(FORM_LABEL2,0,M$LO$->F$DCB.WIDTH#);
    ELSE ME_BUF= SUBSTR(FORM_LABEL2,0,80);
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
    IF ADJACENT_CNT+OVERLAP_CNT > 0 THEN
         IF CMD# = PRINT## THEN DO;
              CALL LEE$WRITE( ' ',LENGTHC(' '),M$LO# );
              CALL PUT_ERROR_CNTS;
              END;
         ELSE CALL DO_CHECK;
    ELSE CALL PUT_ERROR_CNTS;
    RETURN;
 
END PRINT_FRAME;
%EJECT;
DO_READ: PROC;
 
    IF DCBADDR(DCBNUM(M$SI))->F$DCB.ASN# = %FILE# THEN DO;
         ME_BUF= 'Sorry, you can''t have a READ command in a command file';
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
         GOTO RET;
         END;
    FID_STRING= BLK2$->P_OUT.SUBLK$(0)->P_SYM.TEXT;
    CALL M$FID( FID_SI )  ALTRET( OOPS );
    DO WHILE('0'B);
OOPS:
      CALL LEE$MONERR;
      FID_STRING= 'ME';
      CALL M$FID( FID_SI )  ALTRET( RET );
      END;
    CALL LEE$CLOSE( DCBNUM(M$SI) );
    CALL M$OPEN( OPEN_SI )  ALTRET( OOPS );
RET:
    RETURN;
 
END DO_READ;
%EJECT;
DO_USE: PROC  ALTRET;
 
    FID_FPL.V.SCRUB= '111111'B;  /* Scrub: NAME,ACCT,PASS,SN,WSN & RES */
    CALL M$FID( FID_FPL )  ALTRET( OOPS );  /* FID_STRING -> VLPs */
    CALL LEE$CLOSE( DCBNUM(FPL) );
    CALL M$OPEN( OPEN_FPL )  ALTRET( OOPS );
    FPL_FID= FID_STRING;
    RETURN;
 
OOPS:
    CALL LEE$MONERR;
    ALTRETURN;
 
END DO_USE;
%EJECT;
PROCESS_FPL_SOURCE: PROC  ALTRET;
 
    NUM_FDS= 0;
    NUM_FRAMES= 0;
    HIGHEST_COLUMN#= 0;
    HIGHEST_LINE#= 0;
    FILE_HAD_ERRORS= %NO#;
    CALL M$UNFID( UNFID_FPL )  ALTRET( OOPS );              /* DCB -> FPL_FID */
    CALL FIND_PROGRAM_ID  ALTRET( OOPS );
    CALL FIND_FDS  ALTRET( OOPS );
    CALL FIND_FRAME_SECTION  ALTRET( OOPS );
FIND_THE_FR:
    CALL FIND_FR  ALTRET( OOPS );   /* Find 'FR frame-name' */
 
    DO WHILE( TOKEN = 'FR' );
GET_FRAME:
      TMP_ORIGIN_LINE#= 0;
      TMP_ORIGIN_COLUMN#= 0;
      FIRST_LEVEL#= 0;
      R_CNT= 0;
      DOING_A_REPEAT= %NO#;
      CALL GET_TOKEN  ALTRET( OOPS );  /* Get frame name */
      FRAME.NAME= TOKEN;
      CALL INDEX1( FRAME.LEN,' ',FRAME.NAME );
      KEY.LINE#= '00';
      CALL GET_TOKEN  ALTRET( OOPS );/* A period should follow the frame name */
      IF TOKEN ~= '.' THEN
           CALL PARSE_ORIGIN  ALTRET( FIND_THE_FR );
FIND_LEVEL_NUM:
      CALL GET_TOKEN  ALTRET( OOPS );  /* Get what should be a level number   */
 
      DO WHILE( TOKEN ~= 'PROCEDURE' AND
                TOKEN ~= 'FR' );
        CALL SEARCH( I,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                                ALTRET( FOUND_LEVEL );
        CALL CONCAT( ME_BUF,'.. I expected a level#; But found -> ',TOKEN );
        CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,'1'B );
        GOTO FIND_LEVEL_NUM;
FOUND_LEVEL:
        CALL CHARBIN( LEVEL#,SUBSTR(TOKEN,0,TOKEN_LEN) );
        IF LEVEL# <= FIRST_LEVEL# THEN
             CALL PROCESS_REPEATS  ALTRET( OOPS );
        TEMP= INITIALIZED_TEMP;
        TEMP.FRAME= FRAME.NAME;
        TEMP.LEVEL#= LEVEL#;
        IF FPL$->F$DCB.ORG# = %KEYED# THEN
             TEMP.EDIT_KEY= FPL_KEY.EDIT;
        ELSE TEMP.EDIT_KEY= FPL_CNT;
        FLAGS= '0'B;
        CALL GET_TOKEN  ALTRET( OOPS );/* Get the data-name, we hope          */
        TEMP.FIELD_LEN= TOKEN_LEN;
        TEMP.FIELD_NAME= TOKEN;
        CALL GET_TOKEN  ALTRET( OOPS );/* Now, the next token and others      */
        DO WHILE( TOKEN ~= '.'  AND  TOKEN ~= 'FR' AND  TOKEN ~= 'PROCEDURE' AND
                  (SUBSTR(TOKEN,0,1) < '0' OR SUBSTR(TOKEN,0,1) > '9') );
          CALL PROCESS_TOKEN  ALTRET( OOPS );
          END;
        IF DOING_A_REPEAT THEN
             CALL ADD_REPEAT_FIELD;
        ELSE
             IF FLAG(PIC##) OR FLAG(PICTURE##) THEN
                  CALL ADD_FIELD  ALTRET( OOPS );
        IF TOKEN = '.' THEN
            CALL GET_TOKEN  ALTRET( OOPS );
        IF TOKEN = 'FR' OR
           TOKEN = 'PROCEDURE' THEN DO;
             IF DOING_A_REPEAT THEN
                  CALL PROCESS_REPEATS  ALTRET( OOPS );
             END;
        END;
      TEMP.LINE#= 0;  /* Force ADD_FIELD to WRITE a record for the last field */
      CALL ADD_FIELD  ALTRET( OOPS );
      END;
    RETURN;
 
OOPS:
    CALL LEE$CLOSE( DCBNUM(FPL) );
    ALTRETURN;
 
END PROCESS_FPL_SOURCE;
%EJECT;
GET_TOKEN: PROC  ALTRET;
 
    TOKEN_POS= 0;
RETURN_A_PERIOD:
    IF CHR = '.' THEN DO;              /* If we stopped on a period last time,*/
         TOKEN= '.';                   /* return it as the token this time.   */
         TOKEN_LEN= LENGTHC('.');
         CHR= ' ';
         GOTO GOT_A_PERIOD;
         END;
    TOKEN_LEN= 0;
    TOKEN= ' ';
    CHR= ' ';
    DO WHILE( CHR = ' ' );
      CALL GET_A_CHAR  ALTRET( EOF );
      END;
    IF DELIMS(CHRU) = 0 AND            /* If the first non-blank is a         */
      (FPL_POS = 71  OR
       SUBSTR(FPL_BUF,FPL_POS+1,1) = ' ') THEN
         GOTO RETURN_A_PERIOD;         /* delimiter, go make it the token     */
    TOKEN= CHR;
    IF CHR ~= '"' THEN
         DO WHILE( DELIMS(CHRU) ~= 0 );
           SUBSTR(TOKEN,TOKEN_LEN,1)= CHR;
           TOKEN_LEN= TOKEN_LEN + 1;
           CALL GET_A_CHAR  ALTRET( EOF );
           END;
    ELSE DO;
         CHR= ' ';
         TOKEN_LEN= LENGTHC(CHR);
         IN_A_LITERAL= %YES#;
         FPL_ARS= 72;  /* Trailing blanks on the line are significant         */
         DO WHILE( CHR ~= '"' );       /* Keep everything up to and including */
           CALL GET_A_CHAR  ALTRET( EOF );  /* the next double quote          */
           SUBSTR(TOKEN,TOKEN_LEN,1)= CHR;
           TOKEN_LEN= TOKEN_LEN + 1;
           END;
         IN_A_LITERAL= %NO#;
         FPL_ARS= MINIMUM( 72,FPL$->F$DCB.ARS# );
         CALL GET_A_CHAR  ALTRET( EOF );/* Get character after the closing "  */
         END;
    IF TOKEN_LEN > 1  AND
       SUBSTR(TOKEN,TOKEN_LEN-1,1) = '.' THEN DO;
         TOKEN_LEN= TOKEN_LEN - 1;
         SUBSTR(TOKEN,TOKEN_LEN,1)= ' ';
         END;
GOT_A_PERIOD:
    RETURN;
EOF:
    ALTRETURN;
 
END GET_TOKEN;
%EJECT;
GET_A_CHAR: PROC  ALTRET;
 
    FPL_POS= FPL_POS + 1;
    IF FPL_POS >= FPL_ARS THEN DO;
READ_AGAIN:
         FPL_BUF= ' ';
         CALL M$READ( READ_FPL )  ALTRET( EOF );
         IF IN_A_LITERAL THEN
              /* Trailing blanks will be significant while in literals        */
              FPL_ARS= 72;
         ELSE FPL_ARS= MINIMUM( 72,FPL$->F$DCB.ARS#+1 );
CONTINUE:
         FPL_CNT= FPL_CNT + 1;
         IF SUBSTR(FPL_BUF,6,1) = '*' THEN /* If it's a comment, ignore it    */
              GOTO READ_AGAIN;
         IF SUBSTR(FPL_BUF,6,1) = '-' THEN /* If we're continuing a literal,  */
              CALL INDEX1( FPL_POS,'"',FPL_BUF,7 )  ALTRET( READ_AGAIN );
         ELSE FPL_POS= 6;
         FPL_POS= FPL_POS + 1;
         END;
    CHR= SUBSTR(FPL_BUF,FPL_POS,1);
    RETURN;
 
EOF:
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD THEN DO;
         FPL_ARS= 72;
         GOTO CONTINUE;
         END;
    ALTRETURN;
 
END GET_A_CHAR;
%EJECT;
GET_NUM: PROC( NUM )  ALTRET;
DCL NUM                      SBIN;
 
DCL I                        SBIN;
 
    I= TMP;
    DO WHILE( DIGITS(TOKENU(TMP)) = 0 );
      TMP= TMP + 1;
      END;
    IF TMP-I > LENGTHC('12345678') THEN
         ALTRETURN;
    CALL CHARBIN( NUM,SUBSTR(TOKEN,I,TMP-I) );
    RETURN;
 
END GET_NUM;
%EJECT;
PROCESS_TOKEN: PROC  ALTRET;
 
    DO KEYWORD#= 0 TO %(NUM_KEYWORDS-1);
      IF TOKEN = KEYWORD(KEYWORD#) THEN
           GOTO NOW_WHAT;
      END;
    CALL CONCAT( ME_BUF,'.. Unknown keyword -> ',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    CALL GET_TOKEN  ALTRET( OOPS );
    GOTO RET;
 
NOW_WHAT:
    FLAG(KEYWORD#+1)= '1'B;
    DO CASE( KEYWORD#+1 );
      CASE( A_O_I_M## );
        CALL GET_TOKEN  ALTRET( OOPS );
      CASE( ATTRIBUTE## );
        CALL PARSE_ATTRIBUTE  ALTRET( OOPS );
 
      CASE( BLANK##,
            BWZ## );
        CALL PARSE_BLANK  ALTRET( OOPS );
 
      CASE( CLASS## );
        CALL PARSE_CLASS  ALTRET( OOPS );
 
      CASE( CONSTANT## );
        CALL PARSE_CONSTANT  ALTRET( OOPS );
 
      CASE( DEFAULT## );
        CALL PARSE_CONSTANT  ALTRET( OOPS );
 
      CASE( ENTRY_REQUIRED## );
        CALL GET_TOKEN  ALTRET( OOPS );
 
      CASE( ENTRY_OPTIONAL## );
        CALL GET_TOKEN  ALTRET( OOPS );
 
      CASE( ERROR_MESSAGE## );
        CALL PARSE_ERROR_MESSAGE  ALTRET( OOPS );
 
      CASE( FILL## );
        CALL PARSE_FILL  ALTRET( OOPS );
 
      CASE( INPUT## );
        CALL GET_TOKEN  ALTRET( OOPS );
      CASE( I_O## );
        CALL GET_TOKEN  ALTRET( OOPS );
      CASE( OUTPUT### );
        CALL GET_TOKEN  ALTRET( OOPS );
      CASE( JUST##,
            JUSTIFIED## );
        CALL PARSE_JUSTIFIED  ALTRET( OOPS );
 
      CASE( MINIMUM## );
        CALL PARSE_MINIMUM  ALTRET( OOPS );
 
      CASE( PIC##,
            PICTURE## );
        CALL PARSE_PICTURE  ALTRET( OOPS );
 
      CASE( POS##,
            POSITION## );
        CALL PARSE_POSITION  ALTRET( OOPS );
 
      CASE( PROMPT## );
        CALL PARSE_PROMPT  ALTRET( OOPS );
 
      CASE( REPEATS## );
        CALL PARSE_REPEATS  ALTRET( OOPS );
 
      CASE( USAGE## );
        CALL PARSE_USAGE  ALTRET( OOPS );
 
      END;
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PROCESS_TOKEN;
%EJECT;
ADD_FIELD: PROC ALTRET;
 
    IF TEMP.LINE# <= 0 AND TEMP.REPEAT# <= 0 AND TEMP.PIC_LEN <= 0 THEN
       GOTO RE_TURN;
    IF TEMP.COLUMN#+TEMP.PIC_LEN-1 > HIGHEST_COLUMN# THEN
         HIGHEST_COLUMN#= TEMP.COLUMN#+TEMP.PIC_LEN-1;
    IF TEMP.LINE# > HIGHEST_LINE# THEN
         HIGHEST_LINE#= TEMP.LINE#;
    CALL CHARBIN( N,KEY.LINE# );
    IF N ~= TEMP.LINE#  OR
       KEY.FRAME ~= FRAME.NAME THEN DO;
         IF KEY.LINE# ~= '00' THEN DO;
              WRITE_SCREEN.BUF_.BOUND= (LENGTHC(REC.V(0)) * REC.NUM_FIELDS) +
                                       LENGTHC(REC.NUM_FIELDS) - 1;
              CALL M$WRITE( WRITE_SCREEN )  ALTRET( OOPS );
              END;
         KEY.FRAME= FRAME.NAME;
         KEY.LEN= LENGTHC(KEY.LINE#)+LENGTHC(KEY.FRAME);
         CALL BINCHAR( KEY.LINE#,TEMP.LINE# );
         CALL M$READ( READ_SCREEN )  ALTRET( NEW_REC );
         END;
    DO WHILE ('0'B);
NEW_REC:
      CALL BINCHAR( KEY.LINE#,TEMP.LINE# );
      KEY.FRAME= FRAME.NAME;
      REC.NUM_FIELDS= 0;
      END;
    REC.V.EDIT_KEY(REC.NUM_FIELDS)= TEMP.EDIT_KEY;
    REC.V.COLUMN(REC.NUM_FIELDS)= TEMP.COLUMN# - 1 + LENGTHC('xx>');
    REC.V.FRAME(REC.NUM_FIELDS)= FRAME.NAME;
    REC.V.FIELD_LEN(REC.NUM_FIELDS)= TEMP.FIELD_LEN;
    REC.V.FIELD_NAME(REC.NUM_FIELDS)= TEMP.FIELD_NAME;
    REC.V.PIC_LEN(REC.NUM_FIELDS)= TEMP.PIC_LEN;
    REC.V.PIC_END(REC.NUM_FIELDS)= REC.V.COLUMN(REC.NUM_FIELDS)+TEMP.PIC_LEN-1;
    REC.V.PICTURE(REC.NUM_FIELDS)= TEMP.PICTURE;
    REC.NUM_FIELDS= REC.NUM_FIELDS + 1;
RE_TURN:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END ADD_FIELD;
%EJECT;
PARSE_ATTRIBUTE: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip token past 'ATTRIBUTE'         */
    IF TOKEN = 'IS' THEN               /* Skip 'IS' if it's present           */
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the attribute                */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_ATTRIBUTE;
%EJECT;
PARSE_BLANK: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip past 'BLANK' or 'BWZ'          */
    DO WHILE( TOKEN = 'WHEN'  OR       /* Ignore 'WHEN' or 'ZERO' if present  */
              TOKEN = 'ZERO' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_BLANK;
%EJECT;
PARSE_CLASS: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip past 'CLASS'                   */
    IF TOKEN = 'IS' THEN               /* Ignore 'IS' if it's present         */
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the class no we found it     */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_CLASS;
%EJECT;
PARSE_CONSTANT: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'CONSTANT' or 'DEFAULT'        */
    DO WHILE( TOKEN = 'VALUE'  OR      /* Ignore 'VALUE' and/or 'IS'          */
              TOKEN = 'IS' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    IF FLAG(CONSTANT##) THEN
         IF TOKEN = 'ALL' THEN
              CALL HANDLE_ALL_CLAUSE;
         ELSE IF SUBSTR(TOKEN,0,LENGTHC('"')) = '"' THEN
                   SUBSTR(TEMP.PICTURE,0,TOKEN_LEN-LENGTHC('""'))=
                                                     SUBSTR(TOKEN,LENGTHC('"'));
    CALL GET_TOKEN  ALTRET( OOPS );    /* Get token following the value       */
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_CONSTANT;
 
HANDLE_ALL_CLAUSE: PROC;
 
    CALL GET_TOKEN  ALTRET( OOPS );
    J= TOKEN_LEN - LENGTHC('""');
    DO I=0 TO ((TEMP.PIC_LEN/J)*J)-1 BY J;
      SUBSTR(TEMP.PICTURE,I,J)= SUBSTR(TOKEN,LENGTHC('"'));
      END;
    IF MOD(TEMP.PIC_LEN,J) ~= 0 THEN
         SUBSTR(TEMP.PICTURE,(TEMP.PIC_LEN/J)*J,MOD(TEMP.PIC_LEN,J))=
                                                     SUBSTR(TOKEN,LENGTHC('"'));
OOPS:
    RETURN;
 
END HANDLE_ALL_CLAUSE;
%EJECT;
PARSE_ERROR_MESSAGE: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'ERROR-MESSAGE'                */
    IF TOKEN = 'IS' THEN
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip the message now we found it    */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_ERROR_MESSAGE;
%EJECT;
PARSE_FILL: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'FILL'                         */
    DO WHILE( TOKEN = 'CHARACTER' OR   /* Ignore 'CHARACTER' and/or 'IS'      */
              TOKEN = 'IS' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the fill character           */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_FILL;
%EJECT;
PARSE_JUSTIFIED: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'JUST' or 'JUSTIFIED'          */
    IF TOKEN = 'RIGHT' THEN            /* Ignore 'RIGHT' if it's present      */
         CALL GET_TOKEN  ALTRET( OOPS );
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_JUSTIFIED;
%EJECT;
PARSE_MINIMUM: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'MINIMUM'                      */
    DO WHILE( TOKEN = 'SIZE'  OR       /* Ignore 'SIZE' and/or 'IS'           */
              TOKEN = 'IS' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the value now we found it    */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_MINIMUM;
%EJECT;
PARSE_PICTURE: PROC  ALTRET;
 
    DELIM= DELIMIT_PICS;            /* Tells GET_TOKEN not to stop on periods */
    TEMP.PICTURE= ' ';
    TEMP.PIC_LEN= 0;
SKIP_PIC_IS:
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip token past 'PIC' ['IS']           */
    IF TOKEN = 'IS' THEN
         GOTO SKIP_PIC_IS;
FIND_PAREN:
    CALL INDEX1( PAREN_POS,'(',TOKEN,TOKEN_POS ) ALTRET( NO_MORE_REP_CNTS );
    TMP= PAREN_POS - TOKEN_POS - 1;
    IF TMP > 0 THEN DO;
         SUBSTR(TEMP.PICTURE,TEMP.PIC_LEN,TMP)= SUBSTR(TOKEN,TOKEN_POS);
         TEMP.PIC_LEN= TEMP.PIC_LEN + TMP;
         TOKEN_POS= TOKEN_POS + TMP;
         END;
    CHR= SUBSTR(TOKEN,PAREN_POS,1);
    TMP= PAREN_POS + LENGTHC('(');
    CALL GET_NUM(REP_CNT)  ALTRET( OOPS );
    DO I=TEMP.PIC_LEN TO TEMP.PIC_LEN+REP_CNT-1;
      SUBSTR(TEMP.PICTURE,I,1)= SUBSTR(TOKEN,PAREN_POS-1,1);
      END;
    TEMP.PIC_LEN= TEMP.PIC_LEN + REP_CNT;
    TOKEN_POS= TMP + LENGTHC(')');
    GOTO FIND_PAREN;
 
NO_MORE_REP_CNTS:
    IF TOKEN_POS < TOKEN_LEN THEN DO;
         TMP= TOKEN_LEN - TOKEN_POS;
         SUBSTR(TEMP.PICTURE,TEMP.PIC_LEN,TMP)= SUBSTR(TOKEN,TOKEN_POS);
         TEMP.PIC_LEN= TEMP.PIC_LEN + TMP;
         END;
    DELIM= DELIMIT_MOST;
    CALL GET_TOKEN  ALTRET( OOPS ); /* Get the token that's past the picture  */
    RETURN;
 
OOPS:
    DELIM= DELIMIT_MOST;
    CALL GET_TOKEN  ALTRET( OOPS ); /* Get the token that's past the picture  */
    ALTRETURN;
 
END PARSE_PICTURE;
%EJECT;
PARSE_POSITION: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'POS' or 'POSITION'            */
    DO WHILE( TOKEN = 'IS'  OR         /* Ignore 'IS' and/or 'LINE'           */
              TOKEN = 'LINE' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_LINE# );
    CALL CONCAT( ME_BUF,'.. Expected ''LINE#'' ON POSITION; FOUND ->',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_LINE#:
    CALL CHARBIN( TEMP.LINE#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Get token following 'line#'         */
    IF TOKEN = 'COLUMN' THEN           /* Ignore it if it's 'COLUMN'          */
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_COLUMN# );
    CALL CONCAT( ME_BUF,'.. Expected ''column#''; Found ->',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_COLUMN#:
    CALL CHARBIN( TEMP.COLUMN#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    TEMP.COLUMN#= TEMP.COLUMN#;
    CALL GET_TOKEN  ALTRET( OOPS );    /* Get token following the 'column#'   */
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_POSITION;
%EJECT;
PARSE_PROMPT: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'PROMPT'                       */
    IF TOKEN = 'IS' THEN               /* Ignore 'IS' if present              */
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the prompt now we found it   */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_PROMPT;
%EJECT;
PARSE_REPEATS: PROC  ALTRET;
 
    DOING_A_REPEAT= %YES#;
    IF FIRST_LEVEL# = 0 THEN
         FIRST_LEVEL#= TEMP.LEVEL#;
    CALL GET_TOKEN  ALTRET( OOPS );
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_REPEAT# );
    CALL CONCAT( ME_BUF,'.. Expected repeat#; Found -> ',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_REPEAT#:
    CALL CHARBIN( TEMP.REPEAT#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    CALL GET_TOKEN  ALTRET( OOPS );
    TEMP.SEPARATED#= 1;
    IF TOKEN = 'TIMES' THEN
         CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN ~= 'SEPARATED' THEN
         GOTO RET;
    CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN = 'BY' THEN
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_SEPARATED# );
    CALL CONCAT( ME_BUF,'.. Expected separated#; Found -> ',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_SEPARATED#:
    CALL CHARBIN( TEMP.SEPARATED#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    CALL GET_TOKEN  ALTRET( OOPS );
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_REPEATS;
%EJECT;
PARSE_USAGE: PROC  ALTRET;
 
    CALL GET_TOKEN  ALTRET( OOPS );    /* Skip 'USAGE'                        */
    IF TOKEN = 'IS' THEN               /* Ignore 'IS' if it's present         */
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL GET_TOKEN  ALTRET( OOPS );    /* Ignore the usage now we found it    */
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_USAGE;
%EJECT;
PARSE_ORIGIN: PROC  ALTRET;
 
    IF TOKEN ~= 'ORIGIN' THEN DO;
         CALL CONCAT( ME_BUF,'.. Strange FR record -> ',FPL_BUF );
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
         GOTO OOPS;
         END;
    CALL GET_TOKEN  ALTRET( OOPS );
    DO WHILE( TOKEN = 'IS' OR
              TOKEN = 'LINE' );
      CALL GET_TOKEN  ALTRET( OOPS );
      END;
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_LINE# );
    CALL CONCAT( ME_BUF,'.. Expected ''line#'' on ORIGIN; Found ->',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_LINE#:
    CALL CHARBIN( TMP_ORIGIN_LINE#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    IF TMP_ORIGIN_LINE# > 0 THEN
         TMP_ORIGIN_LINE#= TMP_ORIGIN_LINE# - 1;
    CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN = 'COLUMN' THEN
         CALL GET_TOKEN  ALTRET( OOPS );
    CALL SEARCH( TMP,TABLEVAL,SKIP_DIGITS,SUBSTR(TOKEN,0,TOKEN_LEN) )
                                              ALTRET( FOUND_COLUMN# );
    CALL CONCAT( ME_BUF,'.. Expected ''column#'' on ORIGIN; Found -> ',TOKEN );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    GOTO OOPS;
FOUND_COLUMN#:
    CALL CHARBIN( TMP_ORIGIN_COLUMN#,SUBSTR(TOKEN,0,TOKEN_LEN) );
    IF TMP_ORIGIN_COLUMN# > 0 THEN
         TMP_ORIGIN_COLUMN#= TMP_ORIGIN_COLUMN# - 1;
    CALL GET_TOKEN  ALTRET( OOPS );
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_ORIGIN;
%EJECT;
PARSE_CCBUF: PROC  ALTRET;
 
    IF B$JIT.CCDISP = 0 THEN
         CALL INDEX1( I,'(',B$JIT.CCBUF );
    ELSE I= B$JIT.CCDISP;
    CCBUF_CMD= %NO#;
    CMD_NUM= 0;
    NUM_CMDS= 0;
    IF I < B$JIT.CCARS THEN DO;
         CCBUF_CMD= %YES#;
         IF SUBSTR(B$JIT.CCBUF,I) = '(' THEN DO;
              ERR_BUF= 'PRINT IF';
              L= LENGTHC('PRINT IF');
              END;
         ELSE DO;
              I= I+1;                         /* Skip the '('                 */
              L= B$JIT.CCARS - I;
              ERR_BUF= SUBSTR(B$JIT.CCBUF,I,L);
              END;
         CALL XUR$GETCMD( OVERLAP_NODES,BLK1$,VECTOR(PROMPT),ERR_BUF,L )
                                                          ALTRET( PARSE_ERROR );
         CMD_NUM= -1;            /* Tell GET_A_CMD to process first cmd next */
         NUM_CMDS= BLK1_NSUBLKS;
         END;
    RETURN;
 
PARSE_ERROR:
    NUM_CMDS= 0;
    ERRCODE= PERRCODE;
    IF NOT ERRCODE.MON  AND
       ERRCODE.ERR# = %E$SYNERR THEN DO;
         CALL XUR$ECHO( M$ME# );
         CALL XUR$ERRPTR( ,M$LO# );
         END;
    CALL XUR$ERRMSG( ERRCODE );
    ALTRETURN;
 
END PARSE_CCBUF;
%EJECT;
LEE$CLOSE: PROC( DCB#,DISPOSITION );
DCL DCB#                     SBIN;
DCL DISPOSITION              SBIN;
 
    CLOSEF.V.DCB#= DCB#;
    IF ADDR(DISPOSITION) ~= ADDR(NIL)  AND
       DISPOSITION = %RELEASE#  THEN
         CLOSEF.V.DISP#= %RELEASE#;
    ELSE CLOSEF.V.DISP#= %SAVE#;
    CALL M$CLOSE( CLOSEF )  ALTRET( WHO_CARES );
WHO_CARES:
    RETURN;
 
END LEE$CLOSE;
%EJECT;
LEE$CORRES: PROC( DCB1#,DCB2#,FLAG );
DCL DCB1#                    SBIN;
DCL DCB2#                    SBIN;
DCL FLAG                     BIT(1);
 
    CORRES.V.DCB1#= DCB1#;
    CORRES.V.DCB2#= DCB2#;
    FLAG= %NO#;
    CALL M$CORRES( CORRES )  ALTRET( SAME );
    FLAG= %YES#;
SAME:
    RETURN;
 
END LEE$CORRES;
%EJECT;
LEE$INIT: PROC  ALTRET;
 
    FPL$=  DCBADDR(DCBNUM(FPL));
    M$LO$= DCBADDR(M$LO#);
    M$ME$= DCBADDR(M$ME#);
    M$SI$= DCBADDR(M$SI#);
    BRK_CNT= 0;
    CALL M$INT( BREAK_CNTRL )  ALTRET( OOPS );
    CALL M$OPEN( OPEN_ME )     ALTRET( OOPS );
    CALL LEE$OPEN( M$LO# )     ALTRET( OOPS );
    CALL M$UNFID( UNFID_LO )   ALTRET( OOPS );
    CALL XUR$INIT( XUR_INIT );
    CALL XUR$SETDCBS( M$SI#,M$ME# )  ALTRET( OOPS );
    CALL LEE$CORRES( M$LO#,M$ME#,LONEME );
    CALL LEE$WRITE( GREETING,-LENGTHC(GREETING),M$ME# );
    IF LONEME  AND
       NOT B$JIT.PRFLAGS.LS  THEN DO;
         CALL CONCAT( ME_BUF,OUTPUT_WARNING,PREV_LO_FID );
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
         END;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END LEE$INIT;
%EJECT;
LEE$MONERR: PROC( ERR,DCB# );
DCL ERR                      BIT(36);
DCL DCB#                     UBIN;
 
    IF ADDR(ERR) = ADDR(NIL) THEN
         ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    ELSE ERRCODE= ERR;
    IF ADDR(DCB#) = ADDR(NIL) THEN
         ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
    ELSE ERRMSG.V.DCB#= DCB#;
    CALL M$ERRMSG( ERRMSG );
    RETURN;
 
END LEE$MONERR;
%EJECT;
LEE$OPEN: PROC( DCB# )  ALTRET;
DCL DCB#                     SBIN;
 
    OPENF.V.DCB#= DCB#;
    CALL M$OPEN( OPENF )  ALTRET( OOPS );
    RETURN;
 
OOPS:
    ALTRETURN;
 
END LEE$OPEN;
%EJECT;
LEE$WRITE: PROC( BUF,LEN,DCB#,WE_SHOULD_ECHO )  ALTRET;
DCL BUF                      CHAR(BUFLEN);
DCL LEN                      SBIN;
DCL DCB#                     SBIN;
DCL WE_SHOULD_ECHO           BIT(1);
 
DCL BUFLEN                   SBIN;
 
    IF LEN < 0 THEN DO;
         BUFLEN= -LEN;
         CALL SEARCHR( BUFLEN,TABLEVAL,SKIP_BLANKS,BUF )  ALTRET( BLANK_LINE );
         BUFLEN= BUFLEN + 1;
         END;
    ELSE IF LEN = 0 THEN
BLANK_LINE:
              BUFLEN= LENGTHC(' ');
         ELSE BUFLEN= LEN;
    WRITEF.BUF_= VECTOR(BUF);
    WRITEF.V.DCB#= DCB#;
    IF ADDR(WE_SHOULD_ECHO) ~= ADDR(NIL)  AND
       LONEME THEN DO;
         CALL M$WRITE( WRITEF )  ALTRET( OOPS );
         WRITEF.V.DCB#= M$ME#;
         END;
    CALL M$WRITE( WRITEF )  ALTRET( OOPS );
    RETURN;
 
OOPS:
    ALTRETURN;
 
END LEE$WRITE;
%EJECT;
ADD_REPEAT_FIELD: PROC;
 
    IF TEMP.COLUMN# <= 0 AND TEMP.REPEAT# <= 0 AND TEMP.PIC_LEN <= 0 THEN
       ;
    ELSE DO;
       R(R_CNT)= TEMP;
       R_CNT= R_CNT + 1;
       END;
    RETURN;
 
END ADD_REPEAT_FIELD;
%EJECT;
PROCESS_REPEATS: PROC  ALTRET;
 
    IF R_CNT = 1 THEN DO;
         /* The only REPEATed item repeats horizontally. */
         CALL ONE_D_ELEM_REP  ALTRET( OOPS );
         GOTO RET;
         END;
 
ONE_DIM_VERT_REP:
    DO I=1 TO R_CNT-1;
      IF R.REPEAT#(I) > 0 THEN
           GOTO TWO_DIM_GRP_REP;
      END;
    /* One REPEAT was found.  It is on a GROUP item so all subordinate        */
    /* elementary items will REPEAT vertically.                               */
    CALL ONE_D_VERT_REP ALTRET( OOPS );
    GOTO RET;
 
TWO_DIM_GRP_REP:
    IF R_CNT = 2  AND
       R.REPEAT#(1) > 0 THEN DO;
         /* Two REPEATs were found.  The first is a GROUP repeat (so it       */
         /* REPEATs vertically).  The second REPEAT is on an elementary item  */
         /* (so it repeats horizontally) which is subordinate to the GROUP    */
         /* REPEAT.                                                           */
         CALL TWO_D_GRP_ELEM  ALTRET( OOPS );
         GOTO RET;
         END;
 
    IF R.REPEAT#(0) <= 0     OR
       R.PICTURE(0) ~= ' '   OR
       R.REPEAT#(1) <= 0     OR
       R.PICTURE(1) ~= ' '  THEN
     /*R_CNT > 3            THEN */
         GOTO IS_IT_MULTI_REP_INA_GRP_REP;
    DO I=2 TO R_CNT-1;
      IF R.REPEAT#(I) > 0 OR
         R.PICTURE(I) = ' ' THEN
           GOTO IS_IT_MULTI_REP_INA_GRP_REP;
      END;
    /* Two REPEATs were found.  Both were on GROUP items so elementary items  */
    /* will be REPEATed both vertically and horizontally.                     */
    CALL TWO_D_GRP_REP  ALTRET( OOPS );
    GOTO RET;
 
IS_IT_MULTI_REP_INA_GRP_REP:
    DO I=1 TO R_CNT-1;
       IF R.REPEAT#(I) <= 0  OR  R.PICTURE(I) = ' ' THEN
          GOTO CANT_DO_IT;
       END;
 
    CALL MULTI_REP_INA_GRP_REP  ALTRET( OOPS );
    GOTO RET;
 
CANT_DO_IT:
    FRAME_NOT_RIGHT= %YES#;
 
RET:
    DOING_A_REPEAT= %NO#;
    FIRST_LEVEL#= 0;
    R_CNT= 0;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PROCESS_REPEATS;
%EJECT;
ONE_D_ELEM_REP: PROC ALTRET;
 
    ORIGIN_LINE#= TMP_ORIGIN_LINE#;
    ORIGIN_COLUMN#= TMP_ORIGIN_COLUMN#;
    TEMP= R(0);
    TEMP.LINE#= TEMP.LINE# + ORIGIN_LINE#;
    TEMP.COLUMN#= TEMP.COLUMN# + ORIGIN_COLUMN#;
    DO I=1 TO TEMP.REPEAT#;
      CALL ADD_FIELD  ALTRET( OOPS );
      TEMP.COLUMN#= TEMP.COLUMN# + TEMP.PIC_LEN + TEMP.SEPARATED#;
      END;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END ONE_D_ELEM_REP;
%EJECT;
ONE_D_VERT_REP: PROC ALTRET;
 
    ORIGIN_LINE#= TMP_ORIGIN_LINE#;
    ORIGIN_COLUMN#= TMP_ORIGIN_COLUMN#;
    O= 999;
    P= 0;
    DO J=1 TO R_CNT-1;
      IF R.LINE#(J) < O THEN
           O= R.LINE#(J);
      IF R.LINE#(J) > P THEN
           P= R.LINE#(J);
      END;
    DO I=1 TO R.REPEAT#(0);
      DO J=1 TO R_CNT-1;
        IF I=1 THEN
             R.LINE#(J)= R.LINE#(J) + TMP_ORIGIN_LINE#;
        TEMP= R(J);
        TEMP.COLUMN#= TEMP.COLUMN# + TMP_ORIGIN_COLUMN#;
        CALL ADD_FIELD  ALTRET( OOPS );
        R.LINE#(J)= R.LINE#(J) + R.SEPARATED#(0) + P - O;
        END;
      END;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END ONE_D_VERT_REP;
%EJECT;
TWO_D_GRP_ELEM: PROC  ALTRET;
 
    R.LINE#(1)= R.LINE#(1) + TMP_ORIGIN_LINE#;
 
    DO I=1 TO R.REPEAT#(0);
      COL#(I)= R.COLUMN#(1) + TMP_ORIGIN_COLUMN#;
      END;
    DO I=1 TO R.REPEAT#(0);
      DO J=1 TO R.REPEAT#(1);
        TEMP= R(1);
        CALL ADD_FIELD  ALTRET( OOPS );
        R.COLUMN#(1)= R.COLUMN#(1) + R.PIC_LEN(1) + R.SEPARATED#(1);
        END;
      R.COLUMN#(1)= COL#(1);
      R.LINE#(1)= R.LINE#(1) + R.SEPARATED#(0);
      END;
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END TWO_D_GRP_ELEM;
%EJECT;
TWO_D_GRP_REP: PROC  ALTRET;
 
    O= 999;
    P= 0;
    Q= 999;
    S= 0;
    DO I=2 TO R_CNT-1;
      R.COLUMN#(I)= R.COLUMN#(I) + TMP_ORIGIN_COLUMN#;
      COL#(I)= R.COLUMN#(I);
      IF R.COLUMN#(I) < Q THEN
           Q= R.COLUMN#(I);
      IF R.COLUMN#(I)+R.PIC_LEN(I) > S THEN
           S= R.COLUMN#(I)+R.PIC_LEN(I);
      R.LINE#(I)= R.LINE#(I) + TMP_ORIGIN_LINE#;
      IF R.LINE#(I) < O THEN
           O= R.LINE#(I);
      IF R.LINE#(I) > P THEN
           P= R.LINE#(I);
      END;
 
    DO I=1 TO R.REPEAT#(0);
      DO J=1 TO R.REPEAT#(1);
        DO K=2 TO R_CNT-1;
          TEMP= R(K);
          CALL ADD_FIELD  ALTRET( OOPS );
          R.COLUMN#(K)= R.COLUMN#(K) + R.SEPARATED#(1) + S - Q;
          END;
        END;
      DO J=2 TO R_CNT-1;
        R.COLUMN#(J)= COL#(J);
        R.LINE#(J)= R.LINE#(J) + R.SEPARATED#(0) + P - O;
        END;
      END;
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END TWO_D_GRP_REP;
%EJECT;
MULTI_REP_INA_GRP_REP: PROC  ALTRET;
 
    LINE_BIAS= TMP_ORIGIN_LINE#;
    DO I=1 TO R.REPEAT#(0);
       LOW_LINE#= 999;
       HIGH_LINE#= 0;
       DO J=1 TO R_CNT-1;
          TEMP= R(J);
          TEMP.LINE#= TEMP.LINE# + LINE_BIAS;
          TEMP.COLUMN#= TEMP.COLUMN# + TMP_ORIGIN_COLUMN#;
          DO K=1 TO TEMP.REPEAT#;
             CALL ADD_FIELD  ALTRET( OOPS );
             TEMP.COLUMN#= TEMP.COLUMN# + TEMP.PIC_LEN + TEMP.SEPARATED#;
             END;
          IF TEMP.LINE# < LOW_LINE# THEN
             LOW_LINE#= TEMP.LINE#;
          IF TEMP.LINE# > HIGH_LINE# THEN
             HIGH_LINE#= TEMP.LINE#;
          END;
       LINE_BIAS= LINE_BIAS + (HIGH_LINE# - LOW_LINE#) + R.SEPARATED#(0);
       END;
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END MULTI_REP_INA_GRP_REP;
%EJECT;
FIND_PROGRAM_ID: PROC  ALTRET;
 
    TOKEN= ' ';
FIND_PGM_ID:
    DO WHILE( TOKEN ~= 'PROGRAM-ID' );
      FPL_POS= 72;
      CALL GET_TOKEN  ALTRET( OOPS );
      END FIND_PGM_ID;
    CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN = '.' THEN
         CALL GET_TOKEN  ALTRET( OOPS );
    PROGRAM_ID= TOKEN;
    TOKEN= ' ';
    RETURN;
 
OOPS:
    ME_BUF= '.. That''s no FPL program!  I quit!';
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
END FIND_PROGRAM_ID;
%EJECT;
FIND_FRAME_SECTION: PROC  ALTRET;
 
FIND_FRAME_SEC:
    DO WHILE( TOKEN ~= 'FRAME' );
      FPL_POS= 72;
      CALL GET_TOKEN   ALTRET( OOPS );
      END FIND_FRAME_SEC;
    CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN ~= 'SECTION' THEN
         GOTO FIND_FRAME_SEC;
    CHR= ' ';
    RETURN;
 
OOPS:
    ME_BUF= '.. That''s a strange FPL program!  No FRAME SECTION!  I quit!';
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
END FIND_FRAME_SECTION;
%EJECT;
FIND_FR: PROC  ALTRET;
 
FIND_FR_FRAMENAME:
    FPL_POS= 72;
    CALL GET_TOKEN  ALTRET( OOPS );
    IF TOKEN ~= 'FR' THEN DO;
         ME_BUF= '.. FR ... didn''t immediately follow FRAME SECTION';
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
         GOTO FIND_FR_FRAMENAME;
         END;
    RETURN;
 
OOPS:
    ME_BUF= '.. It''s not nice to try to fool mother nature (or OVERLAP)!';
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ME_BUF= '.. I couldn''t find any FR frame-name clauses; so I quit!';
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
END FIND_FR;
%EJECT;
 
FIND_FDS: PROC  ALTRET;
 
    TOKEN= ' ';
FIND_FD:
      DO WHILE( TOKEN ~= 'FD' );  /* Looking for 'FD fd-name FRAMEs ARE ... */
        FPL_POS= 72;
        CALL GET_TOKEN  ALTRET( NO_FDS );
        IF TOKEN = 'WORKING-STORAGE' THEN
             GOTO RET;
        END FIND_FD;
      DO WHILE( TOKEN = 'FD' );
        CALL GET_TOKEN  ALTRET( STRANGE_FD ); /* Get the 'fd-name'            */
        TMP_FD_NAME= TOKEN;
        CALL GET_TOKEN  ALTRET( STRANGE_FD );
        IF TOKEN ~= 'FRAME'  AND              /* We don't want it unless it   */
           TOKEN ~= 'FRAMES'  THEN
             GOTO FIND_FD;                    /* has FRAME or FRAMES here     */
        CALL GET_TOKEN  ALTRET( STRANGE_FD );
        DO WHILE( TOKEN = 'IS'  OR
                  TOKEN = 'ARE' );
          CALL GET_TOKEN  ALTRET( STRANGE_FD );
          END;
        NUM_FDS= NUM_FDS + 1;
        CALL INDEX1( I,' ',TMP_FD_NAME );
        FDS.LEN(NUM_FDS)= I;
        FDS.NAME(NUM_FDS)= TMP_FD_NAME;
        FDS.FIRST_FRAME(NUM_FDS)= -1;
        FDS.NUM_FRAMES(NUM_FDS)= 0;
        DO WHILE( TOKEN ~= '.' );
          NUM_FRAMES= NUM_FRAMES + 1;
          IF FDS.FIRST_FRAME(NUM_FDS) = -1 THEN
               FDS.FIRST_FRAME(NUM_FDS)= NUM_FRAMES;
          FDS.NUM_FRAMES(NUM_FDS)= FDS.NUM_FRAMES(NUM_FDS) + 1;
          FRAMES.FD_INDX(NUM_FRAMES)= NUM_FDS;
          CALL INDEX1( I,' ',SUBSTR(TOKEN,0,31) );
          FRAMES.LEN(NUM_FRAMES)= I;
          FRAMES.NAME(NUM_FRAMES)= TOKEN;
          CALL GET_TOKEN  ALTRET( STRANGE_FD );
          END;
        CALL GET_TOKEN  ALTRET( STRANGE_FD ); /* Skip past the '.'            */
        END;
RET:
      RETURN;
 
NO_FDS:
    ME_BUF= '.. That''s a strange FPL program (No FDs) so I quit';
    GOTO PUT_ERROR;
 
STRANGE_FD:
    ME_BUF= '.. Funny FD encountered.  -> ';
    SUBSTR(ME_BUF,31)= FPL_BUF;
PUT_ERROR:
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
END FIND_FDS;
%EJECT;
GET_A_CMD: PROC  ALTRET;
 
ANOTHER:
    CMD_NUM= CMD_NUM + 1;
    IF CMD_NUM >= NUM_CMDS THEN
         IF CCBUF_CMD THEN DO;
              CMD#= END##;
              GOTO RET;
              END;
         ELSE DO;
              CMD_NUM= 0;
              CALL XUR$GETCMD( OVERLAP_NODES,BLK1$,VECTOR(PROMPT) )
                                                         ALTRET( SYNERR );
              CALL XUR$ECHOIF( M$LO# );
              NUM_CMDS= BLK1_NSUBLKS;
              END;
    BLK2$= BLK1_SUBLK$(CMD_NUM);
    IF BLK2_NSUBLKS > 0 THEN DO;
         BLK3$= BLK2_SUBLK$(0);
         IF BLK3_NSUBLKS > 0 THEN
              BLK4$= BLK3_SUBLK$(0);
         END;
 
    CMD#= BLK2_CODE;
    DO CASE( CMD# );
      CASE( CLEAR## );
 
      CASE( CHECK## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
        CALL PARSE_SELECT  ALTRET( ANOTHER );
 
      CASE( END## );
 
      CASE( HELP## );
 
      CASE( LIST## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
      CASE( NULL## );
 
      CASE( OUTPUT## );
 
      CASE( PRINT## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
        CALL PARSE_SELECT  ALTRET( ANOTHER );
      CASE( PRINT_CHECK## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
        CALL PARSE_SELECT  ALTRET( ANOTHER );
      CASE( PRINT_IF## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
        CALL PARSE_SELECT  ALTRET( ANOTHER );
 
      CASE( READ## );
 
      CASE( SELECT## );
        CALL SEE_IF_FILE_IS_OPEN  ALTRET( ANOTHER );
        CALL PARSE_SELECT  ALTRET( ANOTHER );
      CASE( USE## );
        CALL PARSE_USE  ALTRET( ANOTHER );
      END;
RET:
    RETURN;
 
SYNERR:
    NUM_CMDS= 0;
    ERRCODE= PERRCODE;
    CALL XUR$ECHOIF( M$LO# );
    IF NOT ERRCODE.MON THEN
         IF ERRCODE.ERR# = %E$SYNERR THEN DO;
              CALL XUR$ERRPTR( ,M$LO# );
              IF LONEME THEN
                   CALL XUR$ERRPTR( ,M$ME# );
              END;
         ELSE;
    ELSE IF ERRCODE.ERR# = %E$EOF THEN
              IF DCBADDR(DCBNUM(M$SI))->F$DCB.ASN# = %FILE# THEN DO;
                   FID_STRING= 'ME';
                   CALL M$FID( FID_SI )  ALTRET( OOPS );
                   CALL LEE$CLOSE( DCBNUM(M$SI) );
                   CALL M$OPEN( OPEN_SI )  ALTRET( OOPS );
                   NUM_CMDS= 0;
                   GOTO ANOTHER;
                   END;
              ELSE DO;
                   DONE= %YES#;
                   ALTRETURN;
                   END;
OOPS:
    CALL XUR$ERRMSG( ERRCODE );
    ALTRETURN;
 
END GET_A_CMD;
%EJECT;
PARSE_SELECT: PROC  ALTRET;
 
    FIRST_FRAME= %YES#;
    FIRST_LINE#= %YES#;
    DO I=0 TO BLK2_NSUBLKS-1;
      BLK3$= BLK2_SUBLK$(I);
      DO CASE( BLK3_CODE );
        CASE( FRAMES## );
          CALL PARSE_SELECT_FRAMES  ALTRET( OOPS );
        CASE( LINES## );
          CALL PARSE_SELECT_LINES   ALTRET( OOPS );
        CASE( ELSE );
          INDX= BLK3$->P_SYM.CPOS;
          CALL XUR$ERRPTR( INDX,M$ME# );
          ME_BUF= '.. PARTRGE knows an option on selections that I don''t!';
          CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
          GOTO OOPS;
        END;
      END;
    IF BLK2_NSUBLKS = 0 THEN
         CALL DEFAULT  ALTRET( OOPS );
    ELSE CALL BUILD_WORK  ALTRET( OOPS );
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PARSE_SELECT;
%EJECT;
PARSE_SELECT_FRAMES: PROC  ALTRET;
 
    IF FIRST_FRAME THEN DO;
         FIRST_FRAME= %NO#;
         NUM_REQUESTS= 0;
         END;
    TOKEN= BLK3_TEXT;
    DO INDX=1 TO NUM_FRAMES;
      IF TOKEN = FRAMES.NAME(INDX) THEN
           GOTO LOAD_FRAME;
      END;
    DO INDX=1 TO NUM_FDS;
      IF TOKEN = FDS.NAME(INDX) THEN
           GOTO CNVT_FD_TO_FRAMES;
      END;
    INDX= BLK3$->P_SYM.CPOS;
    CALL XUR$ERRPTR( INDX,M$ME# );
    CALL CONCAT( ME_BUF,'.. Form/Frame was not found in ',FPL_FID );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
CNVT_FD_TO_FRAMES:
    DO J=FDS.FIRST_FRAME(INDX) TO FDS.FIRST_FRAME(INDX)+FDS.NUM_FRAMES(INDX)-1;
      NUM_REQUESTS= NUM_REQUESTS + 1;
      REQUEST.FD_INDX(NUM_REQUESTS)= -1;
      REQUEST.FRAME_INDX(NUM_REQUESTS)= J;
      REQUEST.LEN(NUM_REQUESTS)= FRAMES.LEN(J);
      REQUEST.NAME(NUM_REQUESTS)= FRAMES.NAME(J);
      END;
    GOTO RET;
 
LOAD_FRAME:
    NUM_REQUESTS= NUM_REQUESTS + 1;
    REQUEST.FD_INDX(NUM_REQUESTS)= -1;
    REQUEST.FRAME_INDX(NUM_REQUESTS)= INDX;
    REQUEST.LEN(NUM_REQUESTS)= FRAMES.LEN(INDX);
    REQUEST.NAME(NUM_REQUESTS)= FRAMES.NAME(INDX);
RET:
    RETURN;
 
END PARSE_SELECT_FRAMES;
%EJECT;
PARSE_SELECT_LINES: PROC  ALTRET;
 
    BLK4$= BLK3_SUBLK$(0);
    CALL CHARBIN( LINE1,BLK4_TEXT );
    IF BLK3_NSUBLKS = 2 THEN DO;
         BLK4$= BLK3_SUBLK$(1);
         CALL CHARBIN( LINE2,BLK4_TEXT );
         END;
    ELSE LINE2= LINE1;
    IF LINE1 < 1 THEN DO;
         ME_BUF= '.. Line number(s) must be greater than 1';
         GOTO OOPS;
         END;
    IF LINE2 < LINE1 THEN DO;
         ME_BUF= '.. First line number in a range must be the lowest';
         GOTO OOPS;
         END;
    IF FIRST_LINE# THEN DO;
         FIRST_LINE#= %NO#;
         LINE#S_TBL= '0'B;
         END;
    DO J=LINE1 TO LINE2;
      LINE#S(J)= J;
      END;
    RETURN;
 
OOPS:
    INDX= BLK3_SUBLK$(0)->P_SYM.CPOS;
    CALL XUR$ERRPTR( INDX,M$ME# );
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
    ALTRETURN;
 
END PARSE_SELECT_LINES;
%EJECT;
DEFAULT: PROC  ALTRET;
 
    DO X=1 TO NUM_FDS;
      NUM_REQUESTS= 0;
      DO I=FDS.FIRST_FRAME(X) TO FDS.FIRST_FRAME(X)+FDS.NUM_FRAMES(X)-1;
        NUM_REQUESTS= NUM_REQUESTS + 1;
        REQUEST.FRAME_INDX(NUM_REQUESTS)= I;
        REQUEST.LEN(NUM_REQUESTS)= FRAMES.LEN(I);
        REQUEST.NAME(NUM_REQUESTS)= FRAMES.NAME(I);
        END;
      DO I=0 TO HIGHEST_LINE#;
        LINE#S(I)= 1;
        END;
      CALL BUILD_WORK  ALTRET( OOPS );
      IF CMD# = CHECK## THEN
           CALL DO_CHECK;
      ELSE CALL PRINT_FRAME;
      END;
OOPS:
    ALTRETURN;
 
END DEFAULT;
%EJECT;
PARSE_USE: PROC  ALTRET;
 
    DO I=0 TO BLK2_NSUBLKS-1;
      BLK3$= BLK2_SUBLK$(I);
      DO CASE( BLK3_CODE );
        CASE( AFID## );
          FID_STRING= BLK3_TEXT;
        CASE( ELSE );
          ME_BUF= '.. PARTRGE knows of an USE option that I don''t!';
          CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
          ALTRETURN;
        END;
      END;
    RETURN;
 
END PARSE_USE;
%EJECT;
BUILD_WORK: PROC  ALTRET;
 
    CALL LEE$CLOSE( DCBNUM(M$WORK),%RELEASE# );
    CALL LEE$OPEN( DCBNUM(M$WORK) )  ALTRET( OOPS );
    CALL M$PFIL( BOF_SCREEN )  ALTRET( OOPS );
    KEY2.LINE#= 'xx';
    DO WHILE('1'B);
      CALL M$READ( READS_SCREEN )  ALTRET( EOF_HIT );
      CALL CONCAT( TOKEN,KEY.FRAME,KEY.LINE# );
      CALL WANT_IT  ALTRET( NEXT_SCREEN );
      IF KEY2.LINE# ~= KEY.LINE# THEN DO;
           IF KEY2.LINE# ~= 'xx' THEN DO;
                WRITE_WORK.BUF_.BOUND= (LENGTHC(REC2.V(0)) * REC2.NUM_FIELDS) +
                                       LENGTHC(REC2.NUM_FIELDS) - 1;
                CALL M$WRITE( WRITE_WORK )  ALTRET( NEXT_SCREEN );
                END;
           KEY2.LINE#= KEY.LINE#;
           CALL M$READ( READ_WORK )  ALTRET( NEW_WORK_REC );
           END;
      DO WHILE('0'B);
NEW_WORK_REC:
        KEY2.LINE#= KEY.LINE#;
        REC2.NUM_FIELDS= 0;
        END;
      J= 0;
      DO I=REC2.NUM_FIELDS TO REC2.NUM_FIELDS+REC.NUM_FIELDS-1;
        DO K=1 TO NUM_REQUESTS;
          IF REC.V.FRAME(J) = REQUEST.NAME(K) THEN DO;
               REC2.V(I)= REC.V(J);
               J= J + 1;
               GOTO GET_ANOTHER;
               END;
          END;
GET_ANOTHER:
        END;
      IF J > 0 THEN
           REC2.NUM_FIELDS= REC2.NUM_FIELDS + J;
NEXT_SCREEN:
      END;
EOF_HIT:
    KEY.LEN= LENGTHC(KEY.LINE#)+LENGTHC(KEY.FRAME);
    WRITE_WORK.BUF_.BOUND= (LENGTHC(REC2.V(0)) * REC2.NUM_FIELDS) +
                           LENGTHC(REC2.NUM_FIELDS) - 1;
    CALL M$WRITE( WRITE_WORK );
    CALL SORT_WORK;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END BUILD_WORK;
%EJECT;
WANT_IT: PROC  ALTRET;
 
    DO I=1 TO NUM_REQUESTS;
      IF SUBSTR(TOKEN,0,31) = REQUEST.NAME(I) THEN
           GOTO CHECK_LINE#;
      END;
    ALTRETURN;
CHECK_LINE#:
    CALL CHARBIN( J,SUBSTR(TOKEN,31,2) );
    IF LINE#S(J) > 0 THEN
         RETURN;
    ELSE ALTRETURN;
 
END WANT_IT;
%EJECT;
SORT_WORK: PROC;
 
    CALL M$PFIL( BOF_WORK )  ALTRET( SORT_EM );
    KEY2.LEN= LENGTHC(KEY2.LINE#);
SORT_EM:
    DO WHILE('1'B);
      CALL M$READ( READS_WORK )  ALTRET( EOF_HIT );
      UNSORTED= %YES#;
      DO WHILE( UNSORTED );
        UNSORTED= %NO#;
        DO I=0 TO REC2.NUM_FIELDS-2;
          IF REC2.V.COLUMN(I) > REC2.V.COLUMN(I+1) THEN DO;
               REC2.V(REC2.NUM_FIELDS)= REC2.V(I+1);
               REC2.V(I+1)= REC2.V(I);
               REC2.V(I)= REC2.V(REC2.NUM_FIELDS);
               UNSORTED= %YES#;
               END;
          END;
        END;
      WRITE_WORK.BUF_.BOUND= (LENGTHC(REC2.V(0)) * REC2.NUM_FIELDS) +
                             LENGTHC(REC2.NUM_FIELDS) - 1;
      CALL M$WRITE( WRITE_WORK );
NEXT_REC:
      END;
EOF_HIT:
    KEY2.LEN= LENGTHC(KEY2.LINE#);
    RETURN;
 
END SORT_WORK;
%EJECT;
LIST_FRAMES: PROC;
 
    DO I=1 TO NUM_REQUESTS;
      IF ME_INDX+REQUEST.LEN(I)+LENGTHC(',') >= 80 THEN DO;
           CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
           ME_BUF= ' ';
           ME_INDX= CONT_COL;
           END;
      SUBSTR(ME_BUF,ME_INDX)= REQUEST.NAME(I);
      CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
      IF I < NUM_REQUESTS THEN DO;
           SUBSTR(ME_BUF,ME_INDX+1)= ', ';
           ME_INDX= ME_INDX + LENGTHC(', ');
           END;
      END;
    CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
    RETURN;
 
END LIST_FRAMES;
%EJECT;
PUT_ERROR_CNTS: PROC;
 
    IF OVERLAP_CNT + ADJACENT_CNT > 0 THEN DO;
         FILE_HAD_ERRORS= %YES#;
         IF OVERLAP_CNT > 0 THEN DO;
              IF OVERLAP_CNT = 1 THEN DO;
                   CALL X$WRITE( F_FDS,FMT1_,VECTOR(OVERLAP_CNT) );
                   IF LONEME THEN DO;
                        F_FDS.DCB#= M$LO#;
                        CALL X$WRITE( F_FDS,FMT1_,VECTOR(OVERLAP_CNT) );
                        F_FDS.DCB#= M$ME#;
                        END;
                   END;
              ELSE DO;
                   CALL X$WRITE( F_FDS,FMT2_,VECTOR(OVERLAP_CNT) );
                   IF LONEME THEN DO;
                        F_FDS.DCB#= M$LO#;
                        CALL X$WRITE( F_FDS,FMT2_,VECTOR(OVERLAP_CNT) );
                        F_FDS.DCB#= M$ME#;
                        END;
                   END;
              END;
         IF ADJACENT_CNT > 0 THEN DO;
              IF ADJACENT_CNT = 1 THEN DO;
                   CALL X$WRITE( F_FDS,FMT3_,VECTOR(ADJACENT_CNT) );
                   IF LONEME THEN DO;
                        F_FDS.DCB#= M$LO#;
                        CALL X$WRITE( F_FDS,FMT3_,VECTOR(ADJACENT_CNT) );
                        F_FDS.DCB#= M$ME#;
                        END;
                   END;
              ELSE DO;
                   CALL X$WRITE( F_FDS,FMT4_,VECTOR(ADJACENT_CNT) );
                   IF LONEME THEN DO;
                        F_FDS.DCB#= M$LO#;
                        CALL X$WRITE( F_FDS,FMT4_,VECTOR(ADJACENT_CNT) );
                        F_FDS.DCB#= M$ME#;
                        END;
                   END;
              END;
         END;
    ELSE DO;
         IF BLK2_NSUBLKS = 0 THEN
              CALL CONCAT( ME_BUF,'.. No errors detected in Form ',
                             FDS.NAME(X) );
         ELSE ME_BUF= '.. No errors detected';
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
         END;
    RETURN;
 
END PUT_ERROR_CNTS;
%EJECT;
PUT_FMT5_OR_6: PROC( CNT,FMT_ );
DCL CNT                      SBIN;
DCL FMT_                     BIT(72)   DALIGNED;
 
    IF NOT ANY_ERRORS THEN DO;
         ANY_ERRORS= %YES#;
         CALL PUT_FRAME_LIST;
         END;
 
    CNT= CNT + 1;
    CALL CHARBIN( I,KEY2.LINE# );
    VEC1_= VECTOR( I );
    VEC2_= VECTOR( REC2.V.FIELD_NAME(J-1) );
    VEC4_= VECTOR( REC2.V.FIELD_NAME(J) );
    K= REC2.V.EDIT_KEY(J-1);
    CALL BINCHAR( INT8,K );
    IF FPL$->F$DCB.ORG# = %KEYED# THEN DO;
         CALL SEARCH( K,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,4) );
         CALL CONCAT( INT9,SUBSTR(INT8,K,5-K),'.',SUBSTR(INT8,5,3) );
         VEC3_= VECTOR( SUBSTR(INT9,0,5-K+LENGTHC('.999')) );
         K= REC2.V.EDIT_KEY(J);
         CALL BINCHAR( INT8,K );
         CALL SEARCH( K,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,4) );
         CALL CONCAT( INT10,SUBSTR(INT8,K,5-K),'.',SUBSTR(INT8,5,3) );
         VEC5_= VECTOR( SUBSTR(INT10,0,5-K+LENGTHC('.999')) );
         END;
    ELSE DO;
         CALL SEARCH( K,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,7) );
         INT9= SUBSTR(INT8,K,8-K);
         VEC3_= VECTOR( SUBSTR(INT9,0,8-K) );
         K= REC2.V.EDIT_KEY(J);
         CALL BINCHAR( INT8,K );
         CALL SEARCH( K,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,7) );
         INT10= SUBSTR(INT8,K,8-K);
         VEC5_= VECTOR( SUBSTR(INT10,0,8-K) );
         END;
    IF REC2.V.PIC_END(J-1)+1 = REC2.V.COLUMN(J) THEN DO;
         L= REC2.V.PIC_END(J-1)-LENGTHC(KEY2.LINE#);
         M= REC2.V.COLUMN(J)-LENGTHC(KEY2.LINE#);
         END;
    ELSE DO;
         L= REC2.V.COLUMN(J)-LENGTHC(KEY2.LINE#);
         M= REC2.V.PIC_END(J-1)-LENGTHC(KEY2.LINE#);
         END;
    VEC6_= VECTOR( L );
    VEC7_= VECTOR( M );
    CALL X$WRITE( F_FDS,FMT_,VEC1_,VEC2_,VEC3_,VEC4_,VEC5_,VEC6_,VEC7_ );
    RETURN;
 
END PUT_FMT5_OR_6;
%EJECT;
PUT_FRAME_LIST: PROC( ECHO );
DCL ECHO                     BIT(1);
 
    IF CMD# ~= CHECK## THEN
         IF CMD# = PRINT##  OR
            CMD# = PRINT_CHECK##  OR
            CMD# = PRINT_IF##  THEN
              CALL M$DEVICE( NEW_LO_PAGE );
         ELSE CALL LEE$WRITE( ' ',LENGTHC(' '),M$LO# );
    IF NUM_REQUESTS > 1 THEN DO;
         ME_BUF= '--> Frames ';
         ME_INDX= LENGTHC('--> Frames ');
         CONT_COL= ME_INDX;
         CALL LIST_FRAMES;
         END;
    ELSE DO;
         CALL CONCAT( ME_BUF,'--> Frame ',REQUEST.NAME(1) );
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO#,LONEME );
         END;
    RETURN;
 
END PUT_FRAME_LIST;
%EJECT;
SEE_IF_FILE_IS_OPEN: PROC  ALTRET;
 
    IF FPL$->F$DCB.FCD# THEN
         RETURN;
    ELSE DO;
         INDX= BLK2$->P_SYM.CPOS;
         CALL XUR$ERRPTR( INDX,M$ME# );
         ME_BUF= '.. Can''t do this yet; You haven''t given me a file to USE';
         CALL LEE$WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
         ALTRETURN;
         END;
 
END SEE_IF_FILE_IS_OPEN;
%EJECT;
END OVERLAP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DDA */
LEE$ABORT: PROC;
 
DCL OVERLAP$UNWIND           BIT(72)   SYMREF;
 
    UNWIND TO OVERLAP$UNWIND;
 
END LEE$ABORT;
