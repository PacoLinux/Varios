/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
COPYPGM: PROC MAIN;
 
/* *****************************INCLUDES***************************** */
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE XU_MACRO_C;
%INCLUDE XS_MACRO_C;
%INCLUDE COPYPGM_C1;
%INCLUDE B_ERRORS_C;
 
/* *******************************FPTS******************************* */
 
%FPT_GDS(FPTN=MBS_GDS,
         FREE=NO,
         RESULTS=MBS_VLP,
         SEGSIZE=1024);
%FPT_GDS(FPTN=CBS_GDS,
         FREE=NO,
         RESULTS=CBS_VLP,
         SEGSIZE=1024);
%FPT_GDS(FPTN=LIT_GDS,
         FREE=NO,
         RESULTS=LIT_VLP,
         SEGSIZE=1024);
%FPT_GDS(FPTN=BUF_GDS,
         FREE=NO,
         RESULTS=BUF_VLP,
         SEGSIZE=1024);
%FPT_GDS(FPTN=OUT_GDS,
         FREE=NO,
         RESULTS=OUT_VLP,
         SEGSIZE=1024);
%FPT_GDS(FPTN=XSA_GDS,
         FREE=NO,
         RESULTS=XSA_VLP,
         SEGSIZE=10240);
%VLP_VECTOR(FPTN=MBS_VLP,
            SEGID='6006'O);
%VLP_VECTOR(FPTN=CBS_VLP,
            SEGID='6007'O);
%VLP_VECTOR(FPTN=LIT_VLP,
            SEGID='6010'O);
%VLP_VECTOR(FPTN=BUF_VLP,
            SEGID='6011'O);
%VLP_VECTOR(FPTN=OUT_VLP,
            SEGID='6012'O);
%VLP_VECTOR(FPTN=XSA_VLP,
            SEGID='6013'O);
 
%P_PCB(NAME=WIZ$PCB,
       STCLASS="STATIC SYMDEF",
       R=COMMAND,
       U$=WIZ$USER,
       WSZ=1024);
%PARSE$OUT;
%PARSE$SYM;
 
%B$TCB;
%B$ALT;
 
%F$DCB(DCBN=DUMMY);
 
%XSA_PARAM(FPTN=XSA_EI);
%FPT_OPEN(FPTN=OPEN_EI,
          NAME=NAME_EI,
          PASS=PASS_EI,
          SN=SN_EI,
          ACCT=ACCT_EI,
          WSN=WSN_EI,
          DCB=M$EI,
          EXIST=OLDFILE,
          FUN=IN,
          REASSIGN=YES,
          ACS=SEQUEN);
%VLP_NAME(FPTN=NAME_EI,
          LEN=31,
          NAME='                               ');
%VLP_PASS(FPTN=PASS_EI,
          PASS='        ');
%VLP_SN(FPTN=SN_EI,
        N=6);
%VLP_ACCT(FPTN=ACCT_EI,
          ACCT='        ');
%VLP_WSN(FPTN=WSN_EI,
         WSN='        ');
%FPT_FID(FPTN=FID_EI,
         NAME=NAME_EI,
         ACCT=ACCT_EI,
         PASS=PASS_EI,
         SN=SN_EI,
         WSN=WSN_EI,
         ASN=OPEN_EI.V.ASN#,
         RES=OPEN_EI.V.RES#,
         RESULTS=EI_VLR);
%VLR_FID(FPTN=EI_VLR);
%FPT_READ(FPTN=READ_EI,
          DCB=M$EI,
          KEYR=YES);
%FPT_CLOSE(FPTN=CLOSE_EI,
           DCB=M$EI,
           DISP=SAVE);
 
%XSA_PARAM(FPTN=XSA_EO);
%FPT_OPEN(FPTN=OPEN_EO,
          NAME=NAME_EO,
          PASS=PASS_EO,
          SN=SN_EO,
          ACCT=ACCT_EO,
          WSN=WSN_EO,
          DCB=M$EO,
          REASSIGN=YES,
          DISP=NAMED,
          FUN=CREATE,
          ORG=CONSEC);
%VLP_NAME(FPTN=NAME_EO,
          LEN=31,
          NAME='                               ');
%VLP_PASS(FPTN=PASS_EO,
          PASS='        ');
%VLP_SN(FPTN=SN_EO,
        N=6);
%VLP_ACCT(FPTN=ACCT_EO,
          ACCT='        ');
%VLP_WSN(FPTN=WSN_EO,
         WSN='        ');
%FPT_FID(FPTN=FID_EO,
         NAME=NAME_EO,
         ACCT=ACCT_EO,
         PASS=PASS_EO,
         SN=SN_EO,
         WSN=WSN_EO,
         ASN=OPEN_EO.V.ASN#,
         RES=OPEN_EO.V.RES#,
         RESULTS=EO_VLR);
%VLR_FID(FPTN=EO_VLR);
%FPT_WRITE(FPTN=WRITE_EO,
           DCB=M$EO);
%FPT_CLOSE(FPTN=CLOSE_EO,
           DCB=M$EO,
           DISP=SAVE);
 
%VLP_NAME(FPTN=NAME_HOLD,
          LEN=31,
          NAME='                               ');
%VLP_PASS(FPTN=PASS_HOLD,
          PASS='        ');
%VLP_SN(FPTN=SN_HOLD,
        N=6);
%VLP_ACCT(FPTN=ACCT_HOLD,
          ACCT='        ');
%VLP_WSN(FPTN=WSN_HOLD,
         WSN='        ');
 
/* *******************************REFS******************************* */
 
    DCL XSA$OPEN                       ENTRY(2) ALTRET;
    DCL XSA$READ                       ENTRY(2) ALTRET;
    DCL XSA$WRITE                      ENTRY(2) ALTRET;
    DCL XSA$CLOSE                      ENTRY(2) ALTRET;
    DCL WIZ$USER                       ENTRY(1);
    DCL WIZ$INIT                       ENTRY(4) ALTRET;
    DCL WIZ$SYSERR                     ENTRY(1);
    DCL WIZ$USRERR                     ENTRY(1);
    DCL WIZ$TERM                       ENTRY(1);
    DCL WIZ$PARSERR                    ENTRY(1);
    DCL WIZ$WRITE                      ENTRY(3);
    DCL WIZ$READ                       ENTRY(2) ALTRET;
    DCL X$PARSE                        ENTRY(1) ALTRET;
    DCL COMMAND SYMREF                 BIT(36);
    DCL B$JIT$ SYMREF                  PTR;
    DCL BROKEN SYMREF                  SBIN;
    DCL B$TCB$ SYMREF                  PTR;
 
/* *******************************DCBS******************************* */
 
    DCL M$EI                           DCB;
    DCL M$EO                           DCB;
 
/* *****************************POINTERS***************************** */
 
    DCL MARKER(0:15)                   PTR;
    DCL STACK(0:15)                    PTR;
    DCL MBSPTR                         PTR;
    DCL CBSPTR                         PTR;
    DCL LITPTR                         PTR;
    DCL EIPTR                          PTR;
    DCL EOPTR                          PTR;
    DCL BLK$                           PTR;
    DCL P                              PTR;
    DCL Q                              PTR;
    DCL R                              PTR;
    DCL CBSSAV                         PTR;
    DCL MARK_HOLD                      PTR;
 
/* ***************************WORD VALUES*************************** */
 
    DCL EOL CONSTANT                   SBIN INIT(-1);
    DCL MBSWDS                         SBIN;
    DCL CBSWDS                         SBIN;
    DCL LITBTS                         SBIN;
    DCL BUFBTS                         SBIN;
    DCL OUTBTS                         SBIN;
    DCL HWMREC                         SBIN;
    DCL HWMKEY                         SBIN;
    DCL TOTLEN                         SBIN;
    DCL ARS                            SBIN;
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL L                              SBIN;
    DCL STK                            SBIN;
    DCL MRK                            SBIN;
    DCL PHASE                          SBIN;
    DCL COUNT_EI                       SBIN;
    DCL COUNT_EO                       SBIN;
    DCL FLDSTRT                        SBIN;
    DCL FLDSTOP                        SBIN;
    DCL ASN_HOLD                       UBIN;
    DCL EXIST_HOLD                     UBIN;
    DCL ORG_HOLD                       UBIN;
    DCL RES_HOLD                       CHAR(4);
    DCL CBS_HOLD                       SBIN;
 
/* ***************************CHAR BUFFERS*************************** */
 
    DCL CMDBUF                         CHAR(2048);
    DCL RECBUF                         CHAR(8);
    DCL BUFBUF BASED(BUF_VLP.PTR$)     CHAR(1);
 
/* *******************************BITS******************************* */
 
    DCL BITSTRING BASED                BIT(L);
    DCL OLDEDT                         BIT(72);
    DCL OLDKEY                         BIT(72);
    DCL SAVBUF                         BIT(1);
    DCL USEBUF                         BIT(1);
    DCL HOLDING                        BIT(1);
    DCL VARYING                        BIT(1);
    DCL KEYUSED                        BIT(1);
    DCL XSA_INP                        BIT(1);
    DCL XSA_OUT                        BIT(1);
 
/* ****************************STRUCTURES**************************** */
 
    DCL 1 KEYTBL,
          2 KEYPTR                     PTR,
          2 KEYLEN UNAL                UBIN HALF,
          2 KEYTYP UNAL                UBIN HALF;
 
    DCL 1 KEYBUF,
          2 L UNAL                     UBIN BYTE,
          2 C UNAL                     CHAR(255);
 
 
    DCL 1 KEYWRK1,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
 
    DCL 1 KEYWRK2,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
 
    DCL 1 KEYWRK3,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
 
    DCL 1 WRK,
          2 POINT                      PTR,
          2 LEN                        SBIN,
          2 BASE                       SBIN;
 
    DCL 1 PTRBUF,
          2 N1                         PTR,
          2 F REDEF N1,
            3 IBYT UNAL                UBIN(20),
            3 IBIT UNAL                UBIN(4),
            3 ISEG UNAL                UBIN(12),
          2 N2                         PTR,
          2 T REDEF N2,
            3 IBYT UNAL                UBIN(20),
            3 IBIT UNAL                UBIN(4),
            3 ISEG UNAL                UBIN(12);
 
    DCL 1 EDTBUF,
          2 VAL                        UBIN,
          2 INC                        UBIN;
 
    DCL 1 MBS BASED(MBSPTR),
          2 SRCPTR                     PTR,
          2 SRCLEN UNAL                UBIN HALF,
          2 SRCTYP UNAL                UBIN HALF;
 
    DCL 1 CBS BASED(CBSPTR),
          2 SRCPTR                     PTR,
          2 DSTPTR                     PTR,
          2 SRCLEN UNAL                UBIN HALF,
          2 BC UNAL                    UBIN(3),
          2 NEXT UNAL                  UBIN(15),
          2 U REDEF NEXT,
            3 RESOLVED UNAL            BIT(1),
            3 ANDOR UNAL               BIT(1),
            3 LVL UNAL                 UBIN(13);
 
    DCL 1 ORGBUF,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
 
%EJECT;
/* **************************INITIALIZATION************************** */
 
    CALL WIZ$INIT('COPYPGM B01',11,ADDR(NIL),':') ALTRET(ABORT);
    CALL M$GDS(BUF_GDS) ALTRET(NO_ROOM);
    CALL M$GDS(OUT_GDS) ALTRET(NO_ROOM);
    MBSPTR=MBS_VLP.PTR$;
    CBSPTR=CBS_VLP.PTR$;
    LITPTR=LIT_VLP.PTR$;
    MBSWDS=0;
    CBSWDS=0;
    LITBTS=0;
    BUFBTS=36864;
    OUTBTS=36864;
    HWMREC=0;
    HWMKEY=0;
    TOTLEN=0;
    KEYTBL.KEYPTR=ADDR(NIL);
    WIZ$PCB.TEXT$=ADDR(CMDBUF);
    WIZ$PCB.WORK$=BUF_VLP.PTR$;
    PHASE=0;
    COUNT_EI=0;
    COUNT_EO=0;
    EIPTR=DCBADDR(DCBNUM(M$EI));
    EOPTR=DCBADDR(DCBNUM(M$EO));
    EI_VLR='0'B;
    EO_VLR='0'B;
    READ_EI.KEY_=VECTOR(KEYBUF);
    READ_EI.BUF_.BUF$=BUF_VLP.PTR$;
    SAVBUF='0'B;
    USEBUF='0'B;
    VARYING='0'B;
    KEYUSED='0'B;
    ORGBUF.INT=1;
    ORGBUF.FRC=0;
    KEYTBL.KEYPTR=ADDR(NIL);
    KEYTBL.KEYLEN=0;
    KEYTBL.KEYTYP=0;
    CALL M$GDS(XSA_GDS) ALTRET(NO_ROOM);
    XSA_EI.KBUF_.BOUND=4095;
    XSA_EI.KBUF_.BUF$=XSA_VLP.PTR$;
    XSA_EI.BBUF_.BOUND=16383;
    XSA_EI.BBUF_.BUF$=PINCRW(XSA_VLP.PTR$,1024);
    XSA_EO.KBUF_.BOUND=4095;
    XSA_EO.KBUF_.BUF$=PINCRW(XSA_VLP.PTR$,5120);
    XSA_EO.BBUF_.BOUND=16383;
    XSA_EO.BBUF_.BUF$=PINCRW(XSA_VLP.PTR$,6144);
 
%EJECT;
/* **************************READ COMMANDS************************** */
 
READ_COMMAND:
    CALL WIZ$READ(CMDBUF,ARS) ALTRET(SIERROR);
    WIZ$PCB.NCHARS=ARS;
    CALL X$PARSE(WIZ$PCB) ALTRET(CMDERROR);
    BLK$=WIZ$PCB.OUT$;
    IF OUT$BLK.CODE=%NULCMD THEN
        GOTO READ_COMMAND;
    DO CASE(OUT$BLK.CODE);
 
%EJECT;
        CASE(%COPCMD) /* COPY command */;
            DO I=0 TO OUT$BLK.NSUBLKS-1;
                Q=OUT$BLK.SUBLK$(I);
                P=Q->OUT$BLK.SUBLK$(0);
                IF P->OUT$BLK.CODE<%COPYFIELD OR P->OUT$BLK.CODE
                    >%COPYRANGE THEN DO;
                    CALL WIZ$USRERR(%CPY_BUG);
                    GOTO READ_COMMAND;
                END;
                DO CASE(P->OUT$BLK.CODE-200);
 
                    CASE(%(%COPYFIELD-200));
                        CALL EDT2BIN(P,KEYWRK1) ALTRET(REST_IGNORED);
                        IF USEBUF THEN DO;
                            /* Write this code sometime! */;
                        END;
                        ELSE DO;
                            IF ORGBUF.INT=1 AND KEYWRK1.INT<1 THEN DO;
                                WIZ$PCB.ERROR.CODE=%CPY_OCF;
                                WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                                CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                                GOTO READ_COMMAND;
                            END;
                            WRK.BASE=9*(KEYWRK1.INT-ORGBUF.INT);
                            WRK.LEN=9;
                        END;
                        IF ORGBUF.FRC=1 AND KEYWRK1.FRC<1 THEN DO;
                            WIZ$PCB.ERROR.CODE=%CPY_OCF;
                            WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                            GOTO READ_COMMAND;
                        END;
                        WRK.BASE=WRK.BASE+KEYWRK1.FRC;
                        CALL GETSUBFIELDS ALTRET(READ_COMMAND);
                        IF WRK.BASE>262143 OR WRK.LEN<1 OR
                            WRK.LEN+WRK.BASE>262144 THEN DO;
                            WIZ$PCB.ERROR.CODE=%CPY_BDF;
                            WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                            GOTO READ_COMMAND;
                        END;
                        WRK.POINT=PINCRB(BUF_VLP.PTR$,WRK.BASE);
                        CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
                        IF WRK.LEN+WRK.BASE>HWMREC THEN
                             HWMREC=WRK.LEN+WRK.BASE;
 
                    CASE(%(%COPYKEY-200));
                        WRK.BASE=0;
                        WRK.LEN=0;
                        CALL GETSUBFIELDS ALTRET(READ_COMMAND);
                        IF WRK.BASE>2294 OR WRK.LEN<0 OR
                            WRK.LEN+WRK.BASE>2295 THEN DO;
                            WIZ$PCB.ERROR.CODE=%CPY_BKF;
                            WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                            GOTO READ_COMMAND;
                        END;
                        WRK.POINT=PINCRB(ADDR(KEYBUF.C),WRK.BASE);
                        CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
                        KEYUSED='1'B;
                        IF WRK.LEN+WRK.BASE>HWMKEY THEN
                            HWMKEY=WRK.LEN+WRK.BASE;
 
                    CASE(%(%COPYREC-200));
                        WRK.BASE=0;
                        WRK.LEN=72;
                        CALL GETSUBFIELDS ALTRET(READ_COMMAND);
                        IF WRK.BASE>71 OR WRK.LEN<1 OR
                            WRK.LEN+WRK.BASE>72 THEN DO;
                            WIZ$PCB.ERROR.CODE=%CPY_BRF;
                            WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                            GOTO READ_COMMAND;
                        END;
                        WRK.POINT=PINCRB(ADDR(RECBUF),WRK.BASE);
                        CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
 
                    CASE(%(%COPYASIS-200));
                        WRK.POINT=BUF_VLP.PTR$;
                        WRK.LEN=0;
                        IF Q->OUT$BLK.NSUBLKS>1 THEN DO;
                            P=Q->OUT$BLK.SUBLK$(1);
                            CALL ADJKEY(P,KEYWRK1) ALTRET(READ_COMMAND);
                            IF 9*KEYWRK1.INT+KEYWRK1.FRC>262143 THEN DO;
                                WIZ$PCB.ERROR.CODE=%CPY_OCF;
                                WIZ$PCB.HI_CHAR=P->OUT$BLK.CPOS;
                                CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                                GOTO READ_COMMAND;
                            END;
                            WRK.POINT=PINCRB(WRK.POINT,9*KEYWRK1.INT+
                                KEYWRK1.FRC);
                        END;
                        CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
 
                    CASE(%(%COPYBIT-200),%(%COPYOCT-200),
                        %(%COPYLIT-200),%(%COPYUQL-200));
                        CALL STOW_LIT(P,WRK.POINT,WRK.LEN)
                            ALTRET(NO_ROOM);
                        CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
 
                    CASE(%(%COPYRANGE-200));
                        CALL CHARBIN(FLDSTRT,SUBSTR(P->OUT$BLK.SUBLK$(0)
                            ->OUT$SYM.TEXT,0,P->OUT$BLK.SUBLK$(0)->
                            OUT$SYM.COUNT));
                        IF USEBUF THEN DO;
                            /* Write me too, daddy! */;
                        END;
                        ELSE DO;
                            IF ORGBUF.INT=1 AND FLDSTRT<1 THEN DO;
                                WIZ$PCB.ERROR.CODE=%CPY_OCF;
                                WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                                CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                                GOTO READ_COMMAND;
                            END;
                            FLDSTRT=FLDSTRT-ORGBUF.INT;
                        END;
                        CALL CHARBIN(FLDSTOP,SUBSTR(P->OUT$BLK.SUBLK$(1)
                            ->OUT$SYM.TEXT,0,P->OUT$BLK.SUBLK$(1)->
                            OUT$SYM.COUNT));
                        IF USEBUF THEN DO;
                            /* Me too, daddy! */;
                        END;
                        ELSE DO;
                            IF ORGBUF.INT=1 AND FLDSTOP<1 THEN DO;
                                WIZ$PCB.ERROR.CODE=%CPY_OCF;
                                WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                                CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                                GOTO READ_COMMAND;
                            END;
                            FLDSTOP=FLDSTOP-ORGBUF.INT;
                        END;
                        IF FLDSTOP<FLDSTRT THEN DO;
                            WIZ$PCB.ERROR.CODE=%CPY_RNG;
                            WIZ$PCB.HI_CHAR=Q->OUT$BLK.CPOS;
                            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                            GOTO READ_COMMAND;
                        END;
                        DO FLDSTRT=FLDSTRT TO FLDSTOP;
                            IF USEBUF THEN DO;
                                /* Missing code here */;
                            END;
                            ELSE DO;
                                WRK.BASE=FLDSTRT;
                                WRK.LEN=9;
                            END;
                            WRK.POINT=PINCRC(BUF_VLP.PTR$,WRK.BASE);
                            CALL STOW_MBS(WRK) ALTRET(NO_ROOM);
                            IF 9*WRK.BASE+WRK.LEN>HWMREC THEN
                                HWMREC=9*WRK.BASE+WRK.LEN;
                        END;
 
                END;
            END;
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(%ENDCMD) /* END command */;
            IF B$JIT.MODE=%M_BATCH# THEN
                PHASE=1;
            IF MBSPTR=MBS_VLP.PTR$ THEN DO;
                CALL WIZ$USRERR(%CPY_NCC);
                IF PHASE=0 THEN
                    GOTO READ_COMMAND;
                ELSE
                    CALL WIZ$TERM(6);
            END;
            IF NOT EIPTR->DUMMY.FCD# THEN
                CALL OPEN(OPEN_EI,FID_EI,EI_VLR,XSA_EI) ALTRET(EIOPEN);
            IF XSA_EI.ORG=0 THEN
                XSA_INP='0'B;
            ELSE
                XSA_INP='1'B;
            IF NOT EOPTR->DUMMY.FCD# THEN
                CALL OPEN(OPEN_EO,FID_EO,EO_VLR,XSA_EO) ALTRET(EOOPEN);
            IF XSA_EO.ORG=0 THEN
                XSA_OUT='0'B;
            ELSE
                XSA_OUT='1'B;
            CALL VALIDATE_KEY;
            IF KEYUSED AND EIPTR->DUMMY.ORG#~=%KEYED# AND
                EIPTR->DUMMY.ORG#~=%INDEXED# THEN DO;
                CALL WIZ$USRERR(%CPY_CCK);
                GOTO ABNRML_EOJ;
            END;
            TOTLEN=(TOTLEN+8)/9;
            CALL BINCHAR(RECBUF,TOTLEN);
            J=0;
            DO WHILE(J<7 AND SUBSTR(RECBUF,J,1)='0');
                J=J+1;
            END;
            CALL INSERT(CMDBUF,0,36-J,'Output record size is ',SUBSTR
                (RECBUF,J,8-J),' bytes');
            IF TOTLEN=1 THEN
                I=35-J;
            ELSE
                I=36-J;
            IF VARYING THEN DO;
                CALL INSERT(CMDBUF,I,11,' (variable)');
                I=I+11;
            END;
            CALL WIZ$WRITE(CMDBUF,I,'A');
            HWMREC=(HWMREC+8)/9;
            IF HWMREC<=0 THEN
                HWMREC=1;
            HWMKEY=(HWMKEY+8)/9;
            IF VARYING THEN
                READ_EI.BUF_.BOUND=29126;
            ELSE
                READ_EI.BUF_.BOUND=HWMREC-1;
            IF READ_EI.BUF_.BOUND<255 AND EIPTR->DUMMY.ASN#=3 THEN
                READ_EI.BUF_.BOUND=255;
            DO WHILE(9*READ_EI.BUF_.BOUND>BUFBTS);
                CALL M$GDS(BUF_GDS) ALTRET(NO_ROOM);
                BUFBTS=BUFBTS+36864;
            END;
            IF KEYTBL.KEYPTR~=ADDR(NIL) THEN DO;
                WRITE_EO.KEY_=VECTOR(KEYBUF);
                WRITE_EO.V.ONEWKEY#='1'B;
            END;
            IF CBSPTR~=CBS_VLP.PTR$ THEN DO;
                R=PINCRW(CBSPTR,-SIZEW(CBS));
                R->CBS.BC=7-R->CBS.BC;
                R->CBS.U.ANDOR='0'B;
            END;
            PHASE=1;
            BROKEN=0;
 
FAILURE:
            IF BROKEN>0 THEN
                CALL RECORD_COUNT;
            IF XSA_INP THEN
                CALL XSA$READ(READ_EI,XSA_EI) ALTRET(EXEC_READ);
            ELSE
                CALL M$READ(READ_EI) ALTRET(EXEC_READ);
 
GOOD_READ:
            COUNT_EI=COUNT_EI+1;
            CALL BINCHAR(RECBUF,COUNT_EI);
            IF XSA_INP THEN
                TOTLEN=XSA_EI.ARS#;
            ELSE
                TOTLEN=EIPTR->DUMMY.ARS#;
            IF TOTLEN<HWMREC THEN
                CALL INSERT(BUFBUF,TOTLEN,HWMREC-TOTLEN,' ');
            IF KEYUSED AND KEYBUF.L<HWMKEY THEN
                CALL INSERT(KEYBUF.C,KEYBUF.L,HWMKEY-KEYBUF.L,' ');
            R=CBS_VLP.PTR$;
            DO WHILE(R~=CBSPTR);
                P=R->CBS.SRCPTR;
                Q=R->CBS.DSTPTR;
                L=R->CBS.SRCLEN;
                DO CASE(R->CBS.BC);
                    CASE(%(%RELLE-600));
                        IF P->BITSTRING>Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(%(%RELNE-600));
                        IF P->BITSTRING=Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(%(%RELLT-600));
                        IF P->BITSTRING>=Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(%(%RELGE-600));
                        IF P->BITSTRING<Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(%(%RELEQ-600));
                        IF P->BITSTRING~=Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(%(%RELGT-600));
                        IF P->BITSTRING<=Q->BITSTRING THEN
                            GOTO BRANCH_FALSE;
                    CASE(ELSE);
                        CALL WIZ$USRERR(%CPY_BUG);
                        CALL WIZ$TERM(6);
                END;
                IF R->CBS.U.RESOLVED THEN
                    IF R->CBS.U.ANDOR THEN
                        GOTO SUCCESS;
                    ELSE
                        GOTO FAILURE;
                R=PINCRW(R,SIZEW(CBS)*R->CBS.NEXT);
 
BRANCH_FALSE:
                R=PINCRW(R,SIZEW(CBS));
            END;
 
SUCCESS:
            TOTLEN=0;
            R=MBS_VLP.PTR$;
            Q=OUT_VLP.PTR$;
            DO WHILE(R~=MBSPTR);
                P=R->MBS.SRCPTR;
                L=R->MBS.SRCLEN;
                IF L=0 THEN
                    IF R->MBS.SRCTYP=%COPYKEY THEN
                        L=9*KEYBUF.L;
                    ELSE DO;
                        PTRBUF.N1=P;
                        PTRBUF.N2=BUF_VLP.PTR$;
                        IF XSA_INP THEN
                            L=XSA_EI.ARS#*9-((PTRBUF.F.IBYT-
                                PTRBUF.T.IBYT)*9+PTRBUF.F.IBIT-
                                PTRBUF.T.IBIT);
                        ELSE
                            L=EIPTR->DUMMY.ARS#*9-((PTRBUF.F.IBYT-
                                PTRBUF.T.IBYT)*9+PTRBUF.F.IBIT-
                                PTRBUF.T.IBIT);
                        IF L<0 THEN
                            L=0;
                    END;
                TOTLEN=TOTLEN+L;
                IF TOTLEN>262144 THEN DO;
                    CALL WIZ$USRERR(%CPY_RTL);
                    GOTO ABNRML_EOJ;
                END;
                DO WHILE(TOTLEN>OUTBTS);
                    CALL M$GDS(OUT_GDS) ALTRET(NO_ROOM);
                    OUTBTS=OUTBTS+36864;
                END;
                Q->BITSTRING=P->BITSTRING;
                Q=PINCRB(Q,L);
                R=PINCRW(R,2);
            END;
            IF KEYTBL.KEYPTR~=ADDR(NIL) THEN DO;
                P=KEYTBL.KEYPTR;
                Q=ADDR(KEYBUF.C);
                L=KEYTBL.KEYLEN;
                IF L=0 THEN
                    L=9*KEYBUF.L;
                ELSE
                    Q->BITSTRING=P->BITSTRING;
                KEYBUF.L=(L+8)/9;
                IF KEYTBL.KEYTYP=%KEYEDIT THEN
                    IF EDTBUF.VAL>99999999 THEN DO;
                        CALL WIZ$USRERR(%CPY_EME);
                        GOTO ABNRML_EOJ;
                    END;
            END;
            IF TOTLEN=0 THEN DO;
                WRITE_EO.BUF_.BUF$=ADDR(NIL);
                WRITE_EO.BUF_.BOUND=0;
            END;
            ELSE DO;
                WRITE_EO.BUF_.BUF$=OUT_VLP.PTR$;
                WRITE_EO.BUF_.BOUND=(TOTLEN+8)/9-1;
            END;
            IF XSA_OUT THEN
                CALL XSA$WRITE(WRITE_EO,XSA_EO) ALTRET(EXEC_RITE);
            ELSE
                CALL M$WRITE(WRITE_EO) ALTRET(EXEC_RITE);
            COUNT_EO=COUNT_EO+1;
            IF KEYTBL.KEYTYP=%KEYEDIT THEN
                EDTBUF.VAL=EDTBUF.VAL+EDTBUF.INC;
            GOTO FAILURE;
 
EXEC_RITE:
            CALL WIZ$SYSERR(DCBNUM(M$EO));
            GOTO ABNRML_EOJ;
 
EXEC_READ:
            IF (XSA_INP AND XSA_EI.ERR.CODE=7) OR
                (~XSA_INP AND B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD) THEN
                GOTO GOOD_READ;
            IF (XSA_INP AND (XSA_EI.ERR.CODE=6 OR XSA_EI.ERR.CODE=10))
                OR (~XSA_INP AND (
                     B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF OR
                     B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOD OR
                     B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOT
                )) THEN
                GOTO NORMAL_EOJ;
            CALL WIZ$SYSERR(DCBNUM(M$EI));
            GOTO ABNRML_EOJ;
 
%EJECT;
        CASE(%INPCMD) /* INPUT command */;
            IF EIPTR->DUMMY.FCD# THEN DO;
                CALL XSA$CLOSE(CLOSE_EI,XSA_EI) ALTRET(EIERROR);
                NAME_HOLD=NAME_EI;
                PASS_HOLD=PASS_EI;
                SN_HOLD=SN_EI;
                ACCT_HOLD=ACCT_EI;
                WSN_HOLD=WSN_EI;
                ASN_HOLD=OPEN_EI.V.ASN#;
                RES_HOLD=OPEN_EI.V.RES#;
                HOLDING='1'B;
            END;
            ELSE
                HOLDING='0'B;
            BLK$=OUT$BLK.SUBLK$(0);
            FID_EI.TEXTFID_=VECTOR(OUT$SYM.TEXT);
            CALL M$FID(FID_EI) ALTRET(EIFID);
            CALL OPEN(OPEN_EI,FID_EI,EI_VLR,XSA_EI) ALTRET(EIOPEN);
            I=EIPTR->DUMMY.ORG#;
            IF I~=%CONSEC# AND I~=%KEYED# AND I~=%UR#
                AND I~=%INDEXED# AND I~=%TERMINAL#
                AND I~=%FIXED# AND I~=%VARIABLE# AND
                I~=%UNDEF# THEN DO;
                CALL WIZ$USRERR(%CPY_CUI);
                CALL XSA$CLOSE(CLOSE_EI,XSA_EI) ALTRET(EIERROR);
                GOTO EIFIX;
            END;
            HOLDING='0'B;
            CALL VALIDATE_KEY;
            GOTO READ_COMMAND;
 
EIFID:
            CALL WIZ$USRERR(%CPY_EIF);
            GOTO EIFIX;
 
EIOPEN:
            CALL WIZ$SYSERR(DCBNUM(M$EI));
            GOTO EIFIX;
 
EIFIX:
            IF HOLDING THEN DO;
                NAME_EI=NAME_HOLD;
                PASS_EI=PASS_HOLD;
                SN_EI=SN_HOLD;
                ACCT_EI=ACCT_HOLD;
                WSN_EI=WSN_HOLD;
                OPEN_EI.V.ASN#=ASN_HOLD;
                OPEN_EI.V.RES#=RES_HOLD;
                HOLDING='0'B;
                CALL WIZ$USRERR(%CPY_RIF);
                CALL OPEN(OPEN_EI,FID_EI,EI_VLR,XSA_EI) ALTRET(EIERROR);
            END;
            IF PHASE=0 THEN
                GOTO READ_COMMAND;
            ELSE
                CALL WIZ$TERM(6);
 
%EJECT;
        CASE(%INCCMD) /* INCLUDE command */;
            CBSSAV=CBSPTR;
            CBS_HOLD=CBSWDS;
            MARK_HOLD=MARKER(0);
            I=0;
            STK=0;
            MRK=0;
            IF CBSPTR=CBS_VLP.PTR$ THEN DO;
                MARKER(MRK)=CBSPTR;
                IF OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%IFAND OR
                    OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%IFOR THEN
                    I=I+1;
                CALL GET_TOKEN;
                GOTO IFC_MAIN;
            END;
            CBSPTR=PINCRW(CBSPTR,-SIZEW(CBS));
            IF OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%IFOR THEN DO;
                I=I+1;
                GOTO IFC_OR;
            END;
            ELSE IF OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%IFAND THEN
                I=I+1;
            GOTO IFC_AND;
 
IFC_MAIN:
            DO WHILE(STACK(STK)->OUT$BLK.CODE=%IFLPAR);
                STK=STK+1;
                CALL GET_TOKEN;
                MRK=MRK+1;
                MARKER(MRK)=CBSPTR;
            END;
            STK=STK+1;
            CALL GET_TOKEN;
            STK=STK+1;
            CALL GET_TOKEN;
 
IFC_PUSH:
            STK=STK+1;
            CALL GET_TOKEN;
            IF STK>=4 AND STACK(STK-4)->OUT$BLK.CODE=%IFLPAR AND
                STACK(STK)->OUT$BLK.CODE=%IFRPAR THEN DO;
                CALL GENERATE_FRV(STK-3) ALTRET(IFFIX);
                MRK=MRK-1;
                STK=STK-4;
                CALL GET_TOKEN;
            END;
            ELSE IF STACK(STK)->OUT$BLK.CODE>=%RELLE AND
                STACK(STK)->OUT$BLK.CODE<=%RELGT THEN DO;
                CALL GENERATE_FRV(STK-3) ALTRET(IFFIX);
                CBS.U.ANDOR='1'B;
                CBS.U.LVL=MRK;
                STACK(STK-2)=STACK(STK);
                STK=STK-1;
                CALL GET_TOKEN;
                CBSPTR=PINCRW(CBSPTR,SIZEW(CBS));
                GOTO IFC_PUSH;
            END;
            ELSE DO;
                CALL GENERATE_FRV(STK-3) ALTRET(IFFIX);
                STACK(STK-3)=STACK(STK);
                STK=STK-3;
            END;
            DO WHILE(STACK(STK)->OUT$BLK.CODE=%IFRPAR);
                MRK=MRK-1;
                STK=STK-1;
                CALL GET_TOKEN;
            END;
            IF STACK(STK)->OUT$BLK.CODE=%IFOR THEN DO;
 
IFC_OR:
                CBS.U.ANDOR='1'B;
                CBS.U.LVL=MRK;
                R=MARKER(MRK);
                DO WHILE(R~=CBSPTR);
                    IF R->CBS.U.RESOLVED AND NOT R->CBS.U.ANDOR AND
                        R->CBS.U.LVL>=MRK THEN
                        R->CBS.NEXT=POFFW(CBSPTR,R)/SIZEW(CBS);
                    R=PINCRW(R,SIZEW(CBS));
                END;
                CBSPTR=PINCRW(CBSPTR,SIZEW(CBS));
                MARKER(MRK)=CBSPTR;
                CALL GET_TOKEN;
                GOTO IFC_MAIN;
            END;
            ELSE IF STACK(STK)->OUT$BLK.CODE=%IFAND THEN DO;
 
IFC_AND:
                CBS.BC=7-CBS.BC;
                CBS.U.ANDOR='0'B;
                CBS.U.LVL=MRK;
                R=MARKER(MRK);
                DO WHILE(R~=CBSPTR);
                    IF R->CBS.U.RESOLVED AND R->CBS.U.ANDOR AND
                        R->CBS.U.LVL>=MRK THEN
                        R->CBS.NEXT=POFFW(CBSPTR,R)/SIZEW(CBS);
                    R=PINCRW(R,SIZEW(CBS));
                END;
                CBSPTR=PINCRW(CBSPTR,SIZEW(CBS));
                CALL GET_TOKEN;
                GOTO IFC_MAIN;
            END;
            CBSPTR=PINCRW(CBSPTR,SIZEW(CBS));
            GOTO READ_COMMAND;
 
IFFIX:
            CBSPTR=CBSSAV;
            CBSWDS=CBS_HOLD;
            MARKER(0)=MARK_HOLD;
            IF CBSPTR~=CBS_VLP.PTR$ THEN DO;
                IF OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%IFOR THEN DO;
                    PINCRW(CBSPTR,-SIZEW(CBS))->CBS.NEXT=32767;
                    R=MARKER(0);
                    DO WHILE(R~=CBSPTR);
                        IF R->CBS.NEXT=POFFW(CBSPTR,R)/SIZEW(CBS) THEN
                            R->CBS.NEXT=16384 /* '40000'O */;
                        R=PINCRW(R,SIZEW(CBS));
                    END;
                END;
                ELSE DO;
                    PINCRW(CBSPTR,-SIZEW(CBS))->CBS.NEXT=32767;
                    PINCRW(CBSPTR,-SIZEW(CBS))->CBS.BC=7-PINCRW
                        (CBSPTR,-SIZEW(CBS))->CBS.BC;
                    R=MARKER(0);
                    DO WHILE(R~=CBSPTR);
                        IF R->CBS.NEXT=POFFW(CBSPTR,R)/SIZEW(CBS) THEN
                            R->CBS.NEXT=24576 /* '60000'O */;
                        R=PINCRW(R,SIZEW(CBS));
                    END;
                END;
            END;
            CALL WIZ$USRERR(%CPY_WCI);
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(%KEYCMD) /* KEY command */;
            IF KEYTBL.KEYPTR~=ADDR(NIL) THEN DO;
                OLDKEY=KEYTBL;
                OLDEDT=EDTBUF;
                ORG_HOLD=OPEN_EO.V.ORG#;
                HOLDING='1'B;
            END;
            ELSE
                HOLDING='0'B;
            KEYTBL.KEYPTR=ADDR(NIL);
            KEYTBL.KEYLEN=0;
            OPEN_EO.V.ORG#=%KEYED#;
            KEYTBL.KEYTYP=OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
            IF KEYTBL.KEYTYP=%KEYIN AND OUT$BLK.NSUBLKS=1 THEN
                KEYTBL.KEYPTR=ADDR(KEYBUF.C);
            ELSE IF KEYTBL.KEYTYP=%KEYEDIT THEN DO;
                KEYTBL.KEYPTR=PINCRC(ADDR(EDTBUF.VAL),1);
                KEYTBL.KEYLEN=27;
                EDTBUF.VAL=1000;
                EDTBUF.INC=1000;
                IF OUT$BLK.NSUBLKS>1 THEN DO;
                    I=1;
                    P=OUT$BLK.SUBLK$(I);
                    EDTBUF.VAL=0;
                    IF P->OUT$BLK.CODE=%INTPART THEN DO;
                        CALL CHARBIN(J,P->OUT$SYM.TEXT);
                        IF J>99999 THEN DO;
                            CALL WIZ$USRERR(%CPY_BES);
                            GOTO KEYFIX;
                        END;
                        EDTBUF.VAL=1000*J;
                        I=I+1;
                    END;
                    IF I<OUT$BLK.NSUBLKS THEN DO;
                        P=OUT$BLK.SUBLK$(I);
                        IF P->OUT$BLK.CODE=%FRCPART THEN DO;
                            CALL CHARBIN(J,P->OUT$SYM.TEXT);
                            IF J>999 THEN DO;
                                CALL WIZ$USRERR(%CPY_BES);
                                GOTO KEYFIX;
                            END;
                            EDTBUF.VAL=EDTBUF.VAL+J;
                            I=I+1;
                        END;
                        IF I<OUT$BLK.NSUBLKS THEN DO;
                            P=OUT$BLK.SUBLK$(I);
                            EDTBUF.INC=0;
                            IF P->OUT$BLK.CODE=%INTPART THEN DO;
                                CALL CHARBIN(J,P->OUT$SYM.TEXT);
                                IF J>99999 THEN DO;
                                    CALL WIZ$USRERR(%CPY_BEI);
                                    GOTO KEYFIX;
                                END;
                                EDTBUF.INC=1000*J;
                                I=I+1;
                            END;
                            IF I<OUT$BLK.NSUBLKS THEN DO;
                                P=OUT$BLK.SUBLK$(I);
                                CALL CHARBIN(J,P->OUT$SYM.TEXT);
                                IF J>999 THEN DO;
                                    CALL WIZ$USRERR(%CPY_BEI);
                                    GOTO KEYFIX;
                                END;
                                EDTBUF.INC=EDTBUF.INC+J;
                            END;
                        END;
                    END;
                    IF EDTBUF.INC=0 THEN DO;
                        CALL WIZ$USRERR(%CPY_BEI);
                        GOTO KEYFIX;
                    END;
                END;
            END;
            ELSE DO;
                CALL ADJKEY(OUT$BLK.SUBLK$(1),KEYWRK1) ALTRET
                    (KEYFIX);
                CALL EDT2BIN(OUT$BLK.SUBLK$(2),KEYWRK2) ALTRET
                    (KEYFIX);
                I=9*KEYWRK1.INT+KEYWRK1.FRC;
                J=9*KEYWRK2.INT+KEYWRK2.FRC;
                IF I+J>294912 OR J=0 OR J>2295 OR
                    (KEYTBL.KEYTYP=%KEYINDEX AND MOD(I,9)~=0) THEN DO;
                    CALL WIZ$USRERR(%CPY_BDK);
                    GOTO KEYFIX;
                END;
                KEYTBL.KEYLEN=J;
                IF KEYTBL.KEYTYP=%KEYIN THEN DO;
                    KEYTBL.KEYPTR=PINCRB(BUF_VLP.PTR$,I);
                    HWMREC=MAXIMUM(HWMREC,I+J);
                END;
                ELSE IF KEYTBL.KEYTYP=%KEYOUT THEN
                    KEYTBL.KEYPTR=PINCRB(OUT_VLP.PTR$,I);
                ELSE DO;
                    KEYTBL.KEYPTR=PINCRB(OUT_VLP.PTR$,I);
                    OPEN_EO.V.ORG#=%INDEXED#;
                    OPEN_EO.V.KEYL#=(KEYTBL.KEYLEN+8)/9;
                    OPEN_EO.V.KEYX#=I/9;
                END;
            END;
            OPEN_EO.V.ACS#=%DIRECT#;
            IF EOPTR->DUMMY.ORG#~=OPEN_EO.V.ORG# AND
                EOPTR->DUMMY.FCD# THEN DO;
                IF NOT EOPTR->DUMMY.FEXT THEN
                    CLOSE_EO.V.DISP#=%SCRATCH#;
                CALL XSA$CLOSE(CLOSE_EO,XSA_EO) ALTRET(EOERROR);
                CLOSE_EO.V.DISP#=%NAMED#;
                CALL OPEN(OPEN_EO,FID_EO,EO_VLR,XSA_EO) ALTRET(KEYOPEN);
            END;
            CALL VALIDATE_KEY;
            IF KEYTBL.KEYPTR=ADDR(NIL) THEN
                GOTO KEYFIX;
            HOLDING='0'B;
            GOTO READ_COMMAND;
 
KEYOPEN:
            CALL WIZ$SYSERR(DCBNUM(M$EO));
            GOTO KEYFIX;
 
KEYFIX:
            IF HOLDING THEN DO;
                CALL WIZ$USRERR(%CPY_RKY);
                KEYTBL=OLDKEY;
                EDTBUF=OLDEDT;
                OPEN_EO.V.ORG#=ORG_HOLD;
                HOLDING='0'B;
                IF EOPTR->DUMMY.FCI# THEN
                    CALL OPEN(OPEN_EO,FID_EO,EO_VLR,XSA_EO) ALTRET(EOERROR);
            END;
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(%OUTCMD) /* OUTPUT command */;
            IF EOPTR->DUMMY.FCD# THEN DO;
                IF NOT EOPTR->DUMMY.FEXT THEN
                    CLOSE_EO.V.DISP#=%SCRATCH#;
                CALL XSA$CLOSE(CLOSE_EO,XSA_EO) ALTRET(EOERROR);
                CLOSE_EO.V.DISP#=%NAMED#;
                NAME_HOLD=NAME_EO;
                PASS_HOLD=PASS_EO;
                SN_HOLD=SN_EO;
                ACCT_HOLD=ACCT_EO;
                WSN_HOLD=WSN_EO;
                ASN_HOLD=OPEN_EO.V.ASN#;
                RES_HOLD=OPEN_EO.V.RES#;
                EXIST_HOLD=OPEN_EO.V.EXIST#;
                HOLDING='1'B;
            END;
            ELSE
                HOLDING='0'B;
            OPEN_EO.V.EXIST#=%ERROR#;
            IF OUT$BLK.NSUBLKS=2 THEN DO;
                P=OUT$BLK.SUBLK$(0);
                OUT$BLK.SUBLK$(0)=OUT$BLK.SUBLK$(1);
                IF P->OUT$BLK.CODE=%HOWOVER THEN
                    OPEN_EO.V.EXIST#=%NEWFILE#;
                ELSE IF P->OUT$BLK.CODE=%HOWINTO THEN
                    OPEN_EO.V.EXIST#=%OLDFILE#;
            END;
            BLK$=OUT$BLK.SUBLK$(0);
            FID_EO.TEXTFID_=VECTOR(OUT$SYM.TEXT);
            CALL M$FID(FID_EO) ALTRET(EOFID);
            CALL OPEN(OPEN_EO,FID_EO,EO_VLR,XSA_EO) ALTRET(EOOPEN);
            I=EOPTR->DUMMY.ORG#;
            IF I~=%CONSEC# AND I~=%KEYED# AND I~=%UR#
                AND I~=%INDEXED# AND I~=%TERMINAL#
                AND I~=%FIXED# AND I~=%VARIABLE# AND
                I~=%UNDEF# THEN DO;
                CALL WIZ$USRERR(%CPY_IFT);
                CALL XSA$CLOSE(CLOSE_EO,XSA_EO) ALTRET(EOERROR);
                GOTO EOFIX;
            END;
            HOLDING='0'B;
            CALL VALIDATE_KEY;
            GOTO READ_COMMAND;
 
EOFID:
            CALL WIZ$USRERR(%CPY_EOF);
            GOTO EOFIX;
 
EOOPEN:
            CALL WIZ$SYSERR(DCBNUM(M$EO));
            GOTO EOFIX;
 
EOFIX:
            IF HOLDING THEN DO;
                NAME_EO=NAME_HOLD;
                PASS_EO=PASS_HOLD;
                SN_EO=SN_HOLD;
                ACCT_EO=ACCT_HOLD;
                WSN_EO=WSN_HOLD;
                OPEN_EO.V.ASN#=ASN_HOLD;
                OPEN_EO.V.RES#=RES_HOLD;
                OPEN_EO.V.EXIST#=EXIST_HOLD;
                HOLDING='0'B;
                CALL WIZ$USRERR(%CPY_ROF);
                CALL OPEN(OPEN_EO,FID_EO,EO_VLR,XSA_EO) ALTRET(EOERROR);
            END;
            IF PHASE=0 THEN
                GOTO READ_COMMAND;
            ELSE
                CALL WIZ$TERM(6);
 
%EJECT;
        CASE(%ORGCMD) /* ORG command */;
            CALL EDT2BIN(BLK$,KEYWRK1) ALTRET(READ_COMMAND);
            IF KEYWRK1.INT>1 OR KEYWRK1.FRC>1 THEN
                CALL WIZ$USRERR(%CPY_OTB);
            ELSE
                ORGBUF=KEYWRK1;
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(%SAVCMD) /* SAVE command */;
            IF SAVBUF THEN
                CALL WIZ$USRERR(%CPY_DSV);
            SAVBUF='1'B;
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(%USECMD) /* USE command */;
            CALL WIZ$WRITE('Not yet implemented!',20,'A');
            GOTO READ_COMMAND;
 
%EJECT;
        CASE(ELSE) /* ERROR! */;
            CALL WIZ$USRERR(%CPY_BUG);
            CALL WIZ$TERM(6);
 
    END;
 
ABNRML_EOJ:
    IF PHASE=1 AND NOT SAVBUF AND NOT EOPTR->DUMMY.FEXT THEN DO;
        CLOSE_EO.V.DISP#=%SCRATCH#;
        CALL WIZ$USRERR(%CPY_FNS);
    END;
    IF PHASE=0 AND NOT EOPTR->DUMMY.FEXT THEN
        CLOSE_EO.V.DISP#=%SCRATCH#;
 
NORMAL_EOJ:
    IF EOPTR->DUMMY.FCD# THEN
        CALL XSA$CLOSE(CLOSE_EO,XSA_EO);
    IF EIPTR->DUMMY.FCD# THEN
        CALL XSA$CLOSE(CLOSE_EI,XSA_EI);
    IF COUNT_EI>0 THEN
        CALL RECORD_COUNT;
    IF CLOSE_EO.V.DISP#=%SCRATCH# THEN
        CALL WIZ$TERM(4);
    ELSE
        CALL WIZ$TERM(0);
 
%EJECT;
/* **************************ERROR HANDLERS************************** */
 
REST_IGNORED:
    CALL WIZ$USRERR(%CPY_RCI);
    GOTO READ_COMMAND;
 
NO_ROOM:
    CALL WIZ$USRERR(%CPY_MEM);
    CALL WIZ$TERM(6);
 
SIERROR:
    CALL WIZ$USRERR(%CPY_UEF);
    CALL WIZ$TERM(6);
 
EIERROR:
    IF (XSA_INP AND (XSA_EI.ERR.CODE=6 OR XSA_EI.ERR.CODE=10)) OR
        (~XSA_INP AND (EIPTR->DUMMY.TYC.EOF# OR EIPTR->DUMMY.TYC.EOD#))
        THEN
        GOTO NORMAL_EOJ;
    CALL WIZ$SYSERR(DCBNUM(M$EI));
    IF PHASE=0 THEN
        GOTO READ_COMMAND;
    GOTO ABNRML_EOJ;
 
EOERROR:
    CALL WIZ$SYSERR(DCBNUM(M$EO));
    IF PHASE=0 THEN
        GOTO READ_COMMAND;
    GOTO ABNRML_EOJ;
 
CMDERROR:
    CALL WIZ$PARSERR(ADDR(WIZ$PCB));
    GOTO READ_COMMAND;
 
ABORT:
    CALL WIZ$TERM(6);
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   EDT2BIN decodes a field, start, count, or edit key parse structure *
*   at SRC into an integer part and fraction part at DST, ALTRETing    *
*   if either exceeds a halfword.                                      *
*                                                                      *
\******************************************************************** */
 
EDT2BIN: PROC(SRC,DST) ALTRET;
 
    DCL SRC                            PTR;
    DCL 1 DST,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
    DCL WORK                           UBIN;
 
    DST='0'B;
    IF SRC->OUT$BLK.NSUBLKS<1 OR SRC->OUT$BLK.NSUBLKS>2 THEN
        GOTO E2BERROR;
    CALL CHARBIN(WORK,SRC->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
    IF WORK>262143 THEN
        GOTO E2BERROR;
    IF SRC->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%INTPART THEN
        DST.INT=WORK;
    ELSE
        DST.FRC=WORK;
    IF SRC->OUT$BLK.NSUBLKS=2 THEN DO;
        CALL CHARBIN(WORK,SRC->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT);
        IF WORK>262143 THEN
            GOTO E2BERROR;
        DST.FRC=WORK;
    END;
    RETURN;
 
E2BERROR:
    WIZ$PCB.ERROR.CODE=%CPY_E2B;
    WIZ$PCB.HI_CHAR=SRC->OUT$BLK.CPOS;
    CALL WIZ$PARSERR(ADDR(WIZ$PCB));
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   ADJKEY uses EDT2BIN to retrieve and decode a field, start, or      *
*   count parse structure and then adjusts it for ORG, ALTRETing if    *
*   EDT2BIN ALTRETs or if an ORG conflict is detected.                 *
*                                                                      *
\******************************************************************** */
 
ADJKEY: PROC(SRC,DST) ALTRET;
 
    DCL SRC                            PTR;
    DCL 1 DST,
          2 INT UNAL                   UBIN HALF,
          2 FRC UNAL                   UBIN HALF;
 
    CALL EDT2BIN(SRC,DST) ALTRET(BADKEY);
    IF ORGBUF.INT=1 AND DST.INT<1 THEN DO;
        WIZ$PCB.ERROR.CODE=%CPY_OCF;
        WIZ$PCB.HI_CHAR=SRC->OUT$BLK.CPOS;
        CALL WIZ$PARSERR(ADDR(WIZ$PCB));
        ALTRETURN;
    END;
    DST.INT=DST.INT-ORGBUF.INT;
    IF ORGBUF.FRC=1 AND DST.FRC<1 THEN DO;
        WIZ$PCB.ERROR.CODE=%CPY_OCF;
        WIZ$PCB.HI_CHAR=SRC->OUT$BLK.CPOS;
        CALL WIZ$PARSERR(ADDR(WIZ$PCB));
        ALTRETURN;
    END;
    DST.FRC=DST.FRC-ORGBUF.FRC;
    RETURN;
 
BADKEY:
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Validate that the KEY and INPUT and OUTPUT commands do not         *
*   conflict; that is, if KEY IN is specified, the input file must     *
*   be keyed or indexed.  If KEY INDEX is specified, the output file   *
*   must be indexed; if KEY OUT or KEY EDIT or KEY IN/s/c is           *
*   specified, the output file must be keyed.  Conversely, if no       *
*   KEY is specified and the output file is keyed or indexed, a        *
*   KEY command is requested.  If an error occurs during phase 0,      *
*   return is made to the caller; otherwise, M$XXX is called.          *
*                                                                      *
\******************************************************************** */
 
VALIDATE_KEY: PROC;
 
    IF KEYTBL.KEYPTR=ADDR(NIL) THEN
        IF NOT EOPTR->DUMMY.FCD# THEN
            RETURN;
        ELSE DO;
            I=EOPTR->DUMMY.ORG#;
            IF I=%CONSEC# OR I=%UR# OR I=%TERMINAL#
                OR I=%FIXED# OR I=%VARIABLE# OR I=%UNDEF# THEN
                RETURN;
            ELSE IF I=%KEYED# THEN
                CALL WIZ$USRERR(%CPY_MBK);
            ELSE IF I=%INDEXED# THEN
                CALL WIZ$USRERR(%CPY_MBI);
            ELSE DO;
                CALL WIZ$USRERR(%CPY_IFT);
                CALL WIZ$TERM(6);
            END;
            RETURN;
        END;
    ELSE IF KEYTBL.KEYTYP=%KEYIN AND KEYTBL.KEYLEN=0 THEN
        IF NOT EIPTR->DUMMY.FCD# THEN
            GOTO CHECK_OUTPUT;
        ELSE DO;
            I=EIPTR->DUMMY.ORG#;
            IF I=%KEYED# OR I=%INDEXED# THEN
                GOTO CHECK_OUTPUT;
            ELSE
                CALL WIZ$USRERR(%CPY_INK);
        END;
    ELSE
 
CHECK_OUTPUT:
    IF NOT EOPTR->DUMMY.FCD# THEN
        RETURN;
    ELSE IF KEYTBL.KEYTYP=%KEYINDEX THEN
        IF EOPTR->DUMMY.ORG#=%INDEXED# THEN
            IF EOPTR->DUMMY.KEYL#~=OPEN_EO.V.KEYL# THEN
                CALL WIZ$USRERR(%CPY_IDM);
            ELSE
                RETURN;
        ELSE
            CALL WIZ$USRERR(%CPY_ONI);
    ELSE IF EOPTR->DUMMY.ORG#=%KEYED# THEN
        RETURN;
    ELSE
        CALL WIZ$USRERR(%CPY_ONK);
    KEYTBL.KEYPTR=ADDR(NIL);
    KEYTBL.KEYLEN=0;
    KEYTBL.KEYTYP=0;
    OPEN_EO.V.ACS#=%SEQUEN#;
    IF PHASE=0 THEN
        RETURN;
    ELSE
        CALL WIZ$TERM(6);
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   Stow the literal pointed to by the INPPTR in the literal pool      *
*   and return its address in OUTPTR and its bit length in LENGTH.     *
*   Acquire memory if necessary, ALTRETURN if an error occurs.         *
*                                                                      *
\******************************************************************** */
 
STOW_LIT: PROC(INPPTR,OUTPTR,LENGTH) ALTRET;
 
    DCL INPPTR                         PTR;
    DCL OUTPTR                         PTR;
    DCL LENGTH                         SBIN;
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL K                              SBIN;
    DCL P                              PTR;
    DCL Q                              PTR;
    DCL R                              PTR;
    DCL CH BASED(P) UNAL               CHAR(1);
    DCL B BASED(Q) UNAL                BIT(1);
    DCL O BASED(Q) UNAL                BIT(3);
    DCL C BASED(Q) UNAL                CHAR(K);
    DCL BITSQ BASED(Q) UNAL            BIT(K);
    DCL BITSR BASED(R) UNAL            BIT(K);
 
    I=INPPTR->OUT$BLK.CODE-200;
    IF I<%COPYBIT-200 OR I>%COPYUQL-200 THEN
        ALTRETURN;
    P=INPPTR;
    DO CASE(I);
        CASE(%(%COPYBIT-200));
            P=P->OUT$BLK.SUBLK$(0);
            K=P->OUT$SYM.COUNT;
        CASE(%(%COPYOCT-200));
            P=P->OUT$BLK.SUBLK$(0);
            K=P->OUT$SYM.COUNT*3;
        CASE(%(%COPYLIT-200));
            K=P->OUT$SYM.COUNT*9;
        CASE(%(%COPYUQL-200));
            P=P->OUT$BLK.SUBLK$(0);
            K=P->OUT$SYM.COUNT*9;
        CASE(ELSE);
            ALTRETURN;
    END;
    DO WHILE(K>LITBTS);
        CALL M$GDS(LIT_GDS) ALTRET(ERR_RTN);
        LITBTS=LITBTS+36864;
    END;
    P=ADDR(P->OUT$SYM.TEXT);
    Q=LITPTR;
    DO CASE(I);
        CASE(%(%COPYBIT-200));
            DO J=1 TO K;
                B=BINBIT(ASCBIN(CH)-ASCBIN('0'),1);
                P=PINCRC(P,1);
                Q=PINCRB(Q,1);
            END;
        CASE(%(%COPYOCT-200));
            K=K/3;
            DO J=1 TO K;
                O=BINBIT(ASCBIN(CH)-ASCBIN('0'),3);
                P=PINCRC(P,1);
                Q=PINCRB(Q,3);
            END;
            K=K*3;
        CASE(%(%COPYLIT-200),%(%COPYUQL-200));
            K=K/9;
            C=P->C;
            P=PINCRC(P,K);
            Q=PINCRC(Q,K);
            K=K*9;
        CASE(ELSE);
            ALTRETURN;
    END;
    Q=LITPTR;
    R=LIT_VLP.PTR$;
    J=POFFC(Q,R)-(K+8)/9+1;
    DO I=1 TO J;
        IF BITSQ=BITSR THEN DO;
            LENGTH=K;
            OUTPTR=R;
            RETURN;
        END;
        R=PINCRC(R,1);
    END;
    LENGTH=K;
    OUTPTR=Q;
    LITBTS=LITBTS-((K+8)/9)*9;
    LITPTR=PINCRC(LITPTR,(K+8)/9);
    RETURN;
 
ERR_RTN:
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   STOW_MBS stows the cell in MBSCELL on the top of the MBS list,     *
*   acquiring memory if necessary.                                     *
*                                                                      *
\******************************************************************** */
 
STOW_MBS: PROC(MBSCELL) ALTRET;
 
    DCL 1 MBSCELL,
          2 POINT                      PTR,
          2 LENGTH                     SBIN,
          2 *                          SBIN;
 
    DO WHILE(MBSWDS<SIZEW(MBS));
        CALL M$GDS(MBS_GDS) ALTRET(ERR_RTN);
        MBSWDS=MBSWDS+1024;
    END;
    MBS.SRCPTR=MBSCELL.POINT;
    MBS.SRCLEN=MBSCELL.LENGTH;
    MBS.SRCTYP=P->OUT$BLK.CODE;
    IF MBS.SRCTYP<%COPYFIELD OR MBS.SRCTYP>%COPYUQL THEN
        MBS.SRCTYP=%COPYFIELD;
    MBSPTR=PINCRW(MBSPTR,SIZEW(MBS));
    MBSWDS=MBSWDS-SIZEW(MBS);
    TOTLEN=TOTLEN+MBSCELL.LENGTH;
    IF MBSCELL.LENGTH=0 THEN
        VARYING='1'B;
    IF TOTLEN>262144 THEN DO;
        CALL WIZ$USRERR(%CPY_RTL);
        CALL WIZ$TERM(6);
    END;
    RETURN;
 
ERR_RTN:
    CALL WIZ$USRERR(%CPY_MEM);
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   GETSUBFIELDS processes the start and count fields of field, REC,   *
*   and KEY specifications on COPY statements.                         *
*                                                                      *
\******************************************************************** */
 
GETSUBFIELDS: PROC ALTRET;
 
    DCL P                              PTR;
    DCL J                              SBIN;
 
    KEYWRK2='0'B;
    KEYWRK3='0'B;
    J=1;
    IF Q->OUT$BLK.NSUBLKS<=1 THEN
        RETURN;
    IF Q->OUT$BLK.SUBLK$(1)->OUT$BLK.CODE=%FIELDSTART THEN DO;
        J=J+1;
        P=Q->OUT$BLK.SUBLK$(1);
        CALL ADJKEY(P,KEYWRK2) ALTRET(ERR_RTN);
        WRK.BASE=WRK.BASE+9*KEYWRK2.INT+KEYWRK2.FRC;
        IF Q->OUT$BLK.NSUBLKS<=2 THEN
            RETURN;
    END;
    IF Q->OUT$BLK.SUBLK$(J)->OUT$BLK.CODE=%FIELDCOUNT THEN DO;
        P=Q->OUT$BLK.SUBLK$(J);
        CALL EDT2BIN(P,KEYWRK3) ALTRET(ERR_RTN);
        WRK.LEN=9*KEYWRK3.INT+KEYWRK3.FRC;
    END;
    RETURN;
 
ERR_RTN:
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   RECORD_COUNT displays the current input and output record          *
*   counts on M$LO and returns to the caller after resetting the       *
*   break counter.                                                     *
*                                                                      *
\******************************************************************** */
 
RECORD_COUNT: PROC;
 
    DCL I                              SBIN;
    DCL J                              SBIN;
    DCL WRKBUF                         CHAR(8);
 
    CALL BINCHAR(WRKBUF,COUNT_EI);
    J=0;
    DO WHILE(J<7 AND SUBSTR(WRKBUF,J,1)='0');
        J=J+1;
    END;
    CALL INSERT(CMDBUF,0,23-J,'Records input: ',SUBSTR(WRKBUF,J,8-J));
    I=23-J;
    CALL BINCHAR(WRKBUF,COUNT_EO);
    J=0;
    DO WHILE(J<7 AND SUBSTR(WRKBUF,J,1)='0');
        J=J+1;
    END;
    CALL INSERT(CMDBUF,I,26-J,'; records output: ',SUBSTR(WRKBUF,J,8-J));
    I=I+26-J;
    CALL WIZ$WRITE(CMDBUF,I,'A');
    BROKEN=0;
    RETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   GET_TOKEN returns a pointer to the next token in an IF command     *
*   parse tree.  If none is left, ADDR(EOL) is returned.               *
*                                                                      *
\******************************************************************** */
 
GET_TOKEN: PROC;
 
    IF I>=OUT$BLK.NSUBLKS THEN
        STACK(STK)=ADDR(EOL);
    ELSE
        STACK(STK)=OUT$BLK.SUBLK$(I);
    I=I+1;
    RETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   GENERATE_FRV generates a CBS table block based on the contents     *
*   of STACK(FRV), STACK(FRV+1), and STACK(FRV+2).  RESOLVED is set    *
*   to '1'B (NO).  ALTRET is taken if anything goes wrong.             *
*                                                                      *
\******************************************************************** */
 
GENERATE_FRV: PROC(FRV) ALTRET;
 
    DCL FRV                            SBIN;
 
    DCL P                              PTR;
 
    DO WHILE(CBSWDS<SIZEW(CBS));
        CALL M$GDS(CBS_GDS) ALTRET(MEM_RTN);
        CBSWDS=CBSWDS+1024;
        CBS_HOLD=CBS_HOLD+1024;
    END;
    CALL STOW_LIT(STACK(FRV+2),CBS.DSTPTR,WRK.LEN) ALTRET(ERR_RTN);
    CBS.SRCLEN=WRK.LEN;
    P=STACK(FRV);
    IF P->OUT$BLK.CODE=%COPYFIELD THEN DO;
        CALL EDT2BIN(P,KEYWRK1) ALTRET(ERR_RTN);
        IF USEBUF THEN DO;
            /* More missing code! */;
        END;
        ELSE DO;
            IF ORGBUF.INT=1 AND KEYWRK1.INT<1 THEN DO;
                WIZ$PCB.ERROR.CODE=%CPY_OCF;
                WIZ$PCB.HI_CHAR=P->OUT$BLK.CPOS;
                CALL WIZ$PARSERR(ADDR(WIZ$PCB));
                ALTRETURN;
            END;
            WRK.BASE=9*(KEYWRK1.INT-ORGBUF.INT);
        END;
        IF ORGBUF.FRC=1 AND KEYWRK1.FRC<1 THEN DO;
            WIZ$PCB.ERROR.CODE=%CPY_OCF;
            WIZ$PCB.HI_CHAR=P->OUT$BLK.CPOS;
            CALL WIZ$PARSERR(ADDR(WIZ$PCB));
            ALTRETURN;
        END;
        WRK.BASE=WRK.BASE+KEYWRK1.FRC;
        WRK.POINT=PINCRB(BUF_VLP.PTR$,WRK.BASE);
        IF WRK.BASE+WRK.LEN>HWMREC THEN
            HWMREC=WRK.BASE+WRK.LEN;
    END;
    ELSE IF P->OUT$BLK.CODE=%COPYREC THEN DO;
        WRK.BASE=0;
        WRK.POINT=PINCRB(ADDR(RECBUF),72-WRK.LEN);
    END;
    ELSE IF P->OUT$BLK.CODE=%COPYKEY THEN DO;
        WRK.BASE=0;
        WRK.POINT=ADDR(KEYBUF.C);
        IF WRK.BASE+WRK.LEN>HWMKEY THEN
            HWMKEY=WRK.BASE+WRK.LEN;
        KEYUSED='1'B;
    END;
    ELSE DO;
        CALL WIZ$USRERR(%CPY_BUG);
        CALL WIZ$TERM(6);
    END;
    CBS.SRCPTR=WRK.POINT;
    P=STACK(FRV+1);
    IF P->OUT$BLK.CODE>=%RELLE AND P->OUT$BLK.CODE<=%RELGT THEN
        CBS.BC=P->OUT$BLK.CODE-600;
    ELSE DO;
        CALL WIZ$USRERR(%CPY_BUG);
        CALL WIZ$TERM(6);
    END;
    CBS.NEXT=32767;
    RETURN;
 
MEM_RTN:
    CALL WIZ$USRERR(%CPY_MEM);
 
ERR_RTN:
    ALTRETURN;
 
END;
 
%EJECT;
/* ********************************************************************\
*                                                                      *
*   OPEN "fixes" the open FPT passed to it according to the bits       *
*   set in the VLR_FID passed, then attempts to open the file.         *
*                                                                      *
\******************************************************************** */
 
OPEN: PROC(OPEN_FPT,FID_FPT,FID_VLR,XSA_FPT) ALTRET;
 
%FPT_OPEN(FPTN=OPEN_FPT,
          STCLASS=" ");
%FPT_FID(FPTN=FID_FPT,
         STCLASS=" ");
%VLR_FID(FPTN=FID_VLR,
         STCLASS=" ");
%XSA_PARAM(FPTN=XSA_FPT,
           STCLASS=" ");
 
    IF FID_VLR.NAME THEN
        OPEN_FPT.NAME_=FID_FPT.NAME_;
    ELSE
        OPEN_FPT.NAME_=VECTOR(NIL);
    IF FID_VLR.ACCT THEN
        OPEN_FPT.ACCT_=FID_FPT.ACCT_;
    ELSE
        OPEN_FPT.ACCT_=VECTOR(NIL);
    IF FID_VLR.PASS THEN
        OPEN_FPT.PASS_=FID_FPT.PASS_;
    ELSE
        OPEN_FPT.PASS_=VECTOR(NIL);
    IF FID_VLR.SN THEN
        OPEN_FPT.SN_=FID_FPT.SN_;
    ELSE
        OPEN_FPT.SN_=VECTOR(NIL);
    IF FID_VLR.WSN THEN
        OPEN_FPT.WSN_=FID_FPT.WSN_;
    ELSE
        OPEN_FPT.WSN_=VECTOR(NIL);
    IF FID_VLR.ASN THEN
        ;
    ELSE
        OPEN_FPT.V.ASN#=0;
    IF FID_VLR.RES THEN
        ;
    ELSE
        OPEN_FPT.V.RES#=BINASC(0);
    CALL XSA$OPEN(OPEN_FPT,XSA_FPT) ALTRET(ERR_RTN);
    RETURN;
 
ERR_RTN:
    IF DCBADDR(OPEN_FPT.V.DCB#)->DUMMY.FCD# THEN
        RETURN;
    ALTRETURN;
 
END;
 
END;
