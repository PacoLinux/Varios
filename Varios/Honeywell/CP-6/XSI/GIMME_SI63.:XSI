/*M* GIMME_SI63 - this module contains utility subroutines for GIMME.         */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
MUNGE_PARTS: PROC (OUT_BLK) ALTRET;
/**/
/*  There are quite a few parts that can appear in many GIMME commands.       */
/*  This routine traverses the parse blocks looking for common options        */
/*  and processes them.                                                       */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
%PARSE$OUT (NAME=OUT_BLK,
            STCLASS=" ");
/**/
/*  LOCAL AUTO  */
/**/
DCL NODE SBIN WORD;
DCL NODE$ PTR;
/**/
/*  ENTRY DCLS  */
/**/
DCL MUNGE_ONE_PART ENTRY(1) ALTRET;
%EJECT;
/**/
/* Make sure that we can do this!                                             */
/**/
     IF NOT M$SIGN_SHEET$ -> F$DCB.FCD#
      THEN                              /* File isn't open, this is silly!    */
        DO;
           ERROR_CODE.ERR# = %DEG$NO_FILE_OPEN#;
/*E* ERROR: DEG-DEG$NO_FILE_OPEN#-2
   MESSAGE: There is no sign-up file open now.
*/
           GOTO ERR_BAILOUT;
           END;
/**/
/*  Start options with a clean slate.                                         */
/**/
     OPT = '0'B;                        /* Scrub options block                */
/**/
/* Process each option that we were passed.                                   */
/**/
     DO NODE = 0 TO OUT_BLK.NSUBLKS-1;
        NODE$ = OUT_BLK.SUBLK$(NODE);
        CALL MUNGE_ONE_PART (NODE$ -> OUT$BLK) ALTRET(BAILOUT);
        END;                            /* END DO INDEX on sub-blocks         */
     RETURN;
/**/
ERR_BAILOUT: ;
     CALL XUR$ERRMSG (ERROR_CODE);
BAILOUT: ;
     ALTRETURN;
/**/
     END MUNGE_PARTS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
MUNGE_ONE_PART: PROC (OUT_BLK) ALTRET;
/**/
/*  This routine munges one output block that may contain any part.           */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
%PARSE$OUT (NAME=OUT_BLK,
            STCLASS=" ");
/**/
/*  LOCAL AUTO  */
/**/
DCL KLUGE$ PTR;
/**/
/*  ENTRY DCLS  */
/**/
DCL CONVERT_TIME_NODE ENTRY(2) ALTRET;
DCL CONVERT_TIME ENTRY(2);
/**/
/*  BASED STRUCTURES  */
/**/
%PARSE$SYM (NAME=OUT_SYM,
            STCLASS="BASED(KLUGE$)");
%EJECT;
     KLUGE$ = ADDR(OUT_BLK);
     DO CASE(OUT_BLK.CODE);
        CASE(%START_TIME_PART#);
          CALL CONVERT_TIME_NODE (OPT.START_TIME,
               OUT_BLK.SUBLK$(0) -> OUT$BLK) ALTRET(BAD_START_TIME);
          DO WHILE ('0'B);
BAD_START_TIME: ;
             ERROR_CODE.ERR# = %DEG$BAD_START_TIME#;
/*E* ERROR: DEG-DEG$BAD_START_TIME#-2
   MESSAGE: Invalid start time.
*/
             GOTO BAD_NEWS;
             END;
        CASE(%END_TIME_PART#);
          CALL CONVERT_TIME_NODE (OPT.END_TIME,
               OUT_BLK.SUBLK$(0) -> OUT$BLK) ALTRET(BAD_END_TIME);
          DO WHILE ('0'B);
BAD_END_TIME: ;
             ERROR_CODE.ERR# = %DEG$BAD_END_TIME#;
/*E* ERROR: DEG-DEG$BAD_END_TIME#-2
   MESSAGE: Invalid end time.
*/
             GOTO BAD_NEWS;
             END;
        CASE(%RESOURCE_PART#);
          IF OUT_SYM.COUNT
           > SIZEC(OPT.RESOURCE.RES.TEXT)
           THEN
             DO;
               ERROR_CODE.ERR# = %DEG$BAD_RESOURCE#;
/*E* ERROR: DEG-DEG$BAD_RESOURCE#-2
   MESSAGE: Invalid RESOURCE specification.
*/
               GOTO BAD_NEWS;
               END;
          OPT.RESOURCE.PRESENT = '1'B;
          OPT.RESOURCE.RES.C = OUT_SYM.COUNT;
          OPT.RESOURCE.RES.TEXT = OUT_SYM.TEXT;
        CASE(%ALIAS_PART#);
          IF OUT_SYM.COUNT
           > SIZEC(OPT.ALIAS.RES.TEXT)
           THEN
             DO;
               ERROR_CODE.ERR# = %DEG$BAD_ALIAS#;
/*E* ERROR: DEG-DEG$BAD_ALIAS#-2
   MESSAGE: Invalid ALIAS specification.
*/
               GOTO BAD_NEWS;
               END;
          OPT.ALIAS.PRESENT = '1'B;
          OPT.ALIAS.RES.C = OUT_BLK.SUBLK$(0) -> OUT_SYM.COUNT;
          OPT.ALIAS.RES.TEXT = OUT_BLK.SUBLK$(0) -> OUT_SYM.TEXT;
        CASE(%REASON_PART#);
          OPT.REASON.PRESENT = '1'B;
          OPT.REASON.C = MINIMUM (SIZEC(OPT.REASON.TEXT),
           OUT_BLK.SUBLK$(0) -> OUT$SYM.COUNT);
          OPT.REASON.TEXT = SUBSTR(
           OUT_BLK.SUBLK$(0) -> OUT$SYM.TEXT,0,
           OPT.REASON.C);
        CASE(%ID_PART#);
          CALL CONVERT_TIME_NODE (OPT.ID_TIME,
               OUT_BLK.SUBLK$(0) -> OUT$BLK) ALTRET(BAD_ID_TIME);
          DO WHILE ('0'B);
BAD_ID_TIME: ;
             ERROR_CODE.ERR# = %DEG$BAD_ID_TIME#;
/*E* ERROR: DEG-DEG$BAD_ID_TIME#-2
   MESSAGE: Invalid identification time.
*/
             GOTO BAD_NEWS;
             END;
        CASE(%SITE_PART#);
          OPT.SITE.PRESENT = '1'B;
          OPT.SITE.C = OUT_BLK.SUBLK$(0) -> OUT_SYM.COUNT;
          OPT.SITE.TEXT = OUT_BLK.SUBLK$(0) -> OUT_SYM.TEXT;
        CASE(%AVAIL_TIME_PART#);
          IF OUT_BLK.NSUBLKS ~= 2 THEN
            DO;
              ERROR_CODE.ERR# = %DEG$BAD_TIME_RANGE#;
/*E* ERROR: DEG-DEG$BAD_TIME_RANGE#-2
    MESSAGE: Invalid time range.
*/
              GOTO BAD_NEWS;
              END;
 
          CALL CONVERT_TIME (OPT.AVAIL_TIME.START_,
                                  OUT_BLK.SUBLK$(0) -> OUT$BLK);
          CALL CONVERT_TIME (OPT.AVAIL_TIME.END_,
                                  OUT_BLK.SUBLK$(1) -> OUT$BLK);
          OPT.AVAIL_TIME.PRESENT = '1'B;
        CASE(%DISPLAY_OPT_PART#);
          OPT.DISPLAY_OPT.PRESENT = '1'B;
          OPT.DISPLAY_OPT.CODE = OUT_BLK.SUBLK$(0) -> OUT$BLK.CODE;
        CASE(%REASON_SPEC#);
          OPT.REASON_SPEC.PRESENT = '1'B;
          OPT.REASON_SPEC.CODE = OUT_BLK.SUBLK$(0) -> OUT$BLK.CODE;
          IF OPT.REASON_SPEC.CODE = %DEFAULT# THEN
            DO;
              OPT.REASON_SPEC.DEFAULT.C = OUT_BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0)
                                          -> OUT_SYM.COUNT;
              OPT.REASON_SPEC.DEFAULT.TEXT = OUT_BLK.SUBLK$(0) ->
                                             OUT$BLK.SUBLK$(0) -> OUT_SYM.TEXT;
              END;  /* get default reason string  */
        CASE(ELSE);
          ;                          /* We aren't interested in it!        */
        END;                         /* END CASE                           */
     RETURN;
/**/
BAD_NEWS: ;
     CALL XUR$ERRMSG (ERROR_CODE);
     ALTRETURN;
/**/
     END MUNGE_ONE_PART;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
GET_NEXT_RES: PROC (LAST_RES_TEXT,LAST_RES_C,ALIAS_ACCEPTABLE) ALTRET;
/**/
/*  This routine is used to sequence through the resource names in the        */
/*  sign-up sheet file.                                                       */
/*                                                                            */
/*  The first call should use a length of 0 for the resource name.            */
/*  Subsequent calls should pass the last used resource name.                 */
/*                                                                            */
/*  In the event that there are no resource names remaining, this             */
/*  routine will ALTRET.                                                      */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
DCL LAST_RES_C UBIN BYTE CALIGNED;
DCL LAST_RES_TEXT CHAR(31) CALIGNED;
DCL ALIAS_ACCEPTABLE SBIN WORD;
%EJECT;
     IF LAST_RES_C = 0
      THEN
        DO;
/**/
/*  Position at the first record.                                             */
/**/
          SHEET_KEY.REST = '0'B;
          CALL KEYED_READ;
          END;
     ELSE
       DO;
/**/
/*  Get the next one  */
/**/
        SHEET_KEY.REST = '0'B;
        SHEET_KEY.REST.RES.C = LAST_RES_C;
        SHEET_KEY.REST.RES.TEXT = LAST_RES_TEXT;
NEXT_L: ;
        CALL INSERT (SHEET_KEY.REST.RES.TEXT,
                     SIZEC(SHEET_KEY.REST.RES.TEXT)-1,1,
                     BINASC(ASCBIN(SUBSTR(SHEET_KEY.REST.RES.TEXT,
                       SIZEC(SHEET_KEY.REST.RES.TEXT)-1,1) )+1));
        CALL KEYED_READ;
        END;
     DO CASE(SHEET_RECORD.TYPE);
        CASE(%RT_RES#);
          ;                             /* OK!                                */
        CASE(%RT_END#);
          ALTRETURN;
        CASE(%RT_SIGN#);
          GOTO NEXT_L;
        CASE(%RT_ALIAS#);
          IF ALIAS_ACCEPTABLE = 0
           THEN
             GOTO NEXT_L;
        END;
/**/
     LAST_RES_C = SHEET_KEY.REST.RES.C;
     LAST_RES_TEXT = SHEET_KEY.REST.RES.TEXT;
     RES_AVAIL_TIME.START_ = SHEET_RECORD.RES.AVAIL_TIME.START_;
     RES_AVAIL_TIME.END_ = SHEET_RECORD.RES.AVAIL_TIME.END_;
     RETURN;
%EJECT;
KEYED_READ: PROC;
/**/
/*  This routine reads the record with the specified key, or the one          */
/*  following, if the specified key does not exist.                           */
/**/
     FPT_READ_SHEET.V.KEYS# = '1'B;
     CALL M$READ (FPT_READ_SHEET)
       WHENALTRETURN DO;
         FPT_READ_SHEET.V.KEYS# = '0'B;
         CALL M$READ (FPT_READ_SHEET);
         END;
     RETURN;
     END KEYED_READ;
/**/
     END GET_NEXT_RES;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
INSURE_PARTS: PROC (PART_MASK) ALTRET;
/**/
/*  There are quite a few parts that can appear in many GIMME commands.       */
/*  They are usually marked as optional in the main command node, but are     */
/*  required anyway.  This routine prompts for omitted ones.                  */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE XUD_UTS_M;
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
DCL PART_MASK BIT(36);
/**/
/*  ENTRY DCLS  */
/**/
DCL MUNGE_ONE_PART ENTRY(1) ALTRET;
/**/
/*  LOCAL AUTO  */
/**/
DCL CURRENT_PART SBIN WORD;
/**/
/*  LOCAL CONSTANTS  */
/**/
DCL 1 PART_TABLE (0:%(NUMBER_OF_PARTS#-1)) CONSTANT,
      2 PM BIT(36) INIT(
            %START_TIME_PM#,
            %END_TIME_PM#,
            %RESOURCE_PM#,
            %REASON_PM#,
            %ALIAS_PM#,
            %ID_PM#,
            %SITE_PM#,
            %AVAIL_TIME_PM#,
            %DISPLAY_OPT_PM#,
            %REASON_SPEC_PM#),
      2 NODE$ PTR INIT(
            ADDR(START_TIME_STUB),
            ADDR(END_TIME_STUB),
            ADDR(RESOURCE_STUB),
            ADDR(REASON_STUB),
            ADDR(ALIAS_STUB),
            ADDR(ID_STUB),
            ADDR(SITE_STUB),
            ADDR(AVAIL_TIME_STUB),
            ADDR(DISPLAY_OPT_STUB),
            ADDR(REASON_SPEC_STUB)),
      2 PRESENT$ PTR INIT(
            ADDR(OPT.START_TIME.PRESENT),
            ADDR(OPT.END_TIME.PRESENT),
            ADDR(OPT.RESOURCE.PRESENT),
            ADDR(OPT.REASON.PRESENT),
            ADDR(OPT.ALIAS.PRESENT),
            ADDR(OPT.ID_TIME.PRESENT),
            ADDR(OPT.SITE.PRESENT),
            ADDR(OPT.AVAIL_TIME.PRESENT),
            ADDR(OPT.DISPLAY_OPT.PRESENT),
            ADDR(OPT.REASON_SPEC.PRESENT)),
      2 PMPT_MSG SBIN WORD INIT(
            %DEG$ASK_START_TIME#,
/*E* ERROR:   DEG-DEG$ASK_START_TIME#-2
     MESSAGE: When do you want to start?
*/
            %DEG$ASK_END_TIME#,
/*E* ERROR:   DEG-DEG$ASK_END_TIME#-2
     MESSAGE: How long do you need it?
*/
            %DEG$ASK_RESOURCE#,
/*E* ERROR:   DEG-DEG$ASK_RESOURCE#-2
     MESSAGE: What is the name of the resource?
*/
            %DEG$ASK_REASON#,
/*E* ERROR:   DEG-DEG$ASK_REASON#-2
     MESSAGE: Why do you need it?
*/
            %DEG$ASK_ALIAS#,
/*E* ERROR:   DEG-DEG$ASK_ALIAS#-2
     MESSAGE: What is the alias?
*/
            %DEG$ASK_ID#,
/*E* ERROR:   DEG-DEG$ASK_ID#-2
     MESSAGE: Which instance (starting time) of this resource?
*/
            %DEG$ASK_SITE#,
/*E* ERROR:   DEG-DEG$ASK_SITE#-2
     MESSAGE: What is the associated site name?
*/
            %DEG$ASK_AVAIL_TIME#,
/*E* ERROR:   DEG-DEG$ASK_AVAIL_TIME#-2
     MESSAGE: What is the normal available time range?
*/
            %DEG$ASK_DISPLAY_OPT#,
/*E* ERROR:   DEG-DEG$ASK_DISPLAY_OPT#-2
     MESSAGE: What is the display option?
*/
            %DEG$ASK_REASON_SPEC#);
/*E* ERROR:   DEG-DEG$ASK_REASON_SPEC#-2
     MESSAGE: Is a reason required/optional/default for getting the resource?   */
DCL PROMPT CHAR(0) CONSTANT INIT('- ');
/**/
/*  LOCAL AUTO  */
/**/
%VLP_ERRCODE (FPTN = ERR_CODE,
              STCLASS = AUTO);
DCL OUT$ REDEF ERR_CODE PTR;
/**/
/*  BASED STRUCTURES  */
/**/
DCL BIT$1 BIT(1) BASED UNAL;
%EJECT;
     DO CURRENT_PART = 0 TO %NUMBER_OF_PARTS#-1;
        IF NOT (PART_TABLE.PM(CURRENT_PART) & PART_MASK)
           THEN                         /* Not required                       */
             GOTO NEXT_PART;
        IF PART_TABLE.PRESENT$(CURRENT_PART) -> BIT$1
           THEN                         /* Have one already!                  */
             GOTO NEXT_PART;
/**/
/*  We don't have one of these and would like one.  */
/**/
        DO WHILE ('0'B);
PARSE_ERROR: ;
           CALL XUR$ECHOIF (DCBNUM(M$DO));
           IF ERR_CODE.ERR# = %E$SYNERR
            THEN
              CALL XUR$ERRPTR (,DCBNUM(M$DO));
           CALL XUR$ERRMSG (ERR_CODE);
           END;
        ERROR_CODE.ERR# = PART_TABLE.PMPT_MSG(CURRENT_PART);
        CALL XUR$ERRMSG (ERROR_CODE);
        CALL XUR$GETCMD( PART_TABLE.NODE$(CURRENT_PART) -> BIT$1,
          OUT$,VECTOR(PROMPT)) ALTRET (PARSE_ERROR);
        CALL MUNGE_ONE_PART (OUT$ -> OUT$BLK) ALTRET (SCUMMY_HAPPENINGS);
NEXT_PART: ;
        END;                            /* END DO INDEX                       */
%EJECT;
/**/
/*  Relative forms of the source are with respect to now.                     */
/**/
     IF OPT.START_TIME.RELATIVE THEN
      DO;
        CALL XUD$UTS_ADJUST(OPT.START_TIME.UTS,NOW_UTS,
             OPT.START_TIME.UTS);
        OPT.START_TIME.RELATIVE = '0'B;
        END;
/**/
/*  Relative forms of the ending are with respect to starting time if there   */
/*  is one.  Otherwise, it's with respect to the ID.                          */
/**/
     IF OPT.END_TIME.RELATIVE
      THEN                              /* Needs adjustment                   */
        IF OPT.START_TIME.PRESENT THEN
         DO;
           CALL XUD$UTS_ADJUST(OPT.END_TIME.UTS,OPT.START_TIME.UTS,
                OPT.END_TIME.UTS);
           END;
         ELSE
           CALL XUD$UTS_ADJUST(OPT.END_TIME.UTS,OPT.ID_TIME.UTS,
                OPT.END_TIME.UTS);
/**/
/*  Relative forms of the ID time are with respect to now.                    */
/**/
     IF OPT.ID_TIME.RELATIVE THEN
      DO;
        CALL XUD$UTS_ADJUST(OPT.ID_TIME.UTS,NOW_UTS,
             OPT.ID_TIME.UTS);
        OPT.ID_TIME.RELATIVE = '0'B;
        END;
/**/
     RETURN;
/**/
SCUMMY_HAPPENINGS: ;
     ALTRETURN;
/**/
     END INSURE_PARTS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CONVERT_TIME: PROC (TIME_STR, OUT_BLK);
/**/
/*  This routine builds a time string in the format of HH:MM   */
/*  from a parse output node that is of type %TIME#            */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARARAMETERS   */
/**/
%PARSE$OUT (NAME=OUT_BLK,
            STCLASS=" ");
DCL TIME_STR CHAR(5);
DCL 1 TIME_BUF REDEF TIME_STR,
      2 H CHAR(2),
      2 COLON CHAR(1),
      2 M CHAR(2);
/**/
/*  LOCAL AUTO  */
/**/
DCL I SBIN;
DCL LEN SBIN;
%EJECT;
     TIME_BUF.H = '00';
     LEN = OUT_BLK.SUBLK$(0) -> OUT$SYM.COUNT;
     CALL INSERT(TIME_BUF.H,2-LEN,LEN,OUT_BLK.SUBLK$(0) -> OUT$SYM.TEXT);
     TIME_BUF.COLON = ':';
     TIME_BUF.M = '00';
     LEN = OUT_BLK.SUBLK$(1) -> OUT$SYM.COUNT;
     CALL INSERT(TIME_BUF.M,2-LEN,LEN,OUT_BLK.SUBLK$(1) -> OUT$SYM.TEXT);
     IF OUT_BLK.NSUBLKS = 3 THEN
        DO CASE(OUT_BLK.SUBLK$(2) -> OUT$BLK.CODE);
           CASE(%AM#);
             ;
           CASE(%PM#);
             CALL CHARBIN(I,TIME_BUF.H);
             I = I +12;
             CALL BINCHAR(TIME_BUF.H,I);
           END;            /* END CASE AM/PM                     */
     RETURN;
     END CONVERT_TIME;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CONVERT_TIME_NODE: PROC (TIME_BLOCK,OUT_BLK) ALTRET;
/**/
/*  This routine builds a time block from a parse output block that           */
/*  is either of the time catagories.                                         */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE XUD_UTS_M;
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
%PARSE$OUT (NAME=OUT_BLK,
            STCLASS=" ");
%TIME_BLOCK (NAME=TIME_BLOCK,
             STCLASS = " ");
/**/
/*  LOCAL STATIC  */
/**/
DCL UTS SBIN WORD STATIC;
%FPT_TIME (FPTN = FPT_TIME,
           DATE = DATE_BUF,
           TSTAMP = UTS,
           TIME = TIME_BUF,
           STCLASS = STATIC);
DCL 1 DATE_BUF STATIC,
      2 M CHAR(2) INIT('00'),
      2 * CHAR(1) INIT('/'),
      2 D CHAR(2) INIT('00'),
      2 * CHAR(1) INIT('/'),
      2 Y CHAR(2) INIT('00');
DCL 1 TIME_BUF STATIC,
      2 H CHAR(2) INIT('00'),
      2 * CHAR(1) INIT(':'),
      2 M CHAR(2) INIT('00'),
      2 * CHAR(1) INIT(':'),
      2 S CHAR(2) INIT('00'),
      2 * CHAR(1) INIT('.'),
      2 X CHAR(2) INIT('00');
/**/
/*  LOCAL AUTO  */
/**/
DCL TICK_SIZE SBIN WORD;
DCL NUM_TICKS SBIN WORD;
DCL OFFSET SBIN WORD;
DCL NODE SBIN WORD;
DCL NODE$ PTR;
DCL I SBIN;
DCL UTS_DIFF UBIN;
/**/
/*  ENTRY DCLS  */
/**/
DCL MAKE_NOW_UTS ENTRY;
%EJECT;
    TIME_BLOCK.DATE_PRESENT = '0'B;
    TIME_BLOCK.HOUR_PRESENT = '0'B;
     DO CASE(OUT_BLK.CODE);
        CASE(%NOW_TIME#);
          TIME_BLOCK.RELATIVE = '0'B;
          TIME_BLOCK.UTS = NOW_UTS;
          TIME_BLOCK.DATE_PRESENT = '1'B;
          TIME_BLOCK.HOUR_PRESENT = '1'B;
        CASE(%SPECIFIC_TIME#);
          TIME_BLOCK.RELATIVE = '0'B;
          FPT_TIME.V.SOURCE# = %CLOCK#;
          FPT_TIME.V.DEST# = %LOCAL#;
          CALL M$TIME (FPT_TIME);       /* Get default time pieces            */
          OFFSET = 0;
          DO NODE = 0 TO OUT_BLK.NSUBLKS-1;
             NODE$ = OUT_BLK.SUBLK$(NODE);
             DO CASE (NODE$ -> OUT$BLK.CODE);
                CASE (%TOMORROW#);
                  OFFSET = %UTS_CSEC_DAY#;
                  TIME_BLOCK.DATE_PRESENT = '1'B;
                CASE (%TODAY#);
                  OFFSET = 0;
                  TIME_BLOCK.DATE_PRESENT = '1'B;
                CASE (%YESTERDAY#);
                  OFFSET = -%UTS_CSEC_DAY#;
                  TIME_BLOCK.DATE_PRESENT = '1'B;
                CASE (%DATE#);
                  CALL STUFF2(DATE_BUF.M,0);
                  CALL STUFF2(DATE_BUF.D,1);
                  IF NODE$ -> OUT$BLK.NSUBLKS = 3 THEN
                     CALL STUFF2(DATE_BUF.Y,2);
                  TIME_BLOCK.DATE_PRESENT = '1'B;
                CASE (%TIME#);
                  TIME_BLOCK.HOUR_PRESENT = '1'B;
                  CALL STUFF2(TIME_BUF.H,0);
                  CALL STUFF2(TIME_BUF.M,1);
                  TIME_BUF.S = '00';
                  TIME_BUF.X = '00';
                  IF NODE$ -> OUT$BLK.NSUBLKS = 3 THEN
                     DO CASE(NODE$ -> OUT$BLK.SUBLK$(2) -> OUT$BLK.CODE);
                        CASE(%AM#);
                          ;
                        CASE(%PM#);
                          CALL CHARBIN(I,TIME_BUF.H);
                          I = I +12;
                          CALL BINCHAR(TIME_BUF.H,I);
                        END;            /* END CASE AM/PM                     */
                END;                    /* END DO CASE NODE TYPE              */
             END;                       /* END DO INDEX NODE                  */
          FPT_TIME.V.SOURCE# = %LOCAL#;
          FPT_TIME.V.DEST# = %UTS#;
          CALL M$TIME (FPT_TIME) ALTRET(BAD_NEWS);
          CALL XUD$UTS_ADJUST(UTS,UTS,OFFSET);
          CALL XUD$UTS_DIFF_25TH(UTS_DIFF,UTS,0);
          UTS_DIFF=(UTS_DIFF/%UTS_25TH_MIN#);
          CALL XUD$UTS_ADJ_25TH(UTS,0,UTS_DIFF*%UTS_25TH_MIN#);
          TIME_BLOCK.UTS = UTS;
        CASE(%RELATIVE_TIME#);
          DO CASE(OUT_BLK.SUBLK$(1) -> OUT$BLK.CODE);
             CASE (%MINUTES#);
               TICK_SIZE = %UTS_CSEC_MIN#;
             CASE (%HOURS#);
               TICK_SIZE = %UTS_CSEC_HOUR#;
             CASE (%DAYS#);
               TICK_SIZE = %UTS_CSEC_DAY#;
             CASE (%WEEKS#);
               TICK_SIZE = %UTS_CSEC_DAY#*7;
             CASE (%MONTHS#);
               TICK_SIZE = %UTS_CSEC_DAY#*30;
             CASE (%YEARS#);
               TICK_SIZE = %UTS_CSEC_DAY#*365;
             END;
          CALL X$DEC_CONVERT (OUT_BLK.SUBLK$(0) -> OUT$SYM.TEXTC$,
             NUM_TICKS) ALTRET (BAD_NEWS);
          CALL XUD$UTS_ADJUST(TIME_BLOCK.UTS,0,NUM_TICKS*TICK_SIZE);
          TIME_BLOCK.RELATIVE = '1'B;
 
        END;                         /* END CASE                           */
/**/
     TIME_BLOCK.PRESENT = '1'B;
     RETURN;
/**/
BAD_NEWS: ;
     ALTRETURN;
%EJECT;
/**/
/*  Insert two digits, right justified.  */
/**/
STUFF2: PROC(CHAR2,IDX);
DCL CHAR2 CHAR(2);
DCL IDX SBIN;
DCL LEN SBIN;
     CHAR2 = '00';
     LEN = NODE$ -> OUT$BLK.SUBLK$(IDX) -> OUT$SYM.COUNT;
     CALL INSERT(CHAR2,2-LEN,LEN,NODE$ -> OUT$BLK.SUBLK$(IDX) -> OUT$SYM.TEXT);
     RETURN;
     END STUFF2;
/**/
     END CONVERT_TIME_NODE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
MAKE_NOW_UTS: PROC;
/**/
/*  This routine gets the current time in UTS and puts it where anybody       */
/*  can see it.                                                               */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE XUD_UTS_M;
%INCLUDE *GIMME_DATA_R;
/**/
/*  LOCAL CONSTANT  */
DCL UTS_DIFF UBIN;
/**/
%FPT_TIME (FPTN = FPT_MAKE_NOW,
           DEST = UTS,
           TSTAMP = NOW_UTS,
           SOURCE = CLOCK,
           STCLASS = CONSTANT);
%EJECT;
     CALL M$TIME (FPT_MAKE_NOW);
/**/
/*  Make current time rounded to lowest minute.                               */
/**/
      CALL XUD$UTS_DIFF_25TH(UTS_DIFF,NOW_UTS,0);
      UTS_DIFF = UTS_DIFF/%UTS_25TH_MIN#;
      CALL XUD$UTS_ADJ_25TH(NOW_UTS,0,UTS_DIFF*%UTS_25TH_MIN#);
/**/
/*  Make upper and lower boundaries of today.                                 */
/**/
      CALL XUD$UTS_DIFF_25TH(UTS_DIFF,NOW_UTS,0);
      UTS_DIFF=UTS_DIFF/%UTS_25TH_DAY#;
      CALL XUD$UTS_ADJ_25TH(TODAY_START_UTS,0,UTS_DIFF*%UTS_25TH_DAY#);
      CALL XUD$UTS_ADJUST(TODAY_END_UTS,TODAY_START_UTS,
           %UTS_CSEC_DAY#-1);
/**/
     RETURN;
/**/
     END MAKE_NOW_UTS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
UTS_TO_STRING: PROC (UTS,TEXTC) ALTRET;
/**/
/*  This routine takes a UTS and makes a TEXTC string out of it.              */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
DCL UTS SBIN WORD;
DCL 1 TEXTC CALIGNED,
      2 C UBIN(9) CALIGNED,
      2 TEXT CHAR(TEXTC.C) CALIGNED;
/**/
/*  LOCAL STATIC  */
/**/
%FPT_TIME (FPTN = FPT_TIME,
           DATE = DATE_BUF,
           TIME = TIME_BUF,
           SOURCE = UTS,
           DEST = LOCAL,
           STCLASS = STATIC);
DCL DATE_BUF CHAR(8) STATIC;
DCL TIME_BUF CHAR(11) STATIC;
/**/
/*  LOCAL AUTO  */
/**/
DCL I SBIN WORD;
%EJECT;
     FPT_TIME.TSTAMP_ = VECTOR(UTS);
     CALL M$TIME (FPT_TIME);
/**/
     TEXTC.C = 5;
     TEXTC.TEXT = SUBSTR(TIME_BUF,0,5);
     I = TEXTC.C;
     TEXTC.C = TEXTC.C +1 + SIZEC(DATE_BUF); /* Gotta grow size first    */
     CALL INSERT (TEXTC.TEXT,I,,',',DATE_BUF);
/**/
     RETURN;
/**/
     END UTS_TO_STRING;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
MAKE_RANGE_STRING: PROC (UTS1,UTS2,TEXTC) ALTRET;
/**/
/*  This routine takes two UTS values and makes a TEXTC string out of the     */
/*  resulting range.                                                          */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS  */
/**/
DCL UTS1 SBIN WORD;
DCL UTS2 SBIN WORD;
DCL 1 TEXTC CALIGNED,
      2 C UBIN(9) CALIGNED,
      2 TEXT CHAR(TEXTC.C) CALIGNED;
/**/
/*  LOCAL AUTO  */
/**/
%VLP_NAME (FPTN=STRING1, LEN=31, STCLASS=" ");
%VLP_NAME (FPTN=STRING2, LEN=31, STCLASS=" ");
/**/
/*  ENTRY DCLS  */
/**/
DCL UTS_TO_STRING ENTRY(2) ALTRET;
%EJECT;
     CALL UTS_TO_STRING (UTS1,STRING1);
     CALL UTS_TO_STRING (UTS2,STRING2);
/**/
     TEXTC.C = STRING1.L# + 3 + STRING2.L#;
     CALL CONCAT(TEXTC.TEXT,
          SUBSTR(STRING1.NAME#,0,STRING1.L#),' - ',
          SUBSTR(STRING2.NAME#,0,STRING2.L#));
/**/
     RETURN;
/**/
     END MAKE_RANGE_STRING;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
FETCH_EXIST: PROC(RES_TEXT,RES_C) ALTRET;
/**/
/*  This routine fetches the existance record for a resource name.            */
/*  If no such record exists, a message is printed and we ALTRET.             */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ARGUMENTS  */
/**/
DCL RES_C UBIN(9) CALIGNED;
DCL RES_TEXT CHAR(31) CALIGNED;
/**/
/*  AUTO  */
/**/
DCL 1 TEXTC,
      2 C UBIN BYTE CALIGNED,
      2 TEXT CHAR(31) CALIGNED;
%EJECT;
     SHEET_KEY.REST.RES.C = RES_C;
     SHEET_KEY.REST.RES.TEXT = RES_TEXT;
     SHEET_KEY.REST.UTS = 0;            /* EXIST RECORD                       */
     FPT_READ_SHEET.V.KEYS# = %YES#;
     CALL M$READ (FPT_READ_SHEET) ALTRET (NO_RESOURCE);
     DO WHILE ('0'B);
NO_RESOURCE: ;
        ERROR_CODE.ERR# = %DEG$DEADEND_RES#;
/*E* ERROR: DEG-DEG$DEADEND_RES#-2
   MESSAGE: The resource %U1 is not defined.
*/
        TEXTC.C = RES_C;
        TEXTC.TEXT = RES_TEXT;
        CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(TEXTC));
        ALTRETURN;
        END;
/**/
ALL_OK: ;
     RETURN;
/**/
     END FETCH_EXIST;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CHECK_RANGE: PROC ALTRET;
/**/
/*  This routine makes sure that the proposed resource and time slot          */
/*  are OK.  If not, it will ALTRET after printing a suitable message.        */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ENTRY DCLS  */
/**/
DCL UTS_TO_STRING ENTRY(2) ALTRET;
DCL CHECK_RESOURCE ENTRY(2) ALTRET;
DCL ADVANCE_A_DAY ENTRY (1);
/**/
/*  LOCAL AUTO  */
/**/
%VLP_NAME (FPTN = TEXTC_1, LEN=31, STCLASS = " ");
%VLP_NAME (FPTN = TEXTC_2, LEN=31, STCLASS = " ");
/**/
/*  LOCAL STATIC */
/**/
DCL START_UTS UBIN WORD STATIC;
DCL END_UTS UBIN WORD STATIC;
%FPT_TIME (FPTN = FPT_TIME,
           TSTAMP = START_UTS,
           DATE = START_DATE_BUFF,
           TIME = START_TIME_BUFF,
           STCLASS = STATIC);
 
DCL 1 START_DATE_BUFF STATIC,
      2 M CHAR(2),
      2 * CHAR(1),
      2 D CHAR(2),
      2 * CHAR(1),
      2 Y CHAR(2);
DCL START_DATE_STR REDEF START_DATE_BUFF CHAR(8);
DCL 1 START_TIME_BUFF STATIC,
      2 H CHAR(2),
      2 * CHAR(1),
      2 M CHAR(2),
      2 * CHAR(1),
      2 S CHAR(2),
      2 * CHAR(1),
      2 X CHAR(2);
DCL START_TIME_STR REDEF START_TIME_BUFF CHAR(11);
DCL 1 END_DATE_BUFF STATIC,
      2 M CHAR(2),
      2 * CHAR(1),
      2 D CHAR(2),
      2 * CHAR(1),
      2 Y CHAR(2);
DCL END_DATE_STR REDEF END_DATE_BUFF CHAR(8);
DCL 1 END_TIME_BUFF STATIC,
      2 H CHAR(2),
      2 * CHAR(1),
      2 M CHAR(2),
      2 * CHAR(1),
      2 S CHAR(2),
      2 * CHAR(1),
      2 X CHAR(2);
DCL END_TIME_STR REDEF END_TIME_BUFF CHAR(11);
/**/
%EJECT;
/**/
/*  Insure that the specified resource does exist.                            */
/**/
     CALL CHECK_RESOURCE(1,0) ALTRET(BAILOUT);
/**/
/*  Make sure that the time range starts before it's over!                    */
/**/
     IF OPT.START_TIME.UTS > OPT.END_TIME.UTS
      THEN
        DO;
        ERROR_CODE.ERR# = %DEG$TIMEWARP_SPAN#;
/*E* ERROR: DEG-DEG$TIMEWARP_SPAN#-2
   MESSAGE: Sorry, that span of time is over before it starts!
*/
        GOTO ERR_BAILOUT;
        END;
/**/
/*  Make sure that the time range hasn't already passed!                      */
/**/
     IF OPT.END_TIME.UTS < NOW_UTS
      THEN
        DO;
        ERROR_CODE.ERR# = %DEG$PASSED_SPAN#;
/*E* ERROR: DEG-DEG$PASSED_SPAN#-2
   MESSAGE: Sorry, that span of time is already over!
*/
        GOTO ERR_BAILOUT;
        END;
%EJECT;
/**/
/*  Check the requested period of time day by day                 */
/**/
     FPT_TIME.V.SOURCE# = %UTS#;
     FPT_TIME.V.DEST# = %LOCAL#;
     START_UTS = OPT.START_TIME.UTS;
     CALL M$TIME (FPT_TIME);   /* Convert start time */
     FPT_TIME.DATE_.DATE$ = ADDR(END_DATE_BUFF);
     FPT_TIME.TIME_.TIME$ = ADDR(END_TIME_BUFF);
     FPT_TIME.TSTAMP_ = VECTOR(END_UTS);
     END_UTS = OPT.END_TIME.UTS;
     CALL M$TIME (FPT_TIME);  /* Convert end time */
 
     DO WHILE (START_UTS < OPT.END_TIME.UTS);
 
       IF START_DATE_STR = END_DATE_STR
         THEN
           END_UTS = OPT.END_TIME.UTS;
       ELSE
         DO;
           FPT_TIME.DATE_.DATE$ = ADDR(START_DATE_BUFF);
           FPT_TIME.TIME_.TIME$ = ADDR(START_TIME_BUFF);
           SUBSTR(START_TIME_STR,0,5) = RES_AVAIL_TIME.END_;
           FPT_TIME.TSTAMP_ = VECTOR(END_UTS);
           FPT_TIME.V.SOURCE# = %LOCAL#;
           FPT_TIME.V.DEST# = %UTS#;
           CALL M$TIME (FPT_TIME);
           END;     /* set end_time to end of day associated with the res    */
/**/
/*  Check if this range of time is available                                 */
/**/
       CALL CHECK_A_RANGE (START_UTS,END_UTS) ALTRET (BAILOUT);
/**/
/* Set start_time to start of the next day.                              */
/**/
       CALL ADVANCE_A_DAY(START_DATE_BUFF);
       SUBSTR(START_TIME_STR,0,5) = RES_AVAIL_TIME.START_;
       FPT_TIME.V.SOURCE# = %LOCAL#;
       FPT_TIME.V.DEST# = %UTS#;
       FPT_TIME.DATE_.DATE$ = ADDR(START_DATE_BUFF);
       FPT_TIME.TIME_.TIME$ = ADDR(START_TIME_BUFF);
       FPT_TIME.TSTAMP_ = VECTOR(START_UTS);
       CALL M$TIME (FPT_TIME);
       END;   /* do while the monitored time span is not over    */
/**/
/*  This slot is available!                                                   */
/**/
     RETURN;
/**/
ERR_BAILOUT: ;
     CALL XUR$ERRMSG (ERROR_CODE);
BAILOUT: ;
     ALTRETURN;
/**/
CHECK_A_RANGE: PROC (START_UTS, END_UTS) ALTRET;
/**/
/*  This routine make sure that the specified time period does not conflict   */
/*  with the next user of this resource.                                      */
/**/
/*  PARAMETERS   */
/**/
DCL START_UTS UBIN WORD;
DCL END_UTS UBIN WORD;
/**/
     SHEET_KEY.REST.RES.C = OPT.RESOURCE.RES.C;
     SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT;
     SHEET_KEY.REST.UTS = START_UTS;
     FPT_READ_SHEET.V.KEYS# = %YES#;
     CALL M$READ (FPT_READ_SHEET) ALTRET (OK_1);
     GOTO RES_BUSY;
OK_1: ;                                 /* Not an exact hit                   */
     FPT_READ_SHEET.V.KEYS# = %NO#;
     CALL M$READ (FPT_READ_SHEET);
/*  Check for other endpoints within our span                                 */
     IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT
        AND SHEET_RECORD.TYPE = %RT_SIGN#
        AND SHEET_RECORD.SIGN.START_TIME.UTS > START_UTS
        AND SHEET_RECORD.SIGN.START_TIME.UTS < END_UTS
        THEN
           GOTO RES_BUSY;
     IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT
        AND SHEET_RECORD.TYPE = %RT_SIGN#
        AND SHEET_RECORD.SIGN.END_TIME.UTS > START_UTS
        AND SHEET_RECORD.SIGN.END_TIME.UTS < END_UTS
        THEN
           GOTO RES_BUSY;
%EJECT;
/**/
/*  Make sure that we are not conflicting with any previous cliam.            */
/**/
     CALL M$PRECORD (FPT_PRECORD_SHEET) ALTRET(OK3);
OK3: ;
     CALL M$READ (FPT_READ_SHEET);
/*  Check for other endpoints within our span                                 */
     IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT
        AND SHEET_RECORD.TYPE = %RT_SIGN#
        AND SHEET_RECORD.SIGN.START_TIME.UTS > START_UTS
        AND SHEET_RECORD.SIGN.START_TIME.UTS < END_UTS
        THEN
           GOTO RES_BUSY;
     IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT
        AND SHEET_RECORD.TYPE = %RT_SIGN#
        AND SHEET_RECORD.SIGN.END_TIME.UTS > START_UTS
        AND SHEET_RECORD.SIGN.END_TIME.UTS < END_UTS
        THEN
           GOTO RES_BUSY;
/*  Check for prior span completely enclosing our proposal.                   */
     IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT
        AND SHEET_RECORD.TYPE = %RT_SIGN#
        AND SHEET_RECORD.SIGN.START_TIME.UTS <= START_UTS
        AND SHEET_RECORD.SIGN.END_TIME.UTS >= END_UTS
        THEN
           GOTO RES_BUSY;
/**/
/*  This slot is available   */
/**/
     RETURN;
/**/
RES_BUSY: ;
     CALL UTS_TO_STRING (SHEET_RECORD.SIGN.START_TIME.UTS,TEXTC_1);
     CALL UTS_TO_STRING (SHEET_RECORD.SIGN.END_TIME.UTS,TEXTC_2);
     ERROR_CODE.ERR# = %DEG$RES_BUSY#;
/*E* ERROR: DEG-DEG$RES_BUSY#-2
   MESSAGE: Sorry, %U3 is busy from %U1 to %U2.
*/
     CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(TEXTC_1),
          VECTOR(TEXTC_2),VECTOR(OPT.RESOURCE.RES));
/**/
     ALTRETURN;
/**/
     END CHECK_A_RANGE;
/**/
     END CHECK_RANGE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CHECK_RESOURCE: PROC(MAP_ALIAS,WCARD_ALLOWED) ALTRET;
/**/
/*  This routine makes sure that the proposed resource really exists.         */
/*                                                                            */
/*  If MAP_ALIAS = 1, resource names that are really aliases are              */
/*  replaced by the resource name that they represent.                        */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ARGUMENTS  */
/**/
DCL MAP_ALIAS SBIN WORD;
DCL WCARD_ALLOWED SBIN WORD;
/**/
/*  ENTRIES  */
/**/
DCL CHECK_RES_NAME ENTRY(1) ALTRET;
%EJECT;
     IF OPT.RESOURCE.CHASED
      THEN                              /* We've been here before!            */
        GOTO ALL_OK;
     OPT.RESOURCE.CHASED = %YES#;
     CALL CHECK_RES_NAME (WCARD_ALLOWED) ALTRET(BAILOUT);
     IF OPT.RESOURCE.WCARDED
      THEN
        GOTO ALL_OK;
CHECK_RESOURCE: ;
     SHEET_KEY.REST.RES.C = OPT.RESOURCE.RES.C;
     SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT;
     SHEET_KEY.REST.UTS = 0;            /* EXIST RECORD                       */
     FPT_READ_SHEET.V.KEYS# = %YES#;
     CALL M$READ (FPT_READ_SHEET) ALTRET (NO_RESOURCE);
     IF MAP_ALIAS = 1
      AND SHEET_RECORD.TYPE = %RT_ALIAS#
      THEN
        DO;
          OPT.RESOURCE.RES = SHEET_RECORD.ALIAS.RES;
          GOTO CHECK_RESOURCE;
          END;
     IF SHEET_RECORD.TYPE = %RT_RES#
       THEN
         DO;
           IF B$JIT$ -> B$JIT.PRIV.ACTIVE & %PR_FMSEC#
             THEN
               GOTO ITS_OK;
           IF SHEET_RECORD.RES.SITE.TEXT ~= CURR_SITE.SITE_NAME#.C
             THEN
               DO;
                 ERROR_CODE.ERR# = %DEG$CANT_GET_RESOURCE#;
/*E* ERROR: DEG-DEG$CANT_GET_RESOURCE#-2
   MESSAGE: Can't access %U1 from this site.
*/
                 CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(OPT.RESOURCE.RES));
                 ALTRETURN;
                 END;  /* site names don't match */
             ELSE
               DO;
ITS_OK:          RES_AVAIL_TIME.START_ = SHEET_RECORD.RES.AVAIL_TIME.START_;
                 RES_AVAIL_TIME.END_ = SHEET_RECORD.RES.AVAIL_TIME.END_;
                 END;  /* site names match */
           END;     /* RT_RES type sheet record */
 
     DO WHILE ('0'B);
NO_RESOURCE: ;
        ERROR_CODE.ERR# = %DEG$NO_RESOURCE#;
/*E* ERROR: DEG-DEG$NO_RESOURCE#-2
   MESSAGE: There is no such resource as %U1.
*/
        CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(OPT.RESOURCE.RES));
        ALTRETURN;
        END;
/**/
ALL_OK: ;
     RETURN;
/**/
BAILOUT: ;
     ALTRETURN;
/**/
     END CHECK_RESOURCE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CHECK_RES_NAME: PROC(WILDCARD_OK) ALTRET;
/**/
/*  This routine makes sure that the proposed resource name is LEGAL.         */
/*  No attempt is made to check the EXISTANCE of the name.                    */
/*                                                                            */
/*  If WILDCARD_OK = 1, the resource name may contain wildcarding             */
/*  operators.                                                                */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ARGUMENTS  */
/**/
DCL WILDCARD_OK SBIN WORD;
/**/
/*  LOCAL AUTO  */
/**/
DCL IDX SBIN WORD;
%EJECT;
     CALL INDEX(IDX,'?',OPT.RESOURCE.RES.TEXT);
     IF IDX < LENGTHC(OPT.RESOURCE.RES.TEXT)
      THEN
        OPT.RESOURCE.WCARDED = %YES#;
     ELSE
        OPT.RESOURCE.WCARDED = %NO#;
     IF WILDCARD_OK = 0 AND OPT.RESOURCE.WCARDED
      THEN
        DO;
          ERROR_CODE.ERR# = %DEG$CANT_WILD_RES#;
/*E* ERROR: DEG-DEG$CANT_WILD_RES#-2
   MESSAGE: Wildcarding of resources is not legal here.
*/
          CALL XUR$ERRMSG (ERROR_CODE);
          ALTRETURN;
          END;
/**/
     RETURN;
/**/
     END CHECK_RES_NAME;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CHECK_OWNERSHIP: PROC ALTRET;
/**/
/*  This routine makes sure that the user owns the specified instance         */
/*  of the resource.                                                          */
/*                                                                            */
/*  If the test turns out OK, we will return with SHEET_KEY and SHEET_RECORD  */
/*  containing the specified instance.                                        */
/*                                                                            */
/*  NOTE:  FMSEC priv turned on in the user's JIT will suffice if this        */
/*  user doesn't really own the specified instance.                           */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ENTRY DCLS  */
/**/
DCL CHECK_INSTANCE ENTRY ALTRET;
%EJECT;
     CALL CHECK_INSTANCE ALTRET(BAILOUT);
     IF B$JIT$ -> B$JIT.PRIV.ACTIVE & %PR_FMSEC#
      THEN                              /* The Lord works in mysterious ways  */
        GOTO ITS_OK;
     IF SHEET_RECORD.SIGN.USER_ID ~= USER_ID
      THEN
        DO;
          ERROR_CODE.ERR# = %DEG$NO_OWNERSHIP#;
/*E* ERROR: DEG-DEG$NO_OWNERSHIP#-2
   MESSAGE: Sorry, you don't own that instance of %U1.
*/
          CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(OPT.RESOURCE.RES));
          ALTRETURN;
          END;
/**/
ITS_OK: ;
     RETURN;
/**/
BAILOUT: ;
     ALTRETURN;
/**/
     END CHECK_OWNERSHIP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
CHECK_INSTANCE: PROC ALTRET;
/**/
/*  This routine makes sure that the proposed instance of the resource really */
/*  does exist.                                                               */
/*                                                                            */
/*  If the test turns out OK, we will return with SHEET_KEY and SHEET_RECORD  */
/*  containing the specified instance.                                        */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  ENTRIES  */
/**/
DCL CHECK_RESOURCE ENTRY(2) ALTRET;
%EJECT;
     CALL CHECK_RESOURCE(1,0) ALTRET(BAILOUT);
     SHEET_KEY.REST.RES.C = OPT.RESOURCE.RES.C;
     SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT;
     SHEET_KEY.REST.UTS = OPT.ID_TIME.UTS;
     FPT_READ_SHEET.V.KEYS# = %YES#;
     CALL M$READ (FPT_READ_SHEET) ALTRET (NO_INSTANCE);
     DO WHILE ('0'B);
NO_INSTANCE: ;
        ERROR_CODE.ERR# = %DEG$NO_INSTANCE#;
/*E* ERROR: DEG-DEG$NO_INSTANCE#-2
   MESSAGE: There is no such instance of %U1.
*/
        CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(OPT.RESOURCE.RES));
        ALTRETURN;
        END;
/**/
     RETURN;
/**/
BAILOUT: ;
     ALTRETURN;
/**/
     END CHECK_INSTANCE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
OPEN_SIGNUPS: PROC ALTRET;
/**/
/*  This routine OPENs the main signup-sheet file for GIMME.                  */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  If the previous file is around, get rid of it.                            */
/**/
     IF M$SIGN_SHEET$ -> F$DCB.FCD#
      THEN
        CALL M$CLOSE (FPT_CLOSE_SHEET);
/**/
/*  OPEN the file in an attempt to create it.  Most of the time               */
/*  this will fail since the file already exists.  If we do succeed in        */
/*  the creation, we initialize the file and close it.                        */
/**/
     FPT_OPEN_SHEET.V.FUN# = %CREATE#;
     FPT_OPEN_SHEET.V.EXIST# = %ERROR#;
     CALL M$OPEN (FPT_OPEN_SHEET) ALTRET (CREATION_DONE);
%EJECT;
/**/
/*  File really IS in need of creation.                                       */
/**/
     ERROR_CODE.ERR# = %DEG$TELL_CREATING#;
/*E* ERROR: DEG-DEG$TELL_CREATING#-2
   MESSAGE: (Creating %UF)
*/
     CALL XUR$ERRMSG (ERROR_CODE,M$SIGN_SHEET#);
/**/
/*  Make a special flag record at the end of the file.                        */
/**/
     SHEET_KEY.REST = '777777777777'O;
     SHEET_KEY.REST.RES = '777777777'O;
     SHEET_KEY.REST.UTS = BITBIN('777777777777'O); /* Just something large    */
     SHEET_RECORD = '0'B;
     SHEET_RECORD.TYPE = %RT_END#;
     CALL M$WRITE (FPT_WRITE_SHEET) ALTRET(BAD_NEWS);
/**/
     CALL M$CLOSE (FPT_CLOSE_SHEET) ALTRET(BAD_NEWS);
CREATION_DONE: ;
%EJECT;
/**/
/*  We know that a file exists.  Let's OPEN it for later use.                 */
/**/
     FPT_OPEN_SHEET.V.FUN# = %UPDATE#;
     FPT_OPEN_SHEET.V.EXIST# = %OLDFILE#;
     CALL M$OPEN (FPT_OPEN_SHEET) ALTRET(BAD_NEWS);
/**/
/*  Initialization completed OK.                                              */
/**/
     RETURN;
/**/
BAD_NEWS: ;
     ERROR_CODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
     IF M$SIGN_SHEET$ -> F$DCB.FCD#
      THEN                              /* We got it open                     */
        CALL M$CLOSE (FPT_CLOSE_SHEET);
     CALL XUR$ERRMSG (ERROR_CODE,
                      M$SIGN_SHEET#);
     ALTRETURN;
/**/
     END OPEN_SIGNUPS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
ENQ_SHEET: PROC ALTRET;
/**/
/*  This routine is to be used before changing the file of signup sheets      */
/*  or before extensive tests before changes.  It makes sure that             */
/*  simultanious users don't step on each other.                              */
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
     CALL M$ENQ (FPT_ENQ_SHEET) ALTRET(BAD_NEWS);
     GOT_RESOURCE = '1'B;
     RETURN;
/**/
DEQ_SHEET: ENTRY ALTRET;
/**/
/*  This routine is to be used whenever the file has been updated and         */
/*  we wish to release any special hold we have over the file.  It is OK      */
/*  to call this routine a few extra times since it remembers whether         */
/*  or not it has ENQ'ed on the file.                                         */
/**/
     IF GOT_RESOURCE
      THEN
        DO;
          GOT_RESOURCE = '0'B;
          CALL M$DEQ (FPT_DEQ_SHEET) ALTRET (BAD_NEWS);
          END;
     RETURN;
%EJECT;
BAD_NEWS: ;
     ERROR_CODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
     CALL XUR$ERRMSG (ERROR_CODE,
                      M$SIGN_SHEET#);
     ALTRETURN;
/**/
     END ENQ_SHEET;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
SIGNUP_EVENT: PROC (STASH_RECORD,STASH_KEY) ALTRET;
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS   */
/**/
%SHEET_RECORD (NAME = STASH_RECORD,STCLASS= " ");
%SHEET_KEY (NAME = STASH_KEY,STCLASS = " ");
/**/
DCL ADVANCE_A_DAY ENTRY(1);
/**/
/*  LOCAL STATIC */
/**/
DCL UTS UBIN WORD STATIC;
DCL END_UTS UBIN WORD STATIC;
%FPT_TIME (FPTN = FPT_TIME,
           TSTAMP = UTS,
           DATE = START_DATE_BUFF,
           TIME = START_TIME_BUFF,
           STCLASS = STATIC);
 
DCL 1 START_DATE_BUFF STATIC,
      2 M CHAR(2),
      2 * CHAR(1),
      2 D CHAR(2),
      2 * CHAR(1),
      2 Y CHAR(2);
DCL START_DATE_STR REDEF START_DATE_BUFF CHAR(8);
DCL 1 START_TIME_BUFF STATIC,
      2 H CHAR(2),
      2 * CHAR(1),
      2 M CHAR(2),
      2 * CHAR(1),
      2 S CHAR(2),
      2 * CHAR(1),
      2 X CHAR(2);
DCL START_TIME_STR REDEF START_TIME_BUFF CHAR(11);
DCL 1 END_DATE_BUFF STATIC,
      2 M CHAR(2),
      2 * CHAR(1),
      2 D CHAR(2),
      2 * CHAR(1),
      2 Y CHAR(2);
DCL END_DATE_STR REDEF END_DATE_BUFF CHAR(8);
DCL 1 END_TIME_BUFF STATIC,
      2 H CHAR(2),
      2 * CHAR(1),
      2 M CHAR(2),
      2 * CHAR(1),
      2 S CHAR(2),
      2 * CHAR(1),
      2 X CHAR(2);
DCL END_TIME_STR REDEF END_TIME_BUFF CHAR(11);
/**/
/**/
     FPT_TIME.V.SOURCE# = %UTS#;
     FPT_TIME.V.DEST# = %LOCAL#;
     UTS = STASH_RECORD.SIGN.START_TIME.UTS;
     CALL M$TIME (FPT_TIME);   /* Convert start time */
     FPT_TIME.DATE_.DATE$ = ADDR(END_DATE_BUFF);
     FPT_TIME.TIME_.TIME$ = ADDR(END_TIME_BUFF);
     FPT_TIME.TSTAMP_ = VECTOR(END_UTS);
     END_UTS = STASH_RECORD.SIGN.REQ_END_TIME;
     CALL M$TIME (FPT_TIME);  /* Convert end time */
     FPT_TIME.TSTAMP_ = VECTOR(UTS);
     DO WHILE (UTS < END_UTS);
       SHEET_RECORD.SIGN.START_TIME = STASH_RECORD.SIGN.START_TIME;
       IF START_DATE_STR = END_DATE_STR
         THEN
           SHEET_RECORD.SIGN.END_TIME.UTS = STASH_RECORD.SIGN.REQ_END_TIME;
       ELSE
         DO;
           FPT_TIME.DATE_.DATE$ = ADDR(START_DATE_BUFF);
           FPT_TIME.TIME_.TIME$ = ADDR(START_TIME_BUFF);
 
           SUBSTR(START_TIME_STR,0,5) = RES_AVAIL_TIME.END_;
           FPT_TIME.V.SOURCE# = %LOCAL#;
           FPT_TIME.V.DEST# = %UTS#;
           CALL M$TIME (FPT_TIME);
 
           SHEET_RECORD.SIGN.END_TIME.UTS = UTS;
           END;     /* set end_time to end of day associated with the res    */
/**/
/* Set start_time to start of the next day.                              */
/**/
       CALL ADVANCE_A_DAY(START_DATE_BUFF);
       SUBSTR(START_TIME_STR,0,5) = RES_AVAIL_TIME.START_;
       FPT_TIME.V.SOURCE# = %LOCAL#;
       FPT_TIME.V.DEST# = %UTS#;
       FPT_TIME.DATE_.DATE$ = ADDR(START_DATE_BUFF);
       FPT_TIME.TIME_.TIME$ = ADDR(START_TIME_BUFF);
       CALL M$TIME (FPT_TIME);
       STASH_RECORD.SIGN.START_TIME.UTS = UTS;
/**/
       SHEET_RECORD.SIGN.ID_TIME = NOW_UTS;
       SHEET_RECORD.SIGN.REQ_END_TIME = STASH_RECORD.SIGN.REQ_END_TIME;
       SHEET_RECORD.SIGN.REASON = STASH_RECORD.SIGN.REASON;
       SHEET_RECORD.SIGN.USER_ID = USER_ID;
       SHEET_RECORD.SIGN.USER_NAME = NAME_RECORD.USER_NAME;
       SHEET_RECORD.TYPE = %RT_SIGN#;
/**/
       SHEET_KEY.REST.RES.C = STASH_KEY.REST.RES.C;
       SHEET_KEY.REST.RES.TEXT = STASH_KEY.REST.RES.TEXT;
       SHEET_KEY.REST.UTS = SHEET_RECORD.SIGN.START_TIME.UTS;
/**/
       CALL M$WRITE (FPT_WRITE_SHEET) ALTRET(BAD_WRITE);
/**/
       END;   /* DO WHILE start_time < end_time */
     RETURN;
/**/
BAD_WRITE: ;
     ERROR_CODE.ERR# = %DEG$CANT_WRITE_REC#;
/*E* ERROR: DEG-DEG$CANT_WRITE_REC#-2
   MESSAGE: Unable to write signup record.
*/
     CALL XUR$ERRMSG (ERROR_CODE);
     ALTRETURN;
/**/
     END SIGNUP_EVENT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
ADVANCE_A_DAY: PROC (START_DATE_BUFF);
/**/
/*  Advance the date as stored in START_DATE_BUFF by 1 day          */
/**/
/*  PARAMETERS   */
/**/
DCL 1 START_DATE_BUFF,
      2 M CHAR(2),
      2 * CHAR(1),
      2 D CHAR(2),
      2 * CHAR(1),
      2 Y CHAR(2);
/**/
/*  LOCAL STATIC  */
/**/
DCL DAYS_PER_MONTH (0:11) UBIN HALF STATIC
    INIT(31,28,31,30,31,30,31,31,30,31,30,31);
DCL Y UBIN WORD;
DCL M UBIN WORD;
DCL D UBIN WORD;
    CALL CHARBIN(Y,START_DATE_BUFF.Y);
    IF MOD(Y,4) = 0
      THEN
        DAYS_PER_MONTH(1) = 29;  /* leap year */
    ELSE
      DAYS_PER_MONTH(1) = 28;    /* Non-leap year */
    CALL CHARBIN(D,START_DATE_BUFF.D);
    D = D + 1;
    CALL CHARBIN(M,START_DATE_BUFF.M);
    IF D > DAYS_PER_MONTH (M-1)
      THEN
        DO;
          START_DATE_BUFF.D = '01';
          M = M + 1;
          IF M > 12
            THEN
              DO;
                START_DATE_BUFF.M = '01';
                Y = MOD ((Y+1),100); /* :AT Correct for Year 2000 */
                CALL BINCHAR(START_DATE_BUFF.Y,Y);
                END;  /* reaches end of year */
          ELSE
            CALL BINCHAR(START_DATE_BUFF.M,M);
          END;       /* reaches end of month */
    ELSE
      CALL BINCHAR(START_DATE_BUFF.D,D);
/**/
    RETURN;
/**/
    END ADVANCE_A_DAY;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
DELETE_EVENT: PROC (STASH_RECORD) ALTRET;
/**/
/*  INCLUDE FILES  */
/**/
%INCLUDE *GIMME_DATA_R;
/**/
/*  PARAMETERS */
/**/
%SHEET_RECORD (NAME=STASH_RECORD,STCLASS=" ");
/**/
/*  Delete the record already set up by the calling procedure  */
/**/
     CALL M$DELREC (FPT_DELREC_SHEET) ALTRET (BAD_DELETE);
/**/
/*  Delete other records, if any, related to this event        */
/**/
     FPT_READ_SHEET.V.KEYS# = %NO#;
     DO WHILE (SHEET_RECORD.SIGN.END_TIME.UTS ~= STASH_RECORD.SIGN.REQ_END_TIME AND
               SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT);
/**/
        DO UNTIL ((SHEET_RECORD.SIGN.ID_TIME = STASH_RECORD.SIGN.ID_TIME AND
                  SHEET_RECORD.SIGN.USER_ID = STASH_RECORD.SIGN.USER_ID) OR
                  (SHEET_KEY.REST.RES.TEXT ~= OPT.RESOURCE.RES.TEXT));
          CALL M$READ (FPT_READ_SHEET);
        END;  /* do until the wanted record is read */
/**/
        IF SHEET_KEY.REST.RES.TEXT = OPT.RESOURCE.RES.TEXT THEN
          CALL M$DELREC (FPT_DELREC_SHEET) ALTRET (BAD_DELETE);
     END;     /* do until the last record has been deleted  */
/**/
     RETURN;
/**/
BAD_DELETE: ;
     ERROR_CODE.ERR# = %DEG$CANT_DELETE_REC#;
/*E* ERROR: DEG-DEG$CANT_DELETE_REC#-2
   MESSAGE: Unable to delete signup record.
*/
     CALL XUR$ERRMSG (ERROR_CODE);
     ALTRETURN;
 
     END DELETE_EVENT;
