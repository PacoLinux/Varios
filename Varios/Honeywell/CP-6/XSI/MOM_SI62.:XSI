/*M* MOM_SI62 - Contains data-gathering routines for MOM. */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_SITE:   PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
        2 * EPTR,
        2 * PTR,
        2 * BIT(72) ALIGNED,
        2 * BIT(72) ALIGNED,
        2 PTR$ PTR;
  DCL 1 FL_SITE BASED,
        2 HILITE BIT(1),
        2 HIATT UBIN(35) UNAL,
        2 * UBIN,
        2 * CHAR(16),
        2 V,
           3 L# UBIN(9) UNAL,
           3 C# CHAR(27);
  DCL SITE# CHAR(27);
  DCL SAVE# CHAR(27);
  DCL IND# UBIN;
  DCL IND1# SBIN;
%CP6$ENTS;
%FPT_MONINFO(SITEINFO=VLR_SITEINFO);
%VLR_SITEINFO;
/*
        Procedure
*/
        CALL M$MONINFO(FPT_MONINFO);
        SITE# = VLR_SITEINFO.SITE_NAME#.C;
        IF SITE# = ' ' THEN
           SITE# = '** C00 **';
LP:     DO IND1# = 26 DOWNTO 0;
           IF SUBSTR(SITE#,IND1#,1) ~= ' ' THEN DO;
              IND# = IND1# + 1;
              EXIT LP;
              END;
           END;
        IF IND# < 24 THEN DO;
           SUBSTR(SITE#,IND#+1,3) = VLR_SITEINFO.VERSION#;
           IND# = IND# + 4;
           END;
        IND1# = (27 - IND#) / 2;
        SAVE# = SITE#;
        SITE# = ' ';
        SUBSTR(SITE#,IND1#,IND#) = SUBSTR(SAVE#,0,IND#);
        RBASED.PTR$->FL_SITE.V.C# = SITE#;
        RETURN;
END DG_SITE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_RBATCH: PROC(PTR$);
  DCL PTR$ PTR;
  DCL PT3$ PTR;
  DCL JOB# UBIN;
  DCL IND# UBIN;
  DCL 1 ROUT BASED,
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) WALIGNED,
         2 * BIT(72) WALIGNED,
         2 FLD$ (0:43) PTR;
  DCL 1 FLD1 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN(18) HALIGNED,
         2 * UBIN(18) HALIGNED,
         2 * CHAR(16),
         2 CVAL,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(8);
  DCL 1 FLD2 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN(18) HALIGNED,
         2 * UBIN(18) HALIGNED,
         2 * CHAR(16),
         2 CVAL,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(2);
  DCL 1 FLD3 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN(18) HALIGNED,
         2 * UBIN(18) HALIGNED,
         2 * CHAR(16),
         2 CVAL,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(1);
  DCL 1 FLD4 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN(18) HALIGNED,
         2 * UBIN(18) HALIGNED,
         2 * CHAR(16),
         2 CVAL,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(5);
  DCL EDIT2 (0:1) BIT(9) CONSTANT INIT('101'O,'321'O);
  DCL EDIT5 (0:1) BIT(9) CONSTANT INIT('104'O,'321'O);
%CP6$ENTS;
%FPT_JOBSTATS(FPTN=CHK_RUNNING,
        CRITERIA=VLP_CRITERIA,
        ORDER=SRCH,
        RESULTS=RESULTS);
%VLP_CRITERIA(RUNNING=YES);
%VLR_JOBSTATS_ISRCH(FPTN=RESULTS,
        NJOB=11);
%VLA_JOBSTATS_ISRCH(FPTN=ELEMENT,
        STCLASS="BASED(PT3$)");
/*
        Procedure
*/
        JOB# = 0;
        RESULTS.FOUND = 0;
        CALL M$JOBSTATS(CHK_RUNNING) ALTRET(NONE);
NONE:   DO IND# = 0 TO 43;
           IF JOB# < RESULTS.FOUND THEN DO;
              PT3$ = ADDR(RESULTS.J(JOB#));
              DO CASE(MOD(IND#,4));
                 CASE(0);
                    PTR$->ROUT.FLD$(IND#)->FLD1.CVAL.C# = ELEMENT.ACCT;
                 CASE(1);
                    CALL BINCHAR(PTR$->ROUT.FLD$(IND#)->FLD2.CVAL.C#,ELEMENT.PNUM);
                    CALL EDITCHAR(PTR$->ROUT.FLD$(IND#)->FLD2.CVAL.C#,,,EDIT2,PTR$->ROUT.FLD$(IND#)->FLD2.CVAL.C#);
                 CASE(2);
                    CALL BINCHAR(PTR$->ROUT.FLD$(IND#)->FLD3.CVAL.C#,ELEMENT.RRT(2));
                 CASE(3);
                    CALL BINCHAR(PTR$->ROUT.FLD$(IND#)->FLD4.CVAL.C#,ELEMENT.SYSID);
                    CALL EDITCHAR(PTR$->ROUT.FLD$(IND#)->FLD4.CVAL.C#,,,EDIT5,PTR$->ROUT.FLD$(IND#)->FLD4.CVAL.C#);
                    JOB# = JOB# + 1;
                 END;
              END;
           ELSE DO;
              DO CASE(MOD(IND#,4));
                 CASE(0);
                    PTR$->ROUT.FLD$(IND#)->FLD1.CVAL.C# = ' ';
                 CASE(1);
                    PTR$->ROUT.FLD$(IND#)->FLD2.CVAL.C# = ' ';
                 CASE(2);
                    PTR$->ROUT.FLD$(IND#)->FLD3.CVAL.C# = ' ';
                 CASE(3);
                    PTR$->ROUT.FLD$(IND#)->FLD4.CVAL.C# = ' ';
                 END;
              END;
           END;
        RETURN;
END DG_RBATCH;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_TIME: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL DATE CHAR(8) STATIC INIT(' ');
  DCL TIME CHAR(11) STATIC INIT(' ');
  DCL DT CHAR(15);
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 DATE$ PTR;
  DCL 1 FL_DATE BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(15);
%CP6$ENTS;
%FPT_TIME(DATE=DATE,
        DEST=LOCAL,
        SOURCE=CLOCK,
        TIME=TIME);
/*
        Procedure
*/
        CALL M$TIME(FPT_TIME);
        CALL CONCAT(DT,DATE,'  ',SUBSTR(TIME,0,5));
        RBASED.DATE$->FL_DATE.V.C# = DT;
        RETURN;
END DG_TIME;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_ETMF: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 ETMF$ PTR,
         2 RESP$ PTR;
  DCL 1 FL_ETMF BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(2);
  DCL 1 FL_RESP BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(4);
  DCL EDIT4 (0:1) BIT(9) CONSTANT INIT('103'O,'321'O);
  DCL EDIT2 (0:1) BIT(9) CONSTANT INIT('101'O,'321'O);
%CP6$ENTS;
%FPT_DISPLAY(RESULTS=VLR_DISPLAY);
%VLR_DISPLAY;
/*
        Procedure
*/
        CALL M$DISPLAY(FPT_DISPLAY);
        CALL BINCHAR(RBASED.ETMF$->FL_ETMF.V.C#,VLR_DISPLAY.ETMF);
        CALL EDITCHAR(RBASED.ETMF$->FL_ETMF.V.C#,,,EDIT2,RBASED.ETMF$->FL_ETMF.V.C#);
        CALL BINCHAR(RBASED.RESP$->FL_RESP.V.C#,VLR_DISPLAY.RESP);
        CALL EDITCHAR(RBASED.RESP$->FL_RESP.V.C#,,,EDIT4,RBASED.RESP$->FL_RESP.V.C#);
        IF VLR_DISPLAY.RESP > 500 THEN DO;
           RBASED.RESP$->FL_RESP.HILITE = '1'B;
           RBASED.RESP$->FL_RESP.HIATT = 4;
           END;
        ELSE IF VLR_DISPLAY.RESP > 250 THEN DO;
              RBASED.RESP$->FL_RESP.HILITE = '1'B;
              RBASED.RESP$->FL_RESP.HIATT = 2;
              END;
           ELSE IF VLR_DISPLAY.RESP > 100 THEN DO;
                 RBASED.RESP$->FL_RESP.HILITE = '1'B;
                 RBASED.RESP$->FL_RESP.HIATT = 1;
                 END;
              ELSE
                 RBASED.RESP$->FL_RESP.HILITE = '0'B;
        IF VLR_DISPLAY.ETMF > 15 THEN DO;
           RBASED.ETMF$->FL_ETMF.HILITE = '1'B;
           RBASED.ETMF$->FL_ETMF.HIATT = 4;
           END;
        ELSE IF VLR_DISPLAY.ETMF > 10 THEN DO;
              RBASED.ETMF$->FL_ETMF.HILITE = '1'B;
              RBASED.ETMF$->FL_ETMF.HIATT = 2;
              END;
           ELSE IF VLR_DISPLAY.ETMF > 5 THEN DO;
                 RBASED.ETMF$->FL_ETMF.HILITE = '1'B;
                 RBASED.ETMF$->FL_ETMF.HIATT = 1;
                 END;
              ELSE
                 RBASED.ETMF$->FL_ETMF.HILITE = '0'B;
        RETURN;
END DG_ETMF;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_LASTREC: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 LASTREC$ PTR;
  DCL 1 FL_LASTREC BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(12);
  DCL DATE CHAR(10) STATIC INIT(' ');
  DCL TIME CHAR(11) STATIC INIT(' ');
  DCL DT CHAR(12);
%CP6$ENTS;
%FPT_MONINFO(MONINFO=VLR_MONINFO);
%VLR_MONINFO;
%FPT_TIME(DATE=DATE,
        TIME=TIME,
        TSTAMP=VLR_MONINFO.INIT_UTS#,
        DEST=EXT,
        SOURCE=UTS);
/*
        Procedure
*/
        CALL M$MONINFO(FPT_MONINFO);
        CALL M$TIME(FPT_TIME);
        CALL INSERT(DT,0,12,SUBSTR(TIME,0,5),'  ',SUBSTR(DATE,0,3),SUBSTR(DATE,4,2));
        RBASED.LASTREC$->FL_LASTREC.V.C# = DT;
        RETURN;
END DG_LASTREC;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_FREEPGS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 FREEPGS$ PTR;
  DCL 1 FL_FREEPGS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(5);
  DCL EDIT5 (0:1) BIT(9) CONSTANT INIT('104'O,'321'O);
%CP6$ENTS;
%FPT_MONINFO(MONINFO=VLR_MONINFO);
%VLR_MONINFO;
/*
        Procedure
*/
        CALL M$MONINFO(FPT_MONINFO);
        CALL BINCHAR(RBASED.FREEPGS$->FL_FREEPGS.V.C#,VLR_MONINFO.ACORE#);
        CALL EDITCHAR(RBASED.FREEPGS$->FL_FREEPGS.V.C#,,,EDIT5,RBASED.FREEPGS$->FL_FREEPGS.V.C#);
        IF VLR_MONINFO.ACORE# < 1000 THEN
           RBASED.FREEPGS$->FL_FREEPGS.HILITE = '1'B;
        ELSE
           RBASED.FREEPGS$->FL_FREEPGS.HILITE = '0'B;
        RETURN;
END DG_FREEPGS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_BATCHQ: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 BATCHQ$ PTR;
  DCL 1 FL_BATCHQ BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(4);
  DCL B$TCB$ PTR SYMREF;
  DCL RSLT$ PTR;
DCL  DG_GETMEM ENTRY ALTRET;
  DCL EDIT4 (0:1) BIT(9) CONSTANT INIT('103'O,'321'O);
  DCL CN# CHAR(4);
  DCL IN# UBIN;
%INCLUDE B_SEGIDS_C;
%CP6$ENTS;
%B$TCB;
%B$ALT;
%FPT_JOBSTATS(FPTN=CHK_INPUTQ,
        CRITERIA=INPUTQ,
        ORDER=SRCH,
        OUTPUT=NO);
%VLP_CRITERIA(FPTN=INPUTQ,
        WSN='?');
%FPT_JOBSTATS(FPTN=CHK_RUNQ,
        CRITERIA=RUNQ,
        ORDER=SRCH,
        OUTPUT=NO);
%VLP_CRITERIA(FPTN=RUNQ,
        RUNNING=YES);
%VLR_JOBSTATS_ISRCH(FPTN=RESULTS,
        STCLASS="BASED(RSLT$)");
%VLP_VECTOR(STCLASS=SYMREF);
/*
        Procedure
*/
        IN# = 0;
        IF VLP_VECTOR=VECTOR(NIL) THEN GOTO NOMEM;
        CHK_INPUTQ.RESULTS_ = VLP_VECTOR;
        CHK_RUNQ.RESULTS_ = VLP_VECTOR;
        RSLT$ = VLP_VECTOR.PTR$;
RETRY:  CALL M$JOBSTATS(CHK_INPUTQ) WHENALTRETURN DO;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# = 1114 THEN DO;
             CALL DG_GETMEM ALTRET(NOMEM);
              CHK_INPUTQ.RESULTS_ = VLP_VECTOR;
              CHK_RUNQ.RESULTS_ = VLP_VECTOR;
              GOTO RETRY;
              END;
           END;
        IN# = RESULTS.FOUND;
        CALL M$JOBSTATS(CHK_RUNQ) ALTRET(NONE2);
NONE2:  IN# = IN# - RESULTS.FOUND;
        CALL BINCHAR(CN#,IN#);
        CALL EDITCHAR(CN#,,,EDIT4,CN#);
        RBASED.BATCHQ$->FL_BATCHQ.V.C# = CN#;
IGN:    RETURN;
NOMEM:  RBASED.BATCHQ$->FL_BATCHQ.V.C# = 'Mem!';
        RETURN;
END DG_BATCHQ;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_SYMBQ: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 SYMBQ$ PTR;
  DCL 1 FL_SYMBQ BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(4);
  DCL B$TCB$ PTR SYMREF;
  DCL RSLT$ PTR;
DCL  DG_GETMEM ENTRY ALTRET;
  DCL EDIT4 (0:1) BIT(9) CONSTANT INIT('103'O,'321'O);
  DCL CN# CHAR(4);
%INCLUDE B_SEGIDS_C;
%CP6$ENTS;
%B$TCB;
%B$ALT;
%FPT_JOBSTATS(CRITERIA=VLP_CRITERIA,
        ORDER=SRCH,
        OUTPUT=YES);
%VLP_CRITERIA(PRIO=0,
        PRIO1=15);
%VLR_JOBSTATS_OSRCH(FPTN=RESULTS,
        STCLASS="BASED(RSLT$)");
%VLP_VECTOR(STCLASS=SYMREF);
/*
        Procedure
*/
        IF VLP_VECTOR=VECTOR(NIL) THEN GOTO NOMEM;
        FPT_JOBSTATS.RESULTS_ = VLP_VECTOR;
        RSLT$ = VLP_VECTOR.PTR$;
RETRY:  CALL M$JOBSTATS(FPT_JOBSTATS) WHENALTRETURN DO;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# = 1114 THEN DO;
             CALL DG_GETMEM ALTRET(NOMEM);
              FPT_JOBSTATS.RESULTS_ = VLP_VECTOR;
              GOTO RETRY;
              END;
           END;
        CALL BINCHAR(CN#,RESULTS.FOUND);
        CALL EDITCHAR(CN#,,,EDIT4,CN#);
        RBASED.SYMBQ$->FL_SYMBQ.V.C# = CN#;
IGN:    RETURN;
NOMEM:  RBASED.SYMBQ$->FL_SYMBQ.V.C# = 'Mem!';
        RETURN;
END DG_SYMBQ;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_USERCOUNTS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTR$ (0:11) PTR;
  DCL 1 FL_USERS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(3);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL M$LM DCB;
  DCL B$JIT$ PTR SYMREF;
  DCL M$LM$ PTR;
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$FREEM ENTRY;
  DCL JIT$ PTR;
  DCL LM$ PTR;
  DCL IND# UBIN;
  DCL FOUND BIT(1);
  DCL TALLY (0:6) UBIN;
  DCL CTLLY (0:6) CHAR(3);
  DCL FNAME# CHAR(31);
  DCL CHR3# CHAR(3);
  DCL CHR4# CHAR(4);
  DCL CHR5# CHAR(5);
  DCL CHR6# CHAR(6);
  DCL CHR7# CHAR(7);
%INCLUDE DA_MAP_R;
%INCLUDE B$JIT;
%CP6$ENTS;
%F$DCB(STCLASS="BASED(LM$)");
%FPT_DISPLAY(RESULTS=RESULTS);
%VLR_DISPLAY(FPTN=RESULTS);
/*
        Procedure
*/
        M$LM$ = DCBADDR(DCBNUM(M$LM));
        DO IND# = 0 TO 6;
           TALLY(IND#) = 0;
           END;
        CALL DAM$INIT;
        DO IND# = 1 TO DA_MUAIS;
           CALL DAM$MAP(B$JIT$,JIT$,-IND#,0) ALTRET(NONE);
           IF JIT$->B$JIT.MODE = %M_INT# THEN DO;
              IF JIT$->B$JIT.CPFLAGS1 & %CP_JSTEP# THEN
                 TALLY(5) = TALLY(5) + 1;
              ELSE
                 IF JIT$->B$JIT.CPFLAGS1 & %CP_LOGOFF# OR JIT$->B$JIT.CPFLAGS1 & %CP_LASTCP# THEN ;
                 ELSE DO;
                    CALL DAM$MAP(M$LM$,LM$,-IND#,0) ALTRET(NONE);
                    FNAME# = F$DCB.NAME#.C;
                    DO SELECT(FNAME#);
                       SELECT('EDIT                           ',
                              '6EDIT                          ',
                              '6E                             ');
                          TALLY(0) = TALLY(0) + 1;
                       SELECT('MAIL                           ',
                              'SEND                           ');
                          TALLY(1) = TALLY(1) + 1;
                       SELECT('PCL                            ');
                          TALLY(2) = TALLY(2) + 1;
                       SELECT('SPSS                           ',
                              'BMDP                           ',
                              'SPICE                          ',
                              'SLAM                           ',
                              'MINITAB                        ',
                              'BIMED                          ',
                              'BIMEDT                         ');
                          TALLY(4) = TALLY(4) + 1;
                       SELECT(ELSE);
                          IF SUBSTR(FNAME#,0,4) = 'BMDP' THEN
                             TALLY(4) = TALLY(4) + 1;
                          ELSE DO;
                             CHR3# = SUBSTR(FNAME#,0,3);
                             CHR4# = SUBSTR(FNAME#,0,4);
                             CHR5# = SUBSTR(FNAME#,0,5);
                             CHR6# = SUBSTR(FNAME#,0,6);
                             CHR7# = SUBSTR(FNAME#,0,7);
                             IF (CHR3# = 'PL1') OR (CHR3# = 'PL6') OR
                                (CHR3# = 'APL') OR (CHR3# = 'FPL') OR
                                (CHR3# = 'RPG') OR (CHR4# = 'GMAP') OR
                                (CHR4# = 'BMAP') OR (CHR4# = 'LISP') OR
                                (CHR5# = 'BASIC') OR (CHR5# = 'COBOL') OR
                                (CHR6# = 'PASCAL') OR (CHR6# = 'SNOBOL') OR
                                (CHR7# = 'FORTRAN') OR (CHR7# = 'PARTRGE')
                                                           THEN
                                TALLY(3) = TALLY(3) + 1;
                             ELSE
                                TALLY(6) = TALLY(6) + 1;
                             END;
                       END;
                    END;
              END;
NONE:      END;
        DO IND# = 0 TO 6;
           CALL BINCHAR(CTLLY(IND#),TALLY(IND#));
           CALL EDITCHAR(CTLLY(IND#),,,EDIT3,CTLLY(IND#));
           RBASED.PTR$(IND#+1)->FL_USERS.V.C# = CTLLY(IND#);
           END;
        CALL M$DISPLAY(FPT_DISPLAY);
        CALL BINCHAR(CTLLY(0),RESULTS.OUSERS);
        CALL BINCHAR(CTLLY(1),RESULTS.BUSERS);
        CALL BINCHAR(CTLLY(2),RESULTS.GUSERS);
        CALL BINCHAR(CTLLY(3),RESULTS.TPUSERS);
        CALL EDITCHAR(CTLLY(0),,,EDIT3,CTLLY(0));
        CALL EDITCHAR(CTLLY(1),,,EDIT3,CTLLY(1));
        CALL EDITCHAR(CTLLY(2),,,EDIT3,CTLLY(2));
        CALL EDITCHAR(CTLLY(3),,,EDIT3,CTLLY(3));
        RBASED.PTR$(0)->FL_USERS.V.C# = CTLLY(0);
        RBASED.PTR$(8)->FL_USERS.V.C# = CTLLY(1);
        RBASED.PTR$(9)->FL_USERS.V.C# = CTLLY(2);
        RBASED.PTR$(10)->FL_USERS.V.C# = CTLLY(3);
        TALLY(0) = RESULTS.USERS;
        CALL BINCHAR(CTLLY(0),TALLY(0));
        CALL EDITCHAR(CTLLY(0),,,EDIT3,CTLLY(0));
        RBASED.PTR$(11)->FL_USERS.V.C# = CTLLY(0);
        IF RESULTS.USERS < 100 THEN
           RBASED.PTR$(11)->FL_USERS.HILITE = '0'B;
        ELSE IF RESULTS.USERS < 150 THEN DO;
           RBASED.PTR$(11)->FL_USERS.HILITE = '1'B;
           RBASED.PTR$(11)->FL_USERS.HIATT = 1;
           END;
        ELSE IF RESULTS.USERS < 180 THEN DO;
           RBASED.PTR$(11)->FL_USERS.HILITE = '1'B;
           RBASED.PTR$(11)->FL_USERS.HIATT = 2;
           END;
        ELSE IF RESULTS.USERS < 190 THEN DO;
           RBASED.PTR$(11)->FL_USERS.HILITE = '1'B;
           RBASED.PTR$(11)->FL_USERS.HIATT = 3;
           END;
        ELSE DO;
           RBASED.PTR$(11)->FL_USERS.HILITE = '1'B;
           RBASED.PTR$(11)->FL_USERS.HIATT = 4;
           END;
        CALL DAM$FREEM;
        RETURN;
END DG_USERCOUNTS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_SYSGRANS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 SYSGRANS$ PTR;
  DCL 1 FL_SYSGRANS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(7);
  DCL FREE# UBIN;
  DCL CFR# CHAR(7);
  DCL NEXT# UBIN;
  DCL GRANULE UBIN STATIC;
  DCL XTNDIST(0:18) UBIN;
  DCL NVOL# UBIN;
  DCL FGRANS UBIN;
  DCL AGRANS UBIN;
  DCL VOLGRAN(0:19) UBIN;
  DCL XTN$ PTR;
  DCL IND# UBIN;
  DCL BITX UBIN;
  DCL BITS (0:35) BIT(36) CONSTANT INIT(
                   '4'O,           '2'O,           '1'O,
                  '04'O,          '02'O,          '01'O,
                 '004'O,         '002'O,         '001'O,
                '0004'O,        '0002'O,        '0001'O,
               '00004'O,       '00002'O,       '00001'O,
              '000004'O,      '000002'O,      '000001'O,
             '0000004'O,     '0000002'O,     '0000001'O,
            '00000004'O,    '00000002'O,    '00000001'O,
           '000000004'O,   '000000002'O,   '000000001'O,
          '0000000004'O,  '0000000002'O,  '0000000001'O,
         '00000000004'O, '00000000002'O, '00000000001'O,
        '000000000004'O,'000000000002'O,'000000000001'O);
  DCL M$DP DCB;
  DCL EDIT7 (0:1) BIT(9) CONSTANT INIT('106'O,'321'O);
  DCL B$JIT$ PTR SYMREF;
%INCLUDE FM$FIT;
%INCLUDE MOM_C64;
%INCLUDE B$JIT;
%INCLUDE B_SEGIDS_C;
  DCL F$CFU_ UBIN CONSTANT INIT(BITBIN(%SPCL5SID));
  DCL F$CFU$ REDEF F$CFU_ PTR;
%FM$SET(BASED="BASED(F$CFU$)");
%FM$CFUX;
%FM$VID(BASED=STATIC);
%FM$GRAN(BASED="REDEF FM$VID",FLINK="FLINK UBIN, 2 * (0:1018)");
%FM$FIT(BASED="REDEF FM$VID, 2 * (0:4) UBIN",N=1018);
%FM$GP(BASED="BASED(XTN$)");
%CP6$ENTS;
%FPT_OPEN(FPTN=OPEN#SYS,
        ACCT=VLP_ACCT,
        ASN=DEVICE,
        DCB=M$DP,
        FUN=IN,
        RES='DP',
        SN=VLP_SN);
%FPT_READ(FPTN=READ#SYS,
        BUF=FM$FIT,
        DCB=M$DP,
        KEY=GRANULE,
        KEYS=YES);
%FPT_CLOSE(DCB=M$DP,
        DISP=SCRATCH);
%VLP_ACCT;
%VLP_SN(SN='SYS   ');
%FPT_SAD(MONSID=%DS1SID,
        USERSID=%SPCL5SID);
/*
        Procedure
*/
        IF NOT (B$JIT.PRIV.ACTIVE & %PR_FMDIAG#) THEN DO;
           RBASED.SYSGRANS$->FL_SYSGRANS.V.C# = 'Unknown';
           RETURN;
           END;
        CALL M$SAD(FPT_SAD);
        NEXT# = FM$CFUX.SETH;
MAINL:  DO WHILE(NEXT# ~= 0);
           IF FM$SET.PSN(NEXT#) = 'SYS   ' THEN DO;
              GRANULE = 0;
              XTNDIST = '0'B;
              CALL M$OPEN(OPEN#SYS);
              CALL M$READ(READ#SYS);
              NVOL# = FM$VID.VOLCNT;
              FGRANS = 0;
              IND# = 0;
              FM$GRAN.BLINK = 0;
              GRANULE = 1 + FM_SRZERO;
              VOLGRAN = '0'B;
              DO WHILE(GRANULE ~= 0);
                 CALL M$READ(READ#SYS) ALTRET(BADGP);
                 IF IND# ~= FM$GRAN.BLINK AND IND# ~= 0 THEN
                    GOTO BADGP;
                 XTN$ = ADDR(FM$FIT.CODES);
                 DO WHILE(FM$GRAN.NAVX > POFFW(XTN$,ADDR(FM$FIT)));
                    IF FM$GP.XTNS < FM$GRAN.NAVX-POFFW(XTN$,ADDR(FM$FIT)) THEN DO;
                       IND# = MOD(FM$GP.VOL,SIZEW(VOLGRAN));
                       VOLGRAN(IND#) = VOLGRAN(IND#) - FGRANS;
                       DO IND# = 0 TO FM$GP.XTNS-2;
                          AGRANS = FM$GP.XTN.EADR(IND#) - FM$GP.XTN.ADR(IND#);
                          IF AGRANS > 0 THEN
                             FGRANS = FGRANS + AGRANS;
                          BITX = 18;
                          DO WHILE(AGRANS <= BITBIN(BITS(BITX)) AND BITX < 36);
                             BITX = BITX + 1;
                             END;
                          XTNDIST(BITX-18) = XTNDIST(BITX-18) + 1;
                          END;
                       IND# = MOD(FM$GP.VOL,SIZEW(VOLGRAN));
                       VOLGRAN(IND#) = VOLGRAN(IND#) + FGRANS;
                       XTN$ = PINCRW(XTN$,FM$GP.XTNS+1);
                       END;
                    ELSE
                       XTN$ = ADDR(FM$FIT.CODES(FM$GRAN.NAVX));
                    END;
                 IND# = GRANULE;
                 GRANULE = FM$GRAN.FLINK;
                 END;
              CALL M$CLOSE(FPT_CLOSE);
              FREE# = 0;
              DO IND# = 1 TO NVOL#;
                 FREE# = FREE# + VOLGRAN(IND#);
                 END;
              EXIT MAINL;
              END;
           NEXT# = FM$SET.SETL(NEXT#);
           END MAINL;
        CALL BINCHAR(CFR#,FREE#);
        CALL EDITCHAR(CFR#,,,EDIT7,CFR#);
        RBASED.SYSGRANS$->FL_SYSGRANS.V.C# = CFR#;
        IF FREE# < 500 THEN DO;
           RBASED.SYSGRANS$->FL_SYSGRANS.HILITE = '1'B;
           RBASED.SYSGRANS$->FL_SYSGRANS.HIATT = 4;
           END;
        ELSE IF FREE# < 1000 THEN DO;
              RBASED.SYSGRANS$->FL_SYSGRANS.HILITE = '1'B;
              RBASED.SYSGRANS$->FL_SYSGRANS.HIATT = 2;
              END;
           ELSE IF FREE# < 5000 THEN DO;
                 RBASED.SYSGRANS$->FL_SYSGRANS.HILITE = '1'B;
                 RBASED.SYSGRANS$->FL_SYSGRANS.HIATT = 1;
                 END;
              ELSE
                 RBASED.SYSGRANS$->FL_SYSGRANS.HILITE = '0'B;
        RETURN;
BADGP:  RBASED.SYSGRANS$->FL_SYSGRANS.V.C# = 'Bad GP!';
        RBASED.SYSGRANS$->FL_SYSGRANS.HILITE = '1'B;
        RBASED.SYSGRANS$->FL_SYSGRANS.HIATT = 4;
        RETURN;
END DG_SYSGRANS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_USRS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 ONLINE$ PTR,
         2 BATCH$ PTR,
         2 GHOST$ PTR,
         2 TP$ PTR;
  DCL 1 FL_USRS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(3);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL TMP CHAR(3);
%CP6$ENTS;
%FPT_DISPLAY(RESULTS=VLR_DISPLAY);
%VLR_DISPLAY;
/*
        Procedure
*/
        CALL M$DISPLAY(FPT_DISPLAY);
        CALL BINCHAR(TMP,VLR_DISPLAY.OUSERS);
        CALL EDITCHAR(TMP,,,EDIT3,TMP);
        RBASED.ONLINE$->FL_USRS.V.C# = TMP;
        CALL BINCHAR(TMP,VLR_DISPLAY.BUSERS);
        CALL EDITCHAR(TMP,,,EDIT3,TMP);
        RBASED.BATCH$->FL_USRS.V.C# = TMP;
        CALL BINCHAR(TMP,VLR_DISPLAY.GUSERS);
        CALL EDITCHAR(TMP,,,EDIT3,TMP);
        RBASED.GHOST$->FL_USRS.V.C# = TMP;
        CALL BINCHAR(TMP,VLR_DISPLAY.TPUSERS);
        CALL EDITCHAR(TMP,,,EDIT3,TMP);
        RBASED.TP$->FL_USRS.V.C# = TMP;
        RETURN;
END DG_USRS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_ONLINEUSERS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTRS (0:39),
            3 ACCT$ PTR,
            3 SYSID$ PTR,
            3 MEM$ PTR,
            3 CPU$ PTR,
            3 PROC$ PTR;
  DCL 1 FL_ACCT BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(8);
  DCL 1 FL_SYSID BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(5);
  DCL 1 FL_MEM BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(3);
  DCL 1 FL_CPU BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(6);
  DCL 1 FL_PROC BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(11);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL EDIT5 (0:1) BIT(9) CONSTANT INIT('104'O,'321'O);
  DCL TMP2 CHAR(2);
  DCL TMP3 CHAR(3);
  DCL TMP5 CHAR(5);
  DCL TMP6 CHAR(6);
  DCL 1 STORE# (0:199) ALIGNED,
         2 ACCN CHAR(8),
         2 SYSID UBIN HALF UNAL,
         2 CURRCORE UBIN HALF UNAL,
         2 TIME,
            3 MIN SBIN,
            3 SEC SBIN,
         2 PROC# CHAR(12),
         2 KEY UBIN;
  DCL 1 STORE2# ALIGNED,
         2 ACCN CHAR(8),
         2 SYSID UBIN HALF UNAL,
         2 CURRCORE UBIN HALF UNAL,
         2 TIME,
            3 MIN SBIN,
            3 SEC SBIN,
         2 PROC# CHAR(12),
         2 KEY UBIN;
  DCL B$JIT$ PTR SYMREF;
  DCL M$LM DCB;
  DCL M$LM$ PTR;
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$FREEM ENTRY;
  DCL JIT$ PTR;
  DCL LM$ PTR;
  DCL TEMP SBIN;
  DCL SWITCH BIT(1);
  DCL IND# SBIN;
  DCL IND2# SBIN;
  DCL IND3# SBIN;
%INCLUDE DA_MAP_R;
%INCLUDE B$JIT_C;
%B$JIT0(STCLASS="BASED(JIT$)");
%U$JIT1;
%M$JIT2;
%F$JIT3;
%S$JIT4;
%J$JIT5;
%A$JIT6;
%F$DCB(STCLASS="BASED(LM$)");
/*
        Procedure
*/
        M$LM$ = DCBADDR(DCBNUM(M$LM));
        DO IND# = 0 TO 199;
           STORE#.ACCN(IND#) = ' ';
           STORE#.SYSID(IND#) = 0;
           STORE#.CURRCORE(IND#) = 0;
           STORE#.PROC#(IND#) = ' ';
           STORE#.KEY(IND#) = 0;
           STORE#.TIME.MIN(IND#) = 0;
           STORE#.TIME.SEC(IND#) = 0;
           END;
        CALL DAM$INIT;
        IND2# = 0;
        DO IND# = 1 TO DA_MUAIS;
           CALL DAM$MAP(B$JIT$,JIT$,-IND#,0) ALTRET(NOPE);
           IF B$JIT.MODE = %M_INT# THEN DO;
              CALL DAM$MAP(M$LM$,LM$,-IND#,0) ALTRET(NOPE);
              STORE#.ACCN(IND2#) = B$JIT.ACCN;
              STORE#.SYSID(IND2#) = B$JIT.SYSID;
              STORE#.CURRCORE(IND2#) = B$JIT.CURRCORE;
              TEMP = B$JIT.TPEXT + B$JIT.TPSVT + B$JIT.TUEXT + B$JIT.TUSVT;
              STORE#.TIME.MIN(IND2#) = TEMP / 6000;
              STORE#.TIME.SEC(IND2#) = MOD(TEMP,6000) / 100;
              IF B$JIT.CPFLAGS1 & %CP_JSTEP# THEN
                 STORE#.PROC#(IND2#) = '!(job step)';
              ELSE
                 STORE#.PROC#(IND2#) = F$DCB.NAME#.C;
              STORE#.KEY(IND2#) = TEMP;
              IND2# = IND2# + 1;
              END;
NOPE:      END;
        SWITCH = '1'B;
        IND# = 0;
        IND2# = IND2# - 1;
        DO WHILE(IND# <= IND2#-1 AND SWITCH);
           SWITCH = '0'B;
           DO IND3# = 0 TO IND2#-1;
              IF STORE#.KEY(IND3#) < STORE#.KEY(IND3#+1) THEN DO;
                 SWITCH = '1'B;
                 STORE2# = STORE#(IND3#);
                 STORE#(IND3#) = STORE#(IND3#+1);
                 STORE#(IND3#+1) = STORE2#;
                 END;
              END;
           IND# = IND# + 1;
           END;
        IF IND2# >= 39 THEN
           IND2# = 39;
        DO IND# = 0 TO IND2#;
           RBASED.PTRS.ACCT$(IND#)->FL_ACCT.V.C# = STORE#.ACCN(IND#);
           CALL BINCHAR(TMP5,STORE#.SYSID(IND#));
           CALL EDITCHAR(TMP5,,,EDIT5,TMP5);
           RBASED.PTRS.SYSID$(IND#)->FL_SYSID.V.C# = TMP5;
           CALL BINCHAR(TMP3,STORE#.CURRCORE(IND#));
           CALL EDITCHAR(TMP3,,,EDIT3,TMP3);
           RBASED.PTRS.MEM$(IND#)->FL_MEM.V.C# = TMP3;
           CALL BINCHAR(TMP3,STORE#.TIME.MIN(IND#));
           CALL EDITCHAR(TMP3,,,EDIT3,TMP3);
           CALL BINCHAR(TMP2,STORE#.TIME.SEC(IND#));
           CALL CONCAT(TMP6,TMP3,':',TMP2);
           RBASED.PTRS.CPU$(IND#)->FL_CPU.V.C# = TMP6;
           RBASED.PTRS.PROC$(IND#)->FL_PROC.V.C# = STORE#.PROC#(IND#);
           END;
        DO IND# = IND2#+1 TO 39;
           RBASED.PTRS.ACCT$(IND#)->FL_ACCT.V.C# = ' ';
           RBASED.PTRS.SYSID$(IND#)->FL_SYSID.V.C# = ' ';
           RBASED.PTRS.MEM$(IND#)->FL_MEM.V.C# = ' ';
           RBASED.PTRS.CPU$(IND#)->FL_CPU.V.C# = ' ';
           RBASED.PTRS.PROC$(IND#)->FL_PROC.V.C# = ' ';
           END;
        CALL DAM$FREEM;
        RETURN;
END DG_ONLINEUSERS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_TIME2: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL DATE CHAR(8) STATIC INIT(' ');
  DCL TIME CHAR(11) STATIC INIT(' ');
  DCL DT CHAR(15);
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 DATE$ PTR;
  DCL 1 FL_DATE BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(14);
%CP6$ENTS;
%FPT_TIME(DATE=DATE,
        DEST=LOCAL,
        SOURCE=CLOCK,
        TIME=TIME);
/*
        Procedure
*/
        CALL M$TIME(FPT_TIME);
        CALL CONCAT(DT,DATE,' ',SUBSTR(TIME,0,5));
        RBASED.DATE$->FL_DATE.V.C# = DT;
        RETURN;
END DG_TIME2;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_USERS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTR$ (0:4) PTR;
  DCL 1 FL_USERS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(3);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$FREEM ENTRY;
  DCL INP$ PTR STATIC;
  DCL S_MUIS (0:4) SBIN SYMREF;
  DCL S_MUIS$ PTR STATIC;
  DCL S_MUIS@ (0:4) SBIN BASED;
  DCL IND# UBIN;
  DCL CND# CHAR(3);
%INCLUDE DA_MAP_R;
/*
        Procedure
*/
        CALL DAM$INIT;
        INP$ = ADDR(S_MUIS);
        CALL DAM$MAP(INP$,S_MUIS$,0,0) ALTRET(BMB);
        CALL BINCHAR(CND#,DA_MUAIS);
        CALL EDITCHAR(CND#,,,EDIT3,CND#);
        RBASED.PTR$(0)->FL_USERS.V.C# = CND#;
        DO IND# = 1 TO 4;
           CALL BINCHAR(CND#,S_MUIS$->S_MUIS@(IND#));
           CALL EDITCHAR(CND#,,,EDIT3,CND#);
           RBASED.PTR$(IND#)->FL_USERS.V.C# = CND#;
           END;
BMB:    CALL DAM$FREEM;
        RETURN;
END DG_USERS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_FEPS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTR$ (0:1) PTR;
  DCL 1 FL_FEPS BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(10);
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$FREEM ENTRY;
  DCL INP$ PTR;
/*DCL KI_FEST (0:16) UBIN SYMREF;
  DCL KI_FEST$ PTR;
  DCL KI_FEST@ (0:16) UBIN BASED(KI_FEST$);
  DCL KI_MXFE UBIN SYMREF;
  DCL KI_MXFE$ PTR;
  DCL KI_MXFE@ UBIN BASED; */
  DCL IND# UBIN;
  DCL FEPSTAT (0:5) CHAR(10) STATIC INIT('Down      ','TOK       ',
                                         'Running   ','Queue full',
                                         'Debug mode','Dumping   ');
%INCLUDE DA_MAP_R;
/*
        Procedure
*/
        RETURN;
/*      INP$ = ADDR(KI_FEST);
        CALL DAM$INIT;
        CALL DAM$MAP(INP$,KI_FEST$,0,0) ALTRET(BMB);
        DO IND# = 1 TO 2;                  Both local FEPs.
           RBASED.PTR$(IND#-1)->FL_FEPS.V.C# = FEPSTAT(KI_FEST@(IND#));
           END;
BMB:    CALL DAM$FREEM;
        RETURN; */
END DG_FEPS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_RUNJOBS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTRS (0:10),
            3 ACCT$ PTR,
            3 PART$ PTR,
            3 SYSID$ PTR,
            3 MEM$ PTR,
            3 CPU$ PTR,
            3 JOBNAME$ PTR;
  DCL 1 FL_CHR8 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(8);
  DCL 1 FL_CHR6 BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(6);
  DCL 1 FL_MEM BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(3);
  DCL 1 FL_PART BASED,
         2 HILITE BIT(1),
         2 HIATT UBIN(35) UNAL,
         2 * UBIN,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(2);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL EDIT6 (0:1) BIT(9) CONSTANT INIT('105'O,'321'O);
  DCL TMP2 CHAR(2);
  DCL TMP3 CHAR(3);
  DCL TMP6 CHAR(6);
  DCL TEMP UBIN;
  DCL MIN UBIN;
  DCL IND# UBIN;
  DCL IND2# UBIN;
  DCL JIT$ PTR;
  DCL B$JIT$ PTR SYMREF;
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$FREEM ENTRY;
%INCLUDE DA_MAP_R;
%INCLUDE B$JIT_C;
%B$JIT0(STCLASS="BASED(JIT$)");
%U$JIT1;
%M$JIT2;
%F$JIT3;
%S$JIT4;
%J$JIT5;
%A$JIT6;
/*
        Procedure
*/
        CALL DAM$INIT;
        IND2# = 0;
DLP:    DO IND# = 1 TO DA_MUAIS;
           CALL DAM$MAP(B$JIT$,JIT$,-IND#,0) ALTRET(NOPE);
           IF B$JIT.MODE = %M_BATCH# THEN DO;
              RBASED.PTRS.ACCT$(IND2#)->FL_CHR8.V.C# = B$JIT.ACCN;
              CALL BINCHAR(RBASED.PTRS.PART$(IND2#)->FL_PART.V.C#,B$JIT.PNR+1);
              IF B$JIT.PNR+1 < 10 THEN
                   SUBSTR(RBASED.PTRS.PART$(IND2#)->FL_PART.V.C#,0,1)= ' ';
              CALL BINCHAR(TMP3,B$JIT.CURRCORE);
              CALL EDITCHAR(TMP3,,,EDIT3,TMP3);
              RBASED.PTRS.MEM$(IND2#)->FL_MEM.V.C# = TMP3;
              TEMP = B$JIT.TPEXT + B$JIT.TPSVT + B$JIT.TUEXT + B$JIT.TUSVT;
              MIN = TEMP / 6000;
              TEMP = MOD(TEMP,6000) / 100;
              CALL BINCHAR(TMP3,MIN);
              CALL EDITCHAR(TMP3,,,EDIT3,TMP3);
              CALL BINCHAR(TMP2,TEMP);
              CALL CONCAT(TMP6,TMP3,':',TMP2);
              RBASED.PTRS.CPU$(IND2#)->FL_CHR6.V.C# = TMP6;
              CALL BINCHAR(TMP6,B$JIT.SYSID);
              CALL EDITCHAR(TMP6,,,EDIT6,TMP6);
              RBASED.PTRS.SYSID$(IND2#)->FL_CHR6.V.C# = TMP6;
              RBASED.PTRS.JOBNAME$(IND2#)->FL_CHR8.V.C# = B$JIT.JOBNAME;
              IND2# = IND2# + 1;
              IF IND2# > 10 THEN
                 EXIT DLP;
              END;
NOPE:      END DLP;
        DO IND# = IND2# TO 10;
           RBASED.PTRS.ACCT$(IND#)->FL_CHR8.V.C# = ' ';
           RBASED.PTRS.PART$(IND#)->FL_PART.V.C# = '  ';
           RBASED.PTRS.SYSID$(IND#)->FL_CHR6.V.C# = ' ';
           RBASED.PTRS.MEM$(IND#)->FL_MEM.V.C# = ' ';
           RBASED.PTRS.CPU$(IND#)->FL_CHR6.V.C# = ' ';
           RBASED.PTRS.JOBNAME$(IND#)->FL_CHR8.V.C# = ' ';
           END;
        CALL DAM$FREEM;
        RETURN;
END DG_RUNJOBS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_WAITJOBS: PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
         2 * EPTR,
         2 * PTR,
         2 * BIT(72) ALIGNED,
         2 * BIT(72) ALIGNED,
         2 PTRS (0:20),
            3 ACCT$ PTR,
            3 SYSID$ PTR,
            3 PRI$ PTR,
            3 MXT$ PTR,
            3 PRT$ PTR;
  DCL 1 FL_ACCT BASED,
         2 * BIT(72) ALIGNED,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(8);
  DCL 1 FL_SYSID BASED,
         2 * BIT(72) ALIGNED,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(6);
  DCL 1 FL_PRI BASED,
         2 * BIT(72) ALIGNED,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(2);
  DCL 1 FL_MXT BASED,
         2 * BIT(72) ALIGNED,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(9);
  DCL 1 FL_PRT BASED,
         2 * BIT(72) ALIGNED,
         2 * CHAR(16),
         2 V,
            3 L# UBIN(9) UNAL,
            3 C# CHAR(2);
  DCL B$TCB$ PTR SYMREF;
  DCL EDIT6 (0:1) BIT(9) CONSTANT INIT('105'O,'321'O);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
  DCL EDIT2 (0:1) BIT(9) CONSTANT INIT('101'O,'321'O);
  DCL TMP9 CHAR(9);
  DCL TMP6 CHAR(6);
  DCL TMP3 CHAR(3);
  DCL TMP2 CHAR(2);
  DCL TMP1 CHAR(2);
  DCL TEMP UBIN;
  DCL TEMP2 UBIN;
  DCL IND# UBIN;
  DCL IND2# UBIN;
  DCL JOB# UBIN;
  DCL JOB$ PTR;
  DCL PMASK (0:15) BIT(16) STATIC INIT('1000000000000000'B,
                                       '0100000000000000'B,
                                       '0010000000000000'B,
                                       '0001000000000000'B,
                                       '0000100000000000'B,
                                       '0000010000000000'B,
                                       '0000001000000000'B,
                                       '0000000100000000'B,
                                       '0000000010000000'B,
                                       '0000000001000000'B,
                                       '0000000000100000'B,
                                       '0000000000010000'B,
                                       '0000000000001000'B,
                                       '0000000000000100'B,
                                       '0000000000000010'B,
                                       '0000000000000001'B);
%CP6$ENTS;
%B$TCB;
%B$ALT;
%INCLUDE CP_6_SUBS;
%FPT_JOBSTATS(FPTN=CHK_INPUTQ,
        CRITERIA=INPUTQ,
        ORDER=SRCH,
        OUTPUT=NO,
        RESULTS=RESULTS);
%VLP_CRITERIA(FPTN=INPUTQ,
        WSN='?');
%VLR_JOBSTATS_ISRCH(FPTN=RESULTS,
        NJOB=25);
%VLA_JOBSTATS_ISRCH(FPTN=JOB,
        STCLASS="BASED(JOB$)");
/*
        Procedure
*/
        IND# = 0;
        CALL M$JOBSTATS(CHK_INPUTQ) WHENALTRETURN DO;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= 1114 THEN
              GOTO NONE;
           END;
        DO JOB# = 0 TO RESULTS.FOUND-1;
           JOB$ = ADDR(RESULTS.J(JOB#));
           IF JOB.PRIO ~= %JP_RUN# THEN DO;
              RBASED.PTRS.ACCT$(IND#)->FL_ACCT.V.C# = JOB.ACCT;
              CALL BINCHAR(TMP6,JOB.SYSID);
              CALL EDITCHAR(TMP6,,,EDIT6,TMP6);
              RBASED.PTRS.SYSID$(IND#)->FL_SYSID.V.C# = TMP6;
              DO CASE(JOB.PRIO);
                 CASE(%JP_FOLL#);
                    TMP2 = 'Fo';
                 CASE(%JP_RUNAFTER#);
                    TMP2 = 'Df';
                 CASE(%JP_WPART#);
                    TMP2 = 'Wp';
                 CASE(%JP_OTHER#);
                    TMP2 = 'O?';
                 CASE(%JP_WPS#);
                    TMP2 = 'Wd';
                 CASE(ELSE);
                    CALL BINCHAR(TMP2,JOB.PRIO);
                    CALL EDITCHAR(TMP2,,,EDIT2,TMP2);
                 END;
              RBASED.PTRS.PRI$(IND#)->FL_PRI.V.C# = TMP2;
              TEMP = JOB.TIM / 100;
              TEMP2 = MOD(TEMP,60);
              CALL BINCHAR(TMP2,TEMP2);
              CALL INSERT(TMP9,6,3,':',TMP2);
              TEMP = TEMP / 60;
              TEMP2 = MOD(TEMP,60);
              TEMP = TEMP / 60;
              IF TEMP = 0 THEN DO;
                 CALL BINCHAR(TMP2,TEMP2);
                 CALL EDITCHAR(TMP2,,,EDIT2,TMP2);
                 CALL INSERT(TMP9,0,6,'    ',TMP2);
                 END;
              ELSE DO;
                 CALL BINCHAR(TMP2,TEMP2);
                 CALL INSERT(TMP9,3,3,':',TMP2);
                 CALL BINCHAR(TMP3,TEMP);
                 CALL EDITCHAR(TMP3,,,EDIT3,TMP3);
                 CALL INSERT(TMP9,0,3,TMP3);
                 END;
              RBASED.PTRS.MXT$(IND#)->FL_MXT.V.C# = TMP9;
              TMP1 = '--';
LP:           DO IND2# = 0 TO 15;
                 IF JOB.PART & PMASK(IND2#) THEN DO;
                    CALL BINCHAR(TMP1,IND2#+1);
                    IF IND2#+1 < 10 THEN SUBSTR(TMP1,0,1) = ' ';
                    EXIT LP;
                    END;
                 END LP;
              RBASED.PTRS.PRT$(IND#)->FL_PRT.V.C# = TMP1;
              IND# = IND# + 1;
              IF IND# > 20 THEN
                 RETURN;
              END;
           END;
NONE:   DO JOB# = IND# TO 20;
           RBASED.PTRS.ACCT$(JOB#)->FL_ACCT.V.C# = ' ';
           RBASED.PTRS.SYSID$(JOB#)->FL_SYSID.V.C# = ' ';
           RBASED.PTRS.PRI$(JOB#)->FL_PRI.V.C# = ' ';
           RBASED.PTRS.MXT$(JOB#)->FL_MXT.V.C# = ' ';
           RBASED.PTRS.PRT$(JOB#)->FL_PRT.V.C# = '  ';
           END;
        RETURN;
END DG_WAITJOBS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_IOCACHE:   PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
        2 * EPTR,
        2 * PTR,
        2 * BIT(72) ALIGNED,
        2 * BIT(72) ALIGNED,
        2 PTR$ (0:4) PTR;
  DCL 1 FL_IOCACHE BASED,
        2 HILITE BIT(1),
        2 HIATT UBIN(35) UNAL,
        2 * UBIN,
        2 * CHAR(16),
        2 V,
           3 L# UBIN(9) UNAL,
           3 C# CHAR(6);
  DCL 1 FL_MIN BASED,
        2 HILITE BIT(1),
        2 HIATT UBIN(35) UNAL,
        2 * UBIN,
        2 * CHAR(16),
        2 V,
           3 L# UBIN(9) UNAL,
           3 C# CHAR(3);
  DCL TOT_HITS# UBIN;
  DCL TOT_ATTS# UBIN;
  DCL VAL# (0:2) UBIN;
  DCL IO_NOW UBIN;
  DCL SP_NOW UBIN;
  DCL IO_LAST UBIN STATIC INIT(0);
  DCL SP_LAST UBIN STATIC INIT(0);
  DCL 1 NUM,
        2 I# CHAR(3),
        2 D# CHAR(2);
  DCL NUMR REDEF NUM CHAR(5);
  DCL SEC_SINCE_BOOT UBIN;
  DCL MINUTE UBIN;
  DCL INT_SECS UBIN;
  DCL MIN_BIT BIT(1);
  DCL IND# UBIN;
  DCL IO_TRUNC$ PTR;
  DCL SP_TRUNC$ PTR;
  DCL FMC$STATS$ PTR;
  DCL LIMITS$ PTR;
  DCL UTS_DIFF SBIN;
  DCL CUR_UTS UBIN STATIC;
  DCL PTR$ PTR BASED;
  DCL 1 LIMITS (0:0) BASED(LIMITS$),
        2 EXPIRE SBIN,
        2 * SBIN;
  DCL IO_TRUNC UBIN BASED(IO_TRUNC$);
  DCL SP_TRUNC UBIN BASED(SP_TRUNC$);
  DCL EDIT5 (0:1) BIT(9) CONSTANT INIT('103'O,'322'O);
  DCL FIRST_TIME BIT(1) STATIC INIT('1'B);
  DCL DAM$INIT ENTRY ALTRET;
  DCL DAM$MAP ENTRY(5) ALTRET;
  DCL DAM$FREEM ENTRY;
  DCL SLEEP_TIME UBIN SYMREF;
%INCLUDE MOM_C65;
%INCLUDE DA_MAP_R;
%INCLUDE XUD_UTS_M;
%XUD$UTS_ENTRIES;
%XUD_UTS_EQU;
%CP6$ENTS;
%FMC$STATS(STCLASS="BASED(FMC$STATS$)");
%FMC$STATS(FPTN=FMC$NOW,STCLASS="");
%FMC$STATS(FPTN=FMC$LAST,STCLASS=STATIC);
%FPT_MONINFO(MONINFO=VLR_MONINFO);
%FPT_TIME(TSTAMP=CUR_UTS);
%VLR_MONINFO;
/*
        Procedure
*/
        CALL DAM$INIT;
        CALL DAM$MAP(ADDR(FMC_STATS$),FMC$STATS$,,,DA_MONISDATA);
        FMC$STATS$ = FMC$STATS$->PTR$;
        CALL DAM$MAP(FMC$STATS$,FMC$STATS$);
        CALL DAM$MAP(ADDR(MM_IOTRNC),IO_TRUNC$,,,DA_MONISDATA);
        CALL DAM$MAP(ADDR(MM_SPTRNC),SP_TRUNC$,,,DA_MONISDATA);
        CALL DAM$MAP(FMC_LIMITS,LIMITS$,,,DA_MONISDATA);
        CALL M$MONINFO(FPT_MONINFO);
        CALL M$TIME(FPT_TIME);
        CALL XUD$UTS_DIFF_25TH (UTS_DIFF, CUR_UTS, VLR_MONINFO.INIT_UTS#);
        SEC_SINCE_BOOT = (UTS_DIFF + %UTS_25TH_SEC#/2) / %UTS_25TH_SEC#;
        IF FIRST_TIME OR SLEEP_TIME < 15 THEN DO;
           IO_LAST = 0;
           SP_LAST = 0;
           FMC$LAST = '0'B;
           MINUTE = 60;
           INT_SECS = SEC_SINCE_BOOT;
           FIRST_TIME = '0'B;
           END;
        ELSE DO;
           INT_SECS = SLEEP_TIME;
           MINUTE = SLEEP_TIME;
           END;
        IO_NOW = IO_TRUNC - IO_LAST;
        SP_NOW = SP_TRUNC - SP_LAST;
        IO_LAST = IO_TRUNC;
        SP_LAST = SP_TRUNC;
        DO IND# = 0 TO %(%CACHETYPES-1);
           FMC$NOW.HITZERO(IND#) = FMC$STATS.HITZERO(IND#) - FMC$LAST.HITZERO(IND#);
           FMC$NOW.HITNONZERO(IND#) = FMC$STATS.HITNONZERO(IND#) - FMC$LAST.HITNONZERO(IND#);
           FMC$NOW.ATTGET(IND#) = FMC$STATS.ATTGET(IND#) - FMC$LAST.ATTGET(IND#);
           END;
        FMC$LAST = FMC$STATS;
        VAL#(1) = ((IO_NOW * 1000 / INT_SECS * MINUTE) + 5) / 10;
        VAL#(2) = ((SP_NOW * 1000 / INT_SECS * MINUTE) + 5) / 10;
        MIN_BIT = '1'B;
        IF VAL#(1) > 99999 OR VAL#(2) > 99999 THEN DO;
           VAL#(1) = ((IO_NOW * 1000 / INT_SECS) + 5) / 10;
           VAL#(2) = ((SP_NOW * 1000 / INT_SECS) + 5) / 10;
           MIN_BIT = '0'B;
           END;
        TOT_HITS# = 0;
        TOT_ATTS# = 0;
        DO IND# = 0 TO 9;
           IF LIMITS.EXPIRE(IND#) ~= 0 THEN DO;
              TOT_HITS# = TOT_HITS# + FMC$NOW.HITZERO(IND#) + FMC$NOW.HITNONZERO(IND#);
              TOT_ATTS# = TOT_ATTS# + FMC$NOW.ATTGET(IND#);
              END;
           END;
LP1:    IF TOT_ATTS# > 250000 THEN DO;
           TOT_HITS# = ((TOT_HITS# / 100) + 5) / 10;
           TOT_ATTS# = ((TOT_ATTS# / 100) + 5) / 10;
           GOTO LP1;
           END;
        IF TOT_ATTS# = 0 THEN
           TOT_ATTS# = 1;
        VAL#(0) = (((TOT_HITS# * 100000) / TOT_ATTS#) + 5) / 10;
        DO IND# = 0 TO 2;
           CALL BINCHAR(NUMR,VAL#(IND#));
           CALL EDITCHAR(NUMR,,,EDIT5,NUMR);
           CALL CONCAT(RBASED.PTR$(IND#)->FL_IOCACHE.V.C#,NUM.I#,'.',NUM.D#);
           END;
        DO IND# = 3 TO 4;
           IF MIN_BIT THEN
              RBASED.PTR$(IND#)->FL_MIN.V.C# = 'int';
           ELSE
              RBASED.PTR$(IND#)->FL_MIN.V.C# = 'sec';
           IF FIRST_TIME OR SLEEP_TIME < 15 THEN
              RBASED.PTR$(IND#)->FL_MIN.V.C# = 'min';
           END;
        CALL DAM$FREEM;
        RETURN;
END DG_IOCACHE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_STATS:   PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
        2 * EPTR,
        2 * PTR,
        2 * BIT(72) ALIGNED,
        2 * BIT(72) ALIGNED,
        2 PTR$ (0:4) PTR;
  DCL 1 FL_STATS BASED,
        2 HILITE BIT(1),
        2 HIATT UBIN(35) UNAL,
        2 * UBIN,
        2 * CHAR(16),
        2 V,
           3 L# UBIN(9) UNAL,
           3 C# CHAR(5);
  DCL SLEEP_TIME UBIN SYMREF;
  DCL B$JIT$ PTR SYMREF;
  DCL B$TCB$ PTR SYMREF;
  DCL IND# UBIN;
  DCL CPU# UBIN;
  DCL LOC# UBIN;
DCL  DG_GETMEM ENTRY ALTRET;
  DCL PTR$ PTR;
  DCL PEND$ PTR;
  DCL 1 PMDAT BASED(PTR$) ALIGNED,
        2 ID# UBIN,
        2 ENT# UBIN(18) HALIGNED,
        2 WPE# UBIN(18) HALIGNED,
        2 DATA# (0:0) UBIN;
  DCL STAT_DATA (0:55) UBIN;
  DCL TOT_STATS (0:7) UBIN;
  DCL PERCENT# (0:7) UBIN;
  DCL TEMP# UBIN;
  DCL 1 CTEMP,
        2 I# CHAR(3),
        2 D# CHAR(1);
  DCL CTEMPR REDEF CTEMP CHAR(4);
  DCL TOT_NOW (0:7) UBIN;
  DCL STAT_NOW (0:7) UBIN;
  DCL TEMP_NOW UBIN;
  DCL TEMP_TOT UBIN;
  DCL FIRST_TIME BIT(1) STATIC INIT('1'B);
  DCL TOT_LAST (0:7) UBIN STATIC INIT(0);
  DCL STAT_LAST (0:55) UBIN STATIC INIT(0*0);
  DCL EDIT4 (0:1) BIT(9) CONSTANT INIT('103'O,'321'O);
  DCL STAT_IDS (0:6) UBIN CONSTANT INIT(20,21,22,23,24,46,47);
%INCLUDE B$JIT;
%INCLUDE B_SEGIDS_C;
%CP6$ENTS;
%B$TCB;
%B$ALT;
%FPT_GETPM;
%VLP_VECTOR(STCLASS=SYMREF);
/*
        Procedure
*/
        IF NOT B$JIT.PRIV.ACTIVE & %PR_PM# THEN DO;
           DO IND# = 0 TO 4;
              RBASED.PTR$(IND#)->FL_STATS.V.C# = '     ';
              END;
           RETURN;
           END;
        DO WHILE ('0'B);
RETRY:     CALL DG_GETMEM ALTRET(NOMEM);
        END;
        IF VLP_VECTOR=VECTOR(NIL) THEN GOTO NOMEM;
        FPT_GETPM.RESULTS_ = VLP_VECTOR;
        CALL M$GETPM(FPT_GETPM) WHENALTRETURN DO;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= 7 THEN DO;
              DO IND# = 0 TO 4;
                 RBASED.PTR$(IND#)->FL_STATS.V.C# = '     ';
                 END;
              RBASED.PTR$(0)->FL_STATS.V.C# = 'Error';
              RBASED.PTR$(1)->FL_STATS.V.C# = 'on   ';
              RBASED.PTR$(2)->FL_STATS.V.C# = 'GETPM';
              RETURN;
              END;
           END;
        PTR$ = VLP_VECTOR.PTR$;
        PEND$ = PINCRW(PTR$,VLP_VECTOR.W1.VSIZE# / 4);
        IND# = 0;
        DO WHILE(IND# < 7);
           IF PMDAT.ID# = STAT_IDS(IND#) THEN DO;
              DO CPU# = 0 TO PMDAT.ENT# - 1;
                 LOC# = IND# * 8 + CPU#;
                 STAT_DATA(LOC#) = PMDAT.DATA#(CPU#);
                 END;
              IND# = IND# + 1;
              END;
           PTR$ = PINCRW(PTR$,PMDAT.ENT# * PMDAT.WPE# + 2);
           IF PTR$ >= PEND$ THEN
              GOTO RETRY;
           END;
        DO CPU# = 0 TO 7;
           TOT_STATS(CPU#) = 0;
           END;
        DO IND# = 0 TO 6;
           DO CPU# = 0 TO 7;
              LOC# = IND# * 8 + CPU#;
              TOT_STATS(CPU#) = TOT_STATS(CPU#) + STAT_DATA(LOC#);
              END;
           END;
        DO CPU# = 0 TO 7;
           TEMP# = STAT_DATA(32+CPU#) + STAT_DATA(40+CPU#) + STAT_DATA(48+CPU#);
           STAT_DATA(32+CPU#) = STAT_DATA(24+CPU#);
           STAT_DATA(24+CPU#) = STAT_DATA(16+CPU#);
           STAT_DATA(16+CPU#) = TEMP#;
           END;
        IF FIRST_TIME OR SLEEP_TIME < 15 THEN DO;
           DO CPU# = 0 TO 7;
              TOT_LAST(CPU#) = 0;
              END;
           DO IND# = 0 TO 4;
              DO CPU# = 0 TO 7;
                 LOC# = IND# * 8 + CPU#;
                 STAT_LAST(LOC#) = 0;
                 END;
              END;
           FIRST_TIME = '0'B;
           END;
        DO CPU# = 0 TO 7;
           TOT_NOW(CPU#) = TOT_STATS(CPU#) - TOT_LAST(CPU#);
           END;
        DO IND# = 0 TO 4;
           DO CPU# = 0 TO 7;
              PERCENT#(CPU#) = 0;
              IF TOT_NOW(CPU#) = 0 THEN /* Don't process null CPU. */
                 GOTO SKIP;
              LOC# = IND# * 8 + CPU#;
              STAT_NOW(CPU#) = STAT_DATA(LOC#) - STAT_LAST(LOC#);
              TEMP_NOW = STAT_NOW(CPU#);
              TEMP_TOT = TOT_NOW(CPU#);
LP:           IF TEMP_NOW > 3425000 THEN DO;
                 TEMP_NOW = ((TEMP_NOW / 10) + 5) / 10;
                 TEMP_TOT = ((TEMP_TOT / 10) + 5) / 10;
                 GOTO LP;
                 END;
              PERCENT#(CPU#) = (((TEMP_NOW * 10000) / TEMP_TOT) + 5) / 10;
              STAT_LAST(LOC#) = STAT_DATA(LOC#);
SKIP:         END;
           TEMP# = 0;
           DO CPU# = 0 TO 7;
              TEMP# = TEMP# + PERCENT#(CPU#);
              END;
           CALL BINCHAR(CTEMPR,TEMP#);
           CALL EDITCHAR(CTEMPR,,,EDIT4,CTEMPR);
           CALL CONCAT(RBASED.PTR$(IND#)->FL_STATS.V.C#,CTEMP.I#,'.',CTEMP.D#);
           END;
        TOT_LAST = TOT_STATS;
IGN:    RETURN;
NOMEM:  DO IND# = 0 TO 4;
           RBASED.PTR$(IND#)->FL_STATS.V.C# = ' ';
           END;
        RBASED.PTR$(0)->FL_STATS.V.C# = 'No   ';
        RBASED.PTR$(1)->FL_STATS.V.C# = 'more ';
        RBASED.PTR$(2)->FL_STATS.V.C# = 'mem! ';
        RETURN;
END DG_STATS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_INTERVAL:   PROC(ROUT$);
  DCL ROUT$ PTR;
  DCL 1 RBASED BASED(ROUT$),
        2 * EPTR,
        2 * PTR,
        2 * BIT(72) ALIGNED,
        2 * BIT(72) ALIGNED,
        2 PTR$ PTR;
  DCL 1 FL_INTERVAL BASED,
        2 HILITE BIT(1),
        2 HIATT UBIN(35) UNAL,
        2 * UBIN,
        2 * CHAR(16),
        2 V,
           3 L# UBIN(9) UNAL,
           3 C# CHAR(21);
  DCL SLEEP_TIME UBIN SYMREF;
  DCL CINT# CHAR(3);
  DCL CTMP CHAR(21);
  DCL EDIT3 (0:1) BIT(9) CONSTANT INIT('102'O,'321'O);
/*
        Procedure
*/
        IF SLEEP_TIME < 15 THEN DO;
           RBASED.PTR$->FL_INTERVAL.V.C# = '---------------------';
           RETURN;
           END;
        CALL BINCHAR(CINT#,SLEEP_TIME);
        CALL EDITCHAR(CINT#,,,EDIT3,CINT#);
        CALL CONCAT(CTMP,' Interval:  ',CINT#,' sec. ');
        RBASED.PTR$->FL_INTERVAL.V.C# = CTMP;
        RETURN;
END DG_INTERVAL;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DG_GETMEM:   PROC ALTRET;
 
%CP6$ENTS;
 
%FPT_GDS (FPTN=GETMEM,
          RESULTS=VLP_VECTOR,
          SEGSIZE=1024);
 
%VLP_VECTOR(STCLASS=SYMREF) ;
 
DCL MEM# UBIN WORD SYMREF;
 
/*
          Procedure
*/
          CALL M$GDS(GETMEM) ALTRET (NOMEM);
          MEM# = MEM#+1024;
          RETURN;
NOMEM:    VLP_VECTOR = VECTOR(NIL);
          ALTRETURN ;
 
END DG_GETMEM;
