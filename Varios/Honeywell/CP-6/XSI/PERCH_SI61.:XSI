/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
PERCH:  PROC MAIN;
 
/****************************************************************/
/*                                                              */
/*                   SUBSTITUTION VARIABLES                     */
/*                                                              */
/****************************************************************/
%SUB STACK_SIZE = 100;
%SUB MAXINT = 999999999;
 
/****************************************************************/
/*                                                              */
/*                     EQUATED VARIABLES                        */
/*                                                              */
/****************************************************************/
%EQU RIGHT = '1'B;
%EQU LEFT  = '0'B;
%EQU STACK_MAX = STACK_SIZE + 1;
 
%EJECT
/****************************************************************/
/*                                                              */
/*                      INCLUDED FILES                          */
/*                                                              */
/****************************************************************/
%INCLUDE CP_6      ;                    /* CP-6 SERVICES LIBRARY              */
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C;                    /* ERROR LOOK UP                      */
%INCLUDE XS_MACRO_C;
%INCLUDE XU_MACRO_C;                    /* PARSING ROUTINES                   */
%INCLUDE XU_SUBS_C ;
%INCLUDE B$JIT     ;
 
/****************************************************************/
/*                                                              */
/*                   PREPROCESSOR COMMANDS                      */
/*                                                              */
/****************************************************************/
%B$TCB                         ;
%B$ALT                         ;
%F$DCB(DCBN=FDCB)              ;
%SUB_EXC                       ;
%SUB BBUFSIZ#=8192 /*BBUFSIZ#*/;
%SUB KBUFSIZ#=1024 /*KBUFSIZ#*/;
%M$DCB(DCBN=M$LO,RES='LO')     ;
%PARSE$OUT(STCLASS=BASED)      ;
%PARSE$SYM(STCLASS=BASED)      ;
%VLP_VECTOR(FPTN=DATA_VECTOR)  ;
 
 
/****************************************************************/
/*                                                              */
/*                          SYMREFS                             */
/*                                                              */
/****************************************************************/
DCL B$TCB$ PTR SYMREF;
DCL B$JIT$ PTR SYMREF;
 
/****************************************************************/
/*                                                              */
/*                            DCBS                              */
/*                                                              */
/****************************************************************/
DCL M$EI DCB      ;
DCL M$DO DCB      ;
DCL M$OU DCB      ;
DCL M$SI DCB      ;
DCL M$TERMINAL DCB;
 
%EJECT
/****************************************************************/
/*                                                              */
/*                    EXTERNAL PROCEDURES                       */
/*                                                              */
/****************************************************************/
DCL XSA$OPEN  ENTRY(2) ALTRET;
DCL XSA$READ  ENTRY(2) ALTRET;
DCL XSA$WRITE ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
DCL X$PARSE   ENTRY(1) ALTRET;
 
%EJECT
/****************************************************************/
/*                                                              */
/*                            FPTS                              */
/*                                                              */
/****************************************************************/
%FPT_ERRMSG(FPTN=PERCH_ERR,
            BUF =WORK_AREA,
            OUTDCB1=M$DO);
 
%FPT_OPEN(FPTN=SI_IN,
          FUN =IN   ,
          DCB =M$SI);
 
%FPT_OPEN(FPTN=LO_OUT,
          FUN =CREATE,
          DCB =M$LO);
 
%FPT_READ(FPTN=GET_FID,
          DCB =M$SI,
          BUF =FID_BUF);
 
%FPT_READ(FPTN=READ_REC,
          DCB =M$SI,
          KEY =KEYBUF,
          KEYR=YES,
          BUF =INLINE);
 
%FPT_WRITE(FPTN=TO_TERM,
           DCB =M$TERMINAL,
           BUF =OUTLINE);
 
%FPT_WRITE(FPTN=TO_LO,
           DCB =M$LO,
           BUF =OUTLINE);
 
%FPT_CLOSE(FPTN=LO_CLOSE,
           DISP=SAVE,
           DCB =M$LO);
 
%XSA_PARAM(FPTN=SI_PARAM,
           BBUF=NIL,
           KBUF=NIL);
 
%P_PCB(NAME=PERCH_PCB,
       R   =PERCH_CMD,
       W   =WORK_AREA,
       WSZ ="SIZEW(WORK_AREA)");
 
%EJECT
/****************************************************************/
/*                                                              */
/*                         VARIABLES                            */
/*                                                              */
/****************************************************************/
DCL WORK_AREA(0:200)    UBIN(36)  STATIC                   ;
DCL PERCH_CMD           BIT(36)   SYMREF                   ;
DCL A00_COUNT           UBIN      STATIC          INIT (0) ;
DCL DUMMY               CHAR(50)  STATIC                   ;
DCL OUTLINE             CHAR(256) STATIC                   ;
DCL LO_LINE             CHAR(256) STATIC                   ;
DCL FID_BUF             CHAR(31)  STATIC                   ;
DCL INLINE              CHAR(256) STATIC                   ;
DCL EOF                 BIT(1)    STATIC                   ;
DCL CAP_FLAG            BIT(1)    STATIC                   ;
DCL TOSTR               CHAR(256) STATIC                   ;
DCL STR                 CHAR(256) STATIC                   ;
DCL BLXLAT_STR          CHAR(10)  STATIC          INIT(' ');
DCL INX                 UBIN      STATIC                   ;
DCL IGN_INX             UBIN      STATIC                   ;
DCL TBLVAL              UBIN      STATIC                   ;
DCL START               UBIN      STATIC ALIGNED           ;
DCL XTABLE(0:511)       UBIN(9)          CALIGNED          ;
DCL SEARCH_TABLE(0:511) UBIN(9)          CALIGNED          ;
DCL I                   UBIN      STATIC                   ;
DCL IGN_FLAG(0:30)      UBIN      STATIC                   ;
DCL KEYED_FILE          BIT(1)                             ;
DCL BYPASSED            BIT(1)    STATIC                   ;
DCL DIRECTION           BIT(1)    STATIC                   ;
DCL NUM_BLANKS          UBIN      STATIC                   ;
DCL M$SI$               PTR       STATIC                   ;
DCL REC_SIZE            UBIN      STATIC                   ;
DCL REC_IS_NOT_PRINTED  BIT(1)    STATIC                   ;
DCL SKIP_THIS_REC       BIT(1)    STATIC                   ;
DCL NOT_FOUND           BIT(1)    STATIC                   ;
DCL COL_NUM             CHAR(9)   STATIC                   ;
DCL POS                 UBIN      STATIC                   ;
DCL IS_H_ELLIPSE        BIT(1)    STATIC                   ;
DCL IS_DIGIT1           BIT(1)    STATIC                   ;
DCL IS_DIGIT2           BIT(1)    STATIC                   ;
DCL ALTERED             BIT(1)    STATIC                   ;
DCL SCHEMA_FLAG         BIT(1)    STATIC                   ;
DCL INT_LINEREF         UBIN      STATIC                   ;
 
%EJECT
/****************************************************************/
/*                                                              */
/*                         STRUCTURES                           */
/*                                                              */
/****************************************************************/
DCL RECCNT STATIC SBIN;
DCL 1 TEXT REDEF RECCNT,
      2 * UNAL     CHAR(1),
      2 KEY UNAL   CHAR(3);
 
DCL 1 SEQUENCE_STUFF    STATIC,
      2 MAX_SEQUENCE    UBIN(9) INIT (9),
      2 C               SBIN,
      2 SEQUENCE(0:9)   CHAR(20)    CALIGNED,
      2 SEQLNGTH(0:9)   UBIN(9),
      2 RESERVE_CHAR_STARTS_SEQUENCE   BIT(1);
 
DCL 1 PAREN_STACK         STATIC,
      2 HEAD            SBIN,
      2 PAREN_LINE(0:STACK_SIZE) CHAR(9),
      2 PAREN_COL (0:STACK_SIZE) UBIN,
      2 TALE            SBIN;
 
DCL 1 BRACKET_STACK         STATIC,
      2 HEAD            SBIN,
      2 BRACKET_LINE(0:STACK_SIZE) CHAR(9),
      2 BRACKET_COL (0:STACK_SIZE) UBIN,
      2 TALE            SBIN;
 
DCL 1 BRACE_STACK         STATIC,
      2 HEAD            SBIN,
      2 BRACE_LINE(0:STACK_SIZE) CHAR(9),
      2 BRACE_COL (0:STACK_SIZE) UBIN,
      2 TALE            SBIN;
 
DCL 1 SQUOTE_STACK         STATIC,
      2 HEAD            SBIN,
      2 SQUOTE_LINE(0:STACK_SIZE) CHAR(9),
      2 SQUOTE_COL (0:STACK_SIZE) UBIN,
      2 TALE            SBIN;
 
DCL 1 DQUOTE_STACK         STATIC,
      2 HEAD            SBIN,
      2 DQUOTE_LINE(0:STACK_SIZE) CHAR(9),
      2 DQUOTE_COL (0:STACK_SIZE) UBIN,
      2 TALE            SBIN;
 
DCL LINEREF STATIC CHAR(9);
DCL 1 EDIT REDEF LINEREF,
      2 INTG UNAL CHAR(5),
      2 PER  UNAL CHAR(1),
      2 FRAC UNAL CHAR(3);
 
DCL 1 KEYBUF STATIC,
      2 L UNAL UBIN BYTE,
      2 C UNAL CHAR(31) ;
 
DCL DECTXT STATIC  CHAR(16) INIT('FCG-MCODE#-S/LIN');
DCL 1 DEC REDEF DECTXT,
      2 FCG1 UNAL  CHAR(1),
      2 FCG2 UNAL  CHAR(1),
      2 FCG3 UNAL  CHAR(1),
      2 *    UNAL  CHAR(1),
      2 MON  UNAL  CHAR(1),
      2 CODE UNAL  CHAR(5),
      2 *    UNAL  CHAR(1),
      2 SEV  UNAL  CHAR(1),
      2 *    UNAL  CHAR(1),
      2 LIN  UNAL  CHAR(3);
 
/* -------------------------------------------------------------------------- */
BEGIN:                                  /* MAIN-LINE                          */
        M$SI$= DCBADDR(DCBNUM(M$SI));
        SI_PARAM.BBUF_.BUF$ = DATA_VECTOR.PTR$;
        SI_PARAM.BBUF_.BOUND = BBUFSIZ#*4 - 1;
        SI_PARAM.KBUF_.BUF$ = PINCRW(SI_PARAM.BBUF_. BUF$,BBUFSIZ#);
        SI_PARAM.KBUF_.BOUND = KBUFSIZ#*4 - 1;
 
        SI_IN.NAME_ = VECTOR(M$SI$->FDCB.NAME#);
        SI_IN.ACCT_ = VECTOR(M$SI$->FDCB.ACCT#);
 
        IF (M$SI$->FDCB.ASN# ~= %FILE#) THEN
           CALL NO_FILE_GIVEN;
 
        SEQUENCE_STUFF.C = -1;
        TOSTR = ' ';
        INLINE = ' ';
        CAP_FLAG = '0'B;
        RECCNT = 0;
        BYPASSED = '0'B;
        PAREN_STACK.HEAD = 0;
        PAREN_STACK.TALE = 0;
        BRACKET_STACK.HEAD = 0;
        BRACKET_STACK.TALE = 0;
        BRACE_STACK.HEAD = 0;
        BRACE_STACK.TALE = 0;
        SQUOTE_STACK.HEAD = 0;
        SQUOTE_STACK.TALE = 0;
        DQUOTE_STACK.HEAD = 0;
        DQUOTE_STACK.TALE = 0;
        ALTERED = '0'B;
        SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE = '0'B;
        CALL XSA$OPEN(SI_IN,SI_PARAM)
        WHENALTRETURN
        DO;
           CALL REPORT_ERROR;
           END;                         /* WHENALTRETURN                      */
 
        CALL M$OPEN(LO_OUT)
        WHENALTRETURN
        DO;
           CALL REPORT_LO_ERROR;
           END;                         /* WHENALTRETURN                      */
 
        IF (B$JIT.CCDISP ~= B$JIT.CCARS) THEN
        DO;
           PERCH_PCB.TEXT$=PINCRC(ADDR(B$JIT.CCBUF),B$JIT.CCDISP);
           PERCH_PCB.NCHARS=B$JIT.CCARS - B$JIT.CCDISP;
           CALL X$PARSE(PERCH_PCB)
           WHENALTRETURN DO;
              PERCH_ERR.CODE_ = VECTOR(PERCH_PCB.ERROR);
              CALL M$ERRMSG(PERCH_ERR);
              CALL M$ERR;
              END;                      /* WHENALTRETURN DO                   */
 
           DO INX = 0 TO (PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.NSUBLKS - 1);
              IF PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(INX)->
                OUT$BLK.CODE=3 THEN
              DO;
                 CAP_FLAG = ( PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE = 7);
                 END;                   /* IF CAP_FLAG                        */
              ELSE
              DO;
                 IF (PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(INX)->
                   OUT$BLK.CODE=4) THEN
                 DO IGN_INX= 0 TO (PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(INX)->OUT$BLK.NSUBLKS - 1);
                    CALL CHARBIN(IGN_FLAG(IGN_INX),PERCH_PCB.OUT$->
                      OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(INX)->
                      OUT$BLK.SUBLK$(IGN_INX)->OUT$SYM.TEXT);
                    END;                /* IF IGNORE CODE                     */
                 ELSE
                 DO;
                    IF (PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->
                      OUT$BLK.SUBLK$(INX)->OUT$BLK.CODE=5) THEN
                    DO;
                       BLXLAT_STR = PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->
                         OUT$BLK.SUBLK$(INX)->OUT$BLK.SUBLK$(0)->
                         OUT$SYM.TEXT;
                       END;             /* DO BLXLAT CODE                     */
                     ELSE
                       DO;
                         SCHEMA_FLAG = (PERCH_PCB.OUT$->OUT$BLK.SUBLK$(0)->
                            OUT$BLK.SUBLK$(INX)->OUT$BLK.CODE=6);
                       END;    /* IF SCHEMA IS ON */
                    END;                /* IF BLXLAT CODE                     */
                 END;                   /* ELSE IGN OR BLXLAT OPTIONS         */
              END;                      /* DO INX                             */
           END;                         /* IF OPTIONS EXIST                   */
 
        IF (M$SI$->FDCB.ORG#=%KEYED#) THEN
           KEYED_FILE = '1'B;
        ELSE
           KEYED_FILE = '0'B;
 
        CALL INIT_TABLES;
 
        CALL XSA$READ(READ_REC,SI_PARAM);
        EOF = (SI_PARAM.ERR.CODE = %E$EOF);
        CALL XLATE(TOSTR,XTABLE,INLINE);
        DO WHILE(~ EOF);
           IF KEYED_FILE THEN
           DO;
              TEXT.KEY = KEYBUF.C;
              CALL BINCHAR(EDIT.INTG,RECCNT/1000);
              CALL BINCHAR(EDIT.FRAC,MOD(RECCNT,1000));
              EDIT.PER='.';
              END;                      /* IF KEYED_FILE                      */
           ELSE
           DO;
              RECCNT = RECCNT + 1;
              CALL BINCHAR(LINEREF,RECCNT);
              END;                      /* ELSE DO                            */
           CALL BLANKING_ZEROS(LINEREF);
 
           CALL PROCESS_REC;
           INLINE = ' ';
           TOSTR = ' ';
           CALL XSA$READ(READ_REC,SI_PARAM);
           CALL XLATE(TOSTR,XTABLE,INLINE);
           EOF = (SI_PARAM.ERR.CODE = %E$EOF);
           END;                         /* DO WHILE                           */
        CALL EMPTY_QUES;
        CALL M$CLOSE(LO_CLOSE);
/* -------------------------------------------------------------------------- */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Initializes the translation table and the search table. */
INIT_TABLES: PROC;
 
        DO INX = 0 TO 511;
           XTABLE(INX)  = INX;
           SEARCH_TABLE(INX) = 0;
           END;                         /* DO INX                             */
 
        DO INX = 0 TO (LENGTHC(BLXLAT_STR) - 1);
           XTABLE(ASCBIN(SUBSTR(BLXLAT_STR,INX,1))) = ASCBIN(' ');
           END;                         /* DO INX                             */
 
        SEARCH_TABLE(ASCBIN('!')) = 1;
        SEARCH_TABLE(ASCBIN('"')) = 1;
        SEARCH_TABLE(ASCBIN(''''))= 1;
        SEARCH_TABLE(ASCBIN('(')) = 1;
        SEARCH_TABLE(ASCBIN(')')) = 1;
        SEARCH_TABLE(ASCBIN(',')) = 1;
        SEARCH_TABLE(ASCBIN('.')) = 1;
        SEARCH_TABLE(ASCBIN(':')) = 1;
        SEARCH_TABLE(ASCBIN(';')) = 1;
        SEARCH_TABLE(ASCBIN('?')) = 1;
        SEARCH_TABLE(ASCBIN('[')) = 1;
        SEARCH_TABLE(ASCBIN(']')) = 1;
        SEARCH_TABLE(ASCBIN('{')) = 1;
        SEARCH_TABLE(ASCBIN('}')) = 1;
        SEARCH_TABLE(ASCBIN('-')) = 1;
        SEARCH_TABLE(ASCBIN('\')) = 1;
 
END INIT_TABLES;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Processes the entire file by scanning for specific chars. */
PROCESS_REC: PROC;
 
        SKIP_THIS_REC = '0'B;
 
        IF ( ((SUBSTR(TOSTR,0,8) = '.*P* OFF') AND (NOT CAP_FLAG)) OR
          ((SUBSTR(TOSTR,0,11) = '\*{*P* OFF}') AND CAP_FLAG) )THEN
        DO;
           BYPASSED = '1'B;
           SKIP_THIS_REC = '1'B;
           END;
        ELSE
           IF ( ((SUBSTR(TOSTR,0,7) = '.*P* ON') AND (NOT CAP_FLAG)) OR
             ((SUBSTR(TOSTR,0,10) = '\*{*P* ON}') AND CAP_FLAG) ) THEN
           DO;
              BYPASSED = '0'B;
              SKIP_THIS_REC = '1'B;
              END;
 
        IF ( (SUBSTR(TOSTR,0,1) = '.') AND (NOT CAP_FLAG) ) THEN
           SKIP_THIS_REC = '1'B;
 
        IF ( (((SUBSTR(TOSTR,0,6) = '.*P* ''') AND (NOT CAP_FLAG)) OR
          ((SUBSTR(TOSTR,0,8) = '\*{*P* ''') AND CAP_FLAG) ) AND
          (SEQUENCE_STUFF.C < SEQUENCE_STUFF.MAX_SEQUENCE)) THEN
        DO;
           CALL LOAD_SEQUENCE;
           SKIP_THIS_REC = '1'B;
           END;
 
        INX = 0;
        START = 0;
        CALL SEARCH(INX,TBLVAL,SEARCH_TABLE,TOSTR,START)
        WHENALTRETURN DO; END;
 
        REC_IS_NOT_PRINTED = '1'B;
        REC_SIZE = M$SI$->FDCB.ARS#;
        DO WHILE ((INX <= (REC_SIZE - 1) ) AND (NOT (BYPASSED)) AND (NOT SKIP_THIS_REC));
           DO SELECT (SUBSTR(TOSTR,INX,1));
            SELECT( '\' );              /* IGNORING CAP B00 COMMANDS          */
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              IF (CAP_FLAG) THEN
              DO;
                 I = INX;
                 DO WHILE( (I <= (REC_SIZE - 1) ) AND
                   (SUBSTR(TOSTR,I,1) ~= '{') );
                    I = I + 1;
                    END;
                 IF (SUBSTR(TOSTR,I,1) = '{') THEN
                 DO;
                    DO WHILE( (I <= (REC_SIZE - 1) ) AND
                      (SUBSTR(TOSTR,I,1) ~= '}') );
                       I = I + 1;
                       END;
                    IF (SUBSTR(TOSTR,I,1) = '}') THEN
                       INX = I + 1;
                    END;
                 END;
               END;
            SELECT( '(' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 PAREN_STACK.PAREN_LINE(PAREN_STACK.TALE) = LINEREF;
                 PAREN_STACK.PAREN_COL(PAREN_STACK.TALE) = INX;
                 PAREN_STACK.TALE = MOD((PAREN_STACK.TALE + 1), %STACK_MAX);
                 IF (PAREN_STACK.TALE = PAREN_STACK.HEAD) THEN
                    PAREN_STACK.HEAD = MOD((PAREN_STACK.HEAD + 1), %STACK_MAX);
                 END;
            SELECT( ')' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 IF (PAREN_STACK.HEAD ~= PAREN_STACK.TALE) THEN
                 DO;
                    PAREN_STACK.TALE = MOD((PAREN_STACK.TALE +%STACK_MAX - 1),%STACK_MAX);
                    END;
                 ELSE
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    CALL BINCHAR(COL_NUM,INX);
                    CALL BLANKING_ZEROS(COL_NUM);
                    CALL CONCAT(OUTLINE,'**** ERROR *** unmatched RIGHT PAREN   on line ',
                      LINEREF,' in column: ',COL_NUM);
                    CALL M$WRITE(TO_LO);
                    END;
                 END;
            SELECT( '[' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 BRACKET_STACK.BRACKET_LINE(BRACKET_STACK.TALE) = LINEREF;
                 BRACKET_STACK.BRACKET_COL(BRACKET_STACK.TALE) = INX;
                 BRACKET_STACK.TALE = MOD((BRACKET_STACK.TALE + 1), %STACK_MAX);
                 IF (BRACKET_STACK.TALE = BRACKET_STACK.HEAD) THEN
                    BRACKET_STACK.HEAD = MOD((BRACKET_STACK.HEAD + 1), %STACK_MAX);
              END;
            SELECT( ']' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 IF (BRACKET_STACK.HEAD ~= BRACKET_STACK.TALE) THEN
                 DO;
                    BRACKET_STACK.TALE = MOD((BRACKET_STACK.TALE +%STACK_MAX - 1),%STACK_MAX);
                    END;
                 ELSE
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    CALL BINCHAR(COL_NUM,INX);
                    CALL BLANKING_ZEROS(COL_NUM);
                    CALL CONCAT(OUTLINE,'**** ERROR *** unmatched RIGHT BRACKET on line ',
                      LINEREF,' in column: ',COL_NUM);
                    CALL M$WRITE(TO_LO);
                 END;
              END;
            SELECT( '{' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 BRACE_STACK.BRACE_LINE(BRACE_STACK.TALE) = LINEREF;
                 BRACE_STACK.BRACE_COL(BRACE_STACK.TALE) = INX;
                 BRACE_STACK.TALE = MOD((BRACE_STACK.TALE + 1), %STACK_MAX);
                 IF (BRACE_STACK.TALE = BRACE_STACK.HEAD) THEN
                    BRACE_STACK.HEAD = MOD((BRACE_STACK.HEAD + 1), %STACK_MAX);
              END;
            SELECT( '}' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
                 IF (BRACE_STACK.HEAD ~= BRACE_STACK.TALE) THEN
                 DO;
                    BRACE_STACK.TALE = MOD((BRACE_STACK.TALE +%STACK_MAX - 1),%STACK_MAX);
                    END;
                 ELSE
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    CALL BINCHAR(COL_NUM,INX);
                    CALL BLANKING_ZEROS(COL_NUM);
                    CALL CONCAT(OUTLINE,'**** ERROR *** unmatched RIGHT BRACE   on line ',
                      LINEREF,' in column: ',COL_NUM);
                    CALL M$WRITE(TO_LO);
                 END;
              END;
            SELECT( '-' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
              IF (NUM_BLANKS ~= 0) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) before HYPHEN';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
              IF ( (NUM_BLANKS > 0) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** extra space(s) after HYPHEN';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              END;
            SELECT( ',' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
              IF (NUM_BLANKS ~= 0) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) before COMMA';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
              IF ( (NUM_BLANKS > 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** extra space(s) after COMMA';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              IF ( (NUM_BLANKS = 0) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) needed after COMMA';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              END;
            SELECT( ';' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
              IF (NUM_BLANKS ~= 0) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) before SEMICOLON';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
              IF ( (NUM_BLANKS > 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** extra space(s) after SEMICOLON';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              IF ( (NUM_BLANKS = 0) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) needed after SEMICOLON';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              END;
            SELECT( ':' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL CHECK_TYPE(TOSTR,INX-1,IS_DIGIT1);
              CALL CHECK_TYPE(TOSTR,INX+1,IS_DIGIT2);
              IF (NOT (IS_DIGIT1 AND IS_DIGIT2)) THEN
              DO;
                 CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
                 IF (NUM_BLANKS ~= 0) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** space(s) before COLON';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
                 IF ( (NUM_BLANKS > 2) AND (INX ~= (REC_SIZE - 1) ) ) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** extra space(s) after COLON';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 IF ( (NUM_BLANKS <= 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** space(s) needed after COLON';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 END;
              END;
            SELECT( '!' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
              IF (NUM_BLANKS ~= 0) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) before EXCLAMATION';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
              IF ( (NUM_BLANKS > 2) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** extra space(s) after EXCLAMATION';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              IF ( (NUM_BLANKS <= 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) needed after EXCLAMATION';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              END;
            SELECT( '?' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
              IF (NUM_BLANKS ~= 0) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) before QUESTION MARK';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
              IF ( (NUM_BLANKS > 2) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** extra space(s) after QUESTION MARK';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              IF ( (NUM_BLANKS <= 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
              DO;
                 IF REC_IS_NOT_PRINTED THEN
                    CALL PRINT_REC;
                 OUTLINE = '*** ERROR *** space(s) needed after QUESTION MARK';
                 CALL M$WRITE(TO_LO);
                 END;                   /* END DO                             */
              END;
            SELECT( '.' );
            IF (SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE) THEN
              CALL CHECK_IF_START_OF_SEQUENCE(ALTERED);
            IF (NOT ALTERED) THEN
              DO;
              CALL CHECK_H_ELLIPSE(TOSTR,INX,IS_H_ELLIPSE);
              CALL CHECK_TYPE(TOSTR,INX-1,IS_DIGIT1);
              CALL CHECK_TYPE(TOSTR,INX+1,IS_DIGIT2);
              IF ( (NOT (IS_DIGIT1 AND IS_DIGIT2)) AND
                (NOT (IS_H_ELLIPSE)) ) THEN
              DO;
                 CALL NUMBER_OF_BLANKS(TOSTR,INX,%LEFT,NUM_BLANKS);
                 IF (NUM_BLANKS ~= 0) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** space(s) before PERIOD';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 CALL NUMBER_OF_BLANKS(TOSTR,INX,%RIGHT,NUM_BLANKS);
                 IF ( (NUM_BLANKS > 2) AND (INX ~= (REC_SIZE - 1) ) ) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** extra space(s) after PERIOD';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 IF ( (NUM_BLANKS <= 1) AND (INX ~= (REC_SIZE - 1) ) ) THEN
                 DO;
                    IF REC_IS_NOT_PRINTED THEN
                       CALL PRINT_REC;
                    OUTLINE = '*** ERROR *** space(s) needed after PERIOD';
                    CALL M$WRITE(TO_LO);
                    END;                /* END DO                             */
                 END;
              END;
            SELECT( ELSE );
              NOT_FOUND = '1'B;
              I = 0;
              DO WHILE ( (I <= SEQUENCE_STUFF.C) AND (NOT_FOUND) );
                 IF (SUBSTR(TOSTR,INX,SEQUENCE_STUFF.SEQLNGTH(I)) =
                   SEQUENCE_STUFF.SEQUENCE(I) ) THEN
                 DO;
                    NOT_FOUND = '0'B;
                    INX = INX + SEQUENCE_STUFF.SEQLNGTH(I) - 1;
                    END;                /* END DO                             */
                 I = I + 1;
                 END;                   /* DO WHILE                           */
            END;                        /* DO SELECT                          */
           START = INX +1;
           CALL SEARCH(INX,TBLVAL,SEARCH_TABLE,INLINE,START);
           END;                         /* DO WHILE                           */
 
END PROCESS_REC;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
EMPTY_QUES: PROC;
/*M* Empties ques after processing of file. */
DCL SMALLEST_LINE   UBIN;
DCL SMALLEST_COL    UBIN;
DCL STACK_NUM      UBIN;
DCL STUFF_REMAINING     BIT(1);
DCL INT_LINEREF         UBIN;
 
        SMALLEST_LINE = MAXINT;
        SMALLEST_COL = MAXINT;
 
        STUFF_REMAINING = ((PAREN_STACK.HEAD ~= PAREN_STACK.TALE) |
          (BRACKET_STACK.HEAD ~= BRACKET_STACK.TALE) |
          (BRACE_STACK.HEAD ~= BRACE_STACK.TALE));
 
        IF (STUFF_REMAINING) THEN
        DO;
           OUTLINE = ' ';
           CALL M$WRITE(TO_LO);
           OUTLINE = ' ';
           CALL M$WRITE(TO_LO);
           CALL CONCAT(OUTLINE,'                           --- END OF FILE SUMMARY ---');
           CALL M$WRITE(TO_LO);
           OUTLINE = ' ';
           CALL M$WRITE(TO_LO);
           END;
        DO WHILE(STUFF_REMAINING);
           IF (PAREN_STACK.HEAD ~= PAREN_STACK.TALE) THEN
           DO;
              CALL INTEGERIZE_LINEREF(PAREN_STACK.PAREN_LINE(PAREN_STACK.HEAD),INT_LINEREF);
              IF ( ((INT_LINEREF = SMALLEST_LINE) AND
                (PAREN_STACK.PAREN_COL(PAREN_STACK.HEAD) < SMALLEST_COL)) OR
                (INT_LINEREF < SMALLEST_LINE) ) THEN
              DO;
                 SMALLEST_LINE = INT_LINEREF;
                 SMALLEST_COL = PAREN_STACK.PAREN_COL(PAREN_STACK.HEAD);
                 STACK_NUM = 0;
                 END;
              END;
 
           IF (BRACKET_STACK.HEAD ~= BRACKET_STACK.TALE) THEN
           DO;
              CALL INTEGERIZE_LINEREF(BRACKET_STACK.BRACKET_LINE(BRACKET_STACK.HEAD),INT_LINEREF);
              IF ( ((INT_LINEREF = SMALLEST_LINE) AND
                (BRACKET_STACK.BRACKET_COL(BRACKET_STACK.HEAD) < SMALLEST_COL)) OR
                (INT_LINEREF < SMALLEST_LINE) ) THEN
              DO;
                 SMALLEST_LINE = INT_LINEREF;
                 SMALLEST_COL = BRACKET_STACK.BRACKET_COL(BRACKET_STACK.HEAD);
                 STACK_NUM = 1;
                 END;
              END;
 
           IF (BRACE_STACK.HEAD ~= BRACE_STACK.TALE) THEN
           DO;
              CALL INTEGERIZE_LINEREF(BRACE_STACK.BRACE_LINE(BRACE_STACK.HEAD),INT_LINEREF);
              IF ( ((INT_LINEREF = SMALLEST_LINE) AND
                (BRACE_STACK.BRACE_COL(BRACE_STACK.HEAD) < SMALLEST_COL)) OR
                (INT_LINEREF < SMALLEST_LINE) ) THEN
              DO;
                 SMALLEST_LINE = INT_LINEREF;
                 SMALLEST_COL = BRACE_STACK.BRACE_COL(BRACE_STACK.HEAD);
                 STACK_NUM = 2;
                 END;
              END;
 
           DO CASE(STACK_NUM);
            CASE(0);                    /* PAREN                              */
              DO;
                 CALL BINCHAR(COL_NUM,PAREN_STACK.PAREN_COL(PAREN_STACK.HEAD));
                 CALL BLANKING_ZEROS(COL_NUM);
                 CALL CONCAT(OUTLINE,'**** ERROR *** unmatched LEFT PAREN   on line ',
                   PAREN_STACK.PAREN_LINE(PAREN_STACK.HEAD),' in column: ',COL_NUM);
                 CALL M$WRITE(TO_LO);
                 PAREN_STACK.HEAD = MOD((PAREN_STACK.HEAD+1),%STACK_MAX);
                 END;
            CASE(1);                    /* BRACKET                            */
              DO;
                 CALL BINCHAR(COL_NUM,BRACKET_STACK.BRACKET_COL(BRACKET_STACK.HEAD));
                 CALL BLANKING_ZEROS(COL_NUM);
                 CALL CONCAT(OUTLINE,'**** ERROR *** unmatched LEFT BRACKET on line ',
                   BRACKET_STACK.BRACKET_LINE(BRACKET_STACK.HEAD),' in column: ',COL_NUM);
                 CALL M$WRITE(TO_LO);
                 BRACKET_STACK.HEAD = MOD((BRACKET_STACK.HEAD+1),%STACK_MAX);
                 END;
            CASE(2);                    /* BRACE                              */
              DO;
                 CALL BINCHAR(COL_NUM,BRACE_STACK.BRACE_COL(BRACE_STACK.HEAD));
                 CALL BLANKING_ZEROS(COL_NUM);
                 CALL CONCAT(OUTLINE,'**** ERROR *** unmatched LEFT BRACE   on line ',
                   BRACE_STACK.BRACE_LINE(BRACE_STACK.HEAD),' in column: ',COL_NUM);
                 CALL M$WRITE(TO_LO);
                 BRACE_STACK.HEAD = MOD((BRACE_STACK.HEAD+1),%STACK_MAX);
                 END;
            END;
           STUFF_REMAINING = ((PAREN_STACK.HEAD ~= PAREN_STACK.TALE) |
             (BRACKET_STACK.HEAD ~= BRACKET_STACK.TALE) |
             (BRACE_STACK.HEAD ~= BRACE_STACK.TALE));
           SMALLEST_LINE = MAXINT;
           SMALLEST_COL = MAXINT;
           END;
END EMPTY_QUES;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Converts char representation of line number into an integer */
INTEGERIZE_LINEREF: PROC(LINEREF,INT_LINEREF);
DCL LINEREF        CHAR(9);
DCL INT_LINEREF    UBIN;
DCL TEMP           CHAR(9);
 
        CALL CONCAT(TEMP,SUBSTR(LINEREF,0,5),SUBSTR(LINEREF,6,3));
        CALL CHARBIN(INT_LINEREF,TEMP);
END INTEGERIZE_LINEREF;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Change preceding 0's in line reference to blanks.  */
BLANKING_ZEROS: PROC(LINEREF);
DCL LINEREF        CHAR(9);
DCL I              UBIN   ;
 
        I=0;
        DO WHILE(SUBSTR(LINEREF,I,1) = '0');
           CALL INSERT(LINEREF,I,1,' ');
           I = I + 1;
           END;                         /* DO WHILE                           */
END BLANKING_ZEROS;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* If sequence began with reserved char then INX points after sequence. */
CHECK_IF_START_OF_SEQUENCE: PROC(ALTERED);
DCL ALTERED BIT(1);
    ALTERED = '0'B;
              NOT_FOUND = '1'B;
              I = 0;
              DO WHILE ( (I <= SEQUENCE_STUFF.C) AND (NOT_FOUND) );
                 IF (SUBSTR(TOSTR,INX,SEQUENCE_STUFF.SEQLNGTH(I)) =
                   SEQUENCE_STUFF.SEQUENCE(I) ) THEN
                 DO;
                    NOT_FOUND = '0'B;
                    INX = INX + SEQUENCE_STUFF.SEQLNGTH(I) - 1;
                    ALTERED = '1'B;
                    END;                /* END DO                             */
                 I = I + 1;
                 END;                   /* DO WHILE                           */
END CHECK_IF_START_OF_SEQUENCE;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Error routine for invocation without a file name.  */
NO_FILE_GIVEN: PROC;
 
        OUTLINE = '** ERROR ** No file given as input';
        CALL M$WRITE(TO_LO);
        CALL M$EXIT;
END NO_FILE_GIVEN;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Reporting inability to open input file. */
REPORT_ERROR: PROC;
/* REPORTING INABILITY TO OPEN FILE ERROR TO TERMINAL */
 
        OUTLINE = '** ERROR ** Unable to OPEN specified input file.';
        CALL M$WRITE(TO_LO);
        CALL M$EXIT;
END REPORT_ERROR;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Reporting inability to open output file. */
REPORT_LO_ERROR: PROC;
/* REPORTING INABILITY TO OPEN FILE ERROR TO TERMINAL */
 
        OUTLINE = '** ERROR ** Unable to OPEN output file.';
        CALL M$WRITE(TO_LO);
        CALL M$EXIT;
END REPORT_LO_ERROR;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Returns the number of blanks in the specified direction. */
NUMBER_OF_BLANKS: PROC(TOSTR,INX,MOVE_RIGHT,NUM_BLANKS);
 
DCL TOSTR          CHAR(256) ;
DCL INX            UBIN      ;
DCL MOVE_RIGHT     BIT(1)    ;
DCL NUM_BLANKS     UBIN      ;
DCL INCREMENT      SBIN      ;
DCL TEMP           UBIN      ;
 
        IF (MOVE_RIGHT) THEN            /* SEARCH LEFT TO RIGHT               */
           INCREMENT = 1;
        ELSE
           INCREMENT = -1;              /* SEARCH RIGHT TO LEFT               */
 
        TEMP = INX + INCREMENT;
        NUM_BLANKS = 0;
        DO WHILE (SUBSTR(TOSTR,TEMP,1) = ' ');
           TEMP = TEMP + INCREMENT;
           NUM_BLANKS = NUM_BLANKS + 1;
           END;                         /* DO WHILE                           */
END NUMBER_OF_BLANKS;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Processes a horizontal elipse. */
CHECK_H_ELLIPSE: PROC(TOSTR,INX,IS_H_ELLIPSE);
 
DCL TOSTR     CHAR(256);
DCL IS_H_ELLIPSE  BIT(1)    ;
DCL INX       UBIN          ;
 
        IS_H_ELLIPSE = ((SUBSTR(TOSTR,INX+1,1) = '.') & (SUBSTR(TOSTR,INX+2,1) = '.'));
        IF (IS_H_ELLIPSE) THEN
           INX = INX + 2;
END CHECK_H_ELLIPSE;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* IS_DIGIT is the result of a numeric test on the CHAR at POS. */
CHECK_TYPE: PROC(TOSTR,POS,IS_DIGIT);
 
DCL TOSTR     CHAR(256);
DCL POS       UBIN      ;
DCL IS_DIGIT  BIT(1)    ;
 
        IS_DIGIT = ( (ASCBIN(SUBSTR(TOSTR,POS,1)) >= ASCBIN('0')) &
          (ASCBIN(SUBSTR(TOSTR,POS,1)) <= ASCBIN('9')) );
END CHECK_TYPE;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Outputs record to Listing Output. */
PRINT_REC: PROC;
 
        OUTLINE = LINEREF;
        CALL M$WRITE(TO_LO);
 
        IF (SCHEMA_FLAG) THEN
          OUTLINE = TOSTR;
        ELSE
          OUTLINE = INLINE;
        CALL M$WRITE(TO_LO);
        REC_IS_NOT_PRINTED = '0'B;
END PRINT_REC;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
 
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
/*M* Loads embedded sequences into memory. */
LOAD_SEQUENCE: PROC;
 
        IF (SUBSTR(TOSTR,0,1) = '.') THEN
        DO;
           I = 6;
           DO WHILE ( SUBSTR(TOSTR,I,1) ~= '''' );
              I = I + 1;
              END;
           SEARCH_TABLE(ASCBIN(SUBSTR(TOSTR,6,1))) = 1;
           DO SELECT(SUBSTR(TOSTR,6,1));
             SELECT('\' , '(' , ')' , '[' , ']' , '{' , '}' ,
                    '-' , ',' , ';' , ':' , '!' , '?' , '.' );
               SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE = '1'B;
           END;
           SEQUENCE_STUFF.C = SEQUENCE_STUFF.C + 1;
           SEQUENCE_STUFF.SEQUENCE(SEQUENCE_STUFF.C) = SUBSTR(TOSTR,6,I-6);
           SEQUENCE_STUFF.SEQLNGTH(SEQUENCE_STUFF.C) = I - 6;
           END;
        ELSE
        DO;
           I = 8;
           DO WHILE ( SUBSTR(TOSTR,I,1) ~= '''' );
              I = I + 1;
              END;
           SEARCH_TABLE(ASCBIN(SUBSTR(TOSTR,8,1))) = 1;
           DO SELECT(SUBSTR(TOSTR,8,1));
             SELECT('\' , '(' , ')' , '[' , ']' , '{' , '}' ,
                    '-' , ',' , ';' , ':' , '!' , '?' , '.' );
               SEQUENCE_STUFF.RESERVE_CHAR_STARTS_SEQUENCE = '1'B;
           END;
           SEQUENCE_STUFF.C = SEQUENCE_STUFF.C + 1;
           SEQUENCE_STUFF.SEQUENCE(SEQUENCE_STUFF.C) = SUBSTR(TOSTR,8,I-8);
           SEQUENCE_STUFF.SEQLNGTH(SEQUENCE_STUFF.C) = I - 8;
           END;
END LOAD_SEQUENCE;
/* /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ */
END PERCH;
