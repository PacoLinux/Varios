/*
 
********************************************************************************
*                                                                              *
*                 Copyright (c) 1986-1990, Gregory J. Smith                    *
*                           Bucknell University                                *
*                                                                              *
********************************************************************************
 
      Programmers   :  Gregory J. Smith
                    :  Chris Weber
      Date started  :  September 19, 1985.
      Date finished :  April 11, 1986.
      Date updated  :  June 28, 1990.
 
      This program is a screen editor based on the screen editor used by
      TURBO Pascal.  It uses CP6's windowing capabilities within the FEP
      to provide a screen editing window on any CP6 terminal with cursor
      positioning defined within its profile.
 
      This editor was written as a Senior Design project for Bucknell
      University's Computer Science department and has been turned over
      to the Bucknell Computer Services Systems department for
      maintenance and upgrades.
 
*/
 
PULSE: Proc Main;
 
/*  Copyright data  */
 
      Dcl Copyright Char(0) Static Init
         ('Copyright, (c) Gregory J. Smith, Bucknell University, 1986-1990');
 
/*  Include files  */
 
%Include CP_6;
%Include CP_6_SUBS;
%Include B$JIT;
%Include FM$FIT;
%Include B_ERRORS_C;
%Include XUG_ENTRY;
%Include XUF_ENTRY;
%Include XU_FORMAT_C;
%Include XU_MACRO_C;
%Include XUW_MACRO_C;
%Include XU_PERR_C;
%Include B$TABLES_C;
%Include B_SEGIDS_C;
%Include B$ROSEG;
%Include PULSE_C61;
%Include PULSE_C62;
 
/* ENTRY declarations for YE routines */
 
Dcl  YEM$ErrMsg Entry(8) AltRet;
Dcl  YEG$ErrCode Entry(2);
 
/* ENTRY declarations for YM routines */
 
Dcl  YMU$Unique Entry(1);
 
/* ENTRY declarations for YX routines */
 
Dcl YXH$GoHome Entry;
Dcl YXB$ResetBold Entry;
Dcl YXB$SetBold Entry;
Dcl YXB$SetNorm Entry;
Dcl YBB$Bell Entry;
Dcl YII$Imp Entry;
Dcl YPT$WindowOptions Entry(1) AltRet;
Dcl YPC$CheckProfile Entry;
Dcl XTabsCommand Entry(1);
Dcl XTypeCommand Entry(1);
Dcl IndexR Entry(4) AltRet Conv(0);
Dcl YYY$MakeFid Entry(2);
Dcl YYY$FillIn Entry(1);
Dcl YCF$ClearFile Entry Altret;
Dcl YCF$CopyFile Entry Altret;
Dcl YWS$DownString Entry(3);
Dcl YSC$SaveContext Entry Altret;
Dcl SetArs Entry;
Dcl SetErrCode Entry;
Dcl M$WriteUC03 Entry(3) Altret;
Dcl YPN$PromptName Entry(1) Altret;
Dcl M$EraseEdit Entry Altret;
Dcl CheckIfEmpty Entry Altret;
Dcl PutAwayFiles Entry;
Dcl AltRetError Entry;
Dcl SqueezeBuffers Entry;
Dcl SpreadBuffers Entry;
Dcl SaveFileQuery Entry(1) Altret;
Dcl OverWriteInquireAndSetup Entry(2) Altret;
Dcl SaveWorkFile Entry(5);
Dcl YDW$DeleteFile Entry(1) Altret;
 
%B$Sr_Non_Blank;     /*  search table for non-blank characters  */
%B$Sr_Non_Dec;       /*  search table for non-decimal characters  */
%B$Xl_Upper;         /*  translation table for lower- to upper-case  */
 
%SUB Forever = "While ('1'B)";
 
/*  Formatter  */
 
%F_FDS ( NAME = FDSVFC,
         DVFC = 'a',
          DCB = M$Window,
          BUF = FmtBuf,
      STCLASS = STATIC );
  
%F_FDS ( NAME = FDS3,
         DVFC = ' ',
          BUF = VersionLine,
      STCLASS = STATIC );
 
%F_FDS ( NAME = FDS4,
          DCB = M$UC,
          BUF = FmtBuf,
      STCLASS = STATIC );
 
Dcl VersionLine Char( 30 ) Static Unal;
Dcl PleaseWaitFormat Char(0) Constant Init('** Creating workfile.  Please wait.');
Dcl PleaseWait3Format Char(0) Constant Init('** Saving a copy.  Please wait.');
Dcl EditKeyformat Char( 0 ) constant init('%D.%3ZD  @%D');
Dcl SequenKeyFormat Char(0) constant init('%D  @%D');
Dcl SettingsFormat Char(0) constant init(
'WordWrap=%D,%<>A%N(,HScroll%)%N(,Strip%)%N(,ReadOnly%),%<>A%N(,TextEdit%)%N(,RcrWrap%)%N(,EasyAppend%)' );
Dcl BufferFormat Char(0) constant init(' %1A%D %7-%A  %<>A');
Dcl Buffer1Format Char(0) constant init(' %1A %7-%A  %<>A');
Dcl ThisBufferFormat Char(0) constant init(' => %7-%A  %<>A');
Dcl DeleteBufferFormat Char(0) constant init( 'Delete %<>A? (YES/NO) ' );
Dcl DeleteWorkFormat Char(0) constant init( 'Delete work copy of %<>A? (YES/NO) ' );
Dcl WorkFileFormat Char(0) constant init( 'Transform work file %<>A? (YES/NO) ' );
Dcl CrptFileFormat Char(0) constant init( 'Enter encryption seed for file %<>A  ' );
 
/*  Version stuff  */
 
Dcl VersionFormat Char(0) Constant Init('   PULSE %<>A    ');
 
/*  Memory Management for Buffers  */
 
%FPT_GDS ( COMMON = NO,
          SEGSIZE = 1024,
          RESULTS = ZAP,
             FPTN = GDS );
 
  %VLP_VECTOR ( FPTN = ZAP,
               SEGID = %DS4SID );
 
Dcl B$DS4$ Ptr SymRef;
Dcl B$ROS$ Ptr SymRef;
 
/*  Break control  */
 
%FPT_INT (FPTN = SetBreakControl,
        UENTRY = YBG$Break);
 
Dcl YBG$Break Entry Async;
 
/*  Parsing  */
 
%XUG_INIT ( ALWAYS_SET_PROMPT = YES, NAME = XUG_INIT2, SYNTAX = NO, COMMANDS = NO, GOODCMD = NO,
            Inhibit_Output = YES, Abort = Resume, WSeg = 5, PCB = P_PCB );
 
%XUG_GETCMD ( NAME = Xug_GetCmd2, NODES = Confirm, INDCB = M$Window );
 
%XUG_GETCMD ( NAME = Xug_GetCmd3, NODES = CrptNode, INDCB = M$Window );
 
%XUG_INIT ( NAME = Xug_InitIn, SYNTAX = NO, COMMANDS = NO, PCB = P_PCB,
            Abort=Resume,WSeg=5,BrkMsg=SetBreakPrompt,Echo=NEVER_ECHO);
 
%XUG_GETCMD ( NAME = Xug_Input, INDCB = M$ME, NODES = LMOptions );
 
%XUG_INIT ( SYNTAX = YES, COMMANDS = YES, GOODCMD = YES, Abort = Resume,
            ALWAYS_SET_PROMPT = YES, WSeg = 8, PCB = P_PCB, BrkMsg = SetBreakPrompt );
 
%XUG_GETCMD ( NODES = CommandWindow, OUTDCB = M$Window, INDCB = M$Window,
              DCB_PARAM = M$Window, DCB2_PARAM = M$Window );
 
%XUG_GETCMD ( NODES = Find, OUTDCB = M$Com, DCB_PARAM = M$Com,
              DCB2_PARAM = M$Com, NAME = Xug_Find );
 
%XUG_GETCMD ( NODES = Replace, OUTDCB = M$Com, DCB_PARAM = M$Com,
              DCB2_PARAM = M$Com, NAME = Xug_Replace );
 
%PARSE$OUT  ( NAME = OUT, STCLASS = "BASED(CMD$)" );
%PARSE$SYM  ( NAME = SYM, STCLASS = "BASED(CMD$)" );
 
Dcl B$JIT$ Ptr SymRef;
Dcl CMD$ Ptr;
Dcl CommandWindow SBin SymRef;
Dcl Confirm SBin SymRef;
Dcl LMOptions SBin SymRef;
Dcl CrptNode SBin SymRef;
Dcl Find SBin SymRef;
Dcl Replace SBin SymRef;
 
Dcl ExLength SBin Static;
Dcl Examine$ Ptr;
Dcl OptionBuf Char(30) CAligned Based;
Dcl Prompt Char(0) Constant Init('>');
Dcl PromptBlank Char(0) Constant Init(' ');
 
/*  FPTs  */
 
%FPT_TRAP ( FPTN = TrapControl,
             PTC = VLP_PTC,
          ERRORS = GETOUT,
         COMMAND = TRAP,
        HARDWARE = ABORT,
             IPR = TRAP,
          LOCKUP = TRAP,
          MEMORY = TRAP,
    MISSING_PAGE = TRAP,
     MISSING_SEG = TRAP,
      SECURITY_1 = TRAP,
      SECURITY_2 = TRAP,
         RESTORE = NO,
         STCLASS = STATIC );
 
%VLP_PTC( STCLASS = STATIC );
 
%FPT_XCON ( FPTN = ExitControl,
           PXCON = PrevXCon,
          UENTRY = GetOut );
 
Dcl GetOut Entry;
Dcl Resume Entry;
Dcl SetBreakPrompt Entry;
Dcl PrevXCon UBin Word Static WAligned;
 
/*
      More FPTs
*/
 
%FPT_UNFID (FPTN = GetFid,
             DCB = M$SI,
         STCLASS = STATIC,
         TEXTFID = Fid );
 
%FPT_UNFID (FPTN = GetWorkFid,
             DCB = M$Block,
         STCLASS = STATIC,
         TEXTFID = Fid );
 
%FPT_FID  ( FPTN = BlockFid,
         STCLASS = STATIC,
         TEXTFID = ComLine,
              SN = VLPSNB,
            ACCT = VLPAcctB,
            NAME = VLPNameB,
            PASS = VLPPassB,
             WSN = VLPWSNB,
             RES = ResJunk,
             ASN = AsnJunk,
         RESULTS = VLRFidRes );
 
%FPT_PFIL ( FPTN = PosEOF,
             DCB = M$SI,
             BOF = NO );
 
%FPT_DEVICE(FPTN = FPTDeviceMarker,
             HDR = EOF,
             DCB = M$Edit );
 
%FPT_DELREC(FPTN = DeleteSI,   /* FPT for M$DELREC, to delete */
             DCB = M$SI,       /* a record deleted from the   */
             KEY = DelKey,     /* source.                     */
            LKEY = DelKey );
 
%FPT_DELREC(FPTN = DelUC02,    /* FPT for M$DELREC, to delete */
             DCB = M$Edit,     /* a record from the screen.   */
             KEY = UCKey,
            LKEY = UCKey );
 
%FPT_DELREC(FPTN = DelEdit,
             DCB = M$Edit,
             KEY = DelUCKey,
            LKEY = DelUCKey );
 
%FPT_DELREC(FPTN = DelEditRange,
             DCB = M$Edit,
             KEY = DelUCKey,
            LKEY = DelUCKeyEnd );
 
%FPT_PRECORD(FPTN= PRecSI,     /* Used to position the input file  */
             DCB = M$SI,       /* in order to get more records for */
            KEYS = YES,        /* the FEP                          */
            KEYR = YES,
             KEY = SIKey );
 
%FPT_PRECORD(FPTN= PRecSINoKey,/* Used to position the input file  */
             DCB = M$SI,       /* in order to get more records for */
            KEYS = NO,         /* the FEP */
            KEYR = YES,
             KEY = SIKey );
 
%FPT_PRECORD(FPTN= PRecSIBack2,/* Used to position the input file  */
             DCB = M$SI,       /* back 2 records                   */
            KEYS = NO,
            KEYR = YES,
               N = -2,
             KEY = SIKey );
 
%FPT_PRECORD(FPTN= PRecSIBack1,/* Used to position the input file  */
             DCB = M$SI,       /* back 1 record                    */
            KEYS = NO,
            KEYR = YES,
               N = -1,
             KEY = SIKey );
 
%FPT_PRECORD(FPTN= GetLastKey, /* Used after positioning the input  */
             DCB = M$SI,       /* file to the end in order to get   */
            KEYS = NO,         /* the key of the last record        */
            KEYR = YES,
               N = -1,
             KEY = LastKey );
 
%FPT_OPEN ( FPTN = OpenUC02,   /*  the editing window  */
             DCB = M$Edit,
/*           RES = 'UC02',   is done in the Initialize procedure  */
/*         NRECS = CacheSize is done in the Initialize procedure  */
            KEYL = 4,
             ASN = DEVICE,
             ORG = SE,         /*  screen edit mode  */
          WINDOW = VLPEditWindow );
 
%FPT_OPEN ( FPTN = OpenUC03,   /*  command window  */
             DCB = M$Com,
/*           RES = 'UC03', is done in the Initialize procedure  */
             ASN = DEVICE,
             ORG = X364,
            DVFC = '@',
          WINDOW = VLPComWindow );
 
%FPT_OPEN ( FPTN = OpenUC05,
             DCB = M$Window,
/*           RES = 'UC05', is done in the Initialize procedure  */
             ASN = DEVICE,
             ORG = TERMINAL,
          WINDOW = VLPCommandWindow );
 
%FPT_OPEN ( FPTN = OpenSIForceDcbTest, /* make the DCB fully filled in */
             DCB = M$SI,               /* at invocation */
             FUN = IN,
            TEST = YES );
 
%FPT_OPEN ( FPTN = EditFidFile,
             DCB = M$SI,
             ASN = FILE,
             ACS = DIRECT,
           SCRUB = YES,
          FPARAM = FileAttr,
             FUN = UPDATE,
            ACCT = VLPSIAcct,
            NAME = VLPSIName,
              SN = VLPSISN );
 
%FPT_OPEN ( FPTN = TestDCB,
             DCB = M$SI,
             FUN = IN,
           SCRUB = YES,
            TEST = YES,
            ACCT = VLPSIAcct,
            NAME = VLPSIName,
              SN = VLPSISN,
            PASS = VLPSIPass );
 
%FPT_OPEN ( FPTN = SetWork,      /*  Work file  */
             DCB = M$SI,
             ASN = FILE,
           SCRUB = YES,
          SETDCB = YES,
            NAME = StarUnique );
 
%FPT_OPEN ( FPTN = OpenSIIn,     /* the input file begin edited */
             DCB = M$SI,
          FPARAM = FileAttr,
             FUN = IN,
         STCLASS = STATIC,
             ASN = FILE,
             ACS = SEQUEN );
 
%FPT_OPEN ( FPTN = OpenContextIn,
             DCB = M$OU,
             FUN = IN,
           SCRUB = YES,
              SN = VLPOUSN,
            NAME = VLPOUName,
            ACCT = VLPOUAcct,
            PASS = VLPOUPass,
         STCLASS = STATIC,
             ASN = FILE,
             CTG = YES,
             ACS = DIRECT );
 
%FPT_OPEN ( FPTN = OpenOUWork,
             DCB = M$OU, TYPE = 'SE',
             FUN = CREATE, ORG = KEYED,
           SCRUB = YES,
         IFPARAM = FileAttr,
            NAME = WorkFileName,
         STCLASS = STATIC,
             ASN = FILE,
             CTG = NO,
           EXIST = NEWFILE,
             ACS = DIRECT );
 
%FPT_OPEN ( FPTN = OpenBlock,     /* Block File */
             DCB = M$Block,
             FUN = CREATE, ORG = KEYED, TYPE='SE',
           SCRUB = YES,
              SN = VLPSNB,
            NAME = VLPNameB,
            ACCT = VLPAcctB,
            PASS = VLPPassB,
         STCLASS = STATIC,
             ASN = FILE,
             CTG = NO,
           EXIST = ERROR,
             ACS = DIRECT );
 
%FPT_OPEN ( FPTN = OpenBlockIn,     /*  block file  */
             DCB = M$Block,
             FUN = IN, ORG = CONSEC,
           SCRUB = YES,
              SN = VLPSNB,
            NAME = VLPNameB,
            ACCT = VLPAcctB,
            PASS = VLPPassB,
         STCLASS = STATIC,
             ASN = FILE,
             ACS = SEQUEN );
 
%FPT_OPEN ( FPTN = OpenStarUnique,
             DCB = M$Block,
             FUN = CREATE,
             ORG = CONSEC,
             ASN = FILE,
             ACS = SEQUEN,
           EXIST = ERROR,
         STCLASS = STATIC,
           SCRUB = YES,
            NAME = StarUnique,
             CTG = NO );
 
%FPT_OPEN ( FPTN = OpenStarUniqueK,
             DCB = M$Block, TYPE = 'SE',
             FUN = CREATE,
             ORG = KEYED,
             ASN = FILE,
             ACS = DIRECT,
           SCRUB = YES,
         IFPARAM = FileAttr,
           EXIST = ERROR,
         STCLASS = STATIC,
            NAME = StarUnique,
             CTG = NO );
 
%FPT_OPEN ( FPTN = OpenStarUniqueK2,
             DCB = M$Block2, TYPE = 'SE',
             FUN = CREATE,
             ORG = KEYED,
             ASN = FILE,
             ACS = DIRECT,
           SCRUB = YES,
         IFPARAM = FileAttr,
           EXIST = ERROR,
         STCLASS = STATIC,
            NAME = StarUnique,
             CTG = NO );
 
%FPT_OPEN ( FPTN = DeleteSAndM,
             DCB = M$Block,
             FUN = UPDATE,
             ASN = FILE,
           SCRUB = YES,
          DELETE = YES,
            NAME = SAndMFid,
         STCLASS = STATIC );
 
%FPT_EOM  ( FPTN = EOMUC02,    /* activation chars for Edit window */
             DCB = M$Edit,
        EOMTABLE = VLPEomTableUC02 );
 
%FPT_EOM  ( FPTN = EOMUC02All, /* activation chars for Edit window */
             DCB = M$Edit,
        EOMTABLE = VLPEomTableUC02All );
 
%FPT_EOM  ( FPTN = EOMUC03Normal, /* activation chars for Bar window */
             DCB = M$Com,
        EOMTABLE = VLPEomTableUC03Normal );
 
%FPT_CLOSE( FPTN = CloseStarUniqueDelete,
         STCLASS = STATIC,
             DCB = M$Block,
            DISP = RELEASE );
 
%FPT_CLOSE( FPTN = CloseStarUniqueDelete2,
         STCLASS = STATIC,
             DCB = M$Block2,
            DISP = RELEASE );
 
%FPT_CLOSE( FPTN = CloseOURelease, /* Abort and delete file */
            DISP = RELEASE,
         STCLASS = STATIC,
             DCB = M$OU );
 
%FPT_CLOSE( FPTN = CloseUC02,  /* Close the UC02 window */
         STCLASS = STATIC,
             DCB = M$Edit );
 
%FPT_CLOSE( FPTN = CloseUC03,  /* Close the UC03 window */
         STCLASS = STATIC,
             DCB = M$Com );
 
%FPT_READ ( FPTN = ReadSIByKey,/* Read from the Edit file */
             DCB = M$SI,
             BUF = SILine,
         STCLASS = STATIC,
             KEY = SIKey,
            KEYS = YES );
 
%FPT_READ ( FPTN = ReadUC04Char,  /* Read the command character */
             DCB = M$Com,
           TRANS = NO,
             BUF = ComChar,
         STCLASS = STATIC );
 
%FPT_READ ( FPTN = ReadUC03,   /* Read for extended commands */
             DCB = M$Com,
             BUF = Comline3,
         STCLASS = STATIC );
 
%FPT_READ ( FPTN = ReadContext,
             DCB = M$OU,
         STCLASS = STATIC,
            KEYS = NO );
 
%FPT_SINPUT(FPTN = SInputUC02,  /* for positioning the cursor */
             DCB = M$Edit,
             BUF = PositionKey,
       REREADPOS = 1,
         STCLASS = STATIC,
        POSITION = NO );
 
%FPT_SINPUT(FPTN = SInputUC05,  /* for setting escape D */
             DCB = M$Window,
             BUF = EscapeDBuf,
       REREADPOS = 0,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteUC02,   /* Write records to FEP */
             DCB = M$Edit,
             BUF = SILine,
         STCLASS = STATIC,
             KEY = UCKey,
              BP = YES );
 
%FPT_WRITE( FPTN = WriteUC03,   /* Write output to command window */
             DCB = M$Com,
              BP = YES,
             BUF = ComLine,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteUC04,
             DCB = M$Com,
              BP = YES,
             BUF = ComLine2,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteSI,     /* Write new records to Edit file */
             DCB = M$SI,
             BUF = UCLine,
         STCLASS = STATIC,
             KEY = SIKey,
         ONEWKEY = YES );
 
%FPT_TRUNC( FPTN = FlushSI,
             DCB = M$SI,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteStarUnique,
             DCB = M$Block,
             BUF = UniqueLine,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteStarUniqueK,
             KEY = BlockKey,
             DCB = M$Block,
             BUF = UniqueLine,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = WriteStarUniqueK2,
             KEY = BlockKey,
             DCB = M$Block2,
             BUF = UniqueLine,
         STCLASS = STATIC );
 
%FPT_WEOF ( FPTN = WEOFUC02,    /* Tell FEP no more records */
             DCB = M$Edit );
 
%FPT_TRMCTL(FPTN = NoScrollUC03,
             DCB = M$Com,
          TRMCTL = VLPNoScroll,
         VLPTYPE = TRMCTL );
 
%FPT_TRMCTL(FPTN = TrmCtlUC05,
             DCB = M$Window,
          TRMCTL = VLPUC05,
         VLPTYPE = TRMCTL );
 
%FPT_TRMCTL(FPTN = FPTEdtCtl,   /* Tell FEP scroll parameters */
             DCB = M$Edit,
          TRMCTL = VLPEdtCtl,
         VLPTYPE = EDTCTL );
 
%FPT_TRMCTL(FPTN = FPTTrmCtlInput,
             DCB = M$Com,
          TRMCTL = VLPTrmCtlInput,
         VLPTYPE = TRMCTL );
 
%FPT_TRMCTL(FPTN = FPTEcho,
             DCB = M$Com,
          TRMCTL = VLPEcho,
         VLPTYPE = TRMCTL );
 
%FPT_TRMCTL(FPTN = OriginalWindow,
             DCB = M$UC,
          TRMCTL = VLPOriginalWindow,
         VLPTYPE = WINDOW );
 
%FPT_TRMCTL(FPTN = CommandWindowSettings,
             DCB = M$Window,
          TRMCTL = VLPCommandWindowSettings,
         VLPTYPE = WINDOW );
 
%FPT_TRMATTR(FPTN= FPTTermAttr,
             DCB = M$UC,
         TRMATTR = VLPTermAttr );
 
%FPT_TRMATTR(FPTN= FPTReadOnly,
             DCB = M$Edit,
         TRMATTR = VLPReadOnly );
 
%FPT_TRMATTR(FPTN= FPTUpdate,
             DCB = M$Edit,
         TRMATTR = VLPUpdate );
 
%FPT_TRMATTR(FPTN= FPTCheckAttr,
             DCB = M$Edit,
         TRMATTR = VLPCheckAttr );
 
%FPT_GLINEATTR                  /* Get profile */
          ( FPTN = GetLine,
             DCB = M$UC,
        LINEATTR = VLPLineAttr );
 
%F$DCB;     /* DCB attributes */
 
%XUW_WILDCARD(FPTN=WildCompare,
       WILD_CHAR = "%BinAsc( 1 )",
         STCLASS = STATIC );
 
%XUW_ENTRIES;
 
/*  VLPs  */
 
%VLP_TRMATTR( FPTN = VLPReadOnly,
            FCNTBL = 'SE2' );
 
%VLP_TRMATTR( FPTN = VLPUpdate,
            FCNTBL = 'SE1' );
 
%VLP_TRMATTR( FPTN = VLPCheckAttr );
 
%VLP_EOMTABLE( FPTN = VLPEomTableUC02,   /* EOM chars for Edit */
             VALUES = "16,61,64,32,0*12" );
 
%VLP_EOMTABLE( FPTN = VLPEomTableUC02All,/* EOM chars for Edit */
             VALUES = "255*16" );
 
%VLP_EOMTABLE( FPTN = VLPEomTableUC03Normal,   /* Normal EOM chars */
             VALUES = "0,36,0*14" );
 
%VLP_TRMCTL(FPTN = VLPNoScroll,
        PAGEHALT = NO,
        WRAPPAGE = YES,
          SCROLL = NO );
 
%VLP_TRMCTL(FPTN = VLPUC05,
         STCLASS = STATIC );
 
%VLP_TRMCTL(FPTN = VLPTrmCtlInput,
       DISPINPUT = NO );
 
%VLP_TRMCTL(FPTN = VLPEcho,
       DISPINPUT = YES );
 
%VLP_TRMATTR(FPTN= VLPTermAttr );
 
%VLP_EDTCTL(FPTN = VLPEdtCtl,    /* scroll and key parms */
      EASYAPPEND = YES,
         KEYINCR = 10000,
         KEYTYPE = BIN10,
         RCRWRAP = YES,    /* Real Screen editing! */
        TEXTEDIT = YES,
        VSMARGIN = 5,      /* Scroll margin */
         VSSHIFT = 1 );    /* Scroll how many */
 
%VLP_ERRCODE( FPTN = RcvrErrCode );
 
%VLP_ERRCODE( FPTN = PassErrCode );
 
%VLP_ERRCODE( FPTN = YYY_ErrCode, FCG=YY, MID=Y, MON='0'B, SEV=0 );
 
%VLP_NAME ( FPTN = WorkFileName,
             LEN = 31 );
 
%VLP_SN   ( FPTN = VLPSNB );
%VLP_NAME ( FPTN = VLPNameB );
%VLP_ACCT ( FPTN = VLPAcctB );
%VLP_PASS ( FPTN = VLPPassB );
%VLP_WSN  ( FPTN = VLPWSNB );
 
%VLP_WINDOW(FPTN = VLPEditWindow, /* description of the editing window */
        POSITION = BOTTOM, BTMBRDR = NO, TOPBRDR = NO,
         FWINDOW = 'UC01', RHTBRDR = NO, LFTBRDR = NO,
          LENGTH = -1 );
 
%VLP_WINDOW(FPTN = VLPComWindow,  /* description of the command window */
        POSITION = TOP,
         FWINDOW = 'UC02',
          LENGTH = 2 );   /* specify the length as being 2 lines long */
 
%VLP_WINDOW(FPTN = VLPCommandWindow,  /* description of the big command window */
         BTMBRDR = NO,
         TOPBRDR = YES,
         FWINDOW = 'UC02',
        POSITION = BOTTOM,
       MINLENGTH = 2,
       REMOVABLE = YES,
          LENGTH = .50,
        HBRDRCHR = '-' );
 
%VLP_WINDOW(FPTN = VLPCommandWindowSettings );
 
/*  DCLs  */
 
Dcl EscapeDLen UBin Static;
Dcl OULine     Char( %BufSize ) Static;
Dcl EscapeDBuf Char(   255    ) Static;
 
Dcl Crpt Bit(36) Static Unal;
Dcl 1 Spots (0:10) Static Unal,       /*  for marking a spot  */
    2 Column UBin Word Unal,
    2 Key,
      3 Len UBin(9) Init(0) Unal,
      3 Key UBin(27) Unal;
 
Dcl SpotsChars ReDef Spots Char(88);
                            /* 11 spots,2 word/spot,4 char/word */
 
Dcl 1 CurrentPos Static Unal, /*  for trashing extra blank line at end  */
    2 Column UBin Word Unal,
    2 Key,
      3 Len UBin(9) Init(3) Unal,
      3 Key UBin(27) Unal;
 
Dcl 1 Split Static,           /*  Info for splitting line  */
    2 Key,
        3 Len UBin(9)  Unal,
        3 Key UBin(27) Unal,
    2 Pos UBin Word Unal,
    2 Buf,
        3 Len UBin Unal,
        3 Line Char( %BufSize ) Unal;
 
Dcl 1 Block Static,      /*  Info marking the bounds of a block  */
    2 PosStart SBin Word Unal init(0),
    2 KeyStart,
        3 Len UBin(9) Unal init(0),
        3 Key UBin(27) Unal init(0),
    2 PosEnd SBin Word Unal init(0),
    2 KeyEnd,
        3 Len UBin(9) Unal init(0),
        3 Key UBin(27) Unal init(0);
 
Dcl Err# SBin Static;
Dcl Dcb# SBin Static;
 
Dcl 1 DelKey Static,      /* delete this key for edit file */
    2 Len UBin(9)  Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 BlockKey Static,
    2 Len UBin(9)  Unal,
    2 Key UBin(27) Unal;
 
Dcl DelUCKey UBin Word Static;
Dcl DelUCKeyEnd UBin Word Static;
Dcl PositionKey UBin Word Static; /* used for M$SInput */
Dcl 1 LastKey Static,             /* used for keeping track of the  */
    2 Len UBin(9) Unal Init(3),   /* last key in a file (and in the */
    2 Key UBin(27) Unal;          /* SEAM cache)                    */
 
Dcl FidField# UBin Static Init( %FidField );
Dcl OutField# UBin Static Init( %OutField );
Dcl ComField# UBin Static Init( %ComField );
 
/* Activation character stuff */
 
%Equ _C = BinASC(3);  /* ^C */
%Equ _K = BinASC(11); /* ^K */
%Equ _L = BinASC(12); /* ^L */
%Equ _O = BinASC(15); /* ^O */
%Equ _Q = BinASC(17); /* ^Q */
%Equ _Z = BinASC(26); /* ^Z */
 
%Equ  C = 0;  /* indices of ^x's within EOMChars */
%Equ  K = 1;
%Equ  L = 2;
%Equ  O = 3;
%Equ  Q = 4;
%Equ  Z = 5;
 
Dcl EOMChars Char(0) Constant Init (%Concat(_C, _K,_L,_O,_Q,_Z));
Dcl EOMCharX UBin Word;
 
/* Miscellaneous */
 
Dcl I SBin;
Dcl HowMany SBin;
Dcl CommandWindowSize UBin Half Static HAligned;
Dcl WordWrapClm# UBin Word WAligned;
Dcl AutoTabClm# UBin Word WAligned;
Dcl UpAttr Bit(18) Static HAligned;
Dcl WEOF Bit(1) Static Unal;  /* no more recs? */
Dcl NoWEOF Bit(1) Static Unal init( %False );    /* Don't do WEOF */
Dcl NoFile Bit(1) Static Unal init( %False );  /* any files open? */
Dcl TroubleFlag Bit(1) Static Unal init( %False );
Dcl AlreadyStarted Bit(1) Static Unal init( %False );  /* work file message */
Dcl StartingWithError Bit(1) Static Unal init( %False );  /* recovery */
Dcl DirectToCommandWindow Bit(1) Static Unal init( %False );
                            /* no file specified on command line */
 
Dcl MovingFlag Bit(1) Static Unal init( %False );
    /* don't change Currentpos in delete block */
Dcl WorkFlag Bit(1) Static Unal init( %False );  /* use work file? */
Dcl InputOnlyFlag Bit(1) Static Unal;    /*  read only mode  */
Dcl SequenFlag Bit(1) Static Unal;  /* Seq. file update mode */
Dcl WriteTheLineFlag Bit(1) Static Unal init ( %False );
Dcl DeleteFlag Bit(1) Static Unal Init( %False );  /* delete buffer being closed */
Dcl WordWrapping Bit(1) Static Unal Init( %False );
Dcl InsertMode Bit(1) Static Unal Init( %False );
Dcl ShoveFirst Bit(1) Static Unal Init( %False );
Dcl SE2Flag Bit(1) Static Unal Init( %False );  /* is SE2 a FcnTbl? */
Dcl JunkUBin1 UBin Static Unal;
Dcl JunkUBin2 UBin Static Unal;
Dcl JunkSBin1 SBin Static Unal;
Dcl JunkSBin2 SBin Static Unal;
Dcl RecordNumber# UBin Static Unal;
 
/* Remember... */
 
Dcl CallXCommand Remember Static;
 
/**/
 
Exeunt: Proc (Err#, Dcb#);
/*
      Procedure to handle internal error calls
*/
 
Dcl Err# SBin;
Dcl Dcb# SBin;
 
 
If ( Err# = %E$FileTooBig )
 then do;
   YYY_ErrCode.Err# = %E$PulseAbort;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,4,0 );
   Call YXB$ResetBold;
   Call PutAwayFiles;
 end;  /*  if  */
      
If RestoreOK
 then do;
   If M$Edit$ -> F$Dcb.FCD#
    then
      Call M$Close( CloseUC05 ) WhenAltReturn do; end;
 
   Call Xug$Close_Dcbs( Xug_Close );
   Call M$STrmCtl( OriginalTerminalSettings ) WhenAltReturn do; end;
 end;
 
YYY_ErrCode.Err# = Err#;
Call YEM$ErrMsg(YYY_ErrCode, DCB#,,,,,4);
Call M$Exit;
 
End Exeunt;
 
/**/
 
SetFcnTbl: Proc;
/*
      Procedure to Set the FcnTbl to SE1 or SE2, depending on the
      InputOnlyFlag.
*/
 
   If Not SE2Flag
    Then  /*  don't bother changing the FcnTbl  */
      Return;
 
   If InputOnlyFlag
    Then
      Call M$STrmAttr( FPTReadOnly ) AltRet ( boom );
    Else
      Call M$STrmAttr( FPTUpdate ) AltRet ( boom );
 
   Return;
 
boom:
   Call AltRetError;
   Return;
 
End SetFcnTbl;
 
/**/
 
M$OpenSI: Proc ( FPT ) AltRet;
/*
      Central SI Opening procedure
*/
 
%FPT_OPEN( FPTN=FPT, STCLASS=PARAM );
 
   Brokenflag = %False;
   Unsafeflag = %True;
 
   Call M$Open( FPT ) AltRet ( NoDice );
   RecordNumber# = 0;
 
   Unsafeflag = %False;
 
   If BrokenFlag
    Then
      Call Resume;
 
   Return;
 
NoDice:
   AltReturn;
 
End M$OpenSI;
 
/**/
 
M$CloseSI: Proc ( FPT ) AltRet;
/*
      Central SI Closing procedure
*/
 
%FPT_CLOSE( FPTN=FPT, STCLASS=PARAM );
 
   Call M$Close( FPT ) AltRet ( NoDice );
 
   Return;
 
NoDice:
   AltReturn;
 
End M$CloseSI;
 
/**/ 
 
M$PFilSI: Proc ( FPT ) AltRet;
/*
      Central SI PFil procedure
*/
 
%FPT_PFil( FPTN=FPT, STCLASS=PARAM );
 
   Brokenflag = %False;
   Unsafeflag = %True;
 
   Call M$PFil( FPT ) AltRet ( NoDice );
 
   If FPT.V.BOF#
    Then
      RecordNumber# = 0;
    Else
      RecordNumber# = M$SI$ -> F$Dcb.NRecs#;
 
   Unsafeflag = %False;
   If BrokenFlag
    Then
      Call Resume;
 
   Return;
 
NoDice:
   AltReturn;
 
End M$PFilSI;
 
/**/
  
M$WriteSI: Proc (FPT) AltRet;
/*
      Central Writing procedure for M$SI
*/
 
Dcl JunkLine Char(%BufSize) Static;
 
%FPT_WRITE( FPTN=FPT, STCLASS=PARAM );
 
%FPT_WRITE( FPTN=Local, STCLASS=STATIC );
 
%FPT_READ( FPTN=Read, DCB=M$SI, KEY=SIKey, BUF=JunkLine, STCLASS=STATIC,
           KEYS=YES );
 
/*
   if we're in this routine, PULSE thinks the record (and the file) have
   been updated.
*/
   Buffers.Status.Changed( CurrentBuffer# ) = %True;
 
   If SequenFlag
    Then do;
      Local = FPT;
      If SIKey.Key <= M$SI$ -> F$Dcb.NRecs#
       Then do;
         Call M$ReadSI( Read )
          WhenAltReturn do;
            Goto boom;
          End;
 
         If M$SI$ -> F$Dcb.Ars# > 0
          Then
            Local.Buf_.Bound = M$SI$ -> F$Dcb.Ars# - 1;
          Else
            Local.Buf_ = Vector( Nil );
 
         Local.V.ReWrite# = %True;
         Call M$PRecordSI( PRecSIBack1 ) AltRet ( boom );
       End;  /*  if good replacement  */
       Else do;
         Call M$DelRec( DelUC02 ) WhenAltReturn do; end;  /* have to use my
                                                             own key  */
         SIKey.Key = M$SI$ -> F$Dcb.NRecs# + 1;
         If M$Edit$ -> F$Dcb.Ars# > 0
          Then
            Local.Buf_.Bound = M$Edit$ -> F$Dcb.Ars# - 1;
          Else Do;
            UCLine = ' ';
            Local.Buf_.Bound = 0;
          End;  /*  Do  */
  
         Call M$PFilSI( PosEOF ) Altret ( boom );
         WriteUC02.Buf_.Bound = Local.Buf_.Bound;
         SILine = UCLine;
         UCKey = SIKey.Key;
         Call M$WriteUC02 Altret ( boom );
       End;  /*  else  */
 
      Local.Key_ = Vector( Nil );
      Local.V_ = Vector( Local.V );
 
      Brokenflag = %False;
      Unsafeflag = %True;
 
      Call M$Write( Local ) AltRet ( boom );
      RecordNumber# = RecordNumber# + 1;
 
      Unsafeflag = %False;
      If BrokenFlag
       Then
         Call Resume;
 
      If WriteTheLineFlag and ((Local.Buf_.Bound + 1) ~= M$Edit$->F$Dcb.Ars#)
       Then do;
         WriteUC02.Buf_.Bound = Local.Buf_.Bound;
         SILine = UCLine;
         Call M$WriteUC02 Altret ( boom );
         YYY_ErrCode.Err# = %E$RecordTruncated;
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0 );
         Call YBB$Bell;
         Call YXB$ResetBold;
       End;  /*  if writetheline called us  */
 
    End;  /*  if sequen  */
    Else
      Call M$Write( FPT ) Altret ( boom );
 
   Return;
 
boom:
   AltReturn;
 
End M$WriteSI;
 
/**/
 
M$ReadSI: Proc (FPT) AltRet;
/*
      Central routine to Read M$SI
*/
 
%FPT_READ( FPTN=FPT, STCLASS=PARAM );
 
%FPT_READ( FPTN=Local, STCLASS=STATIC );
 
%FPT_PRECORD( FPTN=PRec, STCLASS=STATIC, DCB=M$SI, KEYS=NO, KEYR=NO );
 
   If SequenFlag
    Then do;
      If FPT.V.KeyS#
       Then do;
         PRec.V.N# = SIKey.Key - RecordNumber# - 1;
         Call M$PRecordSI( PRec ) AltRet ( boom );
       End;
 
      Local = FPT;
      Local.Key_ = Vector( Nil );
      Local.V.KeyS# = %False;
      Local.V.KeyR# = %False;
      Local.V_ = Vector( Local.V );
 
      Brokenflag = %False;
      Unsafeflag = %True;
 
      Call M$Read( Local ) AltRet ( boom );
      RecordNumber# = RecordNumber# + 1;
      If FPT.V.KeyR#
       Then
         SIKey.Key = RecordNumber#;
 
      Unsafeflag = %False;
      If BrokenFlag
       Then
         Call Resume;
 
    End;
    Else
      Call M$Read( FPT )
       WhenReturn do;
         If SIKey.Len ~= 3
          Then do;
            Call MakeAnnouncements;  /*  make sure the file name is up  */
            If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
             Then
               Call M$CloseSI( CloseSIDelete ) WhenAltReturn do; end;
             Else
               Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
 
            Call SqueezeBuffers;
            CurrentBuffer# = CurrentBuffer# - 1;
            If CurrentBuffer# < 0 and Buffers# > 0
             Then
               CurrentBuffer# = Buffers# + CurrentBuffer#;
 
            YYY_ErrCode.Err# = %E$NotEDITKeys;
            RcvrErrCode = YYY_ErrCode;
            UnWind to CallXCommand;
          End;  /*  if  */
       End;  /*  WhenReturn  */
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# = %E$BadVect1
          Then do;
            Call MakeAnnouncements;  /*  make sure the file name is up  */
            If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
             Then
               Call M$CloseSI( CloseSIDelete ) WhenAltReturn do; end;
             Else
               Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
 
            Call SqueezeBuffers;
            CurrentBuffer# = CurrentBuffer# - 1;
            If CurrentBuffer# < 0 and Buffers# > 0
             Then
               CurrentBuffer# = Buffers# + CurrentBuffer#;
 
            YYY_ErrCode.Err# = %E$NotEDITKeys;
            RcvrErrCode = YYY_ErrCode;
            UnWind to CallXCommand;
          End;  /*  if  */
          Else
            Goto boom;
 
       End;  /*  WhenAltReturn  */
 
   Call ScanForMSBSet
    WhenReturn do;  /*  Oh, shit  */
      Call MakeAnnouncements;  /*  make sure the file name is up  */
      If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
       Then
         Call M$CloseSI( CloseSIDelete ) WhenAltReturn do; end;
       Else
         Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
 
      Call SqueezeBuffers;
      CurrentBuffer# = CurrentBuffer# - 1;
      If CurrentBuffer# < 0 and Buffers# > 0
       Then
         CurrentBuffer# = Buffers# + CurrentBuffer#;
 
      YYY_ErrCode.Err# = %E$EncryptBin;
      RcvrErrCode = YYY_ErrCode;
      UnWind to CallXCommand;
    End;
    WhenAltReturn do;  /*  no problem  */
    End;
 
   Return;
 
boom:
   AltReturn;
 
End M$ReadSI;
 
/**/
 
ScanForMSBSet: Proc AltRet;
/*
      Scan the SILine by word and make sure that none of the high bits are
      set.  If they are, Return (saying "True").  Else, AltReturn (saying
      "False").  High bits set indicates trouble (i.e. encrypted record,
      binary record).
*/
 
Dcl I UBin;
 
Do I = 0 to ((M$SI$->F$Dcb.Ars# - 1)/4);
   If SILineBits(I) & '400400400400'O
    Then
      Return;
 
End;  /*  do I  */
 
AltReturn;
 
End ScanForMSBSet;
 
/**/
 
M$PRecordSI: Proc (FPT) AltRet;
/*
      Central PRecord routine for M$SI
*/
 
Dcl Factor SBin Word;
Dcl BofFirst SBin Word;
Dcl EofFirst SBin Word;
Dcl Directly SBin Word;
 
%FPT_PRECORD( FPTN=FPT, STCLASS=PARAM );
 
%FPT_PRECORD( FPTN=PRec, STCLASS=STATIC, DCB=M$SI, KEYS=NO, KEYR=NO );
 
   If SequenFlag
    Then do;
      Brokenflag = %False;
      Unsafeflag = %True;
      If FPT.V.KeyS#
       Then do;
         If M$SI$ -> F$Dcb.NRecs# > %ABigSequenFile
           Then do;
              BofFirst = SIKey.Key - 1;
              EofFirst = M$SI$ -> F$Dcb.NRecs# - SIKey.Key;
              Directly = SIKey.Key - RecordNumber#;
              If Directly < 0
               Then
                 Directly = (-1) * Directly;
 
              If (BofFirst<EofFirst) and (BofFirst<Directly)
               Then
                Call M$PFilSI( PosBOF ) Altret ( boom );
               Else
                If (EofFirst<BofFirst) and (EofFirst<Directly)
                 Then
                   Call M$PFilSI( PosEOF ) Altret ( boom );
 
           End;  /*  if a big file  */
 
         PRec.V.N# = SIKey.Key - RecordNumber# - 1;
         If PRec.V.N# < 0
          Then
            Factor = (-1);
          Else
            Factor = 1;
 
         Call M$PRecord( PRec )
          WhenAltReturn do;
            Call YEG$ErrCode( ErrCode );
            If (ErrCode.Err#~=%E$EOF) and (ErrCode.Err#~=%E$BOF)
             Then
               Goto boom;
          End;
 
         Factor = Factor * M$SI$ -> F$Dcb.Ars#;
         RecordNumber# = RecordNumber# + Factor;
 
       End; /* then */
 
      PRec.V.N# = FPT.V.N#;
      If PRec.V.N# < 0
       Then
         Factor = (-1);
       Else
         Factor = 1;
 
      If PRec.V.N# ~= 0
       Then do;
         Call M$PRecord( PRec ) AltRet ( boom );
         Factor = Factor * M$SI$ -> F$Dcb.Ars#;
         RecordNumber# = RecordNumber# + Factor;
       End;
 
/*
      Next read will Return RecordNumber# + Factor + 1, file pointer
      is just past RecordNumber# + Factor.  RecordNumber# is always
      1 less than the Rec Number of the next read, or equal to the
      record number of the last read or write.
*/
 
      If FPT.V.KeyR#
       Then
        If FPT.Key_.Key$ = Addr(SIKey)
         Then
          SIKey.Key = RecordNumber# + 1;
         Else
          LastKey.Key = RecordNumber# + 1;
 
      Unsafeflag = %False;
      If BrokenFlag
       Then
         Call Resume;
 
    End;  /*  if sequen  */
    Else
      Call M$PRecord( FPT ) Altret ( boom );
 
   Return;
 
boom:
   If SequenFlag
    Then do;
      Factor = Factor * M$SI$ -> F$Dcb.Ars#;
      RecordNumber# = RecordNumber# + Factor;
      If FPT.V.KeyR#
       Then
        If FPT.Key_.Key$ = Addr(SIKey)
         Then
          SIKey.Key = RecordNumber# + 1;
         Else
          LastKey.Key = RecordNumber# + 1;
 
      Unsafeflag = %False;
      If BrokenFlag
       Then
         Call Resume;
 
      AltReturn;
    End;
    Else
      AltReturn;
 
End M$PRecordSI; 
 
/**/
 
M$WriteUC02: Proc Altret;
/*
      Procedure to write records to the screen editing window.
*/
 
Call M$Write( WriteUC02 ) Altret ( boom );
Call UpdateCache;
 
Return;
 
Boom:
      AltReturn;
 
End M$WriteUC02;
 
/**/
 
M$ReadUC03: Proc( Len );
/*
      Procedure to read from the command field on the stats bar.
*/
 
Dcl Len UBin Word;
 
If FieldOrientedTerminal
 Then do;
   Call Concat( ComLine2, CSI, '1;11H' );
   WriteUC03Pos.Buf_.Bound = 6;
 End;  /*  if  */
 Else do;
   Call Concat( ComLine2, CSI, '1;11H', CSI, '7m' );
   WriteUC03Pos.Buf_.Bound = 10;
 End;
 
Call M$Write( WriteUC03Pos ) Altret ( boom );
 
ComLine3 = ' ';
Call M$Read( ReadUC03 )
   WhenReturn do;
      Len = M$Com$ -> F$Dcb.Ars#;
      ComLine = ComLine3;
   End;  /*  When Return  */
   WhenAltReturn do;
      Call AltretError;
   End;  /*  When Altret  */
 
Return;
 
boom:
   Call AltRetError;
   Return;
 
End M$ReadUC03;
 
/**/
 
UpdateCache: Proc;
/*
      Procedure to update the shadow cache with UCKey.
 
*/
Dcl x Sbin Word Static;
Dcl len Sbin Word Static;
Dcl Cirrus Char( %( 4 * CacheSize ) ) Static;
 
Call ProbeCache(x, UCKey)
  WhenAltReturn Do;        /* new key */
    If x > LastCacheEntry
      Then Do;           /* key falls beyond cache */
        If LastCacheEntry = MaxCacheIndex  /* make room for new entry */
          Then Do;
            SubStr (CacheStream, 0, AllBut4Bytes) =
                     SubStr (CacheStream, 4, AllBut4Bytes);
            x = MaxCacheIndex;
            End;
        End;
 
      Else If x < MaxCacheIndex  /* key falls before or within cache */
        Then                     /* make a hole for the new key */
          If ShoveFirst
           Then do;
            len = 4 * x;
            Substr (CacheStream, 0, len ) =
                               Substr( CacheStream, 4, len );  /*  4 * 1 = 4  */
            ShoveFirst = %False;  /*  reset it  */
            x = x - 1;
           end;
           else do;
            len = (LastCacheEntry - x + 1) * 4;
            If LastCacheEntry = MaxCacheIndex  /* have to shift off last */
              Then do;                         /* entry to make room     */
                len = len - 4;
                EOFinFEP = %False;  /*  if there, it's now shoved  */
                end;
 
            Cirrus = CacheStream;
            SubStr (CacheStream, 4 * (x + 1), len) =
                               SubStr (Cirrus, 4 * x, len);
           end;  /*  else  */
 
      Else If InsertMode And
                 Cache(MaxCacheIndex) = LastKey.Key
 
        Then Do;     /* don't push last record off the end */
          SubStr (CacheStream, 0, AllBut8Bytes) =
                   SubStr (CacheStream, 4, AllBut8Bytes);
          x = MaxCacheIndex - 1;
          End;
 
    Cache(x) = UCKey;
 
    If LastCacheEntry < MaxCacheIndex
      Then  /* increment upper bound */
        LastCacheEntry = LastCacheEntry + 1;
 
    End;  /* WhenAltReturn */
 
Return;
End UpdateCache;
 
/**/
 
FixUpShadowCache: Proc ( whichkey );
/*
      Internal shadow-cache error occurred.  This procedure will straighten
      out the mess...
*/
 
Dcl whichkey UBin Param;
Dcl column UBin Half;
 
   YYY_ErrCode.Err# = %E$CacheError;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Com ),,,,3,0 );
   Call YXB$ResetBold;
 
   Call M$EraseEdit Altret ( boom );
   column = 0;
   SIKey.Key = whichkey;
   Call Position( column );
   Return;
 
boom:
   Call AltRetError;
   Return;
 
End FixUpShadowCache;
 
/**/
 
DeleteKeyFromCache: Proc ( WhichKey );
/*
      Procedure to delete the specified key from the Shadow cache.
*/
Dcl WhichKey UBin Word;
Dcl x SBin Word Static;
Dcl len Sbin Word Static;
 
      Call ProbeCache (x, WhichKey)
        WhenAltReturn Do;   /* oops...key didn't exist in shadow cache */
          /* Call Exeunt (%E$CacheError); */
          Call FixUpShadowCache( WhichKey );
          Return;
          End;
 
      If x ~= LastCacheEntry
        Then Do;  /* squeeze key out of shadow cache */
          len = (LastCacheEntry - x) * 4;
          SubStr (CacheStream, 4 * x, len) =
                    SubStr (CacheStream, 4 * (x + 1), len);
          End;
 
      LastCacheEntry = LastCacheEntry - 1; 
 
      Return;
 
End DeleteKeyFromCache;
 
/**/
 
DeleteRangeFromCache: Proc (Key, LKey);
/*
      Procedure to delete a range of records in the shadow cache from Key to
      LKey.
*/
  Dcl  Key UBin;
  Dcl  LKey UBin;
 
  Dcl x1 SBin;
  Dcl x2 SBin;
  Dcl len UBin;
 
  If (LastCacheEntry < 0)
    Then   /* well, there doesn't appear to be anything to do */
      Return;
 
  Call ProbeCache (x1, Key);
  Call ProbeCache (x2, LKey)
    WhenAltReturn Do;
      x2 = x2 - 1;    /* push index back to get REAL last key in range */
      End;
 
  If x1 > x2
    Then      /* bad vibes - go away */
      Return;
 
  If x2 = LastCacheEntry
    Then
      LastCacheEntry = x1 - 1;
 
     Else Do;
       len = (LastCacheEntry - x2) * 4;
       SubStr (CacheStream, 4 * x1, len) =
               SubStr (CacheStream, 4 * (x2 + 1), len);
 
       LastCacheEntry = LastCacheEntry + x1 - x2 - 1;
       End;
 
  Return;
 
End DeleteRangeFromCache;
 
/**/
 
ProbeCache: Proc (x, WhichKey) Altret;
/*
      Procedure to probe the shadow cache for existence of UCKey
*/
 
Dcl x Sbin Word;
Dcl WhichKey UBin Word;
Dcl Lo Sbin Word;
Dcl Hi Sbin Word;
 
Lo = 0;
Hi = LastCacheEntry;
 
Do While Lo <= Hi;
      x = ( Lo + Hi ) / 2;
 
      If WhichKey = Cache( x ) then   /*  found it  */
         Return;
 
      If WhichKey < Cache( x ) then
         Hi = x - 1;
      else
         Lo = x + 1;
 
end;  /*  Do While  */
 
x = Lo;
AltReturn;
 
End ProbeCache;
 
/**/
 
YSG$GetRecords: Proc( NumOfRecs );
/*
      This procedure will determine how many records are needed for screen
      edit mode, and then go get them.
*/
 
Dcl I SBin;
Dcl NumOfRecs SBin;
 
HowMany = NumOfRecs;
SIKey.Len = 3;
WEOF = %False;
 
If HowMany > 0 Then Do;
      SIKey.Key = UCKey + 1;
      PRecSI.V.N# = 0;
      Call M$PRecordSI( PRecSI )
        WhenAltReturn Do; End;
 
Next: Do I = 1 to HowMany;
         Call M$ReadSI ( ReadSI )
          WhenAltReturn Do;
            Call SetErrCode;
            If ErrCode.Err# = %E$LD
             then
               Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), DcbNum( M$UC ),,,,3 );
             Else
               If ErrCode.Err# ~= %E$EOF
                Then
                  goto Boom;
 
            WEOF = %True;
            ShoveFirst = InsertMode & EOFinFEP & ( LastCacheEntry = MaxCacheIndex );
            EOFinFEP = %True;
            Exit Next;
          End;
 
         Call SetArs;
         If SIARS# > 0
          Then
            WriteUC02.BUF_.BOUND = SIARS# - 1;
          Else Do;
            SILine = ' ';
            WriteUC02.BUF_.BOUND = 0;
          End;  /*  Do  */
 
         UCKey = SIKey.Key;
         Call M$WriteUC02 Altret ( boom );
 
      End; /* Do I */
End; /* Do */
 
Else Do;
      PRecSI.V.N# = -1;
      SIKey.Key = UCKey;
      Call M$PRecordSI( PRecSI )
        WhenReturn Do;
          HowMany = -HowMany;  /*  make it positive  */
        End;  /*  When Return  */
        WhenAltReturn Do;
          Call SetErrCode;
          If ErrCode.Err# ~= %E$BOF
           Then
             Goto boom;
 
          WEOF = %True;
          HowMany = 0;
        End;  /*  When Altret  */
 
Last: Do I = 1 to HowMany;
         Call M$ReadSI ( ReadSI )
          WhenAltReturn do;
           Call SetErrCode;
           If ErrCode.Err# = %E$LD then
              Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), DcbNum( M$UC ),,,,3 );
           else
              Goto Boom;
          end;  /*  WhenAltReturn  */
 
         Call SetArs;
         If SIARS# > 0
          Then
            WriteUC02.Buf_.Bound = SIARS# - 1;
          Else Do;
            SILine = ' ';
            WriteUC02.Buf_.Bound = 0;
          End;  /*  Do  */
 
         UCKey = SIKey.Key;
         Call M$WriteUC02 Altret ( boom );
         Call M$PRecordSI( PRecSIBack2 )
          WhenAltReturn do;
            Call SetErrCode;
            If ErrCode.Err# ~= %E$BOF
             Then
               Goto boom;
 
            If I < HowMany
             Then
               WEOF = %True;
 
            Exit Last;
 
          End;  /*  When Altret  */
 
      End; /* Do I */
End; /* Else Do */
 
If WEOF And Not (NoWEOF)
  Then
    Call M$WEOF( WEOFUC02 ) Altret ( boom );
 
 
NoWEOF = %False;
Return;
 
boom:
      Call AltretError;
      Return;
 
End YSG$GetRecords;
 
/**/
 
YSD$DeleteRecord: Proc;
/*
      This procedure will delete the specified record Returned from the last
      M$Read.
*/
 
      Buffers.Status.Changed( CurrentBuffer# ) = %True;
      DelKey.Len = 3;
      DelKey.Key = UCKey;
      Call M$DelRec ( DeleteSI )
           WhenAltReturn Do;
             Call AltRetError;
           End;
 
      Call DeleteKeyFromCache( UCKey );
 
      If UCKey >= LastKey.Key
       then
         Call FigureOutLast;
 
Return;
 
End YSD$DeleteRecord;
 
/**/
 
YRS$Setup: Proc( Incr, SplitKey, LowerKey, UpperKey, BlockSize ) AltRet;
/*
   Procedure to setup for the rekey.  Returns the Increment to be used for the
   keying.  If YRS$Setup Returns, only rekey part of the file.  If YRS$Setup
   AltReturns, rekey the entire file to M$OU.
*/
 
%FPT_PFIL ( FPTN = PosBOFStarUnique,
             DCB = M$Block2,
             BOF = YES );
 
Dcl 1 SplitKey,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl UniqueName Char(6) CAligned;
Dcl Incr UBin;
Dcl BlockSize UBin;
Dcl Offset UBin;
Dcl NumRecsL UBin;
Dcl NumRecsU UBin;
Dcl RekeyLimit UBin;
Dcl MayReplace Bit(1) Static Unal;
Dcl 1 UpperKey,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 LowerKey,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
/* start procedure */
 
      If M$SI$ -> F$Dcb.FFlg.DelF#
       Then do;
         OpenOU.V.Oper.Test# = %True;  /* make sure we can replace the file */
         Call M$Open( OpenOU )
          WhenReturn do;
            RekeyLimit = M$SI$ -> F$Dcb.NRecs# / 4;
            MayReplace = %True;
          End;  /*  When Return  */
          WhenAltReturn do;
            RekeyLimit = %MaxSequenceNumber;
            MayReplace = %False;
          End;  /*  When Altret  */
 
         OpenOU.V.Oper.Test# = %False;  /* restore it */
       End;  /*  if  */
       Else do;
         RekeyLimit = %MaxSequenceNumber;
         MayReplace = %False;
       End;  /*  else  */
 
      If M$SI$ -> F$Dcb.Org# ~= %Keyed#
       Then do;  /* we must be in YKF$MakeItKeyed */
         If MayReplace
          Then
            Incr = 1000;
          Else do;
            Incr = 0;
            AltReturn;
          End;
 
         Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
         Call M$OpenSI( OpenSIIn ) Altret ( boom );
         Call M$Open( OpenOU ) Altret ( boom );
         AltReturn;  /* to force total rekey */
       End;  /*  if not a keyed file  */
 
      Offset = %RekeyOffset;
      SplitKey.Len = 3;
 
DoU:  Do Until Offset > RekeyLimit;
         SIKey = SplitKey;
         PRecSI.V.N# = -Offset;
         Call M$PRecord( PRecSI )
          WhenReturn do;
          End;  /*  When Return  */
          WhenAltReturn do;
            Call YEG$ErrCode( ErrCode );
            If (ErrCode.Err# ~= %E$BOF)
             Then
               Goto boom;
 
            SIKey.Len = 3;  /*  just in case  */
 
          End;
 
         NumRecsL = M$SI$ -> F$Dcb.Ars#;
         LowerKey = SIKey;
         SIKey = SplitKey;
         PRecSI.V.N# = Offset;
         Call M$PRecord( PRecSI )
          WhenReturn do;
            NumRecsU = M$SI$ -> F$Dcb.Ars#;
            If SIKey.Len = 0
             Then
               Goto EofTwo;  /* really just hit EOF When len is 0 on Return */
 
            UpperKey = SIKey;
            Incr = (UpperKey.Key - LowerKey.Key) / (NumRecsL + NumRecsU + BlockSize);
            If Incr >= 10
             Then
               Exit DoU;
 
          End;
          WhenAltReturn do;
            Call YEG$ErrCode( ErrCode );
            If (ErrCode.Err# ~= %E$EOF)
             Then
               Goto boom;
 
            NumRecsU = M$SI$ -> F$Dcb.Ars#;
EofTwo:     UpperKey = LastKey;
            Incr = (%MaxSequenceNumber - LowerKey.Key) / (NumRecsL + NumRecsU + BlockSize);
            If Incr > 1000
             Then
               Incr = 1000;
 
            Exit DoU;
          End;  /*  When Altret  */
 
         OffSet = OffSet + %RekeyOffset;
      End;  /*  do until  */
 
      If (Incr < 10) and MayReplace
       Then do;
         Incr = 1000;
         Call M$Close( CloseSI ) Altret ( boom );
         Call M$Open( OpenSIIn ) Altret ( boom );
 
         If WorkFlag
          Then
            Call M$Open( OpenOUWork ) Altret ( boom );
          Else
            Call M$Open ( OpenOU ) Altret ( boom );
 
         AltReturn;  /*  rekey the whole thing, yuck!  */
       End;  /*  if  */
       Else do;
Loop:    Call YMU$Unique( UniqueName );
         Call Concat( StarUnique.Name#, '*', UniqueName );
         StarUnique.L# = 7;
         Call M$Open( OpenStarUniqueK2 )
          WhenAltReturn do;
            Call YEG$ErrCode( ErrCode );
            If ErrCode.ERR# = %E$CreatErr
             then
               goto loop;
             else
               Call AltretError;
 
          End;  /*  When Altret  */
 
         SIKey = LowerKey;
         PRecSI.V.N# = 0;
         Call M$PRecord( PRecSI ) WhenAltReturn do; end;
         Do Until SIKey >= UpperKey;  /* When they are equal, we just did the last */
           Call M$Read( ReadSI ) Altret (EOF1);
           UniqueLine = SILine;
           BlockKey = SIKey;
           If M$SI$ -> F$Dcb.Ars# > 0
            Then
              WriteStarUniqueK2.Buf_.Bound = M$SI$ -> F$Dcb.Ars# - 1;
            Else do;
              WriteStarUniqueK2.Buf_.Bound = 0;
              UniqueLine = ' ';
            End;
 
           Call M$Write( WriteStarUniqueK2 ) Altret ( boom );
         End;  /*  do until  */
 
EOF1:    Call M$PFil( PosBOFStarUnique ) Altret ( boom );
         DelKeyStart = LowerKey;
         DelKeyEnd = UpperKey;
         Call M$DelRec( DeleteSIRange ) Altret ( boom );
         Return;  /*  only rekey part of the file  */
 
       End;  /*  else  */
 
boom:
   Call AltRetError;
   Return;
 
End YRS$Setup;
 
/**/
 
YRC$RekeyCache: Proc(SkipStart,SkipEnd,FirstKey,LastKey,NewStart,Incr) Altret;
/*
   Copy the shadow cache and rekey it to the FEP to avoid blasting
   the screen after a rekey.  This isn't exactly trivial.
*/
 
Dcl I UBin;
Dcl Incr UBin;
Dcl StartI SBin;
Dcl EndI SBin;
Dcl LastEntry SBin;
Dcl SkipMerged Bit(1) Unal;
Dcl DoneFlags (0:%MaxCacheIndex) Bit(1) Unal;
Dcl TrueFlags (0:%MaxCacheIndex) Bit(1) Unal;
Dcl CopyCache(0:%MaxCacheIndex) UBin Word;
Dcl CopyStream Redef CopyCache Char(%(4*CacheSize));
Dcl NewCache(0:%MaxCacheIndex) UBin Word;
Dcl NewStream Redef NewCache Char(%(4*CacheSize));
Dcl 1 SkipStart,    /* new first key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 SkipEnd,      /* new last key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 FirstKey,     /* old key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 LastKey,      /* old key number of last rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 NewStart,     /* new key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 KeyValue,
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
 
  SkipRange: Proc AltRet;
  /*
   Merge the skiprange into the new cache, now that it will fit
  */
 
   If SkipStart.Len > 0
    Then do;
      SIKey = SkipStart;
      Do While SIKey <= SkipEnd;
        Call M$Read( ReadSIByKey ) altret (boom);
        Call SetArs;
        If SIARS# > 0
         Then
           WriteUC02.Buf_.Bound = SIARS# - 1;
         Else do;
           WriteUC02.Buf_.Bound = 0;
           SILine = ' ';
         End;
        UCKey = SIKey.Key;
        Call M$WriteUC02 altret (boom);
        SIKey.Key = SIKey.Key + Incr;
      End; /* do while */
    End; /* if */
 
   SkipMerged = %True;
   Return;
 
  boom:
      AltReturn;
 
  End SkipRange;
 
  Switch: Proc(I) Altret;  /* internal */
  /*
      Rekey old to new
  */
  Dcl I UBin;
 
  DelUCKey = CopyCache(I);
  SIKey.Len = 3;
  SIKey.Key = NewCache(I);
  UCKey = NewCache(I);
  Call M$DelRec( DelEdit ) altret (boom);
  Call M$Read( ReadSIByKey ) altret (boom);
  Call SetArs;
  If SIARS# > 0
   Then
     WriteUC02.Buf_.Bound = SIARS# - 1;
   Else do;
     WriteUC02.Buf_.Bound = 0;
     SILine = ' ';
   End;
  Call M$WriteUC02 altret (boom);
  DoneFlags(I) = %True;
  CopyCache(I) = NewCache(I);
  If ((SkipEnd.Key + Incr) = NewCache(I))
   Then
     Call SkipRange altret (boom);
 
  Return;
 
  boom:
     AltReturn;
 
  End Switch;
 
/* Copy the old cache so we can work with it */
 
If LastCacheEntry < 0
 Then
   AltReturn;
 
SkipMerged = %False;
StartI = -1;
EndI = -1;
CopyCache = Cache;
LastEntry = LastCacheEntry;
LastCacheEntry = -1;  /* so we'll rebuild cache as we rekey it */
KeyValue = NewStart;
Do I = 0 to LastEntry;
   DoneFlags(I) = %False;
   TrueFlags(I) = %True;
   If (CopyCache(I) >= FirstKey.Key) and (CopyCache(I) <= LastKey.Key)
    Then do;
      If KeyValue = SkipStart
       Then
         KeyValue.Key = SkipEnd.Key + Incr;
 
      NewCache(I) = KeyValue.Key;
      KeyValue.Key = KeyValue.Key + Incr;
    End;
    Else
      NewCache(I) = CopyCache(I);
 
End; /* do I */
 
Do I = LastEntry+1 to %MaxCacheIndex;
   DoneFlags(I) = %True;
   TrueFlags(I) = %True;
End; /* do */
 
/* sort and rewrite the old cache to the new and the FEP */
 
Do While (DoneFlags&TrueFlags) ~= TrueFlags;
   Do I = 0 to LastEntry - 1;
     If NewCache(I) = CopyCache(I)
      Then do;
        UCKey = NewCache(I);
        DoneFlags(I) = %True;
        Call UpdateCache;  /* so the cache is updated correctly */
        If ((SkipEnd.Key + Incr) = NewCache(I))
         Then
           Call SkipRange altret (boom);
      End;
      Else
        If NewCache(I) < CopyCache(I+1)
         Then
           Call Switch(I) AltRet (boom);
 
   End; /* do I */
   If (Not DoneFlags(LastEntry))
    Then
      If (NewCache(LastEntry) > CopyCache(LastEntry)) or
         ((LastEntry > 0) and (DoneFlags(LastEntry-1)))
       Then
         Call Switch(LastEntry) AltRet (boom);
       Else
         If (NewCache(LastEntry) = CopyCache(LastEntry)) or (LastEntry = 0)
          Then do;
            UCKey = NewCache(LastEntry);
            DoneFlags(LastEntry) = %True;
            Call UpdateCache;  /* so the cache is updated correctly */
            If ((SkipEnd.Key + Incr) = NewCache(LastEntry))
             Then
               Call SkipRange altret (boom);
          End;
 
End; /* do while */
 
If Not SkipMerged
 Then
   Call SkipRange altret (boom);
 
Return;
 
boom:
   AltReturn;
 
End YRC$RekeyCache;
 
/**/
 
SetArs2: Proc( TotalRekey );
 
Dcl TotalRekey Bit(1) Param;
 
If TotalRekey
 Then
   SIARS# = M$SI$ -> F$Dcb.Ars#;
 Else
   SIARS# = M$Block2$ -> F$Dcb.Ars#;
 
End SetArs2;
 
/**/
 
YKF$MakeItKeyed: Proc;
/*
      Procedure to make sure the currently open SI fid is keyed with EDIT
      keys.
*/
 
Dcl Incr UBin;
Dcl I UBin;
Dcl 1 JunkKey,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 JunkKey2,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
   MakeItKeyed = %False;
   If InputOnlyFlag or WorkFlag
    Then      /* do nothing if ReadOnly mode or a workfile */
      Return;
 
   If M$SI$ -> F$Dcb.Org# = %Keyed#  /* do nothing if already keyed */
    Then                             /* we don't translate keytypes, either */
      Return;
 
   Call YRS$Setup( Incr, JunkKey, JunkKey, JunkKey2, 1 );
   If Incr = 0
    Then   /* can't do anything to the file */
      Return;
 
   Mode = %Rekeying;
   OutLine = 'Wait';
   ComLine1 = ' ';
   Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
   WriteOU.V.Seed# = ReadSI.V.Seed#;
   OUKey.Len = 3;
   OUKey.Key = Incr;
   Do While %True;
     Call M$Read( ReadSI ) Altret ( EOF );
     Call SetArs;
     If SIARS# ~= 0
      Then
        WriteOU.Buf_.Bound = SIARS# - 1;
      Else do;
        WriteOU.Buf_.Bound = 0;
        SILine = ' ';
      End;  /*  else  */
 
     Call M$Write( WriteOU ) Altret ( boom );
     OUKey.Key = OUKey.Key + Incr;
 
     If OUKey.Key > %MaxSequenceNumber
      Then do;
        Call M$Close( CloseOURelease ) WhenAltReturn do; end;
        Call Exeunt( %E$FileTooBig );
      End;  /*  if it got too big  */
 
   End;  /*  do while true  */
 
EOF:
   Call M$CloseSI( CloseSI ) Altret ( boom );
   Call M$Close( CloseOU ) Altret ( boom );
   If Buffers.Password#( CurrentBuffer# ) ~= ' '
    Then do;
      BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
      EditOldFile.IFParam_ = Vector( BabyFIT );
    End;
    Else
      EditOldFile.IFParam_ = Vector( NIL );
 
   EditOldFile.V.Fun# = %Update#;
   Call M$Open ( EditOldFile ) Altret ( boom );
 
   SequenFlag = %False;
   Buffers.Status.Sequen( CurrentBuffer# ) = %False;
   Call FigureOutLast;
   WriteOU.V.Seed# = '0'B;
 
   Block = Buffers.Block( CurrentBuffer# );
   SpotsChars = Buffers.Spots( CurrentBuffer# );
   CurrentPos = Buffers.CurrentPos( CurrentBuffer# );
 
   CurrentPos.Key.Key = Incr * CurrentPos.Key.Key; /* need to update since not consec */
   Do I = 0 to 10;
     Spots.Key.Key(I) = Incr * Spots.Key.Key(I);
   End;  /*  do I  */
   Block.KeyStart.Key = Incr * Block.KeyStart.Key;
   Block.KeyEnd.Key = Incr * Block.KeyEnd.Key;
 
   Buffers.Block( CurrentBuffer# ) = Block;
   Buffers.Spots( CurrentBuffer# ) = SpotsChars;
   Buffers.CurrentPos( CurrentBuffer# ) = CurrentPos;
   Buffers.Status.Changed( CurrentBuffer# ) = %True;
   Return;
 
boom:
   Call AltretError;
   Return;
 
End YKF$MakeItKeyed;
 
/**/
 
RekeySI: Proc(SkipStart,SkipEnd,FKey,LKey,NKey,Incr);
/*
      Procedure to rekey the input file.  This is necessary Whenever the
      FEP has run out of keys for inserting new records into the file
      currently being edited.
*/
 
%FPT_READ ( FPTN = ReadIt,      /* Read from the Edit file */
             BUF = SILine,
         STCLASS = STATIC,
             KEY = SIKey,
            KEYR = YES );
 
%FPT_WRITE( FPTN = WriteIt,     /* Write new records to Edit file */
             BUF = SILine,
         STCLASS = STATIC,
             KEY = OUKey,
         ONEWKEY = YES );
 
Dcl 1 TempBlock Static,    /*  Info marking the bounds of a block  */
      2 PosStart UBin Word Unal,
      2 KeyStart,
          3 Len UBin(9) Unal,
          3 Key UBin(27) Unal,
      2 PosEnd UBin Word Unal,
      2 KeyEnd,
          3 Len UBin(9) Unal,
          3 Key UBin(27) Unal;
 
Dcl 1 TempCurrentPos Static,
      2 Column UBin Word Unal,
      2 Key,
        3 Len UBin(9) Unal,
        3 Key UBin(27) Unal;
 
Dcl 1 TempSpots (0:10) Static,
      2 Column UBin Word Unal,
      2 Key,
         3 Len UBin(9) Unal,
         3 Key UBin(27) Unal;
 
Dcl TotalRekey Bit(1) Static Unal;
Dcl Incr UBin;
Dcl 1 SkipStart,    /* old first key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 SkipEnd,      /* old last key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 FKey,     /* old key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 LKey,     /* old key number of last rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 NKey,     /* new key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 LowerKey Static,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 UpperKey Static,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl dik Char(255) Unal;  /* because I can't take a substring of ' '...sheez */
Dcl I UBin;
 
/* Start procedure */
 
/* Since, we're rekeying, make sure the file is marked changed */
      Buffers.Status.Changed( CurrentBuffer# ) = %True;
 
      Mode = %Rekeying;
      OutLine = 'Wait';
      ComLine1 = ' ';
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
      Call YRS$Setup( Incr, Split.Key, LowerKey, UpperKey, 1 )
       WhenReturn do;  /* partial */
         WriteIt.V.Dcb# = DcbNum( M$SI );
         ReadIt.V.Dcb# = DcbNum( M$Block2 );
         TotalRekey = %False;
       End;
       WhenAltReturn do;  /* total */
         WriteIt.V.Dcb# = DcbNum( M$OU );
         ReadIt.V.Dcb# = DcbNum( M$SI );
         TotalRekey = %True;
       End;
 
      If Split.Buf.Len = 0
       Then do;
         Split.Buf.Len = 1;
         Split.Buf.Line = ' ';
       End;  /*  If  */
 
      OUKey.Len = 3;
      If TotalRekey
       Then
         OUKey.Key = Incr;
       Else
         OUKey = LowerKey;
 
      TempBlock = Block;
      TempCurrentPos = CurrentPos;
      TempSpots = Spots;
 
      Substr( Split.Buf.Line, Split.Buf.Len ) = ' '; /* blank pad */
      WriteIt.V.Seed# = ReadSI.V.Seed#;
 
      FKey.Len = 0;
      FKey.Key = 0;
      LKey.Key = 0;
      Do Forever;
         Call M$Read ( ReadIt ) Altret ( EOF );
         If (FKey.Len = 0) or (SIKey.Key <= Cache(0))
          Then do;  /* for rekey shadowcache */
            FKey = SIKey;
            NKey = OUKey;
          End;
 
         If (SIKey.Key <= Cache(LastCacheEntry))
          Then
            LKey = SIKey;
 
         If SIKey <= CurrentPos.Key then TempCurrentPos.Key = OUKey;
         If SIKey <= Block.KeyStart then TempBlock.KeyStart = OUKey;
         If SIKey <= Block.KeyEnd then TempBlock.KeyEnd = OUKey;
         Do I = 0 to 10;
           If SIKey <= Spots.Key(I) then TempSpots.Key(I) = OUKey;
         End;
 
         If SIKey.Key ~= Split.Key.Key
          then do;
            Call SetArs2( TotalRekey );
            If SIARS# ~= 0
             then
               WriteIt.Buf_.Bound = SIARS# - 1;
             else do;
               SILine = ' ';
               WriteIt.Buf_.Bound = 0;
             end; /*  else  */
          End;  /* if */
          Else do;   /*  the split!  */
            SkipStart = OUKey; /* used for rekeying shadow cache */
            SkipEnd = OUKey;
            SILine = Substr( Split.Buf.Line,0,Split.Pos - 1 );
            WriteIt.Buf_.Bound = Split.Pos - 2;
            If WriteIt.Buf_.Bound > %BufSize-1
             then do;
               WriteIt.Buf_.Bound = 0;
               SILine = ' ';
             End;  /*  If  */
 
            Call M$Write( WriteIt ) Altret ( boom );
 
            OUKey.Key = OUKey.Key + Incr;
            If AutoTabClm# > 1
             Then do;
               dik = ' ';
               Call Concat(SILine, Substr( dik, 0, AutoTabClm# - 1 ),
                                   Substr( Split.Buf.Line, Split.Pos - 1,
                                           Split.Buf.Len - Split.Pos + 1 ) );
 
               WriteIt.Buf_.Bound = Split.Buf.Len - Split.Pos + AutoTabClm# - 1;
             End;  /*  if  */
             Else do;
               SILine = Substr( Split.Buf.Line, Split.Pos - 1,
                                Split.Buf.Len - Split.Pos + 1 );
 
               WriteIt.Buf_.Bound = Split.Buf.Len - Split.Pos;
             End;  /*  else  */
 
            If WriteIt.Buf_.Bound > %BufSize-1
             then do;
               WriteIt.Buf_.Bound = 0;
               SILine = ' ';
             End;  /*  If  */
 
          End;  /*  Else  */
 
         Call M$Write( WriteIt ) Altret ( boom );
 
         OUKey.Key = OUKey.Key + Incr;
 
         If (OuKey.Key > %MaxSequenceNumber) and TotalRekey
          then do;
            Call M$Close( CloseOURelease ) Altret ( boom );
            Call Exeunt( %E$FileTooBig );
          end;  /*  if it got too big  */
 
      End; /* Do Forever */
 
EOF:
      If TotalRekey
       Then do;
         Block = TempBlock;
         CurrentPos = TempCurrentPos;
         Spots = TempSpots;
         Call M$Close ( CloseSI ) Altret ( boom );
         Call M$Close ( CloseOU ) Altret ( boom );
 
         If Buffers.Password#( CurrentBuffer# ) ~= ' '
          Then do;
            BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
            EditOldFile.IFParam_ = Vector( BabyFIT );
          End;
          Else
            EditOldFile.IFParam_ = Vector( NIL );
 
         EditOldFile.V.Fun# = %Update#;
         Call M$Open ( EditOldFile ) Altret ( boom );
       End;
       Else do;
         If (Block.KeyStart >= LowerKey) and (Block.KeyStart <= UpperKey)
          Then
            Block.KeyStart = TempBlock.KeyStart;
 
         If (Block.KeyEnd >= LowerKey) and (Block.KeyEnd <= UpperKey)
          Then
            Block.KeyEnd = TempBlock.KeyEnd;
 
         Do I = 0 to 10;
           If (Spots.Key(I) >= LowerKey) and (Spots.Key(I) <= UpperKey)
            Then
              Spots(I) = TempSpots(I);
 
         End; /*  do I  */
 
         If (CurrentPos.Key >= LowerKey) and (CurrentPos.Key <= UpperKey)
          Then
            CurrentPos = TempCurrentPos;
 
         Call M$Close( CloseStarUniqueDelete2 ) Altret ( boom );
       End;
 
      Call FigureOutLast;
      WriteIt.V.Seed# = '0'B;
      Return;
 
boom:
      Call AltretError;
      Return;
 
End RekeySI;
 
/**/
 
YSS$RetrySplit: Proc;
/*
      This procedure will rekey the file and try again to split or insert
      the records that there were previously not enough room for.
*/
 
Dcl NumFromEnd UBin;
Dcl Where UBin Half;
Dcl TempKey UBin Word;
Dcl Incr UBin;
Dcl 1 SkipStart,    /* old first key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 SkipEnd,      /* old last key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 FKey,     /* old key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 LKey,     /* old key number of last rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 NKey,     /* new key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
 
/* Start procedure */
 
      SIKey.Key = UCKey;
 
      Split.Key.Key = UCKey;
      Split.Key.Len = 3;
      Split.Pos = M$Edit$ -> F$Dcb.ActPos;
      If Split.Pos = 0
       Then
         Split.Pos = 1;
 
      Split.Buf.Line = UCLine;
      Split.Buf.Len = M$Edit$ -> F$Dcb.Ars#;
 
      PRecSI.V.N# = %MaxSequenceNumber;
 
      Call M$PRecord( PRecSI )
         WhenAltReturn do;
              Call SetArs;
              NumFromEnd = SIARS#;
 
         end; /* PRec Altret */
 
      Call RekeySI(SkipStart,SkipEnd,FKey,LKey,NKey,Incr);
      Call YRC$RekeyCache(SkipStart,SkipEnd,FKey,LKey,NKey,Incr)
       WhenAltReturn do;  /* if it blows up, use the old blast-screen method */
         Call M$EraseEdit Altret ( boom );
       End;
 
      Call M$PFil ( PosEOF ) Altret ( boom );
      If (Split.Pos > Split.Buf.Len) and not WordWrapping
       then do;
         PRecSiNoKey.V.N# = - ( NumFromEnd );
         If AutoTabClm# > 1
          Then
            Split.Pos = AutoTabClm#;
          Else
            Split.Pos = 1;
 
       end; /*  If  */
       else
         If not WordWrapping
          then
            If M$Edit$ -> F$Dcb.Ars# > 0
             Then
               PRecSINoKey.V.N# = - ( NumFromEnd + 1 );
             Else
               PRecSINoKey.V.N# = - ( NumFromEnd );
 
          else
            If Split.Buf.Len > WordWrapClm#
             Then do;
               PRecSiNoKey.V.N# = - ( NumFromEnd );
               Split.Pos = 2 + Split.Buf.Len - Split.Pos;
               If AutoTabClm# > 1
                Then
                  Split.Pos = Split.Pos + AutoTabClm# - 1;
 
             end;
             else
               If Split.Pos > Split.Buf.Len
                then do;
                  PRecSiNoKey.V.N# = - ( NumFromEnd );
                  If AutoTabClm# > 1
                   Then
                     Split.Pos = AutoTabClm#;
                   Else
                     Split.Pos = 1;
 
                end;
                else
                  If M$Edit$ -> F$Dcb.Ars# > 0
                   Then
                     PRecSiNoKey.V.N# = - ( NumFromEnd + 1 );
                   Else
                     PRecSiNoKey.V.N# = - ( NumFromEnd );
 
      Call M$PRecord ( PRecSINoKey ) Altret ( boom );
      where = Split.Pos - 1;   /*  need to adjust before call which adds 1  */
      Call Position( where );  /*  re-position screen  */
 
      Call MakeAnnouncements Altret ( boom );
 
      Return;
 
boom:
      Call AltretError;
      Return;
 
End YSS$RetrySplit;
 
/**/
 
YSF$FindAWord: Proc( AWord, CaseBlind, Where, Global, ActPos, BlockOnly ) AltRet;
/*
      Procedure to actually find the location of a word within M$SI.
      At the end of the procedure, SIKey contains the key of the record
      containing  AWord  and  where  contains the position within that
      line.
*/
 
Dcl 1 AWord,
    2 len UBin,
    2 words Char(71);
 
Dcl CaseBlind Bit(1);
Dcl Global Bit(1);
Dcl Where UBin(18);
Dcl Where1 UBin Word WAligned;
Dcl ActPos UBin(18);
Dcl BlockOnly Bit(1);
Dcl Len UBin;
Dcl Line Char( %BufSize );
Dcl Found Bit(1);
Dcl DoneSearching Bit(1);
Dcl SaidSearching Bit(1);
Dcl ARS UBin;
Dcl Start UBin;
 
  GetIndex: Proc( where, Line1, Len1, Line2, Len2, Start ) Altret;
   /*
      Do INDEX or INDEXR, based on ForwardSearch
   */
 
      Dcl where UBin Word Param;
      Dcl Line1 Char(%BufSize) Param;
      Dcl Line2 Char(%BufSize) Param;
      Dcl Len1 UBin Param;
      Dcl Len2 UBin Param;
      Dcl Start UBin Param;
 
      If (Len1 > Len2) or (Start > Len2)
       Then  /* search string won't fit in source line or starting after eol */
         AltReturn;
 
      If ForwardSearch
        Then
          Call Index( where, Substr( Line1,0,Len1 ),
                      SubStr(Line2,0,Len2), Start)
           WhenReturn do;
              Return;
           End;
           WhenAltReturn do;
              AltReturn;
           End;
        Else
          Call IndexR( where, Substr( Line1,0,Len1 ),
                       SubStr(Line2,0,Len2), Start)
           WhenReturn do;
              Return;
           End;
           WhenAltReturn do;
              AltReturn;
           End;
       
   End GetIndex;
 
   FinishUp: Proc;
 
      DoneSearching = %True;
      SIKey.Key = UCKey;
      Where = ActPos - 1;
      Return;
 
   End FinishUp;
 
/*
      Start YSF$FindAWord
*/
      
      Len = AWord.Len;
      Line = SubStr (AWord.Words, 0, Len);
      If Caseblind then
         Call Upper( Line, Len );  /* set the string to upper case */
 
      found = %False;
      DoneSearching = %False;
      SaidSearching = %False;
      SIKey.Key = UCKey;  /*  The key Returned from the read */
      SILine = ' ';
ReDo: Call M$ReadSI( ReadSI )
       WhenAltReturn do;
         Call SetErrCode;
         If (ErrCode.Err# ~= %E$EOF)
          then
            goto boom;
 
          /* now, clean up */
 
         If ForwardSearch
          then do;
            Call FinishUp;
            AltReturn;
          end;
          else do;
            Call M$PRecordSI( PRecSIBack1 )
             WhenAltReturn do;
               Call FinishUp;
               AltReturn;
             End;
 
            Goto ReDo;
          end;  /*  else  */
 
       end;  /*  When Altret  */
 
      Do while Not DoneSearching;
         If Not SaidSearching and Not
            ((LastCacheEntry >= 0 ) and (SIKey.Key >= Cache(0)) and
            (SIKey.Key <= Cache(LastCacheEntry)))
          Then do;
            SaidSearching = %True;
            OutLine = 'Searching';
            ComLine1 = ' ';
            Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
            Call M$WriteUC03( OutLine, ComLine1, Fid ) WhenAltReturn do; end;
          End;  /* if */
 
         Call SetArs;
         ARS = SIARS#;
         If (ARS > 0)
          Then Do;
           If CaseBlind
            Then
             Call Upper( SILine, ARS);
 
           If ForwardSearch
            Then
             If BlockOnly and (SIKey.Key = Block.KeyStart.Key)
              Then
                Start = Block.PosStart;
              Else
                Start = 0;
            Else
             If BlockOnly and (SIKey.Key = Block.KeyEnd.Key)
              Then
                Start = Block.PosEnd;
              Else
                Start = ARS;
 
           Call GetIndex( where1, Line, Len, SILine, ARS, Start)
             WhenReturn Do;
               Found = %True;
 
               If (SIKey.Key = UCKey)
                then do;
                 If ActPos > ARS Then
                   ActPos = ARS;
 
                 If ((( Where1 + 1 ) <= ActPos) and (Not Global) and (ForwardSearch)) or
                    ((( Where1 + 1 ) >= ActPos) and (Not Global) and (Not ForwardSearch))
                    then do;
                      If ForwardSearch
                       Then
                        Start = ActPos;
                       Else
                        Start = ActPos+Len-2;
 
                      Call GetIndex( where1, Line, Len, SILine, ARS, Start )
                         WhenReturn do;
                           where = where1;
                         end;
                         WhenAltReturn do;
                           Found = %False;
                         end; /* WhenAlt on index */
                    End;
                    else  /* matches if <= actpos */
                         where = where1;
                end; /* do from if */
                else  /*  matches if sikey = uckey  */
                 where = where1;
 
             End; /* When Return from Index1 */
             WhenAltReturn Do;    /* on Index1 */
             End;  /*  When Altret  */
 
          End; /* if ARS > 0 */
 
         If Found
          Then
            DoneSearching = %True;
 
         If ForwardSearch and BlockOnly and (SIKey >= Block.KeyEnd)
          Then do;
            DoneSearching = %True;
            If Found and (SIKey = Block.KeyEnd) and (where >= Block.PosEnd-Len)
             Then do;
               Call FinishUp;
               Found = %False;
             End;
             Else If Not Found
              then
                Call FinishUp;
 
          End;  /*  if  */
          Else If (Not ForwardSearch) and BlockOnly and (SIKey <= Block.KeyStart)
           Then do;
            DoneSearching = %True;
            If Found and (SIKey = Block.KeyStart) and (where < Block.PosStart-1)
             Then do;
               Call FinishUp;
               Found = %False;
             End;
             Else If Not Found
              then
                Call FinishUp;
 
           End;  /*  else if  */
 
         If Not DoneSearching
          Then do;
            SILine = ' ';
            If Not ForwardSearch
             Then
               Call M$PRecordSI( PRecSIBack2 )
                WhenAltReturn do;
                  Call FinishUp;
                  Goto DontBother;
                end;
 
            Call M$ReadSI( ReadSI )
             WhenAltReturn do;
               Call FinishUp;      /* sets done searching to true  */
             end; /* WhenAlt */
 
          End;  /*  if not done searching  */
 
       End; /* Do while */
 
DontBother:
       Global = %False;
       If Found
        Then
          Return;
        Else
          AltReturn;
      
boom:
      Call AltretError;
      Return;
 
End YSF$FindAWord;
 
/**/
 
ParseReplace: Proc( QuitFlag, CaseBlind, global, VerifyFlag, AllFlag, BlockOnly,
                    HowMany, Options, Local$ );
                               
/*
      Procedure to parse the Find options
*/
 
Dcl Local$ Ptr;
%Parse$Out ( Name = Out, StClass = "BASED(Local$)" );
%Parse$Sym ( Name = Sym, StClass = "BASED(Local$)" );
 
Dcl CaseBlind Bit(1);
Dcl Global Bit(1);
Dcl VerifyFlag Bit(1);
Dcl AllFlag Bit(1);
Dcl QuitFlag Bit(1);
Dcl BlockOnly Bit(1);
Dcl HowMany UBin;
Dcl options char(71);
 
Dcl Where1 UBin Word WAligned;
 
/*
      Start Parser 
*/
      
         Call Upper( Options, LengthC( Options ) );
 
         Do Case Out.Code;
          Case( %Quit );
            QuitFlag = %True;
            Call Index( where1, 'Q', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out Q for next search */
              end;
              WhenAltReturn do; end;
               
          Case( %UpperCase );
            CaseBlind = %True;
 
          Case( %Backwards );
            ForwardSearch = %False;
            Call Index( where1, 'B', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out B for next search */
              end;
              WhenAltReturn do; end;
                  
          Case( %Global );
            Global = %True;
            Call Upper( Options, LengthC( Options ) );
            Call Index( where1, 'G', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out G for next search */
              end;
              WhenAltReturn do; end;
              
          Case( %Verify );
            VerifyFlag = %True;
 
          Case( %BlockOnly );
            BlockOnly = %True;
          
          Case( %All );
            AllFlag = %True;
          
          Case( %Next );
            Call CharBin( HowMany, Out.Sublk$(0) -> Sym.Text );
 
          Case( Else );
 
         End;  /*  do case  */
 
end ParseReplace;
 
/**/
 
Verify: Proc (ActPos, DontDoAnymore, Where) Altret;
/*
      Procedure to ask the user a YES or NO question.  If YES, then the 
      procedure takes the normal Return.  If NO, then the procedure will
      take the Alternate Return.  If QUIT, then set the DontDoAnymore flag.
      Otherwise, tell the user about it and make him try again.
*/
 
Dcl ActPos UBin Half;
Dcl DontDoAnymore Bit(1) Param;
Dcl Where UBin(18) Param;
Dcl tempkey UBin;
 
/*  Start Verify  */
 
      OutLine = 'Y,N or Q';
      ComLine1 = ' ';
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
      tempkey = SIKey.Key;
 
retry2:
      Call M$EOM( EOMUC02All ) Altret ( boom );
retry:
      SIKey.Key = tempkey;
      Call Position( where );
      SIKey.Key = tempkey;
reread:
      Call M$Read( ReadUC02 )
         WhenReturn do;
           Call FixUpRecord;
           If (M$Edit$ -> F$Dcb.ActPos ~= (where + 1)) or (UCKey ~= tempkey)
            Then do;
              YYY_ErrCode.Err# = %E$DontMoveCursor;
              Call YXB$SetBold;
              Call YEM$Errmsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0 );
              Call YXB$ResetBold;
              Goto retry;
            End;  /*  if  */
 
         End;  /*  When Return  */
         WhenAltReturn do;
           Call YEG$ErrCode( ErrCode );
           Do Select ErrCode.Err#;
            Select( %E$Records_Needed );
              Call YSG$GetRecords( M$Edit$ -> F$Dcb.Ars# );
              goto reread;
 
            Select( %E$Record_Deleted );
              Call FixUpRecord;
              goto retry;
 
            Select( %E$Insert_No_Room );
              goto retry;
 
            Select( Else );
              Call AltretError;
 
           End;  /*  select  */
         End;  /*  WhenAltret  */
         
      Call M$EOM( EOMUC02 ) Altret ( boom );
      ActPos = M$Edit$->F$Dcb.ActPos;
      DontDoAnymore = %False;
      
      Do Case AscBin( M$Edit$->F$Dcb.EOMChar# );          
         Case( 89, 121 );
            Return;
 
         Case( 78, 110 );
            AltReturn;
 
         Case( 81, 113 );
            DontDoAnymore = %True;
            AltReturn;
 
         Case( else );
            YYY_ErrCode.Err# = %E$YNorQ;
            Call YXB$SetBold;
            Call YEM$Errmsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0 );
            Call YXB$ResetBold;
            Goto retry2;
 
      End;  /*  case  */
 
boom:
      Call AltretError;
      Return;
 
End Verify;
 
/**/
 
FixUpRecord: Proc;
/*
      Procedure to preserve a semblance of ReadOnly mode.
*/
 
   SIKey.Len = 3;
   SIKey.Key = UCKey;
   Call M$ReadSI( ReadSIByKey )
      WhenReturn do;
        Call SetArs;
        If SIARS# > 0
         then
            WriteUC02.Buf_.Bound = SIARS# - 1;
         else do;
            WriteUC02.Buf_.Bound = 0;
            SILine = ' ';
         end;  /*  else  */
 
        Call M$WriteUC02 Altret ( boom );
 
      end;
      WhenAltReturn do;
        Call M$DelRec( DelUC02 ) WhenAltReturn do; end;
      end;
 
   Return;
 
boom:
   Call AltRetError;
   Return;
 
End FixUpRecord;
 
/**/
 
ReplaceIt: Proc( where, This, With, ActPos );
/*
      Procedure to do the actual replacement of strings within a line.
*/
      
Dcl 1 This,
    2 len UBin,
    2 words Char(71);
 
Dcl 1 With,
    2 len UBin,
    2 words Char(71);
 
Dcl where UBin Half;
Dcl ActPos UBin Half;
Dcl Bound UBin Static;
Dcl junk UBin Static;
 
/*
      Start ReplaceIt
*/
 
SIKey.Len = 3;
Call M$ReadSI( ReadSIByKey ) Altret ( boom );  /*  the key better exist  */
 
Call Concat( UCLine, Substr( SILine, 0, where ),
                     Substr( With.words, 0, With.len ),
                     Substr( SILine, Where + This.len ) );
 
SILine = UCLine;
UCKey = SIKey.Key;
 
Call SetArs;
If SequenFlag
 Then do;  /*  can't change line length in sequential files.  */
   WriteSI.Buf_.Bound = SIARS# - 1;
   WriteUC02.Buf_.Bound = WriteSI.Buf_.Bound;
 End;
 Else do;
   WriteSI.Buf_.Bound = SIARS# - This.len + With.len - 1;
   If StripFlag
    Then
      Call SearchR( Bound, junk, B$SR_Non_Blank,
                    Substr( SILine, 0, WriteSI.Buf_.Bound+1 ) )
       WhenReturn do;
         WriteSI.Buf_.Bound = Bound;
       End;
       WhenAltReturn do;
         WriteSI.Buf_.Bound = 0;
       End;
 
   WriteUC02.Buf_.Bound = WriteSI.Buf_.Bound;
 End;
 
Call M$WriteSI( WriteSI ) Altret ( boom );
/*
      Check for record existence in the FEP, then, if necessary, bring it
      up to date.
*/
If (LastCacheEntry >= 0 ) and (SIKey.Key >= Cache(0)) and (SIKey.Key <= Cache( LastCacheEntry ))
 then do;
   Call M$WriteUC02 Altret ( boom );
   Call M$Device( FPTDeviceEdit ) Altret ( boom );
 End;
      
ActPos = Where + With.Len;
 
/*  Don't want a search starting in or before the string we just replaced  */
 
Return;
 
boom:
      Call AltretError;
      Return;
      
End ReplaceIt;
 
/**/
 
Position: Proc( where );
/*
      Procedure to position the screen to the specified column and SIKey.
*/
      
Dcl where UBin Half;
Dcl tempkey UBin Word Static Unal;
 
/*
      Begin Position
*/
      
      SIKey.Len = 3;  /*  just in case  */
      tempkey = SIKey.Key;
 
      If (LastCacheEntry = -1 ) or (SIKey.Key < Cache(0)) or
         (SIKey.Key > Cache( LastCacheEntry ))
       Then Do;  /* position the output */
         Call M$EraseEdit Altret ( boom );
         PRecSI.V.N# = 0;
         Call M$PRecordSI( PRecSI )
          WhenAltReturn do;
            Call SetErrCode;
            If (ErrCode.Err# ~= %E$NoKey) and (ErrCode.Err# ~= %E$EOF) and
               (ErrCode.Err# ~= %E$BOF)  /* that should cover it */
             Then
               Goto boom;
          End;  /*  Altret  */
 
         tempkey = SIKey.Key;
         UCKey = tempkey;
         NoWEOF = %True;
         Call YSG$GetRecords( (CacheSize / 2) );
         UCKey = tempkey + 1;
         NoWEOF = %True;
         Call YSG$GetRecords( -(CacheSize / 2) );
       End; /* if */
 
      SInputUC02.V.ReReadPos# = where + 1;
      PositionKey = tempkey;
      Call M$SInput( SInputUC02 ) Altret ( boom );
 
      Return;
 
boom:
      Call AltretError;
      Return;
      
End Position;
 
/**/
 
YSR$Replace: Proc ( This, With, options );
/*
      This procedure will prompt for a replacement string and options, and
      then replace the occurrences of  Line  within the file, positioning the
      cursor on the screen at the location of the last replacement.
*/
Dcl 1 This,
    2 len UBin,
    2 words Char(71);
 
Dcl 1 With,
    2 len UBin,
    2 words Char(71);
 
Dcl Line Char(%BufSize);
Dcl column UBin;
Dcl Options Char(71);
Dcl Where UBin(18);
Dcl ActPos UBin(18);
Dcl TempWhere UBin(18);
Dcl Tempkey UBin Word Static Unal;
Dcl TempUC UBin Word Static Unal;
Dcl Where1 UBin Word WAligned;
Dcl I UBin;
Dcl HowMany UBin;
Dcl QuitFlag Bit(1) Static Unal;
Dcl CaseBlind Bit(1) Static Unal;
Dcl VerifyFlag Bit(1) Static Unal;
Dcl AllFlag Bit(1) Static Unal;
Dcl BlockOnly Bit(1) Static Unal;
Dcl Count UBin Static Unal;
Dcl Changed UBin Static Unal;
Dcl Global Bit(1) Static Unal;
Dcl Finished Bit(1) Static Unal;
Dcl DontDoAnymore Bit(1) Static Unal;
Dcl 1 F1 Static Unal,
    2 L# UBin(9) Unal,
    2 Text# Char(15) Unal;
 
Dcl 1 F2 Static Unal,
    2 L# UBin(9) Unal,
    2 Text# Char(2) Unal;   /*  for plural  */
 
  TellCount: Proc( Changes# );
      /* Internal procedure */
 
   Dcl Changes# UBin;
 
     If Changes# = 1
      Then do;
        F2.L# = 1;
        F2.Text# = ' ';
      End;
      Else do;
        F2.L# = 2;
        F2.Text# = 's ';
      End;
 
     Call BinChar( F1.Text#, Changes# );
     F1.L# = LengthC( F1.Text# );
     Do While (Substr( F1.Text#,0,1 ) = '0') and ( F1.L# > 1 );
       F1.Text# = Substr( F1.Text#,1 );
       F1.L# = F1.L# - 1;
     End;
 
     If YYY_ErrCode.Err# ~= %E$ChangedStrings
      Then
        Call YXB$SetBold;
      Else
        Call YXB$SetNorm;
 
     Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),Vector( F1 ),
                      Vector( F2 ),,1,0 );
 
     If YYY_ErrCode.Err# ~= %E$ChangedStrings
      Then
        Call YXB$ResetBold;
 
     Return;
 
   End TellCount;
 
/*
      Begin YSR$Replace
*/
      Mode = %Replace;
 
      Xug_Replace.Text_ = Vector( Substr( Options, 0, 71 ) );
      Call Xug$GetCmd( Xug_Replace )
         WhenAltReturn do;
          Call YXB$SetBold;
          Call Xug$ErrPtr( Xug_Replace ) Altret (boom);
          Call YXB$ResetBold;
          Return;
         end;
 
      CMD$ = Xug_Replace.OUT$;
            
      QuitFlag = %False;
      CaseBlind = %False;
      Global = %False;
      VerifyFlag = %False;
      AllFlag = %False;
      BlockOnly = %False;
      HowMany = 1;              /*  default to only replace one  */
      
      SIKey.Key = UCKey;
      PRecSI.V.N# = 0;
      Call M$PRecordSI( PRecSI )
        WhenAltReturn Do; End;
             
      If (Out.NSublks = 0) or (Out.Code = %Next)
       then Call ParseReplace( QuitFlag, CaseBlind, Global, VerifyFlag, AllFlag,
                               BlockOnly, HowMany, options, CMD$ );
       else
        Do I = 0 to Out.NSublks - 1;
 
         Call ParseReplace( QuitFlag, CaseBlind, Global, VerifyFlag, AllFlag,
                            BlockOnly, HowMany, options, Out.Sublk$(I) );
 
        End;  /*  do I  */
 
/*    Continue if no quit was asked for  */
 
      If QuitFlag then Return;
 
      column = M$Edit$ -> F$Dcb.ActPos;
      If BlockOnly
       Then
         Call ValidateBlock   /* check for valid block markers */
          WhenAltReturn do;
            Return;
          End;
 
      SIKey.Key = UCKey;
      PRecSI.V.N# = 0;
      Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
 
      If ForwardSearch and Global
       Then do;
         If BlockOnly
          Then do;
            SIKey = Block.KeyStart;
            column = Block.PosStart;
          End;
          Else
            SIKey.Key = 0;
 
         Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
       End;  /*  if  */
       Else If Global
             Then do;
               If BlockOnly
                Then do;
                  SIKey = Block.KeyEnd;
                  column = Block.PosEnd;
                  Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
                End;  /*  if blockonly  */
                Else do;
                  Call M$PFilSI( PosEOF ) WhenAltReturn do; end;
                  Call M$PRecordSI( PRecSIBack1 ) WhenAltReturn do; end;
                End;  /*  else  */
             End;  /*  else if global  */
 
/*
      Now, go find all the appropriate strings and replace according to the
      options.
*/
 
      Finished = %False;
      Count = 0;    /*  how many we've looked at so far  */
      Changed = 0;  /*  how many we've changed so far  */
      tempkey = UCKey;
      tempwhere = M$Edit$->F$dcb.ActPos - 1;
      ActPos = M$Edit$->F$Dcb.ActPos;
 
      If BlockOnly
       Then
         Call CheckBlockOnly( column )
          WhenAltReturn do;
            Return;
          End;
 
      Do Until Finished;
         PRecSI.V.N# = 0;
         SIKey.Len = 3;
         Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
 
         Call YSF$FindAWord( This, CaseBlind, where, Global, ActPos, BlockOnly )
          WhenReturn do;
            If VerifyFlag
             then do;
               tempkey = SIKey.Key;
               tempUC = UCKey;
 
               Call Verify( ActPos, DontDoAnymore, where )
                WhenReturn do;
                  UCKey = tempUC;
                  SIKey.Key = tempkey;
                  Call ReplaceIt( where, This, With, ActPos );
                  Changed = Changed + 1;
                end;  /*  When Return  */
                WhenAltReturn do;
                  If DontDoAnymore
                   then do;
                     Finished = %True;
                     YYY_ErrCode.Err# = %E$ChangedStrings;
                     Call TellCount( Changed );
                   End;  /*  if  */
                End;  /*  Altret  */
 
               SIKey.Key = tempkey;  /*  make sure verify didn't mess up  */
             end;  /*  if verify  */
             else do;
               Call ReplaceIt( where, This, With, ActPos );
               Changed = Changed + 1;
             end;  /*  else  */
 
            tempkey = SIKey.Key;
            tempwhere = where;
            UCKey = SIKey.Key;   /*  set new starting place  */
            Count = Count + 1;   /*  how many strings checked  */
            If (Count = HowMany) and (not AllFlag)
             then do;
               Finished = %True;
               YYY_ErrCode.Err# = %E$ChangedStrings;
               Call TellCount( Changed );
             end;
 
          end;  /*  When Return  */
          WhenAltReturn do;
            Finished = %True;
            If Count = 0
             then do;
               If Not BlockOnly
                Then
                  YYY_ErrCode.Err# = %E$StringNotFound;
                Else
                  YYY_ErrCode.Err# = %E$StringNotFoundBlock;
 
               Call YXB$SetBold;
               Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
               Call YXB$ResetBold;
             end;
             else do;
               If Not BlockOnly
                Then
                  YYY_ErrCode.Err# = %E$NoMoreStrings;
                Else
                  YYY_ErrCode.Err# = %E$NoMoreStringsBlock;
 
               Call TellCount( Changed );
             End;
            
          End;  /*  When AltReturn  */
 
      end;  /*  do until  */
 
      SIKey.Key = tempkey;
      where = tempwhere;
 
      Call Position( where );  /*  re-position screen  */
 
      Return;
      
boom:
      Call AltretError;
      Return;
    
End YSR$Replace;
 
/**/
 
CheckBlockOnly: Proc( column ) AltRet;
/*
   Check to see if the user is positioned within the block.
*/
 
Dcl column UBin;
Dcl 1 Coord1,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
Dcl 1 Coord2,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
Dcl 1 Coord3,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
 
   Coord1.Key = Block.KeyStart.Key;
   Coord2.Key = Block.KeyEnd.Key;
   Coord3.Key = SIKey.Key;
   Coord1.Column = Block.PosStart;
   Coord2.Column = Block.PosEnd;
   Coord3.Column = Column;
 
   If Coord3 < Coord1
    Then do;
      YYY_ErrCode.Err# = %E$BeforeBlock;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0);
      Call YXB$ResetBold;
      AltReturn;
    End;
    Else If Coord3 > Coord2
     Then do;
      YYY_ErrCode.Err# = %E$AfterBlock;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0);
      Call YXB$ResetBold;
      AltReturn;
     End;
  
   Return;
 
End CheckBlockOnly;
 
/**/
 
ParseFind: Proc( QuitFlag, CaseBlind, global, BlockOnly, Options, Local$ );
/*
      Procedure to parse the Find options
*/
 
Dcl Local$ Ptr;
%Parse$Out ( Name = Out, StClass = "BASED(Local$)" );
 
Dcl QuitFlag Bit(1);
Dcl CaseBlind Bit(1);
Dcl Global Bit(1);
Dcl BlockOnly Bit(1);
Dcl options char(71);
 
Dcl Where1 UBin Word WAligned;
 
/*
      Start Parser
*/
      
         Call Upper( Options, LengthC( Options ) );
 
         Do Case Out.Code;
          Case( %Quit );
            QuitFlag = %True;
            Call Index( where1, 'Q', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out Q for next search */
              end;
              WhenAltReturn do; end;
                
          Case( %UpperCase );
            CaseBlind = %True;
 
          Case( %Backwards );
            ForwardSearch = %False;
            Call Index( where1, 'B', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out B for next search */
              end;
              WhenAltReturn do; end;
                 
          Case( %Global );
            Global = %True;
            Call Index( where1, 'G', options )
              WhenReturn do;
                Substr( options,where1,1 ) = ' '; /* strip out G for next search */
              end;
              WhenAltReturn do; end;
 
          Case( %BlockOnly );
            BlockOnly = %True;
              
          Case( Else );
         End;  /*  do case  */
 
End ParseFind;
 
/**/
 
YSF$Find: Proc ( AWord, options );
/*
      This procedure will prompt for options and then locate the  Line
      according to the options, positioning the cursor on the screen at the
      beginning of the string specified in  Line.
*/
 
Dcl 1 AWord,
    2 len UBin,
    2 words Char(71);
 
Dcl options char(71);
Dcl column UBin;
Dcl Where UBin(18) Static HAligned;
Dcl ActPos UBin(18) Static HAligned;
Dcl Where1 UBin Word WAligned;
Dcl tempkey UBin Word;
Dcl I UBin;
Dcl QuitFlag Bit(1) Static Unal;
Dcl CaseBlind Bit(1) Static Unal;
Dcl Global Bit(1) Static Unal;
Dcl BlockOnly Bit(1) Static Unal;
 
/* get options */
 
      Mode = %Search;
 
      Xug_Find.Text_ = Vector( Substr( Options, 0, 71 ) );
      Call Xug$GetCmd( Xug_Find )
         WhenAltReturn do;
          Call YXB$SetBold;
          Call Xug$ErrPtr( Xug_Find ) Altret (boom);
          Call YXB$ResetBold;
          Return;
         end;
 
      CMD$ = Xug_Find.OUT$;
            
      QuitFlag = %False;
      CaseBlind = %False;
      Global = %False;
      BlockOnly = %False;
      SIKey.Key = UCKey;
      PRecSI.V.N# = 0;
      Call M$PRecordSI( PRecSI )
        WhenAltReturn Do; End;
         
      If Out.NSublks = 0 
       then Call ParseFind( QuitFlag, CaseBlind, Global, BlockOnly,
                            options, CMD$ );
       else
        Do I = 0 to Out.NSublks - 1;
 
         Call ParseFind( QuitFlag, CaseBlind, Global, BlockOnly,
                         options, Out.Sublk$(I) );
 
        End;  /*  do I  */
 
/*    Continue if no quit was asked for.  */
         
      If QuitFlag then Return;
 
      If BlockOnly
       Then
         Call ValidateBlock   /* check for valid block markers */
          WhenAltReturn do;
            Return;
          End;
 
      column = M$Edit$ -> F$Dcb.ActPos;
      If ForwardSearch and Global
       Then do;
         If Not BlockOnly
          Then
            SIKey.Key = 0;
          Else do;
            SIKey = Block.KeyStart;
            column = Block.PosStart;
          End;
 
         Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
       End;  /*  if forward and global  */
       Else If Global
             Then
               If Not BlockOnly
                Then do;
                  Call M$PFilSI( PosEOF ) WhenAltReturn do; end;
                  Call M$PRecordSI( PRecSIBack1 ) WhenAltReturn do; end;
                End;  /*  if not block only  */
                Else do;
                  SIKey = Block.KeyEnd;
                  column = Block.PosEnd;
                  Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
                End;  /*  else do  */
 
 
      If BlockOnly
       Then
         Call CheckBlockOnly( column )
          WhenAltReturn do;
            Return;
          End;
           
      ActPos = M$Edit$->F$Dcb.ActPos;
      Call YSF$FindAWord( AWord, CaseBlind, where, Global, ActPos, BlockOnly )
       WhenAltReturn do;
         If Not BlockOnly
          Then
            YYY_ErrCode.Err# = %E$StringNotFound;
          Else
            YYY_ErrCode.Err# = %E$StringNotFoundBlock;
 
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
         Call YXB$ResetBold;
       End;  /*  When Altret  */
      
      Call Position( where );
 
      Return;
 
boom:
         Call AltretError;
         Return;
 
End YSF$Find;
 
/**/
 
Upper: Proc ( string, len );
/*
      This procedure will take a string of length len and convert all its
      lower case letters to their upper case equivalents.
*/
Dcl string Char(len);
Dcl len UBin;
 
      Call Xlate (string, B$XL_UPPER, string);
 
End Upper;
 
/**/
 
GotoSpot: Proc( Column, Key );
/*
      Procedure to position the cursor to a marked spot.
*/
Dcl Column UBin Word Unal;
Dcl where UBin Half HAligned;
Dcl 1 Key Unal,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
   If Key.Len = 0
    then do;
      YYY_ErrCode.Err# = %E$SpotNotMarked;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
      Call YXB$ResetBold;
      Return;
    end;  /*  if  */
 
   SIKey = Key;
   where = Column - 1;
   OutLine = 'Working';
   ComLine1 = ' ';
   Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
   Call Position( where );
 
   Return;
 
boom:
   Call AltRetError;
   Return;
 
End GotoSpot;
 
/**/
 
AnnounceSequen: Proc;
/*
      Put out the message that this is a sequential file.
*/
 
   YYY_ErrCode.Err# = %E$NoWritesSequen;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$Com ),,,,1,0 );
   Call YBB$Bell;
   Call YXB$ResetBold;
   Return;
 
End AnnounceSequen;
 
/**/
 
MakeAnnouncements: Proc AltRet;
 
   OutLine = ' ';
 
   If SequenFlag
    Then
      OutLine = 'Consec';
   
   If WorkFlag
    Then
      OutLine = 'Work File';
 
   If Buffers# > 0 and Buffers.Status.NewFile( CurrentBuffer# )
    Then
      OutLine = 'New File';
 
   If InputOnlyFlag
    Then
      OutLine = 'Read Only';
 
   ComLine1 = VersionLine;
   If Buffers# = 0
    Then
      Fid = ' ';
    Else
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
 
   If Done
    Then do;
      OutLine = ' ';
      Fid = ' ';
    End;
 
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
   Return;
 
boom:
   AltReturn;
 
End MakeAnnouncements;
 
/**/
 
HandleConflicts: Proc ( NewFid, CurBuf# );
/*
   Procedure to go through the active file list and handle any possible
   conflicts between the NewFid and active file list.
*/
 
Dcl 1 NewFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl I UBin;
Dcl Buf# UBin;
Dcl CurBuf# UBin;
 
Do I = 0 to Buffers# - 1;
   If (I ~= CurBuf#) and (Buffers.PrimaryFid.Fid( I ) = NewFid.Fid)
    Then do;  /* close the entry */
      YYY_ErrCode.Err# = %E$CloseDuplicate;
      Call YEM$ErrMsg( YYY_Errcode,, DcbNum( M$Window ),,,,1 );
 
      Buf# = CurrentBuffer#;  /*  backup  */
      If Buffers.SecondaryFid( I ) ~= ' '
       Then  /* we have to save it */
         Call SaveWorkFile( Buffers.PrimaryFid( I ),
                            Buffers.SecondaryFid( I ),
                            Buffers.Password#( I ),
                            Buffers.Status.DeleteWork( I ),
                            DcbNum( M$Window ) );
 
      CurrentBuffer# = I;
      Call SqueezeBuffers;
      If Buf# >= I
       Then
         CurrentBuffer# = Buf# - 1;
       Else
         CurrentBuffer# = Buf#;
 
      Return;
    End;  /*  if a conflict  */
 
End;  /*  do I  */
 
Return;
 
End HandleConflicts;
 
/**/
 
XEditCommand: Proc Altret;
/*
      Handle the EDIT+ and EDIT- commands, with options.
*/
 
Dcl I UBin;
Dcl Junk UBin;
Dcl WorkWas Bit(1);
Dcl Err# SBin;
Dcl Dcb# SBin;
Dcl Column UBin Half WAligned;
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl SecondaryFid Char(8);
 
   Err# = 0;
   Dcb# = 0;
 
   Call M$EraseEdit Altret ( boom );
 
   If Out.Sublk$(0) -> Out.Sublk$(0) -> Out.Code = %NextBuf
    Then do;
      Call NextBuffer( Out.Sublk$(0) -> Out.Sublk$(0) );
      Call MakeAndOpenFid( DcbNum( M$Window ) ) WhenAltReturn do; end;
      Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
    End;
    Else
      If Out.Sublk$(0) -> Out.Sublk$(0) -> Out.Code = %PrevBuf
       Then do;
         Call PrevBuffer( Out.Sublk$(0) -> Out.Sublk$(0) );
         Call MakeAndOpenFid( DcbNum( M$Window ) ) WhenAltReturn do; end;
         Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
       End;
 
   Crpt = Seeds( CurrentBuffer# );
   InputOnlyFlag = Buffers.Status.InputOnly( CurrentBuffer# );
   If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
    Then do;
      WorkWas = %True;
      WorkFlag = %True;
    End;
    Else do;
      WorkWas = %False;
      WorkFlag = %False;
    End;
 
   If Out.Sublk$(0) -> Out.Code = %Offset
    Then
      Junk = 1;
    Else
      Junk = 0;
 
   If (Junk = 0) or (Out.NSublks > 1)
    Then do;
      StripFlag = Buffers.Status.StripBlanks(CurrentBuffer#);
      VLPEditWindow2Redef = Buffers.EdtCtl(CurrentBuffer#);
      VLPEditWindowSettingsRedef = Buffers.TrmCtl(CurrentBuffer#);
      Call M$STrmCtl( EditWindowSettings ) Altret ( boom );
      Call M$STrmCtl( EditWindow2 ) Altret ( boom );
      MakeItKeyed = %False;
      Do I = 0 to Out.Sublk$(Junk) -> Out.NSublks - 1;
        Call ParseCommandLine( InputOnlyFlag, WorkFlag, Crpt,
                               Out.Sublk$(Junk) -> Out.Sublk$(I) );
      End;  /*  do I  */
 
      /* in case of changes */
      Buffers.Status.StripBlanks(CurrentBuffer#) = StripFlag;
      Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
      Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
      Buffers.EdtCtl(CurrentBuffer#) = VLPEditWindow2Redef;
      Buffers.TrmCtl(CurrentBuffer#) = VLPEditWindowSettingsRedef;
 
    End;  /*  if  */
 
   Buffers.Status.InputOnly( CurrentBuffer# ) = InputOnlyFlag;
   Seeds( CurrentBuffer# ) = Crpt;
 
/*  handle work file toggling here  */
 
   If WorkFlag ~= WorkWas
    Then
      If WorkFlag
       Then do;  /*  have to make a work file  */
         Err# = 0;
         Dcb# = 0;
         PassErrCode = '0'B;
         Call MakeWorkFile( Err#, Dcb#, PassErrCode )
          WhenReturn do;
            Call M$Close( CloseSI ) WhenAltReturn do; end;
          End;
          WhenAltReturn do;
            If Err# ~= 0
             Then do;
               YYY_ErrCode.Err# = Err#;
               Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,2 );
             End;
             Else
               Call YEM$ErrMsg( PassErrCode,, DcbNum( M$Window ),,,,2 );
 
            If Buffers# = 0
             Then
               AltReturn;
 
            NoFile = %False;
            Call RestoreSettings;
            Call MakeAndOpenFid( DcbNum( M$Window ) )
             WhenAltReturn do;
               NoFile = %True;
               AltReturn;
             End;
 
            SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
            Column = Buffers.CurrentPos.Column( CurrentBuffer# );
            If SIKey.Key > LastKey.Key
             Then do;
               SIKey.Key = LastKey.Key;
               Column = 0;
             End;
 
            Call Position( Column );
 
            AltReturn;
          End;  /*  When Altret  */
 
         Buffers.SecondaryFid( CurrentBuffer# ) = M$SI$->F$DCB.Name#.C;
       End;
       Else do;  /*  have to put away a work file  */
         PrimaryFid = Buffers.PrimaryFid( CurrentBuffer# );
         SecondaryFid = Buffers.SecondaryFid( CurrentBuffer# );
         Call SaveWorkFile( PrimaryFid, SecondaryFid,
                            Buffers.Password#( CurrentBuffer# ),
                            Buffers.Status.DeleteWork( CurrentBuffer# ),
                            DcbNum( M$Window ) );
 
         Call HandleConflicts( PrimaryFid, CurrentBuffer# );
         Buffers.PrimaryFid( CurrentBuffer# ) = PrimaryFid;
         Buffers.SecondaryFid( CurrentBuffer# ) = SecondaryFid;
       End;  /*  else  */
 
   If MakeItKeyed
    Then do;
      Call YKF$MakeItKeyed;
      Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
    End;
 
   Call RestoreSettings;
   Call MakeAndOpenFid( DcbNum( M$Window ) )
    WhenAltReturn do;
     AltReturn;
    End;
 
   SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
   Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
   If SIKey.Key > LastKey.Key
    Then do;
      SIKey.Key = LastKey.Key;
      Column = 0;
    End;
 
   Call Position( Column );
   If SequenFlag and Not InputOnlyFlag
    Then
      Call AnnounceSequen;
 
   Return;
 
boom:
   Call AltRetError;
   Return;
 
End XEditCommand;
 
/**/
 
XDoCommand: Proc;
/*
   Procedure to save the current window context, execute the ! command, then
   restore the window context.
*/
 
%FPT_TRMCTL(FPTN = OldEditWindowSettings,
             DCB = M$Edit,
          TRMCTL = OldVLPEditWindowSettings,
         VLPTYPE = TRMCTL );
 
%FPT_TRMCTL(FPTN = OldEditWindow2,
             DCB = M$Edit,
          TRMCTL = OldVLPEditWindow2,
         VLPTYPE = EDTCTL );
 
  %VLP_TRMCTL( FPTN = OldVLPEditWindowSettings );
 
  %VLP_EDTCTL( FPTN = OldVLPEditWindow2 ); /* Change to VLP when we boot E00 */
 
%FPT_YC   ( FPTN = YC,
            ECHO = NO,
         STCLASS = STATIC );
 
%FPT_READ ( FPTN = JunkRead,
             DCB = M$UC,
             BUF = ComLine2,
         STCLASS = STATIC );
 
%F_FDS ( NAME = FDSCR,
         DVFC = 'A',
          DCB = M$UC,
          BUF = FmtBuf,
      STCLASS = STATIC );
 
Dcl CRToGo Char(0) Static Init( 'Hit CR to Return to PULSE... ');
 
%FPT_DEVICE(FPTN = TabSettings,
             DCB = M$Edit,
             HDR = EOF,
             TAB = VLP_TAB,
         STCLASS = STATIC );
 
%VLP_TAB( STCLASS = STATIC );
%VLP_TAB( FPTN = Tab, STCLASS = BASED );
 
Dcl ErrDCB# UBin;
Dcl TempUse Bit(1) Unal;
Dcl TempKeep Bit(1) Unal;
 
/* start procedure */
 
YC.Cmd_ = Vector( Substr( Out.Sublk$(0) -> Sym.Text, 0,
                          Out.Sublk$(0) -> Sym.Count ) );
 
YC.V.Link# = %False;
YC.V.NoErr# = %True;
Call M$YC( YC )
 WhenAltReturn do;
   Call YEG$ErrCode( Errcode );
   If ErrCode.Err# ~= %E$RunDown
    Then do;
      Call YEM$ErrMsg( ErrCode,, DcbNum( M$Window ),,,,2 );
      Return;
    End;
 
   TempUse = AlwaysUseWorkFlag;  /* these may get messed up while in YII$IMP */
   TempKeep = KeepNewMT;
   Call M$GTrmCtl( OldEditWindowSettings ) Altret ( boom );
   Call M$GTrmCtl( OldEditWindow2 ) Altret ( boom );
   Call M$GTrmCtl( TrmCtlUC05 ) Altret ( boom );
   If M$Edit$ -> F$Dcb.Tab$ ~= Addr( Nil )
    Then
      VLP_Tab = M$Edit$ -> F$Dcb.Tab$ -> Tab;
    Else
      If M$UC$ -> F$Dcb.Tab$ ~= Addr( Nil )
       Then
         VLP_Tab = M$UC$ -> F$Dcb.Tab$ -> Tab;
 
   Call M$Close( CloseUC02 ) Altret ( boom );
   Call M$Close( CloseUC03 ) Altret ( boom );
   Call M$Close( CloseUC05 ) Altret ( boom );
   Call YWS$DownString( ExitLine, Exit#, %E$BadExitStr ); /* reset term */
 
/*  do the command here, then restore the windows  */
 
   YC.V.Link# = %True;
   YC.V.NoErr# = %False;
   Call M$YC( YC )
    WhenAltReturn do;
      Call YEG$Errcode( ErrCode, ErrDCB# );
      Call YEM$Errmsg( Errcode, ErrDCB#, DcbNum( M$UC ),,,,2 );
    end;
 
   Call X$Write(FDSCR, Vector( CRToGo ));     /* so he can see his screen */
   Call M$Read(JunkRead) WhenAltReturn do;end;/* before we put up the windows */
 
   Call M$Open( OpenUC02 )  /* Open edit window */
    WhenAltReturn do;
      Call Exeunt( %E$BadProfile );
    end;
 
   Call M$Open( OpenUC03 )  /* Open status window */
    WhenAltReturn do;
      Call Exeunt( %E$BadProfile );
    end;
 
   Call M$STrmCtl( NoScrollUC03 ) /*  turn off pagehalt and set scrolling  */
    WhenAltReturn do;
      Call Exeunt( %E$BadProfile );
    end;
 
   Call M$Open( OpenUC05 )
    WhenAltReturn do;
      Call Exeunt( %E$BadProfile );
    end;
 
   Call M$STrmCtl( TrmCtlUC05 ) Altret ( boom );
   Call M$GTrmCtl( CommandWindowSettings ) Altret ( boom );
   CommandWindowSize = VLPCommandWindowSettings.Length#;
 
   Call M$Eom( EomUC02 ) Altret ( boom );
   Call M$Eom( EomUC03Normal ) Altret ( boom );
   Call YII$IMP;  /*  context file handling  */
   Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
   Call M$Device( FPTDeviceMarker ) Altret ( boom );
   Call M$Device( TabSettings ) Altret ( boom );
   Call M$STrmCtl( OldEditWindowSettings ) Altret ( boom );
   Call M$STrmCtl( OldEditWindow2 ) Altret ( boom );
   AlwaysUseWorkFlag = TempUse;
   KeepNewMT = TempKeep;
   LastCacheEntry = -1;  /* the cache is empty for the new window */
 
   SInputUC05.Buf_.Bound = EscapeDLen - 1;
   Call M$SInput( SInputUC05 ) Altret ( boom );
 
 End;  /*  When Altret on M$YC  */
 
Return;
 
boom:
   Call AltRetError;
   Return;
 
End XDoCommand;
 
/**/
 
XCommandWindow: Proc( LocalErrCode );
/*
      This procedure will open a command window on the screen and accept
      either one of the free commands, or a line number to position the
      text on the screen.
*/
 
%VLP_ERRCODE( FPTN=LocalErrCode, STCLASS=PARAM );
 
Dcl Column UBin Half WAligned;
Dcl Thousands  UBin;
Dcl Thousandths UBin;
Dcl TextualThousandths Char(3) CAligned;
Dcl ResumeFlag Bit(1) CAligned;
Dcl Cur$ Ptr;
Dcl I UBin;
Dcl WorkWas Bit(1);
Dcl Err# Sbin;
Dcl Dcb# Sbin;
Dcl Buf# Sbin;
Dcl junk UBin;
Dcl junkstring Char(255) Based;
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl 1 TFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl SecondaryFid Char(8);
Dcl Okay Bit(1);  /* for controlling No file open message on recovery */
 
  LocalRestore: Proc;
 
      If Buffers# = 0
       Then
         Return;
 
      NoFile = %False;
      Call RestoreSettings;
      Call MakeAndOpenFid( DcbNum( M$Window ) )
        WhenAltReturn do;
          NoFile = %True;
          Return;
        End;
 
      SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
      Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
      If SIKey.Key > LastKey.Key
       Then do;
         SIKey.Key = LastKey.Key;
         Column = 0;
       End;
 
      Call Position( Column );
 
      Return;
 
  End LocalRestore;
 
  
/*  Start  */
 
If (Buffers# = 0) or TroubleFlag
  Then
    NoFile = %True;
  Else
    NoFile = %False;
 
Mode = %CommandWindow;
TroubleFlag = %False;
Call M$GTrmCtl( CommandWindowSettings ) Altret ( boom );
If VLPCommandWindowSettings.Length# ~= CommandWindowSize
 Then do;
   VLPGrow.Length# = CommandWindowSize;
   Call M$STrmCtl( FPTGrow ) Altret ( boom );
 End;  /*  if  */
 
Okay = %True;  /* for controlling No file open message on recovery */
SInputUC05.Buf_.Bound = EscapeDLen - 1;
Call M$SInput( SInputUC05 ) Altret ( boom );
 
If Addr( LocalErrCode ) ~= Addr( Nil )
 Then do;
   Okay = %False;
   Call YEM$ErrMsg( LocalErrCode,DcbNum( M$SI ),DcbNum( M$Window ),,,,4 );
   Call YXH$GoHome;  /* make sure line is clear before putting up line number */
   Junk = SIKey.Key;
   Call WhichLine( Junk, 1 );
   If Buffers# > 0
    Then do;
      Call RestoreSettings;
      Call MakeAndOpenFid( DcbNum( M$Window ) )
       WhenAltReturn do;
         NoFile = %True;
         Goto Again;
       End;
 
      SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
      Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
      If SIKey.Key > LastKey.Key
       Then do;
         SIKey.Key = LastKey.Key;
         Column = 0;
       End;
 
      Call Position( Column );
    End;  /*  if anything to restore  */
 
 End;
 
Again:
 
If NoFile and Okay
 Then do;
   OutLine = ' ';
   ComLine1 = VersionLine;
   Fid = 'No file open';
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 End;
 
Okay = %True;  /* allow No file open message, this is a holdover for recovery */
Call Xug$GetCmd( Xug_GetCmd ) Altret ( boom );
CMD$ = Xug_GetCmd.Out$;
If P_PCB.NChars > 2
 Then do;
   EscapeDBuf = P_PCB.Text$ -> JunkString;
   EscapeDLen = P_PCB.NChars;
 End;
 
Do Case Out.Code;
      Case ( %Nil );
         If NoFile then do;
            goto Again;
         end;  /*  if  */
 
      Case ( %End );
         Done = %True;
 
      Case ( %Do );
         If Not NoFile
          Then do;
            Call SaveCurrent;
            Call M$CloseSI( CloseSI )
             WhenAltReturn do;
               Call SetErrCode;
               If Errcode.Err# ~= %E$DcbClosed
                Then
                  Goto boom;
             end;  /*  Altret  */
          End;
 
         Call XDoCommand;
 
         If Not NoFile
          Then do;
            Call RestoreSettings;
            ComLine = ' ';
            Call MakeAndOpenFid( DcbNum( M$Window ) )
             WhenAltReturn do;
              NoFile = %True;
              Goto Again;
             End;
 
            SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
            Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
            If SIKey.Key > LastKey.Key
             Then do;
               SIKey.Key = LastKey.Key;
               Column = 0;
             End;
 
            Call Position( Column );
            Call MakeAnnouncements Altret ( boom );
            If SequenFlag and Not InputOnlyFlag
             Then
               Call AnnounceSequen;
 
          End;
 
         Goto Again;
 
      Case ( %Tabs );
         Call XTabsCommand( Cmd$ );
         Goto Again;
 
      Case ( %Type );
         Call XTypeCommand( Cmd$ );
         Goto Again;
 
      Case ( %Line );
         If NoFile
          then do;
            YYY_ErrCode.Err# = %E$NoWorkFile;
            Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
            goto Again;
          end;  /*  if  */
 
         Thousands = 0;
         Thousandths = 0;
 
         Do I = 0 to (Out.NSublks - 1);
           Cur$ = Out.Sublk$(I);
 
           If Cur$ -> Out.Code = %Thousandths
             Then Do;
               TextualThousandths = Cur$ -> Sym.Text;
               Call CharBin (Thousandths, TextualThousandths);
               End;
 
             Else
               Call CharBin (Thousands, Cur$ -> Sym.Text);
 
           End;  /* I = 0 to ... */
 
         If SequenFlag
          Then do;
            If Thousandths ~= 0
             Then
               Thousands = Thousands + 1;
 
            SIKey.Key = Thousands;
          End;  /*  if sequen  */
          Else
            SIKey.Key = (Thousands * 1000) + Thousandths;
 
         If SIKey.Key > LastKey.Key
          Then
            SIKey.Key = LastKey.Key;
 
         Column = 0;
         OutLine = 'Working';
         ComLine1 = ' ';
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
         Call Position( column );
         ComLine1 = ' ';
         OutLine = ' ';
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
      Case ( %Save );
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
             Goto Again;
           End;
    
         Call SaveCurrent;
         Call SaveContext
           WhenAltReturn do;
             Call RestoreSettings;
             Goto Again;
           End;
 
         Call RestoreSettings;
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         Goto Again;
 
      Case ( %Restore );
         If Not NoFile
           Then
             Call SaveCurrent;
 
         Call PutAwayFiles;
         PutAwayDone = %False;  /* we aren't getting ready to exit */
 
         Call RestoreContext
           WhenAltReturn do;
             Buffers# = 0;
             CurrentBuffer# = -1;
             NoFile = %True;
             Goto Again;
           End;
 
         Call RestoreSettings;
         ComLine = ' ';
         Call MakeAndOpenFid( DcbNum( M$Window ) )
          WhenAltReturn do;
           NoFile = %True;
           Goto Again;
          End;
  
         SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
         Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
         If SIKey.Key > LastKey.Key
          Then do;
            SIKey.Key = LastKey.Key;
            Column = 0;
          End;
  
         Call Position( Column );
         Call MakeAnnouncements Altret ( boom );
         If SequenFlag and Not InputOnlyFlag
          Then
            Call AnnounceSequen;
 
      Case ( %Transform );
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
             Goto Again;
           End;
    
         Call SaveCurrent;
         Call M$CloseSI( CloseSI )
           WhenAltReturn do;
             Call SetErrCode;
             WorkFlag = %False;
             If ErrCode.Err# ~= %E$DCBCLOSED
              then
                goto boom;
           end; /* When Altret */
  
         Call TransformBuffers;
         Call RestoreSettings;
         Call MakeAndOpenFid( DcbNum( M$Window ) )
          WhenAltReturn do;
            NoFile = %True;
            Goto Again;
          End;
 
         SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
         Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
         If SIKey.Key > LastKey.Key
          Then do;
            SIKey.Key = LastKey.Key;
            Column = 0;
          End;
   
         Call Position( Column );
         Call MakeAnnouncements Altret ( boom );
         NoFile = %False;
         Goto Again;
  
      Case ( %CloseFile, %CloseOffset );
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
             Goto Again;
           End;
   
         Call SaveCurrent;
         Call M$CloseSI( CloseSI )
           WhenAltReturn do;
             Call SetErrCode;
             WorkFlag = %False;
             If ErrCode.Err# ~= %E$DCBCLOSED
              then
                goto boom;
           end; /* When Altret */
 
         DeleteFlag = %False;
         Call CloseBuffer;
         If Buffers# = 0
           Then do;
             NoFile = %True;
             Goto Again;
           End;
 
         Call RestoreSettings;
         Call MakeAndOpenFid( DcbNum( M$Window ) )
          WhenAltReturn do;
           NoFile = %True;
           Goto Again;
          End;
  
         SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
         Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
         If SIKey.Key > LastKey.Key
          Then do;
            SIKey.Key = LastKey.Key;
            Column = 0;
          End;
   
         Call Position( Column );
         Call MakeAnnouncements Altret ( boom );
         If SequenFlag and Not InputOnlyFlag
          Then
            Call AnnounceSequen; 
 
         NoFile = %False;
         Goto Again; 
 
      Case ( %DeleteFile, %DeleteOffset );
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
             Goto Again;
           End;
  
         Call SaveCurrent;
         Call M$CloseSI( CloseSI )
           WhenAltReturn do;
             Call SetErrCode;
             WorkFlag = %False;
             If ErrCode.Err# ~= %E$DCBCLOSED
              then
                goto boom;
           end; /* When Altret */
 
         DeleteFlag = %True;
         Call CloseBuffer;
         DeleteFlag = %False;
         If Buffers# = 0
           Then do;
             NoFile = %True;
             Goto Again;
           End;
  
         Call RestoreSettings;
         Call MakeAndOpenFid( DcbNum( M$Window ) )
          WhenAltReturn do;
           NoFile = %True;
           Goto Again;
          End;
  
         SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
         Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
         If SIKey.Key > LastKey.Key
          Then do;
            SIKey.Key = LastKey.Key;
            Column = 0;
          End;
   
         Call Position( Column );
         Call MakeAnnouncements Altret ( boom );
         If SequenFlag and Not InputOnlyFlag
          Then
            Call AnnounceSequen; 
 
         NoFile = %False;
         Goto Again;
  
      Case ( %List );
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
             Goto Again;
           End;
 
         Call SaveCurrent;
         Call ListBuffers;
         Goto Again;  /*  so the guy has a chance to read the list  */
 
      Case ( %Edit );
         If Buffers# = 1
          Then
            If Buffers.Status.WorkMissing( 0 )
             Then do;
               YYY_ErrCode.Err# = %E$MissingWorkFile;
               Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,2 );
               Goto Again;
             End;
 
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,1 );
             Goto Again;
           End;
 
         If Out.NSublks > 0
          Then do;
            If Not NoFile
             Then
               Call SaveCurrent;
 
            Call M$CloseSI( CloseSI )
              WhenAltReturn do;
                Call SetErrCode;
                WorkFlag = %False;
                If ErrCode.Err# ~= %E$DCBCLOSED
                 then
                   goto boom;
              end; /* When Altret */
 
            If Out.Sublk$(0) -> Out.Code = %OffSet
             Then
               Call CheckIfEmpty
                WhenAltReturn do;  /*  deleted the empty file  */
                  Call SqueezeBuffers;
                  If Out.Sublk$(0) -> Out.Sublk$(0) -> Out.Code = %NextBuf
                   Then  /* have to adjust for next */
                     CurrentBuffer# = CurrentBuffer# - 1;
 
                  If CurrentBuffer# < 0
                   Then
                     CurrentBuffer# = Buffers# + CurrentBuffer#;
 
                End;  /*  When Altret  */
 
            Call XEditCommand
             WhenAltReturn do;
               NoFile = %True;
               Goto Again;
             End;
 
          End;  /*  if there are some sub blocks  */
          Else
            If NoFile      /* in case we're in trouble for some reason */
             Then          /* we don't want to let him in the edit window */
               Goto Again; /* with a corrupt file entry */
 
      Case ( %NextBuf, %PrevBuf );
         If Buffers# = 1
          Then
            If Buffers.Status.WorkMissing( 0 )
             Then do;
               YYY_ErrCode.Err# = %E$MissingWorkFile;
               Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,2 );
               Goto Again;
             End;
             Else
               If Not NoFile
                Then
                  Goto fin;
 
         If NoFile and (Buffers# = 0)
           Then do;
             YYY_ErrCode.Err# = %E$NoWorkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,1 );
             Goto Again;
           End;
   
         If Not NoFile
          Then
            Call SaveCurrent;
 
         Call M$CloseSI( CloseSI )
           WhenAltReturn do;
             Call SetErrCode;
             WorkFlag = %False;
             If ErrCode.Err# ~= %E$DCBCLOSED
              then
                goto boom;
           end; /* When Altret */
 
         Call CheckIfEmpty
          WhenAltReturn do;  /*  deleted the empty file  */
            Call SqueezeBuffers;
            If Out.Code = %NextBuf
             Then do;   /*  have to adjust for next  */
               CurrentBuffer# = CurrentBuffer# - 1;
               If CurrentBuffer# < 0
                Then
                  CurrentBuffer# = Buffers# + CurrentBuffer#;
 
             End;  /*  if NextBuf  */
 
          End;  /*  When Altret  */
 
         Call M$EraseEdit Altret ( boom );
         If Out.Code = %NextBuf
          Then
            Call NextBuffer( CMD$ );
          Else
            Call PrevBuffer( CMD$ );
 
         Call RestoreSettings;
         Call MakeAndOpenFid( DcbNum( M$Window ) )
          WhenAltReturn do;
           NoFile = %True;
           Goto Again;
          End;
 
         SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
         Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
         If SIKey.Key > LastKey.Key
          Then do;
            SIKey.Key = LastKey.Key;
            Column = 0;
          End;
   
         Call Position( Column );
         If SequenFlag and Not InputOnlyFlag
          Then
            Call AnnounceSequen;
 
      Case ( %Switch );
 
         If Buffers# > 0 and Not NoFile
          Then
            Call SaveCurrent;
 
         NoFile = %True;
         Call M$CloseSI( CloseSI )
           WhenAltReturn do;
             Call SetErrCode;
             WorkFlag = %False;
             If ErrCode.Err# ~= %E$DcbClosed
              then
                goto boom;
           end; /* When Altret */
 
         EditOldFile.V.Fun# = %Update#;   /*  Default to update  */
         Call CheckIfEmpty
          WhenAltReturn do;  /*  deleted the empty file  */
            Call SqueezeBuffers;
            CurrentBuffer# = CurrentBuffer# - 1; /* have to adjust for insert */
            If CurrentBuffer# < 0
             Then
               CurrentBuffer# = Buffers# + CurrentBuffer#;
 
          End;
 
         Fid = Out.Sublk$( 0 ) -> Sym.Text;
         InputOnlyFlag = %False;
         WorkFlag = AlwaysUseWorkFlag;
         Crpt = '0'B;
 
         If Out.NSublks > 1
          then do;  /*  must be an option  */
            Do I = 0 to Out.Sublk$( 1 ) -> Out.NSublks - 1;
              Call ParseCommandLine( InputOnlyFlag, WorkFlag, Crpt,
                                     Out.Sublk$(1) -> Out.Sublk$(I) );
            end;  /*  do I  */
 
          end;  /*  if  */
         
         Call M$Fid( MakeFid ) Altret ( PrintError );
         Call GetTestFid( M$Window# )
          WhenAltReturn do;
            Call LocalRestore;
            Goto Again;
          End;
 
         Call YYY$FillIn( TFid );
         Call CheckBuffers( TFid, Buf# )
           WhenReturn do;  /*  check for changed options  */
             /*  well, we'll have to parse that command again  */
             Crpt = Seeds( Buf# );
             InputOnlyFlag = Buffers.Status.InputOnly( Buf# );
             If Buffers.SecondaryFid( Buf# ) ~= ' '
              Then do;
                WorkWas = %True;
                WorkFlag = %True;
              End;
              Else do;
                WorkWas = %False;
                WorkFlag = %False;
              End;
 
             If Out.NSublks > 1
              Then do;
                StripFlag = Buffers.Status.StripBlanks(CurrentBuffer#);
                VLPEditWindow2Redef = Buffers.EdtCtl( Buf# );
                VLPEditWindowSettingsRedef = Buffers.TrmCtl( Buf# );
                Call M$STrmCtl( EditWindowSettings ) Altret ( boom );
                Call M$STrmCtl( EditWindow2 ) Altret ( boom );
                MakeItKeyed = %False;
                Do I = 0 to Out.Sublk$(1) -> Out.NSublks - 1;
                   Call ParseCommandLine( InputOnlyFlag, WorkFlag, Crpt,
                                          Out.Sublk$(1) -> Out.Sublk$(I) );
                End;  /*  do I  */
 
                /* in case of changes */
                Buffers.Status.StripBlanks(CurrentBuffer#) = StripFlag;
                Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
                Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
                Buffers.EdtCtl( Buf# ) = VLPEditWindow2Redef;
                Buffers.TrmCtl( Buf# ) = VLPEditWindowSettingsRedef;
 
              End;  /*  if  */
 
             Buffers.Status.InputOnly( Buf# ) = InputOnlyFlag;
             Seeds( Buf# ) = Crpt;
 
/*  handle work file toggling here  */
 
             If (WorkFlag ~= WorkWas)
              Then
                If WorkFlag
                 Then do;
                   Err# = 0;
                   Dcb# = 0;
                   PassErrCode = '0'B;
                   Call MakeWorkFile( Err#, Dcb#, PassErrCode )
                    WhenReturn do;
                      Call M$Close( CloseSI ) WhenAltReturn do; end;
                    End;
                    WhenAltReturn do;
                      If Err# ~= 0
                       Then do;
                         YYY_ErrCode.Err# = Err#;
                         Call YEM$ErrMsg(YYY_ErrCode,, DcbNum(M$Window),,,,2);
                       End;
                       Else
                         Call YEM$ErrMsg(PassErrCode,, DcbNum(M$Window),,,,2);
 
                      Call LocalRestore;
                      Goto Again;
                    End;  /*  When Altret  */
 
                   Buffers.SecondaryFid( CurrentBuffer# )=M$SI$->F$DCB.Name#.C;
                 End;
                 Else do; /*  have to put away a work file  */
                  PrimaryFid = Buffers.PrimaryFid( CurrentBuffer# );
                  SecondaryFid = Buffers.SecondaryFid( CurrentBuffer# );
                  Call SaveWorkFile( PrimaryFid, SecondaryFid,
                                     Buffers.Password#( CurrentBuffer# ),
                                     Buffers.Status.DeleteWork( CurrentBuffer# ),
                                     DcbNum( M$Window ) );
 
                  Call HandleConflicts( PrimaryFid, CurrentBuffer# );
                  Buffers.PrimaryFid( CurrentBuffer# ) = PrimaryFid;
                  Buffers.SecondaryFid( CurrentBuffer# ) = SecondaryFid;
                 End;  /*  else  */
 
              CurrentBuffer# = Buf#;
              ResumeFlag = %True;
              If MakeItKeyed
               Then do;
                 Call YKF$MakeItKeyed;
                 Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
               End;
 
           End;  /* When Return */
           WhenAltReturn do;
              If Buffers# >= SizeW( Seeds )
                Then do;
                  YYY_ErrCode.Err# = %E$NotEnoughBuffers;
                  Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,3 );
                  Goto Again;
                End;  /*  if way too many  */
 
              If Buffers# >= MaxBuffers#
                Then do;
                   Call M$GDS( GDS )
                    WhenAltReturn do;
                      YYY_ErrCode.Err# = %E$NotEnoughBuffers;
                      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,3 );
                      Goto Again;
                    End;  /*  When Altret  */
 
                   CurrentPages# = CurrentPages# + 1;
                   MaxBuffers# = CurrentPages# * 1024 / LengthW(Buffers(0));
                End;
 
              CurrentBuffer# = CurrentBuffer# + 1;
              Call SpreadBuffers;
              ResumeFlag = %False;
           End;  /*  When Altret  */
 
         Call M$EraseEdit Altret ( boom );
 
         If ResumeFlag
          Then do;
            Call RestoreSettings;
            Call MakeAndOpenFid( DcbNum( M$Window ) )
             WhenAltReturn do;
               NoFile = %True;
               Goto Again;
             End;
 
            SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
            Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
            If SIKey.Key > LastKey.Key
             Then do;
               SIKey.Key = LastKey.Key;
               Column = 0;
             End;
   
            Call Position( Column );
          End;  /*  if resuming  */
          Else do;  /*  opening a new file for the active file list  */
            Call OpenEditFile( Err#, Dcb#, PassErrCode )
             WhenReturn do;
              Call UnMark;
              Call SetFcnTbl;
              Do I = 0 to 10;
                Spots.Key.Len(I) = 0;  /*  unmark the spots  */
                Spots.Key.Key(I) = 0;
                Spots.Column(I) = 0;
              End;  /*  do I  */
              If MakeItKeyed
               Then
                 Call YKF$MakeItKeyed;
 
             End;  /*  When Return  */
             WhenAltReturn do;
               UCKey = 0;
               SIKey.Key = 0;
               If Err# = 0
                then
                  Call YEM$ErrMsg( PassErrCode,, DcbNum( M$Window ),,,,2 );
                else do;
                  YYY_ErrCode.Err# = Err#;
                  Call YEM$ErrMsg( YYY_Errcode, Dcb#, DcbNum( M$Window ),,,,2 );
                end;  /*  else  */
               
               Call SqueezeBuffers;
               CurrentBuffer# = CurrentBuffer# - 1;
               If CurrentBuffer# < 0 and Buffers# > 0
                Then
                  CurrentBuffer# = Buffers# + CurrentBuffer#;
 
               Call LocalRestore;
               Goto Again;
             end;   /*  When Altret  */
 
           If WorkFlag
            Then
              Buffers.SecondaryFid( CurrentBuffer# ) = M$SI$->F$DCB.Name#.C;
            Else do;
              Call YYY$FillIn( Buffers.PrimaryFid( CurrentBuffer# ) );
              Buffers.SecondaryFid( CurrentBuffer# ) = ' ';
            End;
 
           Seeds( CurrentBuffer# ) = Crpt;
           If Crpt ~= '0'B
            Then
              Buffers.Status.Encrypted( CurrentBuffer# ) = %True;
            Else
              Buffers.Status.Encrypted( CurrentBuffer# ) = %False;
 
           ReadSI.V.Seed# = Crpt;
           ReadSIByKey.V.Seed# = Crpt;
           WriteSI.V.Seed# = Crpt;
 
           Call GetFirst( DcbNum( M$Window ) )
             WhenAltReturn do;
              Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
              Call SqueezeBuffers;
              CurrentBuffer# = CurrentBuffer# - 1;
              If CurrentBuffer# < 0 and Buffers# > 0
               Then
                CurrentBuffer# = Buffers# + CurrentBuffer#;
 
              Call LocalRestore;
              Goto Again;
             End;
 
          End;  /*  else  */
 
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         If SequenFlag and Not InputOnlyFlag
          Then
            Call AnnounceSequen; 
 
      Case ( Else );
         If NoFile then do;
            goto Again;
         end;  /*  if  */
 
End; /*  Case  */
 
fin:
   VLPGrow.Length# = %Window_AbsVal# + 1;
   Call M$STrmCtl( FPTGrow ) Altret ( boom );
   Return;
 
boom:
   Call AltretError;
   Return;
 
PrintError:
   Call YEM$ErrMsg( ,,DcbNum( M$Window ),,,,3 );
   Call RestoreSettings;
   If Buffers.Password#( CurrentBuffer# ) ~= ' '
    Then do;
      BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
      EditOldFile.IFParam_ = Vector( BabyFIT );
    End;
    Else
      EditOldFile.IFParam_ = Vector( NIL );
 
   Call M$OpenSI( EditOldFile ) Altret ( boom );  /* re-open M$SI */
   Goto Again;
         
End XCommandWindow;
 
/**/
 
YYY$SuckOut: Proc ( TFid );
/*
      Fill in VLPSIxxxxs from TFid
*/
 
Dcl 1 TFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
   If TFid.PSN# ~= ' '
    Then do;
      VLPSISN.SN#(0) = TFid.PSN#;
      VLPSISN.Num# = 1;
    End;
    Else do;
      VLPSISN.SN#(0) = ' ';
      VLPSISN.Num# = 0;
    End;
 
   VLPSINAME = TFid.Fid.Name#;
   VLPSIAcct.Acct# = TFid.Fid.Acct#;
   Return;
 
End YYY$SuckOut;
 
/**/
 
MakeAndOpenFid: Proc (Dcb#) AltRet;
/*
      Procedure to take the newly restored filename and open it up
*/
 
Dcl Dcb# UBin Param;
 
   Buffers.Status.WorkMissing( CurrentBuffer# ) = %False;
 
   If Buffers.SecondaryFid( Currentbuffer# ) ~= ' '
    Then do;
      Fid = Buffers.SecondaryFid( CurrentBuffer# );
      Call M$Fid( MakeFid ) Altret ( boom );
    End;
    Else
      Call YYY$SuckOut( Buffers.PrimaryFid( CurrentBuffer# ) );
 
   If Buffers.Status.InputOnly( CurrentBuffer# )
    Then
      EditFidFile.V.Fun# = %In#;
    Else
      EditFidFile.V.Fun# = %Update#;   /*  Default to update  */
 
   If Buffers.Password#( CurrentBuffer# ) ~= ' '
    Then do;
      BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
      EditFidFile.IFParam_ = Vector( BabyFIT );
    End;
    Else
      EditFidFile.IFParam_ = Vector( NIL );
 
   If Not Buffers.Status.NewFile( CurrentBuffer# )
    Then
      Call M$OpenSI( EditFidFile ) Altret ( boom );
    Else do;
      Call M$OpenSI( EditFidFile )
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# ~= %E$NoFile
          Then
            Goto boom;
 
         Call M$Open( EditNewFile ) AltRet ( boom );
         Call M$Close( CloseSI ) AltRet ( boom );
         EditOldFile.V.Fun# = %Update#;
         Call M$Open( EditOldFile ) AltRet ( boom );
       End;  /*  When Altret  */
    End;  /*  else  */
 
   If Not M$SI$ -> F$Dcb.FFlg.Read#
    Then do;
      Call M$Close( CloseSI ) WhenAltReturn do; end;
      YYY_ErrCode.Err# = %E$CantRead;
      If Dcb# = DcbNum( M$Window )
       Then
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
       Else
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2,0 );
 
      AltReturn;
    End;
 
   If (M$SI$ -> F$Dcb.Comp#) and (Not InputOnlyFlag) and
      ((M$SI$ -> F$Dcb.Org# = %Consec#) or (M$SI$ -> F$Dcb.Org# = %UR#))
    Then do;
      Call M$Close( CloseSI ) WhenAltReturn do; end;
      YYY_ErrCode.Err# = %E$CompressedFile;
      If Dcb# = DcbNum( M$Window )
       Then
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
       Else
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2,0 );
 
      AltReturn;
    End;
 
   If M$SI$ -> F$Dcb.Org# = %Keyed#
    Then do;
      SequenFlag = %False;
      Buffers.Status.Sequen( CurrentBuffer# ) = %False;
    End;
    Else do;
      SequenFlag = %True;
      Buffers.Status.Sequen( CurrentBuffer# ) = %True;
    End;
 
   Call FigureOutLast;
   If (M$SI$ -> F$Dcb.Org# = %UR#) and Not InputOnlyFlag
    Then do;
      YYY_ErrCode.Err# = %E$CantEditUR;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
      Call YXB$ResetBold;
      InputOnlyFlag = %True;
      Call SetFcnTbl;
    end;
 
   UpAttr = ( %FFlg_DelR# | %FFlg_WNew# | %FFlg_Upd# );
   If (UpAttr & ( M$SI$ -> F$Dcb.FFLG )) ~= UpAttr
    Then
      InputOnlyFlag = %True;
 
   Return;
 
boom:
   Call YEG$ErrCode( ErrCode );
   If (ErrCode.Err# = %E$NoFile) and (Buffers.SecondaryFid( CurrentBuffer# ) ~= ' ')
    Then do;
      YYY_ErrCode.Err# = %E$MissingWorkFile;
      If Dcb# = DcbNum( M$Window )
       Then
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
       Else
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2,0 );
 
      Buffers.Status.WorkMissing( CurrentBuffer# ) = %True;
    End;
    Else
      If Dcb# = DcbNum( M$Window )
       Then
         Call YEM$ErrMsg( ErrCode,, Dcb#,,,,3 );
       Else
         Call YEM$ErrMsg( ErrCode,, Dcb#,,,,3,0 );
   
   AltReturn;
 
End MakeAndOpenFid;
 
/**/
 
CheckBuffers: Proc( Fid, Buf# ) Altret;
/*
      Check the current buffers to see if the Fid is already being used
*/
 
Dcl I UBin;
Dcl 1 Fid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl Buf# SBin Param;
 
Do I = 0 to Buffers# - 1;
   If Buffers.PrimaryFid.Fid( I ) = Fid.Fid
    Then do;
      Buf# = I;
      Return;
    End;
End;  /*  do  */
 
AltReturn;
 
End CheckBuffers;
 
/**/
 
TransformBuffers: Proc;
/*
      Go through the buffer list and offer to make each work file into a
      permanent file.
*/
 
Dcl I UBin;
Dcl PFid Char(60);
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl SecondaryFid Char(8);
 
Do I = 0 to Buffers# - 1;
   If Buffers.SecondaryFid( I ) ~= ' '
    Then do;
      Call YYY$MakeFid( PFid, Buffers.PrimaryFid( I ) );
      Call X$Write( FDSVFC, Vector( WorkFileFormat ),
                            Vector( PFid ) );
      Call XUG$GetCmd( Xug_GetCmd2 )
       WhenReturn do;
         PrimaryFid = Buffers.PrimaryFid( I );
         SecondaryFid = Buffers.SecondaryFid( I );
         Call SaveWorkFile( PrimaryFid, SecondaryFid,
                            Buffers.Password#( I ),
                            Buffers.Status.DeleteWork( I ),
                            DcbNum( M$Window ) );
 
         Call HandleConflicts( PrimaryFid, I );
         Buffers.PrimaryFid( I ) = PrimaryFid;
         Buffers.SecondaryFid( I ) = SecondaryFid;
         Buffers.Status.Changed( I ) = %True;
       End;  /*  When Return  */
       WhenAltReturn do;
         YYY_ErrCode.Err# = %E$NotChanged;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,1 );
       End;
    End;  /*  if  */
End;  /*  do I  */
 
Return;
 
End TransformBuffers;
 
/**/
 
NextBuffer: Proc( Local$ );
/*
      Procedure to go to the buffer after the current one
*/
 
Dcl OffSet UBin;
Dcl Local$ Ptr;
%Parse$Out ( Name = Out, StClass = "BASED(Local$)");
%Parse$Sym ( Name = Sym, StClass = "BASED(Local$)");
 
   If (Addr(Local$) ~= Addr(Nil)) and (Out.NSublks > 0)
    Then do;
      Call CharBin( OffSet, Out.Sublk$(0) -> Sym.Text );
      CurrentBuffer# = Mod( CurrentBuffer# + OffSet, Buffers# );
    End;
    Else
      CurrentBuffer# = Mod( CurrentBuffer# + 1, Buffers# );
 
   Return;
 
End NextBuffer;
 
/**/
 
PrevBuffer: Proc( Local$ );
/*
      Procedure to go to the buffer before the current one
*/
 
Dcl OffSet UBin;
Dcl Local$ Ptr;
%Parse$Out ( Name = Out, StClass = "BASED(Local$)");
%Parse$Sym ( Name = Sym, StClass = "BASED(Local$)");
  
   If (Addr(Local$) ~= Addr(Nil)) and (Out.NSublks > 0)
    Then do;
      Call CharBin( OffSet, Out.Sublk$(0) -> Sym.Text );
      CurrentBuffer# = Mod( CurrentBuffer# - OffSet, Buffers# );
    End;
    Else
      CurrentBuffer# = Mod( CurrentBuffer# - 1, Buffers# );
 
   If CurrentBuffer# < 0
    Then
      CurrentBuffer# = CurrentBuffer# + Buffers#;
 
   Return;
 
End PrevBuffer;
 
/**/
 
ListBuffers: Proc;
/*
      Procedure to list the buffers a user currently has
*/
 
Dcl I UBin;
Dcl offset SBin;
Dcl diff SBin;
Dcl sign Char(1);
Dcl kind Char(2);
Dcl len UBin;
Dcl Start SBin;
Dcl Halfway SBin;
Dcl name Char(60);
 
 ListIt: Proc;  /* internal */
 
   kind = ' ';
   len = 0;
   If Buffers.Status.Sequen( Start )
    then do;
      Substr(kind,len,1) = 'c';
      len = len + 1;
    end;
 
   If Buffers.SecondaryFid( Start ) ~= ' '
    then do;
      Substr(kind,len,1) = 'w';
      len = len + 1;
    end;
 
   If Buffers.Status.InputOnly( Start )
    then do;
      Substr(kind,len,1) = 'r';
      len = len + 1;
    end;
  
   Call YYY$MakeFid( name, Buffers.PrimaryFid( Start ) );
   If Start ~= CurrentBuffer#
    Then do;
     If offset < 0
      Then do;
        sign = '-';
        diff = offset * (-1);
      End;  /*  if  */
      Else do;
        sign = '+';
        diff = offset;
      End;  /*  else  */
  
     If diff = 1
      Then
       Call X$Write( FDS, Vector( Buffer1Format ),
                          Vector( sign ),
                          Vector( kind ),
                          Vector( name ) );
      Else
       Call X$Write( FDS, Vector( BufferFormat ),
                          Vector( sign ), Vector( diff ),
                          Vector( kind ),
                          Vector( name ) );
 
    End;  /*  if  */
    Else
      Call X$Write( FDS, Vector( ThisBufferFormat ),
                         Vector( kind ),
                         Vector( name ) );
 
 End; /* list it */
 
/* start ListBuffers */
 
Halfway = (Buffers# - 1) / 2;
Start = CurrentBuffer# - Halfway;
If Start < 0
 Then
   Start = Buffers# + Start;
 
OffSet = -Halfway;
Do I = 1 to Buffers#;
   Call ListIt;
   OffSet = OffSet + 1;
   Start = Start + 1;
   If Start >= Buffers#
    Then
      Start = 0;
 
End;  /*  do I  */
 
Return;
 
End ListBuffers;
 
/**/
 
GetTestFid: Proc(Dcb#_) AltRet;
/*
      Get the full file name for Fid
*/
 
Dcl junk UBin;
Dcl Dcb#_ UBin(18) Param;  /* where to put the error message */
Dcl Dcb# UBin Word Static Unal;
 
   Dcb# = Dcb#_;
   TestDCB.V.ASN# = ASNJunk;
   TestDCB.V.RES# = RESJunk;
   Call M$OpenSI( TestDCB )
    WhenAltReturn do;
      Call SetErrCode;
      If ErrCode.Err# ~= %E$NoFile
        Then do;
          Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), Dcb#,,,,2 );
          AltReturn;
        End;
      If M$SI$->F$Dcb.Name#.L = 0
       Then do;
        YYY_ErrCode.Err# = %E$ICantEditDat;
        Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
        AltReturn;
       End;
      Call Index( junk, '?', M$SI$->F$Dcb.Name#.C )
       WhenReturn do;
        YYY_ErrCode.Err# = %E$ICantEditDat;
        Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
        AltReturn;
       End;
    End;
 
   If M$SI$ -> F$Dcb.Asn# ~= %File#
    Then do;
       YYY_ErrCode.Err# = %E$NotADiskFile;
       Call YEM$ErrMsg( YYY_ErrCode, DcbNum( M$SI ), Dcb#,,,,2 );
       AltReturn;
    End;
 
   Return;
 
End GetTestFid;
 
/**/
 
FigureOutNewCurrent: Proc AltRet;
/*
      Parse the Close/Delete command and figure out which buffer the
      user is referring to.
*/
 
Dcl Buf# Sbin;
Dcl 1 TFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
   If (Out.Code = %CloseOffset) or (Out.Code = %DeleteOffset)
    Then
      If Out.Sublk$(0) -> Out.Sublk$(0) -> Out.Code = %NextBuf
       Then
         Call NextBuffer( Out.Sublk$(0) -> Out.Sublk$(0) );
       Else
         Call PrevBuffer( Out.Sublk$(0) -> Out.Sublk$(0) ); 
 
    Else do;  /*  it's a filename  */
      Fid = Out.Sublk$(0) -> Sym.Text;
      Call M$Fid( MakeFid ) Altret ( PrintError );
      Call GetTestFid( M$Window# )
       WhenAltReturn do;
         AltReturn;
       End;
 
      Call YYY$FillIn( TFid );
      Call CheckBuffers( TFid, Buf# )
       WhenReturn do;
         CurrentBuffer# = Buf#;
         Return;
       End;
       WhenAltReturn do;
         YYY_ErrCode.Err# = %E$NotOneOfYourBuffers;
         Call YEM$ErrMsg( YYY_ErrCode, DcbNum( M$SI ), DcbNum( M$Window ),,,,2 );
         AltReturn;
       End;
 
    End;  /*  else  */
 
   Return;
 
PrintError:
   Call YEM$ErrMsg( ,, DcbNum( M$Window ),,,,3 );
   AltReturn;
 
End FigureOutNewCurrent;
 
/**/
 
CloseBuffer: Proc;
/*
      Procedure to close out one of the user's buffers
*/
 
Dcl tempbuffer# SBin;
Dcl name Char(60);
 
   If Out.NSublks > 0
    Then do;
      tempbuffer# = CurrentBuffer#;
      Call FigureOutNewCurrent
       WhenAltReturn do;
         CurrentBuffer# = tempbuffer#;
         Return;
       End;
    End;  /*  if  */
    Else
      tempbuffer# = 1;  /*  just so it has something to do  */
 
   If DeleteFlag
    Then do;
      If (Not KeepNewMT) and Buffers.Status.NewFile( CurrentBuffer# ) and
         (M$SI$->F$Dcb.NRecs#=0)
       Then
         Goto JustDoIt;
       Else do;
         Call YYY$MakeFid( name, Buffers.PrimaryFid(CurrentBuffer#) );
         If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
          Then
            Call X$Write( FDSVFC, Vector(DeleteWorkFormat),
                                  Vector(name));
          Else
            Call X$Write( FDSVFC, Vector(DeleteBufferFormat),
                                  Vector(name));
 
         Call XUG$GetCmd( Xug_GetCmd2 )
          WhenReturn do;
JustDoIt:   If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
             Then
               Fid = Buffers.SecondaryFid( CurrentBuffer# );
             Else
               Call YYY$MakeFid( Fid, Buffers.PrimaryFid(CurrentBuffer#) );
 
            If Buffers.Status.DeleteWork( CurrentBuffer# )
             Then
               Call YDW$DeleteFile( Buffers.Password#(CurrentBuffer#) )
                WhenAltReturn do;
                  Call YEM$ErrMsg( ,, DcbNum(M$Window),,,,2 );
                End;
 
            If tempbuffer# >= CurrentBuffer#
             Then
               tempbuffer# = tempbuffer# - 1;
 
            Call SqueezeBuffers;
          End;  /*  When Return  */
          WhenAltReturn do;
           If Out.NSublks > 0
            Then
              CurrentBuffer# = tempbuffer#;
 
           YYY_ErrCode.Err# = %E$NothingDeleted;
           Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Window),,,,1 );
           Return;
          End;  /*  When Altret  */
       End;  /*  else  */
    End;  /*  if delete  */
    Else do;
      If tempbuffer# >= CurrentBuffer#
       Then
         tempbuffer# = tempbuffer# - 1;
 
      If (Buffers.SecondaryFid( CurrentBuffer# ) ~= ' ') and
         (Not Buffers.Status.WorkMissing( CurrentBuffer# )) and
         (Not (Buffers.Status.NewFile( CurrentBuffer# ) and
         (M$SI$ -> F$Dcb.NRecs# = 0) and (Not KeepNewMT)))
       Then
        If Buffers.Status.Changed( CurrentBuffer# )
         Then
          Call SaveFileQuery( CurrentBuffer# )
           WhenReturn do;
            Call SaveWorkFile( Buffers.PrimaryFid( CurrentBuffer# ),
                               Buffers.SecondaryFid( CurrentBuffer# ),
                               Buffers.Password#( CurrentBuffer# ),
                               Buffers.Status.DeleteWork( CurrentBuffer# ),
                               DcbNum( M$Window ) );
           End;  /*  When Return  */
           WhenAltReturn do;
            If Buffers.Status.DeleteWork( CurrentBuffer# )
             Then do;
               Fid = Buffers.SecondaryFid( CurrentBuffer# );
               Call YDW$DeleteFile( Buffers.Password#(CurrentBuffer#) )
                                    altret ( boom );
             End;
           End;  /*  When Altret  */
         Else Do;
           If Buffers.Status.DeleteWork( CurrentBuffer# )
            Then do;
              Fid = Buffers.SecondaryFid( CurrentBuffer# );
              Call YDW$DeleteFile( Buffers.Password#(CurrentBuffer#) )
                                   altret ( boom );
            End;  /* if */
         End;  /* else */
           /* The next ELSE is from the work file check above */
       Else
         If Buffers.Status.WorkMissing( CurrentBuffer# )
          Then do;
             YYY_ErrCode.Err# = %E$MissingworkFile;
             Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,2 );
           End;
           Else
             Call CheckIfEmpty
              WhenAltReturn do;
              End;
 
      Call SqueezeBuffers;
    End;  /* else from delete or close */
 
   If Out.NSublks > 0
    Then
      CurrentBuffer# = tempbuffer#;
    Else
      CurrentBuffer# = CurrentBuffer# - 1;
 
   If Buffers# > 0 and CurrentBuffer# < 0
    Then
      CurrentBuffer# = Buffers# + CurrentBuffer#;
 
   If (Buffers# = 0) or (Out.NSublks = 0)
    Then
      Call M$EraseEdit Altret ( boom );
 
   Return;
 
boom:
   Call AltretError;
   Return;
 
End CloseBuffer;
 
/**/
 
SaveContext: Proc Altret;
/*
      Procedure to dump out the info for the user's current buffers
*/
 
Fid = Out.Sublk$( 1 ) -> Sym.Text;
Do Case Out.Sublk$( 0 ) -> Out.Sublk$( 0 ) -> Out.Code;
   Case( %On );
      OpenContext.V.Exist# = %Error#;
 
   Case( %Over );
      OpenContext.V.Exist# = %NewFile#;
 
   Case( Else );
End;  /*  case  */
 
Call YSC$SaveContext AltRet (PrintError);
Return;
 
PrintError:
   Call YEM$ErrMsg( ,, DcbNum( M$Window ),,,,3 );
   AltReturn;
 
End SaveContext;
 
/**/
 
RestoreContext: Proc AltRet;
/*
      Procedure to read in a dump of a user's context
*/
 
Dcl I UBin;
Dcl Count UBin;
Dcl Junk UBin;
Dcl JunkVersion Char(4);
 
Mode = %Restoring;
BrokenFlag = %False;
Fid = Out.Sublk$( 0 ) -> Sym.Text;
 
Call M$Fid( MakeContextFid ) Altret ( PrintError );
Call M$Open( OpenContextIn ) Altret ( PrintError );
If M$OU$ -> F$Dcb.Type# ~= 'Wp'
 Then do;
   Call M$Close( CloseOU ) WhenAltReturn do; end;
   YYY_ErrCode.Err# = %E$BadContextFile;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,2 );
   AltReturn;
 End;
 
ReadContext.Buf_ = Vector( JunkVersion );
JunkVersion = ' ';
Call M$Read( ReadContext ) Altret ( PrintError );  /* read in version */
If (JunkVersion ~= Version) and (JunkVersion < %ContVersionReal) and
   (JunkVersion < %ContVersionFake)
 Then do;
   YYY_ErrCode.Err# = %E$BadVersion;
   Call YEM$ErrMsg( YYY_Errcode,,DcbNum( M$Window ),,,,2 );
   Call M$Close( CloseOU ) Altret ( PrintError );  /*  context file  */
   AltReturn;
 End;
 
ReadContext.Buf_ = Vector( Junk );
Call M$Read( ReadContext ) Altret ( PrintError );  /* read in num of pages needed */
If Junk > CurrentPages#
 Then do;
   Do I = CurrentPages# to Junk - 1;
     Call M$GDS( GDS )
      WhenAltReturn do;
        YYY_ErrCode.Err# = %E$NotEnoughBuffers;
        Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Window ),,,,3 );
        Call M$Close( CloseOU ) Altret ( PrintError );  /*  context file  */
        AltReturn;
      End;  /*  When Altret  */
   End;  /*  do I  */
 
   CurrentPages# = Junk;
   MaxBuffers# = CurrentPages# * 1024 / LengthW(Buffers(0));
 End;
 
ReadContext.Buf_ = Vector( CurrentBuffer# );
Call M$Read( ReadContext ) Altret ( PrintError );
ReadContext.Buf_.Bound = 1024 * CurrentPages# * 4 - 1;
ReadContext.Buf_.Buf$ = Buffers$;
Call M$Read( ReadContext ) Altret ( PrintError );
Buffers# = M$OU$ -> F$Dcb.Ars# / LengthC( Buffers(0) );
 
ReadContext.Buf_ = Vector( SpecialContext );
Call M$Read( ReadContext ) Altret ( PrintError );
 
KeepNewMT = SpecialContext.Flags.KeepNewMT;
AlwaysUseWorkFlag = SpecialContext.Flags.AlwaysUseWork;
SavedSize = SpecialContext.SavedSize;
FindWord = SpecialContext.FindWord;
Replacement = SpecialContext.Replacement;
LastOperation = SpecialContext.LastOperation;
ForwardSearch = SpecialContext.Direction;
EditNewFile.V.Type# = SpecialContext.Type;
Do Case LastOperation;
   Case( %Find );
     FinOps = SpecialContext.Options;
     RepOps = ' ';
   Case( %Replace );
     RepOps = SpecialContext.Options;
     FinOps = ' ';
   Case( Else );
     FinOps = ' ';
     RepOps = ' ';
End;  /*  case  */
 
Call M$Open( DeleteSAndM ) WhenAltReturn do; end;  /* don't care */
SAndMFid.Name# = ' ';
 
If SavedSize > 0
 Then do;
   Call MakeUniqueName;         /*  opens file  */
   SAndMFid = StarUnique;
   ReadContext.Buf_ = Vector( UniqueLine );
   Do While %True;
    Call M$Read( ReadContext ) Altret ( done );
    WriteStarUnique.Buf_.Bound = M$OU$ -> F$Dcb.ARs# - 1;
    Call M$Write( WriteStarUnique ) Altret ( PrintError );
   End;
done:
   Call M$Close( CloseStarUnique ) Altret ( PrintError );
 
 End;  /*  if there's an SAndM buffer  */ 
  
Call M$Close( CloseOU ) Altret ( PrintError );
If BrokenFlag
 Then
   AltReturn;
 
Do I = 0 to Buffers# - 1;
   Count = 0;
   If Buffers.Status.Encrypted( I )
    Then do;
PromptAgain:
      If BrokenFlag
       Then
         AltReturn;
 
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( I ) );
      Call X$Write( FDSVFC, Vector( CrptFileFormat ),
                            Vector( Fid ) );
 
      Call XUG$GetCmd( Xug_GetCmd3 )
       WhenReturn do;
         Call ComputeCrpt( Xug_GetCmd3.Out$, Seeds( I ) );
         If Seeds( I ) = '0'B
          Then
            Buffers.Status.Encrypted( I ) = %False;
 
       End;
       WhenAltReturn do;
         YYY_ErrCode.Err# = %E$DescribeCrpt;
         Call YEM$ErrMsg( YYY_Errcode,, DcbNum( M$Window ),,,,1 );
         Count = Count + 1;
         If Count > 2
          Then
            AltReturn;
          Else
            Goto PromptAgain;
 
       End;  /*  When Altret  */
    End;  /*  if encrypted  */
    Else
      Seeds( I ) = '0'B;
 
End;  /*  do I  */
 
If BrokenFlag
 Then
   AltReturn;
 
Return;
 
PrintError:
   Call YEM$ErrMsg( ,, DcbNum( M$Window ),,,,3 );
   Call M$Close( CloseOU ) WhenAltReturn do; end;
   AltReturn; 
 
End RestoreContext;
 
/**/
 
SaveCurrent: Proc;
/*
      Store current settings to memory
*/
 
Dcl 1 Tab2 Based,
    2 Margin# UBin(9) CAligned,
    2 Tabs# Char(31) CAligned;
 
%VLP_TAB;
Dcl 1 VLP_Tab2 Redef Vlp_Tab,
    2 Margin# UBin(9) CAligned,
    2 Tabs# Char(31) CAligned;
 
   Buffers.Block( CurrentBuffer# ) = Block;
   Buffers.Spots( CurrentBuffer# ) = SpotsChars;
   Buffers.Status.StripBlanks(CurrentBuffer#) = StripFlag;
   Buffers.Status.InputOnly(CurrentBuffer#) = InputOnlyFlag;
   Buffers.Status.Sequen(CurrentBuffer#) = SequenFlag;
   Buffers.CurrentPos(CurrentBuffer#) = CurrentPos;
   Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
   Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
   Buffers.EdtCtl(CurrentBuffer#) = VLPEditWindow2Redef;
   Buffers.TrmCtl(CurrentBuffer#) = VLPEditWindowSettingsRedef;
   If M$Edit$ -> F$Dcb.Tab$ ~= Addr( Nil )
    Then
      Buffers.Tabs( CurrentBuffer# ) = M$Edit$ -> F$Dcb.Tab$ -> Tab2;
    Else
      If M$UC$ -> F$Dcb.Tab$ ~= Addr( Nil )
       Then
         Buffers.Tabs( CurrentBuffer# ) = M$UC$ -> F$Dcb.Tab$ -> Tab2;
       Else
         Buffers.Tabs( CurrentBuffer# ) = VLP_Tab2;
 
   Return;
 
boom:
   Call AltretError;
   Return; 
 
End SaveCurrent;
 
/**/
 
RestoreSettings: Proc;
/*
      Restore settings from memory
*/
 
%FPT_DEVICE(FPTN = TabSettings,
             DCB = M$Edit,
             HDR = EOF,
             TAB = VLP_TAB,
         STCLASS = STATIC );
 
Dcl 1 VLP_Tab Static,
    2 Margin# UBin(9) CAligned,
    2 Tabs# Char(31) CAligned;
 
   VLP_Tab = Buffers.Tabs( CurrentBuffer# );
   Block = Buffers.Block( CurrentBuffer# );
   SpotsChars = Buffers.Spots( CurrentBuffer# );
   CurrentPos = Buffers.CurrentPos( CurrentBuffer# );
   StripFlag = Buffers.Status.StripBlanks(CurrentBuffer#);
   If StripFlag
    Then
      ReadUC02.V.DVByte.BP# = %False;
    Else
      ReadUC02.V.DVByte.BP# = %True;
 
   If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
    Then
      WorkFlag = %True;
    Else
      WorkFlag = %False;
 
   InputOnlyFlag = Buffers.Status.InputOnly(CurrentBuffer#);
   SequenFlag = Buffers.Status.Sequen(CurrentBuffer#);
   VLPEditWindow2Redef = Buffers.EdtCtl(CurrentBuffer#);
   VLPEditWindowSettingsRedef = Buffers.TrmCtl(CurrentBuffer#);
 
/* restore encryption seeds for this file */
 
   ReadSI.V.Seed# = Seeds( CurrentBuffer# );
   ReadSIByKey.V.Seed# = Seeds( CurrentBuffer# );
   WriteSI.V.Seed# = Seeds( CurrentBuffer# );
 
   Call M$STrmCtl( EditWindowSettings ) Altret ( boom );
   Call M$STrmCtl( EditWindow2 ) Altret ( boom );
   Call SetFcnTbl;
   Call M$Device( TabSettings ) Altret ( boom );
 
   Return;
 
boom:
   Call AltretError;
   Return;
 
End RestoreSettings;
 
/**/
  
GotoEnd: Proc;
/*
      This procedure positions the screen to the end of the file.
*/
 
Dcl Where UBin Half unal;
 
Call M$PFilSI( PosEOF ) Altret ( blip );
 
PRecSINoKey.V.N# = -1;
Call M$PRecordSI( PRecSINoKey )
  WhenAltReturn do;
      Call SetErrCode;
      If ErrCode.Err# ~= %E$BOF
       Then
         Goto Blip;
  End;  /*  When Altret  */
 
Call M$ReadSI( ReadSI )
  WhenReturn do;
      UCKey = SIKey.Key;
      Call SetArs;
      If SIARS# > 0 then
       Where = SIARS#;
      else do;
       Where = 0;
       SiLine = ' ';
      end;
 
      CurrentPos.Column = where + 1;
      CurrentPos.Key.Len = 3;
      CurrentPos.Key.Key = SIKey.Key;
      Call Position( where );
 
  end;  /* When Return */
 
  WhenAltReturn do;
      Call SetErrCode;
      If ErrCode.Err# = %E$LD
       Then
         Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), DcbNum( M$UC ),,,,3 );
 
  End;  /*  When AltReturn  */
 
Return;
 
Blip:
      Call AltretError;
      Return;
 
End GotoEnd;
 
/**/
 
GotoStart: Proc;
/*
      This procedure positions the screen to the start of the file.
*/
 
Dcl where UBin Half HAligned;
 
Call M$PFilSI( PosBOF ) Altret ( boom );
 
Call M$ReadSI( ReadSI )
         WhenReturn Do;
           where = 0;
           Call Position( where );
         End; /*  WhenReturn  */
         WhenAltReturn Do;
           Call SetErrCode;
           If ErrCode.Err# = %E$LD
            Then
              Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), DcbNum( M$UC ),,,,3 );
            Else
              If ErrCode.Err# ~= %E$EOF
               Then
                 Goto boom;
 
         End;
 
         Return;
 
boom:
      Call AltretError;
      Return;
 
End GotoStart;
 
/**/
 
WhichLine: Proc( Key, Column );
/*
      Procedure to determine which line the cursor is currently located on.
*/
 
Dcl Thousands UBin;
Dcl Thousandths UBin;
Dcl Key UBin Param;
Dcl Column UBin Param;
 
Call YXB$SetBold;
If SequenFlag
 Then
  Call X$Write( FDS2, Vector( SequenKeyFormat ),
                      Vector( Key ),
                      Vector( Column) );
 Else do;
  Thousands = Key / 1000;
  Thousandths = Mod( Key, 1000 );
 
  Call X$Write( FDS2, Vector( EditKeyFormat ), Vector( Thousands ),
                      Vector( Thousandths ),
                      Vector( Column) );
 End;
 
Call YXB$ResetBold;
 
End WhichLine;
 
/**/
                                  
InsertBlockHere: Proc ( Incr, Dcb#, SourceLine, SourcePos, SourceLen,
                        BlockSize, PassedKey, Dual ) Altret;
/*
      Procedure to insert a block
*/
      
Dcl Dual Bit(1);
Dcl Incr UBin Word;
Dcl Dcb# UBin;
Dcl SourceLine Char(%BufSize);
Dcl ItLine Char(%BufSize) Static Unal Init(' ');
Dcl Part1 Char(%BufSize);
Dcl Part2 Char(%BufSize);
Dcl Part3 Char(%BufSize);
Dcl Len1 UBin;
Dcl Len2 UBin;
Dcl Len3 UBin;
Dcl ch1# UBin;
Dcl ch2# UBin;
Dcl ch1 Char(1);
Dcl ch2 Char(1);
Dcl db Char(2);
Dcl SourcePos UBin Word;
Dcl SourceLen UBin Word;
Dcl BlockSize UBin Word;
Dcl Length UBin Word;
Dcl 1 ItKey Static,
    2 Len UBin(9) unal,
    2 key UBin(27) unal;
 
Dcl 1 PassedKey Param,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
      %FPT_WRITE( FPTN = WriteIt,     /* Write new records to Edit file */
                   BUF = ItLine,
                   KEY = ItKey,
               STCLASS = STATIC,
               ONEWKEY = YES );
 
/**/
 
M$WriteIt: Proc(Dual) Altret;
 
Dcl Bound UBin Static;
Dcl junk UBin Static;
Dcl Dual Bit(1);
 
If StripFlag
 Then
   Call SearchR( Bound, junk, B$SR_Non_Blank,
                 Substr( ItLine, 0, WriteIt.Buf_.Bound+1 ) )
      WhenReturn do;
        WriteIt.Buf_.Bound = Bound;
      End;
      WhenAltReturn do;
        WriteIt.Buf_.Bound = 0;
      End;
 
Call M$Write( WriteIt ) Altret ( ouch );
If Dual and (LastCacheEntry >= 0 ) and
   (ItKey.Key >= Cache(0)) and (ItKey.Key <= Cache(LastCacheEntry))
 Then do;
   SILine = ItLine;
   WriteUC02.Buf_.Bound = WriteIt.Buf_.Bound;
   UCKey = ItKey.Key;
   Call M$WriteUC02 Altret ( ouch );
 end;
 
Return;
 
ouch:
      AltReturn;
 
End M$WriteIt;
  
/*
      Start InsertBlockHere
*/
      Buffers.Status.Changed( CurrentBuffer# ) = %True;
      db = '  ';
      Call M$GTrmCtl( EditWindow2 ) altret ( boom );
      ItKey = PassedKey;
      WriteIt.Key_ = Vector( ItKey );
      If SourceLen < 1
       Then
         SourceLen = 1;
 
      If SourcePos < 1
       Then
         SourcePos = 1;
 
      If SourcePos > SourceLen
       Then do;
         Substr( SourceLine, SourceLen ) = ' ';  /*  blank fill  */
         SourceLen = SourcePos - 1;
         end;
 
      WriteIt.V.Dcb# = Dcb#;
      WriteIt.V.Seed# = ReadSI.V.Seed#;
 
      Call M$Read( ReadStarUnique )
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# = %E$EOF
          then do;
            ItLine = SourceLine;
            WriteIt.Buf_.Bound = SourceLen - 1;
            Call M$WriteIt(Dual) Altret ( boom );
            ItKey.Key = ItKey.Key + Incr;
            goto Fin;
          end;  /*  if  */
          else
            Goto Boom;
       end;  /*  When Altret  */
 
      If BlockSize = 1
       then
         If (M$Block$->F$Dcb.Ars# + SourceLen) > %BufSize-10
          then do;
            ItLine = Substr( SourceLine,0,SourcePos-1 );
            WriteIt.buf_.bound = SourcePos - 2;
            Call M$WriteIt(Dual) Altret ( boom );
            ItKey.Key = ItKey.Key + Incr;
            ItLine = UniqueLine;
            WriteIt.Buf_.Bound = M$Block$ -> F$Dcb.Ars# - 1;
            Call M$WriteIt(Dual) Altret ( boom );
            ItKey.Key = ItKey.Key + Incr;
            ItLine = Substr( SourceLine,SourcePos-1,SourceLen-SourcePos+1 );
            WriteIt.Buf_.Bound = SourceLen - SourcePos;
            Call M$WriteIt(Dual) Altret ( boom );
          End;  /* if need multiple lines */
          Else do;  /* Single line */
            If VLPEditWindow2.TextEdit# = '10'B
             Then do;
               Len1 = SourcePos - 1;
               Part1 = Substr( SourceLine,0,Len1 );
               Len2 = M$Block$ -> F$Dcb.Ars#;
               Part2 = Substr( UniqueLine,0,Len2 );
               Len3 = SourceLen - SourcePos + 1;
               Part3 = Substr( SourceLine,SourcePos-1, Len3 );
               ch1 = Substr( Part1, Len1-1, 1 );
               ch2 = Substr( Part2, Len2-1, 1 );
               If (ch1 = '.') or (ch1 = '!') or (ch1 = '?') or (ch1 = ':')
                Then
                  ch1# = 2;
                Else
                  ch1# = 1;
 
               If (ch2 = '.') or (ch2 = '!') or (ch2 = '?') or (ch2 = ':')
                Then
                  ch2# = 2;
                Else
                  ch2# = 1;
 
               If Len1 = 0 then ch1# = 0;
               If Len2 = 0 then ch2# = 0;
               If (ch1 = ' ') or (substr(part2,0,1) = ' ') then ch1# = 0;
               If (ch2 = ' ') or (substr(part3,0,1) = ' ') then ch2# = 0;
               Call Concat( ItLine, Substr(Part1,0,Len1), Substr(db,0,ch1#),
                                    Substr(Part2,0,Len2), Substr(db,0,ch2#),
                                    Substr(Part3,0,Len3) );
 
               WriteIt.Buf_.Bound = Len1 + Len2 + Len3 + ch1# + ch2# - 1;
             End;
             Else do;
               Call Concat( ItLine, Substr( SourceLine,0,SourcePos-1 ),
                            Substr( UniqueLine,0,M$Block$->F$Dcb.Ars# ),
                            Substr( SourceLine,SourcePos-1,SourceLen-SourcePos+1 ) );
 
               WriteIt.Buf_.Bound = SourceLen + M$Block$ -> F$Dcb.Ars# - 1;
             End;
 
            Call M$WriteIt(Dual) Altret ( boom );
          End;  /*  else  */
      Else do;  /*  blocksize is > 1  */
       If (M$Block$ -> F$Dcb.Ars# + SourcePos) > %BufSize-10
        then do;  /*  2 lines  */
          ItLine = Substr( SourceLine,0,SourcePos-1 );
          WriteIt.Buf_.bound = SourcePos - 2;
          Call M$WriteIt(Dual) Altret ( boom );
          ItLine = UniqueLine;
          WriteIt.Buf_.bound = M$Block$ -> F$Dcb.Ars# - 1;
          ItKey.Key = ItKey.Key + Incr;
          Call M$WriteIt(Dual) Altret ( boom );
          ItKey.Key = ItKey.Key + Incr;
        end; /*  if  */
        else do;  /*  only 1 line  */
          If VLPEditWindow2.TextEdit# = '10'B
           Then do;
             Len1 = SourcePos - 1;
             Part1 = Substr( SourceLine,0,Len1 );
             Len2 = M$Block$ -> F$Dcb.Ars#;
             Part2 = Substr( UniqueLine,0,Len2 );
             ch1 = substr( Part1,Len1-1,1 );
             If (ch1 = '.') or (ch1 = '!') or (ch1 = '?') or (ch1 = ':')
              Then
                ch1# = 2;
              Else
                ch1# = 1;
 
             If Len1 = 0 then ch1# = 0;
             If (ch1 = ' ') or (substr(part2,0,1) = ' ') then ch1# = 0;
             Call Concat( ItLine, Substr(Part1,0,Len1), Substr(db,0,ch1#),
                                  Substr(Part2,0,Len2) );
 
             WriteIt.Buf_.Bound = Len1 + Len2 + ch1# - 1;
           End;
           Else do;
             Call Concat( ItLine, Substr( SourceLine,0,SourcePos-1 ),
                          Substr( UniqueLine,0,M$block$->F$Dcb.Ars# ) );
 
             WriteIt.Buf_.bound = M$block$->F$Dcb.Ars# + SourcePos - 2;
           End; /* else */
 
          Call M$WriteIt(Dual) Altret ( boom );
          ItKey.Key = ItKey.Key + Incr;
        end;  /*  else  */
 
       If ItKey.Key > %MaxSequenceNumber
        then do;
          Call M$Close( CloseOURelease ) WhenAltReturn do; end;
          Call Exeunt( %E$FileTooBig );
        end;  /*  if it got too big  */
 
       Do while %True;
         Call M$Read( ReadStarUnique ) Altret ( done );
         Length = M$block$ -> F$Dcb.Ars#;
         ItLine = UniqueLine;
 
         If Length <= 0
          then do;
            WriteIt.buf_.bound = 0;
            ItLine = ' ';
          end;
          else
            WriteIt.buf_.bound = Length - 1;
 
         Call M$WriteIt(Dual) Altret ( boom );
  
         ItKey.Key = ItKey.Key + Incr;
 
         If ItKey.Key > %MaxSequenceNumber
          then do;
            Call M$Close( CloseOURelease ) WhenAltReturn do; end;
            Call Exeunt( %E$FileTooBig );
          end;  /*  if it got too big  */
 
       end;  /*  do while  */
 
done:
       ItKey.Key = ItKey.Key - Incr;  /*  reset to last line done  */
 
/*  now, join the lines  */
      
       If (Length + SourceLen - SourcePos + 1) > %BufSize-10
        then do;  /*  2 lines  */
          ItKey.Key = ItKey.Key + Incr;
          ItLine = Substr( SourceLine, SourcePos - 1, SourceLen - SourcePos + 1 );
          WriteIt.Buf_.Bound = SourceLen - SourcePos;
          If WriteIt.Buf_.bound < %BufSize
           then do;
             Call M$WriteIt(Dual) Altret ( boom );
           End;
 
        end;  /*  if 2 lines  */
        else do;
          If VLPEditWindow2.TextEdit# = '10'B
           Then do;
             Len1 = Length;
             Part1 = Substr( UniqueLine,0,Len1 );
             Len2 = SourceLen - SourcePos + 1;
             Part2 = Substr( SourceLine,SourcePos-1,Len2 );
             ch1 = substr( Part1,Len1-1,1 );
             If (ch1 = '.') or (ch1 = '!') or (ch1 = '?') or (ch1 = ':')
              Then
                ch1# = 2;
              Else
                ch1# = 1;
 
             If Len1 = 0 then ch1# = 0;
             If (ch1 = ' ') or (substr(part2,0,1) = ' ') then ch1# = 0;
             Call Concat( ItLine, Substr(Part1,0,Len1), Substr(db,0,ch1#),
                                  Substr(Part2,0,Len2) );
 
             WriteIt.Buf_.Bound = Len1 + Len2 + ch1# - 1;
           End; /* if textedit */
           Else do;
             Call Concat( ItLine,Substr(UniqueLine,0,Length),
                          Substr(SourceLine,SourcePos-1,SourceLen-SourcePos+1) );
 
             WriteIt.Buf_.bound = Length + SourceLen - SourcePos;
           End; /* if not textedit */
 
          If WriteIt.Buf_.bound > %BufSize - 1
           then do;
             WriteIt.buf_.bound = 0;
             ItLine = ' ';
           end;  /*  if  */
      
          Call M$WriteIt(Dual) Altret ( boom );
        end;  /*  else a single line join  */
      end;  /* if not 1 record block */
 
/*
      clean up
*/
Fin:
      ItKey.Key = ItKey.Key + Incr;
      If ItKey.Key > LastKey.Key
       then
         LastKey.Key = ItKey.Key;
 
      WriteIt.V.Seed# = '0'B;
      PassedKey = ItKey;
      Return;
 
Boom:
      WriteIt.V.Seed# = '0'B;
      AltReturn;
 
End InsertBlockHere;
 
/**/
 
ValidateBlock: Proc AltRet;
/*
      Validate the markers for a block.  Altret if block not correctly
      marked.
*/
Dcl 1 TempKey,
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
 
Dcl TempCol UBin Word;
 
If (Block.KeyStart.len = 0) or (Block.KeyEnd.len = 0)
   Then do;
      YYY_ErrCode.Err# = %E$NoBlock;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
      Call YXB$ResetBold;
      AltReturn;
   End;  /*  if no block to work on  */
 
If (Block.KeyEnd.Key < Block.KeyStart.Key)
   Then do;
      TempKey = Block.KeyEnd;
      Block.KeyEnd = Block.KeyStart;
      Block.KeyStart = TempKey;
      TempCol = Block.PosEnd;
      Block.PosEnd = Block.PosStart;
      Block.PosStart = TempCol;
      Return;
   End;  /*  if  */
 
If (Block.KeyStart.Key = Block.KeyEnd.Key) and (Block.PosEnd < Block.PosStart)
   Then do;
      TempCol = Block.PosEnd;
      Block.PosEnd = Block.PosStart;
      Block.PosStart = TempCol;
      Return;
   End;  /*  if  */
 
Return;
 
End ValidateBlock;
 
/**/
 
M$DelRecEdit: Proc Altret;
/*
      Procedure to Delete a record from the FEP cache.
*/
 
Call M$Device( FPTDeviceEdit ) Altret ( boom );
Call M$DelRec( DelEdit ) Altret ( boom );
Call DeleteKeyFromCache( DelUCKey );
 
Return;
 
boom:
      AltReturn;
 
End M$DelRecEdit;
 
/**/
 
MakeUniqueName: Proc;
/*
      Create a uniquely named star file
*/
 
Dcl UniqueName Char(6) CAligned;
 
Loop:
      Call YMU$Unique( UniqueName );
      Call Concat( StarUnique.Name#, '*', UniqueName );
      StarUnique.L# = 7;
 
      Call M$Open( OpenStarUnique ) 
        WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.ERR# = %E$CreatErr
          then goto loop;
          else Call AltretError;
        end;  /*  When Altret  */
 
      Return;
 
End MakeUniqueName;
 
/**/
 
SaveBlock: Proc(BlockSize) Altret;
/*
      Procedure to save the currently marked block in a temp file.
*/
 
Dcl BlockSize UBin Param;
 
      SIKey = Block.KeyStart;
      SILine = ' ';
      BlockSize = 0;
      Call M$ReadSI( ReadSIByKey )
       WhenReturn do;
         UniqueLine = Substr( SILine, Block.PosStart - 1 );
         BlockSize = 1;
 
         If Block.KeyStart ~= Block.KeyEnd
          Then do;
           Call SetArs;
           WriteStarUnique.Buf_.Bound = SIARS# - Block.PosStart;
          end;
          else
           WriteStarUnique.Buf_.Bound = Block.PosEnd - Block.PosStart - 1;
 
         If WriteStarUnique.Buf_.Bound > %BufSize then do;
              WriteStarUnique.Buf_.Bound = 0;
              UniqueLine = ' ';
         end;
 
         Call M$Write( WriteStarUnique ) Altret ( boom );
 
       end;  /*  When Return  */
       WhenAltReturn do;
         PRecSI.V.N# = 0;
         Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
       end;  /*  When Altret  */
 
      Do While %True;
       Call M$ReadSI( ReadSI ) Altret ( EOF );
       If SIKey.Key > Block.KeyEnd.Key then goto EOF;
       If SIKey.Key = Block.KeyEnd.Key then do;
         If Block.PosEnd = 1 then goto EOF;  /*  use none of this line  */
         Call SetArs;
         If SIARS# >= Block.PosEnd
          Then do;
            UniqueLine = Substr( SILine, 0, Block.PosEnd - 1 );
            WriteStarUnique.Buf_.Bound = Block.PosEnd - 2;
          end;
          else do;
            UniqueLine = Substr( SILine, 0, SIARS# );
            WriteStarUnique.Buf_.bound = SIARS# -1 ;
          end;  /*  else  */
 
       end;  /*  if  */
       else do;
         UniqueLine = SILine;
         Call SetArs;
         If SIARS# > 0 then
           WriteStarUnique.Buf_.Bound = SIARS# - 1;
         else do;
           WriteStarUnique.Buf_.Bound = 0;
           UniqueLine = ' ';
         end;  /*  else  */
       end;  /*  else  */
 
       BlockSize = BlockSize + 1;
       Call M$Write( WriteStarUnique ) Altret ( boom );
 
      end;  /*  do while  */
 
EOF: 
      Call M$Close( CloseStarUnique ) Altret ( boom );
      Return;
 
boom:
      AltReturn;
 
End SaveBlock;
 
/**/
 
CopyBlock: Proc AltRet;
/*
      Procedure to copy the block marked in  Block  after the current
      cursor position.
*/
 
Dcl BlockSize UBin Word Unal;
 
Call ValidateBlock
   WhenAltReturn do;
      AltReturn;
   End;
 
Call MakeUniqueName;
Call SaveBlock( BlockSize ) Altret ( boom );
 
/*  now find where we're going to put this block  */
 
Call M$Open( OpenStarUniqueIn ) Altret ( boom );
Call MergeBlock( BlockSize ) Altret ( boom );
Call M$Close( CloseStarUniqueDelete ) Altret ( boom );
 
Return;
 
boom:
      Call AltretError;
      Return;
 
End CopyBlock;
 
/**/
 
MergeBlock: Proc( BlockSize ) AltRet;
/*
      Procedure to read in the * unique file as a block
*/
Dcl Dual Bit(1);
Dcl SourceLine Char(%BufSize) Unal;
Dcl SourceKey UBin Word Unal;
Dcl SourcePos UBin Word Unal;
Dcl SourceLen UBin Word Unal;
Dcl FirstKey SBin Word Unal;
Dcl TheLastKey SBin Word Unal;
Dcl Incr UBin Word Unal;
Dcl BlockSize UBin Param;
Dcl BlockDone Bit(1) Unal;
  
      SourceLine = UCLine;
      SourceKey  = UCKey;
      SourcePos  = M$Edit$ -> F$Dcb.ActPos;
      SourceLen  = M$Edit$ -> F$Dcb.Ars#;
  
      Incr = 1;
      
      SIKey.Key = SourceKey;
      PRecSI.V.N# = -1;
 
      Call M$PRecord( PRecSI )
       WhenAltReturn do;
         FirstKey = SourceKey - 1;
         Incr = 1000;
         DelKey.Key = SourceKey;
         DelKey.Len = 3;
         Call M$DelRec( DeleteSI ) Altret ( boom );
         If (LastCacheEntry >= 0 ) and (SourceKey >= Cache(0)) and (SourceKey <= Cache(LastCacheEntry))
          Then do;
            DelUCKey = SourceKey;
            Call M$DelRecEdit Altret ( boom );
          end;
  
         goto rekey;
       end;  /*  When Altret  */
         
      FirstKey = SIKey.Key + 1;
      CurrentPos.Key.Key = FirstKey;/* save new key number of current position */
 
      SIKey.Key = SourceKey;
      PRecSI.V.N# = 1;
 
      Call M$PRecord( PRecSI )
        WhenReturn do;
         TheLastKey = SIKey.Key - 1;
         If SIKey.Len = 0 then do;
          SIKey.Len = 3;
          TheLastKey = SIKey.Key + ( BlockSize * 1000 );
         end;  /*  if  */
        end;
        WhenAltReturn do;
         Incr = 1000;
        end;  /*  When Altret  */
 
      DelKey.Key = SourceKey;
      DelKey.Len = 3;
      /*  gonna delete the sourceline since we're rebuilding it  */
      Call M$DelRec( DeleteSI ) Altret ( boom );
      If (LastCacheEntry >= 0 ) and (SourceKey >= Cache(0)) and (SourceKey <= Cache(LastCacheEntry))
       Then do;
         DelUCKey = SourceKey;
         Call M$DelRecEdit Altret ( boom );
       end;
 
      If Incr = 1 then
        Incr = ( TheLastKey - FirstKey + 1 ) / (BlockSize + 2);
                                           /* 2 for the line split */
 
      If Incr < 10
       then do;
         Incr = 1000;
         Goto Rekey;     /*  not enough room in here; rekey the sucker  */
       end;  /*  if  */
 
      FirstKey = FirstKey + (Incr/2);  /* don't start right next to */
      CurrentPos.Key.Key = FirstKey;   /* previous key              */
 
      SIKey.Key = FirstKey;
      If DelKey = Block.KeyStart then Block.KeyStart.Key = FirstKey;
      If DelKey = Block.KeyEnd then Block.KeyEnd.Key = FirstKey;
 
      Dual = %True;
      Call InsertBlockHere(Incr,DcbNum(M$SI),SourceLine,SourcePos,SourceLen,
                           BlockSize,SIKey,Dual) Altret ( boom );
      
      Return;
 
rekey:
      Call Rekey2( Incr, SourceLine, SourcePos, SourceLen, FirstKey, Blocksize);
      Return;
 
Boom:
      AltReturn;
 
End MergeBlock;
 
/**/
 
DeleteBlock: Proc AltRet;
/*
      Procedure to delete the block marked by  Block  from the source.
*/
 
Dcl AdjustFlag Bit(1);
Dcl TempBuf Char(%BufSize);
Dcl TempLen UBin;
Dcl 1 Coord1,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
Dcl 1 Coord2,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
Dcl 1 Coord3,
    2 Key UBin Word Unal,
    2 Column UBin Word Unal;
 
Dcl Bound UBin Static;
Dcl junk UBin Static;
Dcl ch Char(1);
Dcl ch# UBin;
 
/* internal */
   YYY$Write: Proc AltRet;
 
      Call M$Write( WriteSI ) Altret ( boom );
      If (LastCacheEntry >= 0) and (SIKey.Key >= Cache(0)) and
         (SIKey.Key <= Cache(LastCacheEntry))
       Then do;
         WriteUC02.Buf_.Bound = WriteSI.Buf_.bound;
         SILine = UCLine;
         UCKey = SIKey.Key;
         Call M$WriteUC02 Altret ( boom );
       End;  /*  if cache  */
 
      Return;
 
   boom:
      AltReturn;
 
   End YYY$Write;
 
/*
   Start DeleteBlock
*/
 
ch# = 0;
Call ValidateBlock   /* check for valid block markers */
   WhenAltReturn do;
     AltReturn;
   End;
 
AdjustFlag = %False;
Call M$GTrmCtl( EditWindow2 ) AltRet ( boom );
 
If Not MovingFlag
 Then do;
   Coord1.Key = Block.KeyStart.Key;
   Coord1.Column = Block.PosStart;
   Coord2.Key = Block.KeyEnd.Key;
   Coord2.Column = Block.PosEnd;
   Coord3.Key = CurrentPos.Key.Key;
   Coord3.Column = CurrentPos.Column;
   If (CurrentPos.Key >= Block.KeyStart) and (CurrentPos.Key <= Block.KeyEnd)
    Then
      AdjustFlag = %True;
 End;
  
Buffers.Status.Changed( CurrentBuffer# ) = %True;
If (Block.KeyStart.Key = Block.KeyEnd.Key)
 Then do;
   SIKey = Block.KeyStart;
   SILine = ' ';
   Call M$Read( ReadSIByKey )
    WhenReturn do;   /*  edit line  */
      Call SetArs;
      If ( Block.PosStart = 1 ) and ( Block.PosEnd > SIARS# )
       Then do;
         DelKeyStart = Block.KeyStart;
         DelKeyEnd = Block.KeyEnd;
 
         Call M$DelRec( DeleteSIRange ) Altret ( boom );
         If (LastCacheEntry >= 0) and (DelKeyStart.Key >= Cache(0)) and
          (DelKeyStart.Key <= Cache(LastCacheEntry))
          Then do;
            DelUCKey = DelKeyStart.Key;
            Call M$DelRecEdit Altret ( boom );
          end;
 
         If LastKey.Key <= DelKeyEnd.Key
          Then
            Call FigureOutLast;
 
         If AdjustFlag
         Then do;
           CurrentPos.Key.Key = DelKeyEnd.Key + 1;
           CurrentPos.Column = 0;
         End;  /*  if adjust for delete  */
 
       End;  /*  if delete whole line  */
       Else do;
         If VLPEditWindow2.TextEdit# = '10'B
          Then Do;
            Do While (Block.PosStart > 1)
             and (Substr( SILine,Block.PosStart-2,1 ) = ' ');
              Block.PosStart = Block.PosStart - 1;
            End;
            Do While (Block.PosEnd < SIArs#)
             and (Substr( SILine,Block.PosEnd-1,1 ) = ' ');
              Block.PosEnd = Block.PosEnd + 1;
            End;
 
            If Block.PosStart > 1
             Then do;
               ch=substr( SILine,Block.PosStart-2,1 );
               if (ch = '.') or (ch = '!') or (ch = '?') or (ch = ':')
                then do;
                  ch# = 1;
                  Call Concat( UCLine, Substr( SILine,0,Block.PosStart-1 ), '  ',
                                       Substr( SILine,Block.PosEnd-1) );
                end;
                else
                  Call Concat( UCLine, Substr( SILine,0,Block.PosStart-1 ), ' ',
                                       Substr( SILine,Block.PosEnd-1) );
             End;
             Else
               UCLine = Substr( SILine,Block.PosEnd-1 );
 
          End; /* if textedit */
          Else
            Call Concat( UCLine, Substr( SILine,0,Block.PosStart-1 ),
                                 Substr( SILine,Block.PosEnd-1) );
 
         If StripFlag
          Then
            Call SearchR( Bound, junk, B$SR_Non_Blank,
                          Substr( UCLine, 0, LengthC( UCLine ) ) )
             WhenReturn do;
               WriteSI.Buf_.Bound = Bound;
             End;
             WhenAltReturn do;
               WriteSI.Buf_.Bound = 0;
             End;
 
          Else /* not stripflag */
            If VLPEditWindow2.TextEdit# = '10'B
             Then
               If Block.PosStart > 1
                Then
                  WriteSI.Buf_.Bound = SIARS# + Block.PosStart - Block.PosEnd + ch#;
                Else
                  WriteSI.Buf_.Bound = SIARS# - Block.PosEnd;
 
             Else
               WriteSI.Buf_.Bound = SIARS# + Block.PosStart - Block.PosEnd - 1;
 
          Call M$Write( WriteSI ) Altret ( boom );
          If (LastCacheEntry >= 0) and (SIKey.Key >= Cache(0)) and (SIKey.Key <= Cache(LastCacheEntry))
           Then do;
             UCKey = SIKey.Key;
             SILine = UCLine;
             WriteUC02.Buf_.bound = WriteSI.Buf_.Bound;
             Call M$WriteUC02 Altret ( boom );
           End;
 
          If AdjustFlag
           Then do;
             CurrentPos.Key.Key = Block.KeyStart.Key;
             If Coord3 > Coord2  /*  current after end of block  */
              Then do;
                CurrentPos.Column = CurrentPos.Column - Block.PosEnd +
                                    Block.PosStart;
 
                If VLPEditWindow2.TextEdit# = '10'B
                 Then
                   CurrentPos.Column = CurrentPos.Column + 1 + ch#;
 
                If StripFlag and (CurrentPos.Column > WriteSI.Buf_.Bound + 2)
                 Then
                   CurrentPos.Column = WriteSI.Buf_.Bound + 2;
 
              End;  /*  if current past end  */
              Else
                If Coord1 <= Coord3
                 Then
                   CurrentPos.Column = Block.PosStart;
 
           End;
 
       End;  /*  else do  */
 
    End;  /*  When Return from read  */
    WhenAltReturn do;
    End;
 
   Return;
 
 End;  /*  if same line  */
 
/*  Delete multiple lines and start by getting starting position  */
 
DelKeyStart = Block.KeyStart;
If Block.PosStart > 1
 Then do;   /*  partial record  */
   SIKey = Block.KeyStart;
   Call M$Read( ReadSIByKey )
    WhenReturn do;  /*  edit and replace  */
      TempBuf = Substr( SILine,0,Block.PosStart - 1 );
      If VLPEditWindow2.TextEdit# = '10'B
       Then
         Call SearchR( Bound, junk, B$SR_Non_Blank,
                       Substr( TempBuf, 0, LengthC( TempBuf ) ) )
          WhenReturn do;
            TempLen = Bound + 1;
          End;
          WhenAltReturn do;
            TempLen = 0;
          End;
       Else
         TempLen = Block.PosStart - 1;
 
    End;
    WhenAltReturn do;
      TempBuf = ' ';
      TempLen = 0;
    End;
 
 End;  /*  if  */
 Else do;
   TempBuf = ' ';
   TempLen = 0;
 End;  /* else */
 
/*  now do the end of the block  */
 
DelKeyEnd = Block.KeyEnd;
SIKey = Block.KeyEnd;
SILine = ' ';
Call M$Read( ReadSIByKey )
 WhenReturn Do;
   Call SetArs;
   If Block.PosEnd <= SIARS#
    then do;  /*  edit line  */
      UCLine = Substr( SILine,Block.PosEnd - 1 );
      If StripFlag
       Then
         Call SearchR( Bound, junk, B$SR_Non_Blank,
                       Substr( UCLine, 0, LengthC( UCLine ) ) )
          WhenReturn do;
            WriteSI.Buf_.Bound = Bound;
          End;
          WhenAltReturn do;
            WriteSI.Buf_.Bound = 0;
          End;
       Else
         WriteSI.Buf_.Bound = SIARS# - Block.PosEnd;
 
      If TempLen > 0
       Then
         If (TempLen + WriteSI.Buf_.Bound) < %BufSize
          Then do;  /* join partial lines around the block */
            WriteSI.Buf_.Bound = WriteSI.Buf_.Bound + TempLen;
            If VLPEditWindow2.TextEdit# = '10'B
             Then do;
               Do While Substr(UCLine,0,1) = ' ';  /* toss leading blanks */
                 UCLine = Substr(UCLine,1);
                 WriteSI.Buf_.Bound = WriteSI.Buf_.Bound - 1;
                 Block.PosEnd = Block.PosEnd + 1; /* for pos adjustment when subtracting */
               End;  /*  while  */
               ch=substr( TempBuf,TempLen-1,1 );
               if (ch = '.') or (ch = '!') or (ch = '?') or (ch = ':')
                then do;
                  ch# = 1;
                  Call Concat( SILine, Substr(TempBuf,0,TempLen), '  ', UCLine );
                end;
                else
                  Call Concat( SILine, Substr(TempBuf,0,TempLen), ' ', UCLine );
 
               WriteSI.Buf_.Bound = WriteSI.Buf_.Bound + 1 + ch#;
               TempLen = TempLen + 1;  /* adjustment for textedit space */
             End;
             Else
               Call Concat( SILine, Substr(TempBuf,0,TempLen), UCLine );
 
            UCLine = SILine;
            Call YYY$Write altret (boom);  /* write out the joined lines */
          End;
          Else do;
            Call YYY$Write altret (boom);  /* write out what we have EOB */
            UCLine = TempBuf;
            SIKey = Block.KeyStart;
            WriteSI.Buf_.Bound = TempLen - 1;
            TempLen = 0;  /* for adjust at end of routine */
            Call YYY$Write altret (boom);  /* write out the BOB line */
            DelKeyStart.Key = Block.KeyStart.Key + 1; /*don't delete this line*/
          End; /* else */
       Else    /* no beginning line to combine.  just write out last line */
         Call YYY$Write altret (boom);
 
      DelKeyEnd.Key = Block.KeyEnd.Key - 1;  /*  don't delete this line  */
    End;  /*  if  */
    Else If TempLen > 0
     Then do;
       UCLine = TempBuf;
       SIKey = Block.KeyStart;
       WriteSI.Buf_.Bound = TempLen - 1;
       Call YYY$Write altret (boom);
       TempLen = 0; /* for adjust at end of routine */
       DelKeyStart.Key = Block.KeyStart.Key + 1;  /* don't delete this line */
     End;  /* else if */
 End;  /* when return */
 WhenAltReturn do;
   If TempLen > 0
    Then do;
      UCLine = TempBuf;
      SIKey = Block.KeyStart;
      WriteSI.Buf_.Bound = TempLen - 1;
      TempLen = 0; /* for adjust at end of routine */
      Call YYY$Write altret (boom);
      DelKeyStart.Key = Block.KeyStart.Key + 1;  /* don't delete this line */
    End;  /* else if */
 End;
 
/*  Now delete the necessary range of lines  */
 
If DelKeyEnd.Key >= DelKeyStart.Key
 then do;
   Call M$DelRec( DeleteSIRange ) Altret ( boom );
   If LastCacheEntry >= 0
    Then do;
      DelUCKey = DelKeyStart.Key;
      DelUCKeyEnd = DelKeyEnd.Key;
      Call M$DelRec( DelEditRange ) Altret ( boom );
      Call DeleteRangeFromCache( DelUCKey, DelUCKeyEnd );
    End;  /*  if cache  */
 End;  /*  if doing a delete  */
 
If DelKeyEnd.Key >= LastKey.Key
 Then
   Call FigureOutLast;
 
If AdjustFlag
 Then do;
   If Coord1 <= Coord3
    Then
      CurrentPos.Key = Block.KeyEnd;
 
   If Coord3 > Coord2  /*  current after end of block  */
    Then do;
      CurrentPos.Column = CurrentPos.Column - Block.PosEnd + 1 + TempLen;
      If VLPEditWindow2.TextEdit# = '10'B
       Then
         CurrentPos.Column = CurrentPos.Column + ch#;
 
      If StripFlag and (CurrentPos.Column > WriteSI.Buf_.Bound + 2)
       Then
         CurrentPos.Column = WriteSI.Buf_.Bound + 2;
 
    End;  /*  if current past end  */
    Else
      If Coord1 <= Coord3
       Then
         CurrentPos.Column = 1 + TempLen;
 
 End;  /*  if adjust  */
 
Return;
 
Boom:
      Call AltretError;
      Return;
 
End DeleteBlock;
 
/**/
 
MarkSpot: Proc(WhichSpot);
/*
      Procedure to mark a spot to Return to later.
*/
 
Dcl WhichSpot UBin Word;
 
Spots.Key.Len(WhichSpot) = 3;
Spots.Key.Key(WhichSpot) = UCKey;
Spots.Column(WhichSpot) = CurrentPos.Column;
If Spots.Column(WhichSpot) = 0
  Then Spots.Column(WhichSpot) = 1;
 
End MarkSpot;
 
/**/
 
MarkBegin: Proc;
/*
      Procedure to fill in the  Block  variable with the beginning position
      of a block.
*/
 
Block.KeyStart.len = 3;
Block.KeyStart.key = UCKey;
Block.PosStart = CurrentPos.Column;
If Block.PosStart = 0
  Then Block.PosStart = 1;
 
End MarkBegin;
 
/**/
 
MarkEnd: Proc;
/*
      Procedure to fill in the  Block  variable with the ending position
      of a block.
*/
 
Block.KeyEnd.len = 3;
Block.KeyEnd.Key = UCKey;
Block.PosEnd = CurrentPos.Column;
If Block.PosEnd = 0
  Then Block.PosEnd = 1;
 
End MarkEnd;
 
/**/
 
UnMark: Proc;
/*
      Procedure to unmark a block.
*/
 
Block.KeyStart.Len = 0;
Block.KeyStart.Key = 0;
Block.KeyEnd.Len = 0;
Block.KeyEnd.Key = 0;
Block.PosStart = 0;
Block.PosEnd = 0;
 
End UnMark;
 
/**/
 
Rekey2: Proc( Incr, SourceLine, SourcePos, SourceLen, FirstKey, BlockSize );
/*
      Procedure to rekey a file and insert a block.
*/
 
%FPT_READ ( FPTN = ReadIt,      /* Read from the Edit file */
             BUF = SILine,
         STCLASS = STATIC,
             KEY = SIKey,
            KEYR = YES );
 
%FPT_WRITE( FPTN = WriteIt,     /* Write new records to Edit file */
             BUF = SILine,
         STCLASS = STATIC,
             KEY = OUKey,
         ONEWKEY = YES );
 
Dcl BlockSize UBin Word;
Dcl Incr UBin Word;
Dcl SourceLine Char(%BufSize);
Dcl SourcePos UBin Word;
Dcl SourceLen UBin Word;
Dcl FirstKey SBin Word;
Dcl BlockDone Bit(1) Unal;
Dcl EmptyFile Bit(1) Unal;
Dcl Where UBin Half;
Dcl I UBin;
 
Dcl 1 TempBlock Static,    /*  Info marking the bounds of a block  */
      2 PosStart UBin Word Unal,
      2 KeyStart,
          3 Len UBin(9) Unal,
          3 Key UBin(27) Unal,
      2 PosEnd UBin Word Unal,
      2 KeyEnd,
          3 Len UBin(9) Unal,
          3 Key UBin(27) Unal;
 
Dcl 1 TempCurrentPos Static,
      2 Column UBin Word Unal,
      2 Key,
        3 Len UBin(9) Unal,
        3 Key UBin(27) Unal;
 
Dcl 1 TempSpots (0:10) Static,
      2 Column UBin Word Unal,
      2 Key,
         3 Len UBin(9) Unal,
         3 Key UBin(27) Unal;
 
Dcl 1 TempKey,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 LowerKey Static,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl 1 UpperKey Static,
    2 Len UBin(9) Unal,
    2 Key UBin(27) Unal;
 
Dcl TotalRekey Bit(1) Static Unal;
Dcl Dual Bit(1);
Dcl 1 SkipStart,    /* old first key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 SkipEnd,      /* old last key number to skip */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 FKey,     /* old key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 LKey,     /* old key number of last rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
Dcl 1 NKey,     /* new key number of first rekeyed key in shadow cache */
    2 Len UBin(9) CAligned,
    2 Key UBin(27) CAligned;
 
/*
      Start Rekey2
*/
 
      Buffers.Status.Changed( CurrentBuffer# ) = %True;
      Mode = %Rekeying;
      OutLine = 'Wait';
      ComLine1 = ' ';
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
      TempKey.Len = 3;
      TempKey.Key = FirstKey;
      Call YRS$Setup( Incr, TempKey, LowerKey, UpperKey, BlockSize )
       WhenReturn do;
         TotalRekey = %False;
         Dcb# = DcbNum( M$SI );
         WriteIt.V.Dcb# = Dcb#;
         ReadIt.V.Dcb# = DcbNum( M$Block2 );
       End;
       WhenAltReturn do;
         TotalRekey = %True;
         Dcb# = DcbNum( M$OU );
         WriteIt.V.Dcb# = Dcb#;
         ReadIt.V.Dcb# = DcbNum( M$SI );
       End;
 
      TempBlock = Block;
      TempCurrentPos = CurrentPos;
      TempSpots = Spots;
      If TotalRekey
       Then
         OUKey.Key = Incr;
       Else
         OUKey.Key = LowerKey.Key;
 
      OUKey.len = 3;
      NKey = OUKey; /* for shadow rekey */
      blockdone = %False;
      EmptyFile = %True;
      WriteOU.V.Seed# = ReadSI.V.Seed#;
             
      FKey.Len = 0;
      FKey.Key = 0;
      LKey.Key = 0;
      Do Forever;
         Call M$Read( ReadIt ) Altret ( eof2 );
         If (FKey.Len = 0) or (SIKey.Key <= Cache(0))
          Then do;  /* for rekey shadowcache */
            FKey = SIKey;
            NKey = OUKey;
          End;
 
         If (SIKey.Key <= Cache(LastCacheEntry))
          Then
            LKey = SIKey;
 
         Call SetArs2( TotalRekey );
         EmptyFile = %False;
         If SIARS# ~= 0
          then
            WriteIt.Buf_.bound = SIARS# - 1;
          else do;
            SILine = ' ';
            WriteIt.Buf_.bound = 0;
          end;  /*  else  */
 
         If (SIKey.Key > FirstKey) and not Blockdone
          then do;
            PositionKey = OUKey.Key;
            Blockdone = %True;
            If FirstKey <= Block.KeyEnd.Key
             Then
               TempBlock.KeyEnd = OUKey;
 
            Dual = %False;
            SkipStart = OUKey; /* for shadow rekey */
            Call InsertBlockHere(Incr,Dcb#,SourceLine,SourcePos,
                                 SourceLen,BlockSize,OUKey,Dual) Altret (boom);
 
            SkipEnd.Len = 3;
            SkipEnd.Key = OUKey.Key - Incr; /* for shadow rekey */
            If (SIKey > Block.KeyStart) and (Block.KeyStart.Key > FirstKey)
             Then
               TempBlock.KeyStart = OUKey;
 
          end;   /*  put in the block  */
 
         If SIKey <= CurrentPos.Key then TempCurrentPos.Key.Key = OUKey.Key + Incr;
         If SIKey <= Block.KeyStart then TempBlock.KeyStart = OUKey;
         Do I = 0 to 10;
           If SIKey <= Spots.Key(I) then TempSpots.Key(I) = OUKey;
         End;  /*  do I  */
         If SIKey <= Block.KeyEnd then TempBlock.KeyEnd = OUKey;
 
         Call M$Write( WriteIt ) Altret ( boom );
         OUKey.Key = OUKey.Key + Incr;
      
         If (OuKey.Key > %MaxSequenceNumber) and TotalRekey
          then do;
            Call M$Close( CloseOURelease ) Altret ( boom );
            Call Exeunt( %E$FileTooBig );
          end;  /*  if it got too big  */
 
      end;  /*  do forever  */
 
eof2:
      If EmptyFile
       Then do;
         TempBlock.KeyStart = OUKey;
         TempBlock.KeyEnd = OUKey;
         Do I = 0 to 10;
           TempSpots.Key(I) = OUKey;
         End;  /*  do I  */
         TempCurrentPos.Key = OUKey;
       End;
 
      If Not BlockDone
       Then do;
         Dual = %False;
         SkipStart = OUKey; /* for shadow rekey */
         Call InsertBlockHere( Incr, Dcb#, SourceLine, SourcePos,
                               SourceLen, BlockSize, OUKey, Dual) Altret (boom);
         SkipEnd.Len = 3;
         SkipEnd.Key = OUKey.Key - Incr; /* for shadow rekey */
       End;
         
      If TotalRekey
       Then do;
         Block = TempBlock;
         CurrentPos = TempCurrentPos;
         Spots = TempSpots;
         Call M$Close( CloseSI ) Altret ( boom );
         Call M$Close( CloseOU ) Altret ( boom );
         If Buffers.Password#( CurrentBuffer# ) ~= ' '
          Then do;
            BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
            EditOldFile.IFParam_ = Vector( BabyFIT );
          End;
          Else
            EditOldFile.IFParam_ = Vector( NIL );
  
         EditOldFile.V.Fun# = %Update#;
         Call M$OpenSI( EditOldFile ) Altret ( boom );
       End;
       Else do;
         If (Block.KeyStart >= LowerKey) and (Block.KeyStart <= UpperKey)
          Then
            Block.KeyStart = TempBlock.KeyStart;
 
         If (Block.KeyEnd >= LowerKey) and (Block.KeyEnd <= UpperKey)
          Then
            Block.KeyEnd = TempBlock.KeyEnd;
 
         Do I = 0 to 10;
           If (Spots.Key(I) >= LowerKey) and (Spots.Key(I) <= UpperKey)
            Then
              Spots(I) = TempSpots(I);
 
         End;  /*  do I  */
 
         If (CurrentPos.Key >= LowerKey) and (CurrentPos.Key <= UpperKey)
          Then
            CurrentPos = TempCurrentPos;
 
         Call M$Close( CloseStarUniqueDelete2 ) Altret ( boom );
       End;  /*  else  */
 
      Call YRC$RekeyCache( SkipStart, SkipEnd, FKey, LKey, NKey, Incr )
       WhenAltReturn do;
         Call M$EraseEdit altret ( boom );
       End;
 
      Call FigureOutLast;
      WriteIt.V.Seed# = '0'B;
      Return;
 
boom:
      Call AltretError;
      Return;
 
End Rekey2;
 
/**/
 
ReadBlock: Proc AltRet;
/*
      Procedure to read a file on disk and insert it as a block in the
      current file.
*/
 
Dcl SourceLine Char(%BufSize) Unal;
Dcl SourceKey UBin Word Unal;
Dcl SourcePos UBin Word Unal;
Dcl SourceLen UBin Word Unal;
Dcl FirstKey SBin Word Unal;
Dcl TheLastKey SBin Word Unal;
Dcl Incr UBin Word Unal;
Dcl BlockSize UBin Word Unal;
Dcl Dual Bit(1);
Dcl Temp Char(255);
Dcl Len UBin Word;
Dcl Buf# SBin;
Dcl 1 TFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
/*
      Start ReadBlock
*/
 
Start:
 
OutLine = 'Name?';
ComLine1 = ' ';
Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
ComLine = ' ';
Call YXH$GoHome;
Call M$Read( ReadUC04 ) Altret ( Skip );
 
If ( ComLine = ' ' ) or ( M$Com$ -> F$Dcb.Ars# = 0 )
 then do;
Skip:
   Call M$CloseSI( CloseSI ) WhenAltReturn do; end;  /* just in case */
   Call MakeAndOpenFid( M$Com# ) WhenAltReturn do; end;
   YYY_ErrCode.Err# = %E$NothingRead;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
   Call YXB$ResetBold;
   AltReturn;
end;
 
Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
Fid = ComLine;
Temp = ComLine;
Call M$Fid( MakeFid )
 WhenAltReturn do;
   Call YXB$SetBold;
   Call YEM$ErrMsg( ,, DcbNum( M$Com ),,,,2,0 );
   Call YXB$ResetBold;
   Goto Start;
 End;
 
Call GetTestFid( M$Com# )
 WhenAltReturn do;
   Goto Start;
 End;
 
Call YYY$FillIn( TFid );
Call CheckBuffers( TFid, Buf# )
 WhenReturn do;  /* he has it open; if it's a work file, give him a choice */
   If (Buffers.SecondaryFid( Buf# ) ~= ' ') and (Buffers.Status.Changed( Buf# ))
    Then do;
      YYY_ErrCode.Err# = %E$OriginalOrWork;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
      Call YXB$ResetBold;
Retry:
      OutLine = 'N,O or Q';
      ComLine1 = ' ';
      Fid = ' ';
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
      ComLine = ' ';
      Call M$ReadUC03( Len );
      If (ComLine = 'Q') or (ComLine = 'q')
       Then
         Goto Skip;
 
      If (ComLine ~= 'N') and (ComLine ~= 'n') and
         (ComLine ~= 'O') and (ComLine ~= 'o')
       Then
         Goto Retry;
 
      If (ComLine = 'N') or (ComLine = 'n')
       Then
         ComLine = Buffers.SecondaryFid( Buf# );
       Else
         ComLine = Temp;
 
    End;  /* if there's a work file of the one he wants to read */
 End;
 
Call MakeAndOpenFid( M$Com# ) WhenAltReturn do; end;
Call M$Fid( BlockFid )
 WhenAltReturn do;
   Call YXB$SetBold;
   Call YEM$ErrMsg( ,, M$Com#,,,,2,0 );
   Call YXB$ResetBold;
   Goto Start;
 End;
 
Call M$Open( OpenblockIn )
      WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# ~= %E$NoFile
          Then do;
            Call YXB$SetBold;
            Call YEM$ErrMsg( ,, DcbNum( M$Com ),,,,2,0 );
            Call YXB$ResetBold;
            AltReturn;
          End;
 
         YYY_ErrCode.Err# = %E$FileDoesNotExist;
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
         Call YXB$ResetBold;
         AltReturn;
      end;
 
SourceLine = UCLine;
SourceKey  = UCKey;
SourcePos  = M$Edit$ -> F$Dcb.ActPos;
SourceLen  = M$Edit$ -> F$Dcb.Ars#;
BlockSize = M$Block$ -> F$Dcb.NRecs#;
 
/*  now find where we're going to put this block  */
 
      Incr = 1;
      
      SIKey.Key = SourceKey;
      PRecSI.V.N# = -1;
 
      Call M$PRecord( PRecSI )
       WhenAltReturn do;
         FirstKey = SourceKey - 1;
         Incr = 1000;
         DelKey.Key = SourceKey;
         DelKey.Len = 3;
         Call M$DelRec( DeleteSI ) Altret ( boom );
         If (LastCacheEntry >= 0 ) and (SourceKey >= Cache(0)) and (SourceKey <= Cache(LastCacheEntry))
          Then do;
            DelUCKey = SourceKey;
            Call M$DelRecEdit Altret ( boom );
          end;
 
         goto rekey;
       end;  /*  When Altret  */
         
      FirstKey = SIKey.Key + 1;
      CurrentPos.Key.Key = FirstKey;/* save new key number of current position */
 
      SIKey.Key = SourceKey;
      PRecSI.V.N# = 1;
 
      Call M$PRecord( PRecSI )
        WhenReturn do;
         TheLastKey = SIKey.Key - 1;
         If SIKey.Len = 0 then do;
          SIKey.Len = 3;
          TheLastKey = SIKey.Key + ( BlockSize * 1000 );
         end;  /*  if  */
        end;
        WhenAltReturn do;
         Incr = 1000;
        end;  /*  When Altret  */
 
      DelKey.Key = SourceKey;
      DelKey.Len = 3;
      /*  gonna delete the sourceline since we're rebuilding it  */
      Call M$DelRec( DeleteSI ) Altret ( boom );
      If (LastCacheEntry >= 0 ) and (SourceKey >= Cache(0)) and (SourceKey <= Cache(LastCacheEntry))
       Then do;
         DelUCKey = SourceKey;
         Call M$DelRecEdit Altret ( boom );
       end;
 
      If Incr = 1 then
        Incr = ( TheLastKey - FirstKey + 1 ) / (BlockSize + 2);
                                           /* 2 for the line split */
 
      If Incr < 10 then do;
         Incr = 1000;
         Goto Rekey;     /*  not enough room in here; rekey the sucker  */
      end;  /*  if  */
 
      FirstKey = FirstKey + (Incr/2);  /* don't start right next to */
      CurrentPos.Key.Key = FirstKey;   /* previous key              */
 
      SIKey.Key = FirstKey;
      If DelKey = Block.KeyStart then Block.KeyStart.Key = FirstKey;
      If DelKey = Block.KeyEnd then Block.KeyEnd.Key = FirstKey;
 
      Dual = %True;
      Call InsertBlockHere(Incr,DcbNum(M$SI),SourceLine,SourcePos,SourceLen,
                           BlockSize,SIKey,Dual) Altret ( boom );
 
      Call M$Close( CloseStarUnique ) Altret ( boom );
      Return;
 
rekey:
      Call Rekey2( Incr, SourceLine, SourcePos, SourceLen, FirstKey, BlockSize);
      Call M$Close( CloseStarUnique ) Altret ( boom );
 
Return;
 
boom:
      Call AltretError;
      Return;
 
End ReadBlock;
 
/**/
 
WriteBlock: Proc AltRet;
/*
      Procedure to write the currently marked block to disk.
*/
Dcl Incr UBin Word Static Unal Init(1000);
 
/*
     Start WriteBlock
*/
      
Call ValidateBlock
   WhenAltReturn do;
      AltReturn;
   End;
 
Start:
 
OpenBlock.V.Exist# = %ERROR#;
OutLine = 'Name?';
ComLine1 = ' ';
Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
ComLine = ' ';
Call YXH$GoHome;
Call M$Read( ReadUC04 ) Altret ( Skip );
 
If ( ComLine = ' ' ) or ( M$Com$ -> F$Dcb.Ars# = 0 )
 then do;
Skip:
   YYY_ErrCode.Err# = %E$NoFileSpecified;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
   Call YXB$ResetBold;
   AltReturn;
 end;
 
Call M$Fid( BlockFid )
   WhenAltReturn do;
    Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
    Goto Start;
   End;
  
Call M$Open( Openblock )
      WhenAltReturn do;
        Call YEG$ErrCode( ErrCode );
        If ErrCode.Err# ~= %E$CreatErr
         Then do;
           Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,3 );
           Goto Start;
         End;
 
        OutLine = ' ';
        ComLine1 = 'Fid exists. Overwrite?(Y,N,Q)';
        Fid = ' ';
        Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
Fool:   Call YXH$GoHome;
        ComLine = ' ';
        Call M$Read( ReadUC04 ) Altret ( Fool );
        ComChar = Substr( ComLine,0,1 );
 
        If (ComChar ~= 'Y') and (ComChar ~= 'y') then
         If (ComChar = 'Q') or (ComChar = 'q') then
           AltReturn;
         else
           goto Start;
 
        Else do;
         OpenBlock.V.Exist# = %NEWFILE#;
         Call M$Open( OpenBlock ) Altret ( boom );
        end;  /*  else  */
      
      end;  /*  Altret  */
 
      SIKey = Block.KeyStart;
      BlockKey.Key = Incr;
      BlockKey.Len = 3;
      SiLine = ' ';
      Call M$ReadSI( ReadSIByKey )
       WhenReturn do;
         UniqueLine = Substr( SILine, Block.PosStart - 1 );
 
         If Block.KeyStart ~= Block.KeyEnd
          Then do;
            Call SetArs;
            WriteStarUniqueK.Buf_.Bound = SIARS# - Block.PosStart;
          End;
          Else
            WriteStarUniqueK.Buf_.Bound = Block.PosEnd - Block.PosStart - 1;
 
         If WriteStarUniqueK.Buf_.Bound > %BufSize-1 then do;
              WriteStarUniqueK.Buf_.Bound = 0;
              UniqueLine = ' ';
         end;
 
         Call M$Write( WriteStarUniqueK ) Altret ( boom );
         BlockKey.Key = BlockKey.Key + Incr;
 
       end;  /*  When Return  */
       WhenAltReturn do;
         PRecSI.V.N# = 0;
         Call M$PRecordSI( PRecSI ) WhenAltReturn do; end;
       end;  /*  When Altret  */
 
      Do While %True;
       Call M$ReadSI( ReadSI ) Altret ( EOF );
       If SIKey.Key > Block.KeyEnd.Key then goto EOF;
       If SIKey.Key = Block.KeyEnd.Key then do;
         If Block.PosEnd = 1 then goto EOF;  /*  use none of this line  */
         Call SetArs;
         If SIARS# >= Block.PosEnd
          Then do;
            UniqueLine = Substr( SILine, 0, Block.PosEnd - 1 );
            WriteStarUniqueK.Buf_.Bound = Block.PosEnd - 2;
          end;
          else do;
            UniqueLine = Substr( SILine, 0, SIARS# );
            WriteStarUniqueK.Buf_.bound = SIARS# -1 ;
          end;  /*  else  */
  
       end;  /*  if  */
       else do;
         UniqueLine = SILine;
         Call SetArs;
         If SIARS# > 0 then
           WriteStarUniqueK.Buf_.Bound = SIARS# - 1;
         else do;
           WriteStarUniqueK.Buf_.Bound = 0;
           UniqueLine = ' ';
         end;  /*  else  */
       end;  /*  else  */
 
       Call M$Write( WriteStarUniqueK ) Altret ( boom );
       BlockKey.Key = BlockKey.Key + Incr;
 
      end;  /*  do while  */
 
EOF:
      Call M$Close( CloseStarUnique ) Altret ( boom );
fin:  Return;
      
boom:
      Call AltretError;
      Return;
 
End WriteBlock;
 
/**/
 
SaveBuffer: Proc AltRet;
/*
      Procedure to save the currently marked block to a temp buffer
*/
 
Call ValidateBlock
   WhenAltReturn do;
      AltReturn;
   End;
 
Call MakeUniqueName;
Call SaveBlock( SavedSize ) AltRet ( boom );
Call M$Open( DeleteSAndM ) WhenAltReturn do; end;  /* don't care */
SAndMFid = StarUnique;
 
Return;
 
boom:
   Call AltRetError;
   Return;
 
End SaveBuffer;
 
/**/
 
MergeBuffer: Proc AltRet;
/*
      Procedure to merge in the saved buffer at the current cursor
      location.
*/
 
If SAndMFid.Name# = ' '
 Then do;
   YYY_ErrCode.Err# = %E$NoBlockSaved;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
   Call YXB$ResetBold;
   AltReturn;
 End;
 
StarUnique = SAndMFid;
Call M$Open( OpenStarUniqueIn ) Altret ( boom );
Call MergeBlock( SavedSize ) Altret ( boom );
Call M$Close( CloseStarUnique ) Altret ( boom );
 
Return;
 
boom:
      Call AltretError;
      Return;
 
End MergeBuffer;
 
/**/
 
DisplaySettings: Proc;
/*
      This procedure will output the current settings of various flags and
      values to the line below the status bar.  
*/
 
Dcl Column UBin Word WAligned;
Dcl InsOvr Char( 10 );
Dcl SearchDir Char( 7 );
Dcl HScroll UBin;
Dcl Strip UBin;
Dcl ReadOnlyF UBin;
Dcl TextEdit UBin;
Dcl RcrWrap UBin;
Dcl EasyAppend UBin;
 
/*  Start  */
 
      Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
      Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
      Column = VLPEditWindowSettings.WordWrapClm#;
 
      If ( VlpEditWindowSettings.InsertMode# = '00'B ) or
         ( VlpEditWindowSettings.InsertMode# = '01'B )
            then InsOvr = 'Overstrike';
            else InsOvr = 'Insert';
 
      If ( VlpEditWindowSettings.HScroll# = '00'B ) or
         ( VlpEditWindowSettings.HScroll# = '01'B )
            then HScroll = 0;
            else HScroll = 1;
 
      If ( VlpEditWindow2.TextEdit# = '00'B ) or
         ( VlpEditWindow2.TextEdit# = '01'B )
            then TextEdit = 0;
            else TextEdit = 1;
 
      If ( VlpEditWindow2.EasyAppend# = '00'B ) or
         ( VlpEditWindow2.EasyAppend# = '01'B )
            then EasyAppend = 0;
            else EasyAppend = 1;
 
      If ( VlpEditWindow2.RcrWrap# = '00'B ) or
         ( VlpEditWindow2.RcrWrap# = '01'B )
            then RcrWrap = 0;
            else RcrWrap = 1;
 
      If StripFlag
         Then Strip = 1;
         Else Strip = 0;
 
      If InputOnlyFlag 
         Then ReadOnlyF = 1;
         Else ReadOnlyF = 0;
 
      If ForwardSearch
         Then SearchDir = 'Forward';
         Else SearchDir = 'Reverse';
 
      Call YXB$SetBold;
      Call X$Write( FDS2, Vector( SettingsFormat ),
                          Vector( Column ),
                          Vector( InsOvr ),
                          Vector( HScroll ),
                          Vector( Strip ),
                          Vector( ReadOnlyF ),
                          Vector( SearchDir ),
                          Vector( TextEdit ),
                          Vector( RcrWrap ),
                          Vector( EasyAppend ) );
 
      Call YXB$ResetBold;
      Return;
 
boom:
      Call AltretError;
      Return;
 
End DisplaySettings;
 
/**/
 
GetCommandChar: Proc (Which) Altret;
/*
      This procedure will read UC04 for the subcommand character.
*/
 
Dcl Which Char(2) Param;
 
   OutLine = Which;
   ComLine1 = ' ';
   Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
   Call YXH$GoHome;
   Call M$STrmCtl( FPTTrmCtlInput ) Altret ( boom );
   ComChar = ' ';
   Call M$Read( ReadUC04Char )
    WhenAltReturn do;
      Call M$STrmCtl( FPTEcho ) Altret ( boom );
      AltReturn;
    end;
 
   Call M$STrmCtl( FPTEcho ) Altret ( boom );
   If AscBin( ComChar ) <= AscBin( ' ' )
    Then
      AltReturn;
 
   Return;
 
boom:
   Call YEM$ErrMsg(,,DcbNum( M$UC ));
   AltReturn;
 
End GetCommandChar;
 
/**/
 
DoAKCommand: Proc;
/*
      This procedure will determine which of the ^K commands was asked for and
      then execute it.
*/
Dcl RePosition Bit(1);
Dcl SayIt Bit(1);
Dcl Column UBin Half HAligned;
Dcl Junk UBin Word;
 
/* Start procedure */
 
         RePosition = %True;
         SayIt = %False;
         Call GetCommandChar('^K') AltRet ( None );
 
         Do Case AscBin ( ComChar );
           Case(   321     ); /* No activating char */
              RePosition = %False;
 
           Case( 46 );        /* . is mark spot */
              Call MarkSpot(10);
              RePosition = %False;
              SayIt = %True;
              YYY_ErrCode.Err# = %E$SpotMarked;
 
           Case( 48,49,50,51,52,53,54,55,56,57 );  /*  0-9 are mark spots  */
              Junk = AscBin(ComChar) - 48;
              Call MarkSpot(Junk);
              RePosition = %False;
              SayIt = %True;
              YYY_ErrCode.Err# = %E$SpotMarked;
 
           Case(  98, 66,2 ); /* ^B  is begin block */
              Call MarkBegin;
              RePosition = %False;
              SayIt = %True;
              YYY_ErrCode.Err# = %E$BlockBegin;
 
           Case(  99, 67,3 ); /* ^C  is copy block */
              If InputOnlyFlag or SequenFlag
               then do;
                 If Not InputOnlyFlag
                  Then
                    YYY_ErrCode.Err# = %E$NoWritesSequen;
                  Else
                    YYY_ErrCode.Err# = %E$NoWrites;
 
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
               End;
               else do;
                Call CopyBlock
                 WhenReturn do;
                   SayIt = %True;
                   YYY_ErrCode.Err# = %E$BlockCopy;
                 End;
 
                Call FigureOutLast;
               end;  /*  else do  */
 
           Case(  100,68,4 ); /* ^D  is exit */
              Done = %True;
              Return;
 
           Case(  104,72,8 ); /* ^H  is unmark block */
              Call UnMark;
              RePosition = %False;
              SayIt = %True;
              YYY_ErrCode.Err# = %E$BlockUnMarked;
 
           Case( 107,75,11 ); /* ^K  is end block */
              Call MarkEnd;
              RePosition = %False;
              SayIt = %True;
              YYY_ErrCode.Err# = %E$BlockEnd;
 
           Case( 109,77,13 ); /* ^M  is merge in the temp buffer */
              If InputOnlyFlag or SequenFlag
               then do;
                 If Not InputOnlyFlag
                  Then
                    YYY_ErrCode.Err# = %E$NoWritesSequen;
                  Else
                    YYY_ErrCode.Err# = %E$NoWrites;
  
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
               End;
               else do;
                Call MergeBuffer
                 WhenReturn do;
                   SayIt = %True;
                   YYY_ErrCode.Err# = %E$BlockMerged;
                 End;
 
                Call FigureOutLast;
               end;  /*  else do  */
  
           Case( 114,82,18 ); /* ^R  is read a block from disk */
              If InputOnlyFlag or SequenFlag
               then do;
                 If Not InputOnlyFlag
                  Then
                    YYY_ErrCode.Err# = %E$NoWritesSequen;
                  Else
                    YYY_ErrCode.Err# = %E$NoWrites;
  
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
               End;
               else do;
                Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
                Call ReadBlock
                 WhenReturn do;
                   SayIt = %True;
                   YYY_ErrCode.Err# = %E$BlockRead;
                 End;
 
                Call YWS$DownString( CmdCloseLine,CmdClose#,%E$BadCmdCloseStr );
                Call FigureOutLast;
               end;  /*  else do  */
 
           Case( 115,83,19 ); /* ^S  is save a block in temp buffer */
              Call SaveBuffer
               WhenReturn do;
                 SayIt = %True;
                 YYY_ErrCode.Err# = %E$BlockSaved;
               End;
 
              RePosition = %False;
 
           Case( 118,86,22 ); /* ^V  is move block */
              If InputOnlyFlag or SequenFlag
               then do;
                 If Not InputOnlyFlag
                  Then
                    YYY_ErrCode.Err# = %E$NoWritesSequen;
                  Else
                    YYY_ErrCode.Err# = %E$NoWrites;
  
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
               End;
               Else do;
                 SayIt = %True;
                 YYY_ErrCode.Err# = %E$BlockMove;
                 Call CopyBlock
                  WhenReturn do;
                    MovingFlag = %True;
                    Call DeleteBlock
                     WhenReturn do;
                       Call UnMark;
                     End;
                     WhenAltReturn do;
                       SayIt = %False;
                     End;
 
                    MovingFlag = %False;
                  End;  /*  when return on Copy  */
                  WhenAltReturn do;
                    SayIt = %False;
                  End;
 
               End;  /*  else  */
 
           Case( 119,87,23 ); /* ^W  is write a block to disk */
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              Call WriteBlock
               WhenReturn do;
                 SayIt = %True;
                 YYY_ErrCode.Err# = %E$BlockWritten;
               End;
 
              RePosition = %False;
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case( 121,89,25 ); /* ^Y  is delete block */
              If InputOnlyFlag or SequenFlag
               then do;
                 If Not InputOnlyFlag
                  Then
                    YYY_ErrCode.Err# = %E$NoWritesSequen;
                  Else
                    YYY_ErrCode.Err# = %E$NoWrites;
  
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
               End;
               else do;
                Call DeleteBlock
                 WhenReturn do;
                   Call UnMark;
                   SayIt = %True;
                   YYY_ErrCode.Err# = %E$BlockDelete;
                 End;
 
               end;
 
           Case( 122,90,26 ); /* ^Z  is copy the current file */
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              Call SaveFile( Buffers.PrimaryFid(CurrentBuffer#),
                             Buffers.SecondaryFid(CurrentBuffer#),
                             Buffers.Password#(CurrentBuffer#) )
               WhenReturn do;
                 SayIt = %True;
                 YYY_ErrCode.Err# = %E$FileSaved;
               End;
 
              RePosition = %False;
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case( Else );
              RePosition = %False;
              YYY_ErrCode.Err# = %E$IllegalCommand;
              Call YXB$SetBold;
              Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
              Call YXB$ResetBold;
 
      End; /*  Case  */
 
None:
      Call MakeAnnouncements;
 
/*  re-position the user to the beginning of the proper block  */
 
      If RePosition
       then do;
         If CurrentPos.Column = 0
          Then
            Column = CurrentPos.Column;
          Else
            Column = CurrentPos.Column - 1;
 
         If CurrentPos.Key.Key > LastKey.Key
          Then
            Call GotoEnd;
          Else do;
            SIKey = CurrentPos.Key;
            Call Position( Column );
          End;  /*  else  */
 
       End;  /*  if re-pos  */
 
      If SayIt
       Then do;
         Call YXB$SetNorm;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,,0 );
       End; /*  if  */
 
      Return;
 
End DoAKCommand;
 
/**/
 
DoACCommand: Proc;  /* formerly DoAQCommand */
/*
      This procedure will determine which of the ^C commands was asked for and
      then execute it.
*/
 
Dcl Junk UBin Word;
Dcl Len UBin Word;
Dcl Column UBin Half WAligned;
 
  NextPrevBuffer: Proc ( whichway );
  /*
      goto a different buffer
  */
 
  Dcl whichway UBin;
 
      If Buffers# = 1
       Then
         If Buffers.Status.WorkMissing( 0 )
          Then do;
            YYY_ErrCode.Err# = %E$MissingWorkFile;
            Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Com ),,,,2,0 );
            Goto BigTrouble;
          End;
          Else
            Return;
  
      Call SaveCurrent;
      Call M$CloseSI( CloseSI )
       WhenAltReturn do;
         Call SetErrCode;
         WorkFlag = %False;
         If ErrCode.Err# ~= %E$DCBCLOSED
          then
            goto boom;
       end; /* When Altret */
  
      Call CheckIfEmpty
       WhenAltReturn do;  /*  deleted the empty file  */
         Call SqueezeBuffers;
         If WhichWay = %Nextbuf
          Then do;
            CurrentBuffer# = CurrentBuffer# - 1;  /* have to adjust for next */
            If CurrentBuffer# < 0
             Then
               CurrentBuffer# = Buffers# + CurrentBuffer#;
 
          End;  /*  adjust for next  */
       End;  /*  When Altret  */
 
      Call M$EraseEdit Altret ( boom );
      If whichway = %PrevBuf
       Then
         Call PrevBuffer;
       Else
         Call NextBuffer;
 
      Call RestoreSettings;
      Call MakeAndOpenFid( DcbNum( M$UC ) ) Altret ( BigTrouble );
 
      SIKey = Buffers.CurrentPos.Key( CurrentBuffer# );
      Column = Buffers.CurrentPos.Column( CurrentBuffer# ) - 1;
      If SIKey.Key > LastKey.Key
       Then do;
         SIKey.Key = LastKey.Key;
         Column = 0;
       End;
   
      Call Position( Column );
 
      Return;
 
boom:
      Call AltRetError;
      Return;
 
BigTrouble:
      TroubleFlag = %True;
      Call XCommandWindow;
      Return;
 
  End NextPrevBuffer;
 
/*
      Start DoACCommand
*/
 
         Call GetCommandChar('^C') AltRet ( None2 );
         Do Case AscBin ( ComChar );
           Case( 321 ); /* No activating char */
              Do; End;
 
           Case( 43 );  /*  + is goto next file  */
              Call NextPrevBuffer( %NextBuf );
 
           Case( 45 );  /*  - is goto prev file  */
              Call NextPrevBuffer( %PrevBuf );
 
           Case( 46 );  /*  . is goto spot  */
              Call GotoSpot( Spots.Column(10), Spots.Key(10) );
 
           Case( 48,49,50,51,52,53,54,55,56,57 );  /*  0-9 are goto spots  */
              Junk = AscBin(ComChar) - 48;
              Call GotoSpot( Spots.Column(Junk), Spots.Key(Junk) );
 
           Case( 63 );  /*  ? is  Where am I?  */
              Len = CurrentPos.Column;
              Call WhichLine( UCKey, Len );
 
           Case(  97, 65,1 ); /* ^A  is replace word */
              If InputOnlyFlag
               then do;
                 YYY_ErrCode.Err# = %E$NoWrites;
                 Call YXB$SetBold;
                 Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                 Call YXB$ResetBold;
                 goto None2;
              end;  /*  if  */
                   
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              LastOperation = %Replace;
              ForwardSearch = %True;
              OutLine = 'Replace:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              ComLine = FindWord.words;
              SInputUC03.Buf_.Bound = FindWord.Len - 1;
              Call M$SInput( SInputUC03 ) Altret ( boom );
              Call M$ReadUC03( Len );
              If Len > 0
               Then do;
                 FindWord.len = Len;
                 FindWord.words = ComLine;
               End;
 
              OutLine = 'With:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              ComLine = Replacement.words;
              SInputUC03.Buf_.Bound = Replacement.Len - 1;
              Call M$SInput( SInputUC03 ) Altret ( boom );
              Call M$ReadUC03( Len );
              If Len > 0
               Then do;
                 Replacement.len = Len;
                 Replacement.words = ComLine;
               End;
 
              OutLine = 'options:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              ComLine = RepOps;
              Call SearchR( Junk, JunkUBin1, B$SR_NON_BLANK, RepOps );
              If ComLine = ' '
               Then
                 Junk = 0;
 
              SInputUC03.Buf_.Bound = Junk;
              Call M$SInput( SInputUC03 ) Altret ( boom );
              Call M$ReadUC03( Junk );
              RepOps = ComLine;
 
              Call YSR$Replace( FindWord, Replacement, RepOps );
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case(  98, 66,2 ); /* ^B  is goto beginning of marked block */
              Call GotoSpot( Block.PosStart, Block.KeyStart );
 
           Case(  99, 67,3 ); /* ^C  is end of document */
              OutLine = 'Working';
              ComLine1 = ' ';
              Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              Call GotoEnd;
 
           Case(  102,70,6 ); /* ^F  is find word */
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              LastOperation = %Find;
              ForwardSearch = %True;
              OutLine = 'Find:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              ComLine = FindWord.words;
              SInputUC03.Buf_.Bound = FindWord.Len - 1;
              Call M$SInput( SInputUC03 ) Altret ( boom );
              Call M$ReadUC03( Len );
              If Len > 0
               Then do;
                 FindWord.len = Len;
                 FindWord.words = ComLine;
               End;
  
              OutLine = 'options:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              ComLine = FinOps;
              Call SearchR( Junk, JunkUBin1, B$SR_NON_BLANK, FinOps );
              If ComLine = ' '
               Then
                 Junk = 0;
  
              SInputUC03.Buf_.Bound = Junk;
              Call M$SInput( SInputUC03 ) Altret ( boom );
              Call M$ReadUC03( Junk );
              FinOps = ComLine;
 
              Call YSF$Find( FindWord, FinOps );
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case(  104,72,8 ); /* ^H  is goto command window */
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              Call XCommandWindow;
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case( 107,75,11 ); /* ^K  is goto end of marked block */
              Call GotoSpot( Block.PosEnd, Block.KeyEnd );
 
           Case( 114,82,18 ); /* ^R  is beginning of block */
              OutLine = 'Working';
              ComLine1 = ' ';
              Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              Call GotoStart;
 
           Case( 83, 115 );    /* ^C S is display status  */
              Call DisplaySettings;
 
           Case( Else );
              YYY_ErrCode.Err# = %E$IllegalCommand;
              Call YXB$SetBold;
              Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
              Call YXB$ResetBold;
 
      End; /*  Case  */
 
None2:
      Call MakeAnnouncements Altret ( boom );
 
      Return;
 
boom:
      Call AltretError;
      Return;
 
End DoACCommand;
 
/**/
 
DoAnOCommand: Proc;
/*
      This procedure will execute a ^O command.  Basically, for formatting
      the screen, functions like WordWrap.
*/
Dcl Wrap UBin Word WAligned;
Dcl Len UBin;
Dcl SayIt Bit(1);
Dcl 1 U1,
    2 L# UBin(9) Unal,
    2 Text# Char(11) Unal;
 
Dcl 1 U2,
    2 L# UBin(9) Unal,
    2 Text# Char(11) Unal;
 
         Call GetCommandChar('^O') AltRet ( None3 );
         SayIt = %False;
 
         Do Case AscBin ( ComChar );
           Case( 321 ); /* No activating char */
              Do; End;
 
           Case( 69, 101 );    /* ^O E is toggle EasyAppend mode */
              Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
              If (VlpEditWindow2.EasyAppend# = '00'B) or
                 (VlpEditWindow2.EasyAppend# = '01'B)
               Then do;
                 VlpEditWindow2.EasyAppend# = '10'B;
                 U2.L# = 2;
                 U2.Text# = 'on';
               End;
               Else do;
                 VlpEditWindow2.EasyAppend# = '00'B;
                 U2.L# = 3;
                 U2.Text# = 'off';
               End;
 
              Call M$STrmCtl( EditWindow2 ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 10;
              U1.Text# = 'EasyAppend';
 
           Case( 8,72,104 );  /* ^O H toggles horizontal scroll mode */
              Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
 
              If ( VlpEditWindowSettings.HScroll# = '00'B ) or
                 ( VlpEditWindowSettings.HScroll# = '01'B )
               then do;
                 VlpEditWindowSettings.HScroll# = '10'B;
                 U2.L# = 2;
                 U2.Text# = 'on';
               End;
               Else do;
                 VlpEditWindowSettings.HScroll# = '00'B;
                 U2.L# = 3;
                 U2.Text# = 'off';
               End;
 
              Call M$STrmCtl( EditWindowSettings ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 7;
              U1.Text# = 'HScroll';
 
           Case( 9,73,105 );  /* ^O I sets insertion mode */
              VLPInsertMode.InsertMode# = '10'B;
 
              Call M$STrmCtl( FPTTrmCtlInsert ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 6;
              U1.Text# = 'Insert';
              U2.L# = 2;
              U2.Text# = 'on';
 
           Case( 15,79,111 ); /* ^O O sets overtype mode */
              VLPInsertMode.InsertMode# = '00'B;
 
              Call M$STrmCtl( FPTTrmCtlInsert ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 10;
              U1.Text# = 'Overstrike';
              U2.L# = 2;
              U2.Text# = 'on';
 
           Case( 114,82,18 ); /* ^O R is set wordwrap column */
              Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
              OutLine = 'Width:';
              ComLine1 = ' ';
              Fid = ' ';
              Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
              Call M$ReadUC03( Len );
              Call Search( JunkUBin1, JunkUBin2, B$Sr_Non_Dec, Substr(ComLine,0,Len) )
                WhenReturn do;
                   Wrap = 0;
                End;
                WhenAltReturn do;
                   If ( Len = 0 ) or ((Len = 1) and ( Substr(Comline,0,1) = ' ' ))
                    then
                        Wrap = 0;
                    Else
                        Call CharBin( Wrap, Substr( ComLine, 0, Len ) );
                End;  /*  When Altret  */
 
              If Wrap > %WrapLimit
               Then do;
                 Wrap = %WrapLimit;
                 Call YXB$SetBold;
               End;
               Else
                 Call YXB$SetNorm;
 
              VLPTrmCtl.WordWrapClm# = Wrap;
              Call M$STrmCtl( FPTTrmCtl ) Altret ( boom );
              YYY_ErrCode.Err# = %E$WordWrap;
              Call BinChar( U1.Text#, Wrap );
              U1.L# = LengthC(U1.Text#);
              Do While (Substr(U1.Text#,0,1) = '0') and (U1.L# > 1);
                U1.Text# = Substr(U1.Text#,1);
                U1.L# = U1.L# - 1;
              End;
 
              Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),Vector(U1),,,,0 );
              Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
 
           Case( 83, 115 );    /* ^O S is toggle strip blanks  */
              StripFlag = ~StripFlag;
              If StripFlag
               Then do;
                 ReadUC02.V.DVByte.BP# = %False;
                 U2.L# = 2;
                 U2.Text# = 'on';
               End;
               Else do;
                 ReadUC02.V.DVByte.BP# = %True;
                 U2.L# = 3;
                 U2.Text# = 'off';
               End;
 
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 5;
              U1.Text# = 'Strip';
 
           Case( 84, 116 );    /* ^O T is toggle TextEdit mode */
              Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
              If (VlpEditWindow2.TextEdit# = '00'B) or
                 (VlpEditWindow2.TextEdit# = '01'B)
               Then do;
                 VlpEditWindow2.TextEdit# = '10'B;
                 U2.L# = 2;
                 U2.Text# = 'on';
               End;
               Else do;
                 VlpEditWindow2.TextEdit# = '00'B;
                 U2.L# = 3;
                 U2.Text# = 'off';
               End;
 
              Call M$STrmCtl( EditWindow2 ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 8;
              U1.Text# = 'TextEdit';
 
           Case( 87, 119 );    /* ^O W is toggle RcrWrap mode */
              Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
              If (VlpEditWindow2.RcrWrap# = '00'B) or
                 (VlpEditWindow2.RcrWrap# = '01'B)
               Then do;
                 VlpEditWindow2.RcrWrap# = '10'B;
                 U2.L# = 2;
                 U2.Text# = 'on';
               End;
               Else do;
                 VlpEditWindow2.RcrWrap# = '00'B;
                 U2.L# = 3;
                 U2.Text# = 'off';
               End;
 
              Call M$STrmCtl( EditWindow2 ) Altret ( boom );
              SayIt = %True;
              YYY_ErrCode.Err# = %E$ToggleMode;
              U1.L# = 7;
              U1.Text# = 'RcrWrap';
  
           Case( Else );
              YYY_ErrCode.Err# = %E$IllegalCommand;
              Call YXB$SetBold;
              Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
              Call YXB$ResetBold;
 
      End; /*  Case  */
 
None3:
      Call MakeAnnouncements Altret ( boom );
      If SayIt
       Then do;
         Call YXB$SetNorm;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),
                          Vector(U1),Vector(U2),,,0 );
       End; /*  if  */
 
      Return;
 
boom:
      Call AltretError;
      Return;
 
End DoAnOCommand;
 
/**/
 
RepeatLastFindReplace: Proc;
/*
      Procedure to repeat the last find or replace function.
*/
Do Case LastOperation;
 Case( %Find );
   Call YSF$Find( FindWord, FinOps );
 Case( %Replace );
   If InputOnlyFlag
    Then do;
      YYY_ErrCode.Err# = %E$NoWrites;
      Call YXB$SetBold;
      Call YEM$ErrMsg( YYY_ErrCode,,DcbNum(M$Com),,,,1,0);
      Call YXB$ResetBold;
      Return;
    End;
 
   Call YSR$Replace( FindWord, Replacement, RepOps );
 
 Case( Else );
   Do; End;
end; /* Case */
 
Call MakeAnnouncements;
Return;
 
End RepeatLastFindReplace;
 
/**/
 
WriteTheLine: Proc;
/*
      This procedure will write the Returned line of text to the file.
*/
 
      Dcl Bound UBin Static;
      Dcl junk UBin Static;
      Dcl where UBin Half;
 
      If Not InputOnlyFlag
       Then Do;
         If M$Edit$ -> F$Dcb.Ars# > 0
          Then
            WriteSI.Buf_.Bound = M$Edit$ -> F$Dcb.Ars# - 1;
          Else
            If (UCKey > LastKey.Key) and
               (M$Edit$ -> F$Dcb.EomChar# ~= %EOM_EOR#)
             Then do;
               Call M$DelRec( DelUC02 ) Altret ( boom );
               Goto Fin;  /*  don't bother with rest of this routine  */
             End;
             Else
              If (UCKey = LastKey.Key) and (LastCacheEntry > -1) and
                 (M$Edit$ -> F$Dcb.EomChar# ~= %EOM_EOR#)
               then do;  /*  special case!  */
                 Call YSD$DeleteRecord;
                 Call M$DelRec( DelUC02 ) Altret ( boom );
                 Goto Fin;  /*  don't bother with rest of this routine  */
               end;  /*  if do  */
               Else do;
                 UCLine = ' ';
                 WriteSI.Buf_.Bound = 0;
               End;  /*  Do  */
 
         If StripFlag and Not SequenFlag   /* strip trailing blanks */
          Then Do;
            Call SearchR (Bound, junk, B$SR_NON_BLANK,
                          SubStr (UCLine, 0, M$Edit$ -> F$DCB.ARS#) )
             WhenReturn Do;
               WriteSI.Buf_.Bound = Bound;
             End;
             WhenAltReturn Do;
               WriteSI.Buf_.Bound = 0;  /* keep one blank around */
             End;
 
            If Bound ~= M$Edit$ -> F$Dcb.Ars# - 1
             Then do;  /*  tell the FEP what we did...  */
               WriteUC02.Buf_.Bound = WriteSI.Buf_.Bound;
               SILine = UCLine;
               Call M$WriteUC02 Altret ( boom );
             End;
 
          end;   /*  if strip blanks mode on  */
 
         SIKey.Len = 3;
         SIKey.Key = UCKey;
         WriteTheLineFlag = %True;
 
         Call M$WriteSI( WriteSI ) Altret ( boom );
 
         WriteTheLineFlag = %False;
         If UCKey > LastKey.Key       /*  bogus record keeping  */
          Then
            LastKey.Key = UCKey;
 
         If UCKey > %MaxSequenceNumber
          Then do;
            LastCacheEntry = -1;  /* to force clear of window */
            Split.Key.Key = UCKey;
            Split.Key.Len = 3;
            Split.Buf.Line = UCLine;
            Split.Buf.Len = M$Edit$ -> F$Dcb.Ars#;
            Split.Pos = M$Edit$ -> F$Dcb.Ars# + 1;  /* keep the whole line */
            Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
            If VLPEditWindowSettings.WordWrapClm# > 0
             then
               WordWrapping = %True;
             else
               WordWrapping = %False;
 
            WordWrapClm# = VLPEditWindowSettings.WordWrapClm#;
            AutoTabClm# = VLPEditWindowSettings.AutoTabClm#;
            Call RekeySI;
            Call MakeAnnouncements Altret ( boom );
            SIKey = LastKey;
            Where = 0;
            Call Position( Where );
          End;  /*  if  */
 
      Call UpdateCache;
 
      end;  /*  if not inputonly  */
 
      else      /*  restore the line to original condition  */
        If Not SE2Flag
         Then  /*  need to use the old ReadOnly stuff  */
           Call FixUpRecord;
 
fin:  Return;
 
boom:
      Call AltretError;
      Return;
 
End WriteTheLine;
 
/**/
 
GetFirst: Proc(ErrDcb#) Altret;
/*
      Procedure to get the first line of an edit file to the FEP.
*/
 
Dcl ErrDcb# SBin Param;
      
      Call FigureOutLast;
      Call M$PFilSI( PosBOF ) Altret ( SourPMME );
 
      Call M$ReadSI( ReadSI )
         WhenReturn Do;           /*  get first line of file and send to FEP  */
           UCKey = SIKey.Key;
           Call SetArs;
           If SIARS# > 0 then
             WriteUC02.Buf_.Bound = SIARS# - 1;
           else do;
             WriteUC02.Buf_.Bound = 0;
             SILine = ' ';
           end;
           Call M$WriteUC02 Altret ( SourPMME );
 
         End; /*  WhenReturn  */
         WhenAltReturn Do;        /*  No first line, i.e. creating new file  */
          Call SetErrCode;
 
          If (ErrCode.ERR# = %E$EOF)
            Then do;
              UCLine = ' ';
              SILine = ' ';
              SIKey.Len = 3;
              SIKey.Key = 10000;
              UCKey = 10000;
              ReadUC02.V.KeyS# = %Yes#;
            end;  /*  if need to create a record  */
            else
              Call YEM$ErrMsg( ErrCode, DcbNum( M$SI ), DcbNum( M$UC ),,,,2 );
 
         End; /*  WhenAltReturn  */
 
      Call SaveCurrent;  /* make sure entire buffer entry is initialized */
      Return;
 
SourPMME:
      Call AltretError;
      Return;
 
End GetFirst;
 
/**/
 
FigureOutLast: Proc;
/*
      What's the last key number in the file?
*/
 
If SequenFlag
 Then do;
   LastKey.Len = 3;
   LastKey.Key = M$SI$ -> F$Dcb.NRecs#;
 End;
 Else
   Call M$PFil( PosEOF )
    WhenReturn do;
      Call M$PRecord( GetLastKey )
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If (ErrCode.Err# ~= %E$BOF) and (ErrCode.Err# ~= %E$BADVECT1)
          Then                          /* this will be found soon enough */
            Goto boom;
 
         LastKey.Key = 0;
         LastKey.Len = 3;
       End;  /*  When Altret on PRec  */
 
    End;  /*  When Return on PFil  */
    WhenAltReturn do;
      Goto boom;
    End;
 
Return;
 
boom:
   Call AltretError;
   Return;
 
End FigureOutLast;
 
/**/
 
ParseCommandLine: Proc( InputOnlyFlag, WorkFlag, Crpt, Local$ );
/*
      Procedure to parse the Command line options.
*/
 
Dcl Local$ Ptr;
%Parse$Out ( Name = Out, StClass = "BASED(Local$)" );
            
Dcl WorkFlag Bit(1);
Dcl InputOnlyFlag Bit(1);
Dcl Crpt Bit(36);
 
Dcl Where1 UBin Word WAligned;
 
/*
      Start Parser 
*/
 
      Do Case Out.Sublk$( 0 ) -> Out.Code;
 
          Case( %Work );
            WorkFlag = %True;
 
          Case( %NWork );
            WorkFlag = %False;
 
          Case( %InputOnly );
            InputOnlyFlag = %True;
            EditOldFile.V.Fun# = %In#;
 
          Case( %Update );
            InputOnlyFlag = %False;
            EditOldFile.V.Fun# = %Update#;
 
          Case( %Crpt );
            Call ComputeCrpt( Out.Sublk$(0)->Out.Sublk$(0), Crpt );
 
          Case( Else );
            Call YPT$WindowOptions( Out.Sublk$(0) ) WhenAltReturn do; end;
 
      End;  /*  do case  */
 
      Return;
 
End ParseCommandLine;
 
/**/
 
ComputeCrpt: Proc ( Local$, Crpt );
/*
      Figure out what crpt to use (octal)
*/
 
Dcl I UBin;
Dcl Chars Char(12);
Dcl Local$ Ptr;
Dcl Crpt Bit(36);
Dcl CrptNum ReDef Crpt UBin;
 
%Parse$Out ( Name = Out, StClass = "BASED(Local$)" );
%Parse$Sym ( Name = Sym, StClass = "BASED(Local$)" );
 
   CrptNum = 0;
   Chars = Local$ -> Sym.Text;
   Do I = 0 to Local$ -> Sym.Count - 1;
      CrptNum = (CrptNum * 8) + AscBin(Substr(Chars,I,1)) - AscBin( '0' );
   End;  /*  do I  */
 
   Return;
 
End ComputeCrpt;
 
/**/
 
MakeWorkFile: Proc( Err#, Dcb#, PassErrCode ) Altret;
/*
      Procedure to create a temporary work file
*/
Dcl Uniquename Char(6) Static;
Dcl Err# Sbin;
Dcl Dcb# Sbin;
%VLP_ERRCODE( FPTN = PassErrCode, STCLASS=PARAM );
Dcl Incr UBin;
 
/*  start  */
 
Mode = %WorkFile;
Call M$Open( OpenSIIn )
 WhenReturn do;
   If M$SI$ -> F$Dcb.Org# ~= %Keyed#
    Then
      Incr = 1000;
    Else
      Incr = 0;
 
   NumberOfRecs = M$SI$ -> F$Dcb.NRecs#;
   If M$SI$->F$Dcb.Pass# ~= ' '
    Then do;
      Buffers.Password#( CurrentBuffer# ) = M$SI$->F$Dcb.Pass#;
      BabyFIT.Password# = M$SI$->F$Dcb.Pass#;
      SetWork.IFParam_ = Vector( BabyFIT );
    End;
    Else do;
      Buffers.Password#( CurrentBuffer# ) = ' ';
      SetWork.IFParam_ = Vector( Nil );
    End;
 
 End;  /*  When Return  */
 WhenAltReturn do;
   Call YEG$ErrCode( ErrCode );
   If ErrCode.Err# ~= %E$NoFile
    Then
      Goto boom;
 
   If (ErrCode.Err# = %E$NoFile) and InputOnlyFlag
    Then
      AltReturn;
 
   NumberOfRecs = 0;  /*  new/work file  */
   Buffers.Status.NewFile( CurrentBuffer# ) = %True;
   If M$SI$->F$Dcb.Pass# ~= ' '
    Then do;
      Buffers.Password#( CurrentBuffer# ) = M$SI$->F$Dcb.Pass#;
      BabyFIT.Password# = M$SI$->F$Dcb.Pass#;
      OpenStarUniqueK.IFParam_ = Vector( BabyFIT );
      SetWork.IFParam_ = Vector( BabyFIT );
    End;  /* if */
    Else do;
      Buffers.Password#( CurrentBuffer# ) = ' ';
      OpenStarUniqueK.IFParam_ = Vector( Nil );
      SetWork.IFParam_ = Vector( Nil );
    End;  /* else */
 
 End;  /*  When AltReturn  */
 
Loop:
Call YMU$Unique( Uniquename );
Call Concat( StarUnique.Name#, '*', UniqueName );
StarUnique.L# = 7;
 
Call M$Open( OpenStarUniqueK )
  WhenAltReturn do;
    Call YEG$Errcode( ErrCode );
    If ErrCode.Err# = %E$CreatErr
     Then
       Goto loop;
     Else do;
       OpenStarUniqueK.IFParam_ = Vector( FileAttr );
       Call AltretError;
     End;
 
  end;
 
OpenStarUniqueK.IFParam_ = Vector( FileAttr );
Buffers.Status.DeleteWork( CurrentBuffer# ) = %True;
If NumberOfRecs > 0
 Then do;
   If AlreadyStarted
    Then
      Call X$Write( FDS, Vector( PleaseWaitFormat ) );
    Else do;
      Call YXB$SetBold;
      Call X$Write( FDS2, Vector( PleaseWaitFormat ) );
      Call YXB$ResetBold;
    End;  /*  else  */
 
   WriteStarUniqueK.V.Seed# = ReadSI.V.Seed#;
   BlockKey.Len = 3;
   BlockKey.Key = 0;
   Do While %True;
      Call M$Read( ReadSI )
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# = %E$Eof
          Then
            Goto Eof;
 
         If ErrCode.Err# = %E$BadVect1
          Then do;
            Err# = %E$NotEDITKeys;
            Dcb# = DcbNum( M$SI );
          End;  /*  if  */
 
         If ErrCode.Err# = %E$LD
          Then do;
            Err# = %E$RecordTooLarge;
            Dcb# = DcbNum( M$SI );
          End;  /*  if  */
 
         Goto boom;
       End;  /*  When Altret  */
 
      UniqueLine = SILine;
      Call SetArs;
      If SIARS# > 0
       Then
         WriteStarUniqueK.Buf_.Bound = SIARS# - 1;
       Else do;
         WriteStarUniqueK.Buf_.Bound = 0;
         UniqueLine = ' ';
       End;  /*  else  */
 
      If Incr = 0
       Then
         BlockKey = SIKey;
       Else
         BlockKey.Key = BlockKey.Key + Incr;
 
      Call M$Write( WriteStarUniqueK ) Altret ( boom );
   end;  /*  do while true  */
 
 End;  /*  if  */
      
eof:
Call M$Close( CloseSI )
 WhenAltReturn do;
   Call YEG$ErrCode( ErrCode );
   If Errcode.Err# ~= %E$DcbClosed
    Then
      Goto boom;
 
 End;
 
Call M$Close( CloseStarUnique ) Altret ( boom );
Call M$Open( SetWork ) Altret ( boom );
WorkFileName = StarUnique;  /* store the name of the work file for rekeys */
WriteStarUniqueK.V.Seed# = '0'B;
If Incr > 0
 Then do;  /* we rekeyed a consec file; have to multiply the old positions */
   CurrentPos.Key.Key = CurrentPos.Key.Key * Incr;
   Block.KeyStart.Key = Block.KeyStart.Key * Incr;
   Block.KeyEnd.Key = Block.KeyEnd.Key * Incr;
   Do I = 0 to 10;
     Spots.Key.Key(I) = Spots.Key.Key(I) * Incr;
   End;
   Buffers.CurrentPos( CurrentBuffer# ) = CurrentPos;
   Buffers.Block( CurrentBuffer# ) = Block;
   Buffers.Spots( CurrentBuffer# ) = SpotsChars;
 End;
 
Return;
 
boom:
   If (Err# = 0) and (PassErrCode = '0'B)
    Then
      Call YEG$ErrCode( PassErrCode );
 
   Call M$Close( CloseSI ) WhenAltReturn do; end;
   Call M$Close( CloseStarUniqueDelete ) WhenAltReturn do; end;
   AltReturn;
 
End MakeWorkFile;
 
/**/
 
SaveFile: Proc (PrimaryFid, SecondaryFid, Password#) AltRet;
/*
      Save a copy of the current file.  If a work file, return to the Name?
      prompt save over the original file.  If not a work file, return does
      nothing.  Otherwise, write a copy to the requested fid, with verification
      of file replacement for existing files.
*/
 
Dcl Label UBin;
Dcl Original Bit(1) Static Unal;
Dcl Bound UBin;
Dcl junk UBin;
Dcl ComLineWas Char(255) Unal;
Dcl SecondaryFid Char(8) Param;
Dcl Password# Char(8) Param;
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
/*
      Start
*/
 
Start:
Label = 0;
Original = %False;
Mode = %None;  /* for now */
Call YPN$PromptName( PrimaryFid ) Altret ( boom );
Call YYY$MakeFid( ComLine, PrimaryFid );
ComLineWas = ComLine;
Call SearchR( Bound, junk, B$SR_Non_Blank, ComLine )
 WhenReturn do;
   SInputUC03.Buf_.Bound = Bound;
   Call M$SInput( SInputUC03 ) Altret ( boom );
 End;
 WhenAltReturn do;
 End;
 
ComLine = ' ';
Call M$Read( ReadUC04 ) Altret ( UhOh );
If (ComLine = ' ') or (M$Com$ -> F$Dcb.Ars# = 0) or (ComLine = ComLineWas)
 Then do;
   If Not Buffers.Status.Changed(CurrentBuffer#)
    Then  /* no changes, there's nothing to do */
      AltReturn;
 
   If SecondaryFid = ' '
    Then do;  /* make sure latest changes are really written to disk */
      Call M$Trunc( FlushSI ) AltRet ( boom );
      AltReturn;
    End;
 
   Original = %True;
   Call YYY$MakeFid( Fid, PrimaryFid );
   Call M$Fid( MakeFid ) Altret ( boom );
   OpenOU.V.Exist# = %NewFile#;
   OpenOU.V.ASN# = ASNJunk;
 end;  /*  if default  */
 else do;  /*  get new file name  */
   Fid = ComLine;
   OpenOU.V.Exist# = %Error#;
   Call M$Fid( MakeFid )
    WhenReturn do;
      If (Substr( RESJunk,0,1 ) ~= BinAsc(0)) /*  valid file name?  */
         and (Substr( RESJunk,0,2 ) ~= 'DP')
       Then do;
         YYY_ErrCode.Err# = %E$BadFileName;
         Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$UC ),,,,2 );
         Goto Start;
       End;  /*  if  */
    End;  /*  When Return  */
    WhenAltReturn do;
      Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
      Goto Start;
    End;
 
 end;  /*  else  */
 
Mode = %Rekeying; /* not really, but it gives what we want for break control */
Call M$PFil( PosBOF ) Altret ( boom );
If (VLPSIPass.Pass# ~= ' ') or (Fid ~= ComLineWas)
 Then
   OpenOU.Pass_ = Vector( VLPSIPass );
 Else
   OpenOU.Pass_ = Vector( NIL );
 
OpenOU.V.Oper.Test# = %True;  /* make sure we can replace the file */
OpenOU.V.Fun# = %Create#;
Call M$Open( OpenOU )
 WhenAltReturn do;
   If Original
    Then do;
      OpenOU.V.Fun# = %Update#;
      Call M$Open( OpenOU )
       WhenReturn do;
         UpAttr = (%FFlg_DelR# | %FFlg_WNew#);
         If ((UpAttr & M$OU$ -> F$Dcb.FFlg) ~= UpAttr)
          Then do;
            YYY_ErrCode.Err# = %E$CantSaveThere;
            Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
            OpenOU.V.Oper.Test# = %False;
            OpenOU.V.Fun# = %Create#;
            Goto Start;
          End;  /*  if can't rewrite file  */
 
         OpenOU.V.Fun# = %Update#;
       End;
       WhenAltReturn do;
         Call YEG$ErrCode( ErrCode );
         If ErrCode.Err# ~= %E$NoFile
          Then do;
            Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
            OpenOU.V.Oper.Test# = %False;
            OpenOU.V.Fun# = %Create#;
            Goto Start;
          End;  /*  if  */
 
         OpenOU.V.Fun# = %Create#;
       End;   /*  When Altret  */
    End;  /*  if original  */
 End;  /*  When Altret  */
 
OpenOU.V.Oper.Test# = %False;  /* restore it */
Call M$Open( OpenOU )
 WhenReturn do;
   If OpenOU.V.Fun# = %Update#
    Then   /* this means we're clearing out old recs, and writing new */
      Call YCF$ClearFile altret ( boom );
 
 End;  /*  When Return  */
 WhenAltReturn do;
   Call YEG$ErrCode( ErrCode );
   If ErrCode.Err# ~= %E$CreatErr
    then do;
      Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
      Goto Start;
    End;
 
   Call OverWriteInquireAndSetUp( Label, PrimaryFid ) Altret ( boom );
   Do Case Label;
    Case( 1 );
      Goto Fin;
    Case( 2 );
      Goto Start;
    Case( 3 );
      Goto UhOh;
   End;  /*  case  */
 
 End;  /* Altret */
 
WriteOut:
Call YXB$SetBold;
Call X$Write( FDS2, Vector( PleaseWait3Format ) );
Call YXB$ResetBold;
Call YCF$CopyFile altret ( boom );
Call M$Close( CloseOU ) Altret ( boom );
 
fin:
OpenOU.V.Exist# = %NewFile#;  /*  restore to original setting  */
OpenOU.Pass_ = Vector( NIL );
WriteOU.V.Seed# = '0'B;
 
If Label = 1
 Then  /* to tell caller we didn't save it */
   AltReturn;
 
Return;
 
UhOh:
   Call YEM$ErrMsg( ErrCode, DcbNum( M$OU ), DcbNum( M$UC ),,,,2 );
UhOh2:
   VLPGrow.Length# = %Window_AbsVal# + 1;
   Call M$STrmCtl( FPTGrow ) WhenAltReturn do; end;
 
   Done = %False;        /*  not done yet....  */
   OpenOU.Pass_ = Vector( NIL );
   UnWind to NewCommand;
 
boom:
   Call AltretError;
   Return;
 
End SaveFile;
 
/**/
 
OpenEditFile: Proc ( Err#, Dcb#, PassErrCode ) Altret;
/*
      Procedure to open up the M$SI file
*/
Dcl Err# SBin;
Dcl DCB# Sbin;
%VLP_ERRCODE( FPTN = PassErrCode, STCLASS=PARAM );
 
/*  Start  */
 
      NumberOfRecs = 0;
      Err# = 0;
      Dcb# = 0;
      PassErrCode = '0'B;
      EditOldFile.V.ACS# = %Direct#;
      SequenFlag = %False;
 
      If M$SI$ -> F$Dcb.Asn# ~= %File#
       Then do;
         Err# = %E$NotADiskFile;
         Dcb# = DcbNum( M$SI );
         AltReturn;
       End;
 
      Call YYY$FillIn( Buffers.PrimaryFid( CurrentBuffer# ) );
 
      ComLine = ' ';
      NumberOfRecs = M$SI$ -> F$Dcb.NRecs#;
      Buffers.Status.NewFile(CurrentBuffer#) = %False;
 
      If WorkFlag
       then
        Call MakeWorkFile( Err#, Dcb#, PassErrCode ) Altret ( SourPMME );
       else
        Buffers.SecondaryFid( CurrentBuffer# ) = ' ';
 
      Call M$Open (EditOldFile)
        WhenReturn Do;
         If Not M$SI$ -> F$Dcb.FFlg.Read#
          Then do;
            Call M$Close( CloseSI ) WhenAltReturn do; end;
            Err# = %E$CantRead;
            Dcb# = DcbNum( M$SI );
            AltReturn;
          End;
 
         If (M$SI$ -> F$Dcb.Comp#) and (Not InputOnlyFlag) and
            ((M$SI$ -> F$Dcb.Org# = %Consec#) or (M$SI$ -> F$Dcb.Org# = %UR#))
            and (Not MakeItKeyed)
          Then do;
            Call M$Close( CloseSI ) Altret ( SourPMME );
            Err# = %E$CompressedFile;
            Dcb# = DcbNum( M$SI );
            AltReturn;
          End;
 
         NumberOfRecs = M$SI$ -> F$Dcb.NRecs#;
         If M$SI$ -> F$Dcb.Org# ~= %Keyed#
          Then do;
            Call M$Close( CloseSI ) Altret ( SourPMME );
            If (M$SI$ -> F$Dcb.Org# = %Consec#) or
               (M$SI$ -> F$Dcb.Org# = %UR# )
             then do;
               If M$SI$ -> F$Dcb.Org# = %UR#
                Then do;
                  InputOnlyFlag = %True;
                  EditOldFile.V.Fun# = %In#;
                  YYY_ErrCode.Err# = %E$CantEditUR;
                  Call YXB$SetBold;
                  Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,1,0 );
                  Call YXB$ResetBold;
                end;
 
               SequenFlag = %True;
               EditOldFile.V.ACS# = %Sequen#;
               Call M$OpenSI( EditOldFile ) Altret (SourPMME);
             end;  /*  if consec or UR  */
             else do;
               Err# = %E$NotAnEditFile;
               Dcb# = DcbNum( M$SI );
               AltReturn;
             end;  /*  else  */
                   
          end;  /*  if not keyed  */
 
          UpAttr = ( %FFlg_DelR# | %FFlg_WNew# | %FFlg_Upd# );
          If (UpAttr & ( M$SI$ -> F$Dcb.FFlg )) ~= UpAttr
           Then
              InputOnlyFlag = %True;
 
        End;
 
        WhenAltReturn Do;
          Call YEG$ErrCode (ErrCode);
          If (ErrCode.Err# = %E$NoFile) and (EditOldFile.V.Fun# ~= %In#)  /* input only */
            Then do;
              Call M$Open (EditNewFile) Altret ( SourPMME );
              Call M$Close(CloseSI) Altret ( SourPMME );  /* force NRecs to 0 */
              Call M$Open (EditOldFile) Altret ( SourPMME );
            End;
            Else
              Goto SourPMME;
 
          Buffers.Status.NewFile( CurrentBuffer# ) = %True;
        End;
 
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
      Call M$Fid ( MakeFid ) Altret ( SourPMME );
      NumberOfRecs = M$SI$ -> F$Dcb.NRecs#;
      If M$SI$->F$Dcb.Pass# ~= ' '
       Then
         Buffers.Password#( CurrentBuffer# ) = M$SI$ -> F$Dcb.Pass#;
       Else
         Buffers.Password#( CurrentBuffer# ) = ' ';
 
      Buffers.Status.Changed( CurrentBuffer# ) = %False;
      Return;
      
SourPMME:
      If (Err# = 0) and (PassErrCode = '0'B)
       Then
         Call YEG$ErrCode( PassErrCode );
 
      Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
      AltReturn;
      
End OpenEditFile;
 
/**/
 
CheckUC: Proc ( Res# ) AltRet;
/*
      Actually checks the ROSeg for the UC stream with number Num.  Altrets
      if it finds such a stream, and Returns if it does not.
*/
 
Dcl Res# Char(4);
Dcl I UBin;
 
   Do I = 0 to 15;
     If Res# = B$ROS$ -> B$ROSeg.LDevName( I )
      Then
        AltReturn;
 
   End;  /*  do I  */
 
   Return;
 
End CheckUC;
 
/**/
 
FindUC: Proc ( GoodRes, StartRes ) AltRet;
/*
      Adds one stream number to StartRes and checks the ROSeg to make sure
      it's an unused stream name.  If it's used, we add one and try again.
      The resulting unused stream name is returned in GoodRes.
*/
 
Dcl GoodRes Char(4);
Dcl StartRes Char(4);
Dcl Num UBin Unal;
Dcl Str# Char(2) Unal;
 
   Call CharBin( Num, Substr( StartRes,2,2 ) );
 
Loop:
   Num = Num + 1;
   If Num > 99
    Then
      AltReturn;
 
   Call BinChar( Str#, Num );
   Call Concat( GoodRes, 'UC', Str# );
   Call CheckUC( GoodRes ) altret (Loop);
   Return;
 
End FindUC;
 
/**/
 
Initialize: Proc AltRet;
/*
      Initialize memory management, and various parameters.
*/
Dcl I UBin;
 
   AlreadyStarted = %False;
 
   Do I = 0 to %NumOfPages - 1;
     Call M$GDS( GDS ) Altret ( NotEnoughMem );
   End;
 
   Buffers$ = B$DS4$;
   CurrentPages# = %NumOfPages;
   MaxBuffers# = %NumOfPages * 1024 / LengthW(Buffers(0));
 
/*
   initialize the first primary fid
*/
 
   Buffers.PrimaryFid.Fid.SetX( 0 ) = 0;
   Buffers.PrimaryFid.Fid.Name#.L( 0 ) = 0;
   Buffers.PrimaryFid.Fid.Name#.C( 0 ) = ' ';
   Buffers.PrimaryFid.Fid.Acct#( 0 ) = ' ';
   Buffers.PrimaryFid.PSN#( 0 ) = ' ';
   Buffers.Password#( 0 ) = ' ';
 
/*
   Shadow cache stuff
*/
 
   MaxCacheIndex = CacheSize - 1;
   AllBut4Bytes  = (4 * CacheSize) - 4;  /* bytes in cache less 4 */
   AllBut8Bytes  = AllBut4Bytes - 4;     /* bytes in cache less 8 */
   OpenUC02.V.NRecs# = CacheSize;
 
/*
   Select some UC stream numbers
*/
 
                                 /* routine adds one to P2 */
   Call FindUC( OpenUC02.V.Res#, 'UC01' ) altret ( abort );
   Call FindUC( OpenUC03.V.Res#, OpenUC02.V.Res# ) altret ( abort );
   Call FindUC( OpenUC05.V.Res#, OpenUC03.V.Res# ) altret ( abort );
 
   Return;
 
NotEnoughMem:
   Call AltretError;
   Return;
 
Abort:
   AltReturn;
 
End Initialize;
 
/**/
 
CheckWindow: Proc AltRet;
/*
      Check to see if the IBEX window is big enough to use.
*/
 
Dcl BorderSize UBin;
 
BorderSize = 0;
If VLPOriginalWindow.TopBrdr#
 Then
   BorderSize = BorderSize + VLPOriginalWindow.HBrdrSiz#;
 
If VLPOriginalWindow.BtmBrdr#
 Then
   BorderSize = BorderSize + VLPOriginalWindow.HBrdrSiz#;
 
If VLPOriginalWindow.Length# - BorderSize < 6
 Then
   AltReturn;
 
BorderSize = 0;
If VLPOriginalWindow.LftBrdr#
 Then
   BorderSize = BorderSize + VLPOriginalWindow.VBrdrSiz#;
 
If VLPOriginalWindow.RhtBrdr#
 Then
   BorderSize = BorderSize + VLPOriginalWindow.VBrdrSiz#;
 
If VLPOriginalWindow.Width# - BorderSize < 40
 Then
   AltReturn;
 
FidFieldWidth# = VLPOriginalWindow.Width# - 40 - BorderSize;
ReadUC04.Buf_.Bound = VLPOriginalWindow.Width# - 3 - BorderSize;
 
Return;
 
End CheckWindow;
 
/**/
 
ToggleSearch: Proc;
/*
   Toggle the search direction and report it
*/
 
Dcl 1 TextC,
    2 L# UBin(9) Unal,
    2 Text# Char(7) Unal;
 
   ForwardSearch = ~ForwardSearch;
   If ForwardSearch
    Then
      TextC.Text# = 'forward';
    Else
      TextC.Text# = 'reverse';
 
   TextC.L# = 7;
   YYY_ErrCode.Err# = %E$ToggleSearch;
   Call YXB$SetNorm;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Com ),
                    Vector( TextC ),,,,0 );
 
 
   Return;
 
End ToggleSearch;
 
/***********************************
*                                  *
*       Start Main Program         *
*                                  *
***********************************/
 
      Remember Abortion in WhereToGo;
      Remember Loop in NewCommand;
      Remember Recovery in CallXCommand;
 
/* Set up Exceptional Condition handling and exit control */
 
      Call M$XCon( ExitControl ) Altret ( SourPMME );
      Call M$Trap( TrapControl ) Altret ( SourPMME );
      Call M$Int( SetBreakControl ) Altret ( SourPMME );
 
      Call Initialize  /*  initialize memory  */
       WhenAltReturn do;
         Call Exeunt( %E$NoUCStreams );
       End;
 
      M$UC$    = DCBAddr( DCBNum( M$UC ) );
      M$ME$    = DCBAddr( DCBNum( M$ME ) );
      M$LM$    = DCBAddr( DCBNum( M$LM ) );
      M$SI$    = DCBAddr( DCBNum( M$SI ) );
      M$Edit$  = DCBAddr( DCBNum( M$Edit ) );
      M$Com$   = DCBAddr( DCBNum( M$Com ) );
      M$Block$ = DCBAddr( DCBNum( M$Block ) );
      M$Block2$= DCBAddr( DCBNum( M$Block2 ) );
      M$OU$    = DCBAddr( DCBNum( M$OU ) );
      M$Window$= DCBAddr( DCBNum( M$Window ) );
  
      If Not (M$SI$ -> F$DCB.AMR#)
        Then
           DirectToCommandWindow = %True;
        Else
           DirectToCommandWindow = %False;
 
      Call Xug$Init( Xug_GetCmd2, Xug_Init2 ) Altret ( SourPMME );
      Call Xug$Init( Xug_GetCmd3, Xug_Init2 ) Altret ( SourPMME );
      Call Xug$Init( Xug_Find, Xug_InitIn ) Altret ( SourPMME );
      Call Xug$Init( Xug_Replace, Xug_InitIn ) Altret ( SourPMME );
      Call Xug$Init( Xug_Imp, Xug_InitIn ) AltRet ( SourPMME );
 
      ExLength = B$Jit.CCArs - B$Jit.CCDisp;
      Examine$ = Addr( Substr( B$Jit.CCBuf, B$Jit.CCDisp ) );
      If ExLength > 0
       Then do;
         Call Xug$Init( Xug_Input, Xug_InitIn ) Altret ( SourPMME );
         Xug_Input.Text_ = Vector( Substr( Examine$ -> OptionBuf, 0, ExLength ) );
         Call Xug$GetCmd( Xug_Input )
          WhenAltReturn do;
            Call Xug$ErrPtr( Xug_Input );
            Return;  /*  exit  */
          End;
 
       End;  /* if options */
 
  /*  Now save the terminal settings for later  */
 
      Call M$GTrmCtl( OriginalTerminalSettings ) Altret ( SourPMME );
      Call M$GTrmCtl( OriginalWindow ) Altret ( SourPMME );
      RestoreOK = %True;
 
      Call CheckWindow
       WhenAltReturn do;
         Call Exeunt( %E$WindowTooSmall );
       End;
 
      Call M$GTrmAttr( FPTTermAttr ) Altret ( SourPMME );
 
      Call M$GLineAttr( GetLine ) Altret ( SourPMME );  /* to check the profile */
      Call YPC$CheckProfile;
 
      Call M$Open( OpenUC02 )  /* Open edit window */
       WhenReturn do;  /*  see if we have Peter's ReadOnly FcnTbl  */
         Call M$STrmAttr( FPTReadOnly ) Altret ( SourPMME );
         Call M$GTrmAttr( FPTCheckAttr ) Altret ( SourPMME );
         Call M$STrmAttr( FPTUpdate ) Altret ( SourPMME );
         If VLPCheckAttr.FcnTbl# = VLPReadOnly.FcnTbl#
          Then
            SE2Flag = %True;
          Else
            SE2Flag = %False;
 
       End;  /*  When Return  */
       WhenAltReturn do;
         Call Exeunt( %E$BadProfile );
       end;
 
      Call M$STrmCtl( FPTTrmCtl2 ) /* HScroll params */
       WhenAltReturn do;
         Call Exeunt( %E$BadProfile );
       end;
 
      Call M$Open( OpenUC03 )  /* Open status window */
       WhenAltReturn do;
         Call Exeunt( %E$BadProfile );
       end;
 
      Call M$STrmCtl( NoScrollUC03 ) /*  turn off pagehalt and set scrolling  */
       WhenAltReturn do;
         Call Exeunt( %E$BadProfile );
       end;
 
      Call M$Open( OpenUC05 )
       WhenAltReturn do;
         Call Exeunt( %E$BadProfile );
       end;
 
      VLPUC05 = VLPOriginalTerm;
      Call M$STrmCtl( TrmCtlUC05 ) Altret ( SourPMME );
      Call M$GTrmCtl( CommandWindowSettings ) Altret ( SourPMME );
      CommandWindowSize = VLPCommandWindowSettings.Length#;
      VLPGrow.Length# = %Window_AbsVal# + 1;
      Call M$STrmCtl( FPTGrow ) Altret ( SourPMME );  /*  shrink to nothing  */
 
      Call M$STrmCtl( FPTEdtCtl ) Altret ( SourPMME );
 
      VLPTrmCtl.WordWrapClm# = 0;   /*  Turn wordwrap off  */
      Call M$STrmCtl( FPTTrmCtl ) Altret ( SourPMME );
 
      Call M$Eom( EomUC02 ) Altret ( SourPMME );
      Call M$Eom( EomUC03Normal ) Altret ( SourPMME );
 
      Call X$Write( FDS3, Vector( VersionFormat ),
                          Vector( Version ) );
 
      PutAwayDone = %False;
      OutLine = ' ';
      ComLine1 = VersionLine;
      Fid = ' ';
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( SourPMME );
 
      Call YII$IMP;  /*  context file handling  */
      Call M$Device( FPTDeviceMarker ) Altret ( SourPMME );/*define EOF marker*/
      InputOnlyFlag = %False;
      WorkFlag = AlwaysUseWorkFlag;
      EscapeDBuf = Substr( B$Jit.CCBuf, 0, B$Jit.CCArs );
      EscapeDLen = B$Jit.CCArs;
      Crpt = '0'B;
 
      If ExLength > 0
       Then do;  /*  there were options  */
         Xug_Input.Text_ = Vector(Substr( Examine$ -> OptionBuf, 0, ExLength ));
         Call Xug$GetCmd( Xug_Input )
          WhenAltReturn do;
            Call Xug$ErrPtr( Xug_Input );
            Return;  /*  exit  */
          End;
 
         CMD$ = Xug_Input.OUT$;
         MakeItKeyed = %False;
         If Out.NSublks = 1
          Then
            Call ParseCommandLine( InputOnlyFlag, WorkFlag, Crpt, CMD$ );
          Else
            Do I = 0 to Out.NSublks - 1;
              Call ParseCommandLine( InputOnlyFlag, WorkFlag, Crpt,
                                     Out.Sublk$(I) );
            End;  /*  do I  */
 
       End;  /*  if option specified  */
 
      ReadSI.V.Seed# = Crpt;
      ReadSIByKey.V.Seed# = Crpt;
      WriteSI.V.Seed# = Crpt;
      Call M$Open( OpenSIForceDcbTest ) WhenAltReturn do; end;
 
      If Not DirectToCommandWindow
        Then
          Call OpenEditFile( Err#, Dcb#, PassErrCode )  /*  open up the edit file  */
            WhenReturn do;
             Call SetFcnTbl;
             Do I = 0 to 10;
               Spots.Key.Len(I) = 0;  /*  unmark the spots  */
               Spots.Key.Key(I) = 0;
               Spots.Column(I) = 0;
             End;  /*  do I  */
             If MakeItKeyed
              Then
                Call YKF$MakeItKeyed;
 
            End;  /*  When Return  */
            WhenAltReturn do;
             UCKey = 0;
             SIKey.Key = 0;
             If Err# = 0
              then
                RcvrErrCode = PassErrCode;
              else do;
                YYY_ErrCode.Err# = Err#;
                RcvrErrCode = YYY_ErrCode;
              end;  /*  else  */
 
             DirectToCommandWindow = %True;
             StartingWithError = %True;
             ComLine = ' ';
 
            end;  /*  WhenAltret  */
        Else
          ComLine = ' ';
 
      Call Xug$Init( Xug_GetCmd, Xug_Init ) Altret ( SourPMME );
      Xug_GetCmd.Prompt_ = Vector( Prompt );
      Xug_GetCmd2.Prompt_ = Vector( PromptBlank );
      Xug_GetCmd3.Prompt_ = Vector( PromptBlank );
 
      LastCacheEntry = -1;  /*  nothing in the shadow cache yet  */
 
           /*  send the first line of the file to the FEP  */
 
      AlreadyStarted = %True;
      Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
 
      If Not DirectToCommandWindow
       Then do;
        Buffers.Status.WorkMissing( CurrentBuffer# ) = %False;
        If Crpt ~= '0'B
         Then
           Buffers.Status.Encrypted( CurrentBuffer# ) = %True;
         Else
           Buffers.Status.Encrypted( CurrentBuffer# ) = %False;
 
        Seeds( CurrentBuffer# ) = Crpt;
        Buffers# = 1;
        If WorkFlag
         Then
           Buffers.SecondaryFid( CurrentBuffer# ) = M$SI$->F$DCB.Name#.C;
         Else do;
           Call YYY$FillIn( Buffers.PrimaryFid( CurrentBuffer# ) );
           Buffers.SecondaryFid( CurrentBuffer# ) = ' ';
         End;
 
        Call GetFirst( DcbNum( M$UC ) )
         WhenAltReturn do;
           Return;
         End;
 
        If SequenFlag and Not InputOnlyFlag
         Then
           Call AnnounceSequen;
 
       End;  /*  if not direct to commandwindow  */
       Else do;
        Buffers# = 0;
        CurrentBuffer# = -1;
        If StartingWithError
         Then
           Call XCommandWindow( RcvrErrCode );
         Else
           Call XCommandWindow;
 
        If CurrentBuffer# > -1
         Then
           Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         Else
           Fid = ' ';
 
       End;
 
      Call MakeAnnouncements Altret ( SourPMME );
 
      Do While %False;
Recovery:    /*  from bad crpt problems, etc...  */
        Call YWS$DownString( CmdOpenLine, CmdOpen#, %E$BadCmdOpenStr );
        Call XCommandWindow( RcvrErrCode );
 
Loop:        /*  unwind destination for BREAK aborts  */
        NoWEOF = %False;  /* just in case it's still set from somewhere */
        Call M$CloseSI( CloseSI )
         WhenAltReturn do;
         End;
 
        If Buffers# > 0
         Then Do;
           If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
            Then /* just in case it got messed up during workfile toggling */
              WorkFlag = %True;
            Else
              WorkFlag = %False;
 
           If InputOnlyFlag  /*  make sure file open in correct mode  */
            Then
              Call M$OpenSI( OpenSIIn ) Altret ( SourPMME );
            Else do;
              EditOldFile.V.Fun# = %Update#;  /*  make sure  */
              Call M$OpenSI( EditOldFile ) Altret ( SourPMME );
            End;
 
         End;  /* if buffers# > 0 */
 
        Call MakeAnnouncements Altret ( SourPMME );
      End;  /*  do while false  */
 
      Call YWS$DownString( CmdCloseLine, CmdClose#, %E$BadCmdCloseStr );
Loop2:
      Do While Not Done;
        Mode = %None;
        NumberOfRecs = M$SI$ -> F$Dcb.NRecs#;
        InsertMode = %True;
        UCLine = ' ';
        Call M$Read( ReadUC02 ) Altret ( FepAltReturn );
        ReadUC02.V.KeyS# = %No#;
        If Not M$Edit$ -> F$Dcb.DVByte.Trans#
         Then  /* don't bother updating the file - the record wasn't changed */
           Call WriteTheLine;
 
        InsertMode = %False;
 
        If InputOnlyFlag and (UCKey > LastKey.Key)
         Then do;
           Call GotoEnd;  /* currentpos set in here */
           UCKey = LastKey.Key;
         End;
         Else do;
           CurrentPos.Column = M$Edit$ -> F$Dcb.ActPos;
           CurrentPos.Key.Len = 3;
           If LastKey.Key = 0
            Then
              CurrentPos.Key.Key = 0;
            Else
              CurrentPos.Key.Key = UCKey;
         End;
 
        ComChar = ' ';
        Call Index1 (EOMCharX, M$Edit$ -> F$DCB.EOMChar#, EOMChars)
         WhenReturn Do;
           Do Case EOMCharX;
             Case (%C, %Q);   /* ^C, ^Q (must have been IMPed) */
               Call DoACCommand;
 
             Case (%K);       /* ^K */
               Call DoAKCommand;
 
             Case (%O);       /* ^O */
               Call DoAnOCommand;
 
             Case (%L);       /* ^L */
               Call RepeatLastFindReplace;
 
             Case (%Z);       /* ^Z */
               Call ToggleSearch;
 
             End;  /* Case EOMCharX */
         End;  /* WhenReturn */
         WhenAltReturn Do;  /* uninteresting activation character */
         End;  /* WhenAltReturn */
 
      End; /*  Do While Not Done  */
 
      Call PutAwayFiles;
 
/* The XCon procedure will take care of the rest of the cleanup  */
 
      Return;
 
SourPMME:
      Call AltretError;
      Return;
 
FepAltReturn:
      ReadUC02.V.KeyS# = %No#;
      Call YEG$ErrCode( ErrCode );
      Do Select ErrCode.Err#;
       Select ( %E$LD );
         YYY_ErrCode.Err# = %E$RecordTooLarge;
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,3,0 );
         Call YXB$ResetBold;
         SIKey.Len = 3;
         SIKey.Key = UCKey;
         Call M$ReadSI( ReadSIByKey )
          WhenReturn do;
            Call SetArs;
            If SIARS# > 0
             Then
               WriteUC02.Buf_.Bound = SIARS# - 1;
             else do;
               WriteUC02.Buf_.Bound = 0;
               SILine = ' ';
             end; /*  else  */
 
            Call M$WriteUC02 Altret ( SourPMME );
 
          end;  /* When Return */
          WhenAltReturn do;
            WriteUC02.Buf_.Bound = 0;
            SILine = ' ';
            WriteUC02.V.DVByte.VFC# = %False;
            WriteUC02.V.DVByte.Trans# = %False;
            Call M$WriteUC02 Altret ( SourPMME );
          end;  /* When AltReturn */
 
       Select ( %E$Records_Needed );
         If (UCKey = Cache( LastCacheEntry - 1)) and (M$Edit$ -> F$Dcb.Ars# > 0)
          Then  /* prevent internal shadow-cache error and get in sync */
            LastCacheEntry = LastCacheEntry - 1;
 
         Call YSG$GetRecords( M$Edit$ -> F$Dcb.Ars# );
 
       Select ( %E$Record_Deleted );
         If Not InputOnlyFlag and Not SequenFlag
          Then
            Call YSD$DeleteRecord;
          Else
            If InputOnlyFlag
             Then do;
               Call WriteTheLine;
               PositionKey = UCKey;
               SInputUC02.V.ReReadPos# = 1;
               Call M$SInput( SInputUC02 ) Altret ( SourPMME );
             End;  /*  if InputOnlyFlag  */
             Else do;
               InputOnlyFlag = %True;
               Call WriteTheLine;
               InputOnlyFlag = %False;
               PositionKey = UCKey;
               SInputUC02.V.ReReadPos# = 1;
               Call M$SInput( SInputUC02 ) Altret ( SourPMME );
             End;  /*  else  */
 
       Select ( %E$Insert_No_Room );
         Call WriteTheLine;
         If Not InputOnlyFlag and Not SequenFlag
          then do;
            Call M$GTrmCtl( EditWindowSettings ) Altret ( SourPMME );
            If VLPEditWindowSettings.WordWrapClm# > 0
             then
               WordWrapping = %True;
             else
               WordWrapping = %False;
 
            WordWrapClm# = VLPEditWindowSettings.WordWrapClm#;
            AutoTabClm# = VLPEditWindowSettings.AutoTabClm#;
            Call YSS$RetrySplit;
          end;
 
       Select ( %E$CantGetCtx );
         Call M$EraseEdit AltRet ( SourPMME );
         Call MakeAnnouncements;  /*  make sure the file name is up  */
         If Buffers.SecondaryFid( CurrentBuffer# ) ~= ' '
          Then
            Call M$CloseSI( CloseSIDelete ) WhenAltReturn do; end;
          Else
            Call M$CloseSI( CloseSI ) WhenAltReturn do; end;
 
         Call SqueezeBuffers;
         CurrentBuffer# = CurrentBuffer# - 1;
         If CurrentBuffer# < 0 and Buffers# > 0
          Then
            CurrentBuffer# = Buffers# + CurrentBuffer#;
 
         YYY_ErrCode.Err# = %E$NoContextMem;
         RcvrErrCode = YYY_ErrCode;
         UnWind to CallXCommand;
 
       Select ( Else );
         OutLine = 'I/O error';
         ComLine1 = VersionLine;
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
         Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( SourPMME );
 
         If InputOnlyFlag
          Then  /* just in case */
            Call WriteTheLine;
 
       End; /*  Select  */
 
      Goto Loop2;  /* Resume normal execution */
 
Abortion:
      Return;
 
End PULSE;
 
/**/
