/*M* CALENDAR - A TOOL FOR BUILDING AND DISPLAYING
                     A PERSONAL CALENDAR.               */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/**/
CALENDAR: PROC MAIN;
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE B_ERRORS_C;
%INCLUDE CALENDAR_C2;
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$BREAK ENTRY ASYNC;
DCL XUR$CLRENABLE ENTRY;
DCL SCH$BREAK ENTRY;
DCL SCH$ERRMSG ENTRY(1) ;
DCL XUR$INIT ENTRY(3) ALTRET;
DCL CMD$SCHEDULE ENTRY;
DCL CMD$CANCEL ENTRY(1);
DCL CMD$CHANGE ENTRY(1);
DCL CMD$DISPLAY ENTRY(1);
DCL CMD$HELP ENTRY(1);
DCL XUR$SETERRMSG ENTRY(1) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL SCH$GROUP ENTRY(2);
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL M$INPUT DCB;
DCL M$UPDATE DCB;
DCL M$LM DCB;
DCL M$LO DCB;
/**/
/* FPT DEFINITIONS */
%FPT_OPEN (FPTN=CAL_OPEN,
           DCB=M$CALENDAR,
           FUN=CREATE,
           REASSIGN=YES);
%FPT_OPEN (FPTN=CAL_SETDCB,
           DCB=M$CALENDAR,
           SETDCB=YES,
           FUN=CREATE,
           NAME=CAL,
           ASN=FILE,
           ACS=DIRECT,
           EXIST=OLDFILE,
           SHARE=ALL,
           ORG=KEYED,
           CTG=YES,
           EXPIRE=NEVER);
%FPT_OPEN (FPTN=IN_OPEN,
           DCB=M$INPUT,
           FUN=IN,
           SCRUB=YES);
%FPT_OPEN (FPTN=UP_OPEN,
           DCB=M$UPDATE,
           FUN=UPDATE,
           SCRUB=YES);
%FPT_CLOSE (FPTN=CAL_CLOSE,
            DCB=M$CALENDAR,
            DISP=SAVE);
%FPT_CLOSE (FPTN=IN_CLOSE,
            DCB=M$INPUT);
%FPT_CLOSE (FPTN=LO_CLOSE,
            DCB=M$LO,
            DISP=SAVE);
 
%FPT_CLOSE (FPTN=UP_CLOSE,
            DCB=M$UPDATE);
%FPT_PFIL (FPTN=CAL_PFIL,
           DCB=M$CALENDAR,
           BOF=YES);
%FPT_DELREC (FPTN=CAL_DEL,DCB=M$CALENDAR);
%FPT_TIME (FPTN=GET_UTS,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TSTP);
%FPT_READ (FPTN=READ_REC,
           DCB=M$CALENDAR,
           BUF=RECORD_BUF,
           KEY=KEY_VAL,
           KEYR=YES);
%FPT_UNFID (DCB=M$LM,LEN=UNFLEN,TEXTFID=TEXT.TXT);
%VLP_NAME (FPTN=CAL,NAME=':CALENDAR');
%FPT_INT (UENTRY=XUR$BREAK,STCLASS=CONSTANT);
%FPT_LINK (FPTN=CAL_LINK,ACCT=SYSACCT,NAME=VLP_PCLNAME,CMD=PCL_CMD);
%VLP_ACCT (FPTN=SYSACCT,ACCT=':SYS');
%VLP_NAME (FPTN=VLP_PCLNAME,NAME='PCL');
/**/
/* VARIABLE DECLARES */
DCL ROOT_NODE SBIN SYMREF;
DCL PTR$ PTR;
%VLP_ERRCODE (FPTN=PERR_CODE,STCLASS="REDEF PTR$");
DCL PRMT CHAR(0) CONSTANT INIT(':');
DCL ENDFLAG BIT(1);
DCL TSTP UBIN WORD STATIC;
DCL 1 KEY_VAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 TEXT STATIC ALIGNED,
      2 COUNT UBIN BYTE UNAL,
      2 TXT CHAR(60);
DCL UNFLEN UBIN WORD STATIC;
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 PCL_CMD STATIC ALIGNED,
      2 L UBIN BYTE UNAL INIT(79),
      2 C CHAR(79) UNAL;
DCL CAL_ACCT CHAR(8);
DCL CAL_FLAG BIT(1);
DCL P_PCB$ PTR STATIC SYMDEF INIT(ADDR(P_PCB));
DCL SC_ERR_RETURN BIT(72) STATIC SYMDEF DALIGNED;
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(PTR$)");
%B$JIT0;
%U$JIT1;
   2 * BIT(1) UNAL;          /* REST OF JIT NOT NEEDED */
%B$TCB;
%B$ALT;
%F$DCB;
%P_PCB( STCLASS="STATIC SYMDEF" );
%XUR_INIT(PCB=P_PCB, ABORT=SCH$BREAK);
/**/
%EJECT;
CALL M$UNFID (FPT_UNFID);
CALL XUR$INIT(XUR_INIT,P_PCB$);
TEXT.COUNT = UNFLEN;
CALL XUR$SETERRMSG (TEXT);
REMEMBER ERR_RETURN IN SC_ERR_RETURN;
CALL M$INT (FPT_INT);
IF NOT B$JIT.PRFLAGS.SI
THEN DO;
    CAL_OPEN.ACCT_ = VECTOR( B$JIT.ACCN );
END;
CALL M$OPEN (CAL_SETDCB) ALTRET(OPEN_ERR);
CALL M$OPEN (CAL_OPEN)
WHENALTRETURN DO;
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$NOACCESS
      THEN GOTO OPEN_ERR;
    CAL_OPEN.V.FUN# = %IN#;
    CALL M$OPEN (CAL_OPEN) ALTRET(OPEN_ERR);
    CALL SCH$ERRMSG (%E$TH_INPUT_ONLY);
/*E* ERROR: SCH-E$TH_INPUT_ONLY-0
     MESSAGE: Calendar is open for input only.
*/
END;
CALL M$OPEN(IN_OPEN) ALTRET(OPEN_ERR);
CALL M$OPEN(UP_OPEN) ALTRET(OPEN_ERR);
CALL SCH$GROUP(%GROUP_OPEN);
ENDFLAG = %FALSE;
                   /* CALL COMMON DRIVER                        */
DO WHILE (NOT ENDFLAG);
GETCMD: ;
    CALL XUR$GETCMD(ROOT_NODE,PTR$,VECTOR(PRMT)) ALTRET(PAR_ERR);
    IF CAL_OPEN.V.FUN# = %IN#
    THEN DO;
         DO CASE (OUT$BLK.CODE);
              CASE (%DISPLAY_CMD,%HELP_CMD,%GROUP_CMD,%MEMBERS_CMD,%QUIT_CMD);
                   ; /* OKAY - COMMAND ALLOWED */
              CASE (ELSE);
                   CALL SCH$ERRMSG (%E$TH_INPUT_ONLY);
                   GOTO GETCMD;
         END;
    END;
 
    DO CASE (OUT$BLK.CODE);
         CASE (%SCHEDULE_CMD);
              CALL CMD$SCHEDULE;
         CASE (%CANCEL_CMD);
              CALL CMD$CANCEL (PTR$);
         CASE (%CHANGE_CMD);
              CALL CMD$CHANGE (PTR$);
         CASE (%DISPLAY_CMD);
              CALL CMD$DISPLAY (OUT$BLK.SUBLK$(0));
        CASE (%CREATE_CMD);
            CALL SCH$GROUP(%GROUP_CREATE,PTR$);
        CASE (%ATTACH_CMD);
            CALL SCH$GROUP(%GROUP_ATTACH,PTR$);
        CASE (%DETACH_CMD);
            CALL SCH$GROUP(%GROUP_DETACH,PTR$);
        CASE (%GROUP_CMD);
            CALL SCH$GROUP(%GROUP_DISPLAY,PTR$);
        CASE (%MEMBERS_CMD);
            CALL SCH$GROUP(%GROUP_MEMBERS,PTR$);
         CASE (%QUIT_CMD);
              ENDFLAG = %TRUE;
                   /* DO NOTHING                                */
    END;           /* END OF DO CASE                            */
    DO NEVER;
PAR_ERR:
         IF PERR_CODE.MON THEN GOTO XIT;
         CALL XUR$ERRPTR(,DCBNUM(M$UPDATE));
         CALL SCH$ERRMSG (%E$TH_PAR_ERR);
         /*E* ERROR: SCH-E$TH_PAR_ERR-0
              MESSAGE: Incorrect command syntax.
              MESSAGE1: Type 'HELP command SYNTAX' for more information.
                        Type 'HELP COMMANDS' to list all possible commands.
         */
    END;
    DO NEVER;
   ERR_RETURN:
         CALL XUR$CLRENABLE;
    END;           /* END OF DO NEVER                           */
END;               /* END OF DO WHILE                           */
XIT:
                   /* DELETE RECORDS WITH DATE PAST THE CURRENT */
                   /* DATE.                                     */
CALL M$TIME (GET_UTS);
    CALL XUD$UTS_ADJUST (TSTP,TSTP,-%UTS_CSEC_DAY#);
    CALL M$PFIL (CAL_PFIL);
     CAL_FLAG = %FALSE;
READ_AGAIN:
    CALL M$READ (READ_REC) ALTRET (THE_END);
    IF KEY_VAL.KEY = 0
        THEN GOTO READ_AGAIN;
    IF TSTP >= KEY_VAL.KEY
         THEN
         DO;
              CALL M$DELREC (CAL_DEL);
               CAL_FLAG = %TRUE;
              GOTO READ_AGAIN;
         END;
THE_END:
    CALL SCH$GROUP(%GROUP_CLOSE);
    CALL M$CLOSE (CAL_CLOSE);
    CALL M$CLOSE (IN_CLOSE);
    CALL M$CLOSE (UP_CLOSE);
    CALL M$CLOSE (LO_CLOSE);
 
     IF CAL_FLAG THEN DO;
        CAL_ACCT=DCBADDR(DCBNUM(M$CALENDAR))->F$DCB.ACCT#;
        CALL CONCAT(PCL_CMD.C,'C :CALENDAR.',CAL_ACCT,' OVER :CALENDAR.',CAL_ACCT);
        CALL M$LINK (CAL_LINK);
        END;
DO NEVER;
    OPEN_ERR:
         CALL SCH$ERRMSG;
         CALL M$ERR;
END;               /* END OF DO NEVER                           */
END CALENDAR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*M* SCH$BREAK - TO CONTROL THE BREAK KEY                       */
SCH$BREAK: PROC;
/**/
DCL SC_ERR_RETURN BIT(72) SYMREF DALIGNED;
/**/
    UNWIND TO SC_ERR_RETURN;
/**/
/**/
END SCH$BREAK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*M* CMD$SCHEDULE - TO SCHEDULE UPCOMING EVENTS/APPOINTMENTS. */
/**/
CMD$SCHEDULE:  PROC;
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE B_ERRORS_C;
%INCLUDE CALENDAR_C2;
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL SCH$ERRMSG ENTRY(1);
DCL DATE_TYPE ENTRY(4) ALTRET;
DCL FILL_FLD ENTRY(2) ALTRET;
DCL WRT_RECORD ENTRY(2);
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL M$INPUT DCB;
DCL M$UPDATE DCB;
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=GET_DATE,
             SOURCE=UTS,
             DEST=LOCAL,
             DATE=RECORD_BUF.INFO.DATE,
             TIME=RECORD_BUF.INFO.TIME,
             TSTAMP=TUTS);
%FPT_READ (FPTN=READ_KEY,
             DCB=M$CALENDAR,
             BUF=RD_REC_BUF,
             KEY=KEY_VAL_ONE,
             KEYR=YES);
%FPT_READ (FPTN=READ_INPUT,
             DCB=M$INPUT,
             BUF=INPUT_BUF);
%FPT_WRITE (FPTN=WRITE_NOTES,
              DCB=M$UPDATE,
              BUF=MSG_BUF);
%FPT_WRITE (FPTN=WRITE_REC_DEV,
              DCB=M$UPDATE,
              BUF=RD_REC_BUF);
%FPT_PRECORD (FPTN=POS_REC,
              DCB=M$CALENDAR,
                KEY=KEY_VAL,
                KEYR=NO,
                KEYS=YES);
%FPT_TIME (FPTN=GET_UTS,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TS_UTS);
/**/
/* VARIABLE DECLARES */
DCL 1 KEY_VAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
        3 DATE_C REDEF DATE CHAR(8),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
        3 TIME_C REDEF TIME CHAR(5),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 KEY_VAL_ONE STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RD_REC_BUF STATIC,
      2 DATE,
        3 MM            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 DD            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 YY            CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 TIME,
        3 HR            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT(':'),
        3 MIN           CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 PLACE           CHAR(80) INIT(' '),
      2 TOPIC           CHAR(80) INIT(' '),
      2 RP              CHAR(2) INIT('0'),
      2 CNT          UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL TS_UTS UBIN WORD STATIC INIT(0);
DCL INPUT_BUF CHAR(80) STATIC INIT(' ');
DCL MSG_BUF CHAR(120) STATIC INIT(' ');
DCL INPUT_DATE_TIME SBIN SYMREF;
DCL INPUT_RP SBIN SYMREF;
DCL INPUT_NOTES SBIN SYMREF;
DCL INPUT_PLACE SBIN SYMREF;
DCL TOP$ PTR;
DCL PRMT1 CHAR(0) CONSTANT INIT('S (DATE and TIME):');
DCL PRMT2 CHAR(0) CONSTANT INIT('S (PLACE):');
DCL PRMT3 CHAR(0) CONSTANT INIT('S (EVENT):');
DCL PRMT4 CHAR(0) CONSTANT INIT('S (Reminder Period):');
DCL PRMT5 CHAR(0) CONSTANT INIT('S (NOTES):');
DCL START UBIN WORD STATIC INIT(0);
DCL STOP UBIN WORD STATIC INIT(0);
DCL TUTS UBIN STATIC;
DCL K UBIN BYTE STATIC INIT(0);
DCL L UBIN BYTE STATIC INIT(0);
DCL TIMING UBIN;
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(TOP$)");
%B$TCB;
%B$ALT;
/**/
%EJECT;
              /* PARSE FIRST INPUT:  TIME AND DATE              */
WHEN:
    CALL XUR$GETCMD(INPUT_DATE_TIME,TOP$,VECTOR(PRMT1)) ALTRET(PAR_ERR1);
IF OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
    DO CASE (OUT$BLK.CODE);
         CASE (%DATE_TIME);
              CALL FILL_FLD(OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0),
                            RECORD_BUF.INFO.TIME.HR) ALTRET(BAD_TIME);
              CALL FILL_FLD(OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(1),
                            RECORD_BUF.INFO.TIME.MIN) ALTRET(BAD_TIME);
              CALL DATE_TYPE(OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                       RECORD_BUF.INFO.TIME,START,STOP) ALTRET (BAD_DATE);
              IF OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
                 OUT$BLK.NSUBLKS > 3
                 THEN TIMING = %UTS_CSEC_DAY#;
                 ELSE TIMING = %UTS_CSEC_WEEK#;
         CASE (%DATE_X);
              RECORD_BUF.INFO.TIME.HR = '00';
              RECORD_BUF.INFO.TIME.MIN = '00';
              CALL DATE_TYPE(OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                       RECORD_BUF.INFO.TIME,START,STOP) ALTRET (BAD_DATE);
              IF OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
                 OUT$BLK.NSUBLKS > 3
                 THEN TIMING = %UTS_CSEC_DAY#;
                 ELSE TIMING = %UTS_CSEC_WEEK#;
         CASE (%TIME_DATE);
              CALL FILL_FLD(OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                            RECORD_BUF.INFO.TIME.HR) ALTRET(BAD_TIME);
              CALL FILL_FLD(OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(1),
                            RECORD_BUF.INFO.TIME.MIN) ALTRET(BAD_TIME);
              CALL DATE_TYPE(OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0),
                       RECORD_BUF.INFO.TIME,START,STOP) ALTRET (BAD_DATE);
              IF OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(0)->
                 OUT$BLK.NSUBLKS > 3
                 THEN TIMING = %UTS_CSEC_DAY#;
                 ELSE TIMING = %UTS_CSEC_WEEK#;
    END;      /* END OF DO CASE                                 */
    CALL M$TIME(GET_UTS);
    IF START < TS_UTS
    THEN DO;
         CALL SCH$ERRMSG (%E$TH_OBSOLETE_EVENT);
/*E* ERROR: SCH-E$TH_OBSOLETE_EVENT
     MESSAGE: You cannot schedule an event in the past.
*/
         GOTO WHEN;
    END;
/**/
              /* PARSE INPUT:  PLACE                            */
WHERE:
    CALL XUR$GETCMD (INPUT_PLACE,TOP$,VECTOR(PRMT2)) ALTRET(PAR_ERR2);
IF OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
    RECORD_BUF.INFO.PLACE = OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
/**/
              /* PARSE INPUT:  WHY(TOPIC).                      */
WHY:
    CALL XUR$GETCMD (INPUT_PLACE,TOP$,VECTOR(PRMT3)) ALTRET(PAR_ERR3);
IF OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
    RECORD_BUF.INFO.TOPIC = OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
/**/
              /* PARSE INPUT:  REMINDING PERIOD.                */
REM_P:
    CALL XUR$GETCMD (INPUT_RP,TOP$,VECTOR(PRMT4)) ALTRET(PAR_ERR4);
IF OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
    IF OUT$BLK.NSUBLKS > 0
       THEN
         CALL FILL_FLD (OUT$BLK.SUBLK$(0),RECORD_BUF.INFO.RP) ALTRET(PAR_ERR4);
       ELSE
         RECORD_BUF.INFO.RP = '00';
/**/
                   /* READ INPUTS FROM THE TERMINAL AS A NOTES. */
DO K = 0 TO 20;
    CALL XUR$GETCMD(INPUT_NOTES,TOP$,VECTOR(PRMT5)) ALTRET(PAR_ERR5);
IF OUT$BLK.CODE = %QUIT_CMD THEN EXIT;
    IF OUT$SYM.COUNT = 0
         THEN EXIT;
    RECORD_BUF.NOTES(K) = OUT$SYM.TEXT;
END;
RECORD_BUF.INFO.CNT = K;
/**/
              /* WRITE THESE INPUTS OUT TO A FILE (:CALENDAR).  */
              /* WRITE OUT A WARNING IF THERE IS ANOTHER EVENT/ */
              /* APPOINTMENT AT THE SAME TIME.                  */
TUTS = START;
DO WHILE (TUTS <= STOP);
    KEY_VAL.KEY = TUTS;
    CALL M$TIME(GET_DATE);
    CALL WRT_RECORD (KEY_VAL,RECORD_BUF);
    CALL CONCAT(MSG_BUF,'Appointment is scheduled for ',
         RECORD_BUF.INFO.DATE_C,'  ',RECORD_BUF.INFO.TIME_C);
    CALL M$WRITE(WRITE_NOTES);
    CALL XUD$UTS_ADJUST (TUTS, TUTS, TIMING);
END;  /* do while */
PAR_ERR2: ;
PAR_ERR3: ;
PAR_ERR5: ;
RETURN;
              /* ERROR MESSAGES                                 */
BAD_TIME:
    CALL SCH$ERRMSG(%E$TH_TIME);
/*E* ERROR: SCH-E$TH_TIME
     MESSAGE: An illegal TIME was entered.
*/
    GOTO WHEN;
BAD_DATE:
    CALL SCH$ERRMSG(%E$TH_DATE);
/*E* ERROR: SCH-E$TH_DATE
     MESSAGE: An illegal DATE or TIME was entered.
*/
    GOTO WHEN;
PAR_ERR1:
    CALL XUR$ERRPTR(,DCBNUM(M$UPDATE));
    CALL SCH$ERRMSG(%E$TH_PAR_ERR1);
/*E* ERROR: SCH-E$TH_PAR_ERR1
     MESSAGE: Invalid syntax for DATE or TIME.
*/
    GOTO WHEN;
PAR_ERR4:
    CALL SCH$ERRMSG(%E$TH_PAR_ERR4);
/*E* ERROR: SCH-E$TH_PAR_ERR4
     MESSAGE: The Reminder Period must be a 1 or 2 digit number.
*/
    GOTO REM_P;
END CMD$SCHEDULE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*   THIS PROC WILL WRITE A RECORD OUT TO A FILE (:CALENDAR)    */
/**/
WRT_RECORD:  PROC(KEY_VAL,RBUF);
/**/
/* PARAMS */
DCL 1 KEY_VAL,
      2 *          UBIN BYTE ,
      2 KEY        UBIN WORD ,
      2 CNT        UBIN BYTE ;
DCL 1 RBUF,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2),
           4 *             CHAR(1),
           4 DD            CHAR(2),
           4 *             CHAR(1),
           4 YY           CHAR(2),
         3 *              CHAR(2),
         3 TIME,
           4 HR            CHAR(2),
           4 *             CHAR(1),
           4 MIN           CHAR(2),
         3 *               CHAR(2),
         3 PLACE           CHAR(80),
         3 TOPIC           CHAR(80),
         3 RP              CHAR(2),
         3 CNT             UBIN BYTE,
      2 NOTES(0:20)     CHAR(80);
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
/**/
/* ENTRY DEFINITIONS */
DCL SCH$GROUP ENTRY(2);
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL M$UPDATE DCB;
/**/
/* FPT DEFINITIONS */
%FPT_PRECORD (FPTN=POS_REC,
            DCB = M$CALENDAR,
                KEY=KVAL,
                KEYR=NO,
                KEYS=YES);
%FPT_READ (FPTN=READ_KEY,
             DCB=M$CALENDAR,
             BUF=RD_REC_BUF,
             KEY=KEY_VAL_ONE,
             KEYR=YES);
%FPT_WRITE (FPTN=WRITE_NOTES,
              DCB=M$UPDATE,
              BUF=MSG_BUF);
%FPT_WRITE (FPTN=WRITE_RECORD,
              DCB=M$CALENDAR,
              BUF=RECORD_BUF,
              KEY=KVAL);
%FPT_WRITE (FPTN=WRITE_REC_DEV,
              DCB=M$UPDATE,
              BUF=WARN_BUF);
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 KEY_VAL_ONE STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RD_REC_BUF STATIC,
      2 DATE,
        3 MM            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 DD            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 YY            CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 TIME,
        3 HR            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT(':'),
        3 MIN           CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 PLACE           CHAR(80) INIT(' '),
      2 TOPIC           CHAR(80) INIT(' '),
      2 RP              CHAR(2) INIT('0'),
      2 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL MSG_BUF CHAR(120) STATIC INIT(' ');
DCL 1 KVAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 WARN_BUF STATIC,
      2 DATE,
        3 MM            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 DD            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 YY            CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 TIME,
        3 HR            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT(':'),
        3 MIN           CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 PLACE           CHAR(80) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 TOPIC           CHAR(80) INIT(' ');
%EJECT;
              /* CHECK CALENDAR FILE TO SEE IF THERE ARE OTHER
                 RECORDS WITH THE SAME KEY.  IF THERE ARE ANY,
                 THEN WRITE THEM OUT AS A WARNING AND CHANGE
                 NEW RECORD'S KEY.                              */
     RECORD_BUF = RBUF;
    KVAL = KEY_VAL;
    CALL M$PRECORD(POS_REC) ALTRET(BAD_POS);
BAD_POS:
    CALL M$READ(READ_KEY) ALTRET(BAD_KEY_RD);
    IF KEY_VAL_ONE = KVAL
         THEN DO;
       IF RD_REC_BUF.TIME.HR = '00' AND RD_REC_BUF.TIME.MIN = '00'
                THEN DO;
                   KVAL.CNT = KVAL.CNT + 1;
                   GOTO BAD_POS;
                     END;
              IF KVAL.CNT = 0
                THEN DO;
                   MSG_BUF='**OTHER APPOINTMENT(S) AT THE SAME TIME**';
                   CALL M$WRITE(WRITE_NOTES);
                   MSG_BUF='-----------------------------------------';
                   CALL M$WRITE(WRITE_NOTES);
                     END;
               WARN_BUF.DATE = RD_REC_BUF.DATE;
               WARN_BUF.TIME = RD_REC_BUF.TIME;
              WARN_BUF.TOPIC = RD_REC_BUF.TOPIC;
              WARN_BUF.PLACE = RD_REC_BUF.PLACE;
              CALL M$WRITE(WRITE_REC_DEV);
              KVAL.CNT = KVAL.CNT + 1;
              GOTO BAD_POS;
              END;
BAD_KEY_RD:
    WRITE_RECORD.BUF_.BOUND = SIZEC(RECORD_BUF.INFO) +
                              (RECORD_BUF.INFO.CNT * 80) - 1;
    CALL M$WRITE(WRITE_RECORD);
    CALL SCH$GROUP(%GROUP_ADD,ADDR(KVAL));
RETURN;
END WRT_RECORD;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
FILL_FLD:  PROC(SYM$,FIELD) ALTRET;
/**/
/* PARAMS */
DCL SYM$ PTR;
DCL FIELD CHAR(2);
DCL RFIELD(0:1) REDEF FIELD CHAR(1);
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE XU_MACRO_C;
/**/
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
    IF OUT$SYM.COUNT = 2
         THEN  FIELD = OUT$SYM.TEXT;
         ELSE
              IF OUT$SYM.COUNT = 1
                   THEN DO;
                        RFIELD(0) = '0';
                        RFIELD(1) = OUT$SYM.TEXT;
                        END;
                   ELSE      /* ERROR */
                        DO;
                             ALTRETURN;
                        END;
    RETURN;
END FILL_FLD;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DATE_TYPE:  PROC(TOP$,TIME_BUF,START,STOP) ALTRET;
/**/
/* PARAMS */
DCL TOP$ PTR;
DCL 1 TIME_BUF,
      2 HR              CHAR(2),
      2 *               CHAR(1),
      2 MIN             CHAR(2);
DCL START UBIN WORD;
DCL STOP UBIN WORD;
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE XU_MACRO_C;
/**/
/* FPT DIFINITIONS */
%FPT_TIME (FPTN=GET_UTS,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TS_UTS);
%FPT_TIME (FPTN=GET_DATE,
           SOURCE=UTS,
           DEST=LOCAL,
           DATE=DATE_BUF,
           DAY=DBUF,
           TSTAMP=TS_UTS);
%FPT_TIME (FPTN=CUR_DATE,
           SOURCE=CLOCK,
           DEST=LOCAL,
           DATE=DATE_BF);
%FPT_TIME (FPTN=CUR_DATE_ONE,
           SOURCE=LOCAL,
           DATE=DATE_BF,
           TIME=TBUF,
           DEST=UTS,
           TSTAMP=TS_UTS);
%FPT_TIME (FPTN=GET_SP_UTS,
           SOURCE=LOCAL,
           DEST=UTS,
           DATE=DATE_BUF,
           TIME=TBUF,
           TSTAMP=SP_UTS);
/**/
/* ENTRY DEFINITIONS */
DCL FILL_FLD ENTRY(2) ALTRET;
/**/
/* VARIABLE DECLARES */
DCL 1 DATE_BUF STATIC,
      2 MM              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 DD              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 YY              CHAR(2) INIT(' ');
DCL 1 DATE_BF STATIC,
      2 MM              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 DD              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 YY              CHAR(2) INIT(' ');
DCL DAY_BUF             CHAR(3) STATIC INIT(' ');
DCL DBUF                CHAR(3) STATIC INIT(' ');
DCL NUM_ALPHA           CHAR(2) STATIC INIT(' ');
DCL NUM UBIN WORD STATIC INIT(0);
DCL TS_UTS UBIN WORD STATIC INIT(0);
DCL 1 TBUF STATIC,
      2 HR              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT(':'),
      2 MIN             CHAR(2) INIT(' ');
DCL SP_UTS UBIN WORD STATIC INIT(0);
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS=BASED);
/**/
%EJECT;
              /*  DETERMINE ITS DATE TYPE.                      */
TBUF = TIME_BUF;
CALL M$TIME (CUR_DATE);
DO CASE (OUT$BLK.CODE);
/**/
              /* DATE_ZERO:  MM/DD/YY (TO|-) MM/DD/YY           */
/**/
    CASE (%DATE_ZERO);
         CALL FILL_FLD (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0),DATE_BUF.MM);
         CALL FILL_FLD (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(1),DATE_BUF.DD);
        IF OUT$BLK.SUBLK$(0)->OUT$BLK.NSUBLKS < 3
           THEN DATE_BUF.YY = DATE_BF.YY;
           ELSE
         CALL FILL_FLD (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(2),DATE_BUF.YY);
         CALL M$TIME(GET_SP_UTS) ALTRET(BAD_DATE);
         START = SP_UTS;
         CALL FILL_FLD (OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(0),DATE_BUF.MM);
         CALL FILL_FLD (OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(1),DATE_BUF.DD);
        IF OUT$BLK.SUBLK$(1)->OUT$BLK.NSUBLKS < 3
           THEN DATE_BUF.YY = DATE_BF.YY;
           ELSE
         CALL FILL_FLD (OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(2),DATE_BUF.YY);
         CALL M$TIME(GET_SP_UTS) ALTRET(BAD_DATE);
         STOP = SP_UTS;
/**/
              /* DATE_ONE:   MM/DD/YY                      */
/**/
    CASE (%DATE_ONE);
         CALL FILL_FLD (OUT$BLK.SUBLK$(0),DATE_BUF.MM);
         CALL FILL_FLD (OUT$BLK.SUBLK$(1),DATE_BUF.DD);
        IF OUT$BLK.NSUBLKS < 3
           THEN DATE_BUF.YY = DATE_BF.YY;
           ELSE
         CALL FILL_FLD (OUT$BLK.SUBLK$(2),DATE_BUF.YY);
         CALL M$TIME(GET_SP_UTS) ALTRET(BAD_DATE);
         START = SP_UTS;
         STOP = START;
/**/
              /* DATE_TWO:  NEXT day                       */
/**/
    CASE (%DATE_TWO);
         CALL WHAT_DAY (OUT$BLK.SUBLK$(0),DAY_BUF);
         CALL M$TIME(GET_UTS);
         FIND_DAY:
              CALL XUD$UTS_ADJUST (TS_UTS,TS_UTS,%UTS_CSEC_DAY#);
              CALL M$TIME (GET_DATE);
              IF DAY_BUF = DBUF
                   THEN DO;
                        CALL M$TIME(GET_SP_UTS) ALTRET(BAD_DATE);
                             START = SP_UTS;
                        STOP = START;
                        END;
                   ELSE  GOTO FIND_DAY;
/**/
              /* DATE_THREE:  EVERY day FOR num WEEKS|MONTHS    */
/**/
    CASE (%DATE_THREE);
         CALL WHAT_DAY (OUT$BLK.SUBLK$(0),DAY_BUF);
         CALL CHARBIN(NUM,OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT);
         CALL M$TIME(GET_UTS);
         FIND_DAY_ONE:
              CALL XUD$UTS_ADJUST (TS_UTS,TS_UTS,%UTS_CSEC_DAY#);
              CALL M$TIME (GET_DATE);
              IF DAY_BUF = DBUF
                   THEN DO;   CALL M$TIME(GET_SP_UTS) ALTRET(BAD_DATE);
                              START = SP_UTS;
                        END;
                   ELSE  GOTO FIND_DAY_ONE;
              IF OUT$BLK.NSUBLKS = 3   AND
                 OUT$BLK.SUBLK$(2) -> OUT$BLK.CODE = %MONTHS
                   THEN CALL XUD$UTS_ADJUST (STOP,START,NUM*%UTS_CSEC_MONTH#);
                   ELSE CALL XUD$UTS_ADJUST (STOP,START,(NUM-1)*%UTS_CSEC_WEEK#);
/**/
               /* DATE_FOUR:  TOMORROW          */
/**/
    CASE (%DATE_FOUR);
         CALL M$TIME (CUR_DATE_ONE) ALTRET(BAD_DATE);
         CALL XUD$UTS_ADJUST (START,TS_UTS,%UTS_CSEC_DAY#);
         STOP = START;
    CASE (ELSE);
         ALTRETURN;
END;          /* END OF CASE DO                                 */
RETURN;
/**/
BAD_DATE:
     ALTRETURN;
%EJECT;
WHAT_DAY:  PROC(TOP$,DAY_BUF);
/**/
/* PARAMS */
DCL TOP$ PTR;
DCL DAY_BUF CHAR(3);
/**/
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
/**/
    DO CASE (OUT$BLK.CODE);
         CASE (%SUN);
              DAY_BUF = 'SUN';
         CASE (%MON);
              DAY_BUF = 'MON';
         CASE (%TUE);
              DAY_BUF = 'TUE';
         CASE (%WED);
              DAY_BUF = 'WED';
         CASE (%THU);
              DAY_BUF = 'THU';
         CASE (%FRI);
              DAY_BUF = 'FRI';
         CASE (%SAT);
              DAY_BUF = 'SAT';
    END;
    RETURN;
END WHAT_DAY;
END DATE_TYPE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*M* CMD$CANCEL - TO CANCEL SCHEDULED EVENTS/APPOINTMENTS.      */
/**/
CMD$CANCEL:  PROC (PTR$);
/**/
/* PARAMS */
DCL PTR$ PTR;
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE B_ERRORS_C;
%INCLUDE CALENDAR_C2;
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL SCH$ERRMSG ENTRY(1);
DCL DATE_TYPE ENTRY(4) ALTRET;
DCL FILL_FLD ENTRY(2) ALTRET;
DCL SCH$GROUP ENTRY(2);
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL M$UPDATE DCB;
%FPT_TIME (FPTN=GET_DATE,
             SOURCE=UTS,
             DEST=LOCAL,
             DATE=DATE_BUF,
             TIME=TIME_BUF,
             TSTAMP=WHEN_UTS);
%FPT_READ (FPTN=READ_KEY,
             DCB=M$CALENDAR,
             BUF=RECORD_BUF,
             KEY=KEY_VAL_ONE,
             KEYR=YES);
%FPT_WRITE (FPTN=WRITE_NOTES,
              DCB=M$UPDATE,
              BUF=MSG_BUF);
%FPT_PRECORD (FPTN=POS_REC,
              DCB=M$CALENDAR,
                KEY=KEY_VAL,
                KEYR=NO,
                KEYS=YES);
%FPT_DELREC (FPTN=CAL_DEL,DCB=M$CALENDAR);
/**/
/* VARIABLE DECLARES */
DCL 1 KEY_VAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 KEY_VAL_ONE STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL WHEN_UTS UBIN WORD STATIC INIT(0);
DCL TEMP_UTS UBIN WORD STATIC INIT(0);
DCL MSG_BUF CHAR(120) STATIC INIT(' ');
DCL INPUT_CANCEL SBIN SYMREF;
DCL TOP$ PTR;
DCL PRMT CHAR(0) CONSTANT INIT('CA (DATE, TIME or EVENT):');
DCL PRMT_FLAG BIT(1);
DCL START UBIN WORD STATIC INIT(0);
DCL STOP UBIN WORD STATIC INIT(0);
DCL TOPIC CHAR(80) STATIC INIT(' ');
DCL 1 TIME_BUF STATIC,
      2 HR              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT(':'),
      2 MIN             CHAR(2) INIT(' ');
DCL 1 DATE_BUF STATIC,
      2 MM              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 DD              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 YY              CHAR(2) INIT(' ');
DCL I UBIN BYTE STATIC;
DCL FLAG UBIN BYTE STATIC;
DCL TEMP UBIN WORD STATIC;
DCL T_DATE CHAR(8) STATIC;
DCL T_TIME CHAR(5) STATIC;
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS=BASED);
%PARSE$SYM (NAME=OUT$SYM,STCLASS=BASED);
%B$TCB;
%B$ALT;
/**/
%EJECT;
              /* DETERMINE WHETHER DATE AND (TIME|TOPIC) WERE
                 ENTERED WITH THE CANCEL COMMAND.  IF NOT
                 PROMPT THE USER FOR DATE AND (TIME|TOPIC). */
PRMT_FLAG = %FALSE;
IF PTR$ -> OUT$BLK.NSUBLKS = 0
    THEN
    DO;
GETCMD:
         PRMT_FLAG = %TRUE;
         CALL XUR$GETCMD(INPUT_CANCEL,TOP$,VECTOR(PRMT)) ALTRET(PAR_ERR);
         DO CASE (TOP$ -> OUT$BLK.CODE);
              CASE (%DATE_TIME);
                   PTR$ = TOP$;
                   GOTO D_TIME;
              CASE (%DATE_TOPIC);
                   PTR$ = TOP$;
                   GOTO D_TOPIC;
              CASE (%QUIT_CMD);
                   RETURN;
         END;
    DO NEVER;
PAR_ERR:
         CALL XUR$ERRPTR(,DCBNUM(M$UPDATE));
         CALL SCH$ERRMSG(%E$TH_PAR_ERR);
         GOTO GETCMD;
    END;
END;
/**/
              /* DO CASE STMT FOR TIME OR TOPIC.                */
/**/
DO CASE (PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE);
    CASE (%TOPIC);
D_TOPIC:
         IF PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0) -> OUT$SYM.COUNT = 0
              THEN TOPIC = ' ';
              ELSE TOPIC = PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
         TIME_BUF.HR = '00';
         TIME_BUF.MIN = '00';
         CALL DATE_TYPE (PTR$ ->OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                         TIME_BUF,START,STOP) ALTRET (BAD_DATE);
IF PTR$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
   OUT$BLK.NSUBLKS  > 3
         THEN TEMP = %UTS_CSEC_DAY#;
         ELSE TEMP = %UTS_CSEC_WEEK#;
         WHEN_UTS = START;
         DO WHILE WHEN_UTS <= STOP;
              CALL M$TIME (GET_DATE);
              FLAG = 0;
              CALL XUD$UTS_ADJUST (TEMP_UTS,WHEN_UTS,%UTS_CSEC_DAY#);
              KEY_VAL.KEY = WHEN_UTS;
              KEY_VAL.CNT = 0;
              CALL M$PRECORD(POS_REC) ALTRET(READ_AGAIN);
    READ_AGAIN:
              CALL M$READ(READ_KEY) ALTRET (BAD_READ);
              IF KEY_VAL_ONE.KEY < TEMP_UTS
                   THEN DO;
                        IF TOPIC = RECORD_BUF.INFO.TOPIC
                             THEN DO;
                                  CALL M$DELREC (CAL_DEL);
                                  CALL SCH$GROUP(%GROUP_DELETE,ADDR(KEY_VAL_ONE));
                                  CALL CONCAT (T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(MSG_BUF,
                                       'Appointment is canceled on ',T_DATE,
                                       ' for ',TOPIC);
                                  CALL M$WRITE(WRITE_NOTES);
                                  FLAG = 1;
                                  END;
                        GOTO READ_AGAIN;
                        END;
                   ELSE
    BAD_READ:
                        IF FLAG = 0
                             THEN DO;
                                  CALL CONCAT (T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(MSG_BUF,
                                       'Nothing is scheduled on ',T_DATE,
                                       ' for ',TOPIC);
                                  CALL M$WRITE(WRITE_NOTES);
                                  END;
              CALL XUD$UTS_ADJUST (WHEN_UTS,WHEN_UTS,TEMP);
         END;
    CASE (%TIME#);
D_TIME:
         CALL FILL_FLD(PTR$ -> OUT$BLK.SUBLK$(1) ->OUT$BLK.SUBLK$(0),
                       TIME_BUF.HR) ALTRET(BAD_TIME);
         CALL FILL_FLD(PTR$ -> OUT$BLK.SUBLK$(1) ->OUT$BLK.SUBLK$(1),
                       TIME_BUF.MIN) ALTRET(BAD_TIME);
         CALL DATE_TYPE(PTR$ -> OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                        TIME_BUF,START,STOP) ALTRET(BAD_DATE);
IF PTR$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
   OUT$BLK.NSUBLKS  > 3
         THEN TEMP = %UTS_CSEC_DAY#;
         ELSE TEMP = %UTS_CSEC_WEEK#;
         WHEN_UTS = START;
         DO WHILE WHEN_UTS <= STOP;
              CALL M$TIME(GET_DATE);
              FLAG = 0;
              KEY_VAL.KEY = WHEN_UTS;
              KEY_VAL.CNT = 0;
              CALL M$PRECORD(POS_REC) ALTRET(READ_AGAIN1);
        READ_AGAIN1:
              CALL M$READ(READ_KEY) ALTRET(BAD_READ1);
              IF KEY_VAL.KEY = KEY_VAL_ONE.KEY
                   THEN DO;
                        CALL M$DELREC(CAL_DEL);
                        CALL SCH$GROUP(%GROUP_DELETE,ADDR(KEY_VAL_ONE));
                        FLAG= 1;
                        CALL CONCAT(T_DATE,DATE_BUF.MM,'/',
                             DATE_BUF.DD,'/',DATE_BUF.YY);
                        CALL CONCAT(T_TIME,TIME_BUF.HR,':',TIME_BUF.MIN);
                        CALL CONCAT(MSG_BUF,'Appointment for ',T_DATE,
                             '  ',T_TIME,' is canceled.');
                        CALL M$WRITE(WRITE_NOTES);
                        GOTO READ_AGAIN1;
                        END;
                   ELSE
         BAD_READ1:
                        IF FLAG = 0
                             THEN DO;
                                  CALL CONCAT(T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(T_TIME,TIME_BUF.HR,':',
                                       TIME_BUF.MIN);
                                  CALL CONCAT(MSG_BUF,
                                       'Nothing is scheduled for ',T_DATE,
                                       '  ',T_TIME);
                                  CALL M$WRITE(WRITE_NOTES);
                                  END;
              CALL XUD$UTS_ADJUST (WHEN_UTS,WHEN_UTS,TEMP);
        END;
END;
RETURN;
/**/
BAD_TIME:
         CALL SCH$ERRMSG(%E$TH_TIME);
         IF PRMT_FLAG
              THEN GOTO GETCMD;
         RETURN;
BAD_DATE:
         CALL SCH$ERRMSG(%E$TH_DATE);
         IF PRMT_FLAG
              THEN GOTO GETCMD;
         RETURN;
END CMD$CANCEL;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*M* CMD$CHANGE - TO RESCHEDULE SCHEDULED EVENTS/APPOINTMENTS. */
/**/
CMD$CHANGE:  PROC (PTR$);
/**/
/* PARAMS */
DCL PTR$ PTR;
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE B_ERRORS_C;
%INCLUDE CALENDAR_C2;
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL SCH$ERRMSG ENTRY(1);
DCL DATE_TYPE ENTRY(4) ALTRET;
DCL FILL_FLD ENTRY(2) ALTRET;
DCL EDIT_THIS ENTRY(3) ALTRET;
DCL WRT_RECORD ENTRY(2) ;
DCL SCH$GROUP ENTRY(2);
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL M$UPDATE DCB;
%FPT_TIME (FPTN=GET_DATE,
             SOURCE=UTS,
             DEST=LOCAL,
             DATE=DATE_BUF,
             TIME=TIME_BUF,
             TSTAMP=WHEN_UTS);
%FPT_READ (FPTN=READ_KEY,
             DCB=M$CALENDAR,
             BUF=RECORD_BUF,
             KEY=KEY_VAL_ONE,
             KEYR=YES);
%FPT_WRITE (FPTN=WRITE_PRMT,
              DCB=M$UPDATE,
              BUF=MSG_BUF);
%FPT_WRITE (FPTN=WRITE_NOTES,
              DCB=M$UPDATE,
              BUF=MSG_BUF);
%FPT_PRECORD (FPTN=POS_REC,
              DCB=M$CALENDAR,
                KEY=KEY_VAL,
                KEYR=NO,
                KEYS=YES);
%FPT_DELREC (FPTN=CAL_DEL,DCB=M$CALENDAR);
%FPT_WRITE (FPTN=WRITE_KEY,
            DCB=M$CALENDAR,
            BUF=RECORD_BUF,
            KEY=KEY_VAL_ONE);
%FPT_READ (FPTN=READ_KEY_ONE,
           DCB=M$CALENDAR,
           BUF=RECORD_BUF,
           KEY=KEY_VAL_ONE,
           KEYS=YES,
           KEYR=NO);
%FPT_TIME (FPTN=GET_NEW_KEY,
           SOURCE=LOCAL,
           DEST=UTS,
           DATE=RECORD_BUF.INFO.DATE,
           TIME=RECORD_BUF.INFO.TIME,
           TSTAMP=NEW_KEY);
/**/
/* VARIABLE DECLARES */
DCL 1 KEY_VAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 TEMP_BUF STATIC,
      2 DATE,
        3 MM            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 DD            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 YY            CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 TIME,
        3 HR            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT(':'),
        3 MIN           CHAR(2) INIT(' '),
      2 *               CHAR(2) INIT(' '),
      2 PLACE           CHAR(80) INIT(' '),
      2 TOPIC           CHAR(80) INIT(' '),
      2 RP              CHAR(2) INIT('0'),
      2 CNT          UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL 1 KEY_VAL_ONE STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 KEY_V_O STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL WHEN_UTS UBIN WORD STATIC INIT(0);
DCL TEMP_UTS UBIN WORD STATIC INIT(0);
DCL MSG_BUF CHAR(120) STATIC INIT(' ');
DCL INPUT_CHANGE SBIN SYMREF;
DCL TOP$ PTR;
DCL PRMT_FLAG BIT(1);
DCL PRMT1 CHAR(0) CONSTANT INIT('CH (DATE, TIME or EVENT, Field Name):');
DCL PRMT2 CHAR(0) CONSTANT INIT('CH:');
DCL START UBIN WORD STATIC INIT(0);
DCL STOP UBIN WORD STATIC INIT(0);
DCL TOPIC CHAR(80) STATIC INIT(' ');
DCL 1 TIME_BUF STATIC,
      2 HR              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT(':'),
      2 MIN             CHAR(2) INIT(' ');
DCL 1 DATE_BUF STATIC,
      2 MM              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 DD              CHAR(2) INIT(' '),
      2 *               CHAR(1) INIT('/'),
      2 YY              CHAR(2) INIT(' ');
DCL I UBIN BYTE STATIC;
DCL FLAG UBIN BYTE STATIC;
DCL NEW_KEY UBIN WORD STATIC INIT(0);
DCL TEMP UBIN WORD STATIC;
DCL SIGNAL UBIN BYTE STATIC INIT(0);
DCL T_DATE CHAR(8) STATIC;
DCL T_TIME CHAR(5) STATIC;
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS=BASED);
%PARSE$SYM (NAME=OUT$SYM,STCLASS=BASED);
%P_PCB( STCLASS=SYMREF );
%B$TCB;
%B$ALT;
/**/
%EJECT;
              /* DETERMINE WHETHER DATE, TIME|TOPIC AND SUBJECT WERE
                 ENTERED WITH THE CHANGE COMMAND.  IF NOT
                 PROMPT THE USER FOR DATE, TIME|TOPIC AND SUBJECT. */
PRMT_FLAG = %FALSE;
IF PTR$ -> OUT$BLK.NSUBLKS = 0
    THEN
    DO;
GETCMD:
         PRMT_FLAG = %TRUE;
         MSG_BUF = PRMT1;
         CALL M$WRITE(WRITE_PRMT);
         CALL XUR$GETCMD(INPUT_CHANGE,TOP$,VECTOR(PRMT2)) ALTRET(PAR_ERR);
         DO CASE (TOP$ -> OUT$BLK.CODE);
              CASE (%DATE_TI_SUB);
                   PTR$ = TOP$;
                   GOTO D_TIME;
              CASE (%DATE_TO_SUB);
                   PTR$ = TOP$;
                   GOTO D_TOPIC;
              CASE (%QUIT_CMD);
                   RETURN;
         END;
    DO NEVER;
PAR_ERR:
         CALL XUR$ERRPTR(P_PCB.HI_CHAR+LENGTHC(PRMT1)-1,DCBNUM(M$UPDATE));
         CALL SCH$ERRMSG(%E$TH_PAR_ERR);
         GOTO GETCMD;
    END;
END;
/**/
              /* DO CASE STMT FOR TIME OR TOPIC.                */
/**/
DO CASE (PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE);
    CASE (%TOPIC);
D_TOPIC:
         IF PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0) -> OUT$SYM.COUNT = 0
              THEN TOPIC = ' ';
              ELSE TOPIC = PTR$ -> OUT$BLK.SUBLK$(1) -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
         TIME_BUF.HR = '00';
         TIME_BUF.MIN = '00';
         CALL DATE_TYPE (PTR$ ->OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                         TIME_BUF,START,STOP) ALTRET (BAD_DATE);
IF PTR$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
   OUT$BLK.NSUBLKS  > 3
         THEN TEMP = %UTS_CSEC_DAY#;
         ELSE TEMP = %UTS_CSEC_WEEK#;
         SIGNAL = 0;
         WHEN_UTS = START;
         DO WHILE WHEN_UTS <= STOP;
              CALL M$TIME (GET_DATE);
              FLAG = 0;
              CALL XUD$UTS_ADJUST (TEMP_UTS,WHEN_UTS,%UTS_CSEC_DAY#);
              KEY_VAL.KEY = WHEN_UTS;
              KEY_VAL.CNT = 0;
              CALL M$PRECORD(POS_REC) ALTRET(READ_AGAIN);
    READ_AGAIN:
              CALL M$READ(READ_KEY) ALTRET (BAD_READ);
              IF KEY_VAL_ONE.KEY < TEMP_UTS
                   THEN DO;
                        IF TOPIC = RECORD_BUF.INFO.TOPIC
                             THEN DO;
                   IF SIGNAL = 1
                     THEN
                     DO CASE(PTR$->OUT$BLK.SUBLK$(2)->OUT$BLK.CODE);
                        CASE (%TI);
                             RECORD_BUF.INFO.TIME = TEMP_BUF.TIME;
                             CALL M$TIME(GET_NEW_KEY);
                             GOTO CH_KEY;
                        CASE(%PL);
                             RECORD_BUF.INFO.PLACE=TEMP_BUF.PLACE;
                             GOTO CH_OTHERS;
                        CASE (%TO);
                             RECORD_BUF.INFO.TOPIC=TEMP_BUF.TOPIC;
                             GOTO CH_OTHERS;
                        CASE (%RP);
                             RECORD_BUF.INFO.RP=TEMP_BUF.RP;
                             GOTO CH_OTHERS;
                        CASE (%NO);
                             DO I = 0 TO TEMP_BUF.CNT - 1;
                                  RECORD_BUF.NOTES(I)=TEMP_BUF.NOTES(I);
                             END;
                             RECORD_BUF.INFO.CNT = TEMP_BUF.CNT;
                             GOTO CH_OTHERS;
                      END;
                                  NEW_KEY = KEY_VAL_ONE.KEY;
                                  CALL EDIT_THIS(PTR$->OUT$BLK.SUBLK$(2),
                                       RECORD_BUF,NEW_KEY) ALTRET(RET);
                                  TEMP_BUF = RECORD_BUF;
                                  SIGNAL = 1;
                                  IF NEW_KEY ~=KEY_VAL_ONE.KEY
                                       THEN DO;
CH_KEY:                                     KEY_V_O.KEY=NEW_KEY;
                                            KEY_V_O.CNT=0;
                                            CALL WRT_RECORD(KEY_V_O,RECORD_BUF);
                                            CALL M$READ (READ_KEY_ONE) ALTRET(BAD_READ);
                                            CALL M$DELREC (CAL_DEL);
                                            CALL SCH$GROUP(%GROUP_DELETE,
                                                            ADDR(KEY_VAL_ONE));
                                            CALL SCH$GROUP(%GROUP_ADD,
                                                           ADDR(KEY_V_O));
                                       END;
                                       ELSE DO;
CH_OTHERS:       WRITE_KEY.BUF_.BOUND = SIZEC(RECORD_BUF.INFO) +
                                        (RECORD_BUF.INFO.CNT * 80) - 1;
                                           CALL M$WRITE(WRITE_KEY);
                                            END;
                                  CALL CONCAT (T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(MSG_BUF,
                                       'Appointment is changed on ',T_DATE,
                                       ' for ',TOPIC);
                                  CALL M$WRITE(WRITE_NOTES);
                                  FLAG= 1;
                                  GOTO BAD_READ;
                                  END;
                        GOTO READ_AGAIN;
                        END;
                   ELSE
    BAD_READ:
                        IF FLAG = 0
                             THEN DO;
                                  CALL CONCAT (T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(MSG_BUF,
                                       'Nothing is scheduled on ',T_DATE,
                                       ' for ',TOPIC);
                                  CALL M$WRITE(WRITE_NOTES);
                                  END;
              CALL XUD$UTS_ADJUST (WHEN_UTS,WHEN_UTS,TEMP);
         END;
    CASE (%TIME#);
D_TIME:
         CALL FILL_FLD(PTR$ -> OUT$BLK.SUBLK$(1) ->
                       OUT$BLK.SUBLK$(0),TIME_BUF.HR) ALTRET(BAD_TIME);
         CALL FILL_FLD(PTR$ -> OUT$BLK.SUBLK$(1) ->
                       OUT$BLK.SUBLK$(1),TIME_BUF.MIN) ALTRET(BAD_TIME);
         CALL DATE_TYPE(PTR$ -> OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0),
                        TIME_BUF,START,STOP) ALTRET(BAD_DATE);
IF PTR$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
   OUT$BLK.NSUBLKS  > 3
         THEN TEMP = %UTS_CSEC_DAY#;
         ELSE TEMP = %UTS_CSEC_WEEK#;
         SIGNAL = 0;
         WHEN_UTS = START;
         DO WHILE WHEN_UTS <= STOP;
              CALL M$TIME(GET_DATE);
              FLAG = 0;
              KEY_VAL.KEY = WHEN_UTS;
              KEY_VAL.CNT = 0;
              CALL M$PRECORD(POS_REC) ALTRET(READ_AGAIN1);
        READ_AGAIN1:
              CALL M$READ(READ_KEY) ALTRET(BAD_READ1);
              IF KEY_VAL.KEY = KEY_VAL_ONE.KEY
                   THEN DO;
                   IF SIGNAL = 1
                     THEN
                     DO CASE(PTR$->OUT$BLK.SUBLK$(2)->OUT$BLK.CODE);
                        CASE (%TI);
                             RECORD_BUF.INFO.TIME = TEMP_BUF.TIME;
                             CALL M$TIME(GET_NEW_KEY);
                             GOTO CH_KEY1;
                        CASE(%PL);
                             RECORD_BUF.INFO.PLACE=TEMP_BUF.PLACE;
                             GOTO CH_OTHERS1;
                        CASE (%TO);
                             RECORD_BUF.INFO.TOPIC=TEMP_BUF.TOPIC;
                             GOTO CH_OTHERS1;
                        CASE (%RP);
                             RECORD_BUF.INFO.RP=TEMP_BUF.RP;
                             GOTO CH_OTHERS1;
                        CASE (%NO);
                             DO I = 0 TO TEMP_BUF.CNT - 1;
                                  RECORD_BUF.NOTES(I)=TEMP_BUF.NOTES(I);
                             END;
                             RECORD_BUF.INFO.CNT = TEMP_BUF.CNT;
                             GOTO CH_OTHERS1;
                      END;
                                  NEW_KEY = KEY_VAL_ONE.KEY;
                                  CALL EDIT_THIS(PTR$->OUT$BLK.SUBLK$(2),
                                       RECORD_BUF,NEW_KEY) ALTRET(RET);
                                  TEMP_BUF = RECORD_BUF;
                                  SIGNAL = 1;
                                  IF NEW_KEY ~=KEY_VAL_ONE.KEY
                                       THEN DO;
CH_KEY1:                                    KEY_V_O.KEY=NEW_KEY;
                                            KEY_V_O.CNT=0;
                                            CALL WRT_RECORD(KEY_V_O,RECORD_BUF);
                                            CALL M$READ (READ_KEY_ONE) ALTRET(BAD_READ);
                                            CALL M$DELREC (CAL_DEL);
                                            CALL SCH$GROUP(%GROUP_DELETE,
                                                            ADDR(KEY_VAL_ONE));
                                            CALL SCH$GROUP(%GROUP_ADD,
                                                           ADDR(KEY_V_O));
                                       END;
                                       ELSE DO;
CH_OTHERS1:      WRITE_KEY.BUF_.BOUND = SIZEC(RECORD_BUF.INFO) +
                                        (RECORD_BUF.INFO.CNT * 80) - 1;
                                            CALL M$WRITE(WRITE_KEY);
                                            END;
                        CALL CONCAT(T_DATE,DATE_BUF.MM,'/',
                             DATE_BUF.DD,'/',DATE_BUF.YY);
                        CALL CONCAT(T_TIME,TIME_BUF.HR,':',TIME_BUF.MIN);
                        CALL CONCAT(MSG_BUF,'Appointment for ',T_DATE,
                             '  ',T_TIME,' is changed.');
                        CALL M$WRITE(WRITE_NOTES);
                                  FLAG= 1;
                        GOTO READ_AGAIN1;
                        END;
                   ELSE
         BAD_READ1:
                        IF FLAG = 0
                             THEN DO;
                                  CALL CONCAT(T_DATE,DATE_BUF.MM,'/',
                                       DATE_BUF.DD,'/',DATE_BUF.YY);
                                  CALL CONCAT(T_TIME,TIME_BUF.HR,':',
                                       TIME_BUF.MIN);
                                  CALL CONCAT(MSG_BUF,
                                       'Nothing is scheduled for ',T_DATE,
                                       '  ',T_TIME);
                                  CALL M$WRITE(WRITE_NOTES);
                                  END;
              CALL XUD$UTS_ADJUST (WHEN_UTS,WHEN_UTS,TEMP);
        END;
END;
RET: RETURN;
/**/
BAD_TIME:
         CALL SCH$ERRMSG(%E$TH_TIME);
         IF PRMT_FLAG
              THEN GOTO GETCMD;
         RETURN;
BAD_DATE:
         CALL SCH$ERRMSG(%E$TH_DATE);
         IF PRMT_FLAG
              THEN GOTO GETCMD;
         RETURN;
END CMD$CHANGE;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/* THIS PROC WILL CHANGE|UPDATE THE SPECIFIED SUBJECT.  IT
   WILL PRINT THE OLD SUBJECT THEN WILL PROMT THE USER TO
   ENTER NEW SUBJECT.                                      */
/**/
EDIT_THIS:  PROC (PTR$,RECORD_BUF,NEW_KEY) ALTRET;
/**/
/* PARAMS */
DCL PTR$ PTR;
DCL 1 RECORD_BUF,
      2 INFO,
        3 DATE,
          4 MM          CHAR(2),
          4 *           CHAR(1),
          4 DD          CHAR(2),
          4 *           CHAR(1),
          4 YY          CHAR(2),
        3 DATE_C REDEF DATE CHAR(8),
        3 *             CHAR(2),
        3 TIME,
          4 HR          CHAR(2),
          4 *           CHAR(1),
          4 MIN         CHAR(2),
        3 TIME_C REDEF TIME CHAR(5),
        3 *             CHAR(2),
        3 PLACE         CHAR(80),
        3 TOPIC         CHAR(80),
        3 RP            CHAR(2),
        3 CNT           UBIN BYTE,
      2 NOTES(0:20)     CHAR(80);
DCL NEW_KEY UBIN WORD;
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE B_ERRORS_C;
%INCLUDE CALENDAR_C2;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL FILL_FLD ENTRY(2) ALTRET;
DCL SCH$ERRMSG ENTRY(1);
/**/
/* DCBS */
DCL M$TEMP DCB;
DCL M$UPDATE DCB;
/**/
/* FPT DEFINITIONS */
%F$DCB;
%FPT_OPEN (FPTN=EDIT_OPEN,
           DCB=M$TEMP,
           ASN=FILE,
           FUN=CREATE,
           NAME=VLP_EDITNAME,
           SCRUB=YES,
           ACS=DIRECT,
           SHARE=ALL,
           ORG=KEYED);
%FPT_OPEN (FPTN=EDIT_OP,DCB=M$TEMP,FUN=IN);
%VLP_NAME (FPTN=VLP_EDITNAME,NAME='*CAL_NOTES');
%FPT_TIME (FPTN=GET_UTS,
           SOURCE=LOCAL,
           DEST=UTS,
           DATE=DBUF,
           TIME=TBUF,
           TSTAMP=NKEY);
%FPT_TIME (FPTN=CUR_DATE,
           SOURCE=CLOCK,
           DEST=LOCAL,
           DATE=DBF);
%FPT_TIME (FPTN=CUR_UTS,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TS_UTS);
%FPT_WRITE (FPTN=WRT_TEMP,
            DCB=M$TEMP,
            BUF=MSG_BUF,
            KEY=KEY_TEMP);
%FPT_LINK (ACCT=SYSACCT,
           NAME=EDIT_NAME,
           CMD=EDIT_CMD);
%VLP_ACCT (FPTN=SYSACCT,ACCT=':SYS');
%VLP_NAME (FPTN=EDIT_NAME,NAME='EDIT');
%FPT_PFIL (FPTN=EDIT_PFIL,DCB=M$TEMP,BOF=YES);
%FPT_READ (FPTN=EDIT_READ,DCB=M$TEMP,BUF=MSG_BUF,KEY=KEY_TEMP,KEYR=YES);
%FPT_CLOSE (FPTN=EDIT_CLOSE,DCB=M$TEMP);
%FPT_CLOSE (FPTN=EDIT_CL,DCB=M$TEMP,DISP=SAVE);
%FPT_WRITE (FPTN=WRITE_NOTES,
            DCB=M$UPDATE,
            BUF=MSG_BUF);
/**/
/* VARIABLE DECLARES */
DCL MSG_BUF CHAR(80) STATIC INIT(' ');
DCL TOP$ PTR;
DCL PRMT1 CHAR(0) CONSTANT INIT('CH (New DATE):');
DCL PRMT2 CHAR(0) CONSTANT INIT('CH (New PLACE):');
DCL PRMT3 CHAR(0) CONSTANT INIT('CH (New EVENT):');
DCL PRMT4 CHAR(0) CONSTANT INIT('CH (New Reminder Period):');
DCL PRMT5 CHAR(0) CONSTANT INIT('CH (New TIME):');
DCL INPUT_TIME SBIN SYMREF;
DCL INPUT_RP SBIN SYMREF;
DCL INPUT_DATE SBIN SYMREF;
DCL INPUT_PLACE SBIN SYMREF;
DCL I SBIN;
DCL T_RP CHAR(2);
DCL 1 KEY_TEMP STATIC,
      2 *          UBIN BYTE CALIGNED INIT(3),
      2 KEY        UBIN(27)  CALIGNED INIT(1000);
DCL 1 EDIT_CMD STATIC ALIGNED,
      2 *          UBIN BYTE UNAL INIT(15),
      2 *          CHAR(15) UNAL INIT('EDIT *CAL_NOTES');
DCL 1 DBUF STATIC,
      2 MM         CHAR(2) INIT(' '),
      2 *          CHAR(1) INIT('/'),
      2 DD         CHAR(2) INIT(' '),
      2 *          CHAR(1) INIT('/'),
      2 YY         CHAR(2) INIT(' ');
DCL 1 DBF STATIC,
      2 MM         CHAR(2) INIT(' '),
      2 *          CHAR(1) INIT('/'),
      2 DD         CHAR(2) INIT(' '),
      2 *          CHAR(1) INIT('/'),
      2 YY         CHAR(2) INIT(' ');
DCL 1 TBUF STATIC,
      2 HR         CHAR(2) INIT(' '),
      2 *          CHAR(1) INIT(':'),
      2 MIN        CHAR(2) INIT(' ');
DCL NKEY UBIN WORD STATIC;
DCL TS_UTS UBIN STATIC INIT(0);
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS=BASED);
%PARSE$SYM (NAME=OUT$SYM,STCLASS=BASED);
%B$TCB;
%B$ALT;
/**/
%EJECT;
DO CASE (PTR$ -> OUT$BLK.CODE);
/**/
              /* SUBJECT TO BE CHANGED IS TIME.       */
/**/
    CASE (%TI);
         CALL CONCAT (MSG_BUF,'Old TIME is: ',RECORD_BUF.INFO.TIME_C);
         CALL M$WRITE (WRITE_NOTES);
TIME_TI:
         CALL XUR$GETCMD(INPUT_TIME,TOP$,VECTOR(PRMT5)) ALTRET(PAR_TIME);
IF TOP$ -> OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
         IF TOP$ -> OUT$BLK.NSUBLKS > 0
              THEN DO;
                   CALL FILL_FLD(TOP$ -> OUT$BLK.SUBLK$(0),
                        RECORD_BUF.INFO.TIME.HR) ALTRET(BAD_TIME);
                   CALL FILL_FLD(TOP$ -> OUT$BLK.SUBLK$(1),
                        RECORD_BUF.INFO.TIME.MIN) ALTRET(BAD_TIME);
                   END;
              ELSE DO;
                             RECORD_BUF.INFO.TIME.HR = '00';
                             RECORD_BUF.INFO.TIME.MIN = '00';
                              END;
         DBUF = RECORD_BUF.INFO.DATE;
         TBUF = RECORD_BUF.INFO.TIME;
         CALL M$TIME (GET_UTS);
         NEW_KEY = NKEY;
         CALL M$TIME(CUR_UTS);
         IF NKEY < TS_UTS
         THEN DO;
              CALL SCH$ERRMSG( %E$TH_OBSOLETE_EVENT );
              GOTO TIME_TI;
         END;
         DO NEVER;
PAR_TIME:
         CALL XUR$ERRPTR(,DCBNUM(M$UPDATE));
         CALL SCH$ERRMSG (%E$TH_PAR_ERR1);
         GOTO TIME_TI;
BAD_TIME:
         CALL SCH$ERRMSG (%E$TH_TIME);
         GOTO TIME_TI;
         END;           /*  END OF DO NEVER */
/**/
              /* SUBJECT TO BE CHANGED IS PLACE.           */
/**/
    CASE (%PL);
         CALL CONCAT(MSG_BUF,'Old PLACE is: ',RECORD_BUF.INFO.PLACE);
         CALL M$WRITE (WRITE_NOTES);
PLACE_PL:
         CALL XUR$GETCMD(INPUT_PLACE,TOP$,VECTOR(PRMT2));
IF TOP$ -> OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
         RECORD_BUF.INFO.PLACE = TOP$ -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
/**/
              /* SUBJECT TO BE CHANGED IS TIOPIC.           */
/**/
    CASE (%TO);
         CALL CONCAT(MSG_BUF,'Old EVENT is: ',RECORD_BUF.INFO.TOPIC);
         CALL M$WRITE (WRITE_NOTES);
TOPIC_TO:
         CALL XUR$GETCMD(INPUT_PLACE,TOP$,VECTOR(PRMT3));
IF TOP$ -> OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
         RECORD_BUF.INFO.TOPIC = TOP$ -> OUT$BLK.SUBLK$(0) -> OUT$SYM.TEXT;
/**/
              /* SUBJECT TO BE CHANGED IS REMINDING PERIOD.     */
/**/
    CASE (%RP);
         T_RP = RECORD_BUF.INFO.RP;
         IF SUBSTR(T_RP,0,1) = '0'
              THEN SUBSTR(T_RP,0,1) = ' ';
         CALL CONCAT(MSG_BUF,'Old Reminder Period is: ',
                     T_RP);
         CALL M$WRITE (WRITE_NOTES);
REM_RP:
         CALL XUR$GETCMD(INPUT_RP,TOP$,VECTOR(PRMT4)) ALTRET(PAR_RP);
IF TOP$ -> OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
         IF TOP$ -> OUT$BLK.NSUBLKS > 0
              THEN CALL FILL_FLD (TOP$->OUT$BLK.SUBLK$(0),RECORD_BUF.INFO.RP) ALTRET(PAR_RP);
              ELSE RECORD_BUF.INFO.RP = '00';
         DO NEVER;
PAR_RP:
         CALL SCH$ERRMSG(%E$TH_PAR_ERR4);
         GOTO REM_RP;
         END;
/**/
              /* DATE IS THE SUBJECT TO BE CHANGED.  WHEN DATE IS
                 CHANGED, THEN KEY NEEDS TO BE CHANGED TOO.     */
/**/
    CASE (%DA);
         CALL CONCAT(MSG_BUF,'Old DATE is: ',RECORD_BUF.INFO.DATE_C);
         CALL M$WRITE (WRITE_NOTES);
DATE_DA:
         CALL XUR$GETCMD(INPUT_DATE,TOP$,VECTOR(PRMT1)) ALTRET(PAR_DATE);
IF TOP$ -> OUT$BLK.CODE = %QUIT_CMD THEN RETURN;
         DO CASE (TOP$->OUT$BLK.CODE);
              CASE (%DATE_X);
                   IF TOP$->OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
                      OUT$BLK.CODE = %DATE_ONE
                        THEN DO;
                     CALL FILL_FLD(TOP$->OUT$BLK.SUBLK$(0)->
                                  OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0),
                                  RECORD_BUF.INFO.DATE.MM) ALTRET (BAD_DATE);
                     CALL FILL_FLD(TOP$->OUT$BLK.SUBLK$(0)->
                                  OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(1),
                                  RECORD_BUF.INFO.DATE.DD) ALTRET (BAD_DATE);
                     IF TOP$->OUT$BLK.SUBLK$(0)->
                          OUT$BLK.SUBLK$(0)->OUT$BLK.NSUBLKS < 3
                          THEN DO;
                                CALL M$TIME(CUR_DATE);
                                RECORD_BUF.INFO.DATE.YY = DBF.YY;
                                END;
                          ELSE
                     CALL FILL_FLD(TOP$->OUT$BLK.SUBLK$(0)->
                                  OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(2),
                                  RECORD_BUF.INFO.DATE.YY) ALTRET (BAD_DATE);
                             END;
                        ELSE GOTO BAD_DATE;
         END;
         DBUF = RECORD_BUF.INFO.DATE;
         TBUF = RECORD_BUF.INFO.TIME;
         CALL M$TIME(GET_UTS);
         NEW_KEY = NKEY;
         CALL M$TIME(CUR_UTS);
         IF NKEY < TS_UTS
         THEN DO;
              CALL SCH$ERRMSG( %E$TH_OBSOLETE_EVENT );
              GOTO DATE_DA;
         END;
         DO NEVER;
PAR_DATE:
         CALL XUR$ERRPTR(,DCBNUM(M$UPDATE));
         CALL SCH$ERRMSG(%E$TH_PAR_ERR1);
         GOTO DATE_DA;
BAD_DATE:
         CALL SCH$ERRMSG(%E$TH_DATE);
         GOTO DATE_DA;
         END;
/**/
              /* TO CHANGE CONTENTS OF NOTES, TEMPORARY FILE WITH
                 NOTES WILL BE BUILT AND PROGRAM WILL CALL
                 THE STANDARD CP-6 LINE EDITOR EDIT.  THE NOTES
                 MAY BE MODIFIED USING ANY OF THE CAPABILITIES
                 OF EDIT.  THE END COMMAND TO EDIT WILL RETURN
                 CONTROL TO THE PROGRAM AND IT WILL REPLACE THE NOTES
                 WITH THE NEWLY EDITED NOTES.              */
/**/
    CASE (%NO);
         IF DCBADDR(DCBNUM(M$TEMP)) -> F$DCB.FCD#
              THEN CALL M$CLOSE(EDIT_CL);
         CALL M$OPEN(EDIT_OPEN) ALTRET(OPEN_ERR);
         KEY_TEMP.KEY = 1000;
         DO I = 0 TO RECORD_BUF.INFO.CNT - 1;
              MSG_BUF = RECORD_BUF.NOTES(I);
              CALL M$WRITE(WRT_TEMP);
              KEY_TEMP.KEY = KEY_TEMP.KEY + 1000;
         END;
         CALL M$CLOSE (EDIT_CL);
         MSG_BUF = '..EDITing *CAL_NOTES';
         CALL M$WRITE (WRITE_NOTES);
         CALL M$LINK(FPT_LINK) ALTRET(OPEN_ERR);
         IF DCBADDR(DCBNUM(M$TEMP)) -> F$DCB.FCD#
              THEN CALL M$CLOSE(EDIT_CL);
         CALL M$OPEN(EDIT_OP) ALTRET(OPEN_ERR);
         CALL M$PFIL (EDIT_PFIL);
         DO I = 0 TO 20;
              MSG_BUF = ' ';
              CALL M$READ (EDIT_READ) ALTRET(READ_END);
              RECORD_BUF.NOTES(I) = MSG_BUF;
         END;
         CALL M$READ (EDIT_READ) ALTRET(READ_END);
         CALL SCH$ERRMSG (%E$TH_EXCESS_NOTES);
/*E* ERROR: SCH-E$TH_EXCESS_NOTES
     MESSAGE: You can only have 21 line of NOTES. Excess lines are ignored.
*/
READ_END:
         RECORD_BUF.INFO.CNT = I;
/**/
    DO NEVER;
OPEN_ERR:
    CALL SCH$ERRMSG;
    CALL M$ERR;
    END;
    CALL M$CLOSE(EDIT_CLOSE);
END;
RETURN;
END EDIT_THIS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/**/
/*M* CMD$DISPLAY - TO DISPLAY SPECIFIED DATE OR RANGE OF DATES'
                   SCHEDULE.                                    */
/**/
CMD$DISPLAY:  PROC (PTR$);
/**/
/* PARAMS */
DCL PTR$ PTR;
/* INCLUDE FILES */
%INCLUDE CP_6;
%INCLUDE B$JIT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XUD_UTS_M;
  %XUD$UTS_ENTRIES;
  %XUD_UTS_EQU;
%INCLUDE CALENDAR_C1;
%INCLUDE CALENDAR_C2;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUF_ENTRY;
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL SCH$ERRMSG ENTRY(1);
DCL FILL_FLD ENTRY(2) ALTRET;
DCL DATE_TYPE ENTRY(4) ALTRET;
/**/
/* DCBS */
DCL M$CALENDAR DCB;
DCL   M$LO  DCB;
/**/
%FPT_READ (FPTN=RD_RECORD,
             DCB=M$CALENDAR,
             BUF=RECORD_BUF,
             KEY=KEY_VAL_ONE,
             KEYR=YES);
%F_FDS (NAME=FDS,DCB=M$LO);
%FPT_PRECORD (FPTN=CAL_POS,
              DCB=M$CALENDAR,
              KEY=KEY_VAL,
              KEYR=NO,
              KEYS=YES);
%FPT_TIME (FPTN=GET_DAY,
           SOURCE=LOCAL,
           DEST=UTS,
           DATE=HEADING.DATE,
           TIME=TIME_BEGIN,
           TSTAMP=DAY_BEGIN);
%FPT_TIME (FPTN=GET_DATE,
           SOURCE=CLOCK,
           DEST=LOCAL,
           DATE=HEADING.DATE,
           TIME=TIME_NOW,
           DAY=HEADING.DAY);
%FPT_TIME (FPTN=GET_DATE_ONE,
           SOURCE=UTS,
           DEST=LOCAL,
           DATE=HEADING.DATE,
           DAY=HEADING.DAY,
           TSTAMP=DAY_BEGIN);
%FPT_TIME (FPTN=GET_UTS,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=KEY_VAL.KEY);
%FPT_TIME (FPTN=GET_D,
           SOURCE=UTS,
           DEST=LOCAL,
           DAY=HEADING.DAY,
           DATE=HEADING.DATE,
           TSTAMP=KEY_VAL_ONE.KEY);
%FPT_WRITE (FPTN=WRITE_NOTES,
            BUF=MSG_BUF,
            DCB=M$LO);
/**/
/* VARIABLE DECLARES */
DCL OUTBUF CHAR(80);
DCL 1 KEY_VAL STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL 1 RECORD_BUF STATIC,
      2 INFO,
        3 DATE,
           4 MM            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 DD            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT('/'),
           4 YY           CHAR(2) INIT(' '),
         3 *              CHAR(2) INIT(' '),
         3 TIME,
           4 HR            CHAR(2) INIT(' '),
           4 *             CHAR(1) INIT(':'),
           4 MIN           CHAR(2) INIT(' '),
         3 *               CHAR(2) INIT(' '),
         3 PLACE           CHAR(80) INIT(' '),
         3 TOPIC           CHAR(80) INIT(' '),
         3 RP              CHAR(2) INIT('0'),
         3 CNT             UBIN BYTE INIT(0),
      2 NOTES(0:20)     CHAR(80) INIT(' ');
DCL R_B CHAR(80) STATIC;
DCL RBUF(0:79) REDEF R_B UBIN BYTE UNAL;
DCL 1 KEY_VAL_ONE STATIC,
      2 *          UBIN BYTE UNAL INIT(5),
      2 KEY        UBIN WORD UNAL,
      2 CNT        UBIN BYTE UNAL INIT(0);
DCL TEMP_VAL_ONE_KEY UBIN WORD ;
DCL DAY_BEGIN UBIN WORD STATIC;
DCL DAY_END UBIN WORD STATIC;
DCL DATE_BEGIN UBIN WORD STATIC;
DCL DATE_END UBIN WORD STATIC;
DCL 1 TIME_BEGIN STATIC,
      2 HR              CHAR(2) INIT('00'),
      2 *               CHAR(1) INIT(':'),
      2 MIN             CHAR(2) INIT('00');
DCL TIME_BEGIN_X REDEF TIME_BEGIN CHAR(5);
DCL TIME_NOW CHAR(5) STATIC;
DCL 1 HEADING STATIC,
      2 DAY             CHAR(3) INIT(' '),
      2 *               CHAR(1) INIT(' '),
      2 DATE,
        3 MM            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 DD            CHAR(2) INIT(' '),
        3 *             CHAR(1) INIT('/'),
        3 YY            CHAR(2) INIT(' ');
DCL FLAG UBIN BYTE STATIC INIT(0);
DCL MSG_BUF CHAR(80) STATIC INIT(' ');
DCL MBUF(0:79) REDEF MSG_BUF UBIN BYTE UNAL;
DCL NOTE_BUF CHAR(12);
DCL RP_NUM CHAR(2);
DCL PRNT UBIN;
DCL NUM UBIN WORD STATIC;
DCL NUM_ONE SBIN WORD STATIC;
DCL I UBIN BYTE STATIC INIT(0);
DCL TIMING UBIN;
DCL RS_FMT CHAR(0) CONSTANT INIT(
'*** %2.24.1P%80A%/    on %1P%2S%8A  %2P%10S%5A, %1P%2A days from today   at %2P%17S%80A%0S');
DCL NOTE_FMT CHAR(0) CONSTANT INIT(
'%12A%80A');
DCL MSG_FMT CHAR(0) CONSTANT INIT(
'%/>>> Schedule for %80A%/');
DCL FND_FMT CHAR(0) CONSTANT INIT(
'*** on %8A %2S%5A  at %2S%80A%0S');
DCL HD_FMT CHAR(0) CONSTANT INIT(
'%/>>> Schedule for %12A <<<%/');
DCL REC_FMT CHAR(0) CONSTANT INIT(
'*** %10S%5A   %82S%80A%/%9Xat %1P%17S%80A%0S');
DCL RH_FMT CHAR(0) CONSTANT INIT(
'%/>>> Reminders for %12A <<<%/');
/**/
/* MACRO INVOCATION */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(PTR$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS=BASED);
/**/
%EJECT;
/**/
/*  DISPLAY SPECIFIED DATE OR RANGE OF DATES' SCHEDULE.         */
/**/
  FDS.BUF_ = VECTOR(OUTBUF);
PRNT = 0;
FLAG = 0;
TIME_BEGIN_X='00:00';
DO CASE (OUT$BLK.CODE);
/**/
/*   DISPLAY SPECIFIED DATE'S SCHEDULE.                    */
/**/
    CASE (%DISPLAY_DATE);
         CALL DATE_TYPE (OUT$BLK.SUBLK$(0) ->OUT$BLK.SUBLK$(0),
                        TIME_BEGIN,DATE_BEGIN,DATE_END) ALTRET(BAD_DATE);
         IF OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
            OUT$BLK.CODE = %DATE_ZERO
              THEN TIMING = %UTS_CSEC_DAY#;
              ELSE TIMING = %UTS_CSEC_WEEK#;
         DAY_BEGIN = DATE_BEGIN;
         DO WHILE DAY_BEGIN <= DATE_END;
              CALL XUD$UTS_ADJUST (DAY_END,DAY_BEGIN,%UTS_CSEC_DAY#);
              CALL M$TIME (GET_DATE_ONE);
              CALL DISPLAY_IT ALTRET (RD_END);
              FLAG = 0;
              CALL XUD$UTS_ADJUST (DAY_BEGIN,DAY_BEGIN,TIMING);
         END;
/**/
/*  DISPLAY SPECIFIED NUMBER OF DAYS SCHEDULE.  */
/**/
    CASE (%DISPLAY_NUM);
         CALL M$TIME (GET_DATE);
         CALL M$TIME(GET_DAY);
         CALL XUD$UTS_ADJUST (DATE_BEGIN,DAY_BEGIN,%UTS_CSEC_DAY#);
         CALL CHARBIN (NUM,OUT$BLK.SUBLK$(0) ->OUT$SYM.TEXT);
         IF OUT$BLK.NSUBLKS = 2   AND
              OUT$BLK.SUBLK$(1) -> OUT$BLK.CODE = %WEEKS
             THEN CALL XUD$UTS_ADJUST (DATE_END,DATE_BEGIN,NUM*%UTS_CSEC_WEEK#);
              ELSE CALL XUD$UTS_ADJUST (DATE_END,DATE_BEGIN,(NUM-1)*%UTS_CSEC_DAY#);
         DAY_BEGIN = DATE_BEGIN;
         DO WHILE DAY_BEGIN <= DATE_END;
              CALL XUD$UTS_ADJUST (DAY_END,DAY_BEGIN,%UTS_CSEC_DAY#);
              CALL M$TIME (GET_DATE_ONE);
              CALL DISPLAY_IT ALTRET (RD_END);
              FLAG = 0;
              CALL XUD$UTS_ADJUST (DAY_BEGIN,DAY_BEGIN,%UTS_CSEC_DAY#);
         END;
/**/
/*  FIND AND DISPLAY SPECIFIED TOPIC'S INFORMATION.    */
/**/
    CASE (%DISPLAY_TOPIC);
              /* DETERMINE WHETHER THE USER WANTS CURRENT DATE'S
                 SCHEDULE OR FIND AND DISPLAY A TOPIC.          */
/**/
         IF OUT$BLK.SUBLK$(0) -> OUT$BLK.SUBLK$(0) -> OUT$SYM.COUNT = 0
              THEN DO;
         CALL M$TIME(GET_DATE);
         CALL M$TIME(GET_DAY);
         DAY_END = DAY_BEGIN + 1;
         DATE_END = DAY_BEGIN;
         DATE_BEGIN = DAY_BEGIN;
         CALL DISPLAY_IT ALTRET( RD_END );
         CALL XUD$UTS_ADJUST (DAY_END,DAY_BEGIN,%UTS_CSEC_DAY#);
         CALL M$TIME(GET_DATE);
         TIME_BEGIN_X=TIME_NOW;
         CALL M$TIME(GET_DAY);
         CALL DISPLAY_IT ALTRET (RD_END);
         FLAG = 0;
         KEY_VAL.KEY = DAY_END;
         CALL M$PRECORD(CAL_POS) ALTRET (READ_IT);
READ_IT:
         CALL M$READ(RD_RECORD) ALTRET(RD_END);
         CALL CHARBIN (NUM,RECORD_BUF.INFO.RP);
TEMP_VAL_ONE_KEY = KEY_VAL_ONE.KEY ;
         CALL XUD$UTS_DIFF_SEC (NUM_ONE,TEMP_VAL_ONE_KEY,DATE_BEGIN);
         NUM_ONE = NUM_ONE/86400;
         IF NUM_ONE <= NUM
              THEN DO;
                   IF FLAG = 0 THEN
                        CALL X$WRITE (FDS,VECTOR(RH_FMT),VECTOR(HEADING));
                   CALL BINCHAR(RP_NUM,NUM_ONE);
                   IF SUBSTR(RP_NUM,0,1) = '0'
                        THEN SUBSTR(RP_NUM,0,1) = ' ';
                   FLAG = 1;
                   PRNT = PRNT + 1;
                   CALL M$TIME (GET_D);
                   CALL X$WRITE (FDS,VECTOR(RS_FMT),VECTOR(RP_NUM),VECTOR(RECORD_BUF));
                   END;
         GOTO READ_IT;
              END;
              ELSE DO;
                   FLAG = 0;
         MSG_BUF = OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
         CALL M$TIME (GET_UTS);
         CALL M$PRECORD (CAL_POS) ALTRET(AGAIN);
AGAIN:
         CALL M$READ (RD_RECORD) ALTRET(TOPIC_END);
         R_B = RECORD_BUF.INFO.TOPIC;
         DO I = 0 TO OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT - 1;
              IF MBUF(I) >= 97  AND  MBUF(I) <= 122
                   THEN MBUF(I) = MBUF(I) - 32;
              IF RBUF(I) >= 97  AND  RBUF(I) <= 122
                   THEN RBUF(I) = RBUF(I) - 32;
              IF MBUF(I) ~= RBUF(I)
                   THEN GOTO AGAIN;
         END;
         IF SUBSTR(R_B,I) = ' '
              THEN DO;
                   FLAG = 1;
                   PRNT = PRNT + 1;
                   MSG_BUF = OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                   NOTE_BUF = 'Notes:';
                   CALL X$WRITE (FDS,VECTOR(MSG_FMT),VECTOR(MSG_BUF));
                   CALL X$WRITE (FDS,VECTOR(FND_FMT),VECTOR(RECORD_BUF));
                   DO I = 0 TO RECORD_BUF.INFO.CNT - 1;
                        MSG_BUF = RECORD_BUF.NOTES(I);
                        CALL X$WRITE (FDS,VECTOR(NOTE_FMT),VECTOR(NOTE_BUF),VECTOR(MSG_BUF));
                        NOTE_BUF = ' ';
                   END;
                   END;
         GOTO AGAIN;
              END;
END;          /*  END OF DO CASE                                */
/**/
RD_END: ;
         IF PRNT = 0
              THEN CALL SCH$ERRMSG (%E$TH_NO_DISPLAY);
         RETURN;
TOPIC_END:
         IF PRNT = 0
         THEN DO;
              CALL CONCAT (MSG_BUF,'Nothing to display for ',
                OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
              CALL M$WRITE (WRITE_NOTES);
         END;
         RETURN;
BAD_DATE:
         CALL SCH$ERRMSG (%E$TH_DATE);
         RETURN;
%EJECT;
/**/
/*  DISPLAY SPECIFIED DATE'S SCHEDULE.  */
/**/
DISPLAY_IT: PROC ALTRET;
/**/
KEY_VAL.KEY = DAY_BEGIN;
CALL M$PRECORD(CAL_POS) ALTRET(R_T);
R_T:
    CALL M$READ(RD_RECORD) ALTRET(END_FILE_READ);
    DO WHILE (KEY_VAL_ONE.KEY < DAY_END);
           IF FLAG = 0
              THEN CALL X$WRITE(FDS,VECTOR(HD_FMT),VECTOR(HEADING));
         FLAG=1;
           PRNT = PRNT + 1;
           CALL X$WRITE (FDS,VECTOR(REC_FMT),VECTOR(RECORD_BUF));
           NOTE_BUF = 'Notes:';
           IF DATE_BEGIN = DATE_END
              THEN
              DO I = 0 TO RECORD_BUF.INFO.CNT - 1;
                   MSG_BUF = RECORD_BUF.NOTES(I);
                   CALL X$WRITE (FDS,VECTOR(NOTE_FMT),VECTOR(NOTE_BUF),VECTOR(MSG_BUF));
                   NOTE_BUF = ' ';
              END;
         CALL M$READ (RD_RECORD) ALTRET(END_FILE_READ);
    END;
     RETURN;
END_FILE_READ:
     ALTRETURN;
END DISPLAY_IT;
END CMD$DISPLAY;
%EOD;
/*M* SCH$ERRMSG - ERROR MESSAGE ROUTINE FOR CALENDAR */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
SCH$ERRMSG:  PROC(CODE);
/**/
/* PARAMS */
DCL CODE UBIN WORD;
/**/
/* INCLUDE FILES */
%INCLUDE CP_6;
/**/
/* VARIABLES */
DCL ERRDCB UBIN WORD STATIC;
DCL 1 SCH_ERRCODE STATIC ALIGNED,
      2 FCG BIT(18),
      2 MON BIT(1),
      2 CODE UBIN(14) UNAL,
      2 SEV UBIN(3) UNAL;
/**/
/* MACROS */
%B$TCB;
%B$ALT;
/**/
/* ENTRY DCLS */
DCL XUR$ERRMSG ENTRY(7) ALTRET;
/**/
/* SYMREFS */
DCL B$TCB$ PTR SYMREF;
%EJECT;
    SCH_ERRCODE ='230310000000'O;
    IF ADDR(CODE) = ADDR(NIL)
         THEN SCH_ERRCODE = B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
         ELSE SCH_ERRCODE.CODE =  CODE;
IF ADDR(CODE) = ADDR(NIL)
     THEN ERRDCB = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
     ELSE ERRDCB = 0;
    CALL XUR$ERRMSG(SCH_ERRCODE,ERRDCB);
    RETURN;
END SCH$ERRMSG;
