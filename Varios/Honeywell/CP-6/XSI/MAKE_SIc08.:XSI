/*M*    make_main:c    --    MAKE main execution driver          */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include   "MAKE_Cc14"
FILE *Makefile = 0;
 
extern char *alloc_text();
static char   blanks[40] = "                                       ";
 
char    **NameList[2]    =  {0, 0};
int       NameSize[2]    =  {0, 0};
int       NameLen [2]    =  {0, 0};
char     *GenerateOption =  0;
char     *Component = 0;
char     *ListerFid = 0;
 
/*D*    NAME:       main(int argn, char **argv)
        PURPOSE:    To initiate and control the make process.
        DESCRIPTION:
           The MAKE process contains the following steps:
 
           1. Analyze the command line options.
 
              This is controlled by the function "do_options" which
              is in this file.  It checks each command line option
              and determines the option flag to set and reports
              inconsistent option combinations.
 
           2. If the verbose option was specified, then print the
              current version of MAKE.
 
           3. Initialize all of the default macros.  This step
              is performed by the make_sym:c module.  This module
              checks for over-riding command line values as well
              as IBEX variables which may be replacing the defaults.
 
           4. Initialize the fake targets.  These fake targets include
              ".PHONY", ".ONLINE", ".SILENT", ".PHONY", ".PRECIOUS",
              and ".DEFAULT".
 
           5. If a Makefile was specified on the command line, it is
              now read via the "ReadMake" function.  After the file
              has been read, it is immediately closed.
 
           6. The default rules are now added via the "complete_rules"
              function.  This function checks for the "-r" option and
              only adds the ".." rules if this option was not
              specified.
 
           7. The "setup_srch_lists" function is used to setup the
              default search lists.
 
           8. The function "mark_old_changed" is used to indicate the
              targets for which the "-o" or "-c" option was specified.
 
           9. If the "-p" option was specified, all of the macro
              definitions are displayed followed by all of the
              dependencies.
 
          10. If the "-z" option was specified, the hash table
              statistics are displayed.
 
          11. If a targets were specified on the command line, they
              are now converted to references to the appropriate
              sym_target entries; otherwise, if the makefile did
              not contain a target, an error is reported.
 
          12. For every target specified, the function "derive" is
              executed to build the action list that will be used
              to actually build the target.
 
          13. If no errors have occured, the function "build" is used
              to build the requested target.
 
          14. If the "-z" or "-m" option was specified, the output
              associated with these options is generated by calling
              the "print_hash_statistics" and "memory_usage"
              functions.
 
          15. Finally, we exit setting the STEPCC to a number between
              0 and 15 which indicates the number of targets
              remaining to be built.
 
*/
 
main(argn, argv)
  int         argn;
  char        **argv;
{
  int   i;
  int   w_p = 0, x_w = 18;
  struct sym_macro *mc;
  char             *Makeflgs = 0;
 
#ifdef RU
  if (argn == 0) goto building;
#endif
  x_w += strlen(argv[0]);
  i = (30>x_w)? x_w : 25;
  blanks[ i ] = 0;
  MakeTargets = (struct sym_target **) argv + 1;
  if (do_options(argn, argv, 0))
     exit(4);
  mc = lookup_sym_macro("MAKEFLGS", 8, 6);
  if (mc && mc->mc_deflen)  {
     Makeflgs = mc->mc_def;
     if (do_options(2, &(mc->mc_def)-1, 1))
        exit(4);
     }
 
  Silent = options['s'];
  if (options['v']) {
     char  version[12];
     extern char B_VERSION[6];
     memcpy(version, B_VERSION+1, B_VERSION[0]);
     version[ B_VERSION[0] ] = 0;
     printf("CP-6 MAKE %s\n", version);
     }
  init_macros();
  setup_pseudo_targets();
  if (Makefile)
     ReadMake(options['p'],options['w'],options['v']);
  fclose(Makefile);
  if (mc && Makeflgs != mc->mc_def && mc->mc_deflen)
     if (do_options(2, &(mc->mc_def)-1, 2))
        exit(4);
  complete_rules(options['r']);
  setup_srch_lists();
  mark_old_changed();
  if (options['p'])
     dump_macros(options['w']);
  if (options['p'])
     dump_dependancies(options['w']);
  if (options['z']) {
     dump_hash_table(&ftype_hash_table,"File Types");
     dump_hash_table(&owner_hash_table,"Target Owners");
     dump_hash_table(&macro_hash_table,"Macros");
     dump_hash_table(&target_hash_table,"Targets");
     }
  if (MakeLabel)  {
     for ( i=0 ; i<MakeLabel ; i++ )  {
        char  *lbl = argv[1+i];
        MakeTarget = lookup_sym_target(lbl,strlen(lbl),2);
        if (!MakeTarget)
           error("### Makefile does not contain target: \"%s\"\n",lbl);
        else MakeTargets[i] = MakeTarget;
        }
     if (Errors) exit(4);
     }
  else {
     if (!MakeTarget)  {
        if (Makefile)
           error("###  Makefile does not contain a target!");
        else error("### A target or Makefile must be specified!\n");
        exit(4);
        }
     MakeTargets[0] = MakeTarget;
     MakeLabel++;
     }
  if (options['v']) {
     if (MakeLabel > 1) {
        printf("### %s: Targets are:",argv[0]), w_p = x_w;
        for ( i=0 ; i<MakeLabel ; i++ )   {
           struct sym_target *tg = MakeTargets[i];
           if ( (w_p + 1 + tg->tg_len) > options['w'])
              printf("\n###                  %s",blanks);
           printf(" %s",tg->tg_text), w_p += 1+tg->tg_len;
           }
        printf("\n");
        }
     else printf("### %s: Target is: %s\n",argv[0],MakeTargets[0]->tg_text);
     }
 
  for ( i=0 ; i<MakeLabel ; i++ )
     derive(MakeTargets[i],options['w'],options['d'],options['v']);
 
  if (options['a'])
     dump_actions(options['w'], options['v']);
 
  if (GenerateOption) {
     extern int errno;
     FILE *af = fopen(GenerateOption, "w");
     if (!af) {
        error("Can't open -g file %s: %s\n", GenerateOption,
              strerror(errno) );
        }
     else generate_action_file(af);
     exit( (af)? 0 : 8 );
     }
  if (Component) {
     extern int errno;
     FILE      *af = fopen(ListerFid, "w");
     if (af)  {
        generate_list_file(af, Component);
        fclose(af);
        }
     else error("Can't open -l file %s: %s\n", ListerFid, strerror(errno));
     }
 
  if (!Errors)
building:
     i = build(options['n'], options['w'], options['v'], options['t'], options['q']);
  else printf("\n\n**\n** Make stopped due to errors.\n**\n"), i=8;
 
  if (options['z'])
     print_hash_stats();
  if (options['m'])
     memory_usage();
 
  exit((i<15)? i : 15);
}
 
 
 
/*D*    NAME:          do_options(argn,argv)
        PURPOSE:       To process the user specified command line
                       options.
*/
 
const char options_message[] = {
     "\n%s Options:\n"
     " -a     dump actions\n"
     " -c     Changed: treat target mod time as now\n"
     " -d     Makefile debug mode\n"
     " -e     Send EMAIL for failures\n"
     " -ffid  specify Makefile name\n"
     " -gfid  create standard file containing actions\n"
     " -iacct specify search account for :include\n"
     " -j511  Limit batch jobs to 511 (for example)\n"
     " -k     Use \"compressed\" file names for DO/LO\n"
     " -m     Memory usage summary\n"
     " -n     No-Execute mode: display build commands\n"
     " -o     Old: treat target as up to date\n"
     " -p     List Makefile, Macros and Dependencies\n"
     " -q     Query. Set stepcc to 0 if goal is uptodate\n"
     " -r     Rules: don't include built-in rules\n"
     " -s     Silent: don't echo @ commands\n"
     " -t     Touch: change target files modify times\n"
     " -u     Update packet restrict to DONE files\n"
     " -v     Verbose: print version & misc. information\n"
     " -w80   Set output width to 80 (for example)\n"
     " -z     Print symbol table information\n"
     "\n"
     };
 
 
char *cmdline_str();
 
static const char endc[2] = {0, 0};
 
 
do_options(argn, argv, makeopts)
  char     *argv[];
  int       argn;
{
  int          i;
  char        *opt, *cp, *sp;
  char       **nl;
  int          w, ch;
 
  if (makeopts == 0) {
     options['w'] = 80;   /****  Default output width   ****/
     options['j'] = 511;  /****  Default max batch jobs ****/
     }
  for (i = 1 ; i<argn ; i++) {
 
     opt = argv[i];
     if (makeopts) {
        opt--;
        goto st_mkopts;
        }
     if (*opt == '-')
     while (*++opt)   {
        int   c = tolower(*opt);
        switch (c) {
        case ' ':
st_mkopts:
           while (1)   {
              while (*(opt+1) == ' ') opt++;
              if (!*(opt+1)) break;
              c = *++opt;
              if (c == '-') {
                 break;
                 }
              if (c == '\'')
                 cmdline_macro(&opt, argv, &i, argn, makeopts);
              else {
                 char *s = strchr(opt, ' '), *t = strchr(opt, '=');
                 if (t && (!s || s>t))   {
                    char len = s ? s-t : strlen(opt);
                    char *buf = malloc(len+1);
                    if (!buf)
                       crash("Out of Memory: do_options");
                    memcpy(buf, opt, len+1);
                    buf[len] = 0;
                    cmdline_macro(&buf, argv, &i, argn, makeopts);
                    free(buf);
                    }
                 else error("Illegal MAKEFLGS target specification\n");
                 }
              }
           break;
        case 'a':
        case 'd':
        case 'e':
        case 'k':
        case 'm':
        case 'n':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'z':
           options[c]++;
           break;
 
        case 'c':      /*  Its changed inspite of mod times   */
        case 'o':      /*  Its old (up to date)               */
           w = (c == 'c')? 1 : 0;
           if (NameLen[w] <= NameSize[w])   {
              nl = (char **) realloc(NameList[w], NameSize[w]+10);
              if (!nl) crash("Out of Memory: options\n");
              NameList[w]  = nl;
              NameSize[w] += 10;
              }
           else nl = NameList[w];
           nl[ NameLen[w]++ ] = cmdline_str(&opt, argv, &i, argn, makeopts);
           break;
 
        case 'f':
           if (makeopts & 2)  {
              error("### MAKEFLGS variable cannot specify -%c\n", c);
              return Errors;
              }
           if (MakeFid)
              error("### %s - Illegal duplicate -f options\n", argv[0]);
           MakeFid = cmdline_str( &opt, argv, &i, argn, makeopts);
           break;
        case 'g':      /* Generate actions file      */
           if (GenerateOption)
              error("### %s - Illegal duplicate -g option\n",argv[0]);
           GenerateOption = cmdline_str( &opt, argv, &i, argn, makeopts);
           break;
        case 'i':      /* search list specification  */
           if (SrchNum >= MAX_SRCH)
              error("### %s - too many search accounts\n", argv[0]);
 
           SrchList[SrchNum] = "\001.";
           if (!makeopts) {
              if ( *(opt+1) )   {
                 cp = opt+1;
                 opt = (char *) endc;
                 }
              else cp = argv[++i];
              w = strlen(cp);
              sp = alloc_text(2+w, cp);
              memcpy( sp+1, cp, w+1 );
              }
           else  {  /* scanning MAKEFLGS... */
              while (' ' == *++opt);
              cp = strchr(opt, ' ');
              w = cp ? cp - opt : strlen(opt);
              sp = alloc_text(2 + w, opt);
              memcpy(sp+1, opt, w);
              opt[w+1] = 0;
              opt += w - 1;
              }
           sp[0] = (strchr(cp, '?')) ? 2 : (strchr(cp, '.')) ? 3 : 1;
           SrchList[SrchNum-1] = sp;
           SrchNum++;
           break;
 
 
 
        case 'l':   /* generate a "fake" lister file    */
           if (Component)
              error("### %s - duplicate -l option\n", argv[0]);
           Component = cmdline_str(&opt, argv, &i, argn, makeopts);
           if (!Component)   {
              error("### -l option requires component[,fid]\n");
              break;
              }
 
           if (cp = strchr(Component, ','))    {
              *cp = 0;
              ListerFid = cp + 1;
              }
           else ListerFid = ":LIST";
           break;
 
 
        case 'j':
        case 'w':
           options[ch=c] = (c=='w')? 80 : 511;
           w = 0, c = *(opt+1);
           while (c >= '0' && c <= '9') w = w*10+c-'0', c=*(++opt+1);
           if (ch=='j')   {
              MaxJobs = options[ch] = w;
              }
           else {
              if (w > 30 && w < 255) options[ch] = w;
           }
           break;
 
        default:
           error("\"-%c\" is not an option.\n",c);
           break;
        }
     }
     else if ('\'' == *opt || strchr(opt, '='))  {
        cmdline_macro(&opt, argv, &i, argn, makeopts);
        }
     else {   /* Better be a label */
        argv[++MakeLabel] = opt;
        }
     }  /*  End of for( i=0; ... ) ... loop       */
 
  UpdateRst = options['u'];
  if (Errors == 0 && MakeFid && !Makefile && makeopts < 2)   {
     Makefile = fopen(MakeFid,"r");
     file_table[0].fid   = MakeFid;
     file_table[0].recno = 0;
     file_table[0].strm  = Makefile;
     file_table[0].ifdepth = 0;
     file_table[0].flags   = 0;
     if (!Makefile)
        error("### %s - cannot open file %s: %s\n",argv[0],MakeFid,strerror(errno));
     return Errors;
     }
 
  if (Errors && !makeopts)
     printf(options_message, argv[0]);
  return Errors;
}
 
 
cmdline_macro(opt_p, argv, i_p, argn, makeopts)
  char   **opt_p;
  char   **argv;
  int     *i_p;
  int      argn;
{
  char  *opt  = *opt_p;
 
  char repbuf[256];
  char macbuf[64];
  char *str;
  char  c;
  int   ins = 0, nl = 0, quoted = '\'' == *opt;
  struct sym_macro *macsym;
  /*  First get the name of the macro */
  if (!quoted) opt--;
  while ( (c = *++opt) && c != ' ' && c != '=' && c != '\'')
     if (ins < 63) macbuf[nl++] = c;
 
  macbuf[nl] = 0;
  while (c == ' ') c = *++opt;
  if (!makeopts && quoted && !c) opt = argv[++*i_p];
  if (!opt || *opt != '=') {
     error("Illegal command line Macro definition!\n");
     *opt_p = opt;
     return;
     }
  /* Now grab the replacement text for the macro  */
  while ( (c = *++opt) != '\'' || *(opt+1) == '\'')  {
     if (!c)  {
        if (!quoted) break;
        if (makeopts)  {
           error("Illegal MAKEFLGS macro definition\n");
           break;
           }
        if (ins<255) repbuf[ins++] = ' ';
        opt = argv[++*i_p];
        if (!opt)   {
           error("Illegal command line macro definition\n");
           break;
           }
        c = *opt;
        }
     if (ins < 255) repbuf[ins++] = c;
     if (c == '\'') opt++;
     }
  /*  Finally, let's define this macro!           */
  repbuf[ins] = 0;
  macsym = lookup_sym_macro(macbuf, nl, 1);
  if (!macsym) crash("Out of Memory: Options\n");
  macsym->mc_def = str = alloc_text(ins+1, repbuf);
  if (!str) crash("Out of Memory: Options\n");
  macsym->mc_deflen  = ins;
  macsym->mc_cmdline = 1;
  *opt_p = opt;
}
 
 
char *
cmdline_str(opt_p, argv, i_p, argn, makeopts)
  char **opt_p;
  char **argv;
  int   *i_p;
{
  char *opt = *opt_p;
  char *rs;
 
  if (!makeopts) {  /* scanning command line */
     if ( *(opt+1) )   {  /* stuff follows option letter   */
        rs = opt+1;
        *opt_p = (char *) endc;
        }
     else rs = argv[++*i_p];
     }
  else  {           /* scanning MAKEFLGS    */
     char *fin;
     int   len;
 
     while (*++opt == ' ');
     fin = strchr(opt, ' ');
     len = fin  ?  fin - opt : strlen(opt);
     rs  = alloc_text(len+1, opt);
     rs[len] = 0;
 
     *opt_p = opt + len - 1;
     }
  return rs;
}
 
 
/*D*    NAME:          mark_old_changed
        PURPOSE:       To flag targets that are old or changed.
*/
 
mark_old_changed()
{
  int         i;
  char      **nl;
 
  if (NameLen[0] > 0)  {
     /**   Mark all -o targets    **/
     nl = NameList[0];
     for ( i=0 ; i<NameLen[0] ; i++ ) {
        struct sym_target *tg = lookup_sym_target(*nl, strlen(*nl),2);
        if (!tg) crash("Out of Memory: mark old/changed targets\n");
        tg->tg_old |= 1;
        nl++;
        }
     free(nl);
     NameLen[0] = NameSize[0] = 0;
     }
 
  if (NameLen[1] > 0)  {
     /**   Mark all -c targets    **/
     nl = NameList[1];
     for ( i=0 ; i<NameLen[1] ; i++ ) {
        struct sym_target *tg = lookup_sym_target(*nl, strlen(*nl),2);
        if (!tg) crash("Out of Memory: mark old/changed targets\n");
        tg->tg_new |= 1;
        nl++;
        }
     free(nl);
     NameLen[1] = NameSize[1] = 0;
     }
 
  return;
}
 
 
 
 
/*F*    NAME:       memory_usage()
        PURPOSE:    To summarize main memory usage.
        DESCRIPTION:
           This function displays the main memory usage when the
           "-m" option was used.
*/
 
memory_usage()   {
  unsigned mem_heap =  SEGSIZE(MakeTarget);
  unsigned mem_auto =  SEGSIZE(&mem_heap);
  unsigned total;
 
  printf(" *** Memory Usage ***\n\n");
  if (mem_targets[0])
     printf(" %d(%d) targets of %d(%d)\n",
            mem_targets[1], mem_targets[1]/sizeof(struct sym_target),
            mem_targets[0], mem_targets[0]/sizeof(struct sym_target));
  if (mem_strings[0])
     printf(" %d strings of %d\n", mem_strings[1], mem_strings[0]);
  if (mem_macros[0])
     printf(" %d(%d) macros  of %d(%d)\n",
        mem_macros[1], mem_macros[1]/sizeof(struct sym_macro),
        mem_macros[0], mem_macros[0]/sizeof(struct sym_macro) );
  if (mem_ftypes[0])
     printf(" %d(%d) file types of %d(%d)\n",
        mem_ftypes[1], mem_ftypes[1]/sizeof(struct sym_ftype),
        mem_ftypes[0], mem_ftypes[0]/sizeof(struct sym_ftype)   );
  if (mem_macstr)
     printf(" %d macro strings\n", mem_macstr);
  if (mem_commands)
     printf(" %d command strings\n", mem_commands);
  if (mem_comrules)
     printf(" %d(%d) rule command lists\n", mem_comrules, mem_comrules/sizeof(struct command_list));
  if (mem_rulelist)
     printf(" %d(%d) rule lists\n", mem_rulelist, mem_rulelist/sizeof(struct target_rule));
  if (mem_dependlist[0])
     printf(" %d(%d) dependency lists\n",
        mem_dependlist[0], mem_dependlist[1]);
  if (mem_actionlist[0])
     printf(" %d(%d) actions of %d(%d)\n",
        mem_actionlist[1], mem_actionlist[1]/sizeof(struct target_action),
        mem_actionlist[0], mem_actionlist[0]/sizeof(struct target_action));
  if (mem_acctlist[0])
     printf(" %d(%d) account lists\n", mem_acctlist[0], mem_acctlist[1]);
  if (mem_ruleptrs[0])
     printf(" %d(%d) filetype rule list\n", mem_ruleptrs[0], mem_ruleptrs[1]);
 
  total = mem_ftypes[0] + mem_strings[0] + mem_targets[0] +
          mem_macros[0] + mem_macstr     + mem_commands   +
          mem_comrules  + mem_rulelist   + mem_dependlist[0] +
          mem_actionlist[0]              + mem_acctlist[0]+
          mem_ruleptrs[0];
 
  printf(" ===========================\n %d total accounted\n",total);
  printf(" ===========================\n");
  printf(" %d(%d) auto size\n %d(%d) heap size\n",
        mem_auto, (mem_auto+4095)/4096,
        mem_heap, (mem_heap+4088)/4096);
}
 
#ifdef RU
MAIN(argn, argv) {
  freopen("ME","r",stdin);
  freopen("ME","a",stdout);
  main(argn, argv);
}
#endif
 
