/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
RQ: PROC MAIN;
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
%INCLUDE RQ_C3;
%LIST;
%INCLUDE RQ_C1;
%EJECT;
%PLIST;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%F$DCB;
 
%B$TCB;
%B$ALT;
 
%SUB NO = "'0'B";
%SUB YES = "'1'B";
%EJECT;
/***********************/
/*                     */
/*    JOBSTATS FPTs    */
/*                     */
/***********************/
%FPT_JOBSTATS (FPTN=FPT_ISRCH,
               CRITERIA=VLP_CRITERIA,
               OUTPUT=NO,
               ORDER=SRCH);
%VLP_CRITERIA (FPTN=VLP_CRITERIA);
%VLR_JOBSTATS_ISRCH
              (FPTN=VLR_ISRCH,
               STCLASS=BASED);
%VLR_JOBSTATS_ISRCH_RES
              (FPTN=VLR_ISRCH_RES,
               NRES=1000,
               STCLASS=BASED);
%VLR_JOBSTATS_ISRCH_SN
              (FPTN=VLR_ISRCH_SN,
               NSN=1000,
               STCLASS=BASED);
%VLA_JOBSTATS_ISRCH
              (FPTN=IQ,
               STCLASS=BASED);
%FPT_JOBSTATS (FPTN=FPT_OSRCH,
               CRITERIA=VLP_CRITERIA,
               OUTPUT=YES,
               ORDER=SRCH);
%VLR_JOBSTATS_OSRCH
              (FPTN=VLR_OSRCH,
               STCLASS=BASED);
%VLA_JOBSTATS_OSRCH
              (FPTN=OQ,
               STCLASS=BASED);
%EJECT;
/*******************/
/*                 */
/*    M$LO FPTs    */
/*                 */
/*******************/
 
%FPT_OPEN     (FPTN=OPN_LO_ASIS,
               DCB=M$LO,
               FUN=CREATE);
%FPT_OPEN     (FPTN=OPEN_LO,
               ACCT=LO_ACCT,
               DCB=M$LO,
               FUN=CREATE,
               NAME=LO_NAME,
               PASS=LO_PASS,
               SN=LO_SN,
               WSN=LO_WSN);
%FPT_WRITE    (FPTN=WRITE_LO,
               BUF=LO_BUF,
               DCB=M$LO);
%FPT_CLOSE    (FPTN=CLOSE_LO,
               DCB=M$LO,
               DISP=SAVE);
%FPT_DEVICE   (FPTN=WRITE_LO_PAGE,
               DCB=M$LO,
               PAGE=YES);
%EJECT;
/*******************/
/*                 */
/*    M$SI FPTs    */
/*                 */
/*******************/
 
%FPT_OPEN     (FPTN=OPN_SI,
               ASN=DEVICE,
               DCB=M$SI,
               FUN=IN,
               RES='ME  ');
%FPT_OPEN     (FPTN=OPN_SI_ASIS,
               ACCT=SI_ACCT,
               DCB=M$SI,
               NAME=SI_NAME,
               PASS=SI_PASS,
               SN=SI_SN,
               WSN=SI_WSN);
%VLP_ACCT     (FPTN=SI_ACCT);
%VLP_NAME     (FPTN=SI_NAME);
%VLP_PASS     (FPTN=SI_PASS);
%VLP_SN       (FPTN=SI_SN);
%VLP_WSN      (FPTN=SI_WSN);
%FPT_READ     (FPTN=REED_SI,
               BUF=SI_BUF,
               DCB=M$SI);
%FPT_CLOSE    (FPTN=CLOSE_SI,
               DCB=M$SI,
               DISP=SAVE);
%EJECT;
/****************************/
/*                          */
/*    MISCELLANEOUS FPTs    */
/*                          */
/****************************/
 
%FPT_TIME     (FPTN=CONV_UTS,
               DATE=GREG_DATE,
               DEST=LOCAL,
               SOURCE=UTS,
               TIME=HHMMSSSS,
               TSTAMP=UTS);
 
%FPT_TIME     (FPTN=GET_UTS,
               DATE=GREG_DATE,
               DEST=UTS,
               SOURCE=ANS,
               TIME=HHMMSSSS,
               TSTAMP=UTS);
 
%FPT_TIME     (FPTN=GET_TIME_DATE,
               DATE=GREG_DATE,
               DEST=ANS,
               SOURCE=CLOCK,
               TIME=HHMMSSSS,
               TSTAMP=UTS);
 
%FPT_ERRMSG   (FPTN=ERRMSG,
               DCB=NIL,
               BUF=ERR_MESG,
               CODE=ERROR_CODE,
               OUTDCB1=M$DO);
 
%FPT_ERRMSG   (FPTN=GETHELP,
               BUF=ERR_MESG,
               CODE=HELPCODE,
               INCLCODE=NO,
               FILEACCT=HELP_ACCT,
               FILENAME=HELP_NAME,
               OUTDCB1=M$LO,
               RESULTS=HELP_RESULTS);
%VLP_ACCT     (FPTN=HELP_ACCT);
%VLP_NAME     (FPTN=HELP_NAME,
               NAME='RQ',
               LEN=6);
%VLR_ERRMSG   (FPTN=HELP_RESULTS);
 
%FPT_WAIT     (FPTN=SLEEP);
 
%FPT_WRITE    (FPTN=WRITE_DO,
               BUF=LO_BUF,
               DCB=M$DO);
 
%FPT_PRIV     (PRIV=%PR_DISPJOB#,
               AUTH=YES);
 
 
%FPT_CORRES   (FPTN=DOVSLO,
               DCB1=M$DO,
               DCB2=M$LO);
 
%FPT_FID      (FPTN=FID_SI,
               ACCT=SI_ACCT,
               ASN=OPN_SI_ASIS.V.ASN#,
               NAME=SI_NAME,
               PASS=SI_PASS,
               RES=OPN_SI_ASIS.V.RES#,
               RESULTS=FID_VLR,
               SN=SI_SN,
               TEXTFID=FID_STRING,
               WSN=SI_WSN);
%VLR_FID      (FPTN=FID_VLR);
%FPT_FID      (FPTN=FID_LO,
               ACCT=LO_ACCT,
               ASN=OPEN_LO.V.ASN#,
               NAME=LO_NAME,
               PASS=LO_PASS,
               RES=OPEN_LO.V.RES#,
               RESULTS=FID_VLR,
               SN=LO_SN,
               TEXTFID=FID_STRING,
               WSN=LO_WSN);
%VLP_ACCT     (FPTN=LO_ACCT);
%VLP_NAME     (FPTN=LO_NAME);
%VLP_PASS     (FPTN=LO_PASS);
%VLP_SN       (FPTN=LO_SN);
%VLP_WSN      (FPTN=LO_WSN);
%FPT_GDS      (FPTN=GDS);
%VLP_VECTOR   (FPTN=GDS_RESULTS_);
%VLP_VECTOR   (FPTN=GDS_RESLIST_);
%VLP_VECTOR   (FPTN=GDS_SNLIST_);
%VLP_VECTOR   (FPTN=OUT_AHEAD_);
%VLP_ERRCODE  (FPTN=ERROR_CODE,
               STCLASS=STATIC);
%FPT_TRMATTR  (FPTN=GET_TRM_ATTR,
               TRMATTR=TRMATTR_VLP);
%VLP_TRMATTR  (FPTN=TRMATTR_VLP);
%EJECT;
/**********************/
/*                    */
/*    PARSER STUFF    */
/*                    */
/**********************/
 
%P_PCB     (NAME=PARSE_IT,
            N#="LENGTHC(SI_BUF)",
            R=RQ_NODES,
            T=SI_BUF,
            W=WORK,
            WSZ="SIZEW(WORK)");
%PARSE$OUT (NAME=P_OUT,
            STCLASS="BASED(BLK1$)");
%PARSE$SYM (NAME=P_SYM,
            STCLASS="BASED(BLK2$)");
DCL RQ_NODES                 UBIN      SYMREF;
DCL WORK                     CHAR(1340) STATIC ALIGNED;
DCL X$PARSE                  ENTRY(1)  ALTRET;
%EJECT;
/********************\
*                    *
*     IBEX STUFF     *
*                    *
\********************/
 
%FPT_LINK (FPTN=FPT_LINK,
           ACCT=LINK_ACCT,
           CMD=LINK_CMND,
           NAME=LINK_NAME,
           PASS=LINK_PASS);
        /* PSID=LINK_PSID.SN#(1)); */
%FPT_YC   (FPTN=FPT_YC,
           CMD=LINK_CMD.TEXT);
%VLP_ACCT (FPTN=LINK_ACCT,
           ACCT='        ');
%VLP_NAME (FPTN=LINK_NAME,
           LEN=31,
           NAME='                               ');
%VLP_PASS (FPTN=LINK_PASS,
           PASS='        ');
%VLP_SN   (FPTN=LINK_PSID,
           N=2);
%FPT_FID  (FPTN=FID_LINK,
           ACCT=LINK_ACCT,
           ASN=OPN_SI_ASIS.V.ASN#,
           NAME=LINK_NAME,
           PASS=LINK_PASS,
           RES=OPN_SI_ASIS.V.RES#,
           RESULTS=FID_VLR,
           SN=LINK_PSID,
           TEXTFID=FID_STRING,
           WSN=LINK_WSN);
%VLP_WSN  (FPTN=LINK_WSN);
 
DCL 1 LINK_CMD  STATIC,
      2 L#                   UBIN(9)   UNAL,
      2 TEXT                 CHAR(255) UNAL;
DCL LINK_CMND REDEF LINK_CMD CHAR(256);
%EJECT;
/**************/
/*            */
/*    DCBs    */
/*            */
/**************/
 
DCL M$DO                     DCB;
DCL F$HELP                   DCB;
DCL M$LO                     DCB;
DCL M$ME                     DCB;
DCL M$SI                     DCB;
 
 
/******************/
/*                */
/*    POINTERS    */
/*                */
/******************/
 
DCL B$JIT$  SYMREF           PTR;
DCL B$TCB$  SYMREF           PTR;
DCL BLK1$                    PTR;
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL BLK5$                    PTR;
DCL F$HELP$                  PTR;
DCL M$LO$                    PTR       SYMREF;
DCL M$SI$                    PTR       SYMREF;
DCL Q$                       PTR;
DCL TBL$                     PTR;
DCL TBL_END$                 PTR;
 
DCL L$CORRES                 ENTRY(3);
DCL L$INIT                   ENTRY(4)  ALTRET;
DCL L$MONERR                 ENTRY;
DCL L$READ                   ENTRY(3)  ALTRET;
DCL L$WRITE                  ENTRY(6);
%EJECT;
DCL FLD#                     SBIN      STATIC;
DCL HELPCNT                  UBIN      STATIC;
%VLP_ERRCODE (FPTN=HELPCODE,
              STCLASS=STATIC);
DCL HELPNUM REDEF HELPCODE   UBIN;
DCL HELP_TYPE                SBIN      STATIC;
DCL NCBS                     SBIN      STATIC;
%EJECT;
DCL ACCT_TALLY(0:0)          UBIN      BASED(OUT_AHEAD_.PTR$);
DCL ACT_FLD#                 SBIN;
DCL BEG                      UBIN      STATIC;
DCL BROKEN                   UBIN      SYMREF;
DCL CMD#                     UBIN      STATIC INIT(DISPLAY_CMD#);
DCL CMD_DISP                 UBIN      STATIC;
DCL CMD_LEN                  SBIN      STATIC;
DCL EVERY_CNT                SBIN      STATIC INIT(-1);
DCL FIELD_BEG(0:MAX_NUM_FIELDS) UBIN   STATIC INIT(0*0);
DCL HOUR                     UBIN      STATIC;
DCL H                        UBIN;
DCL H1                       UBIN;
DCL I                        UBIN;
DCL INTERATIONS              SBIN;
DCL INTERVAL                 UBIN;
DCL J                        UBIN;
DCL J2                       UBIN;
DCL K                        UBIN;
DCL K2                       UBIN;
DCL LEN                      UBIN      STATIC INIT(0);
DCL LINE_CNT                 UBIN      STATIC INIT(99);
DCL LISTED                   UBIN      STATIC;
DCL LO_INDX                  UBIN      STATIC INIT(0);
DCL LO_LEN                   UBIN      STATIC INIT(LENGTHC(LO_BUF));
DCL LO_WIDTH                 UBIN      SYMREF;
DCL MAX_TBL_ENTRIES          UBIN;
DCL MIN                      UBIN      STATIC;
DCL M$DO#                    UBIN      SYMREF;
DCL M$LO#                    UBIN      SYMREF;
DCL NUM_FIELDS               UBIN      STATIC INIT(13);
DCL NUM_JOBS                 UBIN      STATIC;
DCL NUM_TALLIES              SBIN      STATIC;
DCL OUT_AHEAD(0:0)           SBIN      BASED(OUT_AHEAD_.PTR$);
DCL PAGE_SIZE                UBIN      STATIC INIT(22);
DCL POS                      UBIN      STATIC;
DCL PRIO_TALLY(0:21)         UBIN      STATIC;
DCL Q1                       SBIN      STATIC;
DCL Q2                       SBIN      STATIC;
DCL SEARCH_QUEUE             UBIN      STATIC INIT(SE_ALL#);
DCL SEARCHED                 UBIN      STATIC;
DCL SEC                      UBIN      STATIC;
DCL SI_ARS                   UBIN      STATIC;
DCL SI_CNT                   UBIN      STATIC INIT(0);
DCL TABLEVAL                 UBIN      STATIC INIT(0);
DCL TEMP                     UBIN      STATIC;
DCL TITLE_INDX               UBIN      STATIC;
DCL TITLE_LEN                UBIN      STATIC;
DCL TOT_GRANS                UBIN      STATIC;
DCL TOT_TALLIES              UBIN;
DCL UTS                      UBIN      STATIC;
%EJECT;
DCL ACCTS_SPECIFIED          BIT(1)    STATIC INIT('0'B);
DCL CCBUF_CMD                BIT(1)    STATIC INIT(NO);
DCL CMNDS_IN_FILE            BIT(1)    STATIC INIT(NO);
DCL ECHO                     BIT(1)    STATIC INIT(YES);
DCL LOOKING_AT_ALL           BIT(1)    STATIC INIT(YES);
DCL NEW_CRITERIA             BIT(1)    STATIC INIT(NO);
DCL PART_MASK_B18            BIT(18)   STATIC;
DCL PART_MASK_B1(0:17) REDEF
      PART_MASK_B18          BIT(1);
DCL READ_QUEUE               BIT(1)    STATIC INIT(YES);
DCL LONEME                   BIT(1)    SYMREF;
DCL DONELO                   BIT(1)    SYMREF;
%EJECT;
DCL TITLE                    CHAR(132) STATIC INIT('***');
DCL SI_BUF                   CHAR(140) STATIC INIT(' ');
DCL SAVED_SI_BUF             CHAR(140);
DCL 1 LO  STATIC,
      2 TALLY                CHAR(4)   UNAL,
      2 *                    CHAR(2)   UNAL,
      2 TALLY_ACCT           CHAR(8)   UNAL,
      2 *                    CHAR(3)   UNAL,
      2 TALLY_PRIO           CHAR(3)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 TALLY_STATUS         CHAR(35)  UNAL,
      2 *                    CHAR(76)  UNAL;
DCL 1 LO2 REDEF LO,
      2 TALLY                CHAR(4)   UNAL,
      2 *                    CHAR(2)   UNAL,
      2 PRIO                 CHAR(3)   UNAL,
      2 *                    CHAR(2)   UNAL,
      2 GRANS                CHAR(5)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 ACCT                 CHAR(8)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 FORM                 CHAR(6)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 WSN                  CHAR(8)   UNAL,
      2 *                    CHAR(91)  UNAL;
DCL LO_BUF REDEF LO          CHAR(132);
DCL ERROR1                   CHAR(0)   STATIC INIT(
    'This field requires relation of ''='' or ''~=''');
DCL ERROR2                   CHAR(0)   STATIC INIT(
    'This field requires values of ''N'' or ''Y''');
DCL ERROR3                   CHAR(0)   STATIC INIT(
    'Time and/or date is invalid');
DCL ERROR4                   CHAR(0)   STATIC INIT(
    'This field is not in the QUEUE you are SEARCHing');
DCL OUTPUT_WARN              CHAR(0)   STATIC INIT(
    'Warning: RQs output(M$LO) is externally SET elsewhere');
DCL GREETING                 CHAR(0)   STATIC INIT(
    'RQ C00 Here (10/08/84)');
DCL INT1                     CHAR(1)   STATIC;
DCL INT2                     CHAR(2)   STATIC;
DCL INT3                     CHAR(3)   STATIC;
DCL INT4                     CHAR(4)   STATIC;
DCL INT5                     CHAR(5)   STATIC;
DCL INT6                     CHAR(6)   STATIC;
DCL TALLY_ACCT               CHAR(8)   STATIC;
DCL TALLY_DEVT               CHAR(4)   STATIC;
DCL TALLY_FORM               CHAR(8)   STATIC;
DCL TALLY_WSN                CHAR(8)   STATIC;
DCL GREG_DATE                CHAR(8)   STATIC;
DCL 1 GREG REDEF GREG_DATE,
      2 YY                   CHAR(2),
      2 MM                   CHAR(2),
      2 DD                   CHAR(2),
      2 *                    CHAR(2);
DCL HHMMSSSS                 CHAR(11)  STATIC;
DCL 1 TIME REDEF HHMMSSSS,
      2 HH                   CHAR(2),
      2 MM                   CHAR(2),
      2 SSSS                 CHAR(4),
      2 *                    CHAR(3);
DCL ERR_MESG                 CHAR(120) STATIC;
DCL FID_STRING               CHAR(120) STATIC;
DCL HEXCHARS(0:17)           CHAR(1)   STATIC INIT(
    '1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I');
DCL PROMPT                   CHAR(1)   STATIC INIT('-');
DCL 1 SKIP_ZEROES  STATIC,
      2 *                    CHAR(48)  UNAL     INIT(' '),
      2 ZERO                 BIT(9)    UNAL     INIT('000'O),
      2 *                    CHAR(463) UNAL     INIT(' ');
 
DCL 1 SKIP_BLANKS  STATIC,
      2 *                    CHAR(32) UNAL    INIT(' '),
      2 BLANK                BIT(9)   UNAL    INIT('000'O),
      2 *                    CHAR(95) UNAL    INIT(' ');
 
DCL 1 CHK  STATIC,
      2 ACCT                 CHAR(8)   UNAL,
      2 PRIO                 UBIN(9)   UNAL;
DCL CHK_ACCT_PRIO REDEF CHK  CHAR(9);
 
DCL 1 ACT_TBL(0:0)  BASED(TBL$),
      2 ACCT                 CHAR(8)   UNAL,
      2 PRIO                 UBIN(9)   UNAL;
DCL ACT_TABL(0:0)            CHAR(9)   BASED(TBL$);
DCL 1 F(0:25) STATIC,
      2 NUM                  UBIN(9)   UNAL,
      2 REL                  UBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 STR                  CHAR(13)  UNAL;
DCL STRING                   CHAR(13)  STATIC;
DCL 1 STRNG REDEF STRING,
      2 DEC6                 CHAR(6)   UNAL,
      2 *                    CHAR(7)   UNAL;
DCL 1 STRG REDEF STRING,
      2 DEC11                CHAR(11)  UNAL,
      2 *                    CHAR(2)   UNAL;
DCL 1 TBL(0:0)  BASED(TBL$),
      2 TALLY                UBIN      UNAL,
      2 ACCT                 CHAR(8)   UNAL,
      2 AHEAD                SBIN      UNAL,
      2 FORM                 CHAR(8)   UNAL,
      2 GRANS                UBIN      UNAL,
      2 PRIO                 UBIN      UNAL,
      2 WSN                  CHAR(8)   UNAL,
      2 DEVT                 CHAR(4)   UNAL;
 
DCL WILD_X                   UBIN;
DCL WILD_XP                  UBIN;
DCL COMPARE_X                UBIN;
DCL COMPARE_XP               UBIN;
DCL COMP_COUNT               UBIN;
%EJECT;
DCL FIELD_TYPE(0:MAX_NUM_FIELDS) UBIN  STATIC INIT(
    0,              /*  0 - dummy                 */
    ALPHANUM_VAL#,  /*  1 - ACcount               */
    DEC_VAL#,       /*  2 - AHead                 */
    BIT_VAL#,       /*  3 - A                     */
    DATE_VAL#,      /*  4 - Deferred              */
    ALPHANUM_VAL#,  /*  5 - FNAME                 */
    ALPHANUM_VAL#,  /*  6 - FOLLOWS               */
    ALPHANUM_VAL#,  /*  7 - FREL                  */
    BIT_VAL#,       /*  8 - FSAT                  */
    DEC_VAL#,       /*  9 - FSCC                  */
    DEC_VAL#,       /* 10 - FSYSID                */
    BIT_VAL#,       /* 11 - F                     */
    DEC_VAL#,       /* 12 - Initial PRiority      */
    BIT_VAL#,       /* 13 - Is Rerunning          */
    ALPHANUM_VAL#,  /* 14 - Job Name              */
    DEC_VAL#,       /* 15 - Memory                */
    DEC_VAL#,       /* 16 - Number it's Following */
    BIT_VAL#,       /* 17 - No Priority increment */
    DEC_VAL#,       /* 18 - Number RESources      */
    DEC_VAL#,       /* 19 - Number packSets       */
    DEC_VAL#,       /* 20 - OPD                   */
    BIT_VAL#,       /* 21 - O                     */
    DEC_VAL#,       /* 22 - P1                    */
    DEC_VAL#,       /* 23 - P2                    */
    DEC_VAL#,       /* 24 - P3                    */
    DEC_VAL#,       /* 25 - P4                    */
    DEC_VAL#,       /* 26 - P5                    */
    DEC_VAL#,       /* 27 - P6                    */
    DEC_VAL#,       /* 28 - P7                    */
    DEC_VAL#,       /* 29 - P8                    */
    ALPHANUM_VAL#,  /* 30 - PArtition mask        */
    DEC_VAL#,       /* 31 - Priority Increment    */
    DEC_VAL#,       /* 32 - Partition NUmber      */
    DEC_VAL#,       /* 33 - PRIority              */
    BIT_VAL#,       /* 34 - Run After             */
    BIT_VAL#,       /* 35 - Rerun specified       */
    DEC_VAL#,       /* 36 - REsource list index   */
    DEC_VAL#,       /* 37 - SN list index         */
    DEC_VAL#,       /* 38 - SPindles              */
    DATE_VAL#,      /* 39 - STart time            */
    DATE_VAL#,      /* 40 - SUbmittal time        */
    DEC_VAL#,       /* 41 - SYsid                 */
    DEC_VAL#,       /* 42 - TApes                 */
    TIME_VAL#,      /* 43 - MAx time              */
    DEC_VAL#,       /* 44 - User #                */
    ALPHANUM_VAL#,  /* 45 - USername              */
    ALPHANUM_VAL#,  /* 46 - WOo                   */
    ALPHANUM_VAL#,  /* 47 - WorkStation           */
 
    ALPHANUM_VAL#,  /* 48 - ACcount               */
    DEC_VAL#,       /* 49 - AHead                 */
    ALPHANUM_VAL#,  /* 50 - ATtr                  */
    ALPHANUM_VAL#,  /* 51 - Bootid                */
    DEC_VAL#,       /* 52 - Copies                */
    ALPHANUM_VAL#,  /* 53 - DEVName               */
    ALPHANUM_VAL#,  /* 54 - DEVTyp                */
    ALPHANUM_VAL#,  /* 55 - FOrm                  */
    BIT_VAL#,       /* 56 - GLc                   */
    DEC_VAL#,       /* 57 - GRans                 */
    DEC_VAL#,       /* 58 - Hicnum                */
    ALPHANUM_VAL#,  /* 59 - Job Name              */
    ALPHANUM_VAL#,  /* 60 - MOde                  */
    DEC_VAL#,       /* 61 - Num                   */
    DEC_VAL#,       /* 62 - PRIo                  */
    DEC_VAL#,       /* 63 - SAPCopies             */
    BIT_VAL#,       /* 64 - SAP                   */
    BIT_VAL#,       /* 65 - SPill                 */
    DEC_VAL#,       /* 66 - SYsid                 */
    ALPHANUM_VAL#   /* 67 - TName/WSn             */
    );
%EJECT;
DCL IPRIO_STATUS(0:21)       CHAR(35)  STATIC INIT(
    '(At zero priority)',
    '(At priority 1)',
    '(At priority 2)',
    '(At priority 3)',
    '(At priority 4)',
    '(At priority 5)',
    '(At priority 6)',
    '(At priority 7)',
    '(At priority 8)',
    '(At priority 9)',
    '(At priority 10)',
    '(At priority 11)',
    '(At priority 12)',
    '(At priority 13)',
    '(At priority 14)',
    '(At priority 15)',
    '(Running)',
    '(Waiting to ''FOLLOW'' other job(s))',
    '(Deferred)',
    '(Waiting for a partition)',
    '(Stuck in ''OTHER'' queue)',
    '(Waiting for PACKSET)');
 
DCL FIELD_NUM(0:MAX_NUM_FIELDS) UBIN(9);
%EJECT;
DCL FIELD_TITLE(0:MAX_NUM_FIELDS) CHAR(31)  STATIC INIT(
    /*  0 -                       */ '? ',
    /*  1 - ACcount               */ 'ACCOUNT ',
    /*  2 - AHead                 */ 'AHE ',
    /*  3 - Account               */ 'A ',
    /*  4 - Deferred till         */ 'DEFERRED TILL ',
    /*  5 - FName                 */ ' FNAME   ',
    /*  6 - FOLlows               */ ' *FOLLOWS* ',
    /*  7 - FRel                  */ 'FREL ',
    /*  8 - FSat                  */ 'FSAT ',
    /*  9 - FSCc                  */ 'FSCC ',
    /* 10 - FSYsid                */ 'FSYSID ',
    /* 11 - F                     */ 'F ',
    /* 12 - Initial Prio          */ 'IPR ',
    /* 13 - Is Rerunning          */ 'IR ',
    /* 14 - JOb Name              */ 'JOB NAME ',
    /* 15 - Memory                */ ' MEM ',
    /* 16 - NFoll                 */ 'NFO ',
    /* 17 - No Prio incr          */ 'NP ',
    /* 18 - # RES                 */ ' NRES ',
    /* 19 - # SN                  */ ' NSN ',
    /* 20 - OPd                   */ 'OPD ',
    /* 21 - O                     */ 'O ',
    /* 22 - P1                    */ 'P1 ',
    /* 23 - P2                    */ 'P2 ',
    /* 24 - P3                    */ 'P3 ',
    /* 25 - P4                    */ 'P4 ',
    /* 26 - P5                    */ 'P5 ',
    /* 27 - P6                    */ 'P6 ',
    /* 28 - P7                    */ 'P7 ',
    /* 29 - P8                    */ 'P8 ',
    /* 30 - PArtition mask        */ '1 *PARTITION* 16 ',
    /* 31 - Priority Incr         */ 'PI ',
    /* 32 - Partition NUmber      */ 'PNU ',
    /* 33 - PRIority              */ 'PRI ',
    /* 34 - Run After(DEFER)      */ 'RA ',
    /* 35 - Rerun                 */ 'R ',
    /* 36 - REsource index        */ ' RESX ',
    /* 37 - SN list index         */ ' SNX ',
    /* 38 - SPindles              */ 'SP ',
    /* 39 - JOb STARTED           */ ' JOB STARTED ',
    /* 40 -   SUbmitted           */ '  SUBMITTED ',
    /* 41 - SYsid                 */ 'SYSID ',
    /* 42 - TApes                 */ '9T ',
    /* 43 - MAx time              */ 'MAX TIME ',
    /* 44 - User #                */ 'U# ',
    /* 45 - USer name             */ 'USER NAME ',
    /* 46 - WOo                   */ '  WOO ',
    /* 47 - WSn                   */ '  WSN ',
 
    /* 48 - ACcount               */ 'ACCOUNT  ',
    /* 49 -  AHead                */ ' STATUS  ',
    /* 50 -     ATtributes        */ '    ATTRIBUTES     ',
    /* 51 - Bid                   */ 'BID ',
    /* 52 - Copies                */ 'CPYs ',
    /* 53 - DEVName               */ 'DEV  ',
    /* 54 - DEVTyp                */ 'DEV  ',
    /* 55 -  FOrm                 */ ' FORM  ',
    /* 56 - GLc                   */ 'GLC ',
    /* 57 - GRans                 */ 'GRANS ',
    /* 58 - Hicnum                */ 'HIC ',
    /* 59 - Job Name              */ 'JOB NAME ',
    /* 60 - MOde                  */ 'M ',
    /* 61 - Num                   */ 'NUM    ',
    /* 62 - PRIo                  */ 'PR ',
    /* 63 - SAPCpy                */ 'SAPCPY ',
    /* 64 - SAP                   */ 'SAP ',
    /* 65 - SPill                 */ 'SPILL ',
    /* 66 - SYsid                 */ 'SYSID ',
    /* 67 -  TName                */ ' WOD     ',
    /* 68 - ?                     */ '? ');
%EJECT;
DCL FIELD_TITLE_LEN(0:MAX_NUM_FIELDS)  UBIN(9)   STATIC INIT(
     2, /*  0 - ?                 */
     9, /*  1 - ACcount           */
     4, /*  2 - AHead             */
     2, /*  3 - Account           */
    15, /*  4 - Deferred till     */
     9, /*  5 - FName             */
    11, /*  6 - *FOLlows*         */
     5, /*  7 - FRel              */
     5, /*  8 - FSat              */
     5, /*  9 - FScc              */
     7, /* 10 - FSYsid            */
     2, /* 11 - F                 */
     4, /* 12 - Initial Prio      */
     3, /* 13 - Is Rerunning      */
    32, /* 14 - Job Name          */
     5, /* 15 - Memory            */
     4, /* 16 - NFoll             */
     3, /* 17 - No Prio incr      */
     7, /* 18 - # RES             */
     7, /* 19 - # SN              */
     4, /* 20 - OPd               */
     2, /* 21 - O                 */
     3, /* 22 - P1                */
     3, /* 23 - P2                */
     3, /* 24 - P3                */
     3, /* 25 - P4                */
     3, /* 26 - P5                */
     3, /* 27 - P6                */
     3, /* 28 - P7                */
     3, /* 29 - P8                */
    17, /* 30 - PArtition mask    */
     4, /* 31 - Priority Incr     */
     4, /* 32 - Partition NUmber  */
     4, /* 33 - PRIority          */
     3, /* 34 - Run After(DEFER)  */
     2, /* 35 - Rerun             */
     7, /* 36 - REsource Index    */
     7, /* 37 - SN list index     */
     3, /* 38 - SPindles          */
    15, /* 39 - JOb started       */
    15, /* 40 -   SUbmitted       */
     6, /* 41 - SYsid             */
     3, /* 42 - TApes             */
     9, /* 43 - MAx time          */
     3, /* 44 - User #            */
    13, /* 45 - USer name         */
     9, /* 46 - WOo               */
     9, /* 47 - WSn               */
 
     9, /* 48 - ACcount           */
     9, /* 49 -  AHead            */
    19, /* 50 -     ATtributes    */
     4, /* 51 - Bid(BOOTID)       */
     5, /* 51 - Cpys              */
     5, /* 53 - DEVName           */
     5, /* 54 - DEVTyp            */
     7, /* 55 -  FOrm             */
     4, /* 56 -  GLc              */
     6, /* 57 - GRans             */
     4, /* 58 - Hicnum            */
    32, /* 59 - Job Name          */
     2, /* 60 - MOde              */
     4, /* 61 - Num               */
     3, /* 62 - PRIo              */
     7, /* 63 - SAPCpy            */
     4, /* 64 - SAP               */
     6, /* 65 - SPill             */
     6, /* 66 - SYsid             */
     9, /* 67 -  TName/WSn        */
     2);/* 68 - ?                 */
%EJECT;
    CALL L$INIT( VECTOR(GREETING),PROMPT,CMD_DISP,CMD_LEN)
                                                    ALTRET(SI_EOF_WE_HOPE);
    IF LONEME  AND
       NOT B$JIT.PRFLAGS.LS THEN
         /* Warning: RQs output(M$LO) is externally SET elsewhere */
         CALL L$WRITE( OUTPUT_WARN, LENGTHC(OUTPUT_WARN), DCBNUM(M$ME) );
    IF SUBSTR(B$JIT.ACCN,3,4) = 'NSS6' THEN
         CALL M$SPRIV(FPT_PRIV);             /* Give marketeers DISPJOB priv! */
 
    IF  B$JIT.SYSID > 99999 THEN DO;            /* Increase SYSID fields to 6 */
         FIELD_TITLE_LEN(%(DI_SYSID# - DI##)) = /* digits if need be          */
            FIELD_TITLE_LEN(%(DI_SYSID# - DI##)) + 1;
         FIELD_TITLE_LEN(%(DO_SYSID# - DI##)) =
            FIELD_TITLE_LEN(%(DO_SYSID# - DI##)) + 1;
         END;
 
    F$HELP$= DCBADDR(DCBNUM(F$HELP));
    HELP_ACCT.ACCT#= DCBADDR(2)->F$DCB.ACCT#; /* Take HELP from RUs acct */
 
    IF M$SI$->F$DCB.AMR#  AND
       M$SI$->F$DCB.RES# ~= 'CR'  AND
       M$SI$->F$DCB.RES# ~= 'ME' THEN DO;
         CMNDS_IN_FILE= YES;
         SI_ACCT.ACCT#= M$SI$->F$DCB.ACCT#;
         SI_NAME.L#=    M$SI$->F$DCB.NAME#.L;
         SI_NAME.NAME#= M$SI$->F$DCB.NAME#.C;
         SI_PASS.PASS#= M$SI$->F$DCB.PASS#;
         SI_SN.SN#(0)=  M$SI$->F$DCB.PSN#;
         SI_WSN.WSN#=   M$SI$->F$DCB.WSN#;
         END;
    ELSE CMNDS_IN_FILE= NO;
%EJECT;
    GDS_RESULTS_= VECTOR( NIL );
    GDS_RESLIST_= VECTOR( NIL );
    GDS_SNLIST_=  VECTOR( NIL );
    OUT_AHEAD_= VECTOR(NIL);
    CALL EXPAND( OUT_AHEAD_,2048,TBL_END$ )  WHENALTRETURN DO;
        CALL EOJ;
        END;
    CALL DO_RESET;                              /* setup default title line   */
    CALL M$GTRMATTR(GET_TRM_ATTR);
    IF TRMATTR_VLP.DSPHEIGHT# > 0 THEN
         PAGE_SIZE= TRMATTR_VLP.DSPHEIGHT#-1;
    ELSE PAGE_SIZE= 22;
    LINE_CNT= PAGE_SIZE+1;                      /* Force heading */
 
OPEN_SI:
    CALL M$CLOSE(CLOSE_SI);
    IF CMNDS_IN_FILE THEN
         CALL M$OPEN(OPN_SI_ASIS)  ALTRET(OPN_SI_ERR);  /* fid */
    ELSE CALL M$OPEN(OPN_SI)       ALTRET(OPN_SI_ERR);  /* 'ME' */
    DO WHILE('0'B);
OPN_SI_ERR:
      IF CMNDS_IN_FILE THEN DO;
           CALL L$MONERR;
           CMNDS_IN_FILE= NO;
           IF CMD_LEN >= 0 THEN
                CALL M$ERR;
           ELSE GOTO OPEN_SI;
           END;
      ELSE CALL M$XXX;
      END;
    IF CMD_LEN > 0 THEN                     /* Something past '(' in CCBUF    */
         CALL CONCAT( SI_BUF, SUBSTR(B$JIT.CCBUF,CMD_DISP,CMD_LEN),
                              ';END;ENDEVERY;END');
    ELSE IF CMD_LEN = 0 THEN                /* Just a '(' was in CCBUF        */
              SI_BUF= 'S;T;O;N;END';        /* Set default command            */
%EJECT;
 
    DO WHILE('1'B);
READSI:
      IF EVERY_CNT < 0 THEN
           CALL READ_SI  ALTRET(SI_EOF_WE_HOPE);
      ELSE IF EVERY_CNT = 0  OR
              BROKEN > 0 THEN DO;
                SI_BUF= SAVED_SI_BUF;
                EVERY_CNT= -1;
                END;
           ELSE;  /* We are within the scope of a EV/ery */
      NEW_CRITERIA= NO;
      BROKEN= 0;
      CALL X$PARSE(PARSE_IT)  ALTRET(PARSE_ERR);
      BLK1$= PARSE_IT.OUT$;
      DO H = 0 TO BLK1$->P_OUT.NSUBLKS-1;
        BLK2$= BLK1$->P_OUT.SUBLK$(H);
        DO H1 = 0 TO BLK2$->P_OUT.NSUBLKS-1;
          BLK3$= BLK2$->P_OUT.SUBLK$(H1);
          CMD#= BLK3$->P_SYM.CODE;
          IF READ_QUEUE  OR
             NEW_CRITERIA  THEN
               CALL READ_QUE;                   /* Read the selected QUEUE    */
          IF CMD# ~= HELP_CMD# THEN
               HELPCNT= 8;         /* Don't do anything if they type '?' next */
          LISTED= 0;
          SEARCHED= 0;
          DO CASE( CMD# );
 
            CASE( DISPLAY_CMD# );               /* DISPLAY */
              CALL DO_DISPLAY  ALTRET( READSI );
 
            CASE(ECHO_CMD#);                    /* ECHO */
              ECHO= YES;
 
            CASE( END_CMD# );                   /* END | QUIT | XIT */
              IF EVERY_CNT < 0 THEN
                   CALL EOJ;
              ELSE;  /* Ignore E/nd, Q/uit or X/it within scope of EV/ery */
 
            CASE( ENDEVERY_CMD# );
              IF EVERY_CNT < 0 THEN DO;
                   LO_BUF= '* ENDEvery not preceded by an EVery; ignored *';
                   CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
                   END;
              ELSE DO;
                   EVERY_CNT= EVERY_CNT - 1;
                   IF EVERY_CNT >= 1 THEN
                        CALL M$WAIT( SLEEP );
                   END;
 
            CASE( EVERY_CMD# );                 /* EVERY */
              CALL DO_EVERY  ALTRET( GET_MORE_CMDS );
 
            CASE(FIND_CMD#);                    /* FIND */
              CALL DO_FIND;
 
            CASE( HEAD_CMD# );                  /* HEAD */
           /* CALL DO_HEAD; */
 
            CASE(HELP_CMD#);                    /* HELP */
              CALL DO_HELP;
 
            CASE( IBEX_CMD# );                  /* !??? */
              CALL DO_IBEX;
 
            CASE(NOECHO_CMD#);                  /* NO ECHO */
              ECHO= NO;
 
            CASE(NOREAD_CMD#);                  /* NO READ */
              READ_QUEUE= NO;
 
            CASE(NUMBER_CMD#);                  /* NUMBER */
              CALL DO_NUMBER;
 
            CASE(OUTPUT_CMD#);                  /* OUTPUT ON (LP | NO)        */
              CALL DO_OUTPUT;
 
            CASE(PAGE_CMD#);                    /* PAGE */
              CALL M$DEVICE(WRITE_LO_PAGE);
 
            CASE(PRINT_CMD#);                   /* PRINT */
              CALL DO_PRINT  ALTRET( READSI );
 
            CASE(READ_CMD#);                    /* READ */
              READ_QUEUE= YES;
 
            CASE(RESET_CMD#);                   /* RESET */
              CALL DO_RESET;
 
            CASE(SCAN_CMD#);                    /* SCAN */
              IF BLK3$->P_OUT.NSUBLKS > 0 THEN
                   TEMP= BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE;
              ELSE TEMP= SE_ALL#;                  /* 'S/YSTEM' was specified */
              CALL DO_SCAN( TEMP )  ALTRET( READSI );
 
            CASE(SEARCH_CMD#);                  /* SEARCH */
              CALL DO_SEARCH;
 
            CASE( SIZE_CMD# );                  /* SIZE */
           /* CALL DO_SIZE; */
 
            CASE(TALLY_CMD#);                   /* TALLY */
              CALL DO_TALLY;
 
            CASE(XEQ_CMD#);                     /* XEQ   */
              CALL DO_XEQ  ALTRET(OPEN_SI);
 
            END;                                /* END CASE(CMD#) */
          END;  /* end DO H1 = 0 TO BLK2$->P_OUT.NSUBLKS-1; */
        END;  /* end DO H = 0 TO BLK1$->P_OUT.NSUBLKS-1; */
      DO WHILE('0'B);
SI_EOF_WE_HOPE:
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$EOF  AND
           B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$NOPRIV  THEN
             CALL EOJ(B$TCB$->B$TCB.ALT$->B$ALT);
        IF NOT CMNDS_IN_FILE THEN
             CALL EOJ;
        CMNDS_IN_FILE= NO;
        GOTO OPEN_SI;
        END;
 
      DO WHILE('0'B);
PARSE_ERR:
        LO_BUF= ' ';
        IF CMD_LEN >= 0 THEN
             LO_INDX= B$JIT.CCDISP+2;        /* Point to right place in CCBUF */
        ELSE LO_INDX= 1;
        IF PARSE_IT.HI_CHAR < LENGTHC(SI_BUF) THEN
             LO_INDX= PARSE_IT.HI_CHAR+LO_INDX;
        ELSE LO_INDX= M$SI$->F$DCB.ARS#+LO_INDX;
        CALL INSERT(LO_BUF,LO_INDX,1,'^');
        CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
        LO_BUF= 'Syntax error about here';
        CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
        IF CMD_LEN > 0 THEN
             CALL M$ERR;
        END;
GET_MORE_CMDS:
      END;  /* END WHILE('1'B); */
 
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   D I S P L A Y                                                       *
*                                                                              *
*    Syntax: D/isplay [ fieldname1 [,fieldname2...] ]                          *
*                                                                              *
\******************************************************************************/
DO_DISPLAY: PROC  ALTRET;
 
    IF BLK3$->P_OUT.NSUBLKS > 0 THEN DO;
         NUM_FIELDS= 0;
         DO J=0 TO BLK3$->P_OUT.NSUBLKS-1;
           NUM_FIELDS= NUM_FIELDS + 1;
           FLD#= BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CODE;
           IF SEARCH_QUEUE = SE_OUTPUT# THEN DO; /* If we're searching output */
                DO SELECT( FLD# );               /* queue but the parse found */
                   SELECT( DI_ACCOUNT# );        /* match on a input field,   */
                      FLD#= DO_ACCOUNT#;         /* change the code to the    */
                   SELECT( DI_AHEAD# );          /* respective output code    */
                      FLD#= DO_AHEAD#;
                   SELECT( DI_JOBNAME# );
                      FLD#= DO_JOBNAME#;
                   SELECT( DI_PRI# );
                      FLD#= DO_PRIO#;
                   SELECT( DI_SYSID# );
                      FLD#= DO_SYSID#;
                   SELECT( DI_SPINDLES# );
                      FLD#= DO_SPILL#;
                   SELECT( DI_WSN# );
                      FLD#= DO_TNAME#;
                   END;
                IF FLD# < DO## THEN
                     /* This field is not in the QUEUE you are SEARCHing      */
                     CALL PUT_ERR( ERROR4, LENGTHC(ERROR4),
                        BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CPOS )
                                                   ALTRET( OOPS );
                ELSE FIELD_NUM(NUM_FIELDS)= FLD#;
                END;
           ELSE IF FLD# > DI_LAST_CMD# THEN DO;
                     LO_INDX= BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CPOS + 1;
                     /* This field is not in the QUEUE you are SEARCHing      */
                     CALL PUT_ERR( ERROR4, LENGTHC(ERROR4),
                        BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CPOS )
                                                   ALTRET( OOPS );
                     END;
                ELSE IF FLD# = DI_FOLLOWS# THEN DO;
                          FIELD_NUM(NUM_FIELDS)= DI_FSYSID#;
                          FIELD_NUM(NUM_FIELDS+1)= DI_FREL#;
                          FIELD_NUM(NUM_FIELDS+2)= DI_FSCC#;
                          FIELD_NUM(NUM_FIELDS+3)= DI_FSAT#;
                          NUM_FIELDS= NUM_FIELDS + 3;
                          END;
                     ELSE FIELD_NUM(NUM_FIELDS)= FLD#;
           END;
         FIELD_NUM(NUM_FIELDS+1)= DEFAULT_FIELD#;
         CALL BUILD_TITLE;
         END;
    ELSE IF CMD# = DISPLAY_CMD# THEN DO; /* Just 'D/isplay' was specified     */
              CALL BUILD_TITLE;          /* Build and print the title line    */
              CALL L$WRITE( TITLE, LENGTHC(TITLE), M$LO# );
              END;
 
    RETURN;
 
OOPS:
    CALL DO_RESET;
    ALTRETURN;
 
END DO_DISPLAY;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   E V E R Y                                                           *
*                                                                              *
*    Syntax: EV/ery [ # interations * ] interval ... [ ;ENDE/very ]            *
*                                                                              *
\******************************************************************************/
DO_EVERY: PROC  ALTRET;
DCL I                        UBIN;
 
    SAVED_SI_BUF= ' ';
    IF H >= BLK1$->P_OUT.NSUBLKS-1 THEN DO;
         LO_BUF= 'All commands w/in scope of EVery must be on line with EVery';
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         ALTRETURN;
         END;
 
    DO I = H+1 TO BLK1$->P_OUT.NSUBLKS-1;
      BLK3$= BLK1$->P_OUT.SUBLK$(I)->P_OUT.SUBLK$(0);
      IF I = H+1 THEN
           CALL INSERT(SI_BUF,0,BLK3$->P_SYM.CPOS,' ');
      IF BLK3$->P_SYM.CODE = EVERY_CMD# THEN DO;
           LO_BUF= '* Sorry!  Can''t nest EVerys (yet) *';
           CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
           ALTRETURN;
           END;
      IF BLK3$->P_SYM.CODE = ENDEVERY_CMD# THEN
           GOTO SAVE_RESIDUE;
      END;
 
    /* No ENDEVERY command; Supply one */
    CALL INSERT( SI_BUF, SI_ARS, , ';ENDEVERY' );
    BLK3$= BLK1$->P_OUT.SUBLK$(H)->P_OUT.SUBLK$(0);
    GOTO SET_VALUES;
 
SAVE_RESIDUE:
    BLK3$= BLK1$->P_OUT.SUBLK$(H)->P_OUT.SUBLK$(0);
    IF I < BLK1$->P_OUT.NSUBLKS-1 THEN DO;
         BEG= BLK1$->P_OUT.SUBLK$(I+1)->P_OUT.SUBLK$(0)->P_SYM.CPOS;
         SAVED_SI_BUF= SUBSTR(SI_BUF,BEG);
         CALL INSERT(SI_BUF,BEG-1, ,' ');
         H= BLK1$->P_OUT.NSUBLKS;
         END;
 
SET_VALUES:
    BLK4$= BLK3$->P_OUT.SUBLK$(0);
    IF BLK3$->P_OUT.NSUBLKS <= 1 THEN DO;
         INTERATIONS= 99999;
         CALL CHARBIN(INTERVAL,SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT));
         END;
    ELSE DO;
         CALL CHARBIN(INTERATIONS,
                             SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT));
         BLK4$= BLK3$->P_OUT.SUBLK$(1);
         CALL CHARBIN(INTERVAL,SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT));
         END;
    EVERY_CNT= INTERATIONS;
    SLEEP.V.UNITS#= INTERVAL;
    RETURN;
 
END DO_EVERY;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   F I N D                                                             *
*                                                                              *
*    Syntax: F/ind [ fieldname1 operator1 value1 [,...] ]                      *
*                                                                              *
\******************************************************************************/
DO_FIND: PROC;
    NCBS= -1;
    DO J = 0 TO BLK3$->P_OUT.NSUBLKS-1 BY 3;
      BLK4$= BLK3$->P_OUT.SUBLK$(J);
      NCBS= NCBS + 1;
      FLD#= BLK4$->P_SYM.CODE;
      IF SEARCH_QUEUE = %SE_OUTPUT# THEN DO;     /* If we're searching output */
           IF FLD# = DI_ACCOUNT# THEN            /* queue but the parse found */
                FLD#= DO_ACCOUNT#;               /* match on a input field,   */
           ELSE IF FLD# = DI_AHEAD# THEN         /* change the code to the    */
                     FLD#= DO_AHEAD#;            /* respective output code    */
                ELSE IF FLD# = DI_JOBNAME# THEN
                          FLD#= DO_JOBNAME#;
                     ELSE IF FLD# = DI_PRI# THEN
                               FLD#= DO_PRIO#;
                          ELSE IF FLD# = DI_SYSID# THEN
                                    FLD#= DO_SYSID#;
                               ELSE IF FLD# = DI_SPINDLES# THEN
                                         FLD#= DO_SPILL#;
                                    ELSE IF FLD# = DI_WSN# THEN
                                              FLD#= DO_TNAME#;
           IF FLD# < DO## THEN
                /* This field is not in the QUEUE you are SEARCHing      */
                CALL PUT_ERR( ERROR4, LENGTHC(ERROR4),
                   BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CPOS )
                                              ALTRET( SPLIT );
           ELSE F.NUM(NCBS)= FLD#;
           END;
      ELSE IF FLD# > DI_LAST_CMD# THEN
                /* This field is not in the QUEUE you are SEARCHing      */
                CALL PUT_ERR( ERROR4, LENGTHC(ERROR4),
                   BLK3$ -> P_OUT.SUBLK$(J) -> P_SYM.CPOS )
                                              ALTRET( SPLIT );
           ELSE F.NUM(NCBS)= FLD#;
      FLD#= FLD# - DI##;
      F.REL(NCBS)= BLK3$->P_OUT.SUBLK$(J+1)->P_SYM.CODE;
      BLK4$= BLK3$->P_OUT.SUBLK$(J+2);
      F.LEN(NCBS)= BLK4$->P_SYM.COUNT;
      F.STR(NCBS)= BLK4$->P_SYM.TEXT;
      IF FIELD_TYPE(FLD#) = BIT_VAL# THEN
           IF F.REL(NCBS) ~= EQ#  AND
              F.REL(NCBS) ~= NE#  THEN DO;
                BLK4$= BLK3$->P_OUT.SUBLK$(J+1);
                /* This field requires relation of '=' or '~=' */
                CALL PUT_ERR(ERROR1,LENGTHC(ERROR1),BLK4$->P_SYM.CPOS)
                                                ALTRET(SPLIT);
                END;
           ELSE IF SUBSTR(F.STR(NCBS),0,1) ~= 'N'  AND
                   SUBSTR(F.STR(NCBS),0,1) ~= 'n'  AND
                   SUBSTR(F.STR(NCBS),0,1) ~= 'Y'  AND
                   SUBSTR(F.STR(NCBS),0,1) ~= 'y' THEN
                     /* This field requires value of 'N' or 'Y' */
                     CALL PUT_ERR(ERROR2,LENGTHC(ERROR2),BLK4$->P_SYM.CPOS)
                                                ALTRET(SPLIT);
                ELSE;
      ELSE IF FIELD_TYPE(FLD#) = DEC_VAL# THEN DO;
                F.STR(NCBS)= '000000';
                CALL INSERT(F.STR(NCBS),6-F.LEN(NCBS),F.LEN(NCBS),
                               BLK4$->P_SYM.TEXT);
                END;
           ELSE IF FIELD_TYPE(FLD#) = DATE_VAL# THEN
                     CALL VERIFY_DATE  ALTRET(SPLIT);
                ELSE IF FIELD_TYPE(FLD#) = TIME_VAL# THEN
                          CALL VERIFY_TIME  ALTRET(SPLIT);
      END;
    IF BLK3$->P_OUT.NSUBLKS < 1 THEN DO;
         NCBS= 0;
         IF SEARCH_QUEUE = %SE_OUTPUT# THEN
              F.NUM(0)= DO_ACCOUNT#;
         ELSE F.NUM(0)= DI_ACCOUNT#;
         F.REL(0)= EQ#;
         F.LEN(0)= LENGTHC( B$JIT.ACCN );
         F.STR(0)= B$JIT.ACCN;  /* Take users ACCOUNT from JIT */
         END;
    Q$= PINCRW(GDS_RESULTS_.PTR$,2);  /* = ADDR(VLR_ISRCH.J(0)) */
    LINE_CNT= PAGE_SIZE + 1;
    IF NUM_JOBS <= 0 THEN DO;
         DO CASE( SEARCH_QUEUE );
           CASE( SE_ALL# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs running and queue is empty';
             ELSE LO_BUF= '.. YOU have no jobs running or in queue';
           CASE( SE_RUNNING# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs running';
             ELSE LO_BUF= '.. YOU have no jobs running';
           CASE( SE_INPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs waiting to run';
             ELSE LO_BUF= '.. YOU have no jobs waiting to run';
           CASE( SE_OUTPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing in OUTPUT queue';
             ELSE LO_BUF= '.. YOU have nothing in OUTPUT queue';
           END;
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
    DO I=0 TO NUM_JOBS-1;
      DO J=0 TO NCBS;
        STRING= ' ';
        DO CASE( F.NUM(J) );
          CASE( DI_A# );                            /* Account                */
            IF Q$->IQ.FLG.ACC THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_ACCOUNT# );                      /* ACCOUNT                */
            STRING= Q$->IQ.ACCT;
          CASE( DI_AHEAD# );                        /* AHead                  */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.AHEAD);
          CASE( DI_DEFERRED# );                     /* Deferred till          */
            CALL BINCHAR(STRG.DEC11,Q$->IQ.RATIM);
          CASE( DI_F# );                            /* FOLOWS                 */
            IF Q$->IQ.FLG.O3 THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_IPR# );                          /* IP/r                   */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.IPRIO);
          CASE( DI_IR# );                           /* Is Rerunning           */
            IF Q$->IQ.FLG.RR2 THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_JOBNAME# );                      /* Job name               */
            STRING= Q$->IQ.JNAME;
          CASE( DI_NFO# );                          /* NFollow                */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.NFOLL);
          CASE( DI_NPI# );                          /* No Priority Increment  */
            IF Q$->IQ.FLG.NPI THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_NRES# );                         /* Number of RESources    */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.NRES);
          CASE( DI_NSN# );                          /* Number of SNs          */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.NSN);
          CASE( DI_O# );                            /* Order                  */
            IF Q$->IQ.FLG.O1 THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_P1# );                           /* Pseudo 1               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(4) );
          CASE( DI_P2# );                           /* Pseudo 2               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(5) );
          CASE( DI_P3# );                           /* Pseudo 3               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(6) );
          CASE( DI_P4# );                           /* Pseudo 4               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(7) );
          CASE( DI_P5# );                           /* Pseudo 5               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(8) );
          CASE( DI_P6# );                           /* Pseudo 6               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(9) );
          CASE( DI_P7# );                           /* Pseudo 7               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(10) );
          CASE( DI_P8# );                           /* Pseudo 8               */
            CALL BINCHAR( STRNG.DEC6, Q$->IQ.RRT(11) );
          CASE( DI_PART# );                         /* PArtition mask         */
            PART_MASK_B18= Q$->IQ.PART;
            DO K=0 TO 15;
              IF PART_MASK_B1(K) THEN
                   CALL INSERT(STRING,K,1,HEXCHARS(K));
              ELSE CALL INSERT(STRING,K,1,'.');
              END;
          CASE( DI_PI# );                           /* Priority Increment     */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.PI);
          CASE( DI_PNUM# );                         /* Partition NUMber       */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.PNUM);
          CASE( DI_PRI# );                          /* PRIority               */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.PRIO);
          CASE( DI_RA# );                           /* Run After              */
            IF Q$->IQ.FLG.RA THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_R# );                            /* Rerun                  */
            IF Q$->IQ.FLG.RR THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DI_RESX# );                         /* RESource indeX         */
            CALL BINCHAR(STRNG.DEC6, Q$->IQ.RESX);
          CASE( DI_SNX# );                          /* SN indeX               */
            CALL BINCHAR(STRNG.DEC6, Q$->IQ.SNX);
          CASE( DI_START_TIME# );                   /* STarted                */
            CALL BINCHAR(STRG.DEC11, Q$->IQ.START_TIME);
          CASE( DI_SUBMIT_TIME# );                  /* SUbmitted time         */
            CALL BINCHAR(STRG.DEC11, Q$->IQ.SUBMIT_TIME);
          CASE( DI_SYSID# );                        /* SYsid                  */
            CALL BINCHAR(STRNG.DEC6, Q$->IQ.SYSID);
          CASE( DI_MAX_TIME# );                     /* MAx time               */
            CALL BINCHAR(STRG.DEC11, Q$->IQ.TIM);
          CASE( DI_USER# );                         /* User #                 */
 
          CASE( DI_USERNAME# );                     /* USer name              */
            STRING= Q$->IQ.UNAME;
          CASE( DI_WOO# );                          /* WOo                    */
            STRING= Q$->IQ.WOO;
          CASE( DI_WSN# );                          /* WSn                    */
            STRING= Q$->IQ.WSN;
          CASE( DI_MEM# );                          /* Memory                 */
            CALL BINCHAR(STRNG.DEC6, Q$->IQ.RRT(0));
          CASE( DI_SPINDLES# );                     /* SPindles               */
            CALL BINCHAR(STRNG.DEC6, Q$->IQ.RRT(1));
          CASE( DI_TAPES# );                        /* TApes | 9T             */
            CALL BINCHAR(STRNG.DEC6,Q$->IQ.RRT(2));
          CASE( DO_ACCOUNT# );                      /* ACcount                */
            STRING= Q$->OQ.ACCT;
          CASE( DO_AHEAD# );                        /* AHead                  */
            CALL BINCHAR( STRNG.DEC6,OUT_AHEAD(I) );
          CASE( DO_ATTR# );                         /* ATtribute              */
            PART_MASK_B18= Q$->OQ.ATTR;
            DO K = 0 TO 17;
              IF PART_MASK_B1(K) THEN
                   CALL INSERT( STRING,K,1,HEXCHARS(K) );
              ELSE CALL INSERT( STRING,K,1,'.' );
              END;
          CASE( DO_BOOTID# );                       /* Bootid                 */
            STRING= Q$->OQ.BOOTID;
          CASE( DO_COPIES# );                       /* Copies                 */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.COPIES );
          CASE( DO_DEVNAME# );                      /* DEVName                */
            STRING= Q$->OQ.DEVNAME;
          CASE( DO_DEVTYP# );                       /* DEVType                */
            STRING= Q$->OQ.DEVTYP;
          CASE( DO_GLC# );                          /* GLc                    */
            IF Q$->OQ.FLG.GLC THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DO_FORM# );                         /* FOrm                   */
            STRING= Q$->OQ.FORM;
          CASE( DO_GRANS# );                        /* GRans                  */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.GRANS );
          CASE( DO_HICNUM# );                       /* Hicnum                 */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.HICNUM );
          CASE( DO_JOBNAME# );                      /* Job name               */
            STRING= Q$->OQ.JNAME;
          CASE( DO_MODE# );                         /* NOde                   */
            IF Q$->OQ.MODE = %MODE_BATCH# THEN
                 STRING= 'B';
            ELSE IF Q$->OQ.MODE = %MODE_GHOST# THEN
                      STRING= 'G';
                 ELSE IF Q$->OQ.MODE = %MODE_INT# THEN
                           STRING= 'O';
                      ELSE STRING= 'TP';
          CASE( DO_NUM# );                          /* Num                    */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.NUM );
          CASE( DO_PRIO# );                         /* PRIority               */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.PRIO );
          CASE( DO_SAPCOPIES# );                    /* SAPCopies              */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.SAPCOPIES );
          CASE( DO_SAP# );                          /* SAP                    */
            IF Q$->OQ.FLG.SAP THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DO_SPILL# );                        /* SPill                  */
            IF Q$->OQ.FLG.SPILL THEN
                 STRING= 'Y';
            ELSE STRING= 'N';
          CASE( DO_SYSID# );                        /* SYsid                  */
            CALL BINCHAR( STRNG.DEC6,Q$->OQ.SYSID );
          CASE( DO_TNAME# );                        /* TName                  */
            STRING= Q$->OQ.WOD;
          END;
        DO CASE( F.REL(J) );
          CASE( NE# );
            CALL INDEX1( WILD_X,'?',F.STR(J) );
            IF WILD_X < LENGTHC(F.STR(J)) THEN DO;
                 %WILD_COMPARE( WILD_CHARS="F.STR(J)",
                                COMPARE_CHARS="STRING",
                                NO_MATCH="GOTO MATCH_FOUND",
                                COMP_COUNT="COMP_COUNT" );
                 GOTO NEXT_Q_ENTRY;
                 END;
            ELSE IF STRING = F.STR(J) THEN
                      GOTO NEXT_Q_ENTRY;
          CASE( LE# );
            IF STRING > F.STR(J) THEN
                 GOTO NEXT_Q_ENTRY;
          CASE( GE# );
            IF STRING < F.STR(J) THEN
                 GOTO NEXT_Q_ENTRY;
          CASE( EQ# );
            CALL INDEX1( WILD_X,'?',F.STR(J) );
            IF WILD_X < LENGTHC(F.STR(J)) THEN DO;
                 %WILD_COMPARE( WILD_CHARS="F.STR(J)",
                                COMPARE_CHARS="STRING",
                                NO_MATCH="GOTO NEXT_Q_ENTRY",
                                COMP_COUNT="COMP_COUNT" );
                 END;
            ELSE IF STRING ~= F.STR(J) THEN
                      GOTO NEXT_Q_ENTRY;
          CASE( LT# );
            IF STRING >= F.STR(J) THEN
                 GOTO NEXT_Q_ENTRY;
          CASE( GT# );
            IF STRING <= F.STR(J) THEN
                 GOTO NEXT_Q_ENTRY;
          END; /* end DO CASE(F.REL(J)) */
        END; /* end DO J=0 TO NCBS */
MATCH_FOUND:
      IF BROKEN > 0 THEN
           GOTO PUT_FIND_SUM;
      ELSE CALL DISPLAY_LINE(I);
NEXT_Q_ENTRY:
      IF SEARCH_QUEUE = SE_OUTPUT# THEN
           Q$= PINCRC(Q$, SIZEC(VLR_OSRCH.F(0)) );
      ELSE Q$= PINCRC(Q$, LENGTHC(VLR_ISRCH.J(0)) );
      END; /* end DO I=0 TO NUM_JOBS-1 */
    I= NUM_JOBS;
 
PUT_FIND_SUM:
    CALL PUT_NUM_LISTED( LISTED, I );  /* n Listed, n Searched */
 
SPLIT:
    RETURN;
END DO_FIND;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   H E L P                                                             *
*                                                                              *
*    Syntax: H/elp [ { ? | C/ommands | EX/amples | NOT/ation | TE/xt | cmd } ] *
*                                                                              *
\******************************************************************************/
 
DO_HELP: PROC;
 
    IF BLK3$->P_OUT.NSUBLKS > 0 THEN DO;
         IF BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE ~= MORE_HELP#  AND
            BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE ~= QUES2#  THEN
              HELPCNT= 0;
         IF BLK3$->P_OUT.NSUBLKS > 1 THEN
              HELP_TYPE= BLK3$->P_OUT.SUBLK$(1)->P_SYM.CODE;
         ELSE HELP_TYPE= 0;
         IF BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE < ALL_HELP# THEN
              DO CASE( BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE );
                CASE( QUES2# );
                  CALL PUT_HELP( HELPCNT, QUES2# );
                CASE( COMMANDS# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, COMMANDS# );
                CASE( EXAMPLES# );
                  HELP_TYPE= EXAMPLES#;
                  CALL DO_HELP_ALL;
                CASE( TEXT# );
                  HELP_TYPE= TEXT#;
                  CALL DO_HELP_ALL;
                CASE( MORE_HELP# );
                  CALL PUT_HELP( HELPCNT, 999 );
                CASE( HELP_ALL# );
                  HELP_TYPE= QUES2#;
                  CALL DO_HELP_ALL;
                END;
         ELSE DO CASE( BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE );
                CASE( ALL_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, ALL_HELP# );
                CASE( DISPLAY_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, DISPLAY_HELP# );
                CASE( ECHO_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, ECHO_HELP# );
                CASE( END_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, END_HELP# );
                CASE( EVERY_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, EVERY_HELP# );
                CASE( FIND_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, FIND_HELP# );
                CASE( HEAD_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, HEAD_HELP# );
                CASE( HELP_HELP# );
                  HELPCNT= 7;
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, HELP_HELP# );
                CASE( IBEX_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, IBEX_HELP# );
                CASE( INPUT_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, INPUT_HELP# );
                CASE( INPUT_FIELDS_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, INPUT_FIELDS_HELP# );
                CASE( LP_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, LP_HELP# );
                CASE( ME_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, ME_HELP# );
                CASE( NO_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, NO_HELP# );
                CASE( NOECHO_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, NOECHO_HELP# );
                CASE( NOREAD_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, NOREAD_HELP# );
                CASE( NOTATION_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, NOTATION_HELP# );
                CASE( NUMBER_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, NUMBER_HELP# );
                CASE( OUTPUT_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, OUTPUT_HELP# );
                CASE( OUTPUT_FIELDS_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, OUTPUT_FIELDS_HELP# );
                CASE( OUTPUT_ON_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, OUTPUT_ON_HELP# );
                CASE( PAGE_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, PAGE_HELP# );
                CASE( PRINT_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, PRINT_HELP# );
                CASE( READ_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, READ_HELP# );
                CASE( RESET_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, RESET_HELP# );
                CASE( RUNNING_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, RUNNING_HELP# );
                CASE( SCAN_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, SCAN_HELP# );
                CASE( SEARCH_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, SEARCH_HELP# );
                CASE( SIZE_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, SIZE_HELP# );
                CASE( SYSTEM_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, SYSTEM_HELP# );
                CASE( TALLY_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, TALLY_HELP# );
                CASE( XEQ_HELP# );
                  CALL PUT_HELP( HELPCNT, HELP_TYPE, XEQ_HELP# );
                END;
         END;
    ELSE DO;
           HELPCNT= 0;
           CALL PUT_HELP( HELPCNT, 0, HELP_HELP# );
         END;
 
    RETURN;
 
END DO_HELP;
/******************************************************************************\
*                                                                              *
*    D O   I B E X                                                             *
*                                                                              *
*    Syntax: !xxx                                                              *
*                                                                              *
\******************************************************************************/
 
DO_IBEX: PROC;
 
    BLK4$= BLK3$->P_OUT.SUBLK$(0);
    FID_STRING= BLK4$->P_SYM.TEXT;
    IF BLK3$->P_OUT.NSUBLKS > 1 THEN
         CALL CONCAT( LINK_CMD.TEXT,
                         SUBSTR(FID_STRING,0,BLK4$->P_SYM.COUNT),
                         ' ',
                         BLK3$->P_OUT.SUBLK$(1)->P_SYM.TEXT);
    ELSE LINK_CMD.TEXT= FID_STRING;
    CALL M$FID( FID_LINK )  ALTRET( TRY_YC );
    CALL INDEX1(J,'.',FID_STRING);
    CALL INDEX1(I,' ',FID_STRING);
    IF I < J THEN
         LINK_ACCT.ACCT#= ':SYS    ';
    CALL SEARCHR( J,TABLEVAL,SKIP_BLANKS,LINK_CMND );
    LINK_CMD.L#= J;
    CALL M$LINK( FPT_LINK )  ALTRET( M$LINK_ERR );
    RETURN;
 
M$LINK_ERR:
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$NOFILE THEN DO;
         CALL L$MONERR;
         RETURN;
         END;
 
TRY_YC:
    CALL M$YC( FPT_YC )  ALTRET( NO_CAN_DO );
    RETURN;
 
NO_CAN_DO:
    CALL L$MONERR;
    RETURN;
 
END DO_IBEX;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   N U M B E R                                                         *
*                                                                              *
*    Syntax: N/umber [ { [.[account]] | [@[wsn]] | form } ]                    *
*                                                                              *
\******************************************************************************/
 
DO_NUMBER: PROC;
 
    IF NUM_JOBS <= 0 THEN DO;
         DO CASE( SEARCH_QUEUE );
           CASE( SE_ALL# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs running and queue is empty';
             ELSE LO_BUF= '.. YOU have no jobs running or in queue';
           CASE( SE_RUNNING# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs running';
             ELSE LO_BUF= '.. YOU have no jobs running';
           CASE( SE_INPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs waiting to run';
             ELSE LO_BUF= '.. YOU have no jobs waiting to run';
           CASE( SE_OUTPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing in OUTPUT queue';
             ELSE LO_BUF= '.. YOU have nothing in OUTPUT queue';
           END;
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
%EJECT;
    TALLY_ACCT= ' ';
    TALLY_FORM= ' ';
    TALLY_WSN=  ' ';
    IF BLK3$->P_OUT.NSUBLKS > 0 THEN DO;
         LOOKING_AT_ALL= NO;
         BLK4$= BLK3$->P_OUT.SUBLK$(0);
         IF BLK4$->P_OUT.NSUBLKS > 0 THEN DO;
              BLK5$= BLK4$->P_OUT.SUBLK$(0);
              IF BLK4$->P_SYM.CODE = ACCT## THEN
                   TALLY_ACCT= BLK5$->P_SYM.TEXT;
              ELSE IF BLK4$->P_SYM.CODE = WSN## THEN
                        TALLY_WSN= BLK5$->P_SYM.TEXT;
                   ELSE TALLY_FORM= BLK5$->P_SYM.TEXT;
              END;
         ELSE IF BLK4$->P_SYM.CODE = ACCT## THEN
                   TALLY_ACCT= B$JIT.ACCN;
              ELSE IF BLK4$->P_SYM.CODE = WSN## THEN
                        TALLY_WSN= B$JIT.WOO;
                   ELSE DO;
                          CALL DO_SCAN( SE_ALL# );
                          LOOKING_AT_ALL= YES;
                        END;
         END;
    ELSE LOOKING_AT_ALL= YES;
 
    Q$= PINCRW( GDS_RESULTS_.PTR$, 2 );
    NUM_TALLIES= -1;
    IF SEARCH_QUEUE = SE_OUTPUT# THEN
         CALL DO_NUMBER_OUTPUT;
    ELSE CALL DO_NUMBER_INPUT;
    RETURN;
 
END DO_NUMBER;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   O U T P U T                                                         *
*                                                                              *
*    Syntax: [O/utput] [O/n] { LP | ME | NO }                                  *
*            O/utput [O/n] fid                                                 *
*                                                                              *
\******************************************************************************/
DO_OUTPUT: PROC;
 
    CALL M$CLOSE(CLOSE_LO);
    DO CASE( BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE - %OU_LP# );
 
      CASE( %( OU_LP# - OU_LP# ) ); /* ['O/UTPUT'] ['ON'] 'LP' */
        FID_STRING= 'LP';
 
      CASE( %( OU_NO# - OU_LP# ) ); /* ['O/UTPUT'] ['ON'] 'NO' */
        FID_STRING= 'NO';
 
      CASE( %( OU_AFID# - OU_LP# ) );
        FID_STRING= BLK3$->P_OUT.SUBLK$(0)->P_SYM.TEXT;
 
      END;
 
    CALL M$FID( FID_LO )  ALTRET( BAD_FID );
    CALL M$CLOSE( CLOSE_LO );
    CALL M$OPEN( OPEN_LO )  ALTRET( OPEN_ERR );
    GOTO SET_DCB_CORRES;
 
BAD_FID:
    LO_BUF= '* Bad FID *';
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    GOTO SET_DCB_CORRES;
 
OPEN_ERR:
    CALL L$MONERR;
    FID_STRING= 'ME';
    CALL M$FID( FID_LO )  ALTRET( BAD_FID );
    CALL M$OPEN( OPEN_LO );
SET_DCB_CORRES:
    CALL L$CORRES( M$DO#, M$LO#, DONELO );
    CALL L$CORRES( M$LO#, DCBNUM(M$ME), LONEME );
    IF M$LO$->F$DCB.WIDTH# > 0 THEN
         LO_WIDTH= M$LO$->F$DCB.WIDTH#;
    ELSE LO_WIDTH= 132;
    RETURN;
 
END DO_OUTPUT;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   P R I N T                                                           *
*                                                                              *
*    Syntax: P/rint [ fieldname1 [, fieldname2 ] ]                             *
*                                                                              *
\******************************************************************************/
DO_PRINT: PROC  ALTRET;
 
    IF BLK3$->P_OUT.NSUBLKS > 0 THEN
         CALL DO_DISPLAY  ALTRET( OOPS );
    IF NUM_JOBS <= 0 THEN DO;
         DO CASE( SEARCH_QUEUE );
           CASE( SE_ALL# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs to PRINT';
             ELSE LO_BUF= '.. YOU have no jobs to PRINT';
           CASE( SE_RUNNING# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (running) to PRINT';
             ELSE LO_BUF= '.. YOU have nothing (running) to PRINT';
           CASE( SE_INPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (waiting to run) to PRINT';
             ELSE LO_BUF= '.. YOU have nothing (waiting to run) to PRINT';
           CASE( SE_OUTPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (in OUTPUT queue) to PRINT';
             ELSE LO_BUF= '.. YOU have nothing (in OUTPUT queue) to PRINT';
           END;
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
%EJECT;
    LINE_CNT= PAGE_SIZE + 1;  /* Force New Heading */
    Q$= PINCRW( GDS_RESULTS_.PTR$, 2 ); /* = ADDR(VLR_ISRCH.J(0)) */
    IF SEARCH_QUEUE ~= SE_OUTPUT# THEN
         DO I=0 TO NUM_JOBS-1;
           IF SEARCH_QUEUE = SE_ALL# THEN
                IF BROKEN > 0 THEN
                     GOTO PUT_PRINT_SUM;
                ELSE CALL DISPLAY_LINE(I);
           ELSE IF SEARCH_QUEUE = SE_RUNNING# THEN
                     IF Q$->IQ.PRIO = 16 THEN
                          IF BROKEN > 0 THEN
                               GOTO PUT_PRINT_SUM;
                          ELSE CALL DISPLAY_LINE(I);
                     ELSE;
                ELSE IF SEARCH_QUEUE = SE_INPUT# THEN
                          IF Q$->IQ.PRIO ~= 16 THEN
                               IF BROKEN > 0 THEN
                                    GOTO PUT_PRINT_SUM;
                               ELSE CALL DISPLAY_LINE(I);
                          ELSE;
           Q$= PINCRC(Q$,LENGTHC(VLR_ISRCH.J(0)));  /* ADDR(VLR_ISRCH.J(I+1)) */
           END; /* end of DO I=0 TO NUM_JOBS-1 */
    ELSE DO I=0 TO NUM_JOBS-1;
           IF BROKEN > 0 THEN
                GOTO PUT_PRINT_SUM;
           ELSE CALL DISPLAY_LINE(I);
           Q$= PINCRC(Q$,SIZEC(VLR_OSRCH.F(0)));  /* ADDR(VLR_OSRCH.F(I+1)) */
           END;
    BROKEN= 0;
 
PUT_PRINT_SUM:
    CALL PUT_NUM_LISTED( LISTED, 0 );
    RETURN;
 
OOPS:
    ALTRETURN;
END DO_PRINT;
/******************************************************************************\
*                                                                              *
*    D O   R E S E T                                                           *
*                                                                              *
*    Syntax: RE/set display                                                    *
*                                                                              *
\******************************************************************************/
DO_RESET: PROC;
 
    IF SEARCH_QUEUE = SE_OUTPUT# THEN DO;
         FIELD_NUM(1)    = DO_AHEAD#;     /* setup default output field names */
         FIELD_NUM(2)    = DO_SYSID#;
         FIELD_NUM(3)    = DO_NUM#;
         FIELD_NUM(4)    = DO_ACCOUNT#;
         FIELD_NUM(5)    = DO_PRIO#;
         FIELD_NUM(6)    = DO_COPIES#;
         FIELD_NUM(7)    = DO_GRANS#;
         FIELD_NUM(8)    = DO_FORM#;
         FIELD_NUM(9)    = DO_TNAME#;
         FIELD_NUM(10)   = DO_DEVNAME#;
         FIELD_NUM(11)   = DO_MODE#;
         FIELD_NUM(12)   = DO_JOBNAME#;
         FIELD_NUM(13)   = DEFAULT_FIELD#;
         FIELD_TITLE(%DO_NUM# - %DI##)= 'NUM ';
         FIELD_TITLE_LEN(%DO_NUM# - %DI##)= LENGTHC('NUM ');
         NUM_FIELDS      = 12;
         END;
    ELSE DO;
           FIELD_NUM(1)  = DI_AHEAD#;     /* setup default input field names  */
           FIELD_NUM(2)  = DI_PRI#;
           FIELD_NUM(3)  = DI_SYSID#;
           FIELD_NUM(4)  = DI_O#;
           FIELD_NUM(5)  = DI_A#;
           FIELD_NUM(6)  = DI_RA#;
           FIELD_NUM(7)  = DI_MAX_TIME#;
           FIELD_NUM(8)  = DI_MEM#;
           FIELD_NUM(9)  = DI_TAPES#;
           FIELD_NUM(10) = DI_SPINDLES#;
           FIELD_NUM(11) = DI_ACCOUNT#;
           FIELD_NUM(12) = DI_PART#;
           FIELD_NUM(13) = DI_JOBNAME#;
           FIELD_NUM(14) = DEFAULT_FIELD#;
           NUM_FIELDS    = 13;
         END;
    SI_CNT= 0;
    CALL BUILD_TITLE;                     /* Build the title line             */
 
END DO_RESET;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   S C A N                                                             *
*                                                                              *
*    Syntax: SC/an { M/E | A/ll }   or                                         *
*            M/E                    or                                         *
*            S/ystem                                                           *
*                                                                              *
\******************************************************************************/
DO_SCAN: PROC( SCAN_TYPE )  ALTRET;
DCL SCAN_TYPE                UBIN;
 
    IF SCAN_TYPE = ME## THEN
         CALL M$RPRIV(FPT_PRIV);
    ELSE CALL M$SPRIV(FPT_PRIV)  ALTRET(DIDNT_GET_PRIV);
    NEW_CRITERIA= YES;
    RETURN;
 
DIDNT_GET_PRIV:
    LO_BUF= '..Sorry.  You can only look at YOUR jobs/OUTPUT';
    IF CMD_LEN < 0 THEN           /* If NOT the default command then complain */
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    RETURN;
 
END DO_SCAN;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   S E A R C H                                                         *
*                                                                              *
*    Syntax: [ SE/arch ] { A/ll | I/nput | O/utput | R/unning }                *
*                                                                              *
\******************************************************************************/
 
DO_SEARCH: PROC;
 
    SEARCH_QUEUE= BLK3$->P_OUT.SUBLK$(0)->P_SYM.CODE;
    CALL DO_RESET;
    NEW_CRITERIA= YES;
    DO CASE( SEARCH_QUEUE );
      CASE( SE_ALL# );
        IF VLP_CRITERIA.RUNNING# = '1'B THEN DO;
          VLP_CRITERIA.RUNNING#= '0'B;
          NEW_CRITERIA= YES;
          END;
 
      CASE( SE_RUNNING# );
        IF VLP_CRITERIA.RUNNING# = '0'B THEN DO;
          VLP_CRITERIA.RUNNING#= '1'B;
          NEW_CRITERIA= YES;
          END;
 
      CASE( SE_INPUT# );
        IF VLP_CRITERIA.RUNNING# = '1'B THEN DO;
          VLP_CRITERIA.RUNNING#= '0'B;
          NEW_CRITERIA= YES;
          END;
 
      CASE( SE_OUTPUT# );
        VLP_CRITERIA.RUNNING#= '0'B;
        NEW_CRITERIA= YES;
      CASE( ELSE );
        LO_BUF= '* Oops! Someone added a SEARCH option w/o changing RQ';
        CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
 
      END;
 
END DO_SEARCH;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   T A L L Y                                                           *
*                                                                              *
*    Syntax: T/ally [ { .[account] | @[wsn] | form } ]                         *
*                                                                              *
\******************************************************************************/
DO_TALLY: PROC;
 
    IF NUM_JOBS <= 0 THEN DO;
         DO CASE( SEARCH_QUEUE );
           CASE( SE_ALL# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. No jobs to TALLY';
             ELSE LO_BUF= '.. YOU have no jobs to TALLY';
           CASE( SE_RUNNING# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (running) to TALLY';
             ELSE LO_BUF= '.. YOU have nothing (running) to TALLY';
           CASE( SE_INPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (waiting to run) to TALLY';
             ELSE LO_BUF= '.. YOU have nothing (waiting to run) to TALLY';
           CASE( SE_OUTPUT# );
             IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                  LO_BUF= '.. Nothing (in OUTPUT queue) to TALLY';
             ELSE LO_BUF= '.. YOU have nothing (in OUTPUT queue) to TALLY';
           END;
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
%EJECT;
    TALLY_ACCT= ' ';
    TALLY_FORM= ' ';
    TALLY_WSN=  ' ';
    IF BLK3$->P_OUT.NSUBLKS > 0 THEN DO;
         LOOKING_AT_ALL= NO;
         BLK4$= BLK3$->P_OUT.SUBLK$(0);
         IF BLK4$->P_OUT.NSUBLKS > 0 THEN DO;
              BLK5$= BLK4$->P_OUT.SUBLK$(0);
              IF BLK4$->P_SYM.CODE = ACCT## THEN
                   TALLY_ACCT= BLK5$->P_SYM.TEXT;
              ELSE IF BLK4$->P_SYM.CODE = WSN## THEN
                        TALLY_WSN= BLK5$->P_SYM.TEXT;
                   ELSE TALLY_FORM= BLK5$->P_SYM.TEXT;
              END;
         ELSE IF BLK4$->P_SYM.CODE = ACCT## THEN
                   TALLY_ACCT= B$JIT.ACCN;
              ELSE IF BLK4$->P_SYM.CODE = WSN## THEN
                        TALLY_WSN= B$JIT.WOO;
                   ELSE DO;
                          CALL DO_SCAN( SE_ALL# );
                          LOOKING_AT_ALL= YES;
                        END;
         END;
    ELSE LOOKING_AT_ALL= YES;
 
    NUM_TALLIES= -1;
    TOT_GRANS= 0;
    TOT_TALLIES= 0;
    Q$= PINCRW( GDS_RESULTS_.PTR$, 2 );
    IF SEARCH_QUEUE = SE_OUTPUT# THEN
         CALL DO_TALLY_OUTPUT;
    ELSE CALL DO_TALLY_INPUT;
    RETURN;
 
END DO_TALLY;
%EJECT;
/******************************************************************************\
*                                                                              *
*    D O   X E Q                                                               *
*                                                                              *
*    Syntax: X/eq fid                                                          *
*                                                                              *
\******************************************************************************/
 
DO_XEQ: PROC  ALTRET;
 
    IF CMNDS_IN_FILE THEN DO;
         LO_BUF= '* Can''t have XEQ within a command file *';
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
    BLK3$= BLK3$->P_OUT.SUBLK$(0);
    FID_STRING= BLK3$->P_SYM.TEXT;
    CALL M$FID(FID_SI)  ALTRET(XEQ_ERR);
    CMNDS_IN_FILE= YES;
    ALTRETURN;
 
XEQ_ERR:
    LO_BUF= '* BAD FID *';
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    RETURN;
 
END DO_XEQ;
%EJECT;
/***************/
/*             */
/*    E O J    */
/*             */
/***************/
 
EOJ: PROC(ERR_CODE);
 
  DCL ERR_CODE               BIT(36);
 
    CALL M$CLOSE(CLOSE_LO);
    IF ADDR(ERR_CODE) = ADDR(NIL) THEN
         CALL M$EXIT;
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF THEN   /* EOF? */
         CALL M$EXIT;
CALL_ERRMSG:
    CALL L$MONERR;
    CALL M$XXX;
 
END EOJ;
%EJECT;
/***********************/
/*                     */
/*    R E A D   S I    */
/*                     */
/***********************/
 
READ_SI: PROC  ALTRET;
 
    SI_CNT= SI_CNT + 1;
    IF CMD_LEN < 0 THEN DO;
         SI_BUF= ' ';
         CALL M$READ(REED_SI)  ALTRET(SI_ERROR);
         SI_ARS= M$SI$->F$DCB.ARS#;
         END;
    ELSE IF SI_CNT > 1 THEN
              ALTRETURN;
         ELSE SI_ARS= CMD_LEN;
    IF CMNDS_IN_FILE  AND
       ECHO THEN DO;
         CALL INSERT(LO_BUF,0,132,
                       '<',
                       SUBSTR(SI_BUF,0,131));
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         END;
    RETURN;
 
SI_ERROR:
    ALTRETURN;
 
END READ_SI;
%EJECT;
/*******************************/
/*                             */
/*    B U I L D   T I T L E    */
/*                             */
/*******************************/
BUILD_TITLE: PROC;
 
    TITLE_INDX= 0;
    TITLE= ' ';
    DO K=1 TO NUM_FIELDS;
      J2= FIELD_NUM(K);
      FIELD_BEG(J2 - DI##) = TITLE_INDX;
      TITLE_LEN= FIELD_TITLE_LEN(J2 - DI##);
      CALL INSERT(TITLE,TITLE_INDX,TITLE_LEN,FIELD_TITLE(J2 - DI##));
      TITLE_INDX= TITLE_INDX + TITLE_LEN;
      END;
 
END BUILD_TITLE;
%EJECT;
READ_QUE: PROC  ALTRET;
 
    DO WHILE( '0'B );
JOBSTATS_ERR:
      ERROR_CODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
      IF ERROR_CODE.ERR# ~= %E$NOTFND THEN
           IF ERROR_CODE.ERR# = %E$JSIRAS  OR
              ERROR_CODE.ERR# = %E$BADVECT2 THEN
                CALL EXPAND( GDS_RESULTS_,1024 )  ALTRET( CANT_GDS );
           ELSE IF ERROR_CODE.ERR# = %E$JSIRLS THEN
                     CALL EXPAND( GDS_RESLIST_,1024 )  ALTRET( CANT_GDS );
                ELSE IF ERROR_CODE.ERR# = %E$JSISLS THEN
                          CALL EXPAND( GDS_SNLIST_,1024 )  ALTRET( CANT_GDS );
                     ELSE CALL EOJ( ERROR_CODE );
      ELSE DO;
             NUM_JOBS= 0;  /* Nothing in selected queue */
             RETURN;
           END;
      FPT_ISRCH.RESULTS_= GDS_RESULTS_;
      FPT_OSRCH.RESULTS_= GDS_RESULTS_;
      FPT_ISRCH.RESLIST_= GDS_RESLIST_;
      FPT_ISRCH.SNLIST_=  GDS_SNLIST_;
      END;
 
    IF SEARCH_QUEUE = SE_OUTPUT# THEN
         CALL M$JOBSTATS( FPT_OSRCH )  ALTRET( JOBSTATS_ERR );
    ELSE CALL M$JOBSTATS( FPT_ISRCH )  ALTRET( JOBSTATS_ERR );
 
    DO WHILE('0'B);
CANT_GDS:
      LO_BUF= 'WARNING: Unable to look at entire QUEUE; Not enough memory';
      CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
      FPT_ISRCH.RESULTS_= GDS_RESULTS_;
      FPT_OSRCH.RESULTS_= GDS_RESULTS_;
      FPT_ISRCH.RESLIST_= GDS_RESLIST_;
      FPT_ISRCH.SNLIST_=  GDS_SNLIST_;
      END;
 
    IF GDS_RESULTS_.PTR$ ~= ADDR(NIL) THEN
         NUM_JOBS= GDS_RESULTS_.PTR$ -> VLR_ISRCH.FOUND;
    ELSE NUM_JOBS= 0;
    TBL$= PINCRW(OUT_AHEAD_.PTR$,NUM_JOBS);
    IF SEARCH_QUEUE ~= SE_OUTPUT# THEN
         RETURN;
%EJECT;
    MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
    NUM_TALLIES= -1;
    Q$= PINCRW( GDS_RESULTS_.PTR$, 2 );  /* = ADDR(VLR_OSRCH.F(0)) */
    DO Q1 = 0 TO NUM_JOBS-1;
      DO Q2 = 0 TO NUM_TALLIES;
        IF Q$->OQ.FORM = TBL.FORM(Q2)  AND
           Q$->OQ.WOD = TBL.WSN(Q2)  THEN DO;
             IF Q$->OQ.DEVNAME = '  ' THEN
                  TBL.AHEAD(Q2)= TBL.AHEAD(Q2) + 1;
             OUT_AHEAD(Q1)= TBL.AHEAD(Q2);
             TBL.TALLY(Q2)= TBL.TALLY(Q2) + 1;
             Q2= NUM_TALLIES+5;  /* Terminate loop */
             END;
        END;
      IF Q2 < NUM_TALLIES+5 THEN DO;          /* New FORM/WSN?                */
           NUM_TALLIES= NUM_TALLIES + 1;
           IF NUM_TALLIES >= MAX_TBL_ENTRIES THEN DO;
              CALL EXPAND( OUT_AHEAD_,1024,TBL_END$ )  ALTRET( ALT_RETURN );
              MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
              END;
           TBL.TALLY(NUM_TALLIES)= 1;
           IF Q$->OQ.DEVNAME = '  ' THEN
                TBL.AHEAD(NUM_TALLIES)= 0;
           ELSE TBL.AHEAD(NUM_TALLIES)= -1;   /* It's currently outputting    */
           TBL.FORM(NUM_TALLIES)= Q$->OQ.FORM;
           TBL.WSN(NUM_TALLIES)= Q$->OQ.WOD;
           OUT_AHEAD(Q1)= 0;
           END;
      Q$= PINCRC( Q$, SIZEC(VLR_OSRCH.F(0)) );/* = ADDR( VLR_OSRCH.F(Q1+1)) */
      END;
 
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END READ_QUE;
%EJECT;
/*********************************/
/*                               */
/*    D I S P L A Y   L I N E    */
/*                               */
/*********************************/
DISPLAY_LINE: PROC(ENTRY_NUM);
%INCLUDE XUD_UTS_M;
%XUD$UTS_ENTRIES;
%XUD_UTS_EQU;
DCL ENTRY_NUM                UBIN;
 
    LISTED= LISTED + 1;
    LO_BUF= ' ';
    DO J=1 TO NUM_FIELDS;
      J2= FIELD_NUM(J);
      BEG= FIELD_BEG(J2 - DI##);
      K= 0;
      DO CASE( J2 );
        CASE( DI_ACCOUNT# );                        /* ACCOUNT                */
          CALL INSERT(LO_BUF,BEG,8,Q$->IQ.ACCT);
        CASE( DI_AHEAD# );                          /* AHEad                  */
          IF Q$->IQ.START_TIME = 0  THEN DO;
               CALL BINCHAR(INT3,Q$->IQ.AHEAD);
               CALL EDITSTR(INT3,0,2,'102'O,INT3);
               CALL INSERT(LO_BUF,BEG,3,INT3);
               END;
          ELSE CALL INSERT(LO_BUF,BEG,3,'run');
        CASE( DI_A# );                              /* Account                */
          IF Q$->IQ.FLG.ACC THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_DEFERRED# );                       /* DEFERRED TILL          */
          IF Q$->IQ.FLG.RA THEN DO;
            UTS= Q$->IQ.RATIM;
            CALL M$TIME(CONV_UTS);
            CALL INSERT(LO_BUF,BEG,14,SUBSTR(HHMMSSSS,0,5),
                                      ' ',
                                      GREG_DATE);
            END;
        CASE( DI_FNAME# );                          /* FOLLOWS JNAME          */
 
        CASE( DI_FREL# );                           /* FOLLOW RELATION        */
          IF Q$->IQ.NFOLL > 0 THEN
               CALL PUT_FOLLOW_ENTRY( J2, K );
        CASE( DI_FSAT# );                           /* FOLLOW SATISFIED       */
          IF Q$->IQ.NFOLL > 0 THEN
               CALL PUT_FOLLOW_ENTRY( J2, K );
        CASE( DI_FSCC# );                           /* FOLLOW STEPCC          */
          IF Q$->IQ.NFOLL > 0 THEN
               CALL PUT_FOLLOW_ENTRY( J2, K );
        CASE( DI_FSYSID# );                         /* FOLLOW SYSID           */
          IF Q$->IQ.NFOLL > 0 THEN
               CALL PUT_FOLLOW_ENTRY( J2, K );
        CASE( DI_F# );                              /* FOLLOWS                */
          IF Q$->IQ.FLG.O3 THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_IPR# );                            /* Initial Priority       */
          CALL BINCHAR(INT3,Q$->IQ.IPRIO);
          CALL EDITSTR(INT3,0,2,'102'O,INT3);
          CALL INSERT(LO_BUF,BEG,3,INT3);
        CASE( DI_IR# );                             /* Is Rerunning           */
          IF Q$->IQ.FLG.RR2 THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_JOBNAME# );                        /* Job Name               */
          CALL INSERT(LO_BUF,BEG,31,Q$->IQ.JNAME);
        CASE( DI_MEM# );                            /* MEMORY                 */
          CALL BINCHAR(INT4,Q$->IQ.RRT(0));
          CALL EDITSTR(INT4,0,3,'103'O,INT4);
          CALL INSERT(LO_BUF,BEG,4,INT4);
        CASE( DI_NFO# );                            /* NFOLLOW                */
          CALL BINCHAR(INT3,Q$->IQ.NFOLL);
          CALL EDITSTR(INT3,0,2,'102'O,INT3);
          CALL INSERT(LO_BUF,BEG,3,INT3);
        CASE( DI_NPI# );                            /* No Priority Increment  */
          IF Q$->IQ.FLG.NPI THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_NRES# );                           /* Number of Resources    */
          CALL BINCHAR(INT6,Q$->IQ.NRES);
          CALL EDITSTR(INT6,0,5,'105'O,INT6);
          CALL INSERT(LO_BUF,BEG,6,INT6);
        CASE( DI_NSN# );                            /* Number of SN's         */
          CALL BINCHAR(INT6,Q$->IQ.NSN);
          CALL EDITSTR(INT6,0,5,'105'O,INT6);
          CALL INSERT(LO_BUF,BEG,6,INT6);
        CASE( DI_OPD# );                            /* Other Physical Devices */
          CALL BINCHAR( INT3, Q$->IQ.RRT(3) );
          CALL EDITSTR( INT3,0,2,'102'O,INT3 );
          CALL INSERT( LO_BUF,BEG,3,INT3 );
        CASE( DI_O# );                              /* Order                  */
          IF Q$->IQ.FLG.O1 THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_P1# );                             /* Pseudo 1               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(4) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2 );
        CASE( DI_P2# );                             /* Pseudo 2               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(5) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P3# );                             /* Pseudo 3               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(6) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P4# );                             /* Pseudo 4               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(7) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P5# );                             /* Pseudo 5               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(8) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P6# );                             /* Pseudo 6               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(9) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P7# );                             /* Pseudo 7               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(10) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_P8# );                             /* Pseudo 8               */
          CALL BINCHAR( INT2, Q$->IQ.RRT(11) );
          CALL EDITSTR( INT2,0,1,'101'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2);
        CASE( DI_PART# );                           /* Partition mask         */
          IF Q$->IQ.PRIO ~= 16 THEN   /* JOB NOT RUNNING? */
               PART_MASK_B18= Q$->IQ.PART;
          ELSE DO;
                 PART_MASK_B18= '0'B;                 /* Zero all partitions  */
                 PART_MASK_B1(Q$->IQ.PNUM - 1)= '1'B; /* fill in one in use   */
               END;
          DO K=0 TO 15;
            IF PART_MASK_B1(K) THEN
                 CALL INSERT(LO_BUF,BEG+K,1,HEXCHARS(K));
            ELSE CALL INSERT(LO_BUF,BEG+K,1,'.');
            END;
        CASE( DI_PI# );                             /* Priority Increment     */
          CALL BINCHAR(INT3,Q$->IQ.PI);
          CALL EDITSTR(INT3,0,2,'102'O,INT3);
          CALL INSERT(LO_BUF,BEG,3,INT3);
        CASE( DI_PNUM# );                           /* Partition Number       */
          CALL BINCHAR(INT3,Q$->IQ.PNUM);
          CALL EDITSTR(INT3,0,2,'102'O,INT3);
          CALL INSERT(LO_BUF,BEG,3,INT3);
        CASE( DI_PRI# );                            /* Priority               */
          CALL BINCHAR(INT3,Q$->IQ.PRIO);
          CALL EDITSTR(INT3,0,2,'102'O,INT3);
          CALL INSERT(LO_BUF,BEG,3,INT3);
        CASE( DI_RA# );                             /* Run after(Defer)       */
          IF Q$->IQ.FLG.RA THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_R# );                              /* Rerun                  */
          IF Q$->IQ.FLG.RR THEN
            CALL INSERT(LO_BUF,BEG,1,'Y');
        CASE( DI_RESX# );                           /* Resource Index         */
          CALL BINCHAR(INT6,Q$->IQ.RESX);
          CALL EDITSTR(INT6,0,5,'105'O,INT6);
          CALL INSERT(LO_BUF,BEG,6,INT6);
        CASE( DI_SNX# );                            /* SN list Index          */
          CALL BINCHAR(INT6,Q$->IQ.SNX);
          CALL EDITSTR(INT6,0,5,'105'O,INT6);
          CALL INSERT(LO_BUF,BEG,6,INT6);
        CASE( DI_SPINDLES# );                       /* SPINDLES               */
          CALL BINCHAR(INT2,Q$->IQ.RRT(1));
          CALL EDITSTR(INT2,0,1,'101'O,INT2);
          CALL INSERT(LO_BUF,BEG,2,INT2);
        CASE( DI_START_TIME# );                     /* JOB STARTED            */
          IF Q$->IQ.START_TIME ~= 0 THEN DO;
            UTS= Q$->IQ.START_TIME;
            CALL M$TIME(CONV_UTS);
            CALL INSERT(LO_BUF,BEG,14,SUBSTR(HHMMSSSS,0,5),
                                      ' ',
                                      GREG_DATE);
            END;
        CASE( DI_SUBMIT_TIME# );                    /* SUBMITTED              */
          UTS= Q$->IQ.SUBMIT_TIME;
          CALL M$TIME(CONV_UTS);
          CALL INSERT(LO_BUF,BEG,14,SUBSTR(HHMMSSSS,0,5),
                                    ' ',
                                    GREG_DATE);
        CASE( DI_SYSID# );                          /* SYSID                  */
          CALL BINCHAR(INT6,Q$->IQ.SYSID);
          CALL EDITSTR(INT6,0,5,'105'O,INT6);
          IF B$JIT.SYSID < 100000 THEN
               CALL INSERT(LO_BUF,BEG,5,SUBSTR(INT6,1,5));
          ELSE CALL INSERT(LO_BUF,BEG,6,INT6);
        CASE( DI_TAPES# );                          /* TAPES                  */
          CALL BINCHAR(INT2,Q$->IQ.RRT(2));
          CALL EDITSTR(INT2,0,1,'101'O,INT2);
          CALL INSERT(LO_BUF,BEG,2,INT2);
        CASE( DI_MAX_TIME# );                       /* MAX TIME               */
          CALL XUD$UTS_DIFF_SEC(UTS,Q$->IQ.TIM,0);
          HOUR= UTS/3600;
          UTS= UTS-(HOUR*3600);
          MIN= UTS/60;
          SEC= MOD(UTS,60);
          CALL BINCHAR(INT2,HOUR);
          CALL BINCHAR(INT3,MIN);
          CALL BINCHAR(INT4,SEC);
          CALL INSERT(LO_BUF,BEG,8,
                             INT2,
                             ':',
                             SUBSTR(INT3,1,2),
                             ':',
                             SUBSTR(INT4,2,2));
          DO K=BEG TO BEG+4;
            IF SUBSTR(LO_BUF,K,1) >  '0'  AND
               SUBSTR(LO_BUF,K,1) <= '9' THEN
                 K= BEG+5;
            ELSE CALL INSERT(LO_BUF,K,1,' ');
            END;
        CASE( DI_USER# );                           /* User #                 */
 
        CASE( DI_USERNAME# );                       /* User Name              */
          CALL INSERT(LO_BUF,BEG,12,Q$->IQ.UNAME);
        CASE( DI_WOO# );                            /* WOO                    */
          CALL INSERT(LO_BUF,BEG,8,Q$->IQ.WOO);
        CASE( DI_WSN# );                            /* WSN                    */
          CALL INSERT(LO_BUF,BEG,8,Q$->IQ.WSN);
%EJECT;
        CASE( DO_ACCOUNT# );                        /* ACcount                */
          CALL INSERT( LO_BUF,BEG,8,Q$->OQ.ACCT );
        CASE( DO_AHEAD# );                          /* AHead                  */
          IF Q$->OQ.DEVNAME = '  ' THEN DO;
               CALL BINCHAR( INT4,OUT_AHEAD(ENTRY_NUM) );
               CALL EDITSTR( INT4,0,3,'103'O,INT4 );
               IF OUT_AHEAD(ENTRY_NUM) < 100 THEN
                    CALL INSERT( LO_BUF,BEG,8,
                                   SUBSTR(INT4,2,2),
                                   ' Ahead' );
               ELSE IF OUT_AHEAD(ENTRY_NUM) < 1000 THEN
                         CALL INSERT( LO_BUF,BEG,8,
                                        SUBSTR(INT4,1,3),
                                        ' Ahed' );
                    ELSE IF OUT_AHEAD(ENTRY_NUM) < 10000 THEN
                              CALL INSERT( LO_BUF,BEG,8,
                                             INT4,
                                             ' Ahd' );
                         ELSE LO_BUF= 'Lots Ahd';
               END;
          ELSE
             DO SELECT( Q$->OQ.DEVTYP );
                SELECT( 'CP' );
                   CALL INSERT( LO_BUF,BEG,8,'Punching ' );
                SELECT( 'JE' );
                   CALL INSERT( LO_BUF,BEG,8,'Beaming ' );
                SELECT( 'LP' );
                   CALL INSERT( LO_BUF,BEG,8,'Printing' );
                SELECT( 'LZ', 'LE' );
                   CALL INSERT( LO_BUF,BEG,8,'Lasing  ' );
                SELECT( 'PL' );
                   CALL INSERT( LO_BUF,BEG,8,'Plotting' );
                SELECT( 'PR' );
                   CALL INSERT( LO_BUF,BEG,8,'Typing  ' );
                SELECT( ELSE );
                   CALL INSERT( LO_BUF,BEG,8,'Beats me' );
                END;
        CASE( DO_ATTR# );                           /* ATtributes             */
          PART_MASK_B18= Q$->OQ.ATTR;
          DO K=0 TO 17;
            IF PART_MASK_B1(K) THEN
                 CALL INSERT( LO_BUF,BEG+K,1,HEXCHARS(K) );
            ELSE CALL INSERT( LO_BUF,BEG+K,1,'.' );
            END;
        CASE( DO_BOOTID# );                         /* Bootid                 */
          CALL INSERT( LO_BUF,BEG,3,Q$->OQ.BOOTID );
        CASE( DO_COPIES# );                         /* Copies                 */
          CALL BINCHAR( INT4, Q$->OQ.COPIES );
          CALL EDITSTR( INT4,0,3,'103'O,INT4 );
          CALL INSERT( LO_BUF,BEG,4,INT4 );
        CASE( DO_DEVNAME# );                        /* DEVName                */
          CALL INSERT( LO_BUF,BEG,2,Q$->OQ.DEVTYP );
          CALL INSERT( LO_BUF,BEG+2,2,Q$->OQ.DEVNAME );
        CASE( DO_DEVTYP# );                         /* DEVType                */
          CALL INSERT( LO_BUF,BEG,2,Q$->OQ.DEVTYP );
          CALL INSERT( LO_BUF,BEG+2,2,Q$->OQ.DEVNAME );
        CASE( DO_GLC# );                            /* GLc                    */
          IF Q$->OQ.FLG.GLC THEN
               CALL INSERT( LO_BUF,BEG,3,' Y ' );
          ELSE CALL INSERT( LO_BUF,BEG,3,' N ' );
        CASE( DO_FORM# );                           /* FOrm                   */
          CALL INSERT( LO_BUF,BEG,6,Q$->OQ.FORM );
        CASE( DO_GRANS# );                          /* GRans                  */
          CALL BINCHAR( INT5, Q$->OQ.GRANS );
          CALL EDITSTR( INT5,0,4,'104'O,INT5 );
          CALL INSERT( LO_BUF,BEG,5,INT5 );
        CASE( DO_HICNUM# );                         /* Hicnum                 */
          CALL BINCHAR( INT3, Q$->OQ.HICNUM );
          CALL EDITSTR( INT3,0,2,'102'O,INT3 );
          CALL INSERT( LO_BUF,BEG,3,INT3 );
        CASE( DO_JOBNAME# );                        /* Job name               */
          CALL INSERT( LO_BUF,BEG,31,Q$->OQ.JNAME );
        CASE( DO_MODE# );                           /* MOde                   */
          IF Q$->OQ.MODE = %MODE_BATCH# THEN
               CALL INSERT( LO_BUF,BEG,2,'B ' );
          ELSE IF Q$->OQ.MODE = %MODE_GHOST# THEN
                    CALL INSERT( LO_BUF,BEG,2,'G ' );
               ELSE IF Q$->OQ.MODE = %MODE_INT# THEN
                         CALL INSERT( LO_BUF,BEG,2,'O ' );
                    ELSE CALL INSERT( LO_BUF,BEG,2,'T ' );
        CASE( DO_NUM# );                            /* Num                    */
          CALL BINCHAR( INT6, Q$->OQ.NUM );
          CALL EDITSTR( INT6,0,5,'105'O,INT6 );
          CALL INDEX1R( K,' ',INT6 );
          IF K < 2 THEN                       /* Is NUM > 999?                */
             IF FIELD_TITLE_LEN(%DO_NUM# - %DI##) = 4 THEN DO; /* Field big?  */
                FIELD_TITLE_LEN(%DO_NUM# - %DI##)= LENGTHC('   NUM ');/* Nope!*/
                FIELD_TITLE(%DO_NUM# - %DI##)= '   NUM ';  /* Make it big!    */
                CALL BUILD_TITLE;
                LINE_CNT= PAGE_SIZE + 1;      /* Force new headings           */
                END;
          K= LENGTHC(INT6) - FIELD_TITLE_LEN(%DO_NUM# - %DI##) + 1;
          CALL INSERT( LO_BUF,BEG,FIELD_TITLE_LEN(%DO_NUM# - %DI##)-1,
                          SUBSTR(INT6,K) );
        CASE( DO_PRIO# );                           /* PRIority               */
          CALL BINCHAR( INT2, Q$->OQ.PRIO );
          CALL EDITSTR( INT2,0,2,'102'O,INT2 );
          CALL INSERT( LO_BUF,BEG,2,INT2 );
        CASE( DO_SAPCOPIES# );                      /* SAPCopies              */
          CALL BINCHAR( INT4,Q$->OQ.SAPCOPIES );
          CALL EDITSTR( INT4,0,3,'103'O,INT4 );
          CALL INSERT( LO_BUF,BEG,4,INT4 );
        CASE( DO_SAP# );                            /* SAP                    */
          IF Q$->OQ.FLG.SAP THEN
               CALL INSERT( LO_BUF,BEG,3,' Y ' );
          ELSE CALL INSERT( LO_BUF,BEG,3,' N ' );
        CASE( DO_SPILL# );                          /* SPill                  */
          IF Q$->OQ.FLG.SPILL THEN
               CALL INSERT( LO_BUF,BEG,5,'  Y  ' );
          ELSE CALL INSERT( LO_BUF,BEG,5,'  N  ' );
        CASE( DO_SYSID# );                          /* SYsid                  */
          CALL BINCHAR( INT6,Q$->OQ.SYSID );
          CALL EDITSTR( INT6,0,5,'105'O,INT6 );
          IF B$JIT.SYSID < 100000 THEN
               CALL INSERT( LO_BUF,BEG,5,SUBSTR(INT6,1,5));
          ELSE CALL INSERT( LO_BUF,BEG,6,INT6 );
        CASE( DO_TNAME# );                          /* TName                  */
          CALL INSERT( LO_BUF,BEG,8,Q$->OQ.WOD );
        CASE( DEFAULT_FIELD# );         /* ?                      */
          CALL INSERT(LO_BUF,BEG,1,'?');
        END;
      END;
    LINE_CNT= LINE_CNT + 1;
    IF LINE_CNT > PAGE_SIZE THEN DO;
      CALL L$WRITE( TITLE, MINIMUM(LENGTHC(TITLE),LO_WIDTH), M$LO# );
      LINE_CNT= 1;
      END;
    CALL L$WRITE( LO_BUF, MINIMUM(LO_LEN,LO_WIDTH), M$LO# );
    IF Q$->IQ.NFOLL > 1 THEN
         CALL PUT_FOLLOW;
    RETURN;
 
END DISPLAY_LINE;
%EJECT;
/***********************/
/*                     */
/*    P U T   E R R    */
/*                     */
/***********************/
 
PUT_ERR: PROC(ERROR, LEN, POS)  ALTRET;
 
DCL ERROR                    CHAR(LEN);
DCL LEN                      UBIN;
DCL POS                      UBIN(14) UNAL;
 
    LO_BUF= ' ';
    LO_INDX= POS + LENGTHC(PROMPT);
    CALL INSERT(LO_BUF,LO_INDX,1,'^');
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    LO_BUF= ERROR;
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    ALTRETURN;
 
END PUT_ERR;
%EJECT;
/*******************************/
/*                             */
/*    V E R I F Y   D A T E    */
/*                             */
/*******************************/
 
VERIFY_DATE: PROC  ALTRET;
 
    CALL M$TIME(GET_TIME_DATE)  ALTRET(OOPS);
    BLK4$= BLK3$->P_OUT.SUBLK$(J+2);
    DO K=0 TO BLK4$->P_SYM.NSUBLKS-1;
      BLK5$= BLK4$->P_OUT.SUBLK$(K);
      IF BLK5$->P_SYM.COUNT < 2 THEN
           CALL INSERT(INT2,0,2,'0',BLK5$->P_SYM.TEXT);
      ELSE CALL INSERT(INT2,0,2,BLK5$->P_SYM.TEXT);
      DO CASE( BLK5$->P_SYM.CODE );
        CASE( THH# );
          TIME.HH= INT2;
        CASE( TMM# );
          TIME.MM= INT2;
        CASE( MM# );
          GREG.MM= INT2;
        CASE( DD# );
          GREG.DD= INT2;
        CASE( YY# );
          GREG.YY= INT2;
        END; /* end DO CASE(BLK5$->P_SYM.CODE) */
      END; /* end DO K=0 TO BLK4$->P_OUT.NSUBLKS-1 */
    TIME.SSSS= '0000';
    CALL M$TIME(GET_UTS)  ALTRET(OOPS);
    CALL BINCHAR(STRG.DEC11,UTS);
    F.STR(NCBS)= STRG.DEC11;
    F.LEN(NCBS)= 11;
    RETURN;
%EJECT;
OOPS:
    BLK4$= BLK3$->P_OUT.SUBLK$(J);
    /* Time and/or date is invalid */
    CALL PUT_ERR(ERROR3,LENGTHC(ERROR3),BLK4$->P_SYM.CPOS);
    ALTRETURN;
 
END VERIFY_DATE;
%EJECT;
/*******************************/
/*                             */
/*    V E R I F Y   T I M E    */
/*                             */
/*******************************/
 
VERIFY_TIME: PROC  ALTRET;
%XUD$UTS_ENTRIES;
 
    HOUR= 0;
    MIN= 0;
    SEC= 0;
    BLK4$= BLK3$->P_OUT.SUBLK$(J+2);
    DO K=0 TO BLK4$->P_SYM.NSUBLKS-1;
      BLK5$= BLK4$->P_OUT.SUBLK$(K);
      IF BLK5$->P_SYM.COUNT < 2 THEN
           CALL INSERT(INT2,0,2,'0',BLK5$->P_SYM.TEXT);
      ELSE CALL INSERT(INT2,0,2,BLK5$->P_SYM.TEXT);
      DO CASE( BLK5$->P_SYM.CODE );
        CASE( THH# );
          CALL CHARBIN(HOUR,INT2);
        CASE( TMM# );
          CALL CHARBIN(MIN,INT2);
        CASE( TSS# );
          CALL CHARBIN(SEC,INT2);
        END;
      END;
    CALL XUD$UTS_ADJ_25TH(UTS,0, ( ( HOUR * 60 * 60 ) + ( MIN * 60 ) + SEC ) * %UTS_25TH_SEC#);
    CALL BINCHAR(STRG.DEC11,UTS);
    F.STR(NCBS)= STRG.DEC11;
    F.LEN(NCBS)= 11;
    RETURN;
 
END VERIFY_TIME;
%EJECT;
PUT_FOLLOW: PROC;
DCL FIELD                    UBIN;
 
    LO_BUF= ' ';
    DO K = 1 TO Q$->IQ.NFOLL - 1;
      DO K2 = 1 TO NUM_FIELDS;
        J2= FIELD_NUM(K2);
        IF J2 = DI_FNAME#   OR
           J2 = DI_FREL#    OR
           J2 = DI_FSAT#    OR
           J2 = DI_FSCC#    OR
           J2 = DI_FSYSID#  THEN DO;
             BEG= FIELD_BEG(J2 - DI##);
             CALL PUT_FOLLOW_ENTRY( J2, K );
             END;
        END;
      IF LO_BUF ~= ' ' THEN
           CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
      END;
    RETURN;
 
END PUT_FOLLOW;
%EJECT;
PUT_FOLLOW_ENTRY: PROC( FIELD, OCCURANCE );
DCL FIELD                    UBIN;
DCL OCCURANCE                UBIN;
 
    DO CASE( FIELD );
      CASE( DI_FREL# );
        DO CASE( Q$->IQ.JDID.RELATION(OCCURANCE) );
          CASE( 0 );
            CALL INSERT(LO_BUF,BEG,3,'  <');
          CASE( 1 );
            CALL INSERT(LO_BUF,BEG,3,' <=');
          CASE( 2 );
            CALL INSERT(LO_BUF,BEG,3,'  =');
          CASE( 3 );
            CALL INSERT( LO_BUF,BEG,3,' ~=');
          CASE( 4 );
            CALL INSERT( LO_BUF,BEG,3,' >=');
          CASE( 5 );
            CALL INSERT( LO_BUF,BEG,3,'  >');
          CASE( ELSE );
            CALL INSERT( LO_BUF,BEG,3,' ??');
          END;
      CASE( DI_FSAT# );
        IF Q$->IQ.JDID.SATISFIED(OCCURANCE) THEN
             CALL INSERT( LO_BUF,BEG,5,'  Y  ');
        ELSE CALL INSERT( LO_BUF,BEG,5,'  N  ');
      CASE( DI_FSCC# );
        CALL BINCHAR( INT3, Q$->IQ.JDSTEPCC(OCCURANCE) );
        CALL EDITSTR( INT3,0,2,'102'O,INT3);
        CALL INSERT( LO_BUF,BEG,3,INT3 );
      CASE( DI_FSYSID# );
        CALL BINCHAR( INT6, Q$->IQ.JDID.SYSID(OCCURANCE) );
        CALL EDITSTR( INT6,0,5,'105'O,INT6 );
        CALL INSERT( LO_BUF,BEG,6,INT6 );
      END;
 
    RETURN;
 
END PUT_FOLLOW_ENTRY;
%EJECT;
PUT_HELP: PROC( HELPCNT, HELP_TYPE, HELP_NUMB )  ALTRET;
DCL HELPCNT                  UBIN;
DCL HELP_TYPE                SBIN;
DCL HELP_NUMB                SBIN;
 
DCL DONE                     BIT(1)    STATIC;
DCL FOUND                    BIT(1)    STATIC;
 
    IF HELPCNT > 7 THEN
         GOTO GOBACK;
 
    IF ADDR(HELP_NUMB) ~= ADDR(NIL) THEN
         HELPCODE.ERR#= HELP_NUMB;
 
    DONE= NO;
    DO WHILE( NOT DONE );
      IF HELPCNT = 6  AND
         HELP_TYPE = TEXT# THEN  /* we don't want EXAMPLES */
           HELPCNT= HELPCNT + 1;
      ELSE IF HELP_TYPE = EXAMPLES# THEN
                HELPCNT= 6;  /* Read only EXamples */
      FOUND= NO;
      DO WHILE( NOT FOUND );
        HELPCODE.SEV= HELPCNT;
        CALL M_ERRMSG  ALTRET( NO_HELP );
        FOUND= YES;
        HELPCNT= HELPCNT + 1;
        IF HELP_TYPE = 999 THEN
             DONE= YES;
        DO WHILE('0'B);
NO_HELP:
          IF HELPCNT < 7 THEN
               IF HELP_TYPE = 0 OR
                  HELP_TYPE = EXAMPLES# THEN
                    GOTO GOBACK;
               ELSE IF HELPCNT < 6 THEN
                         IF HELP_TYPE = TEXT# THEN
                              HELPCNT= 7;  /* 'for more help...' */
                         ELSE HELPCNT= 6;  /* read EXAMPLE next  */
                    ELSE HELPCNT= 7;
          ELSE IF HELP_TYPE = 0 THEN
                    ALTRETURN;
               ELSE GOTO GOBACK;
          END;
        END;
      IF HELP_TYPE = 0  OR
         HELP_TYPE = EXAMPLES#  OR
         HELPCNT > 7  THEN
           DONE= YES;
      IF NOT DONE THEN DO;
           LO_BUF= ' ';
           CALL L$WRITE( LO_BUF, LO_LEN, M$LO# );
           END;
      END;
 
GOBACK:
    IF BROKEN > 0 THEN
         ALTRETURN;
    ELSE IF HELP_TYPE = QUES2#  OR
            HELP_TYPE = TEXT#   OR
           (HELP_TYPE = EXAMPLES#  AND
            FOUND )          THEN DO;
              LO_BUF= ' ';
              CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, 'b' );
              END;
 
END PUT_HELP;
%EJECT;
M_ERRMSG: PROC  ALTRET;
 
%FPT_OPEN (FPTN=OPEN_HELP,
           ACCT=HELP_ACCT,
           ASN=FILE,
           DCB=F$HELP,
           NAME=HELP_NAME,
           PASS=HELP_PASS);
%VLP_PASS (FPTN=HELP_PASS);
%FPT_READ (FPTN=READ_HELP,
           BUF=ERR_MESG,
           DCB=F$HELP,
           KEY=HLP,
           KEYS=YES);
 
DCL 1 HLP  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(5),
      2 CODE                 UBIN(36)  UNAL,
      2 OCCUR#               UBIN(9)   UNAL   INIT(0);
 
    HLP.CODE= HELPNUM;  /* Build help file(ERRMSG) key */
    IF NOT F$HELP$->F$DCB.FCD# THEN
         CALL M$OPEN( OPEN_HELP )  ALTRET( DO_ERRMSG );
    CALL M$READ( READ_HELP )  ALTRET( NO_RECORD );
DO_ERRMSG:
    CALL M$ERRMSG( GETHELP )  ALTRET( NO_RECORD );
    RETURN;
 
NO_RECORD:
    ALTRETURN;
 
END M_ERRMSG;
%EJECT;
DO_TALLY_OUTPUT: PROC  ALTRET;
 
    MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
    DO Q1 = 0 TO NUM_JOBS-1;
        IF LOOKING_AT_ALL  OR
           TALLY_ACCT = Q$->OQ.ACCT  OR
           TALLY_WSN  = Q$->OQ.WOD OR
           TALLY_FORM = Q$->OQ.FORM  THEN
             DO Q2 = 0 TO NUM_TALLIES;
               IF Q$->OQ.ACCT  = TBL.ACCT(Q2)  AND
                  Q$->OQ.PRIO  = TBL.PRIO(Q2)  AND
                  Q$->OQ.WOD = TBL.WSN (Q2)  AND
                  Q$->OQ.FORM  = TBL.FORM(Q2)  THEN DO;
                    TBL.TALLY(Q2)= TBL.TALLY(Q2) + 1;
                    TBL.GRANS(Q2)= TBL.GRANS(Q2) + Q$->OQ.GRANS;
                    GOTO NEXT_Q_ENTRY;
                    END;
               END;
      IF LOOKING_AT_ALL  OR
         TALLY_ACCT = Q$->OQ.ACCT  OR
         TALLY_FORM = Q$->OQ.FORM  OR
         TALLY_WSN  = Q$->OQ.WOD  THEN DO;
           NUM_TALLIES= NUM_TALLIES + 1;
           IF NUM_TALLIES >= MAX_TBL_ENTRIES THEN DO;
              CALL EXPAND( OUT_AHEAD_,1024,TBL_END$ )  ALTRET( ALT_RETURN );
              MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
              END;
           TBL.TALLY(NUM_TALLIES)= 1;
           TBL.ACCT(NUM_TALLIES)= Q$->OQ.ACCT;
           TBL.FORM(NUM_TALLIES)= Q$->OQ.FORM;
           TBL.PRIO(NUM_TALLIES)= Q$->OQ.PRIO;
           TBL.WSN(NUM_TALLIES) = Q$->OQ.WOD;
           TBL.GRANS(NUM_TALLIES)= Q$->OQ.GRANS;
           END;
 
NEXT_Q_ENTRY:
      Q$= PINCRC( Q$, SIZEC(VLR_OSRCH.F(0)) );
      END;
 
    IF NUM_TALLIES >= 0 THEN
         LO_BUF= 'TALLY PRIO GRANS ACCOUNT   FORM   WSN';
    ELSE LO_BUF= '.. None';
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    LO_BUF= ' ';
    DO I = 0 TO NUM_TALLIES;
      CALL BINCHAR( LO2.TALLY, TBL.TALLY(I) );
      CALL EDITSTR( LO2.TALLY,0,3,'103'O,LO2.TALLY );
      CALL BINCHAR( LO2.PRIO,TBL.PRIO(I) );
      CALL EDITSTR( LO2.PRIO,0,2,'102'O,LO2.PRIO );
      CALL BINCHAR( LO2.GRANS,TBL.GRANS(I) );
      CALL EDITSTR( LO2.GRANS,0,4,'104'O,LO2.GRANS );
      LO2.ACCT= TBL.ACCT(I);
      LO2.FORM= TBL.FORM(I);
      LO2.WSN=  TBL.WSN(I);
      TOT_TALLIES= TOT_TALLIES + TBL.TALLY(I);
      TOT_GRANS= TOT_GRANS + TBL.GRANS(I);
      IF BROKEN > 0 THEN
           GOTO PUT_SUMMARY;
      ELSE CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
      END;
 
PUT_SUMMARY:
    IF NUM_TALLIES > 0 THEN DO;
       LO_BUF= '-----      -----';
       CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
       LO_BUF= ' ';
       CALL BINCHAR( LO2.TALLY,TOT_TALLIES );
       CALL EDITSTR( LO2.TALLY,0,3,'103'O,LO2.TALLY );
       CALL BINCHAR( LO2.GRANS,TOT_GRANS );
       CALL EDITSTR( LO2.GRANS,0,4,'104'O,LO2.GRANS );
       CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
       END;
 
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END DO_TALLY_OUTPUT;
%EJECT;
DO_TALLY_INPUT: PROC  ALTRET;
 
    MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(ACT_TBL(0));
    DO Q1 = 0 TO NUM_JOBS-1;
      CHK.ACCT= Q$->IQ.ACCT;
      CHK.PRIO= Q$->IQ.PRIO;
      IF LOOKING_AT_ALL  AND
         CHK.PRIO = %JP_RUNAFTER# THEN DO;
           Q$->IQ.WSN= 'LOCAL';
           CHK.ACCT= ' <many> ';
           END;
      IF LOOKING_AT_ALL  OR
         TALLY_ACCT = CHK.ACCT  OR
         TALLY_WSN  = Q$->IQ.WSN  THEN DO;
           DO Q2 = 0 TO NUM_TALLIES;
             IF CHK_ACCT_PRIO = ACT_TABL(Q2) THEN DO;
                  ACCT_TALLY(Q2)= ACCT_TALLY(Q2) + 1;
                  GOTO NEXT_Q_ENTRY;
                  END;
             END;
 
           NUM_TALLIES= NUM_TALLIES + 1;
           IF NUM_TALLIES >= MAX_TBL_ENTRIES THEN DO;
              CALL EXPAND( OUT_AHEAD_,1024,TBL_END$ )  ALTRET( ALT_RETURN );
              MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(ACT_TBL(0));
              END;
           ACCT_TALLY(NUM_TALLIES)= 1;
           ACT_TBL.ACCT(NUM_TALLIES)= CHK.ACCT;
           ACT_TBL.PRIO(NUM_TALLIES)= CHK.PRIO;
           END;
 
NEXT_Q_ENTRY:
      Q$= PINCRC( Q$, LENGTHC(VLR_ISRCH.J(0)) );
      END;
 
    IF NUM_TALLIES >= 0 THEN
         LO_BUF= 'TALLY ACCOUNT  PRIORITY';
    ELSE LO_BUF= '.. None';
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO# );
    DO I = 0 TO NUM_TALLIES;
      CALL BINCHAR( INT4,ACCT_TALLY(I) );
      CALL EDITSTR( INT4,0,3,'103'O,INT4 );
      LO_BUF= INT4;
      LO.TALLY_ACCT= SUBSTR(ACT_TBL.ACCT(I),0,8);
      CALL BINCHAR( INT3,ACT_TBL.PRIO(I) );
      CALL EDITSTR( INT3,0,2,'102'O,INT3 );
      LO.TALLY_PRIO= INT3;
      TOT_TALLIES= TOT_TALLIES + ACCT_TALLY(I);
      IF ACT_TBL.PRIO(I) > 15 THEN
           LO.TALLY_STATUS= IPRIO_STATUS(ACT_TBL.PRIO(I));
      IF BROKEN > 0 THEN
           GOTO PUT_SUMMARY;
      ELSE CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
      END;
 
PUT_SUMMARY:
    IF NUM_TALLIES > 0 THEN DO;
       LO_BUF= '-----';
       CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
       CALL BINCHAR( INT4,TOT_TALLIES );
       CALL EDITSTR( INT4,0,3,'103'O,INT4 );
       LO_BUF= INT4;
       CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
       END;
 
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END DO_TALLY_INPUT;
%EJECT;
DO_NUMBER_INPUT: PROC;
 
    DO Q1 = 0 TO 21;
      PRIO_TALLY(Q1)= 0;
      END;
 
    DO Q1 = 0 TO NUM_JOBS-1;
      IF LOOKING_AT_ALL            OR
         TALLY_ACCT = Q$->IQ.ACCT  OR
         TALLY_WSN  = Q$->IQ.WSN  THEN
           IF SEARCH_QUEUE = SE_INPUT# THEN
                IF Q$->IQ.PRIO ~= 16 THEN
                     PRIO_TALLY(Q$->IQ.PRIO)= PRIO_TALLY(Q$->IQ.PRIO) + 1;
                ELSE;
           ELSE IF SEARCH_QUEUE = SE_RUNNING# THEN
                     IF Q$->IQ.PRIO = 16 THEN
                          PRIO_TALLY(Q$->IQ.PRIO)= PRIO_TALLY(Q$->IQ.PRIO) + 1;
                     ELSE;
                ELSE PRIO_TALLY(Q$->IQ.PRIO)= PRIO_TALLY(Q$->IQ.PRIO) + 1;
      Q$= PINCRC( Q$, LENGTHC(VLR_ISRCH.J(0)) );
      END;
 
    LO_INDX= 0;
    IF PRIO_TALLY(PINCRC(Q$,-LENGTHC(Q$->IQ))->IQ.PRIO) ~= NUM_JOBS THEN DO;
         CALL BINCHAR(INT5,NUM_JOBS);
         CALL SEARCH(BEG,TABLEVAL,SKIP_ZEROES,INT5);
         LO_BUF= SUBSTR(INT5,BEG,LENGTHC(INT5)-BEG);
         CALL INSERT(LO_BUF,LENGTHC(INT5)-BEG,LENGTHC(' Jobs: '),' Jobs: ');
         LO_INDX= (LENGTHC(INT5) - BEG) + LENGTHC(' Jobs: ');
         POS= LO_INDX;
         END;
    ELSE LO_BUF= ' ';
 
    DO I=0 TO 21;
      IF PRIO_TALLY(I) > 0 THEN DO;
        CALL BINCHAR(INT5,PRIO_TALLY(I));
        CALL SEARCH(BEG,TABLEVAL,SKIP_ZEROES,INT5);
        CALL SEARCHR(TITLE_LEN,TABLEVAL,SKIP_BLANKS,IPRIO_STATUS(I));
        LEN= (LENGTHC(INT5) - BEG) + TITLE_LEN + LENGTHC(', ');
        IF LO_INDX + LEN > M$LO$->F$DCB.WIDTH# THEN DO;
          CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
          LO_BUF= ' ';
          LO_INDX= POS;
          END;
        CALL INSERT(LO_BUF,LO_INDX,LEN,
                      SUBSTR(INT5,BEG,LENGTHC(INT5)-BEG),
                      ' ',
                      SUBSTR(IPRIO_STATUS(I),1,TITLE_LEN-1),
                      ', ');
        LO_INDX= LO_INDX + LEN;
        END;
      END;
 
    CALL INSERT(LO_BUF,LO_INDX-2,2,'  ');
    IF BROKEN > 0 THEN
         BROKEN= 0;
    ELSE CALL L$WRITE( LO_BUF, LO_LEN, M$LO# );
 
END DO_NUMBER_INPUT;
%EJECT;
DO_NUMBER_OUTPUT: PROC  ALTRET;
 
    MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
    TOT_GRANS= 0;
    DO Q1 = 0 TO NUM_JOBS-1;
      IF LOOKING_AT_ALL  OR
         TALLY_ACCT = Q$->OQ.ACCT  OR
         TALLY_FORM = Q$->OQ.FORM  OR
         TALLY_WSN  = Q$->OQ.WOD THEN DO;
           TOT_GRANS= TOT_GRANS + Q$->OQ.GRANS;
           DO Q2 = 0 TO NUM_TALLIES;
             IF Q$->OQ.DEVTYP = TBL.DEVT(Q2)  AND
                Q$->OQ.WOD   = TBL.WSN(Q2)  THEN DO;
                  TBL.TALLY(Q2)= TBL.TALLY(Q2) + 1;
                  TBL.GRANS(Q2)= TBL.GRANS(Q2) + Q$->OQ.GRANS;
                  GOTO NEXT_Q_ENTRY;
                  END;
             END;
           NUM_TALLIES= NUM_TALLIES + 1;
           IF NUM_TALLIES >= MAX_TBL_ENTRIES THEN DO;
              CALL EXPAND( OUT_AHEAD_,1024,TBL_END$ )  ALTRET( ALT_RETURN );
              MAX_TBL_ENTRIES= (POFFC(TBL_END$,TBL$)+1) / SIZEC(TBL(0));
              END;
           TBL.TALLY(NUM_TALLIES)= 1;
           TBL.ACCT(NUM_TALLIES)= Q$->OQ.ACCT;
           TBL.DEVT(NUM_TALLIES)= Q$->OQ.DEVTYP;
           TBL.WSN(NUM_TALLIES)= Q$->OQ.WOD;
           TBL.GRANS(NUM_TALLIES)= Q$->OQ.GRANS;
           END;
 
NEXT_Q_ENTRY:
      Q$= PINCRC( Q$, SIZEC(VLR_OSRCH.F(0)) );
      END;
 
    IF NUM_TALLIES < 0 THEN DO;
         IF TALLY_ACCT ~= ' ' THEN
              CALL CONCAT( LO_BUF, '..No OUTPUT for .',
                                   TALLY_ACCT );
         ELSE IF TALLY_WSN ~= ' ' THEN
                   IF B$JIT.PRIV.ACTIVE & %PR_DISPJOB# THEN
                        CALL CONCAT( LO_BUF, '..No OUTPUT @',
                                             TALLY_WSN );
                   ELSE CALL CONCAT( LO_BUF, '..YOU have no OUTPUT @',
                                             TALLY_WSN );
              ELSE IF TALLY_FORM ~= ' ' THEN
                        CALL CONCAT( LO_BUF, '.. No OUTPUT for form ',
                                             TALLY_FORM );
                   ELSE LO_BUF= '.. Oops!  Lee blew it!';
         CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
         RETURN;
         END;
 
    LO_INDX= 0;
    IF NUM_TALLIES > 0 THEN DO;
         CALL BINCHAR( INT4,NUM_JOBS );
         CALL SEARCH( BEG,TABLEVAL,SKIP_ZEROES,INT4 );
         LO_BUF= SUBSTR( INT4,BEG,LENGTHC(INT4)-BEG );
         LO_INDX= LENGTHC(INT4)-BEG;
         CALL BINCHAR( INT5,TOT_GRANS );
         CALL SEARCH( J,TABLEVAL,SKIP_ZEROES,INT5 );
         CALL INSERT( LO_BUF,LO_INDX, ,
                         ' items (',
                         SUBSTR(INT5,J,LENGTHC(INT5)-J ),
                         ' grans): ' );
         CALL SEARCHR( LO_INDX,TABLEVAL,SKIP_BLANKS,LO_BUF );
         LO_INDX= LO_INDX + 2;
         POS= LO_INDX;
         END;
    ELSE LO_BUF= ' ';
 
    DO Q1 = 0 TO NUM_TALLIES;
      CALL BINCHAR( INT4,TBL.TALLY(Q1) );
      CALL SEARCH( BEG,TABLEVAL,SKIP_ZEROES,INT4 );
      CALL BINCHAR( INT5,TBL.GRANS(Q1) );
      CALL SEARCH( J,TABLEVAL,SKIP_ZEROES,INT5 );
      CALL SEARCHR( J2,TABLEVAL,SKIP_BLANKS,TBL.WSN(Q1) );
      J2= J2 + 1;
      LEN= (LENGTHC(INT4)-BEG) + (LENGTHC(INT5)-J) + J2 +
           LENGTHC(' DV@ ( grans), ');
      IF LO_INDX + LEN > M$LO$->F$DCB.WIDTH# THEN DO;
           CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
           LO_BUF= ' ';
           LO_INDX= POS;
           END;
      CALL INSERT( LO_BUF, LO_INDX, ,
                      SUBSTR(INT4,BEG,LENGTHC(INT4)-BEG),
                      ' ',
                      SUBSTR(TBL.DEVT(Q1),0,2),
                      '@',
                      SUBSTR(TBL.WSN(Q1),0,J2),
                      ' (');
      LO_INDX= LO_INDX + LEN - (LENGTHC(INT5)-J) - LENGTHC(' grans), ');
      CALL INSERT( LO_BUF, LO_INDX, ,
                      SUBSTR(INT5,J,LENGTHC(INT5)-J),
                      ' grans), ');
      LO_INDX= LO_INDX + (LENGTHC(INT5)-J) + LENGTHC(' grans), ');
      END;
    CALL INSERT( LO_BUF, LO_INDX-2,2,'  ');  /* Blank the trailing ', ' */
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO# );
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END DO_NUMBER_OUTPUT;
%EJECT;
DO_HELP_ALL: PROC;
 
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, HELP_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, NOREAD_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, COMMANDS# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, ALL_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, DISPLAY_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, ECHO_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, END_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, EVERY_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, FIND_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, HEAD_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, IBEX_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, INPUT_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, INPUT_FIELDS_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, ME_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, NOECHO_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, NO_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, OUTPUT_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, LP_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, OUTPUT_ON_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, NOTATION_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, 87 )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, PAGE_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, PRINT_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, READ_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, RESET_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, RUNNING_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, SCAN_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, SEARCH_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, SIZE_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, SYSTEM_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, TALLY_HELP# )  ALTRET( STOP_HELP );
    HELPCNT= 0;
    CALL PUT_HELP( HELPCNT, HELP_TYPE, XEQ_HELP#)  ALTRET( STOP_HELP );
 
STOP_HELP:
    RETURN;
 
END DO_HELP_ALL;
%EJECT;
PUT_NUM_LISTED: PROC( LISTED, SEARCHED );
DCL LISTED                   UBIN;
DCL SEARCHED                 UBIN;
 
    IF LISTED > 0 THEN DO;
         CALL BINCHAR( INT4,LISTED );
         CALL SEARCH( BEG,TABLEVAL,SKIP_ZEROES,INT4 );
         END;
    ELSE DO;
         INT4= '  No';
         BEG= 2;
         END;
    CALL BINCHAR( INT5,SEARCHED );
    CALL SEARCH( J,TABLEVAL,SKIP_ZEROES,INT5 );
    IF SEARCHED > 0 THEN
         IF LISTED ~= 1 THEN
              CALL CONCAT( LO_BUF,
                              '.. ',
                              SUBSTR(INT4,BEG,LENGTHC(INT4)-BEG),
                              ' items Listed, ',
                              SUBSTR(INT5,J,LENGTHC(INT5)-J),
                              ' Searched' );
         ELSE CALL CONCAT( LO_BUF,
                              '.. 1 item Listed, ',
                              SUBSTR(INT5,J,LENGTHC(INT5)-J),
                              ' Searched' );
    ELSE IF LISTED ~= 1 THEN
              CALL CONCAT( LO_BUF,
                              '.. ',
                              SUBSTR(INT4,BEG,LENGTHC(INT4)-BEG),
                              ' items Listed' );
         ELSE IF DONELO THEN
                   LO_BUF= '.. 1 item Listed';
              ELSE RETURN;
    CALL L$WRITE( LO_BUF, LO_LEN, M$LO#, , M$DO#, DONELO );
    RETURN;
 
END PUT_NUM_LISTED;
%EJECT;
EXPAND: PROC( VECTOR_,NUM_WORDS,END$ )  ALTRET;
%VLP_VECTOR(FPTN=VECTOR_,STCLASS=);
DCL NUM_WORDS                UBIN;
DCL END$                     PTR;
 
    GDS.V.SEGSIZE#= NUM_WORDS;
    GDS.RESULTS_= VECTOR(VECTOR_);
    CALL M$GDS( GDS )  ALTRET( ALT_RETURN );
    IF ADDR(END$) ~= ADDR(NIL) THEN
       END$= PINCRC(VECTOR_.PTR$,VECTOR_.W1.VSIZE#);
RE_TURN:
    RETURN;
 
ALT_RETURN:
    ALTRETURN;
 
END EXPAND;
%EJECT;
END RQ;
