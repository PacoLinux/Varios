/*M*      NAME: LXX$MUNGER  Creates SYNC State Tables       */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
LXX$MUNGER: PROC MAIN;
 
    %INCLUDE B$JIT;
    %INCLUDE B_ERRORS_C;
    %INCLUDE CP_6;
    %INCLUDE MUNGER_C62;
    %INCLUDE MUNGER_C61;
    %INCLUDE MUNGER_C63;
    %INCLUDE XU_MACRO_C;
    %INCLUDE XU_PERR_C;
    %INCLUDE XU_SUBS_C;
 
    DCL LXX$SYMTBL ENTRY(3);
    DCL XUU$READ ENTRY(2) ALTRET;
    DCL XUU$OPEN ENTRY(1) ALTRET;
    DCL XUU$CLOSE ENTRY(1) ALTRET;
    DCL X$PARSE ENTRY(1) ALTRET;
 
    DCL B$JIT$ PTR SYMREF;
    DCL LXX$NODES UBIN WORD SYMREF;
    DCL LXX$OPTS UBIN WORD SYMREF;
 
    DCL M$LO DCB;
    DCL M$DO DCB;
    DCL M$SI DCB;
    DCL M$UI DCB;
    DCL M$OU DCB;
 
    DCL 1 TEXTC BASED ALIGNED,
          2 SIZE UBIN BYTE CALIGNED,
          2 TEXT CHAR(TEXTC.SIZE) CALIGNED;
    DCL 1 EQU BASED ALIGNED,
          2 NAME$ PTR,
          2 EVT$ PTR,
          2 VALUE UBIN;
    DCL 1 EVT BASED ALIGNED,
          2 NAME$ PTR,
          2 EQU$ PTR,
          2 VALUE UBIN;
    DCL 1 STT BASED ALIGNED,
          2 NAME$ PTR,
          2 VALUE UBIN;
    DCL 1 ACT BASED ALIGNED,
          2 NAME$ PTR,
          2 VALUE UBIN;
 
    DCL INPUT_BUFFER CHAR(256) STATIC ALIGNED;
    DCL OU_BUFFER CHAR(80) STATIC ALIGNED;
    DCL OUTPUT_BUFFER CHAR(110) STATIC CALIGNED;
    DCL 1 OUTPUT_BUFFER_R REDEF OUTPUT_BUFFER CALIGNED,
          2 VFC CHAR(1) CALIGNED,
          2 * CHAR(3) CALIGNED,
          2 KEY CHAR(10) CALIGNED,
          2 * CHAR(1) CALIGNED,
          2 SEQ CHAR(10) CALIGNED,
          2 SEQ_R(0:9) REDEF SEQ CHAR(1) CALIGNED,
          2 * CHAR(1) CALIGNED,
          2 LVL CHAR(1) CALIGNED,
          2 * CHAR(1) CALIGNED,
          2 TXT CHAR(80) CALIGNED,
          2 * CHAR(2) CALIGNED;
    DCL 1 OUTPUT_BUFFER_E REDEF OUTPUT_BUFFER CALIGNED,
          2 VFC CHAR(1) CALIGNED,
          2 * CHAR(1) CALIGNED,
          2 ENT(0:2) CHAR(36) CALIGNED;
    DCL 1 HDR_BUF STATIC CALIGNED,
          2 * CHAR(12) CALIGNED INIT('MUNGER.     '),
          2 * CHAR(6) CALIGNED INIT(' FILE='),
          2 FID CHAR(52) CALIGNED INIT(' '),
          2 * CHAR(2) CALIGNED INIT('  '),
          2 DAY CHAR(3) CALIGNED INIT(' '),
          2 * CHAR(1) CALIGNED INIT(' '),
          2 DATE CHAR(10) CALIGNED INIT(' '),
          2 * CHAR(1) CALIGNED INIT(' '),
          2 TIME CHAR(11) CALIGNED INIT(' '),
          2 * CHAR(6) CALIGNED INIT(' PAGE:');
    DCL HDR_BUF_R REDEF HDR_BUF CHAR(104) CALIGNED;
    DCL 1 LX_OPTIONS STATIC ALIGNED,
          2 LS# BIT(1) UNAL INIT('1'B),
          2 LU# BIT(1) UNAL INIT('1'B),
          2 OU# BIT(1) UNAL INIT('1'B),
          2 LI# BIT(1) UNAL INIT('0'B),
          2 MAP# BIT(1) UNAL INIT('1'B),
          2 SR ALIGNED,
            3 N UBIN ALIGNED INIT(0),
            3 ACCT(0:15) CHAR(8) CALIGNED;
    DCL 1 BARFO ALIGNED,
          2 COUNT UBIN,
          2 ERR(0:10),
            3 FIELD1 BIT(1) UNAL,
            3 FIELD2 BIT(1) UNAL,
            3 FIELD3 BIT(1) UNAL,
            3 ERRCODE BIT(36) ALIGNED,
            3 FIELD1_ BIT(72) DALIGNED,
            3 FIELD2_ BIT(72) DALIGNED,
            3 FIELD3_ BIT(72) DALIGNED;
    DCL HEADER_BUFFER(0:21) CHAR(80) CONSTANT ALIGNED INIT(
         '%LSET LISTDIR=''0''B;',
         '%LSET LISTEXP=''1''B;',
         '%LSET LISTCOM=''0''B;',
         '%LSET LISTSUB=''1''B;',
         '%LSET STR=CONCAT(TEXTCHAR(STCLASS),''        '');',
         '%IF (SUBSTR(STR,0,6)=''STATIC'')OR(SUBSTR(STR,0,3)=''EXT'')',
         '    OR(SUBSTR(STR,0,8)=''CONSTANT'');',
         '%LSET INIT=CHARTEXT(''INIT'');',
         '%ELSE;',
         '%LSET INIT=CHARTEXT(''/*'');',
         '%ENDIF;',
         'DCL 1 NAME STCLASS ALIGNED,',
         '2 LINHND@ EPTR %INIT(ENTADDR(LINHND))%CHARTEXT(''/**/''),',
         '2 DVCHND@ EPTR %INIT(ENTADDR(DVCHND))%CHARTEXT(''/**/''),',
         '2 STTHND@ EPTR %INIT(ENTADDR(STTHND))%CHARTEXT(''/**/''),',
         '2 STTBFR$ PTR %INIT(ADDR(STTBFR))%CHARTEXT(''/**/''),',
         '2 DFLPRO$ PTR %INIT(ADDR(DFLPRO))%CHARTEXT(''/**/''),',
         '2 INTRCT BIT(1) %INIT(INT)%CHARTEXT(''/**/''),',
         '2 EMAP$ PTR %INIT(ADDR(EMAP))%CHARTEXT(''/**/''),',
         '2 STBL$ PTR %INIT(ADDR(STBL))%CHARTEXT(''/**/''),',
         '2 TIMOUT1# UBIN %INIT(TIMOUT1)%CHARTEXT(''/**/''),',
         '2 TIMOUT2# UBIN %INIT(TIMOUT2)%CHARTEXT(''/**/'');');
    DCL 1 INT STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(4),
          2 TEXT CHAR(31) CALIGNED INIT('''0''B');
    DCL 1 DVCHND STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 LINHND STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 STTHND STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 STTBFR STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 DFLPRO STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 FLAGS STATIC ALIGNED,
          2 TBLINIT BIT(1) UNAL INIT('0'B),
          2 IN# BIT(1) INIT('0'B),
          2 INCL BIT(1) UNAL INIT('0'B),
          2 INT BIT(1) UNAL INIT('0'B),
          2 HDRNAM BIT(1) UNAL INIT('0'B),
          2 TBLNAM BIT(1) UNAL INIT('0'B),
          2 MAPNAM BIT(1) UNAL INIT('0'B),
          2 TBLGEN BIT(1) UNAL INIT('0'B),
          2 MAPGEN BIT(1) UNAL INIT('0'B),
          2 LINHND BIT(1) UNAL INIT('0'B),
          2 STTBFR BIT(1) UNAL INIT('0'B),
          2 STTHND BIT(1) UNAL INIT('0'B),
          2 DVCHND BIT(1) UNAL INIT('0'B),
          2 TIMOUT1 BIT(1) UNAL INIT('0'B),
          2 TIMOUT2 BIT(1) UNAL INIT('0'B),
          2 DFLPRO BIT(1) UNAL INIT('0'B);
    DCL 1 HDRNAM STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED,
          2 TEXT CHAR(31) CALIGNED;
    DCL 1 TBLNAM STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 MAPNAM STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(3),
          2 TEXT CHAR(31) CALIGNED INIT('NIL');
    DCL 1 TIMOUT1 STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(1),
          2 TEXT CHAR(31) CALIGNED INIT('5');
    DCL 1 TIMOUT2 STATIC ALIGNED,
          2 SIZE UBIN BYTE CALIGNED INIT(1),
          2 TEXT CHAR(31) CALIGNED INIT('5');
    DCL WORKSPACE(0:1023) UBIN WORD STATIC ALIGNED;
    DCL ERR_BUFFER(0:10) CHAR(120) STATIC ALIGNED;
    DCL WASTE1 UBIN WORD STATIC ALIGNED;
    DCL WASTE2 UBIN WORD STATIC ALIGNED;
    DCL EVT_VALUE UBIN WORD STATIC ALIGNED INIT(0);
    DCL STT_VALUE UBIN WORD STATIC ALIGNED INIT(0);
    DCL ACT_VALUE UBIN WORD STATIC ALIGNED INIT(0);
    DCL CHR3 CHAR(3) CALIGNED;
    DCL ERROR# BIT(1) ALIGNED;
    DCL I UBIN;
    DCL J UBIN;
    DCL X UBIN;
    DCL K UBIN;
    DCL PTR$ PTR;
    DCL PTR1$ PTR;
    DCL PTR2$ PTR;
    DCL PTR3$ PTR;
    DCL PTR4$ PTR;
    DCL SEV UBIN;
    DCL SIZE SBIN;
    DCL VALUE SBIN;
    DCL EVTSIZ UBIN;
    DCL EVTMAP$(0:0) PTR BASED;
    DCL HDIM UBIN STATIC INIT(0);
    DCL LDIM UBIN STATIC INIT(255);
    DCL LAST UBIN STATIC INIT(0);
    DCL OLD_STT UBIN;
    DCL NEW_STT UBIN;
    DCL EVTBITS(0:255) BIT(1) UNAL STATIC INIT('0'B*0);
    DCL LAST_SAVE UBIN;
    DCL TBL_WID UBIN;
    DCL TBL_LEN UBIN;
    DCL TBL_SIZ UBIN;
    DCL 1 STT_TBL ALIGNED,
          2 ACT(0:65535) UBIN BYTE CALIGNED,
          2 STT(0:65535) UBIN BYTE CALIGNED;
    DCL 1 U1 STATIC CALIGNED,
          2 * UBIN BYTE CALIGNED INIT(3),
          2 TXT CHAR(3) CALIGNED INIT('   ');
 
    %P_PCB         ( NAME = PCB_OPTS,
                     STCLASS = STATIC,
                     R = LXX$OPTS,
                     W = WORKSPACE,
                     WSZ = 1024,
                     OUTDCB = M$DO );
 
    %P_PCB         ( NAME = PCB_CMDS,
                     STCLASS = STATIC,
                     R = LXX$NODES,
                     T = INPUT_BUFFER,
                     W = WORKSPACE,
                     WSZ = 1024,
                     OUTDCB = M$DO );
 
    %PARSE$SYM     ( NAME = PSYM,
                     STCLASS = BASED );
 
    %PARSE$OUT     ( NAME = PBLK,
                     STCLASS = BASED );
 
    %XUU_PARAM     ( FPTN = OPEN,
                     STCLASS = STATIC,
                     BASE = YES,
                     UPDATE = YES,
                     INCLUDE = NO,
                     LU_FIRST = YES,
                     DCB = "DCBNUM(M$LO)" );
 
    %XUU_PARAM     ( FPTN = READ,
                     STCLASS = STATIC,
                     BLANK_FILL = YES,
                     SOURCE_OUT = NO );
 
    %XUU_PARAM     ( FPTN = CLOSE,
                     STCLASS = STATIC,
                     CLOSE_ALL = YES );
 
    %FPT_FID       ( FPTN = FID_SROPT,
                     STCLASS = STATIC,
                     NAME = NAME_SR,
                     ACCT = ACCT_SR,
                     PASS = PASS_SR,
                     WSN = WSN_SR,
                     SN = SN_SR,
                     RES = WASTE1,
                     ASN = WASTE2,
                     RESULTS = VLR_FID );
 
    %FPT_UNFID     ( FPTN = UNFID_SI,
                     STCLASS = STATIC,
                     DCB = M$SI,
                     TEXTFID = HDR_BUF.FID );
 
    %FPT_OPEN      ( FPTN = OPEN_INCL,
                     SCRUB = YES,
                     REASSIGN = YES,
                     FUN = IN,
                     SHARE = ALL,
                     ASN = FILE );
 
    %FPT_OPEN      ( FPTN = OPEN_LO,
                     DCB = M$LO,
                     SCRUB = YES,
                     REASSIGN = YES,
                     ORG = UR,
                     CTG = YES,
                     COMP = YES );
 
    %FPT_OPEN      ( FPTN = OPEN_OU,
                     DCB = M$OU,
                     SCRUB =YES,
                     REASSIGN = YES,
                     TYPE = 'Gi',
                     IXTNSIZE = 20,
                     XTNSIZE = 10,
                     ASN = FILE,
                     ORG = CONSEC );
 
    %FPT_CLOSE     ( FPTN = CLOSE_LO,
                     DCB = M$LO,
                     RELG = YES,
                     DISP = SAVE );
 
    %FPT_CLOSE     ( FPTN = CLOSE_OU,
                     DCB = M$OU,
                     RELG = YES,
                     DISP = SAVE );
 
    %FPT_WRITE     ( FPTN = WRITE_OU,
                     DCB = M$OU,
                     BUF = OU_BUFFER,
                     VFC = NO,
                     WAIT = YES );
 
    %FPT_TIME      ( FPTN = GET_TIME,
                     STCLASS = STATIC,
                     DATE = HDR_BUF.DATE,
                     TIME = HDR_BUF.TIME,
                     DAY = HDR_BUF.DAY,
                     DEST = EXT,
                     SOURCE = CLOCK );
 
    %FPT_WRITE     ( FPTN = WRITE_LO,
                     STCLASS = STATIC,
                     DCB = M$LO,
                     VFC = YES,
                     WAIT = YES,
                     BUF = OUTPUT_BUFFER );
 
    %FPT_DEVICE    ( FPTN = SET_HDR,
                     DCB = M$LO,
                     DVFC = 'A',
                     HDR = VLP_HDR,
                     PAGE = NO,
                     TAB = ERASE );
 
    %FPT_DEVICE    ( FPTN = EJECT,
                     DCB = M$LO,
                     DVFC = 'A',
                     PAGE = YES );
 
    %FPT_ERRMSG    ( FPTN = ERR_MSG,
                     STCLASS = STATIC,
                     BUF = ERR_BUFFER,
                     CODE = VLP_ERRCODE,
                     FILEACCT = VLP_ACCT,
                     FILENAME = VLP_NAME,
                     FLAGLEV = 0,
                     INCLCODE = NO,
                     OUTDCB1 = M$DO,
                     OUTDCB2 = M$LO,
                     VFC = 'A' );
    %VLR_FID;
 
    %VLP_NAME      ( FPTN = NAME_SR );
 
    %VLP_ACCT      ( FPTN = ACCT_SR );
 
    %VLP_PASS      ( FPTN = PASS_SR );
 
    %VLP_WSN       ( FPTN = WSN_SR );
 
    %VLP_SN        ( FPTN = SN_SR );
 
 
    %VLP_NAME      ( NAME = ':LXERRMSG' );
 
    %VLP_ACCT      ( ACCT = 'DJLGN' );
 
    %VLP_HDR       ( COUNT = 106,
                     HEADERHEIGHT = 2,
                     INDENT = 2,
                     RESETPAGE = YES,
                     LEN = 107 );
 
    %VLP_ERRCODE   ( FPTN = CANNED_ERRCODE,
                     STCLASS = STATIC,
                     FCG = LX,
                     MID = X,
                     MON = '0'B,
                     SEV = 4 );
 
    %VLP_ERRCODE   ( STCLASS = STATIC );
 
    IF LX_OPTIONS.OU# THEN CALL M$OPEN ( OPEN_OU );
    CALL M$OPEN ( OPEN_LO );
    IF B$JIT.CCARS ~= B$JIT.CCDISP THEN DO;
         PCB_OPTS.TEXT$ = PINCRC(ADDR(B$JIT.CCBUF), B$JIT.CCDISP);
         PCB_OPTS.NCHARS = B$JIT.CCARS - B$JIT.CCDISP;
         CALL X$PARSE ( PCB_OPTS ) ALTRET ( BAD_OPTIONS );
         DO I = 1 TO PCB_OPTS.OUT$ -> PBLK.NSUBLKS;
              PTR$ = PCB_OPTS.OUT$ -> PBLK.SUBLK$(I - 1);
              DO CASE ( PTR$ -> PSYM.CODE );
                   CASE ( %LX#LS );
                        PTR$ = PTR$ -> PBLK.SUBLK$(0);
                        IF PTR$ -> PSYM.CODE = %LX#YES THEN
                             LX_OPTIONS.LS# = '1'B;
                        ELSE
                             LX_OPTIONS.LS# = '0'B;
                   CASE ( %LX#LU );
                        PTR$ = PTR$ -> PBLK.SUBLK$(0);
                        IF PTR$ -> PSYM.CODE = %LX#YES THEN
                             LX_OPTIONS.LU# = '1'B;
                        ELSE
                             LX_OPTIONS.LU# = '0'B;
                   CASE ( %LX#OU );
                        PTR$ = PTR$ -> PBLK.SUBLK$(0);
                        IF PTR$ -> PSYM.CODE = %LX#YES THEN
                             LX_OPTIONS.OU# = '1'B;
                        ELSE
                             LX_OPTIONS.OU# = '0'B;
                   CASE ( %LX#LI );
                        PTR$ = PTR$ -> PBLK.SUBLK$(0);
                        IF PTR$ -> PSYM.CODE = %LX#YES THEN
                             LX_OPTIONS.LI# = '1'B;
                        ELSE
                             LX_OPTIONS.LI# = '0'B;
                   CASE ( %LX#MAP );
                        PTR$ = PTR$ -> PBLK.SUBLK$(0);
                        IF PTR$ -> PSYM.CODE = %LX#YES THEN
                             LX_OPTIONS.MAP# = '1'B;
                        ELSE
                             LX_OPTIONS.MAP# = '0'B;
                   CASE ( %LX#SR );
                        LX_OPTIONS.SR.N = PTR$ -> PBLK.NSUBLKS;
                        DO J = 0 TO PTR$ -> PBLK.NSUBLKS - 1;
                             PTR2$ = PTR$ -> PBLK.SUBLK$(J);
                             FID_SROPT.TEXTFID_ = VECTOR(PTR2$ -> PSYM.TEXT);
                             CALL M$FID ( FID_SROPT );
                             IF NOT ( VLR_FID.NAME OR VLR_FID.PASS OR
                                  VLR_FID.SN OR VLR_FID.SN ) AND
                                  VLR_FID.ACCT THEN
                                  LX_OPTIONS.SR.ACCT(J) = ACCT_SR.ACCT#;
                             ELSE DO;
/*E*     ERROR: LXX-E$YUKKYFID
       MESSAGE: Bad account name in SR account list.
*/
                                  VLP_ERRCODE = CANNED_ERRCODE;
                                  VLP_ERRCODE.ERR# = %E$YUKKYFID;
                                  CALL M$ERRMSG ( ERR_MSG );
                                  CALL M$CLOSE ( CLOSE_LO );
                                  CALL M$ERR;
                             END;
                        END;
              END;
         END;
    END;
    CALL M$UNFID ( UNFID_SI );
    CALL M$TIME ( GET_TIME );
    VLP_HDR.TITL.L# = SIZEC(HDR_BUF);
    VLP_HDR.TITL.TITLE# = HDR_BUF_R;
    OPEN.FLAGS.UP_DATE# = B$JIT.PRFLAGS.UI;
    CALL M$DEVICE ( SET_HDR );
    IF B$JIT.PRFLAGS.UI THEN
         CALL M$DEVICE ( EJECT );
    OPEN.FLAGS.LU_FIRST# = LX_OPTIONS.LU#;
    CALL XUU$OPEN ( OPEN ) ALTRET ( CANT_OPEN );
    CALL M$DEVICE ( EJECT );
    I = 0;
LOOP:
    BARFO = '0'B;
    CALL XUU$READ ( READ, VECTOR(INPUT_BUFFER) ) ALTRET ( CANT_READ );
    I = I + 1;
    PCB_CMDS.NCHARS = READ.ARS;
    ERROR# = '1'B;
    CALL X$PARSE ( PCB_CMDS ) ALTRET ( BARF );
    ERROR# = '0'B;
    DO CASE ( PCB_CMDS.OUT$ -> PBLK.CODE );
 
%EJECT;
         CASE ( LX#END );
 
              GOTO CLOSE_ALL_FILES;
 
%EJECT;
         CASE ( LX#EJECT );
 
              CALL M$DEVICE ( EJECT );
 
%EJECT;
         CASE ( LX#INCLUDE );
 
INCLUDE:;
              OPEN_INCL.NAME_ = VECTOR(PCB_CMDS.OUT$ -> PBLK.SUBLK$(0)
                   -> PSYM.TEXTC$ -> TEXTC);
              OPEN.FLAGS.BASE# = '0'B;
              OPEN.FLAGS.UP_DATE# = '0'B;
              OPEN.FLAGS.INCLUDE# = '1'B;
              OPEN.O.FPT_PTR$ = ADDR(OPEN_INCL);
              FLAGS.INCL = '0'B;
              DO J = 0 TO LX_OPTIONS.SR.N - 1;
                   OPEN_INCL.ACCT_ = VECTOR(LX_OPTIONS.SR.ACCT(J));
                   CALL XUU$OPEN ( OPEN ) ALTRET ( NEVER_MIND );
                   J = LX_OPTIONS.SR.N - 1;
                   FLAGS.INCL = '1'B;
                   DO WHILE ( '0'B );
NEVER_MIND:;
                        IF OPEN.O.INCL_ERRCODE.ERR# ~= %E$NOFILE THEN
                             GOTO CANT_OPEN;
                        ELSE GOTO IGNORE;
                   END;
IGNORE:;
              END;
              IF NOT FLAGS.INCL THEN DO;
 
/*E*     ERROR: LXX-E$NOINCLFID
       MESSAGE: Can't locate that include file.
*/
 
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$NOINCLFID;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#TBLNAM );
 
TBLNAM:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.TBLNAM THEN DO;
                   FLAGS.TBLNAM = '1'B;
                   TBLNAM.SIZE = PTR$ -> TEXTC.SIZE;
                   TBLNAM.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
 
/*E*     ERROR: LXX-E$DUPTBLNAM
       MESSAGE: Table name already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPTBLNAM;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#MAPNAM );
 
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.MAPNAM THEN DO;
                   FLAGS.MAPNAM = '1'B;
                   MAPNAM.SIZE = PTR$ -> TEXTC.SIZE;
                   MAPNAM.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
 
/*E*     ERROR: LXX-E$DUPMAPNAM
       MESSAGE: Event map name already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPMAPNAM;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#HDRNAM );
 
HDRNAM:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.HDRNAM THEN DO;
                   FLAGS.HDRNAM = '1'B;
                   HDRNAM.SIZE = PTR$ -> TEXTC.SIZE;
                   HDRNAM.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPHDRNAM
       MESSAGE: Header name already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPHDRNAM;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#LINHND );
 
LINHND:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.LINHND THEN DO;
                   FLAGS.LINHND = '1'B;
                   LINHND.SIZE = PTR$ -> TEXTC.SIZE;
                   LINHND.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPLINHND
       MESSAGE: Line handler entry already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPLINHND;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#DVCHND );
 
DVCHND:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.DVCHND THEN DO;
                   FLAGS.DVCHND = '1'B;
                   DVCHND.SIZE = PTR$ -> TEXTC.SIZE;
                   DVCHND.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPDVCHND
       MESSAGE: Device handler entry already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPDVCHND;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#STTHND );
 
STTHND:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.STTHND THEN DO;
                   FLAGS.STTHND = '1'B;
                   STTHND.SIZE = PTR$ -> TEXTC.SIZE;
                   STTHND.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPSTTHND
       MESSAGE: Stats handler entry already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPSTTHND;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#STTBFR );
 
STTBFR:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.STTBFR THEN DO;
                   FLAGS.STTBFR = '1'B;
                   STTBFR.SIZE = PTR$ -> TEXTC.SIZE;
                   STTBFR.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPSTTBFR
       MESSAGE: Statistics buffer pointer already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPSTTBFR;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#DFLPRO );
 
DFLPRO:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.DFLPRO THEN DO;
                   FLAGS.DFLPRO = '1'B;
                   DFLPRO.SIZE = PTR$ -> TEXTC.SIZE;
                   DFLPRO.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPDFLPRO
       MESSAGE: Default profile name already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPSTTBFR;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#INT );
 
INT:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0);
              IF NOT FLAGS.INT THEN DO;
                   FLAGS.INT = '1'B;
                   IF PTR$ -> PBLK.CODE = %LX#YES THEN DO;
                        INT.TEXT = '''1''B';
                        INT.SIZE = 4;
                   END;
              END;
              ELSE DO;
/*E*     ERROR: LXX-E$DUPINT
       MESSAGE: Interactiveness already specified.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPINT;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#TIMOUT1 );
 
TIMOUT1:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.TIMOUT1 THEN DO;
                   FLAGS.TIMOUT1 = '1'B;
                   TIMOUT1.SIZE = PTR$ -> TEXTC.SIZE;
                   TIMOUT1.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
 
/*E*     ERROR: LXX-E$DUPTIMOUT1
       MESSAGE: Primary timout value already initialized.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPTIMOUT1;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#TIMOUT2 );
 
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              IF NOT FLAGS.TIMOUT2 THEN DO;
                   FLAGS.TIMOUT2 = '1'B;
                   TIMOUT2.SIZE = PTR$ -> TEXTC.SIZE;
                   TIMOUT2.TEXT = PTR$ -> TEXTC.TEXT;
              END;
              ELSE DO;
 
/*E*     ERROR: LXX-E$DUPTIMOUT2
       MESSAGE: Secondary timout value already initialized;
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPTIMOUT2;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
 
%EJECT;
         CASE ( LX#EQUATE );
 
EQUATE:;
              PTR1$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(1);
              VALUE = 0;
              DO CASE ( PTR1$ -> PSYM.CODE );
 
                   CASE ( LX#SYM_PLUS );
 
                        PTR$ = PTR1$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                        CALL LOOKUP_EQUATE ALTRET ( EQU_ERR_01 );
                        PTR$ = PTR1$ -> PBLK.SUBLK$(1) -> PSYM.TEXTC$;
                        CALL EVALUATE_DECIMAL;
 
                   CASE ( LX#SYM_MINUS );
 
                        PTR$ = PTR1$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                        CALL LOOKUP_EQUATE ALTRET ( EQU_ERR_01 );
                        VALUE = -VALUE;
                        PTR$ = PTR1$ -> PBLK.SUBLK$(1) -> PSYM.TEXTC$;
                        CALL EVALUATE_DECIMAL;
                        VALUE = -VALUE;
 
                   CASE ( LX#SYM );
 
                        PTR$ = PTR1$ -> PSYM.TEXTC$;
                        CALL LOOKUP_EQUATE ALTRET ( EQU_ERR_01 );
 
                   CASE ( LX#DEC );
 
                        PTR$ = PTR1$ -> PSYM.TEXTC$;
                        CALL EVALUATE_DECIMAL;
              END;
              DO WHILE ( '0'B );
EQU_ERR_01:
/*E*     ERROR: LXX-E$UNDEFSYM
       MESSAGE: Symbol %U1 is not defined previous to this usage.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$UNDEFSYM;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR$ -> TEXTC);
                   IF SEV < 4 THEN SEV = 4;
              END;
              IF VALUE < 0 THEN DO;
/*E*     ERROR: LXX-E$BADVAL
       MESSAGE: You may not define %U1 with a negative value.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$BADVAL;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) =
                        VECTOR(PCB_CMDS.OUT$ -> PBLK.SUBLK$(0)
                        -> PSYM.TEXTC$ -> TEXTC);
              END;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              CALL VERIFY_SYMBOL ALTRET ( EQU_OK_01 );
/*E*     ERROR: LXX-E$DUPNAME
       MESSAGE: You may not redefine symbol %U1.
*/
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$DUPNAME;
              VLP_ERRCODE.SEV = 4;
              BARFO.COUNT = BARFO.COUNT + 1;
              BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
              BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR$ -> TEXTC);
              IF SEV < 4 THEN SEV = 4;
EQU_OK_01:
              IF BARFO.COUNT = 0 THEN DO;
                   SIZE = SIZEW(PTR$ -> TEXTC);
                   CALL LXX$SYMTBL ( %LX#ACQNAM, SIZE, PTR2$ );
                   PTR2$ -> TEXTC.SIZE = PTR$ -> TEXTC.SIZE;
                   PTR2$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT;
                   CALL LXX$SYMTBL ( %LX#ACQEQU, SIZEW(EQU), PTR$ );
                   PTR$ -> EQU.NAME$ = PTR2$;
                   PTR$ -> EQU.EVT$ = ADDR(NIL);
                   PTR$ -> EQU.VALUE = VALUE;
              END;
 
%EJECT;
         CASE ( LX#EVT );
 
EVT:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
              CALL VERIFY_SYMBOL ALTRET ( EVT_OK_01 );
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$DUPNAME;
              BARFO.COUNT = BARFO.COUNT + 1;
              BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
              BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR2$ -> TEXTC);
EVT_OK_01:;
              PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(1) -> PSYM.TEXTC$;
              VALUE = 0;
              CALL LOOKUP_EQUATE ALTRET ( EVT_ERR_01 );
              DO WHILE ( '0'B );
EVT_ERR_01:;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$UNDEFSYM;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR$ ->
                        TEXTC);
                   ERROR# = '1'B;
              END;
              IF NOT ERROR# THEN DO;
                   CALL VERIFY_EVENT ALTRET ( EVT_ERR_02 );
                   DO WHILE ( '0'B );
EVT_ERR_02:;
/*E*     ERROR: LXX-E$DUPEVT
       MESSAGE: Event %U1 already maps into that equated value.
*/
                        VLP_ERRCODE = CANNED_ERRCODE;
                        VLP_ERRCODE.ERR# = %E$DUPEVT;
                        BARFO.COUNT = BARFO.COUNT + 1;
                        BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                        BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                        BARFO.ERR.FIELD1_(BARFO.COUNT) =
                             VECTOR(PTR$ -> TEXTC);
                   END;
              END;
              ELSE ERROR# = '0'B;
              IF BARFO.COUNT = 0 THEN DO;
                   FLAGS.MAPGEN = '1'B;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                   SIZE = SIZEW(PTR$ -> TEXTC);
                   CALL LXX$SYMTBL ( %LX#ACQNAM, SIZE, PTR1$ );
                   PTR1$ -> TEXTC.SIZE = PTR$ -> TEXTC.SIZE;
                   PTR1$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT;
                   SIZE = SIZEW(EVT);
                   CALL LXX$SYMTBL ( %LX#ACQEVT, SIZE, PTR$ );
                   PTR$ -> EVT.NAME$ = PTR1$;
                   PTR$ -> EVT.VALUE = EVT_VALUE;
                   PTR$ -> EVT.EQU$ = PTR2$;
                   PTR2$ -> EQU.EVT$ = PTR$;
                   EVT_VALUE = EVT_VALUE + 1;
              END;
 
%EJECT;
         CASE ( LX#STT );
 
STT:;
              DO J = 0 TO PCB_CMDS.OUT$ -> PBLK.NSUBLKS - 1;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(J) ->
                        PSYM.TEXTC$;
                   ERROR# = '0'B;
                   CALL LOOKUP_STATE ALTRET ( STT_OK_01 );
                   ERROR# = '1'B;
/*E*     ERROR: LXX-E$DUPSTT
       MESSAGE: State %U1 is already defined.
*/
                   BARFO.COUNT = BARFO.COUNT + 1;
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPSTT;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) =
                        VECTOR(PTR$ -> TEXTC);
                   GOTO STT_OK_02;
STT_OK_01:;
                   CALL VERIFY_SYMBOL ALTRET ( STT_OK_02 );
                   ERROR# = '1'B;
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPNAME;
                   VLP_ERRCODE.SEV = 4;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR$ -> TEXTC);
STT_OK_02:;
                   IF NOT ERROR# THEN DO;
                        CALL LXX$SYMTBL ( %LX#ACQSTT, SIZEW(STT), PTR1$ );
                        PTR1$ -> STT.VALUE = STT_VALUE;
                        STT_VALUE = STT_VALUE + 1;
                        SIZE = SIZEW(PTR$ -> TEXTC);
                        CALL LXX$SYMTBL ( %LX#ACQNAM, SIZE, PTR2$ );
                        PTR2$ -> TEXTC.SIZE = PTR$ -> TEXTC.SIZE;
                        PTR2$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT;
                        PTR1$ -> STT.NAME$ = PTR2$;
                   END;
              END;
              ERROR# = '0'B;
 
%EJECT;
         CASE ( LX#ACT );
 
ACT:;
              DO J = 0 TO PCB_CMDS.OUT$ -> PBLK.NSUBLKS - 1;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(J) ->
                        PSYM.TEXTC$;
                   ERROR# = '0'B;
                   CALL LOOKUP_ACTION ALTRET ( ACT_OK_01 );
                   ERROR# = '1'B;
 
/*E*     ERROR: LXX-E$DUPACT
       MESSAGE: Action %U1 is already defined.
*/
 
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPACT;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) =
                        VECTOR(PTR$ -> TEXTC);
ACT_OK_01:;
                   CALL VERIFY_SYMBOL ALTRET ( ACT_OK_02 );
                   ERROR# = '1'B;
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$DUPNAME;
                   VLP_ERRCODE.SEV = 4;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                   BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                   BARFO.ERR.FIELD1_(BARFO.COUNT) = VECTOR(PTR$ -> TEXTC);
ACT_OK_02:;
                   IF NOT ERROR# THEN DO;
                        CALL LXX$SYMTBL ( %LX#ACQACT, SIZEW(ACT), PTR1$ );
                        PTR1$ -> ACT.VALUE = ACT_VALUE;
                        ACT_VALUE = ACT_VALUE + 1;
                        SIZE = SIZEW(PTR$ -> TEXTC);
                        CALL LXX$SYMTBL ( %LX#ACQNAM, SIZE, PTR2$ );
                        PTR2$ -> TEXTC.SIZE = PTR$ -> TEXTC.SIZE;
                        PTR2$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT;
                        PTR1$ -> ACT.NAME$ = PTR2$;
                   END;
              END;
              ERROR# = '0'B;
%EJECT;
 
         CASE ( LX#IN );
 
IN1:;
              IF LAST ~= 0 AND LAST ~= LX#DO THEN DO;
 
/*E*     ERROR: LXX-E$BADINORD
       MESSAGE: "IN" directive misplaced.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$BADINORD;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
              ELSE DO;
                   IF NOT FLAGS.TBLINIT THEN DO;
                        CALL INIT_STATE_TABLE;
                        FLAGS.TBLINIT = '1'B;
                   END;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                   CALL LOOKUP_STATE ALTRET ( IN_ERR_01 );
                   LAST = LX#IN;
                   FLAGS.IN# = '1'B;
                   OLD_STT = VALUE;
                   DO WHILE ( '0'B );
IN_ERR_01:;
 
/*E*     ERROR: LXX-E$BADSTATE
       MESSAGE: State %U1 is not defined.
*/
                        VLP_ERRCODE = CANNED_ERRCODE;
                        VLP_ERRCODE.ERR# = %E$BADSTATE;
                        BARFO.COUNT = BARFO.COUNT + 1;
                        BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                        BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                        BARFO.ERR.FIELD1_(BARFO.COUNT) =
                             VECTOR(PTR$ -> TEXTC.TEXT);
                   END;
              END;
%EJECT;
         CASE ( LX#WHEN );
WHEN1:;
 
              IF LAST ~= 0 AND LAST ~= LX#IN AND LAST ~= LX#DO THEN DO;
 
/*E*     ERROR: LXX-E$BADWHENORD
       MESSAGE: "WHEN" directive misplaced.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$BADWHENORD;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
              ELSE DO;
                   IF NOT FLAGS.TBLINIT THEN DO;
                        CALL INIT_STATE_TABLE;
                        FLAGS.TBLINIT = '1'B;
                   END;
                   LAST_SAVE = LAST;
                   DO J = 0 TO PCB_CMDS.OUT$ -> PBLK.NSUBLKS - 1;
                        PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(J)
                             -> PSYM.TEXTC$;
                        CALL LOOKUP_EVENT ALTRET ( WHEN_ERR_01 );
                        LAST = LX#WHEN;
                        EVTBITS(VALUE) = '1'B;
                   END;
                   DO WHILE ( '0'B );
WHEN_ERR_01:;
                        LAST = LAST_SAVE;
/*E*     ERROR: LXX-E$BADEVENT
       MESSAGE: Event %U1 is not defined.
*/
                        VLP_ERRCODE = CANNED_ERRCODE;
                        VLP_ERRCODE.ERR# = %E$BADEVENT;
                        BARFO.COUNT = BARFO.COUNT + 1;
                        BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                        BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                        BARFO.ERR.FIELD1_(BARFO.COUNT) =
                             VECTOR(PTR$ -> TEXTC);
                   END;
              END;
%EJECT;
 
         CASE ( LX#MOVE );
 
MOVE1:;
              IF LAST ~= LX#WHEN THEN DO;
 
/*E*     ERROR: LXX-E$BADMOVEORD
       MESSAGE: "MOVE" directive misplaced.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$BADMOVEORD;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
              ELSE DO;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                   CALL LOOKUP_STATE ALTRET ( MOVE_ERR_01 );
                   LAST = LX#MOVE;
                   NEW_STT = VALUE;
                   DO WHILE ( '0'B );
MOVE_ERR_01:;
                        VLP_ERRCODE = CANNED_ERRCODE;
                        VLP_ERRCODE.ERR# = %E$BADSTATE;
                        BARFO.COUNT = BARFO.COUNT + 1;
                        BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                        BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                        BARFO.ERR.FIELD1_(BARFO.COUNT) =
                             VECTOR(PTR$ -> TEXTC);
                   END;
              END;
%EJECT;
 
         CASE ( LX#DO );
 
DO1:;
              IF LAST ~= LX#MOVE THEN DO;
 
/*E*     ERROR: LXX-E$BADDOORD
       MESSAGE: "DO" directive misplaced.
*/
                   VLP_ERRCODE = CANNED_ERRCODE;
                   VLP_ERRCODE.ERR# = %E$BADDOORD;
                   BARFO.COUNT = BARFO.COUNT + 1;
                   BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
              END;
              ELSE DO;
                   PTR$ = PCB_CMDS.OUT$ -> PBLK.SUBLK$(0) -> PSYM.TEXTC$;
                   CALL LOOKUP_ACTION ALTRET ( DO_ERR_01 );
                   LAST = LX#DO;
                   DO J = 0 TO TBL_WID - 1;
                        IF FLAGS.IN# THEN DO;
                             IF EVTBITS(J) THEN DO;
                                  X = TBL_WID * OLD_STT + J;
                                  STT_TBL.ACT(X) = VALUE;
                                  STT_TBL.STT(X) = NEW_STT;
                             END;
                        END;
                        ELSE DO;
                             IF EVTBITS(J) THEN DO K = 0 TO TBL_LEN - 1;
                                  X = TBL_WID * K + J;
                                  STT_TBL.ACT(X) = VALUE;
                                  STT_TBL.STT(X) = NEW_STT;
                             END;
                        END;
                   END;
                   EVTBITS = '0'B;
                   DO WHILE ( '0'B );
DO_ERR_01:;
 
/*E*     ERROR: LXX-E$BADACTION
       MESSAGE: Action %U1 is not defined.
*/
                        VLP_ERRCODE = CANNED_ERRCODE;
                        VLP_ERRCODE.ERR# = %E$BADACTION;
                        BARFO.COUNT = BARFO.COUNT + 1;
                        BARFO.ERR.ERRCODE(BARFO.COUNT) = VLP_ERRCODE;
                        BARFO.ERR.FIELD1(BARFO.COUNT) = '1'B;
                        BARFO.ERR.FIELD1_(BARFO.COUNT) =
                             VECTOR(PTR$ -> TEXTC);
                   END;
              END;
    END;
%EJECT;
BARF:
    IF LX_OPTIONS.LS# OR ERROR# OR BARFO.COUNT > 0 THEN DO;
         OUTPUT_BUFFER = ' ';
         OUTPUT_BUFFER_R.VFC = 'A';
         OUTPUT_BUFFER_R.KEY = READ.ASCII_KEY;
         CALL BINCHAR ( OUTPUT_BUFFER_R.SEQ, I );
         J = 0;
         DO WHILE ( J < 10 );
              IF OUTPUT_BUFFER_R.SEQ_R(J) = '0' THEN DO;
                   OUTPUT_BUFFER_R.SEQ_R(J) = ' ';
                   J = J + 1;
              END;
              ELSE J = 10;
         END;
         IF READ.LEVEL > 0 THEN
              CALL BINCHAR ( OUTPUT_BUFFER_R.LVL, READ.LEVEL );
         OUTPUT_BUFFER_R.TXT = INPUT_BUFFER;
         IF READ.LEVEL = 0 OR (READ.LEVEL > 0 AND LX_OPTIONS.LI#) THEN
              CALL M$WRITE ( WRITE_LO );
         IF ERROR# AND PCB_CMDS.ERROR.CODE = %E$SYNERR THEN DO;
              OUTPUT_BUFFER = 'A';
              CALL INSERT ( OUTPUT_BUFFER, 28 + PCB_CMDS.HI_CHAR, 1, '$' );
              CALL M$WRITE ( WRITE_LO );
              VLP_ERRCODE = PCB_CMDS.ERROR;
              CALL M$ERRMSG ( ERR_MSG );
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$LEGALTHERE;
/*E*     ERROR: LXX-E$LEGALTHERE
       MESSAGE: One of the following expected but not found:
*/
              CALL M$ERRMSG ( ERR_MSG );
              PCB_CMDS.NXT = '1'B;
              CALL X$PARSE ( PCB_CMDS );
              IF SEV < 4 THEN SEV = 4;
         END;
         ELSE DO;
              IF ERROR# THEN DO;
                   VLP_ERRCODE = PCB_CMDS.ERROR;
                   CALL M$ERRMSG ( ERR_MSG );
                   IF SEV < 11 THEN SEV = 11;
              END;
         END;
         IF BARFO.COUNT > 0 THEN DO J = 1 TO BARFO.COUNT;
              VLP_ERRCODE = BARFO.ERR.ERRCODE(J);
              IF BARFO.ERR.FIELD1(J) THEN
                   ERR_MSG.FIELD1_ = BARFO.ERR.FIELD1_(J);
              IF BARFO.ERR.FIELD2(J) THEN
                   ERR_MSG.FIELD2_ = BARFO.ERR.FIELD2_(J);
              IF BARFO.ERR.FIELD3(J) THEN
                   ERR_MSG.FIELD3_ = BARFO.ERR.FIELD3_(J);
              CALL M$ERRMSG ( ERR_MSG );
         END;
    END;
    GOTO LOOP;
%EJECT;
CANT_READ:
    IF READ.ERRCODE.MON AND READ.FLAGS.BASE# AND
         READ.ERRCODE.ERR# = %E$EOF THEN DO;
CLOSE_ALL_FILES:;
         CALL XUU$CLOSE ( CLOSE ) ALTRET ( CANT_CLOSE );
         CALL M$DEVICE ( EJECT );
         CALL LXX$SYMTBL ( %LX#SIZEQU, SIZE, PTR$ );
         IF SIZE > 0 THEN DO;
              OUTPUT_BUFFER = 'A **** EQUATE SYMBOL VALUES ****';
              CALL M$WRITE ( WRITE_LO );
              OUTPUT_BUFFER = 'A';
              SIZE = SIZE - SIZEW(EQU);
              DO I = 0 TO SIZE BY SIZEW(EQU);
                   PTR1$ = PINCRW(PTR$, I);
                   J = MOD(I / SIZEW(EQU), 3);
                   IF J = 0 THEN DO;
                        CALL M$WRITE ( WRITE_LO );
                        OUTPUT_BUFFER = 'A';
                   END;
                   CALL BINCHAR ( CHR3, PTR1$ -> EQU.VALUE );
                   CALL CONCAT ( OUTPUT_BUFFER_E.ENT(J),
                        PTR1$ -> EQU.NAME$ -> TEXTC.TEXT,
                        '/', CHR3 );
              END;
              CALL M$WRITE ( WRITE_LO );
         END;
%EJECT;
         CALL M$DEVICE ( EJECT );
         CALL LXX$SYMTBL ( %LX#SIZEVT, SIZE, PTR$ );
         IF SIZE > 0 THEN DO;
              OUTPUT_BUFFER = 'A **** EVENT EQUATE SYMBOLS SORTED BY VALUE ****';
              CALL M$WRITE ( WRITE_LO );
              OUTPUT_BUFFER = 'A';
              SIZE = SIZE - SIZEW(EVT);
              DO I = 0 TO SIZE BY SIZEW(EVT);
                   PTR1$ = PINCRW(PTR$, I);
                   J = MOD(I / SIZEW(EVT), 3);
                   IF J = 0 THEN DO;
                        CALL M$WRITE ( WRITE_LO );
                        OUTPUT_BUFFER = 'A';
                   END;
                   CALL BINCHAR ( CHR3, PTR1$ -> EVT.VALUE );
                   CALL CONCAT ( OUTPUT_BUFFER_E.ENT(J),
                        PTR1$ -> EVT.NAME$ -> TEXTC.TEXT,
                        '/', CHR3 );
                   CALL CONCAT ( OU_BUFFER, '%SET ',
                        PTR1$ -> EVT.NAME$ -> TEXTC.TEXT,
                        ' = ', CHR3, '; /* Event equate */' );
                   IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              END;
              CALL M$WRITE ( WRITE_LO );
         END;
%EJECT;
         CALL M$DEVICE ( EJECT );
         CALL LXX$SYMTBL ( %LX#SIZSTT, SIZE, PTR$ );
         IF SIZE > 0 THEN DO;
              OUTPUT_BUFFER = 'A **** STATE EQUATE SYMBOLS SORTED BY VALUE ****';
              CALL M$WRITE ( WRITE_LO );
              OUTPUT_BUFFER = 'A';
              SIZE = SIZE - SIZEW(STT);
              DO I = 0 TO SIZE BY SIZEW(STT);
                   PTR1$ = PINCRW(PTR$, I);
                   J = MOD(I / SIZEW(STT), 3);
                   IF J = 0 THEN DO;
                        CALL M$WRITE ( WRITE_LO );
                        OUTPUT_BUFFER = 'A';
                   END;
                   CALL BINCHAR ( CHR3, PTR1$ -> STT.VALUE );
                   CALL CONCAT ( OUTPUT_BUFFER_E.ENT(J),
                        PTR1$ -> STT.NAME$ -> TEXTC.TEXT,
                        '/', CHR3 );
                   CALL CONCAT ( OU_BUFFER, '%SET ',
                        PTR1$ -> EVT.NAME$ -> TEXTC.TEXT,
                        ' = ', CHR3, '; /* State equate */' );
                   IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              END;
              CALL M$WRITE ( WRITE_LO );
         END;
%EJECT;
         CALL M$DEVICE ( EJECT );
         CALL LXX$SYMTBL ( %LX#SIZACT, SIZE, PTR$ );
         IF SIZE > 0 THEN DO;
              OUTPUT_BUFFER = 'A **** ACTION EQUATE SYMBOLS SORTED BY VALUE ****';
              CALL M$WRITE ( WRITE_LO );
              OUTPUT_BUFFER = 'A';
              SIZE = SIZE - SIZEW(ACT);
              DO I = 0 TO SIZE BY SIZEW(ACT);
                   PTR1$ = PINCRW(PTR$, I);
                   J = MOD(I / SIZEW(ACT), 3);
                   IF J = 0 THEN DO;
                        CALL M$WRITE ( WRITE_LO );
                        OUTPUT_BUFFER = 'A';
                   END;
                   CALL BINCHAR ( CHR3, PTR1$ -> ACT.VALUE );
                   CALL CONCAT ( OUTPUT_BUFFER_E.ENT(J),
                        PTR1$ -> ACT.NAME$ -> TEXTC.TEXT,
                        '/', CHR3 );
                   CALL CONCAT ( OU_BUFFER, '%SET ',
                        PTR1$ -> ACT.NAME$ -> TEXTC.TEXT,
                        ' = ', CHR3, '; /* Action equate */' );
                   IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              END;
              CALL M$WRITE ( WRITE_LO );
         END;
%EJECT;
         IF NOT FLAGS.HDRNAM THEN DO;
/*E*     ERROR: LXX-E$HDRNAM
       MESSAGE: No header name specified - no header generated.
 */
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$HDRNAM;
              VLP_ERRCODE.SEV = 0;
              CALL M$ERRMSG ( ERR_MSG );
         END;
         ELSE DO;
              PTR$ = ADDR(HDRNAM);
              CALL CONCAT ( OU_BUFFER, '%MACRO ',
                   PTR$ -> TEXTC.TEXT, ' ( NAME=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = 'STCLASS="CONSTANT SYMDEF",';
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(LINHND);
              CALL CONCAT ( OU_BUFFER, 'LINHND=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(DVCHND);
              CALL CONCAT ( OU_BUFFER, 'DVCHND=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(STTHND);
              CALL CONCAT ( OU_BUFFER, 'STTHND=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(STTBFR);
              CALL CONCAT ( OU_BUFFER, 'STTBFR=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(DFLPRO);
              CALL CONCAT ( OU_BUFFER, 'DFLPRO=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(INT);
              CALL CONCAT ( OU_BUFFER, 'INT(YES=''1''B,NO=''0''B)=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(TIMOUT1);
              CALL CONCAT ( OU_BUFFER, 'TIMOUT1=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(TIMOUT2);
              CALL CONCAT ( OU_BUFFER, 'TIMOUT2=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(MAPNAM);
              CALL CONCAT ( OU_BUFFER, 'EMAP=',
                   PTR$ -> TEXTC.TEXT, ',' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(TBLNAM);
              CALL CONCAT ( OU_BUFFER, 'STBL=',
                   PTR$ -> TEXTC.TEXT, ');' );
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              DO J = 0 TO 21;
                   OU_BUFFER = HEADER_BUFFER(J);
                   IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
              END;
              OU_BUFFER = '%MEND;';
              IF LX_OPTIONS.OU# THEN CALL M$WRITE ( WRITE_OU );
         END;
%EJECT;
         IF NOT FLAGS.MAPGEN THEN DO;
 
/*E*     ERROR: LXX-E$NOMAPGEN2
       MESSAGE: No EVENT directives specified - no event map generated.
*/
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$NOMAPGEN2;
              VLP_ERRCODE.SEV = 0;
              CALL M$ERRMSG ( ERR_MSG );
         END;
         IF NOT FLAGS.MAPNAM THEN DO;
 
/*E*     ERROR: LXX-E$NOMAPGEN1
       MESSAGE: No map name specified - no event map generated.
*/
              FLAGS.MAPGEN = '0'B;
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$NOMAPGEN1;
              VLP_ERRCODE.SEV = 0;
              CALL M$ERRMSG ( ERR_MSG );
         END;
         IF FLAGS.MAPGEN AND LX_OPTIONS.OU# THEN DO;
OU_MAPGEN:;
              CALL LXX$SYMTBL ( %LX#SIZEVT, SIZE, PTR$ );
              LDIM = 255;
              HDIM = 0;
              SIZE = SIZE - SIZEW(EVT);
              DO I = 0 TO SIZE BY SIZEW(EVT);
                   PTR1$ = PINCRW(PTR$, I) -> EVT.EQU$;
                   IF LDIM > PTR1$ -> EQU.VALUE THEN
                        LDIM = PTR1$ -> EQU.VALUE;
                   IF HDIM < PTR1$ -> EQU.VALUE THEN
                        HDIM = PTR1$ -> EQU.VALUE;
              END;
              EVTSIZ = HDIM - LDIM + 1;
              CALL LXX$SYMTBL ( %LX#ACQEVT, EVTSIZ, PTR1$ );
              DO I = 0 TO EVTSIZ - 1;
                   PTR1$ -> EVTMAP$(I) = ADDR(NIL);
              END;
              DO I = 0 TO SIZE BY SIZEW(EVT);
                   PTR2$ = PINCRW(PTR$, I);
                   J = PTR2$ -> EVT.EQU$ -> EQU.VALUE - LDIM;
                   PTR1$ -> EVTMAP$(J) = PTR2$ -> EVT.NAME$;
              END;
              PTR$ = ADDR(MAPNAM);
              CALL CONCAT ( OU_BUFFER, '%MACRO ',
                   PTR$ -> TEXTC.TEXT, ' ( NAME=',
                   PTR$ -> TEXTC.TEXT, ',' );
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = 'STCLASS="CONSTANT SYMDEF" );';
              CALL M$WRITE ( WRITE_OU );
              DO I = 0 TO 11;
                   OU_BUFFER = HEADER_BUFFER(I);
                   CALL M$WRITE ( WRITE_OU );
              END;
              CALL BINCHAR ( CHR3, LDIM );
              CALL CONCAT ( OU_BUFFER, '2 LDIM UBIN %INIT(',
                   CHR3, ')%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              CALL BINCHAR ( CHR3, HDIM );
              CALL CONCAT ( OU_BUFFER, '2 HDIM UBIN %INIT(',
                   CHR3, ')%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              CALL BINCHAR ( CHR3, EVTSIZ - 1 );
              CALL CONCAT ( OU_BUFFER, '2 MAP(0:',
                   CHR3, ') UBIN BYTE CALIGNED %INIT(' );
              CALL M$WRITE ( WRITE_OU );
              DO I = 0 TO EVTSIZ - 2;
                   PTR2$ = PTR1$ -> EVTMAP$(I);
                   IF PTR2$ = ADDR(NIL) THEN
                        OU_BUFFER = '   255,';
                   ELSE
                        CALL CONCAT ( OU_BUFFER, '   %',
                             PTR2$ -> TEXTC.TEXT, ',' );
                   CALL M$WRITE ( WRITE_OU );
              END;
              PTR2$ = PTR1$ -> EVTMAP$(EVTSIZ - 1);
              IF PTR2$ = ADDR(NIL) THEN
                   OU_BUFFER = '   255)%CHARTEXT(''/**/'');';
              ELSE
                   CALL CONCAT ( OU_BUFFER, '   %',
                        PTR2$ -> TEXTC.TEXT, ')%CHARTEXT(''/**/'');' );
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = '%MEND;';
              CALL M$WRITE ( WRITE_OU );
         END;
%EJECT;
         IF NOT FLAGS.TBLGEN THEN DO;
 
/*E*     ERROR: LXX-E$NOTBLGEN2
       MESSAGE: No table generating directives specified - no table generated.
*/
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$NOTBLGEN2;
              VLP_ERRCODE.SEV = 0;
              CALL M$ERRMSG ( ERR_MSG );
         END;
         IF NOT FLAGS.TBLNAM THEN DO;
 
/*E*     ERROR: LXX-E$NOTBLGEN1
       MESSAGE: No table name specified - no table generated.
*/
              VLP_ERRCODE = CANNED_ERRCODE;
              VLP_ERRCODE.ERR# = %E$NOTBLGEN1;
              VLP_ERRCODE.SEV = 0;
              CALL M$ERRMSG ( ERR_MSG );
              FLAGS.TBLGEN = '0'B;
         END;
         IF FLAGS.TBLGEN AND LX_OPTIONS.OU# THEN DO;
              PTR$ = ADDR(TBLNAM);
              CALL CONCAT ( OU_BUFFER, '%MACRO ', PTR$ -> TEXTC.TEXT,
                   ' ( NAME=', PTR$ -> TEXTC.TEXT, ',' );
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = 'STCLASS="CONSTANT SYMDEF" );';
              CALL M$WRITE ( WRITE_OU );
              DO I = 0 TO 11;
                   OU_BUFFER = HEADER_BUFFER(I);
                   CALL M$WRITE ( WRITE_OU );
              END;
              CALL BINCHAR ( CHR3, TBL_WID );
              CALL CONCAT ( OU_BUFFER, '2 WID UBIN WORD %INIT(',
                   CHR3, ')%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              CALL BINCHAR ( CHR3, TBL_LEN );
              CALL CONCAT ( OU_BUFFER, '2 LEN UBIN WORD %INIT(',
                   CHR3, ')%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(HDRNAM);
              HDRNAM.SIZE = 6;
              CALL BINCHAR ( PTR$ -> TEXTC.TEXT, TBL_SIZ );
              CALL CONCAT ( OU_BUFFER, '2 MAX UBIN WORD %INIT(',
                   PTR$ -> TEXTC.TEXT, ')%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              CALL BINCHAR ( PTR$ -> TEXTC.TEXT, TBL_SIZ * 2 - 1 );
              CALL CONCAT ( OU_BUFFER, '2 PL6ISDUMB(0:',
                   PTR$ -> TEXTC.TEXT, ') UBIN BYTE CALIGNED %INIT(' );
              CALL M$WRITE ( WRITE_OU );
              CALL LXX$SYMTBL ( %LX#SIZSTT, X, PTR1$ );
              CALL LXX$SYMTBL ( %LX#SIZACT, K, PTR2$ );
              HDRNAM.SIZE = 3;
              HDRNAM.TEXT = '255';
              DO I = 0 TO TBL_SIZ - 2;
                   J = STT_TBL.ACT(I);
                   K = STT_TBL.STT(I);
                   IF J = 255 THEN PTR4$ = ADDR(HDRNAM);
                   ELSE PTR4$ = PINCRW(PTR2$, J * SIZEW(ACT)) -> ACT.NAME$;
                   IF K = 255 THEN PTR3$ = ADDR(HDRNAM);
                   ELSE PTR3$ = PINCRW(PTR1$, K * SIZEW(STT)) -> STT.NAME$;
                   CALL CONCAT ( OU_BUFFER, '   %',
                        PTR4$ -> TEXTC.TEXT, ',   %',
                        PTR3$ -> TEXTC.TEXT, ',' );
                   CALL M$WRITE ( WRITE_OU );
              END;
              J = STT_TBL.ACT(TBL_SIZ - 1);
              K = STT_TBL.STT(TBL_SIZ - 1);
              IF J = 255 THEN PTR4$ = ADDR(HDRNAM);
              ELSE PTR4$ = PINCRW(PTR2$, J * SIZEW(ACT)) -> ACT.NAME$;
              IF K = 255 THEN PTR3$ = ADDR(HDRNAM);
              ELSE PTR3$ = PINCRW(PTR1$, K * SIZEW(STT)) -> STT.NAME$;
              CALL CONCAT ( OU_BUFFER, '   %',
                   PTR4$ -> TEXTC.TEXT, ',   %',
                   PTR3$ -> TEXTC.TEXT, ' )%CHARTEXT(''/**/''),' );
              CALL M$WRITE ( WRITE_OU );
              PTR$ = ADDR(HDRNAM);
              HDRNAM.SIZE = 6;
              CALL BINCHAR ( PTR$ -> TEXTC.TEXT, TBL_SIZ - 1 );
              CALL CONCAT ( OU_BUFFER, '2 TBL(0:', PTR$ -> TEXTC.TEXT,
                   ') REDEF PL6ISDUMB,' );
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = '3 ACT UBIN BYTE CALIGNED,';
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = '3 STT UBIN BYTE CALIGNED;';
              CALL M$WRITE ( WRITE_OU );
              OU_BUFFER = '%MEND;';
              CALL M$WRITE ( WRITE_OU );
         END;
         IF LX_OPTIONS.OU# THEN CALL M$CLOSE ( CLOSE_OU );
         CALL M$CLOSE ( CLOSE_LO );
         CALL M$EXIT;
    END;
    ELSE DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADREAD;
/*E*     ERROR: LXX-E$BADREAD
       MESSAGE: Abnormal return from read service.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = READ.ERRCODE;
         CALL M$ERRMSG ( ERR_MSG );
         CALL M$CLOSE ( CLOSE_LO );
         CALL M$ERR;
    END;
%EJECT;
CANT_OPEN:
    IF OPEN.FLAGS.BASE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADSIOPN;
/*E*     ERROR: LXX-E$BADSIOPN
       MESSAGE: Abnormal return while opening source file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = OPEN.SI_ERRCODE;
    END;
    IF OPEN.FLAGS.UP_DATE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADUIOPN;
/*E*     ERROR: LXX-E$BADUIOPN
       MESSAGE: Abnormal return while opening update file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = OPEN.UI_ERRCODE;
    END;
    IF OPEN.FLAGS.INCLUDE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADINOPN;
/*E*     ERROR: LXX-E$BADINOPN
       MESSAGE: Abnormal return while opening include file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = OPEN.O.INCL_ERRCODE;
    END;
    ERR_MSG.V.DCB# = OPEN.DCB#;
    CALL M$ERRMSG ( ERR_MSG );
    CALL M$CLOSE ( CLOSE_LO );
    CALL M$ERR;
%EJECT;
CANT_CLOSE:
    IF CLOSE.FLAGS.BASE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADSICLS;
/*E*     ERROR: LXX-E$BADSICLS
       MESSAGE: Abnormal return while closing source file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = CLOSE.SI_ERRCODE;
    END;
    IF CLOSE.FLAGS.UP_DATE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADUICLS;
/*E*     ERROR: LXX-E$BADUICLS
       MESSAGE: Abnormal return while closing update file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = CLOSE.UI_ERRCODE;
    END;
    IF CLOSE.FLAGS.INCLUDE# THEN DO;
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$BADINCLS;
/*E*     ERROR: LXX-E$BADINCLS
       MESSAGE: Abnormal return while closing include file.
*/
         CALL M$ERRMSG ( ERR_MSG );
         VLP_ERRCODE = CLOSE.O.INCL_ERRCODE;
    END;
    ERR_MSG.V.DCB# = CLOSE.DCB#;
    CALL M$ERRMSG ( ERR_MSG );
    CALL M$CLOSE ( CLOSE_LO );
    CALL M$ERR;
%EJECT;
BAD_OPTIONS:
    VLP_ERRCODE = PCB_OPTS.ERROR;
    CALL M$ERRMSG ( ERR_MSG );
    IF PCB_OPTS.ERROR.CODE = %E$SYNERR THEN DO;
/*E*     ERROR: LXX-E$LEGALHERE
       MESSAGE: Parser expected one of the following after column %U1:
*/
         CALL BINCHAR ( U1.TXT, B$JIT.CCDISP + PCB_OPTS.HI_CHAR + 1 );
         ERR_MSG.FIELD1_ = VECTOR(U1);
         VLP_ERRCODE = CANNED_ERRCODE;
         VLP_ERRCODE.ERR# = %E$LEGALHERE;
         VLP_ERRCODE.SEV = 0;
         CALL M$ERRMSG ( ERR_MSG );
         ERR_MSG.FIELD1_ = VECTOR(NIL);
         PCB_OPTS.NXT = '1'B;
         CALL X$PARSE ( PCB_OPTS );
    END;
    CALL M$CLOSE ( CLOSE_LO );
    CALL M$ERR;
%EJECT;
VERIFY_SYMBOL:     PROC ALTRET;
 
    DCL TEMP$ PTR;
    DCL TEMP UBIN;
 
    CALL LXX$SYMTBL ( %LX#SIZNAM, SIZE, TEMP$ );
    TEMP = 0;
    DO WHILE ( TEMP < SIZE );
         PTR2$ = PINCRW(TEMP$, J);
         IF PTR$ -> TEXTC.TEXT = PTR2$ -> TEXTC.TEXT THEN RETURN;
         TEMP = TEMP + SIZEW(PTR2$ -> TEXTC);
    END;
    ALTRETURN;
 
END VERIFY_SYMBOL;
%EJECT;
EVALUATE_DECIMAL:  PROC;
 
    DCL CHR(0:0) UBIN BYTE BASED CALIGNED;
    DCL I UBIN;
    DCL TEMP UBIN;
 
    TEMP = 0;
    DO I = 1 TO PTR$ -> CHR(0);
         TEMP = PTR$ -> CHR(I) - 48 + 10 * TEMP;
    END;
    VALUE = VALUE + TEMP;
 
END EVALUATE_DECIMAL;
%EJECT;
LOOKUP_EQUATE:     PROC ALTRET;
 
    DCL TEMP$ PTR;
 
    CALL LXX$SYMTBL ( %LX#SIZEQU, SIZE, TEMP$ );
    SIZE = SIZE - SIZEW(EQU);
    DO J = 0 TO SIZE BY SIZEW(EQU);
         PTR2$ = PINCRW(TEMP$, J);
         IF PTR$ -> TEXTC.TEXT = PTR2$ -> EQU.NAME$ -> TEXTC.TEXT
              THEN DO;
              VALUE = PTR2$ -> EQU.VALUE + VALUE;
              RETURN;
         END;
    END;
    ALTRETURN;
 
END LOOKUP_EQUATE;
%EJECT;
LOOKUP_STATE:      PROC ALTRET;
 
    DCL TEMP$ PTR;
    DCL TEMP1$ PTR;
    DCL TEMP UBIN;
 
    CALL LXX$SYMTBL ( %LX#SIZSTT, SIZE, TEMP$ );
    IF SIZE = 0 THEN ALTRETURN;
    SIZE = SIZE - SIZEW(STT);
    DO TEMP = 0 TO SIZE BY SIZEW(STT);
         TEMP1$ = PINCRW(TEMP$, TEMP) -> STT.NAME$;
         IF TEMP1$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT THEN DO;
              VALUE = PINCRW(TEMP$, TEMP) -> STT.VALUE;
              RETURN;
         END;
    END;
    ALTRETURN;
 
END LOOKUP_STATE;
%EJECT;
LOOKUP_ACTION:     PROC ALTRET;
 
    DCL TEMP$ PTR;
    DCL TEMP1$ PTR;
    DCL TEMP UBIN;
 
    CALL LXX$SYMTBL ( %LX#SIZACT, SIZE, TEMP$ );
    IF SIZE = 0 THEN ALTRETURN;
    SIZE = SIZE - SIZEW(ACT);
    DO TEMP = 0 TO SIZE BY SIZEW(ACT);
         TEMP1$ = PINCRW(TEMP$, TEMP) -> ACT.NAME$;
         IF TEMP1$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT THEN DO;
              VALUE = PINCRW(TEMP$, TEMP) -> ACT.VALUE;
              RETURN;
         END;
    END;
    ALTRETURN;
 
END LOOKUP_ACTION;
%EJECT;
LOOKUP_EVENT:      PROC ALTRET;
 
    DCL TEMP$ PTR;
    DCL TEMP1$ PTR;
    DCL TEMP UBIN;
 
    CALL LXX$SYMTBL ( %LX#SIZEVT, SIZE, TEMP$ );
    IF SIZE = 0 THEN ALTRETURN;
    SIZE = SIZE - SIZEW(EVT);
    DO TEMP = 0 TO SIZE BY SIZEW(EVT);
         TEMP1$ = PINCRW(TEMP$, TEMP) -> EVT.NAME$;
         IF TEMP1$ -> TEXTC.TEXT = PTR$ -> TEXTC.TEXT THEN DO;
              VALUE = PINCRW(TEMP$, TEMP) -> EVT.VALUE;
              RETURN;
         END;
    END;
    ALTRETURN;
 
END LOOKUP_EVENT;
%EJECT;
INIT_STATE_TABLE:  PROC;
 
    DCL TEMP1 UBIN;
    DCL TEMP2 UBIN;
    DCL TEMP$ PTR;
 
    CALL LXX$SYMTBL ( %LX#SIZEVT, TEMP1, TEMP$ );
    CALL LXX$SYMTBL ( %LX#SIZSTT, TEMP2, TEMP$ );
    TBL_WID = TEMP1 / SIZEW(EVT);
    TBL_LEN = TEMP2 / SIZEW(STT);
    TBL_SIZ = TBL_LEN * TBL_WID;
    TEMP2 = TBL_SIZ - 1;
    DO TEMP1 = 0 TO TEMP2;
         STT_TBL.ACT(TEMP1) = 255;
         STT_TBL.STT(TEMP1) = 255;
    END;
    FLAGS.TBLGEN = '1'B;
 
END INIT_STATE_TABLE;
%EJECT;
VERIFY_EVENT: PROC ALTRET;
 
    DCL TEMP1$ PTR;
    DCL TEMP2$ PTR;
    DCL TEMP1 UBIN;
 
    CALL LXX$SYMTBL ( %LX#SIZEVT, SIZE, TEMP1$ );
    SIZE = SIZE - SIZEW(EVT);
    DO TEMP1 = 0 TO SIZE BY SIZEW(EVT);
         TEMP2$ = PINCRW(TEMP1$, TEMP1);
         IF VALUE = TEMP2$ -> EVT.EQU$ -> EQU.VALUE THEN DO;
              PTR$ = TEMP2$ -> EVT.NAME$;
              ALTRETURN;
         END;
    END;
 
END VERIFY_EVENT;
END LXX$MUNGER;
