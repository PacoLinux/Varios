.*M*
FOXI FOXI (FOrtran XSA Interface) provides FORTRAN programs with access to the
XSA Fast Sequential File Access routines.
.*T*
 **************************************************************
 *                                                            *
 *  Copyright (c) Bull HN Information Systems Inc., 1989      *
 *                                                            *
 **************************************************************
.*A*                                             
FOXI (FOrtran Xsa Interface) makes the CP-6 fast sequential file services
available to FORTRAN (or PL-6 or COBOL) application programs.
.*B*
FOXI is provided as a LEMUR library which must be linked with your application
program.  To get the FOXI routines, simply include them in your LINK commands:
 
      !LINK FRED, WILMA OVER PEBBLES (UNSAT=(FOXI.X))
 
To get detailed information about FOXI, try
 
          !HELP (FOXI.X) ROUTINES
 
or
 
          !HELP (FOXI.X) TOPICS
 
A generalized overview of FOXI follows; type ? for more.
.*B*
FOXI (FOrtran XSA Interface) provides FORTRAN, COBOL, and PL-6 programs with
simplified access to the XSA Fast Sequential File Access routines.  Up to 10
files may be open at one time.  FOXI manages its own buffers in the next
available user data segment; programs that use all the data segments are SOL.
Space is reclaimed when a file is closed (adjacent free areas are automatically
combined), and will be available for use with subsequent files.
.*B*
The XSA routines provide fast sequential access to keyed, indexed, relative,
and consec files.  They may be used on other types of files, but to no
advantage (relative to PL-6 monitor I/O; they would still be faster than
FORTRAN reads with an '(A)' format).  The speed is obtained at the expense of
function; the only operations permitted are reading and writing sequentially,
positioning by record count, and positioning to one or the other end of the
file.
 
The XSA package opens files in block mode (i.e. it reads the raw granules of
the file), and interprets the internal structure of the file without the help
of the monitor; in output mode, XSA constructs a file in its buffers, then
writes it block by block to disk.  This buffer space used by XSA must be
provided by the user; FOXI handles the details of this, requiring only that the
FOXI user pass in a count of pages to be used for data (and, optionally, for
keys).
.*B*
The XSA package itself is documented in the Host Library Services Manual, order
number CE71; consult that opus for a complete description of the XSA routines.
This help file will concern itself only with the interface provided by FOXI.
 
To obtain a brief description of the FOXI subroutine calls, type:
 
      !HELP  (FOXI.X)  ROUTINES
 
Each routine is documented in its own topic, with subtopics describing the
arguments in detail.  For example, to see the topic describing the Open
routine, type:
 
      !HELP  (FOXI.X)  FAST$OPEN
 
HELPful hints on when and how to use FOXI to the best advantage may be found in
the topics TECHNIQUES and RATIONALE.
.*
.*K* LINKING
FOXI is a Lemur-style library; it may be referenced either as a library in the
UnSat option of a Link command, or as an object unit on the link.  Some rununit
space may be saved by linking FOXI as a library, but only if not all the FOXI
routines will be called; otherwise, there is no advantage to treating FOXI as a
library.
 
Examples:
 
      !Link Fred, Wilma to Pebbles (UNSAT=(FOXI.X))   - or -
      !Link Barney, FOXI.X over Bedrock
 
.*
.*K* FAST$OPEN OPEN
Call:
 
      CALL FAST$OPEN (IOSTAT, UNIT [, FID, DBUFSIZE, (*)KBUFSIZE,
                      FUN, SHARE, EXIST, UNFAST ] )
 
FAST$OPEN opens a DCB to the named file (or to whatever is already in the DCB,
if FID is blank or not present).  DBUFSIZE and KBUFSIZE specify the number of
pages to use for data and key buffers, respectively (large numbers cut down on
the number of actual I/O calls issued).  FUN, SHARE, and EXIST specify how the
file is to be opened.  UNFAST determines the action to be taken if a subsequent
FOXI call requests a service not provided by the XSA package.
.*B*
The last seven options are optional; any or all of them may be omitted.  PL-6
callers may simply specify null parameters (i.e. two or more consecutive
commas); calls from languages that do not allow omission of arguments within an
argument list may use the value -1 to indicate omission of an argument (except
for the FID parameter, for which a single blank is the sign of omission).
Omitted arguments will be ignored when the file is actually opened, thus
allowing these parameters (except for DBUFSIZE and KBUFSIZE) to be set
externally (via !Set or command-line DCB correspondences).
 
(*) Key Buffers are not used when Fun=Create (FUN=1); therefore, KBUFSIZE is
used to specify the Initial Extent Size (IXTNSIZ) for the new file.  The size
of supplementary extents (XTNSIZE) will be determined by the value set in the
DCB (via !Set or !Adjust).
 
Note:  IOSTAT and UNIT are required for all FOXI calls; they will be described
here only.
.*B* IOSTAT ERRCODE
IOSTAT <INTEGER>
 
IOSTAT returns a standard CP-6 error code if a monitor or XSA error occurs;
this code may be displayed via the ERROROUT FORTRAN subroutine, or, in Delta,
via the \J format specifier, as:  'D IOSTAT\J'.  IOSTAT also returns the
following special codes for FOXI errors:
 
 IOSTAT   Meaning
 
    -1    Error returned by Find$DCB (all routines)
    -2    DCB not open               (all except FAST$OPEN)
    -3    DCB not in table           (all except FAST$OPEN)
    -4    DCB already open           (FAST$OPEN only)
    -5    DCB table full             (FAST$OPEN only)
    -6    Data Segment full          (FAST$OPEN only)
    -7    Invalid Fun value          (FAST$OPEN only)
    -8    Invalid Share value        (FAST$OPEN only)
    -9    Invalid Exist value        (FAST$OPEN only)
   -10    Invalid Disp value         (FAST$CLOSE only)
   -11    DBufSize < 0               (FAST$OPEN only)
   -12    KBufSize (IXtnSize) < 0    (FAST$OPEN only)
   -13    Invalid UnFast value       (FAST$OPEN only)
 
.*
.*B* UNIT DCBNAME DCBNUMB DCB_NUMBER DCBNO
UNIT
 
Either an INTEGER FORTRAN Unit Number (E.g. 100 for F$100), a blank-terminated
text DCB name (as, 'F$100 '), or a DCB number shifted into the upper halfword
of an INTEGER variable (or occupying an entire INTEGER*2 variable).  It is most
efficient to provide the DCB number; FIND$DCB may be used to obtain the DCB
number corresponding to any Unit or DCB Name (see the FIND$DCB  and TECHNIQUES
topics in this HELP file).
 
.*
.*B* FID FILE_NAME
FID <CHARACTER*(*)>
 
FID must contain either a valid CP-6 fid, or blanks.  If FID is blank or not
present, FAST$OPEN will attempt to open the DCB "as is"; this is useful for
opening DCBS that are defined as command-line DCBs.  FAST$OPEN parses the
complete fid; if any errors occur, the open is aborted and the monitor error is
returned in IOSTAT.
 
When FAST$OPEN is called from a COBOL74 routine, FID must contain at least one
blank following the actual CP-6 fid.  (This restriction applies as well to PL-6
routines that do not specify Conv(0) on the Entry Dcl for this routine; see the
macro FOXI$Ents in FOXI_C.X for the proper Dcls.)
.*
.*B* DBUFSIZE DATA_GRANULE_BUFFERS
DBUFSIZE <INTEGER>
 
DBUFSIZE specifies the number of pages that should be used by XSA for cacheing
this file's data granules.  This must be at least one, and should be at least
two.  The more pages that are available to XSA, the fewer disk I/O calls it
must do; however, if space is at a premium, smaller buffers may be used.  If
DBUFSIZE is not specified (or is specified with the value -1), the default is
five (5) pages.
 
.*
.*B* KBUFSIZE KEY_GRANULE_BUFFERS IXTNSIZE INITIAL_EXTENT_SIZE
KBUFSIZE <INTEGER>
 
KBUFSIZE specifies the number of pages that should be used by XSA for cacheing
this file's key granules.  If the file is not keyed, this number may be zero;
otherwise, it must be at least one, and should be at least two.  The more pages
that are available to XSA, the fewer disk I/O calls it must do; however, if
space is at a premium, smaller buffers may be used.  If KBUFSIZE is not
specified (or is specified with the value -1), the default is zero (0).
 
On Fun=Create (FUN=1) opens, KBUFSIZE is used to specify the initial size of
the file (IXTNSIZE); the default in this case is to use the CP-6 default, which
is two (2) granules.
 
.*
.*B* FUN FUNCTION MODE
FUN <INTEGER>
 
FUN specifies whether the file is to be opened for input (FUN=0), output
(FUN=1), or update (FUN=2).  Values other than these will abort the open with
IOSTAT=-7.  If FUN is not specified (or is specified with the value -1), the
default is to use whatever is currently in the DCB.
 
Note that if FUN=2 (update), the XSA routines will use normal Monitor I/O
rather than FSFA mode; this does not preclude any performance gains over
FORTRAN I/O, since all FORMAT scanning and other overhead will be eliminated,
but the gains will not be as pronounced.
 
.*
.*B* SHARE
SHARE <INTEGER>
 
SHARE specifies, for input only, whether other users may read the file at the
same time (SHARE=1, in) or not (SHARE=0, none); the file may be shared with
updaters, too, by specifying SHARE=2.  Values other than these will abort the
open with IOSTAT=-8. If SHARE is not specified (or is specified with the value
-1), the default is to use whatever is currently in the DCB.
 
Note that if SHARE=2 (all), the XSA routines will use normal Monitor I/O rather
than FSFA mode; this does not preclude any performance gains over FORTRAN I/O,
since all FORMAT scanning and other overhead will be eliminated, but the gains
will not be as pronounced.
 
.*
.*B* EXIST
EXIST <INTEGER>
 
EXIST specifies, for output only, what to do if the named file already exists.
The options are to create a new file (EXIST=1), append to the old file
(EXIST=2), or return an error to the user (EXIST=0).  Values other than zero,
one, or two will abort the open with IOSTAT=-9.  If EXIST is not specified (or
is specified with the value -1), the default is to use whatever is currently in
the DCB.
 
.*
.*B* UNFAST
UNFAST <INTEGER>
 
UNFAST specifies the action to be taken by the XSA routines if a FOXI call
requests a service that the XSA routines do not provide.  The options are to
close and reopen the file, and continue using normal monitor I/O (UNFAST=0), or
to return an error to the user (UNFAST=1).  Values other than zero or one will
abort the open with IOSTAT=-13.  If UNFAST is not specified (or is specified
with the value -1), the default is to continue (UNFAST=0).
.*
.*K* FAST$CLOSE CLOSE
Call:
 
      CALL FAST$CLOSE (IOSTAT, UNIT [, DISP ] )
 
FAST$CLOSE closes a DCB that was opened previously by FAST$OPEN.  If the DCB
cannot be found in FOXI's internal tables, or if it is not open, this routine
returns an error.  The optional argument DISP determines whether the file will
be saved or deleted (output only).
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for info on DISP.
.*B* DISP STATUS
DISP <INTEGER>
 
DISP determines whether the file being created should be saved (DISP=2) or
released (DISP=1) during the close.  Any other value will result in an error
return, with IOSTAT=-10.  If DISP is not specified, the default is DISP=2
(SAVE).
 
.*
.*B* IOSTAT UNIT DCBNAME DCBNUMB ERRCODE
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
.*
.*K* FAST$READ READ
Call:
 
      CALL FAST$READ (IOSTAT, UNIT, BUFFER, BLEN [, ARS, DVBYTE,
                       EOMCHAR, KBUFFER, KBLEN ] )
 
FAST$READ reads a record from the specifed file, and optionally returns various
information about the record read.  The last five arguments are optional;
however, if KBUFFER is specified, KBLEN must be, as well.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
.*
.*B* BUFFER
BUFFER <CHARACTER*(BLEN)>
 
FAST$READ reads data into this buffer.  If the buffer is too small for the next
data record, an error code will be returned in IOSTAT.  BLEN specifies the
physical length of the buffer; ARS returns the count of bytes actually read.
The buffer is not blank-filled before reading; this is the user's
responsibility.
 
.*
.*B* BLEN BUFFER_LENGTH
BLEN <INTEGER>
 
 This is the physical size of BUFFER (the max number of bytes that can be read
in).
 
.*
.*B* ARS ACTUAL_RECORD_SIZE RECSIZE
ARS <INTEGER>
 
This returns the number of bytes actually read into BUFFER.  If ARS is less
than BLEN, the remaining bytes in BUFFER will not be changed; no blank filling
is performed.
 
.*
.*B* DVBYTE
DVBYTE <INTEGER>
 
 This returns a collection of flags describing the record read; these are
described in the Monitor Services manual, order number CE74, under Additional
Fields in the DCB.  The nine bits from XSA_PARAM.DvByte are stored in the least
significant byte of DVBYTE; the upper three bytes are zero filled.
 
.*
.*B* EOMCHAR
EOMCHAR <CHARACTER*(1)>
 
This returns the value from XSA_PARAM.EOMCHAR, the meaning of which is somewhat
obscure.
 
*
.*B* KBUFFER KEY_BUFFER
KBUFFER <CHARACTER*(KBLEN)>
 
This returns the key of the record read.  The key is returned in TextC format,
with a leading length byte followed by the bytes of the key; therefor, KBLEN
must be one greater than the length of the longest key expected.
 
.*
.*B* KBLEN KEY_BUFFER_LENGTH
KBLEN <INTEGER>
 
This is the size, in bytes, of the key buffer (KBUFFER).  The length of the
actual key is returned in the first byte of KBUFFER, followed by the bytes of
the actual key; thus, KBLEN must be one greater than the length of the longest
key expected.  Valid ranges for KBLEN are 2 - 512.
 
.*
.*B* IOSTAT UNIT DCBNAME DCBNUMB ERRCODE
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
.*
.*K* FAST$WRITE WRITE
Call:
 
      CALL FAST$WRITE (IOSTAT, UNIT, BUFFER, BLEN [, VFC, BIN, TRANS ] )
 
FAST$WRITE writes a record from BUFFER (1:BLEN) to the current file;
optionally, the data record may be written with the VFC, BIN, or TRANS flags
set.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
.*
.*B* BUFFER
BUFFER <CHARACTER*(BLEN)>
 
FAST$WRITE writes data from the first BLEN bytes of this buffer.
 
.*
.*B* BLEN BUFFER_LENGTH
BLEN <INTEGER>
 
This is the logical size of BUFFER (the number of bytes that are to be
written).
 
.*
.*B* VFC
VFC <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the VFC attribute.  If VFC is not specified, the default is .FALSE.  If
the LOGICAL data type is not available in the caller's language, the INTEGER
(aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE. and
.FALSE., respectively.
 
.*
.*B* BINARY
BIN <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the BIN (binary) attribute.  If BIN is not specified, the default is
 .FALSE.  If the LOGICAL data type is not available in the caller's language,
 the INTEGER (aka COMP-6) values -1 and 0 (zero), may be substituted for
.TRUE. and .FALSE., respectively.
 
.*
.*B* TRANSPARENT
TRANS <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the TRANS (transparent) attribute.  If TRANS is not specified, the default
is .FALSE. If the LOGICAL data type is not available in the caller's language,
the INTEGER (aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE.
and .FALSE., respectively.
 
.*
.*B* IOSTAT UNIT DCBNAME DCBNUMB ERRCODE
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
.*
.*K* FAST$PFIL PFIL FAST$REWIND REWIND
Call:
 
      CALL FAST$PFIL (IOSTAT, UNIT [, BOF ] )
 
FAST$PFIL positions to either the beginning (BOF=.TRUE.) or the end
(BOF=.FALSE.) of the specified file.
 
Alternate Call:
 
      CALL FAST$REWIND (IOSTAT, UNIT)
 
FAST$REWIND is equivalent to FAST$PFIL (IOSTAT, UNIT, .TRUE.).
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
.*
.*B* BOF BEGINNING_OF_FILE
BOF <LOGICAL>
 
Specifies whether to position to the beginning (.TRUE.)  or the end (.FALSE.)
of the file.  If BOF is not specified, the default is .TRUE.  If the LOGICAL
data type is not available in the caller's language, the INTEGER (aka COMP-6)
values -1 and 0 (zero), may be substituted for .TRUE. and .FALSE., respect-
ively.
 
.*
.*B* IOSTAT UNIT DCBNAME DCBNUMB ERRCODE
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
.*
.*K*  FAST$PRECORD PRECORD
Call:
 
      CALL FAST$PRECORD (IOSTAT, UNIT, COUNT [, KBUFFER, KLEN ] )
 
FAST$PRECORD moves the current position in the file by COUNT records, and
optionally, returns the key of the record which would be read next.  Attempting
to position beyond either end of the file will result in a monitor error.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
.*
.*B* COUNT NRECS
COUNT <INTEGER>
 
COUNT specifies how many records, and in which direction, to position.  If
COUNT is positive, the direction is toward the end of the file; if COUNT is
negative, the direction is toward the beginning.
 
(WARNING:  The XSA routines do not currently support counts less than zero;
specification of a negative count (backspace operation) will result in the file
being closed and re-opened for "normal" monitor I/O, unless UNFAST=ERROR has
been specified (either on the Fast$Open call, or via the UNFAST$ERROR routine),
in which case an error will result).
 
.*
.*B* KBUFFER KEY_BUFFER
KBUFFER <CHARACTER*(KBLEN)>
 
This returns the key of the record which would be read next.  The key is
returned in TextC format, with a leading length byte followed by the bytes of
the key; therefor, KBLEN must be one greater than the length of the longest key
expected.
 
.*
.*B* KBLEN KEY_BUFFER_LENGTH
KBLEN <INTEGER>
 
This is the size, in bytes, of the key buffer (KBUFFER).  The length of the
actual key is returned in the first byte of KBUFFER, followed by the bytes of
the actual key; thus, KBLEN must be one greater than the length of the longest
key expected.  The valid range for KBLEN is 2 - 512.
 
.*
.*B* IOSTAT UNIT DCBNAME DCBNUMB ERRCODE
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
.*
.*K* UNFAST$ERROR UNFAST$ALTRET
Call:
 
      CALL  UNFAST$ERROR  ( IOSTAT, UNIT )
 -or-
      CALL  UNFAST$ALTRET ( IOSTAT, UNIT )
 
UNFAST$ERROR sets the UnFast# flag for the specified unit.  When this flag is
set, subsequent calls that would otherwise cause the XSA routines to revert to
normal monitor I/O (principally backspace operations via FAST$PRECORD) will
incur a library error (XSA-00097-0) instead.  The effect of this call may be
reversed at any time by a call to UNFAST$CONTINUE.
 
Note that UNFAST$ALTRET is a synonym for UNFAST$ERROR; either name may be used,
with identical effect.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
.*
.*K* UNFAST$CONTINUE UNFAST$MONITOR
Call:
 
      CALL  UNFAST$CONTINUE ( IOSTAT, UNIT )
 -or-
      CALL  UNFAST$MONITOR  ( IOSTAT, UNIT )
 
UNFAST$CONTINUE resets the UnFast# flag for the specified unit.  When this flag
is reset, subsequent calls that request services not supported by the XSA
routines will cause the routines to revert to normal monitor I/O, rather than
incur a library error.  (The FOXI routine most likely to cause this condition
is FAST$PRECORD with a negative count.)
 
This call cancels the effect of UNFAST$ERROR (or UNFAST=1 on the call to
FAST$OPEN).  Note also that UNFAST$MONITOR is simply a synonym for
UNFAST$CONTINUE; either name may be used, with identical effect.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
.*
.*K* ROUTINES CALLS
The routines in the FOXI library are:
 
      FAST$OPEN         Open a file
      FAST$CLOSE        Close a file
      FAST$READ         Read a record from a file
      FAST$WRITE        Write a record to a file
      FAST$PFIL         Position to the beginning or end of a file
      FAST$PRECORD      Position forward or backward in the file
 
      UNFAST$ERROR      Cause FOXI routines to return an error on
      (UNFAST$ALTRET)     subsequent calls that would otherwise cause
                          XSA to return to "normal" monitor I/O.
 
      UNFAST$CONTINUE   Cause FOXI routines to continue processing in
      (UNFAST$MONITOR)    UnFast mode when unsupported services are
                          requested.
 
Type ? for more . . .
.*B*
Utility routines also provided (and used internally):
 
      FIND$DCB          Utility routine to get a DCB number, given a
                        FORTRAN unit number or a text DCB name.
 
      IOSDCODE          Function to grab the error number out of an
                        IOSTAT variable.
 
For information on a particular routine, type:
 
      !HELP  (FOXI.X)  routinename
 
.*
.*K* RATIONALE WHY_USE_FOXI
FORTRAN formatted I/O is expensive, even when the FORMAT consists of nothing
but a single 'A' format.  FORTRAN always has to go through code to figure out
that it doesn't need to do anything.  For applications where the user wants
only to read or write a character record, with no formatting, FOXI provides
significant performance gains.  (Note that any buffer may be used, including a
COMMON block containing data items of arbitrary types.)
 
One test program, which simply copied one file to another (adding even parity),
took 110 CPU seconds using FORTRAN sequential I/O with '(A)' formats; when
converted to FOXI, this same program took only 14 CPU seconds!  Clearly,
dramatic savings in processing time can be achieved with relatively little
effort, especially in cases where the program is I/O intensive (such as our
test case).  In any event, the I/O overhead incurred by the FORTRAN Library is
eliminated for any units that are converted to FOXI I/O.  (See the topic
TEST_RESULTS for further info on the test case cited above.)
 
.*B*
FORTRAN unformatted (binary) I/O is faster than FORMATted I/O, but will only
work in cases where the record lengths are known in advance; FOXI can process
variable-length as well as fixed-length records.
.*B* PL6
 
PL-6 programmers may find FOXI useful as a somewhat simplified front end for
the XSA routines.  FOXI takes care of the details of memory and FPT management
for the programmer, thus freeing his or her mind for more productive tasks.  To
make FOXI more useful for the PL-6 programmer, all the routines will AltReturn
when the IOSTAT parameter is set to a non-zero value.  In addition, Entry DCLs
for the FOXI routines are defined in the macro Foxi$Ents, in the file FOXI_C.X.
 
.*B* COBOL
COBOL uses the XSA package for its runtime I/O, when applicable, so FOXI will
provide little speed advantage.  However, FOXI permits the program to specify
filenames dynamically, at runtime, while COBOL74 does not; FOXI also has very
little overhead associated with I/O calls, and MAY be somewhat faster than
COBOL's I/O.
 
NOTE:  When FAST$OPEN is called from a COBOL routine, the FID parameter (if
passed) must contain at least one trailing blank (following the actual CP-6
fid).
.*
.*K* FIND$DCB
Call:
 
      CALL FIND$DCB (UNIT, DCBNUMBER [, BUILDFLAG ] )
 
FIND$DCB takes in either a FORTRAN unit number, a text DCB name, or a COBOL FIB
(i.e. a DCB number in a halfword on a word boundary(*)), and returns an Integer
(or SBin) DCB number.  If BUILDFLAG is not specified, or is specified and is
 .TRUE., FIND$DCB will create the DCB if it does not exist; otherwise, if the
DCB does not exist, FIND$DCB will return a -1 as the DCB number.
 
(*) A true COBOL FIB is on a word boundary; this routine will accept values
aligned to a half-word boundary.  (Note that this routine will NOT work with
DCB numbers greater than 511.)
 
.*B* UNIT DCBNAME COBOL_FIB
UNIT
 
One of the following:
 
a) An INTEGER FORTRAN unit number (e.g. 105, representing F$105);
 
b) A blank-terminated CHARACTER DCB name (e.g. 'F$105 ');
 
c) A DCB number in the upper halfword of an INTEGER word (this is what COBOL
passes when an FD name is specified as an argument in an ENTER PL-6 style call;
it is also what COBOL85 passes when the _DCBNUM construct is used), or in an
INTEGER*2 variable.
 
.*
.*B* DCBNUMBER DCB_NUMBER DCBNO
DCBNUMBER <INTEGER>
 
Returns the DCB number for the specified DCB.  If the DCB does not exist (or
cannot be created), DCBNUMBER returns -1.
 
WARNING!  If the DCBNUMBER returned by FIND$DCB is greater than 511, it must
NOT be shifted left and passed to a FOXI routine.  This is an artifact of the
algorithm used by FIND$DCB itself.
.*
.*B* BUILDFLAG BUILD_FLAG
BUILDFLAG  <LOGICAL>
 
Specifies whether (.TRUE.) or not (.FALSE.) to create the specifed DCB if it
does not already exist.  If BUILDFLAG is not present, the default is .TRUE.  If
the LOGICAL data type is not available in the caller's language, the INTEGER
(aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE. and .FALSE.,
respectively.
 
.*
.*K* IOSDCODE
Call:
 
      IERRNUMB = IOSDCODE (IOSTAT)
 
IOSDCODE returns the error number portion of a standard CP-6 error code.  This
is useful for testing for end-of-file, for example, since the error number is a
much smaller, easier to remember constant than is the full error code (when
expressed as an Integer value).
 
Both the argument and the result are integers; the argument may be any IOSTAT
variable returned by either a FORTRAN I/O statement or FOXI call.
.*
.*K* CHECKING_FOR_END_OF_FILE  CHECKING_FOR_ERRORS END_OF_FILE
When called from Fortran code, FOXI routines always return to the statement
following the call.  The only way to determine that an error has occured is to
examine the value returned by FOXI in the IOSTAT variable.  If this value is
zero, no error has occured.  If the value is a small negative number (-1..-13),
the FOXI routines have detected an error (see the IOStat subtopic in the topic
FAST$OPEN for details).  Otherwise, a Monitor I/O error (e.g. END-OF-FILE,
LOST-DATA) has occured.  (The CP-6 Programmer's Reference Manual contains a
list of possible Monitor errors; in addition, the Reference Manuals for Fortran
and COBOL detail the errors that may be encountered when using native I/O
calls.  Consult these works for further information.)
 
.*B*
The Monitor I/O error of most interest to the FOXI user is E$EOF, or End of
File.  This error code (in all of its flavors) has an error number of 6.  The
following code, then, will detect End of File on a FAST$READ (as well as handle
any other errors that might occur):
 
.*X*
.FIF
.*R*
      CALL  FAST$READ  (IOS888 . . . .
      IF (IOS888 .NE. 0 ) THEN
         IF (IOS888 .LT. 0 .AND. IOS888 .GE. -10) THEN
C           FOXI error . . .
         ELSE
            IERR888 = IOSDCODE (IOS888)
            IF (IERR888 .EQ. 6) THEN
               GO TO E$EOF888
            ELSE
C              Other I/O error . . .
            END IF
         END IF
      END IF
 
.*X*
.FIN
.*R*
.*B*  PL6_CONSIDERATIONS
The FOXI routines will AltReturn if IOSTAT is non-zero; thus, PL6 programmers
may use the standard AltRet/WhenAltReturn clauses to field FOXI errors.  The
IOSTAT value returned is in standard CP-6 error code format.
.*
.*K* OWNER
Andrew Birner, Zenith Electronics Corporation
.*K* KUDOS ACKNOWLEDGEMENTS
Many thanks to John Joseph for his assistance in making this Help file more
readable.
.*K* CHANGES
09/01/88 Fixed up the XCon processing, to account for the fact that XCon
         screws up StepCC values.  This involved adding two more routines,
         FAST$XCON_SET and FAST$XCON_RESET.
.*B*
08/01/88 Added support for Unfast# bit --
         This involved a new parameter for Fast$Open, and two new routines,
         UNFAST$ERROR and UNFAST$CONTINUE.
.*R*
11/02/87 Fixed FIND$DCB to find its own DCBs.
.*R*
10/26/87 Modified all routines to AltReturn iff IOSTAT set ~= 0
         Took the B_POINTER_D.:LIBRARY junk out of FOXI_CRU, since
           Link can just as easily find it in :LIB_SYSTEM.:SYS.
.*R*
06/26/87 Modified FAST$OPEN to:
 - use the KBUFSIZE value as IXTNSIZ for Create opens;
 - let DBUFSIZE default if not present;
 - let FID default to blanks if not present;
 - add some error checking for negative values on DBUFSIZE and KBUFSIZE;
 - allow Fun=Update and Share=All (although FSFA mode will be off).
.*R*
06/25/87 Modified FOXI_CRU to copy B_POINTER_D.:LIBRARY into FOXI, and added a
Conv(5) call to B_POINTER in FAST$OPEN; this eliminates the need for specifying
B_POINTER_D.:LIBRARY as an OU on every link.
.*B*
03/19/87 Fixed a bug with not specifying KBufSize on FAST$OPEN calls.
.*
.*K* TECHNIQUES EFFICIENCY_CONSIDERATIONS TRICKS_OF_THE_TRADE
This topic is a repository for hints on improving the efficiency of programs
that use FOXI.  These "tricks of the trade" are described in the following
sub-topics; type '?' for the next trick, or '??' for all of them.
.*
.*B* UNIT_SHOULD_BE_DCBNO
FOXI accepts three different constructs as UNIT specifiers:  Text DCB names,
FORTRAN INTEGER unit specifiers, and Cobol-style DCB numbers (imitation FIBs).
This virtuosity is not without its price, however; FOXI must determine, for
each call, what it has been passed, and deal with it.  Not all of the options
require the same amount of processing; in fact, the FORTRAN-style unit numbers
are the MOST expensive of the three!  The cheapest alternative is the COBOL-
style call; fortunately, this form can be used from FORTRAN programs, as well.
 
Type ? for more . . .
 
.*B*
The routine FIND$DCB, described elsewhere in this HELP file, may be used to
obtain the DCB number corresponding to a particular FORTRAN Unit; this may,
after suitable processing, be used on subsequent calls to FOXI routines, to
speed things up.  The code (for unit F$555) would look something like this:
 
      CALL  FAST$OPEN  (IOSTAT, 555, . . . .)
      CALL  FIND$DCB   (555, IDCB555)
      IDCB555 = ISL (IDCB555, 18)
      CALL  FAST$READ  (IOSTAT, IDCB555, . . .)
 
 -or-
 
      INTEGER*2 IDCB555
       .
      CALL  FAST$OPEN  (IOSTAT, 555, . . . .)
      CALL  FIND$DCB   (555, ITEMP)
      IDCB555 = ITEMP
      CALL  FAST$READ  (IOSTAT, IDCB555, . . .)
 
HOWEVER:  If you have more than 511 DCBs in your program, this trick will NOT
work!  If the DCB number returned by FIND$DCB is greater than 511, you must use
one of the other forms of UNIT specifier.
.*
.*K* SUITABILITY_ANALYSIS PMON
PMON.X is a useful tool for estimating the savings that might be achieved by
converting to FOXI.  PMON must be installed as a Debugger by your System
Manager; if it has not been, contact him or her regarding the possibility of
making PMON available.   To evaluate a program for Foxi use, try the following:
 
    !Under PMON      "associate the PMON debugger
    !your_run_unit. . . .   "run your standard FORTRAN application
    !PMDISP.X  your_run_unit., *PM_DATA   "display the performance statistics
 
The third step will produce a listing of procedures and the time spent in each,
sorted by descending CPU time.  All the routines with names like XFG_5FSCAN or
XFG_7IEDIT are FORTRAN I/O routines; they would be eliminated if all program
I/O were done via FOXI routines.
 
.*
.*K* COMMAND_LINE_DCBS POSITIONAL_DCBS
FOXI can be used to read and write files specified on the command line, using
standard rununit-invocation syntax.  However, FORTRAN will not automatically
create DCBs for unit numbers used in FOXI calls; therefore, Link will not be
able to set up correspondences between these units and the four command-line
dcbs (i.e. via the DCB1/SIDCB, etc. Link options).  To force FORTRAN to
generate a DCB for a unit used only in FOXI calls, use the Unit FORTRAN
compiler option.  For example, to force FORTRAN to create DCBS for units 200
and 400, use a command like:
 
    !FORTRAN  source  OVER  object  (....,Unit (200, 400))
.*
.*K* XINDEX
FOXI.X
.*R*
AID=PROGRAMMING
.*R*
FAST_IO
.*K* XINDEX_ABSTRACT
TOOL=FOXI
.*R*
FOrtran Xsa Interface is the interface to the Fast Sequential File Access
package.
.*K* TEST_RESULTS
This topic describes the results of putting FOXI into a simple I/O bound
program.  The same source is used to generate three rununits; the different
versions are, of course, determined by FORTRAN conditional compilation
statements.  The three flavors are:
 
 FOXI_TST_Y     Standard FORTRAN I/O.
 FOXI_TST_XZ    FOXI I/O, using the integer value 200 as the Unit
 FOXI_TST_X     FOXI I/O, using the DCB number of F$200 as the Unit
 
(For more information on the difference between the X and XZ cases, see the
topic TECHNIQUES in this HELP file.)
 
Type ? for a summary of the test results . . .
 
.*B*
.*X*
.FIF
.*R*
    Test          CPU time      % Improvement
    -----------   -----------   ----------------
    FOXI_TST_Y    01:53.14        ----
    FOXI_TST_XZ   00:30.40        73.1%
    FOXI_TST_X    00:26.69        76.4%  (12.2% vs. XZ)
 
                  % Execution time/
    Test          (time in seconds)       % Improvement
    -----------   -----------------       ----------------
    FOXI_TST_Y     65.49% (0:74.10)         ----
    FOXI_TST_XZ    42.99% (0:13.07)         82.4%
    FOXI_TST_X     39.04% (0:10.42)         86.9%  (20.0% vs. XZ)
 
                  % Service time/
    Test          (time in seconds)       % Improvement
    -----------   -----------------       ----------------
    FOXI_TST_Y     44.51% (0:39.04)         ----
    FOXI_TST_XZ    57.01% (0:17.33)         55.6%
    FOXI_TST_X     60.96% (0:16.27)         58.0%  (06.1% vs. XZ)
 
.*X*
.fin
.*R*
Type ? for more . . .
 
.*B*
The rest of this topic is a Dribble of the test session; it is broken into the
following subtopics:
 
  !HELP (FOXI.X) TEST_RESULTS COMPILE          The compilation phase
  !HELP (FOXI.X) TEST_RESULTS LINK             The linking
  !HELP (FOXI.X) TEST_RESULTS EXECUTION        The running
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_X       The results for X
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_XZ      The results for XZ
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_Y       The results for Y
 
Peruse at your own risk . . .
 
.*B*
.*X*
.FIF
.*R*
DRIBBLE ON @  16:13 11/02/87
!ECHO
!XEQ FOXI_TST_JCL
$JOB NAME=FOXI_TST_JCL
$RES TIME=10, MEM=256
$"
.*B* COMPILE COMPILATION
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_X  (NLS,X,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
 X-STATEMENTS COMPILED: 20
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_XZ (NLS,X,Z,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
 X-STATEMENTS COMPILED: 20
 Z-STATEMENTS COMPILED: 2
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_Y  (NLS,Y,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
* INFO:          INFID is declared but never used.  No storage allocated.
* INFO:          OUTFID is declared but never used.  No storage allocated.
* INFO:          DCB200 is declared but never used.  No storage allocated.
* INFO:          DCB400 is declared but never used.  No storage allocated.
 Y-STATEMENTS COMPILED: 11
$"
.*B* LINK
$LINK FOXI_TST_OUF1_X  OVER FOXI_TST_X  (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  Library file :LIB_SYSTEM.:SYS used.
*  No linking errors.
*  Total program size = 8K.
*  Plovering ....
$LINK FOXI_TST_OUF1_XZ OVER FOXI_TST_XZ (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  Library file :LIB_SYSTEM.:SYS used.
*  No linking errors.
*  Total program size = 8K.
*  Plovering ....
$LINK FOXI_TST_OUF1_Y  OVER FOXI_TST_Y  (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  No linking errors.
*  Total program size = 3K.
$"
.*B* EXECUTE EXECUTION
$DEL *PM_DATA, *PM_DATA_X
  File *PM_DATA does not exist
  File *PM_DATA_X does not exist
$Under PMON
$FOXI_TST_X. FOXI_SI61 OVER *JUNK1
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_X
*PM_DATA -> *PM_DATA_X
$"
$DEL *PM_DATA, *PM_DATA_XZ
  File *PM_DATA does not exist
  File *PM_DATA_XZ does not exist
$Under PMON
$FOXI_TST_XZ. FOXI_SI61 OVER *JUNK1
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_XZ
*PM_DATA -> *PM_DATA_XZ
$"
$DEL *PM_DATA, *PM_DATA_Y
  File *PM_DATA does not exist
  File *PM_DATA_Y does not exist
$Under PMON
$FOXI_TST_Y. FOXI_SI61 OVER *JUNK2
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_Y
*PM_DATA -> *PM_DATA_Y
$"
.*B* FOXI_TST_X
$PMDISP.X FOXI_TST_X,  *PM_DATA_X
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  39.04%, Service time=  60.96%.
 
  Total data points=    1007., Total time used=00:00:26.69.
 
 
LIST OF MODULES
 
  77.95% XSA$FSF
   8.64% FAST$READ
   5.96% FIND$DCB
   5.26% FAST$WRITE
   1.89% FOXI_TST
    .10% XFY_7ATLIST_
    .10% XPM_1TRAP_
    .10% XPM_1EXIT_
    .00% No Module ID
 ------- ---------------------------------------
 100.00% Total
.*B* FOXI_TST_XZ
$PMDISP.X FOXI_TST_XZ, *PM_DATA_XZ
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  42.99%, Service time=  57.01%.
 
  Total data points=    1146., Total time used=00:00:30.40.
 
 
LIST OF MODULES
 
  92.15% XSA$FSF
   3.40% FIND$DCB
           1.31% (  38.46%) [2]  GET_THE_DCB_NUMBER
   2.27% FAST$READ
   1.05% FAST$WRITE
    .70% FOXI_TST
    .17% FAST$OPEN
    .09% XFF_7INITL_
    .09% XPM_1EXIT_
    .09% XPM_1FVP_
    .00% No Module ID
 ------- ---------------------------------------
 100.01% Total
.*B* FOXI_TST_Y
$PMDISP.X FOXI_TST_Y,  *PM_DATA_Y
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  65.49%, Service time=  34.51%.
 
  Total data points=    4362., Total time used=00:01:53.14.
 
 
LIST OF MODULES
 
  24.00% XPM_1READ_SEQ_
  19.07% XPM_1WRITE_SEQ_
  11.78% XFY_7ATLIST_
   9.51% XFG_5DATA_
   8.96% XFG_7IO_SETUP_
   6.19% XFG_7INNAME
   5.14% XFG_7OEDIT_
   4.63% XFG_5FSCAN
   2.06% XPZ_2GETARG_
   1.86% XFY_6FIND_UBLOCK_
   1.33% XFY_5VERIFY_PARAMETERS_
   1.24% XPM_2DCB_UOPT_
    .99% XFG_7IEDIT_
    .69% XFG_5WRSEQ_
    .44% XFG_5RDSEQ_
    .39% XPM_2DCB_ACS_
    .32% XPM_2DCB_ORG_
    .32% XPM_2DCB_ARS_
    .32% FOXI_TST
    .28% XPM_2DCB_ASN_
    .16% XPM_1REW_
    .14% XPM_2DCB_LP_
    .07% XPM_1OPEN_PFILE_
    .05% XPM_1CLOSE_
    .02% XPM_2MONITOR_INFO_
    .02% XPM_1GETDCB_
    .02% XPM_1EXIT_
    .00% No Module ID
 ------- ---------------------------------------
 100.00% Total
$"
!Dont Dribble
DRIBBLE OFF @ 16:21 11/02/87
.*X*
.FIF
.*R*
.*
.*K* EXIT_CONTROL XCON
FSFA creates files behind the monitor's back.  These files are opened
Ctg=No, so if the program aborts or exits without closing a file, the
contents of the file will be lost.  FOXI can protect the user from this
by taking exit control via M$XCON, and closing all the user's files
(if any are left open) whenever the program exits abnormally.  This mode
is established by calling FAST$XCON_SET, and revoked by calling
FAST$XCON_RESET.  (It is only necessary to revoke FOXI's exit control if
you intend to set a StepCC value at exit, e.g. via FORTRAN's CALL EXIT
routine.)
 
Note that this protection applies only to abnormal exits; since all files
are closed as part of a "normal" (e.g. FORTRAN STOP, M$Exit, M$Err) exit,
any files currently being created by FOXI will be destroyed before the
XCon routine can save them.
 
FOXI's exit control routine is well-behaved, in that it saves any
previous exit-control address and restores it after cleaning up its
act.
.*
.*K* FAST$XCON_SET
Call:
 
        CALL  FAST$XCON_SET
 
FAST$XCON_SET invokes protection against accidental loss of files created by
FOXI.  If a program abort occurs after this routine is called, all FOXI files
currently open will be saved; without this protection, any files being created
at the time of the abort would be destroyed.
 
This protection persists until a call to FAST$XCON_RESET.  Normally, it is not
necessary to call FAST$XCON_RESET; however, if you wish to set the Step
Condition Code (StepCC), e.g. via FORTRAN's  CALL EXIT  routine, you must first
disable FOXI's exit control.
 
.*
.*K* FAST$XCON_RESET
Call:
 
       CALL  FAST$XCON_RESET
 
FAST$XCON_RESET turns off FOXI's protection against accidental loss of newly
created files.  This is necessary in order to set the StepCC at exit (e.g.
via FORTRAN's  CALL EXIT  procedure.)
.*
.*X*
.*K* DISCLAIMER
/********************************************************************
*                                                                   *
* This program  is a gratuitous contribution and  is offered as is. *
* Zenith  makes  no  representations  or  warranties  of  any kind, *
* express  or  implied,  relating  to  freedom  from  infringement, *
* accuracy,  error-freedom  or   performance,  and  shall  have  no *
* liability  or responsibility  to users  for damages  of any kind, *
* including special, indirect or consequential damages, arising out *
* of  or resulting  from use,  modification or  reproduction of the *
* program.                                                          *
*                                                                   *
* No  warranty  is  made  by  the  contributor  as to the accuracy, *
* maintenance, and functioning of the program and related material. *
* No  responsibility is  assumed by  the contributor  in connection *
* therewith.                                                        *
*                                                                   *
********************************************************************/
