    " BlOCK T
[1]   $DLT$DLT_$DLT$DLT,T
[2]   $GO(bs>$R$DLT$DLT)/0
[3]   DuMP <> $GO2
    "
    " DeF;$DLT$UDLS;$DLT$UDLK;$DLT$UDLM;$DLT$UDLA;RaNK;$DLT$UDLR
[1]   $GO(0/=$QNC '$DLT$DLT')/Go <> $DLT$DLT_,$Q8
[2]  Go:(0 2$R 0)$QSM 'DeF' <> $DLT$UDLR_'***'
[3]   $GO((bs<_$R$DLT$DLT)$OR0=$R$DLT$UDLR)/Go+2 <> $DLT$DLT_$DLT$DLT,$DLT$UDLR_,$Q8 <> $GOGo+1
[4]  $COM GET CRV SIZE
[5]   $DLT$UDLS_(&\$DLT$DLT$ENuM)/$DLT$DLT <> $DLT$DLT_($R$DLT$UDLS)$DRP$DLT$DLT
[6]  $DLT$UDLQ:$GO(($R$DLT$DLT)>$XEC$DLT$UDLS)/$DLT$UDLQ+1 <> $DLT$DLT_$DLT$DLT,$Q8 <> $GO$DLT$UDLQ
[7]   $DLT$UDLS_($XEC$DLT$UDLS)$TAK$DLT$DLT <> $DLT$DLT_($R$DLT$UDLS)$DRP$DLT$DLT
[8]  $COM GET CLASS, NAME
[9]   $DLT$UDLK_1$TAK$DLT$UDLS <> $DLT$UDLM_1$DRP((~$QIO)+$DLT$UDLS$I' ')$TAK$DLT$UDLS <> $DLT$UDLS_(1+$R$DLT$UDLM)$DRP$DLT$UDLS
[10] $COM GET RANK
[11]  $DLT$UDLS_LoP $DLT$UDLS
[12]  RaNK_(&\$DLT$UDLS$ENuM)/$DLT$UDLS <> $DLT$UDLS_($RRaNK)$DRP$DLT$UDLS
[13] $COM GET SIZE VECTOR
[14]  $DLT$UDLS_LoP $DLT$UDLS
[15]  $DLT$UDLA_'' <> $GO(0=$XECRaNK)/$DLT$UDLV
[16]  $DLT$UDLA_$DLT$UDLS/=' '
[17]  $DLT$UDLA_$DLT$UDLA>-1$DRP1$REV$DLT$UDLA,1
[18]  $DLT$UDLA_((~$QIO)+(+\$DLT$UDLA)$I$XECRaNK)$TAK$DLT$UDLS
[19]  $DLT$UDLS_(1+$R$DLT$UDLA)$DRP$DLT$UDLS <> $DLT$UDLA_$XEC$DLT$UDLA
[20] $COM AND DO CASE( CLASS)...
[21]  (1 2$R No,0)$QSM 'DeF'
[22] $DLT$UDLV:$GO$XEC'$DLT$UDL',('CFNPX'=$DLT$UDLK)/'CFNPX'
[23] $DLT$UDL:'UNKNOWN CLASS: ',$DLT$UDLK <> $GOGo
[24] $DLT$UDLC:$XEC$DLT$UDLM,'_2$TBR($-$QIO)+$QAV$I$DLT$UDLA$R$DLT$UDLS' <> 'CHARACTER VARIABLE: ',$DLT$UDLM <> $GOGo
[25] $DLT$UDLF:$GO(0=$R$R$DLT$UDLA)/$DLT$UDLI <> $GO(2/=$TBR$QFX $DLT$UDLA$R$DLT$UDLS)/No <> 'FUNCTION: ',$DLT$UDLM <> $GOGo
[26] $DLT$UDLN:$XEC$DLT$UDLM,'_$DLT$UDLA$RExEC $DLT$UDLS' <> 'NUMERIC VARIABLE: ',$DLT$UDLM <> $GOGo
[27] $DLT$UDLP:'PSEUDO VARIABLE: ',$DLT$UDLM <> $GO('END'&.=3$TAK$DLT$UDLM)/0 <> $GOGo
[28] $DLT$UDLX:'NONSTANDARD: ',$DLT$UDLM <> $GOGo
[29] $DLT$UDLI:$XEC$DLT$UDLS <> 'INTRINSIC FUNCTION: ',$DLT$UDLM <> $GOGo
[30] No:'UNABLE TO DEFINE ',$DLT$UDLM <> $GOGo
    "
    " DuMP
[1]   $Q8_bs$TAK$DLT$DLT <> $DLT$DLT_bs$DRP$DLT$DLT
    "
    " $DLTR_EnD
[1]   $DLTR_9$TAK'8PEND 0 0'
    "
    " Z_ExEC R;K;S
[1]   $GO(180<$RR_,R)/2 <> Z_$XECR <> $GO0
[2]   Z_$I0 <> $GO(&/R$E' -.E0123456789')$TAK3 <> 'ILLEGAL ARG TO ExEC' <> $GO0
[3]  LOOP:S_$REV180$TAKR <> R_($REV(K_(~$QIO)+S$I' ')$TAKS),180$DRPR <> S_$REVK$DRPS
[4]   Z_Z,$XECS <> $GO(R$OR./=' ')/LOOP
    "
    " $DLTR_FrEP $DLTA;cr;wm
[1]  $COM $DLTA IS THE NAME OF THE FUNCTION.
[2]  $COM RETURN W/EMPTY VECTOR IF UNDEFINED.
[3]   $DLTR_$I0 <> $GO(0=$QNC $DLTA_($DLTA/=' ')/$DLTA)/0
[4]  $COM JUST FOR CP$-6, CHECK FOR INTRINSIC FUNCTION.
[5]   wm_14$TBR6 <> $GO((7 wm $DLTA)$E14 15 16)/$DLTC
[6]  $COM GET CANONICAL REPRESENTATION.
[7]   $DLTR_$QCR $DLTA
[8]  $COM APPEND DATA TYPE, RANK, AND SHAPE VECTOR.
[9]  $DLTG:$DLTR_'F',$DLTA,' ',($FMT($R$R$DLTR),$R$DLTR),' ',,$DLTR
[10] $COM APPEND VECTOR LENGTH.
[11]  $DLTR_($FMT$R$DLTR),$DLTR <> $GO0
[12] $COM JUST FOR CP$-6, HANDLE INTRINSIC FUNCTIONS.
[13] $DLTC:cr_14$TBR5 <> $DLTR_4 cr $DLTA <> $GO$DLTG
    "
    " $DLTR_$DLTA LeSS $DLTB
[1]  $COM RETURN CHARACTER MATRIX DIFFERENCE OF $DLTA AND $DLTB
[2]   $GO(=/$DLTR_(1$DRP$R$DLTA),1$DRP$R$DLTB)/2+1$TAK$QLC
[3]   $DLTR_$MAX/$DLTR <> $DLTA_($REV$DLTR,1$TAK$R$DLTA)$TAK$DLTA <> $DLTB_($REV$DLTR,1$TAK$R$DLTB)$TAK$DLTB
[4]   $DLTR_(&/-$DLTB$OR./=$TPS$DLTA)/-$DLTA
    "
    " $DLTR_LoP $DLTA
[1]   $DLTR_($OR\$DLTA/=' ')/$DLTA
    "
    " $DLTR_$DLTV QrEP $DLTA
[1]  $COM $DLTV IS THE SYSTEM VARIABLE SETTING.
[2]  $COM $DLTA IS THE NAME OF THE SYSTEM VARIABLE.
[3]  $COM CATENATE NAME, RANK, SHAPE VECTOR, AND EXTERNAL VALUE.
[4]   $DLTR_$DLTA,' ',($FMT($R$R$DLTV),$R$DLTV),' ',$FMT,$DLTV
[5]  $COM APPEND DATA TYPE.
[6]   $DLTR_'NC'[$QIO+' '=1$TAK0$R$DLTV],$DLTR
[7]  $COM APPEND VECTOR LENGTH.
[8]   $DLTR_($FMT$R$DLTR),$DLTR
    "
    " RECEIVE;$DLT$DLT;bs
[1]   bs_72 <> $DLT$DLT_$I0 <> $QQ_'FILE?'
[2]   $XEC')SET $Q8 ',$QQ,',FUN=IN'
[3]   DeF
    "
    " SEND;$DLTA;$DLTR;$DLT$DLT;bs
[1]   $QQ_'FILE?' <> $XEC')SET $Q8 ',$QQ,',FUN=CREATE'
[2]   bs_72 <> $DLT$DLT_$I0 <> BlOCK WsIS <> BlOCK WsID
[3]   $DLTR_($QNL 3)LeSS($QGRP 'SENDWS')WiTH $QGRP 'RECEIVEWS' <> $DLTA_0
[4]  $DLTV:$GO((1$TAK$R$DLTR)<$DLTA_$DLTA+1)/$DLTV+1 <> BlOCK FrEP $Q_,$DLTR[$DLTA$-~$QIO;] <> $GO$DLTV
[5]   $DLTR_($QNL 2)LeSS(7 2$R'$DLTV$DLTT$DLTQ$DLTA$DLTR$DLT$DLTbs')WiTH 1 3$R'NuM' <> $DLTA_0
[6]  $DLTT:$GO((1$TAK$R$DLTR)<$DLTA_$DLTA+1)/$DLTT+1 <> BlOCK VrEP $Q_,$DLTR[$DLTA$-~$QIO;] <> $GO$DLTT
[7]   $DLTR_6 3$R'$QIO$QPP$QPW$QCT$QRL$QLX' <> $DLTA_0
[8]  $DLTQ:$GO((1$TAK$R$DLTR)<$DLTA_$DLTA+1)/$DLTQ+1 <> BlOCK($XEC$DLTR[$DLTA$-~$QIO;])QrEP $Q_,$DLTR[$DLTA$-~$QIO;] <> $GO$DLTQ
[9]   BlOCK EnD <> DuMP
[10]  $XEC')SET $Q8 ME'
    "
    " $DLTR_VrEP $DLTZ;wm;$DLTS;$QPP
[1]  $COM $DLTZ IS THE NAME OF THE VARIABLE.
[2]  $COM RETURN W/EMPTY VECTOR IF UNDEFINED.
[3]   $DLTR_$I0 <> $GO(0=$QNC $DLTZ_($DLTZ/=' ')/$DLTZ)/0
[4]  $COM JUST FOR CP$-6, SPECIAL$-CASE LISTS.
[5]   wm_14$TBR6 <> $GO(6=7 wm $DLTZ)/$DLTL
[6]  $COM GET INTERNAL VALUE.
[7]   $QPP_18 <> $DLTS_$DLTR_$XEC$DLTZ
[8]  $COM CATENATE NAME, RANK, SHAPE VECTOR, AND VALUE.
[9]  $DLTG:$DLTR_$DLTZ,' ',($FMT($R$R$DLTR),$R$DLTR),' ',$FMT,$DLTR
[10] $COM APPEND DATA TYPE.
[11]  $DLTR_'NC'[$QIO+' '=1$TAK0$R$DLTS],$DLTR
[12] $COM APPEND VECTOR LENGTH.
[13]  $DLTR_($FMT$R$DLTR),$DLTR <> $GO0
[14] $COM JUST FOR CP$-6, HANDLE LISTS.
[15] $DLTL:$DLTS_$DLTR_'**LIST ERR**' <> $GO$DLTG
    "
    " Z_A WiTH B
[1]   Z_$MAX/(-1$TAK$RA),-1$TAK$RB
[2]   Z_(($REVZ,1$TAK$RA)$TAKA),[$QIO]($REVZ,1$TAK$RB)$TAKB
    "
    " $DLTR_WsID
[1]  $COM JUST FOR CP$-6, WSID LOOKS FUNNY.
[2]   $DLTR_5$DRP$XEC')WSID'
[3]   $DLTR_'PWSID 1 ',($FMT$R$DLTR),' ',$DLTR
[4]   $DLTR_($FMT$R$DLTR),$DLTR
    "
    " $DLTR_WsIS
[1]   $DLTR_10$TAK'9PWSIS 0 0'
    "
NuM_'0123456789'
)GROUP RECEIVEWS RECEIVE DeF NuM LoP ExEC
)GROUP SENDWS BlOCK DuMP EnD FrEP QrEP SEND VrEP WsID WsIS LeSS WiTH
)SET INPUT ME
