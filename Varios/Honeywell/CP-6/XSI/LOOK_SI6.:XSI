/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
LOOK: PROC MAIN;
 
%PLIST;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C; /* For E$? EQUs              */
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;  /* For F$DCB.ORG# references */
 
%FPT_READ   (FPTN=READ_M$UI,
             DCB=M$UI,
             BUF=UI_BUF);
%FPT_OPEN   (FPTN=OPN_LO,
             DCB=M$LO,REASSIGN=YES);
%FPT_WRITE  (FPTN=WRITE_LO,
             DCB=M$LO,
             BUF=LO_BUF);
%FPT_CLOSE  (FPTN=CLOS_LO,
             DCB=M$LO,
             DISP=SAVE);
%FPT_DEVICE (FPTN=WRITE_LO_PAGE,
             DCB=M$LO,
             PAGE=YES);
%FPT_OPEN   (FPTN=OPN_LO_LP,
             ASN=DEVICE,
             DCB=M$LO,
             RES='LP  ');
%FPT_OPEN   (FPTN=OPN_LO_ME,
             ASN=DEVICE,
             DCB=M$LO,
             RES='ME  ');
%FPT_OPEN   (FPTN=OPN_LO_NO,
             ASN=DEVICE,
             DCB=M$LO,
             RES='NO  ');
%FPT_WRITE  (FPTN=WRITE_DO,
             DCB=M$DO,
             BUF=LO_BUF);
%FPT_OPEN   (FPTN=OPN_SI,
             DCB=M$SI,
             FUN=IN);
%FPT_READ   (FPTN=REED_SI,
             DCB=M$SI,
             KEY=KEY,
             KEYR=YES);
%FPT_CLOSE  (FPTN=CLOS_SI,
             DCB=M$SI,
             DISP=SAVE);
%FPT_CORRES (FPTN=LOVSDO,
             DCB1=M$LO,
             DCB2=M$DO);
%FPT_CORRES (FPTN=UIVSLO,
             DCB1=M$UI,
             DCB2=M$LO);
%FPT_PROMPT (FPTN=SET_PROMPT,
             PROMPT=PROMPT_CHAR);
%FPT_PLATEN (FPTN=SET_PLATEN,
             PLATEN=PLATEN_VLP);
%VLP_PLATEN (FPTN=PLATEN_VLP);
%FPT_GDS    (FPTN=GDS,
             SEGSIZE=1024,
             RESULTS=GDS_RESULTS);
%VLP_VECTOR (FPTN=GDS_RESULTS);
%FPT_PFIL   (FPTN=PFIL,
             DCB=M$SI,
             BOF=YES);
%FPT_PRECORD(FPTN=PRECORD,
             DCB=M$SI);
%FPT_ERRMSG (FPTN=ERRMSG,
             DCB=M$SI,
             BUF=ERR_MESG,
             CODE=ERR_CODE,
             OUTDCB1=M$DO);
%FPT_INT    (FPTN=BREAK_CNTL,
             UENTRY=BREAK);
%FPT_UNFID  (FPTN=UNFID_FPT,
             DCB=M$SI,
             TEXTFID=SI_FID);
%EJECT;
%SUB NO="'0'B";
%SUB YES="'1'B";
 
DCL BREAK                    ENTRY     ASYNC;
 
DCL M$DO                     DCB;
DCL M$LO                     DCB;
DCL M$SI                     DCB;
DCL M$UI                     DCB;
 
DCL B$JIT$  SYMREF           PTR;
DCL B$TCB$  SYMREF           PTR;
DCL SIBUF$                   PTR;
DCL M$DO$                    PTR;
DCL M$LO$                    PTR;
DCL M$SI$                    PTR;
DCL M$UI$                    PTR;
DCL FROM$                    PTR;
DCL TO$                      PTR;
DCL KEY$                     PTR;
 
DCL MESG0                    UBIN      CONSTANT INIT(0);
DCL MESG1                    UBIN      CONSTANT INIT(1);
DCL MESG2                    UBIN      CONSTANT INIT(2);
DCL MESG3                    UBIN      CONSTANT INIT(3);
DCL MESG4                    UBIN      CONSTANT INIT(4);
DCL MESG5                    UBIN      CONSTANT INIT(5);
DCL MESG6                    UBIN      CONSTANT INIT(6);
DCL MESG7                    UBIN      CONSTANT INIT(7);
DCL MESG8                    UBIN      CONSTANT INIT(8);
DCL MESG9                    UBIN      CONSTANT INIT(9);
DCL MESG10                   UBIN      CONSTANT INIT(10);
DCL MESG11                   UBIN      CONSTANT INIT(11);
DCL MESG12                   UBIN      CONSTANT INIT(12);
DCL MESG13                   UBIN      CONSTANT INIT(13);
DCL MESG14                   UBIN      CONSTANT INIT(14);
DCL MESG15                   UBIN      CONSTANT INIT(15);
DCL MESG16                   UBIN      CONSTANT INIT(16);
DCL MESG17                   UBIN      CONSTANT INIT(17);
DCL MESG18                   UBIN      CONSTANT INIT(18);
DCL MESG19                   UBIN      CONSTANT INIT(19);
DCL MESG20                   UBIN      CONSTANT INIT(20);
DCL MESG21                   UBIN      CONSTANT INIT(21);
DCL MESG22                   UBIN      CONSTANT INIT(22);
DCL MESG23                   UBIN      CONSTANT INIT(23);
 
DCL ERR_CODE                 BIT(36)   STATIC;
DCL NUMERIC                  BIT(1);
DCL UI_ERR                   BIT(1);
DCL LONEDO                   BIT(1)    STATIC   INIT('0'B);
DCL UINELO                   BIT(1)    STATIC   INIT('0'B);
DCL PARSE_ERR                BIT(1);
DCL DONE_PARSING             BIT(1);
DCL DELIM                    BIT(1);
DCL STRING_STARTED           BIT(1);
DCL GOT_REC_NUMS             BIT(1);
DCL BPON                     BIT(1)    STATIC   INIT('1'B);
DCL SAV_BPON                 BIT(1);
DCL OCTAL                    BIT(1)    STATIC   INIT('1'B);
DCL TEXT                     BIT(1)    STATIC   INIT('1'B);
DCL BROKEN                   BIT(1)    STATIC SYMDEF INIT('0'B);
DCL SEARCHING                BIT(1)    STATIC   INIT('0'B);
%EJECT;
DCL UI_OPTIONS               UBIN;
DCL UI_OPTION(0:35) REDEF UI_OPTIONS  BIT(1) UNAL;
DCL UI_OPT_BITS REDEF UI_OPTIONS  BIT(36);
DCL 1 ITS_A REDEF UI_OPTIONS,
      2 F_OPTION             BIT(1) UNAL,  /*  0 */
      2 S_OPTION             BIT(1) UNAL,  /*  1 */
      2 D_OPTION             BIT(1) UNAL,  /*  2 */
      2 N_OPTION             BIT(1) UNAL,  /*  3 */
      2 B_OPTION             BIT(1) UNAL,  /*  4 */
      2 E_OPTION             BIT(1) UNAL,  /*  5 */
      2 K_OPTION             BIT(1) UNAL,  /*  6 */
      2 I_OPTION             BIT(1) UNAL,  /*  7 */
      2 O_OPTION             BIT(1) UNAL,  /*  8 */
      2 X_OPTION             BIT(1) UNAL,  /*  9 */
      2 *                    BIT(26) UNAL;
DCL SAV_UI_OPTIONS           BIT(36);
DCL SI_ARS                   UBIN;
DCL UI_ARS                   UBIN;
DCL NUM_UI_OPTIONS           UBIN;
DCL NUM_SEARCHED             UBIN      STATIC   INIT(0);
DCL NUM_MATCHES              UBIN      STATIC   INIT(0);
DCL STRING_END               UBIN      STATIC   INIT(0);
DCL INDX                     UBIN;
DCL ZONED_INDX               UBIN;
DCL ZONED_LEN                UBIN;
DCL OPT_NUM                  UBIN;
DCL NUM_OPTIONS              UBIN      STATIC   INIT(10);
DCL FIRST_REC                UBIN;
DCL LAST_REC                 UBIN;
DCL SRCH_BEG_COL             UBIN;
DCL SRCH_END_COL             UBIN;
DCL DISP_BEG_COL             UBIN;
DCL DISP_END_COL             UBIN;
DCL I                        UBIN;
DCL WIDTH                    UBIN;
DCL SAV_WIDTH                UBIN;
DCL LO_INDX                  UBIN;
DCL NUM                      UBIN;
DCL KEYL                     UBIN;
DCL BEG                      UBIN;
DCL MAX_LEN                  UBIN;
DCL TMP_LEN                  UBIN;
DCL LBL_LEN                  UBIN;
DCL TEXT_LEN                 UBIN;
DCL TMP_END_COL              SBIN;
DCL MAX_WRDS                 UBIN;
DCL MAX_LO_INDX              UBIN;
DCL START                    UBIN;
DCL LEN                      UBIN;
DCL SAV_POS                  UBIN;
 
DCL REC_NUM                  SBIN;
DCL THE_NUM                  SBIN;
DCL TMP_NUM_LEN              SBIN;
DCL STRING_LEN               SBIN      STATIC   INIT(-1);
 
DCL PROMPT_CHAR              CHAR(1)   STATIC   INIT('>');
DCL BYT                      CHAR(1)   STATIC;
DCL LO_BUF                   CHAR(132) STATIC;
DCL LO_BYTE(0:131) REDEF LO_BUF  CHAR(1);
DCL LO_FILLER                CHAR(132) STATIC;
DCL UI_BUF                   CHAR(80)  STATIC;
DCL UI_BYTE(0:79) REDEF UI_BUF  CHAR(1);
DCL OPTIONS                  CHAR(10)  STATIC   INIT('FSDNBEKIOX');
DCL OPTION(0:9) REDEF OPTIONS CHAR(1);
DCL TMP_NUM                  CHAR(10);
DCL TMP_DIGIT(0:9) REDEF TMP_NUM  CHAR(1);
DCL STRINGS                  CHAR(80);
DCL STRING(0:79) REDEF STRINGS  CHAR(1);
DCL 1 KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 EDIT                 UBIN(27)  UNAL,
      2 *                    CHAR(252) UNAL;
DCL ZONED                    CHAR(10);
DCL ZONED_BYTE(0:9) REDEF ZONED  CHAR(1);
DCL ERR_MESG                 CHAR(360) STATIC;
DCL SI_FID                   CHAR(120) STATIC;
DCL STRING_DEL               CHAR(1)   STATIC;
DCL UBIN36                   UBIN(36)  STATIC ALIGNED;
DCL 1 U REDEF UBIN36,
      2 *                    UBIN(27)  UNAL,
      2 BIN9                 UBIN(9)   UNAL,
      2 CHAR1 REDEF BIN9     CHAR(1)   UNAL;
DCL BYTS(0:0) BASED          CHAR(1);
DCL STRNG BASED              CHAR(TMP_LEN);
DCL LOBUF BASED              CHAR(133);
DCL NUM_CMNDS                UBIN(9)   STATIC   INIT(17);
DCL CMND(0:16)               CHAR(8)   STATIC   INIT(
  /*  0 */  'BP OFF  ',
  /*  1 */  'BP ON   ',
  /*  2 */  'BPOFF   ',
  /*  3 */  'BPON    ',
  /*  4 */  'LONG    ',
  /*  5 */  'LP      ',
  /*  6 */  'ME      ',
  /*  7 */  'NO OCTAL',
  /*  8 */  'NO TEXT ',
  /*  9 */  'NOOCTAL ',
  /* 10 */  'NOTEXT  ',
  /* 11 */  'NO      ',
  /* 12 */  'OCTAL   ',
  /* 13 */  'PAGE    ',
  /* 14 */  'SHORT   ',
  /* 15 */  'TEXT    ',
  /* 16 */  'WIDTH   ');
DCL 1 XLATE_TABX  STATIC,
      2 A(0:11)              CHAR(40)  UNAL     INIT(
/* DECIMAL   OCTAL   */
/*   0- 39 .000-.047 */ '................................ !"#$%&''',
/*  40- 79 .050-.117 */ '()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO',
/*  80-119 .120-.167 */ 'PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw',
/* 120-159 .170-.237 */ 'xyz{|}~.................................',
/* 160-199 .240-.307 */ '........................................',
/* 200-239 .310-.357 */ '........................................',
/* 240-279 .360-.427 */ '........................................',
/* 280-319 .430-.477 */ '........................................',
/* 320-359 .480-.547 */ '........................................',
/* 360-399 .550-.617 */ '........................................',
/* 400-439 .620-.667 */ '........................................',
/* 440-479 .670-.737 */ '........................................'),
      2 *                    CHAR(32)  UNAL     INIT(
/* 480-511 .740-.777 */ '................................');
DCL XLATE_TAB(0:511) REDEF XLATE_TABX  BIT(9)  UNAL;
%EJECT;
DCL MESG(0:23)               CHAR(80)  STATIC   INIT(
    'Invalid option or delimiter',                            /*  0 */
    'F or S must be only option specified',                   /*  1 */
    'Number too big; Maximum of 10 digits',                   /*  2 */
    'Invalid delimiter',                                      /*  3 */
    'I''m no mind reader!; What should I look for?',          /*  4 */
    'Expected a/ or '' here',                                 /*  5 */
    'No final / or ''',                                       /*  6 */
    'Comma only goes here on F or S option',                  /*  7 */
    'Expected a , here',                                      /*  8 */
    'Expected a , or . here',                                 /*  9 */
    'For byte selection, a : goes here',                      /* 10 */
    'Option not legal here',                                  /* 11 */
    'Expected a - or a digit',                                /* 12 */
    'Expected end of line/record here',                       /* 13 */
    'Expected a - here',                                      /* 14 */
    'Ending record > First record',                           /* 15 */
    'Ending column > First column',                           /* 16 */
    'String won''t fit between specified columns',            /* 17 */
    'Invalid Octal digit',                                    /* 18 */
    'Invalid Hex digit',                                      /* 19 */
    'Please give 3 digits per byte',                          /* 20 */
    'Invalid decimal digit',                                  /* 21 */
    'Think you forgot something here!',                       /* 22 */
    'Width must be >= 27 and <= 132');                        /* 23 */
 
DCL MESG_LEN(0:23)           UBIN      STATIC   INIT(
    27,  /*  0 */
    36,  /*  1 */
    36,  /*  2 */
    17,  /*  3 */
    44,  /*  4 */
    22,  /*  5 */
    15,  /*  6 */
    37,  /*  7 */
    17,  /*  8 */
    22,  /*  9 */
    33,  /* 10 */
    21,  /* 11 */
    23,  /* 12 */
    32,  /* 13 */
    17,  /* 14 */
    28,  /* 15 */
    28,  /* 16 */
    42,  /* 17 */
    19,  /* 18 */
    17,  /* 19 */
    29,  /* 20 */
    21,  /* 21 */
    32,  /* 22 */
    30); /* 23 */
%EJECT;
    M$DO$= DCBADDR(DCBNUM(M$DO));
    M$LO$= DCBADDR(DCBNUM(M$LO));
    M$SI$= DCBADDR(DCBNUM(M$SI));
    M$UI$= DCBADDR(DCBNUM(M$UI));
    CALL M$PROMPT(SET_PROMPT);
    CALL M$CORRES(UIVSLO)  ALTRET(CHK_M$DO);
    UINELO= YES;
CHK_M$DO:
    CALL M$CORRES(LOVSDO)  ALTRET(CHK_PLATEN);
    LONEDO= YES;
CHK_PLATEN:
    CALL M$OPEN(OPN_LO);
    SAV_WIDTH= M$LO$->F$DCB.WIDTH#;
    IF SAV_WIDTH < 27 THEN
         IF SAV_WIDTH = 0 THEN
              WIDTH= 129;
         ELSE DO;
               PLATEN_VLP.WIDTH#= 27;
               CALL M$PLATEN(SET_PLATEN);
               LO_BUF= '* Sorry!  I need platen';
               CALL M$WRITE(WRITE_DO);
               LO_BUF= 'width of at least 27.';
               CALL M$WRITE(WRITE_DO);
               LO_BUF= 'I''m using 27.';
               CALL M$WRITE(WRITE_DO);
               WIDTH= 27;
              END;
    ELSE IF SAV_WIDTH = 80 THEN  DO;
              PLATEN_VLP.WIDTH#= 79;
              CALL M$PLATEN(SET_PLATEN);
              WIDTH= 79;
              END;
         ELSE WIDTH= SAV_WIDTH;
OPEN_SI:
    IF NOT M$SI$->F$DCB.AMR# THEN  DO;
      LO_BUF= '* Hey!  I''m no mind reader!; Please specify FID! *';
      CALL M$WRITE(WRITE_DO);
      GOTO EOJ;
      END;
    IF M$SI$->F$DCB.ASN# = 3 THEN  DO;
      LO_BUF= '* M$SI can''t be SET to a DEVICE *';
      CALL M$WRITE(WRITE_DO);
      GOTO EOJ;
      END;
    CALL M$OPEN(OPN_SI)  ALTRET(OPEN_SI_ERR);
    IF M$SI$->F$DCB.ORG# > %IDS# THEN  DO;
      LO_BUF= '* M$SI has invalid ORG; must be ';
      CALL M$WRITE(WRITE_DO);
      LO_BUF= '* CONSEC,KEYED,RANDOM,UR,RELATIVE,INDEXED or IDS *';
      CALL M$WRITE(WRITE_DO);
      GOTO EOJ;
      END;
    CALL M$UNFID(UNFID_FPT);
    IF M$SI$->F$DCB.ORG# = %RANDOM#  OR
       M$SI$->F$DCB.ORG# = %IDS# THEN
         REED_SI.V.FULL#= YES;
    GDS_RESULTS= REED_SI.BUF_;
    CALL M$GDS(GDS)  ALTRET(NO_ROOM);
    REED_SI.BUF_= GDS_RESULTS;
    SIBUF$= GDS_RESULTS.PTR$;
    IF M$SI$->F$DCB.ORG# ~= %KEYED# THEN
      IF M$SI$->F$DCB.ORG# = %INDEXED# THEN DO;
           LO_BUF= '* File not KEYED - E option unavailable *';
           CALL M$WRITE(WRITE_LO);
           OPTION(5)= BINASC(511);
           END;
      ELSE DO;
             LO_BUF= '* File not KEYED or INDEXED - E/K options unavailable *';
             CALL M$WRITE(WRITE_LO);
             OPTION(1)= BINASC(511);  /* S */
             OPTION(5)= BINASC(511);  /* E */
             OPTION(6)= BINASC(511);  /* K */
           END;
    CALL M$INT(BREAK_CNTL);
GET_CMND:
    BROKEN= NO;
    SEARCHING= NO;
    NUM_SEARCHED= 0;
    NUM_MATCHES= 0;
    CALL READUI         ALTRET(EOJ);
    CALL ISIT_DIRECTIVE ALTRET(GET_CMND);
    CALL GET_OPTIONS    ALTRET(GET_CMND);
    CALL GET_REC_NUMS   ALTRET(GET_CMND);
    IF NOT DONE_PARSING THEN
         IF ITS_A.F_OPTION OR
            ITS_A.S_OPTION  THEN
              CALL PARSE_STRING  ALTRET(GET_CMND);
         ELSE IF BYT ~= ':' THEN
                   /* For byte selection, a : goes here */
                   CALL POINT_TO_ERR(MESG10,INDX)  ALTRET(GET_CMND);
              ELSE;
    ELSE IF ITS_A.F_OPTION OR
            ITS_A.S_OPTION THEN
              /* I'm no mind reader!; What should I look for? */
              CALL POINT_TO_ERR(MESG4,UI_ARS)  ALTRET(GET_CMND);
    INDX= INDX+1;
    IF BYT = ',' THEN
         CALL GET_COLUMNS(SRCH_BEG_COL,SRCH_END_COL)  ALTRET(GET_CMND);
    ELSE IF BYT = ':' THEN
              CALL GET_COLUMNS(DISP_BEG_COL,DISP_END_COL)
                                                      ALTRET(GET_CMND);
         ELSE I= INDX;
    IF NOT DONE_PARSING THEN DO;
         CALL GET_OPTIONS  ALTRET(GET_CMND);
         CALL GET_COLUMNS(DISP_BEG_COL,DISP_END_COL)  ALTRET(GET_CMND);
         END;
    IF STRING_LEN > SRCH_END_COL - SRCH_BEG_COL THEN
      /* String won''t fit between specified columns */
      CALL POINT_TO_ERR(MESG17,STRING_END)  ALTRET(GET_CMND);
%EJECT;
POSITION_SI:
    IF ITS_A.N_OPTION THEN
         CALL PUT_NUM_RECORDS  ALTRET(GET_CMND);
    CALL M$PFIL(PFIL)  ALTRET(EOJ);
    REC_NUM= FIRST_REC-1;
    IF FIRST_REC > 1 THEN DO;
      PRECORD.V.N#= REC_NUM;
      CALL M$PRECORD(PRECORD)  ALTRET(EARLY_EOF);
      END;
    SEARCHING= YES;
READ_SI:
    SI_ARS= 0;
    CALL M$READ(REED_SI)  ALTRET(SI_ERR);
    DO WHILE('0'B);
SI_ERR:
      IF M$SI$->F$DCB.TYC.EOF# THEN GOTO EOF;
      IF NOT M$SI$->F$DCB.TYC.LD# THEN GOTO NO_ROOM;
      SI_ARS= SI_ARS + M$SI$->F$DCB.ARS#;
      CALL M$GDS(GDS)  ALTRET(NO_ROOM);
      SIBUF$= PINCRW(SIBUF$,256);
      REED_SI.BUF_.BOUND= 4095;
      REED_SI.BUF_.BUF$=  SIBUF$;
      REED_SI.V.DVBYTE.CONT#= YES;
      CALL M$READ(REED_SI)  ALTRET(SI_ERR);
      REED_SI.BUF_= GDS_RESULTS;
      REED_SI.V.DVBYTE.CONT#= NO;
      END;
    REC_NUM= REC_NUM+1;
    IF REC_NUM > LAST_REC THEN GOTO EOF;
    SI_ARS= SI_ARS+M$SI$->F$DCB.ARS#;
    IF ITS_A.F_OPTION THEN
         CALL DO_F_SEARCH  ALTRET(WAS_BREAK_HIT);
    ELSE IF ITS_A.S_OPTION THEN
              CALL DO_S_SEARCH  ALTRET(WAS_BREAK_HIT);
DO_SPECIFIED_OPTION:
    IF ITS_A.O_OPTION  OR
       ITS_A.I_OPTION  THEN
         CALL PUT_BLANK_LINE(0);
    LO_INDX= 0;
    CALL BIN2CHAR(REC_NUM);
    CALL PUT_NUM;
    IF ITS_A.E_OPTION THEN
         CALL PUT_EDIT_KEY;
    IF ITS_A.B_OPTION THEN
         CALL PUT_BYTE_COUNT;
    IF  ITS_A.K_OPTION THEN
         CALL PUT_KEY;
    IF ITS_A.D_OPTION THEN
         CALL PUT_TEXT  ALTRET( GET_CMND );
    IF ITS_A.O_OPTION OR
       ITS_A.I_OPTION THEN
         CALL PUT_OCTAL ALTRET(GET_CMND);
    CALL PRINT_LO(7);
WAS_BREAK_HIT:
    IF BROKEN THEN
         CALL HANDLE_BREAK  ALTRET(GET_CMND);
    GOTO READ_SI;
EARLY_EOF:
    REC_NUM= M$SI$->F$DCB.ARS#;
EOF:
    IF REC_NUM < LAST_REC THEN
      CALL PUT_EOF_MESG;
    IF ITS_A.F_OPTION  OR
       ITS_A.S_OPTION THEN  DO;
         LO_INDX= 0;
         CALL SEARCH_SUMMARY;
         END;
    GOTO GET_CMND;
EOJ:
    IF M$LO$->F$DCB.WIDTH# ~= SAV_WIDTH  AND
       SAV_WIDTH > 0  THEN  DO;
      PLATEN_VLP.WIDTH#= SAV_WIDTH;
      CALL M$PLATEN(SET_PLATEN);
      END;
    CALL M$EXIT;
NO_ROOM: ;
OPEN_SI_ERR:
    ERR_CODE= B$TCB$->B$TCB.ALT$->B$ALT.ERR;
    CALL M$ERRMSG(ERRMSG);
    CALL M$ERR;
%EJECT;
READUI: PROC  ALTRET;
REEDUI:
    UI_ERR= NO;
    DONE_PARSING= NO;
    GOT_REC_NUMS= NO;
    SAV_UI_OPTIONS= '0'B;
    FIRST_REC= 1;
    LAST_REC=  9999999;
    SRCH_BEG_COL= 0;
    SRCH_END_COL= 99999;
    DISP_BEG_COL= 0;
    DISP_END_COL= 99999;
READ_AGAIN:
    UI_BUF= ' ';
    CALL M$READ(READ_M$UI)  ALTRET(READUI_ERR);
    UI_ARS= M$UI$->F$DCB.ARS#;
    IF UINELO THEN DO;
        LO_BUF= PROMPT_CHAR;
        CALL INSERT(LO_BUF,1,UI_ARS,UI_BUF);
        WRITE_LO.BUF_.BOUND= UI_ARS;
        CALL M$WRITE(WRITE_LO);
        WRITE_LO.BUF_.BOUND= 131;
        END;
    IF LONEDO THEN  DO;
        LO_BUF= PROMPT_CHAR;
        CALL INSERT(LO_BUF,1,UI_ARS,UI_BUF);
        WRITE_DO.BUF_.BOUND= UI_ARS;
        CALL M$WRITE(WRITE_DO);
        WRITE_DO.BUF_.BOUND= 131;
        END;
    IF UI_BUF = ' '  OR
       UI_BUF = 'END' OR
       UI_BUF = 'Q'   THEN
         ALTRETURN;
READUI_RET:
    I= 0;
    RETURN;
READUI_ERR:
    ERR_CODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOF  OR
       B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$EOD  THEN
         ;
    ELSE DO;
         CALL M$ERRMSG( ERRMSG );
         IF B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR.CODE = %E$IOERR THEN
              GOTO READ_AGAIN; /* Probably noise on phone line, ignore it */
         END;
    UI_ERR= YES;
    ALTRETURN;
END READUI;
%EJECT;
ISIT_DIRECTIVE: PROC  ALTRET;
 
    DO INDX=0 TO NUM_CMNDS-1;
      IF SUBSTR(UI_BUF,0,8) = CMND(INDX) THEN GOTO DO_DIRECTIVE;
      END;
    IF SUBSTR(UI_BUF,0,5) ~= 'WIDTH' THEN
         RETURN;
    INDX= 16;
DO_DIRECTIVE:
    DO CASE(INDX);
      CASE(0,2);             /* BP OFF/BPOFF */
        BPON= NO;
      CASE(1,3);             /* BP ON/BPON   */
        BPON= YES;
      CASE(4);               /* LONG */
        WIDTH= 131;
        PLATEN_VLP.WIDTH#= 131;
        IF M$LO$->F$DCB.WIDTH# > 0 THEN
          CALL M$PLATEN(SET_PLATEN);
      CASE(5);               /* LP */
        CALL M$CLOSE(CLOS_LO);
        CALL M$OPEN(OPN_LO_LP);
        INDX= 4;
        GOTO DO_DIRECTIVE;
      CASE(6);               /* ME */
        CALL M$CLOSE(CLOS_LO);
        CALL M$OPEN(OPN_LO_ME);
        IF WIDTH > 79 THEN  DO;
          INDX= 14;
          GOTO DO_DIRECTIVE;
          END;
      CASE(7,9);             /* NO OCTAL/NOOCTAL */
        OCTAL= NO;
        TEXT= YES;
      CASE(8,10);            /* NO TEXT/NOTEXT */
        TEXT= NO;
        OCTAL= YES;
      CASE(11);              /* NO */
        CALL M$CLOSE(CLOS_LO);
        CALL M$OPEN(OPN_LO_NO);
      CASE(12);              /* OCTAL */
        OCTAL= YES;
      CASE(13);              /* PAGE */
        CALL M$DEVICE(WRITE_LO_PAGE);
      CASE(14);              /* SHORT */
        WIDTH= 79;
        PLATEN_VLP.WIDTH#= 79;
        IF M$LO$->F$DCB.WIDTH# > 0 THEN
          CALL M$PLATEN(SET_PLATEN);
      CASE(15);              /* TEXT */
        TEXT= YES;
      CASE(16);              /* WIDTH */
        STRING_LEN= 0;
        DO I=5 TO UI_ARS-1;
          BYT= UI_BYTE(I);
          IF BYT ~= ' '  AND
             BYT ~= '=' THEN
               IF BYT < '0'  OR
                  BYT > '9' THEN
                    /* Invalid decimal digit */
                    CALL POINT_TO_ERR(MESG21,I) ALTRET(ISIT_DIR_ERR);
               ELSE DO;
                      STRING_LEN= STRING_LEN + 1;
                      STRING(STRING_LEN)= BYT;
                    END;
          END;
        IF STRING_LEN <= 0 THEN
             /* Think you forgot something here! */
             CALL POINT_TO_ERR(MESG22,UI_ARS) ALTRET(ISIT_DIR_ERR);
        CALL CHARBIN(NUM,SUBSTR(STRINGS,1,STRING_LEN));
        IF NUM < 27  OR
           NUM > 132  THEN
             /* Width must be >= 27 and <= 132 */
             CALL POINT_TO_ERR(MESG23,7)  ALTRET(ISIT_DIR_ERR);
        WIDTH= NUM;
        PLATEN_VLP.WIDTH#= NUM;
        IF M$LO$->F$DCB.WIDTH# > 0 THEN
             CALL M$PLATEN(SET_PLATEN);
      END;
ISIT_DIR_ERR:
    ALTRETURN;
END ISIT_DIRECTIVE;
%EJECT;
GET_OPTIONS: PROC  ALTRET;
    NUMERIC= NO;
    DELIM= NO;
    NUM_UI_OPTIONS= 0;
    IF GOT_REC_NUMS THEN  DO;
      SAV_UI_OPTIONS= UI_OPT_BITS;
      IF UI_BYTE(I) = '.' THEN
           I= I + 1;
      END;
    UI_OPTIONS= 0;
    DO INDX=I TO UI_ARS-1;
      BYT= UI_BYTE(INDX);
      IF BYT ~= ' ' THEN DO;
           DO OPT_NUM=0 TO NUM_OPTIONS-1;
             IF BYT = OPTION(OPT_NUM) THEN GOTO SET_UI_OPTION;
             END;
           GOTO CHECK_DELIMS;
           END;
      ELSE GOTO GET_NXT_UI_OPT;
SET_UI_OPTION:
      IF UI_OPTION(OPT_NUM) THEN GOTO GET_NXT_UI_OPT;
      IF OPT_NUM < 2  THEN
           IF GOT_REC_NUMS THEN
                /* Option not legal here */
                CALL POINT_TO_ERR(MESG11,INDX)  ALTRET(OPTION_ERR);
           ELSE IF UI_OPTIONS ~= 0  THEN
                     /* F or S must be only option specified */
                     CALL POINT_TO_ERR(MESG1,INDX)  ALTRET(OPTION_ERR);
                ELSE;
      ELSE IF ITS_A.F_OPTION OR
              ITS_A.S_OPTION  THEN
                /* F or S must be only option specified */
                CALL POINT_TO_ERR(MESG1,INDX)  ALTRET(OPTION_ERR);
      NUM_UI_OPTIONS= NUM_UI_OPTIONS+1;
      UI_OPTION(OPT_NUM)= YES;
GET_NXT_UI_OPT:
      END;
    DONE_PARSING= YES;
    GOTO END_GET_OPTIONS;
 
CHECK_DELIMS:
    IF BYT >= '0' AND
       BYT <= '9'  THEN
         NUMERIC= YES;
    ELSE IF BYT = '-' OR
            BYT = ':' OR
            BYT = ',' OR
            BYT = '/' THEN
              DELIM= YES;
         ELSE /* Invalid option or delimiter */
              CALL POINT_TO_ERR(MESG0,INDX)  ALTRET(OPTION_ERR);
CHECK_OPTIONS:
    IF NOT DONE_PARSING THEN
         IF NUM_UI_OPTIONS = 0 THEN DO;
              NUM_UI_OPTIONS= 1;
              ITS_A.D_OPTION= YES;
              END;
END_GET_OPTIONS:
    UI_OPT_BITS= UI_OPT_BITS | SAV_UI_OPTIONS;
    RETURN;
OPTION_ERR:
    ALTRETURN;
END GET_OPTIONS;
%EJECT;
GET_REC_NUMS: PROC  ALTRET;
    GOT_REC_NUMS= YES;
    IF DONE_PARSING THEN RETURN;
    IF NUMERIC THEN DO;
         CALL GET_A_NUM  ALTRET(GET_REC_NUMS_ERR);
         FIRST_REC= THE_NUM;
         LAST_REC= THE_NUM;
         IF DONE_PARSING THEN
              RETURN;
         END;
    IF BYT = '-' THEN DO;
         INDX= INDX+1;
         SAV_POS= INDX;
         CALL GET_A_NUM  ALTRET(GET_REC_NUMS_ERR);
         IF NUMERIC THEN
              LAST_REC= THE_NUM;
         ELSE LAST_REC= 9999999;
         END;
    IF LAST_REC < FIRST_REC THEN
         /* Last record > First record */
         CALL POINT_TO_ERR(MESG15,SAV_POS)  ALTRET(GET_REC_NUMS_ERR);
    RETURN;
GET_REC_NUMS_ERR:
    ALTRETURN;
END GET_REC_NUMS;
%EJECT;
PARSE_STRING: PROC  ALTRET;
 
    STRING_STARTED= NO;
    STRING_LEN= -1;
    STRINGS= ' ';
    DELIM= NO;
    IF BYT ~= ','  THEN
         IF BYT = '/' THEN
              INDX= INDX-1;
         ELSE /* Expected a , here */
              CALL POINT_TO_ERR(MESG8,INDX)  ALTRET(PARSE_STRING_ERR);
    DO I=INDX+1 TO UI_ARS-1;
      BYT= UI_BYTE(I);
      IF STRING_STARTED THEN
           IF BYT = STRING_DEL THEN
                GOTO CHK_AFTR_STRING;
           ELSE CALL CHECK_STRING  ALTRET(PARSE_STRING_ERR);
       ELSE IF BYT = '/'  OR
               BYT = '''' OR
               BYT = '"' THEN  DO;
                 STRING_DEL= BYT;
                 STRING_STARTED= YES;
                 END;
            ELSE /* Expected a / ' or " here */
                 CALL POINT_TO_ERR(MESG5,I)  ALTRET(PARSE_STRING_ERR);
      END;
    IF STRING_STARTED THEN
         /* No final / or ' */
         CALL POINT_TO_ERR(MESG6,UI_ARS)  ALTRET(PARSE_STRING_ERR);
    ELSE /* I'm no mind reader!; What should I look for? */
         CALL POINT_TO_ERR(MESG4,UI_ARS)  ALTRET(PARSE_STRING_ERR);
PARSE_STRING_ERR:
    ALTRETURN;
CHK_AFTR_STRING:
    STRING_END= I-1;
    IF STRING_DEL = '''' THEN
         IF MOD(STRING_LEN,3) ~= 2 THEN
              /* Please give 3 digits per byte */
              CALL POINT_TO_ERR(MESG20,STRING_END) ALTRET(PARSE_STRING_ERR);
         ELSE CALL BLD_OCTAL;
    DO INDX=I+1 TO UI_ARS-1;
      BYT= UI_BYTE(INDX);
      IF BYT ~= ' ' THEN GOTO CHK_AFTR_STRING1;
      END;
    DONE_PARSING= YES;
    RETURN;
CHK_AFTR_STRING1:
    IF BYT = ',' OR
       BYT = '.' THEN
         DELIM= YES;
    ELSE /* Expected a , or . here */
         CALL POINT_TO_ERR(MESG9,INDX)  ALTRET(PARSE_STRING_ERR);
    RETURN;
 
END PARSE_STRING;
%EJECT;
GET_COLUMNS: PROC(FIRST_COL,LAST_COL)  ALTRET;
DCL FIRST_COL                UBIN;
DCL LAST_COL                 UBIN;
 
    IF DONE_PARSING THEN DO;
         FIRST_COL= 0;
         LAST_COL=  99999;
         RETURN;
         END;
    CALL GET_A_NUM  ALTRET(GET_COLUMNS_ERR);
    IF NUMERIC THEN
         FIRST_COL= THE_NUM-1;
    ELSE FIRST_COL= 0;
    IF NOT DONE_PARSING THEN
         IF BYT = '-' OR
            BYT = ',' THEN DO;
              INDX= INDX+1;
              SAV_POS= INDX;
              CALL GET_A_NUM  ALTRET(GET_COLUMNS_ERR);
              IF NUMERIC THEN
                   LAST_COL= THE_NUM-1;
              ELSE LAST_COL= 99999;
              END;
         ELSE;
    ELSE LAST_COL= 99999;
    IF NOT DONE_PARSING THEN
         IF BYT = '.' THEN
              IF ITS_A.F_OPTION = NO AND
                 ITS_A.S_OPTION = NO  THEN
                   /* Expected end of line/record here */
                   CALL POINT_TO_ERR(MESG13,INDX)
                                               ALTRET(GET_COLUMNS_ERR);
              ELSE;
         ELSE /* Expected end of line/record here */
              CALL POINT_TO_ERR(MESG13,INDX)  ALTRET(GET_COLUMNS_ERR);
    IF LAST_COL < FIRST_COL THEN
         /* Last column < First column */
         CALL POINT_TO_ERR(MESG16,SAV_POS)  ALTRET(GET_COLUMNS_ERR);
    RETURN;
GET_COLUMNS_ERR:
    ALTRETURN;
 
END GET_COLUMNS;
%EJECT;
GET_A_NUM: PROC  ALTRET;
 
    DELIM= NO;
    TMP_NUM_LEN= -1;
    DO I=INDX TO UI_ARS-1;
      BYT= UI_BYTE(I);
      IF BYT = ' ' THEN GOTO NEXT_DIGIT;
      IF BYT < '0' OR
         BYT > '9' THEN GOTO CONVERT_NUM;
      IF TMP_NUM_LEN = -1 AND
         BYT = '0' THEN GOTO NEXT_DIGIT;
      IF TMP_NUM_LEN < 9 THEN DO;
           TMP_NUM_LEN= TMP_NUM_LEN+1;
           TMP_DIGIT(TMP_NUM_LEN)= BYT;
           END;
      ELSE /* Number too big; Maximum of 10 digits */
           CALL POINT_TO_ERR(MESG2,I)  ALTRET(GET_A_NUM_ERR);
NEXT_DIGIT:
      END;
    DONE_PARSING= YES;
CONVERT_NUM:
    NUMERIC= YES;
    IF TMP_NUM_LEN >= 0 THEN DO;
         CALL CHARBIN(THE_NUM,SUBSTR(TMP_NUM,0,TMP_NUM_LEN+1));
         IF THE_NUM = 0 THEN
              THE_NUM= 1;
         ELSE;
         END;
    ELSE NUMERIC= NO;
    INDX= I;
    IF DONE_PARSING THEN
         RETURN;
    IF BYT = '-' OR
       BYT = ':' OR
       BYT = '/' OR
       BYT = ',' OR
       BYT = '.' THEN
         DELIM= YES;
    ELSE /* Invalid delimiter */
         CALL POINT_TO_ERR(MESG3,INDX)  ALTRET(GET_A_NUM_ERR);
    RETURN;
GET_A_NUM_ERR:
    ALTRETURN;
 
END GET_A_NUM;
%EJECT;
PUT_NUM_RECORDS: PROC  ALTRET;
 
    CALL M$PFIL(PFIL);
    REC_NUM= 0;
    PRECORD.V.N#= 99999;
    DO WHILE('1'B);
      CALL M$PRECORD(PRECORD)  ALTRET(CALC_NUM_RECORDS);
      REC_NUM= REC_NUM+99999;
      END;
CALC_NUM_RECORDS:
    REC_NUM= REC_NUM+M$SI$->F$DCB.ARS#;
    CALL BIN2CHAR(REC_NUM);
    CALL INSERT(LO_BUF,0,ZONED_LEN+8,
                  SUBSTR(ZONED,ZONED_INDX,ZONED_LEN),
                  ' Records');
    WRITE_LO.BUF_.BOUND= ZONED_LEN+7;
    CALL M$WRITE(WRITE_LO);
    ITS_A.N_OPTION= NO;
    NUM_UI_OPTIONS= NUM_UI_OPTIONS-1;
    IF NUM_UI_OPTIONS < 1 THEN
         ALTRETURN;
    RETURN;
 
END PUT_NUM_RECORDS;
%EJECT;
DO_F_SEARCH: PROC  ALTRET;
 
    IF SRCH_BEG_COL >= SI_ARS  OR
       SI_ARS - SRCH_BEG_COL < STRING_LEN  THEN
         ALTRETURN;
    TMP_LEN= SI_ARS;
    IF SI_ARS-1 < SRCH_END_COL THEN
         TMP_END_COL= SI_ARS - 1;
    ELSE TMP_END_COL= SRCH_END_COL;
    CALL INDEX(INDX,
               SUBSTR(STRINGS,0,STRING_LEN+1),
               REED_SI.BUF_.BUF$->STRNG,
               SRCH_BEG_COL);
    IF INDX + STRING_LEN > TMP_END_COL  THEN
         ALTRETURN;
    NUM_MATCHES= NUM_MATCHES+1;
    RETURN;
 
END DO_F_SEARCH;
%EJECT;
DO_S_SEARCH: PROC  ALTRET;
 
    IF M$SI$->F$DCB.ORG# = %KEYED# THEN DO;
         KEYL= KEY.LEN;
         KEY$= ADDR(KEY.EDIT);
         END;
    ELSE DO;
           KEYL= M$SI$->F$DCB.KEYL#;
           KEY$= ADDR(KEY.LEN);
         END;
    IF SRCH_BEG_COL >= KEYL  OR
       KEYL - SRCH_BEG_COL < STRING_LEN  THEN
         ALTRETURN;
    TMP_LEN= KEYL;
    IF KEYL - 1 < SRCH_END_COL THEN
         TMP_END_COL= KEYL - 1;
    ELSE TMP_END_COL= SRCH_END_COL;
    CALL INDEX(INDX,
               SUBSTR(STRINGS,0,STRING_LEN+1),
               KEY$->STRNG,
               SRCH_BEG_COL);
    IF INDX + STRING_LEN > TMP_END_COL THEN
         ALTRETURN;
    NUM_MATCHES= NUM_MATCHES + 1;
    RETURN;
 
END DO_S_SEARCH;
%EJECT;
PUT_EDIT_KEY: PROC;
 
    IF KEY.LEN ~= 3 OR
       KEY.EDIT > 99999999 THEN
         RETURN;
    NUM= KEY.EDIT;
    CALL BIN2CHAR(NUM);
    IF ZONED_INDX > 6 THEN  DO;
         CALL INSERT(ZONED,6,ZONED_INDX-6,'000');
         ZONED_INDX= 7;
         END;
    IF LO_INDX < 10 THEN DO;
      CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' - '),' - ');
      LO_INDX= LO_INDX+LENGTHC(' - ');
      END;
    IF BPON THEN
         ZONED_INDX= 2;
    IF ZONED_INDX < 7 THEN  DO;
         CALL INSERT(LO_BUF,LO_INDX,7-ZONED_INDX,
                         SUBSTR(ZONED,ZONED_INDX,7-ZONED_INDX));
         LO_INDX= LO_INDX+(7-ZONED_INDX);
         END;
    CALL INSERT(LO_BUF,LO_INDX,4,'.',SUBSTR(ZONED,7,3));
    LO_INDX= LO_INDX+4;
 
END PUT_EDIT_KEY;
%EJECT;
PUT_BYTE_COUNT: PROC;
 
    CALL BIN2CHAR(SI_ARS);
    CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' - '),' - ');
    LO_INDX= LO_INDX+LENGTHC(' - ');
    IF BPON THEN
      IF ZONED_INDX > 4 THEN
           ZONED_INDX= 4;
    ZONED_LEN= 10-ZONED_INDX;
    CALL INSERT(LO_BUF,LO_INDX,ZONED_LEN,SUBSTR(ZONED,ZONED_INDX,ZONED_LEN));
    LO_INDX= LO_INDX+ZONED_LEN;
    CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' Bytes'),' Bytes');
    LO_INDX= LO_INDX+LENGTHC(' Bytes');
 
END PUT_BYTE_COUNT;
%EJECT;
PUT_KEY: PROC;
 
    IF M$SI$->F$DCB.ORG# = %KEYED# THEN  DO;
         KEYL= KEY.LEN;
         FROM$= ADDR(KEY.EDIT);
         END;
    ELSE IF M$SI$->F$DCB.ORG# = %INDEXED# THEN  DO;
              KEYL= M$SI$->F$DCB.KEYL#;
              FROM$= ADDR(KEY.LEN);
              END;
         ELSE RETURN;
    IF NOT OCTAL THEN
         GOTO PUT_KEY_TEXT;
    MAX_LEN= (WIDTH-7)/3;
    TMP_LEN= (WIDTH - LO_INDX - 10)/3;
    IF TMP_LEN > 0 THEN
         IF (KEYL <= TMP_LEN OR KEYL > MAX_LEN-3) THEN  DO;
              CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' - Key=O'''),' - Key=O''');
              LO_INDX= LO_INDX+LENGTHC(' - Key=O''');
              END;
         ELSE DO;
                CALL PRINT_LO(LENGTHC('       KEY=O'''));
                LO_BUF= '       Key=O''';
                TMP_LEN= (WIDTH - 13)/3;
              END;
    ELSE DO;
           CALL PRINT_LO;
           LO_BUF= '       Key=O''';
           LO_INDX= LENGTHC('       Key=O''');
           TMP_LEN= (WIDTH - 13)/3;
         END;
    IF TMP_LEN > KEYL THEN
      TMP_LEN= KEYL;
    BEG= 0;
    DO WHILE(BEG < KEYL);
      CALL TO_OCTAL(FROM$,BEG*3,TMP_LEN);
      BEG= BEG+TMP_LEN;
      IF BEG < KEYL THEN  DO;
        LO_BYTE(LO_INDX)= '+';
        LO_INDX= LO_INDX+1;
        CALL PRINT_LO(7);
        IF MAX_LEN > KEYL - BEG THEN
             TMP_LEN= KEYL - BEG;
        ELSE TMP_LEN= MAX_LEN;
        END;
      END;
    LO_BYTE(LO_INDX)= '''';
    LO_INDX= LO_INDX+1;
%EJECT;
PUT_KEY_TEXT:
 
    IF NOT TEXT THEN
      RETURN;
    MAX_LEN= WIDTH-7;
    IF OCTAL THEN
         LBL_LEN= 0;
    ELSE LBL_LEN= 6;
    TMP_LEN= WIDTH-LO_INDX-1;
    IF KEYL > TMP_LEN AND
       KEYL+LBL_LEN+6 <= WIDTH THEN DO;
         CALL PRINT_LO(7);
         TMP_LEN= MAX_LEN;
         END;
    IF NOT OCTAL THEN
         CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' - Key='),' - Key=');
    ELSE LO_BYTE(LO_INDX)= '=';
    LO_INDX= LO_INDX+LBL_LEN+1;
    BEG= 0;
    IF TMP_LEN > KEYL THEN
         TMP_LEN= KEYL;
    DO WHILE(BEG < KEYL);
      TO$= PINCRC(ADDR(LO_BUF),LO_INDX);
      CALL XLATE(TO$->LOBUF,  XLATE_TAB, FROM$->STRNG);
      LO_INDX= LO_INDX+TMP_LEN;
      FROM$= PINCRC(FROM$,TMP_LEN);
      BEG= BEG+TMP_LEN;
      IF BEG < KEYL THEN DO;
        CALL PRINT_LO(7);
        IF MAX_LEN > KEYL-BEG THEN
             TMP_LEN= KEYL-BEG;
        ELSE TMP_LEN= MAX_LEN;
        END;
      END;
    RETURN;
END PUT_KEY;
%EJECT;
PUT_TEXT: PROC  ALTRET;
 
    IF DISP_END_COL > SI_ARS-1 THEN
         TMP_END_COL= SI_ARS-1;
    ELSE TMP_END_COL= DISP_END_COL;
    TEXT_LEN= TMP_END_COL - DISP_BEG_COL + 1;
    IF LO_INDX+TEXT_LEN+LENGTHC(' - ') > WIDTH  AND
       TEXT_LEN+9 <= WIDTH THEN  DO;
         CALL PRINT_LO(6);
         TMP_LEN= WIDTH-6;
         END;
    ELSE IF LO_INDX+4 > WIDTH THEN DO;
              CALL PRINT_LO(6);
              TMP_LEN= WIDTH-6;
              END;
         ELSE TMP_LEN= WIDTH - LO_INDX - LENGTHC(' - ');
    CALL INSERT(LO_BUF,LO_INDX,LENGTHC(' - '),' - ');
    LO_INDX= LO_INDX+LENGTHC(' - ');
    IF TMP_LEN > TEXT_LEN THEN
         TMP_LEN= TEXT_LEN;
    BEG= DISP_BEG_COL;
    FROM$= PINCRC(REED_SI.BUF_.BUF$,DISP_BEG_COL);
    DO WHILE(BEG <= TMP_END_COL);
      TO$= PINCRC(ADDR(LO_BUF),LO_INDX);
      CALL XLATE(TO$->LOBUF,  XLATE_TAB,  FROM$->STRNG);
      FROM$= PINCRC(FROM$,TMP_LEN);
      LO_INDX= LO_INDX+TMP_LEN;
      BEG= BEG+TMP_LEN;
      IF BEG <= TMP_END_COL THEN  DO;
           CALL PRINT_LO(7);
           IF BROKEN THEN
                CALL HANDLE_BREAK  ALTRET( CANCELED_BY_BREAK );
           IF WIDTH-7 > TMP_END_COL - BEG THEN
                TMP_LEN= TMP_END_COL - BEG + 1;
           ELSE TMP_LEN= WIDTH - 7;
           END;
      END;
    RETURN;
 
CANCELED_BY_BREAK:
    ALTRETURN;
 
END PUT_TEXT;
%EJECT;
PUT_OCTAL: PROC  ALTRET;
 
    CALL PRINT_LO(7);
    IF DISP_END_COL > SI_ARS-1 THEN
         TMP_END_COL= SI_ARS-1;
    ELSE TMP_END_COL= DISP_END_COL;
    TEXT_LEN= TMP_END_COL - DISP_BEG_COL + 1;
    MAX_WRDS= (WIDTH - 9) / 17;
    MAX_LO_INDX= 7+(MAX_WRDS*13)-1;
    LO_INDX= MOD(DISP_BEG_COL,4);
    IF TMP_END_COL > 4 THEN
         LEN= 4 - LO_INDX;
    ELSE LEN= TMP_END_COL - LO_INDX + 1;
    LO_INDX= (LO_INDX*3)+8;
    BEG= DISP_BEG_COL;
    FROM$= REED_SI.BUF_.BUF$;
    DO WHILE(BEG < TMP_END_COL+1);
      CALL BIN2CHAR(BEG+1);
      IF ZONED_INDX > 5 THEN
        CALL INSERT(ZONED,5,ZONED_INDX-5,'0000');
      LO_BUF= SUBSTR(ZONED,4,6);
      START= BEG;
      DO WHILE(LO_INDX <= MAX_LO_INDX);
        CALL TO_OCTAL(FROM$,BEG*3,LEN);
        BEG= BEG+LEN;
        LEN= 4;
        LO_INDX= LO_INDX+1;
        IF BEG+4 > TMP_END_COL THEN  DO;
             LEN= TMP_END_COL - BEG + 1;
             IF LO_INDX > MAX_LO_INDX THEN
                  MAX_LO_INDX= 7 + (LEN * 3);
             ELSE MAX_LO_INDX= LO_INDX + (LEN * 3) - 1;
             END;
        END;
      IF ITS_A.I_OPTION THEN  DO;
        TMP_LEN= BEG - START;
        IF BPON THEN
             LO_INDX= 7+(MAX_WRDS*13)+2;
        ELSE LO_INDX= LO_INDX+1;
        TO$= PINCRC(ADDR(LO_BUF),LO_INDX);
        FROM$= PINCRC(REED_SI.BUF_.BUF$,START);
        CALL XLATE(TO$->LOBUF,  XLATE_TAB,  FROM$->STRNG);
        LO_INDX= LO_INDX+TMP_LEN;
        FROM$= REED_SI.BUF_.BUF$;
        END;
      CALL PRINT_LO(8);
      IF BROKEN THEN
           CALL HANDLE_BREAK(8)  ALTRET(OCTAL_ERR_RETURN);
      END;
OCTAL_RETURN:
    RETURN;
OCTAL_ERR_RETURN:
    ALTRETURN;
 
END PUT_OCTAL;
%EJECT;
TO_OCTAL: PROC(FROM$,BEG,LEN);
DCL FROM$                    PTR;
DCL BEG                      UBIN;
DCL LEN                      UBIN;
DCL DIG(0:0) BASED           UBIN(3)   UNAL;
 
    DO I=BEG TO BEG+(LEN*3)-1;
      LO_BYTE(LO_INDX)= BINASC(48+FROM$->DIG(I));
      LO_INDX= LO_INDX+1;
      END;
    RETURN;
END TO_OCTAL;
%EJECT;
HANDLE_BREAK: PROC(INDX)  ALTRET;
DCL INDX                     UBIN;
 
    SAV_BPON= BPON;
    IF NOT SEARCHING THEN
      GOTO DO_WE_CANCEL;
    BPON= NO;
    LO_BUF= '-- Interrupted at record ';
    LO_INDX= LENGTHC('-- Interrupted at record ');
    CALL BIN2CHAR(REC_NUM);
    CALL PUT_NUM;
    CALL INSERT(LO_BUF,LO_INDX,1,'(');
    LO_INDX= LO_INDX+1;
    ZONED= ' ';
    CALL PUT_EDIT_KEY;
    IF ZONED = ' ' THEN
         WRITE_DO.BUF_.BOUND= LO_INDX-2;
    ELSE DO;
           CALL INSERT(LO_BUF,LO_INDX,1,')');
           WRITE_DO.BUF_.BOUND= LO_INDX;
         END;
    CALL M$WRITE(WRITE_DO);
 
    IF ITS_A.F_OPTION  OR
       ITS_A.S_OPTION THEN DO;
      LO_BUF= '-- Thus far: ';
      LO_INDX= LENGTHC('-- Thus far: ');
      CALL SEARCH_SUMMARY;
      END;
DO_WE_CANCEL:
    IF ADDR(INDX) = ADDR(NIL) THEN
         LO_INDX= 7;
    ELSE LO_INDX= INDX;
    WRITE_DO.V.DVBYTE.VFC#= '1'B;
    WRITE_DO.BUF_.BOUND= 19;
    LO_BUF= 'aEnter C to continue';
    CALL M$WRITE(WRITE_DO);
    LO_BUF= ' ';
    UI_BYTE(0)= ' ';
    WRITE_DO.V.DVBYTE.VFC#= '0'B;
    WRITE_DO.BUF_.BOUND= 131;
    CALL M$READ(READ_M$UI)  ALTRET(HANDLE_ALT);
    BPON= SAV_BPON;
    BROKEN= NO;
    IF UI_BYTE(0) = 'C'  OR
       UI_BYTE(0) = 'c'  THEN
         RETURN;
HANDLE_ALT:
    BPON= SAV_BPON;
    BROKEN= NO;
    ALTRETURN;
 
END HANDLE_BREAK;
%EJECT;
SEARCH_SUMMARY: PROC;
 
      IF REC_NUM > LAST_REC THEN
           NUM_SEARCHED= REC_NUM - FIRST_REC;
      ELSE NUM_SEARCHED= REC_NUM - FIRST_REC + 1;
      CALL BIN2CHAR(NUM_SEARCHED);
      CALL PUT_NUM;
      IF NUM_SEARCHED > 1 THEN DO;
           CALL INSERT(LO_BUF,LO_INDX,19,' records searched;');
           LO_INDX= LO_INDX+LENGTHC(' records searched; ');
           END;
      ELSE DO;
             CALL INSERT(LO_BUF,LO_INDX,18,' record searched;');
             LO_INDX= LO_INDX+LENGTHC(' record searched; ');
           END;
      CALL BIN2CHAR(NUM_MATCHES);
      CALL PUT_NUM;
      IF NUM_MATCHES > 1 THEN DO;
           CALL INSERT(LO_BUF,LO_INDX,14,' Matches found');
           LO_INDX= LO_INDX+LENGTHC(' Matches found');
           END;
      ELSE DO;
             CALL INSERT(LO_BUF,LO_INDX,12,' match found');
             LO_INDX= LO_INDX+LENGTHC(' match found');
           END;
      WRITE_DO.BUF_.BOUND= LO_INDX-1;
      CALL M$WRITE(WRITE_DO);
 
END SEARCH_SUMMARY;
%EJECT;
PUT_EOF_MESG: PROC;
 
    SAV_BPON= BPON;
    BPON= NO;
    LO_BUF= 'EOF hit after record ';
    LO_INDX= LENGTHC('EOF hit after record ');
    CALL BIN2CHAR(REC_NUM);
    CALL PUT_NUM;
    ZONED= ' ';
    CALL INSERT(LO_BUF,LO_INDX,1,'(');
    LO_INDX= LO_INDX+1;
    CALL PUT_EDIT_KEY;
    IF ZONED = ' ' THEN
         WRITE_LO.BUF_.BOUND= LO_INDX-2;
    ELSE DO;
           CALL INSERT(LO_BUF,LO_INDX,1,')');
           WRITE_LO.BUF_.BOUND= LO_INDX;
         END;
    CALL M$WRITE(WRITE_LO);
    BPON= SAV_BPON;
 
END PUT_EOF_MESG;
%EJECT;
BIN2CHAR: PROC(NUM);
DCL NUM                      UBIN;
 
    CALL BINCHAR(ZONED,NUM);
    ZONED_INDX= 0;
    DO WHILE(ZONED_INDX < 9  AND
             ZONED_BYTE(ZONED_INDX) = '0');
      ZONED_BYTE(ZONED_INDX)= ' ';
      ZONED_INDX= ZONED_INDX+1;
      END;
    ZONED_LEN= 10-ZONED_INDX;
 
END BIN2CHAR;
%EJECT;
CHECK_STRING: PROC  ALTRET;
 
    IF STRING_DEL ~= '/' THEN
         IF STRING_DEL = '''' THEN
              IF BYT < '0'  OR
                 BYT > '7' THEN
                   CALL POINT_TO_ERR(MESG18,I) ALTRET(CHK_STR_ERR);
              ELSE;
         ELSE IF BYT >= '0' AND
                 BYT <= '9' THEN
                   IF BYT < 'A'  OR
                      BYT > 'F' THEN
                        /* Invalid Hex digit */
                        CALL POINT_TO_ERR(MESG19,I) ALTRET(CHK_STR_ERR);
    STRING_LEN= STRING_LEN + 1;
    STRING(STRING_LEN)= BYT;
    RETURN;
 
CHK_STR_ERR:
    ALTRETURN;
 
END CHECK_STRING;
%EJECT;
BLD_OCTAL: PROC;
 
    NUM= (STRING_LEN+1)/3;
    DO INDX=1 TO NUM;
      U.BIN9= ((ASCBIN(SUBSTR(STRINGS,(INDX*3)-3,1)) - 48) * 64);
      U.BIN9= U.BIN9 +  ((ASCBIN(SUBSTR(STRINGS,(INDX*3)-2,1)) - 48) *  8);
      U.BIN9= U.BIN9 + (ASCBIN(SUBSTR(STRINGS,(INDX*3)-1,1)) - 48);
      STRING(INDX-1)= U.CHAR1;
      END;
    STRING_LEN= NUM - 1;
 
END BLD_OCTAL;
%EJECT;
PUT_NUM: PROC;
 
    IF BPON THEN  DO;
         CALL INSERT(LO_BUF,LO_INDX,6,SUBSTR(ZONED,4,6));
         LO_INDX= LO_INDX+6;
         END;
    ELSE DO;
           CALL INSERT(LO_BUF,LO_INDX,ZONED_LEN,SUBSTR(ZONED,ZONED_INDX,ZONED_LEN));
           LO_INDX= LO_INDX+ZONED_LEN;
         END;
 
END PUT_NUM;
%EJECT;
POINT_TO_ERR: PROC(ERR_NUM,POS)  ALTRET;
DCL ERR_NUM                  UBIN;
DCL POS                      UBIN;
 
    IF LONEDO THEN DO;
      LO_BUF= PROMPT_CHAR;
      CALL INSERT(LO_BUF,1,80,UI_BUF);
      WRITE_DO.BUF_.BOUND= UI_ARS;
      CALL M$WRITE(WRITE_DO);
      WRITE_DO.BUF_.BOUND= 131;
      END;
    LO_BUF= ' ';
    LO_BYTE(POS+1)= '^';
    IF POS <= MESG_LEN(ERR_NUM) THEN DO;
      CALL M$WRITE(WRITE_LO);
      IF LONEDO THEN
           CALL M$WRITE(WRITE_DO);
      LO_BUF= ' ';
      END;
    WRITE_LO.BUF_.BOUND= MESG_LEN(ERR_NUM)-1;
    CALL INSERT(LO_BUF,0,WRITE_LO.BUF_.BOUND+1,MESG(ERR_NUM));
    CALL M$WRITE(WRITE_LO);
    IF LONEDO THEN
         CALL M$WRITE(WRITE_DO);
    ALTRETURN;
 
END POINT_TO_ERR;
%EJECT;
PRINT_LO: PROC(INDX);
DCL INDX                     UBIN;
    WRITE_LO.BUF_.BOUND= LO_INDX-1;
    IF LO_BUF ~= ' ' THEN
      CALL M$WRITE(WRITE_LO);
    LO_BUF= ' ';
    LO_INDX= INDX;
END PRINT_LO;
 
PUT_BLANK_LINE: PROC(INDX);
DCL INDX                     UBIN;
    WRITE_LO.BUF_.BOUND= 1;
    LO_BUF= ' ';
    CALL M$WRITE(WRITE_LO);
    LO_INDX= INDX;
END PUT_BLANK_LINE;
 
END LOOK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
BREAK: PROC ASYNC;
 
%INCLUDE CP_6;
 
%FPT_TRMPRG (FPTN=RESET_BRK_CNT,
             RSTBRK=YES);
 
DCL BROKEN                   BIT(1)    SYMREF;
 
    BROKEN= '1'B;
    CALL M$TRMPRG(RESET_BRK_CNT);
    RETURN;
 
END BREAK;
