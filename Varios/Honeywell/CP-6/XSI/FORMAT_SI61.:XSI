/*M* FORMAT_SI61 - PL-6 source formatter */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,MCL=10,CRM=70 */
 
FORMAT_SI61: PROC MAIN;
 
 /***
  *** INCLUDE files:
  ***/
 
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B_MICROPS_C;
%INCLUDE ZQU$FORMAT_SUBS1_C;
%INCLUDE ZQU$F_OPT_C;
%INCLUDE FORMAT_C2;
%INCLUDE XS_MACRO_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
 
 /***
  *** External routines:
  ***/
 
DCL X$PARSE ENTRY(1) ALTRET;
DCL XSA$OPEN ENTRY(2) ALTRET;           /* Fast open                */
DCL XSA$READ ENTRY(2) ALTRET;           /* Fast read                */
DCL XSA$PFIL ENTRY(2) ALTRET;           /* Fast pfil                */
DCL XSA$CLOSE ENTRY(2) ALTRET;          /* Fast close               */
DCL XSA$WRITE ENTRY(2) ALTRET;          /* Fast write               */
DCL ZQU$FORMATINIT ENTRY;               /* Entry pre-formatting     */
DCL ZQU$FORMAT ENTRY(5);           /* Record formatting routine     */
DCL ZQU$INIT ENTRY;           /* Formatting routine initialization  */
DCL ZQU$INTHANDLER ENTRY ASYNC;         /* Break handler            */
DCL ZQU$PREFORMATINIT ENTRY;       /* Formatting pre-initialization */
DCL ZQU$EOF ENTRY;                      /* Formatting end           */
DCL ZQW$STARXOPTIONS ENTRY(1);          /* *X* option processing    */
 
 /***
  *** SYMREFs:
  ***/
 
DCL A_COMMAND UBIN SYMREF;              /* Command line parse nodes */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL PART_OF_PL6 BIT(1) SYMREF;
DCL PAGE_AFTER_LINE BIT(1) SYMREF;      /* Page after next line     */
DCL DO_HEADER_NEEDED BIT(1) SYMREF; /* Indicates if DO header needed */
DCL RECORD_NEEDED SBIN SYMREF;     /* Indicates if record needed    */
DCL COPYRIGHT_YEAR SBIN SYMREF;         /* Year of copyright notice */
DCL STEPCC SBIN SYMREF;                 /* Final STEPCC             */
%FPT_WRITE(FPTN=WRITDOLISTHEADER,
   STCLASS=SYMREF);
DCL NONBLANKTBL(0:511) UBIN BYTE UNAL SYMREF; /* Search table for non-blank */
DCL LFREAD BIT(1) SYMREF;          /* Indicates "read list file"    */
DCL F_OVERRIDE_X_COMMENTS BIT(1) SYMREF;
                                   /* Don't listen to *X* comments  */
DCL F_PL1_CODE BIT(1) SYMREF;
         /* Treat as PL/1 code...accept lower case keywords, accept
         dashed in variable names, accept asterisk in column 1 to
         mean comment line.                                         */
DCL F_PARTRGE_CODE BIT(1) SYMREF;
     /* Treat as PARTRGE input...don't format anything but comments */
DCL F_C_CODE BIT(1) SYMREF;
DCL F_FMT_IF_STARX BIT(1) SYMREF;
                         /* Indicates "format only if *X* found"    */
DCL F_GET_STARX BIT(1) SYMREF;
                         /* Indicates "get initial *X* from M$ME    */
%FORMAT_OPTIONS;
 
 /***
  *** DCBs:
  ***/
 
DCL M$ME DCB;
DCL M$SI DCB;
DCL M$UI DCB;
DCL M$OU DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL F$LISTFILE DCB;
DCL F$NSOHIST DCB;
 
 /***
  *** STATICs:
  ***/
 
  /*** Break and error flags: ***/
 
DCL ZQU$BREAKFLAG SBIN STATIC SYMDEF; /* Incremented by break handler */
DCL MAJOR_ERROR BIT(1) STATIC;          /* Indicates "stop soon"    */
 
  /*** Plus card reading variables: ***/
 
DCL M$SI$ PTR STATIC;                   /* Source DCB pointer       */
DCL M$UI$ PTR STATIC;                   /* Update DCB pointer       */
DCL M$OU$ PTR STATIC;                   /* Output DCB pointer       */
DCL PLUS_ERROR BIT(1) STATIC;      /* Indicates "plus card error"   */
DCL PLUSSTART SBIN WORD STATIC;         /* Beginning of plus range  */
DCL PLUSEND SBIN WORD STATIC;           /* End of plus range or -1  */
 
DCL SIEOF BIT(1) STATIC;                /* Indicates "SI end"       */
%KEYFMT(FPTN=SIKEY);
DCL SIFID CHAR(80) STATIC;              /* Name of SI file          */
DCL SIORG SBIN STATIC;                  /* ORG of SI file           */
DCL SIRECNBR SBIN STATIC;               /* Current SI record number */
DCL UIEOF BIT(1) STATIC;                /* Indicates "UI end"       */
 
%KEYFMT(FPTN=UIKEY);
DCL UINEXT BIT(1) STATIC;               /* Indicates "read UI next" */
DCL UIFID CHAR(80) STATIC;              /* Name of UI file          */
DCL UIORG SBIN STATIC;                  /* ORG of UI file           */
DCL UIPLUSNBR SBIN STATIC;              /* Number after plus card   */
               /* Indicates (>0) if current record came from UI     */
DCL UIREAD BIT(1) STATIC;               /* Indicates "read UI"      */
DCL UIRECNBR SBIN STATIC;               /* Current UI record number */
DCL UITHERE BIT(1) STATIC;         /* Indicates "UI file present"   */
%RECFMT(FPTN=LASTPLUSCARDREC);
 
  /*** Input buffer variables: ***/
 
DCL FROMUI BIT(1) STATIC;     /* Indicates "last input from UI"     */
DCL 1 CRNTERR STATIC,                   /* Last input error         */
      2 FCG BIT(12) UNAL,
      2 MID BIT(6) UNAL,
      2 MON BIT(1) UNAL,
      2 CODE UBIN(14) UNAL,
      2 SEV UBIN(3) UNAL;
%RECFMT(FPTN=REC);
DCL RECPOS SBIN STATIC;                 /* Current position         */
 
  /*** Output variables: ***/
 
DCL OUWRIT BIT(1) STATIC;          /* Indicates "write OU file"     */
%KEYFMT(FPTN=OUKEY);
%KEYFMT(FPTN=LASTOUKEY);
DCL OUORG SBIN STATIC;                  /* ORG of OU file           */
DCL OURECNBR SBIN STATIC;               /* Current OU record number */
%RECFMT(FPTN=OUREC);
DCL LOWRIT BIT(1) STATIC;          /* Indicates "write LO file"     */
 
 /*** List file variables: ***/
 
DCL LFCOLUMN SBIN STATIC INIT(1); /* Column in which file name begins */
%RECFMT(FPTN=LFREC);
%KEYFMT(FPTN=LFKEY);
DCL LFORG SBIN STATIC;                  /* ORG of LF file           */
DCL LFRECNBR SBIN STATIC;               /* Current LF record number */
 
  /*** Record saving ***/
 
%RECFMT(FPTN=SAVREC);
DCL SAVE_FROMUI BIT(1) STATIC;
 
  /*** Temporaries: ***/
 
DCL I SBIN STATIC;
DCL T SBIN STATIC;
DCL T1 SBIN STATIC;
DCL T2 SBIN STATIC;
DCL XBUFFER CHAR(140) STATIC;
DCL N SBIN STATIC;
DCL PARSE_AREA(0:1023) UBIN STATIC;     /* Parser work area         */
DCL TEMP SBIN STATIC;
DCL TEMP$ PTR STATIC;
DCL 1 WHEREBUF STATIC,                  /* Where we are             */
      2 OURECNBR CHAR(%KEYCHARLEN) UNAL,
      2 UPLUS CHAR(1) UNAL,
      2 * CHAR(1) UNAL INIT(' '),
      2 RECKEY CHAR(%KEYCHARLEN) UNAL;
 
  /*** Run specific information: ***/
 
DCL 1 LISTHEADER STATIC,                /* Listing header and date  */
      2 TIMENDATE,
        3 GTIME CHAR(5) UNAL,
        3 * CHAR(1) UNAL INIT(' '),
        3 GDATE CHAR(10) UNAL,
        3 * CHAR(1) UNAL INIT(' '),
      2 SIUIFIDS UNAL,
        3 C(0:59) CHAR(1) UNAL,
      2 SIUIFIDSCHARS REDEF SIUIFIDS CHAR(60) UNAL,
      2 * CHAR(3) UNAL INIT(' ');
DCL LISTHEADERCHARS REDEF LISTHEADER CHAR(80);
DCL 1 NSOREC STATIC,
      2 SIUIFIDSCHARS CHAR(61),
      2 * CHAR(1) INIT(' '),
      2 TIMENDATE CALIGNED,
        3 GTIME CHAR(5) UNAL,
        3 * CHAR(1) UNAL INIT(' '),
        3 GDATE CHAR(10) UNAL,
        3 * CHAR(1) UNAL INIT(' '),
      2 * CHAR(1) INIT(' '),
      2 WARNING CHAR(20);
%VLP_NAME(FPTN=FILENAME,LEN=31);
%EQU FORMATTABLE_MAX_STAR_T=4;
DCL FORMATTABLE_STAR_T(0:%FORMATTABLE_MAX_STAR_T) CHAR(63) STATIC INIT(
   '/*T***********************************************************/',
   '/*T*                                                         */',
   '/*T* Copyright (c) Bull HN Information Systems Inc.,         */',
   '/*T*                                                         */',
   '/*T***********************************************************/' );
DCL 1 STAR_T_PIECE(0:%FORMATTABLE_MAX_STAR_T) REDEF FORMATTABLE_STAR_T,
      2 BEGIN CHAR(1) UNAL,
      2 * CHAR(52) UNAL,
      2 YEAR CHAR(4) UNAL,
      2 * CHAR(05) UNAL,
      2 ENDING CHAR(1) UNAL;
DCL NEXT_STAR_T SBIN STATIC;            /* Index of next *T* record */
DCL STAR_T_NEEDED_NOW BIT(1) STATIC;    /* Indicates *T* needed     */
DCL NEEDING_STAR_T BIT(1) STATIC;       /* Need *T* sometime        */
DCL RESTORE_AFTER_STAR_T BIT(1) STATIC; /* Record to be written after *T* */
DCL STAR_T_STARTX SBIN STATIC;          /* Where *T* should start   */
DCL STAR_T_PREFIX_STARTX SBIN STATIC; /* Where to start the comment (e.g.") */
DCL STAR_T_PREFIX CHAR(4) STATIC;       /* What it is.              */
DCL STAR_T_SUFFIX_EXISTS BIT(1) STATIC; /* Put a " after the *T*    */
DCL REGURGITATED BIT(1) STATIC;    /* If record saved then restored */
DCL UPDATE_NOT_INSERTED BIT(1) STATIC; /* Flags fact that UI not
         included in source output due to NSO option */
 
  /*** Source/update/output options: ***/
 
DCL OU_MAKEUP SBIN STATIC;              /* Indicates how OU is made */
DCL UI_ERR_NON_FATAL BIT(1) STATIC INIT('0'B); /* Ignores UI file if error opening */
DCL UI_MISSING_NO_MSG BIT(1) STATIC INIT('0'B); /* No message if UI doesn't exist */
DCL LIST_UPDATES BIT(1) STATIC INIT('0'B); /* List updates before output */
DCL UI_ANYWAY BIT(1) STATIC INIT('0'B); /* Read UI even if not PRFLAGS.UI */
DCL OU_ANYWAY BIT(1) STATIC INIT('0'B); /* Write OU even if not PRFLAGS.OU */
DCL LO_ANYWAY BIT(1) STATIC INIT('0'B); /* Write LO even if not PRFLAGS.LO */
DCL LIST_SOURCE BIT(1) STATIC INIT('0'B); /* List source file       */
DCL FORMATTABLE BIT(1) STATIC INIT('1'B); /* Can be formatted       */
DCL FORMATTABLE_DECIDED BIT(1) STATIC INIT('0'B); /* FORMATTABLE decided */
DCL FMT_TYPE SBIN STATIC;     /* Indicates "type of formatting"     */
DCL F_FORMAT_UPDATES_ONLY BIT(1) STATIC INIT('0'B);
          /* Output file should only contain updates and plus cards */
DCL WHERE_INCREMENT SBIN STATIC INIT(0);
                                   /* Tell where every n records    */
DCL NO_SOURCE_UPDATE BIT(1) STATIC INIT('0'B); /* Only write
         source input file to source output if file also specifies */
DCL ALREADY_UPDATED BIT(1) STATIC; /* Indicates that plus card
         directives have already had an effect on the output file */
DCL NSO_ALL BIT(1) STATIC INIT('0'B); /* ALL filename for NSOhist file
         means we are to create new source only if no UI exists. */
 
 /***
  *** CONSTANTs:
  ***/
 
DCL OUREC$ PTR CONSTANT INIT(ADDR(OUREC));
DCL REC$ PTR CONSTANT INIT(ADDR(REC));
DCL LASTOUKEY$ PTR CONSTANT INIT(ADDR(LASTOUKEY));
DCL LASTPLUSCARDREC$ PTR CONSTANT INIT(ADDR(LASTPLUSCARDREC));
DCL OUKEY$ PTR CONSTANT INIT(ADDR(OUKEY));
DCL SIKEY$ PTR CONSTANT INIT(ADDR(SIKEY));
DCL UIKEY$ PTR CONSTANT INIT(ADDR(UIKEY));
DCL SIFID$ PTR CONSTANT INIT(ADDR(SIFID));
DCL UIFID$ PTR CONSTANT INIT(ADDR(UIFID));
DCL BLANK CHAR(1) CONSTANT INIT(' ');
DCL LET_NSO_YES CHAR(0) CONSTANT INIT('LET NSO=1');
DCL LET_NSO_NO CHAR(0) CONSTANT INIT('LET NSO=0');
 
 /***
  *** BASED:
  ***/
 
%B$ALT;
%B$TCB;
%F$DCB(DCBN=F$DCB);
DCL FLAG BIT(1) BASED ALIGNED;
DCL NCHARS CHAR(N) BASED UNAL;
DCL STAR_TYPE CHAR(3) BASED UNAL;
DCL 1 KEY BASED,
      2 L UBIN BYTE UNAL,
      2 * CHAR(KEY.L) UNAL;
%KEYFMT(FPTN=BASEDKEY,STCLASS=BASED);
DCL 1 TEXTC BASED,                      /* textc characters         */
      2 L UBIN BYTE UNAL,
      2 C CHAR(TEXTC.L) UNAL;
%PARSE$OUT(STCLASS=BASED);
%PARSE$SYM(STCLASS=BASED);
 
 /***
  *** FPTs:
  ***/
 
%P_PCB(NAME=FMTCMD,
   T=XBUFFER,
   R=A_COMMAND,
   W=PARSE_AREA,
   WSZ=1024,
   STCLASS=STATIC);
 
%FPT_CLOSE(FPTN=CLOSLF,
   DCB=F$LISTFILE,
   DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSLO,
   DCB=M$LO,
   RELG=YES,
   DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSSI,
   DCB=M$SI,
   DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSUI,
   DCB=M$UI,
   DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSOU,
   DCB=M$OU,
   RELG=YES,
   DISP=SAVE);
 
%FPT_CLOSE(FPTN=CLOSNSOHIST,
   DCB=F$NSOHIST,
   DISP=SAVE );
 
%FPT_CORRES(FPTN=CORRESDOLO,
   DCB1=M$DO,
   DCB2=M$LO);
 
%FPT_CLOSE(FPTN=LISTFILECLOSE,
   DCB=F$LISTFILE,
   DISP=SAVE);
 
%FPT_TIME(FPTN=GETTIME,
   TIME=LISTHEADER.TIMENDATE.GTIME,
   DATE=LISTHEADER.TIMENDATE.GDATE);
 
%XSA_PARAM(FPTN=FASTSI);
 
%FPT_READ(FPTN=READSI,
   DCB=M$SI,
   BUF=REC.LISTREC.CHARX,
   KEY=SIKEY,
   KEYR=YES);
 
%FPT_ERRMSG(FPTN=RPTCRNTERR,
   OUTDCB1=M$DO,
   BUF=XBUFFER,
   CODE=CRNTERR,
   INCLCODE=NO);
 
%FPT_PFIL(FPTN=UIPFILBOF,
   DCB=M$UI,
   BOF=YES);
 
%XSA_PARAM(FPTN=FASTUI);
 
%FPT_READ(FPTN=READUI,
   DCB=M$UI,
   BUF=REC.LISTREC.CHARX,
   KEY=UIKEY,
   KEYR=YES);
 
%FPT_WRITE(FPTN=WRITEUI,
   DCB=M$OU,
   BUF=REC.LISTREC.CHARX,
   KEY=UIKEY);
%FPT_WRITE(FPTN=WRITESI,
   DCB=M$OU,
   BUF=REC.LISTREC.CHARX,
   KEY=SIKEY);
 
%FPT_READ(FPTN=LISTFILEREAD,
   DCB=F$LISTFILE,
   BUF=LFREC.LISTREC.CHARX,
   KEY=LFKEY,
   KEYR=YES);
 
%FPT_DEVICE( FPTN=LOHEADER,
   DCB=M$LO,
   PAGE=YES,
   HDR=LOHEADERHDR );
 
%VLP_HDR( FPTN=LOHEADERHDR,
   RESETPAGE=YES,
   COUNT=76,
   HEADERHEIGHT=2,
   TITLE='HH:MM MON DA "YR 123456789012345678901234567890123456789012345678901234567890    PLUSAFEW');
 
%FPT_OPEN(FPTN=OPENSI,
   DCB=M$SI,
      ACS=SEQUEN,
   FUN=IN);
 
%FPT_OPEN(FPTN=OPENUI,
   DCB=M$UI,
      ACS=SEQUEN,
   FUN=IN);
 
%FPT_OPEN(FPTN=OPENOU,
   DCB=M$OU,
      ACS=SEQUEN,
   FUN=CREATE);
 
%FPT_OPEN(FPTN=OPENLO,
   DCB=M$LO,
   FUN=CREATE);
 
%FPT_DEVICE(FPTN=PAGELO,
   DCB=M$LO,
   PAGE=YES);
 
%FPT_UNFID(FPTN=SIUNFID,
   DCB=M$SI,
   TEXTFID=SIFID);
 
%FPT_UNFID(FPTN=UIUNFID,
   DCB=M$UI,
   TEXTFID=UIFID);
 
%FPT_OPEN(FPTN=LISTFILEOPEN,
   DCB=F$LISTFILE,
   FUN=IN);
 
%FPT_OPEN(FPTN=NSOHISTOPEN,
   DCB=F$NSOHIST,
   FUN=CREATE,
   EXIST=OLDFILE,
   ACS=JRNL,
   ORG=CONSEC );
 
%FPT_INT(FPTN=GETINT,
   UENTRY=ZQU$INTHANDLER);
 
%FPT_WRITE( FPTN=WHEREME,
   DCB=M$ME,
   BUF=WHEREBUF );
 
%FPT_WRITE(FPTN=WRITDO,
   DCB=M$DO);
 
%FPT_WRITE(FPTN=WRITLO,
   DCB=M$LO,
   BUF=OUREC.LISTREC);
 
%FPT_WRITE(FPTN=WRITLOLISTHEADER,
   DCB=M$LO,
   BUF=LISTHEADER);
 
%FPT_WRITE(FPTN=WRITLOBLANK,
   DCB=M$LO,
   BUF=BLANK);
 
%FPT_WRITE(FPTN=NSOHIST_UPDATE,
   DCB=F$NSOHIST,
   BUF=NSOREC );
 
%XSA_PARAM(FPTN=FASTOU);
 
%FPT_WRITE(FPTN=WRITOU,
   DCB=M$OU,
   BUF=OUREC.LISTREC.CHARX);
 
%FPT_EXIT(FPTN=STEPCC4,
   STEPCC=4);
 
%FPT_EXIT(FPTN=STEPCCFPT);
 
%FPT_GDP(FPTN=GETKBUF,
   PAGES=1,
   RESULTS=DPVECTOR);
 
%FPT_GDP(FPTN=GETBBUF,
   PAGES=3,
   RESULTS=DPVECTOR);
 
%FPT_YC(FPTN=NSO_YES,
   CMD=LET_NSO_YES);
 
%FPT_YC(FPTN=NSO_NO,
   CMD=LET_NSO_NO);
 
%VLP_VECTOR(FPTN=DPVECTOR);
 
%VLP_NAME(FPTN=FIDNAME,
   LEN=31);
 
%VLP_ACCT(FPTN=FIDACCT);
 
%VLP_PASS(FPTN=FIDPASS);
 
%VLP_SN(FPTN=FIDSN,
   SN="' ',' ',' ',' ',' ',' ',' ',' ',' ',' '",
   N=10);
 
%VLP_WSN(FPTN=FIDWSN);
 
%FPT_OPEN(FPTN=OPENFID,
   SCRUB=YES,
   ACCT=FIDACCT,
   NAME=FIDNAME,
   PASS=FIDPASS,
   SN=FIDSN,
   WSN=FIDWSN,
   CTG=YES);
 
%VLR_FID(FPTN=FIDRESULTS);
 
%FPT_FID(FPTN=FILEFID,
   ACCT=FIDACCT,
   NAME=FIDNAME,
   PASS=FIDPASS,
   RES=OPENFID.V.RES#,
   SN=FIDSN,
   WSN=FIDWSN,
   ASN=OPENFID.V.ASN#,
   RESULTS=FIDRESULTS);
 
 /***
  *** Error messages:
  ***/
 
%EQU ERRMSGS_MAX=26;
DCL ERRMSGS(0:%ERRMSGS_MAX) CHAR(80) CONSTANT INIT(
%EQU PLUSILGLRNG=0;
     '*** End of replacement range is less than beginning',
     %EQU PLUSINSINSOVLP=1;
     '*** Previous insertion point is at or after current insertion point',
     %EQU PLUSINSREPOVLP=2;
     '*** Previous insertion point is in or after current replacement range',
     %EQU PLUSREPINSOVLP=3;
     '*** Previous replacement range ends after current insertion point',
     %EQU PLUSREPREPOVLP=4;
     '*** Previous replacement range overlaps current replacement range',
     %EQU PLUSILGLFMT=5;
     '*** Invalid plus card format',
     %EQU LFCANTPROCESS=6;
     '*** List file record unprocessed due to unopened file(s) ***',
     %EQU LFREADERR=7;
     '*** Error attempting to read list file after record ***',
     %EQU LFFILENAMETOOLONG=8;
     '*** File name too long in list file record ***',
     %EQU SIEOFNOTRNG=9;
     '*** Unexpected source eof looking for end of plus card range',
     %EQU SIEOFBFRRNG=10;
     '*** Unexpected source file end before plus card range',
     %EQU CANTREADLF=11;
     '*** Error attempting to read first list file record',
     %EQU FMTANYWAY=12;
     '... Formatting continues anyway',
     %EQU LFRECILGL=13;
     '*** Invalid list file record ***',
     %EQU RTNUIKEYOVLP=14;
     '*** Key overlap while retaining update keys...key generated',
     %EQU SIEOFALREADY=15;
     '*** Update(s) added at end since source file already ended',
     %EQU SYNTAX_ERROR=16;
     '*** Syntax error ***',
     %EQU OPTION_OVERRIDE=17;
     '*** Option overrides previous ***',
     %EQU NOTTHERE=18;
     '*** Formatting routines do not exist yet',
     %EQU CYR_MADE_CON=19;
     '*** CON assumed since CYR specified',
     %EQU NO_CYR_WITH_FUF=20;
     '*** FMT(CYR) can not be specified with FMT(FUF)',
     %EQU NO_OUORG_WITH_FUF=21;
     '*** No output file organization can be specified with FMT(FUF)',
     %EQU FUF_BUT_NO_UI=22;
     '*** A UI file must exist with FMT(FUF)',
     %EQU CYR_MADE_KEY=23;
     '*** KEY assumed since CYR specified',
     %EQU PLUSILGLRNGSTRT=24;
     '*** +0,X assumed to be +1,X',
     %EQU NO_NSO_WITH_FUF=25;
     '*** FMT(NSO=fid) can not be specified with FMT(FUF)',
     %EQU UI_TO_OU=26;
     '*** Updates applied to source output; NSO specified too late' );
DCL ERRSTEPCCS(0:%ERRMSGS_MAX) SBIN CONSTANT INIT(
   /* 0  1  2  3  4  5  6  7  8  9  */
      2, 2, 2, 2, 2, 2, 4, 4, 4, 2,
      2, 4, 0, 4, 2, 2, 4, 1, 4, 0,
      1, 1, 4, 0, 1, 4, 4 );
 
 /***
  *** Other:
  ***/
 
%SUB ALTRET_HANDLING="WHILE('0'B)";
%SUB TIL_ALTRET="WHILE('1'B)";
 
/*** Output file makeup ***/
 
%EQU DEFAULT_MAKEUP=0;
%EQU RTNUIKEYS_MAKEUP=1;
%EQU KEYED_MAKEUP=2;
%EQU CONSEC_MAKEUP=3;
 
/*** Formatting type ***/
 
%EQU DEFAULT_TYPE=0;
%EQU FORMAT_TYPE=1;
%EQU FORMAT_UI_TYPE=2;
%EQU DONT_FORMAT_TYPE=3;
 
%EJECT;
/********************/
 
   PART_OF_PL6 = %NO#;
 
 /***
  *** Get options/set defaults.
  ***/
 
   CALL ZQU_GETOPTIONS ALTRET(FATALERR);
 /***
  *** Initialize major pointers and values.
  ***/
 
   M$SI$ = DCBADDR(DCBNUM(M$SI));
   M$UI$ = DCBADDR(DCBNUM(M$UI));
   M$OU$ = DCBADDR(DCBNUM(M$OU));
   LFRECNBR = 0;                   /* No list file records read     */
   STEPCC = 0;                          /* No errors yet            */
 
   IF LFREAD
    THEN DO;                            /* Process list file        */
      LFORG = DCBADDR(DCBNUM(F$LISTFILE))->F$DCB.ORG#;
      OPENSI.NAME_ = VECTOR(FILENAME); /* Specify name for list file */
      OPENUI.NAME_ = VECTOR(FILENAME);
      OPENOU.NAME_ = VECTOR(FILENAME);
      DO TIL_ALTRET;
         MAJOR_ERROR = %NO#;
         DO_HEADER_NEEDED = %NO#; /* Don't print DO header if error yet */
         CALL ZQU_LISTFILEREAD ALTRET( LFCLOSE );
         CALL ZQU_FORMATFILE;
         CALL ZQU_CLOSEFILES;
         END;
      END;
    ELSE DO;                            /* Single file              */
      MAJOR_ERROR = %NO#;
      DO_HEADER_NEEDED = %NO#;
      CALL ZQU_OPENFILES ALTRET( LSCLOSE );
      CALL ZQU_FORMATFILE;
      CALL ZQU_CLOSEFILES;
      END;
 
 /***
  *** Close list file.
  ***/
 
   DO ALTRET_HANDLING;
LFCLOSE: ;
      CALL M$CLOSE( CLOSLF );
      END;
 
 /***
  *** Close listing file.
  ***/
 
LSCLOSE: ;
   IF DCBADDR(DCBNUM(M$LO))->F$DCB.FCD#
    THEN CALL M$CLOSE( CLOSLO );
   IF DCBADDR(DCBNUM(F$NSOHIST))->F$DCB.FCD#
    THEN CALL M$CLOSE( CLOSNSOHIST );
 
   STEPCCFPT.V.STEPCC# = STEPCC;
   CALL M$EXIT( STEPCCFPT );
 
 /***
  *** Fatal error handling...print error and exit.
  ***/
 
FATALERR: ;
   CALL M$EXIT( STEPCC4 );
 
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_GETOPTIONS: PROC ALTRET;
/*F*     NAME: ZQU_GETOPTIONS
         PURPOSE: Get command line options and set defaults.
 ***/
 
 /***
  *** Locals:
  ***/
 
DCL HICHAR SBIN STATIC;                 /* Syntax error position    */
DCL OPTIONCODE SBIN STATIC;   /* Code of option being processed     */
DCL OPTIONNUM SBIN STATIC;         /* Ix of option being processed  */
DCL OPTIONBLK$ PTR STATIC; /* Pointer to output node being processed */
DCL SUBOPTIONBLK$ PTR STATIC;
DCL SUBOPTIONCODE SBIN STATIC;
DCL SUBOPTIONNUM SBIN STATIC;
 
/********************/
 
   ZQU$BREAKFLAG = 0;                   /* Reset break flag         */
 
 /***
  *** If no command line options specified, set defaults.
  ***/
 
   OU_MAKEUP = %DEFAULT_MAKEUP;         /* Depends on SI/UI files   */
   LFREAD = %NO#;                       /* Assume no listfile       */
   NO_SOURCE_UPDATE = %NO#;        /* Assume not no source update   */
   UI_ERR_NON_FATAL = %NO#;             /* Assume fatal UI error    */
   UI_MISSING_NO_MSG = %NO#;            /* Give message if UI error */
   LIST_UPDATES = %NO#;            /* Assume don't list updates     */
   COPYRIGHT_YEAR = 0;                  /* No copyright year        */
   FMT_TYPE = %DEFAULT_TYPE;            /* Assume no formatting     */
   F_FORMAT_UPDATES_ONLY = %NO#;
   CALL ZQU$PREFORMATINIT;
   MAJOR_ERROR = %NO#;                  /* Reset major error flag   */
   IF B$JIT.CCARS > B$JIT.CCDISP
    THEN DO;                            /* Process options          */
 
    /***
     *** Set up parse control block to parse CCBUF options.
     ***/
 
      N = B$JIT.CCARS - B$JIT.CCDISP;
      ADDR(XBUFFER)->NCHARS = PINCRC( ADDR(B$JIT.CCBUF), B$JIT.CCDISP )->NCHARS;
      FMTCMD.NCHARS = N;
      CALL X$PARSE( FMTCMD ) ALTRET( SYNERR );
      DO ALTRET_HANDLING;
SYNERR:  ;
         HICHAR = FMTCMD.HI_CHAR + 1;
         CALL ZQU_XBUFERR( %SYNTAX_ERROR, HICHAR );
         MAJOR_ERROR = %YES#;           /* Fool PL-6                */
         IF MAJOR_ERROR THEN ALTRETURN;
         END;
 
    /***
     *** Process specified options.
     ***/
 
      DO OPTIONNUM = 0 TO FMTCMD.OUT$->OUT$BLK.NSUBLKS-1;
         OPTIONBLK$ = FMTCMD.OUT$->OUT$BLK.SUBLK$(OPTIONNUM);
         OPTIONCODE = OPTIONBLK$->OUT$BLK.CODE;
         HICHAR = OPTIONBLK$->OUT$BLK.CPOS + 1; /* Know char position */
         DO CASE( OPTIONCODE );
 
          CASE(%RETAIN_UI_KEYS,%KEY_SOURCE_OUTPUT,%CONSEC_SOURCE_OUTPUT);
            IF OU_MAKEUP ~= %DEFAULT_MAKEUP
             THEN DO;                   /* Option override          */
               CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
               END;
            IF OPTIONCODE = %RETAIN_UI_KEYS
             THEN OU_MAKEUP = %RTNUIKEYS_MAKEUP;
             ELSE IF OPTIONCODE = %KEY_SOURCE_OUTPUT
                THEN OU_MAKEUP = %KEYED_MAKEUP;
                ELSE OU_MAKEUP = %CONSEC_MAKEUP;
 
          CASE(%LIST_UPDATES);
            LIST_UPDATES = %YES#;
 
          CASE(%UI_ANYWAY);
            UI_ANYWAY = %YES#;
 
          CASE(%OU_ANYWAY);
            OU_ANYWAY = %YES#;
 
          CASE(%LO_ANYWAY);
            LO_ANYWAY = %YES#;
 
          CASE(%NO_UIERR_ABORT);
            UI_ERR_NON_FATAL = %YES#;
 
          CASE(%NO_UIERR_ABORT_OR_MSG);
            UI_ERR_NON_FATAL = %YES#;
            UI_MISSING_NO_MSG = %YES#;
 
          CASE( %DONT_FORMAT_FILE );
            IF FMT_TYPE ~= %DEFAULT_TYPE
             THEN DO;
               CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
               END;
            FMT_TYPE = %DONT_FORMAT_TYPE;
 
          CASE(%FORMAT_FILE);
            IF FMT_TYPE ~= %DEFAULT_TYPE
             THEN DO;
               CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
               END;
            FMT_TYPE = %FORMAT_TYPE;
 
          CASE(%PL1CODE);
            OPTIONBLK$ = ADDR(F_PL1_CODE);
            GOTO LANGUAGE_OPTION;
          CASE(%CC_CODE);
            OPTIONBLK$ = ADDR(F_C_CODE);
            GOTO LANGUAGE_OPTION;
          CASE(%PARTRGECODE);
            OPTIONBLK$ = ADDR(F_PARTRGE_CODE);
LANGUAGE_OPTION: ;
            IF F_PL1_CODE OR F_PARTRGE_CODE OR F_C_CODE
             THEN DO;
               CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
               F_PL1_CODE = %NO#;
               F_PARTRGE_CODE = %NO#;
               F_C_CODE = %NO#;
               END;
            OPTIONBLK$->FLAG = %YES#;
            GOTO FORMAT_THIS;
          CASE(%IGNORESTARX);
            F_OVERRIDE_X_COMMENTS = %YES#;
            GOTO FORMAT_THIS;
          CASE(%IFSTARX);
            F_FMT_IF_STARX = %YES#;
            GOTO FORMAT_THIS;
          CASE(%GETXOPTIONS);
            F_GET_STARX = %YES#;
            GOTO FORMAT_THIS;
          CASE(%FORMAT_UPDATES_ONLY);
            F_FORMAT_UPDATES_ONLY = %YES#;
            GOTO FORMAT_THIS;
          CASE(%COPYRIGHT_YEAR);
            IF COPYRIGHT_YEAR > 0
             THEN CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
            CALL CHARBIN( COPYRIGHT_YEAR, OPTIONBLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT );
            STAR_T_PIECE.YEAR(2) = OPTIONBLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
FORMAT_THIS: ;
            IF FMT_TYPE ~= %DEFAULT_TYPE
             THEN IF FMT_TYPE ~= %FORMAT_TYPE
                THEN CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
            FMT_TYPE = %FORMAT_TYPE;
          CASE( %STARXCOMMENTOPTION );
            CALL ZQW$STARXOPTIONS( OPTIONBLK$ );
            GOTO FORMAT_THIS;
 
          CASE(%USE_LISTFILE);
            LFREAD = %YES#;
            IF OPTIONBLK$->OUT$BLK.NSUBLKS > 0
             THEN DO;
               FILEFID.TEXTFID_ = VECTOR(OPTIONBLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
               CALL M$FID( FILEFID ) ALTRET(TELL_MAJOR_ERROR);
               OPENFID.V.DCB# = DCBNUM(F$LISTFILE);
               OPENFID.V.FUN# = %IN#;
               OPENFID.V.ACS# = %SEQUEN#;
               CALL M$OPEN( OPENFID ) ALTRET(TELL_MAJOR_ERROR);
               END;
             ELSE CALL M$OPEN( LISTFILEOPEN) ALTRET(TELL_MAJOR_ERROR);
 
          CASE(%NO_SOURCE_UPDATE);
            NO_SOURCE_UPDATE = %YES#;
            IF OPTIONBLK$->OUT$BLK.NSUBLKS > 0
             THEN DO;
               FILEFID.TEXTFID_ = VECTOR(OPTIONBLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
               CALL M$FID( FILEFID ) ALTRET(TELL_MAJOR_ERROR);
               OPENFID.V.DCB# = DCBNUM(F$NSOHIST);
               OPENFID.V.FUN# = %CREATE#;
               OPENFID.V.EXIST# = %OLDFILE#;
               OPENFID.V.ORG# = %CONSEC#;
               OPENFID.V.ACS# = %JRNL#;
               IF FIDNAME.NAME# = 'ALL'
                THEN NSO_ALL = '1'B;
                ELSE CALL M$OPEN( OPENFID ) ALTRET(TELL_MAJOR_ERROR);
               END;
             ELSE CALL M$OPEN( NSOHISTOPEN ) ALTRET(TELL_MAJOR_ERROR);
            CALL M$YC( NSO_NO );
 
          CASE(%WHERE_INCREMENT);
            IF WHERE_INCREMENT > 0
             THEN CALL ZQU_XBUFERR( %OPTION_OVERRIDE, HICHAR );
            CALL CHARBIN( WHERE_INCREMENT, OPTIONBLK$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT );
 
          END /* CASE command line option */;
         DO ALTRET_HANDLING;
TELL_MAJOR_ERROR: ;
            MAJOR_ERROR = %YES#;
            CALL ZQU_RPTCRNTERR;
            END;
         END /* Each command line option */;
      END /* Command line options exist */;
 
 /***
  *** If formatting updates only, make restrictions.
  ***/
 
   IF F_FORMAT_UPDATES_ONLY
    THEN DO;
      IF COPYRIGHT_YEAR > 0
       THEN DO;
         MAJOR_ERROR = %YES#;
         CALL ZQU_XBUFERR( %NO_CYR_WITH_FUF, 0 );
         END;
      IF OU_MAKEUP ~= %DEFAULT_MAKEUP
       THEN DO;
         MAJOR_ERROR = %YES#;
         CALL ZQU_XBUFERR( %NO_OUORG_WITH_FUF, 0 );
         END;
      IF NO_SOURCE_UPDATE
       THEN DO;
         MAJOR_ERROR = %YES#;
         CALL ZQU_XBUFERR( %NO_NSO_WITH_FUF, 0 );
         END;
      END;
 
 /***
  *** OU must be consecutive for copyright year.
  ***/
 
   IF COPYRIGHT_YEAR > 0
    THEN IF OU_MAKEUP ~= %KEYED_MAKEUP AND OU_MAKEUP ~= %CONSEC_MAKEUP
       THEN DO;
         IF OU_MAKEUP = %RTNUIKEYS_MAKEUP
          THEN DO;                      /* RUK -> KEY if CYR        */
            OU_MAKEUP = %KEYED_MAKEUP;
            CALL ZQU_XBUFERR( %CYR_MADE_KEY, 0 );
            END;
          ELSE DO;                      /* Other -> CON if CYR      */
            OU_MAKEUP = %CONSEC_MAKEUP;
            CALL ZQU_XBUFERR( %CYR_MADE_CON, 0 );
            END;
         END;
 
 /***
  *** Change DONT_FORMAT_TYPE to DEFAULT_TYPE.  Means the
  *** same thing and permits fewer comparisons.  However,
  *** the default (now) is to format, so change DEFAULT_TYPE
  *** to FORMAT_TYPE.
  ***/
 
   IF FMT_TYPE = %DONT_FORMAT_TYPE
    THEN FMT_TYPE = %DEFAULT_TYPE;
    ELSE IF FMT_TYPE = %DEFAULT_TYPE
       THEN FMT_TYPE = %FORMAT_TYPE;
 
 /***
  *** Any major errors cause abort.
  ***/
 
   IF MAJOR_ERROR THEN CALL M$EXIT( STEPCC4 );
   CALL ZQU$FORMATINIT;
   RETURN;
 
END ZQU_GETOPTIONS;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_OPENFILES: PROC ALTRET;
/*F*     NAME: ZQU_OPENFILES
         PURPOSE: Open source, update, output, and listing files
            depending on options and specifications.
 ***/
 
 /***
  *** Locals:
  ***/
 
DCL NO_MSG BIT(1) STATIC;
 
/********************/
 
 /***
  *** Always open source file.
  ***/
 
   CALL XSA$OPEN( OPENSI, FASTSI ) ALTRET( SIOPNERR );
   CALL M$UNFID( SIUNFID );
   SIORG = M$SI$->F$DCB.ORG#;
   SIEOF = %NO#;
   IF FASTSI.BBUF_ = VECTOR(NIL)
    THEN DO;                            /* Need fast buffers        */
      CALL M$GDP( GETKBUF ) ALTRET( FATALERR );
      FASTSI.KBUF_ = DPVECTOR;
      CALL M$GDP( GETBBUF ) ALTRET( FATALERR );
      FASTSI.BBUF_ = DPVECTOR;
      END;
   DO ALTRET_HANDLING;
SIOPNERR: ;
      MAJOR_ERROR = %YES#;
      IF STEPCC < 4
       THEN STEPCC = 4;
      CALL ZQU_RPTXSAERR( FASTSI );
      END;
   IF NOT LFREAD
    THEN FILENAME = M$SI$->F$DCB.NAME#; /* Get name of SI file      */
 
 /***
  *** Open update file if specified.  UI error is not a major error if
  *** a listfile is being used or if user says it isn't.
  ***/
 
   IF B$JIT.PRFLAGS.UI OR UI_ANYWAY
    THEN DO;                            /* Update file specified    */
      IF NOT LFREAD AND M$UI$->F$DCB.NAME#.L = 0
       THEN OPENUI.NAME_ = VECTOR(FILENAME); /* Use SI name         */
      CALL XSA$OPEN( OPENUI, FASTUI ) ALTRET( UIOPNERR );
      CALL M$UNFID( UIUNFID );
      UITHERE = %YES#;                  /* UI file present          */
      UIORG = M$UI$->F$DCB.ORG#;
      UIREAD = %YES#;                   /* Begin by reading UI      */
      UINEXT = %YES#;
      PLUSSTART = 0;                    /* Eliminate overlap        */
      PLUSEND = 0;                      /* Permits +0               */
      UIEOF = %NO#;
      UIPLUSNBR = 0;
      IF FASTUI.BBUF_ = VECTOR(NIL)
       THEN DO;                         /* Need fast buffers        */
         CALL M$GDP( GETKBUF ) ALTRET( FATALERR );
         FASTUI.KBUF_ = DPVECTOR;
         CALL M$GDP( GETBBUF ) ALTRET( FATALERR );
         FASTUI.BBUF_ = DPVECTOR;
         END;
      DO ALTRET_HANDLING;
UIOPNERR: ;
         IF FASTUI.ERR.CODE = %E$NOFILE AND UI_MISSING_NO_MSG
          THEN NO_MSG = %YES#;          /* Give no error message    */
          ELSE DO;
            NO_MSG = %NO#;
            CALL ZQU_RPTXSAERR( FASTUI );
            END;
         IF LFREAD OR UI_ERR_NON_FATAL
          THEN DO;                 /* Don't read UI due to error    */
            UITHERE = %NO#;
            CALL ZQU_SETNOUI;
            IF NOT NO_MSG AND NOT MAJOR_ERROR
             THEN CALL ZQU_ERROR( %FMTANYWAY );
            END;
          ELSE DO;
            MAJOR_ERROR = %YES#;
            IF STEPCC < 4
             THEN STEPCC = 4;
            END;
         END;
      END;
    ELSE DO;
      UITHERE = %NO#;
      CALL ZQU_SETNOUI;                 /* Don't read UI            */
      END;
 
 /***
  *** Must have UI file if formatting update only.
  ***/
 
   IF F_FORMAT_UPDATES_ONLY AND NOT UITHERE
    THEN DO;
      MAJOR_ERROR = %YES#;
      CALL ZQU_ERROR( %FUF_BUT_NO_UI );
      END;
 
 /***
  *** Determine ORG of output file from options and specifications.
  ***/
 
   DO CASE( OU_MAKEUP );
    CASE(%KEYED_MAKEUP);
      OUORG = %KEYED#;
    CASE(%CONSEC_MAKEUP);
      OUORG = %CONSEC#;
    CASE(%DEFAULT_MAKEUP);
      IF UIREAD
       THEN IF F_FORMAT_UPDATES_ONLY
          THEN OUORG = UIORG;
          ELSE OUORG = %CONSEC#;
       ELSE OUORG = SIORG;              /* Just like input file     */
    CASE(%RTNUIKEYS_MAKEUP);
      IF UIREAD
       THEN OUORG = UIORG;
       ELSE OUORG = SIORG;
    END;
 
 /***
  *** Initialize OU writing FPT.
  ***/
 
   IF OUORG = %KEYED#
    THEN WRITOU.KEY_ = VECTOR(OUKEY);
    ELSE WRITOU.KEY_ = VECTOR(NIL);
 
 /***
  *** Open output file if specified.
  ***/
 
   IF (B$JIT.PRFLAGS.OU OR OU_ANYWAY) AND NOT MAJOR_ERROR
    THEN DO;
      OPENOU.V.ORG# = OUORG;
      CLOSOU.V.DISP# = %SAVE#;
      IF NOT LFREAD AND (M$OU$->F$DCB.NAME#.L = 0
        OR M$OU$->F$DCB.NAME#.C = '*G')
       THEN OPENOU.NAME_ = VECTOR(FILENAME); /* Use SI name         */
      CALL XSA$OPEN( OPENOU, FASTOU ) ALTRET( OUOPNERR );
      IF FASTOU.BBUF_ = VECTOR(NIL)
       THEN DO;                         /* Need fast buffers        */
         CALL M$GDP( GETBBUF ) ALTRET( FATALERR );
         FASTOU.BBUF_ = DPVECTOR;
         END;
      OUWRIT = %YES#;
      DO ALTRET_HANDLING;
OUOPNERR: ;
         MAJOR_ERROR = %YES#;
         CALL ZQU_RPTXSAERR( FASTOU );
         OUWRIT = %NO#;
         END;
      END;
 
 /***
  *** Open listing file if specified and now yet opened.
  ***/
 
   IF (B$JIT.PRFLAGS.LS OR LO_ANYWAY OR LIST_UPDATES) AND NOT MAJOR_ERROR
    THEN DO;
      IF NOT DCBADDR(DCBNUM(M$LO))->F$DCB.FCD#
       THEN DO;
         CALL M$OPEN( OPENLO ) ALTRET( LOOPNERR );
         CALL M$DEVICE( PAGELO ) ALTRET( LOOPNERR ); /* Fresh page  */
         END;
      LOWRIT = %YES#;
      IF B$JIT.PRFLAGS.LS OR LO_ANYWAY
       THEN LIST_SOURCE = %YES#;        /* List source file         */
       ELSE LIST_SOURCE = %NO#;
      END;
    ELSE DO;
      DO ALTRET_HANDLING;
LOOPNERR: ;
         MAJOR_ERROR = %YES#;
         CALL ZQU_RPTCRNTERR;
         END;
      LOWRIT = %NO#;
      LIST_SOURCE = %NO#;
      END;
 
 /***
  *** Altreturn if major error.
  ***/
 
   IF MAJOR_ERROR THEN ALTRETURN;
 
   DO_HEADER_NEEDED = %YES#;       /* Need error message header     */
   RETURN;
FATALERR: ;
 
   CALL ZQU_RPTCRNTERR;
   MAJOR_ERROR = %YES#;
   ALTRETURN;
 
END ZQU_OPENFILES;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_SETNOUI: PROC;
/*F*     NAME: ZQU_SETNOUI
         PURPOSE: Sets up variables to indicate that there is no UI.
 ***/
 
/********************/
 
 /***
  *** Make sure that a UI range will never be encountered and that
  *** when SI eof if hit, UI "eof" has already been hit.
  ***/
 
   UIREAD = %NO#;                       /* Don't read UI            */
   UINEXT = %NO#;                       /* Read SI next             */
   PLUSSTART = 99999999;                /* What file is this big??  */
   PLUSEND = -1;
   UIEOF = %YES#;
   RETURN;
 
END ZQU_SETNOUI;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_FORMATFILE: PROC;
/*F*     NAME: ZQU_FORMATFILE
         PURPOSE: For each record in the source/update file, format
            it, and possibly write it to the output file and possibly
            list it.
 ***/
 
/********************/
 
 /***
  *** Read, count, format, write, and list each record.
  ***/
 
   SIRECNBR = 0;
   UIRECNBR = 0;
   OURECNBR = 0;
   CALL M$TIME( GETTIME );
 
 /***
  *** If the update file is to be listed, do it now.
  ***/
 
   IF LIST_UPDATES AND LOWRIT AND UITHERE
    THEN DO;                            /* List update file         */
      CALL INDEX1( N, ' ', UIFID );     /* Length of UI fid         */
      IF N > LENGTHC(LISTHEADER.SIUIFIDS)
       THEN N = LENGTHC(LISTHEADER.SIUIFIDS);
      LISTHEADER.SIUIFIDSCHARS = ' ';
      ADDR(LISTHEADER.SIUIFIDS)->NCHARS = UIFID$->NCHARS;
      WRITLOLISTHEADER.BUF_.BOUND = LENGTHV(LISTHEADER.TIMENDATE) + N;
      LOHEADERHDR.TITL.TITLE# = LISTHEADERCHARS;
      LOHEADERHDR.TITL.L# = LENGTHC(LISTHEADERCHARS);
      CALL M$DEVICE( LOHEADER ) ALTRET( LOPAGEERR );
      CALL M$DEVICE( PAGELO ) ALTRET( LOPAGEERR );
      CALL M$WRITE( WRITLOBLANK ) ALTRET( LOPAGEERR );
      WRITLO.BUF_ = VECTOR(REC.LISTREC);
      REC.LISTREC.MID.UPLUS = ' ';      /* Clear (don't need '*')   */
      DO TIL_ALTRET;
         CALL XSA$READ( READUI, FASTUI ) ALTRET( UILISTEOF );
         UIRECNBR = UIRECNBR + 1;
         CALL ZQU_KEYTEXT( UIORG, UIRECNBR, UIKEY, REC.LISTREC.SEQRKEY );
         WRITLO.BUF_.BOUND = FASTUI.ARS# + %KEYCHARLEN + LENGTHV(REC.LISTREC.MID);
         CALL M$WRITE( WRITLO ) ALTRET( LOPAGEERR );
         END;
 
      DO ALTRET_HANDLING;
UILISTEOF: ;
         IF FASTUI.ERR.CODE ~= %E$EOF
          THEN DO;                      /* Unexpected error         */
            CALL ZQU_RPTXSAERR( FASTUI );
            MAJOR_ERROR = %YES#;
            END;
          ELSE DO;                 /* Reset for regular UI reading  */
            CALL XSA$CLOSE( CLOSUI, FASTUI ) ALTRET( UIPFILERR );
            CALL XSA$OPEN( OPENUI, FASTUI ) ALTRET( UIPFILERR );
            UIRECNBR = 0;
            CALL M$DEVICE( PAGELO ) ALTRET( LOPAGEERR );
            END;
         DO ALTRET_HANDLING;
UIPFILERR:  ;
            CALL ZQU_RPTXSAERR( FASTUI );
            DO ALTRET_HANDLING;
LOPAGEERR:     ;
               CALL ZQU_RPTCRNTERR;
               END;
            MAJOR_ERROR = %YES#;
            END;
         END;
      END;
 
 /***
  *** Build header for listing and DO output.
  ***/
 
   LISTHEADER.SIUIFIDSCHARS = ' ';
   CALL INDEX1( N, ' ', SIFID );        /* Length of SI fid         */
   IF N > LENGTHC( LISTHEADER.SIUIFIDS)
    THEN N = LENGTHC(LISTHEADER.SIUIFIDS);
   ADDR(LISTHEADER.SIUIFIDS)->NCHARS = SIFID$->NCHARS;
   T = N;                               /* Ix of next char          */
   IF UITHERE
    THEN DO;                            /* Must add UI fid          */
      IF T < LENGTHC(LISTHEADER.SIUIFIDS)
       THEN DO;                         /* Have room for '/'        */
         LISTHEADER.SIUIFIDS.C(T) = '/';
         T = T + 1;
         END;
      CALL INDEX1( N, ' ', UIFID );     /* Length of UI fid         */
      IF N + T > LENGTHC( LISTHEADER.SIUIFIDS)
       THEN N = LENGTHC(LISTHEADER.SIUIFIDS) - T; /* Truncate       */
      ADDR(LISTHEADER.SIUIFIDS.C(T))->NCHARS = UIFID$->NCHARS;
      T = T + N;
      END;
   WRITLOLISTHEADER.BUF_.BOUND = LENGTHV(LISTHEADER.TIMENDATE) + T;
   WRITDOLISTHEADER.BUF_ = VECTOR(LISTHEADER);
   WRITDOLISTHEADER.BUF_.BOUND = WRITLOLISTHEADER.BUF_.BOUND;
   DO_HEADER_NEEDED = %YES#;            /* Assume DO header needed  */
   IF LOWRIT
    THEN DO;                       /* Write header for list output  */
      LOHEADERHDR.TITL.TITLE# = LISTHEADERCHARS;
      LOHEADERHDR.TITL.L# = LENGTHC(LISTHEADERCHARS);
      CALL M$DEVICE( LOHEADER ) ALTRET( LOWRTERR );
      CALL M$CORRES( CORRESDOLO ) ALTRET( NODOHEADER );
      DO ALTRET_HANDLING;
NODOHEADER: ;                           /* LO and DO to same place  */
         DO_HEADER_NEEDED = %NO#;
         END;
      END;
 
   PAGE_AFTER_LINE = %NO#;    /* Don't page after record listed     */
 
 /***
  *** File formatting...loop: read, format, [write,] [list,] repeat.
  ***/
 
   CALL ZQU$INIT;             /* Initialize formatting routines     */
   NEXT_STAR_T = 0;
   STAR_T_NEEDED_NOW = %NO#;
   NEEDING_STAR_T = %YES#;              /* Assume will need *T*     */
   RECORD_NEEDED = %RN_YES;
   RESTORE_AFTER_STAR_T = %NO#;
   REGURGITATED = %NO#;
   FORMATTABLE_DECIDED = %NO#;
   UPDATE_NOT_INSERTED = %NO#;
   ALREADY_UPDATED = %NO#;
   ZQU_F_NO_SO_UPDATE = %NO#; /* This formatting option must be reset
      here instead of in ZQU_DEFAULT_OPTIONS because the output file
      might be affected by this option being left on from the previous
      file. */
 
   DO WHILE( NOT MAJOR_ERROR );
GET_NEXT_SIUI: ;
      IF COPYRIGHT_YEAR = 0
       THEN CALL ZQU_SIUIREAD ALTRET( CHKSIUIEOF );
       ELSE IF STAR_T_NEEDED_NOW
          THEN CALL ZQU_NEXT_STAR_T;
          ELSE IF RESTORE_AFTER_STAR_T
             THEN DO;                   /* *T* inserted             */
               REC = SAVREC;            /* Restore saved record     */
               FROMUI = SAVE_FROMUI;
               RECORD_NEEDED = %RN_YES;
               RESTORE_AFTER_STAR_T = %NO#; /* Done restoring       */
               REGURGITATED = %YES#;
               END;
             ELSE CALL ZQU_SIUIREAD ALTRET( CHKSIUIEOF );
 
      IF NOT FORMATTABLE_DECIDED
       THEN DO;          /* Decide how to format from first record  */
         IF OURECNBR <= 0
          THEN DO;
            IF F_PL1_CODE
             THEN FORMATTABLE = %YES#;  /* Must be formattable      */
             ELSE DO;    /* If *, !, ", or $ is first, don't format */
               CALL SEARCH( STAR_T_STARTX, T, NONBLANKTBL, REC$->RECORD.LISTREC.CHARS );
               STAR_T_PREFIX_STARTX = STAR_T_STARTX;
               STAR_T_SUFFIX_EXISTS = '0'B;
               IF STAR_T_STARTX = REC.RECLEN
                THEN FORMATTABLE = %YES#; /* Assume PL; nothing found */
                ELSE DO;
                  TEMP = REC.LISTREC.UBINX(STAR_T_STARTX);
                  IF TEMP = ASCBIN('*') OR TEMP = ASCBIN('!')
                    OR TEMP = ASCBIN('"') OR TEMP= ASCBIN('$')
                   THEN FORMATTABLE = %NO#;
                   ELSE FORMATTABLE = %YES#;
                  END;
               END;
            END;
         FORMATTABLE_DECIDED = %YES#;   /* Know if formattable      */
         END;
 
      IF FMT_TYPE = %DEFAULT_TYPE OR REGURGITATED
        OR (FMT_TYPE ~= %DEFAULT_TYPE AND RESTORE_AFTER_STAR_T)
        OR ( (NO_SOURCE_UPDATE AND ZQU_F_NO_SO_UPDATE) AND NOT ALREADY_UPDATED )
       THEN DO; /* Don't format if: 1) not supposed to, 2) generated *T*,
                or 3) not to update source */
         OUREC.RECLEN = REC.RECLEN;
         OUREC$->RECORD = REC$->RECORD;
         REGURGITATED = %NO#;
         END;
       ELSE DO;                         /* May need formatting      */
         IF FORMATTABLE
          THEN DO;                      /* Format record            */
            CALL ZQU$FORMAT( REC.RECLEN, REC.LISTREC.CHARS,
              OUREC.RECLEN, OUREC.LISTREC.CHARS, REC );
            END;
          ELSE DO;                      /* No formatting            */
            OUREC.RECLEN = REC.RECLEN;
            OUREC$->RECORD = REC$->RECORD;
            IF COPYRIGHT_YEAR > 0
             THEN DO;                   /* Check if needing *T*     */
               RECORD_NEEDED = %RN_YES; /* Assume record needed     */
               IF NEEDING_STAR_T
                THEN DO;                /* Check if *T* insertion   */
                  IF REC.RECLEN >= 3
                   THEN DO;        /* May be *M* or *T* already     */
                     CALL INDEX( I, '*', REC$->RECORD.LISTREC.CHARS );
                     IF I > REC.RECLEN - 3
                      THEN RECORD_NEEDED = %RN_WAIT_STAR_T;
                      ELSE DO;
                        TEMP$ = PINCRC( ADDR(REC.LISTREC.CHARS), I );
                        IF TEMP$->STAR_TYPE = '*M*' OR TEMP$->STAR_TYPE = '*m*'
                         THEN DO;
                           STAR_T_PREFIX = SUBSTR( REC$->RECORD.LISTREC.CHARS,
                             STAR_T_STARTX, I - STAR_T_STARTX );
                           STAR_T_STARTX = I;
                           IF SUBSTR( REC$->RECORD.LISTREC.CHARS, REC.RECLEN-1,
                             1 ) = '"' THEN STAR_T_SUFFIX_EXISTS = '1'B;
                           END;
                         ELSE IF TEMP$->STAR_TYPE = '*T*'
                             OR TEMP$->STAR_TYPE = '*t*'
                            THEN RECORD_NEEDED = %RN_NO;
                            ELSE RECORD_NEEDED = %RN_WAIT_STAR_T;
                        END;
                     END;
                   ELSE RECORD_NEEDED = %RN_WAIT_STAR_T;
                  END;
               END;
            END;
         IF COPYRIGHT_YEAR > 0
          THEN DO;                      /* Special *T* handling     */
            DO CASE( RECORD_NEEDED );
             CASE( %RN_YES );           /* Use current record       */
             CASE( %RN_NO );            /* Ignore current record    */
               GOTO GET_NEXT_SIUI;
             CASE( %RN_WAIT_STAR_T );   /* Wait 'til *T* output     */
               SAVREC = OUREC;          /* Save current record      */
               SAVE_FROMUI = FROMUI;
               STAR_T_NEEDED_NOW = %YES#;
               NEEDING_STAR_T = %NO#;   /* All done                 */
               RESTORE_AFTER_STAR_T = %YES#;
               GOTO GET_NEXT_SIUI;
             END;
            END;
         END;
      OURECNBR = OURECNBR + 1;
 
    /***
     *** Determine output (and listing) key.
     ***/
 
      DO CASE( OU_MAKEUP );
       CASE(%DEFAULT_MAKEUP);
         IF NOT UITHERE
          THEN IF SIORG = %KEYED#
             THEN DO;                   /* Use SI key               */
               OUKEY.L = SIKEY.L;
               OUKEY$->KEY = SIKEY$->KEY;
               END;
             ELSE OUKEY.L = 0;
          ELSE IF F_FORMAT_UPDATES_ONLY
             THEN IF UIORG = %KEYED#
                THEN DO;
                  OUKEY.L = UIKEY.L;
                  OUKEY$->KEY = UIKEY$->KEY;
                  END;
                ELSE OUKEY.L = 0;
             ELSE OUKEY.L = 0;
       CASE(%RTNUIKEYS_MAKEUP);
         IF UITHERE
          THEN DO;                      /* Retaining update keys    */
            IF FROMUI
             THEN DO;
               IF UIORG = %KEYED#
                THEN DO;                /* Use actual UI key        */
                  OUKEY.L = UIKEY.L;
                  OUKEY$->KEY = UIKEY$->KEY;
                  END;
                ELSE DO;                /* Make UI key              */
                  OUKEY.L = 3;
                  OUKEY.EDITKEY.VALUE = SIRECNBR * 1000 + UIPLUSNBR;
                  END;
               END;
             ELSE IF SIORG = %KEYED#
                THEN DO;                /* Use actual SI key        */
                  OUKEY.L = SIKEY.L;
                  OUKEY$->KEY = SIKEY$->KEY;
                  END;
                ELSE DO;                /* Construct OU key         */
                  OUKEY.L = 3;
                  OUKEY.EDITKEY.VALUE = SIRECNBR * 1000;
                  END;
            IF OURECNBR > 1
             THEN DO;                   /* Check for key overlap    */
               IF LASTOUKEY$->KEY >= OUKEY$->KEY
                THEN DO;                /* Overlap                  */
                  CALL ZQU_ERROR( %RTNUIKEYOVLP, REC );
                  IF LASTOUKEY$->KEY.L = 3 AND OUKEY$->KEY.L = 3
                   THEN DO;             /* Attempt recovery         */
                     OUKEY$->KEY = LASTOUKEY$->KEY;
                     OUKEY$->BASEDKEY.EDITKEY.VALUE = OUKEY$->BASEDKEY.EDITKEY.VALUE + 1;
                     END;
                  END;
               END;
            LASTOUKEY.L = OUKEY.L;      /* Save new last OU key     */
            LASTOUKEY$->KEY = OUKEY$->KEY;
            END;
          ELSE DO;                      /* Only SI file             */
            IF SIORG = %KEYED#
             THEN DO;                   /* Use SI key               */
               OUKEY.L = SIKEY.L;
               OUKEY$->KEY = SIKEY$->KEY;
               END;
             ELSE OUKEY.L = 0;
            END;
       CASE(%KEYED_MAKEUP);
         OUKEY.L = 3;
         OUKEY.EDITKEY.VALUE = OURECNBR * 1000;
       CASE(%CONSEC_MAKEUP);
         OUKEY.L = 0;
       END;
 
 
      IF NO_SOURCE_UPDATE AND NOT ZQU_F_NO_SO_UPDATE
        AND (FMT_TYPE = %DEFAULT_TYPE OR NOT FORMATTABLE)
       THEN DO;                         /* Look for *X* NSO         */
         CALL INDEX( I, '*X* NSO', OUREC$->RECORD.LISTREC.CHARS, 0 )
          WHENRETURN DO;
            ZQU_F_NO_SO_UPDATE = %YES#;
            END;
         END;
      IF OUWRIT
       THEN DO;                         /* Writing output file      */
         IF OUREC.RECLEN <= 0
          THEN WRITOU.BUF_ = VECTOR(NIL);
          ELSE DO;
            WRITOU.BUF_ = VECTOR(OUREC.LISTREC.CHARX);
            WRITOU.BUF_.BOUND = OUREC.RECLEN - 1;
            END;
         IF F_FORMAT_UPDATES_ONLY
          THEN DO;
            IF FROMUI
             THEN CALL XSA$WRITE( WRITOU, FASTOU ) ALTRET( OUWRTERR );
            END;
          ELSE IF NO_SOURCE_UPDATE AND ZQU_F_NO_SO_UPDATE
             THEN DO;
               IF ALREADY_UPDATED
                THEN DO;
                  CALL ZQU_ERROR( %UI_TO_OU, 0 );
                  MAJOR_ERROR = %YES#;
                  CALL M$ERR;
                  END;
               IF FROMUI
                THEN DO;
                  UPDATE_NOT_INSERTED = %YES#;
                  END;
                ELSE CALL XSA$WRITE( WRITOU, FASTOU ) ALTRET( OUWRTERR );
               CALL ZQU_SETNOUI;
               END;
             ELSE DO;
               CALL XSA$WRITE( WRITOU, FASTOU ) ALTRET( OUWRTERR );
               IF FROMUI THEN ALREADY_UPDATED = %YES#;
               END;
         END;
 
      DO ALTRET_HANDLING;
OUWRTERR: ;
         CALL ZQU_RPTXSAERR( FASTOU );
         MAJOR_ERROR = %YES#;
         END;
 
    /***
     *** Tell user where we are if requested.
     ***/
 
      IF WHERE_INCREMENT > 0
       THEN DO;
         IF MOD(OURECNBR,WHERE_INCREMENT) = 0
          THEN DO;                      /* Say where we are         */
            CALL ZQU_KEYTEXT( %CONSEC#, OURECNBR, OUKEY, WHEREBUF.OURECNBR );
            IF FROMUI
             THEN DO;
               WHEREBUF.UPLUS = '*';
               CALL ZQU_KEYTEXT( UIORG, UIRECNBR, UIKEY, WHEREBUF.RECKEY );
               END;
             ELSE DO;
               WHEREBUF.UPLUS = ' ';
               CALL ZQU_KEYTEXT( SIORG, SIRECNBR, SIKEY, WHEREBUF.RECKEY );
               END;
            CALL M$WRITE( WHEREME );
            END;
         END;
 
    /***
     *** List record if specified.
     ***/
 
      IF LIST_SOURCE
       THEN DO;                         /* List record              */
         IF OUORG ~= %KEYED#
          THEN DO;
            IF OU_MAKEUP = %CONSEC_MAKEUP
             THEN DO;         /* Just use sequential record number  */
               CALL ZQU_KEYTEXT( %CONSEC#, OURECNBR, OUKEY, OUREC.LISTREC.SEQRKEY );
               END;
             ELSE IF FROMUI
                THEN IF UIORG ~= %KEYED#
                   THEN DO;
                     OUKEY.EDITKEY.VALUE = PLUSSTART * 1000 + UIPLUSNBR;
                     OUKEY.L = 3;
                     CALL ZQU_KEYTEXT( %KEYED#, OURECNBR, OUKEY, OUREC.LISTREC.SEQRKEY );
                     OUREC.LISTREC.USTAR.C = ' '; /* Indicate manufactured key */
                     END;
                   ELSE CALL ZQU_KEYTEXT( %KEYED#, OURECNBR, UIKEY, OUREC.LISTREC.SEQRKEY);
                ELSE CALL ZQU_KEYTEXT( SIORG, SIRECNBR, SIKEY, OUREC.LISTREC.SEQRKEY );
            END;
          ELSE CALL ZQU_KEYTEXT( %KEYED#, OURECNBR, OUKEY, OUREC.LISTREC.SEQRKEY );
       /***
        *** List record.
        ***/
         WRITLO.BUF_ = VECTOR(OUREC.LISTREC);
         WRITLO.BUF_.BOUND = OUREC.RECLEN + %KEYCHARLEN + LENGTHV(REC.LISTREC.MID);
         IF FROMUI
          THEN OUREC.LISTREC.MID.UPLUS = '*';
          ELSE OUREC.LISTREC.MID.UPLUS = ' ';
         CALL M$WRITE( WRITLO ) ALTRET( LOWRTERR );
         IF PAGE_AFTER_LINE
          THEN DO;                      /* Page before write        */
            CALL M$DEVICE( PAGELO ) ALTRET( LOWRTERR );
            PAGE_AFTER_LINE = %NO#;
            END;
         DO ALTRET_HANDLING;
LOWRTERR:   ;
            CALL ZQU_RPTCRNTERR;
            MAJOR_ERROR = %YES#;
            END;
         END;
 
 /***
  *** If any major errors occurred, just return; proper error messages
  *** have already been given.
  ***/
 
      END;
 
CHKSIUIEOF: ; /* Assume eof (any error message has already been written) */
   IF UITHERE AND NO_SOURCE_UPDATE AND (ZQU_F_NO_SO_UPDATE OR NSO_ALL)
    THEN DO;                            /* Update NSO history file  */
      CALL M$YC(NSO_YES);
      CLOSOU.V.DISP# = %RELEASE#;
      IF NSO_ALL THEN EXIT;
      NSOREC.SIUIFIDSCHARS = LISTHEADER.SIUIFIDSCHARS;
      NSOREC.TIMENDATE = LISTHEADER.TIMENDATE;
      IF ALREADY_UPDATED
       THEN DO;          /* Some updates were put in source output  */
         CALL ZQU_ERROR( %UI_TO_OU, 0 );
         NSOREC.WARNING = '*** updated ***';
         END;
       ELSE NSOREC.WARNING = ' ';
      CALL M$WRITE( NSOHIST_UPDATE )
       WHENALTRETURN DO;
         IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$JRNLCLSD
          THEN DO;
            CALL M$CLOSE( CLOSNSOHIST );
            CALL M$OPEN( NSOHISTOPEN )
             WHENRETURN DO;
               CALL M$WRITE( NSOHIST_UPDATE )
                WHENALTRETURN DO;
                  CALL ZQU_RPTCRNTERR;
                  MAJOR_ERROR = %YES#;
                  END;
               END;
             WHENALTRETURN DO;
               CALL ZQU_RPTCRNTERR;
               MAJOR_ERROR = %YES#;
               END;
            END;
          ELSE DO;
            CALL ZQU_RPTCRNTERR;
            MAJOR_ERROR = %YES#;
            END;
         END;
      END;
 
   IF FMT_TYPE ~= %DEFAULT_TYPE
    THEN CALL ZQU$EOF;                  /* Tell formatting routines */
   RETURN;
 
END ZQU_FORMATFILE;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_NEXT_STAR_T: PROC;
/*F*     NAME: ZQU_NEXT_STAR_T
         PURPOSE: Return next *T* record.
 ***/
 
/********************/
 
   IF FORMATTABLE
    THEN DO;                            /* Use formattable *T*      */
      REC.RECLEN = LENGTHC(FORMATTABLE_STAR_T(NEXT_STAR_T));
      REC$->RECORD.LISTREC.CHARS = FORMATTABLE_STAR_T(NEXT_STAR_T);
      END;
    ELSE DO;                            /* Use BMAP-style *T*       */
      N = LENGTHC(FORMATTABLE_STAR_T(NEXT_STAR_T)) - 2;
      REC.RECLEN = N + STAR_T_STARTX;
      PINCRC( ADDR(REC$->RECORD.LISTREC.CHARS), STAR_T_STARTX )->NCHARS =
        PINCRC( ADDR(FORMATTABLE_STAR_T(NEXT_STAR_T)), 1 )->NCHARS;
      N = STAR_T_STARTX;
      ADDR(REC$->RECORD.LISTREC.CHARS)->NCHARS = ' ';
      N = STAR_T_STARTX - STAR_T_PREFIX_STARTX;
      IF N ~= 0
       THEN PINCRC( ADDR(REC$->RECORD.LISTREC.CHARS),
           STAR_T_PREFIX_STARTX )->NCHARS = STAR_T_PREFIX;
      IF STAR_T_SUFFIX_EXISTS
       THEN DO;
         CALL INSERT( REC$->RECORD.LISTREC.CHARS, REC.RECLEN, 1, '"');
         REC.RECLEN = REC.RECLEN + 1;
         END;
      END;
   IF NEXT_STAR_T = %FORMATTABLE_MAX_STAR_T
    THEN DO;                            /* End of *T* records       */
      NEXT_STAR_T = 0;
      STAR_T_NEEDED_NOW = %NO#;
      END;
    ELSE NEXT_STAR_T = NEXT_STAR_T + 1;
   FROMUI = %NO#;
   RETURN;
 
END ZQU_NEXT_STAR_T;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_CLOSEFILES: PROC;
/*F*     NAME: ZQU_CLOSEFILES
         PURPOSE: Close source, update, and object files.  (Leave
            list file and listing file open.)  Form feed LO if
            writing.
 ***/
 
/********************/
 
   IF M$SI$->F$DCB.FCD#
    THEN CALL XSA$CLOSE( CLOSSI, FASTSI ) ALTRET( SICLSERR );
   DO ALTRET_HANDLING;
SICLSERR: ;
      CALL ZQU_RPTXSAERR( FASTSI );
      END;
 
   IF M$UI$->F$DCB.FCD#
    THEN CALL XSA$CLOSE( CLOSUI, FASTUI ) ALTRET( UICLSERR );
   DO ALTRET_HANDLING;
UICLSERR: ;
      CALL ZQU_RPTXSAERR( FASTUI );
      END;
 
   IF DCBADDR(DCBNUM(M$OU))->F$DCB.FCD#
    THEN CALL XSA$CLOSE( CLOSOU, FASTOU ) ALTRET( OUCLSERR );
   DO ALTRET_HANDLING;
OUCLSERR: ;
      CALL ZQU_RPTXSAERR( FASTOU );
      END;
 
   IF LOWRIT
    THEN CALL M$DEVICE( PAGELO );
 
   RETURN;
 
END ZQU_CLOSEFILES;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_LISTFILEREAD: PROC ALTRET;
/*F*     NAME: ZQU_LISTFILEREAD
         PURPOSE: Reads next record from list file and opens necessary
            SI, UI, OU, and LO files.  The alternate return is taken
            if an error occurs reading the list file.  The return is
            taken only if files have been successfully opened.
 ***/
 
/********************/
 
 /***
  *** Get next record for which all necessary files can be opened.
  ***/
 
   DO TIL_ALTRET;
      CALL M$READ( LISTFILEREAD ) ALTRET( CHKLFEOF );
      LFRECNBR = LFRECNBR + 1;     /* One more list file record     */
      CALL ZQU_KEYTEXT( LFORG, LFRECNBR, LFKEY, LFREC.LISTREC.SEQRKEY);
      LFREC.RECLEN = DCBADDR(DCBNUM(F$LISTFILE))->F$DCB.ARS#;
      IF LFCOLUMN > LFREC.RECLEN
       THEN DO;                         /* Illegal list file record */
         CALL ZQU_ERROR( %LFRECILGL, LFREC );
         END;
       ELSE DO;
         I = LFCOLUMN - 1;              /* Find file name           */
         N = 0;               /* Accumlated length of file name     */
         DO WHILE( I < LFREC.RECLEN );
            T1 = LFREC.LISTREC.UBINX(I);
            IF T1 = ASCBIN(',') OR T1 <= ASCBIN(' ') OR T1 = ASCBIN(';')
             THEN I = LFREC.RECLEN;     /* Found char after name    */
             ELSE DO;
               N = N + 1;
               I = I + 1;
               END;
            END;
         IF N <= 0
          THEN DO;
            CALL ZQU_ERROR( %LFRECILGL, LFREC );
            END;
          ELSE DO;
            IF N > LENGTHC(FILENAME.NAME#)
             THEN CALL ZQU_ERROR( %LFFILENAMETOOLONG, LFREC );
             ELSE DO;
               FILENAME.L# = N;
               FILENAME.NAME# = ADDR(LFREC.LISTREC.UBINX(LFCOLUMN-1))->NCHARS;
               CALL ZQU_OPENFILES ALTRET( NOFILE );
               RETURN;
               END;
            END;
         END;
 
NOFILE: ;
      CALL ZQU_ERROR( %LFCANTPROCESS, LFREC );
      CALL ZQU_CLOSEFILES;              /* Close opened files       */
      MAJOR_ERROR = %NO#;
      END                               /* DO TIL_ALTRET */;
 
 /***
  *** Error reading list file...better be end of file.
  ***/
 
CHKLFEOF: ;
   IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF THEN ALTRETURN;
   CALL ZQU_RPTCRNTERR;
   IF LFRECNBR = 0
    THEN CALL ZQU_ERROR( %CANTREADLF );
    ELSE CALL ZQU_ERROR( %LFREADERR, LFREC );
   STEPCCFPT.V.STEPCC# = STEPCC;
   CALL M$EXIT;
 
END ZQU_LISTFILEREAD;
/********************************************************************/
%EJECT;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_SIUIREAD: PROC ALTRET;
/*F*     NAME: ZQU_SIUIREAD
         PURPOSE: Performs source/update packet read.
 ***/
 
/********************/
 
 /***
  *** Successive plus cards must be as follows:
  ***
  ***  +i          +i          +i,j          +i,j
  ***  +k          +k,l        +k            +k,l
  ***
  ***  i<k         i<k<=l      i<=j<=k       i<=j<k<=l
  ***
  ***  +* means that the plus card is a comment and is to be ignored
  ***
  ***  +0 means insert before the beginning of the source
  ***
  ***/
 
   DO TIL_ALTRET;
 
    /***
     *** Continue reading from source unless next read is to be
     *** from the update packet or there's no source left.
     ***/
 
      IF NOT (UINEXT OR SIEOF)
       THEN DO;                         /* Continue reading source  */
         CALL XSA$READ( READSI, FASTSI ) ALTRET( CHKSIEOF );
         REC.RECLEN = FASTSI.ARS#;
         SIRECNBR = SIRECNBR + 1;
 
       /***
        *** If the current source record number is the same as the
        *** beginning of replacement range or insertion point,
        *** the update packet file must be read next.
        ***/
 
         IF SIRECNBR >= PLUSSTART
          THEN DO;
            UINEXT = %YES#;             /* Read UI record next      */
            UIPLUSNBR = 0;         /* Reset update insertion count  */
            END;
 
       /***
        *** Return the current source record if it is before the next
        *** replacement range or insertion point or if it is the last
        *** source record before the insertion point.
        ***/
 
         IF SIRECNBR < PLUSSTART   /* Before beginning of range     */
           OR (SIRECNBR = PLUSSTART AND PLUSEND < 0)
                              /* At last source before insertion    */
          THEN DO;                      /* Return source record     */
            CALL ZQU_KEYTEXT( SIORG, SIRECNBR, SIKEY, REC.LISTREC.SEQRKEY );
            REC.LISTREC.MID.UPLUS = ' '; /* Not update              */
            FROMUI = %NO#;
            RETURN;
            END;
 
       /***
        *** The current source record is the first of a range of
        *** records to replace.   Bypass all source records within the
        *** range.
        ***/
 
         ALREADY_UPDATED = %YES#;
         DO WHILE(SIRECNBR < PLUSEND);
            CALL XSA$READ( READSI, FASTSI ) ALTRET( EARLYSIEOF );
            SIRECNBR = SIRECNBR + 1;
            END;
 
         END                        /* IF NOT (UINEXT OR SIEOF) */;
 
    /***
     *** SI read error handling.
     ***/
 
      DO ALTRET_HANDLING;
EARLYSIEOF: ;
         T = 0;
         GOTO SIEOFCHK;
CHKSIEOF: ;
         T = 1;
SIEOFCHK: ;
         IF FASTSI.ERR.CODE ~= %E$EOF
          THEN DO;                      /* Unknown error            */
            MAJOR_ERROR = %YES#;
            CALL ZQU_RPTXSAERR( FASTSI );
            ALTRETURN;
            END;
         SIEOF = %YES#;
         IF T = 0
          THEN DO;                      /* Unexpected SI eof        */
            CALL ZQU_ERROR( %SIEOFNOTRNG, LASTPLUSCARDREC );
            END;
          ELSE DO;            /* Check if looking for plus start    */
            IF UIREAD AND (NOT UIEOF AND SIRECNBR < PLUSSTART)
             THEN DO;         /* Source ended before start of range */
               CALL ZQU_ERROR( %SIEOFBFRRNG, LASTPLUSCARDREC );
               END;
            END;
         IF UIREAD
          THEN DO;
            IF UIEOF
             THEN ALTRETURN;            /* Return with EOF error    */
             ELSE UINEXT = %YES#;
            END;
          ELSE ALTRETURN;               /* Return with EOF error    */
         END;
 
    /***
     *** We fall to here if 1) a range of source records to be replaced
     *** was bypassed or 2) update insertion records are to read.
     *** We can only get here if an update file is being read.  Otherwise
     *** PLUSSTART is set to a very large number which will always cause
     *** source to be exhausted.  UINEXT must be set.
     ***/
 
      DO WHILE(UINEXT AND NOT UIEOF);
         CALL XSA$READ( READUI, FASTUI ) ALTRET( CHKUIEOF );
         UIRECNBR = UIRECNBR + 1;
         REC.RECLEN = FASTUI.ARS#;
         CALL ZQU_KEYTEXT( UIORG, UIRECNBR, UIKEY, REC.LISTREC.SEQRKEY );
         REC.LISTREC.MID.UPLUS = '+';   /* Indicate update          */
 
       /***
        *** Return update record if it is not a plus card.
        ***/
 
         IF REC.RECLEN < 1              /* Null record              */
           OR (REC.RECLEN >= 1 AND REC.LISTREC.UBINX(0) ~= ASCBIN('+'))
                                        /* Not plus card            */
          THEN DO;                      /* Return update record     */
            UIPLUSNBR = UIPLUSNBR + 1;  /* One more inserted        */
            FROMUI = %YES#;
            RETURN;
            END;
 
       /***
        *** We now have some type of plus card.  If specified, write
        *** it to update file. If only '+', plus card
        *** format error.  If plus comment, ignore it.
        ***/
 
         IF F_FORMAT_UPDATES_ONLY
          THEN DO;                      /* Write plus card          */
            WRITEUI.BUF_.BOUND = REC.RECLEN - 1;
            IF OUWRIT
             THEN CALL XSA$WRITE( WRITEUI, FASTOU ) ALTRET( WRITOUERR );
            END;
 
         IF REC.RECLEN < 2 THEN GOTO PLUSFMTERR; /* Only '+'        */
         T1 = REC.LISTREC.UBINX(1);     /* Next char                */
         IF T1 < ASCBIN('0') OR T1 > ASCBIN('9')
          THEN DO;            /* Not first digit of start range     */
            IF T1 ~= ASCBIN('*')
             THEN DO;                   /* Might be +END            */
               IF REC.LISTREC.PLUSEND.CS = 'END'
                THEN DO;                /* End of update packet     */
                  UIEOF = %YES#;
                  IF SIEOF THEN ALTRETURN; /* All done; both files ended */
                  CALL ZQU_SETNOUI;     /* Stop reading UI          */
                  END;
                ELSE GOTO PLUSFMTERR;
               END;
             ELSE ;                     /* Plus comment             */
            END;
          ELSE DO;                 /* First digit of start range    */
            I = 2;                      /* Index of next char       */
            T1 = T1 - ASCBIN('0');      /* Init number accumulator  */
            T2 = -1;                    /* No end of range yet      */
            DO WHILE(I < REC.RECLEN );
               T = REC.LISTREC.UBINX(I);
               IF T >= ASCBIN('0') AND T <= ASCBIN('9')
                THEN DO;
                  T1 = T1 * 10 + T - ASCBIN('0');
                  I = I + 1;
                  END;
                ELSE DO;           /* Probably end range follows    */
                  IF T = ASCBIN(' ')
                   THEN I = REC.RECLEN; /* No end range...insertion */
                   ELSE DO;
                     I = I + 1;         /* Index of next char       */
                     IF T ~= ASCBIN(',') OR I >= REC.RECLEN
                      THEN GOTO PLUSFMTERR; /* Illegal plus card    */
                     T2 = REC.LISTREC.UBINX(I) - ASCBIN('0'); /* Get next char */
                     IF T2 < 0 OR T2 > 9
                      THEN GOTO PLUSFMTERR;
                     I = I + 1;
                     DO WHILE(I < REC.RECLEN );
                        T = REC.LISTREC.UBINX(I);
                        IF T >= ASCBIN('0') AND T <= ASCBIN('9')
                         THEN DO;
                           T2 = T2 * 10 + T - ASCBIN('0');
                           I = I + 1;
                           END;
                         ELSE DO;       /* Non-digit                */
                           IF T ~= ASCBIN(' ') THEN GOTO PLUSFMTERR;
                           I = REC.RECLEN;
                           END;
                        END   /* DO WHILE(I < REC.RECLEN) */;
                     END;
                  END;
               END                  /* DO WHILE(I < REC.RECLEN) */;
 
          /***
           *** Check for semantically illegal plus card.
           ***/
 
            LASTPLUSCARDREC.RECLEN = REC.RECLEN;
            LASTPLUSCARDREC$->RECORD = REC$->RECORD; /* Save last plus card */
            IF T2 ~= -1
             THEN DO;              /* New plus card is replacement*/
               IF T1 = 0
                THEN DO;                /* +0,x - change 0 to 1     */
                  CALL ZQU_ERROR( %PLUSILGLRNGSTRT, REC );
                  T1 = 1;
                  END;
               IF T2 < T1
                THEN DO;           /* Illegal range specification   */
                  CALL ZQU_ERROR( %PLUSILGLRNG, REC );
                  PLUS_ERROR = %YES#;
                  END;
               END;
            IF PLUSEND = -1
             THEN DO;                   /* Previous was insert*/
               IF T1 <= PLUSSTART
                THEN DO;                /* Overlap*/
                  IF T2 = -1
                   THEN CALL ZQU_ERROR( %PLUSINSINSOVLP, REC );
                   ELSE CALL ZQU_ERROR( %PLUSINSREPOVLP, REC );
                  PLUS_ERROR = %YES#;
                  END;
               END;
             ELSE DO;                   /* Previous was replace     */
               IF T2 = -1
                THEN IF T1 < PLUSEND
                   THEN DO; /* Current insert overlaps previous replacement */
                     CALL ZQU_ERROR( %PLUSREPINSOVLP, REC );
                     PLUS_ERROR = %NO#;
                     END;
                   ELSE ;
                ELSE IF T1 <= PLUSEND
                   THEN DO; /* Current replacement overlaps previous replacement */
                     CALL ZQU_ERROR( %PLUSREPREPOVLP, REC );
                     PLUS_ERROR = %NO#;
                     END;
                   ELSE ;
               END;
 
          /***
           *** Save plus range values and determine if next read should
           *** come from SI or UI if no plus card error.
           ***/
 
            IF NOT PLUS_ERROR
             THEN DO;                   /* Use next plus card       */
               PLUSSTART = T1;
               PLUSEND = T2;
 
               IF SIRECNBR < PLUSSTART
                THEN DO;                /* Read SI next?            */
                  IF SIEOF
                   THEN DO;             /* SI already ended         */
                     UINEXT = %YES#;
                     CALL ZQU_ERROR( %SIEOFALREADY, REC );
                     END;
                   ELSE UINEXT = %NO#;
                  END;
                ELSE DO;           /* Immediately following updates */
                  UINEXT = %YES#;
                  UIPLUSNBR = 0;
                  END;
               END;
             ELSE PLUS_ERROR = %NO#;    /* Reset for next UI read   */
            END;
 
       /***
        *** Plus card format error handling.
        ***/
 
         DO ALTRET_HANDLING;
PLUSFMTERR: ;
            CALL ZQU_ERROR( %PLUSILGLFMT, REC );
            END;
 
       /***
        *** Update file read error handling.
        ***/
 
         DO ALTRET_HANDLING;
CHKUIEOF:   ;
            IF FASTUI.ERR.CODE ~= %E$EOF
             THEN DO;                   /* Unknown error            */
               MAJOR_ERROR = %YES#;
               CALL ZQU_RPTXSAERR( FASTUI );
               ALTRETURN;
               END;
            UIEOF = %YES#;
            IF SIEOF THEN ALTRETURN;    /* Return with EOF error    */
            CALL ZQU_SETNOUI;           /* Indicate no UI to read   */
            END;
         END                  /* DO WHILE(UINEXT AND NOT UIEOF) */;
      END                               /* DO TIL_ALTRET */;
 
WRITOUERR: ;
   MAJOR_ERROR = %YES#;
   CALL ZQU_RPTXSAERR( FASTOU );
   ALTRETURN;
 
END ZQU_SIUIREAD;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_KEYTEXT: PROC( FORG, FRECNBR, FKEY, FKEYTEXT );
/*F*     NAME: ZQU_KEYTEXT
         PURPOSE: Converts file key to text depending on file
            organization and current record number.
 ***/
 
DCL FORG SBIN;                          /* File organization        */
DCL FRECNBR SBIN;                       /* Current record number    */
%KEYFMT(FPTN=FKEY,STCLASS="");          /* Current record key       */
DCL 1 FKEYTEXT,                         /* Returned key text        */
      2 CS CHAR(%KEYCHARLEN) UNAL,
      2 CCS REDEF CS UNAL,
        3 SEQ CHAR(%SEQCHARLEN) UNAL,
        3 DOT CHAR(1) UNAL,
        3 FRAC CHAR(3) UNAL;
 
 /***
  *** Locals:
  ***/
 
DCL KEYCHARS CHAR(%(KEYCHARLEN-1)) STATIC; /* Key chars to be formatted */
DCL SEQCHARS CHAR(%SEQCHARLEN) STATIC;  /* Sequence number chars    */
 
 /***
  *** Local CONSTANT:
  ***/
 
DCL NO4ZS(0:2) BIT(9) CONSTANT UNAL INIT( %MVZB4, %SES10, %MVC1 );
DCL NO5ZSPF(0:3) BIT(9) CONSTANT UNAL INIT( %MVZB5, %SES10, %INSB7, %MVC3 );
 
/********************/
 
 /***
  *** If file is not keyed or key is not EDIT compatible, just use
  *** the current record's sequence number.
  ***/
 
   IF FORG ~= %KEYED# OR (FORG = %KEYED# AND FKEY.L > 3)
    THEN DO;                       /* Use record sequence number    */
      CALL BINCHAR( SEQCHARS, FRECNBR );
      FKEYTEXT.CS = ' ';                /* Blank out receiver       */
      CALL EDITCHAR( FKEYTEXT.CCS.SEQ, , , NO4ZS, SEQCHARS );
      END;
    ELSE DO;                            /* Use EDIT key             */
      CALL BINCHAR( KEYCHARS, FKEY.EDITKEY.VALUE );
      CALL EDITCHAR( FKEYTEXT.CS, , , NO5ZSPF, KEYCHARS );
      END;
   RETURN;
 
END ZQU_KEYTEXT;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_ERROR: PROC( ERRNBR, ERRREC );
/*F*     NAME: ZQU_ERROR
         PURPOSE: Print error with specified error number and
            specified listing line.
 ***/
 
 /***
  *** Parameters:
  ***/
 
DCL ERRNBR SBIN;                        /* Error number             */
%RECFMT(FPTN=ERRREC,STCLASS="");
 
/********************/
 
   IF DO_HEADER_NEEDED
    THEN DO;                       /* Indicate erring file names    */
      IF LFREAD
       THEN DO;                         /* Space between files      */
         WRITDO.BUF_ = VECTOR(BLANK);
         CALL M$WRITE( WRITDO );
         CALL M$WRITE( WRITDO );
         END;
      CALL M$WRITE( WRITDOLISTHEADER );
      DO_HEADER_NEEDED = %NO#;
      END;
 
   IF ADDR(ERRREC) ~= ADDR(NIL)
    THEN DO;             /* Will print record also...use blank line */
      WRITDO.BUF_ = VECTOR(BLANK);      /* Preceed with blank line  */
      CALL M$WRITE( WRITDO );
      END;
 
   WRITDO.BUF_ = VECTOR(ERRMSGS(ERRNBR));
   CALL M$WRITE( WRITDO );
 
   IF ERRSTEPCCS(ERRNBR) > STEPCC
    THEN STEPCC = ERRSTEPCCS(ERRNBR);
 
   IF ADDR(ERRREC) = ADDR(NIL) THEN RETURN;
 
   WRITDO.BUF_ = VECTOR(ERRREC.LISTREC); /* Now print listing record */
   WRITDO.BUF_.BOUND = ERRREC.RECLEN + %KEYCHARLEN + LENGTHV(REC.LISTREC.MID);
   CALL M$WRITE( WRITDO );
 
   RETURN;
 
END ZQU_ERROR;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_XBUFERR: PROC( ERRNBR, HI_CHAR );
/*F*     NAME: ZQU_XBUFFER
         PURPOSE: Report error in X buffer.
 ***/
 
 /***
  *** Parameters:
  ***/
 
DCL ERRNBR SBIN;                        /* Error number             */
DCL HI_CHAR SBIN;                       /* Highest char position ok */
 
/********************/
 
   WRITDO.BUF_ = VECTOR(BLANK);
   CALL M$WRITE( WRITDO );
 
   WRITDO.BUF_ = VECTOR(ERRMSGS(ERRNBR));
   CALL M$WRITE( WRITDO );
 
   IF ERRSTEPCCS(ERRNBR) > STEPCC
    THEN STEPCC = ERRSTEPCCS(ERRNBR);
 
   IF HI_CHAR <= 0
    THEN WRITDO.BUF_ = VECTOR(BLANK);
    ELSE DO;                       /* Show X buffer error point     */
      WRITDO.BUF_ = VECTOR(XBUFFER);
      WRITDO.BUF_.BOUND = HI_CHAR - 1;
      END;
   CALL M$WRITE( WRITDO );
 
   RETURN;
 
END ZQU_XBUFERR;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_RPTCRNTERR: PROC;
/*F*     NAME: ZQU_RPTCRNTERR
         PURPOSE: Report error contained in ALTRET frame.
 ***/
 
/********************/
 
   RPTCRNTERR.V.DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
   CRNTERR = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
   CRNTERR.SEV = 0;                     /* Use level 0 message      */
   CALL M$ERRMSG( RPTCRNTERR );
   RETURN;
 
END ZQU_RPTCRNTERR;
/********************************************************************/
%EJECT;
/********************************************************************/
ZQU_RPTXSAERR: PROC( XSAPARAM );
/*F*  NAME: ZQU_RPTXSAERR
      PURPOSE: Report error contained in XSA_PARAM block.
 ***/
 
 /***
  *** Parameters:
  ***/
 
%XSA_PARAM(FPTN=XSAPARAM,
   STCLASS="");
 
/********************/
 
   RPTCRNTERR.V.DCB# = XSAPARAM.DCB#;
   CRNTERR = XSAPARAM.ERR;
   CRNTERR.SEV = 0;
   CALL M$ERRMSG( RPTCRNTERR );
   RETURN;
 
END ZQU_RPTXSAERR;
/********************************************************************/
%EJECT;
/********************************************************************/
END FORMAT_SI61;
%EOD;
/*M* ZQU$INTHANDLER - break handler for PL-6 formatter */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
ZQU$INTHANDLER: PROC ASYNC;
 
/*F*     NAME: ZQU$INTHANDLER
         PURPOSE: Sets break (interrupt) flag for PL-6 formatter.
 ***/
 
 /***
  *** INCLUDE files:
  ***/
 
%INCLUDE CP_6;
 
 /***
  *** SYMREFs:
  ***/
 
DCL ZQU$BREAKFLAG SBIN SYMREF;
 
/********************/
 
   ZQU$BREAKFLAG = ZQU$BREAKFLAG + 1;   /* Another break            */
   CALL M$TRTN;
 
END ZQU$INTHANDLER;
/********************************************************************/
