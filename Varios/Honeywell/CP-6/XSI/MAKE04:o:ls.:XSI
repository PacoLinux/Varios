

rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=1  
A        1         1             /*M*    make_derive:c  --    determine derivation of major target   */
A        2         2             /*T***********************************************************/
A        3         3             /*T*                                                         */
A        4         4             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
A        5         5             /*T*                                                         */
A        6         6             /*T***********************************************************/
A        7         7
A        8         8             #include   "MAKE_Cc14"
A        9         9             #include   <stdlib.h>
A       10        10             #include   <b$jit_c.h>
A       11        11             #include   <string.h>
A       12        12
A       13        13             /*F*    NAME:          make_derive
A       14        14                     PURPOSE:       To determine the steps involved to produce
A       15        15                                 the specified target.
A       16        16                     DESCRIPTION:
A       17        17                        This function produces two lists and temporarily creates
A       18        18                        and uses a third.  The temporary list is used so save
A       19        19                        memory, we could use recursive calls to make_derive but
A       20        20                        that would waste auto-space.
A       21        21
A       22        22                        The result of this function is a list of targets which were
A       23        23                        more recent than the target we are building and this
A       24        24                        function adds pointers to the "struct target_action"'s
A       25        25                        required to build the main target.
A       26        26
A       27        27                        The major data structures used are:
A       28        28
A       29        29                        1. "struct derive_list *(dl[])" which points to a temporary
A       30        30                           table allocated to hold information instead of using
A       31        31                           recursion.  This table is indexed by the recursion level
A       32        32                           and contains the current dependancy list, the position
A       33        33                           in that list and the index in the early target list that
A       34        34                           corresponds to the first entry associated with this
A       35        35                           target.
A       36        36
A       37        37                        2. "struct sym_target **ChangedTargets" which points to an
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=2  
A       38        38                           array of pointers to the targets which were more recent
A       39        39                           than the target.  This information is used to provide
A       40        40                           the "$?" macro value.
A       41        41
A       42        42                        3. "struct target_action *a" which holds the information
A       43        43                           necessary to build the target.  This structure holds
A       44        44                           the jcl, input and output files and information on
A       45        45                           the entries in ChangedTargets that would be necessary
A       46        46                           to expand if the jcl references the "$?" function.
A       47        47
A       48        48             */
A       49        49
A       50        50             struct derive_list  {
A       51        51    1          struct   dependancy  *dl_depend;
A       52        52    1          int                   dl_index;
A       53        53    1          int                   dl_early;
A       54        54    1          timetype              dl_modtime;
A       55        55    1          };
A       56        56
A       57        57             extern char *fid_acct();
A       58        58
A       59        59             struct  derive_list *dl = 0;
A       60        60             unsigned            dl_size  = 0;
A       61        61             unsigned            dl_i     = 0;
A       62        62
A       63        63             #define             DL_ALLOC 10
A       64        64
A       65        65             struct  sym_target  **ChangedTargets = 0;
A       66        66             unsigned            ChangeTableSize  = 0;
A       67        67
A       68        68             #define ALLOC_NUM      64
A       69        69             struct target_action   *target_action_head = 0;
A       70        70
A       71        71             unsigned            ChangeTableI     = 0;
A       72        72
A       73        73             struct  sym_target  fake_targets[8];  /** Temp pseudo-targets **/
A       74        74             struct  file_info   file_names  [8];  /** Temp file information **/
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=3  
A       75        75             static  int         last_file        = 0;
A       76        76
A       77        77
A       78        78             int
A       79        79             derive(tg, LS_width, debug, verbose)
A       80        80               struct sym_target *tg;
A       81        81               int               LS_width;
A       82        82               int               debug;
A       83        83               int               verbose;
A       84        84             {
A       85        85    1          timetype          early_start;
A       86        86    1          timetype          late_modtime;
A       87        87    1          int               i;
A       88        88    1          int               k;
A       89        89    1          int               w_p;
A       90        90    1          struct dependancy *d;
A       91        91    1          struct sym_target *new_file();
A       92        92    1          struct target_action *a;
A       93        93    1          int                flg;
A       94        94    1        timetype            derive_target();
A       95        95    1        timetype            derive_targets();
A       96        96    1
A       97        97    1          if (tg->tg_status > STATUS_UNUSED) return 0;
A       98        98    1        start:
A       99        99    1          early_start = ChangeTableI;
A      100       100    1          late_modtime = BEGINNING_OF_TIME;
A      101       101    1          i = 0;
A      102       102    1          d = tg->tg_depend;
A      103       103    1
A      104       104    1          tg->tg_status = STATUS_BUSY;
A      105       105    1
A      106       106    1        resume:
A      107       107    1          while (d)   {
A      108       108    2             if (B$JIT$->active.jit)   {
A      109       109    3                char cb[120];
A      110       110    3                static int cci = 1;
A      111       111    3                if (cci) {
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=4  
A      112       112    4                   memset(B$JIT$->ccbuf, ' ', sizeof(B$JIT$->ccbuf));
A      113       113    4                   cci = 0;
A      114       114    4                   }
A      115       115    3                sprintf(cb, "make targets=%d %s",
A      116       116    3                        TargetActionNum,
A      117       117    3                        tg->tg_text );
A      118       118    3                memcpy(B$JIT$->ccbuf, cb, strlen(cb));
A      119       119    3                }
A      120       120    2             for (; i<d->dp_num ; i++)  {
A      121       121    3                struct sym_target *t = d->dp_list[i];
A      122       122    3
A      123       123    3                if (t->tg_status == STATUS_UNUSED)  {
A      124       124    4                   tg->tg_status = STATUS_BUSY;
A      125       125    4                   if (dl_i >= dl_size) {
A      126       126    5                      k = (dl_size += DL_ALLOC) * sizeof(struct derive_list);
A      127       127    5                      dl = (struct derive_list *) realloc(dl, k);
A      128       128    5                      if (!dl) crash("Out of Memory: Derive_Target\n");
A      129       129    5                      }
A      130       130    4                   dl[dl_i].dl_depend    = d;
A      131       131    4                   dl[dl_i].dl_index     = i;
A      132       132    4                   dl[dl_i].dl_early     = early_start;
A      133       133    4                   dl[dl_i].dl_modtime   = late_modtime;
A      134       134    4                   tg = t;
A      135       135    4                   dl_i++;
A      136       136    4                   goto start;
A      137       137    4                   }
A      138       138    3                else if (t->tg_status == STATUS_BUSY)  {
A      139       139    4                   k = dl_i;
A      140       140    4                   warning("### Loop in dependancy list for \"%s\"\n",tg->tg_text);
A      141       141    4                   printf ("#   Traceback: %s",t->tg_text), w_p=t->tg_len+15;
A      142       142    4                   while (k>0 && ((t = dl[--k].dl_depend->dp_target)!=d->dp_target)) {
A
A      143       143    5                      if (w_p+t->tg_len >LS_width)
A      144       144    5                         printf("\n#              "), w_p = 15;
A      145       145    5                      printf(" -> %s",t->tg_text), w_p += 4+t->tg_len;
A      146       146    5                      }
A      147       147    4                   printf("\n");
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=5  
A      148       148    4                   }  /* end of busy target */
A      149       149    3                else late_modtime = MAX(late_modtime,t->tg_modtime), late_modtime = MA
A                               X(late_modtime, t->tg_umodtime);
A      150       150    3                }     /* end of for loop    */
A      151       151    2             d = d->dp_tgdepend, i = 0;
A      152       152    2             }        /* end of while loop  */
A      153       153    1
A      154       154    1          if (debug) {
A      155       155    2             printf("\n  *Deriving: %s",tg->tg_text), w_p = 13 + tg->tg_len;
A      156       156    2             k = dl_i;
A      157       157    2             while (k)   {
A      158       158    3                struct sym_target *t = dl[--k].dl_depend->dp_target;
A      159       159    3                if (w_p + t->tg_len > LS_width)
A      160       160    3                   printf("\n             "), w_p = 13;
A      161       161    3                printf(" %s",t->tg_text), w_p += 1+ t->tg_len;
A      162       162    3                }
A      163       163    2             printf("\n");
A      164       164    2             }
A      165       165    1
A      166       166    1          if (tg->tg_action) goto exit;
A      167       167    1          last_file      = 0;
A      168       168    1          find_file(tg, &file_names[ 0 ], 0, 1);
A      169       169    1          new_file (tg, &file_names[ 0 ], debug, 0);
A      170       170    1          tg->tg_srch = file_names[0].fi_srch;
A      171       171    1
A      172       172    1          if (!tg->tg_action)
A      173       173    1          if ( !tg->tg_phony && (!tg->tg_commands ||
A      174       174    1              (tg->tg_commands->tr_commands->cm_flags&(MC_SI|MC_SI_FILE|MC_SI_ACCT))))
A
A      175       175    1                early_start = derive_target(tg, late_modtime, debug, verbose);
A      176       176    1             else if (tg->tg_commands || !tg->tg_phony)
A      177       177    1                early_start = derive_targets(tg, late_modtime, debug);
A      178       178    1
A      179       179    1
A      180       180    1
A      181       181    1          if (tg->tg_status != STATUS_COMPLETED && (a = tg->tg_action) &&
A      182       182    1             (a->ta_rule) &&
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=6  
A      183       183    1             (flg = a->ta_rule->tr_commands->cm_flags &
A      184       184    1                (MC_EARLIER | MC_PREDECESSOR | MC_DEPENDENT)     ) )   {
A      185       185    2             if (!a->ta_predvar && (flg & MC_PREDECESSOR))
A      186       186    2                build_predecessor_list(tg);
A      187       187    2
A      188       188    2             if (!a->ta_chngvar && (flg & MC_EARLIER))
A      189       189    2                build_changed_list(tg);
A      190       190    2
A      191       191    2             if (!a->ta_dpndvar && (flg & MC_DEPENDENT))
A      192       192    2                build_dependent_list(tg);
A      193       193    2             }
A      194       194    1
A      195       195    1        exit:
A      196       196    1          if (dl_i)   {
A      197       197    2             dl_i--;
A      198       198    2             d            = dl[dl_i].dl_depend;
A      199       199    2             i            = dl[dl_i].dl_index;
A      200       200    2             early_start  = dl[dl_i].dl_early;
A      201       201    2             late_modtime = MAX(late_modtime, dl[dl_i].dl_modtime);
A      202       202    2             tg           = d->dp_target;
A      203       203    2             goto resume;
A      204       204    2             }
A      205       205    1
A      206       206    1          if (dl_size)   {
A      207       207    2             free(dl), dl_size = 0, dl = 0;
A      208       208    2             }
A      209       209    1
A      210       210    1          return Errors;
A      211       211    1        }
A      212       212
A      213       213
A      214       214
A      215       215
A      216       216             /*D*    NAME:       build_target(tg, ft);
A      217       217                     PURPOSE:    To return a pointer to a "struct sym_target" which
A      218       218                              corresponds to the base file name in "tg" with the
A      219       219                              file type indicated by "ft".
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=7  
A      220       220             */
A      221       221
A      222       222
A      223       223             struct sym_target *
A      224       224             build_target(tg, ft)
A      225       225               struct sym_target *tg;
A      226       226               struct sym_ftype  *ft;
A      227       227             {
A      228       228    1          struct file_info  *fi = &file_names[last_file];
A      229       229    1          struct sym_target *t;
A      230       230    1          char               buf[80];
A      231       231    1          int                i = tg->tg_len - tg->tg_suffix_len;
A      232       232    1          int                j = ft->ft_len;
A      233       233    1          int                tgl;
A      234       234    1
A      235       235    1          if (tg->tg_ftype == ft) return tg;     /* Already got it! */
A      236       236    1
A      237       237    1          if (i > 31)
A      238       238    1             crash("### Target name \"%s\" is too long for CP-6 fid\n",tg->tg_text);
A      239       239    1
A      240       240    1          memcpy(buf, tg->tg_text, i);
A      241       241    1          buf[i] = '.';
A      242       242    1          if ((j+i+2) > 63)
A      243       243    1             error("### File type+ \"%s\" is too long, max size=31\n", tg->tg_text), j
A                               =31;
A      244       244    1          memcpy(&buf[i+1], ft->ft_text, j);
A      245       245    1          buf[tgl = i + 1 + j] = 0;
A      246       246    1
A      247       247    1          t = lookup_sym_target(buf,tgl,0);
A      248       248    1          if (t) return t;
A      249       249    1
A      250       250    1          memcpy(fi->fi_tgtext, buf, tgl+1);
A      251       251    1          t = &fake_targets[ last_file ];
A      252       252    1          *t = init_sym_target;
A      253       253    1          t->tg_len = tgl;
A      254       254    1          t->tg_suffix_len = j+1;
A      255       255    1          t->tg_text = fi->fi_tgtext;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=8  
A      256       256    1          t->tg_ftype = ft;
A      257       257    1          return t;
A      258       258    1        }
A      259       259
A      260       260
A      261       261
A      262       262
A      263       263             /*D*    NAME:       new_file(tg, fi, debug, sif)
A      264       264                     PURPOSE:    To add filename information to the specified
A      265       265                                 target.
A      266       266                     DESCRIPTION:
A      267       267                        This may not be a "real" target.  When looking for an
A      268       268                        input file, a "fake" target is allocated when build
A      269       269                        target is creating a target type that doesn't currently
A      270       270                        exist.  This routine must turn this fake target into
A      271       271                        a true "struct sym_target" so that we will find this
A      272       272                        later when looking for this filename.
A      273       273             */
A      274       274
A      275       275             struct sym_target *
A      276       276             new_file(tg, fi, debug, sif)
A      277       277               struct sym_target *tg;
A      278       278               struct file_info  *fi;
A      279       279               int                debug;
A      280       280               int                sif;
A      281       281             {
A      282       282    1          char              *ctime();
A      283       283    1          char              *alloc_text();
A      284       284    1          unsigned long gmt_val1;
A      285       285    1          unsigned long gmt_val2;
A      286       286    1
A      287       287    1          if (sif) {  /*  .h.h style rule, make a real fake target.   */
A      288       288    2             struct sym_ftype *ft = tg->tg_ftype;
A      289       289    2             int               p  = tg->tg_len - tg->tg_suffix_len;
A      290       290    2             memcpy(fi->fi_tgtext, tg->tg_text, tg->tg_len+1);
A      291       291    2             memcpy(fi->fi_tgtext+p, ":.", 2);
A      292       292    2             p += 2;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=9  
A      293       293    2             memcpy(fi->fi_tgtext+p, ft->ft_text, ft->ft_len+1);
A      294       294    2             p += ft->ft_len;
A      295       295    2             tg = lookup_sym_target(fi->fi_tgtext,p,1);
A      296       296    2             }
A      297       297    1          if (fi->fi_tgtext == tg->tg_text)   {  /* a fake target? */
A      298       298    2             tg = lookup_sym_target(tg->tg_text, tg->tg_len, 1);
A      299       299    2             if (!tg) crash("Out of Memory: Derive\n");
A      300       300    2             }
A      301       301    1
A      302       302    1          tg->tg_fid = alloc_text(fi->fi_name[0]+2, fi->fi_name);
A      303       303    1          tg->tg_modtime = fi->fi_mod;
A      304       304    1          if (tg->tg_phony) tg->tg_modtime = END_OF_TIME;
A      305       305    1
A      306       306    1          if (fi->fi_uname[0])   {
A      307       307    2             tg->tg_ufid = alloc_text(fi->fi_uname[0]+2, fi->fi_uname);
A      308       308    2             tg->tg_umodtime = fi->fi_umod;
A      309       309    2             }
A      310       310    1
A      311       311    1          if (debug)  {
A      312       312    2             gmt_val1 = utstogmt(tg->tg_modtime);
A      313       313    2             if (tg->tg_modtime && tg->tg_modtime != END_OF_TIME)
A      314       314    2                printf("File: %s modified %s",&tg->tg_fid[1],ctime(&gmt_val1));
A      315       315    2             else printf("File: %s does not exist.\n",&tg->tg_fid[1]);
A      316       316    2
A      317       317    2             if (tg->tg_ufid) {
A      318       318    3                gmt_val2 = utstogmt(tg->tg_umodtime);
A      319       319    3                if (tg->tg_umodtime && tg->tg_modtime != END_OF_TIME)
A      320       320    3                   printf("File: %s modified %s",&tg->tg_ufid[1],ctime(&gmt_val2));
A      321       321    3                else printf("File: %s does not exist.\n",&tg->tg_ufid[1]);
A      322       322    3                }
A      323       323    2             }
A      324       324    1
A      325       325    1          return tg;
A      326       326    1        }
A      327       327
A      328       328
A      329       329
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=10 
A      330       330
A      331       331             static int forced_online = 0;
A      332       332
A      333       333             int
A      334       334             set_online(struct sym_target *tg, struct sym_target *tgi)
A      335       335             {
A      336       336    1          int   onl = 0;
A      337       337    1          int   dn;
A      338       338    1          int   dnum;
A      339       339    1          struct dependancy *d = tg->tg_depend;
A      340       340    1
A      341       341    1          if (MaxJobs == 0)  {
A      342       342    2             tg->tg_online = 1;
A      343       343    2             return;
A      344       344    2             }
A      345       345    1          if ('*' == tg->tg_fid[1])
A      346       346    1             onl++, forced_online++;
A      347       347    1          else if (tgi && ('*'==tgi->tg_fid[1] || (tgi->tg_ufid&&'*'==tgi->tg_ufid[1])
A                               ))
A      348       348    1             onl++, forced_online++;
A      349       349    1          else  {
A      350       350    2             if (forced_online)
A      351       351    2             while (d)   {
A      352       352    3                for (dn = 0 ; dn < dnum ; )   {
A      353       353    4                   struct sym_target *t = d->dp_list[dn++];
A      354       354    4                   if (t->tg_fid && '*' == t->tg_fid[1])  {
A      355       355    5                      onl++;
A      356       356    5                      goto got_onl;
A      357       357    5                      }
A      358       358    4                   }
A      359       359    3                d = d->next;
A      360       360    3                }  /* end of while (d)  */
A      361       361    2             }     /* end of else       */
A      362       362    1        got_onl:
A      363       363    1          tg->tg_online |= onl;
A      364       364    1        }
A      365       365
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=11 
A      366       366
A      367       367
A      368       368
A      369       369             /*D*    NAME:       new_action(tg, rl, tgi)
A      370       370                     PURPOSE:    To allocate and return a pointer to a new
A      371       371                                 "struct target_action".
A      372       372
A      373       373             */
A      374       374
A      375       375             struct target_action *
A      376       376             new_action(tg, rl, tgi)
A      377       377               struct sym_target    *tg;
A      378       378               struct target_rule   *rl;
A      379       379               struct sym_target    *tgi;
A      380       380             {
A      381       381    1          int                   i;
A      382       382    1          struct target_action *rs;
A      383       383    1
A      384       384    1          set_online(tg, tgi);
A      385       385    1          if (!target_action_head)   {
A      386       386    2             i = ALLOC_NUM;
A      387       387    2             rs = (struct target_action*)malloc(sizeof(struct target_action)*ALLOC_NUM
A                               );
A      388       388    2             if (!(target_action_head = rs)) crash("Out of memory: DERIVE");
A      389       389    2             mem_actionlist[0] += sizeof(struct target_action) * ALLOC_NUM;
A      390       390    2             while(--i) rs->next = rs+1, rs++;
A      391       391    2             rs->next = 0;
A      392       392    2             }
A      393       393    1          mem_actionlist[1] += sizeof(struct target_action);
A      394       394    1          rs = target_action_head;
A      395       395    1          target_action_head = rs->next;
A      396       396    1          rs->next = 0;
A      397       397    1          rs->ta_predvar = 0;
A      398       398    1          rs->ta_chngvar = 0;
A      399       399    1          rs->ta_dpndvar = 0;
A      400       400    1          rs->ta_target  = tg;
A      401       401    1          rs->ta_rule    = rl;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=12 
A      402       402    1          rs->ta_sysid   = 0;
A      403       403    1          rs->ta_flags   = 0;
A      404       404    1          rs->ta_tginput = tgi;
A      405       405    1          if (tgi && tg) {
A      406       406    2             if (tg->tg_owner) {
A      407       407    3                if(!tgi->tg_owner)
A      408       408    3                   tgi->tg_owner = tg->tg_owner;
A      409       409    3                }
A      410       410    2             else if (tgi->tg_owner) tg->tg_owner = tgi->tg_owner;
A      411       411    2             }
A      412       412    1
A      413       413    1          TargetActionNum++;
A      414       414    1          if (TargetActionNum > TargetActionSize)   {
A      415       415    2             struct target_action **t;
A      416       416    2             int i = ALLOC_NUM<<2;
A      417       417    2             t = (struct target_action**)realloc(TargetActions,(TargetActionSize+=i)<<
A                               2);
A      418       418    2             if (!t) crash("Out of Memory: Derive\n");
A      419       419    2             TargetActions = t;
A      420       420    2             }
A      421       421    1          TargetActions[TargetActionNum-1] = rs;
A      422       422    1          return rs;
A      423       423    1        }
A      424       424
A      425       425
A      426       426             /*D*    NAME:             delayed_target(struct sym_target *tg)
A      427       427                     PURPOSE:          To create a fake action for this target if
A      428       428                                       any of its dependencies are produced by actions.
A      429       429                     DESCRIPTION:
A      430       430                        This function is invoked when a rule to produce a target cannot
A      431       431                        be found and it doesn't have a corresponding source file.
A      432       432             */
A      433       433
A      434       434             unsigned
A      435       435             delayed_target(tg, early_start)
A      436       436               struct sym_target *tg;
A      437       437               unsigned          early_start;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=13 
A      438       438             {
A      439       439    1          struct dependancy *d = tg->tg_depend;
A      440       440    1          struct file_info  *of= &file_names[0];
A      441       441    1          int               da = 0;     /*  Number of dependency actions */
A      442       442    1          int               st = STATUS_COMPLETED;  /* Default status    */
A      443       443    1
A      444       444    1          while (d)   {
A      445       445    2             int dn = 0, dnum = d->dp_num;
A      446       446    2             while (dn < dnum) {
A      447       447    3                struct sym_target *t = d->dp_list[dn++];
A      448       448    3                if (t->tg_action) {     /* if depenency is produced...   */
A      449       449    4                   da++;
A      450       450    4                   if (t->tg_status==STATUS_WAITING) st = STATUS_WAITING;
A      451       451    4                   }
A      452       452    3                }     /*    End of while (dn<dnum)  */
A      453       453    2             d = d->next;
A      454       454    2             }        /*    End of while (d)        */
A      455       455    1
A      456       456    1          if (da)  {  /*    if there were dependency actions... */
A      457       457    2             tg->tg_action = new_action(tg, (struct target_rule*)0, (struct sym_target
A                               *)0);
A      458       458    2             tg->tg_status = st;
A      459       459    2             if (st == STATUS_COMPLETED && !tg->tg_modtime)  /* File exist? */
A      460       460    2                error("### Error: Can't find and can't build target %s\n",tg->tg_text)
A                               ;
A      461       461    2             else if (options['v'])
A      462       462    2                warning("### Warning: %s assumed to be built as dependent side-effect\
A                               n",tg->tg_text);
A      463       463    2             if (st == STATUS_WAITING && !tg->tg_modtime && tg->tg_srch) {
A      464       464    3                fid_ins_acct(tg->tg_srch->accts[0].text, of->fi_name);
A      465       465    3                tg->tg_fid = alloc_text(of->fi_name[0]+2, of->fi_name);
A      466       466    3                }
A      467       467    2             if (st == STATUS_WAITING)
A      468       468    2                tg->tg_modtime = early_start = -1;
A      469       469    2             else tg->tg_modtime = MAX(early_start, tg->tg_modtime);
A      470       470    2             return 1;
A      471       471    2             }
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=14 
A      472       472    1          return 0;
A      473       473    1        }
A      474       474
A      475       475
A      476       476
A      477       477             /*D*    NAME:             derive_depinput(tg, rft)
A      478       478                     PURPOSE:          To locate the input file for a target.
A      479       479                     DESCRIPTION:
A      480       480                        This function is invoked when a required target has a dependancy
A      481       481                        which has the same base file name.  In this case, the plan is to
A      482       482                        check each of these dependencies to determine if it is an input
A      483       483                        file that could produce the required output file type.  If it does,
A
A      484       484                        then we assume that it is the intended input for this target.
A      485       485
A      486       486                        This function returns a pointer to the correct production rule to
A      487       487                        produce the target or a NULL pointer if there is no built-in rule
A      488       488                        that can produce the required input file type from one of the same
A      489       489                        named dependencies.
A      490       490             */
A      491       491             struct sym_target *
A      492       492             derive_depinput(tg)
A      493       493               struct sym_target *tg;
A      494       494             {
A      495       495    1          struct sym_ftype     *rft = tg->tg_ftype;    /* Required output file type */
A
A      496       496    1          struct dependancy    *d   = tg->tg_depend;   /* Head of dependancy list   */
A
A      497       497    1          int                   tg_blen = tg->tg_len - tg->tg_suffix_len;
A      498       498    1          struct sym_target    *get_rule();
A      499       499    1
A      500       500    1          while (d)   {
A      501       501    2             int   dn, dnum = d->dp_num;
A      502       502    2             for (dn = 0; dn<dnum ; ) {
A      503       503    3                struct sym_target    *t = d->dp_list[dn++];
A      504       504    3                if (tg_blen == t->tg_len - t->tg_suffix_len && !memcmp(tg->tg_text,t->
A                               tg_text,tg_blen)){
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=15 
A      505       505    4                   struct sym_ftype  *fi = t->tg_ftype;
A      506       506    4                   struct sym_target *tr = 0;
A      507       507    4                   while (tr = get_rule(tr, rft, 1))   {
A      508       508    5                      if (tr->tg_inftype == fi)
A      509       509    5                         return tr;
A      510       510    5                      }  /*       end of while (get_rule)    */
A      511       511    4                   }     /*  end of: if (base == depbase)    */
A      512       512    3                }        /*  end of: for loop                */
A      513       513    2             d = d->next;
A      514       514    2             }           /*  end of: while (d)               */
A      515       515    1          return 0;
A      516       516    1        }
A      517       517
A      518       518
A      519       519
A      520       520
A      521       521             /*D*    NAME:             derive_target(tg)
A      522       522                     PURPOSE:          To initiate all of the action entries
A      523       523                                    required to produce the specified target.
A      524       524                     DESCRIPTION:
A      525       525                        All of the dependancies for this target must have already
A      526       526                        been derived.  A target is produced in one of two ways:
A      527       527
A      528       528                        1. Explicit commands were entered to build the target.
A      529       529
A      530       530                           In this case, we can immediately determine the method
A      531       531                           of producing this target.  If the commands reference
A      532       532                           the special macro $< or $@, then this command
A      533       533                           produces as single file for each invokation.
A      534       534                           Otherwise, all of the targets mentioned on the
A      535       535                           dependancy line for these commands are assumed to be
A      536       536                           produced.
A      537       537
A      538       538                        2. The other method of producing a file (and more often
A      539       539                           used) is to use an implcit rule.  In this case, MAKE
A      540       540                           searches for an existing input file that could produce
A      541       541                           the required output file.  This may involve two steps
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=16 
A      542       542                           such as running LEX to produce C source and then
A      543       543                           running the C compiler to produce the appropriate
A      544       544                           object unit.
A      545       545
A      546       546                        This function determines which case is appropriate for
A      547       547                        building the specified target, builds
A      548       548                        "struct target_action" entries, creates "struct sym_target"
A      549       549                        entries for any input files that are found and updates the
A      550       550                        status of the input target.
A      551       551             */
A      552       552
A      553       553             unsigned
A      554       554             derive_target(tg, early_start, debug, verbose)
A      555       555               struct sym_target    *tg;
A      556       556               timetype              early_start;
A      557       557               int                   debug;
A      558       558               int                   verbose;
A      559       559             {
A      560       560    1          int                   flavor, sif;
A      561       561    1          struct sym_target    *tr;
A      562       562    1          struct sym_target    *t;
A      563       563    1          struct sym_ftype     *rft = tg->tg_ftype;
A      564       564    1          struct file_info     *cf, *of, *tgfi = &file_names[0];
A      565       565    1          struct sym_target    *stg = 0;
A      566       566    1          struct sym_target    *xtg = 0, *tgo = 0;
A      567       567    1          struct target_rule   *rule = tg->tg_commands, *cmds = 0;
A      568       568    1          struct target_action *action = 0;
A      569       569    1          struct target_action **tga = 0;
A      570       570    1          struct sym_target    *tgroot = tg;
A      571       571    1          timetype              time, itime;
A      572       572    1          int                   Status = STATUS_BUSY;
A      573       573    1          struct sym_target    *get_rule();
A      574       574    1          int                   pr = 0;
A      575       575    1          extern struct target_rule FMT_compile, COPY_compile;
A      576       576    1
A      577       577    1          last_file = 1;
A      578       578    1          if (tg->tg_inftype)  {
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=17 
A      579       579    2             flavor = 4;
A      580       580    2             xtg    = tg;
A      581       581    2             }
A      582       582    1          else flavor = (rule) ? 2 : 1;
A      583       583    1
A      584       584    1          of = &file_names[0];
A      585       585    1          if (tg->tg_depbase && flavor!=4 && (tr = derive_depinput(tg)))
A      586       586    1             flavor = 5;
A      587       587    1          else tr = (struct sym_target*) 0;
A      588       588    1
A      589       589    1          while (tr = get_rule(tr, tg->tg_ftype, flavor, xtg)) {
A      590       590    2             if ( pr = (verbose && debug && flavor!=3))
A      591       591    2                printf("%s ",tr->tg_text);
A      592       592    2             sif = tr->tg_inftype == tr->tg_ftype;
A      593       593    2             t   = build_target(tg,tr->tg_inftype);
A      594       594    2             find_file(t, (cf=&file_names[last_file]), sif, 0);
A      595       595    2             if (t->tg_action || cf->fi_mod != 0 || flavor == 3)  {
A      596       596    3                if (pr) printf("\n"), pr=0;
A      597       597    3                cmds = tr->tg_commands;
A      598       598    3                t    = new_file(t, cf, ((flavor==3)? 0 : debug), sif);
A      599       599    3                if (flavor == 3 || rft != tr->tg_ftype) {/*complex derive*/
A      600       600    4                   of = &file_names[++last_file];
A      601       601    4                   stg = tg;   /* produce an output target */
A      602       602    4                   tgo  = build_target(stg, tr->tg_ftype);
A      603       603    4                   if (tg->tg_action)
A      604       604    4                      goto try_next_rule;
A      605       605    4                   find_file(tgo,of,0,1);
A      606       606    4                   xtg = tg  = new_file(tgo, of, ((tgo==tgroot)? 0 : debug),0);
A      607       607    4                   tg->tg_srch = of->fi_srch;
A      608       608    4                   flavor = 3;
A      609       609    4                   }
A      610       610    3        found_in_SI:
A      611       611    3                time = MAX(tg->tg_modtime, tg->tg_umodtime);
A      612       612    3                time = (time == END_OF_TIME)? BEGINNING_OF_TIME : time;
A      613       613    3                if (t->tg_old) {  /* treat target as up-to-date */
A      614       614    4                   t->tg_modtime = BEGINNING_OF_TIME+1;
A      615       615    4                   if (t->tg_umodtime) t->tg_umodtime = BEGINNING_OF_TIME+1;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=18 
A      616       616    4                   }
A      617       617    3                if (t->tg_new) t->tg_modtime = END_OF_TIME;
A      618       618    3                itime = MAX(t->tg_modtime, t->tg_umodtime);
A      619       619    3                early_start = MAX(early_start,itime);
A      620       620    3                Status = (time>=early_start)? STATUS_COMPLETED:STATUS_WAITING;
A      621       621    3                if (tg->tg_old)  {
A      622       622    4                   Status = STATUS_COMPLETED;
A      623       623    4                   tg->tg_modtime = time = BEGINNING_OF_TIME+1;    /* don't count mod
A                               time */
A      624       624    4                   if (tg->tg_umodtime) tg->tg_umodtime = BEGINNING_OF_TIME+1;
A      625       625    4                   }
A      626       626    3                if (tg->tg_new) Status = STATUS_WAITING;
A      627       627    3                /**  Put output in 1st directory if we must generate it **/
A      628       628    3                if (tgfi->fi_srch && Status==STATUS_WAITING) {
A      629       629    4                   fid_ins_acct(tgfi->fi_srch->accts[0].text,of->fi_name);
A      630       630    4                   tg->tg_fid = alloc_text(of->fi_name[0]+2,of->fi_name);
A      631       631    4                   }
A      632       632    3                tg->tg_action = action = new_action(tg, (rule)?rule :cmds, t);
A      633       633    3                if (tga) *tga = action;
A      634       634    3                tga  = &action->next;
A      635       635    3                early_start = (Status==STATUS_WAITING)? END_OF_TIME:MAX(time,early_sta
A                               rt);
A      636       636    3                tg->tg_status = Status;
A      637       637    3                tg->tg_modtime = early_start;
A      638       638    3                if (flavor == 2 || tgroot == tg) goto exit;
A      639       639    3                flavor = 3;
A      640       640    3                tg     = stg;
A      641       641    3                of = &file_names[0];
A      642       642    3                }  /*  End of "found file" or "complex derivation"    */
A      643       643    2        try_next_rule:
A      644       644    2             if (flavor == 5) flavor = 2;
A      645       645    2             }     /*  End of  while...                               */
A      646       646    1
A      647       647    1        /*   Didn't find any way to generate the target file!
A      648       648    1             No problem if we found the target (if debug is we'll
A      649       649    1             say we couldn't find it, otherwise, this is a serious
A      650       650    1             error.
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=19 
A      651       651    1        */
A      652       652    1
A      653       653    1          of = &file_names[last_file=0];
A      654       654    1          if (pr) printf("\n"), pr=0;
A      655       655    1
A      656       656    1        /*   Next possibility... we are really looking for an input file for
A      657       657    1             another target.  This is likely to be true if:
A      658       658    1
A      659       659    1             1. The file type is associated with implicit input rules
A      660       660    1             2. The target file does not exist
A      661       661    1             3. We inserted the OUPATH (overriding the default SI account)
A      662       662    1
A      663       663    1             In this case, see if the file exists in the SIPATH.  If it
A      664       664    1             does, then just return this file's time stamp.
A      665       665    1
A      666       666    1             Note:  If there is an explicit rule to generate this file then
A      667       667    1                    it is an error.
A      668       668    1        */
A      669       669    1             if (!rule && tg->tg_ftype->ft_in && OUPATH && SIPATH && !memcmp(fid_acct(
A                               file_name(tg,0)), SIROOT1, 8))  {
A      670       670    2                char *sf = tg->tg_fid;
A      671       671    2                tg->tg_fid = 0;   /*  Ignore original fid */
A      672       672    2                find_file(tg, (cf = &file_names[0]), 1, 0);
A      673       673    2                if (cf->fi_mod)   {     /* If the file existed...  */
A      674       674    3                   tg = new_file(tg, cf, debug, 0);
A      675       675    3                   time = MAX(tg->tg_modtime, tg->tg_umodtime);
A      676       676    3                   early_start = MAX(early_start, time);
A      677       677    3                   tg->tg_status = STATUS_COMPLETED;
A      678       678    3                   if (options['v'] > 1)
A      679       679    3                      warning("### warning: %s assumed to be an input file not a targe
A                               t\n", tg->tg_text);
A      680       680    3                   goto exit;
A      681       681    3                   }
A      682       682    2                tg->tg_fid = sf;
A      683       683    2                }
A      684       684    1        /*   One interesting possibility to consider:  include files may
A      685       685    1             come from the SI/UI accounts and appear in the OU acction.
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=20 
A      686       686    1             There is no explicit rule to produce them but they are produced
A      687       687    1             here if there is an OUPATH and an SIPATH specified and if
A      688       688    1             the file that we are looking for should be found in the OUPATH.
A      689       689    1        */
A      690       690    1          if (OUPATH && SIPATH)   {
A      691       691    2             char *acct = fid_acct(tg->tg_fid+1);
A      692       692    2             int   i    = 0;
A      693       693    2             int   j    = OUPATH->naccts;
A      694       694    2             last_file  = 1;
A      695       695    2             while (i < j)  {
A      696       696    3                if (memcmp(acct,OUPATH->accts[i++].text,8) == 0)   {
A      697       697    4                   t = build_target(tg, tg->tg_ftype);
A      698       698    4                   find_file(t, (cf = &file_names[last_file]),1,0);
A      699       699    4                   if (cf->fi_mod && memcmp(OUPATH->accts[i-1].text,fid_acct(cf->fi_na
A                               me),8)!=0)   {
A      700       700    5                      cmds = (cf->fi_umod) ? fmt_cmd : copy_cmd;
A      701       701    5                      t    = new_file(t, cf, debug, 1);
A      702       702    5                      if (options['v'] > 1)
A      703       703    5                         warning("## warning: %s assumed to be an include file, format
A                               ted or copied into the OU account\n",tg->tg_text);
A      704       704    5                      goto found_in_SI;
A      705       705    5                      break;
A      706       706    5                      }
A      707       707    4                   }
A      708       708    3                }
A      709       709    2             }
A      710       710    1          tg->tg_modtime = of->fi_mod;
A      711       711    1          tg->tg_umodtime = of->fi_umod;
A      712       712    1
A      713       713    1        /**  Even more possibilities:
A      714       714    1
A      715       715    1             If the target depends upon targets which have actions associated with
A      716       716    1             them, this target could be a side-effect of such a target.
A      717       717    1
A      718       718    1             So, when this case is found, we create a fake action to delay the running
A
A      719       719    1             of targets dependent upon this target.  This fake action will contain no
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=21 
A      720       720    1             commands, so it will merely be marked completed (or errored if the target
A
A      721       721    1             doesn't exist at that point) whenever it is ready to run.
A      722       722    1        */
A      723       723    1          if (tg->tg_depend && delayed_target(tg))
A      724       724    1             goto exit;
A      725       725    1
A      726       726    1          if (of->fi_mod)   {
A      727       727    2             if (debug)
A      728       728    2                printf("### Warning: no actions found to produce \"%s\"\n",
A      729       729    2                       tg->tg_text);
A      730       730    2             tg->tg_status = STATUS_COMPLETED;
A      731       731    2             if ('*' == of->fi_name[1])
A      732       732    2                forced_online++;
A      733       733    2             if (tg->tg_old)   {
A      734       734    3                tg->tg_modtime = BEGINNING_OF_TIME+1;
A      735       735    3                if (tg->tg_umodtime) tg->tg_umodtime = BEGINNING_OF_TIME+1;
A      736       736    3                }
A      737       737    2             if (tg->tg_new) tg->tg_modtime = END_OF_TIME;
A      738       738    2             }
A      739       739    1          else {
A      740       740    2             error("### Error: Can't find and can't build target \"%s\"\n",
A      741       741    2                       tg->tg_text);
A      742       742    2             tg->tg_status = STATUS_ERRORED;
A      743       743    2             }
A      744       744    1
A      745       745    1        exit:
A      746       746    1          return early_start;
A      747       747    1        }
A      748       748
A      749       749
A      750       750             unsigned
A      751       751             derive_targets(tg, early_start, debug)
A      752       752               struct sym_target    *tg;
A      753       753               timetype              early_start;
A      754       754               int                   debug;
A      755       755             {
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=22 
A      756       756    1          struct target_rule   *rule = tg->tg_commands;
A      757       757    1          struct dependancy    *d = (rule)? rule->tr_depend : 0;
A      758       758    1          int                single = 0;
A      759       759    1          timetype              xstart;
A      760       760    1          timetype              time;
A      761       761    1          int                   Status;
A      762       762    1          struct sym_target    *t;
A      763       763    1          int                   fixa;
A      764       764    1          struct target_action **tga = &tg->tg_action;
A      765       765    1          struct target_action *action = 0;
A      766       766    1          struct sym_owner *ow = tg->tg_owner;
A      767       767    1          char                 *accts;
A      768       768    1          char                 *fid;
A      769       769    1          int                   told = 0, tnew = 0;
A      770       770    1
A      771       771    1          xstart = MAX(file_names[0].fi_mod,file_names[0].fi_umod);
A      772       772    1          if (d && rule->tr_commands->cm_flags & (MC_OU|MC_OU_FILE))
A      773       773    1             single = 1;
A      774       774    1          if (d && options['v'] > 1) {
A      775       775    2             if (d->dp_target != tg && !single) {
A      776       776    3                warning("### multiple targets assumed to be produced by commands to pr
A                               oduce target %s\n", tg->tg_text);
A      777       777    3                }
A      778       778    2             }
A      779       779    1          last_file = 1;
A      780       780    1          while (d)   {
A      781       781    2             t = (single) ? tg : d->dp_target;
A      782       782    2             told += t->tg_old;
A      783       783    2             tnew += t->tg_new;
A      784       784    2             if (t != tg)   {  /* Gen names of all other gen'ed files */
A      785       785    3                find_file(t,&file_names[1],0,1);
A      786       786    3                t = new_file(t, &file_names[1], debug, 0);
A      787       787    3                if (!ow) ow = t->tg_owner;
A      788       788    3                time = MAX(file_names[1].fi_mod, file_names[1].fi_umod);
A      789       789    3                xstart = MIN(time,xstart);
A      790       790    3                }
A      791       791    2             d = (single) ? 0 : d->next;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=23 
A      792       792    2             }
A      793       793    1
A      794       794    1          Status = (xstart < early_start)? STATUS_WAITING : STATUS_COMPLETED;
A      795       795    1          if (tg->tg_phony) Status = STATUS_WAITING;
A      796       796    1          if (told) Status = STATUS_COMPLETED;
A      797       797    1          if (tnew) Status = STATUS_WAITING;
A      798       798    1          early_start = (Status==STATUS_WAITING)? END_OF_TIME : MAX(xstart,early_start
A                               );
A      799       799    1          d = (rule) ? rule->tr_depend : 0;
A      800       800    1          fixa = (file_names[0].fi_srch && Status == STATUS_WAITING);
A      801       801    1          accts = (fixa)? file_names[0].fi_srch->accts[0].text : (char*)0;
A      802       802    1          fid   = (fixa)? file_names[2].fi_name : (char *)0;
A      803       803    1
A      804       804    1          while (d)   {
A      805       805    2             t = (single) ? tg : d->dp_target;
A      806       806    2             t->tg_status = Status;
A      807       807    2             if (!t->tg_owner) t->tg_owner = ow;
A      808       808    2             if (Status == STATUS_WAITING)  t->tg_modtime = early_start;
A      809       809    2             if (fixa && memcmp(accts,fid_acct(t->tg_fid),8) != 0) {
A      810       810    3                memcpy(fid,t->tg_fid,t->tg_fid[0]+2);
A      811       811    3                fid_ins_acct(accts,fid);
A      812       812    3                t->tg_fid = alloc_text(fid[0]+2,fid);
A      813       813    3                }
A      814       814    2             d = (single) ? 0 : d->next;
A      815       815    2             }
A      816       816    1
A      817       817    1          *tga = action = new_action(tg, rule, (struct sym_target*)0);
A      818       818    1          tga  = &action->next;
A      819       819    1          return early_start;
A      820       820    1        }
A      821       821
A      822       822
A      823       823
A      824       824
A      825       825             /*D*    NAME:          insert_rule(struct target_rules *rule)
A      826       826                     PURPOSE:       To insert a new rule into the list of used
A      827       827                                    rules.
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=24 
A      828       828                     DESCRIPTION:
A      829       829                        When displaying the rules used in a derivation, this
A      830       830                        routine is used to insert each rule into the list of
A      831       831                        used rules and return a unique integer identifying that
A      832       832                        rule.
A      833       833             */
A      834       834
A      835       835             struct  target_rule    **Rules = 0;
A      836       836             int                    RuleSize = 0;
A      837       837             int                    RuleNum  = 0;
A      838       838
A      839       839             int
A      840       840             insert_rule(rule)
A      841       841               struct target_rule  *rule;
A      842       842             {
A      843       843    1          int i;
A      844       844    1
A      845       845    1          for ( i=0 ; i<RuleNum ; i++ )
A      846       846    1             if (Rules[i] == rule) break;
A      847       847    1
A      848       848    1          if ( i>= RuleNum )   {
A      849       849    2             if (++RuleNum > RuleSize)  {
A      850       850    3                Rules = (struct target_rule**)realloc(Rules,(RuleSize+=10)<<2);
A      851       851    3                if (!Rules) crash("Out of Memory: dump_rules");
A      852       852    3                }
A      853       853    2             Rules[i] = rule;
A      854       854    2             }
A      855       855    1          return i;
A      856       856    1        }
A      857       857
A      858       858
A      859       859             /*D*    NAME:       si_ui_fid(tg)
A      860       860                     PURPOSE:    To return a pointer to a string identifying a
A      861       861                                 target file.
A      862       862             */
A      863       863
A      864       864             char *
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=25 
A      865       865             si_ui_fid(tg)
A      866       866               struct sym_target *tg;
A      867       867             {
A      868       868    1          static char b[88];
A      869       869    1          int j;
A      870       870    1
A      871       871    1          if (!tg) return "";
A      872       872    1          if (!tg->tg_ufid)
A      873       873    1             return (tg->tg_fid)? tg->tg_fid+1 : "";
A      874       874    1
A      875       875    1          memcpy(b,tg->tg_fid+1, j = tg->tg_fid[0]);
A      876       876    1          b[j++] = ',';
A      877       877    1          b[j]   = 0;
A      878       878    1          strcat(b, strchr(tg->tg_ufid,'.'));
A      879       879    1          return b;
A      880       880    1        }
A      881       881
A      882       882
A      883       883             /*D*    NAME:       fid_time(tg)
A      884       884                     PURPOSE:    To return the latest derivation time for
A      885       885                                 a file in printable form "mm/dd/yy hh:mm".
A      886       886             */
A      887       887
A      888       888             char *
A      889       889             fid_time(tg)
A      890       890               struct sym_target *tg;
A      891       891             {
A      892       892    1          static char b[20];
A      893       893    1          timetype time;
A      894       894    1
A      895       895    1          b[0] = 0;
A      896       896    1          if (!tg) return "";
A      897       897    1          time = MAX(tg->tg_modtime,tg->tg_umodtime);
A      898       898    1          if ( time==BEGINNING_OF_TIME || time==END_OF_TIME ) return "";
A      899       899    1          strftime(b, 20, "%m/%d/%y %H:%M", localtime(&time));
A      900       900    1          return b;
A      901       901    1        }
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=26 
A      902       902
A      903       903
A      904       904
A      905       905
A      906       906             /*D*    NAME:          dump_actions(LS_width, verbose)
A      907       907                     PURPOSE:       To format the contents of the actions generated
A      908       908                                    by derive.
A      909       909             */
A      910       910
A      911       911
A      912       912             CONST char act_fmt[] ="%-*.*s %-5.5s %3d %-*.*s %-*.*s %-14.14s\n";
A      913       913             CONST char act_tft[] ="%-*.*s %-5.5s %3.3s %-*.*s %-*.*s %-14.14s\n";
A      914       914
A      915       915             dump_actions(LS_width, verbose)
A      916       916               int            LS_width;
A      917       917               int            verbose;
A      918       918             {
A      919       919    1          int            i, j;
A      920       920    1          int            w_p = 0;
A      921       921    1          int            tw=14, ofw=17, ifw=22, xw=LS_width-80;
A      922       922    1          CONST char    *fmt = act_fmt;
A      923       923    1          CONST char    *tft = act_tft;
A      924       924    1          char *owner;
A      925       925    1          int   ot  = options['e'];
A      926       926    1          struct sym_target *tg;
A      927       927    1
A      928       928    1          if (xw > 0) {
A      929       929    2             tw+=xw/7; ofw+=2*xw/7; ifw+=4*xw/7;
A      930       930    2             }
A      931       931    1          printf("\n");
A      932       932    1          owner = (ot) ? "Owner" : "Time";
A      933       933    1          printf(tft,tw,tw,"Target", "State", "Cmd", ofw,ofw,"Output File", ifw,ifw,"I
A                               nput File", owner);
A      934       934    1
A      935       935    1          for ( i=0 ; i<TargetActionNum ; i++ )  {
A      936       936    2
A      937       937    2             tg = TargetActions[i]->ta_target;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=27 
A      938       938    2             owner = (!ot)? fid_time(tg) : (tg->tg_owner)? tg->tg_owner->ow_text : "";
A
A      939       939    2             printf(fmt,
A      940       940    2                tw,tw,tg->tg_text,
A      941       941    2                state_names[tg->tg_status+1],
A      942       942    2                insert_rule(TargetActions[i]->ta_rule),
A      943       943    2                ofw,ofw,tg->tg_fid+1,
A      944       944    2                ifw,ifw,si_ui_fid(TargetActions[i]->ta_tginput),
A      945       945    2                owner                   );
A      946       946    2             }
A      947       947    1
A      948       948    1          printf("\n\nCommands:   "), w_p = 13;
A      949       949    1
A      950       950    1          for ( i=0 ; i<RuleNum ; i++)  {
A      951       951    2             struct target_rule *r = Rules[i];
A      952       952    2             if (r)   {
A      953       953    3                struct sym_target *t = r->tr_depend->dp_target;
A      954       954    3                if (LS_width < (w_p += t->tg_len +1))
A      955       955    3                   printf("\n             "), w_p = 13 + t->tg_len + 1;
A      956       956    3                printf(" %s", t->tg_text);
A      957       957    3                }
A      958       958    2             }
A      959       959    1          printf("\n");
A      960       960    1
A      961       961    1          if (verbose)   {
A      962       962    2             for ( i=0 ; i<RuleNum ; i++)  {
A      963       963    3                struct target_rule *r = Rules[i];
A      964       964    3                struct command_line *l = (r) ? r->tr_commands->cm_lines : 0;
A      965       965    3                printf("\nCommand %3d: ",i), w_p = 13;
A      966       966    3                for ( j=0 ; j<TargetActionNum ; j++ )
A      967       967    3                   if ( TargetActions[j]->ta_rule == r)   {
A      968       968    4                      struct sym_target *tg = TargetActions[j]->ta_target;
A      969       969    4                      if (LS_width < (w_p += tg->tg_len +1))
A      970       970    4                         printf("\n             "), w_p = 13 + 1 + tg->tg_len;
A      971       971    4                      printf(" %s",tg->tg_text);
A      972       972    4                      }
A      973       973    3                printf("\n");
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=28 
A      974       974    3                if (verbose > 1) {
A      975       975    4                   while(l) printf(" %s\n", l->cmd_text), l= l->next;
A      976       976    4                   printf("\n");
A      977       977    4                   }
A      978       978    3                }
A      979       979    2             printf("\n");
A      980       980    2             if (Rules)
A      981       981    2                free(Rules), Rules=0, RuleSize=0, RuleNum=0;
A      982       982    2             }
A      983       983    1        }
A      984       984
A      985       985
A      986       986
A      987       987             void
A      988       988             generate_action_file(struct _FILE *af)  {
A      989       989    1          int   i;
A      990       990    1
A      991       991    1          for ( i=0   ;  i<TargetActionNum ;  i++   )     {
A      992       992    2             struct   target_action *ta = TargetActions[i];
A      993       993    2             struct   sym_target    *tgi   =  ta->ta_tginput;
A      994       994    2             struct   sym_target    *tgo   =  ta->ta_target;
A      995       995    2
A      996       996    2             if (tgi)
A      997       997    2             fprintf(af, "%s %s %s %s %s\n",
A      998       998    2                si_ui_fid(tgi),
A      999       999    2                tgi->tg_text,
A     1000      1000    2                tgo->tg_fid+1,
A     1001      1001    2                tgo->tg_text,
A     1002      1002    2                ta->ta_rule->tr_depend->dp_target->tg_text);
A     1003      1003    2
A     1004      1004    2             }
A     1005      1005    1
A     1006      1006    1        }
A     1007      1007
A     1008      1008
A     1009      1009
A     1010      1010             void
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=29 
A     1011      1011             generate_list_file(struct _FILE *af, char *component)   {
A     1012      1012    1          int                i;
A     1013      1013    1          char               buf[80];
A     1014      1014    1          char              *jcl, *file, *owner;
A     1015      1015    1          struct sym_macro  *mc;
A     1016      1016    1          int                tlen;
A     1017      1017    1          struct sym_owner  *own;
A     1018      1018    1          struct sym_ftype  *ft;
A     1019      1019    1
A     1020      1020    1          for (i = 0 ; i < TargetActionNum ; )   {
A     1021      1021    2             struct target_action *ta = TargetActions[i++];
A     1022      1022    2             struct sym_target    *tg = ta->ta_tginput;
A     1023      1023    2
A     1024      1024    2             if (tg)  {
A     1025      1025    3                ft = tg->tg_ftype;
A     1026      1026    3                tlen = ft->ft_len + 1;
A     1027      1027    3                memcpy(buf, "..", 2);
A     1028      1028    3                memcpy(buf+2, ft->ft_text, tlen);
A     1029      1029    3                mc = lookup_sym_macro(buf, tlen+1, 4);
A     1030      1030    3                jcl = (mc) ? mc->mc_def : "UNKNOWN";
A     1031      1031    3
A     1032      1032    3                tlen = *(tg->tg_fid);
A     1033      1033    3                file = memchr(tg->tg_fid+1, '.', tlen);
A     1034      1034    3                if (file)   {
A     1035      1035    4                   int tlen = file - tg->tg_fid - 1;
A     1036      1036    4                   memcpy(buf, tg->tg_fid+1, tlen);
A     1037      1037    4                   buf[tlen] = 0;
A     1038      1038    4                   file = buf;
A     1039      1039    4                   }
A     1040      1040    3                else file = tg->tg_fid+1;
A     1041      1041    3
A     1042      1042    3                own = tg->tg_owner;
A     1043      1043    3                if (!own)
A     1044      1044    3                   own = ta->ta_target->tg_owner;
A     1045      1045    3                if (own)  {
A     1046      1046    4                   owner = strchr(own->ow_text, ' ');
A     1047      1047    4                   if (!owner) owner = own->ow_text;
rCC.C03    File=MAKE_SIc04.:XSI                                                      Thu Nov 20 1997  Page=30 
A     1048      1048    4                   }
A     1049      1049    3                else owner = "SMITH";
A     1050      1050    3
A     1051      1051    3                fprintf(af, "%s,JCL:%s,%s         %s\n", file, jcl, component, owner);
A
A     1052      1052    3                }  /* end of if input file */
A     1053      1053    2             }     /* end of for loop      */
A     1054      1054    1        }
A---  Include file information  ---
A
A   MAKE_Cc14.:XSI. is referenced
A   MAKE_Cc13.:XSI. is referenced
A   stdlib:h.:LIBRARY. is referenced
A   b$jit_c:h.:LIBRARY. is referenced
A   xu_cp6_c:h.:LIBRARY. is referenced
A   string:h.:LIBRARY. is referenced
C
ANo diagnostics were issued in the file MAKE_SIc04.:XSI
