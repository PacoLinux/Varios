/*M* FILER_SI6 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,IND=3 */
/*********************************************************************/
/**
***   UT_REPORT_PSBL_ERR   29 SEP 77   (PRY)   INDICATE WHERE
***   ERROR WAS DETECTED AND PRINT AN ERROR MESSAGE.
**/
 
UT_REPORT_PSBL_ERR: PROC;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%LIST;
%INCLUDE FILER_II6;
 
/*** LIST AN OUTPUT BUFFER   ***/
DCL   UT_WRITE_BUF           ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   SHOW ERROR POSITION   ***/
DCL   UT_SHOW_ERR            ENTRY(5);
 
/********************
***   LOCALS:
**/
DCL   ERR_MSG$        PTR ALIGNED AUTO; /* POINTER TO FAULT MESSAGE           */
DCL   ERR_LEN   SBIN WORD ALIGNED AUTO; /* LENGTH OF FAULT MESSAGE            */
DCL   ERR_CHARX SBIN WORD ALIGNED AUTO; /* CHARX OF ERROR                     */
DCL   ERR_CODE  SBIN WORD ALIGNED AUTO; /* ERROR CODE                         */
DCL ERR_CR_CHARX SBIN WORD ALIGNED AUTO; /* IX OF LAST CR                     */
DCL   ERR_BID   SBIN WORD ALIGNED AUTO; /* BUFFER ID                          */
DCL ERR_CR_COUNT SBIN WORD ALIGNED AUTO; /* NUMBER OF CRS BEFORE ERR          */
DCL   PSBLMSG           CHAR(4)   ALIGNED   CONSTANT  INIT( '????' );
DCL   PSBLMSG$          PTR       ALIGNED   CONSTANT  INIT( ADDR( PSBLMSG ) );
 
/********************
***   CHECK IF ANY ERRORS TO REPORT.
**/
   IF NBR_PSBL_ERRS = 0 THEN RETURN;    /* RETURN IF NOTHING                  */
   NBR_PSBL_ERRS = NBR_PSBL_ERRS - 1;   /* CONVERT NUMBER TO INDEX            */
   IF NBR_PSBL_ERRS > MAX_PSBL_ERR_IX   /* ERROR WRAPAROUND?                  */
    THEN NBR_PSBL_ERRS = MAX_PSBL_ERR_IX; /* YES                              */
 
/********************
***   REPORT ALL POSSIBLE ERRORS.
**/
   CALL UT_FLUSH_BUF;                   /* PREPARE BUFFER FOR ERROR MESSAGE   */
   DO WHILE (NBR_PSBL_ERRS >= 0);
      ERR_CHARX = PSBL_ERRS.CHARX(PSBL_ERR_IX);
                                        /* GET CHARX AND SKIP PROMPT          */
      ERR_CODE  = PSBL_ERRS.CODE(PSBL_ERR_IX);
                                        /* AND CODE                           */
      ERR_CR_CHARX = PSBL_ERRS.CR_CHARX(PSBL_ERR_IX);
      ERR_CR_COUNT = PSBL_ERRS.CR_COUNT(PSBL_ERR_IX);
      ERR_BID      = PSBL_ERRS.BID(PSBL_ERR_IX);
      CALL UT_SHOW_ERR( ERR_BID, ERR_CHARX, ERR_CR_CHARX,
        ERR_CR_COUNT, PSBLMSG$ );       /* POINT OUT POSSIBLE ERROR           */
            /**
            *** WRITE THE PSBL ERR MESSAGE.
            **/
      ERR_MSG$ = PSBL_ERR_MSG_PTRS(ERR_CODE);
                                        /* GET POINTER TO ERROR MESSAGE       */
      ERR_LEN  = PSBL_ERR_MSG_LENS(ERR_CODE);
                                        /* GET LENGTH OF MESSAGE              */
      CALL UT_WRITE_BUF( ERR_MSG$, ERR_LEN );
                                        /* WRITE THE PSBL ERR  MESSAGE        */
      NBR_PSBL_ERRS = NBR_PSBL_ERRS - 1; /* COUNT DOWN ERRORS                 */
      PSBL_ERR_IX = PSBL_ERR_IX - 1;
      IF PSBL_ERR_IX < 0 THEN PSBL_ERR_IX = MAX_PSBL_ERR_IX;
                                        /* WRAP AROUND ERROR LIST             */
      END;
 
   RETURN;
 
END UT_REPORT_PSBL_ERR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_REPORT_VAL_FAULT   14 SEP 77   (PRY)   INDICATE WHERE
***   ERROR WAS DETECTED AND PRINT AN ERROR MESSAGE.
**/
 
UT_REPORT_VAL_FAULT: PROC;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%LIST;
%INCLUDE FILER_II7;
 
/*** LIST AN OUTPUT BUFFER   ***/
DCL   UT_WRITE_BUF           ENTRY(2);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   SHOW ERROR POSITION   ***/
DCL   UT_SHOW_ERR            ENTRY(5);
 
 
/********************
***   LOCALS:
**/
DCL   FLT_MSG$        PTR ALIGNED AUTO; /* POINTER TO FAULT MESSAGE           */
DCL   FLT_LEN   SBIN WORD ALIGNED AUTO; /* LENGTH OF FAULT MESSAGE            */
DCL   SPACE_COUNT       SBIN WORD ALIGNED   AUTO;
                                        /* NUMBER OF SPACES TO PRINT          */
DCL   SPACE_NBR SBIN WORD ALIGNED AUTO; /* NUMBER OF SPACES PRINTED           */
DCL   BID       SBIN WORD ALIGNED AUTO; /* BUFFER ID                          */
 
/********************
***   PRINT A DOLLAR SIGN UNDER THE ERROR IF NECESSARY.
**/
   CALL UT_FLUSH_BUF;              /* PREPARE OUTPUT BUFFER FOR ERROR MESSAGE */
   FLT_MSG$ = VAL_FLT_MSG_PTRS(VAL_FAULT);
                                        /* GET POINTER TO ERROR MESSAGE       */
   FLT_LEN  = VAL_FLT_MSG_LENS(VAL_FAULT);
                                        /* GET LENGTH OF MESSAGE              */
   IF CHARX >= 0                        /* NECESSARY TO POINT OUT ERROR?      */
    THEN DO;                            /* SURE IS                            */
      BID = STRING$ -> BUF.ID;          /* GET BUFFER ID                      */
      CALL UT_SHOW_ERR( BID, CHARX, CR_CHARX, CR_COUNT, FLT_MSG$ );
                                        /* PRINT $ UNDER ERROR                */
      END;
/**
***   WRITE THE VAL FAULT MESSAGE.
**/
   FLT_MSG$ = PINCRC( FLT_MSG$, 5 );    /* POINT TO ACTUAL MESSAGE            */
   FLT_LEN  = FLT_LEN - 5;              /* CALC NUMBER OF CHARS TO PRINT      */
   CALL UT_WRITE_BUF( FLT_MSG$, FLT_LEN );
                                        /* WRITE THE VAL FAULT MESSAGE        */
 
   RETURN;
 
END UT_REPORT_VAL_FAULT;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_SBIN_VALUE   9 OCT 77   (PRY)   CONVERTS VALUE SPECIFICATION
***   TO SBIN WORD.
**/
 
UT_SBIN_VALUE: PROC( VALUE# ) NOAUTO;
 
%INCLUDE FILER_II5;
 
/***   GET VALUE   ***/
DCL   EV_GET_VALUE           ENTRY(2);
 
/***   CONVERT VALUE TO SBIN WORD   ***/
DCL   UT_ONE_WORD_VALUE      ENTRY(3);
 
/***   DEALLOCATE A BUFFER DESCRIPTOR AND ASSOCIATED BLOCK   ***/
DCL   UT_DEALLOC_BUF         ENTRY(1);
 
/********************
***   PARAMETERS:
**/
DCL   VALUE#         SBIN WORD ALIGNED; /* RETURNED VALUE                     */
 
/********************
***   LOCALS:
**/
DCL   VAL$            PTR ALIGNED AUTO; /* VALUE DESCRIPTOR POINTER           */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* BLOCK INDEX                        */
DCL   VAL_WIDTH SBIN WORD ALIGNED AUTO; /* WIDTH OF VALUE                     */
DCL   SAV_DESC$         PTR       ALIGNED   AUTO;
                                        /* SAVES CURRENT DESCRIPTOR POINTER   */
DCL   SAV_DWIDTH        SBIN WORD ALIGNED   AUTO;
                                        /* SAVES CURRENT VALUE WIDTH          */
 
/********************
***   GET THE VALUE; CONVERT TO SBIN WORD; FREE THE VALUE.
**/
   SAV_DESC$  = DESC$;                  /* SAVE THE CURRENT VALUE DESCRIPTOR  */
   SAV_DWIDTH = DWIDTH;                 /* AND ITS WIDTH                      */
   CALL EV_GET_VALUE( VAL$, BLK_IX );
   DESC$  = SAV_DESC$;                  /* RESTORE CURRENT VALUE DESCRIPTORS  */
   DWIDTH = SAV_DWIDTH;
   IF VAL_FAULT ~=0 THEN RETURN;
   VAL_WIDTH = VAL$ -> BUF.WIDTH;
   CALL UT_ONE_WORD_VALUE( VAL_WIDTH, BLK_IX, VALUE# );
   CALL UT_DEALLOC_BUF( VAL$ );
 
   RETURN;
 
END UT_SBIN_VALUE;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/********************************************************************/
/**
***   UT_SHOW_ERR   21 OCT 77   (PRY) PRINT A $ UNDER THE ERROR POSITION
***   ALONG WITH THE NAME OF THE ERRING BUFFER AND LINE NUMBER OF THE
***   ERROR.
**/
 
UT_SHOW_ERR: PROC( BID#, CHARX#, CR_CHARX#, CR_COUNT#, MSG$# );
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   OUTPUT A SINGLE CHARACTER   ***/
DCL   UT_OUTPUT_CHAR         ENTRY(1);
 
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   DISPLAY A VALUE IN SPECIFIED FORMAT   ***/
DCL   UT_DISPLAY             ENTRY(3);
 
/********************
***   PARAMETERS:
**/
DCL   BID#           SBIN WORD ALIGNED; /* ID OF ERROR BUFFER                 */
DCL   CHARX#            SBIN WORD ALIGNED;
                                        /* IX WHERE ERROR WAS DETECTED        */
DCL   CR_CHARX#      SBIN WORD ALIGNED; /* IX OF LAST CR                      */
DCL   CR_COUNT#         SBIN WORD ALIGNED;
                                        /* COUNT OF CRS PREVIOUS TO ERROR     */
DCL   MSG$#             PTR       ALIGNED;
                                        /* POINTER TO 4 CHARS ERROR MESSAGE   */
 
/********************
***   LOCALS:
**/
DCL   LCR_COUNT SBIN WORD ALIGNED AUTO; /* LOCAL CR_COUNT#                    */
DCL   LCHARX    SBIN WORD ALIGNED AUTO; /* LOCAL CHARX#                       */
DCL   SPACE_COUNT       SBIN WORD ALIGNED   AUTO;
                                        /* NUMBER OF SPACES TO PRINT          */
DCL   SPACE_NBR SBIN WORD ALIGNED AUTO; /* NUMBER OF SPACES PRINTED           */
DCL  LOCAL_TEMP SBIN WORD ALIGNED AUTO; /* LOCAL TEMPORARY                    */
DCL   LOCAL_TEMP$       PTR       ALIGNED   AUTO;
DCL   NON_SPACE_COUNT   SBIN WORD ALIGNED   AUTO;
                                   /* COUNTS NUMBER OF CHARS IN SHORT MESSAGE */
DCL   L66_VERSION       SBIN WORD ALIGNED   STATIC    SYMDEF INIT(0);
                                   /* FLAG INDICATING L66 VERSION OF FILER    */
DCL   SHORT_FMT         SBIN WORD ALIGNED   AUTO;
                                   /* FLAG INDICATING IF SHORT ERRMSG FMT     */
/********************
***   IF READING FROM A FILE, DISPLAY THE EXECUTING BUFFER.
**/
   CALL UT_FLUSH_BUF;
   IF READ_FILE ~= 0                    /* READING FROM A FILE?               */
    THEN DO;                            /* YES                                */
      LOCAL_TEMP$ = PINCRW( STRT_BUF_DESC$, (BID#*BUF_DESC_SIZE) );
                                   /* POINT TO EXECUTING BUFFER'S DESCRIPTOR  */
      TEMP1 = LOCAL_TEMP$ -> BUF.TYPE;  /* GET THE BUFFER'S TYPE              */
      IF TEMP1 = BT_VAR_BUF  OR  TEMP1 = BT_FIX_BUF
        OR  TEMP1 = BT_CMND_BUF  OR  TEMP1 = BT_VALUE
                                        /* ONLY PRINT IF REASONABLE           */
       THEN DO;
         LOCAL_TEMP = LOCAL_TEMP$ -> BUF.WIDTH;
                                        /* GET THE WIDTH OF THE BUFFER        */
         LOCAL_TEMP$ = LOCAL_TEMP$ -> BUF.BLK$;
                                        /* GET POINTER TO THE DATA            */
         CALL UT_DISPLAY( LOCAL_TEMP$, LOCAL_TEMP, DT_COMMAND );
         CALL UT_FLUSH_BUF;
         END;
      END;
/********************
***   DETERMINE WHICH ERROR MESSAGE FORMAT IS NEEDED.
***   LONG FORMAT(8 CHAR PROMPT ASSUMED): B[N] $ XXX RECORD # N
***   SHORT FORMAT(1 CHAR PROMPT ASSUMED): $ B[N] XXXX RECORD # N
**/
   IF READ_FILE ~= 0  OR  L66_VERSION = 0
    THEN SHORT_FMT = 0;
    ELSE SHORT_FMT = 1;
 
/**
***   CALC NUMBER OF SPACES REQUIRED.
**/
   LCHARX          = CHARX#;
   LCR_COUNT       = CR_COUNT#;
   IF SHORT_FMT =  0                    /* PRINT B[N] FIRST IF NOT SHORT      */
    THEN DO;
      NON_SPACE_COUNT = 4;              /* A[N]: 4 CHAR MINIMUM               */
      TEMP1           = 10;             /* CALC NUMBER OF SPACES TO SKIP      */
      DO WHILE (LCR_COUNT >= TEMP1);
         NON_SPACE_COUNT = NON_SPACE_COUNT + 1;
                                        /* ANOTHER DIGIT                      */
         TEMP1           = TEMP1 * 10;
         END;
      LCHARX  = LCHARX + 7 - NON_SPACE_COUNT - CR_CHARX#;
                              /* SKIP OVER PROMPT AND STUFF ON OTHER LINES    */
      END;
    ELSE DO;                       /* L66 VERSION: $ FIRST; SKIP >> PROMPT    */
      LCHARX = LCHARX - CR_CHARX# + 2;
      END;
   TEMP1 = LCHARX / (LINE_WID-2);       /* BREAK OUTPUT BY LINE  WIDTH        */
   SPACE_COUNT = LCHARX - TEMP1 * (LINE_WID-2);
   DO SPACE_NBR=1 TO SPACE_COUNT;
      CALL UT_OUTPUT_CHAR( CT_SPACE );  /* BLANK OUT BUFFER                   */
      END;
   IF SHORT_FMT ~= 0 THEN CALL UT_OUTPUT_CHARS( '$ ', 2 );
                                        /* PRINT $ NOW IF L66 VERSION         */
/**
***   PRINT THE NAME OF THE BUFFER.
**/
   LOCAL_TEMP = BID# + CT_A;            /* GET NAME OF ERRING BUFFER          */
   IF LOCAL_TEMP > CT_Z                 /* IF VALID NAME, PRINT IT            */
    THEN LOCAL_TEMP = CT_SPACE;
   CALL UT_OUTPUT_CHAR( LOCAL_TEMP );
 
/**
***   PRINT THE LINE NUMBER OF THE ERROR.
**/
   LOCAL_TEMP$ = ADDR( LOCAL_TEMP );    /* POINT TO VALUE                     */
   LOCAL_TEMP  = LCR_COUNT + 1;         /* CALC LINE NUMBER                   */
   CALL UT_OUTPUT_CHAR( CT_LBRACKET );  /* [                                  */
   CALL UT_DISPLAY( LOCAL_TEMP$, 36, -DT_DECIMAL );
                                        /* DISPLAY LINE NUMBER                */
   CALL UT_OUTPUT_CHAR( CT_RBRACKET );  /* ]                                  */
 
/**
***   PRINT THE $ UNDER THE ERROR.
**/
   IF SHORT_FMT = 0                     /* TIME TO PRINT $ IF NOT L66 VERSION */
    THEN CALL UT_OUTPUT_CHARS( ' $ ', 3 );
    ELSE CALL UT_OUTPUT_CHAR( CT_SPACE ); /* TIME FOR SPACE IF SO             */
 
/**
***   PRINT THE 4 CHAR ERROR MESSAGE.
**/
   LOCAL_TEMP$ = MSG$#;                 /* GET THE ERROR MESSAGE POINTER      */
   DO SPACE_NBR=0 TO 3;                 /* PRINT SHORT FORM MESSAGE           */
      LOCAL_TEMP = LOCAL_TEMP$ -> UBIN9#(SPACE_NBR);
      CALL UT_OUTPUT_CHAR( LOCAL_TEMP );
      END;
/**
***   IF READING FROM A FILE, PRINT THE RECORD NUMBER.
**/
   IF READ_FILE ~= 0                    /* FROM A FILE?                       */
    THEN DO;                            /* YES                                */
      CALL UT_OUTPUT_CHARS( ' record # ', 10 );
      LOCAL_TEMP$ = ADDR( FILE_RCOUNT );
      CALL UT_DISPLAY( LOCAL_TEMP$, 36, -DT_DECIMAL );
      END;
   CALL UT_FLUSH_BUF;
 
   RETURN;
 
END UT_SHOW_ERR;
/********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   XQC_SPECIAL_COMMANDS   17 JAN 78   (PRY)   EXECUTES SPECIAL
***   COMMANDS WHICH MAY GO UNDOCUMENTED.
**/
 
XQC_SPECIAL_COMMANDS: PROC;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   OUTPUT A STRING OF CHARACTERS   ***/
DCL   UT_OUTPUT_CHARS        ENTRY(2);
 
/***   DISPLAY A DATA ITEM IN SPECIFIED FORMAT   ***/
DCL   UT_DISPLAY             ENTRY(3);
 
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF           ENTRY;
 
/***   INCREMENT THE CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   CHECK FOR ILLEGAL JUNK    ***/
DCL   UT_JUNK_CHK            ENTRY;
 
/********************
***   LOCALS:
**/
DCL   LOCAL_PTR$        PTR       ALIGNED   AUTO;
                                        /* TEMP POINTER                       */
DCL   LOCAL_PTR$$       PTR       ALIGNED   AUTO;
                                        /* POINTER TO THE ABOVE               */
DCL   LOCAL_TEMP        SBIN WORD ALIGNED   AUTO;
                                        /* LOCAL WORD                         */
DCL   LOCAL_TEMP$       PTR       ALIGNED   AUTO;
                                        /* POINTER TO THE ABOVE               */
 
/********************
***   PRINT OUT DATA.
**/
   CALL UT_INC_CHARX;
   CALL UT_JUNK_CHK;
   IF VAL_FAULT ~= 0 THEN RETURN;
   LOCAL_PTR$$ = ADDR( LOCAL_PTR$ );
   LOCAL_TEMP$ = ADDR( LOCAL_TEMP );
   LOCAL_PTR$ = ADDR( DATA_BASE$ );
   CALL UT_OUTPUT_CHARS( 'DATA_BASE$     = ', 17 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, DT_MACHINE );
   CALL UT_OUTPUT_CHARS( ';  NBR_PAGES_USED   = ', 22 );
   LOCAL_TEMP$ = ADDR( NBR_PAGES_USED );
   CALL UT_DISPLAY( LOCAL_TEMP$, 36, -DT_DECIMAL );
   CALL UT_FLUSH_BUF;
   LOCAL_PTR$ = ADDR( STRT_BUF_DESC$ );
   CALL UT_OUTPUT_CHARS( 'STRT_BUF_DESC$ = ', 17 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, DT_MACHINE );
   LOCAL_PTR$ = ADDR( STRT_BUF_DESC_IX );
   CALL UT_OUTPUT_CHARS( ';  STRT_BUF_DESC_IX = ', 22 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, -DT_DECIMAL );
   CALL UT_FLUSH_BUF;
   LOCAL_PTR$ = PINCRW( DATA_BASE$, STRT_BLK_IX );
   CALL UT_OUTPUT_CHARS( 'STRT_BLK$      = ', 17 );
   CALL UT_DISPLAY( LOCAL_PTR$$, 36, DT_MACHINE );
   LOCAL_PTR$ = ADDR( STRT_BLK_IX );
   CALL UT_OUTPUT_CHARS( ';  STRT_BLK_IX      = ', 22 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, -DT_DECIMAL );
   CALL UT_FLUSH_BUF;
   LOCAL_PTR$ = PINCRW( DATA_BASE$, END_BLK_IX);
   CALL UT_OUTPUT_CHARS( 'END_BLK$       = ', 17 );
   CALL UT_DISPLAY( LOCAL_PTR$$, 36, DT_MACHINE );
   LOCAL_PTR$ = ADDR( END_BLK_IX );
   CALL UT_OUTPUT_CHARS( ';  END_BLK_IX       = ', 22 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, -DT_DECIMAL );
   CALL UT_FLUSH_BUF;
   LOCAL_PTR$ = ADDR( LOWEST_DEALLOC_IX );
   CALL UT_OUTPUT_CHARS( 'LOWEST_DEALLOC_IX = ', 20 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, -DT_DECIMAL );
   LOCAL_PTR$ = ADDR( LAST_FREE_IX );
   CALL UT_OUTPUT_CHARS( ';  LAST_FREE_IX = ', 18 );
   CALL UT_DISPLAY( LOCAL_PTR$, 36, - DT_DECIMAL );
   CALL UT_FLUSH_BUF;
   RETURN;
END XQC_SPECIAL_COMMANDS;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_SPLIT_BLK  12 AUG 77  (PRY)  EITHER (1) DIVIDES A USED BLOCK INTO
***   TWO BLOCKS--ONE OF BLK_SIZE#, THE OTHER OF THE REMAINDER OR (2)
***   LEAVES THE BLOCK WHOLE BUT SETS THE NUMBER OF UNUSED WORDS.
***   BLK_SIZE# INCLUDES THE THREE BLOCK INFO WORDS.  BLK_IX# IS THE
***   INDEX OF THE BLOCK TO SPLIT.
*/
 
AM_SPLIT_BLK: PROC( BLK_IX#, BLK_SIZE# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   BLK_IX#        SBIN WORD ALIGNED; /* INDEX OF BLOCK TO SPLIT            */
DCL   BLK_SIZE#         SBIN WORD ALIGNED;
                                        /* SIZE IN # WDS TO MAKE TOP BLOCK    */
 
/***************
***   LOCALS:
*/
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* LOCALIZES BLK_IX#                  */
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTS TO BLOCK                    */
DCL   SIZE      SBIN WORD ALIGNED AUTO; /* HOLDS SIZE OF BLOCK                */
DCL   NBR_LEFT_OVER     SBIN WORD ALIGNED   AUTO;
                                        /* USED TO CALC SPLIT POSSIBILITY     */
DCL   BLK_SIZE  SBIN WORD ALIGNED AUTO; /* LOCALIZES BLK_SIZE#                */
 
/***************
***   CALCULATE UTILIZATION AMOUNTS.
*/
   BLK_IX        = BLK_IX#;
   BLK_SIZE      = ( (BLK_SIZE# + 1) / 2) * 2;
                                        /* MOVE SIZE TO NEXT DW BOUNDARY      */
   BLK_PTR$      = PINCRW( DATA_BASE$, BLK_IX );
                                        /* POINT TO BLOCK                     */
   SIZE         = BLK_PTR$ -> BLK.SIZE; /* GET BLOCK'S CURRENT SIZE           */
   NBR_LEFT_OVER = SIZE - BLK_SIZE;
                                        /* CALC SIZE OF SPLIT OFF BLOCK       */
/*
***   CHECK UTILIZATION.
*/
   IF NBR_LEFT_OVER >= 4                /* HAVE AT LEAST ONE DATA WORD/BLOCK  */
    THEN DO;                            /* SPLIT BLOCK                        */
         /*
         ***   SET UP BLOCK FOOTER (HEADER HAS ID SET).
         */
      BLK_PTR$ -> BLK.SIZE      = BLK_SIZE;
                                        /* SET SIZE IN HDR                    */
      TPTR1$                    = PINCRW( BLK_PTR$, BLK_SIZE-2  );
                                        /* POINT TO FOOTER                    */
      TPTR1$ -> BLK_FTR.SIZE    = BLK_SIZE;
                                        /* SET SIZE IN FOOTER                 */
      TPTR1$ -> BLK_FTR.ID      = BLK_PTR$ -> BLK.ID;
                                        /* SET ID                             */
      TPTR1$ -> BLK_FTR.NUNUSED = 0;    /* NO UNUSED WORDS                    */
         /*
         ***   SET UP UNUSED BLOCK.
         */
      TPTR1$             = PINCRW( TPTR1$, 2 );
                                        /* POINT TO HEADER OF UNUSED BLOCK    */
      TPTR1$ -> BLK.ID = UNUSED_BUF_ID; /* UNUSED ID                          */
      TPTR1$ -> BLK.SIZE = NBR_LEFT_OVER; /* SET SIZE                         */
      TPTR2$             = PINCRW( TPTR1$, NBR_LEFT_OVER-1 );
                                        /* POINT TO UNUSED BLOCK'S FOOTER     */
      TPTR2$ -> WRD#     = TPTR1$ -> WRD#;
                                        /* SET FOOTER                         */
      IF BLK_IX <= LOWEST_DEALLOC_IX
       THEN LOWEST_DEALLOC_IX = BLK_IX + BLK_SIZE;
                                   /* SAVE IX OF LOWEST DEALLOCATED BLOCK     */
      END;
    ELSE DO;                       /* NOT ENOUGH TO SPLIT INTO TWO BLOCKS     */
      TPTR1$                    = PINCRW( BLK_PTR$, SIZE-2 );
                                        /* POINT TO FOOTER                    */
      TPTR1$ -> BLK_FTR.SIZE    = SIZE; /* SET SIZE                           */
      TPTR1$ -> BLK_FTR.ID      = BLK_PTR$ -> BLK.ID;
                                        /* SET ID                             */
      TPTR1$ -> BLK_FTR.NUNUSED = NBR_LEFT_OVER;
                                        /* SET # UNUSED WORDS                 */
      IF BLK_IX < LOWEST_DEALLOC_IX
       THEN LOWEST_DEALLOC_IX = BLK_IX;
                              /* Save ix of lowest block with unused words    */
       ELSE IF BLK_IX+SIZE > LOWEST_DEALLOC_IX
          THEN LOWEST_DEALLOC_IX = BLK_IX + SIZE; /* None unused now          */
      END;
 
   RETURN;
 
END AM_SPLIT_BLK;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_TEXT   24 AUG 77   (PRY)   CONVERT TEXT STRING TO VALUE.
***   THE CURRENT CHAR IS THE QUOTE CHAR--EITHER '''' OR '"'.
*/
 
EV_TEXT: PROC NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
 
/***   ADD BITS TO THE CURRENT VALUE   ***/
DCL   EV_ADD_VAL_BITS        ENTRY(2);
 
 
/***************
***   LOCALS:
*/
DCL   QUOTE     SBIN WORD ALIGNED AUTO; /* QUOTE CHAR                         */
                                        /* RESET WHEN STRING END FOUND        */
 
/***************
***   INITIALIZE CONVERSION.
*/
   QUOTE     = C;                       /* GET QUOTE CHAR                     */
/*
***   CONVERT STRING TO VALUE AND CONCATENATE TO CURRENT VALUE.
*/
   DO WHILE (CHARX <= CHARX_MAX);
      CALL UT_INC_CHARX;                /* GET NEXT CHAR                      */
      DO WHILE (CHARX <= CHARX_MAX  AND  C ~= QUOTE);
         IF C = CT_CR                   /* ILLEGAL CR IN TEXT STRING?         */
          THEN DO;                      /* YES                                */
            VAL_FAULT = 54;
         /*E* 54V EV_TEXT: ILLEGAL CR IN TEXT STRING */
            RETURN;
            END;
         CALL EV_ADD_VAL_BITS( C, 9 );  /* ADD NEXT CHAR TO VALUE             */
         IF VAL_FAULT ~= 0 THEN RETURN;
                                        /* CHECK IF STORAGE PROBLEMS          */
         CALL UT_INC_CHARX;             /* GET NEXT CHAR                      */
         END;
         /*
         ***   HANDLE TWO ADJACENT QUOTES IN STRING IF NECESSARY.
         */
      IF CHARX <= CHARX_MAX  AND  C = QUOTE
                                        /* QUOTE CHAR?                        */
       THEN DO;                         /* YES                                */
         CALL UT_INC_CHARX;             /* GET NEXT CHAR                      */
         IF CHARX > CHARX_MAX  OR  C ~= QUOTE
                                        /* END OF STRING?                     */
          THEN DO;                      /* YES: NORMAL END                    */
            VAL_FAULT = 0;              /* SUCCESS                            */
            RETURN;
            END;
          ELSE DO;                      /* NO: IMPLIES SINGLE QUOTE CHAR      */
            CALL EV_ADD_VAL_BITS( C, 9 );
                                        /* ADD QUOTE TO STRING                */
            IF VAL_FAULT ~= 0 THEN RETURN;
                                        /* PROBLEMS?                          */
            END;
         END;
      END;
/*
***   WE'RE STILL TRYING TO FIND STRING END, ERROR.
*/
   VAL_FAULT = 12;      /*E* 12V EV_TEXT: CLOSING QUOTE IS MISSING      */
 
   RETURN;
 
END EV_TEXT;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_TEXTC   24 AUG 77   (PRY)   CONVERTS A TEXTC STRING TO A VALUE
***   AND CONCATENATES IT TO THE CURRENT VALUE.
*/
 
EV_TEXTC: PROC NOAUTO;
%INCLUDE FILER_II5;
 
/***   CONVERT TEXT STRING TO N BIT VALUE   ***/
DCL   EV_TEXT                ENTRY;
 
/***   ADD BITS TO THE CURRENT VALUE   ***/
DCL   EV_ADD_VAL_BITS             ENTRY(2);
 
 
/***************
***   LOCALS:
*/
DCL   OLD_DWIDTH        SBIN WORD ALIGNED   AUTO;
                                        /* SAVES CURRENT VALUE WIDTH          */
DCL   NBR_CHARS         SBIN WORD ALIGNED   AUTO;
                                        /* USED TO CALC STRING LENGTH         */
 
/***************
***   SAVE CURRENT VALUE WIDTH AND MAKE ROOM FOR COUNT BYTE.
*/
   OLD_DWIDTH = DWIDTH;
   CALL EV_ADD_VAL_BITS( 0, 9 );        /* RESERVE ROOM FOR TEXTC COUNT       */
/*
***   USE TEXT ROUTINE TO CONVERT THE STRING.
*/
   CALL EV_TEXT;
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF ERROR                    */
/*
***   CALC THE NUMBER OF CHARS IN THE STRING AND STORE INTO THE VALUE.
*/
   NBR_CHARS  = (DWIDTH - OLD_DWIDTH) / 9 - 1;
   IF NBR_CHARS > 511         /* POSSIBLE TO REPRESENT LENGTH WITH 9 BITS?    */
    THEN VAL_FAULT = 13;
                    /*E* 13V EV_TEXTC: TOO MANY CHARS IN TEXTC STRING         */
    ELSE DO;                            /* TEXTC STRING OK                    */
      TPTR1$ = PINCRB( DESC$ -> BUF.BLK$, OLD_DWIDTH );
                                        /* MOVE COUNT BYTE TO STRING          */
      TPTR2$ = PINCRC( ADDR( NBR_CHARS ), 3 );
      TEMP1 = 9;                        /* MOVE A BYTE OF BITS                */
      TPTR1$ -> BITS = TPTR2$ -> BITS;
                                        /* ADD COUNT                          */
      END;
 
   RETURN;
 
END EV_TEXTC;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
TYPES: PROC;
 
/*** NAMED CHARACTER CODES ***/
DCL   CT_NUL            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(0);
DCL   CT_SOH            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(1);
DCL   CT_STX            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(2);
DCL   CT_ETX            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(3);
DCL   CT_EOT            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(4);
DCL   CT_ENQ            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(5);
DCL   CT_ACK            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(6);
DCL   CT_BEL            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(7);
DCL   CT_BS             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(8);
DCL   CT_HT             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(9);
DCL   CT_LF             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(10);
DCL   CT_VT             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(11);
DCL   CT_FF             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(12);
DCL   CT_CR             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(13);
DCL   CT_SO             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(14);
DCL   CT_SI             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(15);
DCL   CT_DLE            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(16);
DCL   CT_DC1            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(17);
DCL   CT_DC2            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(18);
DCL   CT_DC3            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(19);
DCL   CT_DC4            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(20);
DCL   CT_NAK            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(21);
DCL   CT_SYN            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(22);
DCL   CT_ETB            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(23);
DCL   CT_CAN            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(24);
DCL   CT_EM             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(25);
DCL   CT_SS             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(26);
DCL   CT_ESC            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(27);
DCL   CT_FS             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(28);
DCL   CT_GS             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(29);
DCL   CT_RS             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(30);
DCL   CT_US             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(31);
DCL   CT_SPACE          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(32);
DCL   CT_EXCLAMATION    SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(33);
DCL   CT_DQUOTE         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(34);
DCL   CT_POUND          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(35);
DCL   CT_DOLLAR         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(36);
DCL   CT_PERCENT        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(37);
DCL   CT_AMPERSAND      SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(38);
DCL   CT_SQUOTE         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(39);
DCL   CT_LPAREN         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(40);
DCL   CT_RPAREN         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(41);
DCL   CT_ASTERISK       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(42);
DCL   CT_PLUS           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(43);
DCL   CT_COMMA          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(44);
DCL   CT_MINUS          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(45);
DCL   CT_PERIOD         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(46);
DCL   CT_SLASH          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(47);
DCL   CT_0              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(48);
DCL   CT_9              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(57);
DCL   CT_COLON          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(58);
DCL   CT_SEMI_COLON     SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(59);
DCL   CT_LCARAT         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(60);
DCL   CT_EQUAL          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(61);
DCL   CT_RCARAT         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(62);
DCL   CT_QUESTION       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(63);
DCL   CT_AT             SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(64);
DCL   CT_A              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(65);
DCL   CT_B              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(66);
DCL   CT_C              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(67);
DCL   CT_D              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(68);
DCL   CT_E              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(69);
DCL   CT_F              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(70);
DCL   CT_G              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(71);
DCL   CT_H              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(72);
DCL   CT_I              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(73);
DCL   CT_J              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(74);
DCL   CT_K              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(75);
DCL   CT_L              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(76);
DCL   CT_M              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(77);
DCL   CT_N              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(78);
DCL   CT_O              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(79);
DCL   CT_P              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(80);
DCL   CT_Q              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(81);
DCL   CT_R              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(82);
DCL   CT_S              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(83);
DCL   CT_T              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(84);
DCL   CT_U              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(85);
DCL   CT_V              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(86);
DCL   CT_W              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(87);
DCL   CT_X              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(88);
DCL   CT_Y              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(89);
DCL   CT_Z              SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(90);
DCL   CT_LBRACKET       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(91);
DCL   CT_RSLASH         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(92);
DCL   CT_RBRACKET       SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(93);
DCL   CT_UPARROW        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(94);
DCL   CT_UNDERSCORE     SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(95);
DCL   CT_ACCENT         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(96);
DCL   CT_LC_A           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(97);
DCL   CT_LC_Z           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(122);
DCL   CT_LBRACE         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(123);
DCL   CT_BAR            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(124);
DCL   CT_RBRACE         SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(125);
DCL   CT_TILDE          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(126);
DCL   CT_DEL            SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(127);
 
/*** DISPLAY TYPES AND CHAR CODES ***/
DCL   DT_TEXT           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(1);
DCL   FT_TEXT           SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(84);
DCL   DT_TEXTC          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(2);
DCL   FT_TEXTC          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(76);
DCL   DT_DECIMAL        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(3);
DCL   FT_DECIMAL        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(73);
DCL   DT_NOTHING        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(4);
DCL   FT_NOTHING        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(78);
DCL   DT_BASED          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(5);
DCL   FT_BASED          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(64);
DCL   DT_MIXED          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(6);
DCL   FT_MIXED          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(81);
DCL   DT_COMMAND        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(7);
DCL   FT_COMMAND        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(88);
DCL   DT_WIDTH          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(8);
DCL   FT_WIDTH          SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(87);
DCL   DT_NTEXT          SBIN WORD ALIGNED  CONSTANT   SYMDEF   INIT(9);
DCL   FT_NTEXT          SBIN WORD ALIGNED  CONSTANT   SYMDEF   INIT(83);
DCL   FT_DUMP           SBIN WORD ALIGNED  CONSTANT   SYMDEF   INIT(68);
DCL   DT_DUMP           SBIN WORD ALIGNED  CONSTANT   SYMDEF   INIT(10);
DCL   DT_MACHINE        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(11);
DCL   FT_MACHINE        SBIN WORD ALIGNED   CONSTANT  SYMDEF    INIT(77);
 
END TYPES;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
 
/*********************************************************************/
/**
***   UT_WRITE_BUF   14 SEP 77   (PRY)   WRITES CONTENTS OF THE
***   OUTPUT BUFFER.
**/
 
UT_WRITE_BUF: PROC( OUTBUF$#, NBR_CHARS# ) NOAUTO;
 
%INCLUDE FILER_II5;
%INCLUDE CP_6;
 
/********************
***   LIST OUTPUT DCB.
**/
DCL      M$LO     DCB;
 
/********************
***   LIST OUTPUT FPT.
**/
%FPT_WRITE ( FPTN=LIST_FPT, DCB=M$LO, STCLASS=STATIC, WAIT=YES );
 
/********************
***   PARAMETERS:
**/
DCL   OUTBUF$#          PTR    ALIGNED; /* POINTER TO OUTPUT BUFFER           */
DCL   NBR_CHARS#     SBIN WORD ALIGNED; /* NUMBER OF CHARACTERS TO OUTPUT     */
 
/********************
***   LOCALS:
**/
DCL   OUTBUF$         PTR ALIGNED AUTO; /* LOCAL BUFFER POINTER               */
DCL   NBR_CHARS SBIN WORD ALIGNED AUTO; /* LOCALIZES NBR_CHARS#               */
DCL NBR_OUT_CHARS SBIN WORD ALIGNED AUTO; /* NUMBER OF CHARS TO OUTPUT        */
/********************
***   LOCALIZE PARAMETERS.
**/
   OUTBUF$   = OUTBUF$#;                /* GET OUTPUT BUFFER POINTER          */
   NBR_CHARS = NBR_CHARS#;              /* GET NUEBER OF CHARS TO OUTPUT      */
 
/********************
***   BREAK UP OUTPUT LINES.
**/
   DO WHILE (NBR_CHARS > 0);            /* OUTPUT 'TIL ALL DONE               */
      IF NBR_CHARS > LINE_WID           /* NEED TO BREAK LINE?                */
       THEN NBR_OUT_CHARS = LINE_WID;   /* YES                                */
       ELSE NBR_OUT_CHARS = NBR_CHARS;  /* NO                                 */
         /**
         ***   SET UP OUTPUT FPT AND WRITE LINE.
         **/
      LIST_FPT.BUF_.BOUND = NBR_OUT_CHARS - 1; /* SET # CHARS TO WRITE        */
      LIST_FPT.BUF_.BUF$  = OUTBUF$;    /* SET BUFFER POINTER                 */
      CALL M$WRITE( LIST_FPT ) ALTRET ( UT_WRITE_BUF_ALTRET );
         /**
         ***   COUNT DOWN CHARS WRITTEN; MOVE BUFFER PTR TO
         ***   NEXT SEGMENT.
         **/
      NBR_CHARS = NBR_CHARS - NBR_OUT_CHARS; /* COUNT DOWN CHARS              */
      OUTBUF$ = PINCRC( OUTBUF$, NBR_OUT_CHARS ); /* POINT TO NEXT SEGMENT    */
      END;
 
   RETURN;
 
 
UT_WRITE_BUF_ALTRET:
   VAL_FAULT = 24;
         /*E* 24V UT_WRITE_BUF: ERROR WRITING LIST OUTPUT */
   RETURN;
 
END UT_WRITE_BUF;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_EXPAND_BLK  17 AUG 77  (PRY)  EXPANDS BLOCK BLK_IX# TO BLK_SIZE#
***   WORDS.
*/
 
AM_EXPAND_BLK: PROC( BLK_IX#, BLK_SIZE# ) NOAUTO;
%INCLUDE FILER_II5;
/***   ALLOCATE A NEW BLOCK OF BLOCK SPACE   ***/
DCL   AM_ALLOC_NEW_BLK       ENTRY(2);
 
/***   SPLIT OFF UNUSED AREA FROM A USED BLOCK   ***/
DCL   AM_SPLIT_BLK           ENTRY(2);
 
/***   ROTATE A REGION OF BLOCK SPACE   ***/
DCL   AM_ROTATE_BLKS         ENTRY(3);
 
/***   MOVE A BLOCK   ***/
DCL   AM_MOVE_BLK            ENTRY(3);
 
/***   INDICATE THAT BLOCKS HAVE BEEN MOVED   ***/
DCL   UT_INDICATE_COMPACTION ENTRY(2);
 
/***************
***   PARAMETERS:
*/
DCL   BLK_IX#        SBIN WORD ALIGNED; /* IX OF BLOCK TO EXPAND              */
DCL   BLK_SIZE#         SBIN WORD ALIGNED;
                                        /* NUMBER OF WORDS TO EXPAND BLOCK TO */
 
/***************
***   LOCALS:
*/
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* LOCALIZES BLK_IX#                  */
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTER TO CURRENT BLOCK           */
DCL   BLK_SIZE  SBIN WORD ALIGNED AUTO; /* LOCALIZES BLK_SIZE#                */
DCL   SIZE              SBIN WORD ALIGNED   AUTO;
                                        /* USED TO COMPUTE POSSIBLE SIZES     */
DCL   PSIZE             SBIN WORD ALIGNED   AUTO;
                                        /* SAVES CURRENT SIZE OF BLOCK        */
DCL   NEXT_SIZE SBIN WORD ALIGNED AUTO; /* SIZE OF NEXT BLOCK                 */
DCL   PREV_SIZE SBIN WORD ALIGNED AUTO; /* SIZE OF PREVIOUS BLOCK             */
DCL   PREV_UNUSED       SBIN WORD ALIGNED   AUTO;
                              /* NUMBER OF UNUSED WORDS IN PREVIOUS BLOCK     */
DCL   NBR_NEEDED        SBIN WORD ALIGNED   AUTO;
                              /* NUMBER OF WORDS NECESSARY TO EXPAND BLOCK BY */
DCL   NBR_PAGES_NEEDED  SBIN WORD ALIGNED   AUTO;
                    /* NUMBER OF PAGES NECESSARY TO EXPAND BLOCK SPACE BY     */
DCL  ALLOCATING SBIN WORD ALIGNED AUTO; /* CONTROLS ALLOCATION LOOP           */
DCL  LOCAL_TEMP SBIN WORD ALIGNED AUTO; /* USED FOR RETURNED ARGS             */
 
/***************
***   LOCALIZE ARGUMENTS; GET OTHER PARAMETERS.
*/
   BLK_IX   = BLK_IX#;
   BLK_SIZE = ( (BLK_SIZE# + 1) / 2) * 2; /* EVEN OUT BLOCK SIZE              */
   BLK_PTR$ = PINCRW( DATA_BASE$, BLK_IX ); /* POINT TO BLOCK                 */
   PSIZE    = BLK_PTR$ -> BLK.SIZE;     /* GET ITS PRESENT SIZE               */
/*
***   MAKE SURE BLOCK ISN'T TOO LARGE TO STORE SIZE IN BLK.SIZE.
*/
   IF BLK_SIZE > MAX_BLK_SIZE
    THEN DO;                            /* TOO LARGE                          */
      VAL_FAULT = 5;
 /*E* 5V AM_EXPAND_BLK: ATTEMPT TO CREATE A SINGLE BLOCK WHICH IS TOO LARGE   */
      RETURN;
      END;
/*
***   EXPANSION IS EASY IF THIS BLOCK HAS ENOUGH UNUSED WORDS.
*/
   NBR_NEEDED = BLK_SIZE - PSIZE;       /* CALC NUMBER OF WORDS NEEDED        */
   TPTR1$                    = PINCRW( BLK_PTR$, PSIZE-2 );
                                        /* POINT TO FOOTER                    */
   IF NBR_NEEDED <= 0                   /* ENOUGH UNUSED WORDS?               */
    THEN DO;                            /* YES                                */
      TPTR1$ -> BLK_FTR.NUNUSED = - NBR_NEEDED;
                                        /* ADJUST # UNUSED WORDS              */
      RETURN;
      END;
    ELSE TPTR1$->BLK_FTR.NUNUSED = 0;   /* Must use all of block              */
/*
***  IF FOLLOWING BLOCK IS UNUSED, WE MIGHT STEAL SOME EXTRA
***  WORDS FROM IT.
*/
   SIZE   = PSIZE;
   TPTR1$ = PINCRW( BLK_PTR$, PSIZE );
                                        /* POINT TO NEXT BLOCK'S HEADER       */
   IF TPTR1$ -> BLK.ID = UNUSED_BUF_ID  /* BLOCK IN USE?                      */
    THEN DO;                            /* NO                                 */
      NEXT_SIZE = TPTR1$ -> BLK.SIZE;   /* GET ITS SIZE                       */
      SIZE      = SIZE + NEXT_SIZE;     /* CALC TOTAL POSSIBLE SIZE           */
      IF SIZE >= BLK_SIZE               /* ENOUGH WORDS TO EXPAND INTO?       */
       THEN DO;                         /* YES                                */
         BLK_PTR$ -> BLK.SIZE = SIZE;   /* ADJUST SIZE OF BLOCK               */
         CALL AM_SPLIT_BLK( BLK_IX, BLK_SIZE );
                              /* SPLIT BLOCK MADE FROM USED AND UNUSED BLOCKS */
         RETURN;
         END;
      END;
    ELSE NEXT_SIZE = 0;                 /* NO WORDS FROM NEXT BLOCK           */
/*
***   THERE WASN'T ENOUGH EXTRA IN LOWER BLOCK.  TRY PREVIOUS BLOCK.
*/
   TPTR2$     = PINCRW( BLK_PTR$, -2 ); /* POINT TO ITS FOOTER                */
   PREV_UNUSED = ( (TPTR2$ -> BLK_FTR.NUNUSED) / 2) * 2;
                                        /* GET NUMBER OF UNUSED WORDS         */
   SIZE        = SIZE + PREV_UNUSED;    /* CALC POSSIBLE BLOCK SIZE           */
   IF SIZE >= BLK_SIZE             /* ENOUGH WORDS IF STOLEN FROM PREV BLK?   */
    THEN DO;                            /* YES                                */
      IF TPTR2$ -> BLK_FTR.ID < UNUSED_BUF_ID
                                        /* IS PREVIOUS BLOCK IN USE?          */
       THEN DO;                         /* YES: REMOVE UNUSED PORTION         */
         PREV_SIZE              = TPTR2$ -> BLK_FTR.SIZE;
                                        /* GET PREV BLOCK'S SIZE              */
         TPTR1$                 = PINCRW( BLK_PTR$, -PREV_SIZE );
                                        /* POINT TO PREV BLOCK'S HEADER       */
         PREV_SIZE              = PREV_SIZE - PREV_UNUSED;
                                        /* ADJUST BLOCK'S SIZE                */
         TPTR1$ -> BLK.SIZE     = PREV_SIZE;
         TPTR2$                 = PINCRW( TPTR1$, PREV_SIZE-2 );
                                        /* POINT TO PREV BLOCK'S NEW FOOTER   */
         TPTR2$ -> BLK_FTR.SIZE = PREV_SIZE;
                                        /* SET NEW SIZE IN FOOTER             */
         TPTR2$ -> BLK_FTR.ID   = TPTR1$ -> BLK.ID;
                                        /* SET ID                             */
         TPTR2$ -> BLK_FTR.NUNUSED = 0; /* NO WORDS UNUSED NOW                */
         END;
         /*
         ***   MOVE BLOCK INTO PREVIOUS BLOCK'S UNUSED AREA.
         */
      BLK_IX# = BLK_IX - PREV_UNUSED;   /* CALC BLOCK'S NEW IX                */
      CALL AM_MOVE_BLK( BLK_IX, BLK_IX#, PSIZE );
                                   /* MOVE BLOCK UPWARD INTO VACATED SPACE    */
      BLK_IX = BLK_IX#;
      CALL UT_INDICATE_COMPACTION( BLK_IX, BLK_IX );
                                        /* RECORD BLOCK MOVEMENT              */
      BLK_PTR$             = PINCRW( DATA_BASE$, BLK_IX );
                                        /* POINT TO BLOCK'S NEW HEADER        */
      BLK_PTR$ -> BLK.SIZE = SIZE;      /* SET NEW SIZE                       */
      CALL AM_SPLIT_BLK( BLK_IX, BLK_SIZE );
                                        /* SPLIT BLOCK                        */
      RETURN;
      END;
 
/***************
***   WE WEREN'T ABLE TO EXPAND THE BLOCK BY STEALING SURROUNDING
***   FREE WORDS.   TRY THE HEAVY-DUTY STUFF.
***   IF BLOCK IS NOT THE LAST BLOCK IN THE BLOCK SPACE,
***   ROTATE BLOCK TO THE LAST POSITION.
*/
   IF BLK_IX+PSIZE < END_BLK_IX         /* IS BLOCK LAST BLOCK?               */
    THEN DO;                            /* NO                                 */
      LOCAL_TEMP = END_BLK_IX - 1;
                                        /* CALC IX OF LAST USED WORD          */
      CALL AM_ROTATE_BLKS( BLK_IX, LOCAL_TEMP, PSIZE );
                              /* ROTATE TO MAKE BLOCK LAST BLOCK OF SPACE     */
      IF BLK_IX < LOWEST_DEALLOC_IX THEN LOWEST_DEALLOC_IX = BLK_IX;
               /* MAKE SURE LOWEST DEALLOC IX DOESN'T POINT WITHIN A BLOCK    */
      CALL UT_INDICATE_COMPACTION( BLK_IX, LOCAL_TEMP );
                                        /* RECORD BLOCK MOVEMENT              */
      BLK_IX = END_BLK_IX - PSIZE;      /* CALC NEW IX OF BLOCK               */
      END;
/*
***   BLOCK IS THE LAST BLOCK.  TRY TO EXPAND INTO UNUSED SPACE.
*/
   CALL AM_ALLOC_NEW_BLK( NBR_NEEDED, LOCAL_TEMP );
               /* ALLOCATE A NEW UNUSED BLOCK AT THE END OF THE BLOCK SPACE   */
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF PROBLEMS                 */
/*
***   BLOCK CAN BE EXPANDED INTO NEW UNUSED BLOCK.
*/
   BLK_IX                    = LOCAL_TEMP - PSIZE;
                                        /* GET IX OF BLOCK'S NEW POSITION     */
   BLK_PTR$                  = PINCRW( DATA_BASE$, BLK_IX );
                                        /* POINT TO IT                        */
   BLK_PTR$ -> BLK.SIZE     = BLK_SIZE; /* SET SIZE                           */
   TPTR1$                    = PINCRW( BLK_PTR$, BLK_SIZE-2 );
                                        /* POINT TO BLOCK'S FOOTER            */
   TPTR1$ -> BLK_FTR.SIZE   = BLK_SIZE; /* SET IT UP                          */
   TPTR1$ -> BLK_FTR.NUNUSED = 0;
   TPTR1$ -> BLK_FTR.ID      = BLK_PTR$ -> BLK.ID;
   BLK_IX#                   = BLK_IX;  /* RETURN IX OF BLOCK                 */
   IF LOWEST_DEALLOC_IX >= BLK_IX THEN LOWEST_DEALLOC_IX = END_BLK_IX;
                                        /* Would be mid-block otherwise       */
 
   VAL_FAULT = 0;                       /* NO PROBLEMS                        */
   RETURN;
 
END AM_EXPAND_BLK;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_Z_REG   24 AUG 77   (PRY)   CONVERTS Z REGISTER REFERENCE TO
***   VALUE.   CURRENT CHAR IS 'Z'.
*/
 
EV_Z_REG: PROC NOAUTO;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
 
/***   ADD BITS TO THE CURRENT VALUE   ***/
DCL   EV_ADD_VAL_BITS        ENTRY(2);
 
 
/***************
***   GET Z REGISTER NAME.
*/
   CALL UT_INC_CHARX;
   IF CHARX > CHARX_MAX                 /* ONE THERE?                         */
    THEN VAL_FAULT = 3;
                    /*E* 3V EV_Z_REG: EXPECTED Z-REGISTER NAME MISSING        */
    ELSE DO;                            /* HAVE A Z REG NAME; CHECK IT        */
      IF C < CT_A OR C > CT_Z           /* ALPHA CHAR?                        */
       THEN VAL_FAULT = 3;              /* NO                                 */
       ELSE DO;                         /* HAVE Z REG NAME                    */
         C = Z_REG$ -> WORD#(C - CT_A); /* GET Z REGISTER CONTENTS            */
         CALL EV_ADD_VAL_BITS( C, 36 ); /* ADD ALL 36 BITS TO VALUE           */
         IF VAL_FAULT ~= 0 THEN RETURN; /* PROBLEMS?                          */
         CALL UT_INC_CHARX;             /* GET NEXT CHAR                      */
         END;
      END;
 
   RETURN;
 
END EV_Z_REG;
 
/*********************************************************************/
