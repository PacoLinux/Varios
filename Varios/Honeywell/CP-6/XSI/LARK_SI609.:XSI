/*M* LARK_SI609  LARK_ACTIVATE_CMD and LARK_DEACTIVATE_CMD   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_ACTIVATE_CMD
   PURPOSE:       Process the ACTIVATE command
   DESCRIPTION:   This module receives the parse tree for a ACTIVATE command
                  and processes it into data structures used with the M$ACTIVATE.
*/
/*D*
   NAME:          LARK_ACTIVATE_CMD
   CALL:          CALL LARK_ACTIVATE_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_OCTALSTRING_BITSTRING
                  LARK_PROCESS_FID
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
                  LARK_REPORT_SUBCMD_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   SCRATCH:       VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   ACTIVATE_CMD syntax =
                     'ACT/IVATE' ;
                     [ CG_FID ] ;
                     ACTIVATE_OPTION_LIST
*/
 
%EJECT ;
LARK_ACTIVATE_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_OCTALSTRING_BITSTRING ;
%LARK_OPEN_TEMPSTATION ;
%LARK_PROCESS_FID ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_SUBCMD_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%LARK_PARSEBLKS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPT_ACTIVATE_CG,
         STCLASS              = CONSTANT,
         DCB                  = M$CG ) ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPTACTIVATE_CG,
         STCLASS              = AUTO ) ;
 
%VLP_STATION
       ( FPTN                 = VLP_STATION,
         STCLASS              = CONSTANT ) ;
 
%VLP_STATION
       ( FPTN                 = VLPSTATION_ACT,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
DCL      B$TCB$               PTR SYMREF ;
DCL      BLK$                 PTR ;
DCL      I                    SBIN ;
DCL      SUBLK$               PTR ;
DCL      SYM$                 PTR ;
DCL      TEMP_YES_NO          BIT ( 1 ) ;
   DCL      TEMP_NUM             SBIN;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %ACTIVATE_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
/*
   Processing the CG_FID if one has been specified and opening the temporary
   station.
*/
 
IF ( BLK$->OUT$SYM.CODE = %CG_FID ) THEN DO ;
   CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
         ALTRET ( ALT ) ;
END ;
 
CALL LARK_OPEN_TEMPSTATION ( %TRUE )
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
/*
   Processing the ACTIVATE_OPTION_LIST.
*/
 
FPTACTIVATE_CG = FPT_ACTIVATE_CG ;
FPTACTIVATE_CG.V_ = VECTOR ( FPTACTIVATE_CG.V ) ;
 
IF (M$CTRLCG$->F$DCB.FCD#) AND (M$CTRLCG$->F$DCB.AU#)
   THEN
      /* USE USER AU STATION FOR THE CALL */
      FPTACTIVATE_CG.V.DCB# = M$CTRLCG_DCBNUM;
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
END ;
 
IF ( BLK$->OUT$BLK.CODE ~= %ACTIVATE_OPTION_LIST ) OR
   ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
   IF ( SUBLK$->OUT$BLK.NSUBLKS > 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM$ = SUBLK$->OUT$BLK.SUBLK$( 0 ) ;
   DO SELECT ( SYM$->OUT$BLK.CODE ) ;
      SELECT ( %YES ) ;
         TEMP_YES_NO = %YES# ;
      SELECT ( %NO ) ;
         TEMP_YES_NO = %NO# ;
         SELECT ( %NUMREADS );
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
      SELECT ( %STATION_WILDC, %RESOURCE, %ATTRIBUTE, %TYC ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
   DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
      SELECT ( %ABTET_OPT ) ;
         FPTACTIVATE_CG.V.ABTET# = TEMP_YES_NO ;
      SELECT ( %ABTREAD_OPT ) ;
         CALL LARK_OCTALSTRING_BITSTRING ( SYM$->OUT$SYM.TEXT,
                                           SYM$->OUT$SYM.COUNT,
                                           FPTACTIVATE_CG.V.ABTREAD#,
                                           12 ) ;
         SELECT ( %CGCP_BIN_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.BIN# = TEMP_YES_NO ;
         SELECT ( %CGCP_BP_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.BP# = TEMP_YES_NO ;
         SELECT ( %CGCP_CONT_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.CONT# = TEMP_YES_NO ;
         SELECT ( %CGCP_MAXRD_PARM ) ;
            IF ( TEMP_NUM <    3 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMREADS#,
                                               3 ) ;
            END ; ELSE DO ;
               FPTACTIVATE_CG.V.MAXRD# = TEMP_NUM ;
            END ;
         SELECT ( %CGCP_MINRD_PARM ) ;
            IF ( TEMP_NUM < 2 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMREADS#,
                                               3 ) ;
            END ; ELSE DO ;
               FPTACTIVATE_CG.V.MINRD# = TEMP_NUM ;
            END ;
         SELECT ( %CGCP_REREAD_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.REREAD# = TEMP_YES_NO ;
         SELECT ( %CGCP_TRANS_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.TRANS# = TEMP_YES_NO ;
         SELECT ( %CGCP_VFC_PARM ) ;
            FPTACTIVATE_CG.V.DVBYTE.VFC# = TEMP_YES_NO ;
      SELECT ( %ATTR_OPT ) ;
         CALL LARK_OCTALSTRING_BITSTRING ( SYM$->OUT$SYM.TEXT,
                                           SYM$->OUT$SYM.COUNT,
                                           FPTACTIVATE_CG.V.ATTR#,
                                           6 ) ;
      SELECT ( %CONNECTRES_OPT ) ;
         FPTACTIVATE_CG.V.CONNECTRES# = TEMP_YES_NO ;
      SELECT ( %FLUSH_OPT ) ;
         FPTACTIVATE_CG.V.FLUSH# = TEMP_YES_NO ;
      SELECT ( %RES_OPT ) ;
         FPTACTIVATE_CG.V.RES# = SYM$->OUT$SYM.TEXT ;
      SELECT ( %STATION_OPT ) ;
         VLPSTATION_ACT = VLP_STATION ;
         VLPSTATION_ACT.STATION# = SYM$->OUT$SYM.TEXT ;
         FPTACTIVATE_CG.STATION_ = VECTOR ( VLPSTATION_ACT ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END;
END ;
 
/*
   Make sure a station name was specified.
*/
 
IF ( FPTACTIVATE_CG.STATION_ = VECTOR ( NIL ) ) THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_MUST_SPECIFY_STATION#,
                                3 ) ;
   CALL LARK_CLOSE_TEMPSTATION ;
   GOTO ALT ;
END ;
 
/*
   Activating the station(s).
*/
 
CALL M$ACTIVATE ( FPTACTIVATE_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
CALL LARK_CLOSE_TEMPSTATION
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_ACTIVATE_CMD ;
 
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_DEACTIVATE_CMD
   PURPOSE:       Process the DEACTIVATE command
   DESCRIPTION:   This module receives the parse tree for a DEACTIVATE command
                  and processes it into data structures used with the M$DEACTIVATE.
*/
/*D*
   NAME:          LARK_DEACTIVATE_CMD
   CALL:          CALL LARK_DEACTIVATE_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_PROCESS_FID
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   SCRATCH:       VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   DEACTIVATE_CMD syntax =
                     'DEA/CTIVATE' ;
                     [ CG_FID ] ;
                     DEACTIVATE_OPTION_LIST
*/
 
%EJECT ;
LARK_DEACTIVATE_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_OPEN_TEMPSTATION ;
%LARK_PROCESS_FID ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%LARK_PARSEBLKS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPT_DEACTIVATE_CG,
         STCLASS              = CONSTANT,
         DCB                  = M$CG ) ;
 
%FPT_ACTIVATE
       ( FPTN                 = FPTDEACTIVATE_CG,
         STCLASS              = AUTO ) ;
 
%VLP_STATION
       ( FPTN                 = VLP_STATION,
         STCLASS              = CONSTANT ) ;
 
%VLP_STATION
       ( FPTN                 = VLPSTATION_DEACT,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
DCL      B$TCB$               PTR SYMREF ;
DCL      BLK$                 PTR ;
DCL      I                    SBIN ;
DCL      SUBLK$               PTR ;
DCL      SYM$                 PTR ;
DCL      TEMP_YES_NO          BIT ( 1 ) ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %DEACTIVATE_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
/*
   Processing the CG_FID if one has been specified and opening the temporary
   station.
*/
 
IF ( BLK$->OUT$SYM.CODE = %CG_FID ) THEN DO ;
   CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
         ALTRET ( ALT ) ;
END ;
 
CALL LARK_OPEN_TEMPSTATION ( %TRUE )
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
/*
   Processing the DEACTIVATE_OPTION_LIST.
*/
 
FPTDEACTIVATE_CG = FPT_DEACTIVATE_CG ;
FPTDEACTIVATE_CG.V_ = VECTOR ( FPTDEACTIVATE_CG.V ) ;
 
IF (M$CTRLCG$->F$DCB.FCD#) AND (M$CTRLCG$->F$DCB.AU#)
   THEN
      /* USE USER AU STATION FOR THE CALL */
      FPTDEACTIVATE_CG.V.DCB# = M$CTRLCG_DCBNUM;
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
END ;
 
IF ( BLK$->OUT$BLK.CODE ~= %DEACTIVATE_OPTION_LIST ) OR
   ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
   IF ( SUBLK$->OUT$BLK.NSUBLKS > 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM$ = SUBLK$->OUT$BLK.SUBLK$( 0 ) ;
   DO SELECT ( SYM$->OUT$BLK.CODE ) ;
      SELECT ( %YES ) ;
         TEMP_YES_NO = %YES# ;
      SELECT ( %NO ) ;
         TEMP_YES_NO = %NO# ;
      SELECT ( %STATION_WILDC ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
   DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
      SELECT ( %DISCONNECT_OPT ) ;
         FPTDEACTIVATE_CG.V.DISCONNECT# = TEMP_YES_NO ;
      SELECT ( %DSCGO_OPT ) ;
         FPTDEACTIVATE_CG.V.DSCGO# = TEMP_YES_NO ;
      SELECT ( %FLUSH_OPT ) ;
         FPTDEACTIVATE_CG.V.FLUSH# = TEMP_YES_NO ;
      SELECT ( %STATION_OPT ) ;
         VLPSTATION_DEACT = VLP_STATION ;
         VLPSTATION_DEACT.STATION# = SYM$->OUT$SYM.TEXT ;
         FPTDEACTIVATE_CG.STATION_ = VECTOR ( VLPSTATION_DEACT ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END;
END ;
 
/*
   Make sure a station name was specified.
*/
 
IF ( FPTDEACTIVATE_CG.STATION_ = VECTOR ( NIL ) ) THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_MUST_SPECIFY_STATION#,
                                3 ) ;
   CALL LARK_CLOSE_TEMPSTATION ;
   GOTO ALT ;
END ;
 
/*
   Deactivating the station(s).
*/
 
CALL M$DEACTIVATE ( FPTDEACTIVATE_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
CALL LARK_CLOSE_TEMPSTATION
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_DEACTIVATE_CMD ;
%EOD ;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_SETPROFILE_CMD
   PURPOSE:       Process the SETPROFILE command
   DESCRIPTION:   This module receives the parse tree for a SETPROFILE command
                  and processes it into data structures used with the M$PROFILE.
*/
/*D*
   NAME:          LARK_SETPROFILE_CMD
   CALL:          CALL LARK_SETPROFILE_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_INTERNAL_ERROR
                  LARK_PROCESS_FID
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   SCRATCH:       VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   SETPROFILE_CMD syntax =
                     'SETP/ROFILE' ;
                     [ CG_FID ] ;
                     SETPROFILE_OPTION_LIST
*/
 
%EJECT ;
LARK_SETPROFILE_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_OPEN_TEMPSTATION ;
%LARK_PROCESS_FID ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_MUST_SPECIFY_PROFILE#-3
   MESSAGE0:      Profile name must be specified
   Message1:      Default profile name is not supplied
   Description:   User must specify a valid profile name.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%LARK_PARSEBLKS ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_PROFILE
       ( FPTN                 = FPT_PROFILE,
         STCLASS              = CONSTANT,
         DCB                  = M$CG ) ;
 
%FPT_PROFILE
       ( FPTN                 = FPTPROFILE,
         STCLASS              = AUTO ) ;
 
%VLP_NAME
       ( FPTN                 = VLP_NAME,
         STCLASS              = CONSTANT ) ;
 
%VLP_NAME
       ( FPTN                 = VLPNAME_PROFILE,
         STCLASS              = AUTO,
         LEN                  = 11 ) ;
 
%VLP_STATION
       ( FPTN                 = VLP_STATION,
         STCLASS              = CONSTANT ) ;
 
%VLP_STATION
       ( FPTN                 = VLPSTATION_TERM,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
DCL      B$TCB$               PTR SYMREF ;
DCL      BLK$                 PTR ;
DCL      I                    SBIN ;
DCL      SUBLK$               PTR ;
DCL      SYM$                 PTR ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %SETPROFILE_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
/*
   Processing the CG_FID if one has been specified and opening the temporary
   station.
*/
 
IF ( BLK$->OUT$SYM.CODE = %CG_FID ) THEN DO ;
   CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
         ALTRET ( ALT ) ;
END ;
 
CALL LARK_OPEN_TEMPSTATION ( %FALSE )
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
/*
   Processing the SETPROFILE_OPTION_LIST.
*/
 
FPTPROFILE = FPT_PROFILE ;
FPTPROFILE.V_ = VECTOR ( FPTPROFILE.V ) ;
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
END ;
 
IF ( BLK$->OUT$BLK.CODE ~= %SETPROFILE_OPTION_LIST ) OR
   ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
   SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
   IF ( SUBLK$->OUT$BLK.NSUBLKS > 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM$ = SUBLK$->OUT$BLK.SUBLK$( 0 ) ;
   DO SELECT ( SYM$->OUT$BLK.CODE ) ;
      SELECT ( %PROFILE, %STATION_WILDC ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
   DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
      SELECT ( %PROFILE_OPT ) ;
         VLPNAME_PROFILE = VLP_NAME ;
         VLPNAME_PROFILE.NAME# = SYM$->OUT$SYM.TEXT ;
         VLPNAME_PROFILE.L# = SYM$->OUT$SYM.COUNT ;
         FPTPROFILE.PROFILE_ = VECTOR ( VLPNAME_PROFILE ) ;
      SELECT ( %STATION_OPT ) ;
         VLPSTATION_TERM = VLP_STATION ;
         VLPSTATION_TERM.STATION# = SYM$->OUT$SYM.TEXT ;
         FPTPROFILE.STATION_ = VECTOR ( VLPSTATION_TERM ) ;
      SELECT ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END;
END ;
 
/*
   Make sure a station name and profile name were specified.
*/
 
IF ( FPTPROFILE.STATION_ = VECTOR ( NIL ) ) THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_MUST_SPECIFY_STATION#,
                                3 ) ;
   CALL LARK_CLOSE_TEMPSTATION ;
   GOTO ALT ;
END ;
IF ( FPTPROFILE.PROFILE_ = VECTOR ( NIL ) ) THEN DO ;
   CALL LARK_REPORT_CMD_ERROR ( %E$LARK_MUST_SPECIFY_PROFILE#,
                                3 ) ;
   CALL LARK_CLOSE_TEMPSTATION ;
   GOTO ALT ;
END ;
 
/*
   Setting the profile for the supplied terminal station.
*/
 
CALL M$PROFILE ( FPTPROFILE )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                       M$CG_DCBNUM ) ;
         GOTO ALT ;
      END ;
 
CALL LARK_CLOSE_TEMPSTATION
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END LARK_SETPROFILE_CMD ;
