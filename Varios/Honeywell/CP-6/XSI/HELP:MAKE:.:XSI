MAKE is a case tool that is used to maintain, update and reproduce files whose
base components have been modified.
MAKE is invoked with the following command:
 
     !MAKE.X [option [option...]] [target [target...]] ['var=repl']
 
where:
target       target is one of the targets found in the Makefile.
VARIABLES       'var=repl' is a variable assignment (many variables may be
assigned a value this way).
option is one of the following options:
 
-a   -a causes MAKE to display all of the actions that it has determined
    are necessary to produce the goal(s) and to indicate the status of
    each target before actually performing the build (or touch) operation.
    This information includes the names of the CP-6 files used as input
    and output, and the number of the rule used to produce the target.
    All of the target rule names are listed at the end of this summary.
 
-ctarget   -ctarget causes MAKE to treat the following target as if it has
    been modified (or needs to be built), regardless of the latest
    modification time of the file provided by the operating system.  This
    option can be used in conjunction with the -n option to find out what
    would happen if that file was modified.  The target name should appear
    immediately after the "-c" without an intervening blank.
 
-d   -d causes MAKE to display debugging information in addition to normal
    processing messages.  This information includes the names of the
    targets being built, the file names being considered and their most
    recent modification times.  It also indicates the implicit rules being
    considered and displays the action table that MAKE uses to run the
    batch jobs to produce the goals.
 
-e   -e causes MAKE to send electronic mail to the target owner if an
    error occurs producing the target.  Owners get a summary of all of
    their errored targets, and if the option "-ee" is provided then as
    soon as the error occurs MAKE sends a mailgram containing the reason
 
    for the failure, the name of the diagnostic output file and the first
    12 lines of diagnostics.
 
-ffid   -ffid tells MAKE the name of the Makefile to use.  The name of the
    file should immediately follow the "-f" with no intervening blanks.
 
-gfid   -gfid tells MAKE to create a file containing a description of all
    of the input and output files associated with each step of the build
    process.  The file format contains the following fields separated by a
    single blank:  the input file name, the output file name, the output
    target name and the rule name used to generate the file.
 
-iACCOUNT   -iACCOUNT adds ACCOUNT to the search list to use for :include
    files.  Up to 10 search accounts may be specified (by specifying this
    option multiple times).  The "ACCOUNT" may be a simple account name, a
    filename and account or a wildcarded filename and account.
 
-jn   -jn specifies the maximum number of batch jobs that MAKE will have
    submitted to the system simultaneously.  The "-j" must be followed by
    decimal digits with no intervening blanks.  The number field ends on
    the first non-digit.  The number must be greater than zero.  If the
    number is zero, all jobs will be run by the current session, no batch
    jobs will be submitted.
 
-k   -k is used to control the generation listing and diagnostic
    filenames.  When this option is used, only the base target name is
    used to generate the listing and diagnostic filenames by applying the
    LOPATH and DOPATH patterns respectively.  Normally, MAKE uses the
    entire target name for these file names changing embedded "."
    characters into ":".
 
-lcomponent,fid   -l is used to create a fake ":LIST" file from the
    current Makefile.  It is not suitable for use with FUMBLE.X but is
    close enough for use with some of the other tools which use the :LIST
    file such as LNCOUNT.X.
 
-m   -m causes make to display its memory usage.
 
-n   -n causes make to print the commands that would be executed if it
    were to build the goal.
 
-otarget   -otargetcauses MAKE to treat the following target as if it is
    up to date, regardless of its dependencies, or the modification time
    provided by the operating system.  This option can be used to avoid
    recompiling targets that would otherwise be compiled.  The target name
    should appear immediately after the "-o" without an intervening blank.
 
-p   -p print the Makefile, the variable definitions and summarize all of
    the explicit dependencies.
 
-q   -q do not build the goal, set the step condition codes to 0 if the
    target is up to date.
 
-r   -r do not include the default rules.  The Makefile must define all of
    the implicit rules that are required.
 
-s   -s do not echo "@" commands; if "-ss" is specified, the IBEX status
    check commands are not issued on running batch jobs as well.
 
-t   -t do not build the goal, rather, touch all of the files making them
    appear up to date.
 
-u   -u causes update packets to be included if the access control list
    for the update file is empty, contains the account "DONE" or the
    account "?MSC" or contains the current logon account.  If this option
    is specified twice, then the update file is only included if the
    access control list is empty or contains the account "DONE" or "?MSC".
 
-v   -v print the version of MAKE and additional information associated
    with the "-a" and "-d" options.  If this option is specified twice,
    even more output is provided for the "-a" option.
 
-wn   -wn set MAKE's output width to the decimal argument value (as in
    -w80 to set the output width to 80).
Finally, output of MAKE may be redirected using the syntax ">fid".  A single
dash "-" may be used for more than one option as long as the option does not
take a filename or target name parameter.  For example "-vnw80d" may be used
to request the "-v", "-n", "-w80" and "-d" options.
 
For more information on MAKE, try !HELP (MAKE.X) TOPICS. The MAKE manual is
the best way to learn to use this tool.  To get one at LADC, print the tex dvi
file MAKE_dvi.:XSI on the laser printer using the following command:
 
!dvilg MAKE_dvi.:XSI over LZ@UPSTAIRS (FORM=QMSCAP,DEV=800)
 
At other CP-6 sites, the manual may be printed if you have a tex dvi file
print program and a laser printer.
CP-6 MAKE -  Bruce Frost
*************************************************************************
*
* Copyright (c)  Bull HN Information Systems Inc., 1990
*
*************************************************************************
The MAKE program is a case tool that is used to maintain, update and reproduce
files whose base components have been modified.
 
Computer programs are developed by combining a large number of smaller source
programs into a single large run-unit because smaller programs are easier to
develop and maintain.  Often these pieces require different transformations or
even simply different options to produce the derived file (a derived file can
be viewed as an object unit, library or run-unit because it is produced by a
program that takes a different kind of input file and produces a new file).
The resulting derived file often needs more transformations, such as combining
various object files to produce a run-unit.
 
When a large system is being developed, many files can be modified by a
developers, or a single change to an include file may invalidate the
compilation of many modules.
 
MAKE determines which pieces of a large system need to be recreated by running
the correct CP-6 IBEX commands.  This manual uses C, PL6 and Fortran programs
to demonstrate the use of MAKE, but MAKE may be used with any program that
produces an output file that must be kept current with its corresponding input
file(s).
 
In order to use MAKE, a file known as a Makefile is created which describes
the relationships among the various files and contains the commands required
for creating the output files (where MAKE cannot infer the commands from the
file type).
When a suitable Makefile exists, the most up to date target files can be
created simply by using the command:
 
     !MAKE.X -fMakefile
 
MAKE uses the Makefile and the last modification times of the various files to
determine which of the target files need to be recreated.  For each of those
files it runs a batch job to create it.
 
Invocation options can be used to control the various phases of producing the
targets including debugging a Makefile.
 
CP-6 MAKE provides a number of significant extensions beyond the capabilities
provided by other similar programs.  These extensions include:
 
o   building multiple targets in parallel using simultaneous batch jobs.  This
    significantly reduces the time required to produce the final target file.
o   additional built-in implicit rules for the following CP-6 processors:
    PL6, PARTRGE, BMAP, LINK, TEX and HERMAN.
o   looking for CP-6 update files.
o   search paths for files in SI, UI, OU, and GN accounts.
o   a fake target ".PHONY" whose dependents are not actual files.
o   a fake target ".ONLINE" whose dependents are run in the same session as
    MAKE.
o   support for diagnostic output and listing output.
o   the ability to indicate the source file type used to produce a target.
o   a command line option "-c" which treats the following target as if it is
    out of date.
o   a command line option "-o" which treats the following target as if it is
    up to date.
o   a command line option "-a" to list the actions required to produce the
    target(s).
o   a command line option "-w" to set the output width.
o   a command line option "-j" to control the number of running batch jobs.
o   a command line option "-u" which controls selecting update files based
    upon their access controls.
o   a command to indicate the electronic mail address of the owner of a file.
o   a command line option "-e" to control sending electronic mail to owners
    when an error occurs.
o   directives to conditionally select portions of the Makefile.
o   a directive to include other Makefile's.
o   directives to display messages to the MAKE user.
 
For more information on MAKE, try !HELP (MAKE.X) TOPICS. The manual is the
best way to learn how to use this tool.  To get one at LADC (at other sites a
TEX dvi file print program and a laser printer must be available), print the
MAKE_dvi file on the laser printer using DVILG with the following command:
 
!dvilg MAKE_dvi.:XSI over LZ@UPSTAIRS (FORM=QMSCAP,DEV=800)
The following arithmetic operators take two arguments which must both be
integers.  The general syntax is:  "A op B" where op is one of the following
operators:
ADDITION      + the sum of A and B,
SUBTRACTION      - subtracts B from A,
MULTIPLICATION      * multiplies A and B,
DIVISION      / divides A by B,
MODULUS      % returns integer remainder of A divided by B,
LEFT_SHIFT      << shifts bits in A left by B positions,
RIGHT_SHIFT      >> shifts bits in A right by B positions,
AND      & computes the bitwise and of A and B,
OR      | computes the bitwise or of A and B, and
EXCLUSIVE_OR      ^ computes the bitwise exclusive or of A and B.
The following arithmetic operators take a single argument which must be
numeric (with the exception of the sizeof function whose argument must be a
string).  The general form syntax is "op B" where op is one of the following
operators:
NEGATION      - subtracts B from zero,
NOP      + leaves B unchanged,
LOGICAL_NOT      ! if B is 0, returns 1, otherwise returns 0,
NOT      ~  inverts all of the bits in B.
SIZEOF      sizeof(B) returns the integer length of string B.
 
With the exception of the sizeof operator, the arguments to these functions
must also be numbers.  If a variable reference is one of the operands, it is
converted into an integer.  If it contains any non-digits, the result is an
error.
00001
00008
00004
00010
00006
00014
00005
00003
00012
00013
00015
00009
00007
00016
00002
00002
Before writing any implicit rules, it is important to review the names of the
automatic variables that are available when MAKE is creating the jcl.  The
following automatic variables are used to represent the file names that MAKE
has found in order to produce the target file.
GEN_TARGETS       $!  A blank separated list of the chain of targets which
depended upon this target being built (i.e.  the chain of targets starting at
the primary goal target).
CHANGED_TARGETS       $?  A blank separated list of the targets in the chain
of dependents of this target which are newer than this target (i.e.  the names
of the targets which caused this target to be produced).
DEPENDENT_TARGETS       $^ A blank separated list of the names of dependents
of the target being built.
TARGET       $@ The CP-6 file identifier of the target of the rule.
SOURCE_INPUT       $< The CP-6 file identifier of the input file (source
file).
BASE_NAME       $* The CP-6 base file name (without a suffix).
DIAGNOSTICS       $+ The CP-6 diagnostic output file identifier.
LISTING       $& The CP-6 listing output file identifier.
TARGET_FILE       $(@F) The CP-6 target file name without account.
SOURCE_FILE       $(<F) The CP-6 input file name without account.
BASE_FILE       $(*F) The CP-6 base file name without account.
DIAGNOSTIC_FILE       $(+F) The CP-6 diagnostic output file name without
account.
LISTING_FILE       $(&F) The CP-6 listing output file name without account.
TARGET_ACCOUNT       $(@D) The CP-6 target file account.
SOURCE_ACCOUNT       $(<D) The CP-6 input file account.
DIRECTORY_ACCOUNT       $(*D) The CP-6 directory associated with MAKE user.
DIAGNOSTIC_ACCOUNT       $(+D) The CP-6 diagnostic output file account.
LISTING_ACCOUNT       $(&D) The CP-6 listing output file account.
00011
00006
00002
00003
00007
00017
00012
00016
00001
00008
00018
00013
00015
00010
00005
00004
00014
00009
00003
Sometimes it is possible to make a change in a source file that would
otherwise cause all of the files that depend upon it to be recompiled when
only a few really need to be compiled.  For example, suppose a macro or a new
declaration was added to a header file.  Being very conservative, MAKE would
assume that any change in the include file requires recompilation of all of
the dependent files.
 
If this situation has been anticipated, it can be solved by using the "-t"
option.  This flag tells MAKE not to run the commands in the rules, but rather
to mark the target up to date by changing its last modification time.  The
following procedure should be followed:
 1. Use MAKE to recompile any source files that really do need compilation.
 2. Make the change to the include files.
 3. Use MAKE with the "-t" option to mark all of the object files as up to
    date.  The next time MAKE is run, the changes in the header files will not
    cause any recompilation.
 4. Make changes to the source files that need the new include file changes.
 5. Run MAKE to recompile only the changed files.
 
If the include file has already been modified before the first step, it is too
late to do this.  In this case, the "-o" option should be used to compile
everything that needs compilation with MAKE treating the include file as if it
had not been modified.  The following procedure should be used:
 1. Recompile the source files that need to be compiled independent of the
    modified include file with "MAKE.X -oInclude ...".  If more than one
    include file is involved in this, multiple "-o" options should be
    specified, one for each include file.  Use the "-c" option to compile
    changed source files if the source files have been modified to use the new
    include file changes.
 2. Now, touch all of the target files with the command "MAKE.X -t ...".
 3. Finally, make the changes to the source files that need the new include
    file changes.
 4. Run MAKE, compiling only the changed files.
NON_BUILD OPTIONS
 
The Makefile shows MAKE how to tell if a file is up to date.  Unfortunately
updating the targets is not always what is required.  There are a number of
options available when using MAKE that do not cause the targets to be built.
TOUCH       -t is "Touch".  This use of MAKE is to mark all of the targets as
up to date without actually changing them.  In other words, MAKE pretends to
compile the targets but does not really change their contents.
NO_OP       -n is "No-op".  This use of MAKE is to print the commands that
would be used to bring the targets up to date.  The commands are not actually
run.  This option is perhaps the best way to debug a Makefile.
QUESTION       -q is "Question".  This use of MAKE is to find out whether the
target is up to date already.  No commands will be executed, but the step
condition code will be 0 if the target is up to date.
VARIABLE OPTIONS
 
The value of a Makefile variable can be set so that the Makefile assignments
to that variable are ignored.  This is done by the enclosing the variable
definition within single quotes on the MAKE invocation.  For example,
'CC=CC.:SYSTEST' may be specified on the MAKE command to cause the value of
the variable CC to be "CC.:SYSTEST".
 
One use for this is to pass extra options to compilers or to even change the
compiler to be used.
00001
00003
00004
00002
00005
When MAKE builds a batch job, it glues together three separate pieces of CP-6
jcl.  First, it locates the commands associated with the fake target .jcl.
These commands contain a !JOB command, a !RES command, issue a !DIR command to
set the current directory to the file management directory that was associated
with the user running MAKE, sets M$DO to the MAKE file created by the base
file name with the value of the variable DOPATH treated as a file suffix, and
finally the target is deleted if it is not a dependency of .PRECIOUS.
 
Next, the commands provided for the target being built are inserted into the
job stream.  If these commands begin with !DEFAULT commands, those commands
are actually inserted before the commands associated with .jcl, so that the
default job time or name can be overridden.
Finally, MAKE inserts the commands associated with the .end target.  These
commands set the M$DO and M$LL dcbs to NO, delete the diagnostic output file,
and stop execution by default.  It also defines the label ABORT which causes
none of the above actions to occur.
 
The default .jcl and .end target rules are shown in the following two figures.
 
 -JOB $(JOBOPTS)
 -RES $(RESOPTS)
 -Dir .$(*D)
 -Set M$DO $+
 -Let STEPCC = 0
 
 -Set M$DO NO
 -Set M$LL NO
 -Del $+
 -ERASE
 -Quit
 -ABORT: OUTPUT '******** ERROR ***********'
 
These rules may be overridden by supplying them in your Makefile.
MAKE provides a number of predefined implicit rules which are always
available.  These rules are automatically defined if the Makefile does not
define them, allowing them to be overridden easily by a Makefile.  The
following table shows these rules.
 
    Rule             Compiler Variable           Option Variable
 
    .c.o             CC      = CC                COPTS    =
 
    .6.o             PL6     = PL6               PL6OPTS  = (SCH)
 
    .f.o             FORTRAN = FORTRAN           FORTOPTS =
 
    .y.c             YACC    = BISON.X           YACCOPTS = -d
 
    .l.c             LEX     = LEX.X             LEXOPTS  = -t >$@
 
    .n.o             PARTRGE = PARTRGE           PARTOPTS =
 
    .a.o             BMAP    = BMAP              BMAPOPTS =
 
    .p.o             PASCAL  = PASCAL            PASCOPTS =
 
    .o.r             LINK    = LINK              LINKOPTS =
 
    .tex.dvi         TEX     = TEX               TEXOPTS  =
 
    .web.tex         WEAVE   = WEAVE
 
    .web.p           TANGLE  = TANGLE
 
    .cap.dvi         CAPFMT  =                   CAPDEV   =
 
    .cap.herman      CAP     = CAP
 
    .herman.help     HERMAN  = HERMAN.X          HERMOPTS = (NLS,NWA)
 
    .makefile.dependsMIDGET  = MIDGET.X          MIDGOPTS = -cvx
 
                     MAKE    = MAKE.X            MAKEFLGS =
 
    .jcl             JOBOPTS  = Name=$(*F),ReRun RESOPTS  = Mem=128,Time=2
 
    .end
 
    .xeq
 
    .xeqend
CHAINING RULES
 
Sometimes a target is made by a series of implicit rules.  For example, the
file "gram.o" could by produced by first using BISON.X to translate a grammar
file into a C source file and then using CC to translate the C source file
into the target object unit.  Such a series of operations is called a chain.
By default, MAKE looks for a ".y" file before looking for a ".c" file because
of the built-in rule ".y.c" which tells MAKE that a C source file can be
produced.  In this case, when a ".y" file is found MAKE automatically includes
the steps to use BISON.X.
 
MAKE recognizes an implicit rule appearing more than once in a chain and stops
following the chain, preventing the possibility of an infinite loop in the
search for an implicit rule.
00001
03/16/92
The value passed to ctime should be a gmt value not a uts one. Also,
removed the declaration of *B$JIT$  since this is now declared in
<b$jit_c.h>.
07/16/90
Fixed a problem with the output of the -g command.  Also, if this option is
specified, MAKE stops immediately after generating the requested output file.
 
Additional information is now printed when MAKE is unable to create a
temporary file for its jcl.
 
Fixed a bug in the generation of the $^ variable.
 
Implemented implicit commands for the use of MIDGET.X to generate dependency
files.  If MAKE has jit access, the current status line information is
maintained in CCBUF (for users equipped to be spies).
 
Changed the -t option to check for failure to touch the target.  In this case,
MAKE looks through the search path for an existing version of the file and
will copy it or report an error.
05/21/90
Fixed a problem with replacing the default rules for .jcl, .xeq, .end and
.xeqend.
 
03/23/90
Fixed a problem with generating commands where a UNIX style invokation option
will not be broken until after at least 40 characters after the -?  sequence.
 
Braces are now acceptable around variable references as in UNIX (tm) make.
Comments may be embedded in the build commands and are ignored.  Target names
may contain a "-" character, although an initial "-" will cause the name to be
treated as a C style command line option when creating jcl.
When multiple targets are specified as having the same build rule, the
treatment by MAKE has been clarified.  If the variable $@ or $(@F) is
referenced in the build rules, the rule is applied separately to each target.
Otherwise, the rule is treated as though every target is created by one
application of the rule.
 
02/26/89
It is now permitted to set the number of concurrent batch jobs to 0 which is
interpreted as meaning run all targets online.  Implemented the -l option to
provide fake :LIST files.  When variables are assigned values from the
command-line, they are no longer required to be within quotes if the entire
variable assignment contains no white space characters.
 
01/25/89
Fixed a bug in modified references when the reference was previously
undefined.  Corrected the -u option to work with integrations.  Permitted the
default .copy and .fmt rules to be over-riden.
 
12/14/89
Added the "-g" option.  Corrected manual and helpfile to mention the "-m"
option.  Changed the default value of the CC variable to be CC.
 
Implemented the processing of options within the MAKEFLGS variable.  This
variable allows MAKE options to be specified as IBEX variables or within the
Makefile.
 
The order in which MAKE considers implicit rules when searching for files has
been changed to first consider through implicit rules defined within the
Makefile (in the order in which they appeared in the Makefile), and then
through the built-in rules in the order in which they appear in the topic
BUILT_IN_RULES.
 
A problem expanding the parse work area has been corrected.
 
Targets which have dependencies or are themselves temporary files will now be
run as if they were dependents of ".ONLINE".
 
11/03/89
Fixed a bug with really longgggg file names.  Fixed a bug in the default
".xeq" rule.  Corrected the summary mailgram copy option.
 
10/20/89
Modified .y.c rule to work with latest BISON.X and modified .l.c rule to use
FLEX.X.
 
Various improvements to the MAKE manual and help file.
 
Improved performance during derivation phase.
 
10/09/89
Improved decision of when to copy a file in the SIPATH into the OUPATH. Now
MAKE will not do this when the targets default account is the first account in
SIPATH and the file type is used in an input rule.
 
The -ss option causes the IBEX check command information not to be displayed
when a running job's status changes.
 
The default rule for .c.o has changed to be compatible with the new C
compiler.  In addition, the default value of the CC variable is (temporarily)
CC.:SYSTEST.
Implemented the following new Makefile directives:  :if, :elif, :else, :endif,
:include, :error and :print.
 
09/18/89
Corrected the -u option to work.
 
The electronic mail option -e has been added in addition to the ability to
specify the owner of a target file.
 
08/08/89
Changed the way LOPATH and DOPATH are used to generate their file names.
These file names are generated using the entire target name with any "."
characters turned into ':'.  The "-k" option may be used to obtain the old
behaviour.
 
A bug in the handling of more than 9 -c or -o options has been corrected.
 
When a built-in variable contained a filename with a $ in it, macro
substitutions would occasionally occur.  Now dollar signs within built-in
variables are not changed.
 
07/21/89
Improved initial HELP file topic.
 
Fixed a bug in the $?  variable which caused it to not produce its value.
 
Modified the logic used to produce the .ONLINE commands.  They no longer
require an IBEX go command and Makefiles which use online targets may be run
in batch.
 
The commands associated with the ".xeqend" target have been changed.
 
If a target depends upon a target with the same base name and that dependent
target could produce the correct file type, then the built in rule which uses
that target will be used.
 
When MAKE is searching for a built-in rule to produce a target and it locates
a target that is already built as a possible input, it is NOT used.
 
When a file which has no built-in rules to produce it also has dependencies,
and those dependencies have actions associated with them, MAKE will assume
that the target is produced as a side-effect of one of its dependencies.
6/21/89
Submitted to X account.
The following table summarizes the command flags which may appear at the
beginning of a command.  Any number of these flags may appear on a command and
they are removed before the command is sent to the command stream.
 
               Flag Meaning
 
               -    Don't check step condition codes
 
               @    Echo this command before sending batch job
 
               !    Don't prefix command with a "!"
Conditionals cause part of a Makefile to be obeyed or ignored depending on the
values of expressions.  Conditionals can compare the value of one variable
with another, or the value of a variable with a constant string.  Conditionals
control what MAKE actually "sees" in the Makefile, but they do not control
commands at the time of execution.
EXAMPLE
The following conditional is used to select one library if the CC variable is
CC.:SYS and a different library otherwise.  It works by controlling which of
two command lines will be used as the command for a rule.  The result is that
'CC=CC.:SYSTEST' as an argument to MAKE not only changes which compiler is
used but also which shared library is used.
 
 test_lib    = :SHARED_C
 normal_lib  = :SHARED_C_TEST
 
 foo: $(objects)
 :if  CC != "CC" && CC != "CC.:SYS"
         link  $(objects) over $@ (sharelib=$(test_lib))
 :else
         link  $(objects) over $@ (sharelib=$(normal_lib))
 :endif
 
This conditional uses three directives:  :if, :else and :endif.
 
The :if directive contains an expression that is evaluated as MAKE reads the
Makefile.  If the expression's value is true then the Makefile records up to
the :else (in this example) are included.  Otherwise the records following the
:else (in this example) are included.  Variable substitution is performed on
the conditional lines before the expression is evaluated.
The :else directive causes the following lines to be obeyed if the previous
conditional failed.  In the example above, this means that the second link
command is used whenever the first is not used.  It is optional to have an
:else in a conditional.
 
The :endif directive ends the conditional.  Conditionals may not be continued
across :include files.  Unconditional Makefile text follows this command.
When the variable CC has the value CC or CC.:SYS the above example has this
effect:
 
 foo: $(objects)
         link  $(objects) over $@ (sharelib=$(normal_lib))
 
When the variable CC has any other value, this effect is this:
 
 foo: $(objects)
         link  $(objects) over $@ (sharelib=$(test_lib))
 
Equivalent results can be obtained in another way by using a conditional
statements to affect variable assignment and then using the variable
unconditionally.
Many of the conditional commands have arguments which are expressions.
Expressions are defined  under the topic EXPRESSION_EVALUATION. .
 
Portions of Makefiles are conditionally skipped or included by using the
following directives:
 
   :if starts a conditional Makefile section,
   :elif conditionally includes section,
   :else includes section if nothing else has been included,
   :endif terminates the current block.
 
 :if expression
     .
     .
 text-if-:if-true
     .
 :elif expression
     .
 text-if-:elif-true
     .
 :else
     .
     .
 text-if-others-false
     .
 :endif
 
The text-if-:if-true may be any lines of text, to be considered as part of the
Makefile if the condition is true.  If the condition is false, lines within
the Makefile are skipped up to the next :elif, :else or :endif.  The remaining
sections of a conditional body up through the text-if-others-false are
optional.  The :else section (if any), must be the last section of the
conditional body.  Each of the conditional sections that is included may be
any number of lines as long as the conditional body ends before the end of the
file.  Only one section of a conditional body is ever included, even if
multiple :elif expressions are true, in fact, :elif expressions are not
evaluated if a section has already been included from the conditional body.
 
Conditionals work at the textual level.  The lines of the text-if-true are
read as part of the Makefile if the condition is true; if the condition is
false, those lines are ignored completely.  Syntactic units of the Makefile,
such as rules, may safely be split across the beginning or the end of the
conditional.
 
An :include directive may be used within a conditional, but it may not start a
conditional in one file and end it in another.
 
Extra spaces are allowed and ignored at the beginning of the conditional
directive line.  Aside from this, extra spaces may be inserted with no effect
anywhere except within the directive name or within an argument.  Comments
beginning with "#" may appear at the end of the :if, :elif, :else and :endif
directives.    Specific information on each of the conditional directives can
be found under the HELP topics:  IF_DIRECTIVE, ELIF_DIRECTIVE, ELSE_DIRECTIVE
and ENDIF_DIRECTIVE.
00001
MAKE filenames consist of two parts.  The first part is the base file name and
the second part is a suffix, which is used by MAKE to determine the type of
the file.  MAKE needs to know the type of the file when it does not have
explicit rules for creating a target file.  In order to infer the file type,
MAKE requires the use of a file naming convention to help it recognize the
type of the file.  MAKE never looks at the contents of a file, it only looks
at the file name, the rules which have been provided for creating file names
from file types and the names of the files which actually exist.
 
By default, MAKE knows about a number of file types  (see topic
BUILT_IN_RULES). MAKE constructs a CP-6 filename from the base file name and
suffix by using the variable definition with the same name as the suffix
(including the leading ".").  So, for example, there is a variable ".c" whose
value is used to create the real CP-6 filename for a make file name such as
"blotto.c".  The default value of the ".c" variable is ":c" which would
produce the CP-6 file name "blotto:c" when the name "blotto.c" is found in the
Makefile.
 
The actual rules for producing the CP-6 file name from the value of the
variable is as follows:
 
o   If the value of the variable contains no "?"  characters, the CP-6 file
    name is produced by appending the value of the variable to the base file
    name.
o   If the value of the variable contains a "?"  but it does not contain any
    "*" characters, the CP-6 file name is produced by replacing the "?"  in
    the variable value with the base file name.
o   Finally, if the variable value contains both a "?"  and a "*" character,
    then:
     1. Each "*" must be followed by a single digit that indicates the number
        of characters to remove from the base file name.  Each "*" before the
        "?"  removes characters from the beginning of the base file name and
        each "*" after the "?"  removes characters from the end of the base
        file name.
     2. Any characters in the base file name that were not used up by the "*"
        rules replace the "?".
 
The following examples show the use of some common variable definitions for
certain CP-6 file types.
 
          .6      =  :6
          .lib    =  :LIB_?
          .help   =  HELP:?:
 
The first variable definition in the preceding example is used as the default
for PL6 source files.  That is, the default naming convention for PL6 files is
to append ":6" to the end of the base file name.  For example, if the Makefile
referenced a file such as pl6subr.6, then this macro causes its CP-6 file name
to be pl6subr:6.
 
The second macro could be used to name LEMUR libraries.  If the Makefile
referenced a library such as SYSTEM.lib, then this variable definition would
cause its CP-6 file name to become :LIB_SYSTEM.
Finally, the third macro transforms a Makefile file name such as "MAKE.help"
into the CP-6 file name "HELP:MAKE:".
UNIX make has some features that are not implemented or are implemented
differently in CP-6 MAKE. A summary of these follows:
 
o   Features associated with access to SCCS or RCS are not implemented in CP-6
    MAKE.
o   Commands used to build targets are signified by leading blanks or tabs.
    Most other make programs insist upon leading tabs.
o   Variables are not recursively defined.  Their current value is simply
    expanded wherever it appears.  This means that MAKE cannot get into an
    infinite loop referencing a variable but it also forces the Makefile to be
    written without forward references to variables.
o   Commands to build targets are executed via batch jobs.  This prevents any
    interaction with the user of MAKE within the Makefile, or the use of CP-6
    star files as targets.
o   Recursive invocation of MAKE may not work as expected.  This is because by
    default a batch job is used to run the next MAKE.
o   The .IGNORE, .DEFAULT and .SILENT pseudo-targets are not supported.
o   Double colon rules are not supported.
o   The meaning of modified variable references is slightly different.  A
    modified reference may replace a string anywhere it occurs within the
    variable value.
o   Commands must not be attached to the rule line via a ";".  Commands always
    follow the rule on the next line with one or more leading blanks or tabs.
o   When looking for implicit rules to build a target, CP-6 MAKE finds the
    longest path of implicit rules that will generate the target.  Many other
    MAKE programs require that all of the intermediate files exist for each of
    the intervening steps.
Directives appear in the Makefile and always begin with a ":"  as their first
character, followed by the keyword name of the directive and any arguments
associated with the directive.  Directives are executed by MAKE as the
Makefile is being read.  There are three kinds of directives:
 
   Conditional Directives allow portions of the Makefile to be skipped.
   Include Directives cause other Makefiles to be read.
   Message Directives display messages to the MAKE user.
 
The following topics contain more information on directives:
CONDITIONAL_DIRECTIVES, INCLUDE_DIRECTIVE, and MESSAGE_DIRECTIVE.
Double Colon Rules are not implemented in CP-6 MAKE.
Syntax
 
:elif expression
Parameters
 
expression      is an expression that is evaluated for true or false.
Description
 
If no text has been inserted in the current conditional block and if the
expression expression has a true value, then the lines following this
directive up to the next :elif or :else are included.
00002
00001
Syntax
 
:else
Description
 
If no text has been inserted in this conditional block already, then the lines
following this directive up to the next :elif or :else are included.
00001
MAKE can be requested to automatically send electronic mail to owners of
target files when running the commands to build a target have failed.  The "-
e" option controls this feature and provides the user of MAKE with the ability
to notify other project members when problems occur.  If the "-e" option is
used, when MAKE completes execution and prints its summary of errored targets,
it also sends mail to the owners of the targets (one mailgram for each owner
with all of their errors).  If the "-ee" option is used, in addition to the
summary at the end of the MAKE execution, mailgrams are sent when the error is
detected to the owner of the failing target file with the name of the
diagnostic file (including up to 12 lines of diagnostics) or a message
indicating that the target file was not created.
Syntax
 
:endif
Description
 
This directive signals the end of a conditional block and stops the skipping
of lines (if this is not a nested block).  If the block is nested, then the
skipping or inclusion of lines reflects the state of the next outer
conditional block.
00001
Syntax
 
:error expression,expression,expression,...
Parameters
 
expression      is an expression that evaluates to an integer, a string or a
variable reference.
Description
 
This message is created by joining the name of the file being read in double
quotes, followed by the line number and finally the text formed by joining all
of the expression results together.
00002
00001
In the following example, a simple Makefile is created for a hypothetical
program which uses Fortran and C include files and source files.  It consists
of six C sources, one Fortran source and 3 header (or include) files.
 
The first step in producing this program with MAKE is to build a Makefile that
shows how to compile and link the program.  All of the C source files include
the file "vars:h", three include the file "targets:h" and four include the
file "tables:h".
 
To make the program, each source file must be recompiled if it has been
changed, if one of its include files has changed, or if the object unit does
not exist.  Finally, the program must be relinked if any of the object units
is newer than the current version of the program or if the program does not
exist.
 
The following example shows a Makefile that describes the above dependencies
and shows how to compile and link the program.
 
 !B Makefile
 EDIT E00 here
     1.000 program :  main.o macros.o commands.o read.o symbols.o \
     2.000            build.o files.o derive.o
     3.000   link main.o,macros.o,commands.o,read.o,symbols.o, \
     4.000           build.o,files.o,derive.o over program
     5.000
     6.000 main.o     :  main.c    vars.h
     7.000   CC main.c over main.o (NLS)
     8.000
     9.000 macros.o   :  macros.c     vars.h targets.h
    10.000   CC macros.c over macros.o (NLS)
    11.000
    12.000 commands.o : commands.c vars.h targets.h
    13.000   CC commands.c over commands.o (NLS)
    14.000
    15.000 read.o     : read.c  vars.h commands.c
    16.000   CC read.c over read.o (NLS)
    17.000
    18.000 symbols.o  :  symbols.c  vars.h tables.h
    19.000   CC symbols.c over symbols.o (NLS)
    20.000
    21.000 build.o    :  build.c  vars.h tables.h
    22.000   CC build.c over build.o (NLS)
    23.000
    24.000 files.o    :  files.c   vars.h tables.h targets.h
    25.000   CC files.c over files.o (NLS)
    26.000
    27.000 derive.o   :  derive.f
    28.000   FORTRAN derive.c over derive.o (NLS)
    29.000
 
Notice that long lines were split into two lines using the backslash character
to terminate a line.  MAKE sees these lines as a single long line but it is
easier to edit and read two shorter lines.
 
In MAKE terms, each file that is generated by a program (that is to say, a
non-source file) is the "target" of a "rule".  In the preceding example, the
targets are the individual object files such as main.o, macros.o, etc., and
the final target program.  Targets always appear at the beginning of a line
before the colon.  After the colon, the target's "dependencies" are listed;
that is, all of the files that are used as input when the target file is
updated.  A target file will need to be recompiled or relinked (or whatever)
if any of its dependent files are modified.  In addition, any dependent files
that are themselves generated files will be updated if its dependencies have
been modified before this step is invoked.
 
By default, MAKE starts with the first rule that it finds within a Makefile
(excluding rules whose target names begin with a ".").  This is known as the
default "goal".  In the preceding Makefile, the target program is the default
goal.  The other rules in the Makefile are used because they appear as
dependencies of the goal.
 
After each line containing a target and associated dependencies, the Makefile
contains zero or more lines of IBEX commands that indicate how to recreate the
target file.  These lines start with one or more blanks to tell MAKE that they
are in fact commands.  MAKE does not know anything about how the commands
actually produce the target file, it is up to the writer of the Makefile to
supply commands that will create the file correctly.  All that MAKE does is
execute the commands in the Makefile in the correct order when the target file
needs to be created.
Now it is time to show a complete example of MAKE. In order to keep the size
of this example as small as possible, a new program is going to be shown.  In
this example, the default goal will be a run-unit called RU which is made up
of two Fortran sources called MAIN.f and SUBR.f.    The following sample CP-6
session shows the Makefile being created and the MAKE program run with the
"debug" and "no-op" options (-d and -n respectively).
 
 !b MakeRU
 EDIT E00 here
     1.000 OBJS    =  MAIN.o SUBR.o
     2.000
     3.000 RU   :  $(OBJS)
     4.000   LINK $(OBJS) over $@
     6.000
 !MAKE. -dnfMakeRU
  No Errors and No Warnings in Makefile
 ### MAKE: Target is "RU"
 
   *Deriving: MAIN.o RU
 File: MAIN:o does not exist.
 File: MAIN:f.MYACCT modified Mon May  8 15:36:43 1989
 
   *Deriving: SUBR.o RU
 File: SUBR:o does not exist.
 File: SUBR:f.MYACCT modified Mon May  8 15:36:49 1989
   *Deriving: RU
 File: RU does not exist.
 
 *  Dependency wait=3, Waiting to run=0, Running=0, Errored=0, Completed=0
 *  Ready to run: MAIN.o SUBR.o
 !FORTRAN MAIN:f.MYACCT over MAIN:o,NO
 !FORTRAN SUBR:f.MYACCT over SUBR:o,NO
 
 *  Ready to run: RU
 *  Dependency wait=0, Waiting to run=1, Running=0, Errored=0, Completed=2
 !LINK MAIN:o,SUBR:o over RU
 
 *  Dependency wait=0, Waiting to run=0, Running=0, Errored=0, Completed=3
 ***
 *** Build Complete!
 ***
 
If the "-n" (no-op) option had not been specified, MAKE would have run three
batch jobs,
 
   the first job would have compiled the MAIN program,
   the second would have compiled the SUBR program (note that both of these
   compilations would have taken place simultaneously),
   and finally MAKE would have linked the final run unit with the third batch
   job.
The output of the "-d" option shows the steps that MAKE uses to generate the
final goal "RU". The first item of debug output is the line containing the
path to the target being derived "*Deriving MAIN.o RU". The line following
this shows the current status of the target file (in this case MAIN:o).  When
the target file exists, its modification time is displayed.  The next line
contains the input file used to produce this target and its modification time
(in this case MAIN:f).  When the "-v" option is specified in conjunction with
the "-d" option, MAKE displays the names of the implicit rules that are tried
while locating the input file.  Similar output appears for each of the targets
that will be built when trying to produce the goal(s).
The following example uses MAKE without a Makefile.  In this mode, MAKE tries
to find a method to build the specified target using only built-in rules.
Since no dependencies can be specified without a Makefile, only one file will
be input to the final target.  This simple example uses a Fortran program
called main.f which is compiled and linked to produce the run-unit main.  In
order to use MAKE in this simple case, the only command line option necessary
is the target name.
 
This command uses the "-n" option to display the commands that will be
executed before running the batch job.
 
 !b main:f
 EDIT E00 here
     1.000            print *, 'Hello, world!'
     2.000            end
     3.000
 !MAKE. main -n
 
 *  Dependency wait=1, Waiting to run=0, Running=0, Errored=0, Completed=0
 *  Ready to run: main.o
 
 !FORTRAN main:f.MYACCT over main:o.MYACCT,NO
 !LINK main:o.MYACCT over main.MYACCT
 
 ***
 *** Build Complete!
 ***
 
Notice that the build commands show a Fortran compilation followed by linking
the object unit created by this compilation.  These commands would be run in
one batch job.  MAKE chose to use the Fortran compiler because the source file
used the default naming convention for Fortran source.
 
The following example runs MAKE, which batches a job named main and issues the
commands seen in the previous example.  After creating the main run-unit, the
program is run producing its output message "Hello, world!".  It should be
noted that if the MAKE program were immediately re-run, without modifying the
file main:f, the batch job would not be run because the main run-unit would be
found to be up to date.
 
 !MAKE. main
 
 *  Dependency wait=1, Waiting to run=0, Running=0, Errored=0, Completed=0
 *  Ready to run: main.o
 76597 main.MYACCT running 0:00/1:59
 
 *  Dependency wait=0, Waiting to run=0, Running=1, Errored=0, Completed=0
 
 ***
 *** Build Complete!
 ***
 76597 main.MYACCT completed successfully at 23:28 06/11/89
 !main.
 
 Hello, world!
  *STOP*
 !
A variable reference by itself or as an argument to the logical and (&&) or
logical or (||) functions is treated as an existance test.  An existance test
returns the value 1 if the variable has been defined, otherwise it returns 0.
 
If a more complex expression is required, the function defined is available
which returns 1 if the variable argument exists or 0 if it does not.
MAKE evaluates expressions for the following directives:  :if, :elif, :error
and :print.  These directives produce result values for two different
purposes.  The :if and :elif directives need a true or false value to
determine whether to conditionally include statements from the Makefile.  The
:error and :print directives need a display form of the expression result
value.
VALUES
 
Expressions are always evaluated the same way.  Expressions are made up of the
following kinds of values:
 
o   Integers which consist of the digits 0 through 9.
o   Quoted Integers which consist of up to 4 characters within single quotes
    "'".
o   Strings which consist of a string of characters started and terminated by
    a """ character.  If the """ character is required within the string, it
    must be doubled.
o   Variables which are references to variables within the current Makefile.
 
Expressions can use the above values to produce new values through arithmetic
operations, comparison operations, logical operations or through existance
testing for variables.  The operators provided by MAKE are a subset of those
available in the C programming language and full details about their meaning
can be found in the C language manual.
Strings may only be used in comparison operations and as display values.
Their logical value is always true.
 
Integers and Quoted Integers may be used in arithmetic and comparison
operations.  Their logical value is true if their value is non-zero, otherwise
it is false.
 
Variables may be used in arithmetic, comparison and existance testing.  A bare
variable reference by itself is an existance test, or the "defined" operation
may be applied to a variable name when a more general expression is required.
When a variable reference appears in an expression, it is treated as a string
if the other operand to the operation is a string, or it is treated as an
integer if the other operand is a number.
OPERATORS
 
Expressions may contain operators which a divided into four general
categories:  arithmetic operators, relational operators, logical operators,
and the variable existance testing operator.
 
The following table indicates the precedence of the available operators.
 
                   Operators                Associativity
 
                    ()                      left to right
 
                    !  ~  - sizeof defined  right to left
 
                    * / %                   left to right
 
                    + -                     left to right
 
                    << >>                   left to right
 
                    < <= >>=                left to right
 
                    == !=                   left to right
 
                    &                       left to right
 
                    ^                       left to right
 
                    |                       left to right
 
                    &&                      left to right
 
                    ||                      left to right
 
The sizeof function when applied to a variable reference returns the length of
the variable replacement text.  When sizeof is applied to a string, it returns
the length of the string.
 
More information on the individual operators may be found under the following
HELP topics:  ARITHMETIC_OPERATORS, RELATIONAL_OPERATORS, LOGICAL_OPERATORS
and EXISTANCE_OPERATOR.
00002
00001
Expressions are used to control the inclusion of Makefile records or to print
messages to the user.  When the result of the expression is used to control
the inclusion of records, the expression is said to return a true or false
value according to the following rules based upon the value type:
Integers      have the value true if their value is non-zero, otherwise they
have the value false.
Strings      always have the value true.
Variables      have the value true if they have a value, otherwise they are
undefined and have the value false.
 
When the result of the expression is used to display a message, the actual
value of the expression is displayed, which are strings or integer values.
Undefined variable references cause no addition to the display at all, whereas
defined variable references display the value of the variable.
00001
00002
00003
CP6_FILENAMES
As MAKE sends each command to the command stream to be executed, it examines
the command for the names of targets.  When a Makefile target is found, MAKE
replaces the name of the target with the real CP-6 file identifier.  This
permits the Makefile to always refer to files by their name and suffix and
MAKE provides the mechanism to turn these names into real CP-6 file names.  It
also permits MAKE to insert and modify the accounts in which the files are
found or are destined when using the file searching capability outlined in
topic FILE_SEARCHING.
 
The rules for the filename substitution are:
 
   If the command being processed is link or copy, MAKE inserts commas between
   the file names up to the ON, OVER or INTO verb.
   MAKE scans each command looking for the start of a target name or a "-".
   If a "-" character was found, it and the next character are skipped.
   If the current character could be the start of a target name, the entire
   name is picked up and MAKE checks to see if it has generated this target.
   If MAKE has generated this target (or it was a dependency or something that
   was generated), then the text of the target name is replaced with the
   actual CP-6 file identifier.
   Finally, if this is not the name of a target, then the text is moved into
   the command untouched.
When working with large systems and multiple programmers, it is often
desirable to manage files in separate directories.  For example, the system
may be integrated at certain predetermined intervals to produce new
"controlled" versions, which are not modified until the next integration.  As
work continues on the system, new sources, updates, objects and run-units are
generated by individual members who work with the most recently controlled
versions of the files, plus any changes that they are making.  When it is time
to make a new version of the controlled sources, the new updates are used to
produce a new working system.
 
CP-6 MAKE may be used in this environment by defining a number of variables
which indicate the CP-6 directories to search (and the order to search them)
when locating the target and dependent files.  The following table shows the
macros which must be defined.
 
            Variable Meaning
 
            SIPATH   A list of accounts to search for source files
 
            OUPATH   A list of accounts to search for object files
 
            GNPATH   A list of accounts to search for run-units
 
            UIPATH   A list of accounts to search for updates
 
            SPATHS   A list of variables containing search paths
 
Each of these variables must contain a list of CP-6 accounts separated by
blanks.  The first account in which the file is found becomes the version of
the file MAKE uses.  The variable "SPATHS" is handled special.  Instead of
containing a list of accounts, it contains a list of variables which in turn
contain the accounts to search.  There is a maximum of six additional search
lists which may be defined in this way.
The search list is only used if the rule for producing the file name adds an
account specification and that specification is the first account in one of
the search list variables.  The way MAKE uses the search lists is:
 
o   MAKE tries to open the file as indicated by the default rule for creating
    the CP-6 file name.  If the file is found, no further action is taken.
o   MAKE then looks at the CP-6 file identifier that was generated by the
    rule.  If it has an account specification and that account is the same as
    one of the accounts in the search list, the remaining accounts in the
    matching search list are examined for the file.  The first account in
    which the file is found is used.
 
Updates will only be searched for if there is both an SIPATH (which may
consist of only one account), a non-empty UIPATH value and the account in the
file name that was found matches the very first account in SIPATH. Therefore,
the update file must have the same name as the source file, but be in a
different account.
 
Additionally, there are two additional rules associated with using this mode
of operation.  Certain files such as include or header files are strictly
source files, but may have updates to them.  For the purposes of MAKE, files
found in the SI account and have no rules to produce them, but which other
files depend upon, are moved into the OU account.  By default, this is done
using either a PCL copy command or by using the tool FORMAT.X if there are
updates.  The actual commands used to create the files in the OU account may
be controlled by modifying the special fake targets .copy and .fmt.
 
Target files are produced in either the first account mentioned in the OUPATH
variable or in the first account mentioned in the GNPATH variable, as
indicated by the search list used to locate the file.  Therefore, when an out-
of-date file is found in the OUPATH or GNPATH, MAKE recreates the file in the
very first account mentioned in the appropriate search path.
Example
 
The following example is how a large project with multiple developers would
use this search capability.  Assume for the purposes of this example that the
development accounts are as follows:
 
   The controlled accounts are for the "F0" version of the "XYZ" family.
   These accounts are:  source files are in XYZF0SI, most recently integrated
   updates to source files are in XYZF0UI, most recently integrated object
   unit files are in XYZF0OU, and most recently integrated run unit files are
   in XYZF0GN.
   As the developers work on their changes, they make their own source updates
   in the XYZF0TUI account, putting their latest generated files in the
   XYZDVOU and XYZDVGN accounts.
 
Assuming that the sources are all C sources and use the default ":c" suffix,
here are the lines that would be necessary to add to the Makefile:
 
 SIPATH  =  .XYZF0SI
 OUPATH  =  .XYZDVOU  .XYZF0OU
 GNPATH  =  .XYZDVGN  .XYZF0GN
 UIPATH  =  .XYZF0TUI .XYZF0UI
 
 .c      =  :c.XYZF0SI
 .o      =  :o.XYZDVOU
 .r      =  .XYZDVGN
00001
MAKE provides a number of built-in file types that are associated with its
built-in rules.  The following table shows these file types, their implied
meaning and their default variable value.
 
                File Type Variable Value  Meaning
 
                .c        :c              CC source file
 
                .6        :6              PL6 source file
 
                .a        :a              BMAP source file
 
                .y        :y              YACC source file
 
                .l        :l              LEX source file
 
                .f        :f              FORTRAN source file
 
                .n        :n              PARTRGE source file
 
                .p        :p              PASCAL source file
 
                .h        :h              Include source file
 
                .o        :o              Object file
 
                .r                        Run unit
 
                .herman   :herman         HERMAN source file
 
                .help     HELP:?:         CP-6 Help file
 
                .tex      :tex            TEX source file
 
                .dvi      :dvi            TEX output file
 
                .web      :web            Web source file
 
                .cap      :cap            CAPTEX source file
 
                .makefile Make?           MAKE file
 
                .depends  :depends        MIDGET dependencies
 
                DOPATH    :do             diagnostic output
 
                LOPATH    NO              listing output
 
In this table the two variables DOPATH and LOPATH are special in that they are
not true file suffixes and their interpretation is slightly more robust.
These two variables are used as the patterns for generating the diagnostic
output and the compiler listings associated with the target.  These patterns
are not applied to the base file names, instead they are applied to the full
target name with the "."  characters in the target name transformed into ":".
The command line option "-k" may be used to limit the application of these
patterns to the base target name.  Note that they may take on the value of a
CP-6 device which is not treated as a target suffix.  Notice that the default
value for the listing output is the NO output device (also known as the old
bit bucket).
 
From the previous table, it can be seen that there is actually a file type
associated with run-units although all of the examples have not shown the file
type in the Makefile.  This is because when MAKE finds a target name without a
file type, it gives the target an implicit file type of ".r".  This means that
although the goal of your Makefile may appear as the program MUNGER, its CP-6
file name is generated using the value of the variable ".r".  If the suffix
".r" is used, it must be used consistently - it must always be specified or
never specified within the Makefile or MAKE will be unable to resolve one of
the references.
Syntax
 
:if expression
Parameters
 
expression      is an expression that is evaluated for true or false.
Description
 
If the expression expression has the true value, then the lines following this
directive are included up to the next conditional:  :elif or :else.  The :if
directives may be nested (to a depth of 99) and MAKE understands nested blocks
that are being skipped or included.
00002
00001
There are certain standard ways of remaking target files.  For example, one
standard method is to make an object file from a C source file using the C
compiler.  Implicit rules tell MAKE how to use these standard techniques so
that the writer of the Makefile does not have to specify them for every such
file.
 
For example, C compilation typically takes a ".c" file and produces a ".o"
file.  MAKE will apply its implicit rule when it sees this combination of file
names and there are no explicit rules specified.  A chain of implicit rules
can apply in sequence; for example, MAKE knows how to remake a ".o" file from
a ".y" file via a ".c" file.
 
The built-in implicit rules use several predefined variables in their commands
so that, by changing the values of the variables, the way the implicit rule
works can be modified.  For example, the variable COPTS controls the options
given to the C compiler by the implicit rule for C compilation.
 
In addition to using the built-in rules, Makefiles may define new implicit
rules.
USING RULES
To allow MAKE to find a standard method for updating a target file, the
Makefile merely has to refrain from associating commands with the target
rules, use a consistent naming convention (that allows MAKE to determine the
file type from its file name), and to communicate the naming convention
through variable definitions (for each of the file types that is different
from MAKE's default naming conventions).  In the simplest sense, the user
should write a rule with no command lines or even better, don't write a rule
at all.  Then MAKE will figure out which implicit rule to use based upon the
kinds of source files that it finds.
 
For example, suppose the Makefile looks like this:
 
          foo  :  foo.o bar.o
            link foo.o,bar.o over foo
 
Because "foo.o" is mentioned as a dependency with no rule to produce it, MAKE
looks for an implicit rule that will create it.  This happens whether foo.o
currently exists or not.  MAKE finds an implicit rule when an input file
exists that corresponds with an implicit rule (or chain of implicit rules)
that produces the required file type.
 
If an implicit rule is found, it supplies both the commands and the input file
type.  If the file foo.o has dependencies, they could be indicated in the
Makefile as long as no commands were attached to those rules.  There are
built-in implicit rules for many different input file types producing a ".o"
file type.  MAKE will look at each of these rules for a file that exists.  So,
if MAKE finds a file named foo.c, it will use the C compiler; otherwise, if it
finds a file foo.6, it would use the PL6 compiler.
 
Because MAKE tries suffixes for the rules that it has that might produce the
target file, care must be taken to ensure that only the correct suffix will
find an existing input file.  This is because MAKE uses the first suffix that
produces the name of an existing file for input, which could cause the wrong
rule to be associated with a target.
 
The author of the Makefile knows the implicit rule that should be used and the
actual choice can be verified by using the -d and -a options.
EXPLICIT TYPING
 
The rule to use to produce a target may be specifically requested by providing
a dependency upon the input file type.  For example, if the object file
build.o is a produced by a Pascal source file, the following rule causes MAKE
to only look for the Pascal file:
 
          build.o    :  .p
 
This capability is provided so that MAKE may be used when a consistent file
naming convention has not been used.  One restriction associated with this
rule is that the target file must be produced using the input file by a single
implicit rule.  If such a rule does not exist, MAKE considers it an error.
WRITING IMPLICIT RULES
 
Implicit rules appear like other rules with the exception that they contain
two file types.  For example, the implicit rule to create an object file from
a Fortran source file is ".f.o", which says that this rule transforms a
Fortran source ".f" into an object file ".o".  There are no dependencies
allowed on such a definition, and it must be followed by the commands to
produce the appropriate output file.
00002
00001
00003
Implicit rule commands may reference any of the automatic variables to produce
their target file.  Most commands should be a single line such as this rule
for using the PL6 compiler to produce an object file:
 
          .6.o :
            $(PL6) $< over $@,$& $(PL6OPTS)
 
Notice that the actual name of the PL6 compiler is not provided, a variable
(that can be modified by the Makefile user) is used to specify the compiler
name and also its options.  Also notice that the rule does not care whether
there is SI or both SI and UI input to the PL6 compiler.  This is because the
"$<" variable is setup by MAKE to contain both file names if there are updates
provided.
 
When an implicit rule is used to generate a target, the input file that is
found (and is defined in "$<" becomes an implicit dependency of the target.
It is not necessary therefore (and not recommended) to provide an explicit
dependency for the input file.
It is not necessary to write the commands for compiling individual C (or
Fortran) source files as long as a consistent naming convention is used which
indicates the type of source file  (see topic IMPLICIT_RULES), or each output
file type has as an explicit dependency the type of file used to produce it
(see topic SOURCE_FILE_TYPING). MAKE has built-in rules for producing object
files corresponding to C, Fortran, Pascal, PL6, PARTRGE and BMAP source files.
For example, it will use the command "CC main:c over main:o" to compile main.c
into main.o.  Therefore, the commands could be omitted from the rules for the
object files.
 
When a ".c" file is used implicitly,the source file becomes an automatic
dependency and is added to the list of dependencies.  Therefore, the ".c"
files (and ".f" files) should be omitted from the list of explicit
dependencies.
 
At this point, the Makefile  created for HELP TOPIC "EXAMPLES" is shown with
the changes that could be made to this point.
 
 !B Makefile
 EDIT E00 here
     1.000 objects = main.o macros.o commands.o read.o symbols.o \
     1.000           build.o files.o derive.o
     3.000
     4.000 program      :  $(objects)
     5.000     link $(objects) over program
     6.000
     7.000 main.o       :  vars.h
     8.000 macros.o     :  vars.h targets.h
     9.000 commands.o   :  vars.h targets.h
    10.000 read.o       :  vars.h tables.h
    11.000 symbols.o    :  vars.h tables.h
    12.000 build.o      :  vars.h tables.h
    13.000 files.o      :  vars.h targets.h tables.h
    14.000
 
Since the rules for the object files specify only dependencies, the preceding
Makefile could be written by combining dependencies instead of targets.  This
would produce a Makefile like  this:
 
 !B Makefile
 EDIT E00 here
     1.000 objects = main.o macros.o commands.o read.o symbols.o \
     1.000           build.o files.o derive.o
     3.000
     4.000 program      :  $(objects)
     5.000     link $(objects) over program
     6.000
     7.000 $(objects)                        : vars.h
     8.000 macros.o commands.o files.o       : targets.h
     9.000 read.o symbols.o build.o files.o  : tables.h
    10.000
 
Here defs.h is given as a dependency for producing all of the object files;
commands.h and buffer.h are dependencies of the specific object files listed
for them.
 
Whether this is better is a matter of taste - it is definitely more compact,
but some people would dislike it because it can be clearer to put all the
information about a particular target in one place.
The :include directive may be used to request MAKE to suspend reading the
current Makefile and read another file before continuing.  This directive
allows common Makefile lines to be shared by more than one Makefile.  Of
course, the included file can use the other conditional directives to tailor
itself to the current usage.
 
The "-i" command line option affects the way in which include files are
located.  If an account is not specified in the :include directive, then MAKE
uses the search list set up by the "-i" option to locate the file.  The last
entry in the search list is always the current file management account.
 
Up to 11 search paths may be specified on the MAKE invocation.  The -i option
permits the search path to be specified in one of three ways:
ACCOUNT      a simple account  specification of the form -iACCOUNT. A CP-6 fid
is constructed by preceding the ACCOUNT with the name of the include file and
a ".".
NAME_ACCOUNT      a file name and account  specification of the form -
iNAME.ACCOUNT. A CP-6 fid is constructed by inserting the name on the :include
command immediately before the ".".
WILD_ACCOUNT      a wild-carded file name and account  specification of the
form -iWILD?NAME.ACCOUNT. A CP-6 fid is constructed by replacing the "?"
character with the file name on the :include command.
Syntax
 
:include filename
Parameters
 
filename      is the name of the file to be included.  If the filename does
not contain the character ".", then the search list (created by the -i option)
is used to look for the file.
Description
 
This directive causes MAKE to suspend reading the current Makefile and start
reading the file located using the filename option.  When the end of that file
is reached, MAKE will continue reading the current Makefile.  :include
directives may be nested up to 10 files deep.
 
Uses for :include directives include:
 
   sharing common sets of variable definitions,
   sharing common sets of rules,
   reading automatically generated dependencies.
Example
 
If a file named "CommonRules" contained some rules that were common to a
number of projects, then the following command in a Makefile would cause those
rules to be included.
 
    :include  CommonRules     # define some special implicit rules
00001
00006
00007
00002
00005
00003
When the "-e" option is used, the output of the "-a" option is changed to
indicate the owner of the file associated with each action found in the
Makefile in place of file timestamps.  This is sufficient to provide
verification that for every possible step in the Makefile, that there is an
owner.
 
The following figure shows a sample Makefile and an execution of MAKE
demonstrating the output of the "-a" option when used in conjunction with the
"-e" option.
 
 !e MakeErrors
 EDIT E00 here
 *ty 1-10
     1.000 # Makefile to demonstrate electronic mail
     2.000
     2.100 RESOPTS    =  Mem=511,Time=3
     3.000 CC         = CC.:ZBDVGN
     4.000 COPTS      = (SR(.:LIBRARY))
     5.000 OBJS       = a.o b.o c.o
     6.000
     7.000 a    :  $(OBJS)
     8.000   link $^ over $@
     9.000
    10.000 Bill Worker :=  a $(OBJS)
 *q
 !MAKE. -aeenf MakeErrors
 
 Target       State Cmd Output File       Input File           Owner
 a.o          waiti   0 a:o               a:c.MYACCT           Bill Worker
 b.o          waiti   0 b:o               b:c.MYACCT           Bill Worker
 c.o          Compl   0 c:o.MYACCT        c:c.MYACCT           Bill Worker
 a            waiti   1 a                                      Bill Worker
 
 Commands:    .c.o a
 
 *  Dependency wait=3, Waiting to run=0, Running=0, Errored=0, Completed=1
 *  Ready to run: a.o b.o
 
 !CC.:ZBDVGN a:c.MYACCT over a:o,NO (SR(.:LIBRARY))
 
 !CC.:ZBDVGN b:c.MYACCT over b:o,NO (SR(.:LIBRARY))
 
 *  Ready to run: a
 *  Dependency wait=0, Waiting to run=1, Running=0, Errored=0, Completed=3
 
 !link a:o,b:o,c:o.MYACCT over a
 
 ***
 *** Build Complete!
 ***
 !
The logical operators take operands of any type and return either 1 if the
logical relationship is true or 0 if it is false.  The general syntax of the
logical operators is "A op B" where op is one of the following operators:
AND      && if both the left and right operands are true, then the result is
1, otherwise 0.
OR      || if either of the left or right operands is true, then the result is
1, otherwise 0.
00001
00002
MAKE uses variables for various fields in the mailgram.  The following table
indicates the names of the variables and their use.
 
    Variable     Use                          Default Value
 
    MAIL_SUBJECT Mailgram subject field       Integration Failure!
 
    MAIL_COPY    Summary mailgram copy list
 
    MAIL_BODY    Target failure mailgram body  has failed!
 
    MAIL_SUMMARY Summary mailgram body        The following have failed:
 
The variable MAIL_COPY is used for the "cc:"  mail option to send a copy of
each of the summaries to a mail address (usually the project leader).  The
variable MAIL_BODY is used to create a message of the form:
 
  filename MAIL_BODY problem
 
where filename is the name of the failing target file and problem is the
reason that it failed.
 
The variable MAIL_SUMMARY is used to create a message of the form:
 
MAIL_SUMMARY
filename
filename
.
.
 
Figure 8-1 shows an example of a summary mailgram as received by the owner of
the files "a.o" and "b.o".  The owner of the files in this example is "Bill
Worker" and the person running MAKE was "Joe Control".  The variables which
control the mailgram contents had their default values.
 
     Sent: 09/14/89 10:25  Rcvd: 09/14/89 10:25  Number: 147
       To: Bill Worker                             From: Joe Control
  Subject: Integration Failures!
 
 The following have failed:
  a:o
  b:o
 
 ...MAKE.
 
Using this same example, if MAKE had been run with the "-ee" option, then Bill
Worker would have received two mailgrams before the summary mailgram with
specific information about the failures.  The mailgram that Bill Worker
received for the failure of b.o would look like Figure 8-2.
 
     Sent: 09/14/89 10:25  Rcvd: 09/14/89 10:25  Number: 146
       To: Bill Worker                             From: Joe Control
  Subject: Integration Failures!
 
 b:o has failed! See diagnostics file: b:o:do
 
 Diagnostic file contents:
 
 CC.B00 here at 10:25 Thu Sep 14 1989
     2.000         2               int c;
 "*b:c", line 2: c not in parameter list
 "*b:c", line 2: (warning) identifier "cc" is not used
 
 ...MAKE.
 MAKE operates using the following sources of information:
 
   command line options,
   the MAKEFLGS IBEX variable,
   a Makefile database,
   files and their last modification time from the file system,
   a number of built-in rules and variables to produce targets not explicitly
   built.
 
This topic introduces major components of the Makefile database file including
the basic record types.
General Information
 
A Makefile is a standard CP-6 file possibly created by using the EDIT, 6EDIT
or PULSE editors and contains a description of the relationships between the
files of the system being built.  The relationships include such things as the
names of generated files and the names of files used as input to the program
that produces them.
 
Individual records in the Makefile may be of any length although in practice
it is best to break long lines into shorter lines using a "\" character to end
the line to be continued.  Entirely blank lines in the Makefile are treated as
comments as are lines beginning with the "#" character.
Makefile contents
Makefiles contain five kinds of information:  rules, variable definitions,
directives, ownership designations and comments.
 
o   A rule says when and how to recreate one or more files which are known as
    the rule's targets.  It lists the other files that the targets depend
    upon, and may also provide commands to use to create the target (See
    topic WRITING_RULES).
o   A Variable Definition is a line that specifies a text string value for a
    variable that can be used to substitute the string later in the Makefile.
    The simple Makefile example in  topic VARIABLE_EXAMPLE used a variable
    called "objects" as a list of all of the object files  (see topic
    VARIBLES).
o   An Ownership designation indicates the electronic mail address of the
    person (or persons) responsible for a list of target files  (see topic
    EMAIL).
o   Directives are used to:  include other Makefiles; conditionally select
    Makefile commands; or to display messages to the MAKE user  (See topic:
    DIRECTIVES).
o   A "#" in a line of a Makefile starts a comment.  It and the rest of the
    line are ignored.
Naming Makefiles
 
Unlike other MAKE programs, CP-6 MAKE requires that the Makefile name be
specified if it is to be used.  It is a good idea to name Makefiles with
appropriate names such as Makefile or MakeRU where "RU" is the name of the
default goal of the Makefile.
 
The name of the Makefile is provided to MAKE by using the -f option.  The name
of the file must immediately follow the "-f" with no intervening blanks.
Omitting Makefiles
 
A Makefile may not be necessary to use MAKE when there is only a single file
with no dependencies to be built using the built-in implicit rules.  In this
case, simply invoke MAKE with the name of the target file to be produced.  If
the file naming convention needs to be changed from the built-in convention,
or if the built-in compiler options need to be changed, both can be modified
either by specifying the variable values on the invocation line or by using
IBEX variables (see  topic ASSIGNMENT).
00001
00002
00003
00004
After reading the entire makefile, MAKE starts the real work by processing the
first rule, the rule for relinking "program".  Before that rule can be fully
processed, it sees that it must process the rules for the files that program
depends upon.  Each of the object files is processed at this point, according
to their own rules.  These rules show that the object file is recreated by
compiling its source file.  Each compilation must be done if the source file
or any include (header) file named as a dependency has been modified since the
object file was last created (or if the object file does not exist).
 
Before compiling a source file, MAKE also looks for rules for creating the
source or include files.  Since this Makefile does not have any rules for them
(there are no ".c" and ".h" files that are targets of any rules), nothing
needs to be done, but automatically generated source files such as those made
by BISON.X, would be updated by their own rules at this point.
After recompiling the object files which were out of date, MAKE can then
decide whether to relink program.  This will be done if the file program does
not exist, or if any of the object files were more recent than it.  If any
object files were just recompiled, they would be more recent, so program would
be relinked.
CP-6 MAKE provides two directives which allow the Makefile writer to
communicate with the user of MAKE. The directives :error and :print may be
used when the Makefile has been used incorrectly (such as when required
variable definitions are missing).
 
These directives take expressions as their arguments and display them to the
user.  The only difference between the two directives is that the :error
directive includes the linenumber and the name of the file being read with the
message (and incriments the number of errors reported if the verbose option "-
v" is used).  The following figure demonstrates the use of the message
directives to display messages.
 
 !MAKE.:ZBBJFGN -f MakeMyDay 'VERSION=E0A' -p
      1: :print "The variable YACC contains: """, YACC, """"
 The variable YACC contains: "BISON.X"
      2:
      3: :error "Don't know how to link for version: """, VERSION, """"
 "MakeMyDay" line 3: Don't know how to link for version: "E0A"
      4:
 
  One Error and No Warnings in Makefile
 
For more information on the individual directives, see the HELP topics:
PRINT_DIRECTIVE and ERROR_DIRECTIVE.
A rule with multiple targets is equivalent to writing many rules, each with
one target.  The same commands apply to all of the targets, but their effects
may vary because the actual target name is substituted using the special "$@"
variable.  The rule contributes the same dependencies to all of the targets as
well.
CP-6 MAKE allows the rule to be run once for each target file or it may be run
once to produce all of the target files.  MAKE decides which of these cases is
involved based upon the contents of the commands used to create the target.
If the commands reference one of the automatic variables "$<", "$(<D)", or
"$(<F)", the rule is run for every target file, otherwise, MAKE assumes that
the rule should be run once and that all of the target files will be produced.
 
This is useful in two cases:
 
o   Adding common dependencies to a list of files.  No commands are associated
    with the rule.  For example:
 
          kbd.o commands.o files.o : coms.h bufs.h
 
    This provides two additional dependencies to each of the three object
    files mentioned.
o   Similar commands can work for all of the targets.  The commands do not
    need to be absolutely identical, since the automatic variable "$@" can be
    used to substitute the particular target to be remade into the commands.
    For example:
 
          big.c little.c :
            generate $< over $@ ( OPT=$(@F::c=) )
 
    which is equivalent to:
 
          big.c  :
            generate $< over $@ ( OPT=big )
 
          little.c :
            generate $< over $@ ( OPT=little )
 
    In the preceding example, the program generate is assumed to prouced two
    types of output from the same input file, one if given OPT=big and another
    if given OPT=little.
One file can be the target of several rules if at most one rule has commands
associated with it.  The other rules can only have dependencies.  All the
dependencies mentioned in all of the rules are merged into one list of
dependencies for the target.  If the target is older than any of the
dependencies from any of the rules, the commands required to produce the
target are executed.
 
An extra rule with just dependencies can be used to give a few additional
dependencies to many files at one time.  For example, if there is a variable
named objects containing a list of all of the compiler output files being
made, an easy way to say that all of them must be recompiled if the file
"config.h" has been changed is to write:
 
          objects = foo.o bar.o
 
          foo.o : defs.h
          bar.o : defs.h refs.h
          $(objects) : config.h
 
This could be inserted or removed without changing the rules that have
commands for creating the object files, making it a more convenient form to
use when adding additional dependencies.
 
Another possibility is that the additional dependencies could be specified
with a variable that is set with a command argument to MAKE (See  topic
INVOKING_MAKE). For example, with the following line in the Makefile,
 
          $(objects) :  $(extradepends)
 
MAKE could be invoked with the IBEX command:
 
          !MAKE.X -fMakefile 'extradepends=extra.h'
 
which will add an additional dependency to all of the files named in the
variable objects.  If MAKE is invoked without the command line setting of the
extradepends variable, no additional dependencies are added.
 
Finally, if none of the rules for a target have explicit commands, then MAKE
searches for an implicit rule for commands to use to create the file (See
topic IMPLICIT_RULES).
When a target to be built depends upon the fake target .ONLINE, MAKE does not
submit a separate batch job to produce this target.  MAKE builds a stream of
IBEX commands in the same manner as the batch jcl is produced with the
exception that the build commands are preceded by the commands in the fake
target .xeq and are followed by the commands in the fake target .xeqend.
These commands provide the same functionality as the fake targets .jcl and
.end but include commands to resume execution of a saved image of MAKE.
 
MAKE runs an .ONLINE target by producing the commands to be executed, issuing
an IBEX "XEQ" command specifying the file containing the commands, writes the
current status to a star file, and exits to execute the xeq commands.
 
After the IBEX commands have been executed, the status is restored from the
star file and the building process continues.
 
The default .xeq and .xeqend target commands are shown in the following two
figures.
 
 -dir .$(*D)
 -Reset
 -Set M$DO $+
 -let STEPCC=0
 -Echo
 
 -dont echo
 -reset
 -if $fid_exist('$+') then del $+
 -goto resume
 -ABORT: dont echo
 -output 'target $@ failed'
 -Reset
 -resume: dir .$(*D)
 -$(saved_image_MAKE).
 
As with the default .jcl and .end rules, the .xeq and .xeqend rules may be
replaced simply by defining them in the Makefile.
Bruce Frost, LADC
To indicate the owner of a target file, a line with the following form is
written in the Makefile:
 
  email address  := targetlist
 
The email address is a valid CP-6 mail address.  There is only one owner
permitted for any target file.  The targetlist is zero or more make file
names, separated by blanks or commas.
A phony target is one that is not really the name of a file.  It is only a
name for some commands to be executed when this target is explicitly
requested.
 
If a rule is written whose commands do not create the target file, the
commands will be executed every time the target must be remade.  Here is an
example:
 
          clean   :
            -del ?:o
 
Because the delete command does not create a file named "clean", no such file
will ever exist and MAKE will be confused and think that the target rule
failed when this rule is run.
If the fake target is created by mistake, this command will then fail to work
because the file would be considered up to date since it has no dependencies.
 
To avoid this problem, a target can be explicitly declared to be phony by
using the special target .PHONY and making clean dependent upon it as follows:
 
          .PHONY     : clean
 
Once this is done, MAKE will run the commands regardless of whether there is a
file named "clean".
 
A phony target should not be a dependency of a real target file; otherwise,
strange things will result.  Phony targets can have dependencies.  When a
Makefile is used to create multiple programs, it is most convenient to use a
phony target to create all of the programs.  This phony target is usually
called all and it has as dependencies the individual programs which must be
made.  For example:
 
 all     :  prog1 prog2 prog3
 .PHONY  :  all
 
 prog1   :  prog1.o  utils.o
   link prog1.o,utils.o over prog1
 
 prog2   :  prog2.o  utils.o
   link prog2.o,utils.o over prog2
 
 prog3   :  prog3.o sort.o utils.o
   link prog3.o,utils.o,sort.o over prog3
 
Now MAKE will remake all three programs simply by specifying the name of the
Makefile.  Individual programs can be made by explicitly specifying the target
as in "make -fMakefile prog2".
 
Occasionally it is necessary to know which dependency files have changed when
executing the commands associated with a rule.  This is done using the "$?"
automatic variable and a target file.  In some cases, it may not be necessary
for the target file to contain information, the rule simply creates an empty
target file whose only purpose is to contain a modification date used to
indicate which dependency files had changed since the last time this command
had been run.
 
Commands using the "$?"  variable must have some dependencies (or the variable
value is emtpy).  For example, if you wanted to print the changed source files
only after they are working correctly, the following commands could be used:
 
          make_listing  :  a.c b.c c.c
            -copy $(?: =,) to LP(K)
            -copy NO over $@
 
If MAKE is invoked with "make_listing" as one of its goals, a PCL copy command
will copy the source files "a.c", "b.c" or "c.c" to the line printer only if
the source file has been modified since the file "make_listing" was last
modified.
Syntax
 
:print expression,expression,expression,...
Parameters
 
expression      is an expression that evaluates to an integer, a string or a
variable reference.
Description
 
The text formed by joining all of the expression results together is dislayed.
00002
00001
All of the relational operations compare two arguments which are both either
integers or strings.  The general syntax is:  "A op B", where op is one of the
following operators:
LESS      < returns 1 if A is less than B, otherwise 0.
GREATER      > returns 1 if A is greater than B, otherwise, 0.
LESS_EQUAL      <= returns 1 if A is less than or equal to B, otherwise 0.
GREATER_EQUAL      >= returns 1 if A is greater than or equal to B, otherwise
0.
EQUALS      == returns 1 if A is equal to B, otherwise 0.
NOT_EQUALS      != returns 1 if A is not equal to B, otherwise 0.
 
These operators work on arguments that are both arithmetic or both strings.
An error is reported if their types are mixed.  If one of the operands is a
variable reference, the variable is converted to the same type as the other
operand.  If both operands are variable references, they are both treated as
strings.
00005
00002
00004
00001
00003
00006
A Makefile or target is all that is necessary to run MAKE. The files that are
not up to date are determined by MAKE and built-in commands along with
specific commands supplied in the Makefile are used to bring these files up to
date.
 
MAKE may be used to bring all of the files associated with the default goal of
the Makefile up to date, or to selectively bring some of the targets in the
Makefile up to date.  By specifying the appropriate options to MAKE the user
is able to control the operation of this processor.
 
MAKE obtains its options from the following sources:
 
o   the IBEX command line
o   the MAKEFLGS IBEX variable,
o   the MAKEFLGS after reading the Makefile.
 
When options are specified in the MAKEFLGS variable, they appear as they would
be entered on the command line.  The only restriction on the use of this
variable to specify options is that targets may not be specified and a
Makefile name option ("-f") may not be specified within the Makefile.
Otherwise, macro definitions and options may appear within the MAKEFLGS
variable in the same way as they would on the IBEX command line.
MAKEFILE OPTION
The "-f" option is used to specify the name of the Makefile.  For example, "-
fMakeCEM" says to use the file MakeCEM as the Makefile.  The "-f" option may
be specified only once per invocation of MAKE.
GOAL
 
The goals are the targets that MAKE should strive to ensure are up to date.
Other targets will be updated as well, if they appear as dependencies of
goals.  By default, the goal is the first target in the Makefile, excluding
any targets which start with a period.  Therefore, Makefiles are usually
written so that the first target is for compiling the entire program or
library that they represent.
 
A different goal or goals can be specified by using special arguments to MAKE.
In this case, simply specifying the goals on the command line cause MAKE to
process each of those goals in the order they are specified.  Any target in
the Makefile may be the goal when used this way.  For example, if the Makefile
contains:
 
          .PHONY  : all
          all     : opt fe cgg
 
and if all is the goal, then opt, fe and cgg will be brought up to date.
Alternatively, if just cgg is specified as the goal on the command line, then
opt and fe will only be brought up to date if they are needed to produce cgg.
00002
00001
FILE_SEARCHING
By default MAKE will locate the correct source file used to generate a target
file if no rules are specified by scanning through all of the implicit rules
that can generate the required target file type.  This is the simplest mode to
use and is preferred when a consistent file naming convention has been used.
When a consistent naming convention has not been used, MAKE can be directed to
use a particular input file type by adding a dependency upon the input file
type on the target file type.  For example, if the pattern for generating a
Partrge file name is the same as the pattern for generating a PL6 file name,
then MAKE will always find the source file and treat it as PL6 source.  In
order to force MAKE to treat it as a Partrge source, the Makefile must provide
a dependency upon ".n" for the object unit created by Partrge.  Therefore, if
the object unit is nodes.o then the following Makefile line will indicate to
MAKE that it should try to generate this file with the ".n.o" rule:
 
          nodes.o    :  .n
 
Two restrictions are associated with specifically typing the input file type.
First, there must be a single rule to generate the required output file type
from the specified input file type.  If such a one step rule does not exist,
MAKE will consider it to be an error.  Secondly, the pattern used to generate
the input filename is based entirely upon the specified input file type, so
the variable must generate the correct file name.
MAKE recognizes a number of target names as having special meanings.  The
following special targets are recognized by MAKE.
ONLINE      .ONLINE     dependencies are created by executing commands by the
current session, not by submitting batch jobs.  This is the preferred method
of recursively executing MAKE. This fake target uses the special targets .xeq
and .xeqend which must be defined (they are automatically defined built-in
targets).  Targets which are temporary files or which have dependencies which
are temporary files are implicit dependencies of .ONLINE. If the "-j0" option
is used to run MAKE, all targets implicitely depend upon .ONLINE.
PHONY      .PHONY     dependencies are considered to be phony targets.  When
it is time to consider such a target, MAKE runs its commands unconditionally,
regardless of whether a file with that name exists or what its last
modification time is.
PRECIOUS      .PRECIOUS     dependencies of this target are given special
treatment.  When MAKE is executing commands to create such a target, it is not
deleted if the operation fails.
jcl      .jcl     commands are used to create the batch jcl to build the
targets (see  topic BATCH_JCL).
end      .end     commands are used to create the batch jcl to build the
targets (see  topic BATCH_JCL).
XEQ       .xeq     commands are used to create the IBEX commands to build the
targets which are dependent upon ".ONLINE" (see  topic ONLINE_JCL).
XEQEND       .xeqend     commands are used to create the IBEX commands to
build the targets which are dependent upon ".ONLINE" (see  topic ONLINE_JCL).
DEFAULT      .DEFAULT     is not implemented.
IGNORE       .IGNORE     is not imlpemented.
SILENT       .SILENT     is not implemented.
 
An entire class of special targets have names made up of the concatenation of
two file suffixes.  Such targets are implicit rules, the way of defining the
commands used to generate an output file type from a given input file type
(see topic IMPLICIT_RULES).
00008
00005
00009
00004
00001
00002
00003
00010
00006
00007
A variable is a name used to represent a string of text, called the variable's
value.  These values are substituted by explicit request into all subsequent
commands in the Makefile.  Variables can be used to represent lists of file
names, options to compilers, program names, directories, or any string of text
that is required to be reproduced in the Makefile.
 
A variable name consists of any sequence of letters, numbers and the following
special characters "_", ".", "$", "?", and "*".  It is traditional to use
upper case letters in variable names, but good style also suggests using lower
case names for internal purposes, reserving upper-case variables for those
which the user may override from the command line.
REFERENCES
 
To insert a variable's value into a command, a single dollar sign is used
followed by the name of the variable within parenthesis.  For example,
$(FORMAT) is a valid reference to the variable FORMAT. This special
significance for "$" is why the way to use a real dollar sign in a command is
to use $$.  A dollar sign must be doubled if it is to begin or immediately
followed by zero or one characters legal in a target name or an opening
parenthesis "(".  In all other cases, the dollar sign should not be doubled.
 
Variable references can be used in any context:  targets, dependencies,
commands, directives and new variable values.  Here is a common kind of
example, where a variable holds the names of all of the object files in a
program:
          objects =  program.o format.o utilities.o
 
          program : $(objects)
            link $(objects) over program
 
          $(objects) :  common.h
 
Variable references work by strict textual substitution.  Thus, the rule:
 
          ac   = c
          test.o : test.c
            $(ac)$(ac) test.c over $@
 
could be used to compile a C program test.c.  This is because spaces around
the variable value are ignored in variable assignments, therefore, the value
of ac is precisely "c".
 
A dollar sign followed by a character other than a dollar sign, open
parenthesis or open brace is treated as a reference to a single character
variable name.  Thus, the variable "x" could be referenced by writing "$x".
However, this is not good practice with the exception of referencing the
special built-in target name variables.
MODIFIED REFERENCES
 
In addition to simple references, variables may be referenced in a manner that
modifies the value of the reference but does not modify the value of the
 
variable being referenced.  Such a reference is known as a substitution
reference.
 
A substitution reference has the form:
 
          $(var:a=b)
 
This means that it replaces every "a" with "b".  Note that this is slightly
different from the UNIX make definition where the string "a" is only found
when it is immediately followed by a blank.  For example:
 
          wom = a.o b.o c.o
          bat = $(foo:.o=.c)
 
This example sets "bat" to "a.c b.c c.c".
ASSIGNMENT
 
Variables may receive values in one of three ways:
 
   A value may be provided on the MAKE command invocation,
   A value may be provided within the Makefile,
   An initial value may be provided by an IBEX command variable,
   Some variables have initial values provided by MAKE.
 
Before MAKE reads the Makefile, it provides initial values for a number of
built-in variables including the default patterns for file types, compiler
names and their default compiler options.  These values may be overriden by
specifying a command line value, defining a corresponding IBEX variable, or
they may be reassigned within the Makefile.  Variables assigned a value on the
command line override any other definitions and may not be reassigned.
Variables are defined within a Makefile by writing a variable assignment of
the form:
 
            variable = replacement
 
When the value of a variable is specified in a Makefile, leading and trailing
blanks are removed before the first nonblank and after the last nonblank.
There is no limit to the length of the value of a variable other than the
amount of memory that is available.  When a definition is long, however, it is
a good idea to break it into several lines by terminating lines to be
continued with a "\".
 
Variables that are not otherwise defined are assumed to contain an empty
string as their initial value.  There are a number of variables which have
built-in initial values, some of which may be assigned values.
 
Unlike other versions of MAKE, CP-6 MAKE replaces a variable reference with
its current value.  Therefore, it is important to order your variable
assignments so that they do not refer to variables defined later in the
Makefile.  This definition permits MAKE to run faster and is also easier to
understand.
 
Variable values may be defined by an IBEX let command which is a variable
assignment that will be retained for the current session.  Variables assigned
initial values in this manner may be reassigned within the Makefile, however,
IBEX variable values override the default MAKE values listed for the file type
variables (see  topic FILE_TYPES) and compiler names and options (See  topic
BUILT_IN_RULES). Since the file type variables begin with a leading "."  and
this is not a legal character in an IBEX variable, the leading "."  is
replaced with the string "f#" when MAKE is looking for these IBEX variables.
For example, to change the default pattern for Pascal source files to the
string ":pas", the following IBEX command is required:
 
          !Let f#p = ':pas'
 
When MAKE is subsequently run, the variable ".p" will have the value ":pas".
00003
00002
00001
In the HELP TOPIC "EXAMPLES", the object files were listed twice in the rule
for program, the first time to show the dependencies and the second to show
the link command.  This duplication is extremely error prone; for example, if
a new object file is added to the program, it may be added to one list and not
both.  This risk can be eliminated and the Makefile can be simplified by using
a variable.  Variables are used to define a text string once and have it
substituted in (possibly) multiple places later.    (see topic VARIABLES).
 
It is standard practice to have a Makefile variable named objects, OBJECTS,
objs, OBJS, obj or OBJ which is simply a list of all of the object file names.
Such a variable is defined in a Makefile in the following manner:
 
          objects = main.o macros.o commands.o read.o symbols.o \
                    build.o files.o derive.o
 
Thereafter, if the same list of names is required, the Makefile may simply
reference the variable objects with the string "$(objects)".  This is how the
rule for program would look as a result of this change:
 
          program    : $(objects)
            link $(objects) over program
The commands associated with a rule consist of CP-6 IBEX commands to be
executed as part of the target build command stream.  These commands are
executed in one stream, in the order in which they appear following the rule.
Each command must begin with an initial blank, and the commands are terminated
by the next blank line, comment or rule.
 
Commands are limited to 255 characters, but MAKE will try continuing the
command with a ";" if the command is longer.  This may or may not work
depending upon the program that is reading the commands.
Command echoing
 
Normally MAKE does not print the commands before they are written to the
command stream.  However, when a command begins with a "@" character, that
character is removed from the command and the command is printed as the job is
being batched.  Typically this is used to print a message indicating the state
of the MAKE process.
 
Additionally, when MAKE is given the command line option "-n", echoing is all
that happens, no jobs are batched  (see topic INVOKING_MAKE). This option is
used to find out which commands MAKE thinks are necessary to build the target
without actually doing them.  Typically, this option is used when writing a
Makefile to verify that MAKE is making all of the correct decisions.
The "-s" option may be used to prevent any echoing, which causes the commands
beginning with "@" to be treated as if the special echo flag was not present.
Command Execution
 
When it is time to execute the commands required to create a target, they are
executed by MAKE executing a single command stream for all of the commands
associated with the rule being used.  The command stream signals back to MAKE
that the target has not been successfully built in one of two ways.
 
First, MAKE looks for a file with the same base file name as the target being
built, but formed using the variable "DOPATH" as if it were a suffix variable.
If this file exists when the commands have completed execution, MAKE assumes
that the target creation was unsuccessful.  This file is assumed to contain
"diagnostic output" associated with the job so that the reason for the failure
can be discerned.
 
Secondly, MAKE looks for the target file (if the file is not a .PHONY target).
If the target file does not exist, MAKE reports a failure to create the
target.
 
When an error occurs, MAKE continues building all of the targets of the final
goal that can be built, as long as they do not depend upon a failed target.
 
CP-6 MAKE knows how to build several targets simultaneously.  As it is
building, every target remaining to be built is examined to determine if all
of the targets upon which it depends upon are already completely up to date.
If they are, MAKE marks that target as ready to run.  By default, MAKE tries
to run up to 511 simultaneous jobs.  The "-j" option may be used to limit the
number of simultaneous jobs that MAKE submits.  If "-j0" is specified, all
jobs are run in the current session, no batch jobs will be submitted.
 
Since the commands are usually run as batch jobs, output from the commands
being used to build the target is not normally saved unless there is a fatal
error producing the target.  Additionally, input to the jobs must be supplied
entirely by dependent files or by the commands used to build the target.
Command Input
 
MAKE normally inserts a "!"  in front of each command as it is being batched,
to indicate that it is an IBEX command.  If a command runs a program which
will ask for input (such as PCL or EDIT), each non-IBEX command must be
preceded by a "!"  character.  This tells MAKE to remove that "!"  and not to
insert its own.
STEPCC
 
MAKE normally checks the condition codes after every command that is executed.
MAKE does this by inserting the following IBEX command:
 
          !if STEPCC>0 then goto ABORT
 
where the ABORT label defines the actions used to terminate the command
stream, leaving notification to MAKE that the target was not made
successfully.
 
In some cases, this may not be appropriate because
 
   the program may not set the step condition codes,
   the command is followed by non-IBEX input, which would cause the program to
   terminate execution before reading all of its input,
   the step condition codes do not matter.
If a command begins with a "-", MAKE will not check the step condition codes
after that command.  The "-" character is removed before the command is added
to the command stream.
 
When an error has been detected by a nonzero step condition code result, MAKE
marks the current target as errored, and continues trying to build as many of
the other targets required for the final target as long as they do not depend
upon any errored targets.  Finally, when MAKE completes execution, it produces
a list of the remaining targets to be built and the reason that they were not
completed.
 
This mode allows the user to locate as many problems as possible each time
MAKE is run, locating possibly independent problems.
00001
00002
00003
00004
Rules appear in the Makefile and indicate when and how to recreate target
files.  Each rule lists the other files that are required to be current when
the target(s) are created (known as dependencies), and are immediately
followed by the commands used to create the target.
 
The order of rules in a Makefile are not significant, except for the rule
known as the default goal which is the target MAKE uses when a target is not
explicitly indicated.  The default goal is the first rule whose target does
not begin with a period.  Traditionally, the default goal is normally the rule
which causes the entire program or all of the programs described by the
Makefile to be created.
Rule Syntax
 
In general, a rule has the following syntax:
 
          targets    :     dependencies
               command
               command
                  .
 
The targets are make file names, separated by spaces or by commas.  Usually
there is only one target for each rule, but in some cases more than one may be
specified, particularly where a single command generates multiple files.
Dependencies are optional in rule definitions.
 
The command lines begin with at least one leading blank.  The first command
must appear on the line immediately following the rule to which it is
attached.  Blank lines in commands are not permitted  (see topic
WRITING_COMMANDS for more information).
 
Long lines may be split by terminating a line with a backslash "\" but this is
not required.  There is no limit on the length of a non-command line.  Command
lines are limited to 256 characters as required by IBEX.
 
Rules are used to indicate two things:  first it tells MAKE how to determine
if a target is out of date, and secondly, it tells MAKE how to create the file
when it is out of date.  The criterion for being out of date is specified in
terms of the file's dependencies, which consist of make file names separated
by spaces or commas (for information on how make file names are mapped into
CP-6 file names see  topic CP6_FILENAMES). The basic concept is that the
contents of the target file depends only upon the contents of the specified
dependent files, so when one of the dependent files has been modified, MAKE
knows that it is time to recreate the target file.
00001
MAKE.X
AID=PROGRAMMING
AID=INTEGRATION
AID=UTILITY
AID=PROJECT_MANAGEMENT
BATCH_JOBS
CONVERSION
FILE_MANIPULATION
RUNUNIT_MANIPULATION
OBJECT_UNIT_MANIPULATION
LINKING
UNIX
MAKE uses a Makefile database, file timestamps, IBEX command variables and
file dependencies to keep files up-to-date using built-in IBEX commands or
IBEX commands supplied in the Makefile.
