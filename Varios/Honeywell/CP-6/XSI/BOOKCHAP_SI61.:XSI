/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* PLM=3 */
BOOKCHAP: PROC MAIN;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_SUBS_C;
%INCLUDE XU_PERR_C;
%INCLUDE B$JIT_C;
%INCLUDE B_ERRORS_C;
 
DCL M$SI DCB;
DCL M$OU DCB;
DCL M$DO DCB;
 
%FPT_READ (FPTN=READ_SI,
           DCB=M$SI,
           BUF=INPUT_BUFFER);
%FPT_OPEN (FPTN=OPEN_OU,
           NAME=NAME_OUT,
           DCB=M$OU);
%FPT_WRITE (FPTN=WRITE_OU,
            DCB=M$OU,
            BUF=INPUT_BUFFER);
%FPT_CLOSE (FPTN=CLOSE_SI,
            DCB=M$SI);
%FPT_CLOSE (FPTN=CLOSE_OU,
            DCB=M$OU,
            DISP=SAVE);
%FPT_WRITE (FPTN=WRITE_ERROR,
            DCB=M$DO);
%FPT_WRITE (FPTN=WRITE_CHAP,
            DCB=M$DO,
            BUF=NAME_OUT.TEXT);
 
DCL INPUT_BUFFER CHAR(256) STATIC;
 
DCL 1 NAME_OUT STATIC,
      2 L UBIN(9) CALIGNED,
      2 TEXT CHAR(31) INIT('**** No chapter marks found');
DCL 1 PREFIX STATIC,
      2 L UBIN BYTE CALIGNED INIT(0),
      2 T CHAR(31);
DCL 1 SUFFIX STATIC,
      2 L UBIN BYTE CALIGNED INIT(0),
      2 T CHAR(31);
 
DCL M$SI$ PTR STATIC;
DCL M$OU$ PTR STATIC;
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
 
DCL FIRST_SW BIT(1) STATIC;
 
DCL 1 START_MARK BASED(START$),
      2 L UBIN(9),
      2 TEXT CHAR(START_MARK.L);
DCL 1 END_MARK BASED(END$),
      2 L UBIN(9),
      2 TEXT CHAR(END_MARK.L);
DCL START$ PTR STATIC INIT(ADDR(START_CHARS));
DCL END$ PTR STATIC INIT(ADDR(END_CHARS));
DCL START_CHARS CHAR(64) STATIC;
DCL END_CHARS CHAR(64) STATIC;
DCL END_MARK_POS UBIN WORD;
 
%P_PCB (NAME=BOOKCHAP_PCB,
        STCLASS="STATIC SYMDEF",
        R=BOOKCHAP_NODES,
        W=BOOKCHAP_WORKSPACE,
        U$=NIL,
        WSZ=500,
        N#=0);
DCL BOOKCHAP_WORKSPACE(0:499) SBIN WORD STATIC SYMDEF;
DCL BOOKCHAP_NODES SBIN WORD SYMREF;
%PARSE$SYM (NAME=BOOKCHAP$SYM,
            STCLASS="BASED");
%PARSE$OUT (NAME=BOOKCHAP$OUTBLK,
            STCLASS="BASED");
DCL X$PARSE ENTRY(1) ALTRET;
 
DCL PARSE_ERROR_MSG CHAR(0) STATIC INIT('**** Invalid command syntax ***');
DCL FID_ERROR_MSG CHAR(0) STATIC INIT('**** Fid error ****');
DCL SI_GARB_MSG CHAR(0) STATIC INIT('**** SI file has garbage at the front ****');
DCL OU_ERROR_MSG CHAR(0) STATIC INIT('**** Invalid or missing OU file ****');
 
%B$JIT0;
%U$JIT1;
%A$JIT6X;
%B$TCB;
%B$ALT;
%F$DCB;
%EJECT;
/*****************************************************/
 
   M$SI$ = DCBADDR(DCBNUM(M$SI));
   M$OU$ = DCBADDR(DCBNUM(M$OU));
   FIRST_SW = '1'B;
   IF M$OU$->F$DCB.NAME#.L>0
   THEN
      CALL INDEX(END_MARK_POS,'?',
        SUBSTR(M$OU$->F$DCB.NAME#.C,0,M$OU$->F$DCB.NAME#.L)) WHENRETURN DO;
         PREFIX.L = END_MARK_POS;
         PREFIX.T = M$OU$->F$DCB.NAME#.C;
         SUFFIX.L = M$OU$->F$DCB.NAME#.L-END_MARK_POS-1;
         SUFFIX.T = SUBSTR(PREFIX.T,END_MARK_POS+1);
         END;
 
   CALL M$READ (READ_SI) ALTRET (END_OF_SI);
   BOOKCHAP_PCB.ROOT$ = ADDR(BOOKCHAP_NODES);
   IF B$JIT$->B$JIT.CCARS > B$JIT$->B$JIT.CCDISP
   THEN
   DO;
      BOOKCHAP_PCB.TEXT$ = ADDR(B$JIT.CCBUF);
      BOOKCHAP_PCB.NCHARS = B$JIT.CCARS;
      CALL X$PARSE (BOOKCHAP_PCB) ALTRET (PARSE_ERROR);
 
      START_MARK.L = BOOKCHAP_PCB.OUT$->BOOKCHAP$OUTBLK.SUBLK$(1)->
        BOOKCHAP$SYM.COUNT;
      START_MARK.TEXT = BOOKCHAP_PCB.OUT$->BOOKCHAP$OUTBLK.SUBLK$(1)->
        BOOKCHAP$SYM.TEXT;
      END_MARK.L = BOOKCHAP_PCB.OUT$->BOOKCHAP$OUTBLK.SUBLK$(2)->
        BOOKCHAP$SYM.COUNT;
      END_MARK.TEXT = BOOKCHAP_PCB.OUT$->BOOKCHAP$OUTBLK.SUBLK$(2)->
        BOOKCHAP$SYM.TEXT;
      END;
   ELSE
   DO;
      CALL INDEX(END_MARK_POS,SUBSTR(M$SI$->F$DCB.NAME#.C,0,M$SI$->F$DCB.NAME#.L),INPUT_BUFFER)
      WHENRETURN
      DO;
         START_MARK.L = END_MARK_POS;
         START_MARK.TEXT = SUBSTR(INPUT_BUFFER,0,END_MARK_POS);
         END_MARK.L = M$SI$->F$DCB.ARS# - (M$SI$->F$DCB.NAME#.L + END_MARK_POS);
         END_MARK.TEXT = SUBSTR(INPUT_BUFFER,END_MARK_POS + M$SI$->F$DCB.NAME#.L,END_MARK.L);
         END;
      WHENALTRETURN
      DO;
         START_MARK.L = 7;
         START_MARK.TEXT = '.***** ';
         END_MARK.L = 6;
         END_MARK.TEXT = ' *****';
         END;
      END;
   GOTO AFTER_FIRST_REC;
 
READ_LOOP: ;
 
   CALL M$READ (READ_SI) ALTRET (END_OF_SI);
AFTER_FIRST_REC:;
   IF SUBSTR (INPUT_BUFFER,0,START_MARK.L) = START_MARK.TEXT
   THEN
   DO;
      CALL INDEX (END_MARK_POS,END_MARK.TEXT,INPUT_BUFFER)
      WHENALTRETURN
      DO;
         GOTO CONTINUE;
         END;
      IF FIRST_SW AND WRITE_ERROR.BUF_.BUF$ = ADDR(NIL)
        AND SUBSTR (INPUT_BUFFER,START_MARK.L,END_MARK_POS - START_MARK.L) =
        SUBSTR (M$SI$->F$DCB.NAME#.C,0,M$SI$->F$DCB.NAME#.L)
      THEN GOTO READ_LOOP;
      IF M$OU$->F$DCB.FCD# THEN DO;
         CALL M$WRITE (WRITE_CHAP);
         CALL M$CLOSE (CLOSE_OU) ALTRET (OU_CLOSE_ERROR);
         END;
      CALL CONCAT (NAME_OUT.TEXT, SUBSTR (PREFIX.T,0,PREFIX.L),
        SUBSTR (INPUT_BUFFER,START_MARK.L,END_MARK_POS - START_MARK.L),
        SUBSTR (SUFFIX.T,0,SUFFIX.L));
      NAME_OUT.L = END_MARK_POS - START_MARK.L + PREFIX.L + SUFFIX.L;
      FIRST_SW = '0'B;
      CALL M$OPEN (OPEN_OU) ALTRET (OU_OPEN_ERROR);
      GOTO READ_LOOP;
      END;
 
CONTINUE: ;
   IF FIRST_SW
   THEN
   DO;
      WRITE_ERROR.BUF_ = VECTOR(SI_GARB_MSG);
      CALL M$WRITE (WRITE_ERROR);
      FIRST_SW = '0'B;
      END;
   IF NOT M$OU$->F$DCB.FCD# THEN GOTO READ_LOOP;
   WRITE_OU.BUF_.BOUND = M$SI$->F$DCB.ARS# - 1;
   CALL M$WRITE (WRITE_OU) ALTRET (WRITE_ERROR);
   GOTO READ_LOOP;
 
END_OF_SI: ;
   IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$EOF
   THEN
      CALL M$MERC;
   CALL M$WRITE (WRITE_CHAP);
   IF M$OU$->F$DCB.FCD# THEN
      CALL M$CLOSE (CLOSE_OU) ALTRET (OU_CLOSE_ERROR);
   CALL M$EXIT;
 
%EJECT;
OU_OPEN_ERROR: ;
   CALL M$MERC;
   CALL M$EXIT;
 
OU_CLOSE_ERROR: ;
   CALL M$MERC;
   CALL M$EXIT;
 
PARSE_ERROR: ;
   WRITE_ERROR.BUF_ = VECTOR(PARSE_ERROR_MSG);
   CALL M$WRITE (WRITE_ERROR);
   CALL M$EXIT;
 
FID_ERROR: ;
   WRITE_ERROR.BUF_ = VECTOR(FID_ERROR_MSG);
   CALL M$WRITE (WRITE_ERROR);
   CALL M$EXIT;
 
WRITE_ERROR: ;
   CALL M$MERC;
   CALL M$EXIT;
 
END BOOKCHAP;
