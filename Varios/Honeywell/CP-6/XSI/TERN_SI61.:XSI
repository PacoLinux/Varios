/*M* TERN_SI61 - Main module for the TERN processor.             */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
TERN: PROC MAIN;
 
/*X* PLM=3,SQB,AND,ENI=0,SDI=3,CSI=0,ECI=0,IND=0,IAD=3,MOC,MEC,CLM=0,MCL=1,EXM=0,NTB */
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE NK_VFC_C;
%INCLUDE B_ERRORS_C;
 
%INCLUDE TERN_C61; /* COMMON MACROS */
%INCLUDE TERN_C62; /* ERROR MESSAGE SUBS */
%INCLUDE TERN_C63; /* PARSE NODE SUBS */
 
%INCLUDE B$JIT;
DCL B$JIT$ PTR SYMREF;
 
DCL RANTIME ENTRY(3) ;
%INCLUDE XU_MACRO_C; /* XUR MACROS */
%INCLUDE XUH_MACRO_C; /* XUH MACROS */
%INCLUDE XUR_ENTRY; /* XUR ENTRY DCLS */
DCL XU_OUTPUT_OPTIONS ENTRY CONV(5); /* Force linking of XUR$OPENOUT_SPEC */
%INCLUDE XU_PERR_C; /* XUR ERROR SUBS */
%INCLUDE XUE_MACRO_C;
%XUE_ENTRIES;
 
%F$DCB;
 
DCL B$TCB$ PTR SYMREF;
%B$TCB(STCLASS="BASED(B$TCB$)");
%B$ALT;
 
%FPT_UNFID(FPTN=LM_UNFID,
 STCLASS=CONSTANT,
 DCB=M$LM,
 TEXTFID=ERRF_FID.NAME#,
 LEN=ERRF_LEN);
 
DCL ERRF_LEN UBIN STATIC;
 
%VLP_NAME (FPTN = ERRF_FID,
 STCLASS = STATIC);
 
%FPT_PROMPT (FPTN=SI_PROMPT,
 STCLASS=CONSTANT,
 PROMPT=PROMPT.C,
 VFC=YES,
 DCB=M$SI);
 
DCL 1 PROMPT CONSTANT ALIGNED,
       2 L UBIN BYTE CALIGNED INIT(%(256+6)),
       2 C CALIGNED,
          3 * CHAR(1) INIT(%VFC_TRANSITION0),
          3 * CHAR(5) INIT('Tern:');
 
DCL 1 LOG_BUFF STATIC ALIGNED,
       2 VFC CHAR(1) CALIGNED INIT(%VFC_TRANSITION1),
       2 CHARS CHAR(%LOG$RLEN) CALIGNED INIT(' ');
 
DCL LOG_CHRCNT UBIN;
 
%FPT_WRITE(FPTN=LOG_WRITE,
 DCB=F$LOG,
 VFC=YES);
 
%XUR_INIT (NAME=FPT_INIT,
 STCLASS=CONSTANT,
 ABORT=TERN_ABORT,
 BRKMSG=TERN_BRKMSG,
 PREPROCESS=YES,
 PREPROCESSOR=X$PRE_PROCESS);
 
%FPT_INT (STCLASS=CONSTANT,
 UENTRY=XUR$BREAK);
 
%XUH_PARAM (NAME = XUH_PARAM,
 STCLASS = STATIC);
DCL EXITING BIT(1) STATIC;
%VLP_ERRCODE (FPTN = PARSE_ERR,
 STCLASS = STATIC);
DCL OUT$ REDEF PARSE_ERR PTR;
 
%FPT_ERR(FPTN=SI_ERR,
 CODE=PARSE_ERR,
 STEPCC=ERROR,
 STCLASS=CONSTANT);
 
%PARSE$OUT (NAME=OUT$BLK,
 STCLASS=BASED);
%PARSE$SYM (NAME = OUT$SYM,
 STCLASS = BASED);
 
%FPT_OPEN(FPTN=UI_OPEN,
 STCLASS=CONSTANT,
 DCB=M$UI,
 ACS=SEQUEN,
 ASN=DEVICE,
 FUN=IN);
 
%FPT_READ(FPTN=UI_READ,
 STCLASS=STATIC,
 DCB=M$UI,
 BUF=SEND_BUFF);
 
%FPT_PROMPT (FPTN=UI_PROMPT,
 STCLASS=CONSTANT,
 PROMPT=SEND_PROMPT,
 DCB=M$UI);
 
DCL SEND_PROMPT CHAR(0) CONSTANT INIT('Send:');
 
%FPT_EOM(FPTN=UI_EOM,
 STCLASS=STATIC,
 DCB=M$UI,
 TIMEOUT=50,
 UTYPE=MIL10);
 
%FPT_EOM(FPTN=SI_EOM,
 STCLASS=STATIC,
 DCB=M$SI,
 TIMEOUT=0,
 UTYPE=MIL10);
 
%FPT_OPEN(FPTN=LOG_OPEN,
 STCLASS=CONSTANT,
 DCB=F$LOG,
 ORG=UR,
 ACS=SEQUEN,
 ASN=DEVICE,
 RES='ME',
 CTG=YES,
 FUN=CREATE,
 EXIST=ERROR);
 
%FPT_OPEN (FPTN=OPEN_OUT,
 STCLASS=CONSTANT,
 DCB=M$LO,
 ORG=TERMINAL,
 ACS=SEQUEN,
 ASN=DEVICE,
 FUN=CREATE,
 EXIST=ERROR);
 
%FPT_OPEN (FPTN=OPEN_SCRIPT,
 STCLASS=CONSTANT,
 DCB=F$SCRIPT,
 SCRUB=YES,
 ORG=CONSEC,
 ACS=SEQUEN,
 ASN=DEVICE,
 RES='ME',
 FUN=CREATE,
 EXIST=ERROR);
 
%FPT_WRITE(FPTN=WRITE_SCRIPT,
 DCB=F$SCRIPT,
 BUF=SCRIPT_BUFF,
 STCLASS=STATIC);
 
%FPT_OPEN (FPTN=CG_SETDCB,
 STCLASS=STATIC,
 SETDCB=YES,
 ASN=COMGROUP,
 DCB=F$CG,
 NAME=CG_NAME,
 IXTNSIZE=100,
 ACCT=CG_ACCT,
 FUN=CREATE,
 EXIST=OLDFILE,
 AU=YES,
 CTG=YES);
 
%VLP_ATTR(FPTN=CG_ACCESS,
 STCLASS=CONSTANT);
%VLP_ACCESS(ACCT='?',
 EXEC=YES,
 READ=YES,
 WNEW=YES,
 AU=YES,
 AURD=YES,
 TCTL=YES,
 DELF=YES,
 REATTR=YES,
 LAST=";");
 
%VLP_SETSTA (FPTN=CG_SETSTA,
 STCLASS=STATIC,
 MYSTATION='TERN');
 
%VLP_NAME (FPTN=CG_NAME,
 STCLASS=CONSTANT,
 NAME='QUACCG');
 
%VLP_ACCT (FPTN=CG_ACCT,
 STCLASS=CONSTANT,
 ACCT='        ');
 
%FPT_READ(FPTN=CG_READ,
 STCLASS=STATIC,
 DCB=F$CG,
 TRANS=YES,
 WAIT=NO,
 EVENT=%EV$CGREAD,
 BUF=CG_BUFF);
 
%FPT_EVENT(STCLASS=CONSTANT,
 UENTRY=TERN_EVENT);
DCL TERN_EVENT ENTRY ASYNC;
DCL TERN_ABORT ENTRY;
DCL TERN_BRKMSG ENTRY;
DCL TERN_LOG ENTRY(2);
DCL TERN_CONTEXT ENTRY(1);
 
%FPT_TIME(FPTN=GET_SYS_UTS,
 STCLASS=CONSTANT,
 SOURCE=CLOCK,
 DEST=UTS,
 TSTAMP=SYS_UTS);
 
DCL SYS_UTS UBIN STATIC INIT(0);
DCL REF_UTS UBIN STATIC INIT(0);
DCL SCRIPT_UTS UBIN STATIC INIT(0);
 
%FPT_WAIT(STCLASS=STATIC);
 
%VLP_ERRCODE (FPTN = ERROR_CODE,
 FCG = "ZZ",
 MID = "Z",
 STCLASS = STATIC);
 
DCL 1 B_VERSION CALIGNED SYMREF,
       2 L UBIN BYTE CALIGNED,
       2 C CHAR(6) CALIGNED;
DCL 1 B_VERSION_ CALIGNED BASED,
       2 L UBIN BYTE CALIGNED,
       2 C CHAR(B_VERSION.L) CALIGNED;
 
DCL TERN_CMDS BIT(1) SYMREF;
DCL STA_DEF BIT(1) SYMREF;
 
DCL SEND_BUFF CHAR(%CG$MAXMC#) STATIC;
DCL SEND_CHRCNT UBIN STATIC;
DCL SCRIPT_BUFF CHAR(%CG$MAXMC#) STATIC;
DCL SCRIPT_CHRCNT UBIN STATIC;
 
DCL WAIT_TIME UBIN STATIC INIT(0);
DCL PACE_TIME UBIN STATIC INIT(0);
DCL TIME1 UBIN WORD ALIGNED STATIC INIT(0) ;
DCL TIME2 UBIN WORD ALIGNED STATIC INIT(0) ;
 
DCL NPTR UBIN WORD ALIGNED AUTO ;
DCL PTR$ PTR ALIGNED AUTO ;
DCL UBIN_TEMP UBIN AUTO;
 
%CONTEXT (STCLASS="STATIC");
 
%GLOBALS (STCLASS="STATIC SYMDEF");
 
%EJECT;
   EXITING = %NO#;
   REMEMBER MISC_CLEANUP IN TERN_BREAK_PLACE;
   CALL XUR$INIT(FPT_INIT);
   CALL M$UNFID(LM_UNFID);
   ERRF_FID.L# = ERRF_LEN;
   CALL XUR$SETERRMSG(ERRF_FID);
   CALL M$INT(FPT_INT);
   CTX$ = ADDR(CONTEXT);
   CALL M$OPEN(OPEN_OUT);
 
   ERROR_CODE.ERR# = %ERR$HI_THERE#;
   ERROR_CODE.SEV = 0;
   CALL XUR$ERRMSG (ERROR_CODE,,,VECTOR(ADDR(B_VERSION)->B_VERSION_));
/*E*    ERROR:   ZZZ-ERR$HI_THERE#-0
        MESSAGE: TERN %U1 here
       MESSAGE1: You asked for the TERN processor.
                 You got it, now what do you want?
*/
 
   IF (B$JIT.CCARS = B$JIT.CCDISP) THEN GOTO NOOPT;
   CALL XUR$GETCMD(STA_DEF,OUT$,,SUBSTR(B$JIT.CCBUF,
     B$JIT.CCDISP+1,
     B$JIT.CCARS-B$JIT$->B$JIT.CCDISP),
     B$JIT.CCARS-B$JIT.CCDISP)
   WHENRETURN DO;
      CG_SETSTA.ISTA.ISTATION#=OUT$->OUT$SYM.TEXT;
      CG_SETSTA.OSTA.OSTATION#=OUT$->OUT$SYM.TEXT;
      CG_SETDCB.V.AU#='00'B;
   END;
   WHENALTRETURN DO;
NOOPT: ;
   END;
   CALL BINCHAR(CG_SETSTA.MYSTATION#,B$JIT.SYSID);
   CALL INSERT(CG_SETSTA.MYSTATION#,0,4,'TERN');
   CALL M$OPEN(CG_SETDCB);
 
   CALL M$EVENT(FPT_EVENT);
%EJECT;
   DO WHILE (NOT EXITING);
 
      CALL M$TIME(GET_SYS_UTS);
      REF_UTS = SYS_UTS;
 
      IF DCBADDR(DCBNUM(F$CG))->F$DCB.FCD# THEN
      DO INHIBIT;
         UBIN_TEMP = REF_UTS+(WAIT_TIME)*100 ;
         DO WHILE(READS_OUT < 1
           | SYS_UTS < UBIN_TEMP );
            DO WHILE(READS_OUT < 1);
               CALL M$READ(CG_READ) ALTRET(ALT_ERROR);
               READS_OUT = READS_OUT + 1;
               UBIN_TEMP = REF_UTS+(WAIT_TIME)*100 ;
            END;
            CALL M$TIME(GET_SYS_UTS);
            UBIN_TEMP = REF_UTS+(WAIT_TIME)*100 ;
            IF (READS_OUT > 0)
              AND ( SYS_UTS < UBIN_TEMP )
            THEN DO;
               FPT_WAIT.V.UNITS# = WAIT_TIME
                 - (SYS_UTS-REF_UTS)/100;
               CALL M$WAIT(FPT_WAIT);
            END /* IF */;
         END /* WHILE */;
      END /* INHIBIT */;
 
      WAIT_TIME = PACE_TIME;
      IF SENDFILE THEN DO;
         CALL M$READ(UI_READ) WHENALTRETURN DO;
            IF B$TCB.ALT$->B$ALT.ERR.ERR# ~= %E$TIMO
            THEN GOTO ALT_ERROR;
         END;
         SENDFILE_RECORD = SENDFILE_RECORD + 1;
         SEND_CHRCNT = DCBADDR(DCBNUM(M$UI))->F$DCB.ARS#;
         IF DCBADDR(DCBNUM(M$UI))->F$DCB.EOMCHAR# ~= %EOM_EOR# THEN DO;
            CALL INSERT(SEND_BUFF, SEND_CHRCNT, 1,
              DCBADDR(DCBNUM(M$UI))->F$DCB.EOMCHAR#);
            SEND_CHRCNT = SEND_CHRCNT + 1;
         END;
         IF SEND_CHRCNT > 0 THEN DO;
            CALL SEND(SEND_BUFF, SEND_CHRCNT) ALTRET(ALT_ERROR);
         END /* Some to send */;
      END /* SENDFILE */;
 
      ELSE IF PROMPT_FLAG = %NO# THEN DO ;
         CALL XUR$GETCMD(TERN_CMDS,OUT$,PROMPT) ALTRET(PARSE_ERROR);
 
         DO CASE (OUT$ -> OUT$BLK.CODE); /* ON COMMAND TYPE */
 
         CASE (%T$SENDSTR);
            NPTR = 0 ;
            PTR$ = OUT$->OUT$BLK.SUBLK$(NPTR) ;
            IF PTR$->OUT$BLK.CODE = %T$WAIT THEN DO ;
               CALL CHARBIN ( WAIT_TIME, PTR$->OUT$BLK.SUBLK$(0)->
                 OUT$SYM.TEXT ) ;
               IF PTR$->OUT$BLK.NSUBLKS > 1 THEN DO ;
                  TIME1 = WAIT_TIME ;
                  CALL CHARBIN ( TIME2, PTR$->OUT$BLK.SUBLK$(1)->
                    OUT$SYM.TEXT ) ;
                  CALL RANTIME ( WAIT_TIME, TIME1, TIME2 ) ;
               END ;
               NPTR = NPTR + 1 ;
            END ;
            ELSE
            WAIT_TIME = 0 ;
            PTR$ = OUT$->OUT$BLK.SUBLK$(NPTR) ;
            CALL GETSTRING ( SEND_BUFF, SEND_CHRCNT, PTR$->OUT$BLK ) ;
            NPTR = NPTR + 1 ;
            IF NPTR < OUT$->OUT$BLK.NSUBLKS THEN DO ;
               PTR$ = OUT$->OUT$BLK.SUBLK$(NPTR) ;
               CALL GETSTRING ( PROMPT_BUFF, PROMPT_CHRCNT,
                 PTR$->OUT$BLK ) ;
            END ;
            ELSE
            PROMPT_CHRCNT = 0 ;
            IF WAIT_TIME > 0 THEN DO ;
               FPT_WAIT.V.UNITS# = WAIT_TIME ;
               CALL M$WAIT ( FPT_WAIT ) ;
            END ;
            CALL SEND ( SEND_BUFF, SEND_CHRCNT ) ALTRET ( ALT_ERROR ) ;
            IF PROMPT_CHRCNT > 0 THEN
            PROMPT_FLAG = %YES# ;
 
         CASE (%T$SENDFILE, %T$SEND);
            CALL XUR$OPENOUT( , OUT$->OUT$BLK, UI_OPEN) ALTRET(ALT_ERROR);
            IF OUT$->OUT$BLK.CODE = %T$SENDFILE THEN DO;
               UI_READ.V.DVBYTE.TRANS# = %NO#;
               CALL M$PROMPT(UI_PROMPT) WHENALTRETURN DO; END;
            END;
            ELSE DO;
               UI_READ.V.DVBYTE.TRANS# = %YES#;
               CALL M$EOM(UI_EOM) ALTRET(ALT_ERROR);
            END;
            SENDFILE = %YES#;
 
         CASE (%T$WAIT);
            CALL CHARBIN (WAIT_TIME, OUT$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
            IF OUT$->OUT$BLK.NSUBLKS > 1 THEN DO ;
               TIME1 = WAIT_TIME ;
               CALL CHARBIN ( TIME2, OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT) ;
               CALL RANTIME ( WAIT_TIME, TIME1, TIME2 ) ;
            END ;
 
         CASE (%T$PACE);
            CALL CHARBIN (PACE_TIME, OUT$->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
 
         CASE (%T$OUT);
            CALL XUR$OPENOUT( , OUT$->OUT$BLK, OPEN_OUT ) ALTRET(ALT_ERROR);
            OUT_FLAG = %YES#;
 
         CASE (%T$DONTOUT);
            OUT_FLAG = %NO#;
 
         CASE (%T$DOOUT);
            OUT_FLAG = %YES#;
 
         CASE (%T$SCRIPT);
            CALL XUR$OPENOUT( , OUT$->OUT$BLK, OPEN_SCRIPT ) ALTRET(ALT_ERROR);
            SCRIPT_FLAG = %YES#;
            CALL M$TIME(GET_SYS_UTS);
            SCRIPT_UTS = SYS_UTS;
 
         CASE (%T$DONTSCRIPT);
            SCRIPT_FLAG = %NO#;
 
         CASE (%T$LOG);
            CALL TERN_LOG(CONTEXT.LOG_VFC, CONTEXT.LOG_CHRCNT+1);
            CONTEXT.LOG_CHRCNT = 0;
            CONTEXT.LOG_VFC = %VFC_EXT;
            CALL XUR$OPENOUT( , OUT$->OUT$BLK, LOG_OPEN) ALTRET(ALT_ERROR);
            LOG_FLAG = %YES#;
 
         CASE (%T$DOLOG);
            CALL TERN_LOG(CONTEXT.LOG_VFC, CONTEXT.LOG_CHRCNT+1);
            CONTEXT.LOG_CHRCNT = 0;
            CONTEXT.LOG_VFC = %VFC_EXT;
            LOG_FLAG = %YES#;
 
         CASE (%T$DONTLOG);
            CALL TERN_LOG(CONTEXT.LOG_VFC, CONTEXT.LOG_CHRCNT+1);
            CONTEXT.LOG_CHRCNT = 0;
            CONTEXT.LOG_VFC = %VFC_EXT;
            LOG_FLAG = %NO#;
 
         CASE (%T$LOGSTR);
            CALL TERN_LOG(CONTEXT.LOG_VFC, CONTEXT.LOG_CHRCNT+1);
            CONTEXT.LOG_CHRCNT = 0;
            CONTEXT.LOG_VFC = %VFC_EXT;
 
 
            CALL GETSTRING( LOG_BUFF.CHARS, LOG_CHRCNT, OUT$->OUT$BLK);
 
            CALL TERN_LOG( LOG_BUFF.VFC, LOG_CHRCNT + 1);
 
         CASE (%T$OPEN);
            CALL OPENCG( OUT$->OUT$BLK ) ALTRET(ALT_ERROR);
 
         CASE (%T$QUIT);
            EXITING = %YES#;
 
         CASE (%T$NULL);
 /* Do nothing nothing, but let PACE have it's effect. */
 
         CASE (ELSE);
            ERROR_CODE.ERR# = %ERR$UNIMP_CMD#;
            ERROR_CODE.SEV = 2;
            CALL XUR$ERRMSG (ERROR_CODE);
/*E*    ERROR:   ZZZ-ERR$UNIMP_CMD#-2
        MESSAGE: Sorry, that command has not been implemented.
*/
 
         END /* CASE */;
      END /* NOT SENDFILE */;
 
      IF SCRIPT_FLAG THEN DO;
 
         IF OUT$->OUT$BLK.CODE ~= %T$SEND
           AND OUT$->OUT$BLK.CODE ~= %T$SENDFILE
           AND OUT$->OUT$BLK.CODE ~= %T$SENDSTR
           AND OUT$->OUT$BLK.CODE ~= %T$PACE
           AND OUT$->OUT$BLK.CODE ~= %T$WAIT
           AND OUT$->OUT$BLK.CODE ~= %T$SCRIPT
           AND OUT$->OUT$BLK.CODE ~= %T$DONTSCRIPT
         THEN CALL XUR$ECHO(DCBNUM(F$SCRIPT));
      END /* Script stuff */;
 
      DO WHILE (%NO#);
PARSE_ERROR: ;
         CALL XUR$ECHOIF (DCBNUM(M$DO));
         IF PARSE_ERR.ERR# = %E$SYNERR
         THEN
         CALL XUR$ERRPTR (,DCBNUM(M$DO));
         ELSE DO;
            CALL XUR$ERRMSG(PARSE_ERR,DCBNUM(M$SI));
            IF PARSE_ERR.MON THEN CALL M$ERR(SI_ERR);
         END;
      END;
 
      DO WHILE (%NO#);
ALT_ERROR:
         CALL XUR$ERRMSG (B$TCB.ALT$->B$ALT.ERR,
           B$TCB.ALT$->B$ALT.DCB#);
 
 /* If we are running in ghost or batch, and get stuck
    in a read loop because the CG isn't availiable,
    X-off the user. */
 
         IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$READ AND
           B$JIT$->B$JIT.MODE ~= %MODE_INT# THEN
         CALL M$XXX;
 
 
MISC_CLEANUP:
         WAIT_TIME = 0;
         SENDFILE = %NO#;
         SENDFILE_RECORD = 0;
         PROMPT_FLAG = %NO# ;
         CALL M$PROMPT(SI_PROMPT)
         WHENALTRETURN DO; END;
         CALL M$EOM(SI_EOM)
         WHENALTRETURN DO; END;
      END;
ITS_OK:
   END; /* END WHILE NOT EXITING */
 
BAILOUT: ;
   CALL TERN_LOG(CONTEXT.LOG_VFC, CONTEXT.LOG_CHRCNT+1);
   CALL XUR$CLOSE_DCBS; /* CLOSE ALL DCBS WITH SAVE */
   RETURN;
%EJECT;
GETSTRING: PROC( BUFF, CHRCNT, O$BLK);
 
DCL BUFF CHAR(%CG$MAXMC#) CALIGNED;
DCL CHRCNT UBIN;
%PARSE$OUT (NAME=O$BLK, STCLASS="");
 
DCL I UBIN;
DCL J UBIN;
DCL N UBIN BYTE;
DCL D UBIN;
 
   CHRCNT = 0;
   DO I = 0 TO O$BLK.NSUBLKS-1;
      DO CASE(O$BLK.SUBLK$(I)->OUT$BLK.CODE);
      CASE(%T$QUOTED);
         CALL INSERT( BUFF, CHRCNT, O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$SYM.
           COUNT,
           O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
         CHRCNT = CHRCNT + O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
      CASE(%T$MNEMONIC);
         CALL INSERT( BUFF, CHRCNT, , BINASC(O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->
           OUT$BLK.CODE));
         CHRCNT = CHRCNT + 1;
      CASE(%T$OCTAL);
         N=0;
         DO J= 0 TO O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT -1;
            CALL CHARBIN(D, SUBSTR(O$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT,J,1));
            N = (N*8) + D;
         END;
         CALL INSERT(BUFF, CHRCNT, , BINASC(N));
         CHRCNT = CHRCNT + 1;
      END /* CASE */;
   END /* DO I */;
END /* GETSTRING */;
%EJECT;
PUTSTRING: PROC (BUFF, BPOS, STRING, CHRCNT);
 
DCL BUFF CHAR(%CG$MAXMC#) CALIGNED;
DCL BPOS UBIN;
DCL STRING CHAR(CHRCNT) CALIGNED;
DCL CHRCNT UBIN;
 
DCL SPOS UBIN;
 
DCL MNEM(0:31) CHAR(4) CONSTANT INIT('NUL ','SOH ','STX ','ETX ','EOT ',
 'ENQ ','ACK ','BEL ','BS  ','HT  ','LF  ','VT  ','FF  ','CR  ',
 'SO  ','SI  ','DLE ','DC1 ','DC2 ','DC3 ','DC4 ','NAK ','SYN ',
 'ETB ','CAN ','EM  ','SUB ','ESC ','FS  ','GS  ','RS  ','US  ');
 
BINOCT:PROC(BUFF, BPOS, CHR);
 
DCL BUFF CHAR(%CG$MAXMC#) CALIGNED;
DCL BPOS UBIN;
DCL 1 CHR CALIGNED,
       2 SUB(0:2) UBIN(3) UNAL;
 
   CALL BINCHAR(SUBSTR(BUFF,BPOS,1), CHR.SUB(0));
   CALL BINCHAR(SUBSTR(BUFF,BPOS+1,1), CHR.SUB(1));
   CALL BINCHAR(SUBSTR(BUFF,BPOS+2,1), CHR.SUB(2));
END;
 
   SPOS = 0;
 
   DO WHILE SPOS < CHRCNT;
      IF SUBSTR(STRING, SPOS, 1) < ' ' THEN DO;
         CALL INSERT(BUFF, BPOS,, MNEM(ASCBIN(SUBSTR(STRING, SPOS, 1))));
         CALL INDEX(BPOS, ' ', BUFF, BPOS);
         SPOS = SPOS + 1;
      END;
      ELSE IF SUBSTR(STRING, SPOS, 1) = BINASC(127) THEN DO;
         CALL INSERT(BUFF, BPOS,, 'DEL');
         BPOS = BPOS + 3;
         SPOS = SPOS + 1;
      END;
      ELSE IF (SUBSTR(STRING, SPOS, 1) >= ' '
        AND SUBSTR(STRING, SPOS, 1) <= '~') THEN DO;
         CALL INSERT(BUFF, BPOS,, '''');
         BPOS = BPOS + 1;
         DO WHILE (SUBSTR(STRING, SPOS, 1) >= ' '
           AND SUBSTR(STRING, SPOS, 1) <= '~')
           AND SPOS < CHRCNT;
            IF SUBSTR(STRING, SPOS, 1) = '''' THEN DO;
               CALL INSERT(BUFF, BPOS,, '''''');
               BPOS = BPOS + 2;
            END;
            ELSE DO;
               CALL INSERT(BUFF, BPOS,, SUBSTR(STRING, SPOS, 1));
               BPOS = BPOS + 1;
            END;
            SPOS = SPOS + 1;
         END /* While printable */;
         CALL INSERT(BUFF, BPOS,, '''');
         BPOS = BPOS + 1;
      END;
      ELSE DO;
         CALL INSERT(BUFF, BPOS,, '#');
         BPOS = BPOS + 1;
         CALL BINOCT(BUFF, BPOS, SUBSTR(STRING, SPOS, 1));
         BPOS = BPOS + 3;
         SPOS = SPOS + 1;
      END;
 
      IF SPOS < CHRCNT THEN DO;
         CALL INSERT(BUFF, BPOS,, ',');
         BPOS = BPOS + 1;
      END /* IF */;
 
   END /* While more string */;
END PUTSTRING;
%EJECT;
SEND:PROC (BUFF, CHRCNT) ALTRET;
 
DCL CHRCNT UBIN;
DCL BUFF CHAR(CHRCNT) CALIGNED;
 
%FPT_WRITE(FPTN=CG_WRITE,
 STCLASS=STATIC,
 DCB=F$CG,
 TRANS=YES);
 
   IF SCRIPT_FLAG THEN DO;
      CALL M$TIME(GET_SYS_UTS);
      UBIN_TEMP = SCRIPT_UTS + (PACE_TIME*100) + 100 ;
      IF (SYS_UTS > UBIN_TEMP) THEN DO;
         SCRIPT_BUFF = 'Tern:WAIT ';
         CALL BINCHAR( SUBSTR(SCRIPT_BUFF,10,4), (SYS_UTS-SCRIPT_UTS)/100 - PACE_TIME);
         WRITE_SCRIPT.BUF_.BOUND = 13;
         CALL M$WRITE(WRITE_SCRIPT)
         WHENALTRETURN DO; ALTRETURN; END;
      END;
      SCRIPT_UTS = SYS_UTS;
      SCRIPT_CHRCNT = 10;
      SCRIPT_BUFF = 'Tern:SEND ';
      CALL PUTSTRING(SCRIPT_BUFF, SCRIPT_CHRCNT, BUFF, CHRCNT);
      WRITE_SCRIPT.BUF_.BOUND = SCRIPT_CHRCNT - 1;
      CALL M$WRITE(WRITE_SCRIPT)
      WHENALTRETURN DO; ALTRETURN; END;
   END;
   CG_WRITE.BUF_ = VECTOR(BUFF);
   IF CG_SETSTA.OSTA.OSTATION# = ' ' THEN
   CG_WRITE.STATION_ = VECTOR(CONTEXT.STA);
   CALL M$WRITE(CG_WRITE)
   WHENALTRETURN DO; ALTRETURN; END;
 
END SEND;
%EJECT;
OPENCG: PROC(O$BLK) ALTRET;
/* Open F$CG to a (optionally specified) comgroup, and initialize
   related tables and structures.  */
%PARSE$OUT (NAME=O$BLK, STCLASS="");
 
%FPT_OPEN (FPTN=CG_OPEN,
 STCLASS=CONSTANT,
 ASN=COMGROUP,
 ACCESS=CG_ACCESS,
 SETSTA=CG_SETSTA,
 DCB=F$CG);
 
%FPT_OPEN (FPTN=CG_DELETE,
 STCLASS=CONSTANT,
 ASN=FILE,
 DELETE=YES,
 FUN=UPDATE,
 DCB=F$CG);
 
%FPT_CGCTL (FPTN=CG_CGCTL,
 STCLASS=CONSTANT,
 DCB=F$CG,
 CGCP=CG_CGCP);
 
%VLP_CGCP (FPTN=CG_CGCP,
 STCLASS=CONSTANT,
 AUCONDCB=NC,
 AUCONTERM=ACTIVATE,
 AUDCONDCB=NC,
 AUDCONTERM=NC,
 CONMSG=YES,
 DATAPGS=80,
 DCBCONAU=YES,
 DCBCONLGL=YES,
 DCBCONNAU=YES,
 DISKWARN=25,
 INPUT=YES,
 MAXMC=%CG$MAXMC#,
 MAXPG=40,
 MEMWARN=25,
 MINPG=6,
 OUTPUT=YES,
 RAS=YES,
 SECURE=NO,
 SMD=NO,
 TERMCONAU=YES,
 TERMCONLGL=YES,
 TERMCONNAU=YES,
 TRANS=YES,
 TMTYP='INPUT   ',
 WAS=NO,
 XSTALGL=YES,
 XTYPLGL=YES);
 
%FPT_EOM(FPTN=CG_EOM,
 STCLASS=STATIC,
 DCB=F$CG,
 TIMEOUT=20,
 UTYPE=MIL10);
 
%FPT_TRMCTL(FPTN=CG_TRMCTL,
 STCLASS=STATIC,
 TRMCTL=VLP_TRMCTL,
 DCB=F$CG);
 
%VLP_TRMCTL(STCLASS=CONSTANT,
 ACTONTRN=YES);
 
%FPT_WAIT(FPTN=WAIT_X,
 UNITS=7);
 
   CALL XUR$OPENOUT( ,O$BLK, CG_SETDCB)
   WHENALTRETURN DO; ALTRETURN; END;
 
   CALL M$OPEN(CG_OPEN)
   WHENALTRETURN DO;
 /* get rid of the "kind-of-a-comgroup" file created */
      CALL M$OPEN(CG_DELETE)
      WHENALTRETURN DO; END;
      ALTRETURN;
   END;
 
   IF CG_SETDCB.V.AU# ~= '00'B THEN
   CALL M$CGCTL (CG_CGCTL)
   WHENALTRETURN DO; ALTRETURN; END;
 
   ELSE DO;
      CALL TERN_CONTEXT(CG_SETSTA.OSTA.OSTATION#);
      CONTEXT.STATE = %S$IDLE;
 
      CALL M$WAIT (WAIT_X);
      CG_EOM.STATION_ = VECTOR(CONTEXT.STA);
      CALL M$EOM(CG_EOM) WHENALTRETURN DO;
         CALL XUR$ERRMSG(B$TCB.ALT$->B$ALT.ERR,
           B$TCB.ALT$->B$ALT.DCB#);
         CALL M$EXIT;
      END;
 
   END;
   RETURN;
END OPENCG;
END TERN;
