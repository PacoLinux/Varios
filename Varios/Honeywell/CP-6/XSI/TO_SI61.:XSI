/*M* TO allows users to send messages to other online users                   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X*     PLM=3,SQB=Y,AND=Y,ENI=0,SDI=3,MCL=10,CSI=0,ECI=0,IND=0,IAD=3         */
TO_: PROC MAIN;
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B$JIT;
%INCLUDE B$USER;
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
%B$TCB (STCLASS="BASED(B$TCB$)");
%B$ALT;
 
DCL M$CSCG DCB;
DCL M$DO DCB;
DCL M$REGISTER DCB;
 
DCL ID_REGISTER BIT(1) STATIC SYMDEF ALIGNED INIT('1'B);
DCL ID_ACCN BIT(1) STATIC SYMDEF ALIGNED INIT('0'B);
DCL ID_UNAME BIT(1) STATIC SYMDEF ALIGNED INIT('0'B);
DCL ID_SYSID BIT(1) STATIC SYMDEF ALIGNED INIT('1'B);
DCL ID_JOBNAME BIT(1) STATIC SYMDEF ALIGNED INIT('1'B);
DCL ID_WOO BIT(1) STATIC SYMDEF ALIGNED INIT('0'B);
 
DCL TEMP SBIN WORD;
DCL TOKEN CHAR(10);
DCL SENT_ONE BIT(1) STATIC INIT('0'B);
DCL FOUND_ONE BIT(1) STATIC INIT('0'B);
DCL BROKEN_REGISTER BIT(1) STATIC INIT('0'B);
DCL SPECIFIC BIT(1) STATIC INIT(%NO#);
DCL ACCOUNT BIT(1) STATIC INIT(%NO#);
DCL HIS_JIT$ PTR;
DCL I UBIN WORD;
DCL J SBIN;
DCL I_PROMPT CHAR(1) CONSTANT INIT(':');
DCL MON_USRT$ PTR;
 
DCL DAM$MAP ENTRY(5) ALTRET;
DCL DAM$INIT ENTRY ALTRET;
%INCLUDE XUF_ENTRY;
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL X$PARSE ENTRY(1) ALTRET;
DCL XUR$INIT ENTRY(3) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL XUR$ERRMSG ENTRY(7) ALTRET;
 
%INCLUDE XU_MACRO_C;
%INCLUDE DA_MAP_R;
DCL CMD$ PTR;
%PARSE$OUT (NAME=OUT,STCLASS="BASED(CMD$)");
%PARSE$SYM (NAME=SYM,STCLASS="BASED(CMD$)");
%P$PCB (NAME=P_PCB,STCLASS="STATIC SYMDEF");
%XUR_INIT (SYNTAX=NO,PCB=P_PCB,COMMANDS=NO);
DCL TO_CMD SBIN SYMREF;
 
%INCLUDE XU_FORMAT_C;
%F_FDS(NAME=FDS,DCB=M$DO);
DCL FMT_BUF CHAR(140);
 
DCL NO_SUCH CHAR(0) CONSTANT INIT('No such user online.');
DCL NOT_SENT CHAR(0) CONSTANT INIT('Nothing sent.');
DCL NOT_ACCEPTING CHAR(0) CONSTANT INIT('Sysid %D is not accepting messages.');
DCL NOT_ONLINE CHAR(0) CONSTANT INIT('Sysid %D is not an online user.');
DCL ISA_CONSGHOST CHAR(0) CONSTANT INIT('Can''t send to a console ghost. (Sysid %D)');
DCL ISA_ZZZCUST CHAR(0) CONSTANT INIT('Can''t send to account ZZZCUST. (Sysid %D)');
DCL SUSPENDED CHAR(0) CONSTANT INIT('Sysid %D is suspended.');
 
DCL 1 MESSBUF STATIC ALIGNED,
       2 VECTR UBIN BYTE UNAL INIT(7),
       2 KEYIN# UBIN BYTE UNAL INIT(2),
       2 CATTR BIT(18) UNAL INIT('200000'O),
       2 WSN CHAR(8) UNAL INIT('?       '),
       2 SYSID UBIN HALF UNAL,
       2 COUNT UBIN HALF UNAL INIT(0),
       2 TEXT CHAR(132) UNAL INIT(' ');
 
DCL 1 MKEY STATIC,
       2 L UBIN BYTE CALIGNED INIT(20),
       2 ACCN CHAR(8) CALIGNED,
       2 UNAME CHAR(12) CALIGNED;
 
DCL MNAME CHAR(54) STATIC;
 
DCL TEXT_BUFFER CHAR(120) STATIC;
 
%FPT_READ(FPTN=READ_TEXT,
 DCB=M$UC,
 BUF=TEXT_BUFFER);
 
%FPT_OPEN(FPTN=OPEN_REGISTER,
 DCB=M$REGISTER,
 NAME=REGISTER_NAME,
 ACCT=REGISTER_ACCT,
 ASN=FILE,
 FUN=IN,
 SHARE=ALL,
 STCLASS=STATIC);
 
%VLP_NAME(FPTN=REGISTER_NAME,
 NAME=':NAME');
 
%VLP_ACCT(FPTN=REGISTER_ACCT,
 ACCT=':MAIL');
 
%FPT_READ(FPTN=READ_REGISTER,
 DCB=M$REGISTER,
 KEYS=YES,
 KEY=MKEY,
 BUF=MNAME);
 
%F$DCB;
 
%FPT_WRITE (FPTN=FPT_WRITE,
 DCB=M$CSCG,
 WAIT=YES,
 BUF=MESSBUF);
 
%FPT_OPEN (FPTN=FPT_OPEN,
 STCLASS=CONSTANT,
 ASN=COMGROUP,
 DCB=M$CSCG,
 NAME=CSCG_NAME,
 ACCT=CSCG_ACCT,
 SETSTA=VLP_SETSTA,
 SCRUB=YES,
 FUN=UPDATE);
 
%VLP_SETSTA (FPTN=VLP_SETSTA,
 STCLASS=STATIC,
 DIRONLY=YES,
 MYSTATION='TO000000',
 OSTATION='MONKEY  ');
 
%VLP_NAME (FPTN=CSCG_NAME,
 STCLASS=CONSTANT,
 NAME='CSCG');
 
%VLP_ACCT (FPTN=CSCG_ACCT,
 STCLASS=CONSTANT,
 ACCT=':SYS');
 
%FPT_MONINFO (FPTN=GET_MONPTRS,
 STCLASS=CONSTANT,
 MONPTRS=MONPTRS);
 
%VLR_MONPTRS (FPTN=MONPTRS);
 
%FPT_WAIT(FPTN=TWO,
 UNITS=2);
 
DCL SAVE_COUNT UBIN;
 
DCL 1 PRINTABLE_XLATE_TBL CONSTANT ALIGNED,
       2 *(0:511) BIT(9) UNAL INIT(
 '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'007'O,
 '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
 '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
 '056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,'056'O,
 '040'O,'041'O,'042'O,'043'O,'044'O,'045'O,'046'O,'047'O,
 '050'O,'051'O,'052'O,'053'O,'054'O,'055'O,'056'O,'057'O,
 '060'O,'061'O,'062'O,'063'O,'064'O,'065'O,'066'O,'067'O,
 '070'O,'071'O,'072'O,'073'O,'074'O,'075'O,'076'O,'077'O,
 '100'O,'101'O,'102'O,'103'O,'104'O,'105'O,'106'O,'107'O,
 '110'O,'111'O,'112'O,'113'O,'114'O,'115'O,'116'O,'117'O,
 '120'O,'121'O,'122'O,'123'O,'124'O,'125'O,'126'O,'127'O,
 '130'O,'131'O,'132'O,'133'O,'134'O,'135'O,'136'O,'137'O,
 '140'O,'141'O,'142'O,'143'O,'144'O,'145'O,'146'O,'147'O,
 '150'O,'151'O,'152'O,'153'O,'154'O,'155'O,'156'O,'157'O,
 '160'O,'161'O,'162'O,'163'O,'164'O,'165'O,'166'O,'167'O,
 '170'O,'171'O,'172'O,'173'O,'174'O,'175'O,'176'O,'056'O,
 '056'O*384);
%EJECT;
/* Miscelaneous initialization */
 
   FDS.BUF_ = VECTOR(FMT_BUF);
 
   CALL XUR$INIT(XUR_INIT);
   TEMP=B$JIT.CCARS;
   CALL XUR$GETCMD(TO_CMD,CMD$,VECTOR(I_PROMPT),B$JIT.CCBUF,TEMP)
     ALTRET(CMD_ERR);
 
   CALL BINCHAR(VLP_SETSTA.MYSTATION#,B$JIT.SYSID);
   CALL INSERT(VLP_SETSTA.MYSTATION#,0,2,'TO');
   CALL M$OPEN(FPT_OPEN) ALTRET(MON_ERR);
 
   CALL DAM$INIT;
 
   CALL M$MONINFO(GET_MONPTRS) ALTRET(MON_ERR);
   CALL DAM$MAP(MONPTRS.B$USRT$, MON_USRT$, 0);
 
/* Build CSCG message with sender's identification */
 
   IF ID_REGISTER THEN DO;
      BROKEN_REGISTER = %YES#;
      CALL M$OPEN(OPEN_REGISTER) ALTRET(NO_REGISTER);
      MKEY.ACCN = B$JIT.ACCN; MKEY.UNAME = B$JIT.UNAME;
      CALL M$READ(READ_REGISTER) WHENALTRETURN DO;
         MKEY.UNAME = ' ';
         CALL M$READ(READ_REGISTER) ALTRET(NO_REGISTER);
      END;
      TEMP=DCBADDR(DCBNUM(M$REGISTER))->F$DCB.ARS#;
      DO WHILE TEMP>0 AND SUBSTR(MNAME,TEMP-1,1)=' ';
         TEMP = TEMP-1;
      END;
      IF TEMP > 24 THEN TEMP = 24;
      BROKEN_REGISTER = %NO#;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,TEMP,SUBSTR(MNAME,0,TEMP));
      MESSBUF.COUNT = MESSBUF.COUNT + TEMP;
   END;
NO_REGISTER:
 
   IF ID_ACCN OR BROKEN_REGISTER THEN DO;
      IF MESSBUF.COUNT > 0 THEN DO;
         CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,1,' ');
         MESSBUF.COUNT = MESSBUF.COUNT + 1;
      END;
      CALL INDEX( TEMP, ' ', B$JIT.ACCN)
      WHENALTRETURN DO;
         TEMP = SIZEC(B$JIT.ACCN);
      END;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,TEMP,B$JIT.ACCN);
      MESSBUF.COUNT = MESSBUF.COUNT + TEMP;
   END;
 
   IF ID_UNAME OR BROKEN_REGISTER THEN DO;
      IF MESSBUF.COUNT > 0 THEN DO;
         CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,1,',');
         MESSBUF.COUNT = MESSBUF.COUNT + 1;
      END;
      CALL INDEX( TEMP, ' ', B$JIT.UNAME)
      WHENALTRETURN DO;
         TEMP = SIZEC(B$JIT.UNAME);
      END;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,TEMP,B$JIT.UNAME);
      MESSBUF.COUNT = MESSBUF.COUNT + TEMP;
   END;
 
   IF ID_SYSID THEN DO;
      TEMP=0;
      CALL BINCHAR(TOKEN, B$JIT.SYSID);
      DO WHILE SUBSTR(TOKEN,TEMP,1) = '0';
         TEMP = TEMP + 1;
      END;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,12-TEMP,
        '(',SUBSTR(TOKEN,TEMP),')');
      MESSBUF.COUNT = MESSBUF.COUNT + 12-TEMP;
   END;
 
   IF ID_JOBNAME AND B$JIT.JOBNAME~='        ' THEN DO;
      IF MESSBUF.COUNT > 0 THEN DO;
         CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,1,' ');
         MESSBUF.COUNT = MESSBUF.COUNT + 1;
      END;
      CALL INDEX( TEMP, ' ', B$JIT.JOBNAME)
      WHENALTRETURN DO;
         TEMP = SIZEC(B$JIT.JOBNAME);
      END;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,TEMP,B$JIT.JOBNAME);
      MESSBUF.COUNT = MESSBUF.COUNT + TEMP;
   END;
 
   IF ID_WOO AND B$JIT.WOO~='        ' THEN DO;
      CALL INDEX( TEMP, ' ', B$JIT.WOO)
      WHENALTRETURN DO;
         TEMP = SIZEC(B$JIT.WOO);
      END;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,TEMP+1,'@',B$JIT.WOO);
      MESSBUF.COUNT = MESSBUF.COUNT + TEMP +1;
   END;
 
   IF MESSBUF.COUNT > 0 THEN DO;
      CALL INSERT(MESSBUF.TEXT,MESSBUF.COUNT,6,' sez: ');
      MESSBUF.COUNT = MESSBUF.COUNT + 6;
   END;
 
   SAVE_COUNT = MESSBUF.COUNT;
%EJECT;
/* If message text was included in the CCBUF, send it.  Otherwise,
   prompt the user for some until he enters a null record.   */
 
   IF OUT.NSUBLKS > 1 THEN DO;
 
      CALL XLATE( SUBSTR(MESSBUF.TEXT,MESSBUF.COUNT),
        PRINTABLE_XLATE_TBL,
        OUT.SUBLK$(1)->SYM.TEXT);
      MESSBUF.COUNT = MESSBUF.COUNT + OUT.SUBLK$(1)->SYM.COUNT;
 
      CMD$=OUT.SUBLK$(0);
      CALL TO_THEM;
   END;
   ELSE DO;
      CMD$=OUT.SUBLK$(0);
      DO WHILE '1'B;
         MESSBUF.COUNT = SAVE_COUNT;
         CALL M$READ(READ_TEXT) ALTRET(MON_ERR);
         IF DCBADDR(DCBNUM(M$UC))->F$DCB.ARS# = 0
         THEN GOTO WE_IS_DONE;
         CALL XLATE( SUBSTR(MESSBUF.TEXT,MESSBUF.COUNT),
           PRINTABLE_XLATE_TBL,
           TEXT_BUFFER);
         MESSBUF.COUNT = MESSBUF.COUNT
           + DCBADDR(DCBNUM(M$UC))->F$DCB.ARS#;
 
         CALL TO_THEM;
         CALL M$WAIT(TWO);
      END /* WHILE */;
   END /* ELSE */;
WE_IS_DONE:
   RETURN;
 
MON_ERR:
   CALL XUR$ERRMSG (B$TCB.ALT$->B$ALT.ERR,
     B$TCB.ALT$->B$ALT.DCB#,
     DCBNUM(M$DO));
   RETURN;
 
CMD_ERR:
   I=P_PCB.HI_CHAR;
   IF I>0 THEN CALL XUR$ERRPTR(I,DCBNUM(M$DO));
   CALL XUR$ERRMSG(CMD$,,DCBNUM(M$DO));
   P_PCB.NXT = '1'B;
   CALL X$PARSE(P_PCB);
   RETURN;
%EJECT;
/* Process commands.  At this point, we have a command parsed and
   the parse output pointed to by CMD$.
   Send the message to all the selected users */
TO_THEM: PROC;
 
   IF MESSBUF.COUNT > 120
   THEN MESSBUF.COUNT = 120;
   FPT_WRITE.BUF_.BOUND = 15 + MESSBUF.COUNT;
   FOUND_ONE = %NO#;
   SENT_ONE = %NO#;
 
   DO CASE(OUT.CODE);
   CASE(1);                             /* ALL                                */
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT1);
         CALL TO_HIM;
NXT1: END;
   CASE(2);                             /* USER#                              */
      SPECIFIC = %YES#;
      DO I=0 TO OUT.NSUBLKS-1;
         CALL CVTOCT(TEMP,OUT.SUBLK$(I)->OUT);
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-TEMP,0) ALTRET(NXT2);
         CALL TO_HIM;
NXT2: END;
   CASE(3);                             /* SYSID                              */
      SPECIFIC = %YES#;
      DO I=0 TO OUT.NSUBLKS-1;
         CALL CHARBIN(TEMP,OUT.SUBLK$(I)->SYM.TEXT);
         CALL DAM$MAP(B$JIT$,HIS_JIT$,TEMP,0) ALTRET(NXT3);;
         CALL TO_HIM;
NXT3: END;
   CASE(4);                             /* ACCOUNT                            */
      ACCOUNT = %YES#;
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT4);
         DO J=0 TO OUT.NSUBLKS-1;
            CALL WILDCOMP(OUT.SUBLK$(J)->SYM.COUNT,HIS_JIT$->B$JIT.ACCN,8) ALTRET(NXTACCN);
            CALL TO_HIM;
            GOTO NXT4;
NXTACCN: END;
NXT4: END;
   CASE(5);                             /* NAME                               */
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT5);
         DO J=0 TO OUT.NSUBLKS-1;
            CALL WILDCOMP(OUT.SUBLK$(J)->SYM.COUNT,HIS_JIT$->B$JIT.UNAME,12) ALTRET(NXTNAME);
            CALL TO_HIM;
            GOTO NXT5;
NXTNAME: END;
NXT5: END;
   CASE(6);                             /* CCBUF                              */
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT6);
         DO J=0 TO OUT.NSUBLKS-1;
            CALL WILDCOMP(OUT.SUBLK$(J)->SYM.COUNT,HIS_JIT$->B$JIT.CCBUF,BINBIT(HIS_JIT$->B$JIT.CCARS,36)) ALTRET(NXTCCBUF);
            CALL TO_HIM;
            GOTO NXT6;
NXTCCBUF: END;
NXT6: END;
   CASE(7);                             /* FEP                                */
      DO J=0 TO OUT.NSUBLKS-1;
         CALL CHARBIN(TEMP,OUT.SUBLK$(J)->SYM.TEXT);
         OUT.SUBLK$(J)->SYM.SCRITCH=TEMP;
      END;
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT7);
         DO J=0 TO OUT.NSUBLKS-1;
            IF HIS_JIT$->B$JIT.TSLINE.FEX=OUT.SUBLK$(J)->SYM.SCRITCH THEN DO;
               CALL TO_HIM;
               GOTO NXT7;
            END;
         END;
NXT7: END;
   CASE(8);                             /* LINE                               */
      SPECIFIC = %YES#;
      DO J=0 TO OUT.NSUBLKS-1;
         CALL CHARBIN(TEMP,OUT.SUBLK$(J)->OUT.SUBLK$(0)->SYM.TEXT);
         OUT.SUBLK$(J)->OUT.SUBLK$(0)->SYM.SCRITCH=TEMP;
         CALL CVTHEX(TEMP,OUT.SUBLK$(J)->OUT.SUBLK$(1)->SYM);
         OUT.SUBLK$(J)->OUT.SUBLK$(1)->SYM.SCRITCH=TEMP;
      END;
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT8);
         DO J=0 TO OUT.NSUBLKS-1;
            IF HIS_JIT$->B$JIT.TSLINE.FEX=OUT.SUBLK$(J)->OUT.SUBLK$(0)->SYM.SCRITCH AND
              HIS_JIT$->B$JIT.TSLINE.PORT=OUT.SUBLK$(J)->OUT.SUBLK$(1)->SYM.SCRITCH THEN DO;
               CALL TO_HIM;
               GOTO NXT8;
            END;
         END;
NXT8: END;
   CASE(9);                             /* JOBNAME                            */
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT9);
         DO J=0 TO OUT.NSUBLKS-1;
            CALL WILDCOMP(OUT.SUBLK$(J)->SYM.COUNT,HIS_JIT$->B$JIT.JOBNAME,31) ALTRET(NXTJOB);
            CALL TO_HIM;
            GOTO NXT9;
NXTJOB:  END;
NXT9: END;
   CASE(10);                            /* WOO                                */
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP(B$JIT$,HIS_JIT$,-I,0) ALTRET(NXT10);
         DO J=0 TO OUT.NSUBLKS-1;
            CALL WILDCOMP(OUT.SUBLK$(J)->SYM.COUNT,HIS_JIT$->B$JIT.WOO,8) ALTRET(NXTWOO);
            CALL TO_HIM;
            GOTO NXT10;
NXTWOO:  END;
NXT10: END;
   END /* CASE */;
 
   IF NOT FOUND_ONE
   THEN CALL X$WRITE(FDS,VECTOR(NO_SUCH));
   ELSE IF NOT SENT_ONE
   THEN CALL X$WRITE(FDS,VECTOR(NOT_SENT));
 
   RETURN;
 
END TO_THEM;
%EJECT;
TO_HIM: PROC;
 
   FOUND_ONE = %YES#;
 
   IF HIS_JIT$->B$JIT.ACCN = 'ZZZCUST ' THEN DO;
      IF SPECIFIC OR ACCOUNT
      THEN CALL X$WRITE (FDS,VECTOR(ISA_ZZZCUST),VECTOR(HIS_JIT$->B$JIT.SYSID));
      RETURN;
   END;
 
   IF HIS_JIT$->B$JIT.MODE ~= %M_INT# THEN DO;
      IF SPECIFIC
      THEN CALL X$WRITE (FDS,VECTOR(NOT_ONLINE),VECTOR(HIS_JIT$->B$JIT.SYSID));
      RETURN;
   END;
 
   IF HIS_JIT$->B$JIT.TSLINE.FEX=0 THEN DO;
      IF SPECIFIC
      THEN CALL X$WRITE (FDS,VECTOR(ISA_CONSGHOST),VECTOR(HIS_JIT$->B$JIT.SYSID));
      RETURN;
   END;
 
 
   IF MON_USRT$->B$USER.FLG(HIS_JIT$->B$JIT.USER) & %U_NSND
   THEN CALL X$WRITE (FDS,VECTOR(NOT_ACCEPTING),VECTOR(HIS_JIT$->B$JIT.SYSID));
   ELSE IF MON_USRT$->B$USER.FLG(HIS_JIT$->B$JIT.USER) & %U_SUSP
   THEN CALL X$WRITE (FDS,VECTOR(SUSPENDED),VECTOR(HIS_JIT$->B$JIT.SYSID));
 
   ELSE DO;
      MESSBUF.SYSID = HIS_JIT$->B$JIT.SYSID;
      CALL M$WRITE(FPT_WRITE);
      SENT_ONE = %YES#;
   END;
 
   RETURN;
END TO_HIM;
%EJECT;
CVTOCT: PROC(NUM,T);
DCL NUM SBIN;
%PARSE$SYM (NAME=T,STCLASS="");
DCL I SBIN;
   NUM=0;
   DO I=0 TO T.COUNT-1;
      NUM=NUM*8+ASCBIN(SUBSTR(T.TEXT,I,1))-48;
   END;
   RETURN;
END CVTOCT;
%EJECT;
CVTHEX: PROC(NUM,T);
DCL NUM SBIN;
%PARSE$SYM (NAME=T,STCLASS="");
DCL X SBIN;
DCL I SBIN;
DCL HEX CHAR(16) CONSTANT INIT('0123456789ABCDEF');
 
   NUM=0;
   DO I=0 TO T.COUNT-1;
      CALL INDEX1(X,SUBSTR(T.TEXT,I,1),HEX);
      NUM=NUM*16+X;
   END;
   RETURN;
END CVTHEX;
%EJECT;
WILDCOMP: PROC(WILDSTR,STR,STRSIZ) ALTRET;
DCL 1 WILDSTR,
       2 L UBIN BYTE UNAL,
       2 C CHAR(WILDSTR.L);
DCL STR CHAR(STRSIZ);
DCL STRSIZ UBIN;
DCL WX UBIN;
DCL WXP UBIN;
DCL CX UBIN;
DCL CXP UBIN;
 
 
 
   WX=0;
   WXP=WILDSTR.L;
   CX=0;
   CXP=0;
   DO WHILE(WX<WILDSTR.L AND SUBSTR(WILDSTR.C,WX)~=' '
     OR CX<STRSIZ AND SUBSTR(STR,CX)~=' ');
      IF WX<WILDSTR.L AND SUBSTR(WILDSTR.C,WX,1)='?' THEN DO;
         WXP=WX;
      END;
      ELSE DO;
         IF WX=WXP+1 THEN CXP=CX;
         IF WX>=WILDSTR.L OR CX>=STRSIZ
           OR SUBSTR(WILDSTR.C,WX,1) ~= SUBSTR(STR,CX,1) THEN DO;
            IF WXP=WILDSTR.L OR CXP=STRSIZ THEN ALTRETURN;
            WX=WXP;
            CX=CXP;
         END;
         CX=CX+1;
      END;
      IF WX<WILDSTR.L THEN WX=WX+1;
   END;
   RETURN;
END WILDCOMP;
END TO_;
