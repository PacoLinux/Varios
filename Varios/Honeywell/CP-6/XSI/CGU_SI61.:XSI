/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
CGU_MAIN:  PROC    MAIN;
%INCLUDE CP_6;
%INCLUDE XUR_ENTRY;
%INCLUDE XU_MACRO_C;
%XUR_INIT(NAME=XURI, ABORT=CGU_INT, PCB=P_PCB, SYNTAX=YES);
%P_PCB(NAME=P_PCB, STCLASS=STATIC);
%FPT_INT(FPTN=INTFPT, UENTRY=XUR$BREAK);
%FPT_XCON(UENTRY=XCON_RTN);
DCL    CGU_INT     ENTRY ASYNC;
DCL    CGU     ENTRY ALTRET;
DCL    BLK$    STATIC SYMDEF PTR;
DCL    XCON_RTN    ENTRY ASYNC;
/**/
       CALL M$INT(INTFPT);
       CALL XUR$INIT(XURI);
       CALL M$XCON(FPT_XCON);
       CALL CGU;
END CGU_MAIN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
CGU:   PROC    ALTRET;
%INCLUDE CP_6;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUR_ENTRY;
%INCLUDE XU_MACRO_C;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
%EQU_CG;
%B$TCB(STCLASS="BASED(B$TCB$)");
%B$ALT;
%F$DCB(STCLASS="BASED(DCB$)");
/*  Equates  */
%EQU   CGALL#      = 101;
%EQU   CGPARAM#    = 102;
%EQU   CGUSERS#    = 103;
%EQU   CGMESSAGES# = 104;
%EQU   CGSTATS#    = 105;
%EQU   CGFID#      = 106;
%EQU   CGADD#      = 107;
%EQU   CGDROP#     = 108;
%EQU   CGGO#       = 109;
%EQU   CGEND#      = 110;
%EQU   CGMONITOR#  = 111;
%EQU   CGLET#      = 112;
%EQU   CGCREATE#   = 113;
%EQU   CGEXTEND#   = 114;
%EQU   CGDELETE#   = 115;
%EQU   CGDUMP#     = 116;
%EQU   LALL#       = 0;
%EQU   LPARAM#     = 1;
%EQU   LUSERS#     = 2;
%EQU   LMESSAGES#  = 3;
%EQU   LSTATS#     = 4;
%EQU   INC#        = 5;
%EQU   DEST#       = 6;
%EQU   ORIG#       = 7;
%EQU   TYPE#       = 8;
%EQU   ALLQ#       = 9;
%EQU   LSYM#       = 10;
%EQU   LAU#        = 11;
%EQU   LYEA#       = 12;
%EQU   LNAY#       = 13;
%EQU   LSTATION#   = 14;
%EQU   LNC#        = 15;
%EQU   LACT#       = 16;
%EQU   LDEACT#     = 17;
%EQU   LDISC#      = 18;
%EQU   LIXTNSIZE#  = 19;
%EQU   QSELECT#    = 20;
%EQU   LDIRECT#    = 21;
%EQU   LANONYMOUS# = 22;
%EQU   MSGID#      = 23;
%EQU   LQISS#      = 24;
%EQU   LORG#       = 25;
%EQU   LEXIST#     = 26;
%EQU   LM1#        = 27;
%EQU   LM2#        = 28;
%EQU   LM3#        = 29;
%EQU   LM4#        = 30;
%EQU   LAUCONDCB#  = 201;
%EQU   LAUCONTERM# = 202;
%EQU   LAUDCONDCB# = 203;
%EQU   LAUDCONTERM#= 204;
%EQU   LAUTORCVR#  = 205;
%EQU   LBIGMXT#    = 206;
%EQU   LBIN#       = 207;
%EQU   LCARRYOSTA# = 208;
%EQU   LCONMSG#    = 209;
%EQU   LDATAPGS#   = 210;
%EQU   LDCBCONAU#  = 211;
%EQU   LDCBCONLGL# = 212;
%EQU   LDCBCONNAU# = 213;
%EQU   LDCBCONWA#  = 214;
%EQU   LDEFERBLKS# = 215;
%EQU   LDISKWARN#  = 216;
%EQU   LDMTYP#     = 217;
%EQU   LDRML#      = 218;
%EQU   LDSCREQ#    = 219;
%EQU   LDVBYTE#    = 220;
%EQU   LINPUT#     = 221;
%EQU   LJOURNAL#   = 222;
%EQU   LMAXMC#     = 223;
%EQU   LMAXPG#     = 224;
%EQU   LMEMWARN#   = 225;
%EQU   LMEMWARNP#  = 226;
%EQU   LMINPG#     = 227;
%EQU   LMXACT#     = 228;
%EQU   LOUTPUT#    = 229;
%EQU   LQRML#      = 230;
%EQU   LRAS#       = 231;
%EQU   LREDUNDANT# = 232;
%EQU   LREREAD#    = 233;
%EQU   LSECURE#    = 234;
%EQU   LSMD#       = 235;
%EQU   LSTAPRIO#   = 236;
%EQU   LTERMCONAU# = 237;
%EQU   LTERMCONLGL#= 238;
%EQU   LTERMCONNAU#= 239;
%EQU   LTMTYP#     = 240;
%EQU   LTRANS#     = 241;
%EQU   LTRMRDSIZ#  = 242;
%EQU   LTYPPRIO#   = 243;
%EQU   LUNLAMSG#   = 244;
%EQU   LWAS#       = 245;
%EQU   LWRITETIME# = 246;
%EQU   LXSTALGL#   = 247;
%EQU   LXTYPLGL#   = 248;
%EQU   LALLABSENT# = 249;
%EQU   LALLDCBS#   = 250;
%EQU   LALLTRMS#   = 251;
%EQU   LANYDCB#    = 252;
%EQU   LDIRONLY#   = 253;
%EQU   LEOFNONE#   = 254;
%EQU   LEOFONE#    = 255;
%EQU   LILATCH#    = 256;
%EQU   LILOCK#     = 257;
%EQU   LIMSGTYP#   = 258;
%EQU   LISTATION#  = 259;
%EQU   LMYSTATION# = 260;
%EQU   LOLATCH#    = 261;
%EQU   LOLOCK#     = 262;
%EQU   LOMSGTYP#   = 263;
%EQU   LOSTATION#  = 264;
%EQU   LSETSTAWAS# = 265;
%EQU   LNONE#      = 266;
%EQU   LERR#       = 267;
%EQU   LOLDF#      = 268;
%EQU   LNEWF#      = 269;
%EQU   LCG#        = 270;
%EQU   LTERM#      = 271;
%EQU   LDUC#       = 272;
%EQU   LDUA#       = 273;
%EQU   LDUO#       = 274;
%EQU   LHOLDSTA#   = 275;
%EQU   LJRNLSTA#   = 276;
%EQU   LJRNLFID#   = 277;
%EQU   LFID#       = 278;
%EQU   XAUCONDCB#  = 301;
%EQU   XAUCONTERM# = 302;
%EQU   XAUDCONDCB# = 303;
%EQU   XAUDCONTERM#= 304;
%EQU   XAUTORCVR#  = 305;
%EQU   XBIGMXT#    = 306;
%EQU   XBIN#       = 307;
%EQU   XCARRYOSTA# = 308;
%EQU   XCONMSG#    = 309;
%EQU   XDATAPGS#   = 310;
%EQU   XDCBCONAU#  = 311;
%EQU   XDCBCONLGL# = 312;
%EQU   XDCBCONNAU# = 313;
%EQU   XDCBCONWA#  = 314;
%EQU   XDEFERBLKS# = 315;
%EQU   XDISKWARN#  = 316;
%EQU   XDMTYP#     = 317;
%EQU   XDRML#      = 318;
%EQU   XDSCREQ#    = 319;
%EQU   XDVBYTE#    = 320;
%EQU   XINPUT#     = 321;
%EQU   XJOURNAL#   = 322;
%EQU   XMAXMC#     = 323;
%EQU   XMAXPG#     = 324;
%EQU   XMEMWARN#   = 325;
%EQU   XMEMWARNP#  = 326;
%EQU   XMINPG#     = 327;
%EQU   XMXACT#     = 328;
%EQU   XOUTPUT#    = 329;
%EQU   XQRML#      = 330;
%EQU   XRAS#       = 331;
%EQU   XREDUNDANT# = 332;
%EQU   XREREAD#    = 333;
%EQU   XSECURE#    = 334;
%EQU   XSMD#       = 335;
%EQU   XSTAPRIO#   = 336;
%EQU   XTERMCONAU# = 337;
%EQU   XTERMCONLGL#= 338;
%EQU   XTERMCONNAU#= 339;
%EQU   XTMTYP#     = 340;
%EQU   XTRANS#     = 341;
%EQU   XTRMRDSIZ#  = 342;
%EQU   XTYPPRIO#   = 343;
%EQU   XUNLAMSG#   = 344;
%EQU   XWAS#       = 345;
%EQU   XWRITETIME# = 346;
%EQU   XXSTALGL#   = 347;
%EQU   XXTYPLGL#   = 348;
%EQU   XALLABSENT# = 349;
%EQU   XALLDCBS#   = 350;
%EQU   XALLTRMS#   = 351;
%EQU   XANYDCB#    = 352;
%EQU   XDIRONLY#   = 353;
%EQU   XEOFNONE#   = 354;
%EQU   XEOFONE#    = 355;
%EQU   XILATCH#    = 356;
%EQU   XILOCK#     = 357;
%EQU   XIMSGTYP#   = 358;
%EQU   XISTATION#  = 359;
%EQU   XMYSTATION# = 360;
%EQU   XOLATCH#    = 361;
%EQU   XOLOCK#     = 362;
%EQU   XOMSGTYP#   = 363;
%EQU   XOSTATION#  = 364;
%EQU   XSETSTAWAS# = 365;
%EQU   XSTANAME#   = 366;
%EQU   XAU#        = 367;
%EQU   XHOLDSTA#   = 368;
%EQU   XJRNLSTA#   = 369;
%EQU   XJRNLFID#   = 370;
DCL    M$CG    DCB;
DCL    M$LO    DCB;
DCL    M$SI    DCB;
DCL    M$DO    DCB;
%FPT_WAIT(FPTN=WFPT, UNITS=60);
%FPT_OPEN(FPTN=CGOPN, DCB=M$CG, FUN=IN, SHARE=ALL, ASN=COMGROUP,
           NAME=VLP_NAME, PASS=VLP_PASS, ACCT=VLP_ACCT, SN=VLP_SN,
          WSN=VLP_WSN, SETSTA=VLP_SETSTA, SCRUB=YES);
%VLP_SETSTA;
%VLP_NAME;
%VLP_PASS;
%VLP_ACCT;
%VLP_SN;
%VLP_WSN;
%FPT_EXTEND(FPTN=CGEXTEND, DCB=M$CG);
%FPT_FID(FPTN=FIDFPT, NAME=VLP_NAME, PASS=VLP_PASS, ACCT=VLP_ACCT,
           ASN=SBLK$, RES=CGOPN.V.RES#, SN=VLP_SN, WSN=VLP_WSN);
%FPT_CLOSE(FPTN=CGCLS, DCB=M$CG);
%FPT_CGINFO(FPTN=CGINFO, DCB=M$CG,
                         CGCP=CGINFO_CGCP,
                         STAFC=DUMP,
                         SETSTA=CGINFO_SETSTA,
                         STALIST=CGINFO_STALIST,
                         TYPFC=DUMP,
                         QLIST=CGINFO_QLIST,
                         TYPLIST=CGINFO_TYPLIST,
                         HOLDSTA=CGINFO_HOLDSTA,
                         JRNLSTA=CGINFO_JRNLSTA,
                         JRNLFID=CGINFO_JRNLFID,
                         STATS=CGINFO_STATS);
%FPT_CGCTL(FPTN=CGCTL, DCB=M$CG,
                       CGCP=CGINFO_CGCP,
                       SETSTA=CGINFO_SETSTA,
                       HOLDSTA=CGINFO_HOLDSTA, STCLASS="STATIC SYMDEF");
%VLP_CGCP(FPTN=CGINFO_CGCP);
%VLP_JRNLFID(FPTN=CGINFO_JRNLFID);
%VLP_STATION(FPTN=CGINFO_JRNLSTA);
%VLP_CGQL(FPTN=CGINFO_QLIST, NLIST=100);
%VLP_SETSTA(FPTN=CGINFO_SETSTA);
%VLP_CGSTAL(FPTN=CGINFO_STALIST, NSTA=50);
%VLR_CGSTATS(FPTN=CGINFO_STATS);
%VLR_CGSTATS(FPTN=LSTATS);
%VLR_CGSTATS(FPTN=INIT_LSTATS);
%VLP_CGTYPL(FPTN=CGINFO_TYPLIST, NTYP=100);
%FPT_FWCG(FPTN=FWCG, DCB=M$CG,
                     CRITERIA=VLP_CGMA,
                     INFORM=YES,
                     QSELECT=ALL,
                     RESULTS=VLR_FWCG,
                     SCA=VLP_SCGMA);
%VLP_CGMA;
%VLP_SCGMA(PRIO=YES, UTS=YES, MSGSIZE=YES, MSGID=YES);
%VLR_FWCG;
%FPT_FWCG(FPTN=FWCG_DUMP, DCB=M$CG,
                          CRITERIA=VLP_CGMA_DUMP,
                          QSELECT=DIRECT,
                          SCA=VLP_SCGMA_DUMP,
                          REATTR=VLP_CGMA_REATTR,
                          SRA=VLP_SCGMA_DUMP, STCLASS="STATIC SYMDEF");
%VLP_CGMA(FPTN=VLP_CGMA_DUMP, DEST='CGU_HOLD', STCLASS="STATIC SYMDEF");
%VLP_SCGMA(FPTN=VLP_SCGMA_DUMP, DEST=YES, STCLASS="STATIC SYMDEF");
%VLP_CGMA(FPTN=VLP_CGMA_REATTR, DEST=' ', STCLASS="STATIC SYMDEF");
%VLP_STATION(DIRONLY=YES, MSGTYP='?', EOFNONE=YES);
%VLP_STATION(FPTN=CGINFO_HOLDSTA, STCLASS="STATIC SYMDEF");
%VLP_STATION(FPTN=DUMP_HOLDSTA, STATION='CGU_HOLD');
%FPT_READ(FPTN=MSGRD, DCB=M$CG, WAIT=YES, STATION=VLP_STATION);
%B$CGAURD(STCLASS=STATIC);
%VLP_CGMA(FPTN=CGM);
%FPT_READ(FPTN=DREAD, DCB=M$CG, BUF=DUMP_BUF, STATION=DUMP_STA, WAIT=YES);
%VLP_STATION(FPTN=DUMP_STA, EOFNONE=YES, LATCH=YES, STCLASS="STATIC SYMDEF");
%VLP_STATION(FPTN=DUMP_LASTSTA, STCLASS=BASED);
%FPT_UNLATCH(FPTN=DUMP_UNL, DCB=M$CG, TELLOS=NO, TELLAU=NO);
%FPT_ERRMSG(SOURCE=ALTRET, RESULTS=VLR_ERRMSG, DCB=M$CG,
            OUTDCB1=M$LO, BUF=EMSGBUF);
%VLR_ERRMSG;
%PARSE$OUT(NAME=PARSOUT);
%PARSE$SYM(NAME=PARSYM, STCLASS="BASED(SBLK$)");
%F_FDS(NAME=FDS, BUF=LOBUF, DCB=M$LO);
%VLP_VECTOR(FPTN=BUF_);
%VLP_VECTOR(FPTN=BUFA_);
DCL    X$WRITE ENTRY(22);
DCL    NODE    UBIN SYMREF;
DCL    BLK$   PTR SYMREF;
DCL    B$TCB$ PTR SYMREF;
/*  Formats  */
DCL    FMTERR  STATIC CHAR(0) INIT('%0A');
DCL    FMTBLNK STATIC CHAR(0) INIT('%1/');
DCL    FMT00   STATIC CHAR(0) INIT('%1/%0A%1/');
DCL    FMT01   STATIC CHAR(0) INIT('%3(%10LA%8>A| %)%10LA%8>A');
DCL    FMT03   STATIC CHAR(0) INIT('%10LA%8A| %10LA%8D| %10LA%8A| %10LA%8A');
DCL    FMT04   STATIC CHAR(0) INIT('%2(%10LA%8A| %)%10LA%8D| %10LA%8D');
DCL    FMT05   STATIC CHAR(0) INIT('%10LA%8>A| %2(%10LA%8A| %)%10LA%8O');
DCL    FMT07   STATIC CHAR(0) INIT('%10LA%8D| %10LA%8A| %10LA%8D| %10LA%8D');
DCL    FMT09   STATIC CHAR(0) INIT('%3(%10LA%8A| %)%10LA%8D');
DCL    FMT10   STATIC CHAR(0) INIT('%3(%10LA%8A| %)%10LA%8>A');
DCL    FMT11   STATIC CHAR(0) INIT('%10LA%8A| %2(%10LA%8D| %)%10LA%8A');
DCL    FMT12   STATIC CHAR(0) INIT('%10LA%8A| %10LA%8D| %10LA%8A| ');
DCL    FMT13   STATIC CHAR(0) INIT('%2(%1/%0A%)%1/');
DCL    FMT14   STATIC CHAR(0) INIT('%8A %5D %6D %4D %4D %4A');
DCL    FMT15   STATIC CHAR(0) INIT('%8XDCB%8X|%6XTerminal%5X|%8XDisk%7X| DFRBLKS | Garbage');
DCL    FMT16   STATIC CHAR(0) INIT('%3(  Reads%5XWrites |%) Unavail | Col  Runs');
DCL    FMT17   STATIC CHAR(0) INIT('%3( All Snap  All Snap|%)All  Snap|All  Snap');
DCL    FMT18   STATIC CHAR(0) INIT('%3(%3(%4D %)%4D|%)%3D%3X%3D|%3D%3X%3D');
DCL    FMT19   STATIC CHAR(0) INIT('%17A%3D%9A%3D%27A%3D%12A%3D)');
DCL    FMT20   STATIC CHAR(0) INIT('%8>A|%3(%6D|%) %3D|%6D|%2(%8LA|%)%4D|%14..3U');
DCL    FMT21   STATIC CHAR(0) INIT('%31( %)%3D|%6D|%2(%8LA|%)%4D|%14..3U');
DCL    FMT22   STATIC CHAR(0) INIT('%5..4U %0A%0A<>%D<>%0A,%0A%0A');
DCL    FMT23   STATIC CHAR(0) INIT('%0A = %A');
DCL    FMT24   STATIC CHAR(0) INIT('%0A = %D');
DCL    FMT25   STATIC CHAR(0) INIT('%0A = %O');
DCL    FMT26   STATIC CHAR(0) INIT('%10LA%8A|');
DCL    FMT27   STATIC CHAR(0) INIT('%1/%2X%D%X-%X%D%XBytes (Msgid=%D, Type=%0L>A)');
DCL    FMT28   STATIC CHAR(0) INIT('%6.18ZO%2S%2X%4(%2(%3.9ZO%Q%).%2(%3.9ZO%Q%)%X%)');
DCL    FMT29   STATIC CHAR(0) INIT('%6.18ZO%2S%2X%4(%2(%3.9ZO%Q%).%2(%3.9ZO%Q%)%X%)%65-%A');
DCL    FMT30   STATIC CHAR(0) INIT('%V@%X%A%/');
DCL    FMT31   STATIC CHAR(0) INIT('%V@%NX%A%/');
DCL    FMT32   STATIC CHAR(0) INIT('%2(%10LA%8>A| %)%7A %0A');
DCL    FMT33   STATIC CHAR(0) INIT('%NA');
DCL    FMT34   STATIC CHAR(0) INIT('%V@%6.18ZO%2S%2X%4(%2(%3.9ZO%Q%).%2(%3.9ZO%Q%)%X%)');
DCL    TXT77   STATIC CHAR(0) INIT('HOLDSTA');
DCL    TXT78   STATIC CHAR(0) INIT('JRNLSTA');
DCL    TXT79   STATIC CHAR(0) INIT('JRNLFID');
DCL    TXT00   STATIC CHAR(0) INIT('CG Control Parameters');
DCL    TXT01   STATIC CHAR(0) INIT('AUCONDCB');
DCL    TXT02   STATIC CHAR(0) INIT('AUCONTERM');
DCL    TXT03   STATIC CHAR(0) INIT('AUDCONDCB');
DCL    TXT04   STATIC CHAR(0) INIT('AUDCONTERM');
DCL    TXT05   STATIC CHAR(0) INIT('AUTORCVR');
DCL    TXT06   STATIC CHAR(0) INIT('BIGMXT');
DCL    TXT07   STATIC CHAR(0) INIT('BIN');
DCL    TXT08   STATIC CHAR(0) INIT('CARRYOSTA');
DCL    TXT09   STATIC CHAR(0) INIT('CONMSG');
DCL    TXT10   STATIC CHAR(0) INIT('DATAPGS');
DCL    TXT11   STATIC CHAR(0) INIT('DCBCONAU');
DCL    TXT12   STATIC CHAR(0) INIT('DCBCONLGL');
DCL    TXT13   STATIC CHAR(0) INIT('DCBCONNAU');
DCL    TXT14   STATIC CHAR(0) INIT('DCBCONWA');
DCL    TXT15   STATIC CHAR(0) INIT('DEFERBLKS');
DCL    TXT16   STATIC CHAR(0) INIT('DISKWARN');
DCL    TXT17   STATIC CHAR(0) INIT('DMTYP');
DCL    TXT18   STATIC CHAR(0) INIT('DRML');
DCL    TXT19   STATIC CHAR(0) INIT('DSCREQ');
DCL    TXT20   STATIC CHAR(0) INIT('DVBYTE');
DCL    TXT21   STATIC CHAR(0) INIT('INPUT');
DCL    TXT22   STATIC CHAR(0) INIT('JOURNAL');
DCL    TXT23   STATIC CHAR(0) INIT('MAXMC');
DCL    TXT24   STATIC CHAR(0) INIT('MAXPG');
DCL    TXT25   STATIC CHAR(0) INIT('MEMWARN');
DCL    TXT26   STATIC CHAR(0) INIT('MEMWARNP');
DCL    TXT27   STATIC CHAR(0) INIT('MINPG');
DCL    TXT28   STATIC CHAR(0) INIT('MXACT');
DCL    TXT29   STATIC CHAR(0) INIT('OUTPUT');
DCL    TXT30   STATIC CHAR(0) INIT('QRML');
DCL    TXT31   STATIC CHAR(0) INIT('RAS');
DCL    TXT32   STATIC CHAR(0) INIT('REDUNDANT');
DCL    TXT33   STATIC CHAR(0) INIT('REREAD');
DCL    TXT34   STATIC CHAR(0) INIT('SECURE');
DCL    TXT35   STATIC CHAR(0) INIT('SMD');
DCL    TXT36   STATIC CHAR(0) INIT('STAPRIO');
DCL    TXT37   STATIC CHAR(0) INIT('TERMCONAU');
DCL    TXT38   STATIC CHAR(0) INIT('TERMCONLGL');
DCL    TXT39   STATIC CHAR(0) INIT('TERMCONNAU');
DCL    TXT40   STATIC CHAR(0) INIT('TMTYP');
DCL    TXT41   STATIC CHAR(0) INIT('TRANS');
DCL    TXT42   STATIC CHAR(0) INIT('TRMRDSIZ');
DCL    TXT43   STATIC CHAR(0) INIT('TYPPRIO');
DCL    TXT44   STATIC CHAR(0) INIT('UNLAMSG');
DCL    TXT45   STATIC CHAR(0) INIT('WAS');
DCL    TXT46   STATIC CHAR(0) INIT('WRITETIME');
DCL    TXT47   STATIC CHAR(0) INIT('XSTALGL');
DCL    TXT475  STATIC CHAR(0) INIT('XTYPLGL');
DCL    TXT48   STATIC CHAR(0) INIT('CG Stations');
DCL    TXT49   STATIC CHAR(0)
       INIT('Name     Reads Writes Prio Msgs ACPA(Active,Connected,Perm,AUP)');
DCL    TXT50   STATIC CHAR(0) INIT('CG Statistics');
DCL    TXT51   STATIC CHAR(0) INIT('Connected (DCBs :');
DCL    TXT52   STATIC CHAR(0) INIT(', Terms :');
DCL    TXT53   STATIC CHAR(0) INIT(')   Messages (Anonymous Q :');
DCL    TXT54   STATIC CHAR(0) INIT(', Directed :');
DCL    TXT55   STATIC CHAR(0) INIT('CG Messages');
DCL    TXT56   STATIC CHAR(0) INIT(
 '  Type  |Active| Count| MXACT|Prio| MSGID|  DEST  | Origin |Size|  Time Stamp');
DCL    TXT57   STATIC CHAR(0) INIT('CG low memory warning');
DCL    TXT58   STATIC CHAR(0) INIT('CG low disk space warning');
DCL    TXT59   STATIC CHAR(0) INIT('Default SETSTA Parameters');
DCL    TXT60   STATIC CHAR(0) INIT('ALLABSENT');
DCL    TXT61   STATIC CHAR(0) INIT('ALLDCBS');
DCL    TXT62   STATIC CHAR(0) INIT('ALLTRMS');
DCL    TXT63   STATIC CHAR(0) INIT('ANYDCB');
DCL    TXT64   STATIC CHAR(0) INIT('DIRONLY');
DCL    TXT65   STATIC CHAR(0) INIT('EOFNONE');
DCL    TXT66   STATIC CHAR(0) INIT('EOFONE');
DCL    TXT67   STATIC CHAR(0) INIT('ILATCH');
DCL    TXT68   STATIC CHAR(0) INIT('ILOCK');
DCL    TXT69   STATIC CHAR(0) INIT('IMSGTYP');
DCL    TXT70   STATIC CHAR(0) INIT('ISTATION');
DCL    TXT71   STATIC CHAR(0) INIT('MYSTATION');
DCL    TXT72   STATIC CHAR(0) INIT('OLATCH');
DCL    TXT73   STATIC CHAR(0) INIT('OLOCK');
DCL    TXT74   STATIC CHAR(0) INIT('OMSGTYP');
DCL    TXT75   STATIC CHAR(0) INIT('OSTATION');
DCL    TXT76   STATIC CHAR(0) INIT('SETSTAWAS');
DCL    EMSG01  STATIC CHAR(0) INIT('First specify a comgroup with CG name');
DCL    EMSG02  STATIC CHAR(0) INIT('...syntax error');
DCL    EMSG03  STATIC CHAR(0) INIT('No stations currently connected');
DCL    EMSG04  STATIC CHAR(0) INIT('No messages found that satisfy that criteria');
DCL    EMSG05  STATIC CHAR(0) INIT('You must be AU to do that');
DCL    EMSG06  STATIC CHAR(0) INIT('Need EOFNONE=NO to MONITOR');
/*  Static  */
DCL    DUMP_BUF    STATIC CHAR(2048);
DCL    DUMP_BUFA   STATIC CHAR(16);
DCL    CODE        STATIC SYMDEF UBIN INIT(0);
DCL    TAB         STATIC UBIN;
DCL    MYSTATION   STATIC CHAR(8);
DCL    CGU_READ    STATIC SYMDEF REMEMBER;
DCL    STATION STATIC CHAR(8) INIT(' ');
DCL    EMSGBUF STATIC CHAR(120) INIT(' ');
DCL    LOBUF   STATIC CHAR(81) INIT(' ');
DCL 1  AUCON(0:3) STATIC,
     2  TXT    CHAR(4) INIT('  NC', 'ACTV', 'DEAC', 'DISC');
DCL    PRMPT   STATIC CHAR(0) INIT(':');
DCL    SBLK$   STATIC PTR;
DCL    TBLK$   STATIC PTR;
DCL    DCB$    STATIC PTR;
DCL    OPTS    STATIC SBIN INIT(0);
DCL 1  OPT(0:35) REDEF OPTS,
     2  F      BIT(1) UNAL;
/*   BASED   */
DCL 1  RBUF(0:15)  BASED(BUF_.PTR$),
     2     C       CHAR(1) UNAL,
     2     U       REDEF C UBIN(9) UNAL;
DCL 1  RBUFA(0:15) BASED(BUFA_.PTR$),
     2     C       CHAR(1) UNAL;
/*  AUTO  */
DCL    PARM1   CHAR(4);
DCL    PARM2   CHAR(4);
DCL    PARM3   CHAR(4);
DCL    PARM4   CHAR(4);
DCL    PARM5   CHAR(8);
DCL    PARM6   CHAR(8);
DCL    PARM7   CHAR(8);
DCL    PARM8   CHAR(8);
DCL    FIDPARM CHAR(31);
DCL    DPARM1  UBIN;
DCL    DPARM2  UBIN;
DCL    DPARM3  UBIN;
DCL    DPARM4  UBIN;
DCL    IX      SBIN;
DCL    IXC     UBIN(18);
DCL    RECNO   UBIN;
DCL    YNS     CHAR(4);
DCL 1  YN(0:3) REDEF YNS,
     2  V      CHAR(1) UNAL;
DCL    WTIME   UBIN;
DCL    MSGIDS      BIT(1);
DCL    MBLK$       PTR;
/**/
       REMEMBER RD_AGIN IN CGU_READ;
       DCB$ = DCBADDR(DCBNUM(M$CG));
RD_AGIN:   ;
       CALL XUR$GETCMD(NODE, BLK$, VECTOR(PRMPT)) ALTRET(RD_ERR);
       CODE = PARSOUT.SUBLK$(0)->PARSOUT.CODE;
       BLK$ = PARSOUT.SUBLK$(0);
       DO CASE(CODE);
         CASE(%CGALL#,%CGPARAM#,%CGUSERS#,%CGSTATS#,%CGMESSAGES#,
              %CGGO#,%CGMONITOR#,%CGLET#,%CGDELETE#,%CGDUMP#);
           IF NOT F$DCB.FCD# THEN DO;
               CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG01));
               GOTO RD_AGIN;
               END;
           ELSE DO;
               CALL M$CGINFO(CGINFO) ALTRET(CGERR);
               IF PARSOUT.NSUBLKS ~= 0 &
                   (CODE ~= %CGMESSAGES# & CODE ~= %CGDELETE# &
                    CODE ~= %CGUSERS# & CODE ~= %CGPARAM# &
                    CODE ~= %CGLET# & CODE ~= %CGDUMP#) THEN DO;
                   SBLK$ = PARSOUT.SUBLK$(0);
                   CALL CHARBIN(WTIME, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   WFPT.V.UNITS# = WTIME;
                   END;
               END;
           END;
       DO CASE(CODE);
         CASE(%CGPARAM#);  /* CG Parameters...CGCP */
           IF PARSOUT.NSUBLKS = 0 THEN
               CALL CGCP_ALL;
           ELSE
               IF PARSOUT.NSUBLKS = 1 &
                  PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LALL# THEN
                   CALL CGCP_ALL;
               ELSE
                   CALL CGCP_SUB;
           GOTO RD_AGIN;
         CASE(%CGUSERS#);  /*  CG Stations or Users   */
           STATION = ' ';
           IF PARSOUT.NSUBLKS ~= 0 THEN DO;
               TBLK$ = BLK$;
               DO IX=0 TO TBLK$->PARSOUT.NSUBLKS - 1;
                   BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
                   SBLK$ = BLK$;
                   DO CASE(PARSOUT.CODE);
                     CASE(%INC#);
                       CALL CHARBIN(WTIME, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                       WFPT.V.UNITS# = WTIME;
                     CASE(%LSTATION#);
                       SBLK$ = PARSOUT.SUBLK$(0);
                       IF PARSYM.CODE ~= %ALLQ# THEN
                           STATION = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                      END;
                   END;
               END;
           CALL STALIST;
           GOTO RD_AGIN;
         CASE(%CGDUMP#);  /* Dump CG messages */
           IF F$DCB.AU# = %NO# THEN DO;
               CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG05));
               GOTO RD_AGIN;
               END;
           MYSTATION = ' ';
           CGCTL.HOLDSTA_ = VECTOR(DUMP_HOLDSTA); /* HOLDSTA = CGU_HOLD */
           CALL M$CGCTL(CGCTL) ALTRET(CGERR);
           IF CGINFO_HOLDSTA.STATION# = ' ' THEN
               CGCTL.HOLDSTA_ = VECTOR(ERASE);
           ELSE
               CGCTL.HOLDSTA_ = VECTOR(CGINFO_HOLDSTA);
           TBLK$ = BLK$;
           SBLK$ = TBLK$->PARSOUT.SUBLK$(0);
           DPARM1 = PARSYM.CODE;   /* Save type of dump */
           DUMP_STA.CTL.DIRONLY# = '0'B;
           DUMP_STA.STATION# = '?';
           DUMP_STA.MSGTYP# = '?';
           MSGIDS = %NO#;
           DO IX = 1 TO TBLK$->PARSOUT.NSUBLKS - 1;
               BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
               SBLK$ = BLK$;
               DO CASE(PARSOUT.CODE);
                 CASE(%MSGID#);
                   MSGIDS = %YES#;
                   MBLK$ = BLK$;
                 CASE(%ORIG#);
                   IF PARSYM.CODE = %ALLQ# THEN
                       DUMP_STA.STATION# = '?';
                   ELSE DO;
                       SBLK$ = PARSYM.TEXTC$;
                       DUMP_STA.STATION# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                       END;
                 CASE(%DEST#);
                   IF PARSYM.CODE = %ALLQ# THEN
                       GOTO PASS_DEST;
                   ELSE
                       SBLK$ = PARSYM.TEXTC$;
                   MYSTATION = VLP_SETSTA.MYSTATION#;
                   CALL M$CLOSE(CGCLS);
                   DUMP_STA.CTL.DIRONLY# = '1'B;
                   VLP_SETSTA.MYSTATION# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                   CALL M$OPEN(CGOPN) WHENALTRETURN DO;
                       VLP_SETSTA.MYSTATION# = MYSTATION;
                       CALL M$OPEN(CGOPN) ALTRET(CGERR);
                       GOTO CGERR;
                       END;
PASS_DEST: ;
                 CASE(%TYPE#);
                   IF PARSYM.CODE = %ALLQ# THEN
                       DUMP_STA.MSGTYP# = '?';
                   ELSE DO;
                       SBLK$ = PARSYM.TEXTC$;
                       DUMP_STA.MSGTYP# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                       END;
                   END;
               END;
           DUMP_UNL.V.INPUT# = 1;  /* Hold unlatched messages */
           RECNO = 1;
           DO WHILE('1'B);
               CALL M$READ(DREAD) ALTRET(DUMP_ERR);
               IF MSGIDS THEN
                   CALL MSGID_CHK(F$DCB.LASTSTA$->DUMP_LASTSTA.MSGID#)
                       ALTRET(DUMP_NEXT);
               DO CASE(DPARM1);
                 CASE(%LDUC#);
                   CALL X$WRITE(FDS, VECTOR(FMT33), VECTOR(F$DCB.ARS#),
                                VECTOR(SUBSTR(DUMP_BUF,,F$DCB.ARS#)));
                 CASE(%LDUO#, %LDUA#);
                   IXC = 0;
                   DPARM2 = F$DCB.ARS#;
                   CALL X$WRITE(FDS, VECTOR(FMT27), VECTOR(RECNO),
                                VECTOR(DPARM2),
                                VECTOR(F$DCB.LASTSTA$->DUMP_LASTSTA.MSGID#),
                                VECTOR(F$DCB.LASTSTA$->DUMP_LASTSTA.MSGTYP#));
                   DO WHILE(DPARM2 >= 16);
                       DPARM3 = IXC*4;
                       BUF_ = VECTOR(SUBSTR(DUMP_BUF, DPARM3, 16));
                       IF DPARM1 = %LDUO# THEN
                           CALL X$WRITE(FDS, VECTOR(FMT28), VECTOR(IXC), BUF_);
                       ELSE DO;
                           BUFA_ = VECTOR(DUMP_BUFA);
                           DO IX = 0 TO 15;
                               IF RBUF.U(IX) < 32 | RBUF.U(IX) > 126 THEN
                                   RBUFA.C(IX) = '.';
                               ELSE
                                   RBUFA.C(IX) = RBUF.C(IX);
                               END;
                           CALL X$WRITE(FDS, VECTOR(FMT29), VECTOR(IXC), BUF_,
                                                            BUFA_);
                           END;
                       DPARM2 = DPARM2 - 16;
                       IXC = IXC + 4;
                       END;
                   IF DPARM2 > 0 THEN DO;
                       DPARM3 = IXC*4;
                       BUF_ = VECTOR(SUBSTR(DUMP_BUF, DPARM3, DPARM2));
                       IF DPARM1 = %LDUO# THEN
                           CALL X$WRITE(FDS, VECTOR(FMT28), VECTOR(IXC), BUF_);
                       ELSE DO;
                           TAB = 55-(3*DPARM2 +
                                 DPARM2/4-(1-BITBIN(MOD(DPARM2,4)~=0)) +
                                 (DPARM2-2)/4-(1-BITBIN(MOD(DPARM2-2,4)~=0)));
                           BUFA_ = VECTOR(SUBSTR(DUMP_BUFA, 0, DPARM2));
                           DO IX = 0 TO DPARM2-1;
                               IF RBUF.U(IX) < 32 | RBUF.U(IX) > 126 THEN
                                   RBUFA.C(IX) = '.';
                               ELSE
                                   RBUFA.C(IX) = RBUF.C(IX);
                               END;
                           CALL X$WRITE(FDS, VECTOR(FMT34), VECTOR(IXC), BUF_);
                           CALL X$WRITE(FDS, VECTOR(FMT31), VECTOR(TAB), BUFA_);
                           CALL X$WRITE(FDS, VECTOR(FMTBLNK) );
                           END;
                       END;
                   END;
           RECNO = RECNO + 1;
DUMP_NEXT: ;
               CALL M$UNLATCH(DUMP_UNL) ALTRET(CGERR);
               END; /* END DO WHILE */
DUMP_ERR:  ;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$EOF THEN
               GOTO CGERR;
           IF DUMP_STA.CTL.DIRONLY# = %YES# THEN
               CALL UN_CGU_HOLD ALTRET(CGERR);
           ELSE
               CALL M$FWCG(FWCG_DUMP) ALTRET(CGERR);
           CALL M$CGCTL(CGCTL) ALTRET(CGERR);
         CASE(%CGMESSAGES#, %CGDELETE#);  /* Display/delete CG messages */
           IF CODE = %CGDELETE# THEN
               FWCG.V.DELETE# = %YES#;
           ELSE
               FWCG.V.DELETE# = %NO#;
           FWCG.V.QSELECT# = %ALL#;
           VLP_SCGMA.MSGID# = %NO#;
           VLP_SCGMA.MSGTYP# = %NO#;
           VLP_SCGMA.ORIGIN# = %NO#;
           VLP_SCGMA.DEST# = %NO#;
           MSGIDS = %NO#;
           IF CODE = %CGDELETE# THEN DO;
               FWCG.V.DELETE# = %YES#;
               FWCG.V.INFORM# = %NO#;
               VLP_SCGMA.MSGID# = %YES#;
               END;
           ELSE DO;
               FWCG.V.DELETE# = %NO#;
               FWCG.V.INFORM# = %YES#;
               END;
           IF PARSOUT.NSUBLKS = 0 THEN DO;
               VLP_SCGMA.MSGTYP# = %YES#;
               VLP_SCGMA.ORIGIN# = %YES#;
               VLP_SCGMA.DEST# = %YES#;
               VLP_SCGMA.MSGID# = %YES#;
               VLP_CGMA.MSGTYP# = '?';
               VLP_CGMA.ORIGIN# = '?';
               VLP_CGMA.DEST# = '?';
               VLP_CGMA.MSGID# = 0;
               GOTO MSGRPT;
               END;
           TBLK$ = BLK$;
           DO IX=0 TO TBLK$->PARSOUT.NSUBLKS - 1;
               BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
               SBLK$ = BLK$;
               DO CASE(PARSOUT.CODE);
                 CASE(%INC#);
                   CALL CHARBIN(WTIME, SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
                   WFPT.V.UNITS# = WTIME;
                   IF TBLK$->PARSOUT.NSUBLKS = 1 THEN DO;
                       VLP_SCGMA.MSGTYP# = %YES#;
                       VLP_SCGMA.ORIGIN# = %YES#;
                       VLP_SCGMA.DEST# = %YES#;
                       VLP_CGMA.MSGTYP# = '?';
                       VLP_CGMA.ORIGIN# = '?';
                       VLP_CGMA.DEST# = '?';
                       END;
                 CASE(%QSELECT#);
                   SBLK$ = PARSOUT.SUBLK$(IX);
                   DO CASE(PARSYM.CODE);
                     CASE(%LALL#);
                       FWCG.V.QSELECT# = %ALL#;
                     CASE(%LDIRECT#);
                       FWCG.V.QSELECT# = %DIRECT#;
                     CASE(%LANONYMOUS#);
                       FWCG.V.QSELECT# = 3; /* ANONYMOUS */
                     END;
                 CASE(%MSGID#);
                   MSGIDS = %YES#;
                   MBLK$ = BLK$;
                 CASE(%DEST#);
                   SBLK$ = PARSOUT.SUBLK$(IX);
                   FWCG.V.QSELECT# = %DIRECT#;
                   VLP_SCGMA.DEST# = %YES#;
                   IF PARSYM.CODE = %ALLQ# THEN
                       VLP_CGMA.DEST# = '?';
                   ELSE
                       VLP_CGMA.DEST# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%ORIG#);
                   SBLK$ = PARSOUT.SUBLK$(IX);
                   VLP_SCGMA.ORIGIN# = %YES#;
                   IF PARSYM.CODE = %ALLQ# THEN
                       VLP_CGMA.ORIGIN# = '?';
                   ELSE
                       VLP_CGMA.ORIGIN# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%TYPE#);
                   SBLK$ = PARSOUT.SUBLK$(IX);
                   VLP_SCGMA.MSGTYP# = %YES#;
                   IF PARSYM.CODE = %ALLQ# THEN
                       VLP_CGMA.MSGTYP# = '?';
                   ELSE
                       VLP_CGMA.MSGTYP# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 END;
               END;
MSGRPT:    ;
               CALL CGMESS;
               GOTO RD_AGIN;
         CASE(%CGSTATS#);  /* CG Statistics */
           CALL CGSTATS;
           GOTO RD_AGIN;
         CASE(%CGFID#);  /* Open CG fid */
           IF F$DCB.FCD# THEN
               CALL M$CLOSE(CGCLS);
           FIDFPT.TEXTFID_ = VECTOR(PARSOUT.SUBLK$(0)->PARSYM.TEXT);
           CALL M$FID(FIDFPT) ALTRET(CGERR);
           CGOPN.V.AU# = %NO#;
           CGOPN.V.FUN# = %IN#;
           VLP_SETSTA.MYSTATION# = ' ';
           IF PARSOUT.NSUBLKS > 1 THEN DO;
               TBLK$ = BLK$;
               DO IX = 1 TO TBLK$->PARSOUT.NSUBLKS - 1;
                   BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
                   DO CASE(PARSOUT.CODE);
                     CASE(%XAU#);
                       SBLK$ = PARSOUT.SUBLK$(0);
                       IF SBLK$->PARSOUT.SUBLK$(0)->PARSOUT.CODE=%LYEA# THEN DO;
                           CGOPN.V.AU# = %YES#;
                           CGOPN.V.FUN# = %UPDATE#;
                           END;
                     CASE(%XSTANAME#);
                       SBLK$ = PARSOUT.SUBLK$(0);
                       VLP_SETSTA.MYSTATION# = SUBSTR(PARSYM.TEXT,,
                                                      PARSYM.COUNT);
                       END;
                   END;
               END;
           CGCTL.HOLDSTA_ = VECTOR(NIL);
           CGCTL.JRNLSTA_ = VECTOR(NIL);
           CGCTL.JRNLFID_ = VECTOR(NIL);
           CALL M$OPEN(CGOPN) ALTRET(CGERR);
           CALL M$CGINFO(CGINFO) ALTRET(CGERR);
         CASE(%CGADD#);  /*  ADD  */
           DO IX = PARSOUT.NSUBLKS DOWNTO 1 BY -1;
               CODE = PARSOUT.SUBLK$(IX-1)->PARSOUT.CODE;
               IF CODE = 0 THEN DO;
                   OPTS = -1;
                   GOTO XITADD;
                   END;
               OPT.F(CODE) = %YES#;
               END;
XITADD:    ;
         CASE(%CGDROP#);  /*  DROP  */
           DO IX = PARSOUT.NSUBLKS DOWNTO 1 BY -1;
               CODE = PARSOUT.SUBLK$(IX-1)->PARSOUT.CODE;
               IF CODE = 0 THEN DO;
                   OPTS = 0;
                   GOTO XITDROP;
                   END;
               OPT.F(CODE) = %NO#;
               END;
XITDROP:   ;
         CASE(%CGALL#, %CGGO#);  /*  ALL and GO  */
           IF CODE = %CGALL# THEN
               OPTS = -1;
           IF OPT.F(%LPARAM#) = %YES# THEN
               CALL CGCP_ALL;
           DO WHILE('1'B);
               IF OPT.F(%LUSERS#) THEN
                   CALL STALIST;
               IF OPT.F(%LSTATS#) THEN
                   CALL CGSTATS;
               IF OPT.F(%LMESSAGES#) THEN DO;
               VLP_SCGMA.MSGTYP# = %YES#;
               VLP_SCGMA.ORIGIN# = %YES#;
               VLP_SCGMA.DEST# = %YES#;
               VLP_CGMA.MSGTYP# = '?';
               VLP_CGMA.ORIGIN# = '?';
               VLP_CGMA.DEST# = '?';
                   CALL CGMESS;
                   END;
               IF WTIME = 0 THEN
                   GOTO XITGO;
               CALL M$WAIT(WFPT);
               END;
XITGO:     ;
         CASE(%CGEND#);  /* END */
           IF F$DCB.FCD# THEN
               CALL M$CLOSE(CGCLS);
           CGCLS.V.DCB# = DCBNUM(M$LO);
           CGCLS.V.DISP# = %SAVE#;
           CALL M$CLOSE(CGCLS);
           CALL M$EXIT;
         CASE(%CGLET#);  /* LET to change comgroup parameters */
           TBLK$ = BLK$;
           DO IX=0 TO TBLK$->PARSOUT.NSUBLKS - 1;
               BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
               DO CASE(PARSOUT.CODE);
                 CASE(%XAUCONDCB#);
                   CGINFO_CGCP.AUCONDCB# = PARSOUT.SUBLK$(0)->PARSOUT.CODE - %LNC#;
                 CASE(%XAUCONTERM#);
                   CGINFO_CGCP.AUCONTERM# = PARSOUT.SUBLK$(0)->PARSOUT.CODE - %LNC#;
                 CASE(%XAUDCONDCB#);
                   CGINFO_CGCP.AUDCONDCB# = PARSOUT.SUBLK$(0)->PARSOUT.CODE - %LNC#;
                 CASE(%XAUDCONTERM#);
                   CGINFO_CGCP.AUDCONTERM# = PARSOUT.SUBLK$(0)->PARSOUT.CODE - %LNC#;
                 CASE(%XAUTORCVR#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.AUTORCVR# = %YES#;
                   ELSE
                       CGINFO_CGCP.AUTORCVR# = %NO#;
                 CASE(%XBIGMXT#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.BIGMXT# = %YES#;
                   ELSE
                       CGINFO_CGCP.BIGMXT# = %NO#;
                 CASE(%XBIN#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DVBYTE.BIN# = %YES#;
                   ELSE
                       CGINFO_CGCP.DVBYTE.BIN# = %NO#;
                 CASE(%XCARRYOSTA#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.CARRYOSTA# = %YES#;
                   ELSE
                       CGINFO_CGCP.CARRYOSTA# = %NO#;
                 CASE(%XCONMSG#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.CONMSG# = %YES#;
                   ELSE
                       CGINFO_CGCP.CONMSG# = %NO#;
                 CASE(%XDATAPGS#);
                   CALL CHARBIN(DPARM1,
                           SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                  PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.DATAPGS# = DPARM1;
                 CASE(%XDCBCONAU#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DCBCONAU# = %YES#;
                   ELSE
                       CGINFO_CGCP.DCBCONAU# = %NO#;
                 CASE(%XDCBCONLGL#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DCBCONLGL# = %YES#;
                   ELSE
                       CGINFO_CGCP.DCBCONLGL# = %NO#;
                 CASE(%XDCBCONNAU#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DCBCONNAU# = %YES#;
                   ELSE
                       CGINFO_CGCP.DCBCONNAU# = %NO#;
                 CASE(%XDCBCONWA#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DCBCONWA# = %YES#;
                   ELSE
                       CGINFO_CGCP.DCBCONWA# = %NO#;
                 CASE(%XDEFERBLKS#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.DEFERBLKS# = DPARM1;
                 CASE(%XDISKWARN#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.DISKWARN# = DPARM1;
                 CASE(%XDMTYP#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_CGCP.DMTYP# = ' ';
                   ELSE
                       CGINFO_CGCP.DMTYP# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XDRML#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DRML# = %YES#;
                   ELSE
                       CGINFO_CGCP.DRML# = %NO#;
                 CASE(%XDSCREQ#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DSCREQ# = %YES#;
                   ELSE
                       CGINFO_CGCP.DSCREQ# = %NO#;
                 CASE(%XINPUT#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.INPUT# = %YES#;
                   ELSE
                       CGINFO_CGCP.INPUT# = %NO#;
                 CASE(%XJOURNAL#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.JOURNAL# = %YES#;
                   ELSE
                       CGINFO_CGCP.JOURNAL# = %NO#;
                 CASE(%XMAXMC#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.MAXMC# = DPARM1;
                 CASE(%XMAXPG#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.MAXPG# = DPARM1;
                 CASE(%XMEMWARN#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.MEMWARN# = DPARM1;
                 CASE(%XMEMWARNP#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.MEMWARNP# = %YES#;
                   ELSE
                       CGINFO_CGCP.MEMWARNP# = %NO#;
                 CASE(%XMINPG#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.MINPG# = DPARM1;
                 CASE(%XMXACT#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.MXACT# = DPARM1;
                 CASE(%XOUTPUT#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.OUTPUT# = %YES#;
                   ELSE
                       CGINFO_CGCP.OUTPUT# = %NO#;
                 CASE(%XQRML#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.QRML# = %YES#;
                   ELSE
                       CGINFO_CGCP.QRML# = %NO#;
                 CASE(%XRAS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.RAS# = %YES#;
                   ELSE
                       CGINFO_CGCP.RAS# = %NO#;
                 CASE(%XREDUNDANT#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.REDUNDANT# = %YES#;
                   ELSE
                       CGINFO_CGCP.REDUNDANT# = %NO#;
                 CASE(%XREREAD#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DVBYTE.REREAD# = %YES#;
                   ELSE
                       CGINFO_CGCP.DVBYTE.REREAD# = %NO#;
                 CASE(%XSECURE#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.SECURE# = %YES#;
                   ELSE
                       CGINFO_CGCP.SECURE# = %NO#;
                 CASE(%XSMD#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.SMD# = %YES#;
                   ELSE
                       CGINFO_CGCP.SMD# = %NO#;
                 CASE(%XSTAPRIO#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.STAPRIO# = DPARM1;
                 CASE(%XTERMCONAU#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.TERMCONAU# = %YES#;
                   ELSE
                       CGINFO_CGCP.TERMCONAU# = %NO#;
                 CASE(%XTERMCONLGL#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.TERMCONLGL# = %YES#;
                   ELSE
                       CGINFO_CGCP.TERMCONLGL# = %NO#;
                 CASE(%XTERMCONNAU#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.TERMCONNAU# = %YES#;
                   ELSE
                       CGINFO_CGCP.TERMCONNAU# = %NO#;
                 CASE(%XTMTYP#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_CGCP.TMTYP# = ' ';
                   ELSE
                       CGINFO_CGCP.TMTYP# = SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XTRANS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.DVBYTE.TRANS# = %YES#;
                   ELSE
                       CGINFO_CGCP.DVBYTE.TRANS# = %NO#;
                 CASE(%XTRMRDSIZ#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.TRMRDSIZ# = DPARM1;
                 CASE(%XTYPPRIO#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.TYPPRIO# = DPARM1;
                 CASE(%XUNLAMSG#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.UNLAMSG# = %YES#;
                   ELSE
                       CGINFO_CGCP.UNLAMSG# = %NO#;
                 CASE(%XWAS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.WAS# = %YES#;
                   ELSE
                       CGINFO_CGCP.WAS# = %NO#;
                 CASE(%XWRITETIME#);
                   CALL CHARBIN(DPARM1,
                                SUBSTR(PARSOUT.SUBLK$(0)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(0)->PARSYM.COUNT));
                   CGINFO_CGCP.WRITETIME# = DPARM1;
                 CASE(%XXSTALGL#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.XSTALGL# = %YES#;
                   ELSE
                       CGINFO_CGCP.XSTALGL# = %NO#;
                 CASE(%XXTYPLGL#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_CGCP.XTYPLGL# = %YES#;
                   ELSE
                       CGINFO_CGCP.XTYPLGL# = %NO#;
                 CASE(%XALLABSENT#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.ALLABSENT# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.ALLABSENT# = %NO#;
                 CASE(%XALLDCBS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.ALLDCBS# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.ALLDCBS# = %NO#;
                 CASE(%XALLTRMS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.ALLTRMS# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.ALLTRMS# = %NO#;
                 CASE(%XANYDCB#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.ANYDCB# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.ANYDCB# = %NO#;
                 CASE(%XDIRONLY#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.ISTA.DIRONLY# = %YES#;
                   ELSE
                       CGINFO_SETSTA.ISTA.DIRONLY# = %NO#;
                 CASE(%XEOFNONE#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.ISTA.EOFNONE# = %YES#;
                   ELSE
                       CGINFO_SETSTA.ISTA.EOFNONE# = %NO#;
                 CASE(%XEOFONE#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.ISTA.EOFONE# = %YES#;
                   ELSE
                       CGINFO_SETSTA.ISTA.EOFONE# = %NO#;
                 CASE(%XILATCH#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.ISTA.ILATCH# = %YES#;
                   ELSE
                       CGINFO_SETSTA.ISTA.ILATCH# = %NO#;
                 CASE(%XILOCK#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.ISTA.ILOCK# = %YES#;
                   ELSE
                       CGINFO_SETSTA.ISTA.ILOCK# = %NO#;
                 CASE(%XIMSGTYP#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_SETSTA.ISTA.IMSGTYP# = ' ';
                   ELSE
                       CGINFO_SETSTA.ISTA.IMSGTYP# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XISTATION#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_SETSTA.ISTA.ISTATION# = ' ';
                   ELSE
                       CGINFO_SETSTA.ISTA.ISTATION# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XMYSTATION#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_SETSTA.MYSTATION# = ' ';
                   ELSE
                       CGINFO_SETSTA.MYSTATION# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XOLATCH#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.OLATCH# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.OLATCH# = %NO#;
                 CASE(%XOLOCK#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.OLOCK# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.OLOCK# = %NO#;
                 CASE(%XOMSGTYP#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_SETSTA.OSTA.OMSGTYP# = ' ';
                   ELSE
                       CGINFO_SETSTA.OSTA.OMSGTYP# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XOSTATION#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGINFO_SETSTA.OSTA.OSTATION# = ' ';
                   ELSE
                       CGINFO_SETSTA.OSTA.OSTATION# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                 CASE(%XSETSTAWAS#);
                   IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                       CGINFO_SETSTA.OSTA.WAS# = %YES#;
                   ELSE
                       CGINFO_SETSTA.OSTA.WAS# = %NO#;
                 CASE(%XHOLDSTA#);
                   CALL UN_CGU_HOLD ALTRET(CGERR);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGCTL.HOLDSTA_ = VECTOR(ERASE);
                   ELSE DO;
                       CGCTL.HOLDSTA_ = VECTOR(CGINFO_HOLDSTA);
                       CGINFO_HOLDSTA.STATION# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                       END;
                 CASE(%XJRNLSTA#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGCTL.JRNLSTA_ = VECTOR(ERASE);
                   ELSE DO;
                       CGCTL.JRNLSTA_ = VECTOR(CGINFO_JRNLSTA);
                       CGINFO_JRNLSTA.STATION# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                       END;
                 CASE(%XJRNLFID#);
                   SBLK$ = PARSOUT.SUBLK$(0);
                   IF PARSYM.CODE = %LNONE# THEN
                       CGCTL.JRNLFID_ = VECTOR(ERASE);
                   ELSE DO;
                       CGCTL.JRNLFID_ = VECTOR(CGINFO_JRNLFID);
                       CGINFO_JRNLFID.JRNLFID# =
                           SUBSTR(PARSYM.TEXT,,PARSYM.COUNT);
                       END;
                 END; /* END DO CASE */
               END; /* END DO IX */
           CALL M$CGCTL(CGCTL) ALTRET(CGERR);
         CASE(%CGMONITOR#);  /* MONITOR Comgroup */
           IF F$DCB.AU# = %YES# THEN
               CALL CGMONITOR;
           ELSE
               CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG05));
            GOTO RD_AGIN;
         CASE(%CGCREATE#);
           IF F$DCB.FCD# THEN
               CALL M$CLOSE(CGCLS) ALTRET(CGERR);
           FIDFPT.TEXTFID_ = VECTOR(PARSOUT.SUBLK$(0)->PARSYM.TEXT);
           CALL M$FID(FIDFPT) ALTRET(CGERR);
           IF PARSOUT.NSUBLKS > 1 THEN DO;
           TBLK$ = BLK$;
               DO IX = 1 TO TBLK$->PARSOUT.NSUBLKS - 1;
                   BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
                   DO CASE(PARSOUT.CODE);
                     CASE(%LIXTNSIZE#);
                       SBLK$ = PARSOUT.SUBLK$(0);
                       CALL CHARBIN(DPARM1, SUBSTR(PARSYM.TEXT,,
                                                   PARSYM.COUNT));
                       CGOPN.V.IXTNSIZE# = DPARM1;
                     CASE(%LQISS#);
                       IF PARSOUT.SUBLK$(0)->PARSOUT.CODE = %LYEA# THEN
                           CGOPN.V.QISS# = %YES#;
                       ELSE
                           CGOPN.V.QISS# = %NO#;
                     CASE(%LORG#);
                       DO CASE(PARSOUT.SUBLK$(0)->PARSOUT.CODE);
                         CASE(%LCG#);
                           CGOPN.V.ORG# = 11;  /*  ORG=CG */
                         CASE(%LTERM#);
                           CGOPN.V.ORG# = 8;   /*  ORG=TERMINAL */
                           END;
                     CASE(%LEXIST#);
                       CGOPN.V.EXIST# = PARSOUT.SUBLK$(0)->PARSOUT.CODE-%LERR#+1;
                     CASE(%XSTANAME#);
                       SBLK$ = PARSOUT.SUBLK$(0);
                       VLP_SETSTA.MYSTATION# = SUBSTR(PARSYM.TEXT,,
                                                       PARSYM.COUNT);
                       END;
                   END;
               END;
           CGOPN.V.AU# = %YES#;
           VLP_SETSTA.MYSTATION# = ' ';
           CGOPN.V.FUN# = %CREATE#;
           CGOPN.V.CTG# = %YES#;
           CALL M$OPEN(CGOPN) ALTRET(CGERR);
           CGOPN.V.AU# = '01'B;
           CGOPN.V.FUN# = %IN#;
           CGOPN.V.EXIST# = 0;
           CGOPN.V.CTG# = '0'B;
           CGOPN.V.IXTNSIZE# = 0;
           CGOPN.V.ORG# = 0;
           CGOPN.V.QISS# = '01'B;
         CASE(%CGEXTEND#);
           IF F$DCB.FCD# THEN
               CALL M$CLOSE(CGCLS) ALTRET(CGERR);
           FIDFPT.TEXTFID_ = VECTOR(PARSOUT.SUBLK$(0)->PARSYM.TEXT);
           CALL M$FID(FIDFPT) ALTRET(CGERR);
           CALL CHARBIN(DPARM1, SUBSTR(PARSOUT.SUBLK$(1)->PARSYM.TEXT,,
                                       PARSOUT.SUBLK$(1)->PARSYM.COUNT));
           CGEXTEND.V.SIZ# = DPARM1;
           IF PARSOUT.NSUBLKS = 3 THEN
               VLP_SETSTA.MYSTATION# = SUBSTR(PARSOUT.SUBLK$(2)->PARSYM.TEXT,,
                                            PARSOUT.SUBLK$(2)->PARSYM.COUNT);
           CGOPN.V.AU# = %YES#;
           CGOPN.V.FUN# = %UPDATE#;
           CALL M$OPEN(CGOPN) ALTRET(CGERR);
           CALL M$EXTEND(CGEXTEND) ALTRET(CGERR);
           CGOPN.V.AU# = '01'B;
           CGOPN.V.FUN# = %IN#;
           VLP_SETSTA.MYSTATION# = ' ';
         END; /* END DO CASE(CODE) */
       WTIME = 0;
       LSTATS = INIT_LSTATS;
       GOTO RD_AGIN;
RD_ERR:    ;
       CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG02));
       GOTO RD_AGIN;
CGERR:     ;
       CALL M$ERRMSG(FPT_ERRMSG);
       CGOPN.V.FUN# = %IN#;
       CGOPN.V.EXIST# = 0;
       CGOPN.V.CTG# = '0'B;
       CGOPN.V.IXTNSIZE# = 0;
       CGOPN.V.QISS# = '01'B;
       CGOPN.V.ORG# = 0;
       WTIME=0;
       IF CODE = %CGDUMP# THEN DO;
           IF DUMP_STA.CTL.DIRONLY# = %YES# THEN
               CALL UN_CGU_HOLD;
           ELSE
               CALL M$FWCG(FWCG_DUMP) WHENALTRETURN DO; END;
           CALL M$CGCTL(CGCTL);
           END;
       GOTO RD_AGIN;
%EJECT;
MSGID_CHK: PROC(MSGID) ALTRET;
DCL    MSGID       UBIN;
/**/
       DO IX=0 TO MBLK$->PARSOUT.NSUBLKS - 1;
           BLK$ = MBLK$->PARSOUT.SUBLK$(IX);
           DO CASE(PARSOUT.CODE);
             CASE(%LM1#);
               SBLK$ = BLK$;
               CALL CHARBIN(DPARM4,
                            SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
               IF DPARM4 = MSGID THEN
                   RETURN;
             CASE(%LM2#);
               SBLK$ = PARSOUT.SUBLK$(0);
               CALL CHARBIN(DPARM4,
                            SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
               IF DPARM4 <= MSGID THEN
                   RETURN;
             CASE(%LM3#);
               SBLK$ = PARSOUT.SUBLK$(0);
               CALL CHARBIN(DPARM4,
                            SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
               SBLK$ = PARSOUT.SUBLK$(1);
               CALL CHARBIN(DPARM2,
                            SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
               IF DPARM4 <= MSGID &
                  DPARM2 >= MSGID THEN
                   RETURN;
             CASE(%LM4#);
               SBLK$ = PARSOUT.SUBLK$(0);
               CALL CHARBIN(DPARM4,
                            SUBSTR(PARSYM.TEXT,,PARSYM.COUNT));
               IF DPARM4 >= MSGID THEN
                   RETURN;
             END;
           END;
       ALTRETURN;
END MSGID_CHK;
%EJECT;
UN_CGU_HOLD:   ENTRY   ALTRET;
/**/
       CALL M$CLOSE(CGCLS);
       VLP_SETSTA.MYSTATION# = 'CGU_HOLD';
       CALL M$OPEN(CGOPN);
       DUMP_UNL.V.INPUT# = 3;  /* Rerun */
       DUMP_STA.CTL.DIRONLY# = '1'B;
       DO WHILE('1'B);
           CALL M$READ(DREAD) WHENALTRETURN DO;
               CALL M$CLOSE(CGCLS);
               VLP_SETSTA.MYSTATION# = MYSTATION;
               CALL M$OPEN(CGOPN);
               IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$EOF THEN
                   ALTRETURN;
               ELSE
                   RETURN;
               END;
           CALL M$UNLATCH(DUMP_UNL);
           END;
%EJECT;
CGCP_ALL:  PROC;
/* Output CGCP Parameters */
       CALL X$WRITE(FDS, VECTOR(FMT00),
                       VECTOR(TXT00));
       PARM1 = AUCON.TXT(CGINFO_CGCP.AUCONDCB#);
       PARM2 = AUCON.TXT(CGINFO_CGCP.AUCONTERM#);
       PARM3 = AUCON.TXT(CGINFO_CGCP.AUDCONDCB#);
       PARM4 = AUCON.TXT(CGINFO_CGCP.AUDCONTERM#);
       CALL X$WRITE(FDS, VECTOR(FMT01),
                        VECTOR(TXT01), VECTOR(PARM1),
                        VECTOR(TXT02), VECTOR(PARM2),
                        VECTOR(TXT03), VECTOR(PARM3),
                        VECTOR(TXT04), VECTOR(PARM4));
       IF CGINFO_CGCP.AUTORCVR# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.BIGMXT# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_CGCP.DVBYTE.BIN# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_CGCP.CARRYOSTA# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT01),
                       VECTOR(TXT05), VECTOR(PARM1),
                       VECTOR(TXT06), VECTOR(PARM2),
                       VECTOR(TXT07), VECTOR(PARM3),
                       VECTOR(TXT08), VECTOR(PARM4));
       IF CGINFO_CGCP.CONMSG# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       DPARM2 = CGINFO_CGCP.DATAPGS#;
       IF CGINFO_CGCP.DCBCONAU# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_CGCP.DCBCONLGL# = %YES# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT03),
                       VECTOR(TXT09), VECTOR(PARM1),
                       VECTOR(TXT10), VECTOR(DPARM2),
                       VECTOR(TXT11), VECTOR(PARM3),
                       VECTOR(TXT12), VECTOR(PARM4));
       IF CGINFO_CGCP.DCBCONNAU# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.DCBCONWA# = %YES#  THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       DPARM3 = CGINFO_CGCP.DEFERBLKS#;
       DPARM4 = CGINFO_CGCP.DISKWARN#;
       CALL X$WRITE(FDS, VECTOR(FMT04),
                       VECTOR(TXT13), VECTOR(PARM1),
                       VECTOR(TXT14), VECTOR(PARM2),
                       VECTOR(TXT15), VECTOR(DPARM3),
                       VECTOR(TXT16), VECTOR(DPARM4));
       IF CGINFO_CGCP.DMTYP# = ' ' THEN
           PARM8 = 'None';
       ELSE
           PARM8 = CGINFO_CGCP.DMTYP#;
       IF CGINFO_CGCP.DRML# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_CGCP.DSCREQ# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT05),
                       VECTOR(TXT17), VECTOR(PARM8),
                       VECTOR(TXT18), VECTOR(PARM2),
                       VECTOR(TXT19), VECTOR(PARM3),
                       VECTOR(TXT20), VECTOR(CGINFO_CGCP.DVBYTE));
       IF CGINFO_CGCP.INPUT# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.JOURNAL# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       DPARM3 = CGINFO_CGCP.MAXMC#;
       DPARM4 = CGINFO_CGCP.MAXPG#;
       CALL X$WRITE(FDS, VECTOR(FMT04),
                       VECTOR(TXT21), VECTOR(PARM1),
                       VECTOR(TXT22), VECTOR(PARM2),
                       VECTOR(TXT23), VECTOR(DPARM3),
                       VECTOR(TXT24), VECTOR(DPARM4));
       DPARM1 = CGINFO_CGCP.MEMWARN#;
       IF CGINFO_CGCP.MEMWARNP# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       DPARM3 = CGINFO_CGCP.MINPG#;
       DPARM4 = CGINFO_CGCP.MXACT#;
       CALL X$WRITE(FDS, VECTOR(FMT07),
                       VECTOR(TXT25), VECTOR(DPARM1),
                       VECTOR(TXT26), VECTOR(PARM2),
                       VECTOR(TXT27), VECTOR(DPARM3),
                       VECTOR(TXT28), VECTOR(DPARM4));
       IF CGINFO_CGCP.OUTPUT# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.QRML# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_CGCP.RAS# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_CGCP.REDUNDANT# = %YES# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT01),
                       VECTOR(TXT29), VECTOR(PARM1),
                       VECTOR(TXT30), VECTOR(PARM2),
                       VECTOR(TXT31), VECTOR(PARM3),
                       VECTOR(TXT32), VECTOR(PARM4));
       IF CGINFO_CGCP.DVBYTE.REREAD# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.SECURE# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_CGCP.SMD# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       DPARM4 = CGINFO_CGCP.STAPRIO#;
       CALL X$WRITE(FDS, VECTOR(FMT09),
                       VECTOR(TXT33), VECTOR(PARM1),
                       VECTOR(TXT34), VECTOR(PARM2),
                       VECTOR(TXT35), VECTOR(PARM3),
                       VECTOR(TXT36), VECTOR(DPARM4));
       IF CGINFO_CGCP.TERMCONAU# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_CGCP.TERMCONLGL# = %YES# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_CGCP.TERMCONNAU# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
           IF CGINFO_CGCP.TMTYP# = ' ' THEN
               PARM8 = 'None';
           ELSE
               PARM8 = CGINFO_CGCP.TMTYP#;
       CALL X$WRITE(FDS, VECTOR(FMT10),
                       VECTOR(TXT37), VECTOR(PARM1),
                       VECTOR(TXT38), VECTOR(PARM2),
                       VECTOR(TXT39), VECTOR(PARM3),
                       VECTOR(TXT40), VECTOR(PARM8));
       IF CGINFO_CGCP.DVBYTE.TRANS# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       DPARM2 = CGINFO_CGCP.TRMRDSIZ#;
       DPARM3 = CGINFO_CGCP.TYPPRIO#;
       IF CGINFO_CGCP.UNLAMSG# = %YES# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT11),
                       VECTOR(TXT41), VECTOR(PARM1),
                       VECTOR(TXT42), VECTOR(DPARM2),
                       VECTOR(TXT43), VECTOR(DPARM3),
                       VECTOR(TXT44), VECTOR(PARM4));
       IF CGINFO_CGCP.WAS# = %YES# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       DPARM2 = CGINFO_CGCP.WRITETIME#;
       IF CGINFO_CGCP.XSTALGL# = %YES# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_CGCP.XTYPLGL# = %YES# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT03),
                       VECTOR(TXT45), VECTOR(PARM1),
                       VECTOR(TXT46), VECTOR(DPARM2),
                       VECTOR(TXT47), VECTOR(PARM3),
                       VECTOR(TXT475), VECTOR(PARM4));
       IF CGINFO_HOLDSTA.STATION# = ' ' THEN
           PARM7 = 'None';
       ELSE
           PARM7 = CGINFO_HOLDSTA.STATION#;
       IF CGINFO_JRNLSTA.STATION# = ' ' THEN
           PARM8 = 'None';
       ELSE
           PARM8 = CGINFO_JRNLSTA.STATION#;
       IF CGINFO_JRNLFID.L# = 0 THEN
           FIDPARM  = ' None';
       ELSE
           FIDPARM = CGINFO_JRNLFID.JRNLFID#;
       CALL X$WRITE(FDS, VECTOR(FMT32),
                       VECTOR(TXT77), VECTOR(PARM7),
                       VECTOR(TXT78), VECTOR(PARM8),
                       VECTOR(TXT79),
                       VECTOR(SUBSTR(FIDPARM, 0, CGINFO_JRNLFID.L#)));
       CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(TXT59));
       IF CGINFO_SETSTA.OSTA.ALLABSENT# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_SETSTA.OSTA.ALLDCBS# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_SETSTA.OSTA.ALLTRMS# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_SETSTA.OSTA.ANYDCB# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT01),
                         VECTOR(TXT60), VECTOR(PARM1),
                         VECTOR(TXT61), VECTOR(PARM2),
                         VECTOR(TXT62), VECTOR(PARM3),
                         VECTOR(TXT63), VECTOR(PARM4));
       IF CGINFO_SETSTA.ISTA.DIRONLY# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_SETSTA.ISTA.EOFNONE# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_SETSTA.ISTA.EOFONE# THEN
           PARM3 = ' YES';
       ELSE
           PARM3 = '  NO';
       IF CGINFO_SETSTA.ISTA.ILATCH# THEN
           PARM4 = ' YES';
       ELSE
           PARM4 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT01),
                         VECTOR(TXT64), VECTOR(PARM1),
                         VECTOR(TXT65), VECTOR(PARM2),
                         VECTOR(TXT66), VECTOR(PARM3),
                         VECTOR(TXT67), VECTOR(PARM4));
       IF CGINFO_SETSTA.ISTA.ILOCK# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_SETSTA.ISTA.IMSGTYP# = ' ' THEN
           PARM6 = 'None';
       ELSE
           PARM6 = CGINFO_SETSTA.ISTA.IMSGTYP#;
       IF CGINFO_SETSTA.ISTA.ISTATION# = ' ' THEN
           PARM7 = 'None';
       ELSE
           PARM7 = CGINFO_SETSTA.ISTA.ISTATION#;
       IF CGINFO_SETSTA.MYSTATION# = ' ' THEN
           PARM8 = 'None';
       ELSE
           PARM8 = CGINFO_SETSTA.MYSTATION#;
       CALL X$WRITE(FDS, VECTOR(FMT01),
                         VECTOR(TXT68), VECTOR(PARM1),
                         VECTOR(TXT69), VECTOR(PARM6),
                         VECTOR(TXT70), VECTOR(PARM7),
                         VECTOR(TXT71), VECTOR(PARM8));
       IF CGINFO_SETSTA.OSTA.OLATCH# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       IF CGINFO_SETSTA.OSTA.OLOCK# THEN
           PARM2 = ' YES';
       ELSE
           PARM2 = '  NO';
       IF CGINFO_SETSTA.OSTA.OMSGTYP# = ' ' THEN
           PARM7 = 'None';
       ELSE
           PARM7 = CGINFO_SETSTA.OSTA.OMSGTYP#;
       IF CGINFO_SETSTA.OSTA.OSTATION# = ' ' THEN
           PARM8 = 'None';
       ELSE
           PARM8 = CGINFO_SETSTA.OSTA.OSTATION#;
       CALL X$WRITE(FDS, VECTOR(FMT01),
                         VECTOR(TXT72), VECTOR(PARM1),
                         VECTOR(TXT73), VECTOR(PARM2),
                         VECTOR(TXT74), VECTOR(PARM7),
                         VECTOR(TXT75), VECTOR(PARM8));
       IF CGINFO_SETSTA.OSTA.WAS# THEN
           PARM1 = ' YES';
       ELSE
           PARM1 = '  NO';
       CALL X$WRITE(FDS, VECTOR(FMT26), VECTOR(TXT76), VECTOR(PARM1));
       RETURN;
END CGCP_ALL;
%EJECT;
CGCP_SUB:  PROC;
%VLP_VECTOR(FPTN=TXTVECT);
DCL    PARM1       CHAR(8);
DCL    DPARM1      UBIN;
/* Output a selected subset of CGCP parameters */
       TBLK$ = BLK$;
       DO IX=0 TO TBLK$->PARSOUT.NSUBLKS-1;
           BLK$ = TBLK$->PARSOUT.SUBLK$(IX);
           PARM1 = 'NO';
           DO CASE(PARSOUT.CODE);
             CASE(%LAUCONDCB#);
               PARM1 = AUCON.TXT(CGINFO_CGCP.AUCONDCB#);
               TXTVECT = VECTOR(TXT01);
             CASE(%LAUCONTERM#);
               PARM1 = AUCON.TXT(CGINFO_CGCP.AUCONTERM#);
               TXTVECT = VECTOR(TXT02);
             CASE(%LAUDCONDCB#);
               PARM1 = AUCON.TXT(CGINFO_CGCP.AUDCONDCB#);
               TXTVECT = VECTOR(TXT03);
             CASE(%LAUDCONTERM#);
               PARM1 = AUCON.TXT(CGINFO_CGCP.AUDCONTERM#);
               TXTVECT = VECTOR(TXT04);
             CASE(%LAUTORCVR#);
               IF CGINFO_CGCP.AUTORCVR# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT05);
             CASE(%LBIGMXT#);
               IF CGINFO_CGCP.BIGMXT# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT06);
             CASE(%LBIN#);
               IF CGINFO_CGCP.DVBYTE.BIN# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT07);
             CASE(%LCARRYOSTA#);
               IF CGINFO_CGCP.CARRYOSTA# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT08);
             CASE(%LCONMSG#);
               IF CGINFO_CGCP.CONMSG# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT09);
             CASE(%LDATAPGS#);
               DPARM1 = CGINFO_CGCP.DATAPGS#;
               TXTVECT = VECTOR(TXT10);
             CASE(%LDCBCONAU#);
               IF CGINFO_CGCP.DCBCONAU# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT11);
             CASE(%LDCBCONLGL#);
               IF CGINFO_CGCP.DCBCONLGL# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT12);
             CASE(%LDCBCONNAU#);
               IF CGINFO_CGCP.DCBCONNAU# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT13);
             CASE(%LDCBCONWA#);
               IF CGINFO_CGCP.DCBCONWA# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT14);
             CASE(%LDEFERBLKS#);
               DPARM1 = CGINFO_CGCP.DEFERBLKS#;
               TXTVECT = VECTOR(TXT15);
             CASE(%LDISKWARN#);
               DPARM1 = CGINFO_CGCP.DISKWARN#;
               TXTVECT = VECTOR(TXT16);
             CASE(%LDMTYP#);
               IF CGINFO_CGCP.DMTYP# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_CGCP.DMTYP#;
               TXTVECT = VECTOR(TXT17);
             CASE(%LDRML#);
               IF CGINFO_CGCP.DRML# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT18);
             CASE(%LDSCREQ#);
               IF CGINFO_CGCP.DSCREQ# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT19);
             CASE(%LDVBYTE#);
               TXTVECT = VECTOR(TXT20);
             CASE(%LINPUT#);
               IF CGINFO_CGCP.INPUT# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT21);
             CASE(%LJOURNAL#);
               IF CGINFO_CGCP.JOURNAL# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT22);
             CASE(%LMAXMC#);
               DPARM1 = CGINFO_CGCP.MAXMC#;
               TXTVECT = VECTOR(TXT23);
             CASE(%LMAXPG#);
               DPARM1 = CGINFO_CGCP.MAXPG#;
               TXTVECT = VECTOR(TXT24);
             CASE(%LMEMWARN#);
               DPARM1 = CGINFO_CGCP.MEMWARN#;
               TXTVECT = VECTOR(TXT25);
             CASE(%LMEMWARNP#);
               IF CGINFO_CGCP.MEMWARNP# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT26);
             CASE(%LMINPG#);
               DPARM1 = CGINFO_CGCP.MINPG#;
               TXTVECT = VECTOR(TXT27);
             CASE(%LMXACT#);
               DPARM1 = CGINFO_CGCP.MXACT#;
               TXTVECT = VECTOR(TXT28);
             CASE(%LOUTPUT#);
               IF CGINFO_CGCP.OUTPUT# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT29);
             CASE(%LQRML#);
               IF CGINFO_CGCP.QRML# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT30);
             CASE(%LRAS#);
               IF CGINFO_CGCP.RAS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT31);
             CASE(%LREDUNDANT#);
               IF CGINFO_CGCP.REDUNDANT# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT32);
             CASE(%LREREAD#);
               IF CGINFO_CGCP.DVBYTE.REREAD# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT33);
             CASE(%LSECURE#);
               IF CGINFO_CGCP.SECURE# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT34);
             CASE(%LSMD#);
               IF CGINFO_CGCP.SMD# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT35);
             CASE(%LSTAPRIO#);
               DPARM1 = CGINFO_CGCP.STAPRIO#;
               TXTVECT = VECTOR(TXT36);
             CASE(%LTERMCONAU#);
               IF CGINFO_CGCP.TERMCONAU# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT37);
             CASE(%LTERMCONLGL#);
               IF CGINFO_CGCP.TERMCONLGL# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT38);
             CASE(%LTERMCONNAU#);
               IF CGINFO_CGCP.TERMCONNAU# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT39);
             CASE(%LTMTYP#);
               IF CGINFO_CGCP.TMTYP# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_CGCP.TMTYP#;
               TXTVECT = VECTOR(TXT40);
             CASE(%LTRANS#);
               IF CGINFO_CGCP.DVBYTE.TRANS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT41);
             CASE(%LTRMRDSIZ#);
               DPARM1 = CGINFO_CGCP.TRMRDSIZ#;
               TXTVECT = VECTOR(TXT42);
             CASE(%LTYPPRIO#);
               DPARM1 = CGINFO_CGCP.TYPPRIO#;
               TXTVECT = VECTOR(TXT43);
             CASE(%LUNLAMSG#);
               IF CGINFO_CGCP.UNLAMSG# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT44);
             CASE(%LWAS#);
               IF CGINFO_CGCP.WAS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT45);
             CASE(%LWRITETIME#);
               DPARM1 = CGINFO_CGCP.WRITETIME#;
               TXTVECT = VECTOR(TXT46);
             CASE(%LXSTALGL#);
               IF CGINFO_CGCP.XSTALGL# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT47);
             CASE(%LXTYPLGL#);
               IF CGINFO_CGCP.XTYPLGL# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT475);
             CASE(%LALLABSENT#);
               IF CGINFO_SETSTA.OSTA.ALLABSENT# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT60);
             CASE(%LALLDCBS#);
               IF CGINFO_SETSTA.OSTA.ALLDCBS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT61);
             CASE(%LALLTRMS#);
               IF CGINFO_SETSTA.OSTA.ALLTRMS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT62);
             CASE(%LANYDCB#);
               IF CGINFO_SETSTA.OSTA.ANYDCB# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT63);
             CASE(%LDIRONLY#);
               IF CGINFO_SETSTA.ISTA.DIRONLY# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT64);
             CASE(%LEOFNONE#);
               IF CGINFO_SETSTA.ISTA.EOFNONE# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT65);
             CASE(%LEOFONE#);
               IF CGINFO_SETSTA.ISTA.EOFONE# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT66);
             CASE(%LILATCH#);
               IF CGINFO_SETSTA.ISTA.ILATCH# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT67);
             CASE(%LILOCK#);
               IF CGINFO_SETSTA.ISTA.ILOCK# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT68);
             CASE(%LIMSGTYP#);
               IF CGINFO_SETSTA.ISTA.IMSGTYP# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_SETSTA.ISTA.IMSGTYP#;
               TXTVECT = VECTOR(TXT69);
             CASE(%LISTATION#);
               IF CGINFO_SETSTA.ISTA.ISTATION# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_SETSTA.ISTA.ISTATION#;
               TXTVECT = VECTOR(TXT70);
             CASE(%LMYSTATION#);
               IF CGINFO_SETSTA.MYSTATION# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_SETSTA.MYSTATION#;
               TXTVECT = VECTOR(TXT71);
             CASE(%LOLATCH#);
               IF CGINFO_SETSTA.OSTA.OLATCH# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT72);
             CASE(%LOLOCK#);
               IF CGINFO_SETSTA.OSTA.OLOCK# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT73);
             CASE(%LOMSGTYP#);
               IF CGINFO_SETSTA.OSTA.OMSGTYP# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_SETSTA.OSTA.OMSGTYP#;
               TXTVECT = VECTOR(TXT74);
             CASE(%LOSTATION#);
               IF CGINFO_SETSTA.OSTA.OSTATION# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_SETSTA.OSTA.OSTATION#;
               TXTVECT = VECTOR(TXT75);
             CASE(%LSETSTAWAS#);
               IF CGINFO_SETSTA.OSTA.WAS# THEN
                   PARM1 = 'YES';
               TXTVECT = VECTOR(TXT76);
             CASE(%LHOLDSTA#);
               IF CGINFO_HOLDSTA.STATION# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_HOLDSTA.STATION#;
               TXTVECT = VECTOR(TXT77);
             CASE(%LJRNLSTA#);
               IF CGINFO_JRNLSTA.STATION# = ' ' THEN
                   PARM1 = 'None';
               ELSE
                   PARM1 = CGINFO_JRNLSTA.STATION#;
               TXTVECT = VECTOR(TXT78);
             CASE(%LJRNLFID#);
               IF CGINFO_JRNLFID.L# = 0 THEN
                   FIDPARM = 'None';
               ELSE
                   FIDPARM = SUBSTR(CGINFO_JRNLFID.JRNLFID#, 0,
                                    CGINFO_JRNLFID.L#);
               TXTVECT = VECTOR(TXT79);
             END;
           DO CASE(PARSOUT.CODE);
             CASE(%LDATAPGS#, %LDEFERBLKS#, %LDISKWARN#, %LMAXMC#,
                  %LMAXPG#, %LMEMWARN#, %LMINPG#, %LMXACT#, %LSTAPRIO#,
                  %LTRMRDSIZ#, %LTYPPRIO#, %LWRITETIME#);
               CALL X$WRITE(FDS, VECTOR(FMT24), TXTVECT, VECTOR(DPARM1));
             CASE(%LDVBYTE#);
               CALL X$WRITE(FDS, VECTOR(FMT25), TXTVECT,
                            VECTOR(CGINFO_CGCP.DVBYTE));
             CASE(%LJRNLFID#);
               CALL X$WRITE(FDS, VECTOR(FMT23), TXTVECT, VECTOR(FIDPARM));
             CASE(ELSE);
               CALL X$WRITE(FDS, VECTOR(FMT23), TXTVECT, VECTOR(PARM1));
             END;
           END; /* END DO IX */
       RETURN;
END CGCP_SUB;
%EJECT;
CGMESS:    PROC;
DCL    MSGTYP      CHAR(8);
/**/
       CALL M$FWCG(FWCG) ALTRET(FWCG_ERR);
       IF VLR_FWCG.FOUND# = 0 THEN DO;
           CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG04));
           RETURN;
           END;
       MSGRD.BUF_ = VECTOR(B$CGAURD);
       MSGRD.V.DVBYTE.CONT# = %NO#;
       CALL M$READ(MSGRD) ALTRET(IGNORE);
IGNORE:    ;
       IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$LD THEN
           GOTO FWCG_ERR;
       CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(TXT55));
       CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(TXT56));
       MSGRD.BUF_ = VECTOR(CGM);
       MSGRD.V.DVBYTE.CONT# = %YES#;
       MSGTYP = ' ';
       DPARM1 = 0;
       DO WHILE('1'B);
           CALL M$READ(MSGRD) ALTRET(CGREAD_ERR);
           DPARM1 = 1;  /*  Indicate that we didn't ALTRET  */
           GOTO CGMESS_FMT;
CGREAD_ERR:    ;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$EOF THEN
               GOTO CGMESS_END;
           IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE ~= %E$LD THEN
               GOTO FWCG_ERR;
CGMESS_FMT:    ;
           IF MSGIDS THEN
               CALL MSGID_CHK(CGM.MSGID#) ALTRET(CGMESS_NEXT);
           IF CODE = %CGDELETE# THEN DO;
               VLP_CGMA.MSGID# = CGM.MSGID#;
               CALL M$FWCG(FWCG) ALTRET(FWCG_ERR);
               GOTO CGMESS_NEXT;
               END;
           IF CGM.MSGTYP# = MSGTYP THEN
               CALL X$WRITE(FDS, VECTOR(FMT21), VECTOR(CGM.PRIO#),
                       VECTOR(CGM.MSGID#), VECTOR(CGM.DEST#),
                       VECTOR(CGM.ORIGIN#), VECTOR(CGM.MSGSIZE#),
                       VECTOR(CGM.UTS#));
           ELSE DO;
               MSGTYP = CGM.MSGTYP#;
               DO IX = CGINFO_TYPLIST.FOUND#-1 DOWNTO 0 BY -1;
                   IF CGINFO_TYPLIST.LIST.NAME#(IX) = MSGTYP THEN
                       GOTO CGMESS_FOUND;
                   END;
CGMESS_FOUND:  ;
               CALL X$WRITE(FDS, VECTOR(FMT20), VECTOR(CGM.MSGTYP#),
                       VECTOR(CGINFO_QLIST.LIST.CNACT#(IX)), VECTOR(CGINFO_QLIST.LIST.MSGCNT#(IX)),
                       VECTOR(CGINFO_QLIST.LIST.MXACT#(IX)), VECTOR(CGM.PRIO#),
                       VECTOR(CGM.MSGID#), VECTOR(CGM.DEST#), VECTOR(CGM.ORIGIN#),
                       VECTOR(CGM.MSGSIZE#), VECTOR(CGM.UTS#));
               END;
CGMESS_NEXT:   ;
           IF DPARM1 = 1 THEN
               GOTO CGMESS_END;
           END;
CGMESS_END:    ;
       RETURN;
FWCG_ERR:      ;
       CALL M$ERRMSG(FPT_ERRMSG);
       RETURN;
END CGMESS;
%EJECT;
STALIST:   PROC;
DCL    SKFLG       UBIN;
/* Output Station List */
RPT_STALIST:   ;
       IF CGINFO_STALIST.FOUND# = 0 THEN DO;
NONE_THERE:    ;
           CALL X$WRITE(FDS, VECTOR(FMT00), VECTOR(EMSG03));
           GOTO PASS_USR_REPORT;
           END;
       IF STATION = ' ' THEN DO;
           SKFLG = 1;
           CALL X$WRITE(FDS, VECTOR(FMT13),
                           VECTOR(TXT48), VECTOR(TXT49));
           END;
       ELSE
           SKFLG = 0;
       DO IX = CGINFO_STALIST.FOUND# - 1 DOWNTO 0 BY -1;
           IF STATION ~= ' ' THEN DO;
               IF STATION = CGINFO_STALIST.LIST.NAME#(IX) THEN DO;
                   CALL X$WRITE(FDS, VECTOR(FMT13),
                                   VECTOR(TXT48), VECTOR(TXT49));
                   SKFLG = 1;
                   END;
               ELSE
                   GOTO SKIP;
               END;
           DPARM1 = CGINFO_STALIST.LIST.READS(IX);
           DPARM2 = CGINFO_STALIST.LIST.WRITES(IX);
           DPARM3 = CGINFO_STALIST.LIST.PRIO#(IX);
           DPARM4 = CGINFO_STALIST.LIST.MSGCNT#(IX);
           YNS = 'NNNN';
           IF CGINFO_STALIST.LIST.ACTIVE#(IX) = %YES# THEN
               YN.V(0) = 'Y';
           IF CGINFO_STALIST.LIST.CON#(IX) = %YES# THEN
               YN.V(1) = 'Y';
           IF CGINFO_STALIST.LIST.PERM#(IX) = %YES# THEN
               YN.V(2) = 'Y';
           IF CGINFO_STALIST.LIST.AUP#(IX) = %YES# THEN
               YN.V(3) = 'Y';
           CALL X$WRITE(FDS, VECTOR(FMT14),
                           VECTOR(CGINFO_STALIST.LIST.NAME#(IX)),
                           VECTOR(DPARM1), VECTOR(DPARM2), VECTOR(DPARM3),
                           VECTOR(DPARM4), VECTOR(YNS));
SKIP:  ;
           END;
       IF SKFLG = 0 THEN
           GOTO NONE_THERE;
PASS_USR_REPORT:   ;
       IF WTIME ~= 0 & CODE = %CGUSERS# THEN DO;
           CALL M$WAIT(WFPT);
           CALL M$CGINFO(CGINFO);
           GOTO RPT_STALIST;
           END;
   RETURN;
END STALIST;
%EJECT;
CGSTATS:   PROC;
/*     Output Comgroup Statistics */
       CALL X$WRITE(FDS, VECTOR(FMT00),
                       VECTOR(TXT50));
       CALL X$WRITE(FDS, VECTOR(FMT15));
       CALL X$WRITE(FDS, VECTOR(FMT16));
       CALL X$WRITE(FDS, VECTOR(FMT17));
RPT_CGSTATS:   ;
       CALL X$WRITE(FDS, VECTOR(FMT18),
                   VECTOR(CGINFO_STATS.READS), VECTOR(LSTATS.READS),
                   VECTOR(CGINFO_STATS.WRITES), VECTOR(LSTATS.WRITES),
                   VECTOR(CGINFO_STATS.GETS), VECTOR(LSTATS.GETS),
                   VECTOR(CGINFO_STATS.PUTS), VECTOR(LSTATS.PUTS),
                   VECTOR(CGINFO_STATS.DISCRDS), VECTOR(LSTATS.DISCRDS),
                   VECTOR(CGINFO_STATS.DISCWRS), VECTOR(LSTATS.DISCWRS),
                   VECTOR(CGINFO_STATS.NODFRS), VECTOR(LSTATS.NODFRS),
                   VECTOR(CGINFO_STATS.GARBCOLLS),
                   VECTOR(LSTATS.GARBCOLLS));
       CALL X$WRITE(FDS, VECTOR(FMT19),
                       VECTOR(TXT51), VECTOR(CGINFO_STATS.NUMDCBS),
                       VECTOR(TXT52), VECTOR(CGINFO_STATS.NUMTERMS),
                       VECTOR(TXT53), VECTOR(CGINFO_STATS.CCMQ),
                       VECTOR(TXT54), VECTOR(CGINFO_STATS.CCMS));
       IF WTIME ~= 0 & CODE = %CGSTATS# THEN DO;
           WFPT.V.UNITS# = WTIME;
           CALL M$WAIT(WFPT);
           LSTATS = CGINFO_STATS;
           CALL M$CGINFO(CGINFO);
           LSTATS.READS = CGINFO_STATS.READS - LSTATS.READS;
           LSTATS.WRITES = CGINFO_STATS.WRITES - LSTATS.WRITES;
           LSTATS.GETS = CGINFO_STATS.GETS - LSTATS.GETS;
           LSTATS.PUTS = CGINFO_STATS.PUTS - LSTATS.PUTS;
           LSTATS.DISCRDS = CGINFO_STATS.DISCRDS - LSTATS.DISCRDS;
           LSTATS.DISCWRS = CGINFO_STATS.DISCWRS - LSTATS.DISCWRS;
           LSTATS.GARBCOLLS = CGINFO_STATS.GARBCOLLS - LSTATS.GARBCOLLS;
           LSTATS.NODFRS = CGINFO_STATS.NODFRS - LSTATS.NODFRS;
           GOTO RPT_CGSTATS;
           END;
       RETURN;
END CGSTATS;
%EJECT;
CGMONITOR:     PROC;
%B$CGAUCRD(FPTN=AUCRD, STCLASS=STATIC);
%FPT_READ(FPTN=RFPT, DCB=M$CG, BUF=AUCRD, WAIT=YES, STATION=VLP_STATION);
%VLP_STATION(DIRONLY=YES, ALLTRMS=YES, STATION='?', EOFNONE=NO);
DCL    EVENT   CHAR(16);
DCL    REASON  CHAR(8);
/**/
       DO WHILE('1'B);
           CALL M$READ(RFPT) ALTRET(RD_ERR);
           REASON = ' ';
           DO CASE(AUCRD.EVENT);
             CASE(%CG_DOPN#);
               EVENT = 'DCB Open------->';
             CASE(%CG_DCLS#);
               EVENT = 'DCB Close------>';
             CASE(%CG_TCON#);
               EVENT = 'Term Connect--->';
             CASE(%CG_TDSC#);
               EVENT = 'Term Disconnect>';
             CASE(%CG_FWCG#);
               EVENT = 'M$FWCG Message->';
             CASE(%CG_TBRK#);
               EVENT = 'Term Break----->';
               DO CASE(AUCRD.INFO);
                 CASE(%CG_TBRK_BRK#);
                   REASON = '<>BRK';
                 CASE(%CG_TBRK_EC#);
                   REASON = '<>Yc';
                 CASE(%CG_TBRK_RDY#);
                   REASON = '<>In RDY';
                 END;
             CASE(%CG_WARN#);
               IF AUCRD.INFO = %CG_WARN_MEM# THEN
                   CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(TXT57));
               ELSE
                   CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(TXT58));
               GOTO CGMON_LOOP;
             END;
           CALL X$WRITE(FDS, VECTOR(FMT22), VECTOR(EVENT),
                   VECTOR(AUCRD.STATION), VECTOR(AUCRD.CGAUCI.SYSID),
                   VECTOR(AUCRD.CGAUCI.WHO.ACCT),
                   VECTOR(AUCRD.CGAUCI.WHO.NAME), VECTOR(REASON));
CGMON_LOOP:    ;
           END;
RD_ERR:    ;
       IF B$TCB.ALT$->B$ALT.ERR.ERR# = %E$EOF THEN
           CALL X$WRITE(FDS, VECTOR(FMTERR), VECTOR(EMSG06));
            CALL M$ERRMSG(FPT_ERRMSG);
       RETURN;
END CGMONITOR;
END CGU;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
XCON_RTN:  PROC    ASYNC;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%FPT_FWCG(FPTN=FWCG_DUMP, DCB=M$CG,
                          CRITERIA=VLP_CGMA_DUMP,
                          QSELECT=DIRECT,
                          SCA=VLP_SCGMA_DUMP,
                          REATTR=VLP_CGMA_REATTR,
                          SRA=VLP_SCGMA_DUMP, STCLASS=SYMREF);
%VLP_CGMA(FPTN=VLP_CGMA_DUMP, STCLASS=SYMREF);
%VLP_SCGMA(FPTN=VLP_SCGMA_DUMP, STCLASS=SYMREF);
%VLP_CGMA(FPTN=VLP_CGMA_REATTR, STCLASS=SYMREF);
%VLP_STATION(FPTN=DUMP_STA, STCLASS=SYMREF);
%FPT_CGCTL(FPTN=CGCTL, DCB=M$CG,
                       CGCP=CGINFO_CGCP,
                       SETSTA=CGINFO_SETSTA,
                       HOLDSTA=CGINFO_HOLDSTA, STCLASS=SYMREF);
%VLP_STATION(FPTN=CGINFO_HOLDSTA, STCLASS=SYMREF);
DCL    UN_CGU_HOLD ENTRY ALTRET;
DCL    CODE        UBIN SYMREF;
DCL    CGU_READ    REMEMBER SYMREF;
DCL    ENTRY_FLAG  UBIN;
%EQU   CGDUMP#     = 116;
/**/
       ENTRY_FLAG = 1;
XCON_RTN0: ;
       IF CODE = %CGDUMP# THEN DO;
           IF DUMP_STA.CTL.DIRONLY# = %YES# THEN
               CALL UN_CGU_HOLD;
           ELSE
               CALL M$FWCG(FWCG_DUMP) WHENALTRETURN DO; END;
           IF CGINFO_HOLDSTA.STATION# = ' ' THEN
               CGCTL.HOLDSTA_ = VECTOR(ERASE);
           ELSE
               CGCTL.HOLDSTA_ = VECTOR(CGINFO_HOLDSTA);
           CALL M$CGCTL(CGCTL);
           END;
       IF ENTRY_FLAG = 1 THEN
           CALL M$EXIT;
       ELSE
           UNWIND TO CGU_READ;
CGU_INT:   ENTRY;
       ENTRY_FLAG = 2;
       GOTO XCON_RTN0;
END XCON_RTN;
