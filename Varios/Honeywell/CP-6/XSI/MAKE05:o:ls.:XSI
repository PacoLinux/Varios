

rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=1  
A        1         1             /*M*    make_files  --    Routines to manage files                  */
A        2         2             /*T***********************************************************/
A        3         3             /*T*                                                         */
A        4         4             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
A        5         5             /*T*                                                         */
A        6         6             /*T***********************************************************/
A        7         7
A        8         8             #include   "MAKE_Cc13"
A        9         9             #include   "MAKE_Cc14"
A       10        10             #include   <stdlib.h>
A       11        11             #include   <stdio.h>
A       12        12             #include   <fileinfo.h>
A       13        13             #include   <string.h>
A       14        14
A       15        15             static char tbuf[80];
A       16        16
A       17        17             /*D*    NAME:       fid_acct(fid)
A       18        18                     PURPOSE:    To return the account portion of the input fid.
A       19        19             */
A       20        20             char *
A       21        21             fid_acct(fid)
A       22        22               char  *fid;
A       23        23             {
A       24        24    1          static char    acct[8];
A       25        25    1          int            i = 0;
A       26        26    1          int            w = 0;
A       27        27    1
A       28        28    1          memcpy(acct,"        ",8);
A       29        29    1          while (*fid && *fid != '.')   fid++;
A       30        30    1          if (!*fid) return acct;
A       31        31    1          while (*++fid && *fid != '.' && *fid != ' ') {
A       32        32    2             if (i > 8) w++;
A       33        33    2             else acct[i++] = *fid;
A       34        34    2             }
A       35        35    1          return acct;
A       36        36    1        }
A       37        37
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=2  
A       38        38
A       39        39             /*D*    NAME:       fid_filename(fid)
A       40        40                     PURPOSE:    To return the filename portion of the input fid.
A       41        41             */
A       42        42
A       43        43             char *
A       44        44             fid_filename(fid)
A       45        45               char  *fid;
A       46        46             {
A       47        47    1          static char    filename[32];
A       48        48    1          int            i = 0;
A       49        49    1
A       50        50    1          while (*fid && *fid != '.')
A       51        51    1             if (i <= 31)
A       52        52    1                filename[i++] = *fid++;
A       53        53    1             else break;
A       54        54    1          filename[i] = 0;
A       55        55    1          return filename;
A       56        56    1        }
A       57        57
A       58        58
A       59        59
A       60        60             /*D*    NAME:       build_acct_list(buf,blen)
A       61        61                     PURPOSE:    To build an account list structure from an
A       62        62                                 input string.
A       63        63             */
A       64        64
A       65        65             struct acct_list *
A       66        66             build_acct_list(buf, blen)
A       67        67               char        *buf;
A       68        68               int          blen;
A       69        69             {
A       70        70    1          struct acct_list  *ap       = 0;
A       71        71    1          unsigned          apsize    = sizeof(struct acct_list) - 8;
A       72        72    1          int               Naccts    = 0;
A       73        73    1          int               Raccts    = 0;
A       74        74    1          int               i         = 0, j = 0, w = 0;
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=3  
A       75        75    1          int               more      = 40;   /* 5 more accts */
A       76        76    1          char              *b        = buf;
A       77        77    1          char              *Iaccts   = 0;
A       78        78    1          char              *AcctList = 0;
A       79        79    1          int                c;
A       80        80    1
A       81        81    1          while (i < blen)  {
A       82        82    2             while (buf[i] == ' ' && i < blen) i++;
A       83        83    2
A       84        84    2             if (i < blen)  {
A       85        85    3                Naccts++;
A       86        86    3                if (Naccts > Raccts) {  /*  Need to alloc more space  */
A       87        87    4                   if (Raccts == 0)
A       88        88    4                      ap = (struct acct_list *)malloc(apsize += more);
A       89        89    4                   else ap = (struct acct_list *)realloc(ap, apsize += more);
A       90        90    4                   if (!ap) crash("Out of Memory: files");
A       91        91    4                   b = (char *) ap;
A       92        92    4                   Raccts += (more >> 3);
A       93        93    4                   AcctList = b+(sizeof(struct acct_list)-sizeof(struct vlp_acct));
A       94        94    4                   Iaccts   = AcctList + ((Naccts - 1)<<3);
A       95        95    4                   }
A       96        96    3                else Iaccts += 8;
A       97        97    3
A       98        98    3                if (buf[i]=='.') ++i;
A       99        99    3                j = 0;
A      100       100    3                while (i < blen && (c = buf[i]) != ' ' && c != '.') {
A      101       101    4                   if (j < 8) Iaccts[j++] = (c == 128)? '$' : c;
A      102       102    4                   else w++, j++;
A      103       103    4                   i++;
A      104       104    4                   }
A      105       105    3
A      106       106    3                while (j < 8) Iaccts[j++] = ' ';
A      107       107    3                if (buf[i] == '.') i++;
A      108       108    3                }  /* Of: if (i < blen)...    */
A      109       109    2             }     /* Of: while (i < blen)... */
A      110       110    1
A      111       111    1          if (Naccts < Raccts)
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=4  
A      112       112    1             ap = (struct acct_list *)realloc(ap, apsize=(apsize-(Raccts-Naccts)<<3));
A
A      113       113    1          if (ap) {
A      114       114    2             ap->naccts = Naccts;
A      115       115    2             mem_acctlist[0] += apsize;
A      116       116    2             mem_acctlist[1]++;
A      117       117    2             }
A      118       118    1          return ap;
A      119       119    1        }
A      120       120
A      121       121
A      122       122
A      123       123
A      124       124
A      125       125
A      126       126             /*D*    NAME:          setup_srch_lists()
A      127       127                     PURPOSE:       To setup the search accounts for SI, UI,
A      128       128                                 OU and GN accounts.  This is VERY CP-6ish.
A      129       129                     DESCRIPTION:
A      130       130                        The following variables are setup:  srch_lists[0..3]
A      131       131                        which is an array of pointers to struct acct_list, and
A      132       132                        srch_roots[0..3] which is an array of pointers to
A      133       133                        struct vlp_acct.
A      134       134             */
A      135       135
A      136       136             void
A      137       137             setup_srch_lists()  {
A      138       138    1          int   i;
A      139       139    1          struct sym_macro  *sm = sym_macro_specials[MI_SPATHS];
A      140       140    1          int                sl = sm->mc_deflen;
A      141       141    1          char              *st = sm->mc_def;
A      142       142    1
A      143       143    1          for (i = MI_SIPATH ; i<MI_LOPATH ; i++)  {
A      144       144    2             struct sym_macro *mc = sym_macro_specials[i];
A      145       145    2             struct acct_list *al = build_acct_list(mc->mc_def,mc->mc_deflen);
A      146       146    2             srch_roots[i-MI_SIPATH] = (al && al->naccts>1) ? al->accts : 0;
A      147       147    2             srch_lists[i-MI_SIPATH] = al;
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=5  
A      148       148    2             }
A      149       149    1
A      150       150    1          if (SIPATH != 0 && UIPATH != 0 && memcmp(SIROOT1,UIROOT1,8) != 0)
A      151       151    1             TryUIp++;
A      152       152    1
A      153       153    1          Allow_h_h = (SIPATH && OUPATH && memcmp(SIROOT1,OUROOT1,8) != 0);
A      154       154    1
A      155       155    1          i = 0;
A      156       156    1          while (i < sl && srch_num < 10)  {
A      157       157    2             char  vbuf[80];
A      158       158    2             int   j = 0;
A      159       159    2             struct sym_macro *mc;
A      160       160    2             while (i<sl && st[i] == ' ') i++;
A      161       161    2             while (i<sl && st[i] != ' ')
A      162       162    2                if (j < 80) vbuf[j++] = st[i++];
A      163       163    2                   else i++;
A      164       164    2
A      165       165    2             vbuf[j] = 0;
A      166       166    2             mc = lookup_sym_macro(vbuf, j, 0);
A      167       167    2             if (mc)  {
A      168       168    3                struct acct_list  *al = build_acct_list(mc->mc_def,mc->mc_deflen);
A      169       169    3                srch_roots[srch_num] = (al && al->naccts>1)? al->accts : 0;
A      170       170    3                srch_lists[srch_num] = al;
A      171       171    3                if (al) srch_num++;
A      172       172    3                }
A      173       173    2             }
A      174       174    1        }
A      175       175
A      176       176
A      177       177
A      178       178             /*D*    NAME:          fid_ins_acct(acct,fid)
A      179       179                     PURPOSE:       To modify the input file name to specify
A      180       180                                 the account specified in the first argument.
A      181       181                     DESCRIPTION:
A      182       182                        This function uses a temporary buffer (of size 80) to
A      183       183                        update the CP-6 fid in place.
A      184       184             */
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=6  
A      185       185
A      186       186             void
A      187       187             fid_ins_acct(acct,fid)
A      188       188               char     *acct;
A      189       189               char     *fid;
A      190       190             {
A      191       191    1          char      tbuf[80];
A      192       192    1          char     *c = fid+1;
A      193       193    1          char     *t = tbuf + 1;
A      194       194    1          int       i = 0;
A      195       195    1
A      196       196    1          memcpy(tbuf, fid, fid[0]+2);
A      197       197    1
A      198       198    1          while( *t && *t != '.' && *t != ' ') *c++ = *t++;
A      199       199    1          *c++ = '.';
A      200       200    1          if (*t == '.') t++;
A      201       201    1          while (*t && *t != '.' && *t != ' ') t++;
A      202       202    1
A      203       203    1          while (acct[i] != ' ' && i < 8) *c++ = acct[i++];
A      204       204    1          if (*t == '.') *c++ = *t++;
A      205       205    1
A      206       206    1          while (*t && *t != '.' && *t != ' ') *c++ = *t++;
A      207       207    1          *c = 0;
A      208       208    1          fid[0] = (c-fid) - 1;
A      209       209    1        }
A      210       210
A      211       211
A      212       212             /*D*    NAME:          pat_2_name(pat,plen,st,stlen)
A      213       213                     PURPOSE:    To provide string substitution capabilities
A      214       214                                 which are used to map a target name from the
A      215       215                                 make file into a CP-6 file identifier.
A      216       216                     DESCRIPTION:
A      217       217                        The inputs are typically a makefile target name (minus
A      218       218                        the suffix known here as "st" and a pattern to be used
A      219       219                        to map "st" into a file identifier.  The pattern may
A      220       220                        contain two special characters:
A      221       221
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=7  
A      222       222                        "*"   which is followed by a single character which must
A      223       223                              be another "*" (producing a single "*" in the
A      224       224                              output), or a hexadecimal digit which selects that
A      225       225                              many characters from the base string.
A      226       226
A      227       227                        "?"   which inserts all of the remaining characters from
A      228       228                              the base string not used up by "*" controls.
A      229       229                              If "?" is not found in the string, then the pattern
A      230       230                              is treated as if it began with a "?".
A      231       231             */
A      232       232             char *
A      233       233             pat_2_name(pat,plen,st,stlen)
A      234       234               char        *pat;
A      235       235               int          plen;
A      236       236               char        *st;
A      237       237               int          stlen;
A      238       238             {
A      239       239    1          static char  buf[80];   /* Maximum output size  */
A      240       240    1          int         i;
A      241       241    1          int         q = 0;      /* Question mark found  */
A      242       242    1          int         l = 0;      /* # of chars to copied from pat to fid  */
A      243       243    1          int         k = 0;      /* # "*" chars used before the "?"       */
A      244       244    1          int         m = 0;      /* # "*" chars used after the "?"        */
A      245       245    1          int         t = 0;      /* a temporary                           */
A      246       246    1          int         bad = 0;    /* An illegal pattern or result          */
A      247       247    1          int         kk = 0;     /* 2nd pass of chars copied before "?"   */
A      248       248    1          int         ins = 1;    /* Insertion point in output             */
A      249       249    1
A      250       250    1          for ( i=0 ; i<plen ; i++ )  {
A      251       251    2
A      252       252    2             if (pat[i] == '*')   {
A      253       253    3                if ((t = pat[++i]) != '*') {
A      254       254    4                   t = (t>='0' && t<='9')? t-'0' : ((t>='A'&&t<='Z')? t-'A'+10
A      255       255    4                      : ((t>='a'&&t<='z')? t-'a'+10 : -1) );
A      256       256    4                   if ( t>=0 ) {
A      257       257    5                      if (q) m+=t;
A      258       258    5                      else k += t;
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=8  
A      259       259    5                      }
A      260       260    4                   else bad++;
A      261       261    4                   }
A      262       262    3                else l++;
A      263       263    3                }
A      264       264    2             else if (pat[i] == '?') q++;
A      265       265    2             else l++;
A      266       266    2             }
A      267       267    1
A      268       268    1          if (70 < l+stlen)   {
A      269       269    2             if (options['v'])
A      270       270    2             warning("## Produced file name too long: pat=\"%s\", name=\"%s\""
A      271       271    2                     ,pat,st);
A      272       272    2             bad = -999;
A      273       273    2             }
A      274       274    1
A      275       275    1          if (stlen < k + m)   {
A      276       276    2             if (options['v'])
A      277       277    2             warning("## BaseName too short: pat=\"%s\", name=\"%s\"\n",
A      278       278    2                     pat,st);
A      279       279    2             bad = -999;
A      280       280    2             }
A      281       281    1
A      282       282    1          if (!q) memcpy(buf+ins, st, stlen-k), m=k, k=0, q++, ins +=stlen-m;
A      283       283    1             else q=0;
A      284       284    1
A      285       285    1          if (!bad)
A      286       286    1          for ( i=0 ; i<plen ; i++)  {
A      287       287    2             int   c = pat[i];
A      288       288    2             if (c == '*')   {
A      289       289    3                if ((t = pat[++i]) != '*') {
A      290       290    4                   t = (t>='0' && t<='9')? t-'0' : ((t>='A'&&t<='Z')? t-'A'+10
A      291       291    4                      : ((t>='a'&&t<='z')? t-'a'+10 : -1) );
A      292       292    4                   if ( t>=0 ) {
A      293       293    5                      if (q) memcpy(&buf[ins],st+stlen-m,t), m-=t, ins+=t;
A      294       294    5                      else memcpy(&buf[ins],st+1+kk,t), kk+=t, ins+=t;
A      295       295    5                      }
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=9  
A      296       296    4
A      297       297    4                   }
A      298       298    3                else buf[ins++] = '*';
A      299       299    3                }
A      300       300    2             else if (c == '?') memcpy(&buf[ins], st+k,(t=stlen-k-m)), ins+=t, q++;
A      301       301    2             else buf[ins++] = (c == 128) ? '$' : c;
A      302       302    2             }
A      303       303    1          if (bad) buf[ins++] = '!';
A      304       304    1          buf[0] = ins-1, buf[ins] = 0;
A      305       305    1          return buf;
A      306       306    1        }
A      307       307
A      308       308
A      309       309
A      310       310
A      311       311             /*D*    NAME:          gen_spec_name(specnum, target)
A      312       312                     PURPOSE:       To provide the name of a "special" fid.
A      313       313             */
A      314       314
A      315       315             char *
A      316       316             gen_spec_name(specnum, tg)
A      317       317               int               specnum;
A      318       318               struct sym_target *tg;
A      319       319             {
A      320       320    1          char             *rs  = tbuf;
A      321       321    1          struct sym_macro *mcp = sym_macro_specials[MI_LOPATH + specnum];
A      322       322    1          char             *st  = 0;
A      323       323    1          int               stl = 0;
A      324       324    1
A      325       325    1          if (!mcp || mcp->mc_deflen == 0) {
A      326       326    2             if (!specnum)   {  /** DO output **/
A      327       327    3                st = ":do";
A      328       328    3                stl = 3;
A      329       329    3                }
A      330       330    2             else  {           /** LO output **/
A      331       331    3                st = "NO";
A      332       332    3                stl = 2;
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=10 
A      333       333    3                }
A      334       334    2             }
A      335       335    1          else {
A      336       336    2             st = mcp->mc_def;
A      337       337    2             stl = mcp->mc_deflen;
A      338       338    2             }
A      339       339    1
A      340       340    1          if (stl==2 && (strcmp(st,"LP")==0 ||
A      341       341    1              strcmp(st,"NO")==0 || strcmp(st,"ME")==0)) {
A      342       342    2             memcpy(tbuf+1, st, 3);
A      343       343    2             tbuf[0] = 2;
A      344       344    2             }
A      345       345    1          else  {
A      346       346    2             int i = tg->tg_len;
A      347       347    2             char  *dot;
A      348       348    2             char fullname[80];
A      349       349    2             if (options['k']) i = i - tg->tg_suffix_len;
A      350       350    2             memcpy(fullname, tg->tg_text, i);
A      351       351    2             while (dot = memchr(fullname, '.', i))
A      352       352    2                *dot = ':';
A      353       353    2             rs = pat_2_name(st, stl, fullname, i);
A      354       354    2             }
A      355       355    1          return rs;
A      356       356    1        }
A      357       357
A      358       358
A      359       359             /*D*    NAME:          file_name(struct target *tg, int sif, int ouf)
A      360       360                     PURPOSE:       To produce a file name given a target name.
A      361       361                     DESCRIPTION:
A      362       362                        The special flag sif is used to indicate that this name
A      363       363                        should be "forced" to be the si account.  The special
A      364       364                        flag ouf is used to indicate that this name should be
A      365       365                        "forced" to be the ou account.
A      366       366
A      367       367                        The name of the file is produced by looking up a macro
A      368       368                        whose name is the same as the target suffix (file type).
A      369       369                        This macro is used as a pattern (as in pat_2_name) which
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=11 
A      370       370                        is used in conjunction with the base file name (the name
A      371       371                        without the suffix or file type) to produce the fid
A      372       372                        which is to be opened.
A      373       373             */
A      374       374
A      375       375             char *
A      376       376             file_name(tg, sif)
A      377       377               struct sym_target *tg;
A      378       378               int                sif;
A      379       379             {
A      380       380    1          static char        buf[80];      /* Place to generate the filename*/
A      381       381    1          struct sym_macro  *mc;
A      382       382    1          int                base_len = tg->tg_len - tg->tg_suffix_len;
A      383       383    1
A      384       384    1          if (tg->tg_suffix_len)
A      385       385    1             mc = lookup_sym_macro(tg->tg_text+base_len, tg->tg_suffix_len,4);
A      386       386    1          else mc = lookup_sym_macro(".r", 2, 4);
A      387       387    1
A      388       388    1          if (!mc) {
A      389       389    2             memcpy(buf+1, tg->tg_text, tg->tg_len+1);
A      390       390    2             buf[0] = tg->tg_len;
A      391       391    2             }
A      392       392    1          else {
A      393       393    2             char *pb;
A      394       394    2             pb = pat_2_name(mc->mc_def, mc->mc_deflen,tg->tg_text, base_len);
A      395       395    2             memcpy(buf, pb, pb[0]+2);
A      396       396    2             }
A      397       397    1
A      398       398    1          if (sif && SIPATH)
A      399       399    1             fid_ins_acct(SIROOT1, buf);
A      400       400    1
A      401       401    1          return buf;
A      402       402    1        }
A      403       403
A      404       404
A      405       405             /*D*    NAME:       srch_file(char *fid, struct acct_list *srch)
A      406       406                     PURPOSE:    To open a file given its name and an account
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=12 
A      407       407                                 list.
A      408       408                     DESCRIPTION:
A      409       409                        This function attempts to open the specified fid and
A      410       410                        returns the FILE pointer if it exists.  If it does not
A      411       411                        exist and a srch list exists, then the account list is
A      412       412                        scanned starting at the second name in the list (because
A      413       413                        the first name is assumed to be the name already in the
A      414       414                        fid when this function was entered.
A      415       415             */
A      416       416
A      417       417             unsigned
A      418       418             srch_file(fid, srch, acct_access, acct)
A      419       419               char              *fid;
A      420       420               struct acct_list  *srch;
A      421       421               char              *acct;
A      422       422               int               acct_access;
A      423       423             {
A      424       424    1          unsigned           rs = FID_MODTIME( fid+1, acct_access, acct);
A      425       425    1
A      426       426    1          if (!rs && srch)   {
A      427       427    2             int i = 1;
A      428       428    2
A      429       429    2             while ( i<srch->naccts && !rs )   {
A      430       430    3                fid_ins_acct( &srch->accts[i++], fid);
A      431       431    3                rs = FID_MODTIME( fid+1, acct_access, acct);
A      432       432    3                }
A      433       433    2             }
A      434       434    1          return rs;
A      435       435    1        }
A      436       436
A      437       437
A      438       438             /*D*    NAME:       find_file(tg, fi, sif, ouf)
A      439       439                     PURPOSE:    To setup a "struct file_info" for a proposed
A      440       440                                 target name.
A      441       441                     DESCRIPTION:
A      442       442                        This function returns:
A      443       443
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=13 
A      444       444                        0  if a file corresponding to the specified target does
A      445       445                           not exist.
A      446       446
A      447       447                        1  if a file corresponding to the specified target exists.
A      448       448
A      449       449                        2  if a file corresponding to the specified target exists
A      450       450                           and the filename has already been generated.
A      451       451
A      452       452                        If the file exists, the following file_info fields are
A      453       453                        setup:
A      454       454
A      455       455                        fi_mod   file modification time.
A      456       456                        fi_umod  update file modification time.
A      457       457                        fi_name  filename
A      458       458                        fi_uname update file name
A      459       459
A      460       460                        If the file exists and it was found in the root SI account,
A      461       461                        then the update account is checked for an update packet.
A      462       462             */
A      463       463
A      464       464             int
A      465       465             find_file( tg, fi, sif, ouf)
A      466       466               struct sym_target       *tg;
A      467       467               struct file_info        *fi;
A      468       468               int                      sif;
A      469       469               int                      ouf;
A      470       470             {
A      471       471    1          char                    *fn;
A      472       472    1          char                    *acct;
A      473       473    1          int                      i, rs=0;
A      474       474    1          timetype                 mt;
A      475       475    1          struct acct_list        *srch_list;
A      476       476    1          char                     oacct[9];
A      477       477    1
A      478       478    1          fi->fi_target = tg, memcpy(fi->fi_uname,"\000\000",2),fi->fi_umod=0;
A      479       479    1          fi->fi_srch   = 0;
A      480       480    1          if (tg->tg_fid && (!sif || memcmp(fid_acct(tg->tg_fid),SIROOT1,8)==0))  {
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=14 
A      481       481    2             memcpy(fi->fi_name, tg->tg_fid, tg->tg_fid[0]+2);
A      482       482    2             if (tg->tg_ufid)
A      483       483    2                memcpy(fi->fi_uname, tg->tg_ufid, tg->tg_ufid[0]+2);
A      484       484    2             else memcpy(fi->fi_uname, "\000\000", 2);
A      485       485    2             fi->fi_mod  = tg->tg_modtime;
A      486       486    2             fi->fi_umod = tg->tg_umodtime;
A      487       487    2             fi->fi_srch = tg->tg_srch;
A      488       488    2             return 2;
A      489       489    2             }
A      490       490    1
A      491       491    1          fn = file_name(tg, sif);        /* produce our file name */
A      492       492    1          acct = fid_acct(fn);
A      493       493    1
A      494       494    1          srch_list = 0;       /* See if we have a search list  */
A      495       495    1          for ( i=0 ; i<srch_num ; i++ )
A      496       496    1             if (srch_roots[i] && memcmp(srch_roots[i],acct,8) == 0)
A      497       497    1                if (i != 3)
A      498       498    1                   srch_list = srch_lists[i];
A      499       499    1
A      500       500    1          if (ouf && OUPATH && SIPATH)  {
A      501       501    2             if ( srch_list == SIPATH || memcmp(acct,SIROOT1,8) == 0) {
A      502       502    3                fid_ins_acct(OUROOT1, fn);
A      503       503    3                srch_list = (OUROOT) ? OUPATH : (struct acct_list *)0;
A      504       504    3                acct = OUROOT1;
A      505       505    3                }
A      506       506    2             }
A      507       507    1          memcpy(fi->fi_name, fn, fn[0]+2);
A      508       508    1          mt = srch_file( fi->fi_name, srch_list, 0, oacct );
A      509       509    1
A      510       510    1          if (mt)   {                           /* the file exists!    */
A      511       511    2             fi->fi_mod = mt, rs++;
A      512       512    2             fi->fi_srch = srch_list;
A      513       513    2             if (memcmp("        ", fid_acct(fi->fi_name), 8)==0) {
A      514       514    3                fid_ins_acct( oacct, fi->fi_name);
A      515       515    3                }
A      516       516    2             if (TryUIp && memcmp(acct, SIROOT1, 8)== 0)     {
A      517       517    3                memcpy(fi->fi_uname, fi->fi_name, fi->fi_name[0]+2);
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=15 
A      518       518    3                fid_ins_acct( UIROOT1, fi->fi_uname);
A      519       519    3                mt = srch_file(fi->fi_uname, (UIROOT ? UIPATH : (struct acct_list *)0)
A                               , UpdateRst );
A      520       520    3                if (mt)    /**  Updates exist!  **/
A      521       521    3                   fi->fi_umod = mt;
A      522       522    3                else memcpy( fi->fi_uname, "\000\000", 2);
A      523       523    3                }
A      524       524    2             }
A      525       525    1          else {
A      526       526    2             fi->fi_mod = 0;
A      527       527    2             if (srch_list)
A      528       528    2                fid_ins_acct(srch_list->accts[0].text, fi->fi_name);
A      529       529    2             }
A      530       530    1          return rs;
A      531       531    1        }
A      532       532
A      533       533
A      534       534
A      535       535
A      536       536
A      537       537             /*D*    NAME:          delete_target_files(struct sym_target *tg)
A      538       538                     PURPOSE:       To delete all of the target files associated
A      539       539                                    with a primary target.
A      540       540             */
A      541       541
A      542       542             delete_target_files(tg)
A      543       543               struct sym_target *tg;
A      544       544             {
A      545       545    1          struct target_action *a = tg->tg_action;
A      546       546    1
A      547       547    1          while (a) {
A      548       548    2             struct sym_target *t = a->ta_target;
A      549       549    2             if (!t->tg_precious && !t->tg_phony)
A      550       550    2                remove(t->tg_fid+1);
A      551       551    2             a = a->next;
A      552       552    2             }
A      553       553    1          return;
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=16 
A      554       554    1        }
A      555       555
A      556       556
A      557       557
A      558       558
A      559       559             /*D*    NAME:       check_target_status(struct sym_target *tg)
A      560       560                     PURPOSE:    To check the expected output of a job to determine
A      561       561                                 if the files that should be build are present.
A      562       562             */
A      563       563
A      564       564             int
A      565       565             check_target_status(tg)
A      566       566               struct   sym_target  *tg;
A      567       567             {
A      568       568    1          char  *code = 0;
A      569       569    1          char  *arg  = "";
A      570       570    1          int    rs   = 1;
A      571       571    1          FILE  *tf   = 0;
A      572       572    1          struct target_action *ta = tg->tg_action;
A      573       573    1          struct sym_target *t = 0;
A      574       574    1
A      575       575    1          arg = 1+gen_spec_name(1, tg);
A      576       576    1          tf  = fopen(arg, "r");
A      577       577    1          if (tf)  {  /*  If DO file exists... FAILURE     */
A      578       578    2             fclose(tf);
A      579       579    2             code = "See diagnostics file: ";
A      580       580    2             }
A      581       581    1          else {
A      582       582    2             while (ta)  {
A      583       583    3                t = ta->ta_target;
A      584       584    3                if (!t->tg_phony) {
A      585       585    4                   arg = t->tg_fid+1;
A      586       586    4                   tf  = fopen(arg, "r");
A      587       587    4                   if (!tf) {
A      588       588    5                      code = "Missing target file: ";
A      589       589    5                      break;
A      590       590    5                      }
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=17 
A      591       591    4                   fclose(tf);
A      592       592    4                   }
A      593       593    3                ta = ta->next;
A      594       594    3                }
A      595       595    2             }
A      596       596    1          if (code)   {     /*  If failure!  */
A      597       597    2             fprintf(stderr," ** %s failed! %s%s\n",tg->tg_text, code, arg);
A      598       598    2             if (!tg->tg_phony && !tg->tg_precious)
A      599       599    2                remove(tg->tg_fid+1);
A      600       600    2             if (options['e'] > 1)   {
A      601       601    3                FILE *send_email();
A      602       602    3                if (!t || !t->tg_owner) t = tg;
A      603       603    3                if (t->tg_owner)
A      604       604    3                   send_email( (FILE *)0, t, 0, code, arg);
A      605       605    3                else fprintf(stderr," ** no email address for mail!\n");
A      606       606    3                }
A      607       607    2             rs = 0;
A      608       608    2             }
A      609       609    1          return rs;
A      610       610    1        }
A      611       611
A      612       612
A      613       613
A      614       614
A      615       615             /*D*    NAME:       check_system_jobs()
A      616       616                     PURPOSE:    To issue an IBEX check command for each job
A      617       617                                 that is currently expected to be running.
A      618       618                     DESCRIPTION:
A      619       619                        This command is used to cause IBEX to update the notify
A      620       620                        file with the current status of all running jobs.
A      621       621                        This file can then be read to determine whether any jobs
A      622       622                        have completed.
A      623       623             */
A      624       624
A      625       625             int
A      626       626             check_system_jobs()
A      627       627             {
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=18 
A      628       628    1
A      629       629    1          if (options['s'] < 2)
A      630       630    1             system("check");
A      631       631    1          IBEX_output_switch = 0;
A      632       632    1          return 0;
A      633       633    1        }
A      634       634
A      635       635
A      636       636
A      637       637
A      638       638             /*D*    NAME:       mark_sysid_running(int sysid)
A      639       639                     PURPOSE:    To set the sysid running flag on for the action
A      640       640                                 associated with the sysid argument.
A      641       641             */
A      642       642
A      643       643             int
A      644       644             mark_sysid_running(sysid)
A      645       645               int         sysid;
A      646       646             {
A      647       647    1          struct sym_target *tg = target_states[ STATUS_RUNNING ];
A      648       648    1          int                found = 0;
A      649       649    1
A      650       650    1          while (tg)  {
A      651       651    2             if (tg->tg_action->ta_sysid == sysid)  {
A      652       652    3                found++;
A      653       653    3                tg->tg_action->ta_flags |= 1;
A      654       654    3                break;
A      655       655    3                }
A      656       656    2             tg = tg->tg_stchain;
A      657       657    2             }
A      658       658    1          return found;
A      659       659    1        }
A      660       660
A      661       661
A      662       662
A      663       663
A      664       664             /*D*    NAME:       locate_running_jobs(fid)
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=19 
A      665       665                     PURPOSE:    To cause all currently running jobs to mark
A      666       666                                 the associated target_action structure.
A      667       667             */
A      668       668
A      669       669             int
A      670       670             locate_running_jobs()
A      671       671             {
A      672       672    1          int                rs = 0;
A      673       673    1          int                sysid;
A      674       674    1          struct sym_target *tg = target_states[ STATUS_RUNNING ];
A      675       675    1
A      676       676    1          if (IBEX_output_switch)
A      677       677    1             check_system_jobs();
A      678       678    1
A      679       679    1          while (tg)  {
A      680       680    2             sysid = tg->tg_action->ta_sysid;
A      681       681    2             if (CHECK_JOB_COMPLETION(&sysid))
A      682       682    2                tg->tg_action->ta_flags |= 1, rs++;
A      683       683    2             tg = tg->tg_stchain;
A      684       684    2             }
A      685       685    1
A      686       686    1          return rs;
A      687       687    1        }
A      688       688
A      689       689
A      690       690
A      691       691             /*D*    NAME:       send_email
A      692       692                     PURPOSE:    To notify file owners when their compilation has
A      693       693                                 failed.
A      694       694                     DESCRIPTION:
A      695       695                        This function is called in one of three ways.  First, if
A      696       696                        the "-ee" option is provided, then as each file fails a
A      697       697                        mailgram is sent to the file's owner.  This function
A      698       698                        creates that mailgram and sends it when (class==0).
A      699       699
A      700       700                        Secondly, when the build is terminating with errors, then
A      701       701                        for every owner of failing files, he receives a single
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=20 
A      702       702                        complete list of all failures.  There is also a copy sent
A      703       703                        to the project leader (?) if the MAIL_COPY variable is
A      704       704                        defined.  This is done by calling this function with
A      705       705                        (class==1) for each failed file belonging to a particular
A      706       706                        owner.  When all failures for that owner have been sent
A      707       707                        then this function is called with (class == -1) to actually
A      708       708                        send the summary.
A      709       709             */
A      710       710
A      711       711             FILE *
A      712       712             send_email(f, tg, class, arg0, arg1)
A      713       713               FILE *f;
A      714       714               struct sym_target *tg;
A      715       715               int   class;
A      716       716               char  *arg0;
A      717       717               char  *arg1;
A      718       718             {
A      719       719    1          struct sym_macro *mc, *msubj = sym_macro_specials[MI_MAIL_SUBJECT];
A      720       720    1          FILE *dof = 0;
A      721       721    1          int   lines = 0;
A      722       722    1          char  buf[256];
A      723       723    1
A      724       724    1          if (class < 0 && f)  {
A      725       725    2             fclose(f);
A      726       726    2             system("SEND *BODY (GATEWAY)");
A      727       727    2             return 0;
A      728       728    2             }
A      729       729    1          if (!tg->tg_owner || !msubj || !msubj->mc_deflen)
A      730       730    1             return 0;
A      731       731    1
A      732       732    1          if (class == 0)   {
A      733       733    2             /* sending mailgram as soon as failure occurs */
A      734       734    2             f = fopen("*BODY", "w");
A      735       735    2             if (!f) return 0;
A      736       736    2             fprintf(f, "To: %s\n", tg->tg_owner->ow_text);
A      737       737    2             fprintf(f, "Subject: %s\n", msubj->mc_def);
A      738       738    2             fprintf(f, "Signed: ...MAKE.\n");
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=21 
A      739       739    2             mc = sym_macro_specials[MI_MAIL_BODY];
A      740       740    2             fprintf(f, "%s%s%s%s\n", tg->tg_fid+1, mc->mc_def, arg0, arg1);
A      741       741    2             if (arg1 && (dof = fopen(arg1, "r"))) {
A      742       742    3                fprintf(f, "\nDiagnostic file contents:\n\n");
A      743       743    3                while (lines < 14 && fgets(buf, 256, dof))
A      744       744    3                   fputs(buf, f), lines++;
A      745       745    3                if (lines == 14 && fgets(buf, 256, dof))
A      746       746    3                   fprintf(f, "  .\n  .\n  .\n");
A      747       747    3                fclose(dof);
A      748       748    3                }
A      749       749    2             fclose(f);
A      750       750    2             system("SEND *BODY (GATEWAY)");
A      751       751    2             return 0;
A      752       752    2             }
A      753       753    1
A      754       754    1          if (!f)  {
A      755       755    2             f = fopen("*BODY", "w");
A      756       756    2             if (!f) return 0;
A      757       757    2             fprintf(f, "To: %s\n", tg->tg_owner->ow_text);
A      758       758    2             fprintf(f, "Subject: %s\n", msubj->mc_def);
A      759       759    2             fprintf(f, "Signed: ...MAKE.\n");
A      760       760    2             mc = sym_macro_specials[ MI_MAIL_COPY ];
A      761       761    2             if (mc && mc->mc_deflen)
A      762       762    2                fprintf(f,"c: %s\n", mc->mc_def);
A      763       763    2             mc = sym_macro_specials[MI_MAIL_SUMMARY];
A      764       764    2             fprintf(f,"%s\n",mc->mc_def);
A      765       765    2             }
A      766       766    1          fprintf(f," %s\n", tg->tg_fid+1);
A      767       767    1          return f;
A      768       768    1        }
A      769       769
A      770       770
A      771       771
A      772       772             /*F*    NAME:       OpenInclude( char *fid )
A      773       773                     PURPOSE:    To open an include file.
A      774       774                     DESCRIPTION:
A      775       775                        If the passed file name contains an account specification,
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=22 
A      776       776                        that file is opened and the stream pointer returned.
A      777       777
A      778       778                        Otherwise,  the search list is used to locate the file.
A      779       779                        The first item in the search list is always the current
A      780       780                        account.
A      781       781
A      782       782                        The remaining accounts are specified by the -i option
A      783       783                        in one of the following syntax forms:
A      784       784
A      785       785                        1. -iACCOUNT         -- the file name has ".ACCOUNT"
A      786       786                                                appended.
A      787       787                        2. -iname.account    -- the file name is inserted before
A      788       788                                                the '.' in the search string.
A      789       789                        3. -ina?me.account   -- the file name is inserted over the
A      790       790                                                '?' character in the search string.
A      791       791
A      792       792                        The search strings begin with the number of the above case
A      793       793                        to use to create the file name.
A      794       794             */
A      795       795
A      796       796             FILE *
A      797       797             OpenInclude( char *fid )
A      798       798             {
A      799       799    1          FILE *rs;
A      800       800    1          char  buf[80];    /*  To build our file names */
A      801       801    1          char *srch;
A      802       802    1          int   ln, i, j, k, s;
A      803       803    1
A      804       804    1          if (strchr(fid, '.'))
A      805       805    1             return fopen(fid, "r");
A      806       806    1
A      807       807    1          ln = strlen(fid);
A      808       808    1          for (i=0 ; i < SrchNum ; ) {
A      809       809    2             srch = SrchList[i++];
A      810       810    2             s    = *srch++;
A      811       811    2
A      812       812    2             switch (s)  {
rCC.C03    File=MAKE_SIc05.:XSI                                                      Thu Nov 20 1997  Page=23 
A      813       813    3                case 1:           /*  Append '.' and account */
A      814       814    3                   strcat( strcat( strcpy( buf, fid ), "." ), srch);
A      815       815    3                   break;
A      816       816    3                case 2:           /*  Replace '?' with filename */
A      817       817    3                case 3:           /*  Insert filename before '.'*/
A      818       818    3                   k = strchr( srch, ((j = s==2)? '?' : '.') ) - srch;
A      819       819    3                   memcpy(buf,      srch,     k);
A      820       820    3                   memcpy(buf+k,    fid,      ln);
A      821       821    3                   memcpy(buf+k+ln, srch+k+j, 1+strlen(srch+k+j));
A      822       822    3                   break;
A      823       823    3                }
A      824       824    2             rs = fopen(buf, "r");
A      825       825    2             if (rs) return rs;
A      826       826    2             }
A      827       827    1          return (FILE *)0;
A      828       828    1        }
A---  Include file information  ---
A
A   MAKE_Cc13.:XSI. is referenced
A   MAKE_Cc14.:XSI. is referenced
A   stdlib:h.:LIBRARY. is referenced
A   stdio:h.:LIBRARY. is referenced
A   fileinfo:h.:LIBRARY. is referenced
A   string:h.:LIBRARY. is referenced
C
ANo diagnostics were issued in the file MAKE_SIc05.:XSI
