/*M*  DTOR - Converts PL6 data files */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* */
/**/
DTOR:   PROC MAIN;
/**/
%INCLUDE XU_MACRO_C;
%INCLUDE CP_6;
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
%INCLUDE B$TABLES_C;
%B$XL_UPPER;
/* SUBSTITUTIONS */
%EQU OBUFSIZ=132/*OBUFSIZ*/;
/**/
%EQU ASC_BLANK=32/*ASC_BLANK*/;
%EQU ASC_COMMA=44/*ASC_COMMA*/;
%EQU ASC_SEMIC=59/*ASC_SEMIC*/;
%EQU ASC_LPAREN=40/*ASC_LPAREN*/;
%EQU ASC_RPAREN=41/*ASC_RPAREN*/;
%EQU ASC_SLASH=47/*ASC_SLASH*/;
%EQU ASC_SQUOTE=39/*ASC_SQUOTE*/;
%EQU ASC_DQUOTE=34/*ASC_DQUOTE*/;
/**/
%EQU R_PAREN=0;
%EQU R_NOSEMI=1;
%EQU R_COMMENT=2;
%EQU R_QUOTE=3;
/* LOCAL STATIC STORAGE */
DCL 1 EBUF STATIC SYMDEF,
      2 KEY CHAR(10),
      2 SP CHAR(2),
      2 REC CHAR(%OBUFSIZ);
DCL RBUF(0:%(OBUFSIZ-1)) CHAR(1) STATIC SYMDEF;
DCL RBUFC REDEF RBUF CHAR(%OBUFSIZ);
DCL BBUF(0:%(OBUFSIZ-1)) CHAR(1) STATIC SYMDEF;
DCL BBUFC REDEF BBUF CHAR(%OBUFSIZ);
DCL ITEM(0:%(OBUFSIZ-1)) CHAR(1) STATIC SYMDEF;
DCL ITEMT REDEF ITEM CHAR(%OBUFSIZ);
DCL ITEMC CHAR(%OBUFSIZ);
DCL 1 IBUF STATIC SYMDEF,
      2 C(0:255) CHAR(1),
      2 * CHAR(4);
DCL IBUFC REDEF IBUF CHAR(260);
DCL CX UBIN STATIC SYMDEF;
DCL NCHARS UBIN STATIC SYMDEF;
DCL DELIM CHAR(1) STATIC SYMDEF;
DCL TDELIM CHAR(1) STATIC SYMDEF;
DCL CHR CHAR(1) STATIC SYMDEF;
DCL APOS CHAR(1) STATIC SYMDEF;
DCL NUM UBIN STATIC SYMDEF;
DCL RFLG UBIN STATIC SYMDEF;
DCL BFLG UBIN STATIC SYMDEF;
DCL RFLGI UBIN STATIC SYMDEF;
DCL BFLGI UBIN STATIC SYMDEF;
DCL RX UBIN STATIC SYMDEF;
DCL BX UBIN STATIC SYMDEF;
DCL RCNT UBIN STATIC SYMDEF;
DCL BCNT UBIN STATIC SYMDEF;
DCL RDCB UBIN STATIC SYMDEF;
DCL BDCB UBIN STATIC SYMDEF;
DCL M$SI$ PTR STATIC;
DCL M$UI$ PTR STATIC;
DCL M$OU$ PTR STATIC;
DCL 1 FNAME STATIC SYMDEF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL ACCT CHAR(8) STATIC SYMDEF;
DCL 1 SN STATIC SYMDEF,
      2 * UBIN INIT(1),
      2 SN CHAR(6);
DCL REMCNT SBIN STATIC SYMDEF INIT(0);
DCL 1 REM(0:9) STATIC SYMDEF,
      2 TYPE UBIN(18) UNAL,
      2 LINE CHAR(10) UNAL,
      2 REC CHAR(%OBUFSIZ);
DCL COMDEPTH SBIN STATIC SYMDEF;
DCL I UBIN STATIC SYMDEF;
DCL J UBIN STATIC SYMDEF;
DCL K UBIN STATIC SYMDEF;
DCL L UBIN STATIC SYMDEF;
DCL LVL SBIN STATIC SYMDEF;
DCL DCLNAME UBIN STATIC SYMDEF;
DCL DCLLVL CHAR(1) STATIC SYMDEF;
DCL ARRAY UBIN STATIC SYMDEF;
DCL STRUC UBIN STATIC SYMDEF;
DCL CLRTXTFLG UBIN STATIC SYMDEF;
DCL CHRTXTFLG UBIN STATIC SYMDEF;
DCL MACFLG UBIN STATIC SYMDEF;
DCL GFLG SBIN STATIC SYMDEF;
DCL EOFFLG SBIN STATIC SYMDEF;
DCL UNALFLG UBIN STATIC SYMDEF;
DCL CONSTFLG UBIN STATIC SYMDEF;
DCL APOSFLG UBIN STATIC SYMDEF;
DCL ERRCODE BIT(36) STATIC SYMDEF;
DCL ERRDCB UBIN STATIC SYMDEF;
DCL DECOM SBIN STATIC SYMDEF INIT(0);
DCL LISTFLG UBIN STATIC SYMDEF INIT(0);
DCL XUU_FLAGS BIT(36) STATIC SYMDEF INIT('0'B);
DCL MODDIM UBIN STATIC SYMDEF;
/* CONSTANT */
DCL PROCFLG UBIN CONSTANT SYMDEF INIT(0);
DCL MSG1 CONSTANT CHAR(0) INIT('Unexpected EOF');
DCL MSG2 CONSTANT CHAR(0) INIT('Error reading F$LIST');
DCL MSG3 CONSTANT CHAR(0) INIT('Error opening M$SI');
DCL MSG4 CONSTANT CHAR(0) INIT('Error opening M$UI');
DCL MSG5 CONSTANT CHAR(0) INIT('Probable missing semi-colon on pre-processor statement');
DCL MSG6 CONSTANT CHAR(0) INIT('Error reading M$SI');
DCL MSG7 CONSTANT CHAR(0) INIT('Error reading M$UI');
DCL MSG8 CONSTANT CHAR(0) INIT('Last line remembered:');
DCL MSG9 CONSTANT CHAR(0) INIT('Type of item being being searched for:');
DCL MSG10(0:3) CONSTANT CHAR(17) INIT('Right parenthesis',
    'Semi-colon','Comment end','Quoted string end');
DCL STTEXT(0:1) CHAR(9) CONSTANT INIT('CONSTANT','STATIC');
DCL STSIZ(0:1) CONSTANT UBIN INIT(8,6);
%EQU NUMST=2;
/* EXTERNAL */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
/* DCBS */
DCL M$SI DCB;
DCL M$UI DCB;
DCL M$OU DCB;
DCL M$DO DCB;
DCL M$RO DCB;
DCL M$$O DCB;
DCL M$NO DCB;
DCL F$LIST DCB;
/* FPTS */
%FPT_OPEN (FPTN=FPT_OPNSET,SETDCB=YES,FUN=CREATE,EXIST=NEWFILE,ORG=CONSEC);
%FPT_OPEN (FPTN=FPT_SETIN,SETDCB=YES,FUN=IN,ASN=FILE,NAME=FNAME);
%FPT_OPEN (FPTN=FPT_OPNNO,DCB=M$NO,ASN=DEVICE,FUN=CREATE,RES='NO');
%FPT_READ (FPTN=FPT_RDLST,DCB=F$LIST,BUF=IBUF.C);
%FPT_WRITE (FPTN=FPT_WROUT);
%FPT_WRITE (FPTN=FPT_WRERR,DCB=M$DO);
%FPT_CLOSE (FPTN=FPT_CLSSAV,DISP=SAVE,RELG=YES);
%FPT_CLOSE (FPTN=FPT_CLSREL,DISP=RELEASE);
%FPT_ERRMSG (CODE=ERRCODE,BUF=EBUF,OUTDCB1=M$DO,RESULTS=VLR_ERRMSG);
%VLR_ERRMSG;
/* BASED */
%XUU_PARAM (BASE=YES,STCLASS="STATIC SYMDEF");
%XUU$ENTRY;
%F$DCB;
%B$TCB (STCLASS="BASED(B$TCB$)");
%B$ALT;
/**/
/**/
        IF PROCFLG~=0 THEN
           DECOM=1;
        MODDIM=1;
        CALL M$OPEN (FPT_OPNNO);
        CALL GETOPT;
RSTRT:  DCLNAME=0;
        DCLLVL=' ';
        GFLG=0; ARRAY=0; STRUC=0; CLRTXTFLG=0; UNALFLG=0;
        CONSTFLG=0; CHRTXTFLG=0;
        EOFFLG=0; APOSFLG=0;
        ERRCODE='0'B;
        ERRDCB=0;
        REMCNT=0;
        COMDEPTH=0;
/**/
        M$SI$=DCBADDR(DCBNUM(M$SI));
        M$UI$=DCBADDR(DCBNUM(M$UI));
        M$OU$=DCBADDR(DCBNUM(M$OU));
/**/
        CALL INITOUT;
/**/
        CALL OPNIN ALTRET(DONE);
/**/
        CALL OPNOUT;
/**/
        IF DECOM<0 THEN DO;
           CALL COPY;
           GOTO EOF;
           END;
/**/
        IF DECOM>0 THEN
           RFLGI=1;
/**/
ZAPNXT: CALL ZAPREC;
        MACFLG=0;
/**/
NXTITM: CALL GETITEM ALTRET(EOF);
        IF ITEM(0)='%' THEN GOTO PREPROC;
        DO CASE(NUM);
         CASE(0);
           GOTO PUTDELIM;
         CASE(1);
           IF ITEM(0)>='1' AND ITEM(0)<='5' THEN GOTO SDCLLVL;
         CASE(3);
           IF ITEMC='DCL' THEN GOTO SDCL;
           IF ITEMC='BIT' THEN GOTO SBIT;
         CASE(4);
           IF ITEMC='CHAR' THEN GOTO SBIT;
           IF ITEMC='UNAL' THEN GOTO SUNAL;
         END;
        IF DECOM>0 THEN GOTO NOTSPEC;
        DO CASE(NUM);
         CASE(3);
           IF ITEMC='END' THEN GOTO SPROC;
         CASE(4);
           IF ITEMC='PROC' THEN GOTO SPROC;
           IF ITEMC='INIT' THEN GOTO SINIT;
           IF ITEMC='AUTO' THEN GOTO STAT;
         CASE(5);
           IF ITEMC='REDEF' THEN GOTO SREDEF;
         CASE(6);
           IF ITEMC='STATIC' THEN GOTO STAT;
           IF ITEMC='SYMDEF' THEN GOTO SSYMDF;
         CASE(7);
           IF ITEMC='AREADEF' THEN GOTO SSYMDF;
         CASE(8);
           IF ITEMC='CONSTANT' THEN GOTO CONST;
         END;
        IF ITEM(NUM-1)=':' THEN GOTO NXTITM;
        IF NUM>=5 THEN
           IF SUBSTR(ITEMC,NUM-5,5)=':PROC' THEN GOTO SPROC;
        IF DCLNAME~=0 THEN GOTO SDCL20;
/* NON-SPECIAL ITEM */
NOTSPEC: CALL PUT(ITEM,NUM,3);
        IF DELIM~='(' THEN GOTO CHKCOM;
        LVL=0;                          /* Pick up the parentheses too        */
        CALL REMBER(%R_PAREN);
NTS20:  IF ITEM(NUM-1)=')' THEN
           LVL=LVL-1;
        ELSE IF DELIM='(' THEN
              LVL=LVL+1;
        IF LVL=0 THEN DO;
           CALL FORGET;
           IF CHRTXTFLG~=0 THEN DO;
              CHRTXTFLG=0;
              IF DELIM=' ' THEN
                 CALL PUT(DELIM,1,3);
              END;
           GOTO CHKCOM;
           END;
        CALL GETITEM ALTRET(ERR);
        CALL PUT(ITEM,NUM,3);
        GOTO NTS20;
/**/
/* Finished with an item */
/**/
CHKCOM: IF DELIM=',' THEN
           UNALFLG=0;
        GOTO NXTITM;
/**/
PUTDELIM: IF DELIM=',' OR DELIM=';' THEN DO;
           UNALFLG=0;
           CALL PUT(DELIM,1,3);
           END;
        GOTO NXTITM;
/**/
/* DCL */
/**/
SDCL:   CALL PUT(ITEM,NUM,3);
        ARRAY=0; STRUC=0; UNALFLG=0;
        CONSTFLG=0;
        DCLLVL='1';                     /* At level 1                         */
        DCLNAME=1;                      /* Found DCL                          */
        UNALFLG=0;
        GOTO NXTITM;
/**/
SDCLLVL: DCLLVL=ITEM(0);                /* Found a lower level                */
        CALL PUT(ITEM,NUM,3);
        STRUC=1;                        /* In a structure                     */
        DCLNAME=1;
        UNALFLG=0;
        GOTO NXTITM;
/**/
SDCL20: DCLNAME=0;                      /* This may be level 1 name           */
        CALL PUT(ITEM,NUM,1);
        CALL PUTI(ITEM,NUM,2);
        IF DCLLVL='1' AND BFLG~=0 THEN DO;
           IF DELIM='(' OR STRUC~=0 THEN DO;
              CALL INDEX1(I,'_',ITEMC);
              IF I<NUM THEN
                 ITEM(I)='$';
              END;
           END;
        CALL PUTNI(ITEM,NUM,2);
        IF DELIM~='(' THEN GOTO CHKCOM;
        ARRAY=1;                        /* Found an arrayed item              */
        LVL=0;
        CALL REMBER(%R_PAREN);
        DO WHILE '1'B;
           IF DELIM='(' THEN
              LVL=LVL+1;
           ELSE
              IF ITEM(NUM-1)=')' THEN
                 LVL=LVL-1;
           IF LVL=0 THEN DO;
              CALL FORGET;
              GOTO CHKCOM;
              END;
           CALL GETITEM ALTRET(CHKCOM);
           CALL PUTI(ITEM,NUM,3);
           IF DCLLVL='1' AND MODDIM~=0 THEN DO;
              CALL INDEX1(I,':',ITEMC);
              IF I<NUM-1 AND ITEM(0)='(' AND ITEM(NUM-1)=')' THEN DO;
                 IF ITEM(I+1)<'0' OR ITEM(I+1)>'9' THEN DO;
                    ITEMT='(0:8191)';
                    NUM=9-LVL;
                    IF NUM=7 THEN LVL=1;
                    END;
                 END;
              END;
           CALL PUTNI(ITEM,NUM,3);
           END;
/**/
/* BIT or CHAR */
/**/
SBIT:   UNALFLG=1;
        GOTO NOTSPEC;
/**/
/* UNAL */
/**/
SUNAL:  IF UNALFLG~=0 THEN
           GOTO PUTDELIM;
        ELSE
           GOTO NOTSPEC;
/**/
/* INIT clause */
/**/
SINIT:  LVL=1;
        CALL PUTI(ITEM,NUM,3);
        CALL REMBER(%R_PAREN);
SINIT5: CALL GETITEM ALTRET(ERR);
        CALL PUTI(ITEM,NUM,3);
        IF DELIM='(' THEN
           LVL=LVL+1;
        ELSE
           IF ITEM(NUM-1)=')' THEN
              LVL=LVL-1;
        IF LVL~=0 THEN GOTO SINIT5;
        IF DELIM~=' ' AND DELIM~=')' THEN
           CALL PUTNI(DELIM,1,3);
        CALL FORGET;
        GOTO CHKCOM;
/**/
/* STATIC, CONSTANT, AUTO */
/**/
CONST:  CONSTFLG=1;
STAT:   CALL PUTI(ITEM,NUM,3);
        IF DELIM~=' ' THEN
           CALL PUTNI(DELIM,1,3);
        GOTO CHKCOM;
/**/
/* SYMDEF - AREADEF */
/**/
SSYMDF: CALL PUTI(ITEM,NUM,3);
        CALL INSERT(ITEMT,NUM-3,12,'REF READONLY');
        IF CONSTFLG~=0 THEN
           CALL PUTNI(ITEM,NUM+9,1);
        ELSE
           CALL PUTNI(ITEM,NUM,1);
        IF ARRAY+STRUC=0 THEN DO;       /* Not arrayed, not structure         */
           IF CONSTFLG~=0 THEN
              CALL PUTNI(ITEM,NUM+9,2);
           ELSE
              CALL PUTNI(ITEM,NUM,2);
           END;
        ELSE
           CALL PUTNI('BASED',5,2);
        IF NUM=6 THEN
           GOTO CHKCOM;
        LVL=1;
        CALL REMBER(%R_PAREN);
        GOTO SINIT5;
/**/
/* REDEF */
/**/
SREDEF: CALL PUT(ITEM,NUM,3);
        CALL GETITEM ALTRET(ERR);
        CALL PUT(ITEM,NUM,1);
        CALL PUTI(ITEM,NUM,2);
        IF DCLLVL='1' THEN DO;
           CALL INDEX1(I,'_',ITEMC);
           IF I<NUM THEN
              ITEM(I)='$';
           END;
        CALL PUTNI(ITEM,NUM,2);
        GOTO NXTITM;
/**/
/* PROC, END */
/**/
SPROC:  CALL REMBER(%R_NOSEMI);
        DO WHILE(DELIM~=';');           /* Eat entire statement               */
           CALL GETITEM ALTRET(ERR);
           END;
        CALL FORGET;
        GOTO NXTITM;
/**/
/* Pre-processor commands */
/**/
PREPROC: ;
        IF ITEMC='%SUB' THEN DO;
           CALL DMP;
           CALL INDEX1(I,';',IBUFC);
           CALL PUT(IBUF.C,I+1,3);
           CALL DMP;
           GOTO ZAPNXT;
           END;
        IF ITEMC='%RESUB' OR
          ITEMC='%INCLUDE' OR
          ITEMC='%IF' OR
          ITEMC='%ELSEIF' OR
          ITEMC='%SET' OR
          ITEMC='%EQU' OR
          ITEMC='%LSET' OR
          ITEMC='%MAC' OR
          ITEMC='%MACRO' OR
          ITEMC='%ERROR' THEN DO;
SUB20:     CALL DMP;
           CALL PUT(ITEM,NUM,3);
           CALL REMBER(%R_NOSEMI);
           DO WHILE(DELIM~=';');        /* Find the end                       */
              CALL GETITEM ALTRET(ERR);
              CALL PUTI(ITEM,NUM,3);
STCHK:        ;
              DO K=0 TO %(NUMST-1);
                 IF SUBSTR(ITEMC,NUM-STSIZ(K),STSIZ(K))=STTEXT(K)
                   AND DELIM=' ' THEN DO;
                    NUM=NUM-STSIZ(K);
                    CALL PUTNI(ITEM,NUM,1);
                    CALL PUTNI(ITEM,NUM,2);
                    CALL GETITEM ALTRET(ERR);
                    CALL PUTI(ITEM,NUM,3);
                    L=0;
                    IF NUM>7 OR SUBSTR(ITEMC,0,6)~='SYMDEF' THEN DO;
                       TDELIM=DELIM; DELIM=' ';
                       CALL PUTNI(STTEXT(K),STSIZ(K),3);
                       DELIM=TDELIM;
                       GOTO STCHK;
                       END;
                    ITEM(3)='R';
                    IF K=0 THEN DO; NUM=NUM+9;
                       SUBSTR(ITEMT,15,1)=SUBSTR(ITEMT,6,1);
                       SUBSTR(ITEMT,6,9)=' READONLY';
                       END;
                    GOTO NOSMDF;
                    END;
                 CALL INDEX(L,SUBSTR(STTEXT(K),0,STSIZ(K)+1),
                   SUBSTR(ITEMC,0,NUM)) ALTRET(CHKST);
                 J=L+STSIZ(K);
                 DO WHILE SUBSTR(ITEMC,J,1)=' ';
                    J=J+1;
                    END;
                 IF SUBSTR(ITEMC,J,6)='SYMDEF' THEN DO;
                    IF K=0 THEN SUBSTR(ITEMT,L,J+6-L)='SYMREF READONLY';
                    ELSE DO;
                       SUBSTR(ITEMT,L)=SUBSTR(ITEMT,J);
                       SUBSTR(ITEMT,L,6)='SYMREF';
                       NUM=NUM-J+L;
                       END;
                    GOTO NOSMDF;
                    END;
CHKST:           END;
NOSMDF:       CALL PUTNI(ITEM,NUM,1);
              IF SUBSTR(ITEMC,L,6)='SYMREF' THEN DO;
                 IF SUBSTR(ITEMC,L+7,8)='READONLY' AND NUM>14 THEN DO;
                    SUBSTR(ITEMT,L+6)=SUBSTR(ITEMT,L+15);
                    NUM=NUM-9;
                    END;
                 SUBSTR(ITEMT,L,5)='BASED';
                 SUBSTR(ITEMT,L+5)=SUBSTR(ITEMT,L+6);
                 NUM=NUM-1;
                 END;
              CALL PUTNI(ITEM,NUM,2);
              END;
           CALL FORGET;
           CALL DMP;
           GOTO ZAPNXT;
           END;
        IF ITEMC='%CHARTEXT' THEN DO;
           CHRTXTFLG=1;
           GOTO NOTSPEC;
           END;
        IF ITEMC='%INIT' THEN
           GOTO NOTSPEC;
        IF ITEMC='%PLIST' OR
          ITEMC='%LIST' OR
          ITEMC='%NLIST' OR
          ITEMC='%EJECT' OR
          ITEMC='%SPACE' THEN GOTO ZAPNXT;
        IF ITEMC='%EOD' OR
          ITEMC='%MEND' OR
          ITEMC='%ELSE' OR
          ITEMC='%ENDIF' THEN DO;
           CALL DMP;
           ITEM(NUM)=';';
           NUM=NUM+1;
           CALL PUT(ITEM,NUM,3);
           CALL DMP;
           GOTO ZAPNXT;
           END;
        IF DELIM='(' THEN
           IF NUM=1 THEN
              GOTO NOTSPEC;
           ELSE
              GOTO SUB50;
        IF DELIM~=';' THEN
           GOTO NOTSPEC;
        CALL INDEX(I,SUBSTR(ITEMT,0,NUM),IBUFC) ALTRET(NOTSPEC);
        IF I=0 THEN GOTO SUB50;
        IF SUBSTR(IBUFC,0,I)=' ' THEN
           GOTO SUB50;
        GOTO NOTSPEC;
SUB50:  MACFLG=1;
        GOTO SUB20;
/**/
/* All done - close files and get out */
/**/
EOF:    IF GFLG<0 THEN DO;
           GFLG=0;
EOF2:      CALL DMP;
           CALL GETREC ALTRET(EOF);
           CALL INDEX(I,'/*',SUBSTR(IBUFC,0,NCHARS)) ALTRET(EOF3);
           CALL INDEX(J,'*/',SUBSTR(IBUFC,I,NCHARS)) ALTRET(EOF3);
           CALL INDEX1(K,'!',SUBSTR(IBUFC,I,NCHARS)) ALTRET(EOF3);
           IF J>I AND K>I AND K<J THEN DO;
              CX=I;
              GOTO NXTITM;
              END;
EOF3:      DELIM=' ';
           CALL PUT(IBUFC,NCHARS,3);
           GOTO EOF2;
           END;
/**/
        IF RCNT~=0 THEN
           RFLG=1;
        IF BCNT~=0 THEN
           BFLG=1;
        CALL DMP;
        CALL CLOSE(RDCB,RCNT);
        CALL CLOSE(BDCB,BCNT);
        IF LISTFLG~=0 THEN
           GOTO RSTRT;
DONE:   RETURN;
/**/
/**/
/* Unexpected EOF */
/**/
ERR:    IF RCNT~=0 THEN
           RFLG=1;
        IF BCNT~=0 THEN
           BFLG=1;
        CALL DMP;
        CALL CLOSE(RDCB,RCNT);
        CALL CLOSE(BDCB,BCNT);
        CALL ABORT(MSG1,SIZEC(MSG1));
        GOTO RSTRT;
%EJECT;
/*D*    NAME:   GETCHAR
*       CALL:   CALL GETCHAR ALTRET(LOC);
*       INPUT:  IBUF - Current input record buffer
*               CX - Index into IBUF of next character to get
*               NCHARS - Number of chars in IBUF
*       OUTPUT: CHR - Next char from input
*       DESCRIPTION:  If no more chars in IBUF, read next record.
*         Get next char from IBUF, put in CHR, update current position.
*         Note:  Always returns a blank as last char in a record.
*/
GETCHAR: PROC ALTRET;
/**/
        IF EOFFLG~=0 THEN
           ALTRETURN;
        IF CX>=NCHARS THEN DO;
           IF GFLG~=0 THEN DO;
              IF GFLG>0 THEN
                 CALL ABORT(MSG5,SIZEC(MSG5));
              ALTRETURN;
              END;
/**/
GREC:      CALL XUU$READ(XUU_PARAM,VECTOR(IBUF.C)) ALTRET(ERR);
           CX=0;
           NCHARS=XUU_PARAM.ARS+1;
           IBUF.C(NCHARS-1)=' ';
           IF SUBSTR(IBUFC,0,4)='/*M*' THEN DO;
              EBUF.REC=IBUFC;
              I=NCHARS;
              IF DECOM~=0 THEN DO;
/* Save the output file if we get more than one *M* (probly INSREC file */
                 RCNT=BFLGI;
                 BFLGI=1;
                 END;
              CALL PUTOUT(IBUF,I,1,RDCB);
              IBUFC=EBUF.REC;
              I=NCHARS;
              CALL PUTOUT(IBUF,I,1,BDCB);
              GOTO GREC;
              END;
           IF SUBSTR(IBUFC,0,4)='/*T*' THEN DO;
CPR:          EBUF.REC=IBUFC;
              I=NCHARS;
              CALL PUTOUT(IBUF,I,1,RDCB);
              IBUFC=EBUF.REC;
              I=NCHARS;
              CALL PUTOUT(IBUF,I,1,BDCB);
              CALL INDEX(I,'*/',SUBSTR(EBUF.REC,0,NCHARS-1));
              IF I>=NCHARS-1 THEN DO;
                 CALL XUU$READ(XUU_PARAM,VECTOR(IBUF.C)) ALTRET(ERR);
                 NCHARS=XUU_PARAM.ARS+1;
                 GOTO CPR;
                 END;
              GOTO GREC;
              END;
           END;
/**/
        CHR=IBUF.C(CX);
        CX=CX+1;
        RETURN;
/**/
ERR:    IF XUU_PARAM.ERRCODE.ERR#=%E$EOF THEN DO;
           EOFFLG=1;
           ALTRETURN;
           END;
        ERRCODE=XUU_PARAM.ERRCODE;
        IF XUU_PARAM.FLAGS.BASE# THEN
           ERRDCB=DCBNUM(M$SI);
        ELSE
           IF XUU_PARAM.FLAGS.UP_DATE# THEN
              ERRDCB=DCBNUM(M$UI);
        CALL ABORT;
        ALTRETURN;
/**/
GETREC: ENTRY ALTRET;
/**/
        GOTO GREC;
/**/
BACKIN: ENTRY ALTRET;
/**/
        CX=CX-1;
        RETURN;
/**/
ZAPREC: ENTRY ALTRET;
/**/
        CX=0;
        NCHARS=0;
        RETURN;
/**/
END GETCHAR;
%EJECT;
/*D*    NAME:    GETITEM
*       CALL:    CALL GETITEM ALTRET(LOC);
*       OUTPUT:  ITEM - The item found
*                NUM - # chars in ITEM
*                DELIM - The delimiter of ITEM
*                ALTRET if no more chars
*/
GETITEM: PROC ALTRET;
/**/
/* LOCAL AUTOMATIC STORAGE */
DCL FIELD UBIN;
DCL ENDFIELD UBIN;
DCL PREVCHR CHAR(1);
DCL CURC UBIN;
DCL DEPTH SBIN;
/**/
RSTRT:  NUM=0;
        ITEMC=' ';
        ITEMT=' ';
        DELIM=' ';
        FIELD=0;
        ENDFIELD=0;
        DEPTH=0;
        IF APOSFLG~=0 THEN DO;
           APOSFLG=0;                   /* Continue previous string           */
           GOTO APOS20;
           END;
/**/
NXTCHR: CALL GETCHAR ALTRET(EOF);
CHKCHR: DO CASE(ASCBIN(CHR));
         CASE(%ASC_BLANK);              /* Blank                              */
           IF DEPTH~=0 THEN
              GOTO UKN;
           IF FIELD=0 THEN GOTO NXTCHR;
           ENDFIELD=1;
           IF GFLG~=0 THEN GOTO DLM10;
           GOTO NXTCHR;
         CASE(%ASC_COMMA,%ASC_SEMIC);   /* Comma, semi-colon                  */
           IF DEPTH~=0 THEN
              GOTO UKN;
DLM05:     DELIM=CHR;                   /* Remember delimiter                 */
DLM10:     IF ITEMT='*/' THEN DO;
              ITEMT=' ';
              NUM=0;
              IF GFLG<0 THEN ALTRETURN;
              IF DELIM=' ' THEN GOTO RSTRT;
              END;
DLM20:     CALL XLATE (ITEMC,B$XL_UPPER,ITEMT);
           RETURN;
         CASE(%ASC_LPAREN);             /* Open parenthesis                   */
           IF NUM~=0 THEN
              IF DEPTH~=0 OR ITEM(NUM-1)='%' THEN DO;
                 DEPTH=DEPTH+1;         /* Pre-processor expression           */
                 GOTO UKN;
                 END;
           IF FIELD~=0 THEN DO;
              CALL BACKIN;              /* Backup over last input char        */
              GOTO DLM05;
              END;
           GOTO UKN20;
         CASE(%ASC_RPAREN);             /* Close parenthesis                  */
           IF DEPTH~=0 THEN DO;
              DEPTH=DEPTH-1;
              IF DEPTH~=0 THEN
                 GOTO UKN;
              ELSE DO;
                 CALL STUFFCHR;
                 DELIM=CHR;
                 ENDFIELD=1;
                 FIELD=1;
                 CALL GETCHAR ALTRET(EOF);
                 IF CHR=' ' THEN CALL STUFFCHR;
                 ELSE LVL=LVL+1;
                 GOTO CHKCHR;
                 END;
              END;
           IF DELIM~=' ' THEN DO;
              CALL BACKIN;
              GOTO DLM20;
              END;
           CALL STUFFCHR;
           DELIM=CHR;
           ENDFIELD=1;
           FIELD=1;
           GOTO NXTCHR;
         CASE(%ASC_SLASH);              /* Possible comment                   */
COM10:     PREVCHR=CHR;
           CALL GETCHAR ALTRET(ERR);
           IF CHR~='*' THEN DO;         /* Not comment                        */
              CALL STUFF(PREVCHR);
              GOTO CHKCHR;
              END;
           IF FIELD~=0 THEN DO;         /* Already processing an item         */
              ENDFIELD=1;
              CALL BACKIN;
              CALL BACKIN;
              GOTO DLM10;
              END;
           IF COMDEPTH=0 THEN DO;
              COMDEPTH=1;
              CALL REMBER(%R_COMMENT);
              END;
COM30:     CALL GETCHAR ALTRET(ERR);
COM32:     IF CHR='*' THEN DO;          /* May be end of comment              */
COM34:        CALL GETCHAR ALTRET(ERR);
              IF CHR='/' THEN DO;
COM35:           ;
                 CALL FORGET;
                 COMDEPTH=0;
                 GOTO NXTCHR;
                 END;
              GOTO COM32;
              END;
           IF CHR~='!' THEN GOTO COM30;
           IF DECOM>0 THEN GOTO COM50;
           CURC=0; RFLG=0; BFLG=0; RFLGI=0; BFLGI=0;
COM42:     CALL GETCHAR ALTRET(ERR);
           IF CHR='!' THEN GOTO NXTCHR;
           IF CHR=' ' THEN GOTO COM42;
           IF CHR='R' OR CHR='r' THEN DO;
              RFLG=1; CURC=1; GOTO COM42;
              END;
           IF CHR='$' THEN DO;
              BFLG=1; CURC=2; GOTO COM42;
              END;
           IF CHR=',' THEN GOTO COM42;
           IF CHR='I' OR CHR='i' THEN DO;
              IF CURC=1 THEN RFLGI=1;
              ELSE
                 IF CURC=2 THEN BFLGI=1;
              GOTO COM42;
              END;
           IF CHR='*' THEN GOTO COM34;
/* ERROR - UNKNOWN CHAR IN COMMAND */
ENDCOM:    ;                            /* Find end of comment                */
           CALL GETCHAR ALTRET(ERR);
           DO WHILE(CHR='*');
              CALL GETCHAR ALTRET(ERR);
              IF CHR='/' THEN GOTO COM35;
              END;
           GOTO ENDCOM;
/**/
COM50:     CLRTXTFLG=0;
COM52:     CALL GETCHAR ALTRET(ERR);
           IF CHR='*' THEN GOTO COM34;
           IF CHR=' ' THEN GOTO COM52;
           IF CHR~='C' AND CHR~='c' THEN GOTO ENDCOM;
           CLRTXTFLG=1;
           GFLG=-1;
           GOTO COM52;
         CASE(%ASC_SQUOTE,%ASC_DQUOTE); /* Quoted string                      */
           APOS=CHR;                    /* Remember which type of quote       */
           CALL REMBER(%R_QUOTE);
APOS15:    CALL STUFFCHR;
APOS20:    IF CX=NCHARS-1 THEN
              CX=NCHARS;           /* Don't pick up the extra blank at end    */
           IF NUM=%OBUFSIZ THEN DO;
              APOSFLG=1;                /* Go put out this much               */
              ITEMC = ITEMT;
              RETURN;
              END;
           CALL GETCHAR ALTRET(ERR);
           IF CHR~=APOS THEN GOTO APOS15;
           CALL GETCHAR ALTRET(ERR);
           IF CHR=APOS THEN DO;
              CALL STUFFCHR;
              GOTO APOS15;
              END;
           CALL STUFF(APOS);
           CALL FORGET;
           IF CHR='B' OR CHR='O' OR CHR='X'
             OR CHR='b' OR CHR='o' OR CHR='x' THEN DO;
              CALL STUFFCHR;
              GOTO NXTCHR;
              END;
           GOTO CHKCHR;
         CASE(ELSE);                    /* Unknown character                  */
UKN:       IF ENDFIELD~=0 THEN DO;
              IF CHR='=' AND DELIM=' ' THEN DO;
SQUEEZE:         ENDFIELD=0;
                 GOTO UKN20;
                 END;
              IF NUM>0 THEN
                 IF ITEM(NUM-1)='=' THEN
                    GOTO SQUEEZE;
              CALL BACKIN;
              DELIM=' ';
              GOTO DLM10;
              END;
           IF CLRTXTFLG~=0 THEN DO;
              CALL BACKIN;
              ALTRETURN;
              END;
UKN20:     FIELD=1;
           CALL STUFFCHR;
           GOTO NXTCHR;
         END;
EOF:    IF NUM=0 AND DELIM=' ' THEN
           ALTRETURN;
        GOTO DLM10;
/**/
ERR:    CALL ABORT(MSG1,SIZEC(MSG1));
        ALTRETURN;
/**/
STUFF:  PROC(C);
DCL C CHAR(1);
/**/
        ITEM(NUM)=C;
        GOTO ST20;
/**/
STUFFCHR: ENTRY;
/**/
        ITEM(NUM)=CHR;
/**/
ST20:   NUM=NUM+1;
        RETURN;
END STUFF;
/**/
END GETITEM;
%EJECT;
/*D*    NAME:    PUT
*       CALL:    CALL PUT(ITEM,NUM,DEST);
*       INPUT:   ITEM - The thing to put in output buffer
*                NUM - Size of ITEM
*                DEST - 1= R file
*                       2= $ file
*                       3= both
*/
/**/
PUT:    PROC(ITEMP,NUMP,DEST);
/* PARAMETERS */
DCL ITEMP CHAR(%OBUFSIZ);
DCL NUMP UBIN;
DCL DEST SBIN;
/**/
/* LOCAL AUTOMATIC STORAGE */
DCL ENTFLG SBIN;
DCL ITEMC CHAR(%OBUFSIZ);
DCL ITEM(0:%(OBUFSIZ-1)) REDEF ITEMC CHAR(1);
DCL NUM UBIN;
/**/
        ENTFLG=3;                       /* PUT                                */
        GOTO PUT20;
/**/
PUTI:   ENTRY(ITEMP,NUMP,DEST);
        ENTFLG=2;
        GOTO PUT20;
/**/
PUTNI:  ENTRY(ITEMP,NUMP,DEST);
        ENTFLG=1;
/**/
PUT20:  ITEMC=ITEMP;
        NUM=NUMP;
        IF DEST~=2 THEN
           CALL PUT1(RFLG,RFLGI,RBUF,RX,RCNT,RDCB);
/**/
        IF DEST~=1 THEN
           CALL PUT1(BFLG,BFLGI,BBUF,BX,BCNT,BDCB);
/**/
        RETURN;
/**/
PUT1:   PROC(FLG,FLGI,OBUF,OX,OCNT,ODCB);
/* PARAMETERS */
DCL FLG UBIN;
DCL FLGI UBIN;
DCL OBUF(0:%(OBUFSIZ-1)) CHAR(1);
DCL OBUFC REDEF OBUF CHAR(%OBUFSIZ);
DCL OX UBIN;
DCL OCNT SBIN;
DCL ODCB UBIN;
/* LOCAL AUTOMATIC */
DCL TCHR CHAR(1);
DCL TCHR1 CHAR(1);
/**/
        IF FLG=0 THEN RETURN;
        IF FLGI~=0 THEN
           IF ENTFLG=1 THEN RETURN; ELSE;
        ELSE
           IF ENTFLG=2 THEN RETURN; ELSE;
        OCNT=OCNT+1;
        IF (DELIM=',' OR DELIM=';') AND DELIM~=ITEM(NUM-1) THEN DO;
           ITEM(NUM)=DELIM;
           NUM=NUM+1;
           END;
        IF OX~=0 THEN DO;
           TCHR=OBUF(OX-1);
           TCHR1=ITEM(0);
           IF TCHR~=',' AND TCHR~=';' AND TCHR~=')' AND TCHR~=' '
             AND TCHR~='(' AND TCHR1~=' '
             AND TCHR1~=',' AND TCHR1~='(' AND TCHR1~=';' THEN
              IF NUM+OX<=%OBUFSIZ THEN DO;
                 OBUF(OX)=' ';
                 OX=OX+1;
                 END;
           END;
        IF NUM+OX>%OBUFSIZ THEN
           IF TCHR=')' AND TCHR1='%' THEN DO;
              OX=OX-1;
              CALL PUTOUT(OBUF,OX,OCNT,ODCB);
              OBUF(0)=')';
              OX=1;
              END;
           ELSE CALL PUTOUT(OBUF,OX,OCNT,ODCB);
        CALL INSERT(OBUFC,OX,NUM,SUBSTR(ITEMC,0,NUM));
        OX=OX+NUM;
        RETURN;
END PUT1;
END PUT;
%EJECT;
/*D*    NAME:    PUTOUT
*       CALL:    CALL PUTOUT(OBUF,OX,OCNT,ODCB);
*       INPUT:   OBUF - The buffer to dump
*                OX - # bytes in OBUF
*                OCNT - Non-zero if anything worth writing has been written
*                ODCB - DCB to write thru
*/
/**/
PUTOUT: PROC(OBUF,OX,OCNT,ODCB);
/* PARAMETERS */
DCL OBUF(0:%(OBUFSIZ-1)) CHAR(1);
DCL OBUFC REDEF OBUF CHAR(%OBUFSIZ);
DCL OX UBIN;
DCL OCNT UBIN;
DCL ODCB UBIN;
/**/
        IF OCNT=0 THEN RETURN;
        DO WHILE(OX>0 AND OBUF(OX-1)=' ');
           OX=OX-1;
           END;
        IF OX=0 THEN RETURN;
        FPT_WROUT.V.DCB#=ODCB;
        FPT_WROUT.BUF_.BUF$=ADDR(OBUF);
        FPT_WROUT.BUF_.BOUND=OX-1;
        CALL M$WRITE(FPT_WROUT) ALTRET(ERR);
        OX=0;
        OBUFC=' ';
        RETURN;
/**/
ERR:    ERRCODE=B$TCB.ALT$->B$ALT.ERR;
        ERRDCB=ODCB;
        CALL ABORT;
        RETURN;
END PUTOUT;
%EJECT;
/*D*    NAME:    INITOUT
*       CALL:    CALL INITOUT;
*       DESCRIPTION:  Initializes all cells having to do with output
*/
/**/
INITOUT: PROC;
/**/
        RBUFC=' '; BBUFC=' ';
        RFLGI=0; BFLGI=0;
        BFLG=0; RFLG=1;
        RX=0; BX=0; BCNT=0; RCNT=0;
        RDCB=DCBNUM(M$RO); BDCB=DCBNUM(M$$O);
        RETURN;
END INITOUT;
%EJECT;
/*D*    NAME:    DMP
*       CALL:    CALL DMP;
*       DESCRIPTION:  Dumps accumulated buffers to the files if
*         the files are currently enabled
*/
/**/
DMP:    PROC;
/**/
        IF RFLG~=0 AND RX~=0 THEN
           CALL PUTOUT(RBUF,RX,RCNT,RDCB);
/**/
        IF BFLG~=0 AND BX~=0 THEN
           CALL PUTOUT(BBUF,BX,BCNT,BDCB);
/**/
        RETURN;
END DMP;
%EJECT;
/*D*    NAME:    CLOSE
*       CALL:    CALL CLOSE(ODCB);
*       INPUT:   ODCB - DCB number of DCB to close
*       DESCRIPTION:  Closes the specified DCB with save if it is open
*/
/**/
CLOSE:  PROC(ODCB,OCNT);
/* PARAMETERS */
DCL ODCB UBIN;
DCL OCNT UBIN;
/**/
        IF NOT DCBADDR(ODCB)->F$DCB.FCD# THEN RETURN;
        IF OCNT~=0 THEN DO;
           FPT_CLSSAV.V.DCB#=ODCB;
           CALL M$CLOSE(FPT_CLSSAV);
           END;
        ELSE DO;
           FPT_CLSREL.V.DCB#=ODCB;
           CALL M$CLOSE(FPT_CLSREL);
           END;
        RETURN;
END CLOSE;
%EJECT;
/*D*    NAME:    OPNOUT
*       CALL:    CALL OPNOUT;
*       DESCRIPTION:  Opens output DCBs.  For DECOM runs, if M$OU
*        is assigned to file name ':', does SETDCB to change name to
*        the same as M$SI.  For DTOR, sets M$RO to same name as M$SI
*        with last _ and all that follows replaced by _r, and sets
*        M$$O to same as M$RO with trailing _R removed and first _
*        changed to $.
*/
/**/
OPNOUT: PROC;
/* LOCAL AUTOMATIC */
/**/
        DO CASE(DECOM);
         CASE(ELSE);                    /* Decomment or COPY                  */
           IF LISTFLG~=0 OR (B$JIT.PRFLAGS.OU AND
             (DCBADDR(DCBNUM(M$OU))->F$DCB.NAME#.C=':' OR
             DCBADDR(DCBNUM(M$OU))->F$DCB.NAME#.C='*G' OR
             DCBADDR(DCBNUM(M$OU))->F$DCB.NAME#.C=' ')) THEN DO;
              FPT_OPNSET.V.DCB#=DCBNUM(M$OU);
              FPT_OPNSET.NAME_=VECTOR(DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#);
              CALL M$OPEN(FPT_OPNSET) ALTRET(ERR);
              END;
           RDCB=DCBNUM(M$OU);           /* DCB to write thru                  */
           BDCB=DCBNUM(M$NO);
           FPT_WROUT.V.DCB#=RDCB;
         CASE(0);                       /* DTOR                               */
           SN.SN=M$OU$->F$DCB.PSN#;
           ACCT=M$OU$->F$DCB.ACCT#;
           FNAME=M$OU$->F$DCB.NAME#;
           IF FNAME.C=' ' OR FNAME.C='*G' OR FNAME.C=':' THEN
              FNAME=M$SI$->F$DCB.NAME#;
           CALL INDEX1R(I,'_',FNAME.C,FNAME.L);
           CALL INSERT(FNAME.C,I,2,'_R');
           FNAME.L=I+2;
           FPT_OPNSET.V.ASN#=M$OU$->F$DCB.ASN#;
           FPT_OPNSET.V.RES#=M$OU$->F$DCB.RES#;
           FPT_OPNSET.V.DCB#=RDCB;
           FPT_OPNSET.NAME_=VECTOR(FNAME);
           FPT_OPNSET.ACCT_=VECTOR(ACCT);
           FPT_OPNSET.SN_=VECTOR(SN);
           CALL M$OPEN(FPT_OPNSET);
           IBUFC='/*M*';
           CALL INSERT(IBUFC,5,FNAME.L,SUBSTR(FNAME.C,0,FNAME.L));
           CALL INSERT(IBUFC,5+FNAME.L,3,' */');
           I=%OBUFSIZ;
           CALL PUTOUT(IBUF,I,1,RDCB);
           FNAME.L=FNAME.L-2;
           CALL INDEX1(I,'_',FNAME.C,0);
           IF I>FNAME.L THEN
              I=FNAME.L;
           CALL INSERT(FNAME.C,I,1,'$');
           FPT_OPNSET.V.DCB#=BDCB;
           CALL M$OPEN(FPT_OPNSET);
           IBUFC='/*M*';
           CALL INSERT(IBUFC,5,FNAME.L,SUBSTR(FNAME.C,0,FNAME.L));
           CALL INSERT(IBUFC,5+FNAME.L,3,' */');
           I=%OBUFSIZ;
           CALL PUTOUT(IBUF,I,1,BDCB);
         END;
        RETURN;
/**/
ERR:    ERRCODE=B$TCB.ALT$->B$ALT.ERR;
        ERRDCB=DCBNUM(M$OU);
        CALL ABORT;
        RETURN;
END OPNOUT;
%EJECT;
/*D*    NAME:    OPNIN
*       CALL:    CALL OPNIN;
*       DESCRIPTION:  Opens the appropriate input DCBs via the
*        Common Update Package.
*/
/**/
OPNIN:  PROC ALTRET;
/**/
        CALL CLOSE(DCBNUM(M$SI),1);
        CALL CLOSE(DCBNUM(M$UI),1);
        IF LISTFLG~=0 THEN DO;
RDLST:     IBUFC=' ';
           CALL M$READ(FPT_RDLST) ALTRET(LSTERR);
           IF PROCFLG=0 THEN DO;        /* Called as DTOR                     */
              CALL INDEX(I,',DTOR',IBUFC) ALTRET(RDLST);
              DECOM=0;
              END;
           ELSE DO;                     /* Called as DECOM                    */
              CALL INDEX(I,'MRGUP',IBUFC) ALTRET(NOMRG);
              DECOM=-1;
              GOTO GOTIT;
NOMRG:        CALL INDEX(I,'JCL:FORMAT',IBUFC) ALTRET(NOFRMT);
              DECOM=-1;
              GOTO GOTIT;
NOFRMT:       CALL INDEX(I,'JCL:DECOM',IBUFC) ALTRET(RDLST);
              DECOM=1;
              END;
GOTIT:     CALL INDEX1(I,',',IBUFC);
           FNAME.L=I;
           FNAME.C=SUBSTR(IBUFC,0,I);
           FPT_SETIN.V.DCB#=DCBNUM(M$SI);
           CALL M$OPEN(FPT_SETIN);
           XUU_PARAM.FLAGS=XUU_FLAGS;
           IF XUU_PARAM.FLAGS.UP_DATE# THEN DO;
              FPT_SETIN.V.DCB#=DCBNUM(M$UI);
              CALL M$OPEN(FPT_SETIN);
              END;
           CALL XUU$OPEN(XUU_PARAM) ALTRET(ERR);
           FPT_WRERR.BUF_.BUF$=ADDR(FNAME.C);
           FPT_WRERR.BUF_.BOUND=FNAME.L-1;
           CALL M$WRITE(FPT_WRERR);
           RETURN;
LSTERR:    IF B$TCB.ALT$->B$ALT.ERR.CODE=%E$EOF THEN
              ALTRETURN;
           ERRCODE=B$TCB.ALT$->B$ALT.ERR;
           CALL ABORT(MSG2,SIZEC(MSG2));
           CALL M$XXX;
           END;
/**/
        IF XUU_PARAM.FLAGS.UP_DATE# THEN DO; /* UI specified on the call      */
           IF DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#.C=':'
             OR DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#.C=' ' THEN DO;
              FPT_SETIN.V.DCB#=DCBNUM(M$SI); /* Change SI name                */
              FPT_SETIN.NAME_=VECTOR(DCBADDR(DCBNUM(M$UI))->
                F$DCB.NAME#);
              CALL M$OPEN(FPT_SETIN);
              END;
           ELSE
              IF DCBADDR(DCBNUM(M$UI))->F$DCB.NAME#.C=':'
                OR DCBADDR(DCBNUM(M$UI))->F$DCB.NAME#.C=' ' THEN DO;
                 FPT_SETIN.V.DCB#=DCBNUM(M$UI);
                 FPT_SETIN.NAME_=VECTOR(DCBADDR(DCBNUM(M$SI))->
                   F$DCB.NAME#);
                 CALL M$OPEN(FPT_SETIN);
                 END;
           END;
        CALL XUU$OPEN(XUU_PARAM) ALTRET(ERR);
        RETURN;
/**/
ERR:    IF XUU_PARAM.FLAGS.BASE# THEN DO;
           ERRCODE=XUU_PARAM.SI_ERRCODE;
           ERRDCB=DCBNUM(M$SI);
           CALL ABORT(MSG3,SIZEC(MSG3));
           END;
        IF XUU_PARAM.FLAGS.UP_DATE# THEN DO;
           ERRCODE=XUU_PARAM.UI_ERRCODE;
           ERRDCB=DCBNUM(M$UI);
           CALL ABORT(MSG4,SIZEC(MSG4));
           END;
        EOFFLG=0;
        GOTO RDLST;
END OPNIN;
%EJECT;
/*D*    NAME:    COPY
*       CALL:    CALL COPY;
*       DESCRIPTION:  Copies input to output without modification
*/
/**/
COPY:   PROC;
/**/
        DO WHILE(EOFFLG=0);
           CALL XUU$READ(XUU_PARAM,VECTOR(RBUFC)) ALTRET(ERR);
           RCNT=1;
           RX=XUU_PARAM.ARS;
           CALL PUTOUT(RBUF,RX,1,RDCB);
           END;
        RETURN;
/**/
ERR:    EOFFLG=1;
        IF XUU_PARAM.ERRCODE.ERR#=%E$EOF THEN
           RETURN;
        IF XUU_PARAM.FLAGS.BASE# THEN
           ERRDCB=DCBNUM(M$SI);
        ELSE
           IF XUU_PARAM.FLAGS.UP_DATE# THEN
              ERRDCB=DCBNUM(M$UI);
        ERRCODE=XUU_PARAM.ERRCODE;
        CALL ABORT;
        RETURN;
END COPY;
%EJECT;
/*D*    NAME:      REMBER
        ENTRY:     FORGET
        CALL:      CALL REMBER(TYPE);
                   CALL FORGET;
        DESCRIPTION:  Remember an input line number in case of
      later error.
*/
/**/
REMBER: PROC(TYPE);
DCL TYPE UBIN;
/**/
        REM.TYPE(REMCNT)=TYPE;
        REM.LINE(REMCNT)=XUU_PARAM.ASCII_KEY;
        REM.REC(REMCNT)=IBUFC;
        REMCNT=REMCNT+1;
        RETURN;
/**/
FORGET: ENTRY;
        REMCNT=REMCNT-1;
        RETURN;
END REMBER;
%EJECT;
/*D*    NAME:    GETOPT
*       CALL:    CALL GETOPT
*       DESCRIPTION:  Gets the options
*/
/**/
GETOPT: PROC;
/**/
        XUU_PARAM.FLAGS.UP_DATE#=B$JIT.PRFLAGS.UI;
        IF B$JIT.CCARS-B$JIT.CCDISP>=2 THEN DO;
           CALL INDEX(I,'OPTUI',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NOOUI);
           XUU_PARAM.FLAGS.OPT_UI#='1'B;
NOOUI:     ;
           CALL INDEX(I,'(L)',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NOLIST);
           LISTFLG=1;
NOLIST:    ;
           CALL INDEX(I,'NOMODDIM',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NONODIM);
           MODDIM=0;
NONODIM:   ;
           CALL INDEX(I,'LIST',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NOLST);
           LISTFLG=1;
NOLST:     CALL INDEX(I,'NOUI',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(UI);
           XUU_PARAM.FLAGS.OPT_UI#='1'B;
UI:        ;
DONE:      END;
        XUU_FLAGS=XUU_PARAM.FLAGS;
        RETURN;
END GETOPT;
%EJECT;
/*D*    NAME:     WRERR
*       CALL:     CALL WRERR(MSG,MSGSIZ);
*       DESCRIPTION:  Write error message
*/
/**/
WRERR:  PROC(MSG,MSGSIZ);
DCL MSG UBIN;
DCL MSGSIZ UBIN;
/**/
        FPT_WRERR.BUF_.BUF$=ADDR(MSG);
        FPT_WRERR.BUF_.BOUND=MSGSIZ-1;
        CALL M$WRITE(FPT_WRERR);
        RETURN;
END WRERR;
%EJECT;
/*D*    NAME:    ABORT
*       CALL:    CALL ABORT
*       DESCRIPTION:  Aborts with the error in JIT.ERR
*/
/**/
ABORT:  PROC(MSG,MSGSIZ);
/* PARAMETERS */
DCL MSG UBIN;
DCL MSGSIZ UBIN;
/**/
        FPT_ERRMSG.V.DCB#=ERRDCB;
        IF ERRCODE THEN
           CALL M$ERRMSG(FPT_ERRMSG);
        IF ADDR(MSG)~=ADDR(NIL) THEN DO;
           FPT_WRERR.BUF_.BUF$=ADDR(MSG);
           FPT_WRERR.BUF_.BOUND=MSGSIZ-1;
           CALL M$WRITE(FPT_WRERR);
           END;
        IF REMCNT~=0 THEN DO;
           CALL WRERR(MSG8,SIZEC(MSG8));
           EBUF.KEY=REM.LINE(REMCNT-1);
           EBUF.SP=' ';
           EBUF.REC=REM.REC(REMCNT-1);
           CALL WRERR(EBUF,SIZEC(EBUF));
           CALL WRERR(MSG9,SIZEC(MSG9));
           CALL WRERR(MSG10(REM.TYPE(REMCNT-1)),SIZEC(MSG10(0)));
           END;
        REMCNT=0;
        EOFFLG=2;
        ERRCODE='0'B;
        ERRDCB=0;
        IF LISTFLG~=0 THEN RETURN;
        CALL M$XXX;
END ABORT;
END DTOR;
