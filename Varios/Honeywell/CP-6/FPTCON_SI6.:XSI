/*M*  FPTCON - Converts FPT files */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* IND=0,IAD=3 */
/**/
FPTCON: PROC MAIN;
/**/
%INCLUDE XU_MACRO_C;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
/* SUBSTITUTIONS */
%EQU OBUFSIZ=132/*OBUFSIZ*/;
/**/
%EQU ASC_BLANK=32/*ASC_BLANK*/;
%EQU ASC_COMMA=44/*ASC_COMMA*/;
%EQU ASC_SEMIC=59/*ASC_SEMIC*/;
%EQU ASC_LPAREN=40/*ASC_LPAREN*/;
%EQU ASC_RPAREN=41/*ASC_RPAREN*/;
%EQU ASC_SLASH=47/*ASC_SLASH*/;
%EQU ASC_SQUOTE=39/*ASC_SQUOTE*/;
%EQU ASC_DQUOTE=34/*ASC_DQUOTE*/;
/* LOCAL STATIC STORAGE */
DCL 1 EBUF STATIC SYMDEF,
      2 KEY CHAR(10),
      2 SP CHAR(2),
      2 REC CHAR(%OBUFSIZ);
DCL ITEM(0:%(OBUFSIZ-1)) CHAR(1) STATIC SYMDEF;
DCL ITEMC REDEF ITEM CHAR(%OBUFSIZ);
DCL TITEM CHAR(%OBUFSIZ) STATIC SYMDEF;
DCL 1 IBUF STATIC SYMDEF,
      2 C(0:255) CHAR(1);
DCL IBUFC REDEF IBUF CHAR(256);
DCL CX UBIN STATIC SYMDEF;
DCL NCHARS UBIN STATIC SYMDEF;
DCL DELIM CHAR(1) STATIC SYMDEF;
DCL TDELIM CHAR(1) STATIC SYMDEF;
DCL CHR CHAR(1) STATIC SYMDEF;
DCL NUM UBIN STATIC SYMDEF;
%SET DEST_U='4'O;
%SET DEST_E='2'O;
%SET DEST_V='1'O;
%SET DEST_UV='5'O;
%SET DEST_UVP='504'O;
%SET DEST_DCBD='04'O;
%SET DEST_UD='44'O;
%SET DEST_DCB='02'O;
%SET DEST_DCBM='01'O;
%SET DEST_P='004'O;
%SET DEST_VP='104'O;
%SET NUMOUT#=7;
%EQU OUT#_U=1;
%EQU OUT#_E=2;
%EQU OUT#_V=3;
%EQU OUT#_DCBD=4;
%EQU OUT#_DCB=5;
%EQU OUT#_DCBM=6;
%EQU OUT#_P=7;
DCL OFLG(0:%NUMOUT#) BIT(1) ALIGNED STATIC SYMDEF;
DCL OX(0:%NUMOUT#) UBIN STATIC SYMDEF;
DCL OCNT(0:%NUMOUT#) UBIN STATIC SYMDEF;
DCL ODCB(0:%NUMOUT#) UBIN STATIC SYMDEF;
DCL ORECNUM(0:%NUMOUT#) SBIN STATIC SYMDEF;
DCL OMRKR(0:%NUMOUT#) SBIN STATIC SYMDEF;
DCL OBUF(0:%NUMOUT#) CHAR(%OBUFSIZ) STATIC SYMDEF;
DCL 1 FNAME STATIC SYMDEF,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL I UBIN STATIC SYMDEF;
DCL DCBFLG UBIN;
DCL LVL SBIN STATIC SYMDEF;
DCL CHRTXT CHAR(1) STATIC SYMDEF;
DCL VFLG UBIN STATIC SYMDEF;
DCL NAMFLG UBIN STATIC SYMDEF;
DCL VFOUND UBIN STATIC SYMDEF;
DCL PFOUND UBIN STATIC SYMDEF;
DCL MACFLG UBIN STATIC SYMDEF;
DCL VLFLG UBIN STATIC SYMDEF;
DCL EOFFLG SBIN STATIC SYMDEF;
DCL NOUIFLG UBIN STATIC SYMDEF;
DCL UNALFLG UBIN STATIC SYMDEF;
DCL COMFLG SBIN STATIC SYMDEF;
DCL LSFLG UBIN STATIC SYMDEF;
DCL PFILEFLG UBIN STATIC SYMDEF;
DCL VFILEFLG UBIN STATIC SYMDEF;
DCL ERRCODE BIT(36) STATIC SYMDEF;
DCL ERRDCB UBIN STATIC SYMDEF;
DCL ALLFLAG UBIN STATIC SYMDEF INIT(0);
DCL ACCT CHAR(8) STATIC SYMDEF;
DCL FPTNAME CHAR(16) STATIC SYMDEF;
DCL FPTNAMEL UBIN STATIC SYMDEF;
DCL MACCNT SBIN STATIC SYMDEF;
DCL DCLCNT SBIN STATIC SYMDEF;
DCL 1 DONEMSG STATIC SYMDEF,
      2 * CHAR(2) INIT(' '),
      2 MACS CHAR(3),
      2 * CHAR(0) INIT(' Macros, '),
      2 DCLS CHAR(3),
      2 * CHAR(0) INIT(' DCL statements');
/* CONSTANT */
DCL MSG1 CONSTANT CHAR(0) INIT('Unexpected EOF');
DCL MSG2 CONSTANT CHAR(0) INIT('Error reading F$LIST');
DCL MSG3 CONSTANT CHAR(0) INIT('Error opening M$SI');
DCL MSG4 CONSTANT CHAR(0) INIT('Error opening M$UI');
DCL MSG5 CONSTANT CHAR(0) INIT('Probable missing semi-colon on pre-processor statement');
DCL MSG6 CONSTANT CHAR(0) INIT('Error reading M$SI');
DCL MSG7 CONSTANT CHAR(0) INIT('Error reading M$UI');
DCL MSG8 CONSTANT CHAR(0) INIT('Last input record:');
DCL MSG9 CONSTANT CHAR(0) INIT('Not DCL or %MACRO');
DCL MSG10 CONSTANT CHAR(0) INIT('Item too long');
DCL MSG11 CONSTANT CHAR(0) INIT('Missing %MEND');
DCL MSG12 CONSTANT CHAR(0) INIT('%MEND without %MAC');
DCL MSG13 CONSTANT CHAR(0) INIT('Dangling */');
DCL MSG14 CONSTANT CHAR(0) INIT('EOF inside comment');
DCL MSG15 CONSTANT CHAR(0) INIT('Macro invocation outside of macro definition');
DCL MSG16 CONSTANT CHAR(0) INIT('SI name must end in _C if OU not specified');
DCL MSG17 CONSTANT CHAR(0) INIT('SI or OU name must contain an _ before the _C');
DCL BITS(0:8) CONSTANT BIT(36) ALIGNED INIT('0'B,'4'O,'2'O,'1'O,
     '04'O,'02'O,'01'O,'004'O,'002'O);
DCL PATCHI(0:39) UBIN CONSTANT SYMDEF;
DCL PATCHD(0:39) UBIN STATIC SYMDEF;
/* EXTERNAL */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
/* DCBS */
DCL M$SI DCB;
DCL M$UI DCB;
DCL M$DO DCB;
DCL M$OUT DCB;
DCL M$O1 DCB;
DCL M$O2 DCB;
DCL M$O3 DCB;
DCL M$O4 DCB;
DCL M$O5 DCB;
DCL M$O6 DCB;
DCL M$O7 DCB;
DCL F$LIST DCB;
/* FPTS */
%FPT_OPEN (FPTN=FPT_OPNSET,SETDCB=YES,ASN=FILE,FUN=CREATE,EXIST=NEWFILE,ORG=CONSEC);
%FPT_OPEN (FPTN=FPT_SETIN,SETDCB=YES,FUN=IN,ASN=FILE,NAME=FNAME);
%FPT_READ (FPTN=FPT_RDLST,DCB=F$LIST,BUF=IBUF.C);
%FPT_WRITE (FPTN=FPT_WROUT);
%FPT_WRITE (FPTN=FPT_WRERR,DCB=M$DO);
%FPT_WRITE (FPTN=FPT_WRZERO);
%FPT_PRECORD;
%FPT_CLOSE (FPTN=FPT_CLSSAV,DISP=SAVE,RELG=YES);
%FPT_ERRMSG (CODE=ERRCODE,BUF=EBUF,OUTDCB1=M$DO,RESULTS=VLR_ERRMSG);
%VLR_ERRMSG;
/* BASED */
%XUU_PARAM (BASE=YES,STCLASS="STATIC SYMDEF");
%XUU$ENTRY;
%F$DCB;
%B$TCB (STCLASS="BASED(B$TCB$)");
%B$ALT;
/**/
/**/
        ALLFLAG=0; NOUIFLG=0;
        LSFLG=0;
/**/
        CALL GETOPT;
/**/
        ODCB(1)=DCBNUM(M$O1);
        ODCB(2)=DCBNUM(M$O2);
        ODCB(3)=DCBNUM(M$O3);
        ODCB(4)=DCBNUM(M$O4);
        ODCB(5)=DCBNUM(M$O5);
        ODCB(6)=DCBNUM(M$O6);
        ODCB(7)=DCBNUM(M$O7);
/**/
RSTRT:  VLFLG=0; MACFLG=0; VFOUND=0; VFLG=0; PFOUND=0;
        UNALFLG=0; COMFLG=0;
        DCBFLG=0;
        EOFFLG=0;
        ERRCODE='0'B;
        ERRDCB=0;
        MACCNT=0; DCLCNT=0;
        PFILEFLG=0; VFILEFLG=0;
/**/
        CALL INITOUT;
/**/
        CALL OPNIN ALTRET(DONE);
/**/
        CALL OPNOUT;
/**/
ZAPNXT: CALL ZAPREC;
/**/
NXTITM: CALL GETITEM ALTRET(EOF);
        IF ITEMC='%MACRO' OR ITEMC='%MAC' THEN DO;
           IF MACFLG~=0 THEN
           CALL ABORT(MSG11,SIZEC(MSG11),1);
           MACCNT=MACCNT+1;
           VFLG=0; VLFLG=0; VFOUND=0;
           MACFLG=1;
           UNALFLG=0;
           PFILEFLG=0; VFILEFLG=0;
           CALL DMP;
           CALL PUTMRKR(%DEST_V);
           CALL PUT(ITEM,NUM,0,%DEST_UVP|%DEST_DCBD);
           CALL GETITEM ALTRET(ERR);
           IF LSFLG~=0 THEN DO;
              FPT_WRERR.BUF_.BUF$=ADDR(EBUF.REC);
              FPT_WRERR.BUF_.BOUND=SIZEV(EBUF.REC);
              CALL CONCAT(EBUF.REC,'   ',ITEMC);
              CALL M$WRITE(FPT_WRERR);
              END;
           IF ITEMC='FPT_OPEN' OR ITEMC='FPT_CLOSE' THEN DO;
              OFLG(7)='1'B;
              PFOUND=1;
              CALL PUT('%MACRO ',7,0,%DEST_P);
              END;
           IF SUBSTR(ITEMC,0,2)='VL' THEN DO;
              VLFLG=1;
              VFLG=1;
              VFOUND=1;
              END;
           CALL PUT(ITEM,NUM,1,%DEST_U);
           IF ITEMC='M$DCB' THEN
           CALL PUT('M$MDCB',6,1,%DEST_DCBD);
           ELSE
           CALL PUT(ITEM,NUM,1,%DEST_DCBD);
           CALL INDEX1(I,'_',ITEMC);
           IF I>NUM THEN DO;
              I=NUM;
              NUM=NUM+1;
              END;
           ITEM(I)='$';
           CALL INSERT(ITEMC,NUM,2,'_V');
           NUM=NUM+2;
           TITEM=ITEMC;
           CALL INSERT(TITEM,NUM-2,2,'_P');
           CALL PUT(ITEM,NUM,1,%DEST_V);
           CALL PUT(TITEM,NUM,1,%DEST_P);
           CALL PUT('(FPTN=',6,0,%DEST_VP);
           CALL PUT(ITEM,NUM,0,%DEST_V);
           CALL PUT(TITEM,NUM,0,%DEST_P);
           CALL PUT(',BASED=BASED',12,0,%DEST_V);
           CALL PUT(',PFMT=PTR,STCLASS=BASED',23,0,%DEST_P);
           LVL=0;
           IF DELIM~=';' THEN DO;
              TDELIM=' ';
              DO WHILE(TDELIM~=';');
                 CALL GETITEM ALTRET(ERR);
                 IF DELIM=';' THEN NUM=NUM-1;
                 IF ITEM(0)='%' OR ITEM(0)='#' THEN DO;
                    LVL=ASCBIN(ITEM(0))-ASCBIN('$');
                    IF DELIM='(' THEN LVL=LVL*2;
                    ITEMC=SUBSTR(ITEMC,1);
                    NUM=NUM-1;
                    END;
                 IF TDELIM=',' THEN DO;
                    TDELIM=DELIM;
                    DELIM=' ';
                    IF LVL>=0 THEN CALL PUT(',',1,0,%DEST_UD);
                    IF LVL~=0 THEN CALL PUT(',',1,0,%DEST_VP);
                    END;
                 ELSE DO;
                    TDELIM=DELIM;
                    DELIM=' ';
                    END;
                 IF LVL~=0 THEN CALL PUT(ITEM,NUM,0,%DEST_VP);
                 IF LVL>=0 THEN CALL PUT(ITEM,NUM,0,%DEST_UD);
                 IF LVL*LVL=1 AND TDELIM~=' ' THEN LVL=0;
                 IF LVL*LVL>1 AND ITEM(NUM-1)=')' THEN LVL=LVL/2;
                 END;
              CALL PUT(');',2,0,%DEST_VP);
              CALL PUT(');',2,0,%DEST_UD);
              END;
           IF DCBFLG~=0 THEN DO;
              DELIM=' ';
              CALL PUT('%MACRO ',7,0,%DEST_DCBM);
              CALL PUT(FPTNAME,FPTNAMEL,0,%DEST_DCBM);
              CALL PUT('(DCBN=',6,0,%DEST_DCBM);
              CALL PUT(FPTNAME,FPTNAMEL,0,%DEST_DCBM);
              CALL PUT(',BASED="="',10,0,%DEST_DCBM);
              CALL PUT(',STCLASS=BASED',14,0,%DEST_DCBM);
              CALL PUT(');',2,0,%DEST_DCBM);
              END;
           CALL DMP;
           GOTO NXTITM;
           END;
%EJECT;
        IF ITEMC='%MEND' THEN DO;
           IF MACFLG=0 THEN
           CALL ABORT(MSG12,SIZEC(MSG12),1);
           VLFLG=0;
           MACFLG=0;
           VFLG=0;
           IF DCBFLG~=0 THEN DO;
              CALL DMP;
              OFLG(4)='1'B;
              CALL DMP;
              CALL PUT('%MEND;',6,0,%DEST_UD|%DEST_DCBM);
              CALL DMP;
              GOTO NXTITM;
              END;
           IF PFOUND~=0 THEN
           OFLG(7)='1'B;
           CALL DMP;
           CALL PUT('%MEND;',6,0,%DEST_UVP);
           CALL DMP;
           OFLG(7)='0'B;
           IF VFOUND=0 THEN
           CALL ZAPPUT(%DEST_V) ALTRET(ERR);
           VFOUND=0; PFOUND=0;
           GOTO NXTITM;
           END;
%EJECT;
        IF ITEM(0)='%' THEN             /* Pre-processor command              */
        IF ITEMC='%EQU' OR ITEMC='%IF' OR ITEMC='%ELSE'
          OR ITEMC='%ELSEIF' OR ITEMC='%LSET' OR ITEMC='%ERROR'
          OR ITEMC='%RESUB' OR ITEMC='%SUB' OR ITEMC='%INCLUDE'
          OR ITEMC='%SET'
          OR DELIM=';' AND ITEMC~='%EINIT'
          OR (DELIM='(' AND ITEMC~='%INIT' AND ITEMC~='%CHARTEXT')
        THEN DO;
           IF MACFLG=0 THEN
           CALL ABORT(MSG15,SIZEC(MSG15),1);
           CALL DMP;
           CALL PUT(ITEM,NUM,0,%DEST_U);
           IF PFILEFLG~=0 THEN
           CALL PUT(ITEM,NUM,0,%DEST_P);
           IF VFILEFLG~=0 THEN
           CALL PUT(ITEM,NUM,0,%DEST_V);
           DO WHILE(DELIM~=';');
              CALL GETITEM ALTRET(ERR);
              CALL PUT(ITEM,NUM,1,%DEST_U);
              IF PFILEFLG~=0 THEN
              CALL PUT(ITEM,NUM,1,%DEST_P);
              IF VFILEFLG~=0 THEN
              IF ITEMC='STCLASS' THEN
              CALL PUT('BASED',5,1,%DEST_V);
              ELSE IF ITEMC='(STCLASS)' THEN
              CALL PUT('(BASED)',7,1,%DEST_V);
              ELSE
              CALL PUT(ITEM,NUM,1,%DEST_V);
              END;
           CALL DMP;
           GOTO NXTITM;
           END;
%EJECT;
        IF MACFLG=0 THEN DO;            /* Must be DCL ENTRY                  */
           IF ITEMC~='DCL' THEN DO;
              CALL ABORT(MSG9,SIZEC(MSG9),1);
              GOTO RSTRT;
              END;
           DCLCNT=DCLCNT+1;
           VFLG=0; VLFLG=0; VFOUND=0; UNALFLG=0;
           CALL PUT(ITEM,NUM,0,%DEST_E);
           DO WHILE(DELIM~=';');
              CALL GETITEM ALTRET(ERR);
              CALL PUT(ITEM,NUM,1,%DEST_E);
              END;
           GOTO NXTITM;
           END;
%EJECT;
        IF VLFLG~=0 THEN DO;            /* VLPs ARE (relatively) simple.      */
           IF NUM=1 AND ITEM(0)>='0' AND ITEM(0)<='5'
             OR SUBSTR(ITEMC,0,4)='%LVL' OR SUBSTR(ITEMC,0,5)='%(LVL' THEN DO;
              UNALFLG=0;
              NAMFLG=0;
              END;
           ELSE IF ITEM(0)~='%' THEN NAMFLG=1;
           IF ITEMC='STCLASS' THEN DO;
              CALL PUT('BASED',5,1,%DEST_V);
              CALL PUT(ITEM,NUM,1,%DEST_UD);
              GOTO PUTEND;
              END;
           ELSE
           GOTO CHKINIT;
           END;
%EJECT;
        IF NUM=1 AND ITEM(0)>='0' AND ITEM(0)<='5'
          OR SUBSTR(ITEMC,0,4)='%LVL' OR SUBSTR(ITEMC,0,5)='%(LVL' THEN DO;
           UNALFLG=0;
           NAMFLG=0;
           IF DCBFLG~=0 THEN
           GOTO CHKINIT;
           CALL PUT(ITEM,NUM,1,%DEST_UD|%DEST_DCB|%DEST_DCBM);
           IF ITEM(0)='2' THEN DO;
              CALL PUT(ITEM,NUM,1,%DEST_P);
              CALL GETITEM ALTRET(ERR);
              CALL PUT(ITEM,NUM,1,%DEST_UD);
              IF ITEMC='V' THEN DO;
                 VFLG=1;
                 VFOUND=1;
                 CALL PUT('DCL 1 FPTN BASED',16,0,%DEST_V);
                 DELIM=' ';
                 CALL PUT('V UBIN;',7,0,%DEST_P);
                 OFLG(7)='0'B;
                 GOTO PUTEND;
                 END;
              ELSE DO;
                 VFLG=0;
                 CALL PUT(ITEM,NUM,1,%DEST_P);
                 GOTO NXTITM;
                 END;
              END;
           ELSE DO;                     /* Not level 2                        */
              IF VFLG=0 THEN DO;
                 IF OFLG(7) THEN
                 CALL PUT(ITEM,NUM,1,%DEST_P);
                 GOTO PUTEND;
                 END;
              IF ITEM(0)>'2' THEN DO;
                 ITEM(0)=BINASC(ASCBIN(ITEM(0))-1);
                 CALL PUT(ITEM,NUM,1,%DEST_V);
                 GOTO PUTEND;
                 END;
              VFLG=0;
              GOTO PUTEND;
              END;
           END;
        ELSE IF ITEM(0)~='%' THEN NAMFLG=1;
/**/
        IF DCBFLG~=0 THEN
        GOTO CHKINIT;
/**/
        IF VFLG=0 AND PFOUND=0 THEN DO;
           CALL UNALCHK;
           CALL PUT(ITEM,NUM,1,%DEST_UD|%DEST_DCB|%DEST_DCBM);
           GOTO NXTITM;
           END;
/**/
CHKINIT: IF ITEMC='INIT' OR ITEMC='%INIT'
          OR ITEMC='%EINIT' OR ITEMC='%CHARTEXT' THEN DO;
           CALL PUT(ITEM,NUM,1,%DEST_UD);
           IF ITEMC='%EINIT' THEN LVL=0;
           ELSE DO;
              LVL=1;
              DELIM=' ';
              END;
           CHRTXT=ITEM(1);              /* C for CHARTEXT                     */
           DO WHILE(LVL~=0);
              CALL GETITEM ALTRET(ERR);
              IF ITEM(NUM-1)=')' THEN
              LVL=LVL-1;
              ELSE IF DELIM='(' THEN
              LVL=LVL+1;
              IF DCBFLG~=0 AND ITEMC='(29127)' THEN DO;
                 TDELIM=DELIM; DELIM=' ';
                 CALL PUT('(29127);',8,0,%DEST_DCBD);
                 DELIM=TDELIM;
                 OFLG(4)='0'B;
                 END;
              CALL PUT(ITEM,NUM,0,%DEST_UD);
              IF NAMFLG=0 AND VFLG~=0 AND NUM>2 AND (ITEM(NUM-1)=''''
                OR ITEM(NUM-2)='''') THEN DO;
                 CALL INDEX(I,'''',ITEMC);
                 IF DELIM=',' AND LVL~=0 THEN DELIM='?'; /* No commas inside  */
                 IF ITEM(NUM-1)~='''' THEN NUM=NUM-1;
                 I=I+1;
                 CALL PUT(ITEM(I),NUM-I-1,1,%DEST_V);
                 IF DELIM=',' THEN DELIM='?'; /* Don't put the comma in twice */
                 NAMFLG=1;
                 END;
              END;
           IF DELIM=' ' AND CHRTXT='C' THEN
           CALL PUT(DELIM,1,0,%DEST_UD);
           IF DELIM=',' OR DELIM=';' THEN DO;
              UNALFLG=0;
              CALL PUT(DELIM,1,0,%DEST_DCB|%DEST_DCBM);
              IF VFLG~=0 THEN
              CALL PUT(DELIM,1,0,%DEST_V);
              IF OFLG(7) THEN
              CALL PUT(DELIM,1,0,%DEST_P);
              END;
           GOTO PUTEND;
           END;
        IF ITEMC='REDEF' THEN NAMFLG=0;
/**/
        IF ITEM(0)='(' AND ITEM(NUM-1)=')' THEN DO;
           IF ITEMC~='(DCBN.DCBNAME.L)' THEN
           CALL PUT(ITEM,NUM,0,%DEST_UD|%DEST_DCB|%DEST_DCBM|%DEST_P);
           ELSE DO;
              CALL PUT(ITEM,NUM,0,%DEST_UD|%DEST_DCBM);
              CALL PUT('(',1,0,%DEST_DCB);
              CALL PUT(FPTNAME,FPTNAMEL,0,%DEST_DCB);
              CALL PUT('.DCBNAME.L)',11,0,%DEST_DCB);
              END;
           CALL INDEX1(I,':',ITEMC);
           IF I>=NUM THEN
           I=NUM-3;
           IF VFLG~=0 THEN
           IF ITEM(I+1)>='0' AND ITEM(I+1)<='9' OR ITEM(I+1)='%' THEN
           CALL PUT(ITEM,NUM,0,%DEST_V);
           ELSE
           IF ITEM(I)=':' THEN
           CALL PUT('(0:0)',5,0,%DEST_V);
           ELSE
           CALL PUT('(0)',3,0,%DEST_V);
           GOTO PUTEND;
           END;
/**/
        IF DCBFLG~=0 THEN DO;
           IF ITEMC='DCBN' THEN DO;
              CALL PUT(ITEM,NUM,1,%DEST_DCBM|%DEST_UD);
              CALL PUT(FPTNAME,FPTNAMEL,1,%DEST_DCB);
              GOTO NXTITM;
              END;
           IF ITEMC='STCLASS' THEN DO;
              CALL PUT(ITEM,NUM,1,%DEST_UD);
              CALL PUT('BASED',5,1,%DEST_DCB);
              CALL PUTOUT(%OUT#_DCBM);
              CALL PUT('%IF TEXTCHAR(BASED)=''='';',24,0,%DEST_DCBM);
              CALL PUTOUT(%OUT#_DCBM);
              CALL PUT('STCLASS',7,0,%DEST_DCBM);
              CALL PUTOUT(%OUT#_DCBM);
              CALL PUT('%ELSE;',6,0,%DEST_DCBM);
              CALL PUTOUT(%OUT#_DCBM);
              CALL PUT('BASED',5,0,%DEST_DCBM);
              CALL PUTOUT(%OUT#_DCBM);
              CALL PUT('%ENDIF;',7,0,%DEST_DCBM);
              CALL PUTOUT(%OUT#_DCBM);
              GOTO NXTITM;
              END;
           IF ITEMC='TYC' AND DELIM='(' THEN DO;
              DELIM=' ';
              CALL PUT('* UBIN INIT(0),2 TYC,',21,1,%DEST_UD);
              CALL PUT('* UBIN,2 TYC,',13,1,%DEST_DCBM);
              CALL PUT(ITEM,NUM,1,%DEST_DCB);
              CALL GETITEM ALTRET(ERR);
              CALL PUT(ITEM,NUM,0,%DEST_DCB);
              GOTO NXTITM;
              END;
           END;
/**/
        CALL UNALCHK;
        CALL PUT(ITEM,NUM,1,%DEST_UD|%DEST_DCBM|%DEST_P);
        IF NUM>3 THEN
        IF SUBSTR(ITEMC,NUM-4,4)='%L6#' THEN NUM=NUM-4;
        IF NUM~=0 THEN
        IF SUBSTR(ITEMC,NUM-1,1)='#' AND ITEMC~='DCB#' THEN
        NUM=NUM-1;
        CALL PUT(ITEM,NUM,1,%DEST_DCB);
        IF VFLG~=0 THEN DO;
           IF NUM=5 AND VLFLG=0 AND SUBSTR(ITEMC,0,4)='%FIL' THEN
           ITEM(4)=BINASC(ASCBIN(ITEM(4))-1);
           CALL PUT(ITEM,NUM,1,%DEST_V);
           END;
/**/
PUTEND: GOTO NXTITM;
/**/
/**/
/* All done - close files and get out */
/**/
EOF:    IF MACFLG~=0 THEN
        CALL ABORT(MSG11,SIZEC(MSG11),1);
        IF COMFLG~=0 THEN
        CALL ABORT(MSG14,SIZEC(MSG14),1);
        CALL DMP(0);
        DO I=1 TO %NUMOUT#;
           CALL CLOSE(ODCB(I));
           END;
        CALL BINCHAR(DONEMSG.MACS,MACCNT);
        CALL BINCHAR(DONEMSG.DCLS,DCLCNT);
        FPT_WRERR.BUF_.BUF$=ADDR(DONEMSG);
        FPT_WRERR.BUF_.BOUND=SIZEV(DONEMSG);
        CALL M$WRITE(FPT_WRERR);
        IF ALLFLAG~=0 THEN
        GOTO RSTRT;
DONE:   RETURN;
/**/
/**/
/* Unexpected EOF */
/**/
ERR:    CALL DMP(0);
        DO I=1 TO %NUMOUT#;
           CALL CLOSE(ODCB(I));
           END;
        CALL ABORT(MSG1,SIZEC(MSG1));
        GOTO RSTRT;
/**/
/**/
UNALCHK: PROC;
/**/
        IF ITEMC='BIT' OR ITEMC='CHAR' THEN
        UNALFLG=1;                      /* This item is unaligned by default  */
        ELSE
        IF ITEMC='UNAL' AND UNALFLG~=0 THEN DO;
           ITEMC=' ';
           NUM=0;
           END;
        IF DELIM=',' THEN
        UNALFLG=0;
        RETURN;
END UNALCHK;
%EJECT;
/*D*    NAME:   GETCHAR
*       CALL:   CALL GETCHAR ALTRET(LOC);
*       INPUT:  IBUF - Current input record buffer
*               CX - Index into IBUF of next character to get
*               NCHARS - Number of chars in IBUF
*       OUTPUT: CHR - Next char from input
*       DESCRIPTION:  If no more chars in IBUF, read next record.
*         Get next char from IBUF, put in CHR, update current position.
*         Note:  Always returns a blank as last char in a record.
*/
GETCHAR: PROC ALTRET;
/**/
        IF EOFFLG~=0 THEN
        ALTRETURN;
        IF CX>=NCHARS THEN DO;
           CALL XUU$READ(XUU_PARAM,VECTOR(IBUF.C)) ALTRET(ERR);
           CX=0;
           NCHARS=XUU_PARAM.ARS+1;
           IBUF.C(NCHARS-1)=' ';
           END;
/**/
        CHR=IBUF.C(CX);
        CX=CX+1;
        RETURN;
/**/
ERR:    IF XUU_PARAM.ERRCODE.ERR#=%E$EOF THEN DO;
           EOFFLG=1;
           ALTRETURN;
           END;
        ERRCODE=XUU_PARAM.ERRCODE;
        IF XUU_PARAM.FLAGS.BASE# THEN
        ERRDCB=DCBNUM(M$SI);
        ELSE
        IF XUU_PARAM.FLAGS.UP_DATE# THEN
        ERRDCB=DCBNUM(M$UI);
        CALL ABORT;
        ALTRETURN;
/**/
BACKIN: ENTRY ALTRET;
/**/
        CX=CX-1;
        RETURN;
/**/
ZAPREC: ENTRY ALTRET;
/**/
        CX=0;
        NCHARS=0;
        RETURN;
/**/
END GETCHAR;
%EJECT;
/*D*    NAME:    GETITEM
*       CALL:    CALL GETITEM ALTRET(LOC);
*       OUTPUT:  ITEM - The item found
*                NUM - # chars in ITEM
*                DELIM - The delimiter of ITEM
*                ALTRET if no more chars
*/
GETITEM: PROC ALTRET;
/**/
/* LOCAL AUTOMATIC STORAGE */
DCL FIELD UBIN;
DCL ENDFIELD UBIN;
DCL PREVCHR CHAR(1);
DCL APOS CHAR(1);
DCL DEPTH SBIN;
DCL PFLG UBIN;
DCL VFLG UBIN;
/**/
RSTRT:  NUM=0;
        ITEMC=' ';
        DELIM=' ';
        FIELD=0;
        ENDFIELD=0;
        DEPTH=0;
/**/
NXTCHR: CALL GETCHAR ALTRET(EOF);
CHKCHR: DO CASE(ASCBIN(CHR));
         CASE(%ASC_BLANK);              /* Blank                              */
           IF FIELD=0 THEN GOTO NXTCHR;
           IF DELIM=')' THEN DELIM=' ';
           ENDFIELD=1;
           GOTO NXTCHR;
         CASE(%ASC_COMMA,%ASC_SEMIC);   /* Comma, semi-colon                  */
DLM05:     DELIM=CHR;                   /* Remember delimiter                 */
DLM10:     IF ITEMC='*/' THEN DO;
              CALL ABORT(MSG13,SIZEC(MSG13),1);
              ALTRETURN;
              END;
           IF DEPTH=0 THEN RETURN;
           FIELD=0; ENDFIELD=0; DELIM=' ';
           CALL STUFFCHR ALTRET(ERR2);
           GOTO NXTCHR;
         CASE(%ASC_LPAREN);             /* Open parenthesis                   */
           IF NUM~=0 THEN
           IF DEPTH~=0 OR SUBSTR(ITEMC,NUM-1,1)='%' THEN DO;
              DEPTH=DEPTH+1;
              GOTO UKN20;
              END;
           IF FIELD~=0 THEN DO;
              CALL BACKIN;              /* Backup over last input char        */
              GOTO DLM05;
              END;
           GOTO UKN20;
         CASE(%ASC_RPAREN);             /* Close parenthesis                  */
           IF DEPTH~=0 THEN DO;
              DEPTH=DEPTH-1;
              IF DEPTH~=0 THEN
              GOTO UKN;
              ELSE DO;                  /* End of pre-processor expression    */
                 CALL STUFFCHR ALTRET(ERR2);
                 DELIM=CHR;
                 FIELD=1;
                 ENDFIELD=1;
                 CALL GETCHAR ALTRET(EOF);
                 IF CHR=' ' THEN CALL STUFFCHR ALTRET(ERR2);
                 ELSE LVL=LVL+1;
                 GOTO CHKCHR;
                 END;
              END;
           IF DELIM~=' ' THEN DO;
              CALL BACKIN;
              RETURN;
              END;
           CALL STUFFCHR ALTRET(ERR2);
           DELIM=CHR;
           FIELD=1;
           ENDFIELD=1;
           GOTO NXTCHR;
         CASE(%ASC_SLASH);              /* Possible comment                   */
           PREVCHR=CHR;
           CALL GETCHAR ALTRET(COM50);
           IF CHR~='*' THEN DO;         /* Not comment                        */
              CALL STUFF(PREVCHR) ALTRET(ERR2);
              GOTO CHKCHR;
              END;
           COMFLG=1;
           IF FIELD~=0 THEN DO;         /* Already processing an item         */
              ENDFIELD=1;
              CALL BACKIN;
              CALL BACKIN;
              CHR=' ';
              GOTO DLM05;
              END;
           CALL GETCHAR ALTRET(ERR);
           IF CHR~='!' THEN
           GOTO COM32;
           CALL GETCHAR ALTRET(ERR);
           IF CHR~='*' THEN
           GOTO COM32;                  /* Looking for /*!* cmnd              */
           CALL GETCHAR ALTRET(ERR);
           IF CHR='/' THEN
           GOTO COM38;
           VFLG=0; PFLG=0;
CMND2:     CALL GETCHAR ALTRET(ERR);
           IF CHR='*' THEN
           GOTO COM34;
           IF CHR=' ' THEN
           GOTO CMND2;
           IF CHR='V' OR CHR='v' THEN
           VFLG=1;
           IF CHR='P' OR CHR='p' THEN
           PFLG=1;
           IF CHR='Y' OR CHR='y' THEN DO;
              IF VFLG~=0 THEN
              VFILEFLG=1;
              IF PFLG~=0 THEN
              PFILEFLG=1;
              END;
           IF CHR='N' OR CHR='n' THEN DO;
              IF VFLG~=0 THEN
              VFILEFLG=0;
              IF PFLG~=0 THEN
              PFILEFLG=0;
              END;
           GOTO CMND2;
/**/
COM30:     CALL GETCHAR ALTRET(ERR);
COM32:     IF CHR='*' THEN DO;          /* May be end of comment              */
COM34:        CALL GETCHAR ALTRET(ERR);
              IF CHR='/' THEN DO;
COM38:           COMFLG=0;
                 GOTO NXTCHR;
                 END;
              GOTO COM32;
              END;
           GOTO COM30;
COM50:     RETURN;                      /* ERROR - RAN OUT OF INPUT           */
         CASE(%ASC_SQUOTE,%ASC_DQUOTE); /* Quoted string                      */
           APOS=CHR;                    /* Remember which type of quote       */
APOS15:    CALL STUFFCHR ALTRET(ERR2);
           CALL GETCHAR ALTRET(COM50);
           IF CHR~=APOS THEN GOTO APOS15;
           CALL GETCHAR ALTRET(COM50);
           IF CHR=APOS THEN DO;
              CALL STUFFCHR ALTRET(ERR2);
              GOTO APOS15;
              END;
           CALL STUFF(APOS) ALTRET(ERR2);
           IF CHR='B' OR CHR='O' OR CHR='X' THEN DO;
              CALL STUFFCHR ALTRET(ERR2);
              GOTO NXTCHR;
              END;
           GOTO CHKCHR;
         CASE(ELSE);                    /* Unknown character                  */
UKN:       ;
           IF ENDFIELD~=0 THEN DO;
              CALL BACKIN;
              GOTO DLM10;
              END;
UKN20:     FIELD=1;
           CALL STUFFCHR ALTRET(ERR2);
           GOTO NXTCHR;
         END;
EOF:    IF NUM=0 AND DELIM=' ' THEN
        ALTRETURN;
        GOTO DLM10;
/**/
ERR:    CALL ABORT(MSG1,SIZEC(MSG1));
ERR2:   ALTRETURN;
/**/
STUFF:  PROC(C) ALTRET;
DCL C CHAR(1);
/**/
        ITEM(NUM)=C;
        GOTO ST20;
/**/
STUFFCHR: ENTRY ALTRET;
/**/
        ITEM(NUM)=CHR;
/**/
ST20:   NUM=NUM+1;
        IF NUM<=%OBUFSIZ THEN
        RETURN;
        FPT_WRERR.BUF_.BUF$=ADDR(ITEM);
        FPT_WRERR.BUF_.BOUND=NUM-1;
        CALL M$WRITE(FPT_WRERR);
        CALL ABORT(MSG10,SIZEC(MSG10),0);
        ALTRETURN;
END STUFF;
/**/
END GETITEM;
%EJECT;
/*D*    NAME:    PUT
*       CALL:    CALL PUT(ITEM,NUM,BLNK,DEST);
*       INPUT:   ITEM - The thing to put in output buffer
*                NUM - Size of ITEM
*                BLNK - >0 to insert leading blank
*                       <0 to insert trailing blank
*                DEST - BIT 0 = x_CP6
*                       BIT 1 = x$CP6
*                       BIT 2 = xENT
*/
/**/
PUT:    PROC(ITEMP,NUMP,BLNK,DEST);
/* PARAMETERS */
DCL ITEMP CHAR(%OBUFSIZ);
DCL NUMP UBIN;
DCL BLNK SBIN;
DCL DEST BIT(36) ALIGNED;
/**/
/* LOCAL AUTOMATIC */
DCL I UBIN;
DCL OBUF$ PTR;
DCL TCHR CHAR(1);
DCL TCHR1 CHAR(1);
DCL NUM UBIN;
/* STATIC */
DCL ITEM CHAR(%OBUFSIZ) STATIC;
/* BASED */
DCL OUTBUFC CHAR(%OBUFSIZ) BASED(OBUF$) ALIGNED;
DCL OUTBUF(0:%(OBUFSIZ-1)) REDEF OUTBUFC CHAR(1);
/**/
        ITEM=ITEMP;
        NUM=NUMP;
        DO I=1 TO %NUMOUT#;
           IF NOT(DEST&BITS(I)) THEN GOTO NXT;
           IF NOT OFLG(I) THEN GOTO NXT;
           OCNT(I)=1;
           OBUF$=ADDR(OBUF(I));
           IF DELIM=',' OR DELIM=';' THEN DO;
              TCHR = SUBSTR(ITEM,NUM-1,1);
              IF TCHR=',' OR TCHR=';' THEN EXIT;
              CALL INSERT(ITEM,NUM,1,DELIM);
              NUM=NUM+1;
              END;
           IF BLNK>0 AND OX(I)~=0 THEN DO; /* Leading blank                   */
              TCHR=OUTBUF(OX(I)-1);
              TCHR1=SUBSTR(ITEM,0,1);
              IF TCHR~=',' AND TCHR~=';' AND TCHR~=')' AND TCHR~=' '
                AND TCHR1~='(' AND TCHR1~=',' AND TCHR1~=';' THEN
              IF NUM+OX(I)<=%OBUFSIZ THEN DO;
                 OX(I)=OX(I)+1;
                 END;
              END;
           IF NUM+OX(I)>%OBUFSIZ THEN
           IF OUTBUF(OX(I)-1)=')' AND SUBSTR(ITEM,0,1)='%' THEN DO;
              OUTBUF(OX(I)-1)=' ';
              CALL PUTOUT(I);
              OUTBUF(0)=')';
              OX(I)=1;
              END;
           ELSE CALL PUTOUT(I);
           CALL INSERT(OUTBUFC,OX(I),NUM,SUBSTR(ITEM,0,NUM));
           OX(I)=OX(I)+NUM;
           IF BLNK<0 THEN               /* Trailing blank                     */
           IF OX(I)<%OBUFSIZ THEN DO;
              OX(I)=OX(I)+1;
              END;
NXT:       END;
        RETURN;
END PUT;
%EJECT;
/*D*    NAME:    PUTOUT
*       CALL:    CALL PUTOUT(OUTBUF,OX,OCNT,ODCB);
*       INPUT:   I - Buffer number to dump
*/
/**/
PUTOUT: PROC(I);
/* PARAMETERS */
DCL I UBIN;
/* LOCAL AUTOMATIC STORAGE */
DCL OBUF$ PTR;
/* BASED STRUCTURES */
DCL OUTBUFC CHAR(%OBUFSIZ) BASED(OBUF$) ALIGNED;
DCL OUTBUF(0:%(OBUFSIZ-1)) REDEF OUTBUFC CHAR(1);
/**/
        IF OCNT(I)=0 OR OX(I)=0 THEN RETURN;
        OBUF$=ADDR(OBUF(I));
        DO WHILE(OX(I)>0 AND OUTBUF(OX(I)-1)=' ');
           OX(I)=OX(I)-1;
           END;
        IF OX(I)=0 THEN RETURN;
        FPT_WROUT.V.DCB#=ODCB(I);
        FPT_WROUT.BUF_.BUF$=OBUF$;
        FPT_WROUT.BUF_.BOUND=OX(I)-1;
        CALL M$WRITE(FPT_WROUT) ALTRET(ERR);
        ORECNUM(I)=ORECNUM(I)+1;
        OX(I)=0;
        OUTBUFC=' ';
        RETURN;
/**/
ERR:    ERRCODE=B$TCB.ALT$->B$ALT.ERR;
        ERRDCB=FPT_WROUT.V.DCB#;
        CALL ABORT;
        RETURN;
END PUTOUT;
%EJECT;
/*D*    NAME:    PUTMRKR
*       CALL:    CALL PUTMRKR(DEST);
*       DESCRIPTION:  Put a marker in the files indicated by DEST
*         so that they may later be rolled back to this position.
*/
/**/
PUTMRKR: PROC(DEST);
/* PARAMETERS */
DCL DEST BIT(36) ALIGNED;
/* LOCAL AUTOMATIC STORAGE */
DCL I UBIN;
/**/
        DO I=1 TO %NUMOUT#;
           IF DEST&BITS(I) THEN
           OMRKR(I)=ORECNUM(I);
           END;
        RETURN;
END PUTMRKR;
%EJECT;
/*D*    NAME:    ZAPPUT
*       CALL:    CALL ZAPPUT(DEST);
*       DESCRIPTION:  Rolls file DEST back to the last marker.
*/
/**/
ZAPPUT: PROC(DEST) ALTRET;
/* PARAMETERS */
DCL DEST BIT(36) ALIGNED;
/* LOCAL AUTOMATIC STORAGE */
DCL I UBIN;
DCL N SBIN;
/**/
        DO I=1 TO %NUMOUT#;
           IF NOT DEST&BITS(I) THEN GOTO NXTFILE;
           IF OMRKR(I)<0 THEN GOTO NXTFILE;
           N=ORECNUM(I)-OMRKR(I);
           IF N>0 THEN DO;
              FPT_PRECORD.V.DCB#=ODCB(I);
              FPT_PRECORD.V.N#=-N;
              CALL M$PRECORD(FPT_PRECORD) ALTRET(ERR);
              FPT_WRZERO.V.DCB#=ODCB(I);
              CALL M$WRITE(FPT_WRZERO);
              FPT_PRECORD.V.N#=-1;
              CALL M$PRECORD(FPT_PRECORD);
              END;
           ORECNUM(I)=0;
           OMRKR(I)=-1;
           OX(I)=0;
           OBUF(I)=' ';
NXTFILE:   END;
        RETURN;
/**/
ERR:    ERRCODE=B$TCB.ALT$->B$ALT.ERR;
        ERRDCB=ODCB(I);
        CALL ABORT;
        ALTRETURN;
END ZAPPUT;
%EJECT;
/*D*    NAME:    INITOUT
*       CALL:    CALL INITOUT;
*       DESCRIPTION:  Initializes all cells having to do with output
*/
/**/
INITOUT: PROC;
/* LOCAL AUTOMATIC STORAGE */
DCL I UBIN;
/**/
        DO I=0 TO %NUMOUT#;
           OX(I)=0; OCNT(I)=0; OFLG(I)='0'B; OBUF(I)=' ';
           ORECNUM(I)=0; OMRKR(I)=-1;
           END;
        RETURN;
END INITOUT;
%EJECT;
/*D*    NAME:    DMP
*       CALL:    CALL DMP;
*       DESCRIPTION:  Dumps accumulated buffers to the files if
*         the files are currently enabled
*/
/**/
DMP:    PROC(FLG);
/* LOCAL AUTO */
DCL FLG UBIN;
/* LOCAL AUTOMATIC STORAGE */
DCL I UBIN;
/**/
        DO I=1 TO %NUMOUT#;
           IF I=2 THEN                  /* ENT file                           */
           IF ADDR(FLG)=ADDR(NIL) THEN
           GOTO SKIP;
           IF OFLG(I) AND OX(I)~=0 THEN
           CALL PUTOUT(I);
SKIP:      END;
/**/
        RETURN;
END DMP;
%EJECT;
/*D*    NAME:    CLOSE
*       CALL:    CALL CLOSE(ODCB);
*       INPUT:   ODCB - DCB number of DCB to close
*       DESCRIPTION:  Closes the specified DCB with save if it is open
*/
/**/
CLOSE:  PROC(ODCB);
/* PARAMETERS */
DCL ODCB UBIN;
/**/
        IF NOT DCBADDR(ODCB)->F$DCB.FCD# THEN RETURN;
        FPT_CLSSAV.V.DCB#=ODCB;
        CALL M$CLOSE(FPT_CLSSAV);
        RETURN;
END CLOSE;
%EJECT;
/*D*    NAME:    OPNOUT
*       CALL:    CALL OPNOUT;
*       DESCRIPTION:  Opens output DCBs.  If M$OUT is not assigned,
*        all DCBs are assigned to 'NO'.  Otherwise, various DCBs are
*        set to various computed names.  See HELP info for details.
*/
/**/
OPNOUT: PROC;
/* LOCAL AUTOMATIC */
/**/
        FPT_OPNSET.V.ASN#=DCBADDR(DCBNUM(M$OUT))->F$DCB.ASN#;
        FPT_OPNSET.V.RES#=DCBADDR(DCBNUM(M$OUT))->F$DCB.RES#;
        IF NOT B$JIT.PRFLAGS.OU THEN DO;
           FPT_OPNSET.V.RES#='NO';
           FPT_OPNSET.V.ASN#=%DEVICE#;
           END;
        ACCT=DCBADDR(DCBNUM(M$OUT))->F$DCB.ACCT#;
        IF DCBADDR(DCBNUM(M$OUT))->F$DCB.NAME#.C~=' ' AND
          DCBADDR(DCBNUM(M$OUT))->F$DCB.NAME#.C~='*G' THEN
        FNAME=DCBADDR(DCBNUM(M$OUT))->F$DCB.NAME#;
        ELSE DO;
           FNAME=DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#;
           IF SUBSTR(FNAME.C,FNAME.L-2,2)~='_C'
             AND SUBSTR(FNAME.C,FNAME.L-2,2)~='_M'
           THEN CALL ABORT(MSG16,SIZEC(MSG16));
           END;
        IF SUBSTR(FNAME.C,FNAME.L-2,2)='_C'
          OR SUBSTR(FNAME.C,FNAME.L-2,2)='_M'
        THEN FNAME.L=FNAME.L-2;
        FPT_OPNSET.V.DCB#=ODCB(1);
        FPT_OPNSET.NAME_=VECTOR(FNAME);
        FPT_OPNSET.ACCT_=VECTOR(ACCT);
        CALL M$OPEN(FPT_OPNSET);
        CALL SETBFR(1);
/**/
        CALL INDEX(I,'DCB',FNAME.C) ALTRET(NODCB);
        DCBFLG=1;
        CALL INSERT(FNAME.C,FNAME.L,2,'_D');
        FNAME.L=FNAME.L+2;
        FPT_OPNSET.V.DCB#=ODCB(4);
        CALL M$OPEN(FPT_OPNSET);
        FNAME.L=FNAME.L-2;
        CALL INDEX(I,'_',SUBSTR(FNAME.C,0,FNAME.L))
        WHENALTRETURN DO; CALL ABORT(MSG17,SIZEC(MSG17)); END;
        CALL INSERT(FNAME.C,I,1,'$');
        FPT_OPNSET.V.DCB#=ODCB(5);
        CALL M$OPEN(FPT_OPNSET);
        FPTNAME=FNAME.C;
        FPTNAMEL=FNAME.L;
        CALL INSERT(FNAME.C,FNAME.L,1,'M');
        FNAME.L=FNAME.L+1;
        FPT_OPNSET.V.DCB#=ODCB(6);
        CALL M$OPEN(FPT_OPNSET);
        CALL SETBFR(6);
        OFLG(4)='1'B; OFLG(5)='1'B; OFLG(6)='1'B;
        OFLG(1)='1'B;
        RETURN;
/**/
NODCB:  CALL INDEX(I,'_',SUBSTR(FNAME.C,0,FNAME.L));
        IF I=FNAME.L THEN
        FNAME.L=I+1;
        CALL INSERT(FNAME.C,I,1,'$');
        CALL INSERT(FNAME.C,FNAME.L,3,'V_C');
        FNAME.L=FNAME.L+3;
        FPT_OPNSET.V.DCB#=ODCB(3);
        CALL M$OPEN(FPT_OPNSET);
/**/
        I=I+1;
        CALL INSERT(FNAME.C,I,3,'ENT');
        FNAME.L=I+3;
        FPT_OPNSET.V.DCB#=ODCB(2);
        CALL M$OPEN(FPT_OPNSET);
        CALL SETBFR(2);
        FNAME.C='F$CP6P_C';
        FNAME.L=8;
        FPT_OPNSET.V.DCB#=ODCB(7);
        CALL M$OPEN(FPT_OPNSET);
/**/
        OFLG(1)='1'B; OFLG(2)='1'B; OFLG(3)='1'B;
/**/
        RETURN;
/**/
/**/
SETBFR: PROC(I);
DCL I UBIN;
/**/
        OBUF(I)='/*M*';
        CALL INSERT(OBUF(I),5,FNAME.L,FNAME.C);
        CALL INSERT(OBUF(I),6+FNAME.L,2,'*/');
        OX(I)=%OBUFSIZ;
        RETURN;
END SETBFR;
/**/
END OPNOUT;
%EJECT;
/*D*    NAME:    OPNIN
*       CALL:    CALL OPNIN;
*       DESCRIPTION:  Opens the appropriate input DCBs via the
*        Common Update Package.
*/
/**/
OPNIN:  PROC ALTRET;
/**/
        CALL CLOSE(DCBNUM(M$SI));
        CALL CLOSE(DCBNUM(M$UI));
        IF ALLFLAG~=0 THEN DO;
RDLST:     IBUFC=' ';
           CALL M$READ(FPT_RDLST) ALTRET(LSTERR);
           CALL INDEX1(I,' ',IBUFC);
           IF I>= 132 THEN GOTO RDLST;
           FNAME.L=I;
           FNAME.C=SUBSTR(IBUFC,0,I);
           FPT_SETIN.V.DCB#=DCBNUM(M$SI);
           CALL M$OPEN(FPT_SETIN);
           XUU_PARAM.FLAGS='0'B;
           XUU_PARAM.FLAGS.BASE#='1'B;
           IF B$JIT.PRFLAGS.UI THEN DO;
              FPT_SETIN.V.DCB#=DCBNUM(M$UI);
              CALL M$OPEN(FPT_SETIN);
              XUU_PARAM.FLAGS.UP_DATE#='1'B;
              IF NOUIFLG~=0 THEN XUU_PARAM.FLAGS.OPT_UI#='1'B;
              END;
           CALL XUU$OPEN(XUU_PARAM) ALTRET(ERR);
WRNAME:    FPT_WRERR.BUF_.BUF$=ADDR(FNAME.C);
           FPT_WRERR.BUF_.BOUND=FNAME.L-1;
           CALL M$WRITE(FPT_WRERR);
           RETURN;
LSTERR:    IF B$TCB.ALT$->B$ALT.ERR.CODE=%E$EOF THEN
           ALTRETURN;
           ERRCODE=B$TCB.ALT$->B$ALT.ERR;
           CALL ABORT(MSG2,SIZEC(MSG2));
           CALL M$XXX;
           END;
/**/
        XUU_PARAM.FLAGS.BASE#='1'B;
        IF B$JIT.PRFLAGS.UI THEN DO;    /* UI specified on call line          */
           XUU_PARAM.FLAGS.UP_DATE#='1'B;
           IF NOUIFLG~=0 THEN XUU_PARAM.FLAGS.OPT_UI#='1'B;
           IF DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#.C=':'
             OR DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#.C=' ' THEN DO;
              FPT_SETIN.V.DCB#=DCBNUM(M$SI); /* Change SI name                */
              FPT_SETIN.NAME_=VECTOR(DCBADDR(DCBNUM(M$UI))->
                F$DCB.NAME#);
              CALL M$OPEN(FPT_SETIN);
              END;
           ELSE
           IF DCBADDR(DCBNUM(M$UI))->F$DCB.NAME#.C=':'
             OR DCBADDR(DCBNUM(M$UI))->F$DCB.NAME#.C=' ' THEN DO;
              FPT_SETIN.V.DCB#=DCBNUM(M$UI);
              FPT_SETIN.NAME_=VECTOR(DCBADDR(DCBNUM(M$SI))->
                F$DCB.NAME#);
              CALL M$OPEN(FPT_SETIN);
              END;
           END;
        CALL XUU$OPEN(XUU_PARAM) ALTRET(ERR);
        RETURN;
/**/
ERR:    IF XUU_PARAM.FLAGS.BASE# THEN DO;
           ERRCODE=XUU_PARAM.SI_ERRCODE;
           ERRDCB=DCBNUM(M$SI);
           CALL ABORT(MSG3,SIZEC(MSG3));
           END;
        IF XUU_PARAM.FLAGS.UP_DATE# THEN DO;
           ERRCODE=XUU_PARAM.UI_ERRCODE;
           ERRDCB=DCBNUM(M$UI);
           CALL ABORT(MSG4,SIZEC(MSG4));
           END;
        CALL CLOSE(DCBNUM(M$SI));
        GOTO RDLST;
END OPNIN;
%EJECT;
/*D*    NAME:     GETOPT
*       CALL:     CALL GETOPT;
*       DESCRIPTION:  Gets the options from the invocation line
*/
/**/
GETOPT: PROC;
/**/
        IF B$JIT.CCARS-B$JIT.CCDISP>=2 THEN DO;
           CALL INDEX(I,'LS',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NLS);
           LSFLG=1;
NLS:       ;
           CALL INDEX(I,'OPTUI',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(NOPTUI);
           NOUIFLG=1;
NOPTUI:    ;
           CALL INDEX(I,'NOUI',B$JIT.CCBUF,B$JIT.CCDISP) ALTRET(UI);
           NOUIFLG=1;
UI:        END;
        RETURN;
END GETOPT;
%EJECT;
/*D*    NAME:    ABORT
*       CALL:    CALL ABORT
*       DESCRIPTION:  Aborts with the error in JIT.ERR
*/
/**/
ABORT:  PROC(MSG,MSGSIZ,IFLG);
/* PARAMETERS */
DCL MSG UBIN;
DCL MSGSIZ UBIN;
DCL IFLG UBIN;
/**/
        FPT_ERRMSG.V.DCB#=ERRDCB;
        IF ERRCODE THEN
        CALL M$ERRMSG(FPT_ERRMSG);
        IF ADDR(MSG)~=ADDR(NIL) THEN DO;
           FPT_WRERR.BUF_.BUF$=ADDR(MSG);
           FPT_WRERR.BUF_.BOUND=MSGSIZ-1;
           CALL M$WRITE(FPT_WRERR);
           END;
        IF ADDR(IFLG)~=ADDR(NIL) AND IBUFC~=' ' THEN DO;
           FPT_WRERR.BUF_.BUF$=ADDR(MSG8);
           FPT_WRERR.BUF_.BOUND=SIZEV(MSG8);
           CALL M$WRITE(FPT_WRERR);
           EBUF.KEY=XUU_PARAM.ASCII_KEY;
           EBUF.SP=' ';
           EBUF.REC=IBUFC;
           FPT_WRERR.BUF_.BUF$=ADDR(EBUF);
           FPT_WRERR.BUF_.BOUND=SIZEC(EBUF.KEY)+SIZEC(EBUF.SP)+XUU_PARAM.ARS-1;
           CALL M$WRITE(FPT_WRERR);
           END;
        EOFFLG=2;
        ERRCODE='0'B;
        ERRDCB=0;
        IF ALLFLAG~=0 THEN RETURN;
        CALL M$XXX;
END ABORT;
END FPTCON;
