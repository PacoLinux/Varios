

14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        1    
    1      /*M* KX_MACROS_M   Macros for X.25 context templates   */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100,MCL=0     */
    8
    9                          /*F*    NAME:   KX_MACROS_M
   10
   11                          Module KX_MACROS_M contains the macros required to
   12                          create templates for X.25 context.  These include:
   13                              FPT_X25
   14                              KX$L1
   15                              KX$L2
   16                              KX$L3
   17                              KX$DATA
   18                              KX$FRAME
   19                              KX$PACKET
   20
   21                              KX$SL
   22                              KX$LINKDEV
   23                              KX$MSG
   24                              KX$TMRBLK
   25                              KX$CALL_OPTS
   26                              KX$SYSLOG_Q_ENTRY
   27                              KX_STATS
   28                          Also, some code generating macros are included.
   29                          These include:
   30                          DISABLE
   31                          ENABLE
   32                          START_TIMER
   33                          STOP_TIMER
   34                          WRSYSLOG
   35                          */
   36      %EQU KX_EXT = 0;              /* Extended protocol flag - set to 1 for MOD 128                    */
   37                          /*F*    NAME:   DISABLE
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        2    
   38                          DISABLE generates the code needed to call KHI$DISABLE
   39                          to perform a hardware disable instruction.
   40                          */
   41
   42      %MACRO DISABLE;
   43
   44              LEVEL = KH_CTLTBL.PARM.PTR$ ( %KL_HNDLRPARM_INTLVL ) -> BASED_WORD;
   45              CALL KHI$DISABLE ( LEVEL);
   46
   47      %MEND;
   48
   49                          /*F*    NAME:   ENABLE
   50                          ENABLE generates the code to determine if a hardware
   51                          enable instruction needs to be executed, and calls
   52                          KHI$ENABLE if this is true.
   53                          */
   54
   55      %MACRO ENABLE;
   56
   57              IF LEVEL ~= KH_CTLTBL.PARM.PTR$ ( %KL_HNDLRPARM_INTLVL ) -> BASED_WORD
   58              THEN CALL KHI$ENABLE;
   59
   60      %MEND;
   61                          /*F*    NAME:   KX$L1_INNARDS
   62
   63                          KX$L1_INNARDS context is primarily for CCP-related information.
   64                          It includes information about input buffers, output
   65                          buffers being transmitted, and output buffers waiting
   66                          to be transmitted.
   67                          */
   68
   69      %MACRO KX$L1_INNARDS ( LAST = ";" );
   70
   71      %LSET LISTDIR = '0'B;
   72      %LSET LISTEXP = '1'B;
   73      %LSET LISTCOM = '0'B;
   74      %LSET LISTSUB = '1'B;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        3    
   75      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   76      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   77      %IF STC = 1;
   78      %LSET INIT = CHARTEXT(' INIT');
   79      %LSET EINIT = CHARTEXT('');
   80      %ELSE;
   81      %LSET INIT = CHARTEXT('/*');
   82      %LSET EINIT = CHARTEXT('*/');
   83      %ENDIF;
   84      %LSET FEP = BITBIN(MODE_FEP);
   85      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
   86      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
   87      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
   88            2 NEXT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
   89                          /*K*   NEXT$ is used to link together all the X.25
   90                                 L1/L2 context blocks.
   91                          */
   92            2 CHN$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
   93                          /*K*   CHN$ is the pointer to the channel table entry
   94                                 for this context block.
   95                          */
   96            2 BUF_SIZE UBIN BYTE CALIGNED %INIT(0)%EINIT,
   97                          /*K*   BUF_SIZE is the input buffer size for this line.
   98                          */
   99            2 OUT_Q_LEN UBIN BYTE CALIGNED %INIT(0)%EINIT,
  100                          /*K*   OUT_Q_LEN specifies the number of output
  101                                 buffers currently on the ouput queue.
  102                          */
  103            2 TRNST UBIN BYTE CALIGNED %INIT(0)%EINIT,
  104                          /*K*   TRNST is the transmit CCP state.
  105                          */
  106            2 SLCCSTT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  107                          /*K*   SLCCSTT is the SLCC substate.
  108                          */
  109            2 IN_CCB_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  110                          /*K*   IN_CCB_HEAD$ points to the first input buffer.
  111                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        4    
  112            2 IN_CCB_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  113                          /*K*   IN_CCB_TAIL$ points to the last input buffer.
  114                          */
  115            2 OUT_CCB_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  116                          /*K*   OUT_CCB_HEAD$ points to the first output buffer.
  117                          */
  118            2 OUT_CCB_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  119                          /*K*   OUT_CCB_TAIL$ points to the last output buffer.
  120                          */
  121            2 OUT_Q_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  122                          /*K*   OUT_Q_HEAD$ points to the first buffer on the
  123                                 output queue.
  124                          */
  125            2 OUT_Q_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  126                          /*K*   OUT_Q_TAIL$ points to the last buffer on the
  127                                 output queue.
  128                          */
  129            2 SUPV_Q_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  130                          /*K*   SUPV_Q_HEAD$ points to the first buffer on the
  131                                 supervisory queue.
  132                          */
  133            2 SUPV_Q_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT LAST
  134                          /*K*   SUPV_Q_TAIL$ points to the last buffer on the
  135                                 supervisory queue.
  136                          */
  137
  138      %MEND;
  139
  140                          /*F*    NAME:   KX$L1
  141
  142                          KX$L1 is the context block for CCP related information.
  143                          */
  144
  145      %MACRO KX$L1 ( FPTN = KX$L1,
  146          STCLASS = BASED );
  147
  148      %LSET LISTDIR='0'B;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        5    
  149      %LSET LISTEXP='1'B;
  150      %LSET LISTCOM='0'B;
  151      %LSET LISTSUB='1'B;
  152      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  153      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
  154      %LSET INIT=CHARTEXT('INIT');
  155      %LSET EINIT = CHARTEXT ('');
  156      %ELSE;
  157      %LSET INIT=CHARTEXT('/*');
  158      %LSET EINIT = CHARTEXT ('*/');
  159      %ENDIF;
  160
  161      DCL 1 FPTN STCLASS,
  162             %KX$L1_INNARDS;
  163
  164      %MEND;
  165
  166                          /*F*    NAME:   KX$L2
  167
  168                          KX$L2 context is for HDLC frame level information.
  169                          */
  170
  171      %MACRO KX$L2 ( FPTN = KX$L2,
  172          SLCC (YES=1, NO=0) = 0,
  173          STCLASS = BASED );
  174
  175
  176      %LSET LISTDIR = '0'B;
  177      %LSET LISTEXP = '1'B;
  178      %LSET LISTCOM = '0'B;
  179      %LSET LISTSUB = '1'B;
  180      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  181      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  182      %IF STC = 1;
  183      %LSET INIT = CHARTEXT(' INIT');
  184      %LSET EINIT = CHARTEXT('');
  185      %ELSE;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        6    
  186      %LSET INIT = CHARTEXT('/*');
  187      %LSET EINIT = CHARTEXT('*/');
  188      %ENDIF;
  189      %LSET FEP = BITBIN(MODE_FEP);
  190      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  191      %LSET KX_FILBIT = CONCAT('3 * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  192      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
  193
  194      DCL 1 FPTN STCLASS,
  195             %KX$L1_INNARDS ( LAST = "," );
  196            2 K UBIN BYTE CALIGNED %INIT(0)%EINIT,
  197                          /*K*   K is the window size.
  198                          */
  199            2 T1 UBIN BYTE CALIGNED %INIT(0)%EINIT,
  200                          /*K*   T1 is the X.25 frame level timeout value.
  201                          */
  202            2 N2 UBIN BYTE CALIGNED %INIT(0)%EINIT,
  203                          /*K*   N2 is the maximum retransmission value.
  204                          */
  205            2 RC UBIN BYTE CALIGNED %INIT(0)%EINIT,
  206                          /*K*   RC is the current retransmission count.
  207                          */
  208            2 LIC UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  209                          /*K*   LIC specifies the lowest incoming virtual circuit
  210                                 number.
  211                          */
  212            2 HIC UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  213                          /*K*   HIC specifies the highest incoming virtual circuit
  214                                 number.
  215                          */
  216            2 MAXWND UBIN BYTE UNAL %INIT(7)%EINIT,
  217                          /*K*   MAXWND is the maximum window size to allow for
  218                                 any virtual circuits associated with this link.
  219                          */
  220            2 RSPDLY UBIN BYTE UNAL %INIT(1)%EINIT,
  221                          /*K*   RSPDLY is the default response delay to use for
  222                                 incoming calls.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        7    
  223                          */
  224            2 LOC UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  225                          /*K*   LOC specifies the lowest outgoing virtual circuit
  226                                 number.
  227                          */
  228            2 HOC UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  229                          /*K*   HOC specifies the highest outgoing virtual circuit
  230                                 number.
  231                          */
  232            2 STATES UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  233                          /*K*   STATES are the current and last states of the
  234                                 frame level.
  235                          */
  236            2 STATE REDEF STATES,
  237              3 CURRENT UBIN BYTE CALIGNED,
  238                          /*K*   CURRENT is the current state of the frame level.
  239                          */
  240              3 LAST UBIN BYTE CALIGNED,
  241                          /*K*   LAST is the last state of the frame level.
  242                          */
  243            2 ADR_CMND UBIN BYTE CALIGNED %INIT(0)%EINIT,
  244                          /*K*   ADR_CMND is the address to use when sending
  245                                 commands or verifying responses.
  246                          */
  247            2 ADR_RESP UBIN BYTE CALIGNED %INIT(0)%EINIT,
  248                          /*K*   ADR_RESP is the address to use when sending
  249                                 responses or verifying commands.
  250                          */
  251      %IF SLCC=0;
  252            2 HIST,
  253                          /*K*   HIST is the internal history buffer of states,
  254                                 events, and actions.
  255                          */
  256              3 X UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  257                          /*K*   X is the index into the history buffer for
  258                                 the next entry to be inserted.
  259                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        8    
  260              3 STT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
  261                          /*K*   STT is the state history.
  262                          */
  263              3 EVT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
  264                          /*K*   EVT is the event history.
  265                          */
  266              3 ACT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
  267                          /*K*   ACT is the action history.
  268                          */
  269            2 NPR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  270                          /*K*   NPR is N'(R), the next I frame the DCE expects.
  271                          */
  272            2 VS UBIN BYTE CALIGNED %INIT(0)%EINIT,
  273                          /*K*   VS is V(S), the next I frame to send.
  274                          */
  275            2 DCE_I_CNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  276                          /*K*   DCE_I_CNT is the count of DCE I frames that have been
  277                                 received but not yet acknowledged.
  278                          */
  279            2 VR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  280                          /*K*   VR is V(R), the next I frame we expect.
  281                          */
  282      %ELSE;
  283            %KX$CCB (LVL=2, STCLASS=STCLASS, FPTN=P_CCB, LAST=",");
  284                          /*K*   P_CCB is the CCB to use for protocol frames
  285                                 inserted by the SLCC.  For recognition, it
  286                                 must not be a multiple of 8 words into KX$L2.
  287                          */
  288            2 P_FRAME,
  289              3 ADR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  290                          /*K*   P_FRAME is an up-to-8-byte frame built by the
  291                                 SLCC for protocol enforcement.  Subfields are
  292                                 ADR, CTLSI, CTLRPF, FRMR_CTL(0:1), FRMR_VS,
  293                                 FRMR_CRVR, and FRMR_BITS.
  294                           */
  295              3 CTLSI UBIN BYTE CALIGNED %INIT(0)%EINIT,
  296              3 CTLRPF UBIN BYTE CALIGNED %INIT(0)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        9    
  297              3 FRMR_CTL(0:1) UBIN BYTE CALIGNED %INIT(0,0)%EINIT,
  298              3 FRMR_VS UBIN BYTE CALIGNED %INIT(0)%EINIT,
  299              3 FRMR_CRVR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  300              3 FRMR_BITS UBIN BYTE CALIGNED %INIT(0)%EINIT,
  301            2 T1S UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0) %EINIT,
  302                          /*K*   T1S is T1 in SLCC timer units (x60)
  303                          */
  304            2 CCBHD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  305                          /*K*   CCBHD$ is an L6 pointer to the first free CCB.
  306                          */
  307      %ENDIF;
  308            2 FLG,
  309      %KX_FILBIT
  310              3 BLK BIT(1) UNAL %INIT('0'B)%EINIT,
  311                          /*K*   BLK is the blocked flag - the window must be
  312                                 rotated before more I frames can be sent.
  313                          */
  314              3 DCE_BUSY BIT(1) UNAL %INIT('0'B)%EINIT,
  315                          /*K*   DCE_BUSY signifies that the DCE has sent an RNR.
  316                          */
  317              3 REV_CH BIT(1) UNAL %INIT('0'B)%EINIT,
  318                          /*K*   REV_CH indicates whether or not incoming calls
  319                                 that ask for reverse charging may be accpeted.
  320                          */
  321              3 DCE BIT(1) UNAL %INIT('0'B)%EINIT,
  322                          /*K*   DCE specifies whether we are acting like a DCE
  323                                 or a DTE.
  324                          */
  325              3 OK BIT(1) UNAL %INIT('0'B)%EINIT,
  326                          /*K*   OK is used to indicate quickly that the frame
  327                                 level is in state normal.
  328                          */
  329              3 POLL_R BIT(1) UNAL %INIT('0'B)%EINIT,
  330                          /*K*   POLL_R indicates that the poll bit was on in the
  331                                 input frame currently being processed.
  332                          */
  333              3 POLL_S BIT(1) UNAL %INIT('0'B)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        10   
  334                          /*K*   POLL_S indicates whether we sent a command with the
  335                                 poll bit set.
  336                          */
  337              3 DCE_REJ BIT(1) UNAL %INIT('0'B)%EINIT,
  338                          /*K*   DCE_REJ specifies that the DCE has sent a reject frame.
  339                          */
  340      %KX_FILBIT
  341              3 DTE_BUSY BIT(1) UNAL %INIT('0'B)%EINIT,
  342                          /*K*   DTE_BUSY specifies that the interface is to respond
  343                                 with RNR instead of RR.
  344                          */
  345              3 DTE_REJ BIT(1) UNAL %INIT('0'B)%EINIT,
  346                          /*K*   DTE_REJ indicates that a reject frame has been sent
  347                                 to the DCE.
  348                          */
  349              3 ACPX25 BIT(1) UNAL %INIT('1'B)%EINIT,
  350                          /*K*   ACPX25 specifies whether incoming calls with
  351                                 an X.25 defined protocol type should be accepted.
  352                          */
  353              3 ACPX29 BIT(1) UNAL %INIT('1'B)%EINIT,
  354                          /*K*   ACPX29 specifies whether incoming calls with
  355                                 an X.29 protocol type should be accepted.
  356                          */
  357              3 RESTART BIT(1) UNAL %INIT('0'B)%EINIT,
  358                          /*K*   RESTART indicates to the packet level that a RESTART
  359                                 sequence is in progress.
  360                          */
  361              3 RESTART_PEND BIT(1) UNAL %INIT('0'B)%EINIT,
  362                          /*K*   RESTART_PEND indicates to the packet level that a
  363                                 RESTART sequence is pending.
  364                          */
  365              3 DATAVL BIT(1) UNAL %INIT('1'B)%EINIT,
  366                          /*K*   DATAVL is the flag specifying whether or not
  367                                 the associated level 3s have any data ready
  368                                 for transmission.
  369                          */
  370              3 LSTSGNCLK BIT(1) UNAL %INIT('0'B)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        11   
  371                          /*K*   LSTSGNCLK is the flag specifying whether or not
  372                                 we have already started a clock for timing out
  373                                 lost of line signals.
  374                          */
  375              %KX_FILBIT
  376              3 EXTSEQ BIT(1) UNAL %INIT('0'B)%EINIT,
  377                          /*K*   EXTSEQ is the flag specifying whether or not
  378                                 extended frame sequence numbers are used
  379                          */
  380              3 FSTSLCACP BIT(1) UNAL %INIT('1'B)%EINIT,
  381                          /*K*   FSTSLCACP is the flag specifying whether or not
  382                                 we will accept fast select calls on this link
  383                          */
  384              3 CHRINF BIT(1) UNAL %INIT('0'B)%EINIT,
  385                          /*K*   CHRINF is the flag specifying whether or not
  386                                 we will request charging information on incoming
  387                                 virtual circuits.
  388                          */
  389            2 MAXCCB UBIN(5) UNAL %INIT(4)%EINIT,
  390                          /*K*   MAXCCB is max number of CCBs the controller
  391                                 can handle. 4 is the limit for MLC8 while
  392                                 MLC16s can hold 8. We should pick a reasonable
  393                                 number for SLCC.
  394                           */
  395            2 I_CNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  396                          /*K*   I_CNT is the count of unacknowledged I frames.
  397                          */
  398            2 I_LIST_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  399                          /*K*   I_LIST_HEAD$ points to the first unacknowledged
  400                                 I frame.
  401                          */
  402            2 I_LIST_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  403                          /*K*   I_LIST_TAIL$ points to the last unacknowledged
  404                                 I frame.
  405                          */
  406            2 L3_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  407                          /*K*   L3_HEAD$ points to the first level 3 context
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        12   
  408                                 associated with this line.
  409                          */
  410            2 L3_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  411                          /*K*   L3_TAIL$ points to the last level 3 context
  412                                 associated with this line.
  413                          */
  414            2 FRMR_CTL UBIN(%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  415                          /*K*   FRMR_CTL is the control field to send along on
  416                                 FRMR frames.
  417                          */
  418            2 FRMR_BITS UBIN BYTE CALIGNED %INIT(0)%EINIT,
  419                          /*K*   FMRM_BITS is the identifying information to send
  420                                 along with FRMR frames.
  421                          */
  422            2 NTWADR CALIGNED,
  423                          /*K*   NTWADR is the network address structure for
  424                                 this endpoint. Also the CALLING address
  425                                 in call request packets for all VC's on
  426                                 this link.
  427                          */
  428              3 LNG UBIN BYTE CALIGNED %INIT(0)%EINIT,
  429                          /*K*   LNG is the length of the network address in
  430                                 BCD digits.
  431                          */
  432              3 ADR_STRING CHAR(7) CALIGNED,
  433              3 ADR_PAIR (0:6) REDEF ADR_STRING UBIN BYTE CALIGNED,
  434                          /*K*   ADR_PAIR is the network address of this endpoint in
  435                                 pairs of BCD digits.
  436                          */
  437            %KX$TMRBLK ( FPTN = TMRBLK, LVL = 2, STCLASS = STCLASS, LAST=",",
  438                         SBR = "ENTADDR(KXF$FRAME)", SBRPRM = %KX_F_EV_TO# );
  439                          /*K*   TMRBLK is the context for chaining this
  440                                 context onto the general purpose timer
  441                                 routine.
  442                          */
  443            %KX$TMRBLK ( FPTN = T20TMR, LVL = 2, STCLASS = STCLASS, LAST=",",
  444                         SBR = "ENTADDR(KXF$FRAME)", SBRPRM = %KX_F_EV_T20# );
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        13   
  445                          /*K*   T20TMR is the context for chaining this
  446                                 context onto the general purpose timer
  447                                 routine.
  448                          */
  449              2 ERRLOGWRDCNT UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  450                          /*K*   ERRLOGWRDCNT is number of words used for queueing
  451                                 errlog entries for this line.
  452                          */
  453                2 FRMR_NSNR UBIN(%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  454                          /*K*   FRMR_NSNR is the N(S) and N(R) word to send along
  455                                 on FMR frames.
  456                          */
  457                2 FRMR_NSNR_REDEF REDEF FRMR_NSNR,
  458                3 * UBIN(%(17-2*FEP)) UNAL,
  459                3 CR BIT(1) UNAL,
  460                2 R20_CNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  461                          /*K*   R20_CNT is counter for number of T20 timer
  462                                 time outs.
  463                          */
  464                2 R20 UBIN BYTE CALIGNED %INIT(%KX_X25RCNT_RESTART#)%EINIT,
  465                          /*K*   R20 is number of retries of the restart
  466                                 request before other corrective actions.
  467                                 (In our case, start the link again.)
  468                          */
  469                2 T20 UBIN BYTE CALIGNED %INIT(%KX_X25TMR_RESTART_PRD#)%EINIT,
  470                          /*K*   T20 is number of seconds for the T20
  471                                 timer.
  472                          */
  473                2 IDL_PRD UBIN BYTE CALIGNED %INIT(%KX_X25TMR_IDL_PRD#)%EINIT,
  474                          /*K*   IDL_PRD is number of seconds the link is
  475                                 allowed to be idle before polling frames
  476                                 are sent.
  477                          */
  478                2 IDL_CLK UBIN BYTE CALIGNED %INIT(0)%EINIT,
  479                          /*K*   IDL_CLK is number of seconds left before
  480                                 link assurance actions take place.
  481                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        14   
  482                2 REJ_CNT UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  483                          /*K*   REJ_CNT is number of REJs received during
  484                                 the current interval (of 1 minute).
  485                          */
  486                %KL_VIRCIR ( NAME = DFLVCPRF, STCLASS = STCLASS, LVL = 2, LAST = "," );
  487                          /*K*   DFLVCPRF is the default virtual circuit profile for
  488                                 VCs on this link.
  489                          */
  490            2 DSTSNPA CALIGNED,
  491              3 LNG UBIN BYTE CALIGNED %INIT(0)%EINIT,
  492              3 ADR_STRING CHAR(7) CALIGNED,
  493              3 ADR_PAIR (0:6) REDEF ADR_STRING UBIN BYTE CALIGNED,
  494                          /*K*   DSTSNPA is the group of x.121 addresses that this link
  495                                 can reach. Usually is the DNIC of a PDN.
  496                          */
  497            2 LDCTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  498                          /*K*   LDCTX is the used if DSTSNPA is not empty, to
  499                                 identify the connection with the network layer.
  500                          */
  501            2 QOS UBIN BYTE CALIGNED %INIT(2)%EINIT,
  502                          /*K*   QOS is the quality of service of this link. It
  503                                 is set in SUPER when the link is created.
  504                          */
  505      %IF NOT MODE_FEP;
  506            2 * BIT(1) %INIT('0'B)%EINIT,
  507      %ENDIF;
  508            2 INIT_ALTRET BIT (1) UNAL %INIT('0'B)%EINIT,
  509                          /*K*   INIT_ALTRET indicates that the last attempt to
  510                                 send an INIT to network failed.
  511                          */
  512            2 TERM_ALTRET BIT (1) UNAL %INIT('0'B)%EINIT,
  513                          /*K*   TERM_ALTRET indicates that the last attempt to
  514                                 send a TERM to network failed.
  515                          */
  516            2 TERMACKPND BIT (1) UNAL %INIT('0'B)%EINIT,
  517                          /*K*   TERMACKPND indicates that this L2 is waiting for
  518                                 a TERM_ACK from network. Valid only when DSTSNPA
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        15   
  519                                 is not empty.
  520                          */
  521            2 RLS_TERMACKPND BIT (1) UNAL %INIT('0'B)%EINIT,
  522                          /*K*   RLS_TERMACKPND indicates that when a TERM_ACK is
  523                                 received from network, this L2 can be released.
  524                                 Valid only when DSTSNPA is not empty.
  525                          */
  526            2 * BIT(4) %INIT('0'B)%EINIT,
  527            2 DVC_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  528                          /*K*   DVC_HEAD$ is the head pointer to the list of LINKDEVs.
  529                          */
  530            2 DVC_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  531                          /*K*   DVC_TAIL$ is the tail pointer to the list of LINKDEVs.
  532                          */
  533            2 * CHAR(6) CALIGNED,
  534                                    /*     3 word filler to align trace buffer.
  535                                    */
  536      %IF SLCC=0;                   /* The SLCC has no trace buffer here                                */
  537            2 TRCX UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  538                          /*K*  TRCX is the index into the trace buffer
  539                          */
  540            2 TRC (0:199) UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0*0)%EINIT;
  541                          /*K*  TRC is the trace buffer. Each frame trace uses
  542                                4 words. Hence buffer is for 50 frames.
  543                          */
  544      %ELSE;
  545            2 L2$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  546                          /*K*   L2$ for the SLCC is the beginning of the total
  547                                 buffer allocated for L2 and CCBs.  L2 must be
  548                                 on a 128-word boundary, so it isn't the same
  549                                 as the pointer in the channel table.
  550                          */
  551            2 L2SIZ UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  552                          /*K*   L2SIZ is the size used to allocate the buffer
  553                                 for the SLCC.  It will be used again to release
  554                                 it.
  555                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        16   
  556            2 XMTCCB,
  557              3 HEAD UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  558                          /*K*   XMTCCB.HEAD heads the chain of CCBs currently
  559                                 owned by the SLCC.  Set by KXN if zero.
  560                          */
  561              3 TAIL UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  562                          /*K*   XMTCCB.TAIL ends the chain of CCBs still
  563                                 in use by the SLCC.   Set by KXN.
  564                          */
  565              3 LOCK SBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  566                          /*K*   XMTCCB.LOCK is used to prevent the FEP and SLCC
  567                                 from updating the Next-Queue at the same time.
  568                                 Decremented by the FEP to lock out the SLCC,
  569                                 set to 2 by the SLCC.  SLCC waits if the "2"
  570                                 bit is already set,  FEP waits until the value
  571                                 goes from zero to -1.
  572                          */
  573              3 NEXT UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  574                          /*K*   XMTCCB.NEXT is set by FEP when zero to the next
  575                                 CCB that needs to get into the SLCC queues.
  576                                 Zeroed by SLCC when the chain from NEXT to TAIL
  577                                 has been queued up.
  578                          */
  579            2 COMBUF,
  580                          /*K*   COMBUF is used to communicate info from
  581                                 the SLCC to the FEP.  The SLCC sets DATAVL
  582                                 when it has info to send.  The FEP sets FEPRDY
  583                                 and FEPBSY and uses the data in DAT.
  584                                 FNC denotes what the info is.  When done,
  585                                 the FEP resets FEPBSY.  SLCC uses and resets
  586                                 FEPRDY to gate the info.  (Currently only STATS).
  587                          */
  588      %KX_FILBIT
  589              3 DATAVL BIT(1) %INIT('0'B)%EINIT,
  590              3 FEPRDY BIT(1) %INIT('0'B)%EINIT,
  591              3 FEPBSY BIT(1) %INIT('0'B)%EINIT,
  592              3 * BIT(5) %INIT('0'B)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        17   
  593      %KX_FILBIT
  594              3 FNC BIT(8) %INIT('0'B)%EINIT,
  595              3 DAT(0:15) UBIN BYTE CALIGNED %INIT(0*0)%EINIT;
  596      %ENDIF;
  597
  598      %MEND;
  599
  600                          /*F*    NAME:   KX$L3
  601
  602                          KX$L3 is for level 3 context.  It contains the information
  603                          necessary for operation of a single virtual circuit.
  604                          */
  605
  606      %MACRO KX$L3 ( FPTN = KX$L3,
  607          STCLASS = BASED );
  608
  609
  610      %LSET LISTDIR = '0'B;
  611      %LSET LISTEXP = '1'B;
  612      %LSET LISTCOM = '0'B;
  613      %LSET LISTSUB = '1'B;
  614      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  615      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  616      %IF STC = 1;
  617      %LSET INIT = CHARTEXT(' INIT');
  618      %LSET EINIT = CHARTEXT('');
  619      %ELSE;
  620      %LSET INIT = CHARTEXT('/*');
  621      %LSET EINIT = CHARTEXT('*/');
  622      %ENDIF;
  623      %LSET FEP = BITBIN(MODE_FEP);
  624      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  625      %LSET KX_FILBIT2 = CONCAT('2 * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  626      %LSET KX_FILBIT3 = CONCAT('3 * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  627      %LSET KX_FILBIT2 = CHARTEXT(SUBSTR(KX_FILBIT2, FEP*LENGTHC(KX_FILBIT2)));
  628      %LSET KX_FILBIT3 = CHARTEXT(SUBSTR(KX_FILBIT3, FEP*LENGTHC(KX_FILBIT3)));
  629
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        18   
  630      DCL 1 FPTN STCLASS,
  631            2 NEXT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  632                          /*K*   NEXT$ is the pointer to the next virtual circuit
  633                                 associated with the same line.
  634                          */
  635            2 L2$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  636                          /*K*   L2$ is the pointer to the L2 context.
  637                          */
  638            2 CM$ PTR %KX_DBLBYTALG  %INIT(ADDR(NIL))%EINIT,
  639                          /*K*   CM$ is the pointer to Connection Manager context.
  640                          */
  641            2 CHN$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  642                          /*K*   CHN$ is the pointer to the channel table
  643                                 associated with this VC.
  644                          */
  645            2 IN_ CALIGNED,
  646                          /*K*   IN_ is the area for keeping track of incoming
  647                                 data reconstruction.
  648                          */
  649              3 ADR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  650                          /*K*   ADR$ is the pointer to the data buffer.
  651                          */
  652              3 BYTX SBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  653                          /*K*   BYTX is the offset into the data buffer to the
  654                                 first meaningful byte.
  655                          */
  656              3 BYTSIZ UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  657                          /*K*   BYTSIZ is the size of the data in the data buffer.
  658                          */
  659              3 BFRSIZ UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  660                          /*K*   BFRSIZ is the size of the data buffer.
  661                          */
  662            2 OUT_ CALIGNED,
  663                          /*K*   OUT_ is the area for keeping track of outgoing
  664                                 data fragmentation.
  665                          */
  666              3 ADR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        19   
  667                          /*K*   ADR$ is the pointer to the data buffer.
  668                          */
  669              3 BYTX SBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  670                          /*K*   BYTX is the offset into the data buffer to the
  671                                 first meaningful byte.
  672                          */
  673              3 BYTSIZ UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  674                          /*K*   BYTSIZ is the size of the data in the data buffer.
  675                          */
  676              3 BFRSIZ UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  677                          /*K*   BFRSIZ is the size of the data buffer.
  678                          */
  679            2 NOD UBIN BYTE CALIGNED %INIT(255)%EINIT,
  680                          /*K*   NOD is the node number that the VC connects to.
  681                          */
  682            2 QOS UBIN BYTE CALIGNED %INIT(2)%EINIT,
  683                          /*K*   QOS is the quality of service this VC provides.
  684                                 It is a SUPER option. For a VC created on
  685                                 demand, it defaults to 2.
  686                          */
  687            2 TYP UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  688                          /*K*   TYP is the type of VC.  This is only meaningful
  689                                 for SUPER-defined VCs.
  690                          */
  691             %KX$CALL_OPTS ( FPTN = CALL_OPTS, LVL = 2, LAST = "," , STCLASS = STCLASS );
  692                          /*K*   CALL_OPTS are the call options that have been
  693                                 (or are being) agreed to for the duration of
  694                                 the call.
  695                          */
  696             %KX$CALL_OPTS ( FPTN = CM_OPTS, LVL = 2, LAST = ",", STCLASS = STCLASS );
  697                          /*K*   CM_OPTS are the call options that the
  698                                 connection manager has specified to use for
  699                                 this VC until further notice.
  700                          */
  701             %KX$CALL_OPTS ( FPTN = DFL_OPTS, LVL = 2, LAST = ",", STCLASS = STCLASS );
  702                          /*K*   DFL_OPTS are the original call options as
  703                                 specified by SUPER.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        20   
  704                          */
  705              %KX_FILBIT2
  706                2 DATA BIT(1) %INIT('0'B)%EINIT,
  707                          /*K*   DATA is the data available from the Connection
  708                                 Manager flag.
  709                          */
  710                2 INTPND BIT(1) %INIT('0'B)%EINIT,
  711                          /*K*   INTPND is the interrupt confirmation packet
  712                                 pending flag.
  713                          */
  714                2 BLK BIT(1) %INIT('0'B)%EINIT,
  715                          /*K*   BLK is the flag for send window exhausted.
  716                          */
  717                2 MAYBE BIT(1) %INIT('0'B)%EINIT,
  718                          /*K*   MAYBE is the flag for a call to RLSL3_MAYBE
  719                                 that could not be released.
  720                          */
  721                2 RNR BIT(1) UNAL %INIT('0'B)%EINIT,
  722                          /*K*   RNR specifies whether we are flow controlled by the other end.
  723                          */
  724                2 RLSCHN BIT(1) UNAL %INIT('0'B)%EINIT,
  725                          /*K*   RLSCHN specifies whether KH$CHN is to be released or not
  726                          */
  727                2 INPBLK BIT(1) UNAL %INIT('0'B)%EINIT,
  728                          /*K*   INPBLK when set specifies CM is not ready for input
  729                          */
  730                2 PVC BIT(1) UNAL %INIT('0'B)%EINIT,
  731                          /*K*   PVC indicates when set that this is a permanet VC
  732                          */
  733                %KX_FILBIT2
  734                2 FSTSLC UBIN(2) UNAL %INIT(0)%EINIT,
  735                          /*K*   FSTSLC indicates choice of fast select facility and
  736                                 the restriction on response.
  737                          */
  738                2 EXTSEQ BIT(1) UNAL %INIT('0'B)%EINIT,
  739                          /*K*   EXTSEQ when set specifies use of extended seq#.
  740                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        21   
  741                2 CHRINF BIT(1) UNAL %INIT('0'B)%EINIT,
  742                          /*K*   CHRINF indicates when set that charging information
  743                                 will be requested on this virtual circuit.
  744                          */
  745                2 CUGLNG UBIN(2) UNAL %INIT(0)%EINIT,
  746                          /*K*   CUGLNG specifies number of digits in CUG.
  747                          */
  748                2 RSPTOCMP BIT(1) %INIT('1'B)%EINIT,
  749                          /*K*   RSPTOCMP specifies that any incoming data
  750                                 packets that are not continued should be
  751                                 acknowledged regardless of RSPDLY.
  752                          */
  753                2 RVS BIT(1) %INIT('0'B)%EINIT,
  754                          /*K*   RVS specifies that reverse charges are to be
  755                                 specified in the outgoing call.
  756                                 If this is a remote VC, this bit will say
  757                                 whether reverse charging was specified in
  758                                 the incoming call packet.
  759                          */
  760                %KX_FILBIT2
  761                2 IN_QBIT BIT(1) %INIT('0'B)%EINIT,
  762                          /*K*   IN_QBIT indicates Q bit setting of the data in IN_.
  763                          */
  764                2 OUT_QBIT BIT(1) %INIT('0'B)%EINIT,
  765                          /*K*   OUT_QBIT indicates Q bit setting of the data in OUT_.
  766                          */
  767                2 IN_MBIT BIT(1) %INIT('0'B)%EINIT,
  768                          /*K*   IN_MBIT indicates M bit setting of the data in IN_.
  769                          */
  770                2 OUT_MBIT BIT(1) %INIT('0'B)%EINIT,
  771                          /*K*   OUT_MBIT indicates M bit setting of the data in OUT_.
  772                          */
  773                2 LCN# UBIN(%(13-FEP)) UNAL %INIT(0)%EINIT,
  774                2 LCN REDEF LCN#,
  775                3 LCGN UBIN(4) UNAL,
  776                          /*K*   LCGN is the logical channel group number.
  777                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        22   
  778                3 LCN UBIN BYTE UNAL,
  779                          /*K*   LCN is the logical channel number.
  780                          */
  781                2 CUG UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  782                          /*K*   CUG is the closed user group to specify on
  783                                 Call packets (2 or 4 BCD digits).
  784                          */
  785                2 CUG_BCD REDEF CUG,
  786                          /*K*   CUG_BCD is the CUG redefined as BCD digits.
  787                          */
  788                3 BCDPAIR1 UBIN BYTE CALIGNED,
  789                                    /* contains BCD digits 1 and 2.
  790                                    */
  791                3 BCDPAIR2 UBIN BYTE CALIGNED,
  792                                    /* contains BCD digits 3 and 4.
  793                                    */
  794                2 TRNDLY UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  795                          /*K*   TRNDLY when none zero is the value of delay used in
  796                                 transit delay facility on this outgoing circuit.
  797                          */
  798                2 TRNDLYBYT REDEF TRNDLY,
  799                3 LFT UBIN BYTE UNAL,
  800                3 RGH UBIN BYTE UNAL,
  801                2 TRNDLYIND UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  802                          /*K*   TRNDLYIND stores the transit delay indication
  803                                 value from the network. Only meaningful if TRNDLY
  804                                 is non-zero.
  805                          */
  806                2 TRNDLYINDBYT REDEF TRNDLYIND,
  807                3 LFT UBIN BYTE UNAL,
  808                3 RGH UBIN BYTE UNAL,
  809                2 DCNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  810                          /*K*   DCNT is the number of outstanding data packets.
  811                          */
  812                2 PPR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  813                          /*K*   PPR is P'(R), the last data expect the other end
  814                                 expects to receive without rotating the window.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        23   
  815                          */
  816                2 VS UBIN BYTE CALIGNED %INIT(0)%EINIT,
  817                          /*K*   VS is V(S), the next data packet to send.
  818                          */
  819                2 VR UBIN BYTE CALIGNED %INIT(0)%EINIT,
  820                          /*K*   VR is V(R), the next data packet we expect.
  821                          */
  822                2 DCNTP UBIN BYTE CALIGNED %INIT(0)%EINIT,
  823                          /*K*   DCNTP is the count of received data packets
  824                                 that have not yet been acknowledged.
  825                          */
  826                2 DEVNUM UBIN BYTE CALIGNED %INIT(0)%EINIT,
  827                          /*K*   DEVNUM is a copy of the same named field in the
  828                                 KL_LNKVC structure that created this L3 context.
  829                                 This is really used in D00 interim colour book
  830                                 package only, but here is occupies an otherwise
  831                                 slack byte. So it should not bother anyone.
  832                          */
  833                2 STATES UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
  834                          /*K*   STATES are the current and previous states.
  835                          */
  836                2 STATE REDEF STATES,
  837                3 CURRENT UBIN BYTE CALIGNED,
  838                          /*K*   CURRENT is the current state of this circuit.
  839                          */
  840                3 LAST UBIN BYTE CALIGNED,
  841                          /*K*   LAST is the previous state of this circuit.
  842                          */
  843                2 HIST,
  844                          /*K*   HIST is the internal history buffer of states,
  845                                 events, and actions.
  846                          */
  847                3 X UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%EINIT,
  848                          /*K*   X is the index into the history buffer for
  849                                 the next entry to be inserted.
  850                          */
  851                3 STT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        24   
  852                          /*K*   STT is the state history.
  853                          */
  854                3 EVT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
  855                          /*K*   EVT is the event history.
  856                          */
  857                3 ACT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
  858                          /*K*   ACT is the action history.
  859                          */
  860                2 CTL_Q_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  861                          /*K*   CTL_Q_HEAD$ points to the first buffer on the ctl pkt queue.
  862                          */
  863                2 CTL_Q_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  864                          /*K*   CTL_Q_TAIL$ points to the last buffer on the ctl pkt queue.
  865                          */
  866                2 RTR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  867                          /*K*   RTR$ points to the first data packet to retransmit.
  868                          */
  869                2 D_LIST_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  870                          /*K*   D_LIST_HEAD$ points to the first unacknowledged
  871                                 data packet.
  872                          */
  873                2 D_LIST_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  874                          /*K*   D_LIST_TAIL$ points to the last unacknowledged
  875                                 data packet.
  876                          */
  877                2 INP_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  878                          /*K*   INP_HEAD$ points to the first input
  879                                 data packet waiting to be processed.
  880                          */
  881                2 INP_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
  882                          /*K*   INP_TAIL$ points to the last input
  883                                 data packet waiting to be processed.
  884                          */
  885                %KX$TMRBLK ( FPTN = TMRBLK, LVL = 2, STCLASS = STCLASS, LAST=",",
  886                SBR = "ENTADDR(KXP$PACKET)", SBRPRM = %KX_P_EV_TO# );
  887                          /*K*   TMRBLK is the timer block for setting a
  888                                 clock associated with this virtual circuit.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        25   
  889                          */
  890              %KX$TMRBLK ( FPTN = DATTMRBLK, LVL = 2, STCLASS = STCLASS, LAST=",",
  891              SBR = "ENTADDR(KXP$PACKET)", SBRPRM = %KX_P_EV_DATTMR# );
  892                          /*K*   DATTMRBLK is the timer block for detecting
  893                                 unacknowledged data packets.
  894                          */
  895              %KX$TMRBLK ( FPTN = INTTMRBLK, LVL = 2, STCLASS = STCLASS, LAST=",",
  896              SBR = "ENTADDR(KXP$PACKET)", SBRPRM = %KX_P_EV_INTTMR# );
  897                          /*K*   INTTMRBLK is the timer block for detecting
  898                                 unacknowledged interrupt packets.
  899                          */
  900            2 T21 UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(%KX_X25TMR_CALL_PRD#)%EINIT,
  901                          /*K*   T21 is the period of the call timer in seconds.
  902                          */
  903            2 T22 UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(%KX_X25TMR_RESET_PRD#)%EINIT,
  904                          /*K*   T22 is the period of the reset timer in seconds.
  905                          */
  906            2 T23 UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(%KX_X25TMR_CLEAR_PRD#)%EINIT,
  907                          /*K*   T23 is the period of the clear timer in seconds.
  908                          */
  909            2 T25 UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(%KX_X25TMR_DATA_PRD#)%EINIT,
  910                          /*K*   T25 is the period of the data packet timer in
  911                                 seconds.
  912                          */
  913            2 T26 UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(%KX_X25TMR_INTERRUPT_PRD#)%EINIT,
  914                          /*K*   T26 is the period of the interrupt packet timer in
  915                                 seconds.
  916                          */
  917            2 R21 UBIN BYTE CALIGNED %INIT(%KX_X25RCNT_CALL#)%EINIT,
  918                          /*K*   R21 is the maximum number of consecutive
  919                                 unsuccessful calls to attempt before declaring
  920                                 the VC to be unusable. CP6 parameter.
  921                          */
  922            2 R22 UBIN BYTE CALIGNED %INIT(%KX_X25RCNT_RESET#)%EINIT,
  923                          /*K*   R22 is the maximum number of reset packets
  924                                 to try before clearing the circuit.
  925                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        26   
  926            2 R23 UBIN BYTE CALIGNED %INIT(%KX_X25RCNT_CLEAR#)%EINIT,
  927                          /*K*   R23 is number of retries of the clear req
  928                                 packet before a restart will be tried.
  929                          */
  930            2 R25 UBIN BYTE CALIGNED %INIT(%KX_X25RCNT_DATA#)%EINIT,
  931                          /*K*   R25 is number of retries of unacknowledged data
  932                                 packets before ??
  933                          */
  934            2 RTRCNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
  935                          /*K*   RTRCNT is the number of retries of type R21, R22,
  936                                 R23 or R25. What it is tracking depends on the
  937                                 state of the circuit.
  938                          */
  939            2 RSPDLY UBIN BYTE CALIGNED %INIT(1)%EINIT,
  940                          /*K*   RSPDLY is the number of
  941                                 unacknowledged data packets to recive before
  942                                 sending an acknowledgement.
  943                          */
  944            2 RSPTMR UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(1)%EINIT,
  945                          /*K*   RSPTMR is the number of seconds to wait after
  946                                 RSPDLY or RSPTOCMP has been noticed but before
  947                                 sending an explicit flow control packet.
  948                          */
  949            2 CALDLY UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(60)%EINIT,
  950                          /*K*   CALDLY is the number of seconds to wait after
  951                                 completing a clear procedure before starting
  952                                 a call procedure.
  953                          */
  954            2 TOACT UBIN BYTE CALIGNED %INIT(%KX_L3_TOACT_RSTRTR#)%EINIT,
  955                          /*K*   TOACT is the action to be taken when a data
  956                                 packet times out. See %KX_L3_TOACT_?.
  957                          */
  958            2 IDLPRD UBIN BYTE CALIGNED %INIT(0)%EINIT,
  959                          /*K*   IDLPRD is the amount of time this switched virtual
  960                                 circuit is allowed to idle before being disconnected.
  961                          */
  962            2 IDLCLK UBIN BYTE CALIGNED %INIT(0)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        27   
  963                          /*K*   IDLCLK is the number of seconds this virtual circuit
  964                                 is still allowed to idle before being disconnected.
  965                          */
  966      %KX_FILBIT2
  967            2 NOREASM BIT(1) UNAL %INIT('0'B)%EINIT,
  968                          /*K*   NOREASM indicates to L3 that it should not reassemble
  969                                 packet sequences but just pass M bit packets up.
  970                          */
  971            2 CLRCPND BIT (1) %INIT('0'B)%EINIT,
  972                          /*K*   CLRCPND set means a clear confirm packet is being
  973                                 held until disconnecting with VDH is completed.
  974                          */
  975            2 WNDNGT BIT (1) %INIT('0'B)%EINIT,
  976                          /*K*   WNDNGT set means window negotiation is to be used
  977                                 when making or accepting calls.
  978                          */
  979            2 PCKNGT BIT (1) %INIT('0'B)%EINIT,
  980                          /*K*   PCKNGT set means packet size negotiation is to be
  981                                 used when making or accepting calls.
  982                          */
  983            2 CALL_COLLISION BIT (1) %INIT('0'B)%EINIT,
  984                          /*K*   CALL_COLLISION set means call collision has
  985                                 occurred.
  986                          */
  987            2 LCLADR CALIGNED,
  988                          /*K*   LCLADR is our network address.
  989                          */
  990              3 SIZ UBIN BYTE CALIGNED %INIT(0)%EINIT,
  991                          /*K*   SIZ specifies how many of the BCD digits in
  992                                 ADR are valid.
  993                          */
  994              3 ADR_STRING CHAR(7) CALIGNED,
  995                          /*K*   defined as char string for ease of comparison                          */
  996              3 ADR_PAIR(0:6) REDEF ADR_STRING UBIN BYTE CALIGNED,
  997                          /*K*   redef for coding convenience.
  998                          */
  999              %FPT_NSAP ( FPTN = LCLNSAP, ADRTYP = NET, STCLASS = STCLASS,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        28   
 1000              LVL = 2, LAST = "," );
 1001            2 LCLNSAP_REDEF REDEF LCLNSAP,
 1002              3 NSAP CHAR(22) CALIGNED,
 1003                          /*K*   LCLNSAP is the local NSAP address extension.
 1004                          */
 1005              %FPT_NSAP ( FPTN = RMTNSAP, ADRTYP = NET, STCLASS = STCLASS,
 1006              LVL = 2, LAST = "," );
 1007            2 RMTNSAP_REDEF REDEF RMTNSAP,
 1008              3 NSAP CHAR(22) CALIGNED;
 1009                          /*K*   RMTNSAP is the remote NSAP address extension.
 1010                          */
 1011
 1012      %MEND;
 1013
 1014
 1015                          /*F*    NAME:   KX$SL
 1016
 1017                          KX$SL is the context block for maintaining the association
 1018                          between a VC and the Network layer. SL stands for Single
 1019                          Link, just because we used to have an ML.
 1020                          */
 1021
 1022      %MACRO KX$SL ( FPTN = KX$SL,
 1023                      STCLASS = BASED,
 1024                      ALGN = ALIGNED );
 1025
 1026
 1027      %LSET LISTDIR = '0'B;
 1028      %LSET LISTEXP = '1'B;
 1029      %LSET LISTCOM = '0'B;
 1030      %LSET LISTSUB = '1'B;
 1031      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1032      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1033      %IF STC = 1;
 1034      %LSET INIT = CHARTEXT(' INIT');
 1035      %LSET EINIT = CHARTEXT('');
 1036      %ELSE;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        29   
 1037      %LSET INIT = CHARTEXT('/*');
 1038      %LSET EINIT = CHARTEXT('*/');
 1039      %ENDIF;
 1040      %LSET FEP = BITBIN(MODE_FEP);
 1041      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1042      %LSET KX_FILBIT = CONCAT('2 * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1043      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 1044      DCL 1 FPTN STCLASS ALGN,
 1045            2 SBR$ EPTR %KX_DBLBYTALG %INIT(ENTADDR(KXV$VCNTW))%EINIT,
 1046                          /*K*   SBR$ is the entry pointer of the subroutine
 1047                                 that owns this piece of context, i.e. KXV$VCNTW.
 1048                          */
 1049            2 LNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1050                          /*K*   LNK$ is the link to other KX$SL blocks.
 1051                          */
 1052            2 L3$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1053                          /*K*   L3$ is the pointer to the L3 context.
 1054                          */
 1055            2 OTPBFR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1056                          /*K*   OTPBFR$ points to THE output buffer owned by
 1057                                 this SL. This is the place where concatenating
 1058                                 is performed.
 1059                          */
 1060            2 SCN_L3$ REDEF OTPBFR$ PTR %KX_DBLBYTALG,
 1061                          /*K*   SCN_L3$ is the pointer to the second L3 context.
 1062                                 Meaningful only for redirected circuits, which
 1063                                 do not use OTPBFR$.
 1064                          */
 1065            2 PRTID UBIN BYTE CALIGNED %INIT(%KX_PRTID_SL#)%EINIT,
 1066                          /*K*   PRTID is the protocol id.
 1067                          */
 1068            2 LCLNOD UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1069                          /*K*   LCLNOD is the source node number
 1070                          */
 1071            2 RMTNOD UBIN BYTE CALIGNED %INIT(255)%EINIT,
 1072                          /*K*   RMTNOD is the destinnation node number
 1073                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        30   
 1074            %KX_FILBIT
 1075            2 RPRDAT BIT(1) UNAL %INIT('0'B)%EINIT,
 1076                          /*K*   RPRDAT is set whenever SL should
 1077                                 report DATAVL to the Packet level.  Otherwise,
 1078                                 Packet will request data when it can accept it.
 1079                          */
 1080            2 NTWBLK BIT(1) UNAL %INIT('0'B)%EINIT,
 1081                          /*K*   NTWBLK is set after a CQ BLOCK message has been
 1082                                 sent to the Network layer.
 1083                          */
 1084            2 SNDDAT_ALTRET BIT(1) UNAL %INIT('0'B)%EINIT,
 1085                          /*K*   SNDDAT_ALTRET indicates that the last attempt
 1086                                 to put data on CQ failed.
 1087                          */
 1088            2 SNDINT_ALTRET BIT(1) UNAL %INIT('0'B)%EINIT,
 1089                          /*K*    SNDINT_ALTRET indicates that there is an
 1090                                  INIT CQ message pending.
 1091                          */
 1092            2 INPDAT_ALTRET REDEF SNDINT_ALTRET BIT(1) UNAL,
 1093                          /*K*    INPDAT_ALTRET indicates that L3$ was input blocked
 1094                                  some time in the past. Only used on redirected
 1095                                  circuits.
 1096                          */
 1097            2 SNDTRM_ALTRET BIT(1) UNAL %INIT('0'B)%EINIT,
 1098                          /*K*    SNDTRM_ALTRET indicates that there is a
 1099                                  TERM CQ message pending.
 1100                          */
 1101            2 SCN_INPDAT_ALTRET REDEF SNDTRM_ALTRET BIT(1) UNAL,
 1102                          /*K*    SCN_INPDAT_ALTRET indicates that SCN_L3$ was input
 1103                                  blocked some time in the past. Only used on
 1104                                  redirected circuits.
 1105                          */
 1106            2 SNDINTACK_ALTRET BIT (1) UNAL %INIT('0'B)%EINIT,
 1107                          /*K*    SNDINTACK_ALTRET indicates that there is a
 1108                                  INIT_ACK CQ message (with reason 0) pending.
 1109                          */
 1110            2 L3_RSTPND REDEF SNDINTACK_ALTRET BIT (1) UNAL,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        31   
 1111                          /*K*    L3_RSTPND indicates that the VC pointed to by
 1112                                  L3$ has a reset in progress and will respond
 1113                                  shortly with a reset event. Only used in
 1114                                  redirected circuits.
 1115                          */
 1116            2 SNDINTNAK_ALTRET BIT (1) UNAL %INIT('0'B)%EINIT,
 1117                          /*K*    SNDINTNAK_ALTRET indicates that there is a
 1118                                  INIT_ACK CQ message (with reason ~= 0) pending.
 1119                          */
 1120            2 SCN_L3_RSTPND REDEF SNDINTNAK_ALTRET BIT (1) UNAL,
 1121                          /*K*    SCN_L3_RSTPND indicates that the VC pointed to by
 1122                                  SCN_L3$ has a reset in progress and will respond
 1123                                  shortly with a reset event. Only used in
 1124                                  redirected circuits.
 1125                          */
 1126            2 SNDTRMACK_ALTRET BIT (1) UNAL %INIT('0'B)%EINIT,
 1127                          /*K*    SNDTRMACK_ALTRET indicates that there is a
 1128                                  TERM_ACK CQ message pending.
 1129                          */
 1130            %KX_FILBIT
 1131            2 REDIRECT BIT(1) UNAL %INIT('0'B)%EINIT,
 1132                          /*K*    REDIRECT indicates this SL is handling a
 1133                                  redirected circuit.
 1134                          */
 1135            2 * BIT (%(16-FEP)) UNAL %INIT('0'B)%EINIT,
 1136            2 LDCTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1137                          /*K*   LDCTX is the identifier to pass thru the SCQ
 1138                                 to identify the specific connection.
 1139                          */
 1140            2 STATE UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1141                          /*K*   STATE contains the current state of the KX$ML
 1142                                 block.
 1143                          */
 1144            2 HIST,
 1145                          /*K*   HIST is the internal history buffer of states,
 1146                                 events, and actions.
 1147                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        32   
 1148              3 X UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1149                          /*K*   X is the index into the history buffer for
 1150                                 the next entry to be inserted.
 1151                          */
 1152              3 STT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
 1153                          /*K*   STT is the state history.
 1154                          */
 1155              3 EVT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
 1156                          /*K*   EVT is the event history.
 1157                          */
 1158              3 ACT (0:7) UBIN BYTE CALIGNED %INIT(0*0)%EINIT,
 1159                          /*K*   ACT is the action history.
 1160                          */
 1161            2 INPDAT_ %KX_DBLBYTALG,
 1162              3 ADR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1163                          /*K*   INPDAT_.ADR$ points to the input packet that SL is
 1164                                 in the middle of processing. If SNDDAT_ALTRET
 1165                                 is not set, INPDAT_.ADR$ has to be nil.
 1166                          */
 1167              3 BYTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1168                          /*K*   INPDAT_.BYTX is the byte index into the buffer.
 1169                          */
 1170              3 BYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1171                          /*K*   INPDAT_.BYTSIZ is the byte size of the buffer.
 1172                          */
 1173            2 CQMSG_ %KX_DBLBYTALG,
 1174              3 ADR$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1175                          /*K*   CQMSG_.ADR$ points to the current output message
 1176                                 that SL is working on.
 1177                          */
 1178              3 BYTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1179                          /*K*   CQMSG_.BYTX is the byte index into the buffer.
 1180                          */
 1181              3 BYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1182                          /*K*   CQMSG_.BYTSIZ is the byte size of the buffer.
 1183                          */
 1184            2 SCN_INPDAT_ REDEF CQMSG_ %KX_DBLBYTALG,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        33   
 1185              3 ADR$ PTR %KX_DBLBYTALG,
 1186                          /*K*   SCN_INPDAT_.ADR$ points to the current input packet
 1187                                 from SCN_L3$.
 1188                          */
 1189              3 BYTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 1190                          /*K*   SCN_INPDAT_.BYTX is the byte index into the buffer.
 1191                          */
 1192              3 BYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 1193                          /*K*   SCN_INPDAT_.BYTSIZ is the byte size of the buffer.
 1194                          */
 1195            2 OTPBFRBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1196                          /*K*   OTPBFRBYTSIZ is exactly the size of a full packet.
 1197                          */
 1198            2 OTPBFRBYTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1199                          /*K*   OTPBFRBYTX is the index into the output buffer
 1200                                 where the next concatenated message should go.
 1201                          */
 1202            2 OTPBFR_STAGE UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1203                          /*K*   OTPBFR_STAGE is similar to CQMSG_STAGE, but refering
 1204                                 to the stage of OTPBFR$.
 1205                          */
 1206            2 INPDAT_STAGE REDEF OTPBFR_STAGE UBIN BYTE CALIGNED,
 1207                          /*K*   INPDAT_STAGE is similar to CQMSG_STAGE, but refering
 1208                                 to the stage of INPDAT$.
 1209                          */
 1210            2 CQMSG_STAGE UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1211                          /*K*   CQMSG_STAGE is used to indicate how far L3 has
 1212                                 gone in transmitting this output message for us.
 1213                                 STAGE 0 means we have just prepared this message
 1214                                 for L3. STAGE 1 means L3 now knows about this
 1215                                 message. STAGE 2 means L3 has copied this message
 1216                                 in IOBUF, whence we'll clear CQMSG$ and STAGE
 1217                                 immediately.
 1218                          */
 1219            2 SCN_INPDAT_STAGE REDEF CQMSG_STAGE UBIN BYTE CALIGNED,
 1220                          /*K*   SCN_INPDAT_STAGE is similar to CQMSG_STAGE, but
 1221                                 referring to the stage of SCN_INPDAT$.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        34   
 1222                          */
 1223            2 BCKLOG SBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1224                          /*K*   BCKLOG is the count of output data bytes left in
 1225                                 the RCQ during this scan cycle. This is to be
 1226                                 compared with upper and lower thresholds to
 1227                                 determine if a flow control CQ message should be
 1228                                 send to the Network layer.
 1229                          */
 1230            2 START_RCQ$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1231                          /*K*   START_RCQ$ is used to guarantee orderly processing
 1232                                 of RCQ message for each SL context. It stores the
 1233                                 pointer to the first RCQ message for this SL that
 1234                                 wasn't removed from the RCQ, or is otherwise nil.
 1235                          */
 1236            2 CALUSRDAT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1237                          /*K*   CALUSRDAT$ is the pointer to the buffer containing
 1238                                 the call user data for/from the circuit.
 1239                          */
 1240            2 CALUSRDATBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1241                          /*K*   CALUSRDATBYTSIZ is the byte size of the call
 1242                                 user data in CALUSRDAT$.
 1243                          */
 1244            2 CALRSPDAT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1245                          /*K*   CALRSPDAT$ is the pointer to the buffer containing
 1246                                 the call confirm user data for/from the circuit.
 1247                          */
 1248            2 CALRSPDATBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1249                          /*K*   CALRSPDATBYTSIZ is the byte size of the call
 1250                                 confirm user data in CALRSPDAT$.
 1251                          */
 1252            2 CLRDAT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1253                          /*K*   CLRDAT$ is the pointer to the buffer containing
 1254                                 the clear data for/from the circuit.
 1255                          */
 1256            2 CLRDATBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT;
 1257                          /*K*   CLRDATBYTSIZ is the byte size of the clear
 1258                                 data in CLRDAT$.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        35   
 1259                          */
 1260      %MEND;
 1261                          /*F*    NAME:   KX$LINKDEV
 1262
 1263                          KX$LINKDEV is the context block for maintaining the
 1264                          control connection between HDLCX25 and the resource
 1265                          manager in the HOST.
 1266                          */
 1267
 1268      %MACRO KX$LINKDEV ( FPTN = KX$LINKDEV,
 1269                          STCLASS = BASED,
 1270                          ALGN = ALIGNED );
 1271
 1272
 1273      %LSET LISTDIR = '0'B;
 1274      %LSET LISTEXP = '1'B;
 1275      %LSET LISTCOM = '0'B;
 1276      %LSET LISTSUB = '1'B;
 1277      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1278      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1279      %IF STC = 1;
 1280      %LSET INIT = CHARTEXT(' INIT');
 1281      %LSET EINIT = CHARTEXT('');
 1282      %ELSE;
 1283      %LSET INIT = CHARTEXT('/*');
 1284      %LSET EINIT = CHARTEXT('*/');
 1285      %ENDIF;
 1286      %LSET FEP = BITBIN(MODE_FEP);
 1287      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1288      %LSET KX_FILBIT = CONCAT('2 * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1289      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 1290      DCL 1 FPTN STCLASS ALGN,
 1291            2 SBR$ EPTR %KX_DBLBYTALG %INIT(ENTADDR(NIL))%EINIT,
 1292                          /*K*   SBR$ is the entry pointer of the subroutine
 1293                                 that owns this piece of context, required for
 1294                                 compatibility with other contexts. Always nil.
 1295                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        36   
 1296            2 VDI$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1297                          /*K*   VDI$ is the pointer to the VDI context.
 1298                          */
 1299            2 CHN$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1300                          /*K*   CHN$ is the pointer to the channel table.
 1301                          */
 1302            2 FLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1303                          /*K*   FLNK$ is the pointer to the next KX$LINKDEV block.
 1304                          */
 1305            2 BLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1306                          /*K*   BLNK$ is the pointer to the previous KX$LINKDEV block.
 1307                          */
 1308            2 L2$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1309                          /*K*   L2$ is the pointer to the L2 context that this
 1310                                 LINKDEV belongs to.
 1311                          */
 1312            2 L4_HEAD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1313                          /*K*   L4_HEAD$ is the pointer to the head of the list of
 1314                                 'L4's owned by this LINKDEV.
 1315                          */
 1316            2 L4_TAIL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1317                          /*K*   L4_TAIL$ is the pointer to the tail of the list of
 1318                                 'L4's owned by this LINKDEV.
 1319                          */
 1320            2 CRC UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1321                          /*K*   CRC is the number of circuits allowed on this
 1322                                 resource. Only used for outgoing resources.
 1323                          */
 1324            2 CRCCNT UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1325                          /*K*   CRCCNT is the number of active outbound circuits
 1326                                 on this resource.
 1327                          */
 1328            2 PRTID UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1329                          /*K*   PRTID is the protocol id used to identify incoming
 1330                                 circuits. Only for incoming resources.
 1331                          */
 1332            2 SUBADR UBIN BYTE CALIGNED %INIT(0)%EINIT,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        37   
 1333                          /*K*   SUBADR is the subaddress that this resource owns.
 1334                                 Only for incoming resources.
 1335                          */
 1336            2 LOGON CHAR(8) CALIGNED %INIT('        ')%EINIT,
 1337                          /*K*   LOGON is the logon string to register this LINKDEV
 1338                                 in the resource table.
 1339                          */
 1340            2 PNDEVTCNT UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1341                          /*K*   PNDEVTCNT is the count of pending break events to
 1342                                 VDH on this LINKDEV.
 1343                          */
 1344            %KX_FILBIT
 1345            2 OUTBOUND BIT(1) UNAL %INIT('0'B)%EINIT,
 1346                          /*K*   OUTBOUND is set when outbound VCs are allowed.
 1347                          */
 1348            2 INBOUND BIT(1) UNAL %INIT('0'B)%EINIT,
 1349                          /*K*   INBOUND is set when incoming VCs are allowed.
 1350                          */
 1351            2 OPNSSN BIT(1) UNAL %INIT('0'B)%EINIT,
 1352                          /*K*   OPNSSN is set when a VDO_OPNSSN was received.
 1353                          */
 1354            2 CLSSSN BIT(1) UNAL %INIT('0'B)%EINIT,
 1355                          /*K*   CLSSSN is set when a VDO_CLSSSN was received.
 1356                          */
 1357            2 RECNC BIT(1) UNAL %INIT('0'B)%EINIT,
 1358                          /*K*   RECNC indicates that this link device can be
 1359                                 reconnected once the current disconnect procedure
 1360                                 is complete.
 1361                          */
 1362            2 * BIT(3) UNAL %INIT('0'B)%EINIT;
 1363      %MEND;
 1364                          /*F*    NAME:   KX$DATA_INNARDS
 1365
 1366                          KX$DATA_INNARDS details the exact structure needed for
 1367                          the KX$DATA macro.
 1368                          */
 1369
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        38   
 1370      %MACRO KX$DATA_INNARDS ( LAST = ";" );
 1371
 1372            2 NEXT$ PTR %INIT(ADDR(NIL))%EINIT,
 1373                          /*K*   NEXT$ is the link used by L1 code.
 1374                          */
 1375            2 L2_LIST$ PTR %INIT(ADDR(NIL))%EINIT,
 1376                          /*K*   L2_LIST$ is the link used by L2 code.
 1377                          */
 1378            2 L3_LIST$ PTR %INIT(ADDR(NIL))%EINIT,
 1379                          /*K*   L3_LIST$ is the link used by L3 code.
 1380                          */
 1381            2 RLS_STAT UBIN(3) UNAL %INIT(0)%EINIT,
 1382                          /*K*   RLS_STAT is used to indicate when all the levels
 1383                                 are done with a buffer.
 1384                          */
 1385            2 RLS REDEF RLS_STAT,
 1386              3 L3 BIT(1) UNAL,
 1387                          /*K*   L3 indicates when level 3 is done with the buffer.
 1388                          */
 1389              3 L2 BIT(1) UNAL,
 1390                          /*K*   L2 indicates when level 2 is done with the buffer.
 1391                          */
 1392              3 L1 BIT(1) UNAL,
 1393                          /*K*   L1 indicates when level 1 is done with the buffer.
 1394                          */
 1395            2 BFRSIZ UBIN(13) UNAL %INIT(0)%EINIT,
 1396                          /*K*   BFRSIZ is the index into the table of buffer
 1397                                 sizes for data buffers.
 1398                          */
 1399            2 CNT UBIN UNAL %INIT(0)%EINIT LAST
 1400                          /*K*   CNT is the byte count for the buffer.
 1401                          */
 1402
 1403      %MEND;
 1404
 1405                          /*F*    NAME:   KX$CCB
 1406
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        39   
 1407                          KX$CCB is the structure of a SLCC CCB.
 1408                          */
 1409
 1410      %MACRO KX$CCB ( FPTN = KX$CCB,
 1411          LAST = ";",
 1412          LVL = 1,
 1413          STCLASS = BASED );
 1414
 1415
 1416      %LSET LISTDIR = '0'B;
 1417      %LSET LISTEXP = '1'B;
 1418      %LSET LISTCOM = '0'B;
 1419      %LSET LISTSUB = '1'B;
 1420      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1421      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1422      %IF STC = 1;
 1423      %LSET INIT = CHARTEXT(' INIT');
 1424      %LSET EINIT = CHARTEXT('');
 1425      %ELSE;
 1426      %LSET INIT = CHARTEXT('/*');
 1427      %LSET EINIT = CHARTEXT('*/');
 1428      %ENDIF;
 1429      %LSET FEP = BITBIN(MODE_FEP);
 1430      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1431      %LSET KX_FILBIT = CONCAT(' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1432      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+2),KX_FILBIT);
 1433      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 1434
 1435      %IF LVL=1;
 1436      DCL 1 FPTN STCLASS,
 1437      %ELSE;
 1438              LVL FPTN,
 1439      %ENDIF;
 1440                %(LVL+1) LNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 1441                          /*K*   LNK$ is an L6 pointer to the next free one.
 1442                                 It is only used in free CCBs.  See LNK.
 1443                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        40   
 1444                %(LVL+1) LNK REDEF LNK$,
 1445                          /*K*   LNK is a SLCC pointer to the next CCB in
 1446                                 the queue.  It is a byte offset from the
 1447                                 start of the memory pool.  Since it is
 1448                                 only one word, and is a REDEF of LNK$,
 1449                                 the fully_qualified name for the item
 1450                                 is LNK.SLCC.  LNK.FEP is a SLCC pointer
 1451                                 for FEP use to chain XMT CCBs.
 1452                          */
 1453                %(LVL+2) SLCC UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 1454                %(LVL+2) FEP UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 1455                %(LVL+1) DATA_ADR UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1456                          /*K*   DATA_ADR is a SLCC pointer to the data
 1457                                 being received or transmitted.  See LNK.
 1458                          */
 1459                %(LVL+1) RANGE UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1460                          /*K*   RANGE is the size that is to be sent
 1461                                 or that could be received.
 1462                          */
 1463                %(LVL+1) R_RANGE UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT,
 1464                          /*K*   R_RANGE is the remaining range after in
 1465                                 input frame is completed.
 1466                          */
 1467                %(LVL+1) FLAGS,
 1468                %KX_FILBIT
 1469                %(LVL+2) LST BIT(1) %INIT('1'B)%EINIT,
 1470                          /*K*   FLAGS.LST indicates this is the last
 1471                                 CCB for this frame.  It should always be
 1472                                 on except for input frames that are too
 1473                                 long, which don't get sent to the FEP.
 1474                          */
 1475                %(LVL+2) FRS BIT(1) %INIT('1'B)%EINIT,
 1476                          /*K*   FLAGS.FRS indicates this is the first
 1477                                 CCB for this frame.  It is always set.
 1478                          */
 1479                %(LVL+2) RFU BIT(6) %INIT('0'B)%EINIT,
 1480                %KX_FILBIT
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        41   
 1481                %(LVL+2) RSU BIT(8) %INIT('0'B)%EINIT,
 1482                %(LVL+1) RSU(0:1) UBIN BYTE CALIGNED %INIT(0,0)%EINIT,
 1483                %(LVL+1) CCB_TAIL UBIN(%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%EINIT LAST
 1484                          /*K*   CCB_TAIL is a SLCC pointer to the tail
 1485                                 of a chain of CCBS being sent to the SLCC
 1486                                 via an OTPCCBPTR command.
 1487                          */
 1488      %MEND;
 1489
 1490                          /*F*    NAME:   KX$FRAME_INNARDS
 1491
 1492                          KX$FRAME_INNARDS details the structure needed for the
 1493                          KX$FRAME macro.
 1494                          */
 1495
 1496      %MACRO KX$FRAME_INNARDS ( LAST = ";" );
 1497
 1498                2 ADR UBIN(8) CALIGNED %INIT(0)%EINIT,
 1499                          /*K*   ADR is the address field.
 1500                          */
 1501                2 CTL UBIN(%(8+8*KX_EXT)) CALIGNED %INIT(0)%EINIT,
 1502                          /*K*   CTL is the control field.
 1503                          */
 1504                2 CTL_BITS REDEF CTL,
 1505      %IF KX_EXT=0;
 1506                3 NR UBIN(3) UNAL,
 1507                          /*K*   NR is N(R), the current receive sequence number.
 1508                          */
 1509                3 PF BIT(1) UNAL,
 1510                          /*K*   PF is the poll/final bit.
 1511                          */
 1512      %ENDIF;
 1513                3 NS UBIN(%(3+KX_EXT*4)) UNAL,
 1514                          /*K*   NS is N(S), the current send sequence number.
 1515                          */
 1516      %LSET LST=CHARTEXT(SUBSTR(CONCAT(TEXTCHAR(LAST),','),KX_EXT,1));
 1517                3 IFLAG BIT(1) UNAL %LST
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        42   
 1518                          /*K*   IFLAG is zero if this is an I-frame.
 1519                          */
 1520      %IF KX_EXT=1;
 1521                3 NR UBIN(7) UNAL,
 1522                3 PF BIT(1) UNAL LAST
 1523      %ENDIF;
 1524
 1525      %MEND;
 1526                          /*F*    NAME:   KX$EXTFRAME_INNARDS
 1527
 1528                          KX$EXTFRAME_INNARDS details the structure needed for the
 1529                          KX$EXTFRAME macro.
 1530                          */
 1531
 1532      %MACRO KX$EXTFRAME_INNARDS ( LAST = ";" );
 1533
 1534                2 ADR UBIN(8) CALIGNED %INIT(0)%EINIT,
 1535                          /*K*   ADR is the address field.
 1536                          */
 1537                2 XCTL CALIGNED,
 1538                3 CTL UBIN BYTE CALIGNED %INIT(0)%EINIT,
 1539                          /*K*   CTL is the control field.
 1540                          */
 1541                3 CTL_BITS REDEF CTL,
 1542                4 NS UBIN(7) UNAL,
 1543                          /*K*   NS is N(S), the current send sequence number.
 1544                          */
 1545                4 IFLAG BIT(1) UNAL,
 1546                          /*K*   IFLAG is zero if this is an I-frame.
 1547                          */
 1548                3 NR UBIN(7) UNAL %INIT(0)%EINIT,
 1549                3 PF BIT(1) UNAL %INIT('0'B)%EINIT,
 1550                2 XCTL_REDEF REDEF XCTL UBIN(16) CALIGNED LAST
 1551
 1552      %MEND;
 1553
 1554                          /*F*    NAME:   KX$PACKET_INNARDS
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        43   
 1555
 1556                          KX$PACKET_INNARDS details the structure needed for the
 1557                          KX$PACKET macro.
 1558                          */
 1559
 1560      %MACRO KX$PACKET_INNARDS ( LAST = ";" );
 1561      %LSET LISTDIR = '0'B;
 1562      %LSET LISTEXP = '1'B;
 1563      %LSET LISTCOM = '0'B;
 1564      %LSET LISTSUB = '1'B;
 1565      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1566      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1567      %IF STC = 1;
 1568      %LSET INIT = CHARTEXT(' INIT');
 1569      %LSET EINIT = CHARTEXT('');
 1570      %ELSE;
 1571      %LSET INIT = CHARTEXT('/*');
 1572      %LSET EINIT = CHARTEXT('*/');
 1573      %ENDIF;
 1574      %LSET FEP = BITBIN(MODE_FEP);
 1575      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1576      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1577      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 1578
 1579                2 Q_BIT BIT(1) UNAL %INIT('0'B)%EINIT,
 1580                          /*K*   Q_BIT specifies that the data packet contains
 1581                                 control information for the higher-level entity.
 1582                          */
 1583                2 D_BIT BIT(1) UNAL %INIT('0'B)%EINIT,
 1584                          /*K*   D_BIT specifies that flow control acknowledgements
 1585                                 are to have end-to-end significance.
 1586                          */
 1587                2 GFI UBIN(2) UNAL %INIT(0)%EINIT,
 1588                          /*K*   GFI is the general format identifier.
 1589                          */
 1590                2 LCN# UBIN(12) UNAL %INIT(0)%EINIT,
 1591                2 LCN REDEF LCN#,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        44   
 1592                3 LCGN UBIN(4) UNAL,
 1593                          /*K*   LCGN is the logical channel group number.
 1594                          */
 1595                3 LCN UBIN(8) UNAL,
 1596                          /*K*   LCN is the logical channel number.
 1597                          */
 1598                2 TYPE UBIN(8) CALIGNED %INIT(0)%EINIT,
 1599                          /*K*   TYPE is the packet type field.
 1600                          */
 1601                2 TYPE_BITS REDEF TYPE,
 1602      %IF KX_EXT=0;
 1603                3 * BIT(4) %INIT('0'B)%EINIT,
 1604      %ENDIF;
 1605                3 PS UBIN(%(3+KX_EXT*4)) UNAL %INIT(0)%EINIT,
 1606                          /*K*   PS is P(S), the current send sequence number.
 1607                          */
 1608                3 PS_BITS REDEF PS UNAL,
 1609      %IF KX_EXT=1;
 1610                4 * BIT(4) UNAL,    /* FILLER                                                           */
 1611      %ENDIF;
 1612                4 FT UBIN(2) UNAL,
 1613                          /*K*   FT is the type of flow control packet.
 1614                          */
 1615                4 FC BIT(1) UNAL,
 1616                          /*K*   FC is the flow control indicator bit.  If set,
 1617                                 the packet is not a flow control packet.
 1618                          */
 1619                3 DP BIT(1) UNAL %INIT('0'B)%EINIT,
 1620                          /*K*   DP is the bit that identifies the packet as being
 1621                                 a data packet.
 1622                          */
 1623      %IF KX_EXT=1;
 1624                2 PR_BITS,
 1625                3 PR UBIN(7) UNAL %INIT(0)%EINIT,
 1626                          /*K*   PR is P(R), the current receive sequence number.
 1627                          */
 1628                3 M BIT(1) UNAL %INIT('0'B)%EINIT LAST
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        45   
 1629                          /*K*   M is the more data bit (continuation).
 1630                          */
 1631      %ELSE;
 1632                2 PR_BITS REDEF TYPE,
 1633                3 PR UBIN(3) UNAL,
 1634                3 M BIT(1) UNAL,
 1635                3 * BIT(4) UNAL LAST
 1636      %ENDIF;
 1637      %MEND;
 1638
 1639                          /*F*    NAME:   KX$EXTPACKET_INNARDS
 1640
 1641                          KX$EXTPACKET_INNARDS details the structure needed for the
 1642                          KX$EXTPACKET macro.
 1643                          */
 1644
 1645      %MACRO KX$EXTPACKET_INNARDS ( LAST = ";" );
 1646
 1647                2 Q_BIT BIT(1) UNAL %INIT('0'B)%EINIT,
 1648                          /*K*   Q_BIT specifies that the data packet contains
 1649                                 control information for the higher-level entity.
 1650                          */
 1651                2 D_BIT BIT(1) UNAL %INIT('0'B)%EINIT,
 1652                          /*K*   D_BIT specifies that flow control acknowledgements
 1653                                 are to have end-to-end significance.
 1654                          */
 1655                2 GFI UBIN(2) UNAL %INIT(0)%EINIT,
 1656                          /*K*   GFI is the general format identifier.
 1657                          */
 1658                2 LCGN UBIN(4) UNAL %INIT(0)%EINIT,
 1659                          /*K*   LCGN is the logical channel group number.
 1660                          */
 1661                2 LCN UBIN(8) CALIGNED %INIT(0)%EINIT,
 1662                          /*K*   LCN is the logical channel number.
 1663                          */
 1664                2 TYPE UBIN(8) CALIGNED %INIT(0)%EINIT,
 1665                          /*K*   TYPE is the packet type field.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        46   
 1666                          */
 1667                2 TYPE_BITS REDEF TYPE,
 1668                3 PS UBIN(7) UNAL,
 1669                          /*K*   PS is P(S), the current send sequence number.
 1670                          */
 1671                3 PS_BITS REDEF PS UNAL,
 1672                4 * BIT(4) UNAL,    /* FILLER                                                           */
 1673                4 FT UBIN(2) UNAL,
 1674                          /*K*   FT is the type of flow control packet.
 1675                          */
 1676                4 FC BIT(1) UNAL,
 1677                          /*K*   FC is the flow control indicator bit.  If set,
 1678                                 the packet is not a flow control packet.
 1679                          */
 1680                3 DP BIT(1) UNAL,
 1681                          /*K*   DP is the bit that identifies the packet as being
 1682                                 a data packet.
 1683                          */
 1684                2 PR_BITS,
 1685                3 PR UBIN(7) UNAL %INIT(0)%EINIT,
 1686                          /*K*   PR is P(R), the current receive sequence number.
 1687                          */
 1688                3 M BIT(1) UNAL %INIT('0'B)%EINIT LAST
 1689                          /*K*   M is the more data bit (continuation).
 1690                          */
 1691      %MEND;
 1692
 1693                          /*F*    NAME:   KX$DATA
 1694
 1695                          KX$DATA is the prefix for all data buffers.  It contains
 1696                          information about size, linkages, and whether or not it
 1697                          is ok to release the buffer.
 1698                          */
 1699
 1700      %MACRO KX$DATA ( FPTN = KX$DATA,
 1701          STCLASS = BASED );
 1702
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        47   
 1703      %LSET LISTDIR='0'B;
 1704      %LSET LISTEXP='1'B;
 1705      %LSET LISTCOM='0'B;
 1706      %LSET LISTSUB='1'B;
 1707      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1708      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1709      %LSET INIT=CHARTEXT('INIT');
 1710      %LSET EINIT = CHARTEXT ('');
 1711      %ELSE;
 1712      %LSET INIT=CHARTEXT('/*');
 1713      %LSET EINIT = CHARTEXT ('*/');
 1714      %ENDIF;
 1715
 1716      DCL 1 FPTN STCLASS,
 1717             %KX$DATA_INNARDS;
 1718
 1719      %MEND;
 1720
 1721                          /*F*    NAME:   KX$FRAME
 1722
 1723                          KX$FRAME is the structure of the frame level information
 1724                          within an X.25 frame.  It includes an address field and
 1725                          function code (with optional sequencing information).
 1726                          It immediately follows the KX$DATA_INNARDS.
 1727                          */
 1728
 1729      %MACRO KX$FRAME ( FPTN = KX$FRAME,
 1730          STCLASS = BASED );
 1731
 1732      %LSET LISTDIR='0'B;
 1733      %LSET LISTEXP='1'B;
 1734      %LSET LISTCOM='0'B;
 1735      %LSET LISTSUB='1'B;
 1736      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1737      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1738      %LSET INIT=CHARTEXT('INIT');
 1739      %LSET EINIT = CHARTEXT ('');
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        48   
 1740      %ELSE;
 1741      %LSET INIT=CHARTEXT('/*');
 1742      %LSET EINIT = CHARTEXT ('*/');
 1743      %ENDIF;
 1744
 1745      DCL 1 FPTN STCLASS,
 1746             %KX$DATA_INNARDS ( LAST = "," );
 1747             %KX$FRAME_INNARDS;
 1748
 1749      %MEND;
 1750
 1751                          /*F*    NAME:   KX$EXTFRAME
 1752
 1753                          KX$EXTFRAME is the structure of an x.25 frame in the
 1754                          extended format.  It includes an address field and
 1755                          function code (with optional sequencing information).
 1756                          It immediately follows the KX$DATA_INNARDS.
 1757                          */
 1758
 1759      %MACRO KX$EXTFRAME ( FPTN = KX$EXTFRAME,
 1760          STCLASS = BASED );
 1761
 1762      %LSET LISTDIR='0'B;
 1763      %LSET LISTEXP='1'B;
 1764      %LSET LISTCOM='0'B;
 1765      %LSET LISTSUB='1'B;
 1766      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1767      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1768      %LSET INIT=CHARTEXT('INIT');
 1769      %LSET EINIT = CHARTEXT ('');
 1770      %ELSE;
 1771      %LSET INIT=CHARTEXT('/*');
 1772      %LSET EINIT = CHARTEXT ('*/');
 1773      %ENDIF;
 1774
 1775      DCL 1 FPTN STCLASS,
 1776             %KX$DATA_INNARDS ( LAST = "," );
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        49   
 1777             %KX$EXTFRAME_INNARDS;
 1778
 1779      %MEND;
 1780
 1781                          /*F*    NAME:   KX$XFRAME
 1782
 1783                          KX$XFRAME is the structure for sending X.25 FRMR
 1784                          frames, which have information in addition to the
 1785                          usual two bytes.
 1786                          */
 1787
 1788      %MACRO KX$XFRAME ( FPTN = KX$XFRAME,
 1789          STCLASS = BASED );
 1790
 1791      %LSET LISTDIR='0'B;
 1792      %LSET LISTEXP='1'B;
 1793      %LSET LISTCOM='0'B;
 1794      %LSET LISTSUB='1'B;
 1795      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1796      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1797      %LSET INIT=CHARTEXT('INIT');
 1798      %LSET EINIT = CHARTEXT ('');
 1799      %ELSE;
 1800      %LSET INIT=CHARTEXT('/*');
 1801      %LSET EINIT = CHARTEXT ('*/');
 1802      %ENDIF;
 1803
 1804      DCL 1 FPTN STCLASS,
 1805             %KX$DATA_INNARDS ( LAST = "," );
 1806             %KX$FRAME_INNARDS ( LAST = "," );
 1807            2 FRMR_CTL UBIN(%(8+KX_EXT*8)) CALIGNED %INIT(0)%EINIT,
 1808                          /*K*   FRMR_CTL is the control field from the frame
 1809                                 that caused transmission of the FRMR frame.
 1810                          */
 1811            2 FRMR_NSNR UBIN(%(8+KX_EXT*8)) CALIGNED,
 1812            2 FRMR_VARS REDEF FRMR_NSNR,
 1813              3 VS UBIN(%(3+KX_EXT*4)) UNAL,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        50   
 1814                          /*K*   FRMR_VARS.VS is the send seq # of STE reporting
 1815                                 the reject condition.
 1816                          */
 1817              3 CR BIT(1) UNAL,
 1818                          /*K*   FRMR_VARS.CR set to 1 indicates the rejected frame
 1819                                 was a response, and set to 0 for command.
 1820                          */
 1821              3 VR UBIN(%(3+KX_EXT*4)) UNAL,
 1822                          /*K*   FRMR_VARS.VR is the rec seq # of STE reporting the
 1823                                 reject condition.
 1824                          */
 1825              3 * BIT(1) UNAL,      /* FILLER                                                           */
 1826            2 FRMR_BITS UBIN(8) CALIGNED %INIT(0)%EINIT;
 1827                          /*K*   FRMR_BITS identify the reason why a received
 1828                                 frame caused transmission of a FRMR frame.
 1829                          */
 1830
 1831      %MEND;
 1832                          /*F*    NAME:   KX$EXTXFRAME
 1833
 1834                          KX$EXTXFRAME is the structure for sending X.25 FRMR
 1835                          frames, in extended format, which have information
 1836                          in addition to the usual three bytes.
 1837                          */
 1838
 1839      %MACRO KX$EXTXFRAME ( FPTN = KX$EXTXFRAME,
 1840          STCLASS = BASED );
 1841
 1842      %LSET LISTDIR='0'B;
 1843      %LSET LISTEXP='1'B;
 1844      %LSET LISTCOM='0'B;
 1845      %LSET LISTSUB='1'B;
 1846      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1847      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1848      %LSET INIT=CHARTEXT('INIT');
 1849      %LSET EINIT = CHARTEXT ('');
 1850      %ELSE;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        51   
 1851      %LSET INIT=CHARTEXT('/*');
 1852      %LSET EINIT = CHARTEXT ('*/');
 1853      %ENDIF;
 1854
 1855      DCL 1 FPTN STCLASS,
 1856             %KX$DATA_INNARDS ( LAST = "," );
 1857             %KX$FRAME_INNARDS ( LAST = "," );
 1858            2 FRMR_CTL UBIN(16) CALIGNED %INIT(0)%EINIT,
 1859                          /*K*   FRMR_CTL is the control field from the frame
 1860                                 that caused transmission of the FRMR frame.
 1861                          */
 1862            2 FRMR_NSNR UBIN(16) CALIGNED,
 1863            2 FRMR_VARS REDEF FRMR_NSNR,
 1864              3 VS UBIN(7) UNAL,
 1865                          /*K*   FRMR_VARS.VS is the send seq # of STE reporting
 1866                                 the reject condition.
 1867                          */
 1868              3 * BIT(1) UNAL,      /* FILLER                                                           */
 1869              3 VR UBIN(7) UNAL,
 1870                          /*K*   FRMR_VARS.VR is the rec seq # of STE reporting the
 1871                                 reject condition.
 1872                          */
 1873              3 CR BIT(1) UNAL,
 1874                          /*K*   FRMR_VARS.CR set to 1 indicates the rejected frame
 1875                                 was a response, and set to 0 for command.
 1876                          */
 1877            2 FRMR_BITS UBIN(8) CALIGNED %INIT(0)%EINIT;
 1878                          /*K*   FRMR_BITS identify the reason why a received
 1879                                 frame caused transmission of a FRMR frame.
 1880                          */
 1881
 1882      %MEND;
 1883
 1884                          /*F*    NAME:   KX$PACKET
 1885
 1886                          KX$PACKET is the structure for X.25 packet level
 1887                          information.  It includes addressing information,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        52   
 1888                          packet type, optional sequencing information, and
 1889                          some other assorted bits.  It immediately follows
 1890                          KX$DATA_INNARDS and KX$FRAME_INNARDS in a data buffer.
 1891                          */
 1892
 1893      %MACRO KX$PACKET ( FPTN = KX$PACKET,
 1894          STCLASS = BASED );
 1895
 1896      %LSET LISTDIR='0'B;
 1897      %LSET LISTEXP='1'B;
 1898      %LSET LISTCOM='0'B;
 1899      %LSET LISTSUB='1'B;
 1900      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1901      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1902      %LSET INIT=CHARTEXT('INIT');
 1903      %LSET EINIT = CHARTEXT ('');
 1904      %ELSE;
 1905      %LSET INIT=CHARTEXT('/*');
 1906      %LSET EINIT = CHARTEXT ('*/');
 1907      %ENDIF;
 1908
 1909      DCL 1 FPTN STCLASS,
 1910             %KX$DATA_INNARDS ( LAST = "," );
 1911             %KX$FRAME_INNARDS ( LAST = "," );
 1912             %KX$PACKET_INNARDS;
 1913
 1914      %MEND;
 1915
 1916                          /*F*    NAME:   KX$XFPACKET
 1917
 1918                          KX$XFPACKET is the structure for X.25 packet level
 1919                          information.  It includes addressing information,
 1920                          packet type, optional sequencing information, and
 1921                          some other assorted bits.  It immediately follows
 1922                          KX$DATA_INNARDS and KX$EXTFRAME_INNARDS in a data buffer.
 1923                          */
 1924
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        53   
 1925      %MACRO KX$XFPACKET ( FPTN = KX$XFPACKET,
 1926          STCLASS = BASED );
 1927
 1928      %LSET LISTDIR='0'B;
 1929      %LSET LISTEXP='1'B;
 1930      %LSET LISTCOM='0'B;
 1931      %LSET LISTSUB='1'B;
 1932      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1933      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1934      %LSET INIT=CHARTEXT('INIT');
 1935      %LSET EINIT = CHARTEXT ('');
 1936      %ELSE;
 1937      %LSET INIT=CHARTEXT('/*');
 1938      %LSET EINIT = CHARTEXT ('*/');
 1939      %ENDIF;
 1940
 1941      DCL 1 FPTN STCLASS,
 1942             %KX$DATA_INNARDS ( LAST = "," );
 1943             %KX$EXTFRAME_INNARDS ( LAST = "," );
 1944             %KX$PACKET_INNARDS;
 1945
 1946      %MEND;
 1947
 1948                          /*F*    NAME:   KX$XPACKET
 1949
 1950                          KX$XPACKET is the structure common to several
 1951                          X.25 packet types.  It includes a cause and a
 1952                          diagnostic field in addition to the other fields
 1953                          in X.25 packets.  The structure immediately follows
 1954                          KX$DATA_INNARDS and KX$FRAME_INNARDS in data
 1955                          buffers.
 1956                          */
 1957
 1958      %MACRO KX$XPACKET ( FPTN = KX$XPACKET,
 1959          STCLASS = BASED );
 1960
 1961      %LSET LISTDIR='0'B;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        54   
 1962      %LSET LISTEXP='1'B;
 1963      %LSET LISTCOM='0'B;
 1964      %LSET LISTSUB='1'B;
 1965      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1966      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 1967      %LSET INIT=CHARTEXT('INIT');
 1968      %LSET EINIT = CHARTEXT ('');
 1969      %ELSE;
 1970      %LSET INIT=CHARTEXT('/*');
 1971      %LSET EINIT = CHARTEXT ('*/');
 1972      %ENDIF;
 1973
 1974      DCL 1 FPTN STCLASS,
 1975             %KX$DATA_INNARDS ( LAST = "," );
 1976             %KX$FRAME_INNARDS ( LAST = "," );
 1977             %KX$PACKET_INNARDS ( LAST = "," );
 1978      %LSET RDF=CHARTEXT(SUBSTR('REDEF PR_BITS',0,KX_EXT*13));
 1979            2 CAUSE %RDF UBIN(8) CALIGNED %INIT(0)%EINIT,
 1980                          /*K*   CAUSE is the cause field for some packets.
 1981                          */
 1982            2 DIAG UBIN(8) CALIGNED %INIT(0)%EINIT;
 1983                          /*K*   DIAG is the diagnostic code associated with CAUSE.
 1984                          */
 1985
 1986      %MEND;
 1987
 1988                          /*F*    NAME:   KX$MSG
 1989
 1990                          KX$MSG is a byte array in which data to be transferred
 1991                          in inserted.  In data buffers, it follows KX$DATA_INNARDS,
 1992                          KX$FRAME_INNARDS, and KX$PACKET_INNARDS.
 1993                          */
 1994
 1995      %MACRO KX$MSG ( FPTN = KX$MSG,
 1996          STCLASS = BASED );
 1997
 1998      %LSET LISTDIR='0'B;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        55   
 1999      %LSET LISTEXP='1'B;
 2000      %LSET LISTCOM='0'B;
 2001      %LSET LISTSUB='1'B;
 2002      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2003      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 2004      %LSET INIT=CHARTEXT('INIT');
 2005      %LSET EINIT = CHARTEXT ('');
 2006      %ELSE;
 2007      %LSET INIT=CHARTEXT('/*');
 2008      %LSET EINIT = CHARTEXT ('*/');
 2009      %ENDIF;
 2010
 2011      DCL 1 FPTN STCLASS,
 2012             %KX$DATA_INNARDS ( LAST = "," );
 2013             %KX$FRAME_INNARDS ( LAST = "," );
 2014             %KX$PACKET_INNARDS ( LAST = "," );
 2015      %LSET RDF=CHARTEXT(SUBSTR('REDEF PR_BITS',0,KX_EXT*13));
 2016            2 DATA %RDF CALIGNED,
 2017              3 B (0:0) UBIN(8) UNAL %INIT(0)%EINIT;
 2018                          /*K*   DATA.B is the byte array into which data to be
 2019                                 transmitted is inserted.
 2020                          */
 2021
 2022      %MEND;
 2023
 2024                          /*F*    NAME:   KX$TMRBLK
 2025
 2026                          KX$TMRBLK is a substructure that is used
 2027                          by all KX routines for a special clock
 2028                          service.  It is designed to be imbedded
 2029                          into context block structures.
 2030                          */
 2031
 2032      %MACRO KX$TMRBLK ( FPTN = KX$TMRBLK,
 2033                ALGN = WALIGNED,
 2034                STCLASS = CONSTANT,
 2035                LVL = 1,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        56   
 2036                CTX = "ADDR(NIL)",
 2037                SBR = "ENTADDR(NIL)",
 2038                SBRPRM = 0,
 2039                PRD = 0,
 2040                LAST = ";" );
 2041
 2042
 2043      %LSET LISTDIR = '0'B;
 2044      %LSET LISTEXP = '1'B;
 2045      %LSET LISTCOM = '0'B;
 2046      %LSET LISTSUB = '1'B;
 2047      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 2048      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 2049      %IF STC = 1;
 2050      %LSET INIT = CHARTEXT(' INIT');
 2051      %LSET EINIT = CHARTEXT('');
 2052      %ELSE;
 2053      %LSET INIT = CHARTEXT('/*');
 2054      %LSET EINIT = CHARTEXT('*/');
 2055      %ENDIF;
 2056      %LSET FEP = BITBIN(MODE_FEP);
 2057      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 2058      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 2059      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 2060      %LSET ALG = CHARTEXT(TEXTCHAR(ALGN));
 2061      %IF TEXTCHAR(ALGN) = 'WALIGNED';
 2062      %LSET ALG = KX_DBLBYTALG;
 2063      %ENDIF;
 2064      %IF LVL=1;
 2065      DCL 1 FPTN STCLASS %ALG,
 2066      %ELSE;
 2067              %LVL FPTN %ALG,
 2068      %ENDIF;
 2069
 2070                %(LVL+1) FLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 2071                          /*K*   FLNK$ is the forward link to the next timer
 2072                                 block on the chain.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        57   
 2073                          */
 2074                %(LVL+1) BLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%EINIT,
 2075                          /*K*   BLNK$ is the nackward link to the previous
 2076                                 timer block on the chain.
 2077                          */
 2078                %(LVL+1) CTX$ PTR %KX_DBLBYTALG %INIT(CTX)%EINIT,
 2079                          /*K*   CTX$ is the context block pointer that is to
 2080                                 be provided on calls for time-outs.
 2081                          */
 2082                %(LVL+1) SBR$ EPTR %KX_DBLBYTALG %INIT(SBR)%EINIT,
 2083                          /*K*   SBR$ is the routine to call when a time-out
 2084                                 occurs.
 2085                          */
 2086                %(LVL+1) PRM UBIN BYTE CALIGNED %INIT(SBRPRM)%EINIT,
 2087                          /*K*   PRM is the event that is to be passed to the
 2088                                 time-out routine.
 2089                          */
 2090                %(LVL+1) CNT UBIN BYTE CALIGNED %INIT(PRD)%EINIT,
 2091                          /*K*   CNT is the time-out period in seconds
 2092                          */
 2093                %KX_FILBIT
 2094                %(LVL+1) ON BIT(1) UNAL %INIT('0'B)%EINIT,
 2095                          /*K*   ON is the flag that specifies whether or not
 2096                                 the timer block is on the chain.
 2097                          */
 2098                %(LVL+1) * BIT(%(16-BITBIN(MODE_FEP))) LAST
 2099
 2100      %MEND;
 2101
 2102                          /*F*   NAME:   WRSYSLOG
 2103
 2104                          WRSYSLOG is a general-purpose macro for
 2105                          generating calls to M$WRSYSLOG.  It used to fill
 2106                          in the FPT for a particular call according
 2107                          to the macro options.
 2108                          But to cut down the code size of the handler, it
 2109                          now calls KXS$SYSLOG to fill in the FPT and then
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        58   
 2110                          do the SYSLOG calls.
 2111                          */
 2112
 2113      %MACRO WRSYSLOG ( FPTN = FPT_WRSYSLOG,
 2114                         ERRCOD = required,
 2115                         TRMID = required,
 2116                         BFR = optional,
 2117                         VAL0 = optional,
 2118                         VAL1 = optional,
 2119                         VAL2 = optional,
 2120                         VAL3 = optional );
 2121
 2122      %LSET LISTDIR='0'B;
 2123      %LSET LISTEXP='1'B;
 2124      %LSET LISTCOM='0'B;
 2125      %LSET LISTSUB='1'B;
 2126
 2127      %SET P = CONCAT ( TEXTCHAR(ERRCOD), ',', TEXTCHAR(TRMID) );
 2128      %SET P=CONCAT(P,',',SUBSTR(TEXTCHAR(BFR),0,LENGTH(TEXTCHAR(BFR))*BITBIN(TEXTCHAR(BFR)~='optional')));
 2129      %SET P=CONCAT(P,',',SUBSTR(TEXTCHAR(VAL0),0,LENGTH(TEXTCHAR(VAL0))*BITBIN(TEXTCHAR(VAL0)~='optional')));
 2130      %SET P=CONCAT(P,',',SUBSTR(TEXTCHAR(VAL1),0,LENGTH(TEXTCHAR(VAL1))*BITBIN(TEXTCHAR(VAL1)~='optional')));
 2131      %SET P=CONCAT(P,',',SUBSTR(TEXTCHAR(VAL2),0,LENGTH(TEXTCHAR(VAL2))*BITBIN(TEXTCHAR(VAL2)~='optional')));
 2132      %SET P=CONCAT(P,',',SUBSTR(TEXTCHAR(VAL3),0,LENGTH(TEXTCHAR(VAL3))*BITBIN(TEXTCHAR(VAL3)~='optional')));
 2133      %SET P=SUBSTR(P,0,LENGTH(P)-BITBIN(SUBSTR(P,LENGTH(P)-1)=','));
 2134      %SET P=SUBSTR(P,0,LENGTH(P)-BITBIN(SUBSTR(P,LENGTH(P)-1)=','));
 2135      %SET P=SUBSTR(P,0,LENGTH(P)-BITBIN(SUBSTR(P,LENGTH(P)-1)=','));
 2136      %SET P=SUBSTR(P,0,LENGTH(P)-BITBIN(SUBSTR(P,LENGTH(P)-1)=','));
 2137      %SET P = CHARTEXT ( P );
 2138              CALL KXS$SYSLOG ( %P );
 2139
 2140      %MEND;
 2141
 2142                          /*F*   NAME:   START_TIMER
 2143
 2144                          START_TIMER works with a KX$TMRBLK structure
 2145                          to add another entry onto the chain of clock
 2146                          blocks.
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        59   
 2147                          */
 2148
 2149      %MACRO START_TIMER ( FPTN = KX$TMRBLK,
 2150                CTX = optional,
 2151                SBR = optional,
 2152                SBRPRM = optional,
 2153                PRD = 1 );
 2154
 2155      %LSET LISTDIR='0'B;
 2156      %LSET LISTEXP='1'B;
 2157      %LSET LISTCOM='0'B;
 2158      %LSET LISTSUB='1'B;
 2159
 2160              IF PRD ~= 0
 2161              THEN
 2162              DO;
 2163                 FPTN.CNT = PRD;
 2164      %IF TEXTCHAR(CTX) ~= 'optional';
 2165                 FPTN.CTX$ = CTX;
 2166      %ENDIF;
 2167      %IF TEXTCHAR(SBR) ~= 'optional';
 2168                 FPTN.SBR$ = SBR;
 2169      %ENDIF;
 2170      %IF TEXTCHAR(SBRPRM) ~= 'optional';
 2171                 FPTN.PRM = SBRPRM;
 2172      %ENDIF;
 2173                 IF NOT FPTN.ON
 2174                 THEN
 2175                 DO;
 2176                    FPTN.ON = '1'B;
 2177                    FPTN.FLNK$ = ADDR(NIL);
 2178                    IF KX_TMRBLK.QTL$ = ADDR(NIL)
 2179                    THEN
 2180                       KX_TMRBLK.QHD$ = ADDR ( FPTN );
 2181                    ELSE
 2182                       KX_TMRBLK.QTL$ -> KX$BTMRBLK.FLNK$ = ADDR ( FPTN );
 2183                    FPTN.BLNK$ = KX_TMRBLK.QTL$;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        60   
 2184                    KX_TMRBLK.QTL$ = ADDR ( FPTN );
 2185                    END;
 2186                 END;
 2187              ELSE
 2188                 IF FPTN.ON
 2189                 THEN
 2190                 DO;
 2191                    FPTN.ON = '0'B;
 2192                    IF FPTN.FLNK$ = ADDR(NIL)
 2193                    THEN
 2194                       KX_TMRBLK.QTL$ = FPTN.BLNK$;
 2195                    ELSE
 2196                       FPTN.FLNK$ -> KX$BTMRBLK.BLNK$ = FPTN.BLNK$;
 2197                    IF FPTN.BLNK$ = ADDR(NIL)
 2198                    THEN
 2199                       KX_TMRBLK.QHD$ = FPTN.FLNK$;
 2200                    ELSE
 2201                       FPTN.BLNK$ -> KX$BTMRBLK.FLNK$ = FPTN.FLNK$;
 2202                    END;
 2203
 2204      %MEND;
 2205
 2206                          /*F*    NAME:   STOP_TIMER
 2207
 2208                          STOP_TIMER delinks a KX$TMRBLK structure from
 2209                          the chain of blocks associated with the timer.
 2210                          */
 2211
 2212      %MACRO STOP_TIMER ( FPTN = KX$TMRBLK );
 2213
 2214      %LSET LISTDIR='0'B;
 2215      %LSET LISTEXP='1'B;
 2216      %LSET LISTCOM='0'B;
 2217      %LSET LISTSUB='1'B;
 2218
 2219              IF FPTN.ON
 2220              THEN
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        61   
 2221              DO;
 2222                 FPTN.ON = '0'B;
 2223                 IF FPTN.FLNK$ = ADDR(NIL)
 2224                 THEN
 2225                    KX_TMRBLK.QTL$ = FPTN.BLNK$;
 2226                 ELSE
 2227                    FPTN.FLNK$ -> KX$BTMRBLK.BLNK$ = FPTN.BLNK$;
 2228                 IF FPTN.BLNK$ = ADDR(NIL)
 2229                 THEN
 2230                    KX_TMRBLK.QHD$ = FPTN.FLNK$;
 2231                 ELSE
 2232                    FPTN.BLNK$ -> KX$BTMRBLK.FLNK$ = FPTN.FLNK$;
 2233                 END;
 2234
 2235      %MEND;
 2236
 2237                          /*F*    NAME:   KX$CALL_OPTS
 2238
 2239                          KX$CALL_OPTS is used for passing call establishment
 2240                          information between the Packet level and the
 2241                          Connection Manager.
 2242                          */
 2243
 2244      %MACRO KX$CALL_OPTS ( FPTN = KX$CALL_OPTS,
 2245                            STCLASS = BASED,
 2246                            ALGN = CALIGNED,
 2247                            LVL = 1,
 2248                            LAST = ";" );
 2249
 2250
 2251      %LSET LISTDIR = '0'B;
 2252      %LSET LISTEXP = '1'B;
 2253      %LSET LISTCOM = '0'B;
 2254      %LSET LISTSUB = '1'B;
 2255      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 2256      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 2257      %IF STC = 1;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        62   
 2258      %LSET INIT = CHARTEXT(' INIT');
 2259      %LSET EINIT = CHARTEXT('');
 2260      %ELSE;
 2261      %LSET INIT = CHARTEXT('/*');
 2262      %LSET EINIT = CHARTEXT('*/');
 2263      %ENDIF;
 2264      %LSET FEP = BITBIN(MODE_FEP);
 2265      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 2266      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 2267      %LSET KX_FILBIT2 = CONCAT(BINCHAR(LVL+2), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 2268      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 2269      %LSET KX_FILBIT2 = CHARTEXT(SUBSTR(KX_FILBIT2, FEP*LENGTHC(KX_FILBIT2)));
 2270      %LSET ALG = SUBSTR(CONCAT(TEXTCHAR(ALGN),'   '),0,3);
 2271      %IF ALG = 'WAL';
 2272      %LSET ALGN = KX_DBLBYTALG;
 2273      %ENDIF;
 2274      %IF LVL=1;
 2275      DCL 1 FPTN STCLASS ALGN,
 2276      %ELSE;
 2277              %LVL FPTN ALGN,
 2278      %ENDIF;
 2279
 2280                %(LVL+1) RCVPCKSIZ UBIN BYTE CALIGNED %INIT(%KLX25_SIZ_128#)%EINIT,
 2281                          /*K*   RCVPCKSIZ is the receive packet size.
 2282                          */
 2283                %(LVL+1) RCVTHR UBIN BYTE CALIGNED %INIT(%KLX25_THR_NONE#)%EINIT,
 2284                          /*K*   RCVTHR is the receive throughput class.
 2285                          */
 2286                %(LVL+1) RCVWND UBIN BYTE CALIGNED %INIT(2)%EINIT,
 2287                          /*K*   RCVWND is the receive window.
 2288                          */
 2289                %(LVL+1) SNDPCKSIZ UBIN BYTE CALIGNED %INIT(%KLX25_SIZ_128#)%EINIT,
 2290                          /*K*   SNDPCKSIZ is the send packet size.
 2291                          */
 2292                %(LVL+1) SNDTHR UBIN BYTE CALIGNED %INIT(%KLX25_THR_NONE#)%EINIT,
 2293                          /*K*   SNDTHR is the send throughput class.
 2294                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        63   
 2295                %(LVL+1) SNDWND UBIN BYTE CALIGNED %INIT(2)%EINIT,
 2296                          /*K*   SNDWND is the send window.
 2297                          */
 2298                %(LVL+1) RCVADR CALIGNED,
 2299                          /*K*   RCVADR is the network address of the recipient
 2300                                 (or the CALLED addr) of the call procedure.
 2301                          */
 2302                %(LVL+2) SIZ UBIN BYTE CALIGNED %INIT(0)%EINIT,
 2303                          /*K*   SIZ specifies how many of the BCD digits in
 2304                                 ADR are valid.
 2305                          */
 2306                %(LVL+2) ADR_STRING CHAR(7) CALIGNED,
 2307                          /*K*   defined as char string for ease of comparison                          */
 2308                %(LVL+2) ADR_PAIR(0:6) REDEF ADR_STRING UBIN BYTE CALIGNED LAST
 2309                          /*K*   Redef for coding convenience.
 2310                          */
 2311
 2312      %MEND;
 2313
 2314                          /*F*    NAME:   FPT_X25
 2315
 2316                          FPT_X25 is a generic FPT used to communicate
 2317                          between different levels of the X.25 handler.
 2318                          */
 2319
 2320      %MACRO FPT_X25 ( FPTN = FPT_X25,
 2321                       STCLASS = STATIC,
 2322                       ALGN = WALIGNED,
 2323                       LAST = ";",
 2324                       LVL = 1,
 2325                       EVN = 0,
 2326                       CAL$ = "ADDR(NIL)",
 2327                       RCV$ = "ADDR(NIL)",
 2328                       PRM1 = 0,
 2329                       PRM2 = 0,
 2330                       PRM1$ = "ADDR(NIL)",
 2331                       PRM2$ = "ADDR(NIL)",
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        64   
 2332                       ADR$ = "ADDR(NIL)",
 2333                       BYTX = 0,
 2334                       BYTSIZ = 0,
 2335                       PRSPRM1 = '0'B,
 2336                       PRSPRM2 = '0'B,
 2337                       PRSPRM1$ = '0'B,
 2338                       PRSPRM2$ = '0'B,
 2339                       PRSV = '0'B );
 2340
 2341      %LSET LISTDIR='0'B;
 2342      %LSET LISTEXP='1'B;
 2343      %LSET LISTCOM='0'B;
 2344      %LSET LISTSUB='1'B;
 2345
 2346      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2347      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2348      %LSET INIT=CHARTEXT('INIT');
 2349      %LSET EINIT=CHARTEXT('');
 2350      %ELSE;
 2351      %LSET INIT=CHARTEXT('/*');
 2352      %LSET EINIT=CHARTEXT('*/');
 2353      %ENDIF;
 2354      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 2355      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 2356      %IF STC = 1;
 2357      %LSET INIT = CHARTEXT(' INIT');
 2358      %LSET EINIT = CHARTEXT('');
 2359      %ELSE;
 2360      %LSET INIT = CHARTEXT('/*');
 2361      %LSET EINIT = CHARTEXT('*/');
 2362      %ENDIF;
 2363      %LSET FEP = BITBIN ( MODE_FEP );
 2364      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 2365      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 2366      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
 2367      %IF LVL=1;
 2368      DCL 1 FPTN STCLASS ALGN,
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        65   
 2369      %ELSE;
 2370              %LVL FPTN ALGN,
 2371      %ENDIF;
 2372
 2373                %(LVL+1) %CHARTEXT ('EVN ') UBIN %INIT(EVN)%EINIT,
 2374                          /*K*   EVN is the event being reported.
 2375                          */
 2376                %(LVL+1) %CHARTEXT ('CAL$ ') PTR %INIT(CAL$)%EINIT,
 2377                          /*K*   CAL$ is the context pointer of the caller.
 2378                          */
 2379                %(LVL+1) %CHARTEXT ('RCV$ ') PTR %INIT(RCV$)%EINIT,
 2380                          /*K*   RCV$ is the context pointer of the receiver.
 2381                          */
 2382                %(LVL+1) %CHARTEXT ('PRM1 ') UBIN %INIT(PRM1)%EINIT,
 2383                          /*K*   PRM1 is a word parameter.
 2384                          */
 2385                %(LVL+1) %CHARTEXT ('PRM2 ') UBIN %INIT(PRM2)%EINIT,
 2386                          /*K*   PRM2 is another word parameter.
 2387                          */
 2388                %(LVL+1) %CHARTEXT ('PRM1$ ') PTR %INIT(PRM1$)%EINIT,
 2389                          /*K*   PRM1$ is a pointer parameter.
 2390                          */
 2391                %(LVL+1) PRM3N4 REDEF %CHARTEXT('PRM1$'),
 2392                %(LVL+2) PRM3 UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 2393                %(LVL+2) PRM4 UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 2394                %(LVL+1) %CHARTEXT ('PRM2$ ') PTR %INIT(PRM2$)%EINIT,
 2395                          /*K*   PRM2$ is another pointer parameter.
 2396                          */
 2397                %(LVL+1) PRM5N6 REDEF %CHARTEXT('PRM2$'),
 2398                %(LVL+2) PRM5 UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 2399                %(LVL+2) PRM6 UBIN (%(18-2*FEP)) %KX_DBLBYTALG,
 2400                %(LVL+1) V_,
 2401                          /*K*   V_ is a software vector parameter.
 2402                          */
 2403                %(LVL+2) %CHARTEXT ('ADR$ ') PTR %INIT(ADR$)%EINIT,
 2404                          /*K*   ADR$ is a pointer to a buffer.
 2405                          */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        66   
 2406                %(LVL+2) %CHARTEXT ('BYTX ') SBIN %INIT(BYTX)%EINIT,
 2407                          /*K*   BYTX is the offset from the beginning of the
 2408                                 buffer.
 2409                          */
 2410                %(LVL+2) %CHARTEXT ('BYTSIZ ') UBIN %INIT(BYTSIZ)%EINIT,
 2411                          /*K*   BYTSIZ is the size of the data in the buffer.
 2412                          */
 2413                %(LVL+1) PRS,
 2414                          /*K*   PRS are the bits for the presence of optional
 2415                                 parameters.
 2416                          */
 2417                %(LVL+2) %CHARTEXT ('PRM1 ') BIT(1) %INIT(PRSPRM1)%EINIT,
 2418                %(LVL+2) %CHARTEXT ('PRM2 ') BIT(1) %INIT(PRSPRM2)%EINIT,
 2419                %(LVL+2) %CHARTEXT ('PRM1$ ') BIT(1) %INIT(PRSPRM1$)%EINIT,
 2420                %(LVL+2) %CHARTEXT ('PRM2$ ') BIT(1) %INIT(PRSPRM2$)%EINIT,
 2421                %(LVL+2) %CHARTEXT ('V ') BIT(1) %INIT(PRSV)%EINIT,
 2422                %(LVL+1) RET_BIT1 BIT(1) %INIT('0'B)%EINIT,
 2423                %(LVL+1) RET_BIT2 BIT(1) %INIT('0'B)%EINIT,
 2424                %(LVL+1) RET_BIT3 BIT(1) %INIT('0'B)%EINIT,
 2425                %(LVL+1) RET_BIT4 BIT(1) %INIT('0'B)%EINIT,
 2426                %(LVL+1) RET_BIT5 BIT(1) %INIT('0'B)%EINIT,
 2427                %(LVL+1) RET_BIT6 BIT(1) %INIT('0'B)%EINIT,
 2428                %(LVL+1) RET_BIT7 BIT(1) %INIT('0'B)%EINIT,
 2429                %(LVL+1) RET_BIT8 BIT(1) %INIT('0'B)%EINIT,
 2430                %(LVL+1) RET_BIT9 BIT(1) %INIT('0'B)%EINIT,
 2431                %(LVL+1) RET_BIT10 BIT(1) %INIT('0'B)%EINIT,
 2432                %(LVL+1) RET_BIT11 BIT(1) %INIT('0'B)%EINIT LAST
 2433                          /*K*   these 11 bits are defined here for the called
 2434                                 routine to set/reset to indicate certain
 2435                                 conditions to the calling routine on return.
 2436                          */
 2437
 2438      %MEND;
 2439
 2440                          /*F*    NAME:   KX$SYSLOG_Q_ENTRY
 2441
 2442                          KX$SYSLOG_Q_ENTRY is used to hold all of the
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        67   
 2443                          information necessary to complete an altreted
 2444                          M$WRSYSLOG at a later time, including data
 2445                          that was to be included in the syslog.
 2446                          */
 2447      %MACRO KX$SYSLOG_Q_ENTRY ( FPTN = KX$SYSLOG_Q_ENTRY, STCLASS = BASED );
 2448
 2449      %LSET LISTDIR='0'B;
 2450      %LSET LISTEXP='1'B;
 2451      %LSET LISTCOM='0'B;
 2452      %LSET LISTSUB='1'B;
 2453
 2454      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2455      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2456      %LSET INIT=CHARTEXT('INIT');
 2457      %LSET EINIT=CHARTEXT('');
 2458      %LSET DATSIZ=CHARTEXT('1');
 2459      %ELSE;
 2460      %LSET INIT=CHARTEXT('/*');
 2461      %LSET EINIT=CHARTEXT('*/');
 2462      %LSET DATSIZ=CHARTEXT(CONCAT(TEXTCHAR(FPTN),'.BUF.SIZ'));
 2463      %ENDIF;
 2464
 2465      DCL 1 FPTN STCLASS ALIGNED,
 2466            2 NXT$ PTR,
 2467            2 FPT WALIGNED,
 2468              3 V_ VECTOR,
 2469              3 BUF_ VECTOR,
 2470              3 V,
 2471                   %VLP_ERRCODE ( FPTN = ERRCOD, STCLASS = STCLASS, LVL = 4, LAST = "," );
 2472                   %B$TERMINAL_ID ( FPTN = TRMID, STCLASS = STCLASS, LVL = 4, LAST = "," );
 2473                4 VALUES(0:3) UBIN UNAL %INIT(0*0)%EINIT,
 2474                4 FILENUM UBIN UNAL %INIT(1)%EINIT,
 2475            2 BUF WALIGNED,
 2476              3 SIZ UBIN WORD ALIGNED %INIT(0)%EINIT,
 2477              3 DAT CHAR(%DATSIZ) ALIGNED;
 2478
 2479      %MEND;
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        68   
 2480      %MACRO KX_STATS_HDLC ( FPTN = KX_STATS_HDLC, LVL = 1, ALGN = WALIGNED,
 2481          STCLASS = STCLASS, LAST = ";");
 2482
 2483      %LSET LISTDIR='0'B;
 2484      %LSET LISTEXP='1'B;
 2485      %LSET LISTCOM='0'B;
 2486      %LSET LISTSUB='1'B;
 2487      %LSET NXTLVL = LVL + 1;
 2488      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2489      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 2490      %LSET INIT=CHARTEXT('INIT');
 2491      %LSET EINIT = CHARTEXT ('');
 2492      %ELSE;
 2493      %LSET INIT=CHARTEXT('/*');
 2494      %LSET EINIT = CHARTEXT ('*/');
 2495      %ENDIF;
 2496      %IF MODE_FEP;
 2497      %LSET WORD_SIZE = 32;
 2498      %ELSE;
 2499      %LSET WORD_SIZE = 36;
 2500      %ENDIF;
 2501                                    /*****************************************************************
 2502                                    *                                                                *
 2503                                    *                      HDLC Statistics buffer                    *
 2504                                    *                                                                *
 2505                                    *****************************************************************/
 2506
 2507      %IF LVL = 1;
 2508      DCL 1 FPTN STCLASS ALGN,
 2509      %ELSE;
 2510              %LVL FPTN ALGN,
 2511      %ENDIF;
 2512
 2513                                    /**/
 2514                                    /*  Header.                                                         */
 2515                                    /**/
 2516                %KL_REQSTATS (NAME = REQSTATS, LVL = NXTLVL, STCLASS = STCLASS, LAST=",");
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        69   
 2517                                    /**/
 2518                                    /*  Number of active lines.                                         */
 2519                                    /**/
 2520              %NXTLVL LINES UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2521                                    /**/
 2522                                    /*  Number of connects.                                             */
 2523                                    /**/
 2524                %NXTLVL CONNECTS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2525                                    /**/
 2526                                    /*  Number of disconnects.                                          */
 2527                                    /**/
 2528                %NXTLVL DISCONNECTS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2529                                    /**/
 2530                                    /*  Bytes into FEP from line.                                       */
 2531                                    /**/
 2532                %NXTLVL BYTES_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2533                                    /**/
 2534                                    /*  Bytes from FEP to line.                                         */
 2535                                    /**/
 2536                %NXTLVL BYTES_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2537                                    /**/
 2538                                    /*  Frames into FEP from line.                                      */
 2539                                    /**/
 2540                %NXTLVL FRAMES_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2541                                    /**/
 2542                                    /*  Frames from FEP to line.                                        */
 2543                                    /**/
 2544                %NXTLVL FRAMES_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2545                                    /**/
 2546                                    /*  Frame timeouts.                                                 */
 2547                                    /**/
 2548                %NXTLVL TIMEOUTS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2549                                    /**/
 2550                                    /*  Frame level resets.                                             */
 2551                                    /**/
 2552                %NXTLVL RESETS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2553                                    /**/
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        70   
 2554                                    /*  Frame level rejects from line.                                  */
 2555                                    /**/
 2556                %NXTLVL F_REJECTS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2557                                    /**/
 2558                                    /*  Frame level rejects to line.                                    */
 2559                                    /**/
 2560                %NXTLVL F_REJECTS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2561                                    /**/
 2562                                    /*  Time spent at input TCB.                                        */
 2563                                    /**/
 2564                %NXTLVL IN_TCB_TICS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2565                                    /**/
 2566                                    /*  Time spent at output TCB.                                       */
 2567                                    /**/
 2568                %NXTLVL OUT_TCB_TICS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2569                                    /**/
 2570                                    /*  Number of input interrupts.                                     */
 2571                                    /**/
 2572                %NXTLVL IN_TCB_COUNT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2573                                    /**/
 2574                                    /*  Number of output interrupts.                                    */
 2575                                    /**/
 2576                %NXTLVL OUT_TCB_COUNT UBIN (%WORD_SIZE) %INIT(0)%EINIT LAST
 2577      %MEND;
 2578
 2579      %MACRO KX_STATS_X25 ( FPTN = KX_STATS_X25, LVL = 1, ALGN = WALIGNED,
 2580          STCLASS = STCLASS, LAST = ";");
 2581
 2582      %LSET LISTDIR='0'B;
 2583      %LSET LISTEXP='1'B;
 2584      %LSET LISTCOM='0'B;
 2585      %LSET LISTSUB='1'B;
 2586      %LSET NXTLVL = LVL + 1;
 2587      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2588      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
 2589      %LSET INIT=CHARTEXT('INIT');
 2590      %LSET EINIT = CHARTEXT ('');
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        71   
 2591      %ELSE;
 2592      %LSET INIT=CHARTEXT('/*');
 2593      %LSET EINIT = CHARTEXT ('*/');
 2594      %ENDIF;
 2595      %IF MODE_FEP;
 2596      %LSET WORD_SIZE = 32;
 2597      %ELSE;
 2598      %LSET WORD_SIZE = 36;
 2599      %ENDIF;
 2600                                    /*****************************************************************
 2601                                    *                                                                *
 2602                                    *                      X.25 Statistics buffer                    *
 2603                                    *                                                                *
 2604                                    *****************************************************************/
 2605
 2606      %IF LVL = 1;
 2607      DCL 1 FPTN STCLASS ALGN,
 2608      %ELSE;
 2609              %LVL FPTN ALGN,
 2610      %ENDIF;
 2611
 2612                                    /**/
 2613                                    /*  Header.                                                         */
 2614                                    /**/
 2615                %KL_REQSTATS (NAME = REQSTATS, LVL = NXTLVL, STCLASS = STCLASS, LAST=",");
 2616                                    /*  Packet bytes in from line.                                      */
 2617                                    /**/
 2618              %NXTLVL BYTES_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2619                                    /**/
 2620                                    /*  Packet bytes out to line.                                       */
 2621                                    /**/
 2622                %NXTLVL BYTES_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2623                                    /**/
 2624                                    /*  Packets into FEP from line.                                     */
 2625                                    /**/
 2626                %NXTLVL PACKETS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2627                                    /**/
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        72   
 2628                                    /*  Packets from FEP to line.                                       */
 2629                                    /**/
 2630                %NXTLVL PACKETS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2631                                    /**/
 2632                                    /*  Data packets into FEP from line.                                */
 2633                                    /**/
 2634                %NXTLVL D_PACKETS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2635                                    /**/
 2636                                    /*  Data packets from FEP to line.                                  */
 2637                                    /**/
 2638                %NXTLVL D_PACKETS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2639                                    /**/
 2640                                    /*  Packet level restarts into FEP from line.                       */
 2641                                    /**/
 2642                %NXTLVL RESTART_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2643                                    /**/
 2644                                    /*  Packet level restarts from FEP to line.                         */
 2645                                    /**/
 2646                %NXTLVL RESTART_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2647                                    /**/
 2648                                    /*  Packet level rejects from line.                                 */
 2649                                    /**/
 2650                %NXTLVL P_REJECTS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2651                                    /**/
 2652                                    /*  Packet level rejects to line.                                   */
 2653                                    /**/
 2654                %NXTLVL P_REJECTS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2655                                    /**/
 2656                                    /*  Call packets received from line.                                */
 2657                                    /**/
 2658                %NXTLVL CALLS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2659                                    /**/
 2660                                    /*  Call packets sent to line.                                      */
 2661                                    /**/
 2662                %NXTLVL CALLS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2663                                    /**/
 2664                                    /*  Clear packets received from line.                               */
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        73   
 2665                                    /**/
 2666                %NXTLVL CLEARS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2667                                    /**/
 2668                                    /*  Clear packets sent to line.                                     */
 2669                                    /**/
 2670                %NXTLVL CLEARS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2671                                    /*
 2672                                                                         Packet bytes received
 2673                                    */
 2674                %NXTLVL D_BYTES_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2675                                    /*
 2676                                                                         Non-continued packets received
 2677                                    */
 2678                %NXTLVL D_CMPPACKETS_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2679                                    /*
 2680                                                                         Send throttled by window
 2681                                    */
 2682                %NXTLVL P_BLK UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2683                                    /*
 2684                                                                         Non-continued packets sent
 2685                                    */
 2686                %NXTLVL D_CMPPACKETS_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2687                                    /*
 2688                                                                         Packet bytes sent
 2689                                    */
 2690                %NXTLVL D_BYTES_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2691                                    /*
 2692                                                                         Flow control packets received
 2693                                    */
 2694                %NXTLVL P_FLOW_IN UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2695                                    /*
 2696                                                                         Flow control packets sent
 2697                                    */
 2698                %NXTLVL P_FLOW_OUT UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2699                                    /**/
 2700                                    /*  Number of virtual circuits connected.                           */
 2701                                    /**/
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        74   
 2702                %NXTLVL CIRCUITS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2703                                    /**/
 2704                                    /*  Total # resets initiated from either end.                       */
 2705                                    /**/
 2706                %NXTLVL RESETS UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2707                                    /**/
 2708                                    /*  Frame level blocked, in particular, when there are pkts to send */
 2709                                    /**/
 2710                %NXTLVL F_BLK UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2711                                    /**/
 2712                                    /*  Total # calls to KXS$GETBFR.                                    */
 2713                                    /**/
 2714                %NXTLVL KXSGET UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2715                                    /**/
 2716                                    /*  Total # calls to KVB$GET.                                       */
 2717                                    /**/
 2718                %NXTLVL KVBGET UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2719                                    /**/
 2720                                    /*  Reserve for future use.                                         */
 2721                                    /**/
 2722                %NXTLVL RFU1 UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2723                                    /**/
 2724                                    /*  Reserve for future use.                                         */
 2725                                    /**/
 2726                %NXTLVL RFU2 UBIN (%WORD_SIZE) %INIT(0)%EINIT,
 2727                                    /**/
 2728                                    /*  And yet one more time.                                          */
 2729                                    /**/
 2730                %NXTLVL RFU3 UBIN (%WORD_SIZE) %INIT(0)%EINIT LAST
 2731      %MEND;
 2732
 2733                                    /*
 2734                                        The following macro is simply to used to invoke all the
 2735                                        stats macros in one shot.
 2736                                    */
 2737      %MACRO KX_STATS (STCLASS = STCLASS);
 2738                %KX_STATS_HDLC ( STCLASS = STCLASS );
14:58 JUL 28 '97 KX_MACROS_M.:E05SI                                        75   
 2739      %KX_STATS_X25 ( STCLASS = STCLASS );
 2740      %MEND;

