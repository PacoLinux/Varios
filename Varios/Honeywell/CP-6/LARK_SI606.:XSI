/*M* LARK_SI606 LARK_MODIFY Comgroup information modify processing */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_MODIFY_CMD
   PURPOSE:       Process the MODIFY command
   DESCRIPTION:   This module receives the parse tree for a MODIFY command
                  and modifies the selected information about the selected
                  comgroup.
*/
/*D*
   NAME:          LARK_MODIFY_CMD
   CALL:          CALL LARK_MODIFY_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_CGINFO_WITH_DATASEGS
                  LARK_CLOSE_TEMPSTATION
                  LARK_INTERNAL_ERROR
                  LARK_OPEN_TEMPSTATION
                  LARK_PROCESS_FID
                  LARK_REPORT_PMME_ERROR
                  LARK_REPORT_SUBCMD_ERROR
   INTPUT:        PARSE$OUT
                  VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SETSTA_LARK
                  VLP$SN_CG
                  VLP$WSN_CG
   OUTPUT:        VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
   DESCRIPTION:   MODIFY_CMD syntax =
                     'MOD/IFY' ;
                     [ CG_FID ] ;
                     MODIFY_OPTION_LIST
*/
 
%EJECT ;
LARK_MODIFY_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
%INCLUDE B_ERRORS_C ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XU_PERR_C ;
%INCLUDE XUF_ENTRY ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_CGINFO_WITH_DATASEG ;
%LARK_CLOSE_TEMPSTATION ;
%LARK_INTERNAL_ERROR ;
%LARK_OPEN_TEMPSTATION ;
%LARK_PROCESS_FID ;
%LARK_REPORT_PMME_ERROR ;
%LARK_REPORT_SUBCMD_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME           = P_OUT$BLK,
         STCLASS        = "" ) ;
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMBLOCKS#-3
   MESSAGE0:      An unacceptable number of blocks has been specified
   MESSAGE1:      Choose a number of blocks between 5 and 200
   DESCRIPTION:   User must select a value of 5-200.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMBYTES#-3
   MESSAGE0:      An unacceptable number of bytes has been specified
   MESSAGE1:      Choose a number between 0 and 4096 for write count
   MESSAGE2:      Choose a number between 1 and MAXMC for term reads
   DESCRIPTION:   MAXMC = 0-4096;  TRMRDSIZ = 1-MAXMC.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMMINUTES#-3
   MESSAGE0:      An unacceptable number of minutes has been specified
   MESSAGE1:      Choose a number of minutes between 0 and 511
   DESCRIPTION:   User must select a value of 0-511.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMPAGES#-3
   MESSAGE0:      An unacceptable number of pages has been specified
   MESSAGE1:      Choose a number between 3 and 1000 for max pages
   MESSAGE2:      Choose a number between 2 and 1000 for min pages
   DESCRIPTION:   MAX = 3-1000;  MIN = 2-1000.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMPRIO#-3
   MESSAGE0:      An unacceptable priority value has been specified
   MESSAGE1:      Choose a number between 1 and 500
   DESCRIPTION:   User must select a value of 1-500
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMREADS#-3
   MESSAGE0:      An unacceptable number of reads has been specified
   MESSAGE1:      Choose a number greater than 2 for max reads
   MESSAGE2:      Choose a number greater than 1 for min reads
   DESCRIPTION:   MAX = 3-?;  MIN = 2-?.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMSECONDS#-3
   MESSAGE0:      An unacceptable number of seconds has been specified
   MESSAGE1:      Choose a number of seconds between 0 and 2**18-1
   DESCRIPTION:   User must select a value of 0-2**18-1.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_NUMWARN#-3
   MESSAGE0:      An unacceptable warning level has been specified
   MESSAGE1:      Choose a value between 0 and 18000
   DESCRIPTION:   User must select a value of 0-18000.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_PERCENTAGE#-3
   MESSAGE0:      An unacceptable percentage value has been specified
   MESSAGE1:      Choose a value between 1 and 99
   DESCRIPTION:   User must select a value of 1-99.
*/
 
/*E*
   ERROR:         LAR-E$LARK_CANT_CHANGE_MODE#-3
   MESSAGE0:      ADD, CHANGE, and DELETE subcommands cannot be mixed
   MESSAGE1:      The STALIST and TYPLIST MODIFY options allow the use of only one mode
   DESCRIPTION:   The selection of only one STAFC or TYPFC option per CGCTL is allowed.
*/
 
/*E*
   ERROR:         LAR-E$LARK_HOLDSTA_EXISTS#-3
   MESSAGE0:      A HOLDSTA already exists for this comgroup
   MESSAGE1:      A HOLDSTA cannot be added if one already exists
   DESCRIPTION:   The user can't add a HOLDSTA if one already exists.
*/
 
/*E*
   ERROR:         LAR-E$LARK_HOLDSTA_DOESNT_EXIST#-3
   MESSAGE0:      No HOLDSTA exists for this comgroup
   MESSAGE1:      A HOLDSTA that does not exist cannot be changed or deleted
   DESCRIPTION:   The user can't change or delete a HOLDSTA that doesn't exist.
*/
 
/*E*
   ERROR:         LAR-E$LARK_JRNLFID_EXISTS#-3
   MESSAGE0:      A JRNLFID already exists for this comgroup
   MESSAGE1:      A JRNLFID cannot be added if one already exists
   DESCRIPTION:   The user can't add a JRNLFID if one already exists.
*/
 
/*E*
   ERROR:         LAR-E$LARK_JRNLFID_DOESNT_EXIST#-3
   MESSAGE0:      No JRNLFID exists for this comgroup
   MESSAGE1:      A JRNLFID that does not exist cannot be changed or deleted
   DESCRIPTION:   The user can't change or delete a JRNLFID that doesn't exist.
*/
 
/*E*
   ERROR:         LAR-E$LARK_JRNLSTA_EXISTS#-3
   MESSAGE0:      A JRNLSTA already exists for this comgroup
   MESSAGE1:      A JRNLSTA cannot be added if one already exists
   DESCRIPTION:   The user can't add a JRNLSTA if one already exists.
*/
 
/*E*
   ERROR:         LAR-E$LARK_JRNLSTA_DOESNT_EXIST#-3
   MESSAGE0:      No JRNLSTA exists for this comgroup
   MESSAGE1:      A JRNLSTA that does not exist cannot be changed or deleted
   DESCRIPTION:   The user can't change or delete a JRNLSTA that doesn't exist.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_TYP_DELETE_PARMS#-3
   MESSAGE0:      Only the station or message type can be specified for deletion
   MESSAGE1:      Extra parameters were specified on a delete command
   DESCRIPTION:   The user can only specify the station or message type when
                  deleting a list item.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_TYP_DOESNT_EXIST#-3
   MESSAGE0:      The specified station or message type isn't defined
   MESSAGE1:      A list item that does not exist cannot be changed or deleted
   DESCRIPTION:   The user can't change or delete a station or message type that
                  doesn't exist in the list.
*/
 
/*E*
   ERROR:         LAR-E$LARK_STA_TYP_EXISTS#-3
   MESSAGE0:      The specified station or message type is already defined
   MESSAGE1:      A list item that exists cannot be added
   DESCRIPTION:   The user can't add a station or message type that already exists.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
%LARK_CGINFO ;
%LARK_PARSEBLKS ;
 
%EQU_CG ;
 
%B$ALT ;
 
%B$TCB ;
 
%F$DCB ;
 
%FPT_CGCTL
       ( FPTN           = FPT_CGCTL,
         STCLASS        = CONSTANT,
         DCB            = M$CG ) ;
 
%FPT_CGCTL
       ( FPTN           = FPTCGCTL,
         STCLASS        = AUTO ) ;
 
%FPT_EXTEND
       ( FPTN           = FPT_EXTEND_SIZE,
         STCLASS        = CONSTANT,
         DCB            = M$CG ) ;
 
%FPT_EXTEND
       ( FPTN           = FPTEXTEND_SIZE,
         STCLASS        = AUTO ) ;
 
/*
   Local data
*/
 
DCL         B$TCB$               PTR SYMREF ;
DCL         BLK$                 PTR ;
DCL         I                    SBIN ;
DCL         GOODINFO             BIT ( 1 ) ;
DCL         LOBUF                STATIC CHAR ( 80 ) INIT ( ' ' ) ;
DCL         OPTION_ALTRET        BIT ( 1 ) ;
DCL         OPTIONS_EXIST        BIT ( 1 ) ;
DCL         SUBLK$               PTR ;
DCL         SYM$                 PTR ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %MODIFY_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
/*
   Processing the optional parameter:  CG_FID
   If a CG_FID is not specified, the last FID supplied is used.
*/
 
OPTIONS_EXIST = %FALSE ;
 
IF ( P_OUT$BLK.NSUBLKS > 0 ) THEN DO ;
 
   BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
   IF ( BLK$->OUT$SYM.CODE ~= %CG_FID ) THEN DO ;
      IF ( P_OUT$BLK.NSUBLKS > 1 ) OR
         ( BLK$->OUT$BLK.CODE ~= %MODIFY_OPTION_LIST ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT;
      END ; ELSE DO ;
         OPTIONS_EXIST = %TRUE ;
      END ;
   END ; ELSE DO ;
      /*
         Processing the CG_FID if it was included in the command.
      */
      CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
            ALTRET ( ALT ) ;
   END ;
 
END ;
 
CALL LARK_OPEN_TEMPSTATION ( %TRUE )
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
/*
   Processing the MODIFY_OPTION_LIST.
*/
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) OR OPTIONS_EXIST THEN DO ;
 
   IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
      BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
   END ; ELSE DO ;
      BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
   END ;
 
   IF ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   /*
      Processing the option list.
   */
 
   DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
 
      /*
         Uses previously allocated data segment to store information returned
         from this CGINFO call.
      */
 
      CALL LARK_CGINFO_WITH_DATASEG
            ALTRET ( ALT ) ;
 
      /*
         Initializing the CGCTL structure.
      */
 
      FPTCGCTL = FPT_CGCTL ;
      FPTCGCTL.V_ = VECTOR ( FPTCGCTL.V ) ;
 
      IF (M$CTRLCG$->F$DCB.FCD#) AND (M$CTRLCG$->F$DCB.AU#)
         THEN
            /* USE USER AU STATION FOR THE CALL */
            FPTCGCTL.V.DCB# = M$CTRLCG_DCBNUM;
 
      SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
      DO SELECT SUBLK$->OUT$BLK.CODE ;
 
         SELECT ( %CGCP_OPT ) ;
            CALL CGCP_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %EVENT_OPT ) ;
            CALL EVENT_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %HOLDSTA_OPT ) ;
            CALL HOLDSTA_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %JRNLFID_OPT ) ;
            CALL JRNLFID_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %JRNLSTA_OPT ) ;
            CALL JRNLSTA_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %QLIST_OPT ) ;
            CALL QLIST_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %SETSTA_OPT ) ;
            CALL SETSTA_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %SIZE_OPT ) ;
            CALL SIZE_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %STALIST_OPT ) ;
            CALL STALIST_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( %TYPLIST_OPT ) ;
            CALL TYPLIST_MODIFY
                  ALTRET ( ALT ) ;
 
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
 
      END ;
 
      /*
         Issue the CGCTL pmme after each subcommand is processed.  This allows
         doing things like adding and deleting message types with one command.
         In the case of a size extend, we do an M$EXTEND instead of an M$CGCTL.
         In the case of EVENTs, which is internal to LARK, don't do anything.
      */
 
      IF ( SUBLK$->OUT$BLK.CODE = %EVENT_OPT ) THEN DO ; END;
      ELSE IF ( SUBLK$->OUT$BLK.CODE = %SIZE_OPT ) THEN DO ;
         CALL M$EXTEND ( FPTEXTEND_SIZE )
               WHENALTRETURN DO ;
                  CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                M$CG_DCBNUM ) ;
                  GOTO ALT ;
               END ;
      END ; ELSE DO ;
         CALL M$CGCTL ( FPTCGCTL )
               WHENALTRETURN DO ;
                  CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                                M$CG_DCBNUM ) ;
                  GOTO ALT ;
               END ;
      END ;
 
   END ;
 
END ; ELSE DO ;
 
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
 
END ;
 
CALL LARK_CLOSE_TEMPSTATION
      WHENALTRETURN DO ;
         GOTO ALT ;
      END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
%EJECT ;
/*I*
   NAME:          GETCMD_SUB_ERROR
   PURPOSE:       To handle an error returned by XUG$GETCMD
   CALL:          CALL GETCMD_SUB_ERROR
   DESCRIPTION:   Reports the parser error and aborts.
*/
 
%EJECT ;
GETCMD_SUB_ERROR : PROC ;
 
CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
CALL XUG$ERRPTR ( XUG$GETCMD_SUB ) ;
XUG$GETCMD_SUB.ERRDCB# = DCBNUM ( NIL ) ;
XUG$GETCMD_SUB.ERR_CODE = XUG$GETCMD_SUB.ERR# ;
CALL XUG$ERRMSG ( XUG$GETCMD_SUB ) ;
CALL LARK_INTERNAL_ERROR ;
 
RETURN;
 
END GETCMD_SUB_ERROR ;
 
%EJECT ;
/*I*
   NAME:          RETURN_DATASEG_INFO
   PURPOSE:       To return information about remaining space in the CGINFO data
                  segment
   CALL:          CALL RETURN_DATASEG_INFO ( AVAIL$, AVAIL )
   PARAMETERS:    AVAIL$ points to the beginning of the available space
                  AVAIL contains the number of remaining words to the end of the
                     data segment
   DESCRIPTION:   Returns a pointer to the beginning of the available space in
                  the CGINFO data segment and the number of available words.
*/
 
%EJECT ;
RETURN_DATASEG_INFO : PROC ( AVAIL$, AVAIL ) ;
 
DCL      AVAIL$               PTR ;
DCL      AVAIL                UBIN ;
 
%VLP_VECTOR
       ( FPTN                 = TEMP_,
         STCLASS              = AUTO ) ;
/*
   The last list in the data segment is always the list for the type of items
   that the anonymous queue is NOT ordered by.
*/
 
    /* Weird trick -- I don't know which DCB is the AU */
IF DCBADDR(FPTCGCTL.V.DCB#)->F$DCB.QISS# THEN DO ;
   TEMP_ = FPT$CGINFO.TYPLIST_ ;
END ; ELSE DO ;
   TEMP_ = FPT$CGINFO.STALIST_ ;
END ;
AVAIL$ = PINCRW ( TEMP_.PTR$,
                  ( TEMP_.W1.VSIZE# + 3 ) / 4 ) ;
AVAIL = ( ( VLP$VECTOR_CGINFO_DATASEG.W1.VSIZE# + 3 ) / 4 ) -
      POFFW ( AVAIL$,
              VLP$VECTOR_CGINFO_DATASEG.PTR$ ) ;
 
RETURN;
 
END RETURN_DATASEG_INFO ;
 
%EJECT ;
/*I*
   NAME:          ACCESS_MODIFY
   PURPOSE:       To modify the account access privileges of the selected
                  comgroup
   CALL:          CALL ACCESS_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the access privileges of various
                  accounts
*/
 
%EJECT ;
ACCESS_MODIFY : PROC ;
 
RETURN;
 
END ACCESS_MODIFY ;
 
%EJECT ;
/*I*
   NAME:          CGCP_MODIFY
   PURPOSE:       To modify the CGCP parameters of the selected comgroup.
   CALL:          CALL CGCP_MODIFY
   DESCRIPTION:   Uses the parameters provided to modify the CGCP parameters.
                  Uses a subcommand level to receive input.
*/
 
%EJECT ;
CGCP_MODIFY : PROC ALTRET ;
 
   DCL   CGCP$                PTR ;
   DCL   CGCP_MOD_PARMS       SBIN SYMREF ;
   DCL   CGCP_PROMPT          CHAR ( 0 ) CONSTANT INIT ( 'CGCP PARMS>' ) ;
   DCL   SYM$                 PTR ;
   DCL   TEMP_CODE            UBIN ;
   DCL   TEMP_NUM             SBIN ;
   DCL   TEMP_YES_NO          BIT ( 1 ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
   DCL   ACTIVATE#            UBIN CONSTANT INIT ( 1 ) ;
   DCL   DEACTIVATE#          UBIN CONSTANT INIT ( 2 ) ;
   DCL   DISCONNECT#          UBIN CONSTANT INIT ( 3 ) ;
   DCL   NC#                  UBIN CONSTANT INIT ( 0 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( CGCP_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( CGCP_PROMPT ) ;
CGCP$ = VBASE ( BITVECT ( FPT$CGINFO.CGCP_ ) ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %ACTIVATE ) ;
            TEMP_CODE = ACTIVATE# ;
         SELECT ( %DEACTIVATE ) ;
            TEMP_CODE = DEACTIVATE# ;
         SELECT ( %DISCONNECT ) ;
            TEMP_CODE = DISCONNECT# ;
         SELECT ( %NOCHANGE ) ;
            TEMP_CODE = NC# ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %NUMACTIVE, %NUMBLOCKS, %NUMBYTES, %NUMMINUTES,
                %NUMPAGES,  %NUMPRIO,   %NUMREADS,   %NUMWARN,
                %PERCENTAGE ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSGTYPE ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO CASE ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         CASE ( %CGCP_AUCONDCB_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.AUCONDCB# = TEMP_CODE ;
         CASE ( %CGCP_AUCONTERM_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.AUCONTERM# = TEMP_CODE ;
         CASE ( %CGCP_AUDCONDCB_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.AUDCONDCB# = TEMP_CODE ;
         CASE ( %CGCP_AUDCONTERM_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.AUDCONTERM# = TEMP_CODE ;
         CASE ( %CGCP_AUTORCVR_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.AUTORCVR# = TEMP_YES_NO ;
         CASE ( %CGCP_BIGMXT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.BIGMXT# = TEMP_YES_NO ;
         CASE ( %CGCP_BIN_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.BIN# = TEMP_YES_NO ;
         CASE ( %CGCP_BP_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.BP# = TEMP_YES_NO ;
         CASE ( %CGCP_CARRYOSTA_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.CARRYOSTA# = TEMP_YES_NO ;
         CASE ( %CGCP_CONMSG_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.CONMSG# = TEMP_YES_NO ;
         CASE ( %CGCP_CONT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.CONT# = TEMP_YES_NO ;
         CASE ( %CGCP_DATAPGS_PARM ) ;
            IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > 99 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_PERCENTAGE#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.DATAPGS# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_DCBCONAU_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DCBCONAU# = TEMP_YES_NO ;
         CASE ( %CGCP_DCBCONLGL_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DCBCONLGL# = TEMP_YES_NO ;
         CASE ( %CGCP_DCBCONNAU_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DCBCONNAU# = TEMP_YES_NO ;
         CASE ( %CGCP_DCBCONWA_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DCBCONWA# = TEMP_YES_NO ;
         CASE ( %CGCP_DEFERBLKS_PARM ) ;
            IF ( TEMP_NUM < 5 ) OR ( TEMP_NUM > 200 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMBLOCKS#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.DEFERBLKS# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_DISKWARN_PARM ) ;
            IF ( TEMP_NUM < 0 ) OR ( TEMP_NUM > 18000 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMWARN#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.DISKWARN# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_DMTYP_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DMTYP# = SYM$->OUT$SYM.TEXT ;
         CASE ( %CGCP_DRML_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DRML# = TEMP_YES_NO ;
         CASE ( %CGCP_DSCREQ_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DSCREQ# = TEMP_YES_NO ;
         CASE ( %CGCP_INPUT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.INPUT# = TEMP_YES_NO ;
         CASE ( %CGCP_JOURNAL_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.JOURNAL# = TEMP_YES_NO ;
         CASE ( %CGCP_MAXMC_PARM ) ;
            IF ( TEMP_NUM < 0 ) OR ( TEMP_NUM > 4096 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMBYTES#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MAXMC# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MAXPG_PARM ) ;
            IF ( TEMP_NUM <    3 ) OR ( TEMP_NUM > 1000 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPAGES#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MAXPG# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MAXRD_PARM ) ;
            IF ( TEMP_NUM <    3 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMREADS#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MAXRD# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MEMWARN_PARM ) ;
            IF ( TEMP_NUM < 0 ) OR ( TEMP_NUM > 18000 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMWARN#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MEMWARN# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MEMWARNP_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.MEMWARNP# = TEMP_YES_NO ;
         CASE ( %CGCP_MINPG_PARM ) ;
            IF ( TEMP_NUM < 2 ) OR ( TEMP_NUM > 1000 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPAGES#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MINPG# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MINRD_PARM ) ;
            IF ( TEMP_NUM < 2 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMREADS#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.MINRD# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_MXACT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.MXACT# = TEMP_NUM ;
         CASE ( %CGCP_OUTPUT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.OUTPUT# = TEMP_YES_NO ;
         CASE ( %CGCP_QRML_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.QRML# = TEMP_YES_NO ;
         CASE ( %CGCP_RAS_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.RAS# = TEMP_YES_NO ;
         CASE ( %CGCP_REDUNDANT_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.REDUNDANT# = TEMP_YES_NO ;
         CASE ( %CGCP_REREAD_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.REREAD# = TEMP_YES_NO ;
         CASE ( %CGCP_SECURE_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.SECURE# = TEMP_YES_NO ;
         CASE ( %CGCP_SMD_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.SMD# = TEMP_YES_NO ;
         CASE ( %CGCP_STAPRIO_PARM ) ;
            IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > 500 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPRIO#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.STAPRIO# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_TERMCONAU_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.TERMCONAU# = TEMP_YES_NO ;
         CASE ( %CGCP_TERMCONLGL_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.TERMCONLGL# = TEMP_YES_NO ;
         CASE ( %CGCP_TERMCONNAU_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.TERMCONNAU# = TEMP_YES_NO ;
         CASE ( %CGCP_TMTYP_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.TMTYP# = SYM$->OUT$SYM.TEXT ;
         CASE ( %CGCP_TRANS_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.TRANS# = TEMP_YES_NO ;
         CASE ( %CGCP_TRMRDSIZ_PARM ) ;
            IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > CGCP$->VLP_CGCP_CGINFO.MAXMC# ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMBYTES#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.TRMRDSIZ# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_TYPPRIO_PARM ) ;
            IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > 500 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPRIO#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.TYPPRIO# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_UNLAMSG_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.UNLAMSG# = TEMP_YES_NO ;
         CASE ( %CGCP_VFC_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.DVBYTE.VFC# = TEMP_YES_NO ;
         CASE ( %CGCP_WAS_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.WAS# = TEMP_YES_NO ;
         CASE ( %CGCP_WRITETIME_PARM ) ;
            IF ( TEMP_NUM < 0 ) OR ( TEMP_NUM > 511 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMMINUTES#,
                                               3 ) ;
            END ; ELSE DO ;
               CGCP$->VLP_CGCP_CGINFO.WRITETIME# = TEMP_NUM ;
            END ;
         CASE ( %CGCP_XSTALGL_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.XSTALGL# = TEMP_YES_NO ;
         CASE ( %CGCP_XTYPLGL_PARM ) ;
            CGCP$->VLP_CGCP_CGINFO.XTYPLGL# = TEMP_YES_NO ;
         CASE ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
FPTCGCTL.CGCP_ = VECTOR ( CGCP$->VLP_CGCP_CGINFO ) ;
 
RETURN;
 
ALT:
   ALTRETURN ;
 
END CGCP_MODIFY;
 
%EJECT ;
EVENT_MODIFY : PROC ALTRET ;
 
   DCL   EVENT_MOD_PARMS      SBIN SYMREF ;
   DCL   EVENT_PROMPT         CHAR ( 0 ) CONSTANT INIT ( '*AUEV CODE >' ) ;
   DCL   SYM$                 PTR ;
   DCL   TEMP_CODE            UBIN ;
   DCL   TEMP_NUM             SBIN ;
   DCL   TEMP_YES_NO          BIT ( 1 ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( EVENT_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( EVENT_PROMPT ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      IF (XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS = 1 ) THEN
         DO SELECT ( SYM$->OUT$SYM.CODE ) ;
            SELECT ( %YES ) ;
               TEMP_YES_NO = %YES# ;
            SELECT ( %NO ) ;
               TEMP_YES_NO = %NO# ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
      ELSE  TEMP_YES_NO = %YES# ;
 
      IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE < %EVENT_ALL_PARAM)
         THEN DO;
            TEMP_NUM = XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE -
                      %EVENT_DOPN_PARAM ;
            RPT_AU_EVNT (TEMP_NUM) = TEMP_YES_NO;
            END;
      ELSE IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE = %EVENT_ALL_PARAM)
               /* Make them all TEMP_YES_NO  */
           THEN DO TEMP_NUM = 0 TO %CG_MAX# ;
              RPT_AU_EVNT (TEMP_NUM)  = TEMP_YES_NO;
              END ;
           ELSE DO; /* Something is wrong here */
              CALL LARK_INTERNAL_ERROR ;
              GOTO ALT ;
              END ;
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN;
 
ALT:
   ALTRETURN ;
 
END EVENT_MODIFY;
 
%EJECT ;
/*I*
   NAME:          HOLDSTA_MODIFY
   PURPOSE:       To modify the HOLDSTA parameters associated with the
                  selected comgroup.
   CALL:          CALL HOLDSTA_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the HOLDSTA.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
HOLDSTA_MODIFY : PROC ALTRET ;
 
   DCL   HOLDSTA$             PTR ;
   DCL   HOLDSTA_MOD_CMDS     SBIN SYMREF ;
   DCL   HOLDSTA_PROMPT       CHAR ( 0 ) CONSTANT INIT ( 'HOLDSTA CMDS>' ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( HOLDSTA_MOD_CMDS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( HOLDSTA_PROMPT ) ;
FPTCGCTL.HOLDSTA_ = VECTOR ( NIL ) ;
HOLDSTA$ = VBASE ( BITVECT ( FPT$CGINFO.HOLDSTA_ ) ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %HOLDSTA_HAS_STA_CMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %HOLDSTA_NO_STA_CMD ) ) OR
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 2 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   DO CASE ( XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE ) ;
      CASE ( %ADD_SUBCMD ) ;
         IF ( HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# ~= ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_HOLDSTA_EXISTS#,
                                            3 ) ;
         END ; ELSE DO ;
            HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            FPTCGCTL.HOLDSTA_ = VECTOR ( HOLDSTA$->VLP_HOLDSTA_CGINFO ) ;
         END ;
      CASE ( %CHANGE_SUBCMD ) ;
         IF ( HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# = ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_HOLDSTA_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            FPTCGCTL.HOLDSTA_ = VECTOR ( HOLDSTA$->VLP_HOLDSTA_CGINFO ) ;
         END ;
      CASE ( %DELETE_SUBCMD ) ;
         IF ( HOLDSTA$->VLP_HOLDSTA_CGINFO.STATION# = ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_HOLDSTA_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            FPTCGCTL.HOLDSTA_ = VECTOR ( ERASE ) ;
         END ;
      CASE ( %EXIT_SUBCMD ) ;
         ZEXIT = %TRUE ;
      CASE ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
 
END HOLDSTA_MODIFY ;
 
%EJECT ;
/*I*
   NAME:          JRNLFID_MODIFY
   PURPOSE:       To modify the JRNLFID associated with the selected comgroup.
   CALL:          CALL JRNLFID_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the JRNLFID.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
JRNLFID_MODIFY : PROC ALTRET ;
 
   DCL   JRNLFID$             PTR ;
   DCL   JRNLFID_MOD_CMDS     SBIN SYMREF ;
   DCL   JRNLFID_PROMPT       CHAR ( 0 ) CONSTANT INIT ( 'JRNLFID CMDS>' ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( JRNLFID_MOD_CMDS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( JRNLFID_PROMPT ) ;
FPTCGCTL.JRNLFID_ = VECTOR ( NIL ) ;
JRNLFID$ = VBASE ( BITVECT ( FPT$CGINFO.JRNLFID_ ) ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %JRNLFID_HAS_FID_CMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %JRNLFID_NO_FID_CMD ) ) OR
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 2 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   DO CASE ( XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE ) ;
      CASE ( %ADD_SUBCMD ) ;
         IF ( JRNLFID$->VLP_JRNLFID_CGINFO.L# ~= 0 ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLFID_EXISTS#,
                                            3 ) ;
         END ; ELSE DO ;
            JRNLFID$->VLP_JRNLFID_CGINFO.JRNLFID# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            JRNLFID$->VLP_JRNLFID_CGINFO.L# = SIZEC ( JRNLFID$->VLP_JRNLFID_CGINFO.JRNLFID# ) ;
            FPTCGCTL.JRNLFID_ = VECTOR ( JRNLFID$->VLP_JRNLFID_CGINFO ) ;
         END ;
      CASE ( %CHANGE_SUBCMD ) ;
         IF ( JRNLFID$->VLP_JRNLFID_CGINFO.L# = 0 ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLFID_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            JRNLFID$->VLP_JRNLFID_CGINFO.JRNLFID# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            JRNLFID$->VLP_JRNLFID_CGINFO.L# = SIZEC ( JRNLFID$->VLP_JRNLFID_CGINFO.JRNLFID# ) ;
            FPTCGCTL.JRNLFID_ = VECTOR ( JRNLFID$->VLP_JRNLFID_CGINFO ) ;
         END ;
      CASE ( %DELETE_SUBCMD ) ;
         IF ( JRNLFID$->VLP_JRNLFID_CGINFO.L# = 0 ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLFID_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            FPTCGCTL.JRNLFID_ = VECTOR ( ERASE ) ;
         END ;
      CASE ( %EXIT_SUBCMD ) ;
         ZEXIT = %TRUE ;
      CASE ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END JRNLFID_MODIFY ;
 
%EJECT ;
/*I*
   NAME:          JRNLSTA_MODIFY
   PURPOSE:       To modify the JRNLSTA parameters associated with the
                  selected comgroup.
   CALL:          CALL JRNLSTA_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the JRNLSTA.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
JRNLSTA_MODIFY : PROC ALTRET ;
 
   DCL   JRNLSTA$             PTR ;
   DCL   JRNLSTA_MOD_CMDS     SBIN SYMREF ;
   DCL   JRNLSTA_PROMPT       CHAR ( 0 ) CONSTANT INIT ( 'JRNLSTA CMDS>' ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( JRNLSTA_MOD_CMDS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( JRNLSTA_PROMPT ) ;
FPTCGCTL.JRNLSTA_ = VECTOR ( NIL ) ;
JRNLSTA$ = VBASE ( BITVECT ( FPT$CGINFO.JRNLSTA_ ) ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %JRNLSTA_HAS_STA_CMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %JRNLSTA_NO_STA_CMD ) ) OR
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 2 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   DO CASE ( XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE ) ;
      CASE ( %ADD_SUBCMD ) ;
         IF ( JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# ~= ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLSTA_EXISTS#,
                                            3 ) ;
         END ; ELSE DO ;
            JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            FPTCGCTL.JRNLSTA_ = VECTOR ( JRNLSTA$->VLP_JRNLSTA_CGINFO ) ;
         END ;
      CASE ( %CHANGE_SUBCMD ) ;
         IF ( JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# = ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLSTA_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# =
                  XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT ;
            FPTCGCTL.JRNLSTA_ = VECTOR ( JRNLSTA$->VLP_JRNLSTA_CGINFO ) ;
         END ;
      CASE ( %DELETE_SUBCMD ) ;
         IF ( JRNLSTA$->VLP_JRNLSTA_CGINFO.STATION# = ' ' ) THEN DO ;
            CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_JRNLSTA_DOESNT_EXIST#,
                                            3 ) ;
         END ; ELSE DO ;
            FPTCGCTL.JRNLSTA_ = VECTOR ( ERASE ) ;
         END ;
      CASE ( %EXIT_SUBCMD ) ;
         ZEXIT = %TRUE ;
      CASE ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END JRNLSTA_MODIFY ;
 
%EJECT ;
/*I*
   NAME:          QLIST_MODIFY
   PURPOSE:       To modify the anonymous queue nodes of the selected
                  comgroup.
   CALL:          CALL QLIST_MODIFY
   DESCRIPTION:   Changes the parameters of the anonymous queue nodes
*/
 
%EJECT ;
QLIST_MODIFY: PROC ALTRET ;
 
DCL         FOUND                UBIN ;
DCL         IX                   SBIN ;
DCL         LISTX                SBIN ;
DCL         NAME                 CHAR ( 8 ) ;
DCL         QLIST$               PTR ;
DCL         QLIST_MOD_PARMS      SBIN SYMREF ;
DCL         QLIST_PROMPT         CHAR ( 0 ) CONSTANT INIT ( 'QLIST PARMS>' ) ;
DCL         STA_TYP$             PTR ;
DCL         SUBLK$               PTR ;
DCL         SYM0$                PTR ;
DCL         SYM1$                PTR ;
DCL         TEMP_NUM             SBIN ;
DCL         TEMP_YES_NO          BIT ( 1 ) ;
DCL         ZEXIT                BIT ( 1 ) ;
 
%EJECT ;
QLIST$ = VBASE ( BITVECT ( FPT$CGINFO.QLIST_ ) ) ;
FPTCGCTL.QLIST_ = FPT$CGINFO.QLIST_ ;
    /* Weird trick -- I don't know which DCB is the AU */
IF DCBADDR(FPTCGCTL.V.DCB#)->F$DCB.QISS# THEN DO ;
   STA_TYP$ = VBASE ( BITVECT ( FPT$CGINFO.STALIST_ ) ) ;
   FPTCGCTL.STALIST_ = FPT$CGINFO.STALIST_ ;
   FPTCGCTL.V.STAFC# = %CG_CTLFC_CHGATTR# ;
END ; ELSE DO ;
   STA_TYP$ = VBASE ( BITVECT ( FPT$CGINFO.TYPLIST_ ) ) ;
   FPTCGCTL.TYPLIST_ = FPT$CGINFO.TYPLIST_ ;
   FPTCGCTL.V.TYPFC# = %CG_CTLFC_CHGATTR# ;
END ;
FPTCGCTL.V.ATTRS.MXACT# = %YES# ;
 
XUG$GETCMD_SUB.NODES$ = ADDR ( QLIST_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( QLIST_PROMPT ) ;
 
ZEXIT = %FALSE ;
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 3 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
   IF ( SYM0$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM1$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 1 ) ;
      SUBLK$ = SYM1$->OUT$BLK.SUBLK$( 0 ) ;
      LISTX = -1 ;
    /* Weird trick -- I don't know which DCB is the AU */
      IF DCBADDR(FPTCGCTL.V.DCB#)->F$DCB.QISS# THEN DO ;
         FOUND = STA_TYP$->VLP_CGSTAL_CGINFO.FOUND# ;
      END ; ELSE DO ;
         FOUND = STA_TYP$->VLP_CGTYPL_CGINFO.FOUND# ;
      END ;
      DO IX = 0 TO ( FOUND - 1 ) ;
    /* Weird trick -- I don't know which DCB is the AU */
         IF DCBADDR(FPTCGCTL.V.DCB#)->F$DCB.QISS# THEN DO ;
            NAME = STA_TYP$->VLP_CGSTAL_CGINFO.LIST.NAME#( IX ) ;
         END ; ELSE DO ;
            NAME = STA_TYP$->VLP_CGTYPL_CGINFO.LIST.NAME#( IX ) ;
         END ;
         IF ( NAME = SUBLK$->OUT$SYM.TEXT ) THEN DO ;
            LISTX = IX ;
         END ;
      END ;
      IF ( LISTX = -1 ) THEN DO ;
         CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_STA_TYP_DOESNT_EXIST#,
                                         3 ) ;
         GOTO SKIP_PARM ;
      END ;
      SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 2 ) ;
      IF ( SYM0$->OUT$BLK.CODE ~= %Q_OPTION_LIST ) OR
         ( SYM0$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ;
      DO IX = 0 TO ( SYM0$->OUT$BLK.NSUBLKS - 1 ) ;
         SUBLK$ = SYM0$->OUT$BLK.SUBLK$ ( IX ) ;
         IF ( SUBLK$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
         DO SELECT ( SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$BLK.CODE ) ;
            SELECT ( %YES ) ;
               TEMP_YES_NO = %YES# ;
            SELECT ( %NO ) ;
               TEMP_YES_NO = %NO# ;
            SELECT ( %NUMACTIVE ) ;
               CALL CHARBIN ( TEMP_NUM,
                              SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$SYM.TEXT ) ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
 
         DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
            SELECT ( %MXACT_OPT ) ;
               QLIST$->VLP_CGQL_CGINFO.LIST.MXACT# ( LISTX ) = TEMP_NUM ;
            SELECT ( %AUTORCVR_OPT ) ;
               QLIST$->VLP_CGQL_CGINFO.LIST.AUTORCVR# ( LISTX ) = TEMP_YES_NO ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
      END ;
 
      SKIP_PARM: ;
 
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END QLIST_MODIFY;
 
%EJECT ;
/*I*
   NAME:          SETSTA_MODIFY
   PURPOSE:       To modify the SETSTA parameters of the selected comgroup.
   CALL:          CALL SETSTA_MODIFY
   DESCRIPTION:   Modifies the selected SETSTA parameters.  Uses subcommands
                  to input the information.
*/
 
%EJECT ;
SETSTA_MODIFY : PROC ALTRET ;
 
   DCL   SETSTA$              PTR ;
   DCL   SETSTA_MOD_PARMS     SBIN SYMREF ;
   DCL   SETSTA_PROMPT        CHAR ( 0 ) CONSTANT INIT ( 'SETSTA PARMS>' ) ;
   DCL   SYM$                 PTR ;
   DCL   TEMP_NUM             SBIN ;
   DCL   TEMP_YES_NO          BIT ( 1 ) ;
   DCL   ZEXIT                BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( SETSTA_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( SETSTA_PROMPT ) ;
SETSTA$ = VBASE ( BITVECT ( FPT$CGINFO.SETSTA_ ) ) ;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
      DO SELECT ( SYM$->OUT$SYM.CODE ) ;
         SELECT ( %YES ) ;
            TEMP_YES_NO = %YES# ;
         SELECT ( %NO ) ;
            TEMP_YES_NO = %NO# ;
         SELECT ( %NUMSECONDS ) ;
            CALL CHARBIN ( TEMP_NUM,
                           SYM$->OUT$SYM.TEXT ) ;
         SELECT ( %MSGTYPE, %STATION ) ;
         SELECT ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
 
      DO CASE ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ) ;
         CASE ( %SETSTA_ALLABSENT_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLABSENT# = TEMP_YES_NO ;
         CASE ( %SETSTA_ALLDCBS_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLDCBS# = TEMP_YES_NO ;
         CASE ( %SETSTA_ALLTRMS_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.ALLTRMS# = TEMP_YES_NO ;
         CASE ( %SETSTA_ANYDCB_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.ANYDCB# = TEMP_YES_NO ;
         CASE ( %SETSTA_DIRONLY_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.DIRONLY# = TEMP_YES_NO ;
         CASE ( %SETSTA_EOFNONE_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFNONE# = TEMP_YES_NO ;
         CASE ( %SETSTA_EOFONE_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFONE# = TEMP_YES_NO ;
         CASE ( %SETSTA_EOFTIME_PARM ) ;
            IF ( TEMP_NUM > 262143 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMSECONDS#,
                                               3 ) ;
            END ; ELSE DO ;
               SETSTA$->VLP_SETSTA_CGINFO.ISTA.EOFTIME# = TEMP_NUM ;
            END ;
         CASE ( %SETSTA_ILATCH_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.ILATCH# = TEMP_YES_NO ;
         CASE ( %SETSTA_ILOCK_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.ILOCK# = TEMP_YES_NO ;
         CASE ( %SETSTA_IMSGTYP_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.IMSGTYP# = SYM$->OUT$SYM.TEXT ;
         CASE ( %SETSTA_ISTATION_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.ISTA.ISTATION# = SYM$->OUT$SYM.TEXT ;
         CASE ( %SETSTA_MYSTATION_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.MYSTATION# = SYM$->OUT$SYM.TEXT ;
         CASE ( %SETSTA_OLATCH_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.OLATCH# = TEMP_YES_NO ;
         CASE ( %SETSTA_OLOCK_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.OLOCK# = TEMP_YES_NO ;
         CASE ( %SETSTA_OMSGTYP_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.OMSGTYP# = SYM$->OUT$SYM.TEXT ;
         CASE ( %SETSTA_OSTATION_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.OSTATION# = SYM$->OUT$SYM.TEXT ;
         CASE ( %SETSTA_WAS_PARM ) ;
            SETSTA$->VLP_SETSTA_CGINFO.OSTA.WAS# = TEMP_YES_NO ;
         CASE ( ELSE ) ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
      END ;
   END; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
FPTCGCTL.SETSTA_ = VECTOR ( SETSTA$->VLP_SETSTA_CGINFO ) ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END SETSTA_MODIFY ;
 
%EJECT ;
/*I*
   NAME:            SIZE_MODIFY
   PURPOSE:         To modify the physical size (granules) allocated to a comgroup
                    file.
   CALL:            CALL SIZE_MODIFY
   DESCRIPTION:     Uses the parameter provided to increase the size of a comgroup
                    file using M$EXTEND.
*/
 
%EJECT ;
SIZE_MODIFY : PROC ALTRET ;
 
   DCL SIZE$                    PTR ;
   DCL SIZE_MOD_CMDS            SBIN SYMREF ;
   DCL SIZE_PROMPT              CHAR ( 0 ) CONSTANT INIT ( 'SIZE>' ) ;
   DCL SIZE_NUM                 SBIN ;
   DCL ZEXIT                    BIT ( 1 ) ;
 
ZEXIT = %FALSE ;
XUG$GETCMD_SUB.NODES$ = ADDR ( SIZE_MOD_CMDS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( SIZE_PROMPT ) ;
FPTEXTEND_SIZE = FPT_EXTEND_SIZE ;
FPTEXTEND_SIZE.V_ = VECTOR ( FPTEXTEND_SIZE.V ) ;
 
IF (M$CTRLCG$->F$DCB.FCD#) AND (M$CTRLCG$->F$DCB.AU#)
   THEN
      /* USE USER AU STATION FOR THE CALL */
      FPTEXTEND_SIZE.V.DCB# = M$CTRLCG_DCBNUM;
 
DO UNTIL ZEXIT ;
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) AND
      ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.CODE = %SIZE_INCREASE_PARM ) THEN DO ;
      SYM$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$ ( 0 ) ;
      IF ( SYM$->OUT$SYM.CODE ~= %NUMGRANS ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ; ELSE DO ;
         CALL CHARBIN ( SIZE_NUM,
                        SYM$->OUT$SYM.TEXT ) ;
         FPTEXTEND_SIZE.V.SIZ# = SIZE_NUM ;
      END ;
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END SIZE_MODIFY ;
 
%EJECT ;
/*I*
   NAME:          STALIST_MODIFY
   PURPOSE:       To modify the station nodes of the selected comgroup.
   CALL:          CALL STALIST_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the currently known stations.
*/
 
%EJECT ;
STALIST_MODIFY: PROC ALTRET ;
 
%VLP_CGSTAL
          ( FPTN                 = VLP_CGSTAL,
            STCLASS              = CONSTANT ) ;
 
%VLP_VECTOR
          ( FPTN                 = VLP_VECTOR_TEMP,
            STCLASS              = CONSTANT ) ;
 
%VLP_VECTOR
          ( FPTN                 = VLPVECTOR_TEMP,
            STCLASS              = AUTO ) ;
 
DCL         CGINFO_STA$          PTR ;
DCL         IX                   SBIN ;
DCL         LISTX                SBIN ;
DCL         MODE                 UBIN ;
DCL         NSTA                 UBIN ;
DCL         STALIST$             PTR ;
DCL         STALIST_MOD_PARMS    SBIN SYMREF ;
DCL         STALIST_PROMPT       CHAR ( 0 ) CONSTANT INIT ( 'STALIST PARMS>' ) ;
DCL         STALIST_SIZE         UBIN ;
DCL         SUBLK$               PTR ;
DCL         SYM0$                PTR ;
DCL         SYM1$                PTR ;
DCL         TEMP_NUM             SBIN ;
DCL         TEMP_YES_NO          BIT ( 1 ) ;
DCL         ZEXIT                BIT ( 1 ) ;
 
%EJECT ;
ZEXIT = %FALSE ;
NSTA = 0 ;
MODE = 0 ;
CGINFO_STA$ = VBASE ( BITVECT ( FPT$CGINFO.STALIST_ ) ) ;
CALL RETURN_DATASEG_INFO ( STALIST$,
                           STALIST_SIZE ) ;
XUG$GETCMD_SUB.NODES$ = ADDR ( STALIST_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( STALIST_PROMPT ) ;
 
DO UNTIL ZEXIT ;
 
/*N*
    Need to check to make sure there's enough room in the data segment.
*/
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 3 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
   IF ( SYM0$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM1$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 1 ) ;
      IF ( MODE = 0 ) THEN DO ;
         MODE = SYM0$->OUT$BLK.CODE ;
         DO SELECT ( MODE ) ;
            SELECT ( %ADD_SUBCMD ) ;
               FPTCGCTL.V.STAFC# = %CG_CTLFC_ADD# ;
            SELECT ( %CHANGE_SUBCMD ) ;
               FPTCGCTL.V.STAFC# = %CG_CTLFC_CHGATTR# ;
               FPTCGCTL.V.ATTRS.AUP# = %YES# ;
               FPTCGCTL.V.ATTRS.PERM# = %YES# ;
               FPTCGCTL.V.ATTRS.PRIO# = %YES# ;
            SELECT ( %DELETE_SUBCMD ) ;
               FPTCGCTL.V.STAFC# = %CG_CTLFC_DELETE# ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
      END ; ELSE IF ( MODE ~= SYM0$->OUT$BLK.CODE ) THEN DO ;
         CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_CANT_CHANGE_MODE#,
                                         3 ) ;
         GOTO SKIP_PARM ;
      END ;
      SUBLK$ = SYM1$->OUT$BLK.SUBLK$( 0 ) ;
      LISTX = -1 ;
      DO IX = 0 TO ( CGINFO_STA$->VLP_CGSTAL_CGINFO.FOUND# - 1 ) ;
         IF ( CGINFO_STA$->VLP_CGSTAL_CGINFO.LIST.NAME#(IX) = SUBLK$->OUT$SYM.TEXT ) THEN DO ;
            IF ( MODE = %ADD_SUBCMD ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_STA_TYP_EXISTS#,
                                               3 ) ;
               GOTO SKIP_PARM ;
            END ;
            LISTX = IX ;
         END ;
      END ;
      DO SELECT ( MODE ) ;
         SELECT ( %CHANGE_SUBCMD, %DELETE_SUBCMD ) ;
            IF ( LISTX = -1 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_STA_TYP_DOESNT_EXIST#,
                                               3 ) ;
               GOTO SKIP_PARM ;
            END ;
      END ;
      STALIST$->VLP_CGSTAL_CGINFO.LIST ( NSTA ) = VLP_CGSTAL.LIST ( 0 ) ;
      STALIST$->VLP_CGSTAL_CGINFO.LIST.NAME# ( NSTA ) = SUBLK$->OUT$SYM.TEXT ;
      IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS = 3 ) THEN DO ;
         SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 2 ) ;
         IF ( SYM0$->OUT$BLK.CODE ~= %STATION_OPTION_LIST ) OR
            ( SYM0$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
         IF ( MODE = %CHANGE_SUBCMD ) THEN DO ;
            STALIST$->VLP_CGSTAL_CGINFO.LIST(NSTA) = CGINFO_STA$->VLP_CGSTAL_CGINFO.LIST(LISTX) ;
         END ;
         DO IX = 0 TO ( SYM0$->OUT$BLK.NSUBLKS - 1 ) ;
            SUBLK$ = SYM0$->OUT$BLK.SUBLK$ ( IX ) ;
            IF ( SUBLK$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
            END ;
            DO SELECT ( SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$BLK.CODE ) ;
               SELECT ( %YES ) ;
                  TEMP_YES_NO = %YES# ;
               SELECT ( %NO ) ;
                  TEMP_YES_NO = %NO# ;
               SELECT ( %NUMPRIO ) ;
                  CALL CHARBIN ( TEMP_NUM,
                                 SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$SYM.TEXT ) ;
               SELECT ( ELSE ) ;
                  CALL LARK_INTERNAL_ERROR ;
                  GOTO ALT ;
            END ;
 
            DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
               SELECT ( %AUP_OPT ) ;
                  STALIST$->VLP_CGSTAL_CGINFO.LIST.AUP# ( NSTA ) = TEMP_YES_NO ;
               SELECT ( %PERM_OPT ) ;
                  STALIST$->VLP_CGSTAL_CGINFO.LIST.PERM# ( NSTA ) = TEMP_YES_NO ;
               SELECT ( %PRIO_OPT ) ;
                  IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > 500 ) THEN DO ;
                     CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPRIO#,
                                                     3 ) ;
                  END ; ELSE DO ;
                     STALIST$->VLP_CGSTAL_CGINFO.LIST.PRIO# ( NSTA ) = TEMP_NUM ;
                  END ;
            END ;
         END ;
      END ;
      NSTA = NSTA + 1 ;
 
      SKIP_PARM: ;
 
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
IF ( NSTA > 0 ) THEN DO ;
   VLPVECTOR_TEMP = VLP_VECTOR_TEMP ;
   VLPVECTOR_TEMP.W1.VSIZE# = ( NSTA * SIZEW ( VLP_CGSTAL_CGINFO.LIST ( 0 ) ) + 1 ) * 4 - 1;
   VLPVECTOR_TEMP.PTR$ = STALIST$ ;
   FPTCGCTL.STALIST_ = VLPVECTOR_TEMP ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END STALIST_MODIFY;
 
%EJECT ;
/*I*
   NAME:          TYPLIST_MODIFY
   PURPOSE:       To modify the message type nodes of the selected comgroup.
   CALL:          CALL TYPLIST_MODIFY
   DESCRIPTION:   Adds, deletes, or changes the currently known message types.
*/
 
%EJECT ;
TYPLIST_MODIFY: PROC ALTRET ;
 
%VLP_CGTYPL
          ( FPTN                 = VLP_CGTYPL,
            STCLASS              = CONSTANT ) ;
 
%VLP_VECTOR
          ( FPTN                 = VLP_VECTOR_TEMP,
            STCLASS              = CONSTANT ) ;
 
%VLP_VECTOR
          ( FPTN                 = VLPVECTOR_TEMP,
            STCLASS              = AUTO ) ;
 
DCL         CGINFO_TYP$          PTR ;
DCL         IX                   SBIN ;
DCL         LISTX                SBIN ;
DCL         MODE                 UBIN ;
DCL         NTYP                 UBIN ;
DCL         TYPLIST$             PTR ;
DCL         TYPLIST_MOD_PARMS    SBIN SYMREF ;
DCL         TYPLIST_PROMPT       CHAR ( 0 ) CONSTANT INIT ( 'TYPLIST PARMS>' ) ;
DCL         TYPLIST_SIZE         UBIN ;
DCL         SUBLK$               PTR ;
DCL         SYM0$                PTR ;
DCL         SYM1$                PTR ;
DCL         TEMP_NUM             SBIN ;
DCL         TEMP_YES_NO          BIT ( 1 ) ;
DCL         ZEXIT                BIT ( 1 ) ;
 
%EJECT ;
ZEXIT = %FALSE ;
NTYP = 0 ;
MODE = 0 ;
CGINFO_TYP$ = VBASE ( BITVECT ( FPT$CGINFO.TYPLIST_ ) ) ;
CALL RETURN_DATASEG_INFO ( TYPLIST$,
                           TYPLIST_SIZE ) ;
XUG$GETCMD_SUB.NODES$ = ADDR ( TYPLIST_MOD_PARMS ) ;
XUG$GETCMD_SUB.PROMPT_ = VECTOR ( TYPLIST_PROMPT ) ;
 
DO UNTIL ZEXIT ;
 
/*N*
    Need to check to make sure there's enough room in the data segment.
*/
 
   CALL XUG$GETCMD ( XUG$GETCMD_SUB )
         WHENALTRETURN DO ;
            CALL GETCMD_SUB_ERROR ;
            GOTO ALT ;
         END ;
 
   CALL XUG$ECHOIF ( XUG$GETCMD_SUB ) ;
 
   IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS > 3 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 0 ) ;
   IF ( SYM0$->OUT$BLK.CODE ~= %EXIT_SUBCMD ) THEN DO ;
      SYM1$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 1 ) ;
      IF ( MODE = 0 ) THEN DO ;
         MODE = SYM0$->OUT$BLK.CODE ;
         DO SELECT ( MODE ) ;
            SELECT ( %ADD_SUBCMD ) ;
               FPTCGCTL.V.TYPFC# = %CG_CTLFC_ADD# ;
            SELECT ( %CHANGE_SUBCMD ) ;
               FPTCGCTL.V.TYPFC# = %CG_CTLFC_CHGATTR# ;
               FPTCGCTL.V.ATTRS.JOURNAL# = %YES# ;
               FPTCGCTL.V.ATTRS.ONEREPORT# = %YES# ;
               FPTCGCTL.V.ATTRS.PERM# = %YES# ;
               FPTCGCTL.V.ATTRS.PRIO# = %YES# ;
            SELECT ( %DELETE_SUBCMD ) ;
               FPTCGCTL.V.TYPFC# = %CG_CTLFC_DELETE# ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
      END ; ELSE IF ( MODE ~= SYM0$->OUT$BLK.CODE ) THEN DO ;
         CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_CANT_CHANGE_MODE#,
                                         3 ) ;
         GOTO SKIP_PARM ;
      END ;
      SUBLK$ = SYM1$->OUT$BLK.SUBLK$( 0 ) ;
      LISTX = -1 ;
      DO IX = 0 TO ( CGINFO_TYP$->VLP_CGTYPL_CGINFO.FOUND# - 1 ) ;
         IF ( CGINFO_TYP$->VLP_CGTYPL_CGINFO.LIST.NAME#(IX) = SUBLK$->OUT$SYM.TEXT ) THEN DO ;
            IF ( MODE = %ADD_SUBCMD ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_STA_TYP_EXISTS#,
                                               3 ) ;
               GOTO SKIP_PARM ;
            END ;
            LISTX = IX ;
         END ;
      END ;
      DO SELECT ( MODE ) ;
         SELECT ( %CHANGE_SUBCMD, %DELETE_SUBCMD ) ;
            IF ( LISTX = -1 ) THEN DO ;
               CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_STA_TYP_DOESNT_EXIST#,
                                               3 ) ;
               GOTO SKIP_PARM ;
            END ;
      END ;
      TYPLIST$->VLP_CGTYPL_CGINFO.LIST ( NTYP ) = VLP_CGTYPL.LIST ( 0 ) ;
      TYPLIST$->VLP_CGTYPL_CGINFO.LIST.NAME# ( NTYP ) = SUBLK$->OUT$SYM.TEXT ;
      IF ( XUG$GETCMD_SUB.OUT$->OUT$BLK.NSUBLKS = 3 ) THEN DO ;
         SYM0$ = XUG$GETCMD_SUB.OUT$->OUT$BLK.SUBLK$( 2 ) ;
         IF ( SYM0$->OUT$BLK.CODE ~= %MSGTYP_OPTION_LIST ) OR
            ( SYM0$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
         IF ( MODE = %CHANGE_SUBCMD ) THEN DO ;
            TYPLIST$->VLP_CGTYPL_CGINFO.LIST(NTYP) = CGINFO_TYP$->VLP_CGTYPL_CGINFO.LIST(LISTX) ;
         END ;
         DO IX = 0 TO ( SYM0$->OUT$BLK.NSUBLKS - 1 ) ;
            SUBLK$ = SYM0$->OUT$BLK.SUBLK$ ( IX ) ;
            IF ( SUBLK$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
            END ;
            DO SELECT ( SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$BLK.CODE ) ;
               SELECT ( %YES ) ;
                  TEMP_YES_NO = %YES# ;
               SELECT ( %NO ) ;
                  TEMP_YES_NO = %NO# ;
               SELECT ( %NUMPRIO ) ;
                  CALL CHARBIN ( TEMP_NUM,
                                 SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$SYM.TEXT ) ;
               SELECT ( ELSE ) ;
                  CALL LARK_INTERNAL_ERROR ;
                  GOTO ALT ;
            END ;
 
            DO SELECT ( SUBLK$->OUT$BLK.CODE ) ;
               SELECT ( %JOURNALT_OPT ) ;
                  TYPLIST$->VLP_CGTYPL_CGINFO.LIST.JOURNAL# ( NTYP ) = TEMP_YES_NO ;
               SELECT ( %ONEREPORT_OPT ) ;
                  TYPLIST$->VLP_CGTYPL_CGINFO.LIST.ONEREPORT# ( NTYP ) = TEMP_YES_NO ;
               SELECT ( %PERM_OPT ) ;
                  TYPLIST$->VLP_CGTYPL_CGINFO.LIST.PERM# ( NTYP ) = TEMP_YES_NO ;
               SELECT ( %PRIO_OPT ) ;
                  IF ( TEMP_NUM < 1 ) OR ( TEMP_NUM > 500 ) THEN DO ;
                     CALL LARK_REPORT_SUBCMD_ERROR ( %E$LARK_BAD_NUMPRIO#,
                                                     3 ) ;
                  END ; ELSE DO ;
                     TYPLIST$->VLP_CGTYPL_CGINFO.LIST.PRIO# ( NTYP ) = TEMP_NUM ;
                  END ;
            END ;
         END ;
      END ;
      NTYP = NTYP + 1 ;
 
      SKIP_PARM: ;
 
   END ; ELSE DO ;
      ZEXIT = %TRUE ;
   END ;
 
END ;
 
IF ( NTYP > 0 ) THEN DO ;
   VLPVECTOR_TEMP = VLP_VECTOR_TEMP ;
   VLPVECTOR_TEMP.W1.VSIZE# = ( NTYP * SIZEW ( VLP_CGTYPL_CGINFO.LIST ( 0 ) ) + 1 ) * 4 - 1;
   VLPVECTOR_TEMP.PTR$ = TYPLIST$ ;
   FPTCGCTL.TYPLIST_ = VLPVECTOR_TEMP ;
END ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
END TYPLIST_MODIFY;
 
END LARK_MODIFY_CMD ;
