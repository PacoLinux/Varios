      PROGRAM TIDYMAIN
*
C*T***********************************************************
C*T*                                                         *
C*T* Copyright (c) Honeywell Bull Inc., 1987                 *
C*T*                                                         *
C*T***********************************************************
*  TIDY is a program that reformats (prettyprints) FORTRAN
*  programs.
*
*  Author:           John Stewart
*                    Computing Services
*                    Carleton University
*                    Ottawa, Canada
*
*  History:    The first version of TIDY was put up on
*              Carleton's CPV system in 1978.  A great deal
*              of changes have been made to it since then.
*              TIDY was first installed on CP6 in spring, 1980.
*              Eventually, TIDY was installed in the standard CP-6
*              X account, with modifications by Dwain Nell, LADC.
*
 
      INTEGER I,IJK,LENGTH,TEMP,STATUS
      LOGICAL OK,CMENT
      CHARACTER PROCNAME*30
      INTEGER  BEGIN
      CHARACTER  IOBUFF2(100)*1,COM*1
      EXTERNAL LENGTH
      INCLUDE TIDY_CF3
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF4
      INCLUDE TIDY_CF7
      INCLUDE TIDY_CF9
 
      DATA  COM/','/
 
      CALL OPENBASE
      CALL OPENALL
X     CALL PMSTART
      CALL INITIALIZE
C
C GET USER OPTIONS
C
      CMENT = .FALSE.
      CALL PARSE$DR(BUFF,CMENT,DECSCN,DECPASCAL,
     1              JUSTIFY,HOLDFORMATS,NOINDENT,
     2              DEFAULT,TABSIZ,LBLSRT,FMTSRT,
     3              LBLINC,FMTINC,IGNOREX,YEAR,
     4              COMONLY,PROMPT,CYR)
      BEGIN = 1
      IF (PROMPT) THEN
         DO 990 I = 1,100
            IOBUFF2(I) = ' '
 990     CONTINUE
1000     CALL OUT('INPUT OPTION LIST.')
         CALL OUT('SEPARATE OPTIONS WITH COMMAS OR')
         CALL OUT('INPUT ONE OPTION PER LINE.')
         CALL OUT('AN EMPTY LINE WILL TERMINATE THIS INPUT.')
1010     READ(UNIT=999,FMT='(A72)',END=1030) IOBUFFER
         LEN = 72
         CALL TRANSBUF
         LEN = LENGTH(72)
         IF (LEN .LE. 0) GO TO 1030
         IF (BEGIN .GT. 1) THEN
            IOBUFF2(BEGIN) = COM
            BEGIN = BEGIN + 1
         ENDIF
         IF (BEGIN .EQ. 1) THEN
            IOBUFF2(1) = 'C'
            IOBUFF2(2) = '*'
            IOBUFF2(3) = 'X'
            IOBUFF2(4) = '*'
            BEGIN = 4
         ENDIF
         DO 1020 I = 1,LEN
            IOBUFF2(BEGIN + I) = BUFF(I)
1020     CONTINUE
         BEGIN = LEN + 1
         GO TO 1010
1030     CONTINUE
         LEN = 0
         DO 1040 I = 1,100
            IF (IOBUFF2(I) .EQ. ' ') GO TO 1050
            LEN = LEN + 1
1040     CONTINUE
1050     CONTINUE
         IF (LEN .GT. 0) THEN
      WRITE(899,9900) (IOBUFF2(I),I=1,72)
9900  FORMAT(/,72A1,/)
            CMENT = .TRUE.
            PROMPT = .FALSE.
            CALL PARSE$DR (IOBUFF2,CMENT,DECSCN,DECPASCAL,
     1                     JUSTIFY,HOLDFORMATS,NOINDENT,DEFAULT,
     2                     TABSIZ,LBLSRT,FMTSRT,LBLINC,FMTINC,
     3                     IGNOREX,YEAR,COMONLY,PROMPT,CYR)
         ENDIF
      ENDIF
C
C  READ A LINE INTO THE TEMPORARY BUFFER
C
1070  CALL NEWLYN
1075  KEY = 1
      FMTKEY = 10000
      CALL WRITEBUF (' ', 1, 0)
1080  CALL NXTLYN
      LSTLBL=LBLSRT-LBLINC
      FMTLBL=FMTSRT-FMTINC
*
*     SETUP HASH TABLE
*
      DO 1090 , I=0,41
          LINK(I)=0
1090  CONTINUE
      FREE=42
      IF LEV = 0
 
C PUT A FULL LINE INTO 'BUFF'
      CALL HEADER (OK, PROCNAME)
      WRITE (UNIT=899, FMT='(1X,A)') PROCNAME
      IF (OK) THEN
         CALL OLDOUT (KEY, 2)
         CALL NXTLYN
      ENDIF
      GO TO 4
2     CONTINUE
      CALL NXTLYN
4     CONTINUE
      IF (BUFFCODE(1) .NE. DIGIT) THEN
          I = 2
        ELSE
          I = 1
      ENDIF
      TEMP = LEN
      LEN = 6
      CALL DECNUM(I, DUMMY, LLABEL, .FALSE.)
      LEN = TEMP
      IF (DEBUG) WRITE (6,9020)(BUFF(IJK),IJK=1,LEN)
      OLDKEY=KEY
      INDENT=INDENT+TABNXT*TABSIZ
      TABNXT = 0
      TABNOW = 0
      SPACE = 0
      AGAIN=.FALSE.
      CALL LYNSCN (STATUS)
      INDENT = INDENT + TABNOW * TABSIZ
      CURIND = MAX0 (0, INDENT + SPACE)
      IF (DEBUG) WRITE (6,9010) STATUS,DONE
      GO TO (1110,1120,1130,1150,1160),STATUS
      CALL ONLINE
      CALL OUT('**TRAP** Bad status returned from LYNSCN')
      CALL ERRTXT
************************************************************************
*  FORMAT FOUND
************************************************************************
1110  IF (LLABEL .NE. 0) CALL LABEL(FMTLBL,FMTINC,BUFF)
      IF (HOLDFORMATS) THEN
         CALL OLDOUT (KEY, 2)
      ELSE
         CALL OLDOUT (FMTKEY, 2)
      ENDIF
      GO TO 2
************************************************************************
*  END STATEMENT FOUND
************************************************************************
1120  IF (LLABEL .NE. 0) CALL LABEL(LSTLBL,LBLINC,NEWBUF)
      KEY=FMTKEY+1
      IF (DONE) THEN
          CALL LYNOUT(CURIND,KEY,NEWBUF,PNBUFF,CURIND)
        ELSE
          CALL STKLYN
      ENDIF
      CALL RESCAN
      FREESPACE = 1
      PSTK = 0
      KEY = 1
      FMTKEY=10000
      IF (IF LEV .GT. 0) THEN
         CALL ONLINE
         WRITE (UNIT=899, FMT=9001) IF LEV
9001  FORMAT (' **ERROR** ', I, ' ENDIF statements are missing.')
      ENDIF
      IF LEV = 0
      DO 9, PIND=PIND, 1, -1
         CALL ONLINE
         WRITE (UNIT=899, FMT=9088) INDSTK (PIND)
9     CONTINUE
9088  FORMAT (' **ERROR** REPEAT/DO loop with label ',I,
     *   ' is unbounded because the ',/,
     *   T12, 'label is undefined.')
      PIND = 0
      CALL WRITEBUF (' ', 1, 0)
      GO TO 1080
************************************************************************
*  ORDINARY LINE FOUND
************************************************************************
1130  IF (LLABEL .NE. 0) CALL LABEL(LSTLBL,LBLINC,NEWBUF)
1140  IF (DONE) THEN
          CALL LYNOUT(CURIND,KEY,NEWBUF,PNBUFF,CURIND)
        ELSE
          CALL STKLYN
      ENDIF
      GO TO 2
************************************************************************
*  Declaration statement (already printed)
************************************************************************
1150  CONTINUE
      GOTO 2
************************************************************************
*  Declaration statement (not printed)
1160  CONTINUE
      CALL OLDOUT (KEY, 2)
      GOTO 2
9010  FORMAT(' STATUS=',I2,',DONE=',L2)
9020  FORMAT(X,72A1)
      END
      SUBROUTINE HEADER (OK, PROCNAME)
**********
*        *
* HEADER *
*        *
**********
*     HEADER expects to find a header to a FORTRAN routine.
*  Possible headers are
*
*        1) SUBROUTINE statement
*        2) FUNCTION statement
*        3) PROGRAM statement
*        4) BLOCK DATA statement
*
*     If no header is found, it is assumed that this is the
*  beginning of an unnamed main program.
*     OK returns .TRUE. unless this is an unnamed main program.
*  Returning .FALSE. indicates that the input line will have
*  to reparsed (as a declaration statement).
*     PROCNAME returns the name of the header that was found.
*  If this is an unnamed main program, '4MAIN' is returned.
*
*
      IMPLICIT LOGICAL(A-Z)
      INTEGER I,CNT,FSTART,J
      LOGICAL OK
      CHARACTER PROCNAME*(*)
      INCLUDE TIDY_CF6
      OK = .TRUE.
      PNBUFF=0
      CALL SCNALP(7,CNT,LEN)
      IF (CNT .LT. 4) GO TO 1190
      GO TO (1190,1190,1190,1040,1040,1040,1070,1080,1090,1111,1111,
     1     1111,1130,1130),CNT
      IF (ALPSTR1(1:15).EQ.'DOUBLEPRECISION') THEN
         FSTART = 16
         GO TO 1170
      ENDIF
1130  IF (ALPSTR1(1:13).EQ.'DOUBLECOMPLEX') THEN
         FSTART = 14
         GO TO 1170
      ENDIF
1111  IF (ALPSTR1(1:10).EQ.'SUBROUTINE') THEN
         CALL SCNALPHA (7, CNT, LEN)
         PROCNAME = ALPSTR1 (11:CNT)
         RETURN
      ENDIF
1090  IF (ALPSTR1(1:9).EQ.'CHARACTER') THEN
         FSTART = 10
         GO TO 1170
      ELSE IF (ALPSTR1(1:9).EQ.'BLOCKDATA') THEN
         RETURN
      ENDIF
1080  IF (ALPSTR1(1:8).EQ.'FUNCTION') THEN
         CALL SCNALPHA (7, CNT, LEN)
         PROCNAME = ALPSTR1 (9:CNT)
         RETURN
      ENDIF
1070  IF (ALPSTR1(1:7).EQ.'INTEGER') THEN
         FSTART = 8
         GO TO 1170
      ELSE IF (ALPSTR1(1:7).EQ.'LOGICAL') THEN
         FSTART = 8
         GO TO 1170
      ELSE IF (ALPSTR1(1:7).EQ.'COMPLEX') THEN
         FSTART = 8
         GO TO 1170
      ELSE IF (ALPSTR1(1:7).EQ.'PROGRAM') THEN
         CALL SCNALPHA (7, CNT, LEN)
         PROCNAME = ALPSTR1 (8:CNT)
         RETURN
      ENDIF
1040  IF (ALPSTR1(1:4) .EQ. 'REAL') THEN
         FSTART = 5
         GO TO 1170
      ENDIF
      GO TO 1190
C  FIND A LETTER AND CHECK FOR 'FUNCTION'
1170  CONTINUE
      IF (BUFFCODE (SCANTO) .EQ. ASTERIX) THEN
         SCANTO = SCANTO + 1
         CALL SKIPBLANKS
         CALL USINTC
         CALL SCNALP (SCANTO, CNT, LEN)
         I = 1
      ELSE
         I = FSTART
      ENDIF
      IF (ALPSTR1 (I:I + 7) .EQ. 'FUNCTION') THEN
         PROCNAME = ALPSTR1 (I+8:CNT)
         J = CNT - (I + 7)
         CALL SCNALPHA (SCANTO, CNT, LEN)
         IF (CNT .GT. 0) THEN
            PROCNAME (J+1:) = ALPSTR1 (1:CNT)
         ENDIF
         RETURN
      ENDIF
1190  CONTINUE
      PROCNAME = '4MAIN'
      OK = .FALSE.
      END
      SUBROUTINE DECLAR (OK, PRNTED)
**********
*        *
* DECLAR *
*        *
**********
*     DECLAR expects to find a declaration statement.  If it does
*  not OK is set to .FALSE. to indicate that the line must be
*  reparsed as an executable statement.
*     PRNTED returns .TRUE. if the line was printed out, .FALSE.
*  if it was not.
*
*
      IMPLICIT LOGICAL(A-Z)
      INTEGER CNT, FSTART, SKANTO
      LOGICAL OK, PRNTED
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF7
 
      OK = .TRUE.
      PRNTED = .FALSE.
      PNBUFF=0
      SKANTO = 1
      CALL SCNEXP ('=', SKANTO)
      IF (SKANTO .LE. LEN) GOTO 1190
      CALL SCNALPHA(7,CNT,LEN)
      IF (CNT .LT. 4) GO TO 1190
      GO TO (1190,1190,1190,1040,1040,1060,1070,1080,1090,1090,1110,
     1     1110,1130,1130),CNT
      IF (ALPSTR1(1:15).EQ.'DOUBLEPRECISION') THEN
         FSTART = 16
         GO TO 2
      ENDIF
1130  IF (ALPSTR1(1:13).EQ.'DOUBLECOMPLEX') THEN
         FSTART = 14
         GO TO 2
      ENDIF
1110  IF (ALPSTR1(1:11).EQ.'EQUIVALENCE') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) RETURN
      ENDIF
1090  IF (ALPSTR1(1:9).EQ.'CHARACTER') THEN
         FSTART = 10
         GO TO 1
      ENDIF
      IF (ALPSTR1(1:9).EQ.'DIMENSION') THEN
         FSTART = 10
         GO TO 2
      ENDIF
      IF (ALPSTR1(1:9).EQ.'PARAMETER') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) RETURN
      ENDIF
      IF (ALPSTR1(1:9).EQ.'INTRINSIC') THEN
         FSTART = 10
         GO TO 3
      ENDIF
1080  IF (ALPSTR1(1:8).EQ.'NAMELIST') THEN
         IF (SCANTO .GT. LEN) RETURN
         IF (BUFFCODE (SCANTO) .EQ. COMMA) RETURN
      ENDIF
      IF (ALPSTR1(1:8).EQ.'IMPLICIT') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) RETURN
      ENDIF
      IF (ALPSTR1(1:8).EQ.'EXTERNAL') THEN
         FSTART = 9
         GO TO 3
      ENDIF
      IF (ALPSTR1(1:8).EQ.'CONSTANT') THEN
         IF (BUFFCODE (SCANTO) .EQ. COMMA) RETURN
      ENDIF
1070  IF (ALPSTR1(1:7).EQ.'INTEGER') THEN
         FSTART = 8
         GO TO 1
      ENDIF
      IF (ALPSTR1(1:7).EQ.'LOGICAL') THEN
         FSTART = 8
         GO TO 1
      ENDIF
      IF (ALPSTR1(1:7).EQ.'COMPLEX') THEN
         FSTART = 8
         GO TO 1
      ENDIF
      IF (ALPSTR1(1:7).EQ.'INCLUDE') THEN
         IF (BUFFCODE (SCANTO) .NE. EQUALSIGN) RETURN
      ENDIF
1060  IF (ALPSTR1(1:6).EQ.'COMMON') THEN
         IF (SCANTO .GT. LEN) RETURN
         IF (BUFFCODE (SCANTO) .EQ. COMMA) RETURN
         IF (BUFFCODE (SCANTO) .EQ. SLASH) RETURN
      ENDIF
      IF (ALPSTR1(1:6).EQ.'GLOBAL') THEN
         FSTART = 7
         GO TO 2
      ENDIF
1040  IF (ALPSTR1(1:4).EQ.'DATA') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) RETURN
         IF (BUFFCODE (SCANTO) .EQ. COMMA) RETURN
         IF (BUFFCODE (SCANTO) .EQ. SLASH) RETURN
      ENDIF
      IF (ALPSTR1(1:4).EQ.'REAL') THEN
         FSTART = 5
         GO TO 1
      ENDIF
      IF (ALPSTR1(1:4).EQ.'SAVE') THEN
         FSTART = 5
         GO TO 3
      ENDIF
      GO TO 1190
1     CONTINUE
      IF (SCANTO .GT. LEN) GOTO 5
      IF (BUFFCODE (SCANTO) .EQ. ASTERIX) GOTO 5
2     CONTINUE
      IF (SCANTO .GT. LEN) GOTO 5
      IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) GOTO 5
3     CONTINUE
      IF (SCANTO .GT. LEN) GOTO 5
      IF (BUFFCODE (SCANTO) .EQ. COMMA) GOTO 5
 
*  this is no declaration statement
 
      GOTO 1190
 
C  CHECK TO SEE IF DECLARATION SHOULD BE REFORMATTED
 
5     CONTINUE
      IF (DECSCN) THEN
         CALL SCNDEC (FSTART)
         PRNTED = .TRUE.
      ENDIF
      RETURN
1190  CONTINUE
      OK = .FALSE.
      END
      SUBROUTINE LYNSCN (STATUS)
**********
*        *
* LYNSCN *
*        *
**********
*     LYNSCN scans BUFF, changing any labels found and placing the new
* line into NEWBUF.
*     A value of one to four will be returned throught STATUS
* depending on what was found when the line was scanned.
*
*             STATUS = 1    FORMAT statement found
*             STATUS = 2    END statement found
*             STATUS = 3    default value
*             STATUS = 4    declaration statement (already printed)
*             STATUS = 5    declaration statement (not printed)
*
*     AGAIN is .FALSE. if the line is being scanned for the first time
* and .TRUE. if it is being rescanned.  When AGAIN is .TRUE. it tells
* LYNSCN to change only those labels followed by a special symbol.('&')
*     If all labels were changed successfully a value of .TRUE. is
* returned thru DONE, otherwise a value of .FALSE. is returned.
*
*
      INTEGER I,J,LABL,VALUE,CNT, STATUS, TSCANTO
      LOGICAL PRNTED, OK
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF4
      INCLUDE TIDY_CF2
      INCLUDE TIDY_CF7
      INCLUDE TIDY_CF5
 
      STATUS=3
      DONE=.TRUE.
 
*  Is this a declaration statement?
 
      IF (.NOT. AGAIN) THEN
         CALL DECLAR (OK, PRNTED)
         IF (PRNTED) THEN
            STATUS = 4
            RETURN
         ENDIF
         IF (OK) THEN
            STATUS = 5
            RETURN
         ENDIF
      ENDIF
      PNTP=0
      PNBUFF=0
      CALL CATEN8 (1, 6)
 
*  Return if we have scanned to the end of the line
 
1200  IF (PBUFF.GT.LEN) RETURN
************************************************************************
*     SCAN UP TO FIRST NON ALPHABETIC CHARACTER TO CHECK FOR KEYWORD
************************************************************************
      CALL SCNALP(PBUFF,CNT,LEN)
 
*  Do a computed GOTO on the number of alphabetic characters
*  found before a non-alphabetic, non-blank character was found.
*  In this way we only have to compare the string scanned with
*  those keywords that have the same number of letters.
 
      GOTO (1210,1220,1230,1240,1250,1260,1270,1280,1290),CNT
      GO TO 1300
1210  GO TO 1300
1220  IF (ALPSTR1(1:2).EQ.'IF') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            CALL KEYWORD
            GO TO 1370
         ENDIF
      ELSE IF (ALPSTR1(1:2).EQ.'DO') THEN
         TSCANTO = SCANTO
         CALL DECNUM(SCANTO,J,LABL,AGAIN)
         IF (LABL.EQ.0) GO TO 1320
         IF (BUFFCODE(J) .EQ. COMMA) GO TO 1400
         CALL FNDNAN(J,I)
         IF (BUFFCODE(I) .NE. EQUALSIGN) THEN
            CALL CATEN8 (PBUFF, I)
            GOTO 1330
         ENDIF
         SCANTO=I+1
         CALL SCNEXP(',',SCANTO)
         IF (SCANTO.GT.LEN) GO TO 1330
C  THI   S IS DEFINITELY A DO LOOP
1400     CONTINUE
         CALL ADDON ('DO ')
         PBUFF = TSCANTO
         CALL SCRHTR(LABL,J-1,.TRUE.)
         IF (.NOT. AGAIN) THEN
            PIND=PIND+1
            INDSTK(PIND)=LABL
            TABNXT = TABNXT + 1
         ENDIF
         GOTO 1330
      ENDIF
      GO TO 1300
1230  IF (ALPSTR1(1:3).EQ.'END') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            STATUS = 2
            RETURN
         ENDIF
      ENDIF
      GO TO 1300
1240  IF (ALPSTR1(1:4).EQ.'GOTO') THEN
         IF (BUFFCODE(SCANTO) .EQ. LEFTBRACKET) GOTO 1360
         TSCANTO = SCANTO
         CALL DECNUM(TSCANTO,SCANTO,LABL,AGAIN)
         IF (.NOT.(SCANTO.GT.LEN)) GO TO 1330
         CALL ADDON ('GOTO ')
         PBUFF = TSCANTO
         CALL SCRHTR(LABL,SCANTO-1,.TRUE.)
         RETURN
1360     CONTINUE
         CALL COPYONE
         CALL SMTLST
         CALL COPYONE
         GOTO 1330
      ELSE IF (ALPSTR1(1:4).EQ.'READ') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:4).EQ.'OPEN') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            CALL KEYWORD
            CALL COPYONE
            GOTO 1330
         ENDIF
      ELSE IF (ALPSTR1(1:4).EQ.'ELSE') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            IF (IF LEV .GT. 0) THEN
               SPACE = -TABSIZ
            ELSE
               CALL ONLINE
               WRITE (UNIT=899, FMT=9001)
9001        FORMAT (' **ERROR** ELSE with no matching ',
     *        'IF .. THEN statement was found.')
            ENDIF
            RETURN
         ENDIF
      ELSE IF (ALPSTR1(1:4).EQ.'STOP') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            RETURN
         ELSE IF (BUFFCODE (SCANTO) .EQ. SINGLEQUOTE) THEN
            CALL KEYWORD
            CALL CATEN8 (SCANTO, LEN)
            RETURN
         ELSE IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            TSCANTO = SCANTO
            CALL DECNUM (TSCANTO, SCANTO, LABL, .FALSE.)
            IF (SCANTO .GT. LEN) THEN
               CALL ADDON ('STOP ')
               CALL CATEN8 (TSCANTO, LEN)
               RETURN
            ELSE
               GOTO 1320
            ENDIF
         ENDIF
      ENDIF
      GO TO 1300
1250  IF (ALPSTR1(1:5).EQ.'WRITE') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:5).EQ.'PUNCH') THEN
         GO TO 1430
      ELSE IF (ALPSTR1(1:5).EQ.'PRINT') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:5).EQ.'CLOSE') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            CALL KEYWORD
            CALL COPYONE
            GOTO 1330
         ENDIF
      ELSE IF (ALPSTR1(1:5).EQ.'ENDIF') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            IF (IF LEV .GT. 0) THEN
               IF LEV = IF LEV - 1
               TABNOW = -1
            ELSE
               CALL ONLINE
               WRITE (UNIT=899, FMT=9000)
9000        FORMAT (' **ERROR** ENDIF with no matching ',
     *        'IF .. THEN statement was found.')
            ENDIF
            RETURN
         ENDIF
      ELSE IF (ALPSTR1(1:5).EQ.'PAUSE') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            RETURN
         ELSE IF (BUFFCODE (SCANTO) .EQ. SINGLEQUOTE) THEN
            CALL KEYWORD
            CALL CATEN8 (SCANTO, LEN)
            RETURN
         ELSE IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            TSCANTO = SCANTO
            CALL DECNUM (TSCANTO, SCANTO, LABL, .FALSE.)
            IF (SCANTO .GT. LEN) THEN
               CALL ADDON ('PAUSE ')
               CALL CATEN8 (TSCANTO, LEN)
               RETURN
            ELSE
               GOTO 1320
            ENDIF
         ENDIF
      ENDIF
      GO TO 1300
1260  IF (ALPSTR1(1:6).EQ.'FORMAT') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            CALL KEYWORD
            STATUS = 1
            RETURN
         ENDIF
      ELSE IF (ALPSTR1(1:6).EQ.'REPEAT') THEN
         IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            CALL KEYWORD
            CALL DECNUM(PBUFF,SCANTO,LABL,AGAIN)
            CALL SCRHTR(LABL,SCANTO-1,.FALSE.)
            IF (AGAIN) GO TO 1330
            IF (LABL.EQ.0) GO TO 1330
            PIND=PIND+1
            INDSTK(PIND)=LABL
            TABNXT = TABNXT + 1
         ENDIF
      ELSE IF (ALPSTR1(1:6).EQ.'ENCODE') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:6).EQ.'DECODE') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:6).EQ.'DECODE') THEN
         GO TO 1450
      ELSE IF (ALPSTR1(1:6).EQ.'ASSIGN') THEN
         IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            CALL KEYWORD
            CALL DECNUM(PBUFF,SCANTO,LABL,AGAIN)
            CALL SCRHTR(LABL,SCANTO-1,.TRUE.)
            GO TO 1330
         ENDIF
      ELSE IF (ALPSTR1(1:6).EQ.'ACCEPT') THEN
         GO TO 1430
      ELSE IF (ALPSTR1(1:6).EQ.'REWIND') THEN
         IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            CALL KEYWORD
            GO TO 1330
         ENDIF
      ELSE IF (ALPSTR1(1:6).EQ.'ELSEIF') THEN
         IF (BUFFCODE(SCANTO) .NE. LEFTBRACKET) GO TO 1330
         CALL ADDON ('ELSE IF ')
         PBUFF = SCANTO
         IF (IF LEV .GT. 0) THEN
            SPACE = -TABSIZ
         ELSE
            CALL ONLINE
            WRITE (UNIT=899, FMT=9002)
9002     FORMAT (' **ERROR** ELSEIF with no matching ',
     *     'IF .. THEN statement was found.')
         ENDIF
* IF LEV = IF LEV - 1 TO "cancel out" IF statement code.
            IF LEV = IF LEV - 1
* TABNXT = -1 to "cancel out" IF statement code
         TABNXT = -1
         GO TO 1370
      ENDIF
      GO TO 1300
1270  IF (ALPSTR1(1:7).EQ.'INQUIRE') THEN
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            CALL KEYWORD
            CALL COPYONE
            GOTO 1330
         ENDIF
      ELSE IF (ALPSTR1(1:7).EQ.'ENDFILE') THEN
         IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            CALL KEYWORD
            GO TO 1330
         ENDIF
      ENDIF
      GO TO 1300
1280  IF (ALPSTR1(1:8).EQ.'CONTINUE') THEN
         IF (SCANTO .GT. LEN) THEN
            CALL KEYWORD
            RETURN
         ENDIF
      ENDIF
      GO TO 1300
1290  IF (ALPSTR1(1:9).EQ.'BACKSPACE') THEN
         IF (BUFFCODE (SCANTO) .EQ. DIGIT) THEN
            CALL KEYWORD
            GO TO 1330
         ENDIF
      ENDIF
 
*  If we fall through to here check for keywords that are immediately
*  followed by alphanumeric characters (and hence can't be parsed
*  with the previous computed GOTO.)
 
1300  CONTINUE
      GOTO (1319, 1319, 1319, 1319, 1302), CNT
1302  CONTINUE
      IF (ALPSTR1 (1:4) .EQ. 'GOTO') GOTO 1318
1319  CONTINUE
      GOTO 1320
************************************************************************
*  Possible assigned GOTO statement
************************************************************************
1318  CONTINUE
      IF (BUFFCODE (SCANTO) .EQ. COMMA) CALL FNDNAN (SCANTO+1,SCANTO)
      IF (BUFFCODE(SCANTO) .NE. LEFTBRACKET) GOTO 1320
 
*  Assigned GOTO found
 
      CALL CATEN8(PBUFF,SCANTO)
      CALL SMTLST
      CALL COPYONE
      GO TO 1330
************************************************************************
* IF WE FALL THROUGH TO HERE THIS MUST BE AN ORDINARY ASSIGNMENT
* STATEMENT
************************************************************************
1320  CALL FNDNAN (SCANTO, SCANTO)
      CALL CATEN8(PBUFF,SCANTO-1)
1330  IF (PBUFF.GT.LEN) RETURN
1340  CALL ACTSCN
      GO TO 1200
************************************************************************
*  POSSIBLE IF STATEMENT
************************************************************************
1370  IF (BUFFCODE(PBUFF) .NE. LEFTBRACKET) GO TO 1330
      CALL COPYONE
      CALL ACTSCN
      CALL DECNUM(PBUFF,SCANTO,VALUE,.FALSE.)
      IF (VALUE.EQ.0) GO TO 1380
*   arithmetic IF statement
      CALL ADDONE (' ')
      CALL SMTLST
      RETURN
*   check for THEN clause
1380  CALL SCNALP (PBUFF, CNT, LEN)
      IF (CNT.NE.4 .OR. ALPSTR1(1:4).NE.'THEN') GO TO 1200
      IF LEV = IF LEV + 1
      TABNXT = TABNXT + 1
      GO TO 1200
************************************************************************
*  TYPE, PRINT, PUNCH OR OTHER SIMILAR STATEMENT FOUND
************************************************************************
1430  CONTINUE
      TSCANTO = SCANTO
      CALL DECNUM(SCANTO,SCANTO,LABL,AGAIN)
      IF (SCANTO.GT.LEN) GO TO 1440
      IF (BUFFCODE(SCANTO) .EQ. COMMA) GO TO 1440
      IF (BUFFCODE(SCANTO) .EQ. SEMICOLAN) GO TO 1440
      CALL CATEN8(PBUFF,SCANTO-1)
      GO TO 1330
1440  CONTINUE
      CALL CATEN8 (PBUFF, TSCANTO - 1)
      CALL ADDONE (' ')
      CALL SCRHTR(LABL,SCANTO-1,.FALSE.)
      GO TO 1330
************************************************************************
*  POSSIBLE READ, WRITE, PRINT, DECODE OR ENCODE STATEMENT
************************************************************************
1450  IF (BUFFCODE(SCANTO) .NE. LEFTBRACKET) GO TO 1430
      CALL KEYWORD
      CALL COPYONE
C  CHECK FOR KEYWORD MODE
      CALL FNDNAN(PBUFF,SCANTO)
      IF (BUFFCODE(SCANTO) .EQ. EQUALSIGN) THEN
         CALL ACTSCN
         GO TO 1330
      ENDIF
1460  CALL COPYONE
      GO TO (1460,1460,1460,1470,1330,1460,1460,1480,1460,1460,1460,
     1     1460,1460,1460,1460), BUFFCODE(PBUFF-1)
C  LEFT BRACKET FOUND
1470  CALL ACTSCN
      GO TO 1460
C  COMMA FOUND - REACHED FORMAT SPECIFIER
1480  CALL DECNUM(PBUFF,SCANTO,LABL,AGAIN)
      CALL SCRHTR(LABL,SCANTO-1,.FALSE.)
      CALL ACTSCN
      GO TO 1330
      END
      SUBROUTINE ADDON (STRING)
***********
*         *
*  ADDON  *
*         *
***********
*  Catenate STRING onto NEWBUF.  Since we have a global variable
*  called LEN (a legacy from CPV TIDY in the dark days before
*  character variables and the LEN function) we must pass the
*  buck onto another routine AADDON.
      CHARACTER STRING*(*)
 
      CALL AADDON (STRING, LEN(STRING))
      END
      SUBROUTINE AADDON (STRING, LENGTH)
***********
*         *
*  AADDON  *
*         *
***********
*  This routine does the work for ADDON.
      CHARACTER STRING*(*)
      INTEGER I
      INCLUDE TIDY_CF6
 
      DO 10, I=1, LENGTH
         PNBUFF = PNBUFF + 1
         NEWBUF(PNBUFF) = STRING(I:I)
10    CONTINUE
      END
      SUBROUTINE ENCNUM(NUMBIN,ARRAY,SIZE)
************
*          *
*  ENCNUM  *
*          *
************
*  Convert binary number NUMBIN to a BCD string in ARRAY.  Length
*  of string created is returned through SIZE.
      INCLUDE TIDY_CF7
      IMPLICIT LOGICAL (A-Z)
      INTEGER NUMBER,NUMBIN,SIZE,I,END
      CHARACTER ARRAY(5)*1,CHAR(10)*1
      SAVE CHAR
      DATA CHAR/'0','1','2','3','4','5',
     1         '6','7','8','9'/
 
      SIZE=0
      NUMBER=NUMBIN
      IF (NUMBER .GT. 99999) THEN
         CALL OUT ('**TRAP** Argument to ENCNUM is > 99999.')
         CALL ERRTXT
      ENDIF
      IF (NUMBER/100) 1080,1000,1010
 1000 IF (NUMBER/10) 1080,1070,1060
 1010 IF (NUMBER/1000) 1080,1050,1020
 1020 IF (NUMBER/10000) 1080,1040,1030
 1030 SIZE=SIZE+1
      ARRAY(SIZE)=CHAR(NUMBER/10000+1)
      NUMBER=MOD(NUMBER,10000)
 1040 SIZE=SIZE+1
      ARRAY(SIZE)=CHAR(NUMBER/1000+1)
      NUMBER=MOD(NUMBER,1000)
 1050 SIZE=SIZE+1
      ARRAY(SIZE)=CHAR(NUMBER/100+1)
      NUMBER=MOD(NUMBER,100)
 1060 SIZE=SIZE+1
      ARRAY(SIZE)=CHAR(NUMBER/10+1)
      NUMBER=MOD(NUMBER,10)
 1070 SIZE=SIZE+1
      ARRAY(SIZE)=CHAR(NUMBER+1)
      IF (JUSTIFY) THEN
         IF (SIZE .LT. 5) THEN
            END = 5
            DO 1075 I = SIZE,1,-1
               ARRAY(END) = ARRAY(I)
               END = END - 1
1075        CONTINUE
           DO 1077 I = END,1,-1
              ARRAY(I) = ' '
1077       CONTINUE
         ENDIF
      ENDIF
      RETURN
C     **ERROR** THE NUMBER TO BE ENCODED IS NEGATIVE, PRINT ERROR
C     MESSAGE AND STOP.
1080  CONTINUE
      CALL ONLINE
      CALL OUT ('**TRAP** Argument to ENCNUM is negative.')
      CALL ERRTXT
      END
      SUBROUTINE TRANSBUF
*************
*           *
* TRANSBUF  *
*           *
*************
*  initialize BUFFCODE array to character type of corresponding
*  characters in BUFF.
      INCLUDE TIDY_CF6
      INTEGER I
*
      DO 10, I=1, LEN
          BUFFCODE(I) = CHRSET(ICHAR(BUFF(I)))
10    CONTINUE
      END
      SUBROUTINE CATEN8(BEGIN,FIN)
*************
*           *
*  CATEN8   *
*           *
*************
C     CATEN8 CATENATES 'BUFF' FROM 'BEGIN' TO 'FIN' ONTO 'NEWBUF'.
C 'PBUFF' IS THAN SET TO POINT TO 'FIN+1'.
      IMPLICIT LOGICAL (A-Z)
      INTEGER BEGIN, FIN, I
      INCLUDE TIDY_CF6
 
      I = FIN - BEGIN + 1
      IF (I .LE. 0) RETURN
      NEWSTR (PNBUFF+1:PNBUFF+I) = OLDSTR (BEGIN:FIN)
      PNBUFF = PNBUFF + I
      PBUFF = FIN + 1
      END
      SUBROUTINE SCNALP (BEGIN, CNT, LINELEN)
*************
*           *
*  SCNALP   *
*           *
*************
*  Scans BUFF file from BEGIN until a non-blank, non-alphabetic
*  character is found.  Alphabetic characters are stored into
*  ALPSTR1.  CNT returns number of alphabetic characters parsed.
*  LINELEN is the length of BUFF.
 
      INTEGER BEGIN, CNT, LINELEN
      INCLUDE TIDY_CF6
 
      CNT = 0
      DO 10, SCANTO = BEGIN, LINELEN
         GOTO (10, 1000), BUFFCODE (SCANTO)
         RETURN
1000     CNT = CNT + 1
         ALPSTR (CNT) = BUFF (SCANTO)
10    CONTINUE
      END
      SUBROUTINE SCNALPHA (BEGIN, CNT, LINELEN)
*************
*           *
* SCNALPHA  *
*           *
*************
*  Same function as SCNALP except that it parses alphanumeric
*  characters.
 
      INTEGER BEGIN, CNT, LINELEN
      INCLUDE TIDY_CF6
      CNT = 0
      DO 10, SCANTO = BEGIN, LINELEN
         GOTO (10, 1000, 1000), BUFFCODE (SCANTO)
         RETURN
1000     CNT = CNT + 1
         ALPSTR (CNT) = BUFF (SCANTO)
10    CONTINUE
      END
      SUBROUTINE NEWLYN
************
*          *
*  NEWLYN  *
*          *
************
*  NEWLYN simply reads a new line into the temporary buffer.
*  It may also set the EOF flag if end of file is reached or
*  the CMENT flag if the line is a comment.
 
      INCLUDE TIDY_CF8
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF5
 
      TBUFF2 = ' '
      CALL READSOUR (TBUFF2, LEN2, 120, EOF, TLINE)
      IF (EOF) RETURN
      IF (LEN2 .EQ. 0) THEN
         LEN2 = 1
         CMENT = .TRUE.
         RETURN
      ENDIF
 
*  Check to see if the line is a comment
 
      IF (TBUFF2 (1:LEN2) .EQ. ' ') GO TO 1020
      IF (TBUFF(1).EQ.'*') GOTO 1020
      IF (TBUFF(1).EQ.'C') GO TO 1020
      IF (TBUFF(1).EQ.'$') GO TO 1020
      CMENT=.FALSE.
      RETURN
 
 1020 CMENT=.TRUE.
      END
      SUBROUTINE NXTLYN
*************
*           *
*  NXTLYN   *
*           *
*************
*  NXTLYN catenates lines from the temporary buffer to form
*  complete lines.  If the end of file flag is set we are
*  finished and the program halts.  If the comment flag is set
*  the temporary buffer is output and a new one is read in.
 
      INTEGER ABC
      INTEGER  LBLNEW,FMTNEW
         EXTERNAL KONTINUED
         LOGICAL KONTINUED
      INCLUDE TIDY_CF8
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF7
      CHARACTER  COPYRT1*64
      CHARACTER  COPYRT2*64
      CHARACTER  COPYRT3*64
      INTEGER  QUOTECNT, TEMPIND
      LOGICAL  OPENLITERAL
      DATA  COPYRT1
     1/'C*T***********************************************************'/
 
      DATA  COPYRT2
     1/'C*T*                                                         *'/
 
      DATA  COPYRT3
     1/'C*T* Copyright (c) Bull HN, Inc. XXXX                        *'/
 
 1000 IF (EOF) THEN
         CALL FLUSH
         CALL ENDJOB
      ENDIF
      IF (CMENT) THEN
         IF (TBUFF2(1:4) .EQ. 'C*X*') THEN
            IF (.NOT. IGNOREX) THEN
          LBLNEW = LBLSRT
          FMTNEW = FMTSRT
               CALL PARSE$DR(TBUFF2,CMENT,DECSCN,DECPASCAL,
     2                           JUSTIFY,HOLDFORMATS,
     3                   NOINDENT,DEFAULT,TABSIZ,LBLNEW,
     4                   FMTNEW,LBLINC,FMTINC,IGNOREX,
     5                           YEAR,COMONLY,PROMPT,CYR)
      IF (FMTNEW .NE. FMTSRT) THEN
          FMTLBL = FMTNEW - FMTINC
          FMTSRT = FMTNEW
      ENDIF
      IF (LBLNEW .NE. LBLSRT) THEN
          LSTLBL = LBLNEW - LBLINC
          LBLSRT = LBLNEW
      ENDIF
           ENDIF
         ENDIF
         IF (CYR) THEN
            IF (YEAR(1:4) .LE. '0000') THEN
               CALL GETTIME(YEAR)
            ENDIF
            IF (TBUFF2(1:4) .EQ. 'C*T*') THEN
               COPYRT3(47:50) = YEAR(1:4)
               CALL WRITEBUF(COPYRT1,64,KEY)
               CALL WRITEBUF(COPYRT2,64,KEY+1)
               CALL WRITEBUF(COPYRT3,64,KEY+2)
               CALL WRITEBUF(COPYRT2,64,KEY+3)
               CALL WRITEBUF(COPYRT1,64,KEY+4)
               KEY = KEY + 5
               REPEAT 1010, WHILE (TBUFF2(1:4) .EQ. 'C*T*')
                  CALL NEWLYN
 1010          CONTINUE
               GO TO 1000
            ENDIF
         ENDIF
         CURRENTLINE = TLINE
         CALL WRITEBUF(TBUFF,LEN2,KEY)
         KEY=KEY+1
         CALL NEWLYN
         GO TO 1000
      ENDIF
 
*  If this is a continuation line blow the user away
 
      IF (KONTINUED (TBUFF2 (1:LEN2))) THEN
         CALL ONLINE
         CALL OUT ('**ERROR** TIDY does not like comments located in')
         CALL OUT ('the middle of a statement.')
         CALL ERRTXT
      ENDIF
      CURRENTLINE = TLINE
 
*  If there is card sequencing save it
 
      IF (LEN2 .GT. 72) THEN
         $COMMENT = LEN2 - 72
         COMMENT (1:$COMMENT) = TBUFF2 (73:LEN2)
         LEN2 = 72
         CALL TRIM (TBUFF2, LEN2)
      ELSE
         $COMMENT = 0
      ENDIF
      LEN2 = MAX0 (LEN2, 6)
 
*  Copy the first 6 characters to OLDSTR/BUFF and treat the rest
*  of the first line as a continuation line.
 
      OLDSTR (1:6) = TBUFF2 (1:6)
      LEN = 6
      RECPTR=0
      GO TO 1040
 
 1030 CALL NEWLYN
 
*  Are we done yet?
 
      IF (EOF .OR. CMENT .OR. .NOT.KONTINUED(TBUFF2(1:LEN))) THEN
         CALL TRANSBUF
         BUFFCODE (LEN+1) = BLANK
         OLDSTR (LEN+1:LEN+17) = ' '
         RETURN
      ENDIF
 
*  We want to ignore card sequencing on continuation lines, so
*  trim blanks back from column 72.
 
      LEN2 = MIN0 (LEN2, 72)
 
*    SAVE THE FIRST 6 CHARACTERS OF THE CONTINUATION LINE
 
      CONTINUE6(RECPTR) = TBUFF2(1:6)
 
 1040 IF (.NOT. OPENLITERAL) THEN
*   Trim leading blanks
 
         DO 1050 ABC=7,LEN2
          IF (TBUFF(ABC).NE.' ')   GO TO 1060
 1050    CONTINUE
      GO TO 1030
      ELSE
         ABC = 7
      ENDIF
 
*  Check the number of quotes in the line
 
1060     QUOTECNT = 0
         DO 900 TEMPIND = 1, LEN2
            IF (TBUFF(TEMPIND) .EQ. '''') THEN
               QUOTECNT = QUOTECNT + 1
            ENDIF
  900    CONTINUE
         IF (QUOTECNT .NE. QUOTECNT / 2 * 2) THEN
            IF (OPENLITERAL) THEN
               OPENLITERAL = .FALSE.
            ELSE
               OPENLITERAL = .TRUE.
            ENDIF
         ENDIF
      IF (.NOT. OPENLITERAL) THEN
         CALL TRIM (TBUFF2,LEN2)
      ENDIF
      RECPTR = RECPTR + 1
      IF (RECPTR .GT. 19) THEN
            CALL ONLINE
            CALL OUT('** WARNING ** A statement containing more')
            CALL OUT('than 19 continuation cards was found.')
            CALL OUT('This statement will not be formatted.')
         RECPTR = 19
         CALL OLDOUT (KEY,0)
         RECPTR = 1
         REPEAT 1070, WHILE (KONTINUED(TBUFF2(1:LEN))
     1                       .AND. .NOT. CMENT
     2                       .AND. .NOT. EOF)
            RECLEN(1) = LEN2
            OLDSTR(1:120) = TBUFF2(1:120)
            CALL OLDOUT (KEY,0)
            CALL NEWLYN
 1070    CONTINUE
         CALL TRANSBUF
         BUFFCODE (LEN + 1) = BLANK
         OLDSTR (LEN+1:LEN+17) = ' '
         GOTO 1000
      ENDIF
      RECIND (RECPTR) = ABC - 7
      OLDSTR (LEN+1:LEN+LEN2-ABC+1) = TBUFF2 (ABC:LEN2)
      LEN = LEN + LEN2 - ABC + 1
      RECLEN(RECPTR)=LEN
      IF (LEN .GT. 4000) THEN
         CALL ONLINE
         CALL OUT('**ERROR** A statement containing more than 4000')
        CALL OUT(' characters was found.  You should limit yourself')
         CALL OUT(' to 19 continuation cards as this is all the')
         CALL OUT(' FORTRAN standard allows.')
         CALL ERRTXT
      ENDIF
      GO TO 1030
      END
      SUBROUTINE DECNUM(BEGIN,FIN,VALUE,AGAIN1)
************
*          *
*  DECNUM  *
*          *
************
*  DECNUM decodes a label from BUFF starting at BEGIN.  DECNUM
* scans until it hits a non numeric character.  What DECNUM does next
* depends on the value of AGAIN1.
 
*     AGAIN1 = .FALSE.  AGAIN1 has this value the first time a line
*                    is scanned.
 
*     AGAIN1 = .TRUE.   If the next character is a '#' then the value
*                       decoded is returned; otherwise 0 is returned.
*                       '#' is used to tell us what labels have not
*                       been changed when we rescan lines.
 
      LOGICAL AGAIN1
      INTEGER BEGIN, FIN, VALUE, I, CLASS, DIGITS
      INCLUDE TIDY_CF6
 
      VALUE = 0
      DIGITS = 0
      DO 10 FIN = BEGIN, LEN
         CLASS = BUFFCODE (FIN)
         IF ((CLASS .NE. BLANK) .AND. (CLASS .NE. DIGIT)) THEN
            GOTO 20
         ELSE  IF (CLASS .EQ. BLANK) THEN
                  GOTO 10
               ELSE
                  VALUE = VALUE * 10 + ICHAR(BUFF(FIN)) - ICHAR('0')
                  DIGITS = DIGITS + 1
               ENDIF
 
        IF (DIGITS .GT. 8) VALUE = 0
  10  CONTINUE
      FIN = LEN + 1
  20  IF (CLASS .NE. NUMBERSIGN) THEN
         GO TO 50
      ELSE  IF (.NOT. AGAIN1) THEN
                GOTO 50
            ELSE
      ENDIF
 
      DO 30, I = FIN + 1, LEN
         FIN = I
         IF (BUFFCODE (FIN) .NE. BLANK) GOTO 40
  30  CONTINUE
      FIN =  LEN + 1
  40  CONTINUE
      RETURN
  50  CONTINUE
      IF ((AGAIN1) .OR. (DIGITS .GT. 5)) VALUE = 0
      END
      INTEGER FUNCTION LENGTH(MAX)
*************
*           *
*  LENGTH   *
*           *
*************
*  LENGTH scans back in BUFF from point MAX until a nonblank character
*  is found.  This point is returned throught LENGTH.
 
      INTEGER MAX
      INCLUDE TIDY_CF6
      DO 1000 , LENGTH=MAX,1,-1
         IF (BUFFCODE (LENGTH) .NE. BLANK) RETURN
 1000 CONTINUE
      LENGTH = 0
      END
      SUBROUTINE FNDNAN(BEGIN,SKANTO)
**************
*            *
*  FNDNAN    *
*            *
**************
*  FNDNAN scans BUFF starting at BEGIN until it finds a non
*  alphanumeric character.  This point is returned through SKANTO.
*  Blanks are considered to be alphanumeric characters.  If the
*  end of BUFF is reached LEN+1 is returned.
 
      INTEGER BEGIN,SKANTO
      INCLUDE TIDY_CF6
 
      DO 1000 SKANTO=BEGIN,LEN
          GO TO (1000,1000,1000,1010,1010,1010,1010,1010,1010,1010,1010,
     1         1010,1010,1010,1010,1010),BUFFCODE (SKANTO)
 1000 CONTINUE
      SKANTO=LEN+1
 1010 END
      SUBROUTINE OUT (STRING)
************
*          *
*  OUT     *
*          *
************
*  OUT just writes STRING out to the terminal.
 
      CHARACTER STRING * (*)
 
      WRITE (UNIT=899, FMT='(5X,A)') STRING
      END
      LOGICAL FUNCTION KONTINUED (STRING)
**************
*            *
* KONTINUED  *
*            *
**************
*  Inspects STRING to see if it is a FORTRAN continuation line.
 
      CHARACTER STRING*(*)
      KONTINUED = .FALSE.
      IF (LEN (STRING) .LT. 6) RETURN
      IF (STRING(6:6) .EQ. ' ') RETURN
      IF (STRING(6:6) .EQ. '0') RETURN
      KONTINUED = .TRUE.
      END
      SUBROUTINE TRIM (STRING, SIZE)
************
*          *
*  TRIM    *
*          *
************
*  Trims trailing blanks off of STRING which is of length SIZE.
*  New length of STRING is returned through SIZE.
 
      CHARACTER STRING*140
      INTEGER SIZE
      DO 10, SIZE=SIZE, 1, -1
         IF (STRING (SIZE:SIZE) .NE. ' ') RETURN
10    CONTINUE
      SIZE = 0
      END
      SUBROUTINE LETCHAR (TO, FROM, SIZE)
***********
*         *
* LETCHAR *
*         *
***********
*  Copy string FROM to TO.  Length of both strings is SIZE.
      INTEGER SIZE
      CHARACTER TO*1, FROM*1
 
      TO (1:SIZE) = FROM (1:SIZE)
      END
       SUBROUTINE LABEL(NLABEL,INCRE,BUF)
**********
*        *
* LABEL  *
*        *
**********
*  searches the first 5 characters of BUF to see if it contains
*  a label.  If it does a new label is placed in the first 5
*  columns and the old label and its new equivalent are added to
*  the hash table where labels are stored.
      INTEGER NLABEL,INCRE,I
      CHARACTER BUF*255
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF4
      INCLUDE TIDY_CF5
1000  IF (PIND.EQ.0) GO TO 1010
      IF (LLABEL.NE.INDSTK(PIND))     GO TO 1010
      PIND=PIND-1
      INDENT = INDENT - TABSIZ
      GO TO 1000
1010  NLABEL=NLABEL+INCRE
      CALL ADTREE(LLABEL,NLABEL)
      IF (CHRSET(ICHAR(BUF(1:1))) .NE. 2) THEN
          BUF(1:6) = ' '
          CALL ENCNUM (NLABEL, BUF, I)
        ELSE
          BUF (2:6) = ' '
          CALL ENCNUM (NLABEL, BUF(2:2), I)
          I = I + 1
      ENDIF
      IF (LLABEL .LT. 0) BUF(I+1:I+1) = '$'
      CURIND = INDENT + SPACE
      END
      SUBROUTINE LYNOUT(INDENT,KEY,BUF,LINELEN,MORIND)
**********
*        *
* LYNOUT *
*        *
**********
*  Writes out a source line.  The major difficulty here is the
*  need to split lines 'nicely'; we do not want to just write
*  out the source line in 72 character chunks.  Indenting is also
*  handled here, but this is no big deal.
*     The source line of length LINELEN is passed in through BUF.
*  INDENT specifies what indenting the first line should have;
*  continuation lines are indented INDENT + MORIND.  KEY is the
*  key to be assigned to the first line; it is incremented for
*  each line written out.
 
      INTEGER NDENT,INDENT,KEY,LINELEN,MORIND,CNT,
     1   NUM, GOODP, BEGIN, MDENT, QUOTECNT, TEMPIND,
     2   SAVEIND
      CHARACTER BUF(1326)*1
      INCLUDE TIDY_CF2
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF1
      INCLUDE TIDY_CF7
*
*  Fix up PNTSTK list before we start calling GOODP
*  First get rid of points that are greater than LEN.
*
1     IF (PNTP .GT. 0 .AND. PNTSTK (PNTP) .GT. LEN) THEN
         PNTP = PNTP - 1
         GOTO 1
      ENDIF
*  Add a point with the value LEN
      PNTP = PNTP + 1
      PNTSTK (PNTP) = LEN
      IF (NOINDENT) THEN
         NDENT = 0
      ELSE
         NDENT = MIN0 (INDENT, 20)
      ENDIF
      LSTCNT=0
      NUM=1
      CNT=MIN0(LINELEN,72-NDENT)
      MDENT = NDENT
      IF (CNT.NE.LINELEN) CNT=GOODP(CNT, MDENT)
      CALL WRITEFOR(BUF,MDENT,BUF(7),CNT-6,KEY)
      KEY=KEY+1
      IF (CNT.EQ.LINELEN) RETURN
      IF (CHRSET(ICHAR(BUF(1))) .EQ. 3) BUF(1) = ' '
      SAVEIND = MORIND
 1000 IF (.NOT. NOINDENT) THEN
         QUOTECNT = 0
         DO 900 TEMPIND = 1,CNT
            IF (BUF(TEMPIND) .EQ. '''') THEN
               QUOTECNT = QUOTECNT + 1
            ENDIF
  900    CONTINUE
         IF (QUOTECNT .NE. QUOTECNT / 2 * 2) THEN
            NDENT = 0
         ELSE
            NDENT = NDENT + MORIND
            MORIND = 0
         ENDIF
      ENDIF
      NUM = NUM + 1
      DO 1010 , BEGIN=CNT+1,LINELEN
          IF (BUF(BEGIN).NE.' ') GO TO 1020
1010  CONTINUE
1020  CNT=MIN0(LINELEN,CNT+66-NDENT)
      MDENT = NDENT
      IF (CNT.NE.LINELEN) CNT=GOODP(CNT, MDENT)
      CALL WRITEFOR(BUF(1)//'    '//ICHARS(NUM),MDENT,BUF(BEGIN),
     1     CNT-BEGIN+1,KEY)
      KEY=KEY+1
      IF (CNT.LT.LINELEN) GO TO 1000
      MORIND = SAVEIND
      END
      INTEGER FUNCTION GOODP(CNT, INDENT)
**********
*        *
* GOODP  *
*        *
**********
*     GOODP is used to find a good point to end a line.  CNT is the
* largest index into BUFF that GOODP can return for a line that
* will be indented INDENT spaces.  GOODP looks through PNTSTK, a
* list of 'nice' places to break a line that is created when a line
* is scanned.  If GOODP cannot find a nice place to break the line
* within the constraints imposed by CNT and INDENT it will break
* the indenting rules by returning a value larger than CNT and
* modifying INDENT as needed.
*     GOODP expects the last entry in PNTSTK to contain the value
* LEN.
      INTEGER CNT,GOOD,INDENT
      LOGICAL NOINDENT /.FALSE./
      SAVE NOINDENT
      INCLUDE TIDY_CF2
 
      GOODP = CNT
      IF (PNTP .EQ. 0) RETURN
      DO 10, GOOD = LSTCNT + 1, PNTP
         IF (PNTSTK (GOOD) .GT. CNT) THEN
            GOOD = GOOD - 1
            GOTO 20
         ENDIF
10    CONTINUE
      GOODP = PNTSTK (PNTP)
      LSTCNT = PNTP
      GOTO 30
20    IF (GOOD .EQ. LSTCNT) THEN
         IF (CNT + INDENT .LT. PNTSTK (GOOD + 1)) THEN
            GOODP = CNT + INDENT
            INDENT = 0
            NOINDENT = .TRUE.
            RETURN
         ELSE
            INDENT = INDENT - (PNTSTK (GOOD + 1) - CNT)
            GOODP = PNTSTK (GOOD + 1)
            LSTCNT = GOOD + 1
            GOTO 30
         ENDIF
      ENDIF
      GOODP = PNTSTK (GOOD)
      LSTCNT = GOOD
*
*  Skip any points in PNTSTK that are the same
*
30    IF (LSTCNT .LT. PNTP) THEN
         IF (PNTSTK (LSTCNT+1) .EQ. PNTSTK (LSTCNT)) THEN
            LSTCNT = LSTCNT + 1
            GOTO 30
         ENDIF
      ENDIF
      IF (NOINDENT) THEN
         INDENT = 0
         NOINDENT = .FALSE.
      ENDIF
      END
      SUBROUTINE SMTLST
**********
*        *
* SMTLST *
*        *
**********
*  Scans a list of labels (for example in a computed GOTO).
*  It returns when it reaches the end of BUFF or finds a right
*  bracket.
      INTEGER FIN,LABL
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF2
      EXTERNAL DECNUM,SCRHTR
1000  CALL DECNUM(PBUFF,FIN,LABL,AGAIN)
      IF (LABL.EQ.0) CALL FNDNAN(FIN,FIN)
      CALL SCRHTR(LABL,FIN-1,.FALSE.)
      IF (PBUFF.GT.LEN) RETURN
      IF (BUFFCODE(PBUFF) .NE. RIGHTBRACKET) GO TO 1010
      RETURN
1010  CALL COPYONE
      PNTP=PNTP+1
      PNTSTK(PNTP)=PNBUFF
      GO TO 1000
      END
      SUBROUTINE ERRTXT
**********
*        *
* ERRTXT *
*        *
**********
*  Called when fatal error occurs.  Execution is aborted.
      CALL OUT ('An ''**ERROR**'' indicates an error on the')
      CALL OUT ('part of the user which TIDY is unable to work')
      CALL OUT ('around.  A ''**TRAP**'' is almost certainly')
      CALL OUT ('due to a bug in TIDY.')
      CALL ERRCLOSE
      END
      SUBROUTINE ENDJOB
***********
*         *
* ENDJOB  *
*         *
***********
*  Cleans up when TIDY is finished.
 
      CALL OUT('Successful Completion')
      STOP
      END
      SUBROUTINE SCNEXP(SPCHAR,SKANTO)
**********
*        *
* SCNEXP *
*        *
**********
*  Parses BUFF until an occurence of SPCHAR is found.
*  Occurences in literal or hollerith strings do not count.
*  This is a 'lookahead' parse, global pointers are not
*  updated.  The primary use of this routine is to parse DO
*  statements to make sure that they really are DO statements.
*  (FORTRAN sure is a godawful language to parse!!)  Oops forgot
*  to mention that occurences of SPCHAR inside a bracketed
*  expression don't count either.
 
      INTEGER SKANTO,CNT,CHRCOD,VALUE
      CHARACTER SPCHAR*1
      INCLUDE TIDY_CF6
      CNT=0
1000  IF (SKANTO.GT.LEN) RETURN
      IF (CNT.NE.0) GO TO 1010
      IF (BUFF(SKANTO) .EQ. SPCHAR) RETURN
1010  CHRCOD = BUFFCODE(SKANTO)
      GO TO (1100,1020,1030,1060,1070,1080,1080,1100,1100,1100,1100,
     1     1100,1100,1100,1100,1080),CHRCOD
C  LETTER FOUND
1020  CALL FNDNAN(SKANTO,SKANTO)
      GO TO 1000
C  NUMBER FOUND
1030  CALL DECNUM(SKANTO,SKANTO,VALUE,.FALSE.)
      IF (VALUE)  1000,1000,1040
1040  IF (SKANTO.GT.LEN) RETURN
      IF (BUFF(SKANTO).EQ.'H') GO TO 1050
      IF (BUFF(SKANTO).EQ.'R') GO TO 1050
      GO TO 1000
1050  SKANTO=SKANTO+VALUE+1
      GO TO 1000
C  LEFT BRACKET FOUND
1060  CNT=CNT+1
      SKANTO=SKANTO+1
      GO TO 1000
C  RIGHT BRACKET FOUND
1070  CNT=CNT-1
      SKANTO=SKANTO+1
      GO TO 1000
C  QUOTE FOUND
1080  DO 1090 SKANTO=SKANTO+1,LEN
          IF (BUFFCODE(SKANTO) .EQ. CHRCOD) GOTO 1100
1090  CONTINUE
      CALL ONLINE
      CALL OUT('**ERROR** Missing closing quote')
1100  SKANTO=SKANTO+1
      GO TO 1000
      END
      SUBROUTINE ACTSCN
**********
*        *
* ACTSCN *
*        *
**********
*  Parses BUFF until an unmatched right bracket is found or
*  until the end of BUFF is reached.
      INTEGER CNT,CHRCOD,NUM,I,VALUE,LENGTH
      INCLUDE TIDY_CF2
      INCLUDE TIDY_CF6
      CHARACTER ITEMP*1
      CNT=1
1000  IF (PBUFF.GT.LEN)  RETURN
      CHRCOD = BUFFCODE (PBUFF)
      GO TO (1190,1010,1060,1110,1120,1130,1130,1160,1190,1190,1170,
     1     1180,1190,1190,1190,1130),CHRCOD
1010  CALL SCNALP(PBUFF,NUM,LEN)
      IF (SCANTO .GT. LEN) THEN
         CALL CATEN8 (PBUFF, LEN)
         RETURN
      ENDIF
      IF (BUFFCODE(SCANTO) .NE. EQUALSIGN) GO TO 1040
      GO TO (1040,1040,1020,1040,1030),NUM
      GO TO 1040
1020  IF (ALPSTR1(1:3).EQ.'END')  GO TO 1050
      IF (ALPSTR1(1:3).EQ.'ERR')  GO TO 1050
      IF (ALPSTR1(1:3).EQ.'FMT')  GO TO 1050
      GO TO 1040
1030  IF (ALPSTR1(1:5).EQ.'ERROR')  GO TO 1050
1040  CALL FNDNAN(SCANTO,SCANTO)
      CALL CATEN8(PBUFF,SCANTO-1)
      PNTP = PNTP + 1
      PNTSTK (PNTP) = SCANTO
      GO TO 1000
1050  CALL CATEN8(PBUFF,LENGTH(SCANTO-1))
      PBUFF=SCANTO
      CALL COPYONE
      CALL DECNUM(PBUFF,I,VALUE,AGAIN)
      CALL SCRHTR(VALUE,I-1,.FALSE.)
      GO TO 1000
C  NUMBER FOUND
1060  CALL DECNUM(PBUFF,I,VALUE,.FALSE.)
      IF (VALUE) 1100,1080,1070
1070  IF (I.GT.LEN) GO TO 1080
      ITEMP=BUFF(I)
      IF (ITEMP.EQ.'H')   GO TO 1090
      IF (ITEMP.EQ.'R')   GO TO 1090
      IF (ITEMP.EQ.'S' .AND. .NOT.AGAIN) GOTO 1100
      IF (ITEMP.EQ.'#')   GO TO 1095
      IF (VALUE.LT.0) GO TO 1100
1080  CALL CATEN8(PBUFF,I-1)
      GO TO 1000
1090  CALL CATEN8(PBUFF,I+VALUE)
      GO TO 1000
 
* # was found, this must be a rescan of a statement label
 
1095  CONTINUE
      CALL DECNUM (PBUFF, I, VALUE, AGAIN)
1100  CALL SCRHTR(VALUE,I-1,.FALSE.)
      CALL COPYONE
      GO TO 1000
C  LEFT BRACKET FOUND
1110  CNT=CNT+1
      CALL COPYONE
      GO TO 1000
C  RIGHT BRACKET FOUND
1120  CNT=CNT-1
      CALL COPYONE
      PNTP=PNTP+1
      PNTSTK(PNTP)=PNBUFF
      IF (CNT.EQ.0) RETURN
      GO TO 1000
C  QUOTE STRING FOUND
1130  CALL COPYONE
      PNTP = PNTP + 1
      PNTSTK (PNTP) = PNBUFF - 1
      DO 1140 , I=PBUFF, LEN
          IF (BUFFCODE(I) .EQ. CHRCOD) GOTO 1150
1140  CONTINUE
      CALL ONLINE
      CALL OUT('**ERROR** Missing closing quote')
      GO TO 1000
1150  CALL CATEN8(PBUFF,I)
      PNTP = PNTP + 1
      PNTSTK (PNTP) = PNBUFF + 1
      GO TO 1000
C  COMMA FOUND
1160  CALL COPYONE
      PNTP=PNTP+1
      PNTSTK(PNTP)=PNBUFF
      GO TO 1000
C  STATEMENT LABEL OF '&NNNN' FORM FOUND
1170  CALL COPYONE
      CALL DECNUM (PBUFF,I,VALUE,AGAIN)
      CALL SCRHTR(VALUE,I-1,.FALSE.)
      GO TO 1000
C  SEMICOLAN FOUND
1180  CALL COPYONE
      PNTP=PNTP+1
      PNTSTK(PNTP)=PNBUFF
      RETURN
C  JUNK CHARACTER FOUND
1190  CALL COPYONE
      GO TO 1000
      END
      SUBROUTINE ADTREE(LABL,NLABEL)
**********
*        *
* ADTREE *
*        *
**********
*  Adds LABL to the hash table for labels.  NLABEL is the new
*  label that is to replace LABL.
      INTEGER POINTER,LABL,NLABEL
      INCLUDE TIDY_CF3
      IF (FREE.GT.LABMAX) THEN
         CALL ONLINE
         CALL OUT('**TRAP** Out of table space for labels')
         CALL ERRTXT
      ENDIF
      IF (LABL) 1000,1010,1020
1000  POINTER=41
      GO TO 1030
1010  CONTINUE
      CALL ONLINE
      CALL OUT('**ERROR** Zero label found.')
      RETURN
1020  POINTER=MOD(LABL,41)
1030  IF (LINK(POINTER)) 1040,1050,1060
*  end of bucket found, link on new label.
1040  CONTINUE
      IF (LABL .EQ. OLDLAB (POINTER)) THEN
         CALL ONLINE
         CALL OUT('**ERROR** Duplicate label found.')
      ENDIF
      LINK(POINTER)=FREE
      POINTER=FREE
      FREE=FREE+1
      OLDLAB(POINTER)=LABL
      NEWLAB(POINTER)=NLABEL
      LINK(POINTER)=-1
      RETURN
*  bucket is empty, drop in first entry.
1050  LINK(POINTER)=-1
      OLDLAB(POINTER)=LABL
      NEWLAB(POINTER)=NLABEL
      RETURN
*  not at end of bucket yet....
1060  CONTINUE
      IF (LABL .EQ. OLDLAB (POINTER)) THEN
         CALL ONLINE
         CALL OUT('**ERROR** Duplicate label found.')
      ENDIF
      POINTER=LINK(POINTER)
      GO TO 1030
      END
      SUBROUTINE SCRHTR(LABL,END,BLANKS)
**********
*        *
* SCRHTR *
*        *
**********
*     SCRHTR searches the hash table for a label LABL.  If
*  LABL is found than its new label is catenated onto NEWBUF.
*  If LABL is not found than BUFF up to the point END is catenated
*  onto NEWBUF and an extra character is added to indicate the label
*  has not been changed.  If BLANKS is .TRUE. than an extra blank
*  is added after a new label has been added to NEWBUF.
      INTEGER LABL,END,POINTER,SIZE,LENGTH
      LOGICAL BLANKS
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF3
      INCLUDE TIDY_CF7
 
      IF (LABL) 1000,1010,1020
1000  POINTER=41
      GO TO 1030
1010  CALL CATEN8(PBUFF,END)
      RETURN
1020  POINTER=MOD(LABL,41)
1030  IF (LINK(POINTER).EQ.0) GO TO 1060
1040  IF (LABL.EQ.OLDLAB(POINTER)) GO TO 1050
      IF (LINK(POINTER).EQ.-1) GO TO 1060
      POINTER=LINK(POINTER)
      GO TO 1040
1050  CALL ENCNUM(IABS(NEWLAB(POINTER)),NEWBUF(PNBUFF+1) ,SIZE)
      IF (JUSTIFY) THEN
         DO 1055 I = 1,4
            IF (NEWBUF(PNBUFF+1) .EQ. ' ') THEN
               DO 1053 J = 1,5-I
               NEWBUF(PNBUFF+J) = NEWBUF(PNBUFF+J+1)
 1053          CONTINUE
            ELSE
               GOTO 1057
            ENDIF
 1055    CONTINUE
      ENDIF
 1057 CONTINUE
      PNBUFF=PNBUFF+SIZE
      IF (LABL.LT.0) CALL ADDONE ('$')
      IF (BLANKS) CALL ADDONE (' ')
      PBUFF=END+1
      RETURN
1060  DONE=.FALSE.
      IF (AGAIN) THEN
         CALL ONLINE
         WRITE (UNIT=899, FMT=9000) LABL
9000  FORMAT (' **ERROR** Label ',I,' is undefined.')
      ENDIF
      IF (LABL.LT.0) GO TO 1070
      CALL CATEN8(PBUFF,END)
      IF (.NOT.AGAIN) CALL ADDONE ('#')
      RETURN
1070  CALL CATEN8(PBUFF,LENGTH(END)-1)
      PBUFF=PBUFF+1
      CALL ADDONE ('&')
      END
      SUBROUTINE KEYWORD
***********
*         *
* KEYWORD *
*         *
***********
*  Called when we find a 'pseudokeyword'.
      INCLUDE TIDY_CF6
      CALL CATEN8(PBUFF,LENGTH(SCANTO-1))
      CALL ADDONE (' ')
      PBUFF=SCANTO
      END
      SUBROUTINE INITIALIZE
**************
*            *
* INITIALIZE *
*            *
**************
*  Performs initialization.
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF3
      INCLUDE TIDY_CF1
      INCLUDE TIDY_CF4
      INCLUDE TIDY_CF7
      INCLUDE TIDY_CF9
      INCLUDE TIDY_CF8
      INCLUDE TIDY_CF2
      DATA ICHARS/' ','1','2','3','4','5','6','7','8','9','A','B',
     1'C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q',
     2'R','S','T','U','V','W','X','Y','Z',24*'*'/
C
C        1         BLANK
C        2         ALPHABETIC CHARACTER (INCLUDING '$' AND '_')
C        3         NUMERIC CHARACTER
C        4         (
C        5         )
C        6         '
C        7         "
C        8         ,
C        9         /
C       10         #
C       11         &
C       12         ;
C       13         *
C       14         =
C       15         ANY OTHER CHARACTER
C
*  Character codes (for ASCII)
      DATA
     1         CHRSET /32*15,1,15,7,10,2,15,11,6,4,5,13,15,8,
     2         2*15,9,10*3,15,12,15,14,3*15,26*2,4*15,2,32*15/
      EOF=.FALSE.
      NOINDENT = .FALSE.
      HOLDFORMATS = .FALSE.
      DECSCN = .FALSE.
      DEFAULT = .FALSE.
      DEBUG = .FALSE.
      JUSTIFY = .FALSE.
      IGNOREX = .FALSE.
      COMONLY = .FALSE.
      PROMPT  = .FALSE.
      CYR = .FALSE.
      PSTK=0
      TABNXT = 0
      ENDDO = 0
      PIND = 0
      INDENT = 0
      LBLSRT=1000
      LBLINC=10
      FMTSRT=9000
      FMTINC=10
      TABSIZ = 3
      YEAR(1:4) = 4H0000
      END
**************
*            *
*   RESCAN   *
*            *
**************
      SUBROUTINE RESCAN
*  Rescans those lines that referenced undefined labels.  At
*  this point all labels should be defined.
 
*  Note:
*     The following three bits of information are taken from the
*     stacks.
 
* KEYS    the starting key of the line in the output file.
* INDNT1  The number of spaces the line is indented
      INTEGER CNT,KEYS,INDNT1,I,STATUS
      INCLUDE TIDY_CF9
      INCLUDE TIDY_CF6
      AGAIN=.TRUE.
      CNT=0
      DO 1010 I=1,PSTK
          CURRENTLINE = UNLINE (I)
          KEYS=UNKEYS(I)
          INDNT1=UNDENT(I)
          CALL LETCHAR(BUFF, UNSPACE(UNSTART(I)), UNLENGTH(I))
          LEN = UNLENGTH(I)
          $COMMENT = COLENGTH (I)
          IF ($COMMENT .GT. 0) CALL LETCHAR (COMMENT,
     1         UNSPACE (COSTART(I)), $COMMENT)
          CALL TRANSBUF
          CALL LYNSCN (STATUS)
          IF (DONE) GO TO 1000
          CNT = CNT + 1
          UNLINE (CNT) = CURRENTLINE
          UNKEYS (CNT) = KEYS
          UNDENT (CNT) = INDNT1
          UNLENGTH(CNT) = UNLENGTH(I)
          UNSTART(CNT) = UNSTART(I)
          GO TO 1010
1000      CALL LYNOUT(INDNT1,KEYS,NEWBUF,PNBUFF,INDNT1)
1010  CONTINUE
      PSTK=CNT
      END
************************************************************************
      SUBROUTINE STKLYN
*  Saves NEWBUF for rescanning later on.  Presumably this
*  source line had a forward reference in it.
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF9
      CALL LETCHAR(UNSPACE(FREESPACE), NEWBUF, PNBUFF)
      KEY=OLDKEY+(PNBUFF/20)+2
      PSTK=PSTK+1
      IF (PSTK.GT.PSTKMAX) THEN
         CALL ONLINE
         CALL OUT('**TRAP** Out of stack space')
         CALL ERRTXT
      ENDIF
      UNLINE(PSTK) = CURRENTLINE
      UNKEYS(PSTK)=OLDKEY
      UNDENT(PSTK)=CURIND
      UNLENGTH(PSTK) = PNBUFF
      UNSTART(PSTK) = FREESPACE
      FREESPACE = FREESPACE + PNBUFF
      IF ($COMMENT .GT. 0) THEN
          CALL LETCHAR(UNSPACE(FREESPACE), COMMENT, $COMMENT)
          COLENGTH (PSTK) = $COMMENT
          COSTART (PSTK) = FREESPACE
          FREESPACE = FREESPACE + $COMMENT
        ELSE
          COLENGTH (PSTK) = 0
      ENDIF
      END
      SUBROUTINE OLDOUT(KEY2,DCB)
*************
*           *
*  OLDOUT   *
*           *
*************
*  writes out old source line exactly as it was read in.  This
*  is useful for statements that we do not format; FORMAT
*  statements for example.
      INTEGER KEY2,J,I,K
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF1
      INCLUDE TIDY_CF7
*
      IF (NOINDENT) THEN
         DO 10, I = 1, RECPTR
            RECIND (I) = 0
10       CONTINUE
      ENDIF
      CALL WRITEFOR(BUFF,RECIND(1),BUFF(7),RECLEN(1)-6,KEY2)
      KEY2=KEY2+1
      DO 1000 J=2,RECPTR
          K=RECLEN(J-1)+1
          CALL WRITEFOR(CONTINUE6(J-1),RECIND(J),BUFF(K),RECLEN(J)
     1         -K+1, KEY2)
      KEY2=KEY2+1
1000  CONTINUE
      END
      SUBROUTINE WRITEFOR(FIRST6,INDENT,BUFFER,BUFLEN,KEY)
**************
*            *
*  WRITEFOR  *
*            *
**************
*  Called by LYNOUT.  Prepares character string for output line
*  and passes it on to yet another low level I/O routine.
      INCLUDE TIDY_CF6
      CHARACTER OUTBUF*120,FIRST6*6,BUFFER*66
      INTEGER INDENT,BUFLEN,KEY,SIZE
      OUTBUF = ' '
      OUTBUF(1:6)=FIRST6
      IF (INDENT .LT. 0) THEN
          CALL ONLINE
          CALL OUT('**TRAP** negative indent specified in WRITEFOR')
          CALL ERRTXT
          INDENT = 0
      ENDIF
      CALL LETCHAR (OUTBUF(7 + INDENT:7 + INDENT), BUFFER, BUFLEN)
      IF ($COMMENT .GT. 0) THEN
          OUTBUF (73:73+$COMMENT) = COMMENT (1:$COMMENT)
          SIZE = 72 + $COMMENT
          $COMMENT = 0
        ELSE
          SIZE = 6 + INDENT + BUFLEN
      ENDIF
      CALL WRITEBUF(OUTBUF,SIZE,KEY)
      END
      SUBROUTINE COPYONE
**************
*            *
*  COPYONE   *
*            *
**************
*  copies one character from BUFF to NEWBUF.
      INCLUDE TIDY_CF6
*
      PNBUFF = PNBUFF + 1
      NEWBUF (PNBUFF) = BUFF (PBUFF)
      PBUFF = PBUFF + 1
      END
      SUBROUTINE ADDONE (CHAR1)
***************
*             *
*  ADDONE     *
*             *
***************
*  Adds CHAR1 to NEWBUF.
      CHARACTER CHAR1*1
      INCLUDE TIDY_CF6
*
      PNBUFF = PNBUFF + 1
      NEWBUF (PNBUFF) = CHAR1
      END
      SUBROUTINE ONLINE
***************
*             *
*  ONLINE     *
*             *
***************
*  Called when an error is detected.  tells user what line
*  in his source file the error was detected on.  If the
*  source line was represented by several lines in the source
*  file the line number corresponds to the first line of the
*  source statement.
      INTEGER LAST LINE
      SAVE LAST LINE
      DATA LAST LINE /-1/
      INCLUDE TIDY_CF6
*
      IF (CURRENT LINE .NE. LAST LINE) THEN
         WRITE (UNIT=899,FMT=1) FLOAT (CURRENTLINE) / 1000
         LAST LINE = CURRENT LINE
      ENDIF
1     FORMAT (' On line',F9.3,'.')
      END
****************
*  SCNDEC      *
****************
      SUBROUTINE SCNDEC (FSTART)
      IMPLICIT LOGICAL (A-Z)
      INTEGER FSTART, START, TAGNUM (200), TAGSTART (1000), I
      INTEGER TAGEND (1000), TAGBEGIN (200), SYMSIZE (200), SMALL
      INTEGER TAGPTR, SYMPTR, CNT, J, K, POINTER, SPACE
      CHARACTER SYMTAB (200)*31, SMALLNAM*31
      INCLUDE TIDY_CF6
      INCLUDE TIDY_CF7
*
      TAGPTR = 0
      SYMPTR = 0
* Find where the variable names start
      I = 0
      DO 10, SCANTO = 7, LEN
         IF (BUFFCODE (SCANTO) .NE. BLANK) THEN
            I = I + 1
            IF (I .EQ. FSTART) GO TO 20
         ENDIF
10    CONTINUE
      SCANTO = LEN + 1
20    CONTINUE
      CALL START$STATEMENT
      CALL WRITE (ALPSTR1 (1:FSTART-1))
* Could be a *n or *(?) here
      IF (BUFFCODE (SCANTO) .EQ. ASTERIX) THEN
         CALL WRITE (' * ')
         SCANTO = SCANTO + 1
         CALL SKIPBLANKS
         START = SCANTO
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            SCANTO = SCANTO + 1
            CALL INTCEXP
            SCANTO = SCANTO + 1
         ELSE
            CALL USINTC
         ENDIF
         CALL WRITE (IOBUFFER (START: SCANTO - 1))
      ENDIF
      IF (.NOT. NOINDENT) CALL ADDTOINDENT (3)
      CALL DUMPLINE
* ready to start picking out variable names
100   CONTINUE
      IF (SCANTO .LE. LEN) THEN
         CALL SCNALPHA (SCANTO, CNT, LEN)
         SYMPTR = SYMPTR + 1
         SYMTAB (SYMPTR) = ALPSTR1 (1:CNT)
         SYMSIZE (SYMPTR) = CNT
         TAGNUM (SYMPTR) = 0
         TAGBEGIN (SYMPTR) = TAGPTR + 1
* Could be a *n or *(?) tag field here
88    CONTINUE
      IF (BUFFCODE (SCANTO) .EQ. ASTERIX) THEN
         START = SCANTO
         SCANTO = SCANTO + 1
         CALL SKIPBLANKS
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            SCANTO = SCANTO + 1
            CALL INTCEXP
            SCANTO = SCANTO + 1
            CALL SKIPBLANKS
            TAGPTR = TAGPTR + 1
            TAGSTART (TAGPTR) = START
            TAGEND (TAGPTR) = SCANTO - 1
            TAGNUM (SYMPTR) = TAGNUM (SYMPTR) + 1
         ELSE
            CALL USINTC
            TAGPTR = TAGPTR + 1
            TAGSTART (TAGPTR) = START
            TAGEND (TAGPTR) = SCANTO - 1
            TAGNUM (SYMPTR) = TAGNUM (SYMPTR) + 1
         ENDIF
      ENDIF
* Check for array declaration tag field
         IF (BUFFCODE (SCANTO) .EQ. LEFTBRACKET) THEN
            START = SCANTO
110         CONTINUE
            IF (SCANTO.LE.LEN .AND. BUFFCODE(SCANTO).NE. RIGHTBRACKET)
     *         THEN
               SCANTO = SCANTO + 1
               CALL DIMBEXP
               GO TO 110
            ENDIF
            TAGPTR = TAGPTR + 1
            TAGSTART (TAGPTR) = START
            TAGEND (TAGPTR) = SCANTO
            TAGNUM (SYMPTR) = TAGNUM (SYMPTR) + 1
            SCANTO = SCANTO + 1
            CALL SKIPBLANKS
*        Could be a *n or *(?) tag field here
            GOTO 88
         ENDIF
* Check for data list
         IF (BUFFCODE (SCANTO) .EQ. SLASH) THEN
            START = SCANTO
            SCANTO = SCANTO + 1
120         CONTINUE
            IF (SCANTO .LE. LEN) THEN
               CALL DATAITEM
               TAGPTR = TAGPTR + 1
               TAGSTART (TAGPTR) = START
               TAGEND (TAGPTR) = SCANTO
               TAGNUM (SYMPTR) = TAGNUM (SYMPTR) + 1
               IF (BUFFCODE (SCANTO) .EQ. SLASH) GO TO 121
               SCANTO = SCANTO + 1
               START = SCANTO
               GO TO 120
            ENDIF
121         CONTINUE
            SCANTO = SCANTO + 1
            CALL SKIPBLANKS
         ENDIF
         SCANTO = SCANTO + 1
         GO TO 100
      ENDIF
* The whole thing should be parsed now
140   CONTINUE
      IF (SYMPTR .GT. 0) THEN
         SMALL = 0
         SMALLNAM = 'ZZZZZZZZ'
         DO 150, I = 1, SYMPTR
            IF (SYMTAB (I)(1:8) .LE. SMALLNAM) THEN
               SMALLNAM = SYMTAB (I)(1:8)
               SMALL = I
            ENDIF
150      CONTINUE
         POINTER = TAGBEGIN (SMALL)
* Make sure name and first tag field are on the same line
         SPACE = SYMSIZE (SMALL)
         IF (TAGNUM (SMALL) .LE. 1) SPACE = SPACE + 2
         IF (TAGNUM (SMALL) .GT. 0) THEN
            SPACE = SPACE + TAGEND (POINTER) - TAGSTART (POINTER) + 1
         ENDIF
         CALL RESERVE (SPACE)
         CALL WRITE (SYMTAB (SMALL)(1:SYMSIZE(SMALL)))
* Print the tag fields if any
         IF (TAGNUM (SMALL) .GT. 0) THEN
            DO 160, I = POINTER, POINTER + TAGNUM (SMALL) - 1
               J = TAGSTART (I)
               K = TAGEND (I)
               CALL WRITE (IOBUFFER (J:K))
160         CONTINUE
         ENDIF
         IF (SYMPTR.GT.1) CALL WRITE (', ')
         IF (DECPASCAL) CALL DUMPLINE
         IF (SMALL .NE. SYMPTR) THEN
            SYMTAB (SMALL) = SYMTAB (SYMPTR)
            SYMSIZE (SMALL) = SYMSIZE (SYMPTR)
            TAGBEGIN (SMALL) = TAGBEGIN (SYMPTR)
            TAGNUM (SMALL) = TAGNUM (SYMPTR)
         ENDIF
         SYMPTR = SYMPTR - 1
         GO TO 140
      ENDIF
      CALL DUMPLINE
      END
********************
*  START$STATEMENT *
********************
      SUBROUTINE START$STATEMENT
      IMPLICIT LOGICAL (A-Z)
      INCLUDE TIDY_CF10
*
      WINDENT = 0
      BUFLEN = 6
      BUFFER = ' '
      LINE = 1
      END
********************
*  DUMPLINE        *
********************
      SUBROUTINE DUMPLINE
      IMPLICIT LOGICAL (A-Z)
      INCLUDE TIDY_CF10
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF1
*
      IF (BUFFER (7:72) .EQ. ' ') RETURN
      CALL WRITEBUF (BUFFER, BUFLEN, KEY)
      KEY = KEY + 1
      LINE = LINE + 1
      BUFLEN = 6 + WINDENT
      BUFFER = ' '
      BUFFER (6:6) = ICHARS (LINE)
      END
********************
*  ADDTOINDENT     *
********************
      SUBROUTINE ADDTOINDENT (VALUE)
      IMPLICIT LOGICAL (A-Z)
      INTEGER VALUE
      INCLUDE TIDY_CF10
*
      WINDENT = WINDENT + VALUE
      END
*****************
*  WRITE        *
*****************
      SUBROUTINE WRITE (STRING)
      IMPLICIT LOGICAL (A-Z)
      CHARACTER STRING *(*)
      INCLUDE TIDY_CF10
      INCLUDE TIDY_CF5
      INCLUDE TIDY_CF1
      INCLUDE TIDY_CF7
*
* We may have to dump the line
      IF (LEN (STRING) + BUFLEN .GT. 72) THEN
         CALL DUMPLINE
         IF (DECPASCAL) BUFLEN = BUFLEN + 3
      ENDIF
      IF (LEN (STRING) + BUFLEN .GT. 72) THEN
         CALL ONLINE
         CALL OUT('**TRAP** STRING too long in WRITE')
         CALL ERRTXT
      ENDIF
      BUFFER (BUFLEN+1:BUFLEN + LEN (STRING)) = STRING
      BUFLEN = BUFLEN + LEN (STRING)
      END
*******************
*  RESERVE        *
*******************
      SUBROUTINE RESERVE (SPACE)
      INTEGER SPACE
      INCLUDE TIDY_CF10
*
      IF (SPACE .GT. 72 - BUFLEN) CALL DUMPLINE
      END
********************
*  SKIPBLANKS      *
********************
      SUBROUTINE SKIPBLANKS
      IMPLICIT LOGICAL (A-Z)
      INCLUDE TIDY_CF6
*
      DO 10, SCANTO = SCANTO, LEN
         IF (BUFFCODE (SCANTO) .NE. BLANK) RETURN
10    CONTINUE
      SCANTO = LEN + 1
      END
*********************
*  INTCEXP          *
*********************
      SUBROUTINE INTCEXP
* Skips to first character after an integer_constant_expression
      INTEGER BRACKETS
      INCLUDE TIDY_CF6
*
      BRACKETS = 0
      DO 10, SCANTO = SCANTO, LEN
         GOTO (10,10,10,20,30,100,100,50,100,100,100,40,10,
     *      100,100), BUFFCODE (SCANTO)
         CALL ONLINE
         CALL OUT('**TRAP** in INTCEXP')
         CALL ERRTXT
* Left bracket found
20       CONTINUE
         BRACKETS = BRACKETS + 1
         GO TO 10
* Right Bracket found
30       CONTINUE
         BRACKETS = BRACKETS - 1
         IF (BRACKETS .LT. 0) RETURN
         GO TO 10
* Comma found
50       CONTINUE
         RETURN
* Semicolan found
40       CONTINUE
         RETURN
* illegal character found
100      CONTINUE
         CALL ONLINE
         CALL ONLINE
         CALL OUT('**ERROR** This is not FORTRAN!')
         CALL ERRTXT
         CALL ERRTXT
10    CONTINUE
      SCANTO = LEN + 1
      END
*****************
*  USINTC       *
*****************
      SUBROUTINE USINTC
* skip an unsigned integer constant
      IMPLICIT LOGICAL (A-Z)
      INCLUDE TIDY_CF6
*
      DO 10, SCANTO = SCANTO, LEN
         GOTO (10, 20, 10), BUFFCODE (SCANTO)
20       RETURN
10    CONTINUE
      END
****************
*  DIMBEXP     *
****************
      SUBROUTINE DIMBEXP
* Parse a dimension expression
      INTEGER BRACKETS
      INCLUDE TIDY_CF6
*
      BRACKETS = 0
      DO 10, SCANTO = SCANTO, LEN
         GOTO (10,10,10,20,30,100,100,50,10,100,100,40,10,
     *      100,100), BUFFCODE (SCANTO)
         CALL ONLINE
         CALL OUT('**TRAP** in INTCEXP')
         CALL ERRTXT
* Left bracket found
20       CONTINUE
         BRACKETS = BRACKETS + 1
         GO TO 10
* Right Bracket found
30       CONTINUE
         BRACKETS = BRACKETS - 1
         IF (BRACKETS .LT. 0) RETURN
         GO TO 10
* Comma found
50       CONTINUE
         RETURN
* Semicolan found
40       CONTINUE
         RETURN
* illegal character found
100      CONTINUE
         IF (BUFF(SCANTO).NE.':' .AND. BUFF(SCANTO).NE.'-'
     *         .AND. BUFF(SCANTO).NE.'+') THEN
            CALL ONLINE
            CALL OUT('**ERROR** This is not FORTRAN!')
            CALL ERRTXT
            CALL ERRTXT
         ENDIF
10    CONTINUE
      SCANTO = LEN + 1
      END
*****************
*  DATAITEM     *
*****************
      SUBROUTINE DATAITEM
      IMPLICIT LOGICAL (A-Z)
      INCLUDE TIDY_CF6
*
      CALL SKIPBLANKS
      IF (BUFFCODE(SCANTO).EQ.SINGLEQUOTE .OR. BUFFCODE(SCANTO).EQ.
     *   DOUBLEQUOTE) THEN
         CALL SKIPLITERAL
         SCANTO = SCANTO + 1
         CALL SKIPBLANKS
         RETURN
      ELSE
         DO 10, SCANTO = SCANTO, LEN
            GOTO (10,10,10,10,10,10,10,20,30,10,10,10,40,10,10),
     *         BUFFCODE (SCANTO)
            CALL ONLINE
            CALL OUT('**TRAP** in DATAITEM')
            CALL ERRTXT
* Comma found
20       CONTINUE
         RETURN
* slash found
30       CONTINUE
         RETURN
10       CONTINUE
         SCANTO = LEN + 1
         RETURN
      ENDIF
* asterix found
40    CONTINUE
      SCANTO = SCANTO + 1
      IF (BUFFCODE (SCANTO).EQ.SINGLEQUOTE .OR. BUFFCODE (SCANTO).EQ.
     *   DOUBLEQUOTE) THEN
         CALL SKIPLITERAL
         CALL SKIPBLANKS
         RETURN
      ELSE
         DO 100, SCANTO = SCANTO, LEN
            GOTO (100,100,100,100,100,100,100,120,130,100,100,100,
     *         100,100,100), BUFFCODE (SCANTO)
            CALL ONLINE
            CALL OUT('**TRAP** #2 in DATAITEM')
            CALL ERRTXT
* comma found
120         CONTINUE
            RETURN
* slash found
130         CONTINUE
            RETURN
100      CONTINUE
         SCANTO = LEN + 1
      ENDIF
      END
*****************
*  SKIPLITERAL  *
*****************
      SUBROUTINE SKIPLITERAL
      IMPLICIT LOGICAL (A-Z)
      INTEGER CHAR
      INCLUDE TIDY_CF6
*
      CHAR = BUFFCODE (SCANTO)
      SCANTO = SCANTO + 1
10    CONTINUE
      IF (SCANTO .LE. LEN) THEN
         IF (BUFFCODE (SCANTO) .EQ. CHAR) THEN
            IF (BUFFCODE (SCANTO+1) .NE. CHAR) THEN
               RETURN
            ELSE
               SCANTO = SCANTO + 2
            ENDIF
         ELSE
            SCANTO = SCANTO + 1
         ENDIF
         GO TO 10
      ENDIF
      CALL ONLINE
      CALL OUT('**ERROR** open quote found')
      SCANTO = LEN + 1
      END
      SUBROUTINE OPENALL
**************
*            *
*  OPENALL   *
*            *
**************
*     Open the input file, output file and scratch files.
 
      INTEGER BUF7(1024), BUF8(1024), BUF9(1024)
      SAVE BUF7, BUF8, BUF9
      DOUBLE PRECISION FPT7(10),FPT8(10),FPT9(10)
      COMMON /FPT/ FPT7, FPT8, FPT9
 
      OPEN(UNIT=2, ACCESS='KEYED', USAGE='CREATE', STATUS='NEW', ERR=10)
      GOTO 20
10    OPEN (UNIT=2, ACCESS='KEYED', USAGE='CREATE', STATUS='OLD')
20    CONTINUE
      OPEN (UNIT=899, FILE='(ME)', USAGE='OUTPUT')
      OPEN (UNIT=999, FILE='(ME)', USAGE='INPUT')
      CALL OPENFSFA (7, FPT7, BUF7, 1024)
      CALL OPENFSFA (8, FPT8, BUF8, 1024)
      CALL OPENFSFA (9, FPT9, BUF9, 1024)
      END
      SUBROUTINE WROUT (BUFFER, BUFLEN, KEY)
*************
*           *
*  WROUT    *
*           *
*************
*     Write record to keyed output file
 
      INTEGER BUFLEN, KEY
      CHARACTER BUFFER*140
 
      CALL WRITEDIT (2, BUFFER, BUFLEN, KEY)
      END
***************
*             *
*  OPENBASE   *
*             *
***************
*  Open the source file.  Fast sequential file access is used.
 
      SUBROUTINE OPENBASE
      INTEGER BUF(1024)
      DOUBLE PRECISION FPT(10)
      SAVE BUF, FPT
 
      CALL OP2FSFA (FPT, BUF, 1024)
      RETURN
 
***************
*             *
*  READSOUR   *
*             *
***************
*  Read a record from the source file
 
      ENTRY READSOUR (BUFFER, LEN, BUFSIZ, EOF, LINE)
      CHARACTER BUFFER*140
      INTEGER LEN, BUFSIZ, LINE, IOERROR, EDITKEY
      LOGICAL EOF
      INTEGER RECORD/0/
      SAVE RECORD
 
      CALL EDITFSFA (FPT, BUFFER, LEN, BUFSIZ, EDITKEY, IOERROR)
      IF (IOERROR .EQ. 0) THEN
         RECORD = RECORD + 1
         EOF = .FALSE.
      ELSE
         EOF = .TRUE.
      ENDIF
      IF (EDITKEY .EQ. 0) THEN
         LINE = RECORD
      ELSE
         LINE = EDITKEY
      ENDIF
      END
      SUBROUTINE WRITEBUF (BUFFER, LEN, KEY)
************
*          *
* WRITEBUF *
*          *
************
*  WRITEBUF writes records out to three scratch files that will
*  later be merged together by FLUSH to form the output file.
*  Most records will go into the master scratch file.  Lines
*  containing forward references will invariably be written to
*  the update scratch file as they will not be written until
*  they are rescanned after an END statement is found.  FORMAT
*  statements that are being moved to the end of a routine are
*  written out to the format scratch file.
*     Between routines that are being processed, it is neccessary
*  to call WRITEBUF with a zero key value to reinitialize it.
 
      INTEGER LEN, KEY, MASKEY, UPKEY, FMTKEY, DISP
      SAVE MASKEY, UPKEY, FMTKEY, DISP
      DATA MASKEY /0/, UPKEY /0/, FMTKEY /0/, DISP /0/
      CHARACTER BUFFER*80
      DOUBLE PRECISION FPT7(10), FPT8(10), FPT9(10)
      COMMON /FPT/ FPT7, FPT8, FPT9
 
      IF (KEY .EQ. 0) THEN
         DISP = DISP + MAX0 (MASKEY, UPKEY, FMTKEY)
         MASKEY = 0
         UPKEY = 0
         FMTKEY = 0
         RETURN
      ENDIF
      IF (KEY .GE. 10000) THEN
         CALL WRIT (FPT9, KEY+DISP, BUFFER, LEN)
         FMTKEY = KEY
      ELSE IF (KEY .GT. MASKEY) THEN
         CALL WRIT (FPT7, KEY+DISP, BUFFER, LEN)
         MASKEY = KEY
      ELSE IF (KEY .LT. MASKEY) THEN
         IF (KEY .GT. UPKEY) THEN
            CALL WRIT (FPT8, KEY+DISP, BUFFER, LEN)
            UPKEY = KEY
         ELSE
            CALL OUT (
     *  '**TRAP** Update record is out of sync.')
            CALL ERRTXT
         ENDIF
      ELSE
         CALL OUT ('**TRAP** Duplicate record in WRITEBUF.')
         CALL ERRTXT
      ENDIF
      END
      SUBROUTINE FLUSH
************
*          *
*  FLUSH   *
*          *
************
*     FLUSH is used to flush the contents of the three scratch files
*  out to the keyed output file.  FLUSH may be called after each
*  routine is processed, or just once after all routines have
*  been processed.  Currently FLUSH is only called once to reduce
*  the overhead of opening and closing scratch files.
      INTEGER MASKEY, UPKEY, I, ERROR, MASLEN, UPLEN, FMTKEY, FMTLEN
      PARAMETER (MAXKEY = 9999999)
      CHARACTER MASBUF*140, UPBUF*140, FMTBUF*140
      DATA I/0/
      DOUBLE PRECISION FPT7(10), FPT8(10), FPT9(10)
      COMMON /FPT/ FPT7, FPT8, FPT9
 
      CALL OUT ('Starting Second Pass')
      CALL REWFSFA (FPT7)
      CALL REWFSFA (FPT8)
      CALL REWFSFA (FPT9)
      CALL READ (FPT7, MASKEY, MASBUF, MASLEN, ERROR)
      IF (ERROR .NE. 0) MASKEY = MAXKEY
      CALL READ (FPT8, UPKEY, UPBUF, UPLEN, ERROR)
      IF (ERROR .NE. 0) UPKEY = MAXKEY
      CALL READ (FPT9, FMTKEY, FMTBUF, FMTLEN, ERROR)
      IF (ERROR .NE. 0) FMTKEY = MAXKEY
2     IF (MASKEY .EQ. MAXKEY .AND. UPKEY .EQ. MAXKEY
     *   .AND. FMTKEY .EQ. MAXKEY) THEN
            RETURN
         ENDIF
      IF (MASKEY .LT. UPKEY .AND. MASKEY .LT. FMTKEY) THEN
         I = I + 1
         CALL WROUT (MASBUF, MASLEN, I * 1000)
         CALL READ (FPT7, MASKEY, MASBUF, MASLEN, ERROR)
         IF (ERROR .NE. 0) MASKEY = MAXKEY
      ELSE IF (UPKEY .LT. MASKEY .AND. UPKEY .LT. FMTKEY) THEN
         I = I + 1
         CALL WROUT (UPBUF, UPLEN, I * 1000)
         CALL READ (FPT8, UPKEY, UPBUF, UPLEN, ERROR)
         IF (ERROR .NE. 0) UPKEY = MAXKEY
      ELSE IF (FMTKEY .LT. MASKEY .AND. FMTKEY .LT. UPKEY) THEN
         I = I + 1
         CALL WROUT (FMTBUF, FMTLEN, I * 1000)
         CALL READ (FPT9, FMTKEY, FMTBUF, FMTLEN, ERROR)
         IF (ERROR .NE. 0) FMTKEY = MAXKEY
      ELSE
         CALL OUT ('**TRAP** Matching keys in FLUSH.')
         CALL ERRTXT
      ENDIF
      GOTO 2
      END
