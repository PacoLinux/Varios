

14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          1    
    1      /*M*   GJ_LCP6_M Macros for Job Step Control Services  */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100,XBO=YES,FRA=YES                */
    9
   10                          /*P*   NAME:   GJ_LCP6_M.
   11
   12                          The file GJ_LCP6_M contains the macros that
   13                          relate to program management services.  This
   14                          includes:
   15                          }
   16                          }   FPT_EXIT
   17                          }   FPT_ERR
   18                          }   FPT_XXX
   19                          }   FPT_LDTRC
   20                          }   FPT_XBREAK
   21                          }   FPT_CPEXIT
   22                          }
   23                          Only monitor services that are to cause control to
   24                          be given to the associated debugger (if any) prior
   25                          to performing that service are to be added to the
   26                          GJ Functional Code Group.
   27
   28                          */
   29
   30
   31
   32                          /*F*  NAME:  Program Management Services
   33                          ..::L1 "Introduction\\X"
   34                          The frequently used program management services are
   35                          explained in this section.  Additional services that
   36                          perform privileged or restricted program management
   37                          functions are described in this manual in the Section
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          2    
   38                          entitled "Special Services".
   39
   40                          */
   41
   42                          /*F*  NAME: M$EXIT - Exit Program
   43
   44                          The M$EXIT service provides for normal
   45                          termination of the current program.
   46
   47                          No FPT is required by M$EXIT but one may be
   48                          specified to provide for an explicit setting of
   49                          the Step Condition Code or error code if desired.
   50                          If no FPT is specified, the Step Condition Code
   51                          and the error code are both set to zero.
   52
   53                          The form of the call for this service is:
   54
   55                          CALL M$EXIT;
   56
   57                          or
   58
   59                          CALL M$EXIT (FPT_EXIT) [ALTRET (label)];
   60
   61                          When the FPT is specified, the parameters are as
   62                          follows:
   63                          */
   64
   65
   66      %MACRO FPT_EXIT (FPTN=FPT_EXIT,
   67         STCLASS=STATIC,
   68         ALGN=WALIGNED,
   69         VECTORS=YES,
   70         ERRCODE=NIL,
   71         STEPCC(G_EXIT#=0,G_CONT#=0,G_SKIP#=2,G_ERR#=4,G_ERROR#=4,
   72                G_XXX#=6,G_ABORT#=6,ANY)=0);
   73
   74      %LSET LISTDIR='0'B;
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          3    
   75      %LSET LISTEXP='1'B;
   76      %LSET LISTCOM='0'B;
   77      %LSET LISTSUB='1'B;
   78      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
   79      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
   80      %LSET INIT=CHARTEXT(' INIT');
   81      %LSET EINIT=CHARTEXT('');
   82      %ELSE;
   83      %LSET INIT=CHARTEXT('/*');
   84      %LSET EINIT=CHARTEXT('*/');
   85      %ENDIF;
   86
   87
   88      DCL 1 FPTN STCLASS ALGN,
   89      %IF TEXTCHAR(VECTORS)='YES';
   90            2 ERRCODE_ VECTOR %INIT(VECTOR(ERRCODE))%EINIT,
   91                          /*K* ERRCODE = VARIABLE specifies
   92                          the 2 word memory location
   93                          containing the error code to be returned
   94                          to the process that had initiated the program.
   95                          The VLP_ERRCODE macro should be used to
   96                          generate a structure for the error code.
   97                          The default is NIL.
   98                          */
   99            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  100            2 V,
  101      %LSET LVL=3;
  102      %ELSE;
  103      %LSET LVL=2;
  104      %ENDIF;
  105                %(LVL) %CHARTEXT('STEPCC UBIN BYTE UNAL')%INIT(STEPCC)%EINIT,
  106                          /*K*  STEPCC = {G_EXIT#|G_ERR#|G_ABORT#|VALUE-DEC(0-255)}
  107                          specifies how the Step
  108                          Condition Code is to be set:  G_EXIT#=0, G_ERR#=4, or
  109                          G_ABORT#=6.  The parameter may also be specified as
  110                          a decimal value (0-255).  The default is G_EXIT#.
  111                          */
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          4    
  112              %(LVL) * BIT(24) UNAL %INIT('0'B)%EINIT;
  113      %MEND;
  114
  115
  116
  117
  118
  119
  120                          /*F*  NAME: M$ERR_ - Error Program
  121
  122                          The M$ERR service provides for error
  123                          termination of the current program.
  124
  125                          No FPT is required by M$ERR but one may be
  126                          specified to provide for an explicit setting of
  127                          the Step Condition Code or error code if desired.
  128                          If no FPT is specified, the Step Condition Code
  129                          is set to 4 and the error code is set to %E$ERRPMME.
  130
  131                          The form of the call for this service is:
  132
  133                          CALL M$ERR;
  134
  135                          or
  136
  137                          CALL M$ERR (FPT_ERR) [ALTRET (label)];
  138
  139                          When the FPT is specified, the parameters are as
  140                          follows:
  141                          */
  142
  143
  144      %MACRO FPT_ERR (FPTN=FPT_ERR,
  145         STCLASS=STATIC,
  146         ALGN=WALIGNED,
  147         VECTORS=YES,
  148         ERRCODE=NIL,
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          5    
  149         STEPCC(G_ERR#=0,G_CONT#=0,G_SKIP#=2,G_ERR#=4,G_ERROR#=4,
  150                G_XXX#=6,G_ABORT#=6,ANY)=4);
  151
  152      %LSET LISTDIR='0'B;
  153      %LSET LISTEXP='1'B;
  154      %LSET LISTCOM='0'B;
  155      %LSET LISTSUB='1'B;
  156      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  157      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  158      %LSET INIT=CHARTEXT(' INIT');
  159      %LSET EINIT=CHARTEXT('');
  160      %ELSE;
  161      %LSET INIT=CHARTEXT('/*');
  162      %LSET EINIT=CHARTEXT('*/');
  163      %ENDIF;
  164
  165
  166      DCL 1 FPTN STCLASS ALGN,
  167      %IF TEXTCHAR(VECTORS)='YES';
  168            2 ERRCODE_ VECTOR %INIT(VECTOR(ERRCODE))%EINIT,
  169                          /*K* ERRCODE = VARIABLE specifies
  170                          the 2 word memory location
  171                          containing the error code to be returned
  172                          to the process that had initiated the program.
  173                          The VLP_ERRCODE macro should be used to
  174                          generate a structure for the error code.
  175                          The default is NIL.
  176                          */
  177            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  178            2 V,
  179      %LSET LVL=3;
  180      %ELSE;
  181      %LSET LVL=2;
  182      %ENDIF;
  183                %(LVL) %CHARTEXT('STEPCC UBIN BYTE UNAL')%INIT(STEPCC)%EINIT,
  184                     /*K*  STEPCC = {G_EXIT#|G_ERR#|G_ABORT#|VALUE-DEC(0-255)}  specifies how the Step
  185                     Condition Code is to be set:  G_EXIT#=0, G_ERR#=4, or
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          6    
  186                     G_ABORT#=6.  The parameter may also be specified as
  187                     a decimal value (0-255).  The default is G_ERR#.
  188                     */
  189              %(LVL) * BIT(24) UNAL %INIT('0'B)%EINIT;
  190      %MEND;
  191
  192
  193
  194
  195
  196
  197                          /*F* NAME: M$XXX - Abort Program
  198
  199                          The M$XXX service provides for abnormal
  200                          termination of the current program.
  201
  202                          No FPT is required by M$XXX but one may be
  203                          specified to provide for an explicit setting of
  204                          the Step Condition Code or error code if desired.
  205                          If no FPT is specified, the Step Condition Code
  206                          is set to 6 and the error code is set to %E$XXXPMME.
  207
  208                          The form of the call for this service is:
  209
  210                          CALL M$XXX;
  211
  212                          or
  213
  214                          CALL M$XXX (FPT_XXX) [ALTRET (label)];
  215
  216                          When the FPT is specified, the parameters are as
  217                          follows:
  218                          */
  219
  220
  221      %MACRO FPT_XXX (FPTN=FPT_XXX,
  222         STCLASS=STATIC,
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          7    
  223         ALGN=WALIGNED,
  224         VECTORS=YES,
  225         ERRCODE=NIL,
  226         STEPCC(G_EXIT#=0,G_CONT#=0,G_SKIP#=2,G_ERR#=4,G_ERROR#=4,
  227                G_XXX#=6,G_ABORT#=6,ANY)=6);
  228
  229      %LSET LISTDIR='0'B;
  230      %LSET LISTEXP='1'B;
  231      %LSET LISTCOM='0'B;
  232      %LSET LISTSUB='1'B;
  233         %FPT_EXIT(FPTN=FPTN,STCLASS=STCLASS,ALGN=ALGN,VECTORS=VECTORS,
  234                   ERRCODE=ERRCODE,STEPCC=STEPCC);
  235
  236                          /*K* ERRCODE = VARIABLE specifies the 2 word area in
  237                          memory containing the error code to be returned
  238                          to the process that had initiated the program.
  239                          The VLP_ERRCODE macro should be used to
  240                          generate a structure for the error code.
  241                          The default is NIL.
  242                          */
  243
  244                     /*K*  STEPCC = {G_EXIT#|G_ERR#|G_ABORT#|VALUE-DEC(0-255)}  specifies how the Step
  245                     Condition Code is to be set:  G_EXIT#=0, G_ERR#=4, or
  246                     G_ABORT#=6.  The parameter may also be specified as
  247                     a decimal value (0-255).  The default is G_ABORT#.
  248                     */
  249      %MEND;
  250
  251
  252
  253
  254
  255                          /*F* NAME: M$LDTRC - Load and Transfer to Program
  256
  257                          The monitor LDTRC routine releases the memory
  258                          used by the calling program, loads a specified run
  259                          unit and transfers control to the starting address
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          8    
  260                          of the called run unit. Any communication from
  261                          the calling program to the called program must
  262                          be accomplished through user Dynamic Data Segment 4
  263                          and/or the Control Command Buffer.
  264                          All allocated data segments
  265                          with the exception of user Dynamic Data Segment 4, are
  266                          released by an M$LDTRC operation.
  267
  268                          If Exit Control has been established in the
  269                          calling program, the issuing of an M$LDTRC
  270                          causes control to be passed to the
  271                          effective Exit Control procedure.  The M$LDTRC
  272                          occurs on exit from the Exit Control procedure,
  273                          via M$EXIT or M$TRTN.
  274
  275                          The called program
  276                          may determine that it has been entered via M$LDTRC
  277                          as the value of G$JIT.PROG_ENTRY will have been
  278                          set to %G_PE_LDTRC#.
  279
  280                          If a debugger is associated
  281                          with the user, the debugger remains associated.
  282
  283                          If the called run unit is not found or the user's
  284                          memory allocation limits would be exceeded by
  285                          loading the run-unit, the alternate return will
  286                          be taken.
  287
  288                          If an I/O error occurs when reading the run-unit, the
  289                          job is aborted.
  290
  291                          The form of the call for this service is:
  292
  293                          CALL M$LDTRC (FPT_LDTRC) [ALTRET (label)];
  294
  295                          The parameters for this service are as follows:
  296                          */
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          9    
  297
  298
  299      %MACRO FPT_LDTRC(FPTN=FPT_LDTRC,
  300                     STCLASS=STATIC,
  301                     ALGN=WALIGNED,
  302                     DISP(DESTROY=1,KEEP=2)=1,
  303                     NO_MICROFPL(YES='1'B,NO='0'B,ANY)='0'B,
  304                     VECTORS=YES,
  305                     NAME=NIL,
  306                     ACCT=NIL,
  307                     PASS=NIL,
  308                     PSN=NIL,
  309                     CMD=NIL);
  310
  311      %LSET LISTDIR='0'B;
  312      %LSET LISTEXP='1'B;
  313      %LSET LISTCOM='0'B;
  314      %LSET LISTSUB='1'B;
  315      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  316      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  317      %LSET INIT=CHARTEXT('INIT');
  318      %LSET EINIT=CHARTEXT('');
  319      %ELSE;
  320      %LSET INIT=CHARTEXT('/*');
  321      %LSET EINIT=CHARTEXT('*/');
  322      %ENDIF;
  323
  324      DCL 1 FPTN STCLASS ALGN,
  325      %IF TEXTCHAR(VECTORS)='YES';
  326            2 NAME_ VECTOR %INIT(VECTOR(NAME))%EINIT,
  327                          /*K* NAME = VARIABLE  specifies an area containing a
  328                          TEXTC string consisting of up to 31 characters, designating the
  329                          run unit to which control is to be transferred.
  330                          The area may be generated by invoking the
  331                          VLP_TEXTC macro.
  332                          The default is NIL.
  333                          */
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          10   
  334            2 ACCT_ VECTOR %INIT(VECTOR(ACCT))%EINIT,
  335                          /*K* ACCT = VARIABLE specifies an area containing a
  336                          TEXT string consisting of eight characters, designating the
  337                          account from which the run unit is to be
  338                          obtained.
  339                          The default is NIL.
  340                          */
  341            2 PASS_ VECTOR %INIT(VECTOR(PASS))%EINIT,
  342                          /*K* PASS = VARIABLE  specifies the location of a string consisting of
  343                          eight characters, designating the password
  344                          associated with the run unit.
  345                          The default is NIL.
  346                          */
  347            2 PSN_ VECTOR %INIT(VECTOR(PSN))%EINIT,
  348                          /*K* PSN = VARIABLE  specifies the location of a
  349                          6 character string designating the
  350                          identification of the pack set on which the run
  351                          unit is located.
  352                          The default is NIL.
  353                          */
  354            2 CMD_ VECTOR %INIT(VECTOR(CMD))%EINIT,
  355                          /*K* CMD = VARIABLE  locates an area containing a
  356                          TEXT string of up to 256 characters that is
  357                          passed in the Control Command Buffer
  358                          to the called program.  If CMD is not specified
  359                          the id of the calling program in put in the Control
  360                          Command Buffer in VLP_FPRG format.
  361                          The default is NIL.
  362                          */
  363            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  364            2 V,
  365      %LSET LVL=3;
  366      %ELSE;
  367      %LSET LVL=2;
  368      %ENDIF;
  369                %(LVL) %CHARTEXT('DISP UBIN BYTE UNAL')%INIT(DISP)%EINIT,
  370                          /*K*  DISP = {KEEP|DESTROY}
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          11   
  371                          allows the user to specify the action the monitor
  372                          is to take when closing any open DCBs prior to
  373                          loading the target run unit.  This option
  374                          .xeq GF_LCP6_M M$CLOSE DISP
  375
  376                          The default is DESTROY.
  377                          */
  378              %(LVL) * BIT(7) UNAL %INIT('0'B)%EINIT,
  379              %(LVL) %CHARTEXT('NO_MICROFPL BIT(1) UNAL') %INIT(NO_MICROFPL)%EINIT,
  380                          /*K*  NO_MICROFPL = {YES|NO}
  381                          allows TPFP to specify that the FPRG specified is
  382                          to be put into execution and that no attempt is to
  383                          be made to associate TPFP.:SYS for microFPL loading.
  384                          */
  385              %(LVL) * BIT(16) UNAL %INIT('0'B)%EINIT;
  386      %MEND;
  387
  388
  389
  390
  391                          /*F* NAME:  VLP_TEXTC
  392
  393                          The VLP_TEXTC macro may be used to generate
  394                          storage for any monitor service parameter
  395                          or results area that is in TEXTC format.
  396                          It generates a length byte and a character
  397                          string of fixed length.
  398
  399                          If the VLP_TEXTC macro is used to generate a
  400                          BASED structure, the length of the character
  401                          string is that of the value currently in the
  402                          length byte.
  403                          */
  404
  405       %MACRO VLP_TEXTC   (FPTN=VLP_TEXTC,
  406                         TEXT='                               ',
  407                        L=,
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          12   
  408                        LEN=,
  409                        STCLASS=STATIC);
  410
  411       %LSET LISTDIR='0'B;
  412       %LSET LISTEXP='1'B;
  413       %LSET LISTCOM='0'B;
  414       %LSET LISTSUB='1'B;
  415       %LSET LNG=CHARTEXT('');
  416       %LSET SIZ=CHARTEXT('');
  417       %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  418       %IF STR='STA' OR STR='CON' OR STR='EXT';
  419       %IF LENGTHC(TEXTCHAR(L))=0;
  420       %LSET SIZ=LENGTHC(TEXT);
  421       %ENDIF;
  422       %IF LENGTHC(TEXTCHAR(LEN))=0;
  423       %LSET LNG=0;
  424       %ENDIF;
  425       %LSET INIT=CHARTEXT('INIT');
  426      %LSET EINIT=CHARTEXT('');
  427       %ELSE;
  428       %IF LENGTHC(TEXTCHAR(LEN))=0;
  429       %LSET LNG=CHARTEXT(CONCAT(TEXTCHAR(FPTN),'.L'));
  430       %IF STR='AUT';
  431       %LSET LNG=31;
  432       %ENDIF;
  433       %ENDIF;
  434       %LSET INIT=CHARTEXT('/*');
  435      %LSET EINIT=CHARTEXT('*/');
  436       %ENDIF;
  437
  438
  439      DCL 1 FPTN STCLASS,
  440            2 %CHARTEXT('L ') UBIN(8) %INIT(L%SIZ)%EINIT UNAL,
  441                          /*K* L = VALUE-DEC(0-n)  specifies the number of significant
  442                          characters in the text string.  It defaults to the
  443                          length of TEXT, or to 31 if TEXT is not
  444                          specified.
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          13   
  445                          */
  446            2 %CHARTEXT('TEXT ') CHAR(LEN%LNG) %INIT(TEXT)%EINIT UNAL;
  447                          /*K* TEXT = VALUE-CHAR(n)  specifies a character
  448                          string.  The length of the CHAR field
  449                          generated is the length of TEXT (31 if TEXT is
  450                          not specified).  The LEN parameter can be
  451                          specified to override the length (e.g. LEN=5).
  452                          If a non-initializing STCLASS is used, the default for
  453                          LEN causes generation of a variable-length character
  454                          string whose length is in the length byte (VLP_TEXT.L).
  455
  456                          If STCLASS=AUTO is used, LEN must be specified.
  457                          */
  458
  459
  460                          /*K* LEN = VALUE-DEC(0-n)  specifies the number of
  461                          bytes to be provided for the name.
  462                          */
  463
  464       %MEND;
  465
  466
  467
  468                          /*F* NAME: M$XBREAK - Report Break in Execution
  469
  470                          The M$XBREAK monitor service is designed to allow an
  471                          interpreter to report the occurence of a break point
  472                          to an associated debugger.
  473
  474                          A debugger may set a breakpoint in FPL MOMs by placing a
  475                          BRK instruction in the MOM.  The FPL interpreter, when it
  476                          attempts to interpret a MOM whose first word is a BRK
  477                          instruction, will issue an M$XBREAK monitor service request.
  478                          The LCP-6 monitor will pass control to the associated
  479                          debugger with the M$XBREAK request environment in the top
  480                          TSA frame.
  481
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          14   
  482                          */
  483
  484      %MACRO FPT_XBREAK(FPTN=FPT_XBREAK,
  485                     ALGN=WALIGNED,
  486                     STCLASS=STATIC,
  487                     VLP_XBREAK=NIL);
  488
  489      %LSET LISTDIR='0'B;
  490      %LSET LISTEXP='1'B;
  491      %LSET LISTCOM='0'B;
  492      %LSET LISTSUB='1'B;
  493      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  494      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  495      %LSET INIT=CHARTEXT('INIT');
  496      %LSET EINIT=CHARTEXT('');
  497      %ELSE;
  498      %LSET INIT=CHARTEXT('/*');
  499      %LSET EINIT=CHARTEXT('*/');
  500      %ENDIF;
  501
  502      DCL 1 FPTN STCLASS ALGN,
  503            2 VLP_XBREAK_ VECTOR %INIT(VECTOR(VLP_XBREAK))%EINIT;
  504                          /*K* VLP_XBREAK = VARIABLE  specifies an area containing
  505                          the parameters to be passed between the interpreter
  506                          and the debugger.  The VLP_XBREAK macro should
  507                          be used to define this area.
  508                          The default is NIL.
  509                          */
  510      %MEND;
  511
  512
  513
  514
  515
  516
  517
  518                          /*F*  NAME: VLP_XBREAK - M$XBREAK Parameter
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          15   
  519
  520                          The VLP_XBREAK macro defines the area to be used
  521                          for Front-end Debugger and FPL Interpreter communication.
  522                          */
  523
  524      %MACRO VLP_XBREAK (FPTN=VLP_XBREAK,
  525          IC=0,
  526          OLDIC=0,
  527          AUTO=NIL,
  528          TRAP=0,
  529          TC(YES='1'B,NO='0'B,ANY)='0'B,
  530          TT(YES='1'B,NO='0'B,ANY)='0'B,
  531          GOIC(YES='1'B,NO='0'B,ANY)='0'B,
  532          GOBREAK(YES='1'B,NO='0'B,ANY)='0'B,
  533          ALGN=WALIGNED,
  534          STCLASS=STATIC);
  535
  536      %LSET LISTDIR='0'B;
  537      %LSET LISTEXP='1'B;
  538      %LSET LISTCOM='0'B;
  539      %LSET LISTSUB='1'B;
  540      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  541      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  542      %LSET INIT=CHARTEXT('INIT');
  543      %LSET EINIT=CHARTEXT('');
  544      %ELSE;
  545      %LSET INIT=CHARTEXT('/*');
  546      %LSET EINIT=CHARTEXT('*/');
  547      %ENDIF;
  548      DCL 1 FPTN STCLASS ALGN,
  549            2 %CHARTEXT('IC') SBIN(32) %INIT(IC)%EINIT,
  550                          /*K* IC - SBIN(32).  This field is set by the interpreter
  551                          to the current contents of the user's Program Counter
  552                          and may be modified by the Front-end Debugger. (See GOIC).
  553                          */
  554            2 IC$ REDEF %CHARTEXT('IC') PTR,
  555                          /*K* IC$ - PTR, a redef of IC.
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          16   
  556                          */
  557            2 %CHARTEXT('OLDIC') SBIN(32) %INIT(OLDIC)%EINIT,
  558                          /*K* OLDIC - SBIN(32).  This is set by the interpreter in
  559                          the case of a Trace-Transfer report, to report the
  560                          address from which the transfer was taken.  See TT.
  561                          */
  562            2 OLDIC$ REDEF %CHARTEXT('OLDIC') PTR,
  563                          /*K* OLDIC$ - PTR, a redef of OLDIC.
  564                          */
  565            2 REPLACED REDEF %CHARTEXT('OLDIC'),
  566              3 * BIT(16),3 INSTR UBIN(16),
  567                          /*K* REPLACED.INSTR - UBIN(16), a redef of OLDIC.   This
  568                          is set by the debugger along with GOBREAK to proceed
  569                          from a breakpoint.  It contains the memory word that should
  570                          be at IC, but which contains a BRK instruction instead.
  571                          See GOBREAK.
  572                          */
  573
  574            2 AUTO$ PTR %INIT(ADDR(AUTO))%EINIT,
  575                          /*K* AUTO$ - PTR.  Contains the address of the AUTO frame
  576                          corresponding to the current IC.  Set by the interpreter.
  577                          */
  578
  579            2 TRAP# UBIN(8) UNAL %INIT(TRAP)%EINIT,
  580                          /*K* TRAP# - UBIN(8).  TRAP# is set by the interpreter
  581                          to the trap number of any current trap condition.
  582                          For pre-DELTA-associated FPRGs, the interpreter's
  583                          initial call to M$DBCONTROL will RETURN, in which case
  584                          the interpreter should call M$XBREAK with TRAP# set to
  585                          zero.  For reporting breakpoints or Trace-Transfers,
  586                          the interpreter should set TRAP# to %G_TRACE# (see
  587                          G_LCP6_E).  For all other traps, the interpreter should
  588                          set TRAP# to the actual trap number.  To indicate
  589                          unexpected traps (internal errors), the interpreter
  590                          may set IC to the address of the trap within the
  591                          interpreter itself before calling M$XBREAK.
  592                          */
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          17   
  593            2 %CHARTEXT('TT') BIT(1) UNAL %INIT(TT)%EINIT,
  594                          /*K* TT - BIT(1).  The Trace Transfer bit is
  595                          set by the debugger to indicate that the interpreter
  596                          is to report an XBREAK upon each transfer.  It does so
  597                          by reporting the old and new ICs in OLDIC and IC,
  598                          respectively.
  599                          */
  600            2 %CHARTEXT('GOIC') BIT(1) UNAL %INIT(GOIC)%EINIT,
  601                          /*K* GOIC - BIT(1).  The GOIC bit is set by
  602                          the debugger to indicate that IC contains an address
  603                          at which execution is to continue.
  604                          */
  605            2 %CHARTEXT('GOBREAK') BIT(1) UNAL %INIT(GOBREAK)%EINIT,
  606                          /*K* GOBREAK - BIT(1).  The GOBREAK bit is set by the
  607                          interpreter to indicate that it is capable of executing
  608                          the replaced instruction for a break-point out-of-line.
  609                          If it is set, the debugger will resume execution from a
  610                          breakpoint by leaving it set and returning the replaced
  611                          instruction in REPLACED.INSTR, instead of replacing the
  612                          instruction in its proper memory location,  setting
  613                          a temporary breakpoint at the next instruction,  and
  614                          setting TT.
  615                          */
  616            2 %CHARTEXT('TC') BIT(1) UNAL %INIT(TC)%EINIT,
  617                          /*K* TC - BIT(1).  The Trace Call bit is
  618                          set by the debugger to indicate that the interpreter
  619                          is to report an XBREAK upon each CALL.  It does so
  620                          by reporting the old and new ICs in OLDIC and IC,
  621                          respectively.
  622                          */
  623            2 * BIT(4) UNAL %INIT('0'B)%EINIT;
  624      %MEND;
  625
  626
  627
  628
  629
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          18   
  630
  631
  632
  633                          /*F*  NAME: M$CPEXIT - Command Processor Exit
  634
  635                          The M$CPEXIT monitor service with no FPT specified
  636                          is issued by the monitor to get the first user
  637                          program put into execution.
  638
  639                          Maybe later we will have a real service.
  640                          */
  641
  642      %MACRO FPT_CPEXIT(FPTN=FPT_CPEXIT,
  643                     ALGN=WALIGNED,
  644                     STCLASS=STATIC,
  645                     NAME=NIL,
  646                     ACCT=NIL,
  647                     PASS=NIL,
  648                     PSN=NIL,
  649                     CMD=NIL);
  650
  651      %LSET LISTDIR='0'B;
  652      %LSET LISTEXP='1'B;
  653      %LSET LISTCOM='0'B;
  654      %LSET LISTSUB='1'B;
  655      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  656      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  657      %LSET INIT=CHARTEXT('INIT');
  658      %LSET EINIT=CHARTEXT('');
  659      %ELSE;
  660      %LSET INIT=CHARTEXT('/*');
  661      %LSET EINIT=CHARTEXT('*/');
  662      %ENDIF;
  663
  664      DCL 1 FPTN STCLASS ALGN,
  665            2 NAME_ VECTOR %INIT(VECTOR(NAME))%EINIT,
  666                          /*K* NAME = VARIABLE  specifies an area containing a
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          19   
  667                          TEXTC string consisting of up to 31 characters, designating the
  668                          run unit to which control is to be transferred.
  669                          The area may be generated by invoking the
  670                          VLP_NAME macro.  The default is NIL.                                          */
  671            2 ACCT_ VECTOR %INIT(VECTOR(ACCT))%EINIT,
  672                          /*K* ACCT = VARIABLE specifies an area containing a
  673                          TEXT string consisting of eight characters, designating the
  674                          account from which the run unit is to be
  675                          obtained. The area may be generated by invoking
  676                          the VLP_ACCT macro.  The default is NIL.                                      */
  677            2 PASS_ VECTOR %INIT(VECTOR(PASS))%EINIT,
  678                          /*K* PASS = VARIABLE  Specifies the location of a string consisting of
  679                          eight characters, designating the password
  680                          associated with the run unit.  The area may be
  681                          generated by invoking the VLP_PASS macro.
  682                          The default is NIL.                                                           */
  683            2 PSN_ VECTOR %INIT(VECTOR(PSN))%EINIT,
  684                          /*K* PSN = VARIABLE specifies the location of a
  685                          6 character string designating the
  686                          identification of the pack set on which the run
  687                          unit is located.  The default is NIL.                                         */
  688            2 CMD_ VECTOR %INIT(VECTOR(CMD))%EINIT;
  689                          /*K* CMD = VARIABLE locates an area containing a
  690                          TEXT string of up to 120 characters that is
  691                          passed in the Control Command Buffer
  692                          to the called program.  The default is NIL.                                   */
  693      %MEND;
  694                          /*F*   NAME:   M$SCREECH - Initiate Recovery
  695
  696                          The M$SCREECH service provides an entry to the
  697                          system recovery procedure for user programs.  The
  698                          SNAP privilege is required to initiate a snapshot
  699                          dump using M$SCREECH.  The SCREECH privilege is
  700                          required to initiate a full recovery.
  701
  702                          The M$SCREECH services does not pass parameters
  703                          via an FPT.  The single parameter passed on a
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          20   
  704                          call to M$SCREECH is the screech code which should
  705                          be generated using the VLP_SCODE macro.
  706                          */
  707
  708
  709
  710
  711
  712
  713
  714
  715
  716
  717                          /*P*   NAME:   GJ_MCL_E.
  718
  719                          The GJ_MCL_E macro generates the specific values
  720                          for the individual monitor service requests within
  721                          the GJ Functional Code Group.
  722                          */
  723
  724      %MACRO GJ_MCL_E;
  725      %EQU G_MCL_EXIT# = %G_FCG_J#*64 + 0;
  726      %EQU G_MCL_ERR# = %G_FCG_J#*64 +1;
  727      %EQU G_MCL_XXX# = %G_FCG_J#*64 +2;
  728      %EQU G_MCL_LDTRC# = %G_FCG_J#*64 +3;
  729      %EQU G_MCL_XBREAK# = %G_FCG_J#*64 +4;
  730      %EQU G_MCL_SCREECH# = %G_FCG_J#*64 +5;
  731      %EQU G_MCL_CPEXIT# = %G_FCG_J#*64 +6;
  732      %MEND;
  733
  734
  735
  736
  737
  738                          /*P*   NAME: GJ$ENTS.
  739
  740                          The GJ$ENTS macro generates the ENTRY declarations
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          21   
  741                          for the Monitor Services belonging to the GJ
  742                          Functional Code Group.
  743                          */
  744
  745      %MACRO GJ$ENTS;
  746      DCL M$EXIT ENTRY(1) CONV(1,2,%G_MCL_EXIT#) ALTRET;
  747      DCL M$ERR ENTRY(1) CONV(1,2,%G_MCL_ERR#) ALTRET;
  748      DCL M$XXX ENTRY(1) CONV(1,2,%G_MCL_XXX#) ALTRET;
  749      DCL M$LDTRC ENTRY(1) CONV(1,5,%G_MCL_LDTRC#) ALTRET;
  750      DCL M$XBREAK ENTRY(1) CONV(1,1,%G_MCL_XBREAK#) ALTRET;
  751      DCL M$CPEXIT ENTRY(1) CONV(1,5,%G_MCL_CPEXIT#) ALTRET;
  752      DCL M$SCREECH ENTRY(1) CONV(1,1,%G_MCL_SCREECH#) ALTRET;
  753      %MEND;
  754
  755
  756
  757
  758
  759                          /*P*   NAME: GJ_FPTS.
  760
  761                          The GJ_FPTS macro provides the LCL-6 monitor services
  762                          decoder with the information required to build the
  763                          segment descriptors and pointers for each FPT within
  764                          the GJ Functional Code Group.
  765                          */
  766
  767      %MACRO GJ_FPTS (FPTN=GJ_FPTS);
  768
  769      /* Generate the FCG_GJ header word */
  770      %GUD_FCG_INFO (FPTN=FPTN,C=%G_MCL_CPEXIT#,HAND=GJM$MCL);
  771
  772      /* Generate the data for FPT_EXIT   */
  773      %GUD_MCL_INFO (C=%G_MCL_EXIT#,V=2);
  774      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  775      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  776
  777      /* Generate the data for FPT_ERR   */
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          22   
  778      %GUD_MCL_INFO (C=%G_MCL_ERR#,V=2);
  779      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  780      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  781
  782      /* Generate the data for FPT_XXX   */
  783      %GUD_MCL_INFO (C=%G_MCL_XXX#,V=2);
  784      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  785      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  786
  787      /* Generate the data for FPT_LDTRC  */
  788      %GUD_MCL_INFO (C=%G_MCL_LDTRC#,V=6);
  789      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=2);
  790      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7);
  791      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7);
  792      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=5);
  793      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=0);
  794      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
  795
  796      /* Generate the data for FPT_XBREAK  */
  797      %GUD_MCL_INFO (C=%G_MCL_XBREAK#,V=1);
  798      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=11);
  799
  800      /* Generate the data for FPT_SCREECH */
  801      %GUD_MCL_INFO (C=%G_MCL_SCREECH#,V=1);
  802      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=5);
  803
  804      /* Generate the data for FPT_CPEXIT  */
  805      %GUD_MCL_INFO (C=%G_MCL_CPEXIT#,V=5);
  806      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=31);
  807      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7);
  808      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7);
  809      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=5);
  810      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=0);
  811
  812      %MEND;
  813
  814
14:35 JUL 28 '97 GJ_LCP6_M.:E05SI                                          23   
  815
  816
  817
  818                          /*P*   NAME: GJ$HANDLERS.
  819
  820                          The GJ$HANDLERS macro generates the ENTRY declarations
  821                          for the GJ MCL handlers.
  822                          */
  823
  824      %MACRO GJ$HANDLERS;
  825      DCL GJM$MCL ENTRY(1);
  826      %MEND;

