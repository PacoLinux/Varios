C*T***********************************************************  
C*T*                                                         *  
C*T* Copyright (c) Bull HN Information Systems Inc., 1989    *  
C*T*                                                         *  
C*T***********************************************************  
      INTEGER FUNCTION ADDSTR (S, STR, J, MAXSIZ)
      INTEGER J, MAXSIZ
      INTEGER S (100), STR (MAXSIZ)
      INTEGER I, ADDSET
      I = 1
1000  IF (.NOT.(S (I) .NE. -2))GOTO 1020 
      IF (ADDSET (S (I), STR, J, MAXSIZ) .EQ. 0) THEN
         ADDSTR = 0
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      ADDSTR = 1
      RETURN
      END 
      INTEGER FUNCTION AMOVE (NAME1, NAME2)
      INTEGER NAME1 (100), NAME2 (100)
      INTEGER BUF (133)
      INTEGER JUNK
      INTEGER GETLIN, REMOVE
      INTEGER FD1, FD2
      INTEGER CREATE, OPEN
      FD1 = OPEN (NAME1,1)
      IF (FD1 .EQ. -3) THEN
         AMOVE=(-3)
         RETURN
      ENDIF 
      FD2 = CREATE (NAME2, 2)
      IF (FD2 .EQ. -3) THEN
         AMOVE=(-3)
         RETURN
      ENDIF 
1000  IF (GETLIN (BUF,FD1) .NE. -1) THEN
         CALL PUTLIN (BUF,FD2)
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      CALL CLOSE (FD1)
      CALL CLOSE (FD2)
      JUNK = REMOVE (NAME1)
      AMOVE=(-2)
      RETURN
      END 
      SUBROUTINE CATSUB (LIN, FROM, TO, SUB, NEW, K, MAXNEW)
      INTEGER LIN (133), SUB (MAXNEW), NEW (128)
      INTEGER FROM (10), TO (10), K, MAXNEW
      INTEGER I, J, JUNK, RI
      INTEGER ADDSET
      I = 1
1000  IF (.NOT.(SUB (I) .NE. -2))GOTO 1050 
      IF (SUB (I) .EQ. -3) THEN
         I = I + 1
         RI = SUB (I) + 1
         J = FROM (RI)
1010     IF (.NOT.(J .LT. TO (RI)))GOTO 1030 
         JUNK = ADDSET (LIN (J), NEW, K, MAXNEW)
1020     J = J + 1
         GOTO 1010 
1030     CONTINUE 
      ELSE 
         JUNK = ADDSET (SUB (I), NEW, K, MAXNEW)
      ENDIF 
1040  I = I + 1
      GOTO 1000 
1050  CONTINUE 
      RETURN
      END 
      SUBROUTINE CONCAT (BUF1, BUF2, OUTSTR)
      INTEGER BUF1(100), BUF2(100), OUTSTR(100)
      INTEGER I
      I = 1
      CALL STCOPY (BUF1, 1, OUTSTR, I)
      CALL SCOPY (BUF2, 1, OUTSTR, I)
      RETURN
      END 
      INTEGER FUNCTION CTOI(IN, I)
      INTEGER IN (100)
      INTEGER I
      INTEGER D
      INTEGER INDX
      INTEGER DIGITS(11)
      LOGICAL MFLAG
      DATA DIGITS (1) /48/, DIGITS (2) /49/, DIGITS (3) /50/, DIGITS (4)
     * /51/, DIGITS (5) /52/, DIGITS (6) /53/, DIGITS (7) /54/, DIGITS (
     *8) /55/, DIGITS (9) /56/, DIGITS (10) /57/, DIGITS (11) /-2/
1000  IF (IN (I) .EQ. 32 .OR. IN (I) .EQ. 9) THEN
         I = I + 1
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      MFLAG = IN(I) .EQ. 45
      IF (MFLAG) THEN
         I = I + 1
      ENDIF 
      CTOI = 0
1020  IF (.NOT.(IN (I) .NE. -2))GOTO 1040 
      D = INDX (DIGITS, IN (I))
      IF (D .EQ. 0) THEN
         GOTO 1040 
      ENDIF 
      CTOI = 10 * CTOI + D - 1
1030  I = I + 1
      GOTO 1020 
1040  CONTINUE 
      IF (MFLAG) THEN
         CTOI = -CTOI
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION CTOMN (C, REP)
      INTEGER C, REP (4)
      INTEGER I
      INTEGER LENGTH
      INTEGER MNTEXT (136)
      DATA MNTEXT /  78, 85, 76, -2, 83, 79, 72, -2, 83, 84, 88, -2, 69,
     * 84, 88, -2, 69, 79, 84, -2, 69, 78, 81, -2, 65, 67, 75, -2, 66, 6
     *9, 76, -2, 66, 83, -2, -2, 72, 84, -2, -2, 76, 70, -2, -2, 86, 84,
     * -2, -2, 70, 70, -2, -2, 67, 82, -2, -2, 83, 79, -2, -2, 83, 73, -
     *2, -2, 68, 76, 69, -2, 68, 67, 49, -2, 68, 67, 50, -2, 68, 67, 51,
     * -2, 68, 67, 52, -2, 78, 65, 75, -2, 83, 89, 78, -2, 69, 84, 66, -
     *2, 67, 65, 78, -2, 69, 77, -2, -2, 83, 85, 66, -2, 69, 83, 67, -2,
     * 70, 83, -2, -2, 71, 83, -2, -2, 82, 83, -2, -2, 85, 83, -2, -2, 8
     *3, 80, -2, -2, 68, 69, 76, -2/
      I = AND (C, 127)
      IF (0 .LE. I .AND. I .LE. 32) THEN
         CALL SCOPY (MNTEXT, 4 * I + 1, REP, 1)
      ELSE IF (I .EQ. 127) THEN
         CALL SCOPY (MNTEXT, 133, REP, 1)
      ELSE 
         REP (1) = C
         REP (2) = -2
      ENDIF 
      CTOMN=(LENGTH (REP))
      RETURN
      END 
      SUBROUTINE DELETE (SYMBOL, ST)
      INTEGER SYMBOL (100)
      INTEGER ST
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER STLU
      INTEGER NODE, PRED
      IF (STLU (SYMBOL, NODE, PRED, ST) .EQ. 1) THEN
         MEM (PRED + 0) = MEM (NODE + 0)
         CALL DSFREE (NODE)
      ENDIF 
      RETURN
      END 
      SUBROUTINE DSINIT (W)
      INTEGER W
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER T
      IF (W .LT. 2 * 2 + 2) THEN
         CALL ERROR (42Hin dsinit: unreasonably small memory size.)
      ENDIF 
      T = 2
      MEM (T + 0) = 0
      MEM (T + 1) = 2 + 2
      T = 2 + 2
      MEM (T + 0) = W - 2 - 1
      MEM (T + 1) = 0
      MEM (1) = W
      RETURN
      END 
      SUBROUTINE ENTER (SYMBOL, INFO, ST)
      INTEGER SYMBOL (100)
      INTEGER INFO (100)
      INTEGER ST
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER I, NODSIZ, J
      INTEGER STLU, LENGTH
      INTEGER NODE, PRED
      INTEGER DSGET
      NODSIZ = MEM (ST)
      IF (STLU (SYMBOL, NODE, PRED, ST) .EQ. 0) THEN
         NODE = DSGET (1 + NODSIZ + LENGTH (SYMBOL) + 1)
         MEM (NODE + 0) = 0
         MEM (PRED + 0) = NODE
         I = 1
         J = NODE + 1 + NODSIZ
1000     IF (SYMBOL (I) .NE. -2) THEN
            MEM (J) = SYMBOL (I)
            I = I + 1
            J = J + 1
            GOTO 1000 
         ENDIF 
1010     CONTINUE 
         MEM (J) = -2
      ENDIF 
      I = 1
1020  IF (.NOT.(I .LE. NODSIZ))GOTO 1040 
      J = NODE + 1 + I - 1
      MEM (J) = INFO (I)
1030  I = I + 1
      GOTO 1020 
1040  CONTINUE 
      RETURN
      END 
      SUBROUTINE FCOPY (IN, OUT)
      INTEGER IN, OUT
      INTEGER LINE (133)
      INTEGER GETLIN
1000  IF (GETLIN (LINE, IN) .NE. -1) THEN
         CALL PUTLIN (LINE, OUT)
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      RETURN
      END 
      SUBROUTINE FMTDAT (DATE, TIME, NOW, FORM)
      INTEGER DATE (100), TIME (100)
      INTEGER NOW (7), FORM
      DATE (1) = NOW (2) / 10 + 48
      DATE (2) = MOD (NOW (2), 10) + 48
      DATE (3) = 47
      DATE (4) = NOW (3) / 10 + 48
      DATE (5) = MOD (NOW (3), 10) + 48
      DATE (6) = 47
      DATE (7) = MOD (NOW (1), 100) / 10 + 48
      DATE (8) = MOD (NOW (1), 10) + 48
      DATE (9) = -2
      TIME (1) = NOW (4) / 10 + 48
      TIME (2) = MOD (NOW (4), 10) + 48
      TIME (3) = 58
      TIME (4) = NOW (5) / 10 + 48
      TIME (5) = MOD (NOW (5), 10) + 48
      TIME (6) = 58
      TIME (7) = NOW (6) / 10 + 48
      TIME (8) = MOD (NOW (6), 10) + 48
      TIME (9) = -2
      RETURN
      END 
      INTEGER FUNCTION GCTOI (STR, I, RADIX)
      INTEGER STR (100)
      INTEGER I, RADIX
      INTEGER BASE, V, D, J
      INTEGER INDX
      INTEGER CLOWER
      LOGICAL NEG
      INTEGER DIGITS(17)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/97/,DIGITS(12)/98/,DIGITS(13)/99/,DIGITS(
     *14)/100/,DIGITS(15)/101/,DIGITS(16)/102/,DIGITS(17)/-2/
      V = 0
      BASE = RADIX
1000  IF (STR (I) .EQ. 32 .OR. STR (I) .EQ. 9) THEN
         I = I + 1
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      NEG = (STR (I) .EQ. 45)
      IF (STR (I) .EQ. 43 .OR. STR (I) .EQ. 45) THEN
         I = I + 1
      ENDIF 
      IF (STR (I + 2) .EQ. 114 .AND. STR (I) .EQ. 49 .AND. (48.LE.STR (
     1I+ 1).AND.STR (I + 1).LE.57) .OR. STR (I + 1) .EQ. 114 .AND.
     2(48.LE.STR (I).AND.STR (I).LE.57)) THEN
         BASE = STR (I) - 48
         J = I
         IF (STR (I + 1) .NE. 114) THEN
            J = J + 1
            BASE = BASE * 10 + (STR (J) - 48)
         ENDIF 
         IF (BASE .LT. 2 .OR. BASE .GT. 16) THEN
            BASE = RADIX
         ELSE 
            I = J + 2
         ENDIF 
      ENDIF 
1020  IF (.NOT.(STR (I) .NE. -2))GOTO 1040 
      IF ((48.LE.STR (I).AND.STR (I).LE.57)) THEN
         D = STR (I) - 48
      ELSE 
         D = INDX (DIGITS, CLOWER (STR (I))) - 1
      ENDIF 
      IF (D .LT. 0 .OR. D .GE. BASE) THEN
         GOTO 1040 
      ENDIF 
      V = V * BASE + D
1030  I = I + 1
      GOTO 1020 
1040  CONTINUE 
      IF (NEG) THEN
         GCTOI=(-V)
         RETURN
      ENDIF 
      GCTOI=(+V)
      RETURN
      END 
      INTEGER FUNCTION GETC (C)
      INTEGER C
      INTEGER GETCH
      GETC = GETCH (C, 1)
      RETURN
      END 
      SUBROUTINE GETNOW (NOW)
      INTEGER NOW (7)
      NOW (1) = 1980
      NOW (2) = 09
      NOW (3) = 30
      NOW (4) = 23
      NOW (5) = 59
      NOW (6) = 59
      NOW (7) = 999
      RETURN
      END 
      INTEGER FUNCTION GETPAT (STR, PAT)
      INTEGER STR (100), PAT (100)
      INTEGER MAKPAT
      GETPAT=(MAKPAT (STR, 1, -2, PAT))
      RETURN
      END 
      INTEGER FUNCTION GETWRD (IN, I, OUT)
      INTEGER IN (100), OUT (100)
      INTEGER I
      INTEGER J
1000  IF (IN (I) .EQ. 32 .OR. IN (I) .EQ. 9) THEN
         I = I + 1
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      J = 1
1020  IF (IN (I) .NE. -2 .AND. IN (I) .NE. 32 .AND. IN (I) .NE. 9 .AND.
     1IN (I) .NE. 10) THEN
         OUT (J) = IN (I)
         I = I + 1
         J = J + 1
         GOTO 1020 
      ENDIF 
1030  CONTINUE 
      OUT (J) = -2
      GETWRD = J - 1
      RETURN
      END 
      INTEGER FUNCTION GFNARG (NAME, STATE)
      INTEGER NAME (100)
      INTEGER STATE (4)
      INTEGER L
      INTEGER GETARG, GETLIN, LENGTH
      INTEGER FD
      INTEGER OPEN
      INTEGER IN1(12)
      INTEGER IN2(12)
      INTEGER IN3(12)
      DATA IN1(1)/47/,IN1(2)/100/,IN1(3)/101/,IN1(4)/118/,IN1(5)/47/,IN1
     *(6)/115/,IN1(7)/116/,IN1(8)/100/,IN1(9)/105/,IN1(10)/110/,IN1(11)/
     *49/,IN1(12)/-2/
      DATA IN2(1)/47/,IN2(2)/100/,IN2(3)/101/,IN2(4)/118/,IN2(5)/47/,IN2
     *(6)/115/,IN2(7)/116/,IN2(8)/100/,IN2(9)/105/,IN2(10)/110/,IN2(11)/
     *50/,IN2(12)/-2/
      DATA IN3(1)/47/,IN3(2)/100/,IN3(3)/101/,IN3(4)/118/,IN3(5)/47/,IN3
     *(6)/115/,IN3(7)/116/,IN3(8)/100/,IN3(9)/105/,IN3(10)/110/,IN3(11)/
     *51/,IN3(12)/-2/
1000  CONTINUE 
      IF (STATE (1) .EQ. 1) THEN
         STATE (1) = 2
         STATE (2) = 1
         STATE (3) = -3
         STATE (4) = 0
      ELSE IF (STATE (1) .EQ. 2) THEN
         IF (GETARG (STATE (2), NAME, 128) .NE. -1) THEN
            STATE (1) = 2
            STATE (2) = STATE (2) + 1
            IF (NAME (1) .NE. 45) THEN
               STATE (4) = STATE (4) + 1
               GFNARG=(-2)
               RETURN
            ELSE IF (NAME (2) .EQ. -2) THEN
               CALL SCOPY (IN1, 1, NAME, 1)
               STATE (4) = STATE (4) + 1
               GFNARG=(-2)
               RETURN
            ELSE IF (NAME (2) .EQ. 49 .AND. NAME (3) .EQ. -2) THEN
               CALL SCOPY (IN1, 1, NAME, 1)
               STATE (4) = STATE (4) + 1
               GFNARG=(-2)
               RETURN
            ELSE IF (NAME (2) .EQ. 50 .AND. NAME (3) .EQ. -2) THEN
               CALL SCOPY (IN2, 1, NAME, 1)
               STATE (4) = STATE (4) + 1
               GFNARG=(-2)
               RETURN
            ELSE IF (NAME (2) .EQ. 51 .AND. NAME (3) .EQ. -2) THEN
               CALL SCOPY (IN3, 1, NAME, 1)
               STATE (4) = STATE (4) + 1
               GFNARG=(-2)
               RETURN
            ELSE IF (NAME (2) .EQ. 110 .OR. NAME (2) .EQ. 78) THEN
               STATE (1) = 3
               IF (NAME (3) .EQ. -2) THEN
                  STATE (3) = 1
               ELSE IF (NAME (3) .EQ. 49 .AND. NAME (4) .EQ. -2) THEN
                  STATE (3) = STDIN1
               ELSE IF (NAME (3) .EQ. 50 .AND. NAME (4) .EQ. -2) THEN
                  STATE (3) = STDIN2
               ELSE IF (NAME (3) .EQ. 51 .AND. NAME (4) .EQ. -2) THEN
                  STATE (3) = STDIN3
               ELSE 
                  STATE (3) = OPEN (NAME (3), 1)
                  IF (STATE (3) .EQ. -3) THEN
                     CALL PUTLIN (NAME, 3)
                     CALL REMARK (14H:  can't open.)
                     STATE (1) = 2
                  ENDIF 
               ENDIF 
            ELSE 
               GFNARG=(-3)
               RETURN
            ENDIF 
         ELSE 
            STATE (1) = 4
         ENDIF 
      ELSE IF (STATE (1) .EQ. 3) THEN
         L = GETLIN (NAME, STATE (3))
         IF (L .NE. -1) THEN
            NAME (L) = -2
            STATE (4) = STATE (4) + 1
            GFNARG=(-2)
            RETURN
         ENDIF 
         IF (FD .NE. -3 .AND. FD .NE. 1) THEN
            CALL CLOSE (STATE (3))
         ENDIF 
         STATE (1) = 2
      ELSE IF (STATE (1) .EQ. 4) THEN
         STATE (1) = 5
         IF (STATE (4) .EQ. 0) THEN
            CALL SCOPY (IN1, 1, NAME, 1)
            GFNARG=(-2)
            RETURN
         ENDIF 
         GOTO 1020 
      ELSE IF (STATE (1) .EQ. 5) THEN
         GOTO 1020 
      ELSE 
         CALL ERROR (32Hin gfnarg:  bad state (1) value.)
      ENDIF 
1010  GOTO 1000 
1020  CONTINUE 
      NAME (1) = -2
      GFNARG=(-1)
      RETURN
      END 
      INTEGER FUNCTION GITOC (INT, STR, SIZE, BASE)
      INTEGER INT, SIZE, BASE
      INTEGER STR (SIZE)
      INTEGER CARRY, D, I, RADIX, N
      LOGICAL UNSIGN
      INTEGER DIGITS(17)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/65/,DIGITS(12)/66/,DIGITS(13)/67/,DIGITS(
     *14)/68/,DIGITS(15)/69/,DIGITS(16)/70/,DIGITS(17)/-2/
      STR (1) = -2
      IF (SIZE .LE. 1) THEN
         GITOC=(0)
         RETURN
      ENDIF 
      RADIX = IABS (BASE)
      IF (RADIX .LT. 2 .OR. RADIX .GT. 16) THEN
         RADIX = 10
      ENDIF 
      UNSIGN = (BASE .LT. 0)
      IF (UNSIGN) THEN
         N = AND (INT / 2, 34359738367)
         CARRY = AND (INT, 1)
      ELSE 
         N = INT
      ENDIF 
      I = 1
1000  CONTINUE 
      D = IABS (MOD (N, RADIX))
      IF (UNSIGN) THEN
         D = 2 * D + CARRY
         IF (D .GE. RADIX) THEN
            D = D - RADIX
            CARRY = 1
         ELSE 
            CARRY = 0
         ENDIF 
      ENDIF 
      I = I + 1
      STR (I) = DIGITS (D + 1)
      N = N / RADIX
1010  IF (.NOT.(N .EQ. 0 .OR. I .GE. SIZE))GOTO 1000 
1020  CONTINUE 
      IF (UNSIGN) THEN
         IF (CARRY .NE. 0 .AND. I .LT. SIZE) THEN
            I = I + 1
            STR (I) = 49
         ENDIF 
      ELSE IF (INT .LT. 0 .AND. I .LT. SIZE) THEN
         I = I + 1
         STR (I) = 45
      ENDIF 
      GITOC = I - 1
      D = 1
1030  IF (.NOT.(D .LT. I))GOTO 1050 
      CARRY = STR (D)
      STR (D) = STR (I)
      STR (I) = CARRY
      I = I - 1
1040  D = D + 1
      GOTO 1030 
1050  CONTINUE 
      RETURN
      END 
      SUBROUTINE INITST
      INTEGER INPUT (30), OUTPUT (30), ERROUT (30)
      INTEGER I, OUTACC, ERRACC
      COMMON /ARGS/ NBRARG, PTR (32), ARG (133)
      INTEGER NBRARG
      INTEGER PTR
      INTEGER ARG
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      DATA OUTACC /2/
      DATA ERRACC /2/
      NBRARG = 0
      UNIT (1) = 5
      MODE (1) = 1
      FTYPE (1) = 6
      UNIT (2) = 6
      MODE (2) = 1
      FTYPE (2) = 6
      UNIT (3) = 7
      MODE (3) = 0
      FTYPE (3) = 6
      UNIT (4) = 1
      MODE (4) = 1
      FTYPE (4) = 6
      UNIT (5) = 2
      MODE (5) = 1
      FTYPE (5) = 6
      UNIT (6) = 3
      MODE (6) = 1
      FTYPE (6) = 6
      UNIT(7) = 4
      MODE(7) = 0
      FTYPE(7) = 6
      CALL TERMIN (INPUT)
      CALL TRMOUT (OUTPUT)
      CALL TRMOUT (ERROUT)
      I = 1
1000  IF (.NOT.(I .LE. 7))GOTO 1020 
      FILENM (1, I) = -2
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      END 
      INTEGER FUNCTION ISATTY (INT)
      INTEGER INT
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      IF (MODE (INT) .EQ. 0) THEN
         ISATTY = 1
      ELSE 
         ISATTY = 0
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION LOOKUP (SYMBOL, INFO, ST)
      INTEGER SYMBOL (100)
      INTEGER INFO (100)
      INTEGER ST
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER I, NODSIZ, KLUGE
      INTEGER STLU
      INTEGER NODE, PRED
      IF (STLU (SYMBOL, NODE, PRED, ST) .EQ. 0) THEN
         LOOKUP = 0
         RETURN
      ENDIF 
      NODSIZ = MEM (ST)
      I = 1
1000  IF (.NOT.(I .LE. NODSIZ))GOTO 1020 
      KLUGE = NODE + 1 - 1 + I
      INFO (I) = MEM (KLUGE)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      LOOKUP = 1
      RETURN
      END 
      INTEGER FUNCTION MAKSUB (ARG, FROM, DELIM, SUB)
      INTEGER ARG (128), DELIM, SUB (128)
      INTEGER FROM
      INTEGER ESC, TYPE
      INTEGER I, J, JUNK
      INTEGER ADDSET
      J = 1
      I = FROM
1000  IF (.NOT.(ARG (I) .NE. DELIM .AND. ARG (I) .NE. -2))GOTO 1020 
      IF (ARG (I) .EQ. 38) THEN
         JUNK = ADDSET (-3, SUB, J, 128)
         JUNK = ADDSET (0, SUB, J, 128)
      ELSE IF (ARG (I) .EQ. 64 .AND. TYPE (ARG (I + 1)) .EQ. 48) THEN
         I = I + 1
         JUNK = ADDSET (-3, SUB, J, 128)
         JUNK = ADDSET (ARG (I) - 48, SUB, J, 128)
      ELSE 
         JUNK = ADDSET (ESC (ARG, I), SUB, J, 128)
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      IF (ARG (I) .NE. DELIM) THEN
         MAKSUB = -3
      ELSE IF (ADDSET (-2, SUB, J, 128) .EQ. 0) THEN
         MAKSUB = -3
      ELSE 
         MAKSUB = I
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION MATCH (LIN, PAT)
      INTEGER LIN (133), PAT (128)
      INTEGER I, JUNK (9)
      INTEGER AMATCH
      I = 1
1000  IF (.NOT.(LIN (I) .NE. -2))GOTO 1020 
      IF (AMATCH (LIN, I, PAT, JUNK, JUNK) .GT. 0) THEN
         MATCH = 1
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      MATCH = 0
      RETURN
      END 
      INTEGER FUNCTION MKTABL (NODSIZ)
      INTEGER NODSIZ
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER ST
      INTEGER DSGET
      INTEGER I
      ST = DSGET (43 + 1)
      MEM (ST) = NODSIZ
      MKTABL = ST
      DO 1000 I = 1, 43
         ST = ST + 1
         MEM (ST) = 0
1000  CONTINUE 
1010  CONTINUE 
      RETURN
      END 
      SUBROUTINE MKUNIQ (SEED, NAME)
      INTEGER SEED (100), NAME (100)
      CALL SCOPY (SEED, 1, NAME, 1)
      RETURN
      END 
      INTEGER FUNCTION MNTOC (BUF, P, DEFAULT)
      INTEGER BUF (100), DEFAULT
      INTEGER P
      INTEGER I, TP
      INTEGER EQUAL
      INTEGER C, TMP (133)
      INTEGER TEXT (170)
      DATA TEXT /  6, 97, 99, 107, -2, 7, 98, 101, 108, -2, 8, 98, 115,
     *-2, -2, 24, 99, 97, 110, -2, 13, 99, 114, -2, -2, 17, 100, 99, 49,
     * -2, 18, 100, 99, 50, -2, 19, 100, 99, 51, -2, 20, 100, 99, 52, -2
     *, 127, 100, 101, 108, -2, 16, 100, 108, 101, -2, 25, 101, 109, -2,
     * -2, 5, 101, 110, 113, -2, 4, 101, 111, 116, -2, 27, 101, 115, 99,
     * -2, 23, 101, 116, 98, -2, 3, 101, 116, 120, -2, 12, 102, 102, -2,
     * -2, 28, 102, 115, -2, -2, 29, 103, 115, -2, -2, 9, 104, 116, -2,
     *-2, 10, 108, 102, -2, -2, 21, 110, 97, 107, -2, 0, 110, 117, 108,
     *-2, 30, 114, 115, -2, -2, 15, 115, 105, -2, -2, 14, 115, 111, -2,
     *-2, 1, 115, 111, 104, -2, 32, 115, 112, -2, -2, 2, 115, 116, 120,
     *-2, 26, 115, 117, 98, -2, 22, 115, 121, 110, -2, 31, 117, 115, -2,
     * -2, 11, 118, 116, -2, -2/
      TP = 1
1000  CONTINUE 
      TMP (TP) = BUF (P)
      TP = TP + 1
      P = P + 1
1010  IF (.NOT.(.NOT. (((65.LE.BUF (P).AND.BUF (P).LE.90).OR.(97.LE.BUF(
     1P).AND.BUF (P).LE.122)) .OR. (48.LE.BUF (P).AND.BUF (P).LE.57))
     2.OR. TP .GE. 133))GOTO 1000 
1020  CONTINUE 
      TMP (TP) = -2
      IF (TP .EQ. 2) THEN
         C = TMP (1)
      ELSE 
         CALL LOWER (TMP)
         I = 1
1030     IF (.NOT.(I .LT. 170))GOTO 1050 
         IF (EQUAL (TMP, TEXT (I + 1)) .EQ. 1) THEN
            GOTO 1050 
         ENDIF 
1040     I = I + 5
         GOTO 1030 
1050     CONTINUE 
         IF (I .LT. 170) THEN
            C = TEXT (I)
         ELSE 
            C = DEFAULT
         ENDIF 
      ENDIF 
      MNTOC=(C)
      RETURN
      END 
      SUBROUTINE NOTE (INT, OFFSET)
      INTEGER INT
      INTEGER OFFSET (2)
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      OFFSET (1) = CCNT (INT) + 1
      RETURN
      END 
      SUBROUTINE PROMPT (STR, BUF, FD)
      INTEGER STR(100), BUF(100)
      INTEGER FD
      INTEGER ISATTY
      IF (ISATTY(FD) .EQ. 1) THEN
         CALL PUTLIN (STR, FD)
         CALL FLUSH (FD)
      ENDIF 
      CALL GETLIN (BUF, FD)
      RETURN
      END 
      SUBROUTINE PUTDEC(N,W)
      INTEGER N, W
      INTEGER CHARS (20)
      INTEGER I, ND
      INTEGER ITOC
      ND = ITOC (N, CHARS, 20)
      I = ND + 1
1000  IF (.NOT.(I .LE. W))GOTO 1020 
      CALL PUTC (32)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      I = 1
1030  IF (.NOT.(I .LE. ND))GOTO 1050 
      CALL PUTC (CHARS (I))
1040  I = I + 1
      GOTO 1030 
1050  CONTINUE 
      RETURN
      END 
      SUBROUTINE QUERY (MESG)
      INTEGER MESG (100)
      INTEGER GETARG
      INTEGER ARG1 (3), ARG2 (1)
      IF (GETARG (1, ARG1, 3) .NE. -1 .AND. GETARG (2, ARG2, 1) .EQ. -1)
     1THEN
         IF (ARG1 (1) .EQ. 63 .AND. ARG1 (2) .EQ. -2) THEN
            CALL ERROR (MESG)
         ENDIF 
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION READF (BUF, N, FD)
      INTEGER BUF (100)
      INTEGER N
      INTEGER FD
      INTEGER GETCH
      INTEGER I
      I = 1
1000  IF (.NOT.(I .LE. N))GOTO 1020 
      IF (GETCH (BUF (I), FD) .EQ. -1) THEN
         BUF (I) = -2
         READF=(-1)
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      BUF (I) = -2
      READF=(I-1)
      RETURN
      END 
      SUBROUTINE RMTABL (ST)
      INTEGER ST
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER I
      INTEGER WALKER, BUCKET, NODE
      BUCKET = ST
      DO 1020 I = 1, 43
         BUCKET = BUCKET + 1
         WALKER = MEM (BUCKET)
1000     IF (WALKER .NE. 0) THEN
            NODE = WALKER
            WALKER = MEM (NODE + 0)
            CALL DSFREE (NODE)
            GOTO 1000 
         ENDIF 
1010     CONTINUE 
1020  CONTINUE 
1030  CONTINUE 
      CALL DSFREE (ST)
      RETURN
      END 
      INTEGER FUNCTION SCTABL (TABLE, SYM, INFO, POSN)
      INTEGER TABLE, POSN
      INTEGER SYM (100)
      INTEGER INFO (100)
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER BUCKET, WALKER
      INTEGER DSGET
      INTEGER NODSIZ, I, J
      IF (POSN .EQ. 0) THEN
         POSN = DSGET (2)
         MEM (POSN) = 1
         MEM (POSN + 1) = MEM (TABLE + 1)
      ENDIF 
      BUCKET = MEM (POSN)
      WALKER = MEM (POSN + 1)
      NODSIZ = MEM (TABLE)
1000  CONTINUE 
      IF (WALKER .NE. 0) THEN
         I = WALKER + 1 + NODSIZ
         J = 1
1010     IF (MEM (I) .NE. -2) THEN
            SYM (J) = MEM (I)
            I = I + 1
            J = J + 1
            GOTO 1010 
         ENDIF 
1020     CONTINUE 
         SYM (J) = -2
         I = 1
1030     IF (.NOT.(I .LE. NODSIZ))GOTO 1050 
         J = WALKER + 1 + I - 1
         INFO (I) = MEM (J)
1040     I = I + 1
         GOTO 1030 
1050     CONTINUE 
         MEM (POSN) = BUCKET
         MEM (POSN + 1) = MEM (WALKER + 0)
         SCTABL = 1
         RETURN
      ELSE 
         BUCKET = BUCKET + 1
         IF (BUCKET .GT. 43) THEN
            GOTO 1070 
         ENDIF 
         J = TABLE + BUCKET
         WALKER = MEM (J)
      ENDIF 
1060  GOTO 1000 
1070  CONTINUE 
      CALL DSFREE (POSN)
      POSN = 0
      SCTABL = -1
      RETURN
      END 
      INTEGER FUNCTION SDROP (FROM, TO, CHARS)
      INTEGER FROM (100), TO (100)
      INTEGER CHARS
      INTEGER LEN, START
      INTEGER CTOC, LENGTH, MIN0
      LEN = LENGTH (FROM)
      IF (CHARS .LT. 0) THEN
         SDROP=(CTOC (FROM, TO, LEN + CHARS + 1))
         RETURN
      ENDIF 
      START = MIN0 (CHARS, LEN)
      SDROP=(CTOC (FROM (START + 1), TO, LEN + 1))
      RETURN
      END 
      SUBROUTINE SEEK (OFFSET, INT)
      INTEGER OFFSET (2), INT
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      INTEGER C
      IF (OFFSET (1) .LE. CCNT (INT)) THEN
         CALL RWIND (INT)
      ENDIF 
1000  IF (CCNT (INT) + 1 .LT. OFFSET (1)) THEN
         IF (GETCH (C, INT) .EQ. -1) THEN
            GOTO 1010 
         ENDIF 
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION STAKE (FROM, TO, CHARS)
      INTEGER FROM (100), TO (100)
      INTEGER CHARS
      INTEGER LEN, START
      INTEGER LENGTH, CTOC, MAX0
      LEN = LENGTH (FROM)
      IF (CHARS .LT. 0) THEN
         START = MAX0 (LEN + CHARS, 0)
         STAKE=(CTOC (FROM (START + 1), TO, LEN + 1))
         RETURN
      ENDIF 
      STAKE=(CTOC (FROM, TO, CHARS + 1))
      RETURN
      END 
      INTEGER FUNCTION STRCMP (STR1, STR2)
      INTEGER STR1 (100), STR2 (100)
      INTEGER I
      I = 1
1000  IF (.NOT.(STR1 (I) .EQ. STR2 (I)))GOTO 1020 
      IF (STR1 (I) .EQ. -2) THEN
         STRCMP=(0)
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      IF (STR1 (I) .EQ. -2) THEN
         STRCMP = -1
      ELSE IF (STR2 (I) .EQ. -2) THEN
         STRCMP = + 1
      ELSE IF (STR1 (I) .LT. STR2 (I)) THEN
         STRCMP = -1
      ELSE 
         STRCMP = +1
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION STRIM (STR)
      INTEGER STR (100)
      INTEGER LNB, I
      LNB = 0
      I = 1
1000  IF (.NOT.(STR (I) .NE. -2))GOTO 1020 
      IF (STR (I) .NE. 32 .AND. STR (I) .NE. 9) THEN
         LNB = I
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      STR (LNB + 1) = -2
      STRIM=(LNB)
      RETURN
      END 
      INTEGER FUNCTION SLSTR (FROM, TO, FIRST, CHARS)
      INTEGER FROM (100), TO (100)
      INTEGER FIRST, CHARS
      INTEGER LEN, I, J, K
      INTEGER LENGTH
      LEN = LENGTH (FROM)
      I = FIRST
      IF (I .LT. 1) THEN
         I = I + LEN + 1
      ENDIF 
      IF (CHARS .LT. 0) THEN
         I = I + CHARS + 1
         CHARS = - CHARS
      ENDIF 
      J = I + CHARS - 1
      IF (I .LT. 1) THEN
         I = 1
      ENDIF 
      IF (J .GT. LEN) THEN
         J = LEN
      ENDIF 
      K = 0
1000  IF (.NOT.(I .LE. J))GOTO 1020 
      TO (K + 1) = FROM (I)
      I = I + 1
1010  K = K + 1
      GOTO 1000 
1020  CONTINUE 
      TO (K + 1) = -2
      SLSTR=(K)
      RETURN
      END 
      INTEGER FUNCTION TYPE (C)
      INTEGER C
      IF ((97 .LE. C .AND. C .LE. 122) .OR. (65 .LE. C .AND. C .LE. 90))
     1THEN
         TYPE = 97
      ELSE IF (48 .LE. C .AND. C .LE. 57) THEN
         TYPE = 48
      ELSE 
         TYPE = C
      ENDIF 
      RETURN
      END 
      SUBROUTINE UPPER (TOKEN)
      INTEGER TOKEN (100)
      INTEGER CUPPER
      INTEGER I
      I = 1
1000  IF (.NOT.(TOKEN (I) .NE. -2))GOTO 1020 
      TOKEN (I) = CUPPER (TOKEN (I))
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
 
      INTEGER FUNCTION WKDAY (MONTH, DAY, YEAR)
      INTEGER IDAYS,LEAP,LYEAR
      INTEGER MONTH,DAY,YEAR,TDAYS
      DIMENSION IMNTH(12)
      DATA IMNTH /0,31,28,31,30,31,30,31,31,30,31,30/
      LYEAR = YEAR
      IF (LYEAR.LT.21)THEN
          LYEAR = LYEAR + 2000 - 1
      ELSE
          LYEAR = LYEAR + 1900 - 1
      ENDIF 
      LEAP = 0
      IF((MOD(LYEAR+1,4).EQ.0.AND.MOD(LYEAR+1,100).NE.0).OR.
     +  MOD(LYEAR+1,400).EQ.0) LEAP = 1
      IMNTH(3) = 28 + LEAP
      IDAYS = 0
      DO 1001 I=1, MONTH
         IDAYS = IDAYS + IMNTH(I)
1001  CONTINUE
      IDAYS = IDAYS + DAY
      TDAYS = LYEAR*365+LYEAR/4-LYEAR/100+LYEAR/400+IDAYS
      WKDAY = MOD(TDAYS, 7) + 1
      RETURN
      END 
 
      INTEGER FUNCTION WRITEF (BUF, N, FD)
      INTEGER BUF (100)
      INTEGER N
      INTEGER FD
      INTEGER I
      I = 1
1000  IF (.NOT.(I .LE. N))GOTO 1020 
      IF (BUF (I) .EQ. -2) THEN
         GOTO 1020 
      ENDIF 
      CALL PUTCH (BUF (I), FD)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      WRITEF=(I - 1)
      RETURN
      END 
      INTEGER FUNCTION REMOVE (FILE)
      INTEGER FILE (100)
      CALL REMARK ('-Remove- not fully implemented.')
      CALL PUTLIN (FILE, 3)
      CALL REMARK (':  cannot remove.')
      REMOVE=(-3)
      RETURN
      END 
      INTEGER FUNCTION CREATE (NAME, ACCESS)
      INTEGER NAME (100)
      INTEGER ACCESS
      INTEGER OPEN
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      CREATE=(OPEN (NAME, ACCESS))
      RETURN
      END 
      SUBROUTINE STCOPY (IN, I, OUT, J)
      INTEGER IN (100), OUT (100)
      INTEGER I, J
      INTEGER K
      K = I
1000  IF (.NOT.(IN (K) .NE. -2))GOTO 1020 
      OUT (J) = IN (K)
      J = J + 1
1010  K = K + 1
      GOTO 1000 
1020  CONTINUE 
      OUT(J) = -2
      RETURN
      END 
      INTEGER FUNCTION MAKPAT (ARG, FROM, DELIM, PAT)
      INTEGER ARG (128), DELIM, PAT (128)
      INTEGER FROM
      INTEGER ESC
      INTEGER I, J, JUNK, LASTCL, LASTJ, LJ, TAGNST, TAGNUM, TAGSTK (9)
      INTEGER ADDSET, GETCCL, STCLOS
      J = 1
      LASTJ = 1
      LASTCL = 0
      TAGNUM = 0
      TAGNST = 0
      I = FROM
1000  IF (.NOT.(ARG (I) .NE. DELIM .AND. ARG (I) .NE. -2))GOTO 1020 
      LJ = J
      IF (ARG (I) .EQ. 63) THEN
         JUNK = ADDSET (63, PAT, J, 128)
      ELSE IF (ARG (I) .EQ. 37 .AND. I .EQ. FROM) THEN
         JUNK = ADDSET (37, PAT, J, 128)
      ELSE IF (ARG (I) .EQ. 36 .AND. ARG (I + 1) .EQ. DELIM) THEN
         JUNK = ADDSET (36, PAT, J, 128)
      ELSE IF (ARG (I) .EQ. 91) THEN
         IF (GETCCL (ARG, I, PAT, J) .EQ. -3) THEN
            MAKPAT = -3
            RETURN
         ENDIF 
      ELSE IF (ARG (I) .EQ. 42 .AND. I .GT. FROM) THEN
         LJ = LASTJ
         IF (PAT (LJ) .EQ.37 .OR. PAT (LJ) .EQ.36 .OR. PAT (LJ) .EQ.
     1      42 .OR.PAT (LJ) .EQ. 123 .OR. PAT (LJ) .EQ. 125) THEN
            GOTO 1020 
         ENDIF 
         LASTCL = STCLOS (PAT, J, LASTJ, LASTCL)
      ELSE IF (ARG (I) .EQ. 123) THEN
         IF (TAGNUM .GE. 9) THEN
            GOTO 1020 
         ENDIF 
         TAGNUM = TAGNUM + 1
         TAGNST = TAGNST + 1
         TAGSTK (TAGNST) = TAGNUM
         JUNK = ADDSET (123, PAT, J, 128)
         JUNK = ADDSET (TAGNUM, PAT, J, 128)
      ELSE IF (ARG (I) .EQ. 125 .AND. TAGNST .GT. 0) THEN
         JUNK = ADDSET (125, PAT, J, 128)
         JUNK = ADDSET (TAGSTK (TAGNST), PAT, J, 128)
         TAGNST = TAGNST - 1
      ELSE 
         JUNK = ADDSET (97, PAT, J, 128)
         JUNK = ADDSET (ESC (ARG, I), PAT, J, 128)
      ENDIF 
      LASTJ = LJ
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      IF (ARG (I) .NE. DELIM) THEN
         MAKPAT = -3
      ELSE IF (ADDSET (-2, PAT, J, 128) .EQ. 0) THEN
         MAKPAT = -3
      ELSE IF (TAGNST .NE. 0) THEN
         MAKPAT = -3
      ELSE 
         MAKPAT = I
      ENDIF 
      RETURN
      END 
      SUBROUTINE CANT (FILE)
      INTEGER FILE (100)
      INTEGER MSG(15)
      DATA MSG(1), MSG(2), MSG(3), MSG(4), MSG(5), MSG(6), MSG(7), MSG(8
     *), MSG(9), MSG(10), MSG(11), MSG(12), MSG(13), MSG(14), MSG(15) /5
     *8, 32, 32, 99, 97, 110, 39, 116, 32, 111, 112, 101, 110, 10, -2/
      CALL PUTLIN (FILE, 3)
      CALL PUTLIN (MSG, 3)
      CALL ENDST
      END 
      SUBROUTINE DELARG (N)
      INTEGER N
      COMMON /ARGS/ NBRARG, PTR (32), ARG (133)
      INTEGER NBRARG
      INTEGER PTR
      INTEGER ARG
      INTEGER I
      IF (N .GT. NBRARG) THEN
         RETURN
      ENDIF 
      I = N
1000  IF (.NOT.(I .LT. NBRARG))GOTO 1020 
      PTR (I) = PTR (I + 1)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      NBRARG = NBRARG - 1
      RETURN
      END 
      INTEGER FUNCTION ERRSUB (ARG, FILE, ACCESS)
      INTEGER ARG (100), FILE (100)
      INTEGER ACCESS
      IF (ARG (1) .EQ. 63 .AND. ARG (2) .NE. 63 .AND. ARG (2) .NE. -2)
     1THEN
         ERRSUB = 1
         ACCESS = 2
         CALL SCOPY (ARG, 2, FILE, 1)
      ELSE IF (ARG (1) .EQ. 63 .AND. ARG (2) .EQ. 63 .AND. ARG (3) .NE
     1. -2) THEN
         ERRSUB = 1
         ACCESS = 4
         CALL SCOPY (ARG, 3, FILE, 1)
      ELSE 
         ERRSUB = 0
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION OUTSUB (ARG, FILE, ACCESS)
      INTEGER ARG (100), FILE (100)
      INTEGER ACCESS
      IF (ARG (1) .EQ. 62 .AND. ARG (2) .NE. 62 .AND. ARG (2) .NE. -2)
     1THEN
         OUTSUB = 1
         ACCESS = 2
         CALL SCOPY (ARG, 2, FILE, 1)
      ELSE IF (ARG (1) .EQ. 62 .AND. ARG (2) .EQ. 62 .AND. ARG (3) .NE
     1. -2) THEN
         ACCESS = 4
         OUTSUB = 1
         CALL SCOPY (ARG, 3, FILE, 1)
      ELSE 
         OUTSUB = 0
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION INSUB (ARG, FILE)
      INTEGER ARG (100), FILE (100)
      IF (ARG (1) .EQ. 60 .AND. ARG (2) .NE. -2) THEN
         INSUB = 1
         CALL SCOPY (ARG, 2, FILE, 1)
      ELSE 
         INSUB = 0
      ENDIF 
      RETURN
      END 
      SUBROUTINE MAKARG
      COMMON /ARGS/ NBRARG, PTR (32), ARG (133)
      INTEGER NBRARG
      INTEGER PTR
      INTEGER ARG
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      INTEGER INDEX, TOG, FUNIT, I
      INTEGER INMAP
      NBRARG = 0
      FUNIT = UNIT (2)
      WRITE (FUNIT,9000)
      FUNIT = UNIT (1)
      READ (FUNIT,9010) (ARG (I), I = 1, 133)
      I = 1
1000  IF (.NOT.(I .LE. 133))GOTO 1020 
      ARG (I) = INMAP (ARG (I))
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      ARG (133) = -2
      INDEX = 1
      I = 1
1030  IF (.NOT.(I .LE. 32))GOTO 1090 
      IF (INDEX .LT. 133) THEN
         CALL SKIPBL (ARG, INDEX)
      ENDIF 
      IF (INDEX .GE. 133) THEN
         GOTO 1090 
      ENDIF 
      PTR (I) = INDEX
      IF (ARG (INDEX) .EQ. 39 .OR. ARG (INDEX) .EQ. 34) THEN
         PTR (I) = INDEX+1
         TOG = ARG (INDEX)
         INDEX = INDEX + 1
1040     IF (ARG (INDEX) .NE. TOG .AND. ARG (INDEX) .NE. -2) THEN
            INDEX = INDEX + 1
            GOTO 1040 
         ENDIF 
1050     CONTINUE 
      ELSE 
1060     IF (ARG (INDEX) .NE. 32 .AND. ARG (INDEX) .NE. -2) THEN
            INDEX = INDEX + 1
            GOTO 1060 
         ENDIF 
1070     CONTINUE 
      ENDIF 
      ARG (INDEX) = -2
      INDEX = INDEX + 1
1080  I = I + 1
      GOTO 1030 
1090  CONTINUE 
      NBRARG = I -1
      RETURN
9000  FORMAT (1X, 5HARGS:)
9010  FORMAT (133 A1)
      END 
      SUBROUTINE TRMOUT (NAME)
      INTEGER NAME (100)
      INTEGER TNAME(4)
      DATA TNAME(1)/116/,TNAME(2)/116/,TNAME(3)/121/,TNAME(4)/-2/
      CALL SCOPY (TNAME, 1, NAME, 1)
      RETURN
      END 
      SUBROUTINE TERMIN (NAME)
      INTEGER NAME (100)
      INTEGER TNAME(4)
      DATA TNAME(1)/116/,TNAME(2)/116/,TNAME(3)/121/,TNAME(4)/-2/
      CALL SCOPY (TNAME, 1, NAME, 1)
      RETURN
      END 
      INTEGER FUNCTION STLU (SYMBOL, NODE, PRED, ST)
      INTEGER SYMBOL (100)
      INTEGER NODE, PRED, ST
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER HASH, I, J, NODSIZ
      NODSIZ = MEM (ST)
      HASH = 0
      I = 1
1000  IF (.NOT.(SYMBOL (I) .NE. -2))GOTO 1020 
      HASH = HASH + SYMBOL (I)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      HASH = MOD (HASH, 43) + 1
      PRED = ST + HASH
      NODE = MEM (PRED)
1030  IF (NODE .NE. 0) THEN
         I = 1
         J = NODE + 1 + NODSIZ
1040     IF (SYMBOL (I) .EQ. MEM (J)) THEN
            IF (SYMBOL (I) .EQ. -2) THEN
               STLU=(1)
               RETURN
            ENDIF 
            I = I + 1
            J = J + 1
            GOTO 1040 
         ENDIF 
1050     CONTINUE 
         PRED = NODE
         NODE = MEM (PRED + 0)
         GOTO 1030 
      ENDIF 
1060  CONTINUE 
      STLU=(0)
      RETURN
      END 
      INTEGER FUNCTION AMATCH (LIN, FROM, PAT, TAGBEG, TAGEND)
      INTEGER LIN (133), PAT (128)
      INTEGER FROM, TAGBEG (10), TAGEND (10)
      INTEGER I, J, OFFSET, STACK
      INTEGER OMATCH, PATSIZ
      I = 1
1000  IF (.NOT.(I .LE. 10))GOTO 1020 
      TAGBEG (I) = 0
      TAGEND (I) = 0
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      TAGBEG (1) = FROM
      STACK = 0
      OFFSET = FROM
      J = 1
1030  IF (.NOT.(PAT (J) .NE. -2))GOTO 1110 
      IF (PAT (J) .EQ. 42) THEN
         STACK = J
         J = J + 4
         I = OFFSET
1040     IF (.NOT.(LIN (I) .NE. -2))GOTO 1060 
         IF (OMATCH (LIN, I, PAT, J) .EQ. 0) THEN
            GOTO 1060 
         ENDIF 
1050     GOTO 1040 
1060     CONTINUE 
         PAT (STACK + 1) = I - OFFSET
         PAT (STACK + 3) = OFFSET
         OFFSET = I
      ELSE IF (PAT (J) .EQ. 123) THEN
         I = PAT (J + 1)
         TAGBEG (I + 1) = OFFSET
      ELSE IF (PAT (J) .EQ. 125) THEN
         I = PAT (J + 1)
         TAGEND (I + 1) = OFFSET
      ELSE IF (OMATCH (LIN, OFFSET, PAT, J) .EQ. 0) THEN
1070     IF (.NOT.(STACK .GT. 0))GOTO 1090 
         IF (PAT (STACK + 1) .GT. 0) THEN
            GOTO 1090 
         ENDIF 
1080     STACK = PAT (STACK + 2)
         GOTO 1070 
1090     CONTINUE 
         IF (STACK .LE. 0) THEN
            AMATCH = 0
            RETURN
         ENDIF 
         PAT (STACK + 1) = PAT (STACK + 1) - 1
         J = STACK + 4
         OFFSET = PAT (STACK + 3) + PAT (STACK + 1)
      ENDIF 
1100  J = J + PATSIZ (PAT, J)
      GOTO 1030 
1110  CONTINUE 
      AMATCH = OFFSET
      TAGEND (1) = OFFSET
      RETURN
      END 
      SUBROUTINE LOWER (TOKEN)
      INTEGER TOKEN (100)
      CALL FOLD (TOKEN)
      RETURN
      END 
      SUBROUTINE FLUSH (INT)
      INTEGER INT
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      IF (FILENM (1, INT) .EQ. -2) THEN
         RETURN
      ENDIF 
      IF (LASTC (INT) .GT. 0 .AND. FILACC (INT) .NE. 1) THEN
         CALL PUTCH (10,INT)
      ENDIF 
      RETURN
      END 
      SUBROUTINE PUTC (C)
      INTEGER C
      CALL PUTCH (C, 2)
      RETURN
      END 
      INTEGER FUNCTION GETARG (N, ARRAY, MAXSIZ)
      INTEGER N, MAXSIZ
      INTEGER ARRAY (MAXSIZ)
      COMMON /ARGS/ NBRARG, PTR (32), ARG (133)
      INTEGER NBRARG
      INTEGER PTR
      INTEGER ARG
      INTEGER INDEX, I
      IF (N .LT. 1 .OR. N .GT. NBRARG) THEN
         ARRAY (1) = -2
         GETARG = -1
         RETURN
      ENDIF 
      INDEX = PTR (N)
      I = 1
1000  IF (.NOT.(I .LE. MAXSIZ))GOTO 1020 
      ARRAY (I) = ARG (INDEX)
      IF (ARG (INDEX) .EQ. -2) THEN
         GOTO 1020 
      ENDIF 
      INDEX = INDEX + 1
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      ARRAY (I) = -2
      GETARG = I - 1
      RETURN
      END 
      SUBROUTINE DSFREE (BLOCK)
      INTEGER BLOCK
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER P0, P, Q
      INTEGER N, JUNK
      INTEGER CON (10)
      P0 = BLOCK - 2
      N = MEM (P0 + 0)
      Q = 2
1000  CONTINUE 
      P = MEM (Q + 1)
      IF (P .EQ. 0 .OR. P .GT. P0) THEN
         GOTO 1020 
      ENDIF 
      Q = P
1010  GOTO 1000 
1020  CONTINUE 
      IF (Q + MEM (Q + 0) .GT. P0) THEN
         CALL REMARK (46Hin dsfree:  attempt to free unallocated block.)
         CALL REMARK (21Htype 'c' to continue.)
         JUNK = GETLIN (CON, 1)
         IF (CON (1) .NE. 99 .AND. CON (1) .NE. 67) THEN
            CALL ENDST
         ENDIF 
         RETURN
      ENDIF 
      IF (P0 + N .EQ. P .AND. P .NE. 0) THEN
         N = N + MEM (P + 0)
         MEM (P0 + 1) = MEM (P + 1)
      ELSE 
         MEM (P0 + 1) = P
      ENDIF 
      IF (Q + MEM (Q + 0) .EQ. P0) THEN
         MEM (Q + 0) = MEM (Q + 0) + N
         MEM (Q + 1) = MEM (P0 + 1)
      ELSE 
         MEM (Q + 1) = P0
         MEM (P0 + 0) = N
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION DSGET (W)
      INTEGER W
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER P, Q, L
      INTEGER N, K, JUNK
      INTEGER GETLIN
      INTEGER C (10)
      N = W + 2
      Q = 2
1000  CONTINUE 
      P = MEM (Q + 1)
      IF (P .EQ. 0) THEN
         CALL REMARK (31Hin dsget: out of storage space.)
         CALL REMARK (41Htype 'c' or 'i' for char or integer dump.)
         JUNK = GETLIN (C, 1)
         IF (C (1) .EQ. 99 .OR. C (1) .EQ. 67) THEN
            CALL DSDUMP (97)
         ELSE IF (C (1) .EQ. 105 .OR. C (1) .EQ. 73) THEN
            CALL DSDUMP (48)
         ENDIF 
         CALL ERROR (19Hprogram terminated.)
      ENDIF 
      IF (MEM (P + 0) .GE. N) THEN
         GOTO 1020 
      ENDIF 
      Q = P
1010  GOTO 1000 
1020  CONTINUE 
      K = MEM (P + 0) - N
      IF (K .GE. 8) THEN
         MEM (P + 0) = K
         L = P + K
         MEM (L + 0) = N
      ELSE 
         MEM (Q + 1) = MEM (P + 1)
         L = P
      ENDIF 
      DSGET=(L + 2)
      RETURN
      END 
      INTEGER FUNCTION CTOC (FROM, TO, LEN)
      INTEGER LEN
      INTEGER FROM (100), TO (LEN)
      INTEGER I
      I = 1
1000  IF (.NOT.(I .LT. LEN .AND. FROM (I) .NE. -2))GOTO 1020 
      TO (I) = FROM (I)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      TO (I) = -2
      CTOC=(I - 1)
      RETURN
      END 
      INTEGER FUNCTION CUPPER (C)
      INTEGER C
      IF (C .GE. 97 .AND. C .LE. 122) THEN
         CUPPER = C + (65 - 97)
      ELSE 
         CUPPER = C
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION OPEN (NAME, ACCESS)
      INTEGER NAME (100)
      INTEGER ACCESS
      INTEGER I
      INTEGER ASSIGN
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      I = 1
1000  IF (.NOT.(I .LE. 7))GOTO 1020 
      IF (FILENM (1, I) .EQ. -2) THEN
         GOTO 1020 
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      IF (I .GT. 7) THEN
         OPEN=(-3)
         RETURN
      ENDIF 
      OPEN = ASSIGN (NAME, I, ACCESS)
      RETURN
      END 
      INTEGER FUNCTION STCLOS (PAT, J, LASTJ, LASTCL)
      INTEGER PAT (128)
      INTEGER J, LASTJ, LASTCL
      INTEGER ADDSET
      INTEGER JP, JT, JUNK
      JP = J - 1
1000  IF (.NOT.(JP .GE. LASTJ))GOTO 1020 
      JT = JP + 4
      JUNK = ADDSET (PAT (JP), PAT, JT, 128)
1010  JP = JP - 1
      GOTO 1000 
1020  CONTINUE 
      J = J + 4
      STCLOS = LASTJ
      JUNK = ADDSET (42, PAT, LASTJ, 128)
      JUNK = ADDSET (0, PAT, LASTJ, 128)
      JUNK = ADDSET (LASTCL, PAT, LASTJ, 128)
      JUNK = ADDSET (0, PAT, LASTJ, 128)
      RETURN
      END 
      INTEGER FUNCTION GETCCL (ARG, I, PAT, J)
      INTEGER ARG (128), PAT (128)
      INTEGER I, J
      INTEGER JSTART, JUNK
      INTEGER ADDSET
      I = I + 1
      IF (ARG (I) .EQ. 126) THEN
         JUNK = ADDSET (110, PAT, J, 128)
         I = I + 1
      ELSE 
         JUNK = ADDSET (91, PAT, J, 128)
      ENDIF 
      JSTART = J
      JUNK = ADDSET (0, PAT, J, 128)
      CALL FILSET (93, ARG, I, PAT, J, 128)
      PAT (JSTART) = J - JSTART - 1
      IF (ARG (I) .EQ. 93) THEN
         GETCCL = -2
      ELSE 
         GETCCL = -3
      ENDIF 
      RETURN
      END 
      SUBROUTINE SKIPBL(LIN, I)
      INTEGER LIN(100)
      INTEGER I
1000  IF (LIN (I) .EQ. 32 .OR. LIN (I) .EQ. 9) THEN
         I = I + 1
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION EQUAL (STR1, STR2)
      INTEGER STR1(100), STR2(100)
      INTEGER I
      I = 1
1000  IF (.NOT.(STR1 (I) .EQ. STR2 (I)))GOTO 1020 
      IF (STR1 (I) .EQ. -2) THEN
         EQUAL=(1)
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      EQUAL=(0)
      RETURN
      END 
      INTEGER FUNCTION OMATCH (LIN, I, PAT, J)
      INTEGER LIN (133), PAT (128)
      INTEGER I, J
      INTEGER BUMP
      INTEGER LOCATE
      OMATCH = 0
      IF (LIN (I) .EQ. -2) THEN
         RETURN
      ENDIF 
      BUMP = -1
      IF (PAT (J) .EQ. 97) THEN
         IF (LIN (I) .EQ. PAT (J + 1)) THEN
            BUMP = 1
         ENDIF 
      ELSE IF (PAT (J) .EQ. 37) THEN
         IF (I .EQ. 1) THEN
            BUMP = 0
         ENDIF 
      ELSE IF (PAT (J) .EQ. 63) THEN
         IF (LIN (I) .NE. 10) THEN
            BUMP = 1
         ENDIF 
      ELSE IF (PAT (J) .EQ. 36) THEN
         IF (LIN (I) .EQ. 10) THEN
            BUMP = 0
         ENDIF 
      ELSE IF (PAT (J) .EQ. 91) THEN
         IF (LOCATE (LIN (I), PAT, J + 1) .EQ. 1) THEN
            BUMP = 1
         ENDIF 
      ELSE IF (PAT (J) .EQ. 110) THEN
         IF (LIN (I) .NE. 10 .AND. LOCATE (LIN (I), PAT, J + 1) .EQ. 0)
     1      THEN
            BUMP = 1
         ENDIF 
      ELSE 
         CALL ERROR (24Hin omatch: can't happen.)
      ENDIF 
      IF (BUMP .GE. 0) THEN
         I = I + BUMP
         OMATCH = 1
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION PATSIZ (PAT, N)
      INTEGER PAT (128)
      INTEGER N
      IF (PAT (N) .EQ. 97 .OR. PAT (N) .EQ. 123 .OR. PAT (N) .EQ. 125)
     1THEN
         PATSIZ = 2
      ELSE IF (PAT (N) .EQ. 37 .OR. PAT (N) .EQ. 36 .OR. PAT (N) .EQ
     1. 63)THEN
         PATSIZ = 1
      ELSE IF (PAT (N) .EQ. 91 .OR. PAT (N) .EQ. 110) THEN
         PATSIZ = PAT (N + 1) + 2
      ELSE IF (PAT (N) .EQ. 42) THEN
         PATSIZ = 4
      ELSE 
         CALL ERROR (24Hin patsiz: can't happen.)
      ENDIF 
      RETURN
      END 
      SUBROUTINE FOLD (TOKEN)
      INTEGER TOKEN (100)
      INTEGER CLOWER
      INTEGER I
      I = 1
1000  IF (.NOT.(TOKEN (I) .NE. -2))GOTO 1020 
      TOKEN (I) = CLOWER (TOKEN (I))
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      SUBROUTINE DSDUMP (FORM)
      INTEGER FORM
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER P, T, Q
      T = 2
      CALL REMARK (27H** DYNAMIC STORAGE DUMP **.)
      CALL PUTINT (1, 5, 3)
      CALL PUTCH (32, 3)
      CALL PUTINT (2 + 1, 0, 3)
      CALL REMARK (14H words in use.)
      P = MEM (T + 1)
1000  IF (P .NE. 0) THEN
         CALL PUTINT (P, 5, 3)
         CALL PUTCH (32, 3)
         CALL PUTINT (MEM (P + 0), 0, 3)
         CALL REMARK (17H words available.)
         Q = P + MEM (P + 0)
1010     IF (Q .NE. MEM (P + 1) .AND. Q .LT. MEM (1)) THEN
            CALL DSDBIU (Q, FORM)
            GOTO 1010 
         ENDIF 
1020     CONTINUE 
         P = MEM (P + 1)
         GOTO 1000 
      ENDIF 
1030  CONTINUE 
      CALL REMARK (15H** END DUMP **.)
      RETURN
      END 
      INTEGER FUNCTION GETLIN (LINE, INT)
      INTEGER LINE (133)
      INTEGER INT
      INTEGER I
      INTEGER GETCH
      I = 1
1000  IF (.NOT.(I .LT. 133))GOTO 1020 
      IF (GETCH (LINE (I), INT) .EQ. 10) THEN
         LINE (I + 1) = -2
         GETLIN=(I)
         RETURN
      ELSE IF (LINE (I) .EQ. -1) THEN
         LINE (I) = -2
         GETLIN=(-1)
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      LINE (133) = -2
      GETLIN=(133 - 1)
      RETURN
      END 
      INTEGER FUNCTION ASSIGN (NAME, INT, ACCESS)
      INTEGER NAME (100)
      INTEGER INT, ACCESS
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      LOGICAL ERROR
      IF (INT .LT. 1 .OR. INT .GT. 7) THEN
         ASSIGN = -3
      ELSE 
         CALL SCOPY (NAME, 1, FILENM (1, INT), 1)
         ASSIGN = INT
         LASTC (INT) = 0
         CCNT (INT) = 0
         FILACC (INT) = IABS (ACCESS)
         IF (ACCESS .GT. 0) THEN
            CALL OPENIT (NAME, ACCESS, UNIT(INT), ERROR)
         ENDIF 
         IF (ERROR) THEN
            ASSIGN = -3
         ENDIF 
      ENDIF 
      IF (MODE (INT) .EQ. 1) THEN
         CALL RWIND (INT)
      ENDIF 
      RETURN
      END 
      SUBROUTINE FILSET (DELIM, ARRAY, I, SET, J, MAXSET)
      INTEGER I, J, MAXSET
      INTEGER ARRAY (100), DELIM, SET (MAXSET)
      INTEGER ESC
      INTEGER JUNK
      INTEGER ADDSET, INDX
      INTEGER DIGITS(11)
      INTEGER LOWALF(27)
      INTEGER UPALF(27)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/-2/
      DATA LOWALF(1)/97/,LOWALF(2)/98/,LOWALF(3)/99/,LOWALF(4)/100/,LOWA
     *LF(5)/101/,LOWALF(6)/102/,LOWALF(7)/103/,LOWALF(8)/104/,LOWALF(9)/
     *105/,LOWALF(10)/106/,LOWALF(11)/107/,LOWALF(12)/108/,LOWALF(13)/10
     *9/,LOWALF(14)/110/,LOWALF(15)/111/,LOWALF(16)/112/,LOWALF(17)/113/
     *,LOWALF(18)/114/,LOWALF(19)/115/,LOWALF(20)/116/,LOWALF(21)/117/,L
     *OWALF(22)/118/,LOWALF(23)/119/,LOWALF(24)/120/,LOWALF(25)/121/,LOW
     *ALF(26)/122/,LOWALF(27)/-2/
      DATA UPALF(1)/65/,UPALF(2)/66/,UPALF(3)/67/,UPALF(4)/68/,UPALF(5)/
     *69/,UPALF(6)/70/,UPALF(7)/71/,UPALF(8)/72/,UPALF(9)/73/,UPALF(10)/
     *74/,UPALF(11)/75/,UPALF(12)/76/,UPALF(13)/77/,UPALF(14)/78/,UPALF(
     *15)/79/,UPALF(16)/80/,UPALF(17)/81/,UPALF(18)/82/,UPALF(19)/83/,UP
     *ALF(20)/84/,UPALF(21)/85/,UPALF(22)/86/,UPALF(23)/87/,UPALF(24)/88
     */,UPALF(25)/89/,UPALF(26)/90/,UPALF(27)/-2/
1000  IF (.NOT.(ARRAY (I) .NE. DELIM .AND. ARRAY (I) .NE. -2))GOTO 1020 
      IF (ARRAY (I) .EQ. 64) THEN
         JUNK = ADDSET (ESC (ARRAY, I), SET, J, MAXSET)
      ELSE IF (ARRAY (I) .NE. 45) THEN
         JUNK = ADDSET (ARRAY (I), SET, J, MAXSET)
      ELSE IF (J .LE. 1 .OR. ARRAY (I + 1) .EQ. -2) THEN
         JUNK = ADDSET (45, SET, J, MAXSET)
      ELSE IF (INDX (DIGITS, SET (J - 1)) .GT. 0) THEN
         CALL DODASH (DIGITS, ARRAY, I, SET, J, MAXSET)
      ELSE IF (INDX (LOWALF, SET (J - 1)) .GT. 0) THEN
         CALL DODASH (LOWALF, ARRAY, I, SET, J, MAXSET)
      ELSE IF (INDX (UPALF, SET (J - 1)) .GT. 0) THEN
         CALL DODASH (UPALF, ARRAY, I, SET, J, MAXSET)
      ELSE 
         JUNK = ADDSET (45, SET, J, MAXSET)
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      SUBROUTINE ERROR (LINE)
      INTEGER LINE (100)
      CALL REMARK (LINE)
      CALL ENDST
      END 
      INTEGER FUNCTION LOCATE (C, PAT, OFFSET)
      INTEGER C, PAT (128)
      INTEGER OFFSET
      INTEGER I
      I = OFFSET + PAT (OFFSET)
1000  IF (.NOT.(I .GT. OFFSET))GOTO 1020 
      IF (C .EQ. PAT (I)) THEN
         LOCATE=(1)
         RETURN
      ENDIF 
1010  I = I - 1
      GOTO 1000 
1020  CONTINUE 
      LOCATE=(0)
      RETURN
      END 
      INTEGER FUNCTION CLOWER(C)
      INTEGER C
      INTEGER K
      IF (C .GE. 65 .AND. C .LE. 90) THEN
         K = 97 - 65
         CLOWER = C + K
      ELSE 
         CLOWER = C
      ENDIF 
      RETURN
      END 
      SUBROUTINE DSDBIU (B, FORM)
      INTEGER B
      INTEGER FORM
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL /CDSMEM/
      INTEGER L, S, LMAX
      INTEGER BLANKS(11)
      DATA BLANKS(1)/32/,BLANKS(2)/32/,BLANKS(3)/32/,BLANKS(4)/32/,BLANK
     *S(5)/32/,BLANKS(6)/32/,BLANKS(7)/32/,BLANKS(8)/32/,BLANKS(9)/32/,B
     *LANKS(10)/32/,BLANKS(11)/-2/
      CALL PUTINT (B, 5, 3)
      CALL PUTCH (32, 3)
      CALL PUTINT (MEM (B + 0), 0, 3)
      CALL REMARK (14H words in use.)
      L = 0
      S = B + MEM (B + 0)
      IF (FORM .EQ. 48) THEN
         LMAX = 5
      ELSE 
         LMAX = 50
      ENDIF 
      B = B + 2
1000  IF (.NOT.(B .LT. S))GOTO 1020 
      IF (L .EQ. 0) THEN
         CALL PUTLIN (BLANKS, 3)
      ENDIF 
      IF (FORM .EQ. 48) THEN
         CALL PUTINT (MEM (B), 10, 3)
      ELSE IF (FORM .EQ. 97) THEN
         CALL PUTCH (MEM (B), 3)
      ENDIF 
      L = L + 1
      IF (L .GE. LMAX) THEN
         L = 0
         CALL PUTCH (10, 3)
      ENDIF 
1010  B = B + 1
      GOTO 1000 
1020  CONTINUE 
      IF (L .NE. 0) THEN
         CALL PUTCH (10, 3)
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION GETCH (C, INT)
      INTEGER C
      INTEGER INT
      INTEGER N, COUNT
      INTEGER GETR
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      N = LASTC (INT)
      IF (N .EQ. 0 .OR. BUFFER (N, INT) .EQ. 10 .OR. N .GE. 133) THEN
         COUNT = GETR (UNIT (INT), BUFFER (1, INT), 80)
         IF (COUNT .EQ. -1) THEN
            C = -1
            GETCH=(-1)
            RETURN
         ENDIF 
         LASTC (INT) = 0
      ENDIF 
      LASTC (INT) = LASTC (INT) + 1
      CCNT (INT) = CCNT (INT) + 1
      C = BUFFER (LASTC (INT), INT)
      GETCH=(C)
      RETURN
      END 
      SUBROUTINE SCOPY (FROM, I, TO, J)
      INTEGER FROM (100), TO (100)
      INTEGER I, J
      INTEGER K1, K2
      K2 = J
      K1 = I
1000  IF (.NOT.(FROM (K1) .NE. -2))GOTO 1020 
      TO (K2) = FROM (K1)
      K2 = K2 + 1
1010  K1 = K1 + 1
      GOTO 1000 
1020  CONTINUE 
      TO (K2) = -2
      RETURN
      END 
      SUBROUTINE DODASH (VALID, ARRAY, I, SET, J, MAXSET)
      INTEGER I, J, MAXSET
      INTEGER VALID (100), ARRAY (100), SET (MAXSET)
      INTEGER ESC
      INTEGER JUNK, K, LIMIT
      INTEGER ADDSET, INDX
      I = I + 1
      J = J - 1
      LIMIT = INDX (VALID, ESC (ARRAY, I))
      K = INDX (VALID, SET (J))
1000  IF (.NOT.(K .LE. LIMIT))GOTO 1020 
      JUNK = ADDSET (VALID (K), SET, J, MAXSET)
1010  K = K + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      SUBROUTINE ENDST
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      INTEGER INT
      INT = 1
1000  IF (.NOT.(INT .LE. 7))GOTO 1020 
      CALL CLOSE (INT)
1010  INT = INT + 1
      GOTO 1000 
1020  CONTINUE 
      END 
      SUBROUTINE PUTLIN (LINE, INT)
      INTEGER LINE (100)
      INTEGER INT
      INTEGER I
      I = 1
1000  IF (.NOT.(LINE (I) .NE. -2))GOTO 1020 
      CALL PUTCH (LINE (I), INT)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      END 
      SUBROUTINE REMARK (LINE)
      INTEGER LINE (100)
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      INTEGER FUNIT
      DIMENSION ITEMP(80)
      FUNIT = UNIT (3)
      DECODE (80,9000, LINE) ITEMP
      DO 1000 J = 1, 80
         IF (ITEMP(J) .EQ. 46) THEN
            GOTO 1010 
         ENDIF 
1000  CONTINUE 
1010  CONTINUE 
      CALL PUTR (FUNIT, ITEMP, J-1, 0)
9000  FORMAT (80R1)
      END 
      SUBROUTINE PUTINT (N, W, FD)
      INTEGER N, W
      INTEGER FD
      INTEGER CHARS (20)
      INTEGER JUNK
      INTEGER ITOC
      JUNK = ITOC (N, CHARS, 20)
      CALL PUTSTR (CHARS, W, FD)
      END 
      INTEGER FUNCTION GETR (F, BUF, MAXSIZ)
      INTEGER F, MAXSIZ
      INTEGER BUF (100)
      INTEGER I
      COMMON /KEYSTUFF/ KEYRETRN
      SAVE IUNIT, IDCB
      LOGICAL DONE
      DATA IUNIT/-1/
      IF (IUNIT .NE. F) THEN
         IUNIT = F
         CALL SETUNIT (F, IDCB)
      ENDIF 
      CALL GETR1 (IDCB, BUF, I, DONE, KEYRETRN)
      IF (DONE) THEN
         GETR = -1
      ELSE 
         BUF(I+1) = 10
         GETR = I + 1
      ENDIF 
      END 
      INTEGER FUNCTION ADDSET (C, STR, J, MAXSIZ)
      INTEGER J, MAXSIZ
      INTEGER C, STR (MAXSIZ)
      IF (J .GT. MAXSIZ) THEN
         ADDSET = 0
      ELSE 
         STR(J) = C
         J = J + 1
         ADDSET = 1
      ENDIF 
      END 
      INTEGER FUNCTION ESC (ARRAY, I)
      INTEGER ARRAY (100)
      INTEGER I
      IF (ARRAY (I) .NE. 64) THEN
         ESC = ARRAY (I)
      ELSE IF (ARRAY (I+1) .EQ. -2) THEN
         ESC = 64
      ELSE 
         I = I + 1
         IF (ARRAY (I) .EQ. 110 .OR. ARRAY (I) .EQ. 78) THEN
            ESC = 10
         ELSE IF (ARRAY (I) .EQ. 116 .OR. ARRAY (I) .EQ. 84) THEN
            ESC = 9
         ELSE 
            ESC = ARRAY (I)
         ENDIF 
      ENDIF 
      END 
      INTEGER FUNCTION INDX (STR, C)
      INTEGER STR (100), C
      INDX = 1
1000  IF (.NOT.(STR (INDX) .NE. -2))GOTO 1020 
      IF (STR (INDX) .EQ. C) THEN
         RETURN
      ENDIF 
1010  INDX = INDX + 1
      GOTO 1000 
1020  CONTINUE 
      INDX = 0
      END 
      SUBROUTINE CLOSE (INT)
      INTEGER INT
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      IF (FILENM (1, INT) .EQ. -2) THEN
         RETURN
      ENDIF 
      IF (LASTC (INT) .GT. 0 .AND. FILACC (INT) .NE. 1) THEN
         CALL PUTCH (10, INT)
      ENDIF 
      CLOSE (UNIT=UNIT(INT))
      IF (MODE (INT) .EQ. 1) THEN
         CALL RWIND (INT)
      ENDIF 
      FILENM (1, INT) = -2
      END 
      SUBROUTINE PUTSTR (STR, W, FD)
      INTEGER STR (100)
      INTEGER W
      INTEGER FD
      INTEGER LENGTH
      INTEGER I, LEN
      LEN = LENGTH (STR)
      I = LEN + 1
1000  IF (.NOT.(I .LE. W))GOTO 1020 
      CALL PUTCH (32, FD)
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      I = 1
1030  IF (.NOT.(I .LE. LEN))GOTO 1050 
      CALL PUTCH (STR (I), FD)
1040  I = I + 1
      GOTO 1030 
1050  CONTINUE 
      I = (-W) - LEN
1060  IF (.NOT.(I .GT. 0))GOTO 1080 
      CALL PUTCH (32, FD)
1070  I = I - 1
      GOTO 1060 
1080  CONTINUE 
      END 
      INTEGER FUNCTION ITOC (INT, STR, SIZE)
      INTEGER INT, SIZE
      INTEGER STR (100)
      INTEGER MOD
      INTEGER D, I, INTVAL, J, K
      INTEGER DIGITS (11)
      DATA DIGITS (1) /48/, DIGITS (2) /49/, DIGITS (3) /50/, DIGITS (4)
     * /51/, DIGITS (5) /52/, DIGITS (6) /53/, DIGITS (7) /54/, DIGITS (
     *8) /55/, DIGITS (9) /56/, DIGITS (10) /57/, DIGITS (11) /-2/
      INTVAL = IABS (INT)
      STR (1) = -2
      I = 1
1000  CONTINUE 
      I = I + 1
      D = MOD (INTVAL, 10)
      STR (I) = DIGITS (D+1)
      INTVAL = INTVAL / 10
1010  IF (.NOT.(INTVAL .EQ. 0 .OR. I .GE. SIZE))GOTO 1000 
1020  CONTINUE 
      IF (INT .LT. 0 .AND. I .LT. SIZE) THEN
         I = I + 1
         STR (I) = 45
      ENDIF 
      ITOC = I - 1
      J = 1
1030  IF (.NOT.(J .LT. I))GOTO 1050 
      K = STR (I)
      STR (I) = STR (J)
      STR (J) = K
      I = I - 1
1040  J = J + 1
      GOTO 1030 
1050  CONTINUE 
      END 
      INTEGER FUNCTION INMAP (C)
      INTEGER C
      INMAP = ISL (C, -24)
      END 
      SUBROUTINE RWIND (INT)
      INTEGER INT
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      INTEGER FUNIT
      LOGICAL OPENED
      CCNT (INT) = 0
      LASTC (INT) = 0
      FUNIT = UNIT (INT)
      INQUIRE (FUNIT, OPENED=OPENED)
      IF (.NOT. OPENED) THEN
         RETURN
      ENDIF 
      REWIND FUNIT
      END 
      SUBROUTINE PUTCH (C, INT)
      INTEGER C
      INTEGER INT
      INTEGER N
      COMMON /IO/ UNIT (7), LASTC (7), CCNT (7), FILACC (7), MODE (7), F
     *TYPE (7), FILENM (30, 7), BUFFER (133, 7)
      INTEGER UNIT
      INTEGER LASTC
      INTEGER CCNT
      INTEGER FILACC
      INTEGER MODE
      INTEGER FTYPE
      INTEGER FILENM
      INTEGER BUFFER
      IF (INT .LE. 0) THEN
         RETURN
      ENDIF 
      N = LASTC (INT)
      IF (N .GE. 133 .OR. C .EQ. 10) THEN
         CALL PUTR (UNIT (INT), BUFFER (1,INT), N, MODE(INT))
         LASTC (INT) = 0
      ENDIF 
      IF (C .NE. 10) THEN
         LASTC (INT) = LASTC (INT) + 1
         N = LASTC (INT)
         BUFFER (N, INT) = C
      ENDIF 
      CCNT (INT) = CCNT (INT) + 1
      END 
      INTEGER FUNCTION LENGTH (STR)
      INTEGER STR (100)
      LENGTH = 0
1000  IF (.NOT.(STR (LENGTH+1) .NE. -2))GOTO 1020 
1010  LENGTH = LENGTH + 1
      GOTO 1000 
1020  CONTINUE 
      END 
      INTEGER FUNCTION OUTMAP(C)
      INTEGER C
      DATA JUNK/8Z00404040/
      OUTMAP = IOR (ISL (C, 24), JUNK)
      END 
      SUBROUTINE PUTR (F, BUF, N, MODE)
      INTEGER F, N
      INTEGER BUF (100)
      SAVE IUNIT1, IUNIT2, IDCB1, IDCB2
      DATA IUNIT1, IUNIT2/-1, -1/
      IF (N .LE. 0) THEN
         WRITE (F, '(/)')
      ELSE IF (MODE .EQ. 1) THEN
         IF (IUNIT1 .NE. F) THEN
            IUNIT1 = F
            CALL SETUNIT (F, IDCB1)
         ENDIF 
         CALL PUTR1 (IDCB1, BUF, N)
      ELSE 
         IF (IUNIT2 .NE. F) THEN
            IUNIT2 = F
            CALL SETUNIT (F, IDCB2)
         ENDIF 
         CALL PUTR1 (IDCB2, BUF, N)
      ENDIF 
      END 
      SUBROUTINE OPENIT (NAME, ACCESS, UNIT, ERROR)
      INTEGER NAME(40), ACCESS, UNIT
      LOGICAL OPENED, ERROR
      CHARACTER FILENAME*40, TYPE(4)*6, TEMP*40
      DATA TYPE /'INPUT', 'OUTPUT', 'UPDATE', 'OUTPUT'/
      DO 1000 I = 1, 40
         IF (NAME(I) .EQ. -2) THEN
            GOTO 1010 
         ENDIF 
1000  CONTINUE 
1010  CONTINUE 
      WRITE (FILENAME,'(40R1)') (NAME(J), J = 1, I-1)
      INQUIRE (UNIT=UNIT, OPENED=OPENED)
      IF (OPENED) THEN
         CLOSE (UNIT=UNIT)
      ENDIF 
      IF (FILENAME .EQ. 'tty') THEN
         RETURN
      ENDIF 
      TEMP = FILENAME(1:I-1)
      OPEN (UNIT=UNIT, NAME=TEMP, USAGE=TYPE(ACCESS), ERR=1020)
      ERROR = .FALSE.
      RETURN
1020  ERROR = .TRUE.
      END 
