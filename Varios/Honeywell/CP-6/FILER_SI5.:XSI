/*M* FILER_SI5 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* THI=1,PLM=3,IND=3 */
%EJECT;
/*********************************************************************/
/*
***   AM_MOVE_BLK  18 AUG 77  (PRY)  MOVES BLK_SIZE# WORDS FROM
***   BLK_FROM_IX# TO BLK_TO_IX#.
*/
 
AM_MOVE_BLK: PROC( BLK_FROM_IX#, BLK_TO_IX#, BLK_SIZE# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   BLK_FROM_IX#   SBIN WORD ALIGNED; /* IX OF SOURCE BLOCK                 */
DCL   BLK_TO_IX#     SBIN WORD ALIGNED; /* IX OF TARGET BLOCK                 */
DCL   BLK_SIZE#      SBIN WORD ALIGNED; /* SIZE OF BLOCK                      */
 
 
/***************
***   CALCULATE MOVE LOCALS.
*/
   TIX1 = BLK_SIZE#;
   TPTR2$  = PINCRW( DATA_BASE$, BLK_FROM_IX# );
   TPTR1$    = PINCRW( DATA_BASE$, BLK_TO_IX# );
/*
***   AVOID OVERWRITE PROBLEMS: IF TARGET BLOCK MIGHT START
***   WITHIN SOURCE BLOCK, MOVE BLOCK FROM REAR TO FRONT.  OTHERWISE
***   MOVE BLOCK FROM FRONT TO REAR.
*/
   IF BLK_TO_IX# >= BLK_FROM_IX#        /* TARGET MIGHT START WITHIN SOURCE?  */
    THEN IF BLK_TO_IX# > BLK_FROM_IX#   /* YES                                */
       THEN DO;
         DO WHILE (TIX1 >= 1);
            TIX1                   = TIX1 - 1;
            TPTR1$ -> WORD#(TIX1) = TPTR2$ -> WORD#(TIX1);
            END;
         END;
       ELSE ;                           /* DO NOTHING IF TARGET = SOURCE      */
    ELSE DO;                            /* TARGET BEFORE SOURCE               */
      DO WHILE(TIX1 > 0);               /* Until everything moved             */
         IF TIX1 > 32767
          THEN DO;                      /* Divide into char string moves      */
            TEMP1 = 32767 * 4;          /* Max # bytes in one move            */
            TIX1 = TIX1 - 32767;
            END;
          ELSE DO;                      /* Last char string move              */
            TEMP1 = TIX1 * 4;
            TIX1 = 0;
            END;
         TPTR1$->CHARS = TPTR2$->CHARS;
         TPTR1$ = PINCRC( TPTR1$, TEMP1 );
         TPTR2$ = PINCRC( TPTR2$, TEMP1 );
         END;
      END;
 
   RETURN;
 
END AM_MOVE_BLK;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/**********************************************************************/
/*
***   EV_MODIFY_VAL_WIDTH   30 AUG 77   (PRY)   ADJUSTS THE LAST
***   VALUE ACCORDING TO SPECIFICATIONS.
*/
 
EV_MODIFY_VAL_WIDTH: PROC( VAL_STRT# );
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
 
/***   INCREMENT THE CURRENT CHARACTER INDEX   ***/
DCL   UT_INC_CHARX           ENTRY;
 
/***   IGNORE BLANKS STARTING WITH THE CURRENT CHARACTER   ***/
DCL   UT_IGNORE_BLANKS       ENTRY;
 
 
/***   MOVE BITS IN A BLOCK TO THE LEFT   ***/
DCL   UT_MOVE_BITS_RWD       ENTRY(3);
 
/***   MOVE BITS IN A BLOCK TO THE RIGHT AND ZERO FILL   ***/
DCL   UT_MOVE_BITS_FWD       ENTRY(3);
 
 
/***   INCREASE WIDTH OF CURRENT VALUE   ***/
DCL   EV_INCREASE_WIDTH      ENTRY(1);
 
 
/***   CONVERT OFFSET SPECIFICATION TO BIT OFFSET   ***/
DCL   EV_GET_OFFSET          ENTRY(5);
 
 
/***************
***   PARAMETERS:
*/
DCL   VAL_STRT#         SBIN WORD ALIGNED;
                              /* WIDTH OF VALUE BEFORE CURRENT VALUE ADDED    */
 
/***************
***   LOCALS:
*/
DCL   VAL_STRT  SBIN WORD ALIGNED AUTO; /* LOCALIZES VAL_STRT#                */
DCL   VAL_WIDTH         SBIN WORD ALIGNED   AUTO;
                                        /* USED TO CALC WIDTH OF LAST VALUE   */
DCL   SIZE      SBIN WORD ALIGNED AUTO; /* MODIFY SIZE                        */
DCL   SIZE_DIF          SBIN WORD ALIGNED   AUTO;
                         /* DIFFERENCE BETWEEN VAL_WIDTH AND SPECIFIED SIZE   */
DCL   TO$               PTR       ALIGNED   AUTO;
                                        /* POINTER TO TARGET FOR BIT MOVE     */
DCL   FROM$             PTR       ALIGNED   AUTO;
                                        /* POINTER TO SOURCE FOR BIT MOVE     */
DCL   GOT_OFS   SBIN WORD ALIGNED AUTO; /* GOT OFFSET/SIZE FLAG               */
DCL   RES       SBIN WORD ALIGNED AUTO; /* INITIAL RESOLUTION PARM            */
DCL   FRES      SBIN WORD ALIGNED AUTO; /* FINAL RESOLUTION                   */
DCL  REPEAT_VAL SBIN WORD ALIGNED AUTO; /* TYPE OF VALUE MODIFICATION         */
 
/***************
***   SKIP OVER '(' AND GET VALUE SIZE.
*/
   IF C = CT_LBRACE
    THEN REPEAT_VAL = 1;
    ELSE REPEAT_VAL = 0;
   CALL UT_INC_CHARX;
   CALL UT_IGNORE_BLANKS;
   IF CHARX > CHARX_MAX                 /* POSSIBLE FOR SIZE?                 */
    THEN DO;                            /* NO                                 */
      VAL_FAULT = 21; /*E* 21V EV_MODIFY_VAL_WIDTH: SIZE IS MISSING   */
      RETURN;
      END;
 
/*
***   GET SIZE.
*/
   RES = 1;                             /* DEFAULT RESOLUTION IS BYTE         */
   CALL EV_GET_OFFSET( RES, 1, FRES, SIZE, GOT_OFS );
   IF VAL_FAULT ~= 0 THEN RETURN;       /* RETURN IF PROBLEMS                 */
   IF GOT_OFS = 0                       /* GET A SIZE?                        */
    THEN DO;                            /* NO                                 */
      VAL_FAULT = 21;
      RETURN;
      END;
   CALL UT_IGNORE_BLANKS;
/**
***   MAKE SURE ')' FOLLOWS.
**/
   IF CHARX > CHARX_MAX
     OR (REPEAT_VAL = 0 AND C ~= CT_RPAREN)
     OR (REPEAT_VAL = 1 AND C ~= CT_RBRACE)
    THEN DO;
      VAL_FAULT = 45;
         /*E* 45V EV_MODIFY_VAL_WIDTH: CLOSING ) IS MISSING */
      RETURN;
      END;
   CALL UT_INC_CHARX;                   /* SKIP OVER >                        */
/*
***   SEE IF LAST VALUE IS TO BE TRUNCATED OR FILLED.
*/
   VAL_STRT  = VAL_STRT#;               /* LOCALIZE PARM                      */
   VAL_WIDTH = DWIDTH - VAL_STRT;       /* CALC WIDTH OF LAST VALUE 'CAT'D    */
   SIZE_DIF  = SIZE -VAL_WIDTH;
                         /* CALC NUMBER OF EXTRA BITS NEEDED DUE TO MODIFIER  */
   IF SIZE_DIF <= 0                     /* CHECK IF MORE SPACE IS NEEDED      */
    THEN DO;                            /* NO                                 */
      TO$    = PINCRB( DESC$ -> BUF.BLK$, VAL_STRT );
                                        /* POINT TO BEGINNING OF LAST VALUE   */
      FROM$  = PINCRB( TO$, -SIZE_DIF );
                                        /* POINT TO BEGINNING OF SOURCE BITS  */
      CALL UT_MOVE_BITS_FWD( FROM$, TO$, SIZE );
                                   /* TRUNCATE THE LAST VALUE CONCATENATED    */
      DWIDTH             = DWIDTH + SIZE_DIF;
                                        /* CALC NEW WIDTH OF CURRENT VALUE    */
      DESC$ -> BUF.WIDTH = DWIDTH;      /* SET WIDTH IN DESCRIPTOR            */
      END;
    ELSE DO;                  /* EXTEND LAST VALUE TO RIGHT WITH ZERO BITS    */
      CALL EV_INCREASE_WIDTH( SIZE_DIF ); /* EXTEND VALUE                     */
      IF VAL_FAULT ~= 0 THEN RETURN;    /* RETURN IF PROBLEMS                 */
      FROM$ = PINCRB( DESC$ -> BUF.BLK$, VAL_STRT );
                                        /* POINT TO SOURCE BIT STRING         */
      IF REPEAT_VAL = 0
       THEN DO;                         /* RIGHT JUSTIFY VALUE IN FIELD       */
         CALL UT_MOVE_BITS_RWD( FROM$, SIZE_DIF, VAL_WIDTH );
                                        /* MAKE ROOM FOR FILLER BITS          */
         END;
       ELSE DO;                         /* REPLICATE VALUE IN FIELD           */
         TO$ = PINCRB( FROM$, VAL_WIDTH ); /* POINT TO TARGET AREA            */
         IF VAL_WIDTH <= 0
          THEN DO;                      /* USE ZERO                           */
            VAL_WIDTH = 36;
            REPEAT_VAL = 0;
            FROM$ = ADDR(REPEAT_VAL);
            END;
         DO WHILE( SIZE_DIF > 0 );
            IF SIZE_DIF > VAL_WIDTH
             THEN TEMP1 = VAL_WIDTH;    /* ROOM FOR ENTIRE VALUE              */
             ELSE TEMP1 = SIZE_DIF;     /* ONLY ROOM FOR INITIAL SEGMENT      */
            TO$->BITS = FROM$->BITS;
            TO$ = PINCRB( TO$, TEMP1 ); /* POINT TO NEXT REPLICATION          */
            SIZE_DIF = SIZE_DIF - TEMP1;
            END;
         END;
      END;
 
   RETURN;
 
END EV_MODIFY_VAL_WIDTH;
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/************************************************************************/
/**
***   UT_NEW_SIZE   30 SEP 77   (PRY)   MAKE BUFFER HAVE NEW SIZE.
**/
 
UT_NEW_SIZE: PROC( BUF$#, NEW_SIZE# ) NOAUTO;
 
%INCLUDE FILER_II5;
 
/***   EXPAND A BLOCK   ***/
DCL   AM_EXPAND_BLK          ENTRY(2);
 
/***   CONTRACT A BLOCK   ***/
DCL   AM_CONTRACT_BLK        ENTRY(2);
 
/********************
***   PARAMETERS:
**/
DCL   BUF$#             PTR       ALIGNED;
                              /* POINTER TO DESCRIPTOR OF BUFFER TO MODIFY    */
DCL   NEW_SIZE#      SBIN WORD ALIGNED; /* NEW SIZE IN BITS                   */
 
/********************
***   LOCALS:
**/
DCL   BUF$            PTR ALIGNED AUTO; /* LOCAL BUF$#                        */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* BLOCK INDEX                        */
DCL   WSIZE     SBIN WORD ALIGNED AUTO; /* SIZE IN WORDS                      */
 
/********************
***   COMPARE DESIRED SIZE OF BUFFER TO CURRENT SIZE; EITHER
***   EXPAND OR CONTRACT IT.
**/
   WSIZE  = (NEW_SIZE#+35) / 36 + 3;
                                        /* CALC DESIRED BUFFER SIZE IN WORDS  */
   BUF$   = BUF$#;                      /* LOCALIZE POINTER                   */
   BLK_IX = BUF$ -> BUF.IX;             /* GET IX OF BUFFER BLOCK             */
   TPTR1$ = PINCRW( DATA_BASE$, BLK_IX ); /* POINT TO THE BLOCK               */
   TEMP1  = TPTR1$ -> BLK.SIZE;         /* GET ITS SIZE                       */
   IF WSIZE > TEMP1                     /* GREATER?                           */
    THEN CALL AM_EXPAND_BLK( BLK_IX, WSIZE );
                                        /* YES: EXPAND BLOCK                  */
    ELSE IF WSIZE < TEMP1
       THEN CALL AM_CONTRACT_BLK( BLK_IX, WSIZE );
                                        /* NO: CONTRACT BLOCK                 */
   IF VAL_FAULT ~=0 THEN RETURN;        /* RETURN IF ERRORS                   */
/*
***   DO BOOKKEEPING; SAVE NEW SIZE AND NUMBER OF WORDS UNUSED.
*/
   BUF$ -> BUF.WIDTH = NEW_SIZE#;       /* SET NEW SIZE                       */
   TPTR1$ = PINCRW( DATA_BASE$, BLK_IX ); /* POINT TO BLOCK'S HEADER          */
   TEMP1  = TPTR1$ -> BLK.SIZE;         /* GET THE BLOCK'S SIZE               */
   TPTR1$ = PINCRW( TPTR1$, TEMP1-2 );
                                        /* POINT TO THE BLOCK'S FOOTER        */
   TPTR1$ -> BLK_FTR.NUNUSED = TEMP1  - WSIZE;
                                        /* SET NUMBER OF WORDS UNUSED         */
 
   RETURN;
 
END UT_NEW_SIZE;
/************************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   EV_NEW_VALUE_DESCS  23 AUG 77  (PRY)  CREATES NBR_DESC# NEW
***   VALUE DESCRIPTORS FOLLOWING THOSE ALREADY CREATED PROVIDED
***   ENOUGH UNUSED SPACE IS AVAILABLE.  VAL_DESC# IS RETURNED AS
***   THE IX OF THE LAST NEW VALUE DESCRIPTOR CREATED.
*/
 
EV_NEW_VALUE_DESCS: PROC( NBR_DESCS#, VAL_DESC# );
%INCLUDE FILER_II5;
 
/***   ALLOCATE A NEW BLOCK OF BLOCK SPACE   ***/
DCL   AM_ALLOC_NEW_BLK       ENTRY(2);
 
 
/***   MOVE A BLOCK   ***/
DCL   AM_MOVE_BLK            ENTRY(3);
 
/***   INDICATE THAT BLOCKS HAVE BEEN MOVED   ***/
DCL   UT_INDICATE_COMPACTION ENTRY(2);
 
 
/***************
***   PARAMETERS:
*/
DCL   NBR_DESCS#        SBIN WORD ALIGNED;
                                        /* THE NUMBER OF DESCRIPTORS DESIRED  */
DCL   VAL_DESC#         SBIN WORD ALIGNED;
                                        /* THE IX OF THE FIRST NEW DESCRIPTOR */
 
/***************
***   LOCALS:
*/
DCL   NBR_DESCS SBIN WORD ALIGNED AUTO; /* LOCALIZES NBR_DESCS#               */
DCL   NEW_END_VAL_DESC_IX SBIN WORD ALIGNED AUTO;
                         /* USED TO CALC THE NEW VALUE OF END_VAL_DESC_IX     */
DCL   MOV_AMT           SBIN WORD ALIGNED   AUTO;
                         /* THE NUMBER OF WORDS OF BUFFER SPACE WHICH MUST BE */
                         /* MOVED TO MAKE ROOM FOR THE NEW VALUE DESCRIPTORS  */
DCL   NEW_END_BLK_IX    SBIN WORD ALIGNED   AUTO;
                              /* USED TO CALC THE NEW VALUE OF END_BLK_IX     */
DCL   BLK_IX    SBIN WORD ALIGNED AUTO; /* SAVES A BLOCK IX                   */
DCL   BLK_PTR$        PTR ALIGNED AUTO; /* POINTS TO A BLOCK                  */
DCL   BLK_ID    SBIN WORD ALIGNED AUTO; /* SAVES A BLOCK ID                   */
DCL LOCAL_TEMP1 SBIN WORD ALIGNED AUTO; /* USED TO CALC PASSED PARAMETERS     */
DCL LOCAL_TEMP2 SBIN WORD ALIGNED AUTO; /* USED TO CALC PASSED PARAMETERS     */
 
/***************
*/
   NBR_DESCS           = NBR_DESCS#;
   NEW_END_VAL_DESC_IX = END_VAL_DESC_IX + (BUF_DESC_SIZE * NBR_DESCS);
                                        /* CALC IX OF LAST NEW DESCRIPTOR     */
   MOV_AMT             = NEW_END_VAL_DESC_IX + BUF_DESC_SIZE
     - STRT_BLK_IX;
                    /* CALC OVERHANG OF LAST NEW DESCRIPTOR INTO BLOCK SPACE  */
/*
***   IF THERE IS ANY OVERHANG, WE'LL HAVE TO MOVE THE BLOCK SPACE
***   TO MAKE ROOM FOR THE NEW DESCRIPTORS.
*/
   IF MOV_AMT > 0                       /* ANY OVERHANG?                      */
    THEN DO;
         /*
         ***   IF BLOCK SPACE WOULD BE MOVED INTO THE TWILIGHT ZONE,
         ***   WE HAVE TO GET A SPARE AREA AT THE END OF THE BLOCK SPACE
         ***   TO ENSURE NO ILLEGAL STORES ARE ATTEMPTED.
         */
      MOV_AMT         = ( (MOV_AMT + 1) / 2) * 2;
                                   /* MOVE BLOCK SPACE BY DOUBLEWORDS OLNY    */
      NEW_END_BLK_IX = END_BLK_IX + MOV_AMT;
                                        /* CALC NEW END_BLK_IX                */
      IF NEW_END_BLK_IX > LAST_FREE_IX
                                        /* OVERHANG INTO TWILIGHT ZONE?       */
       THEN DO;                         /* YES                                */
         CALL AM_ALLOC_NEW_BLK( MOV_AMT, BLK_IX );
                         /* USE BLOCK ALLOCATION LOGIC TO CREATE AN UNUSED    */
                                        /* AREA AT THE REAR OF BLOCK SPACE    */
         IF VAL_FAULT ~= 0 THEN RETURN; /* RETURN IF PROBLEMS                 */
         END_BLK_IX      = BLK_IX;      /* CREATE A NEW END BLOCK             */
         BLK_PTR$        = PINCRW( DATA_BASE$, END_BLK_IX );
                                        /* POINT TO THE NEW END BLOCK         */
         BLK_PTR$ -> BLK = END_BLK;     /* SET IT UP                          */
         END;
         /*
         ***   HAVE SUFFICIENT ROOM.
         */
      LOCAL_TEMP1 = STRT_BLK_IX + MOV_AMT; /* CALC NEW START IX               */
      LOCAL_TEMP2 = END_BLK_IX - STRT_BLK_IX + 1; /* CALC SIZE OF BLOCK SPACE */
      CALL AM_MOVE_BLK( STRT_BLK_IX, LOCAL_TEMP1, LOCAL_TEMP2 );
      STRT_BLK_IX = LOCAL_TEMP1;
                                        /* REFLECT MOVE                       */
      LOWEST_DEALLOC_IX = LOWEST_DEALLOC_IX + MOV_AMT;
      CALL UT_INDICATE_COMPACTION( STRT_BLK_IX, NEW_END_BLK_IX );
                                   /* INDICATE THAT ALL BLOCKS WERE MOVED     */
      END_BLK_IX  = NEW_END_BLK_IX;     /* SET NEW END BLK IX                 */
      END;
/*
***   THERE IS SUFFICIENT SPACE AFTER THE LAST VALUE DESCRIPTOR AND
***   BEFORE THE FIRST BLOCK TO CREATE NEW VALUE DESCRIPTORS.
*/
   TEMP1           = (END_VAL_DESC_IX - STRT_BUF_DESC_IX)
     / BUF_DESC_SIZE;
               /* CALC THE ID NUMBER OF THE LAST OF THE CURRENT DESCRIPTORS   */
   VAL_DESC#     = NEW_END_VAL_DESC_IX; /* RETURN IX                          */
/*
***   SET UP THE NEW DESCRIPTORS; MARK THEM UNUSED AND
***   SET THE IDS.
*/
   DO WHILE (END_VAL_DESC_IX < NEW_END_VAL_DESC_IX);
      END_VAL_DESC_IX    = END_VAL_DESC_IX + BUF_DESC_SIZE;
                                        /* IX NEXT DESC                       */
      TPTR1$             = PINCRW( DATA_BASE$, END_VAL_DESC_IX );
                                   /* POINT TO THE NEXT DESCRIPTOR TO SET UP  */
      TEMP1              = TEMP1 + 1;   /* INCREMENT ID NUMBER                */
      TPTR1$ -> BUF.ID   = TEMP1;       /* SET ID NUMBER                      */
      TPTR1$ -> BUF.TYPE = BT_UNUSED;   /* BUFFER TYPE IS UNUSED              */
      TPTR1$ -> BUF.LOCK = 0;           /* BUFFER IS UNLOCKED                 */
      END;
   VAL_FAULT = 0;                       /* NO PROBLEMS                        */
 
   RETURN;
 
END EV_NEW_VALUE_DESCS;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/**********************************************************************/
/*
***   UT_ONE_WORD_VALUE   24 AUG 77   (PRY)   CONVERTS BLOCKED VALUE
***   INTO A SINGLE WORD VALUE.
*/
 
 
UT_ONE_WORD_VALUE: PROC( VAL_SIZE#, BLK_IX#, VALUE# ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   VAL_SIZE#      SBIN WORD ALIGNED; /* WIDTH (IN BITS) OF VALUE           */
DCL   BLK_IX#           SBIN WORD ALIGNED;
                                        /* BLOCK IN WHICH THE VALUE IS STORED */
DCL   VALUE#         SBIN WORD ALIGNED; /* RETURNED VALUE                     */
 
/***************
***   LOCALS:
*/
DCL   VAL_SIZE  SBIN WORD ALIGNED AUTO; /* LOCALIZES VAL_SIZE#                */
DCL   FROM$           PTR ALIGNED AUTO; /* SOURCE BIT POINTER                 */
DCL   TO$             PTR ALIGNED AUTO; /* TARGET BIT POINTER                 */
 
/***************
***   VALUE MUST CONTAIN BETWEEN 1 AND 36 BITS.
*/
   VAL_SIZE = VAL_SIZE#;                /* LOCALIZE PARM                      */
   IF VAL_SIZE < 1
    THEN VAL_FAULT = 8;
                              /*E* 8V UT_ONE_WORD_VALUE: VALUE CONTAINS       */
                              /*E* LESS THAN 1 OR GREATER THAN 36 BITS        */
    ELSE IF VAL_SIZE > 36               /* CHECK IF TRUNCATION WILL LOSE BITS */
       THEN DO;                         /* YES                                */
         TPTR1$ = PINCRW( DATA_BASE$, BLK_IX#+1 );
                                        /* POINT TO FIRST DATA WORD           */
         TEMP1  = VAL_SIZE - 36;
                                        /* CALC IX OF LAST BIT TO TRUNCATE    */
         IF TPTR1$ -> BITS              /* SET?                               */
          THEN DO;                      /* YES: ERROR                         */
            VAL_FAULT = 8;
            RETURN;
            END;
         FROM$ = PINCRB( TPTR1$, TEMP1 );
                                        /* POINT TO FIRST BIT TO MOVE         */
         TO$   = ADDR( VALUE# );        /* POINT TO TARGET WORD               */
         TEMP1 = 36;                    /* MOVE A WORD OF BITS                */
         TO$ -> BITS = FROM$ -> BITS;
         END;
       ELSE IF VAL_SIZE = 36            /* RIGHT JUSTIFY VALUE                */
          THEN DO;
            VALUE# = DATA_BASE$ -> WORD#(BLK_IX#+1);
                                        /* GET VALUE                          */
            END;
                                   /* ONLY NEED TO ADJUST IF NOT FULL WORD    */
          ELSE DO;
            VALUE# = 0;
            FROM$ = PINCRW( DATA_BASE$, BLK_IX#+1 ); /* POINT TO SOURCE BITS  */
            TO$    = PINCRB( ADDR(VALUE#), 36-VAL_SIZE );
            TEMP1 = VAL_SIZE;
            TO$ -> BITS = FROM$ -> BITS;
            END;
 
   RETURN;
 
END UT_ONE_WORD_VALUE;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_OUTPUT_CHAR   14 SEP 77   (PRY)   DEPOSITS CHARACTERS INTO
***   THE OUTPUT BUFFER AND PRINTS IT WHEN NECESSARY.
**/
 
UT_OUTPUT_CHAR: PROC( OUT_CHAR# ) NOAUTO;
%INCLUDE FILER_II4;
%INCLUDE FILER_II5;
/***   FLUSH THE OUTPUT BUFFER   ***/
DCL   UT_FLUSH_BUF                ENTRY;
 
/********************
***   PARAMETERS:
**/
DCL   OUT_CHAR#      SBIN WORD ALIGNED; /* CHARACTER TO OUTPUT                */
 
 
/********************
***   IF OUTPUT BUFFER IS FULL, FLUSH IT.
**/
   IF BRK_FLAG ~= 0 THEN RETURN;        /* DON'T OUTPUT WHILE BREAK PENDING   */
   IF OUT_CHARX >= LINE_WID-2           /* FULL?                              */
    THEN DO;                  /* YES: INDICATE CONTINUATION AND FLUSH BUFFER  */
      OUT_BUF$ -> UBIN9#(OUT_CHARX) = CT_AMPERSAND;
      OUT_CHARX                     = OUT_CHARX + 1;
                                   /* INDICATE CONTINUATION WITH AMPERSAND    */
      CALL UT_FLUSH_BUF;                /* FLUSH THE OUTPUT BUFFER            */
      END;
 
   OUT_BUF$ -> UBIN9#(OUT_CHARX) = OUT_CHAR#; /* PUT CHAR IN BUFFER           */
   OUT_CHARX           = OUT_CHARX + 1; /* INC CHAR INDEX                     */
 
   RETURN;
 
END UT_OUTPUT_CHAR;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_OUTPUT_CHARS  14 SEP 77   (PRY)   DEPOSITS CHARACTERS INTO
***   THE OUTPUT BUFFER AND PRINTS IT WHEN NECESSARY.
**/
 
UT_OUTPUT_CHARS: PROC( CHARS#, NBR_CHARS# ) NOAUTO;
%INCLUDE FILER_II4;
%INCLUDE FILER_II5;
/*** OUTPUT A SINGLE CHARACTER ***/
DCL   UT_OUTPUT_CHAR              ENTRY(1);
/*** Flush the output buffer ***/
DCL UT_FLUSH_BUF ENTRY;
 
/********************
***   PARAMETERS:
**/
DCL   CHARS#            CHAR(1)   UNAL; /* CHARACTERS TO OUTPUT               */
DCL   NBR_CHARS#     SBIN WORD ALIGNED; /* NUMBER OF CHARS                    */
 
/********************
***   LOCALS:
**/
DCL   PTR$            PTR ALIGNED AUTO; /* POINTER TO STRING                  */
DCL   NBR_CHARS SBIN WORD ALIGNED AUTO; /* LOCALIZES NBR_CHARS#               */
DCL  CHAR_COUNT SBIN WORD ALIGNED AUTO; /* COUNTS CHARS OUTPUT                */
DCL   OUT_CHAR  SBIN WORD ALIGNED AUTO; /* NEXT CHAR TO OUTPUTT               */
 
/********************
***   LOCALIZE PARAMETERS; OUTPUT CHARACTERS.
**/
   PTR$      = ADDR(CHARS#);            /* POINT TO CHARS TO OUTPUT           */
   NBR_CHARS = NBR_CHARS#;
   DO WHILE(NBR_CHARS > 0);             /* While more to move                 */
      IF OUT_CHARX >= LINE_WID-2        /* FULL?                              */
       THEN DO;               /* YES: INDICATE CONTINUATION AND FLUSH BUFFER  */
         OUT_BUF$ -> UBIN9#(OUT_CHARX) = CT_AMPERSAND;
         OUT_CHARX                     = OUT_CHARX + 1;
                                   /* INDICATE CONTINUATION WITH AMPERSAND    */
         CALL UT_FLUSH_BUF;             /* FLUSH THE OUTPUT BUFFER            */
         IF BRK_FLAG ~= 0 THEN RETURN;  /* Don't output while break pending   */
         END;
      TEMP1 = LINE_WID - 2 - OUT_CHARX; /* # chars remaining in buf           */
      IF TEMP1 > NBR_CHARS THEN TEMP1 = NBR_CHARS;
      TPTR1$ = PINCRC( OUT_BUF$, OUT_CHARX );
      TPTR1$->CHARS = PTR$->CHARS;
      OUT_CHARX = OUT_CHARX + TEMP1;    /* Get ready to write next segment    */
      NBR_CHARS = NBR_CHARS - TEMP1;
      PTR$ = PINCRC( PTR$, TEMP1 );
      END;
 
 
   RETURN;
 
END UT_OUTPUT_CHARS;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/********************************************************************/
/**
***   UT_PRINT_SIZE   7 OCT 77   (PRY)   PRINT SIZE IN FILER FORMAT.
**/
 
UT_PRINT_SIZE: PROC( SIZE# ) NOAUTO;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
/***   OUTPUT A SINGLE CHARACTER   ***/
DCL   UT_OUTPUT_CHAR              ENTRY(1);
 
/***   DISPLAY A VALUE   ***/
DCL   UT_DISPLAY                  ENTRY(3);
 
/********************
***   PARAMETERS:
**/
DCL   SIZE#          SBIN WORD ALIGNED; /* SIZE IN BITS                       */
 
/********************
***   LOCALS:
**/
DCL   NBR_UNITS         SBIN WORD ALIGNED   AUTO;
                                        /* NUMBER OF UNITS OF NEXT RESOLUTION */
DCL   NBR_UNITS$      PTR ALIGNED AUTO; /* NUMBER OF UNITS POINTER            */
DCL   RES       SBIN WORD ALIGNED AUTO; /* RESOLUTION                         */
DCL   SIZE      SBIN WORD ALIGNED AUTO; /* LOCAL SIZE#                        */
 
/********************
***   LOCALIZE PARAMETER; PRINT INITIALIRESOLUTION INDICATOR.
**/
   SIZE = SIZE#;
   IF SIZE >= 36                        /* WORD?                              */
    THEN DO;                            /* YES                                */
      CALL UT_OUTPUT_CHAR( CT_W );
      RES = 2;
      END;
    ELSE DO;
      IF SIZE >=9                       /* CHAR?                              */
       THEN DO;                         /* YES                                */
         CALL UT_OUTPUT_CHAR( CT_C );
         RES = 1;
         END;
       ELSE DO;
         IF SIZE > 0                    /* BIT?                               */
          THEN DO;                      /* YES                                */
            CALL UT_OUTPUT_CHAR( CT_B );
            RES = 0;
            END;
          ELSE DO;                      /* NOTHING                            */
            CALL UT_OUTPUT_CHAR( CT_0 );
            RETURN;
            END;
         END;
      END;
 
/********************
***   CONVERT TO NUMERIC UNITS.
**/
   NBR_UNITS$ = ADDR( NBR_UNITS );
                                        /* POINT TO UNITS FOR DISPLAY CALL    */
   DO WHILE (RES >= 0);
      NBR_UNITS = SIZE / RES_WIDTH(RES); /* CALC NUMBER OF UNITS              */
      SIZE      = SIZE - NBR_UNITS * RES_WIDTH(RES);
                                        /* CALC LEFTOVER                      */
      IF NBR_UNITS >= 1                 /* ANYTHING TO PRINT?                 */
       THEN CALL UT_DISPLAY( NBR_UNITS$, 36, -DT_DECIMAL );
                                        /* YES                                */
      IF SIZE > 0 THEN CALL UT_OUTPUT_CHAR( CT_COMMA );
                                        /* SEPARATE ADJACENT TERMS            */
      RES = RES - 1;
      END;
 
   RETURN;
 
END UT_PRINT_SIZE;
/********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/**********************************************************************/
/*
***   UT_PSBL_ERR   4 SEP 77   (PRY)   SAVES POSSIBLE ERROR CODE
***   AND POSITION.
*/
 
UT_PSBL_ERR: PROC( CODE# );
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   CODE#          SBIN WORD ALIGNED; /* ERROR CODE                         */
 
/***************
***   INCREASE ERROR CODE INDICES;  SAVE ERROR AND POSITION.
*/
   NBR_PSBL_ERRS = NBR_PSBL_ERRS + 1;
   PSBL_ERR_IX   = PSBL_ERR_IX + 1;
   IF PSBL_ERR_IX > MAX_PSBL_ERR_IX     /* ADJUST INDEX                       */
    THEN PSBL_ERR_IX = 0;
   PSBL_ERRS.CHARX(PSBL_ERR_IX) = CHARX; /* SAVE ERROR POSITION               */
   PSBL_ERRS.CODE(PSBL_ERR_IX) = CODE#; /* SAVE ERROR CODE                    */
   PSBL_ERRS.BID(PSBL_ERR_IX)      = STRING$ -> BUF.ID;
                                        /* SAVE ID OF BUFFER                  */
   PSBL_ERRS.CR_CHARX(PSBL_ERR_IX) = CR_CHARX;
   PSBL_ERRS.CR_COUNT(PSBL_ERR_IX) = CR_COUNT;
 
   RETURN;
 
 
END UT_PSBL_ERR;
 
/**********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   UT_READ_BUF    13 SEP 77   (PRY)   READ A SPECIFIED NUMBER
***   OF CHARACTERS INTO THE SPECIFIED BUFFER AT THE SPECIFIED INDEX.
***   RETURN THE NUMBER OF CHARACTERS READ.
**/
 
UT_READ_BUF: PROC( BUF$#, SIZE#, LEN#, READ_LOC# ) NOAUTO;
 
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE B$JIT;
%INCLUDE CP_6;
   %F$DCB(DCBN=F$DCB);
 
/********************
***   COMMAND INPUT DCBS.
**/
DCL      M$SI     DCB;
DCL      M$FI     DCB;
DCL B$JIT$ PTR SYMREF;
 
/********************
***   INPUT FPT.
**/
%FPT_READ (  FPTN=RD_SI_FPT, DCB=M$SI, STCLASS=STATIC, WAIT=YES );
%FPT_READ (  FPTN=RD_FI_FPT, DCB=M$FI, STCLASS=STATIC, WAIT=YES );
/********************
***   CLOSE FPT.
**/
%FPT_CLOSE (  FPTN=CLS_FI_FPT, DCB=M$FI, STCLASS=STATIC, DISP= SAVE );
 
/********************
***   STATIC:
**/
DCL   DCB$         PTR       ALIGNED   STATIC;
                                        /* POINTER TO COMMAND INPUT DCB       */
/********************
***   PARAMETERS:
**/
DCL   BUF$#             PTR       ALIGNED;
                                        /* POINTER TO COMMAND BUFFER          */
DCL   LEN#              SBIN WORD ALIGNED;
                                        /* RETURNED LENGTH OF COMMAND SEGMENT */
DCL   SIZE#          SBIN WORD ALIGNED; /* NUMBER OF CHARS TO READ            */
DCL   READ_LOC#      SBIN WORD ALIGNED; /* WHERE TO READ FROM                 */
 
/********************
***   SET UP READ FPT.
**/
   TPTR1$                 = BUF$#;
                                        /* POINT TO BEGINNING OF BUFFER       */
   IF READ_LOC# = 1                     /* DETERMINE PROPER FPT TO SET UP     */
    THEN DO;                            /* IT'S THE FILE DCB                  */
      RD_FI_FPT.BUF_.BOUND = SIZE# - 1;
      RD_FI_FPT.BUF_.BUF$ = TPTR1$;
      CALL M$READ( RD_FI_FPT ) ALTRET( UT_READ_BUF_ALTRET );
      TEMP1                  = DCBNUM( M$FI );
      END;
    ELSE DO;
      RD_SI_FPT.BUF_.BOUND = SIZE# - 1;
      RD_SI_FPT.BUF_.BUF$ = TPTR1$;
      CALL M$READ( RD_SI_FPT ) ALTRET( UT_READ_BUF_ALTRET );
      TEMP1                  = DCBNUM( M$SI );
      END;
/********************
***   READ DONE.
**/
   IF (B$JIT$->B$JIT.MODE = %M_BATCH#
     OR DCBADDR(DCBNUM(M$SI))->F$DCB.DDEV.XEQ#)
     AND TEMP1 = DCBNUM(M$SI)
    THEN ECHO = 1;
    ELSE ECHO = 0;
   FILE_RCOUNT = FILE_RCOUNT + 1;       /* COUNT READ RECORD                  */
   DCB$ = DCBADDR( TEMP1 );             /* POINT TO COMMAND INPUT DCB         */
 
/********************
***   IGNORE ANY TRAILING ACTIVATION CHARS.
**/
   TEMP1 = DCB$  -> F$DCB.ARS#;
                                        /* CALC IX OF LAST CHAR IN BUF        */
   TEMP2 = 0;                           /* INIT SEARCH LOOP                   */
   DO WHILE ( TEMP2 <= CT_SPACE AND TEMP2 ~= CT_DEL  AND TEMP2 ~= CT_BS);
      TEMP1 = TEMP1 - 1;
      IF TEMP1 >= 0                     /* GET NEXT CHAR IF IT EXISTS         */
       THEN TEMP2 = TPTR1$ -> UBIN9#(TEMP1);
       ELSE TEMP2 = CT_SPACE + 1;
      END;
/********************
***   CHANGE ALL LOWER CASE ALPHA INPUT TO UPPER CASE; OBEY DELS.
**/
   TIX2 = -1;                           /* INIT TARGET INDEX                  */
   DO TIX1=0 TO TEMP1;                  /* FOR ALL CHARS IN BUFFER            */
      TEMP2 = TPTR1$ -> UBIN9#(TIX1);   /* GET THE CHAR                       */
      IF TEMP2 ~= CT_DEL AND TEMP2 ~= CT_BS /* 'RUBOUT' CHAR?                 */
       THEN DO;                         /* NO                                 */
         TIX2 = TIX2 + 1;               /* INC TARGET INDEX                   */
         IF UPSHIFT_FLAG ~= 0           /* UPSHIFT IF SUPPOSED TO             */
          THEN IF TEMP2 >= CT_LC_A AND TEMP2 <= CT_LC_Z
                                        /* IF LOWER CASE ALPHA                */
             THEN TEMP2 = TEMP2 - CT_LC_A + CT_A;
                                        /* UPSHIFT                            */
         TPTR1$ -> UBIN9#(TIX2) = TEMP2;
                                        /* PUT CHAR IN PROPER BUFFER POSITION */
         END;
       ELSE DO;                         /* RUBOUT CHAR                        */
         IF TIX2 > -1 THEN TIX2 = TIX2 - 1;
                                        /* RUB OUT PRECEEDING CHAR            */
         END;
      END;
   LEN# = TIX2 + 1;                     /* RETURN LENGTH OF INPUT STRING      */
   RETURN;
 
UT_READ_BUF_ALTRET:
   LEN#      = 0;                       /* NOTHING READ                       */
   IF READ_LOC# = 1                     /* ERROR OK IF READING FROM FILE      */
    THEN DO;
      READ_FILE = 0;
      CALL M$CLOSE( CLS_FI_FPT ) ALTRET ( RB_CLS_FI_ALTRET );
      RETURN;
      END;
   VAL_FAULT = 23;           /*E* 23V UT_READ_BUF: ERROR READING COMMAND */
RB_CLS_FI_ALTRET:
   RETURN;
 
END UT_READ_BUF;
 
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/**
***   UT_READ_CMND   13 SEP 77   (PRY)   READ A SPECIFIED NUMBER
***   OF CHARACTERS INTO THE SPECIFIED BUFFER AT THE SPECIFIED INDEX.
***   RETURN THE LENGTH OF THE COMMAND.
**/
 
UT_READ_CMND: PROC( CMND_BUF$#, CHAR_IX#, CMND_SIZE#, CMND_LEN# );
 
%INCLUDE FILER_II5;
 
/*** READ FROM COMMAND INPUT  ***/
DCL   UT_READ_BUF            ENTRY(4);
/********************
***   PARAMETERS:
**/
DCL   CMND_BUF$#      PTR ALIGNED; /* POINTER TO COMMAND BUFFER DESCRIPTOR    */
DCL   CHAR_IX#       SBIN WORD ALIGNED; /* CHAR INDEX OF BUFFER TO READ INTO  */
DCL   CMND_LEN#      SBIN WORD ALIGNED; /* RETURNED LENGTH OF COMMAND SEGMENT */
DCL   CMND_SIZE#     SBIN WORD ALIGNED; /* NUMBER OF CHARS TO READ            */
 
/*********************
***   LOCALS:
**/
DCL   BUF_PTR$        PTR ALIGNED AUTO; /* POINTER TO BUFFER                  */
 
/********************
***   CALC BUFFER POINTER AND READ COMMAND.
**/
   BUF_PTR$ = PINCRC( CMND_BUF$# -> BUF.BLK$, CHAR_IX# );
                                        /* CALC POINTER TO BUFFER             */
   CALL UT_READ_BUF( BUF_PTR$, CMND_SIZE#, CMND_LEN#, READ_FILE );
               /* READ THE NEXT COMMAND FROM WHEREVER READ_FILE FLAG SAYS     */
   RETURN;
 
END UT_READ_CMND;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*********************************************************************/
/**
***   XQC_READ_FILE   9 JAN 78   (PRY)   EXECUTES THE READ FILE COMMAND.
**/
 
XQC_READ_FILE: PROC;
%INCLUDE FILER_II5;
%INCLUDE FILER_II4;
%INCLUDE CP_6;
/***   IGNORE BLANKS  ***/
DCL UT_IGNORE_BLANKS ENTRY;
/***   INCREMENT CHAR INDEX AND IGNORE BLANKS   ***/
DCL   UT_INC_IGNORE          ENTRY;
 
/***   GET NEXT NAME   ***/
DCL   UT_GET_NAME            ENTRY;
 
/***   CHECK FOR TRAILING ILLEGAL JUNK   ***/
DCL   UT_JUNK_CHK            ENTRY;
DCL   M$FI    DCB;                      /* FILER FILE INPUT DCB               */
/********************
***
**/
DCL   EXECUTING_CMND    SBIN WORD ALIGNED            SYMREF;
                                        /* FLAG CONTROLS COMMAND EXECUTION    */
/********************
***   LOCALS:
**/
DCL 1 FILE_NAME DALIGNED STATIC,
      2 LENGTH UBIN(9) UNAL,
      2 CHR(0:30) UBIN(9) UNAL;
DCL NEW_ACCT CHAR(8) AUTO;
DCL ACCT CHAR(8) DALIGNED STATIC;
DCL 1 NEW_NAME AUTO,
      2 LENGTH UBIN BYTE UNAL,
      2 CHR(0:30) UBIN BYTE UNAL;
                                        /* FILE NAME VLP                      */
%FPT_OPEN (FPTN=OPN_FI_FPT,DCB=M$FI,FUN=IN,ACS=SEQUEN,ASN=FILE,
   NAME=FILE_NAME,ACCT=ERASE,STCLASS="STATIC SYMDEF",DISP=NAMED);
%FPT_CLOSE (FPTN=CLS_FI_FPT,DCB=M$FI,STCLASS=STATIC);
%FPT_PRECORD (FPTN=PRC_FI_FPT,DCB=M$FI,STCLASS=STATIC);
/********************
***           CLOSE THE FILE IF PRESENTLY OPEN. NOW CHECK
***      TO SEE IF A FILE NAME EXIST. IF NOT, SEE IF ANY OTHER
***      FILE NEEDS TO BE TAKEN OFF FILE_STACK. OPEN NEW FILE
***      OR RETURN TO USER. IF FILE NAME DOES EXIST THEN
***      SKIP TO NEXT SECTION.
**/
   IF READ_FILE ~=0 THEN CALL M$CLOSE(CLS_FI_FPT) ALTRET(RF_CLS_FI_ALTRET);
RF_CLS_FI_ALTRET:
   CALL UT_INC_IGNORE;             /* SKIP OVER THE 'R' AND IGNORE THE BLANKS */
   IF CHARX > CHARX_MAX OR C = CT_SEMI_COLON
    THEN DO;   /* THIS IS A SIMPLE 'R' SO SEE IF THERE IS SOMETHING ON STACK  */
RF_PRC_ERROR:
      IF FILE_STK_IX < 0
       THEN DO;                         /* NOTHING ON STACK SO RETURN         */
         READ_FILE = 0;
         RETURN;
         END;
                              /*   POP FILE INFO OFF THE STACK AND OPEN FILE. */
                              /*   MOVE TO NEXT RECORD AND CONTINUE READING.  */
                                        /*   THAT MEANS RETURN!!              */
      FILE_NAME.LENGTH = FILE_STACK.NAME.LENGTH(FILE_STK_IX);
      TPTR1$ = ADDR(FILE_NAME.CHR(0));
      TEMP1 = FILE_NAME.LENGTH;
      TPTR1$ -> CHARS = FILE_STACK.NAME.CHR(FILE_STK_IX);
      FILE_RCOUNT = FILE_STACK.RCOUNT(FILE_STK_IX);
      ACCT = FILE_STACK.ACCT(FILE_STK_IX);
      IF ACCT = ' '
       THEN OPN_FI_FPT.ACCT_ = VECTOR(ERASE);
       ELSE OPN_FI_FPT.ACCT_ = VECTOR(ACCT);
      FILE_STK_IX = FILE_STK_IX - 1;
      CALL M$OPEN (OPN_FI_FPT) ALTRET (RF_OPN_FI_ALTRET);
      PRC_FI_FPT.V.N# = FILE_RCOUNT;
      CALL M$PRECORD(PRC_FI_FPT) ALTRET(RF_PRC_FI_ALTRET);
                                        /* IF ALTRET THIS MEANS EOF OCURRED   */
      READ_FILE = 1;
      RETURN;
      END;
/********************
***      FILE NAME EXISTS SO GET IT AND MAKE SURE IT'S LEGAL
**/
   CALL UT_GET_NAME;
   IF VAL_FAULT ~= 0 THEN RETURN;
   IF CRNT_NAME.LENGTH < 1 OR CRNT_NAME.LENGTH > 31
    THEN DO;
      VAL_FAULT = 79;
         /*E* 79V XQC_READ_FILE: FILE NAME IS MISSING OR TOO LONG */
      RETURN;
      END;
   TPTR1$ = ADDR(NEW_NAME.CHR(0));
   TPTR2$ = ADDR(CRNT_NAME.CHR(0));
   TEMP1 = CRNT_NAME.LENGTH;
   NEW_NAME.LENGTH  = TEMP1;
   TPTR1$ -> CHARS = TPTR2$ -> CHARS;
   CALL UT_IGNORE_BLANKS;               /* FIND NEXT CHAR                     */
   IF CHARX <= CHARX_MAX AND C = CT_PERIOD
    THEN DO;                            /* GET ACCOUNT                        */
      CALL UT_INC_IGNORE;               /* SKIP OVER PERIOD                   */
      IF CHARX > CHARX_MAX OR C = CT_SEMI_COLON
       THEN NEW_ACCT = ' ';
       ELSE DO;                         /* MUST BE ACCOUNT                    */
         CALL UT_GET_NAME;
         IF VAL_FAULT ~= 0 THEN RETURN;
         IF CRNT_NAME.LENGTH < 1 OR CRNT_NAME.LENGTH > 8
          THEN DO;
            VAL_FAULT = 85;
            /*E* 85V XQC_READ_FILE: ACCOUNT MISSING OR TOO LONG */
            RETURN;
            END;
         TEMP1 = CRNT_NAME.LENGTH;
         TPTR2$ = ADDR(CRNT_NAME.CHR(0));
         NEW_ACCT = TPTR2$->CHARS;      /* MOVE ACCOUNT                       */
         END;
      END;
    ELSE NEW_ACCT = ' ';
/********************
***      HAVE A FILE NAME SO NOW LET'S SEE IF YOU CAN OPEN A
***      FILE (MEANING IS THERE ENOUGH ROOM ON THE STACK TO
***      PUSH ANOTHER SET OF FILE STATS.
**/
   CALL UT_JUNK_CHK;                    /* CHECK FOR JUNK AFTER THE FILE NAME */
   IF VAL_FAULT ~= 0 THEN RETURN;
   IF FILE_STK_IX >= FILE_STK_IX_MAX
    THEN DO;
      VAL_FAULT = 84;
        /*E* 84V XQC_READ_FILE: YOU ATTEMPED TO OVER FLOW THE FILE STACK */
      RETURN;
      END;
/********************
***      O.K. NOW PUT THE PRESENT FILE (IF ANY) ON TOP OF THE STACK
***      AND SET UP THE NEW FILE TO BEGIN READING
**/
   IF READ_FILE ~=0
    THEN DO;  /* PUSH THIS FILE ON THE STACK. INCR STACK
                     POINTER AND STORE RCOUNT TOO */
      TPTR1$ = ADDR(FILE_NAME.CHR(0));
      FILE_STK_IX = FILE_STK_IX + 1;
      FILE_STACK.NAME.LENGTH(FILE_STK_IX) = FILE_NAME.LENGTH;
      FILE_STACK.RCOUNT(FILE_STK_IX) = FILE_RCOUNT;
      TEMP1 = FILE_NAME.LENGTH;
      FILE_STACK.NAME.CHR(FILE_STK_IX) = TPTR1$ -> CHARS;
      FILE_STACK.ACCT(FILE_STK_IX) = ACCT;
      END;
                              /* SET UP FILE SPECS. AND OPEN THE NEW FILE     */
   FILE_NAME = NEW_NAME;
   ACCT = NEW_ACCT;
   IF ACCT = ' '
    THEN OPN_FI_FPT.ACCT_ = VECTOR(ERASE);
    ELSE OPN_FI_FPT.ACCT_ = VECTOR(ACCT);
   CALL M$OPEN(OPN_FI_FPT) ALTRET(RF_OPN_FI_ALTRET);
   READ_FILE=1;
   FILE_RCOUNT=0;
   RETURN;
 
 
RF_OPN_FI_ALTRET:
   VAL_FAULT = 80;      /*E* 80V XQC_READ_FILE: FILE CAN'T BE OPENED    */
   READ_FILE = 0;
   FILE_STK_IX = -1;
   RETURN;
 
RF_PRC_FI_ALTRET:
   CALL M$CLOSE(CLS_FI_FPT) ALTRET(RF_CLS_FI_ALTRET);
   GOTO RF_PRC_ERROR;
END XQC_READ_FILE;
/*********************************************************************/
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
%EJECT;
/*********************************************************************/
/*
***   AM_ROTATE_BLKS  12 AUG 77  (PRY)  ROTATES REGION OF BLOCK SPACE
***   FROM BLK_IX1# TO BLK_IX2# BY ROT_AMT#.
*/
 
AM_ROTATE_BLKS: PROC( BLK_IX1#, BLK_IX2#, ROT_AMT#   ) NOAUTO;
%INCLUDE FILER_II5;
 
/***************
***   PARAMETERS:
*/
DCL   BLK_IX1#       SBIN WORD ALIGNED; /* BEGIN ROTATE IX                    */
DCL   BLK_IX2#       SBIN WORD ALIGNED; /* END ROTATE IX                      */
DCL   ROT_AMT#          SBIN WORD ALIGNED;
                                   /* NUMBER OF WORDS TO ROTATE REGION BY     */
 
/***************
***   LOCALS:
*/
DCL   PTR$              PTR       ALIGNED   STATIC;
                                        /* POINTS TO REGION BEING ROTATED     */
DCL   IX      SBIN WORD ALIGNED STATIC; /* INDEXES THROUGH REGION             */
DCL   ROT_AMT SBIN WORD ALIGNED STATIC; /* LOCALIZES ROT_AMT#                 */
DCL NBR_TO_MOVE SBIN WORD ALIGNED STATIC; /* COUNTS WORDS MOVED               */
DCL NBR_WORDS SBIN WORD ALIGNED STATIC; /* CALCS # WORDS TO MOVE              */
DCL   STRT_IX           SBIN WORD ALIGNED   STATIC;
                                        /* KEEPS TRACK OF ROTATION BEGINNING  */
DCL   MOVE_FROM_IX      SBIN WORD ALIGNED   STATIC;
                                   /* MOVES PARALLEL TO IX WHEN MOVING WORDS  */
 
/***************
***   INITIALIZE ROTATION.
*/
   IX          = BLK_IX1#;              /* LOCALIZE BEGIN IX                  */
   PTR$     = PINCRW( DATA_BASE$, IX ); /* POINT TO REGION                    */
   NBR_WORDS   = BLK_IX2# - IX + 1;     /* CALC # WORDS TO MOVE               */
   NBR_TO_MOVE = NBR_WORDS;
   STRT_IX     = 0;
   IX          = 0;
   ROT_AMT     = ROT_AMT#;
/*
***   ROTATE REGION.
*/
   IF NBR_TO_MOVE = ROT_AMT THEN RETURN;
                                        /* RETURN IF NOTHING TO DO            */
   DO WHILE (NBR_TO_MOVE > 0);
      TEMP1        = PTR$ -> WORD#(IX); /* REMOVE FIRST WORD                  */
      MOVE_FROM_IX = IX + ROT_AMT;      /* POSITION MOVE FROM IX              */
      DO WHILE (MOVE_FROM_IX ~= STRT_IX);
                                        /* ROTATE AS MUCH AS POSSIBLE         */
         PTR$ -> WORD#(IX) = PTR$ -> WORD#(MOVE_FROM_IX);
                                        /* MOVE NEXT WORD                     */
         IX                = IX + ROT_AMT;
                                        /* MOVE INDEXES                       */
         MOVE_FROM_IX      = MOVE_FROM_IX + ROT_AMT;
                                        /* INCREMENT INDEXES IN PARALLEL      */
         NBR_TO_MOVE       = NBR_TO_MOVE - 1;
                                        /* MOVED ONE MORE                     */
         IF IX >= NBR_WORDS THEN IX = IX - NBR_WORDS;
                                        /* ADJUST INDEXES FOR RANGE           */
         IF MOVE_FROM_IX >= NBR_WORDS
          THEN MOVE_FROM_IX = MOVE_FROM_IX - NBR_WORDS;
         END;
      PTR$ -> WORD#(IX) = TEMP1;        /* REPLACE LAST WORD                  */
      NBR_TO_MOVE       = NBR_TO_MOVE - 1;
                                        /* MOVED ONE MORE                     */
      STRT_IX           = STRT_IX + 1;  /* MOVE TO NEXT SUB-REGION            */
      IX                = STRT_IX;
      END;
 
   RETURN;
 
END AM_ROTATE_BLKS;
 
/*********************************************************************/
