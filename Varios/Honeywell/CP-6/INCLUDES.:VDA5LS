

 11:05 NOV 14 '97 $6EDIT_INSTALL                           $6EDIT_INSTALL        Page 1
         1  !"*M* Installation file for 6Edit.
         2  !"*T***********************************************************
         3  !"*T*                                                         *
         4  !"*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  !"*T*                                                         *
         6  !"*T***********************************************************
         7  !" This XEQ-file will install the data files used by 6Edit and for
         8  !"      customizing the Introduction to 6Edit manual (CE73).
         9  !"
        10  !" First, split up the :6EDIT_CONTEXT_BOOK.:LIBRARY file into the
        11  !"  separate context files in .:LIBRARY.
        12  !" We use OVER below, thus replacing any similarly-named context files already
        13  !"  in .:LIBRARY.  If you don't want to do this, but only get any new
        14  !"  context files in :6EDIT_CONTEXT_BOOK, XEQ or BATCH with COVER=TO.
        15  !"
        16  !DEFAULT COVER=OVER
        17  !SET M$DO *NAMES
        18  !BOOKCHAP.X :6EDIT_CONTEXT_BOOK.:LIBRARY COVER .:LIBRARY
        19  !IF OK THEN GOTO MAKE_DESC
        20  !OUTPUT '*** BOOKCHAP.X Failed!  Aborting install.'
        21  !END
        22  !MAKE_DESC:
        23  !RESET M$DO
        24  !"
        25  !" Now, build the context description files from the context files in .:LIBRARY.
        26  !" The context description files are used to customize the CE73 manual,
        27  !"      Introduction to 6Edit Screen Editing.
        28  !"
        29  !" We use OVER in the Copy commands below, thus replacing any same-named
        30  !"  context description files already in .:DOCUM.  If you don't want to do
        31  !"  this, but only get any new context description files from
        32  !"  :6EDIT_CONTEXT_BOOK, you should replace the *NAMES below with the
        33  !"  FID of a file listing the names of the desired replacement files.
        34  !"
        35  !6EDIT ($SCREEN EQ 0)
        36  CO FI *NAMES OV AN FI *COMMANDS BY 1
        37  CO ST 'CO FI %?.:LIBRARY OVER AN EDKEY FI %?_TEXT.:DOCUM'||                    ;

 11:05 NOV 14 '97 $6EDIT_INSTALL                           $6EDIT_INSTALL        Page 2
        38  " The context description file starts out as the entire context file.  First, ";
        39  "   delete all records except those which contain *K*.                        ";
        40  "                                                                             ";
        41  " Each *K* record looks something like:                                       ";
        42  "       KEYIN ..... `*K* function <key> <seq>                                 ";
        43  " (where the ` in the above line is actually a double-quote)                  ";
        44  "                                                                             ";
        45  " Frame the key sequence in double-quotes => .SRV function ``<key> <seq>''    ";
        46    '%RCO ST ''.SRV %%W(2) "%%W(3)"%%R'' OV CURR REPE SE ''%%?*K* %%? %%?%%R''%R';
        47     OV CURR REPE SE '%?%R'
        48  " Rename the standard context file appropriately.
        49  BO CURR;':6EDIT_CONTEXT%E_TEXT';IF $MATCHES CO ST '_STANDARD' AFTER THAT
        50  "
        51  END
        52  !6EDIT ($SCREEN EQ 0;$MATCH_LIMIT EQ 100;READ *COMMANDS;END

 11:05 NOV 14 '97 :6EDIT_CONTEXT                           :6EDIT_CONTEXT        Page 3
         1  "*M* :6EDIT_CONTEXT - Standard (terminal-independent) context file for 6Edit
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT standard
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT.:LIBRARY
        10  "*K* FORWARD_PATT_MSG1 SKIP 1 ''
        11  "*K* FORWARD_PATT_WORDS1 The cursor lands on the second apostrophe ('), ready for you to type a pa
            ttern string, a character or set of characters you would like to locate in your file.
        12  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  6Edit inserts it betwe
            en two apostrophes.  This tells 6Edit to search for the first match of the letter I.
        13  "*K* FORWARD_PATT_RPT retyping <CNTL-P>
        14  "*K* SUBSTITUTE_MSG1 COPY STRING '' OVER REPEAT SELECT PATTERN ''
        15  "*K* SUBSTITUTE_WORDS1 (This actually looks more complicated than it is!)  The cursor lands on the
             second apostrophe of the first pair, ready for you
        16  "*K* SUBSTITUTE_WORDS2 to type a replacement string for all pattern matches.  The pattern you want
             to replace goes between the second pair of apostrophes.
        17  "*K* SUBSTITUTE_WORDS3 Fill in the first set of apostrophes
        18  "*K* SUBSTITUTE_WORDS4 using <ESC> <N> to go to the end of the line, fill in the second set of apo
            strophes
        19  "*K* SUBSTITUTE_MSG3 *COPY STRING 'I, a humble admirer,' OVER REPEAT SELECT PATTERN 'I'
        20  "*K* HUMBLE_MSG SKIP 1 'HUMBLE'
        21  "*K* FORWARD_PATT_WORDS3 The cursor lands on the second apostrophe ('),
        22  "*K* SUBSTITUTE_WORDS5 The cursor lands on the second apostrophe ('), ready for you to type a repl
            acement string for all pattern matches.
        23  "*K* SUBSTITUTE_WORDS6 Between the second pair of apostrophes ('') you type the pattern string to
            be replaced.
        24  "----- Standard synonyms and values
        25  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        26  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        27  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        28  ESC EQ '%V(27)';    CR EQ '%V(13)'
        29  "----- Special input activation characters for 6Edit
        30  CMD EQ '%V(3)'

 11:05 NOV 14 '97 :6EDIT_CONTEXT                           :6EDIT_CONTEXT        Page 4
        31  "----- Cursor movement keyins
        32  KEYIN '%V(21)' IS ESC||'A'                       "*K* BACKWARD_1 <CNTL-U>
        33  KEYIN '%V(22)' IS ESC||'B'                       "*K* FORWARD_1 <CNTL-V>
        34  KEYIN ESC||'W' IS CMD||'BACKWARD SKIP 8 BO RECORDS'||CR "*K* BACKWARD_8 <ESC> <W>
        35  KEYIN ESC||'E' IS CMD||'SKIP 8 BO RECORDS'||CR   "*K* FORWARD_8 <ESC> <E>
        36  KEYIN ESC||'A' IS CMD||'BACKWARD SKIP 20 BO RECORDS'||CR "*K* BACKWARD_20 <ESC> <A>
        37  KEYIN ESC||'L' IS CMD||'SKIP 20 BO RECORDS'||CR  "*K* FORWARD_20 <ESC> <L>
        38  KEYIN ESC||'P' IS CMD||'BACKWARD SKIP 1 ''''%V(8)%V(27)>' "*K* BACKWARD_PATTERN <ESC> <P>
        39  KEYIN '%V(16)' IS CMD||'SKIP 1 ''''%V(8)%V(27)>' "*K* FORWARD_PATTERN <CNTL-P>
        40  KEYIN ESC||'B' IS CMD||'BO CURRENT'||CR          "*K* BO_CURRENT <ESC> <B>
        41  KEYIN ESC||'F' IS CMD||'EO CURRENT'||CR          "*K* EO_CURRENT <ESC> <F>
        42  KEYIN ESC||'.' IS CMD||'L'||CR                   "*K* L <ESC> <.>
        43  "----- Block editing keyins
        44  KEYIN '%V(7)'  IS CMD                            "*K* COMMAND <CNTL-G>
        45  KEYIN '%V(20)' IS CMD||'THRU'||CR                "*K* THRU <CNTL-T>
        46  KEYIN '%V(1)'  IS CMD||'ADJUST'||CR              "*K* ADJUST <CNTL-A>
        47  KEYIN ESC||'1' IS CMD||'COPY THAT'||CR           "*K* COPY <ESC> <1>
        48  KEYIN ESC||'!' IS CMD||'MOVE THAT'||CR           "*K* MOVE <ESC> <!>
        49  KEYIN ESC||'3' IS CMD||'COPY RECORD'||CR         "*K* COPY_RECORD <ESC> <3>
        50  KEYIN ESC||'#' IS CMD||'MOVE RECORD'||CR         "*K* MOVE_RECORD <ESC> <#>
        51  KEYIN ESC||'4' IS CMD||'COPY L AFTER HERE'||CR   "*K* COPY_L_AFTER_HERE <ESC> <4>
        52  KEYIN ESC||'$' IS CMD||'MOVE L AFTER HERE'||CR   "*K* MOVE_L_AFTER_HERE <ESC> <$>
        53  KEYIN ESC||'/' IS CMD||'AFTER HERE'||CR          "*K* AFTER <ESC> </>
        54  KEYIN ESC||'@' IS CMD||'OVER THAT'||CR           "*K* OVER <ESC> <@>
        55  KEYIN ESC||'*' IS CMD||'DELETE THAT'||CR         "*K* DELETE <ESC> <*>
        56  KEYIN ESC||'_' IS CMD||'EDIT THAT'||CR           "*K* EDIT_THAT <ESC> <_>
        57  KEYIN ESC||'[' IS CMD||'EDIT PREVIOUS'||CR       "*K* EDIT_PREVIOUS <ESC> <[>
        58  KEYIN ESC||']' IS CMD||'EDIT NEXT'||CR           "*K* EDIT_NEXT <ESC> <]>
        59  KEYIN ESC||':' IS CMD||'LOCATION L IS THAT'||CR  "*K* LO_L_IS_THAT <ESC> <:>
        60  KEYIN ESC||'=' IS CMD||'COPY STRING '''' OVER REPEAT SELECT ''''%V(27)%V(13)%V(27)V''%V(18)%V(27)>
            ' "*K* SUBSTITUTE <ESC> <=>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_DECVT100                  :6EDIT_CONTEXT_DECVT  Page 5
         1  "*M* :6EDIT_CONTEXT_DECVT100 - Context file for 6Edit using DEC VT100 terminals
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "
         8  "                          NOTICE
         9  "
        10  "   To use this context file, the DEC VT100 terminal must be
        11  "   in both 'cursor key mode' and 'alternate keypad mode'.
        12  "   The easiest way to make this happen is to put an IBEX
        13  "   command in your logon setup file which copies a sequence
        14  "   of control characters to the terminal every time you log on.
        15  "
        16  "   Getting IBEX to write control characters to the terminal takes
        17  "   a bit of doing.  It's much easier to use the A03 6EDIT SHOW STRING
        18  "   command, so if you want the terminal to be in these modes all the time,
        19  "   add this line to your logon setup file:
        20  "       !6EDIT (SHOW STRING <ESC>||'[?1h'||<ESC>||'=';END)
        21  "
        22  "
        23  "----- Comments for customization of Introduction to 6Edit (CE73)
        24  "*K* SUBJECT DECVT100
        25  "*K* CONTEXT_FID :6EDIT_CONTEXT_DECVT100.:LIBRARY
        26  "*K* SUBSTITUTE_MSG1 CO ST $INPUT('New string:') OVER REPE SE PA $INPUT('Old string:')
        27  "*K* SUBSTITUTE_MSG2 New string:
        28  "*K* SUBSTITUTE_WORDS1 The string to be substituted may be typed on this line.  Then the prompt ""
            Old String:"" is displayed; the pattern you want to replace goes on this line.
        29  "*K* SUBSTITUTE_WORDS3 Fill in the line
        30  "*K* SUBSTITUTE_WORDS4 the next line
        31  "*K* SUBSTITUTE_MSG3 New string:I, a humble admirer,
        32  "*K* SUBSTITUTE_MSG4 Old string:I
        33  "*K* HUMBLE_MSG Search Pattern:HUMBLE
        34  "*K* NEW_SKIP1 .GO SKIP_OVER_APOST
        35  "*K* FORWARD_PATT_WORDS3 The cursor is placed following the colon (:),
        36  "*K* SUBSTITUTE_WORDS5 The cursor is placed following the colon (:) where you type the replacement

 11:05 NOV 14 '97 :6EDIT_CONTEXT_DECVT100                  :6EDIT_CONTEXT_DECVT  Page 6
             string.  Then to the prompt
        37  "*K* SUBSTITUTE_WORDS6 ""Old String:"" you type the string to be replaced.
        38  "*K* FORWARD_PATT_MSG1 SKIP 1 PA $INPUT('Search Pattern:')
        39  "*K* FORWARD_PATT_MSG2 Search Pattern:
        40  "*K* FORWARD_PATT_WORDS1 The cursor is positioned after the : character.
        41  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  This tells 6Edit to se
            arch for the first match of the letter I.
        42  "*K* FORWARD_PATT_RPT typing <ALT-F2>
        43  "*K* BACKWARD_PATTERN_1 <ALT-F1>
        44  "----- Standard synonyms and values
        45  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        46  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        47  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        48  ESC EQ <ESC>;    CR EQ <CR>
        49  $END_MARK EQ '   ---end---'
        50  "----- Parameters
        51  $INTRO_1 EQ ESC
        52  "----- Special input activation characters for 6Edit
        53  CMD EQ '%V(3)'
        54  "----- Cursor movement keyins
        55  KEYIN <UPARROW> IS ESC||'A'                       "*K* BACKWARD_1 <Up Arrow>
        56  KEYIN <DNARROW> IS ESC||'B'                       "*K* FORWARD_1 <Down Arrow>
        57  KEYIN <RTARROW> IS ESC||'C'                       "*K* RIGHT_1 <Right Arrow>
        58  KEYIN <LTARROW> IS ESC||'D'                       "*K* LEFT_1 <Left Arrow>
        59  KEYIN <PF3> IS <ESC>||'8A'                        "*K* BACKWARD_8 <PF3>
        60  KEYIN <PF4> IS <ESC>||'8B'                        "*K* FORWARD_8 <PF4>
        61  KEYIN <PF1> IS <ESC>||'20A'                       "*K* BACKWARD_20 <PF1>
        62  KEYIN <PF2> IS <ESC>||'20B'                       "*K* FORWARD_20 <PF2>
        63  KEYIN <UF10> IS CMD||'BA SK 1 PA $INPUT(''Search Pattern:'')'||CR "*K* BACKWARD_PATTERN <Pad ,>
        64  KEYIN <ENTER> IS CMD||'SKIP 1 PA $INPUT(''Search Pattern:'')'||CR   "*K* FORWARD_PATTERN <Pad Ente
            r>
        65  KEYIN <UF5> IS CMD||'BO CURRENT'||CR              "*K* BO_CURRENT <Pad 5>
        66  KEYIN <UF6> IS CMD||'EO CURRENT'||CR              "*K* EO_CURRENT <Pad 6>
        67  KEYIN <CNTL-L> IS CMD||'L'||CR                    "*K* L <CNTL-L>
        68  "----- Block editing keyins
        69  KEYIN <CNTL-A> IS CMD                             "*K* COMMAND <CNTL-A>
        70  KEYIN <UF0> IS CMD||'THRU'||CR                    "*K* THRU <Pad 0>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_DECVT100                  :6EDIT_CONTEXT_DECVT  Page 7
        71  KEYIN <UF11> IS CMD||'ADJUST'||CR                 "*K* ADJUST <Pad ->
        72  KEYIN <UF7> IS CMD||'COPY THAT'||CR               "*K* COPY <Pad 7>
        73  KEYIN ESC||'!' IS CMD||'MOVE THAT'||CR            "*K* MOVE <ESC> <!>
        74  KEYIN <UF4> IS CMD||'COPY RECORD'||CR             "*K* COPY_RECORD <Pad 4>
        75  KEYIN ESC||'#' IS CMD||'MOVE RECORD'||CR          "*K* MOVE_RECORD <ESC> <#>
        76  KEYIN <UF9> IS CMD||'COPY L AFTER HERE'||CR       "*K* COPY_L_AFTER_HERE <Pad 9>
        77  KEYIN <ESC>||<@> IS CMD||'MOVE L AFTER HERE'||CR  "*K* MOVE_L_AFTER_HERE <ESC><@>
        78  KEYIN <UF8> IS CMD||'AFTER HERE'||CR              "*K* AFTER <Pad 8>
        79  KEYIN <ESC>||<$> IS CMD||'OVER THAT'||CR          "*K* OVER <ESC><$>
        80  KEYIN <ESC>||<%> IS CMD||'DELETE THAT'||CR        "*K* DELETE <ESC><%>
        81  KEYIN <UF2> IS CMD||'EDIT THAT'||CR               "*K* EDIT_THAT <Pad 2>
        82  KEYIN <UF1> IS CMD||'EDIT PREVIOUS'||CR           "*K* EDIT_PREVIOUS <Pad 1>
        83  KEYIN <UF3> IS CMD||'EDIT NEXT'||CR               "*K* EDIT_NEXT <Pad 3>
        84  KEYIN <UF12> IS CMD||'LOCATION L IS THAT'||CR     "*K* LO_L_IS_THAT <Pad .>
        85  KEYIN <CNTL-T> IS CMD||'CO ST $INPUT(''New string:'') OVER REPE SE PA $INPUT(''Old string:'')'||CR
             "*K* SUBSTITUTE <CNTL-T>
        86  KEYIN <LF> IS ESC||<LF>                           "*K* SPLIT <LF>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTV7800                  :6EDIT_CONTEXT_PCTV7  Page 8
         1  "*M* :6EDIT_CONTEXT_PCTV7800 - Context file for 6Edit using PCTV7800 PC
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT PCTV7800
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_PCTV7800.:LIBRARY
        10  "*K* SUBSTITUTE_MSG1 CO ST $INPUT('New string:') OVER REPE SE PA $INPUT('Old string:')
        11  "*K* SUBSTITUTE_MSG2 New string:
        12  "*K* SUBSTITUTE_WORDS1 The string to be substituted may be typed on this line.  Then the prompt ""
            Old String:"" is displayed; the pattern you want to replace goes on this line.
        13  "*K* SUBSTITUTE_WORDS3 Fill in the line
        14  "*K* SUBSTITUTE_WORDS4 the next line
        15  "*K* SUBSTITUTE_MSG3 New string:I, a humble admirer,
        16  "*K* SUBSTITUTE_MSG4 Old string:I
        17  "*K* HUMBLE_MSG Search Pattern:HUMBLE
        18  "*K* NEW_SKIP1 .GO SKIP_OVER_APOST
        19  "*K* FORWARD_PATT_WORDS3 The cursor is placed following the colon (:),
        20  "*K* SUBSTITUTE_WORDS5 The cursor is placed following the colon (:) where you type the replacement
             string.  Then to the prompt
        21  "*K* SUBSTITUTE_WORDS6 ""Old String:"" you type the string to be replaced.
        22  "*K* FORWARD_PATT_MSG1 SKIP 1 PA $INPUT('Search Pattern:')
        23  "*K* FORWARD_PATT_MSG2 Search Pattern:
        24  "*K* FORWARD_PATT_WORDS1 The cursor is positioned after the : character.
        25  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  This tells 6Edit to se
            arch for the first match of the letter I.
        26  !SET M$LL UC,ORG=T    "Allows RESTORE command to work
        27  "     *****     Replace TOGKEYPAD with KEYPADON if on new release of PCT  *****
        28  $INITIALIZE EQ 'SHOW STRING ''%V(27)_TOGKEYPAD%V(27)\''%R'||"Go to keypad mode";
        29    '!SET M$LL UC,ORG=T%R'||                        "Make $RESTORE work properly";
        30    '!EJECT UC01%R'||                        "Blank screen at 1st entry to 6Edit";
        31    '!EJECT%R'                                      "Reposition cursor to bottom
        32  "     *****
        33  $MIN_COMMAND EQ 2
        34  "     *****     Replace TOGKEYPAD with KEYPADOFF if on new release of PCT  *****

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTV7800                  :6EDIT_CONTEXT_PCTV7  Page 9
        35  $RESTORE EQ 'OUTPUT '''||<ESC>||'_TOGKEYPAD'||<ESC>||'\'''
        36  "     *****
        37  $VSCROLL_MARGIN EQ 0
        38  $VSCROLL EQ 1
        39  "     *****     Replace TOGKEYPAD with KEYPADON if on new release of PCT  *****
        40  SHOW STRING <ESC>||'_TOGKEYPAD'||<ESC>||'\'
        41  "     *****
        42  "----- Standard synonyms and values
        43  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        44  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        45  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        46  ESC EQ <ESC>;    CR EQ <CR>
        47  "----- Custom synonyms and values
        48  $END_MARK EQ '   ---end---'
        49  "----- Special input activation characters for 6Edit
        50  CMD EQ '%V(3)'
        51  "----- Cursor movement keyins
        52  KEYIN <CNTL-G>  IS CMD                           "*K* COMMAND <CNTL-G>
        53  KEYIN <UPARROW> IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        54  KEYIN <DNARROW> IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        55  KEYIN <RTARROW> IS <DC2>                         "*K* RIGHT_1 <Right Arrow>
        56  KEYIN <LTARROW> IS <BS>                          "*K* LEFT_1 <Left Arrow>
        57  KEYIN <SCROLL_SEG_UP> IS <ESC>||'20A'            "*K* BACKWARD_20 <Page Up>
        58  KEYIN <SCROLL_SEG_DOWN> IS <ESC>||'20B'          "*K* FORWARD_20 <Page Down>
        59  KEYIN <SU15> IS <ESC>||'8A'                      "*K* BACKWARD_8 <CNTL-Page Up>
        60  KEYIN <SU14> IS <ESC>||'8B'                      "*K* FORWARD_8 <CNTL-Page Down>
        61  KEYIN <HOME> IS CMD||'BO CURRENT'||CR            "*K* BO_CURRENT <Home>
        62  KEYIN <SU16> IS CMD||'BO THAT'||CR               "*K* BO_THAT <CNTL-Home>
        63  KEYIN <UF11> IS CMD||'EO CURRENT'||CR            "*K* EO_CURRENT <End>
        64  KEYIN <SU11> IS CMD||'EO THAT'||CR               "*K* EO_THAT <CNTL-End>
        65  KEYIN <FF>   IS CMD||'L'||CR                     "*K* L <CNTL-L>
        66  "----- File positioning
        67  KEYIN <DLE>  IS CMD||'EDIT PREVIOUS'||CR         "*K* EDIT_PREVIOUS <CNTL-P>
        68  KEYIN <SO>   IS CMD||'EDIT NEXT'||CR             "*K* EDIT_NEXT <CNTL-N>
        69  "----- Pattern definition and searching
        70  KEYIN <UF1>  IS CMD||'BA SK 1 PA $INPUT(''Search Pattern:'')'||CR
        71                                                   "*K* BACKWARD_PATTERN <CNTL-F1>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTV7800                  :6EDIT_CONTEXT_PCTV7  Page 10
        72  KEYIN <UF2>  IS CMD||'SKIP 1 PA $INPUT(''Search Pattern:'')'||CR
        73                                                   "*K* FORWARD_PATTERN <CNTL-F2>
        74  KEYIN <F11>  IS CMD||'BA SK 1 PA '''''||CR      "*K* BACKWARD_PATTERN_1 <ALT-F1>
        75  KEYIN <F12>  IS CMD||'SKIP 1 PA '''''||CR  "*K* FORWARD_PATT_RPT typing <ALT-F2>
        76  "----- Block editing keyins
        77  KEYIN <LF>   IS ESC||<LF> IN EDITING WINDOW      "*K* SPLIT <LF>
        78  KEYIN <F9>   IS ESC||<FF> IN EDITING WINDOW      "*K* DELETE_RECORD <F9>
        79  KEYIN <F1>   IS CMD||'COPY RECORD'||CR           "*K* COPY_RECORD <F1>
        80  KEYIN <F2>   IS CMD||'MOVE RECORD'||CR           "*K* MOVE_RECORD <F2>
        81  KEYIN <F3>   IS CMD||'LOCATION L IS THAT'||CR    "*K* LO_L_IS_THAT <F3>
        82  KEYIN <F4>   IS CMD||'COPY L AFTER HERE'||CR     "*K* COPY_L_AFTER_HERE <F4>
        83  KEYIN <F5>   IS CMD||'MOVE L AFTER HERE'||CR     "*K* MOVE_L_AFTER_HERE <F5>
        84  KEYIN <SOH>  IS CMD||'AFTER HERE'||CR            "*K* AFTER <CNTL-A>
        85  KEYIN <STX>  IS CMD||'THRU'||CR                  "*K* THRU <CNTL-B>
        86  KEYIN <ETX>  IS CMD||'COPY THAT'||CR             "*K* COPY <CNTL-C>
        87  KEYIN <EOT>  IS CMD||'DELETE THAT'||CR           "*K* DELETE <CNTL-D>
        88  KEYIN <ENQ>  IS CMD||'EDIT THAT'||CR             "*K* EDIT_THAT <CNTL-E>
        89  KEYIN <VT>   IS CMD||'ADJUST'||CR                "*K* ADJUST <CNTL-K>
        90  KEYIN <SI>   IS CMD||'OVER HERE'||CR             "*K* OVER <CNTL-O>
        91  KEYIN <CNTL-T> IS CMD||;
        92    'CO ST $INPUT(''New string:'') OVER REPE SE PA $INPUT(''Old string:'')'||CR
        93                                                   "*K* SUBSTITUTE <CNTL-T>
        94  KEYIN <SYN>  IS CMD||'MOVE THAT'||CR             "*K* MOVE <CNTL-V>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTX364                   :6EDIT_CONTEXT_PCTX3  Page 11
         1  "*M* :6EDIT_CONTEXT_PCTX364 - Context file for 6Edit using PCTX364 PC
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT PCTX364
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_PCTX364.:LIBRARY
        10  "*K* SUBSTITUTE_MSG1 CO ST $INPUT('New string:') OVER REPE SE PA $INPUT('Old string:')
        11  "*K* SUBSTITUTE_MSG2 New string:
        12  "*K* SUBSTITUTE_WORDS1 The string to be substituted may be typed on this line.  Then the prompt ""
            Old String:"" is displayed; the pattern you want to replace goes on this line.
        13  "*K* SUBSTITUTE_WORDS3 Fill in the line
        14  "*K* SUBSTITUTE_WORDS4 the next line
        15  "*K* SUBSTITUTE_MSG3 New string:I, a humble admirer,
        16  "*K* SUBSTITUTE_MSG4 Old string:I
        17  "*K* HUMBLE_MSG Search Pattern:HUMBLE
        18  "*K* NEW_SKIP1 .GO SKIP_OVER_APOST
        19  "*K* FORWARD_PATT_WORDS3 The cursor is placed following the colon (:),
        20  "*K* SUBSTITUTE_WORDS5 The cursor is placed following the colon (:) where you type the replacement
             string.  Then to the prompt
        21  "*K* SUBSTITUTE_WORDS6 ""Old String:"" you type the string to be replaced.
        22  "*K* FORWARD_PATT_MSG1 SKIP 1 PA $INPUT('Search Pattern:')
        23  "*K* FORWARD_PATT_MSG2 Search Pattern:
        24  "*K* FORWARD_PATT_WORDS1 The cursor is positioned after the : character.
        25  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  This tells 6Edit to se
            arch for the first match of the letter I.
        26  !SET M$LL UC,ORG=T    "Allows RESTORE command to work
        27  "     *****     Replace TOGKEYPAD with KEYPADON if on new release of PCT  *****
        28  $INITIALIZE EQ 'SHOW STRING ''%V(27)_TOGKEYPAD%V(27)\''%R'||"Go to keypad mode";
        29    '!SET M$LL UC,ORG=T%R'||                        "Make $RESTORE work properly";
        30    '!EJECT UC01%R'||                        "Blank screen at 1st entry to 6Edit";
        31    '!EJECT%R'                                      "Reposition cursor to bottom
        32  "     *****
        33  $MIN_COMMAND EQ 2
        34  "     *****     Replace TOGKEYPAD with KEYPADOFF if on new release of PCT  *****

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTX364                   :6EDIT_CONTEXT_PCTX3  Page 12
        35  $RESTORE EQ 'OUTPUT '''||<ESC>||'_TOGKEYPAD'||<ESC>||'\'''
        36  "     *****
        37  $VSCROLL_MARGIN EQ 0
        38  $VSCROLL EQ 1
        39  "     *****     Replace TOGKEYPAD with KEYPADON if on new release of PCT  *****
        40  SHOW STRING <ESC>||'_TOGKEYPAD'||<ESC>||'\'
        41  "     *****
        42  "----- Standard synonyms and values
        43  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        44  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        45  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        46  ESC EQ <ESC>;    CR EQ <CR>
        47  "----- Custom synonyms and values
        48  $END_MARK EQ '   ---end---'
        49  "----- Special input activation characters for 6Edit
        50  CMD EQ '%V(3)'
        51  "----- Cursor movement keyins
        52  KEYIN <CNTL-G>  IS CMD                           "*K* COMMAND <CNTL-G>
        53  KEYIN <UPARROW> IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        54  KEYIN <DNARROW> IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        55  KEYIN <RTARROW> IS <DC2>                         "*K* RIGHT_1 <Right Arrow>
        56  KEYIN <LTARROW> IS <BS>                          "*K* LEFT_1 <Left Arrow>
        57  KEYIN <SCROLL_SEG_UP> IS <ESC>||'20A'            "*K* BACKWARD_20 <Page Up>
        58  KEYIN <SCROLL_SEG_DOWN> IS <ESC>||'20B'          "*K* FORWARD_20 <Page Down>
        59  KEYIN <SU15> IS <ESC>||'8A'                      "*K* BACKWARD_8 <CNTL-Page Up>
        60  KEYIN <SU14> IS <ESC>||'8B'                      "*K* FORWARD_8 <CNTL-Page Down>
        61  KEYIN <HOME> IS CMD||'BO CURRENT'||CR            "*K* BO_CURRENT <Home>
        62  KEYIN <SU16> IS CMD||'BO THAT'||CR               "*K* BO_THAT <CNTL-Home>
        63  KEYIN <UF11> IS CMD||'EO CURRENT'||CR            "*K* EO_CURRENT <End>
        64  KEYIN <SU11> IS CMD||'EO THAT'||CR               "*K* EO_THAT <CNTL-End>
        65  KEYIN <FF>   IS CMD||'L'||CR                     "*K* L <CNTL-L>
        66  "----- File positioning
        67  KEYIN <DLE>  IS CMD||'EDIT PREVIOUS'||CR         "*K* EDIT_PREVIOUS <CNTL-P>
        68  KEYIN <SO>   IS CMD||'EDIT NEXT'||CR             "*K* EDIT_NEXT <CNTL-N>
        69  "----- Pattern definition and searching
        70  KEYIN <UF1>  IS CMD||'BA SK 1 PA $INPUT(''Search Pattern:'')'||CR
        71                                                   "*K* BACKWARD_PATTERN <CNTL-F1>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_PCTX364                   :6EDIT_CONTEXT_PCTX3  Page 13
        72  KEYIN <UF2>  IS CMD||'SKIP 1 PA $INPUT(''Search Pattern:'')'||CR
        73                                                   "*K* FORWARD_PATTERN <CNTL-F2>
        74  KEYIN <F11>  IS CMD||'BA SK 1 PA '''''||CR      "*K* BACKWARD_PATTERN_1 <ALT-F1>
        75  KEYIN <F12>  IS CMD||'SKIP 1 PA '''''||CR  "*K* FORWARD_PATT_RPT typing <ALT-F2>
        76  "----- Block editing keyins
        77  KEYIN <LF>   IS ESC||<LF> IN EDITING WINDOW      "*K* SPLIT <LF>
        78  KEYIN <F9>   IS ESC||<FF> IN EDITING WINDOW      "*K* DELETE_RECORD <F9>
        79  KEYIN <F1>   IS CMD||'COPY RECORD'||CR           "*K* COPY_RECORD <F1>
        80  KEYIN <F2>   IS CMD||'MOVE RECORD'||CR           "*K* MOVE_RECORD <F2>
        81  KEYIN <F3>   IS CMD||'LOCATION L IS THAT'||CR    "*K* LO_L_IS_THAT <F3>
        82  KEYIN <F4>   IS CMD||'COPY L AFTER HERE'||CR     "*K* COPY_L_AFTER_HERE <F4>
        83  KEYIN <F5>   IS CMD||'MOVE L AFTER HERE'||CR     "*K* MOVE_L_AFTER_HERE <F5>
        84  KEYIN <SOH>  IS CMD||'AFTER HERE'||CR            "*K* AFTER <CNTL-A>
        85  KEYIN <STX>  IS CMD||'THRU'||CR                  "*K* THRU <CNTL-B>
        86  KEYIN <ETX>  IS CMD||'COPY THAT'||CR             "*K* COPY <CNTL-C>
        87  KEYIN <EOT>  IS CMD||'DELETE THAT'||CR           "*K* DELETE <CNTL-D>
        88  KEYIN <ENQ>  IS CMD||'EDIT THAT'||CR             "*K* EDIT_THAT <CNTL-E>
        89  KEYIN <VT>   IS CMD||'ADJUST'||CR                "*K* ADJUST <CNTL-K>
        90  KEYIN <SI>   IS CMD||'OVER HERE'||CR             "*K* OVER <CNTL-O>
        91  KEYIN <CNTL-T> IS CMD||;
        92    'CO ST $INPUT(''New string:'') OVER REPE SE PA $INPUT(''Old string:'')'||CR
        93                                                   "*K* SUBSTITUTE <CNTL-T>
        94  KEYIN <SYN>  IS CMD||'MOVE THAT'||CR             "*K* MOVE <CNTL-V>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7205                   :6EDIT_CONTEXT_VIP72  Page 14
         1  "*M* :6EDIT_CONTEXT_VIP7205 - Context file for 6Edit using Honeywell VIP7205
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT VIP7205
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_VIP7205.:LIBRARY
        10  "*K* FORWARD_PATT_MSG1 SKIP 1 ''
        11  "*K* FORWARD_PATT_WORDS1 The cursor lands on the second apostrophe ('), ready for you to type a pa
            ttern string, a character or set of characters you would like to locate in your file.
        12  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  6Edit inserts it betwe
            en two apostrophes.  This tells 6Edit to search for the first match of the letter I.
        13  "*K* FORWARD_PATT_RPT retyping <CNTL-P>
        14  "*K* SUBSTITUTE_MSG1 COPY STRING '' OVER REPEAT SELECT PATTERN ''
        15  "*K* SUBSTITUTE_WORDS1 (This actually looks more complicated than it is!)  The cursor lands on the
             second apostrophe of the first pair, ready for you
        16  "*K* SUBSTITUTE_WORDS2 to type a replacement string for all pattern matches.  The pattern you want
             to replace goes between the second pair of apostrophes.
        17  "*K* SUBSTITUTE_WORDS3 Fill in the first set of apostrophes
        18  "*K* SUBSTITUTE_WORDS4 using <ESC> <N> to go to the end of the line, fill in the second set of apo
            strophes
        19  "*K* SUBSTITUTE_MSG3 *COPY STRING 'I, a humble admirer,' OVER REPEAT SELECT PATTERN 'I'
        20  "*K* HUMBLE_MSG SKIP 1 'HUMBLE'
        21  "*K* FORWARD_PATT_WORDS3 The cursor lands on the second apostrophe ('),
        22  "*K* SUBSTITUTE_WORDS5 The cursor lands on the second apostrophe ('), ready for you to type a repl
            acement string for all pattern matches.
        23  "*K* SUBSTITUTE_WORDS6 Between the second pair of apostrophes ('') you type the pattern string to
            be replaced.
        24  "----- Standard synonyms and values
        25  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        26  SYNONYM EACH IS REPEAT SELECT RECORDS SELECT
        27  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        28  ESC EQ '%V(27)';    CR EQ '%V(13)'
        29  "----- Special input activation characters for 6Edit
        30  CMD EQ '%V(3)'

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7205                   :6EDIT_CONTEXT_VIP72  Page 15
        31  "----- Cursor movement keyins
        32  KEYIN ESC||'A' IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        33  KEYIN ESC||'B' IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        34  KEYIN ESC||'5' IS CMD||'BACKWARD SKIP 8 BO RECORDS'||CR "*K* BACKWARD_8 <SHIFT-F2>
        35  KEYIN ESC||'2' IS CMD||'SKIP 8 BO RECORDS'||CR  "*K* FORWARD_8 <F2>
        36  KEYIN ESC||'7' IS CMD||'BACKWARD SKIP 20 BO RECORDS'||CR "*K* BACKWARD_20 <SHIFT-F3>
        37  KEYIN ESC||'6' IS CMD||'SKIP 20 BO RECORDS'||CR "*K* FORWARD_20 <F3>
        38  KEYIN ESC||'1' IS CMD||'BACKWARD SKIP 1 ''''%V(8)%V(27)>' "*K* BACKWARD_PATTERN <SHIFT-F1>
        39  KEYIN ESC||'0' IS CMD||'SKIP 1 ''''%V(8)%V(27)>' "*K* FORWARD_PATTERN <F1>
        40  KEYIN ESC||'T' IS CMD||'BO CURRENT'||CR         "*K* BO_CURRENT <ESC> <T>
        41  KEYIN ESC||'F' IS CMD||'EO CURRENT'||CR         "*K* EO_CURRENT <ESC> <F>
        42  KEYIN ESC||'L' IS CMD||'L'||CR                  "*K* L <ESC> <L>
        43  "----- Block editing keyins
        44  KEYIN ESC||'`' IS CMD                           "*K* COMMAND <CLR>
        45  KEYIN ESC||'i' IS CMD||'THRU'||CR               "*K* THRU <XMIT>
        46  KEYIN '%V(1)'  IS CMD||'ADJUST'||CR             "*K* ADJUST <CTRL-A>
        47  KEYIN ESC||':' IS CMD||'COPY THAT'||CR          "*K* COPY <F5>
        48  KEYIN ESC||';' IS CMD||'MOVE THAT'||CR          "*K* MOVE <SHIFT-F5>
        49  "KEYIN IS CMD||'COPY RECORD'||CR"               "*K* COPY_RECORD <CLR> CO RE <RETURN>
        50  "KEYIN IS CMD||'MOVE RECORD'||CR"               "*K* MOVE_RECORD <CLR> MO RE <RETURN>
        51  "KEYIN IS CMD||'COPY L AFTER HERE'||CR"         "*K* COPY_L_AFTER_HERE <CLR> CO L AF HERE <RETURN>
        52  "KEYIN IS CMD||'MOVE L AFTER HERE'||CR"         "*K* MOVE_L_AFTER_HERE <CLR> MO L AF HERE <RETURN>
        53  KEYIN ESC||'<' IS CMD||'AFTER HERE'||CR         "*K* AFTER <F6>
        54  "KEYIN IS CMD||'OVER THAT'||CR"                 "*K* OVER <CLR> OV THAT <RETURN>
        55  KEYIN ESC||'=' IS CMD||'DELETE THAT'||CR        "*K* DELETE <SHIFT-F6>
        56  "KEYIN IS CMD||'EDIT THAT'||CR"                 "*K* EDIT_THAT <CLR> ED THAT <RETURN>
        57  "KEYIN IS CMD||'EDIT PREVIOUS'||CR"             "*K* EDIT_PREVIOUS <CLR> ED PREV <RETURN>
        58  "KEYIN IS CMD||'EDIT NEXT'||CR"                 "*K* EDIT_NEXT <CLR> ED NEXT <RETURN>
        59  KEYIN ESC||'9' IS CMD||'LOCATION L IS THAT'||CR "*K* LO_L_IS_THAT <SHIFT-F4>
        60  KEYIN ESC||'8' IS CMD||'COPY STRING '''' OVER REPEAT SELECT ''''%V(27)%V(13)%V(27)V''%V(18)%V(27)>
            ' "*K* SUBSTITUTE <F4>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7303                   :6EDIT_CONTEXT_VIP73  Page 16
         1  "*M* :6EDIT_CONTEXT_VIP7303 - Context file for 6Edit using Honeywell VIP7303 (WP 6 Keyboard)
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT VIP7303
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_VIP7303.:LIBRARY
        10  "*K* FORWARD_PATT_MSG1 SKIP 1 ''
        11  "*K* FORWARD_PATT_WORDS1 The cursor lands on the second apostrophe ('), ready for you to type a pa
            ttern string, a character or set of characters you would like to locate in your file.
        12  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  6Edit inserts it betwe
            en two apostrophes.  This tells 6Edit to search for the first match of the letter I.
        13  "*K* FORWARD_PATT_RPT retyping <CNTL-P>
        14  "*K* SUBSTITUTE_MSG1 COPY STRING '' OVER REPEAT SELECT PATTERN ''
        15  "*K* SUBSTITUTE_WORDS1 (This actually looks more complicated than it is!)  The cursor lands on the
             second apostrophe of the first pair, ready for you
        16  "*K* SUBSTITUTE_WORDS2 to type a replacement string for all pattern matches.  The pattern you want
             to replace goes between the second pair of apostrophes.
        17  "*K* SUBSTITUTE_WORDS3 Fill in the first set of apostrophes
        18  "*K* SUBSTITUTE_WORDS4 using <ESC> <N> to go to the end of the line, fill in the second set of apo
            strophes
        19  "*K* SUBSTITUTE_MSG3 *COPY STRING 'I, a humble admirer,' OVER REPEAT SELECT PATTERN 'I'
        20  "*K* HUMBLE_MSG SKIP 1 'HUMBLE'
        21  "*K* FORWARD_PATT_WORDS3 The cursor lands on the second apostrophe ('),
        22  "*K* SUBSTITUTE_WORDS5 The cursor lands on the second apostrophe ('), ready for you to type a repl
            acement string for all pattern matches.
        23  "*K* SUBSTITUTE_WORDS6 Between the second pair of apostrophes ('') you type the pattern string to
            be replaced.
        24  "----- Standard synonyms and values
        25  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        26  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        27  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        28  ESC EQ '%V(27)';    CR EQ '%V(13)';     $INTRO_2 EQ '%V(27)['
        29  "----- Special input activation characters for 6Edit
        30  CMD EQ '%V(3)'

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7303                   :6EDIT_CONTEXT_VIP73  Page 17
        31  "----- Cursor movement keyins
        32  KEYIN ESC||'A' IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        33  KEYIN ESC||'B' IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        34  KEYIN ESC||'!' IS CMD||'BACKWARD SKIP 8 BO RECORDS'||CR "*K* BACKWARD_8 <SHIFT-Up Arrow>
        35  KEYIN ESC||'"' IS CMD||'SKIP 8 BO RECORDS'||CR "*K* FORWARD_8 <SHIFT-Down Arrow>
        36  KEYIN ESC||'$' IS CMD||'BACKWARD SKIP 20 BO RECORDS'||CR "*K* BACKWARD_20 <SHIFT-PAGE>
        37  KEYIN ESC||'#' IS CMD||'SKIP 20 BO RECORDS'||CR "*K* FORWARD_20 <PAGE>
        38  KEYIN ESC||'@' IS CMD||'BACKWARD SKIP 1 ''''%V(8)%V(27)>' "*K* BACKWARD_PATTERN <SHIFT-SEARCH>
        39  KEYIN ESC||'4' IS CMD||'SKIP 1 ''''%V(8)%V(27)>' "*K* FORWARD_PATTERN <SEARCH>
        40  KEYIN ESC||'&' IS CMD||'BO CURRENT'||CR         "*K* BO_CURRENT <SHIFT-NOTE>
        41  KEYIN ESC||'%%' IS CMD||'EO CURRENT'||CR         "*K* EO_CURRENT <NOTE>
        42  KEYIN ESC||'x' IS CMD||'L'||CR                  "*K* L <GOTO PAGE>
        43  "----- Block editing keyins
        44  KEYIN ESC||'<' IS CMD                           "*K* COMMAND <COMMAND>
        45  KEYIN ESC||'/' IS CMD||'THRU'||CR               "*K* THRU <ABBREV>
        46  KEYIN ESC||'3' IS CMD||'ADJUST'||CR             "*K* ADJUST <SHIFT-ABBREV>
        47  KEYIN ESC||'W' IS CMD||'COPY THAT'||CR          "*K* COPY <COPY>
        48  KEYIN ESC||'h' IS CMD||'MOVE THAT'||CR          "*K* MOVE <MOVE>
        49  "KEYIN IS CMD||'COPY RECORD'||CR"               "*K* COPY_RECORD <COMMAND> CO RE <RETURN>
        50  "KEYIN IS CMD||'MOVE RECORD'||CR"               "*K* MOVE_RECORD <COMMAND> MO RE <RETURN>
        51  KEYIN ESC||'g' IS CMD||'COPY L AFTER HERE'||CR  "*K* COPY_L_AFTER_HERE <SHIFT-COPY>
        52  KEYIN ESC||'j' IS CMD||'MOVE L AFTER HERE'||CR  "*K* MOVE_L_AFTER_HERE <SHIFT-MOVE>
        53  KEYIN ESC||'[I' IS CMD||'AFTER HERE'||CR        "*K* AFTER <INSERT>
        54  KEYIN ESC||'[L' IS CMD||'OVER THAT'||CR         "*K* OVER <SHIFT-INSERT>
        55  KEYIN ESC||'[P' IS CMD||'DELETE THAT'||CR       "*K* DELETE <DELETE>
        56  KEYIN ESC||'N' IS CMD||'EDIT THAT'||CR          "*K* EDIT_THAT <AUTO>
        57  KEYIN ESC||'{' IS CMD||'EDIT PREVIOUS'||CR      "*K* EDIT_PREVIOUS <Left unlabelled key>
        58  KEYIN ESC||'}' IS CMD||'EDIT NEXT'||CR          "*K* EDIT_NEXT <Right unlabelled key>
        59  KEYIN ESC||')' IS CMD||'LOCATION L IS THAT'||CR "*K* LO_L_IS_THAT <CODE>
        60  KEYIN ESC||'E' IS CMD||'COPY STRING '''' OVER REPEAT SELECT ''''%V(27)%V(13)%V(27)V''%V(18)%V(27)>
            ' "*K* SUBSTITUTE <REPLACE>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7801                   :6EDIT_CONTEXT_VIP78  Page 18
         1  "*M* :6EDIT_CONTEXT_VIP7801 - Context file for 6Edit using Honeywell VIP7801
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT VIP7801
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_VIP7801.:LIBRARY
        10  "*K* FORWARD_PATT_MSG1 SKIP 1 ''
        11  "*K* FORWARD_PATT_WORDS1 The cursor lands on the second apostrophe ('), ready for you to type a pa
            ttern string, a character or set of characters you would like to locate in your file.
        12  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  6Edit inserts it betwe
            en two apostrophes.  This tells 6Edit to search for the first match of the letter I.
        13  "*K* FORWARD_PATT_RPT retyping <CNTL-P>
        14  "*K* SUBSTITUTE_MSG1 COPY STRING '' OVER REPEAT SELECT PATTERN ''
        15  "*K* SUBSTITUTE_WORDS1 (This actually looks more complicated than it is!)  The cursor lands on the
             second apostrophe of the first pair, ready for you
        16  "*K* SUBSTITUTE_WORDS2 to type a replacement string for all pattern matches.  The pattern you want
             to replace goes between the second pair of apostrophes.
        17  "*K* SUBSTITUTE_WORDS3 Fill in the first set of apostrophes
        18  "*K* SUBSTITUTE_WORDS4 using <ESC> <N> to go to the end of the line, fill in the second set of apo
            strophes
        19  "*K* SUBSTITUTE_MSG3 *COPY STRING 'I, a humble admirer,' OVER REPEAT SELECT PATTERN 'I'
        20  "*K* HUMBLE_MSG SKIP 1 'HUMBLE'
        21  "*K* FORWARD_PATT_WORDS3 The cursor lands on the second apostrophe ('),
        22  "*K* SUBSTITUTE_WORDS5 The cursor lands on the second apostrophe ('), ready for you to type a repl
            acement string for all pattern matches.
        23  "*K* SUBSTITUTE_WORDS6 Between the second pair of apostrophes ('') you type the pattern string to
            be replaced.
        24  "----- Standard synonyms and values
        25  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        26  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        27  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        28  ESC EQ '%V(27)';    CR EQ '%V(13)';     $INTRO_2 EQ '%V(27)['  "VIP78xx's only
        29  "----- Special input activation characters for 6Edit
        30  CMD EQ '%V(3)'

 11:05 NOV 14 '97 :6EDIT_CONTEXT_VIP7801                   :6EDIT_CONTEXT_VIP78  Page 19
        31  "----- Cursor movement keyins
        32  KEYIN ESC||'A' IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        33  KEYIN ESC||'B' IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        34  KEYIN ESC||'[I' IS CMD||'BACKWARD SKIP 8 BO RECORDS'||CR "*K* BACKWARD_8 <DEL/CHAR/INS>
        35  KEYIN ESC||'[L' IS CMD||'SKIP 8 BO RECORDS'||CR "*K* FORWARD_8 <DEL/LINE/INS>
        36  KEYIN ESC||'[P' IS CMD||'BACKWARD SKIP 20 BO RECORDS'||CR "*K* BACKWARD_20 <SHIFT-DEL/CHAR/INS>
        37  KEYIN ESC||'[M' IS CMD||'SKIP 20 BO RECORDS'||CR "*K* FORWARD_20 <SHIFT-DEL/LINE/INS>
        38  KEYIN ESC||'1' IS CMD||'BACKWARD SKIP 1 ''''%V(8)%V(27)>' "*K* BACKWARD_PATTERN <SHIFT-F1>
        39  KEYIN ESC||'0' IS CMD||'SKIP 1 ''''%V(8)%V(27)>' "*K* FORWARD_PATTERN <F1>
        40  KEYIN ESC||'5' IS CMD||'BO CURRENT'||CR         "*K* BO_CURRENT <SHIFT-F2>
        41  KEYIN ESC||'2' IS CMD||'EO CURRENT'||CR         "*K* EO_CURRENT <F2>
        42  KEYIN ESC||'L' IS CMD||'L'||CR                  "*K* L <ESC> <L>
        43  "----- Block editing keyins
        44  KEYIN ESC||'e' IS CMD                           "*K* COMMAND <CLEAR/RESET>
        45  KEYIN ESC||'i' IS CMD||'THRU'||CR               "*K* THRU <TRANSMIT>
        46  KEYIN ESC||'`' IS CMD||'ADJUST'||CR             "*K* ADJUST <SHIFT-CLEAR/RESET>
        47  KEYIN ESC||':' IS CMD||'COPY THAT'||CR          "*K* COPY <F5>
        48  KEYIN ESC||';' IS CMD||'MOVE THAT'||CR          "*K* MOVE <SHIFT-F5>
        49  "KEYIN IS CMD||'COPY RECORD'||CR"               "*K* COPY_RECORD <CLEAR/RESET> CO RE <RETURN>
        50  "KEYIN IS CMD||'MOVE RECORD'||CR"               "*K* MOVE_RECORD <CLEAR/RESET> MO RE <RETURN>
        51  "KEYIN IS CMD||'COPY L AFTER HERE'||CR"         "*K* COPY_L_AFTER_HERE <CLEAR/RESET> CO L AF HERE
            <RETURN>
        52  "KEYIN IS CMD||'MOVE L AFTER HERE'||CR"         "*K* MOVE_L_AFTER_HERE <CLEAR/RESET> MO L AF HERE
            <RETURN>
        53  KEYIN ESC||'<' IS CMD||'AFTER HERE'||CR         "*K* AFTER <F6>
        54  "KEYIN IS CMD||'OVER THAT'||CR"                 "*K* OVER <CLEAR/RESET> OV THAT <RETURN>
        55  KEYIN ESC||'=' IS CMD||'DELETE THAT'||CR        "*K* DELETE <SHIFT-F6>
        56  "KEYIN IS CMD||'EDIT THAT'||CR"                 "*K* EDIT_THAT <CLEAR/RESET> ED THAT <RETURN>
        57  "KEYIN IS CMD||'EDIT PREVIOUS'||CR"             "*K* EDIT_PREVIOUS <CLEAR/RESET> ED PREV <RETURN>
        58  "KEYIN IS CMD||'EDIT NEXT'||CR"                 "*K* EDIT_NEXT <CLEAR/RESET> ED NEXT <RETURN>
        59  KEYIN ESC||'9' IS CMD||'LOCATION L IS THAT'||CR "*K* LO_L_IS_THAT <SHIFT-F4>
        60  KEYIN ESC||'8' IS CMD||'COPY STRING '''' OVER REPEAT SELECT ''''%V(27)%V(13)%V(27)V''%V(18)%V(27)>
            ' "*K* SUBSTITUTE <F4>

 11:05 NOV 14 '97 :6EDIT_CONTEXT_ZENZ19                    :6EDIT_CONTEXT_ZENZ1  Page 20
         1  "*M* :6EDIT_CONTEXT_ZENZ19 - Context file for 6Edit using Zenith Z19 terminal
         2  "*T***********************************************************
         3  "*T*                                                         *
         4  "*T* Copyright (c) Bull HN Information Systems Inc., 1997    *
         5  "*T*                                                         *
         6  "*T***********************************************************
         7  "----- Comments for customization of Introduction to 6Edit (CE73)
         8  "*K* SUBJECT ZENZ19
         9  "*K* CONTEXT_FID :6EDIT_CONTEXT_ZENZ19.:LIBRARY
        10  "*K* FORWARD_PATT_MSG1 SKIP 1 ''
        11  "*K* FORWARD_PATT_WORDS1 The cursor lands on the second apostrophe ('), ready for you to type a pa
            ttern string, a character or set of characters you would like to locate in your file.
        12  "*K* FORWARD_PATT_WORDS2 Without moving the cursor, type the letter ""I"".  6Edit inserts it betwe
            en two apostrophes.  This tells 6Edit to search for the first match of the letter I.
        13  "*K* FORWARD_PATT_RPT retyping <CNTL-P>
        14  "*K* SUBSTITUTE_MSG1 COPY STRING '' OVER REPEAT SELECT PATTERN ''
        15  "*K* SUBSTITUTE_WORDS1 (This actually looks more complicated than it is!)  The cursor lands on the
             second apostrophe of the first pair, ready for you
        16  "*K* SUBSTITUTE_WORDS2 to type a replacement string for all pattern matches.  The pattern you want
             to replace goes between the second pair of apostrophes.
        17  "*K* SUBSTITUTE_WORDS3 Fill in the first set of apostrophes
        18  "*K* SUBSTITUTE_WORDS4 using <ESC> <N> to go to the end of the line, fill in the second set of apo
            strophes
        19  "*K* SUBSTITUTE_MSG3 *COPY STRING 'I, a humble admirer,' OVER REPEAT SELECT PATTERN 'I'
        20  "*K* HUMBLE_MSG SKIP 1 'HUMBLE'
        21  "*K* FORWARD_PATT_WORDS3 The cursor lands on the second apostrophe ('),
        22  "*K* SUBSTITUTE_WORDS5 The cursor lands on the second apostrophe ('), ready for you to type a repl
            acement string for all pattern matches.
        23  "*K* SUBSTITUTE_WORDS6 Between the second pair of apostrophes ('') you type the pattern string to
            be replaced.
        24  "----- Standard synonyms and values
        25  SYNONYM REKEY IS COPY CURRENT OVER CURRENT
        26  SYNONYM EACH IS REPEAT SELECT RECORD SELECT
        27  SYNONYM SHL IS DELETE REPEAT SELECT RECORD SELECT BO RECORD THRU POSITION
        28  ESC EQ '%V(27)';    CR EQ '%V(13)'
        29  "----- Special input activation characters for 6Edit
        30  CMD EQ '%V(3)'

 11:05 NOV 14 '97 :6EDIT_CONTEXT_ZENZ19                    :6EDIT_CONTEXT_ZENZ1  Page 21
        31  "----- Cursor movement keyins
        32  KEYIN ESC||'A' IS ESC||'A'                      "*K* BACKWARD_1 <Up Arrow>
        33  KEYIN ESC||'B' IS ESC||'B'                      "*K* FORWARD_1 <Down Arrow>
        34  KEYIN ESC||'!' IS CMD||'BACKWARD SKIP 8 BO RECORDS'||CR "*K* BACKWARD_8 <ESC> <!>
        35  KEYIN ESC||'1' IS CMD||'SKIP 8 BO RECORDS'||CR  "*K* FORWARD_8 <ESC> <1>
        36  "KEYIN IS CMD||'BACKWARD SKIP 20 BO RECORDS'||CR" "*K* BACKWARD_20 <F1> BA SK 20 RE <RETURN>
        37  KEYIN ESC||'2' IS CMD||'SKIP 20 BO RECORDS'||CR "*K* FORWARD_20 <ESC> <2>
        38  KEYIN ESC||'V' IS CMD||'BACKWARD SKIP 1 ''''%V(8)' "*K* BACKWARD_PATTERN <F4>
        39  KEYIN ESC||'W' IS CMD||'SKIP 1 ''''%V(8)'       "*K* FORWARD_PATTERN <F5>
        40  KEYIN ESC||'0' IS CMD||'BO CURRENT'||CR         "*K* BO_CURRENT <ESC> <0>
        41  KEYIN ESC||'F' IS CMD||'EO CURRENT'||CR         "*K* EO_CURRENT <ESC> <F>
        42  KEYIN ESC||'.' IS CMD||'L'||CR                  "*K* L <ESC> <.>
        43  "----- Block editing keyins
        44  KEYIN ESC||'S' IS CMD                           "*K* COMMAND <F1>
        45  KEYIN ESC||'H' IS CMD||'THRU'||CR               "*K* THRU <Home>
        46  KEYIN ESC||'T' IS CMD||'ADJUST'||CR             "*K* ADJUST <F2>
        47  KEYIN ESC||'R' IS CMD||'COPY THAT'||CR          "*K* COPY <Gray>
        48  KEYIN ESC||'P' IS CMD||'MOVE THAT'||CR          "*K* MOVE <Blue>
        49  KEYIN ESC||'3' IS CMD||'COPY RECORD'||CR        "*K* COPY_RECORD <ESC> <3>
        50  KEYIN ESC||'#' IS CMD||'MOVE RECORD'||CR        "*K* MOVE_RECORD <ESC> <#>
        51  KEYIN ESC||'4' IS CMD||'COPY L AFTER HERE'||CR  "*K* COPY_L_AFTER_HERE <ESC> <4>
        52  KEYIN ESC||'$' IS CMD||'MOVE L AFTER HERE'||CR  "*K* MOVE_L_AFTER_HERE <ESC> <$>
        53  KEYIN ESC||'Q' IS CMD||'AFTER HERE'||CR         "*K* AFTER <Red>
        54  "KEYIN IS CMD||'OVER THAT'||CR"                 "*K* OVER <F1> OV THAT <RETURN>
        55  KEYIN ESC||'E' IS CMD||'DELETE THAT'||CR        "*K* DELETE <SHIFT-ERASE>
        56  KEYIN ESC||'_' IS CMD||'EDIT THAT'||CR          "*K* EDIT_THAT <ESC> <_>
        57  KEYIN ESC||'[' IS CMD||'EDIT PREVIOUS'||CR      "*K* EDIT_PREVIOUS <ESC> <[>
        58  KEYIN ESC||']' IS CMD||'EDIT NEXT'||CR          "*K* EDIT_NEXT <ESC> <]>
        59  KEYIN ESC||':' IS CMD||'LOCATION L IS THAT'||CR "*K* LO_L_IS_THAT <ESC> <:>
        60  KEYIN ESC||'U' IS CMD||'COPY STRING '''' OVER REPEAT SELECT ''''%V(27)%V(13)%V(27)V''%V(18)%V(27)>
            ' "*K* SUBSTITUTE <F3>

 11:05 NOV 14 '97 VDP_MACRO_C                              VDP_MACRO_C           Page 22
         1  /*M* XUI_MACRO_C:  MACRO for XUI$IMP.  */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7  %MACRO XUI_IMP ( FPTN=XUI_IMP,
         8                   STCLASS=STATIC,
         9                   IMP_BUFFER=NIL,
        10                   IMP_BUFFER_OFFSET=0,
        11                   KEY_NAME=NIL,
        12                   KEY_VALUE=NIL,
        13                   PRIMARY(YES='1'B,NO='0'B,ANY)='0'B,
        14                   SECONDARY(YES='1'B,NO='0'B,ANY)='0'B,
        15                   INPUT_OPTION(YES='1'B,NO='0'B,ANY)='0'B,
        16                   FLUSH(YES='1'B,NO='0'B,ANY)='0'B,
        17                   CTRSTR(YES='1'B,NO='0'B,ANY)='0'B,
        18                   FNCKEY(YES='1'B,NO='0'B,ANY)='0'B,
        19                   IMPDCB=M$UC );
        20
        21   %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
        22   %IF (SUBSTR(STR,0,6)='STATIC') OR
        23   (SUBSTR(STR,0,8)='CONSTANT') OR
        24   (SUBSTR(STR,0,3)='EXT');
        25   %LSET INIT=CHARTEXT('INIT');
        26   %LSET EINIT=CHARTEXT('');
        27   %ELSE;
        28   %LSET INIT=CHARTEXT('/*');
        29   %LSET EINIT=CHARTEXT('*/');
        30   %ENDIF;
        31
        32  DCL 1 FPTN STCLASS,
        33        2 IMP_BUFFER_ VECTOR %INIT(VECTOR(IMP_BUFFER))%EINIT,
        34              /*K* IMP_BUFFER = VARIABLE specifies a variable which
        35              will be used to buffer the IMP records to be sent to
        36              the FEP.  If a call to XUI$IMP would cause overflow
        37              of the buffer, or if XUI$IMP.FLUSH# is set, the record

 11:05 NOV 14 '97 VDP_MACRO_C                              VDP_MACRO_C           Page 23
        38              is written.
        39              */
        40        2 %CHARTEXT('IMP_BUFFER_OFFSET') SBIN %INIT(IMP_BUFFER_OFFSET)%EINIT,
        41              /*K* IMP_BUFFER_OFFSET = VALUE(0-n) is a returned value
        42              of the current number of bytes currently buffered into
        43              XUI_IMP.IMP_BUFFER_.  This value should be INIT'ed to
        44              zero before the first call to XUI$IMP.
        45              */
        46        2 KEY_NAME$ PTR %INIT(ADDR(KEY_NAME))%EINIT,
        47              /*K* KEY_NAME = VARIABLE specifies a variable containing
        48              a TEXTC-format of the key sequence to be IMPed.  It may
        49              or may not contain an introducer as the first character
        50              of its text.
        51              */
        52        2 KEY_VALUE$ PTR %INIT(ADDR(KEY_VALUE))%EINIT,
        53              /*K* KEY_VALUE = VARIABLE specifies a variable containing
        54              a TEXTH-format of the key sequence which KEY_NAME is to
        55              be IMPed to.
        56              */
        57        2 PRIMARY# BIT(1) %INIT(PRIMARY)%EINIT,
        58              /*K* PRIMARY = VALUE-BIT(1) specifies whether or not
        59              the key to be defined is to be associated with the
        60              primary introducer.  The default is NO.
        61              */
        62        2 SECONDARY# BIT(1) %INIT(SECONDARY)%EINIT,
        63              /*K* SECONDARY = VALUE-BIT(1) specifies whether or not
        64              the key to be defined is to be associated with the
        65              secondary introducer.  The default is NO.
        66              */
        67        2 INPUT_OPTION# BIT(1) %INIT(INPUT_OPTION)%EINIT,
        68              /*K* INPUT_OPTION = VALUE-BIT(1) specifies whether or
        69              not the key is to be defined with the INPUT option.
        70              the default is NO.
        71              */
        72        2 FLUSH# BIT(1) %INIT(FLUSH)%EINIT,
        73              /*K* FLUSH = VALUE-BIT(1) specifies whether or
        74              not XUI_IMP.IMP_BUFFER_ is to be flushed after buffering

 11:05 NOV 14 '97 VDP_MACRO_C                              VDP_MACRO_C           Page 24
        75              the current KEY_NAME.
        76              */
        77        2 CTRSTR# BIT(1) %INIT(CTRSTR)%EINIT,
        78              /*K* CTRSTR = {YES|NO} specifies whether the first byte of
        79              KEY_NAME is a control-string identifier.
        80              */
        81        2 FNCKEY# BIT(1) %INIT(FNCKEY)%EINIT,
        82              /*K* FNCKEY = {YES|NO} specifies that the first byte of
        83              KEY_NAME is a function-key identifier.
        84              */
        85        2 * BIT(12) %INIT('0'B)%EINIT,
        86        2 IMPDCBNUM# UBIN HALF HALIGNED %INIT(DCBNUM(IMPDCB))%EINIT,
        87              /*K* IMPDCB = VALUE-DCBNAME specifies the DCBNAME
        88              to write the IMP record through.  The default is
        89              M$UC.
        90              */
        91          %VLP_ERRCODE ( LVL=2, FPTN=ERRCODE, STCLASS=" " );
        92              /*K* ERRCODE = VALUE-BIT(36) is a standard VLP_ERRCODE
        93              specifying the error condition upon ALTRET from
        94              XUI$IMP.
        95              */
        96  DCL 1 FPTN%CHARTEXT('_FLG ')REDEF FPTN,
        97        2 *(0:4) SBIN,
        98        2 F BIT(18),
        99              /*K* FPTN_FLG.F = VALUE-BIT(18) redefed for convenient
       100              initialization at runtime of all {YES|NO} items.
       101              */
       102        2 *(0:9) CHAR(1);
       103  %MEND;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 25
         1  /*M* VD_MACROS_M - Macros and Equates for 6Edit */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /*X* MCR=NO, DMC=YES */
         9
        10  /*P*
        11  NAME:   VD_MACROS_M
        12  PURPOSE:
        13          Declare macros and equates for 6Edit.
        14  DESCRIPTION:
        15          This module contains all preprocessor declarations used by
        16          6Edit, except for parse node codes and error codes, which are
        17          in VD_NODES_E and VD_PERR_E, respectively.
        18
        19          Prior to B00, most of the 6Edit data structures were defined
        20          abstractly in the Interface Description Language (IDL) which,
        21          when compiled, produced a pair of PL-6 source files, one for
        22          macros and one for equates.  There was another pair of files
        23          (again, one for macros and one for equates) that contained
        24          hardcoded declarations of things that, for one reason or
        25          another, could not be represented in IDL.  This tended to make
        26          it difficult for anyone but the original author to know where
        27          to find things, or to figure out wjat a given structure really
        28          looked like.  For these and other reasons, all four of these
        29          files have been collapsed into this one for B00.  Free-form
        30          commentary from the original IDL source has been folded into
        31          the IDL-generated macro file, and the contents of the other
        32          files have been merged in at what seemed like appropriate
        33          points.  Most of the oddities that exist in this module can be
        34          traced to this hodgepodge method of derivation.
        35  */
        36
        37  /********************************************************

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 26
        38  *                                                       *
        39  *               Equates                                 *
        40  *                                                       *
        41  ********************************************************/
        42
        43  /*
        44  *   General definitions
        45  */
        46  %EQU FOREVER = CHARTEXT('WHILE (''1''B)');
        47  %EQU NEVER = CHARTEXT('WHILE (''0''B)');
        48  %EQU TRUE = '1'B;
        49  %EQU FALSE = '0'B;
        50  %EQU CLEAR = '0'B;
        51  %EQU INFINITY = BITBIN('377777777777'O);    /* Max SBIN WORD value */
        52  %EQU HALF_INFINITY = BITBIN('377777'O);     /* Max SBIN HALF value */
        53  %EQU XUM_WORDS# = 1;    /* Allocate storage in words (X$ALLOCATE) */
        54
        55  /*
        56  *   Cardinal numbers:  quantities of things
        57  */
        58  %EQU N_PATTERN_ENTRIES_INCR = 20;   /* Nominal # pattern entries */
        59  %EQU N_PATT_STACK_ENTRIES_INCR = 20; /* Nominal # pattern stack entries */
        60  %EQU N_LOCATION_XLATES = 20;    /* Nominal # VD$XLATE_LOCATIONS.XLATES */
        61  %EQU N_FREE_DCB_ENTRIES = 20;   /* Max # free DCBs to remember */
        62
        63  /*
        64  *   Numbers of words or bytes
        65  */
        66  %EQU NW_PARSE_WORK = 100;       /* # words to expand parse workspace by */
        67  %EQU NW_EVAL_WORK = 150;        /* # words to expand X$EVAL workspc by */
        68  %EQU NW_DATA_SEG_INCR = 1024;   /* # words to expand dataseg by */
        69  %EQU NW_FSA_DATA_BUFFER = 1024; /* # words in Fast Sequential buffer */
        70  %EQU NW_FSA_KEY_BUFFER = 1024;  /* # words in Fast Sequen key buffer */
        71  %EQU NB_PER_WORD = 4;           /* # bytes per word */
        72  %EQU NB_VERSION = 6;            /* # chars in B_VERSION */
        73  %EQU NB_NUMERIC_KEY = 3;        /* # bytes in consec key and edit key */
        74  %EQU NB_RESERVED_WORD_ABBREV = 2; /* # chars in keywrd abbreviations */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 27
        75  %EQU NB_DFLT_DATA_REC = 256;    /* Default # chars in data-rec */
        76  %EQU NB_STATIC_TEMP = 1024;     /* # bytes in VD_STATIC_TEMP */
        77  %EQU NB_NON_DISP_FMT = 7;       /* # chars to format a non-display char */
        78
        79  /*
        80  *   Minimum cardinal numbers:  minimum quantities of things
        81  */
        82  %EQU MN_SCREEN_EDITING_HEIGHT = 3;  /* Min # terminal lines to screen edit */
        83  %EQU MN_EDITKEY_FRACT = 1;      /* Mn value of editkey fraction */
        84  %EQU MN_EDITKEY = 0;            /* Mn value for an edit key */
        85  %EQU MN_CONSEC_KEY = 1;         /* Key of 1st rec in a consec-file key */
        86  %EQU MN_SKIP_COUNT = 0;         /* Mn SKIP count */
        87  %EQU MN_REPEAT_COUNT = 0;       /* Mn REPEAT count */
        88
        89  /*
        90  *   Minimum numbers of words or bytes
        91  */
        92  %EQU MNNW_DYN_STORAGE = 2;      /* Mn # words X$ALLOCATE can fragment */
        93
        94  /*
        95  *   Maximum cardinal numbers:  maximum quantities of things
        96  */
        97  %EQU MX_BYTE_VALUE = 511;   /* Mx number in 1 byte */
        98  %EQU MX_EDITKEY_INTEGER = 99999;    /* Mx value of editkey integer */
        99  %EQU MX_EDITKEY_FRACT = 999;    /* Mx value of editkey fract */
       100  %EQU MX_EDITKEY = (MX_EDITKEY_INTEGER * 1000) + MX_EDITKEY_FRACT + 1;
       101  %EQU MX_KEY_INCR = 65534;   /* VLP_EDTCTL.KEYINCR limitation */
       102  %EQU MX_SERIAL_NUMS = 8;        /* Mx # serial #'s in fid */
       103  %EQU MX_STATS_ENQ_WAIT = 5;     /* Mx seconds to M$ENQ on stats-file */
       104  %EQU MX_PATT_SYMBOLS = MX_BYTE_VALUE; /* Mx # "symbols" in pattern expr */
       105  %EQU MX_INT_RESPONSE = 2010;    /* Mx # millisec til detect BREAK, etc. */
       106  %EQU MX_CTRL_FN_ARGS = 2;       /* Mx # args to a $CONTROL function */
       107  %EQU MX_CONSEC_RECORDS = %BITBIN('0777777777'O); /* Mx # recs in consec file */
       108  %EQU MX_ACCESS_LEVELS = 5;      /* Mx # levels in predef accessing structures */
       109  %EQU MX_LOCATION_LEVELS = MX_ACCESS_LEVELS-1; /* Mx#lvls in VD$LOCATION.KEY (no filelvl) */
       110  %EQU MX_STRUCTURE_LEVELS = 5;   /* Mx # levels in any (pre/user def) VD$STRUCTURE */
       111  %EQU MX_SPEC_TYPES = 20;    /* Mx # %SPT_ definitions */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 28
       112  %EQU MX_COMMAND_PARAMS = 9; /* Mx # params for non-editing commands */
       113  %EQU MX_SKIP_COUNT = %BITBIN('0377777'O);   /* Mx SKIP value */
       114  %EQU MX_REPEAT_COUNT = %BITBIN('377777'O);  /* Mx REPEAT SELECT value */
       115  %EQU MX_CONTEXT_ACCT_LIST = 8;      /* Max # accts in context file search */
       116  %EQU MX_CMD_OBJECTS = 50;   /* Mx # dyn-alloc'd misc. objects for cmd */
       117  %EQU MX_TERMINAL_POSITION = 254;    /* Mx value for FEP parameters */
       118  %EQU MX_WILD_STRINGS = 10;    /* Mx number of matching wildcards */
       119  %EQU MX_EDITING_WINDOWS = 10;  /* Mx # editing windows */
       120  %EQU MX_TAB_STOPS = 31;         /* VLP_TABS has (0:30) for stops */
       121
       122  /*
       123  *   Maximum numbers of words or bytes
       124  */
       125  %EQU MXNW_SMALL_SEGMENT_CHUNK = 11; /* Mx wds/chunk in "small" dyn sgmnt */
       126  %EQU MXNW_FIT = 1024;           /* Mx # words in a file's FIT */
       127  %EQU MXNB_FID = 68;             /* Mx # bytes in a fid */
       128  %EQU MXNB_FILE_NAME = 31;       /* Mx # bytes in name portion of fid */
       129  %EQU MXNB_FILE_ACCT = 8;        /* Mx # bytes in account portion of fid */
       130  %EQU MXNB_PROFILE_NAME = 11;    /* Mx # bytes in a PROFILE name */
       131  %EQU MXNB_KEY = 255;            /* Mx # bytes in key component of node */
       132  %EQU MXNB_SPEC = 511;           /* Mx # bytes in spec component of node */
       133  %EQU MXNB_DATA = 2048;          /* Mx # bytes in data component of node */
       134  %EQU MXNB_COMMAND = 2048;       /* Mx # bytes in cmd or READ-file rec */
       135  %EQU MXNB_BUFFER = BITBIN('377777777'O); /* Mx # bytes in VD$BUFFER.BYTES */
       136  %EQU MXNB_RESERVED_WORD = 15;   /* Mx # chars in reserved words */
       137  %EQU MXNB_NAME = 31;            /* Mx # bytes in a name */
       138  %EQU MXNB_NAME_VALUE = 511;     /* Mx # bytes in a TEXTC name's value */
       139  %EQU MXNB_STRING_LOCAL = 3;     /* Mx len string to store in-line */
       140  %EQU MXNB_IMP_TEXT = 255;       /* Mx # bytes in IMP input oper text */
       141  %EQU MXNB_IMPOU_REC = 1024;     /* Mx # bytes in IMP object record */
       142  %EQU MXNB_CHARBIN = 63;         /* Hardware limit: mx # bytes for CHARBIN */
       143  %EQU MXNB_NUM_LITERAL = MXNB_CHARBIN;   /* Mx # bytes in numeric lit */
       144  %EQU MXNB_NUM_DISPLAY = 13;     /* Mx # bytes for BINXCHAR */
       145  %EQU MXNB_ERR_SUBST = 31;   /* Mx # chars in error msg substitution (%Un) */
       146  %EQU MXNB_EDITKEY_INTEGER = 5;  /* Mx # chars in displayed editkey int */
       147  %EQU MXNB_EDITKEY_FRACT = 3;    /* Mx # chars in displayed editkey fract */
       148  %EQU MXNB_DW = 31;          /* Mx # chars in displayed words (VD_DW_ tables) */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 29
       149  %EQU MXNB_$COMMENT = 2;         /* Mx # bytes in $COMMENT value */
       150  %EQU MXNB_$CONTROL = 2;         /* Mx # bytes in $CONTROL value */
       151  %EQU MXNB_DFLT_BLKEXPR = 31;    /* Mx # bytes in blkexpr predef names */
       152  %EQU MXNB_$INTRO = 2;           /* Mx # bytes in $INTRO_1/$INTRO_2 */
       153  %EQU MXNB_$PAD = 100;           /* Mx # bytes in $PAD value */
       154  %EQU MXNB_$RESTORE = 100;       /* Mx # bytes in $RESTORE value */
       155  %EQU MXNB_$EOF_MARK = 80;        /* Mx # bytes in $EOF_MARK value */
       156
       157  /*  Find an appropriate place for this */
       158  %EQU  BNR_ON_1_REC = 1;      /* Both Start and End on one (1) record. */
       159  %EQU  BNR_ON_2_RECS = 2;     /* Both Start and End two (2) records. */
       160  /*
       161  *   Levels in file structures.
       162  */
       163  %EQU LVL_FILE = 0;      /* "File-level" for all file structures */
       164  %EQU LVL_LOWER = 1;     /* First level below file-level */
       165  %EQU LVL_EXT_REC = 1;   /* "Record-level" for external files */
       166
       167  /* Functions only recognized in value of SETUP_6EDIT command variable */
       168  %EQU SETUP_FN_PROFILE = '>P';   /* Alternatively replace with term profile */
       169  %EQU SETUP_FN_USER = '>U';      /* Replace with user name from JIT */
       170
       171  /*
       172  *   ASCII character strings
       173  */
       174  %EQU CHR_ESC = BINASC(27);
       175  %EQU CHR_MSK_TO_UPPER_CASE = '137'O;    /* Mask to force upper case */
       176  %EQU CHR_NON_DISPLAYABLE = '.';     /* Must be '.' for B$XL_ASC_DUMP */
       177  %EQU CHR_BAD_VALUE = '??';          /* Subst string for bad values */
       178  %EQU CHR_PLURAL = 'S';      /* Most common word ending meaning plural */
       179  %EQU CHR_IBEX_PROMPT = '!';     /* IBEX command processor prompt */
       180  %EQU CHR_IBEX_XEQ_VERB = 'XEQ'; /* IBEX command processor XEQ command */
       181
       182  %EQU CHR_FIRST_DISPLAYABLE = ' ';
       183  %EQU CHR_SPACE = ' ';
       184  %EQU CHR_DOLLAR = '$';
       185  %EQU CHR_LPAREN = '(';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 30
       186  %EQU CHR_RPAREN = ')';
       187  %EQU CHR_COMMA = ',';
       188  %EQU CHR_DASH = '-';
       189  %EQU CHR_MINUS = '-';       /* Negative sign from BINXCHAR */
       190  %EQU CHR_PERIOD = '.';
       191  %EQU CHR_UNDERSCORE = '_';
       192  %EQU CHR_LAST_DISPLAYABLE = '~';
       193
       194  /*  Syntax characters for formatting a fid */
       195  %EQU CHR_FID_RES = '#';     /* Follows resource field */
       196  %EQU CHR_FID_SN = '/';      /* Follows packset name or serial #s */
       197  %EQU CHR_FID_ACCT = '.';    /* Precedes account */
       198
       199  /*  External file names, types, etc. */
       200  %EQU CHR_PROMPT = '*';                  /* Prompt for commands */
       201  %EQU CHR_CMDVAR_NAME = 'SETUP_6EDIT';   /* Name of IBEX cmdvar */
       202  %EQU CHR_DATA_FILE_TYPE = 'SE'; /* File type for user data files */
       203  %EQU CHR_TEMP_FILE = '*';               /* 1st char of temp file names */
       204  %EQU CHR_CONTEXT_NAME = CONCAT(':6EDIT_CONTEXT', SETUP_FN_PROFILE);
       205  %EQU CHR_LIBRARY_ACCT = ':LIBRARY';     /* Global context file account */
       206  %EQU CHR_ENCODED_TYPE = 'We';           /* Encoded file type */
       207  %EQU CHR_ENCODED_RECID = '6Edit encoded';   /* Id in all encoded records */
       208  %EQU CHR_ERRFILE_NAME = ':VDERRMSG';    /* Error msg file name */
       209  %EQU CHR_STATS_SITE_A = 'LADC L66A';    /* Sitenames at which to... */
       210  %EQU CHR_STATS_SITE_B = 'LADC L66B';    /* ... gather statistics */
       211  %EQU CHR_STATS_ACCT = ':VDDVGN';  /* Statistics file account */
       212  %EQU CHR_STATS_NAME = ':VD_STATS';  /* Statistics file name */
       213  %EQU CHR_STATS_PASS = 'Yggdrasl';   /* Protect against accidents */
       214  %EQU CHR_STATS_TYPE = 'De';         /* Statistics file type */
       215  %EQU CHR_STATS_RNAME = ':VD_STATS'; /* Stats file M$ENQ name */
       216  %EQU CHR_CONT_CMD_NAME = '*CONTINUATION_COMMANDS';  /* IBEX cont. filename */
       217  %EQU CHR_DCB_PREFIX = 'M$6E';       /* Fixed prefix of editing DCB names */
       218  %EQU CHR_INCANTATION = 'Oh, Kitty, how nice it would be if we could only get through into Looking-
            glass House!';
       219
       220  /*
       221  *   6Edit Keywords (KW_) and keyword abbreviations (KWA_)

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 31
       222  */
       223  %EQU KW_FILE = 'FILE';
       224  %EQU KWA_FILE = 'FI';
       225  %EQU KW_READ = 'READ';
       226  %EQU KW_SYNONYM = 'SYNONYM';
       227  %EQU KWA_SYNONYM = 'SY';
       228
       229  /*
       230  *   "Display Words":  Words substituted into error messages and
       231  *       other displayed text.
       232  *   Note that keywords substituted into error messages should be in upper case,
       233  *       to distinguish them from the rest of the error message.  However,
       234  *       keywords used in format displays (see VDG$FORMAT_xxx) should be in
       235  *       lower-case or initial-caps, to distinguish them from the rest of the
       236  *       display (fids, etc) which are usually in upper-case.  %DWLC_ names
       237  *       are used for these format displays.
       238  */
       239  %EQU DW_ANY = 'ANY';
       240  %EQU DW_AO = 'AO';
       241  %EQU DW_BACKWARD = 'BACKWARD';
       242  %EQU DW_BO = 'BO';
       243  %EQU DW_CONSEC = 'CONSEC';
       244  %EQU DWLC_CURR = 'Curr';
       245  %EQU DW_DATA = 'DATA';
       246  %EQU DW_DONT = 'DONT';
       247  %EQU DW_EO = 'EO';
       248  %EQU DW_EQUALS = 'EQUALS';
       249  %EQU DWLC_FILE = 'File';
       250  %EQU DW_FORWARD = 'FORWARD';
       251  %EQU DW_INDEXED = 'INDEXED';
       252  %EQU DW_KEY = 'KEY';
       253  %EQU DW_KEYED = 'KEYED';
       254  %EQU DW_KEYIN = 'KEYIN';
       255  %EQU DW_LOCATION = 'LOCATION';
       256  %EQU DW_NEW = 'NEW';
       257  %EQU DW_NUMBER = 'NUMBER';
       258  %EQU DW_OFF = 'OFF';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 32
       259  %EQU DW_OLD = 'OLD';
       260  %EQU DW_ON = 'ON';
       261  %EQU DWLC_POSITION = 'position';
       262  %EQU DW_PROTECT = 'PROTECT';
       263  %EQU DW_SEQUENTIAL = 'SEQUENTIAL';
       264  %EQU DW_SPEC = 'SPEC';
       265  %EQU DW_STRING = 'STRING';
       266  %EQU DW_SYNONYM = 'SYNONYM';
       267  %EQU DWLC_THRU = 'thru';
       268
       269  /*
       270  *   Level Names for the predefined Structures.
       271  *   These act just like reserved words, with 2-character abbreviations.
       272  */
       273  %EQU LVN_FILE = 'FILE';         /* Level 0 of all Structures */
       274  %EQU LVN_RECORD = 'RECORD';     /* Level 1 of External and Scratch */
       275  %EQU LVN_NAME = 'NAME';         /* Level 1 of Names */
       276  %EQU LVN_STRUCTURE = 'STRUCTURE';   /* Level 1 of Structures */
       277  %EQU LVN_LEVEL = 'LEVEL';           /* Level 2 of Structures */
       278  %EQU LVN_WINDOW = 'WINDOW';     /* Level 1 of Windows */
       279  %EQU LVN_BLOCK = 'BLOCK';       /* Level 2 of Windows */
       280
       281  /*
       282  *   $CONTROL-function ids.
       283  */
       284  %EQU FNID_VALUE = 'V';          /* Byte value */
       285  %EQU FNID_RECORD = 'R';         /* Record boundary */
       286  %EQU FNID_CURRENT = 'C';        /* CURRENT (EditBlock) boundary (pattern) */
       287  %EQU FNID_WILD_STRING = '?';        /* Wildcard string (pattern) */
       288  %EQU FNID_WILD_CHAR = 'W';          /* Wildcard char (pattern) */
       289  %EQU FNID_SET_OF_SEQUENCES = 'S';   /* Set of sequences (pattern) */
       290  %EQU FNID_BO_MATCH = 'B';       /* BO match is here (pattern) */
       291  %EQU FNID_EO_MATCH = 'E';       /* EO match is here (pattern) */
       292
       293  /*
       294  *   Character class codes.
       295  *   Used when scanning tokens.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 33
       296  */
       297  %EQU CCL_WHSP = 0;  /* "White space": blanks, non-displayable chars */
       298  %EQU CCL_SPEC = 1;  /* Special characters */
       299  %EQU CCL_DOT = 2;   /* Period char; can be in numbers but not names */
       300  %EQU CCL_RES = 3;   /* Reserved characters:  ' ( ) , ; ? */
       301  %EQU CCL_NUM = 4;   /* Numeric chars:  0-9 */
       302  %EQU CCL_NAME = 5;  /* Name chars:  A-Z, a-z, #, $, @, _ */
       303
       304  /*
       305  *   Default (initial) values
       306  */
       307  %EQU DFLT_$BY = 10000;          /* Initial record key increment = 10.000 */
       308  %EQU DFLT_$COMMENT = '"';       /* Initial comment delimiter */
       309  %EQU DFLT_$CONTROL = '%';       /* Initial control-function introducer */
       310  %EQU DFLT_$DEFAULT_DEST = 'THAT';   /* Initial dest block-expression */
       311  %EQU DFLT_$DEFAULT_SOURCE = 'THAT'; /* Initial source block-expression */
       312  %EQU DFLT_$EZ_APPEND = 0; /* Initial value - Normal CP-6 standard */
       313  %EQU DFLT_$EOF_MARK = ' '; /* Initially, transparent eof marker */
       314  %EQU DFLT_$HSCROLL = 0;         /* Initial horiz scroll shift = center */
       315  %EQU DFLT_$INTRO_1 = CHR_ESC;   /* Initial primary introducer for IMP */
       316  %EQU DFLT_$KEY_GENERATION = 4 /* BIN10 */; /* Initial key gen algorithm */
       317  %EQU DFLT_$MATCH_LIMIT = 1;     /* Initial # recs for a pattern match */
       318  %EQU DFLT_$MAX_COMMAND_PCT = 50;    /* Percent of user-domain window */
       319  %EQU DFLT_$MAX_RECORD = MXNB_DATA;  /* Initial max record length */
       320  %EQU DFLT_$MIN_COMMAND = 2;     /* Mn # lines when reading from cmd window */
       321  %EQU DFLT_$MIN_RECORD = 1;      /* Initial min record length */
       322  %EQU DFLT_$PAD = CHR_SPACE;     /* Initial pad char for extending recs */
       323  %EQU DFLT_$REKEY = 100;         /* Initial max # local recs to auto-rekey */
       324  %EQU DFLT_$VSCROLL = 0;         /* Initial vert scroll shift = center */
       325  %EQU DFLT_$VSCROLL_MARGIN_PCT = 25; /* Pct vert scroll shift margin */
       326  %EQU DFLT_$WI_BORDER = '-';     /* Initial window border char */
       327  %EQU DFLT_$WI_PERCENT = 50;     /* Initial new-window percent of old window */
       328  %EQU DFLT_$WS_STORAGE = '"';     /* Workspace file storage class */
       329
       330  %EQU DFLT_SE_WINDOW_SPARE_PCT = 12;  /* % of ed window height for spare */
       331  %EQU DFLT_VFC = 'A';            /* Default VFC char */
       332

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 34
       333  /*
       334  *   Parameter for VDA$PFLUSH
       335  *   Tells whether Presenter should be told of any record updates.
       336  */
       337  %EQU TO_PRESENTER = '0'B;   /* Yes: tell Pres'r of changes */
       338  %EQU FROM_PRESENTER = '1'B; /* No: Pres'r originated change; don't retell */
       339
       340  /*
       341  *   Return codes from VDG$COMPARE_xxxx
       342  *   These tell how LOC_1 compares to LOC_2 or RANGE.
       343  *   Note how RCCL_LESS is less than RCCL_EQUAL
       344  *   And how RCCL_GREATER is greater than RCCL_EQUAL
       345  */
       346  %EQU RCCL_EQUAL = 0;        /* LOC_1 = LOC_2 */
       347  %EQU RCCL_LESS = -1;        /* LOC_1 < LOC_2 */
       348  %EQU RCCL_GREATER = 1;      /* LOC_1 > LOC_2 */
       349
       350  /*
       351  *   STEPCC values for FPT_EXIT/FPT_ERR
       352  */
       353  %EQU STEPCC_OK = 0;
       354  %EQU STEPCC_ERROR = 4;
       355
       356  /*
       357  *   SQ_ - Sequence flags for VDE$RPUT
       358  */
       359  %EQU SQ_PREVIOUS = 1;       /* Put the record before given key */
       360  %EQU SQ_CURRENT = 2;        /* Write the record using given key */
       361  %EQU SQ_NEXT = 3;           /* Put the record after given key */
       362
       363  /*
       364  *   EOM_ - Activation (EOM) characters
       365  */
       366  %EQU EOM_COMMAND = 3;           /* Ctrl-C - Goto command window */
       367  %EQU EOM_PREV_RECORD = 4;       /* Ctrl-D - Goto previous record (1Dim) */
       368  %EQU EOM_NEXT_ED_WINDOW = 14;   /* Ctrl-N - Goto next editing window */
       369  %EQU EOM_SPLIT_RECORD = 22;   /* Ctrl-V - Split record (1Dim) */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 35
       370  %EQU EOM_NEXT_RECORD = 10;      /* Linefeed - Goto next record (1Dim) */
       371  %EQU EOM_ED_WINDOW = 10;        /* Linefeed  - Goto curr ed win (2Dim) */
       372  %EQU EOM_NORMAL = 13;           /* CR - Normal activation; no action */
       373
       374  /*
       375  *   XLATE_ - Action specifiers for VDG$XLATE_LOCATIONS
       376  */
       377  %EQU XLATE_BUILD = 1;   /* Build VD$XLATE_LOCATIONS.ENTRIES */
       378  %EQU XLATE_LOCATION = 2;    /* Xlate according to .ENTRIES */
       379
       380  /*
       381  *   RF_ - "Read from" codes
       382  *   Specify which class of window we will read from next.
       383  */
       384  %EQU RF_DONT_CARE = 0;      /* Don't care */
       385  %EQU RF_COMMAND_WINDOW = 1;
       386  %EQU RF_EDITING_WINDOW = 2;
       387
       388  /*
       389  *   LCA_ - Last command-window activity
       390  *   Remembers what we've done to/with the command window.
       391  */
       392  %EQU LCA_READ = 1;          /* Read from command window */
       393  %EQU LCA_1_INFO_WARN = 2;   /* Displayed 1 info or warning error message */
       394  %EQU LCA_UNACKD_ERROR = 3;  /* Displayed errmsg requiring ACK=force cwin rd */
       395  %EQU LCA_SWITCH = 4;        /* Switched away to read from another window */
       396
       397  /*
       398  *  Predefined Structure names:  keys of level-1 nodes of Structures file
       399  */
       400  %EQU STRUCT_EXTERNAL = 'External';
       401  %EQU STRUCT_EDITKEY = 'Editkey';
       402  %EQU STRUCT_SEQUENTIAL = 'Sequential';
       403  %EQU STRUCT_STRINGKEY = 'Stringkey';
       404  %EQU STRUCT_NAMES = 'Names';
       405  %EQU STRUCT_SCRATCH = 'Scratch';
       406  %EQU STRUCT_STRUCTURES = 'Structures';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 36
       407  %EQU STRUCT_WINDOWS = 'Windows';
       408
       409  /*
       410  *   WK_ - Window keys
       411  *   These are keys of nodes in the Windows file.
       412  */
       413  %EQU WK_COMMAND_WINDOW = 0;     /* At level 1:  command window */
       414  %EQU WK_1ST_EDITING_WINDOW = 1; /* At level 1:  first editing window */
       415
       416  /*
       417  *   WI_ - Subscripts into the Data component (VD$BUFFER-chain) of all KEYINs
       418  *       and the "windowable" predefined EQUALS-names.  For example, to find
       419  *       the value of an EQUALS-name or a KEYIN-name for a window whose key is
       420  *       "n", first assume you'll use the value in the VD$BUFFER at the head of
       421  *       the chain of VD$BUFFERs for the name.  Then, follow the
       422  *       VD$BUFFER.FLINK$ pointer "n"+%WI_KEY_OFFSET times, as long as it's
       423  *       not NIL; if the window you're looking for is an editing window, and
       424  *       if you can follow the first .FLINK$ without getting NIL, then this
       425  *       second VD$BUFFER in the chain (whose "subscript" = %WI_EDITING) is now
       426  *       the assumed value.  If you don't get a NIL and finish the .FLINK$
       427  *       loop, then that's the VD$BUFFER to use for the name.
       428  */
       429  %EQU WI_ALL = 0;        /* "Subscript" of the value to use for all windows */
       430  %EQU WI_EDITING = 1;    /* "Subscript" of value for all editing windows */
       431  %EQU WI_KEY_OFFSET = 2; /* For specific window, add its key to this */
       432
       433
       434  /********************************************************
       435  *                                                       *
       436  *               Macros                                  *
       437  *                                                       *
       438  ********************************************************/
       439
       440  /*
       441  *   BOX
       442  *   Makes that cute little box around titles.
       443  *   Will even eject the page if you ask nicely.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 37
       444  */
       445  /*!C!*/
       446  %MACRO BOX(TITLE="",SPACEVALUE=1,PAGE=NO);
       447  %LSET LISTDIR='0'B;
       448  %LSET LISTMAC='1'B;
       449  %BOX_1(TITLE=TITLE,SPACEVALUE=SPACEVALUE,PAGE=PAGE);
       450  %MEND;
       451  %MACRO BOX_1(TITLE="",SPACEVALUE=1,PAGE=NO);
       452  %LSET LISTDIR='0'B;
       453  %LSET LISTSUB='1'B;
       454  %LSET LISTEXP='1'B;
       455  %IF TEXTCHAR(PAGE)='YES';
       456  %CHARTEXT(' ')
       457  %ELSE;
       458  %SPACE %SPACEVALUE;
       459  %ENDIF;
       460  %CHARTEXT('/***************************************************************************')
       461  %LSET BLANKS=' *                                                                         *';
       462  %CHARTEXT(BLANKS)
       463  %LSET LEN=LENGTHC(TEXTCHAR(TITLE));
       464  %LSET SEG1=CONCAT(SUBSTR(BLANKS, 0, (80 - LEN) / 2), TEXTCHAR(TITLE));
       465  %LSET SEG1=CHARTEXT(CONCAT(SEG1, SUBSTR(BLANKS, LENGTHC(SEG1))));
       466          %SEG1
       467  %LSET SEG1=0;
       468            %CHARTEXT(BLANKS)
       469  %LSET SEG1=0;
       470            %CHARTEXT(' ***************************************************************************/
            ')
       471  %SPACE %SPACEVALUE;
       472  %MEND;
       473  /*! !*/
       474
       475
       476  /*
       477  *   CLEARKEY
       478  *   Generates code to free a record key (VD$KEY structure).
       479  *   This macro makes the following assumptions:

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 38
       480  *       If the key's textc representation is REP_REMOTE, then KEY.V$
       481  *           points to a VD$TEXTC_REMOTE object (or a variant --
       482  *           any "string_object" will do).
       483  *   If the record key is an element of an array, use the INDX
       484  *       parameter to specify the index into the array.
       485  */
       486  %MACRO CLEARKEY (KEY="a VD$KEY structure", INDX=" ");
       487
       488  %LSET LPAR=CHARTEXT(' ');
       489  %LSET RPAR=CHARTEXT(' ');
       490  %IF TEXTCHAR(INDX)~=' ';
       491  %LSET LPAR=CHARTEXT('(');
       492  %LSET RPAR=CHARTEXT(')');
       493  %ENDIF;
       494
       495          IF KEY.REP# %LPAR INDX %RPAR = %REP_REMOTE THEN DO;
       496             CALL VDG$OFREE (KEY.V$ %LPAR INDX %RPAR ->VD$TEXTC_REMOTE)
       497             WHENALTRETURN DO; ALTRETURN; END;
       498             END;
       499          KEY %LPAR INDX %RPAR = %CLEAR;
       500
       501  %MEND;
       502
       503
       504  /*
       505  *   CLEARSPEC
       506  *   Generates code to free a record spec (VD$SPEC structure).
       507  *   This macro makes the following assumptions:
       508  *       If the spec's textc representation is REP_REMOTE, then SPEC.V$
       509  *           points to a VD$TEXTC_REMOTE object (or a variant --
       510  *           any "string_object" will do).
       511  *   If the record spec is an element of an array, use the INDX
       512  *       parameter to specify the index into the array.
       513  */
       514  %MACRO CLEARSPEC (SPEC="a VD$SPEC structure", INDX=" ");
       515
       516  %LSET LPAR=CHARTEXT(' ');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 39
       517  %LSET RPAR=CHARTEXT(' ');
       518  %IF TEXTCHAR(INDX)~=' ';
       519  %LSET LPAR=CHARTEXT('(');
       520  %LSET RPAR=CHARTEXT(')');
       521  %ENDIF;
       522
       523          IF SPEC.REP# %LPAR INDX %RPAR = %REP_REMOTE THEN DO;
       524             CALL VDG$OFREE (SPEC.V$ %LPAR INDX %RPAR ->VD$TEXTC_REMOTE)
       525             WHENALTRETURN DO; ALTRETURN; END;
       526             END;
       527          SPEC %LPAR INDX %RPAR = %CLEAR;
       528
       529  %MEND;
       530
       531
       532  /*
       533  *   COPYKEY
       534  *   Generates code to copy a record key (VD$KEY structure).
       535  *   This macro makes the following assumptions:
       536  *       If the key's textc representation is REP_REMOTE, then KEY.V$
       537  *           points to a VD$TEXTC_REMOTE object (or a variant --
       538  *           any "string_object" will do).
       539  *   If the record key is an element of an array, use the FINDX/TINDX
       540  *       parameter to specify the index into the array.
       541  */
       542  %MACRO COPYKEY (FKEY="a VD$KEY", FINDX=" ", TKEY="a VD$KEY", TINDX=" ");
       543
       544  %LSET FL=CHARTEXT(' ');
       545  %LSET FR=CHARTEXT(' ');
       546  %LSET TL=CHARTEXT(' ');
       547  %LSET TR=CHARTEXT(' ');
       548  %IF TEXTCHAR(FINDX)~=' ';
       549  %LSET FL=CHARTEXT('(');
       550  %LSET FR=CHARTEXT(')');
       551  %ENDIF;
       552  %IF TEXTCHAR(TINDX)~=' ';
       553  %LSET TL=CHARTEXT('(');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 40
       554  %LSET TR=CHARTEXT(')');
       555  %ENDIF;
       556
       557          TKEY %TL TINDX %TR = FKEY %FL FINDX %FR;
       558          IF FKEY.REP# %FL FINDX %FR = %REP_REMOTE THEN DO;
       559             CALL VDG$OCOPY (FKEY.V$ %FL FINDX %FR ->VD$TEXTC_REMOTE,
       560               TKEY.V$ %TL TINDX %TR)
       561             WHENALTRETURN DO; ALTRETURN; END;
       562             END;
       563
       564  %MEND;
       565
       566
       567  /*
       568  *   COPYSPEC
       569  *   Generates code to copy a record Spec component (VD$SPEC structure).
       570  *   This macro makes the following assumptions:
       571  *       If the Spec's textc representation is REP_REMOTE, then SPEC.V$
       572  *           points to a VD$TEXTC_REMOTE object (or a variant --
       573  *           any "string_object" will do).
       574  *   If the Spec component is an element of an array, use the FINDX/TINDX
       575  *       parameter to specify the index into the array.
       576  */
       577  %MACRO COPYSPEC (FSPEC="a VD$SPEC", FINDX=" ", TSPEC="a VD$SPEC", TINDX=" ");
       578
       579  %LSET FL=CHARTEXT(' ');
       580  %LSET FR=CHARTEXT(' ');
       581  %LSET TL=CHARTEXT(' ');
       582  %LSET TR=CHARTEXT(' ');
       583  %IF TEXTCHAR(FINDX)~=' ';
       584  %LSET FL=CHARTEXT('(');
       585  %LSET FR=CHARTEXT(')');
       586  %ENDIF;
       587  %IF TEXTCHAR(TINDX)~=' ';
       588  %LSET TL=CHARTEXT('(');
       589  %LSET TR=CHARTEXT(')');
       590  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 41
       591
       592          TSPEC %TL TINDX %TR = FSPEC %FL FINDX %FR;
       593          IF FSPEC.REP# %FL FINDX %FR = %REP_REMOTE THEN DO;
       594             CALL VDG$OCOPY (FSPEC.V$ %FL FINDX %FR ->VD$TEXTC_REMOTE,
       595               TSPEC.V$ %TL TINDX %TR)
       596             WHENALTRETURN DO; ALTRETURN; END;
       597             END;
       598
       599  %MEND;
       600
       601
       602  /*
       603  *   GETKEY
       604  *   Generates code to get the PTR to the textc string for a record key.
       605  *   This macro makes the following assumptions:
       606  *       If the key's textc representation is REP_REMOTE, then KEY.V$
       607  *           points to a VD$TEXTC_REMOTE structure (or a variant --
       608  *           any "string_object" will do).
       609  *   If the record key is an element of an array, use the INDX
       610  *       parameter to specify the index into the array.
       611  */
       612  %MACRO GETKEY (KEY="a VD$KEY structure", INDX=" ",
       613      PTR="an uninit PTR word");
       614
       615  %LSET LPAR=CHARTEXT(' ');
       616  %LSET RPAR=CHARTEXT(' ');
       617  %IF TEXTCHAR(INDX)~=' ';
       618  %LSET LPAR=CHARTEXT('(');
       619  %LSET RPAR=CHARTEXT(')');
       620  %ENDIF;
       621
       622          IF KEY.REP# %LPAR INDX %RPAR = %REP_REMOTE THEN
       623             PTR = ADDR (KEY.V$ %LPAR INDX %RPAR -> VD$TEXTC_REMOTE.LENGTH#);
       624          ELSE
       625             PTR = ADDR(KEY.V$ %LPAR INDX %RPAR);
       626
       627  %MEND;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 42
       628
       629
       630  /*
       631  *   GETSPEC
       632  *   Generates code to get the PTR to the textc string for the specification
       633  *       component of a record.
       634  *   This macro makes the following assumptions:
       635  *       If the spec's textc representation is REP_REMOTE, then SPEC.V$
       636  *           points to a VD$TEXTC_REMOTE structure (or a variant --
       637  *           any "string_object" will do).
       638  *   If the spec component is an element of an array, use the INDX
       639  *       parameter to specify the index into the array.
       640  */
       641  %MACRO GETSPEC (SPEC="a VD$SPEC structure", INDX=" ",
       642      PTR="an uninit PTR word");
       643
       644  %LSET LPAR=CHARTEXT(' ');
       645  %LSET RPAR=CHARTEXT(' ');
       646  %IF TEXTCHAR(INDX)~=' ';
       647  %LSET LPAR=CHARTEXT('(');
       648  %LSET RPAR=CHARTEXT(')');
       649  %ENDIF;
       650
       651          IF SPEC.REP# %LPAR INDX %RPAR = %REP_REMOTE THEN
       652             PTR = ADDR (SPEC.V$ %LPAR INDX %RPAR -> VD$TEXTC_REMOTE.LENGTH#);
       653          ELSE
       654             PTR = ADDR(SPEC.V$ %LPAR INDX %RPAR );
       655
       656  %MEND;
       657
       658
       659  /*
       660  *   INCREMENT
       661  *   Generates code to add 1 to a statistics counter.
       662  */
       663  %MACRO INCREMENT (BASE=VD_6E, ARRAY=STATS#, INDX="you must provide an index");
       664

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 43
       665          BASE.ARRAY (INDX) = BASE.ARRAY (INDX) + 1;
       666
       667  %MEND;
       668
       669
       670
       671  %SET LEVEL = 0;
       672
       673  /*
       674  *   Overview of 6Edit Structures
       675  *   ----------------------------
       676  *
       677  *   VD_6E.SOURCE.OPERAND.STREAM                 }  Info
       678  *                       .INTREE                 }  on
       679  *                       .EDIT_BLOCK             }  Source
       680  *                       .EVAL                   }  Operand
       681  *
       682  *   VD_CURRENT_WINDOW$->FILE_NODE.DESC.SPEC.V$->------.  }
       683  *           .-----------------------------------------"  }  Info
       684  *           `--->WINDOW_SPEC.OPERAND.STREAM              }  on
       685  *                                   .INTREE              }  Selected
       686  *                                   .EDIT_BLOCK          }  Operand
       687  *                                   .EVAL                }
       688  *
       689  *
       690  *   The Structures and Windows predefined files can never
       691  *   be migrated to disk:  the code needs direct access to their
       692  *   contents.  (Files in the History, Names, and Scratch directories
       693  *   start out internal *N* but may be migrated to external disk files
       694  *   if they get too big*N*.)
       695  *
       696  *   At initialization-time, we build and open Streams for all
       697  *       mandatory predefined files:  all Names files, the
       698  *       Structures file, and the Windows file.
       699  *       We need to know where these Streams are so we can write to
       700  *       the files as a side-effect of other operations, e.g.,
       701  *       to implicitly change the value of a predefined name,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 44
       702  *       or to update a window or structure spec, or to
       703  *       *N*write a history record*N*.
       704  *
       705  *
       706  *   The internal files are organized into directories; each
       707  *   directory has as its children files which share certain
       708  *   attributes:  physical or "accessor" structure,
       709  *   migratability, optional existence.
       710  *   The predefined directories and files are shown below:
       711  *
       712  *       VD_6E.WS.INTERNAL_DIR$->-----> VD$DIR_NODE--------->--.
       713  *                                      for History:           |
       714  *                                       file is:              |
       715  *                                        optional,            |
       716  *                                        migratable           |
       717  *                                         |   |               |
       718  *                                         v   v               |
       719  *                      (Level 0)        FileNode              |
       720  *                                       for History           |
       721  *                                       |  |  |  |            |
       722  *                                       v  v  v  v            |
       723  *                      (Level 1)        FileNodes...          |
       724  *
       725  *   .---------------------------------------------------------"
       726  *   |
       727  *   v
       728  *    VD$DIR_NODE---> VD$DIR_NODE---> VD$DIR_NODE---> VD$DIR_NODE
       729  *    for Names:      for Scratch:    for Structures: for Windows:
       730  *     files are:      files are:      file is:        file is:
       731  *      optional,       optional,       mandatory,      mandatory,
       732  *      migratable      migratable      resident        resident
       733  *         |               |               |               |
       734  *         v               v               v               v
       735  *    FileNodes       FileNodes...    VD$FILE_NODE    VD$FILE_NODE   (Level 0)
       736  *    for Equals,     for scratch     for Structures  for Windows
       737  *    Keyins,         files (eg,           |               |
       738  *    Locations,      Leftover,            |               |

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 45
       739  *    Synonyms        Source)         .----"          .----"
       740  *    |  |  |  |      |  |  |  |      |               |
       741  *    v  v  v  v      v  v  v  v      v               v
       742  *    FileNodes...    FileNodes...    FileNodes...    FileNodes...   (Level 1)
       743  *                                    |  |  |  |      |  |  |  |
       744  *                                    v  v  v  v      v  v  v  v
       745  *                                    FileNodes...    FileNodes...   (Level 2)
       746  *
       747  *
       748  *   Object class hierarchy
       749  *   ----------------------
       750  *   "Objects" are dynamically-allocatable data structures.  They are allocated
       751  *       by VDG$OALLOC, copied by VDG$OCOPY, and freed by VDG$OFREE.
       752  *   Each object belongs to a "class" (ala Smalltalk, Simula, etc.).  The object
       753  *       classes form a hierarchy.  This means that an object class below
       754  *       another in the hierarchy inherits some attributes (data fields) from
       755  *       the object class above it.  This "inheritance" is done very easily in
       756  *       IDL.
       757  *   Not all distinct object classes have distinct PL-6 data structures;
       758  *       some PL-6 data structures (VD$xxx) are used by several different
       759  *       object classes (CLS_xxx).
       760  *
       761  *   Below is the hierarchy of object classes.  The indentation reflects the
       762  *       super-class/sub-class relationship:
       763  *                   super-class
       764  *                       sub-classes of the super-class
       765  *       Entries below in all lower-case represent IDL node classes; entries
       766  *       in upper case without a VD$ or CLS_ are the names of both data
       767  *       structures (VD$<class_name>) and object class codes (CLS_<class_name>).
       768  *
       769  *       objects
       770  *           buffer_objects (VD$BUFFER_HEADER)
       771  *               BUFFER
       772  *                   CLS_BLOCK_BUFFER
       773  *               ENCODED_NODE
       774  *               NUMBER
       775  *                   CLS_NUMBER, CLS_BOOLEAN, CLS_FILE_STCLASS, CLS_ORG,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 46
       776  *                   CLS_KEY_TYPE, CLS_EXIST, CLS_NAME_DATA_TYPE, CLS_COMPONENT,
       777  *                   CLS_DIRECTION, CLS_POINT
       778  *               POINTER
       779  *                   CLS_PTR_INTREE, CLS_PTR_FILE_NODE, CLS_PTR_KEY,
       780  *                   CLS_PTR_LOCATION, CLS_PTR_TEXTC
       781  *           string_objects (VD$STRING_HEADER)
       782  *               TEXTC_REMOTE, FILE_KEY, NAME_SPEC, WINDOW_SPEC, WINDOW_BLOCK,
       783  *               STRUCTURE_SPEC, STRUCTURE_LEVEL
       784  *           array_objects (VD$ARRAY_OBJECT)
       785  *               *N* FIELD_DIR *N*, PATTERN, RECORD_SET, TABS, XLATE_LOCATIONS
       786  *           intree_node (VD$INTREE_NODE)
       787  *               IT_BLOCK_EXPR, IT_SELECT, IT_ADJUST, IT_OPERAND, IT_OPERATOR,
       788  *               IT_COMMAND
       789  *           (all other object classes are sub-classes of class "objects")
       790  *
       791  *   Most string_objects are things which can be Spec components
       792  *
       793  *   Most buffer_objects are things which can be Data components
       794  *
       795  *
       796  *   Workspace structures
       797  *   --------------------
       798  *   The following structures define the "workspace" the user is working
       799  *       with and the context in which commands are interpreted:
       800  *     VD_6E.SOURCE                 describes the current Source operand
       801  *     VD_6E.WS                     all we may save between sessions is
       802  *                                       linked off of this structure
       803  *
       804  *   The user`s "workspace":  all info that may be saved between sessions
       805  *       (at user`s option).
       806  *
       807  *   The workspace (but not Source operand) may be saved in a
       808  *       "workspace file".  This is a consecutive file with a
       809  *       specific file type.  Each record in the file contains one node
       810  *       from an internal file.  Included in each record are all objects
       811  *       pointed-to by the file node.
       812  *   All objects may refer to (point to) other objects, of course.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 47
       813  *       References to other objects in this workspace record
       814  *       are stored in the file as the word-offset
       815  *       into this record of the object referred-to.
       816  *       Objects stored in a record should never refer to other objects
       817  *       not also stored in this record.
       818  *   Each record in the workspace file has a common header:
       819  *       VD$ENCODED_NODE.  This is used to verify that its a valid
       820  *       workspace record, that we haven`t gotten out-of-step with
       821  *       the file, and which internal file node is saved
       822  *       in the record.
       823  *
       824  *   All internal files, including the predefined Names, Structures,
       825  *       and Windows files (and History if it`s internal), are pointed-to
       826  *       by the Workspace; these may be saved between sessions.
       827  *       Because of the way the workspace and all internal files
       828  *       are saved and loaded to/from the workspace file, each
       829  *       object pointed-to by an internal FileNode (key, spec, and
       830  *       data) must be pointed-to by one and only one other
       831  *       object.  There are some exceptions to this rule:
       832  *           Several objects (VD$BLOCK_DESC, VD$IT_BLOCK_EXPR,
       833  *               VD$STRUCTURE_SPEC) may point to a FileNode in the
       834  *               the Structures file.
       835  *               When the workspace is saved, these pointers are
       836  *               translated into record keys in the Structures file.
       837  *           VD$EVALs may point to nodes in the InTree for the window
       838  *               to which the VD$EVALs are attached.
       839  *               When the workspace is saved, these pointers are
       840  *               translated into node numbers, where the nodes
       841  *               of the InTree are numbered as you would walk the
       842  *               InTree, in prefix form (parent numbered before any
       843  *               any of its kids).
       844  *           VD$STREAMs are never saved in the workspace file.
       845  *               When the workspace is saved, these pointers are NILd.
       846  * *N* When certain internal files get too big (ie, History and all
       847  * *N*     scratch files), they can be migrated to external disk files.
       848  * *N*     When this happens, their entry in the INTERNAL_DIR chain is
       849  * *N*     removed, and they are accessed just like normal files to

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 48
       850  * *N*     be edited.
       851  */
       852
       853
       854  /*
       855  *   VD_6E
       856  *   Global static data block
       857  *   Contains pointers to internal files, statistics, and other information
       858  *   of global significance, including the following:
       859  *
       860  *   .INTERRUPT
       861  *       Contains state of processing of asynchronous interrupts.
       862  *       .STATE - State; essentially, the last interrupt we received or what type
       863  *           of activity we`re doing in case we get interrupted.
       864  *       .CMD_LINE - Command line read when asking user if s/he wanted to
       865  *           continue or not.
       866  *
       867  *   .SOURCE
       868  *       Global info for command evaluation of the Source operand.
       869  *   .WS.INTERNAL_DIR$ - Root of list of files that compose the savable
       870  *       workspace.
       871  *
       872  *   There are several STATS arrays.
       873  *   VD_6E.STATS (the general STATS array) counts all non-token,
       874  *       non-error, non-object events of interest.  Subscripts into this
       875  *       array are the %STG_ definitions given below.
       876  *   VD_6E.STATS_OBJECTS counts the number of allocations of each
       877  *       class of object.  Subscripts into this array are the %CLS_ definitions
       878  *       in VD_IDL_D.
       879  *   VD_6E.STATS_TOKENS counts the occurrences of tokens in the
       880  *       commands entered by the user.  Subscripts into this array are
       881  *       the %T_ definitions in VD_NODES0_E.
       882  *   VD_6E.STATS_ERRORS counts the issuance of each of the errors
       883  *       generated by 6Edit itself (ie, excluding monitor errors and
       884  *       library-routine errors).  Subscripts into this array are
       885  *       the %E$ definitions in VD_PERR_C.
       886  */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 49
       887  %MACRO VD_6E (NAME=VD_6E,
       888   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
       889   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
       890
       891  %IF TEXTCHAR(LEV) = 'AUTO';
       892     %LSET LEVEL = LEVEL + 1;
       893  %ELSE;
       894     %LSET LEVEL = LEV;
       895  %ENDIF;
       896
       897  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
       898  %IF LEVEL = 1;
       899  DCL 1 NAME DIM STCLASS ALIGNMENT,
       900   %LSET ENDCHAR = CHARTEXT(';');
       901  %ELSE;
       902   %(LEVEL) NAME DIM ALIGNMENT,
       903  %ENDIF;
       904
       905        %(LEVEL+1) HISTORY$ PTR,
       906        %(LEVEL+1) EQUALS$ PTR,
       907        %(LEVEL+1) LOCATIONS$ PTR,
       908        %(LEVEL+1) SYNONYMS$ PTR,
       909        %(LEVEL+1) KEYINS$ PTR,
       910        %(LEVEL+1) STRUCTURES$ PTR,
       911        %(LEVEL+1) WINDOWS$ PTR,
       912        %(LEVEL+1) STRUCTURE_EDITKEY$ PTR,
       913        %(LEVEL+1) STRUCTURE_EXTERNAL$ PTR,
       914        %(LEVEL+1) STRUCTURE_NAMES$ PTR,
       915        %(LEVEL+1) STRUCTURE_SCRATCH$ PTR,
       916        %(LEVEL+1) STRUCTURE_SEQUENTIAL$ PTR,
       917        %(LEVEL+1) STRUCTURE_STRINGKEY$ PTR,
       918        %(LEVEL+1) STRUCTURE_STRUCTURES$ PTR,
       919        %(LEVEL+1) STRUCTURE_WINDOWS$ PTR,
       920        %(LEVEL+1) WS,
       921          %(LEVEL+2) INTERNAL_DIR$ PTR,
       922        %(LEVEL+1) SOURCE,
       923          %VD$OPERAND (NAME=OPERAND, LEV="%(LEVEL+2)");

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 50
       924          %(LEVEL+2) MOVE BIT (1),
       925          %(LEVEL+2) WILD_STRINGS BIT (1),
       926          %(LEVEL+2) * BIT (34),
       927        %(LEVEL+1) WILD_STRINGS$ PTR,
       928        %(LEVEL+1) CMD_STREAM$ PTR,
       929        %(LEVEL+1) INTERRUPT,
       930          %(LEVEL+2) STATE# UBIN HALF HALIGNED,
       931          %(LEVEL+2) CMD_LINE$ PTR,
       932        %(LEVEL+1) ERR_HEAD$ PTR,
       933        %(LEVEL+1) ERR_TAIL$ PTR,
       934        %(LEVEL+1) PORT_HEAD$ PTR,
       935        %(LEVEL+1) PORT_TAIL$ PTR,
       936        %(LEVEL+1) STATS#(0:%STG_MX) SBIN WORD,
       937        %(LEVEL+1) STATS_OBJECTS#(0:%CLS_MX) SBIN WORD,
       938        %(LEVEL+1) STATS_TOKENS#(0:99) SBIN WORD,
       939        %(LEVEL+1) STATS_ERRORS#(0:299) SBIN WORD %ENDCHAR
       940
       941  %MEND;
       942
       943  /*
       944  *   INST_? - for VE_6E.INTERRUPT.STATE#
       945  *  Interrupt state:  what we`re doing regards asynchronous interrupts.
       946  */
       947  %EQU INST_PROCESSING = 1;           /*  Processing normally         */
       948  %EQU INST_READING = 2;              /*  Reading from user (any window) */
       949  %EQU INST_BREAK_QUEUED = 3;         /*  Waiting to acknowledge <BREAK> */
       950  %EQU INST_HW_TRAPPED = 4;           /*  Responding to hardware fault */
       951  %EQU INST_SCREECHING = 5;           /*  Preparing to die            */
       952
       953
       954  /*
       955  *   Subscripts into VD_6E.STATS arrays.
       956  */
       957  %EQU STG_BREAK_HIT = 1;         /* # Times BREAK hit */
       958  %EQU STG_READFILE_READS = 2;    /* # Records read from READ-files */
       959  %EQU STG_BLKEXPR_CMD = 3;       /* # Block-expr commands (no verb) */
       960  %EQU STG_BLOCK_IN_EDITBLOCK = 4;    /* # Block-exprs located in EditBlock */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 51
       961  %EQU STG_BLOCK_NIN_EDITBLOCK = 5;   /* # Blkexprs not in EditBlock/NEXT/PREV */
       962
       963  %EQU STG_EXPAND_SEG_SMALL = 10; /* # Expansions of small-chunk data segment */
       964  %EQU STG_EXPAND_SEG_LARGE = 11; /* # Expansions of large-chunk data segment */
       965  %EQU STG_EXPAND_EVAL = 12;      /* # Expansions of X$EVAL workspace */
       966
       967  %EQU STG_CTRL_LITERAL = 15;     /* # $CONTROL-Literal func invokes */
       968  %EQU STG_CTRL_VALUE = 16;       /* # $CONTROL-Value func invokes */
       969  %EQU STG_CTRL_RECORD = 17;      /* # $CONTROL-Record func invokes */
       970  %EQU STG_CTRL_CURRENT = 18;     /* # $CONTROL-CURRENT func invokes */
       971  %EQU STG_CTRL_WILD_CHAR = 19;   /* # $CONTROL-Wild char func invokes */
       972  %EQU STG_CTRL_WILD_STRING = 20; /* # $CONTROL-Wild string func invokes */
       973  %EQU STG_CTRL_SET_OF_SEQUENCES = 21; /* # $CONTROL-Set of seq func invokes */
       974  %EQU STG_CTRL_BO_MATCH = 22;    /* # $CONTROL-BO Match func invokes */
       975  %EQU STG_CTRL_EO_MATCH = 23;    /* # $CONTROL-EO Match func invokes */
       976
       977  %EQU STG_OPEN_EXT_FILE = 30;    /* # Opens to external files */
       978  %EQU STG_OPEN_INT_FILE = 31;    /* # Opens to internal files */
       979  %EQU STG_OPEN_PORT_SHARED = 32; /* # Opens to already-open port */
       980
       981  %EQU STG_NAME_READS = 35;       /* # VDA$LREADs on a names-file */
       982
       983  %EQU STG_LOC_STREAM_CURR = 40;  /* # Locations found in VD$STREAM.CURRENT */
       984  %EQU STG_LOC_STREAM_NEXT = 41;  /* # Times STREAM.NEXT was rolled to .CURR */
       985
       986  %EQU STG_ACC_PREADS = 50;           /* # Calls to VDA$PREAD */
       987  %EQU STG_ACC_PREAD_READS = 51;      /* # Calls to VDA$PREAD w/ READ flag set */
       988  %EQU STG_ACC_M$PFILS = 52;          /* # M$PFIL moncalls */
       989  %EQU STG_ACC_M$PRECORDS_SEQ = 53;   /* # M$PRECORD moncalls w/ KEYS=NO */
       990  %EQU STG_ACC_M$PRECORDS_KEYED = 54; /* # M$PRECORD moncalls w/ KEYS=YES */
       991  %EQU STG_ACC_M$READS_SEQ = 55;      /* # M$READ moncalls w/ KEYS=NO */
       992  %EQU STG_ACC_M$READS_KEYED = 56;    /* # M$READ moncalls w/ KEYS=YES */
       993  %EQU STG_ACC_INT_INSERTIONS = 57;   /* # Internal file nodes inserted */
       994  %EQU STG_ACC_INT_DELETIONS = 58;    /* # Internal file nodes deleted */
       995  %EQU STG_MX = 99;               /* Max index: (# ctrs in array) - 1 */
       996
       997

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 52
       998  /*
       999  *   VD$ACCESS_OPTIONS
      1000  *   Access options for a block:  how the user wants to access
      1001  *       the block.
      1002  *
      1003  *   STRUCTURE: Structure def to apply to file
      1004  *   LEVEL: Level of Structure to access file at
      1005  *   COMPONENT: "Component" option for block
      1006  *   PROTECT: "Protect" option for block
      1007  *   EXIST: "Existence" option for block
      1008  *   KEY_INCR: "Key increment" option for block
      1009  */
      1010  %MACRO VD$ACCESS_OPTIONS (NAME=VD$ACCESS_OPTIONS,
      1011   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1012   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1013
      1014  %IF TEXTCHAR(LEV) = 'AUTO';
      1015     %LSET LEVEL = LEVEL + 1;
      1016  %ELSE;
      1017     %LSET LEVEL = LEV;
      1018  %ENDIF;
      1019
      1020  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      1021  %IF LEVEL = 1;
      1022  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1023  %ELSE;
      1024   %(LEVEL) NAME DIM ALIGNMENT,
      1025  %ENDIF;
      1026
      1027        %(LEVEL+1) STRUCTURE$ PTR,
      1028        %(LEVEL+1) LEVEL# SBIN HALF HALIGNED,
      1029        %(LEVEL+1) COMPONENT# UBIN HALF HALIGNED,
      1030        %(LEVEL+1) PROTECT# UBIN HALF HALIGNED,
      1031        %(LEVEL+1) EXIST# UBIN HALF HALIGNED,
      1032
      1033        %VD$KEY (NAME=KEY_INCR, LAST=%LAST#);
      1034

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 53
      1035  %MEND;
      1036
      1037  /*
      1038  *   CO_? - EQUs for VD$ACCESS_OPTIONS.COMPONENT
      1039  */
      1040  %EQU CO_KEY = 1;                    /*  Look at Key component       */
      1041  %EQU CO_SPEC = 2;                   /*  Look at Spec component      */
      1042  %EQU CO_DATA = 3;                   /*  Look at Data component      */
      1043  %EQU CO_MX = CO_DATA;               /*  Maximum CO_? value          */
      1044
      1045  /*
      1046  *   CO_x_BIT - Bits corresponding to components.
      1047  *   Since PL6 doesn't support nested arrays, when we want an array
      1048  *       of bit-flags inside an array of something else, we must
      1049  *       declare the inner bit-flag-array as a bit-string instead.
      1050  *       This happens with bit-flags for components:  we sometimes
      1051  *       wand an array of bit-flags where each bit corresponds to a
      1052  *       node component (%CO_ defs); however, when we want this array
      1053  *       to appear inside an array of something else, we declare it
      1054  *       as a bit-string instead, and we use the following %CO_x_BIT
      1055  *       names to refer to the bit-flags for individual (or sets of)
      1056  *       components.
      1057  *   These bit-masks are intended for use with BIT(4) strings;
      1058  *       because of the way bit-strings are compared and assigned
      1059  *       (left-to-right, padded/truncated on right), these bit-masks
      1060  *       will work on longer bit-strings, but not on shorter ones.
      1061  */
      1062  %EQU CO_KEY_BIT = '0100'B;      /* %CO_KEY = 1 */
      1063  %EQU CO_SPEC_BIT = '0010'B;     /* %CO_SPEC = 2 */
      1064  %EQU CO_DATA_BIT = '0001'B;     /* %CO_DATA = 3 */
      1065  %EQU CO_ALL_BITS = CO_KEY_BIT | CO_SPEC_BIT | CO_DATA_BIT;
      1066
      1067  /*
      1068  *   PROTECT_? - EQUs for VD$ACCESS_OPTIONS.PROTECT_OPT
      1069  */
      1070  %EQU PROTECT = 1;
      1071  %EQU DONT_PROTECT = 2;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 54
      1072
      1073  /*
      1074  *   EX_? - EQUs for file existence state
      1075  */
      1076  %EQU EX_NEW = 1;                    /*  File must not exist; create it */
      1077  %EQU EX_OLD = 2;                    /*  File must currently exist   */
      1078  %EQU EX_ANY = 3;                    /*  Create if doesn't exist; use if does */
      1079
      1080
      1081  /*
      1082      VD$ARRAY_OBJECT
      1083      Objects which contain arrays.  The arrays in these objects can be
      1084          expanded or contracted, in two ways:
      1085          o The objects are allocated with a fixed maximum number of elements
      1086              in the array (.MX_ENTRIES), and a dynamic counter (.N_ENTRIES)
      1087              which indicates how many entries in the array are currently
      1088              occupied.  The array can be expanded and contracted up to
      1089              .MX_ENTRIES entries.
      1090          o If the array needs to be expanded beyond its allocated (.MX_ENTRIES)
      1091              size, then another array can be allocated and linked to the
      1092              first one (.FLINK).  Thus the array can expand as a dynamic-length
      1093              chain of linked fixed-size arrays.
      1094      All array objects have a common header as the first elements of their
      1095          PL-6 structure.
      1096  */
      1097  %MACRO VD$ARRAY_OBJECT (NAME=VD$ARRAY_OBJECT,
      1098   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1099   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1100
      1101  %IF TEXTCHAR(LEV) = 'AUTO';
      1102     %LSET LEVEL = LEVEL + 1;
      1103  %ELSE;
      1104     %LSET LEVEL = LEV;
      1105  %ENDIF;
      1106
      1107  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1108  %IF LEVEL = 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 55
      1109  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1110  %ELSE;
      1111   %(LEVEL) NAME DIM ALIGNMENT,
      1112  %ENDIF;
      1113
      1114        %VD$OBJECT_HEADER (NAME=OBJECT);
      1115        %(LEVEL+1) FLINK$ PTR,
      1116        %(LEVEL+1) N_ENTRIES# SBIN HALF HALIGNED,
      1117        %(LEVEL+1) MX_ENTRIES# SBIN HALF HALIGNED %ENDCHAR
      1118
      1119  %MEND;
      1120
      1121
      1122  /*
      1123  *   VD$BLOCK_DESC
      1124  *   Specification of a "block" of data.
      1125  *   The file key must always be given.
      1126  *   The two locations in RANGE must have the same number of keys (or
      1127  *       none at all).
      1128  *
      1129  *   FILE_KEY: Key of file (points to remote VD$FILE_KEY)
      1130  *   RANGE: Start and end locations of the block
      1131  *   OPTIONS: Access options for this block
      1132  */
      1133  %MACRO VD$BLOCK_DESC (NAME=VD$BLOCK_DESC,
      1134   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1135   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1136
      1137  %IF TEXTCHAR(LEV) = 'AUTO';
      1138     %LSET LEVEL = LEVEL + 1;
      1139  %ELSE;
      1140     %LSET LEVEL = LEV;
      1141  %ENDIF;
      1142
      1143  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      1144  %IF LEVEL = 1;
      1145  DCL 1 NAME DIM STCLASS ALIGNMENT,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 56
      1146  %ELSE;
      1147   %(LEVEL) NAME DIM ALIGNMENT,
      1148  %ENDIF;
      1149
      1150        %VD$OBJECT_HEADER (NAME=OBJECT);
      1151        %VD$KEY (NAME=FILE_KEY);
      1152        %VD$RANGE (NAME=RANGE);
      1153
      1154        %VD$ACCESS_OPTIONS (NAME=OPTIONS, LAST=%LAST#);
      1155
      1156  %MEND;
      1157
      1158  /*
      1159  *   Block Descriptor types
      1160  *   These indicate the type of a BlockDescriptor.
      1161  *   In the names below:
      1162  *       1_REC means "all on one record"
      1163  *       2_REC means "over 2 or more records"
      1164  *       POS, SPOS, and EPOS mean "both position values are",
      1165  *           "the starting position is", and "the ending position is",
      1166  *           respectively; this is followed by either:
      1167  *         0 meaning "equal to 0"; or
      1168  *         NON meaning "not equal to 0"
      1169  */
      1170  %EQU BDT_2_REC_POS_NON = 1;         /* >1 record, both POS~=0 */
      1171  %EQU BDT_2_REC_SPOS_NON_EPOS_0 = 2; /* >1 record, SPOS~=0, EPOS=0 */
      1172  %EQU BDT_2_REC_SPOS_0_EPOS_NON = 3; /* >1 record, SPOS=0, EPOS~=0 */
      1173  %EQU BDT_2_REC_POS_0 = 4;           /* >1 record, both POS=0 */
      1174  %EQU BDT_1_REC_POS_NON = 5;         /* 1 record, both POS~=0 */
      1175  %EQU BDT_1_REC_SPOS_NON_EPOS_0 = 6; /* 1 record, SPOS~=0, EPOS=0 */
      1176  %EQU BDT_1_REC_SPOS_0_EPOS_NON = 7; /* 1 record, SPOS=0, EPOS~=0 */
      1177  %EQU BDT_1_REC_POS_0 = 8;       /* 1 record, both POS=0 */
      1178  %EQU BDT_SPOS_NON_EOF = 9;      /* SPOS~=0 thru EOF */
      1179  %EQU BDT_SPOS_0_EOF = 10;       /* SPOS=0 thru EOF */
      1180  %EQU BDT_EOF_NOT_EOF = 11;      /* EOF thru NOT EOF */
      1181  %EQU BDT_EOF_EOF = 12;          /* EOF thru EOF */
      1182  %EQU BDT_NOT_BOF_BOF = 13;      /* NOT BOF thru BOF */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 57
      1183  %EQU BDT_BOF_EPOS_NON = 14;     /* BOF thru EPOS~=0 */
      1184  %EQU BDT_BOF_EPOS_0 = 15;       /* BOF thru EPOS=0 */
      1185  %EQU BDT_BOF_EOF = 16;          /* BOF thru EOF */
      1186  %EQU BDT_BOF_BOF = 17;          /* BOF thru BOF */
      1187
      1188
      1189  /*
      1190  *   VD$BUFFER
      1191  *   A long string of data bytes.
      1192  *   Note that the ".BYTES" element is a varying character string, whose
      1193  *       length is determined by the inherited element ".LENGTH".
      1194  *   Macro Parameters:
      1195  *       NAME, STCLASS, ALGN:  Name, storage class, and alignment
      1196  *           of structure.  Default storage class is STATIC;
      1197  *           Default alignment is ALIGNED.
      1198  *       ICLASS:  %CLS_ definition for this structure.  Default is %CLS_BUFFER.
      1199  *       MXNB:  # bytes to allocate for text portion of structure.
      1200  *           This must be a compile-time-evaluated value.
      1201  *           If MXNB is omitted, an IBYTES parameter must be given,
      1202  *               and the text field of the structure will be allocated
      1203  *               to be the size of the IBYTES parameter.
      1204  *       IBYTES:  String (in quotes) for initial value.  If IBYTES="''",
      1205  *           then will build the structure for MXNB chars,
      1206  *           whose initial value is a zero-length string.
      1207  */
      1208  %MACRO VD$BUFFER (NAME=VD$BUFFER,
      1209   STCLASS(PARAM=" ",ANY)=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1210   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      1211   ICLASS=%CLS_BUFFER, MXNB=0, IBYTES=' ');
      1212
      1213  %IF TEXTCHAR(LEV) = 'AUTO';
      1214     %LSET LEVEL = LEVEL + 1;
      1215  %ELSE;
      1216     %LSET LEVEL = LEV;
      1217  %ENDIF;
      1218
      1219  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 58
      1220  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      1221  %LSET INIT=CHARTEXT('INIT');
      1222  %LSET EIN=CHARTEXT(' ');
      1223  %ELSE;
      1224  %LSET INIT=CHARTEXT('/*');
      1225  %LSET EIN=CHARTEXT('*/');
      1226  %ENDIF;
      1227
      1228  %IF TEXTCHAR(IBYTES)=TEXTCHAR('');
      1229  %LSET LENIBYTES=0;
      1230  %LSET LIBYTES=' ';
      1231  %ELSE;
      1232  %LSET LENIBYTES=LENGTHC(IBYTES);
      1233  %LSET LIBYTES=IBYTES;
      1234  %ENDIF;
      1235
      1236   %LSET STCL = SUBSTR (CONCAT (TEXTCHAR (STCLASS), '   '), 0, 3);
      1237   %LSET BASED_DECL = STCL ~= 'AUT' & STCL ~= 'STA' & STCL ~= 'CON' & STCL ~= 'EXT';
      1238  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1239  %IF LEVEL = 1;
      1240  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1241  %ELSE;
      1242   %(LEVEL) NAME DIM ALIGNMENT,
      1243  %ENDIF;
      1244
      1245        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=ICLASS);
      1246        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      1247        %(LEVEL+1) LENGTH# SBIN HALF HALIGNED %INIT (%LENIBYTES) %EIN,
      1248   %IF BASED_DECL OR MXNB<0;
      1249        %(LEVEL+1) BYTES CHAR (NAME.LENGTH#) %ENDCHAR
      1250   %ELSE;
      1251        %(LEVEL+1) BYTES CHAR (MXNB) %INIT (%LIBYTES) %EIN %ENDCHAR
      1252   %ENDIF;
      1253
      1254  %MEND;
      1255
      1256  /*

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 59
      1257  *   VD_BUFFER
      1258  *   Version of VD$BUFFER.
      1259  */
      1260  %MACRO VD_BUFFER (NAME=VD_BUFFER, STCLASS=STATIC, DIM=" ",
      1261      ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      1262      ICLASS=%CLS_BUFFER, MXNB=0, IBYTES=' ');
      1263
      1264  %VD$BUFFER (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      1265      LEV=LEVEL, LAST=LAST, ICLASS=ICLASS, MXNB=MXNB, IBYTES=IBYTES);
      1266
      1267  %MEND;
      1268
      1269
      1270  /*
      1271  *   VD$BUFFER_HEADER
      1272  *   A "buffer_object" is an object which stores a long string of data bytes
      1273  *       (possibly longer than 511 bytes).  They`re used to store
      1274  *       Data components of file nodes, among other things.
      1275  *   All "buffer_objects" have a common header as the first element(s) of their
      1276  *       PL6 structure.
      1277  */
      1278  %MACRO VD$BUFFER_HEADER (NAME=VD$BUFFER_HEADER,
      1279   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1280   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1281
      1282  %IF TEXTCHAR(LEV) = 'AUTO';
      1283     %LSET LEVEL = LEVEL + 1;
      1284  %ELSE;
      1285     %LSET LEVEL = LEV;
      1286  %ENDIF;
      1287
      1288  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1289  %IF LEVEL = 1;
      1290  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1291  %ELSE;
      1292   %(LEVEL) NAME DIM ALIGNMENT,
      1293  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 60
      1294
      1295        %VD$OBJECT_HEADER (NAME=OBJECT);
      1296        %(LEVEL+1) FLINK$ PTR,
      1297        %(LEVEL+1) LENGTH# SBIN HALF HALIGNED %ENDCHAR
      1298
      1299  %MEND;
      1300
      1301
      1302  /*
      1303  *   VD$CMD_STREAM
      1304  *   Specifies a location in a READ-file, an InTree, or the command-window
      1305  *       command stream.  VD$CMD_STREAMs are stacked; the top entry,
      1306  *       if any, represents the current command stream.
      1307  *   RECORD and INTREE represent the last record read from the command stream;
      1308  *       this record is currently being processed.  Only the part from
      1309  *       .POSITION on is being looked at.
      1310  *   INTREE - If .INTREE is non-NIL, then it`s the InTree which is the
      1311  *       encoded representation of the command line in RECORD (however,
      1312  *       there may not be any command line in RECORD, eg, the InTree built for
      1313  *       the invocation command line`s DCBs).  The InTree is a chain of
      1314  *       VD$IT_COMMAND nodes.
      1315  *       If INTREE is non-NIL, always use it instead of RECORD; RECORD is kept
      1316  *       in that case for error reporting.
      1317  *   POSITION is the index of the first item in RECORD/INTREE to process.
      1318  *       If INTREE is non-NIL, then POSITION is the # of the next node in the
      1319  *       chain to process (first node is # 0).
      1320  *       If INTREE is NIL, then POSITION is the index into RECORD`s data of
      1321  *       the next character to process.
      1322  *   IT_FROM_PARSE_TREE is set if .INTREE came from a parsed-and-encoded
      1323  *       text record.  It`s used to indicate that when we pop back into
      1324  *       this command stream from another, we must re-parse the text record
      1325  *       in spite of the presence of an InTree (ref`d via .INTREE).
      1326  *       (We must re-parse because the InTree`s VD$IT_COMMAND nodes may contain
      1327  *       ref`s to ParseTree nodes for block expressions; but the ParseTree
      1328  *       workspace is scratched and re-used after every command-line parse,
      1329  *       so the ParseTree that was there when the InTree was built may
      1330  *       no longer be there, so we must re-parse.)

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 61
      1331  *       If this flag isn`t set, then when we pop back into this command
      1332  *       stream, we`ll simply keep using the InTree ref`d via .INTREE.
      1333  *   REC_NUM is the record number in the command stream of the record in
      1334  *       .RECORD/INTREE, counting from 1.  It`s behaviour depends on .TYPE:
      1335  *       CS_BUFFER:  This command stream has a record chain in RECORD/INTREE.
      1336  *           If REC_NUM is 0, we haven`t processed RECORD/INTREE yet; the next
      1337  *               read from the command stream should "read" it.
      1338  *           If REC_NUM is >= 1 we`ve just read a RECORD/INTREE and are processing
      1339  *               it; the next "read" from the command stream will hit
      1340  *               end-of-"file" unless RECORD has a FLINK$.
      1341  *       CS_FILE, CS_DCB:  To position to the the record in RECORD/INTREE,
      1342  *           M$PRECORD with N=(REC_NUM-1).
      1343  *   IF_CMD indicates a satisfied IF command.  An ELSE command is only
      1344          permitted if IF_CMD is set.
      1345  *   CMD_AFTER_READ is used when a READ command is not last of a command line.
      1346  *       It means the rest of the command is saved in RECORD$, and SYNONYM
      1347  *       substitution has already been done there.
      1348  *
      1349  *   BLINK: Prev entry on stack
      1350  *   TYPE: Type of command stream
      1351  *   FILE: If .TYPE = CS_FILE, fid of file
      1352  *   DCB: If .TYPE = CS_DCB, dcb to use
      1353  *   FILE_TYPE: If .TYPE = CS_FILE | _DCB, file type
      1354  *   RECORD: Last command line read
      1355  *   INTREE: InTree form of last command line read
      1356  *   POSITION:
      1357  *   ECHO: Honor $ECHO?
      1358  *   IT_FROM_PARSE_TREE: InTree came from a ParseTree
      1359  *   REC_NUM:
      1360  */
      1361  %MACRO VD$CMD_STREAM (NAME=VD$CMD_STREAM,
      1362   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1363   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1364
      1365  %IF TEXTCHAR(LEV) = 'AUTO';
      1366     %LSET LEVEL = LEVEL + 1;
      1367  %ELSE;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 62
      1368     %LSET LEVEL = LEV;
      1369  %ENDIF;
      1370
      1371  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1372  %IF LEVEL = 1;
      1373  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1374  %ELSE;
      1375   %(LEVEL) NAME DIM ALIGNMENT,
      1376  %ENDIF;
      1377
      1378        %VD$OBJECT_HEADER (NAME=OBJECT);
      1379        %(LEVEL+1) BLINK$ PTR,
      1380        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,
      1381        %(LEVEL+1) FILE,
      1382          %(LEVEL+2) LENGTH# UBIN BYTE CALIGNED,
      1383          %(LEVEL+2) BYTES CHAR (%MXNB_FID),
      1384        %(LEVEL+1) DCB# UBIN HALF HALIGNED,
      1385        %(LEVEL+1) FILE_TYPE CHAR (2),
      1386        %(LEVEL+1) RECORD$ PTR,
      1387        %(LEVEL+1) INTREE$ PTR,
      1388        %(LEVEL+1) POSITION# SBIN HALF HALIGNED,
      1389        %(LEVEL+1) ECHO BIT (1),
      1390        %(LEVEL+1) IT_FROM_PARSE_TREE BIT (1),
      1391        %(LEVEL+1) IF_CMD BIT(1),
      1392        %(LEVEL+1) CMD_AFTER_READ BIT(1),
      1393        %(LEVEL+1) *   BIT(14), /* RFU */
      1394        %(LEVEL+1) REC_NUM# SBIN WORD %ENDCHAR
      1395
      1396  %MEND;
      1397
      1398  /*
      1399  *   CS_? - EQUs for VD$CMD_STREAM.TYPE
      1400  */
      1401  %EQU CS_BUFFER = 1;                 /*  Invocation command line     */
      1402  %EQU CS_ME = 2;                     /*  From command window         */
      1403  %EQU CS_FILE = 3;                   /*  From READ-file              */
      1404  %EQU CS_DCB = 4;                    /*  From user-set DCB           */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 63
      1405
      1406
      1407  /*
      1408  *   VD$DCBS
      1409  *   Info about dynamically-allocated DCBs.
      1410  *   .N_DYNAMIC - # of DCBs dynamically allocated so far in this session.
      1411  *       Used when allocating a new DCB, to uniquely identify each new DCB.
      1412  *   .N_FREE - Index into .FREE_DCB of the next empty entry.
      1413  *   .FREE_DCB - List of DCBs which we`ve allocated (via M$GETDCB) but
      1414  *       which we aren`t using currently.  Whenever we need a new DCB,
      1415  *       we should check this list before M$GETDCBing any more DCBs.
      1416  */
      1417  %MACRO VD$DCBS (NAME=VD$DCBS,
      1418   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1419   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1420
      1421  %IF TEXTCHAR(LEV) = 'AUTO';
      1422     %LSET LEVEL = LEVEL + 1;
      1423  %ELSE;
      1424     %LSET LEVEL = LEV;
      1425  %ENDIF;
      1426
      1427  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1428  %IF LEVEL = 1;
      1429  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1430  %ELSE;
      1431   %(LEVEL) NAME DIM ALIGNMENT,
      1432  %ENDIF;
      1433
      1434        %(LEVEL+1) N_DYNAMIC# SBIN HALF HALIGNED,
      1435        %(LEVEL+1) N_FREE# SBIN HALF HALIGNED,
      1436        %(LEVEL+1) FREE_DCB#(0:0) UBIN HALF HALIGNED,
      1437        %(LEVEL+1) *   BIT(18) %ENDCHAR  /* RFU */
      1438
      1439  %MEND;
      1440
      1441

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 64
      1442  /*
      1443  *   VD$DIR_NODE
      1444  *   Directory of internal files.
      1445  *   Directories are distinguished by the common characteristics of
      1446  *       the files in them:
      1447  *       o Have same migratability, and same file storage class (FSTCL_).
      1448  *       o Use same accessor Structure.
      1449  *
      1450  *   BLINK: Back Link
      1451  *   FLINK: Forward link
      1452  *   KEY: Name of directory
      1453  *   MIGRATABLE: Files can be migrated to external files
      1454  *   FILE_STCLASS: File storage class:  where files reside
      1455  *   STRUCTURE: Lvl-0 of accessor Structure for files in dir
      1456  *   HEAD: } Ref to chain of files in directory
      1457  *   TAIL: }
      1458  *   COUNT:
      1459  */
      1460  %MACRO VD$DIR_NODE (NAME=VD$DIR_NODE,
      1461   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1462   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1463
      1464  %IF TEXTCHAR(LEV) = 'AUTO';
      1465     %LSET LEVEL = LEVEL + 1;
      1466  %ELSE;
      1467     %LSET LEVEL = LEV;
      1468  %ENDIF;
      1469
      1470  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1471  %IF LEVEL = 1;
      1472  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1473  %ELSE;
      1474   %(LEVEL) NAME DIM ALIGNMENT,
      1475  %ENDIF;
      1476
      1477        %VD$OBJECT_HEADER (NAME=OBJECT);
      1478        %(LEVEL+1) BLINK$ PTR,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 65
      1479        %(LEVEL+1) FLINK$ PTR,
      1480        %(LEVEL+1) KEY CHAR (%MXNB_FILE_NAME),
      1481        %(LEVEL+1) MIGRATABLE BIT (1),
      1482        %(LEVEL+1) *   BIT(8),  /* RFU */
      1483        %(LEVEL+1) FILE_STCLASS CHAR (1),
      1484        %(LEVEL+1) *   BIT(27), /* RFU */
      1485        %(LEVEL+1) STRUCTURE$ PTR,
      1486        %(LEVEL+1) HEAD$ PTR,
      1487        %(LEVEL+1) TAIL$ PTR,
      1488        %(LEVEL+1) COUNT# SBIN WORD %ENDCHAR
      1489
      1490  %MEND;
      1491
      1492  /* "File storage class" of predefined files: 1st char of file key */
      1493  %EQU FSTCL_EXTERNAL = ':';  /* Always stored externally */
      1494  %EQU FSTCL_INTERNAL= '"';   /* Always stored internally */
      1495  %EQU FSTCL_MIGRATABLE = '*'; /* Migratable to external star-file */
      1496
      1497  /* Constant string in all predefined file keys (chars 2-7) */
      1498  %EQU PFK_CONSTANT = '6Edit_';
      1499
      1500  /* Internal directory keys (chars 8-n of predefined file keys) */
      1501  %EQU DK_HISTORY = 'History';
      1502  %EQU DK_NAMES = 'Names';
      1503  %EQU DK_SCRATCH = 'Scratch';
      1504  %EQU DK_STRUCTURES = 'Structures';
      1505  %EQU DK_WINDOWS = 'Windows';
      1506  /* (((Upper-case versions of these names for user syntax:))) */
      1507  %EQU DKU_HISTORY = 'HISTORY';
      1508  %EQU DKU_NAMES = 'NAMES';
      1509  %EQU DKU_STRUCTURES = 'STRUCTURES';
      1510  %EQU DKU_WINDOWS = 'WINDOWS';
      1511
      1512  /* Predefined file names (after %DK_ in predefined file keys) */
      1513  %EQU PFN_NAMES_EQUALS = 'Equals';
      1514  %EQU PFN_NAMES_KEYINS = 'Keyins';
      1515  %EQU PFN_NAMES_LOCATIONS = 'Locations';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 66
      1516  %EQU PFN_NAMES_SYNONYMS = 'Synonyms';
      1517  %EQU PFN_SCRATCH_LEFTOVER = 'Leftover';
      1518  %EQU PFN_SCRATCH_SOURCE = 'Source';
      1519  /* (((Upper-case versions of these names for user syntax:))) */
      1520  %EQU PFNU_NAMES_EQUALS = 'EQUALS';
      1521  %EQU PFNU_NAMES_KEYINS = 'KEYINS';
      1522  %EQU PFNU_NAMES_LOCATIONS = 'LOCATIONS';
      1523  %EQU PFNU_NAMES_SYNONYMS = 'SYNONYMS';
      1524
      1525
      1526  /*
      1527  *   VD$ENCODED_DESC
      1528  *   Info about a node stored in an encoded file.
      1529  *   Contains all info necessary to recreate the original node of
      1530  *       either an internal or external file.
      1531  */
      1532  %MACRO VD$ENCODED_DESC (NAME=VD$ENCODED_DESC,
      1533   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1534   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1535
      1536  %IF TEXTCHAR(LEV) = 'AUTO';
      1537     %LSET LEVEL = LEVEL + 1;
      1538  %ELSE;
      1539     %LSET LEVEL = LEV;
      1540  %ENDIF;
      1541
      1542  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1543  %IF LEVEL = 1;
      1544  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1545  %ELSE;
      1546   %(LEVEL) NAME DIM ALIGNMENT,
      1547  %ENDIF;
      1548
      1549        %VD$KEY (NAME=FILE_KEY);
      1550        %VD$LOCATION (NAME=LOCATION);
      1551        %VD$NAC (NAME=ACCESS);
      1552        %VD$SPEC (NAME=SPEC);

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 67
      1553        %(LEVEL+1) DATA$ PTR %ENDCHAR
      1554
      1555  %MEND;
      1556
      1557
      1558  /*
      1559  *   VD$ENCODED_FILE_SPEC
      1560  *   "Spec component" of the header record of an encoded workspace file.
      1561  *   Note that this is NOT a sub-class of "string_objects" (as are most other
      1562  *       Spec-component structures).  In fact, it`s not even an object,
      1563  *       because it never needs to be stored in dynamic storage by itself
      1564  *       (when read from the workspace file, it`s part of VD$ENCODED_NODE`s
      1565  *       data area, pointed-to by VD$ENCODED_NODE.DESC.SPEC.V$).
      1566  *
      1567  *   CONTENTS: What types of nodes are in this workspace file
      1568  *   LAST_MODIFIED: Info on last update of this file
      1569  *       TIME: UTS time of last update to file
      1570  *       USER_NAME: User name who last updated file
      1571  *       PROFILE: Terminal profile of last updater
      1572  */
      1573  %MACRO VD$ENCODED_FILE_SPEC (NAME=VD$ENCODED_FILE_SPEC,
      1574   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1575   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1576
      1577  %IF TEXTCHAR(LEV) = 'AUTO';
      1578     %LSET LEVEL = LEVEL + 1;
      1579  %ELSE;
      1580     %LSET LEVEL = LEV;
      1581  %ENDIF;
      1582
      1583  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1584  %IF LEVEL = 1;
      1585  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1586  %ELSE;
      1587   %(LEVEL) NAME DIM ALIGNMENT,
      1588  %ENDIF;
      1589

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 68
      1590        %VD$PDFF (NAME=CONTENTS);
      1591        %(LEVEL+1) LAST_MODIFIED,
      1592          %(LEVEL+2) TIME# UBIN WORD,
      1593          %(LEVEL+2) USER_NAME CHAR (12),
      1594          %(LEVEL+2) PROFILE,
      1595            %(LEVEL+3) LENGTH# UBIN BYTE CALIGNED,
      1596            %(LEVEL+3) BYTES CHAR (%MXNB_PROFILE_NAME) %ENDCHAR
      1597
      1598  %MEND;
      1599
      1600
      1601  /*
      1602  *   VD$ENCODED_NODE
      1603  *   Record in an "encoded" file.
      1604  *   An encoded node is an externally-storable representation of a node
      1605  *       from either an internal or external file.  Encoded files are used
      1606  *       for the workspace file, the History file, and (someday perhaps)
      1607  *       the files which have migrated from internal to external
      1608  *       storage (History, Names, scratch files).  Encoded files
      1609  *       store all components of a node    Key, Spec, and Data
      1610  *       in the Data component of the encoded representation, so
      1611  *       that any node can be stored in an external file.  Also,
      1612  *       the Key component contains all keys, from file-level to
      1613  *       this node`s level, needed to rewrite the node to it`s
      1614  *       original file, be it internal or external.
      1615  *   The VD$ENCODED_NODE PL-6 structure defines the format of the Data
      1616  *       component of a record in the external encoded file.
      1617  *       The VD$ENCODED_NODE object is a sub-class of "buffer_objects".
      1618  *   Each record contains one node from the file, and all the
      1619  *       objects it points to.  Note that for the predefined files,
      1620  *       the Spec component often refers to many other objects.
      1621  *       Exception:  VD$STREAMs are not stored in the workspace
      1622  *       file; references to them are nil`d, and they are re-built
      1623  *       each time the node is read and decoded.
      1624  *   There are some special types of records in encoded files:
      1625  *       Command records can be stored in the workspace or History
      1626  *           files.  For these records, VD$FILE_KEY.RES = "ME#" and

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 69
      1627  *           DESC.LOCATION is %CLEAR.
      1628  *       Header records are always the first record in an encoded file.  They
      1629  *           have:
      1630  *           .RECORD_NUM = 0
      1631  *           .DESC.FILE_KEY and .DESC.LOCATION = %CLEAR
      1632  *           .DESC.SPEC.TYPE# = SPT_ENCODED_FILE_SPEC
      1633  *           .DESC.SPEC.V$ pointing to a VD$ENCODED_FILE_SPEC    which is NOT
      1634  *               an object!!  It`s just a simple PL-6 data structure.
      1635  *
      1636  *   .RECORD_ID contains an identifying string; the same string
      1637  *       appears in all records in the encoded file.
      1638  *   .RECORD_VERSION contains the B_VERSION string of the 6Edit
      1639  *       processor which last wrote the record.
      1640  *   .CHECKSUM contains an additive checksum of all words in the
      1641  *       record laying beyond .CHECKSUM.
      1642  *   .RECORD_NUM is this record`s number in the workspace file.  It
      1643  *       is stored in the record itself as a consistency check.
      1644  *   .DESC contains the Key, Spec, and Data components for this node.
      1645  *       The Key component contains both file-level and all necessary
      1646  *       lower-level keys for this node.
      1647  */
      1648  %MACRO VD$ENCODED_NODE (NAME=VD$ENCODED_NODE,
      1649   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1650   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1651
      1652  %IF TEXTCHAR(LEV) = 'AUTO';
      1653     %LSET LEVEL = LEVEL + 1;
      1654  %ELSE;
      1655     %LSET LEVEL = LEV;
      1656  %ENDIF;
      1657
      1658  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      1659  %IF LEVEL = 1;
      1660  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1661  %ELSE;
      1662   %(LEVEL) NAME DIM ALIGNMENT,
      1663  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 70
      1664
      1665        %VD$OBJECT_HEADER (NAME=OBJECT);
      1666        %(LEVEL+1) FLINK$ PTR,
      1667        %(LEVEL+1) LENGTH# SBIN HALF HALIGNED,
      1668        %(LEVEL+1) RECORD_ID CHAR (%LENGTHC(CHR_ENCODED_RECID)),
      1669        %(LEVEL+1) RECORD_VERSION CHAR (%NB_VERSION),
      1670        %(LEVEL+1) CHECKSUM# SBIN WORD,
      1671        %(LEVEL+1) RECORD_NUM# SBIN WORD,
      1672
      1673        %VD$ENCODED_DESC (NAME=DESC, LAST=%LAST#);
      1674
      1675  %MEND;
      1676
      1677
      1678  /*
      1679  *   VD$ERR
      1680  *   Global error structure.  Records what we were doing when the
      1681  *       error was detected, and info needed to output the error
      1682  *       message and continue/abort/terminate processing.
      1683  *   A chain of these are linked off VD_6E.ERR_HEAD.  Although most VD$ERRs
      1684  *       reside in dynamic storage, the first one resides in static
      1685  *       storage; it is used for reporting fatal errors.  Successive
      1686  *       entries in the chain are allocated dynamically.
      1687  *   Each VD$ERR is immediately followed by an array of three
      1688  *       VD$NUMBERs/VD$POINTERs.  These contain the info for the
      1689  *       substitution fields in the error message.
      1690  */
      1691  %MACRO VD$ERR (NAME=VD$ERR,
      1692   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1693   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1694
      1695  %IF TEXTCHAR(LEV) = 'AUTO';
      1696     %LSET LEVEL = LEVEL + 1;
      1697  %ELSE;
      1698     %LSET LEVEL = LEV;
      1699  %ENDIF;
      1700

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 71
      1701  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1702  %IF LEVEL = 1;
      1703  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1704  %ELSE;
      1705   %(LEVEL) NAME DIM ALIGNMENT,
      1706  %ENDIF;
      1707
      1708        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS);
      1709        %(LEVEL+1) FLINK$ PTR,
      1710        %VD$ERR_CODE (NAME=ERR);
      1711        %(LEVEL+1) FLAGLEV# UBIN HALF HALIGNED,
      1712        %(LEVEL+1) CMDLINE_INDEX# SBIN HALF HALIGNED,
      1713        %(LEVEL+1) DCB# UBIN HALF HALIGNED,
      1714        %(LEVEL+1) *   BIT(18) %ENDCHAR /* RFU */
      1715
      1716  %MEND;
      1717
      1718  /*
      1719  *  FLV_? - Flag levels for error message (VD$ERR.FLAGLVL#)
      1720  */
      1721  %EQU FLV_INFO = 1;                  /*  Informational message       */
      1722  %EQU FLV_WARN = 2;                  /*  Warning message             */
      1723  %EQU FLV_SERIOUS = 3;               /*  Serious error; aborts command line */
      1724  %EQU FLV_FATAL = 4;                 /*  Fatal error; aborts 6EDIT   */
      1725
      1726
      1727  /*
      1728  *   VD$ERR_CODE
      1729  *   Standard CP-6 error code word.
      1730  */
      1731  %MACRO VD$ERR_CODE (NAME=VD$ERR_CODE,
      1732   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1733   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1734
      1735  %IF TEXTCHAR(LEV) = 'AUTO';
      1736     %LSET LEVEL = LEVEL + 1;
      1737  %ELSE;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 72
      1738     %LSET LEVEL = LEV;
      1739  %ENDIF;
      1740
      1741  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1742  %IF LEVEL = 1;
      1743  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1744  %ELSE;
      1745   %(LEVEL) NAME DIM ALIGNMENT,
      1746  %ENDIF;
      1747
      1748        %(LEVEL+1) FCG BIT (12),
      1749        %(LEVEL+1) MID BIT (6),
      1750        %(LEVEL+1) MON BIT (1),
      1751        %(LEVEL+1) CODE# UBIN (14) UNAL,
      1752        %(LEVEL+1) SEV# UBIN (3) UNAL %ENDCHAR
      1753
      1754  %MEND;
      1755
      1756  /*
      1757  *   Values for VLP_ERRMSG fields:  FCG and MIDs
      1758  */
      1759  %EQU FCG = CONCAT(SUBBIT(ASCBIT('V'),3,6), SUBBIT(ASCBIT('D'),3,6));
      1760  %EQU FCG_MID_GLOBAL = SUBBIT(ASCBIT('G'),3,6);  /* Global routines */
      1761  %EQU FCG_MID_INT = SUBBIT(ASCBIT('I'),3,6);     /* Interpreter */
      1762  %EQU FCG_MID_EVAL = SUBBIT(ASCBIT('E'),3,6);    /* Evaluator */
      1763  %EQU FCG_MID_ACC = SUBBIT(ASCBIT('A'),3,6);     /* Accessor */
      1764  %EQU FCG_MID_PRES = SUBBIT(ASCBIT('P'),3,6);    /* Presenter */
      1765
      1766  %EQU FCG_XU = CONCAT(SUBBIT(ASCBIT('X'),3,6), SUBBIT(ASCBIT('U'),3,6));
      1767
      1768
      1769  /*
      1770  *   VD$EVAL
      1771  *   Info about the block currently being selected.  Corresponds to
      1772  *       the $ENCLOSING, $RANGE, and $FP predefined names, and the
      1773  *       Pres`r`s "cursor field".  Set by Int`r and Eval`r as a result
      1774  *       of evaluation of a block expression`s InTree.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 73
      1775  *   The FilePointer is always at either the start or end of this block.
      1776  *       If STATE = EVST_INITIAL:  FilePointer is at start of
      1777  *           the block, and we haven`t begun selecting a block yet
      1778  *           (so $RANGE/cursor-field is an empty block at the FilePointer
      1779  *           location; and RANGE.START = RANGE.ENDD).
      1780  *           Both boundaries float along with FilePointer movement.
      1781  *       If STATE = EVST_START:  FilePointer is at the start of the
      1782  *           range, and the end-boundary is anchored in the file.
      1783  *       If STATE = EVST_END:  FilePointer is at the end of the
      1784  *           range, and the start-boundary is anchored in the file.
      1785  *   VD$EVALs are stacked when during evaluation of the InTree we hit
      1786  *       an IT_SELECT node.
      1787  *  *N*  or a generator movement-level node, or a parenthesized block
      1788  *  *N*  expression.
      1789  */
      1790  %MACRO VD$EVAL (NAME=VD$EVAL,
      1791   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1792   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1793
      1794  %IF TEXTCHAR(LEV) = 'AUTO';
      1795     %LSET LEVEL = LEVEL + 1;
      1796  %ELSE;
      1797     %LSET LEVEL = LEV;
      1798  %ENDIF;
      1799
      1800  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1801  %IF LEVEL = 1;
      1802  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1803  %ELSE;
      1804   %(LEVEL) NAME DIM ALIGNMENT,
      1805  %ENDIF;
      1806
      1807        %VD$OBJECT_HEADER (NAME=OBJECT);
      1808        %(LEVEL+1) BLINK$ PTR,
      1809        %VD$RANGE (NAME=ENCLOSING);
      1810        %VD$RANGE (NAME=RANGE);
      1811        %VD$RANGE (NAME=LAST_FOUND_RANGE);

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 74
      1812        %(LEVEL+1) STATE# UBIN HALF HALIGNED,
      1813        %(LEVEL+1) CTRL_REC_MATCHED_EOF BIT (1),
      1814        %(LEVEL+1) NODE$ PTR,
      1815        %(LEVEL+1) REMAINING# SBIN WORD %ENDCHAR
      1816
      1817  %MEND;
      1818
      1819  /*
      1820  *   EVST_? - States in the evaluation of a block`s range
      1821  *   EVST_TOGGLE only appears in VD$IT_ADJUST.NEW_STATE#
      1822  */
      1823  %EQU EVST_INITIAL = 1;              /*  Not yet selecting; both bounds float */
      1824  %EQU EVST_START = 2;                /*  Start bound floats; end bound anchored */
      1825  %EQU EVST_END = 3;                  /*  End bound floats; start bound anchored */
      1826  %EQU EVST_TOGGLE = 4;               /*  Toggle between _START and _END */
      1827
      1828
      1829  /*
      1830  *   VD$EVAL_OPTIONS
      1831  *   Evaluation options for an InTree movement node.
      1832  *
      1833  *   SRCH: "Search" evaluation option
      1834  *   SKIP: "Skip" evaluation option
      1835  *   POINT: "Point" evaluation option
      1836  *   DIRECTION: "Direction" evaluation option
      1837  */
      1838  %MACRO VD$EVAL_OPTIONS (NAME=VD$EVAL_OPTIONS,
      1839   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1840   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1841
      1842  %IF TEXTCHAR(LEV) = 'AUTO';
      1843     %LSET LEVEL = LEVEL + 1;
      1844  %ELSE;
      1845     %LSET LEVEL = LEV;
      1846  %ENDIF;
      1847
      1848  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 75
      1849  %IF LEVEL = 1;
      1850  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1851  %ELSE;
      1852   %(LEVEL) NAME DIM ALIGNMENT,
      1853  %ENDIF;
      1854
      1855        %(LEVEL+1) SRCH BIT (1),
      1856        %(LEVEL+1) *   BIT(17), /* RFU */
      1857        %(LEVEL+1) SKIP# SBIN HALF HALIGNED,
      1858        %(LEVEL+1) POINT# UBIN HALF HALIGNED,
      1859        %(LEVEL+1) DIRECTION# UBIN HALF HALIGNED %ENDCHAR
      1860
      1861  %MEND;
      1862
      1863  /*
      1864  *   DIR_? - "Direction" option values.
      1865  */
      1866  %EQU DIR_FORWARD = 1;
      1867  %EQU DIR_BACKWARD = 2;
      1868
      1869  /*
      1870  *   PNT_? - "Point" option values.
      1871  *   Points in an entity to which to move the FilePointer.
      1872  *   Also indicates how much of the entity is to be "covered"
      1873  *       by the block expression.
      1874  */
      1875  %EQU PNT_AO = 1;                    /*  All Of                      */
      1876  %EQU PNT_BO = 2;                    /*  Beginning Of                */
      1877  %EQU PNT_EO = 3;                    /*  End Of                      */
      1878
      1879
      1880  /*
      1881  *   VD$EVAL_PATTERN
      1882  *   Info about a pattern search being performed.  VD$EVAL_PATTERNs are
      1883  *       stacked during evaluation of a pattern string:
      1884  *       The top entry in the stack is modified as searching proceeds.
      1885  *       The other entries in the stack save the search parameters as they were

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 76
      1886  *           at the point where we found a non-PS_WILD_STRING symbol and
      1887  *           .REMAINING_BYTES was > 0 (so we could resume the search if we
      1888  *           need to backtrack).
      1889  *
      1890  *   BLINK: Ref to prev entry on evaluation stack
      1891  *   RANGE: Search location / location of match
      1892  *   PATTERN: Pattern we`re evaluating
      1893  *   PATT_INDEX: VD$PATTERN index to entry we`re looking for
      1894  *   DIRECTION: Direction of search
      1895  *   REMAINING_RECS: # recs we can still search
      1896  *   REMAINING_BYTES: # bytes we can still search
      1897  */
      1898  %MACRO VD$EVAL_PATTERN (NAME=VD$EVAL_PATTERN,
      1899   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1900   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      1901
      1902  %IF TEXTCHAR(LEV) = 'AUTO';
      1903     %LSET LEVEL = LEVEL + 1;
      1904  %ELSE;
      1905     %LSET LEVEL = LEV;
      1906  %ENDIF;
      1907
      1908  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1909  %IF LEVEL = 1;
      1910  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1911  %ELSE;
      1912   %(LEVEL) NAME DIM ALIGNMENT,
      1913  %ENDIF;
      1914
      1915        %VD$OBJECT_HEADER (NAME=OBJECT);
      1916        %(LEVEL+1) BLINK$ PTR,
      1917        %VD$RANGE (NAME=RANGE);
      1918        %(LEVEL+1) PATTERN$ PTR,
      1919        %(LEVEL+1) PATT_INDEX# SBIN HALF HALIGNED,
      1920        %(LEVEL+1) DIRECTION# UBIN HALF HALIGNED,
      1921        %(LEVEL+1) REMAINING_RECS# SBIN WORD,
      1922        %(LEVEL+1) REMAINING_BYTES# SBIN WORD %ENDCHAR

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 77
      1923
      1924  %MEND;
      1925
      1926
      1927  /*
      1928  *   VD$FILE_KEY
      1929  *   Funny sub-class of "string_objects", to store a file-level key.
      1930  *       The .LENGTH element (inherited from the super-class) only includes the
      1931  *       occupied portion of .UNIQUE (account and occupied part of filename),
      1932  *       and is all that should be compared when comparing file keys.
      1933  *       However, OBJECT.SIZE indicates the full size of the
      1934  *       VD$FILE_KEY object.
      1935  *   For external files, this is an M$FID`d fid or a DCB number.
      1936  *       If .DCB ~= 0, then it must already be !SET to a file.
      1937  *   For internal files, only .UNIQUE.FNAME is given; the rest of
      1938  *       .UNIQUE is all blanks.
      1939  *   Special cases:
      1940  *       If .RES = "ME#", this represents a command record from the
      1941  *           command stream (History and workspace files only).
      1942  */
      1943  %MACRO VD$FILE_KEY (NAME=VD$FILE_KEY,
      1944   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      1945   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      1946   IACCT=' ', IFNAME=' ', IASN=0, IRES=' ', IPSN=' ',
      1947   IPASS=' ', IDCB=0);
      1948
      1949  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      1950  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      1951  %LSET INIT=CHARTEXT('INIT');
      1952  %LSET EIN=CHARTEXT(' ');
      1953  %ELSE;
      1954  %LSET INIT=CHARTEXT('/*');
      1955  %LSET EIN=CHARTEXT('*/');
      1956  %ENDIF;
      1957
      1958  %IF TEXTCHAR(LEV) = 'AUTO';
      1959     %LSET LEVEL = LEVEL + 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 78
      1960  %ELSE;
      1961     %LSET LEVEL = LEV;
      1962  %ENDIF;
      1963
      1964  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      1965  %IF LEVEL = 1;
      1966  DCL 1 NAME DIM STCLASS ALIGNMENT,
      1967  %ELSE;
      1968   %(LEVEL) NAME DIM ALIGNMENT,
      1969  %ENDIF;
      1970
      1971  /*
      1972  *   The first items in the structure are acct, name.length, name.bytes.
      1973  *   Add up their length
      1974  */
      1975  %LSET ILN=MXNB_FILE_ACCT + 1 + LENGTHC(IFNAME);
      1976        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=%CLS_FILE_KEY);
      1977        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      1978        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (%ILN) %EIN,
      1979        %(LEVEL+1) UNIQUE CALIGNED,
      1980          %(LEVEL+2) ACCT CHAR (8) %INIT (IACCT) %EIN,
      1981          %(LEVEL+2) FNAME CALIGNED,
      1982            %(LEVEL+3) LENGTH# UBIN BYTE CALIGNED %INIT (%LENGTHC(IFNAME)) %EIN,
      1983            %(LEVEL+3) BYTES CHAR (31) %INIT (IFNAME) %EIN,
      1984        %(LEVEL+1) ASN# UBIN BYTE CALIGNED %INIT (IASN) %EIN,
      1985        %(LEVEL+1) RES CHAR (4) %INIT (IRES) %EIN,
      1986        %(LEVEL+1) PSN CHAR (6) %INIT (IPSN) %EIN,
      1987        %(LEVEL+1) PASS CHAR (8) %INIT (IPASS) %EIN,
      1988        %(LEVEL+1) DCB# UBIN HALF HALIGNED %INIT (IDCB) %EIN,
      1989        %(LEVEL+1) * BIT(18) %INIT (%CLEAR) %EIN %ENDCHAR
      1990
      1991  %MEND;
      1992
      1993  /*
      1994  *   VD_FILE_KEY
      1995  *   Version of VD$FILE_KEY.
      1996  */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 79
      1997  %MACRO VD_FILE_KEY (NAME=VD_FILE_KEY, STCLASS=STATIC, ALIGNMENT=ALIGNED,
      1998      DIM=" ", LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      1999      IACCT=' ', IFNAME=' ', IASN=0, IRES=' ', IPSN=' ',
      2000      IPASS=' ', IDCB=0);
      2001
      2002  %VD$FILE_KEY (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      2003      LEV=LEVEL, LAST=LAST, IACCT=IACCT, IFNAME=IFNAME, IASN=IASN,
      2004      IRES=IRES, IPSN=IPSN, IPASS=IPASS, IDCB=IDCB);
      2005
      2006  %MEND;
      2007
      2008
      2009  /*
      2010  *   VD$FILE_NODE
      2011  *   Internal representation of a node in an internal file.
      2012  *   An internal file is represented as a tree of VD$FILE_NODEs.
      2013  *   The root of the tree is "level 0" or the "file level":  one
      2014  *       VD$FILE_NODE which represents the entire internal file.
      2015  *   Internal files may have any number of levels in the tree.
      2016  *       At each level are some number of VD$FILE_NODEs linked
      2017  *       via .BLINK$ and .FLINK$.
      2018  *   The tree has a maximum height (number of levels, specified by
      2019  *       the number of level-1 nodes in the Structures-file entry
      2020  *       for this file).  This max level is called the "record level".
      2021  *   VD$FILE_NODEs at all levels except the record level have a
      2022  *       set of VD$FILE_NODEs as their children; the first
      2023  *       child is linked via .HEAD$, the last child via .TAIL$,
      2024  *       and the number of children is in .COUNT.
      2025  */
      2026  %MACRO VD$FILE_NODE (NAME=VD$FILE_NODE,
      2027   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2028   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2029
      2030  %IF TEXTCHAR(LEV) = 'AUTO';
      2031     %LSET LEVEL = LEVEL + 1;
      2032  %ELSE;
      2033     %LSET LEVEL = LEV;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 80
      2034  %ENDIF;
      2035
      2036  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2037  %IF LEVEL = 1;
      2038  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2039  %ELSE;
      2040   %(LEVEL) NAME DIM ALIGNMENT,
      2041  %ENDIF;
      2042
      2043        %VD$OBJECT_HEADER (NAME=OBJECT);
      2044        %(LEVEL+1) BLINK$ PTR,
      2045        %(LEVEL+1) FLINK$ PTR,
      2046        %VD$NAC (NAME=ACCESS);
      2047        %VD$NODE_DESC (NAME=DESC);
      2048        %(LEVEL+1) HEAD$ PTR,
      2049        %(LEVEL+1) TAIL$ PTR,
      2050        %(LEVEL+1) COUNT# SBIN WORD %ENDCHAR
      2051
      2052  %MEND;
      2053
      2054
      2055  /*
      2056  *   VD$FIT
      2057  *   Representation of an external file`s FIT.
      2058  *
      2059  *   CODE2: Ptr to CODE2 in FIT string
      2060  *   CODE3: Ptr to CODE3 in FIT string
      2061  *   FIT: Actual FIT string
      2062  */
      2063  %MACRO VD$FIT (NAME=VD$FIT,
      2064   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2065   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2066
      2067  %IF TEXTCHAR(LEV) = 'AUTO';
      2068     %LSET LEVEL = LEVEL + 1;
      2069  %ELSE;
      2070     %LSET LEVEL = LEV;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 81
      2071  %ENDIF;
      2072
      2073  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2074  %IF LEVEL = 1;
      2075  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2076  %ELSE;
      2077   %(LEVEL) NAME DIM ALIGNMENT,
      2078  %ENDIF;
      2079
      2080        %VD$OBJECT_HEADER (NAME=OBJECT);
      2081        %(LEVEL+1) CODE2$ PTR,
      2082        %(LEVEL+1) CODE3$ PTR,
      2083        %(LEVEL+1) FIT CHAR (%(MXNW_FIT*NB_PER_WORD)) %ENDCHAR
      2084
      2085  %MEND;
      2086
      2087
      2088  /*
      2089  *   VD$INTREE_NODE
      2090  *   There are two types of nodes in an InTree:  leaf nodes, and
      2091  *       the interior nodes which define the structure of a block expression.
      2092  *   The leaf nodes are:
      2093  *       VD$IT_OPERAND       VD$IT_OPERATOR      VD$IT_COMMAND
      2094  *   The interior, block-expression nodes, in their required structure, are:
      2095  *       VD$IT_BLOCK_EXPR, whose kids can only be:
      2096  *           VD$IT_SELECTs, whose kids can only be:
      2097  *               VD$IT_ADJUSTs, whose kids can only be leaf nodes.
      2098  *   All InTree nodes are, of course, "objects"; they all also inherit the
      2099  *   following attributes.
      2100  *       VD$OBJECT_HEADER
      2101  *       PARENT$ - Pointer to InTree node for parent
      2102  *       FLINK$ - Pointer to InTree node for right sibling
      2103  */
      2104  %MACRO VD$INTREE_NODE (NAME=VD$INTREE_NODE,
      2105   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2106   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2107

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 82
      2108  %IF TEXTCHAR(LEV) = 'AUTO';
      2109     %LSET LEVEL = LEVEL + 1;
      2110  %ELSE;
      2111     %LSET LEVEL = LEV;
      2112  %ENDIF;
      2113
      2114  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2115  %IF LEVEL = 1;
      2116  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2117  %ELSE;
      2118   %(LEVEL) NAME DIM ALIGNMENT,
      2119  %ENDIF;
      2120
      2121        %VD$OBJECT_HEADER (NAME=OBJECT);
      2122        %(LEVEL+1) PARENT$ PTR,
      2123        %(LEVEL+1) FLINK$ PTR %ENDCHAR
      2124
      2125  %MEND;
      2126
      2127
      2128  /*
      2129  *   VD$IT_ADJUST
      2130  *   InTree node for a range-bound adjustment.
      2131  *
      2132  *   NEW_STATE: Evaluation state to transition to
      2133  *   MOVEMENTS:      } Leaf-level children
      2134  *   MOVEMENTS_TAIL: }
      2135  */
      2136  %MACRO VD$IT_ADJUST (NAME=VD$IT_ADJUST,
      2137   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2138   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2139
      2140  %IF TEXTCHAR(LEV) = 'AUTO';
      2141     %LSET LEVEL = LEVEL + 1;
      2142  %ELSE;
      2143     %LSET LEVEL = LEV;
      2144  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 83
      2145
      2146  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2147  %IF LEVEL = 1;
      2148  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2149  %ELSE;
      2150   %(LEVEL) NAME DIM ALIGNMENT,
      2151  %ENDIF;
      2152
      2153        %VD$OBJECT_HEADER (NAME=OBJECT);
      2154        %(LEVEL+1) PARENT$ PTR,
      2155        %(LEVEL+1) FLINK$ PTR,
      2156        %(LEVEL+1) NEW_STATE# UBIN HALF HALIGNED,
      2157        %(LEVEL+1) *   BIT(18), /* RFU */
      2158        %(LEVEL+1) MOVEMENTS$ PTR,
      2159        %(LEVEL+1) MOVEMENTS_TAIL$ PTR %ENDCHAR
      2160
      2161  %MEND;
      2162
      2163
      2164  /*
      2165  *   VD$IT_BLOCK_EXPR
      2166  *   InTree node for a block expression.
      2167  *   .DOMAINN is only non-%CLEAR when the block expression explicitly
      2168  *       specifies a new domain for the block.  Only one of
      2169  *       .NEXT, .PREVIOUS, or .FILE_KEY/.RANGE are set (if .FILE_KEY
      2170  *       is set, so will .RANGE be set, and vice-versa).
      2171  */
      2172  %MACRO VD$IT_BLOCK_EXPR (NAME=VD$IT_BLOCK_EXPR,
      2173   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2174   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2175
      2176  %IF TEXTCHAR(LEV) = 'AUTO';
      2177     %LSET LEVEL = LEVEL + 1;
      2178  %ELSE;
      2179     %LSET LEVEL = LEV;
      2180  %ENDIF;
      2181

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 84
      2182  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2183  %IF LEVEL = 1;
      2184  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2185  %ELSE;
      2186   %(LEVEL) NAME DIM ALIGNMENT,
      2187  %ENDIF;
      2188
      2189        %VD$OBJECT_HEADER (NAME=OBJECT);
      2190        %(LEVEL+1) PARENT$ PTR,
      2191        %(LEVEL+1) FLINK$ PTR,
      2192        %(LEVEL+1) DOMAINN,
      2193            %(LEVEL+2) NEXT BIT (1),
      2194            %(LEVEL+2) PREVIOUS BIT (1),
      2195            %(LEVEL+2) *  BIT(34), /* RFU */
      2196            %VD$KEY (NAME=FILE_KEY, LEV="%(LEVEL+2)");
      2197            %VD$RANGE (NAME=RANGE, LEV="%(LEVEL+2)");
      2198        %VD$ACCESS_OPTIONS (NAME=OPTIONS);
      2199        %(LEVEL+1) SELECTS$ PTR,
      2200        %(LEVEL+1) SELECTS_TAIL$ PTR %ENDCHAR
      2201
      2202  %MEND;
      2203
      2204
      2205  /*
      2206  *   VD$IT_COMMAND
      2207  *   InTree node for a command.
      2208  *   Commands may appear in two places in an Intree:
      2209  *       As top-level nodes, from which VD$IT_BLOCK_EXPR nodes hang.
      2210  *           This is the case when a command has been parsed and encoded
      2211  *           into InTree form; one of the command`s parameters may be a block
      2212  *           expression.
      2213  *       As leaf nodes (no children).  This is the case for non-editing
      2214  *           commands embedded in a block expression.
      2215  *   If the command came from a parsed-and-encoded command line, then:
      2216  *       .CMDLINE_INDEX is the index into that command line (which should
      2217  *           still be in VD$CMD_STREAM.RECORD) of the command encoded in this
      2218  *           VD$IT_COMMAND.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 85
      2219  *       .PT_BLOCK_EXPR$ will point to the ParseTree for the block expression
      2220  *           if the .CODE for this VD$IT_COMMAND indicates an editing command
      2221  *           (explicit or implicit).
      2222  *   .FLAGS and .PARAM are arrays used differently by each type of command
      2223  *       (based on the T_xxx_CMD token code stored in .CODE).  The
      2224  *       CF_cmd_xxx equates define subscripts into the .FLAGS array for
      2225  *       each <cmd>; the CP_cmd_xxx equates define subscripts into the
      2226  *       .PARAM array for each <cmd>.
      2227  *
      2228  *   CODE: Code for command verb from ParseTree; see T_
      2229  *   CMDLINE_INDEX: Index into cmdline of command
      2230  *   PT_BLOCK_EXPR: ParseTree for editing cmd`s block expr
      2231  *   FLAGS: Flags for command
      2232  *   PARAM: Array of arguments for the command
      2233  */
      2234  %MACRO VD$IT_COMMAND (NAME=VD$IT_COMMAND,
      2235   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2236   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2237
      2238  %IF TEXTCHAR(LEV) = 'AUTO';
      2239     %LSET LEVEL = LEVEL + 1;
      2240  %ELSE;
      2241     %LSET LEVEL = LEV;
      2242  %ENDIF;
      2243
      2244  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2245  %IF LEVEL = 1;
      2246  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2247  %ELSE;
      2248   %(LEVEL) NAME DIM ALIGNMENT,
      2249  %ENDIF;
      2250
      2251        %VD$OBJECT_HEADER (NAME=OBJECT);
      2252        %(LEVEL+1) PARENT$ PTR,
      2253        %(LEVEL+1) FLINK$ PTR,
      2254        %(LEVEL+1) CODE# SBIN HALF HALIGNED,
      2255        %(LEVEL+1) CMDLINE_INDEX# SBIN HALF HALIGNED,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 86
      2256        %(LEVEL+1) PT_BLOCK_EXPR$ PTR,
      2257        %(LEVEL+1) FLAGS(0:%(MX_COMMAND_PARAMS-1)) BIT (1),
      2258        %(LEVEL+1) PARAM$(0:%(MX_COMMAND_PARAMS-1)) PTR %ENDCHAR
      2259
      2260  %MEND;
      2261
      2262  /*
      2263  *   Subscripts into VD$IT_COMMAND.FLAGS array, for each command.
      2264  */
      2265  /* For the SAVE command */
      2266  %EQU CF_SAVE_ALL = 0;       /* SAVE ALL ... */
      2267  %EQU CF_SAVE_SETUP = 1;     /* SAVE SETUP ... */
      2268  %EQU CF_SAVE_SESSION = 2;   /* SAVE SESSION ... */
      2269  %EQU CF_SAVE_TO = 3;        /* SAVE ... TO or ON fid */
      2270  %EQU CF_SAVE_OVER = 4;      /* SAVE ... OVER fid */
      2271
      2272  /* For the WINDOW command */
      2273  %EQU CF_WI_DELETE = 0;  /* Delete the window */
      2274  %EQU CF_WI_NEW = 1;     /* Define a New Window */
      2275
      2276  /*
      2277  *   Subscripts into VD$IT_COMMAND.PARAM$ array, for each command.
      2278  */
      2279  /* For all editing commands */
      2280  %EQU CP_EDCMD_BLOCK = 0;    /* Block to operate upon */
      2281
      2282  /* For the EQUALS command */
      2283  %EQU CP_EQ_NAME = 0;    /* Name being assigned */
      2284  %EQU CP_EQ_VALUE = 1;   /* Value being assigned to name */
      2285  %EQU CP_EQ_IN = 2;      /* IN-window specifier */
      2286
      2287  /* For the KEYIN command */
      2288  %EQU CP_KE_NAME = 0;    /* Name being assigned */
      2289  %EQU CP_KE_VALUE = 1;   /* Value being assigned to name */
      2290  %EQU CP_KE_IN = 2;      /* IN-window specifier */
      2291
      2292  /* For the LOCATION command */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 87
      2293  /* Note that subscript 0 is used for CP_EDCMD_BLOCK */
      2294  %EQU CP_LO_NAME = 1;    /* Name being assigned */
      2295
      2296  /* For the READ command */
      2297  %EQU CP_READ_FID = 0;           /* Fid to read */
      2298  %EQU CP_READ_NEXT_COMMAND = 1;  /* Offset of next command in cmd line */
      2299
      2300  /* For the RESTORE command */
      2301  %EQU CP_RESTORE_FID = 0;        /* Fid to restore from */
      2302
      2303  /* For the SAVE command */
      2304  %EQU CP_SAVE_FID = 0;   /* Fid to write to */
      2305
      2306  /* For the SYNONYM command */
      2307  %EQU CP_SY_NAME = 0;    /* Name being assigned */
      2308  %EQU CP_SY_VALUE = 1;   /* Value being assigned to name */
      2309
      2310  /* For the WINDOW command */
      2311  %EQU CP_WI_LINES = 1;   /* Height of window in lines */
      2312  %EQU CP_WI_NUM = 2;     /* Window Identifier */
      2313
      2314
      2315  /*
      2316  *   VD$IT_OPERAND
      2317  *   InTree node for an absolute or relative block operand or
      2318  *       parenthesized block-expr.
      2319  *
      2320  *   CODE: Code for operand
      2321  *   OPTIONS: Movement evaluation options
      2322  *   KEY: Optional key parameter
      2323  *   PARAM: Optional object parameter
      2324  */
      2325  %MACRO VD$IT_OPERAND (NAME=VD$IT_OPERAND,
      2326   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2327   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2328
      2329  %IF TEXTCHAR(LEV) = 'AUTO';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 88
      2330     %LSET LEVEL = LEVEL + 1;
      2331  %ELSE;
      2332     %LSET LEVEL = LEV;
      2333  %ENDIF;
      2334
      2335  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2336  %IF LEVEL = 1;
      2337  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2338  %ELSE;
      2339   %(LEVEL) NAME DIM ALIGNMENT,
      2340  %ENDIF;
      2341
      2342        %VD$OBJECT_HEADER (NAME=OBJECT);
      2343        %(LEVEL+1) PARENT$ PTR,
      2344        %(LEVEL+1) FLINK$ PTR,
      2345        %(LEVEL+1) CODE# UBIN HALF HALIGNED,
      2346        %VD$EVAL_OPTIONS (NAME=OPTIONS);
      2347        %VD$KEY (NAME=KEY);
      2348        %(LEVEL+1) PARAM$ PTR %ENDCHAR
      2349
      2350  %MEND;
      2351
      2352  /*
      2353  *   OPAND_? - EQUs for VD$IT_OPERAND.CODE in the InTree
      2354  */
      2355  %EQU OPAND_FILE = 1;        /*  .KEY is file-level key      */
      2356  %EQU OPAND_LO_NAME = 2;     /*  .KEY is key of name in locations file */
      2357  %EQU OPAND_NEXT = 3;        /*                              */
      2358  %EQU OPAND_PREVIOUS = 4;    /*                              */
      2359  %EQU OPAND_BLOCK_DESC = 5;  /*  .PARAM$ -> VD$BLOCK_DESC    */
      2360  %EQU OPAND_NODE = 6;        /*  if absolute, .KEY is absolute key */
      2361  %EQU OPAND_POSITION = 7;    /*  if absolute, .KEY.BYTES# is abs pos'n */
      2362  %EQU OPAND_PATTERN = 8;     /*  .PARAM$ -> VD$PATTERN       */
      2363  %EQU OPAND_BLOCK_EXPR = 9;  /*  .PARAM$ -> VD$IT_BLOCK_EXPR (nested) */
      2364
      2365
      2366  /*

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 89
      2367  *   VD$IT_OPERATOR
      2368  *   InTree node for a block operator.
      2369  *
      2370  *   CODE: Code for operator
      2371  *   OPERAND: Operand to apply operator to
      2372  *   R_OPERAND: Right-hand opand for binary opors
      2373  */
      2374  %MACRO VD$IT_OPERATOR (NAME=VD$IT_OPERATOR,
      2375   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2376   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2377
      2378  %IF TEXTCHAR(LEV) = 'AUTO';
      2379     %LSET LEVEL = LEVEL + 1;
      2380  %ELSE;
      2381     %LSET LEVEL = LEV;
      2382  %ENDIF;
      2383
      2384  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2385  %IF LEVEL = 1;
      2386  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2387  %ELSE;
      2388   %(LEVEL) NAME DIM ALIGNMENT,
      2389  %ENDIF;
      2390
      2391        %VD$OBJECT_HEADER (NAME=OBJECT);
      2392        %(LEVEL+1) PARENT$ PTR,
      2393        %(LEVEL+1) FLINK$ PTR,
      2394        %(LEVEL+1) CODE# UBIN HALF HALIGNED,
      2395        %(LEVEL+1) *   BIT(18), /* RFU */
      2396        %(LEVEL+1) OPERAND$ PTR,
      2397        %(LEVEL+1) R_OPERAND$ PTR %ENDCHAR
      2398
      2399  %MEND;
      2400
      2401  /*
      2402  *  OPOR_? - EQUs for VD$IT_OPERATOR.CODE in the InTree
      2403  */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 90
      2404  %EQU OPOR_OPTIONAL = 1;             /*                              */
      2405  %EQU OPOR_AND = 2;                  /*                              */
      2406  %EQU OPOR_OR = 3;                   /*                              */
      2407  %EQU OPOR_NOT = 4;                  /*                              */
      2408
      2409
      2410  /*
      2411  *   VD$IT_SELECT
      2412  *   InTree node for a subset (range) selection.
      2413  *   RPT_ALL: Flag for "ALL" range selection repeat count
      2414  *           If set, .RPT_COUNT is ignored
      2415  *   RPT_COUNT: Range selection repeat count:
      2416  *           # times to re-evaluate this subtree of
      2417  *           block expr. Ignored if .RPT_ALL set
      2418  *   ADJUSTS: VD$IT_ADJUST children
      2419  */
      2420  %MACRO VD$IT_SELECT (NAME=VD$IT_SELECT,
      2421   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2422   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2423
      2424  %IF TEXTCHAR(LEV) = 'AUTO';
      2425     %LSET LEVEL = LEVEL + 1;
      2426  %ELSE;
      2427     %LSET LEVEL = LEV;
      2428  %ENDIF;
      2429
      2430  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2431  %IF LEVEL = 1;
      2432  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2433  %ELSE;
      2434   %(LEVEL) NAME DIM ALIGNMENT,
      2435  %ENDIF;
      2436
      2437        %VD$OBJECT_HEADER (NAME=OBJECT);
      2438        %(LEVEL+1) PARENT$ PTR,
      2439        %(LEVEL+1) FLINK$ PTR,
      2440        %(LEVEL+1) RPT_ALL BIT (1),

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 91
      2441        %(LEVEL+1) * BIT(17), /* RFU */
      2442        %(LEVEL+1) RPT_COUNT# SBIN HALF HALIGNED,
      2443        %(LEVEL+1) ADJUSTS$ PTR,
      2444        %(LEVEL+1) ADJUSTS_TAIL$ PTR %ENDCHAR
      2445
      2446  %MEND;
      2447
      2448
      2449  /*
      2450  *   VD$KEY
      2451  *   Key of a node.  A textc string, containing either a binary number or
      2452  *       a string:  TYPE tells how to interpret the textc string.
      2453  *   For string keys, the string will be stored locally if it`s
      2454  *       <= MXNB_STRING_LOCAL bytes.
      2455  *       Else the string is stored remotely in a VD$TEXTC_REMOTE
      2456  *           or VD$FILE_KEY object.
      2457  *
      2458  *   VD$KEY =>           VD$KEY for long string keys stored in dynamic storage
      2459  *   VD$KEY_LOCAL =>    VD$KEY for short string keys stored locally
      2460  *   VD$KEY_NUMBER =>   VD$KEY for numeric keys (always stored locally)
      2461  */
      2462  %MACRO VD$KEY (NAME=VD$KEY,
      2463   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2464   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2465
      2466  %IF TEXTCHAR(LEV) = 'AUTO';
      2467     %LSET LEVEL = LEVEL + 1;
      2468  %ELSE;
      2469     %LSET LEVEL = LEV;
      2470  %ENDIF;
      2471
      2472  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2473  %IF LEVEL = 1;
      2474  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2475  %ELSE;
      2476   %(LEVEL) NAME DIM ALIGNMENT,
      2477  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 92
      2478
      2479        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,
      2480        %(LEVEL+1) REP# UBIN HALF HALIGNED,
      2481        %(LEVEL+1) V$ PTR %ENDCHAR
      2482
      2483  %MEND;
      2484
      2485  %MACRO VD$KEY_LOCAL (NAME=VD$KEY_LOCAL,
      2486   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2487   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2488
      2489  %IF TEXTCHAR(LEV) = 'AUTO';
      2490     %LSET LEVEL = LEVEL + 1;
      2491  %ELSE;
      2492     %LSET LEVEL = LEV;
      2493  %ENDIF;
      2494
      2495  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2496  %IF LEVEL = 1;
      2497  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2498  %ELSE;
      2499   %(LEVEL) NAME DIM ALIGNMENT,
      2500  %ENDIF;
      2501
      2502        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,
      2503        %(LEVEL+1) REP# UBIN HALF HALIGNED,
      2504        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      2505        %(LEVEL+1) BYTES CHAR (%MXNB_STRING_LOCAL) %ENDCHAR
      2506
      2507  %MEND;
      2508
      2509  %MACRO VD$KEY_NUMBER (NAME=VD$KEY_NUMBER,
      2510   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2511   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2512
      2513  %IF TEXTCHAR(LEV) = 'AUTO';
      2514     %LSET LEVEL = LEVEL + 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 93
      2515  %ELSE;
      2516     %LSET LEVEL = LEV;
      2517  %ENDIF;
      2518
      2519  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2520  %IF LEVEL = 1;
      2521  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2522  %ELSE;
      2523   %(LEVEL) NAME DIM ALIGNMENT,
      2524  %ENDIF;
      2525
      2526        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,
      2527        %(LEVEL+1) REP# UBIN HALF HALIGNED,
      2528        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      2529        %(LEVEL+1) BYTES# UBIN (27) CALIGNED %ENDCHAR
      2530
      2531  %MEND;
      2532
      2533  /*
      2534  *   VD_KEY
      2535  *   Initializing version of VD$KEY.
      2536  *   Macro parameters:
      2537  *   STCLASS must be STATIC or CONSTANT.
      2538  *   ITYPE should be a %KT_ definition; it initializes the .TYPE field.
      2539  *   IREP should be a %REP_ def; it initializes the .REP field.
      2540  *   IBYTES initializes the .V$ or .LENGTH#/.BYTES fields.
      2541  *       What IBYTES should be, based on ITYPE and IREP, is:
      2542  *           ITYPE       IREP            IBYTES
      2543  *           ----------  --------------  ----------------------------
      2544  *           %KT_STRING  %REP_LOCAL      character string expression
      2545  *           %KT_STRING  %REP_REMOTE     name of VD_TEXTC_REMOTE (or
      2546  *                                           "string_object" variant)
      2547  *           %KT_NUMBER  %REP_LOCAL      integer expression
      2548
      2549  *           %KT_EDITKEY %REP_LOCAL      integer expression
      2550  *           %KT_EDITKEY %REP_REMOTE     (this combo is illegal)
      2551  *           %KT_NUMBER  %REP_REMOTE     (this combo is illegal)

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 94
      2552  *   The default is to build a %CLEAR VD$KEY structure.
      2553  */
      2554  %MACRO VD_KEY (NAME=VD_KEY, STCLASS=STATIC, ALIGNMENT=ALIGNED, DIM=" ",
      2555      LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      2556      ITYPE=0, IREP=0, IBYTES=0);
      2557
      2558  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      2559  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      2560  %LSET INIT=CHARTEXT('INIT');
      2561  %LSET EIN=CHARTEXT(' ');
      2562  %ELSE;
      2563  %LSET INIT=CHARTEXT('/*');
      2564  %LSET EIN=CHARTEXT('*/');
      2565  %ENDIF;
      2566
      2567  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2568  %IF LEVEL = 1;
      2569  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2570  %ELSE;
      2571   %(LEVEL) NAME DIM ALIGNMENT,
      2572  %ENDIF;
      2573         %(LEVEL+1) TYPE# UBIN HALF HALIGNED %INIT (ITYPE) %EIN,
      2574         %(LEVEL+1) REP# UBIN HALF HALIGNED %INIT (IREP) %EIN,
      2575  %IF ITYPE=0;
      2576         %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (0) %EIN,
      2577         %(LEVEL+1) BYTES# UBIN(27) CALIGNED %INIT (0) %EIN  %ENDCHAR
      2578  %ELSE;
      2579     %IF ITYPE=%KT_NUMBER OR ITYPE=%KT_EDITKEY;
      2580         %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (%MXNB_STRING_LOCAL) %EIN,
      2581         %(LEVEL+1) BYTES# UBIN(27) CALIGNED %INIT (IBYTES) %EIN  %ENDCHAR
      2582     %ELSE;
      2583        %IF IREP=REP_LOCAL;
      2584         %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (LENGTHC(IBYTES)) %EIN,
      2585         %(LEVEL+1) BYTES CHAR(%MXNB_STRING_LOCAL) CALIGNED
      2586             %INIT (IBYTES) %EIN  %ENDCHAR
      2587        %ELSE;
      2588           %IF 'IBYTES'='0';

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 95
      2589              %LSET IB='NIL';
      2590           %ELSE;
      2591              %LSET IB=TEXTCHAR(IBYTES);
      2592              %ENDIF;
      2593         %(LEVEL+1) V$ PTR %INIT (ADDR(%CHARTEXT(IB))) %EIN  %ENDCHAR
      2594           %ENDIF;     /* Local or Remote */
      2595        %ENDIF;     /* Number or String */
      2596     %ENDIF;     /* Type omitted */
      2597
      2598  %MEND;
      2599
      2600  /*
      2601  *   KT_? - Key type
      2602  */
      2603  %EQU KT_NUMBER = 1;                 /*  27-bit binary number        */
      2604  %EQU KT_STRING = 2;                 /*  String of bytes             */
      2605  %EQU KT_EDITKEY = 3;                /*  EDIT file key               */
      2606  %EQU KT_MXP1 = 4;                   /*  Max KT_ plus 1              */
      2607
      2608  /*
      2609  *   REP_? - Storage representation for textc strings
      2610  */
      2611  %EQU REP_LOCAL = 1;                 /*  In-line VD$TEXTC            */
      2612  %EQU REP_REMOTE = 2;                /*  Pointer to VD$REMOTE_TEXTC  */
      2613
      2614
      2615  /*
      2616  *   VD$LOCATION
      2617  *   A location within a file.
      2618  *   Usually, this points to a byte in a record.  Actually, the location
      2619  *       specified is the "left edge of the cursor", or the point in front
      2620  *       of the byte being pointed-to.
      2621  *   However, not all keys in the file`s structure need be given.  If
      2622  *       keys down to the record level are not given, then .POSITION
      2623  *       is ignored, and the "location" referred to is the "left edge" of
      2624  *       the node specified by the last key given.  If no keys are given,
      2625  *       this is the "left edge" of the file (or enclosing range)

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 96
      2626  *       that is, BOF.
      2627  *       The "left edge" of a node is the first byte of the first record
      2628  *       included in that node.
      2629  *   Note that the file level is not included in the set of keys given in
      2630  *       a VD$LOCATION; the first key in .KEY is the key for level 1 of
      2631  *       the file structure.
      2632  *   If EOF is set, .KEY and .POSITION are ignored.
      2633  *   Note that the location specified may be in any component of the
      2634  *       record:  Key, Spec, or Data.  The domain of the block expression
      2635  *       (outermost enclosing block, at the file level) specifies which
      2636  *       record component we`re looking at.
      2637  *
      2638  *   KEY: Keys from level 1 thru record level
      2639  *   POSITION: Optional byte offset into record data
      2640  *   EOF: If set ignore .KEY and .POSITION
      2641  */
      2642  %MACRO VD$LOCATION (NAME=VD$LOCATION,
      2643   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2644   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2645
      2646  %IF TEXTCHAR(LEV) = 'AUTO';
      2647     %LSET LEVEL = LEVEL + 1;
      2648  %ELSE;
      2649     %LSET LEVEL = LEV;
      2650  %ENDIF;
      2651
      2652  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2653  %IF LEVEL = 1;
      2654  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2655  %ELSE;
      2656   %(LEVEL) NAME DIM ALIGNMENT,
      2657  %ENDIF;
      2658
      2659        %VD$KEY (NAME=KEY, DIM="(0:%(MX_LOCATION_LEVELS-1))");
      2660        %(LEVEL+1) POSITION# SBIN HALF HALIGNED,
      2661        %(LEVEL+1) EOF BIT (1),
      2662        %(LEVEL+1) *   BIT(17) %ENDCHAR /* RFU */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 97
      2663
      2664  %MEND;
      2665
      2666  /*
      2667  *   VD_LOCATION
      2668  *   Initializing version of VD$LOCATION.
      2669  *   STCLASS must be STATIC or CONSTANT.
      2670  *   INITS specifies the number of keys to initialize:  0 thru 4.
      2671  *       Default is 0.  ITYPEn, IREPn, and IBYTESn may only be
      2672  *       given for n <= INITS.  Remainder of .KEYs will be %CLEARed.
      2673  *   ITYPEn, IREPn, and IBYTESn are as described for VD_KEY.
      2674  *       "n" is the level number: 1 thru 4 (for subscripts 0 - 3).
      2675  *   IPOSITION initializes the POSITION field.
      2676  *   IEOF initializes the EOF field.
      2677  */
      2678  %MACRO VD_LOCATION (NAME=VD_LOCATION, STCLASS=STATIC, DIM=" ",
      2679      ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2, INITS=0,
      2680      ITYPE1=0, ITYPE2=0, ITYPE3=0, ITYPE4=0,
      2681      IREP1=0, IREP2=0, IREP3=0, IREP4=0,
      2682      IBYTES1=0, IBYTES2=0, IBYTES3=0, IBYTES4=0,
      2683      IPOSITION=0, IEOF='0'B);
      2684
      2685  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      2686  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      2687  %LSET INIT=CHARTEXT('INIT');
      2688  %LSET EIN=CHARTEXT(' ');
      2689  %ELSE;
      2690  %LSET INIT=CHARTEXT('/*');
      2691  %LSET EIN=CHARTEXT('*/');
      2692  %ENDIF;
      2693
      2694  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2695  %IF LEVEL = 1;
      2696  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2697  %ELSE;
      2698   %(LEVEL) NAME DIM ALIGNMENT,
      2699  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 98
      2700
      2701  %LSET NLEVEL=LEVEL+1;
      2702  %IF INITS<1;        /* No initializers */
      2703          %NLEVEL KEY (0:4),
      2704            %(NLEVEL+1) TYPE# UBIN HALF HALIGNED %INIT (0*0) %EIN,
      2705            %(NLEVEL+1) REP# UBIN HALF HALIGNED %INIT (0*0) %EIN,
      2706            %(NLEVEL+1) V SBIN %INIT (0*0) %EIN,
      2707  %ELSE;
      2708            %VD_KEY (NAME=KEY, DIM="(0:0)", LEVEL=%NLEVEL, STCLASS=STCLASS,
      2709            LAST=NO, ITYPE=ITYPE1, IREP=IREP1, IBYTES=IBYTES1);
      2710
      2711  %IF INITS<2;        /* No 2nd initializer */
      2712          %NLEVEL * (0:5) SBIN %INIT (0*0) %EIN,
      2713  %ELSE;
      2714            %VD_KEY (NAME="*", LEVEL=%NLEVEL, STCLASS=STCLASS, LAST=NO,
      2715            ITYPE=ITYPE2, IREP=IREP2, IBYTES=IBYTES2);
      2716
      2717  %IF INITS<3;        /* No 3rd initializer */
      2718          %NLEVEL * (0:3) SBIN %INIT (0*0) %EIN,
      2719  %ELSE;
      2720            %VD_KEY (NAME="*", LEVEL=%NLEVEL, STCLASS=STCLASS, LAST=NO,
      2721            ITYPE=ITYPE3, IREP=IREP3, IBYTES=IBYTES3);
      2722
      2723  %IF INITS<4;        /* No 4th initializer */
      2724          %NLEVEL * (0:1) SBIN %INIT (0*0) %EIN,
      2725  %ELSE;
      2726            %VD_KEY (NAME="*", LEVEL=%NLEVEL, STCLASS=STCLASS, LAST=NO,
      2727            ITYPE=ITYPE4, IREP=IREP4, IBYTES=IBYTES4);
      2728
      2729  %ENDIF;     /* INITS=4 */
      2730  %ENDIF;     /* INITS=3 */
      2731  %ENDIF;     /* INITS=2 */
      2732  %ENDIF;     /* INITS=1 */
      2733
      2734          %NLEVEL POSITION# SBIN HALF HALIGNED %INIT (IPOSITION) %EIN,
      2735            %NLEVEL EOF BIT (1) %INIT (IEOF) %EIN,
      2736            %NLEVEL * BIT(17) %INIT (%CLEAR) %EIN %ENDCHAR

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 99
      2737
      2738  %MEND;
      2739
      2740
      2741  /*
      2742  *   VD$LOCATION_PTRS
      2743  *   Passed to VDG$COMPARE_PTRS_W_xxx and VDG$COMPARE_xxx_W_PTRS.
      2744  *   Contains same info as a VD$LOCATION, but with pointers to keys
      2745  *       rather than VD$KEYs.  These pointers are to the
      2746  *       VD$TEXTC strings for each key at each index of a VD$LOCATION.
      2747  *       Note that these are the keys for levels 1 thru "n" of a
      2748  *       file structure; level 0 of the structure is omitted from
      2749  *       VD$LOCATIONs.
      2750  *
      2751  *   POSITION: Optional byte offset into data
      2752  *   EOF: If set, ignore .KEY and .POSITION
      2753  *   COUNT: # of ptrs in .KEY$
      2754  *   KEY: GETKEY ptrs = ptrs to simple VD$TEXTCs
      2755  */
      2756  %MACRO VD$LOCATION_PTRS (NAME=VD$LOCATION_PTRS,
      2757   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2758   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2759
      2760  %IF TEXTCHAR(LEV) = 'AUTO';
      2761     %LSET LEVEL = LEVEL + 1;
      2762  %ELSE;
      2763     %LSET LEVEL = LEV;
      2764  %ENDIF;
      2765
      2766  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2767  %IF LEVEL = 1;
      2768  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2769  %ELSE;
      2770   %(LEVEL) NAME DIM ALIGNMENT,
      2771  %ENDIF;
      2772
      2773        %(LEVEL+1) POSITION# SBIN HALF HALIGNED,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 100
      2774        %(LEVEL+1) EOF BIT (1),
      2775        %(LEVEL+1) COUNT# UBIN BYTE CALIGNED,
      2776        %(LEVEL+1) KEY$(0:%(MX_LOCATION_LEVELS-1)) PTR %ENDCHAR
      2777
      2778  %MEND;
      2779
      2780
      2781  /*
      2782  *   VD$NAC - Access flags (bit-wise) for specific nodes of internal files
      2783  *   These flags are used only for nodes of always-internal files:
      2784  *       Names, Structures, and Windows.
      2785  */
      2786  %MACRO VD$NAC (NAME=VD$NAC,
      2787   STCLASS=BASED, DIM=" ", ALIGNMENT=UNAL,
      2788   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      2789
      2790  %ERROR (TEXTCHAR(DIM)~=' ','"DIM" may not be specified when invoking NAC',2);
      2791
      2792  %IF TEXTCHAR(LEV) = 'AUTO';
      2793     %LSET LEVEL = LEVEL + 1;
      2794  %ELSE;
      2795     %LSET LEVEL = LEV;
      2796  %ENDIF;
      2797
      2798  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2799  %IF LEVEL = 1;
      2800  DCL 1 NAME(0:8) BIT (1) ALIGNMENT STCLASS;
      2801  %ELSE;
      2802        %(LEVEL) NAME(0:8) BIT (1) ALIGNMENT %ENDCHAR
      2803  %ENDIF;
      2804
      2805  %MEND;
      2806
      2807  /*
      2808  *   VD_NAC
      2809  *   Initializing version for NAC.
      2810  *   This macro declares a two-level structure, so we can align

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 101
      2811  *       the parent structure while leaving the bits UNAL.
      2812  */
      2813  %MACRO VD_NAC (NAME=VD_NAC, STCLASS=STATIC, ALIGNMENT=ALIGNED,
      2814      DIM=" ", LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      2815      READ=%FALSE, WRITE=%FALSE, DELETE=%FALSE);
      2816
      2817  %ERROR (TEXTCHAR(DIM)~=' ','"DIM" may not be specified when invoking VD_NAC',2);
      2818
      2819  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      2820  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      2821  %LSET INIT=CHARTEXT('INIT');
      2822  %LSET EIN=CHARTEXT(' ');
      2823  %ELSE;
      2824  %LSET INIT=CHARTEXT('/*');
      2825  %LSET EIN=CHARTEXT('*/');
      2826  %ENDIF;
      2827
      2828  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2829  %IF LEVEL = 1;
      2830  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2831  %ELSE;
      2832   %(LEVEL) NAME DIM ALIGNMENT,
      2833  %ENDIF;
      2834
      2835      %(LEVEL+1) ACCESS (0:8) BIT(1) UNAL
      2836          %INIT (%FALSE, READ, WRITE, DELETE, %FALSE*0) %EIN   %ENDCHAR
      2837
      2838  %MEND;
      2839
      2840  /*
      2841  *   NAC_? - Access flags (bit-wise) for specific nodes of internal files
      2842  *   These flags are used only for nodes of always-internal files:
      2843  *       Names, Structures, and Windows.
      2844  */
      2845  %EQU NAC_READ = 1;                  /*  User can read node          */
      2846  %EQU NAC_WRITE = 2;                 /*  User can change any component of node */
      2847  %EQU NAC_DELETE = 3;                /*  User can delete node        */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 102
      2848
      2849  /*
      2850  *   NAC_x_BIT - Bits corresponding to node access flags.
      2851  *   Since PL6 doesn't support nested arrays, when we want an array
      2852  *       of bit-flags inside an array of something else, we must
      2853  *       declare the inner bit-flag-array as a bit-string instead.
      2854  *       This happens with %NAC_ fields:  when we want this array
      2855  *       to appear inside an array of something else, we declare it
      2856  *       as a bit-string instead, and we use the following %NAC_x_BIT
      2857  *       names to refer to the bit-flags for individual (or sets of)
      2858  *       access flags.
      2859  *   These bit-masks are intended for use with BIT(9) strings;
      2860  *       because of the way bit-strings are compared and assigned
      2861  *       (left-to-right, padded/truncated on right), these bit-masks
      2862  *       will work on longer bit-strings, but not on shorter ones.
      2863  */
      2864  %EQU NAC_READ_BIT = '010000000'B;   /* NAC_READ = 1 */
      2865  %EQU NAC_WRITE_BIT = '001000000'B;  /* NAC_WRITE = 2 */
      2866  %EQU NAC_READ_WRITE_BITS = NAC_READ_BIT | NAC_WRITE_BIT;
      2867  %EQU NAC_DELETE_BIT = '000100000'B; /* NAC_DELETE = 3 */
      2868  %EQU NAC_ALL_BITS = '111111111'B;   /* Allow all possible types of access */
      2869
      2870
      2871  /*
      2872  *   VD$NAME_SPEC
      2873  *   The Spec component of records in a Names internal file.
      2874  *   VD$FILE_NODE.DESC.SPEC.V$ points to a VD$NAME_SPEC object (which is
      2875  *       a sub-class of "string_objects").
      2876  *
      2877  *   DATA_TYPE: Type of data in Data component of record
      2878  *   LEGAL_DATA_TYPE: If non-0, is the only legal DATA_TYPE
      2879  *   WINDOWABLE: Can be window-specific ("FOR" clause
      2880  *   M: Min legal value (number) or length (string)
      2881  *   N: Max legal value (number) or length (string)
      2882  *   READER: Opt. routine to read value
      2883  *   WRITER: Opt. routine to write value
      2884  *

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 103
      2885  *   Note that .LEGAL_DATA_TYPE is initialized with the same value
      2886  *       that is used for .DATA_TYPE, 'cause we figger a static/constant
      2887  *       VD$NAME_SPEC is used for the predefined names, which are
      2888  *       not allowed to change types.
      2889  */
      2890  %MACRO VD$NAME_SPEC (NAME=VD$NAME_SPEC,
      2891   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      2892   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      2893   ITYPE=0, IWINDOWABLE='0'B, IM=0, IN=0, IREADER=0, IWRITER=0);
      2894
      2895  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      2896  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      2897  %LSET INIT=CHARTEXT('INIT');
      2898  %LSET EIN=CHARTEXT(' ');
      2899  %ELSE;
      2900  %LSET INIT=CHARTEXT('/*');
      2901  %LSET EIN=CHARTEXT('*/');
      2902  %ENDIF;
      2903
      2904  %IF TEXTCHAR(LEV) = 'AUTO';
      2905     %LSET LEVEL = LEVEL + 1;
      2906  %ELSE;
      2907     %LSET LEVEL = LEV;
      2908  %ENDIF;
      2909
      2910  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      2911  %IF LEVEL = 1;
      2912  DCL 1 NAME DIM STCLASS ALIGNMENT,
      2913  %ELSE;
      2914   %(LEVEL) NAME DIM ALIGNMENT,
      2915  %ENDIF;
      2916
      2917        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=%CLS_NAME_SPEC);
      2918        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      2919        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (19) %EIN,
      2920        %(LEVEL+1) * BIT(9) %INIT (%CLEAR) %EIN,
      2921        %(LEVEL+1) DATA_TYPE# UBIN HALF HALIGNED %INIT (ITYPE) %EIN,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 104
      2922        %(LEVEL+1) LEGAL_DATA_TYPE# UBIN HALF HALIGNED %INIT (ITYPE) %EIN,
      2923        %(LEVEL+1) WINDOWABLE BIT(1) %INIT (IWINDOWABLE) %EIN,
      2924        %(LEVEL+1) * BIT(17) %INIT (%CLEAR) %EIN,
      2925        %(LEVEL+1) M# SBIN WORD %INIT (IM) %EIN,
      2926        %(LEVEL+1) N# SBIN WORD %INIT (IN) %EIN,
      2927        %(LEVEL+1) READER# UBIN HALF HALIGNED %INIT (IREADER) %EIN,
      2928        %(LEVEL+1) WRITER# UBIN HALF HALIGNED %INIT (IWRITER) %EIN %ENDCHAR
      2929
      2930  %MEND;
      2931
      2932  /*
      2933  *   VD_NAME_SPEC
      2934  *   Version of VD$NAME_SPEC.
      2935  */
      2936  %MACRO VD_NAME_SPEC (NAME=VD_NAME_SPEC, STCLASS=STATIC,
      2937      DIM=" ", ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      2938      ITYPE=0, IWINDOWABLE='0'B, IM=0, IN=0, IREADER=0, IWRITER=0);
      2939
      2940  %VD$NAME_SPEC( NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      2941      LEV=LEVEL, LAST=LAST, ITYPE=ITYPE, IWINDOWABLE=IWINDOWABLE, IM=IM,IN=IN,
      2942      IREADER=IREADER, IWRITER=IWRITER);
      2943
      2944  %MEND;
      2945
      2946  /*
      2947
      2948  *   NDT_? - EQUs for Node Data Types
      2949  */
      2950  %EQU NDT_EQUALS = 1;                /*  Data is string value        */
      2951  %EQU NDT_LOCATION = 2;              /*  Data is block descriptor    */
      2952  %EQU NDT_SYNONYM = 3;               /*  Data is string synonym      */
      2953  %EQU NDT_KEYIN = 4;                 /*  Data is string (IMP TEXT)   */
      2954  %EQU NDT_MXP1 = 5;                  /*  Maximum NDT_ value, plus 1  */
      2955
      2956  /*
      2957  *   RDR - Reader-codes for predefined names:  how to find the data.
      2958  *   For each RDR_`s name, the actual Data-component value is

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 105
      2959  *       stored elsewhere in the internal workspace; therefore,
      2960  *       the Accessor must go find the data each time it reads the name.
      2961  */
      2962  %EQU RDR_$ENCLOSING = 1;            /*                              */
      2963  %EQU RDR_$RANGE = 2;                /*                              */
      2964  %EQU RDR_$FP = 3;                   /*                              */
      2965  %EQU RDR_CURRENT = 4;               /*                              */
      2966  %EQU RDR_THAT = 5;                  /*                              */
      2967  %EQU RDR_HERE = 6;                  /*                              */
      2968  %EQU RDR_$ENCLOSING_SOURCE = 7;     /*  Internally generated, for   */
      2969  %EQU RDR_$RANGE_SOURCE = 8;         /*  refs to these names in the  */
      2970  %EQU RDR_$FP_SOURCE = 9;            /*  source operand's InTree     */
      2971  %EQU RDR_$FILETYPE = 10;            /*  Obtained from the currently */
      2972  %EQU RDR_$FILERECORDS = 11;         /*  open                        */
      2973  %EQU RDR_$FILEORG = 12;             /*  edit file DCB.              */
      2974  %EQU RDR_MXP1 = 13;                 /*  Max RDR_ value, plus 1      */
      2975
      2976  /*
      2977  *   WRTR - Writer-codes for predefined names:  where to store the data.
      2978  *   For each WRTR_`s name, there is a global value which holds
      2979  *       an internal representation of the value of the name.
      2980  *       Each time the Accessor writes to the name, it should also
      2981  *       update the global value.
      2982  *   These codes also identify those names whose values must be
      2983  *       verified before updating them, and those whose values must
      2984  *       be told to others (eg, inform FEP of change in the name`s
      2985  *       value).
      2986  */
      2987  %EQU WRTR_$$INCANTATION = 1;        /*  Verify                      */
      2988  %EQU WRTR_$$MON_ACC = 2;            /*  Verify                      */
      2989  %EQU WRTR_$$MON_EVAL = 3;           /*  Verify                      */
      2990  %EQU WRTR_$$MON_PRES = 4;           /*  Verify                      */
      2991  %EQU WRTR_$$QUAC = 5;               /*  Verify                      */
      2992  %EQU WRTR_$AUTOTAB = 6;             /*  Tell FEP                    */
      2993  %EQU WRTR_$BY = 7;                  /*  Verify                      */
      2994  %EQU WRTR_$CASE = 8;                /*                              */
      2995  %EQU WRTR_$COMMAND = 9;             /*                              */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 106
      2996  %EQU WRTR_$COMMENT = 10;            /*  Verify                      */
      2997  %EQU WRTR_$COMPONENT = 11;          /*                              */
      2998  %EQU WRTR_$CONTEXT = 12;            /*                              */
      2999  %EQU WRTR_$CONTROL = 13;            /*                              */
      3000  %EQU WRTR_$DEFAULT_DEST = 14;       /*                              */
      3001  %EQU WRTR_$DEFAULT_SOURCE = 15;     /*                              */
      3002  %EQU WRTR_$DIRECTION = 16;          /*                              */
      3003  %EQU WRTR_$ECHO = 17;               /*                              */
      3004  %EQU WRTR_$EXIST = 18;              /*                              */
      3005  %EQU WRTR_$HSCROLL = 19;            /*  Tell FEP                    */
      3006  %EQU WRTR_$HSCROLL_MARGIN = 20;     /*  Tell FEP                    */
      3007  %EQU WRTR_$INSERT = 21;             /*  Tell FEP                    */
      3008  %EQU WRTR_$INTRO_1 = 22;            /*  Verify                      */
      3009  %EQU WRTR_$INTRO_2 = 23;            /*  Verify                      */
      3010  %EQU WRTR_$KEY_GENERATION = 24;     /*  Tell FEP                    */
      3011  %EQU WRTR_$MATCHES = 25;            /*                              */
      3012  %EQU WRTR_$MATCH_LIMIT = 26;        /*                              */
      3013  %EQU WRTR_$MAX_COMMAND = 27;        /*                              */
      3014  %EQU WRTR_$MAX_RECORD = 28;         /*                              */
      3015  %EQU WRTR_$MIN_COMMAND = 29;        /*                              */
      3016  %EQU WRTR_$MIN_RECORD = 30;         /*                              */
      3017  %EQU WRTR_$PAD = 31;                /*                              */
      3018  %EQU WRTR_$POINT = 32;              /*                              */
      3019  %EQU WRTR_$PROTECT = 33;            /*                              */
      3020  %EQU WRTR_$RECORDS_DELETED = 34;    /*                              */
      3021  %EQU WRTR_$RECORDS_INSERTED = 35;   /*                              */
      3022  %EQU WRTR_$RECORDWRAP = 36;         /*                              */
      3023  %EQU WRTR_$RESTORE = 37;            /*                              */
      3024  %EQU WRTR_$SCREEN = 38;             /*                              */
      3025  %EQU WRTR_$SEARCH = 39;             /*                              */
      3026  %EQU WRTR_$SITES = 40;              /*                              */
      3027  %EQU WRTR_$SKIP = 41;               /*                              */
      3028  %EQU WRTR_$STRIP_BLANKS = 42;       /*                              */
      3029  %EQU WRTR_$STRUCTURE = 43;          /*                              */
      3030  %EQU WRTR_$VSCROLL = 44;            /*  Tell FEP                    */
      3031  %EQU WRTR_$VSCROLL_MARGIN = 45;     /*  Tell FEP                    */
      3032  %EQU WRTR_$WI_BORDER = 46;          /*                              */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 107
      3033  %EQU WRTR_$WI_PERCENT = 47;         /*                              */
      3034  %EQU WRTR_$WORDWRAP = 48;           /*  Tell FEP                    */
      3035  %EQU WRTR_$WS_STORAGE = 49;         /*                              */
      3036  %EQU WRTR_$REKEY = 50;              /*  Add at end so dont screw up A01 */
      3037  %EQU WRTR_$HSALL = 51;              /*  Tell FEP                    */
      3038  %EQU WRTR_$TEXTEDIT = 52;           /*  Tell FEP                    */
      3039  %EQU WRTR_$EZ_APPEND = 53;          /*  Tell FEP                    */
      3040  %EQU WRTR_$SCROLL = 54;            /* Tell FEP                      */
      3041  %EQU WRTR_$EOF_MARK = 55;           /* Tell Fep                     */
      3042  %EQU WRTR_$FILETYPE = 56;           /*                              */
      3043  %EQU WRTR_$INITIALIZE = 57;         /*                              */
      3044  %EQU WRTR_$ONESPACEEDIT = 58;       /*                            */
      3045  %EQU WRTR_MXP1 = 59;                /* Max WRTR_ value, plus 1    */
      3046
      3047
      3048  /*
      3049  *   VD$NODE_DESC
      3050  *   Info about a node in either an internal or an external file.
      3051  *   Data component at non-record levels is optional; if present,
      3052  *       it contains a free-form description of this node in the file
      3053  *       (eg, "Chapter 7: Origin of the Ape" or "Window 1: Names file").
      3054  *   .EOR is here only temporarily; in a future release it should be
      3055  *       managed separately (in AUTO) by VDI$BINSERT and VDI$BDELETE.
      3056  *       For now, VDE$RGET will set the bit on initially for the
      3057  *       VDI$Bxxx routines.
      3058  *   Note that a node with a 0-length Data component is represented
      3059  *       as .DATA$ pointing to a VD$BUFFER with .LENGTH# = 0.
      3060  */
      3061  %MACRO VD$NODE_DESC (NAME=VD$NODE_DESC,
      3062   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3063   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3064
      3065  %IF TEXTCHAR(LEV) = 'AUTO';
      3066     %LSET LEVEL = LEVEL + 1;
      3067  %ELSE;
      3068     %LSET LEVEL = LEV;
      3069  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 108
      3070
      3071  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3072  %IF LEVEL = 1;
      3073  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3074  %ELSE;
      3075   %(LEVEL) NAME DIM ALIGNMENT,
      3076  %ENDIF;
      3077
      3078        %VD$KEY (NAME=KEY);
      3079        %VD$SPEC (NAME=SPEC);
      3080        %(LEVEL+1) DATA$ PTR,
      3081        %(LEVEL+1) EOR BIT (1),
      3082        %(LEVEL+1) * BIT(35) %ENDCHAR /* RFU */
      3083
      3084  %MEND;
      3085
      3086
      3087  /*
      3088  *   VD$NUMBER
      3089  *   Sub-class of "buffer_objects" for holding specific types of information.
      3090  *   These are used as the Data component in some predefined files;
      3091  *       giving them their own object-class codes allows the Pres`r to
      3092  *       display them intelligently in some way readable by the
      3093  *       user.  Numbers are BINCHAR`d and enumerated values are converted
      3094  *       into keywords.
      3095  *   Note:  CLS_BLOCK_BUFFER is used in VD$BUFFERs which contain a
      3096  *       VD$BLOCK_DESC.  This is not a sub-class of VD$NUMBER
      3097  *  *N**N*   Someday, need to support entry of data into these types of
      3098  *  *N**N*   Data components, too, where the Pres`r performs the
      3099  *  *N**N*   reverse of the translations described above for display.
      3100  *   VD$NUMBER are also used to hold or point-to data for
      3101  *       error-message substitution fields (U1, U2, U3).  Here again, the
      3102  *       object-class code allows us to convert binary data to human-readable
      3103  *       form for the error message.
      3104  *
      3105  *  Used for CLS_NUMBER, CLS_BOOLEAN, CLS_FILE_STCLASS, CLS_ORG,
      3106  *           CLS_KEY_TYPE, CLS_EXIST, CLS_NAME_DATA_TYPE, CLS_COMPONENT,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 109
      3107  *           CLS_DIRECTION, CLS_POINT
      3108  */
      3109  %MACRO VD$NUMBER (NAME=VD$NUMBER,
      3110   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3111   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      3112   ICLASS=%CLS_NUMBER, IV=0);
      3113
      3114  %IF TEXTCHAR(LEV) = 'AUTO';
      3115     %LSET LEVEL = LEVEL + 1;
      3116  %ELSE;
      3117     %LSET LEVEL = LEV;
      3118  %ENDIF;
      3119
      3120  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3121  %IF LEVEL = 1;
      3122  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3123  %ELSE;
      3124   %(LEVEL) NAME DIM ALIGNMENT,
      3125  %ENDIF;
      3126
      3127  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      3128  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      3129  %LSET INIT=CHARTEXT('INIT');
      3130  %LSET EIN=CHARTEXT(' ');
      3131  %ELSE;
      3132  %LSET INIT=CHARTEXT('/*');
      3133  %LSET EIN=CHARTEXT('*/');
      3134  %ENDIF;
      3135
      3136        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=ICLASS);
      3137        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      3138        %(LEVEL+1) LENGTH# SBIN HALF HALIGNED %INIT (6) %EIN,
      3139        %(LEVEL+1) *   BIT(18), /* RFU */
      3140        %(LEVEL+1) V# SBIN WORD %INIT (IV) %EIN %ENDCHAR
      3141
      3142  %MEND;
      3143

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 110
      3144  /*
      3145  *   VD_NUMBER
      3146  *   Version of VD$NUMBER.
      3147  */
      3148  %MACRO VD_NUMBER (NAME=VD_NUMBER, STCLASS=STATIC, DIM=" ", ALIGNMENT=ALIGNED,
      3149      LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      3150      ICLASS=%CLS_NUMBER, IV=0);
      3151
      3152  %VD$NUMBER (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      3153      LEV=LEVEL, LAST=LAST, ICLASS=ICLASS, IV=IV);
      3154
      3155  %MEND;
      3156
      3157
      3158  /*
      3159  *   VD$OBJECT_HEADER
      3160  *   Objects are those PL6 structures which are always dynamically allocated.
      3161  *   All objects have a common header as the first element of their
      3162  *       PL6 structure.
      3163  *   Note that constant/static/auto/param (that is, any non-dynamically-
      3164  *       allocated) instances of "objects" must not have .OBJECT.SIZE#
      3165  *       filled in -- they must leave it 0.  (That way, if we do pass an
      3166  *       "object" residing in static/constant/auto/param to VDG$OFREE, OFREE
      3167  *       will know not to actually free it by looking at it's .SIZE#.)
      3168  *       Therefore, the only parameter for VD$OBJECT_HEADER is ICLASS:  a
      3169  *       %CLS_ value.
      3170  */
      3171  %MACRO VD$OBJECT_HEADER (NAME=VD$OBJECT_HEADER,
      3172   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3173   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2, ICLASS=0);
      3174
      3175  %IF TEXTCHAR(LEV) = 'AUTO';
      3176     %LSET LEVEL = LEVEL + 1;
      3177  %ELSE;
      3178     %LSET LEVEL = LEV;
      3179  %ENDIF;
      3180

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 111
      3181  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      3182  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      3183  %LSET INIT=CHARTEXT('INIT');
      3184  %LSET EIN=CHARTEXT(' ');
      3185  %ELSE;
      3186  %LSET INIT=CHARTEXT('/*');
      3187  %LSET EIN=CHARTEXT('*/');
      3188  %ENDIF;
      3189
      3190  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3191  %IF LEVEL = 1;
      3192  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3193  %ELSE;
      3194   %(LEVEL) NAME DIM ALIGNMENT,
      3195  %ENDIF;
      3196
      3197           %(LEVEL+1) CLASS# UBIN HALF HALIGNED %INIT (ICLASS) %EIN,
      3198           %(LEVEL+1) SIZE# SBIN HALF HALIGNED %INIT (0) %EIN  %ENDCHAR
      3199
      3200  %MEND;
      3201
      3202  /*
      3203  *   CLS_? - EQUs for object class
      3204  */
      3205  %EQU CLS_BLOCK_BUFFER = 1;
      3206  %EQU CLS_BLOCK_DESC = 2;
      3207  %EQU CLS_BOOLEAN = 3;
      3208  %EQU CLS_BUFFER = 4;
      3209  %EQU CLS_CMD_STREAM = 5;
      3210  %EQU CLS_COMPONENT = 6;
      3211  %EQU CLS_DIRECTION = 7;
      3212  %EQU CLS_DIR_NODE = 8;
      3213  %EQU CLS_ENCODED_NODE = 9;
      3214  %EQU CLS_ERR = 10;
      3215  %EQU CLS_EVAL = 11;
      3216  %EQU CLS_EVAL_PATTERN = 12;
      3217  %EQU CLS_EXIST = 13;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 112
      3218  %EQU CLS_FILE_KEY = 14;
      3219  %EQU CLS_FILE_NODE = 15;
      3220  %EQU CLS_FILE_STCLASS = 16;
      3221  %EQU CLS_FIT = 17;
      3222  %EQU CLS_IT_ADJUST = 18;
      3223  %EQU CLS_IT_BLOCK_EXPR = 19;
      3224  %EQU CLS_IT_COMMAND = 20;
      3225  %EQU CLS_IT_OPERAND = 21;
      3226  %EQU CLS_IT_OPERATOR = 22;
      3227  %EQU CLS_IT_SELECT = 23;
      3228  %EQU CLS_KEY_TYPE = 24;
      3229  %EQU CLS_NAME_DATA_TYPE = 25;
      3230  %EQU CLS_NAME_SPEC = 26;
      3231  %EQU CLS_NUMBER = 27;
      3232  %EQU CLS_ORG = 28;
      3233  %EQU CLS_PATTERN = 29;
      3234  %EQU CLS_POINT = 30;
      3235  %EQU CLS_PORT = 31;
      3236  %EQU CLS_PTR_BLOCK_DESC = 32;
      3237  %EQU CLS_PTR_FILE_NODE = 33;
      3238  %EQU CLS_PTR_INTREE = 34;
      3239  %EQU CLS_PTR_KEY = 35;
      3240  %EQU CLS_PTR_LOCATION = 36;
      3241  %EQU CLS_PTR_TEXTC = 37;
      3242  %EQU CLS_RECORD_SET = 38;
      3243  %EQU CLS_STREAM = 39;
      3244  %EQU CLS_STRUCTURE_LEVEL = 40;
      3245  %EQU CLS_STRUCTURE_SPEC = 41;
      3246  %EQU CLS_TABS = 42;
      3247  %EQU CLS_TEXTC_REMOTE = 43;
      3248  %EQU CLS_WINDOW_BLOCK = 44;
      3249  %EQU CLS_WINDOW_SPEC = 45;
      3250  %EQU CLS_XLATE_LOCATIONS = 46;
      3251  %EQU CLS_PROTECT = 47;
      3252  %EQU CLS_MX = 99;
      3253
      3254

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 113
      3255  /*
      3256  *  VD_OBJECTS
      3257  *  Table of info about objects.  Entries in array are found using
      3258  *      object's %CLS_ code as an index.
      3259  *   ISIZEn - Size in words of object whose %CLS_ code is "n".
      3260  *       If object is variable-length, don't specify ISIZEn (defaults
      3261  *       to 0).
      3262  *       Unoccupied entries have a negative .SIZE.
      3263  *   The following parameters are bit-flags indicating a class' super-class(es):
      3264  *   IBUFn - Bit flag; class "n" is a sub-class of class "buffer_objects";
      3265  *       ie, it has a halfword .LENGTH# field.
      3266  *   IBUFNn - Bit flag; class "n" is a sub-class of class %CLS_NUMBER;
      3267  *       ie, its data structure is VD$NUMBER.
      3268  *   IBUFPn - Bit flag; class "n" is a sub-class of class %CLS_POINTER;
      3269  *       ie, its data structure is VD$POINTER.
      3270  *   ISTRn - Bit flag; class "n" is a sub-class of class "string_objects";
      3271  *       ie, it has a one-byte .LENGTH# field.
      3272  *   IARRn - Bit flag; class "n" is a sub-class of class "array_objects".
      3273  *   IINTn - Bit flag: class "n" is a sub-class of class "intree_node".
      3274  *
      3275  *   IFMTn - Table of "displayed words" (%DW_ values).  This is used only if
      3276  *       class "n" is a sub-class of %CLS_NUMBER which represents an enumerated
      3277  *       data type.  Usually this is a VD_DW_<class_name> table.
      3278  */
      3279
      3280  %MACRO VD_OBJECTS (NAME=VD_OBJECTS, DIM="(0:%(CLS_MX-1))", STCLASS=SYMREF,
      3281      ISIZE0=-1, ISIZE1=-1, ISIZE2=-1, ISIZE3=-1, ISIZE4=-1,
      3282      ISIZE5=-1, ISIZE6=-1, ISIZE7=-1, ISIZE8=-1, ISIZE9=-1,
      3283      ISIZE10=-1, ISIZE11=-1, ISIZE12=-1, ISIZE13=-1, ISIZE14=-1,
      3284      ISIZE15=-1, ISIZE16=-1, ISIZE17=-1, ISIZE18=-1, ISIZE19=-1,
      3285      ISIZE20=-1, ISIZE21=-1, ISIZE22=-1, ISIZE23=-1, ISIZE24=-1,
      3286      ISIZE25=-1, ISIZE26=-1, ISIZE27=-1, ISIZE28=-1, ISIZE29=-1,
      3287      ISIZE30=-1, ISIZE31=-1, ISIZE32=-1, ISIZE33=-1, ISIZE34=-1,
      3288      ISIZE35=-1, ISIZE36=-1, ISIZE37=-1, ISIZE38=-1, ISIZE39=-1,
      3289      ISIZE40=-1, ISIZE41=-1, ISIZE42=-1, ISIZE43=-1, ISIZE44=-1,
      3290      ISIZE45=-1, ISIZE46=-1, ISIZE47=-1, ISIZE48=-1, ISIZE49=-1,
      3291      ISIZE50=-1, ISIZE51=-1, ISIZE52=-1, ISIZE53=-1, ISIZE54=-1,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 114
      3292      ISIZE55=-1,
      3293      IBUF0='0'B, IBUF1='0'B, IBUF2='0'B, IBUF3='0'B, IBUF4='0'B,
      3294      IBUF5='0'B, IBUF6='0'B, IBUF7='0'B, IBUF8='0'B, IBUF9='0'B,
      3295      IBUF10='0'B, IBUF11='0'B, IBUF12='0'B, IBUF13='0'B, IBUF14='0'B,
      3296      IBUF15='0'B, IBUF16='0'B, IBUF17='0'B, IBUF18='0'B, IBUF19='0'B,
      3297      IBUF20='0'B, IBUF21='0'B, IBUF22='0'B, IBUF23='0'B, IBUF24='0'B,
      3298      IBUF25='0'B, IBUF26='0'B, IBUF27='0'B, IBUF28='0'B, IBUF29='0'B,
      3299      IBUF30='0'B, IBUF31='0'B, IBUF32='0'B, IBUF33='0'B, IBUF34='0'B,
      3300      IBUF35='0'B, IBUF36='0'B, IBUF37='0'B, IBUF38='0'B, IBUF39='0'B,
      3301      IBUF40='0'B, IBUF41='0'B, IBUF42='0'B, IBUF43='0'B, IBUF44='0'B,
      3302      IBUF45='0'B, IBUF46='0'B, IBUF47='0'B, IBUF48='0'B, IBUF49='0'B,
      3303      IBUF50='0'B, IBUF51='0'B, IBUF52='0'B, IBUF53='0'B, IBUF54='0'B,
      3304      IBUF55='0'B,
      3305      IBUFN0='0'B, IBUFN1='0'B, IBUFN2='0'B, IBUFN3='0'B, IBUFN4='0'B,
      3306      IBUFN5='0'B, IBUFN6='0'B, IBUFN7='0'B, IBUFN8='0'B, IBUFN9='0'B,
      3307      IBUFN10='0'B, IBUFN11='0'B, IBUFN12='0'B, IBUFN13='0'B, IBUFN14='0'B,
      3308      IBUFN15='0'B, IBUFN16='0'B, IBUFN17='0'B, IBUFN18='0'B, IBUFN19='0'B,
      3309      IBUFN20='0'B, IBUFN21='0'B, IBUFN22='0'B, IBUFN23='0'B, IBUFN24='0'B,
      3310      IBUFN25='0'B, IBUFN26='0'B, IBUFN27='0'B, IBUFN28='0'B, IBUFN29='0'B,
      3311      IBUFN30='0'B, IBUFN31='0'B, IBUFN32='0'B, IBUFN33='0'B, IBUFN34='0'B,
      3312      IBUFN35='0'B, IBUFN36='0'B, IBUFN37='0'B, IBUFN38='0'B, IBUFN39='0'B,
      3313      IBUFN40='0'B, IBUFN41='0'B, IBUFN42='0'B, IBUFN43='0'B, IBUFN44='0'B,
      3314      IBUFN45='0'B, IBUFN46='0'B, IBUFN47='0'B, IBUFN48='0'B, IBUFN49='0'B,
      3315      IBUFN50='0'B, IBUFN51='0'B, IBUFN52='0'B, IBUFN53='0'B, IBUFN54='0'B,
      3316      IBUFN55='0'B,
      3317      IBUFP0='0'B, IBUFP1='0'B, IBUFP2='0'B, IBUFP3='0'B, IBUFP4='0'B,
      3318      IBUFP5='0'B, IBUFP6='0'B, IBUFP7='0'B, IBUFP8='0'B, IBUFP9='0'B,
      3319      IBUFP10='0'B, IBUFP11='0'B, IBUFP12='0'B, IBUFP13='0'B, IBUFP14='0'B,
      3320      IBUFP15='0'B, IBUFP16='0'B, IBUFP17='0'B, IBUFP18='0'B, IBUFP19='0'B,
      3321      IBUFP20='0'B, IBUFP21='0'B, IBUFP22='0'B, IBUFP23='0'B, IBUFP24='0'B,
      3322      IBUFP25='0'B, IBUFP26='0'B, IBUFP27='0'B, IBUFP28='0'B, IBUFP29='0'B,
      3323      IBUFP30='0'B, IBUFP31='0'B, IBUFP32='0'B, IBUFP33='0'B, IBUFP34='0'B,
      3324      IBUFP35='0'B, IBUFP36='0'B, IBUFP37='0'B, IBUFP38='0'B, IBUFP39='0'B,
      3325      IBUFP40='0'B, IBUFP41='0'B, IBUFP42='0'B, IBUFP43='0'B, IBUFP44='0'B,
      3326      IBUFP45='0'B, IBUFP46='0'B, IBUFP47='0'B, IBUFP48='0'B, IBUFP49='0'B,
      3327      IBUFP50='0'B, IBUFP51='0'B, IBUFP52='0'B, IBUFP53='0'B, IBUFP54='0'B,
      3328      IBUFP55='0'B,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 115
      3329      ISTR0='0'B, ISTR1='0'B, ISTR2='0'B, ISTR3='0'B, ISTR4='0'B,
      3330      ISTR5='0'B, ISTR6='0'B, ISTR7='0'B, ISTR8='0'B, ISTR9='0'B,
      3331      ISTR10='0'B, ISTR11='0'B, ISTR12='0'B, ISTR13='0'B, ISTR14='0'B,
      3332      ISTR15='0'B, ISTR16='0'B, ISTR17='0'B, ISTR18='0'B, ISTR19='0'B,
      3333      ISTR20='0'B, ISTR21='0'B, ISTR22='0'B, ISTR23='0'B, ISTR24='0'B,
      3334      ISTR25='0'B, ISTR26='0'B, ISTR27='0'B, ISTR28='0'B, ISTR29='0'B,
      3335      ISTR30='0'B, ISTR31='0'B, ISTR32='0'B, ISTR33='0'B, ISTR34='0'B,
      3336      ISTR35='0'B, ISTR36='0'B, ISTR37='0'B, ISTR38='0'B, ISTR39='0'B,
      3337      ISTR40='0'B, ISTR41='0'B, ISTR42='0'B, ISTR43='0'B, ISTR44='0'B,
      3338      ISTR45='0'B, ISTR46='0'B, ISTR47='0'B, ISTR48='0'B, ISTR49='0'B,
      3339      ISTR50='0'B, ISTR51='0'B, ISTR52='0'B, ISTR53='0'B, ISTR54='0'B,
      3340      ISTR55='0'B,
      3341      IARR0='0'B, IARR1='0'B, IARR2='0'B, IARR3='0'B, IARR4='0'B,
      3342      IARR5='0'B, IARR6='0'B, IARR7='0'B, IARR8='0'B, IARR9='0'B,
      3343      IARR10='0'B, IARR11='0'B, IARR12='0'B, IARR13='0'B, IARR14='0'B,
      3344      IARR15='0'B, IARR16='0'B, IARR17='0'B, IARR18='0'B, IARR19='0'B,
      3345      IARR20='0'B, IARR21='0'B, IARR22='0'B, IARR23='0'B, IARR24='0'B,
      3346      IARR25='0'B, IARR26='0'B, IARR27='0'B, IARR28='0'B, IARR29='0'B,
      3347      IARR30='0'B, IARR31='0'B, IARR32='0'B, IARR33='0'B, IARR34='0'B,
      3348      IARR35='0'B, IARR36='0'B, IARR37='0'B, IARR38='0'B, IARR39='0'B,
      3349      IARR40='0'B, IARR41='0'B, IARR42='0'B, IARR43='0'B, IARR44='0'B,
      3350      IARR45='0'B, IARR46='0'B, IARR47='0'B, IARR48='0'B, IARR49='0'B,
      3351      IARR50='0'B, IARR51='0'B, IARR52='0'B, IARR53='0'B, IARR54='0'B,
      3352      IARR55='0'B,
      3353      IINT0='0'B, IINT1='0'B, IINT2='0'B, IINT3='0'B, IINT4='0'B,
      3354      IINT5='0'B, IINT6='0'B, IINT7='0'B, IINT8='0'B, IINT9='0'B,
      3355      IINT10='0'B, IINT11='0'B, IINT12='0'B, IINT13='0'B, IINT14='0'B,
      3356      IINT15='0'B, IINT16='0'B, IINT17='0'B, IINT18='0'B, IINT19='0'B,
      3357      IINT20='0'B, IINT21='0'B, IINT22='0'B, IINT23='0'B, IINT24='0'B,
      3358      IINT25='0'B, IINT26='0'B, IINT27='0'B, IINT28='0'B, IINT29='0'B,
      3359      IINT30='0'B, IINT31='0'B, IINT32='0'B, IINT33='0'B, IINT34='0'B,
      3360      IINT35='0'B, IINT36='0'B, IINT37='0'B, IINT38='0'B, IINT39='0'B,
      3361      IINT40='0'B, IINT41='0'B, IINT42='0'B, IINT43='0'B, IINT44='0'B,
      3362      IINT45='0'B, IINT46='0'B, IINT47='0'B, IINT48='0'B, IINT49='0'B,
      3363      IINT50='0'B, IINT51='0'B, IINT52='0'B, IINT53='0'B, IINT54='0'B,
      3364      IINT55='0'B,
      3365      IFMT0=NIL, IFMT1=NIL, IFMT2=NIL, IFMT3=NIL, IFMT4=NIL,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 116
      3366      IFMT5=NIL, IFMT6=NIL, IFMT7=NIL, IFMT8=NIL, IFMT9=NIL,
      3367      IFMT10=NIL, IFMT11=NIL, IFMT12=NIL, IFMT13=NIL, IFMT14=NIL,
      3368      IFMT15=NIL, IFMT16=NIL, IFMT17=NIL, IFMT18=NIL, IFMT19=NIL,
      3369      IFMT20=NIL, IFMT21=NIL, IFMT22=NIL, IFMT23=NIL, IFMT24=NIL,
      3370      IFMT25=NIL, IFMT26=NIL, IFMT27=NIL, IFMT28=NIL, IFMT29=NIL,
      3371      IFMT30=NIL, IFMT31=NIL, IFMT32=NIL, IFMT33=NIL, IFMT34=NIL,
      3372      IFMT35=NIL, IFMT36=NIL, IFMT37=NIL, IFMT38=NIL, IFMT39=NIL,
      3373      IFMT40=NIL, IFMT41=NIL, IFMT42=NIL, IFMT43=NIL, IFMT44=NIL,
      3374      IFMT45=NIL, IFMT46=NIL, IFMT47=NIL, IFMT48=NIL, IFMT49=NIL,
      3375      IFMT50=NIL, IFMT51=NIL, IFMT52=NIL, IFMT53=NIL, IFMT54=NIL,
      3376      IFMT55=NIL);
      3377
      3378  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      3379  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      3380  %LSET INIT=CHARTEXT('INIT');
      3381  %ELSE;
      3382  %LSET INIT=CHARTEXT('/*');
      3383  %ENDIF;
      3384
      3385  DCL 1 NAME DIM STCLASS,
      3386        2 SIZE SBIN HALF HALIGNED /* If fixed-length, size in words of object */
      3387          %INIT (ISIZE0, ISIZE1, ISIZE2, ISIZE3, ISIZE4,
      3388              ISIZE5, ISIZE6, ISIZE7, ISIZE8, ISIZE9,
      3389              ISIZE10, ISIZE11, ISIZE12, ISIZE13, ISIZE14,
      3390              ISIZE15, ISIZE16, ISIZE17, ISIZE18, ISIZE19,
      3391              ISIZE20, ISIZE21, ISIZE22, ISIZE23, ISIZE24,
      3392              ISIZE25, ISIZE26, ISIZE27, ISIZE28, ISIZE29,
      3393              ISIZE30, ISIZE31, ISIZE32, ISIZE33, ISIZE34,
      3394              ISIZE35, ISIZE36, ISIZE37, ISIZE38, ISIZE39,
      3395              ISIZE40, ISIZE41, ISIZE42, ISIZE43, ISIZE44,
      3396              ISIZE45, ISIZE46, ISIZE47, ISIZE48, ISIZE49,
      3397              ISIZE50, ISIZE51, ISIZE52, ISIZE53, ISIZE54,
      3398              ISIZE55, -1*0)    %CHARTEXT('/**/') ,
      3399        2 BUF BIT(1)              /* Sub-class of "buffer_objects" */
      3400          %INIT (IBUF0, IBUF1, IBUF2, IBUF3, IBUF4,
      3401              IBUF5, IBUF6, IBUF7, IBUF8, IBUF9,
      3402              IBUF10, IBUF11, IBUF12, IBUF13, IBUF14,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 117
      3403              IBUF15, IBUF16, IBUF17, IBUF18, IBUF19,
      3404              IBUF20, IBUF21, IBUF22, IBUF23, IBUF24,
      3405              IBUF25, IBUF26, IBUF27, IBUF28, IBUF29,
      3406              IBUF30, IBUF31, IBUF32, IBUF33, IBUF34,
      3407              IBUF35, IBUF36, IBUF37, IBUF38, IBUF39,
      3408              IBUF40, IBUF41, IBUF42, IBUF43, IBUF44,
      3409              IBUF45, IBUF46, IBUF47, IBUF48, IBUF49,
      3410              IBUF50, IBUF51, IBUF52, IBUF53, IBUF54,
      3411              IBUF55, '0'B*0)    %CHARTEXT('/**/') ,
      3412        2 BUFN BIT(1)              /* Sub-class of %CLS_NUMBER */
      3413          %INIT (IBUFN0, IBUFN1, IBUFN2, IBUFN3, IBUFN4,
      3414              IBUFN5, IBUFN6, IBUFN7, IBUFN8, IBUFN9,
      3415              IBUFN10, IBUFN11, IBUFN12, IBUFN13, IBUFN14,
      3416              IBUFN15, IBUFN16, IBUFN17, IBUFN18, IBUFN19,
      3417              IBUFN20, IBUFN21, IBUFN22, IBUFN23, IBUFN24,
      3418              IBUFN25, IBUFN26, IBUFN27, IBUFN28, IBUFN29,
      3419              IBUFN30, IBUFN31, IBUFN32, IBUFN33, IBUFN34,
      3420              IBUFN35, IBUFN36, IBUFN37, IBUFN38, IBUFN39,
      3421              IBUFN40, IBUFN41, IBUFN42, IBUFN43, IBUFN44,
      3422              IBUFN45, IBUFN46, IBUFN47, IBUFN48, IBUFN49,
      3423              IBUFN50, IBUFN51, IBUFN52, IBUFN53, IBUFN54,
      3424              IBUFN55, '0'B*0)    %CHARTEXT('/**/') ,
      3425        2 BUFP BIT(1)              /* Sub-class of "pointers" */
      3426          %INIT (IBUFP0, IBUFP1, IBUFP2, IBUFP3, IBUFP4,
      3427              IBUFP5, IBUFP6, IBUFP7, IBUFP8, IBUFP9,
      3428              IBUFP10, IBUFP11, IBUFP12, IBUFP13, IBUFP14,
      3429              IBUFP15, IBUFP16, IBUFP17, IBUFP18, IBUFP19,
      3430              IBUFP20, IBUFP21, IBUFP22, IBUFP23, IBUFP24,
      3431              IBUFP25, IBUFP26, IBUFP27, IBUFP28, IBUFP29,
      3432              IBUFP30, IBUFP31, IBUFP32, IBUFP33, IBUFP34,
      3433              IBUFP35, IBUFP36, IBUFP37, IBUFP38, IBUFP39,
      3434              IBUFP40, IBUFP41, IBUFP42, IBUFP43, IBUFP44,
      3435              IBUFP45, IBUFP46, IBUFP47, IBUFP48, IBUFP49,
      3436              IBUFP50, IBUFP51, IBUFP52, IBUFP53, IBUFP54,
      3437              IBUFP55, '0'B*0)    %CHARTEXT('/**/') ,
      3438        2 STR BIT(1)              /* Sub-class of "string_objects" */
      3439          %INIT (ISTR0, ISTR1, ISTR2, ISTR3, ISTR4,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 118
      3440              ISTR5, ISTR6, ISTR7, ISTR8, ISTR9,
      3441              ISTR10, ISTR11, ISTR12, ISTR13, ISTR14,
      3442              ISTR15, ISTR16, ISTR17, ISTR18, ISTR19,
      3443              ISTR20, ISTR21, ISTR22, ISTR23, ISTR24,
      3444              ISTR25, ISTR26, ISTR27, ISTR28, ISTR29,
      3445              ISTR30, ISTR31, ISTR32, ISTR33, ISTR34,
      3446              ISTR35, ISTR36, ISTR37, ISTR38, ISTR39,
      3447              ISTR40, ISTR41, ISTR42, ISTR43, ISTR44,
      3448              ISTR45, ISTR46, ISTR47, ISTR48, ISTR49,
      3449              ISTR50, ISTR51, ISTR52, ISTR53, ISTR54,
      3450              ISTR55, '0'B*0)    %CHARTEXT('/**/') ,
      3451        2 ARR BIT(1)              /* Sub-class of "array_objects" */
      3452          %INIT (IARR0, IARR1, IARR2, IARR3, IARR4,
      3453              IARR5, IARR6, IARR7, IARR8, IARR9,
      3454              IARR10, IARR11, IARR12, IARR13, IARR14,
      3455              IARR15, IARR16, IARR17, IARR18, IARR19,
      3456              IARR20, IARR21, IARR22, IARR23, IARR24,
      3457              IARR25, IARR26, IARR27, IARR28, IARR29,
      3458              IARR30, IARR31, IARR32, IARR33, IARR34,
      3459              IARR35, IARR36, IARR37, IARR38, IARR39,
      3460              IARR40, IARR41, IARR42, IARR43, IARR44,
      3461              IARR45, IARR46, IARR47, IARR48, IARR49,
      3462              IARR50, IARR51, IARR52, IARR53, IARR54,
      3463              IARR55, '0'B*0)    %CHARTEXT('/**/') ,
      3464        2 INT BIT(1)              /* Sub-class of "intree_node" */
      3465          %INIT (IINT0, IINT1, IINT2, IINT3, IINT4,
      3466              IINT5, IINT6, IINT7, IINT8, IINT9,
      3467              IINT10, IINT11, IINT12, IINT13, IINT14,
      3468              IINT15, IINT16, IINT17, IINT18, IINT19,
      3469              IINT20, IINT21, IINT22, IINT23, IINT24,
      3470              IINT25, IINT26, IINT27, IINT28, IINT29,
      3471              IINT30, IINT31, IINT32, IINT33, IINT34,
      3472              IINT35, IINT36, IINT37, IINT38, IINT39,
      3473              IINT40, IINT41, IINT42, IINT43, IINT44,
      3474              IINT45, IINT46, IINT47, IINT48, IINT49,
      3475              IINT50, IINT51, IINT52, IINT53, IINT54,
      3476              IINT55, '0'B*0)    %CHARTEXT('/**/') ,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 119
      3477        2 * BIT(12) %INIT (%CLEAR*0) %CHARTEXT('/**/'),  /* Resrvd for future use */
      3478        2 FMT$ PTR                /* Displayed-word table for formatting */
      3479          %INIT (ADDR(IFMT0), ADDR(IFMT1), ADDR(IFMT2), ADDR(IFMT3), ADDR(IFMT4),
      3480            ADDR(IFMT5), ADDR(IFMT6), ADDR(IFMT7), ADDR(IFMT8), ADDR(IFMT9),
      3481            ADDR(IFMT10), ADDR(IFMT11), ADDR(IFMT12), ADDR(IFMT13), ADDR(IFMT14),
      3482            ADDR(IFMT15), ADDR(IFMT16), ADDR(IFMT17), ADDR(IFMT18), ADDR(IFMT19),
      3483            ADDR(IFMT20), ADDR(IFMT21), ADDR(IFMT22), ADDR(IFMT23), ADDR(IFMT24),
      3484            ADDR(IFMT25), ADDR(IFMT26), ADDR(IFMT27), ADDR(IFMT28), ADDR(IFMT29),
      3485            ADDR(IFMT30), ADDR(IFMT31), ADDR(IFMT32), ADDR(IFMT33), ADDR(IFMT34),
      3486            ADDR(IFMT35), ADDR(IFMT36), ADDR(IFMT37), ADDR(IFMT38), ADDR(IFMT39),
      3487            ADDR(IFMT40), ADDR(IFMT41), ADDR(IFMT42), ADDR(IFMT43), ADDR(IFMT44),
      3488            ADDR(IFMT45), ADDR(IFMT46), ADDR(IFMT47), ADDR(IFMT48), ADDR(IFMT49),
      3489            ADDR(IFMT50), ADDR(IFMT51), ADDR(IFMT52), ADDR(IFMT53), ADDR(IFMT54),
      3490            ADDR(IFMT55), ADDR(NIL)*0)    %CHARTEXT('/**/') ;
      3491
      3492  %MEND;
      3493
      3494
      3495  /*
      3496  *   VD$OPERAND
      3497  *   Info about an operand:  either the Source operand or the
      3498  *       Selected operand.  This is all the info needed by the InTree
      3499  *       evaluation routines (VDE$Ixxx) when evaluating a Source
      3500  *       or Selected InTree.
      3501  */
      3502  %MACRO VD$OPERAND (NAME=VD$OPERAND,
      3503   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3504   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3505
      3506  %IF TEXTCHAR(LEV) = 'AUTO';
      3507     %LSET LEVEL = LEVEL + 1;
      3508  %ELSE;
      3509     %LSET LEVEL = LEV;
      3510  %ENDIF;
      3511
      3512  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3513  %IF LEVEL = 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 120
      3514  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3515  %ELSE;
      3516   %(LEVEL) NAME DIM ALIGNMENT,
      3517  %ENDIF;
      3518
      3519        %(LEVEL+1) STREAM$ PTR,
      3520        %(LEVEL+1) INTREE$ PTR,
      3521        %(LEVEL+1) EDIT_BLOCK$ PTR,
      3522        %(LEVEL+1) EVAL$ PTR %ENDCHAR
      3523
      3524  %MEND;
      3525
      3526
      3527  /*
      3528  *   VD$PATTERN
      3529  *   Specifies a pattern.
      3530  *   A VD$PATTERN represents one level of alternative sequences of
      3531  *       VD$PATT_ENTRYs.  Contiguous VD$PATT_ENTRYs form a sequence;
      3532  *       alternative sequences are demarkated with VD$PATT_ENTRY`s
      3533  *       .ALTERNATIVE flag.
      3534  *
      3535  *   N_ENTRIES: Number of .ENTRIES occupied
      3536  *   MX_ENTRIES: Number of .ENTRIES allocated
      3537  *   ENTRIES: Seq Of VD$PATT_ENTRY;
      3538  */
      3539  %MACRO VD$PATTERN (NAME=VD$PATTERN,
      3540   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3541   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3542
      3543  %IF TEXTCHAR(LEV) = 'AUTO';
      3544     %LSET LEVEL = LEVEL + 1;
      3545  %ELSE;
      3546     %LSET LEVEL = LEV;
      3547  %ENDIF;
      3548
      3549  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      3550  %IF LEVEL = 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 121
      3551  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3552  %ELSE;
      3553   %(LEVEL) NAME DIM ALIGNMENT,
      3554  %ENDIF;
      3555
      3556        %VD$OBJECT_HEADER (NAME=OBJECT);
      3557        %(LEVEL+1) FLINK$ PTR,
      3558        %(LEVEL+1) N_ENTRIES# SBIN HALF HALIGNED,
      3559        %(LEVEL+1) MX_ENTRIES# SBIN HALF HALIGNED,
      3560
      3561        %VD$PATT_ENTRY (NAME=ENTRIES, DIM="(0:0)", LAST=%LAST#);
      3562
      3563  %MEND;
      3564
      3565
      3566  /*
      3567  *   VD$PATT_ENTRY
      3568  *   An entry in a pattern specification.
      3569  *   .M and .N are used differently, based on .CODE:
      3570  *       For PS_VALUE, match a byte whose value lies between .M and .N,
      3571  *           inclusive.
      3572  *       For PS_WILD_STRING, match a number of any byte, where the
      3573  *           number of bytes to match lies between .M and .N, inclusive.
      3574  *   .MATCH is used differently, based on .CODE:
      3575  *       For PS_LITERAL, .MATCH points to a VD$TEXTC_REMOTE containing
      3576  *           the literal string to match.
      3577  *       For PS_PATTERN, .MATCH points to a VD$PATTERN for a subordinate
      3578  *           level of alternative sequences to match.
      3579  */
      3580  %MACRO VD$PATT_ENTRY (NAME=VD$PATT_ENTRY,
      3581   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3582   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3583
      3584  %IF TEXTCHAR(LEV) = 'AUTO';
      3585     %LSET LEVEL = LEVEL + 1;
      3586  %ELSE;
      3587     %LSET LEVEL = LEV;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 122
      3588  %ENDIF;
      3589
      3590  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3591  %IF LEVEL = 1;
      3592  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3593  %ELSE;
      3594   %(LEVEL) NAME DIM ALIGNMENT,
      3595  %ENDIF;
      3596
      3597        %(LEVEL+1) ALTERNATIVE BIT (1),
      3598        %(LEVEL+1)  * BIT(17), /* RFU */
      3599        %(LEVEL+1) CODE# UBIN HALF HALIGNED,
      3600        %(LEVEL+1) M# SBIN WORD,
      3601        %(LEVEL+1) N# SBIN WORD,
      3602        %(LEVEL+1) MATCH$ PTR %ENDCHAR
      3603
      3604  %MEND;
      3605
      3606  /*
      3607  *   PS_? - EQUs for VD$PATT_ENTRY.CODE
      3608  */
      3609  %EQU PS_LITERAL = 1;            /*  Match a literal             */
      3610  %EQU PS_VALUE = 2;              /*  Match one char in range M-N */
      3611  %EQU PS_WILD_STRING = 3;        /*  Match M-N repetitions of any char */
      3612  %EQU PS_PATTERN = 4;            /*  Match subordinate pattern   */
      3613  %EQU PS_RECORD = 5;             /*  Match EOR boundary          */
      3614  %EQU PS_CURRENT = 6;            /*  Match current boundary (BO or EO block) */
      3615  %EQU PS_BO_MATCH = 7;           /*  Match location is BO match  */
      3616  %EQU PS_EO_MATCH = 8;           /*  Match location is EO match  */
      3617
      3618
      3619  %MACRO VD$PDFF (NAME=VD$PDFF,
      3620   STCLASS=BASED, DIM=" ", ALIGNMENT=UNAL,
      3621   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3622
      3623  %ERROR (TEXTCHAR(DIM)~=' ','"DIM" may not be specified when invoking PDFF',2);
      3624

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 123
      3625  %IF TEXTCHAR(LEV) = 'AUTO';
      3626     %LSET LEVEL = LEVEL + 1;
      3627  %ELSE;
      3628     %LSET LEVEL = LEV;
      3629  %ENDIF;
      3630
      3631  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3632  %IF LEVEL = 1;
      3633  DCL 1 NAME(0:8) BIT (1) ALIGNMENT STCLASS;
      3634  %ELSE;
      3635        %(LEVEL) NAME(0:8) BIT (1) ALIGNMENT %ENDCHAR
      3636  %ENDIF;
      3637
      3638  %MEND;
      3639
      3640  /*
      3641  *   PDFF_? - Predefined file flags (bit-wise)
      3642  *   These values can be used as subscripts into an array of bit-flags
      3643  *       to represent a set of predefined files.
      3644  */
      3645  %EQU PDFF_EQUALS = 1;
      3646  %EQU PDFF_KEYINS = 2;
      3647  %EQU PDFF_LOCATIONS = 3;
      3648  %EQU PDFF_SYNONYMS = 4;
      3649  %EQU PDFF_STRUCTURES = 5;
      3650  %EQU PDFF_WINDOWS = 6;
      3651
      3652
      3653  /*
      3654  *   VD$POINTER
      3655  *   Sub-class of "buffer_objects" for holding specific types of information.
      3656  *   These are used as the Data component in some predefined files;
      3657  *       giving them their own object-class codes allows the Pres`r to
      3658  *       display them intelligently    in some way readable by the
      3659  *       user.  Pointed-to PL-6 structures are translated
      3660  *       into text descriptions.
      3661  *   Note:  CLS_BLOCK_BUFFER is used in VD$BUFFERs which contain a

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 124
      3662  *       VD$BLOCK_DESC.  This is not a sub-class of VD$POINTER.
      3663  *  *N**N*   Someday, need to support entry of data into these types of
      3664  *  *N**N*   Data components, too, where the Pres`r performs the
      3665  *  *N**N*   reverse of the translations described above for display.
      3666  *   VD$POINTER is also used to hold or point-to data for
      3667  *       error-message substitution fields (U1, U2, U3).  Here again, the
      3668  *       object-class code allows us to convert binary data to human-readable
      3669  *       form for the error message.  This is also why we use a pointer to
      3670  *       other data, instead of including the data itself in the buffer:
      3671  *       so all objects in these sub-classes are the same size.  The other-data
      3672  *       pointed-to will always be info that already resides somewhere else
      3673  *       in memory anyway, so instead of making a new copy, we just refer to it
      3674  *       from a VD$POINTER.
      3675  *
      3676  *  Used for CLS_PTR_BLOCK_DESC, CLS_PTR_LOCATION, CLS_PTR_KEY,
      3677  *           CLS_PTR_TEXTC, CLS_PTR_FILE_NODE, CLS_PTR_INTREE
      3678  */
      3679  %MACRO VD$POINTER (NAME=VD$POINTER,
      3680   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3681   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      3682   ICLASS=0, IV=NIL);
      3683
      3684  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      3685  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      3686  %LSET INIT=CHARTEXT('INIT');
      3687  %LSET EIN=CHARTEXT(' ');
      3688  %ELSE;
      3689  %LSET INIT=CHARTEXT('/*');
      3690  %LSET EIN=CHARTEXT('*/');
      3691  %ENDIF;
      3692
      3693  %IF TEXTCHAR(LEV) = 'AUTO';
      3694     %LSET LEVEL = LEVEL + 1;
      3695  %ELSE;
      3696     %LSET LEVEL = LEV;
      3697  %ENDIF;
      3698

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 125
      3699  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3700  %IF LEVEL = 1;
      3701  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3702  %ELSE;
      3703   %(LEVEL) NAME DIM ALIGNMENT,
      3704  %ENDIF;
      3705
      3706        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=ICLASS);
      3707        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      3708        %(LEVEL+1) LENGTH# SBIN HALF HALIGNED %INIT (6) %EIN,
      3709        %(LEVEL+1) *   BIT(18), /* RFU */
      3710        %(LEVEL+1) V$ PTR %INIT (ADDR(IV)) %EIN %ENDCHAR
      3711
      3712  %MEND;
      3713
      3714  /*
      3715  *   VD_POINTER
      3716  *   Version of VD$POINTER.
      3717  */
      3718  %MACRO VD_POINTER (NAME=VD_POINTER, STCLASS=STATIC, DIM=" ",
      3719      ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      3720      ICLASS=0, IV=NIL);
      3721
      3722  %VD$POINTER (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      3723      LEV=LEVEL, LAST=LAST, ICLASS=ICLASS, IV=IV);
      3724
      3725  %MEND;
      3726
      3727
      3728  /*
      3729  *   VD$PORT
      3730  *   Port onto an internal or external file structure; basically, each
      3731  *       VD$PORT represents one DCB.
      3732  *   Note that more than one VD$STREAM may be open to the same VD$PORT at
      3733  *       any one time:  all VD$STREAMs open to the same file use the
      3734  *       same VD$PORT.
      3735  *   General Principle:  6Edit will have at most 1 DCB open to any 1

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 126
      3736  *       external file at any one time.
      3737  *   Corrolary:  The first access to a file determines the most liberal
      3738  *       access (in terms of the "protect" option) allowed to that file,
      3739  *       until all access to the file ceases (can then be reinitiated
      3740  *       using any "protect" option).  If the first opener sets unprotected
      3741  *       access and a later opener wants protected access, 6Edit will
      3742  *       itself enforce the protection on the second opener.
      3743  *       Input-only DCBs are opened SHARE=ALL, and create/update DCBs
      3744  *       are opened SHARE=NONE, but this is only effective for
      3745  *       outside users:  this user of 6Edit in this session
      3746  *       can open other streams to the same file all s/he wants, enjoying
      3747  *       effective SHARE=ALL access to any file between the different
      3748  *       streams/windows of this session.
      3749  *
      3750  *   The general form of the name part of the file key for predefined
      3751  *       (and Scratch) files is:
      3752  *           x6Edit_<dir>_<file>
      3753  *   where:
      3754  *       "x" is the file storage class of the file.  This is a single char,
      3755  *           and comes from VD$DIR_NODE.FILE_STCLASS (settable by the user).
      3756  *           It is one of the FSTCL_ values, and specifies where to look
      3757  *           for the file.  If the file storage class for a directory is
      3758  *           FSTCL_MIGRATABLE or FSTCL_EXTERNAL, then the user can`t
      3759  *           access any external file which starts with "x6Edit_<dir>".
      3760  *       <dir> is the directory key:  a DK_ value.  There are
      3761  *           five directories:  History, Names, Scratch, Structures,
      3762  *           and Windows.
      3763  *       _<file> is optional, and makes the entire file name unique
      3764  *           for a specific file within the directory.  The History,
      3765  *           Names, and Scratch directories may contain several files
      3766  *           each; the Structures and Windows directories each contain
      3767  *           only one file, so they don`t use the "_<file>" part in
      3768  *           their file names.
      3769  *
      3770  *   For internal files, the VD$PORT doesn`t have a DCB attached;
      3771  *       it simply points to the internal file (level-0 VD$FILE_NODE).
      3772  *   For external files, there are always just two levels:  the file level

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 127
      3773  *       and the record level.  The VD$PORT holds info about the DCB and
      3774  *       what we`ve done to it, so we can optimize use of the DCB by
      3775  *       minimizing file-management PMMEs.
      3776  *
      3777  *   Most of VD$PORT exclusive of VD$PORT.LEVEL is set on file-level
      3778  *       operations (open, close):
      3779  *   .REFS is used to close and garbage-collect VD$PORTs to which no
      3780  *       stream points any longer:  each attachment of a stream to this port
      3781  *       increments REFS, and each detachment decrements REFS.
      3782  *   .EXIST is 0 when this port is "closed":  the port exists and may have a
      3783  *       DCB attached to it, but the DCB is closed.  For a closed port:
      3784  *           o The only meaningful fields in the VD$PORT are
      3785  *               .BLINK, .FLINK, .REFS, .EXIST, .DCB, and
      3786  *               .FILE_KEY.
      3787  *           o A closed port never has any internal VD$FILE_NODEs
      3788  *               attached to it.  Note, however, it may have a DCB attached
      3789  *               to it (closed, of course).
      3790  *   .INTRINSIC_PROTECT - Set if the port is open for input only.
      3791  *       By "intrinsic" for external files, we mean that the DCB is
      3792  *       open for input only, either by request, because we already
      3793  *       had a DCB open to the requested file and it was open for
      3794  *       input only, or because CP-6 file management will only allow
      3795  *       this user read-access to the file.
      3796  *       For internal files, by "intrinsic" we mean that the
      3797  *       level 0 FileNode for the file is protected.
      3798  *   .POSITION_PROTECT - Set if some previous caller expects the
      3799  *       Port`s position to remain the same.  Used to prevent recursion
      3800  *       errors.  Whenever an Accessor routine has positioned the
      3801  *       Port, but calls some other routine while still expecting the
      3802  *       Port to remain positioned, it should set this bit, make the
      3803  *       call, then clear the bit upon return.  This is required because
      3804  *       many other routines (most commonly VDG$EREPORT_ERROR when it
      3805  *       reports warnings at the time of their detection) call the
      3806  *       Accessor as a side-effect, to adjust window sizes, update the
      3807  *       value of a predefined name, etc.  If the caller had positioned
      3808  *       the Windows or Locations file for some other purpose, then called
      3809  *       a routine which generated a warning, the recursive call to

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 128
      3810  *       the Accessor would reposition the Windows-file Port.
      3811  *       Test case for this:  !6EDIT consec_file.  Opening the
      3812  *       first editing window follows this logic:
      3813  *           VDA$L/PWRITE position the Windows file appropriately,
      3814  *               then call the writer routine VDA$WWINDOWS.
      3815  *           VDA$WWINDOWS calls VDA$FOPEN to open the window`s Edit Block.
      3816  *           VDA$FOPEN reports a warning about limited updating of
      3817  *               consecutive files, by calling VDG$EREPORT_ERROR.
      3818  *           VDG$EREPORT_ERROR wants to expand the command window, so
      3819  *               calls VDG$GUAR_WINDOW_HEIGHT.
      3820  *           VDG$GUAR_WINDOW_HEIGHT calls VDA$LWRITE to write new coords
      3821  *               for the command window.
      3822  *           VDA$LWRITE wants to reposition the Port for the Windows file
      3823  *               to the command window.  However, this would screw up
      3824  *               the instance of VDA$WWINDOWS above when we return.
      3825  *               Instead, the first instance of VDA$LWRITE should have
      3826  *               set .POSITION_PROTECT for the Windows-file`s Port, and
      3827  *               this instance of VDA$LWRITE would have rejected the
      3828  *               write due to E$PORT_BUSY.  VDG$GUAR_WINDOW_HEIGHT can
      3829  *               then update the Windows file some other way (e.g.,
      3830  *               directly instead of using the Accessor), or it could
      3831  *               altreturn to abort the entire operation.
      3832  *   .DCB - If the port is open (.EXIST ~= 0) and .DCB = 0, then we`re
      3833  *       open to an internal file.  If the port is closed, there may or
      3834  *       may not be a DCB attached to this port.
      3835  *   .FIT - Points to a VD$FIT (for both internal and external files.)
      3836  *       NIL when port is closed.
      3837  *   .FILE_KEY is the file we`re open to, if any.  Always points to
      3838  *       a remote VD$FILE_KEY.
      3839  *   .CURRENT is the "current position" of the port below the file
      3840  *       level.  For external files, the port`s "current position" always
      3841  *       exactly matches the DCB`s "current record pointer"    except
      3842  *       just after a VDA$LWRITE call:  if PORT.LAST_OP# = ACCOP_WRITE,
      3843  *       then the DCB may not be at .CURRENT currently,
      3844  *       but it will be when the (mandatory) VDA$PFLUSH call is
      3845  *       later performed (by caller, or forced internally by the
      3846  *       Accessor `cause another call needs to reposition the DCB).

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 129
      3847  *
      3848  *   .LEVEL (0:n) contain info about the levels of the file structure:
      3849  *   .LEVEL.ORG, .KEY_TYPE, and .SPEC_TYPE are set on file-level operations
      3850  *       (open, close).  The remaining elements in VD$PORT.LEVEL may be
      3851  *       set by each lower-level operation (read, write, delete, flush).
      3852  *   .LEVEL.INTERNAL is used for internal files only; it points
      3853  *       to the VD$FILE_NODE for the node corresponding to
      3854  *       PORT.CURRENT.KEY (level).  If .CURRENT.EOF is set, this
      3855  *       pointer is nil at all levels except the file level.
      3856  *       If PORT.FILE_KEY = %CLEAR, this pointer is clear at the file
      3857  *       level as well.
      3858  */
      3859  %MACRO VD$PORT (NAME=VD$PORT,
      3860   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3861   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3862
      3863  %IF TEXTCHAR(LEV) = 'AUTO';
      3864     %LSET LEVEL = LEVEL + 1;
      3865  %ELSE;
      3866     %LSET LEVEL = LEV;
      3867  %ENDIF;
      3868
      3869  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3870  %IF LEVEL = 1;
      3871  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3872  %ELSE;
      3873   %(LEVEL) NAME DIM ALIGNMENT,
      3874  %ENDIF;
      3875
      3876        %VD$OBJECT_HEADER (NAME=OBJECT);
      3877        %(LEVEL+1) BLINK$ PTR,
      3878        %(LEVEL+1) FLINK$ PTR,
      3879        %(LEVEL+1) REFS# SBIN HALF HALIGNED,
      3880        %(LEVEL+1) EXIST# UBIN HALF HALIGNED,
      3881        %(LEVEL+1) INTRINSIC_PROTECT BIT (1),
      3882        %(LEVEL+1) POSITION_PROTECT BIT (1),
      3883        %(LEVEL+1) *   BIT(16), /* RFU */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 130
      3884        %(LEVEL+1) DCB# UBIN HALF HALIGNED,
      3885        %(LEVEL+1) FIT$ PTR,
      3886        %(LEVEL+1) STRUCTURE$ PTR,
      3887        %(LEVEL+1) LAST_OP# UBIN HALF HALIGNED,
      3888        %(LEVEL+1) *   BIT(18), /* RFU */
      3889        %VD$KEY (NAME=FILE_KEY);
      3890        %VD$LOCATION (NAME=CURRENT);
      3891        %(LEVEL+1) LEVEL (0:%(MX_LOCATION_LEVELS)),
      3892          %(LEVEL+2) ORG# UBIN HALF HALIGNED,
      3893          %(LEVEL+2) KEY_TYPE# UBIN HALF HALIGNED,
      3894          %(LEVEL+2) SPEC_TYPE# UBIN HALF HALIGNED,
      3895        %(LEVEL+2)  *  BIT(18), /* RFU */
      3896          %VD$SPEC (NAME=SPEC, LEV="%(LEVEL+2)");
      3897          %(LEVEL+2) DATA$ PTR,
      3898          %(LEVEL+2) SPEC_MODIFIED BIT (1),
      3899          %(LEVEL+2) DATA_MODIFIED BIT (1),
      3900        %(LEVEL+2)  *  BIT(34), /* RFU */
      3901          %(LEVEL+2) INTERNAL$ PTR %ENDCHAR
      3902
      3903  %MEND;
      3904
      3905  /*
      3906  *   ACCOP_? - ACCessor OPeration codes...
      3907  *   used to set last operation (.LAST_OP) codes for VD$PORT and VD$STREAM
      3908  */
      3909  %EQU ACCOP_OPEN = 1;
      3910  %EQU ACCOP_LOCATION = 2;
      3911  %EQU ACCOP_CLOSE = 3;
      3912  %EQU ACCOP_READ = 4;
      3913  %EQU ACCOP_WRITE = 5;
      3914  %EQU ACCOP_DELETE = 6;
      3915
      3916
      3917  /*
      3918  *   VD$RANGE
      3919  *   A range of locations within a file.
      3920  *   Except in some of the block-expression-evaluation modules

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 131
      3921  *       (where Range objects are built), the starting Location
      3922  *       is always guaranteed to be before or equal to the
      3923  *       ending Location.  If they`re equal, this VD$RANGE specifies
      3924  *       an "empty" range:  zero bytes at a specific location.
      3925  *   Note that the ending Location points to the byte following
      3926  *       the last byte to be included in the range.
      3927  *   Note that the two VD$LOCATIONs in a VD$RANGE may have different numbers
      3928  *       of keys.  If .START.KEY doesn`t position down to record-level,
      3929  *       then the first record included in the node at .START.KEY`s last given
      3930  *       key is the start of the range (if .START.KEY has no keys, the
      3931  *       first record of the file is the start of the range);
      3932  *       if .ENDD.KEY doesn`t position down to the record-level, then the
      3933  *       first record included in the node at .ENDD.KEY`s last given key
      3934  *       is the end of the range.
      3935  */
      3936  %MACRO VD$PORT_LEVEL (NAME=VD$PORT_LEVEL,
      3937        STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3938        LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3939
      3940  %IF TEXTCHAR(LEV) = 'AUTO';
      3941     %LSET LEVEL = LEVEL + 1;
      3942  %ELSE;
      3943     %LSET LEVEL = LEV;
      3944  %ENDIF;
      3945
      3946  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      3947  %IF LEVEL = 1;
      3948  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3949  %ELSE;
      3950        %(LEVEL) NAME DIM ALIGNMENT,
      3951  %ENDIF;
      3952
      3953        %(LEVEL+1) ORG#   UBIN           HALF      HALIGNED,
      3954        %(LEVEL+1) KEY_TYPE# UBIN        HALF      HALIGNED,
      3955        %(LEVEL+1) SPEC_TYPE# UBIN       HALF      HALIGNED,
      3956        %VD$SPEC (NAME=SPEC);
      3957        %(LEVEL+1) DATA$  PTR,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 132
      3958        %(LEVEL+1) SPEC_MODIFIED  BIT(1),
      3959        %(LEVEL+1) DATA_MODIFIED  BIT(1),
      3960        %(LEVEL+1) INTERNAL$ PTR  %ENDCHAR
      3961
      3962  %MEND;
      3963  %MACRO VD$RANGE (NAME=VD$RANGE,
      3964   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      3965   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3966
      3967  %IF TEXTCHAR(LEV) = 'AUTO';
      3968     %LSET LEVEL = LEVEL + 1;
      3969  %ELSE;
      3970     %LSET LEVEL = LEV;
      3971  %ENDIF;
      3972
      3973  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      3974  %IF LEVEL = 1;
      3975  DCL 1 NAME DIM STCLASS ALIGNMENT,
      3976  %ELSE;
      3977   %(LEVEL) NAME DIM ALIGNMENT,
      3978  %ENDIF;
      3979
      3980        %VD$LOCATION (NAME=START);
      3981
      3982        %VD$LOCATION (NAME=ENDD, LAST=%LAST#);
      3983
      3984  %MEND;
      3985
      3986
      3987  /*
      3988  *   VD$RECORD_SET
      3989  *   Info about the set of records which have been "checked out" to
      3990  *       VDH.
      3991  *   This is a sub-class of "array_objects".
      3992  */
      3993  %MACRO VD$RECORD_SET (NAME=VD$RECORD_SET,
      3994   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 133
      3995   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      3996
      3997  %IF TEXTCHAR(LEV) = 'AUTO';
      3998     %LSET LEVEL = LEVEL + 1;
      3999  %ELSE;
      4000     %LSET LEVEL = LEV;
      4001  %ENDIF;
      4002
      4003  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      4004  %IF LEVEL = 1;
      4005  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4006  %ELSE;
      4007   %(LEVEL) NAME DIM ALIGNMENT,
      4008  %ENDIF;
      4009
      4010        %VD$OBJECT_HEADER (NAME=OBJECT);
      4011        %(LEVEL+1) SQ_OFFSET# SBIN ALIGNED,
      4012        %(LEVEL+1) N_ENTRIES# SBIN HALF HALIGNED,
      4013        %(LEVEL+1) MX_ENTRIES# SBIN HALF HALIGNED,
      4014
      4015        %VD$NODE_DESC (NAME=DESC, DIM="(0:0)", LAST=%LAST#);
      4016
      4017  %MEND;
      4018
      4019
      4020  /*
      4021  *   VD$SPEC
      4022  *   Specification information for a node.  A textc string.
      4023  *       TYPE tells how to interpret the textc string.
      4024  *
      4025  *   VD$SPEC =>             VD$SPEC for long strings stored in dynamic storage
      4026  *   VD$SPEC_LOCAL =>       VD$SPEC for short strings stored locally
      4027  */
      4028  %MACRO VD$SPEC (NAME=VD$SPEC,
      4029   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4030   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4031

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 134
      4032  %IF TEXTCHAR(LEV) = 'AUTO';
      4033     %LSET LEVEL = LEVEL + 1;
      4034  %ELSE;
      4035     %LSET LEVEL = LEV;
      4036  %ENDIF;
      4037
      4038  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4039  %IF LEVEL = 1;
      4040  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4041  %ELSE;
      4042   %(LEVEL) NAME DIM ALIGNMENT,
      4043  %ENDIF;
      4044
      4045        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,
      4046        %(LEVEL+1) REP# UBIN HALF HALIGNED,
      4047        %(LEVEL+1) V$ PTR %ENDCHAR
      4048
      4049  %MEND;
      4050
      4051  %MACRO VD$SPEC_LOCAL (NAME=VD$SPEC_LOCAL,
      4052   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4053   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4054
      4055  %IF TEXTCHAR(LEV) = 'AUTO';
      4056     %LSET LEVEL = LEVEL + 1;
      4057  %ELSE;
      4058     %LSET LEVEL = LEV;
      4059  %ENDIF;
      4060
      4061  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4062  %IF LEVEL = 1;
      4063  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4064  %ELSE;
      4065   %(LEVEL) NAME DIM ALIGNMENT,
      4066  %ENDIF;
      4067
      4068        %(LEVEL+1) TYPE# UBIN HALF HALIGNED,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 135
      4069        %(LEVEL+1) REP# UBIN HALF HALIGNED,
      4070        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      4071        %(LEVEL+1) BYTES CHAR (%MXNB_STRING_LOCAL) %ENDCHAR
      4072
      4073  %MEND;
      4074
      4075  /*
      4076  *   VD_SPEC
      4077  *   Initializing version of VD$SPEC.
      4078  *   Macro parameters:
      4079  *   STCLASS must be STATIC or CONSTANT.
      4080  *   ITYPE should be a %SPT_ definition; it initializes the .TYPE field.
      4081  *   IREP should be a %REP_ def; it initializes the .REP field.
      4082  *   IBYTES initializes the .V$ or .LENGTH#/.BYTES fields.
      4083  *       What IBYTES should be, based on ITYPE and IREP, is:
      4084  *       ITYPE             IREP          IBYTES
      4085  *       ---------------   ----------    ----------------------------
      4086  *       %SPT_EXT_RECORD   %REP_LOCAL    character string expression
      4087  *       %SPT_xxx          %REP_REMOTE   name of VD_TEXTC_REMOTE (or
      4088  *                                           "string_object" variant)
      4089  *         (any other combo is illegal)
      4090  *   The default is to build a %CLEAR VD$SPEC structure.
      4091  */
      4092  %MACRO VD_SPEC (NAME=VD_SPEC, STCLASS=STATIC, ALIGNMENT=ALIGNED, DIM=" ",
      4093      LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      4094      ITYPE=0, IREP=0, IBYTES=0);
      4095
      4096  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      4097  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      4098  %LSET INIT=CHARTEXT('INIT');
      4099  %LSET EIN=CHARTEXT(' ');
      4100  %ELSE;
      4101  %LSET INIT=CHARTEXT('/*');
      4102  %LSET EIN=CHARTEXT('*/');
      4103  %ENDIF;
      4104
      4105  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 136
      4106  %IF LEVEL = 1;
      4107  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4108  %ELSE;
      4109   %(LEVEL) NAME DIM ALIGNMENT,
      4110  %ENDIF;
      4111         %(LEVEL+1) TYPE# UBIN HALF HALIGNED %INIT (ITYPE) %EIN,
      4112         %(LEVEL+1) REP# UBIN HALF HALIGNED %INIT (IREP) %EIN,
      4113  %IF ITYPE=0;
      4114         %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (0) %EIN,
      4115         %(LEVEL+1) BYTES# UBIN(27) CALIGNED %INIT (0) %EIN  %ENDCHAR
      4116  %ELSE;
      4117     %IF ITYPE=SPT_EXT_RECORD;
      4118         %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED
      4119                    %INIT (%MIN(MXNB_STRING_LOCAL, LENGTHC(IBYTES))) %EIN,
      4120         %(LEVEL+1) BYTES CHAR(%MXNB_STRING_LOCAL) %INIT (IBYTES) %EIN %ENDCHAR
      4121     %ELSE;
      4122        %IF 'IBYTES'='0';
      4123           %LSET IB='NIL';
      4124        %ELSE;
      4125           %LSET IB=TEXTCHAR(IBYTES);
      4126           %ENDIF;
      4127         %(LEVEL+1) V$ PTR %INIT (ADDR(%CHARTEXT(IB))) %EIN  %ENDCHAR
      4128        %ENDIF;     /* ExtRecord or other */
      4129     %ENDIF;     /* Type omitted */
      4130
      4131  %MEND;
      4132
      4133  /*
      4134  *   SPT_? - Spec type
      4135  */
      4136  %EQU SPT_EXT_RECORD = 1;        /*  Spec is DVBYTE                 */
      4137  %EQU SPT_HISTORY_SPEC = 2;      /*  Spec is type of info in record */
      4138  %EQU SPT_NAME_SPEC = 3;         /*  Names level 1; spec is VD$NAME_SPEC */
      4139  %EQU SPT_STRUCTURE_SPEC = 4;    /*  Structure level 1; spec is VD$STRUCTURE_SPEC */
      4140  %EQU SPT_STRUCTURE_LEVEL = 5;   /*  Structures level 2; spec is VD$STRUCTURE_LEVEL */
      4141  %EQU SPT_WINDOW_SPEC = 6;       /*  Windows level 1; spec is VD$WINDOW_SPEC */
      4142  %EQU SPT_WINDOW_BLOCK = 7;      /*  Windows level 2; spec is VD$WINDOW_BLOCK */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 137
      4143  %EQU SPT_ENCODED_FILE_SPEC = 8; /*  File spec for encoded file (not an object) */
      4144  %EQU SPT_MXP1 = 9;              /*  Max SPT_ plus 1             */
      4145
      4146
      4147  /*
      4148  *   VD$STREAM
      4149  *   A stream of data traversing a file.
      4150  *   There exist the following streams:
      4151  *       One stream for each editing window, including the predefined
      4152  *           windows Windows, Names, Structures, and History.
      4153  *       One stream for the source operand for two-operand editing operations.
      4154  *   The editing windows` VD$WINDOW_SPEC.STREAM points to their VD$STREAMs;
      4155  *       the source stream`s VD$STREAM is pointed-to by VD_6E.SOURCE.
      4156  *   All updates to Windows, Structures, Names, and History must be thru
      4157  *       the Acc`r, so that if these internal files are on display
      4158  *       anywhere, the screen will be updated properly.  Names and History
      4159  *       are also read via the Acc`r; however, the nodes of the
      4160  *       Windows and Structures files (ie, each VD$WINDOW_SPEC,
      4161  *       VD$WINDOW_BLOCK, VD$STRUCTURE_SPEC, and VD$STRUCTURE_LEVEL) are
      4162  *       found and examined directly by the rest of 6Edit.
      4163  *   The interface between the Acc`r and the rest of 6Edit tries to make
      4164  *       only certain fixed assumptions about the "structure" of a file and
      4165  *       how it is accessed:
      4166  *           o The file is composed of a tree of nodes.
      4167  *           o The topmost level of the tree is called the "file level".
      4168  *               It is the only level that must be "opened"; all other
      4169  *               levels may be traversed freely.
      4170  *           o Each node consists of Key, Spec, and Data components.
      4171  *               Key and Data components are usually free-form sequences
      4172  *               of bytes (exceptions are:  Keys at file-level are
      4173  *               VD$FILE_KEYs; Data components in Names-file records
      4174  *               for predefined names are usually VD$NUMBERs or VD$POINTERs.)
      4175  *               Spec components are usually PL-6 structures.
      4176  *   At the file level, the "nodes" are the files which match a file
      4177  *       "key", or fid.  Usually there is only one node at the file
      4178  *       level.  However, wildcarded fids are like patterns at the file
      4179  *       level.  We can position sequentially at the file level for just

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 138
      4180  *       this reason:  to deliver sequential fids to the Eval`r for
      4181  *       comparison against a wildcarded fid.
      4182  *   The VD$STREAM traverses the level structure of the file.  Each level has
      4183  *       its own set of "registers":  these registers, called CURRENT
      4184  *       and NEXT, contain info about two adjacent nodes at that level
      4185  *       in the file.
      4186  *   If the stream`s port is closed, the only valid info in the
      4187  *       VD$STREAM is:
      4188  *           PORT - Always points to connected port, if any
      4189  *           FILE_KEY - File we`re positioned to, if any
      4190  *       .CURRENT and .NEXT are %CLEAR when the stream`s port is closed.
      4191  *
      4192  *   .PROTECT (n) is an array of bit-flags, one flag for each
      4193  *       component of the node at level "n"; the CO_ definitions are
      4194  *       used as subscripts into this array.
      4195  *       If the flag for a component at level "n" is set,
      4196  *       the user is not allowed to change that component at that level.
      4197  *   .FILE_KEY contains the key at file level (a file fid).  When
      4198  *       STREAM is open, this will always point to a remote VD$FILE_KEY.
      4199  *   .CURRENT contains the keys (below file level) of the current node.
      4200  *   .NEXT contains the keys (below file level) of the node immediately
      4201  *       following .CURRENT.
      4202  *   Note that at any point in time:
      4203  *       .CURRENT is never = %CLEAR:  if we`re at the end of the file,
      4204  *           CURRENT.EOF will be set.
      4205  *       .NEXT may be = %CLEAR; this means we haven`t yet looked at the
      4206  *           next node.
      4207  */
      4208  %MACRO VD$STREAM (NAME=VD$STREAM,
      4209   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4210   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4211
      4212  %IF TEXTCHAR(LEV) = 'AUTO';
      4213     %LSET LEVEL = LEVEL + 1;
      4214  %ELSE;
      4215     %LSET LEVEL = LEV;
      4216  %ENDIF;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 139
      4217
      4218  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      4219  %IF LEVEL = 1;
      4220  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4221  %ELSE;
      4222   %(LEVEL) NAME DIM ALIGNMENT,
      4223  %ENDIF;
      4224
      4225        %VD$OBJECT_HEADER (NAME=OBJECT);
      4226        %(LEVEL+1) PORT$ PTR,
      4227        %(LEVEL+1) LAST_OP# UBIN HALF HALIGNED,
      4228        %(LEVEL+1) PROTECT(0:%(MX_LOCATION_LEVELS)) BIT (4),
      4229        %(LEVEL+1)  *  BIT(34), /* RFU */
      4230        %VD$KEY (NAME=FILE_KEY);
      4231        %VD$LOCATION (NAME=CURRENT);
      4232
      4233        %VD$LOCATION (NAME=NEXT, LAST=%LAST#);
      4234
      4235  %MEND;
      4236
      4237
      4238  /*
      4239  *   VD$STRING_HEADER
      4240  *   A "string_object" is an object which stores a short (<512 byte) string.
      4241  *       They`re used to store Key and Spec components of file nodes,
      4242  *       among other things.
      4243  *   All "string_objects" have a common header as the first element(s) of their
      4244  *       PL6 structure.
      4245  */
      4246  %MACRO VD$STRING_HEADER (NAME=VD$STRING_HEADER,
      4247   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4248   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4249
      4250  %IF TEXTCHAR(LEV) = 'AUTO';
      4251     %LSET LEVEL = LEVEL + 1;
      4252  %ELSE;
      4253     %LSET LEVEL = LEV;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 140
      4254  %ENDIF;
      4255
      4256  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4257  %IF LEVEL = 1;
      4258  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4259  %ELSE;
      4260   %(LEVEL) NAME DIM ALIGNMENT,
      4261  %ENDIF;
      4262
      4263        %VD$OBJECT_HEADER (NAME=OBJECT);
      4264        %(LEVEL+1) FLINK$ PTR,
      4265        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %ENDCHAR
      4266
      4267  %MEND;
      4268
      4269
      4270  /*
      4271  *   VD$STRUCTURE_LEVEL
      4272  *   Specification of a level of a file "structure".
      4273  *   Each VD$STRUCTURE_LEVEL is one record node (level 2) in the "Structures"
      4274  *       internal file.  The VD$STRUCTURE_LEVEL PL-6 structure defines the
      4275  *       format of the Spec component of the node, pointed-to by each
      4276  *       FILE_NODE.DESC.SPEC.V$ at the record level of the Structures file.
      4277  *       The VD$STRUCTURE_LEVEL object is a sub-class of "string_objects".
      4278  *   .ORG, .KEY_TYPE, and .SPEC_TYPE specify attributes of the
      4279  *       file at this level.  They are significant only for accessor
      4280  *       Structures, and are used primarily for file creation.
      4281  *       By specifying the Structure in a block expression which will
      4282  *       create a file, the user also specifies how to create the file.
      4283  *   .PROTECT and .FILTER are repeated for each component of nodes at this
      4284  *       level.  Subscripts into the arrays are the CO_ definitions.
      4285  *   .PROTECT:  If set, ignore the user`s "protect" option from
      4286  *       the block expression:  the user simply can`t change the nodes`
      4287  *       individual components at this level.
      4288  *       (If not set, for internal files, each node`s ACCESS (NAC_ codes)
      4289  *       controls protection of that one node.)
      4290  */

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 141
      4291  %MACRO VD$STRUCTURE_LEVEL (NAME=VD$STRUCTURE_LEVEL,
      4292   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4293   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      4294   IORG=0, IKEY_TYPE=0, ISPEC_TYPE=0,
      4295   IPROT_KEY='0'B, IPROT_SPEC='0'B, IPROT_DATA='0'B);
      4296
      4297  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      4298  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      4299  %LSET INIT=CHARTEXT('INIT');
      4300  %LSET EIN=CHARTEXT(' ');
      4301  %ELSE;
      4302  %LSET INIT=CHARTEXT('/*');
      4303  %LSET EIN=CHARTEXT('*/');
      4304  %ENDIF;
      4305
      4306  %IF TEXTCHAR(LEV) = 'AUTO';
      4307     %LSET LEVEL = LEVEL + 1;
      4308  %ELSE;
      4309     %LSET LEVEL = LEV;
      4310  %ENDIF;
      4311
      4312  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4313  %IF LEVEL = 1;
      4314  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4315  %ELSE;
      4316   %(LEVEL) NAME DIM ALIGNMENT,
      4317  %ENDIF;
      4318
      4319        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=%CLS_STRUCTURE_LEVEL);
      4320        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      4321        %(LEVEL+1) LENGTH UBIN BYTE CALIGNED %INIT (27) %EIN,
      4322        %(LEVEL+1) * BIT(9) %INIT (%CLEAR) %EIN,
      4323        %(LEVEL+1) ORG# UBIN HALF HALIGNED %INIT (IORG) %EIN,
      4324        %(LEVEL+1) KEY_TYPE# UBIN HALF HALIGNED %INIT (IKEY_TYPE) %EIN,
      4325        %(LEVEL+1) SPEC_TYPE# UBIN HALF HALIGNED %INIT (ISPEC_TYPE) %EIN,
      4326        %(LEVEL+1) PROTECT(0:%CO_MX) BIT (1)
      4327            %INIT ('0'B, IPROT_KEY, IPROT_SPEC, IPROT_DATA) %EIN,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 142
      4328        %(LEVEL+1) * BIT(%(36-CO_MX-1)) %INIT (%CLEAR) %EIN,
      4329        %(LEVEL+1) FILTER#(0:3) SBIN WORD %INIT (0*0) %EIN %ENDCHAR
      4330
      4331  %MEND;
      4332
      4333  /*
      4334  *   VD_STRUCTURE_LEVEL
      4335  *   Version of VD$STRUCTURE_LEVEL.
      4336  */
      4337  %MACRO VD_STRUCTURE_LEVEL (NAME=VD_STRUCTURE_LEVEL, STCLASS=STATIC,
      4338      DIM=" ", ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      4339      IORG=0, IKEY_TYPE=0, ISPEC_TYPE=0,
      4340      IPROT_KEY='0'B, IPROT_SPEC='0'B, IPROT_DATA='0'B);
      4341
      4342  %VD$STRUCTURE_LEVEL (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      4343      LEV=LEVEL, LAST=LAST, IORG=IORG, IKEY_TYPE=IKEY_TYPE, ISPEC_TYPE=ISPEC_TYPE,
      4344      IPROT_KEY=IPROT_KEY, IPROT_SPEC=IPROT_SPEC, IPROT_DATA=IPROT_DATA);
      4345
      4346  %MEND;
      4347
      4348  /*
      4349  *   ORG - File organizations.  Based on CP-6`s but not the same ones exactly.
      4350  *       Identifies how Acc`r is to access file; here is where we`d expand
      4351  *       in the future with ORG_FSA, ORG_TAPE, ORG_CG, ORG_BASIC, ORG_MAIL, ...
      4352  */
      4353  %EQU ORG_CONSEC = 1;        /*  Consec/UR: use KT_NUMBER    */
      4354  %EQU ORG_KEYED = 2;         /*  Keyed: use KT_NUMBER (edit key) or KT_STRING */
      4355  %EQU ORG_INDEXED = 3;       /*  Indexed: use KT_STRING      */
      4356  %EQU ORG_MXP1 = 4;          /*  Max ORG_ value, plus 1      */
      4357
      4358
      4359  /*
      4360  *   VD$STRUCTURE_SPEC
      4361  *   Specification of a file "structure".
      4362  *   There are two kinds of structures:  predefined and user-defined.
      4363  *   The predefined structures specify different ways to access files.
      4364  *       (These are also called "accessor structures".)

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 143
      4365  *       The user can build user-defined structures by changing
      4366  *       some of a predefined structure`s parameters (eg, FIT params)
      4367  *  *N*  and/or adding "display filters" to the predefined structure.
      4368  *   Each VD$STRUCTURE_SPEC is one inner node (level 1) in the "Structures"
      4369  *       internal file.  The VD$STRUCTURE_SPEC PL-6 structure defines the
      4370  *       format of the Spec component of the node, pointed-to by each
      4371  *       FILE_NODE.DESC.SPEC.V$ at level 1 of the Structures file.
      4372  *       The VD$STRUCTURE_SPEC object is a sub-class of "string_objects".
      4373  *   The nodes of the "Structures" file are maintained by both Pres`r
      4374  *       and Int`r.  Making "Structures" a file allows us to have
      4375  *       a window open to the "Structures" file, and have the display
      4376  *       updated whenever a structure`s definition is changed.
      4377  *       The node keys at level 1 of this file are structure names.
      4378  *       All VD$STRUCTURE_SPECs can be found by following the chain
      4379  *       of VD$FILE_NODEs which hang off the VD$FILE_NODE for Structures.
      4380  *   The "record level" of the Structures file is (conceptually) a set of
      4381  *       VD$STRUCTURE_LEVELs.  Each record represents one level of the
      4382  *       file structure.
      4383  *
      4384  *   .ACCESSOR:  If non-nil, this VD$STRUCTURE_SPEC defines a user-defined
      4385  *       structure, and .ACCESSOR refers to the (FileNode for the) predefined
      4386  *       structure which specifies how to access the file.  We need this
      4387  *       `cause modules accessing the file need to know how many real key
      4388  *       levels there are in the actual file structure (and so how many keys
      4389  *       there are in VD$LOCATIONs, VD$BLOCK_DESCs, etc); note that
      4390  *       VD$FILE_NODE.COUNT for this level-1 node shows how many levels
      4391  *       there are in the structure, which (for user-defined structures)
      4392  *       may include abstract levels not used when accessing nodes.
      4393  *       Therefore, when using user-defined structures, evaluation of
      4394  *       user-entered block expressions follows the key schema of this
      4395  *       structure, but evaluation yields a set of keys using .ACCESSOR`s
      4396  *       key schema, and all calls to the Accessor use .ACCESSOR`s key
      4397  *       schema.
      4398  */
      4399  %MACRO VD$STRUCTURE_SPEC (NAME=VD$STRUCTURE_SPEC,
      4400   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4401   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 144
      4402
      4403  %IF TEXTCHAR(LEV) = 'AUTO';
      4404     %LSET LEVEL = LEVEL + 1;
      4405  %ELSE;
      4406     %LSET LEVEL = LEV;
      4407  %ENDIF;
      4408
      4409  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4410  %IF LEVEL = 1;
      4411  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4412  %ELSE;
      4413   %(LEVEL) NAME DIM ALIGNMENT,
      4414  %ENDIF;
      4415
      4416        %VD$OBJECT_HEADER (NAME=OBJECT);
      4417        %(LEVEL+1) FLINK$ PTR,
      4418        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      4419        %(LEVEL+1) * BIT(27), /* RFU */
      4420        %(LEVEL+1) ACCESSOR$ PTR,
      4421        %(LEVEL+1) FIT$ PTR %ENDCHAR
      4422
      4423  %MEND;
      4424
      4425
      4426  /*
      4427  *       VD$TABS
      4428  *       VLP_TABS parameters.  Sub-class of "array_objects".
      4429  *       If .FLUSH is set, then we`ve changed some of these params and
      4430  *           haven`t yet told the FEP.
      4431  */
      4432  %MACRO VD$TABS (NAME=VD$TABS,
      4433   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4434   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4435
      4436  %IF TEXTCHAR(LEV) = 'AUTO';
      4437     %LSET LEVEL = LEVEL + 1;
      4438  %ELSE;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 145
      4439     %LSET LEVEL = LEV;
      4440  %ENDIF;
      4441
      4442  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4443  %IF LEVEL = 1;
      4444  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4445  %ELSE;
      4446   %(LEVEL) NAME DIM ALIGNMENT,
      4447  %ENDIF;
      4448
      4449        %VD$OBJECT_HEADER (NAME=OBJECT);
      4450        %(LEVEL+1) FLINK$ PTR,
      4451        %(LEVEL+1) N_ENTRIES# SBIN HALF HALIGNED,
      4452        %(LEVEL+1) MX_ENTRIES# SBIN HALF HALIGNED,
      4453        %(LEVEL+1) FLUSH BIT (1),
      4454        %(LEVEL+1) *   BIT(8), /* RFU */
      4455        %(LEVEL+1) STOPS#(0:%(MX_TAB_STOPS-1)) UBIN BYTE CALIGNED %ENDCHAR
      4456
      4457  %MEND;
      4458
      4459
      4460  /*
      4461  *   VD$TEXTC[_?]
      4462  *   A short string of data bytes.
      4463  *   Three forms:
      4464  *       VD$TEXTC is resident in static or auto storage.  The ".BYTES"
      4465  *           element is varying-length, based on the ".LENGTH" element.
      4466  *
      4467  *       VD$TEXTC_NUMBER is resident in static or auto storage, or
      4468  *           can be based, pointed-to by the results of a GETKEY
      4469  *           macro.  The ".BYTES#" element is fixed-length.  This
      4470  *           is the actual key value portion of a VD$KEY_NUMBER.
      4471  *
      4472  *       VD$TEXTC_REMOTE is resident in dynamic storage, and is an object
      4473  *           in its own right.
      4474  *           Note that the ".BYTES" element is a varying character string,
      4475  *           whose length is determined by the inherited element

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 146
      4476  *           ".LENGTH".
      4477  *       Macro Parameters:
      4478  *           NAME, STCLASS, ALIGNMENT:  Name, storage class, and alignment
      4479  *               of structure.  Default storage class is BASED;
      4480  *               default alignment is ALIGNED.
      4481  *           ICLASS:  %CLS_ definition for this structure.  Default is
      4482  *               %CLS_TEXTC_REMOTE.
      4483  *           MXNB:  # bytes to allocate for text portion of structure.
      4484  *               This must be a compile-time-evaluated value.
      4485  *               If MXNB is omitted, an IBYTES parameter must be given,
      4486  *                   and the text field of the structure will be allocated
      4487  *                   to be the size of the IBYTES parameter.
      4488  *           IBYTES:  String (in quotes) for initial value.  If IBYTES="''",
      4489  *               then will build the structure for MXNB chars,
      4490  *               whose initial value is a zero-length string.
      4491  */
      4492  %MACRO VD$TEXTC (NAME=VD$TEXTC,
      4493   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4494   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4495
      4496  %IF TEXTCHAR(LEV) = 'AUTO';
      4497     %LSET LEVEL = LEVEL + 1;
      4498  %ELSE;
      4499     %LSET LEVEL = LEV;
      4500  %ENDIF;
      4501
      4502  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4503  %IF LEVEL = 1;
      4504  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4505   %LSET STRUCTNAME = TEXTCHAR(NAME);
      4506   %LSET STCL = SUBSTR (CONCAT (TEXTCHAR (STCLASS), '   '), 0, 3);
      4507   %LSET BASED_DECL = STCL ~= 'AUT' & STCL ~= 'STA' & STCL ~= 'CON' & STCL ~= 'EXT';
      4508  %ELSE;
      4509   %(LEVEL) NAME DIM ALIGNMENT,
      4510   %LSET STRUCTNAME = CONCAT (STRUCTNAME, '.', TEXTCHAR(NAME));
      4511  %ENDIF;
      4512

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 147
      4513        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      4514   %IF BASED_DECL;
      4515        %(LEVEL+1) BYTES CHAR (%CHARTEXT(STRUCTNAME).LENGTH#) %ENDCHAR
      4516   %ELSE;
      4517        %(LEVEL+1) BYTES CHAR (1) %ENDCHAR
      4518   %ENDIF;
      4519
      4520  %MEND;
      4521
      4522  %MACRO VD$TEXTC_NUMBER (NAME=VD$TEXTC_NUMBER,
      4523   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4524   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4525
      4526  %IF TEXTCHAR(LEV) = 'AUTO';
      4527     %LSET LEVEL = LEVEL + 1;
      4528  %ELSE;
      4529     %LSET LEVEL = LEV;
      4530  %ENDIF;
      4531
      4532  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4533  %IF LEVEL = 1;
      4534  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4535  %ELSE;
      4536   %(LEVEL) NAME DIM ALIGNMENT,
      4537  %ENDIF;
      4538
      4539        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      4540        %(LEVEL+1) BYTES# UBIN (27) CALIGNED %ENDCHAR
      4541
      4542  %MEND;
      4543
      4544  %MACRO VD$TEXTC_REMOTE (NAME=VD$TEXTC_REMOTE,
      4545   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4546   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2,
      4547   MXNB=0, IBYTES=' ', ICLASS=%CLS_TEXTC_REMOTE);
      4548
      4549  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 148
      4550  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      4551  %LSET INIT=CHARTEXT('INIT');
      4552  %LSET EIN=CHARTEXT(' ');
      4553  %ELSE;
      4554  %LSET INIT=CHARTEXT('/*');
      4555  %LSET EIN=CHARTEXT('*/');
      4556  %ENDIF;
      4557
      4558  %IF TEXTCHAR(IBYTES)=TEXTCHAR('');
      4559  %LSET LENIBYTES=0;
      4560  %LSET LIBYTES=' ';
      4561  %ELSE;
      4562  %LSET LENIBYTES=LENGTHC(IBYTES);
      4563  %LSET LIBYTES=IBYTES;
      4564  %ENDIF;
      4565
      4566  %IF TEXTCHAR(LEV) = 'AUTO';
      4567     %LSET LEVEL = LEVEL + 1;
      4568  %ELSE;
      4569     %LSET LEVEL = LEV;
      4570  %ENDIF;
      4571
      4572   %LSET STCL = SUBSTR (CONCAT (TEXTCHAR (STCLASS), '   '), 0, 3);
      4573   %LSET BASED_DECL = STCL ~= 'AUT' & STCL ~= 'STA' & STCL ~= 'CON' & STCL ~= 'EXT';
      4574  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4575  %IF LEVEL = 1;
      4576  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4577   %LSET STRUCTNAME = TEXTCHAR(NAME);
      4578   %LSET STCL = SUBSTR (CONCAT (TEXTCHAR (STCLASS), '   '), 0, 3);
      4579   %LSET BASED_DECL = STCL ~= 'AUT' & STCL ~= 'STA' & STCL ~= 'CON' & STCL ~= 'EXT';
      4580  %ELSE;
      4581   %(LEVEL) NAME DIM ALIGNMENT,
      4582  %ENDIF;
      4583
      4584        %VD$OBJECT_HEADER (NAME=OBJECT, STCLASS=STCLASS, ICLASS=ICLASS);
      4585        %(LEVEL+1) FLINK$ PTR %INIT (ADDR(NIL)) %EIN,
      4586        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED %INIT (%LENIBYTES) %EIN,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 149
      4587   %IF BASED_DECL;
      4588        %(LEVEL+1) BYTES CHAR (NAME.LENGTH#) %ENDCHAR
      4589   %ELSE;
      4590        %(LEVEL+1) BYTES CHAR (MXNB) %INIT (%LIBYTES) %EIN %ENDCHAR
      4591   %ENDIF;
      4592
      4593  %MEND;
      4594
      4595  /*
      4596  *   VD_TEXTC
      4597  *   Version of VD$TEXTC with initialization parameters.
      4598  *   Macro Parameters:
      4599  *       NAME, STCLASS, ALIGNMENT:  Name, storage class, and alignment
      4600  *           of structure.  Default storage class is STATIC;
      4601  *           default alignment is CALIGNED.
      4602  *       DIM:  Array declaraction, as follows:
      4603  *                   ... DIM="(0:n)", ...
      4604  *           where "n" is the array upper bound.  Note double-quotes
      4605  *           and parens are required.  Defaults is DIM=" " -- that
      4606  *           is, this isn't an array.
      4607  *       MXNB:  # bytes to allocate for text portion of structure.
      4608  *           This must be a compile-time-evaluated value.
      4609  *           If MXNB is omitted and STCLASS ~= BASED, then an
      4610  *               IBYTES parameter must be given.  The text field of
      4611  *               the TEXTC structure will be allocated to be the
      4612  *               size of the IBYTES parameter.
      4613  *           If MXNB is omitted and STCLASS = BASED, then the
      4614  *               TEXTC structure must be based on an implicit pointer
      4615  *               (ie, the "BASED" clause must include a "(xx$)"
      4616  *               clause).  The text field of the TEXTC structure will
      4617  *               be a varying-length CHAR field; the length field of
      4618  *               the TEXTC structure will determine the length of the
      4619  *               text field.
      4620  *           If STCLASS = PARAM and MXNB = LENGTH, then the TEXTC
      4621  *               structure must be a parameter.  As for BASED above,
      4622  *               the text field of the TEXTC structure will be a
      4623  *               varying-length CHAR field; the length field of the

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 150
      4624  *               TEXTC structure will determine the length of the
      4625  *               text field.
      4626  *       IBYTES:  String (in quotes) for initial value.  Only
      4627  *           valid if STCLASS=STATIC or CONSTANT.  If IBYTES="''",
      4628  *           then will build a TEXTC structure for MXNB chars,
      4629  *           whose initial value is a zero-length string.
      4630  *       INITS:  Number of IBYTES initializers.  This should be given
      4631  *           only if this is an array or is part of an array and
      4632  *           STCLASS is static or constant.
      4633  *           If the array was declared (0:5), then INITS should be <=6,
      4634  *           IBYTES will initialize array subscript 0,
      4635  *           IBYTES1 will initialize array subscript 1, ... ,
      4636  *           and IBYTES5 will initialize array subscript 5.
      4637  *           Note that IBYTES initializers need not be given for
      4638  *           all entries in the array; if the array is (0:5),
      4639  *           you may only want to initialize the first 3 entries,
      4640  *           with REPEAT_LAST=YES to repeat the last initializer.
      4641  *           In this case, INITS should specify the number of
      4642  *           IBYTES parameters you actually give, not the number of
      4643  *           entries in the array.
      4644  *       IBYTES1 thru IBYTES8:  Same as IBYTES, but for entries
      4645  *           1 thru 8 in the array.  IBYTESn is only meaningful
      4646  *           INITS >= (n+1).
      4647  *                           !!! NOTE !!!
      4648  *               IBYTES1 thru IBYTES8 must have double-quotes
      4649  *               around the literal; eg:
      4650  *                       IBYTES1="'initializer #1'", IBYTES2="' # 2'", ...
      4651  *       REPEAT_LAST:  YES or NO.  Only meaningful when
      4652  *           STCLASS is static or constant, and IBYTES initializers
      4653  *           are given.  REPEAT_LAST=YES specifies that the last
      4654  *           IBYTESn given is to be repeated (append "*0" to it).
      4655  */
      4656  %MACRO VD_TEXTC (NAME=TEXTC, STCLASS=STATIC, ALIGNMENT=CALIGNED, DIM=" ",
      4657      MXNB=0, IBYTES=' ', LEVEL=1, LAST=";", INITS=1,
      4658      REPEAT_LAST(YES='1'B,NO='0'B)='0'B,
      4659      IBYTES1=' ', IBYTES2=' ', IBYTES3=' ', IBYTES4=' ',
      4660      IBYTES5=' ', IBYTES6=' ', IBYTES7=' ', IBYTES8=' ');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 151
      4661
      4662  %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
      4663  %IF (SUBSTR(STR,0,6)='STATIC') OR (SUBSTR(STR,0,8)='CONSTANT');
      4664  %LSET INIT=CHARTEXT('INIT');
      4665
      4666  %IF TEXTCHAR(IBYTES)=TEXTCHAR('');
      4667  %LSET LENIBYTES='0';
      4668  %LSET LIBYTES=TEXTCHAR("' '");
      4669  %ELSE;
      4670  %LSET LENIBYTES=BINCHAR(LENGTHC(IBYTES));
      4671  %LSET LIBYTES=TEXTCHAR(IBYTES);
      4672  %IF SUBSTR(LIBYTES,0,1)~='''';
      4673  %LSET LIBYTES=CONCAT('''', IBYTES, '''');
      4674  %ENDIF;
      4675  %ENDIF;
      4676
      4677  %IF INITS>1;
      4678  %IF TEXTCHAR(IBYTES1)=TEXTCHAR('');
      4679  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4680  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4681  %ELSE;
      4682  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES1)));
      4683  %IF SUBSTR(TEXTCHAR(IBYTES1),0,1)='''';
      4684  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES1));
      4685  %ELSE;
      4686  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES1, '''');
      4687  %ENDIF;
      4688  %ENDIF;
      4689
      4690  %IF INITS>2;
      4691  %IF TEXTCHAR(IBYTES2)=TEXTCHAR('');
      4692  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4693  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4694  %ELSE;
      4695  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES2)));
      4696  %IF SUBSTR(TEXTCHAR(IBYTES2),0,1)='''';
      4697  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES2));

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 152
      4698  %ELSE;
      4699  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES2, '''');
      4700  %ENDIF;
      4701  %ENDIF;
      4702
      4703  %IF INITS>3;
      4704  %IF TEXTCHAR(IBYTES3)=TEXTCHAR('');
      4705  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4706  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4707  %ELSE;
      4708  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES3)));
      4709  %IF SUBSTR(TEXTCHAR(IBYTES3),0,1)='''';
      4710  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES3));
      4711  %ELSE;
      4712  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES3, '''');
      4713  %ENDIF;
      4714  %ENDIF;
      4715
      4716  %IF INITS>4;
      4717  %IF TEXTCHAR(IBYTES4)=TEXTCHAR('');
      4718  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4719  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4720  %ELSE;
      4721  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES4)));
      4722  %IF SUBSTR(TEXTCHAR(IBYTES4),0,1)='''';
      4723  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES4));
      4724  %ELSE;
      4725  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES4, '''');
      4726  %ENDIF;
      4727  %ENDIF;
      4728
      4729  %IF INITS>5;
      4730  %IF TEXTCHAR(IBYTES5)=TEXTCHAR('');
      4731  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4732  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4733  %ELSE;
      4734  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES5)));

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 153
      4735  %IF SUBSTR(TEXTCHAR(IBYTES5),0,1)='''';
      4736  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES5));
      4737  %ELSE;
      4738  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES5, '''');
      4739  %ENDIF;
      4740  %ENDIF;
      4741
      4742  %IF INITS>6;
      4743  %IF TEXTCHAR(IBYTES6)=TEXTCHAR('');
      4744  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4745  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4746  %ELSE;
      4747  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES6)));
      4748  %IF SUBSTR(TEXTCHAR(IBYTES6),0,1)='''';
      4749  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES6));
      4750  %ELSE;
      4751  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES6, '''');
      4752  %ENDIF;
      4753  %ENDIF;
      4754
      4755  %IF INITS>7;
      4756  %IF TEXTCHAR(IBYTES7)=TEXTCHAR('');
      4757  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4758  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');
      4759  %ELSE;
      4760  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES7)));
      4761  %IF SUBSTR(TEXTCHAR(IBYTES7),0,1)='''';
      4762  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES7));
      4763  %ELSE;
      4764  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES7, '''');
      4765  %ENDIF;
      4766  %ENDIF;
      4767
      4768  %IF INITS>8;
      4769  %IF TEXTCHAR(IBYTES8)=TEXTCHAR('');
      4770  %LSET LENIBYTES=CONCAT(LENIBYTES, ',0');
      4771  %LSET LIBYTES=CONCAT(LIBYTES, ', '' ''');

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 154
      4772  %ELSE;
      4773  %LSET LENIBYTES=CONCAT(LENIBYTES, ',', BINCHAR(LENGTHC(IBYTES8)));
      4774  %IF SUBSTR(TEXTCHAR(IBYTES8),0,1)='''';
      4775  %LSET LIBYTES=CONCAT(LIBYTES, ',', TEXTCHAR(IBYTES8));
      4776  %ELSE;
      4777  %LSET LIBYTES=CONCAT(LIBYTES, ',''', IBYTES8, '''');
      4778  %ENDIF;
      4779  %ENDIF;
      4780
      4781  %ERROR (INITS>9, 'VD_TEXTC INITS parameter must be <= 8.', 1);
      4782  %ENDIF;     /* IF INITS>8 */
      4783  %ENDIF;     /* IF INITS>7 */
      4784  %ENDIF;     /* IF INITS>6 */
      4785  %ENDIF;     /* IF INITS>5 */
      4786  %ENDIF;     /* IF INITS>4 */
      4787  %ENDIF;     /* IF INITS>3 */
      4788  %ENDIF;     /* IF INITS>2 */
      4789  %ENDIF;     /* IF INITS>1 */
      4790  %IF REPEAT_LAST;
      4791  %LSET LENIBYTES=CONCAT(LENIBYTES, '*0');
      4792  %LSET LIBYTES=CONCAT(LIBYTES, '*0');
      4793  %ENDIF;
      4794  %ELSE;      /* Not static or constant */
      4795  %LSET INIT=CHARTEXT('/*');
      4796  %LSET LENIBYTES='0';
      4797  %LSET LIBYTES=' ';
      4798  %ENDIF;
      4799
      4800  %IF (SUBSTR(STR,0,5)='BASED' AND TEXTCHAR(MXNB)='0')
      4801      OR (SUBSTR(STR,0,5)='PARAM' AND TEXTCHAR(MXNB)='LENGTH');
      4802  %LSET LMXNB=CHARTEXT(CONCAT(TEXTCHAR(NAME),'.LENGTH#'));
      4803  %ELSE;
      4804  %LSET LMXNB=MXNB;
      4805  %ENDIF;
      4806
      4807  %IF LEVEL=1;
      4808  DCL 1 NAME DIM STCLASS ALIGNMENT,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 155
      4809  %ELSE;
      4810          %LEVEL NAME DIM ALIGNMENT,
      4811  %ENDIF;
      4812            %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED
      4813            %INIT (%CHARTEXT(LENIBYTES)) %CHARTEXT('/**/'),
      4814            %(LEVEL+1) BYTES CHAR(%LMXNB) CALIGNED
      4815            %INIT (%CHARTEXT(LIBYTES)) %CHARTEXT('/**/')  LAST
      4816
      4817  %MEND;
      4818
      4819  /*
      4820  *   VD_TEXTC_REMOTE
      4821  *   Version of VD$TEXTC_REMOTE with initialization parameters.
      4822  */
      4823  %MACRO VD_TEXTC_REMOTE (NAME=VD_TEXTC_REMOTE, STCLASS=STATIC,
      4824      DIM=" ", MXNB=0, IBYTES=' ', ICLASS=%CLS_TEXTC_REMOTE,
      4825      ALIGNMENT=ALIGNED, LEVEL=1, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4826
      4827            %VD$TEXTC_REMOTE (NAME=NAME, STCLASS=STCLASS, DIM=DIM, ALIGNMENT=ALIGNMENT,
      4828            LEV=LEVEL, LAST=LAST, MXNB=MXNB, IBYTES=IBYTES, ICLASS=ICLASS);
      4829
      4830  %MEND;
      4831
      4832
      4833  /*
      4834  *   VD$WILD_STRINGS
      4835  *   Actually a VD$BUFFER, but contains two arrays used to keep track of
      4836  *   matching wildcards.  The W.N# array contains the number of the
      4837  *   source wildcard string that is to replace the position represented
      4838  *   by the corresponding entry in the W.RANGE array of RANGES.  But, since
      4839  *   VD$RANGE already has an array in it, W is not an array, and references
      4840  *   to it are made by PINCRWing by index*SIZEW(VD$WILDSTRINGS.W).
      4841  */
      4842  %MACRO VD$WILD_STRINGS (NAME=VD$WILD_STRINGS,
      4843   STCLASS=BASED, ALIGNMENT=ALIGNED,
      4844   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2)=2);
      4845

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 156
      4846  %IF TEXTCHAR(LEV)='AUTO';
      4847   %LSET LEVEL=LEVEL+1;
      4848  %ELSE;
      4849   %LSET LEVEL=LEV;
      4850  %ENDIF;
      4851
      4852  %LSET ENDCHAR=CHARTEXT (SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4853          %VD$BUFFER_HEADER (NAME=NAME,LEV="%(LEVEL)",STCLASS=STCLASS,LAST=NO);
      4854          %(LEVEL+1) N_WILDCARDS# SBIN HALF HALIGNED,
      4855          %(LEVEL+1) W ALIGNMENT,
      4856          %(LEVEL+2) N# SBIN,
      4857  %LSET   LASTN=LAST+2;
      4858          %VD$RANGE (NAME=RANGE, LEV=LEVEL+2, LAST=LASTN);
      4859  %MEND;
      4860
      4861
      4862  /*
      4863  *   VD$WINDOW_BLOCK
      4864  *   The Spec component of records in the Windows internal file.
      4865  *   VD$FILE_NODE.DESC.SPEC.V$ at record-level points to a
      4866  *       VD$WINDOW_BLOCK object (which is a sub-class of "string_objects").
      4867  *   Contains info about previous EditBlocks and SelectedBlocks on display
      4868  *       in the window.
      4869  *
      4870  *   EDIT_BLOCK: EditBlock on display in window
      4871  *   EVAL: Top of evaluation stack: SelBlock
      4872  */
      4873  %MACRO VD$WINDOW_BLOCK (NAME=VD$WINDOW_BLOCK,
      4874   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      4875   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      4876
      4877  %IF TEXTCHAR(LEV) = 'AUTO';
      4878     %LSET LEVEL = LEVEL + 1;
      4879  %ELSE;
      4880     %LSET LEVEL = LEV;
      4881  %ENDIF;
      4882

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 157
      4883  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      4884  %IF LEVEL = 1;
      4885  DCL 1 NAME DIM STCLASS ALIGNMENT,
      4886  %ELSE;
      4887   %(LEVEL) NAME DIM ALIGNMENT,
      4888  %ENDIF;
      4889
      4890        %VD$OBJECT_HEADER (NAME=OBJECT);
      4891        %(LEVEL+1) FLINK$ PTR,
      4892        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      4893        %(LEVEL+1)  *  BIT(27), /* RFU */
      4894        %(LEVEL+1) EDIT_BLOCK$ PTR,
      4895        %(LEVEL+1) EVAL$ PTR %ENDCHAR
      4896
      4897  %MEND;
      4898
      4899
      4900  /*
      4901  *   VD$WINDOW_SPEC
      4902  *   Info about the command window or an editing window.
      4903  *   Note that a window can have a 0-size COORDS.  This is called
      4904  *       a "pop-up" window:  a window (and it`s associated stream,
      4905  *       EditBlock, and SelectedBlock) which is maintained by 6Edit but
      4906  *       is not currently being displayed on the screen.  At any time,
      4907  *       the user can pop such a window up onto the screen.  Pop-up
      4908  * *N*   windows are used for the pre-defined windows for the internal
      4909  * *N*   files:  History, Names, Structures, and Windows.
      4910  *       Also used for the command window.
      4911  *   Note that editing operations are always performed on behalf of an
      4912  *       editing window; therefore, at least one operand of all editing
      4913  *       operations will refer to the window`s EditBlock    if not,
      4914  *       the Int`r will either change the window`s EditBlock first or
      4915  *       reject the editing operation.
      4916  *   This means that at least one stream in all operations will be open
      4917  *       to the window`s EditBlock.  Each window has its own stream
      4918  *       reserved for access to its current EditBlock.
      4919  *       For one-stream operations, only the window`s stream is

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 158
      4920  *       used; for two-stream operations, the destination is always
      4921  *       in the EditBlock, so the window`s stream is used for that;
      4922  *       the SourceBlock has its own stream to use.
      4923  *   Each VD$WINDOW_SPEC is one inner node (level 1) in the "Windows"
      4924  *       internal file.  The VD$WINDOW_SPEC PL-6 structure defines the
      4925  *       format of the Spec component of the node, pointed-to by each
      4926  *       VD$FILE_NODE.DESC.SPEC.V$ at level 1 of the Windows file.
      4927  *   The nodes of the "Windows" file are maintained by both Pres`r
      4928  *       and Int`r.  Making "Windows" a file allows us to have
      4929  *       a window open to the "Windows" file as a status display, and
      4930  *       have the display updated whenever a window`s status changed.
      4931  *       The node keys for this file are user-visible window numbers,
      4932  *       counting the top window on the screen as window #1.  Note that
      4933  *       the node key for a window may change if we create a new
      4934  *       window above it on the screen.
      4935  *       All VD$WINDOW_SPECs can be found by following the chain
      4936  *       of VD$FILE_NODEs which hang off the VD$FILE_NODE for Windows.
      4937  *   The "record level" of the Windows file is (conceptually) a set of
      4938  *       VD$WINDOW_BLOCKs.  Each record represents one entry in the
      4939  *       "EditBlock stack" for the window, representing previous EditBlocks
      4940  *       which have been on display in the window.  The current
      4941  *       EditBlock is maintained in .OPERAND, although it has an entry
      4942  *       in the set of VD$WINDOW_BLOCKs.  .CURR_INDEX# is the index
      4943  *       into the VD$WINDOW_BLOCKs of the entry for the current
      4944  *       EditBlock.
      4945  *       Each record-level VD$FILE_NODE.DESC.SPEC.V$ points to a
      4946  *       VD$WINDOW_BLOCK PL-6 structure, which is a sub-class of
      4947  *       "string_objects".
      4948  *
      4949  *   .COMMAND is set if this is the command window.  There will only
      4950  *       ever be one command window in the Windows file.  For the
      4951  *       command window, only the following fields are valid:
      4952  *           COORDS, DCB, TRMCTL, EDTCTL, TABS, INTRO_1, INTRO_2,
      4953  *           KEY_DEFINITION_BUFFER
      4954  *   .OPERAND specifies all info needed by the InTree evaluation
      4955  *       routines in order to evaluate the InTree for this window.
      4956  *       This includes:

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 159
      4957  *       .STREAM$ points to the VD$STREAM dedicated to use by this
      4958  *           editing window.
      4959  *       .INTREE points to the VD$IT_BLOCK_EXPR root node of the current
      4960  *           InTree for this window.  After each editing command,
      4961  *           the InTree is freed.
      4962  *       .EDIT_BLOCK specifies the current EditBlock; also, its:
      4963  *           "protect" option specifies access mode of the window;
      4964  *           "component" option specifies which component of the record
      4965  *               we`re displaying in the window;
      4966  *           "structure" option specifies the structure and display
      4967  *               filter used to display the file;
      4968  *           "level" option specifies the level of the file structure
      4969  *               on display in the window;
      4970  *           .RANGE is always constrained to be on record boundaries,
      4971  *               ie, only whole records will be included.
      4972  *       .EVAL points to the top entry on the evaluation stack.  This
      4973  *           top entry specifies locations of the cursor/FilePointer
      4974  *           ($FP/HERE) and the cursor-field/block-being-selected
      4975  *           ($RANGE/THAT), which may be empty.
      4976  *           Pres`r and Int`r share maintenance of .EVAL:  when Pres`r
      4977  *           gets control it uses it to record info on the cursor field;
      4978  *           when Int`r gets control to process a command, it uses
      4979  *           .EVAL during the evaluation of the InTree.
      4980  *   .CURR_INDEX# is the index into the level-2 children of this
      4981  *       window of the entry for the current EditBlock.  Note that
      4982  *       the info in this VD$WINDOW_SPEC should be used instead
      4983  *       of the info in the VD$WINDOW_BLOCK specified by .CURR_INDEX#;
      4984  *       .CURR_INDEX# just acts as a "file pointer", indicating where
      4985  *       we are in the level-2 chain.
      4986  *   .SCREEN_UPDATED is set whenever the Pres`r does an M$READ or
      4987  *       an M$DEVICE to this window, and reset whenver it does
      4988  *       an M$WRITE, M$ERASE, M$DELETE, or M$REKEY to this window.
      4989  *       It`s tested just before we read from any window (command
      4990  *       or editing), to be sure the FEP has posted any changes
      4991  *       to the screen.  If the bit is reset, we`ll M$DEVICE to
      4992  *       force the changes to the screen.
      4993  *   .RECORD_SET specifies which records VDH is editing.  Due to an

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 160
      4994  *       anamoly in the way VDH`S ORG=SE handles end of the block on
      4995  *       the screen, .RECORD_SET may at times specify at most one
      4996  *       record at the top of the screen which isn`t actually on
      4997  *       display in the screen anymore.  This isn`t a problem, as
      4998  *       long as (1) it`s at most 1 record, and (2) .RECORD_SET only
      4999  *       ever errs by thinking more is on the screen than actually
      5000  *       is, rather than by thinking less is on the screen.
      5001  *   .COORDS
      5002  *       Info needed to recreate a window via VDH.
      5003  *       Note that .HEIGHT and .WIDTH may be stored as either a # of
      5004  *           lines or columns, or as percentages of the size of another
      5005  *           window.  Percentages are used only before M$OPENing a window;
      5006  *           once it`s open, the actual numbers are stored in .HEIGHT and
      5007  *           .WIDTH.
      5008  *
      5009  *       LINE:        } Screen co-ordinates of upper-left corner
      5010  *       COLUMN:      }
      5011  *       HEIGHT:    } Size of window:  may be 0 for "pop-up" windows
      5012  *       WIDTH:     }
      5013  *       HEIGHT_PERCENT: Set if .HEIGHT is a percentage
      5014  *       WIDTH_PERCENT: Set if .WIDTH is a percetage
      5015  *   .TRMCTL contains values for M$STRMCTL for this window.
      5016  *       If .FLUSH is set, then we`ve changed some of these params and
      5017  *           haven`t yet told the FEP.
      5018  *       If .FLUSH is set, then we`ve changed some of these params and
      5019  *           haven`t yet told the FEP.
      5020  *   .EDTCTL contains values for M$STRMCTL for this window.
      5021  *   .TABS contains tab stops for this window.
      5022  *   .INTRO_1 contains the $INTRO_1 chars for this window.
      5023  *   .INTRO_2 contains the $INTRO_2 chars for this window.
      5024  *   .KEY_DEFINITION_BUFFER points to a VD$BUFFER holding any terminal
      5025  *       key definitions which haven`t been sent to the FEP yet.
      5026  */
      5027
      5028  /*    Equates for FLUSH flags of EDTCTL's and TRMCTL's */
      5029
      5030  %EQU  TRM_WORDWRAP = 1;

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 161
      5031  %EQU  TRM_INSERT_MODE = 2;
      5032  %EQU  TRM_HSCROLL_MARGIN = 4;
      5033  %EQU  TRM_HSCROLL = 8;
      5034  %EQU  TRM_AUTOTAB = 16;
      5035
      5036  %EQU  EDT_EZAPPEND = 1;
      5037  %EQU  EDT_TEXTEDIT = 2;
      5038  %EQU  EDT_HSALL = 4;
      5039  %EQU  EDT_VSCROLL_MARGIN = 8;
      5040  %EQU  EDT_VSCROLL = 16;
      5041  %EQU  EDT_RECORDWRAP = 32;
      5042  %EQU  EDT_KEY_GENERATION = 64;
      5043
      5044  %MACRO VD$WINDOW_SPEC (NAME=VD$WINDOW_SPEC,
      5045   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      5046   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      5047
      5048  %IF TEXTCHAR(LEV) = 'AUTO';
      5049     %LSET LEVEL = LEVEL + 1;
      5050  %ELSE;
      5051     %LSET LEVEL = LEV;
      5052  %ENDIF;
      5053
      5054  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      5055  %IF LEVEL = 1;
      5056  DCL 1 NAME DIM STCLASS ALIGNMENT,
      5057  %ELSE;
      5058   %(LEVEL) NAME DIM ALIGNMENT,
      5059  %ENDIF;
      5060
      5061        %VD$OBJECT_HEADER (NAME=OBJECT);
      5062        %(LEVEL+1) FLINK$ PTR,
      5063        %(LEVEL+1) LENGTH# UBIN BYTE CALIGNED,
      5064        %(LEVEL+1) COMMAND BIT (1),
      5065        %(LEVEL+1) COORDS,
      5066          %(LEVEL+2) LINE# SBIN WORD,
      5067          %(LEVEL+2) COLUMN# SBIN WORD,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 162
      5068          %(LEVEL+2) HEIGHT# SBIN WORD,
      5069          %(LEVEL+2) WIDTH# SBIN WORD,
      5070          %(LEVEL+2) HEIGHT_PERCENT BIT (1),
      5071          %(LEVEL+2) WIDTH_PERCENT BIT (1),
      5072        %VD$OPERAND (NAME=OPERAND);
      5073        %(LEVEL+1) CURR_INDEX# SBIN HALF HALIGNED,
      5074        %(LEVEL+1) DCB# UBIN HALF HALIGNED,
      5075        %(LEVEL+1) BOB_DISPLAYED BIT (1),
      5076        %(LEVEL+1) EOB_DISPLAYED BIT (1),
      5077        %(LEVEL+1) SCREEN_UPDATED BIT (1),
      5078        %(LEVEL+1)  *        BIT(6), /* RFU */
      5079        %(LEVEL+1)  FWINDOW# UBIN(9) CALIGNED,
      5080        %(LEVEL+1) RECORD_SET$ PTR,
      5081        %(LEVEL+1) TRMCTL,
      5082          %(LEVEL+2) FLUSH,
      5083            %(LEVEL+3)   AUTOTAB  BIT(1),
      5084            %(LEVEL+3)   HSCROLL  BIT(1),
      5085            %(LEVEL+3)   HSCROLL_MARGIN   BIT(1),
      5086            %(LEVEL+3)   INSERT_MODE      BIT(1),
      5087            %(LEVEL+3)   SCROLL           BIT(1),
      5088            %(LEVEL+3)   WORDWRAP BIT(1),
      5089            %(LEVEL+3)   * BIT(3),
      5090          %(LEVEL+2) * BIT(7),
      5091          %(LEVEL+2) INSERT_MODE BIT (1),
      5092          %(LEVEL+2) SCROLL#     BIT (1),
      5093          %(LEVEL+2) AUTOTAB# SBIN HALF HALIGNED,
      5094          %(LEVEL+2) HSCROLL# SBIN HALF HALIGNED,
      5095          %(LEVEL+2) HSCROLL_MARGIN# SBIN HALF HALIGNED,
      5096          %(LEVEL+2) WORDWRAP# SBIN HALF HALIGNED,
      5097        %(LEVEL+1) EDTCTL,
      5098          %(LEVEL+2) FLUSH,
      5099            %(LEVEL+3) KEY_GENERATION BIT(1),
      5100            %(LEVEL+3) RECWRAP BIT(1),
      5101            %(LEVEL+3) VSCROLL BIT(1),
      5102            %(LEVEL+3) VSCROLL_MARGIN BIT(1),
      5103            %(LEVEL+3) HSALL   BIT(1),
      5104            %(LEVEL+3) TEXTEDIT BIT(1),

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 163
      5105            %(LEVEL+3) EZAPPEND BIT(1),
      5106            %(LEVEL+3) EOFMARK BIT(1),
      5107            %(LEVEL+3) TABS BIT(1),
      5108            %(LEVEL+3) ONESPACEEDIT BIT(1),
      5109            %(LEVEL+3) * BIT(2),
      5110          %(LEVEL+2) ONESPACEEDIT# BIT(1),
      5111          %(LEVEL+2) * BIT(1),
      5112          %(LEVEL+2) RECORDWRAP BIT (1),
      5113          %(LEVEL+2) HSALL#  BIT(1),
      5114          %(LEVEL+2) TEXTEDIT# BIT(1),
      5115          %(LEVEL+2) EZAPPEND# BIT(1),
      5116          %(LEVEL+2) KEY_GENERATION# SBIN HALF HALIGNED,
      5117          %(LEVEL+2) VSCROLL# SBIN HALF HALIGNED,
      5118          %(LEVEL+2) VSCROLL_MARGIN# SBIN HALF HALIGNED,
      5119          %(LEVEL+2) KEY_INCR# SBIN HALF HALIGNED,
      5120        %(LEVEL+1) TABS$ PTR,
      5121        %(LEVEL+1) EOFMARK$ PTR,
      5122        %(LEVEL+1) INTRO_1 ALIGNMENT,
      5123          %(LEVEL+2) LENGTH# UBIN BYTE CALIGNED,
      5124          %(LEVEL+2) BYTES CHAR (%MXNB_$INTRO),
      5125        %(LEVEL+1) INTRO_2 ALIGNMENT,
      5126          %(LEVEL+2) LENGTH# UBIN BYTE CALIGNED,
      5127          %(LEVEL+2) BYTES CHAR (%MXNB_$INTRO),
      5128        %(LEVEL+1) KEY_DEFINITION_BUFFER$ PTR %ENDCHAR
      5129
      5130  %MEND;
      5131
      5132  %MACRO VD$WINDOW_COORDS (NAME=VD$WINDOW_COORDS,
      5133        STCLASS(PARAM=" ",ANY)=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      5134        LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      5135
      5136  %IF TEXTCHAR(LEV) = 'AUTO';
      5137        %LSET LEVEL = LEVEL + 1;
      5138  %ELSE;
      5139        %LSET LEVEL = LEV;
      5140  %ENDIF;
      5141

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 164
      5142  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      5143  %IF LEVEL = 1;
      5144  DCL 1 NAME DIM  STCLASS  ALIGNMENT,
      5145  %ELSE;
      5146    %(LEVEL) NAME DIM ALIGNMENT,
      5147  %ENDIF;
      5148
      5149        %(LEVEL+1)  LINE#                SBIN WORD,
      5150        %(LEVEL+1)  COLUMN#              SBIN WORD,
      5151        %(LEVEL+1)  HEIGHT#              SBIN WORD,
      5152        %(LEVEL+1)  WIDTH#               SBIN WORD,
      5153        %(LEVEL+1)  HEIGHT_PERCENT       BIT(1),
      5154        %(LEVEL+1)  WIDTH_PERCENT        BIT(1)   %ENDCHAR
      5155
      5156  %MEND;
      5157
      5158  /*
      5159  *   VD$XLATE_ENTRY
      5160  *   One entry in VD$XLATE_LOCATIONS.XLATES array.
      5161  *   .OLD_KEY_LO is the low-bound of the keys to match at
      5162  *       VD$XLATE_LOCATIONS.LEVEL.
      5163  *   .OLD_KEY_HI is the high-bound of the keys to match.
      5164  *   .NEW_KEY is the new key to translate any matching keys to.
      5165  *   .OLD_POS_LO is the low position for translation.
      5166  *   .OLD_POS_HI is the high position for translation.
      5167  *   .NEW_POS is the new position to translate to.  It is used for
      5168  *       any positions in .OLD_KEY_ range which are between .OLD_POS_LO
      5169  *       and .OLD_POS_HI.
      5170  *       If .NEW_POS is <0, then we shouldn`t translate (key or position)
      5171  *       any locations in the .OLD_KEY_ range which are between .OLD_POS_LO
      5172  *       and .OLD_POS_HI.  However, if .NEW_POS_INCR is >0, we should
      5173  *       go ahead and do it`s translations.
      5174  *   .NEW_POS_INCR is the position increment.  It is used for any
      5175  *       positions in .OLD_KEY_ range which are greater than .OLD_POS_HI.
      5176  */
      5177  %MACRO VD$XLATE_ENTRY (NAME=VD$XLATE_ENTRY,
      5178   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 165
      5179   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      5180
      5181  %IF TEXTCHAR(LEV) = 'AUTO';
      5182     %LSET LEVEL = LEVEL + 1;
      5183  %ELSE;
      5184     %LSET LEVEL = LEV;
      5185  %ENDIF;
      5186
      5187  %LSET ENDCHAR = CHARTEXT(SUBSTR(',;,;',LAST+BITBIN(LAST>LEVEL),1));
      5188  %IF LEVEL = 1;
      5189  DCL 1 NAME DIM STCLASS ALIGNMENT,
      5190  %ELSE;
      5191   %(LEVEL) NAME DIM ALIGNMENT,
      5192  %ENDIF;
      5193
      5194        %VD$KEY (NAME=OLD_KEY_LO);
      5195        %VD$KEY (NAME=OLD_KEY_HI);
      5196        %(LEVEL+1) OLD_POS_LO# SBIN HALF HALIGNED,
      5197        %(LEVEL+1) OLD_POS_HI# SBIN HALF HALIGNED,
      5198        %VD$KEY (NAME=NEW_KEY);
      5199        %(LEVEL+1) NEW_POS# SBIN HALF HALIGNED,
      5200        %(LEVEL+1) NEW_POS_INCR# SBIN HALF HALIGNED %ENDCHAR
      5201
      5202  %MEND;
      5203
      5204
      5205  /*
      5206  *   VD$XLATE_LOCATIONS
      5207  *   Passed to VDG$XLATE_ routines.  VD$XLATE_LOCATIONS is a sub-class of
      5208  *       "array_objects".
      5209  *   Contains array of key and position translations, used when rekeying a
      5210  *       file or inserting or deleting blocks.
      5211  *   .LEVEL specifies the level at which translation is to take place.
      5212  *   .PREFIX specifies the keys from levels 1 thru (.LEVEL - 1).
      5213  *       A location must match .FILE_KEY and .PREFIX in order to
      5214  *       qualify for translation.
      5215  *   .XLATES is the array of translations.

 11:05 NOV 14 '97 VD_MACROS_M                              VD_MACROS_M           Page 166
      5216  */
      5217  %MACRO VD$XLATE_LOCATIONS (NAME=VD$XLATE_LOCATIONS,
      5218   STCLASS=BASED, DIM=" ", ALIGNMENT=ALIGNED,
      5219   LEV=AUTO, LAST(YES=1, NO=0, AUTO=2, ANY)=2);
      5220
      5221  %IF TEXTCHAR(LEV) = 'AUTO';
      5222     %LSET LEVEL = LEVEL + 1;
      5223  %ELSE;
      5224     %LSET LEVEL = LEV;
      5225  %ENDIF;
      5226
      5227  %IF LEVEL = 1;
      5228  DCL 1 NAME DIM STCLASS ALIGNMENT,
      5229  %ELSE;
      5230   %(LEVEL) NAME DIM ALIGNMENT,
      5231  %ENDIF;
      5232
      5233        %VD$OBJECT_HEADER (NAME=OBJECT);
      5234        %(LEVEL+1) N_ENTRIES# SBIN HALF HALIGNED,
      5235        %(LEVEL+1) MX_ENTRIES# SBIN HALF HALIGNED,
      5236        %(LEVEL+1) FLINK$ PTR,
      5237        %VD$KEY (NAME=FILE_KEY);
      5238        %(LEVEL+1) LEVEL# SBIN HALF HALIGNED,
      5239        %VD$LOCATION (NAME=PREFIX);
      5240
      5241  %LSET LAST# = BITBIN((LAST=1)|(LAST>LEVEL));
      5242        %VD$XLATE_ENTRY (NAME=XLATES, DIM="(0:0)", LAST=%LAST#);
      5243
      5244  %MEND;

 11:05 NOV 14 '97 VD_NODES0_E                              VD_NODES0_E           Page 167
         1  /*M* VD_NODES0_E - EQUs for VD_NODES0_D */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /*N*  The parse codes for 6EDIT start at 1001, thus reserving 0 - 1000 for XUE
         9        function parse codes (Star# 30354) */
        10
        11
        12  %EQU  VD_BASE#   =  1000;
        13
        14  %EQU T_COMMAND_LINE = %VD_BASE# + 01;
        15  %EQU T_EDIT_CMD = %VD_BASE# + 02;
        16  %EQU T_WINDOW_CMD = %VD_BASE# + 03;
        17  %EQU T_LINES = %VD_BASE# + 04;
        18  %EQU T_PERCENT = %VD_BASE# + 05;
        19  %EQU T_DISPLAY_CMD = %VD_BASE# + 06;
        20  %EQU T_COPY_CMD = %VD_BASE# + 07;
        21  %EQU T_MOVE_CMD = %VD_BASE# + 08;
        22  %EQU T_AFTER_CMD = %VD_BASE# + 09;
        23  %EQU T_OVER_CMD = %VD_BASE# + 10;
        24  %EQU T_DELETE_CMD = %VD_BASE# + 11;
        25  %EQU T_EQUALS_CMD = %VD_BASE# + 12;
        26  %EQU T_LOCATION_CMD = %VD_BASE# + 13;
        27  %EQU T_SYNONYM_CMD = %VD_BASE# + 14;
        28  %EQU T_SPECIAL_NAME = %VD_BASE# + 15;
        29  %EQU T_SY_VALUE = %VD_BASE# + 16;
        30  %EQU T_KEYIN_CMD = %VD_BASE# + 17;
        31  %EQU T_IF_CMD = %VD_BASE# + 18;
        32  %EQU T_KEYIN_NAME = %VD_BASE# + 19;
        33  %EQU T_KEYIN_VALUE = %VD_BASE# + 20;
        34  %EQU T_INPUT = %VD_BASE# + 21;
        35  %EQU T_SAVE_CMD = %VD_BASE# + 22;
        36  %EQU T_ALL = %VD_BASE# + 23;
        37  %EQU T_PREDEF_FILE_NAME = %VD_BASE# + 24;

 11:05 NOV 14 '97 VD_NODES0_E                              VD_NODES0_E           Page 168
        38  %EQU T_TO = %VD_BASE# + 25;
        39  %EQU T_SHOW_CMD = %VD_BASE# + 26;
        40  %EQU T_OVER = %VD_BASE# + 27;
        41  %EQU T_RESTORE_CMD = %VD_BASE# + 28;
        42  %EQU T_READ_CMD = %VD_BASE# + 29;
        43  %EQU T_END_CMD = %VD_BASE# + 30;
        44  %EQU T_FID = %VD_BASE# + 31;
        45  %EQU T_BLOCK_EXPR = %VD_BASE# + 32;
        46  %EQU T_PROTECT = %VD_BASE# + 33;
        47  %EQU T_DONT = %VD_BASE# + 34;
        48  %EQU T_STRUCTURE = %VD_BASE# + 35;
        49  %EQU T_KEY = %VD_BASE# + 36;
        50  %EQU T_SPEC = %VD_BASE# + 37;
        51  %EQU T_DATA = %VD_BASE# + 38;
        52  %EQU T_KEY_INCR = %VD_BASE# + 39;
        53  %EQU T_SELECT_CLAUSE = %VD_BASE# + 40;
        54  %EQU T_REPEAT = %VD_BASE# + 41;
        55  %EQU T_THRU = %VD_BASE# + 42;
        56  %EQU T_ADJUST = %VD_BASE# + 43;
        57  %EQU T_AND = %VD_BASE# + 44;
        58  %EQU T_OR = %VD_BASE# + 45;
        59  %EQU T_OPTIONAL = %VD_BASE# + 46;
        60  %EQU T_NOT = %VD_BASE# + 47;
        61  %EQU T_MOVEMENT = %VD_BASE# + 48;
        62  %EQU T_FIND = %VD_BASE# + 49;
        63  %EQU T_MATCH = %VD_BASE# + 50;
        64  %EQU T_SKIP = %VD_BASE# + 51;
        65  %EQU T_FORWARD = %VD_BASE# + 52;
        66  %EQU T_BACKWARD = %VD_BASE# + 53;
        67  %EQU T_BO = %VD_BASE# + 54;
        68  %EQU T_AO = %VD_BASE# + 55;
        69  %EQU T_EO = %VD_BASE# + 56;
        70  %EQU T_NEXT = %VD_BASE# + 57;
        71  %EQU T_PREVIOUS = %VD_BASE# + 58;
        72  %EQU T_FILE_FID = %VD_BASE# + 59;
        73  %EQU T_NEW = %VD_BASE# + 60;
        74  %EQU T_OLD = %VD_BASE# + 61;

 11:05 NOV 14 '97 VD_NODES0_E                              VD_NODES0_E           Page 169
        75  %EQU T_ANY = %VD_BASE# + 62;
        76  %EQU T_LO_NAME = %VD_BASE# + 63;
        77  %EQU T_NUMERIC_KEY = %VD_BASE# + 64;
        78  %EQU T_STRING_KEY = %VD_BASE# + 65;
        79  %EQU T_PATTERN = %VD_BASE# + 66;
        80  %EQU T_POSITIONS = %VD_BASE# + 67;
        81  %EQU T_LEVEL_NAME = %VD_BASE# + 68;
        82  %EQU T_KEY_NAME = %VD_BASE# + 69;
        83  %EQU T_STRING_EXPR = %VD_BASE# + 70;
        84  %EQU T_FN_CMDVAR = %VD_BASE# + 71;
        85  %EQU T_DEF_NAME = %VD_BASE# + 72;
        86  %EQU T_INTEGER = %VD_BASE# + 73;
        87  %EQU T_FRACT = %VD_BASE# + 74;
        88  %EQU T_IN_WINDOW = %VD_BASE# + 75;
        89  %EQU T_COMMAND_WINDOW = %VD_BASE# + 76;
        90  %EQU T_EDITING_WINDOW = %VD_BASE# + 77;
        91  %EQU T_SPECIFIC_WINDOW = %VD_BASE# + 78;
        92  %EQU T_SETUP = %VD_BASE# + 79;
        93  %EQU T_SESSION = %VD_BASE# + 80;
        94  %EQU T_INVOK_CMD = %VD_BASE# + 81;
        95  %EQU T_FUNKEY_EXP = %VD_BASE# + 82;
        96  %EQU T_CNTL_EXP = %VD_BASE# + 83;
        97  %EQU MX_TOKEN  = 99;

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 170
         1  /*M* VD_PERR_C - Error code definitions for 6Edit */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /*X* MCR=NO, DMC=YES */
         9  /*T*/
        10
        11  /*
        12  *   6Edit errors fall into the following categories:
        13  *       E$CANT_do_action
        14  *           When user tried something we don't let him/her do
        15  *       E$thing_NOT_attribute
        16  *           When something doesn't meet some criteria for legality
        17  *       E$NO_thing
        18  *           When something is missing which is required
        19  *       E$TOO_MANY_thing
        20  *           When the user has given too many of something
        21  *       E$thing_CONFLICTS_W_thing
        22  *           Two things conflict with each other.
        23  *       E$external_routine_FAILED
        24  *           When a library or monitor service fails
        25  *       E$WARN_condition or _action
        26  *       E$INFO_condition or _action
        27  *           For warnings and informational messages
        28  *   These categories not only imply a form for the name of the error,
        29  *       they also imply a form for the error message at each level.
        30  *       These consistent forms for error messages are designed to:
        31  *           o Minimize the panic factor.
        32  *               Instead of:         Use:
        33  *               -----------------   ----------------------------
        34  *               Bad xxx             Unrecognized xxx
        35  *               Invalid xxx         Unrecognized xxx
        36  *               Illegal xxx         6Edit doesn't support xxx
        37  *

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 171
        38  *           o Avoid blaming; that is, emphasize that 6Edit doesn't
        39  *               support something, not that the user shouldn't have
        40  *               done something.
        41  *               Instead of:         Use:
        42  *               -----------------   ----------------------------
        43  *               You can't xxx       6Edit can't xxx
        44  *
        45  *           o Emphasize and identify clearly the important items in
        46  *               the message.  Important words are placed at the beginning
        47  *               of the first-level message, even at the expense of
        48  *               proper English grammar (in first-level messages).
        49  *               Also, substitutions (%Us) are used generously,
        50  *               to clearly identify the thing we're
        51  *               referring to (this is particularly important when
        52  *               synonyms are used or several commands are combined
        53  *               on one command line).
        54  *           o Present consistent levels of information.
        55  *               Level 0 (MESSAGE:) --  Should be short, no more than
        56  *                       40 characters -- for two reasons:  fast reading,
        57  *                       'cause we're just gently reminding the user
        58  *                       about something s/he already knows but forgot
        59  *                       momentarily; and in consideration of slow
        60  *                       line speeds.  Need not be proper English.
        61  *                       VERY important that the most
        62  *                       significant item of information be the first
        63  *                       words of the message.
        64  *
        65  *               Level 1 message (MESSAGE1:) -- The message at this
        66  *                       level should explain the condition fully in
        67  *                       clear and proper English.  If the message says
        68  *                       that 6Edit doesn't recognize something the user
        69  *                       typed or doesn't support something the user
        70  *                       requested, this message should LIST THE LEGAL
        71  *                       ALTERNATIVES!!
        72  *
        73  *
        74  *   The general forms for messages in the categories are:

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 172
        75  *   E$CANT_do_action:
        76  *       MESSAGE: action% %Un% can't be done.
        77  *       MESSAGE1: 6Edit can't do action% %Un% now, or can only do it
        78  *                when certain conditions are met.
        79  *
        80  *   E$thing_NOT_attribute
        81  *       MESSAGE: thing% %Un% must be attribute.
        82  *       MESSAGE1: thing% %Un% must be one of the following: ...
        83  *
        84  *   E$NO_thing
        85  *       MESSAGE: No thing% %Un% available.
        86  *       MESSAGE1: thing% %Un% must be available in order to ...
        87  *
        88  *   E$TOO_MANY_thing
        89  *       MESSAGE: Too many thing% %Un%.
        90  *       MESSAGE1: No more than %Un things% %Un% may be given to 6Edit.
        91  *
        92  *   E$thing_CONFLICTS_W_thing
        93  *       MESSAGE: thing% %Un% conflicts with thing% %Un%.
        94  *       MESSAGE1: thing% %Un% may not conflict with thing% %Un%.
        95  *                (describe how they must agree.)
        96  *
        97  *   E$external_routine_FAILED
        98  *       MESSAGE: Internal error (external_routine).
        99  *
       100  *   E$WARN_condition or _action
       101  *   E$INFO_condition or _action
       102  *       MESSAGE: condition present.     OR  action occurred.
       103  *       MESSAGE1: (fuller explanation of condition or action.)
       104  */
       105
       106
       107  /************************************************************
       108  *                                                           *
       109  *                  General Errors (VDG$)                    *
       110  *                    Error codes 1 - 49                     *
       111  *                                                           *

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 173
       112  *************************************************************/
       113
       114  %EQU E$HUH = 1;
       115  /*E* ERROR:  VDG-E$HUH-0
       116      MESSAGE: Internal error.%  (%U1)%% (%U2)%% (%U3)%
       117  */
       118
       119  %EQU E$ALLOCATE_FAILED = 2;
       120  /*E* ERROR:  VDG-E$ALLOCATE_FAILED-0
       121      MESSAGE: Internal error.  (allocate)
       122  */
       123
       124  %EQU E$DEALLOCATE_FAILED = 3;
       125  /*E* ERROR:  VDG-E$DEALLOCATE_FAILED-0
       126      MESSAGE: Internal error.  (deallocate)
       127  */
       128
       129  %EQU E$CANT_SCREEN_EDIT = 4;
       130  /*E* ERROR:  VDG-E$CANT_SCREEN_EDIT-0
       131      MESSAGE: Screen editing suspended - the window went away.
       132      MESSAGE1: 6edit is in serial mode because ASAVE or SAVE/GET closed the DCB.
       133                Set $COMMAND EQ OFF when you are sure of the profile and IMPs.
       134  */
       135
       136  %EQU E$INFO_BANNER = 5;
       137  /*E* ERROR:  VDG-E$INFO_BANNER-0
       138      MESSAGE: 6Edit% %U1% Here.
       139  */
       140
       141  %EQU E$INVOK_NOT_RECOGNIZED = 6;
       142  /*E* ERROR:  VDG-E$INVOK_NOT_RECOGNIZED-0
       143      MESSAGE: Invocation not recognized%: %U1%
       144      MESSAGE1: To run 6Edit, type:    6EDIT fid ( commands )
       145                where "fid" is the file to edit, and "commands" is an optional list of 6Edit
       146                commands to execute initially.%  You typed: %U1%
       147  */
       148

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 174
       149  %EQU E$BREAK_HIT = 7;
       150  /*E* ERROR:  VDG-E$BREAK_HIT-0
       151      MESSAGE: Break:  processing stopped.
       152      MESSAGE1: In response to the BREAK key, processing of the command has been stopped.
       153  */
       154
       155  %EQU E$BAD_WS_FILE = 8;                      /* thing NOT attr */
       156  /*E* ERROR:  VDG-E$BAD_WS_FILE-0
       157      MESSAGE: Workspace file% %UF% is invalid% (record code %U1)%.
       158  */
       159
       160  %EQU E$CANT_GENERATE_KEY = 9;
       161  /*E* ERROR:  VDG-E$CANT_GENERATE_KEY-0
       162      MESSAGE: Can't insert record.
       163      MESSAGE1: No room for new record between two existing records.  Some records must be
       164                rekeyed.
       165  */
       166
       167  %EQU E$INFO_NONE = 10;  /* 1Dim Presenter found no rec to reread */
       168  /*E* ERROR:  VDG-E$INFO_NONE-0
       169      MESSAGE: None.
       170      MESSAGE1: The requested block was not found.
       171  */
       172
       173  %EQU E$INFO_READING = 11;
       174  /*E* ERROR:  VDG-E$INFO_READING-0
       175      MESSAGE: Reading% %UF%.
       176  */
       177
       178  %EQU E$SETUP_6EDIT_NOT_FID = 12;
       179  /*E* ERROR:  VDG-E$SETUP_6EDIT_NOT_FID-0
       180      MESSAGE: Value of SETUP_6EDIT doesn't look like a fid%: "%U1"%.
       181      MESSAGE1: The value %(%U1) %assigned to the command variable
       182                SETUP_6EDIT must be a fid, optionally with ">P" and/or ">U" in the
       183                file name portion.
       184  */
       185

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 175
       186  %EQU E$CANT_DO_IBEX_XEQ = 13;
       187  /*E* ERROR:  VDG-E$CANT_DO_IBEX_XEQ-0
       188      MESSAGE: Can't $RESTORE an XEQ command when not first processor.
       189               Command ignored%: "%U1"%.
       190      MESSAGE1: The value assigned to the $RESTORE predefined name is an XEQ
       191                command% (%U1)%,  but 6Edit was called from a processor,
       192                not from IBEX.  The XEQ command is being ignored, because it would
       193                most likely cause the calling processor to exit.
       194  */
       195
       196  %EQU E$WARN_SAVED_W_DIFF_PROFILE = 14;
       197  /*E* ERROR:  VDG-E$WARN_SAVED_W_DIFF_PROFILE-0
       198      MESSAGE: Keyins were saved with profile %U1; current profile is %U2.
       199               Continuing.
       200  */
       201
       202
       203  /************************************************************
       204  *                                                           *
       205  *            Lexical and Parsing Errors (VDI$P)             *
       206  *                    Error codes 50 - 99                    *
       207  *                                                           *
       208  *************************************************************/
       209
       210  %EQU E$SYND_RECORD_TOO_LONG = 50;
       211  /*E* ERROR:  VDG-E$SYND_RECORD_TOO_LONG-0
       212      MESSAGE: Command record too long after synonym substitution.
       213      MESSAGE1: 300 characters is the maximum length of a single command record.  After
       214                substituting synonym values into the command record, it is longer than 300
       215                characters.
       216  */
       217
       218  %EQU E$WI_KEY_NOT_IN_RANGE = 51;
       219  /*E* ERROR:  VDG-E$WI_KEY_NOT_IN_RANGE-0
       220      MESSAGE: Window number must be nonzero and not more than %U1.
       221      MESSAGE1: You used %U2 as a window number, but zero is the command
       222                window, and you have only %U1 editing window(s).

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 176
       223  */
       224
       225  %EQU E$NO_CTRLFN_LEFT_PAREN = 53;
       226  /*E* ERROR:  VDG-E$NO_CTRLFN_LEFT_PAREN-0
       227      MESSAGE: No left parenthesis found in $CONTROL-function.
       228      MESSAGE1: The $CONTROL-Value and -Wild Character functions
       229                must be immediately following by parameter(s) enclosed in parentheses.
       230  */
       231
       232  %EQU E$NO_CTRLFN_RIGHT_PAREN = 54;
       233  /*E* ERROR:  VDG-E$NO_CTRLFN_RIGHT_PAREN-0
       234      MESSAGE: No right parenthesis found in $CONTROL-function.
       235      MESSAGE1: The parameter list following a $CONTROL function needs a right parenthesis.
       236  */
       237
       238  %EQU E$CTRLFN_NUM_PARAM_NOT_LEGAL = 55;
       239  /*E* ERROR:  VDG-E$CTRLFN_NUM_PARAM_NOT_LEGAL-0
       240      MESSAGE: Parameter for $CONTROL function must be a decimal number.
       241      MESSAGE1: A parameter for a $CONTROL function is too long or contains non-digit
       242                characters.  The parameter must be a decimal number, containing
       243                only the digits 0 through 9, up to 64 characters in length.
       244  */
       245
       246  %EQU E$CTRLFN_NUM_PARAM_NOT_INRANGE = 56;
       247  /*E* ERROR:  VDG-E$CTRLFN_NUM_PARAM_NOT_INRANGE-0
       248      MESSAGE: Parameter for $CONTROL function must be between %U1 and %U2.
       249      MESSAGE1: A parameter for a $CONTROL function is too large or too small.
       250               The minimum value is %U1; the maximum value is %U2.
       251  */
       252
       253  %EQU E$CTRLFN_ID_NOT_LEGAL = 57;
       254  /*E* ERROR:  VDG-E$CTRLFN_ID_NOT_LEGAL-0
       255      MESSAGE: $CONTROL-function identifier not recognized.
       256      MESSAGE1: $CONTROL-function identifiers are: V, R, ?, W, B, E, and the $CONTROL
       257                string itself.
       258  */
       259

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 177
       260  %EQU E$UNBAL_STRING = 58;                    /* thing NOT attr */
       261  /*E* ERROR:  VDG-E$UNBAL_STRING-0
       262      MESSAGE: Literal string doesn't have an ending delimiter.
       263      MESSAGE1: While searching for SYNONYM substititions, 6EDIT found an
       264                unterminated quote-string in your command line.
       265  */
       266
       267  %EQU E$DECIMAL_NOT_LEGAL = 59;
       268  /*E* ERROR:  VDG-E$DECIMAL_NOT_LEGAL-0
       269      MESSAGE: Number %("%U1") %may contain only digits.
       270      MESSAGE1: A number%, unlike %U1,% contains only the digits 0 through 9.
       271  */
       272
       273  %EQU E$CONSEC_KEY_FRACT_NOT_LEGAL = 60;
       274  /*E* ERROR:  VDG-E$CONSEC_KEY_FRACT_NOT_LEGAL-0
       275      MESSAGE: Key for consecutive file must be an integer.
       276      MESSAGE1: Record keys for consecutive files must be whole integers.
       277                The key you specified% ("%U1")% contains a fractional part.
       278  */
       279
       280  %EQU E$EDITKEY_FRACT_NOT_LEGAL = 61;
       281  /*E* ERROR:  VDG-E$EDITKEY_FRACT_NOT_LEGAL-0
       282      MESSAGE: Only 3 digits allowed in fraction of a record key.
       283      MESSAGE1: The fractional part of a record key is limited to 3 digits.
       284                The key you specified %(%U1)% contained more.
       285  */
       286
       287  %EQU E$NUMKEY_INTEGER_NOT_LEGAL = 62;
       288  /*E* ERROR:  VDG-E$NUMKEY_INTEGER_NOT_LEGAL-0
       289      MESSAGE: Only 5 digits allowed in integer part of a record key.
       290      MESSAGE1: The integer part of a numeric record key cannot exceed 99999.
       291                The integer for your key %(%U1)% is too large.
       292  */
       293  /*N* Someday NUMKEY_INTEGER_NOT_LEGAL's legal-limit should be
       294  *N*     changed to %MX_CONSEC_RECORDS.
       295  */
       296

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 178
       297  %EQU E$TOO_MANY_CTRLFN_VALUE_PARAMS = 63;
       298  /*E* ERROR:  VDG-E$TOO_MANY_CTRLFN_VALUE_PARAMS-0
       299      MESSAGE: $CONTROL-Value function must have 1 or perhaps 2 parameters.
       300      MESSAGE1: The $CONTROL-Value function may have 2 parameters when it is used in
       301                a pattern string; otherwise, it must have exactly one parameter.
       302  */
       303
       304  %EQU E$TOO_MANY_CTRLFN_WILDC_PARAMS = 64;
       305  /*E* ERROR:  VDG-E$TOO_MANY_CTRLFN_WILDC_PARAMS-0
       306      MESSAGE: $CONTROL-Wild Character function must have 1 or 2 parameters.
       307      MESSAGE1: The $CONTROL-Wild Character function can have up to two parameters
       308                in pattern strings, but only one in literal strings.
       309  */
       310
       311  %EQU E$CTRLFN_BOM_CONFLICTS_W_LIT = 65;
       312  /*E* ERROR:  VDG-E$CTRLFN_BOM_CONFLICTS_W_LIT-0
       313      MESSAGE: $CONTROL-BO Match function can't be used in a string.
       314      MESSAGE1: The $CONTROL-BO Match function can only be used in pattern strings.
       315  */
       316
       317  %EQU E$CTRLFN_CURR_CONFLICTS_W_LIT = 66;
       318  /*E* ERROR:  VDG-E$CTRLFN_CURR_CONFLICTS_W_LIT-0
       319      MESSAGE: $CONTROL-Current function can't be used in a string.
       320      MESSAGE1: The $CONTROL-Current function can only be used in pattern strings.
       321  */
       322
       323  %EQU E$TOO_MANY_WILD_STRINGS = 67;
       324  /*E* ERROR:  VDG-E$TOO_MANY_WILD_STRINGS-0
       325      MESSAGE: Only %U1 $CONTROL-Wild-Characters and -Wild-Strings in a literal.
       326      MESSAGE1: The $CONTROL-Wild Character and $CONTROL-Wild String functions
       327                can be used a total of only %U1 times in a single literal string.
       328  */
       329
       330  %EQU E$CTRLFN_WILDS_CONFLICTS_W_LIT = 68;
       331  /*E* ERROR:  VDG-E$CTRLFN_WILDS_CONFLICTS_W_LIT-0
       332      MESSAGE: $CONTROL-Wild String function can't be used in a string.
       333      MESSAGE1: The $CONTROL-Wild String function can only be used in pattern strings.

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 179
       334  */
       335
       336  %EQU E$CTRLFN_EOM_CONFLICTS_W_LIT = 69;
       337  /*E* ERROR:  VDG-E$CTRLFN_EOM_CONFLICTS_W_LIT-0
       338      MESSAGE: $CONTROL-EO Match function can't be used in a string.
       339      MESSAGE1: The $CONTROL-EO Match function can only be used in pattern strings.
       340  */
       341
       342  %EQU E$WARN_STOPPING_READ_FILE = 70;
       343  /*E* ERROR:  VDG-E$WARN_STOPPING_READ_FILE-0
       344      MESSAGE: Stopping READ-file% %U1%% at record %U2%.
       345  */
       346
       347  %EQU E$WARN_COMMANDS_IGNORED = 71;
       348  /*E* ERROR:  VDG-E$WARN_COMMANDS_IGNORED-0
       349      MESSAGE: Command(s) ignored%:  %U1%
       350  */
       351
       352  %EQU E$NO_MORE_COMMANDS = 72;
       353  /*E* ERROR:  VDG-E$NO_MORE_COMMANDS-0
       354      MESSAGE: EOF in command stream.
       355  */
       356
       357  %EQU E$CTRLFN_CURR_CONFLICTS_W_MID = 73;
       358  /*E* ERROR:  VDG-E$CTRLFN_CURR_CONFLICTS_W_MID-0
       359      MESSAGE: $CONTROL-Current function can't be used in middle of a pattern string.
       360      MESSAGE1: The $CONTROL-Current function can only appear as the first item or the
       361                last item in a pattern string.
       362  */
       363
       364  %EQU E$INFO_READ_FILE_AT = 74;
       365  /*E* ERROR:  VDG-E$INFO_READ_FILE_AT-0
       366      MESSAGE: Error occurred at record %U1 in READ-file %UF.
       367  */
       368
       369  %EQU E$PARSE_FAILED = 75;
       370  /*E* ERROR:  VDG-E$PARSE_FAILED-0

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 180
       371      MESSAGE: Internal error.  (Parse)
       372  */
       373
       374  %EQU E$CTRLFN_BOM_NOT_BEFORE_EOM = 76;
       375  /*E* ERROR:  VDG-E$CTRLFN_BOM_NOT_BEFORE_EOM-0
       376      MESSAGE: $CONTROL-BO Match function can't follow $CONTROL-EO Match function.
       377      MESSAGE1: In a pattern string, $CONTROL-BO Match functions may only appear before
       378                the first $CONTROL-EO Match function.
       379  */
       380
       381  %EQU E$CTRLFN_CONFLICTS_W_KEYIN = 77;
       382  /*E* ERROR:  VDG-E$CTRLFN_CONFLICTS_W_KEYIN-0
       383      MESSAGE: Most $CONTROL functions are invalid in KEYIN name or value strings.
       384      MESSAGE1: $CONTROL functions other than $CONTROL-value(n)
       385                can only be used in pattern strings and STRING strings.
       386  */
       387
       388  %EQU E$KEY_OPTIONS_NOT_LEGAL = 78;
       389  /*E* ERROR:  VDG-E$KEY_OPTIONS_NOT_LEGAL-0
       390      MESSAGE: Can't use SKIP, FORWARD, or BACKWARD on a record key.
       391      MESSAGE1: Can't modify a record key operand with SKIP, FORWARD, or BACKWARD options.
       392  */
       393
       394  %EQU E$LO_NAME_OPTIONS_NOT_LEGAL = 79;
       395  /*E* ERROR:  VDG-E$LO_NAME_OPTIONS_NOT_LEGAL-0
       396      MESSAGE: Can't use SKIP, FORWARD, or BACKWARD on a LOCATION-name.
       397      MESSAGE1: Can't modify a LOCATION-name with the SKIP, FORWARD, or BACKWARD options.
       398  */
       399
       400  %EQU E$STRING_NOT_ONLY_OPAND = 80;
       401  /*E* ERROR:  VDG-E$STRING_NOT_ONLY_OPAND-0
       402      MESSAGE: A string must be the only operand in a block expression.
       403  */
       404
       405  %EQU E$TOO_MANY_SKIPS = 81;
       406  /*E* ERROR:  VDG-E$TOO_MANY_SKIPS-0
       407      MESSAGE: Too many SKIP options.

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 181
       408      MESSAGE1: 6Edit supports only one SKIP option for each operand.
       409  */
       410
       411  %EQU E$SKIP_COUNT_NOT_IN_RANGE = 82;
       412  /*E* ERROR:  VDG-E$SKIP_COUNT_NOT_IN_RANGE-0
       413      MESSAGE: SKIP count too large or too small.
       414      MESSAGE1: SKIP count must be between 0 and 131071 (inclusive).
       415  */
       416
       417  %EQU E$POSITION_VALUE_NOT_IN_RANGE = 83;
       418  /*E* ERROR:  VDG-E$POSITION_VALUE_NOT_IN_RANGE-0
       419      MESSAGE: POSITION value too large or too small.
       420      MESSAGE1: POSITION value must be between 1 and 2048 (inclusive).
       421  */
       422
       423  %EQU E$TOO_MANY_DIRECTIONS = 84;
       424  /*E* ERROR:  VDG-E$TOO_MANY_DIRECTIONS-0
       425      MESSAGE: Too many FORWARD or BACKWARD options.
       426      MESSAGE1: 6Edit supports only one FORWARD or BACKWARD option for each operand.
       427  */
       428
       429  %EQU E$TOO_MANY_POINTS = 85;
       430  /*E* ERROR:  VDG-E$TOO_MANY_POINTS-0
       431      MESSAGE: Too many ALL OF, BEGINNING OF, or END OF options.
       432      MESSAGE1: 6Edit supports only one ALL OF, BEGINNING OF, or END OF option for each
       433                operand.
       434  */
       435
       436  %EQU E$TOO_MANY_PROC_OPTS = 86;
       437  /*E* ERROR:  VDG-E$TOO_MANY_PROC_OPTS-0
       438      MESSAGE: Too many PROTECT options.
       439      MESSAGE1: 6Edit supports only one PROTECT option for each operand.
       440  */
       441
       442  %EQU E$PROC_OPT_NOT_1ST = 87;
       443  /*E* ERROR:  VDG-E$PROC_OPT_NOT_1ST-0
       444      MESSAGE: PROTECT must be first option.

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 182
       445      MESSAGE1: The PROTECT option must be the first item in a block expression.
       446  */
       447
       448  %EQU E$DOMAIN_OPAND_NOT_1ST = 88;
       449  /*E* ERROR:  VDG-E$DOMAIN_OPAND_NOT_1ST-0
       450      MESSAGE: FILE or LOCATION-name must be first operand.
       451      MESSAGE1: A FILE or LOCATION-name reference must be the first operand in a block
       452                expression.  (A LOCATION-name may be used later in a block expression
       453                only when it refers to the same file as the rest of the expression.)
       454  */
       455
       456  %EQU E$REPEAT_COUNT_NOT_IN_RANGE = 89;
       457  /*E* ERROR:  VDG-E$REPEAT_COUNT_NOT_IN_RANGE-0
       458      MESSAGE: REPEAT count too large or too small.
       459      MESSAGE1: REPEAT count must be between 0 and 131171 (inclusive).
       460  */
       461
       462  %EQU E$CTRLFN_CONFLICTS_W_KEY = 90;
       463  /*E* ERROR:  VDG-E$CTRLFN_CONFLICTS_W_KEY-0
       464      MESSAGE: Most $CONTROL functions can't be used in a record key.
       465      MESSAGE1: $CONTROL functions other than $CONTROL-value(n)
       466                can only be used in pattern strings and STRING strings.
       467  */
       468
       469  %EQU E$KEYNAME_NOT_FIRST = 91;
       470  /*E* ERROR: VDG-E$KEYNAME_NOT_FIRST-0
       471      MESSAGE: The $KEY function must start a KEYIN name or EQUALS value.
       472      MESSAGE1: The FEP can only interpret function keys alone or as the
       473                first token in a sequence, so 6EDIT only allows you to use
       474                the $KEY function at the beginning of an expression, and
       475                then only if the expression represents a KEYIN name or
       476                an EQUALS value, presumably for later use as a KEYIN name.
       477  */
       478
       479  %EQU E$BAD_CTRLFN_IN_INITIALIZE = 92;
       480  /*E* ERROR:  VDG-E$BAD_CTRLFN_IN_INITIALIZE-0
       481      MESSAGE: Unusable $CONTROL function encountered in $INITIALIZE.

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 183
       482      MESSAGE1: $CONTROL functions other than -value(n), -literal,
       483                and -record cannot be used in $INITIALIZE.
       484  */
       485
       486  %EQU E$BAD_KEY_INCR = 93;
       487  /*E* ERROR: VDG-E$BAD_KEY_INCR-0
       488      MESSAGE: A key increment must not exceed 65.534.
       489  */
       490
       491  %EQU E$ELSE_CMD_WITHOUT_IF = 94;
       492  /*E* ERROR: VDG-E$ELSE_CMD_WITHOUT_IF-0
       493      MESSAGE: The ELSE command is only useful after an IF command.
       494      MESSAGE1: Each ELSE command must be preceded by a corresponding IF
       495                command, and both must be on the same command line.
       496  */
       497
       498  %EQU E$IF_CMD_IS_LAST = 95;
       499  /*E* ERROR: VDG-E$IF_CMD_IS_LAST-0
       500      MESSAGE: The IF command must not be last.
       501      MESSAGE1: The IF command must be followed by some commands on the same line.
       502  */
       503
       504  %EQU E$READ_2BIG = 96;
       505  /*E* ERROR: VDG-E$READ_2BIG-0
       506      MESSAGE: This continued command line with READ is too big to reparse.
       507      MESSAGE1: This continued command line has more commands after an imbedded
       508                READ command than will fit in the input buffer.  The line must
       509                be broken up into additional command lines.
       510  */
       511
       512
       513  /************************************************************
       514  *                                                           *
       515  *            Command Processing Errors (VDI$C)              *
       516  *                   Error codes 100 - 149                   *
       517  *                                                           *
       518  *************************************************************/

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 184
       519
       520  %EQU E$NO_RANGE_FOR_EDIT = 100;
       521  /*E* ERROR:  VDG-E$NO_RANGE_FOR_EDIT-0
       522      MESSAGE: No block for EDIT command.
       523      MESSAGE1: Evaluation of the block expression found no block to edit.
       524  */
       525
       526  %EQU E$INFO_SAVING_OVER = 101;
       527  /*E* ERROR:  VDG-E$INFO_SAVING_OVER-0
       528      MESSAGE: Saving over% %UF%.
       529  */
       530
       531  %EQU E$END_NOT_LAST_CMD = 102;
       532  /*E* ERROR:  VDG-E$END_NOT_LAST_CMD-0
       533      MESSAGE: END, XIT, or QUIT command must be last in command line.
       534      MESSAGE1: The END, XIT, or QUIT command must be the last command in the command line.
       535  */
       536
       537  %EQU E$INFO_PUSHED_OLD_EDIT_BLOCK = 103;
       538  /*E* ERROR:  VDG-E$INFO_PUSHED_OLD_EDIT_BLOCK-0
       539      MESSAGE: EDIT PREVIOUS will restore the Edit Block.
       540      MESSAGE1: You can restore the Edit Block with the following command:  EDIT PREVIOUS.
       541  */
       542
       543  %EQU E$NO_CURRENT_EDIT_BLOCK = 104;
       544  /*E* ERROR:  VDG-E$NO_CURRENT_EDIT_BLOCK-0
       545      MESSAGE: No CURRENT Edit Block.
       546      MESSAGE1: No CURRENT Edit Block.  Use the EDIT command to edit the data in a file.
       547  */
       548
       549  %EQU E$NO_EDIT_BLOCK = 105;
       550  /*E* ERROR:  VDG-E$NO_EDIT_BLOCK-0
       551      MESSAGE: No block open for editing.
       552      MESSAGE1: A block expression makes no sense unless or until
       553                the name of a file to edit has been explicitly specified.
       554  */
       555

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 185
       556  %EQU E$NAME_HAS_NO_VALUE = 106;                 /* thing NOT attr */
       557  /*E* ERROR:  VDG-E$NAME_HAS_NO_VALUE-0
       558      MESSAGE: Name %"%U1" %has no value currently.
       559      MESSAGE1: A %%U2-%name %("%U1") %was used in an expression,
       560                but it is currently undefined.
       561  */
       562
       563  %EQU E$ABS_SEL_NOT_1ST = 107;
       564  /*E* ERROR:  VDG-E$ABS_SEL_NOT_1ST-0
       565      MESSAGE: It makes no sense to start a block relatively and end it absolutely.
       566      MESSAGE1: When using relative and absolute SELECT clauses together,
       567                the absolute SELECT clause must be first.
       568  */
       569
       570  %EQU E$CANT_USE_THAT_NDT = 108;
       571  /*E* ERROR:  VDG-E$CANT_USE_THAT_NDT-0
       572      MESSAGE: Name %"%U1" %is a %U2-name.
       573      MESSAGE1: Name %"%U1" %is a %U2-name, and can't be used in a string
       574                expression; only Equals-names can be used in string expressions.
       575  */
       576
       577  %EQU E$CANT_SAVE = 109;
       578  /*E* ERROR:  VDG-E$CANT_SAVE-0
       579      MESSAGE: Can't save% %U1%.
       580      MESSAGE1: %%U1 %can't be saved in a 6Edit workspace file.
       581  */
       582
       583
       584  %EQU E$NO_PREV_EDIT_BLOCK = 119;
       585  /*E* ERROR:  VDG-E$NO_PREV_EDIT_BLOCK-0
       586      MESSAGE: No PREVIOUS Edit Block.
       587      MESSAGE1: PREVIOUS was given in a block expression, but there is no previous
       588                Edit Block.
       589  */
       590
       591  %EQU E$NO_NEXT_EDIT_BLOCK = 120;
       592  /*E* ERROR:  VDG-E$NO_NEXT_EDIT_BLOCK-0

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 186
       593      MESSAGE: No NEXT Edit Block.
       594      MESSAGE1: NEXT was given in a block expression, but there is no next Edit Block.
       595  */
       596
       597  %EQU E$EDIT_RPT_CNT_NOT_1 = 121;
       598  /*E* ERROR:  VDG-E$EDIT_RPT_CNT_NOT_1-0
       599      MESSAGE: A REPEATed block can't be EDITed.
       600      MESSAGE1: If an EDIT command uses the REPEAT option in its block expression, the
       601                REPEAT option will be ignored.  Only the first instance of the block
       602                will be EDITed.
       603  */
       604
       605  %EQU E$CANT_EDIT_SCRATCH = 122;
       606  /*E* ERROR:  VDG-E$CANT_EDIT_SCRATCH-0
       607      MESSAGE: STRING operand can't be edited.
       608      MESSAGE1: Only the COPY command can specify a STRING operand.
       609  */
       610
       611  %EQU E$CANT_EDIT_PARTIAL_RECS = 123;
       612  /*E* ERROR:  VDG-E$CANT_EDIT_PARTIAL_RECS-0
       613      MESSAGE: Partial records can't be EDITed.
       614      MESSAGE1: The block specified for an EDIT command must describe whole records;
       615                6Edit can't edit partial records.
       616  */
       617
       618  %EQU E$LOCATION_RPT_CNT_NOT_1 = 124;
       619  /*E* ERROR:  VDG-E$LOCATION_RPT_CNT_NOT_1-0
       620      MESSAGE: A REPEATed block can't be used in a LOCATION command.
       621      MESSAGE1: A LOCATION command can't use the REPEAT option in its block expression.
       622  */
       623
       624  %EQU E$NO_RANGE_FOR_LOCATION = 125;
       625  /*E* ERROR:  VDG-E$NO_RANGE_FOR_LOCATION-0
       626      MESSAGE: No block for LOCATION command.
       627      MESSAGE1: Evaluation of the block expression found no block to remember the
       628                location of.
       629  */

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 187
       630
       631  %EQU E$BAD_SY_NAME = 126;                    /* thing NOT attr */
       632  /*E* ERROR:  VDG-E$BAD_SY_NAME-0
       633      MESSAGE: Can't use that name as a synonym.
       634      MESSAGE1: A SYNONYM name must not begin with a digit, and must not contain the
       635                $CONTROL string or any of the following reserved characters:  ( ) . ; ?
       636  */
       637
       638  %EQU E$WARN_KEYIN_DISPLAYABLE = 127;
       639  /*E* ERROR:  VDG-E$WARN_KEYIN_DISPLAYABLE-0
       640      MESSAGE: Warning: Displayable character% "%U1"% being redefined with KEYIN command.
       641      MESSAGE1: The terminal key being redefined with the KEYIN command%, "%U1",%
       642                is a displayable character.  You may not be able to type that character
       643                anymore (until the KEYIN definition is deleted).
       644  */
       645
       646  %EQU E$SPEC_CANT_BE_INTRO = 128;             /* CONFLICTS_W */
       647  /*E* ERROR:  VDG-E$SPEC_CANT_BE_INTRO-0
       648      MESSAGE: Can't redefine $INTRO_1 or $INTRO_2 with KEYIN command.
       649      MESSAGE1: $INTRO_1 or $INTRO_2 can't work as an introducer if redefined,
       650                so such redefinitions are not allowed for the KEYIN command.
       651  */
       652
       653  %EQU E$BAD_KEYIN_NAME_INTRO = 129;        /* thing NOT attr */
       654  /*E* ERROR:  VDG-E$BAD_KEYIN_NAME_INTRO-0
       655      MESSAGE: First character(s) of KEYIN name must be $INTRO_1 or $INTRO_2.
       656      MESSAGE1: In a multi-character KEYIN name, all but the last character must match
       657                the current values of the names "$INTRO_1" or "$INTRO_2".
       658  */
       659
       660  %EQU E$BAD_KEYIN_NAME_LENGTH = 130;       /* thing NOT attr */
       661  /*E* ERROR:  VDG-E$BAD_KEYIN_NAME_LENGTH-0
       662      MESSAGE: KEYIN name is empty or too long.
       663      MESSAGE1: KEYIN names must be exactly one character long, or they must consist of
       664                one character following the current value of $INTRO_1 or $INTRO_2.
       665  */
       666

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 188
       667  %EQU E$BAD_KEYIN_VALUE_LENGTH = 131;      /* thing NOT attr */
       668  /*E* ERROR:  VDG-E$BAD_KEYIN_VALUE_LENGTH-0
       669      MESSAGE: Value of KEYIN command is too long.
       670      MESSAGE1: The value of a KEYIN command may not be longer than 255 characters.
       671  */
       672
       673  %EQU E$CANT_LOCATION_SCRATCH = 132;
       674  /*E* ERROR:  VDG-E$CANT_LOCATION_SCRATCH-0
       675      MESSAGE: Can't use a string operand in a LOCATION command.
       676      MESSAGE1: A LOCATION command can't specify a STRING operand.
       677  */
       678
       679  %EQU E$WARN_INTRO_DISPLAYABLE = 133;
       680  /*E* ERROR:  VDG-E$WARN_INTRO_DISPLAYABLE-0
       681      MESSAGE: Warning: Displayable character% "%U1"% being assigned as KEYIN introducer.
       682      MESSAGE1: The value %("%U1") %being assigned% to "%U2"% is displayable.
       683                If you use it in a later KEYIN comand, you may no longer be able
       684                to type that character (until the KEYIN definition is deleted).
       685  */
       686
       687  %EQU E$INFO_N_BLOCKS_COPIED = 134;
       688  /*E* ERROR:  VDG-E$INFO_N_BLOCKS_COPIED-0
       689      MESSAGE: %U1 blocks copied.
       690  */
       691
       692  %EQU E$INFO_N_BLOCKS_MOVED = 135;
       693  /*E* ERROR:  VDG-E$INFO_N_BLOCKS_MOVED-0
       694      MESSAGE: %U1 blocks moved.
       695  */
       696
       697  %EQU E$INFO_N_BLOCKS_DELETED = 136;
       698  /*E* ERROR:  VDG-E$INFO_N_BLOCKS_DELETED-0
       699      MESSAGE: %U1 blocks deleted.
       700  */
       701
       702  %EQU E$INFO_1_BLOCK_COPIED = 137;
       703  /*E* ERROR:  VDG-E$INFO_1_BLOCK_COPIED-0

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 189
       704      MESSAGE: 1 block copied.
       705  */
       706
       707  %EQU E$INFO_1_BLOCK_MOVED = 138;
       708  /*E* ERROR:  VDG-E$INFO_1_BLOCK_MOVED-0
       709      MESSAGE: 1 block moved.
       710  */
       711
       712  %EQU E$INFO_1_BLOCK_DELETED = 139;
       713  /*E* ERROR:  VDG-E$INFO_1_BLOCK_DELETED-0
       714      MESSAGE: 1 block deleted.
       715  */
       716
       717  %EQU E$INFO_FILE_DELETED = 140;
       718  /*E* ERROR:  VDG-E$INFO_FILE_DELETED-0
       719      MESSAGE: File %UF deleted.
       720  */
       721
       722
       723  /************************************************************
       724  *                                                           *
       725  *               Block Handling Errors (VDI$B)               *
       726  *                   Error codes 150 - 199                   *
       727  *                                                           *
       728  *************************************************************/
       729
       730  %EQU E$INFO_NDELRECS_SOURCE = 152;
       731  /*E* ERROR:  VDG-E$INFO_NDELRECS_SOURCE-0
       732      MESSAGE: %U1 record(s) deleted from the source block.
       733  */
       734
       735  %EQU E$INFO_NDELRECS_DEST = 153;
       736  /*E* ERROR:  VDG-E$INFO_NDELRECS_DEST-0
       737      MESSAGE: %U1 record(s) deleted from the destination block.
       738  */
       739
       740  %EQU E$CUTOFF = 154;                         /* thing NOT attr */

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 190
       741  /*E* ERROR:  VDG-E$CUTOFF-0
       742      MESSAGE: Not enough room for data from source block.
       743      MESSAGE1: In a COPY or MOVE operation, the destination block wasn't large enough to
       744                hold all data from the source block.
       745  */
       746
       747  %EQU E$INFO_LAST_RECORD_COPIED = 155;
       748  /*E* ERROR:  VDG-E$INFO_LAST_RECORD_COPIED-0
       749      MESSAGE: Last record copied/moved was %U1 -> %U2.
       750  */
       751
       752  %EQU E$INFO_DATA_IN_$LEFTOVER = 156;
       753  /*E* ERROR:  VDG-E$INFO_DATA_IN_$LEFTOVER-0
       754      MESSAGE: Partial record saved under name "$LEFTOVER".
       755      MESSAGE1: To retrieve the partial record, COPY $LEFTOVER to some location.
       756  */
       757
       758  %EQU E$NO_DEST_FOR_SOURCE = 157;
       759  /*E* ERROR:  VDG-E$NO_DEST_FOR_SOURCE-0
       760      MESSAGE: No destination block found for next source block.
       761      MESSAGE1: A source block was found after processing all% %U1% destination blocks;
       762                no more destination blocks could be found in the current Edit Block.
       763  */
       764
       765  %EQU E$NO_SOURCE_FOR_DEST = 158;
       766  /*E* ERROR:  VDG-E$NO_SOURCE_FOR_DEST-0
       767      MESSAGE: No source block found for next destination block.
       768      MESSAGE1: A destination block was found after processing all% %U1% source blocks;
       769                no more source blocks could be found in the current Edit Block.
       770  */
       771
       772  %EQU E$OVERLAP_BLOCK = 159;                  /* CONFLICTS_W */
       773  /*E* ERROR:  VDG-E$OVERLAP_BLOCK-0
       774      MESSAGE: Source and destination blocks overlap.
       775      MESSAGE1: In a copy/move operation, the source and destination blocks may not
       776                overlap.
       777  */

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 191
       778
       779  %EQU E$GENKEY_CONFLICTS_W_ORGKT = 160;
       780  /*E* ERROR:  VDG-E$GENKEY_CONFLICTS_W_ORGKT-0
       781      MESSAGE: Can't generate key for this file.
       782      MESSAGE1: 6Edit can only insert records into edit-keyed files.  The file you're
       783                editing either has some other organization or its keys are not numeric.
       784  */
       785
       786  %EQU E$INFO_DATA_IN_$NOT_COPIED = 161;
       787  /*E* ERROR:  VDG-E$INFO_DATA_IN_$NOT_COPIED-0
       788      MESSAGE: Part of source block saved under name "$NOT_COPIED".
       789      MESSAGE1: To retrieve the portion of the source block which wasn't copied,
       790                COPY $NOT_COPIED to some location.
       791  */
       792
       793  %EQU E$WARN_NO_SOURCE_OPERAND = 162;
       794  /*E* ERROR:  VDG-E$WARN_NO_SOURCE_OPERAND-0
       795      MESSAGE: No source block to copy or move.
       796      MESSAGE1: You gave an AFTER or OVER command, but you haven't yet specified the
       797                source block to copy/move.  You must give a COPY or MOVE command before
       798                an AFTER or OVER command.
       799  */
       800
       801
       802  /************************************************************
       803  *                                                           *
       804  *             Intree Evaluation Errors (VDE$I)              *
       805  *                   Error codes 200 - 249                   *
       806  *                                                           *
       807  *************************************************************/
       808
       809
       810  /************************************************************
       811  *                                                           *
       812  *                  Accessor Errors (VDA$)                   *
       813  *                   Error codes 250 - 299                   *
       814  *                                                           *

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 192
       815  *************************************************************/
       816
       817  %EQU E$INFO_BOB = 250;
       818  /*E* ERROR:  VDG-E$INFO_BOB-0
       819      MESSAGE: Beginning of Edit Block reached.
       820  */
       821
       822  %EQU E$INFO_EOB = 251;
       823  /*E* ERROR:  VDG-E$INFO_EOB-0
       824      MESSAGE: End of Edit Block reached.
       825  */
       826
       827  %EQU E$CANT_WRITE = 252;
       828  /*E* ERROR:  VDG-E$CANT_WRITE-0
       829      MESSAGE: Can't update file %UF; open for reading only.
       830      MESSAGE1: File %UF is open for reading only;
       831                6Edit can't write anything into the file.
       832  */
       833
       834  %EQU E$CANT_DELETE = 253;
       835  /*E* ERROR:  VDG-E$CANT_DELETE-0
       836      MESSAGE: Can't delete data from file %UF; open for reading only.
       837      MESSAGE1: File %UF is open for reading only;
       838                6Edit can't delete data from the file.
       839  */
       840
       841  %EQU E$CANT_DELETE_ACROSS_NODES = 254;
       842  /*E* ERROR:  VDG-E$CANT_DELETE_ACROSS_NODES-0
       843      MESSAGE: Can't delete nodes from more than one parent.
       844      MESSAGE1: 6Edit can't delete nodes with different parents; for example, 6Edit can't
       845                delete records from two different files.
       846  */
       847
       848  %EQU E$CANT_ACCESS_NODE = 255;
       849  /*E* ERROR:  VDG-E$CANT_ACCESS_NODE-0
       850      MESSAGE: Key% %U1% is reserved for internal use.
       851      MESSAGE1: Certain predefined names are used by 6Edit developers to

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 193
       852                facilitate maintenance of the editor.  They are not otherwise
       853                useful or even visible, except when you try to change one.
       854  */
       855
       856  %EQU E$CANT_WRITE_NODE = 256;
       857  /*E* ERROR:  VDG-E$CANT_WRITE_NODE-0
       858      MESSAGE: Can't change record% with key %U1%.
       859      MESSAGE1: Some predefined names% (e.g., %U1)% have their values assigned
       860                automatically by 6Edit in response to editing activities, or have
       861                constant values.  They are not assignable directly.
       862  */
       863
       864  %EQU E$CANT_DELETE_NODE = 257;
       865  /*E* ERROR:  VDG-E$CANT_DELETE_NODE-0
       866      MESSAGE: Can't delete record% with key %U1%.
       867      MESSAGE1: The predefined name definitions% (e.g., %U1)% cannot be deleted.
       868  */
       869
       870  %EQU E$FILE_NOT_FILLED = 258;
       871  /*E* ERROR:  VDG-E$FILE_NOT_FILLED-0
       872      MESSAGE: File% %U1% isn't filled% to level %U2%.
       873      MESSAGE1: A write was attempted at level %U2 to file% %U1%, but
       874                the file isn't filled down to that level.  6Edit can't write the node.
       875  */
       876
       877  %EQU E$BAD_TYPE_FOR_NAME = 259;              /* thing NOT attr */
       878  /*E* ERROR:  VDG-E$BAD_TYPE_FOR_NAME-0
       879      MESSAGE: Name% %U1% needs %U2-value.
       880      MESSAGE1: You must use a %U2 command to assign a value to name% %U1%.
       881  */
       882
       883  %EQU E$BAD_NUMBER_FOR_NAME = 260;            /* thing NOT attr */
       884  /*E* ERROR:  VDG-E$BAD_NUMBER_FOR_NAME-0
       885      MESSAGE: Value for name% "%U1"% must be a number between %U2 and %U3.
       886      MESSAGE1: Value for name% "%U1"% is too small or too large.
       887                The minimum value is %U2; the maximum is %U3.
       888  */

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 194
       889
       890  %EQU E$BAD_NAME_VALUE_LENGTH = 261;          /* thing NOT attr */
       891  /*E* ERROR:  VDG-E$BAD_NAME_VALUE_LENGTH-0
       892      MESSAGE: Value for name% "%U1"% must contain between %U2 and %U3 characters.
       893      MESSAGE1: Value for name% "%U1"% is too long or too short.
       894                The minimum length is %U2 characters; the maximum is %U3.
       895  */
       896
       897  %EQU E$BAD_FILE_STCLASS_FOR_NAME = 262;      /* thing NOT attr */
       898  /*E* ERROR:  VDG-E$BAD_FILE_STCLASS_FOR_NAME-0
       899      MESSAGE: Value for name% %U1% must be a file storage class.
       900      MESSAGE1: Value for% %U1% must be a file storage class character.
       901               Legal values are '"' (quotation mark), '*' (asterisk), and ':' (colon).
       902  */
       903
       904  %EQU E$CONTROL_CONFLICTS_W_COMMENT = 263;
       905  /*E* ERROR:  VDG-E$CONTROL_CONFLICTS_W_COMMENT-0
       906      MESSAGE: Value for name $CONTROL conflicts with value for name $COMMENT.
       907      MESSAGE1: The value for name $CONTROL cannot contain the current value of name
       908              $COMMENT as a substring.
       909  */
       910
       911  %EQU E$COMMENT_CONFLICTS_W_CONTROL = 264;
       912  /*E* ERROR:  VDG-E$COMMENT_CONFLICTS_W_CONTROL-0
       913      MESSAGE: Value for name $COMMENT conflicts with value for name $CONTROL.
       914      MESSAGE1: The value for name $COMMENT cannot contain the current value of name
       915              $CONTROL as a substring.
       916  */
       917
       918  %EQU E$IMP_INTROS_EQUAL = 265;               /* CONFLICTS_W */
       919  /*E* ERROR:  VDG-E$IMP_INTROS_EQUAL-0
       920      MESSAGE: Names $INTRO_1 and $INTRO_2 may not have the same value.
       921      MESSAGE1: It makes no sense to have the same value for both $INTRO_1
       922                and $INTRO_2, so 6Edit doesn't allow that condition.
       923  */
       924
       925  %EQU E$CANT_INSERT_DELETE_RECORDS = 266;

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 195
       926  /*E* ERROR:  VDG-E$CANT_INSERT_DELETE_RECORDS-0
       927      MESSAGE: Can't insert or delete records in file% %UF%.
       928      MESSAGE1: File% %UF% is a consecutive or unit record file.
       929                You can change records in the file, but you can't change their lengths,
       930                and you can't add or remove records, except at the end of the file.
       931  */
       932
       933  %EQU E$WARN_MIN_CANT_BE_GRTR_MAX = 267;
       934  /*E* ERROR:  VDG-E$WARN_MIN_CANT_BE_GRTR_MAX-0
       935      MESSAGE: %U1 can't be greater than $MAX%U2; continuing.
       936      MESSAGE1: The value of %U1 can't be set to a value greater than $MAX%U2.
       937                6Edit has adjusted the value and is continuing.
       938  */
       939
       940  %EQU E$WARN_MAX_CANT_BE_LESS_MIN = 268;
       941  /*E* ERROR:  VDG-E$WARN_MAX_CANT_BE_LESS_MIN-0
       942      MESSAGE: %U1 can't be less than $MIN%U2; continuing.
       943      MESSAGE1: The value of %U1 can't be set to a value less than $MIN%U2.
       944                6Edit has adjusted the value and is continuing.
       945  */
       946
       947  %EQU E$INFO_FOR_ALICE = 269;
       948  /*E* ERROR:  VDG-E$INFO_FOR_ALICE-0
       949      MESSAGE: !esuoH ssalg-gnikooL ot emocleW
       950  */
       951
       952  %EQU E$CANT_REKEY_FILE = 270;
       953  /*E* ERROR:  VDG-E$CANT_REKEY_FILE-0
       954      MESSAGE: Can't rekey file% %UF%.
       955      MESSAGE1: Can't rekey file %%UF %because it is PROTECTed,
       956                or because it doesn't have edit keys.
       957  */
       958
       959  %EQU E$COMM_CON_CANT_HAVE_RES_SPEC = 271;
       960  /*E* ERROR:  VDG-E$COMM_CON_CANT_HAVE_RES_SPEC-0
       961      MESSAGE: Can't assign the value "%U2" to name %U1.
       962      MESSAGE1: The value for name %U1 cannot contain any reserved special

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 196
       963                characters (which are  '  (  )  .  ;  ?), or numbers (0 through 9), or
       964                letters.
       965  */
       966
       967  %EQU E$PORT_BUSY = 272;
       968  /*E* ERROR:  VDG-E$PORT_BUSY-0
       969      MESSAGE: Internal error (port busy).
       970  */
       971
       972  %EQU E$NO_ROOM_FOR_BORDERS = 273;
       973  /*E* ERROR:  VDG-E$NO_ROOM_FOR_BORDERS-0
       974      MESSAGE: No room for window borders.
       975      MESSAGE1: There is no room on the terminal screen for borders around editing windows.
       976                $SCREEN minus $MIN_COMMAND is the number of lines available for the editing
       977                windows, and each editing window must get at least 1 line.  To make room for
       978                window borders, you must either decrease $MIN_COMMAND, or remove some editing
       979                windows (or increase $SCREEN if you aren't using your entire terminal screen).
       980  */
       981
       982  %EQU E$NO_ROOM_FOR_WINDOW = 274;
       983  /*E* ERROR:  VDG-E$NO_ROOM_FOR_WINDOW-0
       984      MESSAGE: No room for new editing window.
       985      MESSAGE1: There is no room on the terminal screen for another editing window.
       986                $SCREEN minus $MIN_COMMAND is the number of lines available for the editing
       987                windows, and each editing window must get at least 1 line, plus another line
       988                if $WI_BORDER is set.  To make room for a new editing window, you must either
       989                remove other editing windows, or decrease $MIN_COMMAND (or increase $SCREEN
       990                if you aren't using your entire terminal screen).
       991  */
       992
       993  %EQU E$VD_LD = 275;
       994  /*E* ERROR:  VDG-E$VD_LD-0
       995      MESSAGE: Data record too long to read% (key %U1)%.
       996      MESSAGE1: 6Edit can only read records up to 2048 bytes long.  A record
       997                %(key %U1) %in your file %%UF %exceeds that.
       998  */
       999

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 197
      1000  %EQU E$VD_CREATERR = 276;
      1001  /*E* ERROR:  VDG-E$VD_CREATERR-0
      1002      MESSAGE: File %UF exists; it is not NEW.
      1003      MESSAGE1: File %UF already exists;
      1004                6Edit can't access it with the NEW option.
      1005  */
      1006
      1007  %EQU E$CONSEC_KEY_TOO_BIG = 277;             /* thing NOT attr */
      1008  /*E* ERROR:  VDG-E$CONSEC_KEY_TOO_BIG-0
      1009      MESSAGE: Record number% %U1% too big for consecutive file.
      1010      MESSAGE1: Record number %%U1 %for consecutive file exceeds the maximum
      1011                supported (134217727).
      1012  */
      1013
      1014  %EQU E$FILE_ORG_NOT_ACCESSABLE = 278;
      1015  /*E* ERROR:  VDG-E$FILE_ORG_NOT_ACCESSABLE-0
      1016      MESSAGE: File %UF can't be accessed by 6Edit.
      1017      MESSAGE1: 6Edit can access only edit-keyed, consecutive, or unit record files;
      1018                file %UF isn't one of these, so 6Edit can't access it.
      1019  */
      1020
      1021  %EQU E$FILE_ASN_NOT_ACCESSABLE = 279;
      1022  /*E* ERROR:  VDG-E$FILE_ASN_NOT_ACCESSABLE-0
      1023      MESSAGE: Fid %"%U1" %can't be edited by 6Edit.
      1024      MESSAGE1: 6Edit can edit disk files only;  Your request
      1025                %"%U1" %isn't a disk file.
      1026  */
      1027
      1028  %EQU E$ORG_CONFLICT = 280;                   /* CONFLICTS_W */
      1029  /*E* ERROR:  VDG-E$ORG_CONFLICT-0
      1030      MESSAGE: File %UF isn't a %U1 file.
      1031      MESSAGE1: You tried to open %UF as a %U1 file, but it isn't one.
      1032  */
      1033
      1034  %EQU E$ORG_KEYTYPE_CONFLICT = 281;           /* CONFLICTS_W */
      1035  /*E* ERROR:  VDG-E$ORG_KEYTYPE_CONFLICT-0
      1036      MESSAGE: File %UF is a %U1 file; it's key type cannot be %U2.

 11:05 NOV 14 '97 VD_PERR_C                                VD_PERR_C             Page 198
      1037      MESSAGE1: You tried to access %UF with %U2 keys.
      1038                Since the file is %U1, that won't work.
      1039  */
      1040
      1041  %EQU E$PROTECT_CONFLICTS_W_NEW = 282;
      1042  /*E* ERROR:  VDG-E$PROTECT_CONFLICTS_W_NEW-0
      1043      MESSAGE: NEW file can't be PROTECTed.
      1044      MESSAGE1: A file accessed with the NEW option can't also be accessed with the
      1045                PROTECT option.
      1046  */
      1047
      1048  %EQU E$CANT_READ_FILE = 283;
      1049  /*E* ERROR:  VDG-E$CANT_READ_FILE-0
      1050      MESSAGE: Can't read file% %UF%.
      1051      MESSAGE1: The current edit block file%, %UF,%
      1052                doesn't allow read access to 6Edit.
      1053  */
      1054
      1055  %EQU E$CANT_WINDOW_THIS_NAME = 284;
      1056  /*E* ERROR:  VDG-E$CANT_WINDOW_THIS_NAME-0
      1057      MESSAGE: Can't use "IN window" for name% "%U1"%.
      1058      MESSAGE1: Name %"%U1" %can't have different values for each window; so
      1059                you can't use the IN clause in this assignment command.
      1060  */
      1061
      1062  %EQU E$VD_FILEBUSY = 285;
      1063  /*E* ERROR:  VDG-E$VD_FILEBUSY-0
      1064      MESSAGE: File %UF is busy for updating; opened for reading only.
      1065      MESSAGE1: File %UF is busy if opened for update, but not for reading.
      1066                6Edit opened it for reading; you can't change data in the file.
      1067  */
      1068  %EQU MX_ERROR_CODE = 299;

 11:05 NOV 14 '97 TABLE OF CONTENTS                        VD_PERR_C             Page 199
 $6EDIT_INSTALL..............................1     $6EDIT_INSTALL..............................1
 :6EDIT_CONTEXT..............................3     :6EDIT_CONTEXT..............................3
 :6EDIT_CONTEXT_DECVT100.....................5     :6EDIT_CONTEXT_DECVT100.....................5
 :6EDIT_CONTEXT_PCTV7800.....................8     :6EDIT_CONTEXT_PCTV7800.....................8
 :6EDIT_CONTEXT_PCTX364......................11    :6EDIT_CONTEXT_PCTX364......................11
 :6EDIT_CONTEXT_VIP7205......................14    :6EDIT_CONTEXT_VIP7205......................14
 :6EDIT_CONTEXT_VIP7303......................16    :6EDIT_CONTEXT_VIP7303......................16
 :6EDIT_CONTEXT_VIP7801......................18    :6EDIT_CONTEXT_VIP7801......................18
 :6EDIT_CONTEXT_ZENZ19.......................20    :6EDIT_CONTEXT_ZENZ19.......................20
 VDP_MACRO_C.................................22    VDP_MACRO_C.................................22
 VD_MACROS_M.................................25    VD_MACROS_M.................................25
 VD_NODES0_E.................................167   VD_NODES0_E.................................167
 VD_PERR_C...................................170   VD_PERR_C...................................170
