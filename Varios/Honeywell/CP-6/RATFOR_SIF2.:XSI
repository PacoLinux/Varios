C*T***********************************************************  
C*T*                                                         *  
C*T* Copyright (c) Bull HN Information Systems Inc., 1989    *  
C*T*                                                         *  
C*T***********************************************************  
      PROGRAM RATFOR
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       COMMON /ECOUNT/ NERRORS
      DATA NERRORS /0/
      LOGICAL LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      INTEGER OPEN
      INTEGER DEFNS(1)
      DATA DEFNS(1)/-2/
      CALL INITST
      IF (DEFNS (1) .NE. -2) THEN
         INFILE (1) = OPEN (DEFNS, 1)
         IF (INFILE (1) .EQ. -3) THEN
            CALL REMARK (37Hcan't open standard definitions file.)
         ELSE 
            CALL PARSE
            CALL CLOSE (INFILE (1))
         ENDIF 
      ENDIF 
      CALL STARTUP
      CALL INITKW
      INFILE (1) = 1
      CALL PARSE
      IF (NERRORS .GT. 0) THEN
         CALL EOUT (NERRORS)
      ENDIF 
      IF (LISTL) THEN
         CALL LNDICT
      ENDIF 
      CALL ENDST
      IF (NERRORS .GT. 0) THEN
         CALL EXIT (6)
      ELSE 
         CALL EXIT (0)
      ENDIF 
      END 
      SUBROUTINE ADDCHR (C, BUF, BP, MAXSIZ)
      INTEGER BP, MAXSIZ
      INTEGER C, BUF (100)
      IF (BP .GT. MAXSIZ) THEN
         CALL BADERR (16Hbuffer overflow.)
      ENDIF 
      BUF (BP) = C
      BP = BP + 1
      RETURN
      END 
      INTEGER FUNCTION ALLBLK (BUF)
      INTEGER BUF (100)
      INTEGER I
      ALLBLK = 1
      I = 1
1000  IF (.NOT.(BUF (I) .NE. 10 .AND. BUF (I) .NE. -2))GOTO 1020 
      IF (BUF (I) .NE. 32) THEN
         ALLBLK = 0
         GOTO 1020 
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION ALLDIG (STR)
      INTEGER STR (100)
      INTEGER I
      ALLDIG = 0
      IF (STR (1) .EQ. -2) THEN
         RETURN
      ENDIF 
      I = 1
1000  IF (.NOT.(STR (I) .NE. -2))GOTO 1020 
      IF (.NOT.(48.LE.STR (I).AND.STR (I).LE.57)) THEN
         RETURN
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      ALLDIG = 1
      RETURN
      END 
      SUBROUTINE BADERR (MSG)
      INTEGER MSG (100)
      CALL SYNERR (MSG)
      CALL ENDST
      END 
      SUBROUTINE BALPAR
      INTEGER T, TOKEN (100)
      INTEGER GETTOK, GNBTOK
      INTEGER NLPAR
      IF (GNBTOK (TOKEN, 100) .NE. 40) THEN
         CALL SYNERR (19Hmissing left paren.)
         RETURN
      ENDIF 
      CALL OUTSTR (TOKEN)
      NLPAR = 1
1000  CONTINUE 
      T = GETTOK (TOKEN, 100)
      IF (T .EQ. 59 .OR. T .EQ. 123 .OR. T .EQ. 125 .OR. T .EQ. -1) THEN
         CALL PBSTR (TOKEN)
         GOTO 1020 
      ENDIF 
      IF (T .EQ. 10) THEN
         TOKEN (1) = -2
      ELSE IF (T .EQ. 40) THEN
         NLPAR = NLPAR + 1
      ELSE IF (T .EQ. 41) THEN
         NLPAR = NLPAR - 1
      ENDIF 
      IF (T .EQ. -9) THEN
         CALL SQUASH (TOKEN)
      ENDIF 
      CALL OUTSTR (TOKEN)
1010  IF (.NOT.(NLPAR .LE. 0))GOTO 1000 
1020  CONTINUE 
      IF (NLPAR .NE. 0) THEN
         CALL SYNERR (33Hmissing parenthesis in condition.)
      ENDIF 
      RETURN
      END 
      SUBROUTINE BRKNXT (SP, LEXTYP, LABVAL, TOKEN)
      INTEGER LABVAL (100), LEXTYP (100), SP, TOKEN
      INTEGER I, N
      INTEGER ALLDIG, CTOI
      INTEGER T, PTOKEN (100)
      INTEGER GNBTOK
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      N = 0
      T = GNBTOK (PTOKEN, 100)
      IF (ALLDIG (PTOKEN) .EQ. 1) THEN
         I = 1
         N = CTOI (PTOKEN, I) - 1
      ELSE IF (T .NE. 59) THEN
         CALL PBSTR (PTOKEN)
      ENDIF 
      DO 1000 I = SP, 1, -1
         IF (LEXTYP (I) .EQ. -15 .OR. LEXTYP (I) .EQ. -10 .OR. LEXTYP (
     1      I) .EQ. -16 .OR. LEXTYP (I) .EQ. -17) THEN
            IF (N .GT. 0) THEN
               N = N - 1
               GOTO 1000 
            ELSE IF (TOKEN .EQ. -8) THEN
               CALL OUTGO (LABVAL (I) + 1)
            ELSE 
               CALL OUTGO (LABVAL (I))
            ENDIF 
            XFER = 1
            RETURN
         ENDIF 
1000  CONTINUE 
1010  CONTINUE 
      IF (TOKEN .EQ. -8) THEN
         CALL SYNERR (14Hillegal break.)
      ELSE 
         CALL SYNERR (13Hillegal next.)
      ENDIF 
      RETURN
      END 
      SUBROUTINE CASCOD (LAB, TOKEN)
      INTEGER LAB, TOKEN
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER T, L, LB, UB, I, J, JUNK
      INTEGER CASLAB, LABGEN, GNBTOK
      INTEGER TOK (100)
      IF (SWTOP .LE. 0) THEN
         CALL SYNERR (24Hillegal case or default.)
         RETURN
      ENDIF 
      CALL OUTGO (LAB + 1)
      XFER = 1
      L = LABGEN (1)
      IF (TOKEN .EQ. -25) THEN
1000     IF (CASLAB (LB, T) .NE. -1) THEN
            UB = LB
            IF (T .EQ. 45) THEN
               JUNK = CASLAB (UB, T)
            ENDIF 
            IF (LB .GT. UB) THEN
               CALL SYNERR (28Hillegal range in case label.)
               UB = LB
            ENDIF 
            IF (SWLAST + 3 .GT. 1000) THEN
               CALL BADERR (22Hswitch table overflow.)
            ENDIF 
            I = SWTOP + 3
1010        IF (.NOT.(I .LT. SWLAST))GOTO 1030 
            IF (LB .LE. SWSTAK (I)) THEN
               GOTO 1030 
            ELSE IF (LB .LE. SWSTAK (I+1)) THEN
               CALL SYNERR (21Hduplicate case label.)
            ENDIF 
1020        I = I + 3
            GOTO 1010 
1030        CONTINUE 
            IF (I .LT. SWLAST .AND. UB .GE. SWSTAK (I)) THEN
               CALL SYNERR (21Hduplicate case label.)
            ENDIF 
            J = SWLAST
1040        IF (.NOT.(J .GT. I))GOTO 1060 
            SWSTAK (J+2) = SWSTAK (J-1)
1050        J = J - 1
            GOTO 1040 
1060        CONTINUE 
            SWSTAK (I) = LB
            SWSTAK (I + 1) = UB
            SWSTAK (I + 2) = L
            SWSTAK (SWTOP + 1) = SWSTAK (SWTOP + 1) + 1
            SWLAST = SWLAST + 3
            IF (T .EQ. 58) THEN
               GOTO 1070 
            ELSE IF (T .NE. 44) THEN
               CALL SYNERR (20Hillegal case syntax.)
            ENDIF 
            GOTO 1000 
         ENDIF 
1070     CONTINUE 
      ELSE 
         T = GNBTOK (TOK, 100)
         IF (SWSTAK (SWTOP + 2) .NE. 0) THEN
            CALL ERROR (38Hmultiple defaults in switch statement.)
         ELSE 
            SWSTAK (SWTOP + 2) = L
         ENDIF 
      ENDIF 
      IF (T .EQ. -1) THEN
         CALL SYNERR (15Hunexpected EOF.)
      ELSE IF (T .NE. 58) THEN
         CALL ERROR (39Hmissing colon in case or default label.)
      ENDIF 
      XFER = 0
      CALL OUTCON (L)
      RETURN
      END 
      INTEGER FUNCTION CASLAB (N, T)
      INTEGER N, T
      INTEGER TOK (100)
      INTEGER I, S
      INTEGER GNBTOK, CTOI
      T = GNBTOK (TOK, 100)
1000  IF (T .EQ. 10) THEN
         T = GNBTOK (TOK, 100)
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      IF (T .EQ. -1) THEN
         CASLAB=(T)
         RETURN
      ENDIF 
      IF (T .EQ. 45) THEN
         S = -1
      ELSE 
         S = +1
      ENDIF 
      IF (T .EQ. 45 .OR. T .EQ. 43) THEN
         T = GNBTOK (TOK, 100)
      ENDIF 
      IF (T .NE. 48) THEN
         CALL SYNERR (19Hinvalid case label.)
         N = 0
      ELSE 
         I = 1
         N = S * CTOI (TOK, I)
      ENDIF 
      T = GNBTOK (TOK, 100)
1020  IF (T .EQ. 10) THEN
         T = GNBTOK (TOK, 100)
         GOTO 1020 
      ENDIF 
1030  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION DEFTOK (TOKEN, TOKSIZ)
      INTEGER TOKEN (100)
      INTEGER TOKSIZ
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER T, C, DEFN (400), MDEFN (400)
      INTEGER GTOK
      INTEGER AP, ARGSTK (100), CALLST (50), NLB, PLEV (50), IFL
      INTEGER LUDEF, PUSH, IFPARM
      INTEGER BALP(3)
      DATA BALP(1)/40/,BALP(2)/41/,BALP(3)/-2/
      CP = 0
      AP = 1
      EP = 1
      T = GTOK (TOKEN, TOKSIZ)
1000  IF (.NOT.(T .NE. -1))GOTO 1050 
      IF (T .EQ. -9) THEN
         IF (LUDEF (TOKEN, DEFN, DEFTBL) .EQ. 0) THEN
            IF (CP .EQ. 0) THEN
               GOTO 1050 
            ELSE 
               CALL PUTTOK (TOKEN)
            ENDIF 
         ELSE IF (DEFN (1) .EQ. -4) THEN
            CALL GETDEF (TOKEN, TOKSIZ, DEFN, 400)
            CALL ENTDEF (TOKEN, DEFN, DEFTBL)
         ELSE IF (DEFN (1) .EQ. -15 .OR. DEFN (1) .EQ. -16) THEN
            C = DEFN (1)
            CALL GETDEF (TOKEN, TOKSIZ, DEFN, 400)
            IFL = LUDEF (TOKEN, MDEFN, DEFTBL)
            IF ((IFL .EQ. 1 .AND. C .EQ. -15) .OR. (IFL .EQ. 0 .AND. C .
     1            EQ. -16)) THEN
               CALL PBSTR (DEFN)
            ENDIF 
         ELSE 
            CP = CP + 1
            IF (CP .GT. 50) THEN
               CALL BADERR (20Hcall stack overflow.)
            ENDIF 
            CALLST (CP) = AP
            AP = PUSH (EP, ARGSTK, AP)
            CALL PUTTOK (DEFN)
            CALL PUTCHR (-2)
            AP = PUSH (EP, ARGSTK, AP)
            CALL PUTTOK (TOKEN)
            CALL PUTCHR (-2)
            AP = PUSH (EP, ARGSTK, AP)
            T = GTOK (TOKEN, TOKSIZ)
            IF (T .EQ. 32) THEN
               T = GTOK (TOKEN, TOKSIZ)
               CALL PBSTR (TOKEN)
               IF (T .NE. 40) THEN
                  CALL PUTBAK (32)
               ENDIF 
            ELSE 
               CALL PBSTR (TOKEN)
            ENDIF 
            IF (T .NE. 40) THEN
               CALL PBSTR (BALP)
            ELSE IF (IFPARM (DEFN) .EQ. 0) THEN
               CALL PBSTR (BALP)
            ENDIF 
            PLEV (CP) = 0
         ENDIF 
      ELSE IF (T .EQ. -10) THEN
         NLB = 1
1010     CONTINUE 
         T = GTOK (TOKEN, TOKSIZ)
         IF (T .EQ. -10) THEN
            NLB = NLB + 1
         ELSE IF (T .EQ. -11) THEN
            NLB = NLB - 1
            IF (NLB .EQ. 0) THEN
               GOTO 1030 
            ENDIF 
         ELSE IF (T .EQ. -1) THEN
            CALL BADERR (14HEOF in string.)
         ENDIF 
         CALL PUTTOK (TOKEN)
1020     GOTO 1010 
1030     CONTINUE 
      ELSE IF (CP .EQ. 0) THEN
         GOTO 1050 
      ELSE IF (T .EQ. 40) THEN
         IF (PLEV (CP) .GT. 0) THEN
            CALL PUTTOK (TOKEN)
         ENDIF 
         PLEV (CP) = PLEV (CP) + 1
      ELSE IF (T .EQ. 41) THEN
         PLEV (CP) = PLEV (CP) - 1
         IF (PLEV (CP) .GT. 0) THEN
            CALL PUTTOK (TOKEN)
         ELSE 
            CALL PUTCHR (-2)
            CALL EVALR (ARGSTK, CALLST (CP), AP - 1)
            AP = CALLST (CP)
            EP = ARGSTK (AP)
            CP = CP - 1
         ENDIF 
      ELSE IF (T .EQ. 44 .AND. PLEV (CP) .EQ. 1) THEN
         CALL PUTCHR (-2)
         AP = PUSH (EP, ARGSTK, AP)
      ELSE 
         CALL PUTTOK (TOKEN)
      ENDIF 
1040  T = GTOK (TOKEN, TOKSIZ)
      GOTO 1000 
1050  CONTINUE 
      DEFTOK = T
      IF (T .EQ. -9) THEN
         CALL FOLD (TOKEN)
      ENDIF 
      RETURN
      END 
      SUBROUTINE DOARTH (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER K, L
      INTEGER CTOI
      INTEGER OP
      K = ARGSTK (I + 2)
      L = ARGSTK (I + 4)
      J = ARGSTK (I + 3)
      OP = EVALST (J)
1000  IF (OP .EQ. 32) THEN
         J = J + 1
         OP = EVALST (J)
         IF (OP .EQ. -2) THEN
            GOTO 1010 
         ENDIF 
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      IF (OP .EQ. 43) THEN
         CALL PBNUM (CTOI (EVALST, K) + CTOI (EVALST, L))
      ELSE IF (OP .EQ. 45) THEN
         CALL PBNUM (CTOI (EVALST, K) - CTOI (EVALST, L))
      ELSE IF (OP .EQ. 42 ) THEN
         CALL PBNUM (CTOI (EVALST, K) * CTOI (EVALST, L))
      ELSE IF (OP .EQ. 47 ) THEN
         CALL PBNUM (CTOI (EVALST, K) / CTOI (EVALST, L))
      ELSE 
         CALL REMARK ('arith error.')
      ENDIF 
      RETURN
      END 
      SUBROUTINE DOCODE (LAB)
      INTEGER LAB
      INTEGER LABGEN
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER GNBTOK
      INTEGER LEXSTR (100)
      INTEGER SDO(3)
      DATA SDO(1)/100/,SDO(2)/111/,SDO(3)/-2/
      XFER = 0
      CALL OUTTAB
      CALL OUTSTR (SDO)
      CALL OUTCH (32)
      LAB = LABGEN (2)
      IF (GNBTOK (LEXSTR, 100) .EQ. 48) THEN
         CALL OUTSTR (LEXSTR)
      ELSE 
         CALL PBSTR (LEXSTR)
         CALL OUTNUM (LAB)
      ENDIF 
      CALL OUTCH (32)
      CALL EATUP
      CALL OUTDON
      RETURN
      END 
      SUBROUTINE DOIF (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER A2, A3, A4, A5
      INTEGER EQUAL
      IF (J - I .LT. 5) THEN
         RETURN
      ENDIF 
      A2 = ARGSTK (I + 2)
      A3 = ARGSTK (I + 3)
      A4 = ARGSTK (I + 4)
      A5 = ARGSTK (I + 5)
      IF (EQUAL (EVALST (A2), EVALST (A3)) .EQ. 1) THEN
         CALL PBSTR (EVALST (A4))
      ELSE 
         CALL PBSTR (EVALST (A5))
      ENDIF 
      RETURN
      END 
      SUBROUTINE DOINCR (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER K
      INTEGER CTOI
      K = ARGSTK (I + 2)
      CALL PBNUM (CTOI (EVALST, K) + 1)
      RETURN
      END 
      SUBROUTINE DOMAC (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER A2, A3
      IF (J - I .GT. 2) THEN
         A2 = ARGSTK (I + 2)
         A3 = ARGSTK (I + 3)
         CALL ENTDEF (EVALST (A2), EVALST (A3), DEFTBL)
      ENDIF 
      RETURN
      END 
      SUBROUTINE DOSTAT (LAB)
      INTEGER LAB
      CALL OUTCON (LAB)
      CALL OUTCON (LAB + 1)
      RETURN
      END 
      SUBROUTINE DOSUB (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER AP, FC, K, NC
      INTEGER CTOI, LENGTH
      IF (J - I .LT. 3) THEN
         RETURN
      ENDIF 
      IF (J - I .LT. 4) THEN
         NC = 100
      ELSE 
         K = ARGSTK (I + 4)
         NC = CTOI (EVALST, K)
      ENDIF 
      K = ARGSTK (I + 3)
      AP = ARGSTK (I + 2)
      FC = AP + CTOI (EVALST, K) - 1
      IF (FC .GE. AP .AND. FC .LT. AP + LENGTH (EVALST (AP))) THEN
         K = FC + MIN0(NC, LENGTH (EVALST (FC))) - 1
1000     IF (.NOT.(K .GE. FC))GOTO 1020 
         CALL PUTBAK (EVALST (K))
1010     K = K - 1
         GOTO 1000 
1020     CONTINUE 
      ENDIF 
      RETURN
      END 
      SUBROUTINE EATUP
      INTEGER PTOKEN (100), T, TOKEN (100)
      INTEGER GETTOK
      INTEGER NLPAR
      NLPAR = 0
1000  CONTINUE 
      T = GETTOK (TOKEN, 100)
      IF (T .EQ. 59 .OR. T .EQ. 10) THEN
         GOTO 1040 
      ENDIF 
      IF (T .EQ. 125 .OR. T .EQ. 123) THEN
         CALL PBSTR (TOKEN)
         GOTO 1040 
      ENDIF 
      IF (T .EQ. -1) THEN
         CALL SYNERR (15Hunexpected EOF.)
         CALL PBSTR (TOKEN)
         GOTO 1040 
      ENDIF 
      IF (T .EQ. 44 .OR. T .EQ. 43 .OR. T .EQ. 45 .OR. T .EQ. 42 .OR. T.
     1EQ. 40 .OR. T .EQ. 38 .OR. T .EQ. 124 .OR. T .EQ. 33 .OR. T .EQ.
     2126 .OR. T .EQ. 126 .OR. T .EQ. 94 .OR. T .EQ. 61 .OR. T .EQ. 95)
     3THEN
1010     IF (GETTOK (PTOKEN, 100) .EQ. 10) THEN
            GOTO 1010 
         ENDIF 
1020     CONTINUE 
         CALL PBSTR (PTOKEN)
         IF (T .EQ. 95) THEN
            TOKEN (1) = -2
         ENDIF 
      ENDIF 
      IF (T .EQ. 40) THEN
         NLPAR = NLPAR + 1
      ELSE IF (T .EQ. 41) THEN
         NLPAR = NLPAR - 1
      ENDIF 
      IF (T .EQ. -9) THEN
         CALL SQUASH (TOKEN)
      ENDIF 
      CALL OUTSTR (TOKEN)
1030  IF (.NOT.(NLPAR .LT. 0))GOTO 1000 
1040  CONTINUE 
      IF (NLPAR .NE. 0) THEN
         CALL SYNERR (23Hunbalanced parentheses.)
      ENDIF 
      RETURN
      END 
      SUBROUTINE ELSEIF (LAB)
      INTEGER LAB
      LAB = 0
      CALL ELSE
      RETURN
      END 
      SUBROUTINE ENTDEF (NAME, DEFN, TABLE)
      INTEGER NAME (100), DEFN (100)
      INTEGER TABLE
      INTEGER LOOKUP
      INTEGER TEXT
      INTEGER SDUPL
      IF (LOOKUP (NAME, TEXT, TABLE) .EQ. 1) THEN
         CALL DSFREE (TEXT)
      ENDIF 
      CALL ENTER (NAME, SDUPL (DEFN), TABLE)
      RETURN
      END 
      SUBROUTINE ENTDKW
      INTEGER DEFT (2), INCT (2), SUBT (2), IFT (2), ART (2), IFDFT (2),
     * IFNDT (2), MACT (2)
      INTEGER DEFNAM(7)
      INTEGER MACNAM(8)
      INTEGER INCNAM(5)
      INTEGER SUBNAM(7)
      INTEGER IFNAM(7)
      INTEGER ARNAM(6)
      INTEGER IFDFNM(6)
      INTEGER IFNDNM(9)
      DATA DEFNAM(1)/100/,DEFNAM(2)/101/,DEFNAM(3)/102/,DEFNAM(4)/105/,D
     *EFNAM(5)/110/,DEFNAM(6)/101/,DEFNAM(7)/-2/
      DATA MACNAM(1)/109/,MACNAM(2)/100/,MACNAM(3)/101/,MACNAM(4)/102/,M
     *ACNAM(5)/105/,MACNAM(6)/110/,MACNAM(7)/101/,MACNAM(8)/-2/
      DATA INCNAM(1)/105/,INCNAM(2)/110/,INCNAM(3)/99/,INCNAM(4)/114/,IN
     *CNAM(5)/-2/
      DATA SUBNAM(1)/115/,SUBNAM(2)/117/,SUBNAM(3)/98/,SUBNAM(4)/115/,SU
     *BNAM(5)/116/,SUBNAM(6)/114/,SUBNAM(7)/-2/
      DATA IFNAM(1)/105/,IFNAM(2)/102/,IFNAM(3)/101/,IFNAM(4)/108/,IFNAM
     *(5)/115/,IFNAM(6)/101/,IFNAM(7)/-2/
      DATA ARNAM(1)/97/,ARNAM(2)/114/,ARNAM(3)/105/,ARNAM(4)/116/,ARNAM(
     *5)/104/,ARNAM(6)/-2/
      DATA IFDFNM(1)/105/,IFDFNM(2)/102/,IFDFNM(3)/100/,IFDFNM(4)/101/,I
     *FDFNM(5)/102/,IFDFNM(6)/-2/
      DATA IFNDNM(1)/105/,IFNDNM(2)/102/,IFNDNM(3)/110/,IFNDNM(4)/111/,I
     *FNDNM(5)/116/,IFNDNM(6)/100/,IFNDNM(7)/101/,IFNDNM(8)/102/,IFNDNM(
     *9)/-2/
      DATA DEFT (1), DEFT (2) /-4, -2/
      DATA MACT (1), MACT (2) /-10, -2/
      DATA INCT (1), INCT (2) /-12, -2/
      DATA SUBT (1), SUBT (2) /-13, -2/
      DATA IFT (1), IFT (2) /-11, -2/
      DATA ART (1), ART (2) /-14, -2/
      DATA IFDFT (1), IFDFT (2) /-15, -2/
      DATA IFNDT (1), IFNDT (2) /-16, -2/
      CALL ULSTAL (DEFNAM, DEFT)
      CALL ULSTAL (MACNAM, MACT)
      CALL ULSTAL (INCNAM, INCT)
      CALL ULSTAL (SUBNAM, SUBT)
      CALL ULSTAL (IFNAM, IFT)
      CALL ULSTAL (ARNAM, ART)
      CALL ULSTAL (IFDFNM, IFDFT)
      CALL ULSTAL (IFNDNM, IFNDT)
      RETURN
      END 
      SUBROUTINE ENTFKW
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      INTEGER SCHAR(10)
      INTEGER SCONTI(9)
      INTEGER SCOMPL(8)
      INTEGER SLOGIC(8)
      INTEGER SIMPLI(9)
      INTEGER SPARAM(10)
      INTEGER SEXTER(9)
      INTEGER SDIMEN(10)
      INTEGER SINTEG(8)
      INTEGER SEQUIV(12)
      INTEGER SFUNCT(9)
      INTEGER SSUBRO(11)
      INTEGER SPRECI(10)
      DATA SCHAR(1)/99/,SCHAR(2)/104/,SCHAR(3)/97/,SCHAR(4)/114/,SCHAR(5
     *)/97/,SCHAR(6)/99/,SCHAR(7)/116/,SCHAR(8)/101/,SCHAR(9)/114/,SCHAR
     *(10)/-2/
      DATA SCONTI(1)/99/,SCONTI(2)/111/,SCONTI(3)/110/,SCONTI(4)/116/,SC
     *ONTI(5)/105/,SCONTI(6)/110/,SCONTI(7)/117/,SCONTI(8)/101/,SCONTI(9
     *)/-2/
      DATA SCOMPL(1)/99/,SCOMPL(2)/111/,SCOMPL(3)/109/,SCOMPL(4)/112/,SC
     *OMPL(5)/108/,SCOMPL(6)/101/,SCOMPL(7)/120/,SCOMPL(8)/-2/
      DATA SLOGIC(1)/108/,SLOGIC(2)/111/,SLOGIC(3)/103/,SLOGIC(4)/105/,S
     *LOGIC(5)/99/,SLOGIC(6)/97/,SLOGIC(7)/108/,SLOGIC(8)/-2/
      DATA SIMPLI(1)/105/,SIMPLI(2)/109/,SIMPLI(3)/112/,SIMPLI(4)/108/,S
     *IMPLI(5)/105/,SIMPLI(6)/99/,SIMPLI(7)/105/,SIMPLI(8)/116/,SIMPLI(9
     *)/-2/
      DATA SPARAM(1)/112/,SPARAM(2)/97/,SPARAM(3)/114/,SPARAM(4)/97/,SPA
     *RAM(5)/109/,SPARAM(6)/101/,SPARAM(7)/116/,SPARAM(8)/101/,SPARAM(9)
     */114/,SPARAM(10)/-2/
      DATA SEXTER(1)/101/,SEXTER(2)/120/,SEXTER(3)/116/,SEXTER(4)/101/,S
     *EXTER(5)/114/,SEXTER(6)/110/,SEXTER(7)/97/,SEXTER(8)/108/,SEXTER(9
     *)/-2/
      DATA SDIMEN(1)/100/,SDIMEN(2)/105/,SDIMEN(3)/109/,SDIMEN(4)/101/,S
     *DIMEN(5)/110/,SDIMEN(6)/115/,SDIMEN(7)/105/,SDIMEN(8)/111/,SDIMEN(
     *9)/110/,SDIMEN(10)/-2/
      DATA SINTEG(1)/105/,SINTEG(2)/110/,SINTEG(3)/116/,SINTEG(4)/101/,S
     *INTEG(5)/103/,SINTEG(6)/101/,SINTEG(7)/114/,SINTEG(8)/-2/
      DATA SEQUIV(1)/101/,SEQUIV(2)/113/,SEQUIV(3)/117/,SEQUIV(4)/105/,S
     *EQUIV(5)/118/,SEQUIV(6)/97/,SEQUIV(7)/108/,SEQUIV(8)/101/,SEQUIV(9
     *)/110/,SEQUIV(10)/99/,SEQUIV(11)/101/,SEQUIV(12)/-2/
      DATA SFUNCT(1)/102/,SFUNCT(2)/117/,SFUNCT(3)/110/,SFUNCT(4)/99/,SF
     *UNCT(5)/116/,SFUNCT(6)/105/,SFUNCT(7)/111/,SFUNCT(8)/110/,SFUNCT(9
     *)/-2/
      DATA SSUBRO(1)/115/,SSUBRO(2)/117/,SSUBRO(3)/98/,SSUBRO(4)/114/,SS
     *UBRO(5)/111/,SSUBRO(6)/117/,SSUBRO(7)/116/,SSUBRO(8)/105/,SSUBRO(9
     *)/110/,SSUBRO(10)/101/,SSUBRO(11)/-2/
      DATA SPRECI(1)/112/,SPRECI(2)/114/,SPRECI(3)/101/,SPRECI(4)/99/,SP
     *RECI(5)/105/,SPRECI(6)/115/,SPRECI(7)/105/,SPRECI(8)/111/,SPRECI(9
     *)/110/,SPRECI(10)/-2/
      CALL ENTER (SCHAR, 0, FKWTBL)
      CALL ENTER (SCONTI, 0, FKWTBL)
      CALL ENTER (SCOMPL, 0, FKWTBL)
      CALL ENTER (SLOGIC, 0, FKWTBL)
      CALL ENTER (SIMPLI, 0, FKWTBL)
      CALL ENTER (SPARAM, 0, FKWTBL)
      CALL ENTER (SEXTER, 0, FKWTBL)
      CALL ENTER (SDIMEN, 0, FKWTBL)
      CALL ENTER (SINTEG, 0, FKWTBL)
      CALL ENTER (SEQUIV, 0, FKWTBL)
      CALL ENTER (SFUNCT, 0, FKWTBL)
      CALL ENTER (SSUBRO, 0, FKWTBL)
      CALL ENTER (SPRECI, 0, FKWTBL)
      RETURN
      END 
      SUBROUTINE ENTRKW
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      INTEGER SIF(3)
      INTEGER SELSE(5)
      INTEGER SWHILE(6)
      INTEGER SDO(3)
      INTEGER SBREAK(6)
      INTEGER SNEXT(5)
      INTEGER SFOR(4)
      INTEGER SREPT(7)
      INTEGER SUNTIL(6)
      INTEGER SRET(7)
      INTEGER SSTR(7)
      INTEGER SSWTCH(7)
      INTEGER SCASE(5)
      INTEGER SDEFLT(8)
      DATA SIF(1)/105/,SIF(2)/102/,SIF(3)/-2/
      DATA SELSE(1)/101/,SELSE(2)/108/,SELSE(3)/115/,SELSE(4)/101/,SELSE
     *(5)/-2/
      DATA SWHILE(1)/119/,SWHILE(2)/104/,SWHILE(3)/105/,SWHILE(4)/108/,S
     *WHILE(5)/101/,SWHILE(6)/-2/
      DATA SDO(1)/100/,SDO(2)/111/,SDO(3)/-2/
      DATA SBREAK(1)/98/,SBREAK(2)/114/,SBREAK(3)/101/,SBREAK(4)/97/,SBR
     *EAK(5)/107/,SBREAK(6)/-2/
      DATA SNEXT(1)/110/,SNEXT(2)/101/,SNEXT(3)/120/,SNEXT(4)/116/,SNEXT
     *(5)/-2/
      DATA SFOR(1)/102/,SFOR(2)/111/,SFOR(3)/114/,SFOR(4)/-2/
      DATA SREPT(1)/114/,SREPT(2)/101/,SREPT(3)/112/,SREPT(4)/101/,SREPT
     *(5)/97/,SREPT(6)/116/,SREPT(7)/-2/
      DATA SUNTIL(1)/117/,SUNTIL(2)/110/,SUNTIL(3)/116/,SUNTIL(4)/105/,S
     *UNTIL(5)/108/,SUNTIL(6)/-2/
      DATA SRET(1)/114/,SRET(2)/101/,SRET(3)/116/,SRET(4)/117/,SRET(5)/1
     *14/,SRET(6)/110/,SRET(7)/-2/
      DATA SSTR(1)/115/,SSTR(2)/116/,SSTR(3)/114/,SSTR(4)/105/,SSTR(5)/1
     *10/,SSTR(6)/103/,SSTR(7)/-2/
      DATA SSWTCH(1)/115/,SSWTCH(2)/119/,SSWTCH(3)/105/,SSWTCH(4)/116/,S
     *SWTCH(5)/99/,SSWTCH(6)/104/,SSWTCH(7)/-2/
      DATA SCASE(1)/99/,SCASE(2)/97/,SCASE(3)/115/,SCASE(4)/101/,SCASE(5
     *)/-2/
      DATA SDEFLT(1)/100/,SDEFLT(2)/101/,SDEFLT(3)/102/,SDEFLT(4)/97/,SD
     *EFLT(5)/117/,SDEFLT(6)/108/,SDEFLT(7)/116/,SDEFLT(8)/-2/
      LOGICAL LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      CALL ENTER (SIF, -19, RKWTBL)
      CALL ENTER (SELSE, -11, RKWTBL)
      CALL ENTER (SWHILE, -15, RKWTBL)
      CALL ENTER (SDO, -10, RKWTBL)
      CALL ENTER (SBREAK, -8, RKWTBL)
      CALL ENTER (SNEXT, -13, RKWTBL)
      CALL ENTER (SFOR, -16, RKWTBL)
      CALL ENTER (SREPT, -17, RKWTBL)
      CALL ENTER (SUNTIL, -18, RKWTBL)
      CALL ENTER (SRET, -20, RKWTBL)
      IF (STRNG) THEN
         CALL ENTER (SSTR, -23, RKWTBL)
      ENDIF 
      CALL ENTER (SSWTCH, -24, RKWTBL)
      CALL ENTER (SCASE, -25, RKWTBL)
      CALL ENTER (SDEFLT, -26, RKWTBL)
      RETURN
      END 
      SUBROUTINE EVALR (ARGSTK, I, J)
      INTEGER ARGSTK (100), I, J
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER ARGNO, K, M, N, T, TD
      INTEGER INDX, LENGTH
      INTEGER DIGITS(11)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/-2/
      T = ARGSTK (I)
      TD = EVALST (T)
      IF (TD .EQ. -10) THEN
         CALL DOMAC (ARGSTK, I, J)
      ELSE IF (TD .EQ. -12) THEN
         CALL DOINCR (ARGSTK, I, J)
      ELSE IF (TD .EQ. -13) THEN
         CALL DOSUB (ARGSTK, I, J)
      ELSE IF (TD .EQ. -11) THEN
         CALL DOIF (ARGSTK, I, J)
      ELSE IF (TD .EQ. -14) THEN
         CALL DOARTH (ARGSTK, I, J)
      ELSE 
         K = T + LENGTH (EVALST (T)) - 1
1000     IF (.NOT.(K .GT. T))GOTO 1020 
         IF (EVALST (K - 1) .NE. 36) THEN
            CALL PUTBAK (EVALST (K))
         ELSE 
            ARGNO = INDX (DIGITS, EVALST (K)) - 1
            IF (ARGNO .GE. 0 .AND. ARGNO .LT. J - I) THEN
               N = I + ARGNO + 1
               M = ARGSTK (N)
               CALL PBSTR (EVALST (M))
            ENDIF 
            K = K - 1
         ENDIF 
1010     K = K - 1
         GOTO 1000 
1020     CONTINUE 
         IF (K .EQ. T) THEN
            CALL PUTBAK (EVALST (K))
         ENDIF 
      ENDIF 
      RETURN
      END 
      SUBROUTINE FINIT
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      OUTP = 0
      LEVEL = 1
      LINECT (1) = 0
      SBP = 1
      FNAMP = 2
      FNAMES (1) = -2
      BP = 400
      BUF (BP) = -2
      FORDEP = 0
      FCNAME (1) = -2
      SWTOP = 0
      SWLAST = 1
      RETURN
      END 
      SUBROUTINE FORCOD (LAB)
      INTEGER LAB
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER T, TOKEN (100)
      INTEGER GETTOK, GNBTOK
      INTEGER I, J, NLPAR
      INTEGER LENGTH, LABGEN
      INTEGER IFNOT(10)
      DATA IFNOT(1)/105/,IFNOT(2)/102/,IFNOT(3)/32/,IFNOT(4)/40/,IFNOT(5
     *)/46/,IFNOT(6)/110/,IFNOT(7)/111/,IFNOT(8)/116/,IFNOT(9)/46/,IFNOT
     *(10)/-2/
      LAB = LABGEN (3)
      CALL OUTCON (0)
      IF (GNBTOK (TOKEN, 100) .NE. 40) THEN
         CALL SYNERR (19Hmissing left paren.)
         RETURN
      ENDIF 
      IF (GNBTOK (TOKEN, 100) .NE. 59) THEN
         CALL PBSTR (TOKEN)
         CALL OUTTAB
         CALL EATUP
         CALL OUTDON
      ENDIF 
      IF (GNBTOK (TOKEN, 100) .EQ. 59) THEN
         CALL OUTCON (LAB)
      ELSE 
         CALL PBSTR (TOKEN)
         CALL OUTNUM (LAB)
         CALL OUTTAB
         CALL OUTSTR (IFNOT)
         CALL OUTCH (40)
         NLPAR = 0
1000     IF (NLPAR .GE. 0) THEN
            T = GETTOK (TOKEN, 100)
            IF (T .EQ. 59) THEN
               GOTO 1010 
            ENDIF 
            IF (T .EQ. 40) THEN
               NLPAR = NLPAR + 1
            ELSE IF (T .EQ. 41) THEN
               NLPAR = NLPAR - 1
            ENDIF 
            IF (T .EQ. -1) THEN
               CALL PBSTR (TOKEN)
               RETURN
            ENDIF 
            IF (T .EQ. -9) THEN
               CALL SQUASH (TOKEN)
            ENDIF 
            IF (T .NE. 10 .AND. T .NE. 95) THEN
               CALL OUTSTR (TOKEN)
            ENDIF 
            GOTO 1000 
         ENDIF 
1010     CONTINUE 
         CALL OUTCH (41)
         CALL OUTCH (41)
         CALL OUTGO (LAB+2)
         IF (NLPAR .LT. 0) THEN
            CALL SYNERR (19Hinvalid for clause.)
         ENDIF 
      ENDIF 
      FORDEP = FORDEP + 1
      J = 1
      DO 1020 I = 1, FORDEP-1
         J = J + LENGTH (FORSTK (J)) + 1
1020  CONTINUE 
1030  CONTINUE 
      FORSTK (J) = -2
      NLPAR = 0
      T = GNBTOK (TOKEN, 100)
      CALL PBSTR (TOKEN)
1040  IF (NLPAR .GE. 0) THEN
         T = GETTOK (TOKEN, 100)
         IF (T .EQ. 40) THEN
            NLPAR = NLPAR + 1
         ELSE IF (T .EQ. 41) THEN
            NLPAR = NLPAR - 1
         ENDIF 
         IF (T .EQ. -1) THEN
            CALL PBSTR (TOKEN)
            GOTO 1050 
         ENDIF 
         IF (NLPAR .GE. 0 .AND. T .NE. 10 .AND. T .NE. 95) THEN
            IF (T .EQ. -9) THEN
               CALL SQUASH (TOKEN)
            ENDIF 
            IF (J + LENGTH (TOKEN) .GE. 200) THEN
               CALL BADERR (20Hfor clause too long.)
            ENDIF 
            CALL SCOPY (TOKEN, 1, FORSTK, J)
            J = J + LENGTH (TOKEN)
         ENDIF 
         GOTO 1040 
      ENDIF 
1050  CONTINUE 
      LAB = LAB + 1
      RETURN
      END 
      SUBROUTINE FORS (LAB)
      INTEGER LAB
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER I, J
      INTEGER LENGTH
      XFER = 0
      CALL OUTNUM (LAB)
      J = 1
      DO 1000 I = 1, FORDEP-1
         J = J + LENGTH (FORSTK (J)) + 1
1000  CONTINUE 
1010  CONTINUE 
      IF (LENGTH (FORSTK (J)) .GT. 0) THEN
         CALL OUTTAB
         CALL OUTSTR (FORSTK (J))
         CALL OUTDON
      ENDIF 
      CALL OUTGO (LAB - 1)
      CALL OUTCON (LAB + 1)
      FORDEP = FORDEP - 1
      RETURN
      END 
      SUBROUTINE GETDEF (TOKEN, TOKSIZ, DEFN, DEFSIZ)
      INTEGER TOKEN (100), DEFN (400)
      INTEGER TOKSIZ, DEFSIZ
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER C, T, PTOKEN (100)
      INTEGER GTOK, NGETCH
      INTEGER I, NLPAR
      CALL SKPBLK
      C = GTOK (PTOKEN, 100)
      IF (C .EQ. 40) THEN
         T = 40
      ELSE 
         T = 32
         CALL PBSTR (PTOKEN)
      ENDIF 
      CALL SKPBLK
      IF (GTOK (TOKEN, TOKSIZ) .NE. -9) THEN
         CALL BADERR (22Hnon-alphanumeric name.)
      ENDIF 
      CALL SKPBLK
      C = GTOK (PTOKEN, 100)
      IF (T .EQ. 32) THEN
         CALL PBSTR (PTOKEN)
         I = 1
1000     CONTINUE 
         C = NGETCH (C)
         IF (I .GT. DEFSIZ) THEN
            CALL BADERR (20Hdefinition too long.)
         ENDIF 
         DEFN (I) = C
         I = I + 1
1010     IF (.NOT.(C .EQ. 35 .OR. C .EQ. 10 .OR. C .EQ. -1))GOTO 1000 
1020     CONTINUE 
         IF (C .EQ. 35) THEN
            CALL PUTBAK (C)
         ENDIF 
      ELSE IF (T .EQ. 40) THEN
         IF (C .NE. 44) THEN
            CALL BADERR (24Hmissing comma in define.)
         ENDIF 
         NLPAR = 0
         I = 1
1030     IF (.NOT.(NLPAR .GE. 0))GOTO 1050 
         IF (I .GT. DEFSIZ) THEN
            CALL BADERR (20Hdefinition too long.)
         ELSE IF (NGETCH (DEFN (I)) .EQ. -1) THEN
            CALL BADERR (20Hmissing right paren.)
         ELSE IF (DEFN (I) .EQ. 40) THEN
            NLPAR = NLPAR + 1
         ELSE IF (DEFN (I) .EQ. 41) THEN
            NLPAR = NLPAR - 1
         ENDIF 
1040     I = I + 1
         GOTO 1030 
1050     CONTINUE 
      ELSE 
         CALL BADERR (19Hgetdef is confused.)
      ENDIF 
      DEFN (I - 1) = -2
      RETURN
      END 
      INTEGER FUNCTION GETTOK (TOKEN, TOKSIZ)
      INTEGER TOKEN (100)
      INTEGER TOKSIZ
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER I, LEN
      INTEGER EQUAL, OPEN, LENGTH
      INTEGER NAME (30), T
      INTEGER DEFTOK
      INTEGER FNCN(9)
      INTEGER INCL(8)
      DATA FNCN(1)/102/,FNCN(2)/117/,FNCN(3)/110/,FNCN(4)/99/,FNCN(5)/11
     *6/,FNCN(6)/105/,FNCN(7)/111/,FNCN(8)/110/,FNCN(9)/-2/
      DATA INCL(1)/105/,INCL(2)/110/,INCL(3)/99/,INCL(4)/108/,INCL(5)/11
     *7/,INCL(6)/100/,INCL(7)/101/,INCL(8)/-2/
1000  IF (.NOT.(LEVEL .GT. 0))GOTO 1100 
      GETTOK = DEFTOK (TOKEN, TOKSIZ)
1010  IF (.NOT.(GETTOK .NE. -1))GOTO 1050 
      IF (EQUAL (TOKEN, FNCN) .EQ. 1) THEN
         CALL SKPBLK
         T = DEFTOK (FCNAME, 30)
         CALL PBSTR (FCNAME)
         IF (T .NE. -9) THEN
            CALL SYNERR (22Hmissing function name.)
         ENDIF 
         CALL PUTBAK (32)
         RETURN
      ELSE IF (EQUAL (TOKEN, INCL) .EQ. 0) THEN
         RETURN
      ENDIF 
      CALL SKPBLK
      T = DEFTOK (NAME, 30)
      IF (T .EQ. 39 .OR. T .EQ. 34) THEN
         LEN = LENGTH (NAME) - 1
         DO 1020 I = 1, LEN-1
            NAME (I) = NAME (I + 1)
1020     CONTINUE 
1030     CONTINUE 
         NAME (I) = -2
      ENDIF 
      I = LENGTH (NAME) + 1
      IF (LEVEL .GE. 5) THEN
         CALL SYNERR (27Hincludes nested too deeply.)
      ELSE 
         INFILE (LEVEL + 1) = OPEN (NAME, 1)
         LINECT (LEVEL + 1) = 0
         IF (INFILE (LEVEL + 1) .EQ. -3) THEN
            CALL SYNERR (19Hcan't open include.)
         ELSE 
            LEVEL = LEVEL + 1
            IF (FNAMP + I .LE.  150) THEN
               CALL SCOPY (NAME, 1, FNAMES, FNAMP)
               FNAMP = FNAMP + I
            ENDIF 
         ENDIF 
      ENDIF 
1040  GETTOK = DEFTOK (TOKEN, TOKSIZ)
      GOTO 1010 
1050  CONTINUE 
      IF (LEVEL .GT. 1) THEN
         CALL CLOSE (INFILE (LEVEL))
         FNAMP = FNAMP - 1
1060     IF (.NOT.(FNAMP .GT. 1))GOTO 1080 
         IF (FNAMES (FNAMP - 1) .EQ. -2) THEN
            GOTO 1080 
         ENDIF 
1070     FNAMP = FNAMP - 1
         GOTO 1060 
1080     CONTINUE 
      ENDIF 
1090  LEVEL = LEVEL - 1
      GOTO 1000 
1100  CONTINUE 
      TOKEN (1) = -1
      TOKEN (2) = -2
      GETTOK = -1
      RETURN
      END 
      INTEGER FUNCTION GNBTOK (TOKEN, TOKSIZ)
      INTEGER TOKEN (100)
      INTEGER TOKSIZ
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER GETTOK
      CALL SKPBLK
      GNBTOK = GETTOK (TOKEN, TOKSIZ)
      RETURN
      END 
      INTEGER FUNCTION GTOK (LEXSTR, TOKSIZ)
      INTEGER LEXSTR (100)
      INTEGER TOKSIZ
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER C
      INTEGER NGETCH, CLOWER
      INTEGER I, B, N, D
      INTEGER ITOC, INDX
      INTEGER DIGITS(37)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/97/,DIGITS(12)/98/,DIGITS(13)/99/,DIGITS(
     *14)/100/,DIGITS(15)/101/,DIGITS(16)/102/,DIGITS(17)/103/,DIGITS(18
     *)/104/,DIGITS(19)/105/,DIGITS(20)/106/,DIGITS(21)/107/,DIGITS(22)/
     *108/,DIGITS(23)/109/,DIGITS(24)/110/,DIGITS(25)/111/,DIGITS(26)/11
     *2/,DIGITS(27)/113/,DIGITS(28)/114/,DIGITS(29)/115/,DIGITS(30)/116/
     *,DIGITS(31)/117/,DIGITS(32)/118/,DIGITS(33)/119/,DIGITS(34)/120/,D
     *IGITS(35)/121/,DIGITS(36)/122/,DIGITS(37)/-2/
      C = NGETCH (LEXSTR (1))
      IF (C .EQ. 32 .OR. C .EQ. 9) THEN
         LEXSTR (1) = 32
1000     IF (C .EQ. 32 .OR. C .EQ. 9) THEN
            C = NGETCH (C)
            GOTO 1000 
         ENDIF 
1010     CONTINUE 
         IF (C .EQ. 35) THEN
1020        IF (NGETCH (C) .NE. 10) THEN
               GOTO 1020 
            ENDIF 
1030        CONTINUE 
         ENDIF 
         IF (C .NE. 10) THEN
            CALL PUTBAK (C)
         ELSE 
            LEXSTR (1) = 10
         ENDIF 
         LEXSTR (2) = -2
         GTOK = LEXSTR (1)
         RETURN
      ENDIF 
      I = 1
      IF (((65.LE.C.AND.C.LE.90).OR.(97.LE.C.AND.C.LE.122)) ) THEN
         DO 1040 I = 1, TOKSIZ-3
            C = NGETCH (LEXSTR (I + 1))
            IF (.NOT.((65.LE.C.AND.C.LE.90).OR.(97.LE.C.AND.C.LE.122))
     1            .AND. .NOT.(48.LE.C.AND.C.LE.57) .AND. C .NE. 95 )
     2            THEN
               GOTO 1050 
            ENDIF 
1040     CONTINUE 
1050     CONTINUE 
         CALL PUTBAK (C)
         GTOK = -9
      ELSE IF (C .EQ. 64) THEN
         DO 1060 I = 1, TOKSIZ-3
            C = NGETCH (LEXSTR (I+1))
            IF (.NOT.((65.LE.C.AND.C.LE.90).OR.(97.LE.C.AND.C.LE.122))
     1            .AND. .NOT.(48.LE.C.AND.C.LE.57) .AND. C .NE.
     2            95 .AND. C .NE. 46) THEN
               GOTO 1070 
            ENDIF 
1060     CONTINUE 
1070     CONTINUE 
         CALL PUTBAK (C)
         GTOK = -9
      ELSE IF ((48.LE.C.AND.C.LE.57)) THEN
         B = C - 48
         DO 1080 I = 1, TOKSIZ-3
            C = NGETCH (LEXSTR (I + 1))
            IF (.NOT.(48.LE.C.AND.C.LE.57)) THEN
               GOTO 1090 
            ENDIF 
            B = 10 * B + C - 48
1080     CONTINUE 
1090     CONTINUE 
         IF (C .EQ. 37 .AND. B .GE. 2 .AND. B .LE. 36) THEN
            N = 0
1100        CONTINUE 
            D = INDX (DIGITS, CLOWER (NGETCH (C))) - 1
            IF (D .LT. 0) THEN
               GOTO 1120 
            ENDIF 
            N = B * N + D
1110        GOTO 1100 
1120        CONTINUE 
            CALL PUTBAK (C)
            I = ITOC (N, LEXSTR, TOKSIZ)
         ELSE 
            CALL PUTBAK (C)
         ENDIF 
         GTOK = 48
      ELSE IF (C .EQ. 91) THEN
         LEXSTR (1) = 123
         GTOK = 123
      ELSE IF (C .EQ. 93) THEN
         LEXSTR (1) = 125
         GTOK = 125
      ELSE IF (C .EQ. 36) THEN
         IF (NGETCH (LEXSTR (2)) .EQ. 40) THEN
            I = 2
            GTOK = 123
         ELSE IF (LEXSTR (2) .EQ. 41) THEN
            I = 2
            GTOK = 125
         ELSE IF (LEXSTR(2) .EQ. 93) THEN
            I = 2
            GTOK = -11
         ELSE IF (LEXSTR(2) .EQ. 123) THEN
            I = 2
            GTOK = -10
         ELSE 
            CALL PUTBAK (LEXSTR (2))
            GTOK = 36
         ENDIF 
      ELSE IF (C .EQ. 39 .OR. C .EQ. 34) THEN
         GTOK = C
         I = 2
1130     IF (.NOT.(NGETCH (LEXSTR (I)) .NE. LEXSTR (1)))GOTO 1170 
         IF (LEXSTR(I) .EQ. 64) THEN
            CALL COLLECTTOKEN (LEXSTR, I)
         ENDIF 
         IF (LEXSTR (I) .EQ. 95) THEN
            IF (NGETCH (C) .EQ. 10) THEN
1140           IF (C .EQ. 10 .OR. C .EQ. 32 .OR. C .EQ. 9) THEN
                  C = NGETCH (C)
                  GOTO 1140 
               ENDIF 
1150           CONTINUE 
               LEXSTR (I) = C
            ELSE 
               CALL PUTBAK (C)
            ENDIF 
         ENDIF 
         IF (LEXSTR (I) .EQ. 10 .OR. I .GE. TOKSIZ - 1) THEN
            CALL SYNERR (14Hmissing quote.)
            LEXSTR (I) = LEXSTR (1)
            CALL PUTBAK (10)
            GOTO 1170 
         ENDIF 
         IF (LEXSTR(I) .EQ. 64) THEN
            CALL PUTBAK (LEXSTR(I))
            I = I - 1
         ENDIF 
1160     I = I + 1
         GOTO 1130 
1170     CONTINUE 
      ELSE IF (C .EQ. 35) THEN
1180     IF (NGETCH (LEXSTR (1)) .NE. 10) THEN
            GOTO 1180 
         ENDIF 
1190     CONTINUE 
         GTOK = 10
      ELSE IF (C .EQ. 62 .OR. C .EQ. 60 .OR. C .EQ. 126 .OR. C .EQ
     1. 33 .OR. C.EQ.126 .OR. C .EQ. 94 .OR. C .EQ. 61 .OR. C .EQ
     2. 38 .OR. C .EQ. 124) THEN
         CALL RELATE (LEXSTR, I)
         GTOK = C
      ELSE 
         GTOK = C
      ENDIF 
      IF (I .GE. TOKSIZ - 1) THEN
         CALL SYNERR (15Htoken too long.)
      ENDIF 
      LEXSTR (I + 1) = -2
      RETURN
      END 
      SUBROUTINE IFCODE (LAB)
      INTEGER LAB
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      XFER = 0
      LAB = 0
      CALL IFTHEN
      RETURN
      END 
      SUBROUTINE IFGO (LAB)
      INTEGER LAB
      INTEGER IFNOT(10)
      DATA IFNOT(1)/105/,IFNOT(2)/102/,IFNOT(3)/32/,IFNOT(4)/40/,IFNOT(5
     *)/46/,IFNOT(6)/110/,IFNOT(7)/111/,IFNOT(8)/116/,IFNOT(9)/46/,IFNOT
     *(10)/-2/
      CALL OUTTAB
      CALL OUTSTR (IFNOT)
      CALL BALPAR
      CALL OUTCH (41)
      CALL OUTGO (LAB)
      RETURN
      END 
      INTEGER FUNCTION IFPARM (STRNG)
      INTEGER STRNG (100)
      INTEGER C
      INTEGER I, INDX, TYPE
      C = STRNG (1)
      IF (C .EQ.-12 .OR. C .EQ.-13 .OR. C .EQ.-11 .OR. C .EQ.-14 .OR. C.
     1EQ. -10) THEN
         IFPARM = 1
      ELSE 
         IFPARM = 0
         I = 1
1000     IF (.NOT.(INDX (STRNG (I), 36) .GT. 0))GOTO 1020 
         I = I + INDX (STRNG (I), 36)
         IF (TYPE (STRNG (I)) .EQ. 48) THEN
            IF (TYPE (STRNG (I + 1)) .NE. 48) THEN
               IFPARM = 1
               GOTO 1020 
            ENDIF 
         ENDIF 
1010     GOTO 1000 
1020     CONTINUE 
      ENDIF 
      RETURN
      END 
      SUBROUTINE INITKW
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER MKTABL
      CALL DSINIT (50000)
      DEFTBL = MKTABL (1)
      CALL ENTDKW
      RKWTBL = MKTABL (1)
      CALL ENTRKW
      FKWTBL = MKTABL (0)
      CALL ENTFKW
      NAMTBL = MKTABL (1)
      GENTBL = MKTABL (0)
      LABEL = 23000
      RETURN
      END 
      SUBROUTINE LABELC (LEXSTR)
      INTEGER LEXSTR (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER LENGTH
      XFER = 0
      IF (LENGTH (LEXSTR) .EQ. 5) THEN
         IF (LEXSTR (1) .EQ. 50 .AND. LEXSTR (2) .EQ. 51) THEN
            CALL SYNERR (33Hwarning: possible label conflict.)
         ENDIF 
      ENDIF 
      CALL OUTSTR (LEXSTR)
      CALL OUTTAB
      RETURN
      END 
      INTEGER FUNCTION LABGEN (N)
      INTEGER N
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      LABGEN = LABEL
      LABEL = LABEL + N
      RETURN
      END 
      INTEGER FUNCTION LEX (LEXSTR)
      INTEGER LEXSTR (100), TOKEN(100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER GNBTOK
      INTEGER LOOKUP
      LOGICAL PUSHBK
      SAVE LSAVE, TOKEN
      DATA PUSHBK/.FALSE./
      IF (PUSHBK) THEN
         GOTO 1030 
      ENDIF 
      LEX = GNBTOK (LEXSTR, 100)
1000  IF (.NOT.(LEX .EQ. 10))GOTO 1020 
1010  LEX = GNBTOK (LEXSTR, 100)
      GOTO 1000 
1020  CONTINUE 
      IF (LEX .EQ. -1 .OR. LEX .EQ. 59 .OR. LEX .EQ. 123 .OR. LEX .EQ.
     1125) THEN
         RETURN
      ENDIF 
      IF (LEX .EQ. 48) THEN
         LEX = -9
      ELSE IF (LEX .EQ. 37) THEN
         LEX = -27
      ELSE IF (LOOKUP (LEXSTR, LEX, RKWTBL) .EQ. 1) THEN
      ELSE 
         LEX = -14
      ENDIF 
      RETURN
1030  PUSHBK = .FALSE.
      CALL SCOPY (TOKEN, 1, LEXSTR, 1)
      LEX = LSAVE
      RETURN
      ENTRY PBLEX (LTYPE, LEXSTR)
      PUSHBK = .TRUE.
      CALL SCOPY (LEXSTR, 1, TOKEN, 1)
      LSAVE = LTYPE
      LEX = 0
      PBLEX = 0
      END 
      SUBROUTINE LITRAL
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER NGETCH
      IF (OUTP .GT. 0) THEN
         CALL OUTDON
      ENDIF 
      OUTP = 1
1000  IF (.NOT.(NGETCH (OUTBUF (OUTP)) .NE. 10))GOTO 1020 
1010  OUTP = OUTP + 1
      GOTO 1000 
1020  CONTINUE 
      OUTP = OUTP - 1
      CALL OUTDON
      RETURN
      END 
      SUBROUTINE LNDICT
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER SYM (100), C
      INTEGER CUPPER
      INTEGER SCTABL
      INTEGER POSN, LOCN
      POSN = 0
1000  IF (SCTABL (NAMTBL, SYM, LOCN, POSN) .NE. -1) THEN
         CALL PUTCH (67, 7)
         CALL PUTCH (32, 7)
1010     IF (.NOT.(MEM (LOCN) .NE. -2))GOTO 1030 
         C = MEM (LOCN)
         C = CUPPER (C)
         CALL PUTCH (C, 7)
1020     LOCN = LOCN + 1
         GOTO 1010 
1030     CONTINUE 
         CALL PUTCH (32, 7)
         CALL PUTCH (32, 7)
         CALL UPPER (SYM)
         CALL PUTLIN (SYM, 7)
         CALL PUTCH (10, 7)
         GOTO 1000 
      ENDIF 
1040  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION LUDEF (ID, DEFN, TABLE)
      INTEGER ID (100), DEFN (100)
      INTEGER TABLE
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER I
      INTEGER LOOKUP
      INTEGER LOCN
      LUDEF = LOOKUP (ID, LOCN, TABLE)
      IF (LUDEF .EQ. 1) THEN
         I = 1
1000     IF (.NOT.(MEM (LOCN) .NE. -2))GOTO 1020 
         DEFN (I) = MEM (LOCN)
         I = I + 1
1010     LOCN = LOCN + 1
         GOTO 1000 
1020     CONTINUE 
         DEFN (I) = -2
      ELSE 
         DEFN (1) = -2
      ENDIF 
      RETURN
      END 
      INTEGER FUNCTION NGETCH (C)
      INTEGER C
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER GETLIN
      IF (BUF (BP) .EQ. -2) THEN
         IF (GETLIN (BUF (400), INFILE (LEVEL)) .EQ. -1) THEN
            C = -1
         ELSE 
            C = BUF (400)
            BP = 400 + 1
            LINECT (LEVEL) = LINECT (LEVEL) + 1
            CALL STORER (BUF(400), INFILE(LEVEL), LINECT(LEVEL))
         ENDIF 
      ELSE 
         C = BUF (BP)
         BP = BP + 1
      ENDIF 
      NGETCH=(C)
      RETURN
      END 
      SUBROUTINE OTHERC (LEXSTR)
      INTEGER LEXSTR (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      XFER = 0
      CALL OUTTAB
      IF (((65.LE.LEXSTR (1).AND.LEXSTR (1).LE.90).OR.(97.LE.LEXSTR (1)
     1.AND.LEXSTR (1).LE.122))) THEN
         CALL SQUASH (LEXSTR)
      ENDIF 
      CALL OUTSTR (LEXSTR)
      CALL EATUP
      CALL OUTDON
      RETURN
      END 
      SUBROUTINE OUTCH (C)
      INTEGER C
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER I
      IF (OUTP .GE. 72) THEN
         CALL OUTDON
         DO 1000 I = 1, 5
            OUTBUF (I) = 32
1000     CONTINUE 
1010     CONTINUE 
         OUTBUF (6) = 42
         OUTP = 6
      ENDIF 
      OUTP = OUTP + 1
      OUTBUF (OUTP) = C
      RETURN
      END 
      SUBROUTINE OUTCON (N)
      INTEGER N
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      INTEGER CONTIN(9)
      DATA CONTIN(1)/99/,CONTIN(2)/111/,CONTIN(3)/110/,CONTIN(4)/116/,CO
     *NTIN(5)/105/,CONTIN(6)/110/,CONTIN(7)/117/,CONTIN(8)/101/,CONTIN(9
     *)/-2/
      XFER = 0
      IF (N .LE. 0 .AND. OUTP .EQ. 0) THEN
         RETURN
      ENDIF 
      IF (N .GT. 0) THEN
         CALL OUTNUM (N)
      ENDIF 
      CALL OUTTAB
      CALL OUTSTR (CONTIN)
      CALL OUTDON
      RETURN
      END 
      SUBROUTINE OUTDON
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       LOGICAL LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /KEYSTUFF/ KEY
      INTEGER ALLBLK
      OUTBUF (OUTP + 1) = 10
      OUTBUF (OUTP + 2) = -2
      IF (ALLBLK (OUTBUF) .EQ. 0) THEN
         CALL STOREF (OUTBUF)
         IF (KEYSEQ) THEN
            DO 1000 I = OUTP+1, 72
               OUTBUF(I) = 32
1000        CONTINUE 
1010        CONTINUE 
            IF (LEVEL .GE. 1) THEN
               I = LEVEL
            ELSE 
               I = 1
            ENDIF 
            IF (KEY .LT. 0) THEN
               CALL DECIMAL (LINECT(I), OUTBUF(73), 8)
               OUTBUF(81) = 10
               OUTBUF(82) = -2
            ELSE 
               CALL DECIMAL (KEY/1000, OUTBUF(73), 5)
               CALL DECIMAL (MOD (KEY,1000)+1000, OUTBUF(78), 4)
               OUTBUF(78) = 46
               OUTBUF(82) = 10
               OUTBUF(83) = -2
            ENDIF 
         ENDIF 
         CALL PUTLIN (OUTBUF, 2)
      ENDIF 
      OUTP = 0
      RETURN
      END 
      SUBROUTINE OUTGO (N)
      INTEGER N
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      INTEGER SGOTO(6)
      DATA SGOTO(1)/103/,SGOTO(2)/111/,SGOTO(3)/116/,SGOTO(4)/111/,SGOTO
     *(5)/32/,SGOTO(6)/-2/
      IF (XFER .EQ. 1) THEN
         RETURN
      ENDIF 
      CALL OUTTAB
      CALL OUTSTR (SGOTO)
      CALL OUTNUM (N)
      CALL OUTDON
      RETURN
      END 
      SUBROUTINE OUTNUM (N)
      INTEGER N
      INTEGER CHARS (20)
      INTEGER I, M
      M = IABS (N)
      I = 0
1000  CONTINUE 
      I = I + 1
      CHARS (I) = MOD (M, 10) + 48
      M = M / 10
1010  IF (.NOT.(M .EQ. 0 .OR. I .GE. 20))GOTO 1000 
1020  CONTINUE 
      IF (N .LT. 0) THEN
         CALL OUTCH (45)
      ENDIF 
1030  IF (.NOT.(I .GT. 0))GOTO 1050 
      CALL OUTCH (CHARS (I))
1040  I = I - 1
      GOTO 1030 
1050  CONTINUE 
      RETURN
      END 
      SUBROUTINE OUTSTR (STR)
      INTEGER STR (100)
      INTEGER C
      INTEGER CUPPER
      INTEGER I, J
      I = 1
1000  IF (.NOT.(STR (I) .NE. -2))GOTO 1080 
      C = STR (I)
      IF (C .NE. 39 .AND. C .NE. 34) THEN
         C = CUPPER (C)
         CALL OUTCH (C)
      ELSE 
         I = I + 1
         J = I
1010     IF (.NOT.(STR (J) .NE. C))GOTO 1030 
1020     J = J + 1
         GOTO 1010 
1030     CONTINUE 
         IF (C .EQ. 39) THEN
            CALL OUTCH (39)
         ELSE 
            CALL OUTNUM (J - I)
            CALL OUTCH (72)
         ENDIF 
1040     IF (.NOT.(I .LT. J))GOTO 1060 
         CALL OUTCH (STR (I))
1050     I = I + 1
         GOTO 1040 
1060     CONTINUE 
         IF (C .EQ. 39) THEN
            CALL OUTCH (39)
         ENDIF 
      ENDIF 
1070  I = I + 1
      GOTO 1000 
1080  CONTINUE 
      RETURN
      END 
      SUBROUTINE OUTTAB
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
1000  IF (OUTP .LT. 6) THEN
         CALL OUTCH (32)
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      RETURN
      END 
      SUBROUTINE PARSE
      DIMENSION ISAVESP(100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER LEXSTR (100)
      INTEGER LAB, LABVAL (100), LEXTYP (100), SP, TOKEN, I
      INTEGER LEX, PBLEX
      CALL FINIT
      SP = 1
      LEXTYP (1) = -1
      ISP = 0
      TOKEN = LEX (LEXSTR)
1000  IF (.NOT.(TOKEN .NE. -1))GOTO 1100 
      IF (TOKEN .EQ. -19) THEN
         CALL IFCODE (LAB)
      ELSE IF (TOKEN .EQ. -10) THEN
         CALL DOCODE (LAB)
      ELSE IF (TOKEN .EQ. -15) THEN
         CALL WHILEC (LAB)
      ELSE IF (TOKEN .EQ. -16) THEN
         CALL FORCOD (LAB)
      ELSE IF (TOKEN .EQ. -17) THEN
         CALL REPCOD (LAB)
      ELSE IF (TOKEN .EQ. -24) THEN
         CALL SWCODE (LAB)
      ELSE IF (TOKEN .EQ. -25 .OR. TOKEN .EQ. -26) THEN
         DO 1010 I = SP, 1, -1
            IF (LEXTYP (I) .EQ. -24) THEN
               GOTO 1020 
            ENDIF 
1010     CONTINUE 
1020     CONTINUE 
         IF (I .EQ. 0) THEN
            CALL SYNERR (24Hillegal case or default.)
         ELSE 
            CALL CASCOD (LABVAL (I), TOKEN)
         ENDIF 
      ELSE IF (TOKEN .EQ. -9) THEN
         CALL LABELC (LEXSTR)
      ELSE IF (TOKEN .EQ. -11) THEN
         IF (LEXTYP (SP) .EQ. -19) THEN
            CALL ELSEIF (LABVAL (SP))
         ELSE 
            CALL SYNERR (13Hillegal else.)
         ENDIF 
      ELSE IF (TOKEN .EQ. -27) THEN
         CALL LITRAL
      ENDIF 
      IF (TOKEN .EQ. -19 .OR. TOKEN .EQ. -15 .OR. TOKEN .EQ. -16 .OR.
     1TOKEN .EQ. -17 .OR. TOKEN .EQ. -24 .OR. TOKEN .EQ. -10 .OR.
     2TOKEN .EQ. -9 .OR. TOKEN .EQ. 123) THEN
         SP = SP + 1
         IF (SP .GT. 100) THEN
            CALL BADERR (25Hstack overflow in parser.)
         ENDIF 
         LEXTYP (SP) = TOKEN
         LABVAL (SP) = LAB
      ELSE IF (TOKEN .EQ. -11) THEN
         NEWTOKEN = LEX(LEXSTR)
         IF (NEWTOKEN .NE. -19) THEN
            CALL OUTDON
            ISP = ISP + 1
            ISAVESP(ISP) = SP + 1
         ENDIF 
         IDUMMY = PBLEX (NEWTOKEN, LEXSTR)
         SP = SP + 1
         IF (SP .GT. 100) THEN
            CALL BADERR (25HSTACK OVERFLOW IN PARSER.)
         ENDIF 
         LEXTYP(SP) = TOKEN
         LABVAL(SP) = LAB
      ELSE IF (TOKEN .NE. -25 .AND. TOKEN .NE. -26) THEN
         IF (TOKEN .EQ. 125) THEN
            IF (LEXTYP (SP) .EQ. 123) THEN
               SP = SP - 1
            ELSE IF (LEXTYP (SP) .EQ. -24) THEN
               CALL SWEND (LABVAL (SP))
               SP = SP - 1
            ELSE 
               CALL SYNERR (20Hillegal right brace.)
            ENDIF 
         ELSE IF (TOKEN .EQ. -14) THEN
            CALL OTHERC (LEXSTR)
         ELSE IF (TOKEN .EQ. -8 .OR. TOKEN .EQ. -13) THEN
            CALL BRKNXT (SP, LEXTYP, LABVAL, TOKEN)
         ELSE IF (TOKEN .EQ. -20) THEN
            CALL RETCOD
         ELSE IF (TOKEN .EQ. -23) THEN
            CALL STRDCL
         ENDIF 
         TOKEN = LEX (LEXSTR)
         IDUMMY = PBLEX (TOKEN, LEXSTR)
         I=ISP
1030     IF (.NOT.(I.GT.0))GOTO 1050 
         IF (ISAVESP(I) .GE. SP) THEN
            CALL IFEND
            ISP = ISP - 1
         ENDIF 
1040     I=I-1
         GOTO 1030 
1050     CONTINUE 
         CALL UNSTAK (SP, LEXTYP, LABVAL, TOKEN)
         I=ISP
1060     IF (.NOT.(I.GT.0))GOTO 1080 
         IF (ISAVESP(I) .GE. SP) THEN
            CALL IFEND
            ISP = ISP - 1
         ENDIF 
1070     I=I-1
         GOTO 1060 
1080     CONTINUE 
      ENDIF 
1090  TOKEN = LEX (LEXSTR)
      GOTO 1000 
1100  CONTINUE 
      IF (SP .NE. 1) THEN
         CALL SYNERR (15Hunexpected EOF.)
      ENDIF 
      RETURN
      END 
      SUBROUTINE PBNUM (N)
      INTEGER N
      INTEGER M, NUM
      INTEGER MOD
      INTEGER DIGITS(11)
      DATA DIGITS(1)/48/,DIGITS(2)/49/,DIGITS(3)/50/,DIGITS(4)/51/,DIGIT
     *S(5)/52/,DIGITS(6)/53/,DIGITS(7)/54/,DIGITS(8)/55/,DIGITS(9)/56/,D
     *IGITS(10)/57/,DIGITS(11)/-2/
      NUM = IABS (N)
1000  CONTINUE 
      M = MOD (NUM, 10)
      CALL PUTBAK (DIGITS (M + 1))
      NUM = NUM / 10
1010  IF (.NOT.(NUM .EQ. 0))GOTO 1000 
1020  CONTINUE 
      IF (N .LT. 0) THEN
         CALL PUTBAK (45)
      ENDIF 
      RETURN
      END 
      SUBROUTINE PBSTR (IN)
      INTEGER IN (100)
      INTEGER I
      INTEGER LENGTH
      DO 1000 I = LENGTH (IN), 1, -1
         CALL PUTBAK (IN (I))
1000  CONTINUE 
1010  CONTINUE 
      RETURN
      END 
      INTEGER FUNCTION PUSH (EP, ARGSTK, AP)
      INTEGER AP, ARGSTK (100), EP
      IF (AP .GT. 100) THEN
         CALL BADERR ('arg stack overflow.')
      ENDIF 
      ARGSTK (AP) = EP
      PUSH = AP + 1
      RETURN
      END 
      SUBROUTINE PUTBAK (C)
      INTEGER C
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      IF (BP .LE. 1) THEN
         CALL BADERR (32Htoo many characters pushed back.)
      ELSE 
         BP = BP - 1
         BUF (BP) = C
      ENDIF 
      RETURN
      END 
      SUBROUTINE PUTCHR (C)
      INTEGER C
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      IF (EP .GT. 500) THEN
         CALL BADERR ('evaluation stack overflow.')
      ENDIF 
      EVALST (EP) = C
      EP = EP + 1
      RETURN
      END 
      SUBROUTINE PUTTOK (STR)
      INTEGER STR (100)
      INTEGER I
      I = 1
1000  IF (.NOT.(STR (I) .NE. -2))GOTO 1020 
      CALL PUTCHR (STR (I))
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      SUBROUTINE RELATE (TOKEN, LAST)
      INTEGER TOKEN (100)
      INTEGER LAST
      INTEGER NGETCH
      INTEGER LENGTH
      INTEGER T1, T2
      INTEGER SAND(6)
      INTEGER SOR(5)
      INTEGER SNOT(6)
      INTEGER SLT(5)
      INTEGER SGT(5)
      INTEGER SGE(5)
      INTEGER SLE(5)
      INTEGER SEQ(5)
      INTEGER SNE(5)
      DATA SAND(1)/46/,SAND(2)/65/,SAND(3)/78/,SAND(4)/68/,SAND(5)/46/,S
     *AND(6)/-2/
      DATA SOR(1)/46/,SOR(2)/79/,SOR(3)/82/,SOR(4)/46/,SOR(5)/-2/
      DATA SNOT(1)/46/,SNOT(2)/78/,SNOT(3)/79/,SNOT(4)/84/,SNOT(5)/46/,S
     *NOT(6)/-2/
      DATA SLT(1)/46/,SLT(2)/76/,SLT(3)/84/,SLT(4)/46/,SLT(5)/-2/
      DATA SGT(1)/46/,SGT(2)/71/,SGT(3)/84/,SGT(4)/46/,SGT(5)/-2/
      DATA SGE(1)/46/,SGE(2)/71/,SGE(3)/69/,SGE(4)/46/,SGE(5)/-2/
      DATA SLE(1)/46/,SLE(2)/76/,SLE(3)/69/,SLE(4)/46/,SLE(5)/-2/
      DATA SEQ(1)/46/,SEQ(2)/69/,SEQ(3)/81/,SEQ(4)/46/,SEQ(5)/-2/
      DATA SNE(1)/46/,SNE(2)/78/,SNE(3)/69/,SNE(4)/46/,SNE(5)/-2/
      IDUMMY = NGETCH (TOKEN(2))
      IF (TOKEN(2) .NE. 61 .AND. TOKEN(2) .NE. 62 .AND. TOKEN(2) .NE.
     160) THEN
         CALL PUTBAK (TOKEN(2))
         TOKEN(2) = 32
      ENDIF 
      T1 = TOKEN(1)
      T2 = TOKEN(2)
      IF (T1 .EQ. 126 .OR. T1 .EQ. 94) THEN
         T1 = 33
      ENDIF 
      IF (T1 .EQ. 38) THEN
         CALL SCOPY (SAND, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 33 .AND. T2 .EQ. 32) THEN
         CALL SCOPY (SNOT, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 124) THEN
         CALL SCOPY (SOR, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 60 .AND. T2 .EQ. 32) THEN
         CALL SCOPY (SLT, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 62 .AND. T2 .EQ. 32) THEN
         CALL SCOPY (SGT, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 33 .AND. T2 .EQ. 61) THEN
         CALL SCOPY (SNE, 1, TOKEN, 1)
      ELSE IF (T1 .EQ. 61 .AND. T2 .EQ. 61) THEN
         CALL SCOPY (SEQ, 1, TOKEN, 1)
      ELSE IF ((T1 .EQ. 60 .AND. T2 .EQ. 62) .OR. (T1 .EQ. 62 .AND. T2 
     1.EQ. 60)) THEN
         CALL SCOPY (SNE, 1, TOKEN, 1)
      ELSE IF ((T1 .EQ. 62 .AND. T2 .EQ. 61) .OR. (T1 .EQ. 61 .AND. T2 
     1.EQ. 62)) THEN
         CALL SCOPY (SGE, 1, TOKEN, 1)
      ELSE IF ((T1 .EQ. 60 .AND. T2 .EQ. 61) .OR. (T1 .EQ. 61 .AND. T2 
     1.EQ. 60)) THEN
         CALL SCOPY (SLE, 1, TOKEN, 1)
      ELSE 
         TOKEN(2) = -2
      ENDIF 
      LAST = LENGTH (TOKEN)
      END 
      SUBROUTINE REPCOD (LAB)
      INTEGER LAB
      INTEGER LABGEN
      CALL OUTCON (0)
      LAB = LABGEN (3)
      CALL OUTCON (LAB)
      LAB = LAB + 1
      RETURN
      END 
      SUBROUTINE RETCOD
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER TOKEN (100), T
      INTEGER GNBTOK
      INTEGER SRET(7)
      DATA SRET(1)/114/,SRET(2)/101/,SRET(3)/116/,SRET(4)/117/,SRET(5)/1
     *14/,SRET(6)/110/,SRET(7)/-2/
      T = GNBTOK (TOKEN, 100)
      IF (T .NE. 10 .AND. T .NE. 59 .AND. T .NE. 125) THEN
         CALL PBSTR (TOKEN)
         CALL OUTTAB
         CALL SCOPY (FCNAME, 1, TOKEN, 1)
         CALL SQUASH (TOKEN)
         CALL OUTSTR (TOKEN)
         CALL OUTCH (61)
         CALL EATUP
         CALL OUTDON
      ELSE IF (T .EQ. 125) THEN
         CALL PBSTR (TOKEN)
      ENDIF 
      CALL OUTTAB
      CALL OUTSTR (SRET)
      CALL OUTDON
      XFER = 1
      RETURN
      END 
      INTEGER FUNCTION SDUPL (STR)
      INTEGER STR (100)
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL(BUF=50) /CDSMEM/
      INTEGER I
      INTEGER LENGTH
      INTEGER J
      INTEGER DSGET
      J = DSGET (LENGTH (STR) + 1)
      SDUPL = J
      I = 1
1000  IF (.NOT.(STR (I) .NE. -2))GOTO 1020 
      MEM (J) = STR (I)
      J = J + 1
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      MEM (J) = -2
      RETURN
      END 
      SUBROUTINE SKPBLK
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER C
      INTEGER NGETCH
      C = NGETCH (C)
1000  IF (.NOT.(C .EQ. 32 .OR. C .EQ. 9))GOTO 1020 
1010  C = NGETCH (C)
      GOTO 1000 
1020  CONTINUE 
      CALL PUTBAK (C)
      RETURN
      END 
      SUBROUTINE SQUASH (ID)
      INTEGER ID (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       COMMON /CMAXID/ MAXID
      INTEGER JUNK, I, J
      INTEGER LOOKUP
      INTEGER NEWID (100), RECDID (100)
      IF (MAXID .EQ. 0) THEN
         RETURN
      ENDIF 
      J = 1
      I = 1
1000  IF (.NOT.(ID (I) .NE. -2))GOTO 1020 
      IF (((65.LE.ID (I).AND.ID (I).LE.90).OR.(97.LE.ID (I).AND.ID (I)
     1.LE.122)) .OR. (48.LE.ID (I).AND.ID (I).LE.57)) THEN
         NEWID (J) = ID (I)
         J = J + 1
      ENDIF 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      NEWID (J) = -2
      IF (I - 1 .LT. MAXID .AND. I .EQ. J) THEN
         RETURN
      ENDIF 
      IF (I - 1 .EQ. MAXID .AND. I .EQ. J) THEN
         IF (ID (MAXID) .NE. 48) THEN
            RETURN
         ENDIF 
      ENDIF 
      IF (LOOKUP (ID, JUNK, FKWTBL) .EQ. 1) THEN
         RETURN
      ENDIF 
      IF (LUDEF (ID, RECDID, NAMTBL) .EQ. 1) THEN
         CALL SCOPY (RECDID, 1, ID, 1)
         RETURN
      ENDIF 
      CALL UNIQID (NEWID)
      CALL ENTDEF (ID, NEWID, NAMTBL)
      CALL SCOPY (NEWID, 1, ID, 1)
      RETURN
      END 
      SUBROUTINE STRDCL
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER T, TOKEN (100), DCHAR (100)
      INTEGER GNBTOK
      INTEGER I, J, K, N, LEN, PBLEX, ADDSTR
      INTEGER LENGTH, CTOI, LEX
      INTEGER CHAR(11)
      INTEGER DAT(6)
      INTEGER EOSS(5)
      DATA CHAR(1)/99/,CHAR(2)/104/,CHAR(3)/97/,CHAR(4)/114/,CHAR(5)/97/
     *,CHAR(6)/99/,CHAR(7)/116/,CHAR(8)/101/,CHAR(9)/114/,CHAR(10)/47/,C
     *HAR(11)/-2/
      DATA DAT(1)/100/,DAT(2)/97/,DAT(3)/116/,DAT(4)/97/,DAT(5)/32/,DAT(
     *6)/-2/
      DATA EOSS(1)/69/,EOSS(2)/79/,EOSS(3)/83/,EOSS(4)/47/,EOSS(5)/-2/
      T = GNBTOK (TOKEN, 100)
      IF (T .NE. -9) THEN
         CALL SYNERR (21Hmissing string token.)
      ENDIF 
      CALL SQUASH (TOKEN)
      CALL OUTTAB
      CALL PBSTR (CHAR)
1000  CONTINUE 
      T = GNBTOK (DCHAR, 100)
      IF (T .EQ. 47) THEN
         GOTO 1020 
      ENDIF 
      CALL OUTSTR (DCHAR)
1010  GOTO 1000 
1020  CONTINUE 
      CALL OUTCH (32)
      CALL OUTSTR (TOKEN)
      IDUM = ADDSTR (TOKEN, SBUF, SBP, 500)
      CALL ADDCHR (-2, SBUF, SBP, 500)
      IF (GNBTOK (TOKEN, 100) .NE. 40) THEN
         LEN = LENGTH (TOKEN) + 1
         IF (TOKEN (1) .EQ. 39 .OR. TOKEN (1) .EQ. 34) THEN
            LEN = LEN - 2
         ENDIF 
      ELSE 
         T = GNBTOK (TOKEN, 100)
         I = 1
         LEN = CTOI (TOKEN, I)
         IF (TOKEN (I) .NE. -2) THEN
            CALL SYNERR (20Hinvalid string size.)
         ENDIF 
         IF (GNBTOK (TOKEN, 100) .NE. 41) THEN
            CALL SYNERR (20Hmissing right paren.)
         ELSE 
            T = GNBTOK (TOKEN, 100)
         ENDIF 
      ENDIF 
      CALL OUTCH (40)
      CALL OUTNUM (LEN)
      CALL OUTCH (41)
      CALL OUTDON
      IF (TOKEN (1) .EQ. 39 .OR. TOKEN (1) .EQ. 34) THEN
         LEN = LENGTH (TOKEN)
         TOKEN (LEN) = -2
         IDUM = ADDSTR (TOKEN (2), SBUF, SBP, 500)
      ELSE 
         IDUM = ADDSTR (TOKEN, SBUF, SBP, 500)
      ENDIF 
      CALL ADDCHR (-2, SBUF, SBP, 500)
      T = LEX (TOKEN)
      IDUMMY = PBLEX (T, TOKEN)
      IF (T .NE. -23) THEN
         I = 1
1030     IF (.NOT.(I .LT. SBP))GOTO 1110 
         CALL OUTTAB
         CALL OUTSTR (DAT)
         K = 1
         J = I + LENGTH (SBUF (I)) + 1
1040     CONTINUE 
         IF (K .GT. 1) THEN
            CALL OUTCH (44)
         ENDIF 
         CALL OUTSTR (SBUF (I))
         CALL OUTCH (40)
         CALL OUTNUM (K)
         CALL OUTCH (41)
         CALL OUTCH (47)
         IF (SBUF (J) .EQ. -2) THEN
            GOTO 1060 
         ENDIF 
         N = SBUF (J)
         CALL OUTNUM (N)
         CALL OUTCH (47)
         K = K + 1
1050     J = J + 1
         GOTO 1040 
1060     CONTINUE 
         CALL PBSTR (EOSS)
1070     CONTINUE 
         T = GNBTOK (TOKEN, 100)
         CALL OUTSTR (TOKEN)
1080     IF (.NOT.(T .EQ. 47))GOTO 1070 
1090     CONTINUE 
         CALL OUTDON
1100     I = J + 1
         GOTO 1030 
1110     CONTINUE 
         SBP = 1
      ENDIF 
      RETURN
      END 
      SUBROUTINE SWCODE (LAB)
      INTEGER LAB, T
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER TOK (100)
      INTEGER LABGEN, GNBTOK
      LAB = LABGEN (2)
      IF (SWLAST + 3 .GT. 1000) THEN
         CALL BADERR (22Hswitch table overflow.)
      ENDIF 
      SWSTAK (SWLAST) = SWTOP
      SWSTAK (SWLAST + 1) = 0
      SWSTAK (SWLAST + 2) = 0
      SWTOP = SWLAST
      SWLAST = SWLAST + 3
      XFER = 0
      CALL OUTTAB
      CALL SWVAR (LAB)
      CALL OUTCH (61)
      CALL BALPAR
      CALL OUTDON
      CALL OUTGO (LAB)
      XFER = 1
1000  CONTINUE 
      T = GNBTOK (TOK, 100)
1010  IF (.NOT.(T .NE. 10))GOTO 1000 
1020  CONTINUE 
      IF (T .NE. 123) THEN
         CALL SYNERR (39Hmissing left brace in switch statement.)
         CALL PBSTR (TOK)
      ENDIF 
      RETURN
      END 
      SUBROUTINE SWEND (LAB)
      INTEGER LAB
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER LB, UB, N, I, J
      INTEGER SIF(5)
      INTEGER SLT(10)
      INTEGER SGT(5)
      INTEGER SGOTO(7)
      INTEGER SEQ(5)
      INTEGER SGE(5)
      INTEGER SLE(5)
      INTEGER SAND(6)
      DATA SIF(1)/105/,SIF(2)/102/,SIF(3)/32/,SIF(4)/40/,SIF(5)/-2/
      DATA SLT(1)/46/,SLT(2)/108/,SLT(3)/116/,SLT(4)/46/,SLT(5)/49/,SLT(
     *6)/46/,SLT(7)/111/,SLT(8)/114/,SLT(9)/46/,SLT(10)/-2/
      DATA SGT(1)/46/,SGT(2)/103/,SGT(3)/116/,SGT(4)/46/,SGT(5)/-2/
      DATA SGOTO(1)/103/,SGOTO(2)/111/,SGOTO(3)/116/,SGOTO(4)/111/,SGOTO
     *(5)/32/,SGOTO(6)/40/,SGOTO(7)/-2/
      DATA SEQ(1)/46/,SEQ(2)/101/,SEQ(3)/113/,SEQ(4)/46/,SEQ(5)/-2/
      DATA SGE(1)/46/,SGE(2)/103/,SGE(3)/101/,SGE(4)/46/,SGE(5)/-2/
      DATA SLE(1)/46/,SLE(2)/108/,SLE(3)/101/,SLE(4)/46/,SLE(5)/-2/
      DATA SAND(1)/46/,SAND(2)/97/,SAND(3)/110/,SAND(4)/100/,SAND(5)/46/
     *,SAND(6)/-2/
      LB = SWSTAK (SWTOP + 3)
      UB = SWSTAK (SWLAST - 2)
      N = SWSTAK (SWTOP + 1)
      CALL OUTGO (LAB + 1)
      IF (SWSTAK (SWTOP + 2) .EQ. 0) THEN
         SWSTAK (SWTOP + 2) = LAB + 1
      ENDIF 
      XFER = 0
      CALL OUTCON (LAB)
      IF (N .GE. 3 .AND. UB - LB + 1 .LT. 2 * N) THEN
         IF (LB .NE. 1) THEN
            CALL OUTTAB
            CALL SWVAR (LAB)
            CALL OUTCH (61)
            CALL SWVAR (LAB)
            IF (LB .LT. 1) THEN
               CALL OUTCH (43)
            ENDIF 
            CALL OUTNUM (-LB + 1)
            CALL OUTDON
         ENDIF 
         CALL OUTTAB
         CALL OUTSTR (SIF)
         CALL SWVAR (LAB)
         CALL OUTSTR (SLT)
         CALL SWVAR (LAB)
         CALL OUTSTR (SGT)
         CALL OUTNUM (UB - LB + 1)
         CALL OUTCH (41)
         CALL OUTGO (SWSTAK (SWTOP + 2))
         CALL OUTTAB
         CALL OUTSTR (SGOTO)
         J = LB
         I = SWTOP + 3
1000     IF (.NOT.(I .LT. SWLAST))GOTO 1080 
1010     IF (.NOT.(J .LT. SWSTAK (I)))GOTO 1030 
         CALL OUTNUM (SWSTAK (SWTOP + 2))
         CALL OUTCH (44)
1020     J = J + 1
         GOTO 1010 
1030     CONTINUE 
         J = SWSTAK(I + 1) - SWSTAK (I)
1040     IF (.NOT.(J.GE.0))GOTO 1060 
         CALL OUTNUM (SWSTAK (I + 2))
         IF (J .GT. 0) THEN
            CALL OUTCH (44)
         ENDIF 
1050     J = J -1
         GOTO 1040 
1060     CONTINUE 
         J = SWSTAK (I + 1) + 1
         IF (I .LT. SWLAST - 3) THEN
            CALL OUTCH (44)
         ENDIF 
1070     I = I + 3
         GOTO 1000 
1080     CONTINUE 
         CALL OUTCH (41)
         CALL OUTCH (44)
         CALL SWVAR (LAB)
         CALL OUTDON
      ELSE IF (N .GT. 0) THEN
         I = SWTOP + 3
1090     IF (.NOT.(I .LT. SWLAST))GOTO 1110 
         CALL OUTTAB
         CALL OUTSTR (SIF)
         CALL SWVAR (LAB)
         IF (SWSTAK (I) .EQ. SWSTAK (I+1)) THEN
            CALL OUTSTR (SEQ)
            CALL OUTNUM (SWSTAK (I))
         ELSE 
            CALL OUTSTR (SGE)
            CALL OUTNUM (SWSTAK (I))
            CALL OUTSTR (SAND)
            CALL SWVAR (LAB)
            CALL OUTSTR (SLE)
            CALL OUTNUM (SWSTAK (I + 1))
         ENDIF 
         CALL OUTCH (41)
         CALL OUTGO (SWSTAK (I + 2))
1100     I = I + 3
         GOTO 1090 
1110     CONTINUE 
         IF (LAB + 1 .NE. SWSTAK (SWTOP + 2)) THEN
            CALL OUTGO (SWSTAK (SWTOP + 2))
         ENDIF 
      ENDIF 
      CALL OUTCON (LAB + 1)
      SWLAST = SWTOP
      SWTOP = SWSTAK (SWTOP)
      RETURN
      END 
      SUBROUTINE SWVAR (LAB)
      INTEGER LAB
      CALL OUTCH (73)
      CALL OUTNUM (LAB)
      RETURN
      END 
      SUBROUTINE SYNERR (MSG)
      INTEGER MSG (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       COMMON /ECOUNT/ NERRORS
      LOGICAL KEYFLAG
      COMMON /KEYEDIN/ KEYFLAG
      INTEGER LC (20)
      INTEGER I, JUNK
      INTEGER ITOC
      INTEGER IN(5)
      INTEGER ERRMSG(16)
      DATA IN(1)/32/,IN(2)/105/,IN(3)/110/,IN(4)/32/,IN(5)/-2/
      DATA ERRMSG(1)/32/,ERRMSG(2)/101/,ERRMSG(3)/114/,ERRMSG(4)/114/,ER
     *RMSG(5)/111/,ERRMSG(6)/114/,ERRMSG(7)/32/,ERRMSG(8)/97/,ERRMSG(9)/
     *116/,ERRMSG(10)/32/,ERRMSG(11)/108/,ERRMSG(12)/105/,ERRMSG(13)/110
     */,ERRMSG(14)/101/,ERRMSG(15)/32/,ERRMSG(16)/-2/
      NERRORS = NERRORS + 1
      CALL PUTLIN (ERRMSG, 3)
      IF (LEVEL .GE. 1) THEN
         I = LEVEL
      ELSE 
         I = 1
      ENDIF 
      JUNK = ITOC (LINECT (I), LC, 20)
      CALL PUTLIN (LC, 3)
      I = FNAMP - 1
1000  IF (.NOT.(I .GT. 1))GOTO 1020 
      IF (FNAMES (I - 1) .EQ. -2) THEN
         CALL PUTLIN (IN, 3)
         CALL PUTLIN (FNAMES (I), 3)
         GOTO 1020 
      ENDIF 
1010  I = I - 1
      GOTO 1000 
1020  CONTINUE 
      CALL PUTCH (58, 3)
      IF (KEYFLAG) THEN
         CALL KEYOUT (1, 3)
      ENDIF 
      CALL PUTCH (10, 3)
      CALL REMARK (MSG)
      RETURN
      END 
      SUBROUTINE ULSTAL (NAME, DEFN)
      INTEGER NAME (100), DEFN (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      CALL ENTDEF (NAME, DEFN, DEFTBL)
      CALL UPPER (NAME)
      CALL ENTDEF (NAME, DEFN, DEFTBL)
      RETURN
      END 
      SUBROUTINE UNIQID (ID)
      INTEGER ID (100)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       COMMON /CMAXID/ MAXID
      INTEGER I, J, JUNK, IDCHL
      INTEGER LOOKUP, INDX, LENGTH
      INTEGER START (100)
      INTEGER IDCH(37)
      DATA IDCH(1)/48/,IDCH(2)/49/,IDCH(3)/50/,IDCH(4)/51/,IDCH(5)/52/,I
     *DCH(6)/53/,IDCH(7)/54/,IDCH(8)/55/,IDCH(9)/56/,IDCH(10)/57/,IDCH(1
     *1)/97/,IDCH(12)/98/,IDCH(13)/99/,IDCH(14)/100/,IDCH(15)/101/,IDCH(
     *16)/102/,IDCH(17)/103/,IDCH(18)/104/,IDCH(19)/105/,IDCH(20)/106/,I
     *DCH(21)/107/,IDCH(22)/108/,IDCH(23)/109/,IDCH(24)/110/,IDCH(25)/11
     *1/,IDCH(26)/112/,IDCH(27)/113/,IDCH(28)/114/,IDCH(29)/115/,IDCH(30
     *)/116/,IDCH(31)/117/,IDCH(32)/118/,IDCH(33)/119/,IDCH(34)/120/,IDC
     *H(35)/121/,IDCH(36)/122/,IDCH(37)/-2/
      I = 1
1000  IF (.NOT.(ID (I) .NE. -2))GOTO 1020 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      DO 1030 J = I, MAXID
         ID (J) = 48
1030  CONTINUE 
1040  CONTINUE 
      I = MAXID + 1
      ID (I) = -2
      ID (I - 1) = 48
      IF (LOOKUP (ID, JUNK, GENTBL) .EQ. 1) THEN
         IDCHL = LENGTH (IDCH)
         DO 1050 I = 2, MAXID-1
            START (I) = ID (I)
1050     CONTINUE 
1060     CONTINUE 
1070     CONTINUE 
         DO 1080 I = MAXID-1, 2, -1
            J = MOD (INDX (IDCH, ID (I)), IDCHL) + 1
            ID (I) = IDCH (J)
            IF (ID (I) .NE. START (I)) THEN
               GOTO 1090 
            ENDIF 
1080     CONTINUE 
1090     CONTINUE 
         IF (I .EQ. 1) THEN
            CALL BADERR (30Hcannot make identifier unique.)
         ENDIF 
1100     IF (.NOT.(LOOKUP (ID, JUNK, GENTBL) .EQ. 0))GOTO 1070 
1110     CONTINUE 
      ENDIF 
      CALL ENTER (ID, 0, GENTBL)
      RETURN
      END 
      SUBROUTINE UNSTAK (SP, LEXTYP, LABVAL, TOKEN)
      INTEGER LABVAL (100), LEXTYP (100), SP, TOKEN
1000  IF (.NOT.(SP .GT. 1))GOTO 1020 
      IF (LEXTYP (SP) .EQ. 123 .OR. LEXTYP (SP) .EQ. -24) THEN
         GOTO 1020 
      ENDIF 
      IF (LEXTYP (SP) .EQ. -19 .AND. TOKEN .EQ. -11) THEN
         GOTO 1020 
      ENDIF 
      IF (LEXTYP (SP) .EQ. -19) THEN
         CALL IFEND
      ELSE IF (LEXTYP (SP) .EQ. -11) THEN
         IF (SP .GT. 2) THEN
            SP = SP - 1
         ENDIF 
      ELSE IF (LEXTYP (SP) .EQ. -10) THEN
         CALL DOSTAT (LABVAL (SP))
      ELSE IF (LEXTYP (SP) .EQ. -15) THEN
         CALL WHILES (LABVAL (SP))
      ELSE IF (LEXTYP (SP) .EQ. -16) THEN
         CALL FORS (LABVAL (SP))
      ELSE IF (LEXTYP (SP) .EQ. -17) THEN
         CALL UNTILS (LABVAL (SP), TOKEN)
      ENDIF 
1010  SP = SP - 1
      GOTO 1000 
1020  CONTINUE 
      RETURN
      END 
      SUBROUTINE UNTILS (LAB, TOKEN)
      INTEGER LAB, TOKEN
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       INTEGER PTOKEN (100)
      INTEGER JUNK
      INTEGER LEX
      XFER = 0
      CALL OUTNUM (LAB)
      IF (TOKEN .EQ. -18) THEN
         JUNK = LEX (PTOKEN)
         CALL IFGO (LAB - 1)
         TOKEN = LEX (PTOKEN)
         IDUMMY = PBLEX (TOKEN, PTOKEN)
      ELSE 
         CALL OUTGO (LAB - 1)
      ENDIF 
      CALL OUTCON (LAB + 1)
      RETURN
      END 
      SUBROUTINE WHILEC (LAB)
      INTEGER LAB
      INTEGER LABGEN
      CALL OUTCON (0)
      LAB = LABGEN (2)
      CALL OUTNUM (LAB)
      CALL IFTHEN
      RETURN
      END 
      SUBROUTINE WHILES (LAB)
      INTEGER LAB
      CALL OUTGO (LAB)
      CALL IFEND
      CALL OUTCON (LAB + 1)
      RETURN
      END 
      SUBROUTINE COMLINE (NOPTIONS, OPTIONS, MAXOPTIONS)
      CHARACTER OPTIONS(2,MAXOPTIONS)*8, LINE*140, KEYCHAR*3
      LOGICAL BATCH, KEYFLAG
      COMMON /KEYEDIN/ KEYFLAG
      CALL OPENCALL ('DISC', 1, -1, ERROR)
      OPEN (5)
      INQUIRE (UNIT=5, KEYED=KEYCHAR)
      KEYFLAG = KEYCHAR .EQ. 'YES'
      CALL OPENCALL ('DISC', 2, -2, ERROR)
      CALL OPENCALL ('LIST', 7, -2, ERROR)
      CALL GETCOM (LINE)
      IPOS = INDEX (LINE, '(')
      IF (IPOS .LE. 0) THEN
         NOPTIONS = 0
         RETURN
      ENDIF 
      CALL PARSEOPT (LINE(IPOS:), MAXOPTIONS, NOPTIONS, OPTIONS,
     1ISTATUS)
      IF (ISTATUS .NE. 0) THEN
         GOTO 1000 
      ENDIF 
      RETURN
1000  IF (BATCH()) THEN
         STOP 'ERROR IN OPTIONS'
      ENDIF 
1010  IF (ISTATUS .NE. 0) THEN
         OUTPUT (108) 'REENTER OPTIONS'
         READ (105,'(A)') LINE
         CALL PARSEOPT (LINE, MAXOPTIONS, NOPTIONS, OPTIONS, ISTATUS)
         GOTO 1010 
      ENDIF 
1020  CONTINUE 
      END 
      SUBROUTINE STARTUP
      CHARACTER OPTIONS(2,10)*8
      LOGICAL ERROR
      OPEN (105, NAME='(ME)')
      OPEN (108, NAME='(LO)')
      CALL COMLINE (NOPTIONS, OPTIONS, 10)
      CALL DOOPTIONS (NOPTIONS, OPTIONS)
      CALL OPENCALL ('(LO)', 3, 2, ERROR)
      CLOSE (105)
      CLOSE (108)
      END 
      SUBROUTINE DOOPTIONS (NOPTIONS, OPTIONS)
      CHARACTER OPTIONS (2,1)*8, LINE*80
      LOGICAL LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      LOGICAL BATCH
      COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /CMAXID/ MAXID
      MAXID = 0
      LISTS = .FALSE.
      LISTL = .FALSE.
      LISTF = .FALSE.
      LISTI = .FALSE.
      STRNG = .FALSE.
      KEYSEQ = .FALSE.
1000  DO 1010 I = 1, NOPTIONS
         IF (OPTIONS(1,I) .EQ. 'LONGNAME') THEN
            READ (OPTIONS(2,I),'(I)') MAXID
         ELSE IF (OPTIONS(1,I) .EQ. 'NLS') THEN
            LISTS = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'LS') THEN
            LISTS = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'NLF') THEN
            LISTF = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'LF') THEN
            LISTF = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'NLL') THEN
            LISTL = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'LL') THEN
            LISTL = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'NLI') THEN
            LISTI = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'LI') THEN
            LISTI = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'STRING') THEN
            STRNG = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'NSTRING') THEN
            STRNG = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'KEYSEQ') THEN
            KEYSEQ = .TRUE.
         ELSE IF (OPTIONS(1,I) .EQ. 'NKEYSEQ') THEN
            KEYSEQ = .FALSE.
         ELSE IF (OPTIONS(1,I) .EQ. 'STOP') THEN
            CALL EXIT
         ELSE IF (OPTIONS(1,I) .EQ. 'HELP') THEN
            PRINT   9000
         ELSE 
            GOTO 1030 
         ENDIF 
1010  CONTINUE 
1020  CONTINUE 
      RETURN
1030  OUTPUT 'INVALID OPTION ENTERED'
      WRITE (108,'(1X,A)') OPTIONS(1,I)
      IF (BATCH()) THEN
         STOP 'ERROR IN OPTION LIST'
      ENDIF 
      OUTPUT 'REENTER OPTIONS'
      READ (105,'(A)') LINE
      CALL PARSEOPT (LINE, MAXOPTIONS, NOPTIONS, OPTIONS, ISTATUS)
      IF (ISTATUS .NE. 0) THEN
         GOTO 1030 
      ENDIF 
      GOTO 1000 
9000  FORMAT (' OPTIONS FOR RATFOR ARE:', /, ' (N)LS - LIST RATFOR SOURC
     *E', /, ' (N)LF - LIST FORTRAN SOURCE', /, ' (N)LI - LIST RATFOR IN
     *CLUDES', /, ' (N)LL - LIST LONG NAMES DICTIONARY', /, ' (N)STRING
     *- ALLOW THE STRING KEYWORD IN RATFOR', /, ' (N)KEYSEQ - PUT RATFOR
     * SOURCE KEYS IN THE FORTRAN SOURCE ', 'SEQUENCE FIELD (73-80)', /,
     * ' LONGNAME=n - LENGTH OF FORTRAN VARIABLE NAMES TO GENERATE', //,
     * ' DEFAULTS ARE:', /, ' NLS, NLF, NLI, NLL, NSTRING, NKEYSEQ, LONG
     *NAME=0', //, ' STOP - EXIT RATFOR BACK TO THE SYSTEM', /, ' HELP -
     * PRODUCE THIS PRINTOUT')
      END 
      SUBROUTINE OPENCALL (NAME, ICHANNEL, IACCESS, ERROR)
      CHARACTER NAME*(*)
      DIMENSION INAME(51)
      INTEGER ASSIGN
      LOGICAL ERROR
      L = MIN0(50, LEN (NAME))
      READ (NAME,'(50R1)') (INAME(I), I = 1, L)
      INAME(LENSIG(NAME)+1) = -2
      I = ASSIGN (INAME, ICHANNEL, IACCESS)
      ERROR = I .EQ. -3
      END 
      SUBROUTINE KEYOUT (INUNIT, IOUTUNIT)
      COMMON /KEYSTUFF/ KEY
      CALL KEYPRT (KEY, IOUTUNIT)
      END 
      SUBROUTINE STORER (IBUFF, IUNIT, ILINES)
      DIMENSION IBUFF(100)
      INTEGER RBUFF(100)
      INTEGER PAGE1(6)
      INTEGER PAGE2(6)
      INTEGER END1(4)
      INTEGER END2(4)
      DATA PAGE1(1)/35/,PAGE1(2)/80/,PAGE1(3)/65/,PAGE1(4)/71/,PAGE1(5)/
     *69/,PAGE1(6)/-2/
      DATA PAGE2(1)/35/,PAGE2(2)/112/,PAGE2(3)/97/,PAGE2(4)/103/,PAGE2(5
     *)/101/,PAGE2(6)/-2/
      DATA END1(1)/69/,END1(2)/78/,END1(3)/68/,END1(4)/-2/
      DATA END2(1)/101/,END2(2)/110/,END2(3)/100/,END2(4)/-2/
      LOGICAL LISTS, LISTF, LISTL, LISTI, PAGE, RSAVE, ENDF, EQUL, STRNG
     *, KEYSEQ
      COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
      COMMON /IO/ IUNITS(7)
      LOGICAL KEYFLAG
      COMMON /KEYEDIN/ KEYFLAG
      SAVE ICOUNT, RSAVE, RBUFF, ISAVEL, ISAVEK
      DATA ICOUNT/0/, RSAVE/.FALSE./
      IF (.NOT. LISTS) THEN
         RETURN
      ENDIF 
      IF (.NOT. LISTI .AND. IUNIT .NE. 1) THEN
         RETURN
      ENDIF 
      IF (LISTF) THEN
         IF (RSAVE) THEN
            CALL PUTLINES (RSAVE, RBUFF, ISAVEL, ISAVEK, -2, ICOUNT)
         ENDIF 
         IF (EQUL (PAGE1, IBUFF) .OR. EQUL (PAGE2, IBUFF)) THEN
            WRITE (IUNITS(7),'(''1'')')
         ELSE 
            CALL SCOPY (IBUFF, 1, RBUFF, 1)
            RSAVE = .TRUE.
            ISAVEL = ILINES
            IF (KEYFLAG) THEN
               INQUIRE (IUNITS(IUNIT), NEXTREC=ISAVEK)
            ENDIF 
         ENDIF 
      ELSE 
         CALL PUTCH (32, 7)
         CALL PUTINT (ILINES, 4, 7)
         CALL PUTCH (32, 7)
         IF (KEYFLAG) THEN
            CALL KEYOUT (IUNIT, 7)
         ENDIF 
         CALL PUTCH (32, 7)
         CALL PUTINT (ICOUNT+1, 4, 7)
         CALL PUTCH (32, 7)
         CALL PUTLIN (IBUFF, 7)
         IF (EQUL (PAGE1, IBUFF) .OR. EQUL (PAGE2, IBUFF)) THEN
            WRITE (IUNITS(7),'(''1'')')
         ENDIF 
         I=1
1000     IF (.NOT.(IBUFF(I) .EQ. 32))GOTO 1020 
         IF (IBUFF(I) .EQ. -2) THEN
            RETURN
         ENDIF 
1010     I=I+1
         GOTO 1000 
1020     CONTINUE 
         IF (EQUL (END1, IBUFF(I)) .OR. EQUL (END2, IBUFF(I))) THEN
            PAGE = .TRUE.
         ELSE 
            PAGE = .FALSE.
         ENDIF 
         IF (PAGE .AND. (IBUFF(I+3) .EQ. 32 .OR. IBUFF(I+3) .EQ. -2 .OR.
     1      IBUFF(I+3) .EQ. 10)) THEN
            WRITE (IUNITS(7), '(''1'')')
         ENDIF 
      ENDIF 
      RETURN
      ENTRY STOREF (IBUFF)
      ICOUNT = ICOUNT + 1
      IF (.NOT. LISTF) THEN
         IF (ENDF (IBUFF)) THEN
            ICOUNT = 0
         ENDIF 
         RETURN
      ENDIF 
      IF (LISTS) THEN
         CALL PUTLINES (RSAVE, RBUFF, ISAVEL, ISAVEK, IBUFF, ICOUNT)
      ELSE 
         CALL PUTCH (32, 7)
         CALL PUTINT (ICOUNT, 4, 7)
         CALL PUTCH (32, 7)
         CALL PUTLIN (IBUFF, 7)
         IF (ENDF (IBUFF)) THEN
            WRITE (IUNITS(7),'(''1'')')
            ICOUNT = 0
         ENDIF 
      ENDIF 
      END 
      SUBROUTINE PUTLINES (RSAVE, RBUFF, ILINES, KEY, IBUFF, ICOUNT)
      INTEGER RBUFF(100), IBUFF(100)
      LOGICAL RSAVE, SHORT, ENDF
      COMMON /IO/ IUNITS(7)
      LOGICAL KEYFLAG
      COMMON /KEYEDIN/ KEYFLAG
      SHORT = .TRUE.
      CALL PUTCH (32, 7)
      IF (RSAVE) THEN
         CALL PUTINT (ILINES, 4, 7)
         CALL PUTCH (32, 7)
         IF (KEYFLAG) THEN
            CALL KEYPRT (KEY, 7)
         ENDIF 
         CALL PUTCH (32, 7)
         L = LENGTH (RBUFF)
         IF (RBUFF(L) .EQ. 10) THEN
            RBUFF(L) = -2
            L = L - 1
         ENDIF 
         IF (L .GT. 39) THEN
            SHORT = .FALSE.
         ENDIF 
         CALL PUTLIN (RBUFF, 7)
         RSAVE = .FALSE.
      ELSE 
         DO 1000 I = 1, 54
            CALL PUTCH (32, 7)
1000     CONTINUE 
1010     CONTINUE 
         L = 40
      ENDIF 
      IF (IBUFF(1) .EQ. -2) THEN
         CALL PUTCH (10, 7)
         RETURN
      ENDIF 
      IF (SHORT) THEN
         DO 1020 I = L+1, 39
            CALL PUTCH (32, 7)
1020     CONTINUE 
1030     CONTINUE 
      ELSE 
         CALL PUTCH (10, 7)
         DO 1040 I = 1, 55
            CALL PUTCH (32, 7)
1040     CONTINUE 
1050     CONTINUE 
      ENDIF 
      CALL PUTCH (32, 7)
      CALL PUTINT (ICOUNT, 4, 7)
      CALL PUTCH (32, 7)
      CALL PUTLIN (IBUFF, 7)
      IF (ENDF (IBUFF)) THEN
         WRITE (IUNITS(7),'(''1'')')
         ICOUNT = 0
      ENDIF 
      END 
      SUBROUTINE KEYPRT (KEY, IOUTUNIT)
      DIMENSION ICHAR(10)
      IF (KEY .LE. 0) THEN
         DO 1000 I = 1, 9
            CALL PUTCH (32, IOUTUNIT)
1000     CONTINUE 
1010     CONTINUE 
      ELSE 
         I = KEY/1000
         CALL PUTINT (I, 5, IOUTUNIT)
         CALL PUTCH (46, IOUTUNIT)
         J = MOD (KEY, 1000) + 1000
         IDUM = ITOC (J, ICHAR, 10)
         CALL PUTLIN (ICHAR(2), IOUTUNIT)
      ENDIF 
      END 
      LOGICAL FUNCTION EQUL (ISTR1, ISTR2)
      DIMENSION ISTR1(100), ISTR2(100)
      I=1
1000  IF (.NOT.(ISTR1(I) .EQ. ISTR2(I)))GOTO 1020 
      CONTINUE 
1010  I = I + 1
      GOTO 1000 
1020  CONTINUE 
      EQUL = ISTR1(I) .EQ. -2
      END 
      LOGICAL FUNCTION ENDF (IBUFF)
      DIMENSION IBUFF(100)
      INTEGER STREND(5)
      DATA STREND(1)/32/,STREND(2)/69/,STREND(3)/78/,STREND(4)/68/,STREN
     *D(5)/-2/
      LOGICAL EQUL
      IF (EQUL (STREND, IBUFF(6)) .AND. (IBUFF(10) .EQ. 32 .OR. IBUFF(
     110) .EQ. -2 .OR. IBUFF(10) .EQ. 10)) THEN
         ENDF = .TRUE.
      ELSE 
         ENDF = .FALSE.
      ENDIF 
      END 
      SUBROUTINE DECIMAL (IDEC, ISTRING, IWIDTH)
      DIMENSION ISTRING(1), ICHARS(10)
      ND = ITOC (IDEC, ICHARS, 10)
      DO 1000 I = ND+1, IWIDTH
         ISTRING(I-ND) = 32
1000  CONTINUE 
1010  CONTINUE 
      DO 1020 I = 1, ND
         ISTRING(I+IWIDTH-ND) = ICHARS(I)
1020  CONTINUE 
1030  CONTINUE 
      END 
      SUBROUTINE IFEND
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      INTEGER SIFEND(6)
      DATA SIFEND(1)/69/,SIFEND(2)/78/,SIFEND(3)/68/,SIFEND(4)/73/,SIFEN
     *D(5)/70/,SIFEND(6)/-2/
      CALL OUTTAB
      CALL OUTSTR (SIFEND)
      CALL OUTDON
      XFER = 0
      END 
      SUBROUTINE IFTHEN
      INTEGER SIF(4)
      INTEGER STHEN(6)
      DATA SIF(1)/73/,SIF(2)/70/,SIF(3)/32/,SIF(4)/-2/
      DATA STHEN(1)/32/,STHEN(2)/84/,STHEN(3)/72/,STHEN(4)/69/,STHEN(5)/
     *78/,STHEN(6)/-2/
      CALL OUTTAB
      CALL OUTSTR (SIF)
      CALL BALPAR
      CALL OUTSTR (STHEN)
      CALL OUTDON
      END 
      SUBROUTINE EOUT (N)
      INTEGER MSG(14)
      DATA MSG(1)/32/,MSG(2)/69/,MSG(3)/82/,MSG(4)/82/,MSG(5)/79/,MSG(6)
     */82/,MSG(7)/83/,MSG(8)/32/,MSG(9)/70/,MSG(10)/79/,MSG(11)/85/,MSG(
     *12)/78/,MSG(13)/68/,MSG(14)/-2/
      CALL PUTCH (32, 3)
      CALL PUTINT (N, 4, 3)
      CALL PUTLIN (MSG, 3)
      CALL PUTCH (10, 3)
      END 
      SUBROUTINE ELSE
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
      XFER = 0
      INTEGER SELSE(5)
      DATA SELSE(1)/69/,SELSE(2)/76/,SELSE(3)/83/,SELSE(4)/69/,SELSE(5)/
     *-2/
      CALL OUTTAB
      CALL OUTSTR (SELSE)
      END 
      SUBROUTINE COLLECTTOKEN (LEXSTR, I)
      IMPLICIT INTEGER (A-Z)
      DIMENSION LEXSTR(*)
      COMMON /CDEFIO/ BP, BUF (600)
      INTEGER BP
      INTEGER BUF
      COMMON /CFNAME/ FCNAME (30)
      INTEGER FCNAME
      COMMON /CFOR/ FORDEP, FORSTK (200)
      INTEGER FORDEP
      INTEGER FORSTK
      COMMON /CGOTO/ XFER
      INTEGER XFER
      COMMON /CLABEL/ LABEL
      INTEGER LABEL
      COMMON /CLINE/ LEVEL, LINECT (5), INFILE (5), FNAMP, FNAMES ( 150)
      INTEGER LEVEL
      INTEGER LINECT
      INTEGER INFILE
      INTEGER FNAMP
      INTEGER FNAMES
      COMMON /CMACRO/ CP, EP, EVALST (500), DEFTBL
      INTEGER CP
      INTEGER EP
      INTEGER EVALST
      INTEGER DEFTBL
      COMMON /COUTLN/ OUTP, OUTBUF (83)
      INTEGER OUTP
      INTEGER OUTBUF
      COMMON /CSBUF/ SBP, SBUF (500)
      INTEGER SBP
      INTEGER SBUF
      COMMON /CSWTCH/ SWTOP, SWLAST, SWSTAK (1000)
      INTEGER SWTOP
      INTEGER SWLAST
      INTEGER SWSTAK
      COMMON /CKWORD/ RKWTBL
      INTEGER RKWTBL
      COMMON /CLNAME/ FKWTBL, NAMTBL, GENTBL
      INTEGER FKWTBL
      INTEGER NAMTBL
      INTEGER GENTBL
      INTEGER MEM( 50000)
      COMMON/CDSMEM/MEM
      VIRTUAL (BUF=50) /CDSMEM/
       DIMENSION REPLACEMENT(100)
      LOGICAL CONTINUE
      IPLACEHOLDER = I
      I = I + 1
      CH = NGETCH(LEXSTR(I))
      IF (LEXSTR(I) .EQ. 64) THEN
         I = I + 1
         CH = NGETCH(LEXSTR(I))
      ENDIF 
1000  IF (((65.LE.CH.AND.CH.LE.90).OR.(97.LE.CH.AND.CH.LE.122)) .OR.
     1(48.LE.CH.AND.CH.LE.57) .OR. CH .EQ. 46 .OR. CH .EQ. 95) THEN
         I = I + 1
         CH = NGETCH(LEXSTR(I))
         GOTO 1000 
      ENDIF 
1010  CONTINUE 
      CONTINUE = .FALSE.
      IF (LEXSTR(I) .EQ. 10) THEN
         IF (LEXSTR(I-1) .EQ. 95) THEN
            CONTINUE = .TRUE.
            CALL PUTBAK (LEXSTR(I))
            I = I - 1
         ELSE 
            CALL PUTBAK (LEXSTR(I))
         ENDIF 
      ELSE 
         CALL PUTBAK (LEXSTR(I))
      ENDIF 
      LEXSTR(I) = -2
      IF (LEXSTR(IPLACEHOLDER + 1) .EQ. 64) THEN
         IF (LUDEF (LEXSTR(IPLACEHOLDER + 1), REPLACEMENT, DEFTBL) .EQ.
     1      1)THEN
            J = IPLACEHOLDER + 1
1020        IF (.NOT.(LEXSTR(J) .NE. -2))GOTO 1040 
            LEXSTR(J - 1) = LEXSTR(J)
1030        J = J + 1
            GOTO 1020 
1040        CONTINUE 
            I = J - 1
         ENDIF 
         IF (CONTINUE) THEN
            LEXSTR(I) = 95
         ENDIF 
      ELSE 
         IF (LUDEF (LEXSTR(IPLACEHOLDER), REPLACEMENT, DEFTBL) .EQ. 1)
     1      THEN
            J = 1
1050        IF (.NOT.(REPLACEMENT(J) .NE. -2))GOTO 1070 
            LEXSTR(IPLACEHOLDER) = REPLACEMENT(J)
            IPLACEHOLDER = IPLACEHOLDER + 1
1060        J = J + 1
            GOTO 1050 
1070        CONTINUE 
            IF (CONTINUE) THEN
               LEXSTR(IPLACEHOLDER) = 95
            ENDIF 
            I = IPLACEHOLDER
         ELSE IF (CONTINUE) THEN
            LEXSTR(I) = 95
         ENDIF 
      ENDIF 
      IF (.NOT.CONTINUE) THEN
         CH = NGETCH(LEXSTR(I))
         IF (LEXSTR(I) .EQ. LEXSTR(1)) THEN
            CALL PUTBAK (LEXSTR(I))
            I = I - 1
         ENDIF 
      ENDIF 
      END 
