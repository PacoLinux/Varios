.*M*
HELP file for: RATFOR.X
.*T*
 **************************************************************
 *                                                            *
 *  Copyright (c) Bull HN Information Systems Inc., 1989      *
 *                                                            *
 **************************************************************
.*X*                              
FYI, this HELP file has been specially prepared to run through TUNA.X (LEN=79)
prior to running through HERMAN.  This action will guarantee that the lines of
text in it will fill a screen as much as possible, and that more lines will end
up per screen.
.*R*
.*A*
RATFOR.X is a CP-6 implementation of the RATional FORtran preprocessor derived
from the the book SOFTWARE TOOLS, by B.W.  Kernighan and P.J. Plauger.  This
version was obtained from the technical staff at Cummins Diesel Engine Company.
.*B*
Invocation syntax:
 
!RATFOR.X  srcfile  { INTO | ON | OVER }  outfile [,listfile] [ (options) ]
 
srcfile     is the RATFOR source code developed with the editor.
 
outfile     is the standard FORTRAN source created by the RATFOR preprocessor.
 
listfile    is the destination file for all other RATFOR output, including
RATFOR source listing and RATFOR errors.
 
outfile should now be used as the input file for the FORTRAN compiler.
 
Options are:
 
[N]LS   - List RATFOR source on 'listfile'
.*R*
[N]LF   - List FORTRAN source on 'listfile'
.*R*
[N]LI   - List FORTRAN include source on 'listfile'
.*R*
[N]LL   - List long names dictionary on 'listfile'
.*R*
[N]KEYSEQ - Put RATFOR source keys in the FORTRAN source sequence field (73-80)
.*R*
LONGNAME=n - Length of FORTRAN variable names to generate
.*R*
[N]STRING - Permit STRING as a valid RATFOR keyword
 
The default options are NLS, NLF, NLI, NLL, NSTRING, NKEYSEQ and LONGNAME=0.
 
Two other options are:
 
STOP  - Exit RATFOR back to the system
.*R*
HELP  - Produce a printout of the available options
 
? for more...
.*B*
The STRING option is only used when processing the RATFOR code itself.  RATFOR
has a STRING keyword which is not covered in these notes.  It was useful in the
days of FORTRAN 66 when all character string work was done with integer arrays.
The STRING statement has one parameter, a quoted string which RATFOR converts
to an integer array declaration and DATA statements to initialize the elements
to the characters of the quoted string.  However, with FORTRAN 77 CHARACTER
variables, the feature is not needed except for the RATFOR processor itself
which was written in terms of the STRING keyword.
 
The LL and LONGNAME options are related.  LL only has meaning if the 'n' value
LONGNAME is nonzero.  If LONGNAME is zero, the default, variables encountered
by RATFOR are passed unchanged into the FORTRAN source code.  However, if
LONGNAME is nonzero, then any name RATFOR encounters which is longer than 'n'
is converted into another unique name which is no longer than 'n'.
 
For example, if a program is being developed in RATFOR for a pure FORTRAN 77
compiler, the program could use names longer than 6 characters, the FORTRAN 77
standard, and still have the program run correctly through the compiler.  The
LL option would display the dictionary mapping long names into unique names.
.*K* ABOUT_RATFOR INTRODUCTION
RATFOR USER'S GUIDE
 
INTRODUCTION
 
The current industry standard scientific computer language for applications
programming is FORTRAN.  To aid the applications programmer in the process of
designing and implementing a computer program, RATFOR was developed.
 
RATFOR, which stands for RATional FORtran, is known as a high-level, structured
language.  It is an extension of the FORTRAN language, containing all of the
FORTRAN statements plus structural constructs which provide for easier
programming, greater understanding and easier program maintenance.  RATFOR
provides for faster development of more reliable programs.
 
In structured programming, only three forms of control structures are
permitted.  These forms are:
 
- Simple sequencing or concatenation of statements
 
- Selecting the next statement(s) to be executed as a result of a test.
 
- Conditional iteration
 
A programmer, using RATFOR, can do anything already available in FORTRAN; the
main difference is that RATFOR programs are:
 
- More logical
 
- Structured
 
- More understandable
 
- Simpler
 
Many of the syntactical idiosyncrasies of FORTRAN are now handled by RATFOR,
allowing a programmer to spend more time on the development of the solution and
less time on the development of the program.
 
.*B*  OVERVIEW
RATFOR OVERVIEW
 
RATFOR is an extension of the FORTRAN language which is translated by the
RATFOR preprocessor into FORTRAN 77.  The preprocessor reads the RATFOR source
code and produces standard FORTRAN statements, taking into consideration such
things as the necessity of continuation lines, column justification and
converting constructs into a form understood by the FORTRAN compiler.  The
FORTRAN statements created are then written to a user defined file which
becomes the FORTRAN source code.
 
.*
.fif
.*R*
         RATFOR Source Code
                 |
                 |
                 | RATFOR Preprocessor
                 |
                 v
       FORTRAN Source Code
                 |
                 |
                 | FORTRAN Processor
                 |
                 v
           Object File
                 |
                 |
                 | LINK Processor
                 |
                 v
              Rununit
.*
.fin
.*R*
.*B*
 
RATFOR Preprocessor Overview
.*R*
----------------------------
 
RATFOR will accept variable names up to 31 characters in length.  These may
pass through to the FORTRAN source code unchanged.  Since the RATFOR
preprocessor depends on special words in the RATFOR source code to tell it how
to process a statement, these words must never be used as variable names.
These special words are known as "keywords".
 
In translating some of the RATFOR structures into FORTRAN, RATFOR may need to
generate IF, GOTO and CONTINUE statements.  The statement numbers used on
CONTINUE statements begin with 23000 and increment by one from there.  Users
should avoid statement numbers in this range in their programs.
 
The CASE statement (discussed elsewhere) generates integer variables with names
of the form I23000, I23001, ... .  Users should avoid variable names of this
form.
 
.*B*
Source Code Format
.*R*
------------------
 
The format of RATFOR statements is very general.  No specific columns need to
be used.  Statements can appear anywhere on a line.  RATFOR automatically
justifies lines correctly and provides continuations when necessary.  If a
RATFOR statement needs to be continued onto another line, just leave a dangling
delimiter or operator (i.e., + * - ,) at the end of the line to be continued
and RATFOR will generate the necessary continuations in FORTRAN.  Explicit line
continuation can also be achieved by ending the line to be continued with an
underscore (_).  The use of a character in column 6 will not cause a line to be
continued, as it does in FORTRAN.
 
Note that the slash character (/) may not be used as a dangling operation to
continue a line since it is a valid terminator for the DATA statement.  If it
were permitted as a continuation character, there would be an ambiguity with
the DATA statement.
 
Quoted strings may be continued explicitly using the underscore.  When this is
used, leading blanks on the continuation line are skipped and continuation
begins with the first nonblank character on the line.
 
.*B*
For example:
 
      STRING = 'ABCD_
         XYZ'
 
would be translated to
 
      STRING = 'ABCDXYZ'
 
in FORTRAN.
 
Some statements in RATFOR require a 'test condition' to be specified.  These
statements are IF, ELSE IF, REPEAT and WHILE.  The 'test condition' is
basically anything which translates into a FORTRAN logical expression.
Continuation in the form of dangling operators or an underscore is not required
for 'test conditions'.  RATFOR recognizes the keyword introducing the 'test
condition', finds the left parenthesis starting the test condition and then
continues processing characters until it finds a matching right parenthesis.
 
For example:
 
IF (A == B  &
    A == C) RETURN
.*B* COMMENTARY
Comments are designated by preceding them by a pound sign (#).  They can appear
anywhere in a RATFOR source file.  Any text to the right of the pound sign is
considered a comment, with the end of the comment coincident with the end of
that line.  Blank lines are also acceptable anywhere.  The use of a "C" in
column 1 will not designate the beginning of a comment, as it does in FORTRAN.
 
     EXAMPLE
 
      #
      #  This is an example of a comment
 
         X = A + B   # Comments may occur
                     # anywhere including at
         Z = X**2    # the end of executable
                     # statements
      #  The following demonstrates how to continue
      #  a line in RATFOR.
         Z(I) = X + 2*B - Q +
                Y**3 - COS(THETA)
         QARRAY(K) = X + 2.045 + 93.0 _
                *TEMP(J)
 
.*B* LINE_NUMBERS
Any RATFOR line, except continuation lines, may begin with a number.  This
number will be treated as a FORTRAN statement number and positioned properly in
columns 1 - 5 of the output FORTRAN source.
 
.*B* RELATIONAL_OPERATORS
Alternate Forms of Relational Operators
.*R*
---------------------------------------
 
The relational operators are used for the comparison of values of two
variables.  RATFOR accepts all the relational operators used in FORTRAN, plus
the alternate forms shown in the following table.
 
.*
.FIF
.*R*
      FORTRAN                   RATFOR
Relational Operators      Relational Operators
       .EQ.                       ==
       .NE.                     !=, <>
       .GT.                       >
       .LT.                       <
       .GE.                       >=
       .LE.                       <=
 
      FORTRAN                   RATFOR
  Logical Operators       Logical Operators
       .AND.                      &
       .OR.                       |
       .NOT.                      !
.*
.FIN
.*R*
 
.*B*
EXAMPLE
 
The RATFOR statement:
 
      IF (BLUE == GREEN  &  TODAY > TOMORROW)
         FUTURE = PAST
 
is equivalent to the FORTRAN statement:
 
      IF (BLUE .EQ. GREEN  .AND.  TODAY .GT. TOMORROW) FUTURE = PAST
 
.*B* COMPOUND_STATEMENTS
Compound Statements
.*R*
-------------------
 
One of the biggest advantages of RATFOR is the ability to use blocks of
statements anywhere that a single statement is used in FORTRAN.  Throughout the
rest of this text, the phrase "statement" will correspond to either the simple
RATFOR statement or the compound RATFOR statement.
 
A simple RATFOR statement is just like a FORTRAN statement.  That is, just one
line of code (with possible continuations).  A compound RATFOR statement is a
group or block of simple statements or other compound statements.  This type of
block statement capability is extremely useful, in particular when combined
with the IF ... ELSE, DO, WHILE, REPEAT, FOR and CASE constructs explained
later.
 
.*B*
The beginning of a RATFOR compound statement is indicated by a dollar sign and
left parenthesis ("$(") or a left square bracket ("[").  The end of a compound
statement is indicated by a dollar sign and right parenthesis ("$)") or a right
square bracket ("]").
 
Simple statements:
 
      BABY = MOM + DAD
 
      TIME = FOREVER
 
      IF (EGGS == BROKEN)
         THEY = SCRAMBLED
 
.*B*
Compound statements:
 
      IF (BABY == BOY) $(
         COLOR = BLUE
         SEX = MALE
         NAME = JOHNNY
      $)
 
      IF (BABY == GIRL) [
         COLOR = PINK
         NAME = LISA
         IF (BABY >= BREADBOX) [
            MOM = RELIEVED
            DAD = SURPRISED
            DOCTOR = FAMOUS
         ]
         SEX = FEMALE
      ]
 
Note that RATFOR statements like IF, DO, WHILE, CASE are considered single
statements whether they control compound or simple statements.  Therefore, the
following is valid:
 
.*B*
IF (CONDITION)
   DO I = 1, 100 [
      X(I) = 0.
      Y(I) = FLOAT(I)
   ]
 
Brackets are not needed for the IF since it is followed by only 1 statement,
the DO.
 
.*B*
While it is permitted to put brackets around single statements, it is not
recommended.
 
For example:
 
.*
.FIF
.*R*
DO 10 I = 1, N [
   X(I) = 0.
]
.*
.FIN
.*R*
 
is the same as
 
.*
.FIF
.*R*
DO 10 I = 1, N
   X(I) = 0.
.*
.FIN
.*R*
 
The extraneous brackets clutter up the source code and make the reader wonder
why they are there in the first place.
 
.*K* SYNTAX CONSTRUCTS
RATFOR CONSTRUCTS AND SYNTAX
 
It should be noted that RATFOR does not know any FORTRAN.  All that RATFOR does
is translate the RATFOR code into the best FORTRAN that it can.  If invalid
FORTRAN constructs are used, such as the square root of a negative number or
two plus signs side by side, the RATFOR preprocessor will not catch the errors.
Only errors such as unbalanced parentheses or missing quotation marks will be
indicated.
 
.*B* DEFINE
DEFINE
.*R*
------
 
The DEFINE statement is used to associate any character string with a
replacement text.  DEFINE has the syntax:
 
      DEFINE (name, replacement text)
 
During the translation process, anywhere in the RATFOR source that 'name'
appears it will be replaced by 'replacement text'.  The DEFINE provides for a
global definition of 'name' as 'replacement text'.  This is very useful, for
example, in assigning a value to an array dimension which appears globally.
The DEFINE construct will cause a substitution of text only when 'name' is
found in the source code appropriately delimited.  The DEFINEs
 
      DEFINE (LUNIN, 105)
      DEFINE (LUNOUT,108)
 
will cause every occurrence of the string 'LUNIN' to be replaced by the number
105 and 'LUNOUT' by 108.  If the input and output logical unit numbers need to
be changed, all that is needed is to change the two DEFINEs instead of all the
occurrences of the integer values 105 and 108.  This is a great aid when
converting a program from one computer system to another, or when extending the
size of a program (e.g., increase array sizes).
 
.*B*
As a convention to help make DEFINEd names stand out from variable names,
RATFOR has been extended to allow the at sign (@) as a valid character to begin
a DEFINE name.  It may only be used as the first character and only in DEFINEd
names.
 
EXAMPLE
 
DEFINE (@MAXSIZE, 1000)
 
This DEFINE will cause @MAXSIZE to be replaced by 1000 everywhere it occurs.
For example:
 
.*
.FIF
.*R*
DIMENSION X(@MAXSIZE)
DO I = 1, @MAXSIZE
   X(I) = 0.
.*
.FIN
.*R*
 
 
.*B*
To further stress this convention, DEFINEd names in quoted strings must begin
with an at sign.  Also, if the actual DEFINEd name is to be output, a double at
sign (@@) should be used.  Note that only DEFINEd names will be changed.  At
signs associated with any unDEFINEd names or numbers are not affected.
 
EXAMPLE
 
.*
.FIF
.*R*
DEFINE (@MAX, 100)
DEFINE (@OUTPUT, WRITE (*, *))
 
@OUTPUT 'THE MAX IS @MAX'
@OUTPUT 'THE MAX IS @@MAX'
@OUTPUT '200 HP @2100 RPM'
.*
.FIN
.*R*
 
Produces
 
.*
.FIF
.*R*
WRITE (*, *) 'THE MAX IS 100'
WRITE (*, *) 'THE MAX IS @MAX'
WRITE (*, *) '200 HP @2100 RPM'
.*
.FIN
.*R*
 
More DEFINE capabilities can be found in the "ADVANCED FEATURES" section of
this text.
 
.*B* INCLUDE
INCLUDE
.*R*
-------
 
The INCLUDE statement will insert the contents of the specified file as a
replacement for the INCLUDE.  The INCLUDE has the syntax:
 
      INCLUDE 'filename'
 
where 'filename' is the name of the file which contains the text to be
inserted.  The quotation marks are a necessary part of the syntax.
 
EXAMPLE
 
INCLUDE 'DEFINITS'
 
This statement will replace the INCLUDE statement with the contents of the file
named 'DEFINITS'.  INCLUDEd files may contain other INCLUDE statements to a
nesting level of 3.
 
.*B*
One instance where an INCLUDE is useful is if several files contain RATFOR
source code and each use the same set of DEFINEs.  A single file can be created
which contains all the DEFINEs for all the source code and that file INCLUDEd
in every other file that will require them.
 
Another popular use of include files is for including COMMON block definitions.
In this way, changing the definition in the INCLUDE file will automatically
update all references to the common block once the RATFOR code is reprocessed.
 
.*B* IF IFELSE
IF and IF...ELSE
.*R*
------------------
 
When it is desired to have conditional control over a RATFOR statement, the IF
or IF ... ELSE construct may be used.
 
The IF statement is the same as its counterpart in FORTRAN, except that the
statement which follows the test condition may be a compound RATFOR statement.
The IF statement has the syntax:
 
.*
.FIF
.*R*
IF (test condition)
   statement
 
If 'test condition' is true, then 'statement' is executed.
.*B*
 
EXAMPLE
 
IF (SKY == BLUE)
   CLOUDS = NONE
 
IF (BOB >= LARRY) [
   BOB = 2*SAM + HARRY
   LISA = PI*R**2
   IF (LARRY < LISA)
      LARRY = HERB
]
.*
.FIN
.*R*
 
.*B*
When it is desired to execute either one RATFOR statement or another (but not
both) depending on a test condition, the IF ... ELSE construct may be used.  It
has the syntax:
 
.*
.FIF
.*R*
IF (test condition)
   statement 1
ELSE
   statement 2
.*
.FIN
.*R*
 
If 'test condition' is true, 'statement 1' will be executed, otherwise
'statement 2' will be executed.  No matter what the value of 'test condition'
either 'statement 1' or 'statement 2' will be executed.
 
.*B*
.*
.FIF
.*R*
IF (IEXP == ZERO)
   ANSWER = 1.0
ELSE
   ANSWER = BASE**IEXP
IF (SKY == GRAY) [
   COVER = CLOUDY
   IF (PRECIP == WET) [
      WEATHER = RAINY
      CLIMATE = DAMP
   ]
]
ELSE [
   COVER = CLEAR
   WEATHER = FAIR
   IF (TEMP > FREEZE) [
      ICE = NONE
      SKATING = POOR
   ]
]
.*
.FIN
.*R*
 
The IF ... ELSE IF ... ELSE construct is useful when two or more possibilities
exist for program control.
.*B*
 
Multiple tests can be cascaded using a construct like:
 
.*
.FIF
.*R*
IF (test1)
   statement 1
ELSE IF (test2)
   statement 2
ELSE IF (test3)
   .
   .
   .
.*
.FIN
.*R*
 
This construction is sometimes termed a "skinny tree".  Depending on the
application it may be simpler to use the CASE statement (explained later).
 
.*B*
Note: As observed in the above examples, the statements that follow an IF or
ELSE occur on the next line with no indication of continuation.  This format is
used for greater readability.  RATFOR knows that an executable statement needs
to follow an IF or ELSE and will read as far as necessary into the source code
to satisfy that requirement.  A discussion on program formatting can be found
in the section entitled "Source Code Formatting".
 
If IF statements and ELSE statements are nested, there is a possible ambiguity
in how to match up ELSE statements with IF statements.  The following
illustrates this problem:
 
.*
.FIF
.*R*
IF (TEST 1)
IF (TEST 2)
      do something
ELSE
   something
.*
.FIN
.*R*
 
The rule that RATFOR uses is that an ELSE is matched with the inner most
unELSEd IF.
 
.*B*
The following illustrates how indenting could lead one to interpret this code
incorrectly.
 
.*
.FIF
.*R*
IF (TEST 1)
   IF (TEST 2)
      do something
ELSE
   something
.*
.FIN
.*R*
 
The above indenting structure is misleading.  The structure makes it appear
that the ELSE goes with the first IF rather than the second which is how RATFOR
handles it.
 
.*B* WHILE
WHILE
.*R*
-----
 
Sometimes during program execution, a statement needs to be executed over and
over while a certain test condition is true.  For this type of application, the
WHILE construct should be used.  The syntax for the WHILE is:
 
.*
.FIF
.*R*
WHILE (test condition)
   statement
.*
.FIN
.*R*
 
If 'test condition' is true, 'statement' is executed and continues to be
executed until 'test condition' becomes false.  If 'test condition' is
initially false, 'statement' will not be executed at all.  If 'test condition'
is false on the initial execution of the WHILE, 'statement' will not be
executed at all.
 
.*
.FIF
.*R*
EXAMPLE
 
IEXP = 0
WHILE (ANSWER < REALMAX) [
   IEXP = IEXP + 1
   ANSWER = 10.0**IEXP
]
WHILE (CAT > AWAY) [
   MICE = PLAY
   IF (MICE >= SQUIRREL) [
      MICE = RATS
      PLAY = TOUGH
   ]
   CAT = RANDOM (J)
]
.*
.FIN
.*R*
 
.*B*  REPEAT_UNTIL
REPEAT...UNTIL
.*R*
----------------
 
The REPEAT ... UNTIL construct is much like the WHILE except that instead of
checking the test condition at the top of the block of statements, it is
checked at the bottom.  This means that the statement controlled by a REPEAT
will always be executed at least once.  The syntax for a REPEAT is:
 
.*
.FIF
.*R*
REPEAT
   statement
UNTIL (test condition)
.*
.FIN
.*R*
 
'statement' is executed repeatedly until 'test condition' becomes true.
 
.*B*
EXAMPLES
 
.*
.FIF
.*R*
COMMAND = ' '
REPEAT $(
   CALL PARSE (COMMAND)
   READ (KEYBOARD, '(A)') COMMAND
$) UNTIL (COMMAND == 'STOP')
 
DEFINE (@FOREVER, UNTIL (.FALSE.))
   ...
REPEAT [
   READ (FILE1, END=10) DATA
   IF (DATA < ZERO)
      DATA = ABS(DATA)
   CALL CRUNCH (DATA)
] @FOREVER
.*
.FIN
.*R*
 
 
The REPEAT construct may be used without the UNTIL to create an infinite loop.
The syntax for this is:
.*B*
 
.*
.FIF
.*R*
REPEAT
   statement
.*
.FIN
.*R*
 
 
Again, 'statement' is executed repeatedly, but this time no test condition
exists to terminate the loop explicitly at the end of the construct.  To
terminate an infinite loop a BREAK construct (see the section entitled
"BREAK"), an "END=" clause in a READ statement or a GOTO statement could be
used.
 
The use of a REPEAT without an UNTIL and without a BREAK causes the RATFOR
preprocessor to generate a FORTRAN CONTINUE statement that cannot be reached
from anywhere in the program.  The FORTRAN compiler reports an error if this
condition occurs.  To avoid this, use a construct as shown in the previous
examples.  With FOREVER defined as "UNTIL (.FALSE.)", the REPEAT ... UNTIL will
be an infinite loop but will not generate the FORTRAN compiler error message.
 
.*B* REPEAT_VS_WHILE
REPEAT Versus WHILE
.*R*
-------------------
 
Generally the WHILE statement should be used instead of the REPEAT statement.
One reason is that correctness proofs use the concept of loop invariants which
is better modeled using the WHILE statement.  Also, code with straightforward
initialize and increment steps are more clearly rendered with a WHILE.
 
.*B*
Consider the following simple example:
 
.*
.FIF
.*R*
XSUM = 0.
READ (@LUN, *, IOSTAT=ISTATUS) VALUE
WHILE (ISTATUS == 0) [
   XSUM = XSUM + VALUE
   READ (@LUN, *, IOSTAT=ISTATUS) VALUE
]
IF (ISTATUS > 0) [
   CALL ERROROUT (108, ISTATUS)
   CALL ABORT
]
 
XSUM = 0.
REPEAT [
   READ (@LUN, *, IOSTAT=ISTATUS) VALUE
   IF (ISTATUS < 0)
      BREAK
   XSUM = XSUM + VALUE
] @FOREVER
IF (ISTATUS > 0) [
   CALL ERROROUT (108, ISTATUS)
   CALL ABORT
]
.*
.FIN
.*R*
 
Note that the two segments are about the same length but the REPEAT has the
termination condition buried in the middle of the loop.  This makes it harder
for a reader to detect the manner in which the loop would normally terminate.
 
.*B* FOR
FOR
.*R*
---
 
Two other constructs are provided for conventional looping operations.  These
are FOR and DO constructs.  The syntax of the FOR is:
 
.*
.FIF
.*R*
FOR (initialize; test; assign)
   statement
.*
.FIN
.*R*
 
The parameter 'initialize' is a simple statement which defines the initial
value of the loop variable.  The parameter 'test' is a test condition that is
checked to see if the execution of the FOR construct should continue.  If
'test' is true, execution continues.  The parameter 'assign' is a simple
statement that assigns the next value of the loop variable before 'test' is
checked again.  The FOR construct is exactly equivalent to:
 
.*B*
.*
.FIF
.*R*
initialize
WHILE (test) [
   statement
   assign
]
.*
.FIN
.*R*
 
EXAMPLE
 
.*
.FIF
.*R*
FOR (I=ISTART; I>0; I=IARRAY(I))
   CALL READCHAR (COL(I))
.*
.FIN
.*R*
 
The FOR construct will initialize 'I' at ISTART and as long as 'I' is greater
than zero, will execute the subroutine call.  'I' is then replaced by IARRAY(I)
and the process is repeated.  The statement following a FOR may be compound.
 
.*B* DO
DO
.*R*
--
 
The DO construct is very much like the DO statement in FORTRAN, except that no
statement label need be associated.  The syntax for the DO is:
 
.*
.FIF
.*R*
DO var = begin, end, incr
   statement
.*
.FIN
.*R*
 
where 'incr' is optional.
 
.*
.FIF
.*R*
EXAMPLE
 
DO I = 1, 100 [
   X(I) = Y(I)*Z(I)
   WRITE (LUNOUT, '(F)') X(I)
]
.*
.FIN
.*R*
 
.*B* DO_VS_FOR
DO Versus FOR
.*R*
-------------
 
For most uses, the DO statement will serve just fine.  The FOR statement serves
several, limited purposes.  In the days of FORTRAN 66 it supported zero trip
loops while most implementations of FORTRAN implemented DO loops as one trip
loops.
 
The other use of the FOR is when a loop needs to change the index variable, the
increment variable or the termination values.  FORTRAN 77 DO loops do not
permit any of these modifications in the body of the loop.  The FOR loop should
be used in these cases.
 
.*B* BREAK
BREAK
.*R*
-----
 
The BREAK construct provides a means for exiting a WHILE, REPEAT, FOR or DO
loop.  The syntax for a BREAK is:
 
BREAK
 
The BREAK construct will cause program control to continue with the first
statement following a WHILE, REPEAT, FOR or DO loop.
 
.*
.FIF
.*R*
      +-------------- LOOP
      |
      |
      |
      |      BREAK ------+
      |                  |
      |                  |
      |                  |
      +--------------    |
             <-----------+
.*
.FIN
.*R*
 
 
.*B*
EXAMPLE
 
.*
.FIF
.*R*
REPEAT [
   READ (FILE) DATAPOINT
   IF (DATAPOINT <= ZERO)
      BREAK
   N = N + 1
]
#  The BREAK will cause program control to continue after
#  these comments.
 
.*
.FIN
.*R*
 
.*B* NEXT
NEXT
.*R*
----
 
During the execution of a FOR, DO, REPEAT or WHILE construct, it may be
desirable to skip to the next iteration of the loop.  This is facilitated by
the NEXT construct.
 
Execution of a NEXT in the body of a looping construct will cause program
control to continue at the 'assign' of a FOR or DO construct or at the 'test
condition' of a WHILE or REPEAT.
 
.*
.FIF
.*R*
      +-------------- LOOP
      |
      |
      |
      |      NEXT  ------+
      |                  |
      |                  |
      |                  |
      +----------- <-----+
 
.*
.FIN
.*R*
.*B*
 
EXAMPLES
 
.*
.FIF
.*R*
DO I = 1, 100 [
   IF (I ==  3 .OR.
       I == 14  .OR.
       I == 87)
      NEXT
   X(I) = (X(I) + X(3) + X(14) + X(87))/4.
]
 
ANGLE = 0.0
REPEAT $(
   ANGLE = ANGLE + 1.35
   IF (ANGLE > 45.0  &  ANGLE < 90.0)
      NEXT
   SINE = SIN (ANGLE/57.2958)
$) UNTIL (ANGLE >= 360.)
.*
.FIN
.*R*
 
.*B* CASE
CASE
.*R*
----
 
When it is desired to branch to many different areas of a program from the same
point depending on the integer value of an evaluated expression, the CASE
construct should be used.  This construct acts much the same way as a skinny
tree of IF ... ELSE constructs, except that it is more easily understood for
the many branching case.  The syntax for the CASE is:
 
.*
.FIF
.*R*
SWITCH (var) [
   CASE  a1, a2, ..., ai:
      statement 1
   CASE  b1, b2, ..., bj:
      statement 2
           .
           .
           .
   DEFAULT:
      default statement
]
.*
.FIN
.*R*
 
.*B*
The parameter 'var' is an expression that is evaluated to an integer value
which determines which statement should be executed.  If 'var' equals a1, a2,
 ...  or ai, 'statement 1' will be executed.  If 'var' equals b1, b2, ... or
bj, 'statement 2' will be executed, and so on with all the possible cases.  The
parameters listed after each CASE are integer constants which may include zero
and negative values.  If no match is found with any case listed, 'default
statement' is executed.  If no match is found and a DEFAULT case is not
supplied, no statements are executed.
 
Any portion of the integer list which follows the word CASE may be replaced
with
 
n1 - n2
 
which designates a range of values from n1 to n2.
 
.*B*
EXAMPLES
 
.*
.FIF
.*R*
DO I = 1, 10
   SWITCH (I) [
      CASE 1:
         READ (LUN1) DATA
      CASE 2:
         WRITE (LUN2) DATA
      CASE 3:
         CALL AVERAGE (DATA, NUM)
         WRITE (LUN2) NUM
      DEFAULT:
         WRITE (LUNOUT, 900)
900      FORMAT ('COMMAND NOT IMPLEMENTED YET')
   ]
 
DO I = -20, 20
   SWITCH (I+4) $(
      CASE 1, 3, 5-9: $(
         ARRAY(I) = ARRAY(I)/PI
      $)
      CASE 2, 4, 11, 19, 20: $(
         ARRAY(I) = PI*I**2
         WRITE (FILE2) ARRAY(I)
      $)
      CASE 10:
         READ (FILE1) X
      CASE -1 - -5, -11:
         WRITE (LUNOUT) ARRAY(I)
      DEFAULT:
         WRITE (LUNOUT, '(A)') 'ERROR'
   $)
.*
.FIN
.*R*
 
.*B* RETURN
RETURN
.*R*
------
 
The RETURN construct can be used as a substitute for a FORTRAN RETURN statement
in a FUNCTION subprogram.  The syntax for the RETURN is:
 
RETURN (expr)
 
The parameter 'expr' should be the value that is to be returned as the value of
the function.  Multiple RETURN constructs may appear in different portions of
the FUNCTION subprogram to assign different values to the FUNCTION depending on
various other parameters.
 
.*B*
EXAMPLE
 
.*
.FIF
.*R*
FUNCTION COMPARE (X, Y, Z)
 
IF (X < 0  &  Y > 0)
   RETURN (X+Y)
IF (X > Y)
   RETURN (-1.)
IF (X == Y)
   RETURN (0.)
RETURN (1.)
END
.*
.FIN
.*R*
 
.*K* FORMATTING SOURCE_FORMATTING PRETTY_PRINTING
SOURCE CODE FORMATTING
 
As should be apparent from the examples, there is a suggested style of source
code formatting.  This formatting aids in the readability of the source code
and accents the major blocks of the code.  It also develops a visual hierarchy
that helps someone reading the code to understand the program more quickly.
FORTRAN is usually thought of as being "one dimensional".  With proper
formatting, RATFOR can be "two dimensional".
 
Some simple suggestions have been adopted for formatting RATFOR.  The following
is a summary of these suggestions.  Their use is not mandatory, but is
recommended to gain the full benefit of RATFOR.  The indentations mentioned are
easily obtained by using the tab on the computer terminal.  Before entering an
editor to create the RATFOR source code, be sure that appropriate tab stops
have been set.  The following are recommended.
 
!TABS 7, 10, 13, 16, 19, 22, 25
 
Every time that the tab is then requested, the computer will move the cursor to
the next tab position as specified by the TABS command.
 
.*B* SUGGESTION
Suggestion for Formatting RATFOR Source Code
.*R*
--------------------------------------------
 
o    When not indenting, start all source code in column 7.
 
o    Each time a new construct is introduced, indent the next line(s) of code 3
spaces.  Indent nested code 3 spaces from the level where the nesting started.
 
o    When using compound RATFOR statements, the opening delimiter $( or [
should appear at the end of the line beginning the block.
 
o    When using compound RATFOR statements, the closing delimiter $) or ]
should be on a new line and should start in the same column as the line that
introduced the block.
 
o    Put the executable statement for an IF ... ELSE construct on a new line,
after the IF or ELSE, indented 3 spaces.
 
o    Space before and after the operators '+', '-' and '='.  An except would be
to not space around the '=' of FORTRAN keyword parameters in I/O statements.
For example:
              CALL SUBRTN (X, Y, Z)
 
.*B*
o    Space after every comma (',').
 
o    Space between a keyword, function name or subroutine name and the
beginning of an argument list such as in:
        CALL SUBRTN (X, Y, Z)
 
o    Always space after any FORTRAN or RATFOR keyword.
 
o    Lines which are entirely comments should have the '#' in column 1 and the
body of the comment begin at the same indentation level of the code it is
commenting.  If the comment documents a significant section of code, it should
be preceded by a blank line.
 
o    Continuation lines should be indented at least one level.  Sometimes more
indentation may be appropriate to illustrate parallelism between the initial
and continuation lines.
 
o    Relational operators (e.g. < or ==) should have a space on each side.
 
o    Logical operators (e.g. &) should have two spaces on each side.
 
.*K* INVOCATION OPTIONS
RATFOR PREPROCESSOR OPERATION
 
After developing a RATFOR program with a text editor, it will be necessary to
translate RATFOR source code into FORTRAN.  To run the preprocessor type:
 
!RATFOR.X  srcfile  INTO|ON|OVER  outfile [,listfile] (options)
 
'srcfile' is the RATFOR source code developed with the editor.  'outfile' is
the standard FORTRAN source created by the RATFOR preprocessor.  'listfile' is
the destination file for all other RATFOR output, including RATFOR source
listing and RATFOR errors.  'outfile' should now be used as the input file for
the FORTRAN compiler.
 
Valid options are:
 
.*
.FIF
.*R*
[N]LS   - List RATFOR source on 'listfile'
 
[N]LF   - List FORTRAN source on 'listfile'
 
[N]LI   - List FORTRAN include source on 'listfile'
 
[N]LL   - List long names dictionary on 'listfile'
 
[N]KEYSEQ - Put RATFOR source keys in the FORTRAN source sequence field
(73-80)
 
LONGNAME=n - Length of FORTRAN variable names to generate
 
[N]STRING - Permit STRING as a valid RATFOR keyword
.*
.FIN
.*R*
 
The default options are NLS, NLF, NLI, NLL, NSTRING, NKEYSEQ and LONGNAME=0.
 
Two other options are:
 
STOP  - Exit RATFOR back to the system
 
HELP  - Produce a printout of the available options
 
.*B*
 
The STRING option is only used when processing the RATFOR code itself.  RATFOR
has a STRING keyword which is not covered in these notes.  It was useful in the
days of FORTRAN 66 when all character string work was done with integer arrays.
The STRING statement has one parameter, a quoted string which RATFOR converts
to an integer array declaration and DATA statements to initialize the elements
to the characters of the quoted string.  However, with FORTRAN 77 CHARACTER
variables, the feature is not needed except for the RATFOR processor itself
which was written in terms of the STRING keyword.
 
The LL and LONGNAME options are related.  LL only has meaning if the 'n' value
LONGNAME is nonzero.  If LONGNAME is zero, the default, variables encountered
by RATFOR are passed unchanged into the FORTRAN source code.  However, if
LONGNAME is nonzero, then any name RATFOR encounters which is longer than 'n'
is converted into another unique name which is no longer than 'n'.
 
For example, if a program is being developed in RATFOR for a pure FORTRAN 77
compiler, the program could use names longer than 6 characters, the FORTRAN 77
standard, and still have the program run correctly through the compiler.  The
LL option would display the dictionary mapping long names into unique names.
 
.*K* ERRORS
ERRORS
 
RATFOR errors, as opposed to FORTRAN errors (make sure to distinguish between
the two) are reported to 'listfile' during the running of the RATFOR
preprocessor.  If 'listfile' is not specified, errors will be printed at the
default device (ME).
 
A major weakness for RATFOR is its error checking.  Novice users could become
very frustrated by the lack of clear error messages for common mistakes.
 
Also, the RATFOR lexical scanner is not the greatest.  Sometimes RATFOR
complains about a line and the solution proves to be to insert a comment line
between two statements.
 
The following note some of the shortcomings and more obscure errors that a user
might encounter.
 
Unexpected EOF
      - This message indicates that there is an unmatched opening bracket in
the source code.  RATFOR was looking to close it when the end of the source
code was encountered.
 
.*B*
Strange messages from FORTRAN
     - where part of a statement seems to be missing.  RATFOR has a 200
character buffer for processing 'test condition' clauses and quoted literal
strings.  If it finds tokens longer than this, RATFOR quits at 200 characters
and with no message begins the lexical processing at that point.  A classic
cause of this is to leave off the closing right parenthesis of a 'test
condition'.  RATFOR keeps plowing through code looking for that matching right
parenthesis until if fills its buffer.
 
Defines not included in a source file
      - The INCLUDE statement has no message if the INCLUDE file is not
located.  RATFOR just continues along on its merry way not including the file
and not letting the user know.
 
missing function
      - RATFOR gets upset of a function name begins with a dollar sign ($).
RATFOR has to parse function statements for possible use with the RETURN
(expression) statement.  In doing this, the dollar sign confuses it into
thinking it is working on a macro and missed the function name.  However, the
FORTRAN code generated is correct.
 
.*K* ADVANCED_FEATURES
ADVANCED FEATURES
 
.*B* MACROS
Macros
.*R*
------
 
Another capability of the DEFINE is in the development of "macro statements"
(macros).  Macros are analogous to statement functions in which parameters may
appear in the replacement text.  Any occurrences of the strings '$n' in the
replacement text, where 1 <= n <= 9, will be replaced with the n'th argument
when the macro is actually invoked.
 
EXAMPLE
 
.*
.FIF
.*R*
DEFINE (MEAN, AVERAGE = ($1 + $2 + $3)/3.0)
 
X = MEAN (X, Y, Z)
.*
.FIN
.*R*
 
These two statements will be expanded to:
 
AVERAGE = (X + Y + Z)/3.0
 
The use of compound statements in also acceptable in a DEFINE.
 
.*B*
EXAMPLE
 
.*
.FIF
.*R*
DEFINE (DIAGNOSTIC, $( OUTPUT 'DIAGNOSTICS' _
         WRITE (108, '(1X, 2G)') $1, $2 _
         OUTPUT 'END OF DIAGNOSTIC' $))
.*
.FIN
.*R*
 
This DEFINE may be used as a debugging aid throughout a program.  The
parameters '$1' and '$2' are in the form of a macro.  A typical application
would be:
 
.*
.FIF
.*R*
IF (ISTAT .GT. 0) DIAGNOSTIC (A, B)
.*
.FIN
.*R*
 
If 'ISTAT' were ever greater than zero, the two variables 'A' and 'B' would be
output with the messages.
 
.*B*
In addition to the DEFINE, four other macros are provided by RATFOR.  These are
the ARITH, INCR, IFELSE and SUBSTR macros.
 
.*
.FIF
.*R*
.*B* ARITH
ARITH (p, op, q)
.*
.FIN
.*R*
 
 
ARITH performs the integer arithmetic specified by 'op' (+, -, *, /) between
'p' and 'q' and returns the result as its replacement.  'p' and 'q' must be
either constants or previously defined in a DEFINE construct.
 
The statements:
 
.*
.FIF
.*R*
DEFINE (X, 2)
DEFINE (Y, 3)
DIMENSION XARRAY (ARITH (X, *, Y))
.*
.FIN
.*R*
 
will be translated to
 
.*
.FIF
.*R*
DIMENSION XARRAY (6)
.*
.FIN
.*R*
 
.*B* INCR
INCR (p)
 
INCR converts 'p' to a number, adds one (1) to it and returns the value as its
replacement.  'p' must be an integer constant or previously DEFINEd.
 
EXAMPLE
 
The statements:
 
.*
.FIF
.*R*
DEFINE (X, 10)
 
K = INCR(X)
.*
.FIN
.*R*
 
will be translated to
 
.*
.FIF
.*R*
K = 11
.*
.FIN
.*R*
 
.*B* IFELSE
IFELSE (a, b, c, d)
 
IFELSE compares 'a' and 'b' as character strings and if they are the same, 'c'
is returned as the result, otherwise 'd' is returned.  'a', 'b', 'c' and 'd'
must be constants or previously DEFINEd.
 
EXAMPLE
 
The statements:
 
.*
.FIF
.*R*
STRING = IFELSE (CAT, DOG, .TRUE., .FALSE.)
ANIMAL = IFELSE (MOO, MOO, COW, HORSE)
.*
.FIN
.*R*
 
are translated to
 
.*
.FIF
.*R*
STRING = .FALSE.
ANIMAL = COW
.*
.FIN
.*R*
.*B* SUBSTR
 
SUBSTR (s, m, n)
 
SUBSTR produces the substring of 's' which starts at location 'm' (with an
origin of one) and has length 'n'.  If 'n' is omitted or too big, the remainder
of the string is used (from 'm' to the end).  If 'm' is out of the range of
's', a null string is returned.  's', 'm' and 'n' must be constants or
previously DEFINEd.
 
.*B*
EXAMPLE
 
The statement:
 
.*
.FIF
.*R*
STRING = SUBSTR (YES WE HAVE NO BANANAS, 5, 10)
.*
.FIN
.*R*
 
will be translated to
 
.*
.FIF
.*R*
STRING = WE HAVE NO
.*
.FIN
.*R*
 
.*B* IFDEF IFNOTDEF
IFDEF and IFNOTDEF
.*R*
------------------
 
The IFDEF and IFNOTDEF constructs are used as conditional processing commands
during execution of the RATFOR preprocessor.  Their syntax is:
 
.*
.FIF
.*R*
IFDEF (name, text1)
IFNOTDEF (name, text2)
.*
.FIN
.*R*
 
The parameter 'name' is checked to see if it has been previously DEFINEd.  For
IFDEF, if 'name' was DEFINEd, 'text1' would then be processed.  If 'name' was
not previously DEFINEd, and the IFNOTDEF construct was executed, 'text2' would
then be processed.
 
.*B*
EXAMPLE
 
The following could be used when using different devices for graphic output.
 
.*
.FIF
.*R*
DEFINE (PLOTTER, AVAILABLE)  (This may or may not appear depending
           .                  on whether or not 'PLOTTER' is to be
           .                  DEFINEd.)
           .
IFDEF (PLOTTER, DEFINE (DEVNUM, 13))
IFNOTDEF (PLOTTER, DEFINE (DEVNUM,0))
.*
.FIN
.*R*
 
 
.*B* INTEGER_CONSTANTS
Integer Constants
.*R*
-----------------
 
Integer constants in bases other than decimal may be specified as:
 
n%dddd...
 
where 'n' is a decimal number indicating the base and 'dddd...' are digits in
that base.  For n > 10, letters are used for digits above 9.
 
EXAMPLES
 
.*
.FIF
.*R*
Constant                    Decimal Equivalent
8%77                            63
2%001001                         9
16%2FF                         767
.*
.FIN
.*R*
 
The number is converted to the equivalent decimal value by multiplying each
digit by its positional value.  This may cause overflow if the numer is too
large.
 
.*B* ESCAPING_PREPROCESSOR
Escaping Lines
.*R*
--------------
 
If it becomes necessary to "force" a line through the RATFOR processor without
any modifications by the preprocessor, all that is needed is to put a percent
sign (%) in column one.  The preprocessor will delete the percent sign and
shift the entire statement to the left by one column.
 
EXAMPLE
 
.*
.FIF
.*R*
%      THIS STATEMENT SHOULD NOT BE TRANSLATED
 
becomes
 
      THIS STATEMENT SHOULD NOT BE TRANSLATED
 
.*
.FIN
.*R*
 
.*B* BREAK_N
BREAKn
.*R*
-------
 
The BREAK n construct is used when there are nested loops.  For example, if
there are 5 REPEAT constructs nested and in the innermost REPEAT a BREAK 3
construct occurs, program control will continue at the statement following the
2nd nested REPEAT.  The value of 'n' is the number of constructs to jump past.
 
.*
.FIF
.*R*
+--------------- LOOP 1
|
|   +----------- LOOP 2
|   |
|   |   +------- LOOP 3
|   |   |
|   |   |   +--- LOOP 4
|   |   |   |
|   |   |   |  NEXT n
|   |   |   |  BREAK n
|   |   |   |
|   |   |   +--- <- NEXT
|   |   |        <- BREAK
|   |   +------- <- NEXT 2
|   |            <- BREAK 2
|   +----------- <- NEXT 3
|                <- BREAK 3
+--------------- <- NEXT 4
                 <- BREAK 4
.*
.FIN
.*R*
 
 
.*B*
EXAMPLE
 
.*
.FIF
.*R*
DISCRM = RESULT/2.
REPEAT [
   N = N + 1
   IF (N > 100)
      BREAK
   REPEAT [
      I = N*4
      REPEAT [
         IF (DISCRM < ZERO)
            BREAK 2
         K = 3*I + SQRT(DISCRM)
      ] UNTIL (K > 5000)
   ] UNTIL (I >= 256)
#  The BREAK 2 will cause program control to continue after
#  these comments.
] FOREVER
#  The first BREAK will cause program control to continue after
#  these comments.
.*
.FIN
.*R*
 
.*B* NEXT_N
NEXTn
.*R*
------
 
The NEXT n construct is analogous to the BREAK n construct.  If there are
nested loops, the NEXT n will cause a skip to the next iteration of the n'th
loop construct from the current.  See the BREAK n discussion for a diagram of
the effects of the NEXT n construct.
 
.*K* REFERENCES
REFERENCES
 
Kernighan, Brian W. and Plauger, P. J., SOFTWARE TOOLS, Addison-Wesley, Reading
Mass., 1976
 
Documentation provided with the RATFOR preprocessor source code.
 
.*K* KEYWORDS
RATFOR Keywords
.*R*
---------------
 
The following is a list of reserved keywords which are used by the RATFOR
preprocessor during the translation of the RATFOR source code into FORTRAN
source code.  Use of these words as variable names or other FORTRAN names is
prohibited.
 
.*
.FIF
.*R*
ARITH          IFNOTDEF
BREAK          INCLUDE
CASE           INCR
DEFINE         NEXT
DO             REPEAT
ELSE           RETURN
FOR            SUBSTR
IF             SWITCH
IFDEF          UNTIL
IFELSE         WHILE
and if the STRING option is specified,
STRING
.*
.FIN
.*R*
 
.*K* DEBUGGING DELTA
DEBUGGING RATFOR PROGRAMS
 
Debugging RATFOR programs is slightly more difficult than debugging FORTRAN
programs because of line numbering.  Delta is based on FORTRAN source lines
while most RATFOR programmers would just have a RATFOR source code listing.
There are several ways to handle this situation.
 
First a source code listing could be generated from RATFOR by specifying the LS
and LF options.  When both of these options are present, RATFOR produces a side
by side listing of the RATFOR and FORTRAN code with both RATFOR line numbers
and FORTRAN line numbers.
 
A second way of debugging is to write modularly by using many subroutines and
functions.  By using ON CALL conditions in Delta, the user could frequently
reach the part of the program needing debugging fairly quickly.
 
Third, a user spending a very short amount of time comparing RATFOR source code
with the FORTRAN code produced could quickly figure out how many lines into a
subroutine certain statements are.  For example, RATFOR IF ... ELSE constructs
generate FORTRAN block IF statements and there is a very close match between
RATFOR statements and FORTRAN statements.
 
.*B*
Finally, since Delta can display the statement type as a user single steps
through a subroutine, the user can have a pretty good idea of the current
location in the routine being debugged.  For example two assignment statements
followed by a DO statement should give a good indication of position in a
routine.  Also, since Delta displays the FORTRAN line number, the user has
another idea of relative position.
 
.*K* RATFOR_VS_FORTRAN
RATFOR VERSUS FORTRAN
 
RATFOR was developed in the days of FORTRAN 66 and many of the RATFOR features
were major improvements over FORTRAN.  With the arrival of FORTRAN 77, the
advantages of RATFOR over FORTRAN are less, but still significant.  A
suggestion is that programs less than about 200 lines would not benefit from
RATFOR while larger programs would.
 
RATFOR still has more control structures than FORTRAN including FOR, REPEAT,
WHILE, CASE, NEXT and BREAK.  RATFOR has global substitutions and some macro
ability which FORTRAN does not.  RATFOR has more flexible source code formats
and commenting than FORTRAN.
 
Perhaps with the arrival of FORTRAN 8x, FORTRAN will have reached the point
where it matches the abilities of RATFOR.  However with the FORTRAN 8x standard
still some time off and processors for it further off, RATFOR still has some
life left in it.
.*K*  OWNER
Rob Janes, CUMMINS ENGINE CORP.
.*K* XINDEX
RATFOR.X
.*R*
AID=PROGRAMMING
.*R*
FORTRAN
.*R*
RATFOR
.*K* XINDEX_ABSTRACT
TOOL=RATFOR
.*R*
A RATional FORtran preprocessor for CP-6.
.*K* CHANGES Changes changes
97/11/11 [AT] RATFOR.X Has been made year 2000 ready. Please see star #42944
.*B*
860827
.*R*
Installed in LADC X account.
