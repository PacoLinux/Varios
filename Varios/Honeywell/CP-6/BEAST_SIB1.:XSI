10 REM This programme manipulates diskette image files (virtual
20 REM diskettes) and gives the user access to the CP/M format
30 REM files contained therein.
40 REM   BY DENNIS GRIESSER, SUMMER 1982.
50 REM   REVISION HISTORY:
60 REM      10/22/82 - $SYS, $R/O, *DEL* ATTRIBUTES.  ABILITY TO
70 REM                 COPY DELETED FILES.
80 REM      12/21/82 - REUSED BLOCK COUNT FOR *DEL*.
90 REM      03/16/83 - MASK ATTRIBUTE BITS ON OPEN.
100 REM      04/06/83 - MUNGE TYPE = BLOCKED.
110 REM      06/01/83 - FID EXPANDED TO NAME.EXT.ETC
120 REM      11/18/83 - TEXT-MUNGE EATS PARITY BIT
130 REM      10/12/84 - VARIOUS DISKETTE PARAMETERS MOVED TO CENTRAL
140 REM                 POINT - SIMPLIFIES ODDBALL CP/M TYPES.
150 REM      10/31/84 - VIRTUAL FILE DELETION, MUCH PROGRAMME
160 REM                 RESTRUCTURING.
170 REM      11/01/84 - DELETE, UNDELETE, AND CLEAN COMMANDS
180 REM      11/04/84 - COPY *TO* A VIRTUAL DISKETTE, FINALLY!
190 REM                 TEXT MUNGE AND VERBATIM SUPPORTED.
200 REM      11/06/84 - COPY BOTH WAYS OBEYS THE RECORD COUNT IN
210 REM                 THE FCB.  TEXT-MUNGE TO A DISKETTE IMAGE
220 REM                 COMPRESSES SPACES INTO TABS.
230 REM      11/19/84 - COPY FROM CP-6 TO CP/M NOW SUPPORTS CORE-IMAGE
240 REM                 (.COM FILE) MUNGE.
250 REM      11/27/84 - ADDED 'FILL' AND 'CHECK' COMMANDS
260 REM      12/14/84 - #n AS A CP/M FID GETS THAT FILE NUMBER
270 OPTION BASE 0
280 REM ****** FUNCTIONS ******
290 REM FNI$(P$,H$) OBTAINS COMMAND INPUT, ONE WORD AT A TIME.  EXTRA INPUT IS
300 REM          BUFFERED FOR LATER USE.  IF THE USER TYPES '?', THE HELP (H$)
310 REM          WILL BE PRINTED.
320 DEF FNI$(P$,H$)
330 DO WHILE LEN(CMDBUF$)=0
340   REM BUFFER EMPTY, GET INPUT AND STRIP TRAILING BLANKS
350   PRINT P$;
360   WHEN BREAK GOTO 370
370   LINPUT CMDBUF$
380   WHEN BREAK GOTO ERROR
390   CMDBUF$=FNC$(FNB$(CMDBUF$))
400   END DO
410 REM SATISFY INPUT FROM BUFFER
420 X=SCN(CMDBUF$," ",1,1)
430 IF X=0 THEN
440   XFNI$=CMDBUF$
450   CMDBUF$=""
460 ELSE
470   XFNI$=SST$(CMDBUF$,1,X-1)
480   CMDBUF$=FNC$(SST$(CMDBUF$,X+1))
490   ENDIF
500 IF XFNI$="?" THEN
510   PRINT H$
520   GOTO 340
530   ENDIF
540 FNI$=XFNI$
550 FNEND
560 REM FNB$(A$) RETURNS THE INPUT STRIPPED OF TRAILING BLANKS
570 DEF FNB$(A$)
580 IF LEN(A$)=0 THEN 630
590 IF SST$(A$,LEN(A$))=" " THEN
600   A$=SST$(A$,1,LEN(A$)-1)
610   GOTO 580
620   ENDIF
630 FNB$=A$
640 FNEND
650 REM FNC$(A$) RETURNS THE INPUT STRIPPED OF LEADING BLANKS
660 DEF FNC$(A$)
670 IF LEN(A$)=0 THEN 760
680 IF SST$(A$,1,1)=" " THEN
690   IF LEN(A$)=1 THEN
700     A$=""
710   ELSE
720     A$=SST$(A$,2)
730     ENDIF
740   GOTO 670
750   ENDIF
760 FNC$=A$
770 FNEND
780 REM FNSPL$(X$) RETURNS THE STRING WITH ALL PARITY BITS SET LOW
790 DEF FNSPL$(X$)
800 IF LEN(X$)=0 THEN 860
810 CHANGE X$ TO X
820 FOR I=LEN(X$)-1 TO 0 STEP -1!REMEMBER ZERO BASED ARRAYS
830   X(I)=MOD(X(I),128)
840   NEXT I
850 CHANGE X TO X$
860 FNSPL$=X$
870 FNEND
880 REM FNH$(D,N) RETURNS 'N' HEX NIBS FOR THE DECIMAL NUMBER
890 DEF FNH$(D,N)
900 XFNH$=""
910 FOR Z1=N TO 1 STEP -1
920   Z2=INT(D/(2**(4*Z1-4)))
930   Z2=Z2-INT(Z2/16)*16
940   XFNH$=XFNH$+SST$("0123456789ABCDEF",Z2+1,1)
950   NEXT Z1
960   FNH$=XFNH$
970   FNEND
980 REM FND(H$) RETURNS THE DECIMAL NUMBER CORRESPONDING TO THE PASSED HEX
990 REM         STRING.
1000 DEF FND(H$)
1010 XFND=0
1020 FOR X1=1 TO LEN(H$)
1030   X2=ASC(SST$(H$,X1,1))
1040   IF X2>57 THEN X2=X2-7
1050   IF X2=32 THEN X2=48
1060   XFND=(XFND*16) + X2-48
1070   NEXT X1
1080   FND=XFND
1090 FNEND
1100 REM FNRPR$(T,S) READS AND RETURNS THE PHYSICAL SECTOR WITH THE GIVEN
1110 REM           TRACK (T) AND SECTOR (S) NUMBERS.  IF THE RECORD IS
1120 REM           NOT AVAILABLE, THE NULL STRING IS RETURNED.
1130 DEF FNRPR$(T,S)
1140 X1$=""
1150 CUR_KEY$=CHR$(0)+CHR$(T)+CHR$(S)
1160 WHEN MONERR GOTO 1220
1170 LINPUT#1;CUR_KEY$,X1$
1180 IF LEN(X1$)<>SSIZ THEN
1190   PRINT LEN(X1$);"- byte record LINPUT with key:";
1200   PRINT ASC(SST$(CUR_KEY$,1,1)),ASC(SST$(CUR_KEY$,2,1)),ASC(SST$(CUR_KEY$,3,1))
1210   ENDIF
1220 FNRPR$=X1$
1230 FNEND
1240 REM FNWPR(T,S,X$) WRITES THE PHYSICAL SECTOR WITH THE GIVEN
1250 REM           TRACK (T) AND SECTOR (S) NUMBERS
1260 DEF FNWPR(T,S,X$)
1270 CUR_KEY$=CHR$(0)+CHR$(T)+CHR$(S)
1280 PRINT#1;CUR_KEY$,X$
1290 FNWPR=0
1300 FNEND
1310 REM FNRW(X$) RE-WRITES THE LAST ACCESSED SECTOR USING THE PASSED
1320 REM         DATA.  NOTHING USEFUL IS RETURNED.
1330 DEF FNRW(X$)
1340 PRINT#1;CUR_KEY$,X$
1350 FNRW=0
1360 FNEND
1370 REM FNRLR$(T,S) READS AND RETURNS THE LOGICAL SECTOR WITH THE GIVEN
1380 REM           TRACK (T) AND SECTOR (S) NUMBERS
1390 DEF FNRLR$(T,S)
1400 X=TRATAB(S)                  
1410 FNRLR$=FNRPR$(T,X)
1420 FNEND
1430 REM FNWLR(T,S,X$) WRITES THE LOGICAL SECTOR WITH THE GIVEN
1440 REM           TRACK (T) AND SECTOR (S) NUMBERS
1450 DEF FNWLR(T,S,X$)
1460 X=TRATAB(S)
1470 FNWLR=FNWPR(T,X,X$)
1480 FNEND
1490 REM FNPLB(B) PREPARES FOR SEQUENTIAL I/O AT THE GIVEN DATA BLOCK (1-N).
1500 DEF FNPLB(B)
1510 X=(B-1)*BSIZ + DATSEC-1
1520 X=FNPLT(INT(X/NSECTORS)+DATTRK,MOD(X,NSECTORS)+1)
1530 FNEND
1540 REM FNPLT(T,S) PREPARES FOR SEQUENTIAL I/O AT THE GIVEN LOGICAL TRACK
1550 REM          AND SECTOR.
1560 DEF FNPLT(T,S)
1570 NXT_LTRK=T
1580 NXT_LSEC=S
1590 FNEND
1600 REM FNRLS$(X) READS A LOGICAL SECTOR SEQUENTIALLY (X IS DUMMY).
1610 DEF FNRLS$(X)
1620 X$=FNRLR$(NXT_LTRK,NXT_LSEC)
1630 NXT_LSEC=NXT_LSEC +1
1640 IF NXT_LSEC > NSECTORS THEN
1650   NXT_LSEC=1
1660   NXT_LTRK=NXT_LTRK+1
1670   ENDIF
1680 FNRLS$=X$
1690 FNEND
1700 REM FNWLS(X$) WRITES A LOGICAL SECTOR SEQUENTIALLY.
1710 DEF FNWLS(X$)
1720 X=FNWLR(NXT_LTRK,NXT_LSEC,X$)
1730 NXT_LSEC=NXT_LSEC +1
1740 IF NXT_LSEC > NSECTORS THEN
1750   NXT_LSEC=1
1760   NXT_LTRK=NXT_LTRK+1
1770   ENDIF
1780 FNEND
1790 REM FNFF$(N) RETURNS A TEXT STRING CONTAINING THE NAME OF THE
1800 REM          FILE WITH THE PASSED INDEX.
1810 DEF FNFF$(N)
1820 FNFF$=NAME$(N)+"."+TYPE$(N)+"."+ETC$(N)
1830 FNEND
1840 REM FNFF(N$) RETURNS THE DIRECTORY INDEX OF THE FILE NAME PASSED.  0 ON
1850 REM         RETURN MEANS FILE NOT FOUND.  WE ALSO SET UP GLOBAL
1860 REM         VARIABLES TO CONTAIN NAME, TYPE, AND ETC.
1870 DEF FNFF(N$)
1880 FNFF=0
1890 X=SCN(N$,".",1,1)
1900 IF X=0 THEN
1910   !No ".", must be CP-6 file
1920   MNAME$=SST$(N$+"        ",1,8)
1930   MTYPE$="   "
1940   METC$=""
1950 ELSE
1960   !Found a ".", must be CP/M file
1970   MNAME$=SST$(SST$(N$,1,X-1)+"        ",1,8)
1980   IF SST$(MNAME$,1,1)="#" THEN
1990     !Reference by file NUMBER, not name
2000     X=VAL(SST$(MNAME$,2))
2010     MNAME$=NAME$(X)
2020     MTYPE$=TYPE$(X)
2030     METC$=ETC$(X)
2040     FNFF=X
2050     GOTO 2310
2060     ENDIF
2070   MTYPE$=SST$(N$+" ",X+1)
2080   X=SCN(MTYPE$,".",1,1)
2090   IF X=0 THEN
2100     MTYPE$=SST$(MTYPE$+"        ",1,3)
2110     METC$=""
2120   ELSE
2130     METC$=SST$(SST$(MTYPE$+" ",X+1),1,LEN(MTYPE$)-(X+1))
2140     MTYPE$=SST$(SST$(MTYPE$,1,X-1)+"   ",1,3)
2150     ENDIF
2160   ENDIF
2170 FOR X=1 TO NFILES
2180   REM * CHECK THE NAME
2190   IF MNAME$<>NAME$(X) THEN 2300
2200   REM * CHECK THE ATTRIBUTES.  MUST MATCH OR BE CONTAINED.
2210   IF ETC$(X)<>METC$ THEN
2220     IF LEN(METC$)=0 THEN 2300
2230     IF SCN(ETC$(X)+" ",METC$,1,1)=0 THEN 2300
2240     ENDIF
2250   REM * COMPARE EXTENSION (BLIND TO ATTRIBUTE BITS)
2260   IF MTYPE$<>TYPE$(X) THEN 2300
2270   REM * REQUESTED FILE HAS BEEN FOUND
2280   FNFF=X
2290   GOTO 2310
2300   NEXT X
2310 FNEND
2320 REM ****** MAIN CODE ******
2330 REM **** DCLS
2340 DIM X(300)!HANDY FOR SECTOR 'CHANGE' COMMAND
2350 DIM MIMAGE(65536)!MEMORY IMAGE, 0-BASED, FOR RU CONSTRUCTION
2360 REM **** INITIALIZATION
2370 PRINT "(Any time that you are prompted for input, you may type '?')"
2380 CMDBUF$=""
2390 REM **** SET UP FIRST VIRTUAL DISKETTE
2400 F$=FNI$("Virtual disk FID","CP-6 FID of file containing the CP/M diskette image.")
2410 REM TRY TO OPEN SPECIFIED DISK FILE
2420 WHEN MONERR GOTO 2450
2430 OPEN F$ TO 1,INPUT,UPDATE,SKEY
2440 GOTO 2490
2450 REM OPEN ERROR
2460 PRINT "Unable to OPEN that virtual disk."
2470 CMDBUF$=""
2480 GOTO 2400
2490 REM OPEN WORKED O.K.
2500 REM **** SET UP DISK PARAMETERS FOR THIS VERSION OF CP/M
2510 SKEW=6!SECTOR 1,7,13...
2520 MBIAS=256!FIRST ADDRESS OCCUPPIED BY COM-FILE
2530 NSECTORS=26!NUMBER OF SECTORS PER SIDE, NUMBERED 1-NSECTORS
2540 NTRACKS=77!NUMBER OF TRACKS PER SIDE, NUMBERED 0-(NTRACKS-1)
2550 BSIZ=8!NUMBER OF SECTORS PER BLOCK
2560 SSIZ=128!NUMBER OF BYTES PER SECTOR
2570 DATTRK=2!TRACK NUMBER THAT DATA STARTS ON
2580 DATSEC=9!SECTOR NUMBER THAT DATA STARTS ON IN DATTRK
2590 DIRTRK=2!DIRECTORY STARTS ON THIS TRACK
2600 DIRSEC=1!DIRECTORY STARTS ON THIS SECTOR
2610 DIRSIZ=16!NUMBER OF SECTORS IN DIRECTORY
2620 TABS=8
2625 MARGIN 80
2630 MARGIN#1,SSIZ
2640 MARGIN#2,510
2650 DIM TRATAB(27)!ENTRIES 1-26 ARE USED
2660 RESTORE 2680
2670 FOR I=1 TO 26\READ TRATAB(I)\NEXT I
2680 DATA 1,7,13,19,25,5,11,17,23,3,9,15,21,2,8,14,20,26,6,12,18,24,4,10,16,22
2690 REM **** SECONDARY CONSTANTS DERIVED FROM FUNDAMENTALS
2700 TOPBLOCK=INT((NTRACKS-DATTRK)*NSECTORS/BSIZ)!NUMBER OF LAST DATA BLOCK
2710 BOTBLOCK=2!FOR SOME REASON, BLOCK 1 OVERLAPS LAST DIRECTORY
2720 REM **** START BY LISTING THE DIRECTORY
2730 GOSUB 4990!MUNGE DIRECTORY INTO LOCAL STORAGE
2740 GOSUB 6060!PRINT THE DIRECTORY
2750 REM **** TOP OF COMMAND LOOP
2760 C$=UPC$(FNI$("Command","Choices are: C[OPY], DEL[ETE], CLE[AN], UNDEL, L[IST], Q[UIT], X[CHANGE], CH[ECK], FILL, E[ND]."))
2770 I=LEN(C$)              
2780 IF I>6 THEN 2890
2790 IF C$=SST$("COPY   ",1,I) THEN 4050
2800 IF C$=SST$("DELETE ",1,MAX(3,I)) THEN 3720
2810 IF C$=SST$("FILL   ",1,MAX(4,I)) THEN 2930
2820 IF C$=SST$("CHECK  ",1,MAX(2,I)) THEN 3050
2830 IF C$=SST$("UNDEL  ",1,I) THEN 3490
2840 IF C$=SST$("CLEAN  ",1,MAX(3,I)) THEN 3310
2850 IF C$=SST$("QUIT   ",1,I) THEN 4020
2860 IF C$=SST$("LIST   ",1,I) THEN 4950
2870 IF C$=SST$("XCHANGE",1,I) THEN 3950
2880 IF C$=SST$("END    ",1,I) THEN 3990
2890 PRINT "Unrecognized command.  For a list, type '?'."             
2900 CMDBUF$=""
2910 GOTO 2750!THIS COMMAND IS DONE
2920 REM *** CODE TO IMPLEMENT VARIOUS COMMANDS
2930 REM ** 'FILL' - WRITE OVER UNUSED SECTORS
2940 OREC$=""\FOR I=1 TO SSIZ\OREC$=OREC$+CHR$(FND("E5"))\NEXT I
2950 PRINT "Filling..."
2960 FOR CUR_BLOCK=BOTBLOCK TO TOPBLOCK
2970   IF BUSERS(CUR_BLOCK)=0 THEN
2980     X=FNPLB(CUR_BLOCK)!PREPARE FOR I/O
2990     FOR RECORD=1 TO BSIZ
3000       X=FNWLS(OREC$)   
3010       NEXT RECORD            
3020     ENDIF
3030   NEXT CUR_BLOCK
3040 GOTO 2750!THIS COMMAND IS DONE
3050 REM ** 'CHECK' - INSURE THAT USED SECTORS ARE ON DISKETTE
3060 TMISSING=0
3070 PRINT "Checking..."
3080 FOR CUR_FILE=1 TO NFILES
3090   IRECS=0!NUMBER OF RECORDS IN THIS FILE
3100   CMISSING=0
3110   FOR CUR_BLOCK=1 TO NB(CUR_FILE)
3120     X=FNPLB(B(CUR_FILE,CUR_BLOCK))!PREPARE FOR I/O
3130     FOR CUR_RECORD=1 TO BSIZ
3140       IRECS=IRECS+1
3150       IF IRECS>NR(CUR_FILE) THEN 3230
3160       X$=FNRLS$(0)!READ A SECTOR                
3170       IF LEN(X$)=0 THEN
3180         CMISSING=CMISSING+1
3190         PRINT FNH$(ASC(SST$(CUR_KEY$,1,1)),2)+FNH$(ASC(SST$(CUR_KEY$,2,1)),2)+FNH$(ASC(SST$(CUR_KEY$,3,1)),2)
3200         ENDIF        
3210       NEXT CUR_RECORD
3220     NEXT CUR_BLOCK
3230   REM DONE WITH THIS FILE
3240   IF CMISSING>0 THEN
3250     TMISSING=TMISSING+CMISSING
3260     PRINT FNFF$(CUR_FILE)+" is missing";CMISSING;" sectors."
3270     ENDIF
3280   NEXT CUR_FILE
3290 PRINT "There are";TMISSING;"total missing sectors."
3300 GOTO 2750!THIS COMMAND IS DONE
3310 REM ** 'CLEAN' - WIPE DIRECTORY ENTRIES FOR DELETED FILES
3320 X=FNPLT(DIRTRK,DIRSEC)!POSITION TO BEGINNING OF DIRECTORY
3330 E$=""\FOR I=1 TO 32\E$=E$+CHR$(229)\NEXT I!BUILD CLEAN DIRECTORY ENTRY
3340 FOR RECORD=1 TO DIRSIZ
3350    R$=FNRLS$(0)
3360    FOR START=1 TO SSIZ STEP 32
3370      IF ASC(SST$(R$,START,1))=229 THEN
3380        IF START+32>SSIZ THEN                      
3390          R$=SST$(R$,1,START-1)+E$
3400        ELSE
3410          R$=SST$(R$,1,START-1)+E$+SST$(R$,START+32)
3420          ENDIF
3430        ENDIF
3440     NEXT START
3450   X=FNRW(R$)
3460   NEXT RECORD
3470 GOSUB 4990!RE-MUNGE DIRECTORY AFTER CLEANUP
3480 GOTO 2750!THIS COMMAND IS DONE       
3490 REM ** 'UNDELETE' COMMAND - MAKE FILE FROM VIRTUAL FLOPPY NOT DELETED
3500 FI$=FNI$("CP/M file ID (target)","The CP/M ID of the file that is to be UNdeleted.")
3510 CUR_FILE=FNFF(FI$)
3520 IF CUR_FILE=0 THEN
3530   PRINT "That file does not exist."
3540   CMDBUF$=""
3550   GOTO 2750!THIS COMMAND IS DONE
3560   ENDIF
3570 X=FNPLT(DIRTRK,DIRSEC)!POSITION TO BEGINNING OF DIRECTORY
3580 FOR RECORD=1 TO DIRSIZ
3590   R$=FNRLS$(0)
3600   FOR START=1 TO SSIZ STEP 32
3610     EXTENT=(START-1)/32 + (RECORD-1)*SSIZ/32
3620     FOR I=1 TO NX(CUR_FILE)
3630       IF XL(CUR_FILE,I)=EXTENT THEN
3640         R$=SST$(R$,1,START-1)+CHR$(0)+SST$(R$,START+1)
3650         ENDIF
3660       NEXT I
3670     NEXT START
3680   X=FNRW(R$)
3690   NEXT RECORD
3700 GOSUB 4990!RE-MUNGE DIRECTORY AFTER UNDELETION
3710 GOTO 2750!THIS COMMAND IS DONE
3720 REM ** 'DELETE' COMMAND - DELETE FILE FROM VIRTUAL FLOPPY
3730 FI$=FNI$("CP/M file ID (target)","The CP/M ID of the file that is to be deleted.")
3740 CUR_FILE=FNFF(FI$)
3750 IF CUR_FILE=0 THEN
3760   PRINT "That file does not exist."
3770   CMDBUF$=""
3780   GOTO 2750!THIS COMMAND IS DONE
3790   ENDIF
3800 X=FNPLT(DIRTRK,DIRSEC)!POSITION TO BEGINNING OF DIRECTORY
3810 FOR RECORD=1 TO DIRSIZ
3820   R$=FNRLS$(0)
3830   FOR START=1 TO SSIZ STEP 32
3840     EXTENT=(START-1)/32 + (RECORD-1)*SSIZ/32
3850     FOR I=1 TO NX(CUR_FILE)
3860       IF XL(CUR_FILE,I)=EXTENT THEN
3870         R$=SST$(R$,1,START-1)+CHR$(229)+SST$(R$,START+1)
3880         ENDIF
3890       NEXT I
3900     NEXT START
3910   X=FNRW(R$)
3920   NEXT RECORD
3930 GOSUB 4990!RE-MUNGE DIRECTORY AFTER DELETION
3940 GOTO 2750!THIS COMMAND IS DONE
3950 REM ** 'X' COMMAND - EXCHANGE VIRTUAL DISKS
3960 CLOSE ALL
3970 GOTO 2400
3980   DSYS$="CP-6"
3990 REM ** 'END' COMMAND
4000 CLOSE ALL
4010 STOP
4020 REM ** 'QUIT' COMMAND
4030 CLOSE ALL
4040 IBEX "Q"
4050 REM ** 'COPY' COMMAND
4060 FI$=FNI$("Source file ID","The file from which the data is to be taken.")
4070 IF SCN(FI$,".",1,1)<>0 THEN
4080   REM THE COPY IS FROM VIRTUAL DISKETTE FILE TO CP-6 FILE
4090   DSYS$="CP-6"
4100   CUR_FILE=FNFF(FI$)
4110   IF CUR_FILE=0 THEN
4120     PRINT "That file does not exist in the diskette image "+F$+"."
4130     CMDBUF$=""
4140     GOTO 2750!THIS COMMAND IS DONE
4150     ENDIF
4160   DISP$=FNI$("Output FID disposition","Output disposition can be ON, TO, OVER, or INTO")
4170   FO$=FNI$("Destination file ID","The file to which the data is to be sent.")
4180   WHEN MONERR GOTO 4350
4190   IF DISP$="OVER" THEN
4200     OPEN FO$ TO 2,PRINT,OVER,CONSEC
4210     GOTO 4380
4220     ENDIF
4230   IF DISP$="TO" OR DISP$="ON" THEN
4240     OPEN FO$ TO 2,PRINT,CONSEC
4250     GOTO 4380
4260     ENDIF
4270   IF DISP$="INTO" THEN
4280     OPEN FO$ TO 2,INPUT,UPDATE,CONSEC
4290     RESTORE #2,EOF
4300     GOTO 4380
4310     ENDIF
4320   PRINT "Unknown file disposition."
4330     CMDBUF$=""
4340   GOTO 4160
4350   PRINT "OPEN ERROR.  Bad disp or FID."
4360     CMDBUF$=""
4370   GOTO 4160
4380   REM FILES OPEN FOR VIRTUAL -> CP-6 COPY
4390 ELSE
4400   REM COPY TYPE IS CP-6 -> CP/M
4410   DSYS$="CP/M"
4420   WHEN MONERR GOTO 4460
4430   OPEN FI$ TO 2,INPUT,CONSEC
4440   WHEN MONERR GOTO ERROR
4450   GOTO 4490
4460   PRINT "Unable to open that input file."
4470   CMDBUF$=""
4480   GOTO 2750!THIS COMMAND IS DONE
4490   REM INPUT FILE IS OPEN
4500   DISP$=FNI$("Output FID disposition","Output disposition must be TO or ON.")
4510   IF DISP$<>"TO" AND DISP$<>"ON" THEN 
4520     PRINT "Unknown file disposition."
4530     CMDBUF$=""
4540     GOTO 4500
4550     ENDIF
4560   FO$=FNI$("Destination file ID","The file to which data is to be written.")
4570   X=FNFF(FO$)
4580   IF X<>0 THEN
4590     PRINT "The file "+FO$+" already exists in "+F$+"."
4600     CMDBUF$=""
4610     GOTO 2750!THIS COMMAND IS DONE
4620     ENDIF
4630   NFILES=NFILES+1
4640   CUR_FILE=NFILES
4650   U(CUR_FILE)=0!USER
4660   NX(CUR_FILE)=0!NO EXTENTS YET
4670   NB(CUR_FILE)=0!NO BLOCKS YET
4680   NAME$(CUR_FILE)=MNAME$
4690   T$(CUR_FILE)=MTYPE$
4700   ENDIF      
4710 OPT$=UPC$(FNI$("Copy type","Choices are:  V[ERBATIM], T[EXT-MUNGE], C[ORE-DUMP], B[LOCKED]"))
4720 REM PARENTHESIS AROUND THE MUNGE-TYPE ARE IGNORED
4730 OPT$=REP$(OPT$,")","",-1,1)
4740 OPT$=REP$(OPT$,"(","",-1,1)
4750 C_TYPE=0
4760 IF SST$(OPT$,1,1)="V" THEN C_TYPE=1
4770 IF SST$(OPT$,1,1)="T" THEN C_TYPE=2
4780 IF SST$(OPT$,1,1)="C" THEN C_TYPE=3
4790 IF SST$(OPT$,1,1)="B" THEN C_TYPE=4
4800 IF C_TYPE=0 THEN
4810   PRINT "Invalid type.  Choices are:  V[ERBATIM], T[EXT-MUNGE], C[ORE-DUMP],"
4820   PRINT "                             B[LOCKED]"
4830   CMDBUF$=""
4840   GOTO 4710
4850   ENDIF
4860 IF DSYS$="CP-6" THEN
4870   GOSUB 6150!COPY CP/M -> CP-6
4880 ELSE     
4890   GOSUB 7360!COPY CP-6 -> CP/M
4900   GOSUB 8640!FLUSH LAST EXTENT IF NEEDED
4910   GOSUB 4990!RE-MUNGE DIRECTORY AFTER COPY
4920   ENDIF
4930 CLOSE 2
4940 GOTO 2750!THIS COMMAND IS DONE
4950 REM ** 'LIST' COMMAND
4960 GOSUB 6060!PRINT THE DIRECTORY
4970 GOTO 2750!THIS COMMAND IS DONE
4980 REM ****** SUBROUTINES! ******
4990 REM **** MUNGE THE DIRECTORY INTO LOCAL STORAGE
5000 REM ** ALLOCATE STORAGE FOR DIRECTORY & CLEAR IT
5010 DIM NAME$(100)!LIST OF VIRTUAL FILE NAMES
5020 DIM T$(100)!LIST OF VIRTUAL FILE TYPES (EXTENSIONS) - PARITY IS FLAG
5030 DIM TYPE$(100)!LIST OF VIRTUAL FILE TYPES (EXTENSIONS) ONLY
5040 DIM ETC$(100)!LIST OF VIRTUAL FILE ATTRIBUTE FLAGS
5050 DIM B(100,300)!FOR EACH VIRTUAL FILE, BLOCK NUMBERS IN IT
5060 DIM U(100)!USER NUMBER FOR THIS VIRTUAL FILE
5070 DIM NB(100)!NUMBER OF BLOCKS IN THIS VIRTUAL FILE
5080 DIM NX(100)!NUMBER OF EXTENTS ON THIS VIRTUAL FILE
5090 DIM NR(100)!NUMBER OF 128-BYTE RECORDS IN THIS VIRTUAL FILE
5100 DIM XL(100,50)!FOR EACH VIRTUAL FILE, LIST OF EXTENT NUMBERS
5110 DIM BUSERS(300)!COUNT OF DATA BLOCK USERS INDEXED BY BLOCK NUMBER
5120 MAT BUSERS=ZER
5130 NFILES=0
5140 REM ** POSITION TO BEGINNING OF DIRECTORY
5150 X=FNPLT(DIRTRK,DIRSEC)
5160 FOR RECORD=1 TO DIRSIZ
5170   R$=FNRLS$(0)
5180   FOR START=1 TO SSIZ STEP 32
5190     E$=SST$(R$,START,32)
5200     REM PROCESS E$, AN ENTRY IN THE DIRECTORY
5210     U=ASC(SST$(E$,1,1))!USE NUMBER
5220     N$=SST$(E$,2,8)!NAME
5230     T$=SST$(E$,10,3)!TYPE/EXTENSTION
5240     IF NFILES=0 THEN 5280
5250     FOR I=1 TO NFILES
5260       IF N$=NAME$(I) AND T$=T$(I) AND U=U(I) THEN 5390
5270       NEXT I
5280     REM THIS ENTRY IS NEW.  ADD THIS ENTRY TO THE DIRECTORY LIST.
5290     IF ASC(SST$(E$,1,1))=229 AND ASC(SST$(E$,2,1))=229 THEN 5540
5300     NFILES = NFILES +1
5310     I=NFILES
5320     T$(I)=T$
5330     NAME$(I)=N$
5340     U(I)=U
5350     NX(I)=0
5360     NB(I)=0
5370     NR(I)=0
5380     ETC$(I)=""
5390     REM MAKE THIS ENTRY (I) GROW BY ADDING A NEW EXTENT
5400     NX(I)=NX(I)+1
5410     NR(I)=NR(I)+ASC(SST$(E$,16,1))
5420     XL(I,NX(I))=(START-1)/32 + (RECORD-1)*SSIZ/32
5430     IF ASC(SST$(E$,13,1))<>NX(I)-1 THEN
5440       ETC$(I)=ETC$(I)+" *EXTENT OUT OF ORDER*"
5450       ENDIF
5460     FOR J=17 TO 32
5470       X=ASC(SST$(E$,J,1))
5480       IF X<>0 THEN
5490         NB(I)=NB(I)+1
5500         B(I,NB(I))=X
5510         BUSERS(X)=BUSERS(X)+1
5520         ENDIF
5530       NEXT J
5540     REM THIS ENTRY IS DONE!
5550     NEXT START
5560   NEXT RECORD
5570 REM * DONE SCANNING DIRECTORY
5580 REM ** SCAN INTERNAL TABLES TO BUILD ETC$ FIELDS
5590 FOR I=1 TO NFILES
5600   REM CHECK DELETED FILE OR USER NUMBER
5610   IF U(I)>0 AND U(I)<229 THEN ETC$(I)=ETC$(I)+" USER="+SST$(STR$(U(I)),2)
5620   IF U(I)=229 THEN
5630    ETC$(I)=ETC$(I)+" *DELETED*"
5640    REM  CHECK FOR 'RECOVERABILITY'
5650    MU=0
5660    IF NB(I)=0 THEN 5780
5670    FOR RI=1 TO NFILES
5680      IF RI=I OR NB(RI)=0 THEN 5770
5690      FOR RJ=1 TO NB(RI)
5700        FOR RK=1 TO NB(I)
5710          IF B(RI,RJ)=B(I,RK) THEN
5720            MU=MU+1
5730            GOTO 5760
5740            ENDIF
5750          NEXT RK
5760        NEXT RJ
5770      NEXT RI
5780    IF MU=NB(I) THEN
5790      ETC$(I)=ETC$(I)+" (ALL REUSED)"
5800    ELSE
5810      ETC$(I)=ETC$(I)+" ("+SST$(STR$(MU),2)+" REUSED)"
5820      ENDIF
5830    ENDIF
5840   REM (STRIP ATTRIBUTE BITS OFF EXTENSION)
5850   EXT=ASC(SST$(T$(I),1,1))
5860   IF EXT>=128 THEN
5870     EXT=EXT-128
5880     ETC$(I)=ETC$(I)+" $R/O"
5890     ENDIF
5900   TYPE$=CHR$(EXT)
5910   EXT=ASC(SST$(T$(I),2,1))
5920   IF EXT>=128 THEN
5930     EXT=EXT-128
5940     ETC$(I)=ETC$(I)+" $SYS"
5950     ENDIF
5960   TYPE$=TYPE$+CHR$(EXT)
5970   EXT=ASC(SST$(T$(I),3,1))
5980   IF EXT>=128 THEN
5990     EXT=EXT-128
6000     ETC$(I)=ETC$(I)+" $FLAG3"
6010     ENDIF
6020   TYPE$=TYPE$+CHR$(EXT)
6030   TYPE$(I)=TYPE$
6040   NEXT I
6050 RETURN
6060 REM **** LIST THE DIRECTORY FROM LOCAL STORAGE
6070 PRINT "DIRECTORY FOR VIRTUAL FLOPPY:  "+F$
6080 PRINT "NO NAME     EXT    EXTENTS    BLOCKS  FIRST BLK  (ETC.)"
6090 FOR I=1 TO NFILES
6100   PRINT USING 6110,I,NAME$(I),TYPE$(I),NX(I),NB(I),B(I,1),ETC$(I)
6110   :## 'LLLLLLL 'LL    #####      #####    ######    'LLLLLLLLLLLLLLLLLLLLLLL
6120   NEXT I
6130 PRINT "...";NFILES;" listed"
6140 RETURN
6150 REM **** COPY THE CURRENT FILE (DEFINED BY CUR_FILE INDEX) TO STREAM 2.
6160 WHEN BREAK GOTO 6460
6170 POSIT=1
6180 IF NB(CUR_FILE)=0 THEN
6190   PRINT "That file is empty."
6200   GOTO 6460
6210   ENDIF
6220 IF C_TYPE=4 THEN
6230   COBLK=0
6240   MOBLK=VAL(FNI$("Record size","What is the logical record size"))
6250   ENDIF
6260 IRECS=0!COUNT OF INPUT RECORDS
6270 REM *** FOR EACH BLOCK
6280 FOR CUR_BLOCK=1 TO NB(CUR_FILE)
6290   REM *** PREPARE FOR SEQUENTIAL READ
6300   X=FNPLB(B(CUR_FILE,CUR_BLOCK))
6310   FINISHED$="NO"
6320   REM *** FOR EACH RECORD IN THE BLOCK
6330   FOR CUR_RECORD=1 TO BSIZ
6340     REM *** COPY A RECORD
6350     X$=FNRLS$(0)
6360     IF LEN(X$)=0 THEN
6370       PRINT "WARNING - missing sector encountered"
6380       ENDIF
6390     IRECS=IRECS+1!COUNT OF INPUT RECORD
6400     IF IRECS>NR(CUR_FILE) THEN 6460!RECORD COUNT EXHAUSTED
6410     ON C_TYPE GOSUB 6500,6530,7060,6890
6420     IF FINISHED$="YES" THEN GOTO 6460
6430     REM *** DONE WITH THIS RECORD
6440     NEXT CUR_RECORD
6450   NEXT CUR_BLOCK
6460 REM *** DONE WITH COPY!
6470 WHEN BREAK GOTO ERROR
6480 RETURN
6490 REM *** ROUTINES TO COPY FROM VIRTUAL DISKETTE TO CP-6
6500 REM ** VERBATIM COPY
6510 PRINT#2,X$
6520 RETURN
6530 REM ** TEXT-MUNGE COPY
6540 ENDI=LEN(X$)
6550 X$=FNSPL$(X$)!SET PARITY BITS LOW
6560 FOR CHIDX=1 TO ENDI
6570   C$=SST$(X$,CHIDX,1)
6580   CVAL=ASC(C$)
6590   REM CHECK FOR (CR)
6600   IF CVAL=13 THEN
6610     PRINT#2,""
6620     POSIT=1
6630     GOTO 6860
6640     ENDIF
6650   REM CHECK FOR CTRL-Z
6660   IF CVAL=26 THEN
6670     PRINT#2
6680     FINISHED$="YES"
6690     RETURN
6700     ENDIF
6710   REM CHECK FOR TAB
6720   IF CVAL=9 THEN
6730     IF MOD(POSIT,TABS)=0 THEN
6740       POSIT=POSIT+TABS
6750     ELSE
6760       POSIT=POSIT+TABS -MOD(POSIT-1,TABS)
6770       ENDIF
6780     PRINT#2,TAB(POSIT);
6790     GOTO 6860
6800     ENDIF
6810   REM CHECK FOR (LF)
6820   IF CVAL=10 THEN 6860
6830   REM CHECK FOR OTHERS
6840   PRINT#2,C$;
6850   POSIT=POSIT+1
6860   REM DONE THIS CHARACTER
6870   NEXT CHIDX
6880 RETURN
6890 REM ** BLOCKED INPUT COPY
6900 REM COBLK=CURRENT SIZE OF OUTPUT RECORD
6910 REM MOBLK=MAX SIZE OF OUTPUT RECORD
6920 IF COBLK+LEN(X$)<MOBLK THEN
6930   PRINT#2,X$;
6940   COBLK=COBLK+LEN(X$)
6950 ELSE
6960   PRINT#2,SST$(X$,1,MOBLK-COBLK)
6970   IF MOBLK-COBLK=LEN(X$) THEN
6980     X$=""
6990   ELSE
7000     X$=SST$(X$,MOBLK-COBLK+1)
7010     ENDIF
7020   COBLK=0
7030   GOTO 6920
7040   ENDIF
7050 RETURN
7060 REM ** CORE-DUMP COPY
7070 REM OU FORMAT IS   :NNAAAAFFDD...DDYY
7080 REM WHERE NN=NUMBER OF DATA BYTES
7090 REM       AAAA=ADDRESS TO LOAD
7100 REM       FF=RECORD FUNCTION CODE (00)
7110 REM       YY=NEGATIVE CHECKSUM OF NN THROUGH DD
7120 REM * LOOP FOR EACH 32-BYTE CHUNK TO BE CONVERTED
7130 FOR IDX=1 TO SSIZ STEP 32
7140 REM INIT OUTPUT STRING
7150 LOC=(POSIT-1)*32 + IDX-1 + MBIAS     
7160 Y$=":"+FNH$(32,2)+FNH$(LOC,4)+"00"
7170 C=32 + INT(LOC/256) + MOD(LOC,256)
7180 REM LOOP FOR EACH BYTE TO OUTPUT
7190 FOR P=IDX TO IDX+31         
7200   VALU=ASC(SST$(X$,P,1))
7210   Y$=Y$+FNH$(VALU,2)
7220   C=C+VALU
7230   NEXT P
7240 REM MAKE CHECKSUM NEGATIVE
7250 C=0-C
7260 REM MAKE SURE CHECKSUM WILL FIT
7270 IF C>=0 THEN 7300
7280 C=C+256
7290 GOTO 7270
7300 REM APPEND CHECKSUM
7310 Y$=Y$+FNH$(C,2)
7320 PRINT#2,Y$
7330 NEXT IDX
7340 POSIT=POSIT+INT(SSIZ/32)
7350 RETURN
7360 REM **** COPY CP-6 FILE ON STREAM 2 TO CP/M FILE CUR_FILE
7370 WHEN BREAK GOTO 7620
7380 WASECTORS=0!NUMBER OF SECTORS LEFT IN CURRENT BLOCK (NORMALLY 1-BSIZ)
7390 WABINDEX=999!INDEX INTO BLOCK LIST IN EXTENT (NORMALLY 1-16)
7400 WAEXTENT=-1!EXTENT NUMBER (NORMALLY 0-(N-1))
7410 FINISHED$="NO"
7420 OREC$=""
7430 IRECS=0!COUNT OF INPUT RECORDS
7440 MTOP=0
7450 MBASE=65536
7460 WHEN EOF#2 GOTO 7510
7470 LINPUT#2,IREC$
7480 IRECS=IRECS+1
7490 ON C_TYPE GOSUB 7660,7740,8080,8050
7500 IF FINISHED$="NO" THEN 7470
7510 REM EOF ENCOUNTERED
7520 FINISHED$="YES"                   
7530 IREC$=""
7540 ON C_TYPE GOSUB 7660,7740,8080,8050!ALLOW APPROPRIATE TERMINATION
7550 IF OREC$<>"" THEN
7560   REM BUFFER NEEDS TO BE FLUSHED
7570   DO WHILE LEN(OREC$)<SSIZ
7580      OREC$=OREC$+CHR$(0)
7590      END DO
7600   GOSUB 8350
7610   ENDIF
7620 REM *** DONE WITH COPY
7630 WHEN BREAK GOTO ERROR
7640 RETURN
7650 REM *** ROUTINES FOR CP-6 -> CP/M COPY
7660 REM ** VERBATIM COPY
7670 IF FINISHED$="YES" THEN 
7680   RETURN!NO ADDITIONAL PROCESSING AT END
7690   ENDIF
7700 OREC$=IREC$
7710 GOSUB 8350!WRITE IT SEQUENTIALLY             
7720 OREC$=""
7730 RETURN
7740 REM ** TEXT-MUNGE COPY
7750 IF FINISHED$="YES" THEN
7760   IREC$=CHR$(26)!CTRL-Z MARKS EOF FOR CP/M
7770 ELSE
7780   REM ACTUAL DATA
7790   IREC$=FNB$(IREC$)!STRIP TRAILING BLANKS
7800   REM COMPRESS SPACES INTO TABS IF POSSIBLE
7810   OFFSET=0
7820   MAX_COL=LEN(IREC$)
7830   FOR COLUMN=TABS TO MAX_COL STEP TABS
7840     CUR_IDX=COLUMN+OFFSET
7850     IF SST$(IREC$,CUR_IDX-1,2)<>"  " THEN 7930!ONLY COMPRESS IF 2 CONSEC SPACES
7860     IREC$=SST$(IREC$,1,CUR_IDX-2)+CHR$(9)+SST$(IREC$,CUR_IDX+1)
7870     OFFSET=OFFSET-2+1!REMOVE TWO SPACES ADD ONE TAB
7880     FOR IDX=CUR_IDX-2 TO MAX(1,CUR_IDX-TABS+1) STEP -1
7890       IF SST$(IREC$,IDX,1)<>" " THEN 7930
7900       IREC$=SST$(IREC$,1,IDX-1)+SST$(IREC$,IDX+1)
7910       OFFSET=OFFSET-1
7920       NEXT IDX
7930     NEXT COLUMN
7940   REM TOSS IN <CR><LF> TO SEPARATE RECORDS
7950   IF IRECS>1 THEN IREC$=CHR$(13)+CHR$(10)+IREC$
7960   ENDIF
7970 IREC$=OREC$+IREC$!REAL DATA IS LAST CHUNK THEN THIS ONE
7980 DO WHILE LEN(IREC$)>SSIZ
7990   OREC$=SST$(IREC$,1,SSIZ)
8000   GOSUB 8350!WRITE IT SEQUENTIALLY
8010   IREC$=SST$(IREC$,SSIZ+1)
8020   END DO
8030 OREC$=IREC$!SAVE FRAGMENTS IN OUTPUT BUFFER
8040 RETURN
8050 REM ** BLOCKED-MODE COPY
8060 PRINT "Not yet implemented"\FINISHED$="YES"
8070 RETURN
8080 REM ** CORE-DUMP COPY
8090 IF FINISHED$="YES" THEN
8100   PRINT "Run unit occupies "+FNH$(MBASE,4)+"-"+FNH$(MTOP,4)+" HEX"
8110   IF FNH$(MBASE,4)<>"0100" THEN                
8120     PRINT "*** NOT A VALID STARTING ADDRESS"
8130     ENDIF
8140   FOR POSIT=MBASE TO MTOP STEP SSIZ
8150     OREC$=""
8160     FOR I=POSIT TO POSIT+SSIZ-1
8170       OREC$=OREC$+CHR$(MIMAGE(I))
8180       NEXT I
8190     GOSUB 8350!WRITE RECORD
8200     NEXT POSIT     
8210 ELSE
8220   IF SST$(IREC$,8,2)="00" THEN    
8230     REM LOAD DATA RECORD
8240     FIRSTLOC=FND(SST$(IREC$,4,4))
8250     LCOUNT=FND(SST$(IREC$,2,2))
8260     LASTLOC=FIRSTLOC+LCOUNT-1
8270     IF FIRSTLOC<MBASE THEN MBASE=FIRSTLOC
8280     IF LASTLOC>MTOP THEN MTOP=LASTLOC
8290     FOR L1=0 TO LCOUNT-1
8300       MIMAGE(FIRSTLOC+L1)=FND(SST$(IREC$,10+L1*2,2))
8310       NEXT L1
8320     ENDIF 
8330   ENDIF 
8340 RETURN
8350 REM ** WRITE RECORD OREC$ SEQUENTIALLY TO CP/M FILE CUR_FILE
8360 IF WASECTORS>0 THEN
8370   X=FNWLS(OREC$)
8380   WASECTORS=WASECTORS-1
8390   EXTENT$=SST$(EXTENT$,1,15)+CHR$(1+ASC(SST$(EXTENT$,16,1)))+SST$(EXTENT$,17)
8400   RETURN
8410   ENDIF
8420 REM GOTTA ALLOCATE A BLOCK
8430 IF WABINDEX<16 THEN
8440   FOR I=BOTBLOCK TO TOPBLOCK
8450     IF BUSERS(I)=0 THEN
8460       BUSERS(I)=1!MARK BLOCK AS IN USE
8470       WABINDEX=WABINDEX+1
8480       EXTENT$=EXTENT$+CHR$(I)
8490       WASECTORS=BSIZ
8500       X=FNPLB(I)!PREPARE FOR SEQUENTIAL OUTPUT
8510       GOTO 8350
8520       ENDIF
8530     NEXT I
8540   PRINT "NO FREE BLOCKS!  COPY ABORTS!"
8550   FINISHED$="YES"
8560   RETURN
8570   ENDIF
8580 REM GOTTA ALLOCATE EXTENT
8590 GOSUB 8640!FLUSH PREVIOUS EXTENT IF NEEDED
8600 WAEXTENT=WAEXTENT+1
8610 WABINDEX=1
8620 EXTENT$=CHR$(0)+MNAME$+MTYPE$+CHR$(WAEXTENT)+CHR$(0)+CHR$(0)+CHR$(0)
8630 GOTO 8420
8640 REM **** FLUSH EXTENT IF IT NEEDS IT
8650 IF WAEXTENT<0 THEN
8660   RETURN
8670   ENDIF
8680 DO WHILE LEN(EXTENT$)<32
8690   EXTENT$=EXTENT$+CHR$(0)
8700   END DO
8710 X=FNPLT(DIRTRK,DIRSEC)!POSITION TO BEGINNING OF DIRECTORY
8720 FOR RECORD=1 TO DIRSIZ
8730   R$=FNRLS$(0)
8740   FOR START=1 TO SSIZ STEP 32
8750     IF ASC(SST$(R$,START,1))=229 THEN
8760       IF START+32>SSIZ THEN
8770          R$=SST$(R$,1,START-1)+EXTENT$
8780       ELSE
8790          R$=SST$(R$,1,START-1)+EXTENT$+SST$(R$,START+32)
8800          ENDIF
8810       X=FNRW(R$)
8820       RETURN
8830       ENDIF
8840     NEXT START                           
8850   NEXT RECORD                          
8860 PRINT "NO ROOM IN THE DIRECTORY!  COPY ABORTS!"
8870 FINISHED$="YES"
8880 RETURN
8890 END
