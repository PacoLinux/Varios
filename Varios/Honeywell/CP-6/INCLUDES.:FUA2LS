

 10:19 FEB 12 '98 FUS_DATA_C                               FUS_DATA_C            Page 1
         1  /*M* FUS_DATA_C - EQUs for NFS security database manager */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /* Parse node EQU's */
         9  %EQU UNIXID = 1;
        10  %EQU CP6ID = 2;
        11  %EQU HOSTS = 3;
        12  %EQU NFS = 4;
        13  %EQU JUNK = 5;
        14  %EQU UNIX_OPTS = 6;
        15  %EQU UNX_ID_OPTS = 7;
        16  %EQU UNX_NAME = 8;
        17  %EQU UNX_GID = 9;
        18  %EQU UNX_UID = 10;
        19  %EQU UNX_ID_NUM = 11;
        20  %EQU UNX_ID_WILD = 12;
        21  %EQU CP6_OPTS = 13;
        22  %EQU CP6_ACCT = 14;
        23  %EQU CP6_NAME = 15;
        24  %EQU HOST_OPTS = 16;
        25  %EQU HOST_WILD = 17;
        26  %EQU HOST_ONE = 18;
        27  %EQU HOST_LIST = 19;
        28  %EQU HOST_NAME = 20;
        29  %EQU NFS_OPTS = 30;
        30  %EQU NFS_OPTS_LIST = 31;
        31  %EQU SECCHK = 32;
        32  %EQU FMBLK = 33;
        33  %EQU FMSEC = 34;
        34  %EQU FMREAD = 35;
        35  %EQU TOPLVL = 36;
        36  %EQU MOUNT = 37;
        37  %EQU REJECT = 38;

 10:19 FEB 12 '98 FUS_DATA_C                               FUS_DATA_C            Page 2
        38  %EQU UNX_ID_NEG = 39;
        39  %EQU YES = 1;
        40  %EQU NO = 0;
        41  %EQU TOP_ALL = 0;
        42  %EQU TOP_MAD = 1;
        43  %EQU TOP_PAD = 2;
        44  %EQU TOP_NONE = 3;
        45  %EQU ANY = 99;

 10:19 FEB 12 '98 FUU_EQU_E                                FUU_EQU_E             Page 3
         1  /*M* FUU_EQU_E - equates for displacements into the nfs ds file */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7  /* DRAW with EQU=3,PL6 */
         8
         9  FUU_EQU_E: PROC;
        10  %INCLUDE FU_NFS_M;
        11  %FU$NFSDS( NAME=DS, STCLASS=AUTO, PARY=);
        12
        13
        14
        15   IF
        16   DS.P.SYSID+ DS.MSGCNT+ DS.BYTESIN+ DS.P.MSGCNT+ DS.BYTESOUT+
        17   DS.NFSRQS(0)+ DS.HCNT+ DS.FCNT+ DS.UCNT+ DS.P.FCNT+
        18   DS.CTXLIM+ DS.DCBLIM+ DS.BUFLIM+ DS.OPENLIM+
        19   DS.QREADLIM+ DS.SREADLIM+ DS.TRANSIZE+
        20   DS.P.UCNT+ DS.P.PMMECNT+ DS.P.DISKIOS+ DS.P.STIME+ DS.P.XTIME
        21
        22   = 0 THEN RETURN;
        23
        24
        25  END FUU_EQU_E;

 10:19 FEB 12 '98 FU_NFSSUBS_C                             FU_NFSSUBS_C          Page 4
         1  /*M* FU_NFSSUBS_C    Equates for NFS as defined by Sun          */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /* Program Numbers */
         9  %EQU PROG_PMAP = 100000;
        10  %EQU PROG_NFS = 100003;
        11  %EQU PROG_MOUNT = 100005;
        12
        13  %EQU PROG_SPREAD = 230912; /* Add to program number for 9bit bytes */
        14
        15  /* Port numbers */
        16  %EQU PORT_PMAP = 111;
        17  %EQU PORT_NFS = 2049;
        18
        19  /* Program versions */
        20  %EQU VERS_PMAP = 2;
        21  %EQU VERS_NFS = 2;
        22  %EQU VERS_RPC = 2;
        23  %EQU VERS_MOUNT = 1;
        24
        25  /* Message types */
        26  %EQU TYPE_CALL = 0;
        27  %EQU TYPE_REPLY = 1;
        28
        29  /* Message reply status */
        30  %EQU MSG_ACCEPTED = 0;
        31  %EQU MSG_DENIED = 1;
        32
        33  /* Status to return to the client when a RPC call is accepted */
        34  %EQU SUCCESS = 0;           /* RPC executed successfully */
        35  %EQU PROG_UNAVAIL = 1;      /* Remote hasn't exported program */
        36  %EQU PROG_MISMATCH = 2;     /* Remote can't support version # */
        37  %EQU PROC_UNAVAIL = 3;      /* Program can't support procedure */

 10:19 FEB 12 '98 FU_NFSSUBS_C                             FU_NFSSUBS_C          Page 5
        38  %EQU GARBAGE_ARGS = 4;      /* Procedure can't decode parameters */
        39
        40  /* Reasons why a call was rejected */
        41  %EQU RPC_MISMATCH = 0;      /* RPC Version number != 2 */
        42  %EQU AUTH_ERROR = 1;        /* Remote can't authenticate caller */
        43
        44  /* Reasons why authentication failed */
        45  %EQU AUTH_BADCRED = 1;      /* Bad credentials (seal broken) */
        46  %EQU AUTH_REJECTEDCRED = 2; /* Client must begin new session */
        47  %EQU AUTH_BADVERF = 3;      /* Bad verifier (seal broken) */
        48  %EQU AUTH_REJECTEDVERF = 4; /* Verifier rejected or replayed */
        49  %EQU AUTH_TOOWEAK = 5;      /* Rejected for security reasons */
        50
        51  /* Type of authentication */
        52  %EQU AUTH_NULL = 0;
        53  %EQU AUTH_UNIX = 1;
        54  %EQU AUTH_SHORT = 2;
        55
        56  /* TOPLVL values */
        57  %EQU TOPLVL_ALL = 0;
        58  %EQU TOPLVL_MAD = 1;
        59  %EQU TOPLVL_PAD = 2;
        60  %EQU TOPLVL_NONE = 3;
        61
        62  /* NFS Procedure numbers */
        63  %EQU NFSPROC_NULL = 0; /* Always there */
        64  %EQU NFSPROC_GETATTR = 1; /* fhandle -> attrstat */
        65  %EQU NFSPROC_SETATTR = 2; /* sattrargs -> attrstat */
        66  %EQU NFSPROC_ROOT = 3; /* void -> void (obsolete) */
        67  %EQU NFSPROC_LOOKUP = 4; /* diropargs -> diropres */
        68  %EQU NFSPROC_READLINK = 5; /* fhandle -> readlinkres (unimplementable) */
        69  %EQU NFSPROC_READ = 6; /* readargs -> readres */
        70  %EQU NFSPROC_WRITECACHE = 7; /* void -> void (future use) */
        71  %EQU NFSPROC_WRITE = 8; /* writeargs -> attrstat */
        72  %EQU NFSPROC_CREATE = 9; /* createargs -> diropres */
        73  %EQU NFSPROC_REMOVE = 10; /* diropargs -> stat */
        74  %EQU NFSPROC_RENAME = 11; /* renameargs -> stat */

 10:19 FEB 12 '98 FU_NFSSUBS_C                             FU_NFSSUBS_C          Page 6
        75  %EQU NFSPROC_LINK = 12; /* linkargs -> stat */
        76  %EQU NFSPROC_SYMLINK = 13; /* symlinkargs -> stat */
        77  %EQU NFSPROC_MKDIR = 14; /* createargs -> diropres */
        78  %EQU NFSPROC_RMDIR = 15; /* diropargs -> stat */
        79  %EQU NFSPROC_READDIR = 16; /* readdirargs -> readdirres */
        80  %EQU NFSPROC_STATFS = 17; /* fhandle -> statfsres */
        81
        82  /* NFS Error Codes */
        83  %EQU NFS_OK = 0;
        84  %EQU NFSERR_PERM = 1;
        85  %EQU NFSERR_NOENT = 2;
        86  %EQU NFSERR_IO = 5;
        87  %EQU NFSERR_NXIO = 6;
        88  %EQU NFSERR_ACCES = 13;
        89  %EQU NFSERR_EXIST = 17;
        90  %EQU NFSERR_NODEV = 19;
        91  %EQU NFSERR_NOTDIR = 20;
        92  %EQU NFSERR_ISDIR = 21;
        93  %EQU NFSERR_FBIG = 27;
        94  %EQU NFSERR_NOSPC = 28;
        95  %EQU NFSERR_ROFS = 30;
        96  %EQU NFSERR_NAMETOOLONG = 63;
        97  %EQU NFSERR_NOTEMPTY = 66;
        98  %EQU NFSERR_DQUOT = 69;
        99  %EQU NFSERR_STALE = 70;
       100  %EQU NFSERR_WFLUSH = 99;
       101
       102  /* File types */
       103  %EQU NFNON = 0;             /* Non-file */
       104  %EQU NFREG = 1;             /* Regular file */
       105  %EQU NFDIR = 2;             /* Directory */
       106  %EQU NFBLK = 3;             /* Block - special device */
       107  %EQU NFCHR = 4;             /* Character - special device */
       108  %EQU NFLNK = 5;             /* Symbolic link */
       109
       110  /* Portmapper procedures */
       111  %EQU PMAPPROC_NULL = 0;           /* void null(void) */

 10:19 FEB 12 '98 FU_NFSSUBS_C                             FU_NFSSUBS_C          Page 7
       112  %EQU PMAPPROC_SET = 1;            /* bool set(map) */
       113  %EQU PMAPPROC_UNSET = 2;          /* bool unset(map) */
       114  %EQU PMAPPROC_GETPORT = 3;        /* uint getport(map) */
       115  %EQU PMAPPROC_DUMP = 4;           /* *map dump(void) */
       116  %EQU PMAPPROC_CALLIT = 5;         /* call_result callit(call_args) */
       117
       118  /* Portmapper protocols */
       119  %EQU IPPROTO_TCP = 6;
       120  %EQU IPPROTO_UDP = 17;
       121
       122  /* Mount procedures */
       123  %EQU MOUNTPROC_MNT = 1;           /* fhstatus mount(dirpath) */
       124  %EQU MOUNTPROC_DUMP = 2;          /* mountlist dump(void) */
       125  %EQU MOUNTPROC_UMNT = 3;          /* void unmount(dirpath) */
       126  %EQU MOUNTPROC_UMNTALL = 4;       /* void unmount-all-for-host(void) */
       127  %EQU MOUNTPROC_EXPORT = 5;        /* exportlist export(void) */

 10:19 FEB 12 '98 FU_NFS_M                                 FU_NFS_M              Page 8
         1  /*M* Macros for nfs */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7
         8  /*X* */
         9

 10:19 FEB 12 '98 FU$NFSDS                                 FU_NFS_M              Page 9
        10  /*F* NAME: FU$NFSDS
        11       DESCRIPTION:  This structure describes the global context maintained at
        12       the beginning of the shared data segment used by NFSD and its clones. */
        13
        14  %MACRO FU$NFSDS( NAME=FU$NFSDS, PARY="(0:5)",
        15   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
        16
        17  %LSET LISTDIR='0'B;
        18  %LSET LISTCOM='0'B;
        19  %LSET LISTEXP='1'B;
        20  %LSET LISTSUB='1'B;
        21
        22  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
        23  %IF STR='CON' OR STR='STA' OR STR='EXT';
        24  %LSET INIT=CHARTEXT('INIT');
        25  %LSET ENIT=CHARTEXT(' ');
        26  %ELSE;
        27  %LSET INIT=CHARTEXT('/*');
        28  %LSET ENIT=CHARTEXT('*/');
        29  %ENDIF;
        30
        31  %IF LVL=1;
        32  DCL 1 NAME STCLASS ALGN,
        33  %ELSE;
        34   %(LVL) NAME ALGN,
        35  %ENDIF;
        36
        37        /*K* MOUNTPORT UBIN - port number that mount got. */
        38   %(LVL+1) MOUNTPORT UBIN %INIT(0)%ENIT,
        39
        40        /*K* MSGCNT SBIN - total number of incoming requests. */
        41   %(LVL+1) MSGCNT SBIN %INIT(0)%ENIT,
        42
        43        /*K* BYTESIN UBIN - total number of incoming message bytes. */
        44   %(LVL+1) BYTESIN UBIN %INIT(0)%ENIT,
        45
        46        /*K* BYTESOUT UBIN - total number of outgoing message bytes. */

 10:19 FEB 12 '98 FU$NFSDS                                 FU_NFS_M              Page 10
        47   %(LVL+1) BYTESOUT UBIN %INIT(0)%ENIT,
        48
        49        /*K* FCTX$ PTR - head of the FU$FCTX chain. */
        50   %(LVL+1) FCTX$ PTR %INIT(ADDR(NIL))%ENIT,
        51
        52        /*K* FCNT SBIN - length of the FU$HCTX chain. */
        53   %(LVL+1) FCNT SBIN %INIT(0)%ENIT,
        54
        55        /*K* HCTX$ PTR - head of the FU$HCTX chain. */
        56   %(LVL+1) HCTX$ PTR %INIT(ADDR(NIL))%ENIT,
        57
        58        /*K* HCNT SBIN - length of the FU$HCTX chains. */
        59   %(LVL+1) HCNT SBIN %INIT(0)%ENIT,
        60
        61        /*K* UCNT SBIN - length of all the FU$UCTX chains. */
        62   %(LVL+1) UCNT SBIN %INIT(0)%ENIT,
        63
        64        /*K* MCNT SBIN - length of all the FU$RQSCTX chains. */
        65   %(LVL+1) MCNT SBIN %INIT(0)%ENIT,
        66
        67        /*K* CTXLIM SBIN - config limit of blocks in use (0 to 2048). */
        68   %(LVL+1) CTXLIM SBIN %INIT(1950)%ENIT,
        69
        70        /*K* DCBLIM SBIN - config limit of DCBs per process. */
        71   %(LVL+1) DCBLIM SBIN %INIT(120)%ENIT,  /* The segment holds 135 total        */
        72
        73        /*K* BUFLIM SBIN - config limit of BUFs per process. */
        74   %(LVL+1) BUFLIM SBIN %INIT(255)%ENIT,  /* The segment holds 256 total        */
        75
        76        /*K* OPENLIM SBIN - config limit of idle DCB open time (in UTS units). */
        77   %(LVL+1) OPENLIM SBIN %INIT(30)%ENIT,
        78
        79        /*K* QREADLIM UBIN - config limit for maximum granules to read in order
        80        to determine the length of a file. (for "quick" files). */
        81   %(LVL+1) QREADLIM UBIN %INIT(50)%ENIT,
        82
        83        /*K* SREADLIM UBIN - config limit for maximum granules to read in order

 10:19 FEB 12 '98 FU$NFSDS                                 FU_NFS_M              Page 11
        84        to determine the length of a file. (for "slow" files). */
        85   %(LVL+1) SREADLIM UBIN %INIT(10)%ENIT,
        86
        87        /*K* TRANSIZE UBIN - the optimum transfer size of the server in bytes.
        88        Used mainly by NFS for READ and WRITE requests.  This allows tuning
        89        of NFS depending on the site usage. */
        90   %(LVL+1) TRANSIZE UBIN %INIT(4096)%ENIT,
        91
        92        /*K* NFSRQS SBIN ARRAY - count of NFS requests by procedure number. */
        93   %(LVL+1) NFSRQS(0:17) SBIN %INIT(0*0)%ENIT, /* Make an even 16wds            */
        94
        95        /*K* P ARRAY of STRUCTURES - items kept for each of multiprocceses. */
        96   %(LVL+1) P PARY ALIGNED,
        97
        98        /*K* P.SYSID UBIN(18) - SYSID of the process. */
        99    %(LVL+2) SYSID UBIN(18) UNAL %INIT(0*0)%ENIT,
       100
       101        /*K* P.EVENT UBIN(9) - so the start looks like FPT_RUE.V. */
       102    %(LVL+2) EVENT UBIN(9) UNAL %INIT(23*0)%ENIT,
       103
       104        /*K* P.* UBIN(9) - so the start looks like FPT_RUE.V. */
       105    %(LVL+2) * UBIN(9) UNAL %INIT(0*0)%ENIT,
       106
       107        /*K* P.MSGCNT SBIN - number of incoming requests. */
       108    %(LVL+2) MSGCNT SBIN %INIT(0*0)%ENIT,
       109
       110        /*K* P.BYTESIN UBIN - total of incoming request sizes. */
       111    %(LVL+2) BYTESIN UBIN %INIT(0*0)%ENIT,
       112
       113        /*K* P.BYTESOUT UBIN - total of outgoing response sizes. */
       114    %(LVL+2) BYTESOUT UBIN %INIT(0*0)%ENIT,
       115
       116        /*K* P.UCNT SBIN - number of owned FU$UCTX's (BUF$ not NIL). */
       117    %(LVL+2) UCNT SBIN %INIT(0*0)%ENIT,
       118
       119        /*K* P.FCNT SBIN - number of owned FU$FCTX's (DCB# not 0). */
       120    %(LVL+2) FCNT SBIN %INIT(0*0)%ENIT,

 10:19 FEB 12 '98 FU$NFSDS                                 FU_NFS_M              Page 12
       121
       122        /*K* P.PMMECNT UBIN - number of PMMEs so far. */
       123    %(LVL+2) PMMECNT UBIN %INIT(0*0)%ENIT,
       124
       125        /*K* P.DISKIOS UBIN - number of DISKIOs so far. */
       126    %(LVL+2) DISKIOS UBIN %INIT(0*0)%ENIT,
       127
       128        /*K* P.STIME UBIN - service time (us) so far. */
       129    %(LVL+2) STIME UBIN %INIT(0*0)%ENIT,
       130
       131        /*K* P.XTIME UBIN - execution time (us) so far. */
       132    %(LVL+2) XTIME UBIN %INIT(0*0)%ENIT,
       133        /*K* P.RQS$ PTR - points to chain of FU$RQSCTX's. */
       134    %(LVL+2) RQS$ PTR %INIT(ADDR(NIL)*0)%ENIT,
       135
       136        /*K* P.FPRG$ PTR - points to chain of FU$FCTX's to be freed. */
       137    %(LVL+2) FPRG$ PTR %INIT(ADDR(NIL)*0)%ENIT,
       138
       139        /*K* P.UPRG$ PTR - points to chain of FU$UCTX's to be freed. */
       140    %(LVL+2) UPRG$ PTR %INIT(ADDR(NIL)*0)%ENIT,
       141    %(LVL+2) * CHAR(12) %INIT(' '*0)%ENIT LAST /* Make 16wds to ease indexing   */
       142
       143  %MEND;

 10:19 FEB 12 '98 FU$FHANDLE                               FU_NFS_M              Page 13
       144   /*F* NAME: FU$FHANDLE
       145       DESCRIPTION:  This structure describes the 32-octet file-handle used by
       146       CP-6 to provide access to its file-system entities by unix systems. */
       147
       148  %MACRO FU$FHANDLE(NAME=FU$FHANDLE,
       149   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       150
       151  %LSET LISTDIR='0'B;
       152  %LSET LISTCOM='0'B;
       153  %LSET LISTEXP='1'B;
       154  %LSET LISTSUB='1'B;
       155
       156  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       157  %IF STR='CON' OR STR='STA' OR STR='EXT';
       158  %LSET INIT=CHARTEXT('INIT');
       159  %LSET ENIT=CHARTEXT(' ');
       160  %ELSE;
       161  %LSET INIT=CHARTEXT('/*');
       162  %LSET ENIT=CHARTEXT('*/');
       163  %ENDIF;
       164
       165  %IF LVL=1;
       166  DCL 1 NAME STCLASS ALGN,
       167  %ELSE;
       168   %(LVL) NAME ALGN,
       169  %ENDIF;
       170
       171          /*K* STAMP - UBIN(18).  Bottom 16 bits of fid item's creation UTS.
       172          Note that it needs expansion/compression for 8-to-9 problem, but only
       173          when accessing an item for the first time via fhandle.  It is stored
       174          in FU$FCTX just as it appears in the network.  */
       175   %(LVL+1) STAMP UBIN(18) UNAL %INIT(0)%ENIT,
       176
       177   %(LVL+1) * BIT(1) %INIT('0'B)%ENIT,    /* filler 'cuz unix is 8-bit          */
       178
       179          /*K* HASH - BIT(1).  Indicates that the fid doesn't fit in 33 chars,
       180          and that instead, the high-order bits of TEXT ('80'x/'200'o), when

 10:19 FEB 12 '98 FU$FHANDLE                               FU_NFS_M              Page 14
       181          concatenated together, form a 27-bit hash of the fid characters beyond
       182          the 29th one.  If the fid is between 30 and 33 characters, those high
       183          bits are used to carry the characters beyond 29 directly. */
       184   %(LVL+1) HASH BIT(1) %INIT('0'B)%ENIT,
       185
       186          /*K* PSNLNG - UBIN(3).  Count of fid characters devoted to PSN value. */
       187   %(LVL+1) PSNLNG UBIN(3) UNAL %INIT(0)%ENIT,
       188
       189          /*K* ACCTLNG - UBIN(4).  Count of fid characters used for ACCT value. */
       190   %(LVL+1) ACCTLNG UBIN(4) UNAL %INIT(0)%ENIT,
       191
       192          /*K* TEXT - CHAR(29).  The characters comprising the fid.  Since all
       193          parts are ASCII, only the bottom 7 bits of each byte are actual fid
       194          characters.  If HASH is set, the high bits hash into a table.
       195          Otherwise, if the first high bit is set, the remaining 28 ones form up
       196          to four 7-bit characters to extend the value. */
       197   %(LVL+1) TEXT CHAR(29) %INIT(BINASC(0))%ENIT LAST
       198
       199  %MEND;
       200

 10:19 FEB 12 '98 FU$HCTX                                  FU_NFS_M              Page 15
       201  /*F* NAME: FU$HCTX
       202       DESCRIPTION:  Contains data specific to a particular foreign host, namely
       203       its name and internet address, for verification purposes.
       204       */
       205
       206  %MACRO FU$HCTX(NAME=FU$HCTX,
       207   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       208
       209  %LSET LISTDIR='0'B;
       210  %LSET LISTCOM='0'B;
       211  %LSET LISTEXP='1'B;
       212  %LSET LISTSUB='1'B;
       213
       214  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       215  %IF STR='CON' OR STR='STA' OR STR='EXT';
       216  %LSET INIT=CHARTEXT('INIT');
       217  %LSET ENIT=CHARTEXT(' ');
       218  %ELSE;
       219  %LSET INIT=CHARTEXT('/*');
       220  %LSET ENIT=CHARTEXT('*/');
       221  %ENDIF;
       222
       223  %IF LVL=1;
       224  DCL 1 NAME STCLASS ALGN,
       225  %ELSE;
       226   %(LVL) NAME ALGN,
       227  %ENDIF;
       228
       229        /*K* LNK$ PTR - points to the next in the collection of FU$HCTX's. */
       230   %(LVL+1) LNK$ PTR %INIT(ADDR(NIL))%ENIT,
       231
       232        /*K* UCTX$ PTR - points to head of FU$UCTX chain for this host. */
       233   %(LVL+1) UCTX$ PTR %INIT(ADDR(NIL))%ENIT,
       234
       235        /*K* S_ADDR UBIN - internet address it should be sending messages from. */
       236   %(LVL+1) S_ADDR UBIN %INIT(0)%ENIT,
       237

 10:19 FEB 12 '98 FU$HCTX                                  FU_NFS_M              Page 16
       238        /*K* MSGCNT SBIN - Number of requests received from the host. */
       239   %(LVL+1) MSGCNT SBIN %INIT(0)%ENIT,
       240
       241        /*K* BYTESIN UBIN - Number of bytes received in the requests. */
       242   %(LVL+1) BYTESIN UBIN %INIT(0)%ENIT,
       243
       244        /*K* BYTESOUT UBIN - Number of bytes sent in response to the requests. */
       245   %(LVL+1) BYTESOUT UBIN %INIT(0)%ENIT,
       246
       247        /*K* REXMITS UBIN - Number of requests received with previous XIDs. */
       248   %(LVL+1) REXMITS UBIN %INIT(0)%ENIT,
       249
       250        /*K* XIDX UBIN - Next index into the XIDS list to save a new one. */
       251   %(LVL+1) XIDX UBIN %INIT(0)%ENIT,
       252
       253        /*K* XIDS UBIN ARRAY(0:15) - Saved XIDs for the last 16 requests. */
       254   %(LVL+1) XIDS(0:15) UBIN %INIT(0)%ENIT,
       255
       256        /*K* NAME TEXTW - name it should be using to identify itself. */
       257   %(LVL+1) %CHARTEXT('NAME'),
       258     %(LVL+2) L UBIN %INIT(0)%ENIT,
       259     %(LVL+2) T CHAR(NAME.%CHARTEXT('NAME').L) %INIT(' ')%ENIT LAST
       260
       261  %MEND;
       262

 10:19 FEB 12 '98 FU$UCTX                                  FU_NFS_M              Page 17
       263  /*F* NAME: FU$UCTX
       264       DESCRIPTION:  Contains data specific to a particular host/uid/fhandle
       265       combination.
       266       */
       267
       268  %MACRO FU$UCTX(NAME=FU$UCTX,
       269   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       270
       271  %LSET LISTDIR='0'B;
       272  %LSET LISTCOM='0'B;
       273  %LSET LISTEXP='1'B;
       274  %LSET LISTSUB='1'B;
       275
       276  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       277  %IF STR='CON' OR STR='STA' OR STR='EXT';
       278  %LSET INIT=CHARTEXT('INIT');
       279  %LSET ENIT=CHARTEXT(' ');
       280  /* INCLUDE CP_6_SUBS for FFLG_OWNER# */
       281  %ELSE;
       282  %LSET INIT=CHARTEXT('/*');
       283  %LSET ENIT=CHARTEXT('*/');
       284  %LSET FFLG_OWNER#=CHARTEXT('');
       285  %ENDIF;
       286
       287  %IF LVL=1;
       288  DCL 1 NAME STCLASS ALGN,
       289  %ELSE;
       290   %(LVL) NAME ALGN,
       291  %ENDIF;
       292
       293        /*K* HLNK$ PTR - points to next in chain off FU$HCTX. */
       294   %(LVL+1) HLNK$ PTR %INIT(ADDR(NIL))%ENIT,
       295
       296        /*K* HCTX$ PTR - points to FU$HCTX whose chain it's in. */
       297   %(LVL+1) HCTX$ PTR %INIT(ADDR(NIL))%ENIT,
       298
       299        /*K* FLNK$ PTR - points to next in chain off FU$FCTX. */

 10:19 FEB 12 '98 FU$UCTX                                  FU_NFS_M              Page 18
       300   %(LVL+1) FLNK$ PTR %INIT(ADDR(NIL))%ENIT,
       301
       302        /*K* FCTX$ PTR - points to FU$FCTX whose chain it's in. */
       303   %(LVL+1) FCTX$ PTR %INIT(ADDR(NIL))%ENIT,
       304
       305        /*K* USER FU$SECREC - contains items that get copied when making a
       306        new FU$UCTX from an existing one, e.g., to access a new file.  The
       307        call to the security check routine is thereby eliminated. */
       308   %LSET L1 = LVL+1;
       309   %FU$SECREC( NAME=USER, LVL=%L1, STCLASS=STCLASS, LAST=NO);
       310
       311        /*K* AGE UBIN - message counter when last accessed (for purging). */
       312   %(LVL+1) AGE UBIN %INIT(0)%ENIT,
       313
       314        /*K* FFLG FFLG structure - FFLG value for access to FU$FCTX'S dcb. */
       315   %(LVL+1) FFLG# BIT(18) %INIT(%FFLG_OWNER#)%ENIT,
       316   %(LVL+1) FFLG REDEF FFLG#,
       317    %(LVL+2) READ BIT(1),
       318    %(LVL+2) DELR BIT(1),
       319    %(LVL+2) WNEW BIT(1),
       320    %(LVL+2) UPD BIT(1),
       321    %(LVL+2) DELF BIT(1),
       322    %(LVL+2) NOLIST BIT(1),
       323    %(LVL+2) REATTR BIT(1),
       324    %(LVL+2) EXEC BIT(1),
       325    %(LVL+2) CREATE BIT(1),
       326    %(LVL+2) CGFLGS BIT(3),
       327    %(LVL+2) MOUNT BIT(1),
       328    %(LVL+2) * BIT(5),
       329
       330       /*K* CONTREAD BIT(1) - designates that next read to this uid's
       331                 buffer is supposed to be a continued read */
       332
       333   %(LVL+1) CONTREAD BIT(1) UNAL %INIT('0'B)%ENIT,
       334
       335   %(LVL+1) * BIT(11) UNAL %INIT('0'B)%ENIT,
       336

 10:19 FEB 12 '98 FU$UCTX                                  FU_NFS_M              Page 19
       337        /*K* LFCNT UBIN(6) - number of LFs to insert after record (text mode). */
       338   %(LVL+1) LFCNT UBIN(6) UNAL %INIT(0)%ENIT,
       339
       340        /*K* ARS# UBIN - actual record size (from DCB) of the data in
       341                           this FU$UCTX's buffer (may include inserted LFs) */
       342   %(LVL+1) ARS#    UBIN %INIT(0)%ENIT,
       343
       344
       345        /*K* BUF$ PTR - pointer to base of this uid's file I/O buffer */
       346   %(LVL+1) BUF$  PTR  %INIT(ADDR(NIL))%ENIT,
       347
       348       /*K* FILEPOS STRUCTURE - an array of items needed for quick
       349            repositioning in the file should the client timeout and
       350            re-request a fileblock */
       351   %(LVL+1) FILEPOS (0:9),
       352
       353        /*K* FILEPOS.CRECNO UBIN - CP-6 file record number of the record
       354                           matching the corresponding FOFFSET */
       355    %(LVL+2) CRECNO UBIN %INIT(0*0)%ENIT,
       356
       357        /*K* FILEPOS.FOFFSET - the offset (in bytes) from the beginning of
       358                        the file which corresponds with CRECNO */
       359    %(LVL+2) FOFFSET UBIN %INIT(0*0)%ENIT,
       360    %(LVL+2) FOFFSET_ REDEF FOFFSET,
       361     %(LVL+3) GRAN UBIN(24) UNAL,
       362     %(LVL+3) * BIT(12) UNAL,
       363
       364        /*K* COOKIE STRUCTURE - redef of FILEPOS when dealing with directories.
       365             Maintains a one-level cache of cookie vs name information. */
       366   %(LVL+1) COOKIE(0:1) REDEF FILEPOS,
       367
       368        /*K* COOKIE.ID UBIN - cookie value last handed out for a READDIR op. */
       369    %(LVL+2) ID UBIN,
       370
       371        /*K* NAME TEXTC(31) - name that corresponds (with L and T subitems). */
       372    %(LVL+2) %CHARTEXT('NAME'),
       373     %(LVL+3) L UBIN(9) UNAL,

 10:19 FEB 12 '98 FU$UCTX                                  FU_NFS_M              Page 20
       374     %(LVL+3) T CHAR(31) CALIGNED,
       375    %(LVL+2) * UBIN LAST             /* To fill it out to 10 words per entry    */
       376
       377  %MEND;
       378

 10:19 FEB 12 '98 FU$SECREC                                FU_NFS_M              Page 21
       379  /*F* NAME: FU$SECREC
       380       DESCRIPTION: Base recond in :nfssec - contains items that get copied when
       381        making a new FU$UCTX from an existing one, e.g., to access a new file.
       382        The call to the security check routine is thereby eliminated.
       383  */
       384
       385  %MACRO FU$SECREC( NAME=FU$SECREC,
       386   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       387
       388  %LSET LISTDIR='0'B;
       389  %LSET LISTCOM='0'B;
       390  %LSET LISTEXP='1'B;
       391  %LSET LISTSUB='1'B;
       392
       393  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       394  %IF STR='CON' OR STR='STA' OR STR='EXT';
       395  %LSET INIT=CHARTEXT('INIT');
       396  %LSET ENIT=CHARTEXT(' ');
       397  %ELSE;
       398  %LSET INIT=CHARTEXT('/*');
       399  %LSET ENIT=CHARTEXT('*/');
       400  %ENDIF;
       401
       402  %IF LVL=1;
       403  DCL 1 NAME STCLASS ALGN,
       404  %ELSE;
       405   %(LVL) NAME ALGN,
       406  %ENDIF;
       407
       408        /*K* UID UBIN - unix (expanded) uid for this user. */
       409    %(LVL+1) UID UBIN %INIT(0)%ENIT,
       410
       411        /*K* GID UBIN - unix (expanded) gid for this user. */
       412    %(LVL+1) GID UBIN %INIT(0)%ENIT,
       413
       414        /*K* ACCN CHAR(8) - CP-6 user account he appears to be. */
       415    %(LVL+1) ACCN CHAR(8) %INIT(' ')%ENIT,

 10:19 FEB 12 '98 FU$SECREC                                FU_NFS_M              Page 22
       416
       417        /*K* UNAME CHAR(12) - CP-6 user name he appears to be. */
       418    %(LVL+1) UNAME CHAR(12) %INIT(' ')%ENIT,
       419
       420        /*K* SECCHK BIT(1) - recheck security for new FCTX association. */
       421    %(LVL+1) SECCHK BIT(1) %INIT('0'B)%ENIT,
       422
       423        /*K* FMBLK BIT(1) - run with FMBLK (NXTA) privilege on. */
       424    %(LVL+1) FMBLK BIT(1) %INIT('0'B)%ENIT,
       425
       426        /*K* FMSEC BIT(1) - run with FMSEC privilege on. */
       427    %(LVL+1) FMSEC BIT(1) %INIT('0'B)%ENIT,
       428
       429        /*K* MOUNT BIT(1) - something is mountable. */
       430    %(LVL+1) MOUNT BIT(1) %INIT('0'B)%ENIT,
       431
       432        /*K* FMREAD BIT(1) - run with FMREAD privilege on. */
       433    %(LVL+1) FMREAD BIT(1) %INIT('0'B)%ENIT,
       434
       435        /*K* TOPLVL UBIN(2) - limit for "parent" access.
       436        0=ALL, 1=MAD, 2=PAD, 3=NONE */
       437    %(LVL+1) TOPLVL UBIN(2) UNAL %INIT(1)%ENIT,
       438
       439        /*K* REJECT BIT(1) - access to anything is to be refused. */
       440    %(LVL+1) REJECT BIT(1) %INIT('0'B)%ENIT,
       441
       442    %(LVL+1) * BIT(10) %INIT('0'B)%ENIT,
       443
       444        /*K* SMKEY UBIN(18) - if SECCHK or MOUNT is set, points to a FU$SMREC in
       445        ;nfssec that contains details. */
       446    %(LVL+1) SMKEY UBIN(18) UNAL %INIT(0)%ENIT LAST
       447
       448  %MEND;
       449

 10:19 FEB 12 '98 FU$FCTX                                  FU_NFS_M              Page 23
       450  /*F* NAME: FU$FCTX
       451       DESCRIPTION:  Contains data specific to a particular fhandle, while it has
       452       a DCB open or requests outstanding on any master or slave instance of nfsd.
       453       */
       454
       455  %MACRO FU$FCTX(NAME=FU$FCTX,
       456   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       457
       458  %LSET LISTDIR='0'B;
       459  %LSET LISTCOM='0'B;
       460  %LSET LISTEXP='1'B;
       461  %LSET LISTSUB='1'B;
       462
       463  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       464  %IF STR='CON' OR STR='STA' OR STR='EXT';
       465  %LSET INIT=CHARTEXT('INIT');
       466  %LSET ENIT=CHARTEXT(' ');
       467  %ELSE;
       468  %LSET INIT=CHARTEXT('/*');
       469  %LSET ENIT=CHARTEXT('*/');
       470  %ENDIF;
       471
       472  %IF LVL=1;
       473  DCL 1 NAME STCLASS ALGN,
       474  %ELSE;
       475   %(LVL) NAME ALGN,
       476  %ENDIF;
       477
       478        /*K* LNK$ PTR - points to the next in the chain of FU$FCTX's. */
       479   %(LVL+1) LNK$ PTR %INIT(ADDR(NIL))%ENIT,
       480
       481        /*K* UCTX$ PTR - points to the head of a chain of FU$UCTX's. */
       482   %(LVL+1) UCTX$ PTR %INIT(ADDR(NIL))%ENIT,
       483
       484        /*K* FHANDLE STRUCTURE - the fhandle corresponding to the DCB. */
       485   %LSET L1 = LVL+1;
       486   %FU$FHANDLE( NAME=FHANDLE, LVL=%L1, STCLASS=STCLASS, LAST=NO);

 10:19 FEB 12 '98 FU$FCTX                                  FU_NFS_M              Page 24
       487
       488        /*K* DCB#  UBIN(18) - DCB number. */
       489   %(LVL+1) DCB#  UBIN(18) UNAL %INIT(0)%ENIT,
       490
       491        /*K* PROC# UBIN(18) - Index into FU$NFSDS.P of server owning the DCB. */
       492   %(LVL+1) PROC# UBIN(18) UNAL %INIT(0)%ENIT,
       493
       494        /*K* AGE UBIN - message counter when last accessed (for purging). */
       495   %(LVL+1) AGE UBIN %INIT(0)%ENIT,
       496
       497        /*K* CRECNO UBIN - current record number of the file's position.
       498                      Necessary to keep multiple users of the same file
       499                      from tromping on each other. */
       500   %(LVL+1) CRECNO UBIN %INIT(0)%ENIT,
       501
       502       /*K* FITMOD BIT(1) - the uFIT has been updated - please write it. */
       503   %(LVL+1) FITMOD BIT(1) UNAL %INIT('0'B)%ENIT,
       504
       505       /*K* RENAMED BIT(1) - the file has been renamed - when the DCB is closed,
       506            the FHANDLE will be stale, so the FTX might as well go then, too. */
       507   %(LVL+1) RENAMED BIT(1) UNAL %INIT('0'B)%ENIT,
       508
       509   %(LVL+1) * BIT(16) UNAL %INIT('0'B)%ENIT,
       510
       511       /*K* CHUNK  UBIN HALF - current chunk number of current record
       512                 kept track of in order to make sure we're synchronized
       513                 between possible multiple users of the file */
       514   %(LVL+1) CHUNK UBIN HALF HALIGNED %INIT(0)%ENIT,
       515
       516        /*K* FATTR STRUCTURE - the current FU$FATTR values for the item.
       517        Maintained in network form - no high bits on */
       518   %FU$FATTR( NAME=FATTR, LVL=%L1, STCLASS=STCLASS, LAST=NO);
       519
       520        /*K* FID STRUCTURE - CP-6 style rendition of FHANDLE, suitable for moving
       521        in bulk to STATIC to eliminate a lot of VECTOR(based) code.   Subitems,
       522        self_explanatory I hope, are PSN.N, PSN.SN, ACCT, NAME.L, and NAME.T. */
       523   %FU$FIDPARTS( NAME=FID, LVL=%L1, STCLASS=STCLASS, LAST=NO);

 10:19 FEB 12 '98 FU$FCTX                                  FU_NFS_M              Page 25
       524
       525        /*K* FOFFSET - the offset (in bytes) from the beginning of the file
       526                         where the file is currently positioned.  This is
       527                         also a function of CHUNK and CRECNO. */
       528    %(LVL+1) FOFFSET UBIN %INIT(0)%ENIT,
       529    %(LVL+1) FOFFSET_ REDEF FOFFSET,
       530     %(LVL+2) GRAN UBIN(24) UNAL,
       531     %(LVL+2) * BIT(12) UNAL;
       532
       533  %MEND;
       534

 10:19 FEB 12 '98 FU$FIDPARTS                              FU_NFS_M              Page 26
       535        /*F* NAME: FU$FIDPARTS.
       536        descriptioni:  CP-6 style rendition of FHANDLE, suitable for moving
       537        in bulk to STATIC to eliminate a lot of VECTOR(based) code.   Subitems,
       538        self_explanatory I hope, are PSN.N, PSN.SN, ACCT, NAME.L, and NAME.T.
       539        Also, RES and ASN, of which is no clear use yet, but just in case. */
       540
       541  %MACRO FU$FIDPARTS( NAME=FU$FIDPARTS, SMREC=0,
       542   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       543
       544  %LSET LISTDIR='0'B;
       545  %LSET LISTCOM='0'B;
       546  %LSET LISTEXP='1'B;
       547  %LSET LISTSUB='1'B;
       548
       549  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       550  %IF STR='CON' OR STR='STA' OR STR='EXT';
       551  %LSET INIT=CHARTEXT('INIT');
       552  %LSET ENIT=CHARTEXT(' ');
       553  %ELSE;
       554  %LSET INIT=CHARTEXT('/*');
       555  %LSET ENIT=CHARTEXT('*/');
       556  %ENDIF;
       557
       558  %IF LVL=1;
       559  DCL 1 NAME STCLASS ALGN,
       560  %ELSE;
       561   %(LVL) NAME ALGN,
       562  %ENDIF;
       563   %(LVL+1) PSN CALIGNED,
       564    %(LVL+2) N UBIN UNAL %INIT(1)%ENIT,
       565    %(LVL+2) SN CHAR(6) %INIT(' ')%ENIT,
       566   %(LVL+1) ASN UBIN(18) UNAL %INIT(1)%ENIT,
       567   %(LVL+1) FFLG REDEF ASN,
       568    %(LVL+2) READ BIT(1),
       569    %(LVL+2) DELR BIT(1),
       570    %(LVL+2) WNEW BIT(1),
       571    %(LVL+2) UPD BIT(1),

 10:19 FEB 12 '98 FU$FIDPARTS                              FU_NFS_M              Page 27
       572    %(LVL+2) DELF BIT(1),
       573    %(LVL+2) NOLIST BIT(1),
       574    %(LVL+2) REATTR BIT(1),
       575    %(LVL+2) EXEC BIT(1),
       576    %(LVL+2) CREATE BIT(1),
       577    %(LVL+2) CGFLGS BIT(3),
       578    %(LVL+2) MOUNT BIT(1),
       579    %(LVL+2) * BIT(5),
       580   %(LVL+1) RES CHAR(4) %INIT('DP')%ENIT,
       581   %(LVL+1) ACCT CHAR(8) %INIT(' ')%ENIT,
       582   %(LVL+1) %CHARTEXT('NAME'),
       583    %(LVL+2) L UBIN(9) UNAL %INIT(0)%ENIT,
       584  %LSET NL=CONCAT('31',TEXTCHAR(NAME),'.NAME.L');
       585  %LSET NL=CHARTEXT(SUBSTR(NL,2*SMREC,2+SMREC*(LENGTH(TEXTCHAR(NAME))+5)));
       586    %(LVL+2) T CHAR(%NL) %INIT(' ')%ENIT LAST
       587  %MEND;
       588

 10:19 FEB 12 '98 FU$RQSCTX                                FU_NFS_M              Page 28
       589  /*F* NAME: FU$RQSCTX
       590       DESCRIPTION:  Contains data specific to a particular RPC request, including
       591       the request itself, and the address from whence it came.
       592       */
       593
       594  %MACRO FU$RQSCTX(NAME=FU$RQSCTX, BODYLEN=8192,
       595   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       596
       597  %LSET LISTDIR='0'B;
       598  %LSET LISTCOM='0'B;
       599  %LSET LISTEXP='1'B;
       600  %LSET LISTSUB='1'B;
       601
       602  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       603  %IF STR='CON' OR STR='STA' OR STR='EXT';
       604  %LSET INIT=CHARTEXT('INIT');
       605  %LSET ENIT=CHARTEXT(' ');
       606  %ELSE;
       607  %LSET INIT=CHARTEXT('/*');
       608  %LSET ENIT=CHARTEXT('*/');
       609  %ENDIF;
       610
       611  %IF LVL=1;
       612  DCL 1 NAME STCLASS ALGN,
       613  %ELSE;
       614   %(LVL) NAME ALGN,
       615  %ENDIF;
       616
       617           /*K* LNK$ PTR - points to another request for the same slave.
       618           See also LEN.
       619           */
       620   %(LVL+1) LNK$ PTR %INIT(ADDR(NIL))%ENIT,
       621
       622           /*K* DATLNK$ PTR - points to another FU$RQSCTX if the message doesn't
       623           fit in one chunk.  Only used for messages passed to slaves, so that
       624           fixed-size memory management can be used in the shared DS.
       625           */

 10:19 FEB 12 '98 FU$RQSCTX                                FU_NFS_M              Page 29
       626   %(LVL+1) DATLNK$ PTR %INIT(ADDR(NIL))%ENIT,
       627
       628           /*K* LEN UBIN - Number of bytes in the message chunk.  Set by FUA$MAIN
       629           from the incoming message length.  Reduced by the RPC parser after
       630           setting BODY$ and converting any AUTH_UNIX to AUTH_SHORT form, to
       631           include only what remains in BODY.
       632           */
       633   %(LVL+1) LEN UBIN %INIT(0)%ENIT,
       634
       635           /*K* BODY$ PTR - Points to the application-specific portion of the rqs.
       636           BODY$ is set by the RPC parser when it has found the end of the RPC
       637           header info.  When a slave has finished processing a message, it needs
       638           to set BODY$ to ADDR(NIL) so that the master can reuse the buffer
       639           space.  Only the master can use the space-management routines.
       640           */
       641   %(LVL+1) BODY$ PTR %INIT(ADDR(NIL))%ENIT,
       642
       643           /*K* UCTX$ PTR - Points to FU$UCTX after the RPC parser has determined
       644           who it is.  Possibly changed later to point to a more accurate one by
       645           the NFS request parser.
       646           */
       647   %(LVL+1) UCTX$ PTR %INIT(ADDR(NIL))%ENIT,
       648
       649           /*K* PROC# UBIN - the procedure number, copied from the incoming
       650           request by the RPC parser, so that the parser can also set up the
       651           reply header.  The request handler need only fill in its own protocol
       652           items, starting at REPLYHDR.RESULTS (or NA_RESULTS for PMAP), to build
       653           the response message in place.
       654           */
       655   %(LVL+1) PROC# UBIN %INIT(0)%ENIT,
       656
       657           /*K* FROMADDR SOCKADDR_IN - what got returned by XSL$RECVFROM, to be
       658           used in the call to XSL$SENDTO when a response to the request is made.
       659           */
       660   %LSET L1 = LVL+1;
       661   %XSL$SOCKADDR_IN(FPTN=FROMADDR, LVL=%L1, STCLASS=STCLASS, LAST=",");
       662

 10:19 FEB 12 '98 FU$RQSCTX                                FU_NFS_M              Page 30
       663           /*K* CALLHDR - describes a fixed-length RPC header for a call-type message.
       664           It's fixed length because AUTH_CRED is AUTH_SHORT flavored.  An incoming
       665           request with AUTH_UNIX flavored AUTH_CRED is converted to this form by
       666           the RPC parser.  REXMIT.F (a REDEF or the top bit in XID) is set if a
       667           retransmission has been detected for this message.
       668           */
       669   %(LVL+1) CALLHDR,
       670     %(LVL+2) XID UBIN %INIT(0)%ENIT,
       671     %(LVL+2) REXMIT REDEF XID,
       672      %(LVL+3) F BIT(1),
       673      %(LVL+3) * BIT(35),
       674     %(LVL+2) TYPE UBIN %INIT(0)%ENIT,    /* =0 for a call                      */
       675     %(LVL+2) RPCVERS UBIN %INIT(2)%ENIT, /* =2 to avoid an error response      */
       676     %(LVL+2) PROG# UBIN %INIT(0)%ENIT,   /* 100000 or so                       */
       677     %(LVL+2) VERS# UBIN %INIT(0)%ENIT,   /* depends on the program             */
       678     %(LVL+2) PROC# UBIN %INIT(0)%ENIT,   /* depends on the program             */
       679     %(LVL+2) AUTH_CRED,
       680       %(LVL+3) FLAVOR UBIN %INIT(2)%ENIT, /* =2 (SHORT) if structure is right  */
       681       %(LVL+3) LEN UBIN %INIT(8)%ENIT,   /* =8 (two words)                     */
       682       %(LVL+3) U,                        /* UID and GID                        */
       683         %(LVL+4) UID UBIN(18) UNAL %INIT(0)%ENIT, /* unix uid                  */
       684         %(LVL+4) GID UBIN(18) UNAL %INIT(0)%ENIT, /* unix gid                  */
       685       %(LVL+3) HID,       /* offset of HCTX ptr, combined with master's sysid  */
       686         %(LVL+4) HCTX UBIN(18) UNAL %INIT(0)%ENIT, /* top 16 bits, spread      */
       687         %(LVL+4) SYSID UBIN(18) UNAL %INIT(0)%ENIT, /* anded with .377377      */
       688     %(LVL+2) AUTH_UNIX REDEF AUTH_CRED,
       689       %(LVL+3) FLAVOR UBIN,              /* =1 (UNIX) if structure is right    */
       690       %(LVL+3) LEN UBIN,                 /* varies                             */
       691       %(LVL+3) STAMP UBIN,               /* varies                             */
       692       %(LVL+3) %CHARTEXT('NAME') BIT(36), /* actually the length, text follows */
       693
       694     %(LVL+2) AUTH_VERF,
       695       %(LVL+3) FLAVOR UBIN %INIT(0)%ENIT, /* =0 (NULL) if structure is right   */
       696       %(LVL+3) LEN UBIN %INIT(0)%ENIT,   /* =0 (empty)                         */
       697   %(LVL+1) REPLYHDR REDEF CALLHDR,       /* to make replies easier             */
       698     %(LVL+2) XID UBIN,
       699     %(LVL+2) TYPE UBIN,                  /* =1 for a reply                     */

 10:19 FEB 12 '98 FU$RQSCTX                                FU_NFS_M              Page 31
       700     %(LVL+2) REPLY_STAT UBIN,            /* MSG_ACCEPTED or MSG_DENIED         */
       701     %(LVL+2) REJECT_STAT UBIN, /* RPC_MISMATCH or AUTH_ERROR if MSG_DENIED     */
       702     %(LVL+2) AUTH_VERF REDEF REJECT_STAT BIT(36), /* if MSG_ACCEPTED           */
       703     %(LVL+2) AUTH_VERF_FLAVOR REDEF REJECT_STAT UBIN, /* if MSG_ACCEPTED       */
       704     %(LVL+2) VERS_LOW UBIN,              /* if RPC_MISMATCH, = 2               */
       705     %(LVL+2) AUTH_STAT REDEF VERS_LOW UBIN, /* if AUTH_ERROR = AUTH?           */
       706     %(LVL+2) AUTH_VERF_LEN REDEF VERS_LOW UBIN, /* if MSG_ACCEPTED             */
       707     %(LVL+2) VERS_HIGH UBIN,             /* if RPC_MISMATCH, = 2               */
       708     %(LVL+2) AUTH_VERF_U REDEF VERS_HIGH BIT(36), /* if MSG_ACCEPTED           */
       709     %(LVL+2) NA_ACCEPT_STAT REDEF VERS_HIGH UBIN, /* if MSG_ACCEPTED,NULL_AUTH */
       710     %(LVL+2) AUTH_VERF_HID BIT(36),      /* if MSG_ACCEPTED                    */
       711     %(LVL+2) NA_RESULTS(0:0) REDEF AUTH_VERF_HID UBIN, /* if SUCCESS,NULLAUTH  */
       712     %(LVL+2) NA_RESULT0 REDEF AUTH_VERF_HID UBIN, /* if SUCCESS,NULLAUTH       */
       713     %(LVL+2) ACCEPT_STAT UBIN, /* SUCCESS,PROG/C_UNAVAIL/MISMATCH,GARBAGE_ARGS */
       714     %(LVL+2) PVERS_LOW UBIN,             /* if PROG_MISMATCH                   */
       715     %(LVL+2) RESULTS(0:0) REDEF PVERS_LOW UBIN, /* if SUCCESS                  */
       716     %(LVL+2) RESULT0 REDEF PVERS_LOW UBIN, /* if SUCCESS                       */
       717     %(LVL+2) PVERS_HIGH UBIN,            /* if PROG_MISMATCH                   */
       718     %(LVL+2) RESULT1 REDEF PVERS_HIGH UBIN, /* if SUCCESS                      */
       719     %(LVL+2) RESULT2 UBIN,          /* filler to make redef of CALLHDR work    */
       720     %(LVL+2) RESULT3 UBIN,          /* filler to make redef of CALLHDR work    */
       721   %(LVL+1) BODY CHAR(BODYLEN) LAST
       722
       723  %MEND;
       724

 10:19 FEB 12 '98 FU$FATTR                                 FU_NFS_M              Page 32
       725  /*F* NAME: FU$FATTR
       726       DESCRIPTION:  This structure describes the nfs FIT structure.
       727       Use SETONLY=YES to generate the settable ones only. */
       728
       729  %MACRO FU$FATTR(NAME=FU$FATTR,
       730   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       731
       732  %LSET LISTDIR='0'B;
       733  %LSET LISTCOM='0'B;
       734  %LSET LISTEXP='1'B;
       735  %LSET LISTSUB='1'B;
       736
       737  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       738  %IF STR='CON' OR STR='STA' OR STR='EXT';
       739  %LSET INIT=CHARTEXT('INIT');
       740  %LSET ENIT=CHARTEXT(' ');
       741  %ELSE;
       742  %LSET INIT=CHARTEXT('/*');
       743  %LSET ENIT=CHARTEXT('*/');
       744  %ENDIF;
       745
       746  %IF LVL=1;
       747  DCL 1 NAME STCLASS ALGN,
       748  %ELSE;
       749   %(LVL) NAME ALGN,
       750  %ENDIF;
       751
       752        /*K* TYPE UBIN - file type.  One of the NFxxx values from NFSSUBS_C. */
       753     %(LVL+1) TYPE UBIN %INIT(0)%ENIT,
       754
       755       /*K* XATTR STRUCTURE - contains items in the uFIT, but not in FATTR. */
       756     %(LVL+1) XATTR,
       757
       758       /*K* XATTR.TEXTMODE BIT(1) - designates if UNIX-style record separation
       759            is supposed to be simulated for this file */
       760
       761       %(LVL+2) TEXTMODE BIT(1) UNAL %INIT('1'B)%ENIT,

 10:19 FEB 12 '98 FU$FATTR                                 FU_NFS_M              Page 33
       762
       763       /*K* XATTR.UFIT BIT(1) - a real uFIT exists - updating it is possible. */
       764       %(LVL+2) UFIT BIT(1) UNAL %INIT('1'B)%ENIT,
       765
       766       %(LVL+2) * BIT(16) UNAL %INIT('0'B)%ENIT,
       767
       768        /*K* MODE BITS - file access mode bits.  unix style. */
       769     %(LVL+1) MODE,
       770       %(LVL+2) * BIT(1) %INIT('0'B)%ENIT,
       771
       772        /*K* MODE.TYPE BIT(3) - another rendition of TYPE, but with different
       773        values.  2,3, and 5 are the same, but 1 and 4 are switched, as are
       774        0 and 6. */
       775       %(LVL+2) TYPE BIT(3) %INIT('0'B)%ENIT,
       776       %(LVL+2) * BIT(1) %INIT('0'B)%ENIT,
       777
       778        /*K* MODE.SUID BIT(1) - set user id on execution. */
       779       %(LVL+2) SUID BIT(1) %INIT('0'B)%ENIT,
       780
       781        /*K* MODE.SGID BIT(1) - set group id on execution. */
       782       %(LVL+2) SGID BIT(1) %INIT('0'B)%ENIT,
       783
       784        /*K* MODE.SST BIT(1) - save swapped text. */
       785       %(LVL+2) SST BIT(1) %INIT('0'B)%ENIT,
       786
       787        /*K* MODE.OREAD BIT(1) - read by owner. */
       788       %(LVL+2) OREAD BIT(1) %INIT('0'B)%ENIT,
       789       %(LVL+2) * BIT(1) %INIT('0'B)%ENIT,
       790
       791        /*K* MODE.OWRITE BIT(1) - write by owner. */
       792       %(LVL+2) OWRITE BIT(1) %INIT('0'B)%ENIT,
       793
       794        /*K* MODE.OEXEC BIT(1) - execute/search by owner. */
       795       %(LVL+2) OEXEC BIT(1) %INIT('0'B)%ENIT,
       796
       797        /*K* MODE.GREAD BIT(1) - read by group. */
       798       %(LVL+2) GREAD BIT(1) %INIT('0'B)%ENIT,

 10:19 FEB 12 '98 FU$FATTR                                 FU_NFS_M              Page 34
       799
       800        /*K* MODE.GWRITE BIT(1) - write by group. */
       801       %(LVL+2) GWRITE BIT(1) %INIT('0'B)%ENIT,
       802
       803        /*K* MODE.GEXEC BIT(1) - execute/search by group. */
       804       %(LVL+2) GEXEC BIT(1) %INIT('0'B)%ENIT,
       805
       806        /*K* MODE.EREAD BIT(1) - read by other. */
       807       %(LVL+2) EREAD BIT(1) %INIT('0'B)%ENIT,
       808
       809        /*K* MODE.EWRITE BIT(1) - write by other. */
       810       %(LVL+2) EWRITE BIT(1) %INIT('0'B)%ENIT,
       811
       812        /*K* MODE.EEXEC BIT(1) - execute/search by other. */
       813       %(LVL+2) EEXEC BIT(1) %INIT('0'B)%ENIT,
       814
       815        /*K* NLINK UBIN - number of hard links.  Always zero. */
       816     %(LVL+1) NLINK UBIN %INIT(0)%ENIT,
       817
       818        /*K* UID UBIN - userid of the file owner. */
       819     %(LVL+1) UID UBIN %INIT(0)%ENIT,
       820
       821        /*K* GID UBIN - groupid of the file group. */
       822     %(LVL+1) GID UBIN %INIT(0)%ENIT,
       823
       824        /*K* SIZE UBIN - size in bytes of the file. */
       825     %(LVL+1) SIZE UBIN %INIT(0)%ENIT,
       826
       827        /*K* BLOCKSIZE UBIN - size in bytes of a block of the file. */
       828     %(LVL+1) BLOCKSIZE UBIN %INIT(0)%ENIT,
       829
       830        /*K* RDEV UBIN - device number for "special" files. */
       831     %(LVL+1) RDEV UBIN %INIT(0)%ENIT,
       832
       833        /*K* BLOCKS UBIN - number of blocks the file uses. */
       834     %(LVL+1) BLOCKS UBIN %INIT(0)%ENIT,
       835

 10:19 FEB 12 '98 FU$FATTR                                 FU_NFS_M              Page 35
       836        /*K* FSID UBIN - file system uniqueifier. */
       837     %(LVL+1) FSID UBIN %INIT(0)%ENIT,
       838
       839        /*K* FILEID UBIN - file uniqueifier within its file system. */
       840     %(LVL+1) FILEID UBIN %INIT(0)%ENIT,
       841
       842        /*K* ATIME timeval - file access time, in seconds (.SECONDS) and
       843        microseconds (.USECONDS) since 1/1/70 GMT */
       844     %(LVL+1) ATIME,
       845       %(LVL+2) SECONDS UBIN %INIT(0)%ENIT,
       846       %(LVL+2) USECONDS UBIN %INIT(0)%ENIT,
       847
       848        /*K* MTIME timeval - file write time, in seconds (.SECONDS) and
       849        microseconds (.USECONDS) since 1/1/70 GMT */
       850     %(LVL+1) MTIME,
       851       %(LVL+2) SECONDS UBIN %INIT(0)%ENIT,
       852       %(LVL+2) USECONDS UBIN %INIT(0)%ENIT,
       853
       854        /*K* CTIME timeval - file status change time, in seconds (.SECONDS) and
       855        microseconds (.USECONDS) since 1/1/70 GMT */
       856     %(LVL+1) CTIME,
       857       %(LVL+2) SECONDS UBIN %INIT(0)%ENIT,
       858       %(LVL+2) USECONDS UBIN %INIT(0)%ENIT LAST
       859
       860  %MEND;
       861

 10:19 FEB 12 '98 FU$SATTR                                 FU_NFS_M              Page 36
       862  /*F* NAME: FU$SATTR
       863       DESCRIPTION:  This structure describes the setattr request items.
       864       It's a subset of the items in FU$FATTR. */
       865
       866  %MACRO FU$SATTR(NAME=FU$SATTR,
       867   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       868
       869  %LSET LISTDIR='0'B;
       870  %LSET LISTCOM='0'B;
       871  %LSET LISTEXP='1'B;
       872  %LSET LISTSUB='1'B;
       873
       874  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       875  %IF STR='CON' OR STR='STA' OR STR='EXT';
       876  %LSET INIT=CHARTEXT('INIT');
       877  %LSET ENIT=CHARTEXT(' ');
       878  %ELSE;
       879  %LSET INIT=CHARTEXT('/*');
       880  %LSET ENIT=CHARTEXT('*/');
       881  %ENDIF;
       882
       883  %IF LVL=1;
       884  DCL 1 NAME STCLASS ALGN,
       885  %ELSE;
       886   %(LVL) NAME ALGN,
       887  %ENDIF;
       888
       889       /*K* MODE UBIN - the new mode of the file if not -1. */
       890     %(LVL+1) MODE UBIN %INIT(0)%ENIT,
       891
       892        /*K* UID UBIN - new userid of the file owner if not -1. */
       893     %(LVL+1) UID UBIN %INIT(0)%ENIT,
       894
       895        /*K* GID UBIN - new groupid of the file group if not -1. */
       896     %(LVL+1) GID UBIN %INIT(0)%ENIT,
       897
       898        /*K* SIZE UBIN - size in bytes of the file - if 0, means truncate. */

 10:19 FEB 12 '98 FU$SATTR                                 FU_NFS_M              Page 37
       899     %(LVL+1) SIZE UBIN %INIT(0)%ENIT,
       900
       901        /*K* ATIME timeval - file access time, in seconds (.SECONDS) and
       902        microseconds (.USECONDS) since 1/1/70 GMT */
       903     %(LVL+1) ATIME,
       904       %(LVL+2) SECONDS UBIN %INIT(0)%ENIT,
       905       %(LVL+2) USECONDS UBIN %INIT(0)%ENIT,
       906
       907        /*K* MTIME timeval - file write time, in seconds (.SECONDS) and
       908        microseconds (.USECONDS) since 1/1/70 GMT */
       909     %(LVL+1) MTIME,
       910       %(LVL+2) SECONDS UBIN %INIT(0)%ENIT,
       911       %(LVL+2) USECONDS UBIN %INIT(0)%ENIT LAST
       912
       913  %MEND;
       914

 10:19 FEB 12 '98 FU$ATTRSTAT                              FU_NFS_M              Page 38
       915  /*F* NAME: FU$ATTRSTAT
       916       DESCRIPTION:  Describes the response to several requests. */
       917
       918  %MACRO FU$ATTRSTAT(NAME=FU$ATTRSTAT,
       919   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       920
       921  %LSET LISTDIR='0'B;
       922  %LSET LISTCOM='0'B;
       923  %LSET LISTEXP='1'B;
       924  %LSET LISTSUB='1'B;
       925
       926  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       927  %IF STR='CON' OR STR='STA' OR STR='EXT';
       928  %LSET INIT=CHARTEXT('INIT');
       929  %LSET ENIT=CHARTEXT(' ');
       930  %ELSE;
       931  %LSET INIT=CHARTEXT('/*');
       932  %LSET ENIT=CHARTEXT('*/');
       933  %ENDIF;
       934
       935  %IF LVL=1;
       936  DCL 1 NAME STCLASS ALGN,
       937  %ELSE;
       938   %(LVL) NAME ALGN,
       939  %ENDIF;
       940
       941  %LSET L1=LVL+1;
       942        /*K* STAT UBIN - error code. Zero if all is ok.  */
       943     %(LVL+1) STAT UBIN %INIT(0)%ENIT,
       944
       945        /*K* FATTR FU$FATTR - file attributes. */
       946     %FU$FATTR( NAME=FATTR, LVL=%L1, STCLASS=STCLASS, LAST=LAST);
       947
       948  %MEND;
       949

 10:19 FEB 12 '98 FU$DIROPARGS                             FU_NFS_M              Page 39
       950  /*F* NAME: FU$DIROPARGS
       951       DESCRIPTION:  Describes the argauments for directory operations. */
       952
       953  %MACRO FU$DIROPARGS( NAME=FU$DIROARGS,
       954   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       955
       956  %LSET LISTDIR='0'B;
       957  %LSET LISTCOM='0'B;
       958  %LSET LISTEXP='1'B;
       959  %LSET LISTSUB='1'B;
       960
       961  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       962  %IF STR='CON' OR STR='STA' OR STR='EXT';
       963  %LSET INIT=CHARTEXT('INIT');
       964  %LSET ENIT=CHARTEXT(' ');
       965  %ELSE;
       966  %LSET INIT=CHARTEXT('/*');
       967  %LSET ENIT=CHARTEXT('*/');
       968  %ENDIF;
       969
       970  %IF LVL=1;
       971  DCL 1 NAME STCLASS ALGN,
       972  %ELSE;
       973   %(LVL) NAME ALGN,
       974  %ENDIF;
       975
       976        /*K* DIR FU$FHANDLE - specifies the fhandle of the directory. */
       977  %LSET L1=LVL+1;
       978     %FU$FHANDLE( NAME=DIR, LVL=%L1, STCLASS=STCLASS, LAST=NO);
       979
       980        /*K* NAME TEXTW - name of the affected item in DIR. */
       981     %(LVL+1) %CHARTEXT('NAME'),
       982       %(LVL+2) L UBIN %INIT(0)%ENIT,
       983       %(LVL+2) T CHAR(NAME.%CHARTEXT('NAME').L) %INIT(' ')%ENIT LAST
       984
       985  %MEND;
       986

 10:19 FEB 12 '98 FU$DIROPRES                              FU_NFS_M              Page 40
       987  /*F* NAME: FU$DIROPRES
       988       DESCRIPTION:  Describes the results of a directory operation. */
       989
       990  %MACRO FU$DIROPRES(NAME=FU$DIROPRES,
       991   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
       992
       993  %LSET LISTDIR='0'B;
       994  %LSET LISTCOM='0'B;
       995  %LSET LISTEXP='1'B;
       996  %LSET LISTSUB='1'B;
       997
       998  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
       999  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1000  %LSET INIT=CHARTEXT('INIT');
      1001  %LSET ENIT=CHARTEXT(' ');
      1002  %ELSE;
      1003  %LSET INIT=CHARTEXT('/*');
      1004  %LSET ENIT=CHARTEXT('*/');
      1005  %ENDIF;
      1006
      1007  %IF LVL=1;
      1008  DCL 1 NAME STCLASS ALGN,
      1009  %ELSE;
      1010   %(LVL) NAME ALGN,
      1011  %ENDIF;
      1012
      1013        /*K* STAT UBIN - error code.  Zero if all is ok. */
      1014     %(LVL+1) STAT UBIN %INIT(0)%ENIT,
      1015
      1016        /*K* FILE FU$FHANDLE - file handle of the affected item. */
      1017  %LSET L1=LVL+1;
      1018     %FU$FHANDLE( NAME=FILE, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1019
      1020        /*K* FATTR FU$FATTR - (new) attributes of the item. */
      1021     %FU$FATTR( NAME=FATTR, LVL=%L1, STCLASS=STCLASS, LAST=LAST);
      1022
      1023  %MEND;

 10:19 FEB 12 '98 FU$DIROPRES                              FU_NFS_M              Page 41
      1024

 10:19 FEB 12 '98 FU$READDIRARGS                           FU_NFS_M              Page 42
      1025  /*F* NAME: FU$READDIRARGS
      1026       DESCRIPTION:  Arguments for the directory read request. */
      1027
      1028  %MACRO FU$READDIRARGS( NAME=FU$READDIRARGS,
      1029   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1030
      1031  %LSET LISTDIR='0'B;
      1032  %LSET LISTCOM='0'B;
      1033  %LSET LISTEXP='1'B;
      1034  %LSET LISTSUB='1'B;
      1035
      1036  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1037  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1038  %LSET INIT=CHARTEXT('INIT');
      1039  %LSET ENIT=CHARTEXT(' ');
      1040  %ELSE;
      1041  %LSET INIT=CHARTEXT('/*');
      1042  %LSET ENIT=CHARTEXT('*/');
      1043  %ENDIF;
      1044
      1045  %IF LVL=1;
      1046  DCL 1 NAME STCLASS ALGN,
      1047  %ELSE;
      1048   %(LVL) NAME ALGN,
      1049  %ENDIF;
      1050
      1051        /*K* DIR FU$FHANDLE - directory fhandle. */
      1052  %LSET L1=LVL+1;
      1053     %FU$FHANDLE( NAME=DIR, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1054
      1055        /*K* COOKIE ? - start point - 4 bytes, but what's in 'em? */
      1056     %(LVL+1) COOKIE UBIN %INIT(0)%ENIT,
      1057
      1058        /*K* COUNT UBIN - number of bytes to limit the response to. */
      1059     %(LVL+1) COUNT UBIN %INIT(0)%ENIT LAST
      1060
      1061  %MEND;

 10:19 FEB 12 '98 FU$READDIRARGS                           FU_NFS_M              Page 43
      1062

 10:19 FEB 12 '98 FU$READARGS                              FU_NFS_M              Page 44
      1063  /*F* NAME: FU$READARGS
      1064       DESCRIPTION:  Arguments for the read from file request. */
      1065
      1066  %MACRO FU$READARGS( NAME=FU$READARGS,
      1067   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1068
      1069  %LSET LISTDIR='0'B;
      1070  %LSET LISTCOM='0'B;
      1071  %LSET LISTEXP='1'B;
      1072  %LSET LISTSUB='1'B;
      1073
      1074  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1075  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1076  %LSET INIT=CHARTEXT('INIT');
      1077  %LSET ENIT=CHARTEXT(' ');
      1078  %ELSE;
      1079  %LSET INIT=CHARTEXT('/*');
      1080  %LSET ENIT=CHARTEXT('*/');
      1081  %ENDIF;
      1082
      1083  %IF LVL=1;
      1084  DCL 1 NAME STCLASS ALGN,
      1085  %ELSE;
      1086   %(LVL) NAME ALGN,
      1087  %ENDIF;
      1088
      1089        /*K* FILE FU$FHANDLE - file fhandle. */
      1090  %LSET L1=LVL+1;
      1091     %FU$FHANDLE( NAME=DIR, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1092
      1093        /*K* OFFSET UBIN - start point - bytes offset into the file. */
      1094     %(LVL+1) OFFSET UBIN %INIT(0)%ENIT,
      1095
      1096        /*K* COUNT UBIN - number of bytes to limit the response to. */
      1097     %(LVL+1) COUNT UBIN %INIT(0)%ENIT,
      1098
      1099        /*K* TOTALCOUNT UBIN - no longer used. */

 10:19 FEB 12 '98 FU$READARGS                              FU_NFS_M              Page 45
      1100     %(LVL+1) TOTALCOUNT UBIN %INIT(0)%ENIT LAST
      1101
      1102  %MEND;
      1103

 10:19 FEB 12 '98 FU$READRES                               FU_NFS_M              Page 46
      1104  /*F* NAME: FU$READRES
      1105       DESCRIPTION:  Response to the read from file request. */
      1106
      1107  %MACRO FU$READRES( NAME=FU$READRES,
      1108   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1109
      1110  %LSET LISTDIR='0'B;
      1111  %LSET LISTCOM='0'B;
      1112  %LSET LISTEXP='1'B;
      1113  %LSET LISTSUB='1'B;
      1114
      1115  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1116  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1117  %LSET INIT=CHARTEXT('INIT');
      1118  %LSET ENIT=CHARTEXT(' ');
      1119  %ELSE;
      1120  %LSET INIT=CHARTEXT('/*');
      1121  %LSET ENIT=CHARTEXT('*/');
      1122  %ENDIF;
      1123
      1124  %IF LVL=1;
      1125  DCL 1 NAME STCLASS ALGN,
      1126  %ELSE;
      1127   %(LVL) NAME ALGN,
      1128  %ENDIF;
      1129
      1130        /*K* STAT UBIN - operation status. */
      1131     %(LVL+1) STAT UBIN %INIT(0)%ENIT,
      1132
      1133        /*K* FATTR FU$FATTR - file attributes. */
      1134  %LSET L1=LVL+1;
      1135     %FU$FATTR( NAME=FATTR, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1136
      1137        /*K* COUNT UBIN - number of bytes of data being returned.
      1138        Presumably, if less than the request, the file ended. */
      1139     %(LVL+1) COUNT UBIN %INIT(0)%ENIT,
      1140

 10:19 FEB 12 '98 FU$READRES                               FU_NFS_M              Page 47
      1141        /*K* DATA CHAR(NAME.COUNT) - the data being returned. */
      1142     %(LVL+1) DATA CHAR(NAME.COUNT) %INIT(' ')%ENIT LAST
      1143
      1144  %MEND;
      1145

 10:19 FEB 12 '98 FU$WRITEARGS                             FU_NFS_M              Page 48
      1146  /*F* NAME: FU$WRITEARGS
      1147       DESCRIPTION:  Arguments for the write to file request. */
      1148
      1149  %MACRO FU$WRITEARGS( NAME=FU$WRITEARGS,
      1150   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1151
      1152  %LSET LISTDIR='0'B;
      1153  %LSET LISTCOM='0'B;
      1154  %LSET LISTEXP='1'B;
      1155  %LSET LISTSUB='1'B;
      1156
      1157  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1158  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1159  %LSET INIT=CHARTEXT('INIT');
      1160  %LSET ENIT=CHARTEXT(' ');
      1161  %ELSE;
      1162  %LSET INIT=CHARTEXT('/*');
      1163  %LSET ENIT=CHARTEXT('*/');
      1164  %ENDIF;
      1165
      1166  %IF LVL=1;
      1167  DCL 1 NAME STCLASS ALGN,
      1168  %ELSE;
      1169   %(LVL) NAME ALGN,
      1170  %ENDIF;
      1171
      1172        /*K* FILE FU$FHANDLE - file fhandle. */
      1173  %LSET L1=LVL+1;
      1174     %FU$FHANDLE( NAME=FILE, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1175
      1176        /*K* BEGINOFFSET UBIN - no longer used. */
      1177     %(LVL+1) BEGINOFFSET UBIN %INIT(0)%ENIT,
      1178
      1179        /*K* OFFSET UBIN - starting byte offset into the file. */
      1180     %(LVL+1) OFFSET UBIN %INIT(0)%ENIT,
      1181
      1182        /*K* TOTALCOUNT UBIN - no longer used. */

 10:19 FEB 12 '98 FU$WRITEARGS                             FU_NFS_M              Page 49
      1183     %(LVL+1) TOTALCOUNT UBIN %INIT(0)%ENIT,
      1184
      1185        /*K* COUNT UBIN - number of bytes to write. */
      1186     %(LVL+1) COUNT UBIN %INIT(0)%ENIT,
      1187
      1188        /*K* DATA CHAR(NAME.COUNT) - data to be written. */
      1189     %(LVL+1) DATA CHAR(NAME.COUNT) %INIT(' ')%ENIT LAST
      1190
      1191  %MEND;
      1192

 10:19 FEB 12 '98 FU$SATTRARGS                             FU_NFS_M              Page 50
      1193  /*F* NAME: FU$SATTRARGS
      1194       DESCRIPTION:  Describes the arguments for a set attributes request. */
      1195
      1196  %MACRO FU$SATTRARGS( NAME=FU$SATTRARGS,
      1197   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1198
      1199  %LSET LISTDIR='0'B;
      1200  %LSET LISTCOM='0'B;
      1201  %LSET LISTEXP='1'B;
      1202  %LSET LISTSUB='1'B;
      1203
      1204  %IF LVL=1;
      1205  DCL 1 NAME STCLASS ALGN,
      1206  %ELSE;
      1207   %(LVL) NAME ALGN,
      1208  %ENDIF;
      1209
      1210        /*K* FILE FU$FHANDLE - item fhandle. */
      1211  %LSET L1=LVL+1;
      1212     %FU$FHANDLE( NAME=FILE, LVL=%L1, STCLASS=STCLASS, LAST=NO);
      1213
      1214        /*K* SATTR FU$FATTR(setonly) - attributes to change. */
      1215     %FU$SATTR( NAME=SATTR, LVL=%L1, STCLASS=STCLASS, LAST=LAST);
      1216
      1217  %MEND;
      1218

 10:19 FEB 12 '98 FU$STATFSRES                             FU_NFS_M              Page 51
      1219  /*F* NAME: FU$STATFSRES
      1220       DESCRIPTION:  Describes results for a get filesystem attributes request. */
      1221
      1222  %MACRO FU$STATFSRES( NAME=FU$STATFSRES,
      1223   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1224
      1225  %LSET LISTDIR='0'B;
      1226  %LSET LISTCOM='0'B;
      1227  %LSET LISTEXP='1'B;
      1228  %LSET LISTSUB='1'B;
      1229
      1230  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1231  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1232  %LSET INIT=CHARTEXT('INIT');
      1233  %LSET ENIT=CHARTEXT(' ');
      1234  %ELSE;
      1235  %LSET INIT=CHARTEXT('/*');
      1236  %LSET ENIT=CHARTEXT('*/');
      1237  %ENDIF;
      1238
      1239  %IF LVL=1;
      1240  DCL 1 NAME STCLASS ALGN,
      1241  %ELSE;
      1242   %(LVL) NAME ALGN,
      1243  %ENDIF;
      1244
      1245        /*K* STAT UBIN - operation status. */
      1246     %(LVL+1) STAT UBIN %INIT(0)%ENIT,
      1247
      1248        /*K* TSIZE UBIN - optimum transfer size. */
      1249     %(LVL+1) TSIZE UBIN %INIT(0)%ENIT,
      1250
      1251        /*K* BSIZE UBIN - byte block size. */
      1252     %(LVL+1) BSIZE UBIN %INIT(0)%ENIT,
      1253
      1254        /*K* BLOCKS UBIN - total blocks in filesystem. */
      1255     %(LVL+1) BLOCKS UBIN %INIT(0)%ENIT,

 10:19 FEB 12 '98 FU$STATFSRES                             FU_NFS_M              Page 52
      1256
      1257        /*K* BFREE UBIN - free blocks in filesystem. */
      1258     %(LVL+1) BFREE UBIN %INIT(0)%ENIT,
      1259
      1260        /*K* BAVAIL UBIN - free non-privileged blocks in filesystem. */
      1261     %(LVL+1) BAVAIL UBIN %INIT(0)%ENIT LAST
      1262
      1263  %MEND;
      1264

 10:19 FEB 12 '98 FU$NFSSECKEY                             FU_NFS_M              Page 53
      1265  /*F* NAME: FU$NFSSECKEY
      1266       DESCRIPTION:  Describes the key for a user record in :nfssec.:SYS. */
      1267
      1268  %MACRO FU$NFSSECKEY( NAME=FU$NFSSECKEY,
      1269   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1270
      1271  %LSET LISTDIR='0'B;
      1272  %LSET LISTCOM='0'B;
      1273  %LSET LISTEXP='1'B;
      1274  %LSET LISTSUB='1'B;
      1275
      1276  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1277  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1278  %LSET INIT=CHARTEXT('INIT');
      1279  %LSET ENIT=CHARTEXT(' ');
      1280  %ELSE;
      1281  %LSET INIT=CHARTEXT('/*');
      1282  %LSET ENIT=CHARTEXT('*/');
      1283  %ENDIF;
      1284
      1285  %IF LVL=1;
      1286  DCL 1 NAME STCLASS ALGN,
      1287  %ELSE;
      1288   %(LVL) NAME ALGN,
      1289  %ENDIF;
      1290
      1291        /*K* L UBIN BYTE - key length (big surprise!). */
      1292     %(LVL+1) L UBIN(9) UNAL %INIT(5)%ENIT,
      1293
      1294        /*K* * BIT(9) - hole for alignment purposes. */
      1295     %(LVL+1) * BIT(9) %INIT('0'B)%ENIT,
      1296
      1297        /*K* UID UBIN HALF - unix uid (expanded - 256 is the wildcard). */
      1298     %(LVL+1) UID UBIN(18) UNAL %INIT(0)%ENIT,
      1299
      1300        /*K* GID UBIN HALF - unix gid (expanded - 256 is the wildcard). */
      1301     %(LVL+1) GID UBIN(18) UNAL %INIT(0)%ENIT,

 10:19 FEB 12 '98 FU$NFSSECKEY                             FU_NFS_M              Page 54
      1302
      1303        /*K* NAME CHAR(var) - hostname (length is L-5 - L=5 for wildcard). */
      1304     %(LVL+1) %CHARTEXT('NAME') CHAR(249) %INIT(' ')%ENIT LAST
      1305
      1306  %MEND;
      1307

 10:19 FEB 12 '98 FU$SMKEY                                 FU_NFS_M              Page 55
      1308  /*F* NAME: FU$SMKEY
      1309       DESCRIPTION:  Describes the key for a SECCHK/MOUNT record in :nfssec.:SYS. */
      1310
      1311  %MACRO FU$SMKEY( NAME=FU$SMKEY,
      1312   ALGN=ALIGNED, STCLASS=BASED, LVL=1, LAST(YES=";",NO=",")=";");
      1313
      1314  %LSET LISTDIR='0'B;
      1315  %LSET LISTCOM='0'B;
      1316  %LSET LISTEXP='1'B;
      1317  %LSET LISTSUB='1'B;
      1318
      1319  %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
      1320  %IF STR='CON' OR STR='STA' OR STR='EXT';
      1321  %LSET INIT=CHARTEXT('INIT');
      1322  %LSET ENIT=CHARTEXT(' ');
      1323  %ELSE;
      1324  %LSET INIT=CHARTEXT('/*');
      1325  %LSET ENIT=CHARTEXT('*/');
      1326  %ENDIF;
      1327
      1328  %IF LVL=1;
      1329  DCL 1 NAME STCLASS ALGN,
      1330  %ELSE;
      1331   %(LVL) NAME ALGN,
      1332  %ENDIF;
      1333
      1334        /*K* L UBIN BYTE - key length (big surprise!). */
      1335     %(LVL+1) L UBIN(9) UNAL %INIT(3)%ENIT,
      1336
      1337        /*K* * BIT(9) - hole for alignment and file position purposes. */
      1338     %(LVL+1) * BIT(9) %INIT('1'B)%ENIT,
      1339
      1340        /*K* SMKEY UBIN HALF - Arbitrary number chosen by the munger and recorded
      1341             in the :nfssec used record field of the same name. */
      1342     %(LVL+1) SMKEY UBIN(18) UNAL %INIT(0)%ENIT LAST
      1343
      1344  %MEND;

 10:19 FEB 12 '98 FU$SMKEY                                 FU_NFS_M              Page 56
      1345

 10:19 FEB 12 '98 FU$SMREC                                 FU_NFS_M              Page 57
      1346  /*F* NAME: FU$SMREC
      1347       DESCRIPTION: Describes the SECCHK/MOUNT extension records in :nfssec.:SYS.
      1348       Each such record is pointed to by one or more FU$NFSSECRECs and consists of
      1349       a list of FU$FIDPARTs, with FFLG where ASN otherwise lives, and PSN.N
      1350       containing a word offset to the next item in the list, since the NAME.T
      1351       portion is variable (CHAR(NAME.L)) to conserve space.  THe last item in
      1352       the list has a zero in PSN.N. */
      1353
      1354  %MACRO FU$SMREC (NAME=FU$SMREC, LVL=1, STCLASS=BASED, LAST(YES=";",NO=",")=";");
      1355  %LSET LISTDIR = '0'B;
      1356     %FU$FIDPARTS (NAME=NAME, LVL=LVL, STCLASS=STCLASS, LAST=LAST, SMREC=1);
      1357
      1358  %MEND;

 10:19 FEB 12 '98 FU_PERR_C                                FU_PERR_C             Page 58
         1  /*M* Error codes for NFSA                                             */
         2  /*T***********************************************************/
         3  /*T*                                                         */
         4  /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
         5  /*T*                                                         */
         6  /*T***********************************************************/
         7  /*X* DDA */
         8
         9  %EQU E$FUS_NOUID = 1;
        10  %EQU E$FUS_NOGID = 2;
        11  %EQU E$FUS_NOACCT = 3;
        12  %EQU E$FUS_NONAME = 4;
        13  %EQU E$FUS_NOHOST = 5;
        14  %EQU E$FUS_NONFS = 6;
        15  %EQU E$FUS_NOUNIX = 7;
        16  %EQU E$FUS_NOCP6 = 8;
        17  %EQU E$FUS_NOHSTCL = 9;
        18  %EQU E$FUS_UIDTOOBIG = 10;
        19  %EQU E$FUS_GIDTOOBIG = 11;

 10:19 FEB 12 '98 TABLE OF CONTENTS                        FU_PERR_C             Page 59
 FUS_DATA_C..................................1     FU$ATTRSTAT.................................38
 FUU_EQU_E...................................3     FU$DIROPARGS................................39
 FU_NFSSUBS_C................................4     FU$DIROPRES.................................40
 FU_NFS_M....................................8     FU$FATTR....................................32
 FU$NFSDS....................................9     FU$FCTX.....................................23
 FU$FHANDLE..................................13    FU$FHANDLE..................................13
 FU$HCTX.....................................15    FU$FIDPARTS.................................26
 FU$UCTX.....................................17    FU$HCTX.....................................15
 FU$SECREC...................................21    FU$NFSDS....................................9
 FU$FCTX.....................................23    FU$NFSSECKEY................................53
 FU$FIDPARTS.................................26    FU$READARGS.................................44
 FU$RQSCTX...................................28    FU$READDIRARGS..............................42
 FU$FATTR....................................32    FU$READRES..................................46
 FU$SATTR....................................36    FU$RQSCTX...................................28
 FU$ATTRSTAT.................................38    FU$SATTR....................................36
 FU$DIROPARGS................................39    FU$SATTRARGS................................50
 FU$DIROPRES.................................40    FU$SECREC...................................21
 FU$READDIRARGS..............................42    FU$SMKEY....................................55
 FU$READARGS.................................44    FU$SMREC....................................57
 FU$READRES..................................46    FU$STATFSRES................................51
 FU$WRITEARGS................................48    FU$UCTX.....................................17
 FU$SATTRARGS................................50    FU$WRITEARGS................................48
 FU$STATFSRES................................51    FUS_DATA_C..................................1
 FU$NFSSECKEY................................53    FUU_EQU_E...................................3
 FU$SMKEY....................................55    FU_NFSSUBS_C................................4
 FU$SMREC....................................57    FU_NFS_M....................................8
 FU_PERR_C...................................58    FU_PERR_C...................................58
