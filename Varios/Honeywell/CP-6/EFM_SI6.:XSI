/*M* EFM - Ben Faul's Error File Munger */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
EFM:    PROC MAIN;
/*A* EFM: Ben's Error message File Munger */
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
DCL B$JIT$ PTR SYMREF;
%INCLUDE XU_MACRO_C;
%B$ALT;
%B$TCB;
DCL B$TCB$ PTR SYMREF;
%F$DCB;
 
%FPT_INT(FPTN=BREAK_CONTROL,UENTRY=BREAK);
%FPT_DELREC(FPTN=DELREC,DCB=M$IN1,KEY=ERR_KEY,LKEY=LKEY);
%FPT_WRITE(FPTN=WRITE_ADD,ONEWKEY=NO,NEWKEY=YES,BUF=ERR_INPUT,KEY=ERR_KEY,DCB=M$IN1);
%FPT_WRITE(FPTN=OVERWRITE,DCB=M$IN1,ONEWKEY=YES,BUF=ERR_INPUT,KEY=ERR_KEY);
%FPT_CORRES(FPTN=SIDO,DCB1=M$SI,DCB2=M$DO);
%FPT_PFIL(FPTN=BOF,BOF=YES,DCB=M$IN1);
%FPT_READ(FPTN=READ_USER,BUF=INPUT,DCB=M$SI);
%FPT_WRITE(FPTN=WRITE_DO,BUF=OUTPUT,DCB=M$DO);
%FPT_READ(FPTN=READ_ERRFILE_K,BUF=ERR_INPUT,DCB=M$IN1,KEY=ERR_KEY,KEYS=YES);
%FPT_READ(FPTN=READ_ERRFILE_S,BUF=ERR_INPUT,DCB=M$IN1,KEY=ERR_KEY,KEYR=YES);
%FPT_READ(FPTN=READ_STI,BUF=STI_INPUT,DCB=M$IN1,KEY=STI_KEY,KEYS=YES);
%FPT_CLOSE(FPTN=CLOSE,DISP=SAVE,DCB=M$IN1);
%FPT_DELREC(FPTN=DELETE_KEY,DCB=M$IN1,KEY=ERR_KEY);
 
%FPT_OPEN(FPTN=OPEN_UPDATE,
DCB=M$IN1,
NAME=VLP_NAME,
ACCT=VLP_ACCT,
PASS=VLP_PASS,
ASN=FILE,
SN=VLP_SN,
SHARE=IN,
FUN=UPDATE,
ORG=KEYED,
ACS=DIRECT);
 
%FPT_OPEN(FPTN=OPEN_INPUT,
DCB=M$IN1,
NAME=VLP_NAME,
ACCT=VLP_ACCT,
PASS=VLP_PASS,
ASN=FILE,
SN=VLP_SN,
SHARE=ALL,
FUN=IN,
ORG=KEYED,
ACS=DIRECT);
 
%FPT_FID(FPTN=FPT_FID,
NAME=VLP_NAME,
ACCT=VLP_ACCT,
PASS=VLP_PASS,
SN=VLP_SN,
ASN=FID_ASN,
RES=FID_RES,
RESULTS=VLR_FID,
TEXTFID=FID_TEXT);
 
%VLP_NAME;
%VLP_ACCT;
%VLP_PASS;
%VLP_SN;
%VLR_FID;
 
DCL FID_TEXT CHAR(60) STATIC;
DCL FID_RES CHAR(4) STATIC;
DCL FID_ASN UBIN(9) STATIC ALIGNED;
 
DCL M$SI DCB;
DCL M$DO DCB;
DCL M$IN1 DCB;
 
DCL 1 ERR_INPUT STATIC,
      2 SUBS BIT(1) UNAL,
      2 NOT_LAST BIT(1) UNAL,
      2 NA BIT(7) UNAL INIT('0000000'B),
      2 DATA CHAR(115) INIT(' ');
 
DCL 1 STI_INPUT STATIC,
      2 SCOMMENT CHAR (6) UNAL,
        /*K*  SCOMMENT indicates the starting of the comment field
              in source files */
 
      2 * CHAR (1) UNAL,
      2 PRODUCT CHAR (12) UNAL,
        /*K*  PRODUCT is the field to contain the name assigned
              to all components of the product. */
 
      2 * CHAR (1) UNAL,
      2 VERSION CHAR (6) UNAL,
        /*K*  VERSION is the current version of the product */
 
      2 * CHAR (1) UNAL,
      2 TIME CHAR (11) UNAL,
        /*K*  TIME is the time obtained from the UTS. */
 
      2 * CHAR (1) UNAL,
      2 DATE CHAR (10) UNAL,
        /*K*  DATE is the date obtained from the UTS. */
 
      2 * CHAR (1) UNAL,
      2 MARKID CHAR (7) UNAL,
        /*K* MARKeting IDentifier. */
 
 
      2 ECOMMENT CHAR (7) UNAL;
        /*K*  ECOMMENT indicates the ending of the comment field
              in source files */
DCL INPUT CHAR(256) STATIC;             /* input from user buffer             */
DCL OUTPUT CHAR(256) STATIC;            /* output messages to user            */
DCL 1 STI_KEY STATIC,
      2 * UBIN BYTE INIT(3) UNAL,
      2 * CHAR(3) INIT('STI');
 
DCL 1 ERR_KEY STATIC ALIGNED,           /* used in reading err mess files     */
      2 LEN UBIN(9) INIT(5) UNAL,       /* length of key                      */
      2 FCG(0:2) BIT(6) UNAL,           /* functional code group              */
      2 MON_BIT BIT(1) UNAL,            /* monitor bit                        */
      2 CODE# BIT(14) UNAL,             /* error code                         */
      2 MESS# BIT(3) UNAL,              /* message number 0-7                 */
      2 SEQ# BIT(9) UNAL;               /* sequence number                    */
 
DCL 1 ERR_KEY_REDEF REDEF ERR_KEY ALIGNED,
      2 LEN UBIN(9) UNAL,
      2 FCG UBIN(18) UNAL,
      2 MON_BIT BIT(1) UNAL,
      2 CODE# UBIN(14) UNAL,
      2 MESS# UBIN(3) UNAL,
      2 SEQ# UBIN(9) UNAL;
 
DCL 1 LKEY STATIC ALIGNED,              /* used for deleteing a range of keys */
      2 LEN UBIN(9) INIT(5) UNAL,       /* length of key                      */
      2 FCG(0:2) BIT(6) UNAL,           /* functional code group              */
      2 MON_BIT BIT(1) UNAL,            /* monitor bit                        */
      2 CODE# BIT(14) UNAL,             /* error code                         */
      2 MESS# BIT(3) UNAL,              /* message number 0-7                 */
      2 SEQ# BIT(9) UNAL;               /* sequence number                    */
DCL 1 LKEY_REDEF REDEF LKEY ALIGNED,
      2 LEN UBIN(9) UNAL,
      2 FCG UBIN(18) UNAL,
      2 MON_BIT BIT(1) UNAL,
      2 CODE# UBIN(14) UNAL,
      2 MESS# UBIN(3) UNAL,
      2 SEQ# UBIN(9) UNAL;
 
DCL SUBCHAR CHAR(1) STATIC INIT('%');   /* substitution character             */
DCL REMVAR REMEMBER STATIC SYMDEF;
DCL XEQ BIT(1);
%P_PCB(NAME=P_PCB,T=INPUT,W=PARSE_WORK,WSZ=256,R=COMMAND,N#=256);
%PARSE$SYM(NAME=OUTSYM,STCLASS=BASED);
%PARSE$OUT(NAME=OUTBLK,STCLASS=BASED);
 
DCL COMMAND UBIN SYMREF;
DCL PARSE_WORK CHAR(1024) STATIC;
DCL JUNK BIT(1) STATIC INIT('0'B);
 
DCL BLOCK UBIN;
DCL I UBIN;                             /* temps                              */
DCL J UBIN;
DCL K UBIN;
DCL L UBIN;
DCL P$ PTR;
DCL CHARN CHAR(SIZE) BASED;
DCL SIZE UBIN;
DCL OLD_FCG CHAR(3);
DCL OLD_CODE CHAR(6);
DCL OLD_MESS CHAR(1);
DCL OLD_SEQ CHAR(3);
DCL ABORTED_EFM BIT(1) STATIC INIT('1'B); /* true if no file to mod specified */
 
DCL TRANS_TAB CHAR(64) STATIC
  INIT ('@ABCDEFGHIJKLMNOPQRSTUVWXYZ?????????????????????0123456789??????');
DCL SIXBIT BIT(18) ALIGNED;
%INCLUDE EFM_C1;
 
DCL 1 FLAGS STATIC,
      2 MODE# BIT(1) INIT('1'B);        /* 0=input, 1=update                  */
 
DCL FTX_RPTERR ENTRY;
DCL X$PARSE ENTRY(1) ALTRET;
DCL WILDCOMP ENTRY(4) ALTRET;
DCL BREAK ENTRY ASYNC;
DCL INTERNAL_ACCOUNTING ENTRY(1) ALTRET;
 
        OUTPUT=' ';                     /* SALUTE                             */
        CALL M$WRITE(WRITE_DO);
        OUTPUT='  C00 CP6 Error Message File Modifier here.';
        CALL M$WRITE(WRITE_DO);
        OUTPUT=' ';
        CALL M$WRITE(WRITE_DO);
        INPUT=B$JIT.CCBUF;
        P_PCB.NCHARS=B$JIT.CCARS;
        CALL X$PARSE(P_PCB)             /* check uts, if any                  */
        WHENALTRETURN DO;
           OUTPUT=' Error, Bad Uts specification or illegal file name specified.';
           CALL M$WRITE(WRITE_DO);
           CALL M$ERR;
           END;
 
/********** INTERNAL ACCOUNTING RUN *********/
 
        FID_TEXT=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT; /* run unit name, and account */
/* dont do internal accounting */
/*
          CALL INTERNAL_ACCOUNTING(FID_TEXT)
        WHENALTRETURN DO;
           OUTPUT='Please notify system manager that the internal accounting';
           CALL M$WRITE(WRITE_DO);
           OUTPUT='function of EFM is disabled because EFM does not have access';
           CALL M$WRITE(WRITE_DO);
           OUTPUT='to itself. You may proceed anyway.';
           CALL M$WRITE(WRITE_DO);
           END;
*/
 
        CALL INVOKE;                    /*  invoke the processor              */
 
        REMEMBER UP IN REMVAR;          /* for use with the break key         */
        CALL M$INT(BREAK_CONTROL);      /* set up break                       */
        DO WHILE('1'B);                 /* do forever, read commands          */
UP:        XEQ='0'B;
           IF JUNK THEN GOTO OVER;
           ELSE INPUT=' ';
           JUNK='0'B;
           CALL M$READ(READ_USER)
           WHENALTRETURN DO;
              CALL FTX_RPTERR;
              CALL M$ERR;
              END;
           P_PCB.NCHARS=DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#;
OVER:      CALL M$CORRES(SIDO)          /* echo input?                        */
           WHENRETURN DO;
              XEQ='1'B;
              CALL CONCAT(OUTPUT,'XEQ>',SUBSTR(INPUT,0,P_PCB.NCHARS));
              CALL M$WRITE(WRITE_DO);
              END;
           IF ~JUNK THEN DO;
              IF P_PCB.NCHARS=0 OR
                INPUT=' ' OR
                SUBSTR(INPUT,0,1)='"' THEN GOTO UP; /* don't parse this stuff */
              CALL X$PARSE(P_PCB)
              WHENALTRETURN DO;         /* syntax error                       */
                 OUTPUT=' ';
                 IF ~XEQ THEN SUBSTR(OUTPUT,P_PCB.HI_CHAR+1,1)='^';
                 ELSE SUBSTR(OUTPUT,P_PCB.HI_CHAR+4)='^';
                 CALL M$WRITE(WRITE_DO);
                 GOTO UP;
                 END;
              END;
           BLOCK=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE;
           IF ABORTED_EFM AND NOT
             (BLOCK~=INVOKE# OR BLOCK~=END#) THEN DO;
              OUTPUT='Error, no error message file opened to process, input ignored.';
              CALL M$WRITE(WRITE_DO);
              GOTO UP;
              END;
           DO CASE(BLOCK);              /* do the command                     */
            CASE(LIST#);           /* list previous modifications, deletions  */
              CALL LIST;
            CASE(STI#);                 /* print sti record                   */
              CALL STI;
            CASE(ADD#,MODIFY#,DELETE#,UNMODIFY#,
                UNDELETE#,SUB#);        /* user must have write access        */
              IF ~FLAGS.MODE# THEN DO;
                 OUTPUT='Error, you are only allowed to read, not write to file.';
                 CALL M$WRITE(WRITE_DO);
                 END;
              ELSE IF BLOCK=ADD# THEN CALL ADD;
                 ELSE IF BLOCK=MODIFY# THEN CALL MODIFY;
 
                    ELSE IF BLOCK=DELETE# THEN CALL DELETE;
                       ELSE IF BLOCK=UNMODIFY# THEN CALL UNMODIFY;
                          ELSE IF BLOCK=UNDELETE# THEN CALL UNDELETE;
                             ELSE IF BLOCK=SUB# THEN CALL SUB;
            CASE(DUMP#);
              CALL DUMP;
            CASE(FIND#);
              CALL FIND;
            CASE(SECURE#);
              CALL SECURE;
            CASE(UTS#);
              CALL UTS;
            CASE(PRINT_FCGS#);
              CALL PRINT_FCGS;
            CASE(INVOKE#);
              CALL M$CLOSE(CLOSE);
              CALL INVOKE;
            CASE(SET_MON#);
              ERR_KEY.MON_BIT = '1'B;
              OUTPUT='Monitor bit is SET';
              CALL M$WRITE(WRITE_DO);
            CASE(SET_NOT_MON#);
              ERR_KEY.MON_BIT = '0'B;
              OUTPUT='Monitor bit is RESET';
              CALL M$WRITE(WRITE_DO);
            CASE(END#);
              CALL M$CLOSE(CLOSE);
              CALL M$EXIT;
            CASE(SUBCHAR#);
              SUBCHAR=SUBSTR(P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->
                OUTSYM.TEXT,0,1);
            CASE(ELSE);
              OUTPUT='Error, not legal here';
              CALL M$WRITE(WRITE_DO);
            END;                        /* end case                           */
           END;                         /* end do forever                     */
 
%EJECT;
LIST:   PROC;
/*A* LIST: List out previous EFM stuff */
END;
%EJECT;
STI:    PROC;
/*A* STI: List out STI record */
 
        CALL CONCAT(OUTPUT,'Associated product: ',STI_INPUT.PRODUCT);
        CALL M$WRITE(WRITE_DO);
        CALL CONCAT(OUTPUT,'Version: ',STI_INPUT.VERSION);
        CALL M$WRITE(WRITE_DO);
        CALL CONCAT(OUTPUT,'Associated Marketing ID: ',STI_INPUT.MARKID);
        CALL M$WRITE(WRITE_DO);
        CALL CONCAT(OUTPUT,'Birth date: ',STI_INPUT.DATE,' ',STI_INPUT.TIME);
        CALL M$WRITE(WRITE_DO);
 
END;
%EJECT;
FIND:   PROC;
/*A* FIND: FIND a string */
 
DCL TEXT CHAR(115);
DCL T_L UBIN;
DCL STRING CHAR(114);
 
        CALL M$PFIL(BOF);
        CALL M$READ(READ_ERRFILE_S)     /* read past the sti record           */
        WHENALTRETURN DO;
           CALL FTX_RPTERR;
           OUTPUT='Error, Error message file truncatd!';
           CALL M$WRITE(WRITE_DO);
           CALL M$ERR;
           END;
        DO WHILE('1'B);                 /* do until end of file               */
           ERR_INPUT.DATA=' ';
           CALL M$READ(READ_ERRFILE_S) ALTRET(DONE);
           TEXT=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
           T_L=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.COUNT;
           STRING=SUBSTR(ERR_INPUT.DATA,1);
           CALL WILDCOMP(TEXT,T_L,
             STRING,
             DCBADDR(DCBNUM(M$IN1))->F$DCB.ARS#)
           WHENRETURN DO;               /* FOUND ONE THAT MATCHES             */
              OUTPUT=ERR_INPUT.DATA; /* replace with code to show keys as well */
              CALL OUTPUT_KEYS;
              END;
           OLD_FCG=' ';
           OLD_CODE=' ';
           END;                         /* end do forever                     */
DONE:   ;                               /* finished processing                */
        OLD_FCG=' ';
        OLD_CODE=' ';
END;
%EJECT;
MODIFY: PROC;
/*A* MODIFY: Modify a record */
 
DCL OLD_BIT BIT(1);
 
        ERR_INPUT.DATA=' ';
        P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0);
        OLD_FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        IF SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,0,1)='M' THEN DO;
           ERR_KEY.MON_BIT='1'B;
           CALL CHARBIN(J,SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,1));
           END;
        ELSE
        CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
        CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
        CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
/* convert ascii fcgs into binary for use in the key */
 
        ERR_KEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,0,1)),6);
        ERR_KEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,1,1)),6);
        ERR_KEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,2,1)),6);
 
        ERR_KEY_REDEF.CODE#=J;
        ERR_KEY_REDEF.MESS#=K;
        ERR_KEY_REDEF.SEQ#=L;
 
        CALL M$READ(READ_ERRFILE_K)
        WHENALTRETURN DO;
/* test the other monitor bit before blowing up */
           ERR_KEY.MON_BIT=~ERR_KEY.MON_BIT;
           CALL M$READ(READ_ERRFILE_K)
           WHENALTRETURN DO;            /* no luck                            */
              CALL FTX_RPTERR;
              RETURN;
              END;
           END;
        OLD_BIT=ERR_INPUT.NOT_LAST;
        SUBSTR(ERR_INPUT.DATA,1)=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->
          OUTSYM.TEXT;
 
        ERR_INPUT.NOT_LAST='1'B;
/* we do not set the monitor bit automatically on modify, it takes on its prev value */
        DO I=1 TO P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS-1;
           IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
             LAST# THEN ERR_INPUT.NOT_LAST='0'B;
           ELSE IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
                MONITOR# THEN ERR_KEY.MON_BIT='1'B;
           END;
        SIZE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.COUNT;
        CALL CHECK_FOR_SUBS(SIZE);
        SIZE=SIZE+2;
        WRITE_ADD.BUF_=VECTOR(ADDR(ERR_INPUT)->CHARN);
        CALL M$WRITE(OVERWRITE)
        WHENALTRETURN DO;
           CALL FTX_RPTERR;
           END;
        IF OLD_BIT~=ERR_INPUT.NOT_LAST THEN DO; /* user error                 */
           IF OLD_BIT THEN DO;
              OUTPUT='Warning, New LAST record replacing a NOT LAST one!';
              CALL M$WRITE(WRITE_DO);
              END;
           END;
        OLD_FCG=' ';
END MODIFY;
%EJECT;
PRINT_FCGS: PROC;
 
DCL FCG_FIELD CHAR(3);
DCL OLD_FCG CHAR(3);
 
        OUTPUT='Functional code groups found:';
        CALL M$WRITE(WRITE_DO);
        OLD_FCG=' ';
        CALL M$PFIL(BOF);
        CALL M$READ(READ_ERRFILE_S);
        DO WHILE('1'B);
           CALL M$READ(READ_ERRFILE_S) ALTRET(DONE);
     SIXBIT = ERR_KEY.FCG;
     CALL XLATE_6_TO_9(FCG_FIELD,TRANS_TAB,SIXBIT);
           IF OLD_FCG~=FCG_FIELD THEN DO;
              OUTPUT=FCG_FIELD;
              CALL M$WRITE(WRITE_DO);
              END;
           OLD_FCG=FCG_FIELD;
           END;
DONE:   ;
END;
ADD:    PROC;
%EJECT;
/*A* ADD: Add a record */
 
        ERR_INPUT.DATA=' ';
        JUNK='0'B;
        P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0);
        OLD_FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        IF SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,0,1)='M' THEN DO;
           ERR_KEY.MON_BIT='1'B;
           CALL CHARBIN(J,SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,1));
           END;
        ELSE
        CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
        CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
        CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
/* convert ascii fcgs into binary for use in the key */
 
        ERR_KEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,0,1)),6);
        ERR_KEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,1,1)),6);
        ERR_KEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,2,1)),6);
 
        ERR_KEY_REDEF.CODE#=J;
        ERR_KEY_REDEF.MESS#=K;
        ERR_KEY_REDEF.SEQ#=L;
        CALL CHECK_RANGE
        WHENALTRETURN DO;               /* illegal range detected             */
           RETURN;
           END;
 
        SUBSTR(ERR_INPUT.DATA,1)=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->
          OUTSYM.TEXT;
 
        ERR_INPUT.NOT_LAST='1'B;
        DO I=2 TO P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS-1;
           IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
             LAST# THEN ERR_INPUT.NOT_LAST='0'B;
           ELSE IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
                MONITOR# THEN ERR_KEY.MON_BIT='1'B;
              ELSE JUNK='1'B;
           END;
        IF NOT ERR_INPUT.NOT_LAST AND JUNK THEN DO;
           OUTPUT='Error, LAST bit and MORE text bit set together, MORE ignored.';
           CALL M$WRITE(WRITE_DO);
           JUNK='0'B;
           END;
        SIZE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->OUTSYM.COUNT;
        CALL CHECK_FOR_SUBS(SIZE);
        SIZE=SIZE+2;
        WRITE_ADD.BUF_=VECTOR(ADDR(ERR_INPUT)->CHARN);
        CALL M$WRITE(WRITE_ADD)
        WHENALTRETURN DO;
           CALL FTX_RPTERR;
           END;
        DO WHILE JUNK;                  /* do while more text for this thing  */
UP:        JUNK='0'B;
           XEQ='0'B;
           ERR_INPUT.DATA=' ';
           INPUT=' ';
           CALL M$READ(READ_USER)
           WHENALTRETURN DO;
              OUTPUT='Error, input exhausted EFM quits';
              CALL M$WRITE(WRITE_DO);
              CALL M$CLOSE(CLOSE);
              CALL M$EXIT;
              END;
           P_PCB.NCHARS=DCBADDR(DCBNUM(M$SI))->F$DCB.ARS#;
           CALL M$CORRES(SIDO)
           WHENRETURN DO;
              CALL CONCAT(OUTPUT,'XEQ>',SUBSTR(INPUT,0,P_PCB.NCHARS));
              CALL M$WRITE(WRITE_DO);
              END;
           IF INPUT=' ' OR
             SUBSTR(INPUT,0,1)='"' THEN GOTO UP;
           CALL X$PARSE(P_PCB)
           WHENALTRETURN DO;
              OUTPUT=' ';
              IF ~XEQ THEN SUBSTR(OUTPUT,P_PCB.HI_CHAR+1,1)='^';
              ELSE SUBSTR(OUTPUT,P_PCB.HI_CHAR+4,1)='^';
              CALL M$WRITE(WRITE_DO);
              JUNK='0'B;
              RETURN;
              END;
           IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.CODE~=JUNK_TEXT# THEN DO;
              OUTPUT='Warning, EFM was expecting additional text for last error message';
              CALL M$WRITE(WRITE_DO);
              RETURN;
              END;
           ERR_KEY_REDEF.SEQ#=ERR_KEY_REDEF.SEQ#+1; /* increment  sequence number */
           CALL CHECK_RANGE
           WHENALTRETURN DO;
              RETURN;
              END;
           ERR_INPUT.NOT_LAST='1'B;
           JUNK='0'B;
           DO I=2 TO P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS-1;
              IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
                LAST# THEN ERR_INPUT.NOT_LAST='0'B;
              ELSE IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(I)->OUTBLK.CODE=
                   MONITOR# THEN ERR_KEY.MON_BIT='1'B;
                 ELSE JUNK = '1'B;
              END;
           IF JUNK AND NOT ERR_INPUT.NOT_LAST THEN DO;
              OUTPUT='Warning, LAST bit and MORE text set together, MORE ignored';
              CALL M$WRITE(WRITE_DO);
              END;
           IF NOT JUNK THEN ERR_INPUT.NOT_LAST='0'B;
           SIZE=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.COUNT;
           SUBSTR(ERR_INPUT.DATA,1)=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
           CALL CHECK_FOR_SUBS(SIZE);
           SIZE=SIZE+2;
           WRITE_ADD.BUF_=VECTOR(ADDR(ERR_INPUT)->CHARN);
           CALL M$WRITE(WRITE_ADD)
           WHENALTRETURN DO;
              CALL FTX_RPTERR;
              END;
           END;
END ADD;
DELETE: PROC;
/*A* DELETE: Delete some records */
 
        P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0);
        OLD_FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        IF SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,0,1)='M' THEN DO;
           ERR_KEY.MON_BIT='1'B;
           CALL CHARBIN(J,SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,1));
           END;
        ELSE
        CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
        CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
        CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
        CALL CHECK_RANGE
        WHENALTRETURN DO;
           OUTPUT='Error detected in first key.';
           CALL M$WRITE(WRITE_DO);
           RETURN;
           END;
/* convert ascii fcgs into binary for use in the key */
 
        ERR_KEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,0,1)),6);
        ERR_KEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,1,1)),6);
        ERR_KEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,2,1)),6);
 
        ERR_KEY_REDEF.CODE#=J;
        ERR_KEY_REDEF.MESS#=K;
        ERR_KEY_REDEF.SEQ#=L;
 
        LKEY=ERR_KEY;
        IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=2 THEN DO;
           P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1);
           OLD_FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
           CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
           CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
           CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
           CALL CHECK_RANGE
           WHENALTRETURN DO;
              OUTPUT='Error detected in second key.';
              CALL M$WRITE(WRITE_DO);
              RETURN;
              END;
/* convert ascii fcgs into binary for use in the key */
 
           LKEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,0,1)),6);
           LKEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,1,1)),6);
           LKEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,2,1)),6);
 
           LKEY_REDEF.CODE#=J;
           LKEY_REDEF.MESS#=K;
           LKEY_REDEF.SEQ#=L;
 
           END;
        ELSE LKEY=ERR_KEY;
        CALL M$DELREC(DELREC)
        WHENALTRETURN DO;
           CALL FTX_RPTERR;
           END;
END;
%EJECT;
UNMODIFY: PROC;
/*A* UNMODIFY: Change some records back */
 
END;
UNDELETE: PROC;
/*A* UNDELETE: Bring some records back */
 
END;
%EJECT;
DUMP:   PROC;
/*A* DUMP: Dump some records */
 
DCL 1 FIRST_KEY,
      2 FCG UBIN,
      2 CODE# UBIN,
      2 MESS# UBIN,
      2 SEQ# UBIN;
DCL I UBIN;
DCL J UBIN;
 
        IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS = 0 THEN DO; /* dump all */
           OUTPUT=' ';
           CALL M$WRITE(WRITE_DO);
           INPUT='FIND ''?''';
           P_PCB.NCHARS=9;
           CALL X$PARSE(P_PCB);
           CALL FIND;
           END;
        ELSE IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=1 THEN DO;
 
              P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0);
              OLD_FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
              CALL CHARBIN(FIRST_KEY.CODE#,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
              CALL CHARBIN(FIRST_KEY.MESS#,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
              CALL CHARBIN(FIRST_KEY.SEQ#,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
/* convert ascii fcgs into binary for use in the key */
 
              ERR_KEY.FCG(0) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,0,1)),6);
              ERR_KEY.FCG(1) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,1,1)),6);
              ERR_KEY.FCG(2) = BINBIT(ASCBIN(SUBSTR(OLD_FCG,2,1)),6);
 
              ERR_KEY_REDEF.CODE#=FIRST_KEY.CODE#;
              ERR_KEY_REDEF.MESS#=FIRST_KEY.MESS#;
              ERR_KEY_REDEF.SEQ#=FIRST_KEY.SEQ#;
              ERR_INPUT.DATA=' ';
              CALL M$READ(READ_ERRFILE_K)
              WHENALTRETURN DO;
/* test for the other mon bit */
                 ERR_KEY.MON_BIT=~ERR_KEY.MON_BIT;
                 CALL M$READ(READ_ERRFILE_K)
                 WHENALTRETURN DO;      /* no luck                            */
                    CALL FTX_RPTERR;
                    RETURN;
                    END;
                 END;
              OUTPUT=ERR_INPUT.DATA;
              CALL OUTPUT_KEYS;
              END;
           ELSE CALL DUMP_RANGE;
           OLD_FCG=' ';
           OLD_CODE=' ';
END;
%EJECT;
DUMP_RANGE: PROC;
/*A* DUMP_RANGE: Dump a range of records */
 
DCL 1 KEY1,
      2 FCG CHAR(3),
      2 CODE CHAR(6),
      2 MESS CHAR(1),
      2 SEQ CHAR(3);
 
DCL 1 KEY2,
      2 FCG CHAR(3),
      2 CODE CHAR(6),
      2 MESS CHAR(1),
      2 SEQ CHAR(3);
 
DCL 1 TEST_KEY,
      2 FCG CHAR(3),
      2 CODE CHAR(6),
      2 MESS CHAR(1),
      2 SEQ CHAR(3);
 
        P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(0);
 
/* right justify key1 */
        KEY1.FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        IF SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,0,1)='M' THEN DO;
           ERR_KEY.MON_BIT='1'B;
           CALL CHARBIN(J,SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,1));
           END;
        ELSE
        CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
        CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
        CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
        CALL BINCHAR(KEY1.CODE,J);
        CALL BINCHAR(KEY1.MESS,K);
        CALL BINCHAR(KEY1.SEQ,L);
 
        CALL CHECK_RANGE
        WHENALTRETURN DO;
           OUTPUT='Error occured in first key.';
           CALL M$WRITE(WRITE_DO);
           RETURN;
           END;
        P$=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1);
 
/*right justify key2 */
        KEY2.FCG=P$->OUTBLK.SUBLK$(0)->OUTSYM.TEXT;
        IF SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,0,1)='M' THEN DO;
           ERR_KEY.MON_BIT='1'B;
           CALL CHARBIN(J,SUBSTR(P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT,1));
           END;
        ELSE
        CALL CHARBIN(J,P$->OUTBLK.SUBLK$(1)->OUTSYM.TEXT);
        CALL CHARBIN(K,P$->OUTBLK.SUBLK$(2)->OUTSYM.TEXT);
        CALL CHARBIN(L,P$->OUTBLK.SUBLK$(3)->OUTSYM.TEXT);
 
        CALL BINCHAR(KEY2.CODE,J);
        CALL BINCHAR(KEY2.MESS,K);
        CALL BINCHAR(KEY2.SEQ,L);
 
        CALL CHECK_RANGE
        WHENALTRETURN DO;
           OUTPUT='Error detected in second key.';
           CALL M$WRITE(WRITE_DO);
           RETURN;
           END;
 
        CALL M$PFIL(BOF);
        READ_ERRFILE_S.V.DCB#=DCBNUM(M$IN1);
 
        DO WHILE('1'B);
           ERR_INPUT.DATA=' ';
           CALL M$READ(READ_ERRFILE_S) ALTRET(DONE);
     SIXBIT = ERR_KEY.FCG;
     CALL XLATE_6_TO_9(TEST_KEY.FCG,TRANS_TAB,SIXBIT);
           CALL BINCHAR(TEST_KEY.CODE,ERR_KEY_REDEF.CODE#);
           CALL BINCHAR(TEST_KEY.MESS,ERR_KEY_REDEF.MESS#);
           CALL BINCHAR(TEST_KEY.SEQ,ERR_KEY_REDEF.SEQ#);
           IF TEST_KEY>=KEY1 AND
             TEST_KEY<=KEY2 THEN DO;
              OUTPUT=ERR_INPUT.DATA;
              CALL OUTPUT_KEYS;
              END;
           ELSE IF TEST_KEY>KEY2 THEN RETURN;
           END;
DONE:   ;
END;
%EJECT;
SUB:    PROC;
/*A* SUB: Change some records using string substitution */
 
END;
%EJECT;
CHECK_RANGE: PROC ALTRET;
/*A* CHECK_RANGE: Check key ranges for overflow */
 
        IF K>7 THEN DO;
           OUTPUT='Error, message numbers range from 0-7.';
           CALL M$WRITE(WRITE_DO);
           END;
        IF L>255 THEN DO;
           OUTPUT='Error, sequence numbers range from 0-255.';
           CALL M$WRITE(WRITE_DO);
           END;
        IF K>7 OR
          L>255 THEN ALTRETURN;
END;
%EJECT;
SECURE: PROC;
/*A* SECURE: Make sure that there ar no bogus records in this file that
             could cause a security breach */
 
END;
%EJECT;
UTS:    PROC;
/*A* UTS: Process/check time stamp input */
 
END;
%EJECT;
OUTPUT_KEYS: PROC;
/*A* OUTPUT_KEYS: Print the record with its key */
 
DCL TEXT CHAR(256);
 
DCL FCG CHAR(4);
DCL CODE CHAR(6);
DCL MESS CHAR(1);
DCL SEQ CHAR(3);
DCL TEST_STRING CHAR(13);
DCL MON CHAR(2);
 
     SIXBIT = ERR_KEY.FCG;
     CALL XLATE_6_TO_9(FCG,TRANS_TAB,SIXBIT);
        CALL BINCHAR(CODE,ERR_KEY_REDEF.CODE#);
        CALL BINCHAR(MESS,ERR_KEY_REDEF.MESS#);
        CALL BINCHAR(SEQ,ERR_KEY_REDEF.SEQ#);
        CALL SUPRESS(CODE,6);
        CALL SUPRESS(SEQ,3);
        IF ERR_KEY.MON_BIT THEN MON='M'; /* monitor bit is set                */
        ELSE MON=' ';
        SUBSTR(FCG,3,1)='-';
        IF FCG=OLD_FCG THEN DO;
           OLD_FCG=FCG;
           FCG=' ';
           END;
        ELSE OLD_FCG=FCG;
        IF OLD_CODE=CODE THEN DO;       /* duplicate                          */
           OLD_CODE=CODE;
           CODE=' ';
           END;
        ELSE OLD_CODE=CODE;
        CALL CONCAT(TEST_STRING,CODE,'-',MESS,'-',SEQ,' ');
        CALL CONCAT(TEXT,FCG,MON,TEST_STRING,OUTPUT);
        OUTPUT=TEXT;
        CALL M$WRITE(WRITE_DO);
 
END;
%EJECT;
CHECK_FOR_SUBS: PROC(SIZE);
/*A* CHECK_FOR_SUBS: Check for % character */
 
DCL SIZE UBIN;
DCL I UBIN;
        DO I=0 TO SIZE-1;
           IF SUBSTR(ERR_INPUT.DATA,I,1)=SUBCHAR THEN DO;
              ERR_INPUT.SUBS='1'B;
              RETURN;
              END;
           END;
        ERR_INPUT.SUBS='0'B;
END;
%EJECT;
INVOKE: PROC;
/*A* INVOKE: Start processing a (new) error message file. */
 
        ABORTED_EFM='1'B;               /* by default, none specified         */
        STI_INPUT.SCOMMENT='*NONE*';
        STI_INPUT.PRODUCT='*NONE*';
        STI_INPUT.VERSION='*NONE*';
        STI_INPUT.TIME='*NONE*';
        STI_INPUT.DATE='*NONE';
        STI_INPUT.MARKID='*NONE*';
        STI_INPUT.SCOMMENT='*NONE';
        CALL M$CLOSE(CLOSE);  /* close old error message file, if applicable  */
 
        IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=1 THEN DO; /* no error mess file specified */
           OUTPUT='No error message file specified.';
           CALL M$WRITE(WRITE_DO);
           RETURN;
           END;
        FID_TEXT=P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(1)->
          OUTSYM.TEXT;
        CALL M$FID(FPT_FID)
        WHENALTRETURN DO;
           CALL FTX_RPTERR;
           CALL M$ERR;
           END;
        CALL M$OPEN(OPEN_UPDATE)        /* try and open file update mode      */
        WHENALTRETURN DO;          /* if failure, then try and open input     */
           FLAGS.MODE#='0'B;            /* open input last chance             */
           CALL M$OPEN(OPEN_INPUT)
           WHENALTRETURN DO;
              CALL FTX_RPTERR;
              RETURN;
              END;
           OUTPUT='File opened for input only.';
           CALL M$WRITE(WRITE_DO);
           END;
 
        CALL M$READ(READ_STI)           /* get sti record                     */
        WHENALTRETURN DO;
           OUTPUT='Warniing, File does not contain an STI record';
           CALL M$WRITE(WRITE_DO);
           ABORTED_EFM='0'B;
           RETURN;
           END;
        IF P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.NSUBLKS=3 THEN DO; /* uts has been specified */
           IF STI_INPUT.VERSION~=
             P_PCB.OUT$->OUTBLK.SUBLK$(0)->OUTBLK.SUBLK$(2)->OUTBLK.SUBLK$(0)->OUTSYM.TEXT THEN DO;
              OUTPUT='Error, UTS specified and STI UTS does not match.';
              CALL M$WRITE(WRITE_DO);
              RETURN;
              END;
           END;
        CALL M$READ(READ_ERRFILE_S) ALTRET(TRUNCED); /* find and set monitor bit */
        CALL M$READ(READ_ERRFILE_S) ALTRET(TRUNCED);
        DO WHILE('0'B);
TRUNCED:   OUTPUT='Error, Error message file has been truncated!';
           CALL M$WRITE(WRITE_DO);
           END;
        ABORTED_EFM='0'B;
END;
%EJECT;
SUPRESS: PROC(STRING,SIZE);
/*A* SUPRESS: Supress zeros */
DCL STRING CHAR(SIZE);
DCL SIZE UBIN;
DCL I UBIN;
        DO I=0 TO SIZE-2;
           IF SUBSTR(STRING,I,1)~='0' THEN RETURN;
           ELSE SUBSTR(STRING,I,1)=' ';
           END;
END;
END;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
FTX_RPTERR: PROC;
 
%INCLUDE CP_6;
%F$DCB;
 
%B$ALT;
 
%B$TCB;
 
DCL B$TCB$ PTR SYMREF;
%FPT_ERRMSG(FPTN=ERRBUFFERMSG,
   OUTDCB1=M$DO,
   BUF=ERRBUFFER,
   CODE=ERRCODE,
   INCLCODE=NO);
 
%VLP_ERRCODE(FPTN=ERRCODE,STCLASS=STATIC SYMDEF);
DCL ERRBUFFER CHAR(120) STATIC;
DCL M$DO DCB;
/*F*     NAME: FTX_RPTERR
         PURPOSE: Report ALTRET frame error.
 ***/
 
/********************/
 
        ERRBUFFERMSG.V.DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
        ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
        ERRCODE.SEV = 4;
        CALL M$ERRMSG(ERRBUFFERMSG);
 
END FTX_RPTERR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
WILDCOMP: PROC(WILDSTR,WL,STR,STRSIZ) ALTRET;
 
/* This proc, stolen from SPY.X is used to compare wildstrings to
   accounts. */
DCL WILDSTR CHAR(WL);
DCL STR CHAR(STRSIZ);
DCL STRSIZ UBIN;
DCL WX UBIN;
DCL WL UBIN;
DCL WXP UBIN;
DCL CX UBIN;
DCL CXP UBIN;
/**/
/**/
/**/
        WX=0;
        WXP=WL;
        CX=0;
        CXP=0;
        DO WHILE(WX<WL AND SUBSTR(WILDSTR,WX)~=' '
          OR CX<STRSIZ AND SUBSTR(STR,CX)~=' ');
           IF WX<WL AND SUBSTR(WILDSTR,WX,1)='?' THEN DO;
              WXP=WX;
              END;
           ELSE DO;
              IF WX=WXP+1 THEN CXP=CX;
              IF WX>=WL OR CX>=STRSIZ
                OR SUBSTR(WILDSTR,WX,1) ~= SUBSTR(STR,CX,1) THEN DO;
                 IF WXP=WL OR CXP=STRSIZ THEN ALTRETURN;
                 WX=WXP;
                 CX=CXP;
                 END;
              CX=CX+1;
              END;
           IF WX<WL THEN WX=WX+1;
           END;
        RETURN;
END WILDCOMP;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
BREAK:  PROC ASYNC;
/*A* BREAK: Establish break control for user */
 
DCL REMVAR REMEMBER SYMREF;
DCL PROMPT_C CHAR(14) STATIC INIT('C to continue*');
DCL PROMPT_STAR CHAR(1) STATIC INIT('*');
 
DCL INPUT CHAR(1) STATIC;
DCL M$SI DCB;
 
%INCLUDE CP_6;
%FPT_READ(FPTN=READ_SI,DCB=M$SI,BUF=INPUT);
%FPT_PROMPT(FPTN=PROMPT_S,PROMPT=PROMPT_STAR);
%FPT_PROMPT(FPTN=PROMPT_INPUT,PROMPT=PROMPT_C);
%FPT_TRMPRG(FPTN=TRMPRG,RSTBRK=YES,DCB=M$UC);
 
        CALL M$PROMPT(PROMPT_INPUT);    /* change prompt                      */
        INPUT=' ';
        CALL M$READ(READ_SI);
        CALL M$PROMPT(PROMPT_S);        /* change prompt back to original     */
        CALL M$TRMPRG(TRMPRG);          /* reset break                        */
        IF INPUT='C'
          OR INPUT='c' THEN RETURN;     /* continue what you are doing        */
        ELSE UNWIND TO REMVAR;          /* stop what you are doing            */
 
END BREAK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
INTERNAL_ACCOUNTING: PROC(STRING) ALTRET;
/*A* UPDATE_USECOUNT: Updates the usage count in the run unit being used.
                      Sort of an internal accounting feature. */
 
DCL I UBIN;
DCL M$LM DCB;                           /* run umit opened with this dcb      */
DCL M$RUN DCB;
DCL 1 KEY STATIC,
      2 * UBIN BYTE UNAL INIT(10),
      2 * CHAR(10) INIT('ACCOUNTING');
 
DCL STRING CHAR(60);                    /* fid of run unit being modified     */
DCL DATE CHAR(11) STATIC INIT(' ');
DCL TIME CHAR(12) STATIC INIT(' ');
DCL DAY CHAR(4) STATIC INIT(' ');
DCL FID_TEXT CHAR(60) STATIC;
DCL FID_RES CHAR(4) STATIC;
DCL FID_ASN UBIN(9) STATIC ALIGNED;
 
DCL INPUT CHAR(80) STATIC;              /* input buffer                       */
DCL USE_COUNT UBIN;                     /* use count                          */
 
%INCLUDE CP_6;
%FPT_READ(FPTN=READ_RU,BUF=INPUT,DCB=M$RUN,KEYS=YES,KEY=KEY); /*read run unit key */
%FPT_WRITE(FPTN=WRITE_RU,BUF=INPUT,DCB=M$RUN,KEY=KEY); /*write run unit key   */
%FPT_CLOSE(FPTN=CLOSE,DCB=M$LM,DISP=SAVE);
%FPT_TIME(FPTN=GET_TIME,SOURCE=CLOCK,TIME=TIME,DATE=DATE,DAY=DAY,DEST=EXT);
%FPT_OPEN(FPTN=OPEN_RU,
SHARE=ALL,
DCB=M$RUN,
NAME=VLP_NAME,
ACCT=VLP_ACCT,
PASS=VLP_PASS,
SN=VLP_SN,
WSN=VLP_WSN,
FUN=UPDATE,
ORG=KEYED,
ASN=FILE);
 
%FPT_FID(FPTN=FPT_FID,
NAME=VLP_NAME,
ACCT=VLP_ACCT,
WSN=VLP_WSN,
PASS=VLP_PASS,
SN=VLP_SN,
ASN=FID_ASN,
RES=FID_RES,
RESULTS=VLR_FID,
TEXTFID=FID_TEXT);
%FPT_WAIT(FPTN=WAIT,UNITS=1);
 
        %VLP_NAME;
          %VLP_ACCT;
        %VLP_PASS;
        %VLP_SN;
        %VLR_FID;
        %VLP_WSN;
 
        CALL M$CLOSE(CLOSE);            /* close m$lm so I can open it update */
        CLOSE.V.DCB#=DCBNUM(M$RUN); /* reset dcb so I can close before exiting */
        FID_TEXT=STRING;
        CALL M$FID(FPT_FID)
        WHENALTRETURN DO;
           ALTRETURN;                   /* passed me a bad fid dummy          */
           END;
        CALL M$OPEN(OPEN_RU)
        WHENALTRETURN DO;
           DO I=0 TO 4;
              CALL M$WAIT(WAIT);
              CALL M$OPEN(OPEN_RU)
              WHENRETURN DO;
                 GOTO ACCOUNT;
                 END;
              END;
           ALTRETURN;
           END;
ACCOUNT:INPUT=' ';
        CALL M$READ(READ_RU)
        WHENALTRETURN DO;          /* record did not exist, lets make one     */
           CALL M$TIME(GET_TIME);
           CALL CONCAT(INPUT,'0000000001 ',DAY,DATE,TIME);
           CALL M$WRITE(WRITE_RU);
           CALL M$CLOSE(CLOSE);
           RETURN;
           END;
        CALL CHARBIN(USE_COUNT,SUBSTR(INPUT,0,10));
        USE_COUNT=USE_COUNT+1;
        CALL BINCHAR(SUBSTR(INPUT,0,10),USE_COUNT);
        DO USE_COUNT=0 TO 9;            /* suppress leading zeros             */
           IF SUBSTR(INPUT,USE_COUNT,1)~='0' THEN GOTO WRITE_IT;
           ELSE SUBSTR(INPUT,USE_COUNT,1)=' ';
           END;
WRITE_IT:CALL M$WRITE(WRITE_RU);
        CALL M$CLOSE(CLOSE);
END;
