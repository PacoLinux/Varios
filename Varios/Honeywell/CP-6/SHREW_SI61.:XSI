/*M* SHREW - Main routine for SHREW                               */
/*T***********************************************************/
/*T*                                                         */
/*T* COPYRIGHT, (C) HONEYWELL INFORMATION SYSTEMS INC., 1985 */
/*T*                                                         */
/*T***********************************************************/
/*  Contributed by
        Grand Valley State College  -  J.Lance Wilkinson
         Although this program has been tested by its contributor,
         no warranty, express or implied, is made by the
         contributor or Grand Valley State College, as to the
         accuracy and functioning of the program and related
         program materials, nor shall the fact of distribution
         constitute any such warranty, and no responsibility is
         assumed by the contributor or Grand Valley State College.
 
         The SHREW tool as submitted herein is based upon the WEASEL.X
         tool from Honeywell Information Systems.  The original copyright
         notices are therefore incorporated.
*/
 
/*X* */
SHREW:    PROC MAIN;
/**/
/* INCLUDES FILES */
/**/
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XS_MACRO_C;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6_SUBS;
%INCLUDE SHREW_C600;
%INCLUDE SHREW_C6;
%INCLUDE EL$TABLES;
%INCLUDE EL_SUBS_C;
%INCLUDE ES_TABLES_M;
%INCLUDE ES_SUBS_E;
%INCLUDE UD_EQU_E;
/**/
/* SYMDEFS */
DCL 1 ELF_CONSTRAINTS STATIC SYMDEF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN HALF UNAL INIT(0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL 1 ELF_SAVE STATIC SYMDEF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN HALF UNAL INIT(0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL ELF_ERR_RETURN REMEMBER STATIC SYMDEF;
DCL ELF_BRKMSG BIT(1) ALIGNED STATIC SYMDEF INIT('0'B);
DCL ELF_LASTTYPE SBIN WORD STATIC SYMDEF ALIGNED INIT(-1);
DCL ELF_DATE CHAR(10) STATIC SYMDEF INIT(' ');
DCL ELF_TIME CHAR(11) STATIC SYMDEF INIT(' ');
/**/
/* SYMREFS */
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL ELF_CMD SBIN SYMREF;
DCL ELF_LOGNUM SBIN SYMREF;
DCL TYPE_CMD SBIN SYMREF;
/**/
/* ENTRY DEFINITIONS */
DCL XUR$INIT ENTRY(3) ALTRET;
DCL XUR$GETCMD ENTRY(6) ALTRET;
DCL XUR$SETERRMSG ENTRY(1) ALTRET;
DCL XUR$ERRMSG ENTRY(7) ALTRET;
DCL XUR$ERRPTR ENTRY(2) ALTRET;
DCL SHREW_BRKMSG ENTRY;
DCL SHREW_BREAK ENTRY;
DCL XUR$BREAK ENTRY ASYNC;
/**/
/* DCBS */
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$SECLOG DCB;
/**/
/* CONSTANT DATA */
/**/
/*             CONSTANT FPTS               */
/**/
%FPT_TIME (FPTN=LOCAL,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           DEST=LOCAL,
           DATE=DBUF,
           TIME=TBUF);
%FPT_TIME (FPTN=CUR_DATE,
           STCLASS=CONSTANT,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=CURDATE);
%FPT_TIME (FPTN=ANS_DATE,
           STCLASS=CONSTANT,
           DEST=ANS,
           SOURCE=UTS,
           TSTAMP=CURDATE,
           DATE=ANSDATE);
%FPT_OPEN (FPTN=FIND_FIRST,
           STCLASS=CONSTANT,
           TEST=YES,
           DCB=M$SECLOG,
           NAME=SECLOG,
           ACCT=VLP_SYS,
           NXTF=YES,
           THISF=NO,
           ASN=FILE,
           FUN=IN,
           SHARE=ALL);
%XSA_PARAM (FPTN=SL_XSA_PARAM,
            STCLASS=STATIC);
%FPT_READ (FPTN=READ_CMD,
           STCLASS=CONSTANT,
           BUF=CMD_BUF,
           DCB=M$SI);
%FPT_WRITE (FPTN=ECHO_FPT,
            STCLASS=CONSTANT,
            BUF=CMD_BUF,
            DCB=M$LO);
%FPT_CLOSE (FPTN=CLOSE_LO,
            STCLASS=CONSTANT,
            DCB=M$LO);
%FPT_CLOSE (FPTN=SL_CLOSE_SECLOG,
            STCLASS=CONSTANT,
            DCB=M$SECLOG,
            DISP=SAVE);
%VLP_NAME (FPTN=SECLOG,
           STCLASS=STATIC,
           NAME=':ELFxx780101');
%FPT_MONINFO(FPTN=FPT_MONINFO,
           STCLASS=CONSTANT,
           SITEINFO=VLR_SITEINFO);
%FPT_INT(UENTRY=XUR$BREAK,
         STCLASS=CONSTANT);
/**/
/*           CONSTANT VARIABLES            */
/**/
DCL HI_FMT CHAR(0) CONSTANT INIT(
    '%A is the first available ELF #%2D log %20P');
/**/
/* STATIC DATA */
/**/
/*             STATIC FPTS                  */
/**/
%VLR_SITEINFO;
%FPT_TIME (FPTN=CUR_TIME,
           SOURCE=UTS,
           DEST=EXT,
           TSTAMP=CURDATE,
           TIME=ELF_TIME,
           DATE=ELF_DATE);
%FPT_TIME (FPTN=FIRST_SECLG,
           DEST=UTS,
           TIME=TIME_BUF,
           TSTAMP=SL_FIRST_SECLG,
           SOURCE=ANS);
%FPT_OPEN (FPTN=OPEN_LO,
           DCB=M$LO,
           SCRUB=YES,
           REASSIGN=YES,
           STCLASS=STATIC);
%FPT_OPEN (FPTN=SL_OPEN_SECLOG,
           STCLASS=STATIC,
           ACS=SEQUEN,
           NAME=SL_VLP_SECLOG,
           ACCT=VLP_SYS,
           ASN=FILE,
           FUN=IN,
           DCB=M$SECLOG,
           SHARE=ALL);
%VLP_NAME (FPTN=SL_VLP_SECLOG,
           STCLASS=STATIC,
           NAME=':ELFnn??????',
           LEN=12);
%FPT_UNFID(FPTN=ERRMSG_UNFID,
           TEXTFID=SL_SITE_NAME.C,
           LEN=CURDATE);
/**/
/*           STATIC VARIABLES              */
/**/
DCL  LOG#  STATIC SYMDEF UBIN WORD INIT(0);
DCL 1 LTBL STATIC SYMDEF ALIGNED,
     2 MAX# UBIN WORD UNAL INIT(0),
     2 TBL (0:%MAX_TYPES),
      3 TYPE UBIN BYTE UNAL INIT(0*0),
      3 TEXT CHAR(23) UNAL INIT(' '*0),
      3 COUNT UBIN WORD INIT(0*0);
DCL 1 PRMT STATIC,
     2 * CHAR(3) INIT('ELF'),
     2 LOG# CHAR(2),
     2 * CHAR(1) INIT(':');
DCL P_PCB$ PTR STATIC INIT(ADDR(P_PCB));
DCL 1 SL_DEFAULT STATIC DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN HALF UNAL INIT(%ALL,0*0),
     2 START UBIN WORD ALIGNED INIT(0),
     2 STOP UBIN WORD ALIGNED INIT(BITBIN('377777777777'O));
DCL 1 SL_ERRCODE STATIC ALIGNED,
     2 FCG BIT(18) UNAL,
     2 MON BIT(1)  UNAL,
     2 CODE UBIN(14) UNAL,
     2 SEV UBIN(3) UNAL;
DCL SL_CPOS SBIN STATIC INIT(-1);
DCL SL_ENDFLAG BIT(1) ALIGNED STATIC INIT('0'B);
DCL SL_CURDATE UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_FIRST_SECLG UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_BOF BIT(1) ALIGNED STATIC INIT('1'B);
DCL SL_LASTUTS UBIN WORD STATIC ALIGNED INIT(0);
DCL SL_DAY CHAR(3) STATIC;
DCL SL_SITE_ID CHAR(6) STATIC ALIGNED INIT(' ');
DCL 1 SL_SITE_NAME STATIC ALIGNED,
      2 L UBIN BYTE UNAL INIT(0),
      2 C CHAR(119) UNAL INIT(' ');
DCL SL_XSA_BUF_VECTOR VECTOR STATIC INIT(VECTOR(NIL));
DCL 1 SL_XSA_BUF REDEF SL_XSA_BUF_VECTOR,
      2 * UBIN,
      2 P$ PTR;
DCL SL_M$SECLOG$ PTR STATIC;
%VLP_ACCT(FPTN=VLP_SYS,
          ACCT=':SYS',
          STCLASS=STATIC);
DCL SL_CHANGE_ACCOUNT BIT(1) ALIGNED STATIC INIT('1'B);
DCL ANSDATE CHAR(6) STATIC;
DCL CURDATE UBIN WORD STATIC;
DCL FIRST_DATE CHAR(6) STATIC;
DCL TIME_BUF CHAR(8) STATIC INIT('00000000');
DCL TBUF CHAR(5) STATIC;
DCL DBUF CHAR(8) STATIC;
DCL CMD_BUF CHAR(256) STATIC;
DCL HI_VEC VECTOR STATIC INIT(VECTOR(HI_FMT));
DCL SL_OUTBUF CHAR(133) STATIC INIT(' ');
/**/
/* AUTO DATA */
/**/
DCL I UBIN;
DCL INDX UBIN;
DCL CODE UBIN;
DCL NDAYS UBIN WORD;
DCL NAMEBUF CHAR(13);
DCL TOP$ PTR;
DCL PARSE_CODE REDEF TOP$ BIT(36);
DCL LMDCB$ PTR;
DCL WORK_ACCT CHAR(8) STATIC INIT(':SYS');
DCL ELF$ PTR;
/**/
/* MACRO INVOCATIONS */
%P_PCB (STCLASS=STATIC);
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(TOP$)");
%P$NODE (NAME=P$NODE,STCLASS="BASED(TOP$)");
DCL 1 ELF_NODE1 STATIC ALIGNED,
     2 * BIT(36),              /* Header of P$NODE structure */
     2 SUBNDS$ (0:2)  PTR;     /* 3 subnodes in ELF_CMD */
DCL 1 ELF_NODE2 STATIC ALIGNED,
     2 * BIT(36),              /* Header of P$NODE structure */
     2 SUBNDS$ (0:6)  PTR;     /* 7 subnodes: the commands */
%F$DCB;
%B$TCB;
%B$ALT;
%XUR_INIT (ABORT=SHREW_BREAK,BRKMSG=SHREW_BRKMSG,PCB=P_PCB);
%LIST;
%EL$HDR(NAME=SL_RECORD_BUF,STCLASS=STATIC,HDRONLY=YES,FILE=FILENUM);
      2 INFO(0:999)    UBIN WORD INIT(0*0);
%PLIST;
/*  Customization Procedures */
DCL ELF$$(0:99) STATIC EPTR INIT(ENTADDR(NIL)*4,ENTADDR(ELF04),ENTADDR(ELF05),
               ENTADDR(ELF06),ENTADDR(ELF07),ENTADDR(ELF08),ENTADDR(ELF09),
               ENTADDR(ELF10),ENTADDR(ELF11),ENTADDR(ELF12),ENTADDR(ELF13),
               ENTADDR(ELF14),ENTADDR(ELF15),ENTADDR(ELF16),ENTADDR(ELF17),
               ENTADDR(ELF18),ENTADDR(ELF19),
               ENTADDR(ELF20),ENTADDR(ELF21),ENTADDR(ELF22),ENTADDR(ELF23),
               ENTADDR(ELF24),ENTADDR(ELF25),ENTADDR(ELF26),ENTADDR(ELF27),
               ENTADDR(ELF28),ENTADDR(ELF29),
               ENTADDR(ELF30),ENTADDR(ELF31),ENTADDR(ELF32),ENTADDR(ELF33),
               ENTADDR(ELF34),ENTADDR(ELF35),ENTADDR(ELF36),ENTADDR(ELF37),
               ENTADDR(ELF38),ENTADDR(ELF39),
               ENTADDR(ELF40),ENTADDR(ELF41),ENTADDR(ELF42),ENTADDR(ELF43),
               ENTADDR(ELF44),ENTADDR(ELF45),ENTADDR(ELF46),ENTADDR(ELF47),
               ENTADDR(ELF48),ENTADDR(ELF49),
               ENTADDR(ELF50),ENTADDR(ELF51),ENTADDR(ELF52),ENTADDR(ELF53),
               ENTADDR(ELF54),ENTADDR(ELF55),ENTADDR(ELF56),ENTADDR(ELF57),
               ENTADDR(ELF58),ENTADDR(ELF59),
               ENTADDR(ELF60),ENTADDR(ELF61),ENTADDR(ELF62),ENTADDR(ELF63),
               ENTADDR(ELF64),ENTADDR(ELF65),ENTADDR(ELF66),ENTADDR(ELF67),
               ENTADDR(ELF68),ENTADDR(ELF69),
               ENTADDR(ELF70),ENTADDR(ELF71),ENTADDR(ELF72),ENTADDR(ELF73),
               ENTADDR(ELF74),ENTADDR(ELF75),ENTADDR(ELF76),ENTADDR(ELF77),
               ENTADDR(ELF78),ENTADDR(ELF79),
               ENTADDR(ELF80),ENTADDR(ELF81),ENTADDR(ELF82),ENTADDR(ELF83),
               ENTADDR(ELF84),ENTADDR(ELF85),ENTADDR(ELF86),ENTADDR(ELF87),
               ENTADDR(ELF88),ENTADDR(ELF89),
               ENTADDR(ELF90),ENTADDR(ELF91),ENTADDR(ELF92),ENTADDR(ELF93),
               ENTADDR(ELF94),ENTADDR(ELF95),ENTADDR(ELF96),ENTADDR(ELF97),
               ENTADDR(ELF98),ENTADDR(ELF99));
DCL ELF04 ENTRY (3) OPTIONAL;
DCL ELF05 ENTRY (3) OPTIONAL;
DCL ELF06 ENTRY (3) OPTIONAL;
DCL ELF07 ENTRY (3) OPTIONAL;
DCL ELF08 ENTRY (3) OPTIONAL;
DCL ELF09 ENTRY (3) OPTIONAL;
DCL ELF10 ENTRY (3) OPTIONAL;
DCL ELF11 ENTRY (3) OPTIONAL;
DCL ELF12 ENTRY (3) OPTIONAL;
DCL ELF13 ENTRY (3) OPTIONAL;
DCL ELF14 ENTRY (3) OPTIONAL;
DCL ELF15 ENTRY (3) OPTIONAL;
DCL ELF16 ENTRY (3) OPTIONAL;
DCL ELF17 ENTRY (3) OPTIONAL;
DCL ELF18 ENTRY (3) OPTIONAL;
DCL ELF19 ENTRY (3) OPTIONAL;
DCL ELF20 ENTRY (3) OPTIONAL;
DCL ELF21 ENTRY (3) OPTIONAL;
DCL ELF22 ENTRY (3) OPTIONAL;
DCL ELF23 ENTRY (3) OPTIONAL;
DCL ELF24 ENTRY (3) OPTIONAL;
DCL ELF25 ENTRY (3) OPTIONAL;
DCL ELF26 ENTRY (3) OPTIONAL;
DCL ELF27 ENTRY (3) OPTIONAL;
DCL ELF28 ENTRY (3) OPTIONAL;
DCL ELF29 ENTRY (3) OPTIONAL;
DCL ELF30 ENTRY (3) OPTIONAL;
DCL ELF31 ENTRY (3) OPTIONAL;
DCL ELF32 ENTRY (3) OPTIONAL;
DCL ELF33 ENTRY (3) OPTIONAL;
DCL ELF34 ENTRY (3) OPTIONAL;
DCL ELF35 ENTRY (3) OPTIONAL;
DCL ELF36 ENTRY (3) OPTIONAL;
DCL ELF37 ENTRY (3) OPTIONAL;
DCL ELF38 ENTRY (3) OPTIONAL;
DCL ELF39 ENTRY (3) OPTIONAL;
DCL ELF40 ENTRY (3) OPTIONAL;
DCL ELF41 ENTRY (3) OPTIONAL;
DCL ELF42 ENTRY (3) OPTIONAL;
DCL ELF43 ENTRY (3) OPTIONAL;
DCL ELF44 ENTRY (3) OPTIONAL;
DCL ELF45 ENTRY (3) OPTIONAL;
DCL ELF46 ENTRY (3) OPTIONAL;
DCL ELF47 ENTRY (3) OPTIONAL;
DCL ELF48 ENTRY (3) OPTIONAL;
DCL ELF49 ENTRY (3) OPTIONAL;
DCL ELF50 ENTRY (3) OPTIONAL;
DCL ELF51 ENTRY (3) OPTIONAL;
DCL ELF52 ENTRY (3) OPTIONAL;
DCL ELF53 ENTRY (3) OPTIONAL;
DCL ELF54 ENTRY (3) OPTIONAL;
DCL ELF55 ENTRY (3) OPTIONAL;
DCL ELF56 ENTRY (3) OPTIONAL;
DCL ELF57 ENTRY (3) OPTIONAL;
DCL ELF58 ENTRY (3) OPTIONAL;
DCL ELF59 ENTRY (3) OPTIONAL;
DCL ELF60 ENTRY (3) OPTIONAL;
DCL ELF61 ENTRY (3) OPTIONAL;
DCL ELF62 ENTRY (3) OPTIONAL;
DCL ELF63 ENTRY (3) OPTIONAL;
DCL ELF64 ENTRY (3) OPTIONAL;
DCL ELF65 ENTRY (3) OPTIONAL;
DCL ELF66 ENTRY (3) OPTIONAL;
DCL ELF67 ENTRY (3) OPTIONAL;
DCL ELF68 ENTRY (3) OPTIONAL;
DCL ELF69 ENTRY (3) OPTIONAL;
DCL ELF70 ENTRY (3) OPTIONAL;
DCL ELF71 ENTRY (3) OPTIONAL;
DCL ELF72 ENTRY (3) OPTIONAL;
DCL ELF73 ENTRY (3) OPTIONAL;
DCL ELF74 ENTRY (3) OPTIONAL;
DCL ELF75 ENTRY (3) OPTIONAL;
DCL ELF76 ENTRY (3) OPTIONAL;
DCL ELF77 ENTRY (3) OPTIONAL;
DCL ELF78 ENTRY (3) OPTIONAL;
DCL ELF79 ENTRY (3) OPTIONAL;
DCL ELF80 ENTRY (3) OPTIONAL;
DCL ELF81 ENTRY (3) OPTIONAL;
DCL ELF82 ENTRY (3) OPTIONAL;
DCL ELF83 ENTRY (3) OPTIONAL;
DCL ELF84 ENTRY (3) OPTIONAL;
DCL ELF85 ENTRY (3) OPTIONAL;
DCL ELF86 ENTRY (3) OPTIONAL;
DCL ELF87 ENTRY (3) OPTIONAL;
DCL ELF88 ENTRY (3) OPTIONAL;
DCL ELF89 ENTRY (3) OPTIONAL;
DCL ELF90 ENTRY (3) OPTIONAL;
DCL ELF91 ENTRY (3) OPTIONAL;
DCL ELF92 ENTRY (3) OPTIONAL;
DCL ELF93 ENTRY (3) OPTIONAL;
DCL ELF94 ENTRY (3) OPTIONAL;
DCL ELF95 ENTRY (3) OPTIONAL;
DCL ELF96 ENTRY (3) OPTIONAL;
DCL ELF97 ENTRY (3) OPTIONAL;
DCL ELF98 ENTRY (3) OPTIONAL;
DCL ELF99 ENTRY (3) OPTIONAL;
DCL ELF00 ENTRY (3);
DCL ELFNN$$ EPTR;
/**/
%EJECT;
        CALL XUR$INIT(XUR_INIT,P_PCB$);
        /* The errmsg file is part of the run unit. But this RU may
           not always be run from the .X account, so we need to
           find out where we're coming from. Also reusing some
           variables to do this for convenience.                  */
        LMDCB$ = DCBADDR(%M$LM#);
        ERRMSG_UNFID.V.DCB# = %M$LM#;
        CALL M$UNFID(ERRMSG_UNFID);
        SL_SITE_NAME.L = CURDATE;
        CALL XUR$SETERRMSG(SL_SITE_NAME);
        CALL M$TIME(CUR_DATE);
        CALL M$TIME(CUR_TIME);
        SL_CURDATE = CURDATE;
        NDAYS = CURDATE/%TICS_PER_DAY;
        SL_DEFAULT.START = NDAYS * %TICS_PER_DAY;
        SL_DEFAULT.STOP = SL_DEFAULT.START + %TICS_PER_DAY - 1;
        ELF_CONSTRAINTS = SL_DEFAULT;
        CALL M$MONINFO(FPT_MONINFO);
        SL_SITE_ID = VLR_SITEINFO.SITE_ID#;
        SL_SITE_NAME = VLR_SITEINFO.SITE_NAME#;
        SL_ENDFLAG = %NO;
        REMEMBER RET_LBL IN ELF_ERR_RETURN;
        CALL M$INT(FPT_INT);
                                        /* CALL COMMAND DRIVER                */
        DO WHILE(NOT SL_ENDFLAG);
              IF LOG#>3 THEN GOTO SHREW_2;
              I=B$JIT.CCARS;
              CALL XUR$GETCMD(ELF_LOGNUM,TOP$,,B$JIT.CCBUF,I)ALTRET(SHREW_1);
              CALL CHARBIN(LOG#,OUT$BLK.SUBLK$(1)->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
              IF LOG#<4 THEN DO;
     SHREW_1:    CALL ERRMSG( %E$BAD_LOG_NUMBER );
                 /*E* ERROR:   SL-E$BAD_LOG_NUMBER-0
                      MESSAGE: A log number between 4 thru 99 is required.
                 */
                 CALL M$EXIT;
                 END;
                 ELSE CALL BINCHAR(PRMT.LOG#,LOG#);
              IF OUT$BLK.SUBLK$(1)->OUT$BLK.NSUBLKS>1 THEN
                   DO;
                   VLP_SYS.ACCT# = OUT$BLK.SUBLK$(1)->
                                   OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT;
                   WORK_ACCT = VLP_SYS.ACCT#;
                   END;
             TOP$ = ADDR(ELF_CMD);   /* Copy node for ELF_CMD */
             ELF_NODE1 = P$NODE;
             DO I = 0 TO P$NODE.NSUBNDS-1;
              ELF_NODE1.SUBNDS$(I) = P$NODE.SUBNDS$(I);
             END;
             TOP$ = ELF_NODE1.SUBNDS$(1); /* copy subnode for commands */
             IF ELF$$(LOG#)~=ENTADDR(NIL) THEN
                DO;
                ELFNN$$ = ELF$$(LOG#);
                CALL ELFNN$$ (4,ELF$);
                END;
                ELSE ELF$ = ADDR(TYPE_CMD);
             ELF_NODE1.SUBNDS$(1) = ADDR(ELF_NODE2); /* substitute */
             ELF_NODE2 = P$NODE;    /* Copy node of commands */
             DO I = 0 TO P$NODE.NSUBNDS-1;
              ELF_NODE2.SUBNDS$(I) = P$NODE.SUBNDS$(I);
              IF ELF_NODE2.SUBNDS$(I) = ADDR(TYPE_CMD)
                 THEN ELF_NODE2.SUBNDS$(I) = ELF$;
             END;
     SHREW_2:
           IF SL_CHANGE_ACCOUNT THEN
           DO;
              CALL M$TIME(ANS_DATE);
              CALL CONCAT(NAMEBUF,':ELF',PRMT.LOG#,ANSDATE);
              SL_OPEN_SECLOG.V.SHARE# = %ALL#;
              SL_VLP_SECLOG.NAME# = NAMEBUF;
              SL_M$SECLOG$ = DCBADDR(DCBNUM(M$SECLOG));
              CALL M$OPEN(SL_OPEN_SECLOG) ALTRET(OPEN_ERR);
              DO NEVER;                 /* OPEN ERROR HANDLING                */
OPEN_ERR:        CALL ERRMSG;
                 END;                   /* DO NEVER                           */
              CALL M$CLOSE(SL_CLOSE_SECLOG);
 
                                        /* LOOK FOR FIRST AVAIL. :ELFnn FILE */
              SUBSTR(SECLOG.NAME#,4,2) = PRMT.LOG#;
              CALL M$OPEN(FIND_FIRST) ALTRET(NO_SECLOG_FILES);
              IF SL_M$SECLOG$->F$DCB.NAME#.L~=LENGTHC(':ELFnnyymmdd')
                 THEN GOTO NO_SECLOG_FILES;
              NAMEBUF = SL_M$SECLOG$->F$DCB.NAME#.C;
              IF SUBSTR(NAMEBUF,0,4) ~= ':ELF' THEN GOTO NO_SECLOG_FILES;
              IF SUBSTR(NAMEBUF,4,2) ~= PRMT.LOG# THEN GOTO NO_SECLOG_FILES;
              FIRST_DATE = SUBSTR(NAMEBUF,LENGTHC(':ELFnn'),6);
              FIRST_SECLG.DATE_ = VECTOR(FIRST_DATE);
              CALL M$TIME(FIRST_SECLG) ALTRET(NO_SECLOG_FILES);
              CALL WRITE_IT(HI_VEC,VECTOR(NAMEBUF),VECTOR(LOG#));
              SL_CHANGE_ACCOUNT = '0'B;
 
              DO NEVER;
NO_SECLOG_FILES: ;
                 CALL ERRMSG( %E$NO_ELFLOG_FILES );
                 /*E* ERROR:   SL-E$NO_ELFLOG_FILES-0
                      MESSAGE: The USE account contains no ELF log files
                 */
                 END;
              END;
              CALL XUR$GETCMD(ELF_NODE1,TOP$,VECTOR(PRMT)) ALTRET(PARSE_ERR);
              DO CASE(OUT$BLK.CODE);
               CASE(%END_CMD);
                 SL_ENDFLAG = %YES;
               CASE(%REPORT_CMD);
                 CALL REPORT;
               CASE(%SPAN_CMD);
                 CALL SPAN ALTRET(RET_LBL);
               CASE(%NULL_CMD);
               CASE(%USE_CMD);
                 IF OUT$BLK.NSUBLKS <= 0
                 THEN DO;
                    VLP_SYS.ACCT# = B$JIT.FACCN;
                    SL_CHANGE_ACCOUNT = '1'B;
                    END;
                 ELSE DO;
                    IF OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT > 8
                    THEN DO;
                       CALL ERRMSG(%E$BAD_ACCT);
                       /*E* ERROR:   SL-E$BAD_ACCT-0
                            MESSAGE: Bad account specification
                       */
                       SL_CHANGE_ACCOUNT = '0'B;
                       END;
                    ELSE DO;
                       VLP_SYS.ACCT# = OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
                       SL_CHANGE_ACCOUNT = '1'B;
                       END;
                    END;
               CASE(%TYPE_CMD);
                 ELF_CONSTRAINTS.TYPES='0'B;
                 DO I = 0 TO OUT$BLK.NSUBLKS-1;
                    CODE=OUT$BLK.SUBLK$(I)->OUT$BLK.CODE;
                    IF CODE=600 THEN
             SHREW_4: DO;
                      CALL CHARBIN(CODE,OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)
                                                ->OUT$SYM.TEXT);
                      IF CODE>511 THEN GOTO PARSE_ERR;
                      IF OUT$BLK.SUBLK$(I)->OUT$BLK.NSUBLKS=2 THEN
               SHREW_5: DO;
               SHREW_6: DO INDX=0 TO LTBL.MAX# - 1;
                          IF LTBL.TBL.TYPE(INDX)=CODE THEN
                   SHREW_7: DO;
                            LTBL.TBL.TEXT(INDX)=OUT$BLK.SUBLK$(I)
                                                ->OUT$BLK.SUBLK$(1)
                                                  ->OUT$SYM.TEXT;
                            LTBL.TBL.COUNT(INDX)=OUT$BLK.SUBLK$(I)
                                                ->OUT$BLK.SUBLK$(1)
                                                  ->OUT$SYM.COUNT;
                            EXIT SHREW_4;
                            END SHREW_7;
                         END SHREW_6;
                         INDX = LTBL.MAX#; /* Must add to table */
                         LTBL.MAX# = LTBL.MAX# + 1;
                         LTBL.TBL.TYPE(INDX) = CODE;
                         GOTO SHREW_7;
                         END SHREW_5;
                        END SHREW_4;
                    INDX=CODE-%TYPE_LO;
                    IF CODE=%ALL THEN ELF_CONSTRAINTS.TYPES(0)=CODE;
                                 ELSE ELF_CONSTRAINTS.TYPES(INDX)=CODE;
                    END;
               CASE(%RESET_CMD);
                 IF OUT$BLK.NSUBLKS=0 OR OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%ALL
                 THEN DO;
                    ELF_CONSTRAINTS=SL_DEFAULT;
                    LTBL.MAX# = 0;
                    VLP_SYS.ACCT#=WORK_ACCT;
                    SL_CHANGE_ACCOUNT='1'B;
                    END;
                 ELSE DO I=0 TO OUT$BLK.NSUBLKS-1;
                    DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
                     CASE(%USE);
                       VLP_SYS.ACCT#=WORK_ACCT;
                       SL_CHANGE_ACCOUNT='1'B;
                     CASE(%SPAN);
                       ELF_CONSTRAINTS.START=SL_DEFAULT.START;
                       ELF_CONSTRAINTS.STOP=SL_DEFAULT.STOP;
                     CASE(%TYPE);
                       ELF_CONSTRAINTS.TYPES = SL_DEFAULT.TYPES;
                       LTBL.MAX# = 0;
                     END;
                    END;
               END;                     /* DO CASE                            */
RET_LBL:
           CALL CLOSEXSA;
           DO NEVER;                    /* PARSE ERROR HANDLING               */
PARSE_ERR:    SL_ERRCODE = PARSE_CODE;
              IF NOT SL_ERRCODE.MON
                 THEN SL_CPOS = P_PCB.HI_CHAR;
                 ELSE SL_ENDFLAG = %YES;
              IF SL_ERRCODE.FCG = '302522'O  /* 'XUR' */ AND SL_ERRCODE.CODE = 1
              THEN DO;
                 SL_ERRCODE = '231400000000'O;
                 IF SL_CPOS = 0
                 THEN DO;
                    SL_ERRCODE.CODE = %E$CMD_ERR;
                    SL_CPOS = -1;
                    /*E* ERROR:   SL-E$CMD_ERR-0
                         MESSAGE: Unknown command
                    */
                    END;
                 ELSE DO;
                    SL_ERRCODE.CODE = %E$SYNTAX_ERR;
                    /*E* ERROR:   SL-E$SYNTAX_ERR-0
                         MESSAGE: Syntax error
                    */
                    END;
                 END;                   /* IF FCG = 'XUR' AND CODE = 1        */
              IF SL_CPOS >= 0 THEN
                 CALL XUR$ERRPTR(SL_CPOS,DCBNUM(M$DO));
              SL_CPOS = -1;
              CALL XUR$ERRMSG(SL_ERRCODE,DCBNUM(M$SI),DCBNUM(M$DO));
              END;                      /* DO NEVER                           */
           END;                         /* DO WHILE NOT SL_ENDFLAG            */
        CALL M$EXIT;
%EJECT;
REPORT: PROC;
/**/
/* VARIABLES */
/**/
DCL LO_REASSIGNED BIT(1) ALIGNED STATIC INIT('0'B);
DCL TEXT$ PTR;
DCL TEXTBUF CHAR(132) STATIC INIT(' ');
DCL 1 TVEC_,
      2 BOUND UBIN(20) UNAL,
      2 * BIT(16),
      2 PTR$ PTR;
DCL TEMP_BUF CHAR(132) STATIC INIT(' ');
DCL TEMP_BUF2 CHAR(132);
DCL BUF_COUNT UBIN;
DCL DBUF2 CHAR(8) STATIC;
DCL TBUF2 CHAR(11) STATIC;
DCL LOC_UTS UBIN WORD STATIC;
DCL SYM$ PTR;
DCL M$LO$ PTR;
DCL I SBIN;
DCL K SBIN;
DCL SUM_CLAUSE_FLG BIT(1) ALIGNED;
DCL DIST_INTVL UBIN;
DCL DIST_UNITS UBIN;
DCL DIST_TICS UBIN;
DCL DIST_MAX UBIN;
DCL DISTRIBUTION (0:98) UBIN;
DCL NUM_RECS SBIN;
DCL NUM_TYPES SBIN;
DCL TYPES(0:%MAX_TYPES) UBIN HALF;
DCL RECORD_TYPE UBIN;
DCL TYPE_CNT(0:%MAX_TYPES) UBIN;
DCL COUNT UBIN WORD;
DCL REPORT_CODE UBIN;
DCL LO_ASN UBIN(9) STATIC;
DCL LO_RES CHAR(4) STATIC;
DCL SECLOG_DATE UBIN WORD STATIC;
DCL DAY_BUF CHAR(3) STATIC;
DCL EOF_FLAG BIT(1) ALIGNED;
DCL DATE_BUF CHAR(10) STATIC;
DCL TYPE_FMT CHAR(0) CONSTANT INIT(
'TYPES: %T%20P');
DCL SUM_FMT CHAR(0) CONSTANT INIT(
'%2/SUMMARY%2/TYPE  (MNEMONIC)%38-COUNT%/------------------------------------ -----%20P');
DCL SUM_ENTRY CHAR(0) CONSTANT INIT(
'%T%38-%2P%5D%20P');
DCL SUM_TOT  CHAR(0) CONSTANT INIT(
'%2/TOTAL: %D%20P');
DCL RAW_HDR CHAR(0) CONSTANT INIT(
'ELF #%2D Listing for %3P%T from %4P%14.36.2U to %5P%14.36.2U%20P');
DCL SUM_HDR CHAR(0) CONSTANT INIT(
'ELF #%2D Summary for %3P%T from %4P%14.36.2U to %5P%14.36.2U%20P');
DCL HDR_VEC_ VECTOR;
DCL DATE_HDR CHAR(0) CONSTANT INIT('%2/ ***** %A %2P%A ***** %/%20P');
DCL DATE_FMT VECTOR STATIC INIT(VECTOR(DATE_HDR));
DCL 1 DIST_HDR CONSTANT,
    2 * CHAR(0) INIT('%/%5XTime Distribution%/'),
    2 * CHAR(0) INIT('%5X* = %D occurrences of selected types%/'),
    2 * CHAR(0) INIT('%5X%D subspans representing %<>T%S each%/%/'),
    2 * CHAR(0) INIT('%8..1U%N(  %) %8..1U%/'),
    2 * CHAR(0) INIT('  %6..0U%N(  %) %6..0U%/'),
    2 * CHAR(0) INIT('Events /%N(-+%)-\%20P');
DCL DIST_FMT CONSTANT CHAR(0) INIT('%*6D |%NA |%20P');
DCL 1 DIST_END CONSTANT,
    2 * CHAR(0) INIT('       \%N(-+%)-/%/'),
    2 * CHAR(0) INIT('  %6..0U%N(  %) %6..0U%/'),
    2 * CHAR(0) INIT('%8..1U%N(  %) %8..1U%/'),
    2 * CHAR(0) init('SubSpan     SubSpan      Total%/'),
    2 * CHAR(0) init('Number    Date   Time   Events%20P');
DCL DIST_SUM CONSTANT CHAR(0) INIT('%5D%9-%14.36.2U%25-%*6D%20P');
%XUD_PARAM (SIZE=63,TIMESPAN=YES,TEXTC=YES);
DCL XUD$UTS_CHAR ENTRY(3) ALTRET;
/**/
/* MACRO INVOCATIONS */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=RECORD_DATE,
           SOURCE=UTS,
           DEST=EXT,
           DATE=ELF_DATE,
           TIME=ELF_TIME,
           DAY=SL_DAY,
           TSTAMP=SL_LASTUTS,
           STCLASS=CONSTANT);
%FPT_TIME (FPTN=EXT_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=SECLOG_DATE,
           DEST=EXT,
           DATE=DATE_BUF,
           DAY=DAY_BUF);
%FPT_TIME (FPTN=LOC_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=LOC_UTS,
           DATE=DBUF2,
           TIME=TBUF2,
           DEST=LOCAL);
%FPT_OPEN (FPTN=REP_LO_UR,
           STCLASS=CONSTANT,
           DCB=M$LO,
            HDR=LO_HEADER,
           FUN=CREATE,
           SCRUB=YES,
           ORG=UR,
           REASSIGN=YES);
%FPT_OPEN (FPTN=REP_LO_CONSEC,
           STCLASS=CONSTANT,
           DCB=M$LO,
           FUN=CREATE,
           SCRUB=YES,
           ORG=CONSEC,
           REASSIGN=YES);
%FPT_OPEN (FPTN=REP_LO);
%FPT_CLOSE (FPTN=CLOSE_LO,
            STCLASS=CONSTANT,
            DISP=SAVE,
            DCB=M$LO);
%FPT_FID (NAME=LO_NAME,
          ACCT=LO_ACCT,
          PASS=LO_PASS,
          WSN=LO_WSN,
          SN=LO_SN,
          ASN=LO_ASN,
          RES=LO_RES,
          RESULTS=LO_RESULTS);
%VLP_NAME (FPTN=LO_NAME,LEN=31);
%VLP_ACCT (FPTN=LO_ACCT);
%VLP_PASS (FPTN=LO_PASS);
%VLP_WSN (FPTN=LO_WSN);
%VLP_SN (FPTN=LO_SN);
%VLR_FID (FPTN=LO_RESULTS);
%VLP_HDR (FPTN=LO_HEADER,
         STCLASS=STATIC,
         COUNT=107,
         HEADERHEIGHT=2,
         TITLE=' ',
         RESETPAGE=YES,
         LEN=106);
        M$LO$ = DCBADDR(DCBNUM(M$LO));
        LO_REASSIGNED = %NO;
        IF M$LO$->F$DCB.FCD# THEN
           CALL M$CLOSE(CLOSE_LO);
        SUM_CLAUSE_FLG = %NO;
        IF ELF$$(LOG#) ~= ENTADDR(NIL)
                 THEN DO;
                 ELFNN$$ = ELF$$(LOG#);
                 CALL  ELFNN$$ (5,ADDR(NIL));
                 END;
        REPORT_CODE = OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
        DO I = 1 TO OUT$BLK.NSUBLKS - 1;
           DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
            CASE(%DIST_CLAUSE);
              CALL CHARBIN (DIST_UNITS,OUT$BLK.SUBLK$(I)
                                ->OUT$BLK.SUBLK$(1)->OUT$SYM.TEXT);
              CALL CHARBIN (DIST_INTVL,OUT$BLK.SUBLK$(I)
                                ->OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
              IF DIST_INTVL < 1 THEN  DIST_INTVL =
                             (M$LO$->F$DCB.WIDTH# - 20)/2;
              IF DIST_UNITS < 1 THEN  DIST_UNITS = 1;
              DO K = 0 TO 98;
                 DISTRIBUTION(K) = 0;
              END;
            CASE(%FOR_CLAUSE);
              IF ELF$$(LOG#) ~= ENTADDR(NIL)
                 THEN DO;
                 ELFNN$$ = ELF$$(LOG#);
                 CALL  ELFNN$$ (5, OUT$BLK.SUBLK$(I));
                 END;
            CASE(%SUM_CLAUSE);
              SUM_CLAUSE_FLG = %YES;
            CASE(%ON_CLAUSE);
              SYM$ = OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1);
              FPT_FID.TEXTFID_ = VECTOR(OUT$SYM.TEXT);
              CALL M$FID(FPT_FID) ALTRET(FID_ERR);
              REP_LO = REP_LO_UR;
              REP_LO.V_ = VECTOR(REP_LO.V);
              REP_LO.V.EXIST# = OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
              REP_LO.NAME_ = VECTOR(LO_NAME);
              REP_LO.ACCT_ = VECTOR(LO_ACCT);
              REP_LO.PASS_ = VECTOR(LO_PASS);
              REP_LO.SN_ = VECTOR(LO_SN);
              REP_LO.WSN_ = VECTOR(LO_WSN);
              REP_LO.V.RES# = LO_RES;
              REP_LO.V.ASN# = LO_ASN;
              LO_REASSIGNED = %YES;
            END;                        /* CASE                   */
           END;                         /* DO I                               */
           IF REPORT_CODE = %SUM
              THEN HDR_VEC_ = VECTOR(SUM_HDR);
              ELSE HDR_VEC_ = VECTOR(RAW_HDR);
           CALL WRITE_IT(HDR_VEC_,VECTOR(LOG#),
                         VECTOR(SL_SITE_ID),
                         VECTOR(SL_SITE_NAME),
                         VECTOR(ELF_CONSTRAINTS.START),
                         VECTOR(ELF_CONSTRAINTS.STOP));
        IF LO_REASSIGNED THEN DO;
              SL_OUTBUF=SUBSTR(SL_OUTBUF,1);
              CALL INSERT(LO_HEADER.TITL.TITLE#,0,100,SL_OUTBUF);
              CALL INSERT(LO_HEADER.TITL.TITLE#,101, ,'PAGE');
              LO_HEADER.TITL.L# = LENGTHC(LO_HEADER.TITL.TITLE#);
           CALL M$CLOSE(CLOSE_LO);
           CALL M$OPEN(REP_LO) ALTRET(OPN_ERR);
           END;
        ELF_SAVE = ELF_CONSTRAINTS;
           TEXT$ = ADDR(TEXTBUF);
           BUF_COUNT = 0;
           DO I = 0 TO %MAX_TYPES;
              IF ELF_CONSTRAINTS.TYPES(I) ~= 0 THEN DO;
                 CALL TYPENAME(ELF_CONSTRAINTS.TYPES(I),TEMP_BUF,COUNT);
                 IF (BUF_COUNT+2+COUNT) >
                      (MINIMUM(LENGTHC(TEMP_BUF2),M$LO$->F$DCB.WIDTH#)
                              -LENGTHC('TYPES: '))
                    THEN DO;
                    CALL  ADD_TEXTC(TEXT$,TEMP_BUF2,BUF_COUNT);
                    TVEC_ = VECTOR(TEXTBUF);
                    TVEC_.BOUND = BUF_COUNT;
                    CALL  WRITE_IT (VECTOR(TYPE_FMT),TVEC_);
                    TEXT$ = ADDR(TEXTBUF);
                    BUF_COUNT = 0;
                    END;
                 IF BUF_COUNT > 0 THEN DO;
                    CALL INSERT(TEMP_BUF2,BUF_COUNT,2,', ');
                    BUF_COUNT = BUF_COUNT + 2;
                    END;
                 CALL INSERT(TEMP_BUF2,BUF_COUNT,COUNT,SUBSTR(TEMP_BUF,0,COUNT));
                 BUF_COUNT = BUF_COUNT + COUNT;
                 END;
              END;
           CALL ADD_TEXTC(TEXT$,TEMP_BUF2,BUF_COUNT);
           TVEC_ = VECTOR(TEXTBUF);
           TVEC_.BOUND = BUF_COUNT;
           IF BUF_COUNT > 0 THEN CALL WRITE_IT(VECTOR(TYPE_FMT),TVEC_);
        DO CASE(REPORT_CODE);
         CASE(%DIST);
           ELF_BRKMSG = '0'B;
           NUM_TYPES = 0;
           NUM_RECS = 0;
           DIST_TICS = (ELF_CONSTRAINTS.STOP - ELF_CONSTRAINTS.START)
                                   /DIST_INTVL;
           DO SECLOG_DATE = (ELF_CONSTRAINTS.START/%TICS_PER_DAY)*%TICS_PER_DAY
             TO (ELF_CONSTRAINTS.STOP/%TICS_PER_DAY)*%TICS_PER_DAY
             BY %TICS_PER_DAY;
              CALL OPENXSA(SECLOG_DATE) ALTRET(NO_FILE_DIST);
              EOF_FLAG = %NO;
              CALL PRECORDXSA(ELF_CONSTRAINTS.START);
              DO WHILE(NOT EOF_FLAG);
                 CALL GETREC ALTRET(EOF_DIST);
                 NUM_RECS = NUM_RECS + 1;
                 IF SUM_CLAUSE_FLG THEN DO;
                    RECORD_TYPE = SL_RECORD_BUF.TYPE;
                    DO K = 1 TO NUM_TYPES;
                       IF TYPES(K) = RECORD_TYPE THEN DO;
                          TYPE_CNT(K) = TYPE_CNT(K) + 1;
                          GOTO FOUND_TYP_DIST;
                          END;             /* IF                                 */
                       END;                /* DO K                               */
                    NUM_TYPES = NUM_TYPES + 1;
                    TYPES(NUM_TYPES) = RECORD_TYPE;
                    TYPE_CNT(NUM_TYPES) = 1;
FOUND_TYP_DIST:;
                    END;
                 /* Put this record into the distribution array */
                 K = (SL_RECORD_BUF.UTS - ELF_CONSTRAINTS.START)
                                   / DIST_TICS;
                 DISTRIBUTION(K) = DISTRIBUTION(K) + 1;
                 DO NEVER;
EOF_DIST:           EOF_FLAG = %YES;
                    END;
                 END;                   /* DO WHILE NOT EOF_FLG   */
NO_FILE_DIST:
              END;                      /* DO SECLOG_DATE = START TO STOP     */
           CALL CLOSEXSA;
           DIST_MAX = 0;
           ELF_LASTTYPE = -1;
           DO K = 0 TO 98;
              IF DIST_MAX < DISTRIBUTION(K)
                    THEN  DIST_MAX = DISTRIBUTION(K);
           END;
           IF NUM_RECS = 0   THEN GOTO   END_DIST;
           CALL  XUD$UTS_CHAR (XUD_PARAM,DIST_TICS,TEXTBUF);
           CALL  WRITE_IT (VECTOR(DIST_HDR),VECTOR(DIST_UNITS),
                           VECTOR(DIST_INTVL),VECTOR(TEXTBUF),
                           VECTOR(ELF_CONSTRAINTS.START),
                           VECTOR(DIST_INTVL),
                           VECTOR(ELF_CONSTRAINTS.STOP),
                           VECTOR(ELF_CONSTRAINTS.START),
                           VECTOR(DIST_INTVL),
                           VECTOR(ELF_CONSTRAINTS.STOP),
                           VECTOR(DIST_INTVL));
           K = ((DIST_MAX+DIST_UNITS-1)/DIST_UNITS)*DIST_UNITS;
           TEXTBUF = ' ';
           DO I = K DOWNTO DIST_UNITS BY -DIST_UNITS;
              DO K = 0 TO DIST_INTVL-1;
                 IF DISTRIBUTION(K) >= I
                    THEN SUBSTR(TEXTBUF,K*2,2) = ' *';
              END;
              K = DIST_INTVL * 2;
              CALL  WRITE_IT (VECTOR(DIST_FMT),VECTOR(I),
                                VECTOR(K),VECTOR(TEXTBUF));
           END;
           I = 0;
           IF DIST_UNITS > 1
              THEN DO;
                 DO K = 0 TO DIST_INTVL-1;
                    IF DISTRIBUTION(K) > I
                       THEN SUBSTR(TEXTBUF,K*2,2) = ' *';
                 END;
                 K = DIST_INTVL * 2;
                 CALL  WRITE_IT (VECTOR(DIST_FMT),VECTOR(I),
                                   VECTOR(K),VECTOR(TEXTBUF));
              END;
           CALL  WRITE_IT (VECTOR(DIST_END),VECTOR(DIST_INTVL),
                           VECTOR(ELF_CONSTRAINTS.START),
                           VECTOR(DIST_INTVL),
                           VECTOR(ELF_CONSTRAINTS.STOP),
                           VECTOR(ELF_CONSTRAINTS.START),
                           VECTOR(DIST_INTVL),
                           VECTOR(ELF_CONSTRAINTS.STOP));
           DIST_MAX = ELF_CONSTRAINTS.START;
           DO I = 0 TO DIST_INTVL-1;
              CALL WRITE_IT(VECTOR(DIST_SUM),VECTOR(I),
                          VECTOR(DIST_MAX),VECTOR(DISTRIBUTION(I)));
              DIST_MAX = DIST_MAX + DIST_TICS;
           END;
END_DIST:  IF SUM_CLAUSE_FLG THEN
              GOTO PRINT_SUM;
           CALL WRITE_IT(VECTOR(SUM_TOT),VECTOR(NUM_RECS));
         CASE(%RAW,%DETAIL,%DATA);
           ELF_BRKMSG = '1'B;
           DO SECLOG_DATE = (ELF_CONSTRAINTS.START/%TICS_PER_DAY)*%TICS_PER_DAY
             TO (ELF_CONSTRAINTS.STOP/%TICS_PER_DAY)*%TICS_PER_DAY
             BY %TICS_PER_DAY;
              NUM_RECS = 0;
              NUM_TYPES = 0;
              CALL OPENXSA(SECLOG_DATE) ALTRET(NO_FILE);
              CALL M$TIME(EXT_DATE);
              EOF_FLAG = %NO;
              CALL PRECORDXSA(ELF_CONSTRAINTS.START);
              DO WHILE(NOT EOF_FLAG);
                 CALL GETREC ALTRET(EOF_LBL);
                 IF NUM_RECS = 0
                 THEN CALL WRITE_IT(DATE_FMT,VECTOR(DAY_BUF),VECTOR(DATE_BUF));
                 NUM_RECS = NUM_RECS + 1;
                 IF SUM_CLAUSE_FLG THEN DO;
                    RECORD_TYPE = SL_RECORD_BUF.TYPE;
                    DO K = 1 TO NUM_TYPES;
                       IF TYPES(K) = RECORD_TYPE THEN DO;
                          TYPE_CNT(K) = TYPE_CNT(K) + 1;
                          GOTO FOUND_TYP;
                          END;             /* IF                                 */
                       END;                /* DO K                               */
                    NUM_TYPES = NUM_TYPES + 1;
                    TYPES(NUM_TYPES) = RECORD_TYPE;
                    TYPE_CNT(NUM_TYPES) = 1;
FOUND_TYP:;
                    END;
                 CALL M$TIME(RECORD_DATE);
                 CALL REPORT_ONE ALTRET(EOF_LBL);
                 DO NEVER;
EOF_LBL:            EOF_FLAG = %YES;
                    END;
                 END;                   /* DO WHILE NOT EOF_FLG   */
NO_FILE:
              END;                      /* DO SECLOG_DATE = START TO STOP     */
           CALL CLOSEXSA;
           ELF_LASTTYPE = -1;
           IF SUM_CLAUSE_FLG THEN
              GOTO PRINT_SUM;
         CASE(%SUM);
           ELF_BRKMSG = '0'B;
           NUM_TYPES = 0;
           NUM_RECS = 0;
           DO SECLOG_DATE = (ELF_CONSTRAINTS.START/%TICS_PER_DAY)*%TICS_PER_DAY
             TO (ELF_CONSTRAINTS.STOP/%TICS_PER_DAY)*%TICS_PER_DAY
             BY %TICS_PER_DAY;
              CALL OPENXSA(SECLOG_DATE) ALTRET(NO_FILE2);
              EOF_FLAG = %NO;
              CALL PRECORDXSA(ELF_CONSTRAINTS.START);
              DO WHILE(NOT EOF_FLAG);
                 CALL GETREC ALTRET(EOF);
                 NUM_RECS = NUM_RECS + 1;
                 RECORD_TYPE = SL_RECORD_BUF.TYPE;
                 DO K = 1 TO NUM_TYPES;
                    IF TYPES(K) = RECORD_TYPE THEN DO;
                       TYPE_CNT(K) = TYPE_CNT(K) + 1;
                       GOTO FOUND_TYPE;
                       END;             /* IF                                 */
                    END;                /* DO K                               */
                 NUM_TYPES = NUM_TYPES + 1;
                 TYPES(NUM_TYPES) = RECORD_TYPE;
                 TYPE_CNT(NUM_TYPES) = 1;
FOUND_TYPE:      ;
                 DO NEVER;
EOF:                EOF_FLAG = %YES;
                    END;                /* DO NEVER                           */
                 END;                   /* DO WHILE NOT EOF_FLAG              */
NO_FILE2:
              END;                      /* DO SECLOG_DATE = START TO STOP     */
           CALL CLOSEXSA;
PRINT_SUM:;
           IF NUM_TYPES > 0 THEN DO;
              CALL WRITE_IT(VECTOR(SUM_FMT));
              DO I = 1 TO NUM_TYPES;
                 TEXT$ = ADDR(TEXTBUF);
                 CALL TYPENAME(TYPES(I),TEMP_BUF,COUNT);
                 CALL BINCHAR (SUBSTR(TEXTBUF,1,3),TYPES(I));
                 SUBSTR(TEXTBUF,0,1) = BINASC(3);
                 IF SUBSTR(TEXTBUF,1,3)~=SUBSTR(TEMP_BUF,0,COUNT)
                   THEN DO;
                   SUBSTR(TEXTBUF,0,1) = BINASC(4+COUNT);
                   CALL INSERT(TEXTBUF,4,COUNT+3,' ',TEMP_BUF);
                   COUNT = COUNT + 4;
                   END;
                   ELSE COUNT = 3;
                 TVEC_ = VECTOR(TEXTBUF);
                 TVEC_.BOUND = COUNT;
                 CALL WRITE_IT(VECTOR(SUM_ENTRY),
                   TVEC_,
                   VECTOR(TYPE_CNT(I)));
                 END;                   /* DO I                               */
              END;                      /* IF NUM_TYPES > 0                   */
           CALL WRITE_IT(VECTOR(SUM_TOT),VECTOR(NUM_RECS));
         END;                           /* CASE REPORT CODE                   */
        ELF_CONSTRAINTS = ELF_SAVE;
        CALL M$CLOSE(CLOSE_LO);
        DO NEVER;
OPN_ERR:
           CALL ERRMSG;
           END;                         /* DO NEVER                           */
NO_REPORT:
        RETURN;
FID_ERR:
        CALL ERRMSG;
        RETURN;
%EJECT;
TYPENAME: PROC(TYPE,TEXT,COUNT);
/**/
DCL TYPE UBIN HALF UNAL;
DCL TEXT CHAR(63);
DCL COUNT UBIN WORD;
DCL  1 ELF_TBL BASED (ELF$) ALIGNED,
       2 MAX#  UBIN WORD UNAL,
       2 TBL (0:0),
         3 TYPE UBIN BYTE UNAL,
         3 TEXT CHAR (23) UNAL,
         3 COUNT UBIN WORD;
DCL ELF$ PTR;
DCL INDX SBIN;
/**/
     IF TYPE=%ALL THEN
       DO;
       TEXT = 'ALL';
       COUNT = 3;
       RETURN;
       END;
     IF ELF$$(LOG#)~=ENTADDR(NIL) THEN
        DO; ELFNN$$ = ELF$$(LOG#);
            CALL ELFNN$$ (0,ELF$); /* Get Type Name table */
            END;
        ELSE ELF$ = ADDR(LTBL);
SRCH:  DO INDX = 0 TO ELF_TBL.MAX#-1;
          IF TYPE = ELF_TBL.TBL.TYPE(INDX) THEN DO;
             TEXT = ELF_TBL.TBL.TEXT(INDX);
             COUNT = ELF_TBL.TBL.COUNT(INDX);
             RETURN;
             END;
       END;
     IF ELF$~=ADDR(LTBL) THEN
       DO;
       ELF$ = ADDR(LTBL);
       GOTO SRCH;
       END;
     CALL BINCHAR(SUBSTR(TEXT,0,3),TYPE);
     COUNT = 3;
     RETURN;
END TYPENAME;
%EJECT;
ADD_TEXTC: PROC(PTR$,TXT,SIZE);
/**/
DCL PTR$ PTR;
DCL TXT CHAR(SIZE);
DCL SIZE SBIN;
/**/
DCL 1 TIMEBUF BASED(PTR$),
      2 N UBIN BYTE UNAL,
      2 C CHAR(SIZE);
/**/
     TIMEBUF.N = SIZE;
     TIMEBUF.C = TXT;
     PTR$ = PINCRC(PTR$,SIZE+1);
     RETURN;
END ADD_TEXTC;
%EJECT;
REPORT_ONE: PROC ALTRET;
/**/
/* SUBS */
/**/
/**/
/* CONSTANT DATA */
/**/
DCL SL_OUTBUF$ PTR CONSTANT INIT(ADDR(SL_OUTBUF));
/**/
/* EXTERNAL REQUIREMENTS */
/**/
/**/
/* STATIC DATA */
/**/
%FPT_WRITE(FPTN=WRITE_RECORD,
           DCB=M$LO,
           BUF=SL_OUTBUF,
           VFC=YES);
/**/
/* AUTO DATA */
/**/
DCL PRINT_HDR BIT(1) ALIGNED;
DCL I UBIN;
DCL PMME UBIN HALF ALIGNED;
DCL HALFWORD UBIN HALF;
DCL J UBIN;
DCL RESULTS$ PTR;
/**/
/* BASED STRUCTURES */
/**/
DCL 1 RESULTS ALIGNED BASED(RESULTS$),
     2 COUNT UBIN WORD,
     2 VECTOR_ (0:0) VECTOR;
DCL DATABUF BASED CHAR(J);
%EJECT;
  I = SL_RECORD_BUF.TYPE - %TYPE_LO - 1;
  IF ELF_LASTTYPE ~= SL_RECORD_BUF.TYPE THEN DO;
     IF REPORT_CODE = %RAW THEN DO;
        SL_OUTBUF = 'A';
        CALL WRITE_REC ALTRET(WRITE_ERR);
        END;
     SL_OUTBUF = 'B<<<< ';   HALFWORD = SL_RECORD_BUF.TYPE;
     CALL TYPENAME (HALFWORD,SUBSTR(SL_OUTBUF,6),J);
     SUBSTR(SL_OUTBUF,6+J) = ' >>>> (999)';
     CALL BINCHAR (SUBSTR(SL_OUTBUF,6+J+7,3),SL_RECORD_BUF.TYPE);
     CALL WRITE_REC ALTRET(WRITE_ERR);
     PRINT_HDR = %YES;
     ELF_LASTTYPE = SL_RECORD_BUF.TYPE;
     END;
  ELSE PRINT_HDR = %NO;
  IF ELF$$(LOG#)~=ENTADDR(NIL) THEN
     ELFNN$$ = ELF$$(LOG#);
    ELSE ELFNN$$ = ENTADDR(ELF00);
  DO CASE(REPORT_CODE);
     CASE(%RAW);
       IF PRINT_HDR THEN DO;
          CALL ELFNN$$ (1,RESULTS$); /* Get RAW header */
          DO I = 0 TO RESULTS.COUNT-1;
            J = VBOUND(RESULTS.VECTOR_(I))+1;
            SL_OUTBUF = VBASE(RESULTS.VECTOR_(I))->DATABUF;
            CALL WRITE_REC ALTRET(WRITE_ERR);
          END;
          END;
       CALL ELFNN$$ (2,RESULTS$,SL_RECORD_BUF); /* Get RAW report */
       DO I = 0 TO RESULTS.COUNT-1;
         J = VBOUND(RESULTS.VECTOR_(I))+1;
         SL_OUTBUF = VBASE(RESULTS.VECTOR_(I))->DATABUF;
         CALL WRITE_REC ALTRET(WRITE_ERR);
       END;
     CASE(%DETAIL,%DATA);
       IF REPORT_CODE = %DETAIL
           THEN CALL ELFNN$$ (3,RESULTS$,SL_RECORD_BUF);
           ELSE CALL ELF00 (3,RESULTS$,SL_RECORD_BUF);
       DO I = 0 TO RESULTS.COUNT-1;
         J = VBOUND(RESULTS.VECTOR_(I))+1;
         SL_OUTBUF = VBASE(RESULTS.VECTOR_(I))->DATABUF;
         CALL WRITE_REC ALTRET(WRITE_ERR);
       END;
       SL_OUTBUF = 'A';
       CALL WRITE_REC ALTRET(WRITE_ERR);
     END; /* Do Case REPORT_CODE */
  RETURN;
WRITE_ERR:;
  CALL ERRMSG;
  RETURN;
 
%EJECT;
WRITE_REC: PROC ALTRET;
/**/
DCL I UBIN;
/**/
  DO I = 0 TO LENGTHC(SL_OUTBUF)-1;
   IF SUBSTR(SL_OUTBUF,I,1) < ' '
      | SUBSTR(SL_OUTBUF,I,1) > '~'
        THEN SUBSTR(SL_OUTBUF,I,1) = '.';
  END;
  CALL M$WRITE(WRITE_RECORD) ALTRET(ERR);
  SL_OUTBUF = ' ';
  RETURN;
ERR:;
  ALTRETURN;
END WRITE_REC;
END REPORT_ONE;
END REPORT;
%EJECT;
SPAN:   PROC ALTRET;
/**/
/* VARS */
DCL I UBIN;
DCL VALUE UBIN;
DCL STOP UBIN WORD ;
DCL TEMP UBIN WORD STATIC;
DCL START UBIN WORD;
/**/
/* FPT DEFS */
%FPT_TIME (FPTN=CUR_TIME,
           SOURCE=CLOCK,
           DEST=UTS,
           TSTAMP=TEMP);
%EJECT;
        START = ELF_CONSTRAINTS.START;
        STOP = ELF_CONSTRAINTS.STOP;
        DO CASE(OUT$BLK.SUBLK$(0)->OUT$BLK.CODE);
         CASE (%TIME_X);
           CALL M$TIME (CUR_TIME);
           CALL CHARBIN(I,OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(0)->
             OUT$SYM.TEXT);
           DO CASE (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(1)->OUT$BLK.CODE);
            CASE (%DAYS);
              START = SL_DEFAULT.START- I * %TICS_PER_DAY;
              STOP = SL_DEFAULT.STOP;
            CASE (%WEEKS);
              START = SL_DEFAULT.START- I * %TICS_PER_WEEK;
              STOP = SL_DEFAULT.STOP;
            CASE (%MONTHS);
              START = SL_DEFAULT.START- I * %TICS_PER_MONTH;
              STOP = SL_DEFAULT.STOP;
            CASE (%YEAR);
              START = SL_DEFAULT.START- I * %TICS_PER_YEAR;
              STOP = SL_DEFAULT.STOP;
            CASE (%MINUTES);
              START = TEMP - I * %TICS_PER_MIN;
              STOP = TEMP;
            CASE (%HOURS);
              START = TEMP - I * %TICS_PER_HOUR;
              STOP = TEMP;
            END;                        /* OF DO CASE TIME_X                  */
         CASE (%TIME_N);
           DO I = 0 TO OUT$BLK.SUBLK$(0)->OUT$BLK.NSUBLKS - 1;
              DO CASE (OUT$BLK.SUBLK$(0)->OUT$BLK.SUBLK$(I)->
                OUT$BLK.CODE);
               CASE(%START);
                 CALL CVTUTS(OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(I),-1,VALUE) ALTRET(ERR_LBL);
                 START = VALUE;
               CASE(%STOP);
                 CALL CVTUTS(OUT$BLK.SUBLK$(0)->
                   OUT$BLK.SUBLK$(I),1,VALUE) ALTRET(ERR_LBL);
                 STOP = VALUE;
               END;                     /* CASE CODE                          */
              END;                      /* DO I                               */
         CASE (%TODAY);
           DO;
              START = SL_DEFAULT.START;
              STOP  = SL_DEFAULT.STOP;
              END;
         END;                           /* OF DO CASE TIME_X OR TIME_N        */
        IF STOP < START
        THEN                            /* BAD TIME CONSTRAINTS               */
        DO;
           CALL ERRMSG(%E$BAD_TIME_RANGE);
           ALTRETURN;
           /*E* ERROR:   SL-E$BAD_TIME_RANGE-0
                MESSAGE: Bad time span: start > stop
           */
           END;                         /* IF BAD TIME RANGE                  */
        ELF_CONSTRAINTS.START = START;
        ELF_CONSTRAINTS.STOP = STOP;
        RETURN;
ERR_LBL:
        CALL ERRMSG(%E$BADTIME);
        ALTRETURN;
        /*E* ERROR:   SL-E$BADTIME-0
             MESSAGE: Illegal format for time or date
        */
%EJECT;
CVTUTS: PROC(TOP$,DAYFLG,UTS) ALTRET;
/**/
/* PARAMS */
DCL TOP$ PTR;
DCL DAYFLG SBIN;
DCL UTS UBIN;
/**/
/* VARS */
DCL I UBIN;
DCL 1 TBUF3 STATIC,
      2 HH CHAR(2),
      2 * CHAR(1),
      2 MM CHAR(2),
      2 * CHAR(1),
      2 SS CHAR(2),
      2 * CHAR(1),
      2 SM CHAR(2);
DCL 1 DBUF3 STATIC,
      2 MM CHAR(2),
      2 * CHAR(1),
      2 DD CHAR(2),
      2 * CHAR(1),
      2 YY CHAR(2);
DCL TIMECHARS CHAR(4);
DCL 1 TIMECHAR REDEF TIMECHARS,
      2 HH CHAR(2),
      2 MM CHAR(2);
DCL SYM$ PTR;
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=FPT_GETTIME,
           DATE=DBUF3,
           TIME=TBUF3,
           SOURCE=CLOCK,
           DEST=LOCAL);
%FPT_TIME (FPTN=FPT_GETUTS,
           DATE=DBUF3,
           TIME=TBUF3,
           SOURCE=LOCAL,
           DEST=UTS);
/**/
/* MACRO INVOCATIONS */
%PARSE$OUT (NAME=OUT$BLK,STCLASS="BASED(TOP$)");
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
%EJECT;
        CALL M$TIME(FPT_GETTIME);
        IF DAYFLG > 0
        THEN                            /* DEFAULT TIME = 23:59               */
        DO;
           TBUF3.HH = '23';
           TBUF3.MM = '59';
           TBUF3.SS = '59';
           TBUF3.SM = '99';
           END;
        ELSE                            /* DEFAULT TIME = 00:00               */
        DO;
           TBUF3.HH = '00';
           TBUF3.MM = '00';
           TBUF3.SS = '00';
           TBUF3.SM = '00';
           END;
        DO I = 0 TO OUT$BLK.NSUBLKS - 1;
           DO CASE(OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
            CASE(%DATE_P);
              CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0),DBUF3.MM) ALTRET(BAD_TIME);
              CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1),DBUF3.DD) ALTRET(BAD_TIME);
              IF OUT$BLK.SUBLK$(I)->OUT$BLK.NSUBLKS = 3 THEN
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(2),DBUF3.YY) ALTRET(BAD_TIME);
            CASE(%TIME_P);
              IF OUT$BLK.SUBLK$(I)->OUT$BLK.NSUBLKS = 1
              THEN
              DO;
                 SYM$=OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0);
                 IF OUT$SYM.COUNT ~= 4
                 THEN
                    ALTRETURN;
                 TIMECHARS = OUT$SYM.TEXT;
                 TBUF3.HH = TIMECHAR.HH;
                 TBUF3.MM = TIMECHAR.MM;
                 END;
              ELSE
              DO;
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0),TBUF3.HH) ALTRET(BAD_TIME);
                 CALL FILL_FIELD(OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(1),TBUF3.MM) ALTRET(BAD_TIME);
                 END;
            END;                        /* CASE CODE                          */
           END;                         /* DO I                               */
        FPT_GETUTS.TSTAMP_ = VECTOR(UTS);
        CALL M$TIME(FPT_GETUTS) ALTRET(BAD_TIME);
        RETURN;
BAD_TIME:
        ALTRETURN;
%EJECT;
FILL_FIELD: PROC(SYM$,FIELD) ALTRET;
/**/
/* PARAMS */
DCL SYM$ PTR;
DCL FIELD CHAR(2);
DCL RFIELD(0:1) REDEF FIELD CHAR(1);
/**/
%PARSE$SYM (NAME=OUT$SYM,STCLASS="BASED(SYM$)");
/**/
        IF OUT$SYM.COUNT = 2
        THEN FIELD = OUT$SYM.TEXT;
        ELSE
           IF OUT$SYM.COUNT = 1
           THEN
           DO;
              RFIELD(0) = '0';
              RFIELD(1) = OUT$SYM.TEXT;
              END;
           ELSE                         /* ERROR                              */
           DO;
              ALTRETURN;
              END;                      /* IF                                 */
        RETURN;
END FILL_FIELD;
END CVTUTS;
END SPAN;
%EJECT;
GETREC: PROC(KEY_NAME,UTS,DONT_CLOSE) ALTRET;
/**/
/* PARAMS */
DCL KEY_NAME CHAR(8);
DCL UTS SBIN WORD;
DCL DONT_CLOSE SBIN;
/**/
/**/
/* ENTRY DEFS */
DCL XSA$READ ENTRY(2) ALTRET;
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
DCL XUR$ERRMSG ENTRY(7) ALTRET;
/**/
/* VARS */
DCL I SBIN;
DCL PASSED_FLAG BIT(1) ALIGNED;
DCL RESULTS$ PTR;
/**/
/**/
/* FPT DEFINITIONS */
%FPT_READ (FPTN=READ_SECLOG,
           STCLASS=CONSTANT,
           DCB=M$SECLOG,
           BUF=SL_RECORD_BUF);
%FPT_PFIL (DCB=M$SECLOG,
           STCLASS=CONSTANT,
           BOF=YES);
/**/
%EJECT;
           PASSED_FLAG = %NO;
           IF SL_BOF
           THEN DO;
              SL_BOF = %NO;
              CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
              CALL XSA$OPEN(SL_OPEN_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
              END;                      /* IF SL_BOF                          */
           DO WHILE(NOT(PASSED_FLAG));
              CALL XSA$READ(READ_SECLOG,SL_XSA_PARAM) ALTRET(READ_ERR);
              PASSED_FLAG = %YES;
              IF SL_RECORD_BUF.UTS < ELF_CONSTRAINTS.START THEN
                 GOTO NOT_PASSED;
              IF SL_RECORD_BUF.UTS > ELF_CONSTRAINTS.STOP THEN
                 GOTO SECLOG_EOF;
              IF ELF$$(LOG#) ~= ENTADDR(NIL)
                 THEN DO;
                 ELFNN$$ = ELF$$(LOG#);
                 CALL ELFNN$$ (6, RESULTS$, SL_RECORD_BUF);
                 IF  RESULTS$ = ADDR(NIL) THEN GOTO NOT_PASSED;
                 END;
              IF ELF_CONSTRAINTS.TYPES(0) = %ALL THEN
                 GOTO FOUND_NTYPES;
              DO I = 1 TO %MAX_TYPES;
                 IF SL_RECORD_BUF.TYPE = ELF_CONSTRAINTS.TYPES(I)
                    THEN GOTO FOUND_NTYPES;
                 END;
NOT_PASSED:      ;
              PASSED_FLAG = %NO;
FOUND_NTYPES: ;
              END;
           SL_LASTUTS = SL_RECORD_BUF.UTS;
           RETURN;
XSA_ERR:   CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
           RETURN;
READ_ERR:  IF SL_XSA_PARAM.ERR.CODE ~= %E$EOF
           THEN DO;
              CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
              RETURN;
              END;
SECLOG_EOF: ;
           ALTRETURN;
END GETREC;
%EJECT;
OPENXSA: PROC(SECLOG_DATE) ALTRET;
DCL SECLOG_DATE UBIN;
/**/
/* ENTRY DEFS */
DCL XSA$OPEN ENTRY(2) ALTRET;
DCL XSA$PRECORD ENTRY(2) ALTRET;
DCL XSA$CLOSE ENTRY(2) ALTRET;
/**/
/* VARIABLES */
DCL SECLOGDATE UBIN STATIC;
DCL ANSDATE2 CHAR(6) STATIC;
DCL TODAYDATE CHAR(6) STATIC;
DCL 1 FSF_BUF BASED(SL_XSA_BUF.P$),
      2 KEYS (0:1023) UBIN,
      2 DATA (0:1023) UBIN;
/**/
/* FPT DEFINITIONS */
%FPT_TIME (FPTN=ANS_DATE,
           STCLASS=CONSTANT,
           SOURCE=UTS,
           TSTAMP=SECLOGDATE,
           DEST=ANS,
           DATE=ANSDATE2);
%FPT_TIME (FPTN=TODAY_DATE,
           STCLASS=CONSTANT,
           SOURCE=CLOCK,
           DEST=ANS,
           DATE=TODAYDATE);
%FPT_PRECORD (FPTN=POSITION_SECLOG,
              DCB=M$SECLOG,
              KEY=ELF_CONSTRAINTS.START,
              KEYS=YES,
              STCLASS=CONSTANT);
%FPT_GDS (FPTN=GET_XSA_BUF,
          FREE=YES,
          RESULTS=SL_XSA_BUF_VECTOR,
          SEGSIZE="SIZEW(FSF_BUF)",
          STCLASS=CONSTANT);
%EJECT;
        SECLOGDATE = SECLOG_DATE;
        IF SL_XSA_BUF.P$ = ADDR(NIL)
        THEN DO;
           CALL M$GDS(GET_XSA_BUF) ALTRET(PMME_ERR);
           SL_XSA_PARAM.KBUF_ = VECTOR(FSF_BUF.KEYS);
           SL_XSA_PARAM.BBUF_ = VECTOR(FSF_BUF.DATA);
           END;
        IF SL_M$SECLOG$->F$DCB.FCD#
        THEN CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
        CALL M$TIME(ANS_DATE);
        CALL INSERT(SL_VLP_SECLOG.NAME#,LENGTHC(':ELFnn'),6,ANSDATE2);
        CALL M$TIME(TODAY_DATE);
        IF TODAYDATE = ANSDATE2 THEN
           SL_OPEN_SECLOG.V.SHARE# = %ALL#;
        ELSE SL_OPEN_SECLOG.V.SHARE# = %IN#;
        CALL XSA$OPEN(SL_OPEN_SECLOG,SL_XSA_PARAM) ALTRET(OPEN_ERR);
        RETURN;
OPEN_ERR: ;
        ALTRETURN;
PMME_ERR: ;
        CALL ERRMSG;
        RETURN;
%EJECT;
PRECORDXSA: ENTRY(SECLOG_DATE) ALTRET;
        IF SECLOG_DATE = ELF_CONSTRAINTS.START
          AND (SECLOG_DATE-(SECLOG_DATE/%TICS_PER_DAY)*%TICS_PER_DAY) ~= 0
        THEN DO;
           CALL XSA$PRECORD(POSITION_SECLOG,SL_XSA_PARAM) ALTRET(KEY_ERR);
KEY_ERR:   ;
           SL_BOF = %NO;
           END;
        ELSE SL_BOF = %YES;
        RETURN;
%EJECT;
CLOSEXSA: ENTRY ALTRET;
        IF SL_M$SECLOG$->F$DCB.FCD#
        THEN CALL XSA$CLOSE(SL_CLOSE_SECLOG,SL_XSA_PARAM) ALTRET(XSA_ERR);
        IF SL_XSA_BUF.P$ ~= ADDR(NIL)
        THEN CALL M$FDS(GET_XSA_BUF) ALTRET(PMME_ERR);
        RETURN;
XSA_ERR: ;
        CALL XUR$ERRMSG(SL_XSA_PARAM.ERR);
        RETURN;
END OPENXSA;
%EJECT;
WRITE_IT: PROC(FORMAT_VEC,DV1,DV2,DV3,DV4,DV5,DV6,DV7,DV8,DV9,DV10,
                          D11,D12,D13,D14,D15,D16,D17,D18,D19,D20);
/**/
/* PARAMS */
DCL FORMAT_VEC VECTOR;
DCL DV1 VECTOR;
DCL DV2 VECTOR;
DCL DV3 VECTOR;
DCL DV4 VECTOR;
DCL DV5 VECTOR;
DCL DV6 VECTOR;
DCL DV7 VECTOR;
DCL DV8 VECTOR;
DCL DV9 VECTOR;
DCL DV10 VECTOR;
DCL D11 VECTOR;
DCL D12 VECTOR;
DCL D13 VECTOR;
DCL D14 VECTOR;
DCL D15 VECTOR;
DCL D16 VECTOR;
DCL D17 VECTOR;
DCL D18 VECTOR;
DCL D19 VECTOR;
DCL D20 VECTOR;
/**/
/* VARIABLES */
DCL I UBIN;
DCL M$LO$ PTR;
DCL DATA_VEC(0:19) VECTOR STATIC INIT(VECTOR(NIL)*0);
/**/
/* ENTRY DEFS */
DCL X$FORMAT ENTRY(1);
/**/
/* MACROS */
%F_FDS (NAME=FDS,
        DCB=M$LO,
        TRUNC=NO,
        BUF=SL_OUTBUF,
        VECTR=DATA_VEC);
/**/
/* FPT DEFINITIONS */
/**/
%EJECT;
        M$LO$ = DCBADDR(DCBNUM(M$LO));
        IF NOT M$LO$->F$DCB.FCD#
        THEN CALL M$OPEN(OPEN_LO);
        FDS.FMT_ = FORMAT_VEC;
        DO I = 0 TO 19;
           DATA_VEC(I) = VECTOR(NIL);
        END;
        IF ADDR(DV1) ~= ADDR(NIL) THEN DATA_VEC(0) = DV1;
        IF ADDR(DV2) ~= ADDR(NIL) THEN DATA_VEC(1) = DV2;
        IF ADDR(DV3) ~= ADDR(NIL) THEN DATA_VEC(2) = DV3;
        IF ADDR(DV4) ~= ADDR(NIL) THEN DATA_VEC(3) = DV4;
        IF ADDR(DV5) ~= ADDR(NIL) THEN DATA_VEC(4) = DV5;
        IF ADDR(DV6) ~= ADDR(NIL) THEN DATA_VEC(5) = DV6;
        IF ADDR(DV7) ~= ADDR(NIL) THEN DATA_VEC(6) = DV7;
        IF ADDR(DV8) ~= ADDR(NIL) THEN DATA_VEC(7) = DV8;
        IF ADDR(DV9) ~= ADDR(NIL) THEN DATA_VEC(8) = DV9;
        IF ADDR(DV10) ~= ADDR(NIL) THEN DATA_VEC(9) = DV10;
        IF ADDR(D11) ~= ADDR(NIL) THEN DATA_VEC(10) = D11;
        IF ADDR(D12) ~= ADDR(NIL) THEN DATA_VEC(11) = D12;
        IF ADDR(D13) ~= ADDR(NIL) THEN DATA_VEC(12) = D13;
        IF ADDR(D14) ~= ADDR(NIL) THEN DATA_VEC(13) = D14;
        IF ADDR(D15) ~= ADDR(NIL) THEN DATA_VEC(14) = D15;
        IF ADDR(D16) ~= ADDR(NIL) THEN DATA_VEC(15) = D16;
        IF ADDR(D17) ~= ADDR(NIL) THEN DATA_VEC(16) = D17;
        IF ADDR(D18) ~= ADDR(NIL) THEN DATA_VEC(17) = D18;
        IF ADDR(D19) ~= ADDR(NIL) THEN DATA_VEC(18) = D19;
        IF ADDR(D20) ~= ADDR(NIL) THEN DATA_VEC(19) = D20;
        I = 0;
        DO WHILE(DATA_VEC(I) ~= VECTOR(NIL) AND I < 20);
           I = I + 1;
           END;                         /* DO WHILE                           */
        FDS.NVECS# = I;
        FDS.BUF_.BOUND = M$LO$->F$DCB.WIDTH#-1;
        IF (FDS.BUF_.BOUND = 0 OR FDS.BUF_.BOUND > 132)
        THEN FDS.BUF_.BOUND = 132;
        CALL X$FORMAT(FDS);
END WRITE_IT;
%EJECT;
ERRMSG: PROC(CODE);
/**/
/* PARAMS */
DCL CODE UBIN WORD;
/**/
/* LOCALS */
DCL DCB# UBIN;
%EJECT;
        IF ADDR(CODE) = ADDR(NIL)
        THEN DO;
           SL_ERRCODE = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
           SL_ERRCODE.SEV = 0;
           DCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
           CALL XUR$ERRMSG(SL_ERRCODE,DCB#);
           END;
        ELSE DO;
           SL_ERRCODE = '231400000000'O;
           SL_ERRCODE.CODE = CODE;
           CALL XUR$ERRMSG(SL_ERRCODE);
           END;
        RETURN;
END ERRMSG;
END SHREW;
%EOD;
/********************************************************************
*
*      ELF00                 Provide generic functions for undefined
*                            error logs [ENTADDR(ELFnn)=ENTADDR(NIL)]
*/
       ELF00:                          PROC
           (F#,PTR$,EL_RECORD_BUF);
/**
 *                 PARAMETER DECLARATIONS
 **/
DCL    F#                              UBIN   WORD;
DCL    PTR$                            PTR;
/**/
%INCLUDE EL$TABLES;
/**/
%LIST;
%EL$HDR            (NAME=EL_RECORD_BUF,
                    STCLASS=PARAM,
                    HDRONLY=NO);
%PLIST;
/**
 *                 SHREW MACROS, ETC.
 **/
%INCLUDE SHREW_C600;
/**/
%INCLUDE SHREW_C6;
/**/
DCL    ELF_FORMAT                      ENTRY  (21);
/**
 *                 GLOBAL SYMREF REQUIREMENTS
 **/
DCL  1 LTBL                            SYMREF    ALIGNED,
       2 MAX#                          UBIN   WORD         UNAL,
       2 TBL (0:%MAX_TYPES),
         3 TYPE                        UBIN   BYTE         UNAL,
         3 TEXT                        CHAR   (23)         UNAL,
         3 COUNT                       UBIN   WORD;
DCL    ELF_TIME                        CHAR   (11)         SYMREF;
DCL    TYPE_CMD                        SBIN                SYMREF;
/**
 *                 LOCAL VARIABLE DECLARATIONS
 **/
DCL    I                               SBIN   WORD;
DCL    J                               SBIN   WORD;
DCL    K                               SBIN   WORD;
DCL    INFO_SIZE                       SBIN   WORD;
DCL  1 VECTORC                         STATIC    SYMDEF    ALIGNED,
       2 COUNT                         UBIN   WORD,
       2 VECTOR_ (0:260)               VECTOR;
DCL    RAWHDR1                         CONSTANT
                                       CHAR   (0)
                                       INIT('ATIME   SIZE  1st 3 Words');
DCL    RAWHDR2                         CONSTANT
                                       CHAR   (0)
       INIT('A-----  ----  --------------------------------------- ----------------');
DCL    DATA (0:260)                    STATIC    SYMDEF
                                       CHAR   (100);
/**
 *                 FORMATTING SERVICE REQUIREMENTS
 **/
%INCLUDE XUF_ENTRY;
/**/
%INCLUDE XU_FORMAT_C;
/**/
%F_FDS             (NAME=FDS,
                    STCLASS="STATIC SYMDEF",
                    DCB=NIL,
                    DVFC='A',
                    TRUNC=YES);
/**/
DCL    RAW_FMT                         CONSTANT
                                       CHAR   (0)
           INIT('%VA%5MA%2P  %4D  %N(%12ZO %)%7P%55-%N(%4A %)%11P');
DCL    DETAIL_FMT1                     CONSTANT
                                       CHAR   (0)
                                       INIT('%VA%5MA%2P  %4D');
DCL  1 DETAIL_FMT2                     CONSTANT,
       2 *                             CHAR   (0)
                             INIT('%VA%2-%4ZO %N(%12ZO %)%7P'),
       2 *                             CHAR   (0)
                                       INIT('%61-%N(%4A %)%12P');
/**/
                   /***********************
                    *   BEGIN  PROCEDURE  *
                    ***********************/
/**/
/**
 *     F# actions:    0 - Return ADDR(type name table) in PTR$.
 *                    1 - Return ADDR(VECTORC table) in PTR$ with
 *                               VECTORC table loaded for RAW report
 *                               headings.
 *                    2 - Return ADDR(VECTORC table) in PTR$ with
 *                               VECTORC table loaded for RAW report
 *                               data.  EL_RECORD_BUF provides data.
 *                    3 - Return ADDR(VECTORC table) in PTR$ with
 *                               VECTORC table loaded for DETAIL report
 *                               data.  EL_RECORD_BUF provides data.
 *                    4 - Return ADDR(TYPE_CMD) in PTR$ with TYPE_CMD
 *                               being the syntax node which describes
 *                               the TYPE command.
 *                 5 - Initialize FOR clause selection criteria by
 *                           the blank-delimited string passed as
 *                           PTR$->OUT$BLK.SUBLK$(0)->OUT$SYM.  When
 *                           PTR$=ADDR(NIL), reset selection criteria
 *                           to accept anything.
 *                 6 - Return ADDR(NIL) in PTR$ when record passed
 *                           as SL_RECORD_BUFF doesn't fit criteria
 *                           selected in last call with F# = 5.
 *                           Otherwise return ADDR(SL_RECORD_BUF)
 *                           in PTR.
 *         ELF00 does not provide services 5 or 6; it ignores
 *         any selection criteria and accepts any record passed.
 */
           VECTORC.COUNT = 0;
           IF  ADDR(EL_RECORD_BUF)~=ADDR(NIL)
                   THEN INFO_SIZE = EL_RECORD_BUF.SIZE - 5;
           DO CASE(F#);
       CASE(0);              PTR$ = ADDR(LTBL);
                             RETURN;
       CASE(1);              PTR$ = ADDR(VECTORC);
                             VECTORC.COUNT = 2;
                             VECTORC.VECTOR_(0) = VECTOR(RAWHDR1);
                             VECTORC.VECTOR_(1) = VECTOR(RAWHDR2);
                             RETURN;
       CASE(2);              PTR$ = ADDR(VECTORC);
                             /* Load up informtion */
                             IF INFO_SIZE < 3    THEN      K = INFO_SIZE;
                                                 ELSE      K = 3;
                             CALL ELF_FORMAT (VECTOR(RAW_FMT),
                                           VECTOR(ELF_TIME),
                             VECTOR(INFO_SIZE),VECTOR(K),
                             VECTOR(EL_RECORD_BUF.INFO(0)),
                             VECTOR(EL_RECORD_BUF.INFO(1)),
                             VECTOR(EL_RECORD_BUF.INFO(2)),
                                       VECTOR(K),
                             VECTOR(EL_RECORD_BUF.INFO(0)),
                             VECTOR(EL_RECORD_BUF.INFO(1)),
                             VECTOR(EL_RECORD_BUF.INFO(2)));
                             RETURN;
       CASE(3);              PTR$ = ADDR(VECTORC);
                             VECTORC.COUNT = 2; /* varies */
                             /* Load up table of entries, based on
                                EL_RECORD_BUF.SIZE information */
                             DATA(0) = 'ATIME   SIZE';
                             DATA(1) = 'A-----  ----';
                             CALL ELF_FORMAT (VECTOR(DETAIL_FMT1),
                                          VECTOR(ELF_TIME),
                                          VECTOR(INFO_SIZE));
                             VECTORC.VECTOR_(0) = VECTOR(DATA(0));
                             VECTORC.VECTOR_(1) = VECTOR(DATA(1));
                             I = 0;
                             J = INFO_SIZE;
                             DO WHILE J > 0;
                             IF J < 4  THEN      K = J;
                                       ELSE      K = 4;
                             FDS.BUFX = 0;
                             CALL ELF_FORMAT
                                 (VECTOR(DETAIL_FMT2),
                                       VECTOR(I), VECTOR(K),
                                   VECTOR(EL_RECORD_BUF.INFO(I)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+1)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+2)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+3)),
                                       VECTOR(K),
                                   VECTOR(EL_RECORD_BUF.INFO(I)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+1)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+2)),
                                   VECTOR(EL_RECORD_BUF.INFO(I+3)));
                             J = J - 4;
                             I = I + 4;
                             END;
       CASE(4);              PTR$ = ADDR(TYPE_CMD);
                             RETURN;
       CASE(5);              RETURN;
       CASE(6);              PTR$ = ADDR(EL_RECORD_BUF);
                             RETURN;
           END;
/**/
       END ELF00;
%EOD;
/*********************************************************************
*
*          ELF_FORMAT                  Format a line & advance vectors
*/
       ELF_FORMAT:                     PROC
           (FMT_,V1_,V2_,V3_,V4_,V5_,V6_,V7_,V8_,V9_,V10_,
                 V11_,V12_,V13_,V14_,V15_,V16_,V17_,V18_,V19_,V20_);
/**
 *                 PARAMETER DECLARATIONS
 **/
DCL    FMT_                            VECTOR;
DCL    V1_                             VECTOR;
DCL    V2_                             VECTOR;
DCL    V3_                             VECTOR;
DCL    V4_                             VECTOR;
DCL    V5_                             VECTOR;
DCL    V6_                             VECTOR;
DCL    V7_                             VECTOR;
DCL    V8_                             VECTOR;
DCL    V9_                             VECTOR;
DCL    V10_                            VECTOR;
DCL    V11_                            VECTOR;
DCL    V12_                            VECTOR;
DCL    V13_                            VECTOR;
DCL    V14_                            VECTOR;
DCL    V15_                            VECTOR;
DCL    V16_                            VECTOR;
DCL    V17_                            VECTOR;
DCL    V18_                            VECTOR;
DCL    V19_                            VECTOR;
DCL    V20_                            VECTOR;
/**
 *                 LOCAL VARIABLE DECLARATIONS
 **/
DCL    V_ (0:19)                       VECTOR;
DCL    JUST_VFC                        CONSTANT
                                       CHAR   (0)
                                       INIT('%VA  ');
/**
 *                 GLOBAL SYMREF REQUIREMENTS
 **/
DCL    DATA (0:260)                    SYMREF
                                       CHAR   (100);
DCL  1 VECTORC                         SYMREF    ALIGNED,
       2 COUNT                         UBIN   WORD,
       2 VECTOR_ (0:260)               VECTOR;
/**
 *                 FORMATTING SERVICE REQUIREMENTS
 **/
DCL    X$FORMAT                        ENTRY   (1);
/**/
%INCLUDE XU_FORMAT_C;
/**/
%F_FDS             (NAME=FDS,
                    STCLASS=SYMREF);
/**/
                   /***********************
                    *   BEGIN  PROCEDURE  *
                    ***********************/
/**/
           FDS.BUF_ = VECTOR(DATA(VECTORC.COUNT));
           DATA(VECTORC.COUNT) = ' ';
           VECTORC.VECTOR_(VECTORC.COUNT) = BITVECT(FDS.BUF_);
           VECTORC.COUNT = VECTORC.COUNT + 1;
           IF  ADDR(FMT_)=ADDR(NIL)    THEN DO;
                                       FDS.FMT_ = VECTOR(JUST_VFC);
                                       FDS.NVECS# = 0;
                                       CALL      X$FORMAT (FDS);
                                       RETURN;
                                       END;
           FDS.FMT_ = FMT_;
           FDS.VECTR$ = ADDR(V_);
           FDS.NVECS# = 0;
           IF ADDR(V1_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(0) = V1_;
                                       END;
           IF ADDR(V2_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(1) = V2_;
                                       END;
           IF ADDR(V3_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(2) = V3_;
                                       END;
           IF ADDR(V4_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(3) = V4_;
                                       END;
           IF ADDR(V5_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(4) = V5_;
                                       END;
           IF ADDR(V6_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(5) = V6_;
                                       END;
           IF ADDR(V7_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(6) = V7_;
                                       END;
           IF ADDR(V8_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(7) = V8_;
                                       END;
           IF ADDR(V9_) ~= ADDR(NIL)   THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(8) = V9_;
                                       END;
           IF ADDR(V10_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(9) = V10_;
                                       END;
           IF ADDR(V11_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(10) = V11_;
                                       END;
           IF ADDR(V12_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(11) = V12_;
                                       END;
           IF ADDR(V13_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(12) = V13_;
                                       END;
           IF ADDR(V14_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(13) = V14_;
                                       END;
           IF ADDR(V15_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(14) = V15_;
                                       END;
           IF ADDR(V16_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(15) = V16_;
                                       END;
           IF ADDR(V17_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(16) = V17_;
                                       END;
           IF ADDR(V18_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(17) = V18_;
                                       END;
           IF ADDR(V19_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(18) = V19_;
                                       END;
           IF ADDR(V20_) ~= ADDR(NIL)  THEN DO;
                                       FDS.NVECS# = FDS.NVECS# + 1;
                                       V_(19) = V20_;
                                       END;
           CALL    X$FORMAT (FDS);
/**/
       END ELF_FORMAT;
%EOD;
SHREW_BREAK: PROC;
/**/
%INCLUDE SHREW_C600;
/**/
DCL ELF_LASTTYPE SBIN WORD SYMREF ALIGNED;
DCL ELF_ERR_RETURN REMEMBER SYMREF;
DCL 1 ELF_CONSTRAINTS SYMREF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN HALF UNAL,
      2 START UBIN WORD ALIGNED,
      2 STOP UBIN WORD ALIGNED;
DCL 1 ELF_SAVE SYMREF DALIGNED,
     2 TYPES (0:%MAX_TYPES) UBIN HALF UNAL,
      2 START UBIN WORD ALIGNED,
      2 STOP UBIN WORD ALIGNED;
/**/
 
     ELF_CONSTRAINTS = ELF_SAVE;
     ELF_LASTTYPE = -1;
     UNWIND TO ELF_ERR_RETURN;
END SHREW_BREAK;
%EOD;
SHREW_BRKMSG:PROC;
/**/
%INCLUDE CP_6;
DCL ELF_BRKMSG BIT(1) SYMREF;
DCL ELF_DATE CHAR(10) SYMREF;
DCL ELF_TIME CHAR(11) SYMREF;
DCL M$LO DCB;
DCL MSGBUF CHAR(80) STATIC INIT(' ');
%FPT_TIME
       (FPTN=CUR_TIME,
        SOURCE=CLOCK,
        DEST=EXT,
        DATE=ELF_DATE,
        TIME=ELF_TIME);
%FPT_WRITE
       (FPTN=RECORD_DATE,
       DCB=M$LO,
       BUF=MSGBUF,
       WAIT=YES);
/**/
 
  IF NOT ELF_BRKMSG THEN
     CALL M$TIME(CUR_TIME);
  CALL CONCAT(MSGBUF,'Break at ',ELF_TIME,' ',ELF_DATE,'! C to continue.');
  CALL M$WRITE(RECORD_DATE) ALTRET(DO_NOTHING);
  DO_NOTHING:
END SHREW_BRKMSG;
