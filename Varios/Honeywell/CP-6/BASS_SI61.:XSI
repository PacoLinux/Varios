/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DDA */
 
LEE$ABORT: PROC;
 
DCL BASSES$UNWIND            BIT(72)   SYMREF;
 
    UNWIND TO BASSES$UNWIND;
 
END LEE$ABORT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DDA */
 
BASS: PROC MAIN;
 
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
/* CLUDE BASS_C1; */
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;
  %CODE01(BASED="BASED(CODE01$)");
  %CODE03(BASED="BASED(CODE03$)");
  %CODE04(BASED="BASED(CODE04$)");
  %CODE16(BASED="BASED(CODE16$)");
%INCLUDE FS$FIT;
  %FS$DEST;
%INCLUDE FM$GRAN;
  %FM$GRAN(BASED="BASED(GRAN$)");
  %FM$CON(BASED="BASED(RCW$)");
%INCLUDE XSJ_MAC_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
/* %INCLUDE XU_WILDCARD_C; */
%INCLUDE XUH_MACRO_C;
 
%EQU LINE_FEED#        = 10;
%EQU LPH$NOT_YOUR_GRAN = 1234;
%EJECT;
%LIST;
%INCLUDE BASS_C61;
%PLIST;
%EJECT;
/**/
/* SUBs used to access the PCB */
/**/
 
%SUB BLK1_NSUBLKS = "BLK1$->P_OUT.NSUBLKS";
%SUB BLK1_SUBLK$  = "BLK1$->P_OUT.SUBLK$";
 
%SUB BLK2_NSUBLKS = "BLK2$->P_OUT.NSUBLKS";
%SUB BLK2_SUBLK$  = "BLK2$->P_OUT.SUBLK$";
%SUB BLK2_CODE    = "BLK2$->P_SYM.CODE";
%SUB BLK2_COUNT   = "BLK2$->P_SYM.COUNT";
%SUB BLK2_TEXT    = "SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)";
 
%SUB BLK3_NSUBLKS = "BLK3$->P_OUT.NSUBLKS";
%SUB BLK3_SUBLK$  = "BLK3$->P_OUT.SUBLK$";
%SUB BLK3_CODE    = "BLK3$->P_SYM.CODE";
%SUB BLK3_COUNT   = "BLK3$->P_SYM.COUNT";
%SUB BLK3_TEXT    = "SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)";
 
%SUB BLK4_NSUBLKS = "BLK4$->P_OUT.NSUBLKS";
%SUB BLK4_SUBLK$  = "BLK4$->P_OUT.SUBLK$";
%SUB BLK4_CODE    = "BLK4$->P_SYM.CODE";
%SUB BLK4_COUNT   = "BLK4$->P_SYM.COUNT";
%SUB BLK4_TEXT    = "SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT)";
 
%SUB BLK5_NSUBLKS = "BLK5$->P_OUT.NSUBLKS";
%SUB BLK5_SUBLK$  = "BLK5$->P_OUT.SUBLK$";
%SUB BLK5_CODE    = "BLK5$->P_SYM.CODE";
%SUB BLK5_COUNT   = "BLK5$->P_SYM.COUNT";
%SUB BLK5_TEXT    = "SUBSTR(BLK5$->P_SYM.TEXT,0,BLK5$->P_SYM.COUNT)";
%EJECT;
/**************************************************\
*                                                  *
*   XUR$GETCMD, X$PARSE & XUF$FORMAT macro stuff   *
*                                                  *
\**************************************************/
 
%XUR_INIT    (NAME=                    XUR_INIT,
              ABORT=LEE$ABORT,
              STCLASS=STATIC,
              PCB=P_PCB );
 
%P$PCB       (NAME                     = P_PCB,
              STCLASS=STATIC );
 
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS=BASED );
 
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS=BASED );
 
%F_FDS       (NAME                     = F_FDS,
           /* BUF=ME_BUF,                     ME_BUF is acquired dynamically  */
              DCB=M$LO,
              STCLASS=STATIC );
 
%XUH_PARAM;
%EJECT;
/**/
/* FORMATter formats and VECTORs */
/**/
 
DCL FORMAT1                  CHAR(0)   STATIC INIT(
    '.. Examining %D-%D (%>A.%>A) %D records, %D Pages, %D grans -> %>A@%>A.');
DCL FORMAT2                  CHAR(0)   STATIC INIT(
  '.. Examining %D-%D (%>A.%>A) %D+%D records, %D Pages, %D grans -> %>A@%>A.');
DCL FORMAT3                  CHAR(0)   STATIC INIT(
    '.. %D items found; Please qualify enough to select 1 and only 1 item.');
DCL FORMAT4                  CHAR(0)   STATIC INIT(
    '%>A');
DCL FORMAT5                  CHAR(0)   STATIC INIT(
    '.. Warning: BASSes primary output (M$LO) is externally SET to %>A.');
DCL FORMAT6                  CHAR(0)   STATIC INIT(
    '.. One Match found, %D records searched.');
DCL FORMAT7                  CHAR(0)   STATIC INIT(
    '.. %D Matches found, %D records searched.');
DCL FORMAT8                  CHAR(0)   STATIC INIT(
    'SYSID-NUM GRANS NRECS NPAGES DEV  WSN    NAME.ACCT');
DCL FORMAT9                  CHAR(0)   STATIC INIT(
    '%6D-%D %11-%5D %5D %5D  %A %A %>A.%>A');
DCL FORMAT10                 CHAR(0)   STATIC INIT(
    '.. Warning: The %D words of memory I got for the QUEUE wasn''t enough');
DCL FORMAT11                 CHAR(0)   STATIC INIT(
    '     1 - >> PLATEN: Width=%D, Length=%D, Limbo=%D, Firstline=%D, LPI=%D.');
DCL FORMAT12                 CHAR(0)   STATIC INIT(
    '.. Sorry, you may only look at YOUR output.');
DCL FORMAT13                 CHAR(0)   STATIC INIT(
    '.. EOF hit after record %D');
DCL FORMAT14                 CHAR(0)   STATIC INIT(
    '.. Beginning-Of-File hit.');
DCL FORMAT15                 CHAR(0)   STATIC INIT(
    '.. Sorry, that''s NOT yours.');
DCL FORMAT16                 CHAR(0)   STATIC INIT(
    '.. No file is OPEN; Command ignored');
DCL FORMAT17                 CHAR(0)   STATIC INIT(
    '.. There is nothing in the output queue.');
DCL FORMAT18                 CHAR(0)   STATIC INIT(
    '.. YOU have nothing in the output queue.');
DCL FORMAT19                 CHAR(0)   STATIC INIT(
    '.. The only item in the output queue was not listed.');
DCL FORMAT20                 CHAR(0)   STATIC INIT(
    '.. YOUR one item in the output queue was not listed.');
DCL FORMAT21                 CHAR(0)   STATIC INIT(
    '.. None listed, %D searched.');
DCL FORMAT22                 CHAR(0)   STATIC INIT(
    '.. None of YOUR %D items was listed.');
DCL FORMAT23                 CHAR(0)   STATIC INIT(
    '.. The only item in the queue was listed.');
DCL FORMAT24                 CHAR(0)   STATIC INIT(
    '.. YOUR only item in the queue was listed.');
DCL FORMAT25                 CHAR(0)   STATIC INIT(
    '.. One of the %D items in the output queue was listed.');
DCL FORMAT26                 CHAR(0)   STATIC INIT(
    '.. One of YOUR %D items in the queue was listed.');
DCL FORMAT27                 CHAR(0)   STATIC INIT(
    '.. %D items listed, %D searched.');
DCL FORMAT28                 CHAR(0)   STATIC INIT(
    '.. %D items listed, %D of YOUR items were searched.');
DCL FORMAT29                 CHAR(0)   STATIC INIT(
    '.. All of the %D items searched were listed.');
DCL FORMAT30                 CHAR(0)   STATIC INIT(
    '.. Nothing found.');
DCL FORMAT31                 CHAR(0)   STATIC INIT(
    '.. Nothing (of YOURs) found.');
DCL FORMAT32                 CHAR(0)   STATIC INIT(
    '.. Record %D (the BANNER occupies the first %D records), Columns %D-%D');
DCL FORMAT33                 CHAR(0)   STATIC INIT(
  '.. Records %D-%D (the BANNER occupies the first %D records), Columns %D-%D');
DCL FORMAT34                 CHAR(0)   STATIC INIT(
    '.. Record %D (Beyond the %D BANNER records), Columns %D-%D');
DCL FORMAT35                 CHAR(0)   STATIC INIT(
    '.. Records %D-%D (Beyond the %D BANNER records), Columns %D-%D');
DCL FORMAT36                 CHAR(0)   STATIC INIT(
    '.. Sorry, you can''t nest READ commands; This READ ignored.');
DCL FORMAT37                 CHAR(0)   STATIC INIT(
    '%6D - Margin: %D, Tabs: %D%N(, %D%)%99P');
DCL FORMAT38                 CHAR(0)   STATIC INIT(
    '%6D - Margin: %D, Tabs: None');
DCL FORMAT39                 CHAR(0)   STATIC INIT(
    '   File name = %A.:SYMO');
DCL FORMAT40                 CHAR(0)   STATIC INIT(
    ' ');
%EJECT;
/**/
/* VECTORs */
/**/
 
DCL FMT1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT1));
DCL FMT2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT2));
DCL FMT3_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT3));
DCL FMT4_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT4));
DCL FMT5_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT5));
DCL FMT6_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT6));
DCL FMT7_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT7));
DCL FMT8_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT8));
DCL FMT9_                    BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT9));
DCL FMT10_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT10));
DCL FMT11_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT11));
DCL FMT12_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT12));
DCL FMT13_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT13));
DCL FMT14_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT14));
DCL FMT15_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT15));
DCL FMT16_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT16));
DCL FMT17_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT17));
DCL FMT18_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT18));
DCL FMT19_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT19));
DCL FMT20_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT20));
DCL FMT21_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT21));
DCL FMT22_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT22));
DCL FMT23_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT23));
DCL FMT24_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT24));
DCL FMT25_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT25));
DCL FMT26_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT26));
DCL FMT27_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT27));
DCL FMT28_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT28));
DCL FMT29_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT29));
DCL FMT30_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT30));
DCL FMT31_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT31));
DCL FMT32_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT32));
DCL FMT33_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT33));
DCL FMT34_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT34));
DCL FMT35_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT35));
DCL FMT36_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT36));
DCL FMT37_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT37));
DCL FMT38_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT38));
DCL FMT39_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT39));
DCL FMT40_                   BIT(72) STATIC DALIGNED INIT(VECTOR(FORMAT40));
%EJECT;
/***************\
*               *
*   M$LO FPTs   *
*               *
\***************/
 
%M$DCB       (DCBN                     = M$LO,
              ASN=DEVICE,
              FUN=CREATE,
              ORG=TERMINAL,
              RES='ME  ' );
 
%FPT_OPEN    (FPTN                     = OPEN_LO,
              ACCT=LO_ACCT,
              DCB=M$LO,
              NAME=LO_NAME,
              PASS=LO_PASS,
              SN=LO_SN,
              WSN=LO_WSN );
%VLP_ACCT    (FPTN                     = LO_ACCT );
%VLP_NAME    (FPTN                     = LO_NAME );
%VLP_PASS    (FPTN                     = LO_PASS );
%VLP_SN      (FPTN                     = LO_SN,
              N=1 );
%VLP_WSN     (FPTN                     = LO_WSN );
 
%FPT_FID     (FPTN                     = FID_LO,
              ACCT=LO_ACCT,
              ASN=OPEN_LO.V.ASN#,
              NAME=LO_NAME,
              PASS=LO_PASS,
              RES=OPEN_LO.V.RES#,
              SN=LO_SN,
              TEXTFID=FID_STRING,
              WSN=LO_WSN );
%EJECT;
/***************\
*               *
*   M$ME FPTs   *
*               *
\***************/
 
%M$DCB       (DCBN                     = M$ME );
 
%FPT_OPEN    (FPTN                     = OPEN_ME,
              ASN=DEVICE,
              DCB=M$ME,
              FUN=CREATE,
              ORG=TERMINAL,
              RES='ME  ' );
%EJECT;
/*************************\
*                         *
*   M$SI and M$SI2 FPTs   *
*                         *
\*************************/
 
%M$DCB       (DCBN                     = M$SI,
              ASN=DEVICE,
              FUN=IN,
              RES='ME  ' );
 
DCL M$SI2                    DCB;
%FPT_OPEN    (FPTN                     = OPEN_SI2,
              ACCT=SI2_ACCT,
              DCB=M$SI2,
              NAME=SI2_NAME,
              PASS=SI2_PASS,
              SN=SI2_SN );
%VLP_ACCT    (FPTN                     = SI2_ACCT );
%VLP_NAME    (FPTN                     = SI2_NAME );
%VLP_PASS    (FPTN                     = SI2_PASS );
%VLP_SN      (FPTN                     = SI2_SN,
              N=1 );
 
%FPT_FID     (FPTN                     = FID_SI2,
              ACCT=SI2_ACCT,
              ASN=OPEN_SI2.V.ASN#,
              NAME=SI2_NAME,
              PASS=SI2_PASS,
              RES=OPEN_SI2.V.RES#,
              SN=SI2_SN,
              TEXTFID=FID_STRING );
%EJECT;
/*****************\
*                 *
*   M$SYMO FPTs   *
*                 *
\*****************/
 
DCL M$SYMO                   DCB;
 
%FPT_OPEN    (FPTN                     = OPEN_SYMO,
              ACCT=SYMO_ACCT,
              ACS=BLOCK,
              ASN=FILE,
              DCB=M$SYMO,
           /* FPARAM=FPARAM,                  FPARAM is acquired dynamically  */
              FUN=IN,
              ORG=SYMB,
              TEST=YES );
%VLP_ACCT    (FPTN                     = SYMO_ACCT,
              ACCT=':SYMO   ' );
 
%FPT_READ    (FPTN                     = READ_SYMO,
           /* BUF=FPARAM,                     FPARAM is acquired dynamically  */
              DCB=M$SYMO,
              KEYS=YES,
              KEY=ZERO );
 
%FPT_OPEN    (FPTN                     = MERGE_SYMO,
              DCB=M$SYMO,
              NAME=SYMO,
              SETDCB=YES );
 
%FPT_OPEN    (FPTN                     = TEST_SYMO,
              ACCT=SYMO_ACCT,
              DCB=M$SYMO,
           /* NAME=CUR_FILE,                    this gets done dynamically    */
              TEST=YES );
%EJECT;
/********************\
*                    *
*   M$PACKSET FPTs   *
*                    *
\********************/
 
%M$DCB       (DCBN                     = M$PACKSET,
              ACCT=':SYMO   ',
              ASN=FILE,
              FUN=IN,
              ORG=SYMB );
 
%FPT_OPEN    (FPTN                     = TO_PACKSET,
              DCB=M$PACKSET,
              FUN=IN,
              RES='DP',
              SCRUB=YES,
              SN=SYMO_PSN );
%VLP_SN      (FPTN                     = SYMO_PSN,
              SN='SYS   ');
 
%FPT_READ    (FPTN                     = READ_GRAN,
           /* BUF=GRAN,                       GRAN is acquired dynamically    */
              DCB=M$PACKSET,
              KEYS=YES,
              KEY=SDA_KEY );
 
%FPT_MADMUCK (FPTN                     = MADMUCK,
              ACCT=SYMO_ACCT,
              READ=YES,
              SN=SYMO_PSN );
%EJECT;
/********************\
*                    *
*   F$JOBSTATS FPTs   *
*                     *
\*********************/
 
%M$DCB       (DCBN                     = F$JOBSTATS,
              ACCT=':SYS    ',
              ASN=FILE,
              FUN=IN,
              NAME=':JOBSTATS',
              SHARE=ALL );
 
%FPT_READ    (FPTN                     = READ_JOBNAME,
              BUF=XSJ_NAMEREC,
              DCB=F$JOBSTATS,
              KEY=XSJ_NAMEKEY,
              KEYS=YES );
%XSJ_NAMEREC (FPTN                     = XSJ_NAMEREC );
%XSJ_NAMEKEY (FPTN                     = XSJ_NAMEKEY );
%EJECT;
/**/
/* STATS STUFF */
/**/
%M$DCB       (DCBN                     = M$STATS,
              ACCT='ZZZA1MAR',
              ASN=FILE,
              EXIST=OLDFILE,
              FUN=CREATE,
              NAME='BASS_TURDS',
              ORG=CONSEC );
%FPT_OPEN    (FPTN                     = OPEN_STATS,
              DCB=M$STATS );
%FPT_WRITE   (FPTN                     = WRITE_STATS,
              BUF=STATS_BUF,
              DCB=M$STATS );
%FPT_CLOSE   (FPTN                     = CLOSE_STATS,
              DCB=M$STATS,
              DISP=SAVE );
%FPT_TIME    (FPTN                     = GET_TIME,
              DATE=STATS.DATE,
              DEST=LOCAL,
              SOURCE=CLOCK,
              TIME=STATS.TIME );
DCL 1 STATS  STATIC,
      2 ACCN                 CHAR(8)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 UNAME                CHAR(12)  UNAL,
      2 *                    CHAR(1)   UNAL,
      2 FACCN                CHAR(8)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 TIME                 CHAR(11)  UNAL,
      2 *                    CHAR(1)   UNAL,
      2 DATE                 CHAR(8)   UNAL,
      2 *                    CHAR(1)   UNAL,
      2 CCBUF                CHAR(148) UNAL;
DCL STATS_BUF REDEF STATS    CHAR(200);
 
DCL STATS_DONE               BIT(1)    STATIC INIT(%NO#);
%EJECT;
/**/
/* PMME FPTs */
/**/
 
%FPT_INT     (FPTN                     = BREAK_CNTRL,
              UENTRY=XUR$BREAK );
 
%FPT_CORRES  (FPTN                     = LO_VS_ME,
              DCB1=M$LO,
              DCB2=M$ME );
 
%FPT_OPEN    (FPTN                     = FPT_OPEN );
 
%FPT_CLOSE   (FPTN                     = FPT_CLOSE,
              DISP=SAVE );
 
%FPT_WRITE   (FPTN                     = FPT_WRITE );
 
%FPT_GDS     (FPTN                     = GDS,
              SEGSIZE=1024 );
%VLP_VECTOR  (FPTN                     = GDS_ );
 
%VLP_VECTOR  (FPTN                     = BUF_ );
 
%VLP_VECTOR  (FPTN                     = EXTNT_ );
 
%FPT_ERRMSG  (FPTN                     = ERRMSG,
              BUF=ERR_BUF,
              CODE=ERRCODE,
              OUTDCB1=M$ME );
%VLP_ERRCODE (FPTN                     = ERRCODE,
              STCLASS=STATIC );
 
%FPT_EXIT    (FPTN                     = SET_STEPCC,
              STEPCC=OK );
 
%FPT_JOBSTATS(FPTN                     = DEFAULT_JOBSTATS,
              STCLASS=STATIC );
 
%VLP_VECTOR  (FPTN                     = OSRCH_RESULTS_ );
 
%FPT_JOBSTATS(FPTN                     = JOBSTATS,
              CRITERIA=O_CRITERIA,
              ORDER=SRCH,
              OUTPUT=YES,
              RESULTS=OSRCH_RESULTS_,
              STCLASS=STATIC );
 
%VLP_CRITERIA(FPTN                    = O_CRITERIA,
              STCLASS=STATIC );
 
%VLP_CRITERIA(FPTN                    = DEFAULT_CRITERIA,
              STCLASS=STATIC );
 
%FPT_PRIV    (FPTN                     = DISPJOB_PRIV,
              PRIV=%PR_DISPJOB#,
              AUTH=YES );
 
%FPT_PRIV    (FPTN                     = FMREAD_PRIV,
              PRIV=%PR_FMREAD#,
              AUTH=YES );
 
%FPT_PRIV    (FPTN                     = FMSEC_PRIV,
              PRIV=%PR_FMSEC#,
              AUTH=NO );
 
%FPT_PRIV    (FPTN                     = FMDIAG_PRIV,
              PRIV=%PR_FMDIAG#,
              AUTH=YES );
 
%FPT_PFIL    (FPTN                     = BOF,
              BOF=YES,
              DCB=M$SYMO );
 
%FPT_PRECORD (FPTN                     = PRECORD,
              DCB=M$SYMO );
 
%FPT_UNFID   (FPTN                     = UNFID_LO,
              DCB=M$LO,
              TEXTFID=PREV_LO_FID );
 
%FPT_LDEV    (FPTN                     = LDEV,
              HOLD=YES );
 
%FPT_JOBSTATS(FPTN                     = UNHOLDF,
              ORDER=UNHOLDF,
              OUTPUT=YES,
              RESULTS=VLR_JOBSTATS_CHECK );
%VLR_JOBSTATS_CHECK (FPTN              = VLR_JOBSTATS_CHECK );
 
%FPT_JOBSTATS(FPTN                     = CHECK_JOBNAME,
              ORDER=CHECK,
              OUTPUT=YES,
              RESULTS=VLR_JOBSTATS_CHECK,
              STCLASS=STATIC );
 
%VLP_TAB     (FPTN                     = TAB,
              STCLASS="BASED(PLATEN$)" );
 
%FPT_MONINFO (FPTN                     = FPT_MONINFO,
              SYMBINFO=SYMBINFO );
%VLR_SYMBINFO(FPTN                     = SYMBINFO );
%EJECT;
/**/
/* BASED items */
/**/
 
%VLA_JOBSTATS_OSRCH          (FPTN     = A$OUTPUT,
          STCLASS="BASED(A$OUTPUT$)" );
 
%VLR_JOBSTATS_OSRCH          (FPTN     = R$OUTPUT,
          STCLASS="BASED(GDS_.PTR$)",
          NFIL=0 );
 
DCL LREC                     CHAR(RECL)       BASED(REC$);
%EJECT;
DCL FPARAM(0:1023)           SBIN      BASED(FPARAM$);
DCL GRAN                     CHAR(4096)BASED(GRAN$);
DCL  GRANWD(0:1023) REDEF GRAN UBIN;
DCL ME_BUF                   CHAR(772) BASED(ME_BUF$);
DCL 1 ME REDEF ME_BUF,
      2 VFC                  CHAR(1),
      2 BUF1                 CHAR(771);
DCL SYMO_BUF                 CHAR(764) BASED(SYMO_BUF$);
DCL 1 PLATEN  BASED(PLATEN$),
      2 TLP,
        3 T                  UBIN(9)   CALIGNED,    /* INIT(8)  */
        3 L                  UBIN(9)   CALIGNED,    /* INIT(16) */
      2 WIDTH                UBIN(9)   CALIGNED,
      2 LENGTH               UBIN(9)   CALIGNED,
      2 LIMBO                UBIN(9)   CALIGNED,
      2 FIRSTLINE            UBIN(9)   CALIGNED,
      2 *                    BIT(8)    UNAL,
      2 EXTWID               BIT(1)    UNAL,
      2 LPI                  UBIN(9)   CALIGNED;
%EJECT;
/**/
/* SYMREFed PTRs, ENTRYs and EPTRs */
/**/
 
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL LEE$ABORT                ENTRY;
DCL X$WRITE                  ENTRY(22);
DCL XSF$LOCCODT              ENTRY(2)  ALTRET;
DCL XUR$ALLMSG               ENTRY(1)  ALTRET;
DCL XUR$BREAK                ENTRY     ASYNC;
DCL XUR$ECHO                 ENTRY(1)  ALTRET;
DCL XUR$ECHOIF               ENTRY(1)  ALTRET;
DCL XUR$ERRMSG               ENTRY(7)  ALTRET;
DCL XUR$ERRPTR               ENTRY(2)  ALTRET;
DCL XUR$GETCMD               ENTRY(6)  ALTRET;
DCL XUR$HELP                 ENTRY(1)  ALTRET;
DCL XUR$INIT                 ENTRY(3)  ALTRET;
DCL XUR$MOREMSG              ENTRY(1)  ALTRET;
DCL XUR$SETDCBS              ENTRY(4)  ALTRET;
 
DCL XUR_ABORT                EPTR STATIC SYMDEF INIT(ENTADDR(LEE$ABORT));
%EJECT;
/**/
/* BIT items */
/**/
 
DCL CCBUF_CMD                BIT(1);
DCL DONE                     BIT(1)    STATIC INIT(%NO#);
DCL LO_NE_ME                 BIT(1);
DCL ONE_SHOT                 BIT(1);
DCL PROMPT_                  BIT(72)   STATIC INIT(VECTOR(PROMPT1));
DCL USING_JOBSTATS           BIT(1);
%EJECT;
/**/
/* CHARacter items */
/**/
 
DCL ACCT                     CHAR(8)   STATIC;
DCL DEV                      CHAR(2)   STATIC;
DCL ERR_BUF                  CHAR(120) STATIC;
DCL FID_STRING               CHAR(80)  STATIC;
DCL FORM                     CHAR(6);
DCL GREETING                 CHAR(0)   STATIC INIT('BASS C00 here (10/24/88)');
DCL INT3                     CHAR(3);
DCL INT6                     CHAR(6);
DCL INT7                     CHAR(7);
DCL INT8                     CHAR(8);
DCL JOBNAME                  CHAR(31)  STATIC;
DCL NOT_IMPLEMENTED          CHAR(0)   STATIC INIT(
    '.. Command not implemented YET.');
DCL PREV_LO_FID              CHAR(80)  STATIC;
DCL PROMPT1                  CHAR(0)   STATIC INIT('Cmd? ');
DCL PROMPT2                  CHAR(0)   STATIC INIT('Range? ');
DCL STR                      CHAR(132);
DCL TNAME                    CHAR(8)   STATIC;
DCL UNAME                    CHAR(12)  STATIC;
DCL VFC                      CHAR(1);
DCL XUR_BUF                  CHAR(133) STATIC;
%EJECT;
/**/
/* PTRs */
/**/
 
DCL A$OUTPUT$                PTR       STATIC;
DCL BLK1$                    PTR;
DCL  PERRCODE REDEF BLK1$    BIT(36);
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL BLK5$                    PTR;
DCL CODE01$                  PTR;
DCL CODE03$                  PTR;
DCL CODE04$                  PTR;
DCL CODE16$                  PTR;
DCL DEST$                    PTR;
DCL EXTNT$                   PTR;
DCL FRCW$                    PTR;
DCL FIT$                     PTR;
DCL FPARAM$                  PTR;
DCL GRAN$                    PTR;
DCL LRCW$                    PTR;
DCL M$LO$                    PTR;
DCL M$ME$                    PTR;
DCL M$PACKSET$               PTR;
DCL M$SI$                    PTR;
DCL M$SI2$                   PTR;
DCL M$SYMO$                  PTR;
DCL ME_BUF$                  PTR;
DCL PLATEN$                  PTR;
DCL RCW$                     PTR;
DCL REC$                     PTR;
DCL SYMO_BUF$                PTR;
 
 
/**/
/* REMEMBER item */
/**/
 
DCL BASSES$UNWIND            BIT(72)   STATIC SYMDEF;
%EJECT;
/**/
/* SBIN items */
/**/
 
DCL BANNER_BIAS              SBIN      STATIC INIT(0);
DCL BANNER_LINES             SBIN      STATIC INIT(0);
DCL BASS_NODES               SBIN      SYMREF;
DCL CMD_NUM                  SBIN;
DCL CMD#                     SBIN;
DCL CODE                     SBIN;
DCL CUR_GRAN#                SBIN;
DCL F                        SBIN;
DCL I                        SBIN;
DCL IINDX                    SBIN;
DCL INDX                     SBIN;
DCL J                        SBIN;
DCL K                        SBIN;
DCL L                        SBIN      STATIC;
DCL LAST_OCTAL_POS           SBIN;
DCL LEN                      SBIN;
DCL LEFT                     SBIN      STATIC INIT(1);
DCL LINE                     SBIN;
DCL M                        SBIN;
DCL M$LO#                    SBIN;
DCL M$ME#                    SBIN;
DCL M$PACKSET#               SBIN;
DCL M$SI#                    SBIN;
DCL M$SI2#                   SBIN;
DCL M$SYMO#                  SBIN;
DCL MAX_GRANS                SBIN;
DCL MAX_EXTNTS               SBIN;
DCL MAX_SYMO_LEN             SBIN;
DCL ME_LEN                   SBIN;
DCL NGRANS                   SBIN      STATIC;
DCL NPAGES                   SBIN      STATIC;
DCL NRECS                    SBIN      STATIC;
DCL NUM                      SBIN      STATIC;
DCL NUM_CMDS                 SBIN;
DCL NUM_FOUND                SBIN      STATIC;
DCL NUM_GRANS                SBIN;
DCL NUM_JOBS                 SBIN;
DCL NUM_LISTED               SBIN;
DCL NUM_MATCHES              SBIN;
DCL NUM_PAGES                SBIN;
DCL NUM_PLATEN_RECS          SBIN;
DCL NUM_SELECTED             SBIN      STATIC;
DCL NUM_TAB_RECS             SBIN;
DCL OINDX                    SBIN;
DCL PAGE_SIZE                SBIN      STATIC INIT(24);
DCL POS                      SBIN;
DCL PRIO                     SBIN      STATIC;
DCL R                        SBIN      STATIC;
DCL REC#                     SBIN;
DCL REC1                     SBIN      STATIC;
DCL REC2                     SBIN      STATIC;
DCL RECL                     SBIN;
DCL RIGHT                    SBIN      STATIC INIT(-1);
DCL STR_LEN                  SBIN;
DCL SYMO_ARS                 SBIN;
DCL SYSID                    SBIN      STATIC;
DCL TABLEVAL                 SBIN;
DCL TOTAL_JOBS               SBIN;
DCL TOTAL_NRECS              SBIN      STATIC;
DCL TY_LEFT                  SBIN      STATIC;
DCL TY_RIGHT                 SBIN      STATIC;
DCL TYPE                     SBIN      STATIC INIT(%TC##);
DCL WIDTH                    SBIN;
DCL WIDTH#                   SBIN;
DCL X                        SBIN;
DCL ZERO                     SBIN      STATIC INIT(0);
%EJECT;
/**/
/* STATIC STRUCTUREs */
/**/
 
DCL 1 SKIP_BLANKS  STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 BLANK                UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(95)  UNAL   INIT(' ');
 
DCL 1 SKIP_DIGITS  STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 DIGITS(0:9)          UBIN(9)   UNAL   INIT(0*0),
      2 *                    CHAR(70)  UNAL   INIT(' ');
 
DCL 1 FIND_NONPRINTABLES  STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 *(0:94)              UBIN(9)   UNAL   INIT(0*0),
      2 *                    CHAR(385) UNAL   INIT(' ');
 
DCL 1 SYMO  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 NAME#                CHAR(31)  UNAL;
 
DCL 1 CUR_FILE,
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL;
DCL 1 CUR_FIL REDEF CUR_FILE,
      2 L                    UBIN(9)   UNAL,
      2 BOOTID               CHAR(3)   UNAL,
      2 SYSID                CHAR(6)   UNAL,
      2 NUM                  CHAR(6)   UNAL,
      2 CHUNK                CHAR(3)   UNAL,
      2 *                    CHAR(13)  UNAL;
 
DCL 1 PREV_FIL,
      2 L                    UBIN(9)   UNAL,
      2 BOOTID               CHAR(3)   UNAL,
      2 SYSID                CHAR(6)   UNAL,
      2 NUM                  CHAR(6)   UNAL,
      2 CHUNK                CHAR(3)   UNAL,
      2 *                    CHAR(13)  UNAL;
 
DCL 1 SELECTED_FILE,
      2 L                    UBIN(9)   UNAL,
      2 BOOTID               CHAR(3)   UNAL,
      2 SYSID                CHAR(6)   UNAL,
      2 NUM                  CHAR(6)   UNAL,
      2 CHUNK                CHAR(3)   UNAL,
      2 *                    CHAR(13)  UNAL;
 
DCL 1 TMP_FILE,
      2 L                    UBIN(9)   UNAL,
      2 BOOTID               CHAR(3)   UNAL,
      2 SYSID                CHAR(6)   UNAL,
      2 NUM                  CHAR(6)   UNAL,
      2 CHUNK                CHAR(3)   UNAL,
      2 *                    CHAR(13)  UNAL;
 
DCL 1 EXTNT(0:0) BASED(EXTNT_.PTR$),
      2 *                    BIT(9)    UNAL,
      2 SDA                  UBIN(27)  UNAL,
      2 HASH                 UBIN(36)  UNAL,
      2 REC#                 UBIN(36)  UNAL;
 
DCL 1 OPT,
      2 FLAG(0:71)           BIT(1);
 
DCL 1 LIST,
      2 AUTH                 BIT(1)    UNAL,
      2 *                    BIT(34)   UNAL,
      2 ACTIVE               BIT(1)    UNAL;
 
DCL 1 EXAMINE,
      2 AUTH                 BIT(1)    UNAL,
      2 *                    BIT(34)   UNAL,
      2 ACTIVE               BIT(1)    UNAL;
 
DCL 1 BYT,
      2 U1                   UBIN(3)   UNAL,
      2 U2                   UBIN(3)   UNAL,
      2 U3                   UBIN(3)   UNAL;
DCL BYTX REDEF BYT           CHAR(1)   UNAL;
DCL BYTU REDEF BYT           UBIN(9)   UNAL;
 
DCL 1 DVBYTE,
      2 TOP#                 BIT(1)    UNAL,
      2 *                    BIT(1)    UNAL,
      2 VFC#                 BIT(1)    UNAL,
      2 BIN#                 BIT(1)    UNAL,
      2 TRAN#                BIT(1)    UNAL,
      2 *                    BIT(3)    UNAL;
%EJECT;
DCL 1 XLATE_TABX  STATIC,
      2 A(0:11)              CHAR(40)  UNAL     INIT(
/* DECIMAL   OCTAL   */
/*   0- 39 .000-.047 */ '................................ !"#$%&''',
/*  40- 79 .050-.117 */ '()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO',
/*  80-119 .120-.167 */ 'PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw',
/* 120-159 .170-.237 */ 'xyz{|}~.................................',
/* 160-199 .240-.307 */ '........................................',
/* 200-239 .310-.357 */ '........................................',
/* 240-279 .360-.427 */ '........................................',
/* 280-319 .430-.477 */ '........................................',
/* 320-359 .480-.547 */ '........................................',
/* 360-399 .550-.617 */ '........................................',
/* 400-439 .620-.667 */ '........................................',
/* 440-479 .670-.737 */ '........................................'),
      2 *                    CHAR(32)  UNAL     INIT(
/* 480-511 .740-.777 */ '................................');
DCL XLATE_TAB(0:511) REDEF XLATE_TABX  CHAR(1)  UNAL;
 
DCL 1 LC_TO_UC  STATIC,
      2 *(0:127)             UBIN(9)   UNAL   INIT(
/* DECIMAL   OCTAL   */
/*   0-  7 .000-.007 */  000,001,002,003,004,005,006,007,
/*   8- 15 .010-.017 */  008,009,010,011,012,013,014,015,
/*  16- 23 .020-.027 */  016,017,018,019,020,021,022,023,
/*  24- 31 .030-.037 */  024,025,026,027,028,029,030,031,
/*  32- 39 .040-.047 */  032,033,034,035,036,037,038,039,
/*  40- 47 .050-.057 */  040,041,042,043,044,045,046,047,
/*  48- 55 .060-.067 */  048,049,050,051,052,053,054,055,
/*  56- 63 .070-.077 */  056,057,058,059,060,061,062,063,
/*  64- 71 .100-.107 */  064,065,066,067,068,069,070,071,
/*  72- 79 .110-.117 */  072,073,074,075,076,077,078,079,
/*  80- 87 .120-.127 */  080,081,082,083,084,085,086,087,
/*  88- 95 .130-.137 */  088,089,090,091,092,093,094,095,
/*  96-103 .140-.147 */  096,097,098,099,100,101,102,103,
/* 104-111 .150-.157 */  104,105,106,107,108,109,110,111,
/* 112-119 .160-.167 */  112,113,114,115,116,117,118,119,
/* 120-127 .170-.177 */  120,121,122,123,124,125,126,127);
%EJECT;
DCL 1 CRITERIA  STATIC,
      2 ACCT                 CHAR(8)   UNAL,
      2 DEV                  CHAR(2)   UNAL,
      2 FORM                 CHAR(6)   UNAL,
      2 JOBNAME              CHAR(31)  UNAL,
      2 PRIO                 SBIN(9)   UNAL,
      2 NUM                  SBIN      UNAL,
      2 SYSID                SBIN      UNAL,
      2 TNAME                CHAR(8)   UNAL,
      2 ACCT_FLAG            BIT(1)    UNAL,
      2 ACCT_WILD            BIT(1)    UNAL,
      2 NOT_ACCT             BIT(1)    UNAL,
      2 DEV_FLAG             BIT(1)    UNAL,
      2 DEV_WILD             BIT(1)    UNAL,
      2 NOT_DEV              BIT(1)    UNAL,
      2 FORM_FLAG            BIT(1)    UNAL,
      2 FORM_WILD            BIT(1)    UNAL,
      2 NOT_FORM             BIT(1)    UNAL,
      2 JOBNAME_FLAG         BIT(1)    UNAL,
      2 JOBNAME_WILD         BIT(1)    UNAL,
      2 NOT_JOBNAME          BIT(1)    UNAL,
      2 NUM_FLAG             BIT(1)    UNAL,
      2 NOT_NUM              BIT(1)    UNAL,
      2 OUTPUTTING           BIT(1)    UNAL,
      2 PRIO_FLAG            BIT(1)    UNAL,
      2 NOT_PRIO             BIT(1)    UNAL,
      2 SYSID_FLAG           BIT(1)    UNAL,
      2 NOT_SYSID            BIT(1)    UNAL,
      2 TNAME_FLAG           BIT(1)    UNAL,
      2 TNAME_WILD           BIT(1)    UNAL,
      2 NOT_TNAME            BIT(1)    UNAL;
%EJECT;
/**/
/* UBIN items */
/**/
 
DCL COMPARE_X                UBIN;
DCL COMPARE_XP               UBIN;
DCL SDA_KEY                  UBIN      STATIC;
DCL WILD_X                   UBIN;
DCL WILD_XC REDEF WILD_X CHAR(4);
DCL WILD_XP                  UBIN;
%EJECT;
/**/
/* VECTORs */
/**/
 
DCL ACCT_                    BIT(72) STATIC DALIGNED INIT(VECTOR(ACCT));
DCL BANNER_LINES_            BIT(72) STATIC DALIGNED INIT(VECTOR(BANNER_LINES));
DCL DEV_                     BIT(72) STATIC DALIGNED INIT(VECTOR(DEV));
DCL FIRSTLINE_               BIT(72) STATIC DALIGNED;
DCL JOBNAME_                 BIT(72) STATIC DALIGNED INIT(VECTOR(JOBNAME));
DCL L_                       BIT(72) STATIC DALIGNED INIT(VECTOR(L));
DCL LENGTH_                  BIT(72) STATIC DALIGNED;
DCL LIMBO_                   BIT(72) STATIC DALIGNED;
DCL LPI_                     BIT(72) STATIC DALIGNED;
DCL NGRANS_                  BIT(72) STATIC DALIGNED INIT(VECTOR(NGRANS));
DCL NPAGES_                  BIT(72) STATIC DALIGNED INIT(VECTOR(NPAGES));
DCL NRECS_                   BIT(72) STATIC DALIGNED INIT(VECTOR(NRECS));
DCL NUM_                     BIT(72) STATIC DALIGNED INIT(VECTOR(NUM));
DCL NUM_FOUND_               BIT(72) STATIC DALIGNED INIT(VECTOR(NUM_FOUND));
DCL NUM_SELECTED_            BIT(72) STATIC DALIGNED INIT(VECTOR(NUM_SELECTED));
DCL R_                       BIT(72) STATIC DALIGNED INIT(VECTOR(R));
DCL REC1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(REC1));
DCL REC2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(REC2));
DCL SYSID_                   BIT(72) STATIC DALIGNED INIT(VECTOR(SYSID));
DCL TNAME_                   BIT(72) STATIC DALIGNED INIT(VECTOR(TNAME));
DCL TOTAL_NRECS_             BIT(72) STATIC DALIGNED INIT(VECTOR(TOTAL_NRECS));
DCL TY_LEFT_                 BIT(72) STATIC DALIGNED INIT(VECTOR(TY_LEFT));
DCL TY_RIGHT_                BIT(72) STATIC DALIGNED INIT(VECTOR(TY_RIGHT));
DCL WIDTH_                   BIT(72) STATIC DALIGNED;
%EJECT;
START_HERE:
    IF NOT (B$JIT.PRIV.JOB & %PR_FMSEC#) THEN /* If THEY didn't have FMSEC on */
       CALL M$RPRIV( FMSEC_PRIV );            /* turn it OFF, quick!          */
    CALL M$RPRIV( FMDIAG_PRIV );
    REMEMBER BREAK_HIT IN BASSES$UNWIND;
    CALL INITIALIZE  ALTRET( SET_THE_STEPCC );
 /* CALL PUT_STATS; */
 
    DO WHILE( NOT DONE );
       CALL GET_A_CMD  ALTRET( NEXT_CMD );/* Read and PARSE the command(s)    */
       DO CASE( CMD# );
          CASE( %ALLHELP## );                 /* ??                           */
             CALL XUR$ALLMSG( XUH_PARAM )  ALTRET( NEXT_CMD );
          CASE( %BANNER## );                  /* B/anner                      */
             CALL FIND_BANNER_SIZE;
          CASE( %CANCEL## );                  /* CA/ncel                      */
             /* .. Command not implemented YET. */
             CALL X$WRITE( F_FDS,VECTOR(NOT_IMPLEMENTED) );
             CALL WRITE( ME.BUF1,LENGTHC(ME.BUF1),,M$ME# );
          CASE( %CLOSE## );                   /* CL/ose                       */
             CALL CLOSE( M$PACKSET# );
             PROMPT_= VECTOR(PROMPT1);
          CASE( %COPY## );                    /* CO/py                        */
             /* .. Command not implemented YET. */
             CALL X$WRITE( F_FDS,VECTOR(NOT_IMPLEMENTED) );
             CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
          CASE( %DEBUG## );                   /* DEBUG                        */
 
          CASE( %DVBYTE## );                  /* [DI/SPLAY] DV/BYTE           */
 
          CASE( %EXAMINE## );                 /* EX/amine                     */
             CALL DO_EXAMINE;
          CASE( %FID## );                     /* [DI/SPLAY] FI/DS             */
 
          CASE( %FIND## );                    /* F/ind                        */
             CALL FIND_STRING  ALTRET( NEXT_CMD );
PUT_FIND_SUM:
             CALL PUT_FIND_SUMMARY;
          CASE( %HELP## );                    /* H/elp                        */
             XUH_PARAM.HELP$= BLK2$->P_OUT.SUBLK$(0)->P_SYM.TEXTC$;
             CALL XUR$HELP( XUH_PARAM )  ALTRET( NEXT_CMD );
          CASE( %HOLD## );                    /* HO/ld                        */
             CALL M$LDEV( LDEV )  WHENALTRETURN DO;
                CALL REPORT_ERR;
                END;
          CASE( %INTERPRET## );               /* I/nterpret                   */
            OPT.FLAG(%NINTERPRET##)= %NO#;
          CASE( %JOBSTATS## );                /* J/obstats                    */
             USING_JOBSTATS= %YES#;
          CASE( %LEFT## );                    /* LE/ft                        */
             IF BLK2_NSUBLKS > 0 THEN DO;
                BLK3$= BLK2_SUBLK$(0);
                CALL CHARBIN( LEFT,BLK3_TEXT );
                IF LEFT > MAX_SYMO_LEN-1 THEN
                   LEFT= MAX_SYMO_LEN-1;
                END;
          CASE( %LIST## );                    /* L/ist                        */
             IF M$PACKSET$->F$DCB.FCD# THEN
                CALL DO_STATUS;
             ELSE DO;
                CALL SCAN_FILES;
PUT_LIST_SUM:
                CALL PUT_LIST_SUMMARY;
                END;
          CASE( %ME## );                      /* M/e                          */
             LIST.ACTIVE= %NO#;
          CASE( %MOREHELP## );                /* ?                            */
             CALL XUR$MOREMSG( XUH_PARAM )  ALTRET( NEXT_CMD );
          CASE( %NBANNER## );                 /* N/o B/anner                  */
             OPT.FLAG(%BANNER##)= %NO#;
             CALL FIND_BANNER_SIZE;
          CASE( %NDVBYTE## );                 /* N/o DV/byte                  */
 
          CASE( %NFID## );                    /* N/o FI/ds                    */
 
          CASE( %NINTERPRET## );              /* N/o I/nterpret               */
            OPT.FLAG(%INTERPRET##)= %NO#;
          CASE( %NUC## );                     /* NUC                          */
             /* .. Command not implemented YET. */
             CALL X$WRITE( F_FDS,VECTOR(NOT_IMPLEMENTED) );
             CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
          CASE( %NULL## );
             /* Don't do anything */
          CASE( %NVFC## );                    /* NV/fc                        */
             OPT.FLAG(%VFC##)= %NO#;
          CASE( %OUTPUT## );                  /* OU/tput                      */
             CALL DO_OUTPUT;
          CASE( %PAGEMODE## );                /* P/age M/ode                  */
 
          CASE( %READ## );                    /* RE/ad                        */
             CALL DO_READ;
          CASE( %RECORDMODE## );              /* REC/ord M/ode                */
             OPT.FLAG(%PAGEMODE##)= %NO#;
          CASE( %RIGHT## );                   /* RI/ght                       */
             IF BLK2_NSUBLKS > 0 THEN DO;
                BLK3$= BLK2_SUBLK$(0);
                CALL CHARBIN( RIGHT,BLK3_TEXT );
                IF RIGHT > MAX_SYMO_LEN-1  OR  RIGHT < LEFT  THEN
                   RIGHT= MAX_SYMO_LEN-1;
                END;
          CASE( %SE## );                      /* SE/lect                      */
             CALL DO_SE;
          CASE( %SPACE## );                   /* SP/ace                       */
 
          CASE( %STATUS## );                  /* ST/atus                      */
             CALL DO_STATUS;
             CALL DO_SE;
          CASE( %SYMO## );                    /* SYM/o                        */
             USING_JOBSTATS= %NO#;
          CASE( %SYSTEM## );                  /* S/ystem                      */
             IF LIST.AUTH THEN
                LIST.ACTIVE= %YES#;
             ELSE DO;
                CALL X$WRITE( F_FDS,FMT12_ );
                CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
                END;
          CASE( %TC##,
                %TN##,
                %TO##,
                %TP##,
                %TS##,
                %TV##,
                %TY## );
             CALL DO_TYPES;
          CASE( %UC## );                      /* UC                           */
             /* .. Command not implemented YET. */
             CALL X$WRITE( F_FDS,VECTOR(NOT_IMPLEMENTED) );
             CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
          CASE( %UNHOLD## );                  /* UN/hold                      */
             CALL M$JOBSTATS( UNHOLDF )  WHENALTRETURN DO;
                CALL REPORT_ERR;
                END;
 
          CASE( %VFC## );                     /* VF/c                         */
 
          CASE( %WIDTH## );                   /* W/idth                       */
             BLK3$= BLK2_SUBLK$(0);
             CALL CHARBIN( WIDTH,BLK3_TEXT );
          CASE( %XIT## );                     /* E/nd | Q/uit | X/it          */
             IF M$SI2$->F$DCB.FCD# THEN DO;   /* Are we in a READ file?       */
                CALL CLOSE( M$SI2# );         /* Yep!  CLOSE it and go        */
                CALL XUR$SETDCBS( M$SI#, , ,);    /* back and read M$SI           */
                END;
             ELSE
                DONE= %YES#;                  /* We're really DONE!           */
          END;
       DO WHILE('0'B);
BREAK_HIT:
          CALL M$RPRIV( FMSEC_PRIV );      /* Turn off FMSEC incase it was ON */
          NUM_CMDS= 0;
          DO CASE( CMD# );
             CASE( %FIND## );
                GOTO PUT_FIND_SUM;
             CASE( %LIST## );
                GOTO PUT_LIST_SUM;
             END;
          END;
NEXT_CMD:
       END;
 
    DO WHILE('0'B);
SET_THE_STEPCC:
       SET_STEPCC.V.STEPCC#= %ERROR#;
       SET_STEPCC.CODE_= VECTOR(ERRCODE);
       END;
 
ALL_DONE:
 /* IF NOT STATS_DONE THEN
       CALL PUT_STATS; */
    CALL CLOSE( M$SYMO# );
    CALL CLOSE( DCBNUM(M$PACKSET) );
    CALL CLOSE( M$SI# );
    CALL CLOSE( M$LO# );
    CALL CLOSE( M$ME# );
    CALL M$EXIT( SET_STEPCC );
 
%EJECT;
INITIALIZE: PROC  ALTRET;
 
    /**/
    /*  Initialize DCB numbers and PTRs */
    /**/
    M$LO#=      DCBNUM(M$LO);
    M$ME#=      DCBNUM(M$ME);
    M$PACKSET#= DCBNUM(M$PACKSET);
    M$SI#=      DCBNUM(M$SI);
    M$SI2#=     DCBNUM(M$SI2);
    M$SYMO#=    DCBNUM(M$SYMO);
 
    M$LO$=      DCBADDR(M$LO#);
    M$ME$=      DCBADDR(M$ME#);
    M$PACKSET$= DCBADDR(M$PACKSET#);
    M$SI$=      DCBADDR(M$SI#);
    M$SI2$=     DCBADDR(M$SI2#);
    M$SYMO$=    DCBADDR(M$SYMO#);
 
    /**/
    /*  Setup and OPEN primary I/O DCBs */
    /**/
    CALL M$OPEN( OPEN_ME )  ALTRET( CALL_ERRMSG );  /* OPEN M$ME -> ME        */
    CALL OPEN( M$LO# )      ALTRET( CALL_ERRMSG );
    CALL M$UNFID( UNFID_LO )ALTRET( CALL_ERRMSG );
    CALL XUR$INIT( XUR_INIT );
    CALL XUR$SETDCBS( M$SI#,M$LO#, , )  ALTRET( CALL_ERRMSG );
%EJECT;
    /**/
    /*  Get dynamic buffers and initialize PTRs to them */
    /**/
    BUF_= VECTOR(NIL);
    CALL EXPAND( BUF_,3072 )  ALTRET( CALL_ERRMSG );
    FPARAM$= BUF_.PTR$;                       /* FPARAM gets the first K      */
    GRAN$= PINCRW( FPARAM$,1024 );            /* GRAN gets the next K         */
    ME_BUF$= PINCRW( GRAN$,1024 );            /* ME_BUF gets 772 bytes        */
    SYMO_BUF$= PINCRC( ME_BUF$,772 );         /* SYMO_BUF gets 764 bytes      */
    FIT$= PINCRW( FPARAM$,SIZEW(FM$GRAN) );   /* FIT$ starts past FM$GRAN stuf*/
    PLATEN$= PINCRC( SYMO_BUF$,1 );
 
    /**/
    /* Initialize FPT vectors that frame non-STATIC items */
    /**/
    F_FDS.BUF_= VECTOR(ME_BUF);
    TEST_SYMO.NAME_= VECTOR(CUR_FILE);
    OPEN_SYMO.FPARAM_= VECTOR(FPARAM);
    READ_SYMO.BUF_= VECTOR(FPARAM);
    READ_GRAN.BUF_= VECTOR(GRAN);
 
    FIRSTLINE_= VECTOR(PLATEN.FIRSTLINE);
    LENGTH_= VECTOR(PLATEN.LENGTH);
    LIMBO_= VECTOR(PLATEN.LIMBO);
    LPI_= VECTOR(PLATEN.LPI);
    WIDTH_= VECTOR(I);
 
    TY_LEFT= -1;
    TY_RIGHT= -1;
    IF B$JIT.SYSID < 100000 THEN              /* If we can, make SYSIDs       */
       SUBSTR(FORMAT9,1,1)= '5';              /* 5 digits.                    */
    USING_JOBSTATS= %YES#;
%EJECT;
    LIST= '0'B;                               /* Assume they can't do anything*/
    EXAMINE= '0'B;                            /* Assume they can't do anything*/
    IF (B$JIT.PRIV.AUTH & (%PR_FMREAD# | %PR_FMSEC#)) OR
       (B$JIT.PRIV.ACTIVE & (%PR_FMREAD# | %PR_FMSEC#)) THEN DO;
       LIST.AUTH= %YES#;                      /* Note that they can LIST and  */
       EXAMINE.AUTH= %YES#;                   /* EXAMINE other users output.  */
       IF B$JIT.PRIV.JOB & (%PR_FMREAD# | %PR_FMSEC#) THEN DO;
          LIST.ACTIVE= %YES#;                 /* Indicate that they want to.  */
          EXAMINE.ACTIVE= %YES#;
          END;
       END;
    ELSE
       IF B$JIT.PRIV.AUTH & %PR_DISPJOB# THEN DO;
          LIST.AUTH= %YES#;                   /* Remember they can LIST others*/
          IF B$JIT.PRIV.JOB & %PR_DISPJOB# THEN
             LIST.ACTIVE= %YES#;              /* Note that DISPJOB was ON     */
          END;
 
    /**/
    /*  Determine which FMSEC to turn on and off later */
    /**/
    IF B$JIT.PRIV.JOB & %PR_FMSEC# THEN   /* If THEY had FMSEC on, don't ever */
       FMSEC_PRIV.V.PRIV#= FMSEC_PRIV.V.PRIV# & (~%PR_FMSEC#);  /* turn it OFF*/
    ELSE
       IF B$JIT.PRIV.PRC & %PR_FMSEC# THEN
          FMSEC_PRIV.V.AUTH#= %NO#;              /* Use PRoCessor privelege      */
       ELSE
          FMSEC_PRIV.V.AUTH#= %YES#;             /* Use the USERs privelege      */
    IF (B$JIT.PRIV.AUTH & %PR_FMSEC#)  OR
       (B$JIT.PRIV.PRC  & %PR_FMSEC#)  THEN
       ;
    ELSE DO;
       OPEN_SYMO.V.OPER.TEST#= %NO#;          /* READ the FIT                 */
       CALL M$SPRIV( FMREAD_PRIV );           /* Try to turn on FMREAD        */
       END;
%EJECT;
    /**/
    /*  Determine which FMDIAG to turn on and off later */
    /**/
    IF B$JIT.PRIV.PRC & %PR_FMDIAG# THEN
       FMDIAG_PRIV.V.AUTH#= %NO#;             /* Use PRoCessor privelege      */
    ELSE
       FMDIAG_PRIV.V.AUTH#= %YES#;            /* Use the USERs privelege      */
 
    LO_NE_ME= %NO#;                           /* Assume M$LO = M$ME           */
    CALL M$CORRES( LO_VS_ME )  ALTRET( GREET_THEM );
    LO_NE_ME= %YES#;                          /* On second thought...         */
GREET_THEM:
    CALL PARSE_CCBUF  ALTRET( OOPS );      /* If anythings in CCBUF; Parse it */
    CALL WRITE( GREETING,LENGTHC(GREETING),M$ME# );  /* BASS C00 here (date)  */
    IF LO_NE_ME  AND  NOT B$JIT.PRFLAGS.LS THEN DO;
       /* Warning: BASSes primary output (M$LO) is externally SET to ...      */
       CALL X$WRITE( F_FDS,FMT5_,VECTOR(PREV_LO_FID) );
       CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),M$ME# );
       END;
    CALL M$INT( BREAK_CNTRL )  ALTRET( CALL_ERRMSG );  /* Take BReaK control  */
 
    CALL M$MONINFO( FPT_MONINFO )  ALTRET( CALL_ERRMSG );
 
    OPT= '0'B;
    OPT.FLAG(%INTERPRET##)= %YES#;
    OPT.FLAG(%DVBYTE##)= %YES#;
    GDS_= VECTOR(NIL);
    CALL EXPAND( GDS_,1024 )  ALTRET( CALL_ERRMSG );
 
    EXTNT_= VECTOR(NIL);
    CALL EXPAND( EXTNT_,1024 )  ALTRET( CALL_ERRMSG );
    MAX_EXTNTS = (EXTNT_.W1.VSIZE# + 1) / LENGTHC(EXTNT(0));
 
    NUM_SELECTED= 0;
    NUM_FOUND= 0;
    RETURN;
 
CALL_ERRMSG:
    CALL REPORT_ERR;
OOPS:
    ALTRETURN;
 
END INITIALIZE;
%EJECT;
OPEN: PROC( DCB# )  ALTRET;
DCL DCB#                     UBIN;
 
    FPT_OPEN.V.DCB#= DCB#;
    CALL M$OPEN( FPT_OPEN )  ALTRET( OOPS );
    RETURN;
 
OOPS:
    ALTRETURN;
 
END OPEN;
%EJECT;
WRITE: PROC( BUF,LEN,DCB1#,DCB2#,VFC )  ALTRET;
DCL BUF                      CHAR(BUFLEN);
DCL LEN                      SBIN;
DCL DCB1#                    UBIN;
DCL DCB2#                    UBIN;
DCL VFC                      CHAR(1);
 
DCL BUFLEN                   UBIN;
 
    IF LEN < 0 THEN DO;                   /* Should we figure out the length? */
       BUFLEN= -LEN;
       CALL SEARCHR( BUFLEN,TABLEVAL,SKIP_BLANKS,BUF )  ALTRET( BLANK_LINE );
       BUFLEN= BUFLEN+1;
       END;
    ELSE
       IF LEN = 0 THEN
BLANK_LINE:
          BUFLEN= LENGTHC(' ');
       ELSE
          BUFLEN= LEN;
 
    FPT_WRITE.BUF_= VECTOR(BUF);              /* Frame what we will WRITE     */
    IF ADDR(VFC) = ADDR(NIL) THEN
       FPT_WRITE.V.DVBYTE.VFC#= %NO#;
    ELSE
       FPT_WRITE.V.DVBYTE.VFC#= %YES#;
    IF ADDR(DCB1#) ~= ADDR(NIL) THEN DO;      /* If DCB1 was specified,       */
       FPT_WRITE.V.DCB#= DCB1#;
       CALL M$WRITE( FPT_WRITE )  ALTRET( OOPS );   /* WRITE through it       */
       END;
 
    IF ADDR(DCB2#) ~= ADDR(NIL)  AND  LO_NE_ME THEN DO;
       FPT_WRITE.V.DCB#= DCB2#;
       CALL M$WRITE( FPT_WRITE )  ALTRET( OOPS );
       END;
    RETURN;
 
OOPS:
    ALTRETURN;
 
END WRITE;
%EJECT;
PARSE_CCBUF: PROC  ALTRET;
 
    IF B$JIT.PROG_ENTRY = %PE_LINK# THEN      /* Were we M$LINKed to?         */
       CALL INDEX1( I,'(',B$JIT.CCBUF );      /* Find the '(' the hard way    */
    ELSE
       I= B$JIT.CCDISP;
    CMD_NUM= 0;
    NUM_CMDS= 0;
    IF I < B$JIT.CCARS THEN DO;               /* Any left paren found in CCBUF*/
       CCBUF_CMD= %YES#;                      /* Tell GET_A_CMD it's in CCBUF */
       IF SUBSTR(B$JIT.CCBUF,I) = '(' THEN DO;/* Anything past the '('?       */
          ERR_BUF= 'L .';                     /* Nope.  Use 'L .' as default  */
          J= LENGTHC('L .');
          END;
       ELSE DO;
          I= I+LENGTHC('(');                  /* Skip the '('                 */
          J= B$JIT.CCARS - I;
          ERR_BUF= SUBSTR(B$JIT.CCBUF,I,J);
          END;
       CALL XUR$GETCMD( BASS_NODES,BLK1$,,ERR_BUF,J )  ALTRET( PARSE_ERROR );
       CMD_NUM= -1;            /* Tell GET_A_CMD to process first cmd next */
       NUM_CMDS= BLK1_NSUBLKS;
       END;
    ELSE
       CCBUF_CMD= %NO#;                 /* Tell GET_A_CMD it's NOT from CCBUF */
    RETURN;
 
PARSE_ERROR:
    NUM_CMDS= 0;
    ERRCODE= PERRCODE;
    IF NOT ERRCODE.MON  AND
       ERRCODE.ERR# = %E$SYNERR THEN DO;
         J= LENGTHC('!') + B$JIT.CCDISP + P_PCB.HI_CHAR;
         CALL XUR$ERRPTR( J,M$ME# );
         END;
    CALL XUR$ERRMSG( ERRCODE );
    ALTRETURN;
 
END PARSE_CCBUF;
%EJECT;
GET_A_CMD: PROC  ALTRET;
 
ANOTHER:
    CMD_NUM= CMD_NUM + 1;
    IF CMD_NUM >= NUM_CMDS THEN               /* Are we out of commands?      */
       IF CCBUF_CMD THEN DO;                  /* Yep; Was command from CCBUF? */
          CMD#= %XIT##;                       /* Yep; Fake an END command     */
          GOTO RET;
          END;
       ELSE DO;                               /* Go get another command       */
          CMD_NUM= 0;
          CALL XUR$GETCMD(BASS_NODES,BLK1$,PROMPT_) ALTRET( SYNERR );
          CALL XUR$ECHOIF( M$LO# );
          NUM_CMDS= BLK1_NSUBLKS;
          END;
 
    BLK2$= BLK1_SUBLK$(CMD_NUM);
    IF BLK2_NSUBLKS > 0 THEN DO;
       BLK3$= BLK2_SUBLK$(0);
       IF BLK3_NSUBLKS > 0 THEN
          BLK4$= BLK3_SUBLK$(0);
       END;
 
    CMD#= BLK2_CODE;                     /* remember what command we're doing */
    OPT.FLAG(CMD#)= %YES#;
    DO CASE( CMD# );
       CASE( %ALLHELP## );                    /* ??                           */
 
       CASE( %BANNER## );
 
       CASE( %CANCEL## );
          CALL PARSE_WHAT;
       CASE( %CLOSE## );
 
       CASE( %COPY## );
 
       CASE( %DEBUG## );
 
       CASE( %DVBYTE## );
 
       CASE( %EXAMINE## );
          CALL PARSE_WHAT;
       CASE( %FID## );
 
       CASE( %FIND## );
          CALL PARSE_RANGE;
       CASE( %HELP## );
 
       CASE( %HOLD## );
          LDEV.V.STREAMNAME#= BLK3_TEXT;
       CASE( %INTERPRET## );
          OPT.FLAG(%NINTERPRET##)= %NO#;
       CASE( %JOBSTATS## );                   /* J/obstats                    */
 
       CASE( %LEFT## );
 
       CASE( %LIST## );
          CALL PARSE_WHAT;
       CASE( %ME## );
 
       CASE( %MOREHELP## );
 
       CASE( %NBANNER## );
 
       CASE( %NDVBYTE## );
          OPT.FLAG(%DVBYTE##)= %NO#;
       CASE( %NFID## );
          OPT.FLAG(%FID##)= %NO#;
       CASE( %NINTERPRET## );                 /* NI/nterpret                  */
          OPT.FLAG(%INTERPRET##)= %NO#;
       CASE( %NUC## );                        /* NUC                          */
 
       CASE( %NULL## );
          IF M$PACKSET$->F$DCB.FCD# THEN
             IF M$SI$->F$DCB.EOMVAL#.VALUE# = %LINE_FEED# THEN DO;
                CMD#= %TN##;
                GOTO TN_1;
                END;
             ELSE
                ;
          ELSE
             CMD#= %MOREHELP##;
       CASE( %NVFC## );
 
       CASE( %OUTPUT## );
 
       CASE( %PAGEMODE## );
 
       CASE( %READ## );
          BLK3$= BLK2_SUBLK$(0);
          FID_STRING= BLK3_TEXT;
       CASE( %RECORDMODE## );
 
       CASE( %RIGHT## );
 
       CASE( %SE## );
          CALL PARSE_RANGE;
          IF BLK2_NSUBLKS = 0 THEN DO;
             REC1= BANNER_BIAS + 1;
             REC2= TOTAL_NRECS;
             END;
 
       CASE( %SPACE## );
 
       CASE( %STATUS## );
 
       CASE( %SYMO## );
 
       CASE( %SYSTEM## );
 
       CASE( %TC## );
          TYPE= %TC##;
          CALL PARSE_RANGE;
       CASE( %TN## );
          IF BLK2_NSUBLKS > 0 THEN
             CALL CHARBIN( I,BLK3_TEXT );
          ELSE
TN_1:
             I= 1;
          IF REC2 >= TOTAL_NRECS THEN DO;
             /* EOF hit after record %D */
             CALL X$WRITE( F_FDS,FMT13_,NRECS_ );
             CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
             CMD#= %NULL##;                   /* Tell MAIN LINE to ignore this*/
             END;
          ELSE DO;
             REC1= REC2 + 1;
             REC2= REC2 + I;
             IF REC2 > TOTAL_NRECS THEN
                   REC2= TOTAL_NRECS;
             END;
       CASE( %TO## );
          TYPE= %TO##;
          CALL PARSE_RANGE;
       CASE( %TP## );
          IF BLK2_NSUBLKS > 0 THEN
             CALL CHARBIN( I,BLK3_TEXT );
          ELSE
             I= 1;
          IF REC1 <= 1 THEN DO;
             /* .. Beginning-Of-File hit. */
             CALL X$WRITE( F_FDS,FMT14_ );
             CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
             CMD#= %NULL##;
             END;
          ELSE DO;
             REC2= REC1 - 1;
             REC1= REC1 - I;
             IF REC1 < 1 THEN
                   REC1= 1;
             END;
       CASE( %TS## );
          TYPE= %TS##;
          CALL PARSE_RANGE;
       CASE( %TV## );
          TYPE= %TV##;
          CALL PARSE_RANGE;
       CASE( %TY## );
          TYPE= %TY##;
          CALL PARSE_RANGE;
       CASE( %UC## );
 
       CASE( %UNHOLD## );
          CALL CHARBIN( UNHOLDF.V.SYSID#,BLK3_TEXT );
          BLK3$= BLK2_SUBLK$(1);
          CALL CHARBIN( I,BLK3_TEXT );
          UNHOLDF.V.NUM#= I;
       CASE( %VFC## );
 
       CASE( %WIDTH## );
 
       CASE( %XIT## );
 
       END;  /* end DO CASE( CMD# ); */
RET:
    RETURN;
 
SYNERR:
    NUM_CMDS= 0;
    ERRCODE= PERRCODE;
    CALL XUR$ECHOIF( M$LO# );
    IF NOT ERRCODE.MON THEN
       IF ERRCODE.ERR# = %E$SYNERR THEN DO;
          I= P_PCB.HI_CHAR;
          CALL XUR$ERRPTR( I,M$LO# );
          IF LO_NE_ME THEN
             CALL XUR$ERRPTR( ,M$ME# );
          END;
       ELSE
          ;
    ELSE DO;
       DONE= %YES#;
       IF ERRCODE.ERR# = %E$EOF THEN
          GOTO ALT_RETURN;
       END;
OOPS:
    CALL XUR$ERRMSG( ERRCODE );
    IF ERRCODE.ERR# = %E$DI THEN              /* Noisy line?                  */
       GOTO ANOTHER;                          /* Yep, just go read again.     */
ALT_RETURN:
    ALTRETURN;
 
END GET_A_CMD;
%EJECT;
PARSE_WHAT: PROC  ALTRET;
 
    ONE_SHOT= %YES#;                  /* Assume we won't have to search :SYMO */
    CRITERIA= '0'B;
    CRITERIA.ACCT= ' ';
    CRITERIA.DEV= ' ';
    CRITERIA.FORM= ' ';
    CRITERIA.JOBNAME= ' ';
    CRITERIA.TNAME= ' ';
    CRITERIA.NUM= -1;
    CRITERIA.SYSID= -1;
    CRITERIA.PRIO= -1;
    DO I=0 TO BLK2_NSUBLKS-1;
       BLK3$= BLK2_SUBLK$(I);
       IF BLK3_NSUBLKS > 0 THEN
          BLK4$= BLK3_SUBLK$(0);
       DO CASE( BLK3_CODE );
          CASE( %SYSID## );
             IF BLK3_NSUBLKS > 1 THEN DO;
                CRITERIA.NOT_SYSID= %YES#;
                ONE_SHOT= %NO#;
                BLK4$= BLK3_SUBLK$(1);
                END;
             ELSE
                CRITERIA.SYSID_FLAG= %YES#;
             CALL CHARBIN( CRITERIA.SYSID,BLK4_TEXT );
          CASE( %ACCT## );
             IF CRITERIA.JOBNAME = ' ' THEN   /* If no jobname, do it slow way*/
                ONE_SHOT= %NO#;
             CRITERIA.ACCT_FLAG= %YES#;
             IF BLK3_NSUBLKS = 0 THEN
                CRITERIA.ACCT= B$JIT.ACCN;
             ELSE
                IF BLK3_NSUBLKS = 1 THEN DO;
                   CRITERIA.ACCT_FLAG= %YES#;
                   CRITERIA.ACCT= BLK4_TEXT;
                   END;
                ELSE DO;
                   ONE_SHOT= %NO#;
                   CRITERIA.NOT_ACCT= %YES#;
                   CRITERIA.ACCT_FLAG= %NO#;
                   BLK4$= BLK3_SUBLK$(1);
                   CRITERIA.ACCT= BLK4_TEXT;
                   END;
             CALL INDEX1 (INDX,'?',CRITERIA.ACCT );
             IF INDX < LENGTHC(CRITERIA.ACCT) THEN
                CRITERIA.ACCT_WILD= %YES#;
          CASE( %WHAT_ME## );
             IF BLK3_NSUBLKS = 1 THEN DO;
                ONE_SHOT= %NO#;
                CRITERIA.NOT_SYSID= %YES#;
                END;
             ELSE
                CRITERIA.SYSID_FLAG= %YES#;
             CRITERIA.SYSID= B$JIT.SYSID;
          CASE( %LASTSYSID## );
             IF BLK3_NSUBLKS = 1 THEN DO;
                ONE_SHOT= %NO#;
                CRITERIA.NOT_SYSID= %YES#;
                END;
             ELSE
                CRITERIA.SYSID_FLAG= %YES#;
             CRITERIA.SYSID= B$JIT.LBJID;
          CASE( %JOBNAME## );
             CRITERIA.ACCT= B$JIT.ACCN;
             IF BLK3_NSUBLKS > 1 THEN DO;
                ONE_SHOT= %NO#;
                CRITERIA.NOT_JOBNAME= %YES#;
                BLK4$= BLK3_SUBLK$(1);
                END;
             ELSE
                CRITERIA.JOBNAME_FLAG= %YES#;
             CRITERIA.JOBNAME= BLK4_TEXT;
             CALL INDEX1( INDX,'?',BLK4_TEXT );
             IF INDX < LENGTHC(BLK4_TEXT) THEN
                ONE_SHOT= %NO#;
          CASE( %ANYTHING## );
             ONE_SHOT= %NO#;
             CRITERIA.ACCT= ' ';
             CRITERIA.ACCT_FLAG= %YES#;
          CASE( %DEV## );
             ONE_SHOT= %NO#;
             IF BLK3_NSUBLKS > 1 THEN DO;
                CRITERIA.NOT_DEV= %YES#;
                BLK4$= BLK3_SUBLK$(1);
                END;
             ELSE
                CRITERIA.DEV_FLAG= %YES#;
             CRITERIA.DEV= BLK4_TEXT;
             CALL INDEX1( INDX,'?',CRITERIA.DEV );
             IF INDX < LENGTHC(CRITERIA.DEV) THEN
                CRITERIA.DEV_WILD= %YES#;
          CASE( %WSN## );
             ONE_SHOT= %NO#;
             IF BLK3_NSUBLKS > 1 THEN DO;
                CRITERIA.NOT_TNAME= %YES#;
                BLK4$= BLK3_SUBLK$(1);
                END;
             ELSE
                CRITERIA.TNAME_FLAG= %YES#;
             CRITERIA.TNAME= BLK4_TEXT;
             CALL INDEX1( INDX,'?',CRITERIA.TNAME );
             IF INDX < LENGTHC(CRITERIA.TNAME) THEN
                CRITERIA.TNAME_WILD= %YES#;
          CASE( %NUM## );
             CALL CHARBIN( CRITERIA.NUM,BLK4_TEXT );
             CRITERIA.NUM_FLAG= %YES#;
          CASE( %FORM## );
             ONE_SHOT= %NO#;
             IF BLK3_NSUBLKS > 1 THEN DO;
                CRITERIA.NOT_FORM= %YES#;
                BLK4$= BLK3_SUBLK$(1);
                END;
             ELSE
                CRITERIA.FORM_FLAG= %YES#;
             CRITERIA.FORM= BLK4_TEXT;
             CALL INDEX1( INDX,'?',CRITERIA.FORM );
             IF INDX < LENGTHC(CRITERIA.FORM) THEN
                CRITERIA.FORM_WILD= %YES#;
          END;  /* end DO CASE( BLK3_CODE ); */
       END;
 
    IF BLK2_NSUBLKS = 0 THEN                  /* Any thing past EXAMINE?      */
       ONE_SHOT= %NO#;                        /* Nope, do things the slow way */
 
    IF NOT USING_JOBSTATS THEN       /* Should we use M$JOBSTATS if possible? */
       ONE_SHOT= %NO#;               /* Nope.                                 */
 
    IF ONE_SHOT  AND  CRITERIA.JOBNAME_FLAG THEN DO; /* Find sysid            */
       XSJ_NAMEKEY.ACCT#= CRITERIA.ACCT;
       XSJ_NAMEKEY.JOBNAME#= CRITERIA.JOBNAME;
       CALL M$READ( READ_JOBNAME )
       WHENRETURN DO;
          CRITERIA.SYSID= XSJ_NAMEREC.SYSID#;
          END;
       WHENALTRETURN DO;
          ONE_SHOT= %NO#;                   /* Could be a ghost, be thorough! */
          END;
       END;
 
    RETURN;
 
END PARSE_WHAT;
%EJECT;
CALL_JOBSTATS: PROC  ALTRET;
 
    OSRCH_RESULTS_= GDS_;
    JOBSTATS.RESULTS_= OSRCH_RESULTS_;
 
    DO WHILE('0'B);
JOBSTATS_ERR:
       ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
       IF ERRCODE.ERR# ~= %E$NOTFND THEN
          IF ERRCODE.ERR# = %E$JSIRAS  OR
             ERRCODE.ERR# = %E$BADVECT2 THEN DO;
             CALL EXPAND( GDS_,(GDS_.W1.VSIZE#+3)/4 )  ALTRET( CANT_GDS );
             END;
          ELSE DO;
             CALL REPORT_ERR;
             GOTO OOPS;
             END;
       ELSE
          GOTO ZERO_JOBS;
       OSRCH_RESULTS_= GDS_;
       JOBSTATS.RESULTS_= OSRCH_RESULTS_;
       END;
 
    CALL M$JOBSTATS( JOBSTATS )  ALTRET( JOBSTATS_ERR );
CONTINUE:
    IF OSRCH_RESULTS_.PTR$ = ADDR(NIL) THEN DO;
ZERO_JOBS:
       NUM_JOBS= 0;
       TOTAL_JOBS= 0;
       END;
    ELSE DO;
       NUM_JOBS= OSRCH_RESULTS_.PTR$ -> R$OUTPUT.FOUND;
       TOTAL_JOBS= NUM_JOBS;
       END;
    RETURN;
 
CANT_GDS:
    I= GDS_.W1.VSIZE#+1;
    /* .. Warning: The %D words of memory I got for the QUEUE wasn't enough   */
    CALL X$WRITE( F_FDS,FMT10_,VECTOR(I) );
    CALL WRITE( ME_BUF,-LENGTHC(ME_BUF),,M$ME# );
    OSRCH_RESULTS_= GDS_;
    CALL M$JOBSTATS( JOBSTATS )  ALTRET( CONTINUE );
    GOTO CONTINUE;
 
OOPS:
    ALTRETURN;
 
END CALL_JOBSTATS;
%EJECT;
CLOSE: PROC( DCB# );
DCL DCB#                     UBIN;
 
    IF DCB# = M$PACKSET# THEN
       CALL M$RPRIV( FMDIAG_PRIV );           /* Turn off FMDIAG              */
    IF DCBADDR(DCB#)->F$DCB.FCD# THEN DO;
       FPT_CLOSE.V.DCB#= DCB#;
       CALL M$CLOSE( FPT_CLOSE )  ALTRET( SO_WHAT );
       END;
SO_WHAT:
    RETURN;
 
END CLOSE;
%EJECT;
COMPRESS: PROC( TEXT,LENGTH );
DCL TEXT                     CHAR(LENGTH);
DCL LENGTH                   UBIN;
 
DCL BEG                      UBIN      STATIC;
DCL LAST                     UBIN      STATIC;
DCL LEN                      UBIN      STATIC;
DCL NEW_LEN                  UBIN      STATIC;
DCL OLD_LEN                  UBIN      STATIC;
 
    CALL INDEX2( BEG,'  ',TEXT )  ALTRET( BYE );    /* Anything to do?        */
    BEG= 0;
    NEW_LEN= 0;
    OLD_LEN= LENGTH;
    DO WHILE( BEG < OLD_LEN );
       CALL SEARCH( BEG,TABLEVAL,SKIP_BLANKS,TEXT,BEG )  ALTRET( FILL );
       CALL INDEX2( LAST,'  ',TEXT,BEG );
       LEN= LAST - BEG + 1;
       SUBSTR(TEXT,NEW_LEN,LEN)= SUBSTR(TEXT,BEG,LEN);
       BEG= LAST + LENGTHC('  ');                   /* Point past the '  '    */
       NEW_LEN= NEW_LEN + LEN;
       END;
 
FILL:
    SUBSTR(TEXT,NEW_LEN)= ' ';                      /* Clear the rest of TEXT */
    LENGTH= NEW_LEN;                       /* return COMPRESsed string length */
BYE:
    RETURN;
 
END COMPRESS;
%EJECT;
PARSE_RANGE: PROC;
 
    TY_LEFT= -1;
    TY_RIGHT= -1;
    IF BLK2_NSUBLKS <= 0 THEN
       GOTO RE_TURN;
    DO I=0 TO BLK2_NSUBLKS-1;
       BLK3$= BLK2_SUBLK$(I);
       IF BLK3_CODE = %RANGE## THEN DO;
          REC1= -1;
          REC2= -1;
          END;
       IF BLK3_CODE = %STRING## THEN DO;
          STR= BLK3_TEXT;
          STR_LEN= BLK3_COUNT;
          END;
       DO J=0 TO BLK3_NSUBLKS-1;
          BLK4$= BLK3_SUBLK$(J);
          IF BLK4_NSUBLKS > 0 THEN
             BLK5$= BLK4_SUBLK$(0);
          DO CASE( BLK4_CODE );
             CASE( %REC1## );
                IF BLK5_CODE = %RECNUM## THEN DO;
                   CALL CHARBIN( REC1,BLK5_TEXT );
                   IF REC1 = 0 THEN
                      REC1= BANNER_BIAS + 1;
                   ELSE
                      REC1= BANNER_BIAS + REC1;
                   END;
                ELSE
                   IF BLK5_CODE = %BOF## THEN
                      REC1= BANNER_BIAS + 1;
                   ELSE
                      REC1= TOTAL_NRECS;
                IF J = BLK3_NSUBLKS-1 THEN       /* Anything past REC1?          */
                   REC2= REC1;                   /* No.  Make REC2 = REC1        */
             CASE( %DASH## );
                IF REC1 = -1 THEN
                   REC1= BANNER_BIAS + 1;
                IF J = BLK3_NSUBLKS-1 THEN       /* If nothing past the '-'      */
                   REC2= TOTAL_NRECS;            /* make REC2 = last-record-num  */
             CASE( %REC2## );
                IF BLK5_CODE = %RECNUM## THEN DO;
                   CALL CHARBIN( REC2,BLK5_TEXT );
                   IF NOT OPT.FLAG(%BANNER##) THEN
                      REC2= REC2 + BANNER_BIAS;
                   END;
                ELSE
                   IF BLK5_CODE = %BOF## THEN
                      REC2= BANNER_BIAS + 1;
                   ELSE
                      REC2= TOTAL_NRECS;
             CASE( %BEG_COL## );
                CALL CHARBIN( TY_LEFT,BLK4_TEXT );
             CASE( %END_COL## );
                CALL CHARBIN( TY_RIGHT,BLK4_TEXT );
             END;
          END;
       END;
RE_TURN:
    RETURN;
 
END PARSE_RANGE;
%EJECT;
DO_TYPES: PROC;
 
    CALL POSITION_FILE  ALTRET( RE_TURN );
 
    DO WHILE( REC# <= REC2 );
GET_A_SYMO_REC:
       CALL PRINT_IT( 0 );
       CALL READ_SYMO_REC  ALTRET( RE_TURN );
       END;
    IF K = %TV## THEN
       CALL WRITE( ' ',LENGTHC(' '),M$LO# );
 
RE_TURN:
    RETURN;
 
END DO_TYPES;
%EJECT;
PRINT_IT: PROC( CMND );
DCL CMND                     UBIN;
 
    CALL SET_MARGINS( CMND );
    CALL BINCHAR( INT6,REC#-BANNER_BIAS );
    CALL EDITSTR( INT6,0,5,'105'O,INT6 );
    IF CMD# = %TN##  OR  CMD# = %TP##  OR  CMD# = %FIND## THEN
       K= TYPE;
    ELSE
       K= CMD#;
    IF K = %TO## THEN DO;
       CALL DUMP_OCTAL;
       GOTO RE_TURN;
       END;
    IF OPT.FLAG(%VFC##) THEN
       IF K = %TC## THEN DO;
          CALL CONCAT( ME_BUF,INT6,' - ',VFC,SUBSTR(SYMO_BUF,L,LEN) );
          CALL COMPRESS( SUBSTR(ME_BUF,10),LEN );
          END;
       ELSE
          IF K = %TY## THEN
             CALL CONCAT( ME_BUF,INT6,' - ',VFC,SUBSTR(SYMO_BUF,L,LEN) );
          ELSE
             IF K = %TS## THEN
                CALL CONCAT( ME_BUF,VFC,SUBSTR(SYMO_BUF,L,LEN) );
             ELSE
                IF K = %TV## THEN
                   ME_BUF= SYMO_BUF;
                ELSE
                   CALL CONCAT( ME_BUF,VFC,'<<OOPS>>',SUBSTR(SYMO_BUF,L,LEN) );
    ELSE
       IF K = %TC## THEN DO;
          CALL CONCAT( ME_BUF,INT6,' - ',SUBSTR(SYMO_BUF,L,LEN) );
          CALL COMPRESS( SUBSTR(ME_BUF,9),LEN );
          END;
       ELSE
          IF K = %TY## THEN
             CALL CONCAT( ME_BUF,INT6,' - ',SUBSTR(SYMO_BUF,L,LEN) );
          ELSE
             IF K = %TS## THEN
                ME_BUF= SUBSTR(SYMO_BUF,L,LEN);
             ELSE
                IF K = %TV## THEN
                   ME_BUF= SYMO_BUF;
                ELSE
                   CALL CONCAT( ME_BUF,'<<OOPS>>',SUBSTR(SYMO_BUF,L,LEN) );
    CALL SEARCHR( ME_LEN,TABLEVAL,SKIP_BLANKS,ME_BUF );
    IF ME_LEN = LENGTHC(ME_BUF) THEN
       ME_LEN= LENGTHC(' ');
    CALL SEARCH( INDX,TABLEVAL,FIND_NONPRINTABLES,SUBSTR(ME_BUF,0,ME_LEN) )
                                                             ALTRET( LOOKS_OK );
    CALL XLATE( SUBSTR(ME_BUF,0,ME_LEN),XLATE_TAB,SUBSTR(ME_BUF,0,ME_LEN) );
LOOKS_OK:
    IF SUBSTR(SYMO_BUF,0,1) = BITASC('033'O)  AND
       OPT.FLAG(%INTERPRET##)  THEN DO;
       IF PLATEN.EXTWID  AND  PLATEN.WIDTH ~= 255 THEN
          I= PLATEN.WIDTH + 254;
       ELSE
          I= PLATEN.WIDTH;
       CALL X$WRITE( F_FDS,FMT11_,WIDTH_,LENGTH_,LIMBO_,FIRSTLINE_,LPI_ );
       END;
    ELSE
       IF K = %TV## THEN
          CALL WRITE( ME_BUF,SYMO_ARS,M$LO#,,SUBSTR(SYMO_BUF,0,1) );
       ELSE
          IF SUBSTR(SYMO_BUF,0,1) = BITASC('021'O)  AND
             OPT.FLAG(%INTERPRET##)  THEN DO;
             I= REC# - BANNER_BIAS;
             J= 0;
             DO WHILE( J<22  AND  TAB.TABS#(J)>0 );
                J= J+1;
                END;
             J= J-1;
             IF J>0 THEN DO;
                CALL X$WRITE( F_FDS,FMT37_,VECTOR(I),VECTOR(TAB.MARGIN#),
                                       VECTOR(TAB.TABS#(0)),
                                       VECTOR(J),
                                       VECTOR(TAB.TABS#(1)),
                                       VECTOR(TAB.TABS#(2)),
                                       VECTOR(TAB.TABS#(3)),
                                       VECTOR(TAB.TABS#(4)),
                                       VECTOR(TAB.TABS#(5)),
                                       VECTOR(TAB.TABS#(6)),
                                       VECTOR(TAB.TABS#(7)),
                                       VECTOR(TAB.TABS#(8)),
                                       VECTOR(TAB.TABS#(9)),
                                       VECTOR(TAB.TABS#(10)),
                                       VECTOR(TAB.TABS#(11)),
                                       VECTOR(TAB.TABS#(12)),
                                       VECTOR(TAB.TABS#(13)),
                                       VECTOR(TAB.TABS#(14)),
                                       VECTOR(TAB.TABS#(15)),
                                       VECTOR(TAB.TABS#(16)) );
                END;
             ELSE
                CALL X$WRITE( F_FDS,FMT38_,VECTOR(I),VECTOR(TAB.MARGIN#) );
             END;
          ELSE
             CALL WRITE( ME_BUF,-LENGTHC(ME_BUF),M$LO# );
RE_TURN:
    RETURN;
 
END PRINT_IT;
%EJECT;
FIND_STRING: PROC  ALTRET;
 
    NUM_MATCHES= 0;
    NUM_FOUND= 0;
    CALL POSITION_FILE  ALTRET( OOPS );
 
    DO WHILE( REC# <= REC2 );
       NUM_FOUND= NUM_FOUND + 1;
       CALL SET_MARGINS( 0 );
       CALL INDEX(INDX,SUBSTR(STR,0,STR_LEN),SUBSTR(SYMO_BUF,L,LEN))
                                                             ALTRET( NEXT_REC );
       NUM_MATCHES= NUM_MATCHES + 1;
       CALL PRINT_IT( %FIND## );
NEXT_REC:
       CALL READ_SYMO_REC  ALTRET( RE_TURN );
       END;
 
RE_TURN:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END FIND_STRING;
%EJECT;
REPORT_ERR: PROC( ERR,DCB# )  ALTRET;
DCL ERR                      BIT(36)          ALIGNED;
DCL DCB#                     UBIN;
 
    IF ADDR(ERR) = ADDR(NIL) THEN
       ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    ELSE
       ERRCODE= ERR;
    IF ADDR(DCB#) = ADDR(NIL) THEN
       ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
    ELSE
       ERRMSG.V.DCB#= DCB#;
    CALL M$ERRMSG( ERRMSG );
    ALTRETURN;
 
END REPORT_ERR;
%EJECT;
DO_OUTPUT: PROC;
 
    CALL M$RPRIV( FMSEC_PRIV );      /* Turn OFF the FMSEC priv while OPENing */
    OPEN_LO.V.EXIST#= %ERROR#;     /* By default, don't clobber existing file */
    DO I=0 TO BLK2_NSUBLKS-1;
      BLK3$= BLK2_SUBLK$(I);
      DO CASE( BLK3_CODE );
        CASE( %ON## );
          /* Done by default above */
        CASE( %OVER## );
          OPEN_LO.V.EXIST#= %NEWFILE#;
        CASE( %INTO## );
          OPEN_LO.V.EXIST#= %OLDFILE#;
        CASE( %WHERE## );
          FID_STRING= BLK3_TEXT;
        END;
      END;
 
    FID_LO.V.SCRUB= '111111'B;          /* Scrub: NAME,ACCT,PASS,SN,WSN & RES */
    CALL M$FID( FID_LO )  ALTRET( CALL_ERRMSG );
    CALL CLOSE( M$LO# );
    CALL M$OPEN( OPEN_LO )  ALTRET( REOPEN_LO );
    PREV_LO_FID= FID_STRING;
    LO_NE_ME= %NO#;
    CALL M$CORRES( LO_VS_ME )  ALTRET( RE_TURN );
    LO_NE_ME= %YES#;
    GOTO RE_TURN;
 
REOPEN_LO:
    CALL REPORT_ERR;
    FID_STRING= PREV_LO_FID;
    CALL M$FID( FID_LO )  ALTRET( CALL_ERRMSG );
    OPEN_LO.V.EXIST#= %OLDFILE#;
    CALL M$OPEN( OPEN_LO )  ALTRET( CALL_ERRMSG );
    GOTO RE_TURN;
 
CALL_ERRMSG:
    CALL REPORT_ERR;
RE_TURN:
    RETURN;
 
END DO_OUTPUT;
%EJECT;
EVAL_CRITERIA: PROC  ALTRET;
 
CHK_ACCT:
       IF CRITERIA.ACCT ~= '        ' THEN       /* Was .account specified?   */
          IF CRITERIA.ACCT_WILD THEN DO;
             CALL WILD_COMP( CRITERIA.ACCT,8,ACCT )  ALTRET( CHK_ACCT_FLAG );
             GOTO CHK_NOT_ACCT;
             END;
          ELSE
             IF ACCT = CRITERIA.ACCT THEN
CHK_NOT_ACCT:
                IF CRITERIA.NOT_ACCT THEN
                   GOTO GET_NEXT_ENTRY;
                ELSE
                   GOTO CHK_DEV;
             ELSE
CHK_ACCT_FLAG:
                IF CRITERIA.ACCT_FLAG THEN
                   GOTO GET_NEXT_ENTRY;
 
CHK_DEV:
       IF CRITERIA.DEV ~= '        ' THEN       /* Was 'dev' specified?      */
          IF CRITERIA.DEV_WILD THEN DO;
             CALL WILD_COMP( CRITERIA.DEV,2,DEV )  ALTRET( CHK_DEV_FLAG );
             GOTO CHK_NOT_DEV;
             END;
          ELSE
             IF DEV = CRITERIA.DEV THEN
CHK_NOT_DEV:
                IF CRITERIA.NOT_DEV THEN
                   GOTO GET_NEXT_ENTRY;
                ELSE
                   GOTO CHK_FORM;
             ELSE
CHK_DEV_FLAG:
                IF CRITERIA.DEV_FLAG THEN
                   GOTO GET_NEXT_ENTRY;
 
CHK_FORM:
       IF CRITERIA.FORM ~= '      ' THEN         /* Was 'form' specified?     */
          IF CRITERIA.FORM_WILD THEN DO;
             CALL WILD_COMP( CRITERIA.FORM,6,FORM )  ALTRET( CHK_FORM_FLAG );
             GOTO CHK_NOT_FORM;
             END;
          ELSE
             IF FORM = CRITERIA.FORM THEN
CHK_NOT_FORM:
                IF CRITERIA.NOT_FORM THEN
                   GOTO GET_NEXT_ENTRY;
                ELSE
                   GOTO CHK_JOBNAME;
             ELSE
CHK_FORM_FLAG:
                IF CRITERIA.FORM_FLAG THEN
                   GOTO GET_NEXT_ENTRY;
 
CHK_JOBNAME:
       IF CRITERIA.JOBNAME ~= ' ' THEN        /* Was 'jobname' specified?     */
          IF CRITERIA.JOBNAME_WILD THEN DO;
             CALL WILD_COMP( CRITERIA.JOBNAME,31,JOBNAME )
                                                     ALTRET( CHK_JOBNAME_FLAG );
             GOTO CHK_NOT_JOBNAME;
             END;
          ELSE
             IF JOBNAME = CRITERIA.JOBNAME THEN
CHK_NOT_JOBNAME:
                IF CRITERIA.NOT_JOBNAME THEN
                   GOTO GET_NEXT_ENTRY;
                ELSE
                   GOTO CHK_NUM;
             ELSE
CHK_JOBNAME_FLAG:
                IF CRITERIA.JOBNAME_FLAG THEN
                   GOTO GET_NEXT_ENTRY;
 
CHK_NUM:
       IF CRITERIA.NUM ~= -1 THEN         /* Was 'num' specified?        */
          IF NUM = CRITERIA.NUM THEN
CHK_NOT_NUM:
             IF CRITERIA.NOT_NUM THEN
                GOTO GET_NEXT_ENTRY;
             ELSE
                GOTO CHK_OUTPUTTING;
          ELSE
CHK_NUM_FLAG:
             IF CRITERIA.NUM_FLAG THEN
                GOTO GET_NEXT_ENTRY;
 
CHK_OUTPUTTING: ;
    /* IF CRITERIA.OUTPUTTING THEN
          IF A$OUTPUT.DEVNAME = '  ' THEN
             GOTO GET_NEXT_ENTRY; */
 
CHK_PRIO:
       IF CRITERIA.PRIO ~= -1       THEN         /* Was 'prio' specified?     */
          IF PRIO = CRITERIA.PRIO THEN
CHK_NOT_PRIO:
             IF CRITERIA.NOT_PRIO THEN
                GOTO GET_NEXT_ENTRY;
             ELSE
                GOTO CHK_SYSID;
          ELSE
CHK_PRIO_FLAG:
             IF CRITERIA.PRIO_FLAG THEN
                GOTO GET_NEXT_ENTRY;
CHK_SYSID:
       IF CRITERIA.SYSID ~= -1 THEN             /* Was 'sysid' specified?     */
          IF SYSID = CRITERIA.SYSID THEN
CHK_NOT_SYSID:
             IF CRITERIA.NOT_SYSID THEN
                GOTO GET_NEXT_ENTRY;
             ELSE
                GOTO CHK_TNAME;
          ELSE
CHK_SYSID_FLAG:
             IF CRITERIA.SYSID_FLAG THEN
                GOTO GET_NEXT_ENTRY;
CHK_TNAME:
       IF CRITERIA.TNAME ~= '      ' THEN         /* Was 'tname' specified?   */
          IF CRITERIA.TNAME_WILD THEN DO;
             CALL WILD_COMP( CRITERIA.TNAME,8,TNAME )  ALTRET( CHK_TNAME_FLAG );
             GOTO CHK_NOT_TNAME;
             END;
          ELSE
             IF TNAME = CRITERIA.TNAME THEN
CHK_NOT_TNAME:
                IF CRITERIA.NOT_TNAME THEN
                   GOTO GET_NEXT_ENTRY;
                ELSE
                   GOTO LOOKS_OK;
             ELSE
CHK_TNAME_FLAG:
                IF CRITERIA.TNAME_FLAG THEN
                   GOTO GET_NEXT_ENTRY;
 
LOOKS_OK: ;
     /*NUM_SELECTED= NUM_SELECTED + 1; */
RE_TURN:
    RETURN;
GET_NEXT_ENTRY:
    ALTRETURN;
 
END EVAL_CRITERIA;
%EJECT;
WILD_COMP: PROC( PATTERN,LEN,TARGET )  ALTRET;
DCL PATTERN                  CHAR(LEN);
DCL LEN                      UBIN;
DCL TARGET                   CHAR(LEN);
 
    %WILD_COMPARE( WILD_CHARS="PATTERN",
                   COMPARE_CHARS="TARGET",
                   NO_MATCH="GOTO DIDNT_MATCH" );
IT_MATCHED:
    RETURN;
 
DIDNT_MATCH:
    ALTRETURN;
 
END WILD_COMP;
%EJECT;
FIND_BANNER_SIZE: PROC;
 
    IF NOT M$PACKSET$->F$DCB.FCD# THEN
       GOTO RE_TURN;
 
    BANNER_BIAS= 0;
    CALL RESET_FILE_TO_BOF;
    DO WHILE( '1'B );
       CALL READ_SYMO_REC  ALTRET( SET_BANNER_BIAS );
       IF VFC = BITASC('021'O) THEN
          IF BANNER_BIAS = 0 THEN
             BANNER_BIAS= 1;
          ELSE
             EXIT;
       ELSE
          IF VFC = BITASC('033'O) THEN DO;
             IF PLATEN.EXTWID  AND  PLATEN.WIDTH ~= 255 THEN
                MAX_SYMO_LEN= PLATEN.WIDTH + 254;
             ELSE
                MAX_SYMO_LEN= PLATEN.WIDTH;
             IF WIDTH = 0 THEN
                WIDTH= LENGTHC('123456 - ') + PLATEN.WIDTH;
             END;
       END;
 
SET_BANNER_BIAS:
    IF NOT OPT.FLAG(%BANNER##) THEN
       BANNER_BIAS= REC#;
    ELSE
       BANNER_BIAS= 0;
    BANNER_LINES= REC#;                     /* Remember the # of BANNER lines */
    NRECS= TOTAL_NRECS - BANNER_BIAS;
RE_TURN:
    RETURN;
 
END FIND_BANNER_SIZE;
%EJECT;
SCAN_FILES: PROC  ALTRET;
 
    SYMO.LEN= 0;
    SYMO.NAME#= ' ';
    CALL M$OPEN( MERGE_SYMO );                /* Init DCB NAME# field to blank*/
    OPEN_SYMO.V.OPER.NXTF#= %YES#;
    OPEN_SYMO.NAME_= VECTOR(NIL);
    LINE= PAGE_SIZE + 1;                      /* Force page heading first time*/
    PREV_FIL.SYSID= '000000';
    NUM_FOUND= 0;                             /* Zero number of files found   */
    NUM_SELECTED= 0;                          /* Zero number of files selected*/
 
    DO WHILE('1'B);
       CALL OPEN_NEXT  ALTRET( END_OF_DIR );
       CALL CHECK_FILE ALTRET( NEXT_FILE );
       CALL LIST_FILE;
       CALL GET_FIT_INFO  ALTRET( NEXT_FILE );
       IF CUR_FIL.CHUNK = '000' THEN
          NUM_FOUND= NUM_FOUND + 1;
       CALL EVAL_CRITERIA  ALTRET( NEXT_FILE );
       PREV_FIL= CUR_FIL;
NEXT_FILE:
       END;
 
END_OF_DIR:
    ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
LIST_LAST_FILE:
    CALL LIST_FILE;
    IF ERRCODE.ERR# = %E$FDEOF THEN DO;       /* End of File Directory?       */
RE_TURN:
       RETURN;                                /* Yep.                         */
       END;
    ELSE DO;
       CALL REPORT_ERR;
       GOTO NEXT_FILE;
       END;
 
END SCAN_FILES;
%EJECT;
OPEN_NEXT: PROC  ALTRET;
 
    CALL M$SPRIV( FMSEC_PRIV );               /* [Try to] Turn on FMSEC       */
NEXT_FILE:
    CALL M$OPEN( OPEN_SYMO )  ALTRET( OPEN_ERR );  /* OPEN next file          */
    CUR_FILE= M$SYMO$->F$DCB.NAME#;           /* Remember the file name       */
    ERRCODE= '0'B;
    IF NOT (B$JIT.PRIV.ACTIVE & %PR_FMSEC#) THEN DO; /* Do we have FMSEC?     */
       CALL M$READ( READ_SYMO );              /* No.  READ the FIT to get     */
       CALL CLOSE( M$SYMO# );                 /* the CREATOR.ACCT             */
       END;
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
    RETURN;
 
OPEN_ERR:
    ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    IF ERRCODE.ERR# = %E$FILEBUSY THEN        /* Was file busy?               */
       GOTO NEXT_FILE;                        /* Yep; Forget it               */
    CUR_FILE= M$SYMO$->F$DCB.NAME#;           /* Remember the file name       */
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
    ALTRETURN;
 
END OPEN_NEXT;
%EJECT;
CHECK_FILE: PROC  ALTRET;
 
    IF M$SYMO$->F$DCB.ORG# ~= %SYMB# THEN     /* Is it a SYMbiont file?       */
       GOTO NOT_THIS_FILE;                    /* Nope!  Forget it.            */
 
    IF CUR_FILE.L ~= LENGTHC('BBBSSSSSSNNNNNNCCC') THEN
       GOTO NOT_THIS_FILE;                  /* File name not correct length   */
 
    CALL SEARCH( INDX,TABLEVAL,SKIP_DIGITS,SUBSTR(CUR_FILE.C,3,CUR_FILE.L-3) )
                                                     ALTRET( LOOKS_OK );
                                              /* Bad sysid,num or chunk #     */
 
NOT_THIS_FILE:
    ALTRETURN;
 
LOOKS_OK:
    RETURN;
 
END CHECK_FILE;
%EJECT;
LIST_FILE: PROC;
 
    IF PREV_FIL.SYSID = '000000' THEN
       GOTO RESET;
 
    IF CUR_FIL.SYSID = PREV_FIL.SYSID  AND
       CUR_FIL.NUM   = PREV_FIL.NUM   THEN
       GOTO RE_TURN;
 
    IF CMD# ~= %LIST## THEN
       GOTO CNT_THE_FILE;
 
    LINE= LINE + 1;
    IF LINE > PAGE_SIZE THEN DO;
       /* SYSID-NUM GRANS NRECS NPAGES DEV  WSN    NAME.ACCT */
       CALL X$WRITE( F_FDS,FMT8_ );
       LINE= 2;
       END;
 
    /* %6D-%D %11-%5D %5D %5D  %A %A %>A.%>A */
    CALL X$WRITE( F_FDS,FMT9_,SYSID_,NUM_,NGRANS_,NRECS_,NPAGES_,DEV_,TNAME_,
                              JOBNAME_,ACCT_ );
 
CNT_THE_FILE:
    NUM_SELECTED= NUM_SELECTED + 1;
    IF NUM_SELECTED = 1 THEN
       SELECTED_FILE= TMP_FILE;
 
RESET:
    PREV_FIL.SYSID= '000000';
    PREV_FIL.NUM=   '000000';
 
    NGRANS= 0;
    NRECS= 0;
 
RE_TURN:
    RETURN;
 
END LIST_FILE;
%EJECT;
GET_FIT_INFO: PROC  ALTRET;
 
    CODE01$= FIT$;
    CODE= 1;
    CALL XSF$LOCCODT( CODE01$,CODE )  ALTRET( NOT_THIS_FILE );
 
    CODE04$= FIT$;
    CODE= 4;
    CALL XSF$LOCCODT( CODE04$,CODE )  ALTRET( NOT_THIS_FILE );
    ACCT= CODE04$->CODE04.CREATOR.ACCT;
    UNAME= CODE04$->CODE04.CREATOR.NAME;
    IF NOT LIST.ACTIVE THEN                         /* Does he have DISPJOB?  */
       IF ACCT ~= B$JIT.ACCN  OR                         /* No.  Only let him */
          UNAME ~= B$JIT.UNAME  THEN                      /* see HIS output   */
          GOTO NOT_THIS_FILE;
 
 
    TMP_FILE= CUR_FILE;
    CALL CHARBIN( SYSID,CUR_FIL.SYSID );
    CALL CHARBIN( NUM,CUR_FIL.NUM );
 
    CODE03$= FIT$;
    CODE= 3;
    CALL XSF$LOCCODT( CODE03$,CODE )  ALTRET( NOT_THIS_FILE );
    NGRANS= NGRANS + CODE03$->CODE03.UGRANS;
    NRECS= NRECS + CODE03$->CODE03.NRECS;
 
    DEST$= FIT$;
    CODE= 13;
    CALL XSF$LOCCODT( DEST$,CODE )  ALTRET( NOT_THIS_FILE );
    DEV= DEST$->FS$DEST.DT.DEV;
    IF DEST$->FS$DEST.OUTSYMF.CWSN THEN       /* Was WSN changed?             */
       TNAME= DEST$->FS$DEST.NEWWSN;          /* Yep; Use NEW WSN             */
    ELSE
       TNAME= DEST$->FS$DEST.DT.WSN;          /* No; Use original WSN         */
    IF DEST$->FS$DEST.OUTSYMF.CPRIO THEN      /* Was PRIO changed?            */
       PRIO= DEST$->FS$DEST.NEWPRIO;          /* Yep; Use NEW prio            */
    ELSE
       PRIO= DEST$->FS$DEST.PRIO;             /* No;  Use the original PRIO   */
    JOBNAME= DEST$->FS$DEST.JOBNAME;
 
    IF M$SYMO$->F$DCB.CODE16$ = ADDR(NIL) THEN DO;
       CODE16$= FIT$;
       CODE= 16;
       CALL XSF$LOCCODT( CODE16$,CODE )  ALTRET( NOT_THIS_FILE );
       END;
    ELSE
       CODE16$= M$SYMO$->F$DCB.CODE16$;
    FORM= CODE16$->CODE16.FORM;
    NPAGES= CODE16$->CODE16.PAGENO;
    IF NPAGES = 0  AND  DEV = 'LP'  AND       /* Is it just a BANNER?         */
       NOT OPT.FLAG(%DEBUG##)  THEN
       GOTO NOT_THIS_FILE;                    /* Yep!  Ignore it.             */
 
RE_TURN:
    RETURN;
 
NOT_THIS_FILE:
    ALTRETURN;
 
END GET_FIT_INFO;
%EJECT;
BUILD_EXTENT_LIST: PROC;
 
    MAX_GRANS= NUM_GRANS + CODE03$->CODE03.UGRANS;
 
    DO I=0 TO CODE01$->CODE01.NXTNTS-1;
       DO J=0 TO CODE01$->CODE01.XTNT.XTNSIZE(I)-1;
          IF NUM_GRANS < MAX_GRANS THEN DO;
             IF NUM_GRANS >= MAX_EXTNTS - 2 THEN DO;
                CALL EXPAND( EXTNT_,1024 )  ALTRET( RE_TURN );
                MAX_EXTNTS = (EXTNT_.W1.VSIZE# + 1) / LENGTHC(EXTNT(0));
                END;
             NUM_GRANS= NUM_GRANS + 1;
             EXTNT.HASH(NUM_GRANS)= CODE01$->CODE01.HASH;
             EXTNT.SDA(NUM_GRANS)= CODE01$->CODE01.XTNT.XTNSDA(I)+J;
             EXTNT.REC#(NUM_GRANS)= 0;
             END;
          ELSE
             GOTO RE_TURN;
          END;
       END;
 
RE_TURN:
    RETURN;
 
END BUILD_EXTENT_LIST;
%EJECT;
OPEN_SYMO_FILE: PROC  ALTRET;
 
    OPEN_SYMO.V.OPER.NXTF#= %NO#;
    CUR_FILE= SELECTED_FILE;
    OPEN_SYMO.NAME_= VECTOR(CUR_FILE);
    NRECS= 0;
    NGRANS= 0;
    NUM_GRANS= -1;
    CALL RESET_FILE_TO_BOF;
    CALL M$SPRIV( FMSEC_PRIV );               /* Turn it on.                  */
    CALL CLOSE( DCBNUM(M$PACKSET) );
    PROMPT_= VECTOR(PROMPT1);
 
    DO K=0 TO 999;
       CALL CLOSE( M$SYMO# );
       CALL BINCHAR( CUR_FIL.CHUNK,K );
       CALL M$OPEN( OPEN_SYMO )  ALTRET( WHAT_NOW );
       IF NOT (B$JIT.PRIV.ACTIVE & %PR_FMSEC#) THEN DO;
          CALL M$READ( READ_SYMO );
          CALL CLOSE( M$SYMO# );
          END;
       CALL GET_FIT_INFO         ALTRET( NOT_HIS_FILE );
       CALL BUILD_EXTENT_LIST;
       END;
 
WHAT_NOW:
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
    CALL CLOSE( M$SYMO# );
    ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    IF ERRCODE.ERR# ~= %E$NOFILE  THEN
       GOTO CALL_REPORT_ERR;
 
    IF ERRCODE.ERR# = %E$NOFILE  THEN
       IF ONE_SHOT  AND  K = 0 THEN DO;       /* Was first chunk there?       */
          GOTO ALT_RETURN;                    /* Nope.                        */
          END;
 
    /*
    * If THEY don't have FMREAD or FMSEC and it's NOT their output, don't let
    * them see it!
    */
    IF NOT EXAMINE.AUTH THEN
       IF ACCT ~= B$JIT.ACCN  OR  UNAME ~= B$JIT.UNAME THEN DO;
          /* Sorry, That's NOT YOUR output. */
          CALL X$WRITE( F_FDS,FMT15_ );
          CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
          GOTO ALT_RETURN;
          END;
    CALL M$SPRIV( FMDIAG_PRIV )  ALTRET( DID_FILE_GO_AWAY );/* Turn on FMDIAG */
    CALL M$OPEN( TO_PACKSET )    ALTRET( DID_FILE_GO_AWAY );/* OPEN packset   */
    TOTAL_NRECS= NRECS;                       /* Remember actual # records    */
    PROMPT_= VECTOR(PROMPT2);                 /* Prompt = 'Range? '           */
    TYPE= %TC##;                              /* Default type to TC           */
    WIDTH= 0;                          /* Tell FIND_BANNER_SIZE to calc WIDTH */
    CALL FIND_BANNER_SIZE;
    CALL DO_STATUS;
    REC1= BANNER_BIAS + 1;
    REC2= TOTAL_NRECS;
 
 
RE_TURN:
    RETURN;
 
NOT_HIS_FILE:
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
    CALL CLOSE( M$SYMO# );
    GOTO ALT_RETURN;
 
DID_FILE_GO_AWAY:
    ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    IF ERRCODE.ERR# = %E$NOFILE THEN DO;
       ME_BUF= '.. You''re too late; that file went away!';
       CALL WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
       END;
    ELSE
CALL_REPORT_ERR:
       CALL REPORT_ERR;
ALT_RETURN:
    ALTRETURN;
 
END OPEN_SYMO_FILE;
%EJECT;
POSITION_FILE: PROC  ALTRET;
 
SHOULD_WE_LET_THEM:
    IF NOT M$PACKSET$->F$DCB.FCD# THEN DO;    /* Is the file OPEN?            */
       /* .. No file is OPEN; Command ignored. */
       CALL X$WRITE( F_FDS,FMT16_ );
       CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
       GOTO FILE_NOT_OPEN;
       END;
 
    IF CMD# = %TN## THEN
       IF REC2 > TOTAL_NRECS THEN
          GOTO RE_TURN;
       ELSE
          ;
    ELSE
       IF CMD# = %TP## THEN
          IF REC1 < 1 THEN
             GOTO RE_TURN;
 
    IF NOT EXAMINE.ACTIVE THEN             /* Can they fish past current EOF? */
       IF REC1 > TOTAL_NRECS THEN             /* Is first record past EOF?    */
          GOTO PUT_EOF_MSG;                   /* Yep, go tellem               */
       IF REC2 > TOTAL_NRECS THEN             /* Is last record past EOF?     */
          REC2= TOTAL_NRECS;                  /* Yep, change it to EOF        */
 
SHOULD_WE_PRECORD:
    IF REC#+1 < REC1 THEN DO;
       CALL LOCATE_NEXT( REC1 - REC# - 1 )  ALTRET( WAS_EOF_HIT );
       END;
    ELSE
       IF REC# > REC1 THEN
          IF REC# - REC1 < REC1 THEN DO;
             CALL LOCATE_NEXT( REC1 - REC# )  ALTRET( WAS_EOF_HIT );
             END;
          ELSE DO;
             CALL RESET_FILE_TO_BOF;
             GOTO SHOULD_WE_PRECORD;
             END;
 
    IF REC# < REC1 THEN
       CALL READ_SYMO_REC  ALTRET( WAS_EOF_HIT );
 
RE_TURN:
    RETURN;
 
WAS_EOF_HIT: ;
    IF ERRCODE.ERR# = %E$EOF THEN DO;
PUT_EOF_MSG:
       /* EOF hit after record %D */
       CALL X$WRITE( F_FDS,FMT13_,NRECS_ );
       CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
       REC1= TOTAL_NRECS + 1;
       REC2= TOTAL_NRECS + 1;
       END;
FILE_NOT_OPEN:
    ALTRETURN;
 
END POSITION_FILE;
%EJECT;
READ_SYMO_REC: PROC  ALTRET;
 
    CALL LOCATE_NEXT( 1 )  ALTRET( WAS_IT_EOF );
 
    CALL SET_MARGINS( 0 );
 
RE_TURN:
    RETURN;
 
WAS_IT_EOF:
    ALTRETURN;
 
END READ_SYMO_REC;
%EJECT;
LOCATE_NEXT: PROC( DIRECTION )  ALTRET;
DCL DIRECTION                SBIN;
 
    IF DIRECTION < 0 THEN                     /* Should we go backwards?      */
       DO X=1 TO -DIRECTION;
          RCW$= PINCRW( RCW$,1 );
          REC#= REC# - 1;
          IF RCW$ > FRCW$ THEN
             CALL READ_NEXT_GRAN( -1 )  ALTRET( BOF_OR_EOF );
          END;
    ELSE                                      /* Go forward DIRECTION records */
       DO X=1 TO DIRECTION;
          RCW$= PINCRW( RCW$,-1 );
          REC#= REC# + 1;
          IF RCW$ < LRCW$ THEN
             CALL READ_NEXT_GRAN( 1 )  ALTRET( BOF_OR_EOF );
          END;
 
    REC$= PINCRW( GRAN$,FM$CON.GX );
    RECL= FM$CON.GACTB;
    DVBYTE= FM$CON.CTL;
    SYMO_BUF= REC$->LREC;
    SYMO_ARS= RECL;
    VFC= SUBSTR(SYMO_BUF,0,1);
 
RE_TURN:
    RETURN;
 
BOF_OR_EOF:
    REC$= PINCRW( GRAN$,FM$CON.GX );
    RECL= FM$CON.GACTB;
    SYMO_BUF= REC$->LREC;
    SYMO_ARS= RECL;
    VFC= SUBSTR(SYMO_BUF,0,1);
    ALTRETURN;
 
END LOCATE_NEXT;
%EJECT;
READ_NEXT_GRAN: PROC( DIRECTION )  ALTRET;
DCL DIRECTION                SBIN;
 
    CUR_GRAN#= CUR_GRAN# + DIRECTION;
    CALL READ_GRANULE( CUR_GRAN#,DIRECTION )  ALTRET( BOF_OR_EOF );
 
    IF EXTNT.REC#(CUR_GRAN#) = 0 THEN
       IF DIRECTION >= 0 THEN
          EXTNT.REC#(CUR_GRAN#)= REC#;
 
RE_TURN:
    RETURN;
 
BOF_OR_EOF:
    IF ERRCODE.ERR# = %E$BOF  OR
       ERRCODE.ERR# = %E$EOF THEN
       ;
    ELSE
       IF ERRCODE.ERR# = %LPH$NOT_YOUR_GRAN THEN DO;
          ME_BUF= '.. Oops.  You lose.  That file went away!';
          CALL WRITE( ME_BUF,-LENGTHC(ME_BUF),M$ME# );
          CALL CLOSE( M$PACKSET# );
          PROMPT_= VECTOR(PROMPT1);
          END;
       ELSE
          CALL REPORT_ERR;
ALT_RETURN:
    ALTRETURN;
 
END READ_NEXT_GRAN;
%EJECT;
READ_GRANULE: PROC( GRAN#,DIRECTION )  ALTRET;
DCL GRAN#                    SBIN;
DCL DIRECTION                SBIN;
 
    ERRCODE= '0'B;
    IF GRAN# < 0 THEN
       GOTO BOF_HIT;
    IF GRAN# > NUM_GRANS THEN
       GOTO EOF_HIT;
 
    /***
      Verify that the file is still theirs.  Do a TEST OPEN to see if
      the file still exists.  If it doesn't, tell them it went away.
    */
    CUR_FIL.CHUNK= '000';                     /* See if CHUNK 000 is there    */
    CALL M$SPRIV( FMSEC_PRIV );               /* Turn it on.                  */
    CALL M$OPEN( TEST_SYMO )  ALTRET( NOT_THEIRS );
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
 
    SDA_KEY= EXTNT.SDA(GRAN#);           /* Get Disk Address for this granule */
    CALL M$READ( READ_GRAN )  ALTRET( UNEXPECTED_ERR );
 
    LRCW$= PINCRW( GRAN$,FM$GRAN.NAVX+FM$GRAN.AVAIL );
    FRCW$= PINCRW( GRAN$,1023 );
    IF DIRECTION >= 0 THEN
       RCW$= FRCW$;
    ELSE
       RCW$= LRCW$;
 
RE_TURN:
    RETURN;
 
BOF_HIT:
    GRAN#= -1;
    ERRCODE.ERR#= %E$BOF;
    GOTO ALT_RETURN;
 
EOF_HIT:
    REC#= REC# - 1;
    IF GRAN# > 0 THEN DO;
       GRAN#= GRAN# - 1;
       RCW$= PINCRW( RCW$,1 );
       END;
    ERRCODE.ERR#= %E$EOF;
    GOTO ALT_RETURN;
 
NOT_THEIRS:
    CALL M$RPRIV( FMSEC_PRIV );               /* Turn OFF FMSEC               */
    ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    IF ERRCODE.ERR# ~= %E$NOFILE THEN
       GOTO UNEXPECTED_ERR;
    ERRCODE.ERR#= %LPH$NOT_YOUR_GRAN;
    GOTO ALT_RETURN;
 
UNEXPECTED_ERR:
    CALL REPORT_ERR;
ALT_RETURN:
    ALTRETURN;
 
END READ_GRANULE;
%EJECT;
PUT_LIST_SUMMARY: PROC;
 
    IF NUM_SELECTED = 0 THEN
       IF NUM_FOUND = 0 THEN
          IF LIST.ACTIVE THEN
             /* .. There is nothing in the output queue. */
             CALL X$WRITE( F_FDS,FMT17_ );
          ELSE
             /* .. YOU have nothing in the output queue. */
             CALL X$WRITE( F_FDS,FMT18_ );
       ELSE
          IF NUM_FOUND = 1 THEN
             IF LIST.ACTIVE THEN
                /* .. The only item in the output queue was not listed. */
                CALL X$WRITE( F_FDS,FMT19_ );
             ELSE
                /* .. YOUR one item in the output queue was not listed. */
                CALL X$WRITE( F_FDS,FMT20_ );
          ELSE
             IF LIST.ACTIVE THEN
                /* .. None listed, %D searched. */
                CALL X$WRITE( F_FDS,FMT21_,NUM_FOUND_ );
             ELSE
                /* .. None of YOUR %D items were listed. */
                CALL X$WRITE( F_FDS,FMT22_,NUM_FOUND_ );
    ELSE
       IF NUM_SELECTED = 1 THEN
          IF NUM_FOUND = 1 THEN
             IF LIST.ACTIVE THEN
                /* .. The only item in the queue was listed. */
                CALL X$WRITE( F_FDS,FMT23_ );
             ELSE
                /* .. YOUR only item in the queue was listed. */
                CALL X$WRITE( F_FDS,FMT24_ );
          ELSE
             IF LIST.ACTIVE THEN
                /* .. One of the %D items in the output queue was listed. */
                CALL X$WRITE( F_FDS,FMT25_,NUM_FOUND_ );
             ELSE
                /* .. One of YOUR %D items in the queue was listed. */
                CALL X$WRITE( F_FDS,FMT26_,NUM_FOUND_ );
       ELSE
          IF LIST.ACTIVE THEN
             IF NUM_SELECTED ~= NUM_FOUND THEN
                /* .. %D items listed, %D searched. */
                CALL X$WRITE( F_FDS,FMT27_,NUM_SELECTED_,NUM_FOUND_ );
             ELSE
                /* .. All of the %D items searched were listed. */
                CALL X$WRITE( F_FDS,FMT29_,NUM_FOUND_ );
          ELSE
             /* .. %D items listed, %D of YOUR items were searched. */
             CALL X$WRITE( F_FDS,FMT28_,NUM_SELECTED_,NUM_FOUND_ );
    CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
RE_TURN:
    RETURN;
 
END PUT_LIST_SUMMARY;
%EJECT;
DO_SE: PROC;
 
    IF NOT M$PACKSET$->F$DCB.FCD# THEN
       GOTO RE_TURN;
 
    IF LEFT > -1  AND  LEFT < MAX_SYMO_LEN THEN
       L= LEFT;
    ELSE
       L= MAX_SYMO_LEN - 1;
    IF RIGHT > -1  AND  RIGHT < MAX_SYMO_LEN THEN
       R= RIGHT;
    ELSE
       R= MAX_SYMO_LEN - 1;
    IF REC1 = REC2 THEN
       IF OPT.FLAG(%BANNER##) THEN
          /* .. Record %D (the BANNER occupies the first %D records), Colum*/
          CALL X$WRITE( F_FDS,FMT32_,REC1_,BANNER_LINES_,L_,R_ );
       ELSE
          /* .. Record %D (Beyond the %D BANNER records), Columns %D-%D    */
          CALL X$WRITE( F_FDS,FMT34_,REC1_,BANNER_LINES_,L_,R_ );
    ELSE
       IF OPT.FLAG(%BANNER##) THEN
          /* .. Records %D-%D (the BANNER occupies the first %D records), C*/
          CALL X$WRITE( F_FDS,FMT33_,REC1_,REC2_,BANNER_LINES_,L_,R_ );
       ELSE
          /* .. Records %D-%D (Beyond the %D BANNER records), Columns %D-%D*/
          CALL X$WRITE( F_FDS,FMT35_,REC1_,REC2_,BANNER_LINES_,L_,R_ );
 
RE_TURN:
    RETURN;
 
END DO_SE;
%EJECT;
RESET_FILE_TO_BOF: PROC;
 
    CUR_GRAN#= -1;
    REC#= 0;
    RCW$= PINCRW( GRAN$,3 );
    FRCW$= PINCRW( RCW$,-1 );
    LRCW$= PINCRW( RCW$,1 );
RE_TURN:
    RETURN;
 
END RESET_FILE_TO_BOF;
%EJECT;
DO_STATUS: PROC;
 
    IF M$PACKSET$->F$DCB.FCD# THEN            /* If a file is OPEN            */
       IF OPT.FLAG(%BANNER##) THEN
          /* .. Examining %D-%D (%>A.%>A) %D records, %D Pages, %D ... */
          CALL X$WRITE( F_FDS,FMT1_,SYSID_,NUM_,JOBNAME_,ACCT_,
                                    NRECS_,NPAGES_,NGRANS_,DEV_,TNAME_ );
       ELSE
          /* .. Examining %D-%D (%>A.%>A) %D+%D Records, %D Pages, %D*/
          CALL X$WRITE( F_FDS,FMT2_,SYSID_,NUM_,JOBNAME_,ACCT_,
                                    BANNER_LINES_,NRECS_,NPAGES_,
                                    NGRANS_,DEV_,TNAME_ );
       IF OPT.FLAG(%FID##) THEN
          /*    File name = %A.:SYMO */
          CALL X$WRITE( F_FDS,FMT39_,VECTOR(SUBSTR(CUR_FILE.C,0,CUR_FILE.L)) );
RE_TURN:
    RETURN;
 
END DO_STATUS;
%EJECT;
PUT_STATS: PROC;
 
    IF B$JIT.ACCN = 'TSMFEP  ' OR  B$JIT.ACCN = 'ZLHNSS6 '  THEN
       GOTO SO_WHAT;
    CALL M$OPEN( OPEN_STATS )  ALTRET( SO_WHAT );
    STATS_BUF= ' ';
    STATS.ACCN= B$JIT.ACCN;
    STATS.UNAME= B$JIT.UNAME;
    STATS.FACCN= B$JIT.FACCN;
    STATS.CCBUF= B$JIT.CCBUF;
    CALL M$TIME( GET_TIME );
    WRITE_STATS.BUF_.BOUND= 51 + B$JIT.CCARS;
    CALL M$WRITE( WRITE_STATS );
    STATS_DONE= %YES#;
    CALL M$CLOSE( CLOSE_STATS );
SO_WHAT:
    RETURN;
 
END PUT_STATS;
%EJECT;
DO_EXAMINE: PROC;
 
    IF ONE_SHOT THEN DO;
       IF CRITERIA.NUM = -1 THEN
          CRITERIA.NUM= 1;
       O_CRITERIA= DEFAULT_CRITERIA;
       O_CRITERIA.SYSID#= CRITERIA.SYSID;
       O_CRITERIA.SYSID1#= CRITERIA.SYSID;
       CALL CALL_JOBSTATS;
       IF NUM_JOBS > 0 THEN
          SELECTED_FILE.BOOTID= ADDR(R$OUTPUT.F(0))->A$OUTPUT.BOOTID;
       ELSE
          SELECTED_FILE.BOOTID= SYMBINFO.STREAMFILEID#;
       SELECTED_FILE.L= LENGTHC('BBBSSSSSSNNNNNNCCC');
       CALL BINCHAR( SELECTED_FILE.SYSID,CRITERIA.SYSID );
       CALL BINCHAR( SELECTED_FILE.NUM,CRITERIA.NUM );
       SELECTED_FILE.CHUNK= '000';
       END;
    ELSE
       IF BLK2_NSUBLKS > 0  OR  NUM_SELECTED ~= 1 THEN DO;
SCAN_SLOW_WAY:
          CALL SCAN_FILES;
          IF NUM_SELECTED ~= 1 THEN DO;
             IF NUM_SELECTED > 1 THEN
                /* .. %D items found; Please qualify enough to select...*/
                CALL X$WRITE( F_FDS,FMT3_,VECTOR(NUM_SELECTED) );
             ELSE
                IF LIST.ACTIVE THEN
                   /* .. Nothing found. */
                   CALL X$WRITE( F_FDS,FMT30_ );
                ELSE
                   /* .. Nothing (of YOURs) found. */
                   CALL X$WRITE( F_FDS,FMT31_ );
             GOTO RE_TURN;
             END;
          END;
    CALL OPEN_SYMO_FILE  WHENALTRETURN DO;
       IF ONE_SHOT THEN DO;
          ONE_SHOT= %NO#;
          GOTO SCAN_SLOW_WAY;
          END;
       ELSE
          /* .. Nothing found. */
          CALL X$WRITE( F_FDS,FMT30_ );
       END;
RE_TURN:
    RETURN;
 
END DO_EXAMINE;
%EJECT;
PUT_FIND_SUMMARY: PROC;
 
    IF NUM_MATCHES = 1 THEN
       IF LO_NE_ME THEN
          /* .. One Match found, %D records searched. */
          CALL X$WRITE( F_FDS,FMT6_,NUM_FOUND_ );
       ELSE
          GOTO RE_TURN;
    ELSE
       /* .. %D Matches found, %D records searched. */
       CALL X$WRITE( F_FDS,FMT7_,VECTOR(NUM_MATCHES),NUM_FOUND_ );
    CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
RE_TURN:
    RETURN;
 
END PUT_FIND_SUMMARY;
%EJECT;
DO_READ: PROC  ALTRET;
 
    IF M$SI2$->F$DCB.FCD# THEN DO;
       /* .. Sorry, you can''t nest READ commands; This READ ignored. */
       CALL X$WRITE( F_FDS,FMT36_ );
       CALL WRITE( ME.BUF1,-LENGTHC(ME.BUF1),,M$ME# );
       END;
    ELSE DO;
       CALL M$RPRIV( FMSEC_PRIV );              /* Make sure FMSEC is off     */
       FID_SI2.V.SCRUB= '111111'B;            /* Scrub: NAME,ACCT,PASS,SN,RES */
       CALL M$FID( FID_SI2 )  ALTRET( CALL_ERRMSG );
       CALL M$OPEN( OPEN_SI2 )  ALTRET( CALL_ERRMSG );
       CALL XUR$SETDCBS( M$SI2#, , , );
       END;
RE_TURN:
    RETURN;
 
CALL_ERRMSG:
    CALL REPORT_ERR;
ALT_RETURN:
    ALTRETURN;
 
END DO_READ;
%EJECT;
SET_MARGINS: PROC( CMND );
DCL CMND                     UBIN;
 
    IF TY_LEFT > -1  AND  CMND = 0 THEN
       L= TY_LEFT;
    ELSE
       IF LEFT > -1 THEN
          L= LEFT;
       ELSE
          L= 1;
 
    IF TY_RIGHT > -1  AND  CMND = 0 THEN
       R= TY_RIGHT;
    ELSE
       IF RIGHT > -1 THEN
          R= RIGHT;
       ELSE
          R= SYMO_ARS;
    IF R >= SYMO_ARS  AND  SYMO_ARS > 1  THEN
       R= SYMO_ARS - 1;                       /* Change R to displacement     */
 
    LEN= MINIMUM( R - L + 1,SYMO_ARS );
 
RE_TURN:
    RETURN;
 
END SET_MARGINS;
%EJECT;
DUMP_OCTAL: PROC;
 
    IF M$LO$->F$DCB.WIDTH# < 80 THEN
       WIDTH#= 80;
    ELSE
       WIDTH#= M$LO$->F$DCB.WIDTH#;
    I= (WIDTH#-LENGTHC('123456  '))/LENGTHC('xxxxxx.xxxxxx cccc');
    LAST_OCTAL_POS= LENGTHC('123456  ') + (I*LENGTHC('xxxxxx.xxxxxx ')) - 1;
    IF L = 1  AND  OPT.FLAG(%VFC##) THEN
       POS= 0;
    ELSE
       POS= L;
    IF OPT.FLAG(%DVBYTE##) THEN DO;
       CALL CONCAT( ME_BUF,INT6,' - ' );
       OINDX= LENGTHC(INT6) + LENGTHC(' - ');
       CALL BINCHAR( INT6,RECL );
       IINDX= 0;
       DO WHILE( IINDX < LENGTHC(INT6)-1  AND  SUBSTR(INT6,IINDX,1)='0' );
          IINDX= IINDX + 1;
          END;
       CALL INSERT( ME_BUF,OINDX,,SUBSTR(INT6,IINDX),' Bytes [VFC' );
       OINDX= OINDX + (LENGTHC(INT6) - IINDX) + LENGTHC(' Bytes [VFC');
       IF DVBYTE.TOP# THEN DO;
          SUBSTR(ME_BUF,OINDX)= ',TOP';
          OINDX= OINDX + LENGTHC(',TOP');
          END;
       IF DVBYTE.BIN# THEN DO;
          SUBSTR(ME_BUF,OINDX)= ',BIN';
          OINDX= OINDX + LENGTHC(',BIN');
          END;
       IF DVBYTE.TRAN# THEN DO;
          SUBSTR(ME_BUF,OINDX)= ',TRANS';
          OINDX= OINDX + LENGTHC(',TRANS');
          END;
       SUBSTR(ME_BUF,OINDX)= ']';
       CALL WRITE( ME_BUF,-WIDTH#,M$LO# );
       ME_BUF= ' ';
       END;
    ELSE
       ME_BUF= INT6;
    OINDX= LENGTHC('123456  ') + (MOD(POS,4)*3);
    IINDX= LAST_OCTAL_POS + LENGTHC(' ') + MOD(POS,4);
    DO WHILE( POS <= R );
       IF OINDX > LAST_OCTAL_POS THEN DO;
          CALL WRITE( ME_BUF,-WIDTH#,M$LO# );
          CALL BINCHAR( INT6,POS );
          CALL EDITSTR( INT6,0,3,'103'O,INT6 );
          ME_BUF= INT6;
          IINDX= LAST_OCTAL_POS + 1;
          OINDX= LENGTHC('123456  ');
          END;
       BYTX= SUBSTR(SYMO_BUF,POS,1);
       CALL INSERT( ME_BUF,OINDX,3,BINASC(BYT.U1+48),BINASC(BYT.U2+48),
                                   BINASC(BYT.U3+48) );
       OINDX= OINDX + LENGTHC('xxx');
       DO CASE( MOD(POS,4) );
          CASE( 0,2 );
 
          CASE( 1 );
             IF POS < R THEN DO;
                SUBSTR(ME_BUF,OINDX,1)= '.';
                OINDX= OINDX + LENGTHC('.');
                END;
          CASE( 3 );
             OINDX= OINDX + LENGTHC(' ');
          END;
       SUBSTR(ME_BUF,IINDX,1)= XLATE_TAB(BYTU);
       IINDX= IINDX + LENGTHC(BYTX);
       POS= POS + 1;
       END;
    IF SUBSTR(ME_BUF,LENGTHC('123456  ')) ~= ' ' THEN
       CALL WRITE( ME_BUF,-WIDTH#,M$LO# );
RE_TURN:
    RETURN;
 
END DUMP_OCTAL;
%EJECT;
EXPAND: PROC( SEG_,NUM_WORDS )  ALTRET;
%VLP_VECTOR (FPTN=SEG_,STCLASS=);
DCL NUM_WORDS                UBIN;
 
    GDS.V.SEGSIZE#= NUM_WORDS;
    GDS.RESULTS_= VECTOR(SEG_);
    CALL M$GDS( GDS )  ALTRET( NO_MEM );
RE_TURN:
    RETURN;
 
NO_MEM:
    ALTRETURN;
 
END EXPAND;
%EJECT;
END BASS;
