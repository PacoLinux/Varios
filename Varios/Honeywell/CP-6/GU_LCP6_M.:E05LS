

14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          1    
    1      /*M* GU_LCP6_M   Macros for User Services FPTs and related structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*  MEC,MOC,EXM=20,CLM=20,CRM=100                */
    8
    9
   10                          /*P* NAME: GU_LCP6_M.
   11
   12                          The file GU_LCP6_M contains the macros that
   13                          relate to a variety of user services.  Among
   14                          these are those relating to Exceptional
   15                          Condition Processing and Program Management.
   16                          */
   17
   18
   19
   20                          /*F* NAME: Exceptional Condition Services
   21                          ..::L1 "Introduction\\X"
   22                          The monitor services described in this section
   23                          allow the user program to take control at a
   24                          specific location for processing whenever an
   25                          exceptional condition occurs.  Also described in
   26                          this section are services that allow the program
   27                          to return after processing the exceptional
   28                          condition.
   29
   30                          An exceptional condition is defined as an event
   31                          that causes an interruption of the normal flow of
   32                          program execution, such as program exit or abort,
   33                          timer run-out, no-wait I/O completion, monitor
   34                          service request errors, etc.
   35                          ..::L1 "Establishing Exceptional Condition Control\\X"
   36                          Exceptional condition control may be established
   37                          by issuing the following service requests:
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          2    
   38                          ..VA$M_FOOTER "\Establishing Exceptional Condition Control"
   39
   40                          TU
   41                            Any monitor service    To take control when the monitor detects an
   42                            call with ALTRET       error on any monitor service request.
   43
   44                            M$TRAP                 To take control of machine traps and errors
   45                                                   on monitor service calls when ALTRET is not
   46                                                   specified.
   47
   48                            M$INT                  To take control of a terminal "Break" keyin.
   49
   50                            M$EVENT                To take control on completion of an event,
   51                                                   such as timer run-out or no-wait I/O completion.
   52
   53                            M$XCON                 To take control of program exits or aborts.
   54
   55                          TF
   56
   57                          These services simply establish the entry point to
   58                          receive control when the condition occurs.  The
   59                          services listed first take precedence over the
   60                          M$XCON request for control.  For instance, if the
   61                          user requests control at a specific trap
   62                          condition, the M$TRAP procedure takes control;
   63                          otherwise, the system passes control to the exit
   64                          procedure if the same fault occurs.
   65
   66                          Control of any of these exceptional conditions
   67                          may be nested in program subroutines.  Each of
   68                          these services will optionally return the address
   69                          of the condition handler that
   70                          may have previously been established
   71                          in an area specified by the Pname
   72                          parameter (name = TRAP, INT, EVENT or XCON).
   73                          This returned entry point may then
   74                          later be re-established as the address to receive
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          3    
   75                          control when the condition occurs by setting
   76                          the Nname parameter to Pname.
   77
   78                          ..::L1 "G$ECCB - Exception Condition Control Block\G$ECCB\1"
   79                          The monitor maintains an Exceptional Condition
   80                          Control Block (ECCB) for each domain
   81                          in the user's Read Only Segment. The ECCB contains
   82                          the entry points of the procedure to be entered when
   83                          one of the Exceptional Condition occurs.  It also
   84                          contains control flags used by the monitor when
   85                          giving exceptional condition control to the user.
   86
   87                          The G$ECCB macro may be used to generate a structure
   88                          of the ECCB.  The ECCB may be addressed by using
   89                          the U_ECCB$ pointer which is within the user's
   90                          Read Only Segment.
   91                          Please refer to the description of the G$ROS
   92                          macro elsewhere in this manual for details on
   93                          accessing data within the Read Only Segment.
   94
   95                          The subfields within G$ECCB have the following
   96                          meaning:
   97                          */
   98      %MACRO G$ECCB (FPTN=G$ECCB,
   99        LVL=1,
  100        LAST(YES=";",NO=",",ANY)=";",
  101        ALGN=WALIGNED,
  102        ARRAYED(YES=1,NO=0,ANY)=0,
  103        STCLASS=BASED);
  104
  105      %LSET LISTDIR='0'B;
  106      %LSET LISTEXP='1'B;
  107      %LSET LISTCOM='0'B;
  108      %LSET LISTSUB='1'B;
  109      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  110      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  111      %LSET INIT=CHARTEXT('INIT');
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          4    
  112      %LSET EINIT=CHARTEXT('');
  113      %ELSE;
  114      %LSET INIT=CHARTEXT('/*');
  115      %LSET EINIT=CHARTEXT('*/');
  116      %ENDIF;
  117
  118      %IF LVL=1;
  119      DCL 1 FPTN STCLASS ALGN,
  120      %ELSE;
  121              %LVL FPTN,
  122      %ENDIF;
  123      %LSET ECCB_NXT_LVL=LVL+1;
  124
  125      %IF ARRAYED=0;
  126                %(LVL+1) EVENT$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  127                          /*K*  EVENT$ - EPTR  contains the address of the
  128                          procedure to be entered on event completion.
  129                          */
  130                %(LVL+1) INT$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  131                          /*K*  INT$ - EPTR  contains the address of the
  132                          procedure to be entered on break key interrupt.
  133                          */
  134                %(LVL+1) XCON$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  135                          /*K*  XCON$ - EPTR  contains the address of the
  136                          procedure to be entered for exit control
  137                          processing.
  138                          */
  139                %(LVL+1) TRAP$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  140                          /*K*   TRAP$ - EPTR  contains the address of the
  141                          procedure to be entered on machine traps and on
  142                          Monitor Service Request errors when ALTRET is not
  143                          specified on the service request call.
  144                          */
  145                %(LVL+1) DBCONTROL$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  146                          /*B*  DBCONTROL$ - EPTR  contains the address of the
  147                          procedure to be entered the occurrence of an
  148                          event originated by the associated debugger.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          5    
  149                          */
  150      %ELSE;
  151                %(LVL+1) HAND$(0:4) EPTR %INIT(ENTADDR(NIL)*4)%EINIT,
  152                          /*K* HAND$ - EPTR ARRAY  may be used to reference EVENT$,
  153                          INT$, XCON$ and TRAP$ as an array of EPTRs indexed
  154                          by the MCL codes for the corresponding service request.
  155                          */
  156      %ENDIF;
  157                %(LVL+1) FLAGS,
  158                          /*K*   FLAGS is a bit field that contains the bit
  159                          settings used by the monitor for Exceptional
  160                          Condition control as follows:
  161                          */
  162                %(LVL+2) XCONP BIT(1) UNAL %INIT('0'B)%EINIT,
  163                          /*K* FLAGS.XCONP - BIT(1)  set when Exit Control is in progress.
  164                          */
  165                %(LVL+2) TCBFULL BIT(1) UNAL %INIT('0'B)%EINIT,
  166                          /*K* FLAGS.TCBFULL - BIT(1)   is set when the exit control frame
  167                          is in the ALTRET frame of the TCB because the TCB was
  168                          full at entry to exit control.
  169                          */
  170                %(LVL+2) EXTD_LIM BIT(1) UNAL %INIT('0'B)%EINIT,
  171                          /*K* FLAGS.EXTD_LIM - BIT(1)  is set when the maximum run
  172                          time has been extended for Class 2 or Class 3
  173                          exit control processing.
  174                          */
  175                %(LVL+2) * BIT(13) UNAL %INIT('0'B)%EINIT,
  176                          /* RFU                                                                        */
  177                %G_TRAP_BLOCK (FPTN=FLTFLG,LVL=ECCB_NXT_LVL,LAST=NO,STCLASS=STCLASS);
  178                          /*K*  FLTFLG - BIT(48)  contains the bit settings to indicate which
  179                          of the hardware traps are under control of the user.
  180                          Refer to VLP_TRAP_CONDITIONS for the names and meanings of the
  181                          individual traps.                                                             */
  182              %(LVL+1) FLTFLGS(0:47) REDEF FLTFLG BIT(1) UNAL LAST
  183
  184      %MEND;
  185
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          6    
  186
  187
  188
  189
  190                          /*F* NAME: G$TCB  - Saving the User Environment
  191
  192                          When an exceptional condition occurs over which
  193                          the user requested control, the system saves the
  194                          environment of the interrupted program.  This
  195                          action enables the user to return to the point of
  196                          interruption and resume normal processing, if the
  197                          user determines that this is possible.
  198
  199                          When an exceptional condition processing procedure
  200                          is entered, the environment of the interrupted
  201                          program as well as information specific to the
  202                          exceptional condition is stored in the program
  203                          Task Control Block (TCB).  The TCB is in the
  204                          Read Only Segment.  The TCB consists of three parts:
  205
  206                            1.  The TCB header which contains control information
  207                                and pointers to the next two sections.
  208
  209                            2.  A fixed area for the program environment when an ALTRET
  210                                code sequence is to be entered following a monitor
  211                                service request.
  212
  213                            3.  An Exceptional Condition Stack containing one or more
  214                                frames.  A frame is allocated, filled with the program
  215                                environment from the TSA or ISA, and pushed
  216                                onto the top of the stack for each exceptional condition.
  217                                The stack is "popped" (that is, the top frame is released)
  218                                by the user after the exceptional condition is processed.
  219
  220                          The G$TCB macro may be used to generate a based
  221                          structure for accessing data on the TCB.
  222
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          7    
  223                          The TCB may be referenced through the linker
  224                          built pointer, G$TCB$.
  225
  226                          The fields in the TCB header are as follows:
  227                          */
  228
  229      %MACRO G$TCB (FPTN=G$TCB,
  230        ALT$=NIL,
  231        STK$=NIL,
  232        AVSZ=0,
  233        CURRSZ=0,
  234        LVL=1,
  235        LAST(YES=";",NO=",",ANY)=";",
  236        ALGN=WALIGNED,
  237        STCLASS=BASED);
  238
  239      %LSET LISTDIR='0'B;
  240      %LSET LISTEXP='1'B;
  241      %LSET LISTCOM='0'B;
  242      %LSET LISTSUB='1'B;
  243      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  244      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  245      %LSET INIT=CHARTEXT('INIT');
  246      %LSET EINIT=CHARTEXT('');
  247      %ELSE;
  248      %LSET INIT=CHARTEXT('/*');
  249      %LSET EINIT=CHARTEXT('*/');
  250      %ENDIF;
  251
  252      %IF LVL=1;
  253      DCL 1 FPTN STCLASS ALGN,
  254      %ELSE;
  255              %LVL FPTN,
  256      %ENDIF;
  257                %(LVL+1) %CHARTEXT('ALT$ ') PTR %INIT(ADDR(ALT$))%EINIT,
  258                          /*K*  ALT$ - PTR   contains a pointer
  259                          to the ALTRET frame in the TCB.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          8    
  260                          */
  261                %(LVL+1) %CHARTEXT('STK$ ') PTR %INIT(ADDR(STK$))%EINIT,
  262                          /*K* STK$ - PTR   contains a pointer to the
  263                          top frame in the TCB Exceptional Condition Stack.
  264                          */
  265                %(LVL+1) %CHARTEXT('AVSZ ') SBIN WORD UNAL %INIT(AVSZ)%EINIT,
  266                          /*K* AVSZ - SBIN   contains
  267                          the number of unused words remaining in the
  268                          TCB Exceptional Condition Stack.
  269                          */
  270                %(LVL+1) %CHARTEXT('CURRSZ ') SBIN WORD UNAL %INIT(CURRSZ)%EINIT LAST
  271                          /*K* CURRSZ - SBIN   contains the
  272                          size of the top frame on the TCB Exceptional
  273                          Condition Stack.
  274                          */
  275      %MEND;
  276
  277
  278
  279
  280
  281                          /*F* NAME: G$EXCFR - Exceptional Condition Frame
  282
  283                          The G$EXCFR macro may be used to generate
  284                          a structure that defines the fixed portion of
  285                          any environment in the Task Control Block, be it the
  286                          ALTRET frame or a frame on the exceptional condition
  287                          stack.  The value in G$EXCFR.ECC differentiates
  288                          the frame types.
  289
  290                          The structure contains the hardware environment
  291                          followed by monitor supplied error information.
  292
  293                          The subfields within G$EXCFR have the following
  294                          meaning:
  295                          */
  296
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          9    
  297
  298
  299      %MACRO G$EXCFR (FPTN=G$EXCFR,
  300        PREVSZ=0,
  301        ECC=0,
  302        P$=NIL,
  303        LVL=1,
  304        LAST(YES=";",NO=",",ANY)=";",
  305        ALGN=WALIGNED,
  306        STCLASS=BASED);
  307
  308      %LSET LISTDIR='0'B;
  309      %LSET LISTEXP='1'B;
  310      %LSET LISTCOM='0'B;
  311      %LSET LISTSUB='1'B;
  312      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  313      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  314      %LSET INIT=CHARTEXT('INIT');
  315      %LSET EINIT=CHARTEXT('');
  316      %ELSE;
  317      %LSET INIT=CHARTEXT('/*');
  318      %LSET EINIT=CHARTEXT('*/');
  319      %ENDIF;
  320
  321      %IF LVL=1;
  322      DCL 1 FPTN STCLASS ALGN,
  323      %ELSE;
  324              %LVL FPTN,
  325      %ENDIF;
  326      %LSET EXCFR_NXT_LVL=LVL+1;
  327
  328                %(LVL+1) %CHARTEXT('PREVSZ ') SBIN WORD %INIT(PREVSZ)%EINIT,
  329                          /*K*   PREVSZ - SBIN   contains
  330                          the number of words in the previous Stack
  331                          frame.  If this is the first frame on the
  332                          Exceptional Condition Stack the value will be zero.
  333                          This field is redefined as ALTEMPTY in an ALTRET frame.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          10   
  334                          */
  335                %(LVL+1) ALTEMPTY REDEF %CHARTEXT('PREVSZ ') SBIN,
  336                          /*K*   ALTEMPTY - SBIN   contains
  337                          a non-zero value when the ALTRET frame is empty.
  338                          The ALTRET frame is marked empty on initial entry
  339                          to a run-unit and after execution of an M$MERC,
  340                          M$RETRY or M$SENV monitor service.
  341                          This field has meaning only in an ALTRET frame and
  342                          is redefined as PREVSZ in a TCB Stack frame.
  343                          */
  344                %(LVL+1) %CHARTEXT('ECC ') SBIN WORD %INIT(ECC)%EINIT,
  345                          /*K*   ECC - SBIN   contains
  346                          the Exceptional Condition Code.  When the
  347                          environment is in a frame on the exceptional
  348                          condition stack, the ECC
  349                          will be set to one of the following:
  350                          }
  351                          }%G_EVENT#   0    Event Completion
  352                          }%G_INT#     1    Time-sharing terminal INT keyin
  353                          }%G_XCON#    2    Exit condition, normal or abnormal
  354                          }%G_TRAP#    3    Program Trap
  355                          }
  356                          When the environment is in the ALTRET frame,
  357                          the ECC will contain:
  358                          }
  359                          }%G_ALT#     99   Monitor services error with ALTRET specified
  360                          }%G_TCBFULL# 98   Insufficient space in TCB stack to
  361                          }                 allocate an Exceptional Condition frame
  362                          }
  363                          */
  364                %G$ISM1 (FPTN=ISM1,STCLASS=STCLASS,LVL=EXCFR_NXT_LVL,LAST=",");
  365                          /*N* ISM1 - BIT(16)   contains the contents of the
  366                          Interrupt Save Mask 1.  For any exceptional condition frame,
  367                          bit settings in this word will indicate if the corresponding
  368                          field in the REGS area of the frame is valid.  Refer to
  369                          G$ISM1 for the names of the individual bits in ISM1.
  370                          */
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          11   
  371              %G$ISM2 (FPTN=ISM2,STCLASS=STCLASS,LVL=EXCFR_NXT_LVL,LAST=",");
  372                          /*N* ISM2 - BIT(16)   contains the contents of the
  373                          Interrupt Save Mask 2.  For any exceptional condition frame,
  374                          bit settings in this word will indicate if the corresponding
  375                          field in the REGS area of the frame is valid.  Refer to
  376                          G$ISM2 for the names of the individual bits in ISM2.
  377                          */
  378              %(LVL+1) %CHARTEXT('P$$ EPTR') %INIT(ENTADDR(P$$))%EINIT,
  379              %(LVL+1) %CHARTEXT('P$ ') REDEF %CHARTEXT('P$$ ') PTR,
  380              %(LVL+1) %CHARTEXT('P ') REDEF %CHARTEXT('P$$ ') UBIN(32),
  381                          /*K* P$$ - EPTR   contains the contents of the Program
  382                          Counter at the time the exceptional condition occurred.
  383                          This field is REDEFed as P$ PTR and as P UBIN(32).
  384                          */
  385      %G$STATUS_REG (FPTN=S,STCLASS=STCLASS,LVL=EXCFR_NXT_LVL,LAST=",");
  386                          /*K*  S - BIT(16)   contains the contents of the Status
  387                          Register at the time of the exceptional condition:
  388                          */
  389
  390                          /*K* S.QLT - VALUE-BIT(1)  indicates
  391                               whether a unit in the system has successfully
  392                               completed its Quality Logic Test or not.
  393                              }
  394                              }    0 = QLT successfully completed.
  395                              }    1 = QLT either still running or failed
  396                              }
  397                          */
  398
  399                          /*K* S.RING - BIT(2)
  400                               contains the currently active
  401                               Ring value.  Note that ring values are always
  402                               encoded as ones complement whenever they appear.
  403                               Thus this field will contain one of the following:
  404                              }
  405                              } %G_RING0#  11   Ring 0 - Monitor
  406                              } %G_R_MON#  10   Ring 1 - Monitor/Handlers
  407                              } %G_R_DB#   01   Ring 2 - Debugger
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          12   
  408                              } %G_R_USR#  00   Ring 3 - User
  409                              }
  410                          */
  411                          /*K* S.ID - BIT(2)  contains the processor ID
  412                               which is hard-wired and cannot be changed under
  413                               program control.  These 2 bits are used as the least
  414                               significant bits of the 10-bit channel number for
  415                               the processor itself, where the 8 high order bits
  416                               are always zero.
  417                          */
  418                          /*K* S.LEVEL - UBIN(6)  contains the
  419                               interrupt priority level on which the processor
  420                               is currently executing.  Level 0 is the highest
  421                               priority level and 63 is the lowest.
  422                          */
  423              %VLP_REGISTERS (FPTN=REGS,STCLASS=STCLASS,LVL=EXCFR_NXT_LVL,LAST=",");
  424                          /*K* REGS - is the contents of the hardware registers at
  425                          the time of the exceptional condition:
  426                          */
  427                          /*N* (Note that the bit settings within
  428                          ISM1 and ISM2 determine the validity of the contents
  429                          of REGS.)
  430                          */
  431                          /*K* REGS.Bn$ - PTR (where n = 1-7)
  432                          .XEQ GH_LCP6_M VLP_REGISTERS Bn$
  433                          */
  434
  435                          /*K* REGS.I - BIT(16)   contains a copy of the
  436                          Indicator Register and, if a trap condition exists,
  437                          the trap number.
  438                          .XEQ GH_LCP6_M VLP_REGISTERS I
  439                          */
  440
  441                          /*K* REGS.I.TRAP# - UBIN(8)
  442                          .XEQ GH_LCP6_M G$INDICATOR_REG TRAP#
  443                          */
  444                          /*K* REGS.I.OV - BIT(1)
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          13   
  445                          .XEQ GH_LCP6_M G$INDICATOR_REG OV
  446                          */
  447                          /*K* REGS.I.C - BIT(1)
  448                          .XEQ GH_LCP6_M G$INDICATOR_REG C
  449                          */
  450                          /*K* REGS.I.B - BIT(1)
  451                          .XEQ GH_LCP6_M G$INDICATOR_REG B
  452                          */
  453                          /*K* REGS.I.IO - BIT(1)
  454                          .XEQ GH_LCP6_M G$INDICATOR_REG IO
  455                          */
  456                          /*K* REGS.I.G - BIT(1)
  457                          .XEQ GH_LCP6_M G$INDICATOR_REG G
  458                          */
  459                          /*K* REGS.I.L - BIT(1)
  460                          .XEQ GH_LCP6_M G$INDICATOR_REG L
  461                          */
  462                          /*K* REGS.I.U - BIT(1)
  463                          .XEQ GH_LCP6_M G$INDICATOR_REG U
  464                          */
  465
  466                          /*K* REGS.Rn - UBIN  (where n = 1-7)
  467                          are the seven 16 bit general registers numbered R1 through
  468                          R7.  The first three, R1 - R3, may be used as index
  469                          registers.  R6 and R7 may be used as a double word.
  470                          */
  471
  472
  473                          /*K* REGS.M1 enables and disables the Trace
  474                          Trap and the General Register Overflow Trap:
  475                          */
  476
  477                          /*K* REGS.M1.J - BIT(1) is the Trace Trap control
  478                          bit;  0 = Trace Trap disabled, 1 = Trace Trap enabled.
  479                          */
  480
  481                          /*K* REGS.M1.Rn_OV - BIT(1) (where n = 1-7) are the
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          14   
  482                          Overflow trap control bits for the seven general registers;
  483                          0 = trap disabled, 1 = trap enabled.
  484                          */
  485
  486                          /*K* REGS.M3 contains the control
  487                          information for the Commercial Instruction Processor(CIP):
  488                          */
  489
  490                          /*K* REGS.M3.CIP_OV - BIT(1) is the CIP Overflow
  491                          Trap Mask; 0 = trap disabled, 1 = trap enabled.
  492                          */
  493
  494                          /*K* REGS.M3.CIP_TR - BIT(1) is the CIP Truncation
  495                          Trap Mask; 0 = trap disabled, 1 = trap enabled.
  496                          */
  497
  498                          /*K* REGS.T$ - PTR contains
  499                          the address of the first word of the stack header.
  500                          PL-6 programs use T$ to address the AUTO stack.
  501                          */
  502
  503                          /*K* REGS.CI - BIT(8) are the Commercial Indicator
  504                          Register bits that are set and reset by the CIP:
  505                          */
  506
  507                          /*K* REGS.CI.OV - BIT(1) if set, indicates that an
  508                          overflow occurred during a decimal instruction.
  509                          */
  510
  511                          /*K* REGS.CI.TR - BIT(1) if set, indicates that the
  512                          alphanumeric result was truncated.
  513                          */
  514
  515                          /*K* REGS.CI.SF - BIT(1) if set, indicates that a
  516                          sign fault occurred (negative operand is stored in
  517                          unsigned field).
  518                          */
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          15   
  519
  520                          /*K* REGS.CI.G - BIT(1) is the Greater-than Indicator that
  521                          contains the results of the last compare instruction
  522                          executed by the computer.
  523                          */
  524
  525                          /*K* REGS.CI.L - BIT(1) is the Less-than Indicator that
  526                          contains the results of the last compare instruction
  527                          executed by the computer.
  528                          */
  529
  530                          /*K* REGS.CI.QLT - BIT(1)
  531                               indicates whether the CIP has successfully
  532                               completed its Quality Logic Test or not.
  533
  534                              }    0 = QLT successfully completed.
  535                              }    1 = QLT either still running or failed
  536
  537                          */
  538
  539                          /*K* REGS.RDBR$ - PTR is the Remote Descriptor Base Register
  540                          used by the CIP to locate a remote descriptor array.
  541                          */
  542              %G$EXCFR_TRLR (FPTN=TRLR,STCLASS=STCLASS,LVL=EXCFR_NXT_LVL,LAST=LAST);
  543                          /*K* TRLR - is the trailer portion of an exceptional
  544                          condition frame.  TRLR is an area 5 words long that contains
  545                          information about the condition supplied by the
  546                          software:
  547                          */
  548      %MEND;
  549                          /* no *F* here so the *K*'s get associated
  550                            with the commentary for G$EXCFR.
  551                          */
  552                          /* *   NAME: G$EXCFR_TRLR.
  553
  554                          The G$EXCFR_TRLR macro may be used to generate
  555                          a structure that contains the words in
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          16   
  556                          the trailer portion of an Exceptional Condition
  557                          Frame.
  558
  559                          The fields in the trailer are:
  560                          */
  561
  562      %MACRO G$EXCFR_TRLR (FPTN=G$EXCFR_TRLR,
  563        SUBC=0,
  564        EVID=0,
  565        P#=0,
  566        LVL=1,
  567        LAST(YES=";",NO=",",ANY)=";",
  568        ALGN=WALIGNED,
  569        STCLASS=BASED);
  570
  571      %LSET LISTDIR='0'B;
  572      %LSET LISTEXP='1'B;
  573      %LSET LISTCOM='0'B;
  574      %LSET LISTSUB='1'B;
  575      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  576      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  577      %LSET INIT=CHARTEXT('INIT');
  578      %LSET EINIT=CHARTEXT('');
  579      %ELSE;
  580      %LSET INIT=CHARTEXT('/*');
  581      %LSET EINIT=CHARTEXT('*/');
  582      %ENDIF;
  583
  584      %IF LVL=1;
  585      DCL 1 FPTN STCLASS ALGN,
  586      %ELSE;
  587              %LVL FPTN,
  588      %ENDIF;
  589      %LSET EXCFRT_NXT_LVL=LVL+1;
  590
  591                %(LVL+1) %CHARTEXT('SUBC ') SBIN %INIT(SUBC)%EINIT,
  592                          /*K* TRLR.SUBC - SBIN   contains
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          17   
  593                          the exceptional condition sub-code.  The contents
  594                          of this field is dependent on the type of condition
  595                          that has occurred.  This field is redefined by
  596                          MCL_CODE, DEV, TRAP, and XCON.
  597                          */
  598                %(LVL+1) MCL_CODE REDEF %CHARTEXT('SUBC '),
  599                          /*K* TRLR.MCL_CODE - SBIN  for ALTRET frames,
  600                          contains the Service Request Code:
  601                          */
  602                %(LVL+2) V# UBIN(6) UNAL,
  603                          /*K* TRLR.MCL_CODE.V# - UBIN(6)  contains the number
  604                          of vectors in the FPT.
  605                          */
  606                %(LVL+2) CODE UBIN(10) UNAL,
  607                          /*K* TRLR.MCL_CODE.CODE - UBIN(10)   contains the monitor service
  608                          request code.  A list of monitor service codes
  609                          may be found in Appendix E of this manual.  The
  610                          system file, LCP_6, contains EQU statements for
  611                          monitor service request codes in the form
  612
  613                          }   %EQU G_MCL_name#
  614
  615                          where name is the name from M$name.
  616                          */
  617                %G$DEV (FPTN="DEV REDEF %CHARTEXT('SUBC ')",LVL=EXCFRT_NXT_LVL,LAST=NO,STCLASS=STCLASS);
  618                          /*K* TRLR.DEV - BIT(16)  for Interrupt frames,
  619                          contains the Device word:
  620                          */
  621
  622                          /*K* TRLR.DEV.CHN - UBIN(10)   contains the
  623                          interrupting channel number.
  624                          */
  625
  626                          /*K* TRLR.DEV.IL - UBIN(6)   contains the
  627                          interrupting level number.
  628                          */
  629
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          18   
  630              %(LVL+1) TRAP REDEF %CHARTEXT('SUBC '),
  631              %(LVL+2) TRAP# UBIN(8) UNAL,
  632                          /*K* TRLR.TRAP.TRAP# - UBIN(8)
  633                          for trap frames, contains the trap number associated
  634                          with the trap.  See REGS.I.TRAP#.
  635                          */
  636              %(LVL+2) IR BIT(8) UNAL,
  637
  638
  639                          /*K* TRLR.TRAP.IR - BIT(8)   contains the contents of the
  640                               Indicator register at the time of the trap.
  641                          */
  642              %(LVL+1) XCON REDEF %CHARTEXT('SUBC '),
  643                          /*K* TRLR.XCON - BIT(16) for exit control frames,
  644                          contains the following:
  645                          */
  646              %(LVL+2) TRAP# UBIN(8) UNAL,
  647                          /*K* TRLR.XCON.TRAP# - UBIN(8)   contains the value
  648                          from G$TSA.I.TRAP# at the time of the exit condition.
  649                          See REGS.I.TRAP#.
  650                          */
  651              %(LVL+2) FLAGS,
  652              %(LVL+3) XCONP BIT(1) UNAL,
  653                          /*K* TRLR.XCON.FLAGS.XCONP - BIT(1)  set
  654                          if exit control was already in progress on
  655                          this entry to exit control.
  656                          */
  657              %(LVL+3) * BIT(7) UNAL,
  658              %(LVL+1) %CHARTEXT('EVID ') SBIN WORD %INIT(EVID)%EINIT,
  659                          /*K* TRLR.EVID - SBIN  for event
  660                          frames, contains the event ID.  This
  661                          value is user supplied.
  662                           */
  663      %G_RNST (FPTN="RNST REDEF %CHARTEXT('EVID ')",LVL=EXCFRT_NXT_LVL,LAST=NO,STCLASS=STCLASS);
  664                          /*K* TRLR.RNST - BIT(16)  for Exit Control frames,
  665                          contains the Run Status.  If the program terminated
  666                          via M$EXIT, TRLR.RNST will be set to '0000'X.  If
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          19   
  667                          the program terminated for any other reason,
  668                          TRLR.RNST will be set as follows:
  669                          */
  670                          /*K*TRLR.RNST.XKEY - BIT(1)
  671                          .XEQ GU_LCP6_M G_RNST XKEY
  672                          */
  673                          /*K*TRLR.RNST.DSC - BIT(1)
  674                          .XEQ GU_LCP6_M G_RNST DSC
  675                          */
  676                          /*K*TRLR.RNST.OFF - BIT(1)
  677                          .XEQ GU_LCP6_M G_RNST OFF
  678                          */
  679                          /*K*TRLR.RNST.LIMX - BIT(1)
  680                          .XEQ GU_LCP6_M G_RNST LIMX
  681                          */
  682                          /*K*TRLR.RNST.EKEY - BIT(1)
  683                          .XEQ GU_LCP6_M G_RNST EKEY
  684                          */
  685                          /*K*TRLR.RNST.SSP - BIT(1)
  686                          .XEQ GU_LCP6_M G_RNST SSP
  687                          */
  688                          /*K*TRLR.RNST.INTABRT - BIT(1)
  689                          .XEQ GU_LCP6_M G_RNST INTABRT
  690                          */
  691                          /*K*TRLR.RNST.ABRT - BIT(1)
  692                          .XEQ GU_LCP6_M G_RNST ABRT
  693                          */
  694                          /*K*TRLR.RNST.LDTRC - BIT(1)
  695                          .XEQ GU_LCP6_M G_RNST LDTRC
  696                          */
  697                          /*K*TRLR.RNST.XXX - BIT(1)
  698                          .XEQ GU_LCP6_M G_RNST XXX
  699                          */
  700                          /*K*TRLR.RNST.ERR - BIT(1)
  701                          .XEQ GU_LCP6_M G_RNST ERR
  702                          */
  703
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          20   
  704              %(LVL+1) BRKCNT REDEF %CHARTEXT('EVID ') UBIN,
  705                          /*K* TRLR.BRKCNT - UBIN   contains the number of terminal
  706                          breaks received since the last read.  This is for
  707                          break condition only.
  708                           */
  709              %(LVL+1) DCB# REDEF %CHARTEXT('EVID ') UBIN,
  710                          /*K* DCB# - UBIN  for ALTRET frames contains the number of the
  711                          DCB associated with this monitor service request.
  712                          */
  713      %VLP_ERRCODE (FPTN=ERR,LVL=EXCFRT_NXT_LVL,LAST=",",STCLASS=STCLASS);
  714                          /*K*  TRLR.ERR - BIT(32)   contains the error code.
  715                          TRLR.ERR is in VLP_ERRCODE format and contains the
  716                          following subfields:
  717                          */
  718                          /*K*TRLR.ERR.FCG - BIT(10)
  719                          .XEQ GU_LCP6_M VLP_ERRCODE FCG
  720                          */
  721                          /*K*TRLR.ERR.MID - BIT(5)
  722                          .XEQ GU_LCP6_M VLP_ERRCODE MID
  723                          */
  724                          /*K*TRLR.ERR.MON - BIT(1)
  725                          .XEQ GU_LCP6_M VLP_ERRCODE MON
  726                          */
  727                          /*K*TRLR.ERR.ERR# - UBIN(13)  (Range is 0 to 8191)
  728                          .XEQ GU_LCP6_M VLP_ERRCODE ERR#
  729                          */
  730                          /*K*TRLR.ERR.SEV - UBIN(3)  (Range is 0 to 7)
  731                          .XEQ GU_LCP6_M VLP_ERRCODE SEV
  732                          */
  733              %(LVL+1) %CHARTEXT('P# ') SBIN WORD %INIT(P#)%EINIT LAST
  734                          /*K* TRLR.P# - SBIN   contains
  735                          the number of additional words on this
  736                          stack frame.  For ALTRET frame, this value is always zero.
  737
  738                          The content of these additional words
  739                          is dependent on the type of condition
  740                          that has occurred.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          21   
  741                          */
  742      %MEND;
  743
  744
  745
  746
  747
  748
  749
  750
  751
  752                          /*P* NAME: G_RNST.
  753
  754                          The G_RNST macro is used to generate the
  755                          RNST and FRS words in the JIT and the
  756                          RNST word in G$EXCFR.
  757                          */
  758
  759      %MACRO G_RNST (FPTN=RNST,
  760        LVL=2,
  761        LAST(YES=";",NO=",",ANY)=",",
  762        ALGN=CALIGNED,
  763        STCLASS=STATIC);
  764
  765      %LSET LISTDIR='0'B;
  766      %LSET LISTEXP='1'B;
  767      %LSET LISTCOM='0'B;
  768      %LSET LISTSUB='1'B;
  769      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  770      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  771      %LSET INIT=CHARTEXT('INIT');
  772      %LSET EINIT=CHARTEXT('');
  773      %ELSE;
  774      %LSET INIT=CHARTEXT('/*');
  775      %LSET EINIT=CHARTEXT('*/');
  776      %ENDIF;
  777
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          22   
  778      %IF LVL=1;
  779      DCL 1 FPTN STCLASS ALGN,
  780      %ELSE;
  781              %LVL FPTN ALGN,
  782      %ENDIF;
  783                %(LVL+1) XKEY BIT(1) UNAL %INIT('0'B)%EINIT,
  784                          /*K* XKEY - BIT(1)
  785                          is set if termination was because of a !X keyin
  786                          by the operator.
  787                          */
  788                %(LVL+1) DSC BIT(1) UNAL %INIT('0'B)%EINIT,
  789                          /*K* DSC - BIT(1)
  790                          is set if termination was because of path disconnect.
  791                          */
  792                %(LVL+1) OFF BIT(1) UNAL %INIT('0'B)%EINIT,
  793                          /*K* OFF - BIT(1)
  794                          is set if the monitor is terminating the session.
  795                          */
  796                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
  797
  798                %(LVL+1) LIMX BIT(1) UNAL %INIT('0'B)%EINIT,
  799                          /*K* LIMX - BIT(1)
  800                          is set if termination is because of a limit
  801                          that has been exceeded.
  802                          */
  803                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
  804
  805                %(LVL+1) EKEY BIT(1) UNAL %INIT('0'B)%EINIT,
  806                          /*K* EKEY - BIT(1)
  807                          is set if termination was because of a !E keyin
  808                          by the operator.
  809                          */
  810                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
  811
  812                %(LVL+1) * BIT(2) UNAL %INIT('0'B)%EINIT,
  813
  814                %(LVL+1) SSP BIT(1) UNAL %INIT('0'B)%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          23   
  815                          /*K* SSP - BIT(1)
  816                          is set if termination was initiated by a Special
  817                          Shared Processor; i.e., the Debugger.
  818                          */
  819                %(LVL+1) INTABRT BIT(1) UNAL %INIT('0'B)%EINIT,
  820                          /*K* INTABRT - BIT(1)
  821                          is set if termination occurred at an interrupt level.
  822                          */
  823                %(LVL+1) ABRT BIT(1) UNAL %INIT('0'B)%EINIT,
  824                          /*K* ABRT - BIT(1)
  825                          is set if termination was caused by a monitor detected
  826                          error condition.  This may be a program trap when
  827                          the program has no trap control or an errored
  828                          monitor service request when there is no ALTRET
  829                          routine specified.
  830                          */
  831                %(LVL+1) LDTRC BIT(1) UNAL %INIT('0'B)%EINIT,
  832                          /*K* LDTRC - BIT(1)
  833                          is set if an M$LDTRC service request was issued.
  834                          */
  835                %(LVL+1) XXX BIT(1) UNAL %INIT('0'B)%EINIT,
  836                          /*K* XXX - BIT(1)
  837                          is set if an M$XXX service request was issued.
  838                          */
  839                %(LVL+1) ERR BIT(1) UNAL %INIT('0'B)%EINIT LAST
  840                          /*K* ERR - BIT(1)
  841                          is set if an M$ERR service request was issued.
  842                          */
  843      %MEND;
  844
  845
  846
  847
  848                          /*F* NAME: ALTRET Condition
  849
  850                          The ALTRET option on a monitor service call establishes
  851                          a statement to receive control in case of errors.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          24   
  852                          The ALTRET label must be in the same scope as the
  853                          monitor service call.  Before transferring to the
  854                          ALTRET label, the system saves the environment in the
  855                          fixed ALTRET frame in the TCB.
  856
  857                          The ALTRET frame contains the environment as
  858                          described by the G$EXCFR structure.
  859                          The user may access the ALTRET frame through the
  860                          ALT$ pointer in the TCB; i.e.
  861
  862                          }   G$TCB$ -> G$TCB.ALT$ -> G$EXCFR
  863
  864                          G$EXCFR.ECC in the ALTRET frame will be set to %G_ALT#.
  865
  866                          G$EXCFR.TRLR.MCL_CODE will contain the monitor
  867                          service request code.
  868
  869                          G$EXCFR.TRLR.DCB# will contain the number of the
  870                          DCB associated with the monitor service request, if any.
  871
  872                          G$EXCFR.TRLR.ERR will contain the error code.
  873
  874                          The ALTRET frame is overlaid every time the
  875                          monitor transfers control to an ALTRET code sequence.
  876                          In the course of processing the ALTRET
  877                          condition, the user may call another monitor service,
  878                          but may first want to save the original ALTRET
  879                          environment, because the original ALTRET
  880                          environment is lost if another monitor service
  881                          error occurs.
  882
  883                          Also note that the ALTRET frame is overlaid if the
  884                          "insufficient space in Exceptional Condition
  885                          Stack" condition occurs at any exceptional
  886                          condition.
  887
  888                          The following list summarizes the monitor services
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          25   
  889                          that act indirectly on the TCB ALTRET frame or the
  890                          ALTRET environment stored in a frame of the
  891                          Exceptional Condition Stack.
  892
  893                          TU
  894                            Monitor Service    Function
  895                          ___________________________________________________________
  896
  897                            M$SENV             Save ALTRET environment in the Exceptional
  898                                               Condition Stack
  899
  900                            M$RENV             Restore ALTRET environment from top frame
  901                                               of Exceptional Condition Stack to TCB
  902                                               ALTRET frame
  903
  904                            M$RETRY            Retry original monitor service (original
  905                                               environment is in ALTRET frame)
  906
  907                            M$RETRYS           Retry original monitor service (original
  908                                               environment is in Exceptional Condition
  909                                               Stack top frame)
  910
  911                            M$MERC             Request monitor error handling (original
  912                                               environment is in ALTRET frame)
  913
  914                            M$MERCS            Request monitor error handling (original
  915                                               environment is in Exceptional Condition
  916                                               Stack top frame)
  917
  918                          ---------------------------------------------------------------
  919
  920                          TF
  921
  922                          */
  923
  924
  925
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          26   
  926
  927
  928                          /*F* NAME: M$SENV and M$RENV - Save/Restore ALTRET Environment
  929
  930                          The services to save and restore the environment
  931                          are typically used in conjunction with an ALTRET
  932                          code sequence.
  933                          Using M$SENV/M$RENV allows recursion into the
  934                          ALTRET code sequence and can
  935                          protect the ALTRET environment of
  936                          the main procedure of a program if any ASYNC
  937                          procedure also issues monitor service requests.
  938                          In addition, using the M$SENV service ensures the
  939                          integrity of the ALTRET environment in case of an
  940                          "insufficient space in TCB stack" condition which
  941                          can occur if an exceptional condition is detected
  942                          while the ALTRET code sequence has control.
  943
  944
  945                          M$SENV
  946
  947                          The M$SENV service allocates a frame in the
  948                          Exceptional Condition Stack and moves the
  949                          environment to the frame from the TCB ALTRET frame.
  950
  951                          The M$SENV service takes the alternate return if
  952                          there is no environment in the ALTRET frame or if
  953                          there is insufficient space to store the
  954                          environment in the Exceptional Condition Stack.
  955
  956                          The form of the call for this service is:
  957
  958                          CALL M$SENV [ALTRET (label)];
  959
  960                          Because no parameters are associated with the
  961                          monitor service call, there is no FPT.
  962
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          27   
  963
  964                          M$RENV
  965
  966                          The M$RENV service removes the top frame of the
  967                          exceptional condition stack and restores the
  968                          environment to the ALTRET frame in the TCB.
  969
  970                          The M$RENV service takes the alternate return if
  971                          the exceptional condition stack is empty or if the
  972                          top frame of the stack is not an ALTRET frame.
  973
  974                          The form of the call for this service is:
  975
  976                          CALL M$RENV [ALTRET (label)];
  977
  978                          Because no parameters are associated with the
  979                          monitor service call, there is no FPT.
  980                          */
  981
  982
  983
  984
  985                          /*P* NAME: FPT_EXC
  986
  987                          The FPT_EXC macro generates the FPT for the
  988                          following services:
  989
  990                             M$EVENT   M$INT   M$XCON   M$TRAP   M$DBCONTROL
  991
  992                          */
  993
  994      %MACRO FPT_EXC (FPTN=FPT_EXC,
  995        NHAND=NIL,
  996        PHAND=NIL,
  997        UENTRY$=NIL,
  998        ALGN=WALIGNED,
  999        ECC=HAND,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          28   
 1000        VECTORS=YES,
 1001        STCLASS=STATIC);
 1002
 1003      %LSET LISTDIR='0'B;
 1004      %LSET LISTEXP='1'B;
 1005      %LSET LISTCOM='0'B;
 1006      %LSET LISTSUB='1'B;
 1007      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1008      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1009      %LSET INIT=CHARTEXT(' INIT');
 1010      %LSET EINIT=CHARTEXT('');
 1011      %ELSE;
 1012      %LSET INIT=CHARTEXT('/*');
 1013      %LSET EINIT=CHARTEXT('*/');
 1014      %ENDIF;
 1015      %LSET NHND=CONCAT(TEXTCHAR(NHAND),'     ');
 1016      %LSET NEWHAND=%CHARTEXT(CONCAT('N',TEXTCHAR(ECC),'_'));
 1017      %LSET PREVHAND=%CHARTEXT(CONCAT('P',TEXTCHAR(ECC),'_'));
 1018      %LSET HAND$=%CHARTEXT(CONCAT(TEXTCHAR(ECC),'$'));
 1019
 1020      DCL 1 FPTN STCLASS ALGN,
 1021
 1022      %IF TEXTCHAR(VECTORS)='YES';
 1023      %LSET LVL=3;
 1024
 1025      %IF (SUBSTR(NHND,0,3)='NIL');
 1026            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1027            2 %NEWHAND REDEF V_ VECTOR,
 1028      %ELSE;
 1029            2 %NEWHAND VECTOR %INIT(VECTOR(NHAND))%EINIT,
 1030            2 V_ REDEF %NEWHAND VECTOR,
 1031      %ENDIF;
 1032                          /*K* NHAND = VARIABLE   locates a 2-word area
 1033                          that contains an EPTR to the procedure that
 1034                          is to be entered when the condition occurs.
 1035                          Default = NIL.
 1036                          */
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          29   
 1037            2 %PREVHAND VECTOR %INIT(VECTOR(PHAND))%EINIT,
 1038                          /*K* PHAND = VARIABLE    locates a 2-word area
 1039                          where an EPTR to the previously set procedure
 1040                          address is to be returned.
 1041                          Default = NIL.
 1042                          */
 1043      %ELSE;
 1044      %LSET LVL=2;
 1045      %ENDIF;
 1046
 1047      %IF TEXTCHAR(VECTORS)='YES';
 1048            2 V,
 1049      %ENDIF;
 1050              %LVL %HAND$ EPTR %INIT(ENTADDR(UENTRY$))%EINIT;
 1051                          /*K* UENTRY$ = {ENTRY|NIL}   specifies the procedure
 1052                          that is to be entered when the condition occurs.
 1053                          Default = NIL.
 1054
 1055                          If both NHAND and UENTRY$ are specified,
 1056                          the UENTRY$ parameter is ignored.
 1057                          */
 1058      %MEND;
 1059
 1060
 1061
 1062
 1063
 1064                          /*F* NAME: M$XCON - Set Exit Control
 1065
 1066                          EXIT CONDITIONS
 1067
 1068                          Conditions causing a program exit are listed
 1069                          below.  The conditions are classified by severity
 1070                          of impact as follows:
 1071
 1072                          TU
 1073                            Class    Condition
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          30   
 1074                          ___________________________________________________________
 1075
 1076                               1     Normal exit at M$EXIT
 1077                               1     Abnormal exit at M$ERR or M$XXX
 1078                               1     Transfer of control to another load module (M$LDTRC)
 1079                               1     Machine trap and no user trap control requested
 1080                               1     Monitor service error not processed by ALTRET code
 1081                                     sequence or M$TRAP (MCL) procedure
 1082                               1     Exceptional condition occurs but procedure cannot
 1083                                     be entered because the stack is full
 1084                               1     Operator errored the user
 1085
 1086                               2     Resources limit exceeded
 1087
 1088                               3     Operator aborted the user
 1089                               3     Line disconnect
 1090
 1091                          ---------------------------------------------------------------
 1092                          TF
 1093
 1094                          The M$XCON service is used to establish the entry
 1095                          address of the users procedure that
 1096                          is to receive control should any of these conditions
 1097                          occur.
 1098
 1099                          When the exit procedure takes control, the program is in
 1100                          "exit" status; a flag in the ECCB is set to
 1101                          reflect "exit control in progress".
 1102                          Executing the M$XCON service within an exit procedure removes
 1103                          the program from "exit" status.
 1104
 1105                          The exit control frame on the TCB contains the environment as
 1106                          described by the G$EXCFR structure.
 1107                          The user may access the exit control frame through the
 1108                          STK$ pointer in the TCB; i.e.
 1109
 1110                          }   G$TCB$ -> G$TCB.STK$ -> G$EXCFR
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          31   
 1111
 1112                          G$EXCFR.ECC in the exit control frame will be set to %G_XCON#.
 1113
 1114                          G$EXCFR.TRLR.RNST in the exit control frame will
 1115                          contain the value of G$JIT.RNST as it existed at
 1116                          the time of the exit condition.
 1117
 1118                          G$EXCFR.TRLR.ERR will contain the error code.
 1119
 1120                          A time limit is imposed if a class 2 or class 3
 1121                          exit condition exists.
 1122
 1123                          If there is insufficient room on the
 1124                          Exceptional Condition stack for the exceptional
 1125                          condition environment, as indicated by the
 1126                          the FLAGS.TCBFULL bit set in the ECCB, the exit control
 1127                          environment will be in the ALTRET frame with the
 1128                          ECC set to indicate that the TCB is full (%G_TCBFULL#).
 1129                          The format of the frame is the
 1130                          same as the exit control frame that is placed on the
 1131                          stack with the exception of the value of the ECC.
 1132                          The user should always inspect the ECCB upon entry to
 1133                          the exit control procedure to determine if this condition
 1134                          exists. When this condition occurs, the exit
 1135                          control information must be accessed via the
 1136                          ALTRET frame pointer in the TCB. For example, on
 1137                          entry to an exit control procedure:
 1138                          }
 1139                          }    IF G$ECCB$->G$ECCB.FLAGS.TCBFULL
 1140                          }    THEN MYPTR$ = G$TCB$->G$TCB.ALT$;
 1141                          }    ELSE MYPTR$ = G$TCB$->G$TCB.STK$;
 1142                          }
 1143
 1144                          The M$XCON service may also be used to determine the
 1145                          address of any previously set exit control procedure.
 1146                          This previously set procedure address may then
 1147                          then be used on a subsequent call to M$XCON to
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          32   
 1148                          restore the exit control procedure address to its
 1149                          former value.
 1150
 1151                          Using the M$XCON service with the exit control procedure
 1152                          address set NIL causes the request for exit control
 1153                          to be reset.
 1154                          If an exit condition occurs when exit control has
 1155                          been reset, the program is aborted.
 1156
 1157                          To resume normal execution of a program after
 1158                          receiving exit control, the user can call the
 1159                          M$TRTN service.  This service removes the exit
 1160                          control frame from the TCB stack and removes
 1161                          the program from the "exit" status.
 1162
 1163                          Please note that a program is removed from the "exit" status
 1164                          any time an exit control frame is removed from the Exceptional
 1165                          Condition Stack and the frame does not indicate a nested
 1166                          exit control entry; when G$EXCFR.TRLR.XCON.XCONP
 1167                          is reset.  This may be as a result of an M$CLRSTK service
 1168                          request or an M$TRTN service request.
 1169
 1170
 1171                          The user can also issue the M$XCON service within
 1172                          the exit procedure to remove the program from the "exit"
 1173                          status.  The user may call this service with a
 1174                          previously acquired PXCON parameter specified
 1175                          as the exit control entry address to reestablish
 1176                          a previous exit
 1177                          control entry.  If this is followed by an M$EXIT,
 1178                          M$ERR or M$XXX, that exit control entry will then
 1179                          be entered.
 1180
 1181                          To unconditionally exit the current program, the
 1182                          user can call the M$EXIT, M$ERR, or M$XXX service.
 1183
 1184
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          33   
 1185                          The form of the call for this service is:
 1186
 1187                          CALL M$XCON (FPT_XCON) [ALTRET (label)];
 1188
 1189                          Parameters for the M$XCON service are as follows:
 1190                          */
 1191      %MACRO FPT_XCON (FPTN=FPT_XCON,
 1192        NXCON=NIL,
 1193        PXCON=NIL,
 1194        XCON$=NIL,
 1195        ALGN=WALIGNED,
 1196        VECTORS=YES,
 1197        STCLASS=STATIC);
 1198
 1199      %LSET LISTDIR='0'B;
 1200      %LSET LISTEXP='1'B;
 1201      %LSET LISTCOM='0'B;
 1202      %LSET LISTSUB='1'B;
 1203              %FPT_EXC(FPTN=FPTN,NHAND=NXCON,PHAND=PXCON,UENTRY$=XCON$,
 1204              VECTORS=VECTORS,STCLASS=STCLASS,ECC=XCON);
 1205                          /*K* NXCON = VARIABLE   locates a 2-word area
 1206                          that contains an EPTR to the exit procedure that
 1207                          is to be entered upon exit of the current
 1208                          program whether normal or abnormal.
 1209                          If the EPTR is ENTADDR(NIL) the request for
 1210                          exit control is reset.
 1211                          Default = NIL.
 1212                          */
 1213
 1214                          /*K* PXCON = VARIABLE    locates a 2-word area
 1215                          where an EPTR to the previously set exit procedure
 1216                          address is to be returned.
 1217                          Default = NIL.
 1218                          */
 1219
 1220                          /*K* XCON$ = {ENTRY|NIL}   specifies the procedure
 1221                          that is to be entered upon exit of the current
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          34   
 1222                          program whether normal or abnormal.
 1223                          Specifying NIL will cause the request for exit
 1224                          control to be reset.  Default = NIL.
 1225
 1226                          If both NXCON and XCON$ are specified,
 1227                          the XCON$ parameter is ignored.
 1228                          */
 1229      %MEND;
 1230
 1231
 1232
 1233                          /*F* NAME: M$INT_ - Set Break Control
 1234                          The M$INT service permits the caller to specify a
 1235                          procedure to be entered in the event the BREAK key
 1236                          or YC (Control Y) is depressed.  The specified
 1237                          procedure is entered with the environment of the
 1238                          interrupted process on the TCB.
 1239
 1240                          The event frame on the TCB contains the environment as
 1241                          described by the G$EXCFR structure.
 1242                          The user may access the event frame through the
 1243                          STK$ pointer in the TCB; i.e.
 1244
 1245                          }   G$TCB$ -> G$TCB.STK$ -> G$EXCFR
 1246
 1247                          G$EXCFR.ECC in the event frame will be set to %G_BRK#.
 1248
 1249                          G$EXCFR.TRLR.SUBC in the event frame will be set to
 1250                          one of the following:
 1251                          }
 1252                          } %G_YCSC#      0      YC (Control Y) was typed.
 1253                          } %G_BRKSC#     1      BREAK was typed.
 1254                          }
 1255
 1256                          G$EXCFR.TRLR.ERR will contain the JIT error code.
 1257
 1258
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          35   
 1259                          The form of the call for this service is:
 1260
 1261                          CALL M$INT (FPT_INT) [ALTRET (label)];
 1262
 1263                          Parameters for the M$INT service are as follows:
 1264                          */
 1265
 1266      %MACRO FPT_INT (FPTN=FPT_INT,
 1267        NINT=NIL,
 1268        PINT=NIL,
 1269        INT$=NIL,
 1270        ALGN=WALIGNED,
 1271        VECTORS=YES,
 1272        STCLASS=STATIC);
 1273
 1274      %LSET LISTDIR='0'B;
 1275      %LSET LISTEXP='1'B;
 1276      %LSET LISTCOM='0'B;
 1277      %LSET LISTSUB='1'B;
 1278              %FPT_EXC(FPTN=FPTN,NHAND=NINT,PHAND=PINT,UENTRY$=INT$,
 1279              VECTORS=VECTORS,STCLASS=STCLASS,ECC=INT);
 1280                          /*K* NINT = VARIABLE   locates a 2-word area
 1281                          that contains an EPTR to the procedure that
 1282                          is to be entered upon when the terminal break
 1283                          key is depressed.  If the EPTR is ENTADDR(NIL)
 1284                          the request for break control is reset.
 1285                          Default = NIL.
 1286                          */
 1287
 1288                          /*K* PINT = VARIABLE    locates a 2-word area
 1289                          where an EPTR to the previously set break control
 1290                          address is to be returned.
 1291                          Default = NIL.
 1292                          */
 1293
 1294                          /*K* INT$ = {ENTRY|NIL}   specifies the procedure
 1295                          that is to be entered when the terminal break key
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          36   
 1296                          is depressed.  An address of NIL resets any
 1297                          previous request for break control.
 1298                          Default = NIL.
 1299
 1300                          If both NINT and INT$ are specified,
 1301                          the INT$ parameter is ignored.
 1302                          */
 1303      %MEND;
 1304
 1305
 1306
 1307
 1308
 1309                          /*F* NAME: M$EVENT - Set Event Control
 1310
 1311                          The M$EVENT service is used to establish the entry
 1312                          address of the users event processing procedure that
 1313                          is to receive control upon completion of an asynchronous
 1314                          operation, such as no-wait read or real time clock
 1315                          expiration.
 1316
 1317                          This service may also be used to determine the
 1318                          address of any previously set event control procedure
 1319                          and to reset the request for event control.  If
 1320                          an event completion occurs when event control has
 1321                          been reset, the program is aborted.
 1322
 1323                          Entry to the event procedure occurs following
 1324                          a monitor service request or at the completion
 1325                          of a time slice.
 1326                          If a program has been suspended by the M$WAIT
 1327                          service when an event completion occurs, the
 1328                          suspension is terminated and the event completion
 1329                          is reported.
 1330
 1331                          The user may request as many concurrent no-wait
 1332                          operations as desired.  The order in which events
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          37   
 1333                          are processed is not necessarily the order in
 1334                          which they were requested.  The event procedure
 1335                          processes events in the order of event completion.
 1336
 1337                          The event frame on the TCB contains the environment as
 1338                          described by the G$EXCFR structure.
 1339                          The user may access the event frame through the
 1340                          STK$ pointer in the TCB; i.e.
 1341
 1342                          }   G$TCB$ -> G$TCB.STK$ -> G$EXCFR
 1343
 1344                          G$EXCFR.ECC in the event frame will be set to %G_EVENT#.
 1345
 1346                          G$EXCFR.TRLR.SUBC in the event frame will be set to
 1347                          one of the following:
 1348                          }
 1349                          } %G_XTMRSC#      0    M$CLOCK execution timer expiration
 1350                          } %G_RTTMRSC#     1    M$CLOCK real-time timer expiration
 1351                          } %G_DATA_RQS#    3    Remote end-point has issued a read
 1352                          } %G_DATA_AVL#    4    Remote end-point has issued a write
 1353                          } %G_IO_CMP#      5    IO Complete
 1354                          }
 1355
 1356                          G$EXCFR.TRLR.EVID contains the user supplied event
 1357                          identification.
 1358
 1359                          G$EXCFR.TRLR.ERR will contain the error code (if any).
 1360
 1361                          The form of the call for this service is:
 1362
 1363                          CALL M$EVENT (FPT_EVENT) [ALTRET(label)];
 1364
 1365                          The parameter for this service is as follows:
 1366                          */
 1367
 1368      %MACRO FPT_EVENT (FPTN=FPT_EVENT,
 1369        NEVENT=NIL,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          38   
 1370        PEVENT=NIL,
 1371        EVENT$=NIL,
 1372        ALGN=WALIGNED,
 1373        VECTORS=YES,
 1374        STCLASS=STATIC);
 1375
 1376      %LSET LISTDIR='0'B;
 1377      %LSET LISTEXP='1'B;
 1378      %LSET LISTCOM='0'B;
 1379      %LSET LISTSUB='1'B;
 1380              %FPT_EXC(FPTN=FPTN,NHAND=NEVENT,PHAND=PEVENT,UENTRY$=EVENT$,
 1381              VECTORS=VECTORS,STCLASS=STCLASS,ECC=EVENT);
 1382                          /*K* NEVENT = VARIABLE   locates a 2-word area
 1383                          that contains an EPTR to the procedure that
 1384                          is to be entered when event completion occurs.
 1385                          If the EPTR contained in NEVENT is ENTADDR(NIL)
 1386                          the request for event control is reset.
 1387                          Default = NIL.
 1388                          */
 1389
 1390                          /*K* PEVENT = VARIABLE    locates a 2-word area
 1391                          where an EPTR to the previously set event
 1392                          procedure is to be returned.
 1393                          Default = NIL.
 1394                          */
 1395
 1396                          /*K* EVENT$ = {ENTRY|NIL}   specifies the event
 1397                          procedure entry address.  An address of NIL resets
 1398                          a previous request and specifies that event
 1399                          completion is not to be reported to the user.
 1400                          Default = NIL.
 1401
 1402                          If both NEVENT and EVENT$ are specified,
 1403                          the EVENT$ parameter is ignored.
 1404                          */
 1405      %MEND;
 1406
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          39   
 1407
 1408
 1409
 1410
 1411
 1412                          /*F* NAME: G$NWIO - No-Wait IO Event Frame
 1413
 1414                          The %G$NWIO macro may be used to generate a
 1415                          based structure of a frame placed on the TCB
 1416                          stack for a No-wait I/O event.
 1417
 1418                          All the fields in the G$NWIO structure are identical
 1419                          to those in G$EXCFR.
 1420
 1421                          Of special interest here is G$NWIO.TRLR.EVID
 1422                          which will contain the event ID as was specified
 1423                          on the M$OPEN service request.
 1424
 1425                          The standard exceptional condition frame is then
 1426                          followed by:
 1427                          */
 1428
 1429      %MACRO G$NWIO (FPTN=G$NWIO,STCLASS=BASED,PARONLY=0);
 1430       %IF PARONLY=0;
 1431              %G$EXCFR (FPTN=FPTN,STCLASS=STCLASS,LAST=",");
 1432                          /*K* TRLR.SUBC - UBIN   contains the event sub-code.
 1433                          For No-wait I/O completion this field will be set
 1434                          to %G_IO_CMP#.
 1435                          */
 1436                          /*K* EVID - UBIN   contains the event ID as
 1437                          was specified on the M$READ or M$WRITE Service Request.
 1438                          */
 1439                          /*K* TRLR.ERR is the 32 bit error code.
 1440                          */
 1441       %ELSE;
 1442      DCL 1 FPTN STCLASS ALIGNED,
 1443            2 P# UBIN,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          40   
 1444                          /*K* P# - UBIN   contains the number
 1445                          of words of parameters that follow.
 1446                          */
 1447       %ENDIF;
 1448            2 ARS UBIN,
 1449                          /*K* ARS - UBIN  contains the
 1450                          actual record size.
 1451                          */
 1452            2 DVE,
 1453              3 DVBYTE,
 1454                          /*K* DVE.DVBYTE is returned on reads
 1455                          and contains information about the nature of
 1456                          the item read.  See M$DCB.  This field contains
 1457                          the following subfields:
 1458                          */
 1459                4 * BIT(1),
 1460                4 VFC BIT(1),
 1461                          /*K* DVE.DVBYTE.VFC - BIT(1).
 1462                          Set if the first character of the
 1463                          record read should be interpreted as a VFC character.                         */
 1464                4 BIN BIT(1),
 1465                          /*K* DVE.DVBYTE.BIN - BIT(1).
 1466                          Set if the record was read in binary
 1467                          mode.  This means that data was read bit-by-bit from
 1468                          the medium into the buffer rather than one character
 1469                          per 9 bit byte.                                                               */
 1470                4 TRANS BIT(1),
 1471                          /*K* DVE.DVBYTE.TRANS - BIT(1).
 1472                          Set if the record was read in
 1473                          transparent mode.  This means that no translation
 1474                          was performed by the system and the data is that
 1475                          which was read from the I/O medium. This bit is only
 1476                          set in cases where the default read of the record
 1477                          would cause a translation to be done, as with
 1478                          time-sharing terminals.
 1479                                                                                  */
 1480                4 * BIT(3),
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          41   
 1481              3 * BIT(1),
 1482              3 EOMCHAR CHAR(1),
 1483                          /*K* DVE.EOMCHAR - CHAR(1)   contains
 1484                          the activation character of reads.
 1485                          */
 1486            2 * UBIN(16) UNAL,
 1487
 1488            %VLP_CG (FPTN=CGPARM,LVL=2,STCLASS=STCLASS,LAST=";");
 1489                          /*K* CGPARM is described under
 1490                          VLP_CG.
 1491                          */
 1492
 1493      %MEND;
 1494
 1495
 1496
 1497
 1498
 1499                          /*F* NAME: G$COMIO - Communications IO Event Frame
 1500
 1501                          The G$COMIO macro may be used to generate a
 1502                          based structure of a frame placed on the TCB
 1503                          stack for a communications I/O event.
 1504                          All the fields in the G$COMIO structure are identical
 1505                          to those in G$EXCFR.
 1506
 1507                           Of special interest here is G$COMIO.TRLR.EVID
 1508                           which will contain the event ID as was specified
 1509                           on the M$OPEN service request.
 1510
 1511                          The standard exceptional condition frame is then
 1512                          followed by:
 1513                          */
 1514
 1515      %MACRO G$COMIO (FPTN=G$COMIO,STCLASS=BASED,PARONLY=0);
 1516
 1517       %IF PARONLY=0;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          42   
 1518
 1519              %G$EXCFR (FPTN=FPTN,STCLASS=STCLASS,LAST=NO);
 1520       %ELSE;
 1521
 1522      DCL 1 FPTN STCLASS ALIGNED,
 1523            2 P# UBIN,
 1524
 1525       %ENDIF;
 1526            2 ARS UBIN;
 1527                          /*K* ARS - UBIN   contains the
 1528                          actual record size. This is the size of the record
 1529                          available for a %G_DATA_AVL# event or the size
 1530                          of the read buffer for a %G_DATA_RQS# event.
 1531                          */
 1532
 1533      %MEND;
 1534
 1535
 1536
 1537                          /*F* NAME: M$DBCONTROL - Set Debugger Control
 1538
 1539                          The M$DBCONTROL service is used to establish the entry
 1540                          address of the procedure that
 1541                          is to receive control upon the occurrence of an event
 1542                          originated by the associated debugger.
 1543                          This service allows the FPL interpreter to establish
 1544                          control of the async event needed for post-association
 1545                          of the debugger and asynchronous interrupt of the
 1546                          FPRG.
 1547
 1548                          Note that a debugger need not be currently associated
 1549                          in order to use this service.  The user may determine
 1550                          if a debugger is currently associated by inspecting
 1551                          the contents of G$JIT.DB#.
 1552
 1553                          This service may also be used to determine the
 1554                          address of any previously set debug control procedure
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          43   
 1555                          and to reset the request for debug control.  If
 1556                          a debug event occurs when debug control has
 1557                          been reset, the program is aborted.
 1558
 1559                          The frame on the TCB contains the environment as
 1560                          described by the G$EXCFR structure.
 1561                          The TCB frame may be accessed through the
 1562                          STK$ pointer in the TCB; i.e.
 1563
 1564                          }   G$TCB$ -> G$TCB.STK$ -> G$EXCFR
 1565
 1566                          G$EXCFR.ECC in the frame will be set to %G_DBCONTROL#.
 1567
 1568                          The form of the call for this service is:
 1569
 1570                          CALL M$DBCONTROL (FPT_DBCONTROL) [ALTRET(label)];
 1571
 1572                          The parameter for this service is as follows:
 1573                          */
 1574
 1575      %MACRO FPT_DBCONTROL (FPTN=FPT_DBCONTROL,
 1576        NDBCONTROL=NIL,
 1577        PDBCONTROL=NIL,
 1578        DBCONTROL$=NIL,
 1579        ALGN=WALIGNED,
 1580        VECTORS=YES,
 1581        STCLASS=STATIC);
 1582
 1583      %LSET LISTDIR='0'B;
 1584      %LSET LISTEXP='1'B;
 1585      %LSET LISTCOM='0'B;
 1586      %LSET LISTSUB='1'B;
 1587              %FPT_EXC(FPTN=FPTN,NHAND=NDBCONTROL,PHAND=PDBCONTROL,UENTRY$=DBCONTROL$,
 1588              VECTORS=VECTORS,STCLASS=STCLASS,ECC=DBCONTROL);
 1589                          /*K* NDBCONTROL = VARIABLE   locates a 2-word area
 1590                          that contains an EPTR to the procedure that
 1591                          is to be entered when debug control events occur.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          44   
 1592                          If the EPTR contained in NDBCONTROL is ENTADDR(NIL)
 1593                          the request for debug control is reset.
 1594                          Default = NIL.
 1595                          */
 1596
 1597                          /*K* PDBCONTROL = VARIABLE    locates a 2-word area
 1598                          where an EPTR to the previously set debug control
 1599                          procedure is to be returned.
 1600                          Default = NIL.
 1601                          */
 1602
 1603                          /*K* DBCONTROL$ = {ENTRY|NIL}   specifies the debug control
 1604                          procedure entry address.  An address of NIL resets
 1605                          a previous request and specifies that debug control
 1606                          events are not to be reported.
 1607                          Default = NIL.
 1608
 1609                          If both NDBCONTROL and DBCONTROL$ are specified,
 1610                          the DBCONTROL$ parameter is ignored.
 1611                          */
 1612      %MEND;
 1613
 1614
 1615
 1616
 1617
 1618
 1619
 1620                          /*P* NAME: G_TRAP_BLOCK
 1621
 1622                          The G_TRAP_BLOCK macro defines the structure of the
 1623                          user's trap control settings.  This structure
 1624                          is used as follows:
 1625                             }
 1626                             } - within the Exceptional Condition Control Block;
 1627                             }   used by the monitor to determine if the user has
 1628                             }   requested control over specific traps.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          45   
 1629                             }
 1630                             } - within the New Trap Conditions (NTC) option of
 1631                             }   M$TRAP which allows the user to specify control
 1632                             }   over specified traps.
 1633                             }
 1634                             } - within the Prior Trap Conditions (PTC) option of
 1635                             }   M$TRAP where the trap condition settings are
 1636                             }   returned to the user.
 1637                             }
 1638                             } - within the debugger data segment to specify
 1639                             }   on which user traps the debugger wishes to
 1640                             }   receive control.
 1641                             }
 1642                          This structure is simply one bit for each of
 1643                          the possible hardware traps.
 1644                          The trap_name = {G_ABORT# | G_TRAP#} parameters allow
 1645                          specification of the trap state of each of the traps.
 1646                          If set to G_TRAP# ('1'B), the user trap handler will
 1647                          be entered.  If set to G_ABORT# ('0'B), the program
 1648                          will be aborted.
 1649                          Refer to VLP_TRAP_CONDITIONS for the keyword names
 1650                          and meanings of each of the individual traps.
 1651                          Default for each trap = G_ABORT#.
 1652                          */
 1653
 1654      %MACRO G_TRAP_BLOCK (FPTN=G_TRAP_BLOCK,
 1655
 1656        IGN_IO(G_YES#='1'B,G_NO#='0'B,ANY)='0'B,
 1657        MCL(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1658        TRACE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1659        NO_SIP(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1660        UNIMPL(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1661        INT_REG_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1662        STK_UF(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1663        STK_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1664        REMOTE_DESC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1665        PRIV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          46   
 1666        MEM_PROT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1667        INT_UR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1668        PROG_ERR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1669        INT_MBE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1670        EXT_UR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1671        EXT_MBE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1672        C_DBZ(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1673        C_SPEC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1674        C_CHAR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1675        C_TRUNC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1676        C_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1677        CIP_QLT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1678        SIP_QLT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1679        EXT_PROT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1680        S_ARG(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1681        FPRG_EXIT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1682        FPRG_ERR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1683        FPRG_XXX(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1684        FPRG_LDTRC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1685        FPRG_XBREAK(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1686        FPRG_SCREECH(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1687        HOST_INT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1688        FPRG_EVENT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1689        FPRG_BRK(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1690        FPRG_XCON(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1691        FPRG_MCLTRAP(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1692        DB_TIMER(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1693        FPRG_START(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1694        FPRG_START2(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1695        MCL2(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ANY)='0'B,
 1696
 1697        LVL=1,
 1698        DB_DS(YES=1,NO=0,ANY)=0,
 1699        LAST(YES=";",NO=",",ANY)=";",
 1700        ALGN=WALIGNED,
 1701        STCLASS=STATIC);
 1702
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          47   
 1703      %LSET LISTDIR='0'B;
 1704      %LSET LISTEXP='1'B;
 1705      %LSET LISTCOM='0'B;
 1706      %LSET LISTSUB='1'B;
 1707      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1708      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1709      %LSET INIT=CHARTEXT('INIT');
 1710      %LSET EINIT=CHARTEXT('');
 1711      %ELSE;
 1712      %LSET INIT=CHARTEXT('/*');
 1713      %LSET EINIT=CHARTEXT('*/');
 1714      %ENDIF;
 1715
 1716      %IF LVL=1;
 1717      DCL 1 FPTN STCLASS ALGN,
 1718      %ELSE;
 1719              %LVL FPTN,
 1720      %ENDIF;
 1721                %(LVL+1) %CHARTEXT('IGN_IO ') BIT(1) UNAL %INIT(IGN_IO)%EINIT,
 1722                %(LVL+1) %CHARTEXT('MCL ') BIT(1) UNAL %INIT(MCL)%EINIT,
 1723                %(LVL+1) %CHARTEXT('TRACE ') BIT(1) UNAL %INIT(TRACE)%EINIT,
 1724                %(LVL+1) %CHARTEXT('NO_SIP ') BIT(1) UNAL %INIT(NO_SIP)%EINIT,
 1725                %(LVL+1) TROT BIT(1) UNAL %INIT('0'B)%EINIT,
 1726                %(LVL+1) %CHARTEXT('UNIMPL ') BIT(1) UNAL %INIT(UNIMPL)%EINIT,
 1727                %(LVL+1) %CHARTEXT('INT_REG_OV ') BIT(1) UNAL %INIT(INT_REG_OV)%EINIT,
 1728                %(LVL+1) %CHARTEXT('S_DBZ ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1729                %(LVL+1) %CHARTEXT('S_EXP_OV ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1730                %(LVL+1) %CHARTEXT('STK_UF ') BIT(1) UNAL %INIT(STK_UF)%EINIT,
 1731                %(LVL+1) %CHARTEXT('STK_OV ') BIT(1) UNAL %INIT(STK_OV)%EINIT,
 1732                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 1733                %(LVL+1) %CHARTEXT('REMOTE_DESC ') BIT(1) UNAL %INIT(REMOTE_DESC)%EINIT,
 1734                %(LVL+1) %CHARTEXT('PRIV ') BIT(1) UNAL %INIT(PRIV)%EINIT,
 1735                %(LVL+1) %CHARTEXT('MEM_PROT ') BIT(1) UNAL %INIT(MEM_PROT)%EINIT,
 1736                %(LVL+1) %CHARTEXT('INT_UR ') BIT(1) UNAL %INIT(INT_UR)%EINIT,
 1737                %(LVL+1) %CHARTEXT('PROG_ERR ') BIT(1) UNAL %INIT(PROG_ERR)%EINIT,
 1738                %(LVL+1) %CHARTEXT('INT_MBE ') BIT(1) UNAL %INIT(INT_MBE)%EINIT,
 1739                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          48   
 1740                %(LVL+1) %CHARTEXT('S_EXP_UF ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1741                %(LVL+1) %CHARTEXT('S_PROG_ERR ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1742                %(LVL+1) %CHARTEXT('S_SIGNIF ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1743                %(LVL+1) %CHARTEXT('S_PRECISION ') BIT(1) UNAL %INIT('0'B)%EINIT,
 1744                %(LVL+1) %CHARTEXT('EXT_UR ') BIT(1) UNAL %INIT(EXT_UR)%EINIT,
 1745                %(LVL+1) %CHARTEXT('EXT_MBE ') BIT(1) UNAL %INIT(EXT_MBE)%EINIT,
 1746                %(LVL+1) %CHARTEXT('C_DBZ ') BIT(1) UNAL %INIT(C_DBZ)%EINIT,
 1747                %(LVL+1) %CHARTEXT('C_SPEC ') BIT(1) UNAL %INIT(C_SPEC)%EINIT,
 1748                %(LVL+1) %CHARTEXT('C_CHAR ') BIT(1) UNAL %INIT(C_CHAR)%EINIT,
 1749                %(LVL+1) %CHARTEXT('C_TRUNC ') BIT(1) UNAL %INIT(C_TRUNC)%EINIT,
 1750                %(LVL+1) %CHARTEXT('C_OV ') BIT(1) UNAL %INIT(C_OV)%EINIT,
 1751                %(LVL+1) %CHARTEXT('CIP_QLT ') BIT(1) UNAL %INIT(CIP_QLT)%EINIT,
 1752                %(LVL+1) %CHARTEXT('SIP_QLT ') BIT(1) UNAL %INIT(SIP_QLT)%EINIT,
 1753                %(LVL+1) %CHARTEXT('EXT_PROT ') BIT(1) UNAL %INIT(EXT_PROT)%EINIT,
 1754                %(LVL+1) %CHARTEXT('S_ARG ') BIT(1) UNAL %INIT(S_ARG)%EINIT,
 1755      %IF DB_DS=0;
 1756                %(LVL+1) *(0:13) BIT(1) UNAL %INIT('0'B*0)%EINIT LAST
 1757      %ELSE;
 1758                %(LVL+1) *(0:12) BIT(1) UNAL %INIT('0'B*0)%EINIT,
 1759                %(LVL+1) %CHARTEXT('FPRG_EXIT ') BIT(1) UNAL %INIT(FPRG_EXIT)%EINIT,
 1760                %(LVL+1) %CHARTEXT('FPRG_ERR ') BIT(1) UNAL %INIT(FPRG_ERR)%EINIT,
 1761                %(LVL+1) %CHARTEXT('FPRG_XXX ') BIT(1) UNAL %INIT(FPRG_XXX)%EINIT,
 1762                %(LVL+1) %CHARTEXT('FPRG_LDTRC ') BIT(1) UNAL %INIT(FPRG_LDTRC)%EINIT,
 1763                %(LVL+1) %CHARTEXT('FPRG_XBREAK ') BIT(1) UNAL %INIT(FPRG_XBREAK)%EINIT,
 1764                %(LVL+1) %CHARTEXT('FPRG_SCREECH ') BIT(1) UNAL %INIT(FPRG_SCREECH)%EINIT,
 1765                %(LVL+1) *(0:1) BIT(1) UNAL %INIT('0'B*0)%EINIT,
 1766                          /* Traps 53 - 54                                                              */
 1767                %(LVL+1) %CHARTEXT('HOST_INT ') BIT(1) UNAL %INIT(HOST_INT)%EINIT,
 1768                %(LVL+1) %CHARTEXT('FPRG_EVENT ') BIT(1) UNAL %INIT(FPRG_EVENT)%EINIT,
 1769                %(LVL+1) %CHARTEXT('FPRG_BRK ') BIT(1) UNAL %INIT(FPRG_BRK)%EINIT,
 1770                %(LVL+1) %CHARTEXT('FPRG_XCON ') BIT(1) UNAL %INIT(FPRG_XCON)%EINIT,
 1771                %(LVL+1) %CHARTEXT('FPRG_MCLTRAP ') BIT(1) UNAL %INIT(FPRG_MCLTRAP)%EINIT,
 1772                %(LVL+1) %CHARTEXT('DB_TIMER ') BIT(1) UNAL %INIT(DB_TIMER)%EINIT,
 1773                %(LVL+1) %CHARTEXT('FPRG_START ') BIT(1) UNAL %INIT(FPRG_START)%EINIT,
 1774                %(LVL+1) %CHARTEXT('FPRG_START2 ') BIT(1) UNAL %INIT(FPRG_START2)%EINIT,
 1775                %(LVL+1) %CHARTEXT('MCL2 ') BIT(1) UNAL %INIT(MCL2)%EINIT LAST
 1776      %ENDIF;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          49   
 1777      %MEND;
 1778
 1779
 1780
 1781
 1782
 1783
 1784
 1785                          /*F* NAME: M$TRAP - Set Trap Control
 1786
 1787                          The M$TRAP service identifies particular hardware
 1788                          detected traps at which the user wants control
 1789                          and provides for the enabling or disabling of
 1790                          the Trace, Overflow and Truncation traps.
 1791
 1792                          A call to M$TRAP specifies the desired trap
 1793                          settings through the New Trap Conditions (NTC)
 1794                          parameter.  The call may also request that the
 1795                          settings of the Prior Trap Conditions (PTC) be
 1796                          returned to the user.
 1797
 1798                          The trap condition settings
 1799                          include the trap handler entry address
 1800                          and the state of each of
 1801                          the hardware faults (TRAP or ABORT).  The
 1802                          structure of the NTC and PTC areas should
 1803                          be generated using the VLP_TRAP_CONDITIONS macro.
 1804
 1805                          The user may change trap control and specify
 1806                          different trap procedures during program execution.
 1807                          The M$TRAP FPT may specify that both the PTC be
 1808                          returned to the user and that the active
 1809                          trap conditions be replaced with those specified in
 1810                          the NTC.  The active trap conditions may later be
 1811                          reset to their previous values by calling M$TRAP
 1812                          specifying the PTC area that was returned on the
 1813                          original call as the NTC parameter.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          50   
 1814                          This allows any procedure within a
 1815                          program to handle its own trap conditions and to
 1816                          restore the trap conditions to their original
 1817                          states before returning.
 1818
 1819                          Entry to the trap procedure follows
 1820                          the occurrence of a hardware trap or a monitor
 1821                          service request error when no ALTRET is specified.
 1822
 1823                          The trap frame on the TCB contains the environment as
 1824                          described by the G$EXCFR structure.
 1825                          The user may access the trap frame through the
 1826                          STK$ pointer in the TCB; i.e.
 1827
 1828                          }   G$TCB$ -> G$TCB.STK$ -> G$EXCFR
 1829
 1830                          G$EXCFR.ECC in the trap frame will be set to %G_TRAP#.
 1831
 1832                          G$EXCFR.TRLR.SUBC in the trap frame will contain the
 1833                          contents of the Indicator Register at the time
 1834                          of the trap.
 1835
 1836                          The form of the call for this service is:
 1837
 1838                          CALL M$TRAP (FPT_TRAP) [ALTRET (label)];
 1839
 1840                          Parameters for the M$TRAP service are as follows:
 1841                          */
 1842
 1843      %MACRO FPT_TRAP (FPTN=FPT_TRAP,
 1844        NTC=NIL,
 1845        PTC=NIL,
 1846        ALGN=WALIGNED,
 1847        STCLASS=STATIC);
 1848
 1849      %LSET LISTDIR='0'B;
 1850      %LSET LISTEXP='1'B;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          51   
 1851      %LSET LISTCOM='0'B;
 1852      %LSET LISTSUB='1'B;
 1853      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1854      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1855      %LSET INIT=CHARTEXT('INIT');
 1856      %LSET EINIT=CHARTEXT('');
 1857      %ELSE;
 1858      %LSET INIT=CHARTEXT('/*');
 1859      %LSET EINIT=CHARTEXT('*/');
 1860      %ENDIF;
 1861
 1862      DCL 1 FPTN STCLASS ALGN,
 1863            2 NTC_ VECTOR %INIT(VECTOR(NTC))%EINIT,
 1864                          /*K* NTC = VARIABLE   specifies the area that
 1865                          contains the settings for the desired trap
 1866                          condition settings.  This area should be generated
 1867                          using the VLP_TRAP_CONDITIONS macro.
 1868                          The default is NIL.
 1869                          */
 1870            2 PTC_ VECTOR %INIT(VECTOR(PTC))%EINIT;
 1871                          /*K* PTC = VARIABLE    specifies the area
 1872                          where the prior trap conditions are to be returned
 1873                          to the user.  This area should also be
 1874                          generated by the VLP_TRAP_CONDITIONS macro.
 1875                          The default is NIL.
 1876                          */
 1877      %MEND;
 1878
 1879
 1880
 1881
 1882
 1883                          /*F*   NAME: VLP_TRAP_CONDITIONS
 1884
 1885                          The VLP_TRAP_CONDITIONS macro generates a structure
 1886                          that contains the program trap condition settings.
 1887                          This includes the trap handler entry address,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          52   
 1888                          the contents of the Mode Control Registers,
 1889                          and, for each of the hardware traps, the action to be
 1890                          taken when the trap occurs.
 1891
 1892                          This structure is used with the M$TRAP monitor service.
 1893
 1894                          The TRAP$ parameter allows specification of the user
 1895                          trap handler address.
 1896
 1897                          The trap_name = {ABORT | ENT_TRAP} parameters allow
 1898                          specification of the trap state of each of the traps.
 1899                          If set to TRAP, the user
 1900                          trap handler, as specified by the TRAP$ parameter, will
 1901                          be entered.  If set to ABORT, the program will be aborted.
 1902                          The default in all cases is ABORT.
 1903
 1904                          The mask_name = {ENABLE | DISABLE} parameters
 1905                          allow specification of the trap mask for those
 1906                          traps that may be masked.
 1907                          The default in each case is DISABLE.
 1908
 1909                          The IGN_IO parameter allows specification of
 1910                          special processing of the Internal Unavailable
 1911                          Resource trap.
 1912
 1913                          Options available with the VLP_TRAP_CONDITIONS
 1914                          macro are:
 1915
 1916                          */
 1917
 1918      %MACRO VLP_TRAP_CONDITIONS (FPTN=VLP_TRAP_CONDITIONS,
 1919        TRAP$=NIL,
 1920
 1921        IGN_IO(G_YES#='1'B,G_NO#='0'B,YES='1'B,NO='0'B,ANY)='0'B,
 1922
 1923        MCL(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1924        TRACE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          53   
 1925        NO_SIP(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1926        UNIMPL(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1927        INT_REG_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1928        STK_UF(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1929        STK_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1930        REMOTE_DESC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1931        PRIV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1932        MEM_PROT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1933        INT_UR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1934        PROG_ERR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1935        INT_MBE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1936        EXT_UR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1937        EXT_MBE(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1938        C_DBZ(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1939        C_SPEC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1940        C_CHAR(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1941        C_TRUNC(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1942        C_OV(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1943        CIP_QLT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1944        SIP_QLT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1945        EXT_PROT(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1946        S_ARG(G_ENT_TRAP#='1'B,G_ABORT#='0'B,ENT_TRAP='1'B,ABORT='0'B)='0'B,
 1947
 1948        J(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1949        R1_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1950        R2_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1951        R3_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1952        R4_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1953        R5_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1954        R6_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1955        R7_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1956
 1957        CIP_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1958        CIP_TR(G_ENABLE#='1'B,G_DISABLE#='0'B,ENABLE='1'B,DISABLE='0'B)='0'B,
 1959
 1960        ALGN=WALIGNED,
 1961        STCLASS=STATIC);
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          54   
 1962
 1963      %LSET LISTDIR='0'B;
 1964      %LSET LISTEXP='1'B;
 1965      %LSET LISTCOM='0'B;
 1966      %LSET LISTSUB='1'B;
 1967      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1968      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1969      %LSET INIT=CHARTEXT('INIT');
 1970      %LSET EINIT=CHARTEXT('');
 1971      %ELSE;
 1972      %LSET INIT=CHARTEXT('/*');
 1973      %LSET EINIT=CHARTEXT('*/');
 1974      %ENDIF;
 1975
 1976      DCL 1 FPTN STCLASS ALGN,
 1977            2 %CHARTEXT('TRAP$ ') EPTR %INIT(ENTADDR(TRAP$))%EINIT,
 1978                          /*K* TRAP$ = {ENTRY|NIL}  specifies an entry address to
 1979                          which control is to be transferred
 1980                          if any of the traps that have been set to the TRAP
 1981                          state should occur.  This is also the entry address
 1982                          to which control is to be transferred at an error
 1983                          on a monitor service call without ALTRET if the MCL
 1984                          parameter has been specified as TRAP.
 1985                          Default = NIL.
 1986                          */
 1987            %G_TRAP_BLOCK (FPTN=FLTFLG,LVL=2,LAST=",",STCLASS=STCLASS,
 1988               IGN_IO=IGN_IO,MCL=MCL,TRACE=TRACE,NO_SIP=NO_SIP,UNIMPL=UNIMPL,
 1989               INT_REG_OV=INT_REG_OV,STK_UF=STK_UF,STK_OV=STK_OV,
 1990               REMOTE_DESC=REMOTE_DESC,PRIV=PRIV,MEM_PROT=MEM_PROT,
 1991               INT_UR=INT_UR,PROG_ERR=PROG_ERR,INT_MBE=INT_MBE,
 1992               EXT_UR=EXT_UR,EXT_MBE=EXT_MBE,C_DBZ=C_DBZ,C_SPEC=C_SPEC,
 1993               C_CHAR=C_CHAR,C_TRUNC=C_TRUNC,C_OV=C_OV,CIP_QLT=CIP_QLT,
 1994               SIP_QLT=SIP_QLT,EXT_PROT=EXT_PROT,S_ARG=S_ARG);
 1995
 1996                          /* 00 = No trap event set. This bit used for IGN_IO option.                   */
 1997                          /*K* IGN_IO = {YES|NO}  specifies that if
 1998                          an internal unavailable resource trap occurs on an
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          55   
 1999                          IO instruction, the trap is to be ignored and control
 2000                          returned to the user program.
 2001                          */
 2002
 2003                          /*K* MCL = {ABORT|ENT_TRAP}   specifies the action
 2004                          to take on a monitor service error when ALTRET
 2005                          was not specified on the request.
 2006                          */
 2007
 2008                          /*K* TRACE = {ABORT|ENT_TRAP}   specifies the action
 2009                          to take whenever trace trap control has been
 2010                          enabled and: (1) a BRK (Breakpoint) instruction
 2011                          is executed or (2) a branch or jump instruction
 2012                          is executed.
 2013
 2014                          This trap is enabled only when the J bit in the
 2015                          M1 Register is set.  The user may cause the trace
 2016                          trap to be enabled or disabled via the J option.
 2017                          */
 2018
 2019                          /*K* NO_SIP = {ABORT|ENT_TRAP}   specifies the action to
 2020                          take whenever a scientific instruction is encountered
 2021                          and the Scientific Instruction Processor option
 2022                          has not been installed.
 2023                          */
 2024
 2025                     /* 04 = Reserved for Software.  Use to turn watch dog timer interrupt into trap.   */
 2026                          /*N* TROT - watch-dog Timer RunOut Trap.
 2027                          The LCP-6 software user trap vector 4 to simulate
 2028                          a trap on the occurrence of the watch-dog timer
 2029                          runout interrupt.
 2030                          */
 2031
 2032                          /*K* UNIMPL = {ABORT|ENT_TRAP}   specifies the action
 2033                          to take whenever the central processor attempts to
 2034                          execute an instruction and the contents of the
 2035                          Instruction Register are not recognized as an
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          56   
 2036                          instruction.
 2037                          */
 2038
 2039                          /*K* INT_REG_OV = {ABORT|ENT_TRAP}   specifies the action
 2040                          to take on an Integer Register Overflow trap.  This
 2041                          trap will occur when the overflow bit in the Indicator
 2042                          Register is set to 1 as a result of an operation on
 2043                          an R-register while the overflow trap for that register
 2044                          is enabled.
 2045
 2046                          This trap is enabled or disabled for each
 2047                          R-register via bit settings in the M1 Register.
 2048                          The user may cause the Integer Register traps to
 2049                          be enabled or disabled via the Rn_OV option
 2050                          (where n= 0->7).
 2051                          */
 2052
 2053                          /* 07 = Scientific Divide by Zero                                             */
 2054
 2055                          /* 08 = Scientific Exponential Overflow                                       */
 2056
 2057                          /*K* STK_UF = {ABORT|ENT_TRAP}   specifies the action
 2058                          to take on a Stack Underflow Trap.  This trap is
 2059                          generated when a RLQ (Relinquish Stack Space) instruction
 2060                          would cause the CW (current word length) to be
 2061                          reduced to zero.
 2062                          */
 2063
 2064                          /*K* STK_OV = {ABORT|ENT_TRAP}   specifies the action
 2065                          to take on a Stack Overflow Trap.  This trap is
 2066                          generated when a ACQ (Acquire Stack Space) instruction
 2067                          would cause the MW (maximum word length) to be
 2068                          exceeded.
 2069                          */
 2070
 2071                          /* 11 = RFU                                                                   */
 2072
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          57   
 2073                          /*K* REMOTE_DESC = {ABORT|ENT_TRAP}   specifies the action
 2074                          to take on a trap caused by Recursive Remote Descriptor
 2075                          usage.
 2076                          */
 2077
 2078                          /*K* PRIV = {ABORT|ENT_TRAP}   specifies the action
 2079                          to take when the central processor attempts to
 2080                          execute a privileged instruction while running in
 2081                          the unprivileged mode (RNG value in the Status Register
 2082                          > Ring 1).  The following instructions are
 2083                          privileged:
 2084                             }
 2085                             } HLT       Halt
 2086                             } RTCN/F    Real-time Clock On/Off
 2087                             } WDTN/F    Watchdog Timer On/Off
 2088                             } IO(H)     Input/Output Word/Halfword
 2089                             } IOLD      Input/Output Load
 2090                             } LEV       Level Change
 2091                             } ASD       Activate Segment Descriptor
 2092                             }
 2093
 2094                          */
 2095
 2096                          /*K* MEM_PROT = {ABORT|ENT_TRAP}   specifies the action
 2097                          to take on a Memory Protection Trap.  This trap will
 2098                          occur whenever an attempt is made to perform a type
 2099                          of memory access not permitted by the appropriate
 2100                          permission field (read, write or execute) in the
 2101                          address space descriptor.
 2102                          */
 2103
 2104                          /*K* INT_UR = {ABORT|ENT_TRAP}   specifies the action
 2105                          to take on an internal Unavailable Resource trap.
 2106                          This trap is caused by any of the following:
 2107                           }
 2108                           } - a reference to non-existent memory.
 2109                           }
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          58   
 2110                           } - a reference to a segment whose validity bit in
 2111                           }   the address space descriptor is zero.
 2112                           }
 2113                           } - access out of bounds; a reference to an address
 2114                           }   beyond the size established by the address space
 2115                           }   descriptor.
 2116                           }
 2117                           } - improper channel number in an I/O instruction.
 2118                           }
 2119                           } - a Watchdog Timer On or Off instruction when the
 2120                           }   watchdog timer is not installed.
 2121                           }
 2122                          */
 2123
 2124                          /*K* PROG_ERR = {ABORT|ENT_TRAP}   specifies the action
 2125                          to take whenever:
 2126                           }
 2127                           } - the central processor attempts to execute an RTT
 2128                           }   instruction and a trap save area cannot be found.
 2129                           }
 2130                           } - the central processor attempts to execute an
 2131                           }   instruction that illegally contains a register
 2132                           }   address syllable.
 2133                           }
 2134                           } - the central processor attempts to execute an RLQ
 2135                           }   (Relinquish Stack Space) instruction and the
 2136                           }   CW (current word length) is already zero, of if
 2137                           }   the RLQ would cause the CW to go negative.
 2138                           }
 2139                          */
 2140
 2141                          /*K* INT_MBE = {ABORT|ENT_TRAP}   specifies the action
 2142                          to take when an internal Memory or Bus error
 2143                          (parity or noncorrectable EDAC) is detected.  Only
 2144                          users with Test and Diagnostic authorization may
 2145                          request control of this trap.
 2146                          */
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          59   
 2147
 2148                          /* 18 = RFU                                                                   */
 2149
 2150
 2151
 2152
 2153                          /* 19->22 = SIP errors                                                        */
 2154
 2155                          /*K* EXT_UR = {ABORT|ENT_TRAP}   specifies the action
 2156                          to take on an external (CIP) reference to an unavailable
 2157                          resource.
 2158                          */
 2159
 2160                          /*K* EXT_MBE = {ABORT|ENT_TRAP}   specifies the action
 2161                          to take when an external (CIP) Memory or Bus error
 2162                          (parity or noncorrectable EDAC) is detected.  Only
 2163                          users with Test and Diagnostic authorization may
 2164                          request control of this trap.
 2165                          */
 2166
 2167                          /*K* C_DBZ = {ABORT|ENT_TRAP}   specifies the action
 2168                          to take whenever the CIP attempts to
 2169                          execute a decimal divide instruction and the
 2170                          divisor is equal to zero.  Note that the OV
 2171                          bit in the CIP Indicator Register is set by
 2172                          this trap.
 2173                          */
 2174
 2175                          /*K* C_SPEC = {ABORT|ENT_TRAP}   specifies the action
 2176                          to take in the event of a CIP Illegal Specification
 2177                          trap.  This trap is generated by the CIP whenever any
 2178                          of the following conditions are detected:
 2179                            }
 2180                            } - undefined CIP op code is detected
 2181                            }
 2182                            } - a descriptor of an alphanumeric instruction is
 2183                            }   a packed decimal descriptor
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          60   
 2184                            }
 2185                            } - a decimal operand has a zero length
 2186                            }
 2187                            } - an operand in an EDIT, VRF or SHR instruction
 2188                            }   has a zero length
 2189                            }
 2190                            } - a separate signed decimal operand consists
 2191                            }   of only a sign ATOM
 2192                            }
 2193                            } - in a Move and Edit instruction, the receiving
 2194                            }   field length has been exhausted but either
 2195                            }   there are no more micro-ops or the sending
 2196                            }   field length is exhausted
 2197                            }
 2198                            } - a DD2 specifies an IOM except for DCM and
 2199                            }   ACM instructions
 2200                            }
 2201                            } - in a DSH, DD1 specifies an IMO
 2202                            }
 2203                            } - a DD3 specifies an IMO
 2204                            }
 2205                            } - in an SRH instruction SLL < SAL or OL < OEL
 2206                            }
 2207                            } - in an VRF instruction VLL < VAL or OL < OEL
 2208                            }
 2209
 2210                          */
 2211
 2212                          /*K* C_CHAR = {ABORT|ENT_TRAP}   specifies the action
 2213                          to take in the event of a CIP Illegal Character
 2214                          trap.  This trap is generated by the CIP under any
 2215                          of the following conditions:
 2216                            }
 2217                            } - illegal decimal digit is detected
 2218                            }
 2219                            } - illegal sign digit is detected
 2220                            }
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          61   
 2221                            } - illegal overpunch digit is detected
 2222                            }
 2223                          */
 2224
 2225                          /*K* C_TRUNC = {ABORT|ENT_TRAP}   specifies the action to
 2226                          take in the event of a CIP Truncation Trap.  This trap
 2227                          is generated by the CIP whenever the receiving field
 2228                          of an alphanumeric instruction cannot contain all
 2229                          characters of the result.  Note that the TR bit in the
 2230                          CIP Indicator register will be set as a result of
 2231                          this trap.
 2232
 2233                          This trap is enabled only when
 2234                          the CIP_TR bit in the M3 Register is set.
 2235                          The user may cause the CIP Truncation trap to
 2236                          be enabled or disabled via the CIP_TR option.
 2237                          */
 2238
 2239                          /*K* C_OV = {ABORT|ENT_TRAP}   specifies the action to
 2240                          be taken in the event of a CIP Overflow Trap.  This trap
 2241                          is generated by the CIP whenever:
 2242                            }
 2243                            } - the receiving field of a decimal instruction
 2244                            }   cannot contain all significant digits of the
 2245                            }   result
 2246                            }
 2247                            } - a nonzero digit is shifted out during a shift
 2248                            }   left instruction
 2249                            }
 2250                          This trap is enabled only when
 2251                          the OV bit in the M3 Register is set.
 2252                          The user may cause the CIP Overflow trap to be
 2253                          enabled or disabled via the CIP_OV option.
 2254
 2255                          If the trap occurs (M3.OV='1'B) then the instruction is
 2256                          aborted and the original operands will remain unmodified.
 2257                          Note that the OV bit in
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          62   
 2258                          the CIP Indicator Register will be set as a result of
 2259                          this trap.
 2260
 2261                          If no trap occurs (M3.OV='0'B), the receiving field
 2262                          will be altered (it will contain the least significant
 2263                          part of the result).
 2264                          */
 2265
 2266                          /*K* CIP_QLT = {ABORT|ENT_TRAP}   specifies the action to
 2267                          be taken in the event on a CIP QLT Error Trap.  This
 2268                          trap is signaled by the CIP whenever it detects a
 2269                          malfunction while executing the QLT.  Only users
 2270                          with Test and Diagnostic authorization may
 2271                          request control of this trap.
 2272                          */
 2273
 2274                          /* 31 = SIP_QLT                                                               */
 2275
 2276                          /*K* EXT_PROT = {ABORT|ENT_TRAP}  specifies the
 2277                          action to be taken in the event of an External
 2278                          Memory Protection Trap.
 2279                          */
 2280                          /* 33 = S_ARG                                                                 */
 2281
 2282                          /* 34->46 = RFU                                                               */
 2283
 2284                          /* 47->63 are used by the LCP-6 debugger                                      */
 2285            %G$M1_REG (FPTN=M1,LVL=2,LAST=",",STCLASS=STCLASS,
 2286               J=J,R1_OV=R1_OV,R2_OV=R2_OV,R3_OV=R3_OV,R4_OV=R4_OV,
 2287               R5_OV=R5_OV,R6_OV=R6_OV,R7_OV=R7_OV);
 2288
 2289                          /*K* J = {ENABLE | DISABLE}   specifies the
 2290                          setting for the Trace Trap control bit in the
 2291                          M1 Register.  Default = DISABLE.
 2292
 2293                          This option is ignored when executing under
 2294                          control of a debugger.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          63   
 2295                          */
 2296
 2297                          /*K* Rn_OV = {ENABLE | DISABLE}   specifies the
 2298                          setting for the Overflow Trap control bits in the
 2299                          M1 Register, where n = 1 -> 7.  Default = DISABLE.
 2300                          */
 2301
 2302              2 M2 BIT(16) UNAL %INIT('0'B)%EINIT,
 2303                          /* RFU                                                                        */
 2304                %G$M3_REG (FPTN=M3,LVL=2,LAST=",",STCLASS=STCLASS,
 2305                CIP_OV=CIP_OV,CIP_TR=CIP_TR);
 2306
 2307                          /*K* CIP_OV = {ENABLE | DISABLE}   specifies the
 2308                          setting for the CIP Overflow Trap mask in the
 2309                          M3 Register. Default = DISABLE.
 2310                          */
 2311
 2312                          /*K* CIP_TR = {ENABLE | DISABLE}   specifies the
 2313                          setting for the CIP Truncation Trap mask in the
 2314                          M3 Register. Default = DISABLE.
 2315                          */
 2316
 2317              %G$M4_REG (FPTN=M4,LVL=2,LAST=",",STCLASS=STCLASS);
 2318                          /* SIP Mode Control Register                                                  */
 2319              %G$M5_REG (FPTN=M5,LVL=2,LAST=",",STCLASS=STCLASS);
 2320                          /* SIP Trap Mask Register                                                     */
 2321            2 M6 BIT(16) UNAL %INIT('0'B)%EINIT,
 2322                          /* RFU                                                                        */
 2323            2 M7 BIT(16) UNAL %INIT('0'B)%EINIT;
 2324                          /* RFU                                                                        */
 2325      %MEND;
 2326
 2327
 2328
 2329
 2330                          /*F* NAME: Exiting Exceptional Condition Procedures
 2331
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          64   
 2332                          The user's exceptional condition procedure or ALTRET
 2333                          code sequence determines whether to exit, to abort, to pass
 2334                          control to the monitor for error processing, or to
 2335                          resume normal program execution.  The services
 2336                          described here allow the user to transfer control,
 2337                          to manipulate the TCB Exception Condition Stack,
 2338                          and to restore a prior environment to the
 2339                          Trap Save Area.  These services are categorized
 2340                          below by the type of procedure in which they may
 2341                          appear.
 2342
 2343                          }  Routine Type    Monitor Services to Exit the Routine
 2344                          }
 2345                          }  ALTRET          M$MERC
 2346                          }  code sequence   M$MERCS  (a)
 2347                          }                  M$RETRY
 2348                          }                  M$RETRYS (a)
 2349                          }
 2350                          }  Exceptional     M$TRTN
 2351                          }  Condition       M$CLRSTK
 2352                          }  Procedures      M$MERCS
 2353                          }                  M$RETRYS (b)
 2354                          }
 2355                            a  This service is appropriate if the original monitor service
 2356                               environment is in the top frame of the Exceptional Condition
 2357                               Stack.
 2358
 2359                            b  This service may be used to exit the PMME procedure
 2360                               specified on the M$TRAP service.
 2361                          ..::L1 "PL-6 Considerations\\X"
 2362                          In a PL-6 program, the M$TRAP, M$EVENT,
 2363                          M$INT, and M$XCON services establish the entry
 2364                          (ENTADDR) to procedures to be entered asynchronously
 2365                          when exceptional conditions occur.  These procedures
 2366                          should be coded as external ASYNC procedures.
 2367
 2368                          Exit from these procedures can take advantage of the
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          65   
 2369                          PL-6 RETURN and ALTRETURN statements.  In
 2370                          particular, exit from a PL-6 ASYNC procedure can
 2371                          occur as follows:
 2372                          }
 2373                          o  RETURN - Generates an M$TRTN monitor service request (with no
 2374                                        FPT) which returns to the point of interruption
 2375                                        with the original environment restored to the
 2376                                        Trap Save Area.
 2377                          }
 2378                          o  ALTRETURN - Generates an M$MERCS monitor service request
 2379                                        which gives control to the monitor for error
 2380                                        processing.
 2381                          }
 2382                          o  UNWIND - Restores the AUTO pointer to the REMEMBERed value
 2383                                        and transfers control to the REMEMBERed
 2384                                        label.  UNWIND should normally be preceded by
 2385                                        M$CLRSTK to release the top frame on the
 2386                                        Exceptional Condition Stack.
 2387
 2388                          If it is necessary to execute an M$TRTN or M$MERCS
 2389                          procedure specifying an FPT, this must be done by
 2390                          calling X6A_TRTN or X6A_MERCS respectively, passing
 2391                          the FPT to be used.  Automatic storage will be
 2392                          properly maintained followed by the execution of the
 2393                          desired monitor service request.  In no case should
 2394                          M$TRTN or M$MERCS monitor service, with or without an
 2395                          FPT, be requested directly from an PL6 procedure.
 2396                          */
 2397
 2398
 2399
 2400
 2401
 2402                          /*F* NAME: M$TRTN - TCB Return
 2403
 2404                          The M$TRTN service returns control to the program
 2405                          from an exceptional condition  procedure.  The
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          66   
 2406                          service removes the top frame of the Exceptional
 2407                          Condition Stack and restores that environment to
 2408                          the Trap Save Area.  The user may specify
 2409                          changes to be made to the environment, including
 2410                          the registers and the Program Counter.  The M$TRTN service
 2411                          transfers control to the user program at the
 2412                          statement following the point of interruption or
 2413                          to the location specified by the P$$ option.
 2414
 2415                          Note that if the M$TRTN service request is issued
 2416                          when the top frame on the Exceptional Condition
 2417                          Stack is an exit control frame, and that frame does
 2418                          not indicate a nested exit control entry, the program
 2419                          is removed from the "exit" status.
 2420
 2421                          The M$TRTN service takes the alternate return if
 2422                          there is no environment in the Exceptional
 2423                          Condition Stack.
 2424
 2425                          If there are no changes to the environment, the
 2426                          form of the call for the M$TRTN service is as
 2427                          follows:
 2428
 2429                          CALL M$TRTN [ALTRET (label)];
 2430
 2431                          If there are changes to be made to the
 2432                          environment, the form of the call for this service
 2433                          is as follows:
 2434
 2435                          CALL M$TRTN (FPT_TRTN) [ALTRET (label)];
 2436
 2437                          In this case, the parameters for the M$TRTN
 2438                          service are as follows:
 2439                          */
 2440
 2441
 2442
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          67   
 2443
 2444      %MACRO FPT_TRTN(FPTN=FPT_TRTN,
 2445        REGS=NIL,
 2446        P$$=NIL,
 2447        ALGN=WALIGNED,
 2448        STCLASS=STATIC);
 2449
 2450      %LSET LISTDIR='0'B;
 2451      %LSET LISTEXP='1'B;
 2452      %LSET LISTCOM='0'B;
 2453      %LSET LISTSUB='1'B;
 2454      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2455      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2456      %LSET INIT=CHARTEXT(' INIT');
 2457      %LSET EINIT=CHARTEXT('');
 2458      %ELSE;
 2459      %LSET INIT=CHARTEXT('/*');
 2460      %LSET EINIT=CHARTEXT('*/');
 2461      %ENDIF;
 2462
 2463      DCL 1 FPTN STCLASS ALGN,
 2464            2 REGS_ VECTOR %INIT(VECTOR(REGS))%EINIT,
 2465                          /*K* REGS = VARIABLE    locates a 34-word area
 2466                          that contains the values to be used to replace the
 2467                          base registers, the general registers, the mode
 2468                          control registers, etc.
 2469                          The structure of this area should be
 2470                          generated using the VLP_REGISTERS macro.
 2471                          Default = NIL.
 2472                          */
 2473            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 2474            2 V,
 2475              3 %CHARTEXT('P$$ EPTR') %INIT(ENTADDR(P$$))%EINIT,
 2476              3 %CHARTEXT('P$ ') REDEF %CHARTEXT('P$$ ') PTR;
 2477                          /*K* P$$ = EPTR   specifies the
 2478                          procedure to be entered following the call to
 2479                          M$TRTN.  A value of NIL indicates that the Program
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          68   
 2480                          Counter is not to be changed.  Default = NIL.
 2481                          */
 2482      %MEND;
 2483
 2484
 2485
 2486
 2487
 2488                          /*F* NAME: M$RETRY - Retry Monitor Service
 2489
 2490                          The M$RETRY service returns control from the user
 2491                          ALTRET code sequence to the original monitor service
 2492                          call and retries the service call.  The
 2493                          environment for the original monitor service
 2494                          request is assumed to be in the ALTRET frame of
 2495                          the TCB.  The M$RETRY service takes the alternate
 2496                          return if there is no environment in the ALTRET
 2497                          frame.
 2498
 2499                          The contents of registers R3 and B3 may be altered
 2500                          via options on the FPT.  If no changes
 2501                          are to be made to the environment, the form of the
 2502                          call for this service is as follows:
 2503
 2504                          CALL M$RETRY [ALTRET (label)];
 2505
 2506                          If changes are to be made to the environment, the
 2507                          form of the call is as follows:
 2508
 2509                          CALL M$RETRY (FPT_RETRY) [ALTRET (label)];
 2510
 2511                          The M$RETRYS service retries a monitor service
 2512                          call.  Its function is the same as the M$RETRY
 2513                          service except that the environment of the
 2514                          original monitor service call is assumed to be in
 2515                          the top frame of the Exceptional Condition Stack.
 2516                          The M$RETRYS service removes this frame from the
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          69   
 2517                          stack and restores it to the Trap Save Area.
 2518                          The M$RETRYS service takes the alternate return if
 2519                          the Exceptional Condition Stack is empty or if the
 2520                          top frame does not contain the environment of
 2521                          a monitor service request.
 2522
 2523                          If no changes are to be made to the environment
 2524                          prior to retrying the original monitor service
 2525                          call, the form of the call for this service is as
 2526                          follows:
 2527
 2528                          CALL M$RETRYS [ALTRET (label)];
 2529
 2530                          If changes are to be made to the environment, the
 2531                          form of the call is as follows:
 2532
 2533                          CALL M$RETRYS (FPT_RETRY) [ALTRET (label)];
 2534
 2535                          Note that FPT_RETRY is used for both the
 2536                          M$RETRY and M$RETRYS services.  The parameters are
 2537                          as follows:
 2538                          */
 2539
 2540      %MACRO FPT_RETRY (FPTN=FPT_RETRY,
 2541         R3=0,
 2542         B3$=NIL,
 2543         ALGN=WALIGNED,
 2544         VECTORS=YES,
 2545         STCLASS=STATIC);
 2546
 2547      %LSET LISTDIR='0'B;
 2548      %LSET LISTEXP='1'B;
 2549      %LSET LISTCOM='0'B;
 2550      %LSET LISTSUB='1'B;
 2551      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2552      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2553      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          70   
 2554      %LSET INIT=CHARTEXT(' INIT');
 2555      %LSET EINIT=CHARTEXT('');
 2556      %ELSE;
 2557      %LSET INIT=CHARTEXT('/*');
 2558      %LSET EINIT=CHARTEXT('*/');
 2559      %ENDIF;
 2560
 2561      DCL 1 FPTN STCLASS ALGN,
 2562      %IF TEXTCHAR(VECTORS)='YES';
 2563            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 2564            2 V,
 2565      %LSET LVL=3;
 2566      %ELSE;
 2567      %LSET LVL=2;
 2568      %ENDIF;
 2569            %(LVL) %CHARTEXT('R3 ') UBIN %INIT(R3)%EINIT,
 2570                          /*K* R3 = VALUE(0-65535)  specifies the value
 2571                          for general register R3.  This is the value that
 2572                          will be used for the monitor service request code.
 2573                          The default is 0.
 2574                          */
 2575            %(LVL) %CHARTEXT('B3$ ') PTR %INIT(ADDR(B3$))%EINIT;
 2576                          /*K* B3$ = PTR  specifies the value for
 2577                          base register B3.  This is the value that
 2578                          will be used as the address of the FPT.
 2579                          The default is NIL.
 2580                          */
 2581      %MEND;
 2582
 2583
 2584
 2585
 2586
 2587                          /*F* NAME: M$MERC - Monitor Error Control
 2588
 2589
 2590                          The M$MERC service returns control from the user
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          71   
 2591                          ALTRET code sequence to the monitor.  This service is
 2592                          provided in case the ALTRET procedure cannot process
 2593                          all possible error codes.  The original
 2594                          environment from the error on a monitor service
 2595                          call is assumed to be in the ALTRET frame of the
 2596                          TCB at the call to the M$MERC service.
 2597
 2598                          The monitor responds by taking appropriate action
 2599                          based on the severity of the error:
 2600
 2601                          .BRN 11
 2602                          .FIF
 2603                            Severity Level   Monitor Action
 2604
 2605                             0               Ignore the error.  Return to the statement
 2606                                             following the monitor service call, with the
 2607                                             Trap Save Area reflecting the original
 2608                                             environment.  If the MERC is from exit control
 2609                                             the monitor performs M$EXIT.
 2610
 2611                            1-4              Abort the program. (The monitor performs M$ERR.)
 2612
 2613                            > 4              Abort the program.  (The monitor performs M$XXX.)
 2614
 2615                          .FIN
 2616                          The STEPCC will be set to the value of the
 2617                          severity of the error code.
 2618                          The M$MERC service takes the alternate return if
 2619                          there is no environment in the ALTRET frame of the
 2620                          TCB.  No FPT is required by M$MERC but one may
 2621                          be specified to provide for explicit
 2622                          setting of the severity of the error.
 2623
 2624                          The form of the call for this service is:
 2625
 2626                          CALL M$MERC [ALTRET(label)];
 2627
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          72   
 2628                          or
 2629
 2630                          CALL M$MERC(FPT_MERC) [ALTRET(label)];
 2631
 2632
 2633                          The M$MERCS service performs the same function as
 2634                          the M$MERC service, except that the
 2635                          environment is assumed to be in the top frame of
 2636                          the Exceptional Condition Stack.  (The M$MERCS
 2637                          service releases this top frame.)  Thus this
 2638                          service is appropriate for use in an ALTRET
 2639                          code sequence that previously executed M$SENV, in the
 2640                          M$TRAP procedure when G$EXCFR.TRLR.TRAP.TRAP# contains %G_MCL#, and
 2641                          in an exit control procedure that receives control
 2642                          because the program provides no ALTRET procedure or
 2643                          M$TRAP procedure.
 2644
 2645                          The M$MERCS service takes the alternate return if
 2646                          the Exceptional Condition Stack frame is empty.
 2647                          No FPT is required by M$MERCS but one may
 2648                          be specified to provide for explicit
 2649                          setting of the severity of the error.
 2650
 2651                          The form of the call for this service is:
 2652
 2653                          CALL M$MERCS [ALTRET(label)];
 2654
 2655                          or
 2656
 2657                          CALL M$MERCS(FPT_MERC) [ALTRET(label)];
 2658
 2659
 2660                          Note that FPT_MERC is used for both the
 2661                          M$MERC and M$MERCS services. The
 2662                          parameter is:
 2663                          */
 2664
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          73   
 2665      %MACRO FPT_MERC (FPTN=FPT_MERC,
 2666         ERRCODE=NIL,
 2667         ALGN=WALIGNED,
 2668         STCLASS=STATIC);
 2669
 2670      %LSET LISTDIR='0'B;
 2671      %LSET LISTEXP='1'B;
 2672      %LSET LISTCOM='0'B;
 2673      %LSET LISTSUB='1'B;
 2674      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2675      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2676      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2677      %LSET INIT=CHARTEXT(' INIT');
 2678      %LSET EINIT=CHARTEXT('');
 2679      %ELSE;
 2680      %LSET INIT=CHARTEXT('/*');
 2681      %LSET EINIT=CHARTEXT('*/');
 2682      %ENDIF;
 2683
 2684      DCL 1 FPTN STCLASS ALGN,
 2685            2 ERRCODE_ VECTOR %INIT(VECTOR(ERRCODE))%EINIT;
 2686                          /*K* ERRCODE = VARIABLE  locates
 2687                          the double word that is to be used
 2688                          to replace the error code.  The VLP_ERRCODE macro
 2689                          should be used to generate the error code.  When
 2690                          specified the value of the Severity will be
 2691                          used by the monitor to determine
 2692                          how to proceed.
 2693                          The default is NIL.
 2694                          */
 2695
 2696      %MEND;
 2697
 2698                          /*F* NAME: M$CLRSTK - Clear the TCB Stack Frame
 2699
 2700                          The M$CLRSTK service deletes one or more frames
 2701                          from the Exceptional Condition Stack.  Following
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          74   
 2702                          this call, execution continues in-line.  If there
 2703                          is no environment in the Exceptional Condition
 2704                          Stack, the alternate return is taken.
 2705
 2706                          Note that on removing an exit control frame from
 2707                          the Exceptional Condition Stack, if that frame does
 2708                          not indicate a nested exit control entry, the program
 2709                          is removed from the "exit" status.
 2710
 2711                          To clear the top frame in the stack, the form of
 2712                          the call to this service is as follows:
 2713
 2714                          CALL M$CLRSTK [ALTRET (label)];
 2715
 2716                          To clear more that one frame, the form of the call
 2717                          for this service is as follows:
 2718
 2719                          CALL M$CLRSTK (FPT_CLRSTK) [ALTRET (label)];
 2720
 2721                          In this case, the parameter for the service is as
 2722                          follows:
 2723                          */
 2724
 2725
 2726      %MACRO FPT_CLRSTK(FPTN=FPT_CLRSTK,
 2727          VECTORS=YES,
 2728          FRAMES=1,
 2729          ALGN=WALIGNED,
 2730          STCLASS=STATIC);
 2731
 2732      %LSET LISTDIR='0'B;
 2733      %LSET LISTEXP='1'B;
 2734      %LSET LISTCOM='0'B;
 2735      %LSET LISTSUB='1'B;
 2736      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2737      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2738      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          75   
 2739      %LSET INIT=CHARTEXT(' INIT');
 2740      %LSET EINIT=CHARTEXT('');
 2741      %ELSE;
 2742      %LSET INIT=CHARTEXT('/*');
 2743      %LSET EINIT=CHARTEXT('*/');
 2744      %ENDIF;
 2745
 2746      DCL 1 FPTN STCLASS ALGN,
 2747
 2748      %IF TEXTCHAR(VECTORS)='YES';
 2749      %LSET LVL=3;
 2750            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 2751            2 V,
 2752      %ELSE;
 2753      %LSET LVL=2;
 2754      %ENDIF;
 2755
 2756              %LVL %CHARTEXT('FRAMES') UBIN %INIT(FRAMES)%EINIT;
 2757                          /*K* FRAMES = VALUE-DEC(1-n)    specifies the
 2758                          number of frames to remove from the Exceptional
 2759                          Condition Stack.  If the value specified is equal
 2760                          to or greater than the number of frames currently
 2761                          on the stack, all frames are removed and the stack
 2762                          is marked empty.  Default = 1.
 2763                          */
 2764      %MEND;
 2765
 2766
 2767                          /*F* NAME: M$ERRMSG - Return Text for Error Code
 2768
 2769                          The M$ERRMSG service obtains an error message
 2770                          based on the error code supplied as a parameter,
 2771                          and stores the message in the user buffer.
 2772                          M$ERRMSG allows phrase and message substitution.
 2773                          The output of the M$ERRMSG service is a TEXT string
 2774                          placed in a user-passed area.  Status about the
 2775                          call is returned in a RESULTS area.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          76   
 2776
 2777                          The form of the call for this service is as follows:
 2778
 2779                          CALL M$ERRMSG (FPT_ERRMSG) [ALTRET(label)];
 2780
 2781                          The required parameters for the service are CODE
 2782                          and BUF.
 2783                          */
 2784      %MACRO FPT_ERRMSG (FPTN = FPT_ERRMSG,
 2785               CODE = NIL,
 2786               ALTCODE = NIL,
 2787               BUF = NIL,
 2788               FILENAME = NIL,
 2789               FILEACCT = NIL,
 2790               FILEPASS = NIL,
 2791               FIELD1 = NIL,
 2792               FIELD2 = NIL,
 2793               FIELD3 = NIL,
 2794               RESULTS = NIL,
 2795               DCB = NIL,
 2796               INCLCODE (YES='1'B,NO='0'B)= '1'B,
 2797               SUBFILE (YES='1'B,NO='0'B)= '1'B,
 2798               SUBMESS (YES='1'B,NO='0'B)= '1'B,
 2799               SUBLANG (YES='1'B,NO='0'B)= '1'B,
 2800               MY_LANG (YES='1'B,NO='0'B)= '1'B,
 2801               LANG = ' ',
 2802               SOURCE (PASS=0,TRAP=1,ALTRET=2)= 0,
 2803               FLAGLEV = 0,
 2804               ALGN=WALIGNED,
 2805               VECTORS=YES,
 2806               STCLASS = STATIC);
 2807
 2808      %LSET LISTDIR='0'B;
 2809      %LSET LISTEXP='1'B;
 2810      %LSET LISTCOM='0'B;
 2811      %LSET LISTSUB='1'B;
 2812      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          77   
 2813      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
 2814      %LSET INIT=CHARTEXT('INIT');
 2815      %LSET EINIT=CHARTEXT('');
 2816      %ELSE;
 2817      %LSET INIT=CHARTEXT('/*');
 2818      %LSET EINIT=CHARTEXT('*/');
 2819      %ENDIF;
 2820
 2821      DCL 1 FPTN STCLASS ALGN,
 2822
 2823      %IF TEXTCHAR(VECTORS)='YES';
 2824      %LSET LVL=3;
 2825
 2826            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 2827            2 CODE_ VECTOR %INIT(VECTOR(CODE))%EINIT,
 2828                          /*K* CODE = VARIABLE specifies the area in
 2829                          memory containing the error code identifying the
 2830                          message to be read from the file.
 2831                          This area is to be in standard VLP_ERRCODE format.
 2832                          The default is NIL.
 2833                          */
 2834            2 BUF_ VECTOR %INIT(VECTOR(BUF))%EINIT,
 2835                          /*K* BUF = VARIABLE specifies the buffer where the
 2836                          TEXT form of the error message is to be placed.
 2837                          The default is NIL.
 2838                          */
 2839            2 FILENAME_ VECTOR %INIT(VECTOR(FILENAME))%EINIT,
 2840                          /*K* FILENAME = VARIABLE specifies the area containing
 2841                          the TEXTC name of a file to be read for the error
 2842                          message.  The VLP_TEXTC macro may be invoked to
 2843                          generate this area. If the named file cannot be
 2844                          opened or if no error message or default message
 2845                          can be found in the file, this condition is
 2846                          treated as if no FILENAME were specified.
 2847                          The default is NIL.
 2848                          */
 2849            2 FILEACCT_ VECTOR %INIT(VECTOR(FILEACCT))%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          78   
 2850                          /*K* FILEACCT = VARIABLE specifies the area containing
 2851                          a TEXT string consisting of eight characters, word aligned,
 2852                          designating the account of the error message file.
 2853                          The default is NIL.
 2854                          */
 2855            2 FILEPASS_ VECTOR %INIT(VECTOR(FILEPASS))%EINIT,
 2856                          /*K* FILEPASS = VARIABLE specifies the area containing
 2857                          a TEXT string consisting of eight characters, word aligned,
 2858                          designating the password of the error message file.
 2859                          The default is NIL.
 2860                          */
 2861            2 FIELD1_ VECTOR %INIT(VECTOR(FIELD1))%EINIT,
 2862                          /*N* FIELD1 = VARIABLE  specifies the location of the
 2863                          TEXTC field to be substituted into the error
 2864                          message for the special string %U1. If an error
 2865                          message contains any special string %Ux and the
 2866                          corresponding FIELDx is not supplied, then blanks
 2867                          are substituted, or the conditional phrase is not
 2868                          printed.  The default is NIL.
 2869                          */
 2870            2 FIELD2_ VECTOR %INIT(VECTOR(FIELD2))%EINIT,
 2871                          /*N* FIELD2 = VARIABLE  specifies the location of the
 2872                          TEXTC field to be substituted for %U2.
 2873                          The default is NIL.
 2874                          */
 2875            2 FIELD3_ VECTOR %INIT(VECTOR(FIELD3))%EINIT,
 2876                          /*N* FIELD3 = VARIABLE specifies the location of the
 2877                          TEXTC field to be substituted for %U3.
 2878                          The default is NIL.                                                           */
 2879            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT,
 2880                          /*K* RESULTS = VARIABLE specifies an area in the
 2881                          user's data where any status information about a
 2882                          call to M$ERRMSG is returned to the caller.  The
 2883                          information returned consists of bits indicating
 2884                          unusual conditions encountered in the processing
 2885                          of the CALL.  The VLR_ERRMSG macro described
 2886                          later in this section can be invoked to generate
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          79   
 2887                          this area.  The default is NIL.
 2888                          */
 2889            2 ALTCODE_ VECTOR %INIT(VECTOR(ALTCODE))%EINIT,
 2890                          /*K* ALTCODE = VARIABLE specifies the area in
 2891                          memory containing the error code identifying the
 2892                          alternate message to be read from the file. It is used
 2893                          to form the key to read the file if no message can
 2894                          be found for CODE.  This area is to be in standard
 2895                          VLP_ERRCODE format.
 2896                          The default is NIL.
 2897                          */
 2898            2 V,
 2899      %ELSE;
 2900      %LSET LVL=2;
 2901      %ENDIF;
 2902              %LVL %CHARTEXT('DCB#') UBIN(8) UNAL %INIT(DCBNUM(DCB))%EINIT,
 2903                          /*N* DCB = DCBNAME specifies the DCB on which the
 2904                          error condition occurred. DCB is used to obtain
 2905                          variable information which is substituted into
 2906                          the error message for special strings %UF and %DC.
 2907                          If an error message contains these
 2908                          special strings and DCB is not specified, then
 2909                          blanks are substituted, or the conditional phrase
 2910                          is not printed.  The default is NIL.
 2911                          */
 2912                %LVL %CHARTEXT('SUBFILE') BIT(1) UNAL %INIT(SUBFILE)%EINIT,
 2913                          /*K* SUBFILE = {YES|NO} specifies, if YES, to use
 2914                          the default system error message file if the file
 2915                          passed by the user does not contain a message for
 2916                          the code passed in this call.  The default is YES.
 2917                          */
 2918                %LVL %CHARTEXT('SUBMESS') BIT(1) UNAL %INIT(SUBMESS)%EINIT,
 2919                          /*K* SUBMESS = {YES|NO} specifies, if YES, to use a
 2920                          substitute message, (i.e., one with less severity)
 2921                          or the default message, if the error message file
 2922                          contains no message corresponding to the error code
 2923                          specified.  The default is YES.  If no substitute
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          80   
 2924                          message is available, the text of the error code
 2925                          is used.
 2926                          */
 2927                %LVL %CHARTEXT('SUBLANG') BIT(1) UNAL %INIT(SUBLANG)%EINIT,
 2928                          /*K* SUBLANG = {YES|NO}   specifies, if YES, that a
 2929                          message will be in the default language if the user's
 2930                          native language is not available.  The default
 2931                          is YES.
 2932                          */
 2933                %LVL %CHARTEXT('INCLCODE') BIT(1) UNAL %INIT(INCLCODE)%EINIT,
 2934                          /*K* INCLCODE = {YES|NO} indicates whether or not the
 2935                          error code should be output before the error
 2936                          message.  The default is YES.
 2937                          */
 2938                %LVL %CHARTEXT('MY_LANG ') BIT(1) UNAL %INIT(MY_LANG)%EINIT,
 2939                          /*K* MY_LANG = {YES|NO}   specifies, if YES, that the
 2940                          default native language key is that of the user making
 2941                          the M$ERRMSG request.  NO specifies that the character
 2942                          specified via the LANG option is to be used in selecting
 2943                          the error message file.  The default is YES.
 2944                          */
 2945                %LVL %CHARTEXT('SOURCE ') UBIN(3) UNAL %INIT(SOURCE)%EINIT,
 2946                          /*K* SOURCE = {PASS|TRAP|ALTRET} specifies where
 2947                          M$ERRMSG should look for the error code
 2948                          to report on.  PASS, the default, indicates that the
 2949                          error code will be passed in CODE.  TRAP indicates
 2950                          that M$ERRMSG should look in the top frame of the
 2951                          exceptional condition stack for the error code
 2952                          (G$TCB$ -> G$TCB.STK$ -> G$EXCFR.TRLR.ERR).
 2953                          ALTRET indicates that M$ERRMSG should look in the
 2954                          monitor services ALTRET frame for the error code
 2955                          (G$TCB$ -> G$TCB.ALT$ -> G$EXCFR.TRLR.ERR).
 2956                          */
 2957                %LVL %CHARTEXT('LANG') CHAR(1) UNAL %INIT(LANG)%EINIT ,
 2958                          /*K* LANG = VALUE-CHAR(1) is an encoded character that
 2959                          determines the native language to be used for the
 2960                          message.  The default is a blank (for English).
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          81   
 2961                          */
 2962                %LVL %CHARTEXT('FLAGLEV ') UBIN BYTE UNAL %INIT(FLAGLEV)%EINIT;
 2963                          /*K* FLAGLEV = VALUE-DEC(0-4) specifies the number
 2964                          asterisks (*), from 0-4, that precede the error
 2965                          message.  The number is an indication of the
 2966                          seriousness of the error message.  The default is 0.
 2967                          */
 2968       %MEND;
 2969
 2970
 2971
 2972                          /*F* NAME: VLR_ERRMSG
 2973
 2974                          The VLR_ERRMSG macro generates an area which
 2975                          receives the results of the M$ERRMSG service. The
 2976                          area contains these fields:
 2977                          */
 2978
 2979      %MACRO VLR_ERRMSG (FPTN = VLR_ERRMSG,
 2980                         STCLASS = STATIC);
 2981
 2982       %LSET LISTDIR='0'B;
 2983       %LSET LISTEXP='1'B;
 2984       %LSET LISTCOM='0'B;
 2985       %LSET LISTSUB='1'B;
 2986      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2987      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
 2988      %LSET INIT=CHARTEXT('INIT');
 2989      %LSET EINIT=CHARTEXT('');
 2990      %ELSE;
 2991      %LSET INIT=CHARTEXT('/*');
 2992      %LSET EINIT=CHARTEXT('*/');
 2993      %ENDIF;
 2994
 2995      DCL 1 FPTN STCLASS ALIGNED,
 2996            2 * BIT(1) UNAL %INIT('0'B)%EINIT,
 2997            2 NOFILE BIT(1) UNAL %INIT('0'B)%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          82   
 2998                          /*K* NOFILE - BIT(1)   if set specifies that
 2999                          M$ERRMSG  was unable to open the message file.
 3000                          */
 3001            2 NOMSG BIT(1) UNAL %INIT('0'B)%EINIT,
 3002                          /*K* NOMSG - BIT(1)   if set specifies that
 3003                          M$ERRMSG  was unable to find any message for the
 3004                          error code.
 3005                          */
 3006            2 ALTMSG BIT(1) UNAL %INIT('0'B)%EINIT,
 3007                          /*K* ALTMSG - BIT(1)   if set specifies that
 3008                          M$ERRMSG  stored a substitute message in the user
 3009                          buffer.
 3010                          */
 3011            2 MSGCOMP BIT(1) UNAL %INIT('0'B)%EINIT,
 3012                          /*K* MSGCOMP - BIT(1)   if set specifies that the
 3013                          entire message is stored in the user buffer.
 3014                          */
 3015            2 NNATIVE BIT(1) UNAL %INIT('0'B)%EINIT,
 3016                          /*K* NNATIVE - BIT(1)   if set specifies that the
 3017                          returned message is not in the user's native language.
 3018                          */
 3019            2 * BIT(1) UNAL %INIT('0'B)%EINIT,
 3020            2 INERR BIT(1) UNAL %INIT('0'B)%EINIT,
 3021                          /*K* INERR - BIT(1)   if set specifies
 3022                          error on reading the message.
 3023                          */
 3024            2 * BIT(8) UNAL ; /* SPARE BITS*/
 3025       %MEND;
 3026
 3027                          /*F*   NAME: VLP_ERRCODE
 3028
 3029                          The VLP_ERRCODE macro may be used to generate a structure
 3030                          that contains the standard 2 word error code used
 3031                          internally in LCP-6.  This is the format of the error
 3032                          code as it is maintained in the JIT, the exceptional
 3033                          condition frames, and in various messages sent to
 3034                          cooperating processes in CP-6.  It is also the error
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          83   
 3035                          code that is passed to M$ERRMSG by that cooperating
 3036                          host process.
 3037                          */
 3038
 3039      %MACRO VLP_ERRCODE (FPTN=VLP_ERRCODE,
 3040        FCG='0'B,
 3041        MID='0'B,
 3042        MON='0'B,
 3043        ERR#=0,
 3044        SEV(G_SEV_CONT#=0,G_SEV_ERROR#=4,G_SEV_ABORT#=6,ANY)=0,
 3045        LVL=1,
 3046        LAST(YES=";",NO=",",ANY)=";",
 3047        ALGN=WALIGNED,
 3048        STCLASS=STATIC);
 3049
 3050      %LSET LISTDIR='0'B;
 3051      %LSET LISTEXP='1'B;
 3052      %LSET LISTCOM='0'B;
 3053      %LSET LISTSUB='1'B;
 3054
 3055      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3056      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3057      %LSET INIT=CHARTEXT('INIT');
 3058      %LSET EINIT=CHARTEXT('');
 3059      %ELSE;
 3060      %LSET INIT=CHARTEXT('/*');
 3061      %LSET EINIT=CHARTEXT('*/');
 3062      %ENDIF;
 3063      %IF LVL=1;
 3064      DCL 1 FPTN STCLASS ALGN,
 3065      %ELSE;
 3066              %LVL FPTN ALGN,
 3067      %ENDIF;
 3068
 3069      %LSET FCG#=CONCAT(TEXTCHAR(FCG),BINASC(0),BINASC(0));
 3070      %LSET L=LENGTHC(TEXTCHAR(FCG))-1;
 3071      %IF L<1;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          84   
 3072      %ELSEIF SUBSTR(FCG#,0,1)='''' AND(SUBSTR(FCG#,L,1)='''');
 3073      %LSET FCG#=CONCAT(SUBSTR(FCG#,1,L-1),BINASC(0));
 3074      %LSET L=L-2;
 3075      %ENDIF;
 3076      %IF SUBSTR(FCG#,0,1)~='''' AND(L<2);
 3077      %LSET FCG#=CONCAT(SUBBIT(ASCBIT(SUBSTR(FCG#,0,1)),3,5),SUBBIT(ASCBIT(SUBSTR(FCG#,1,1)),3,5));
 3078      %ELSE;
 3079      %LSET FCG#=FCG;
 3080      %ENDIF;
 3081                %(LVL+1) %CHARTEXT('FCG ') BIT(10) %INIT(%FCG#) %EINIT UNAL,
 3082                          /*K* FCG = VALUE-BIT(10)
 3083                          contains the two special five bit characters that
 3084                          identify the functional code group that is
 3085                          reporting the error.
 3086                          .XEQ
 3087                          For convenience, it may be
 3088                          specified as text or as a quote string (e.g., FCG=GM or FCG='GM').
 3089                          Each character is composed of the low-order 5 bits
 3090                          of the ASCII code;
 3091                          only the characters A through Z may be represented
 3092                          within any 5 bit field.
 3093                          */
 3094      %LSET MID#=CONCAT(TEXTCHAR(MID),BINASC(0));
 3095      %LSET L=LENGTHC(TEXTCHAR(MID))-1;
 3096      %IF L<1;
 3097      %ELSEIF SUBSTR(MID#,0,1)='''' AND(SUBSTR(MID#,L,1)='''');
 3098      %LSET MID#=SUBSTR(MID#,1,L-1);
 3099      %LSET L=L-2;
 3100      %ENDIF;
 3101      %IF SUBSTR(MID#,0,1)~='''' AND(L<2);
 3102      %LSET MID#=SUBBIT(ASCBIT(SUBSTR(MID#,0,1)),3,5);
 3103      %ELSE;
 3104      %LSET MID#=MID;
 3105      %ENDIF;
 3106                %(LVL+1) %CHARTEXT('MID ') BIT(5) %INIT(%MID#) %EINIT UNAL,
 3107                          /*K* MID = VALUE-BIT(5)
 3108                          contains the special five bit character that identifies
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          85   
 3109                          which module in the functional code group is
 3110                          reporting the error.
 3111                          .XEQ
 3112                          For convenience, it may be
 3113                          specified as text or as a quote string (e.g., MID=M or MID='M').
 3114                          Only the characters A through Z should be specified.
 3115                          */
 3116                %(LVL+1) %CHARTEXT('MON ') BIT(1) %INIT(MON) %EINIT UNAL,
 3117                          /*K* MON = VALUE-BIT(1)
 3118                          is set if this error is reported by the monitor.
 3119                          */
 3120                %(LVL+1) %CHARTEXT('ERR# ') UBIN(13) %INIT(ERR#) %EINIT UNAL,
 3121                          /*K* ERR# = VALUE-DEC(0-8191)
 3122                          contains the number that identifies a particular
 3123                          error condition.  The file B_ERRORS_C.:LIBRARY
 3124                          contains the values for the ERR#s reported by the
 3125                          monitor.
 3126                          */
 3127
 3128                %(LVL+1) %CHARTEXT('SEV ') UBIN(3) %INIT(SEV) %EINIT UNAL LAST
 3129                          /*K* SEV = VALUE-DEC(0-7)
 3130                          serves a double purpose.  Within the monitor it is
 3131                          used to indicate the seriousness of an error.  When
 3132                          passed by the user to M$ERRMSG it indicates the level
 3133                          of detail requested in the error message.
 3134
 3135                          .XEQ
 3136                          One of the following may be specified to indicate
 3137                          the action the monitor is to take when the user
 3138                          has not specified an ALTRET address on the monitor
 3139                          service request that has caused the error:
 3140                          }
 3141                          } G_SEV_CONT#   - Ignore the error; continue the user.
 3142                          }
 3143                          } G_SEV_ERROR#  - Error the program.
 3144                          }
 3145                          } G_SEV_ABORT#  - Abort the program.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          86   
 3146                          }
 3147                          */
 3148      %MEND;
 3149
 3150
 3151
 3152
 3153
 3154                          /*F*   NAME: VLP_SCODE
 3155
 3156                          The VLP_SCODE macro generates the structure describing
 3157                          a standard LCP-6 recovery code.  This is the code passed to the
 3158                          monitor on a call to M$SCREECH.
 3159                          */
 3160
 3161      %MACRO VLP_SCODE (FPTN=VLP_SCODE,
 3162        FCG='0'B,
 3163        MID='0'B,
 3164        MON(YES='1'B,NO='0'B,ANY)='1'B,
 3165        ERR#=0,
 3166        SEV(G_SEV_SNAP#=5,G_SEV_SUA#=6,G_SEV_SCREECH#=7,ANY)=5,
 3167        LVL=1,
 3168        LAST(YES=";",NO=",",ANY)=";",
 3169        ALGN=WALIGNED,
 3170        STCLASS=STATIC);
 3171
 3172      %LSET LISTDIR='0'B;
 3173      %LSET LISTEXP='1'B;
 3174      %LSET LISTCOM='0'B;
 3175      %LSET LISTSUB='1'B;
 3176      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3177      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3178      %LSET INIT=CHARTEXT('INIT');
 3179      %LSET EINIT=CHARTEXT('');
 3180      %ELSE;
 3181      %LSET INIT=CHARTEXT('/*');
 3182      %LSET EINIT=CHARTEXT('*/');
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          87   
 3183      %ENDIF;
 3184
 3185                %VLP_ERRCODE (FPTN=FPTN,FCG=FCG,MID=MID,MON=MON,ERR#=ERR#,SEV=SEV,
 3186                LVL=LVL,LAST=NO,STCLASS=STCLASS);
 3187                          /*K* FCG = VALUE-BIT(10)
 3188                          contains the two special five bit characters that
 3189                          identify the functional code group that is
 3190                          initiating the recovery.
 3191                          .XEQ
 3192                          For convenience, it may be
 3193                          specified as text or as a quote string (e.g., FCG=GM or FCG='GM').
 3194                          Each character is composed of the low-order 5 bits
 3195                          of the ASCII code;
 3196                          only the characters A through Z may be represented
 3197                          within any 5 bit field.
 3198                          */
 3199                          /*K* MID = VALUE-BIT(5)
 3200                          contains the special five bit character that identifies
 3201                          which module in the functional code group is
 3202                          initiating the recovery.
 3203                          .XEQ
 3204                          For convenience, it may be
 3205                          specified as text or as a quote string (e.g., MID=M or MID='M').
 3206                          Only the characters A through Z should be specified.
 3207                          */
 3208                          /*K* MON = {YES|NO}
 3209                          specifies that Recovery was called by the Monitor
 3210                          if set to 1 or by a Ghost or Special Shared
 3211                          Processor if set to 0.  The default is YES.
 3212                          */
 3213                          /*K* ERR# = VALUE-DEC(0-8191)
 3214                          contains the number that identifies a particular
 3215                          recovery condition.  The file B_SCODE_C contains
 3216                          the values for the recoveries initiated by the monitor.
 3217                          */
 3218
 3219                          /*K* SEV = VALUE-DEC(0-7)
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          88   
 3220                          specifies the severity of the Recovery code:
 3221
 3222                          }    G_SEV_SNAP# - Snapshot Dump
 3223                          }    G_SEV_SUA# - Single User Abort
 3224                          }    G_SEV_SCREECH# - Full FEP Recovery
 3225
 3226                          The default is G_SEV_SNAP#.
 3227                          */
 3228
 3229              %(LVL+1) DUMP_BITS UBIN WORD LAST
 3230      %MEND;
 3231
 3232
 3233                          /*F* NAME: M$WAIT - Suspend Program
 3234
 3235                          The M$WAIT service causes suspension of background
 3236                          program execution for a specified period of real
 3237                          time.  Program execution is resumed at the next
 3238                          statement following the M$WAIT request.  Optionally,
 3239                          the suspension period of a suspended program may
 3240                          be adjusted by an interrupt level program associated
 3241                          with the suspended program.  A suspended program
 3242                          is resumed before its suspension time has expired
 3243                          if an asynchronous event is reported (see
 3244                          M$EVENT). The amount of unexpired time may be
 3245                          returned to the user.
 3246
 3247                          The form of the call for this service is:
 3248
 3249                          CALL M$WAIT (FPT_WAIT) [ALTRET(label)];
 3250
 3251                          The parameters for this service are as follows:
 3252                                                                                                     */
 3253      %MACRO  FPT_WAIT (FPTN=FPT_WAIT,
 3254                        ALGN=WALIGNED,
 3255                        STCLASS=STATIC,
 3256                        UETIME=NIL,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          89   
 3257                        MODE(SUSP=0,ADJUST=1)=0,
 3258                        UTYPE(TICS=0,SEC=1,UTS=2)=1,
 3259                        VECTORS=YES,
 3260                        UNITS=NIL);
 3261
 3262      %LSET LISTDIR='0'B;
 3263      %LSET LISTEXP='1'B;
 3264      %LSET LISTCOM='0'B;
 3265      %LSET LISTSUB='1'B;
 3266      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3267      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3268      %LSET INIT=CHARTEXT('INIT');
 3269      %LSET EINIT=CHARTEXT('');
 3270      %ELSE;
 3271      %LSET INIT=CHARTEXT('/*');
 3272      %LSET EINIT=CHARTEXT('*/');
 3273      %ENDIF;
 3274
 3275      DCL 1 FPTN STCLASS ALGN,
 3276      %IF TEXTCHAR(VECTORS)='YES';
 3277      %LSET LVL=3;
 3278            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 3279            2 %CHARTEXT('UNITS ') VECTOR %INIT(VECTOR(UNITS))%EINIT,
 3280                          /*K* UNITS = VARIABLE locates an area containing
 3281                          the number of units of time the program is to
 3282                          be suspended or the suspension time is to be
 3283                          adjusted.  VARIABLE is UBIN(16) if UTYPE=SEC or
 3284                          UTYPE=TICS and UBIN(32) if UTYPE=UTS.
 3285
 3286                          The default is NIL.
 3287                          */
 3288            2 %CHARTEXT('UETIME ') VECTOR %INIT(VECTOR(UETIME))%EINIT,
 3289                          /*K* UETIME = VARIABLE locates a UBIN(16) area into
 3290                          which the unexpired time is to be stored if the
 3291                          suspension is terminated prematurely.  If UETIME
 3292                          is NIL, the time is not returned. If the
 3293                          suspension is not terminated prematurely, the
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          90   
 3294                          unexpired time will be zero.  When MODE=ADJUST,
 3295                          the unexpired time will be zero unless the user
 3296                          is not suspended, in which case it will be the
 3297                          requested adjust interval.
 3298
 3299                          The value returned in UETIME is in UTS units,
 3300                          regardless of UTYPE.  If UTS was specified,
 3301                          UETIME is the interval from the current time to
 3302                          the specified UTS time.
 3303
 3304                          The default is NIL.
 3305                                                                         */
 3306            2 V,
 3307      %ELSE;
 3308      %LSET LVL=2;
 3309      %ENDIF;
 3310              %LVL %CHARTEXT('MODE ') UBIN(2) UNAL %INIT(MODE)%EINIT,
 3311                          /*K* MODE = OPTION specifies if the calling program
 3312                          is to be suspended, MODE=SUSP, or if the suspension
 3313                          time of the currently suspended background level
 3314                          program of this user is to be adjusted, MODE=ADJUST.
 3315                          The M$WAIT service will return immediately if
 3316                          OPTION is incorrect for the mode of the calling
 3317                          program.
 3318
 3319                          The default is SUSP.
 3320                          */
 3321                %LVL %CHARTEXT('UTYPE ') UBIN(2) UNAL %INIT(UTYPE)%EINIT,
 3322                          /*K* UTYPE = OPTION specifies the kind of time in
 3323                          which UNITS is expressed.  Valid options are:
 3324                          }
 3325                          }      TICS   FEP UTS units (.133 seconds)
 3326                          }
 3327                          }      SEC    Seconds.
 3328                          }
 3329                          }      UTS    A specific wakeup date and time in
 3330                          }             LCP-6 UTS units.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          91   
 3331                          }
 3332                          When TICS or SEC is specified, UNITS is treated
 3333                          modulo 24 hours.  When UTS is specified, UNITS
 3334                          gives the date and time the user is to be awakened
 3335                          to the nearest .133 second.
 3336                          The default is SEC.
 3337                          */
 3338                %LVL * BIT(12) UNAL %INIT('0'B)%EINIT;
 3339      %MEND;
 3340
 3341
 3342
 3343
 3344
 3345
 3346                          /*F* NAME: M$CLOCK - Request Clock Service
 3347
 3348                          The M$CLOCK service provides the facility for
 3349                          requesting notification when a specified period
 3350                          of time has expired, obtaining the currently
 3351                          unexpired time and canceling an outstanding
 3352                          request.  Either Wall time or Execution time
 3353                          may be specified in minutes, seconds or
 3354                          UTS units.  Both Wall and Execution timers
 3355                          may be in effect at the same time.
 3356
 3357                          Notification of timer expiration may be by entry
 3358                          to the user's Event asynchronous procedure or by
 3359                          activation of a specified interrupt level.
 3360
 3361                          Both execution and wall timers may be made permanent.
 3362                          In this mode they are reset to their original increment
 3363                          each time they expire.
 3364
 3365                          This service is only available to the User
 3366                          domain at the User Interrupt Level or a Handler
 3367                          Interrupt Level, and cannot be used by the
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          92   
 3368                          Debugger.
 3369
 3370
 3371                          The form of the call for this service is:
 3372
 3373                          CALL M$CLOCK (FPT_CLOCK) [ALTRET(label)];
 3374
 3375                          The parameters for this service are as follows:
 3376                          */
 3377      %MACRO  FPT_CLOCK (FPTN=FPT_CLOCK,
 3378                        ALGN=WALIGNED,
 3379                        STCLASS=STATIC,
 3380                         VECTORS=YES,
 3381                        CLOCK(WALL=0,EXECUTION=1)=0,
 3382                        MODE(SET=0,TEST=1)=0,
 3383                        UTYPE(UTS=0,TICS=0,SEC=1,MIN=2)=0,
 3384                        CANCEL(YES='1'B,NO='0'B)='0'B,
 3385                        PERM(YES='1'B,NO='0'B)='0'B,
 3386                        LEVEL=0,
 3387                        UNITS=NIL);
 3388
 3389
 3390      %LSET LISTDIR='0'B;
 3391      %LSET LISTEXP='1'B;
 3392      %LSET LISTCOM='0'B;
 3393      %LSET LISTSUB='1'B;
 3394      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3395      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3396      %LSET INIT=CHARTEXT('INIT');
 3397      %LSET EINIT=CHARTEXT('');
 3398      %ELSE;
 3399      %LSET INIT=CHARTEXT('/*');
 3400      %LSET EINIT=CHARTEXT('*/');
 3401      %ENDIF;
 3402
 3403      DCL 1 FPTN STCLASS ALGN,
 3404
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          93   
 3405      %IF TEXTCHAR(VECTORS)='YES';
 3406
 3407      %LSET LVL=3;
 3408            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 3409            2 %CHARTEXT('UNITS ') VECTOR %INIT(VECTOR(UNITS))%EINIT,
 3410                          /*K* UNITS = VARIABLE  locates a 1-word area.
 3411                          If MODE=SET is specified this area contains the
 3412                          number of units of time which are to elapse before
 3413                          the user is notified by entry to his Event procedure.
 3414
 3415                          If MODE=TEST is specified, this area will be set to
 3416                          the number of units of time remaining before the
 3417                          specified clock will expire.
 3418
 3419                          The default is NIL.
 3420                          */
 3421
 3422            2 V,
 3423      %ELSE;
 3424      %LSET LVL=2;
 3425
 3426      %ENDIF;
 3427
 3428
 3429              %LVL %CHARTEXT('CLOCK ') UBIN(2) UNAL %INIT(CLOCK)%EINIT,
 3430                %LVL %CHARTEXT('MODE ') UBIN(2) UNAL %INIT(MODE)%EINIT,
 3431                %LVL %CHARTEXT('UTYPE ') UBIN(2) UNAL %INIT(UTYPE)%EINIT,
 3432                %LVL %CHARTEXT('CANCEL ') BIT(1) UNAL %INIT(CANCEL)%EINIT,
 3433                %LVL %CHARTEXT('PERM   ') BIT(1) UNAL %INIT(PERM)%EINIT,
 3434                %LVL * UBIN(2) UNAL %INIT(0)%EINIT,
 3435                %LVL %CHARTEXT('LEVEL ') UBIN(6) UNAL %INIT(LEVEL)%EINIT;
 3436                          /*K* CLOCK = OPTION specifies which clock is to be
 3437                          used.
 3438
 3439                          WALL specifies that the real time wall clock is
 3440                          to be used.
 3441
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          94   
 3442                          EXECUTION specifies that user execution time,
 3443                          including time spent performing monitor services,
 3444                          is to be used.
 3445
 3446                          The default is WALL.
 3447                                                                         */
 3448                          /*K* MODE = OPTION specifies the operation to be
 3449                          performed.  Valid options are:
 3450
 3451                          SET specifies that the clock is to be set.  Setting
 3452                          a clock that is already running is permitted and
 3453                          begins a new interval.
 3454
 3455                          TEST specifies that the current unelapsed time in
 3456                          the specified clock is to be returned in UNITS.
 3457
 3458                          The default is SET.
 3459                          */
 3460                          /*K* UTYPE = OPTION specifies the kind of time that
 3461                          UNITS is expressed in.  Valid options are:
 3462
 3463                          }    TICS  FEP UTS units (.133 seconds)
 3464                          }    SEC   seconds
 3465                          }    MIN   minutes
 3466
 3467                          The default is TICS.
 3468                          */
 3469                          /*K* CANCEL = {YES|NO}
 3470                          specifies, if YES, that the clock is to be canceled.
 3471                          No entry is made to the Event procedure or interrupt
 3472                          level scheduled.
 3473
 3474                          The default is NO.
 3475                          */
 3476                          /*K* PERM = {YES|NO}
 3477                          specifies, if yes, that the clock is to be permanent
 3478                          and is to be reset with the original time interval
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          95   
 3479                          each time it expires.
 3480
 3481                          The default is NO.
 3482                          */
 3483                          /*K* LEVEL = VALUE-DEC(0-61) specifies an Interrupt
 3484                          Level that is to be scheduled (triggered) when
 3485                          the requested clock interval expires.
 3486
 3487                          A value of zero (0) indicates that no interrupt
 3488                          level is to be scheduled but that the users
 3489                          EVENT asynchronous entry procedure is to be
 3490                          entered instead.
 3491                          When the event handler is entered, G$EXCFR.SUBC will
 3492                          be set to %G_RTTMRSC# if the CLOCK option specified
 3493                          WALL.  G$EXCFR.SUBC will be set to %G_XTMRSC# if
 3494                          CLOCK=EXECUTION was specified.
 3495
 3496                          The default is zero (0).
 3497                                                                         */
 3498      %MEND;
 3499
 3500
 3501
 3502
 3503
 3504
 3505                          /*F* NAME: M$MAKEUSR - Create New User
 3506
 3507                          The M$MAKEUSR service builds and initializes a new user.
 3508                          This service is only available to the NODEADMIN user and
 3509                          will ALTRET if called from any other.
 3510
 3511                          The form of the call for this service is:
 3512
 3513                          CALL M$MAKEUSR (FPT_MAKEUSR) [ALTRET(label)];
 3514
 3515                          The parameters for this service are as follows:
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          96   
 3516                                                                                  */
 3517
 3518      %MACRO FPT_MAKEUSR (FPTN=FPT_MAKEUSR,
 3519                        ALGN=WALIGNED,
 3520                        STCLASS=STATIC,
 3521                         STRTU=NIL);
 3522
 3523      %LSET LISTDIR='0'B;
 3524      %LSET LISTEXP='1'B;
 3525      %LSET LISTCOM='0'B;
 3526      %LSET LISTSUB='1'B;
 3527      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3528      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3529      %LSET INIT=CHARTEXT('INIT');
 3530      %LSET EINIT=CHARTEXT('');
 3531      %ELSE;
 3532      %LSET INIT=CHARTEXT('/*');
 3533      %LSET EINIT=CHARTEXT('*/');
 3534      %ENDIF;
 3535
 3536      DCL 1 FPTN STCLASS ALGN,
 3537            2 %CHARTEXT('STRTU') VECTOR %INIT(VECTOR(STRTU))%EINIT;
 3538                          /*K* STRTU = VARIABLE specifies the location of a structure
 3539                          containing initialization parameters for the user being
 3540                          started.  This structure is generated by the KL_STRTU
 3541                          macro in the KL_MACRO_C include file.
 3542                          The default is NIL.
 3543                                                                                  */
 3544      %MEND;
 3545
 3546
 3547
 3548
 3549
 3550
 3551                          /*F* NAME: M$AFD - Associate Front-end Debugger
 3552
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          97   
 3553                          The M$AFD service associates the front-end debugger for
 3554                          a specified user.
 3555                          This service is only available to the NODEADMIN user and
 3556                          will ALTRET if called from any other.
 3557
 3558                          The form of the call for this service is:
 3559
 3560                          CALL M$AFD (FPT_AFD) [ALTRET(label)];
 3561
 3562                          The parameters for this service are as follows:
 3563                                                                                  */
 3564
 3565      %MACRO FPT_AFD (FPTN=FPT_AFD,
 3566                        ALGN=WALIGNED,
 3567                        STCLASS=STATIC,
 3568                        AFD=NIL);
 3569
 3570      %LSET LISTDIR='0'B;
 3571      %LSET LISTEXP='1'B;
 3572      %LSET LISTCOM='0'B;
 3573      %LSET LISTSUB='1'B;
 3574      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3575      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3576      %LSET INIT=CHARTEXT('INIT');
 3577      %LSET EINIT=CHARTEXT('');
 3578      %ELSE;
 3579      %LSET INIT=CHARTEXT('/*');
 3580      %LSET EINIT=CHARTEXT('*/');
 3581      %ENDIF;
 3582
 3583      DCL 1 FPTN STCLASS ALGN,
 3584            2 %CHARTEXT('AFD') VECTOR %INIT(VECTOR(AFD))%EINIT;
 3585                          /*K* AFD = VARIABLE specifies the location of a structure
 3586                          containing information about which user to associate
 3587                          the FD with and also information about which HOST
 3588                          endpoint to connect to. Also included is information
 3589                          useful in enforcing debugging access control.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          98   
 3590                          This structure is generated by a KL_AFD macro.
 3591                                                                                  */
 3592      %MEND;
 3593
 3594
 3595
 3596
 3597                          /*F* NAME: M$SPRIV - Control Of System Privileges
 3598
 3599                          The Job Information Table contains three double words that
 3600                          are used to verify a user's privileges prior to
 3601                          performing certain system functions on behalf of the
 3602                          user: G$JIT.PRIV.AUTH, G$JIT.PRIV.PRC, and G$JIT.PRIV.ACTIVE.
 3603
 3604                          The privileges allowed a user program are
 3605                          authorized by SUPER and stored in the user
 3606                          authorization record.  At program initiation these
 3607                          privilege bits are set in G$JIT.PRIV.AUTH.
 3608
 3609                          Processors in the :SYS account may have certain
 3610                          of these user privileges associated with the processor
 3611                          itself.  These privileges, specified by an option of
 3612                          FEPLINK, are stored in the head record of the
 3613                          run unit.  At initiation of a processor fetched
 3614                          from the :SYS account, these bits are copied to
 3615                          G$JIT.PRIV.PRC. If the run unit is not from
 3616                          :SYS, G$JIT.PRIV.PRC is set to zero.
 3617
 3618                          The privileges effective for the currently
 3619                          running user program or processor are set in
 3620                          G$JIT.PRIV.ACTIVE.
 3621                          When a program is initiated, all privilege bits
 3622                          in G$JIT.PRIV.ACTIVE are turned off.
 3623
 3624                          A user program or system processor may use M$SPRIV
 3625                          to activate the privileges for which the user is authorized.
 3626
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          99   
 3627                          The privilege bits specified on the PRIV parameter of
 3628                          M$SPRIV are turned on only if the corresponding
 3629                          bits are set in G$JIT.PRIV.AUTH or G$JIT.PRIV.PRC.
 3630                          The AUTH and PRC options may be used to qualify
 3631                          the operation.
 3632
 3633                          Only those privileges required by the current
 3634                          process should be specified to avoid
 3635                          inadvertent use of unneeded privileges.
 3636
 3637                          A separate word in the Job Information Table is used
 3638                          to control the access to restricted LCP-6 processors
 3639                          and the specific functions performed by these processors.
 3640                          User authorization is established by SUPER and
 3641                          stored in the user authorization record.  When a
 3642                          user is initiated these processor function bits are
 3643                          set in G$JIT.PPRIV.  When a system processor
 3644                          is put into execution it may inspect the privilege
 3645                          bit settings in G$JIT.PPRIV to determine if the user
 3646                          has the required system processor privilege prior to
 3647                          performing a specific function.
 3648                          The processor privilege bits in G$JIT.PPRIV may also be used
 3649                          to qualify the privileges to be made active.
 3650
 3651                          All bits specified and allowed are set in
 3652                          G$JIT.PRIV.ACTIVE.  All bits not specified are reset.
 3653                          If not all specified bits are
 3654                          allowed, the bits representing privileges granted
 3655                          are set and the alternate return is then
 3656                          taken with the error severity code set to 0.
 3657
 3658                          The form of the call for this service is:
 3659
 3660                          CALL M$SPRIV (FPT_SPRIV)[ALTRET (label)];
 3661
 3662                          The parameters for the M$SPRIV are as follows:
 3663                          */
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          100  
 3664
 3665
 3666      %MACRO FPT_SPRIV (FPTN=FPT_SPRIV,
 3667         ALGN=WALIGNED,
 3668         PRIV=NIL,
 3669         PPRIV=NIL,
 3670         AUTH(YES='1'B,NO='0'B)='1'B,
 3671         PRC(YES='1'B,NO='0'B)='0'B,
 3672         PPCHK(ALL='1'B,ANY='0'B)='0'B,
 3673         VECTORS=YES,
 3674         STCLASS=STATIC);
 3675
 3676      %LSET LISTDIR='0'B;
 3677      %LSET LISTEXP='1'B;
 3678      %LSET LISTCOM='0'B;
 3679      %LSET LISTSUB='1'B;
 3680      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3681      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3682      %LSET INIT=CHARTEXT(' INIT');
 3683      %LSET EINIT=CHARTEXT('');
 3684      %ELSE;
 3685      %LSET INIT=CHARTEXT('/*');
 3686      %LSET EINIT=CHARTEXT('*/');
 3687      %ENDIF;
 3688
 3689      DCL 1 FPTN STCLASS ALGN,
 3690      %IF TEXTCHAR(VECTORS)='YES';
 3691            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 3692            2 PRIV_ VECTOR %INIT(VECTOR(PRIV))%EINIT,
 3693                          /*K* PRIV = VARIABLE  locates a two word
 3694                          memory location that contains the privilege bits
 3695                          that are to be set in G$JIT.ACTIVE.
 3696                          The VLP_PRIV macro may be used to generate this area.
 3697
 3698                          Default=NIL.
 3699                          */
 3700            2 PPRIV_ VECTOR %INIT(VECTOR(PPRIV))%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          101  
 3701                          /*K* PPRIV = VARIABLE  locates a two word
 3702                          memory location that contains the privilege bits
 3703                          that are to be compared with G$JIT.PPRIV prior to
 3704                          granting the privilege request.  The PPCHK option
 3705                          may be used to specify if all bits in G$JIT.PPRIV
 3706                          must be set, or if a any one set is sufficient to
 3707                          grant the request.
 3708                          The VLP_PPRIV macro may be used to generate this area.
 3709
 3710                          Default=NIL.  If this parameter is not specified,
 3711                          there is no test against G$JIT.PPRIV.
 3712
 3713                          */
 3714            2 V,
 3715      %LSET LVL=3;
 3716      %ELSE;
 3717      %LSET LVL=2;
 3718      %ENDIF;
 3719              %(LVL) %CHARTEXT('AUTH BIT(1)') %INIT(AUTH)%EINIT,
 3720                          /*K* AUTH = {YES|NO}   specifies, if YES, that
 3721                          the AUTH field from G$JIT.PRIV is used
 3722                          to verify the operation.  Default is YES.
 3723                          */
 3724
 3725              %(LVL) %CHARTEXT('PRC BIT(1)') %INIT(PRC)%EINIT,
 3726                          /*K* PRC = {YES|NO}   specifies, if YES, that
 3727                          the PRC field from G$JIT.PRIV is used
 3728                          to verify the operation.  If YES, and the PPRIV option
 3729                          is also specified, then the PRC privileges will be
 3730                          used to verify the operation only if the PPRIV check
 3731                          succeeds.
 3732
 3733                          Default is NO.
 3734                          */
 3735              %(LVL) %CHARTEXT('PPCHK BIT(1)') %INIT(PPCHK)%EINIT,
 3736                          /*K* PPCHK = {ALL|ANY}   specifies, if ALL, that
 3737                          the PRC field from G$JIT.PRIV is to be used to verify
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          102  
 3738                          the operation only if all the privileges specified
 3739                          via the PPRIV option are contained in G$JIT.PPRIV.
 3740                          If ANY is specified, then the PRC privileges will be
 3741                          used to verify the operation if any of the privileges
 3742                          specified via PPRIV are contained in G$JIT.PPRIV.
 3743
 3744                          Default = ANY.  This option is ignored if the PRC option
 3745                          is NO, or if the PPRIV option is not specified.
 3746                          */
 3747              %(LVL) * BIT(13) %INIT('0'B)%EINIT;
 3748      %MEND;
 3749
 3750
 3751
 3752                          /*F* NAME: VLP_PRIV
 3753
 3754                          The VLP_PRIV macro may be used to generate the
 3755                          area specified by the PRIV option of FPT_SPRIV.
 3756
 3757                          Privileges in the VLP_PRIV area may be set on or
 3758                          off by specifying the privilege name={ON|OFF}.
 3759                          A description of the privilege names and the
 3760                          meaning of each privilege follows:
 3761                          */
 3762
 3763      %MACRO VLP_PRIV (FPTN=VLP_PRIV,
 3764        FMSEC(ON='1'B,OFF='0'B)='0'B,
 3765        FMREAD(ON='1'B,OFF='0'B)='0'B,
 3766        SNAP(ON='1'B,OFF='0'B)='0'B,
 3767        SCREECH(ON='1'B,OFF='0'B)='0'B,
 3768        GPP(ON='1'B,OFF='0'B)='0'B,
 3769        EXPM(ON='1'B,OFF='0'B)='0'B,
 3770        SYSLOG(ON='1'B,OFF='0'B)='0'B,
 3771        CQ(ON='1'B,OFF='0'B)='0'B,
 3772        INTCON(ON='1'B,OFF='0'B)='0'B,
 3773        TND(ON='1'B,OFF='0'B)='0'B,
 3774        MSYS(ON='1'B,OFF='0'B)='0'B,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          103  
 3775        MAXMEM(ON='1'B,OFF='0'B)='0'B,
 3776        EXMM(ON='1'B,OFF='0'B)='0'B,
 3777        SPCLMM(ON='1'B,OFF='0'B)='0'B,
 3778
 3779        LVL=1,
 3780        LAST(YES=";",NO=",",ANY)=";",
 3781        ALGN=WALIGNED,
 3782        STCLASS=STATIC);
 3783
 3784      %LSET LISTDIR='0'B;
 3785      %LSET LISTEXP='1'B;
 3786      %LSET LISTCOM='0'B;
 3787      %LSET LISTSUB='1'B;
 3788      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3789      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3790      %LSET INIT=CHARTEXT('INIT');
 3791      %LSET EINIT=CHARTEXT('');
 3792      %ELSE;
 3793      %LSET INIT=CHARTEXT('/*');
 3794      %LSET EINIT=CHARTEXT('*/');
 3795      %ENDIF;
 3796
 3797      %IF LVL=1;
 3798      DCL 1 FPTN STCLASS ALGN,
 3799      %ELSE;
 3800              %LVL FPTN ALGN,
 3801      %ENDIF;
 3802                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3803                          /* Corresponds to FMBLK in the host PRIV word.
 3804                          */
 3805                %(LVL+1) %CHARTEXT('FMSEC ') BIT(1) UNAL %INIT(FMSEC)%EINIT,
 3806                          /*N* FMSEC = {ON|OFF}
 3807                          allows the user to bypass all of the file management
 3808                          security checks when using shared data segments.
 3809                          */
 3810                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3811                          /* Corresponds to FMDIAG in the host PRIV word.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          104  
 3812                          */
 3813                %(LVL+1) %CHARTEXT('FMREAD ') BIT(1) UNAL %INIT(FMREAD)%EINIT,
 3814                          /*N* FMREAD = {ON|OFF}
 3815                          allows the user to bypass all read only file management
 3816                          security checks when using shared data segments.
 3817                          */
 3818                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3819                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3820                          /* Corresponds to SYSACCT in the host PRIV word.
 3821                          */
 3822                %(LVL+1) * BIT(4) UNAL %INIT('0'B)%EINIT,
 3823
 3824                %(LVL+1) %CHARTEXT('SNAP ') BIT(1) UNAL %INIT(SNAP)%EINIT,
 3825                          /*N* SNAP = {ON|OFF}
 3826                          allows the user to use M$SCREECH to take a snapshot dump.
 3827                          */
 3828                %(LVL+1) %CHARTEXT('SCREECH ') BIT(1) UNAL %INIT(SCREECH)%EINIT,
 3829                          /*K* SCREECH = {ON|OFF}
 3830                          allows the user to use M$SCREECH to dump and
 3831                          reboot the Front End.
 3832                          */
 3833                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3834                          /* Corresponds to DISPJOB in the host PRIV word.
 3835                          */
 3836                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3837
 3838                %(LVL+1) %CHARTEXT('GPP ') BIT(1) UNAL %INIT(GPP)%EINIT,
 3839                          /*K* GPP = {ON|OFF}
 3840                          allows a user to override the stealable page limit and acquire
 3841                          physical memory pages.
 3842                          */
 3843                %(LVL+1) %CHARTEXT('EXPM ') BIT(1) UNAL %INIT(EXPM)%EINIT,
 3844                          /*K* EXPM = {ON|OFF}
 3845                          allows the user to start and stop the monitor performance monitor.
 3846                          */
 3847                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3848                %(LVL+1) %CHARTEXT('SYSLOG ') BIT(1) UNAL %INIT(SYSLOG)%EINIT,
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          105  
 3849                          /*K* SYSLOG = {ON|OFF}
 3850                          allows the user to use the M$WRSYSLOG monitor service request.
 3851                          */
 3852                %(LVL+1) * BIT(2) UNAL %INIT('0'B)%EINIT,
 3853                          /* Corresponds to MFEP and CFEP in the host PRIV word.
 3854                          */
 3855                %(LVL+1) %CHARTEXT('CQ ') BIT(1) UNAL %INIT(CQ)%EINIT,
 3856                          /*K* CQ = {ON|OFF}
 3857                          allows the user to use the Circular Queue.
 3858                          */
 3859                %(LVL+1) %CHARTEXT('INTCON ') BIT(1) UNAL %INIT(INTCON)%EINIT,
 3860                          /*K* INTCON = {ON|OFF}
 3861                          allows the user to use the M$INTCON monitor service.
 3862                          */
 3863                %(LVL+1) * BIT(2) UNAL %INIT('0'B)%EINIT,
 3864                          /* Corresponds to IOQW and IOQ in the host PRIV word.
 3865                          */
 3866                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3867                          /* Corresponds to PM in the host PRIV word.
 3868                          */
 3869                %(LVL+1) %CHARTEXT('TND ') BIT(1) UNAL %INIT(TND)%EINIT,
 3870                          /*K* TND = {ON|OFF}
 3871                          allows the user to use the Test aNd Diagnostic monitor services.
 3872                          */
 3873                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3874                          /* Corresponds to JIT in the host PRIV word.
 3875                          */
 3876                %(LVL+1) * BIT(1) UNAL %INIT('0'B)%EINIT,
 3877
 3878                %(LVL+1) %CHARTEXT('MSYS ') BIT(1) UNAL %INIT(MSYS)%EINIT,
 3879                          /*K* MSYS = {ON|OFF}
 3880                          allows the user to use the M$SYS monitor service
 3881                          and to execute his interrupt processing routines in Ring 1.
 3882                          */
 3883                %(LVL+1) %CHARTEXT('MAXMEM ') BIT(1) UNAL %INIT(MAXMEM)%EINIT,
 3884                          /*K* MAXMEM = {ON|OFF}
 3885                          allows the user to allocate memory beyond his authorized limit.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          106  
 3886                          */
 3887                %(LVL+1) %CHARTEXT('EXMM ') BIT(1) UNAL %INIT(EXMM)%EINIT,
 3888                          /*K* EXMM = {ON|OFF}
 3889                          allows the user to utilize a set of EXtended Memory
 3890                          Management services.
 3891                          M$CVM (read/write access) is the only one available to date.
 3892                          */
 3893                %(LVL+1) %CHARTEXT('SPCLMM ') BIT(1) UNAL %INIT(SPCLMM)%EINIT LAST
 3894                          /*K* SPCLMM = {ON|OFF}
 3895                          allows the user to utilize a set of SPeCiaL Memory Management services.
 3896                          M$CVM (read only access) is the only one available to date.
 3897                          */
 3898      %MEND;
 3899
 3900
 3901
 3902
 3903                          /*F* NAME: VLP_PPRIV
 3904
 3905                          The VLP_PPRIV macro may be used to generate the
 3906                          area specified by the PPRIV option of FPT_SPRIV.
 3907
 3908                          Privileges in the VLP_PPRIV area may be set on or
 3909                          off by specifying the processor privilege={ON|OFF}.
 3910                          A description of the processor privileges and the
 3911                          meaning of each privilege follows:
 3912                          */
 3913
 3914      %MACRO VLP_PPRIV (FPTN=VLP_PPRIV,
 3915
 3916        LVL=1,
 3917        LAST(YES=";",NO=",",ANY)=";",
 3918        ALGN=WALIGNED,
 3919        STCLASS=STATIC);
 3920
 3921      %LSET LISTDIR='0'B;
 3922      %LSET LISTEXP='1'B;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          107  
 3923      %LSET LISTCOM='0'B;
 3924      %LSET LISTSUB='1'B;
 3925      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3926      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3927      %LSET INIT=CHARTEXT('INIT');
 3928      %LSET EINIT=CHARTEXT('');
 3929      %ELSE;
 3930      %LSET INIT=CHARTEXT('/*');
 3931      %LSET EINIT=CHARTEXT('*/');
 3932      %ENDIF;
 3933
 3934      %IF LVL=1;
 3935      DCL 1 FPTN STCLASS ALGN,
 3936      %ELSE;
 3937              %LVL FPTN,
 3938      %ENDIF;
 3939                %(LVL+1) * BIT(32) UNAL %INIT('0'B)%EINIT LAST
 3940                          /*K* processor privilege = {ON|OFF}.
 3941                          There are currently no LCP-6 processor privileges defined.
 3942                          */
 3943      %MEND;
 3944                          /*F* NAME: M$DRTN - Debugger Return
 3945
 3946                          The M$DRTN monitor service provides a way
 3947                          for a Front-end Debugger (hereafter
 3948                          referred to as FD) to return control to
 3949                          the user program.
 3950
 3951                          The FD normally returns control to the user program
 3952                          by returning to the trap handler, but may under special
 3953                          conditions return control to the user program via
 3954                          the M$DRTN service request. The form of the
 3955                          call for this service is as follows:
 3956
 3957                          CALL M$DRTN(FPT_DRTN) [ALTRET(label)];
 3958
 3959                          The parameters for this service are as follows:
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          108  
 3960
 3961                          */
 3962
 3963
 3964
 3965      %MACRO FPT_DRTN
 3966                    (FPTN=FPT_DRTN,
 3967                     SETECC(YES='1'B,NO='0'B)='0'B,
 3968                     ECC=0,
 3969                     QUIT(YES='1'B,NO='0'B)='0'B,
 3970                     KILLFD(YES='1'B,NO='0'B)='0'B,
 3971                     VECTORS=YES,
 3972                     STCLASS=STATIC);
 3973
 3974      %LSET LISTDIR='1'B;
 3975      %LSET LISTEXP='1'B;
 3976      %LSET LISTCOM='0'B;
 3977      %LSET LISTSUB='1'B;
 3978      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3979      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3980      %LSET INIT=CHARTEXT(' INIT');
 3981      %LSET EINIT=CHARTEXT('');
 3982      %ELSE;
 3983      %LSET INIT=CHARTEXT('/*');
 3984      %LSET EINIT=CHARTEXT('*/');
 3985      %ENDIF;
 3986
 3987      DCL 1 FPTN STCLASS DALIGNED,
 3988      %IF TEXTCHAR(VECTORS)='YES';
 3989            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3990            2 V DALIGNED,
 3991      %LSET LVL=3;
 3992      %ELSE;
 3993      %LSET LVL=2;
 3994      %ENDIF;
 3995              %(LVL) %CHARTEXT('SETECC ') BIT(1) UNAL %INIT(SETECC)%EINIT,
 3996                          /*N* SETECC = {YES|NO}  specifies, if YES, that the value
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          109  
 3997                          specified via the ECC option is to be used to
 3998                          replace the value of G$TSA.I.TRAP#.
 3999                          Default = NO.
 4000                          */
 4001              %(LVL) %CHARTEXT('QUIT ') BIT(1) UNAL %INIT(QUIT)%EINIT,
 4002                          /*K* QUIT = {YES|NO}  specifies, if YES, the user's program is
 4003                          to be run down without entering user level Exit Control
 4004                          or reentering the FD. Default = NO.
 4005                          */
 4006              %(LVL) %CHARTEXT('KILLFD ') BIT(1) UNAL %INIT(KILLFD)%EINIT,
 4007                          /*K* KILLFD = {YES|NO} specifies, if YES, that the FD is to
 4008                          be disassociated from the user.
 4009                          Default = NO.
 4010                          */
 4011              %(LVL) * BIT(13) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 4012              %(LVL) %CHARTEXT('ECC ') UBIN(8) UNAL %INIT(ECC)%EINIT,
 4013                          /*N* ECC = VALUE-DEC(0-n)  specifies the value
 4014                          that is replace the G$TSA.I.TRAP#.
 4015                          This value
 4016                          is used by the monitor to determine how to
 4017                          proceed. This option is ignored if SETECC = NO;
 4018                          the value from G$TSA.I.TRAP# will be used.
 4019                          Basically, the monitor proceeds as follows:
 4020
 4021                          If the user has not established control
 4022                          over the condition the FD will be
 4023                          reentered at the M$DRTN ALTRET address.
 4024                          G$ALT.ERR in FD's TCB ALTRET frame will be set
 4025                          to E$NOCONTROL.
 4026
 4027                          If the user has established control over
 4028                          the condition the frame is moved from
 4029                          the TSA to the user's TCB and the
 4030                          user will be entered at his Exceptional
 4031                          Condition processing procedure. If there
 4032                          is insufficient room in the user's TCB to
 4033                          contain the frame, the TRAP# code will be changed
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          110  
 4034                          to XCON and the FD will be reentered
 4035                          at FD's start address.
 4036
 4037                          */
 4038              %(LVL) * BIT(8) UNAL %INIT('0'B)%CHARTEXT('/**/');
 4039      %MEND;
 4040
 4041
 4042
 4043
 4044
 4045                          /*F* NAME: M$UNSHARE - Unshare Library or Program
 4046
 4047                          The M$UNSHARE service provides a means for the
 4048                          user to obtain an unshared copy of the currently
 4049                          executing run unit and/or run time library.
 4050
 4051                          The form of the call for this service is:
 4052
 4053                          CALL M$UNSHARE(FPT_UNSHARE) [ALTRET(label)];
 4054
 4055                          The parameters for this service are as follows:
 4056                          */
 4057
 4058      %MACRO FPT_UNSHARE (FPTN=FPT_UNSHARE,
 4059         ALGN=WALIGNED,
 4060         PROG(YES='1'B,NO='0'B)='1'B,
 4061         SLIB(YES='1'B,NO='0'B)='0'B,
 4062         VECTORS=YES,
 4063         STCLASS=STATIC);
 4064
 4065      %LSET LISTDIR='0'B;
 4066      %LSET LISTEXP='1'B;
 4067      %LSET LISTCOM='0'B;
 4068      %LSET LISTSUB='1'B;
 4069      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 4070      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          111  
 4071      %LSET INIT=CHARTEXT(' INIT');
 4072      %LSET EINIT=CHARTEXT('');
 4073      %ELSE;
 4074      %LSET INIT=CHARTEXT('/*');
 4075      %LSET EINIT=CHARTEXT('*/');
 4076      %ENDIF;
 4077
 4078      DCL 1 FPTN STCLASS ALGN,
 4079      %IF TEXTCHAR(VECTORS)='YES';
 4080            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 4081            2 V,
 4082      %LSET LVL=3;
 4083      %ELSE;
 4084      %LSET LVL=2;
 4085      %ENDIF;
 4086              %(LVL) %CHARTEXT('PROG BIT(1)') %INIT(PROG)%EINIT,
 4087                          /*K* PROG = {YES|NO}   specifies, if YES, that
 4088                          the currently running program is to be made unshared.
 4089                          Default is NO.
 4090                          */
 4091              %(LVL) %CHARTEXT('SLIB BIT(1)') %INIT(SLIB)%EINIT,
 4092                          /*K* SLIB = {YES|NO}   specifies, if YES, that
 4093                          the currently associated run time library is to
 4094                          be made unshared.  Default is NO.
 4095                          */
 4096              %(LVL) * BIT(14) %INIT('0'B)%EINIT;
 4097      %MEND;
 4098
 4099
 4100
 4101                          /*F* NAME: M$TIME - Return Time and Date
 4102
 4103                          The M$TIME service returns date and time
 4104                          information, obtained from one of several possible
 4105                          sources, in several optional formats. The source
 4106                          of the date and time may be an input from the
 4107                          calling program or the current system elapsed time
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          112  
 4108                          clock. The output format options include three
 4109                          character string formats and two binary formats.
 4110
 4111                          One of the possible source and output formats is
 4112                          the LCP6 Universal Time Stamp (UTS), which is a 32
 4113                          bit value indicating the elapsed time since
 4114                          a base date and time, in units of .133 second.
 4115                          UTS data is used throughout the LCP6 system as the standard
 4116                          notation for time.
 4117
 4118                          The M$TIME service takes the alternate return if the
 4119                          source date is prior to January 1, 1978. (Dates prior
 4120                          to that time can occur when processing data from other
 4121                          systems and cannot be converted to UTS).
 4122                          The form of the call for this service is as follows:
 4123
 4124                          CALL M$TIME (FPT_TIME) [ALTRET (label)];
 4125
 4126                          The parameters for M$TIME are:                                                */
 4127       %MACRO FPT_TIME
 4128                 (FPTN=FPT_TIME,
 4129                  STCLASS=STATIC,
 4130                  ALGN=WALIGNED,
 4131                  VECTORS=YES,
 4132                  SOURCE(CLOCK=0,ANS=2,LOCAL=3,UTS=4,TUN=5)=0,
 4133                  DEST(EXT=1,ANS=2,LOCAL=3,UTS=4,TUN=5)=1,
 4134                  DATE=NIL,
 4135                  TIME=NIL,
 4136                  DAY=NIL,
 4137                  TSTAMP=NIL);
 4138
 4139       %LSET LISTDIR='0'B;
 4140       %LSET LISTEXP='1'B;
 4141       %LSET LISTCOM='0'B;
 4142       %LSET LISTSUB='1'B;
 4143       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4144       %IF (SUBSTR(STR,0,6)='STATIC') OR
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          113  
 4145       (SUBSTR(STR,0,8)='CONSTANT') OR
 4146       (SUBSTR(STR,0,3)='EXT');
 4147       %LSET INIT=CHARTEXT('INIT');
 4148       %LSET EINIT=CHARTEXT('');
 4149       %ELSE;
 4150       %LSET INIT=CHARTEXT('/*');
 4151       %LSET EINIT=CHARTEXT('*/');
 4152       %ENDIF;
 4153
 4154      DCL 1 FPTN STCLASS ALGN,
 4155
 4156      %IF TEXTCHAR(VECTORS)='YES';
 4157
 4158      %LSET LVL=3;
 4159            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 4160            2 %CHARTEXT('DATE_') VECTOR %INIT(VECTOR(DATE))%EINIT,
 4161                          /*K* DATE = VARIABLE specifies a character string
 4162                          buffer to contain the month, day and year. The
 4163                          size must be that shown in the table for the
 4164                          selected DEST format and must correctly describe
 4165                          the input character string when used with the
 4166                          SOURCE=LOCAL or SOURCE=ANS option.  The default is NIL.
 4167                          */
 4168
 4169            2 %CHARTEXT('TIME_') VECTOR %INIT(VECTOR(TIME))%EINIT,
 4170                          /*K* TIME = VARIABLE specifies a character string
 4171                          buffer to contain the time of day.  The size must
 4172                          be that shown in the table for the selected
 4173                          DEST format and must correctly describe the input
 4174                          character string when used with the SOURCE=LOCAL
 4175                          or SOURCE=ANS option.  The default is NIL.
 4176                          */
 4177
 4178            2 %CHARTEXT('DAY_') VECTOR %INIT(VECTOR(DAY))%EINIT,
 4179                          /*K* DAY = VARIABLE specifies a character string
 4180                          buffer for the day of the week for LOCAL or EXT format
 4181                          or the Julian date for ANS format outputs. The size
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          114  
 4182                          must be that shown in the table for the selected
 4183                          format. The default is NIL.                                                   */
 4184            2 %CHARTEXT('TSTAMP_') VECTOR %INIT(VECTOR(TSTAMP))%EINIT,
 4185                          /*K* TSTAMP = VARIABLE specifies a two word buffer to
 4186                          contain either a UTS or milliseconds since
 4187                          midnight when LOCAL, EXT, UTS or TUN is specified for
 4188                          DEST.  TSTAMP specifies a one word variable to contain
 4189                          the number of the day of the week when ANS is specified
 4190                          for DEST.  The days of the week are numbered beginning
 4191                          with Monday=1, Tuesday=2, ... Sunday=7.                                       */
 4192
 4193
 4194            2 V,
 4195      %ELSE;
 4196      %LSET LVL=2;
 4197
 4198      %ENDIF;
 4199              %LVL %CHARTEXT('SOURCE') UBIN(8) UNAL %INIT(SOURCE)%EINIT,
 4200                          /*K* SOURCE = OPTION  indicates the source of the
 4201                          date and time.  The options are as follows:
 4202
 4203                          .INL +9
 4204                          .UNL 9
 4205                          CLOCK    specifies that the current date and
 4206                                   time, obtained from the system
 4207                                   elapsed time clock, are to be returned.
 4208
 4209                          .UNL 9
 4210                          UTS      specifies that the date and time are to
 4211                                   be calculated from an input UTS
 4212                                   value found in the TSTAMP buffer.
 4213
 4214                          .UNL 9
 4215                          LOCAL    specifies that the date and time are to
 4216                                   be calculated from input character
 4217                                   string data found in the DATE and TIME
 4218                                   buffers. Input data must be in the LOCAL
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          115  
 4219                                   format described in the table above.
 4220                                   (Note that leading zeros may be omitted
 4221                                   from any field and the seconds or
 4222                                   hundredths of seconds fields may be
 4223                                   omitted, in which case zero is assumed).
 4224                                   The exact length of the string must be
 4225                                   reflected in TIME_.BOUND.  Output data
 4226                                   will be stored into the DATE and TIME buffers
 4227                          if the EXT, ANS, or LOCAL options are specified for DEST.
 4228
 4229                          .UNL 9
 4230                          ANS      specifies that the date and time are to
 4231                          be calculated from input character
 4232                          string data found in the DATE and
 4233                          TIME buffers. Input data must be in the
 4234                          ANS format described in the table above except
 4235                          that TIME is optional and defaults to zero.
 4236                          Output data will be stored into the DATE
 4237                          and TIME buffers if the EXT, ANS, or
 4238                          LOCAL options are specified for DEST.
 4239
 4240                          .UNL 9
 4241                          TUN      specifies that the input for time is a
 4242                          binary value of milliseconds since
 4243                          midnight to be found in the TSTAMP
 4244                          buffer.  Date is to be the current date.
 4245                          .INL -9
 4246
 4247
 4248                          The default is CLOCK.
 4249                          */
 4250                %LVL %CHARTEXT('DEST') UBIN(8) UNAL %INIT(DEST)%EINIT;
 4251                          /*K* DEST = OPTION   specifies the format of
 4252                          the results of the
 4253                          M$TIME service. The table below illustrates the
 4254                          formats and gives the size, in characters, of the
 4255                          buffer. Results are not returned if a buffer is
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          116  
 4256                          not specified. If TSTAMP is present, a UTS will be
 4257                          returned in the specified double word buffer if the
 4258                          LOCAL or EXT option is specified.  If the ANS option
 4259                          is specified, a day of week value will be
 4260                          returned in a one word buffer specified by TSTAMP.
 4261                          The default for DEST is EXT.
 4262
 4263                          EXT, ANS, LOCAL   are described in the following
 4264                          table.
 4265
 4266                          .brn 11
 4267                          TU
 4268                          OPTION  BUFFER  SIZE  FORMAT         EXAMPLE
 4269
 4270                          EXT     DATE     10   'MON DD ''YY'  DEC 31 '77
 4271                                  TIME     11   'HH:MM:SS.SS'  23:59:59.99
 4272                                  DAY       3   'DAY'          SUN
 4273                          LOCAL   DATE      8   'MM/DD/YY'     12/31/77
 4274                                  TIME     11   'HH:MM:SS.SS'  23:59:59.99
 4275                                  DAY       3   'DAY'          SUN
 4276                          ANS     DATE      6   'YYMMDD'       771231
 4277                                  TIME      8   'HHMMSSSS'     23595999
 4278                                  DAY       5   'YYDDD'        80366
 4279                          TF
 4280
 4281                          UTS   specifies that a UTS is to be computed
 4282                          from the specified input and returned in the
 4283                          TSTAMP buffer.
 4284
 4285                          TUN    specifies that the timer since midnight,
 4286                          in milliseconds, is to be computed from the
 4287                          specified input and returned in the TSTAMP buffer.                            */
 4288       %MEND;
 4289
 4290
 4291
 4292
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          117  
 4293
 4294
 4295                          /*F* NAME: M$CHGUNIT - Increment Unit Counter.
 4296
 4297                          The M$CHGUNIT service permits the user to
 4298                          increment any of eight counters, four 16-bit
 4299                          counters in G$JIT.JOBUNIT and four 16-bit counters
 4300                          in G$JIT.STEPUNIT.
 4301
 4302                          If a counter overflows, it is set to the maximum
 4303                          value; the alternate return is then taken
 4304                          with the severity code set to 0.
 4305
 4306                          If any STEPUNIT counter is incremented during the
 4307                          course of a job step, an LCP-6 step accounting record
 4308                          will be written to the :ACCTLG.:SYS file when the
 4309                          job step is terminated.  The values of the JOBUNIT
 4310                          counters will be reflected in the LCP-6 job end
 4311                          accounting record in the :ACCTLG file.
 4312
 4313                          The form of the call for this service is:
 4314
 4315                          CALL M$CHGUNIT (FPT_CHGUNIT) [ALTRET (label)];
 4316
 4317                          The parameters for the M$CHGUNIT service are as
 4318                          follows:
 4319                          */
 4320
 4321
 4322
 4323      %MACRO FPT_CHGUNIT
 4324              (FPTN=FPT_CHGUNIT,
 4325              STEP(YES='1'B,NO='0'B)='1'B,
 4326              UNIT0=0,UNIT1=0,UNIT2=0,UNIT3=0,
 4327              VECTORS=YES,
 4328              STCLASS=STATIC);
 4329
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          118  
 4330      %LSET LISTDIR='0'B;
 4331      %LSET LISTEXP='1'B;
 4332      %LSET LISTCOM='0'B;
 4333      %LSET LISTSUB='1'B;
 4334      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 4335      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 4336      %LSET INIT=CHARTEXT(' INIT');
 4337      %LSET EINIT=CHARTEXT('');
 4338      %ELSE;
 4339      %LSET INIT=CHARTEXT('/*');
 4340      %LSET EINIT=CHARTEXT('*/');
 4341      %ENDIF;
 4342
 4343      DCL 1 FPTN STCLASS DALIGNED,
 4344      %IF TEXTCHAR(VECTORS)='YES';
 4345            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 4346            2 V,
 4347      %LSET LVL=3;
 4348      %ELSE;
 4349      %LSET LVL=2;
 4350      %ENDIF;
 4351              %(LVL) %CHARTEXT('STEP ') BIT(1) %INIT(STEP)%EINIT,
 4352                          /*K* STEP = {YES|NO} specifies, if yes, that the step
 4353                          counter(s) are to be incremented. NO specifies
 4354                          that the job counter(s) are not to be incremented.
 4355                          Default=YES.
 4356                          */
 4357              %(LVL) * BIT(15) %INIT('0'B)%EINIT,
 4358              %(LVL) %CHARTEXT('UNIT0 ') UBIN UNAL %INIT(UNIT0)%EINIT,
 4359                          /*K* UNIT0 = VALUE-DEC(0 to 2**16-1)   specifies the
 4360                          value by which to increment the first 16-bit
 4361                          counter.  Default=0.
 4362                          */
 4363              %(LVL) %CHARTEXT('UNIT1 ') UBIN UNAL %INIT(UNIT1)%EINIT,
 4364                          /*K* UNIT1 = VALUE-DEC(0 to 2**16-1)   specifies the
 4365                          value by which to increment the second 16-bit
 4366                          counter. Default=0.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          119  
 4367                          */
 4368              %(LVL) %CHARTEXT('UNIT2 ') UBIN UNAL %INIT(UNIT2)%EINIT,
 4369                          /*K* UNIT2 = VALUE-DEC(0 to 2**16-1) specifies the
 4370                          value by which to increment the third 16-bit
 4371                          counter. Default=0.
 4372                          */
 4373              %(LVL) %CHARTEXT('UNIT3 ') UBIN UNAL %INIT(UNIT3)%EINIT;
 4374                          /*K* UNIT3 = VALUE-DEC(0 to 2**16-1)   specifies the
 4375                          value by which to increment the fourth 16-bit
 4376                          counter. Default=0.
 4377                          */
 4378      %MEND;
 4379
 4380                          /*F* NAME: M$RUE - Report User Event.
 4381
 4382                          The M$RUE service is for use
 4383                          by system processors to report execution scheduler
 4384                          events on a specified user.
 4385
 4386                          The form of the call for this service is:
 4387
 4388                          CALL M$RUE(FPT_RUE) [ALTRET (label)];
 4389
 4390                          The parameters for the M$RUE service are as follows:
 4391                          */
 4392       %MACRO FPT_RUE(FPTN=FPT_RUE,
 4393                    STCLASS=STATIC,
 4394                    VECTORS=YES,
 4395                    USER=0,
 4396                    EVENT=0);
 4397
 4398       %LSET LISTDIR='0'B;
 4399       %LSET LISTEXP='1'B;
 4400       %LSET LISTCOM='0'B;
 4401       %LSET LISTSUB='1'B;
 4402      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 4403      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          120  
 4404      %LSET INIT=CHARTEXT(' INIT');
 4405      %LSET EINIT=CHARTEXT('');
 4406      %ELSE;
 4407      %LSET INIT=CHARTEXT('/*');
 4408      %LSET EINIT=CHARTEXT('*/');
 4409      %ENDIF;
 4410
 4411      DCL 1 FPTN STCLASS DALIGNED,
 4412      %IF TEXTCHAR(VECTORS)='YES';
 4413            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 4414            2 V,
 4415      %LSET LVL=3;
 4416      %ELSE;
 4417      %LSET LVL=2;
 4418      %ENDIF;
 4419              %(LVL) %CHARTEXT('USER ') UBIN UNAL %INIT(USER)%EINIT,
 4420                          /*K* USER = VALUE-DEC(1-64K) specifies the SYSID
 4421                          of a user on whom the event is reported.
 4422                          */
 4423              %(LVL) %CHARTEXT('EVENT ') UBIN(8) UNAL %INIT(EVENT)%EINIT,
 4424                          /*K* EVENT = VALUE-DEC(1-255) specifies an execution
 4425                          scheduler event number.
 4426                          */
 4427               %(LVL) * UBIN BYTE UNAL %INIT(0)%EINIT;
 4428       %MEND;
 4429
 4430
 4431
 4432
 4433                          /*P* NAME: GU_MCL_E.
 4434
 4435                          The GU_MCL_E macro generates the specific values
 4436                          for the individual monitor service requests within
 4437                          the GU Functional Code Group.
 4438                          */
 4439
 4440      %MACRO GU_MCL_E;
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          121  
 4441      %EQU G_MCL_EVENT# = %G_FCG_U#*64 + 0;
 4442      %EQU G_MCL_INT# = %G_FCG_U#*64 + 1;
 4443      %EQU G_MCL_XCON# = %G_FCG_U#*64 + 2;
 4444      %EQU G_MCL_TRAP# = %G_FCG_U#*64 + 3;
 4445      %EQU G_MCL_DBCONTROL# = %G_FCG_U#*64 +4;
 4446      %EQU G_MCL_WAIT# = %G_FCG_U#*64 + 5;
 4447      %EQU G_MCL_CLOCK# = %G_FCG_U#*64 + 6;
 4448      %EQU G_MCL_MAKEUSR# = %G_FCG_U#*64 + 7;
 4449      %EQU G_MCL_SENV# = %G_FCG_U#*64 +8;
 4450      %EQU G_MCL_MERC# = %G_FCG_U#*64 +9;
 4451      %EQU G_MCL_RETRY# = %G_FCG_U#*64 +10;
 4452      %EQU G_MCL_RENV# = %G_FCG_U#*64 +11;
 4453      %EQU G_MCL_TRTN# = %G_FCG_U#*64 +12;
 4454      %EQU G_MCL_CLRSTK# = %G_FCG_U#*64 +13;
 4455      %EQU G_MCL_MERCS# = %G_FCG_U#*64 +14;
 4456      %EQU G_MCL_RETRYS# = %G_FCG_U#*64 +15;
 4457      %EQU G_MCL_SPRIV# = %G_FCG_U#*64 +16;
 4458      %EQU G_MCL_AFD#   = %G_FCG_U#*64 +17;
 4459      %EQU G_MCL_DRTN#  = %G_FCG_U#*64 +18;
 4460      %EQU G_MCL_UNSHARE#  = %G_FCG_U#*64 +19;
 4461      %EQU G_MCL_TIME# = %G_FCG_U#*64 +20;
 4462      %EQU G_MCL_CHGUNIT# = %G_FCG_U#*64 +21;
 4463      %EQU G_MCL_ERRMSG# = %G_FCG_U#*64 +22;
 4464      %EQU G_MCL_RUE# = %G_FCG_U#*64 + 23;
 4465      %MEND;
 4466
 4467
 4468
 4469
 4470
 4471                          /*P* NAME: GU$ENTS.
 4472
 4473                          The GU$ENTS macro generates the ENTRY declarations
 4474                          for the Monitor Services belonging to the GU
 4475                          Functional Code Group.
 4476                          */
 4477
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          122  
 4478      %MACRO GU$ENTS;
 4479      DCL M$EVENT ENTRY(1) CONV(1,2,%G_MCL_EVENT#) ALTRET;
 4480      DCL M$INT ENTRY(1) CONV(1,2,%G_MCL_INT#) ALTRET;
 4481      DCL M$XCON ENTRY(1) CONV(1,2,%G_MCL_XCON#) ALTRET;
 4482      DCL M$TRAP ENTRY(1) CONV(1,2,%G_MCL_TRAP#) ALTRET;
 4483      DCL M$DBCONTROL ENTRY(1) CONV(1,2,%G_MCL_DBCONTROL#) ALTRET;
 4484      DCL M$WAIT ENTRY(1) CONV(1,3,%G_MCL_WAIT#) ALTRET;
 4485      DCL M$CLOCK ENTRY(1) CONV(1,2,%G_MCL_CLOCK#) ALTRET;
 4486      DCL M$MAKEUSR ENTRY(1) CONV(1,1,%G_MCL_MAKEUSR#) ALTRET;
 4487      DCL M$SENV ENTRY CONV(1,0,%G_MCL_SENV#) ALTRET;
 4488      DCL M$MERC ENTRY(1) CONV(1,1,%G_MCL_MERC#) ALTRET;
 4489      DCL M$RETRY ENTRY(1) CONV(1,1,%G_MCL_RETRY#) ALTRET;
 4490      DCL M$RENV ENTRY CONV(1,0,%G_MCL_RENV#) ALTRET;
 4491      DCL M$TRTN ENTRY(1) CONV(1,2,%G_MCL_TRTN#) ALTRET;
 4492      DCL M$CLRSTK ENTRY(1) CONV(1,1,%G_MCL_CLRSTK#) ALTRET;
 4493      DCL M$MERCS ENTRY(1) CONV(1,1,%G_MCL_MERCS#) ALTRET;
 4494      DCL M$RETRYS ENTRY(1) CONV(1,1,%G_MCL_RETRYS#) ALTRET;
 4495      DCL M$SPRIV ENTRY(1) CONV(1,3,%G_MCL_SPRIV#) ALTRET;
 4496      DCL M$AFD ENTRY(1) CONV(1,1,%G_MCL_AFD#) ALTRET;
 4497      DCL M$DRTN ENTRY(1) CONV(1,1,%G_MCL_DRTN#) ALTRET;
 4498      DCL M$UNSHARE ENTRY(1) CONV(1,1,%G_MCL_UNSHARE#) ALTRET;
 4499      DCL M$TIME ENTRY(1) CONV(1,5,%G_MCL_TIME#) ALTRET;
 4500      DCL M$CHGUNIT ENTRY(1) CONV(1,1,%G_MCL_CHGUNIT#) ALTRET;
 4501      DCL M$ERRMSG ENTRY(1) CONV(1,11,%G_MCL_ERRMSG#) ALTRET;
 4502      DCL M$RUE ENTRY(1) CONV(1,1,%G_MCL_RUE#) ALTRET;
 4503      %MEND;
 4504
 4505
 4506
 4507
 4508
 4509                          /*P* NAME: GU_FPTS.
 4510
 4511                          The GU_FPTS macro provides the LCL-6 monitor services
 4512                          decoder with the information required to build the
 4513                          segment descriptors and pointers for each FPT within
 4514                          the GU Functional Code Group.
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          123  
 4515                          */
 4516
 4517      %MACRO GU_FPTS (FPTN=GU_FPTS);
 4518
 4519      /* Generate the FCG_GU header word */
 4520      %GUD_FCG_INFO (FPTN=FPTN,C=%G_MCL_RUE#);
 4521
 4522      /* Generate data for FPT_EVENT   */
 4523      %GUD_MCL_INFO (C=%G_MCL_EVENT#,V=2,HAND=GUE$MCL);
 4524      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4525      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=3);
 4526
 4527      /* Generate data for FPT_INT   */
 4528      %GUD_MCL_INFO (C=%G_MCL_INT#,V=2,HAND=GUE$MCL);
 4529      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4530      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=3);
 4531
 4532      /* Generate data for FPT_XCON   */
 4533      %GUD_MCL_INFO (C=%G_MCL_XCON#,V=2,HAND=GUE$MCL);
 4534      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4535      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=3);
 4536
 4537      /* Generate the data for FPT_TRAP   */
 4538      %GUD_MCL_INFO (C=%G_MCL_TRAP#,V=2,HAND=GUE$MCL);
 4539      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=23);
 4540      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=23);
 4541
 4542      /* Generate the data for FPT_DBCONTROL   */
 4543      %GUD_MCL_INFO (C=%G_MCL_DBCONTROL#,V=2,HAND=GUE$MCL);
 4544      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4545      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=3);
 4546
 4547      /* Generate the data for FPT_WAIT   */
 4548      %GUD_MCL_INFO (C=%G_MCL_WAIT#,V=3,HAND=GUS$WAIT);
 4549      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1); /*V_*/
 4550      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1); /*UNITS_*/
 4551      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=1); /*UETIME_*/
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          124  
 4552
 4553      /* Generate the data for FPT_CLOCK   */
 4554      %GUD_MCL_INFO (C=%G_MCL_CLOCK#,V=2,HAND=GUS$CLOCK);
 4555      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4556      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4557
 4558      /* Generate data for M$MAKEUSR   */
 4559      %GUD_MCL_INFO (C=%G_MCL_MAKEUSR#,V=1,HAND=GUS$MAKEUSR);
 4560      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4561
 4562      /* Generate data for FPT_SENV   */
 4563      %GUD_MCL_INFO (C=%G_MCL_SENV#,V=0,HAND=GUE$MCL);
 4564
 4565      /* Generate data for FPT_RENV   */
 4566      %GUD_MCL_INFO (C=%G_MCL_RENV#,V=0,HAND=GUE$MCL);
 4567
 4568      /* Generate data for FPT_TRTN   */
 4569      %GUD_MCL_INFO (C=%G_MCL_TRTN#,V=2,HAND=GUE$MCL);
 4570      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=67);
 4571      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4572
 4573      /* Generate data for FPT_CLRSTK   */
 4574      %GUD_MCL_INFO (C=%G_MCL_CLRSTK#,V=1,HAND=GUE$MCL);
 4575      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4576
 4577      /* Generate data for FPT_MERC   */
 4578      %GUD_MCL_INFO (C=%G_MCL_MERC#,V=1,HAND=GUE$MCL);
 4579      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4580
 4581      /* Generate data for FPT_MERCS   */
 4582      %GUD_MCL_INFO (C=%G_MCL_MERCS#,V=1,HAND=GUE$MCL);
 4583      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4584
 4585      /* Generate data for FPT_RETRY   */
 4586      %GUD_MCL_INFO (C=%G_MCL_RETRY#,V=1,HAND=GUE$MCL);
 4587      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=5);
 4588
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          125  
 4589      /* Generate data for FPT_RETRYS   */
 4590      %GUD_MCL_INFO (C=%G_MCL_RETRYS#,V=1,HAND=GUE$MCL);
 4591      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=5);
 4592
 4593      /* Generate data for FPT_SPRIV */
 4594      %GUD_MCL_INFO (C=%G_MCL_SPRIV#,V=3,HAND=GUM$SPRIV);
 4595      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4596      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=3);
 4597      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3);
 4598
 4599      /* Generate data for FPT_AFD */
 4600      %GUD_MCL_INFO (C=%G_MCL_AFD#,V=1,HAND=GUM$AFD);
 4601      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4602
 4603      /* Generate data for FPT_DRTN */
 4604      %GUD_MCL_INFO (C=%G_MCL_DRTN#,V=1,HAND=GUM$DRTN);
 4605      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=3);
 4606
 4607      /* Generate data for FPT_UNSHARE */
 4608      %GUD_MCL_INFO (C=%G_MCL_UNSHARE#,V=1,HAND=GUM$UNSHARE);
 4609      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4610
 4611      /* Generate data for FPT_TIME */
 4612      %GUD_MCL_INFO (C=%G_MCL_TIME#,V=5,HAND=GUS$TIME);
 4613      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=1);
 4614      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=YES,BND=5);
 4615      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=YES,BND=2);
 4616      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=YES,BND=2);
 4617      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=YES,BND=1);
 4618
 4619      /* Generate data for FPT_CHGUNIT */
 4620      %GUD_MCL_INFO (C=%G_MCL_CHGUNIT#,V=1,HAND=GUM$CHGUNIT);
 4621      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=9);
 4622
 4623      /* Generate data for FPT_ERRMSG */
 4624      %GUD_MCL_INFO (C=%G_MCL_ERRMSG#,V=11,HAND=GUM$ERRMSG);
 4625      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=3); /*V_*/
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          126  
 4626      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3); /*CODE_*/
 4627      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=12); /*BUF_*/
 4628      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=1); /*FILENAME_*/
 4629      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7); /*FILEACCT_*/
 4630      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=7); /*FILEPASS_*/
 4631      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=NO,BND=1); /*FIELD1_*/
 4632      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=NO,BND=1); /*FIELD2_*/
 4633      %GUD_VECT_INFO (MAND=NO,ALIGN=BY,WRT=NO,BND=1); /*FIELD3_*/
 4634      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=1); /*RESULTS_*/
 4635      %GUD_VECT_INFO (MAND=NO,ALIGN=WD,WRT=NO,BND=3); /*ALTCODE_*/
 4636      /* Generate data for FPT_RUE */
 4637      %GUD_MCL_INFO (C=%G_MCL_RUE#,V=1,HAND=GUS$RUE);
 4638      %GUD_VECT_INFO (MAND=YES,ALIGN=WD,WRT=NO,BND=3); /* V_*/
 4639
 4640      %MEND;
 4641
 4642
 4643
 4644
 4645
 4646                          /*P* NAME: GU$HANDLERS.
 4647
 4648                          The GU$HANDLERS macro generates the ENTRY declarations
 4649                          for the GU MCL handlers.
 4650                          */
 4651
 4652      %MACRO GU$HANDLERS;
 4653      DCL GUE$MCL ENTRY(1);
 4654      DCL GUM$DRTN ENTRY(1);
 4655      DCL GUM$SPRIV ENTRY(1);
 4656      DCL GUM$UNSHARE ENTRY(1);
 4657      DCL GUS$RUE ENTRY(1);
 4658      DCL GUS$TIME ENTRY(1);
 4659      DCL GUS$WAIT ENTRY(1);
 4660      DCL GUS$CLOCK ENTRY(1);
 4661      DCL GUS$MAKEUSR ENTRY(1);
 4662      DCL GUM$AFD ENTRY(1);
14:36 JUL 28 '97 GU_LCP6_M.:E05SI                                          127  
 4663      DCL GUM$CHGUNIT ENTRY(1);
 4664      DCL GUM$ERRMSG ENTRY(1);
 4665      %MEND;

