/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
CMPR: PROC MAIN  ALTRET;
 
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;
  %CODE03;
%INCLUDE XS_MACRO_C;
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
 
%SUB NEW# = 1;
%SUB OLD# = 0;
 
%EQU LNH# = 1;
%EQU LNL# = 2;
%EQU PLLF = 21;
 
%SUB BLK1_NSUBLKS = "BLK1$->P_OUT.NSUBLKS";
%SUB BLK1_SUBLK$  = "BLK1$->P_OUT.SUBLK$";
 
%SUB BLK2_NSUBLKS = "BLK2$->P_OUT.NSUBLKS";
%SUB BLK2_SUBLK$  = "BLK2$->P_OUT.SUBLK$";
%SUB BLK2_CODE    = "BLK2$->P_SYM.CODE";
%SUB BLK2_COUNT   = "BLK2$->P_SYM.COUNT";
%SUB BLK2_TEXT    = "SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)";
 
%SUB BLK3_NSUBLKS = "BLK3$->P_OUT.NSUBLKS";
%SUB BLK3_SUBLK$  = "BLK3$->P_OUT.SUBLK$";
%SUB BLK3_CODE    = "BLK3$->P_SYM.CODE";
%SUB BLK3_COUNT   = "BLK3$->P_SYM.COUNT";
%SUB BLK3_TEXT    = "SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)";
%EJECT;
%LIST;
%INCLUDE CMPR_C61;
%PLIST;
%EJECT;
/************************\
*                        *
*   F$OLD & F$NEW FPTs   *
*                        *
\************************/
 
%FPT_OPEN    (FPTN                     = OPENF );
 
%FPT_OPEN    (FPTN                     = MERGE_NEW,
              ASN=FILE,
              DCB=F$NEW,
           /* NAME=F$OLD$->F$DCB.NAME#, is done dynamically in START_UP */
              SETDCB=YES );
%FPT_OPEN    (FPTN                     = MERGE_OLD,
              ASN=FILE,
              DCB=F$OLD,
              SETDCB=YES );
%FPT_READ    (FPTN                     = READF,
              KEY=KEY,
              KEYR=YES);
%FPT_WRITE   (FPTN                     = WRITEF );
%FPT_DEVICE  (FPTN                     = DEVICEF );
%FPT_CLOSE   (FPTN                     = CLOSEF,
              DISP=SAVE);
%FPT_UNFID   (FPTN                     = UNFID_OLD,
              DCB=F$OLD,
              LEN=OLD_FID_LEN,
              TEXTFID=OLD_TEXTFID );
%FPT_UNFID   (FPTN                     = UNFID_NEW,
              DCB=F$NEW,
              LEN=NEW_FID_LEN,
              TEXTFID=NEW_TEXTFID );
%FPT_UNFID   (FPTN                     = UNFID_UPD,
              DCB=F$UPD,
              LEN=UPD_FID_LEN,
              TEXTFID=UPD_TEXTFID );
%EJECT;
/******************\
*                  *
*    F$UPD FPTs    *
*                  *
\******************/
 
%FPT_OPEN    (FPTN                     = OPEN_UPD,
              DCB=F$UPD,
              FUN=CREATE );
 
%FPT_OPEN    (FPTN                     = MERGE_UPD,
              ASN=FILE,
              DCB=F$UPD,
           /* NAME=F$OLD$->F$DCB.NAME#, is done dynamically in START_UP */
              SETDCB=YES );
 
%FPT_WRITE   (FPTN                     = WRITE_UPD,
              DCB=F$UPD );
 
/*****************\
*                 *
*    M$LO FPTs    *
*                 *
\*****************/
 
%FPT_OPEN    (FPTN                     = MERGE_LO,
              ASN=FILE,
              DCB=M$LO,
              SETDCB=YES );
%FPT_OPEN    (FPTN                     = OPEN_LO,
              DCB=M$LO,
              FUN=CREATE,
              ORG=UR );
%FPT_OPEN    (FPTN                     = OPEN_LO_TO_ME,
              ASN=DEVICE,
              DCB=M$LO,
              RES='ME  ');
%FPT_DEVICE  (FPTN                     = NEW_TITLE,
              DCB=M$LO,
              HDR=VLP_HDR );
%FPT_DEVICE  (FPTN                     = NEW_LO_PAGE,
              DCB=M$LO,
              HDR=USR_HDR,
              PAGE=YES );
%VLP_HDR     (FPTN                     = VLP_HDR,
              HEADERHEIGHT=2,
              LEN=132 );
DCL 1 USR_HDR REDEF VLP_HDR,
      2 *                    UBIN(8)   UNAL,
      2 RESETPAGE#           BIT(1),
      2 *                    UBIN(5)   UNAL,
      2 HEADERHEIGHT#        UBIN(4)   UNAL,
      2 IDENT#               UBIN(9)   UNAL,
      2 COUNT#               UBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 TITLE                CHAR(135);
%EJECT;
/*****************\
*                 *
*    M$ME FPTs    *
*                 *
\*****************/
 
%FPT_OPEN    (FPTN                     = OPEN_ME,
              ASN=DEVICE,
              DCB=M$ME,
              RES='ME  ');
%EJECT;
/**************************\
*                          *
*    MISCELLANEOUS FPTs    *
*                          *
\**************************/
 
%FPT_GDDL    (FPTN                     = FPT_GDDL,
              RESULTS=GDDL_RESULTS );
%VLP_GDDL    (FPTN                     = GDDL_RESULTS );
 
%FPT_GDP     (FPTN                     = GDP,
              RESULTS=GDP_ );
%VLP_VECTOR  (FPTN                     = GDP_ );
 
%FPT_GDS     (FPTN                     = GDS,
              RESULTS=GDS_ );
%VLP_VECTOR  (FPTN                     = GDS_ );
 
%FPT_FDP     (FPTN                     = FDP,
              RESULTS=FDP_ );
%VLP_VECTOR  (FPTN                     = FDP_ );
 
%FPT_FDS     (FPTN                     = FDS,
              RESULTS=FDS_ );
%VLP_VECTOR  (FPTN                     = FDS_ );
 
%FPT_ERRMSG  (FPTN                     = ERRMSG,
              DCB=NIL,
              BUF=ERR_MESG,
              CODE=ERRCODE,
              OUTDCB1=M$ME );
%VLP_ERRCODE (FPTN                     = ERRCODE );
 
%VLP_VECTOR  (FPTN                     = IO_ );
 
%VLP_VECTOR  (FPTN                     = PACK_ );
 
%VLP_VECTOR  (FPTN                     = STK_ );
 
%VLP_VECTOR  (FPTN                     = XSA_ );
 
%VLP_VECTOR  (FPTN                     = NEW_INT_BUF_ );
 
%VLP_VECTOR  (FPTN                     = OLD_INT_BUF_ );
 
%FPT_INT     (FPTN                     = BREAK_CNTRL,
              UENTRY=BREAK );
 
%FPT_EXIT    (FPTN                     = SET_STEPCC,
              STEPCC=OK );
 
%FPT_TIME    (FPTN                     = GET_TIME,
              DATE=TYME.DATE,
              DAY=TYME.DAY,
              DEST=EXT,
              SOURCE=CLOCK,
              TIME=TYME.TIME );
 
%FPT_CORRES  (FPTN                     = LOVSME,
              DCB1=M$LO,
              DCB2=M$ME );
 
%FPT_CMDVAR  (FPTN                     = GET_DEFAULTS,
              FUN=FETCH,
              NAME=CMDVAR_NAME );
%VLP_NAME    (FPTN                     = CMDVAR_NAME,
              NAME='CMPR_X_DEFAULTS' );
 
%VLP_NAME    (FPTN                     = BUILT_FID,
              LEN=31 );
 
%VLP_NAME    (FPTN                     = PRI_NAME,
              LEN=31 );
%EJECT;
/********************\
*                    *
*    PARSER STUFF    *
*                    *
\********************/
 
%P_PCB       (NAME                     = CMPR_OPTS,
              R=CMPR_NODES,
              W=WORK,
              WSZ="SIZEW(WORK)");
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS="BASED");
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS="BASED");
 
DCL BLK1$                    PTR;
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL CMPR_NODES               UBIN      SYMREF;
DCL WORK                     CHAR(1000)STATIC ALIGNED;
DCL X$PARSE                  ENTRY(1)  ALTRET;
%EJECT;
/***************\
*               *
*   FSF STUFF   *
*               *
\***************/
 
%XSA_PARAM   (FPTN                     = XSA_OLD );
%XSA_PARAM   (FPTN                     = XSA_NEW );
%XSA_PARAM   (FPTN                     = XSA_UPD );
 
DCL XSA$OPEN                           ENTRY(2) ALTRET;
DCL XSA$READ                           ENTRY(2) ALTRET;
DCL XSA$WRITE                          ENTRY(2) ALTRET;
DCL XSA$CLOSE                          ENTRY(2) ALTRET;
 
%EJECT;
%F_FDS       (NAME                     = F_FDS,
              STCLASS=STATIC,
              DCB=M$ME );
 
/**/
/* BASED */
/**/
DCL BUF                      CHAR(BUFSIZE)      BASED;
DCL FDS_BUF                  CHAR(ME_LEN)       BASED(ME_BUF$);
DCL FPARAM                   CHAR(4096)         BASED;
DCL ME_BUF                   CHAR(ME_LEN)       BASED(ME_BUF$);
DCL LO_BUF                   CHAR(LO_LEN)       BASED(LO_BUF$);
DCL NEW_INT_BUF              CHAR(4096)         BASED(NEW_INT_BUF_.PTR$);
DCL OLD_INT_BUF              CHAR(4096)         BASED(OLD_INT_BUF_.PTR$);
DCL 1 ENTREE                      BASED(ENTREE$),
      2 FILE                 UBIN(3)           UNAL,
      2 SIZ                  SBIN(33)          UNAL,
      2 REC                  CHAR(ENTREE.SIZ);
DCL 1 LINE(0:0)                   BASED(STK$)   ALIGNED,
      2 FLAG                 BIT(1)    UNAL,
      2 DEFERRED             BIT(1)    UNAL,
      2 BLK_CNT              UBIN(10)  UNAL,
      2 OLD_NUM              UBIN(12)  UNAL,
      2 NEW_NUM              UBIN(12)  UNAL;
 
 
/**/
/* BITs */
/**/
DCL DONE                     BIT(1)    STATIC INIT(%NO#);
DCL INT_BUF_NEEDED           BIT(1)    STATIC INIT(%NO#);
DCL ITS_FSF                  BIT(1)    STATIC INIT(%YES#);
DCL LO_IS_ME                 BIT(1)    STATIC INIT(%YES#);
DCL LO_IS_SET                BIT(1)    STATIC INIT(%NO#);
DCL QUIT_FLAG                BIT(1)    STATIC INIT(%NO#);
DCL STKDUMPFLG               BIT(1)    STATIC INIT(%NO#);
DCL UPD_IS_SET               BIT(1)    STATIC INIT(%NO#);
DCL VERIFYING_OPTIONS        BIT(1)    STATIC INIT(%NO#);
%EJECT;
DCL UPPERS(0:63) CONSTANT BIT(72) INIT(
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O);
%EJECT;
/**/
/* CHARacters, error messages */
/**/
DCL COM_ERR                  CHAR(0)   STATIC INIT(
    'COMMENT too long - Maximum is 130');
DCL COMPARE_ERR              CHAR(0)   STATIC INIT(
    'COMPARE LENGTH of zero makes no sense!');
DCL CRYSTAL_BALL             CHAR(0)   STATIC INIT(
  'My crystal ball isn''t working today!  Please specify files to be compared');
DCL HOLD_ERR                 CHAR(0)   STATIC INIT(
    'HOLD value must be greater than zero');
DCL MEM_ERR                  CHAR(0)   STATIC INIT(
    'MEMORY value must be greater than zero');
DCL SYNTAX                   CHAR(0)   STATIC INIT(
'!CMPR.X old-file,new-file {ON|TO|OVER|INTO} [updates] [,listing] [(options)]');
%EJECT;
/**/
/* CHARacters */
/**/
DCL COMMENT                  CHAR(130);
DCL DCBS(0:1)                CHAR(5)   STATIC INIT('F$OLD','F$NEW');
DCL ERR_MESG                 CHAR(120) STATIC;
DCL GREETING                 CHAR(0)   STATIC INIT('CMPR C00 here (2/24/87)');
DCL INT8                     CHAR(8);
DCL NAMES(0:1)               CHAR(3)   STATIC INIT('OLD','NEW');
DCL NEW_ACCT                 CHAR(9)   STATIC INIT('.');
DCL NEW_TEXTFID              CHAR(80)  STATIC;
DCL OLD_ACCT                 CHAR(9)   STATIC INIT('.');
DCL OLD_TEXTFID              CHAR(80)  STATIC;
DCL UPD_ACCT                 CHAR(9)   STATIC INIT('.');
DCL UPD_TEXTFID              CHAR(80)  STATIC;
%EJECT;
/**/
/* CHARacters, Formatter formats */
/**/
DCL FMTVEC                   CHAR(0)   STATIC INIT(
    ' ');
DCL FMTVEC1                  CHAR(0)   STATIC INIT(
    'Specified %A Block Size (%D) was too small so I used %D');
DCL FMTVEC2                  CHAR(0)   STATIC INIT(
    'Only %D of the requested %D pages of MEMORY were available');
DCL FMTVEC3                  CHAR(0)   STATIC INIT(
    'The %D records in %A and %A are IDENTICAL.');
DCL FMTVEC4                  CHAR(0)   STATIC INIT(
    '%A has %D, %A has %D and %A has %D records.');
DCL FMTVEC5                  CHAR(0)   STATIC INIT(
    '%A has %D and %A has %D records; %D updates were listed.');
DCL FMTVEC6                  CHAR(0)   STATIC INIT(
    '%A and %A both have no records.');
DCL FMTVEC7                  CHAR(0)   STATIC INIT(
    '%A and %A both have no records so %A now contains a +END');
DCL FMTVEC8                  CHAR(0)   STATIC INIT(
    '   Input buffer for %A was %D bytes; Longest record read was %D bytes.');
DCL FMTVEC9                  CHAR(0)   STATIC INIT(
    '   %D bytes of the %D byte (%DK) packing buffer were used.');
DCL FMTVEC10                 CHAR(0)   STATIC INIT(
    '   MINIMUM= %D');
DCL FMTVEC11                 CHAR(0)   STATIC INIT(
    '   %D memory overflow(s) occurred.');
DCL FMTVEC12                 CHAR(0)   STATIC INIT(
    '.. All %D %A record(s) read; %D processed; %D are in memory.');
DCL FMTVEC13                 CHAR(0)   STATIC INIT(
    '.. %D %A record(s) read; %D processed; %D are in memory.');
DCL FMTVEC14                 CHAR(0)   STATIC INIT(
    '.. All %D %A record(s) have been read and processed.');
DCL FMTVEC15                 CHAR(0)   STATIC INIT(
    '.. %D %A record(s) have been read and processed.');
DCL FMTVEC16                 CHAR(0)   STATIC INIT(
    ' ');
DCL FMTVEC17                 CHAR(0)   STATIC INIT(
    ' ');
%EJECT;
/**/
/* DCBs */
/**/
DCL F$OLD                    DCB;
DCL F$NEW                    DCB;
DCL F$UPD                    DCB;
DCL M$DO                     DCB;
DCL M$LO                     DCB;
DCL M$ME                     DCB;
 
 
/**/
/* ENTRYs */
/**/
DCL BREAK                    ENTRY     ASYNC;
DCL XSF$LOCCODT              ENTRY(2)  ALTRET;
DCL X$WRITE                  ENTRY(22);
%EJECT;
/**/
/* PTRs */
/**/
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL DES$                     PTR;
DCL ENTREE$                  PTR;
DCL F$OLD$                   PTR;
DCL F$NEW$                   PTR;
DCL F$UPD$                   PTR;
DCL FIT$                     PTR;
DCL LO_BUF$                  PTR;
DCL M$LO$                    PTR;
DCL M$ME$                    PTR;
DCL MBAS$                    PTR;
DCL ME_BUF$                  PTR;
DCL MEMH$                    PTR;
DCL MWAD$                    PTR;
DCL PACK_END$                PTR;
DCL R1$                      PTR;
DCL R2$                      PTR;
DCL R4$                      PTR;
DCL R5$                      PTR;
DCL R6$                      PTR;
DCL SRC$                     PTR;
DCL SVSW$                    PTR;
DCL STK$                     PTR;
DCL TSTK$                    PTR;
%EJECT;
/**/
/* SBINs */
/**/
DCL BEG                      SBIN;
DCL BROKEN                   SBIN      STATIC SYMDEF INIT(0);
DCL BUFSIZE                  SBIN;
DCL COMPRESS_BLANKS          SBIN;
DCL COMPRESS_LEADING         SBIN;
DCL BLOCK_SIZE(0:1)          SBIN      STATIC INIT(-1,-1);
DCL CODE                     SBIN;
DCL ERROR_CNT                SBIN      STATIC INIT(0);
DCL FDS_BUFSIZE              SBIN;
DCL FIRSTSW                  SBIN;
DCL HOLD                     SBIN      STATIC INIT(6);
DCL I                        SBIN;
DCL J                        SBIN;
DCL L                        SBIN;
DCL LBIAS                    SBIN;
DCL LDIFF                    SBIN      STATIC INIT(0);
DCL LEN                      SBIN;
DCL LO_LEN                   SBIN      STATIC INIT(132);
DCL LO_WIDTH                 SBIN;
DCL M$LO#                    SBIN      STATIC INIT(DCBNUM(M$LO));
DCL M$ME#                    SBIN      STATIC INIT(DCBNUM(M$ME));
DCL MAX_STK                  SBIN;
DCL ME_LEN                   SBIN      STATIC INIT(132);
DCL MEMORY                   SBIN      STATIC INIT(-1);
DCL NEW_FID_LEN              SBIN      STATIC;
DCL NEW_INT_ARS              SBIN;
DCL NUM_PLUS_CARDS           SBIN      STATIC INIT(0);
DCL NUM_UPDATE_RECS          SBIN      STATIC INIT(0);
DCL OLD_FID_LEN              SBIN      STATIC;
DCL OLD_INT_ARS              SBIN;
DCL OLNO                     SBIN      STATIC INIT(0);
DCL PASS                     SBIN;
DCL PLUS_CNT                 SBIN      STATIC INIT(0);
DCL R1                       SBIN;
DCL R2                       SBIN;
DCL R3                       SBIN;
DCL R4                       SBIN;
DCL R5                       SBIN;
DCL R6                       SBIN;
DCL R7                       SBIN;
DCL R8                       SBIN;
DCL R9                       SBIN;
DCL R10                      SBIN;
DCL R11                      SBIN;
DCL R12                      SBIN;
DCL R13                      SBIN;
DCL R14                      SBIN;
DCL R15                      SBIN;
DCL STKH                     SBIN      STATIC INIT(0);
DCL STKOVFC                  SBIN      STATIC INIT(0);
DCL STKP                     SBIN      STATIC INIT(0);
DCL TABLEVAL                 SBIN;
DCL TMP1                     SBIN;
DCL TMP2                     SBIN;
DCL TMP3                     SBIN;
DCL TMP4                     SBIN;
DCL TMP5                     SBIN;
DCL TMPCC                    SBIN;
DCL UPD_CNT                  SBIN      STATIC INIT(0);
DCL UPD_FID_LEN              SBIN      STATIC INIT(0);
DCL X                        SBIN;
%EJECT;
/**/
/* STRUCTURES */
/**/
DCL 1 KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 EDIT                 UBIN(27)  UNAL,
      2 EDITX REDEF EDIT     CHAR(3)   UNAL,
      2 *                    CHAR(252) UNAL;
 
DCL 1 SKIP_BLANKS  STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 BLANK                UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(95)  UNAL   INIT(' ');
 
DCL 1 SKIP_ZEROS  STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 ZERO                 UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(79)  UNAL   INIT(' ');
 
DCL 1 EDIT_KEYX  STATIC,
      2 L                    UBIN(9)   UNAL   INIT(0),
      2 XXX                  CHAR(3)   UNAL;
DCL EDIT_KEY REDEF EDIT_KEYX UBIN;
 
DCL 1 TMP,
      2 USER,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 DFLT,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 ALL,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 BUF                  CHAR(256) CALIGNED;
 
DCL 1 TYME  STATIC,
      2 *                    CHAR(4)   UNAL   INIT(' on '),
      2 DAY                  CHAR(4)   UNAL   INIT('    '),
      2 DAYU(0:3) REDEF DAY  UBIN(9)   UNAL,
      2 DATE                 CHAR(11)  UNAL   INIT(' '),
      2 DATEU(0:10) REDEF DATE UBIN(9) UNAL,
      2 *                    CHAR(3)   UNAL   INIT('at '),
      2 TIME                 CHAR(8)   UNAL   INIT(' ');
DCL DAY_DATE_TIME REDEF TYME CHAR(30);
%EJECT;
/**/
/* Option structures */
/**/
DCL OPTION_FLAGS             BIT(36)   STATIC INIT('0'B);
DCL OPT_FLAG(0:35) REDEF OPTION_FLAGS BIT(1);
DCL 1 OPT REDEF OPTION_FLAGS,
      2 *                    BIT(1)    UNAL,
      2 COMMENTS             BIT(1)    UNAL,  /*  1 */
      2 COMPRESS_BLANKS      BIT(1)    UNAL,  /*  2 */
      2 COMPRESS_LEADING     BIT(1)    UNAL,  /*  3 */
      2 COMPRESS_TRAILING    BIT(1)    UNAL,  /*  4 */
      2 DIFFERENCE           BIT(1)    UNAL,  /*  5 */
      2 DONT_COMPRESS_BLANKS BIT(1)    UNAL,  /*  6 */
      2 DONT_COMPRESS_LEADING BIT(1)   UNAL,  /*  7 */
      2 DONT_COMPRESS_TRAILING BIT(1)  UNAL,  /*  8 */
      2 DONT_IGNORE_BLANKS   BIT(1)    UNAL,  /*  9 */
      2 DONT_IGNORE_LEADING  BIT(1)    UNAL,  /* 10 */
      2 DONT_IGNORE_TRAILING BIT(1)    UNAL,  /* 11 */
      2 DONT_IGNORE_VFC      BIT(1)    UNAL,  /* 12 */
      2 DONT_LIST_DELETED    BIT(1)    UNAL,  /* 13 */
      2 HOLD                 BIT(1)    UNAL,  /* 14 */
      2 IGNORE_BLANKS        BIT(1)    UNAL,  /* 15 */
      2 IGNORE_LEADING       BIT(1)    UNAL,  /* 16 */
      2 IGNORE_TRAILING      BIT(1)    UNAL,  /* 17 */
      2 IGNORE_VFC           BIT(1)    UNAL,  /* 18 */
      2 LIST_DELETED         BIT(1)    UNAL,  /* 19 */
      2 NO_DEFAULTS          BIT(1)    UNAL,  /* 20 */
      2 NO_DIFFERENCE        BIT(1)    UNAL,  /* 21 */
      2 NO_PATCH             BIT(1)    UNAL,  /* 22 */
      2 NO_STATISTICS        BIT(1)    UNAL,  /* 23 */
      2 NO_UPPERCASE         BIT(1)    UNAL,  /* 24 */
      2 PATCH                BIT(1)    UNAL,  /* 25 */
      2 STATISTICS           BIT(1)    UNAL,  /* 26 */
      2 UPPERCASE            BIT(1)    UNAL,  /* 27 */
      2 *                    BIT(8)   UNAL;
%EJECT;
/**/
/* Control block */
/**/
DCL 1 IT(0:1)  STATIC,  /* 0=F$OLD, 1=F$NEW */
      2 DCB#                 UBIN,     /* DCB number                          */
      2 DCB$                 PTR,      /* PTR to DCB                          */
      2 LIN$                 PTR,      /* PTR to compare area                 */
      2 IBR                  SBIN,     /*                                     */
      2 KEY                  SBIN,     /* non-zero if EDIT keyed              */
      2 KEYX REDEF KEY       CHAR(4),
      2 LSZ                  SBIN,     /* Logical record length               */
      2 ARS                  SBIN,     /* Actual logical Record Size read     */
      2 ARST                 SBIN,/* Actual logical Record Size aftr compress */
      2 BSZ                  SBIN,     /* Max input block/record size         */
      2 ABS                  SBIN,     /* Actual BlockSize read               */
      2 BFA$                 PTR,      /* Input buffer address                */
      2 BFC$                 PTR,      /* Current deblocking pointer          */
      2 BFCT$                PTR, /* Current deblocking pointer to compressed */
      2 BFH$                 PTR,      /* End of current block PTR            */
      2 LNL                  UBIN,     /* Number of 1st line held in memory   */
      2 BAL$                 PTR,      /* PTR to 1st line held in memory      */
      2 LNH                  UBIN,     /* Number of last line read            */
      2 BAH$                 PTR,      /* PTR to last line in memory          */
      2 LNF                  UBIN,     /* Number of last line to be compared  */
      2 BAF$                 PTR,      /* PTR to last line to be compared     */
      2 BAF_FLAG             SBIN,
      2 FIT$                 PTR,      /* PTR to files FIT                    */
      2 MRS                  SBIN,     /* Maximum Record Size read            */
      2 ORG                  UBIN;     /* Files organization (F$DCB.ORG#)     */
%EJECT;
/**/
/* VECTORs */
/**/
DCL VEC1_                    BIT(72)   DALIGNED;
DCL VEC2_                    BIT(72)   DALIGNED;
DCL VEC3_                    BIT(72)   DALIGNED;
DCL VEC4_                    BIT(72)   DALIGNED;
DCL VEC5_                    BIT(72)   DALIGNED;
DCL VEC6_                    BIT(72)   DALIGNED;
DCL VEC7_                    BIT(72)   DALIGNED;
DCL VEC8_                    BIT(72)   DALIGNED;
DCL VEC9_                    BIT(72)   DALIGNED;
 
 
DCL FMTVEC_                  BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC));
DCL FMTVEC1_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC1));
DCL FMTVEC2_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC2));
DCL FMTVEC3_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC3));
DCL FMTVEC4_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC4));
DCL FMTVEC5_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC5));
DCL FMTVEC6_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC6));
DCL FMTVEC7_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC7));
DCL FMTVEC8_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC8));
DCL FMTVEC9_                 BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC9));
DCL FMTVEC10_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC10));
DCL FMTVEC11_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC11));
DCL FMTVEC12_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC12));
DCL FMTVEC13_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC13));
DCL FMTVEC14_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC14));
DCL FMTVEC15_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC15));
DCL FMTVEC16_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC16));
DCL FMTVEC17_                BIT(72) STATIC DALIGNED INIT(VECTOR(FMTVEC17));
%EJECT;
MAIN_PGM:
    CALL START_UP  ALTRET( DISASTER );
    CALL ALLOCATE_BUFFERS  ALTRET( DISASTER ); /* 2 FPARAMs + ME & LO_BUFs    */
    CALL PARSE_OPTIONS  ALTRET( CLOSEM );
    CALL INIT_IT;
    CALL SET_FDS;
    CALL TEST_FOR_FSF  ALTRET( DISASTER );
    CALL OPEN_FILES  ALTRET( DISASTER );
    CALL GET_STORAGE_BUF  ALTRET( DISASTER );
    DO WHILE( '1'B );
CML1:
      CALL GETLR( OLD# )  ALTRET( EOF_ON_F$OLD );  /* Read a F$OLD record     */
CML1A:
      CALL GETLR( NEW# )  ALTRET( EOF_ON_F$NEW );  /* Read a F$NEW record     */
CML1A2:
      IF BROKEN > 0 THEN
           CALL HANDLE_BREAK;
      IF IT.BAF$(OLD#) = ADDR(NIL)  AND       /* Is memory empty now?         */
         IT.BAF$(NEW#) = ADDR(NIL) THEN
           IF INT_BUF_NEEDED THEN DO;
              TMP1= IT.ARS(OLD#);
              CALL COMPRESS( IT.BFA$(OLD#)->BUF,TMP1,
                             OLD_INT_BUF,OLD_INT_ARS );
              TMP2= IT.ARS(NEW#);
              CALL COMPRESS( IT.BFA$(NEW#)->BUF,TMP2,
                             NEW_INT_BUF,NEW_INT_ARS );
              IF (OLD_INT_ARS ~= NEW_INT_ARS  AND
                  NOT OPT_FLAG(%IGNORE_TRAILING#))  OR
                 SUBSTR(OLD_INT_BUF,0,OLD_INT_ARS) ~=
                 SUBSTR(NEW_INT_BUF,0,NEW_INT_ARS) THEN
                 GOTO CML3;
              ELSE;/* Records match.  Read both files until mismatch or EOF */
              END;
           ELSE
              IF (IT.ARS(OLD#) ~= IT.ARS(NEW#)  AND
                  NOT OPT_FLAG(%IGNORE_TRAILING#))   OR
                 SUBSTR(IT.BFA$(OLD#)->BUF,0,IT.ARS(OLD#)) ~=
                 SUBSTR(IT.BFA$(NEW#)->BUF,0,IT.ARS(NEW#))  THEN DO;
CML3:
                 MWAD$= MBAS$;
                 CALL COMPARE_LOOP  ALTRET( CML9 );
                 END;
              ELSE;  /* Records match.  Read both files until mismatch or EOF */
      ELSE DO;
CALL_CML4:
           CALL COMPARE_LOOP  ALTRET( CML9 );
           END;
      END;
 
EOF_ON_F$OLD:
    IF IT.BAF$(OLD#) = ADDR(NIL) THEN  /* Anything from F$OLD in memory?      */
         CALL CMX1 ALTRET( CMY1 );     /* No, No deletion;  Go drain F$NEW    */
    ELSE GOTO CML1A;                   /* Yes: Keep going                     */
 
EOF_ON_F$NEW:
    IF IT.BAF$(NEW#) = ADDR(NIL) THEN  /* Anything from F$NEW in memory?      */
         CALL CMX2  ALTRET( CMY1 );    /* No, no deletions;  Go drain F$OLD   */
    ELSE GOTO CALL_CML4;               /* Yes, keep going                     */
 
CML9:
    IF IT.BAF$(OLD#) = ADDR(NIL) THEN  /* Anything from F$OLD in memory?      */
         CALL CMX1  ALTRET( CMY1 );    /* No, no deletions;  Go drain F$NEW   */
    ELSE CALL CMX3_ENTRY  ALTRET( CMY1 );  /* Yes.                            */
 
CMY1:
    IF OLNO > 0 THEN DO;               /* Any updates?                        */
         CALL OUTDIFF( %LNH# );
         CALL PUT_PLUS_CARD;           /* Put a '+END'                        */
         VEC1_= VECTOR(SUBSTR(OLD_TEXTFID,0,OLD_FID_LEN));  /* OLD fid        */
         VEC2_= VECTOR(IT.LNH(OLD#));                       /* # OLD records  */
         VEC3_= VECTOR(SUBSTR(NEW_TEXTFID,0,NEW_FID_LEN));  /* NEW fid        */
         VEC4_= VECTOR(IT.LNH(NEW#));                       /* # NEW records  */
         VEC5_= VECTOR(SUBSTR(UPD_TEXTFID,0,UPD_FID_LEN));  /* UPD fid        */
         VEC6_= VECTOR(UPD_CNT);                            /* # UPD lines    */
         IF UPD_IS_SET   AND
            NOT F$UPD$->F$DCB.DDEV.IC# THEN DO;
              /* %A has %D, %A has %D and %A has %D records. */
              CALL X$WRITE( F_FDS,FMTVEC4_,VEC1_,VEC2_,VEC3_,VEC4_,VEC5_,VEC6_);
              IF NOT LO_IS_ME THEN DO;
                   F_FDS.DCB#= M$LO#;
                   /* %A has %D, %A has %D and %A has %D records. */
                   CALL X$WRITE( F_FDS,FMTVEC4_,VEC1_,VEC2_,VEC3_,VEC4_,VEC5_,VEC6_);
                   F_FDS.DCB#= DCBNUM(M$ME);
                   END;
              END;
         ELSE DO;
              /* %A has %D and %A has %D records; %D were listed. */
              CALL X$WRITE( F_FDS,FMTVEC5_,VEC1_,VEC2_,VEC3_,VEC4_,VEC6_ );
              IF NOT LO_IS_ME THEN DO;
                   F_FDS.DCB#= M$LO#;
                   /* %A has %D and %A has %D records; %D were listed. */
                   CALL X$WRITE( F_FDS,FMTVEC5_,VEC1_,VEC2_,VEC3_,VEC4_,VEC6_ );
                   F_FDS.DCB#= DCBNUM(M$ME);
                   END;
              END;
         SET_STEPCC.V.STEPCC#= 2;      /* Set STEPCC indicating updates made  */
         END;
    ELSE CALL EOJ  ALTRET( DISASTER );
    IF OPT_FLAG(%STATISTICS#) THEN     /* Do they want STATS?                 */
         CALL PUT_STATS;
QUIT: ;
OOPS:
    CALL C$CLOSE( IT.DCB#(OLD#) );
    CALL C$CLOSE( IT.DCB#(NEW#) );
    CALL C$CLOSE( DCBNUM(F$UPD) );
CLOSEM:
    CALL C$CLOSE( M$LO# );
    CALL C$CLOSE( M$ME# );
    CALL M$EXIT( SET_STEPCC );
 
DISASTER:
    IF NOT QUIT_FLAG THEN              /* Has an error been printed yet?      */
         CALL C$MONERR;                /* Nope.  Print monitor error.         */
    SET_STEPCC.V.STEPCC#= 4;           /* Set STEPCC indicating unexpected err*/
    CALL M$EXIT( SET_STEPCC );
%EJECT;
OPEN_FILES: PROC  ALTRET;
 
    CALL GETLF( OLD# )  ALTRET( OOPS );
    IO_= VECTOR(NIL);
    CALL EXPAND( IO_,IT.BSZ(OLD#) )  ALTRET( NO_MEM1 );
    IT.ARST(OLD#)= IT.BSZ(OLD#);
    IT.ABS(OLD#)= IT.BSZ(OLD#);
    IT.BFA$(OLD#)= IO_.PTR$;
    IT.BFH$(OLD#)= PINCRC(IO_.PTR$,IT.BSZ(OLD#));
    IT.BFCT$(OLD#)= IT.BFH$(OLD#);
    IF INT_BUF_NEEDED  THEN
         CALL EXPAND( OLD_INT_BUF_,IT.BSZ(OLD#) )  ALTRET( NO_MEM1 );
 
    CALL GETLF( NEW# )  ALTRET( OOPS );
    CALL EXPAND( IO_,IT.BSZ(NEW#) )  ALTRET( NO_MEM2 );
    IT.ARST(NEW#)= IT.BSZ(NEW#);
    IT.ABS(NEW#)= IT.BSZ(NEW#);
    IT.BFA$(NEW#)= PINCRC( IO_.PTR$,IT.BSZ(OLD#) );
    IT.BFH$(NEW#)= PINCRC(IT.BFA$(NEW#),IT.BSZ(NEW#));
    IT.BFCT$(NEW#)= IT.BFH$(NEW#);
    IF INT_BUF_NEEDED THEN
         CALL EXPAND( NEW_INT_BUF_,IT.BSZ(NEW#) )  ALTRET( NO_MEM2 );
    IF IT.DCB$(OLD#)->F$DCB.CFU$ = IT.DCB$(NEW#)->F$DCB.CFU$ THEN
        GOTO SAME_FILE;
    RETURN;
 
SAME_FILE:
    ME_BUF = 'You are comparing a file with itself!';
    GOTO SET_FLAG;
NO_MEM1:
    ME_BUF= 'Well, scenility has got you (no more memory)!';
    GOTO SET_FLAG;
NO_MEM2:
    ME_BUF= 'Well, scenility has got you (no more memory)!';
SET_FLAG:
    CALL C$WRITE( ME_BUF,-ME_LEN,M$ME# );
    QUIT_FLAG= %YES#;
OOPS:
    ALTRETURN;
 
END OPEN_FILES;
%EJECT;
GETLF: PROC( FILE# )  ALTRET;
DCL FILE#                    UBIN;
 
    IF NOT IT.DCB$(FILE#)->F$DCB.AMR# THEN      /* Is DCB set?                */
         GOTO NOT_SET;                          /* Nope!  Go bitch, then exit */
    FIT$= IT.FIT$(FILE#);
    OPENF.V.DCB#= IT.DCB#(FILE#);
    OPENF.FPARAM_= VECTOR(FIT$->FPARAM);
    OPENF.V.OPER.TEST#= %NO#;
    OPENF.V.SETDCB#= %NO#;
    IF ITS_FSF THEN DO;
         IF FILE# = OLD# THEN
              CALL XSA$OPEN(OPENF,XSA_OLD)  ALTRET( OOPS );  /* OPEN the file */
         ELSE CALL XSA$OPEN(OPENF,XSA_NEW)  ALTRET( OOPS );  /* OPEN the file */
         GOTO SET_ORG;
         END;
    ELSE
         IF FILE# = OLD# THEN
              CALL M$OPEN(OPENF)  ALTRET( OOPS );    /* OPEN the file         */
         ELSE CALL M$OPEN(OPENF)  ALTRET( OOPS );    /* OPEN the file         */
    CODE= 3;
    CALL XSF$LOCCODT( FIT$,CODE )  ALTRET( OOPS );
    IT.BSZ(FILE#)= (FIT$->CODE03.RCSZ+1) * 4096;/* Yep, Calc max needed       */
    IT.LSZ(FILE#)= IT.BSZ(FILE#);
SET_ORG:
    IT.ORG(FILE#)= IT.DCB$(FILE#)->F$DCB.ORG#; /* Remember the files org      */
RET:
    RETURN;
 
NOT_SET:
    /* My crystal ball isn't working today!  Please specify files to be
                                                                     compared */
    CALL C$WRITE( CRYSTAL_BALL,LENGTHC(CRYSTAL_BALL),M$ME# );
    CALL C$WRITE( 'Syntax:',LENGTHC('Syntax:'),M$ME# );
    CALL CONCAT( ME_BUF,'  ',SYNTAX );
    /* !CMPR.X old-file,new-file {ON|TO|OVER|INTO} [updates] [,listing]
                                                                  [(options)] */
    CALL C$WRITE( ME_BUF,LENGTHC('  ')+LENGTHC(SYNTAX),M$ME# );
    QUIT_FLAG= %YES#;
 
OOPS:
    ALTRETURN;
 
END GETLF;
%EJECT;
GETLR: PROC(FILE#)  ALTRET;
DCL FILE#                    UBIN;
 
    IF IT.BAF$(FILE#) ~= IT.BAH$(FILE#)  OR
       IT.BAF_FLAG(FILE#) < 0 THEN DO;
         IT.BAF$(FILE#)= IT.BAF$(FILE#);
         GOTO RET;
         END;
GETLY: ENTRY(FILE#)  ALTRET;
    IF IT.IBR(FILE#) < 0 THEN                 /* EOF already hit?             */
         GOTO ARET;
    IT.BFCT$(FILE#)= PINCRC(IT.BFCT$(FILE#),IT.ARST(FILE#));
    IF IT.BFCT$(FILE#) >= IT.BFH$(FILE#) THEN DO;
         BUFSIZE= IT.ABS(FILE#);
         SUBSTR(IT.BFA$(FILE#)->BUF,0,BUFSIZE)= ' ';
         IT.BFCT$(FILE#)= IT.BFA$(FILE#);
         READF.V.DCB#= IT.DCB#(FILE#);
         READF.BUF_.BUF$= IT.BFA$(FILE#);
         READF.BUF_.BOUND= IT.BSZ(FILE#) - 1;
         IF ITS_FSF THEN
              IF FILE# = OLD# THEN DO;
                   CALL XSA$READ( READF,XSA_OLD )  ALTRET( OLD_ALTRET );
                   IT.ABS(OLD#)= XSA_OLD.ARS#;
                   END;
              ELSE DO;
                   CALL XSA$READ( READF,XSA_NEW )  ALTRET( NEW_ALTRET );
                   IT.ABS(NEW#)= XSA_NEW.ARS#;
                   END;
         ELSE DO;
              CALL M$READ( READF )  ALTRET( OOPS );
              IT.ABS(FILE#)= IT.DCB$(FILE#)->F$DCB.ARS#;
              END;
         IF IT.ABS(FILE#) > IT.MRS(FILE#) THEN
              IT.MRS(FILE#)= IT.ABS(FILE#);
         IT.ARST(FILE#)= IT.ABS(FILE#);
         IT.BFH$(FILE#)= PINCRC(IT.BFCT$(FILE#),IT.ARST(FILE#));
         IF IT.ORG(FILE#) = %KEYED# THEN
              IF IT.KEY(FILE#) > -2 THEN
                   IF KEY.LEN = LENGTHC(KEY.EDIT) THEN
                        IT.KEY(FILE#)= KEY.EDIT;
                   ELSE IT.KEY(FILE#)= -2;
              ELSE;
         ELSE IT.KEY(FILE#)= IT.LNH(FILE#) + 1;
         END;
    ELSE IT.ARST(FILE#)= IT.LSZ(FILE#);
    IT.LNH(FILE#)= IT.LNH(FILE#) + 1;  /* Count the record                    */
    IT.ARS(FILE#)= IT.ARST(FILE#);
    IT.BFC$(FILE#)= IT.BFCT$(FILE#);
RET:
    RETURN;
 
OLD_ALTRET:
    ERRCODE= XSA_OLD.ERR;
    IF ERRCODE.ERR# ~= %E$EOF THEN
         CALL C$MONERR( ERRCODE,DCBNUM(F$OLD) );
    GOTO OOPS;
 
NEW_ALTRET:
    ERRCODE= XSA_NEW.ERR;
    IF ERRCODE.ERR# ~= %E$EOF THEN
         CALL C$MONERR( ERRCODE,DCBNUM(F$NEW) );
 
OOPS:
    IT.IBR(FILE#)= -1;
ARET:
    ALTRETURN;
 
END GETLR;
%EJECT;
EOJ: PROC  ALTRET;
 
    TMP1= IT.LNH(OLD#);
    VEC1_= VECTOR(TMP1);
    VEC2_= VECTOR(SUBSTR(OLD_TEXTFID,0,OLD_FID_LEN));
    VEC3_= VECTOR(SUBSTR(NEW_TEXTFID,0,NEW_FID_LEN));
    VEC4_= VECTOR(SUBSTR(UPD_TEXTFID,0,UPD_FID_LEN));
    IF TMP1 > 0 THEN
         /* The %D records in %A and %A are IDENTICAL. */
         CALL X$WRITE( F_FDS, FMTVEC3_,VEC1_,VEC2_,VEC3_ );
    ELSE IF UPD_IS_SET THEN
              /* %A and %A both have no records so %A now contains a +END */
              CALL X$WRITE( F_FDS,FMTVEC7_,VEC2_,VEC3_,VEC4_ );
         ELSE /* %A and %A both have no records. */
              CALL X$WRITE( F_FDS,FMTVEC6_,VEC2_,VEC3_ );
    IF NOT LO_IS_ME THEN DO;
         F_FDS.DCB#= M$LO#;
         IF TMP1 > 0 THEN
              /* The %D records in %A and %A are IDENTICAL. */
              CALL X$WRITE( F_FDS, FMTVEC3_,VEC1_,VEC2_,VEC3_ );
         ELSE IF UPD_IS_SET THEN
                   /* %A and %A both have no records so %A now contains a +END */
                   CALL X$WRITE( F_FDS,FMTVEC7_,VEC2_,VEC3_,VEC4_ );
              ELSE /* %A and %A both have no records. */
                   CALL X$WRITE( F_FDS,FMTVEC6_,VEC2_,VEC3_ );
         END;
    RETURN;
 
END EOJ;
%EJECT;
PACKL: PROC( FILE# )  ALTRET;
DCL FILE#                    UBIN;
 
    R4$= IT.BAF$(FILE#);
    IF IT.BAF_FLAG(FILE#) < 0 THEN DO; /* Are we already at 'next' lin in mem?*/
         IT.BAF_FLAG(FILE#)= 0;
         GOTO PKL7;
         END;
PKM1:
    IF R4$ ~= IT.BAH$(FILE#) THEN DO;
         R4$= PINCRC( R4$,R4$->ENTREE.SIZ);
         DO WHILE( R4$->ENTREE.FILE ~= FILE# );  /* Make sure we have the     */
           R4$= PINCRC( R4$,R4$->ENTREE.SIZ );   /* file we want.             */
           END;
         IT.LNF(FILE#)= IT.LNF(FILE#) + 1;       /* Bump the line counter      */
         IT.BAF$(FILE#)= R4$;
         GOTO PKL7;
         END;
PKL0:
    IF IT.IBR(FILE#) < 0 THEN          /* Return if EOF previously hit        */
         GOTO RET;
    ENTREE$= MWAD$;
    IF IT.KEY(FILE#) > -1 THEN         /* Is file EDIT keyed?                 */
         MWAD$= PINCRC( MWAD$,LENGTHC(ENTREE.SIZ)+IT.ARS(FILE#)+3 );
    ELSE MWAD$= PINCRC( MWAD$,LENGTHC(ENTREE.SIZ)+IT.ARS(FILE#) );
    IF MWAD$ >= PACK_END$ THEN DO;
         CALL EXPAND( PACK_,8192 )  ALTRET( OOPS );  /* Get 2 more pages      */
         PACK_END$= PINCRC( PACK_.PTR$,PACK_.W1.VSIZE#+1 );
         END;
    ENTREE.FILE= FILE#;
    ENTREE.SIZ= IT.ARS(FILE#) + LENGTHC(ENTREE.SIZ);
    SUBSTR(ENTREE.REC,0,IT.ARS(FILE#))=
                  SUBSTR(IT.BFA$(FILE#)->BUF,0,IT.ARS(FILE#));/* BFA$ -> LIN$ */
    IF IT.KEY(FILE#) > -1 THEN DO;     /* Should we include the EDIT key/rec# */
         SUBSTR(ENTREE.REC,ENTREE.SIZ-LENGTHC(ENTREE.SIZ),3)=
                                                     SUBSTR(IT.KEYX(FILE#),1,3);
         ENTREE.SIZ= ENTREE.SIZ + LENGTHC(KEY.EDIT);
         END;
PKL6B:
    IF MWAD$ > MEMH$ THEN
         MEMH$= MWAD$;
    IT.BAH$(FILE#)= ENTREE$;
    R4$= IT.BAF$(FILE#);
    IT.BAF$(FILE#)= ENTREE$;
    IT.LNF (FILE#)= IT.LNH(FILE#);
PKL7:
    IF R4$ = ADDR(NIL) THEN DO;
         IT.LNL (FILE#)= IT.LNH (FILE#);
         IT.BAL$(FILE#)= IT.BAH$(FILE#);
         END;
RET:
    RETURN;
 
OOPS:
    ALTRETURN;
 
END PACKL;
%EJECT;
EXPAND: PROC( SEG_,NUM_BYTES )  ALTRET;
%VLP_VECTOR (FPTN=SEG_,STCLASS=);
DCL NUM_BYTES                UBIN;
 
    GDS.V.SEGSIZE#= (NUM_BYTES+3)/4;
    GDS.RESULTS_= VECTOR(SEG_);
    CALL M$GDS( GDS )  ALTRET( NO_MEM );
    RETURN;
 
NO_MEM:
    ALTRETURN;
 
END EXPAND;
%EJECT;
COMPARE_LOOP: PROC  ALTRET;
 
DCL DUMPFLG                  BIT(1)    ALIGNED  STATIC               INIT('0'B);
 
CML4:
    CALL PACKL( OLD# )  ALTRET( RET );
    SVSW$= R4$;
    CALL PACKL( NEW# )  ALTRET( RET );
    IF R4$ = ADDR(NIL)  AND            /* Have lines already been compared?   */
       SVSW$ = ADDR(NIL) THEN
         GOTO RET;                     /* Yep.  Don't do it again.            */
    R4$= IT.BAL$(OLD#);                /* Get PTR of 1st OLD line in Memory   */
    R10= IT.LNL(OLD#);                 /* Get line # of 1st OLD line in memory*/
    R5$= IT.BAL$(NEW#);                /* Get PTR of 1st NEW line in Memory   */
    R11= IT.LNL(NEW#);                 /* Get line # of 1st NEW line in memory*/
 
    IF DUMPFLG THEN DO;
       CALL DUMP;
       END;
    IF R4$ = ADDR(NIL)  OR
       R5$ = ADDR(NIL) THEN
         GOTO CML5G;
CML5A:
    IF BROKEN > 0 THEN
         CALL HANDLE_BREAK;
    IF R5$ > IT.BAF$(NEW#) THEN DO;    /* Any more to compare this way?       */
         TMPCC= 1;                     /* Nope!  But remember this compare    */
         GOTO CML5D;
         END;
    ELSE IF R5$ = IT.BAF$(NEW#) THEN
              TMPCC= 0;
         ELSE TMPCC= -1;
    R9= R5$->ENTREE.SIZ - LENGTHC(ENTREE.SIZ);
    IF R5$->ENTREE.FILE ~= NEW# THEN DO;
         R5$= PINCRC( R5$,R5$->ENTREE.SIZ );
         GOTO CML5A;
         END;
CML5A1:
    IF IT.KEY(NEW#) > -1 THEN          /* Does NEW have an EDIT key or rec #? */
         R9= R9 - 3;                   /* Don't count the length of the key   */
    R1$= IT.BAF$(OLD#);
    R8= R1$->ENTREE.SIZ - LENGTHC(ENTREE.SIZ);  /* Get length of ENTREE.REC   */
    IF IT.KEY(OLD#) > -1 THEN          /* Does OLD have an EDIT key or rec #? */
         R8= R8 - 3;                   /* Don't count the length of the key   */
    IF INT_BUF_NEEDED THEN DO;
       CALL COMPRESS( R1$->ENTREE.REC,R8,OLD_INT_BUF,OLD_INT_ARS );
       CALL COMPRESS( R5$->ENTREE.REC,R9,NEW_INT_BUF,NEW_INT_ARS );
       IF OLD_INT_ARS = NEW_INT_ARS  OR
          OPT_FLAG(%IGNORE_TRAILING#) THEN DO;
          R2$= R5$;
          IF SUBSTR(OLD_INT_BUF,0,OLD_INT_ARS) =
             SUBSTR(NEW_INT_BUF,0,NEW_INT_ARS)  THEN DO;
             R8= IT.LNF(OLD#);
             R9= R11;
             CALL CML6  ALTRET( RET );
             END;
          END;
       END;
    ELSE
       IF R9 = R8  OR                  /* Do record lengths match?            */
          OPT_FLAG(%IGNORE_TRAILING#) THEN DO;
            R2$= R5$;
            IF SUBSTR(R1$->ENTREE.REC,0,R8) = SUBSTR(R2$->ENTREE.REC,0,R9) THEN DO;
                 R8= IT.LNF(OLD#);
                 R9= R11;
                 CALL CML6  ALTRET( RET );/* Go add equals to the stack       */
                 END;
            END;
CML5C:
    R9= R5$->ENTREE.SIZ;
    R5$= PINCRC( R5$,R9 );
    R11= R11 + 1;                      /* Bump line counter                   */
CML5D:
    IF R4$ < IT.BAF$(OLD#) THEN
         GOTO CML5D2;
    ELSE IF R4$ = IT.BAF$(OLD#) THEN
              IF TMPCC >= 0 THEN
                   GOTO CML5G;
              ELSE;
         ELSE IF TMPCC < 0 THEN
                   GOTO CML5A;
              ELSE GOTO CML5G;
CML5D2:
    R9= R4$->ENTREE.SIZ - LENGTHC(ENTREE.SIZ);
    IF R4$->ENTREE.FILE ~= OLD# THEN DO;
         R4$= PINCRC( R4$,R4$->ENTREE.SIZ );
         GOTO CML5D;
         END;
CML5D3:
    IF IT.KEY(OLD#) > -1 THEN          /* Does OLD have an EDIT key or rec #? */
         R9= R9 - 3;                   /* Don't count the length of the key.  */
    R2$= IT.BAF$(NEW#);                /* Get address of GL                   */
    R8= R2$->ENTREE.SIZ - LENGTHC(ENTREE.SIZ);
    IF IT.KEY(NEW#) > -1 THEN          /* Does NEW have an EDIT key or rec #? */
         R8= R8 - 3;                   /* Don't count the length of the key.  */
    IF INT_BUF_NEEDED THEN DO;
       CALL COMPRESS( R4$->ENTREE.REC,R9,OLD_INT_BUF,OLD_INT_ARS );
       CALL COMPRESS( R2$->ENTREE.REC,R8,NEW_INT_BUF,NEW_INT_ARS );
       IF OLD_INT_ARS = NEW_INT_ARS  OR
          OPT_FLAG(%IGNORE_TRAILING#) THEN DO;
          R1$= R4$;
          IF SUBSTR(OLD_INT_BUF,0,OLD_INT_ARS) =
             SUBSTR(NEW_INT_BUF,0,NEW_INT_ARS)  THEN DO;
             R8= R10;
             R9= IT.LNF(NEW#);
             CALL CML6  ALTRET( RET );
             END;
          END;
       END;
    ELSE
       IF R8 = R9  OR
          OPT_FLAG(%IGNORE_TRAILING#) THEN DO;
            R1$= R4$;
CML5E2:
            IF SUBSTR(R1$->ENTREE.REC,0,R9) = SUBSTR(R2$->ENTREE.REC,0,R8) THEN DO;
                 R8= R10;
                 R9= IT.LNF(NEW#);
                 CALL CML6  ALTRET( RET );
                 END;
            END;
CML5F:
    R9= R4$->ENTREE.SIZ;
    R4$= PINCRC( R4$,R9 );             /* Bump R4$ past line we just looked at*/
    R10= R10 + 1;                      /* Bump line counter                   */
    GOTO CML5A;                        /* Keep comparing                      */
CML5G:
    IF IT.IBR(OLD#) ~= 0  AND          /* EOF hit on both files?              */
       IT.IBR(NEW#) ~= 0 THEN
         IF IT.BAF$(OLD#) = IT.BAH$(OLD#) THEN /* Nothing from OLD to compare?*/
              IF IT.BAF$(NEW#) = IT.BAH$(NEW#) THEN /* Nothing from NEW to com*/
                   IF STKP ~= 0 THEN
                                       /* Go process stack (unless it's empty)*/
                        CALL CML6B  ALTRET( RET );
                   ELSE GOTO CML9;     /* Finish up                           */
RET:
    RETURN;
 
CML9:
    ALTRETURN;
 
END COMPARE_LOOP;
%EJECT;
CML6: PROC  ALTRET;
 
    IF STKDUMPFLG THEN DO;
       CALL DUMPSTK;
       END;
    R1= STKP;
    IF R1 <= 0 THEN DO;                /* Is stack empty?                     */
         R6= IT.LNL(OLD#);             /* Yep.  Get the lowest line number    */
         IF R6 > IT.LNL(NEW#) THEN     /* of any in memory.                   */
              R6= IT.LNL(NEW#);
         LBIAS= R6;                    /* Keep as the bias                    */
         END;
CML6A:
    R8= R8 - LBIAS;                    /* Subtract off the bias               */
    R9= R9 - LBIAS;                    /* Now find whether these are more of  */
    GOTO CML6A2;                       /* an existing block of equals.        */
CML6A1:
                                       /* We must search the entire stack     */
    R13= LINE.BLK_CNT(R1);             /* take (next) stacked item apart      */
    R7= LINE.NEW_NUM(R1) + R13;
    R6= LINE.OLD_NUM(R1) + R13;
    IF R6 = R8 AND                     /* Extension of block of equals?       */
       R7 = R9 THEN DO;
         LINE.BLK_CNT(R1)= LINE.BLK_CNT(R1) + 1; /* Yep.  Just bump block size*/
         IF LINE.BLK_CNT(R1) < HOLD THEN   /* test threshold                  */
              GOTO RET;                /* Block not big enough; keep comparing*/
         ELSE GOTO CML6BX;             /* Go process stack                    */
         END;
CML6A2:
    R1= R1 - 1;
    IF R1 >= 0 THEN                    /* Should item be added to the stack?  */
         GOTO CML6A1;                  /* Nope.  Try next item on the stack   */
    IF R8 > 4095  OR                   /* Are line numbers too big?           */
       R9 > 4095 THEN
         GOTO CML6BX;                  /* Yep.                                */
 
    LINE.FLAG(STKP)= %NO#;
    LINE.DEFERRED(STKP)= %NO#;
    LINE.BLK_CNT(STKP)= 1;             /* Initialize block size to 1          */
    LINE.OLD_NUM(STKP)= R8;
    LINE.NEW_NUM(STKP)= R9;
    STKP= STKP + 1;
    R1= STKP;
    IF STKP > STKH THEN
         STKH= STKP;                   /* Keep as stack high-water mark       */
/* See if there is room for 2 more lines in memory */
    TMP1= MAXIMUM(IT.MRS(OLD#),IT.MRS(NEW#));
    IF PINCRC(MWAD$,TMP1*2) > PACK_END$ THEN DO;
         CALL EXPAND( PACK_,8192 )  ALTRET( OVERFLOW );
SET_PACK_END:
         PACK_END$= PINCRC( PACK_.PTR$,PACK_.W1.VSIZE#+1 );
         END;
    IF STKP+2 >= MAX_STK THEN DO;
         CALL EXPAND( STK_,4096 ) ALTRET( OVERFLOW_HIT );
         MAX_STK= (STK_.W1.VSIZE#+1) / 4;
         END;
    GOTO RET;
 
OVERFLOW:
    IF PINCRC(MWAD$,TMP1*2) < PACK_END$ THEN
         GOTO SET_PACK_END;
OVERFLOW_HIT:
    /* Not enough room in memory.  Get rid of some stuff */
    STKOVFC= STKOVFC + 1;
 
CML6B: ENTRY  ALTRET;
CML6BX:
    FIRSTSW= 1;
CML6B1:
    R14= 0;                         /* Find largest unflagged block of equals */
    R2= 0;
    GOTO CML6B4;                       /* Enter loop                          */
CML6B2:
 
    IF LINE.FLAG(R2)  OR               /* If item is already flagged,         */
       LINE.DEFERRED(R2) THEN
         GOTO CML6B3;                  /* skip it.                            */
    IF R14 < LINE.BLK_CNT(R2) THEN DO; /* If this one is bigger,              */
         R14= LINE.BLK_CNT(R2);        /* remember it and                     */
         R1= R2;                       /* its index                           */
         END;
CML6B3:
    R2= R2 + 1;
CML6B4:
    IF R2 < STKP THEN
         GOTO CML6B2;
    IF R14 = 0 THEN DO;                /* If none left unflagged,             */
         CALL CML6D  ALTRET( GOTO_CML1 ); /*   go to output routine.          */
         GOTO RET;
         END;
    FIRSTSW= FIRSTSW - 1;              /* Count down first time switch        */
                                       /* Get the selected one. Call it 'SEL' */
    LINE.FLAG(R1)= %YES#;              /* in the comments below.  Flag this 1 */
    R13= LINE.NEW_NUM(R1);             /* Set things                          */
    R12= LINE.OLD_NUM(R1);             /*        up                           */
    R15= LINE.BLK_CNT(R1) + R13;       /*           to edit out               */
    R14= LINE.BLK_CNT(R1) + R12;       /*               overlapping blocks    */
    R2= 0;
CML6C:
 
    IF LINE.FLAG(R2)  OR               /* If item is already flagged,         */
       LINE.DEFERRED(R2) THEN
         GOTO CML6C3;                  /* skip it.                            */
    R8= LINE.BLK_CNT(R2);              /* Test for any kind of TST/SEL overlap*/
    R5= LINE.NEW_NUM(R2);
    R4= LINE.OLD_NUM(R2);
    R6= R8 + R4;
    R7= R8 + R5;
    IF R4 < R12 THEN DO;               /* Does TST lie (partly) below SEL?    */
CML6C1:
         IF R6 <= R12 AND              /* If (reduced) TST lies completely    */
            R7 <= R13 THEN DO;         /* below 'SEL' then fall thru to keep  */
              LINE.BLK_CNT(R2)= R8;    /* (reduced) TST.  Store updated size  */
              GOTO CML6C3;             /* of TST                              */
              END;
CML6C1A:
         R6= R6 - 1;                   /* Try reducing size of TST            */
         R7= R7 - 1;
         R8= R8 - 1;
         IF R8 > 0 THEN
              GOTO CML6C1;
         GOTO CML6C2B;                 /* Doesn't help; Eliminate TST         */
         END;
CML6C2:
    IF R4 >= R14 AND                   /* If (reduced) TST lies completely    */
       R5 >= R15 THEN DO;              /* above SEL,                          */
         LINE.FLAG(R2)= %NO#;
         LINE.OLD_NUM(R2)= R4;         /* Update TST                          */
         LINE.NEW_NUM(R2)= R5;
         LINE.BLK_CNT(R2)= R8;
         IF FIRSTSW >= 0 THEN           /* Test for first time                 */
              LINE.DEFERRED(R2)= %YES#;/* Flag TST to defer                   */
         ELSE LINE.DEFERRED(R2)= %NO#;
         GOTO CML6C3;
         END;
CML6C2A:
    R4= R4 + 1;                        /* Try reducing size of TST            */
    R5= R5 + 1;
    R8= R8 - 1;
    IF R8 > 0 THEN                     /* Fall thru if reducing didn't help   */
         GOTO CML6C2;
CML6C2B:
 
    LINE.FLAG(R2)= %YES#;
    LINE.DEFERRED(R2)= %YES#;
CML6C3:
    R2= R2 + 1;
    IF R2 < STKP THEN                  /* When all unflagged items have been  */
         GOTO CML6C;                   /*  compared against SEL,then fall thru*/
    ELSE GOTO CML6B1;                  /* Go find next longest block          */
RET:
    RETURN;
 
GOTO_CML1:
    ALTRETURN;
 
END CML6;
%EJECT;
CML6D: PROC  ALTRET;
 
    R7= 0;                             /* Init stack index for outputting upds*/
    GOTO CML6J1;                       /* Enter loop                          */
CML6D1:
                                       /* Point to next stacked item          */
    IF LINE.DEFERRED(R7) THEN          /* If it's flagged or deferred,        */
         GOTO CML6J;                   /*  skip it.                           */
    R10= LINE.OLD_NUM(R7) + LBIAS;     /* Add LBIAS to get true line numbers  */
    R11= LINE.NEW_NUM(R7) + LBIAS;
    IF R10 = IT.LNL(OLD#) AND
       R11 = IT.LNL(NEW#) THEN         /* If continuation of previous equals, */
         GOTO CML6E;                   /*  then no updates to output yet      */
    IF R10 = IT.LNL(OLD#) THEN
         CALL PUT_PLUS_CARD( R10-1 );
    ELSE CALL PUT_PLUS_CARD( IT.LNL(OLD#),R10-1 );
CML6E:
    R4$= IT.BAL$(OLD#);                /* Get PTR to first line of OLD        */
CML6E1:
 
    R10= LINE.OLD_NUM(R7) + LBIAS - IT.LNL(OLD#);
    IF R10 > 0 AND                     /* More to list and                    */
       OPT_FLAG(%LIST_DELETED#) THEN DO; /* deletions are to be listed?       */
         CALL OUTLN1;                  /* List line from OLD file             */
         IT.LNL(OLD#)= IT.LNL(OLD#) + 1;  /* Count lines listed               */
         GOTO CML6E1;
         END;
CML6F:
 
    R11= LINE.BLK_CNT(R7);             /* How many lines to step over         */
    R10= R10 + R11;                    /* Plus unlisted unequals              */
    IT.LNL(OLD#)= IT.LNL(OLD#) + R10; /* Bump cnt for lines to be stepped ovr */
CML6F1: ;
CML6F2:                                /* Step ahead to next line in memory   */
    R12= R4$->ENTREE.SIZ;              /* (if any) from OLD file after the    */
    R4$= PINCRC( R4$,R12 );            /* last equal line                     */
    IF R4$ <= IT.BAH$(OLD#) THEN DO;
         IF R4$->ENTREE.FILE ~= OLD# THEN
              GOTO CML6F1;
         R10= R10 - 1;
         IF R10 > 0 THEN
              GOTO CML6F2;
         END;
CML6F3:
    IT.BAL$(OLD#)= R4$;                /* Store updated PTR                   */
    R4$= IT.BAL$(NEW#);                /* Get PTR to first line of NEW        */
CML6G:
 
    R10= LINE.NEW_NUM(R7) + LBIAS;
    IF R10 > IT.LNL(NEW#) THEN DO;
         CALL OUTLN2;                  /* Output line from NEW file           */
         IT.LNL(NEW#)= IT.LNL(NEW#) + 1;  /* Count lines output               */
         GOTO CML6G;
         END;
CML6H:
 
    R10= LINE.BLK_CNT(R7);             /* How many lines to step over         */
    IT.LNL(NEW#)= IT.LNL(NEW#) + R10; /* Bump cnt for lines to be stepped ovr */
CML6H1: ;
CML6H2:                                /* Step ahead to next line in memory   */
    R12= R4$->ENTREE.SIZ;              /* (if any) from NEW file after last   */
    R4$= PINCRC( R4$,R12 );            /* equal line                          */
    IF R4$ <= IT.BAH$(NEW#) THEN DO;
         IF R4$->ENTREE.FILE ~= NEW# THEN
              GOTO CML6H2;
         R10= R10 - 1;
         IF R10 > 0 THEN
              GOTO CML6H1;
         END;
CML6H3:
    IT.BAL$(NEW#)= R4$;                /* Store updated PTR                   */
    CALL OUTDIFF(%LNL#);               /* Print line number difference (maybe)*/
CML6J:
    R7= R7 + 1;                    /* Bottom of output loop; Bump stack index */
CML6J1:
    IF R7 < STKP THEN
         GOTO CML6D1;
    STKP= 0;                           /* Finally, mark stack empty           */
    CALL PURGE_MEMORY  ALTRET( GOTO_CML1 );
RET:
    RETURN;
 
GOTO_CML1:
    ALTRETURN;
 
END CML6D;
%EJECT;
PURGE_MEMORY: PROC  ALTRET;
 
    R6$= ADDR(NIL);
    R10= IT.LNL(OLD#);
    IF R10 > 0 THEN
         IF R10 > IT.LNH(OLD#) THEN DO;
              IT.LNL(OLD#)= 0;
              IT.BAL$(OLD#)= ADDR(NIL);
              IT.BAH$(OLD#)= ADDR(NIL);
              IT.LNF(OLD#)= 0;
              IT.BAF$(OLD#)= ADDR(NIL);
              IT.BAF_FLAG(OLD#)= 0;
              END;
         ELSE DO;
              IT.LNF(OLD#)= R10;
              R6$= IT.BAL$(OLD#);
              IT.BAF$(OLD#)= R6$;
              IT.BAF_FLAG(OLD#)= -1;
              END;
CML7B:
    R10= IT.LNL(NEW#);
    IF R10 > 0 THEN
         IF R10 > IT.LNH(NEW#) THEN DO;
              IT.LNL(NEW#)= 0;
              IT.BAL$(NEW#)= ADDR(NIL);
              IT.BAH$(NEW#)= ADDR(NIL);
              IT.LNF(NEW#)= 0;
              IT.BAF$(NEW#)= ADDR(NIL);
              IT.BAF_FLAG(NEW#)= 0;
              END;
         ELSE DO;
              IT.LNF(NEW#)= R10;
              R4$= IT.BAL$(NEW#);
              IT.BAF$(NEW#)= R4$;
              IT.BAF_FLAG(NEW#)= -1;
              END;
    IF R6$ ~= ADDR(NIL) THEN DO;
         IF R6$ < R4$ THEN DO;
              TMP1= POFFC( R6$,MBAS$ );        /* = # bytes we're shifting left*/
              TMP2= POFFC( MWAD$,R6$ );        /* = # bytes being shifted      */
              SRC$= R6$;
              END;
         ELSE DO;
              TMP1= POFFC( R4$,MBAS$ );        /* = # bytes being shifted left */
              TMP2= POFFC( MWAD$,R4$ );        /* = # bytes being shifted      */
              SRC$= R4$;
              END;
         DES$= MBAS$;                         /* Init destination PTR         */
         L= MINIMUM( TMP2,262143 );           /* 262143 is max length of MLR  */
         DO WHILE( SRC$ < MWAD$ );
            SUBSTR(DES$->BUF,0,L)= SUBSTR(SRC$->BUF,0,L);
            SRC$= PINCRC( SRC$,L );
            DES$= PINCRC( DES$,L );
            L= MINIMUM( POFFC(MWAD$,SRC$),262143 );
            END;
         MWAD$= PINCRC( MWAD$,-TMP1 );
         IF IT.BAF$(OLD#) ~= ADDR(NIL) THEN DO;
              IT.BAL$(OLD#)= PINCRC( IT.BAL$(OLD#),-TMP1 );
              IT.BAF$(OLD#)= PINCRC( IT.BAF$(OLD#),-TMP1 );
              IT.BAH$(OLD#)= PINCRC( IT.BAH$(OLD#),-TMP1 );
              END;
         IF IT.BAF$(NEW#) ~= ADDR(NIL) THEN DO;
              IT.BAL$(NEW#)= PINCRC( IT.BAL$(NEW#),-TMP1 );
              IT.BAF$(NEW#)= PINCRC( IT.BAF$(NEW#),-TMP1 );
              IT.BAH$(NEW#)= PINCRC( IT.BAH$(NEW#),-TMP1 );
              END;
         END;
    ALTRETURN;
 
END PURGE_MEMORY;
%EJECT;
CLRPB: PROC;
 
    LO_BUF= ' ';
    OLNO= OLNO + 1;
    CALL BINCHAR( SUBSTR(LO_BUF,0,7),OLNO );
    CALL EDITSTR( SUBSTR(LO_BUF,0,7),0,7,'107'O,SUBSTR(LO_BUF,0,7) );
    RETURN;
 
CLRPBA: ENTRY;
    LO_BUF= ' ';
    SUBSTR(LO_BUF,8,1)= 'D';
    RETURN;
 
END CLRPB;
%EJECT;
CVDLR: PROC( BUF );
DCL BUF                      CHAR(132);
 
DCL I                        UBIN;
DCL L                        UBIN;
 
    CALL BINCHAR( INT8,R3 );
    CALL SEARCH( I,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,7) );
    L= LENGTHC(INT8) - I;
    SUBSTR(BUF,R1,L)= SUBSTR(INT8,I);
    R1= R1 + L;
    RETURN;
 
END CVDLR;
%EJECT;
CVDRL: PROC( BUF );
DCL BUF                      CHAR(132);
 
DCL I                        SBIN;
DCL L                        SBIN;
 
    CALL BINCHAR( INT8,R3 );
    CALL SEARCH( I,TABLEVAL,SKIP_ZEROS,SUBSTR(INT8,0,7) );
    L= LENGTHC(INT8) - I;
    SUBSTR(LO_BUF,R1-L+1,L)= SUBSTR(INT8,I);
    R1= R1 - L;
    RETURN;
 
END CVDRL;
%EJECT;
SNDPB: PROC( SOURCE$,LEN );
DCL SOURCE$                  PTR;
DCL LEN                      UBIN;
 
DCL REC                      CHAR(LEN) BASED(SOURCE$);
 
    IF LO_IS_SET THEN DO;
         UPD_CNT= UPD_CNT + 1;
         CALL C$WRITE( LO_BUF,-LO_LEN,M$LO# );
         END;
    IF UPD_IS_SET THEN DO;
         IF LEN = 0 THEN
              WRITE_UPD.BUF_= VECTOR(NIL);
         ELSE
              WRITE_UPD.BUF_= VECTOR(REC);
         IF ITS_FSF THEN
              CALL XSA$WRITE( WRITE_UPD,XSA_UPD );
         ELSE
              CALL M$WRITE( WRITE_UPD );
         UPD_CNT= UPD_CNT + 1;
         END;
    RETURN;
 
END SNDPB;
%EJECT;
OUTLN1: PROC;
 
    CALL CLRPBA;
    CALL OTL0( OLD# );
    RETURN;
 
END OUTLN1;
%EJECT;
OUTLN2: PROC;
 
    CALL CLRPB;
    CALL OTL0( NEW# );
    RETURN;
 
END OUTLN2;
%EJECT;
OUTDIFF: PROC( FIELD# );
DCL FIELD#                   SBIN;
 
    IF OPT_FLAG(%DIFFERENCE#)  AND
       LO_IS_SET THEN DO;
         IF FIELD# = %LNH# THEN
              R9= IT.LNH(NEW#) - IT.LNH(OLD#);
         ELSE R9= IT.LNL(NEW#) - IT.LNL(OLD#);
         IF R9 ~= LDIFF THEN DO;
              LDIFF= R9;
              LO_BUF= ' ';
              SUBSTR(LO_BUF,%PLLF-1,1)= ')';
              R1= %PLLF - 2;
              IF R9 < 0 THEN
                   R3= -R9;
              ELSE R3=  R9;
              CALL CVDRL( LO_BUF );
              IF R9 < 0 THEN DO;
                   SUBSTR(LO_BUF,R1,1)= '-';
                   R1= R1 - 1;
                   END;
OTDF2:
              SUBSTR(LO_BUF,R1,1)= '(';
              CALL C$WRITE( LO_BUF,-LO_LEN,M$LO# );
              END;
         END;
    RETURN;
 
END OUTDIFF;
%EJECT;
OTL0: PROC( FILE# );
DCL FILE#                    UBIN;
 
    R12= R4$->ENTREE.SIZ - LENGTHC(ENTREE.SIZ);
    IF IT.KEY(FILE#) > -1 THEN
         R12= R12 - LENGTHC(KEY.EDIT);
    TMP5= MINIMUM( R12,LO_LEN-%PLLF );
    SUBSTR(LO_BUF,%PLLF,TMP5)= SUBSTR(R4$->ENTREE.REC,0,TMP5);
    IF IT.KEY(FILE#) > -1 THEN DO;
         EDIT_KEYX.XXX= SUBSTR(R4$->ENTREE.REC,R12,3);
         CALL OUTKEY( FILE#,EDIT_KEY );
         END;
OTL5A:
    IF FILE# = OLD# THEN
         IF LO_IS_SET THEN DO;
              UPD_CNT= UPD_CNT + 1;
              CALL C$WRITE( LO_BUF,%PLLF+TMP5,M$LO# );
              END;
         ELSE;
    ELSE CALL SNDPB( PINCRC(R4$,LENGTHC(ENTREE.SIZ)),R12 );
OTL7:
    IF R4$ <= IT.BAH$(FILE#) THEN DO;
         R4$= PINCRC( R4$,R4$->ENTREE.SIZ );
         IF R4$->ENTREE.FILE ~= FILE# THEN
              GOTO OTL7;
         END;
OTL8:
    RETURN;
 
END OTL0;
%EJECT;
CMX1: PROC  ALTRET;
 
    MWAD$= MBAS$;
    IF IT.BAF$(NEW#) = ADDR(NIL) THEN DO;
         CALL GETLR( NEW# )  ALTRET( CMY1 );
         CALL PACKL( NEW# )  ALTRET( CMY1 );
         END;
CMX1A:
    CALL PUT_PLUS_CARD( IT.LNH(OLD#) );
CMX5:
    R4$= IT.BAL$(NEW#);
    IF R4$ ~= ADDR(NIL) THEN DO;
CMX5A:
         CALL OUTLN2;
         IF R4$ <= IT.BAH$(NEW#) THEN
              GOTO CMX5A;
         END;
CMX5B:
    CALL GETLY( NEW# )  ALTRET( CMY1 );
    CALL CLRPB;
    SUBSTR(LO_BUF,%PLLF,LO_LEN-%PLLF)=SUBSTR(IT.BFA$(NEW#)->BUF,0,IT.ARS(NEW#));
    IF IT.KEY(NEW#) > -1 THEN
         CALL OUTKEY( NEW#,IT.KEY(NEW#) );
CMX5D:
    CALL SNDPB( IT.BFA$(NEW#),IT.ARS(NEW#) );
    GOTO CMX5B;
 
CMY1:
    ALTRETURN;
 
END CMX1;
%EJECT;
CMX2: PROC  ALTRET;
 
    R7= OLD#;
    IF OPT_FLAG(%LIST_DELETED#) THEN DO;
CMX2A:
         CALL PACKL( OLD# ) ALTRET( CMX3 );
         CALL GETLR( OLD# )  ALTRET( CMX3 );
         GOTO CMX2A;
         END;
 
CMX2B:
    IF IT.BAF$(OLD#) = ADDR(NIL) THEN
         IT.LNL(OLD#)= IT.LNH(OLD#);
CMX2C:
    CALL GETLY( OLD# )  ALTRET( CMX3 );
    GOTO CMX2C;
 
CMX3_ENTRY: ENTRY  ALTRET;
CMX3:
    CALL PUT_PLUS_CARD( IT.LNL(OLD#),IT.LNH(OLD#) );
CMX4:
    IF OPT_FLAG(%LIST_DELETED#) THEN DO;
         R4$= IT.BAL$(OLD#);
CMX4A:
         CALL OUTLN1;
         IF R4$ <= IT.BAH$(OLD#) THEN
              GOTO CMX4A;
         END;
CMX5:
    R4$= IT.BAL$(NEW#);
    IF R4$ ~= ADDR(NIL) THEN DO;
CMX5A:
         CALL OUTLN2;
         IF R4$ <= IT.BAH$(NEW#) THEN
              GOTO CMX5A;
         END;
CMX5B:
    CALL GETLY( NEW# )  ALTRET( CMY1 );
    CALL CLRPB;
    SUBSTR(LO_BUF,%PLLF,LO_LEN-%PLLF)=SUBSTR(IT.BFA$(NEW#)->BUF,0,IT.ARS(NEW#));
    IF IT.KEY(NEW#) > -1 THEN
         CALL OUTKEY( NEW#,IT.KEY(NEW#) );
CMX5D:
    CALL SNDPB( IT.BFA$(NEW#),IT.ARS(NEW#) );
    GOTO CMX5B;
 
CMY1:
    ALTRETURN;
 
END CMX2;
%EJECT;
OUTKEY: PROC( FILE#,THE_KEY );
DCL FILE#                    UBIN;
DCL THE_KEY                  UBIN;
 
       CALL BINCHAR( INT8,THE_KEY );
    IF IT.ORG(FILE#) = %KEYED# THEN DO;
       CALL EDITSTR( SUBSTR(INT8,0,4),0,4,'104'O,SUBSTR(INT8,0,4) );
       CALL INSERT( LO_BUF,%PLLF-11,9,SUBSTR(INT8,0,5),'.',SUBSTR(INT8,5,3) );
       END;
    ELSE DO;
       CALL EDITSTR( INT8,0,7,'107'O,INT8 );
       CALL INSERT( LO_BUF,%PLLF-11,5,SUBSTR(INT8,3) );
       END;
 
    RETURN;
 
END OUTKEY;
%EJECT;
ALLOCATE_BUFFERS: PROC  ALTRET;
 
    GDP.V.PAGES#= 3;
    CALL M$GDP( GDP )  ALTRET( DISASTER );
    IT.FIT$(OLD#)= GDP_.PTR$;        /* = ADDR of 1st Dynamic Page Acquired   */
    IT.FIT$(NEW#)= PINCRW(GDP_.PTR$,1024);/*ADDR of 2nd Dynamic Page Acquired */
    LO_BUF$= PINCRW(GDP_.PTR$,2048); /* = ADDR of 3rd Dynamic Page Acquired   */
    ME_BUF$= PINCRW(LO_BUF$,LO_LEN/4);
    RETURN;
 
DISASTER:
    ALTRETURN;
 
END ALLOCATE_BUFFERS;
%EJECT;
INIT_IT: PROC;
 
    IT.DCB#(OLD#)= DCBNUM(F$OLD);
    IT.DCB$(OLD#)= DCBADDR(DCBNUM(F$OLD));
    IT.IBR(OLD#)= 0;
    IT.LNL(OLD#)= 0;
    IT.BAL$(OLD#)= ADDR(NIL);
    IT.LNH(OLD#)= 0;
    IT.BAH$(OLD#)= ADDR(NIL);
    IT.LNF(OLD#)= 0;
    IT.BAF$(OLD#)= ADDR(NIL);
    IT.BAF_FLAG(OLD#)= 0;
    IT.LSZ(OLD#)=  -1;
    IT.BSZ(OLD#)=  -1;
    IT.KEY(OLD#)= -1;
    IT.MRS(OLD#)= 0;
 
    IT.DCB#(NEW#)= DCBNUM(F$NEW);
    IT.DCB$(NEW#)= DCBADDR(DCBNUM(F$NEW));
    IT.IBR(NEW#)= 0;
    IT.LNL(NEW#)= 0;
    IT.BAL$(NEW#)= ADDR(NIL);
    IT.LNH(NEW#)= 0;
    IT.BAH$(NEW#)= ADDR(NIL);
    IT.LNF(NEW#)= 0;
    IT.BAF$(NEW#)= ADDR(NIL);
    IT.BAF_FLAG(NEW#)= 0;
    IT.LSZ(NEW#)= -1;
    IT.BSZ(NEW#)= -1;
    IT.KEY(NEW#)= -1;
    IT.MRS(NEW#)= 0;
 
END INIT_IT;
%EJECT;
GET_STORAGE_BUF: PROC  ALTRET;
 
    PACK_= VECTOR(NIL);
    MEMORY= (IT.BSZ(OLD#)*4) + (IT.BSZ(NEW#)*4);
    CALL EXPAND( PACK_,MEMORY )  ALTRET( NOT_ENUFF_MEM );
SET:
    MBAS$= PACK_.PTR$;
    MEMH$= PACK_.PTR$;
    MWAD$= MBAS$;
    PACK_END$= PINCRC( PACK_.PTR$,PACK_.W1.VSIZE# );
 
    STK_= VECTOR(NIL);
    CALL EXPAND( STK_,4096 )  ALTRET( CANT_GET_STACK );
    STK$= STK_.PTR$;
    MAX_STK= (STK_.W1.VSIZE#+1) / 4;
    RETURN;
 
NOT_ENUFF_MEM:
    ME_BUF= '.. Can''t get memory for PACKing buffer';
    GOTO OOPS;
 
CANT_GET_STACK:
    ME_BUF= '.. Can''t get memory for the stack';
OOPS:
    CALL C$WRITE( ME_BUF,-ME_LEN,M$ME# );
    ALTRETURN;
 
END GET_STORAGE_BUF;
%EJECT;
PUT_MESG: PROC( MESG, LEN, CNT );
DCL MESG                     CHAR(LEN);
DCL LEN                      UBIN;
DCL CNT                      UBIN;
 
    CALL C$WRITE( MESG,LEN,M$LO# );
    IF ADDR(CNT) ~= ADDR(NIL) THEN
         CNT= CNT + 1;
 
END PUT_MESG;
%EJECT;
C$CLOSE: PROC( DCB#,RELEASE );
DCL DCB#                     SBIN;
DCL RELEASE                  UBIN;
 
    CLOSEF.V.DCB#= DCB#;
    IF ADDR(RELEASE) = ADDR(NIL) THEN
         CLOSEF.V.DISP#= %SAVE#;
    ELSE CLOSEF.V.DISP#= RELEASE;
    IF DCBADDR(DCB#)->F$DCB.FCD# THEN           /* Is the file OPEN?          */
        IF ITS_FSF THEN
            IF DCB# = OLD# THEN
                CALL XSA$CLOSE( CLOSEF,XSA_OLD )  ALTRET( OH_WELL );
            ELSE
                IF DCB# = NEW# THEN
                    CALL XSA$CLOSE( CLOSEF,XSA_NEW )  ALTRET( OH_WELL );
                ELSE
                    IF DCB# = DCBNUM(F$UPD) THEN
                        CALL XSA$CLOSE( CLOSEF,XSA_UPD )  ALTRET( OH_WELL );
                    ELSE
                        CALL M$CLOSE( CLOSEF )  ALTRET( OH_WELL );
        ELSE
            CALL M$CLOSE( CLOSEF )  ALTRET( OH_WELL );
OH_WELL:
    RETURN;
 
END C$CLOSE;
%EJECT;
C$MONERR: PROC( ERR#,DCB# );
DCL ERR#                     BIT(36);         /* Optional */
DCL DCB#                     UBIN;            /* Optional */
 
    IF ADDR(ERR#) = ADDR(NIL) THEN
         ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
    ELSE ERRCODE= ERR#;
    IF ADDR(DCB#) = ADDR(NIL) THEN
         ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
    ELSE ERRMSG.V.DCB#= DCB#;
    CALL M$ERRMSG( ERRMSG )  ALTRET( BYE );
BYE:
    RETURN;
 
END C$MONERR;
%EJECT;
C$WRITE: PROC( BUF,SIZ,DCB#,DVFC,DCB2#,ECHO );
DCL BUF                      CHAR(SYZ);
DCL SIZ                      SBIN;
DCL DCB#                     UBIN;
DCL DVFC                     CHAR(1);  /* Optional parameter */
DCL DCB2#                    UBIN;     /* Optional parameter */
DCL ECHO                     BIT(1);   /* Optional parameter */
 
DCL ORIGVFC                  CHAR(1)   STATIC;
DCL SYZ                      SBIN      STATIC;
 
    WRITEF.BUF_.BUF$= ADDR(BUF);
    IF SIZ < 0 THEN DO;                /* Should we suppress trailing blanks? */
         SYZ= -SIZ;
         CALL SEARCHR( SYZ,TABLEVAL,SKIP_BLANKS,BUF );
         IF SYZ = -SIZ THEN  /* WAS BUF BLANK? */
              SYZ= 1;
         ELSE SYZ= SYZ + 1;
         END;
    ELSE SYZ= SIZ;
    IF SYZ > 0 THEN
         WRITEF.BUF_.BOUND= SYZ - 1;
    ELSE WRITEF.BUF_= VECTOR(NIL);
    WRITEF.V.DCB#= DCB#;
    IF ADDR(DVFC) ~= ADDR(NIL) THEN DO;
         ORIGVFC= DCBADDR(DCB#)->F$DCB.DVFC#;   /* Save present DVFC          */
         DEVICEF.V.DVFC#= DVFC;
         DEVICEF.V.DCB#= DCB#;
         CALL M$DEVICE( DEVICEF );              /* Set specified DVFC         */
         CALL M$WRITE( WRITEF );                /* WRITE line with DVFC       */
         IF ADDR(DCB2#) ~= ADDR(NIL) THEN
              IF ADDR(ECHO) = ADDR(NIL) OR
                 ECHO  THEN DO;
                   DEVICEF.V.DCB#= DCB2#;
                   CALL M$DEVICE( DEVICEF );
                   WRITEF.V.DCB#= DCB2#;
                   CALL M$WRITE( WRITEF );
                   DEVICEF.V.DVFC#= ORIGVFC;
                   CALL M$DEVICE( DEVICEF );
                   END;
         DEVICEF.V.DCB#= DCB#;
         DEVICEF.V.DVFC#= ORIGVFC;
         CALL M$DEVICE( DEVICEF );              /* Restore previous DVFC      */
         END;
    ELSE DO;                                    /* WRITE the line             */
         CALL M$WRITE( WRITEF );
         IF ADDR(DCB2#) ~= ADDR(NIL) THEN
              IF ADDR(ECHO) = ADDR(NIL) OR
                   ECHO  THEN DO;
                   WRITEF.V.DCB#= DCB2#;
                   CALL M$WRITE( WRITEF );
                   END;
         END;
    RETURN;
 
END C$WRITE;
%EJECT;
PARSE_OPTIONS: PROC  ALTRET;
 
    PASS= 1;                                  /* Initialize PASS              */
    CMPR_OPTS.TEXT$= ADDR(TMP.ALL.OPTS);
    OPT_FLAG= '0'B;
    IF B$JIT.CCARS = B$JIT.CCDISP THEN
       TMP.USER.OPTS_LEN= 0;
    ELSE
       IF SUBSTR(B$JIT.CCBUF,B$JIT.CCARS-1,1) = ')' THEN
          TMP.USER.OPTS_LEN= B$JIT.CCARS - B$JIT.CCDISP - LENGTHC('()');
       ELSE
          TMP.USER.OPTS_LEN= B$JIT.CCARS - B$JIT.CCDISP - LENGTHC('(');
    TMP.USER.OPTS= SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1,TMP.USER.OPTS_LEN);
    TMP.DFLT.OPTS= ' ';
    TMP.ALL= TMP.USER;
    IF TMP.USER.OPTS_LEN < 1 THEN
       GOTO TRY_DEFAULTS;
PARSE_IT:
    CMPR_OPTS.NCHARS= TMP.ALL.OPTS_LEN;
    CALL X$PARSE( CMPR_OPTS )  ALTRET( PARSE_ERR );
    BLK1$= CMPR_OPTS.OUT$;
    DO I = 0 TO BLK1_NSUBLKS-1;
      BLK2$= BLK1_SUBLK$(I);
      IF BLK2_NSUBLKS > 0 THEN DO;
           BLK3$= BLK2_SUBLK$(0);
           LEN= BLK3$->P_SYM.COUNT;
           END;
      OPT_FLAG(BLK2$->P_SYM.CODE)= %YES#;
      DO CASE( BLK2$->P_SYM.CODE );
 
        CASE( %COMMENTS# );            /* C/omments=.quote                    */
          IF LEN > 130 THEN
                 /* COMMENT too long - Maximum is 130 */
               CALL PUT_MESG( COM_ERR,LENGTHC(COM_ERR),ERROR_CNT);
          ELSE COMMENT= BLK3_TEXT;
 
        CASE( %COMPRESS_BLANKS# );    /* C/ompress B/lanks                    */
          INT_BUF_NEEDED= %YES#;
          OPT_FLAG(%COMPRESS_LEADING#)= %YES#;
          OPT_FLAG(%COMPRESS_TRAILING#)= %YES#;
 
        CASE( %COMPRESS_LEADING# );  /* C/ompress L/eading B/lanks            */
          INT_BUF_NEEDED= %YES#;
 
        CASE( %COMPRESS_TRAILING# );
          INT_BUF_NEEDED= %YES#;
 
        CASE( %DONT_COMPRESS_BLANKS# );
          OPT_FLAG(%COMPRESS_BLANKS#)= %NO#;
 
        CASE( %DONT_COMPRESS_LEADING# );
          OPT_FLAG(%COMPRESS_LEADING#)= %NO#;
 
        CASE( %DONT_COMPRESS_TRAILING# );
           OPT_FLAG(%COMPRESS_TRAILING#)= %NO#;
 
        CASE( %DONT_IGNORE_BLANKS# );
          OPT_FLAG(%IGNORE_BLANKS#)= %NO#;
 
        CASE( %DONT_IGNORE_LEADING# );
          OPT_FLAG(%IGNORE_LEADING#)= %NO#;
 
        CASE( %DONT_IGNORE_TRAILING# );
          OPT_FLAG(%IGNORE_TRAILING#)= %NO#;
 
        CASE( %DONT_IGNORE_VFC# );
          OPT_FLAG(%IGNORE_VFC#)= %NO#;
          READF.V.STRPVFC#= %NO#;
 
        CASE( %DONT_LIST_DELETED# );
          OPT_FLAG(%LIST_DELETED#)= %NO#;
 
        CASE( %HOLD## );               /* H/old= ( .dec4 | A/ll )             */
          CALL CHARBIN( HOLD,BLK3_TEXT );
          IF HOLD <= 0 THEN
               /* HOLD value must be greater than zero */
               CALL PUT_MESG( HOLD_ERR,LENGTHC(HOLD_ERR),ERROR_CNT );
 
        CASE( %IGNORE_BLANKS# );
          OPT_FLAG(%IGNORE_LEADING#)= %YES#;
          OPT_FLAG(%IGNORE_TRAILING#)= %YES#;
          INT_BUF_NEEDED= %YES#;
 
        CASE( %IGNORE_LEADING# );
          INT_BUF_NEEDED= %YES#;
 
        CASE( %IGNORE_TRAILING# );
 
 
        CASE( %IGNORE_VFC# );
          READF.V.STRPVFC#= %YES#;
 
        CASE( %NO_DEFAULTS# );
          PASS= 2;                     /* Pretend we're on pass 2             */
 
        CASE( %NO_DIFFERENCE# );
          OPT_FLAG(%DIFFERENCE#)= %NO#;
 
        CASE( %NO_PATCH# );
          OPT_FLAG(%PATCH#)= %NO#;
 
        CASE( %NO_STATISTICS# );
          OPT_FLAG(%STATISTICS#)= %NO#;
 
        CASE( %NO_UPPERCASE# );
          OPT_FLAG(%UPPERCASE#)= %NO#;
 
        CASE( %PATCH# );               /* P/atch                              */
          INT_BUF_NEEDED= %YES#;
 
        CASE( %UPPERCASE# );
          INT_BUF_NEEDED= %YES#;
 
        CASE( %DIFFERENCE#,            /* D/ifference                         */
              %LIST_DELETED#,          /* L/ist D/eleted                      */
              %STATISTICS# );          /* S/tatistics                         */
        END;
      END;
 
    IF PASS = 1 THEN DO;
TRY_DEFAULTS:
       PASS= 2;
       GET_DEFAULTS.VALUE_= VECTOR(TMP.DFLT);
       CALL M$CMDVAR( GET_DEFAULTS )  ALTRET( PUT_OPTIONS );
       IF TMP.USER.OPTS = ' ' THEN
          TMP.ALL= TMP.DFLT;
       ELSE DO;
          CALL CONCAT( TMP.ALL.OPTS,SUBSTR(TMP.DFLT.OPTS,0,TMP.DFLT.OPTS_LEN),
                                    ',',
                                    SUBSTR(TMP.USER.OPTS,0,TMP.USER.OPTS_LEN) );
          TMP.ALL.OPTS_LEN=TMP.DFLT.OPTS_LEN + LENGTHC(',') + TMP.USER.OPTS_LEN;
          END;
       GOTO PARSE_IT;
       END;
 
PUT_OPTIONS:
    CALL CONCAT( TMP.BUF,'CMPR C00 here (9/6/88), Options used: ',
                         TMP.ALL.OPTS );
    IF TMP.ALL.OPTS = ' ' THEN
       CALL INDEX( I,')',TMP.BUF );
    ELSE
       I= -LENGTHC(TMP.BUF);
    CALL C$WRITE( TMP.BUF,I+1,M$ME# );
 
    IF NOT LO_IS_ME THEN DO;
       IF TMP.ALL.OPTS = ' ' THEN
          CALL CONCAT( LO_BUF,'Current FMA was .',B$JIT.FACCN,'   ',
                              'Options used: None' );
       ELSE
          CALL CONCAT( LO_BUF,'Current FMA was .',B$JIT.FACCN,'   ',
                              'Options used: ',
                              TMP.ALL.OPTS );
       CALL INDEX( I,')',LO_BUF );
       IF I = LENGTHC(LO_BUF) THEN
          I= -I;
       CALL C$WRITE( LO_BUF,I,M$LO# );
       LO_BUF= ' ';
       CALL C$WRITE( ' ',LENGTHC(' '),M$LO# );
       END;
 
    RETURN;
PARSE_ERR:
    ME_BUF= ' ';
    SUBSTR(ME_BUF,CMPR_OPTS.HI_CHAR+B$JIT.CCDISP+1,1)= '^';
    CALL C$WRITE( ME_BUF,CMPR_OPTS.HI_CHAR+B$JIT.CCDISP+2,M$ME# );
    ME_BUF= 'Invalid CMPR option specified; Parsing stopped here';
    CALL C$WRITE( ME_BUF,-LO_LEN,M$ME# );
      SET_STEPCC.V.STEPCC#= 4;         /* Indicate unexpected error occurred  */
    ALTRETURN;
 
END PARSE_OPTIONS;
%EJECT;
SET_FDS: PROC;
 
    FDS_BUFSIZE= ME_LEN;
    F_FDS.BUF_= VECTOR(FDS_BUF);
    RETURN;
 
END SET_FDS;
%EJECT;
COMPRESS: PROC( SRCE,SRCE_LEN,DEST,DEST_LEN );
DCL SRCE                     CHAR(SRC_LEN);
DCL SRCE_LEN                 UBIN;
DCL DEST                     CHAR(DEST_LEN);
DCL DEST_LEN                 UBIN;
 
DCL SRC_LEN                  UBIN;
 
    SRC_LEN= SRCE_LEN;
    IF OPT_FLAG(%PATCH#) THEN
       CALL INDEX( SRC_LEN,'"',SRCE );
 
    DEST_LEN= 0;
    SUBSTR(DEST,0,SRCE_LEN)= ' ';
    CALL SEARCH( BEG,TABLEVAL,SKIP_BLANKS,SRCE )  WHENALTRETURN DO;
       IF OPT_FLAG(%COMPRESS_LEADING#)  THEN
          DEST_LEN= 1;
       ELSE
          IF OPT_FLAG(%IGNORE_LEADING#)  OR
             OPT_FLAG(%IGNORE_TRAILING#)  THEN
             DEST_LEN= 0;
          ELSE
             DEST_LEN= SRC_LEN;
       GOTO RE_TURN;
       END;
 
    IF OPT_FLAG(%IGNORE_LEADING#) THEN DO;
       IF OPT_FLAG(%IGNORE_VFC#) = %YES# THEN
          BEG = 1;
       ELSE
          IF OPT_FLAG(%IGNORE_VFC#) = %NO# THEN
             BEG = 0;
NEXT_1:
       CALL INDEX( X,' ',SRCE,BEG )  WHENALTRETURN DO;
          IF X-1 >= BEG THEN DO;
             SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
             DEST_LEN= DEST_LEN + X - BEG;
             END;
          GOTO SHOULD_WE_XLATE;
          END;
       SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
       DEST_LEN= DEST_LEN + X - BEG;
       CALL SEARCH( BEG,TABLEVAL,SKIP_BLANKS,SRCE,X )  WHENALTRETURN DO;
          GOTO SHOULD_WE_XLATE;
          END;
       GOTO NEXT_1;
       END;
    ELSE
       IF OPT_FLAG(%COMPRESS_LEADING#) THEN
          IF BEG > 0 THEN
             DEST_LEN= 1;
          ELSE
             ;
       ELSE
          BEG= 0;
 
    IF OPT_FLAG(%IGNORE_BLANKS#) THEN DO;
NEXT_2:
       CALL INDEX( X,' ',SRCE,BEG )  WHENALTRETURN DO;
          IF X-1 >= BEG THEN DO;
             SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
             DEST_LEN= DEST_LEN + X - BEG;
             END;
          GOTO SHOULD_WE_XLATE;
          END;
       SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
       DEST_LEN= DEST_LEN + X - BEG;
       CALL SEARCH( BEG,TABLEVAL,SKIP_BLANKS,SRCE,X )  WHENALTRETURN DO;
          GOTO SHOULD_WE_XLATE;
          END;
       GOTO NEXT_2;
       END;
    ELSE
       IF OPT_FLAG(%COMPRESS_BLANKS#) THEN DO;
NEXT_3:
          CALL INDEX( X,'  ',SRCE,BEG )  WHENALTRETURN DO;
             IF X-1 >= BEG THEN DO;
                SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
                DEST_LEN= DEST_LEN + X - BEG;
                END;
             GOTO SHOULD_WE_XLATE;
             END;
          SUBSTR(DEST,DEST_LEN,X-BEG)= SUBSTR(SRCE,BEG,X-BEG);
          DEST_LEN= DEST_LEN + X - BEG;
          CALL SEARCH( BEG,TABLEVAL,SKIP_BLANKS,SRCE,X )  WHENALTRETURN DO;
             GOTO SHOULD_WE_XLATE;
             END;
          GOTO NEXT_3;
          END;
       ELSE DO;
          SUBSTR(DEST,DEST_LEN,SRC_LEN-BEG)= SUBSTR(SRCE,BEG,SRC_LEN-BEG);
          DEST_LEN= DEST_LEN + SRC_LEN - BEG;
          END;
 
SHOULD_WE_XLATE:
    IF OPT_FLAG(%UPPERCASE#) THEN DO;
       CALL XLATE( DEST,UPPERS,SRCE );
       END;
 
RE_TURN:
    RETURN;
 
END COMPRESS;
%EJECT;
PUT_PLUS_CARD: PROC( FIRST#,LAST# );
DCL FIRST#                   UBIN;
DCL LAST#                    UBIN;
 
    CALL CLRPB;
    IF ADDR(FIRST#) ~= ADDR(NIL) THEN DO;  /* Any arguments?                  */
         SUBSTR(LO_BUF,%PLLF,1)= '+';
         R1= %PLLF + LENGTHC('+');
         R3= FIRST#;
         CALL CVDLR( LO_BUF );
         IF ADDR(LAST#) ~= ADDR(NIL) THEN DO;  /* Is there a LAST#?           */
              SUBSTR(LO_BUF,R1,1)= ',';
              R1= R1 + LENGTHC(',');
              R3= LAST#;
              CALL CVDLR( LO_BUF );
              END;
         END;
    ELSE DO;                           /* Generate a +END                     */
         SUBSTR(LO_BUF,%PLLF,4)= '+END';
         R1= %PLLF + LENGTHC('+END');
         END;
    IF OPT_FLAG(%COMMENTS#) THEN DO;
         CALL INSERT( LO_BUF,R1,,'  ',COMMENT );
         CALL SEARCHR( R1,TABLEVAL,SKIP_BLANKS,LO_BUF );
         R1= R1 + 1;
         END;
    IF LO_IS_SET THEN
         CALL C$WRITE( LO_BUF,R1,M$LO# );
    IF UPD_IS_SET THEN DO;
         WRITE_UPD.BUF_= VECTOR(SUBSTR(LO_BUF,%PLLF,R1-%PLLF));
         IF ITS_FSF THEN
             CALL XSA$WRITE( WRITE_UPD,XSA_UPD );
         ELSE
             CALL M$WRITE( WRITE_UPD );
         END;
    PLUS_CNT= PLUS_CNT + 1;
    UPD_CNT= UPD_CNT + 1;
    RETURN;
 
END PUT_PLUS_CARD;
%EJECT;
START_UP: PROC  ALTRET;
 
    F$NEW$= DCBADDR(DCBNUM(F$NEW));
    F$OLD$= DCBADDR(DCBNUM(F$OLD));
    F$UPD$= DCBADDR(DCBNUM(F$UPD));
    M$LO$=  DCBADDR(DCBNUM(M$LO));
    M$ME$=  DCBADDR(DCBNUM(M$ME));
    LO_WIDTH= M$LO$->F$DCB.RECL#;
 
    CALL M$OPEN( OPEN_ME )  ALTRET( DISASTER );
 
    IF F$UPD$->F$DCB.AMR# THEN DO;     /* Is F$UPD SET?                       */
         IF M$LO$->F$DCB.AMR# THEN     /* Is M$LO SET?                        */
              LO_IS_SET= %YES#;        /* Yep.  Take note of the fact         */
         ELSE LO_IS_SET= %NO#;         /* Nope.  Don't WRITE to M$LO          */
         END;
    ELSE LO_IS_SET= %YES#;             /* WRITE to M$LO only                  */
    CALL INDEX( TMP1,'?',F$OLD$->F$DCB.NAME#.C )  WHENALTRETURN DO;
       IF F$OLD$->F$DCB.NAME#.C = ' ' THEN
          TMP1= 0;
       END;
    CALL INDEX( TMP2,'?',F$NEW$->F$DCB.NAME#.C )  WHENALTRETURN DO;
       IF F$NEW$->F$DCB.NAME#.C = ' ' THEN
          TMP2= 0;
       END;
    CALL INDEX( TMP3,'?',F$UPD$->F$DCB.NAME#.C )  WHENALTRETURN DO;
       IF (F$UPD$->F$DCB.NAME#.C = ' '  OR
           F$UPD$->F$DCB.NAME#.C = '*G')  AND
           NOT F$UPD$->F$DCB.AMR# THEN
          TMP3= 0;
       END;
    CALL INDEX( TMP4,'?',M$LO$->F$DCB.NAME#.C )   WHENALTRETURN DO;
       IF M$LO$->F$DCB.NAME#.C = ' ' THEN
          TMP4= 0;
       END;
 
    IF (TMP1 < LENGTHC(F$OLD$->F$DCB.NAME#.C)) OR
       (F$OLD$->F$DCB.ASN# = %DEVICE#)  THEN
       IF (TMP2 < LENGTHC(F$NEW$->F$DCB.NAME#.C))  OR
          (F$NEW$->F$DCB.ASN# = %DEVICE#)  THEN
          IF (TMP3 < LENGTHC(F$UPD$->F$DCB.NAME#.C))  OR
             (F$UPD$->F$DCB.ASN# = %DEVICE#)  THEN
             IF (TMP4 < LENGTHC(M$LO$->F$DCB.NAME#.C))  OR
                (M$LO$->F$DCB.ASN# = %DEVICE#)  THEN DO;
                IF B$JIT.PRFLAGS.SI  OR  B$JIT.PRFLAGS.UI  OR
                   B$JIT.PRFLAGS.OU  OR  B$JIT.PRFLAGS.LS THEN
                   CALL C$WRITE( '.. Sorry, at least one of the fids specified MUST be non-wildcarded.',68,M$ME# );
                ELSE
                   GOTO RE_TURN;
                QUIT_FLAG= %YES#;             /* Tell "main" not to print msg */
                GOTO DISASTER;
                END;
             ELSE
                PRI_NAME= M$LO$->F$DCB.NAME#;
          ELSE
             PRI_NAME= F$UPD$->F$DCB.NAME#;
       ELSE
          PRI_NAME= F$NEW$->F$DCB.NAME#;
    ELSE
       PRI_NAME= F$OLD$->F$DCB.NAME#;
 
    IF TMP1 < LENGTHC(F$OLD$->F$DCB.NAME#.C) THEN DO;
       CALL CONCAT( BUILT_FID.NAME#,
                       SUBSTR(F$OLD$->F$DCB.NAME#.C,0,TMP1),
                       SUBSTR(PRI_NAME.NAME#,0,PRI_NAME.L#),
                       SUBSTR(F$OLD$->F$DCB.NAME#.C,TMP1+1) );
       CALL INDEX( I,' ',BUILT_FID.NAME# );
       BUILT_FID.L#= I;
       MERGE_OLD.NAME_= VECTOR(BUILT_FID);
       CALL M$OPEN( MERGE_OLD );
       END;
 
    IF TMP2 < LENGTHC(F$NEW$->F$DCB.NAME#.C) THEN DO;
       CALL CONCAT( BUILT_FID.NAME#,
                       SUBSTR(F$NEW$->F$DCB.NAME#.C,0,TMP2),
                       SUBSTR(PRI_NAME.NAME#,0,PRI_NAME.L#),
                       SUBSTR(F$NEW$->F$DCB.NAME#.C,TMP2+1) );
       CALL INDEX( I,' ',BUILT_FID.NAME# );
       BUILT_FID.L#= I;
       MERGE_NEW.NAME_= VECTOR(BUILT_FID);
       CALL M$OPEN( MERGE_NEW );
       END;
 
    IF F$UPD$->F$DCB.AMR#  AND
       TMP3 < LENGTHC(F$UPD$->F$DCB.NAME#.C)  AND
       F$UPD$->F$DCB.ASN# ~= %DEVICE#  THEN DO;
       IF F$UPD$->F$DCB.NAME#.C = '*G' THEN
          BUILT_FID.NAME#= PRI_NAME.NAME#;
       ELSE
          CALL CONCAT( BUILT_FID.NAME#,
                          SUBSTR(F$UPD$->F$DCB.NAME#.C,0,TMP3),
                          SUBSTR(PRI_NAME.NAME#,0,PRI_NAME.L#),
                          SUBSTR(F$UPD$->F$DCB.NAME#.C,TMP3+1) );
       CALL INDEX( I,' ',BUILT_FID.NAME# );
       BUILT_FID.L#= I;
       MERGE_UPD.NAME_= VECTOR(BUILT_FID);
       CALL M$OPEN( MERGE_UPD );
       END;
 
    IF M$LO$->F$DCB.AMR#  AND
       TMP4 < LENGTHC(M$LO$->F$DCB.NAME#.C)  AND
       M$LO$->F$DCB.ASN# ~= %DEVICE#  THEN DO;
       CALL CONCAT( BUILT_FID.NAME#,
                       SUBSTR(M$LO$->F$DCB.NAME#.C,0,TMP4),
                       SUBSTR(PRI_NAME.NAME#,0,PRI_NAME.L#),
                       SUBSTR(M$LO$->F$DCB.NAME#.C,TMP4+1) );
       CALL INDEX( I,' ',BUILT_FID.NAME# );
       BUILT_FID.L#= I;
       MERGE_LO.NAME_= VECTOR(BUILT_FID);
       CALL M$OPEN( MERGE_LO );
       END;
 
 
    IF M$LO$->F$DCB.AMR# THEN          /* Is M$LO SET?                        */
         CALL M$OPEN( OPEN_LO )  ALTRET( DISASTER );
    ELSE CALL M$OPEN( OPEN_LO_TO_ME )  ALTRET( DISASTER );
 
    CALL M$CORRES( LOVSME )  ALTRET( LO_EQ_ME );
    LO_IS_ME= %NO#;
LO_EQ_ME:
 
    CALL M$UNFID( UNFID_OLD )  ALTRET( DISASTER );
    IF SUBSTR(OLD_TEXTFID,OLD_FID_LEN-1,1) = '.' THEN DO;
         OLD_FID_LEN= OLD_FID_LEN - 1;
         SUBSTR(OLD_TEXTFID,OLD_FID_LEN,1)= ' ';
         END;
 
    CALL M$UNFID( UNFID_NEW )  ALTRET( DISASTER );
    IF SUBSTR(NEW_TEXTFID,NEW_FID_LEN-1,1) = '.' THEN DO;
         NEW_FID_LEN= NEW_FID_LEN - 1;
         SUBSTR(NEW_TEXTFID,NEW_FID_LEN,1)= ' ';
         END;
 
    CALL BUILD_TITLE;
 
    CALL M$INT( BREAK_CNTRL )  ALTRET( DISASTER );
RE_TURN:
    RETURN;
 
DISASTER:
    ALTRETURN;
 
END START_UP;
%EJECT;
PUT_STATS: PROC;
 
    VEC1_= VECTOR(DCBS(OLD#));
    VEC2_= VECTOR(IT.BSZ(OLD#));
    VEC3_= VECTOR(IT.MRS(OLD#));
    /* Input buffer for %A was %D bytes; Longest record read was %D bytes. */
    CALL X$WRITE( F_FDS,FMTVEC8_,VEC1_,VEC2_,VEC3_ );
 
    VEC1_= VECTOR(DCBS(NEW#));
    VEC2_= VECTOR(IT.BSZ(NEW#));
    VEC3_= VECTOR(IT.MRS(NEW#));
    /* Input buffer for %A was %D bytes; Longest record read was %D bytes. */
    CALL X$WRITE( F_FDS,FMTVEC8_,VEC1_,VEC2_,VEC3_ );
 
    TMP1= POFFC( MEMH$,PACK_.PTR$ );
    TMP2= PACK_.W1.VSIZE#+1;
    TMP3= TMP2 / 4096;
    VEC1_= VECTOR(TMP1);
    VEC2_= VECTOR(TMP2);
    VEC3_= VECTOR(TMP3);
    /* %D bytes of the %D byte (%Dk) packing buffer were used. */
    CALL X$WRITE( F_FDS,FMTVEC9_,VEC1_,VEC2_,VEC3_ );
 
    /* MINIMUM= %D                                                            */
    CALL X$WRITE( F_FDS,FMTVEC10_,VECTOR(HOLD) );
 
    IF STKOVFC > 0 THEN DO;
         /* %D memory overflow(s) occurred.                                   */
         CALL X$WRITE( F_FDS,FMTVEC11_,VECTOR(STKOVFC) );
         END;
    RETURN;
 
END PUT_STATS;
%EJECT;
HANDLE_BREAK: PROC;
 
    CALL C$WRITE( ' ',LENGTHC(' '),M$ME# );
    BROKEN= 0;
    TMP1= IT.LNH(OLD#);
    IF IT.LNL(OLD#) > 0 THEN
         TMP3= IT.LNL(OLD#) - 1;
    ELSE TMP3= 0;
    TMP4= TMP1 - TMP3;
    VEC1_= VECTOR(TMP1);
    VEC2_= VECTOR(SUBSTR(OLD_TEXTFID,0,OLD_FID_LEN));
    VEC3_= VECTOR(TMP3);
    VEC4_= VECTOR(TMP4);
    IF IT.BAF$(OLD#) ~= ADDR(NIL) THEN
         IF IT.IBR(OLD#) >= 0 THEN
              CALL X$WRITE( F_FDS,FMTVEC13_,VEC1_,VEC2_,VEC3_,VEC4_ );
         ELSE CALL X$WRITE( F_FDS,FMTVEC12_,VEC1_,VEC2_,VEC3_,VEC4_ );
    ELSE IF IT.IBR(OLD#) >= 0 THEN
              CALL X$WRITE( F_FDS,FMTVEC15_,VEC1_,VEC2_ );
         ELSE CALL X$WRITE( F_FDS,FMTVEC14_,VEC1_,VEC2_ );
 
    TMP1= IT.LNH(NEW#);
    IF IT.LNL(NEW#) > 0 THEN
         TMP3= IT.LNL(NEW#) - 1;
    ELSE TMP3= 0;
    TMP4= TMP1 - TMP3;
    VEC1_= VECTOR(TMP1);
    VEC2_= VECTOR(SUBSTR(NEW_TEXTFID,0,NEW_FID_LEN));
    VEC3_= VECTOR(TMP3);
    VEC4_= VECTOR(TMP4);
    IF IT.BAF$(NEW#) ~= ADDR(NIL) THEN
         IF IT.IBR(NEW#) >= 0 THEN
              CALL X$WRITE( F_FDS,FMTVEC13_,VEC1_,VEC2_,VEC3_,VEC4_ );
         ELSE CALL X$WRITE( F_FDS,FMTVEC12_,VEC1_,VEC2_,VEC3_,VEC4_ );
    ELSE IF IT.IBR(NEW#) >= 0 THEN
              CALL X$WRITE( F_FDS,FMTVEC15_,VEC1_,VEC2_ );
         ELSE CALL X$WRITE( F_FDS,FMTVEC14_,VEC1_,VEC2_ );
 
    RETURN;
 
END HANDLE_BREAK;
%EJECT;
BUILD_TITLE: PROC;
 
    CALL M$TIME( GET_TIME );
    TYME.DAYU(1)=  TYME.DAYU(1) + (ASCBIN('a')-ASCBIN('A')); /* DAY -> Day    */
    TYME.DAYU(2)=  TYME.DAYU(2) + (ASCBIN('a')-ASCBIN('A'));
    TYME.DATEU(1)= TYME.DATEU(1) + (ASCBIN('a')-ASCBIN('A'));/* MON -> Mon    */
    TYME.DATEU(2)= TYME.DATEU(2) + (ASCBIN('a')-ASCBIN('A'));
 
    IF LO_WIDTH = 0 THEN
         IF M$LO$->F$DCB.WIDTH# < 80 THEN
              IF M$LO$->F$DCB.ASN# = %DEVICE# THEN
                   LO_WIDTH= 80;
              ELSE LO_WIDTH= 108;
         ELSE IF M$LO$->F$DCB.WIDTH# = 132  AND
                 M$LO$->F$DCB.LINES# = 39 THEN /* LADC paper for binders?     */
                   LO_WIDTH= 108;
              ELSE LO_WIDTH= M$LO$->F$DCB.WIDTH#;
    ELSE IF LO_WIDTH < 80 THEN
              LO_WIDTH= 80;
    IF LO_WIDTH > 132 THEN
         LO_WIDTH= 132;
    USR_HDR.LEN= 132;
    CALL CONCAT( USR_HDR.TITLE,'CMPR.X of ',SUBSTR(OLD_TEXTFID,0,OLD_FID_LEN),
                        ' and ',SUBSTR(NEW_TEXTFID,0,NEW_FID_LEN),
                        DAY_DATE_TIME );
    LEN= LENGTHC('CMPR.X of  and ') + OLD_FID_LEN + NEW_FID_LEN +
         LENGTHC(DAY_DATE_TIME);
    VLP_HDR.CTL.RESETPAGE#= %YES#;
    IF NOT LO_IS_ME THEN
         CALL M$DEVICE( NEW_LO_PAGE );
    VLP_HDR.CTL.RESETPAGE#= %NO#;
    IF LEN + LENGTHC(' Page xxx') < LO_WIDTH THEN DO;
         SUBSTR(USR_HDR.TITLE,LO_WIDTH-LENGTHC('Page xxx')-1)= 'Page';
         VLP_HDR.CTL.COUNT#= LO_WIDTH - LENGTHC('999');
         END;
    ELSE DO;
         SUBSTR(USR_HDR.TITLE,LEN)= ' Page';
         VLP_HDR.CTL.COUNT#= LEN + LENGTHC(' Page  ');
         END;
    CALL M$DEVICE( NEW_TITLE );
    RETURN;
 
END BUILD_TITLE;
%EJECT;
TEST_FOR_FSF: PROC  ALTRET;
 
 
    IF NOT IT.DCB$(OLD#)->F$DCB.AMR# THEN       /* Is DCB set?                */
         GOTO NOT_SET;                          /* Nope!  Go bitch, then exit */
    IF SUBSTR(IT.DCB$(OLD#)->F$DCB.NAME#.C,0,1) = '*'  OR
       (NOT ITS_FSF)  THEN         /* This is a band-aid and will be removed! */
         GOTO NOT_FSF;
    FIT$= IT.FIT$(OLD#);
    OPENF.V.DCB#= IT.DCB#(OLD#);
    OPENF.FPARAM_= VECTOR(FIT$->FPARAM);
    OPENF.V.OPER.TEST#= %YES#;
    CALL M$OPEN(OPENF)  ALTRET( NOT_FSF );
    CODE= 3;
    CALL XSF$LOCCODT( FIT$,CODE )  ALTRET( NOT_FSF );
    IF FIT$->CODE03.RCSZ > 1 THEN
         GOTO NOT_FSF;
    IT.BSZ(OLD#)= (FIT$->CODE03.RCSZ+1) * 4096;        /* Yep, Calc max needed*/
    IT.LSZ(OLD#)= IT.BSZ(OLD#);
 
    IF NOT IT.DCB$(NEW#)->F$DCB.AMR# THEN       /* Is DCB set?                */
         GOTO NOT_SET;                          /* Nope!  Go bitch, then exit */
    IF SUBSTR(IT.DCB$(NEW#)->F$DCB.NAME#.C,0,1) = '*' THEN
         GOTO NOT_FSF;
    FIT$= IT.FIT$(NEW#);
    OPENF.V.DCB#= IT.DCB#(NEW#);
    OPENF.FPARAM_= VECTOR(FIT$->FPARAM);
    CALL M$OPEN(OPENF)  ALTRET( NOT_FSF );
    CODE= 3;
    CALL XSF$LOCCODT( FIT$,CODE )  ALTRET( NOT_FSF );
    IF FIT$->CODE03.RCSZ > 1 THEN
         GOTO NOT_FSF;
    IT.BSZ(NEW#)= (FIT$->CODE03.RCSZ+1) * 4096;        /* Yep, Calc max needed*/
    IT.LSZ(NEW#)= IT.BSZ(NEW#);
 
GET_FSF_BUFS:
    CALL EXPAND( XSA_,61440 )  ALTRET( NOT_FSF );
    XSA_OLD.KBUF_.BOUND= 4096-1;
    XSA_OLD.KBUF_.BUF$= XSA_.PTR$;
    XSA_OLD.BBUF_.BOUND= (4*4096)-1;
    XSA_OLD.BBUF_.BUF$= PINCRC(XSA_OLD.KBUF_.BUF$,XSA_OLD.KBUF_.BOUND+1);
    XSA_NEW.KBUF_.BOUND= 4096-1;
    XSA_NEW.KBUF_.BUF$= PINCRC(XSA_OLD.BBUF_.BUF$,XSA_OLD.BBUF_.BOUND+1);
    XSA_NEW.BBUF_.BOUND= (4*4096)-1;
    XSA_NEW.BBUF_.BUF$= PINCRC(XSA_NEW.KBUF_.BUF$,XSA_NEW.KBUF_.BOUND+1);
    XSA_UPD.KBUF_.BOUND= 4096-1;
    XSA_UPD.KBUF_.BUF$= PINCRC(XSA_NEW.BBUF_.BUF$,XSA_NEW.BBUF_.BOUND+1);
    XSA_UPD.BBUF_.BOUND= (4*4096)-1;
    XSA_UPD.BBUF_.BUF$= PINCRC(XSA_UPD.KBUF_.BUF$,XSA_UPD.KBUF_.BOUND+1);
    DO WHILE('0'B);
NOT_FSF:
      ITS_FSF= %NO#;
      END;
 
OPN_UPD:
 
    IF F$UPD$->F$DCB.AMR# THEN DO;     /* Is F$UPD SET?                       */
         UPD_IS_SET= %YES#;            /* Yep.  Take note of the fact         */
         CALL M$UNFID( UNFID_UPD )  ALTRET( DISASTER );
         IF SUBSTR(UPD_TEXTFID,UPD_FID_LEN-1,1) = '.' THEN DO;
              UPD_FID_LEN= UPD_FID_LEN - 1;
              SUBSTR(UPD_TEXTFID,UPD_FID_LEN,1)= ' ';
              END;
         IF ITS_FSF THEN
             CALL XSA$OPEN(OPEN_UPD,XSA_UPD) ALTRET( DISASTER ); /* OPEN F$UPD*/
         ELSE
             CALL M$OPEN( OPEN_UPD )  ALTRET( DISASTER );
         IF M$LO$->F$DCB.AMR# THEN     /* Is M$LO SET?                        */
              LO_IS_SET= %YES#;        /* Yep.  Take note of the fact         */
         ELSE LO_IS_SET= %NO#;         /* Nope.  Don't WRITE to M$LO          */
         END;
    ELSE LO_IS_SET= %YES#;             /* WRITE to M$LO only                  */
 
NOT_SET:
    RETURN;
 
DISASTER:
    ALTRETURN;
 
END TEST_FOR_FSF;
%EJECT;
DUMP: PROC;
 
DCL DUMPFMT1                 CHAR(0)   STATIC INIT(
    '%A %3D %6O-%1O %4D %>A');
DCL DUMPFMT2                 CHAR(80)  STATIC INIT(' ');
 
DCL DUMPFMT1_                BIT(72) STATIC DALIGNED INIT(VECTOR(DUMPFMT1));
DCL DUMPFMT2_                BIT(72) STATIC DALIGNED INIT(VECTOR(DUMPFMT2));
DCL VEC1_                    BIT(72)   DALIGNED;
DCL VEC2_                    BIT(72)   DALIGNED;
DCL VEC3_                    BIT(72)   DALIGNED;
DCL VEC4_                    BIT(72)   DALIGNED;
DCL VEC5_                    BIT(72)   DALIGNED;
DCL VEC6_                    BIT(72)   DALIGNED;
 
DCL FILES                    CHAR(2)   STATIC INIT('ON');
 
DCL NEW_CNT                  SBIN;
DCL OLD_CNT                  SBIN;
DCL TMPSIZ                   SBIN;
DCL TMPBIT                   SBIN;
DCL DUMPSIZ                  SBIN;
DCL HIGH$                    PTR;
DCL PTR$                     PTR;
DCL 1 P REDEF PTR$,
      2 WORD#                UBIN(18)  UNAL,
      2 BIT#                 UBIN(2)   UNAL,
      2 *                    UBIN(16)  UNAL;
 
    IF IT.BAF$(%OLD#) > IT.BAF$(%NEW#) THEN
       HIGH$= IT.BAF$(%OLD#);
    ELSE
       HIGH$= IT.BAF$(%NEW#);
    IF IT.BAL$(%OLD#) < IT.BAL$(%NEW#) THEN
       PTR$= IT.BAL$(%OLD#);
    ELSE
       PTR$= IT.BAL$(%NEW#);
    OLD_CNT= IT.LNL(%OLD#);
    NEW_CNT= IT.LNL(%NEW#);
 
    DO WHILE( PTR$ <= HIGH$ );
       VEC1_= VECTOR(SUBSTR(FILES,PTR$->ENTREE.FILE,1));
       IF PTR$->ENTREE.FILE = %OLD# THEN
          VEC2_= VECTOR(OLD_CNT);
       ELSE
          VEC2_= VECTOR(NEW_CNT);
       VEC3_= VECTOR(P.WORD#);
       TMPBIT= P.BIT#;
       VEC4_= VECTOR(TMPBIT);
       TMPSIZ= PTR$->ENTREE.SIZ;
       VEC5_= VECTOR(TMPSIZ);
       DUMPSIZ= MINIMUM(PTR$->ENTREE.SIZ,92);
       VEC6_= VECTOR(SUBSTR(PTR$->ENTREE.REC,0,DUMPSIZ-4));
       CALL X$WRITE( F_FDS,DUMPFMT1_,VEC1_,VEC2_,VEC3_,VEC4_,VEC5_,VEC6_ );
       IF PTR$->ENTREE.FILE = %OLD# THEN
          OLD_CNT= OLD_CNT + 1;
       ELSE
          NEW_CNT= NEW_CNT + 1;
       PTR$= PINCRC( PTR$,PTR$->ENTREE.SIZ );
       END;
RE_TURN:
    RETURN;
 
END DUMP;
%EJECT;
DUMPSTK: PROC;
 
DCL STKFMT1                  CHAR(0)   STATIC INIT(
    'LINE# F D BLK OLD NEW');
DCL STKFMT2                  CHAR(0)   STATIC INIT(
    '%5D %D %D%4D%4D%4D');
 
DCL FMT1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(STKFMT1));
DCL FMT2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(STKFMT2));
 
DCL VEC1_                    BIT(72) STATIC DALIGNED INIT(VECTOR(I));
DCL VEC2_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP2));
DCL VEC3_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP3));
DCL VEC4_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP4));
DCL VEC5_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP5));
DCL VEC6_                    BIT(72) STATIC DALIGNED INIT(VECTOR(TMP6));
 
DCL I                        SBIN STATIC;
DCL TMP2                     SBIN STATIC;
DCL TMP3                     SBIN STATIC;
DCL TMP4                     SBIN STATIC;
DCL TMP5                     SBIN STATIC;
DCL TMP6                     SBIN STATIC;
 
    CALL X$WRITE( F_FDS,FMT1_ );
    DO I=0 TO STKP-1;
       IF LINE.FLAG(I) THEN
          TMP2= 1;
       ELSE
          TMP2= 0;
       IF LINE.DEFERRED(I) THEN
          TMP3= 1;
       ELSE
          TMP3= 0;
       TMP4= LINE.BLK_CNT(I);
       TMP5= LINE.OLD_NUM(I);
       TMP6= LINE.NEW_NUM(I);
       CALL X$WRITE( F_FDS,FMT2_,VEC1_,VEC2_,VEC3_,VEC4_,VEC5_,VEC6_ );
       END;
RE_TURN:
    RETURN;
 
END DUMPSTK;
END CMPR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
BREAK: PROC ASYNC;
 
%INCLUDE CP_6;
 
%FPT_TRMPRG (FPTN=RESET_BRK_CNT,
             RSTBRK=YES);
 
DCL BROKEN                   UBIN      SYMREF;
 
    BROKEN= BROKEN + 1;
    CALL M$TRMPRG( RESET_BRK_CNT );
    RETURN;
 
END BREAK;
