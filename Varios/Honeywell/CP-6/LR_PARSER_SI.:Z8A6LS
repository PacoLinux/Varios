

09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      1    
    1      /*M* PROTOTYPE LR PARSER */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8
    9      /*P*
   10           NAME: PARSER
   11        PURPOSE: Provide front end parsing for the LALR(1)
   12                 input.
   13      */
   14
   15
   16
   17      PARSER : PROC;
   18
   19
   20      /*D*
   21             NAME: PARSER
   22      DESCRIPTION: Using LR parse tables generated by the LALR1 parser,
   23                     parse the language input, execute semantic actions
   24                     to build appropriate trees,
   25                     symbol table, etc of a compiler.
   26                     For a description of the LR parsing technique, see
   27                     Aho & Ullman - Principles of Compiler Design - Section 6.
   28                     For a description of the parse tables used, see Section
   29                     6.8 and Section 3.8 of that book.
   30
   31                    This particular implementation uses a token stacking
   32                     scheme compatible with the parser implemented by Dave Ward on
   33                     Multics, in order to use the same semantic actions with
   34                     little change;
   35
   36                   Using this parser as a model, customization can be done to support
   37                     most any type of context for the parser.  Changes may need to be
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      2    
   38                      be made for error messages, abnormal termination, semantic extensions,
   39                      etc.
   40      */
   41
   42
   43      /* This file may be used to customize the standard parser
   44         provided with the LALR1 parser generator.  Ideally, no
   45         modifications need to be made to the parser itself, so that
   46         newly released revisions may be installed without modification
   47         of the parser body.
   48      */
   49
   50
   51
   52      /* Several routines need to be supplied for custom parsers:
   53
   54           SEMANTICS:
   55
   56                The routine to execute a semantic action.  One parameter
   57                is passed -- the semantic action number derived from the
   58                action given in the grammar.  Usually the SEMANTICS  routine is
   59                one large case statement on symbolic action numbers.  All
   60                semantic routines may have access to the lexical token stack and
   61                semantic stack, if required.
   62
   63           SCANNER:
   64
   65                The routine to obtain the next token from the input.
   66                One parameter is passed -- the token structure to be returned.
   67
   68           TERMINATE:
   69
   70                The routine to abnormally terminate the parse (and compilation)
   71                when an unrecoverable error is encountered.
   72
   73           ERRORMSG:
   74
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      3    
   75                The routine to output an error message.  Up to five
   76                parameters are passed to the error message routine:
   77
   78                   1. Error number -- The error number which uniquely
   79                        designates an error message.
   80
   81                   2. Line number  -- The number of the line where the
   82                        error occurred.
   83
   84                   3. Column number -- The number of the column where the
   85                        error occurred.
   86
   87                   4-5. Plugins -- 0, 1, or 2 pieces of text in DNT format.
   88                          These text pieces should be "plugged" into the
   89                          error message before issuing the message to the
   90                          user.  The number of plugins passed is determined
   91                          by the particular error encountered.
   92
   93           CREATE_DUMMY_TOKEN:
   94
   95                The routine to simulate a token, as if the scanner had
   96                returned the token from the input.  The dummy tokens are
   97                used for error correction to allow the parse to proceed.
   98                Four parameters are passed:
   99
  100                   1. TOKEN -- the token data structure that needs to be
  101                               filled in with the dummy token.
  102
  103                   2. SYMBOL NUMBER -- The number of the terminal symbol
  104                               that needs to be created.
  105
  106                   3. LINE NUMBER -- The line number to be used in creating
  107                               the dummy token.
  108
  109                   4. COLUMN NUMBER -- The column number to be used in
  110                               creating the dummy token.
  111
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      4    
  112      */
  113
  114
  115
  116
  117      %IF LEXICAL_PHASE;
  118      %INCLUDE LRXDPDA_SUBS;
  119      DCL LASTCARD SBIN EXT;
  120      DCL LASTCOLUMN SBIN EXT;
  121      %ELSE;
  122      %INCLUDE PADPDA_SUBS;
  123      %ENDIF;
  124      %SET KLUDGE_FLAG = '1'B;
  125      %INCLUDE PARSER_STACK;
  126      %INCLUDE PARSER_STATE;
  127      %INCLUDE CP_6;
  128
  129      /* If parse transitions are to be monitored, set PARSING_STATS to true
  130         and set PARSING_STATS_FILENAME to the file name for data retention.
  131      */
  132      %EQU PARSING_STATS = '0'B;
  133      %EQU PARSING_STATS_FILENAME = 'STATISTICS';
  134
  135      %INCLUDE PARSER_MACROS;
  136      %INCLUDE PARSER_EC_SI;
  137
  138      DCL SCANNER   ENTRY(1);
  139      DCL SEMANTICS ENTRY(1);
  140      DCL FORCE_LIST ENTRY;
  141      DCL FLUSH ENTRY;
  142      DCL OUT_STR ENTRY(2);
  143
  144
  145      %EJECT;

09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      5    
  146      /* The following macros and code may need to be customized
  147         for a specific application.
  148      */
  149
  150      %MACRO TERMINATE;
  151        /* Insert code for abnormal termination of parser */
  152        CALL M$ERR;
  153      %MEND;
  154
  155
  156      %EQU DI_CHAR_LEN_MAX = 100;  /* Maximum length of an error plug-in */
  157
  158
  159      /* Define the structure of a DNT ENTRY.  This will
  160         contain arbitrary text used in error messages
  161         and other token text manipulations.
  162      */
  163      DCL 1 DNT BASED ALIGNED,
  164            2 TEXT,
  165              3 LENGTH SBIN WORD,
  166              3 NAME CHAR(DNT.TEXT.LENGTH);
  167
  168
  169      /* Posssible error conditions and messages */
  170
  171      %EQU E$PARSE_STACK_OVERFLOW_ERROR = 0;    /* Parse stack overflowed */
  172      %EQU E$SEMANTIC_TOKEN_STACK_OVERFLW = 1;  /* Semantic token stack overflowed */
  173      %EQU E$RED_STACK_OVERFLOW_ERROR = 2;      /* Reduction stack overflowed */
  174      %EQU E$PARSE_ERROR = 3;                   /* Syntax error occurred - Input is being skipped */
  175      %EQU E$UNEXP_EOF_DURING_RECOVERY = 4;     /* Unexpected end-of-file during error recovery */
  176      %EQU E$PARSING_RESUMED = 5;               /* Parsing has been resumed at this point */
  177      %EQU E$SYNTAX_INS = 6;                    /* Syntax error: =PLUG1= has been inserted before =PLUG2= */
  178      %EQU E$SYNTAX_REP = 7;                    /* Syntax error: =PLUG1= is incorrect and has been replaced by =PLUG2= */
  179      %EQU E$SYNTAX_DEL = 8;                    /* Syntax error: =PLUG1= is incorrect and has been deleted */
  180      %EQU E$CORRECTION_FAILURE = 9;            /* The compiler could not recover from this error */
  181
  182
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      6    
  183      %MACRO ERRORPROC;
  184      ERROR : PROC(ERROR_TYPE, PLUG1$, PLUG2$);
  185
  186      DCL ERROR_TYPE SBIN WORD;
  187      DCL PLUG1$ PTR;  /* TO DNT */
  188      DCL PLUG2$ PTR;  /* TO DNT */
  189
  190      DCL DIAG ENTRY(6);
  191      DCL I SBIN;
  192      DCL TEXTCHAR1 CHAR(140);
  193      DCL TEXTCHAR2 CHAR(140);
  194
  195      /* ERROR LOCATION IS SET WITH THE RESET_ERROR_LOC MACRO BEFORE
  196         THE ERROR PROCEDURE IS CALLED */
  197      %IF LEXICAL_PHASE;
  198      %ELSE;
  199      CALL FORCE_LIST;
  200      CALL FLUSH;
  201      DO I= 1 TO ERRCOL -1 + LENGTHC(KEY_REC) ;
  202        %OUT_STR(S="' '");
  203      END;
  204      %OUT_STR(S="'1'");
  205      CALL FLUSH;
  206      %ENDIF;
  207
  208      DO CASE(ERROR_TYPE);
  209
  210        CASE(%E$PARSE_STACK_OVERFLOW_ERROR);
  211
  212            /* MSG => PARSE STACK OVERFLOWED */
  213            %IF LEXICAL_PHASE;
  214            CALL DIAG(15,' ERROR => Lexical parse stack overflowed%%');
  215            %ELSE;
  216            CALL DIAG(15,' ERROR => Parse stack overflowed%%');
  217            %ENDIF;
  218
  219        CASE(%E$SEMANTIC_TOKEN_STACK_OVERFLW);
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      7    
  220
  221            /* MSG => SEMANTIC STACK OVERFLOW */
  222            %IF LEXICAL_PHASE;
  223            CALL DIAG(15,' ERROR => Lexical semantic stack overflowed%%');
  224            %ELSE;
  225            CALL DIAG(15,' ERROR => Semantic stack overflowed%%');
  226            %ENDIF;
  227
  228        CASE(%E$RED_STACK_OVERFLOW_ERROR);
  229
  230            /* MSG => REDUCTION STACK OVERFLOW ERROR */
  231            %IF LEXICAL_PHASE;
  232            CALL DIAG(15,' ERROR => Lexical reduction stack overflowed%%');
  233            %ELSE;
  234            CALL DIAG(15,' ERROR => Reduction stack overflowed%%');
  235            %ENDIF;
  236
  237        CASE(%E$PARSE_ERROR);
  238
  239            /* MSG => SYNTAX ERROR OCCURRED - INPUT IS BEING SKIPPED */
  240            %IF LEXICAL_PHASE;
  241            ;
  242            %ELSE;
  243            CALL DIAG(6,' ERROR => Syntax error while reading %%',
  244                        LA_STK.DNTPTR(LA_GET)->DNT.TEXT.NAME,
  245                        ' - Input is being skipped %%');
  246            %ENDIF;
  247
  248        CASE(%E$UNEXP_EOF_DURING_RECOVERY);
  249
  250            /* MSG => UNEXPECTED END_OF_FILE DURING ERROR_RECOVERY */
  251            ;
  252
  253        CASE(%E$PARSING_RESUMED);
  254
  255            /* MSG => PARSING HAS BEEN RESUMED AT THIS POINT */
  256            %IF LEXICAL_PHASE;
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      8    
  257            ;
  258            %ELSE;
  259            CALL DIAG(6,' ERROR => Parsing has been resumed with %%',
  260                        LA_STK.DNTPTR(LA_GET)->DNT.TEXT.NAME);
  261            %ENDIF;
  262
  263        CASE(%E$SYNTAX_INS);
  264
  265            /* MSG => SYNTAX ERROR: =PLUG1$= HAS BEEN INSERTED BEFORE =PLUG2$= */
  266            %IF LEXICAL_PHASE;
  267            ;
  268            %ELSE;
  269            CALL INSERT(TEXTCHAR1,,,PLUG1$->DNT.TEXT.NAME,'%% ');
  270            CALL INSERT(TEXTCHAR2,,,PLUG2$->DNT.TEXT.NAME,'%% ');
  271            CALL DIAG(6,' ERROR => Syntax error: %%',
  272                        TEXTCHAR1,
  273                       ' has been inserted before %%',
  274                       TEXTCHAR2);
  275            %ENDIF;
  276
  277        CASE(%E$SYNTAX_REP);
  278
  279            /* MSG => =PLUG1$= IS INCORRECT AND HAS BEEN REPLACED BY =PLUG2$= */
  280            %IF LEXICAL_PHASE;
  281            ;
  282            %ELSE;
  283            CALL INSERT(TEXTCHAR1,,,PLUG1$->DNT.TEXT.NAME,'%% ');
  284            CALL INSERT(TEXTCHAR2,,,PLUG2$->DNT.TEXT.NAME,'%% ');
  285            CALL DIAG(6,' ERROR => Syntax error: %%',
  286                        TEXTCHAR1,
  287                        ' is incorrect and has been replaced by %%',
  288                        TEXTCHAR2);
  289            %ENDIF;
  290
  291        CASE(%E$SYNTAX_DEL);
  292
  293            /* MSG => =PLUG1$= IS INCORRECT AND HAS BEEN DELETED */
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      9    
  294            %IF LEXICAL_PHASE;
  295            ;
  296            %ELSE;
  297            CALL INSERT(TEXTCHAR1,,,PLUG1$->DNT.TEXT.NAME,'%% ');
  298            CALL DIAG(6,' ERROR => Syntax error:  %%',
  299                        TEXTCHAR1,
  300                        ' is incorrect and has been deleted %%');
  301            %ENDIF;
  302
  303        CASE(%E$CORRECTION_FAILURE);
  304
  305            /* MSG => THE COMPILER COULD NOT RECOVER FROM THIS ERROR */
  306            %IF LEXICAL_PHASE;
  307            ;
  308            %ELSE;
  309            CALL DIAG(15,' ERROR => The compiler could not recover from this error %%');
  310            %ENDIF;
  311
  312      END;  /* CASE */
  313
  314      END ERROR;
  315      %MEND;
  316
  317
  318
  319
  320
  321      %MACRO RESET_ERROR_LOC(L=0,C=0);
  322
  323        /* RESET THE LINE & COLUMN TO THE POINT OF ERROR */
  324        DO;
  325           ERRLINE = L;
  326           ERRCOL  = C;
  327        END;
  328      %MEND;
  329
  330
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      10   
  331      %IF LOCALLY_LEAST_COST_RECOVERY;
  332
  333      %TSTRING_SYMREFS;
  334
  335      CREATE_DUMMY_TOKEN : PROC(LA_PUT,
  336                                SYM_TO_BE_INSERTED,
  337                                LINE_IN_ERROR,
  338                                COL_IN_ERROR);
  339
  340      /* CREATE A DUMMY TOKEN FOR ERROR CORRECTION */
  341
  342      DCL LA_PUT SBIN WORD;  /* INDEX INTO LA_STKAT WHICH POINT TO INSERT TOKEN */
  343      DCL SYM_TO_BE_INSERTED SBIN WORD;
  344      DCL LINE_IN_ERROR SBIN WORD;
  345      DCL COL_IN_ERROR SBIN WORD;
  346
  347      DCL SYMLEN SBIN WORD;
  348      DCL NEWLEN SBIN WORD;
  349      DCL TEXTCHAR CHAR(140);
  350      DCL NEW$ PTR;
  351
  352      SYMLEN = TERM_STRING.LEN(SYM_TO_BE_INSERTED);
  353      CALL INSERT(TEXTCHAR,,,SUBSTR(TSTRING_SPACE,TERM_STRING.INDX(SYM_TO_BE_INSERTED),SYMLEN),
  354                  '%%    ');
  355      NEWLEN = (LENGTHC(DNT.TEXT.LENGTH) + SYMLEN + 7)/4;
  356      CALL GETNEW(NEW$,NEWLEN);
  357      NEW$ -> DNT.TEXT.LENGTH = SYMLEN+2;
  358      NEW$->DNT.TEXT.NAME = SUBSTR(TEXTCHAR,0,SYMLEN+2);
  359
  360      LA_STK.DNTPTR(LA_PUT) = NEW$;
  361      LA_STK.SYMPTR(LA_PUT) = ADDR(NIL);
  362      LA_STK.SYMBOL(LA_PUT) = SYM_TO_BE_INSERTED;
  363      LA_STK.LINE(LA_PUT) = LINE_IN_ERROR;
  364      LA_STK.COLUMN(LA_PUT) = COL_IN_ERROR;
  365
  366      END CREATE_DUMMY_TOKEN;
  367      %ENDIF;
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      11   
  368
  369
  370
  371
  372      %MACRO CREATE_DUMMY_TOKEN;
  373        CALL CREATE_DUMMY_TOKEN (LA_PUT,
  374                                 BINBIT(CORRECTION.SYM(CORRECTION.INDX), 36),
  375                                 ERRLINE,
  376                                 ERRCOL);
  377      %MEND;
  378
  379
  380      %MACRO CREATE_EMPTY_TERMINAL_ON_LX_STK;
  381        DO;
  382          /* LX_STK(LX_TOP) may be filled in to an empty terminal value
  383                   if required */
  384        END;
  385      %MEND;
  386
  387
  388      %MACRO ALTERNATE_ENTRY_TO_PARSER;
  389
  390        /* For name changes to parser;
  391              for example:
  392                   Z8EP$PARSE : ENTRY;
  393        */
  394
  395      %MEND;
  396
  397
  398      /* Set up the trial parse length to try a sample parse on
  399         any proposed correction during error recovery.  The specified
  400         number designates how many tokens to parse past the proposed
  401         correction.  If the trial parse fails, the cost to insert these
  402         symbols will be doubled.  This will encourage deletion of
  403         symbols when multiple corrections need to be made in adjacent
  404         contexts.  Setting trial  parse length to 0 will disable
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      12   
  405         the trial parse.
  406      */
  407      %EQU TRIAL_PARSE_LENGTH = 0;
  408
  409
  410      %MACRO LAST_SHIFTED_LOC(L=0,C=0);
  411
  412        /* Set the location of the last shifted token which differs
  413           from the location of the last token scanned when error
  414           correction is done.
  415        */
  416        DO;
  417          ERRLINE = L;
  418          ERRCOL = C;
  419          %IF LEXICAL_PHASE;
  420          LASTCARD = L;
  421          LASTCOLUMN = C-1;
  422          %ENDIF;
  423        END;
  424      %MEND;
  425
  426
  427      %MACRO CALL_SEMANTICS(A=0);
  428
  429        /* Call the semantics routine with the designated action.
  430        */
  431
  432        CALL SEMANTICS(BITBIN(A));
  433
  434      %MEND;
  435
  436
  437      %MACRO CALL_SCANNER;
  438
  439        /* Call the scanner to obtain the next token.  The token should be
  440           placed in LA_STK(LA_PUT).
  441        */
09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      13   
  442        CALL SCANNER(ADDR(LA_STK(LA_PUT)));
  443
  444      %MEND;
  445
  446
  447
  448      %ERRORPROC;
  449
  450
  451      %IF LOCALLY_LEAST_COST_RECOVERY;
  452        %LOCALLY_LEAST_COST_PROC;
  453      %ENDIF;
  454
  455
  456      %IF PARSING_STATS;
  457        %RESTORE_PARSER_STATS_PROC;
  458        %DUMP_PARSER_STATS_PROC;
  459      %ENDIF;
  460
  461      %RESTORE_PARSER_STATS;
  462
  463      %EJECT;

09:09 AUG 09 '97 LR_PARSER_SI.:Z8A6SI                                      14   
  464
  465      %ALTERNATE_ENTRY_TO_PARSER;
  466
  467
  468
  469      /*
  470           BEGIN INTERPRETATION...
  471      */
  472
  473      %INITIAL_INITIALIZATION;
  474      %RESTART_INITIALIZATION;
  475
  476      %PARSE_LOOP;
  477
  478
  479        /* The above loop should never fall thru;  it terminates in the
  480             shift action when the next state is zero.
  481        */
  482
  483      END PARSER;

