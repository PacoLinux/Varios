

CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=1  
        1         1             /* $Header: ic.c,v 1.5 87/03/10 11:03:02 ceriel Exp $ */
        2         2             /*
        3         3              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        4         4              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        5         5              */
        6         6             /* I N T E R M E D I A T E   C O D E
        7         7              *
        8         8              * I C . C
        9         9              */
       10        10
       11        11             #include <stdio:h>
       12        12             #include "types:h"
       13        13             #include "debug:h"
       14        14             #include "def:h"
       15        15             #include "map:h"
       16        16             #include "em_spec:h"
       17        17             #include "em_pseu:h"
       18        18             #include "em_flag:h"
       19        19             #include "em_mes:h"
       20        20             #include "ic:h"
       21        21             #include "ic_lookup:h"
       22        22             #include "ic_aux:h"
       23        23             #include "ic_io:h"
       24        24             #include "ic_lib:h"
       25        25             #include "alloc:h"
       26        26             #include "global:h"
       27        27             #include "files:h"
       28        28             #include "put:h"
       29        29             #include "aux:h"
       30        30
       31        31
       32        32             /* Global variables */
       33        33
       34        34
       35        35             dblock_p  db = NULL ;
       36        36             dblock_p  curhol = (dblock_p) 0;  /* hol block in current scope */
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=2  
       37        37             dblock_p  ldblock = NULL ;  /* last dblock  */
       38        38             proc_p    lproc = NULL ;    /* last proc    */
       39        39             struct proc proc_init = {0,0,0,0,0,0,
       40        40    1              (bblock_p) 0, (cset) 0, (lset) 0,
       41        41    1              (change_p) 0, (use_p) 0, (pext_p) 0,
       42        42    1              (proc_p) 0, (line_p) 0,0,0,0 };
       43        43
       44        44             struct line_table line_table_init = { (line_table_p) 0,
       45        45    1              (line_table_p) 0, (line_p) 0, (proc_p) 0};
       46        46
       47        47             short     tabval;     /* used by table1, table2 and table3 */
       48        48             offset    tabval2;
       49        49             char      string[IDL+1];
       50        50             line_p    firstline = NULL ;   /* first line of current procedure */
       51        51             line_p    lastline = NULL ; /* last line read */
       52        52             line_p  act_lastline = NULL ; /*save last line of curr proc for mes 16 */
       53        53             line_p  last_mes16 = NULL;
       54        54             int    labelcount; /* # labels in current procedure */
       55        55             short     fragm_type = DUNKNOWN; /* fragm. type: DCON, DROM or DUNKNOWN */
       56        56             short     fragm_nr = 0;  /* fragment number */
       57        57             obj_id    lastoid = 0;
       58        58             proc_id      lastpid = 0;
       59        59             dblock_id lastdid = 0;
       60        60             lab_id    lastlid = 0;
       61        61
       62        62             offset       mespar = UNKNOWN_SIZE;
       63        63                 /* argumument of ps_par message of current procedure */
       64        64
       65        65
       66        66             extern    process_lines();
       67        67             extern int   readline();
       68        68             extern line_p   readoperand();
       69        69             extern line_p   inpseudo();
       70        70
       71        71
       72        72             icmain(argc,argv)
       73        73              int argc;
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=3  
       74        74              char *argv[];
       75        75             {
       76        76    1        dblock_p d;
       77        77    1        proc_p p, last_p;
"zbe$ic:c.:ZBC3TSI", line 77: (warning) identifier "last_p" is not used
       78        78    1        obj_p obj;
       79        79    1         /* The input files must be legal EM Compact
       80        80    1          * Assembly Language files, as produced by the EM Peephole
       81        81    1          * Optimizer.
       82        82    1          * Their file names are passed as arguments.
       83        83    1          * The output consists of the files:
       84        84    1          *  - lfile: the EM code in Intermediate Code format
       85        85    1          *  - dfile: the data block table file
       86        86    1          *  - pfile: the proc table file
       87        87    1          *  - pdump: the names of all procedures
       88        88    1          *  - ddump: the names of all data blocks
       89        89    1          */
       90        90    1
       91        91    1         FILE  *lfile, *dfile, *pfile, *pdump, *ddump;
"zbe$ic:c.:ZBC3TSI", line 91: (warning) identifier "pfile" is not used
"zbe$ic:c.:ZBC3TSI", line 91: (warning) identifier "dfile" is not used
       92        92    1         extern FILE  *zbe_ddump, *zbe_pdump, *zbe_lfile;
       93        93    1
       94        94    1         lfile = tmpfile();
       95        95    1         pdump = tmpfile();
       96        96    1         ddump = tmpfile();
       97        97    1         zbe_lfile = lfile;
       98        98    1         zbe_pdump = pdump;
       99        99    1         zbe_ddump = ddump;
      100       100    1        /*    set pmap and omap globals to null for this pass... */
      101       101    1         omap = (obj_p) 0 ;
"zbe$ic:c.:ZBC3TSI", line 101: (warning) incompatible pointers in =
      102       102    1         pmap = (proc_p) 0 ;
"zbe$ic:c.:ZBC3TSI", line 102: (warning) incompatible pointers in =
      103       103    1         while (next_file(argc,argv) != NULL) {
      104       104    2            /* Read all EM input files, process the code
      105       105    2             * and concatenate all output.
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=4  
      106       106    2             */
      107       107    2            process_lines(lfile);
      108       108    2            dump_procnames(prochash,NPROCHASH,pdump);
      109       109    2            dump_dblocknames(symhash,NSYMHASH,ddump);
      110       110    2            /* Save the names of all procedures that were
      111       111    2             * first come accross in this file.
      112       112    2             */
      113       113    2            cleanprocs(prochash,NPROCHASH,PF_EXTERNAL);
      114       114    2            cleandblocks(symhash,NSYMHASH,DF_EXTERNAL);
      115       115    2            /* Make all procedure names that were internal
      116       116    2             * in this input file invisible.
      117       117    2             */
      118       118    2         }
      119       119    1         fseek(lfile,0, SEEK_SET);
      120       120    1         fseek(pdump,0, SEEK_SET);
      121       121    1         fseek(ddump,0, SEEK_SET);
      122       122    1
      123       123    1
      124       124    1         /* remove the remainder of the hashing tables */
      125       125    1         cleanprocs(prochash,NPROCHASH,0);
      126       126    1         cleandblocks(symhash,NSYMHASH,0);
      127       127    1         /* Now write the datablock table and the proctable */
      128       128    1         first_line_table->assoc_proc = data_proc;
      129       129    1
      130       130    1
      131       131    1         olength = 0;
      132       132    1
      133       133    1         for( d=fdblock; d != (dblock_p) 0; d = d->d_next) {
      134       134    2           for (obj = d->d_objlist; obj != (obj_p) 0; obj=obj->o_next) {
      135       135    3             olength++;} }
      136       136    1
      137       137    1         omap = (obj_p *) newmap(olength);
      138       138    1
      139       139    1         for( d=fdblock; d != (dblock_p) 0; d = d->d_next) {
      140       140    2           for (obj = d->d_objlist; obj != (obj_p) 0; obj=obj->o_next) {
      141       141    3             omap[obj->o_id] = obj; } }
      142       142    1
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=5  
      143       143    1
      144       144    1         plength = 0;
      145       145    1         first_proc = fproc;
      146       146    1         if (first_proc == (proc_p) 0) {
      147       147    2           first_proc = data_proc; } /* make sure at least date proc is set. */
      148       148    1         for (p=first_proc; p != (proc_p) 0; p = p->p_next) {
      149       149    2           plength++; }
      150       150    1
      151       151    1         pmap = (proc_p *) newmap(plength);
      152       152    1         for (p=first_proc; p != (proc_p) 0; p = p->p_next) {
      153       153    2           pmap[p->p_id] = p;
      154       154    2           p->p_start = (bblock_p) 0;
      155       155    2           p->p_calling = (cset) 0;
      156       156    2           p->p_loops = (lset) 0;
      157       157    2           p->p_change = (change_p) 0;
      158       158    2           p->p_use = (use_p) 0;
      159       159    2           p->p_extend = (pext_p) 0;
      160       160    2           if (p->p_mes16 != (line_p) 0) {
      161       161    3              set_func_type(p); }
      162       162    2           }
      163       163    1           return ;
      164       164    1        }
      165       165
      166       166
      167       167
      168       168             /* Value returned by readline */
      169       169
      170       170             #define NORMAL     0
      171       171             #define WITH_OPERAND  1
      172       172             #define EOFILE     2
      173       173             #define PRO_INSTR  3
      174       174             #define END_INSTR  4
      175       175             #define DELETED_INSTR 5
      176       176
      177       177
      178       178             STATIC add_end()
      179       179             {
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=6  
      180       180    1        line_p pl;
      181       181    1         /* Add an end-pseudo to the current instruction list */
      182       182    1
      183       183    1         lastline->l_next = newline(OPNO);
      184       184    1         pl = lastline;
      185       185    1         lastline = lastline->l_next;
      186       186    1         lastline->l_instr = ps_end;
      187       187    1         lastline->l_next = (line_p) 0;
      188       188    1         lastline->l_prev = pl;
      189       189    1        }
      190       190
      191       191
      192       192             process_lines(fout)
      193       193              FILE *fout;
"zbe$ic:c.:ZBC3TSI", line 193: (warning) identifier "fout" is not used
      194       194             {
      195       195    1         line_p lnp;
      196       196    1         short   instr;
      197       197    1         bool   eof;
      198       198    1         int i ;
      199       199    1         line_table_p curr_line_table, next_lt;
      200       200    1         int first_proc = 1;
      201       201    1
      202       202    1         /* Read and process the code contained in the current file,
      203       203    1          * on a per procedure basis.
      204       204    1          * On the fly, fragments are formed. Recall that two
      205       205    1          * successive CON pseudos are allocated consecutively
      206       206    1          * in a single fragment, unless these CON pseudos are
      207       207    1          * separated in the assembly language program by one
      208       208    1          * of: ROM, BSS, HOL and END (and of course EndOfFile).
      209       209    1          * The same is true for ROM pseudos.
      210       210    1          * We keep track of a fragment type (DROM after a ROM
      211       211    1          * pseudo, DCON after a CON and DUNKNOWN after a HOL,
      212       212    1          * BSS, END or EndOfFile) and a fragment number (which
      213       213    1          * is incremented every time we enter a new fragment).
      214       214    1          * Every data block is assigned such a number
      215       215    1          * when we come accross its defining occurrence.
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=7  
      216       216    1          */
      217       217    1
      218       218    1         eof = FALSE;
      219       219    1         firstline = (line_p) 0;
      220       220    1         first_line_table = (line_table_p) newcore(sizeof(struct line_table));
      221       221    1         *first_line_table = line_table_init;
      222       222    1         curr_line_table = first_line_table;
      223       223    1
      224       224    1         lastline = (line_p) 0;
      225       225    1         fproc = (proc_p) 0;
      226       226    1         fdblock = (dblock_p) 0;
      227       227    1         for (i=0; i<NPROCHASH ; i++)
      228       228    1           prochash[ i ] = NULL ;
      229       229    1         for (i=0; i<NSYMHASH ; i++)
      230       230    1           symhash[ i ] = NULL ;
      231       231    1         for (i=0; i<NNUMHASH ; i++)
      232       232    1           numhash[ i ] = NULL ;
      233       233    1         first_line_ptr = (line_p) 0; /* make initially null. */
      234       234    1         data_proc = newproc();  /* generate data proc block. */
      235       235    1         *data_proc = proc_init ; /* init the data block. */
      236       236    1         while (!eof) {
      237       237    2            linecount++;   /* for error messages */
      238       238    2            switch(readline(&instr, &lnp)) {
      239       239    3               /* read one line, see what kind it is */
      240       240    3               case WITH_OPERAND:
      241       241    3                  /* instruction with operand, e.g. LOL 10 */
      242       242    3                  lnp = readoperand(instr);
      243       243    3                  lnp->l_instr = instr;
      244       244    3                  /* Fall through! */
      245       245    3               case NORMAL:
      246       246    3                  VL(lnp);
      247       247    3                  if (lastline != (line_p) 0) {
      248       248    4                     lastline->l_next = lnp;
      249       249    4                  }
      250       250    3            else { lnp->l_next = lastline; }
      251       251    3            lnp->l_prev = lastline;
      252       252    3                  lastline = lnp;
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=8  
      253       253    3                  break;
      254       254    3               case EOFILE:
      255       255    3                  eof = TRUE;
      256       256    3                  fragm_type = DUNKNOWN;
      257       257    3                  if (firstline != (line_p) 0) {
      258       258    4                     add_end();
      259       259    4        /*  putlines(firstline,fout);      */
      260       260    4                     firstline = (line_p) 0;
      261       261    4                  }
      262       262    3                  break;
      263       263    3               case PRO_INSTR:
      264       264    3                  VL(lnp);
      265       265    3                  labelcount = 0;
      266       266    3                  if (firstline != lnp) {
      267       267    4                     /* If PRO is not the first
      268       268    4                      * instruction:
      269       269    4                      */
      270       270    4                     add_end();
      271       271    4        /*  putlines(firstline,fout);     */
      272       272    4           next_lt = (line_table_p) newcore(sizeof(struct line_table));
      273       273    4           *next_lt = line_table_init;
      274       274    4           curr_line_table->lt_next = next_lt;
      275       275    4           next_lt->lt_priv = curr_line_table;
      276       276    4           curr_line_table = next_lt;
      277       277    4           curr_line_table->first_line = lnp;
      278       278    4           curr_line_table->assoc_proc = curproc;
      279       279    4                     firstline = lnp;
      280       280    4                  }
      281       281    3            else { lnp->l_next = lastline; }
      282       282    3            if (first_proc != 0) {
      283       283    4              first_proc = 0; }
      284       284    3            else {
      285       285    4              curproc->p_mes16 = last_mes16; }
      286       286    3                  lastline = lnp;
      287       287    3                  break;
      288       288    3               case END_INSTR:
      289       289    3                  curproc->p_nrformals = mespar;
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=9  
      290       290    3                  mespar = UNKNOWN_SIZE;
      291       291    3                  assert(lastline != (line_p) 0);
      292       292    3                  lastline->l_next = lnp;
      293       293    3            lnp->l_prev = lastline ;
      294       294    3        /* putlines(firstline,fout);     */
      295       295    3                  /* write and delete code */
      296       296    3                  firstline = (line_p) 0;
      297       297    3                  lastline = (line_p) 0;
      298       298    3                  cleaninstrlabs();
      299       299    3                  /* scope of instruction labels ends here,
      300       300    3                   * so forget about them.
      301       301    3                   */
      302       302    3                  fragm_type = DUNKNOWN;
      303       303    3                  break;
      304       304    3               case DELETED_INSTR:
      305       305    3                  /* EXP, INA etc. are deleted */
      306       306    3                  break;
      307       307    3               default:
      308       308    3                  error("illegal readline");
      309       309    3            }
      310       310    2           if (first_line_ptr == (line_p) 0) {
      311       311    3              first_line_ptr = lnp ;
      312       312    3              data_proc->p_line = lnp;
      313       313    3              curr_line_table->first_line = lnp; }
      314       314    2         }
      315       315    1        }
      316       316
      317       317
      318       318
      319       319             int readline(instr_out, lnp_out)
      320       320              short  *instr_out;
      321       321              line_p *lnp_out;
      322       322             {
      323       323    1         register line_p lnp;
      324       324    1         short n;
      325       325    1
      326       326    1         /* Read one line. If it is a normal EM instruction without
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=10 
      327       327    1          * operand, we can allocate a line struct for it here.
      328       328    1          * If so, return a pointer to it via lnp_out, else just
      329       329    1          * return the instruction code via instr_out.
      330       330    1          */
      331       331    1
      332       332    1         VA((short *) instr_out);
      333       333    1         VA((short *) lnp_out);
      334       334    1         switch(table1()) {
      335       335    2            /* table1 sets string, tabval or tabval2 and
      336       336    2             * returns an indication of what was read.
      337       337    2             */
      338       338    2            case ATEOF:
      339       339    2               return EOFILE;
      340       340    2            case INST:
      341       341    2               *instr_out = tabval; /* instruction code */
      342       342    2               return WITH_OPERAND;
      343       343    2            case DLBX:
      344       344    2               /* data label defining occurrence, precedes
      345       345    2                * a data block.
      346       346    2                */
      347       347    2               db = block_of_lab(string);
      348       348    2               /* global variable, used by inpseudo */
      349       349    2               lnp = newline(OPSHORT);
      350       350    2               SHORT(lnp) = (short) db->d_id;
      351       351    2               lnp->l_instr = ps_sym;
      352       352    2               *lnp_out = lnp;
      353       353    2               if (firstline == (line_p) 0) {
      354       354    3                  firstline = lnp;
      355       355    3                  /* only a pseudo (e.g. PRO) or data label
      356       356    3                   * can be the first instruction.
      357       357    3                   */
      358       358    3               }
      359       359    2               return NORMAL;
      360       360    2            case ILBX:
      361       361    2               /* instruction label defining occurrence */
      362       362    2               labelcount++;
      363       363    2               lnp = newline(OPINSTRLAB);
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=11 
      364       364    2               lnp->l_instr = op_lab;
      365       365    2               INSTRLAB(lnp) = instr_lab(tabval);
      366       366    2               *lnp_out = lnp;
      367       367    2               return NORMAL;
      368       368    2            case PSEU:
      369       369    2               n = tabval;
      370       370    2               lnp = inpseudo(n); /* read a pseudo */
      371       371    2               if (lnp == (line_p) 0)  return DELETED_INSTR;
      372       372    2               *lnp_out = lnp;
      373       373    2               lnp->l_instr = n;
      374       374    2          lnp->l_next = (line_p) 0;
      375       375    2               if (firstline == (line_p) 0) {
      376       376    3                  firstline = lnp;
      377       377    3                  /* only a pseudo (e.g. PRO) or data label
      378       378    3                   * can be the first instruction.
      379       379    3                   */
      380       380    3               }
      381       381    2               if (n == ps_end)  return END_INSTR;
      382       382    2               if (n == ps_pro)  return PRO_INSTR;
      383       383    2               return NORMAL;
      384       384    2         }
      385       385    1         /* NOTREACHED */
      386       386    1        }
      387       387
      388       388
      389       389             line_p readoperand(instr)
      390       390              short instr;
      391       391             {
      392       392    1         /* Read the operand of the given instruction.
      393       393    1          * Create a line struct and return a pointer to it.
      394       394    1          */
      395       395    1
      396       396    1
      397       397    1         register line_p lnp;
      398       398    1         short flag;
      399       399    1
      400       400    1         VI(instr);
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=12 
      401       401    1         flag = em_flag[ instr - sp_fmnem] & EM_PAR;
      402       402    1         if (flag == PAR_NO) {
      403       403    2            return (newline(OPNO));
      404       404    2         }
      405       405    1         switch(table2()) {
      406       406    2            case sp_cend:
      407       407    2               return(newline(OPNO));
      408       408    2            case CSTX1:
      409       409    2               /* constant */
      410       410    2               /* If the instruction has the address
      411       411    2                * of an external variable as argument,
      412       412    2                * the constant must be regarded as an
      413       413    2                * offset in the current hol block,
      414       414    2                * so an object must be created.
      415       415    2                * Similarly, the instruction may have
      416       416    2                * an instruction label as argument.
      417       417    2                */
      418       418    2               switch(flag) {
      419       419    3                  case PAR_G:
      420       420    3                  lnp = newline(OPOBJECT);
      421       421    3                  OBJ(lnp) =
      422       422    3                    object((char *) 0,(offset) tabval,
      423       423    3                      opr_size(instr));
      424       424    3                  break;
      425       425    3                  case PAR_B:
      426       426    3                  lnp = newline(OPINSTRLAB);
      427       427    3                  INSTRLAB(lnp) = instr_lab(tabval);
      428       428    3                  break;
      429       429    3                  default:
      430       430    3                  lnp = newline(OPSHORT);
      431       431    3                  SHORT(lnp) = tabval;
      432       432    3                  break;
      433       433    3               }
      434       434    2               break;
      435       435    2        #ifdef LONGOFF
      436       436    2            case CSTX2:
      437       437    2               /* double constant */
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=13 
      438       438    2               lnp = newline(OPOFFSET);
      439       439    2               OFFSET(lnp) = tabval2;
      440       440    2               break;
      441       441    2        #endif
      442       442    2            case ILBX:
      443       443    2               /* applied occurrence instruction label */
      444       444    2               lnp = newline(OPINSTRLAB);
      445       445    2               INSTRLAB(lnp) = instr_lab(tabval);
      446       446    2               break;
      447       447    2            case DLBX:
      448       448    2               /* applied occurrence data label */
      449       449    2               lnp = newline(OPOBJECT);
      450       450    2               OBJ(lnp) = object(string, (offset) 0,
      451       451    2                     opr_size(instr) );
      452       452    2               break;
      453       453    2            case VALX1:
      454       454    2               lnp = newline(OPOBJECT);
      455       455    2               OBJ(lnp) = object(string, (offset) tabval,
      456       456    2                     opr_size(instr) );
      457       457    2               break;
      458       458    2        #ifdef LONGOFF
      459       459    2            case VALX2:
      460       460    2               lnp = newline(OPOBJECT);
      461       461    2               OBJ(lnp) = object(string,tabval2,
      462       462    2                     opr_size(instr) );
      463       463    2               break;
      464       464    2        #endif
      465       465    2            case sp_pnam:
      466       466    2               lnp = newline(OPPROC);
      467       467    2               PROC(lnp) = proclookup(string,OCCURRING);
      468       468    2               VP(PROC(lnp));
      469       469    2               break;
      470       470    2            default:
      471       471    2               assert(FALSE);
      472       472    2         }
      473       473    1         return lnp;
      474       474    1        }
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=14 
      475       475
      476       476
      477       477
      478       478             line_p inpseudo(n)
      479       479              short n;
      480       480             {
      481       481    1         int m;
      482       482    1         line_p lnp;
      483       483    1         byte pseu;
      484       484    1         short nlast;
      485       485    1
      486       486    1         /* Read the (remainder of) a pseudo instruction, the instruction
      487       487    1          * code of which is n. The END pseudo may be deleted (return 0).
      488       488    1          * The pseudos INA, EXA, INP and EXP (visibility pseudos) must
      489       489    1          * also be deleted, although the effects they have on the
      490       490    1          * visibility of global names and procedure names must first
      491       491    1          * be recorded in the datablock or procedure table.
      492       492    1          */
      493       493    1
      494       494    1
      495       495    1         switch(n) {
      496       496    2            case ps_hol:
      497       497    2            case ps_bss:
      498       498    2            case ps_rom:
      499       499    2            case ps_con:
      500       500    2               if (lastline == (line_p) 0 || !is_datalabel(lastline)) {
      501       501    3                  if (n == ps_hol) {
      502       502    4                     /* A HOL need not be preceded
      503       503    4                     * by a label.
      504       504    4                     */
      505       505    4                     curhol = db = block_of_lab((char *) 0);
      506       506    4                  } else {
      507       507    4                     assert(lastline != (line_p) 0);
      508       508    4                     nlast = INSTR(lastline);
      509       509    4                     if (n == nlast &&
      510       510    4                     (n == ps_rom || n == ps_con)) {
      511       511    5                     /* Two successive roms/cons are
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=15 
      512       512    5                      * combined into one data block
      513       513    5                      * if the second is not preceded by
      514       514    5                      * a data label.
      515       515    5                      */
      516       516    5                     lnp = arglist(0);
      517       517    5                     pseu = (byte) (n == ps_rom?DROM:DCON);
      518       518    5                     combine(db,lastline,lnp,pseu);
      519       519    5                     oldline(lnp);
      520       520    5                     return (line_p) 0;
      521       521    5                     } else {
      522       522    5              /* error message has been deleted.  */
      523       523    5                     }
      524       524    4                  }
      525       525    3               }
      526       526    2               VD(db);
      527       527    2               m = (n == ps_hol || n == ps_bss ? 3 : 0);
      528       528    2               lnp = arglist(m);
      529       529    2               /* Read the arguments, 3 for hol or bss and a list
      530       530    2                * of undetermined length for rom and con.
      531       531    2                */
      532       532    2               dblockdef(db,n,lnp);
      533       533    2               /* Fill in d_pseudo, d_size and d_values fields of db */
      534       534    2               if (fragm_type != db->d_pseudo & BMASK) {
      535       535    3                  /* Keep track of fragment numbers,
      536       536    3                   * enter a new fragment.
      537       537    3                   */
      538       538    3                  fragm_nr++;
      539       539    3                  switch(db->d_pseudo) {
      540       540    4                     case DCON:
      541       541    4                     case DROM:
      542       542    4                        fragm_type = db->d_pseudo;
      543       543    4                        break;
      544       544    4                     default:
      545       545    4                        fragm_type = DUNKNOWN;
      546       546    4                        break;
      547       547    4                  }
      548       548    3               }
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=16 
      549       549    2               db->d_fragmnr = fragm_nr;
      550       550    2               return lnp;
      551       551    2            case ps_ina:
      552       552    2               getsym(DEFINING);
      553       553    2               /* Read and lookup a symbol. As this must be
      554       554    2                * the first occurrence of the symbol and we
      555       555    2                * say it's a defining occurrence, getsym will
      556       556    2                * automatically make it internal (according to
      557       557    2                * the EM visibility rules).
      558       558    2                * The result (a dblock pointer) is voided.
      559       559    2                */
      560       560    2               return (line_p) 0;
      561       561    2            case ps_inp:
      562       562    2               getproc(DEFINING);  /* same idea */
      563       563    2               return (line_p) 0;
      564       564    2            case ps_exa:
      565       565    2               getsym(OCCURRING);
      566       566    2               return (line_p) 0;
      567       567    2            case ps_exp:
      568       568    2               getproc(OCCURRING);
      569       569    2               return (line_p) 0;
      570       570    2            case ps_pro:
      571       571    2               curproc = getproc(DEFINING);
      572       572    2               /* This is a real defining occurrence of a proc */
      573       573    2               curproc->p_localbytes = get_off();
      574       574    2               curproc->p_flags1 |= PF_BODYSEEN;
      575       575    2               /* Record the fact that we came accross
      576       576    2                * the body of this procedure.
      577       577    2                */
      578       578    2               lnp = newline(OPPROC);
      579       579    2               PROC(lnp) = curproc;
      580       580    2           curproc->p_line = lnp;
      581       581    2               lnp->l_instr = (byte) ps_pro;
      582       582    2               return lnp;
      583       583    2            case ps_end:
      584       584    2               curproc->p_nrlabels = labelcount;
      585       585    2               lnp = newline(OPNO);
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=17 
      586       586    2               get_off();
      587       587    2               /* Void # localbytes, which we already know
      588       588    2                * from the PRO instruction.
      589       589    2                */
      590       590    2               return lnp;
      591       591    2            case ps_mes:
      592       592    2               lnp = arglist(0);
      593       593    2               switch((int) aoff(ARG(lnp),0)) {
      594       594    3               case ms_err:
      595       595    3                  error("ms_err encountered");
      596       596    3               case ms_opt:
      597       597    3                  error("ms_opt encountered");
      598       598    3               case ms_emx:
      599       599    3                  ws = aoff(ARG(lnp),1);
      600       600    3                  ps = aoff(ARG(lnp),2);
      601       601    3                  break;
      602       602    3               case ms_ext:
      603       603    3                  /* this message was already processed
      604       604    3                   * by the lib package
      605       605    3                   */
      606       606    3               case ms_src:
      607       607    3                  /* Don't bother about linecounts */
      608       608    3                  oldline(lnp);
      609       609    3                  return (line_p) 0;
      610       610    3             case ms_fun: /* chk if imediately follows an end... */
      611       611    3              last_mes16 = lnp;
      612       612    3              break;
      613       613    3               case ms_par:
      614       614    3                  mespar = aoff(ARG(lnp),1);
      615       615    3                  /* #bytes of parameters of current proc */
      616       616    3                  break;
      617       617    3               }
      618       618    2               return lnp;
      619       619    2            default:
      620       620    2               assert(FALSE);
      621       621    2         }
      622       622    1         /* NOTREACHED */
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=18 
      623       623    1        }
      624       624
      625       625             /*i*
      626       626                   name: set_func_type
      627       627                   procedure: this routine sets the function type (static
      628       628                   or global ) bit int the procedure table. Specifically,
      629       629                   it sets the STATICFUNCTION bit the the flags1 word of
      630       630                   the procedure table.
      631       631             */
      632       632             set_func_type(p) proc_p p; {
      633       633    1        arg_p a1,a2,a3,a4,a5;
      634       634    1        line_p l;
      635       635    1
      636       636    1              a1=(arg_p) p->p_mes16;
      637       637    1              l = (line_p) a1;
      638       638    1              a1 = l->l_a.la_arg;
      639       639    1              a2 = a1->a_next;
      640       640    1              a3 = a2->a_next;
      641       641    1              a4 = a3->a_next;
      642       642    1              a5 = a4->a_next;
      643       643    1              if (a5->a_a.a_offset == 0) { /* chk for static function. */
      644       644    2                p->p_flags1 |= PF_STATICFUNCTION; }
      645       645    1
      646       646    1              return;
      647       647    1        }
      648       648
---  Include file information  ---

   stdio:h.:LIBRARY. is referenced
   zbe$types:h.:ZBC3TOU. is referenced
   zbe$debug:h.:ZBC3TOU. is referenced
   zbe$def:h.:ZBC3TOU. is referenced
   zbe$map:h.:ZBC3TOU. is referenced
   em_spec:h.:ZBC3TOU. is referenced
   em_pseu:h.:ZBC3TOU. is referenced
   em_flag:h.:ZBC3TOU. is referenced
   em_mes:h.:ZBC3TOU. is referenced
CC.C03    File=zbe$ic:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=19 
   zbe$ic:h.:ZBC3TOU. is referenced
   zbe$ic_lookup:h.:ZBC3TOU. is referenced
   zbe$ic_aux:h.:ZBC3TOU. is referenced
   zbe$ic_io:h.:ZBC3TOU. is referenced
   zbe$ic_lib:h.:ZBC3TOU. is referenced
   zbe$alloc:h.:ZBC3TOU. is referenced
   zbe$global:h.:ZBC3TOU. is referenced
   zbe$files:h.:ZBC3TOU. is referenced
   zbe$put:h.:ZBC3TOU. is referenced
   zbe$aux:h.:ZBC3TOU. is referenced

6 warnings were detected in the file zbe$ic:c.:ZBC3TSI
