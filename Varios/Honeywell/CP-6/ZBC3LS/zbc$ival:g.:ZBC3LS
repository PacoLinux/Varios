

11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       1    
    1      /*
    2       * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
    3       * See the copyright notice in the ACK home directory, in the file "Copyright".
    4       */
    5      /* $Header: ival.g,v 3.3 87/03/27 16:39:26 ceriel Exp $ */
    6      /* CODE FOR THE INITIALISATION OF GLOBAL VARIABLES */
    7
    8      {
    9      #include "nofloat:h"
   10      #include <em:h>
   11      #include "debug:h"
   12      #include <alloc:h>
   13      #include "nobitfield:h"
   14      #include "arith:h"
   15      #include "align:h"
   16      #include "label:h"
   17      #include "expr:h"
   18      #include "type:h"
   19      #include "struct:h"
   20      #include "field:h"
   21      #include "assert:h"
   22      #include "Lpars:h"
   23      #include "class:h"
   24      #include "sizes:h"
   25      #include "idf:h"
   26      #include "level:h"
   27      #include "def:h"
   28      #include "LLlex:h"
   29      #include "noRoption:h"
   30      #include "estack:h"
   31      #include "zb_target:h"
   32      #include "dataFirst:h"
   33      #include "use_tmp:h"
   34
   35      #define con_nullbyte()   if (initialize_const)\
   36                             C_rom_ucon("0", (arith)1), constant_data++;\
   37                        else C_con_ucon("0", (arith)1), static_data++
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       2    
   38      #define aggregate_type(tp) ((tp)->tp_fund == ARRAY || (tp)->tp_fund == STRUCT || (tp)->tp_fund == UNION)
   39
   40      char *long2str();
   41      char *strncpy();
   42      extern char options[];
   43      static int gen_error;
   44      struct type **gen_tphead(), **gen_tpmiddle();
   45      struct sdef *gen_align_to_next();
   46      int initialize_const = 0, within_init = 0;
   47      static char zeroes[40] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
   48      }
   49
   50      /*  initial_value recursively guides the initialisation expression.
   51       Upto now, the initialisation of a union is not allowed!
   52      */
   53      /* 7 */
   54      initial_value(register struct type **tpp; register struct expr **expp; int auto_agg;)
   55       {int init_flg;  }
   56      :
   57             {
   58                init_flg = within_init;
   59                if (!within_init) {
   60                   if (tpp)  {
   61                      struct type *tp = *tpp;
   62                      while (tp->tp_fund == ARRAY)
   63                         tp = tp->tp_up;
   64                      initialize_const = tp->tp_const && !tp->tp_volatile;
   65                      if (auto_agg) initialize_const = 1;
   66                      }
   67                   else initialize_const = 0;
   68                   within_init = 1;
   69                   }
   70                if (tpp) gen_tpcheck(tpp, 0);
   71             }
   72      [
   73       assignment_expression(expp)
   74             { if ((*expp)->ex_type->tp_fund == ARRAY)
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       3    
   75                array2pointer(*expp);
   76               if (tpp) {
   77                gen_simple_exp(tpp, expp);
   78                free_expression(*expp);
   79                *expp = 0;
   80               }
   81             }
   82      |
   83       initial_value_pack(tpp, expp)
   84      ]
   85       { within_init = init_flg;
   86          if (!within_init)  {
   87             long *sectp = (initialize_const)?&constant_data : &static_data;
   88             int   rem   = (*sectp)&3;
   89             if (rem) {
   90      #if DATAFIRST && defined(USE_TMP)
   91                if (!options['N']) EM_File_No = 1;
   92      #endif
   93                if (initialize_const) C_rom_scon("\0\0\0", (arith) 4-rem);
   94                else C_con_scon("\0\0\0", (arith) 4-rem);
   95                (*sectp) += 4-rem;
   96      #if DATAFIRST && defined(USE_TMP)
   97                EM_File_No = 0;
   98      #endif
   99                }
  100             }
  101       }
  102      ;
  103
  104      initial_value_pack(struct type **tpp; struct expr **expp;) :
  105       '{'
  106       initial_value_list(tpp, expp)
  107       '}'
  108      ;
  109
  110      initial_value_list(register struct type **tpp; struct expr **expp;)
  111       { struct expr *e1;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       4    
  112         register struct type **tpp2 = 0;
  113       }
  114      :
  115             { if (tpp) tpp2 = gen_tphead(tpp, 0); }
  116       initial_value(tpp2, &e1, 0)
  117             { if (!tpp) init_expression(&expp, e1); }
  118       [%while (AHEAD != '}')     /* >>> conflict on ',' */
  119          ','
  120             { if (tpp) tpp2 = gen_tpmiddle(); }
  121          initial_value(tpp2, &e1, 0)
  122             { if (!tpp) init_expression(&expp, e1); }
  123       ]*
  124             { if (tpp) gen_tpend(); }
  125       ','?           /* optional trailing comma */
  126      ;
  127
  128      {
  129      gen_tpcheck(tpp, union_allowed)
  130       struct type **tpp;
  131      {
  132       register struct type *tp;
  133
  134       if (gen_error) return;
  135       switch((tp = *tpp)->tp_fund) {
  136       case ARRAY:
  137          if (! valid_type(tp->tp_up, "array element"))
  138             gen_error = 1;
  139          break;
  140       case STRUCT:
  141          if (! valid_type(tp, "struct"))
  142             gen_error = 1;
  143          break;
  144       case UNION:
  145          if (options['R'] && ! union_allowed) {
  146             warning("union initialisation not allowed");
  147             break;
  148          }
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       5    
  149          if (! valid_type(tp, "union"))
  150             gen_error = 1;
  151          break;
  152       }
  153      }
  154
  155      gen_simple_exp(tpp, expp)
  156       struct type **tpp;
  157       struct expr **expp;
  158      {
  159       register struct type *tp;
  160
  161       if (gen_error) return;
  162       if ( (*expp)->ex_flags & EX_COMMA )
  163          warning("expression comma incorrect in initialization");
  164       tp = *tpp;
  165       switch(tp->tp_fund) {
  166       case ARRAY:
  167          if ((*expp)->ex_class == String && tp->tp_up->tp_fund == CHAR) {
  168             ch_array(tpp,*expp);
  169             break;
  170          }
  171          /* Fall through */
  172       case STRUCT:
  173       case UNION:
  174          check_and_pad(expp, tpp);
  175          break;
  176       case ERRONEOUS:
  177          gen_error = 1;
  178          break;
  179       default:
  180          check_ival(expp, tp);
  181          break;
  182       }
  183      }
  184
  185      struct e_stack *p_stack = 0;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       6    
  186
  187      struct type **
  188      arr_elem(tpp, p)
  189       struct type **tpp;
  190       struct e_stack *p;
  191      {
  192       register struct type *tp = *tpp;
  193
  194       if (tp->tp_up->tp_fund == CHAR && AHEAD == STRING && p->elem_count == 1) {
  195          p->nelem = 1;
  196          return tpp;
  197       }
  198       if (AHEAD == '{' || ! aggregate_type(tp->tp_up))
  199          return &(tp->tp_up);
  200       return gen_tphead(&(tp->tp_up), 1);
  201      }
  202
  203      struct sdef *
  204      next_field(sd, p)
  205       register struct sdef *sd;
  206       register struct e_stack *p;
  207      {
  208       if (sd->sd_sdef)
  209          p->bytes_upto_here += zero_bytes(sd);
  210       if (p->last_offset != sd->sd_offset) {
  211          p->bytes_upto_here +=
  212             size_of_type(sd->sd_type, "selector");
  213          p->last_offset = sd->sd_offset;
  214       }
  215       return sd->sd_sdef;
  216      }
  217
  218      struct type **
  219      gen_tphead(tpp, nest)
  220       struct type **tpp;
  221      {
  222       register struct type *tp = *tpp;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       7    
  223       register struct e_stack *p = new_e_stack();
  224       register struct sdef *sd;
  225
  226       if (gen_error) return tpp;
  227       p->next = p_stack;
  228       p_stack = p;
  229       p->s_nested = nest;
  230       p->s_tpp = tpp;
  231       switch(tp->tp_fund) {
  232       case ARRAY:
  233          p->nelem = -1;
  234          p->elem_count = 1;
  235          if (tp->tp_size != (arith) -1) {
  236             p->nelem = (tp->tp_size / tp->tp_up->tp_size);
  237          }
  238          return arr_elem(tpp, p);
  239       case STRUCT:
  240          p->s_def = sd = tp->tp_sdef;
  241          p->bytes_upto_here = 0;
  242          p->last_offset = -1;
  243      #ifndef NOBITFIELD
  244          while (sd && is_anon_idf(sd->sd_idf)) {
  245             put_bf(sd->sd_type, (arith) 0);
  246             sd = next_field(sd, p);
  247          }
  248      #endif
  249          p->s_def = sd;
  250          if (AHEAD != '{' && aggregate_type(sd->sd_type)) {
  251             return gen_tphead(&(sd->sd_type), 1);
  252          }
  253          return &(sd->sd_type);
  254       case UNION:
  255          sd = tp->tp_sdef;
  256          p->nelem = 1;
  257          p->elem_count = 1;
  258          return &(sd->sd_type);
  259       default:
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       8    
  260          p->nelem = 1;
  261          p->elem_count = 1;
  262          return tpp;
  263       }
  264      }
  265
  266      struct type **
  267      gen_tpmiddle()
  268      {
  269       register struct type *tp;
  270       register struct sdef *sd;
  271       register struct e_stack *p = p_stack;
  272
  273       if (!p) gen_error = 1;
  274       if (gen_error) return (p) ? p->s_tpp : (struct type **)0;
  275      again:
  276       tp = *(p->s_tpp);
  277       switch(tp->tp_fund) {
  278       default:
  279          if (p->elem_count == p->nelem && p->s_nested) {
  280             p = p->next;
  281             free_e_stack(p_stack);
  282             p_stack = p;
  283             goto again;
  284          }
  285          p->elem_count++;
  286          if (p->nelem >= 0 && p->elem_count > p->nelem) {
  287             too_many_initialisers();
  288             return p->s_tpp;
  289          }
  290          if (tp->tp_fund == ARRAY) {
  291             return arr_elem(p->s_tpp, p);
  292          }
  293          return p->s_tpp;
  294       case STRUCT:
  295          sd = gen_align_to_next(p);
  296          if (! sd) {
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       9    
  297      #if DATAFIRST && defined(USE_TMP)
  298             if (!options['N'])  EM_File_No = 1;
  299      #endif
  300             while (p->bytes_upto_here++ < tp->tp_size)
  301                con_nullbyte();
  302      #if DATAFIRST && defined(USE_TMP)
  303             EM_File_No = 0;
  304      #endif
  305             if (p->s_nested) {
  306                p = p->next;
  307                free_e_stack(p_stack);
  308                p_stack = p;
  309                goto again;
  310             }
  311             too_many_initialisers();
  312             return p->s_tpp;
  313          }
  314          if (AHEAD != '{' && aggregate_type(sd->sd_type)) {
  315             return gen_tphead(&(sd->sd_type), 1);
  316          }
  317          return &(sd->sd_type);
  318       }
  319      }
  320
  321      struct sdef *
  322      gen_align_to_next(p)
  323       register struct e_stack *p;
  324      {
  325       register struct sdef *sd = p->s_def;
  326
  327       if (! sd) return sd;
  328      #ifndef NOBITFIELD
  329       do {
  330          if (is_anon_idf(sd->sd_idf)) put_bf(sd->sd_type, (arith) 0);
  331      #endif
  332          sd = next_field(sd, p);
  333      #ifndef NOBITFIELD
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       10   
  334       } while (sd && is_anon_idf(sd->sd_idf));
  335      #endif
  336       p->s_def = sd;
  337       return sd;
  338      }
  339
  340      gen_tpend()
  341      {
  342       register struct e_stack *p = p_stack;
  343       register struct type *tp;
  344       register struct sdef *sd;
  345       int getout = 0;
  346       int offs;
  347
  348       while (!getout) {
  349           if (p && !gen_error) {
  350          tp = *(p->s_tpp);
  351          switch(tp->tp_fund) {
  352          case ARRAY:
  353             if (tp->tp_size == -1) {
  354                *(p->s_tpp) = construct_type(ARRAY,
  355                   tp->tp_up, p->elem_count, (struct formal*)0);
  356             }
  357             else {
  358                while (p->nelem-- > p->elem_count) {
  359                   initialize_to_zero(&tp->tp_up, initialize_const, 0);
  360                }
  361             }
  362             break;
  363          case UNION:
  364             {  int i = (tp->tp_size) - (tp->tp_sdef->sd_type->tp_size);
  365                if (i > 0)
  366                   if (initialize_const) zero_memory(i, &constant_data, C_rom_ucon);
  367                      else zero_memory(i, &static_data, C_con_ucon);
  368                break;
  369             }
  370          case STRUCT:
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       11   
  371             sd = p->s_def;
  372             offs = (sd) ? sd->sd_offset : -1;
  373             sd = gen_align_to_next(p);
  374             while (sd && offs == sd->sd_offset) {
  375                put_bf( sd->sd_type, (arith) 0 );
  376                sd = next_field(sd, p);
  377                }
  378             while (sd) {
  379                initialize_to_zero(&sd->sd_type, initialize_const, 0);
  380                if (sd->sd_sdef)
  381                   p->bytes_upto_here += zero_bytes(sd);
  382                p->bytes_upto_here +=
  383                   size_of_type(sd->sd_type, "selector");
  384                sd = sd->sd_sdef;
  385             }
  386      #if DATAFIRST && defined(USE_TMP)
  387             if (!options['N'])  EM_File_No = 1;
  388      #endif
  389             while (p->bytes_upto_here++ < tp->tp_size)
  390                con_nullbyte();
  391      #if DATAFIRST && defined(USE_TMP)
  392             EM_File_No = 0;
  393      #endif
  394             break;
  395          }
  396           }
  397          if (p) {
  398             if (! p->s_nested) getout = 1;
  399             p = p->next;
  400             free_e_stack(p_stack);
  401             p_stack = p;
  402          }
  403          else getout = 1;
  404       }
  405       gen_error = 0;
  406      }
  407
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       12   
  408      /*  check_and_pad() is given a simple initialisation expression
  409       where the type can be either a simple or an aggregate type.
  410       In the latter case, only the first member is initialised and
  411       the rest is zeroed.
  412      */
  413      check_and_pad(expp, tpp)
  414       struct type **tpp;
  415       struct expr **expp;
  416      {
  417       /* ex is of a fundamental type   */
  418       register struct type *tp = *tpp;
  419       register struct expr *ex = *expp;
  420
  421       if (tp->tp_fund == ARRAY) {
  422          check_and_pad(expp, &(tp->tp_up));  /* first member   */
  423          if (tp->tp_size == (arith)-1)
  424             /* no size specified upto here: just
  425                set it to the size of one member.
  426             */
  427             tp = *tpp = construct_type(ARRAY, tp->tp_up, (arith)1, (struct formal*)0);
  428          else {
  429             register int dim = (tp->tp_size)?tp->tp_size / tp->tp_up->tp_size : 0;
  430             /* pad remaining members with zeroes */
  431             while (--dim > 0)
  432                initialize_to_zero(&tp->tp_up, initialize_const, 0);
  433          }
  434       }
  435       else
  436       if (tp->tp_fund == STRUCT || tp->tp_fund == UNION) {
  437          register struct sdef *sd = tp->tp_sdef;
  438
  439          check_and_pad(expp, &(sd->sd_type));
  440          /* next selector is aligned by adding extra zeroes */
  441          if (tp->tp_fund == UNION)   {
  442             int n = tp->tp_size - sd->sd_type->tp_size;
  443
  444             if (initialize_const) constant_data += n;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       13   
  445                else static_data += n;
  446      #if DATAFIRST && defined(USE_TMP)
  447           if (!options['N']) EM_File_No = 1;
  448      #endif
  449             while (n--)    {
  450                if (initialize_const)  C_rom_icon("0",(arith)1);
  451                   else C_con_icon("0",(arith)1);
  452                }
  453      #if DATAFIRST && defined(USE_TMP)
  454           EM_File_No = 0;
  455      #endif
  456             }
  457             else   {
  458                if (sd->sd_sdef)
  459                   zero_bytes(sd);
  460                while (sd = sd->sd_sdef) { /* pad remaining selectors */
  461                   initialize_to_zero(&sd->sd_type, initialize_const, 0);
  462                   if (sd->sd_sdef)
  463                      zero_bytes(sd);
  464             }
  465          }
  466       }
  467       else  /* simple type */
  468          check_ival(expp, tp);
  469      }
  470
  471      /*  pad() fills an element of type tp with zeroes.
  472       If the element is an aggregate, pad() is called recursively.
  473      */
  474      pad(tpx)
  475       struct type *tpx;
  476      {
  477       register struct type *tp = tpx;
  478       register arith sz = tp->tp_size;
  479
  480       gen_tpcheck(&tpx, 1);
  481       if (gen_error) return;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       14   
  482       switch (tp->tp_fund) {
  483       case UNION:
  484      #ifndef NOROPTION
  485          if (options['R']) {
  486             warning("initialisation of unions not allowed");
  487          }
  488      #endif
  489          break;
  490      #ifndef NOBITFIELD
  491       case FIELD:
  492          put_bf(tp, (arith)0);
  493          return;
  494      #endif NOBITFIELD
  495          default:
  496             break;
  497       }
  498
  499      #if DATAFIRST && defined(USE_TMP)
  500       if (!options['N'])  EM_File_No = 1;
  501      #endif
  502       if (initialize_const)  {
  503          while (sz && (constant_data & (word_size - 1))) {
  504             C_rom_icon("0",(arith)1);
  505             constant_data++;
  506             sz--;
  507             }
  508          constant_data += sz;
  509          while (sz >= word_size) {
  510             C_rom_cst((arith) 0);
  511             sz -= word_size;
  512             }
  513          while (sz) {
  514             C_rom_icon("0", (arith) 1);
  515             sz--;
  516             }
  517          }
  518       else  {
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       15   
  519          while (sz && (static_data & (word_size - 1))) {
  520             C_con_icon("0",(arith)1);
  521             static_data++;
  522             sz--;
  523             }
  524          static_data += sz;
  525          while (sz >= word_size) {
  526             C_con_cst((arith) 0);
  527             sz -= word_size;
  528          }
  529          while (sz) {
  530             C_con_icon("0", (arith) 1);
  531             sz--;
  532          }
  533       }
  534      #if DATAFIRST && defined(USE_TMP)
  535       EM_File_No = 0;
  536      #endif
  537      }
  538
  539      /*  check_ival() checks whether the initialisation of an element
  540       of a fundamental type is legal and, if so, performs the initialisation
  541       by directly generating the necessary code.
  542       No further comment is needed to explain the internal structure
  543       of this straightforward function.
  544      */
  545      check_ival(expp, tp)
  546       register struct type *tp;
  547       struct expr **expp;
  548      {
  549       /* The philosophy here is that ch7cast puts an explicit
  550          conversion node in front of the expression if the types
  551          are not compatible.  In this case, the initialisation
  552          expression is no longer a constant.
  553       */
  554       register struct expr *expr = *expp;
  555
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       16   
  556       switch (tp->tp_fund) {
  557       case CHAR:
  558       case SHORT:
  559       case INT:
  560       case LONG:
  561       case ENUM:
  562       case POINTER:
  563          ch7cast(expp, '=', tp);
  564          expr = *expp;
  565      #ifdef DEBUG
  566          print_expr("init-expr after cast", expr);
  567      #endif DEBUG
  568      #if DATAFIRST && defined(USE_TMP)
  569          if (!options['N']) EM_File_No = 1;
  570      #endif
  571          if (initialize_const) constant_data += tp->tp_size;
  572             else static_data += tp->tp_size;
  573          if (!is_ld_cst(expr))
  574             illegal_init_cst(expr);
  575          else
  576          if (expr->VL_CLASS == Const)
  577             con_int(expr);
  578          else
  579          if (expr->VL_CLASS == Name) {
  580             register struct idf *idf = expr->VL_IDF;
  581
  582             if (idf->id_def->df_level >= L_LOCAL)
  583                illegal_init_cst(expr);
  584             else  /* e.g., int f(); int p = f; */
  585             if (idf->id_def->df_type->tp_fund == FUNCTION)
  586                if (initialize_const) C_rom_pnam(idf->id_text);
  587                   else C_con_pnam(idf->id_text);
  588             else  /* e.g., int a; int *p = &a; */
  589                if (initialize_const) C_rom_dnam(idf->id_text, expr->VL_VALUE);
  590                   else C_con_dnam(idf->id_text, expr->VL_VALUE);
  591          }
  592          else {
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       17   
  593             ASSERT(expr->VL_CLASS == Label);
  594             if (initialize_const) C_rom_dlb(expr->VL_LBL, expr->VL_VALUE);
  595                else C_con_dlb(expr->VL_LBL, expr->VL_VALUE);
  596          }
  597      #if DATAFIRST && defined(USE_TMP)
  598          EM_File_No = 0;
  599      #endif
  600          break;
  601      #ifndef NOFLOAT
  602       case FLOAT:
  603       case DOUBLE:
  604          ch7cast(expp, '=', tp);
  605          expr = *expp;
  606      #ifdef DEBUG
  607          print_expr("init-expr after cast", expr);
  608      #endif DEBUG
  609      #if DATAFIRST && defined(USE_TMP)
  610          if (!options['N']) EM_File_No = 1;
  611      #endif
  612          if (initialize_const) constant_data += tp->tp_size;
  613             else static_data += tp->tp_size;
  614          if (expr->ex_class == Float) {
  615      #ifdef FLOATOPT
  616      #define FLOATSRC fbuf
  617             char fbuf[44];
  618             sprintf(fbuf, "%.20g", expr->FL_VALUE);
  619      #else
  620      #define FLOATSRC expr->FL_VALUE
  621      #endif
  622             if (initialize_const)
  623                C_rom_fcon(FLOATSRC, expr->ex_type->tp_size);
  624             else C_con_fcon(FLOATSRC, expr->ex_type->tp_size);
  625             }
  626          else
  627          if (expr->ex_class == Oper && expr->OP_OPER == INT2FLOAT) {
  628             /* float f = 1; */
  629             expr = expr->OP_RIGHT;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       18   
  630             if (is_cp_cst(expr))
  631                if (initialize_const) C_rom_fcon(long2str((long)expr->VL_VALUE, 10), tp->tp_size);
  632                   else C_con_fcon(long2str((long)expr->VL_VALUE, 10),
  633                   tp->tp_size);
  634             else
  635                illegal_init_cst(expr);
  636          }
  637          else
  638             illegal_init_cst(expr);
  639      #if DATAFIRST && defined(USE_TMP)
  640          EM_File_No = 0;
  641      #endif
  642          break;
  643      #endif NOFLOAT
  644
  645      #ifndef NOBITFIELD
  646       case FIELD:
  647          ch7cast(expp, '=', tp->tp_up);
  648          expr = *expp;
  649      #ifdef DEBUG
  650          print_expr("init-expr after cast", expr);
  651      #endif DEBUG
  652          if (is_cp_cst(expr))
  653             put_bf(tp, expr->VL_VALUE);
  654          else
  655             illegal_init_cst(expr);
  656          break;
  657      #endif NOBITFIELD
  658
  659       case ERRONEOUS:
  660       case FUNCTION:
  661          break;
  662       default:
  663          crash("check_ival");
  664       }
  665      }
  666
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       19   
  667      /*  ch_array() initialises an array of characters when given
  668       a string constant.
  669       Alignment is taken care of.
  670      */
  671      ch_array(tpp, ex)
  672       struct type **tpp;   /* type tp = array of characters */
  673       struct expr *ex;
  674      {
  675       register struct type *tp = *tpp;
  676       register arith length = ex->SG_LEN;
  677       char *s;
  678       arith ntopad;
  679
  680       ASSERT(ex->ex_class == String);
  681       if (tp->tp_size == (arith)-1) {
  682          /* set the dimension */
  683          tp = *tpp = construct_type(ARRAY, tp->tp_up, length, (struct formal*)0);
  684          ntopad = align(tp->tp_size, (int) word_size) - tp->tp_size;
  685       }
  686       else {
  687          arith dim = tp->tp_size / tp->tp_up->tp_size;
  688          extern char options[];
  689
  690          if (length > dim) {
  691             if (dim < (length - 1))
  692                expr_warning(ex,"too many initialisers for char array");
  693             length = dim;
  694          }
  695        ntopad = dim - length;
  696       }
  697       /* throw out the characters of the already prepared string  */
  698       s = ex->SG_VALUE;
  699       str_cst(s, (int) (length), initialize_const, 0);
  700       vfree(s);
  701       while (ntopad >= sizeof(zeroes)) {
  702          str_cst(zeroes,(int) sizeof(zeroes), initialize_const, 0);
  703          length += sizeof(zeroes);
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       20   
  704          ntopad -= sizeof(zeroes);
  705          }
  706       if (ntopad) {
  707          str_cst(zeroes, (int) ntopad, initialize_const, 0);
  708          length += ntopad;
  709          }
  710       if (initialize_const) constant_data += length;
  711          else static_data += length;
  712      }
  713
  714      /*  As long as some parts of the pipeline cannot handle very long string
  715       constants, string constants are written out in chunks
  716      */
  717      str_cst(str, len, rom, pad)
  718       register char *str;
  719       register int len;
  720      {
  721       arith chunksize = ((127 + word_size) / word_size) * word_size;
  722
  723      #if DATAFIRST && defined(USE_TMP)
  724       if (!options['N'])  EM_File_No = 1;
  725      #endif
  726       while (len > chunksize) {
  727          if (rom) C_rom_scon(str, chunksize);
  728             else C_con_scon(str, chunksize);
  729          len -= chunksize;
  730          str += chunksize;
  731       }
  732       if (rom) C_rom_scon(str, (arith) len);
  733          else C_con_scon(str, (arith) len);
  734       if (pad && (len & 3))
  735          if (rom) C_rom_scon("\000\000\000", (arith) 4 - (len&3));
  736             else C_con_scon("\000\000\000", (arith) 4 - (len&3));
  737      #if DATAFIRST && defined(USE_TMP)
  738       EM_File_No = 0;
  739      #endif
  740      }
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       21   
  741
  742      #ifndef NOBITFIELD
  743      /*  put_bf() takes care of the initialisation of (bit-)field
  744       selectors of a struct: each time such an initialisation takes place,
  745       put_bf() is called instead of the normal code generating routines.
  746       Put_bf() stores the given integral value into "field" and
  747       "throws" the result of "field" out if the current selector
  748       is the last of this number of fields stored at the same address.
  749      */
  750      put_bf(tp, val)
  751       struct type *tp;
  752       arith val;
  753      {
  754       static long field = (arith)0;
  755       static arith offset = (arith)-1;
  756       register struct field *fd = tp->tp_field;
  757       register struct sdef *sd =  fd->fd_sdef;
  758       static struct expr exp;
  759
  760       ASSERT(sd);
  761       if (offset == (arith)-1) {
  762          /* first bitfield in this field  */
  763          offset = sd->sd_offset;
  764          exp.ex_type = tp->tp_up;
  765          exp.ex_class = Value;
  766          exp.VL_CLASS = Const;
  767       }
  768       if (val != 0)  /* insert the value into "field" */
  769          field |= (val & fd->fd_mask) << fd->fd_shift;
  770       if (sd->sd_sdef == 0 || sd->sd_sdef->sd_offset != offset ||
  771           sd->sd_stype->tp_fund == UNION ) {
  772          /* the selector was the last stored at this address   */
  773          exp.VL_VALUE = field;
  774          con_int(&exp);
  775          if (initialize_const) constant_data += exp.ex_type->tp_size;
  776             else static_data += exp.ex_type->tp_size;
  777          field = (arith)0;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       22   
  778          offset = (arith)-1;
  779       }
  780      }
  781      #endif NOBITFIELD
  782
  783      int
  784      zero_bytes(sd)
  785       register struct sdef *sd;
  786      {
  787       /* fills the space between a selector of a struct
  788          and the next selector of that struct with zero-bytes.
  789       */
  790       register int n =
  791          (sd->sd_type->tp_fund!=FIELD || !sd->sd_sdef || sd->sd_sdef->sd_offset!=sd->sd_offset)?
  792          sd->sd_sdef->sd_offset - sd->sd_offset -
  793          size_of_type(sd->sd_type, "struct member")
  794          : 0;
  795       register int count = n;
  796
  797      #if DATAFIRST && defined(USE_TMP)
  798       if (!options['N'])  EM_File_No = 1;
  799      #endif
  800       while (n-- > 0)
  801          con_nullbyte();
  802      #if DATAFIRST && defined(USE_TMP)
  803       EM_File_No = 0;
  804      #endif
  805       return count;
  806      }
  807
  808      int
  809      valid_type(tp, str)
  810       struct type *tp;
  811       char *str;
  812      {
  813       if (tp->tp_size < 0) {
  814          error("size of %s unknown", str);
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       23   
  815          return 0;
  816       }
  817       return 1;
  818      }
  819
  820      con_int(ex)
  821       register struct expr *ex;
  822      {
  823       register struct type *tp = ex->ex_type;
  824
  825      #if DATAFIRST && defined(USE_TMP)
  826       if (!options['N'])  EM_File_No = 1;
  827      #endif
  828       ASSERT(is_cp_cst(ex));
  829       if (tp->tp_unsigned)
  830          if (initialize_const)
  831             C_rom_ucon(long2str((long)ex->VL_VALUE, -10), tp->tp_size);
  832          else C_con_ucon(long2str((long)ex->VL_VALUE, -10), tp->tp_size);
  833       else
  834          if (initialize_const)
  835             C_rom_icon(long2str((long)ex->VL_VALUE, 10), tp->tp_size);
  836          else C_con_icon(long2str((long)ex->VL_VALUE, 10), tp->tp_size);
  837      #if DATAFIRST && defined(USE_TMP)
  838       EM_File_No = 0;
  839      #endif
  840      }
  841
  842      illegal_init_cst(ex)
  843       struct expr *ex;
  844      {
  845       expr_error(ex, "illegal initialisation constant");
  846       gen_error = 1;
  847      }
  848
  849      too_many_initialisers()
  850      {
  851       error("too many initialisers");
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       24   
  852       gen_error = 1;
  853      }
  854
  855      static arith fill_zero_bytes = 0;
  856      static arith bf_offset = (arith)-1;
  857
  858      initialize_to_zero(tpp,con,nest)
  859        struct type **tpp;
  860        int   con;
  861        int   nest;
  862      {
  863        register struct type *tp = *tpp;
  864
  865
  866        switch   (tp->tp_fund)  {
  867
  868        case CHAR:
  869        case SHORT:
  870        case INT:
  871        case LONG:
  872        case ENUM:
  873           fill_zero_bytes += tp->tp_size;
  874           break;
  875
  876        case FLOAT:
  877        case DOUBLE:
  878           zero_float(tp->tp_size,con);
  879           break;
  880
  881        case POINTER:
  882           zero_pointer(tp->tp_size,con);
  883           break;
  884
  885      #ifndef NOBITFIELD
  886        case FIELD:
  887           zero_field(tp->tp_size, con, tp->tp_field->fd_sdef);
  888           break;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       25   
  889      #endif
  890
  891        case STRUCT:
  892           {
  893              register struct sdef *sd = tp->tp_sdef;
  894              int bytes = 0, b;
  895              while (sd)  {
  896                 initialize_to_zero(&sd->sd_type,con,nest+1);
  897                 b = 0;
  898                 if (sd->sd_type->tp_fund != FIELD || !sd->sd_sdef ||
  899                        sd->sd_sdef->sd_offset != sd->sd_offset      )
  900                    b = sd->sd_type->tp_size;
  901                 bytes += (b<0) ? 1 : b;
  902                 if (sd->sd_sdef) b = pseudo_zero_bytes(sd);
  903                    else b = tp->tp_size - bytes;
  904                 fill_zero_bytes += b;
  905                 bytes += b;
  906                 sd = sd->sd_sdef;
  907              }
  908           }
  909           break;
  910
  911        case UNION:
  912           {
  913              register struct sdef *sd = tp->tp_sdef;
  914              if (sd) {
  915                 if (FIELD != sd->sd_type->tp_fund)
  916                    initialize_to_zero(&sd->sd_type,con,nest+1);
  917                 else fill_zero_bytes += sd->sd_type->tp_size;
  918                 }
  919              fill_zero_bytes += size_of_type(tp,"union") - sd->sd_type->tp_size;
  920           }
  921           break;
  922
  923        case ARRAY:
  924           {
  925              int sz = tp->tp_size;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       26   
  926              struct type *tpu = tp->tp_up;
  927              int elems, i;
  928
  929              while (tpu->tp_fund == ARRAY)
  930                 tpu = tpu->tp_up;
  931
  932              elems = ((sz < 0)? tpu->tp_size : sz) / tpu->tp_size;
  933
  934              switch   (tpu->tp_fund) {
  935              case STRUCT:
  936              case UNION:
  937                 for (i=0; i<elems; i++)
  938                    initialize_to_zero(&tpu,con,nest+1);
  939                 break;
  940
  941              case POINTER:
  942                 for (i=0; i<elems; i++)
  943                    zero_pointer(tpu->tp_size, con);
  944                 break;
  945
  946              case FLOAT:
  947              case DOUBLE:
  948                 for (i=0; i<elems; i++)
  949                    zero_float(tpu->tp_size, con);
  950                 break;
  951
  952      #ifndef NOBITFIELD
  953              case FIELD:
  954                 for (i=0; i<elems; i++)
  955                    zero_field(tpu->tp_size, con, tpu->tp_field->fd_sdef);
  956                 break;
  957      #endif
  958
  959              default:
  960                 fill_zero_bytes += elems * tpu->tp_size;
  961              }
  962           }
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       27   
  963        }
  964        if (fill_zero_bytes && !nest) force_zeroes(fill_zero_bytes,con), fill_zero_bytes = 0;
  965      }
  966
  967      force_zeroes(n,con)
  968        int n;
  969      {
  970      #if DATAFIRST && defined(USE_TMP)
  971        if (!options['N']) EM_File_No = 1;
  972      #endif
  973
  974        if (con) {
  975           while (n && (constant_data & (word_size - 1)))   {
  976              C_rom_ucon("0",(arith)1);
  977              constant_data++;
  978              n--;
  979              }
  980           while (n >= word_size)   {  /* >= 5/4/89 */
  981              C_rom_cst((arith)0);
  982              constant_data += word_size;
  983              n -= word_size;
  984              }
  985           while (n)   {
  986              C_rom_ucon("0",(arith)1);
  987              constant_data++;
  988              n--;
  989              }
  990           }
  991        else {
  992           int l;
  993           while (n && (static_data & (word_size - 1)))   {
  994              C_con_ucon("0",(arith)1);
  995              static_data++;
  996              n--;
  997              }
  998           if (n >= word_size) {       /* >= 5/4/89 */
  999              l = n % word_size;
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       28   
 1000              C_bss_cst((arith)n-l,(arith)0, 1);
 1001              static_data += n-l;
 1002              n = l;
 1003              }
 1004           while (n)   {
 1005              C_con_ucon("0",(arith)1);
 1006              static_data++;
 1007              n--;
 1008              }
 1009           }
 1010      #if DATAFIRST && defined(USE_TMP)
 1011        EM_File_No = 0;
 1012      #endif
 1013      }
 1014
 1015      zero_float(sz, con)
 1016        arith sz;
 1017        int   con;
 1018      {
 1019        if (fill_zero_bytes)   force_zeroes(fill_zero_bytes, con), fill_zero_bytes = 0;
 1020      #if DATAFIRST && defined(USE_TMP)
 1021        if (!options['N']) EM_File_No = 1;
 1022      #endif
 1023        if (con) {
 1024           C_rom_fcon("0", sz);
 1025           constant_data += sz;
 1026           }
 1027        else  {
 1028           C_con_fcon("0", sz);
 1029           static_data += sz;
 1030        }
 1031      #if DATAFIRST && defined(USE_TMP)
 1032        EM_File_No = 0;
 1033      #endif
 1034      }
 1035
 1036      zero_pointer(sz, con)
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       29   
 1037        arith sz;
 1038        int   con;
 1039      {
 1040        if (fill_zero_bytes)   force_zeroes(fill_zero_bytes, con), fill_zero_bytes = 0;
 1041      #if DATAFIRST && defined(USE_TMP)
 1042        if (!options['N']) EM_File_No = 1;
 1043      #endif
 1044        if (con) {
 1045           C_rom_ucon("3084", sz);       /*** NULLSID ***/
 1046           constant_data += sz;
 1047           }
 1048        else  {
 1049           C_con_ucon("3084", sz);       /*** NULLSID ***/
 1050           static_data += sz;
 1051           }
 1052      #if DATAFIRST && defined(USE_TMP)
 1053        EM_File_No = 0;
 1054      #endif
 1055      }
 1056
 1057      zero_field(sz, con, sd)
 1058        arith sz;
 1059        int   con;
 1060        struct sdef *sd;
 1061      {
 1062        if (bf_offset == (arith)-1) bf_offset = sd->sd_offset;
 1063
 1064        if (sd->sd_sdef == 0  ||  sd->sd_sdef->sd_offset != bf_offset) {
 1065           fill_zero_bytes += sz;
 1066           bf_offset = (arith)-1;
 1067           }
 1068      }
 1069
 1070      pseudo_zero_bytes(sd)
 1071        register struct sdef *sd;
 1072      {
 1073        /*    counts the space between a selector of a struct and
11:50 AUG 20 '97 zbc$ival:g.:ZBC3TSI                                       30   
 1074              the next selector and returns the number of bytes.
 1075        */
 1076        int n;
 1077        if (sd->sd_type->tp_fund != FIELD || sd->sd_sdef->sd_offset != sd->sd_offset)
 1078           n = sd->sd_sdef->sd_offset - sd->sd_offset - size_of_type(sd->sd_type,"struct member");
 1079        else n = 0;
 1080        return n;
 1081      }
 1082
 1083      zero_memory(bytes, coffset, fzero)
 1084        int bytes;
 1085        int *coffset;
 1086        void (*fzero)();
 1087      {
 1088      #if DATAFIRST && defined(USE_TMP)
 1089        if (!options['N']) EM_File_No = 1;
 1090      #endif
 1091        while ( bytes > 0  &&  (*coffset)&3 )
 1092           fzero("0",(arith)1), (*coffset)++, bytes--;
 1093
 1094        while ( bytes >= 4 )
 1095           fzero("0",(arith)4), *coffset += 4, bytes -= 4;
 1096
 1097        while ( bytes > 0 )
 1098           fzero("0",(arith)1), (*coffset)++, bytes--;
 1099
 1100      #if DATAFIRST && defined(USE_TMP)
 1101        EM_File_No = 0;
 1102      #endif
 1103      }
 1104
 1105      }
 1106

