

CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=1  
        1         1             /*P*
        2         2                   NAME: ou$tables:c
        3         3                   PURPOSE: This is the module to build the constant, label,
        4         4                   and symbol tables for the building of the object units.
        5         5
        6         6             */
        7         7             #include <stdio:h>
        8         8             #include <string:h>
        9         9             #include "zb6$ougen:h"
       10        10             #include "zb6$tables:h"
       11        11             #include "zb6$instructions:h"
       12        12             #include "codegen:h"
       13        13             #include "zb6$equate1:h"
       14        14             #include "zb_cp6_object:h"
       15        15
       16        16
       17        17             #define pl6str(_s_)  ( *(int *) buffer =0,\
       18        17                   strcpy( &buffer[2], _s_ ),\
       19        17                   *(int *)buffer |= strlen( &buffer[2]) << 18)
       20        20
       21        21             extern char buffer[512] ;
       22        22             struct constants *p ;
       23        23             struct labels *ll ;
       24        24             struct symbols *ss ;
       25        25             int float_tbl[] = {1,0,1,1,1,1,
       26        26    1              0,0,0,1,0,1,1,1,1,
       27        27    1              0,0,0,0,0,0,0,0,0,0,0,0,
       28        28    1              0,0,0,0,0,0,0,0,0,0,0,0,
       29        29    1              0,0,0,0,0,0,0,0,0,0,0,0 };
       30        30
       31        31             struct labels *last_lbl_ptr;
       32        32
       33        33             int local_storage ; /*  holds the amount of local storage used in
       34        34                                     the program..  */
       35        35             int next_log_blk_num[30];
       36        36             struct blk_info_tbl {
       37        37    1              int first_var;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=2  
       38        38    1              int last_var;
       39        39    1              int first_line_no;
       40        40    1              int last_line_no;
       41        41    1              int stmt_no;
       42        42    1              int last_stmt_no;
       43        43    1              int lex_depth;
       44        44    1              int log_blk_num;
       45        45    1              int name_offset;
       46        46    1              int stmt_count;
       47        47    1              };
       48        48
       49        49             struct blk_info_tbl blk_info[20];
       50        50
       51        51             int blk_count ; /* holds nesting count of debug blk count. */
       52        52             int length ;
       53        53             int *label_hash[601];
       54        54             int *symbol_hash[601];
       55        55             union {  double dtemp;
       56        56    1              int item[2]; } data;
       57        57             extern double curr_cons_value;
       58        58             extern int float_cons;
       59        59
       60        60             extern int last_opt;
       61        61             extern int opt;
       62        62
       63        63             extern int set_constant();
       64        64             extern int set_file_name();
       65        65             extern int set_static_storage();
       66        66             extern int debug_flag ;
       67        67             extern int integer_only_flag;
       68        68             extern int actual_stmt_count;
       69        69             extern int line_num;
       70        70             extern int static_function_flag;
       71        71             extern char *Srealloc();
       72        72             extern int debug_rec_match_flag ;
       73        73             struct sym_tbl *next_debug_rec;
       74        74             extern int global_store_flag ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=3  
       75        75             extern void set_global_debug_vars();
       76        76             extern char static_func_suffix[]; /* holds user speicifed suffix foe static fu
                               nctions. */
       77        77             extern double strtod();
       78        78
       79        79
       80        80             union h_s {
       81        81    1              char label_t[65];
       82        82    1              unsigned  int_text[8];}  h_stuff;
       83        83
       84        84             /* log_blk_num is the current logical debug blk number. */
       85        85             char blanks_32[] ={"                                              "};
       86        86             int curr_line_no;
       87        87             int local_temps;
       88        88             int one_val = {1};
       89        89             int zero_val = {0};
       90        90             int fourteen = {14};
       91        91             int seventeen = {17};
       92        92             int twenty_val = {20};
       93        93             int thirtyfive = {35};
       94        94             struct constants *last_int_ptr;
       95        95             struct two_halfs {
       96        96    1              unsigned top_half :18;
       97        97    1              unsigned bot_half :18;
       98        98    1               } instruc ;
       99        99             int save_f_count;
      100       100
      101       101             int addr_type_tbl[] = {0,
      102       102    1              1,  /* static -> static */
      103       103    1              2,  /* auto -> auto */
      104       104    1              1,  /* symref -> static */
      105       105    1              1,  /* symdef -> static */
      106       106    1              0,  /* field -> what ever struct is. */
      107       107    1              3 } ; /* based -> based */
      108       108
      109       109             int curr_offset_value ; /* contains the offset addr value for last struct head
                                processed. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=4  
      110       110             int curr_storage_class ;  /* holds the current storage class to be associated
      111       111                                     with the last level one item. */
      112       112             int curr_struct_type ;  /* holds the current gbl data type. */
      113       113             int curr_struct_reloc_type ; /* hold curreent struct operand type */
      114       114             int curr_struct_reloc_section ; /* hold curreent struct operand offset. */
      115       115             int hash_value;
      116       116             int prog_first_line_no; /* first line no in prog. is saved. */
      117       117             int last_line_no; /* last line no in the proc being processed. */
      118       118
      119       119             int minus_one_val = {-1};
      120       120             int current_set_use;
      121       121             int std_call = {STD_CALL};
      122       122                   int stmt_count; /* count of the number of stmt entries in the function.
                               */
      123       123
      124       124             int arg_check[2] = {0,-1};
      125       125             /*    The follwoing table the alignment values for all data types
      126       126                   that are associated with the variable debug records in o.u.
      127       127                   generation.
      128       128             */
      129       129             int align_vals[] = {0, /* null first value */
      130       130    1              1,0,1,0,0,0,0,0,3,3, /* first ten */
      131       131    1              3,3,1,1,1,1,3,1,4,3, /* second ten */
      132       132    1              3,3,0,4,3,3,4,0,2,1, /* third ten */
      133       133    1              3,2,2,3,3,3,1,0,1,1, /* fourth ten */
      134       134    1              1,1,1,1,1,1,1,1,1,1, /* fifth ten */
      135       135    1              1,1,1,1,1,1,1,1,1,1, /* sixth ten */
      136       136    1              1,1,1 } ;
      137       137
      138       138
      139       139
      140       140             #define NEW_ID   1
      141       141             #define OLD_ID   0
      142       142             #define POS_MASK 0377777777777
      143       143
      144       144             struct labels *lp,*ld,*last_ld;
      145       145             struct sym_tbl *last_sp;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=5  
      146       146
      147       147
      148       148             /*I*
      149       149                   NAME:myalloc
      150       150                   PURPOSE: This routine allocates the memory for each of the
      151       151                   data entities that are added to the tables for the label,
      152       152                   constants, and symbols.
      153       153             */
      154       154             short *myalloc(size) register size; {
      155       155    1         register short *p,*q;
      156       156    1         extern char *Malloc();
      157       157    1        extern int active_label;
      158       158    1
      159       159    1         p = (short *)Malloc(size);
      160       160    1
      161       161    1         if (p == NULL )
      162       162    1            perror("out of memory");
      163       163    1         for(q=p;size>0;size -= sizeof(short))
      164       164    1            *q++ = 0;
      165       165    1         return(p);
      166       166    1        }
      167       167             /*I*
      168       168                   NAME: set_constant
      169       169                   PURPOSE: This is the routine that converts the numeric
      170       170                   constants from string values to binary/hex values, and
      171       171                   builds entries in the constant table as well as generated
      172       172                   the o.u. for the specific constant in question.
      173       173                   It returns the offset address into the control section
      174       174                   where the constant has been allocated. It also setsup
      175       175                   the reloc_section and reloc_type globals for relocation
      176       176                   address generation.
      177       177             */
      178       178             set_constant(mode)  int mode;  {
      179       179    1
      180       180    1        int use_section;
      181       181    1        int digit;
      182       182    1        char digits[100];
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=6  
      183       183    1        int blank_count;
      184       184    1        int i;
      185       185    1        int val;
      186       186    1        unsigned unsval;
      187       187    1        int integer1;
      188       188    1        int exponent;
      189       189    1        int exponent_flag;
      190       190    1        constants_p next ;
      191       191    1        struct constants *d, *last_d ;
      192       192    1        struct constants *p;
      193       193    1
      194       194    1
      195       195    1              blank_count = 0;
      196       196    1              if (c == ' ') {
      197       197    2               while ((c=getc(infile)) ==  ' ')
      198       198    2                 blank_count++;  }
      199       199    1
      200       200    1              data.item[0] = 0;
      201       201    1              data.item[1] = 0;
      202       202    1              exponent = 0;
      203       203    1              exponent_flag = 0;
      204       204    1              length = 1;
      205       205    1              digits[0] =c;
      206       206    1              i=1;
      207       207    1
      208       208    1              if (mode == FLOAT_LIT || mode == DFLOAT_LIT) {
      209       209    2                 while ((c=getc(infile)) != ',' && c != ' ' && c != '\n' ) {
      210       210    3                    digits[i] = c;
      211       211    3                    i++;
      212       212    3                 }
      213       213    2                 digits[i] = '\000'; /* make sure non valid last charcter. */
      214       214    2              } else {
      215       215    2                 while((c=getc(infile)) != ',' && c != ' ' && c != '\n' && c != 'e' &&
                                c != 'E'
      216       216    2                        && c != 'd' && c != 'D') {
      217       217    3                   if (c == '.') {
      218       218    4                     if (integer_only_flag != 0 ) break;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=7  
      219       219    4                     exponent_flag = -1; }
      220       220    3                   else {
      221       221    4                     digits[i] = c;
      222       222    4                     i++;
      223       223    4                     length++;
      224       224    4                     if (exponent_flag !=0 ) {
      225       225    5                       exponent--; }
      226       226    4                   }
      227       227    3                 }  /* finihed building the numeric text string at this point. */
      228       228    2
      229       229    2                 if (c == 'e' || c == 'E' || c == 'd' || c == 'D') {
      230       230    3                   i = get_value();
      231       231    3                   exponent += i;
      232       232    3                 }
      233       233    2              }  /* end of if test on mode. */
      234       234    1
      235       235    1              check_eol();
      236       236    1
      237       237    1              if (curr_con_section == procsec && static_data_flag == 0) {
      238       238    2                use_section = conssec; }
      239       239    1              else {
      240       240    2                use_section = curr_con_section; }
      241       241    1
      242       242    1
      243       243    1              switch (mode) {
      244       244    2               case FLOAT_LIT:  /* floating point constant. */
      245       245    2               case DFLOAT_LIT:  /* double precision floating point constant. */
      246       246    2        /*      if (length > 20) {
      247       247    2                  i = length - 20;
      248       248    2                  length = 20;
      249       249    2                  exponent += i; }
      250       250    2                if (mode == DFLOAT_LIT) {
      251       251    2                  if (digits[0] == '-' || digits[0] == '+' ) {
      252       252    2                    length--;
      253       253    2                    if (digits[0] == '-' && (opt == ZCIF || opt == ZCID)) {
      254       254    2                       val = 0;
      255       255    2                       for (i=1; i <= length; i++) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=8  
      256       256    2                          val *= 10;
      257       257    2                          val += (digits[i] - '0'); }
      258       258    2                       val = -val;
      259       259    2                       unsval = val;
      260       260    2                       data.dtemp = unsval;
      261       261    2                     } else {
      262       262    2                      XPN_7LSPTOD (&data.dtemp, digits, &length, &exponent); }
      263       263    2                  } else {
      264       264    2                    XPN_7NSPTOD (&data.dtemp, digits, &length, &exponent);
      265       265    2                   }
      266       266    2                } else {
      267       267    2                  if (digits[0] == '-' || digits[0] == '+' ) {
      268       268    2                    length--;
      269       269    2                    XPN_7LSPTOR (&data.dtemp, digits, &length, &exponent);
      270       270    2                  } else {
      271       271    2                    XPN_7NSPTOR (&data.dtemp, digits, &length, &exponent);
      272       272    2                   }
      273       273    2                }  */ /* end of the test on the mode ... */
      274       274    2                if (digits[0] == '-' && (opt == ZCUF || opt == ZCUD)) {
      275       275    3                    val = 0;
      276       276    3                    for (i=1; i <= length; i++) {
      277       277    4                       val *= 10;
      278       278    4                       val += (digits[i] - '0'); }
      279       279    3                    val = -val;
      280       280    3                    unsval = val;
      281       281    3                    data.dtemp = unsval;  }
      282       282    2                else {
      283       283    3                    data.dtemp = strtod(digits); } /* use library routine to convert
      284       284    2                             decimal string to floating point constant. */
      285       285    2
      286       286    2                if (static_data_flag != 0 ) {
      287       287    3                  if (mode == FLOAT_LIT) {
      288       288    4                    float_cons = 1; }
      289       289    3                  else {
      290       290    4                    float_cons = 2; }
      291       291    3                  if (last_opt == ZNULL && last_lbl_ptr != NULL) {
      292       292    4                    last_lbl_ptr->have_cons = float_cons;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=9  
      293       293    4                    last_lbl_ptr->float_cons = data.dtemp;
      294       294    4                    last_lbl_ptr = NULL; }
      295       295    3                }
      296       296    2                if (dfloat_ptr != NULL)  {  /* not the first entry on the thread. */
      297       297    3                  for(d=(struct constants *)dfloat_ptr; d!=NULL; d =(struct constants
                               *) next) {
      298       298    4                    next = d->next ;
      299       299    4                    last_d = d;
      300       300    4                    if(d->uval.double_val == data.dtemp && static_data_flag == 0 && cu
                               rr_con_section != procsec) {
      301       301    5                      reloc_type = d->reloc_type ;
      302       302    5                      reloc_section = d->reloc_section ;
      303       303    5                      return (d->addr_offset);
      304       304    5                    }  /* end of if test on dfoat testing */
      305       305    4
      306       306    4                  } /* end of for loop testing for match on cons. */
      307       307    3                }  /* end of if test on thread already existing. */
      308       308    2
      309       309    2        /* build new entry if we get to this point. */
      310       310    2
      311       311    2                p = (struct constants *) myalloc(sizeof(struct constants));
      312       312    2                p->uval.double_val = data.dtemp ;
      313       313    2                p->next = NULL ;
      314       314    2                p->mode = mode ;
      315       315    2                p->reloc_type  = SECTION_TYPE ;
      316       316    2                p->reloc_section = use_section ;
      317       317    2                p->reloc_directive = UHALF_WORD ;
      318       318    2
      319       319    2                if (dfloat_ptr != NULL) {
      320       320    3                  last_d->next = &p->next; }
"zb6$tables:c.:ZBC3TSI", line 320: (warning) incompatible pointers in =
      321       321    2                else {
      322       322    3                  dfloat_ptr =(int *) p ;  }
      323       323    2
      324       324    2                if (mode == DFLOAT_LIT && (s_s_table[use_section].curr_offset %2) != 0
                               ) {
      325       325    3                  s_s_table[use_section].curr_offset++; }
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=10 
      326       326    2                p->addr_offset = s_s_table[use_section].curr_offset;
      327       327    2
      328       328    2                XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      329       329    2                          &data.item[0]);
      330       330    2
      331       331    2                s_s_table[use_section].curr_offset++;
      332       332    2
      333       333    2                if (mode == DFLOAT_LIT) {
      334       334    3                  XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      335       335    3                          &data.item[1]);
      336       336    3                  s_s_table[use_section].curr_offset++;  }
      337       337    2                break ;
      338       338    2
      339       339    2               case OCT_LIT:
      340       340    2               case HEX_LIT:
      341       341    2               case INT_LIT:  /* convert int cons to binary at this point. */
      342       342    2                switch (mode) {  /* this switch is for oct,hex and int data types */
      343       343    3                 case INT_LIT:  /* use lib routine to do the conversions. */
      344       344    3
      345       345    3                  if (digits[0] == '-' || digits[0] == '+') {
      346       346    4                    length--;
      347       347    4                    XPN_7LSPTOI (&integer1, digits, &length, &zero_val); }
      348       348    3                  else {
      349       349    4                    XPN_7NSPTOI (&integer1, digits, &length, &zero_val); }
      350       350    3                  break;
      351       351    3
      352       352    3                 case OCT_LIT:  /* convert octal constants here. */
      353       353    3
      354       354    3                    integer1 = 0;
      355       355    3                   for (i=0 ; i < length; i++) {
      356       356    4
      357       357    4                    c = digits[i];
      358       358    4                    integer1 = integer1 <<3;
      359       359    4                    integer1 |= (c - '0');
      360       360    4                     }   /*  end of while for octal constant processing. */
      361       361    3                  break;
      362       362    3                 case HEX_LIT:  /* convert hex constants here. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=11 
      363       363    3
      364       364    3                  for (i= 0 ; i < length ; i++ ) {
      365       365    4                    length--;
      366       366    4                    c = digits[i];
      367       367    4                    if(c >= 'A' && c <= 'Z') {
      368       368    5                      digit = c - 'A' +10;
      369       369    5                    } else {
      370       370    5                      if ( c >= 'a' && c <= 'z') {
      371       371    6                        digit = c - 'a' +10; }
      372       372    5                      else {
      373       373    6                        digit = c - '0'; }
      374       374    5                     }
      375       375    4                    integer1 = integer1<<4;
      376       376    4                    integer1 |= digit;
      377       377    4                  }  /* end of whie on input chars for conversion. */
      378       378    3                  break;
      379       379    3                 }  /* end of do case on inter data types.. */
      380       380    2
      381       381    2
      382       382    2                if (int_ptr != NULL && mode != OCT_LIT)  {  /* not the first entry on
                               the thread. */
      383       383    3                  for(d=(struct constants *)int_ptr; d!=NULL; d = next) {
      384       384    4                    next = d->next ;
      385       385    4                    last_d = d;
      386       386    4                    if(d->uval.int_val == integer1 && mode != OCT_LIT )  {
      387       387    5                      reloc_type = d->reloc_type ;
      388       388    5                      reloc_section = d->reloc_section ;
      389       389    5                      return (d->addr_offset);
      390       390    5                    }  /* end of if test on dfoat testing */
      391       391    4
      392       392    4                  } /* end of for loop testing for match on cons. */
      393       393    3                }  /* end of if test on thread already existing. */
      394       394    2                else {
      395       395    3                  if (int_ptr != NULL) {
      396       396    4                    last_d = last_int_ptr; }
      397       397    3                }
      398       398    2
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=12 
      399       399    2        /* build new entry if we get to this point. */
      400       400    2
      401       401    2                p = (struct constants *) myalloc(sizeof(struct constants));
      402       402    2                p->uval.int_val = integer1 ;
      403       403    2                p->next = NULL ;
      404       404    2                p->mode = mode ;
      405       405    2                p->reloc_type  = SECTION_TYPE ;
      406       406    2                p->reloc_section = use_section ;
      407       407    2                p->reloc_directive = UHALF_WORD ;
      408       408    2
      409       409    2                if (int_ptr != NULL) {
      410       410    3                  last_d->next = &p->next; last_int_ptr = p; }
"zb6$tables:c.:ZBC3TSI", line 410: (warning) incompatible pointers in =
      411       411    2                else {
      412       412    3                  int_ptr =(int *) p ; last_int_ptr = p;  }
      413       413    2
      414       414    2                p->addr_offset = s_s_table[use_section].curr_offset;
      415       415    2
      416       416    2                XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      417       417    2                          &integer1);
      418       418    2
      419       419    2                s_s_table[use_section].curr_offset++;
      420       420    2
      421       421    2                break ;
      422       422    2               case DEC_LIT:
      423       423    2                p = (struct constants *) myalloc(sizeof(struct constants));
      424       424    2                p->uval.int_val = integer1 ;
      425       425    2                p->next = NULL ;
      426       426    2                p->mode = mode ;
      427       427    2                p->reloc_type  = SECTION_TYPE ;
      428       428    2                p->reloc_section = use_section ;
      429       429    2                p->reloc_directive = UHALF_WORD ;
      430       430    2
      431       431    2                if (int_ptr != NULL) {
      432       432    3                  last_d->next = &p->next; }
"zb6$tables:c.:ZBC3TSI", line 432: (warning) incompatible pointers in =
      433       433    2                else {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=13 
      434       434    3                  int_ptr =(int *) p ;  }
      435       435    2
      436       436    2                p->addr_offset = s_s_table[use_section].curr_offset;
      437       437    2                i= 0;
      438       438    2                while (i < length) {
      439       439    3                 XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset, &digits[
                               i] ) ;
      440       440    3                 s_s_table[use_section].curr_offset++;
      441       441    3                 i += 4;
      442       442    3                 }
      443       443    2                break ;
      444       444    2
      445       445    2              }  /* end of do case on mode of the constants taht are being
      446       446    1                    processed. */
      447       447    1
      448       448    1              last_lbl_ptr = NULL;
      449       449    1              reloc_section = p->reloc_section;
      450       450    1              reloc_type = p->reloc_type;
      451       451    1              return (p->addr_offset);
      452       452    1
      453       453    1              }  /* end of the function get_constants.. */
      454       454
      455       455             /*i*
      456       456                   name: conv_i_to_f
      457       457                   purpose: This routine converts an inteer constatnt to a
      458       458                   floatinf point constant. Special routine for the special
      459       459                   integer to floaing point operator.
      460       460             */
      461       461             conv_i_to_f(kind) int kind; {
      462       462    1
      463       463    1              curr_instr.addr_offset = set_constant(kind);
      464       464    1
      465       465    1              if (kind == FLOAT_LIT) {
      466       466    2                curr_instr.op_code = CFLD >> 8; }
      467       467    1              else {
      468       468    2                curr_instr.op_code = CDFLD >> 8; }
      469       469    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=14 
      470       470    1              return;
      471       471    1        }
      472       472
      473       473
      474       474             /*i*
      475       475                   name: comv_f_to_i
      476       476                   purpose: This routine converts the inputted floating point
      477       477                   constant to integer.
      478       478             */
      479       479             conv_f_to_i(kind) int kind; {
      480       480    1
      481       481    1              integer_only_flag = 1;
      482       482    1              curr_instr.addr_offset = set_constant(kind);
      483       483    1              integer_only_flag = 0;
      484       484    1
      485       485    1              curr_instr.op_code = CLDQ >> 8;
      486       486    1
      487       487    1              return;
      488       488    1        }
      489       489
      490       490
      491       491             /*I*
      492       492                   NAME: set_use
      493       493                   PURPOSE: This routine sets up the current control section
      494       494                   that will be receiving the code that will be generated
      495       495                   until the next ZUSE operator is encountered.
      496       496             */
      497       497             set_use()  {   /* scan the control section value form the input
      498       498    1                          stream. It should be a single numeric caracter
      499       499    1                          item. */
      500       500    1        int i;
      501       501    1        int blank_count ;
      502       502    1
      503       503    1              blank_count =0;
      504       504    1              while ((c = getc(infile)) == ' ')
      505       505    1                   blank_count++;
      506       506    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=15 
      507       507    1              i = c - '0'; /* convert to integer... */
      508       508    1
      509       509    1             /* now scan to the end of line character... */
      510       510    1              while ((c = getc(infile)) != '\n')
      511       511    1                   blank_count++;
      512       512    1
      513       513    1              check_eol();
      514       514    1              current_set_use = i;
      515       515    1              switch (i)  {   /* run on control section type.. */
      516       516    2               case TXT_USE:
      517       517    2                 curr_con_section = procsec ;
      518       518    2                 break;
      519       519    2               case CON_USE:
      520       520    2                 curr_con_section = datasec ;
      521       521    2                 break;
      522       522    2               case ROM_USE:
      523       523    2                 curr_con_section = conssec ;
      524       524    2                 break;
      525       525    2               case BSS_USE:
      526       526    2                 curr_con_section = datasec ;
      527       527    2                 break;
      528       528    2              }   /* end of the switch on control section types. */
      529       529    1              return;
      530       530    1              }  /* end of set_use... */
      531       531
      532       532             /*I*
      533       533                   NAME: set_addr_pointer
      534       534                   PURPOSE: This routine builds a pointer to the literal address
      535       535                   that is referenced in the instruction that is being processed.
      536       536                   A pointer to the id is generated and stored in static
      537       537                   storage. The location where the pointer is stored is returned
      538       538                   to the calling function.
      539       539             */
      540       540             int set_addr_pointer()  {
      541       541    1
      542       542    1        int offset;
      543       543    1        int use_section;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=16 
      544       544    1        int oper;
      545       545    1        int temp;
      546       546    1        int temp_section;
      547       547    1        struct sym_tbl *sp;
      548       548    1        sym_tbl_p scan_and_search_for_id();
      549       549    1
      550       550    1
      551       551    1              global_store_flag = 1; /* find global name match. */
      552       552    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID); /* find the id.
                               */
      553       553    1              global_store_flag = 0; /* reset serach flag.. */
      554       554    1
      555       555    1              sp->ou_set_flag = -1; /* make sure set in this function. */
      556       556    1              reloc_type = sp->reloc_type;
      557       557    1              reloc_section = sp->reloc_section;
      558       558    1              offset = sp->offset ;
      559       559    1              check_for_plus(&offset);
      560       560    1              if (reloc_type == 0) { /* need to set symref info stuff for
      561       561    2                                        this undefined global symref... */
      562       562    2                if (static_data_flag != 0 && sp->addr_type == 1) {
      563       563    3                  /* static data type entity yet undefined at this point. */
      564       564    3                  forward_ref_flag = 1;
      565       565    3                  reloc_type = FREF_AUTO;
      566       566    3                  reloc_section = forward_ref_count;
      567       567    3                  fwd_p->fwd_tbl[forward_ref_count++] = (int *) sp;
      568       568    3                  if (forward_ref_count >= fwd_tbl_size) {
      569       569    4                     fwd_p = (fwd_ref_p) Srealloc(fwd_p, (fwd_tbl_size+400)* sizeof(sh
                               ort));
      570       570    4                     fwd_tbl_size += 400;
      571       571    4                    }
      572       572    3                } else {
      573       573    3                  sp->addr_type = SYMREF_TYPE;
      574       574    3                  set_reloc_stuff (sp);
      575       575    3                  reloc_type = sp->reloc_type;
      576       576    3                  reloc_section = sp->reloc_section;  }
      577       577    2              }
      578       578    1              if (curr_con_section == procsec && static_data_flag == 0) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=17 
      579       579    2                use_section = conssec; }
      580       580    1              else {
      581       581    2                use_section = curr_con_section; }
      582       582    1              temp = offset << 16; /* shift to upper half of the word, for byte addr.
                               */
      583       583    1              XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      584       584    1                        &temp);
      585       585    1              if (forward_ref_flag == 0) {  /* have forward ref of static id. */
      586       586    2                XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      587       587    2                   &reloc_type, &reloc_section, &one_val, &zero_val,
      588       588    2                   &seventeen, &zero_val);
      589       589    2              } else {
      590       590    2                forward_ref_flag = 0;
      591       591    2                temp_section = FREF_TYPE;
      592       592    2                temp = FREF_SNAM;
      593       593    2                XUO$RELOC(&use_section,&s_s_table[use_section].curr_offset,
      594       594    2                  &temp_section, &reloc_section, &temp, &zero_val,&seventeen,
      595       595    2                  &zero_val);
      596       596    2                temp_section = FREF_TYPE;
      597       597    2                XUO$RELOC(&use_section, &s_s_table[use_section].curr_offset,
      598       598    2                  &temp_section, &reloc_section, &reloc_type, &zero_val,
      599       599    2                  &seventeen);  }
      600       600    1              oper = 6;
      601       601    1              XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      602       602    1                   &oper, &xbo_seg_ref_id, &fourteen, &twenty_val,
      603       603    1                   &thirtyfive ,&zero_val);
      604       604    1              reloc_type = SECTION_TYPE ;
      605       605    1              reloc_section = use_section;
      606       606    1              temp = s_s_table[use_section].curr_offset;
      607       607    1              s_s_table[use_section].curr_offset++;
      608       608    1              return (temp);
      609       609    1              }
      610       610
      611       611             /*I*
      612       612                   NAME: set_pointer
      613       613                   PURPOSE: This routine builds a pointer to the literal label
      614       614                   that is referenced in the instruction that is being processed.
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=18 
      615       615                   A pointer to the label is generated and stored in static
      616       616                   storage. The location where the pointer is stored is returned
      617       617                   to the calling function.
      618       618             */
      619       619             int set_pointer()  {
      620       620    1
      621       621    1        int offset;
      622       622    1        int temp_section;
      623       623    1        int use_section;
      624       624    1        int oper;
      625       625    1        int temp;
      626       626    1
      627       627    1              offset = set_stmt_lbl (REFED);
      628       628    1              check_for_plus(&offset);
      629       629    1
      630       630    1              if (curr_con_section == procsec && static_data_flag == 0) {
      631       631    2                use_section = conssec; }
      632       632    1              else {
      633       633    2                use_section = curr_con_section; }
      634       634    1              temp = offset << 16; /* shift to upper half of the word, for byte addr.
                               */
      635       635    1              XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      636       636    1                        &temp);
      637       637    1              if (forward_ref_flag == 0) {  /* non zero - lbl defed already. */
      638       638    2                XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      639       639    2                   &reloc_type, &reloc_section, &one_val, &zero_val,
      640       640    2                   &seventeen, &zero_val);  }
      641       641    1              else {  /* have to make relocation reference here... */
      642       642    2                forward_ref_flag = 0;
      643       643    2                temp_section = FREF_TYPE;
      644       644    2                temp = FREF_SLBL;
      645       645    2                XUO$RELOC(&use_section,&s_s_table[use_section].curr_offset,
      646       646    2                  &temp_section, &reloc_section, &temp, &zero_val,&seventeen,
      647       647    2                  &zero_val);
      648       648    2                temp_section = FREF_TYPE;
      649       649    2                XUO$RELOC(&use_section, &s_s_table[use_section].curr_offset,
      650       650    2                  &temp_section, &reloc_section, &reloc_type, &zero_val,
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=19 
      651       651    2                  &seventeen);  }
      652       652    1              oper = 6;
      653       653    1              XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      654       654    1                   &oper, &xbo_seg_ref_id, &fourteen, &twenty_val,
      655       655    1                   &thirtyfive ,&zero_val);
      656       656    1              reloc_type = SECTION_TYPE ;
      657       657    1              reloc_section = use_section;
      658       658    1              temp = s_s_table[use_section].curr_offset;
      659       659    1              s_s_table[use_section].curr_offset++;
      660       660    1              return (temp);
      661       661    1              }
      662       662
      663       663             /*i*
      664       664                   NAME: set_ptr_to_id
      665       665                   PURPOSE: This routine generates a pointer to the passed
      666       666                   id or label and sets it inot the current control section.
      667       667                   The current control section should be a data or constant
      668       668                   control section.
      669       669                   This routine uses the functions set_pointer and set_addr_pointer
      670       670                   to so the actual building of the relocation directives for
      671       671                   the generation of the pointer in storage.
      672       672
      673       673             */
      674       674             set_ptr_to_id() {
      675       675    1
      676       676    1              while ((c=getc(infile)) == ' ') {}
      677       677    1
      678       678    1              if (c == '@') {   /* have a lbl to generate a pointer to. */
      679       679    2                ungetc(c,infile);
      680       680    2                set_pointer();
      681       681    2                return;
      682       682    2               }
      683       683    1              /* have id at this point. */
      684       684    1
      685       685    1              ungetc(c,infile);
      686       686    1              set_addr_pointer();
      687       687    1              return;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=20 
      688       688    1              }  /* end of the function set_ptr_to_id. */
      689       689
      690       690             /*i*
      691       691                   name:set_ptr_to_function
      692       692                   purpose: This routine sets the the passed pointer into a
      693       693                   storage location and generates a pointer to it. It assumes
      694       694                   that the id is a function name.
      695       695             */
      696       696             set_ptr_to_function () {
      697       697    1        int offset;
      698       698    1        int use_section;
      699       699    1        int oper;
      700       700    1        int temp;
      701       701    1        struct sym_tbl *sp;
      702       702    1
      703       703    1              while ((c = getc(infile)) == ' ') { }
      704       704    1              ungetc (c, infile);
      705       705    1              if (c == '@') { /* We have a label to generate a pointer to it*/
      706       706    2                 set_pointer();
      707       707    2                 return(0);
      708       708    2              }
      709       709    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID); /* find the id.
                               */
      710       710    1
      711       711    1              sp->ou_set_flag = -1; /* make sure set in this function. */
      712       712    1              reloc_type = sp->reloc_type;
      713       713    1              reloc_section = sp->reloc_section;
      714       714    1              offset = sp->offset ;
      715       715    1              if (reloc_type == 0 || reloc_type == -1 || reloc_section == -1 || reloc_
                               section == 0) { /* need to set
      716       716    2                  entref info stuff for function id that hasn't been setup. */
      717       717    2                sp->sym_class = FUNCTION_CLASS ;
      718       718    2                sp->addr_type = 0; /* no address typoe associated with func call.*/
      719       719    2                set_reloc_stuff (sp);
      720       720    2                reloc_type = sp->reloc_type;
      721       721    2                reloc_section = sp->reloc_section;
      722       722    2                offset = 0 ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=21 
      723       723    2              }
      724       724    1              check_for_plus(&offset);
      725       725    1
      726       726    1              if (curr_con_section == procsec && static_data_flag == 0) {
      727       727    2                use_section = conssec; }
      728       728    1              else {
      729       729    2                use_section = curr_con_section; }
      730       730    1              temp = offset << 16; /* shift to upper half of the word, for byte addr.
                               */
      731       731    1              XUO$PRGM (&use_section, &s_s_table[use_section].curr_offset,
      732       732    1                        &temp);
      733       733    1              XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      734       734    1                   &reloc_type, &reloc_section, &one_val, &zero_val,
      735       735    1                   &seventeen, &zero_val);
      736       736    1              oper = 6;
      737       737    1              XUO$RELOC (&use_section, &s_s_table[use_section].curr_offset,
      738       738    1                   &oper, &xbo_seg_ref_id, &fourteen, &twenty_val,
      739       739    1                   &thirtyfive ,&zero_val);
      740       740    1              reloc_type = SECTION_TYPE ;
      741       741    1              reloc_section = use_section;
      742       742    1              temp = s_s_table[use_section].curr_offset;
      743       743    1              s_s_table[use_section].curr_offset++;
      744       744    1              return (temp);
      745       745    1              }
      746       746
      747       747
      748       748             /*i*
      749       749                   name: set_stmt_lbl
      750       750                   purpose: This routine scan the lbl, hashes it, searches the
      751       751                   label table, and builds label table entries if necessary.
      752       752                   It also generated the relocation code to forwards lbl refs
      753       753                   when the def stmt if found. For refs of already defined
      754       754                   lbls, it returns the relocation values in the appropriate
      755       755                   locations.
      756       756
      757       757             */
      758       758             set_stmt_lbl(kind)  int kind;  {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=22 
      759       759    1        int blank_count;
      760       760    1        int i;
      761       761    1        int length;
      762       762    1        int hash_value;
      763       763    1        labels_p next;
      764       764    1        struct sym_tbl *sp;
      765       765    1
      766       766    1
      767       767    1        /*    At this point setup for the moving of the text from the
      768       768    1              file to memory. */
      769       769    1        /*    if (kind == DEFED && curr_con_section == datasec) {
      770       770    1                i = s_s_table[datasec].curr_offset% 2 ;
      771       771    1                if ( i != 0) {
      772       772    1                   s_s_table[datasec].curr_offset ++;  } }   */
      773       773    1              /* make sure constatn section lbls are curently on dbl
      774       774    1                 word boundarys.  */
      775       775    1
      776       776    1              strcpy(h_stuff.label_t, blanks_32);  /* blank out lbl text area */
      777       777    1              last_ld = NULL ;
      778       778    1              blank_count = 0;
      779       779    1              while ((c =getc(infile)) == ' ')
      780       780    1                  blank_count++;
      781       781    1              if (static_data_flag != 0 && c != '@' && kind == DEFED) {
      782       782    2                ungetc(c,infile);
      783       783    2                last_lbl_ptr = NULL;
      784       784    2                symdef_flag = 1;
      785       785    2                global_store_flag = 1; /* find global name match. */
      786       786    2                sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
      787       787    2                global_store_flag = 0; /* reset serach flag.. */
      788       788    2                /* if symdef or static item, allocate it in current data sec. */
      789       789    2                if (sp->addr_type == SYMDEF_TYPE || sp->addr_type == 1) { set_reloc_st
                               uff(sp); }
      790       790    2                symdef_flag = 0;
      791       791    2                return(0);
      792       792    2              }
      793       793    1
      794       794    1              h_stuff.label_t[0] = c;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=23 
      795       795    1              i = 1;
      796       796    1              length = 1;
      797       797    1              while ((c =getc(infile)) != ' ' && c != ',' && c != '\n' && c != '+' ) {

      798       798    2               h_stuff.label_t[i] = c;
      799       799    2               i++;
      800       800    2               length++;
      801       801    2              }  /* end of the while loop getting label text */
      802       802    1              h_stuff.label_t[i] = '\0';
      803       803    1              check_eol();
      804       804    1              /* do the hasing of the lbl at this point. */
      805       805    1
      806       806    1              hash_value = h_stuff.int_text[0] + h_stuff.int_text[1];
      807       807    1              hash_value = hash_value * hash_value;
      808       808    1              hash_value = (hash_value & POS_MASK)% 601;  /* may want to make
      809       809    1                                                    this value bigger. */
      810       810    1              lp = (struct labels *) label_hash[hash_value];
      811       811    1              if (lp == NULL) {  /* empty hash table entry; build new
      812       812    2                                    hash table entry. */
      813       813    2                bld_lbl_tbl (hash_value, kind);
      814       814    2                return (0);
      815       815    2               }
      816       816    1              /*  Search for match of current label.. */
      817       817    1
      818       818    1              for (ld = lp; ld != NULL ; ld = next) {
      819       819    2                next = ld->next;
      820       820    2                last_ld = ld;
      821       821    2                if ((i=strcmp(h_stuff.label_t,ld->lname)) == 0) {
      822       822    3                    /* have a match here - same lbl already in the tbl. */
      823       823    3                  if (ld->refed != 0 && kind == DEFED) {
      824       824    4                     /* lbl was previously refed, and now it is defed.
      825       825    4                        Need to generate the relocation address into for
      826       826    4                        the previous refs. */
      827       827    4                     ld->def_use = current_set_use; /* mark curr con section.*/
      828       828    4                     if (static_data_flag != 0) {
      829       829    5                       ld->lbl_type = GLOBAL_STATIC_LBL; }
      830       830    4                     else {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=24 
      831       831    5                       ld->lbl_type = LOCAL_LBL; }
      832       832    4                     ld->defed = 1;
      833       833    4                     ld->offset = s_s_table[curr_con_section].curr_offset;
      834       834    4                     ld->reloc_section = curr_con_section;
      835       835    4                     return(0); /* no code is generated for this case. */
      836       836    4                     }
      837       837    3                  else {
      838       838    4                     if (kind == REFED && ld->defed )  {
      839       839    5                         /* have a ref of a previously defined lbl. */
      840       840    5                        reloc_type = ld->reloc_type;
      841       841    5                        reloc_section = ld->reloc_section;
      842       842    5                        reloc_directive = ld->reloc_directive;
      843       843    5                        if (reloc_section != static_con_ref_num) {
      844       844    6                           ld->have_cons = 0; }
      845       845    5                        if (ld->have_cons != 0 && float_tbl[opt - ZFLD] != 0) {
      846       846    6                          if (ld->float_cons != 0.0) {
      847       847    7                            float_cons = ld->have_cons;
      848       848    7                            curr_cons_value = ld->float_cons; }
      849       849    6                        }
      850       850    5
      851       851    5                        return (ld->offset);
      852       852    5                      } else {
      853       853    5                        bld_ref_thread_entry (ld);
      854       854    5                        return (0); } }
      855       855    3                 }  /*  end of if on name match, */
      856       856    2               } /* end of the for loop on matching of lbl texts */
      857       857    1
      858       858    1        /*    At this point we have no match on building label table
      859       859    1              entries.   */
      860       860    1              bld_lbl_tbl (hash_value, kind);  /* go produce the new lbl tbl entry */
      861       861    1
      862       862    1              return (0);
      863       863    1              }  /* end of set_stmt_lbl function. */
      864       864
      865       865             /*i*
      866       866                   name: bld_lbl_tbl
      867       867                   purpose: This routine builds the lbl tbl entry for the
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=25 
      868       868                   current lbl that is being processed. It receives two
      869       869                   parameters: the hash value, and the kind of lbl position
      870       870                   that is being processed: a ref or a def.
      871       871
      872       872             */
      873       873             bld_lbl_tbl(hash_value, r_d_kind)
      874       874             int hash_value;
      875       875             int r_d_kind;    {  /* start of the program. */
      876       876    1        labels_p lbl;
      877       877    1
      878       878    1              ld = (struct labels *) myalloc (sizeof(struct labels));
      879       879    1
      880       880    1              if (lbl_tbl_ptr == NULL ) {  /* put onto lbl tbl thread-all lbls. */
      881       881    2                first_lbl_tbl_ptr = ld;
      882       882    2                lbl_tbl_ptr = ld;
      883       883    2                ld->next_lbl_entry = NULL; }
      884       884    1              else {
      885       885    2                lbl = lbl_tbl_ptr;
      886       886    2                lbl->next_lbl_entry = ld;
      887       887    2                ld->next_lbl_entry = NULL;
      888       888    2                lbl_tbl_ptr = ld;
      889       889    2               }
      890       890    1              if (lp == NULL) {
      891       891    2                 label_hash[hash_value] = (int *)ld;
      892       892    2                 ld->previous = NULL;
      893       893    2                }
      894       894    1              else {
      895       895    2                last_ld->next = ld;
      896       896    2                ld->previous = last_ld;
      897       897    2                }
      898       898    1              ld->next = NULL;
      899       899    1              ld->hash_value = hash_value;
      900       900    1              ld->ref_thread = NULL;
      901       901    1              ld->offset = s_s_table[curr_con_section].curr_offset;
      902       902    1              ld->reloc_section = curr_con_section;
      903       903    1              ld->reloc_type = SECTION_TYPE;
      904       904    1              ld->reloc_directive = UHALF_WORD ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=26 
      905       905    1              strcpy (ld->lname, h_stuff.label_t);
      906       906    1
      907       907    1              switch (r_d_kind) {  /*  set the ref or def flag depending on
      908       908    2                                       which one we are processign.  */
      909       909    2               case DEFED:
      910       910    2                 if (static_data_flag != 0 ) {
      911       911    3                   ld->lbl_type = GLOBAL_STATIC_LBL;
      912       912    3                   ld->def_use = current_set_use;
      913       913    3                   }
      914       914    2                 else {
      915       915    3                   ld->lbl_type = LOCAL_LBL; }
      916       916    2                 ld->defed = 1;
      917       917    2                 break;
      918       918    2               case REFED:
      919       919    2                 ld->refed = 1;
      920       920    2                 break;
      921       921    2               }  /* end of the do case on def or ref.. */
      922       922    1
      923       923    1
      924       924    1              if (r_d_kind == DEFED) {
      925       925    2                ld->ref_thread = NULL;
      926       926    2                last_lbl_ptr = ld;
      927       927    2                return ;  }
      928       928    1
      929       929    1              /* The lbl tbl entry is now built. However, we have a ref
      930       930    1                 entry and now we must add a ref lbl tbl entry so that
      931       931    1                 we can eventually reset the actual address into the
      932       932    1                 instruction that is referencing the label.
      933       933    1              */
      934       934    1
      935       935    1              bld_ref_thread_entry (ld);
      936       936    1
      937       937    1              return ;
      938       938    1              }   /* end of the bld_lbl_tlb function. */
      939       939
      940       940             /*i*
      941       941                   name: bld_ref_thread_entry
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=27 
      942       942                   purpose: This routine is the one that sets up the lbl ref
      943       943                   tbl entry. It saves the information about where the lbl ref
      944       944                   occured, so that when the lblb def in encountered we cam set
      945       945                   the def address information into the ref control section
      946       946                   location.
      947       947             */
      948       948             bld_ref_thread_entry (lp)  struct labels *lp ;  {
      949       949    1        struct forward_refs *fp ,*next_fp, *fp1, *last_fp;
      950       950    1
      951       951    1              forward_ref_flag = -1;
      952       952    1              reloc_type = FREF_LBL ;
      953       953    1              reloc_directive = UHALF_WORD ;
      954       954    1              /*  build entry in the frwd ref table for later processing. */
      955       955    1              fwd_p->fwd_tbl[forward_ref_count] = (int *)lp;
      956       956    1              reloc_section = forward_ref_count ;
      957       957    1
      958       958    1              forward_ref_count++;  /* make sure never have zero offset.. */
      959       959    1              if (forward_ref_count >= fwd_tbl_size) {
      960       960    2                 fwd_p = (fwd_ref_p) Srealloc(fwd_p, (fwd_tbl_size+400)* sizeof(short)
                               );
      961       961    2                 fwd_tbl_size += 400;
      962       962    2                }
      963       963    1              fp = (struct forward_refs *) myalloc(sizeof(struct forward_refs));
      964       964    1
      965       965    1              if (lp->ref_thread == NULL) {
      966       966    2                lp->ref_thread =  fp;
      967       967    2              } else {
      968       968    2                for (fp1=lp->ref_thread; fp1 != NULL; fp1 = next_fp) {
      969       969    3                  last_fp = fp1;
      970       970    3                  next_fp = fp1->next; }
      971       971    2                last_fp->next = fp; }
      972       972    1
      973       973    1              fp->next = NULL;
      974       974    1              fp->offset = s_s_table[curr_con_section].curr_offset;
      975       975    1              fp->reloc_directive = UHALF_WORD;
      976       976    1              fp->reloc_type = SECTION_TYPE;
      977       977    1              fp->reloc_section = curr_con_section ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=28 
      978       978    1
      979       979    1              return;
      980       980    1              }  /* end of bld_ref_thread_entry function. */
      981       981
      982       982
      983       983
      984       984             /*i*
      985       985                   name: set_file_name
      986       986                   purpose: This routine gets the file name of the module
      987       987                   that is being processed and saves it away for generating
      988       988                   name in the obejct unit.
      989       989             */
      990       990             set_file_name()    {
      991       991    1        int i;
      992       992    1
      993       993    1              while ((c=getc(infile)) == ' ')
      994       994    1                   i++;
      995       995    1              i=0;
      996       996    1              if (c == '@' ) { /* HAVE LABEL -not test of fid. */
      997       997    2                ungetc(c, infile);
      998       998    2                i = set_stmt_lbl(REFED);
      999       999    2                return; }
     1000      1000    1              ungetc (c,infile);
     1001      1001    1              while ((c=getc(infile)) != ' ' && c != '\n' && c != ','
     1002      1002    1                      && c != EOF)  {
     1003      1003    2                 progname[i] = c;
     1004      1004    2                 }
     1005      1005    1              check_eol();
     1006      1006    1
     1007      1007    1              progname[i] = '\0';
     1008      1008    1
     1009      1009    1              return;  }  /* end of set_file_name function. */
     1010      1010
     1011      1011             /*i*
     1012      1012                   name: set_static_storage
     1013      1013                   purpose: Increments the current control section by n words.
     1014      1014             */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=29 
     1015      1015             set_static_storage()  {
     1016      1016    1        struct sym_tbl *sp;
     1017      1017    1        int offset;
     1018      1018    1        int i;
     1019      1019    1
     1020      1020    1              while ((c=getc(infile)) == ' ') {}
     1021      1021    1              if (c != ',') {
     1022      1022    2                ungetc(c,infile);
     1023      1023    2                if (c == '@') {  /* look for label */
     1024      1024    3                  set_stmt_lbl (DEFED);
     1025      1025    3                  offset = 0;
     1026      1026    3                  check_for_plus(&offset); }
     1027      1027    2                else { global_store_flag = 1;
     1028      1028    3                  sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1029      1029    3                  global_store_flag = 0;
     1030      1030    3                  sp->ou_set_flag = -1;
     1031      1031    3                  symdef_flag =1;
     1032      1032    3                  if (sp->addr_type == SYMDEF_TYPE || sp->addr_type == 1) { set_reloc_
                               stuff(sp); }
     1033      1033    3                  symdef_flag = 0;
     1034      1034    3                } /* end of if test for lbl. (@) */
     1035      1035    2                }
     1036      1036    1              i= get_value(); /* go get the numeric value from the input stream. */
     1037      1037    1              s_s_table[curr_con_section].curr_offset += i ;
     1038      1038    1
     1039      1039    1              return ; }  /*  end of set_static_storage. */
     1040      1040
     1041      1041             /*i*
     1042      1042                   name: set_var_info
     1043      1043                   purpose: This routine processes the variable record for the
     1044      1044                   instruction code file. It cntains all the info needed to
     1045      1045                   generate debug record information for the variable name in
     1046      1046                   the object unit.
     1047      1047             */
     1048      1048             set_var_info()  {  /* processign the PS_VAR_OP record. */
     1049      1049    1        int i;
     1050      1050    1        int old_level_no, old_data_type, old_addr_type, match;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=30 
     1051      1051    1        int old_stmt_no, old_line_no ,old_offset ;
     1052      1052    1        int old_ele_size, old_size_bytes, old_starting_bit, old_alignment;
     1053      1053    1        int count;
     1054      1054    1        int array_size;
     1055      1055    1        int array_rank;
     1056      1056    1        struct sym_tbl *sp, *sp1, *sp2, *last_sp, *next_sp;
     1057      1057    1        struct sym_debug_tbl *dp, *dp1;
     1058      1058    1        int indirect_ptr_count;
     1059      1059    1        sym_tbl_p bld_sym_tbl_entry();
     1060      1060    1        sym_tbl_p check_match();
     1061      1061    1
     1062      1062    1
     1063      1063    1              /*  start of the recrd processing..   */
     1064      1064    1              match = 0;
     1065      1065    1              if (debug_rec_match_flag != 0) { /* processing duplicate structures. */
     1066      1066    2                sp = check_match();  /* make sure new = old structure entity. */
     1067      1067    2                dp = sp->debug; /* ptr to the debug stuff for the id. */
     1068      1068    2              } else {  /* normal id processing follows. */
     1069      1069    2                sp = (struct sym_tbl *) scan_and_search_for_id(NEW_ID);  /* get sym tb
                               l entity */
     1070      1070    2                if (sp->debug == NULL) {  /* new sym tbl entry - no deug info. */
     1071      1071    3                  dp = (struct sym_debug_tbl *) myalloc(sizeof(struct sym_debug_tbl));

     1072      1072    3                  sp->debug =  dp;
     1073      1073    3                  match = 0;
     1074      1074    3                  }
     1075      1075    2                else {
     1076      1076    3                  dp = sp->debug;
     1077      1077    3                  old_level_no = dp->level_no;
     1078      1078    3                  old_line_no = dp->line_no;
     1079      1079    3                  old_stmt_no = dp->stmt_no;
     1080      1080    3                  old_data_type = dp->data_type;
     1081      1081    3                  old_addr_type = dp->addr_type;
     1082      1082    3                  old_offset = sp->offset;
     1083      1083    3                  old_starting_bit = dp->starting_bit;
     1084      1084    3                  old_alignment = dp->alignment;
     1085      1085    3                  old_ele_size = dp->ele_size;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=31 
     1086      1086    3                  old_size_bytes = dp->size_bytes;
     1087      1087    3                  match = 1; }
     1088      1088    2              }
     1089      1089    1              sp->ou_set_flag = -1;
     1090      1090    1
     1091      1091    1              if ((c =getc(infile)) != ',') {  /* have sructure name. */
     1092      1092    2               scan_name(sp->struct_name); /* scan the structure name - if one exists.
                                */
     1093      1093    2               /* scan the debug info and set it into the debug record of
     1094      1094    2                 the symbol table entry. */
     1095      1095    2               }
     1096      1096    1              dp->line_no  = get_value(); /* get the line no. */
     1097      1097    1              dp->stmt_no  = get_value(); /* get the stmt no. */
     1098      1098    1              dp->level_no  = get_value()+1; /* get the level no. */
     1099      1099    1              dp->addr_type = get_value(); /* get the addr type */
     1100      1100    1              if (dp->addr_type==SYMDEF_TYPE && static_data_flag == 0) {
     1101      1101    2                dp->addr_type = SYMREF_TYPE; }
     1102      1102    1
     1103      1103    1              sp->addr_type = dp->addr_type; /* save the addr type */
     1104      1104    1              dp->data_type = get_value(); /* get the data type */
     1105      1105    1              dp->size_bytes = get_value(); /* get the sizein bytes. */
     1106      1106    1              dp->ele_size = get_value(); /* get the element size. */
     1107      1107    1              dp->addr_byte = get_value(); /* get the byte address. */
     1108      1108    1              sp->offset = dp->addr_byte ;
     1109      1109    1              dp->starting_bit = get_value(); /* get the starting bit. */
     1110      1110    1              dp->alignment = get_value(); /* get alignment of the id. */
     1111      1111    1
     1112      1112    1              /* check if this case is really a replacement of a previous
     1113      1113    1                 structure... */
     1114      1114    1              if (static_data_flag != 0 && match != 0 &&
     1115      1115    1                  old_level_no == 1 && old_level_no == dp->level_no &&
     1116      1116    1                  old_addr_type == SYMREF_TYPE && old_data_type == STRUCTURE_DATA_TYPE
                                &&
     1117      1117    1                  old_data_type == dp->data_type && dp->addr_type == 4) {
     1118      1118    2                 debug_rec_match_flag = 1;
     1119      1119    2                 next_debug_rec = sp->next_sym_entry; }
     1120      1120    1              else {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=32 
     1121      1121    2                if (static_data_flag != 0 && match != 0 &&
     1122      1122    2                   old_level_no == 1 && ((old_addr_type == SYMREF_TYPE &&
     1123      1123    2                   old_data_type == STRUCTURE_DATA_TYPE) || old_addr_type == 4
     1124      1124    2                   || old_addr_type == STATIC_TYPE) &&
     1125      1125    2                   dp->level_no != 1 ) {  /* make new table entry for the
     1126      1126    3                                            current debug record being processed. */
     1127      1127    3        new_entry: ;
     1128      1128    3                   sp2 = (struct sym_tbl *) symbol_hash[hash_value];
     1129      1129    3                   if (sp2 == NULL) {
     1130      1130    4                     last_sp = NULL; }
     1131      1131    3                   else {
     1132      1132    4                     for (sp1 = sp2; sp1 != NULL; sp1 = next_sp) {
     1133      1133    5                       next_sp = sp1->next;
     1134      1134    5                       last_sp = sp1; }
     1135      1135    4                   }
     1136      1136    3                   sp1 = (struct sym_tbl *) bld_sym_tbl_entry(sp2, last_sp, hash_value
                               );
     1137      1137    3                   sp1->next = NULL;
     1138      1138    3                   sp1->debug = (struct sym_debug_tbl *) myalloc(sizeof(struct sym_deb
                               ug_tbl));
     1139      1139    3                   dp1 = sp1->debug;
     1140      1140    3                   dp1->line_no = dp->line_no;
     1141      1141    3                   dp1->stmt_no = dp->stmt_no;
     1142      1142    3                   dp1->level_no = dp->level_no;
     1143      1143    3                   dp1->addr_type = dp->addr_type;
     1144      1144    3                   dp1->data_type = dp->data_type;
     1145      1145    3                   dp1->size_bytes = dp->size_bytes;
     1146      1146    3                   dp1->ele_size = dp->ele_size;
     1147      1147    3                   dp1->addr_byte = dp->addr_byte;
     1148      1148    3                   dp1->starting_bit = dp->starting_bit;
     1149      1149    3                   dp1->alignment = dp->alignment;
     1150      1150    3                   dp->level_no = old_level_no;
     1151      1151    3                   dp->addr_type = old_addr_type ;
     1152      1152    3                   dp->data_type = old_data_type ;
     1153      1153    3                   sp->addr_type = old_addr_type;
     1154      1154    3                   sp->offset = old_offset;
     1155      1155    3                   dp->line_no = old_line_no ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=33 
     1156      1156    3                   dp->stmt_no = old_stmt_no ;
     1157      1157    3                   dp->alignment = old_alignment;
     1158      1158    3                   dp->starting_bit = old_starting_bit;
     1159      1159    3                   dp->size_bytes = old_size_bytes;
     1160      1160    3                   dp->ele_size = old_ele_size;
     1161      1161    3
     1162      1162    3
     1163      1163    3                   sp = sp1;  /* set up for new tl entry. */
     1164      1164    3                   dp = dp1;  /* set up for new tl entry. */
     1165      1165    3                }
     1166      1166    2                else {
     1167      1167    3                   if (static_data_flag != 0 && match != 0 && old_level_no != 1
     1168      1168    3                      && dp->level_no == 1) {
     1169      1169    4                     goto new_entry; }
     1170      1170    3                }
     1171      1171    2              } /* end of the test on special id processing.... */
     1172      1172    1
     1173      1173    1              dp->array_rank = 0;
     1174      1174    1              dp->array_rec_count = 0;
     1175      1175    1              count = get_value(); /* get number of items following. */
     1176      1176    1              if (count != 0) {
     1177      1177    2                indirect_ptr_count = get_value(); /* chk for ptr type. */
     1178      1178    2                count--;
     1179      1179    2                if (indirect_ptr_count != 0) {
     1180      1180    3                  dp->size_bytes = 4;
     1181      1181    3                  dp->ele_size = 4;
     1182      1182    3                  dp->data_type = POINTER_DATA_TYPE; }
     1183      1183    2
     1184      1184    2                  while (count >0 && c != '\n') {
     1185      1185    3                array_rank = get_value(); /* get array rank - # of dims. */
     1186      1186    3                count--;  /* decrement count for rand operand.  */
     1187      1187    3                dp->array_rank = array_rank;
     1188      1188    3                dp->array_rec_count = array_rank;
     1189      1189    3                count -= array_rank ;
     1190      1190    3                if (array_rank != 0) {
     1191      1191    4                  i = 0;
     1192      1192    4                  while (array_rank > 0) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=34 
     1193      1193    5                    dp->array_info[i] = get_value();
     1194      1194    5                    if (dp->array_info[i] == -1) {
     1195      1195    6                      if (dp->data_type == 2 || dp->data_type == 4) {
     1196      1196    7                         dp->array_info[i] = 8; }
     1197      1197    6                      else {
     1198      1198    7                         dp->array_info[i] = 4; }  }
     1199      1199    5                    if (i == 0) {
     1200      1200    6                      array_size = dp->array_info[i]; }
     1201      1201    5                    i++;
     1202      1202    5                    array_rank--; }
     1203      1203    4                  dp->array_size = array_size;
     1204      1204    4                 }
     1205      1205    3                  if (count > 0) {
     1206      1206    4                     count--;
     1207      1207    4                indirect_ptr_count = get_value(); /* pointer trait check. */
     1208      1208    4                if (indirect_ptr_count != 0) {
     1209      1209    5                  dp->size_bytes = 4;
     1210      1210    5                  dp->ele_size = 4;
     1211      1211    5                  dp->data_type = POINTER_DATA_TYPE; }
     1212      1212    4                  }   /* if terminus. */
     1213      1213    3                  }   /* while loop on count terminus. */
     1214      1214    2              }  /* end of array  arg processing for the variable id. */
     1215      1215    1
     1216      1216    1              get_eol(); /* make sure we are at eol. */
     1217      1217    1              check_eol();
     1218      1218    1
     1219      1219    1              /* finish generating the recolation stuff and o.u.
     1220      1220    1                 record debug stuff....
     1221      1221    1              */
     1222      1222    1              /* if static storage item, dont allocate it. */
     1223      1223    1              if (sp->addr_type != 1 || (static_data_flag == 0 && dp->addr_byte != 0))
                                {
     1224      1224    2                set_reloc_stuff (sp);  }
     1225      1225    1              build_debug (sp);
     1226      1226    1
     1227      1227    1              return;
     1228      1228    1              }  /* end of set_var_info function. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=35 
     1229      1229
     1230      1230             /*I*
     1231      1231                   NAME: scan_and_search_for_id
     1232      1232                   PURPOSE: This routine check if symtbl entry already exists for
     1233      1233                   the id, and if so, it returns pointer to the sym tbl entry.
     1234      1234                   Otherwise, a new symbol table entry is gnereated for the
     1235      1235                   new id.
     1236      1236             */
     1237      1237             sym_tbl_p  scan_and_search_for_id(new_old) int new_old; { /* scan the symbol t
                               able for id. */
     1238      1238    1        int i; int length;
     1239      1239    1        struct sym_tbl *sp, *sp1, *sp2, *next, *last_sp;
     1240      1240    1        struct sym_debug_tbl *dp;
     1241      1241    1        int blank_count;
     1242      1242    1        sym_tbl_p  bld_sym_tbl_entry();
     1243      1243    1
     1244      1244    1
     1245      1245    1              /* program starts here..  */
     1246      1246    1              strcpy(h_stuff.label_t, blanks_32);  /* blank out symbol text area */
     1247      1247    1              length = 1;
     1248      1248    1              last_sp = NULL ;
     1249      1249    1              blank_count = 0;
     1250      1250    1              while ((c =getc(infile)) == ' ')
     1251      1251    1                  blank_count++;
     1252      1252    1
     1253      1253    1              h_stuff.label_t[0] = c;
     1254      1254    1              i = 1;
     1255      1255    1              while ((c =getc(infile)) != ' ' && c != ',' && c != '\n' && c != '+') {
     1256      1256    2               h_stuff.label_t[i] = c;
     1257      1257    2               i++;
     1258      1258    2               length++;
     1259      1259    2              }  /* end of the while loop getting symbol text */
     1260      1260    1              h_stuff.label_t[i] = '\0';
     1261      1261    1              check_eol();
     1262      1262    1              /* do the hashing of the symbol at this point. */
     1263      1263    1
     1264      1264    1              hash_value = h_stuff.int_text[0] + h_stuff.int_text[1] + h_stuff.int_tex
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=36 
                               t[2] ;
     1265      1265    1              hash_value = hash_value * hash_value;
     1266      1266    1              hash_value = (hash_value & POS_MASK)% 601;  /* may want to make
     1267      1267    1                                                    this value bigger. */
     1268      1268    1              sp1 = (struct sym_tbl *) symbol_hash[hash_value];
     1269      1269    1
     1270      1270    1              if (sp1 == NULL) { /* build new symbol table entry.*/
     1271      1271    2                sp = (struct sym_tbl *) bld_sym_tbl_entry(sp1,last_sp,hash_value);
     1272      1272    2                sp->debug = NULL ;
     1273      1273    2                sp->next = NULL ;
     1274      1274    2                return (sp);
     1275      1275    2                }
     1276      1276    1              /*  search for match.. */
     1277      1277    1              for (sp2 = sp1; sp2 != NULL; sp2 = next) {
     1278      1278    2                next =  sp2->next;
     1279      1279    2                last_sp = sp2;
     1280      1280    2                if (( i=strcmp (h_stuff.label_t, sp2->name)) == 0 && (new_old == OLD_I
                               D || static_data_flag != 0)) {
     1281      1281    3                   if (global_store_flag != 0 && sp2->debug != NULL) {
     1282      1282    4                     if (sp2->debug->level_no > 1) {goto try_next; } }
     1283      1283    3                   if (static_data_flag != 0 && sp2->debug != NULL) {
     1284      1284    4                     dp = sp2->debug;
     1285      1285    4                     if ((dp->level_no > 1 || dp->data_type == STRUCTURE_DATA_TYPE) &&

     1286      1286    4                        symdef_flag == 0 ) {
     1287      1287    5                       if (dp->level_no == 1 && (dp->addr_type == SYMREF_TYPE ||
     1288      1288    5                           dp->addr_type == 1 || dp->addr_type == 4)) /* static or sym
                               def. */
     1289      1289    5                          { goto  return_ptr; }
     1290      1290    5                       for (sp= sp2; sp != NULL;sp = next) {
     1291      1291    6                         next = sp->next ;
     1292      1292    6                         last_sp = sp; }
     1293      1293    5                       break; }
     1294      1294    4                   }
     1295      1295    3                  /* have match on text names at this point. */
     1296      1296    3                  if (ref_name_flag != 0 && sp2->sym_class != FUNCTION_CLASS) {
     1297      1297    4                     goto try_next; }
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=37 
     1298      1298    3        return_ptr: ;
     1299      1299    3                  if (sp2->ou_set_flag == 0) { /* first use in this program. */
     1300      1300    4                    set_reloc_stuff(sp2);
     1301      1301    4                  }
     1302      1302    3                  return (sp2);
     1303      1303    3                   }  /* enf of if test on name match. */
     1304      1304    2        try_next: ;
     1305      1305    2                }  /* end of the loop on symbol names. */
     1306      1306    1
     1307      1307    1              /* at this point, no match was found so build new
     1308      1308    1                 new symbol table entry.  */
     1309      1309    1              sp = (struct sym_tbl *) bld_sym_tbl_entry (sp1,last_sp,hash_value);
     1310      1310    1
     1311      1311    1              sp->debug = NULL ;
     1312      1312    1              sp->next = NULL ;
     1313      1313    1              return (sp);
     1314      1314    1              }   /* end of the scan_and_serch_for_id function.. */
     1315      1315
     1316      1316             /*i*
     1317      1317                   name: bld_sym_tbl_entry
     1318      1318                   purpose: This routine builds the symbol table entry for
     1319      1319                   the current id taht is being processed..
     1320      1320             */
     1321      1321             sym_tbl_p  bld_sym_tbl_entry(sp,last_sp,hash_value)  struct sym_tbl *sp,*last_
                               sp;
     1322      1322             int hash_value;   {  /* routine follows.....  */
     1323      1323    1        struct sym_tbl *ssp , *sym ;
     1324      1324    1
     1325      1325    1              ssp = (struct sym_tbl *) myalloc(sizeof(struct sym_tbl));
     1326      1326    1              if (sym_tbl_ptr == NULL) { /*building sym tbl thread entry. */
     1327      1327    2                first_sym_tbl_ptr =ssp;
     1328      1328    2                sym_tbl_ptr =ssp;
     1329      1329    2                ssp->next_sym_entry = NULL; }
     1330      1330    1              else {
     1331      1331    2                sym = sym_tbl_ptr;
     1332      1332    2                ssp->next_sym_entry = NULL;
     1333      1333    2                sym->next_sym_entry = ssp;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=38 
     1334      1334    2                sym_tbl_ptr = ssp;
     1335      1335    2              }
     1336      1336    1              if (sp == NULL) {
     1337      1337    2                ssp->previous = NULL;
     1338      1338    2                symbol_hash[hash_value] = (int *)ssp; }
     1339      1339    1              else {
     1340      1340    2                ssp->previous = last_sp;
     1341      1341    2                last_sp->next = ssp ; }
     1342      1342    1
     1343      1343    1              strcpy (ssp->name, h_stuff.label_t);
     1344      1344    1              ssp->next = NULL;
     1345      1345    1              ssp->hash_value = hash_value;
     1346      1346    1              return (ssp);
     1347      1347    1              }   /* end of the bld_sym_tbl_entry function. */
     1348      1348
     1349      1349             /*i*
     1350      1350                   name: check_match
     1351      1351                   purpose: This routine is used to make sure that the names
     1352      1352                   of the current struct item to e replace is the same as the
     1353      1353                   current debug item off of the input stream...
     1354      1354             */
     1355      1355             sym_tbl_p check_match() {
     1356      1356    1        int i;
     1357      1357    1        char new_name[32];
     1358      1358    1        struct sym_tbl *sp;
     1359      1359    1
     1360      1360    1              sp = next_debug_rec ;
     1361      1361    1              scan_name (new_name);
     1362      1362    1              if ((i = strcmp(new_name, next_debug_rec->name)) != 0) {
     1363      1363    2                 printf ("mismatch on debug rec names %s and %s did not match. \n ",
     1364      1364    2                    new_name, next_debug_rec->name);
     1365      1365    2              }
     1366      1366    1
     1367      1367    1              next_debug_rec = next_debug_rec->next_sym_entry;
     1368      1368    1              if (next_debug_rec == NULL) {
     1369      1369    2                debug_rec_match_flag = 0;
     1370      1370    2              }
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=39 
     1371      1371    1              if (next_debug_rec->debug->level_no <= 1) {
     1372      1372    2                debug_rec_match_flag = 0;
     1373      1373    2              }
     1374      1374    1
     1375      1375    1              return (sp);
     1376      1376    1
     1377      1377    1              } /* end of the function check_match.. */
     1378      1378
     1379      1379             /*i*
     1380      1380                   name: scan_name
     1381      1381                   purpose: This routine puts the text name into the past
     1382      1382                   text field. The text name is gotten off on the input stream.
     1383      1383             */
     1384      1384             scan_name(st)  char *st;   {
     1385      1385    1        int i;
     1386      1386    1
     1387      1387    1              if (c == ' ') {
     1388      1388    2               while ((c=getc(infile)) == ' ')
     1389      1389    2                 i++;
     1390      1390    2                }
     1391      1391    1
     1392      1392    1              st[0] = c;
     1393      1393    1              i = 1;
     1394      1394    1              while ((c=getc(infile)) != ' ' && c != ',' && c != '\n' && c != '+' ) {
     1395      1395    2                st[i] = c;
     1396      1396    2                i++;
     1397      1397    2              }  /* end of the while loop.  */
     1398      1398    1              check_eol();
     1399      1399    1              st[i] = '\0' ;
     1400      1400    1
     1401      1401    1              return; }
     1402      1402
     1403      1403             /*i*
     1404      1404                   name: set_reloc_stuff
     1405      1405                   purpose: This routine does the allocation for all static
     1406      1406                   and sym defed items. It also sets the reloc_type, reloc_section
     1407      1407                   fields in the symbol table entry for all other types of is
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=40 
     1408      1408                   that are being processed.
     1409      1409                   Offset field is also set (if applicable).
     1410      1410
     1411      1411             */
     1412      1412             set_reloc_stuff(sp)  struct sym_tbl *sp;  {
     1413      1413    1        struct sym_debug_tbl *dp;
     1414      1414    1        int name_offset;
     1415      1415    1        int symref_num;
     1416      1416    1        int eref_num;
     1417      1417    1        char *ret_c;
     1418      1418    1        int j;
     1419      1419    1        char tmp1[128];
     1420      1420    1
     1421      1421    1              if ( ref_name_flag != 0 ) { return; }
     1422      1422    1                  /* IF ENTREF item skip this stuff.. */
     1423      1423    1              switch (sp->addr_type) {  /* switch on addr type.. */
     1424      1424    2               case STATIC_TYPE:
     1425      1425    2                if (sp->storage_class == GLOBAL_STATIC_STORAGE) return;
     1426      1426    2                if (static_data_flag == 0) {
     1427      1427    3                  if (sp->debug != NULL ) {
     1428      1428    4                    dp = sp->debug ;
     1429      1429    4                    if (dp->level_no ==1 && dp->addr_byte != 0 ) {
     1430      1430    5                      get_label_addr (sp, dp); }
     1431      1431    4                    else {
     1432      1432    5                      set_address(sp);
     1433      1433    5                      sp->reloc_type = SECTION_TYPE ;
     1434      1434    5                      sp->reloc_section = curr_con_section   ;  }
     1435      1435    4                  } else {
     1436      1436    4                    set_address(sp);
     1437      1437    4                    sp->reloc_type = SECTION_TYPE ;
     1438      1438    4                    sp->reloc_section = curr_con_section   ;  }
     1439      1439    3                  sp->storage_class = LOCAL_STATIC_STORAGE; }
     1440      1440    2                else {
     1441      1441    3                  set_address(sp);
     1442      1442    3                  sp->reloc_type = SECTION_TYPE ;
     1443      1443    3                  sp->reloc_section = curr_con_section   ;
     1444      1444    3                  sp->def_use = current_set_use ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=41 
     1445      1445    3                  sp->storage_class = GLOBAL_STATIC_STORAGE; }
     1446      1446    2
     1447      1447    2                break;
     1448      1448    2               case AUTO_TYPE:
     1449      1449    2                sp->reloc_section = -1;
     1450      1450    2                sp->reloc_type = -1;
     1451      1451    2                sp->storage_class = AUTO_STORAGE;
     1452      1452    2
     1453      1453    2                break;
     1454      1454    2               case SYMDEF_TYPE:
     1455      1455    2                if (symdef_flag == 0) { break; }
     1456      1456    2                sp->reloc_type = SECTION_TYPE;
     1457      1457    2                sp->reloc_section = curr_con_section;
     1458      1458    2                sp->offset = s_s_table[curr_con_section].curr_offset;
     1459      1459    2                bld_symdef (sp);
     1460      1460    2                sp->storage_class = GLOBAL_STORAGE;
     1461      1461    2
     1462      1462    2                break;
     1463      1463    2               case SYMREF_TYPE:
     1464      1464    2                sp->reloc_type = SYMREF_TYPE;
     1465      1465    2              /*  add name to the ref name talbe, and then add entry to the
     1466      1466    2                  symref table entry.
     1467      1467    2              */
     1468      1468    2
     1469      1469    2                if ((ret_c = strchr(sp->name, '#')) != (char *) 0) { return; }
     1470      1470    2                pl6str (sp->name) ;
     1471      1471    2                XUO$RNAME (buffer, &name_offset);
     1472      1472    2                XUO$SREF (&name_offset, &zero_val, &symref_num, &zero_val);
     1473      1473    2
     1474      1474    2                sp->reloc_section = symref_num ;
     1475      1475    2                sp->storage_class = GLOBAL_STORAGE;
     1476      1476    2
     1477      1477    2                break ;
     1478      1478    2               default:
     1479      1479    2                if (sp->sym_class != FUNCTION_CLASS) break;
     1480      1480    2                j = static_func_chk (sp);
     1481      1481    2                if (j != 0) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=42 
     1482      1482    3                  strcpy(tmp1, sp->name);
     1483      1483    3                  strcat(tmp1, "#");
     1484      1484    3                  if (static_data_flag != 0) {
     1485      1485    4                     if (strcmp(static_func_suffix, "    ") != 0) {
     1486      1486    5                        strcat(tmp1, static_func_suffix); }
     1487      1487    4                     else {
     1488      1488    5                        strcat(tmp1, static_name); } }
     1489      1489    3                  else {
     1490      1490    4                     strcat(tmp1, static_name);  }
     1491      1491    3                  pl6str(tmp1);
     1492      1492    3                } else {
     1493      1493    3                  pl6str(sp->name); }
     1494      1494    2                XUO$RNAME (buffer, &name_offset);
     1495      1495    2                XUO$EREF (&name_offset, &zero_val, &minus_one_val, &zero_val,
     1496      1496    2                   &std_call, &zero_val, &eref_num);
     1497      1497    2
     1498      1498    2                sp->reloc_section = eref_num ;
     1499      1499    2                sp->reloc_type = ENTREF_TYPE;
     1500      1500    2                sp->offset = 0;
     1501      1501    2
     1502      1502    2                break ;
     1503      1503    2               case FIELD_TYPE:
     1504      1504    2
     1505      1505    2                break;
     1506      1506    2               case BASED_TYPE:
     1507      1507    2
     1508      1508    2                break;
     1509      1509    2              }  /* end of the switch on addr type....  */
     1510      1510    1
     1511      1511    1              return;
     1512      1512    1              }   /* end  of the function set_reloc_stuff.. */
     1513      1513
     1514      1514
     1515      1515             /*i*
     1516      1516                   name: get_label_addr
     1517      1517                   purpose: This routine generates a label address for the local
     1518      1518                   static addresses that reference a global static entity.
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=43 
     1519      1519
     1520      1520             */
     1521      1521             get_label_addr (sp, dp)
     1522      1522             struct sym_tbl *sp;
     1523      1523             struct sym_debug_tbl *dp; {
     1524      1524    1        struct labels *next;
     1525      1525    1        int hash_value, i, k ,ii, kk ;
     1526      1526    1        int power_of_kk();
     1527      1527    1        char j;
     1528      1528    1              strcpy(h_stuff.label_t, blanks_32);
     1529      1529    1
     1530      1530    1              strcpy(h_stuff.label_t, "@C");
     1531      1531    1              k = 2;
     1532      1532    1              i = dp->addr_byte ;
     1533      1533    1              kk = 0;
     1534      1534    1              for (ii=i; ii>0 ; ii/= 10) {
     1535      1535    2                kk++; }
     1536      1536    1              while ( i >= 10) {
     1537      1537    2                j = i/power_of_kk(kk)  | 060 ;
     1538      1538    2                h_stuff.label_t[k] = j;
     1539      1539    2                k++;
     1540      1540    2                i = i%(10*(kk-1));
     1541      1541    2                kk--;
     1542      1542    2              }
     1543      1543    1              j = i | 060;
     1544      1544    1              h_stuff.label_t[k++] = j;
     1545      1545    1              h_stuff.label_t[k] = '\0';
     1546      1546    1              hash_value = h_stuff.int_text[0] + h_stuff.int_text[1];
     1547      1547    1              hash_value = hash_value * hash_value;
     1548      1548    1              hash_value = (hash_value & POS_MASK)% 601;  /* may want to make
     1549      1549    1                                                    this value bigger. */
     1550      1550    1              lp = (struct labels *) label_hash[hash_value];
     1551      1551    1
     1552      1552    1              if (lp == NULL) {
     1553      1553    2                /* have error condition if we et to this point... */
     1554      1554    2                printf ("We have reference to nonexistent static data entity. %s, %d \
                               n ", h_stuff.label_t, line_num);
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=44 
     1555      1555    2                return;  }
     1556      1556    1
     1557      1557    1              for (ld = lp; ld != NULL ; ld = next) {
     1558      1558    2                next = ld->next;
     1559      1559    2                last_ld = ld;
     1560      1560    2                if ((i=strcmp(h_stuff.label_t,ld->lname)) == 0) {
     1561      1561    3                    /* have a match here - same lbl already in the tbl. */
     1562      1562    3                  sp->reloc_type = ld->reloc_type;
     1563      1563    3                  sp->reloc_section = ld->reloc_section;
     1564      1564    3                  sp->offset = lp->offset*4; /* make byte values. */
     1565      1565    3                  dp->addr_byte = lp->offset*4; /* make bytes value offsets. */
     1566      1566    3                  return;
     1567      1567    3                }   /* end of if test on string match. */
     1568      1568    2              } /* end of for loop on string search. */
     1569      1569    1
     1570      1570    1              /* if we et here it is an error. */
     1571      1571    1              printf ("We have reference to nonexistent static data entity. %s %d \n",
                                h_stuff.label_t , line_num );
     1572      1572    1              return;
     1573      1573    1        }     /* end of the function get_label_addr.   */
     1574      1574
     1575      1575             /*i*
     1576      1576                   name: power_of_kk
     1577      1577                   purpose: This routine is the one to calculate the power
     1578      1578                   of the of 10 to be user in decoding the binary value into
     1579      1579                   a deciaml number.
     1580      1580             */
     1581      1581             int power_of_kk(kk) int kk; {
     1582      1582    1        int i,k;
     1583      1583    1
     1584      1584    1              k = 1;
     1585      1585    1              for (i = kk-1; i > 0; i-- ) {
     1586      1586    2                k = k * 10 ;
     1587      1587    2              }
     1588      1588    1              return (k);
     1589      1589    1        }
     1590      1590
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=45 
     1591      1591
     1592      1592             /*i*
     1593      1593                   name: set_address
     1594      1594                   purpose: This routine allocates storage area in the data
     1595      1595                   section for the passed ids. This is for static and symdef
     1596      1596                   data types.
     1597      1597             */
     1598      1598             set_address(sp)  struct sym_tbl *sp;    {
     1599      1599    1        int i;
     1600      1600    1        struct sym_debug_tbl *dt;
     1601      1601    1
     1602      1602    1              /*  procedure follows......   */
     1603      1603    1              sp->offset = s_s_table[curr_con_section].curr_offset;
     1604      1604    1              /* dont increment the current location counter for
     1605      1605    1                 allocation of the static data entity. Fill stuff
     1606      1606    1                 will take care of it.... */
     1607      1607    1
     1608      1608    1              if (static_data_flag != 0)
     1609      1609    1                return;
     1610      1610    1
     1611      1611    1              dt =(struct sym_debug_tbl *) sp->debug;
     1612      1612    1              dt->addr_byte = sp->offset * 4; /* make byte value.. */
     1613      1613    1
     1614      1614    1              i = (dt->size_bytes +3)/4 ;
     1615      1615    1
     1616      1616    1        /*    s_s_table[datasec].curr_offset  += i ;  */
     1617      1617    1
     1618      1618    1              return ;
     1619      1619    1              }  /*  end of the function set_address  */
     1620      1620
     1621      1621
     1622      1622             /*i*
     1623      1623                   name: bld_symdef
     1624      1624                   purpose: This routine builds the o.u. symdef entity.
     1625      1625
     1626      1626             */
     1627      1627             bld_symdef(sp)  struct sym_tbl *sp;   {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=46 
     1628      1628    1        int name_offset ;
     1629      1629    1
     1630      1630    1              pl6str (sp->name); /* put name string into pl6 form of char string. */
     1631      1631    1              XUO$DNAME (buffer, &name_offset);
     1632      1632    1              XUO$SDEF (&name_offset, &curr_con_section, &sp->offset);
     1633      1633    1
     1634      1634    1              return;
     1635      1635    1              }   /*  end of the function bld_symdef.  */
     1636      1636
     1637      1637
     1638      1638             /*i*
     1639      1639                   name: set_entry_def
     1640      1640                   purpose: This routine sets the entry point and id for the
     1641      1641                   program that we are compiling. The symbol is first found
     1642      1642                   in the symbol tbl (or a symbol table entry is built for it),
     1643      1643                   the class is then set, and the o.u. ent def records are
     1644      1644                   generated.
     1645      1645             */
     1646      1646             set_entry_def()     {
     1647      1647    1        struct sym_tbl *sp;
     1648      1648    1        int name_offset;
     1649      1649    1
     1650      1650    1
     1651      1651    1              global_store_flag = 1; /* find global name_match. */
     1652      1652    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1653      1653    1              global_store_flag = 0; /* reset search flag.  */
     1654      1654    1              /* symbol table entry is now in hand..*/
     1655      1655    1              sp->ou_set_flag = -1;
     1656      1656    1              if (static_data_flag != 0 )  {
     1657      1657    2                if (sp->addr_type == SYMDEF_TYPE) {
     1658      1658    3                   return; }
     1659      1659    2                else {
     1660      1660    3                   sp->addr_type = SYMDEF_TYPE;
     1661      1661    3                   return;
     1662      1662    3                    }
     1663      1663    2               }
     1664      1664    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=47 
     1665      1665    1              pl6str(sp->name);  /* convert c string to pl6 string. */
     1666      1666    1              sp->sym_class = FUNCTION_CLASS;
     1667      1667    1              sp->reloc_type = ENTREF_TYPE ;
     1668      1668    1              sp->reloc_section = -1 ; /* set for recursive subprogram call. */
     1669      1669    1
     1670      1670    1              XUO$DNAME (buffer, &name_offset);
     1671      1671    1              XUO$EDEF ( &procsec, &zero_val, &name_offset, &minus_one_val, &zero_val,
                                &arg_check[sp->arg_checking],
     1672      1672    1                         &std_call, &sp->no_params );
     1673      1673    1
     1674      1674    1              strcpy (progname, sp->name);
     1675      1675    1              first_func_flag = -1;
     1676      1676    1              return ;
     1677      1677    1              }   /* end of set_entry_def function.. */
     1678      1678
     1679      1679
     1680      1680             /*i*
     1681      1681                   name: get_symbol_adr
     1682      1682                   purpose: This routine sets the relocation directive values
     1683      1683                   for code generation. It uses the values from the passed
     1684      1684                   symbol table entry to set the relocation directives.
     1685      1685             */
     1686      1686             get_symbol_adr ()    {
     1687      1687    1        int name_offset , eref_num, i;
     1688      1688    1        char tmp1[128];
     1689      1689    1        int j;
     1690      1690    1        struct sym_tbl *sp ;
     1691      1691    1
     1692      1692    1
     1693      1693    1              global_store_flag = 1;
     1694      1694    1              sp =(struct sym_tbl *) scan_and_search_for_id (OLD_ID);
     1695      1695    1              global_store_flag = 0;
     1696      1696    1              if (ref_name_flag != 0) { /* looking for ent ref name. */
     1697      1697    2                if (sp->reloc_type != ENTREF_TYPE || sp->ou_set_flag == 0 ||
     1698      1698    2                  sp->reloc_section == -1 ) {
     1699      1699    3                  sp->reloc_type = ENTREF_TYPE;
     1700      1700    3                  sp->sym_class = FUNCTION_CLASS;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=48 
     1701      1701    3                  j = static_func_chk (sp);
     1702      1702    3                  if (j != 0) {
     1703      1703    4                    strcpy(tmp1, sp->name);
     1704      1704    4                    strcat(tmp1,  "#");
     1705      1705    4                    strcat(tmp1, static_name);
     1706      1706    4                    pl6str(tmp1);
     1707      1707    4                  } else {
     1708      1708    4                    pl6str(sp->name); }
     1709      1709    3                  XUO$RNAME(buffer, &name_offset);
     1710      1710    3                  i =  sp->no_params ;
     1711      1711    3                  if (sp->arg_checking != 0) {
     1712      1712    4                    j = -1; }
     1713      1713    3                  else {
     1714      1714    4                    j = 0; }
     1715      1715    3                  XUO$EREF( &name_offset, &zero_val, &zero_val, &j ,
     1716      1716    3                      &std_call, &i , &eref_num);
     1717      1717    3                  sp->reloc_section = eref_num;
     1718      1718    3                }
     1719      1719    2              }
     1720      1720    1              sp->ou_set_flag = -1;
     1721      1721    1              if (sp->addr_type == 0 && sp->reloc_type == 0) {
     1722      1722    2                sp->addr_type = SYMREF_TYPE;
     1723      1723    2                set_reloc_stuff (sp); }
     1724      1724    1              /* we have the symbol table entity in hand... */
     1725      1725    1
     1726      1726    1              reloc_section = sp->reloc_section ;
     1727      1727    1              reloc_type = sp->reloc_type ;
     1728      1728    1              reloc_directive = UHALF_WORD ;
     1729      1729    1
     1730      1730    1              return(sp->offset);
     1731      1731    1              }   /* end of the function get_symbol_adr   */
     1732      1732
     1733      1733
     1734      1734             /*i*
     1735      1735                   name: zero_pseudo
     1736      1736                   purpose: this routine processes the zero pseudo op that
     1737      1737                   is input off of the code gen input stream.
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=49 
     1738      1738                   Form of the op is ZERO n,m     where n and m are integer
     1739      1739                   values, that may be in symbolic form to be set in a later
     1740      1740                   code gen input record.
     1741      1741             */
     1742      1742             zero_pseudo()    {
     1743      1743    1        struct inst_std curr_inst;
"zb6$tables:c.:ZBC3TSI", line 1743: (warning) identifier "curr_inst" is not used
     1744      1744    1        int name_offset;
"zb6$tables:c.:ZBC3TSI", line 1744: (warning) identifier "name_offset" is not used
     1745      1745    1        int type;
"zb6$tables:c.:ZBC3TSI", line 1745: (warning) identifier "type" is not used
     1746      1746    1        int eref_num;
"zb6$tables:c.:ZBC3TSI", line 1746: (warning) identifier "eref_num" is not used
     1747      1747    1        int opt_flag, lbl_name_off;
"zb6$tables:c.:ZBC3TSI", line 1747: (warning) identifier "lbl_name_off" is not used
"zb6$tables:c.:ZBC3TSI", line 1747: (warning) identifier "opt_flag" is not used
     1748      1748    1        int temp1;
"zb6$tables:c.:ZBC3TSI", line 1748: (warning) identifier "temp1" is not used
     1749      1749    1        int i;
     1750      1750    1        int sym_offset;
"zb6$tables:c.:ZBC3TSI", line 1750: (warning) identifier "sym_offset" is not used
     1751      1751    1        int frd_ref, count, temp, reloc_type;
     1752      1752    1
     1753      1753    1
     1754      1754    1              i = 0;
     1755      1755    1              while ((c=getc(infile)) == ' ') i++;
     1756      1756    1
     1757      1757    1              i = process_field(0);  /* process the first field. */
     1758      1758    1              instruc.top_half = i;
     1759      1759    1              while ((c=getc(infile)) == ' ') i++;
     1760      1760    1
     1761      1761    1              i = process_field(1);  /* process the second field. */
     1762      1762    1              instruc.bot_half = i;
     1763      1763    1
     1764      1764    1              i = s_s_table[procsec].curr_offset ;
     1765      1765    1              s_s_table[procsec].curr_offset++ ;
     1766      1766    1              XUO$PRGM (&procsec, &i, &instruc);
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=50 
     1767      1767    1              temp = 17;
     1768      1768    1              count = forward_ref_count - 1; /* should be the first one. */
     1769      1769    1              frd_ref = FREF_TYPE;
     1770      1770    1              reloc_type = FREF_AUTO;
     1771      1771    1              save_f_count = count;
     1772      1772    1
     1773      1773    1              XUO$RELOC (&procsec, &i, &frd_ref, &count, &reloc_type,&zero_val, &temp)
                               ;
     1774      1774    1              return; }  /*end of the function zero_pseudo. */
     1775      1775
     1776      1776
     1777      1777             int direct[2] ={UHALF_WORD, LHALF_WORD};
     1778      1778
     1779      1779             /*i*
     1780      1780                   name: process_field
     1781      1781                   purpose: This routine processes the argument fields from
     1782      1782                   the zero_pseudo instruction. It expects either an integer
     1783      1783                   or symbolic name. The symbolic name is satisfied later
     1784      1784                   by an equate cod gen record.
     1785      1785             */
     1786      1786             int process_field (j) int j;  {
     1787      1787    1        int i;
     1788      1788    1        struct sym_tbl *sp;
     1789      1789    1
     1790      1790    1
     1791      1791    1              i = 0;
     1792      1792    1              if (c >= '0' && c <= '9') { /* have an integer value at this point. */
     1793      1793    2                i = c - '0';
     1794      1794    2                while ((c =getc(infile)) >= '0' && c <= '9') {
     1795      1795    3                  i *= 10;
     1796      1796    3                  i += (c - '0');
     1797      1797    3                 }   /* end of the while stmt. */
     1798      1798    2              } else {
     1799      1799    2                /*  have symbolic value string at this point.
     1800      1800    2                    Need to make thjis value a symbol table value, and
     1801      1801    2                    save the result, and make this a forward ref to be
     1802      1802    2                    satisfied at the end of the o.u. generation processing. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=51 
     1803      1803    2                ungetc(c, infile); /* reset curr char. */
     1804      1804    2                sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1805      1805    2              sp->ou_set_flag = -1;
     1806      1806    2                sp->sym_class = EQU_CLASS;
     1807      1807    2                sp->offset = 0;   /* the equ code gen record will set the
     1808      1808    2                                  offset field of the symbol table entry
     1809      1809    2                                  to contain the actual numeric value to
     1810      1810    2                                  be set into this field. It will be done
     1811      1811    2                                  via the forward ref satisfy o.u. scheme
     1812      1812    2                                  of things... */
     1813      1813    2                sp->reloc_type = FREF_AUTO ;
     1814      1814    2                sp->storage_class = AUTO_STORAGE ; /* really a dummy - to get
     1815      1815    2                                it dropped from the variables thread. */
     1816      1816    2                reloc_type = FREF_AUTO;
     1817      1817    2                reloc_directive = direct[j];
     1818      1818    2                /* set the forward ref table.  */
     1819      1819    2                fwd_p->fwd_tbl[forward_ref_count] = (int *)sp;
     1820      1820    2                sp->reloc_section = forward_ref_count ;
     1821      1821    2                forward_ref_count++;
     1822      1822    2                if (forward_ref_count >= fwd_tbl_size) {
     1823      1823    3                   fwd_p = (fwd_ref_p) Srealloc(fwd_p, (fwd_tbl_size+400)* sizeof(shor
                               t));
     1824      1824    3                   fwd_tbl_size += 400;
     1825      1825    3                  }
     1826      1826    2
     1827      1827    2
     1828      1828    2                }  /* end of if on alpha or constant test */
     1829      1829    1              check_eol();
     1830      1830    1              return (i);
     1831      1831    1              }  /* end of process_field function.  */
     1832      1832
     1833      1833
     1834      1834             /*i*
     1835      1835                   name: set_equ_pseudo
     1836      1836                   purpose: This routine processes that equ code gen pseudo op
     1837      1837                   code. It gets the value to be associated with the symbol
     1838      1838                   that is associated with a numeric value and saves the
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=52 
     1839      1839                   numeric value in the symbol table entry taht is associated
     1840      1840                   with the symbolic name.
     1841      1841             */
     1842      1842             set_equ_pseudo()   {
     1843      1843    1        struct sym_tbl *sp;
     1844      1844    1        int i;
     1845      1845    1
     1846      1846    1
     1847      1847    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1848      1848    1
     1849      1849    1              while ((c=getc(infile)) < '0' && c > '9') i++;
     1850      1850    1              i = 0;
     1851      1851    1              if (c == '0') { /* have an octal value.. */
     1852      1852    2                while ((c=getc(infile)) >= '0' && c <= '7') {
     1853      1853    3                  i = i <<3;
     1854      1854    3                  i += (c-'0');
     1855      1855    3                }
     1856      1856    2              } else {
     1857      1857    2                 i = (c-'0');
     1858      1858    2                while ((c=getc(infile)) >= '0' && c <= '9') {
     1859      1859    3                  i *= 10;
     1860      1860    3                  i += (c-'0');
     1861      1861    3                }
     1862      1862    2              }   /* end of the if test for octal. */
     1863      1863    1              check_eol();
     1864      1864    1
     1865      1865    1              /*  add pad of 8 for strind move stuff..*/
     1866      1866    1              i += 8;
     1867      1867    1              sp->offset = i; /* set the equate value into the symbol tbl. */
     1868      1868    1              sp->sym_class = EQU_CLASS ;
     1869      1869    1              return ;
     1870      1870    1              }   /* end of the function set_equ_pseudo.    */
     1871      1871
     1872      1872
     1873      1873             /*i*
     1874      1874                   name: set_debug_fun_info
     1875      1875                   purpose: This routine is used to setup info about the
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=53 
     1876      1876                   function that we are about to process. this info is then used
     1877      1877                   in the building of the entdef and debug entry o.u. records.
     1878      1878
     1879      1879             */
     1880      1880             set_debug_fun_info()   {
     1881      1881    1        struct sym_tbl *sp;
     1882      1882    1        int i;
     1883      1883    1        char tmp1[128];
     1884      1884    1        int j;
     1885      1885    1        int name_offset ;
     1886      1886    1
     1887      1887    1              ref_name_flag = 1;
     1888      1888    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1889      1889    1              ref_name_flag = 0;
     1890      1890    1              sp->ou_set_flag = -1;
     1891      1891    1              sp->sym_class = FUNCTION_CLASS;
     1892      1892    1
     1893      1893    1              /* symbl table entry is now in hand..  */
     1894      1894    1
     1895      1895    1              j = static_func_chk (sp);
     1896      1896    1              strcpy (tmp1, sp->name);
     1897      1897    1              if (j != 0) {
     1898      1898    2                 strcat (tmp1, "#");
     1899      1899    2                 strcat (tmp1, static_name);  }
     1900      1900    1              strcpy (progname, tmp1);
     1901      1901    1              /*  program o.u. init is done at theis time. */
     1902      1902    1
     1903      1903    1              ouinit();
     1904      1904    1
     1905      1905    1              /* check for static function name.. */
     1906      1906    1
     1907      1907    1              sp->arg_checking = get_value(); /* set the arg schecking flag */
     1908      1908    1              i  = get_value(); /* get normal calling seq flag  */
     1909      1909    1              sp->glo_static_flag = get_value(); /* global static ref flag  */
     1910      1910    1              if (sp->glo_static_flag == 0) { /* have static function. */
     1911      1911    2                static_function_flag = 1;  }
     1912      1912    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=54 
     1913      1913    1              i  = get_value(); /* number of bytes of parameters */
     1914      1914    1              if (sp->no_params == 0) {
     1915      1915    2                 sp->no_params = ((i-16)+3)/4 ;  /* get no. of wrds of parameters. */
     1916      1916    2              }   /* end of chk on # of params. */
     1917      1917    1              if (sp->no_params < 0) sp->no_params = 0;  /* make sure never neg.*/
     1918      1918    1              local_storage = ((i=get_value())+3)/4;  /* get no. of
     1919      1919    1                                words of storage. */
     1920      1920    1
     1921      1921    1              if( j != 0) {
     1922      1922    2                sp->sym_class = FUNCTION_CLASS;
     1923      1923    2                sp->reloc_type = ENTREF_TYPE ;
     1924      1924    2                sp->reloc_section = -1 ; /* set for recursive subprogram call. */
     1925      1925    2                strcpy(tmp1, sp->name);
     1926      1926    2                strcat(tmp1, "#" );
     1927      1927    2                strcat(tmp1, static_name);
     1928      1928    2
     1929      1929    2                pl6str(tmp1);  /* convert c string to pl6 string. */
     1930      1930    2                XUO$DNAME (buffer, &name_offset);
     1931      1931    2                XUO$EDEF ( &procsec, &zero_val, &name_offset, &minus_one_val, &zero_va
                               l, &arg_check[sp->arg_checking],
     1932      1932    2                           &std_call, &sp->no_params );
     1933      1933    2
     1934      1934    2                strcpy (progname, sp->name);
     1935      1935    2                first_func_flag = -1;
     1936      1936    2              }
     1937      1937    1              return ;
     1938      1938    1              }   /* end of the set_debug_fun_info function. */
     1939      1939
     1940      1940
     1941      1941             /*i*
     1942      1942                   name: set_ref_function
     1943      1943                   purpose: The purpose of this function is to get the
     1944      1944                   values for paramter checking for functions that are
     1945      1945                   referenced in this c compile file.
     1946      1946             */
     1947      1947             set_ref_function()  {
     1948      1948    1        int i;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=55 
     1949      1949    1        struct sym_tbl *sp;
     1950      1950    1
     1951      1951    1
     1952      1952    1              ref_name_flag = 1;
     1953      1953    1              sp = (struct sym_tbl *) scan_and_search_for_id(OLD_ID);
     1954      1954    1              ref_name_flag = 0;
     1955      1955    1              sp->ou_set_flag = -1;
     1956      1956    1              sp->sym_class = FUNCTION_CLASS;
     1957      1957    1              sp->arg_checking = get_value();
     1958      1958    1              i = get_value();
     1959      1959    1              sp->no_params = get_value();
     1960      1960    1              return;
     1961      1961    1        }  /* end of the function set_ref_function. */
     1962      1962             /*i*
     1963      1963                   name:static_func_chk
     1964      1964                   purpose: The purpose of this routine is to check if the
     1965      1965                   function name that is currently being processed is a
     1966      1966                   static function name.
     1967      1967
     1968      1968             */
     1969      1969             static_func_chk (sp) struct sym_tbl *sp; {
     1970      1970    1        extern int static_func_count ;
     1971      1971    1        static_funcs_p p, next_p;
     1972      1972    1
     1973      1973    1              if (static_func_count == 0 ) return(0);
     1974      1974    1
     1975      1975    1              for (p = static_p; p != (static_funcs_p) 0; p = next_p) {
     1976      1976    2                next_p = p->next ;
     1977      1977    2                if (strcmp(sp->name, p->name_field.name) == 0 ) {
     1978      1978    3                  return (1); }
     1979      1979    2              }
     1980      1980    1
     1981      1981    1              return (0);
     1982      1982    1              } /* end of the staic_func_chk function. */
     1983      1983
     1984      1984
     1985      1985             /*i*
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=56 
     1986      1986                   name: set_debug_blk_info
     1987      1987                   purpose: This routine sets the debug blk tbl info for the
     1988      1988                   debug schema taht is to be generated...
     1989      1989
     1990      1990             */
     1991      1991             set_debug_blk_info()   {
     1992      1992    1        int line_no, stmt_no, lex_depth;
     1993      1993    1        int start_end_flag;
     1994      1994    1        int name_offset;
     1995      1995    1        int var_num;
     1996      1996    1
     1997      1997    1
     1998      1998    1              start_end_flag = get_value() ; /* get start/end flag */
     1999      1999    1              line_no = get_value() ; /* line numbe blk starts. */
     2000      2000    1              stmt_no = get_value() ; /* stmt number blk starts. */
     2001      2001    1              lex_depth = get_value()+1 ; /* level depth of the blk. */
     2002      2002    1
     2003      2003    1              if (start_end_flag == 0) { /* start debug block. */
     2004      2004    2        /*      if (blk_count != 0) {
     2005      2005    2                  blk_count++;
     2006      2006    2                  return;
     2007      2007    2                 }           */ /* >>>>>>> TEMP CODE <<<<<< */
     2008      2008    2                XUO$LOGBLKALLOC (&log_blk_num);
     2009      2009    2                next_log_blk_num[blk_count] = log_blk_num;
     2010      2010    2                pl6str(progname);
     2011      2011    2                XUO$DBGNAME (buffer, &name_offset);
     2012      2012    2                XUO$LOGBLKEXSTINIT ( &log_blk_num, &stmt_count, &line_no,
     2013      2013    2                           &name_offset, &lex_depth);
     2014      2014    2                XUO$VREBLNUM( &var_num);
     2015      2015    2                blk_info[blk_count].first_line_no = line_no;
     2016      2016    2                blk_info[blk_count].stmt_no = stmt_no;
     2017      2017    2                blk_info[blk_count].lex_depth = lex_depth;
     2018      2018    2                blk_info[blk_count].log_blk_num = log_blk_num;
     2019      2019    2                blk_info[blk_count].name_offset = name_offset;
     2020      2020    2                blk_info[blk_count].stmt_count = stmt_count;
     2021      2021    2                blk_info[blk_count].first_var = var_num;
     2022      2022    2                XUO$LOGBLKVREBLINIT ( &log_blk_num, &var_num);
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=57 
     2023      2023    2                blk_count++;
     2024      2024    2                }
     2025      2025    1              else {   /*  end debug block. */
     2026      2026    2        /*      if (blk_count > 1) {    >>>>>>> TEMP CODE <<<<<<<
     2027      2027    2                  blk_count--;
     2028      2028    2                  return;
     2029      2029    2                 }      */
     2030      2030    2
     2031      2031    2
     2032      2032    2                if (blk_count == 1) {
     2033      2033    3                  set_global_debug_vars();  }
     2034      2034    2                XUO$VREBLNUM( &var_num);
     2035      2035    2                if (blk_count > 1) {  /* finish blk stuff if outside the blk. */
     2036      2036    3
     2037      2037    3                  XUO$LOGBLKEXSTTERM ( &log_blk_num, &stmt_count, &last_line_no);
     2038      2038    3                  XUO$LOGBLKVREBLTERM (&log_blk_num, &var_num);  }
     2039      2039    2                blk_count--;
     2040      2040    2                blk_info[blk_count].last_line_no = last_line_no;
     2041      2041    2                blk_info[blk_count].last_stmt_no = stmt_count;
     2042      2042    2                blk_info[blk_count].stmt_count = stmt_count;
     2043      2043    2                blk_info[blk_count].last_var = var_num;
     2044      2044    2                if (blk_count >= 1) {
     2045      2045    3                  log_blk_num = next_log_blk_num[blk_count-1]; }
     2046      2046    2
     2047      2047    2
     2048      2048    2                }
     2049      2049    1              return;
     2050      2050    1              }  /* end of the function set_debug_blk_info. */
     2051      2051
     2052      2052             /*i*
     2053      2053                   name: zb6_close_debug_blks
     2054      2054                   purpose: This routine closes the debug blocks that are
     2055      2055                   associated with the object unit, and specify the range
     2056      2056                   of the debug information.
     2057      2057             */
     2058      2058             zb6_close_debug_blks () {
     2059      2059    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=58 
     2060      2060    1                  XUO$LOGBLKEXSTTERM ( &blk_info[0].log_blk_num,
     2061      2061    1                     &actual_stmt_count, &blk_info[0].last_line_no);
     2062      2062    1                  XUO$LOGBLKVREBLTERM (&blk_info[0].log_blk_num,
     2063      2063    1                         &blk_info[0].last_var);
     2064      2064    1                  return;
     2065      2065    1        }
     2066      2066
     2067      2067
     2068      2068
     2069      2069             /*i*
     2070      2070                   name: set_label_info
     2071      2071                   purpose: this routine sets up the label info for the debug
     2072      2072                   tables. That is, the executable stmt entries that are made
     2073      2073                   for each statement.
     2074      2074
     2075      2075             */
     2076      2076             set_label_info()   {
     2077      2077    1        char lbl_str[32];
     2078      2078    1        int lbl_offset;
     2079      2079    1        struct line_tbl *lp;
     2080      2080    1        struct sub_lbl_tbl *slp, *slp_next, *last_slp;
     2081      2081    1        int line_no, sub_stmt_no;
     2082      2082    1        line_tbl_p get_line_tbl_entry();
     2083      2083    1
     2084      2084    1
     2085      2085    1              line_no = get_value(); /* get the line number */
     2086      2086    1              sub_stmt_no = get_value(); /* get the substmt number for the line */
     2087      2087    1              if (c == ',') { c = getc(infile); }
     2088      2088    1              scan_name(lbl_str); /* scan the lbl name */
     2089      2089    1
     2090      2090    1              pl6str(lbl_str);
     2091      2091    1              XUO$DBGNAME ( buffer, &lbl_offset);
     2092      2092    1              active_label = lbl_offset;
     2093      2093    1
     2094      2094    1              lp = (struct line_tbl *) get_line_tbl_entry(line_no);
     2095      2095    1
     2096      2096    1              if (sub_stmt_no == 0 ) {  /* no substmt number for lbl. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=59 
     2097      2097    2                lp->lbl_name_offset = lbl_offset ;
     2098      2098    2                return;
     2099      2099    2               }
     2100      2100    1
     2101      2101    1              if (lp->sub_lbl_tbl_ptr == NULL )  { /* bld entry ofr the null string. *
                               /
     2102      2102    2                lp->sub_lbl_tbl_ptr = (struct sub_lbl_tbl *) myalloc(sizeof(struct sub
                               _lbl_tbl));
     2103      2103    2                slp = lp->sub_lbl_tbl_ptr;
     2104      2104    2                slp->next = NULL;
     2105      2105    2                slp->sub_stmt_no = sub_stmt_no;
     2106      2106    2                slp->lbl_name_offset = lbl_offset;
     2107      2107    2                return;
     2108      2108    2              } /* end of if test for null ptr. */
     2109      2109    1
     2110      2110    1              for (slp = lp->sub_lbl_tbl_ptr; slp != NULL; slp = slp_next) {
     2111      2111    2                slp_next = slp->next;
     2112      2112    2                last_slp = slp;
     2113      2113    2                if (slp->sub_stmt_no == sub_stmt_no) {
     2114      2114    3                  slp->lbl_name_offset = lbl_offset;
     2115      2115    3                  return;
     2116      2116    3                }
     2117      2117    2              }  /* end of the for loop */
     2118      2118    1              /* no match so build a new entry at this point. */
     2119      2119    1              slp = (struct sub_lbl_tbl *) myalloc(sizeof(struct sub_lbl_tbl));
     2120      2120    1              slp->next = NULL;
     2121      2121    1              last_slp->next = &slp->next;
"zb6$tables:c.:ZBC3TSI", line 2121: (warning) incompatible pointers in =
     2122      2122    1              slp->sub_stmt_no = sub_stmt_no;
     2123      2123    1              slp->lbl_name_offset = lbl_offset;
     2124      2124    1              return;
     2125      2125    1              }  /* end of the function set_label_info. */
     2126      2126
     2127      2127             /*i*
     2128      2128                   name: get_line_tbl_entry
     2129      2129                   purpose: This routine is the one to find the current line
     2130      2130                   number, or build a new line table entry for the current
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=60 
     2131      2131                   line number.
     2132      2132
     2133      2133             */
     2134      2134             line_tbl_p  get_line_tbl_entry(line_no)  int line_no;  {
     2135      2135    1        struct line_tbl *lp, *next_lp, *last_lp;
     2136      2136    1
     2137      2137    1
     2138      2138    1              if (line_tbl_ptr == NULL)  {  /* first entry in table. */
     2139      2139    2                line_tbl_ptr =(struct line_tbl *) myalloc(sizeof(struct line_tbl));
     2140      2140    2                lp = line_tbl_ptr;
     2141      2141    2                lp->line_no = line_no;
     2142      2142    2                lp->lbl_name_offset = -1;
     2143      2143    2                lp->next = NULL;
     2144      2144    2                lp->sub_lbl_tbl_ptr = NULL;
     2145      2145    2                return (lp);
     2146      2146    2              }  /* end of if test for first line tbl entry. */
     2147      2147    1
     2148      2148    1              /* search existing line tbl entries for match. */
     2149      2149    1              for (lp=line_tbl_ptr; lp != NULL; lp = next_lp) {
     2150      2150    2                next_lp = lp->next;
     2151      2151    2                last_lp = lp;
     2152      2152    2                if (lp->line_no == line_no)  { /* have match on line no. */
     2153      2153    3                  return (lp);
     2154      2154    3                 }
     2155      2155    2                }   /* end of the for loop . */
     2156      2156    1              /* if we get here, no match was found. build the next entry. */
     2157      2157    1              lp = (struct line_tbl *) myalloc(sizeof(struct line_tbl));
     2158      2158    1
     2159      2159    1              lp->next = NULL;
     2160      2160    1              last_lp->next = &lp->next ;
"zb6$tables:c.:ZBC3TSI", line 2160: (warning) incompatible pointers in =
     2161      2161    1              lp->sub_lbl_tbl_ptr =NULL;
     2162      2162    1              lp->line_no = line_no;
     2163      2163    1              lp->lbl_name_offset = -1;
     2164      2164    1
     2165      2165    1              return (lp);
     2166      2166    1              }  /* end of the get_line_tbl_entry function. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=61 
     2167      2167
     2168      2168
     2169      2169             /*i*
     2170      2170                   name: set_debug_stmt_info
     2171      2171                   purpose: This routine sets the stmt number into into the
     2172      2172                   line number table entry. If stmt number already exist,
     2173      2173                   build sub stmt number entry.
     2174      2174
     2175      2175             */
     2176      2176             set_debug_stmt_info()  {
     2177      2177    1        int line_no;
     2178      2178    1        int stmt_no;
     2179      2179    1        int stmt_type;
     2180      2180    1        int sub_stmt_no;
     2181      2181    1        struct line_tbl *lp;
     2182      2182    1        struct sub_lbl_tbl *slp, *next_slp, *last_slp;
     2183      2183    1        int save_curr_sec;
     2184      2184    1        struct inst_std curr_inst;
     2185      2185    1        int name_offset;
     2186      2186    1        int type;
     2187      2187    1        int eref_num;
     2188      2188    1        int opt_flag, lbl_name_off;
     2189      2189    1        int temp1;
     2190      2190    1        int i;
     2191      2191    1        int sym_offset;
     2192      2192    1        int frd_ref, count, temp, reloc_type;
     2193      2193    1
     2194      2194    1
     2195      2195    1              stmt_count++;
     2196      2196    1              stmt_type = get_value(); /* get the stmt type value */
     2197      2197    1              line_no = get_value(); /* get the line number value */
     2198      2198    1              stmt_no = get_value(); /* get the stmt number value */
     2199      2199    1              lp = (struct line_tbl *) get_line_tbl_entry(line_no);
     2200      2200    1              last_line_no = line_no; /* save lin no of last stmt processed. */
     2201      2201    1
     2202      2202    1              if (stmt_count == 1) { /* save line no of first stmt in the prog. */
     2203      2203    2                prog_first_line_no = line_no; }
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=62 
     2204      2204    1
     2205      2205    1              if (lp->stmt_type == 0)  {  /* NO previous stmt entry.. */
     2206      2206    2                lp->stmt_type = stmt_type;
     2207      2207    2                lp->stmt_no = stmt_no;
     2208      2208    2                if (active_label != 0) {
     2209      2209    3                  lp->lbl_name_offset = active_label; }
     2210      2210    2                if (first_prog_line != 0 ) {
     2211      2211    3                  first_prog_line = 0;
     2212      2212    3                  save_curr_sec = curr_con_section ;
     2213      2213    3                  curr_con_section = procsec ;
     2214      2214    3                  bld_debug_exec_tbl_entry (line_no, 0);
     2215      2215    3              if (strcmp(progname, "main") == 0) { /* have main prog so generate speci
                               al code */
     2216      2216    4                temp = 17;
     2217      2217    4                count = forward_ref_count - 1; /* should be the first one. */
     2218      2218    4                frd_ref = FREF_TYPE;
     2219      2219    4                reloc_type = FREF_AUTO;
     2220      2220    4                curr_inst.y_field = 5;
     2221      2221    4                curr_inst.op_code = CTRA >> 8;
     2222      2222    4                curr_inst.null1 = 0;
     2223      2223    4                curr_inst.tag_tm = 0;
     2224      2224    4                curr_inst.tag_td = 4;
     2225      2225    4                i = s_s_table[procsec].curr_offset ++;
     2226      2226    4                XUO$PRGM (&procsec, &i, &curr_inst);
     2227      2227    4                curr_inst.y_field = 0;
     2228      2228    4                curr_inst.op_code = 0;
     2229      2229    4                curr_inst.tag_td = 0;
     2230      2230    4                i = s_s_table[procsec].curr_offset++;
     2231      2231    4                XUO$PRGM (&procsec, &i, &curr_inst);
     2232      2232    4                opt_flag = 0;
     2233      2233    4                lbl_name_off = -1;
     2234      2234    4                temp1 = S_INITIALIZE;
     2235      2235    4                i++;
     2236      2236    4                XUO$EXST(&curr_con_section,&i, &lbl_name_off, &log_blk_num,
     2237      2237    4                   &opt_flag, &temp1, &zero_val, &zero_val, &zero_val);
     2238      2238    4                curr_inst.y_field = 0;
     2239      2239    4                curr_inst.op_code = CEPPR7 >> 8;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=63 
     2240      2240    4                curr_inst.tag_td = 0 ;
     2241      2241    4                i = s_s_table[procsec].curr_offset++;
     2242      2242    4                pl6str("__LIB$COM$VECTOR__");
     2243      2243    4                XUO$RNAME (buffer, &name_offset);
     2244      2244    4                XUO$SREF(&name_offset, &zero_val,&sym_offset,&zero_val);
     2245      2245    4                XUO$PRGM (&procsec, &i, &curr_inst);
     2246      2246    4                type = SYMREF_TYPE;
     2247      2247    4                XUO$RELOC (&procsec, &i, &type, &sym_offset, &one_val,
     2248      2248    4                           &zero_val, &temp);
     2249      2249    4                curr_inst.y_field = 0;
     2250      2250    4                curr_inst.op_code = CTSX0 >> 8;
     2251      2251    4                curr_inst.tag_td = 0 ;
     2252      2252    4                i = s_s_table[procsec].curr_offset ++;
     2253      2253    4                actual_stmt_count++;
     2254      2254    4                XUO$PRGM (&procsec, &i, &curr_inst);
     2255      2255    4                /* build relocation ref to main setup routine. */
     2256      2256    4                pl6str("__XBI_CSTARTUP");
     2257      2257    4                XUO$RNAME (buffer, &name_offset);
     2258      2258    4                XUO$EREF(&name_offset, &zero_val, &minus_one_val, &zero_val,
     2259      2259    4                  &std_call, &zero_val, &eref_num);
     2260      2260    4                reloc_section = eref_num;
     2261      2261    4                type = ENTREF_TYPE;
     2262      2262    4
     2263      2263    4                XUO$RELOC(&procsec, &i, &type, &reloc_section, &one_val,
     2264      2264    4                  &zero_val, &temp);
     2265      2265    4
     2266      2266    4                i = s_s_table[procsec].curr_offset ++;
     2267      2267    4                XUO$PRGM(&procsec, &i, &instruc);
     2268      2268    4                /* repeat of the equal setup stuff..... */
     2269      2269    4                count = save_f_count;
     2270      2270    4                XUO$RELOC(&procsec, &i, &frd_ref, &count, &reloc_type,
     2271      2271    4                  &zero_val, &temp);
     2272      2272    4                pl6str("_GET_UNSHARED_DATA");
     2273      2273    4                XUO$RNAME(buffer, &name_offset);
     2274      2274    4                XUO$EREF (&name_offset, &zero_val, &minus_one_val, &zero_val,
     2275      2275    4                      &std_call, &zero_val, &eref_num);
     2276      2276    4
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=64 
     2277      2277    4              }  /* end of if on main program processing. */
     2278      2278    3                  curr_con_section = save_curr_sec;
     2279      2279    3                 }
     2280      2280    2                active_label = 0;
     2281      2281    2                if (stmt_no != 0 ) {
     2282      2282    3                  last_slp = NULL;
     2283      2283    3                  sub_stmt_no = 0;
     2284      2284    3                  goto set_sub_stmt; }
     2285      2285    2                return;
     2286      2286    2               } /* end of test on stmt_tyep */
     2287      2287    1
     2288      2288    1              /* have stmt entry already in the line number table.
     2289      2289    1                 Walk the sub stmt thread to find match or build a
     2290      2290    1                 new entry.
     2291      2291    1              */
     2292      2292    1              last_slp = NULL;
     2293      2293    1              sub_stmt_no = 0;
     2294      2294    1              for (slp = lp->sub_lbl_tbl_ptr; slp != NULL; slp = next_slp)  {
     2295      2295    2                next_slp = slp->next ;
     2296      2296    2                last_slp = slp;
     2297      2297    2                sub_stmt_no ++;
     2298      2298    2                if (slp->stmt_type == 0)  {
     2299      2299    3                  slp->stmt_type = stmt_type;
     2300      2300    3                  return;
     2301      2301    3                }
     2302      2302    2               }  /* end of the for loop- did not find empty table entry.
     2303      2303    1                     Therefore, need to build new entry and set the start
     2304      2304    1                     stmt_type and sub_stmt_no fields...
     2305      2305    1                  */
     2306      2306    1        set_sub_stmt:
     2307      2307    1              slp = (struct sub_lbl_tbl *) myalloc(sizeof(struct sub_lbl_tbl));
     2308      2308    1              sub_stmt_no++;
     2309      2309    1              if (last_slp != NULL)  {
     2310      2310    2                last_slp->next = &slp->next;
"zb6$tables:c.:ZBC3TSI", line 2310: (warning) incompatible pointers in =
     2311      2311    2              } else  {
     2312      2312    2                lp->sub_lbl_tbl_ptr = slp; }
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=65 
     2313      2313    1              slp->next = NULL;
     2314      2314    1              slp->stmt_type = stmt_type;
     2315      2315    1              slp->sub_stmt_no = sub_stmt_no ;
     2316      2316    1              slp->lbl_name_offset = -1 ;
     2317      2317    1
     2318      2318    1              return ;
     2319      2319    1              }  /*   end of the set debug stmt info..  */
     2320      2320
     2321      2321
     2322      2322             /*i*
     2323      2323                   name: set_line
     2324      2324                   purpose: this is the routine to build the debug table
     2325      2325                   entries for executable statements. this is the rtuine
     2326      2326                   to process the line number entries from the code gen
     2327      2327                   input stream.
     2328      2328
     2329      2329             */
     2330      2330             set_line()    {  /* process the line number fields on input. */
     2331      2331    1        int line_no, sub_line_no ;
     2332      2332    1
     2333      2333    1
     2334      2334    1              line_no = get_value(); /* get the line number in binary. */
     2335      2335    1
     2336      2336    1              if (line_no == prog_first_line_no) { /* not really first line, so skip.
                               */
     2337      2337    2                curr_line_no = line_no;
     2338      2338    2                get_eol();
     2339      2339    2                return; }
     2340      2340    1
     2341      2341    1              sub_line_no = line_no/262144;
     2342      2342    1              line_no = line_no%262144 ;
     2343      2343    1
     2344      2344    1              curr_line_no = line_no;
     2345      2345    1
     2346      2346    1              line_num = curr_line_no;
     2347      2347    1              bld_debug_exec_tbl_entry(line_no, sub_line_no);
     2348      2348    1
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=66 
     2349      2349    1              get_eol(); /* make sure at eol character. */
     2350      2350    1              return;
     2351      2351    1              }  /* end of set_line funxtion. */
     2352      2352
     2353      2353
     2354      2354             /*i*
     2355      2355                   name: bld_debug_exec_tbl_entry
     2356      2356                   purpose: This routine is the one to build the o.u. debug
     2357      2357                   record entries for executable statements. It searches the
     2358      2358                   line # tbl looking for the match, and then uses the info
     2359      2359                   from the line no. tbl to build the debug record.
     2360      2360
     2361      2361             */
     2362      2362             bld_debug_exec_tbl_entry(line_no, sub_line_no)  int line_no;int sub_line_no;
                               {
     2363      2363    1        int opt_flag , offset_address;
     2364      2364    1        struct line_tbl *lp;
     2365      2365    1        struct sub_lbl_tbl *slp, *next_slp ;
     2366      2366    1
     2367      2367    1              lp = (struct line_tbl *) get_line_tbl_entry(line_no);
     2368      2368    1
     2369      2369    1              if (sub_line_no == 0) { /* build main line no debug stuff. */
     2370      2370    2                /*build exec stmt debug record.  */
     2371      2371    2                lp->section_no = curr_con_section;
     2372      2372    2                lp->addr_offset = s_s_table[curr_con_section].curr_offset;
     2373      2373    2                if (lp->stmt_type  == 101) { /* loop for proc stmt. */
     2374      2374    3                   lp->addr_offset = 0; }
     2375      2375    2
     2376      2376    2
     2377      2377    2                opt_flag = 0;
     2378      2378    2                if (lp->stmt_type == 1 || lp->stmt_type == 5 ||
     2379      2379    2                    lp->stmt_type ==35 )  {
     2380      2380    3                  opt_flag = -1; }
     2381      2381    2                XUO$EXST (&lp->section_no, &lp->addr_offset, &lp->lbl_name_offset,
     2382      2382    2                         &log_blk_num, &opt_flag, &lp->stmt_type, &line_no, &zero_val,
                                &zero_val);
     2383      2383    2                actual_stmt_count++;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=67 
     2384      2384    2              }  /* this is the end of main line no debug processing. */
     2385      2385    1
     2386      2386    1              /* now walk the sub lbl tbl thread looking for sub stmts
     2387      2387    1                 for the current line number. */
     2388      2388    1
     2389      2389    1              if (sub_line_no == 0) { return; }
     2390      2390    1              for (slp= lp->sub_lbl_tbl_ptr ; slp != NULL; slp=next_slp) {
     2391      2391    2                next_slp = slp->next ;
     2392      2392    2                opt_flag = 0;
     2393      2393    2                if (sub_line_no == slp->sub_stmt_no ) {
     2394      2394    3                  if (slp->stmt_type == 1 || slp->stmt_type == 5 ||
     2395      2395    3                      slp->stmt_type ==35 )  {
     2396      2396    4                    opt_flag = -1; }
     2397      2397    3                  offset_address = s_s_table[curr_con_section].curr_offset;
     2398      2398    3                  XUO$EXST (&lp->section_no, &offset_address, &slp->lbl_name_offset,
     2399      2399    3                          &log_blk_num, &opt_flag, &slp->stmt_type, &line_no, &zero_va
                               l, &zero_val);
     2400      2400    3                  actual_stmt_count++;
     2401      2401    3                  return; }
     2402      2402    2
     2403      2403    2              }  /* end of the for loop */
     2404      2404    1              return;
     2405      2405    1              }  /* end of the bld_debug_exec_tbl_entry. */
     2406      2406
     2407      2407
     2408      2408             /*i*
     2409      2409                   name: incr_line
     2410      2410                   purpose: This routine sets the current line nmber and
     2411      2411                   then builds the debug table entry for the executable
     2412      2412                   statements.
     2413      2413             */
     2414      2414             incr_line ()   {
     2415      2415    1
     2416      2416    1              curr_line_no++;
     2417      2417    1              line_num = curr_line_no;
     2418      2418    1
     2419      2419    1              bld_debug_exec_tbl_entry(curr_line_no, 0);
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=68 
     2420      2420    1
     2421      2421    1              get_eol(); /* make sure at eol character. */
     2422      2422    1              return;
     2423      2423    1              }   /* end of incr_line function. */
     2424      2424
     2425      2425
     2426      2426
     2427      2427             /*i*
     2428      2428                   name: build_debug
     2429      2429                   purpose: This routine is used to build the ariable debug record
     2430      2430                   hat is needed for all variables that are used in the program.
     2431      2431                   It calls the XUO$VREBL routine whcih acutally puts the info
     2432      2432                   into the o.u. debug record.
     2433      2433             */
     2434      2434             build_debug(sp)  struct sym_tbl *sp; {
     2435      2435    1        struct sym_debug_tbl *dt;
     2436      2436    1        int d_address;
     2437      2437    1        int d_addr_type;
     2438      2438    1        int d_data_type;
     2439      2439    1        int d_ref_flag;
     2440      2440    1        int d_mod_flag;
     2441      2441    1        int d_log_size;
     2442      2442    1        int d_level_no;
     2443      2443    1        int d_align_type;
     2444      2444    1        int d_size_type_flag;
     2445      2445    1        int d_array_type;
     2446      2446    1        int d_operand_type;
     2447      2447    1        int d_operand;
     2448      2448    1        int d_imp_ptr;
     2449      2449    1        int d_ele_size;
     2450      2450    1        int d_scale_factor;
     2451      2451    1        int d_dims ;
     2452      2452    1        int d_name_offset;
     2453      2453    1        int d_elements;
     2454      2454    1        int d_offset;
     2455      2455    1        int d_multi[10];
     2456      2456    1        int i;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=69 
     2457      2457    1        int ele_bytes;
     2458      2458    1        int save_flag = 0;
     2459      2459    1        int save_reloc_type;
     2460      2460    1        int save_reloc_section;
     2461      2461    1        int save_storage_class;
     2462      2462    1
     2463      2463    1              if (static_data_flag != 0) return;
     2464      2464    1              dt = sp->debug;
     2465      2465    1              pl6str( sp->name);
     2466      2466    1
     2467      2467    1              XUO$DBGNAME (buffer, &d_name_offset); /* put name in debug name tbl */
     2468      2468    1
     2469      2469    1              if (dt->addr_type == 1) {  /* static data entity.. */
     2470      2470    2                if (sp->storage_class == GLOBAL_STATIC_STORAGE) {
     2471      2471    3                   d_address = sp->offset * 36; }
     2472      2472    2                else {
     2473      2473    3                   d_address = sp->offset * 9; }  }
     2474      2474    1              else {
     2475      2475    2                d_address = dt->addr_byte*9 ; /* make a bit address. */
     2476      2476    2                if (dt->starting_bit != 0) {
     2477      2477    3                  d_address += dt->starting_bit; }
     2478      2478    2              }
     2479      2479    1              d_addr_type = addr_type_tbl[dt->addr_type];
     2480      2480    1              d_data_type = dt->data_type;
     2481      2481    1              d_ref_flag = -1;
     2482      2482    1              d_mod_flag = -1;
     2483      2483    1              d_ele_size = 0;
     2484      2484    1              d_level_no = dt->level_no;
     2485      2485    1              d_align_type = align_vals[d_data_type];
     2486      2486    1              d_size_type_flag = 0;
     2487      2487    1              if (d_data_type == STRUCTURE_DATA_TYPE && d_level_no == 1) {
     2488      2488    2                 curr_struct_type = d_addr_type;
     2489      2489    2                 curr_struct_reloc_type = sp->reloc_type;
     2490      2490    2                 curr_struct_reloc_section = sp->reloc_section;
     2491      2491    2                curr_offset_value = d_address ;
     2492      2492    2                 curr_storage_class = sp->storage_class ; }
     2493      2493    1              else {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=70 
     2494      2494    2                 if ( d_level_no > 1 ) {
     2495      2495    3                    d_addr_type = curr_struct_type;
     2496      2496    3                    if (d_addr_type != AUTO_TYPE) {
     2497      2497    4                      d_address  += curr_offset_value ; }
     2498      2498    3                    save_flag = 1;
     2499      2499    3                    save_reloc_type = sp->reloc_type;
     2500      2500    3                    save_reloc_section = sp->reloc_section;
     2501      2501    3                    save_storage_class = sp->storage_class;
     2502      2502    3                    sp->reloc_type = curr_struct_reloc_type;
     2503      2503    3                    sp->reloc_section = curr_struct_reloc_section;
     2504      2504    3                    sp->storage_class = curr_storage_class; }
     2505      2505    2               }
     2506      2506    1              ele_bytes = 1; /* set to default value of 1. */
     2507      2507    1              if (d_data_type == 1 ||
     2508      2508    1                  d_data_type == 3 ||
     2509      2509    1                  d_data_type == 13
     2510      2510    1                                    ) {
     2511      2511    2                ele_bytes = 4; }
     2512      2512    1              else {
     2513      2513    2                if (d_data_type == 2 || d_data_type == 4) {
     2514      2514    3                  ele_bytes = 8; }
     2515      2515    2                }
     2516      2516    1              if (d_data_type == 24) {
     2517      2517    2                ele_bytes = 4 ; }
     2518      2518    1              if (d_data_type == 3 ||    /* single pre float */
     2519      2519    1                  d_data_type == 4  ||   /* double pre float */
     2520      2520    1                  d_data_type == 17      /* structure  */
     2521      2521    1                                    ) {
     2522      2522    2                  d_ele_size = dt->ele_size * 9; }
     2523      2523    1              else {
     2524      2524    2                 d_ele_size = dt->ele_size ; }
     2525      2525    1
     2526      2526    1              if (d_data_type == UBIN_DATA_TYPE || d_data_type == SBIN_DATA_TYPE) {
     2527      2527    2                d_log_size = dt->size_bytes; }
     2528      2528    1              else {
     2529      2529    2                d_log_size = d_ele_size;  }
     2530      2530    1              if (dt->array_rec_count != 0) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=71 
     2531      2531    2                 /* have array variable. */
     2532      2532    2                 if (d_data_type == CHAR_DATA_TYPE) {
     2533      2533    3                   d_ele_size = 9; }
     2534      2534    2                 if (d_data_type == POINTER_DATA_TYPE) {
     2535      2535    3                   d_ele_size = 36; }
     2536      2536    2                 if (dt->array_rec_count == 1) {
     2537      2537    3                    d_dims = dt->array_size/ele_bytes;
     2538      2538    3                    d_array_type = VECTOR0_ARRAY; }
     2539      2539    2                 else {
     2540      2540    3                    d_array_type = GENERAL_ARRAY;
     2541      2541    3                    d_dims = dt->array_rec_count; }  }
     2542      2542    1              else {
     2543      2543    2                 d_ele_size = 0;
     2544      2544    2                 d_array_type = SCALAR_ARRAY ;
     2545      2545    2                 d_dims = 0; }
     2546      2546    1              d_operand_type = sp->reloc_type ;
     2547      2547    1              d_operand = sp->reloc_section ;
     2548      2548    1              if (d_data_type == POINTER_DATA_TYPE) {
     2549      2549    2                 d_log_size = 1;
     2550      2550    2                 d_imp_ptr = 0;
     2551      2551    2               }
     2552      2552    1
     2553      2553    1
     2554      2554    1              if (d_addr_type == 3) {  /* pointer address type.  */
     2555      2555    2                 d_imp_ptr = -1;
     2556      2556    2              } else {
     2557      2557    2                 d_imp_ptr = -1;
     2558      2558    2               }
     2559      2559    1
     2560      2560    1              d_scale_factor = 0;
     2561      2561    1
     2562      2562    1              XUO$VREBL (&d_address, &d_addr_type,
     2563      2563    1                 &d_data_type, &d_ref_flag,
     2564      2564    1                 &d_mod_flag,
     2565      2565    1                 &d_log_size,
     2566      2566    1                 &d_level_no,
     2567      2567    1                 &d_align_type,
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=72 
     2568      2568    1                 &d_size_type_flag,
     2569      2569    1                 &d_array_type,
     2570      2570    1                 &d_operand_type,
     2571      2571    1                 &d_imp_ptr,
     2572      2572    1                 &d_operand,
     2573      2573    1                 &d_ele_size,
     2574      2574    1                 &d_scale_factor,
     2575      2575    1                 &d_dims ,
     2576      2576    1                 &d_name_offset );
     2577      2577    1              if (d_array_type == GENERAL_ARRAY ) {
     2578      2578    2                for (i=0; i <= 5; i++) {  /* zero init the array items. */
     2579      2579    3                  d_multi[i] = 0; }
     2580      2580    2                d_elements = dt->array_size/ele_bytes;
     2581      2581    2                d_offset = 0;
     2582      2582    2                d_multi[dt->array_rec_count-1] =1;
     2583      2583    2                for ( i= dt->array_rec_count-2; i >= 0; i--) {
     2584      2584    3                  d_multi[i] = dt->array_info[i+1]/ele_bytes;
     2585      2585    3                 }
     2586      2586    2                XUO$VREBL_CONT (&d_offset, &d_data_type,
     2587      2587    2                    &d_elements, &d_multi[0],
     2588      2588    2                    &d_multi[1], &d_multi[2],
     2589      2589    2                    &d_multi[3], &d_multi[4],
     2590      2590    2                    &d_multi[5] ) ;
     2591      2591    2              }   /* end of the array multipliers processing. */
     2592      2592    1
     2593      2593    1              if (save_flag != 0) {
     2594      2594    2                 sp->reloc_type = save_reloc_type;
     2595      2595    2                 sp->reloc_section = save_reloc_section;
     2596      2596    2                 sp->storage_class = save_storage_class;  }
     2597      2597    1              return ;
     2598      2598    1              }   /* end of the build debug routine     */
     2599      2599
     2600      2600             /*i*
     2601      2601                   name: check_eol
     2602      2602                   purpose: To check for the eol character, and if found
     2603      2603                   set the eol_flag (a global ) indicating it have been found.
     2604      2604                   ..
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=73 
     2605      2605             */
     2606      2606             check_eol()  {
     2607      2607    1
     2608      2608    1              if (c == '\n') {
     2609      2609    2                 eol_flag = -1;
     2610      2610    2               }
     2611      2611    1              return;
     2612      2612    1              }
     2613      2613
     2614      2614
     2615      2615             /*i*
     2616      2616                   name: get_eol
     2617      2617                   purpose: To make sure that an eol character has been hit
     2618      2618                   on the current record that is being processed.
     2619      2619
     2620      2620             */
     2621      2621             get_eol () {
     2622      2622    1        int i;
     2623      2623    1
     2624      2624    1              if ( c != '\n' ) {
     2625      2625    2                while ((c=getc(infile)) != '\n' ) i++;
     2626      2626    2               }
     2627      2627    1              return;
     2628      2628    1              }
     2629      2629
     2630      2630             /*i*
     2631      2631                   name: check_for_plus
     2632      2632                   purpose: This routine checks for addative value to be added
     2633      2633                   to the pointed at address value. This value is then added to
     2634      2634                   the offset of the entity that is being pointed at. Example:
     2635      2635                   symdefid+6. The '+6' is added to the offset address for the
     2636      2636                   symdefid after the '+6' has been scanned.
     2637      2637                   This is a byte address value that is being added to the
     2638      2638                   address field of the pointer that is being evaluated.
     2639      2639             */
     2640      2640             check_for_plus (offset) int *offset; {
     2641      2641    1        int val;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=74 
     2642      2642    1
     2643      2643    1
     2644      2644    1              *offset = *offset << 2; /* make wrd addr a byte addr. */
     2645      2645    1              if (c == ',' || c == '\n') return;
     2646      2646    1              if (c == '+') {
     2647      2647    2                 while ((c=getc(infile)) == '+'){}
     2648      2648    2                 ungetc(c,infile); }
     2649      2649    1              val = get_value() ;
     2650      2650    1              *offset += val;
     2651      2651    1              return;
     2652      2652    1              } /* end of the check_for_plus routine. */
     2653      2653
     2654      2654             /*i*
     2655      2655                   NAME:chk_entref_names
     2656      2656                   PURPOSE: This function checks if the static function names
     2657      2657                   are in the debug record. They will not be, so it then builds
     2658      2658                   the debug schema for all the static function names so that
     2659      2659                   the user can then reference all the static function names
     2660      2660                   via their 'correct' user reference name.
     2661      2661             */
     2662      2662             chk_entref_names() {
     2663      2663    1        int i;
     2664      2664    1        int eref_num, name_offset;
     2665      2665    1        int hash_value;
     2666      2666    1        char tmp1 [128];
     2667      2667    1        static_funcs_p p, next_p;
     2668      2668    1        struct sym_tbl *sp, *last_p, *sp1, *sp2, *next ;
"zb6$tables:c.:ZBC3TSI", line 2668: (warning) identifier "last_p" is not used
     2669      2669    1        struct sym_debug_tbl *dp;
     2670      2670    1
     2671      2671    1
     2672      2672    1              for (p = static_p; p != (static_funcs_p) 0; p = next_p ) {
     2673      2673    2                next_p = p->next;
     2674      2674    2                sp1 = (struct sym_tbl *) symbol_hash[p->hash];
     2675      2675    2                strcpy (h_stuff.label_t, p->name_field.name);
     2676      2676    2                if (sp1 == NULL) {
     2677      2677    3                  hash_value = p->hash ;
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=75 
     2678      2678    3                  sp = (struct sym_tbl *) bld_sym_tbl_entry(sp1,last_sp,hash_value);
     2679      2679    3                  sp->debug = NULL ;
     2680      2680    3                  sp->next = NULL ;  }
     2681      2681    2                else {
     2682      2682    3                  /*  search for match.. */
     2683      2683    3                  for (sp2 = sp1; sp2 != NULL; sp2 = next) {
     2684      2684    4                    next =  sp2->next;
     2685      2685    4                    last_sp = sp2;
     2686      2686    4                    if (( i=strcmp (h_stuff.label_t, sp2->name)) == 0 ) {
     2687      2687    5                      /* have match on text names at this point. */
     2688      2688    5                      if (sp2->sym_class != FUNCTION_CLASS) { goto next_test; }
     2689      2689    5                      sp = sp2 ;
     2690      2690    5                      goto set_debug;
     2691      2691    5                    }  /* end of if test on string compare... */
     2692      2692    4        next_test:  ;
     2693      2693    4                  }  /* end of the for loop on matching.. */
     2694      2694    3                  /* at this point, no match was found so build new
     2695      2695    3                     new symbol table entry.  */
     2696      2696    3                  hash_value = p->hash ;
     2697      2697    3                  sp = (struct sym_tbl *) bld_sym_tbl_entry (sp1,last_sp,hash_value);
     2698      2698    3
     2699      2699    3                  sp->debug = NULL ;
     2700      2700    3                  sp->next = NULL ;
     2701      2701    3                }  /* end of if test on sp1 == null  */
     2702      2702    2
     2703      2703    2                sp->addr_type = AUTO_TYPE;
     2704      2704    2                sp->sym_class = FUNCTION_CLASS;
     2705      2705    2
     2706      2706    2        set_debug:  /* at this point, we are setting the debug info. */
     2707      2707    2
     2708      2708    2                if (sp->debug == NULL ) {
     2709      2709    3                  dp = (struct sym_debug_tbl *) myalloc(sizeof(struct sym_debug_tbl));

     2710      2710    3                  sp->debug = dp;
     2711      2711    3                }
     2712      2712    2                /* set the values in the debug table entry for the symbol
     2713      2713    2                   so the proper debug info will be generated. */
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=76 
     2714      2714    2                dp = sp->debug;
     2715      2715    2                dp->level_no = 1;
     2716      2716    2                dp->addr_type = STATIC_TYPE;
     2717      2717    2                dp->data_type = LABEL_DATA_TYPE;
     2718      2718    2                dp->ele_size = 1;
     2719      2719    2                sp->offset = 0;
     2720      2720    2
     2721      2721    2                if (sp->reloc_type == 0 || sp->reloc_section == -1)  { /* build entref
                                of external name. */
     2722      2722    3                  strcpy(tmp1, sp->name);
     2723      2723    3                  strcat(tmp1, "#");
     2724      2724    3                  strcat(tmp1, static_name);
     2725      2725    3                  pl6str(tmp1);
     2726      2726    3                  XUO$RNAME (buffer, &name_offset);
     2727      2727    3                  XUO$EREF (&name_offset, &zero_val, &minus_one_val, &zero_val,
     2728      2728    3                     &std_call, &zero_val, &eref_num);
     2729      2729    3                  sp->reloc_section = eref_num ;
     2730      2730    3                  sp->reloc_type = ENTREF_TYPE;
     2731      2731    3                }  /* end of the build of the relocation directive... */
     2732      2732    2
     2733      2733    2                build_debug (sp);
     2734      2734    2                sp->addr_type = STATIC_TYPE;
     2735      2735    2              }  /* end of for loop on static function names. */
     2736      2736    1              return;
     2737      2737    1        }  /* end of the chk_entref_name function..  */
     2738      2738
     2739      2739             /*I*
     2740      2740                   NAME: GET_LAST_DEBUG_LINE
     2741      2741                   PURPOSE: This function gets the last executable line tbl
     2742      2742                   entry of the last o.u. that was created, and compares it
     2743      2743                   with the passed line number. It sets a flag word that was
     2744      2744                   passed to indicate if a match was found. I returns 0 if
     2745      2745                   the <= condition was not found  with the compare. It returns
     2746      2746                   -1 it the last debug line is <= to the passed line number.
     2747      2747             */
     2748      2748             GET_LAST_DEBUG_LINE(line, flag) int *line, *flag; {
     2749      2749    1              if (curr_line_no < *line) {
CC.C03    File=zb6$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=77 
     2750      2750    2                *flag = -1; }
     2751      2751    1              else {
     2752      2752    2                *flag = 0;}
     2753      2753    1              return;
     2754      2754    1        }
---  Include file information  ---

   stdio:h.:LIBRARY. is referenced
   string:h.:LIBRARY. is referenced
   zb6$ougen:h.:ZBC3TOU. is referenced
   zb6$tables:h.:ZBC3TOU. is referenced
   zb6$instructions:h.:ZBC3TOU. is referenced
   codegen:h.:ZBC3TOU. is referenced
   zb6$equate1:h.:ZBC3TOU. is referenced
   zb_cp6_object:h.:ZBC3TOU. is referenced

15 warnings were detected in the file zb6$tables:c.:ZBC3TSI
