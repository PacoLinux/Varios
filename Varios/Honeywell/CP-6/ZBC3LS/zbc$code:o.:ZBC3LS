

CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=1  
        1         1             /*
        2         2              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3         3              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4         4              */
        5         5             /* $Header: code.c,v 3.27 87/04/02 13:02:16 ceriel Exp $ */
        6         6             /*  C O D E - G E N E R A T I N G   R O U T I N E S    */
        7         7
        8         8             #include  <em.h>
        9         9             #include  "botch_free.h"
       10        10             #include  <alloc.h>
       11        11             #include  "nofloat.h"
       12        12             #include  "dataflow.h"
       13        13             #include  "use_tmp.h"
       14        14             #include  "arith.h"
       15        15             #include  "type.h"
       16        16             #include  "idf.h"
       17        17             #include  "label.h"
       18        18             #include  "code.h"
       19        19             #include  "stmt.h"
       20        20             #include  "def.h"
       21        21             #include  "expr.h"
       22        22             #include  "sizes.h"
       23        23             #include  "stack.h"
       24        24             #include  "level.h"
       25        25             #include  "decspecs.h"
       26        26             #include  "declar.h"
       27        27             #include  "Lpars.h"
       28        28             #include  "mes.h"
       29        29             #include  "LLlex.h"
       30        30             #include  "specials.h"
       31        31             #include  "atw.h"
       32        32             #include  "assert.h"
       33        33             #include  "align.h"
       34        34             #include  "noRoption.h"
       35        35             #include "zb_cp6_object.h"
       36        36             #include "zb_target.h"
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=2  
       37        37             #include "dataFirst.h"
       38        38             #include "use_tmp.h"
       39        39             #include "struct.h"
       40        40
       41        41             label lab_count = 1;
       42        42             label datlab_count = 1;
       43        43             long static_data = 0, constant_data = 0;
       44        44
       45        45             #define align_data(data,algn) ((align(data,algn)-data) & (-4))
       46        46
       47        47
       48        48             #ifndef NOFLOAT
       49        49             int fp_used;
       50        50             #endif NOFLOAT
       51        51
       52        52             extern char options[];
       53        53             char *symbol2str();
       54        54
       55        55             init_code(dst_file)
       56        56              char *dst_file;
       57        57             {
       58        58    1         /* init_code() initialises the output file on which the
       59        59    1            compact EM code is written
       60        60    1         */
       61        61    1         C_init(word_size, pointer_size); /* initialise EM module */
       62        62    1         if (C_open(dst_file) == 0)
       63        63    1            fatal("cannot write to %s\n", dst_file);
       64        64    1        #ifdef USE_TMP
       65        65    1         if (options['N'])
       66        66    1        #endif USE_TMP
       67        67    1         famous_first_words();
       68        68    1        }
       69        69
       70        70             famous_first_words()
       71        71             {
       72        72    1         C_magic();
       73        73    1         C_ms_emx(word_size, pointer_size);
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=3  
       74        74    1        }
       75        75
       76        76             static struct string_cst *str_list[37] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
       77        77             int const_strings = 0;
       78        78             static char zeroes[8] = {"\000\000\000\000\000\000\000"};
       79        79
       80        80             label code_string(val, len)
       81        81              char *val;
       82        82              int len;
       83        83             {
       84        84    1         register struct string_cst *sc;
       85        85    1         label dlb;
       86        86    1         register int stri = _LOG_B_2(len);
       87        87    1
       88        88    1         if (const_strings) {
       89        89    2            sc = str_list[stri];
       90        90    2            while (sc)
       91        91    2               if (sc->sc_len == len && strcmp(val,sc->sc_value)==0)   {
       92        92    3                  C_ina_dlb(sc->sc_dlb);
       93        93    3                  return sc->sc_dlb;
       94        94    3               }
       95        95    2               else sc = sc->next;
       96        96    2         }
       97        97    1         sc = new_string_cst();
       98        98    1         sc->next = str_list[stri];
       99        99    1         str_list[stri] = sc;
      100       100    1         dlb = data_label();
      101       101    1         C_ina_dlb(dlb);
      102       102    1         sc->sc_value = val;
      103       103    1         sc->sc_len = len;
      104       104    1         sc->sc_dlb = dlb;
      105       105    1         return dlb;
      106       106    1        }
      107       107
      108       108             def_strings()
      109       109             {
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=4  
      110       110    1         register i, Fn = 0;
      111       111    1         register sz = (const_strings) ? constant_data : static_data;
      112       112    1
      113       113    1        #if DATAFIRST && defined(USE_TMP)
      114       114    1         if (!options['N'])  Fn = 1;
      115       115    1        #endif
      116       116    1         for (i = 36; i >= 0 ; i--)   {
      117       117    2            register struct string_cst *s, *sc = str_list[i];
      118       118    2            str_list[i] = 0;
      119       119    2            while (sc) {
      120       120    3               s = sc;
      121       121    3        #if DATAFIRST && defined(USE_TMP)
      122       122    3               EM_File_No = Fn;
      123       123    3        #endif
      124       124    3               sz = ATW(sz);
      125       125    3               C_df_dlb(sc->sc_dlb);
      126       126    3               str_cst(sc->sc_value, sc->sc_len, const_strings, 1);
      127       127    3               sz += ATW( sc->sc_len );
      128       128    3               sc = sc->next;
      129       129    3               free_string_cst(s);
      130       130    3            }
      131       131    2         }
      132       132    1         i = ATW(sz) - sz;
      133       133    1        #if DATAFIRST && defined(USE_TMP)
      134       134    1         EM_File_No = Fn;
      135       135    1        #endif
      136       136    1         if (const_strings) {
      137       137    2            constant_data = sz + i;
      138       138    2            if (i) C_rom_scon(zeroes, (arith)i);
      139       139    2         }
      140       140    1         else {
      141       141    2            static_data = sz + i;
      142       142    2            if (i) C_con_scon(zeroes, (arith)i);
      143       143    2         }
      144       144    1        #if DATAFIRST && defined(USE_TMP)
      145       145    1         EM_File_No = 0;
      146       146    1        #endif
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=5  
      147       147    1        }
      148       148
      149       149             end_code()
      150       150             {
      151       151    1         /* end_code() performs the actions to be taken when closing
      152       152    1            the output stream.
      153       153    1         */
      154       154    1         def_strings();
      155       155    1         C_ms_src((int)(LineNumber - 2), FileName);
      156       156    1         C_close();
      157       157    1        }
      158       158
      159       159             #ifdef USE_TMP
      160       160             prepend_scopes(dst_file)
      161       161              char *dst_file;
      162       162             {
      163       163    1         /* prepend_scopes() runs down the list of global idf's
      164       164    1            and generates those exa's, exp's, ina's and inp's
      165       165    1            that superior hindsight has provided, on the file dst_file.
      166       166    1         */
      167       167    1         register struct stack_entry *se = local_level->sl_entry;
      168       168    1
      169       169    1         if (C_open(dst_file) == 0)
      170       170    1            fatal("cannot create %s", dst_file ? dst_file : "stdout");
      171       171    1         famous_first_words();
      172       172    1         prepend_csect_info();
      173       173    1         while (se != 0)   {
      174       174    2            register struct idf *id = se->se_idf;
      175       175    2            register struct def *df = id->id_def;
      176       176    2             register struct sdef *sdef = id->id_sdef;
      177       177    2
      178       178    2                if (df && !df->df_schema && (df->df_sc != EXTERN || df->df_used != 0)
                               )
      179       179    2                   debugvar(id, df, 0, 0);
      180       180    2
      181       181    2                if (sdef && (sdef->sd_stype->tp_debmes == 1) )
      182       182    2                   debugbased(sdef->sd_stype->tp_sdef);
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=6  
      183       183    2
      184       184    2            if (df && (df->df_initialized || df->df_used || df->df_alloc))
      185       185    2               code_scope(id->id_text, df);
      186       186    2            se = se->next;
      187       187    2         }
      188       188    1         C_close();
      189       189    1        }
      190       190             #endif USE_TMP
      191       191
      192       192             code_scope(text, def)
      193       193              char *text;
      194       194              register struct def *def;
      195       195             {
      196       196    1         /* generates code for one name, text, of the storage class
      197       197    1            as given by def, if meaningful.
      198       198    1         */
      199       199    1         int fund = def->df_type->tp_fund;
      200       200    1
      201       201    1         switch (def->df_sc)  {
      202       202    2         case EXTERN:
      203       203    2         case GLOBAL:
      204       204    2         case IMPLICIT:
      205       205    2            if (fund == FUNCTION)  {
      206       206    3               struct formallist *fm = def->df_type->tp_formal;
      207       207    3               C_exp(text);
      208       208    3               if (fm && !fm->fl_elips) {
      209       209    4                  int j = fm->fl_num;
      210       210    4                  if ((j == 1) && (fm->fl_type[0] == void_type))
      211       211    4                    j = 0;
      212       212    4                  C_ms_rfun(text, (fm && !fm->fl_elips), 0, j);
      213       213    4                  }
      214       214    3               }
      215       215    2            else
      216       216    2               C_exa_dnam(text);
      217       217    2            break;
      218       218    2         case STATIC:
      219       219    2            if (fund == FUNCTION)  {
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=7  
      220       220    3               if (!def->df_alloc && !def->df_initialized)
      221       221    3                  error("definition of static function %s missing", text);
      222       222    3               C_inp(text);
      223       223    3               }
      224       224    2            else
      225       225    2               C_ina_dnam(text);
      226       226    2            break;
      227       227    2         }
      228       228    1        }
      229       229
      230       230             static label return_label;
      231       231             static char return_expr_occurred;
      232       232             struct type *func_tp;
      233       233             struct def  *func_df;
      234       234             arith        func_rs;
      235       235             static label func_res_label;
      236       236             static char *last_fn_given = "";
      237       237             char *current_function_name = "";
      238       238             static int  current_function_sc    = 0;
      239       239             int         current_block_level    = 0, current_statement_type = 0;
      240       240             static label file_name_label;
      241       241
      242       242             begin_proc(name, def) /* to be called when entering a procedure */
      243       243              char *name;
      244       244              register struct def *def;
      245       245             {
      246       246    1         /* begin_proc() is called at the entrance of a new function
      247       247    1            and performs the necessary code generation:
      248       248    1            -  a scope indicator (if needed) exp/inp
      249       249    1            -  the procedure entry pro $name
      250       250    1            -  reserves some space if the result of the function
      251       251    1               does not fit in the return area
      252       252    1            -  a fil pseudo instruction
      253       253    1         */
      254       254    1         arith size;
      255       255    1         register struct type *tp = def->df_type;
      256       256    1
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=8  
      257       257    1        #ifdef USE_TMP
      258       258    1         if (options['N']) code_scope(name,def);
      259       259    1        #else USE_TMP
      260       260   *S*        code_scope(name, def);
      261       261   *S*       #endif USE_TMP
      262       262    1        #ifdef DATAFLOW
      263       263    1         if (options['d'])
      264       264    1            DfaStartFunction(name);
      265       265    1        #endif DATAFLOW
      266       266    1
      267       267    1         if (tp->tp_fund != FUNCTION) {
      268       268    2            error("making function body for non-function");
      269       269    2            tp = error_type;
      270       270    2         }
      271       271    1         else
      272       272    1            tp = tp->tp_up;
      273       273    1         func_tp = (tp == float_type) ? double_type : tp;
      274       274    1         func_rs = 0;
      275       275    1         func_df = def;
      276       276    1         size = ATW(tp->tp_size);
      277       277    1         current_function_name = name;
      278       278    1         current_function_sc   = def->df_sc != STATIC;
      279       279    1         ASSERT(current_block_level == 0);
      280       280    1         C_pro_narg(name);
      281       281    1         C_ms_blk(0, dot.tok_debline, 0, current_block_level++);
      282       282    1         C_ms_stmt(S_PROC, dot.tok_debline, 0);
      283       283    1         if (is_struct_or_union(tp->tp_fund))   {
      284       284    2        #if DATAFIRST && defined(USE_TMP)
      285       285    2            if (!options['N']) EM_File_No = 1;
      286       286    2        #endif
      287       287    2            if (zb_target_sys == TARGET_CP6)  { ;
      288       288    3        #if 0
      289       289   *S*              arith s = align_data(static_data, tp->tp_align);
      290       290   *S*              align_sect_to_word(&static_data,0);
      291       291   *S*              if (s) {
      292       292   *S*                 C_bss_cst(s, (arith)0, 1);
      293       293   *S*                 static_data += s;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=9  
      294       294   *S*                 }
      295       295   *S*              static_data = ATW(static_data);
      296       296   *S*              C_df_dlb(func_res_label = data_label());
      297       297   *S*              C_bss_cst(size, (arith)0, 1);
      298       298   *S*       #endif
      299       299    3               }
      300       300    2            else {
      301       301    3               static_data = ATW(static_data);
      302       302    3               C_df_dlb(func_res_label = data_label());
      303       303    3               C_bss_cst(size, (arith)0, 1);
      304       304    3               }
      305       305    2        #if DATAFIRST && defined(USE_TMP)
      306       306    2            EM_File_No = 0;
      307       307    2        #endif
      308       308    2         }
      309       309    1         else
      310       310    1            func_res_label = 0;
      311       311    1         /* Special arrangements if the function result doesn't fit in
      312       312    1            the function return area of the EM machine.  The size of
      313       313    1            the function return area is implementation dependent.
      314       314    1         */
      315       315    1         lab_count = (label) 1;
      316       316    1         return_label = text_label();
      317       317    1         return_expr_occurred = 0;
      318       318    1         prc_entry(name);
      319       319    1        #ifndef _CP6_
      320       320   *S*        if (! options['L'])  {  /* profiling */
      321       321   *S*           if (strcmp(last_fn_given, FileName) != 0) {
      322       322   *S*              /* previous function came from other file */
      323       323   *S*              arith fnlen = strlen(FileName) + 1;
      324       324   *S*       #if DATAFIRST && defined(USE_TMP)
      325       325   *S*              if (!options['N'])  EM_File_No = 1;
      326       326   *S*       #endif
      327       327   *S*              constant_data = ATW(constant_data);
      328       328   *S*              C_df_dlb(file_name_label = data_label());
      329       329   *S*              C_rom_scon(last_fn_given = FileName, fnlen);
      330       330   *S*              constant_data +=  fnlen;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=10 
      331       331   *S*              if (fnlen & 3) {
      332       332   *S*                 C_rom_scon( "\000\000\000\000", 4 - (fnlen & 3));
      333       333   *S*                 constant_data += 4 - (fnlen & 3);
      334       334   *S*                 }
      335       335   *S*       #if DATAFIRST && defined(USE_TMP)
      336       336   *S*              EM_File_No = 0;
      337       337   *S*       #endif
      338       338   *S*           }
      339       339   *S*           /* enable debug trace of EM source */
      340       340   *S*           C_fil_dlb(file_name_label, (arith)0);
      341       341   *S*       #endif  /* _CP6_ */
      342       342    1            C_lin((arith)dot.tok_debline);
      343       343    1            finfo.ExprLines++;
      344       344    1        #ifndef _CP6_
      345       345   *S*        }
      346       346   *S*       #endif
      347       347    1        }
      348       348
      349       349             end_proc(fbytes, nbytes)
      350       350              arith fbytes, nbytes;
      351       351             {
      352       352    1         /* end_proc() deals with the code to be generated at the end of
      353       353    1            a function, as there is:
      354       354    1            -  the EM ret instruction: "ret 0"
      355       355    1            -  loading of the function result in the function
      356       356    1               result area if there has been a return <expr>
      357       357    1               in the function body (see do_return_expr())
      358       358    1            -  indication of the use of floating points
      359       359    1            -  indication of the number of bytes used for
      360       360    1               formal parameters
      361       361    1            -  use of special identifiers such as "setjmp"
      362       362    1            -  "end" + number of bytes used for local variables
      363       363    1         */
      364       364    1         static int mes_flt_given = 0; /* once for the whole program */
      365       365    1         arith debline;
      366       366    1         int   p;
      367       367    1
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=11 
      368       368    1        #ifdef DATAFLOW
      369       369    1         if (options['d'])
      370       370    1            DfaEndFunction();
      371       371    1        #endif DATAFLOW
      372       372    1         debline = C_ms_stmt( S_PROC_END, dot.tok_debline );
      373       373    1         C_lin( debline );
      374       374    1         prc_exit();
      375       375    1         if ( !return_expr_occurred && func_tp->tp_size < 0 )
      376       376    1            error("size of function result unknown");
      377       377    1         if (strcmp(current_function_name,"main")==0)  {
      378       378    2         C_loc( (arith)0 );
      379       379    2         C_ret( (arith)word_size);
      380       380    2         }
      381       381    1         else C_ret((arith)0);
      382       382    1         if (return_expr_occurred != 0)   {
      383       383    2            C_df_ilb(return_label);
      384       384    2            C_lin( debline );
      385       385    2            prc_exit();
      386       386    2            if (is_struct_or_union(func_tp->tp_fund))  {
      387       387    3               if (zb_target_sys != TARGET_CP6) {
      388       388    4                  C_lae_dlb(func_res_label, (arith)0);
      389       389    4                  store_block(func_tp->tp_size, func_tp->tp_align);
      390       390    4                  C_lae_dlb(func_res_label, (arith)0);
      391       391    4                  }
      392       392    3               else C_lol(12, (arith)0);
      393       393    3               C_ret(pointer_size);
      394       394    3            }
      395       395    2            else  {
      396       396    3               if (zb_target_sys == TARGET_CP6)  {
      397       397    4                  arith sz = func_tp->tp_size;
      398       398    4                  int   al = func_tp->tp_align;
      399       399    4                  if (sz == word_size && al == word_align) C_lol(func_rs);
      400       400    4                  else if (sz==double_size && al == double_align) C_ldl(func_rs);
      401       401    4                  else {
      402       402    5                     C_lal(func_rs);
      403       403    5                     load_block(sz,al);
      404       404    5                     }
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=12 
      405       405    4                  }
      406       406    3               C_ret(ATW(func_tp->tp_size));
      407       407    3               }
      408       408    2         }
      409       409    1        #ifndef NOFLOAT
      410       410    1         if (fp_used && mes_flt_given == 0)  {
      411       411    2            /* floating point used  */
      412       412    2            C_ms_flt();
      413       413    2            mes_flt_given++;
      414       414    2         }
      415       415    1        #endif NOFLOAT
      416       416    1         C_ms_par(fbytes);    /* # bytes for formals     */
      417       417    1         if (sp_occurred[SP_SETJMP]) { /* indicate use of "setjmp"   */
      418       418    2            C_ms_gto();
      419       419    2            sp_occurred[SP_SETJMP] = 0;
      420       420    2         }
      421       421    1         nbytes = (nbytes > -func_rs)? nbytes : -func_rs;
      422       422    1         p = func_df->df_type->tp_formal && !func_df->df_type->tp_formal->fl_elips;
      423       423    1         C_ms_fun(current_function_name,p,0,current_function_sc,fbytes,nbytes);
      424       424    1         C_ms_blk(1, dot.tok_debline, 0, --current_block_level);
      425       425    1         finfo.ExprLines++;
      426       426    1         C_end(ATW(nbytes));
      427       427    1        }
      428       428
      429       429             do_return()
      430       430             {
      431       431    1         /* do_return generates a direct return */
      432       432    1         /* isn't a jump to the return label smarter ??? */
      433       433    1         prc_exit();
      434       434    1         if (!memcmp(current_function_name,"main", 5)) {
      435       435    2             C_loc(0);
      436       436    2             C_ret((arith)word_size);
      437       437    2             }
      438       438    1         else C_ret((arith)0);
      439       439    1        }
      440       440
      441       441             do_return_expr(expr)
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=13 
      442       442              struct expr *expr;
      443       443             {
      444       444    1         /* do_return_expr() generates the expression and the jump for
      445       445    1            a return statement with an expression.
      446       446    1         */
      447       447    1         ch7cast(&expr, RETURN, func_tp);
      448       448    1         code_expr(expr, RVAL, TRUE, NO_LABEL, NO_LABEL);
      449       449    1         if (func_tp == void_type)
      450       450    1            error("void functions cannot return results");
      451       451    1         if (zb_target_sys == TARGET_CP6)  {
      452       452    2            arith sz = func_tp->tp_size;
      453       453    2            int   al = func_tp->tp_align;
      454       454    2            if (is_struct_or_union(func_tp->tp_fund)) {
      455       455    3               C_lol(12);    /* __varyarg_ptr */
      456       456    3               store_block(sz,al);
      457       457    3               }
      458       458    2            else {
      459       459    3               func_rs  = -align(sz, al);
      460       460    3               if (sz == word_size) C_stl(func_rs);
      461       461    3               else if (sz == dword_size && al == double_align) C_sdl(func_rs);
      462       462    3               else {
      463       463    4                  C_lal(func_rs);
      464       464    4                  store_block(sz, al);
      465       465    4                  }
      466       466    3               }
      467       467    2            }
      468       468    1         C_bra(return_label);
      469       469    1         return_expr_occurred = 1;
      470       470    1        }
      471       471
      472       472
      473       473             static label auto_init_lbl = 0;
      474       474
      475       475
      476       476             code_declaration(idf, expr, lvl, sc)
      477       477              register struct idf *idf;  /* idf to be declared   */
      478       478              struct expr *expr;   /* initialisation; NULL if absent   */
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=14 
      479       479              int lvl;    /* declaration level */
      480       480              int sc;        /* storage class, as in the declaration */
      481       481             {
      482       482    1         /* code_declaration() does the actual declaration of the
      483       483    1            variable indicated by "idf" on declaration level "lvl".
      484       484    1            If the variable is initialised, the expression is given
      485       485    1            in "expr", but for global and static initialisations it
      486       486    1            is just non-zero, as the expression is not parsed yet.
      487       487    1            There are some cases to be considered:
      488       488    1            -  filter out typedefs, they don't correspond to code;
      489       489    1            -  global variables, coded only if initialized;
      490       490    1            -  local static variables;
      491       491    1            -  local automatic variables;
      492       492    1            Since the expression may be modified in the process,
      493       493    1            code_declaration() frees it after use, as the caller can
      494       494    1            no longer do so.
      495       495    1
      496       496    1            If there is a storage class indication (EXTERN/STATIC),
      497       497    1            code_declaration() will generate an exa or ina.
      498       498    1            The sc is the actual storage class, as given in the
      499       499    1            declaration.  This is to allow:
      500       500    1               extern int a;
      501       501    1               int a = 5;
      502       502    1            while at the same time forbidding
      503       503    1               extern int a = 5;
      504       504    1         */
      505       505    1         char *text = idf->id_text;
      506       506    1         register struct def *def = idf->id_def;
      507       507    1         register struct type *tp = def->df_type;
      508       508    1         register arith size = tp->tp_size;
      509       509    1         register int fund = tp->tp_fund;
      510       510    1         int def_sc = def->df_sc;
      511       511    1
      512       512    1         if (def_sc == TYPEDEF)  /* no code for typedefs    */
      513       513    1            return;
      514       514    1         if (expr  &&  def_sc == EXTERN  &&  lvl > L_GLOBAL)
      515       515    1            warning("initializing block scoped extern");
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=15 
      516       516    1         if (def_sc == EXTERN && !is_anon_idf(idf) && (expr || sc == 0)  )
      517       517    1            def->df_sc = sc = GLOBAL;
      518       518    1         if (sc == EXTERN && expr && !is_anon_idf(idf))
      519       519    1            error("%s is extern; cannot initialize", text);
      520       520    1         if (lvl == L_FORMAL2 && expr)
      521       521    1            error("%s is formal argument; cannot initialize", text);
      522       522    1         if (lvl == L_GLOBAL) {  /* global variable   */
      523       523    2            /* is this an allocating declaration? */
      524       524    2            if (  (sc == 0 || sc == STATIC || sc == GLOBAL)
      525       525    2               && fund != FUNCTION
      526       526    2               && size >= 0
      527       527    2            )
      528       528    2               def->df_alloc = ALLOC_SEEN;
      529       529    2            if (expr) { /* code only if initialized */
      530       530    3        #ifdef USE_TMP
      531       531    3               if (options['N'])
      532       532    3        #endif USE_TMP
      533       533    3               code_scope(text, def);
      534       534    3               def->df_alloc = ALLOC_DONE;
      535       535    3        #if DATAFIRST && defined(USE_TMP)
      536       536    3               if (!options['N']) EM_File_No = 1;
      537       537    3        #endif
      538       538    3               if (zb_target_sys == TARGET_CP6) {
      539       539    4                  int con = tp->tp_const && !tp->tp_volatile;
      540       540    4                  arith s;
      541       541    4                  align_sect_to_word( (con ? &constant_data : &static_data),con);
      542       542    4                  s = (con) ? constant_data : static_data;
      543       543    4                  s = align_data( s, tp->tp_align);
      544       544    4                  if (s)
      545       545    4                     if (con)
      546       546    4                           C_rom_ucon("0",(arith)s), constant_data += s;
      547       547    4                        else C_con_ucon("0", (arith)s), static_data += s;
      548       548    4               }
      549       549    3               C_df_dnam(text);
      550       550    3        #if DATAFIRST && defined(USE_TMP)
      551       551    3               EM_File_No = 0;
      552       552    3        #endif
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=16 
      553       553    3            }
      554       554    2         }
      555       555    1         else
      556       556    1         if (lvl >= L_LOCAL)  {  /* local variable */
      557       557    2            /* STATIC, EXTERN, GLOBAL, IMPLICIT, AUTO or REGISTER */
      558       558    2            switch (def_sc)   {
      559       559    3            case STATIC:
      560       560    3               if (def->df_type->tp_fund == FUNCTION) {
      561       561    4                  /* should produce "inp $function" ??? */
      562       562    4                  break;
      563       563    4               }
      564       564    3               /* they are handled on the spot and get an
      565       565    3                  integer label in EM.
      566       566    3               */
      567       567    3        #if DATAFIRST && defined(USE_TMP)
      568       568    3               if (!options['N']) EM_File_No = 1;
      569       569    3        #endif
      570       570    3               if (zb_target_sys == TARGET_CP6) {
      571       571    4                  int con = tp->tp_const && !tp->tp_volatile;
      572       572    4                  arith s;
      573       573    4                  align_sect_to_word( (con ? &constant_data : &static_data),con);
      574       574    4                  s = (con)? constant_data : static_data;
      575       575    4                  s = align_data(s,  tp->tp_align);
      576       576    4                  if (s)
      577       577    4                     if (con)
      578       578    4                           C_rom_ucon("0",(arith)s), constant_data += s;
      579       579    4                        else C_con_ucon("0", (arith)s), static_data += s;
      580       580    4               }
      581       581    3               static_data = ATW(static_data);
      582       582    3               C_df_dlb((label)def->df_address);
      583       583    3               if (expr) { /* there is an initialisation */
      584       584    4               }
      585       585    3               else {   /* produce blank space */
      586       586    4                  if (size <= 0) {
      587       587    5                     error("size of %s unknown", text);
      588       588    5                     size = (arith)0;
      589       589    5                  }
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=17 
      590       590    4                  if (zb_target_sys == TARGET_CP6)   {
      591       591    5                     initialize_to_zero(&def->df_type,(tp->tp_const && !tp->tp_volatil
                               e),0);
      592       592    5                     }
      593       593    4                  else {
      594       594    5                     C_bss_cst(ATW(size), (arith)0, 1);
      595       595    5                     static_data += ATW(size);
      596       596    5                  }
      597       597    4               }
      598       598    3        #if DATAFIRST && defined(USE_TMP)
      599       599    3               EM_File_No = 0;
      600       600    3        #endif
      601       601    3               break;
      602       602    3            case EXTERN:
      603       603    3            case GLOBAL:
      604       604    3            case IMPLICIT:
      605       605    3               /* we are sure there is no expression */
      606       606    3        #ifdef USE_TMP
      607       607    3               if (options['N'])
      608       608    3        #endif USE_TMP
      609       609    3               code_scope(text, def);
      610       610    3               break;
      611       611    3            case AUTO:
      612       612    3            case REGISTER:
      613       613    3               if (expr)  {
      614       614    4                  if (fund==STRUCT || fund==UNION || fund==ARRAY) {
      615       615    5                     arith s;
      616       616    5        #if DATAFIRST && defined(USE_TMP)
      617       617    5                     if (!options['N']) EM_File_No = 1;
      618       618    5        #endif
      619       619    5                     /* Bound constant section as required */
      620       620    5                     align_sect_to_word(&constant_data, 1);
      621       621    5                     s = align_data(constant_data, tp->tp_align);
      622       622    5                     if (s) C_rom_ucon("0",(arith)s), constant_data += s;
      623       623    5                     /* Define a label in constant         */
      624       624    5                     auto_init_lbl = data_label();
      625       625    5                     C_df_dlb(auto_init_lbl);
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=18 
      626       626    5        #if DATAFIRST && defined(USE_TMP)
      627       627    5                     EM_File_No = 0;
      628       628    5        #endif
      629       629    5                     }
      630       630    4                  else loc_init(expr, idf);
      631       631    4                  }
      632       632    3               break;
      633       633    3            default:
      634       634    3               crash("bad local storage class");
      635       635    3               break;
      636       636    3            }
      637       637    2         }
      638       638    1        }
      639       639
      640       640             loc_init(expr, id)
      641       641              struct expr *expr;
      642       642              register struct idf *id;
      643       643             {
      644       644    1         /* loc_init() generates code for the assignment of
      645       645    1            expression expr to the local variable described by id.
      646       646    1            It frees the expression afterwards.
      647       647    1         */
      648       648    1         register struct type *tp = id->id_def->df_type;
      649       649    1         register struct expr *e = expr;
      650       650    1
      651       651    1         ASSERT(id->id_def->df_sc != STATIC);
      652       652    1         if (e->ex_flags & EX_COMMA)
      653       653    1            warning("expression comma incorrect in initialization");
      654       654    1         switch (tp->tp_fund) {
      655       655    2         case ARRAY:
      656       656    2         case STRUCT:
      657       657    2         case UNION:
      658       658    2            error("no automatic aggregate initialisation");
      659       659    2            free_expression(e);
      660       660    2            return;
      661       661    2         }
      662       662    1         if (ISCOMMA(e))   {  /* embraced: int i = {12}; */
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=19 
      663       663    2        #ifndef NOROPTION
      664       664    2            if (options['R']) {
      665       665    3               if (ISCOMMA(e->OP_LEFT)) /* int i = {{1}} */
      666       666    3                  expr_error(e, "extra braces not allowed");
      667       667    3               else
      668       668    3               if (e->OP_RIGHT != 0) /* int i = {1 , 2} */
      669       669    3                  expr_error(e, "too many initializers");
      670       670    3            }
      671       671    2        #endif NOROPTION
      672       672    2            while (e)   {
      673       673    3               loc_init(e->OP_LEFT, id);
      674       674    3               e = e->OP_RIGHT;
      675       675    3            }
      676       676    2         }
      677       677    1         else  {  /* not embraced   */
      678       678    2            struct value vl;
      679       679    2
      680       680    2            ch7cast(&expr, '=', tp);   /* may modify expr */
      681       681    2            if (! options['L'])  { /* profiling */
      682       682    3               expr->ex_debline = C_ms_stmt(S_INITIALIZE, expr->ex_debline);
      683       683    3               C_lin((arith)(expr->ex_debline>=0) ? expr->ex_debline : -expr->ex_debli
                               ne);
      684       684    3               }
      685       685    2            EVAL(expr, RVAL, TRUE, NO_LABEL, NO_LABEL);
      686       686    2            free_expression(expr);
      687       687    2            vl.vl_class = Name;
      688       688    2            vl.vl_data.vl_idf = id;
      689       689    2            vl.vl_value = (arith)0;
      690       690    2            store_val(&vl, tp);
      691       691    2         }
      692       692    1        }
      693       693
      694       694
      695       695             init_auto_aggregate(id, must_init)
      696       696               register struct idf *id;
      697       697             {
      698       698    1          register struct def  *df = id->id_def;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=20 
      699       699    1          register struct type *tp = df->df_type;
      700       700    1          register int          fund = tp->tp_fund;
      701       701    1          register arith        sz = tp->tp_size;
      702       702    1
      703       703    1          if (must_init) {
      704       704    2             if (tp->tp_size != (arith)-1) {
      705       705    3                struct stack_level *stl = stack_level_of(df->df_level);
      706       706    3                df->df_address = stl->sl_local_offset =
      707       707    3                   -align(-stl->sl_local_offset + tp->tp_size, tp->tp_align);
      708       708    3                if (stl->sl_local_offset < stl->sl_max_block)
      709       709    3                   stl->sl_max_block = stl->sl_local_offset;
      710       710    3                }
      711       711    2             else error("size of local %s is unknown", id->id_text);
      712       712    2             }
      713       713    1          if (auto_init_lbl && (fund==STRUCT || fund==UNION || fund==ARRAY)) {
      714       714    2             C_ina_dlb(auto_init_lbl);
      715       715    2             C_lae_dlb(auto_init_lbl, (arith)0);
      716       716    2             C_loi(sz);
      717       717    2             C_lal(df->df_address);
      718       718    2             C_sti(sz);
      719       719    2             }
      720       720    1          auto_init_lbl = 0;
      721       721    1        }
      722       722
      723       723
      724       724             bss(idf)
      725       725              register struct idf *idf;
      726       726             {
      727       727    1         /* bss() allocates bss space for the global idf.
      728       728    1         */
      729       729    1         arith size = idf->id_def->df_type->tp_size;
      730       730    1
      731       731    1        #ifdef USE_TMP
      732       732    1         if (options['N'])
      733       733    1        #endif USE_TMP
      734       734    1         code_scope(idf->id_text, idf->id_def);
      735       735    1         /* Since bss() is only called if df_alloc is non-zero, and
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=21 
      736       736    1            since df_alloc is only non-zero if size >= 0, we have:
      737       737    1         */
      738       738    1         /* but we already gave a warning at the declaration of the
      739       739    1            array. Besides, the message given here does not apply to
      740       740    1            voids
      741       741    1
      742       742    1         if (options['R'] && size == 0)
      743       743    1            warning("actual array of size 0");
      744       744    1         */
      745       745    1        #if DATAFIRST && defined(USE_TMP)
      746       746    1            if (!options['N']) EM_File_No = 1;
      747       747    1        #endif
      748       748    1            if (idf->id_def->df_sc != EXTERN || zb_target_sys != TARGET_CP6)
      749       749    1            {
      750       750    2               struct type *tp = idf->id_def->df_type;
      751       751    2               int con = tp->tp_const && !tp->tp_volatile;
      752       752    2               int sz = con ? constant_data : static_data;
      753       753    2               arith s = align_data(sz, tp->tp_align);
      754       754    2               align_sect_to_word(&sz, con);
      755       755    2               if (s)  {
      756       756    3                  if (con) C_rom_ucon("0",(arith)s);
      757       757    3                     else C_con_ucon("0",(arith)s);
      758       758    3                  sz += s;
      759       759    3               }
      760       760    2               sz = ATW(sz);
      761       761    2               C_df_dnam(idf->id_text);
      762       762    2               if (zb_target_sys == TARGET_CP6) {
      763       763    3                  if (con) constant_data = sz;
      764       764    3                     else static_data = sz;
      765       765    3                  initialize_to_zero(&tp, con, 0);
      766       766    3                  }
      767       767    2               else {
      768       768    3                  C_bss_cst(ATW(size), (arith)0, 1);
      769       769    3                  sz += ATW(size);
      770       770    3                  if (con) constant_data = sz;
      771       771    3                     else static_data = sz;
      772       772    3                  }
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=22 
      773       773    2            }
      774       774    1        #if DATAFIRST && defined(USE_TMP)
      775       775    1            EM_File_No = 0;
      776       776    1        #endif
      777       777    1        }
      778       778
      779       779             formal_cvt(df)
      780       780              register struct def *df;
      781       781             {
      782       782    1         /* formal_cvt() converts a formal parameter of type char or
      783       783    1            short from int to that type.
      784       784    1         */
      785       785    1         register struct type *tp = df->df_type;
      786       786    1
      787       787    1         if (tp->tp_size != int_size &&
      788       788    1            (tp->tp_fund == CHAR || tp->tp_fund == SHORT)
      789       789    1         ) {
      790       790    2            C_lol(df->df_address);
      791       791    2            /* conversion(int_type, df->df_type); ???
      792       792    2               No, you can't do this on the stack! (CJ)
      793       793    2            */
      794       794    2            C_lal(df->df_address);
      795       795    2            C_sti(tp->tp_size);
      796       796    2            df->df_register = REG_NONE;
      797       797    2         }
      798       798    1        }
      799       799
      800       800             code_expr(expr, val, code, tlbl, flbl)
      801       801              struct expr *expr;
      802       802              label tlbl, flbl;
      803       803             {
      804       804    1         /* code_expr() is the parser's interface to the expression code
      805       805    1            generator.  If line number trace is wanted, it generates a
      806       806    1            lin instruction.  EVAL() is called directly.
      807       807    1         */
      808       808    1         if (! options['L'])  /* profiling   */
      809       809    1            C_lin((arith)(expr->ex_debline>=0) ? expr->ex_debline : -expr->ex_debline)
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=23 
                               ;
      810       810    1            finfo.ExprLines++;
      811       811    1         EVAL(expr, val, code, tlbl, flbl);
      812       812    1        }
      813       813
      814       814             /*  The FOR/WHILE/DO/SWITCH stacking mechanism:
      815       815              stack_stmt() has to be called at the entrance of a
      816       816              for, while, do or switch statement to indicate the
      817       817              EM labels where a subsequent break or continue causes
      818       818              the program to jump to.
      819       819             */
      820       820             static struct stmt_block *stmt_stack;   /* top of statement stack */
      821       821
      822       822             /*  code_break() generates EM code needed at the occurrence of "break":
      823       823              it generates a branch instruction to the break label of the
      824       824              innermost statement in which break has a meaning.
      825       825              As "break" is legal in any of 'while', 'do', 'for' or 'switch',
      826       826              which are the only ones that are stacked, only the top of
      827       827              the stack is interesting.
      828       828             */
      829       829             code_break()
      830       830             {
      831       831    1         register struct stmt_block *stmt_block = stmt_stack;
      832       832    1
      833       833    1         if (stmt_block)
      834       834    1            C_bra(stmt_block->st_break);
      835       835    1         else
      836       836    1            error("break not inside for, while, do or switch");
      837       837    1        }
      838       838
      839       839             /*  code_continue() generates EM code needed at the occurrence of
      840       840              "continue":
      841       841              it generates a branch instruction to the continue label of the
      842       842              innermost statement in which continue has a meaning.
      843       843             */
      844       844             code_continue()
      845       845             {
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=24 
      846       846    1         register struct stmt_block *stmt_block = stmt_stack;
      847       847    1
      848       848    1         while (stmt_block)   {
      849       849    2            if (stmt_block->st_continue)  {
      850       850    3               C_bra(stmt_block->st_continue);
      851       851    3               return;
      852       852    3            }
      853       853    2            stmt_block = stmt_block->next;
      854       854    2         }
      855       855    1         error("continue not inside for, while or do");
      856       856    1        }
      857       857
      858       858             stack_stmt(break_label, cont_label)
      859       859              label break_label, cont_label;
      860       860             {
      861       861    1         register struct stmt_block *stmt_block = new_stmt_block();
      862       862    1
      863       863    1         stmt_block->next = stmt_stack;
      864       864    1         stmt_block->st_break = break_label;
      865       865    1         stmt_block->st_continue = cont_label;
      866       866    1         stmt_stack = stmt_block;
      867       867    1        }
      868       868
      869       869             unstack_stmt()
      870       870             {
      871       871    1         /* unstack_stmt() unstacks the data of a statement
      872       872    1            which may contain break or continue
      873       873    1         */
      874       874    1         register struct stmt_block *sbp = stmt_stack;
      875       875    1         stmt_stack = sbp->next;
      876       876    1         free_stmt_block(sbp);
      877       877    1        }
      878       878
      879       879             static label l1;
      880       880
      881       881             prc_entry(name)
      882       882              char *name;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=25 
      883       883             {
      884       884    1         int fnlen = strlen(name) + 1;
      885       885    1         if (options['p']) {
      886       886    2        #if DATAFIRST && defined(USE_TMP)
      887       887    2            if (!options['N']) EM_File_No = 1;
      888       888    2        #endif
      889       889    2            constant_data = ATW(constant_data);
      890       890    2            C_df_dlb(l1 = data_label());
      891       891    2            str_cst(name, (arith) fnlen, 1, 1);
      892       892    2            constant_data += ATW( fnlen );
      893       893    2        #if DATAFIRST && defined(USE_TMP)
      894       894    2            EM_File_No = 0;
      895       895    2        #endif
      896       896    2            C_lae_dlb(l1, (arith) 0);
      897       897    2            C_cal("procentry");
      898       898    2            C_asp(pointer_size);
      899       899    2         }
      900       900    1        }
      901       901
      902       902             prc_exit()
      903       903             {
      904       904    1         if (options['p']) {
      905       905    2            C_lae_dlb(l1, (arith) 0);
      906       906    2            C_cal("procexit");
      907       907    2            C_asp(pointer_size);
      908       908    2         }
      909       909    1        }
      910       910
      911       911             prepend_csect_info()   {
      912       912    1
      913       913    1        register struct stack_entry *se  = local_level->sl_entry;
      914       914    1        register struct stack_entry *ses = (struct stack_entry *)0;
      915       915    1        register struct idf         *idf = (struct idf *)0;
      916       916    1        register struct idf         *idv = (struct idf *)0;
      917       917    1
      918       918    1          while (se)  {
      919       919    2             register struct idf *id = se->se_idf;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=26 
      920       920    2             register struct def *df = id->id_def;
      921       921    2
      922       922    2             if (df)  {
      923       923    3                int fund = df->df_type->tp_fund;
      924       924    3                int sc   = df->df_sc;
      925       925    3
      926       926    3                if (df->df_initialized && fund == FUNCTION)  {
      927       927    4                   if (sc == STATIC) {
      928       928    5                      if (ses == (struct stack_entry*)0) ses = se;
      929       929    5                   }
      930       930    4                   else  idf = id;
      931       931    4                }
      932       932    3                else
      933       933    3                if (fund != FUNCTION && sc == GLOBAL)
      934       934    3                   idv = id;
      935       935    3             }
      936       936    2             se = se->next;
      937       937    2          }
      938       938    1
      939       939    1          if (!idf) idf = idv;
      940       940    1          if (!idf) error("No Globals defined in this file!");
      941       941    1            else C_ms_ctln(idf->id_text);
      942       942    1
      943       943    1          if (se = ses) {
      944       944    2             int   code = 0;
      945       945    2             while (se)  {
      946       946    3                register struct idf *id = se->se_idf;
      947       947    3                register struct def *df = id->id_def;
      948       948    3
      949       949    3                if (df)  {
      950       950    4                   int fund = df->df_type->tp_fund;
      951       951    4                   int sc   = df->df_sc;
      952       952    4
      953       953    4                   if (df->df_initialized && fund==FUNCTION && sc==STATIC)
      954       954    4                      code = C_ms_sfun(id->id_text,code);
      955       955    4                }
      956       956    3                se = se->next;
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=27 
      957       957    3             }
      958       958    2             if (code != 0)
      959       959    2                C_ms_sfun("",2);
      960       960    2          }
      961       961    1        }
      962       962
      963       963             /*  Function to bound out either static or constant control
      964       964                 section to an even number of words.
      965       965             **/
      966       966
      967       967             align_sect_to_word(sz, con)
      968       968               int *sz;    /*  Pointer to size of section  */
      969       969               int con;    /*  0=static, 1=read only       */
      970       970             {
      971       971    1          int (*f)() = (con) ? C_rom_ucon : C_con_ucon;
      972       972    1          int amt    = (*sz) & 3;
      973       973    1
      974       974    1          switch   (amt)   {
      975       975    2          case 1:  f("0",(arith)1);
      976       976    2          case 2:  f("0",(arith)1);
      977       977    2          case 3:  f("0",(arith)1);
      978       978    2                   *sz += 4 - amt;
      979       979    2          }
      980       980    1        }
      981       981
---  Include file information  ---

   em:h.:ZBC3TOU. is referenced
   em_arith:h.:ZBC3TOU. is referenced
   em_label:h.:ZBC3TOU. is referenced
   em_code:h.:ZBC3TOU. is referenced
   zbc$botch_free:h.:ZBC3TOU. is referenced
   alloc:h.:ZBC3TOU. is referenced
   zbc$nofloat:h.:ZBC3TOU. is referenced
   zbc$dataflow:h.:ZBC3TOU. is referenced
   zbc$use_tmp:h.:ZBC3TOU. is referenced
   zbc$arith:h.:ZBC3TOU. is referenced
CC.C03    File=zbc$code:c.:ZBC3TSI                                                  Fri Aug 22 1997  Page=28 
   zbc$spec_arith:h.:ZBC3TOU. is referenced
   zbc$type:h.:ZBC3TOU. is referenced
   zbc$nobitfield:h.:ZBC3TOU. is referenced
   zbc$idf:h.:ZBC3TOU. is referenced
   zbc$nopp:h.:ZBC3TOU. is referenced
   zbc$label:h.:ZBC3TOU. is referenced
   zbc$code:h.:ZBC3TOU. is referenced
   zbc$stmt:h.:ZBC3TOU. is referenced
   zbc$def:h.:ZBC3TOU. is referenced
   zbc$expr:h.:ZBC3TOU. is referenced
   zbc$sizes:h.:ZBC3TOU. is referenced
   zbc$nocross:h.:ZBC3TOU. is referenced
   zbc$target_sizes:h.:ZBC3TOU. is referenced
   zbc$stack:h.:ZBC3TOU. is referenced
   zbc$level:h.:ZBC3TOU. is referenced
   zbc$decspecs:h.:ZBC3TOU. is referenced
   zbc$declar:h.:ZBC3TOU. is referenced
   zbc$Lpars:h.:ZBC3TOU. is referenced
   zbc$mes:h.:ZBC3TOU. is referenced
   zbc$LLlex:h.:ZBC3TOU. is referenced
   zbc$file_info:h.:ZBC3TOU. is referenced
   zbc$specials:h.:ZBC3TOU. is referenced
   zbc$atw:h.:ZBC3TOU. is referenced
   zbc$assert:h.:ZBC3TOU. is referenced
   zbc$debug:h.:ZBC3TOU. is referenced
   zbc$align:h.:ZBC3TOU. is referenced
   zbc$noRoption:h.:ZBC3TOU. is referenced
   zb_cp6_object:h.:ZBC3TOU. is referenced
   zbc$zb_target:h.:ZBC3TOU. is referenced
   zbc$dataFirst:h.:ZBC3TOU. is referenced
   zbc$struct:h.:ZBC3TOU. is referenced

No diagnostics were issued in the file zbc$code:c.:ZBC3TSI
