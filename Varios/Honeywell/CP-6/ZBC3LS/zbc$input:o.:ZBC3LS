

CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=1  
        1         1             /*
        2         2              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3         3              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4         4              */
        5         5             /* $Header: input.c,v 3.13 87/03/27 16:39:03 ceriel Exp $ */
        6         6
        7         7             #include "inputtype:h"
        8         8             #include "file_info:h"
        9         9             #include "input:h"
       10        10             #define INP_TYPE   struct file_info
       11        11             #define INP_VAR    finfo
       12        12             struct file_info   finfo = {0, 0, 0};
       13        13             long DebugLineBias = 1;
       14        14             #define DEBUG_NUM DebugLineBias
       15        15             int NewLineBias = 1;
       16        16             int VeryLastCharIsBackSlash = 0;
       17        17             #include "nopp:h"
       18        18             #pragma LIST INCLUDE_ON
       19        19             #include <inp_package:c>
        1+       20             /*M*        zb_input$inp_package:c     */
        2+       21             /*T*/
        3+       22             /*P*        NAME:       zb_input$inp_package:c
        4+       23                         PURPOSE:    This routine feeds a character stream to the user
        5+       24                         DESCRIPTION:These routines serve as an interface to input
        6+       25                                     characters from an input stream.  It allows
        7+       26                                     the user to choose how the input should be
        8+       27                                     read from files or text and it gives the
        9+       28                                     data to the user one character at a time.
       10+       29             */
       11+       30             #include    <alloc:h>
        1+       31             /* $Header: alloc.h,v 1.3 87/03/10 09:05:21 ceriel Exp $ */
        2+       32             /*
        3+       33              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        4+       34              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        5+       35              */
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=2  
        6+       36             /*  PROGRAM'S INTERFACE TO MEMORY ALLOCATION ROUTINES     */
        7+       37
        8+       38             /*  This file serves as the interface between the program and the
        9+       39              memory allocating routines.
       10+       40              There are 3 memory allocation routines:
       11+       41                 char *Malloc(n)      allocate n bytes
       12+       42                 char *Salloc(str, n) allocate n bytes and fill them with
       13+       43                          string str
       14+       44                 char *Realloc(str, n)   reallocate the string at str to n bytes,
       15+       45                          only works if str was last allocated
       16+       46             */
       17+       47
       18+       48             extern char *Salloc(), *Malloc(), *Srealloc();
       19+       49             extern char *malloc(), *realloc();
       20+       50
       21+       51             /*  S T R U C T U R E - S T O R A G E  D E F I N I T I O N S */
       22+       52
       23+       53             #ifndef   BOTCH_FREE
       24+       54             #define   st_free(ptr, phead, size)  (ptr->next = *phead, *phead = ptr)
       25+       55             #else  def BOTCH_FREE
       26+       56   *S*       #define   st_free(ptr, phead, size)  (botch((char *)(ptr), size), \
       27+       56   *S*                       ptr->next = *phead, *phead = ptr)
       28+       58   *S*       #endif BOTCH_FREE
       29+       59
       12+       60             #include    <valloc:h>
        1+       61             /*T***********************************************************/
        2+       62             /*T*                                                         */
        3+       63             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
        4+       64             /*T*                                                         */
        5+       65             /*T***********************************************************/
        6+       66             /*      valloc.h
        7+       67
        8+       68                     Definitions for Virtual memory allocation routines.
        9+       69
       10+       70                     WGE Jul 18, 1989
       11+       71             */
       12+       72             #ifndef __valloc
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=3  
       13+       73             #define __valloc
       14+       74
       15+       75             #ifndef __size_t
       16+       76             #define __size_t
       17+       77             typedef unsigned size_t;
       18+       78             #endif
       19+       79
       20+       80             extern  void   *vcalloc ( size_t, size_t );
       21+       81             extern  void    vfree   ( void *);
       22+       82             extern  void    vmemscrub (void );
       23+       83             extern  int     vmeminit ( size_t, int, size_t );
       24+       84             extern  void   *vmalloc ( size_t );
       25+       85             extern  void   *vrealloc (void *, size_t );
       26+       86             #endif
       13+       87             #include    <system:h>
        1+       88             /*
        2+       89              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3+       90              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4+       91              */
        5+       92             /* RCS: $Header: system.h,v 1.2 87/03/09 15:06:01 ceriel Exp $ */
        6+       93
        7+       94             struct _sys_fildes {
        8+       95    1         int o_fd;   /* CP-6 DCB number */
        9+       96    1         int o_flags;   /* flags for open; 0 if not used */
       10+       97    1         int f_blknum; /*  current block #  */
       11+       98    1         unsigned f_blkpos : 18;  /**  Current block number     **/
       12+       99    1         unsigned f_blklen : 18;  /**  Length of current block  **/
       13+      100    1         int f_blklast; /*  Number of blocks/records in file */
       14+      101    1         unsigned          : 18;
       15+      102    1         unsigned f_lblklen: 18;  /**  Length of last block     **/
       16+      103    1         char *f_blk; /*  Current block  */
       17+      104    1         char *fp;  /* pointer to actual C library file pointer */
       18+      105    1        };
       19+      106
       20+      107             typedef struct _sys_fildes File;
       21+      108
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=4  
       22+      109             extern File Z_SYS_FTAB[];
       23+      110
       24+      111             /* flags for sys_open() */
       25+      112             #define OP_READ    001
       26+      113             #define OP_WRITE   002
       27+      114             #define OP_APPEND  004
       28+      115             #define OP_BIN     010
       29+      116
       30+      117             #define OP_STRPVFC 0400
       31+      118             /*  dvbyte values:     */
       32+      119             #define OP_BP      0200000
       33+      120             #define OP_VFC     0100000
       34+      121             #define OP_BINIO   0040000
       35+      122             #define OP_TRANS   0020000
       36+      123             /*  organization:      */
       37+      124             #define OP_CONSEC  001000000000
       38+      125             #define OP_KEYED   002000000000
       39+      126             #define OP_UR      004000000000
       40+      127             #define OP_TERM    010000000000
       41+      128             #define OP_X364    030000000000
       42+      129
       43+      130             /* flags for sys_access() */
       44+      131             #define AC_EXIST   00
       45+      132             #define AC_READ    04
       46+      133             #define AC_WRITE   02
       47+      134             #define AC_EXEC    01
       48+      135
       49+      136             /* flags for sys_stop() */
       50+      137             #define S_END   0
       51+      138             #define S_EXIT  1
       52+      139             #define S_ABORT 2
       53+      140
       54+      141             /* standard file decsriptors */
       55+      142             #define STDIN   &Z_SYS_FTAB[0]
       56+      143             #define STDOUT  &Z_SYS_FTAB[1]
       57+      144             #define STDERR  &Z_SYS_FTAB[2]
       58+      145
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=5  
       59+      146             /* maximum number of open files */
       60+      147             #define SYS_NOPEN  20
       61+      148
       62+      149             /* return value for sys_break */
       63+      150             #define ILL_BREAK  ((char *)0)
       64+      151
       65+      152             /* system's idea of block */
       66+      153             #define BUFSIZ  1024
       67+      154
       68+      155             #define sys_open Z_SYS_OPEN
       69+      156             #define sys_close Z_SYS_CLOSE
       70+      157             #define sys_fseek Z_SYS_FSEEK
       71+      158             #define sys_fsize Z_SYS_FSIZE
       72+      159             #define sys_ftell Z_SYS_FTELL
       73+      160             #define sys_fileinfo Z_SYS_FILEINFO
       74+      161             #define sys_heading  Z_SYS_HEADING
       75+      162
       76+      163             /*   File Information  */
       77+      164
       78+      165             struct file_asn_file   {
       79+      166    1          int   ixtnsize;
       80+      167    1          int   nrecs;
       81+      168    1          int   ctg      :  9;
       82+      169    1          int   disp     :  9;
       83+      170    1          int   share    :  9;
       84+      171    1        };
       85+      172
       86+      173
       87+      174             struct file_asn_tape   {
       88+      175    1          int   blkl;
       89+      176    1          int   vol;
       90+      177    1          int   fsn      :  9;
       91+      178    1          int   density  :  9;
       92+      179    1          int   blocked  :  9;
       93+      180    1          int   cvol     :  9;
       94+      181    1          int   ebcdic   :  9;
       95+      182    1          int   cnvrt    :  9;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=6  
       96+      183    1          int   spanned  :  9;
       97+      184    1        };
       98+      185
       99+      186             struct file_asn_uc     {
      100+      187    1          int   wlen     :  9;
      101+      188    1          int   wwid     :  9;
      102+      189    1          int   minl     :  9;
      103+      190    1          int   minw     :  9;
      104+      191    1          int   winline  :  9;
      105+      192    1          int   wincol   :  9;
      106+      193    1        };
      107+      194
      108+      195             struct file_asn_comgroup  {
      109+      196    1          char  mystation[8];
      110+      197    1          char  istation[8];
      111+      198    1          char  ostation[8];
      112+      199    1          char  imsgtyp[8];
      113+      200    1          char  omsgtyp[8];
      114+      201    1          int   alldcbs  :  9;
      115+      202    1          int   alltrms  :  9;
      116+      203    1          int   anydcb   :  9;
      117+      204    1          int   dironly  :  9;
      118+      205    1          int   ilatch   :  9;
      119+      206    1          int   ilock    :  9;
      120+      207    1          int   olatch   :  9;
      121+      208    1          int   olock    :  9;
      122+      209    1          int   eofnone  :  9;
      123+      210    1          int   eofone   :  9;
      124+      211    1          int   au       :  9;
      125+      212    1          int   qiss     :  9;
      126+      213    1        };
      127+      214
      128+      215             struct file_org_ur  {
      129+      216    1          int   page;
      130+      217    1          char  *title;
      131+      218    1          char  form[8];
      132+      219    1          int   dvfc     :  9;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=7  
      133+      220    1          int   hdrh     :  9;
      134+      221    1          int   indent   :  9;
      135+      222    1          int   width    :  9;
      136+      223    1          int   margin   :  9;
      137+      224    1          int   lines    :  9;
      138+      225    1        };
      139+      226
      140+      227             struct file_org_indexed   {
      141+      228    1          int   keyx;
      142+      229    1          int   keyl;
      143+      230    1          int   load     :  9;
      144+      231    1        };
      145+      232
      146+      233             struct file_org_relative  {
      147+      234    1          int   nrecs;
      148+      235    1        };
      149+      236
      150+      237             struct file_org_random    {
      151+      238    1          int   ixtnsize;
      152+      239    1        };
      153+      240
      154+      241             struct file_org_fprg      {
      155+      242    1          char  profile[32];
      156+      243    1          char  fprg[44];
      157+      244    1        };
      158+      245
      159+      246             struct file_org_se        {
      160+      247    1          int   nrecs;
      161+      248    1          int   spare;
      162+      249    1        };
      163+      250
      164+      251             /**  Now for the argument to the function sys_fileinfo();  */
      165+      252
      166+      253             typedef struct  file_set {
      167+      254    1          int   fun;
      168+      255    1          int   acs;
      169+      256    1          int   org;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=8  
      170+      257    1          int   asn;
      171+      258    1          char  fid[72];
      172+      259    1          union {
      173+      260    2             struct file_org_ur         ur;
      174+      261    2             struct file_org_indexed    indexed;
      175+      262    2             struct file_org_random     random;
      176+      263    2             struct file_org_fprg       fprg;
      177+      264    2             struct file_org_se         se;
      178+      265    2          } file_org;
      179+      266    1          union {
      180+      267    2             struct file_asn_file       file;
      181+      268    2             struct file_asn_tape       tape;
      182+      269    2             struct file_asn_uc         uc;
      183+      270    2             struct file_asn_comgroup   comgroup;
      184+      271    2          } file_asn;
      185+      272    1        } File_Set;
      186+      273
      187+      274
       14+      275             #include    <inp_types:h>
        1+      276             /*M*     zb_input$inp_types:h */
        2+      277             /*T*/
        3+      278             /*B*
        4+      279                   NAME:    zb_files
        5+      280                   PURPOSE: This structure contains the entire interface to
        6+      281                            the ZB_INPUT$ routines. This structure must match
        7+      282                            the equivalent PL6 routine: ZB_INPUT$TYPES:PL6
        8+      283                   DESCRIPTION:
        9+      284                      char *buffer   - Points at a buffer that is to receive
       10+      285                                       a record of data from ZB_INPUT_READ
       11+      286                      int BUFSIZE    - The size of the buffer that BUFFER$
       12+      287                                       points at
       13+      288                      int NBYTES     - Number of bytes read by ZB_INPUT_READ
       14+      289                      int FILETYPE   - The type of file to open, read, or close
       15+      290                                        =1 Base file
       16+      291                                        =2 Update file
       17+      292                                        =3 Include file
       18+      293                      char *filename - A pointer to the name of the file to
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=9  
       19+      294                                       be opened
       20+      295                      int open_flag  - Is the file open
       21+      296                                        =0 No the file is not open
       22+      297                                        =1 Yes the file is open
       23+      298                      int level      - The nested level of the include files
       24+      299                      int optui      - Is the UI file optional
       25+      300                      int list_update-  List updates at beginning of LS file??
       26+      301                      char *key      - Pointer to the text of the key that was read in
       27+      302             */
       28+      303
       29+      304             #define  IN_TEXT     0
       30+      305             #define  IN_BASE     1
       31+      306             #define  IN_UPDATE   2
       32+      307             #define  IN_INCLUDE  3
       33+      308
       34+      309             struct      zb_files {
       35+      310    1                       char     *buffer;       /* contains the text read */
       36+      311    1                       int      bufsize;       /* Size of buffer         */
       37+      312    1                       int      nbytes;        /* Number of bytes read   */
       38+      313    1                       int      filetype;      /* Type of file read from */
       39+      314    1                       char     *filename;     /* Name of file           */
       40+      315    1                       int      open_flag;     /* Is the file open       */
       41+      316    1                       int      level;         /* Level of include depth */
       42+      317    1                       int      optui;         /* Is UI file optional */
       43+      318    1                       int      list_update;   /* List updates??      */
       44+      319    1                       char     *key;          /*    contains key text   */
       45+      320    1                    };
       46+      321             extern   int   zb_LS_flag;
       47+      322             extern   int   zb_LS_include_flag;
       15+      323             #include    <errno:h>
        1+      324             /*T***********************************************************/
        2+      325             /*T*                                                         */
        3+      326             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
        4+      327             /*T*                                                         */
        5+      328             /*T***********************************************************/
        6+      329             #ifndef __errno
        7+      330             #define __errno
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=10 
        8+      331
        9+      332             extern int errno;
       10+      333
       11+      334             #define EDOM 25805718999
       12+      335             #define ERANGE 25805719007
       13+      336
       14+      337             #define EMFILE   3332047682
       15+      338             #define ENFILE   3332047682
       16+      339
       17+      340
       18+      341             #endif
       16+      342             #include    <string:h>
        1+      343             /*T***********************************************************/
        2+      344             /*T*                                                         */
        3+      345             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
        4+      346             /*T*                                                         */
        5+      347             /*T***********************************************************/
        6+      348             /*     string.h
        7+      349
        8+      350                    Definitions for string functions.
        9+      351
       10+      352             */
       11+      353             #ifndef __string
       12+      354             #define __string
       13+      355
       14+      356             #ifndef NULL
       15+      357             #ifdef __STDC__
       16+      358             #define NULL (void *)0
       17+      359             #else
       18+      360   *S*       #define NULL (char *)0
       19+      361   *S*       #endif
       20+      362             #endif
       21+      363
       22+      364             #ifndef __size_t
       23+      365   *S*       #define __size_t
       24+      366   *S*       typedef unsigned size_t;
       25+      367   *S*       #endif
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=11 
       26+      368
       27+      369             extern void     *memcpy     ( void *, const void *, size_t );
       28+      370             extern void     *memmove    ( void *, const void *, size_t );
       29+      371             extern char     *strcpy     ( char *, const char * );
       30+      372             extern char     *strncpy    ( char *, const char *, size_t );
       31+      373             extern char     *strcat     ( char *, const char * );
       32+      374             extern char     *strncat    ( char *, const char *, size_t );
       33+      375             extern int      memcmp      ( const void *, const void *, size_t );
       34+      376             extern int      strcmp      ( const char *, const char * );
       35+      377             extern int      strcoll     ( const char *, const char * );
       36+      378             extern int      strncmp     ( const char *, const char *, size_t );
       37+      379             extern size_t   strxfrm     ( char *, const char *, size_t );
       38+      380             extern void     *memchr     ( const void *, int, size_t );
       39+      381             extern char     *strchr     ( const char *, int );
       40+      382             extern size_t   strcspn     ( const char *, const char * );
       41+      383             extern char     *strpbrk    ( const char *, const char * );
       42+      384             extern char     *strrchr    ( const char *, int );
       43+      385             extern size_t   strspn      ( const char *, const char * );
       44+      386             extern char     *strstr     ( const char *, const char * );
       45+      387             extern char     *strtok     ( char *, const char * );
       46+      388             extern void     *memset     ( void *, int, size_t );
       47+      389             extern char     *strerror   ( int );
       48+      390             extern size_t   strlen      ( const char * );
       49+      391             extern char     *memccpy    ( char *, char *, int, int);
       50+      392
       51+      393             void  *__builtin_memcpy(void *,  void *, int);
       52+      394             void  *__builtin_memchr(void *,     int, int);
       53+      395             int    __builtin_memcmp(void *,  void *, int);
       54+      396             void  *__builtin_memset(void *,     int, int);
       55+      397             void  *__builtin_memmove(void *, void *, int);
       56+      398             void  *__builtin_memrchr(void *,    int, int);
       57+      399
       58+      400             int    __builtin_strlen(const char *);
       59+      401             char  *__builtin_strcpy(      char *, const char *);
       60+      402             char  *__builtin_strcat(      char *, const char *);
       61+      403             int    __builtin_strcmp(const char *, const char *);
       62+      404             char  *__builtin_strchr(const char *, int);
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=12 
       63+      405             char  *__builtin_strrchr(const char *, int);
       64+      406
       65+      407
       66+      408             #define memcpy(a,b,c)   __builtin_memcpy(a,b,c)
       67+      409             #define memchr(a,b,c)   __builtin_memchr(a,b,c)
       68+      410             #define memcmp(a,b,c)   __builtin_memcmp(a,b,c)
       69+      411             #define memset(a,b,c)   __builtin_memset(a,b,c)
       70+      412             #define memmove(a,b,c)  __builtin_memmove(a,b,c)
       71+      413             #define memrchr(a,b,c)  __builtin_memrchr(a,b,c)
       72+      414
       73+      415             #define strlen(a)     __builtin_strlen(a)
       74+      416             #define strcpy(a,b)   __builtin_strcpy(a,b)
       75+      417             #define strcat(a,b)   __builtin_strcat(a,b)
       76+      418             #define strcmp(a,b)   __builtin_strcmp(a,b)
       77+      419             #define strchr(a,b)   __builtin_strchr(a,b)
       78+      420             #define strrchr(a,b)  __builtin_strrchr(a,b)
       79+      421             #endif
       17+      422             #include    <ctype.h>
        1+      423             /*T***********************************************************/
        2+      424             /*T*                                                         */
        3+      425             /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
        4+      426             /*T*                                                         */
        5+      427             /*T***********************************************************/
        6+      428             #ifndef __ctype
        7+      429
        8+      430             #define __ctype
        9+      431
       10+      432             extern int isalnum( int );
       11+      433             extern int isalpha( int );
       12+      434             extern int isascii( int );
       13+      435             extern int iscntrl( int );
       14+      436             extern int isdigit( int );
       15+      437             extern int isgraph( int );
       16+      438             extern int islower( int );
       17+      439             extern int isprint( int );
       18+      440             extern int ispunct( int );
       19+      441             extern int isspace( int );
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=13 
       20+      442             extern int isupper( int );
       21+      443             extern int isxdigit( int );
       22+      444             extern int tolower( int );
       23+      445             extern int toupper( int );
       24+      446
       25+      447             #endif
       18+      448
       19+      449             #ifndef     INP_NPUSHBACK
       20+      450             #define     INP_NPUSHBACK     2
       21+      451             #endif
       22+      452
       23+      453             #ifndef     DEBUG_NUM
       24+      454   *S*       int   debug_num = 1;
       25+      455   *S*       #define     DEBUG_NUM   debug_num++
       26+      456   *S*       #endif
       27+      457
       28+      458             #if         INP_NPUSHBACK <   1
       29+      459   *S*       #define     INP_NPUSHBACK     1
       30+      460   *S*       #endif
       31+      461
       32+      462             #ifndef     INP_BUFSIZE
       33+      463             #define     INP_BUFSIZE       BUFSIZ
       34+      464             #endif
       35+      465
       36+      466             #if         INP_NPUSHBACK >   INP_BUFSIZE/2
       37+      467   *S*       this is ridiculous!  You deserve what you get!!
       38+      468   *S*       #endif
       39+      469
       40+      470             #ifdef      INP_TYPE
       41+      471             extern      INP_TYPE          INP_VAR;
       42+      472             #endif
       43+      473
       44+      474             #define     PRIVATE
       45+      475
       46+      476             struct      buffer_header {
       47+      477    1                       struct buffer_header    *next;
       48+      478    1                       int                     bh_size;   /* buf size    */
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=14 
       49+      479    1                       char                    *bh_text;  /* ptr to text */
       50+      480    1                       char                    *bh_ipp;   /* stacked ipp */
       51+      481    1        #ifdef      INP_TYPE
       52+      482    1                       INP_TYPE                bh_i;      /* user defined*/
       53+      483    1        #endif
       54+      484    1                       int                     bh_file;   /* file flag   */
       55+      485    1                       char                    bh_eofreturned; /*eof flag*/
       56+      486    1                       int                     LS_flag;  /*Listing on/off*/
       57+      487    1                    };
       58+      488
       59+      489             struct      i_buf {
       60+      490    1                       struct   i_buf *next;
       61+      491    1                       char           ib_text[INP_BUFSIZE + INP_NPUSHBACK];
       62+      492    1                    };
       63+      493
       64+      494
       65+      495             struct      zb_files    zb_fileinfo;
       66+      496
       67+      497             char                                *_ipp = 0;
       68+      498             PRIVATE  struct   buffer_header     *head = 0;
       69+      499             PRIVATE  int                        stdin_flag = 0;
       70+      500             PRIVATE  struct   i_buf             *i_ptr = 0;
       71+      501             int      no_base_file = 1;
       72+      502             char     *base_name = 0;
       73+      503             char     *update_name = 0;
       74+      504
       75+      505             /*F*     NAME:       pushbuf
       76+      506                      PURPOSE:    Allocate a buffer for each file to be read
       77+      507                      DESCRIPTION:This routine allocates a buffer for each file
       78+      508                                  to be read so input can be suspended in the
       79+      509                                  middle of a buffers input
       80+      510             */
       81+      511             /*D*     NAME:    pushbuf
       82+      512                      CALL:    pushbuf()
       83+      513                      INPUT:   None
       84+      514                      OUTPUT:
       85+      515                               This routine returns a pointer to the buffer
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=15 
       86+      516                               allocated minus the number of characters that
       87+      517                               the user wants to be able to pushback onto the
       88+      518                               input stream
       89+      519                      DESCRIPTION:
       90+      520                         This routine simply allocates a buffer that is to
       91+      521                         contain the input stream of the current file that is
       92+      522                         open. Note that not all of the buffer is given to the
       93+      523                         user. This so that if the user wants to be able to push
       94+      524                         characters back onto the input stream it will still
       95+      525                         work as advertised.
       96+      526             */
       97+      527
       98+      528
       99+      529             PRIVATE char *
      100+      530             pushbuf()
      101+      531             {
      102+      532    1           register struct   i_buf *ib =
      103+      533    1           (struct i_buf *) Malloc (sizeof (struct i_buf));
      104+      534    1
      105+      535    1           if (!ib) return 0;
      106+      536    1           ib->next = i_ptr;
      107+      537    1           i_ptr = ib;
      108+      538    1
      109+      539    1        /*    Keep part of the buffer for a good PUSHBACK           */
      110+      540    1           return &(ib->ib_text[INP_NPUSHBACK-1]);
      111+      541    1        }
      112+      542
      113+      543
      114+      544             /*F*        NAME:       push_bh
      115+      545                         PURPOSE:    Pushes off information when input sources change
      116+      546                         DESCRIPTION:Pushes off information when input sources change
      117+      547                                     so that they can be restored when input
      118+      548                                     returns to the old input source
      119+      549             */
      120+      550             /*D*        NAME:    push_bh
      121+      551                         CALL:    push_bh()
      122+      552                         INPUT:   None
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=16 
      123+      553                         OUTPUT:
      124+      554                                  This routine returns the top position of the
      125+      555                                  stack of input saved information
      126+      556                         DESCRIPTION:
      127+      557                            This routine pushes off all the necessary information
      128+      558                            about the current input source that is being read from.
      129+      559                            This includes:
      130+      560                               The current buffer in use
      131+      561                               The position being read in the current buffer
      132+      562                               User supplied variable
      133+      563                               The size of the current buffer
      134+      564             */
      135+      565
      136+      566             PRIVATE     struct   buffer_header *
      137+      567             push_bh()
      138+      568             {
      139+      569    1           register struct   buffer_header *bh;
      140+      570    1
      141+      571    1           if (bh = head) {
      142+      572    2              bh->bh_ipp = _ipp;
      143+      573    2        #ifdef   INP_TYPE
      144+      574    2              if (bh->bh_file) { bh->bh_i = INP_VAR; }
      145+      575    2        #endif   INP_TYPE
      146+      576    2           }
      147+      577    1
      148+      578    1           if (!(bh = (struct buffer_header *) Malloc ( sizeof (struct buffer_header))
                               )) return 0;
      149+      579    1           bh->next = head;
      150+      580    1           bh->bh_eofreturned = 0;
      151+      581    1           head = bh;
      152+      582    1           return bh;
      153+      583    1        }
      154+      584
      155+      585             /*F*        NAME:       pop_bh
      156+      586                         PURPOSE:    Restores information about a previous input source
      157+      587                         DESCRIPTION:Restores information about a previous input source
      158+      588                                     that was suspended by the user
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=17 
      159+      589             */
      160+      590             /*D*        NAME:    pop_bh
      161+      591                         CALL:    pop_bh()
      162+      592                         INPUT:   None
      163+      593                         OUTPUT:
      164+      594                                  This routine returns a 1 if there was a information
      165+      595                                  to be restored from the stack else it returns a 0
      166+      596                         DESCRIPTION:
      167+      597                            This routine pops off all the information that was
      168+      598                            saved by the routine push_bh().
      169+      599             */
      170+      600
      171+      601             PRIVATE  int
      172+      602             pop_bh()
      173+      603             {
      174+      604    1           register struct   buffer_header  *bh = head;
      175+      605    1        #ifdef INP_TYPE
      176+      606    1           int PopFile = 0;
      177+      607    1        #endif
      178+      608    1
      179+      609    1           if (bh->bh_file) {   /* Unstack a file */
      180+      610    2              struct   i_buf *ib;
      181+      611    2
      182+      612    2              ib = i_ptr->next;
      183+      613    2              vfree ((char *) i_ptr);
      184+      614    2              i_ptr = ib;
      185+      615    2        #ifdef INP_TYPE
      186+      616    2              PopFile = 1;
      187+      617    2        #endif
      188+      618    2           }
      189+      619    1
      190+      620    1           bh = bh->next;
      191+      621    1           vfree ((char *) head);
      192+      622    1           head = bh;
      193+      623    1
      194+      624    1           if (!bh) {  /* No more entries   */
      195+      625    2              head = (struct buffer_header *) 0;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=18 
      196+      626    2              return 0;
      197+      627    2           }
      198+      628    1
      199+      629    1           _ipp = bh->bh_ipp;   /* Restore previous input pointer   */
      200+      630    1           zb_LS_flag = bh->LS_flag;
      201+      631    1        #ifdef   INP_TYPE
      202+      632    1           if (PopFile) { INP_VAR = bh->bh_i; }
      203+      633    1        #endif   INP_TYPE
      204+      634    1
      205+      635    1           return 1;
      206+      636    1        }
      207+      637
      208+      638
      209+      639             /*F*     NAME:       readblock
      210+      640                      PURPOSE:    Read the next record from the current input source
      211+      641                      DESCRIPTION:This routine reads the next input source from the
      212+      642                                  current input file using the read routine
      213+      643                                  that uses XUU services
      214+      644             */
      215+      645             /*D*     NAME:    readblock
      216+      646                      CALL:    readblock (buf,n)
      217+      647                      INPUT:
      218+      648                               char  buf[] - A pointer to a buffer
      219+      649                      OUTPUT:
      220+      650                               char  buf[] - An array that contains the record
      221+      651                                             that was read from the input file
      222+      652                               int   n     - The number of bytes in the current
      223+      653                                             record
      224+      654                               This routine returns a 1 on a successful read and
      225+      655                               a 0 on an unsuccessful read (like EOF)
      226+      656                      DESCRIPTION:
      227+      657                         This routine calls and gets the next record from the input
      228+      658                         file and puts a '\0' at the end of the record on a
      229+      659                         successful read and returns a 1 else it returns a 0
      230+      660             */
      231+      661
      232+      662             PRIVATE int
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=19 
      233+      663             readblock (buf,n)
      234+      664             char  buf[];
      235+      665             int   *n;
      236+      666             {
      237+      667    1
      238+      668    1           int   ret_val = 0;
      239+      669    1           char  *result;
      240+      670    1           char  *errmsg;
      241+      671    1           zb_fileinfo.bufsize = INP_BUFSIZE;
      242+      672    1           zb_fileinfo.buffer = buf;
      243+      673    1           if ((ret_val = ZB_INPUT_READ (&zb_fileinfo)) == 0) {
      244+      674    2              *n = 0;
      245+      675    2              return 0;
      246+      676    2           }
      247+      677    1           else if (ret_val < 0) {
      248+      678    2              result = strerror(errno);
      249+      679    2              errmsg = Malloc (strlen(result));
      250+      680    2              strcpy (errmsg, result);
      251+      681    2              zb_listing_error (errmsg, DEBUG_NUM, 0, 8);
      252+      682    2              Free (errmsg);
      253+      683    2              *n = 0;
      254+      684    2              return 0;
      255+      685    2           }
      256+      686    1           buf = zb_fileinfo.buffer;
      257+      687    1           *n = zb_fileinfo.nbytes;
      258+      688    1           buf[*n] = '\0';
      259+      689    1           zb_listing_append (DEBUG_NUM,buf);
      260+      690    1           AtBoBF (buf, n);
      261+      691    1           return   1;
      262+      692    1        }
      263+      693
      264+      694
      265+      695             /*F*     NAME:       mk_filename
      266+      696                      PURPOSE:    This routine concatenates a dir and a filename
      267+      697                      DESCRIPTION:This routine concatenates a dir and a filename
      268+      698             */
      269+      699             /*D*     NAME:    mk_filename
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=20 
      270+      700                      CALL:    mk_filename (dir, file, newname)
      271+      701                      INPUT:
      272+      702                               char  *dir  - the directory part for newname
      273+      703                               char  *file - the file name part for newname
      274+      704                      OUTPUT:
      275+      705                               char **newname - A pointer to the new filename
      276+      706                                                that was created with dir and file
      277+      707                      DESCRIPTION:
      278+      708                         This routine creates the next filename that needs to
      279+      709                         be opened by the InsertFile. The variables dir and file
      280+      710                         can come in several different varieties:
      281+      711                            1) file '.' dir
      282+      712                            2) dir (up to '.') file rest of dir
      283+      713                            3) replace ? in dir with file
      284+      714                         If a newname can be created a 1 is returned else a 0
      285+      715             */
      286+      716
      287+      717             PRIVATE int
      288+      718             mk_filename(dir, file, newname)
      289+      719             register char *dir, *file;
      290+      720             char **newname;
      291+      721             {
      292+      722    1           int dirtype, newlen;
      293+      723    1           char *p, *strindex();
      294+      724    1           register char *dst;
      295+      725    1           char  *q = 0;
      296+      726    1           int   dirlen = 0;
      297+      727    1           int   fillen = 0;
      298+      728    1
      299+      729    1           dirtype = 0, newlen = 2;
      300+      730    1           dirlen = strlen(dir) + 1;
      301+      731    1           fillen = strlen(file);
      302+      732    1           p = memchr(dir, '.', dirlen);
      303+      733    1           if (p) dirtype = 1;
      304+      734    1           if (q = memchr(dir, '?', dirlen)) dirtype = 2;
      305+      735    1
      306+      736    1           newlen += dirlen + fillen;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=21 
      307+      737    1           dst = Malloc((unsigned) (newlen));
      308+      738    1           if (!dst) return 0;
      309+      739    1           *newname = dst;
      310+      740    1
      311+      741    1           switch(dirtype)    {
      312+      742    2
      313+      743    2           case 0:   /***  file '.' dir   ***/
      314+      744    2              memcpy(dst, file, fillen);
      315+      745    2              dst[fillen] = '.';
      316+      746    2              memcpy(dst+fillen+1, dir, dirlen);
      317+      747    2              break;
      318+      748    2
      319+      749    2           case 1:   /***  dir (up to '.') file (rest of dir)  ***/
      320+      750    2              newlen = p - dir;
      321+      751    2              memcpy(dst, dir, newlen);
      322+      752    2              memcpy(dst+newlen, file, fillen);
      323+      753    2              memcpy(dst+newlen+fillen, p, dirlen-newlen);
      324+      754    2              break;
      325+      755    2
      326+      756    2           case 2:   /**   Replace '?' in dir with file        ***/
      327+      757    2              newlen = q - dir;
      328+      758    2              memcpy(dst, dir, newlen);
      329+      759    2              memcpy(dst+newlen, file, fillen);
      330+      760    2              memcpy(dst+newlen+fillen, q+1, dirlen-newlen-1);
      331+      761    2              break;
      332+      762    2           }
      333+      763    1           return 1;
      334+      764    1        }
      335+      765
      336+      766
      337+      767             /*F*     NAME:       InsertFile
      338+      768                      PURPOSE:    Suspend current input and start input from a file
      339+      769                      DESCRIPTION:Suspend current input and start input from a file
      340+      770                                  supplied by the caller
      341+      771             */
      342+      772             /*D*     NAME:    InsertFile
      343+      773                      CALL:    InsertFile (filnam, table, result)
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=22 
      344+      774                      INPUT:
      345+      775                               char *filnam   - The name of the file to open
      346+      776                               char *table[]  - A table of directories that are
      347+      777                                                to be searched for filnam
      348+      778                      OUTPUT:
      349+      779                               char **result  - Contains the entire filename
      350+      780                                                that was opened (comes from mk_filename)
      351+      781                      DESCRIPTION:
      352+      782                         This routine suspends input from the current input source
      353+      783                         and starts input from the file supplied by the user.
      354+      784                         It opens the new file and allocates the buffer needed for
      355+      785                         reading the data from the file. If the file is opened
      356+      786                         ok, the routine returns a 1 else it returns a 0.
      357+      787             */
      358+      788
      359+      789             int
      360+      790             InsertFile (filnam, table, result)
      361+      791             char *filnam;
      362+      792             char *table[];
      363+      793             char **result;
      364+      794             {
      365+      795    1           char  *newfn = 0;
      366+      796    1           char  *acctloc = 0;
      367+      797    1           char  *slashloc = 0;
      368+      798    1           int   len = 0;
      369+      799    1
      370+      800    1           if (!filnam) {
      371+      801    2              if (!OpenSource (IN_BASE, 0, 0))
      372+      802    2                 return 0;
      373+      803    2              *result = base_name;
      374+      804    2              return 1;
      375+      805    2           }
      376+      806    1           zb_fileinfo.filetype = IN_INCLUDE;
      377+      807    1           zb_fileinfo.optui = 0;
      378+      808    1           if (no_base_file) {
      379+      809    2              zb_fileinfo.key = Malloc (12 * sizeof (char));
      380+      810    2                 zb_listing_input_init (filnam,filnam,(char *) 0,&(zb_fileinfo.nbytes)
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=23 
                               ,zb_fileinfo.key);
      381+      811    2           }
      382+      812    1           if (!filnam) stdin_flag = 1;
      383+      813    1           else {
      384+      814    2              len = strlen(filnam);
      385+      815    2              slashloc = memchr(filnam, '/', len);
      386+      816    2              if (slashloc) {           /* check to see if '/' goes to '$'  */
      387+      817    3                 char     *pos = filnam;
      388+      818    3                 if ((!memcmp(pos, "DP", 2)) ||
      389+      819    3                    (!memcmp(pos, "dp", 2)) ||
      390+      820    3                    (!memcmp(pos, "LT", 2)) ||
      391+      821    3                    (!memcmp(pos, "lt", 2))) {
      392+      822    4                    pos += 2;
      393+      823    4                    if ((pos == slashloc) || (*pos == '#') ||
      394+      824    4                       (((pos + 1) <= slashloc) && (isdigit(*pos)) &&
      395+      825    4                          (isdigit(*(pos + 1))) && ((*(pos + 2) == '#') ||
      396+      826    4                             (*(pos + 2) == '/')))) {   /* Dont change this
      397+      827    5                                                           slash */
      398+      828    5                       slashloc++;
      399+      829    5                       slashloc = memchr(slashloc, '/', len - (slashloc - filnam - 1))
                               ;
      400+      830    5                    }
      401+      831    4                 }
      402+      832    3                 while (slashloc) {
      403+      833    4                    *slashloc++ = '$';
      404+      834    4                    slashloc = memchr(slashloc, '/', len - (slashloc - filnam - 1));
      405+      835    4                 }
      406+      836    3              }
      407+      837    2              if ((table == 0) || (acctloc = strindex (filnam, '.')) != 0) {
      408+      838    3                 /* Do not look in table (yet) */
      409+      839    3                 zb_fileinfo.filename = filnam;
      410+      840    3                 if (!ZB_INPUT_OPEN (&zb_fileinfo)) {
      411+      841    4                    if (table) {
      412+      842    5                       *acctloc++ = ':';
      413+      843    5                       while (acctloc = strchr(acctloc, '.')) {
      414+      844    6                          *acctloc++ = ':';
      415+      845    6                       }
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=24 
      416+      846    5                       goto look_in_table;
      417+      847    5                    }
      418+      848    4                    return 0;
      419+      849    4                 }
      420+      850    3              }
      421+      851    2              else {
      422+      852    3        look_in_table:
      423+      853    3                 while (*table) {
      424+      854    4                    if (!mk_filename (*table++, filnam, &newfn)) {
      425+      855    5                       return 0;
      426+      856    5                    }
      427+      857    4                    zb_fileinfo.filename = newfn;
      428+      858    4                    if (ZB_INPUT_OPEN (&zb_fileinfo)) {
      429+      859    5                       filnam = zb_fileinfo.filename;
      430+      860    5                       break;
      431+      861    5                    }
      432+      862    4                    vfree (newfn);
      433+      863    4                    newfn = 0;
      434+      864    4                 }
      435+      865    3              }
      436+      866    2           }
      437+      867    1
      438+      868    1           if (zb_fileinfo.open_flag) {
      439+      869    2              register struct   buffer_header  *bh = push_bh();
      440+      870    2
      441+      871    2              if (!bh) {
      442+      872    3                 if (!stdin_flag) ZB_INPUT_CLOSE (&zb_fileinfo);
      443+      873    3                 return 0;
      444+      874    3              }
      445+      875    2
      446+      876    2              if (no_base_file) {
      447+      877    3                 no_base_file = 0;
      448+      878    3                 bh->LS_flag = zb_LS_flag;
      449+      879    3              }
      450+      880    2              else {
      451+      881    3                 zb_LS_flag = bh->LS_flag = zb_LS_include_flag;
      452+      882    3                 zb_listing_include (filnam, 0, 0);
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=25 
      453+      883    3              }
      454+      884    2
      455+      885    2              if (!(_ipp = bh->bh_text = pushbuf()) || !readblock (_ipp,&(bh->bh_size)
                               )) {
      456+      886    3        /* Dont fail here it could have been an empty file */
      457+      887    3                 *_ipp = '\0';
      458+      888    3              }
      459+      889    2              bh->bh_file = zb_fileinfo.filetype;
      460+      890    2              *result = filnam;
      461+      891    2              return 1;
      462+      892    2           }
      463+      893    1           return 0;
      464+      894    1        }
      465+      895
      466+      896              /*F*    NAME:       InsertText
      467+      897                      PURPOSE:    Changes input from current source to a text string
      468+      898                      DESCRIPTION:Changes input from current source to a text string that i
                               s a user supplied parameter
      469+      899             */
      470+      900             /*D*     NAME:    InsertText
      471+      901                      CALL:    InsertText (text,length)
      472+      902                      INPUT:
      473+      903                               char *text  - The text that is to be used as the
      474+      904                                             input source
      475+      905                               int  length - The length of the text string
      476+      906                      OUTPUT:  None
      477+      907                      DESCRIPTION:
      478+      908                         This routine suspends input from the current source
      479+      909                         and makes the new input source a text string. This
      480+      910                         routine returns a 1 if everything worked ok else it
      481+      911                         returns a 0.
      482+      912             */
      483+      913             int
      484+      914             InsertText (text,length)
      485+      915             char  *text;
      486+      916             int   length;
      487+      917             {
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=26 
      488+      918    1           register struct   buffer_header  *bh = push_bh();
      489+      919    1
      490+      920    1           if (!bh) return 0;
      491+      921    1           bh->LS_flag = 0;
      492+      922    1           bh->bh_size = length;
      493+      923    1           _ipp = bh->bh_text = text;
      494+      924    1           bh->bh_file = IN_TEXT;
      495+      925    1           return 1;
      496+      926    1        }
      497+      927
      498+      928
      499+      929             int
      500+      930             OpenSource (filetype, optui, list_update)
      501+      931             int   filetype;
      502+      932             unsigned int   optui;
      503+      933             unsigned int   list_update;
      504+      934             {
      505+      935    1           base_name = Malloc(132);
      506+      936    1           update_name = Malloc (132);
      507+      937    1           no_base_file = 0;
      508+      938    1           zb_fileinfo.key = Malloc (12 * sizeof(char));
      509+      939    1           zb_fileinfo.filetype = filetype;
      510+      940    1           zb_fileinfo.optui = optui;
      511+      941    1           zb_fileinfo.list_update = list_update;
      512+      942    1           if (!ZB_GETFILENAME (&filetype, base_name, update_name)) {
      513+      943    2              base_name = (char *) 0;
      514+      944    2              update_name = (char *) 0;
      515+      945    2           }
      516+      946    1           if (filetype == IN_BASE)
      517+      947    1              update_name = (char *) 0;
      518+      948    1           zb_listing_input_init ("funcname", base_name, update_name,
      519+      949    1                                  &(zb_fileinfo.nbytes), zb_fileinfo.key);
      520+      950    1           if (!ZB_INPUT_OPEN (&zb_fileinfo))
      521+      951    1              goto No_such_file;
      522+      952    1           if (zb_fileinfo.open_flag) {
      523+      953    2              register struct   buffer_header  *bh = push_bh();
      524+      954    2              if (!bh) {
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=27 
      525+      955    3                 if (!stdin_flag)
      526+      956    3                    ZB_INPUT_CLOSE (&zb_fileinfo);
      527+      957    3                 goto No_such_file;
      528+      958    3              }
      529+      959    2              bh->LS_flag = zb_LS_flag;
      530+      960    2              if (!(_ipp = bh->bh_text = pushbuf()) ||
      531+      961    2                 (!readblock (_ipp,&bh->bh_size)))      {
      532+      962    3                 *_ipp = '\0';
      533+      963    3              }
      534+      964    2              bh->bh_file = zb_fileinfo.filetype;
      535+      965    2              return 1;
      536+      966    2           }
      537+      967    1        No_such_file:
      538+      968    1           base_name = (char *) 0;
      539+      969    1           update_name = (char *) 0;
      540+      970    1           zb_listing_input_init ("funcname",base_name,update_name,&(zb_fileinfo.nbyte
                               s),zb_fileinfo.key);
      541+      971    1           return 0;
      542+      972    1        }
      543+      973
      544+      974             /*F*     NAME:       loadbuf
      545+      975                      PURPOSE:    This routine loads the buffer with the next record from t
                               he current input source
      546+      976                      DESCRIPTION:This routine loads the buffer with the next record from t
                               he current input source
      547+      977             */
      548+      978             /*D*     NAME:    loadbuf
      549+      979                      CALL:    loadbuf()
      550+      980                      INPUT:   None
      551+      981                      OUTPUT:  None
      552+      982                      DESCRIPTION:
      553+      983                         This routine is called whenever the defined routine
      554+      984                         loadchar encounters a '\0'. This character either means
      555+      985                         the end of the buffer has been found or there is actually
      556+      986                         a '\0' in the input (not likely). If a file is the
      557+      987                         current input source the last INP_PUSHBACK characters must
      558+      988                         be saved off so a good pushback can be implemented.
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=28 
      559+      989                         Once this is done the next record is read from the
      560+      990                         current file. If this read fails the routine calls
      561+      991                         AtEoIF. And the next time this routine is called it pops
      562+      992                         the last input source that was found.
      563+      993             */
      564+      994             /*  loadbuf() is called if LoadChar meets a '\0' character
      565+      995                 which may be the end-of-buffer mark of the current input
      566+      996                 buffer.  The '\0' could be genuine although not likely.
      567+      997                 Note: this routine is exported due to its occurence in the definition
      568+      998                 of LoadChar [input.h], that is defined as a macro.
      569+      999             */
      570+     1000             int
      571+     1001             loadbuf()
      572+     1002             {
      573+     1003    1           register struct buffer_header *bh = head;
      574+     1004    1           static   char buf[INP_NPUSHBACK + 1];
      575+     1005    1           int      FromFile;
      576+     1006    1
      577+     1007    1           if (!bh) {      /* stack exhausted, EOF on sourcefile */
      578+     1008    2              return EOI;
      579+     1009    2           }
      580+     1010    1
      581+     1011    1           if (_ipp < &(bh->bh_text[bh->bh_size])) {
      582+     1012    2                  /* a genuine '\0' character has been seen */
      583+     1013    2              return '\0';
      584+     1014    2           }
      585+     1015    1
      586+     1016    1           FromFile = bh->bh_file;
      587+     1017    1
      588+     1018    1           if (FromFile) {
      589+     1019    2        #if INP_NPUSHBACK > 1
      590+     1020    2              register char *so = &(bh->bh_text[bh->bh_size]);
      591+     1021    2              register char *de = bh->bh_text;
      592+     1022    2              register int i = INP_NPUSHBACK - 1;
      593+     1023    2
      594+     1024    2              while (i-- > 0) {
      595+     1025    3                  /* make sure PushBack will work */
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=29 
      596+     1026    3                 *--de = *--so;
      597+     1027    3              }
      598+     1028    2        #endif
      599+     1029    2              if (
      600+     1030    2                  readblock(bh->bh_text, &(bh->bh_size))
      601+     1031    2                  &&
      602+     1032    2                  bh->bh_size > 0
      603+     1033    2                     )  {
      604+     1034    3                 _ipp = bh->bh_text;
      605+     1035    3                 return *_ipp++;
      606+     1036    3              }
      607+     1037    2           }
      608+     1038    1
      609+     1039    1
      610+     1040    1           if (!bh->bh_eofreturned) {
      611+     1041    2              bh->bh_eofreturned = 1;
      612+     1042    2              _ipp--;
      613+     1043    2              if (FromFile) {
      614+     1044    3                 if (AtEoIF()) return EOI;
      615+     1045    3              }
      616+     1046    2              else {
      617+     1047    3                 if (AtEoIT()) return EOI;
      618+     1048    3              }
      619+     1049    2           }
      620+     1050    1
      621+     1051    1
      622+     1052    1           if (pop_bh()) {
      623+     1053    2              if (*_ipp) return *_ipp++;
      624+     1054    2              if (zb_fileinfo.level != -1) return loadbuf();
      625+     1055    2           }
      626+     1056    1           _ipp = &buf[INP_NPUSHBACK];
      627+     1057    1           return EOI;
      628+     1058    1        }
       20      1059             #pragma LIST INCLUDE_OFF
       21      1060
       22      1061             #ifndef NOPP
       23      1062             char *
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=30 
       24      1063             getwdir(fn)
       25      1064              register char *fn;
       26      1065             {
       27      1066    1         register char *p;
       28      1067    1         char *strrindex();
       29      1068    1
       30      1069    1         p = strrindex(fn, '/');
       31      1070    1         while (p && *(p + 1) == '\0') {  /* remove trailing /'s */
       32      1071    2            *p = '\0';
       33      1072    2            p = strrindex(fn, '/');
       34      1073    2         }
       35      1074    1
       36      1075    1         if (fn[0] == '\0' || (fn[0] == '/' && p == &fn[0])) /* absolute path */
       37      1076    1            return "";
       38      1077    1         if (p) {
       39      1078    2            *p = '\0';
       40      1079    2            fn = Salloc(fn, p - &fn[0] + 1);
       41      1080    2            *p = '/';
       42      1081    2            return fn;
       43      1082    2         }
       44      1083    1         return ".";
       45      1084    1        }
       46      1085             #endif NOPP
       47      1086
       48      1087             int NoUnstack;
       49      1088
       50      1089             AtEoIT()
       51      1090             {
       52      1091    1        #ifndef NOPP
       53      1092    1         if (NoUnstack) lexerror("unexpected EOF");
       54      1093    1         DoUnstack();
       55      1094    1        #endif NOPP
       56      1095    1         return 0;
       57      1096    1        }
       58      1097
       59      1098             AtEoIF()
       60      1099             {
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=31 
       61      1100    1         if (NoUnstack) lexerror("unexpected EOF");
       62      1101    1          if (finfo.ExprLines || finfo.ErrorLines) {
       63      1102    2             /* if (include file generated code)... */
       64      1103    2             if (head->next) {
       65      1104    3                register struct buffer_header *bh = head->next;
       66      1105    3                bh->bh_i.ExprLines += finfo.ExprLines;
       67      1106    3                bh->bh_i.ErrorLines += finfo.ErrorLines;
       68      1107    3                bh->bh_i.StartLine = DebugLineBias;
       69      1108    3                while (bh->next) {
       70      1109    4                   register struct buffer_header *b = bh->next;
       71      1110    4                   b->bh_i.StartLine = DebugLineBias;
       72      1111    4                   bh = b;
       73      1112    4                   }
       74      1113    3                }
       75      1114    2             }
       76      1115    1          else DebugLineBias = finfo.StartLine;
       77      1116    1         return 0;
       78      1117    1        }
       79      1118             AtBoBF(buffer, n)
       80      1119                   char *buffer;
       81      1120                   int  *n;
       82      1121             {
       83      1122    1        #define NewLine         '\n'
       84      1123    1        #define BackSlash       '\\'
       85      1124    1        #define EOS             '\0'
       86      1125    1        #define QuestionMark    '?'
       87      1126    1
       88      1127    1        static const int mapping[128] = {
       89      1128    2        /*
       90      1129    2        0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
       91      1130    2        */
       92      1131    2        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       93      1132    2        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
       94      1133    2        0,'|',  0,  0,  0,  0,  0,'^','[',']',  0,  0,  0,'~',  0,'\\',
       95      1134    2        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,'{','#','}',  0,
       96      1135    2        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
       97      1136    1        static int NewLineCnt;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=32 
       98      1137    1        char *ip;
       99      1138    1        char *ep;
      100      1139    1        char *lp = &buffer[*n];
      101      1140    1        int i;
      102      1141    1        int len;
      103      1142    1        char *NextBackSlash = 0;
      104      1143    1        char *NextNewLine   = 0;
      105      1144    1        char *NextQuestionMark =0;
      106      1145    1        char ASCIIchar;
      107      1146    1
      108      1147    1
      109      1148    1        ep = ip = &buffer[0];
      110      1149    1        NextQuestionMark = memchr(ep, QuestionMark, lp-ep);
      111      1150    1        while (ep < lp && NextQuestionMark) {
      112      1151    2
      113      1152    2              if (NextQuestionMark == &buffer[0]) {
      114      1153    3                                                         /* what happens to QuestionMa
                               rks occupies different blocks */
      115      1154    3              }
      116      1155    2              if (ip != ep) {
      117      1156    3                 if (len = NextQuestionMark-ep) {
      118      1157    4                    memcpy(ip, ep, len);
      119      1158    4                    ip += len;
      120      1159    4                 }
      121      1160    3              }
      122      1161    2              if (NextQuestionMark + 1 < lp ) {
      123      1162    3                 if (NextQuestionMark[1] == QuestionMark) {
      124      1163    4                     if (ASCIIchar = mapping[NextQuestionMark[2]]) {
      125      1164    5                         if (ip == ep) ip = NextQuestionMark;
      126      1165    5                         *ip++ = ASCIIchar;
      127      1166    5                         ep = NextQuestionMark + 3;
      128      1167    5                     }
      129      1168    4                     else {/* only two ??, but consider ???) */
      130      1169    5                       if (NextQuestionMark[2] == QuestionMark) {
      131      1170    6                          if (ip != ep)
      132      1171    6                             *ip++ = QuestionMark;
      133      1172    6                          else
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=33 
      134      1173    6                             ip = NextQuestionMark+1;
      135      1174    6                          ep = NextQuestionMark+1;
      136      1175    6                       }
      137      1176    5                       else {/* ??x where x is not part of a trigraph char */
      138      1177    6                            if (ip != ep) {
      139      1178    7                                memset(ip, QuestionMark, 2);
      140      1179    7                                ip += 2;
      141      1180    7                                *ip++ = NextQuestionMark[2];
      142      1181    7                            }
      143      1182    6                            else
      144      1183    6                                ip = NextQuestionMark + 3;
      145      1184    6                            ep = NextQuestionMark + 3;
      146      1185    6                       }
      147      1186    5                     }
      148      1187    4                 }
      149      1188    3                 else {/* ?x */
      150      1189    4                    if (ip != ep) {
      151      1190    5                       *ip++ = QuestionMark;
      152      1191    5                       *ip++ = NextQuestionMark[1];
      153      1192    5                       ep = NextQuestionMark + 2;
      154      1193    5                    }
      155      1194    4                    else
      156      1195    4                       ip = ep = NextQuestionMark + 2;
      157      1196    4                 };
      158      1197    3              }
      159      1198    2              else {
      160      1199    3                 memcpy(ip, "?", 2);
      161      1200    3                 ip += 2;
      162      1201    3                 *n = ip - &buffer[0];
      163      1202    3                 goto L1;
      164      1203    3              }
      165      1204    2              if (ep < lp)
      166      1205    2              NextQuestionMark = memchr(ep, QuestionMark, lp-ep);
      167      1206    2        }
      168      1207    1
      169      1208    1        if (ip != ep) {
      170      1209    2                 if (len = lp - ep) {
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=34 
      171      1210    3                    memcpy(ip, ep, len);
      172      1211    3                    ip += len;
      173      1212    3                 }
      174      1213    2                 *ip = '\0';
      175      1214    2                 *n = ip - &buffer[0];
      176      1215    2        }
      177      1216    1        L1:
      178      1217    1           lp = &buffer[*n];
      179      1218    1           NewLineBias += NewLineCnt;
      180      1219    1           NewLineCnt = 0;
      181      1220    1           ep = ip = &buffer[0];
      182      1221    1
      183      1222    1           NextBackSlash = memchr(ep,BackSlash,lp-ep);
      184      1223    1           NextNewLine   = memchr(ep,NewLine,lp-ep);
      185      1224    1
      186      1225    1           while(ep < lp && (NextBackSlash || NextNewLine)) {
      187      1226    2              if (NextNewLine == &buffer[0]) {  /* first char. of the current block */

      188      1227    3                 if (VeryLastCharIsBackSlash) {
      189      1228    4                 }
      190      1229    3                 else {
      191      1230    4                 /* what happens if NewLineBias > 0 ? */
      192      1231    4                    ip = ep = &buffer[1];
      193      1232    4                    goto again;
      194      1233    4                 }
      195      1234    3              }
      196      1235    2              if (ip != ep) {
      197      1236    3                 if (!NextBackSlash || NextNewLine < NextBackSlash) {
      198      1237    4                    if (len = NextNewLine - ep) {
      199      1238    5                       memcpy(ip, ep, len);
      200      1239    5                       ip += len;
      201      1240    5                    }
      202      1241    4                    if (NewLineCnt) {
      203      1242    5                       memset(ip, NewLine, NewLineCnt);
      204      1243    5                       ip += NewLineCnt;
      205      1244    5                    }
      206      1245    4                    NewLineCnt=0;
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=35 
      207      1246    4                    ep=NextNewLine+1;
      208      1247    4                 }
      209      1248    3                 else {
      210      1249    4                    if (len = NextBackSlash - ep) {
      211      1250    5                       memcpy(ip, ep, len);
      212      1251    5                       ip += len;
      213      1252    5                    }
      214      1253    4                    NewLineCnt++;
      215      1254    4                    ep = NextBackSlash+2;
      216      1255    4                 }
      217      1256    3              }
      218      1257    2              else {
      219      1258    3                 if (NextBackSlash) {
      220      1259    4                    if (NextNewLine == NextBackSlash + 1) {
      221      1260    5                       NewLineCnt++;
      222      1261    5                       ip=NextBackSlash;
      223      1262    5                       ep=NextBackSlash+2;
      224      1263    5                    }
      225      1264    4                    else {
      226      1265    5                       ip=ep=NextBackSlash+1;
      227      1266    5                    }
      228      1267    4                 }
      229      1268    3                 else {  /* No Backslash at all */
      230      1269    4                    return 0;
      231      1270    4                 }
      232      1271    3              }
      233      1272    2         again:
      234      1273    2              if (ep < lp) {
      235      1274    3                 NextBackSlash = memchr(ep,BackSlash,lp-ep);
      236      1275    3                 NextNewLine   = memchr(ep,NewLine,lp-ep);
      237      1276    3              }
      238      1277    2           }
      239      1278    1        /* At the end of the current block,
      240      1279    1         * check to see if we need to do a move.
      241      1280    1         */
      242      1281    1           if (NewLineCnt || ip != ep) {
      243      1282    2              if (len = lp -ep) {
CC.C03    File=zbc$input:c.:ZBC3TSI                                                 Fri Aug 22 1997  Page=36 
      244      1283    3                 memcpy(ip, ep, len);
      245      1284    3                 ip += len;
      246      1285    3              }
      247      1286    2              *ip=EOS;/* bh->bh_size=ip-&buffer[0]; */
      248      1287    2              *n = ip - &buffer[0];
      249      1288    2           }
      250      1289    1           return 0;
      251      1290    1        }
      252      1291
---  Include file information  ---

   zbc$inputtype:h.:ZBC3TOU. is referenced
   zbc$file_info:h.:ZBC3TOU. is referenced
   zbc$input:h.:ZBC3TOU. is referenced
   inp_pkg:spec.:ZBC3TOU. is referenced
   zbc$nopp:h.:ZBC3TOU. is referenced
   inp_package:c.:ZBC3TOU. is referenced
   alloc:h.:ZBC3TOU. is referenced
   valloc:h.:LIB_E05. is referenced
   system:h.:ZBC3TOU. is referenced
   inp_types:h.:ZBC3TOU. is referenced
   errno:h.:LIB_E05. is referenced
   string:h.:LIB_E05. is referenced
   ctype:h.:LIB_E05. is referenced

No diagnostics were issued in the file zbc$input:c.:ZBC3TSI
