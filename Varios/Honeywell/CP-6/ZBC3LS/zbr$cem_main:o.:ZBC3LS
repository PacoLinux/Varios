

CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=1  
        1         1             #include <string:h>
        2         2             #include "root_interface:h"
        3         3             #include "zbc$macro:h"
        4         4             #include "zbc$idfsize:h"                             /* IDFSIZE */
        5         5             #define SOURCE    10
        6         6             #define UPDATE    11
        7         7             #define OBJECT    12
        8         8             /*
        9         9              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
       10        10              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
       11        11              */
       12        12             /* $Header: main.c,v 3.22 87/03/25 23:04:33 ceriel Exp $ */
       13        13             /* MAIN PROGRAM */
       14        14
       15        15             #include "zbc$nofloat:h"
       16        16             #include <system:h>
       17        17             #include "zbc$nopp:h"
       18        18             #include "zbc$target_sizes:h"
       19        19             #include "zbc$debug:h"
       20        20             #include "zbc$use_tmp:h"
       21        21             #include "zbc$inputtype:h"
       22        22             #include "zbc$input:h"
       23        23             #include "zbc$level:h"
       24        24             #include "zbc$idf:h"
       25        25             #include "zbc$arith:h"
       26        26             #include "zbc$type:h"
       27        27             #include "zbc$declar:h"
       28        28             #include "zbc$tokenname:h"
       29        29             #include "zbc$Lpars:h"
       30        30             #include "zbc$LLlex:h"
       31        31             #include <alloc:h>
       32        32             #include "zbc$specials:h"
       33        33             #include "zbc$noRoption:h"
       34        34             #include "zbc$nocross:h"
       35        35             #include "zbc$sizes:h"
       36        36             #include "zbc$align:h"
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=2  
       37        37             #include "zbc$zb_target:h"
       38        38             #include <inp_types:h>
       39        39             #include "zbc$dataFirst:h"
       40        40             #include <stdio:h>
       41        41             #include <fileinfo:h>
       42        42             extern char *tmpnam();
       43        43
       44        44             extern struct tokenname tkidf[], tkother[];
       45        45             extern char *symbol2str();
       46        46             extern int pp_only;
       47        47             char options[128];
       48        48             char *prog_name;
       49        49             char *destination = "*em";
       50        50             char *source;
       51        51             char *nmlist = (char *)0;
       52        52             char *result = (char *)0;
       53        53             int updates;
       54        54             extern int idfsize;                              /* idf:c */
       55        55             extern struct xux_std_options std_options;
       56        56
       57        57             void zb_listing_start_listing();
       58        58             extern zb_LS_flag;
       59        59             int zb_ls_depth = 0;
       60        60             int zb_skipping = 0;
       61        61             extern int zb_numerrs;
       62        62             extern int zb_max_severity;
       63        63             extern char *list_rec_source;
       64        64             extern char *current_function_name;
       65        65             #define BREAK_FMT   "%s  File=%s  Key=%s  Line=%d\nFunction=%s  Errors=%d  Max
                                Sev=%d\n"
       66        66             char  *CEM_PHASE ="Semantics:";
       67        67
       68        68             extern struct zb_files zb_fileinfo;
       69        69
       70        70             #ifndef NOPP
       71        71             int inc_pos = 1;
       72        72             char *inctable[MAXINCL]    = {
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=3  
       73        73    1         "..",
       74        74    1         ".:LIBRARY",
       75        75    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       76        76    1        }    ;
       77        77
       78        78             extern char *getwdir();
       79        79             #endif NOPP
       80        80
       81        81             extern int const_strings; /* put strings in readonly or static */
       82        82             static int signed_char = UNSIGNED;
       83        83             struct sp_id special_ids[] =   {
       84        84    1        #if 0
       85        85   *S*        {"setjmp", SP_SETJMP},                           /* non-local goto's are regi
                               stered */
       86        86   *S*       #endif
       87        87    1         {"__builtin_memcpy",     SP_MEMCPY},
       88        88    1         {"__builtin_memchr",     SP_MEMCHR},
       89        89    1         {"__builtin_memcmp",     SP_MEMCMP},
       90        90    1         {"__builtin_memset",     SP_MEMSET},
       91        91    1         {"__builtin_memmove",    SP_MEMMOVE},
       92        92    1         {"__builtin_memrchr",    SP_MEMRCHR},
       93        93    1         {"__builtin_atan",       SP_ATAN},
       94        94    1         {"__builtin_atan2",      SP_ATAN2},
       95        95    1         {"__builtin_cos",        SP_COS},
       96        96    1         {"__builtin_sin",        SP_SIN},
       97        97    1         {"__builtin_tan",        SP_TAN},
       98        98    1         {"__builtin_cosh",       SP_COSH},
       99        99    1         {"__builtin_sinh",       SP_SINH},
      100       100    1         {"__builtin_tanh",       SP_TANH},
      101       101    1         {"__builtin_exp",        SP_EXP},
      102       102    1         {"__builtin_log",        SP_LOG},
      103       103    1         {"__builtin_log10",      SP_LOG10},
      104       104    1         {"__builtin_pow",        SP_POW},
      105       105    1         {"__builtin_sqrt",       SP_SQRT},
      106       106    1         {"__builtin_fabs",       SP_FABS},
      107       107    1         {"__builtin_abs",        SP_ABS},
      108       108    1         {"__builtin_strlen",     SP_STRLEN},
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=4  
      109       109    1         {"__builtin_strcpy",     SP_STRCPY},
      110       110    1         {"__builtin_strcat",     SP_STRCAT},
      111       111    1         {"__builtin_strcmp",     SP_STRCMP},
      112       112    1         {"__builtin_strchr",     SP_STRCHR},
      113       113    1         {"__builtin_strrchr",    SP_STRRCHR},
      114       114    1         {0, 0}
      115       115    1        };
      116       116
      117       117             #ifndef NOCROSS
      118       118             arith
      119       119              short_size = SZ_SHORT,
      120       120              word_size = SZ_WORD,
      121       121              dword_size = (SZ_WORD + SZ_WORD),
      122       122              int_size = SZ_INT,
      123       123              long_size = SZ_LONG,
      124       124             #ifndef NOFLOAT
      125       125              float_size = SZ_FLOAT,
      126       126              double_size = SZ_DOUBLE,
      127       127             #endif NOFLOAT
      128       128              pointer_size = SZ_POINTER;
      129       129
      130       130             int
      131       131              short_align = AL_SHORT,
      132       132              word_align = AL_WORD,
      133       133              int_align = AL_INT,
      134       134              long_align = AL_LONG,
      135       135             #ifndef NOFLOAT
      136       136              float_align = AL_FLOAT,
      137       137              double_align = AL_DOUBLE,
      138       138             #endif NOFLOAT
      139       139              pointer_align = AL_POINTER,
      140       140              struct_align = AL_STRUCT,
      141       141              union_align = AL_UNION;
      142       142             #endif NOCROSS
      143       143
      144       144             #ifndef NOPP
      145       145             arith ifval;                                     /* ifval will contain the res
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=5  
                               ult of the #if expression */
      146       146             #endif NOPP
      147       147
      148       148
      149       149             static struct arguments *CC_options;
      150       150
      151       151
      152       152             cem_main(cem_arg)
      153       153              struct arguments *cem_arg;
      154       154             {
      155       155    1        #define free_dlist(p)  st_free(p, &hh_dlist, sizeof(struct dlist))
      156       156    1        void Free(void *);
      157       157    1        extern int Mvmalloc;
      158       158    1        struct clist *hh_clist;
      159       159    1        struct dlist *hh_dlist;
      160       160    1        register struct dlist *p = cem_arg->DefineList;
      161       161    1
      162       162    1        #define free_clist(p) st_free(p, &hh_clist, sizeof(struct clist))
      163       163    1        register struct clist *q = cem_arg->CrossList;
      164       164    1
      165       165    1        /*{int i;for (i=0; i<128; i++) options[i] = (cem_arg->options)[i];}*/
      166       166    1        memcpy(options, cem_arg->options, 128);
      167       167    1        CC_options = cem_arg;
      168       168    1        prog_name = cem_arg->prog_name;
      169       169    1        updates = cem_arg->update_input;
      170       170    1        const_strings = 1 - cem_arg->str_write;
      171       171    1        if (cem_arg->chsigned) signed_char = SIGNED;
      172       172    1
      173       173    1        init_hmask();
      174       174    1
      175       175    1        #ifndef NOPP
      176       176    1        init_pp();
      177       177    1        #endif NOPP
      178       178    1
      179       179    1
      180       180    1        if (!options['A']) {
      181       181    2           macro_def(str2idf("TS_CP6"), (char **)0, "1", -1, 1, NOFLAG);
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=6  
      182       182    2           macro_def(str2idf("TM_L66"), (char **)0, "1", -1, 1, NOFLAG);
      183       183    2        }
      184       184    1        macro_def(str2idf("_CP6_"), (char **)0, "1", -1, 1, NOFLAG);
      185       185    1        macro_def(str2idf("_L66_"), (char **)0, "1", -1, 1, NOFLAG);
      186       186    1
      187       187    1        if (cem_arg->idfsize) { /* identifier size is given from command line */
      188       188    2           idfsize = cem_arg->idfsize;
      189       189    2           if (idfsize > IDFSIZE) {
      190       190    3               warning("maximum identifier length is %d", IDFSIZE);
      191       191    3               idfsize = IDFSIZE;
      192       192    3           }
      193       193    2           else if (idfsize < 8) { /* Notice the difference between CPP & CEM */
      194       194    3               warning("minimum identifier length is 8");
      195       195    3               idfsize = 8;
      196       196    3           }
      197       197    2        }
      198       198    1
      199       199    1        while (p != (struct dlist *)0 ) {
      200       200    2        register struct dlist *nxt = p->next;
      201       201    2          if (p->type) {                                 /* NDefine */
      202       202    3                 register struct idf *idef;
      203       203    3                 if (p->dname)
      204       204    3                    if ((idef=str2idf(p->dname))->id_macro) {
      205       205    4                       free_macro(idef->id_macro);
      206       206    4                       idef->id_macro = (struct macro *) 0;
      207       207    4                    }
      208       208    3          }
      209       209    2          else {                                         /* Define */
      210       210    3                 if (p->buf) {                           /* Define(id=buf) */
      211       211    4                    macro_def(str2idf(p->dname), (char **)0, p->buf, -1, strlen(p->buf
                               ),NOFLAG);
      212       212    4                 }
      213       213    3                 else {                                  /* Define(id) */
      214       214    4                    macro_def(str2idf(p->dname), (char **)0, "1", -1, 2, NOFLAG);
      215       215    4                 }
      216       216    3          };
      217       217    2          Mvmalloc = 0;
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=7  
      218       218    2          Free(p->dname);
      219       219    2          Mvmalloc = 1;
      220       220    2          free_dlist(p);
      221       221    2          p = nxt;
      222       222    2        }                                                /* while */
      223       223    1
      224       224    1        while (q != (struct clist *)0 ) {
      225       225    2        register struct clist *nxt = q->next;
      226       226    2        switch (q->type) {
      227       227    3        case Short:
      228       228    3                 if (q->size) short_size = q->size;
      229       229    3                 if (q->align) short_align = q->align;
      230       230    3                 break;
      231       231    3        case Word:
      232       232    3                 if (q->size) dword_size = (word_size = q->size) << 1;
      233       233    3                 if (q->align) word_align = q->align;
      234       234    3                 break;
      235       235    3        case Int:
      236       236    3                 if (q->size) int_size = q->size;
      237       237    3                 if (q->align) int_align = q->align;
      238       238    3                 break;
      239       239    3        case Long:
      240       240    3                 if (q->size) long_size = q->size;
      241       241    3                 if (q->align) long_align = q->align;
      242       242    3                 break;
      243       243    3        case Float:
      244       244    3                 if (q->size) float_size = q->size;
      245       245    3                 if (q->align) float_align = q->align;
      246       246    3                 break;
      247       247    3        case Double:
      248       248    3                 if (q->size) double_size= q->size;
      249       249    3                 if (q->align) double_align = q->align;
      250       250    3                 break;
      251       251    3        case Pointer :
      252       252    3                 if (q->size) pointer_size = q->size;
      253       253    3                 if (q->align) pointer_align = q->align;
      254       254    3                 break;
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=8  
      255       255    3        case Struct:
      256       256    3                 if (q->align) struct_align = q->align;
      257       257    3                 break;
      258       258    3        case Union:
      259       259    3                 if (q->align) union_align = q->align;
      260       260    3                 break;
      261       261    3        default:
      262       262    3                 printf("You got be kidding!\n");
      263       263    3                 break;
      264       264    3        }
      265       265    2        free_clist(q);
      266       266    2        q=nxt;
      267       267    2        }                                                /* while */
      268       268    1
      269       269    1        {  int i;
      270       270    2           for (i=1; i < MAXINCL; i++)
      271       271    2               inctable[i] = (cem_arg->srch_table)[i];
      272       272    2        }
      273       273    1
      274       274    1        compile(cem_arg->opt_ui, cem_arg->opt_lu);
      275       275    1        strcpy(cem_arg->destination, destination);      /* Object unit */
      276       276    1
      277       277    1        #ifdef DEBUG
      278       278    1        hash_stat();
      279       279    1        #endif DEBUG
      280       280    1
      281       281    1        zb_LS_flag = cem_arg->zb_LS_flag;
      282       282    1        if (err_occurred) cem_arg->err_occurred = 1;
      283       283    1
      284       284    1        }
      285       285
      286       286             #ifdef USE_TMP
      287       287
      288       288
      289       289             #ifdef TS_CP6
      290       290             char *tmpfdir = "";
      291       291             static char *tmpfname = "*Cem:XXXXXX";
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=9  
      292       292             #else
      293       293   *S*       char *tmpfdir = "/tmp";
      294       294   *S*       static char *tmpfname = "/Cem.XXXXXX";
      295       295   *S*       #endif
      296       296             char *tempfile = 0;
      297       297             #if DATAFIRST
      298       298             char *tmpfile2 = 0;
      299       299             #endif
      300       300             #endif USE_TMP
      301       301
      302       302             extern char *GetFileName();
      303       303             compile(opt_ui, opt_lu)
      304       304                   unsigned int opt_ui;
      305       305                   unsigned int opt_lu;
      306       306             {
      307       307    1        #ifdef USE_TMP
      308       308    1        #ifdef TS_CP6
      309       309    1         char tmpf[60];
      310       310    1        #if DATAFIRST
      311       311    1         char tmpf2[60];
      312       312    1        #endif DATAFIRST
      313       313    1        #else TS_CP6
      314       314   *S*        char tmpf[256];
      315       315   *S*       #if DATAFIRST
      316       316   *S*        char tmpf2[256];
      317       317   *S*       #endif DATAFIRST
      318       318   *S*       #endif TS_CP6
      319       319    1        #endif USE_TMP
      320       320    1        #ifdef USE_TMP
      321       321    1         if (! options['N']) {
      322       322    2            strcpy(tmpf, tmpfdir);
      323       323    2            strcat(tmpf, tmpfname);
      324       324    2          tempfile = tmpnam (tmpf);
      325       325    2        #if DATAFIRST
      326       326    2            strcpy(tmpf2, tmpfdir);
      327       327    2            strcat(tmpf2, tmpfname);
      328       328    2           tmpfile2 = tmpnam (tmpf2);
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=10 
      329       329    2        #endif
      330       330    2         }
      331       331    1        #endif USE_TMP
      332       332    1
      333       333    1          options['l'] = zb_LS_flag;
      334       334    1          zb_listing_start_listing(CP6_VERSION,&zb_ls_depth,&zb_skipping);
      335       335    1          if (!OpenSource( 1 + updates, opt_ui, opt_lu)) {
      336       336    2             options['l'] = 0;
      337       337    2             GetFileName(SOURCE);
      338       338    2             if (updates) {
      339       339    3                GetFileName(UPDATE);
      340       340    3                fatal("%s: no source file %s or update file %s\n", prog_name, source,
                               result);
      341       341    3             }
      342       342    2             fatal("%s: no source file %s\n", prog_name, source);
      343       343    2          }
      344       344    1          GetFileName(SOURCE);
      345       345    1          FileName = source;
      346       346    1
      347       347    1          set_break_vars (BREAK_FMT, &CEM_PHASE, &FileName, &list_rec_source,
      348       348    1                          &LineNumber, &current_function_name, &zb_numerrs,
      349       349    1                          &zb_max_severity);
      350       350    1         File_Inserted = 1;
      351       351    1         init();
      352       352    1         LineNumber = 0;
      353       353    1        #ifndef NOPP
      354       354    1         WorkingDir = getwdir(source);
      355       355    1        #endif NOPP
      356       356    1         PushLex();
      357       357    1
      358       358    1        #ifdef DEBUG
      359       359    1        #ifndef NOPP
      360       360    1         if (pp_only)   /* run the preprocessor as if it is stand-alone */
      361       361    1            preprocess();
      362       362    1         else
      363       363    1        #endif NOPP
      364       364    1        #endif DEBUG
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=11 
      365       365    1         {
      366       366    2
      367       367    2        #ifdef USE_TMP
      368       368    2            if (!options['N']) {
      369       369    3               init_code(tempfile);
      370       370    3        #if DATAFIRST
      371       371    3               EM_File_No++, init_code(tmpfile2), EM_File_No = 0;
      372       372    3        #endif
      373       373    3            }
      374       374    2            else
      375       375    2        #endif USE_TMP
      376       376    2            init_code(destination);
      377       377    2
      378       378    2          /* compile the source text         */
      379       379    2            C_program();
      380       380    2            end_code();
      381       381    2        #if DATAFIRST && defined(USE_TMP)
      382       382    2            if (!options['N'])
      383       383    2               EM_File_No = 1, C_close(), EM_File_No = 0;
      384       384    2        #endif
      385       385    2
      386       386    2        #ifdef USE_TMP
      387       387    2            if (! options['N']) {
      388       388    3               prepend_scopes(destination);
      389       389    3        #if DATAFIRST
      390       390    3               AppendFile(tmpfile2, destination);
      391       391    3               sys_remove(tmpfile2);
      392       392    3        #endif
      393       393    3               AppendFile(tempfile, destination);
      394       394    3               sys_remove(tempfile);
      395       395    3            }
      396       396    2        #endif USE_TMP
      397       397    2
      398       398    2        #ifdef DEBUG
      399       399    2            if (options['u']) {
      400       400    3               unstack_level();                               /* unstack L_GLOBAL */
      401       401    3            }
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=12 
      402       402    2            if (options['f'] || options['t'])
      403       403    2               dumpidftab("end of main", options['f'] ? 0 : 0);
      404       404    2        #endif DEBUG
      405       405    2         }
      406       406    1         PopLex();
      407       407    1
      408       408    1          GetFileName(OBJECT);    /* get Object unit name */
      409       409    1
      410       410    1        }
      411       411
      412       412             init()
      413       413             {
      414       414    1         init_cst();  /* initialize variables of "cstoper.c"      */
      415       415    1         reserve(tkidf);           /* mark the C reserved words as such */
      416       416    1         init_specials(special_ids);  /* mark special ids as such */
      417       417    1
      418       418    1        #ifndef NOROPTION
      419       419    1         if (options['R'])
      420       420    1            reserve(tkother);
      421       421    1        #endif
      422       422    1
      423       423    1         char_type  = standard_type(CHAR, signed_char, 1, (arith)1);
      424       424    1         uchar_type = standard_type(CHAR, UNSIGNED, 1, (arith)1);
      425       425    1         schar_type = standard_type(CHAR,   SIGNED, 1, (arith)1);
      426       426    1
      427       427    1         short_type = standard_type(SHORT, 0, short_align, short_size);
      428       428    1         ushort_type = standard_type(SHORT, UNSIGNED, short_align, short_size);
      429       429    1
      430       430    1        /*  Treat type `word' as `int', having its own size and
      431       431    1            alignment requirements.
      432       432    1            This type is transparent to the user.
      433       433    1         */
      434       434    1         word_type = standard_type(INT, 0, word_align, word_size);
      435       435    1         uword_type = standard_type(INT, UNSIGNED, word_align, word_size);
      436       436    1
      437       437    1         int_type = standard_type(INT, 0, int_align, int_size);
      438       438    1         sint_type = standard_type(INT,   SIGNED, int_align, int_size);
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=13 
      439       439    1         uint_type = standard_type(INT, UNSIGNED, int_align, int_size);
      440       440    1
      441       441    1         long_type = standard_type(LONG, 0, long_align, long_size);
      442       442    1         ulong_type = standard_type(LONG, UNSIGNED, long_align, long_size);
      443       443    1
      444       444    1        #ifndef NOFLOAT
      445       445    1         float_type = standard_type(FLOAT, 0, float_align, float_size);
      446       446    1         double_type = standard_type(DOUBLE, 0, double_align, double_size);
      447       447    1         ldouble_type = standard_type(DOUBLE, 0, double_align, double_size);
      448       448    1        #endif NOFLOAT
      449       449    1         void_type = standard_type(VOID, 0, 1, (arith)0);
      450       450    1         label_type = standard_type(LABEL, 0, 0, (arith)0);
      451       451    1         error_type = standard_type(ERRONEOUS, 0, 1, (arith)1);
      452       452    1
      453       453    1        /*  POINTER Arithmetic type: all arithmetics concerning
      454       454    1            pointers is supposed to be performed in the
      455       455    1            pointer arithmetic type which is equal to either
      456       456    1            int_type or long_type, depending on the pointer_size
      457       457    1         */
      458       458    1         if (pointer_size == word_size)
      459       459    1            pa_type = word_type;
      460       460    1         else
      461       461    1         if (pointer_size == short_size)
      462       462    1            pa_type = short_type;
      463       463    1         else
      464       464    1         if (pointer_size == int_size)
      465       465    1            pa_type = int_type;
      466       466    1         else
      467       467    1         if (pointer_size == long_size)
      468       468    1            pa_type = long_type;
      469       469    1         else
      470       470    1            fatal("pointer size incompatible with any integral size");
      471       471    1
      472       472    1         if (int_size != word_size)
      473       473    1            fatal("int_size and word_size are not equal");
      474       474    1         if (short_size > int_size || int_size > long_size)
      475       475    1            fatal("sizes of short/int/long decreasing");
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=14 
      476       476    1
      477       477    1        /* Build a type for function returning int, RM 13 */
      478       478    1         funint_type = construct_type(FUNCTION, int_type, (arith)0, (struct formal*)0)
                               ;
      479       479    1         string_type = construct_type(POINTER, char_type, (arith)0, (struct formal*)0)
                               ;
      480       480    1         voidptr_type = construct_type(POINTER, void_type, (arith)0, (struct formal*)0
                               );
      481       481    1
      482       482    1        /* Define the standard type identifiers. */
      483       483    1         add_def(str2idf("char"), TYPEDEF, char_type, L_UNIVERSAL);
      484       484    1         add_def(str2idf("int"), TYPEDEF, int_type, L_UNIVERSAL);
      485       485    1        #ifndef NOFLOAT
      486       486    1         add_def(str2idf("float"), TYPEDEF, float_type, L_UNIVERSAL);
      487       487    1         add_def(str2idf("double"), TYPEDEF, double_type, L_UNIVERSAL);
      488       488    1        #endif NOFLOAT
      489       489    1         add_def(str2idf("void"), TYPEDEF, void_type, L_UNIVERSAL);
      490       490    1         stack_level();
      491       491    1        }
      492       492
      493       493             init_specials(si)
      494       494              register struct sp_id *si;
      495       495             {
      496       496    1         int spec;
      497       497    1         while (si->si_identifier)  {
      498       498    2            struct idf *idf = str2idf(si->si_identifier);
      499       499    2
      500       500    2            if (idf->id_special)
      501       501    2               fatal("maximum identifier length insufficient");
      502       502    2            spec = si->si_flag;
      503       503    2            if (spec >= SP_BIBASE)  {     /* builtin function? */
      504       504    3               unsigned mask = 1<<(35 - (spec - 64));
      505       505    3               if (! (mask & CC_options->bi_off.bi_flags))   {
      506       506    4                  idf->id_special = spec;     /* really built in!  */
      507       507    4                  if (mask & CC_options->bi_on.bi_flags)    {
      508       508    5                     idf = str2idf(si->si_identifier+10);
      509       509    5                     idf->id_special = spec;
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=15 
      510       510    5                     }   /* end of build-in without __builtin_?    */
      511       511    4                  }      /* end of build it in                     */
      512       512    3               else idf->id_special = spec + (SP_BIXBASE - SP_BIBASE);
      513       513    3               }
      514       514    2            else idf->id_special = si->si_flag;
      515       515    2            si++;
      516       516    2         }
      517       517    1        }
      518       518
      519       519             #ifdef DEBUG
      520       520             #ifndef NOPP
      521       521             preprocess()
      522       522             {
      523       523    1        /*  preprocess() is the "stand-alone" preprocessor which
      524       524    1            consecutively calls the lexical analyzer LLlex() to get
      525       525    1            the tokens and prints them in a suitable way.
      526       526    1         */
      527       527    1         static unsigned int lastlineno = 0;
      528       528    1         static char *lastfilenm = "";
      529       529    1
      530       530    1         while (LLlex() !=  EOI) {
      531       531    2            if (lastlineno != dot.tk_line)   {
      532       532    3               if (strcmp(lastfilenm, dot.tk_file) == 0) {
      533       533    4                  if (dot.tk_line - lastlineno <= 1)  {
      534       534    5                     lastlineno++;
      535       535    5                     print("\n");
      536       536    5                  }
      537       537    4                  else  {
      538       538    5                     lastlineno = dot.tk_line;
      539       539    5                     if (!options['P'])
      540       540    5                        print("\n#line %ld \"%s\"\n",
      541       541    5                           lastlineno,
      542       542    5                           lastfilenm
      543       543    5                        );
      544       544    5                  }
      545       545    4               }
      546       546    3               else  {
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=16 
      547       547    4                  lastfilenm = dot.tk_file;
      548       548    4                  lastlineno = dot.tk_line;
      549       549    4                  if (!options['P'])
      550       550    4                     print("\n#line %ld \"%s\"\n",
      551       551    4                        lastlineno, lastfilenm);
      552       552    4               }
      553       553    3            }
      554       554    2            else
      555       555    2            if (strcmp(lastfilenm, dot.tk_file) != 0) {
      556       556    3               lastfilenm = dot.tk_file;
      557       557    3               if (!options['P'])
      558       558    3                  print("\n#line %ld \"%s\"\n",
      559       559    3                     lastlineno, lastfilenm);
      560       560    3            }
      561       561    2            switch (DOT)   {
      562       562    3            case IDENTIFIER:
      563       563    3            case TYPE_IDENTIFIER:
      564       564    3               print("%s ", dot.tk_idf->id_text);
      565       565    3               break;
      566       566    3            case STRING:
      567       567    3            {
      568       568    4               char sbuf[1024];                               /* a transient buffer */

      569       569    4               char *bts2str();
      570       570    4
      571       571    4               print("\"%s\" ", bts2str(dot.tk_bts, dot.tk_len, sbuf));
      572       572    4               break;
      573       573    4            }
      574       574    3            case INTEGER:
      575       575    3               print("%ld ", dot.tk_ival);
      576       576    3               break;
      577       577    3        #ifndef NOFLOAT
      578       578    3            case FLOATING:
      579       579    3               print("%s ", dot.tk_fval);
      580       580    3               break;
      581       581    3        #endif NOFLOAT
      582       582    3            case EOI:
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=17 
      583       583    3            case EOF:
      584       584    3               return;
      585       585    3            default:                                       /* very expensive... */
      586       586    3               print("%s ", symbol2str(DOT));
      587       587    3            }
      588       588    2         }
      589       589    1        }
      590       590             #endif NOPP
      591       591             #endif DEBUG
      592       592
      593       593             #ifdef USE_TMP
      594       594             AppendFile(src, dst)
      595       595              char *src, *dst;
      596       596             { extern int em_binary_option;
      597       597    1
      598       598    1         File *fp_src, *fp_dst;
      599       599    1         char buf[BUFSIZ];
      600       600    1         int n;
      601       601    1
      602       602    1         if (sys_open(src, OP_READ+em_binary_option, &fp_src) == 0)
      603       603    1            fatal("cannot read %s", src);
      604       604    1         if (dst) {
      605       605    2            if (sys_open(dst, OP_APPEND+em_binary_option, &fp_dst) == 0)
      606       606    2               fatal("cannot write to %s", src);
      607       607    2         }
      608       608    1         else
      609       609    1            fp_dst = STDOUT;
      610       610    1         while (sys_read(fp_src, buf, BUFSIZ, &n) != 0 && n > 0)
      611       611    1            if (sys_write(fp_dst, buf, n) == 0)
      612       612    1               fatal("(AppendFile) write error");
      613       613    1         if (n != 0)
      614       614    1            fatal("(AppendFile) read error");
      615       615    1         sys_close(fp_src);
      616       616    1         if (fp_dst != STDOUT)
      617       617    1            sys_close(fp_dst);
      618       618    1        }
      619       619             #endif USE_TMP
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=18 
      620       620
      621       621
      622       622             C_failed()
      623       623             {
      624       624    1         fatal("write failed");
      625       625    1        }
      626       626
      627       627
      628       628             char *
      629       629             GetFileName(FileType)
      630       630              int FileType;
      631       631              /* Purpose :
      632       632               *            This function returns filename strings translated
      633       633               *            from M$SI, M$UI or M$OU.
      634       634               *
      635       635               * FileType :
      636       636               *            SOURCE  :returns filename of M$SI
      637       637               *            UPDATE  :returns filename of M$UI
      638       638               *            OBJECT  :returns filename of M$OU
      639       639               */
      640       640             {
      641       641    1        extern int finform();
      642       642    1
      643       643    1        FILE_SET    M_SI_set;
      644       644    1        FILE        M_SI;
      645       645    1
      646       646    1              M_SI._fpt_read._v._dcb = FileType;
      647       647    1              if (!finform(&M_SI, &M_SI_set)) {
      648       648    2                register char *filename = M_SI_set.fid;
      649       649    2                switch (FileType) {
      650       650    3                case SOURCE:
      651       651    3                       return strcpy(source=Malloc(strlen(filename)+1), filename);
      652       652    3                case UPDATE:
      653       653    3                       return strcpy(result=Malloc(strlen(filename)+1), filename);
      654       654    3                case OBJECT:
      655       655    3                       return strcpy(destination=Malloc(strlen(filename)+1), filename)
                               ;
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=19 
      656       656    3                       break;
      657       657    3                default:
      658       658    3                       break;
      659       659    3                }
      660       660    2              }
      661       661    1              return (char *)0;
      662       662    1        }
---  Include file information  ---

   string:h.:LIB_E05. is referenced
   zbr$root_interface:h.:ZBC3TOU. is referenced
   xu_cp6_c:h.:LIB_E05. is referenced
   xu_macro_c:h.:LIB_E05. is referenced
   xux$interface_m:h.:LIB_E05. is referenced
   zbc$macro:h.:ZBC3TOU. is referenced
   zbc$nopp:h.:ZBC3TOU. is referenced
   zbc$idfsize:h.:ZBC3TOU. is referenced
   zbc$nofloat:h.:ZBC3TOU. is referenced
   system:h.:ZBC3TOU. is referenced
   zbc$target_sizes:h.:ZBC3TOU. is referenced
   zbc$debug:h.:ZBC3TOU. is referenced
   zbc$use_tmp:h.:ZBC3TOU. is referenced
   zbc$inputtype:h.:ZBC3TOU. is referenced
   zbc$input:h.:ZBC3TOU. is referenced
   inp_pkg:spec.:ZBC3TOU. is referenced
   zbc$level:h.:ZBC3TOU. is referenced
   zbc$idf:h.:ZBC3TOU. is referenced
   zbc$arith:h.:ZBC3TOU. is referenced
   zbc$spec_arith:h.:ZBC3TOU. is referenced
   em_arith:h.:ZBC3TOU. is referenced
   zbc$type:h.:ZBC3TOU. is referenced
   zbc$nobitfield:h.:ZBC3TOU. is referenced
   zbc$declar:h.:ZBC3TOU. is referenced
   zbc$tokenname:h.:ZBC3TOU. is referenced
   zbc$Lpars:h.:ZBC3TOU. is referenced
   zbc$LLlex:h.:ZBC3TOU. is referenced
   zbc$file_info:h.:ZBC3TOU. is referenced
CC.C03    File=zbr$cem_main:c.:ZBC3TSI                                              Fri Aug 22 1997  Page=20 
   alloc:h.:ZBC3TOU. is referenced
   zbc$specials:h.:ZBC3TOU. is referenced
   zbc$noRoption:h.:ZBC3TOU. is referenced
   zbc$nocross:h.:ZBC3TOU. is referenced
   zbc$sizes:h.:ZBC3TOU. is referenced
   zbc$align:h.:ZBC3TOU. is referenced
   zbc$zb_target:h.:ZBC3TOU. is referenced
   inp_types:h.:ZBC3TOU. is referenced
   zbc$dataFirst:h.:ZBC3TOU. is referenced
   stdio:h.:LIB_E05. is referenced
   fileinfo:h.:LIB_E05. is referenced

No diagnostics were issued in the file zbr$cem_main:c.:ZBC3TSI
