

CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=1  
        1         1             /*
        2         2              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3         3              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4         4              */
        5         5             /* $Header: domacro.c,v 3.11 87/03/20 08:26:31 ceriel Exp $ */
        6         6             /* PREPROCESSOR: CONTROLLINE INTERPRETER */
        7         7
        8         8             #include  "interface.h"
        9         9             #include  "arith.h"
       10        10             #include  "LLlex.h"
       11        11             #include  "Lpars.h"
       12        12             #include  "debug.h"
       13        13             #include  "idf.h"
       14        14             #include  "input.h"
       15        15             #include  "nopp.h"
       16        16             #include  "zb_target.h"
       17        17
       18        18             int tok = 0;
       19        19
       20        20
       21        21             #ifndef NOPP
       22        22             #include  "ifdepth.h"
       23        23             #include  "botch_free.h"
       24        24             #include  "nparams.h"
       25        25             #include  "parbufsize.h"
       26        26             #include  "textsize.h"
       27        27             #include  "idfsize.h"
       28        28             #include  "assert.h"
       29        29             #include  <alloc.h>
       30        30             #include  "class.h"
       31        31             #include  "macro.h"
       32        32
       33        33             IMPORT char *inctable[]; /* list of include directories      */
       34        34             IMPORT char *getwdir();
       35        35             PRIVATE char ifstack[IFDEPTH]; /* if-stack: the content of an entry is */
       36        36                       /* 1 if a corresponding ELSE has been  */
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=2  
       37        37                       /* encountered.            */
       38        38                 /* 2 while the if-expr is true. */
       39        39             PRIVATE int nestlevel = -1; /* initially no nesting level.    */
       40        40             char *_NIL_; /* uninitialized pointer      */
       41        41             int dont_skip_spaces; /* referenced in LLlex() */
       42        42             extern int zb_skipping;  /* declared in main() */
       43        43             int dont_replace_directives = 0; /* referenced in LLlex() */
       44        44
       45        45             PRIVATE struct idf *
       46        46             GetIdentifier()
       47        47             {
       48        48    1         /* returns a pointer to the descriptor of the identifier that is
       49        49    1            read from the input stream. A null-pointer is returned if
       50        50    1            the input does not contain an identifier.
       51        51    1            The substitution of macros is disabled.
       52        52    1         */
       53        53    1         struct token tk;
       54        54    1
       55        55    1         ReplaceMacros = 0;
       56        56    1         tok = GetToken(&tk);
       57        57    1         ReplaceMacros = 1;
       58        58    1         return tok == IDENTIFIER ? tk.tk_idf : (struct idf *)0;
       59        59    1        }
       60        60
       61        61             /*  domacro() is the control line interpreter. The '#' has already
       62        62              been read by the lexical analyzer by which domacro() is called.
       63        63              The token appearing directly after the '#' is obtained by calling
       64        64              the basic lexical analyzing function GetToken() and is interpreted
       65        65              to perform the action belonging to that token.
       66        66              An error message is produced when the token is not recognized,
       67        67              i.e. it is not one of "define" .. "undef" , integer or newline.
       68        68             */
       69        69             EXPORT
       70        70             domacro()
       71        71             {
       72        72    1         struct token tk;  /* the token itself        */
       73        73    1
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=3  
       74        74    1         dont_replace_directives = 1;
       75        75    1         EoiForNewline = 1;
       76        76    1         SkipEscNewline = 1;
       77        77    1         switch(GetToken(&tk)) {    /* select control line action */
       78        78    2         case IDENTIFIER:     /* is it a macro keyword?  */
       79        79    2            switch (tk.tk_idf->id_resmac) {
       80        80    3            case K_DEFINE:          /* "define" */
       81        81    3               do_define();
       82        82    3               break;
       83        83    3            case K_ELIF:            /* "elif"   */
       84        84    3               do_elif();
       85        85    3               break;
       86        86    3            case K_ELSE:            /* "else"   */
       87        87    3               do_else();
       88        88    3               break;
       89        89    3            case K_ENDIF:           /* "endif"  */
       90        90    3               do_endif();
       91        91    3               break;
       92        92    3            case K_IF:           /* "if"     */
       93        93    3               do_if();
       94        94    3               break;
       95        95    3            case K_IFDEF:           /* "ifdef"  */
       96        96    3               do_ifdef(1);
       97        97    3               break;
       98        98    3            case K_IFNDEF:          /* "ifndef" */
       99        99    3               do_ifdef(0);
      100       100    3               break;
      101       101    3            case K_INCLUDE:            /* "include"   */
      102       102    3               do_include();
      103       103    3               break;
      104       104    3            case K_LINE:            /* "line"   */
      105       105    3               /* set LineNumber and FileName according to
      106       106    3                  the arguments.
      107       107    3               */
      108       108    3               if ((tok = GetToken(&tk)) != INTEGER) {
      109       109    4                  lexerror("#line without linenumber");
      110       110    4                  if (tok != EOI) SkipRestOfLine();
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=4  
      111       111    4               }
      112       112    3               else
      113       113    3                  do_line((unsigned int)tk.tk_ival);
      114       114    3               break;
      115       115    3            case K_UNDEF:           /* "undef"  */
      116       116    3               do_undef();
      117       117    3               break;
      118       118    3          case K_PRAGMA : /* "pragma " */
      119       119    3           do_pragma();
      120       120    3           break;
      121       121    3          case K_ERROR  : /* "error"   */
      122       122    3           do_error();
      123       123    3           break;
      124       124    3            default:
      125       125    3               /* invalid word seen after the '#'  */
      126       126    3               lexerror("%s: unknown control", tk.tk_idf->id_text);
      127       127    3               SkipRestOfLine();
      128       128    3            }
      129       129    2            break;
      130       130    2         case INTEGER:     /* # <integer> [<filespecifier>]?   */
      131       131    2            do_line((unsigned int)tk.tk_ival);
      132       132    2            break;
      133       133    2         case EOI:   /* only `#' on this line: do nothing, ignore */
      134       134    2            break;
      135       135    2         default: /* invalid token following '#'      */
      136       136    2            lexerror("illegal # line");
      137       137    2            SkipRestOfLine();
      138       138    2         }
      139       139    1         dont_replace_directives = 0;
      140       140    1         EoiForNewline = 0;
      141       141    1         SkipEscNewline = 0;
      142       142    1        }
      143       143
      144       144             PRIVATE
      145       145             skip_block()
      146       146             {
      147       147    1         /* skip_block() skips the input from
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=5  
      148       148    1            1) a false #if, #ifdef, #ifndef or #elif until the
      149       149    1               corresponding #elif (resulting in true), #else or
      150       150    1               #endif is read.
      151       151    1            2) a #else or a #elif corresponding to a true #if, #ifdef,
      152       152    1               #ifndef or #elif until the corresponding #endif is
      153       153    1               seen.
      154       154    1         */
      155       155    1        #define Corresponding_Ifexpr_Is_False (!(ifstack[nestlevel] & 2))
      156       156    1         register int ch;
      157       157    1         register int skiplevel = nestlevel; /* current nesting level */
      158       158    1         struct token tk;
      159       159    1         extern char options[];
      160       160    1
      161       161    1         NoUnstack++;
      162       162    1         zb_skipping++;
      163       163    1         for (;;) {
      164       164    2            LoadChar(ch);  /* read first character after newline  */
      165       165    2          ch = skipspaces(ch);
      166       166    2            if (ch != '#') {
      167       167    3               if (ch == EOI) {
      168       168    4                  NoUnstack--;
      169       169    4            zb_skipping--;
      170       170    4                  return;
      171       171    4               }
      172       172    3               SkipRestOfLine();
      173       173    3               continue;
      174       174    3            }
      175       175    2          dont_replace_directives = 1;
      176       176    2            if ((tok = GetToken(&tk)) != IDENTIFIER) {
      177       177    3               if (tok != EOI) SkipRestOfLine();
      178       178    3           dont_replace_directives = 0;
      179       179    3               continue;
      180       180    3            }
      181       181    2          dont_replace_directives = 0;
      182       182    2            /* an IDENTIFIER: look for #if, #ifdef and #ifndef
      183       183    2               without interpreting them.
      184       184    2               Interpret #else, #elif and #endif if they occur
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=6  
      185       185    2               on the same level.
      186       186    2            */
      187       187    2            switch(tk.tk_idf->id_resmac) {
      188       188    3            case K_IF:
      189       189    3            case K_IFDEF:
      190       190    3            case K_IFNDEF:
      191       191    3               push_if();
      192       192    3               break;
      193       193    3            case K_ELIF:
      194       194    3               if (nestlevel == skiplevel) {
      195       195    4           if (Corresponding_Ifexpr_Is_False) {
      196       196    5                  nestlevel--;
      197       197    5                  push_if();
      198       198    5            NoUnstack--;
      199       199    5                  if (ifexpr()) {
      200       200    6             ifstack[nestlevel] |= 2;
      201       201    6             zb_skipping--;
      202       202    6                     return;
      203       203    6                  }
      204       204    5            else
      205       205    5              NoUnstack++;
      206       206    5            }
      207       207    4            else {
      208       208    5             if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      209       209    6                lexerror("only new-line character allowed after constant-expression");

      210       210    6             }
      211       211    5             if (tok != EOI) SkipRestOfLine();
      212       212    5            }
      213       213    4               }
      214       214    3               break;
      215       215    3            case K_ELSE:
      216       216    3           ifstack[nestlevel] |= 1;
      217       217    3               if (nestlevel == skiplevel) {
      218       218    4           if (Corresponding_Ifexpr_Is_False) {
      219       219    5            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      220       220    6               lexerror("only new-line character allowed after \"else\"");
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=7  
      221       221    6            }
      222       222    5                  if (tok != EOI) SkipRestOfLine();
      223       223    5                  NoUnstack--;
      224       224    5            zb_skipping--;
      225       225    5                  return;
      226       226    5               }
      227       227    4           }
      228       228    3           else {
      229       229    4            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      230       230    5               lexerror("only new-line character allowed after \"else\"");
      231       231    5            }
      232       232    4            if (tok != EOI) SkipRestOfLine();
      233       233    4           }
      234       234    3               break;
      235       235    3            case K_ENDIF:
      236       236    3               ASSERT(nestlevel >= 0);
      237       237    3               if (nestlevel == skiplevel) {
      238       238    4            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      239       239    5               lexerror("only new-line character allowed after \"endif\"");
      240       240    5            }
      241       241    4                  if (tok != EOI) SkipRestOfLine();
      242       242    4                  nestlevel--;
      243       243    4                  NoUnstack--;
      244       244    4            zb_skipping--;
      245       245    4                  return;
      246       246    4               }
      247       247    3               nestlevel--;
      248       248    3               break;
      249       249    3            }
      250       250    2         }
      251       251    1        }
      252       252
      253       253             PRIVATE
      254       254             ifexpr()
      255       255             {
      256       256    1         /* ifexpr() returns whether the restricted constant
      257       257    1            expression following #if or #elif evaluates to true.  This
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=8  
      258       258    1            is done by calling the LLgen generated subparser for
      259       259    1            constant expressions.  The result of this expression will
      260       260    1            be given in the extern long variable "ifval".
      261       261    1         */
      262       262    1         IMPORT arith ifval;
      263       263    1         int errors = err_occurred;
      264       264    1
      265       265    1         ifval = (arith)0;
      266       266    1         AccDefined = 1;
      267       267    1         UnknownIdIsZero = 1;
      268       268    1         PushLex();  /* NEW parser */
      269       269    1         If_expr();  /* invoke constant expression parser   */
      270       270    1         PopLex();   /* OLD parser */
      271       271    1         AccDefined = 0;
      272       272    1         UnknownIdIsZero = 0;
      273       273    1         return (errors == err_occurred) && (ifval != (arith)0);
      274       274    1        }
      275       275
      276       276             PRIVATE
      277       277             do_include()
      278       278             {
      279       279    1         /* do_include() performs the inclusion of a file.
      280       280    1         */
      281       281    1         extern char options[];
      282       282    1         char *filenm;
      283       283    1         char *result;
      284       284    1         struct token tk;
      285       285    1         extern zb_LS_include_flag;
      286       286    1
      287       287    1         AccFileSpecifier = 1;
      288       288    1         if (((tok = GetToken(&tk)) == FILESPECIFIER) || tok == STRING)
      289       289    1            filenm = tk.tk_bts;
      290       290    1         else {
      291       291    2            lexerror("bad include syntax");
      292       292    2            filenm = (char *)0;
      293       293    2         }
      294       294    1         AccFileSpecifier = 0;
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=9  
      295       295    1         if (tok != EOI) SkipRestOfLine();
      296       296    1         inctable[0] = WorkingDir;
      297       297    1         if (filenm) {
      298       298    2        /* inctable[0] contains the curent directory, if Unix search option
      299       299    2         * is on and the filename is enclosed by double quotes, then search
      300       300    2         * from the current directory then the search list, otherwise
      301       301    2         * search the search list first (i.e. inctable[1])
      302       302    2         */
      303       303    2            if (!InsertFile(filenm, &inctable[ !( tok==STRING && options['X'] ) ], &re
                               sult)){
      304       304    3               lexerror("cannot find include file \"%s\"", filenm);
      305       305    3            }
      306       306    2            else {
      307       307    3               WorkingDir = getwdir(result);
      308       308    3               File_Inserted = 1;
      309       309    3               FileName = result;
      310       310    3               finfo.ExprLines = 0;
      311       311    3               finfo.ErrorLines = 0;
      312       312    3               finfo.StartLine = DebugLineBias;
      313       313    3               LineNumber = 0;
      314       314    3           if (zb_LS_include_flag) finfo.ErrorLines++;
      315       315    3            }
      316       316    2         }
      317       317    1        }
      318       318
      319       319             PRIVATE
      320       320             do_define()
      321       321             {
      322       322    1         /* do_define() interprets a #define control line.
      323       323    1         */
      324       324    1         struct idf *id;      /* the #defined identifier's descriptor */
      325       325    1         int nformals = -1;   /* keep track of the number of formals */
      326       326    1         char *formals[NPARAMS]; /* pointers to the names of the formals */
      327       327    1         char parbuf[PARBUFSIZE];      /* names of formals  */
      328       328    1         char *repl_text;  /* start of the replacement text */
      329       329    1         int length;    /* length of the replacement text   */
      330       330    1         register ch;
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=10 
      331       331    1         char *get_text();
      332       332    1
      333       333    1         /* read the #defined macro's name   */
      334       334    1         dont_skip_spaces = 1;
      335       335    1         if (!(id = GetIdentifier())) {
      336       336    2          dont_skip_spaces = 0;
      337       337    2            lexerror("#define: illegal macro name");
      338       338    2            if (tok != EOI) SkipRestOfLine();
      339       339    2            return;
      340       340    2         }
      341       341    1         dont_skip_spaces = 0;
      342       342    1         /* there is a formal parameter list if the identifier is
      343       343    1            followed immediately by a '('.
      344       344    1         */
      345       345    1         LoadChar(ch);
      346       346    1         while (ch == EOR) LoadChar(ch);
      347       347    1         if (ch == '(') {
      348       348    2            if ((nformals = getparams(formals, parbuf)) == -1) {
      349       349    3               SkipRestOfLine();
      350       350    3               return;  /* an error occurred */
      351       351    3            }
      352       352    2            LoadChar(ch);
      353       353    2         }
      354       354    1         /* read the replacement text if there is any       */
      355       355    1         ch = skipspaces(ch); /* find first character of the text */
      356       356    1         ASSERT(ch != EOI);
      357       357    1         if (class(ch) == STNL) {
      358       358    2            /* Treat `#define something' as `#define something ""'
      359       359    2            */
      360       360    2            repl_text = "";
      361       361    2            length = 0;
      362       362    2         }
      363       363    1         else {
      364       364    2            PushBack();
      365       365    2            repl_text = get_text((nformals > 0) ? formals : 0, &length, id->id_text);
      366       366    2         }
      367       367    1         macro_def(id, formals, repl_text, nformals, length, NOFLAG);
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=11 
      368       368    1         AdjustLineNumber;
      369       369    1        }
      370       370
      371       371             PRIVATE
      372       372             push_if()
      373       373             {
      374       374    1         if (nestlevel >= IFDEPTH)
      375       375    1            fatal("too many nested #if/#ifdef/#ifndef");
      376       376    1         else
      377       377    1            ifstack[++nestlevel] = 0;
      378       378    1        }
      379       379
      380       380             PRIVATE
      381       381             do_elif()
      382       382             {
      383       383    1         if (nestlevel < 0 || (ifstack[nestlevel] & 1)) {
      384       384    2            lexerror("#elif without corresponding #if");
      385       385    2            SkipRestOfLine();
      386       386    2         }
      387       387    1         else { /* restart at this level as if a #if is detected.  */
      388       388    2            skip_block();
      389       389    2         }
      390       390    1        }
      391       391
      392       392             PRIVATE
      393       393             do_else()
      394       394             {
      395       395    1         struct token tk;
      396       396    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      397       397    2            lexerror("only new-line character allowed after \"else\"");
      398       398    2         }
      399       399    1         if (tok != EOI) SkipRestOfLine();
      400       400    1         if (nestlevel < 0 || (ifstack[nestlevel] & 1))
      401       401    1            lexerror("#else without corresponding #if");
      402       402    1         else {   /* mark this level as else-d     */
      403       403    2          ifstack[nestlevel] |= 1;
      404       404    2            skip_block();
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=12 
      405       405    2         }
      406       406    1        }
      407       407
      408       408             PRIVATE
      409       409             do_endif()
      410       410             {
      411       411    1         struct token tk;
      412       412    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      413       413    2            lexerror("only new-line character allowed after \"endif\"");
      414       414    2         }
      415       415    1         if (tok != EOI) SkipRestOfLine();
      416       416    1         ifstack[nestlevel] = 0;
      417       417    1         if (nestlevel < 0)   {
      418       418    2            lexerror("#endif without corresponding #if");
      419       419    2         }
      420       420    1         else  nestlevel--;
      421       421    1        }
      422       422
      423       423             PRIVATE
      424       424             do_if()
      425       425             {
      426       426    1         push_if();
      427       427    1         if (!ifexpr()) /* a false #if/#elif expression */
      428       428    1            skip_block();
      429       429    1         else
      430       430    1          ifstack[nestlevel] |= 2;
      431       431    1        }
      432       432
      433       433             PRIVATE
      434       434             do_ifdef(how)
      435       435             {
      436       436    1         register struct idf *id;
      437       437    1         struct token tk;
      438       438    1
      439       439    1         /* how == 1 : ifdef; how == 0 : ifndef
      440       440    1         */
      441       441    1         push_if();
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=13 
      442       442    1         if (!(id = GetIdentifier()))
      443       443    1          if (how) {
      444       444    2             lexerror("illegal #ifdef construction");
      445       445    2          }
      446       446    1          else {
      447       447    2             lexerror("illegal #ifndef construction");
      448       448    2          }
      449       449    1
      450       450    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      451       451    2            if (how) {
      452       452    3              lexerror("only one identifier and new-line character allowed after \"ifd
                               ef\"");
      453       453    3            }
      454       454    2            else {
      455       455    3              lexerror("only one identifier and new-line character allowed after \"ifn
                               def\"");
      456       456    3            }
      457       457    2         }
      458       458    1         /* The next test is a shorthand for:
      459       459    1            (how && !id->id_macro) || (!how && id->id_macro)
      460       460    1         */
      461       461    1         if (how ^ (id && id->id_macro != 0))
      462       462    1            skip_block();
      463       463    1         else {
      464       464    2           ifstack[nestlevel] |= 2;
      465       465    2            if (tok != EOI) SkipRestOfLine();
      466       466    2         }
      467       467    1        }
      468       468
      469       469             PRIVATE
      470       470             do_pragma()
      471       471             {
      472       472    1          /* The current options include :
      473       473    1             #pragma LIST ON
      474       474    1             #pragma LIST OFF
      475       475    1             #pragma LIST INCLUDE_ON
      476       476    1             #pragma LIST INCLUDE_OFF
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=14 
      477       477    1             #pragma LIST SPACE
      478       478    1             #pragma LIST SPACE n
      479       479    1             #pragma LIST EJECT
      480       480    1          */
      481       481    1          /* Some recommendations:
      482       482    1             #pragma LIST EJECT, INCLUDE_ON
      483       483    1
      484       484    1             #pragma LIST OFF
      485       485    1             #pragma LIST INCLUDE_ON still get a listing
      486       486    1          */
      487       487    1
      488       488    1         extern int zb_LS_flag;          /* 1 - LIST ON, 0 - LIST OFF */
      489       489    1         extern int zb_LS_include_flag;  /* 1 - LIST INCLUDE_ON, 0 - LIST INCLUDE_OFF
                               */
      490       490    1         extern void zb_listing_eject(); /* LIST should be ON */
      491       491    1         extern void zb_listing_space(); /* n = 1 for LIST SPACE */
      492       492    1         struct idf *id;
      493       493    1         struct token tk;
      494       494    1
      495       495    1         if (id = GetIdentifier()) { /* we are looking for "LIST" */
      496       496    2          if (!strcmp(id->id_text, "LIST")) {
      497       497    3            if (!(id = GetIdentifier())) { /* #pragma LIST */
      498       498    4               zb_LS_flag = 1;
      499       499    4            }
      500       500    3            else {
      501       501    4               switch (*(id->id_text)) {
      502       502    5
      503       503    5               case 'O': /* ON or OFF */
      504       504    5
      505       505    5                         if ( !strcmp(id->id_text, "ON")) { /* LIST ON */
      506       506    6                            zb_LS_flag = 1;
      507       507    6                         }
      508       508    5                         else
      509       509    5                         if ( !strcmp(id->id_text, "OFF")){ /* LIST OFF */
      510       510    6                            zb_LS_flag = 0;
      511       511    6                         }
      512       512    5                         break;
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=15 
      513       513    5
      514       514    5               case 'I': /* INCLUDE_ON or INCLUDE_OFF */
      515       515    5
      516       516    5                         if ( !strcmp(id->id_text, "INCLUDE_ON")) { /* INCLUDE_ON */
      517       517    6                            zb_LS_include_flag = 1;
      518       518    6                            finfo.ErrorLines++;
      519       519    6                         }
      520       520    5                         else
      521       521    5                         if ( !strcmp(id->id_text, "INCLUDE_OFF")){ /* INCLUDE_OFF */
      522       522    6                            if (zb_LS_include_flag && finfo.ErrorLines) finfo.ErrorLin
                               es--;
      523       523    6                            zb_LS_include_flag = 0;
      524       524    6                         }
      525       525    5                         break;
      526       526    5
      527       527    5               case 'S': /* SPACE */
      528       528    5
      529       529    5                         if (!strcmp(id->id_text, "SPACE")) {
      530       530    6                            if ((tok = GetToken(&tk) != INTEGER)) {
      531       531    7                               zb_listing_space(1);
      532       532    7                            }
      533       533    6                            else {
      534       534    7                               zb_listing_space(tk.tk_ival);
      535       535    7                            }
      536       536    6                         }
      537       537    5                         break;
      538       538    5
      539       539    5               case 'E': /* EJECT */
      540       540    5
      541       541    5                         zb_listing_eject();
      542       542    5                         break;
      543       543    5
      544       544    5               default :
      545       545    5                          break;
      546       546    5              } /* switch */
      547       547    4            } /* else */
      548       548    3          } /* "LIST" */
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=16 
      549       549    2         } /* if */
      550       550    1         if (tok != EOI) SkipRestOfLine();
      551       551    1
      552       552    1        }/* do_pragma */
      553       553
      554       554             PRIVATE
      555       555             do_undef()
      556       556             {
      557       557    1         register struct idf *id;
      558       558    1         struct token tk;
      559       559    1
      560       560    1         /* Forget a macro definition. */
      561       561    1         if (id = GetIdentifier()) {
      562       562    2            if (id->id_macro) { /* forget the macro */
      563       563    3               free_macro(id->id_macro);
      564       564    3               id->id_macro = (struct macro *) 0;
      565       565    3            } /* else: don't complain */
      566       566    2          if (options['A'] && (tok = GetToken(&tk)) != EOI) {
      567       567    3             lexerror("only one identifier and new-line character allowed after \"unde
                               f\"");
      568       568    3          }
      569       569    2         }
      570       570    1         else
      571       571    1            lexerror("illegal #undef construction");
      572       572    1         if (tok != EOI) SkipRestOfLine();
      573       573    1        }
      574       574
      575       575
      576       576             do_error()
      577       577             {
      578       578    1        /* do_error interprets a #error control line, this
      579       579    1           directive produces a compile-time error message that
      580       580    1           includes character sequence after #error.
      581       581    1        */
      582       582    1
      583       583    1
      584       584    1        int i=0;
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=17 
      585       585    1
      586       586    1        char buffer[2048];
      587       587    1        char c;
      588       588    1
      589       589    1        LoadChar(c);
      590       590    1        while (class(c) != STNL && c!= EOI) {
      591       591    2              buffer[i++] = c;
      592       592    2              LoadChar(c);
      593       593    2        }
      594       594    1        buffer[i] = '\0';
      595       595    1        lexerror("%s\n", buffer);
      596       596    1
      597       597    1        PushBack();
      598       598    1        skipline();
      599       599    1        }
      600       600             PRIVATE int
      601       601             getparams(buf, parbuf)
      602       602              char *buf[];
      603       603              char parbuf[];
      604       604             {
      605       605    1         /* getparams() reads the formal parameter list of a macro
      606       606    1            definition.
      607       607    1            The number of parameters is returned.
      608       608    1            As a formal parameter list is expected when calling this
      609       609    1            routine, -1 is returned if an error is detected, for
      610       610    1            example:
      611       611    1               #define one(1), where 1 is not an identifier.
      612       612    1            Note that the '(' has already been eaten.
      613       613    1            The names of the formal parameters are stored into parbuf.
      614       614    1         */
      615       615    1         register char **pbuf = &buf[0];
      616       616    1         register char **epbuf = &buf[NPARAMS];
      617       617    1         register int c;
      618       618    1         register char *ptr = &parbuf[0];
      619       619    1         register char **pbuf2;
      620       620    1
      621       621    1         LoadChar(c);
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=18 
      622       622    1         c = skipspaces(c);
      623       623    1         if (c == ')') {      /* no parameters: #define name() */
      624       624    2            *pbuf = (char *) 0;
      625       625    2            return 0;
      626       626    2         }
      627       627    1         for (;;) {     /* eat the formal parameter list */
      628       628    2            if (class(c) != STIDF) {   /* not an identifier */
      629       629    3               lexerror("#define: bad formal parameter");
      630       630    3               return -1;
      631       631    3            }
      632       632    2            *pbuf = ptr;   /* name of the formal   */
      633       633    2            *ptr++ = c;
      634       634    2            if (ptr >= &parbuf[PARBUFSIZE])
      635       635    2               fatal("formal parameter buffer overflow");
      636       636    2            do {        /* eat the identifier name */
      637       637    3               LoadChar(c);
      638       638    3               *ptr++ = c;
      639       639    3               if (ptr >= &parbuf[PARBUFSIZE])
      640       640    3                  fatal("formal parameter buffer overflow");
      641       641    3            } while (in_idf(c));
      642       642    2            *(ptr - 1) = '\0';   /* mark end of the name    */
      643       643    2
      644       644    2            /* Check if this formal parameter is already used.
      645       645    2               Usually, macros do not have many parameters, so ...
      646       646    2            */
      647       647    2            for (pbuf2 = pbuf - 1; pbuf2 >= &buf[0]; pbuf2--) {
      648       648    3               if (!strcmp(*pbuf2, *pbuf)) {
      649       649    4                  warning("formal parameter \"%s\" already used",
      650       650    4                     *pbuf);
      651       651    4               }
      652       652    3            }
      653       653    2
      654       654    2            pbuf++;
      655       655    2            if (pbuf >= epbuf) {
      656       656    3               lexerror("#define: too many parameters");
      657       657    3               return -1;
      658       658    3               }
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=19 
      659       659    2            c = skipspaces(c);
      660       660    2            if (c == ')') {   /* end of the formal parameter list */
      661       661    3               *pbuf = (char *) 0;
      662       662    3               return pbuf - buf;
      663       663    3            }
      664       664    2            if (c != ',') {
      665       665    3               lexerror("#define: bad formal parameter list");
      666       666    3               return -1;
      667       667    3            }
      668       668    2            LoadChar(c);
      669       669    2            c = skipspaces(c);
      670       670    2         }
      671       671    1         /*NOTREACHED*/
      672       672    1        }
      673       673
      674       674             EXPORT
      675       675             macro_def(id, formals, text, nformals, length, flags)
      676       676              register struct idf *id;
      677       677              char *formals[];
      678       678              char *text;
      679       679             {
      680       680    1         register struct macro *newdef = id->id_macro;
      681       681    1
      682       682    1         /* macro_def() puts the contents and information of a macro
      683       683    1            definition into a structure and stores it into the symbol
      684       684    1            table entry belonging to the name of the macro.
      685       685    1            A warning is given if the definition overwrites another.
      686       686    1         */
      687       687    1         if (newdef) {     /* is there a redefinition?   */
      688       688    2          if (nformals != newdef->mc_nps) {
      689       689    3             if (nformals == -1) {
      690       690    4                   lexerror("redefine a function-like macro as an object-like macro");

      691       691    4             }
      692       692    3             else
      693       693    3             if (newdef->mc_nps == -1) {
      694       694    4                   lexerror("redefine an object-like macro as a function-like macro");
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=20 

      695       695    4             }
      696       696    3             else {
      697       697    4                   lexerror("redefine a function-like macro with different number of p
                               arameters");
      698       698    4             }
      699       699    3             return;
      700       700    3          }
      701       701    2          else
      702       702    2          if (newdef->mc_nps > 0 && formals) {
      703       703    3          /* function-like macros with same name and same num. of params. */
      704       704    3             char **ip = &formals[0];
      705       705    3             char **jp = &(newdef->mc_formals)[0];
      706       706    3
      707       707    3             while (*ip) {
      708       708    4                if (!macroeq(*jp++, *ip++)) {
      709       709    5                   lexerror("different spelling of parameters of function-like macros"
                               );
      710       710    5                   return;
      711       711    5                }
      712       712    4             }
      713       713    3          }
      714       714    2            if (macroeq(newdef->mc_text, text))
      715       715    2               return;
      716       716    2            lexwarning("redefine \"%s\"", id->id_text);
      717       717    2         }
      718       718    1         else
      719       719    1            id->id_macro = newdef = new_macro();
      720       720    1         if (nformals > 0 && formals) { /* store formal parameters list */
      721       721    2            char **ip = &formals[0];
      722       722    2            char **jp = &(newdef->mc_formals)[0];
      723       723    2
      724       724    2            while (*ip) {
      725       725    3               *jp = Malloc(1+strlen(*ip));
      726       726    3               strcpy(*jp++, *ip++);
      727       727    3            }
      728       728    2            *jp = 0;
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=21 
      729       729    2         }
      730       730    1
      731       731    1         newdef->mc_name = id->id_text; /* macro name */
      732       732    1         newdef->mc_text = text;    /* replacement text  */
      733       733    1         newdef->mc_nps  = nformals;   /* nr of formals  */
      734       734    1         newdef->mc_length = length;   /* length of repl. text */
      735       735    1         newdef->mc_flag = flags;   /* special flags  */
      736       736    1         newdef->mc_count = 0;
      737       737    1        }
      738       738
      739       739             PRIVATE int
      740       740             find_name(nm, index)
      741       741              char *nm, *index[];
      742       742             {
      743       743    1         /* find_name() returns the index of "nm" in the namelist
      744       744    1            "index" if it can be found there.  0 is returned if it is
      745       745    1            not there.
      746       746    1         */
      747       747    1         register char **ip = &index[0];
      748       748    1
      749       749    1         while (*ip)
      750       750    1            if (strcmp(nm, *ip++) == 0)
      751       751    1               return ip - &index[0];
      752       752    1         /* arrived here, nm is not in the name list. */
      753       753    1         return 0;
      754       754    1        }
      755       755
      756       756             PRIVATE char *
      757       757             get_text(formals, length, macro_name)
      758       758              char *formals[];
      759       759              int *length;
      760       760              char *macro_name;
      761       761             {
      762       762    1         /* get_text() copies the replacement text of a macro
      763       763    1            definition with zero, one or more parameters, thereby
      764       764    1            substituting each formal parameter by a special character
      765       765    1            (non-ascii: 0200 & (order-number in the formal parameter
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=22 
      766       766    1            list)) in order to substitute this character later by the
      767       767    1            actual parameter.  The replacement text is copied into
      768       768    1            itself because the copied text will contain fewer or the
      769       769    1            same amount of characters.  The length of the replacement
      770       770    1            text is returned.
      771       771    1
      772       772    1            Implementation:
      773       773    1            finite automaton : we are only interested in
      774       774    1            identifiers, because they might be replaced by some actual
      775       775    1            parameter.  Other tokens will not be seen as such.
      776       776    1         */
      777       777    1         register int c;
      778       778    1         register int text_size;
      779       779    1         char *text = Malloc(text_size = ITEXTSIZE);
      780       780    1         register int pos = 0;
      781       781    1         register unsigned int string_literal = 0;
      782       782    1         extern char options[];
      783       783    1         register unsigned int formal_param_pushed = 0;
      784       784    1            /* true if top of text is a formal parameter */
      785       785    1         register unsigned int single_pound_pushed = 0;
      786       786    1            /* true if top of text is a '#' operator */
      787       787    1         register int single_pound_position = 0;
      788       788    1         register int dont_fetch_c = 0;
      789       789    1         register int kr = options['R'];
      790       790    1
      791       791    1        #define RESET_fpp {if (formal_param_pushed) formal_param_pushed = 0;}
      792       792    1        #define check_spp {if (single_pound_pushed){single_pound_pushed=0;\
      793       792    1              if (string_literal) text[single_pound_position] = '#'; \
      794       792    1        }}
      795       795    1
      796       796    1         LoadChar(c);
      797       797    1
      798       798    1
      799       799    1        /*
      800       800    1          The following "while" loop scans the define replacement text
      801       801    1          producing the saved replacement text with special marks for
      802       802    1          actions required at expansion time.  The following special
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=23 
      803       803    1          characters are handled:
      804       804    1
      805       805    1          1) \ followed by a newline character indicates that the
      806       806    1             definition is to extend to the next line.
      807       807    1
      808       808    1          2) if we are within a "string" or a 'string' then no special
      809       809    1             handling of the string contents is performed, we simply
      810       810    1             look for the end of the string.
      811       811    1
      812       812    1          3) if a / is followed by a *, then we skip the comment
      813       813    1             replacing it with a single blank (or nothing if restricted
      814       814    1             K&R mode is required).
      815       815    1
      816       816    1          4) if a # is found, it is expanded into either a stringization
      817       817    1             (single #) or an identifier merge (double ##).
      818       818    1
      819       819    1          5) if a ( is found following a formal parameter name, it is
      820       820    1             marked with a FORMAL_OPEN flag.
      821       821    1
      822       822    1          6) if an identifier is found, it is first determined whether it
      823       823    1             is an identifier or a formal paramter.  Formal parameters are
      824       824    1             marked with their parameter position, otherwise, the name of
      825       825    1             the identifier is copied (preceded by a RECURSIVE marker if
      826       826    1             the identifier is the name of the macro being defined).
      827       827    1        */
      828       828    1
      829       829    1          while ( (c != EOI)  &&  (class(c) != STNL) )   {
      830       830    2
      831       831    2            if (string_literal && c != '\\' && ( !kr || STIDF != class(c))) {
      832       832    3              if (c == string_literal)
      833       833    3                string_literal = 0;
      834       834    3              text[pos++] = c;
      835       835    3            }
      836       836    2            else
      837       837    2            switch (c)  {   /***  actions on '\', '''', '"', '/', '#' and '(' */
      838       838    3
      839       839    3            case '\\':      /** check for continuation of definition **/
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=24 
      840       840    3              LoadChar(c);
      841       841    3              if ('\n' == c) {
      842       842    4                  text[pos++] = ' ';
      843       843    4                  AdjustLineNumber;
      844       844    4                  break;
      845       845    4                }
      846       846    3              formal_param_pushed = 0;
      847       847    3              check_spp;
      848       848    3              text[pos++] = '\\';
      849       849    3              if (c != '\\') {
      850       850    4                 dont_fetch_c++;
      851       851    4                 if (c && c == string_literal)
      852       852    4                   string_literal = 0;   /* will restart this literal next */
      853       853    4                 }
      854       854    3              else {
      855       855    4                 if (pos >= text_size)
      856       856    4                    text = Srealloc(text, text_size += RTEXTSIZE*2);
      857       857    4                 text[pos++] = c;
      858       858    4                 }
      859       859    3              break;
      860       860    3
      861       861    3            case '\'':   /** a quoted int       **/
      862       862    3            case '"':    /** a quoted string    **/
      863       863    3              text[pos++] = c;
      864       864    3              string_literal = c;
      865       865    3              break;
      866       866    3
      867       867    3            case '/':    /** a possible comment **/
      868       868    3              LoadChar(c);
      869       869    3              if ('*' == c) {
      870       870    4                skipcomment();
      871       871    4                if (!kr)
      872       872    4                  text[pos++] = ' ';
      873       873    4                break;
      874       874    4              }
      875       875    3              dont_fetch_c++;  /* got next char already! */
      876       876    3              text[pos++] = '/';
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=25 
      877       877    3              formal_param_pushed = 0;
      878       878    3              check_spp;
      879       879    3              break;
      880       880    3
      881       881    3            case '#':    /** stringization or identifier merge **/
      882       882    3              LoadChar(c);
      883       883    3              if (c == '#') {          /* merge into single identifier */
      884       884    4                check_spp;
      885       885    4                while (pos && ('\n' == text[pos-1] || class(text[pos-1])==STSKIP))
      886       886    4                  pos--;
      887       887    4                if (!pos) {
      888       888    5                  lexwarning("## at start of define text");
      889       889    5                  break;
      890       890    5                }
      891       891    4                text[pos++] = DBL_POUND;                /*merge*/
      892       892    4                LoadChar(c);
      893       893    4              } /** end of merge ## */
      894       894    3
      895       895    3              else {                   /*  stringization  */
      896       896    4                if (!single_pound_pushed++) {
      897       897    5                  single_pound_position = pos;
      898       898    5                  text[pos++] = SGL_POUND;             /*stringization*/
      899       899    5                }
      900       900    4                else lexwarning("formal parameter expected after # in define text");
      901       901    4              }  /** end of stringization # */
      902       902    3
      903       903    3              /* for both stringizing and merging, we skip whitespace */
      904       904    3              while ( STSKIP == class(c) || '/' == c) {
      905       905    4                if ('/' == c) {
      906       906    5                  LoadChar(c);
      907       907    5                  if ('*' != c) { /** comment-whitespace? **/
      908       908    6                    if (pos >= text_size)
      909       909    6                      text = Srealloc(text, text_size += RTEXTSIZE*2);
      910       910    6                    text[pos++] = '/';
      911       911    6                    break;
      912       912    6                  }
      913       913    5                  else skipcomment();
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=26 
      914       914    5                }
      915       915    4                LoadChar(c);
      916       916    4              }  /** end of skipping whitespace **/
      917       917    3
      918       918    3              dont_fetch_c++;
      919       919    3              break;
      920       920    3
      921       921    3            case '(':
      922       922    3              if (formal_param_pushed)  {  /* formal param with args */
      923       923    4                text[pos++] = FORMAL_OPEN;
      924       924    4                if (pos >= text_size)
      925       925    4                  text = Srealloc(text, text_size += RTEXTSIZE*2 );
      926       926    4              } /** fall through and push the '(' **/
      927       927    3
      928       928    3        /*    WARNING: fall through into the default case for '('      */
      929       929    3
      930       930    3            default:  /**  identifiers and other misc chars handled **/
      931       931    3
      932       932    3              if (STIDF == class(c)) {  /** process an identifier **/
      933       933    4                char id_buf[IDFSIZE+4];
      934       934    4                register id_size = 0, n;
      935       935    4
      936       936    4                while (in_idf(c)) {
      937       937    5                  if (id_size <= IDFSIZE)
      938       938    5                    id_buf[id_size++] = c;
      939       939    5                  LoadChar(c);
      940       940    5                }
      941       941    4                id_buf[id_size] = 0;
      942       942    4                dont_fetch_c++;
      943       943    4                if (formals && (n = find_name(id_buf, formals))) {
      944       944    5                  text[pos++] = FORMALP | (char)n;
      945       945    5                  formal_param_pushed++;
      946       946    5                  single_pound_pushed = 0;
      947       947    5                  break;   /* done if it was a formal parameter */
      948       948    5                }
      949       949    4                if (single_pound_pushed)  /* # should be followed by formal name */
      950       950    4                  lexwarning("formal parameter expected after # in define text");
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=27 
      951       951    4                check_spp;
      952       952    4                if (0 == strcmp(macro_name, id_buf))
      953       953    4                  text[pos++] = RECURSION;
      954       954    4
      955       955    4                /* Since it isn't a formal parameter, we have to stuff the
      956       956    4                   entire name into the output buffer!
      957       957    4                */
      958       958    4
      959       959    4                if (pos + id_size  > text_size)
      960       960    4                  text = Srealloc(text,
      961       961    4                                  text_size += (IDFSIZE>RTEXTSIZE) ?
      962       962    4                                  IDFSIZE*2 : RTEXTSIZE*2 );
      963       963    4
      964       964    4                memcpy(text+pos, id_buf, id_size);
      965       965    4                pos += id_size;
      966       966    4              }  /* end of if this starts an identifier */
      967       967    3
      968       968    3              else {  /** this is not an identifier  **/
      969       969    4                text[pos++] = c;
      970       970    4                formal_param_pushed = 0;
      971       971    4                if (STSKIP != class(c))
      972       972    4                  check_spp;                                         /*?*/
      973       973    4              }  /** end of "else" not an identifier **/
      974       974    3              break;
      975       975    3
      976       976    3            }    /** end of "switch (c) {" **/
      977       977    2
      978       978    2            if (pos >= text_size)
      979       979    2              text = Srealloc(text, text_size += RTEXTSIZE*2 );
      980       980    2
      981       981    2            if ( !dont_fetch_c )
      982       982    2              LoadChar(c);
      983       983    2            dont_fetch_c = 0;
      984       984    2          }    /** end of: "while ( (c != EOI)  && ...) {"  **/
      985       985    1
      986       986    1          if (string_literal && STNL == class(c))
      987       987    1            lexerror("new line inside string literal");
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=28 
      988       988    1
      989       989    1          /* neither double pound (identifier merge) nor single pound
      990       990    1             (stringization) are allowed as the last non-blank token
      991       991    1             in a replacement list.
      992       992    1          */
      993       993    1          c = pos;
      994       994    1          while (c > 0 && (STSKIP == class(text[c-1]) || '\n' == text[c-1]))
      995       995    1            c--;
      996       996    1          if (text[c] == SGL_POUND) {
      997       997    2            text[c] = ' ';
      998       998    2            lexwarning("'#' ignored at end of define text");
      999       999    2          }
     1000      1000    1          else if (text[c] == DBL_POUND) {
     1001      1001    2            text[c] = ' ';
     1002      1002    2            lexwarning("'##' ignored at end of define text");
     1003      1003    2          }
     1004      1004    1
     1005      1005    1          if (pos+2 >= text_size)
     1006      1006    1            text = Srealloc(text, text_size += 2);
     1007      1007    1
     1008      1008    1          text[pos++] = EOR;
     1009      1009    1          text[pos] = 0;
     1010      1010    1          *length = pos;
     1011      1011    1          return text;
     1012      1012    1        }
     1013      1013
     1014      1014             #define   BLANK(ch)   ((ch == ' ') || (ch == '\t'))
     1015      1015
     1016      1016             /*  macroeq() decides whether two macro replacement texts are
     1017      1017              identical.  This version compares the texts, which occur
     1018      1018              as strings, without taking care of the leading and trailing
     1019      1019              blanks (spaces and tabs).
     1020      1020             */
     1021      1021             PRIVATE
     1022      1022             macroeq(s, t)
     1023      1023              register char *s, *t;
     1024      1024             {
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=29 
     1025      1025    1
     1026      1026    1         /* skip leading spaces  */
     1027      1027    1         while (BLANK(*s)) s++;
     1028      1028    1         while (BLANK(*t)) t++;
     1029      1029    1         /* first non-blank encountered in both strings  */
     1030      1030    1         /* The actual comparison loop:         */
     1031      1031    1         while (*s && *s == *t)
     1032      1032    1            s++, t++;
     1033      1033    1         /* two cases are possible when arrived here: */
     1034      1034    1         if (*s == '\0')   {  /* *s == '\0'     */
     1035      1035    2            while (BLANK(*t)) t++;
     1036      1036    2            return *t == '\0';
     1037      1037    2         }
     1038      1038    1         else  {     /* *s != *t    */
     1039      1039    2            while (BLANK(*s)) s++;
     1040      1040    2            while (BLANK(*t)) t++;
     1041      1041    2            return (*s == '\0') && (*t == '\0');
     1042      1042    2         }
     1043      1043    1        }
     1044      1044             #else NOPP
     1045      1045   *S*       EXPORT
     1046      1046   *S*       domacro()
     1047      1047   *S*       {
     1048      1048   *S*        struct token tk;
     1049      1049   *S*
     1050      1050   *S*        EoiForNewline = 1;
     1051      1051   *S*        SkipEscNewline = 1;
     1052      1052   *S*        if ((tok = GetToken(&tk)) == IDENTIFIER) {
     1053      1053   *S*           if (strcmp(tk.tk_idf->id_text, "line") != 0) {
     1054      1054   *S*              error("illegal # line");
     1055      1055   *S*              SkipRestOfLine();
     1056      1056   *S*              return;
     1057      1057   *S*           }
     1058      1058   *S*           tok = GetToken(&tk);
     1059      1059   *S*        }
     1060      1060   *S*        if (tok != INTEGER) {
     1061      1061   *S*           error("illegal # line");
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=30 
     1062      1062   *S*           if (tok != EOI) SkipRestOfLine();
     1063      1063   *S*           return;
     1064      1064   *S*        }
     1065      1065   *S*        do_line((unsigned int) tk.tk_ival);
     1066      1066   *S*        EoiForNewline = 0;
     1067      1067   *S*        SkipEscNewline = 0;
     1068      1068   *S*       }
     1069      1069   *S*       #endif NOPP
     1070      1070
     1071      1071             PRIVATE
     1072      1072             SkipRestOfLine()
     1073      1073             {
     1074      1074    1         /* we do a PushBack because we don't want to skip the next line
     1075      1075    1            if the last character was a newline
     1076      1076    1         */
     1077      1077    1         PushBack();
     1078      1078    1         skipline();
     1079      1079    1        }
     1080      1080
     1081      1081             PRIVATE
     1082      1082             do_line(l)
     1083      1083              unsigned int l;
     1084      1084             {
     1085      1085    1         struct token tk;
     1086      1086    1
     1087      1087    1          LineNumber = l - 1;     /* the number of the next input line */
     1088      1088    1         AccFileSpecifier = 1;
     1089      1089    1         if ((tok = GetToken(&tk)) == STRING) { /*  filespecifier? */
     1090      1090    2             if (tk.tok_qualifier == LONG)
     1091      1091    2                lexwarning("character string literal expected for filename");
     1092      1092    2            FileName = tk.tk_bts;
     1093      1093    2             }
     1094      1094    1         AccFileSpecifier = 0;
     1095      1095    1         if (tok != EOI) SkipRestOfLine();
     1096      1096    1        }
     1097      1097
---  Include file information  ---
CC.C03    File=zbc$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=31 

   zbc$interface:h.:ZBC3TOU. is referenced
   zbc$arith:h.:ZBC3TOU. is referenced
   zbc$spec_arith:h.:ZBC3TOU. is referenced
   em_arith:h.:ZBC3TOU. is referenced
   zbc$LLlex:h.:ZBC3TOU. is referenced
   zbc$nofloat:h.:ZBC3TOU. is referenced
   zbc$file_info:h.:ZBC3TOU. is referenced
   zbc$nopp:h.:ZBC3TOU. is referenced
   zbc$Lpars:h.:ZBC3TOU. is referenced
   zbc$debug:h.:ZBC3TOU. is referenced
   zbc$idf:h.:ZBC3TOU. is referenced
   zbc$input:h.:ZBC3TOU. is referenced
   inp_pkg:spec.:ZBC3TOU. is referenced
   zbc$zb_target:h.:ZBC3TOU. is referenced
   zbc$ifdepth:h.:ZBC3TOU. is referenced
   zbc$botch_free:h.:ZBC3TOU. is referenced
   zbc$nparams:h.:ZBC3TOU. is referenced
   zbc$parbufsize:h.:ZBC3TOU. is referenced
   zbc$textsize:h.:ZBC3TOU. is referenced
   zbc$idfsize:h.:ZBC3TOU. is referenced
   zbc$assert:h.:ZBC3TOU. is referenced
   alloc:h.:ZBC3TOU. is referenced
   zbc$class:h.:ZBC3TOU. is referenced
   zbc$macro:h.:ZBC3TOU. is referenced

No diagnostics were issued in the file zbc$domacro:c.:ZBC3TSI
