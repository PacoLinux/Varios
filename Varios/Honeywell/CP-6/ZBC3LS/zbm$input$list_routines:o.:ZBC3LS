

CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=1  
        1         1             /*M*     zb_listing_package:c       */
        2         2             /*T*/
        3         3             /*P*     NAME:       zb_listing_package:c
        4         4                      PURPOSE:    This package does everything needed for a listing
        5         5                      DESCRIPTION:These routines serve as an interface for the
        6         6                                  creation of a listed output. It allows the
        7         7                                  user to input listing records, error records,
        8         8                                  blank lines and page breaks.
        9         9             */
       10        10
       11        11             /*V*     listing generator overview          */
       12        12             /*
       13        13
       14        14
       15        15                      How to invoke the listing generator
       16        16
       17        17                   To get a listing outputed is a fairly simple task to accomplish.
       18        18                   There are a two initialization routines that must be called
       19        19                   to start up a listing.  The first one, zb_listing_start_listing,
       20        20                   sets up some global variables and opens up the output file.
       21        21                   The other init routine, zb_listing_input_init, opens up the
       22        22                   temporary files used by this program. After these two have
       23        23                   been called all that is neccessary is to insert the type of
       24        24                   records that you want inserted into the program.  There are
       25        25                   four basic types of records that can be inserted:
       26        26
       27        27                      1) zb_listing_append - Actual text records from the source
       28        28                                             files. These records must be inserted
       29        29                                             sequentially.
       30        30
       31        31                      2) zb_listing_error  - Error messages that are to be inserted
       32        32                                             in the listing. They get inserted
       33        33                                             after the record that contains the
       34        34                                             error. This routine also writes out
       35        35                                             the error to STDERR.
       36        36
       37        37                      3) zb_listing_eject  - Inserts a page break after the last
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=2  
       38        38                                             source record that was written out
       39        39                                             with zb_listing_append.
       40        40
       41        41                      4) zb_listing_space  - Inserts N spaces after the last source
       42        42                                             record that was written out with
       43        43                                             zb_listing_append.
       44        44
       45        45                   After all the records (all of the above ) have been written
       46        46                   out to the temporary files, and the user wants the listing
       47        47                   outputted, all that is needed is to call zb_listing_output_ls
       48        48                   and it outputs everything to the output listing file.
       49        49
       50        50                      HOW THE LISTING GENERATOR IS IMPLEMENTED
       51        51
       52        52                   The listing generator simulates keyed files by using the debug
       53        53                   line number as the key.  There are a total of three files needed
       54        54                   to simulate this process.
       55        55
       56        56                   1) ERRFP    - This file contains all the error messages that
       57        57                                 may have occurred before the first record was
       58        58                                 written out (first source line of file). This
       59        59                                 can occur if the file to be compiled does not
       60        60                                 exist or if errors occured in the include files.
       61        61
       62        62                   2) KEYFP    - This file contains the keys that are used as an
       63        63                                 index to the listing file. Since these records
       64        64                                 are very small, an array of them are kept (to keep
       65        65                                 I/O at a minimum).
       66        66
       67        67                   3) LISTFP   - This file contains all the record that were
       68        68                                 created by zb_listing_append or zb_listing_error
       69        69                                 (if the error was not at BOF).
       70        70
       71        71                   The format for the three types of records are:
       72        72
       73        73                Key_record:
       74        74
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=3  
       75        75                   ------------------------
       76        76                   | debug_num | byte_pos |
       77        77                   ------------------------
       78        78
       79        79                   debug_num- The debug number of the record in the LISTFP file.
       80        80                   byte_pos - The byte offset for the record from the beginning
       81        81                              of the LISTFP file.
       82        82
       83        83                listing_record:
       84        84
       85        85                   ------------------------------------------------------------------------
                               -----------------------------
       86        86                   | recnum | rec_source | debug_num | nest_lev | formfeed | linefeed | ext
                               ra_text | nbytes | rec_text |
       87        87                   ------------------------------------------------------------------------
                               -----------------------------
       88        88
       89        89                   recnum      - The current record number being written out
       90        90                   rec_source  - The actual text of the key written out
       91        91                   debug_num   - Debug number for the line nmuber
       92        92                   nest_lev    - The nested level of braces to this point
       93        93                   formfeed    - Page break flag for after this line
       94        94                   linefeed    - Number of blank lines to put after this line
       95        95                   extra_text  - Position in the file for possible extra text that
       96        96                                 may follow after this record (i.e., error messages)
       97        97                   nbytes      - Number of bytes of text in record
       98        98                   text        - Actual text of the record
       99        99
      100       100                error_record:
      101       101
      102       102                   -------------------------------------------------
      103       103                   | next_err | pos_err | severity | nbytes | text |
      104       104                   -------------------------------------------------
      105       105
      106       106                   next_err    - Position in the file for the next possible error
      107       107                                 message following this one
      108       108                   pos_err     - Position of where the error occurred in the actual
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=4  
      109       109                                 source record
      110       110                   severity    - The severity of this error
      111       111                   nbytes      - Number of bytes of text in the error message
      112       112                   text        - Actual text of the record
      113       113
      114       114             */
      115       115             #include    <stdio:h>
      116       116             #include    <system:h>
      117       117             #include    "cp_6_subs:h"
      118       118             #include    "b$jit_c:h"
      119       119             #include    "alloc:h"
      120       120             #include    <assert.h>
      121       121             #include    "zb_listing:h"
      122       122             extern   char  *malloc();
      123       123             extern   struct   b_jit    *B$JIT$;
      124       124
      125       125             /*F*     NAME:       zb_listing_start_listing
      126       126                      PURPOSE:    Initialize some stuff for the listing generator
      127       127                      DESCRIPTION:This routine initializes a couple of the global
      128       128                                  variables needed for the listing generator and
      129       129                                  opens up the output listing file
      130       130             */
      131       131             /*D*     NAME:       zb_listing_start_listing
      132       132                      CALL:       zb_listing_start_listing (comp_vers, nest_level)
      133       133                      INPUT:
      134       134                               char  *comp_vers  - A pointer to the current compiler
      135       135                                                   version that is running.
      136       136                               int   *nest_level - A pointer to a variable that is
      137       137                                                   to contain the nesting level of
      138       138                                                   the braces in the C program.
      139       139                      OUTPUT:
      140       140                               zb_date  - Contains the current date
      141       141                               zb_time  - Contains the current time
      142       142                               zb_list_on - A flag turned on enabling listings
      143       143                               outfp      - File pointer to the listing file
      144       144                               outerrfp   - File pointer to the error file
      145       145                      DESCRIPTION:
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=5  
      146       146                         This routine is the first routine that is called to create
      147       147                         a listing generator. It initializes a couple of global
      148       148                         variables and opens up the listing output file. If this
      149       149                         file does not open up ok the listing generator bombs!!
      150       150                         This routine also creates the formats that are used for
      151       151                         the writing of error messages to STDERR.
      152       152             */
      153       153
      154       154             zb_listing_start_listing (prog_name, nest_level, skipping)
      155       155             char  *prog_name;
      156       156             int   *nest_level;
      157       157             int   *skipping;
      158       158
      159       159             {
      160       160    1           long  clock;
      161       161    1           int   i;
      162       162    1           long  sys_time();
      163       163    1           char  date_time[30];
      164       164    1           char  *ctime();
      165       165    1
      166       166    1           zb_list_on = zb_LS_flag;
      167       167    1
      168       168    1        /*    Set up the include variables to point to the correct variables
      169       169    1              that will be used to contain values for the LS file         */
      170       170    1
      171       171    1           i = B_VERSION[0];
      172       172    1           memcpy (list_comp_vers,&B_VERSION[1],i);
      173       173    1           list_comp_vers[i] = '\0';
      174       174    1           list_prog_name = malloc (strlen (prog_name) + 1);
      175       175    1           if (!list_prog_name)
      176       176    1              No_Mem ();
      177       177    1           strcpy (list_prog_name, prog_name);
      178       178    1           mark_heap_pointer (list_prog_name);
      179       179    1           list_nest_level =  nest_level;
      180       180    1           list_skipping = skipping;
      181       181    1
      182       182    1        /*    Get the date for today for the TOP line of stuff             */
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=6  
      183       183    1           clock = sys_time();
      184       184    1           strcpy (date_time, ctime(&clock));
      185       185    1           strncpy (zb_date, date_time, 12);
      186       186    1           strncpy (&zb_date[11], &date_time[20], 4);
      187       187    1           zb_date[15] = '\0';
      188       188    1
      189       189    1           strncpy (zb_time, &date_time[11], 5);
      190       190    1           zb_time[5] ='\0';
      191       191    1
      192       192    1        /*    Initialize some variables for writing out the error info to
      193       193    1              the stderr file.  They are formatted to match the LS stuff but
      194       194    1              formatted for stderr                                         */
      195       195    1
      196       196    1           outerrfp = STDERR;
      197       197    1           outerrfp->o_flags += OP_VFC;
      198       198    1        /*    Output a little info about compiler to STDERR                */
      199       199    1
      200       200    1           sprintf (zb_output_str,"A%s%s here at %s %s\n",list_prog_name,
      201       201    1                    list_comp_vers,zb_time,zb_date);
      202       202    1           sys_write (outerrfp, zb_output_str, strlen(zb_output_str));
      203       203    1           outerrfp ->o_flags ^= OP_VFC;
      204       204    1
      205       205    1           sys_fileinfo (outerrfp, &out_setting);
      206       206    1           zb_text_size = out_setting.file_org.ur.width - ZB_FIXED_SIZE - 1;
      207       207    1           if (zb_text_size < ZB_MIN_WIDTH)
      208       208    1              zb_text_size = ZB_MIN_WIDTH;
      209       209    1           sprintf (zb_form_err, "A%%-.%ds\n\0",zb_text_size + ZB_FIXED_SIZE);
      210       210    1           sprintf (zb_form_rec, "A%%9s%%9d%%5d        %%-.%ds\n\0",zb_text_size);
      211       211    1           sprintf (zb_form_rec2, "A%%9s%%9d             %%-.%ds\n\0",zb_text_size);
      212       212    1           sprintf (zb_form_rec3, "A%%9s%%9d   *S*       %%-.%ds\n\0",zb_text_size);
      213       213    1           sprintf (zb_form_rec_cont, "A%%%ds%%-.%ds\n\0",ZB_FIXED_SIZE+1, zb_text_siz
                               e);
      214       214    1
      215       215    1        /*    Open the output file, if it does not open write out an error
      216       216    1              condition and abort the program                              */
      217       217    1
      218       218    1           if (zb_list_on) {
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=7  
      219       219    2              if (!sys_open ("dcb=M$LO", OP_WRITE+OP_UR+OP_VFC, &outfp)) {
      220       220    3                 fprintf (stderr, "Could not open the listing file.\n");
      221       221    3                 zb_list_on = 0;
      222       222    3                 return 0;
      223       223    3              }
      224       224    2           }
      225       225    1           return 1;
      226       226    1        }
      227       227
      228       228             /*F*     NAME:       zb_listing_input_init
      229       229                      PURPOSE:    Initializes some more stuff for listing generator
      230       230                      DESCRIPTION:This routine initializes the rest of the stuff
      231       231                                  needed for the start-up of the listing generator.
      232       232                                  This info is gotten from the input routines
      233       233             */
      234       234             /*D*     NAME:    zb_listing_input_init
      235       235                      CALL:    zb_listing_input_init(funcname, base_file, up_date_file,
      236       236                                                     nbytes, rec_source)
      237       237                      INPUT:
      238       238                               char *funcname - Points to the current function being compil
                               ed
      239       239                               char *base_file- Points to the name of the base file
      240       240                               char *update_file- Points to the name of the update file
      241       241                               int  *nbytes   - Points at the number of bytes that
      242       242                                                are contained in the source record
      243       243                               char *rec_source-Points at text of the current record key
      244       244                      OUTPUT:
      245       245                               keyfp - File pointer to the temporary key file
      246       246                               listfp - File pointer to the temporary listing file
      247       247                               errfp - File pointer to the temporary error file
      248       248                      DESCRIPTION:
      249       249                         This routine is called by the input routine before it
      250       250                         opens up the base and update source files.  It sets up
      251       251                         all the rest of the information needed by the listing
      252       252                         generator to create a complete listing (see INPUT:).
      253       253                         This routine also opens up the three temporary files that
      254       254                         are used to store the data in the intermediate format.
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=8  
      255       255
      256       256                         This routine is called even if no listing is desired, so
      257       257                         that the error messages can be inserted after the correct
      258       258                         debug line number, and outputted correctly to the error
      259       259                         file.
      260       260             */
      261       261
      262       262             zb_listing_input_init (funcname, base_file, update_file, nbytes, rec_source)
      263       263
      264       264             char  *funcname;
      265       265             char  *base_file;
      266       266             char  *update_file;
      267       267             int   *nbytes;
      268       268             char   *rec_source;
      269       269
      270       270             {
      271       271    1
      272       272    1           list_func_name = funcname;
      273       273    1           if (base_file) {
      274       274    2              list_base_file = malloc (strlen (base_file) + 1);
      275       275    2              if (!list_base_file)
      276       276    2                 No_Mem ();
      277       277    2              strcpy (list_base_file, base_file);
      278       278    2              mark_heap_pointer (list_base_file);
      279       279    2           }
      280       280    1           else
      281       281    1              list_base_file = base_file;
      282       282    1           if (update_file) {
      283       283    2              list_update_file = malloc (strlen (update_file) + 1);
      284       284    2              if (!list_update_file)
      285       285    2                 No_Mem ();
      286       286    2              strcpy (list_update_file, update_file);
      287       287    2              mark_heap_pointer (list_update_file);
      288       288    2           }
      289       289    1           else
      290       290    1              list_update_file = update_file;
      291       291    1           list_nbytes = nbytes;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=9  
      292       292    1           list_rec_source = rec_source;
      293       293    1
      294       294    1           zb_listing_init = 1;
      295       295    1
      296       296    1        /*    Open a temporary file that will contain the information about
      297       297    1              the keys of the index file                                   */
      298       298    1
      299       299    1           if ((keyfp = tmpfile()) == (FILE *) 0)
      300       300    1              return 0;
      301       301    1
      302       302    1        /*    Open a temporary file that will contain the the actual text
      303       303    1              of the LS file in a simplistic format                        */
      304       304    1
      305       305    1           if ((listfp = tmpfile()) == (FILE *) 0)
      306       306    1              return 0;
      307       307    1
      308       308    1
      309       309    1        /*    Open a temporary file that can possibly contain error
      310       310    1              messages at the begining of a the file (include file errors) */
      311       311    1
      312       312    1           if ((errfp = tmpfile()) == (FILE *) 0)
      313       313    1              return 0;
      314       314    1
      315       315    1        #ifdef   _CP6_
      316       316    1           Create_Top_Of_Form();
      317       317    1           sys_heading(outfp, zb_form_page2, &zb_pagenum);
      318       318    1        #endif
      319       319    1
      320       320    1           return 1;
      321       321    1        }
      322       322
      323       323             /*F*        NAME:       zb_listing_append
      324       324                         PURPOSE:    Write a listing record in the intermediate format
      325       325                         DESCRIPTION:This routine writes out the next sequential
      326       326                                     listing record that is to be written out to
      327       327                                     the listing file.
      328       328             */
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=10 
      329       329             /*D*        NAME:       zb_listing_append
      330       330                         CALL:       zb_listing_append (debug_num, text)
      331       331                         INPUT:
      332       332                                  int   debug_num - The debug number of the source record
      333       333                                  char  text[]    - Actual text of the source record
      334       334                         OUTPUT:
      335       335                                  NONE
      336       336                         DESCRIPTION:
      337       337                            This routine outputs a listing record to the temporary
      338       338                            listing file.  It creates a key for this record in the
      339       339                            key file as well.  It is important that all the variables
      340       340                            that were used to set up the global variables in the
      341       341                            initialization routines contain the correct values for
      342       342                            this record otherwise the record created may contain
      343       343                            BOGUS information.
      344       344             */
      345       345
      346       346             zb_listing_append (debug_num, text)
      347       347             int   debug_num;
      348       348             char  *text;
      349       349             {
      350       350    1
      351       351    1        /*    Check to see if they want a listing for this record or not   */
      352       352    1
      353       353    1        /*    Add the entry onto the key file for access                   */
      354       354    1           zb_write_key (debug_num,zb_last_ls_text);
      355       355    1
      356       356    1        /*    Dump all the needed information into a structure so that it
      357       357    1              can be written out to the temp ls file                       */
      358       358    1
      359       359    1           zb_list_info.recnum = zb_list_recnum++;
      360       360    1           strcpy (zb_list_info.rec_source, list_rec_source);
      361       361    1           zb_list_info.debugnum = debug_num;
      362       362    1           if (zb_list_on) {
      363       363    2              if (*list_skipping) {
      364       364    3                 if (!zb_saved_nest)
      365       365    3                    zb_saved_nest = -(*list_nest_level) - 1;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=11 
      366       366    3                 zb_list_info.nest_lev = zb_saved_nest;
      367       367    3              }
      368       368    2              else {
      369       369    3                 if (zb_saved_nest) {
      370       370    4                    *list_nest_level = (-zb_saved_nest) - 1;
      371       371    4                    zb_saved_nest = 0;
      372       372    4                 }
      373       373    3                 zb_list_info.nest_lev = *list_nest_level;
      374       374    3              }
      375       375    2           }
      376       376    1           zb_list_info.formfeed = 0;
      377       377    1           zb_list_info.linefeed = 0;
      378       378    1           zb_list_info.extra_text = -1;
      379       379    1           zb_list_info.nbytes = *list_nbytes + 1;
      380       380    1           zb_write_listing (zb_last_ls_text, 1, text);
      381       381    1        }
      382       382
      383       383             /*F*        NAME:       zb_listing_error
      384       384                         PURPOSE:    Write an error message to the listing file
      385       385                         DESCRIPTION:This routine outputs an error message to either
      386       386                                     the error file or the listing file (depending
      387       387                                     if the error goes at the beginning of the
      388       388                                     listing file or not).
      389       389             */
      390       390             /*D*        NAME:    zb_listing_error
      391       391                         CALL:    zb_listing_error(text, linenum, errpos, severity)
      392       392                         INPUT:
      393       393                                  char  *text    - The error message text
      394       394                                  int   linenum  - The debug line number of where
      395       395                                                   the error occurred
      396       396                                  int   errpos   - The position of where the error
      397       397                                                   occurred within the listings text
      398       398                                  int   severity - The severity of the error
      399       399                         OUTPUT:
      400       400                                  NONE
      401       401                         DESCRIPTION:
      402       402                            This routine is called when an error message is to be
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=12 
      403       403                            outputted to the listing file.  This message is outputted
      404       404                            to both the listing file and STDERR.  It keeps track
      405       405                            of the number of errors that have occurred in the
      406       406                            sourcefile and the maximum severity of these errors.
      407       407                            The next thing done is the finding of the position of
      408       408                            the source record that contained the error.  If the
      409       409                            debug number is less than the smallest debug line number
      410       410                            of the listing file the error message is written out
      411       411                            to the temporary error file otherwise it is written out
      412       412                            to the listing file.  Once the debug number is found,
      413       413                            it searches till it finds the correct position to insert
      414       414                            the error message in the file. And the error message
      415       415                            is written out to its respective file.
      416       416             */
      417       417
      418       418             zb_listing_error (text, linenum, errpos, severity)
      419       419             char  text[];
      420       420             int   linenum;
      421       421             int   errpos;
      422       422             int   severity;
      423       423             {
      424       424    1           int   byte_pos;
      425       425    1           int   errrec = 0;
      426       426    1           int   errflag = 0;
      427       427    1           int   not_found = 0;
      428       428    1           static   int   last_debug_err = -1;
      429       429    1
      430       430    1        /* check to see if the listing generator has been initialized       */
      431       431    1
      432       432    1           if (!zb_listing_init) {
      433       433    2              zb_listing_input_init ((char *) 0,(char *) 0, (char *) 0, (int *) 0, (ch
                               ar *) 0);
      434       434    2           }
      435       435    1
      436       436    1
      437       437    1           if (severity > zb_max_severity)
      438       438    1              zb_max_severity = severity;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=13 
      439       439    1           if (severity > 4)
      440       440    1              zb_numerrs++;
      441       441    1           else
      442       442    1              zb_numwarns++;
      443       443    1        /*    Find the position of the key that is to get the error mess   */
      444       444    1           byte_pos = zb_get_key (linenum);
      445       445    1
      446       446    1        /*    If a -1 it means that the error goes before any lines of
      447       447    1              the LS file and must be handled as a special case (damn)     */
      448       448    1           if (byte_pos == -1) {
      449       449    2              if (zb_begerr) {
      450       450    3                 errrec = 0;
      451       451    3                 while (errrec >= 0) {
      452       452    4                    zb_read_ls_err_record (errrec, 0, 1, zb_err_text);
      453       453    4                    byte_pos = errrec;
      454       454    4                    errrec = zb_error_info.next_err;
      455       455    4                    errflag = 1;
      456       456    4                 }
      457       457    3                 zb_error_info.next_err = zb_last_err_text;
      458       458    3                 zb_write_err_listing (byte_pos, 0, 1, zb_err_text);
      459       459    3              }
      460       460    2              zb_error_info.next_err = -1;
      461       461    2              zb_error_info.pos_err = 0; /* No text before it to point at  */
      462       462    2              zb_error_info.severity = severity;
      463       463    2              zb_error_info.nbytes = strlen (text) + 1;
      464       464    2              zb_begerr = 1;
      465       465    2              zb_write_err_listing (zb_last_err_text, 1, 1, text);
      466       466    2
      467       467    2        /*    Output the error message to stderr                           */
      468       468    2
      469       469    2              strcpy (zb_err_text, text);
      470       470    2              if (zb_err_text[zb_error_info.nbytes - 2] == '\n')
      471       471    2                 zb_err_text[zb_error_info.nbytes - 2] = '\0';
      472       472    2              output_error_rec (outerrfp, zb_err_text);
      473       473    2              return 1;
      474       474    2           }
      475       475    1
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=14 
      476       476    1        /*    If byte_pos <0 then absolute value must be taken of it because
      477       477    1              the debug line number was not found                          */
      478       478    1
      479       479    1           if (byte_pos < 0) {
      480       480    2              byte_pos = - byte_pos;
      481       481    2              not_found = 1;
      482       482    2           }
      483       483    1
      484       484    1        /*    If neccesary position the LS file to the correct area and
      485       485    1              read the record that is supposed to get the error message    */
      486       486    1
      487       487    1           zb_read_ls_record (byte_pos, 1, zb_ls_text);
      488       488    1
      489       489    1        /*    Output the record that has the error to stderr               */
      490       490    1
      491       491    1           zb_error_info.next_err = -1;
      492       492    1           if ((errpos < 0) || (errpos > zb_list_info.nbytes))
      493       493    1              errpos = 0;
      494       494    1           zb_error_info.pos_err = errpos;
      495       495    1           zb_error_info.severity = severity;
      496       496    1           zb_error_info.nbytes = strlen (text) + 1;
      497       497    1           strcpy (zb_err_text, text);
      498       498    1           if (zb_err_text[zb_error_info.nbytes - 2] == '\n')
      499       499    1              zb_err_text[zb_error_info.nbytes - 2] = '\0';
      500       500    1           if (linenum == last_debug_err)
      501       501    1              output_error_rec (outerrfp, zb_err_text);
      502       502    1           else
      503       503    1              output_list_rec (outerrfp, &errrec, zb_err_text);
      504       504    1           last_debug_err = linenum;
      505       505    1        /* If the record is not going to be listed attach it to LS file    */
      506       506    1           if (not_found) {
      507       507    2              zb_read_key_block (zb_key_saved_blocks);
      508       508    2              byte_pos = zb_key_array[zb_key_saved_pos-1].byte_pos;
      509       509    2              zb_read_ls_record (byte_pos, 1, zb_ls_text);
      510       510    2              zb_not_last_rec = 1;
      511       511    2              errpos = -1;
      512       512    2           }
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=15 
      513       513    1
      514       514    1           errrec = zb_list_info.extra_text;
      515       515    1           while (errrec > 0) {
      516       516    2              zb_read_ls_err_record (errrec, 0, 0, zb_err_text);
      517       517    2              byte_pos = errrec;
      518       518    2              errrec = zb_error_info.next_err;
      519       519    2              errflag = 1;
      520       520    2           }
      521       521    1           if (errflag) {
      522       522    2              zb_error_info.next_err = zb_last_ls_text;
      523       523    2              zb_write_err_listing (byte_pos, 0, 0, zb_err_text);
      524       524    2           }
      525       525    1           else {
      526       526    2              zb_list_info.extra_text = zb_last_ls_text;
      527       527    2              zb_write_listing (byte_pos, 0, zb_ls_text);
      528       528    2           }
      529       529    1
      530       530    1        /*    Create the error message info and write it out to the file   */
      531       531    1           zb_error_info.next_err = -1;
      532       532    1           zb_error_info.pos_err = errpos;
      533       533    1           zb_error_info.severity = severity;
      534       534    1           zb_error_info.nbytes = strlen (text) + 1;
      535       535    1           zb_write_err_listing (zb_last_ls_text, 1, 0, text);
      536       536    1
      537       537    1           return 1;
      538       538    1        }
      539       539
      540       540             /*F*        NAME:       zb_listing_eject
      541       541                         PURPOSE:    Insert a page break after the last listing record
      542       542                         DESCRIPTION: This routine inserts a page break after the
      543       543                                      last source record that was written out to
      544       544                                      the listing file via zb_listing_append
      545       545             */
      546       546             /*D*        NAME:       zb_listing_eject
      547       547                         CALL:       zb_listing_eject()
      548       548                         INPUT:
      549       549                               NONE
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=16 
      550       550                         OUTPUT:
      551       551                               NONE
      552       552                         DESCRIPTION:
      553       553                            This routine is called when a page break is desired
      554       554                            be the user's source program.  The page break is
      555       555                            inserted after the last source record that was appended
      556       556                            to the listing file.  The page break will appear after
      557       557                            all the errors that may have occured for that source
      558       558                            record
      559       559             */
      560       560
      561       561             zb_listing_eject ()
      562       562             {
      563       563    1           if ((!zb_list_on) || (!zb_LS_flag))
      564       564    1              return;
      565       565    1
      566       566    1           zb_read_ls_record (zb_lastls_write_pos, 0, zb_ls_text);
      567       567    1           if (!zb_list_info.formfeed) {
      568       568    2              zb_list_info.formfeed = 1;
      569       569    2              zb_write_listing (zb_lastls_write_pos, 0, zb_ls_text);
      570       570    2           }
      571       571    1        }
      572       572
      573       573             /*F*     NAME:       zb_listing_space
      574       574                      PURPOSE:    Inserts N blank lines after a last listing record
      575       575                      DESCRIPTION:This routine outputs N blank lines after a source
      576       576                                  record that was last written out to the listing file
      577       577                                  via zb_listing_append
      578       578             */
      579       579             /*D*     NAME:       zb_listing_spaces
      580       580                      CALL:       zb_listing_spaces(numspaces)
      581       581                      INPUT:
      582       582                               int   numspaces   - The number of blank lines to be
      583       583                                                   written
      584       584                      OUTPUT:
      585       585                               NONE
      586       586                      DESCRIPTION:
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=17 
      587       587                         This routine outputs numspaces newline characters out to
      588       588                         the output file.  Theses blank lines are inserted after
      589       589                         the last record written out to the listing file with
      590       590                         zb_listing_append.
      591       591             */
      592       592
      593       593             zb_listing_space (numspaces)
      594       594             int   numspaces;
      595       595             {
      596       596    1           if ((!zb_list_on) || (!zb_LS_flag))
      597       597    1              return;
      598       598    1
      599       599    1           zb_read_ls_record (zb_lastls_write_pos, 0, zb_ls_text);
      600       600    1           zb_list_info.linefeed += numspaces;
      601       601    1           zb_write_listing (zb_lastls_write_pos, 0, zb_ls_text);
      602       602    1        }
      603       603
      604       604             zb_listing_include (filename, lines, errors)
      605       605             char  filename[];
      606       606             int   lines;
      607       607             int   errors;
      608       608             {
      609       609    1           struct   zb_inc_struct  *temp = zb_head_inc;
      610       610    1           struct   zb_inc_struct  *last = zb_head_inc;
      611       611    1
      612       612    1        /*    Check if this include file has already been referenced       */
      613       613    1           while (temp) {
      614       614    2              if (!strcmp (temp->name,filename))
      615       615    2                 return;
      616       616    2              last = temp;
      617       617    2              temp = temp->next;
      618       618    2           }
      619       619    1
      620       620    1        /*    Not there so need to add it                                  */
      621       621    1           temp = (struct zb_inc_struct *) malloc (sizeof (struct zb_inc_struct));
      622       622    1           if (!temp)
      623       623    1              No_Mem();
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=18 
      624       624    1           mark_heap_pointer (temp);
      625       625    1           temp->lines = lines;
      626       626    1           temp->errors = errors;
      627       627    1           temp->next = (struct zb_inc_struct *) NULL;
      628       628    1           temp->name = malloc (strlen (filename) + 1);
      629       629    1           if (!temp->name)
      630       630    1              No_Mem();
      631       631    1           mark_heap_pointer (temp->name);
      632       632    1           strcpy (temp->name, filename);
      633       633    1           if (!zb_head_inc)
      634       634    1              zb_head_inc = temp;
      635       635    1           else
      636       636    1              last->next = temp;
      637       637    1        }
      638       638
      639       639             zb_listing_storage (execute, const_val)
      640       640             int   execute;
"zbm$input$list_routines:c.:ZBC3TSI", line 640: (warning) identifier "execute" is not used
"zbm$input$list_routines:c.:ZBC3TSI", line 640: (warning) identifier "const_val" is not used
      641       641             int   const_val;
      642       642             { ;
      643       643    1        }
      644       644
      645       645             /* These are the local routines that the listing routines call     */
      646       646
      647       647
      648       648             /*F*        NAME:       zb_read_key_block
      649       649                         PURPOSE:    Reads the specified key block from the key file
      650       650                         DESCRIPTION:This routine reads a key block from the key
      651       651                                     file.
      652       652             */
      653       653             /*D*        NAME:    zb_read_key_block
      654       654                         CALL:    zb_read_key_block (blocknum)
      655       655                         INPUT:
      656       656                               int   blocknum - The block number that is to be read
      657       657                         OUTPUT:
      658       658                               zb_key_array - contains the block of keys that were
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=19 
      659       659                                              just read in
      660       660                         DESCRIPTION:
      661       661                            This routine reads a block of keys from the key file.
      662       662                            If the current block has had information written to it
      663       663                            it is purged out before the new block is read in
      664       664             */
      665       665
      666       666             zb_read_key_block (blocknum)
      667       667             int   blocknum;
      668       668             {
      669       669    1           int   nbytes = 8 * ZB_KEY_ARRAY_SIZE;
      670       670    1
      671       671    1           if (blocknum != zb_key_curblk) {
      672       672    2              if (zb_key_dirty) {
      673       673    3                 zb_purge_key ();
      674       674    3              }
      675       675    2              if (fseek (keyfp, blocknum * nbytes, SEEK_SET)) {
      676       676    3                 zb_abort_listing ("zb_read_key_block", "Trying to seek to a block of
                               keys");
      677       677    3              }
      678       678    2              zb_key_curblk = blocknum;
      679       679    2              zb_key_pos = ZB_KEY_ARRAY_SIZE;
      680       680    2              if (fread (zb_key_array, sizeof (char), nbytes, keyfp) == nbytes)
      681       681    2                 return 1;
      682       682    2              else {
      683       683    3                 zb_abort_listing ("zb_read_key_block", "Trying to read a block of key
                               s");
      684       684    3              }
      685       685    2           }
      686       686    1        }
      687       687
      688       688             /*F*        NAME:       zb_write_key
      689       689                         PURPOSE:    Write a key to the key file
      690       690                         DESCRIPTION:This routine is called everytime a new key
      691       691                                     is to be written out to th key file
      692       692             */
      693       693             /*D*        NAME:    zb_write_key
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=20 
      694       694                         CALL:    zb_write_key (debug_num, byte_pos)
      695       695                         INPUT:
      696       696                               int   debug_num   - The debug number of the source record (i
                               .e., the key)
      697       697                               int   byte_pos    - The byte position of the listing
      698       698                                                   record
      699       699                         OUTPUT:
      700       700                               NONE
      701       701                         DESCRIPTION:
      702       702                            This routine writes one key to the buffered up key
      703       703                            array. If this key array is full it is then written
      704       704                            out to the key file.
      705       705             */
      706       706
      707       707             zb_write_key (debug_num, byte_pos)
      708       708             int   debug_num;
      709       709             int   byte_pos;
      710       710             {
      711       711    1           int   nbytes = 8 * ZB_KEY_ARRAY_SIZE;
      712       712    1
      713       713    1        /*    If the record being written out is not to be included in the
      714       714    1              LS file. It must be distinguished from records written out so
      715       715    1              its offset in the file is stored as a -OFFSET.  When the
      716       716    1              records start being written out again, the keys of the
      717       717    1              negative ones must be written over because the debug numbers
      718       718    1              may have been reset back                                     */
      719       719    1
      720       720    1           if (!zb_LS_flag) {
      721       721    2              byte_pos = - byte_pos;
      722       722    2              if (!zb_key_saved_pos) {
      723       723    3                 zb_key_saved_pos = zb_key_pos;
      724       724    3                 zb_key_saved_blocks = zb_key_blocks;
      725       725    3              }
      726       726    2           }
      727       727    1           else if (zb_key_saved_pos) {
      728       728    2              if (zb_key_saved_blocks != zb_key_blocks) {
      729       729    3                 zb_read_key_block (zb_key_saved_blocks);
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=21 
      730       730    3                 zb_key_curblk = zb_key_blocks = zb_key_saved_blocks;
      731       731    3              }
      732       732    2              zb_key_pos = zb_key_saved_pos;
      733       733    2              zb_key_saved_pos = 0;
      734       734    2           }
      735       735    1           if (zb_key_pos >= ZB_KEY_ARRAY_SIZE) {
      736       736    2              if (zb_key_dirty) {
      737       737    3                 if (fseek (keyfp, zb_key_blocks * nbytes, SEEK_SET)) {
      738       738    4                    zb_abort_listing ("zb_write_key", "Trying to seek to a block of ke
                               ys");
      739       739    4                 }
      740       740    3                 if (fwrite (zb_key_array, sizeof (char), nbytes, keyfp) != nbytes) {
      741       741    4                    zb_abort_listing ("zb_write_key", "Trying to write a block of keys
                               ");
      742       742    4                 }
      743       743    3                 zb_key_blocks++;
      744       744    3              }
      745       745    2              zb_key_pos = 0;
      746       746    2           }
      747       747    1           zb_key_curblk = zb_key_blocks;
      748       748    1           zb_key_array[zb_key_pos].debug_num = debug_num;
      749       749    1           zb_key_array[zb_key_pos++].byte_pos  = byte_pos;
      750       750    1           zb_key_dirty = 1;
      751       751    1        }
      752       752
      753       753             /*F*        NAME:       zb_purge_key
      754       754                         PURPOSE:    Writes out a buffer of keys to the key file
      755       755                         DESCRIPTION:This routine writes out a buffer of keys to
      756       756                                     the key file when the program is trying to
      757       757                                     read a block of keys when the array has some
      758       758                                     data in it that has not been written out to
      759       759                                     the key file.
      760       760             */
      761       761             /*D*        NAME:    zb_purge_key
      762       762                         CALL:    zb_purge_key()
      763       763                         INPUT:
      764       764                               NONE
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=22 
      765       765                         OUTPUT:
      766       766                               NONE
      767       767                         DESCRIPTION:
      768       768                            This routine writes out a buffer of keys to the key
      769       769                            file. The reason this routine is called is because
      770       770                            a buffer of keys is to be read in and the current
      771       771                            buffer has not been written out yet.  To show that
      772       772                            this is a partial buffer of keys a -1 is written out
      773       773                            in the last key position to indicate the end of the
      774       774                            current block of keys.  The rest of the block is filled
      775       775                            with the last key that was written to this block.
      776       776                            this is done so that when a binary search is done
      777       777                            on the block to find the key things don't get really
      778       778                            messed up.
      779       779             */
      780       780
      781       781             zb_purge_key ()
      782       782             {
      783       783    1           int   i;
      784       784    1
      785       785    1           if (zb_key_pos < ZB_KEY_ARRAY_SIZE) {
      786       786    2              zb_key_array[zb_key_pos].byte_pos = -1;
      787       787    2              zb_key_array[zb_key_pos--].debug_num = -1;
      788       788    2              i = zb_key_pos + 2;
      789       789    2              while (i < ZB_KEY_ARRAY_SIZE) {
      790       790    3                 zb_key_array[i].byte_pos = zb_key_array[zb_key_pos].byte_pos;
      791       791    3                 zb_key_array[i++].debug_num =zb_key_array[zb_key_pos].debug_num;
      792       792    3              }
      793       793    2           }
      794       794    1           if (fseek (keyfp, zb_key_curblk * ZB_KEY_ARRAY_SIZE * 8, SEEK_SET)) {
      795       795    2              zb_abort_listing ("zb_purge_key", "Trying to seek to a block of keys");
      796       796    2           }
      797       797    1           if (fwrite (zb_key_array, sizeof (char), 8 * ZB_KEY_ARRAY_SIZE, keyfp) != (
                               8 * ZB_KEY_ARRAY_SIZE)) {
      798       798    2              zb_abort_listing ("zb_purge_key", "Trying to write a block of keys");
      799       799    2           }
      800       800    1           zb_key_dirty = 0;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=23 
      801       801    1           zb_key_pos = 0;
      802       802    1           zb_key_blocks++;
      803       803    1        }
      804       804
      805       805             /*F*        NAME:       zb_write_listing
      806       806                         PURPOSE:    Writes out a listing record to the temp LS file
      807       807                         DESCRIPTION:This routine writes out a listing record
      808       808                                     to the temporary listing file.
      809       809             */
      810       810             /*D*        NAME:    zb_write_listing
      811       811                         CALL:    zb_write_listing(seek_pos, write_text, text)
      812       812                         INPUT:
      813       813                                  int   seek_pos - Position in the file where
      814       814                                                   the record is to be written
      815       815                                  int   write_text-A flag if set indicates the
      816       816                                                   text is to be written out to
      817       817                                                   the file
      818       818                                  char  text[]   - Actual text to be possibly
      819       819                                                   written out to the file
      820       820                         OUTPUT:
      821       821                                  NONE
      822       822                         DESCRIPTION:
      823       823                            This routine writes out a listing record. It positions
      824       824                            the file if neccessary and always write outs the
      825       825                            information about the record, and if the write_text
      826       826                            flag is non zero it writes out the text as well
      827       827             */
      828       828
      829       829             zb_write_listing (seek_pos, write_text, text)
      830       830             int   seek_pos;
      831       831             int   write_text;
      832       832             char  *text;
      833       833             {
      834       834    1           int   nbytes = 40;
      835       835    1
      836       836    1           if (seek_pos != zb_list_seek_pos)
      837       837    1              if (fseek (listfp, seek_pos, SEEK_SET)) {
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=24 
      838       838    2                 zb_abort_listing ("zb_write_listing", "Trying to seek to a listing re
                               cord");
      839       839    2              }
      840       840    1           zb_list_seek_pos = seek_pos + nbytes;
      841       841    1           if (fwrite (&zb_list_info, sizeof(char), nbytes, listfp) != nbytes) {
      842       842    2              zb_abort_listing ("zb_write_listing", "Trying to write listing record in
                               formation");
      843       843    2           }
      844       844    1           if (write_text) {
      845       845    2              zb_lastls_rec = zb_lastls_write_pos = zb_last_ls_text;
      846       846    2              if (fwrite (text, sizeof(char), zb_list_info.nbytes, listfp) != zb_list_
                               info.nbytes) {
      847       847    3                 zb_abort_listing ("zb_write_listing", "Trying to write listing record
                                text");
      848       848    3              }
      849       849    2              zb_list_seek_pos += zb_list_info.nbytes;
      850       850    2              zb_last_ls_text += nbytes + zb_list_info.nbytes;
      851       851    2           }
      852       852    1        }
      853       853
      854       854             /*F*        NAME:       zb_read_ls_record
      855       855                         PURPOSE:    Read a listing record
      856       856                         DESCRIPTION:This routine reads a listing record from
      857       857                                     the temporary listing file.
      858       858             */
      859       859             /*D*        NAME:    zb_read_ls_record
      860       860                         CALL:    zb_read_ls_record (seek_pos, read_text, text)
      861       861                         INPUT:
      862       862                                  int   seek_pos - Position in the file of the
      863       863                                                   record that is to be read
      864       864                                  int   read_text -A flag if set indicates the
      865       865                                                   text of the record is to be read
      866       866                         OUTPUT:
      867       867                                  char  text[]   - If the text was requested to be
      868       868                                                   read it contains the text that
      869       869                                                   was read
      870       870                         DESCRIPTION:
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=25 
      871       871                            This routine reads a listing record from the temporary
      872       872                            listing file. If necessary it seeks to the correct
      873       873                            position of the file, and reads the information about
      874       874                            the record, and if requested it reads the text of the
      875       875                            record
      876       876             */
      877       877
      878       878             zb_read_ls_record (seek_pos, read_text, text)
      879       879             int   seek_pos;
      880       880             int   read_text;
      881       881             char  *text;
      882       882             {
      883       883    1           int   nbytes = 40;
      884       884    1           if (seek_pos != zb_list_seek_pos)
      885       885    1              if (fseek (listfp, seek_pos, SEEK_SET)) {
      886       886    2                 zb_abort_listing ("zb_read_ls_record", "Trying to seek to a listing r
                               ecord");
      887       887    2              }
      888       888    1              zb_lastls_rec = seek_pos;
      889       889    1           zb_list_seek_pos = seek_pos + nbytes;
      890       890    1           if (fread (&zb_list_info, sizeof(char), 40, listfp) != 40) {
      891       891    2              zb_abort_listing ("zb_read_ls_record", "Trying to read listing record in
                               formation");
      892       892    2           }
      893       893    1           if (read_text) {
      894       894    2              nbytes = zb_list_info.nbytes;
      895       895    2              zb_list_seek_pos += zb_list_info.nbytes;
      896       896    2           if (fread (text, sizeof(char), zb_list_info.nbytes, listfp) != zb_list_info
                               .nbytes) {
      897       897    3              zb_abort_listing ("zb_read_ls_record", "Trying to read listing record te
                               xt");
      898       898    3              }
      899       899    2              if (*(text + zb_list_info.nbytes - 2) == '\n')
      900       900    2                 *(text + zb_list_info.nbytes - 2) = '\0';
      901       901    2           }
      902       902    1        }
      903       903
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=26 
      904       904             /*F*           NAME:       zb_read_ls_err_record
      905       905                            PURPOSE:    Reads an error record
      906       906                            DESCRIPTION:This routine reads an error record from
      907       907                                        either the error file or the listing file
      908       908                                        depending on the value of errfile
      909       909             */
      910       910             /*D*           NAME:    zb_read_ls_err_record
      911       911                            CALL:    zb_read_ls_err_record(seek_pos,read_text,errfile,text)

      912       912                            INPUT:
      913       913                                  int   seek_pos - Position in the file of the
      914       914                                                   record to be read
      915       915                                  int   read_text- A flag if set indicates that the
      916       916                                                   error text must be read
      917       917                                  int   errfile  - A flag if set indicates to read
      918       918                                                   from the errfile, otherwise read
      919       919                                                   from the listing file for the
      920       920                                                   error record
      921       921                            OUTPUT:
      922       922                                  char  text[]   - A buffer that will contain the
      923       923                                                   error message text if it was
      924       924                                                   requested
      925       925                            DESCRIPTION:
      926       926                               This routine reads an error record.  This error
      927       927                               record can be from one of two files (ERRFP or LISTFP)
      928       928                               It reads from ERRFP if errfile is set else it reads
      929       929                               from LISTFP.  The file will be positioned to the
      930       930                               correct position and the general information will
      931       931                               be read. If requested the text of the error message
      932       932                               will also be read
      933       933             */
      934       934
      935       935             zb_read_ls_err_record (seek_pos, read_text, errfile, text)
      936       936             int   seek_pos;
      937       937             int   read_text;
      938       938             int   errfile;
      939       939             char  *text;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=27 
      940       940             {
      941       941    1           int   nbytes = 16;
      942       942    1
      943       943    1           if (errfile) {
      944       944    2              if (fseek (errfp, seek_pos, SEEK_SET)) {
      945       945    3                 zb_abort_listing ("zb_read_ls_err_record", "Trying to seek to a error
                                record in error file");
      946       946    3              }
      947       947    2              if (fread (&zb_error_info, sizeof(char), 16, errfp) != 16) {
      948       948    3                 zb_abort_listing ("zb_read_ls_err_record", "Trying to read error reco
                               rd information in error file");
      949       949    3              }
      950       950    2              if (read_text) {
      951       951    3                 nbytes = zb_error_info.nbytes;
      952       952    3                 if (fread (text, sizeof(char), zb_error_info.nbytes, errfp) != zb_err
                               or_info.nbytes) {
      953       953    4                    zb_abort_listing ("zb_read_ls_err_record", "Trying to read error r
                               ecord text in error file");
      954       954    4                 }
      955       955    3                 if (*(text + zb_error_info.nbytes - 2) == '\n')
      956       956    3                    *(text + zb_error_info.nbytes - 2) = '\0';
      957       957    3              }
      958       958    2           }
      959       959    1           else {
      960       960    2              if (seek_pos != zb_list_seek_pos)
      961       961    2                 if (fseek (listfp, seek_pos, SEEK_SET)) {
      962       962    3                    zb_abort_listing ("zb_read_ls_err_record", "Trying to seek to erro
                               r record in listing file");
      963       963    3                 }
      964       964    2              zb_list_seek_pos = seek_pos + nbytes;
      965       965    2                 if (fread (&zb_error_info, sizeof(char), 16, listfp) != 16) {
      966       966    3                    zb_abort_listing ("zb_read_ls_err_record", "Trying to read error r
                               ecord information in listing file");
      967       967    3                 }
      968       968    2              if (read_text) {
      969       969    3                 nbytes = zb_error_info.nbytes;
      970       970    3                 zb_list_seek_pos += zb_error_info.nbytes;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=28 
      971       971    3                 if (fread (text, sizeof(char), zb_error_info.nbytes, listfp) != zb_er
                               ror_info.nbytes) {
      972       972    4                    zb_abort_listing ("zb_read_ls_err_record", "Trying to read error r
                               ecord text in listing file");
      973       973    4                 }
      974       974    3                 if (*(text + zb_error_info.nbytes - 2) == '\n')
      975       975    3                    *(text + zb_error_info.nbytes - 2) = '\0';
      976       976    3              }
      977       977    2           }
      978       978    1        }
      979       979
      980       980             /*F*           NAME:       zb_write_err_listing
      981       981                            PURPOSE:    Writes an error record
      982       982                            DESCRIPTION:This routine writes an error record to
      983       983                                        either the error file or the listing file
      984       984                                        depending on the value of errfile
      985       985             */
      986       986             /*D*           NAME:    zb_write_err_listing
      987       987                            CALL:    zb_write_err_listing(seek_pos,write_text,errfile,text)

      988       988                            INPUT:
      989       989                                  int   seek_pos - Position in the file of the
      990       990                                                   record to be written
      991       991                                  int   write_text- A flag if set indicates that the
      992       992                                                   error text must be written
      993       993                                  int   errfile  - A flag if set indicates that the
      994       994                                                   write is supposed to go to the
      995       995                                                   error file, otherwise the record
      996       996                                                   gets written to the listing file
      997       997                            OUTPUT:
      998       998                                  char  text[]   - A buffer that contains the
      999       999                                                   error message text to be written
     1000      1000                                                   out if requested
     1001      1001                            DESCRIPTION:
     1002      1002                               This routine writes an error record.  This error
     1003      1003                               record can be written to one of two files (ERRFP or LISTFP)
     1004      1004                               It writes to ERRFP if errfile is set else it writes
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=29 
     1005      1005                               to LISTFP.  The file will be positioned to the
     1006      1006                               correct position and the general information will
     1007      1007                               be written. If requested the text of the error message
     1008      1008                               will also be written
     1009      1009             */
     1010      1010
     1011      1011             zb_write_err_listing (seek_pos, write_text, errfile, text)
     1012      1012             int   seek_pos;
     1013      1013             int   write_text;
     1014      1014             int   errfile;
     1015      1015             char  *text;
     1016      1016             {
     1017      1017    1           int nbytes = 16;
     1018      1018    1           if (errfile) {
     1019      1019    2              if (fseek (errfp, seek_pos, SEEK_SET)) {
     1020      1020    3                 zb_abort_listing ("zb_write_err_listing", "Trying to seek to error re
                               cord in error file");
     1021      1021    3              }
     1022      1022    2              if (fwrite (&zb_error_info, sizeof(char), nbytes, errfp) != nbytes) {
     1023      1023    3                 zb_abort_listing ("zb_write_err_listing", "Trying to write error reco
                               rd information in error file");
     1024      1024    3              }
     1025      1025    2              if (write_text) {
     1026      1026    3                 if (fwrite (text, sizeof(char), zb_error_info.nbytes, errfp) != zb_er
                               ror_info.nbytes) {
     1027      1027    4                    zb_abort_listing ("zb_write_err_listing", "Trying to write error r
                               ecord text in error file");
     1028      1028    4                 }
     1029      1029    3                 zb_last_err_text += nbytes + zb_error_info.nbytes;
     1030      1030    3              }
     1031      1031    2           }
     1032      1032    1           else {
     1033      1033    2              if (seek_pos != zb_list_seek_pos)
     1034      1034    2                 if (fseek (listfp, seek_pos, SEEK_SET)) {
     1035      1035    3                    zb_abort_listing ("zb_write_err_listing", "Trying to seek to error
                                record in listing file");
     1036      1036    3                 }
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=30 
     1037      1037    2              zb_list_seek_pos = seek_pos + nbytes;
     1038      1038    2              if (fwrite (&zb_error_info, sizeof(char), nbytes, listfp) != nbytes) {
     1039      1039    3                 zb_abort_listing ("zb_write_err_listing", "Trying to write error reco
                               rd information in listing file");
     1040      1040    3              }
     1041      1041    2              if (write_text) {
     1042      1042    3                 if (fwrite (text, sizeof(char), zb_error_info.nbytes, listfp) != zb_e
                               rror_info.nbytes) {
     1043      1043    4                    zb_abort_listing ("zb_write_err_listing", "Trying to write error r
                               ecord text in listing file");
     1044      1044    4                 }
     1045      1045    3                 zb_list_seek_pos += zb_error_info.nbytes;
     1046      1046    3                 zb_last_ls_text += nbytes + zb_error_info.nbytes;
     1047      1047    3              }
     1048      1048    2           }
     1049      1049    1        }
     1050      1050
     1051      1051             /*F*        NAME:       zb_get_key
     1052      1052                         PURPOSE:    Find offset of listing record from BOF
     1053      1053                         DESCRIPTION:This routine finds the offset from BOF of
     1054      1054                                     a listing record with the passed in debug
     1055      1055                                     line number.
     1056      1056             */
     1057      1057             /*D*        NAME:    zb_get_key
     1058      1058                         CALL:    zb_get_key (linenum)
     1059      1059                         INPUT:
     1060      1060                               int   linenum  - The debug line nmuber of the record
     1061      1061                                                that is to be found
     1062      1062                         OUTPUT:
     1063      1063                               This routine returns the offset of from the beginning
     1064      1064                               of the listing file of where the record starts.
     1065      1065                               If the debug linenumber is less than the smallest
     1066      1066                               debug number of the file a -1 is returned. And if
     1067      1067                               the exact debug line number is not found the next
     1068      1068                               smallest debug linenumber is returned.
     1069      1069                         DESCRIPTION:
     1070      1070                            This routine finds the offset from the beginning of
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=31 
     1071      1071                            file of a listing record with the corresponding debug
     1072      1072                            line number.  It uses the key file to find the correct
     1073      1073                            debug number, and does a binary search on it to find
     1074      1074                            the correct record.  If the record number is smaller
     1075      1075                            than the smallest debug line number a -1 is returned,
     1076      1076                            else is the debug number is not found the next smallest
     1077      1077                            debug number's offset is used.
     1078      1078             */
     1079      1079
     1080      1080             zb_get_key (linenum)
     1081      1081             int   linenum;
     1082      1082             {
     1083      1083    1           int   done;
     1084      1084    1           int   byte_pos = 0;
     1085      1085    1           int   blocknum;
     1086      1086    1           int   low;
     1087      1087    1           int   high;
     1088      1088    1           int   mid;
     1089      1089    1           int   lastmid = -1;
     1090      1090    1
     1091      1091    1           int   toploc;
     1092      1092    1           done = 0;
     1093      1093    1           if ((zb_key_pos == 0) && (zb_key_blocks == 0))
     1094      1094    1              return (-1);
     1095      1095    1           toploc = zb_key_pos - 1;
     1096      1096    1           blocknum = zb_key_curblk;
     1097      1097    1           while (!done) {
     1098      1098    2              if (zb_key_array[toploc].debug_num == -1)
     1099      1099    2                 toploc--;
     1100      1100    2              if ((linenum >= zb_key_array[0].debug_num) &&
     1101      1101    2                  (linenum <= zb_key_array[toploc].debug_num)) {
     1102      1102    3        /*    Have the correct block for key in the array                  */
     1103      1103    3                 low = 0;
     1104      1104    3                 high = toploc;
     1105      1105    3                 mid = high / 2;
     1106      1106    3                 while (!done) {
     1107      1107    4                    if (zb_key_array[mid].debug_num == -1)
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=32 
     1108      1108    4                       mid--;
     1109      1109    4                    if (zb_key_array[mid].debug_num == linenum) {
     1110      1110    5                       done = 1;
     1111      1111    5                       byte_pos = zb_key_array[mid].byte_pos;
     1112      1112    5                    }
     1113      1113    4                    if (mid == lastmid) {
     1114      1114    5                       done = 1;
     1115      1115    5                       byte_pos = zb_key_array[mid].byte_pos;
     1116      1116    5                    }
     1117      1117    4                    else if (zb_key_array[mid].debug_num < linenum) {
     1118      1118    5                       low = mid + 1;
     1119      1119    5                       lastmid = mid;
     1120      1120    5                       mid = (low + high) / 2;
     1121      1121    5                    }
     1122      1122    4                    else {
     1123      1123    5                       high = mid - 1;
     1124      1124    5                       lastmid = mid;
     1125      1125    5                       mid = (low + high) / 2;
     1126      1126    5                    }
     1127      1127    4                 }
     1128      1128    3              }
     1129      1129    2              else if (linenum < zb_key_array[0].debug_num) {
     1130      1130    3                 if (--blocknum >= 0)
     1131      1131    3                    zb_read_key_block (blocknum);
     1132      1132    3                 else {
     1133      1133    4                    done = 1;
     1134      1134    4                    byte_pos = - zb_key_array[0].byte_pos;
     1135      1135    4                    blocknum++;
     1136      1136    4                    if (blocknum == 0)
     1137      1137    4                       byte_pos = -1; /* error goes at begining of LS   */
     1138      1138    4                 }
     1139      1139    3                 toploc = ZB_KEY_ARRAY_SIZE - 1;
     1140      1140    3              }
     1141      1141    2              else {
     1142      1142    3                 ++blocknum;
     1143      1143    3                 if ((blocknum < zb_key_blocks) || ((blocknum == zb_key_blocks) && (zb
                               _key_dirty))) {
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=33 
     1144      1144    4                    zb_read_key_block (blocknum);
     1145      1145    4                 }
     1146      1146    3                 else {
     1147      1147    4                    done = 1;
     1148      1148    4                    byte_pos = zb_key_array[toploc].byte_pos;
     1149      1149    4                    if (byte_pos == -1) /* was -1 which is EOblock marker*/
     1150      1150    4                    byte_pos = zb_key_array[toploc-1].byte_pos;
     1151      1151    4                    blocknum--;
     1152      1152    4                 }
     1153      1153    3                 toploc = ZB_KEY_ARRAY_SIZE - 1;
     1154      1154    3              }
     1155      1155    2           }
     1156      1156    1           zb_key_curblk = blocknum;
     1157      1157    1           return (byte_pos);
     1158      1158    1        }
     1159      1159
     1160      1160             /*F*        NAME:       zb_listing_output_ls
     1161      1161                         PURPOSE:    Output the complete listing to the final file
     1162      1162                         DESCRIPTION:This routine outputs the complete listing
     1163      1163                                     to the output file (M$LO).
     1164      1164             */
     1165      1165             /*D*        NAME:    zb_listing_output_ls
     1166      1166                         CALL:    zb_listing_output_ls
     1167      1167                         INPUT:
     1168      1168                                  NONE
     1169      1169                         OUTPUT:
     1170      1170                                  NONE
     1171      1171                         DESCRIPTION:
     1172      1172                            This routine outputs the entire listing file to the
     1173      1173                            output file (M$LO).  It merges the listing source
     1174      1174                            records with the error messages, blank lines, and
     1175      1175                            page breaks.
     1176      1176             */
     1177      1177
     1178      1178             zb_listing_output_ls ()
     1179      1179             {
     1180      1180    1           int   errrec;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=34 
     1181      1181    1           int   i;
     1182      1182    1           int   j;
     1183      1183    1           int   vfc;
     1184      1184    1
     1185      1185    1           if (!zb_list_on) return;
     1186      1186    1
     1187      1187    1        /*    Position the temporary files to the beginning of file        */
     1188      1188    1
     1189      1189    1
     1190      1190    1           if (zb_key_dirty) {
     1191      1191    2              zb_purge_key();
     1192      1192    2           }
     1193      1193    1           zb_key_blocks--;
     1194      1194    1           fseek (errfp, 0, SEEK_SET);
     1195      1195    1           fseek (listfp, 0, SEEK_SET);
     1196      1196    1           fseek (keyfp, 0, SEEK_SET);
     1197      1197    1
     1198      1198    1
     1199      1199    1        /*    Create the formats for the strings that are needed to be
     1200      1200    1              written out to the output file.                              */
     1201      1201    1
     1202      1202    1           sys_fileinfo (outfp, &out_setting);
     1203      1203    1           zb_lines_per_page = out_setting.file_org.ur.lines;
     1204      1204    1           zb_text_size = out_setting.file_org.ur.width - ZB_FIXED_SIZE - 1;
     1205      1205    1           if (zb_lines_per_page == 0)
     1206      1206    1              zb_lines_per_page = ZB_STDLP;
     1207      1207    1           else if (zb_lines_per_page < ZB_MIN_LENGTH)
     1208      1208    1              zb_lines_per_page = ZB_MIN_LENGTH;
     1209      1209    1           if (zb_text_size < ZB_MIN_WIDTH)
     1210      1210    1              zb_text_size = ZB_MIN_WIDTH;
     1211      1211    1           sprintf (zb_form_err, "A%%-.%ds\n\0",zb_text_size + ZB_FIXED_SIZE);
     1212      1212    1           sprintf (zb_form_rec, "A%%9s%%9d%%5d        %%-.%ds\n\0",zb_text_size);
     1213      1213    1           sprintf (zb_form_rec2, "A%%9s%%9d             %%-.%ds\n\0",zb_text_size);
     1214      1214    1           sprintf (zb_form_rec3, "A%%9s%%9d   *S*       %%-.%ds\n\0",zb_text_size);
     1215      1215    1           sprintf (zb_form_rec_cont, "A%%%ds%%-.%ds\n\0",ZB_FIXED_SIZE, zb_text_size)
                               ;
     1216      1216    1
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=35 
     1217      1217    1        #ifndef  _CP6_
     1218      1218   *S*          Create_Top_Of_Form();
     1219      1219   *S*       #endif
     1220      1220    1
     1221      1221    1           OUTPUT_TOP_OF_FORM;
     1222      1222    1
     1223      1223    1        #ifdef   _CP6_
     1224      1224    1           sys_heading(outfp, zb_form_page2, &zb_pagenum);
     1225      1225    1        #endif
     1226      1226    1
     1227      1227    1        /*    Now with all the files positioned correctly write out the
     1228      1228    1              errors that may have occured before the first piece of
     1229      1229    1              text was outputed to the LS file                             */
     1230      1230    1
     1231      1231    1           if ((zb_begerr) && (B$JIT$->prflags.list)) {
     1232      1232    2              errrec = 0;
     1233      1233    2                 while (errrec >= 0) {
     1234      1234    3                    zb_read_ls_err_record (errrec, 1, 1, zb_err_text);
     1235      1235    3                    errrec = zb_error_info.next_err;
     1236      1236    3                    output_error_rec (outfp, zb_err_text);
     1237      1237    3                 }
     1238      1238    2           }
     1239      1239    1
     1240      1240    1        /*    Keep reading the keyed file until EOF and output the
     1241      1241    1              corresponding LS record(s)                                   */
     1242      1242    1
     1243      1243    1           for (j=0; (j<=zb_key_blocks && B$JIT$->prflags.list); j++) {
     1244      1244    2              zb_read_key_block(j);
     1245      1245    2              for (i=0; i<ZB_KEY_ARRAY_SIZE && zb_key_array[i].byte_pos!=-1; i++) {
     1246      1246    3
     1247      1247    3                 if (zb_key_array[i].byte_pos >= 0) {
     1248      1248    4                 zb_read_ls_record (zb_key_array[i].byte_pos, 1, zb_ls_text);
     1249      1249    4
     1250      1250    4                 errrec = zb_list_info.extra_text;
     1251      1251    4                 output_list_rec (outfp, &errrec, zb_err_text);
     1252      1252    4                 while (errrec > 0) {
     1253      1253    5                    zb_read_ls_err_record (errrec, 1, 0, zb_err_text);
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=36 
     1254      1254    5                    errrec = zb_error_info.next_err;
     1255      1255    5                    output_error_rec (outfp, zb_err_text);
     1256      1256    5                 }
     1257      1257    4        /*    Write out the possible linefeeds and/or formfeeds for the
     1258      1258    4              current record (write out after the errors though)           */
     1259      1259    4
     1260      1260    4                 if ((zb_list_info.formfeed) && (!zb_top_form)) {
     1261      1261    5                    OUTPUT_TOP_OF_FORM;
     1262      1262    5        #ifdef   _CP6_
     1263      1263    5                    sys_heading (outfp, zb_form_page2, &zb_pagenum);
     1264      1264    5        #endif
     1265      1265    5                 }
     1266      1266    4                 else if (zb_list_info.linefeed) {
     1267      1267    5                    zb_linenum += zb_list_info.linefeed;
     1268      1268    5                    if (zb_linenum >= zb_lines_per_page) {
     1269      1269    6                       OUTPUT_TOP_OF_FORM;
     1270      1270    6        #ifdef   _CP6_
     1271      1271    6                       sys_heading (outfp, zb_form_page2, &zb_pagenum);
     1272      1272    6        #endif
     1273      1273    6                    }
     1274      1274    5                    else {
     1275      1275    6                       vfc = 'A' + zb_list_info.linefeed - 1;
     1276      1276    6                       while (vfc > 'O') {
     1277      1277    7                          sys_write (outfp, "o\n", 2);
     1278      1278    7                          vfc = (vfc - 'O') + 'A' - 1;
     1279      1279    7                       }
     1280      1280    6                       sprintf (zb_output_str, "%c\n\0", vfc);
     1281      1281    6                       sys_write (outfp,zb_output_str,strlen(zb_output_str));
     1282      1282    6                    }
     1283      1283    5                 }
     1284      1284    4                 }
     1285      1285    3              }
     1286      1286    2           }
     1287      1287    1
     1288      1288    1        /*    Output some summary information about errors                 */
     1289      1289    1
     1290      1290    1           if (zb_head_inc) {
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=37 
     1291      1291    2              if (zb_linenum != 3)
     1292      1292    2                 OUTPUT_TOP_OF_FORM;
     1293      1293    2              strcpy (zb_output_str,"A---  Include file information  ---\nA\n");
     1294      1294    2              sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1295      1295    2              zb_linenum += 2;
     1296      1296    2              while (zb_head_inc) {
     1297      1297    3                 sprintf (zb_output_str,"A   %s is referenced\n",zb_head_inc->name);
     1298      1298    3                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1299      1299    3                 if (++zb_linenum >=zb_lines_per_page)
     1300      1300    3                    OUTPUT_TOP_OF_FORM;
     1301      1301    3                 zb_head_inc = zb_head_inc->next;
     1302      1302    3              }
     1303      1303    2           }
     1304      1304    1           sys_write (outfp, "C\n", 2);
     1305      1305    1           zb_linenum += 2;
     1306      1306    1           if (zb_linenum >= zb_lines_per_page)
     1307      1307    1              OUTPUT_TOP_OF_FORM;
     1308      1308    1           if ((!zb_numerrs) && (!zb_numwarns)) {
     1309      1309    2                 sprintf (zb_output_str, "ANo diagnostics were issued in the file %s\n
                               ",
     1310      1310    2                          list_base_file);
     1311      1311    2                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1312      1312    2           }
     1313      1313    1           else {
     1314      1314    2              if (zb_numerrs == 1) {
     1315      1315    3                 sprintf (zb_output_str, "A1 error was detected in the file %s\n",
     1316      1316    3                          list_base_file);
     1317      1317    3                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1318      1318    3              }
     1319      1319    2              else if (zb_numerrs > 1) {
     1320      1320    3                 sprintf (zb_output_str, "A%d errors were detected in the file %s\n",
     1321      1321    3                          zb_numerrs, list_base_file);
     1322      1322    3                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1323      1323    3              }
     1324      1324    2              if (zb_numwarns == 1) {
     1325      1325    3                 sprintf (zb_output_str, "A1 warning was detected in the file %s\n",
     1326      1326    3                          list_base_file);
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=38 
     1327      1327    3                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1328      1328    3              }
     1329      1329    2              else if (zb_numwarns > 1) {
     1330      1330    3                 sprintf (zb_output_str, "A%d warnings were detected in the file %s\n"
                               ,
     1331      1331    3                          zb_numwarns, list_base_file);
     1332      1332    3                 sys_write (outfp, zb_output_str, strlen(zb_output_str));
     1333      1333    3              }
     1334      1334    2           }
     1335      1335    1
     1336      1336    1        /*    Close all of the files up                                     */
     1337      1337    1           sys_close (outfp);
     1338      1338    1        }
     1339      1339
     1340      1340             /*F*        NAME:       output_error_rec
     1341      1341                         PURPOSE:    Output an error record to the output file
     1342      1342                         DESCRIPTION:This routine outputs a error record out to
     1343      1343                                     the output file (M$LO) or the error file (STDERR).
     1344      1344             */
     1345      1345             /*D*        NAME:    output_error_rec
     1346      1346                         CALL:    output_error_rec (fp, text)
     1347      1347                         INPUT:
     1348      1348                               File  *fp   - The file pointer that the output
     1349      1349                                             record is to be written to.
     1350      1350                               char  text[]- The actual text of the error record
     1351      1351                                             that is to be written out
     1352      1352                         OUTPUT:
     1353      1353                               NONE
     1354      1354                         DESCRIPTION:
     1355      1355                            This routine outputs a formatted error record to either
     1356      1356                            the erroutfp (STDERR) or outfp (M$LO) depending on the
     1357      1357                            value of fp.  This routine outputs a ^ that points to
     1358      1358                            the position in the record that contains the error
     1359      1359             */
     1360      1360
     1361      1361             output_error_rec (fp, text)
     1362      1362             File  *fp;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=39 
     1363      1363             char  text[];
     1364      1364             {
     1365      1365    1           int   i;
     1366      1366    1           int   nbytes;
     1367      1367    1
     1368      1368    1           if (fp == outerrfp)
     1369      1369    1              fp->o_flags |= OP_VFC;
     1370      1370    1           if (zb_error_info.pos_err > 0) {
     1371      1371    2              zb_error_info.pos_err = zb_error_info.pos_err % zb_text_size;
     1372      1372    2              sprintf (zb_form_err_pos,"A%%%ds\n",zb_error_info.pos_err + ZB_FIXED_SIZ
                               E);
     1373      1373    2              sprintf (zb_output_str,zb_form_err_pos,"^");
     1374      1374    2              sys_write (fp, zb_output_str, strlen (zb_output_str));
     1375      1375    2              CHECK_TOP_OF_FORM;
     1376      1376    2           }
     1377      1377    1           sprintf (zb_output_str, zb_form_err, text);
     1378      1378    1           sys_write (fp, zb_output_str, strlen(zb_output_str));
     1379      1379    1           CHECK_TOP_OF_FORM;
     1380      1380    1           nbytes = zb_error_info.nbytes - 1;
     1381      1381    1           i = zb_text_size + ZB_FIXED_SIZE;
     1382      1382    1           while (nbytes > i) {
     1383      1383    2              sprintf (zb_output_str, zb_form_err, &(text[i]));
     1384      1384    2              sys_write (fp, zb_output_str, strlen(zb_output_str));
     1385      1385    2              i += zb_text_size + ZB_FIXED_SIZE;
     1386      1386    2           CHECK_TOP_OF_FORM;
     1387      1387    2           }
     1388      1388    1           if (fp == outerrfp)
     1389      1389    1              fp->o_flags ^= OP_VFC;
     1390      1390    1        }
     1391      1391
     1392      1392             /*F*        NAME:       output_list_rec
     1393      1393                         PURPOSE:    Output a formatted listing record to a file
     1394      1394                         DESCRIPTION:This routine outputs a formatted listing
     1395      1395                                     record to a file, either STDERR or M$LO.
     1396      1396             */
     1397      1397             /*D*        NAME:    output_list_rec
     1398      1398                         CALL:    output_list_rec (fp, errflag, err_text_buf)
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=40 
     1399      1399                         INPUT:
     1400      1400                                  File  *fp   - The output file that is to receive
     1401      1401                                                the formatted listing record
     1402      1402                                  int   *errflag - Position in the listing file of
     1403      1403                                                   where the error record is located,
     1404      1404                                                   if there is one. Otherwise it == -1
     1405      1405                                  char  err_text_buf[] - A buffer that will receive
     1406      1406                                                         the error record (if any)
     1407      1407                         OUTPUT:
     1408      1408                               NONE
     1409      1409                         DESCRIPTION:
     1410      1410                            This routine outputs a formatted listing record to the
     1411      1411                            output file (STDERR or M$LO).  If this record contains
     1412      1412                            an error message, the first one is outputted imbedded
     1413      1413                            within the listing record. This routine though only
     1414      1414                            outputs the first error record.
     1415      1415             */
     1416      1416
     1417      1417             output_list_rec (fp, errflag, err_text_buf)
     1418      1418             File  *fp;
     1419      1419             int   *errflag;
     1420      1420             char  err_text_buf[];
     1421      1421             {
     1422      1422    1           int   i;
     1423      1423    1           int   nbytes;
     1424      1424    1           int   pos_carat = -1;
     1425      1425    1
     1426      1426    1           if (fp == outerrfp)
     1427      1427    1              fp->o_flags |= OP_VFC;
     1428      1428    1           if (zb_list_info.nest_lev == 0) {
     1429      1429    2              sprintf (zb_output_str, zb_form_rec2, zb_list_info.rec_source,zb_list_in
                               fo.debugnum,
     1430      1430    2                       zb_ls_text);
     1431      1431    2           }
     1432      1432    1           else if (zb_list_info.nest_lev < 0) {
     1433      1433    2              sprintf (zb_output_str, zb_form_rec3, zb_list_info.rec_source,zb_list_in
                               fo.debugnum,
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=41 
     1434      1434    2                       zb_ls_text);
     1435      1435    2           }
     1436      1436    1           else {
     1437      1437    2              sprintf (zb_output_str, zb_form_rec, zb_list_info.rec_source,zb_list_inf
                               o.debugnum,
     1438      1438    2                       zb_list_info.nest_lev, zb_ls_text);
     1439      1439    2           }
     1440      1440    1           if (zb_list_info.formfeed) {
     1441      1441    2              zb_output_str[0] = 'P';
     1442      1442    2           }
     1443      1443    1           sys_write (fp,zb_output_str,strlen(zb_output_str));
     1444      1444    1           CHECK_TOP_OF_FORM;
     1445      1445    1
     1446      1446    1           if (*errflag != -1) {
     1447      1447    2              if (fp == outfp) {
     1448      1448    3                 zb_read_ls_err_record (*errflag, 1, 0, err_text_buf);
     1449      1449    3                 *errflag = zb_error_info.next_err;
     1450      1450    3              }
     1451      1451    2              if (((zb_error_info.pos_err != -1) || (fp == outfp)) && (zb_error_info.p
                               os_err < zb_text_size)) {
     1452      1452    3                 output_error_rec (fp,err_text_buf);
     1453      1453    3                 if (fp == outerrfp)
     1454      1454    3                    fp->o_flags |= OP_VFC;
     1455      1455    3              }
     1456      1456    2              else
     1457      1457    2                 pos_carat = zb_error_info.pos_err - zb_text_size;
     1458      1458    2           }
     1459      1459    1           nbytes = zb_list_info.nbytes - 1;
     1460      1460    1           i = zb_text_size;
     1461      1461    1           while (nbytes > i) {
     1462      1462    2              sprintf (zb_output_str,zb_form_rec_cont," ",&(zb_ls_text[i]));
     1463      1463    2              i += zb_text_size;
     1464      1464    2              sys_write (fp, zb_output_str, strlen(zb_output_str));
     1465      1465    2              CHECK_TOP_OF_FORM;
     1466      1466    2              if (pos_carat != -1) {
     1467      1467    3                 if (pos_carat < zb_text_size) {
     1468      1468    4                    output_error_rec (fp, err_text_buf);
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=42 
     1469      1469    4                    pos_carat = -1;
     1470      1470    4                 }
     1471      1471    3                 else
     1472      1472    3                    pos_carat -= zb_text_size;
     1473      1473    3              }
     1474      1474    2           }
     1475      1475    1           if (fp == outerrfp)
     1476      1476    1              fp->o_flags ^= OP_VFC;
     1477      1477    1        }
     1478      1478             Create_Top_Of_Form()
     1479      1479             {
     1480      1480    1           int   blank_len = 22;
     1481      1481    1           int   date_len = 15;
     1482      1482    1           int   vers_len = 0;
     1483      1483    1           int   base_len = 0;
     1484      1484    1           int   update_len = 0;
     1485      1485    1           int   page_len = 4;
     1486      1486    1           int   tot_len = 0;
     1487      1487    1           int   act_len = 0;
     1488      1488    1           int   nam_len = 0;
     1489      1489    1           int   acct_pos = 0;
     1490      1490    1           char  *cp;
     1491      1491    1           char  *strindex();
     1492      1492    1
     1493      1493    1        /*    Get the lengths for each piece of the form                   */
     1494      1494    1           vers_len = strlen (list_comp_vers);
     1495      1495    1           nam_len = strlen (list_prog_name);
     1496      1496    1           if (list_base_file)
     1497      1497    1              base_len = strlen (list_base_file);
     1498      1498    1           if (list_update_file)
     1499      1499    1              update_len = strlen (list_update_file);
     1500      1500    1           tot_len = vers_len + base_len + update_len + date_len + page_len + blank_le
                               n + nam_len;
     1501      1501    1           sys_fileinfo(outfp, &out_setting);
     1502      1502    1           act_len = out_setting.file_org.ur.width;
     1503      1503    1           if (tot_len > act_len) {
     1504      1504    2              tot_len -= update_len;
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=43 
     1505      1505    2              update_len = 0;
     1506      1506    2              if (tot_len > act_len) {
     1507      1507    3        /*    First remove the possible disk pack off the name             */
     1508      1508    3                 if (cp = strindex (list_base_file,'/')) {
     1509      1509    4                    tot_len -= base_len;
     1510      1510    4                    base_len = strlen (++cp);
     1511      1511    4                    list_base_file = cp;
     1512      1512    4                    tot_len += base_len;
     1513      1513    4                 }
     1514      1514    3        /*    Remove the ACCT and possibly part of the name                */
     1515      1515    3                 if (tot_len > act_len) {
     1516      1516    4                    if (cp = strindex (list_base_file, '.')) {
     1517      1517    5                       acct_pos = cp - list_base_file;
     1518      1518    5                       cp = '\0';
     1519      1519    5                    }
     1520      1520    4                    if ((tot_len - acct_pos) > act_len) {
     1521      1521    5                       base_len = act_len - (tot_len - base_len);
     1522      1522    5                       act_len = tot_len;
     1523      1523    5                    }
     1524      1524    4                    else {
     1525      1525    5                       act_len -= base_len - acct_pos;
     1526      1526    5                       base_len = acct_pos;
     1527      1527    5                    }
     1528      1528    4                 }
     1529      1529    3              }
     1530      1530    2           }
     1531      1531    1
     1532      1532    1        /*    The lengths are now set up right so create the format needed */
     1533      1533    1           if (base_len == 0) {
     1534      1534    2              sprintf (zb_form_page,"r%%%ds%%%ds                    %%%ds  Page=%%s\n"
                               ,nam_len,vers_len,date_len+(act_len-tot_len));
     1535      1535    2              sprintf (zb_form_page2,zb_form_page,list_prog_name,list_comp_vers,zb_dat
                               e,"%d");
     1536      1536    2           }
     1537      1537    1           else if (update_len == 0) {
     1538      1538    2              sprintf (zb_form_page,"r%%%ds%%%ds    File=%%%ds      %%%ds  Page=%%s\n"
                               ,nam_len,vers_len,base_len,date_len+(act_len-tot_len));
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=44 
     1539      1539    2              sprintf (zb_form_page2,zb_form_page,list_prog_name,list_comp_vers,list_b
                               ase_file,zb_date,"%d");
     1540      1540    2           }
     1541      1541    1           else {
     1542      1542    2              sprintf (zb_form_page,"r%%%ds%%%ds    File=%%%ds/%%%ds     %%%ds  Page=%
                               %s\n",nam_len,vers_len,base_len,update_len,date_len+(act_len-tot_len));
     1543      1543    2              sprintf (zb_form_page2,zb_form_page,list_prog_name,list_comp_vers,list_b
                               ase_file,list_update_file,zb_date,"%d");
     1544      1544    2           }
     1545      1545    1
     1546      1546    1        }
     1547      1547             static   int   zbm_curkey;
     1548      1548
     1549      1549             void  loinit ()
     1550      1550             {
     1551      1551    1           sys_fileinfo (outfp, &out_setting);
     1552      1552    1           zb_text_size = out_setting.file_org.ur.width - ZB_FIXED_SIZE - 1;
     1553      1553    1           if (zb_text_size < ZB_MIN_WIDTH)
     1554      1554    1              zb_text_size = ZB_MIN_WIDTH;
     1555      1555    1           sprintf (zb_form_rec, "A%%9s%%9d%%5d        %%-.%ds\n\0",zb_text_size);
     1556      1556    1           sprintf (zb_form_rec2, "A%%9s%%9d             %%-.%ds\n\0",zb_text_size);
     1557      1557    1           if (zb_key_dirty) {
     1558      1558    2              zb_purge_key();
     1559      1559    2              zb_key_blocks--;
     1560      1560    2           }
     1561      1561    1           else if (!zb_LS_flag)   /* Handle case of exactly on key block */
     1562      1562    1              zb_key_blocks--;
     1563      1563    1           zbm_curkey = ZB_KEY_ARRAY_SIZE;
     1564      1564    1           zb_key_curblk = -1;
     1565      1565    1
     1566      1566    1        #ifndef  _CP6_
     1567      1567   *S*       /*    Since UNGMAP expects a heading for it to be created we must
     1568      1568   *S*             create it.  This is done in a PL6 routine                     */
     1569      1569   *S*
     1570      1570   *S*          if (!zb_LS_flag) {
     1571      1571   *S*             Create_Top_Of_Form();   /* creates C style heading */
     1572      1572   *S*          }
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=45 
     1573      1573   *S*       #endif
     1574      1574    1           sys_heading (outfp, zb_form_page2, &zb_pagenum);
     1575      1575    1           return;
     1576      1576    1        }
     1577      1577
     1578      1578             void  GET_SOURCE_REC (line_no, stmt_text, got_rec)
     1579      1579                int *line_no;
     1580      1580                char *stmt_text;
     1581      1581                int   *got_rec;
     1582      1582
     1583      1583             {
     1584      1584    1           int byte_pos;
     1585      1585    1           int debug_num = 0;
     1586      1586    1
     1587      1587    1           if (zbm_curkey >= ZB_KEY_ARRAY_SIZE || zb_key_array[zbm_curkey].byte_pos ==
                                -1) {
     1588      1588    2              debug_num = zb_key_array[zbm_curkey-1].debug_num;
     1589      1589    2              if (zb_key_curblk == zb_key_blocks) {
     1590      1590    3                 *got_rec = 0;
     1591      1591    3                 return;
     1592      1592    3              }
     1593      1593    2              if (!zb_read_key_block (zb_key_curblk + 1)) {
     1594      1594    3                 *got_rec = 0;
     1595      1595    3                 return;
     1596      1596    3              }
     1597      1597    2              if ((debug_num >= zb_key_array[0].debug_num) && (zb_key_curblk !=0)) {
     1598      1598    3                 *got_rec = 0;
     1599      1599    3                 return;
     1600      1600    3              }
     1601      1601    2              zbm_curkey = 0;
     1602      1602    2           }
     1603      1603    1
     1604      1604    1           byte_pos = zb_key_array[zbm_curkey++].byte_pos;
     1605      1605    1           if (byte_pos >=0) { /* read the record     */
     1606      1606    2              zb_read_ls_record (byte_pos, 1, zb_ls_text);
     1607      1607    2              if (zb_list_info.nest_lev == 0)
     1608      1608    2                 sprintf (stmt_text, zb_form_rec2, zb_list_info.rec_source,
CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=46 
     1609      1609    2                          zb_list_info.debugnum, zb_ls_text);
     1610      1610    2              else
     1611      1611    2                 sprintf (stmt_text, zb_form_rec, zb_list_info.rec_source,
     1612      1612    2                          zb_list_info.debugnum, zb_list_info.nest_lev,
     1613      1613    2                          zb_ls_text);
     1614      1614    2              *line_no = zb_list_info.debugnum;
     1615      1615    2           }
     1616      1616    1           *got_rec = 1;
     1617      1617    1           return;
     1618      1618    1        }
     1619      1619
     1620      1620             void loclose ()
     1621      1621             {
     1622      1622    1           ;
     1623      1623    1        }
     1624      1624
     1625      1625
     1626      1626             void zb_abort_listing (char *funcname, char *mess)
     1627      1627             {
     1628      1628    1           fprintf (stderr, "An error occured in the listing generator function %s:\n"
                               ,funcname);
     1629      1629    1           fprintf (stderr, "%s\n", mess);
     1630      1630    1           perror ((char *) 0);
     1631      1631    1           assert(0);
     1632      1632    1        }
---  Include file information  ---

   stdio:h.:LIB_E05. is referenced
   system:h.:ZBC3TOU. is referenced
   cp_6_subs:h.:LIB_E05. is referenced
   b$jit_c:h.:LIB_E05. is referenced
   xu_cp6_c:h.:LIB_E05. is referenced
   alloc:h.:ZBC3TOU. is referenced
   assert:h.:LIB_E05. is referenced
   zb_listing:h.:ZBC3TOU. is referenced

CC.C03    File=zbm$input$list_routines:c.:ZBC3TSI                                   Fri Aug 22 1997  Page=47 
2 warnings were detected in the file zbm$input$list_routines:c.:ZBC3TSI
