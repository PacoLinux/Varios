

CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=1  
        1         1             /*P*
        2         2                   NAME: ou$tables:c
        3         3                   PURPOSE: This is the module to build the constant, label,
        4         4                   and symbol tables for the building of the object units.
        5         5
        6         6             */
        7         7             #include <stdio:h>
        8         8             #include <string:h>
        9         9             #include "zbk$ougen:h"
       10        10             #include "zbk$tables:h"
       11        11             #include "zb_cp6_object:h"
       12        12
       13        13
       14        14             #define pl6str(_s_)  ( *(int *) zbk_buffer =0,\
       15        14                   strcpy( &zbk_buffer[2], _s_ ),\
       16        14                   *(int *)zbk_buffer |= strlen( &zbk_buffer[2]) << 18)
       17        17
       18        18             extern char zbk_buffer[512] ;
       19        19             struct zbk_constants *p ;
       20        20             struct zbk_labels *ll ;
       21        21             struct zbk_symbols *ss ;
       22        22
       23        23             struct zbk_labels *zbk_last_lbl_ptr;
       24        24
       25        25             int zbk_local_storage ; /*  holds the amount of local storage used in
       26        26                                     the program..  */
       27        27             int zbk_next_log_blk_num[30];
       28        28             struct zbk_blk_info_tbl {
       29        29    1              int first_var;
       30        30    1              int last_var;
       31        31    1              int first_line_no;
       32        32    1              int last_line_no;
       33        33    1              int stmt_no;
       34        34    1              int last_stmt_no;
       35        35    1              int lex_depth;
       36        36    1              int log_blk_num;
       37        37    1              int name_offset;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=2  
       38        38    1              int stmt_count;
       39        39    1              };
       40        40
       41        41             struct zbk_blk_info_tbl zbk_blk_info[20];
       42        42
       43        43             int zbk_blk_count ; /* holds nesting count of debug blk count. */
       44        44             int length ;
       45        45             int *zbk_label_hash[601];
       46        46             int *zbk_symbol_hash[601];
       47        47
       48        48
       49        49             extern int zbk$set_file_name();
       50        50             extern int zbk$set_static_storage();
       51        51             extern int zbk_debug_flag ;
       52        52             extern int zbk_integer_only_flag;
       53        53             extern int zbk_actual_stmt_count;
       54        54             extern int zbk_line_num;
       55        55             extern int zbk_static_function_flag;
       56        56             extern char *Srealloc();
       57        57             extern int zbk_debug_rec_match_flag ;
       58        58             struct zbk_sym_tbl *zbk_next_debug_rec;
       59        59             extern int zbk_global_store_flag ;
       60        60             extern void zbk$set_global_debug_vars();
       61        61             extern char zbk_static_func_suffix[]; /* holds user speicifed suffix foe stati
                               c functions. */
       62        62
       63        63
       64        64             union h_s {
       65        65    1              char label_t[65];
       66        66    1              unsigned  int_text[8];}  zbk_h_stuff;
       67        67
       68        68             /* zbk_log_blk_num is the current logical debug blk number. */
       69        69             char zbk_blanks_32[] ={"                                              "};
       70        70             int zbk_curr_line_no;
       71        71             int zbk_local_temps;
       72        72             int zbk_one_val = {1};
       73        73             int zbk_zero_val = {0};
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=3  
       74        74             int zbk_fourteen = {14};
       75        75             int zbk_seventeen = {17};
       76        76             int zbk_twenty_val = {20};
       77        77             int zbk_thirtyfive = {35};
       78        78             struct zbk_constants *last_int_ptr;
       79        79             struct two_halfs zbk_instruc ;
       80        80             int zbk_save_f_count;
       81        81
       82        82             int zbk_addr_type_tbl[] = {0,
       83        83    1              1,  /* static -> static */
       84        84    1              2,  /* auto -> auto */
       85        85    1              1,  /* symref -> static */
       86        86    1              1,  /* symdef -> static */
       87        87    1              0,  /* field -> what ever struct is. */
       88        88    1              3 } ; /* based -> based */
       89        89
       90        90             int zbk_curr_offset_value ; /* contains the offset addr value for last struct
                               head processed. */
       91        91             int zbk_curr_storage_class ;  /* holds the current storage class to be associa
                               ted
       92        92                                     with the last level one item. */
       93        93             int zbk_curr_struct_type ;  /* holds the current gbl data type. */
       94        94             int zbk_curr_struct_reloc_type ; /* hold curreent struct operand type */
       95        95             int zbk_curr_struct_reloc_section ; /* hold curreent struct operand offset. */

       96        96             int zbk_hash_value;
       97        97             int zbk_prog_first_line_no; /* first line no in prog. is saved. */
       98        98             int zbk_last_line_no; /* last line no in the proc being processed. */
       99        99
      100       100             int zbk_minus_one_val = {-1};
      101       101             int zbk_current_set_use;
      102       102             int zbk_std_call = {STD_CALL};
      103       103                   int zbk_stmt_count; /* count of the number of stmt entries in the functi
                               on. */
      104       104
      105       105             int zbk_arg_check[2] = {0,-1};
      106       106             /*    The follwoing table the alignment values for all data types
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=4  
      107       107                   that are associated with the variable debug records in o.u.
      108       108                   generation.
      109       109             */
      110       110             int zbk_align_vals[] = {0, /* null first value */
      111       111    1              1,0,1,0,0,0,0,0,3,3, /* first ten */
      112       112    1              3,3,1,1,1,1,3,1,4,3, /* second ten */
      113       113    1              3,3,0,4,3,3,4,0,2,1, /* third ten */
      114       114    1              3,2,2,3,3,3,1,0,1,1, /* fourth ten */
      115       115    1              1,1,1,1,1,1,1,1,1,1, /* fifth ten */
      116       116    1              1,1,1,1,1,1,1,1,1,1, /* sixth ten */
      117       117    1              1,1,1 } ;
      118       118
      119       119
      120       120
      121       121             #define NEW_ID   1
      122       122             #define OLD_ID   0
      123       123             #define POS_MASK 0377777777777
      124       124
      125       125             struct zbk_labels *lp,*ld,*zbk_last_ld;
      126       126             struct zbk_sym_tbl *last_sp;
      127       127
      128       128
      129       129             /*I*
      130       130                   NAME:zbk$myalloc
      131       131                   PURPOSE: This routine allocates the memory for each of the
      132       132                   data entities that are added to the tables for the label,
      133       133                   constants, and symbols.
      134       134             */
      135       135             short *zbk$myalloc(size) register size; {
      136       136    1         register short *p,*q;
      137       137    1         extern char *Malloc();
      138       138    1        extern int zbk_active_label;
      139       139    1
      140       140    1         p = (short *)Malloc(size);
      141       141    1
      142       142    1         if (p == NULL )
      143       143    1            perror("out of memory");
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=5  
      144       144    1         for(q=p;size>0;size -= sizeof(short))
      145       145    1            *q++ = 0;
      146       146    1         return(p);
      147       147    1        }
      148       148
      149       149
      150       150             /*I*
      151       151                   NAME: zbk$set_use
      152       152                   PURPOSE: This routine sets up the current control section
      153       153                   that will be receiving the code that will be generated
      154       154                   until the next ZUSE operator is encountered.
      155       155             */
      156       156             zbk$set_use(int use_val)  {   /* scan the control section value form the input

      157       157    1                          stream. It should be a single numeric caracter
      158       158    1                          item. */
      159       159    1
      160       160    1              zbk_current_set_use = use_val;
      161       161    1              switch (use_val)  {   /* run on control section type.. */
      162       162    2               case TXT_USE:
      163       163    2                 zbk_curr_con_section = zbk_procsec ;
      164       164    2                 break;
      165       165    2               case CON_USE:
      166       166    2                 zbk_curr_con_section = zbk_datasec ;
      167       167    2                 break;
      168       168    2               case ROM_USE:
      169       169    2                 zbk_curr_con_section = zbk_conssec ;
      170       170    2                 break;
      171       171    2               case BSS_USE:
      172       172    2                 zbk_curr_con_section = zbk_datasec ;
      173       173    2                 break;
      174       174    2              }   /* end of the switch on control section types. */
      175       175    1              return;
      176       176    1              }  /* end of zbk$set_use... */
      177       177
      178       178             /*I*
      179       179                   NAME: zbk$set_addr_pointer
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=6  
      180       180                   PURPOSE: This routine builds a pointer to the literal address
      181       181                   that is referenced in the instruction that is being processed.
      182       182                   A pointer to the id is generated and stored in static
      183       183                   storage. The location where the pointer is stored is returned
      184       184                   to the calling function.
      185       185             */
      186       186             int zbk$set_addr_pointer(char *symbol,int offset)  {
      187       187    1
      188       188    1        int use_section;
      189       189    1        int oper;
      190       190    1        int temp;
      191       191    1        int temp_section;
      192       192    1        struct zbk_sym_tbl *sp;
      193       193    1        sym_tbl_p zbk$scan_and_search_for_id();
      194       194    1
      195       195    1
      196       196    1              zbk_global_store_flag = 1; /* find global name match. */
      197       197    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(symbol,OLD_ID); /
                               * find the id. */
      198       198    1              zbk_global_store_flag = 0; /* reset serach flag.. */
      199       199    1
      200       200    1              sp->ou_set_flag = -1; /* make sure set in this function. */
      201       201    1              zbk_reloc_type = sp->reloc_type;
      202       202    1              zbk_reloc_section = sp->reloc_section;
      203       203    1              offset += (sp->offset << 2) ;
      204       204    1              if (zbk_reloc_type == 0) { /* need to set symref info stuff for
      205       205    2                                        this undefined global symref... */
      206       206    2                if (zbk_static_data_flag != 0 && sp->addr_type == 1) {
      207       207    3                  /* static data type entity yet undefined at this point. */
      208       208    3                  zbk_forward_ref_flag = 1;
      209       209    3                  zbk_reloc_type = FREF_AUTO;
      210       210    3                  zbk_reloc_section = zbk_forward_ref_count;
      211       211    3                  zbk_fwd_p->fwd_tbl[zbk_forward_ref_count++] = (int *) sp;
      212       212    3                  if (zbk_forward_ref_count >= zbk_fwd_tbl_size) {
      213       213    4                     zbk_fwd_p = (zbk_fwd_ref_p) Srealloc(zbk_fwd_p, (zbk_fwd_tbl_size
                               +400)* sizeof(short));
      214       214    4                     zbk_fwd_tbl_size += 400;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=7  
      215       215    4                    }
      216       216    3                } else {
      217       217    3                  sp->addr_type = SYMREF_TYPE;
      218       218    3                  zbk$set_reloc_stuff (sp);
      219       219    3                  zbk_reloc_type = sp->reloc_type;
      220       220    3                  zbk_reloc_section = sp->reloc_section;  }
      221       221    2              }
      222       222    1              else {
      223       223    2                if (zbk_reloc_section == -1) {
      224       224    3                  temp = sp->addr_type;
      225       225    3                  sp->addr_type = 0;
      226       226    3                  zbk$set_reloc_stuff (sp);
      227       227    3                  zbk_reloc_type = sp->reloc_type;
      228       228    3                  zbk_reloc_section = sp->reloc_section;
      229       229    3                  sp->addr_type = temp;   }
      230       230    2              }
      231       231    1
      232       232    1              use_section = zbk_curr_con_section;
      233       233    1              temp = offset << 16; /* shift to upper half of the word, for word addr.
                               */
      234       234    1              XUO$PRGM (&use_section, &zbk_s_s_table[use_section].curr_offset,
      235       235    1                        &temp);
      236       236    1              if (zbk_forward_ref_flag == 0) {  /* have forward ref of static id. */
      237       237    2                XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      238       238    2                   &zbk_reloc_type, &zbk_reloc_section, &zbk_one_val, &zbk_zero_val,
      239       239    2                   &zbk_seventeen, &zbk_zero_val);
      240       240    2              } else {
      241       241    2                zbk_forward_ref_flag = 0;
      242       242    2                temp_section = FREF_TYPE;
      243       243    2                temp = FREF_SNAM;
      244       244    2                XUO$RELOC(&use_section,&zbk_s_s_table[use_section].curr_offset,
      245       245    2                  &temp_section, &zbk_reloc_section, &temp, &zbk_zero_val,&zbk_sevente
                               en,
      246       246    2                  &zbk_zero_val);
      247       247    2                temp_section = FREF_TYPE;
      248       248    2                XUO$RELOC(&use_section, &zbk_s_s_table[use_section].curr_offset,
      249       249    2                  &temp_section, &zbk_reloc_section, &zbk_reloc_type, &zbk_zero_val,
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=8  
      250       250    2                  &zbk_seventeen);  }
      251       251    1              oper = 6;
      252       252    1              XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      253       253    1                   &oper, &xbo_seg_ref_id, &zbk_fourteen, &zbk_twenty_val,
      254       254    1                   &zbk_thirtyfive ,&zbk_zero_val);
      255       255    1              zbk_reloc_type = SECTION_TYPE ;
      256       256    1              zbk_reloc_section = use_section;
      257       257    1              temp = zbk_s_s_table[use_section].curr_offset++;
      258       258    1              return (temp);
      259       259    1              }
      260       260
      261       261             /*I*
      262       262                   NAME: zbk$set_pointer
      263       263                   PURPOSE: This routine builds a pointer to the literal label
      264       264                   that is referenced in the instruction that is being processed.
      265       265                   A pointer to the label is generated and stored in static
      266       266                   storage. The location where the pointer is stored is returned
      267       267                   to the calling function.
      268       268             */
      269       269             int zbk$set_pointer(char *symbol, int offset)  {
      270       270    1
      271       271    1        int temp_section;
      272       272    1        int use_section;
      273       273    1        int oper;
      274       274    1        int temp;
      275       275    1
      276       276    1              temp = zbk$set_stmt_lbl (symbol, REFED);
      277       277    1
      278       278    1              use_section = zbk_curr_con_section;
      279       279    1              temp = temp << 2;
      280       280    1              temp = (temp + offset) << 16; /* shift to upper half of the word, for wo
                               rd addr. */
      281       281    1              XUO$PRGM (&use_section, &zbk_s_s_table[use_section].curr_offset,
      282       282    1                        &temp);
      283       283    1              if (zbk_forward_ref_flag == 0) {  /* non zero - lbl defed already. */
      284       284    2                XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      285       285    2                   &zbk_reloc_type, &zbk_reloc_section, &zbk_one_val, &zbk_zero_val,
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=9  
      286       286    2                   &zbk_seventeen, &zbk_zero_val);  }
      287       287    1              else {  /* have to make relocation reference here... */
      288       288    2                zbk_forward_ref_flag = 0;
      289       289    2                temp_section = FREF_TYPE;
      290       290    2                temp = FREF_SLBL;
      291       291    2                XUO$RELOC(&use_section,&zbk_s_s_table[use_section].curr_offset,
      292       292    2                  &temp_section, &zbk_reloc_section, &temp, &zbk_zero_val,&zbk_sevente
                               en,
      293       293    2                  &zbk_zero_val);
      294       294    2                temp_section = FREF_TYPE;
      295       295    2                XUO$RELOC(&use_section, &zbk_s_s_table[use_section].curr_offset,
      296       296    2                  &temp_section, &zbk_reloc_section, &zbk_reloc_type, &zbk_zero_val,
      297       297    2                  &zbk_seventeen);  }
      298       298    1              oper = 6;
      299       299    1              XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      300       300    1                   &oper, &xbo_seg_ref_id, &zbk_fourteen, &zbk_twenty_val,
      301       301    1                   &zbk_thirtyfive ,&zbk_zero_val);
      302       302    1              zbk_reloc_type = SECTION_TYPE ;
      303       303    1              zbk_reloc_section = use_section;
      304       304    1              temp = zbk_s_s_table[use_section].curr_offset++;
      305       305    1              return (temp);
      306       306    1              }
      307       307
      308       308             /*i*
      309       309                   NAME: zbk$set_ptr_to_id
      310       310                   PURPOSE: This routine generates a pointer to the passed
      311       311                   id or label and sets it inot the current control section.
      312       312                   The current control section should be a data or constant
      313       313                   control section.
      314       314                   This routine uses the functions zbk$set_pointer and zbk$set_addr_pointer

      315       315                   to so the actual building of the relocation directives for
      316       316                   the generation of the pointer in storage.
      317       317
      318       318             */
      319       319             zbk$set_ptr_to_id(char *symbol, int offset) {
      320       320    1
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=10 
      321       321    1
      322       322    1              if (symbol[0] == '@') {   /* have a lbl to generate a pointer to. */
      323       323    2                zbk$set_pointer(symbol,offset);
      324       324    2                return;
      325       325    2               }
      326       326    1              /* have id at this point. */
      327       327    1
      328       328    1              zbk$set_addr_pointer(symbol,offset);
      329       329    1              return;
      330       330    1              }  /* end of the function zbk$set_ptr_to_id. */
      331       331
      332       332             /*i*
      333       333                   name: zbk_set_ptr_to_function
      334       334                   purpose: This routine sets the the passed pointer into a
      335       335                   storage location and generates a pointer to it. It assumes
      336       336                   that the id is a function name.
      337       337             */
      338       338             zbk$set_ptr_to_function (char *symbol, int offset) {
      339       339    1        int use_section;
      340       340    1        int oper;
      341       341    1        int temp;
      342       342    1        struct zbk_sym_tbl *sp;
      343       343    1
      344       344    1              if (symbol[0] == '@') { /* We have a label to generate a pointer to it*/

      345       345    2                 zbk$set_pointer(symbol, offset);
      346       346    2                 return(0);
      347       347    2              }
      348       348    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(symbol,OLD_ID); /
                               * find the id. */
      349       349    1
      350       350    1              sp->ou_set_flag = -1; /* make sure set in this function. */
      351       351    1              zbk_reloc_type = sp->reloc_type;
      352       352    1              zbk_reloc_section = sp->reloc_section;
      353       353    1              if (zbk_reloc_type == 0 || zbk_reloc_type == -1 || zbk_reloc_section ==
                               -1 || zbk_reloc_section == 0) { /* need to set
      354       354    2                  entref info stuff for function id that hasn't been setup. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=11 
      355       355    2                sp->sym_class = FUNCTION_CLASS ;
      356       356    2                sp->addr_type = 0; /* no address typoe associated with func call.*/
      357       357    2                zbk$set_reloc_stuff (sp);
      358       358    2                zbk_reloc_type = sp->reloc_type;
      359       359    2                zbk_reloc_section = sp->reloc_section;
      360       360    2                sp->offset = 0 ;
      361       361    2              }
      362       362    1              offset += sp->offset << 2;
      363       363    1
      364       364    1              use_section = zbk_curr_con_section;
      365       365    1              temp = offset << 16; /* shift to upper half of the word, for word addr.
                               */
      366       366    1              XUO$PRGM (&use_section, &zbk_s_s_table[use_section].curr_offset,
      367       367    1                        &temp);
      368       368    1              XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      369       369    1                   &zbk_reloc_type, &zbk_reloc_section, &zbk_one_val, &zbk_zero_val,
      370       370    1                   &zbk_seventeen, &zbk_zero_val);
      371       371    1              oper = 6;
      372       372    1              XUO$RELOC (&use_section, &zbk_s_s_table[use_section].curr_offset,
      373       373    1                   &oper, &xbo_seg_ref_id, &zbk_fourteen, &zbk_twenty_val,
      374       374    1                   &zbk_thirtyfive ,&zbk_zero_val);
      375       375    1              zbk_reloc_type = SECTION_TYPE ;
      376       376    1              zbk_reloc_section = use_section;
      377       377    1              temp = zbk_s_s_table[use_section].curr_offset++;
      378       378    1              return (temp);
      379       379    1              }
      380       380
      381       381
      382       382             /*i*
      383       383                   name: zbk$set_stmt_lbl
      384       384                   purpose: This routine scan the lbl, hashes it, searches the
      385       385                   label table, and builds label table entries if necessary.
      386       386                   It also generated the relocation code to forwards lbl refs
      387       387                   when the def stmt if found. For refs of already defined
      388       388                   lbls, it returns the relocation values in the appropriate
      389       389                   locations.
      390       390
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=12 
      391       391             */
      392       392             zbk$set_stmt_lbl(char *lname, int kind)    {
"zbk$tables:c.:ZBC3TSI", line 392: (warning) function zbk$set_stmt_lbl called before prototype definition
      393       393    1        int i;
      394       394    1        int length;
      395       395    1        int hash_value;
      396       396    1        labels_p next;
      397       397    1        struct zbk_sym_tbl *sp;
      398       398    1
      399       399    1
      400       400    1
      401       401    1              strcpy(zbk_h_stuff.label_t, zbk_blanks_32);  /* blank out lbl text area
                               */
      402       402    1              zbk_last_ld = NULL ;
      403       403    1              if ( lname[0] != '@' && kind == DEFED) {
      404       404    2                zbk_last_lbl_ptr = NULL;
      405       405    2                zbk_symdef_flag = 1;
      406       406    2                zbk_global_store_flag = 1; /* find global name match. */
      407       407    2                sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(lname,OLD_ID);
      408       408    2                zbk_global_store_flag = 0; /* reset serach flag.. */
      409       409    2                if (sp->addr_type == 0 && sp->debug == NULL) {
      410       410    3                   sp->addr_type = 1; }  /* make it a static entity. */
      411       411    2                /* if symdef or static item, allocate it in current data sec. */
      412       412    2                if (sp->addr_type == SYMDEF_TYPE || sp->addr_type == 1) { zbk$set_relo
                               c_stuff(sp); }
      413       413    2                zbk_symdef_flag = 0;
      414       414    2                return(0);
      415       415    2              }
      416       416    1
      417       417    1              strcpy (zbk_h_stuff.label_t, lname);
      418       418    1              length = strlen(lname);
      419       419    1              /* do the hasing of the lbl at this point. */
      420       420    1
      421       421    1              hash_value = zbk_h_stuff.int_text[0] + zbk_h_stuff.int_text[1];
      422       422    1              hash_value = hash_value * hash_value;
      423       423    1              hash_value = (hash_value & POS_MASK)% 601;  /* may want to make
      424       424    1                                                    this value bigger. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=13 
      425       425    1              lp = (struct zbk_labels *) zbk_label_hash[hash_value];
      426       426    1              if (lp == NULL) {  /* empty hash table entry; build new
      427       427    2                                    hash table entry. */
      428       428    2                zbk$bld_lbl_tbl (hash_value, kind);
      429       429    2                return (0);
      430       430    2               }
      431       431    1              /*  Search for match of current label.. */
      432       432    1
      433       433    1              for (ld = lp; ld != NULL ; ld = next) {
      434       434    2                next = ld->next;
      435       435    2                zbk_last_ld = ld;
      436       436    2                if ((i=strcmp(zbk_h_stuff.label_t,ld->lname)) == 0) {
      437       437    3                    /* have a match here - same lbl already in the tbl. */
      438       438    3                  if (ld->refed != 0 && kind == DEFED) {
      439       439    4                     /* lbl was previously refed, and now it is defed.
      440       440    4                        Need to generate the relocation address into for
      441       441    4                        the previous refs. */
      442       442    4                     ld->def_use = zbk_current_set_use; /* mark curr con section.*/
      443       443    4                     if (zbk_static_data_flag != 0) {
      444       444    5                       ld->lbl_type = GLOBAL_STATIC_LBL; }
      445       445    4                     else {
      446       446    5                       ld->lbl_type = LOCAL_LBL; }
      447       447    4                     ld->defed = 1;
      448       448    4                     ld->offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
      449       449    4                     ld->reloc_section = zbk_curr_con_section;
      450       450    4                     return(0); /* no code is generated for this case. */
      451       451    4                     }
      452       452    3                  else {
      453       453    4                     if (kind == REFED && ld->defed )  {
      454       454    5                         /* have a ref of a previously defined lbl. */
      455       455    5                        zbk_reloc_type = ld->reloc_type;
      456       456    5                        zbk_reloc_section = ld->reloc_section;
      457       457    5                        zbk_reloc_directive = ld->reloc_directive;
      458       458    5
      459       459    5                        return (ld->offset);
      460       460    5                      } else {
      461       461    5                        zbk$bld_ref_thread_entry (ld);
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=14 
      462       462    5                        return (0); } }
      463       463    3                 }  /*  end of if on name match, */
      464       464    2               } /* end of the for loop on matching of lbl texts */
      465       465    1
      466       466    1        /*    At this point we have no match on building label table
      467       467    1              entries.   */
      468       468    1              zbk$bld_lbl_tbl (hash_value, kind);  /* go produce the new lbl tbl entry
                                */
      469       469    1
      470       470    1              return (0);
      471       471    1              }  /* end of zbk$set_stmt_lbl function. */
      472       472
      473       473             /*i*
      474       474                   name: zbk$bld_lbl_tbl
      475       475                   purpose: This routine builds the lbl tbl entry for the
      476       476                   current lbl that is being processed. It receives two
      477       477                   parameters: the hash value, and the kind of lbl position
      478       478                   that is being processed: a ref or a def.
      479       479
      480       480             */
      481       481             zbk$bld_lbl_tbl(hash_value, r_d_kind)
      482       482             int hash_value;
      483       483             int r_d_kind;    {  /* start of the program. */
      484       484    1        labels_p lbl;
      485       485    1
      486       486    1              ld = (struct zbk_labels *) zbk$myalloc (sizeof(struct zbk_labels));
      487       487    1
      488       488    1              if (zbk_lbl_tbl_ptr == NULL ) {  /* put onto lbl tbl thread-all lbls. */

      489       489    2                zbk_first_lbl_tbl_ptr = ld;
      490       490    2                zbk_lbl_tbl_ptr = ld;
      491       491    2                ld->next_lbl_entry = NULL; }
      492       492    1              else {
      493       493    2                lbl = zbk_lbl_tbl_ptr;
      494       494    2                lbl->next_lbl_entry = ld;
      495       495    2                ld->next_lbl_entry = NULL;
      496       496    2                zbk_lbl_tbl_ptr = ld;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=15 
      497       497    2               }
      498       498    1              if (lp == NULL) {
      499       499    2                 zbk_label_hash[hash_value] = (int *)ld;
      500       500    2                 ld->previous = NULL;
      501       501    2                }
      502       502    1              else {
      503       503    2                zbk_last_ld->next = ld;
      504       504    2                ld->previous = zbk_last_ld;
      505       505    2                }
      506       506    1              ld->next = NULL;
      507       507    1              ld->hash_value = hash_value;
      508       508    1              ld->ref_thread = NULL;
      509       509    1              ld->offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
      510       510    1              ld->reloc_section = zbk_curr_con_section;
      511       511    1              ld->reloc_type = SECTION_TYPE;
      512       512    1              ld->reloc_directive = UHALF_WORD ;
      513       513    1              strcpy (ld->lname, zbk_h_stuff.label_t);
      514       514    1
      515       515    1              switch (r_d_kind) {  /*  set the ref or def flag depending on
      516       516    2                                       which one we are processign.  */
      517       517    2               case DEFED:
      518       518    2                 if (zbk_static_data_flag != 0 ) {
      519       519    3                   ld->lbl_type = GLOBAL_STATIC_LBL;
      520       520    3                   ld->def_use = zbk_current_set_use;
      521       521    3                   }
      522       522    2                 else {
      523       523    3                   ld->lbl_type = LOCAL_LBL; }
      524       524    2                 ld->defed = 1;
      525       525    2                 break;
      526       526    2               case REFED:
      527       527    2                 ld->refed = 1;
      528       528    2                 break;
      529       529    2               }  /* end of the do case on def or ref.. */
      530       530    1
      531       531    1
      532       532    1              if (r_d_kind == DEFED) {
      533       533    2                ld->ref_thread = NULL;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=16 
      534       534    2                zbk_last_lbl_ptr = ld;
      535       535    2                return ;  }
      536       536    1
      537       537    1              /* The lbl tbl entry is now built. However, we have a ref
      538       538    1                 entry and now we must add a ref lbl tbl entry so that
      539       539    1                 we can eventually reset the actual address into the
      540       540    1                 instruction that is referencing the label.
      541       541    1              */
      542       542    1
      543       543    1              zbk$bld_ref_thread_entry (ld);
      544       544    1
      545       545    1              return ;
      546       546    1              }   /* end of the bld_lbl_tlb function. */
      547       547
      548       548             /*i*
      549       549                   name: zbk$bld_ref_thread_entry
      550       550                   purpose: This routine is the one that sets up the lbl ref
      551       551                   tbl entry. It saves the information about where the lbl ref
      552       552                   occured, so that when the lblb def in encountered we cam set
      553       553                   the def address information into the ref control section
      554       554                   location.
      555       555             */
      556       556             zbk$bld_ref_thread_entry (lp)  struct zbk_labels *lp ;  {
      557       557    1        struct zbk_forward_refs *fp ,*next_fp, *fp1, *last_fp;
      558       558    1
      559       559    1              zbk_forward_ref_flag = -1;
      560       560    1              zbk_reloc_type = FREF_LBL ;
      561       561    1              zbk_reloc_directive = UHALF_WORD ;
      562       562    1              /*  build entry in the frwd ref table for later processing. */
      563       563    1              zbk_fwd_p->fwd_tbl[zbk_forward_ref_count] = (int *)lp;
      564       564    1              zbk_reloc_section = zbk_forward_ref_count ;
      565       565    1
      566       566    1              zbk_forward_ref_count++;  /* make sure never have zero offset.. */
      567       567    1              if (zbk_forward_ref_count >= zbk_fwd_tbl_size) {
      568       568    2                 zbk_fwd_p = (zbk_fwd_ref_p) Srealloc(zbk_fwd_p, (zbk_fwd_tbl_size+400
                               )* sizeof(short));
      569       569    2                 zbk_fwd_tbl_size += 400;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=17 
      570       570    2                }
      571       571    1              fp = (struct zbk_forward_refs *) zbk$myalloc(sizeof(struct zbk_forward_r
                               efs));
      572       572    1
      573       573    1              if (lp->ref_thread == NULL) {
      574       574    2                lp->ref_thread =  fp;
      575       575    2              } else {
      576       576    2                for (fp1=lp->ref_thread; fp1 != NULL; fp1 = next_fp) {
      577       577    3                  last_fp = fp1;
      578       578    3                  next_fp = fp1->next; }
      579       579    2                last_fp->next = fp; }
      580       580    1
      581       581    1              fp->next = NULL;
      582       582    1              fp->offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
      583       583    1              fp->reloc_directive = UHALF_WORD;
      584       584    1              fp->reloc_type = SECTION_TYPE;
      585       585    1              fp->reloc_section = zbk_curr_con_section ;
      586       586    1
      587       587    1              return;
      588       588    1              }  /* end of zbk$bld_ref_thread_entry function. */
      589       589
      590       590
      591       591
      592       592             /*i*
      593       593                   name: zbk$set_var_info
      594       594                   purpose: This routine processes the variable record for the
      595       595                   instruction code file. It cntains all the info needed to
      596       596                   generate debug record information for the variable name in
      597       597                   the object unit.
      598       598             */
      599       599             zbk$set_var_info(char *sname,char *struc,long cst_vec[],int cst_len)  {  /* pr
                               ocessign the PS_VAR_OP record. */
      600       600    1        int i  ;
      601       601    1        int old_level_no, old_data_type, old_addr_type, match;
      602       602    1        int old_stmt_no, old_line_no ,old_offset ;
      603       603    1        int old_starting_bit, old_alignment, old_ele_size, old_size_bytes;
      604       604    1        int count;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=18 
      605       605    1        int array_size;
      606       606    1        int array_rank;
      607       607    1        struct zbk_sym_tbl *sp, *sp1, *sp2, *last_sp, *next_sp;
      608       608    1        struct zbk_sym_debug_tbl *dp, *dp1;
      609       609    1        int indirect_ptr_count;
      610       610    1        sym_tbl_p zbk$bld_sym_tbl_entry();
      611       611    1        sym_tbl_p zbk$check_match();
      612       612    1
      613       613    1
      614       614    1              /*  start of the recrd processing..   */
      615       615    1              match = 0;
      616       616    1              if (zbk_debug_rec_match_flag != 0) { /* processing duplicate structures.
                                */
      617       617    2                sp = zbk$check_match(sname);  /* make sure new = old structure entity.
                                */
      618       618    2                dp = sp->debug; /* ptr to the debug stuff for the id. */
      619       619    2              } else {  /* normal id processing follows. */
      620       620    2                sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,NEW_ID);
                                /* get sym tbl entity */
      621       621    2                if (sp->debug == NULL) {  /* new sym tbl entry - no deug info. */
      622       622    3                  dp = (struct zbk_sym_debug_tbl *) zbk$myalloc(sizeof(struct zbk_sym_
                               debug_tbl));
      623       623    3                  sp->debug =  dp;
      624       624    3                  match = 0;
      625       625    3                  }
      626       626    2                else {
      627       627    3                  dp = sp->debug;
      628       628    3                  old_level_no = dp->level_no;
      629       629    3                  old_line_no = dp->line_no;
      630       630    3                  old_stmt_no = dp->stmt_no;
      631       631    3                  old_data_type = dp->data_type;
      632       632    3                  old_addr_type = dp->addr_type;
      633       633    3                  old_offset = sp->offset;
      634       634    3                  old_alignment = dp->alignment;
      635       635    3                  old_starting_bit = dp->starting_bit;
      636       636    3                  old_size_bytes = dp->size_bytes;
      637       637    3                  old_ele_size = dp->ele_size;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=19 
      638       638    3                  match = 1; }
      639       639    2              }
      640       640    1              sp->ou_set_flag = -1;
      641       641    1
      642       642    1              if ( struc != NULL ) {  /* have sructure name. */
      643       643    2                strcpy (sp->struct_name,struc);
      644       644    2               /* scan the debug info and set it into the debug record of
      645       645    2                 the symbol table entry. */
      646       646    2               }
      647       647    1              dp->line_no  = cst_vec[0] ; /* get the line no. */
      648       648    1              dp->stmt_no  = cst_vec[1] ; /* get the stmt no. */
      649       649    1              dp->level_no  = cst_vec[2] +1; /* get the level no. */
      650       650    1              dp->addr_type = cst_vec[3] ; /* get the addr type */
      651       651    1              if (dp->addr_type==SYMDEF_TYPE && zbk_static_data_flag == 0) {
      652       652    2                dp->addr_type = SYMREF_TYPE; }
      653       653    1
      654       654    1              sp->addr_type = dp->addr_type; /* save the addr type */
      655       655    1              dp->data_type = cst_vec[4] ; /* get the data type */
      656       656    1              dp->size_bytes = cst_vec[5] ; /* get the sizein bytes. */
      657       657    1              dp->ele_size = cst_vec[6] ; /* get the element size. */
      658       658    1              dp->addr_byte = cst_vec[7] ; /* get the byte address. */
      659       659    1              sp->offset = dp->addr_byte ;
      660       660    1              dp->starting_bit = cst_vec[8] ; /* get the starting bit. */
      661       661    1              dp->alignment = cst_vec[9] ; /* get alignment of the id. */
      662       662    1
      663       663    1              /* check if this case is really a replacement of a previous
      664       664    1                 structure... */
      665       665    1              if (zbk_static_data_flag != 0 && match != 0 &&
      666       666    1                  old_level_no == 1 && old_level_no == dp->level_no &&
      667       667    1                  old_addr_type == SYMREF_TYPE && old_data_type == STRUCTURE_DATA_TYPE
                                &&
      668       668    1                  old_data_type == dp->data_type && dp->addr_type == 4) {
      669       669    2                 zbk_debug_rec_match_flag = 1;
      670       670    2                 zbk_next_debug_rec = sp->next_sym_entry; }
      671       671    1              else {
      672       672    2                if (zbk_static_data_flag != 0 && match != 0 &&
      673       673    2                   old_level_no == 1 && ((old_addr_type == SYMREF_TYPE &&
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=20 
      674       674    2                   old_data_type == STRUCTURE_DATA_TYPE) || old_addr_type == 4
      675       675    2                   || old_addr_type == STATIC_TYPE) &&
      676       676    2                   dp->level_no != 1 ) {  /* make new table entry for the
      677       677    3                                            current debug record being processed. */
      678       678    3        new_entry: ;
      679       679    3                   sp2 = (struct zbk_sym_tbl *) zbk_symbol_hash[zbk_hash_value];
      680       680    3                   if (sp2 == NULL) {
      681       681    4                     last_sp = NULL; }
      682       682    3                   else {
      683       683    4                     for (sp1 = sp2; sp1 != NULL; sp1 = next_sp) {
      684       684    5                       next_sp = sp1->next;
      685       685    5                       last_sp = sp1; }
      686       686    4                   }
      687       687    3                   sp1 = (struct zbk_sym_tbl *) zbk$bld_sym_tbl_entry(sp2, last_sp, zb
                               k_hash_value);
      688       688    3                   sp1->next = NULL;
      689       689    3                   sp1->debug = (struct zbk_sym_debug_tbl *) zbk$myalloc(sizeof(struct
                                zbk_sym_debug_tbl));
      690       690    3                   dp1 = sp1->debug;
      691       691    3                   dp1->line_no = dp->line_no;
      692       692    3                   dp1->stmt_no = dp->stmt_no;
      693       693    3                   dp1->level_no = dp->level_no;
      694       694    3                   dp1->addr_type = dp->addr_type;
      695       695    3                   dp1->data_type = dp->data_type;
      696       696    3                   dp1->size_bytes = dp->size_bytes;
      697       697    3                   dp1->ele_size = dp->ele_size;
      698       698    3                   dp1->addr_byte = dp->addr_byte;
      699       699    3                   dp1->starting_bit = dp->starting_bit;
      700       700    3                   dp1->alignment = dp->alignment;
      701       701    3                   dp->level_no = old_level_no;
      702       702    3                   dp->addr_type = old_addr_type ;
      703       703    3                   dp->data_type = old_data_type ;
      704       704    3                   sp->addr_type = old_addr_type;
      705       705    3                   sp->offset = old_offset;
      706       706    3                   dp->line_no = old_line_no ;
      707       707    3                   dp->stmt_no = old_stmt_no ;
      708       708    3                   dp->alignment = old_alignment;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=21 
      709       709    3                   dp->starting_bit = old_starting_bit;
      710       710    3                   dp->size_bytes = old_size_bytes;
      711       711    3                   dp->ele_size = old_ele_size;
      712       712    3
      713       713    3                   sp = sp1;  /* set up for new tl entry. */
      714       714    3                   dp = dp1;  /* set up for new tl entry. */
      715       715    3                }
      716       716    2                else {
      717       717    3                   if (zbk_static_data_flag != 0 && match != 0 && old_level_no != 1
      718       718    3                      && dp->level_no == 1) {
      719       719    4                     goto new_entry; }
      720       720    3                }
      721       721    2              } /* end of the test on special id processing.... */
      722       722    1
      723       723    1              dp->array_rank = 0;
      724       724    1              dp->array_rec_count = 0;
      725       725    1              count = cst_vec[10] ; /* get number of items following. */
      726       726    1              if (count != 0) {
      727       727    2                indirect_ptr_count = cst_vec[11] ; /* chk for ptr type. */
      728       728    2                count--;
      729       729    2                if (indirect_ptr_count != 0) {
      730       730    3                  dp->size_bytes = 4;
      731       731    3                  dp->ele_size = 4;
      732       732    3                  dp->data_type = POINTER_DATA_TYPE; }
      733       733    2
      734       734    2                while (count >0 ) {
      735       735    3                  array_rank = cst_vec[12] ; /* get array rank - # of dims. */
      736       736    3                  count--;  /* decrement count for rand operand.  */
      737       737    3                  dp->array_rank = array_rank;
      738       738    3                  dp->array_rec_count = array_rank;
      739       739    3                  count -= array_rank ;
      740       740    3                  if (array_rank != 0) {
      741       741    4                    i = 0;
      742       742    4                    while (array_rank > 0) {
      743       743    5                      dp->array_info[i] = cst_vec[13+i];
      744       744    5                      if (dp->array_info[i] == -1) {
      745       745    6                        if (dp->data_type == 2 || dp->data_type == 4) {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=22 
      746       746    7                           dp->array_info[i] = 8; }
      747       747    6                        else {
      748       748    7                           dp->array_info[i] = 4; }  }
      749       749    5                      if (i == 0) {
      750       750    6                        array_size = dp->array_info[i]; }
      751       751    5                      i++;
      752       752    5                      array_rank--; }
      753       753    4                    dp->array_size = array_size;
      754       754    4                   }
      755       755    3                    if (count > 0) {
      756       756    4                       count--;
      757       757    4                  indirect_ptr_count = cst_vec[cst_len - 1] ; /* pointer trait check.
                               */
      758       758    4                  if (indirect_ptr_count != 0) {
      759       759    5                    dp->size_bytes = 4;
      760       760    5                    dp->ele_size = 4;
      761       761    5                    dp->data_type = POINTER_DATA_TYPE; }
      762       762    4                    }   /* if terminus. */
      763       763    3                  }   /* while loop on count terminus. */
      764       764    2              }  /* end of array  arg processing for the variable id. */
      765       765    1
      766       766    1
      767       767    1              /* finish generating the recolation stuff and o.u.
      768       768    1                 record debug stuff....
      769       769    1              */
      770       770    1              /* if static storage item, dont allocate it. */
      771       771    1              if (sp->addr_type != 1 || (zbk_static_data_flag == 0 && dp->addr_byte !=
                                0)) {
      772       772    2                zbk$set_reloc_stuff (sp);  }
      773       773    1              zbk$build_debug (sp);
      774       774    1
      775       775    1              return;
      776       776    1              }  /* end of zbk$set_var_info function. */
      777       777
      778       778             /*I*
      779       779                   NAME: zbk$scan_and_search_for_id
      780       780                   PURPOSE: This routine check if symtbl entry already exists for
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=23 
      781       781                   the id, and if so, it returns pointer to the sym tbl entry.
      782       782                   Otherwise, a new symbol table entry is gnereated for the
      783       783                   new id.
      784       784             */
      785       785             sym_tbl_p  zbk$scan_and_search_for_id(char *sname,int new_old)  { /* scan the
"zbk$tables:c.:ZBC3TSI", line 785: (warning) function zbk$scan_and_search_for_id called before prototype defi
nition
                               symbol table for id. */
      786       786    1        int i; int length;
      787       787    1        struct zbk_sym_tbl *sp, *sp1, *sp2, *next, *last_sp;
      788       788    1        struct zbk_sym_debug_tbl *dp;
      789       789    1        sym_tbl_p  zbk$bld_sym_tbl_entry();
      790       790    1
      791       791    1
      792       792    1              /* program starts here..  */
      793       793    1              strcpy(zbk_h_stuff.label_t, zbk_blanks_32);  /* blank out symbol text ar
                               ea */
      794       794    1              last_sp = NULL ;
      795       795    1
      796       796    1              length = strlen(sname);
      797       797    1              strcpy(zbk_h_stuff.label_t, sname);
      798       798    1              /* do the hashing of the symbol at this point. */
      799       799    1              zbk_hash_value = zbk_h_stuff.int_text[0] + zbk_h_stuff.int_text[1] + zbk
                               _h_stuff.int_text[2] ;
      800       800    1              zbk_hash_value = zbk_hash_value * zbk_hash_value;
      801       801    1              zbk_hash_value = (zbk_hash_value & POS_MASK)% 601;  /* may want to make
      802       802    1                                                    this value bigger. */
      803       803    1              sp1 = (struct zbk_sym_tbl *) zbk_symbol_hash[zbk_hash_value];
      804       804    1
      805       805    1              if (sp1 == NULL) { /* build new symbol table entry.*/
      806       806    2                sp = (struct zbk_sym_tbl *) zbk$bld_sym_tbl_entry(sp1,last_sp,zbk_hash
                               _value);
      807       807    2                sp->debug = NULL ;
      808       808    2                sp->next = NULL ;
      809       809    2                return (sp);
      810       810    2                }
      811       811    1              /*  search for match.. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=24 
      812       812    1              for (sp2 = sp1; sp2 != NULL; sp2 = next) {
      813       813    2                next =  sp2->next;
      814       814    2                last_sp = sp2;
      815       815    2                if (( i=strcmp (zbk_h_stuff.label_t, sp2->name)) == 0 && (new_old == O
                               LD_ID || zbk_static_data_flag != 0)) {
      816       816    3                   if (zbk_global_store_flag != 0 && sp2->debug != NULL) {
      817       817    4                     if (sp2->debug->level_no > 1) {goto try_next; } }
      818       818    3                   if (zbk_static_data_flag != 0 && sp2->debug != NULL) {
      819       819    4                     dp = sp2->debug;
      820       820    4                     if ((dp->level_no > 1 || dp->data_type == STRUCTURE_DATA_TYPE) &&

      821       821    4                        zbk_symdef_flag == 0 ) {
      822       822    5                       if (dp->level_no == 1 && (dp->addr_type == SYMREF_TYPE ||
      823       823    5                           dp->addr_type == 1 || dp->addr_type == 4)) /* static or sym
                               def. */
      824       824    5                          { goto  return_ptr; }
      825       825    5                       for (sp= sp2; sp != NULL;sp = next) {
      826       826    6                         next = sp->next ;
      827       827    6                         last_sp = sp; }
      828       828    5                       break; }
      829       829    4                   }
      830       830    3                  /* have match on text names at this point. */
      831       831    3                  if (zbk_ref_name_flag != 0 && sp2->sym_class != FUNCTION_CLASS) {
      832       832    4                     goto try_next; }
      833       833    3        return_ptr: ;
      834       834    3                  if (sp2->ou_set_flag == 0) { /* first use in this program. */
      835       835    4                    zbk$set_reloc_stuff(sp2);
      836       836    4                  }
      837       837    3                  return (sp2);
      838       838    3                   }  /* enf of if test on name match. */
      839       839    2        try_next: ;
      840       840    2                }  /* end of the loop on symbol names. */
      841       841    1
      842       842    1              /* at this point, no match was found so build new
      843       843    1                 new symbol table entry.  */
      844       844    1              sp = (struct zbk_sym_tbl *) zbk$bld_sym_tbl_entry (sp1,last_sp,zbk_hash_
                               value);
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=25 
      845       845    1
      846       846    1              sp->debug = NULL ;
      847       847    1              sp->next = NULL ;
      848       848    1              return (sp);
      849       849    1              }   /* end of the scan_and_serch_for_id function.. */
      850       850
      851       851             /*i*
      852       852                   name: zbk$bld_sym_tbl_entry
      853       853                   purpose: This routine builds the symbol table entry for
      854       854                   the current id taht is being processed..
      855       855             */
      856       856             sym_tbl_p  zbk$bld_sym_tbl_entry(sp,last_sp,hash_value)  struct zbk_sym_tbl *s
                               p,*last_sp;
      857       857             int hash_value;   {  /* routine follows.....  */
      858       858    1        struct zbk_sym_tbl *ssp , *sym ;
      859       859    1
      860       860    1              ssp = (struct zbk_sym_tbl *) zbk$myalloc(sizeof(struct zbk_sym_tbl));
      861       861    1              if (zbk_sym_tbl_ptr == NULL) { /*building sym tbl thread entry. */
      862       862    2                zbk_first_sym_tbl_ptr =ssp;
      863       863    2                zbk_sym_tbl_ptr =ssp;
      864       864    2                ssp->next_sym_entry = NULL; }
      865       865    1              else {
      866       866    2                sym = zbk_sym_tbl_ptr;
      867       867    2                ssp->next_sym_entry = NULL;
      868       868    2                sym->next_sym_entry = ssp;
      869       869    2                zbk_sym_tbl_ptr = ssp;
      870       870    2              }
      871       871    1              if (sp == NULL) {
      872       872    2                ssp->previous = NULL;
      873       873    2                zbk_symbol_hash[hash_value] = (int *)ssp; }
      874       874    1              else {
      875       875    2                ssp->previous = last_sp;
      876       876    2                last_sp->next = ssp ; }
      877       877    1
      878       878    1              strcpy (ssp->name, zbk_h_stuff.label_t);
      879       879    1              ssp->next = NULL;
      880       880    1              ssp->hash_value = hash_value;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=26 
      881       881    1              return (ssp);
      882       882    1              }   /* end of the zbk$bld_sym_tbl_entry function. */
      883       883
      884       884             /*i*
      885       885                   name: zbk$check_match
      886       886                   purpose: This routine is used to make sure that the names
      887       887                   of the current struct item to e replace is the same as the
      888       888                   current debug item off of the input stream...
      889       889             */
      890       890             sym_tbl_p zbk$check_match(char *sname) {
"zbk$tables:c.:ZBC3TSI", line 890: (warning) function zbk$check_match called before prototype definition
      891       891    1        int i;
      892       892    1        char new_name[32];
      893       893    1        struct zbk_sym_tbl *sp;
      894       894    1
      895       895    1              sp = zbk_next_debug_rec ;
      896       896    1              strcpy (new_name, sname);
      897       897    1              if ((i = strcmp(new_name, zbk_next_debug_rec->name)) != 0) {
      898       898    2                 printf ("mismatch on debug rec names %s and %s did not match. \n ",
      899       899    2                    new_name, zbk_next_debug_rec->name);
      900       900    2              }
      901       901    1
      902       902    1              zbk_next_debug_rec = zbk_next_debug_rec->next_sym_entry;
      903       903    1              if (zbk_next_debug_rec == NULL) {
      904       904    2                zbk_debug_rec_match_flag = 0;
      905       905    2              }
      906       906    1              if (zbk_next_debug_rec->debug->level_no <= 1) {
      907       907    2                zbk_debug_rec_match_flag = 0;
      908       908    2              }
      909       909    1
      910       910    1              return (sp);
      911       911    1
      912       912    1              } /* end of the function zbk$check_match.. */
      913       913
      914       914
      915       915             /*i*
      916       916                   name: zbk$set_reloc_stuff
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=27 
      917       917                   purpose: This routine does the allocation for all static
      918       918                   and sym defed items. It also sets the zbk_reloc_type, zbk_reloc_section
      919       919                   fields in the symbol table entry for all other types of is
      920       920                   that are being processed.
      921       921                   Offset field is also set (if applicable).
      922       922
      923       923             */
      924       924             zbk$set_reloc_stuff(sp)  struct zbk_sym_tbl *sp;  {
      925       925    1        struct zbk_sym_debug_tbl *dp;
      926       926    1        int name_offset;
      927       927    1        int symref_num;
      928       928    1        int eref_num;
      929       929    1        char *ret_c;
      930       930    1        int j;
      931       931    1        char tmp1[128];
      932       932    1
      933       933    1              if ( zbk_ref_name_flag != 0 ) { return; }
      934       934    1                  /* IF ENTREF item skip this stuff.. */
      935       935    1              switch (sp->addr_type) {  /* switch on addr type.. */
      936       936    2               case STATIC_TYPE:
      937       937    2                if (sp->storage_class == GLOBAL_STATIC_STORAGE) return;
      938       938    2                if (zbk_static_data_flag == 0) {
      939       939    3                  if (sp->debug != NULL ) {
      940       940    4                    dp = sp->debug ;
      941       941    4                    if (dp->level_no ==1 && dp->addr_byte != 0 ) {
      942       942    5                      zbk$get_label_addr (sp, dp); }
      943       943    4                    else {
      944       944    5                      if (sp->reloc_type == ENTREF_TYPE) return;
      945       945    5                      zbk$set_address(sp);
      946       946    5                      sp->reloc_type = SECTION_TYPE ;
      947       947    5                      sp->reloc_section = zbk_curr_con_section   ;  }
      948       948    4                  } else {
      949       949    4                    if (sp->sym_class  == FUNCTION_CLASS) return;
      950       950    4                    zbk$set_address(sp);
      951       951    4                    sp->reloc_type = SECTION_TYPE ;
      952       952    4                    sp->reloc_section = zbk_curr_con_section   ;  }
      953       953    3                  sp->storage_class = LOCAL_STATIC_STORAGE; }
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=28 
      954       954    2                else {
      955       955    3                  zbk$set_address(sp);
      956       956    3                  sp->reloc_type = SECTION_TYPE ;
      957       957    3                  sp->reloc_section = zbk_curr_con_section   ;
      958       958    3                  sp->def_use = zbk_current_set_use ;
      959       959    3                  sp->storage_class = GLOBAL_STATIC_STORAGE; }
      960       960    2
      961       961    2                break;
      962       962    2               case AUTO_TYPE:
      963       963    2                sp->reloc_section = -1;
      964       964    2                sp->reloc_type = -1;
      965       965    2                sp->storage_class = AUTO_STORAGE;
      966       966    2
      967       967    2                break;
      968       968    2               case SYMDEF_TYPE:
      969       969    2                if (zbk_symdef_flag == 0) { break; }
      970       970    2                sp->reloc_type = SECTION_TYPE;
      971       971    2                sp->reloc_section = zbk_curr_con_section;
      972       972    2                sp->offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
      973       973    2                zbk$bld_symdef (sp);
      974       974    2                sp->storage_class = GLOBAL_STORAGE;
      975       975    2
      976       976    2                break;
      977       977    2               case SYMREF_TYPE:
      978       978    2                sp->reloc_type = SYMREF_TYPE;
      979       979    2              /*  add name to the ref name talbe, and then add entry to the
      980       980    2                  symref table entry.
      981       981    2              */
      982       982    2
      983       983    2                if ((ret_c = strchr(sp->name, '#')) != (char *) 0) { return; }
      984       984    2                pl6str (sp->name) ;
      985       985    2                XUO$RNAME (zbk_buffer, &name_offset);
      986       986    2                XUO$SREF (&name_offset, &zbk_zero_val, &symref_num, &zbk_zero_val);
      987       987    2
      988       988    2                sp->reloc_section = symref_num ;
      989       989    2                sp->storage_class = GLOBAL_STORAGE;
      990       990    2
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=29 
      991       991    2                break ;
      992       992    2               default:
      993       993    2                if (sp->sym_class != FUNCTION_CLASS) break;
      994       994    2                j = zbk$static_func_chk (sp);
      995       995    2                if (j != 0) {
      996       996    3                  strcpy(tmp1, sp->name);
      997       997    3                  strcat(tmp1, "#");
      998       998    3                  if (zbk_static_data_flag != 0) {
      999       999    4                     if (strcmp(zbk_static_func_suffix, "    ") != 0) {
     1000      1000    5                        strcat(tmp1, zbk_static_func_suffix); }
     1001      1001    4                     else {
     1002      1002    5                        strcat(tmp1, zbk_static_name); } }
     1003      1003    3                  else {
     1004      1004    4                     strcat(tmp1, zbk_static_name);  }
     1005      1005    3                  pl6str(tmp1);
     1006      1006    3                } else {
     1007      1007    3                  pl6str(sp->name); }
     1008      1008    2                XUO$RNAME (zbk_buffer, &name_offset);
     1009      1009    2                XUO$EREF (&name_offset, &zbk_zero_val, &zbk_minus_one_val, &zbk_zero_v
                               al,
     1010      1010    2                   &zbk_std_call, &zbk_zero_val, &eref_num);
     1011      1011    2
     1012      1012    2                sp->reloc_section = eref_num ;
     1013      1013    2                sp->reloc_type = ENTREF_TYPE;
     1014      1014    2                sp->offset = 0;
     1015      1015    2
     1016      1016    2                break ;
     1017      1017    2               case FIELD_TYPE:
     1018      1018    2
     1019      1019    2                break;
     1020      1020    2               case BASED_TYPE:
     1021      1021    2
     1022      1022    2                break;
     1023      1023    2              }  /* end of the switch on addr type....  */
     1024      1024    1
     1025      1025    1              return;
     1026      1026    1              }   /* end  of the function zbk$set_reloc_stuff.. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=30 
     1027      1027
     1028      1028
     1029      1029             /*i*
     1030      1030                   name: zbk$get_label_addr
     1031      1031                   purpose: This routine generates a label address for the local
     1032      1032                   static addresses that reference a global static entity.
     1033      1033
     1034      1034             */
     1035      1035             zbk$get_label_addr (sp, dp)
     1036      1036             struct zbk_sym_tbl *sp;
     1037      1037             struct zbk_sym_debug_tbl *dp; {
     1038      1038    1        struct zbk_labels *next;
     1039      1039    1        int hash_value, i, k ,ii, kk ;
     1040      1040    1        int zbk$power_of_kk();
     1041      1041    1        char j;
     1042      1042    1              strcpy(zbk_h_stuff.label_t, zbk_blanks_32);
     1043      1043    1
     1044      1044    1              strcpy(zbk_h_stuff.label_t, "@C");
     1045      1045    1              k = 2;
     1046      1046    1              i = dp->addr_byte ;
     1047      1047    1              kk = 0;
     1048      1048    1              for (ii=i; ii>0 ; ii/= 10) {
     1049      1049    2                kk++; }
     1050      1050    1              while ( i >= 10) {
     1051      1051    2                j = i/zbk$power_of_kk(kk)  | 060 ;
     1052      1052    2                zbk_h_stuff.label_t[k] = j;
     1053      1053    2                k++;
     1054      1054    2                i = i%(10*(kk-1));
     1055      1055    2                kk--;
     1056      1056    2              }
     1057      1057    1              j = i | 060;
     1058      1058    1              zbk_h_stuff.label_t[k++] = j;
     1059      1059    1              zbk_h_stuff.label_t[k] = '\0';
     1060      1060    1              hash_value = zbk_h_stuff.int_text[0] + zbk_h_stuff.int_text[1];
     1061      1061    1              hash_value = hash_value * hash_value;
     1062      1062    1              hash_value = (hash_value & POS_MASK)% 601;  /* may want to make
     1063      1063    1                                                    this value bigger. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=31 
     1064      1064    1              lp = (struct zbk_labels *) zbk_label_hash[hash_value];
     1065      1065    1
     1066      1066    1              if (lp == NULL) {
     1067      1067    2                /* have error condition if we et to this point... */
     1068      1068    2                printf ("We have reference to nonexistent static data entity. %s, %d \
                               n ", zbk_h_stuff.label_t, zbk_line_num);
     1069      1069    2                return;  }
     1070      1070    1
     1071      1071    1              for (ld = lp; ld != NULL ; ld = next) {
     1072      1072    2                next = ld->next;
     1073      1073    2                zbk_last_ld = ld;
     1074      1074    2                if ((i=strcmp(zbk_h_stuff.label_t,ld->lname)) == 0) {
     1075      1075    3                    /* have a match here - same lbl already in the tbl. */
     1076      1076    3                  sp->reloc_type = ld->reloc_type;
     1077      1077    3                  sp->reloc_section = ld->reloc_section;
     1078      1078    3                  sp->offset = lp->offset*4; /* make byte values. */
     1079      1079    3                  dp->addr_byte = lp->offset*4; /* make bytes value offsets. */
     1080      1080    3                  return;
     1081      1081    3                }   /* end of if test on string match. */
     1082      1082    2              } /* end of for loop on string search. */
     1083      1083    1
     1084      1084    1              /* if we et here it is an error. */
     1085      1085    1              printf ("We have reference to nonexistent static data entity. %s %d \n",
                                zbk_h_stuff.label_t , zbk_line_num );
     1086      1086    1              return;
     1087      1087    1        }     /* end of the function zbk$get_label_addr.   */
     1088      1088
     1089      1089             /*i*
     1090      1090                   name: zbk$power_of_kk
     1091      1091                   purpose: This routine is the one to calculate the power
     1092      1092                   of the of 10 to be user in decoding the binary value into
     1093      1093                   a deciaml number.
     1094      1094             */
     1095      1095             int zbk$power_of_kk(kk) int kk; {
     1096      1096    1        int i,k;
     1097      1097    1
     1098      1098    1              k = 1;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=32 
     1099      1099    1              for (i = kk-1; i > 0; i-- ) {
     1100      1100    2                k = k * 10 ;
     1101      1101    2              }
     1102      1102    1              return (k);
     1103      1103    1        }
     1104      1104
     1105      1105
     1106      1106             /*i*
     1107      1107                   name: zbk$set_address
     1108      1108                   purpose: This routine allocates storage area in the data
     1109      1109                   section for the passed ids. This is for static and symdef
     1110      1110                   data types.
     1111      1111             */
     1112      1112             zbk$set_address(sp)  struct zbk_sym_tbl *sp;    {
     1113      1113    1        int i;
     1114      1114    1        struct zbk_sym_debug_tbl *dt;
     1115      1115    1
     1116      1116    1              /*  procedure follows......   */
     1117      1117    1              sp->offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
     1118      1118    1              /* dont increment the current location counter for
     1119      1119    1                 allocation of the static data entity. Fill stuff
     1120      1120    1                 will take care of it.... */
     1121      1121    1
     1122      1122    1              if (zbk_static_data_flag != 0 || sp->debug == NULL)
     1123      1123    1                return;
     1124      1124    1
     1125      1125    1              dt =(struct zbk_sym_debug_tbl *) sp->debug;
     1126      1126    1              dt->addr_byte = sp->offset * 4; /* make byte value.. */
     1127      1127    1
     1128      1128    1              i = (dt->size_bytes +3)/4 ;
     1129      1129    1
     1130      1130    1        /*    zbk_s_s_table[zbk_datasec].curr_offset  += i ;  */
     1131      1131    1
     1132      1132    1              return ;
     1133      1133    1              }  /*  end of the function zbk$set_address  */
     1134      1134
     1135      1135
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=33 
     1136      1136             /*i*
     1137      1137                   name: zbk$bld_symdef
     1138      1138                   purpose: This routine builds the o.u. symdef entity.
     1139      1139
     1140      1140             */
     1141      1141             zbk$bld_symdef(sp)  struct zbk_sym_tbl *sp;   {
     1142      1142    1        int name_offset ;
     1143      1143    1
     1144      1144    1              pl6str (sp->name); /* put name string into pl6 form of char string. */
     1145      1145    1              XUO$DNAME (zbk_buffer, &name_offset);
     1146      1146    1              XUO$SDEF (&name_offset, &zbk_curr_con_section, &sp->offset);
     1147      1147    1
     1148      1148    1              return;
     1149      1149    1              }   /*  end of the function zbk$bld_symdef.  */
     1150      1150
     1151      1151
     1152      1152             /*i*
     1153      1153                   name: zbk$set_entry_def
     1154      1154                   purpose: This routine sets the entry point and id for the
     1155      1155                   program that we are compiling. The symbol is first found
     1156      1156                   in the symbol tbl (or a symbol table entry is built for it),
     1157      1157                   the class is then set, and the o.u. ent def records are
     1158      1158                   generated.
     1159      1159             */
     1160      1160             zbk$set_entry_def(char *sname)     {
     1161      1161    1        struct zbk_sym_tbl *sp;
     1162      1162    1        int name_offset;
     1163      1163    1
     1164      1164    1
     1165      1165    1              zbk_global_store_flag = 1; /* find global name_match. */
     1166      1166    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,OLD_ID);
     1167      1167    1              zbk_global_store_flag = 0; /* reset search flag.  */
     1168      1168    1              /* symbol table entry is now in hand..*/
     1169      1169    1              sp->ou_set_flag = -1;
     1170      1170    1              if (zbk_static_data_flag != 0 )  {
     1171      1171    2                if (sp->addr_type == SYMDEF_TYPE) {
     1172      1172    3                   return; }
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=34 
     1173      1173    2                else {
     1174      1174    3                   sp->addr_type = SYMDEF_TYPE;
     1175      1175    3                   return;
     1176      1176    3                    }
     1177      1177    2               }
     1178      1178    1
     1179      1179    1              pl6str(sp->name);  /* convert c string to pl6 string. */
     1180      1180    1              sp->sym_class = FUNCTION_CLASS;
     1181      1181    1              sp->reloc_type = ENTREF_TYPE ;
     1182      1182    1              sp->reloc_section = -1 ; /* set for recursive subprogram call. */
     1183      1183    1
     1184      1184    1              XUO$DNAME (zbk_buffer, &name_offset);
     1185      1185    1              XUO$EDEF ( &zbk_procsec, &zbk_zero_val, &name_offset, &zbk_minus_one_val
                               , &zbk_zero_val, &zbk_arg_check[sp->arg_checking],
     1186      1186    1                         &zbk_std_call, &sp->no_params );
     1187      1187    1
     1188      1188    1              strcpy (zbk_progname, sp->name);
     1189      1189    1              zbk_first_func_flag = -1;
     1190      1190    1              return ;
     1191      1191    1              }   /* end of zbk$set_entry_def function.. */
     1192      1192
     1193      1193
     1194      1194             /*i*
     1195      1195                   name: zbk$get_symbol_adr
     1196      1196                   purpose: This routine sets the relocation directive values
     1197      1197                   for code generation. It uses the values from the passed
     1198      1198                   symbol table entry to set the relocation directives.
     1199      1199             */
     1200      1200             zbk$get_symbol_adr (char *sname)    {
     1201      1201    1        int name_offset , eref_num, i;
     1202      1202    1        char tmp1[128];
     1203      1203    1        int j;
     1204      1204    1        struct zbk_sym_tbl *sp ;
     1205      1205    1
     1206      1206    1
     1207      1207    1              zbk_global_store_flag = 1;
     1208      1208    1              sp =(struct zbk_sym_tbl *) zbk$scan_and_search_for_id (sname,OLD_ID);
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=35 
     1209      1209    1              zbk_global_store_flag = 0;
     1210      1210    1              if (zbk_ref_name_flag != 0) { /* looking for ent ref name. */
     1211      1211    2                if (sp->reloc_type != ENTREF_TYPE || sp->ou_set_flag == 0 ||
     1212      1212    2                  sp->reloc_section == -1 ) {
     1213      1213    3                  sp->reloc_type = ENTREF_TYPE;
     1214      1214    3                  sp->sym_class = FUNCTION_CLASS;
     1215      1215    3                  j = zbk$static_func_chk (sp);
     1216      1216    3                  if (j != 0) {
     1217      1217    4                    strcpy(tmp1, sp->name);
     1218      1218    4                    strcat(tmp1,  "#");
     1219      1219    4                    strcat(tmp1, zbk_static_name);
     1220      1220    4                    pl6str(tmp1);
     1221      1221    4                  } else {
     1222      1222    4                    pl6str(sp->name); }
     1223      1223    3                  XUO$RNAME(zbk_buffer, &name_offset);
     1224      1224    3                  i =  sp->no_params ;
     1225      1225    3                  if (sp->arg_checking != 0) {
     1226      1226    4                    j = -1; }
     1227      1227    3                  else {
     1228      1228    4                    j = 0; }
     1229      1229    3                  XUO$EREF( &name_offset, &zbk_zero_val, &zbk_zero_val, &j ,
     1230      1230    3                      &zbk_std_call, &i , &eref_num);
     1231      1231    3                  sp->reloc_section = eref_num;
     1232      1232    3                }
     1233      1233    2              }
     1234      1234    1              sp->ou_set_flag = -1;
     1235      1235    1              if (sp->addr_type == 0 && sp->reloc_type == 0) {
     1236      1236    2                sp->addr_type = SYMREF_TYPE;
     1237      1237    2                zbk$set_reloc_stuff (sp); }
     1238      1238    1              /* we have the symbol table entity in hand... */
     1239      1239    1
     1240      1240    1              zbk_reloc_section = sp->reloc_section ;
     1241      1241    1              zbk_reloc_type = sp->reloc_type ;
     1242      1242    1              zbk_reloc_directive = UHALF_WORD ;
     1243      1243    1
     1244      1244    1              return(sp->offset);
     1245      1245    1              }   /* end of the function zbk$get_symbol_adr   */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=36 
     1246      1246
     1247      1247             int direct[2] ={UHALF_WORD, LHALF_WORD};
     1248      1248
     1249      1249             /*i*
     1250      1250                   name: zbk$zero_pseudo
     1251      1251                   purpose: this routine processes the zero pseudo op that
     1252      1252                   is input off of the code gen input stream.
     1253      1253                   Form of the op is ZERO n,m     where n and m are integer
     1254      1254                   values, that may be in symbolic form to be set in a later
     1255      1255                   code gen input record.
     1256      1256             */
     1257      1257             zbk$zero_pseudo(char *sname)    {
     1258      1258    1        int i;
     1259      1259    1        int frd_ref, count, temp, reloc_type;
     1260      1260    1        struct zbk_sym_tbl *sp;
     1261      1261    1        int save_curr_sec;
     1262      1262    1        struct zbk_inst_std curr_inst;
     1263      1263    1        int name_offset;
     1264      1264    1        int type;
     1265      1265    1        int eref_num;
     1266      1266    1        int opt_flag, lbl_name_off;
     1267      1267    1        int temp1;
     1268      1268    1        int sym_offset;
     1269      1269    1
     1270      1270    1
     1271      1271    1                sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,NEW_ID);
     1272      1272    1              sp->ou_set_flag = -1;
     1273      1273    1                sp->sym_class = EQU_CLASS;
     1274      1274    1                sp->offset = 0;   /* the equ code gen record will set the
     1275      1275    1                                  offset field of the symbol table entry
     1276      1276    1                                  to contain the actual numeric value to
     1277      1277    1                                  be set into this field. It will be done
     1278      1278    1                                  via the forward ref satisfy o.u. scheme
     1279      1279    1                                  of things... */
     1280      1280    1                sp->reloc_type = FREF_AUTO ;
     1281      1281    1                sp->storage_class = AUTO_STORAGE ; /* really a dummy - to get
     1282      1282    1                                it dropped from the variables thread. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=37 
     1283      1283    1                zbk_reloc_type = FREF_AUTO;
     1284      1284    1                zbk_reloc_directive = direct[0];
     1285      1285    1                /* set the forward ref table.  */
     1286      1286    1                zbk_fwd_p->fwd_tbl[zbk_forward_ref_count] = (int *)sp;
     1287      1287    1                sp->reloc_section = zbk_forward_ref_count ;
     1288      1288    1                zbk_forward_ref_count++;
     1289      1289    1                if (zbk_forward_ref_count >= zbk_fwd_tbl_size) {
     1290      1290    2                   zbk_fwd_p = (zbk_fwd_ref_p) Srealloc(zbk_fwd_p, (zbk_fwd_tbl_size+4
                               00)* sizeof(short));
     1291      1291    2                   zbk_fwd_tbl_size += 400;
     1292      1292    2                  }
     1293      1293    1              i = zbk_s_s_table[zbk_curr_con_section].curr_offset - 1;
     1294      1294    1
     1295      1295    1              temp = 17;
     1296      1296    1              count = zbk_forward_ref_count - 1; /* should be the first one. */
     1297      1297    1              frd_ref = FREF_TYPE;
     1298      1298    1              reloc_type = FREF_AUTO;
     1299      1299    1              zbk_save_f_count = count;
     1300      1300    1
     1301      1301    1              XUO$RELOC (&zbk_procsec, &i, &frd_ref, &count, &reloc_type,&zbk_zero_val
                               , &temp);
     1302      1302    1                save_curr_sec = zbk_curr_con_section ;
     1303      1303    1                zbk_curr_con_section = zbk_procsec ;
     1304      1304    1                if (strcmp(zbk_progname, "main") == 0) { /* have main prog so generate
                                special code */
     1305      1305    2                  temp = 17;
     1306      1306    2                  frd_ref = FREF_TYPE;
     1307      1307    2                  reloc_type = FREF_AUTO;
     1308      1308    2                  curr_inst.y_field = 5;
     1309      1309    2                  curr_inst.op_code = 0710000 >> 8;   /* TRA */
     1310      1310    2                  curr_inst.null1 = 0;
     1311      1311    2                  curr_inst.tag_tm = 0;
     1312      1312    2                  curr_inst.tag_td = 4;
     1313      1313    2                  i = zbk_s_s_table[zbk_procsec].curr_offset ++;
     1314      1314    2                  XUO$PRGM (&zbk_procsec, &i, &curr_inst);
     1315      1315    2                  curr_inst.y_field = 0;
     1316      1316    2                  curr_inst.op_code = 0;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=38 
     1317      1317    2                  curr_inst.tag_td = 0;
     1318      1318    2                  i = zbk_s_s_table[zbk_procsec].curr_offset++;
     1319      1319    2                  XUO$PRGM (&zbk_procsec, &i, &curr_inst);
     1320      1320    2                  opt_flag = 0;
     1321      1321    2                  lbl_name_off = -1;
     1322      1322    2                  temp1 = S_INITIALIZE;
     1323      1323    2                  i++;
     1324      1324    2                  XUO$EXST(&zbk_curr_con_section,&i, &lbl_name_off, &zbk_log_blk_num,
     1325      1325    2                     &opt_flag, &temp1, &zbk_zero_val, &zbk_zero_val, &zbk_zero_val);
     1326      1326    2                  curr_inst.y_field = 0;
     1327      1327    2                  curr_inst.op_code = 0637400 >> 8;   /* ERRP7 */
     1328      1328    2                  curr_inst.tag_td = 0 ;
     1329      1329    2                  i = zbk_s_s_table[zbk_procsec].curr_offset++;
     1330      1330    2                  pl6str("__LIB$COM$VECTOR__");
     1331      1331    2                  XUO$RNAME (zbk_buffer, &name_offset);
     1332      1332    2                  XUO$SREF(&name_offset, &zbk_zero_val,&sym_offset,&zbk_zero_val);
     1333      1333    2                  XUO$PRGM (&zbk_procsec, &i, &curr_inst);
     1334      1334    2                  type = SYMREF_TYPE;
     1335      1335    2                  XUO$RELOC (&zbk_procsec, &i, &type, &sym_offset, &zbk_one_val,
     1336      1336    2                             &zbk_zero_val, &temp);
     1337      1337    2                  curr_inst.y_field = 0;
     1338      1338    2                  curr_inst.op_code = 0700000 >> 8;  /* TSX0  */
     1339      1339    2                  curr_inst.tag_td = 0 ;
     1340      1340    2                  i = zbk_s_s_table[zbk_procsec].curr_offset ++;
     1341      1341    2                  zbk_actual_stmt_count++;
     1342      1342    2                  XUO$PRGM (&zbk_procsec, &i, &curr_inst);
     1343      1343    2                  /* build relocation ref to main setup routine. */
     1344      1344    2                  pl6str("__XBI_CSTARTUP");
     1345      1345    2                  XUO$RNAME (zbk_buffer, &name_offset);
     1346      1346    2                  XUO$EREF(&name_offset, &zbk_zero_val, &zbk_minus_one_val, &zbk_zero_
                               val,
     1347      1347    2                    &zbk_std_call, &zbk_zero_val, &eref_num);
     1348      1348    2                  zbk_reloc_section = eref_num;
     1349      1349    2                  type = ENTREF_TYPE;
     1350      1350    2
     1351      1351    2                  XUO$RELOC(&zbk_procsec, &i, &type, &zbk_reloc_section, &zbk_one_val,

CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=39 
     1352      1352    2                    &zbk_zero_val, &temp);
     1353      1353    2
     1354      1354    2                  i = zbk_s_s_table[zbk_procsec].curr_offset ++;
     1355      1355    2                  XUO$PRGM(&zbk_procsec, &i, &zbk_instruc);
     1356      1356    2                  /* repeat of the equal setup stuff..... */
     1357      1357    2                  count = zbk_save_f_count;
     1358      1358    2                  XUO$RELOC(&zbk_procsec, &i, &frd_ref, &count, &reloc_type,
     1359      1359    2                    &zbk_zero_val, &temp);
     1360      1360    2                  pl6str("_GET_UNSHARED_DATA");
     1361      1361    2                  XUO$RNAME(zbk_buffer, &name_offset);
     1362      1362    2                  XUO$EREF (&name_offset, &zbk_zero_val, &zbk_minus_one_val, &zbk_zero
                               _val,
     1363      1363    2                        &zbk_std_call, &zbk_zero_val, &eref_num);
     1364      1364    2
     1365      1365    2                }  /* end of if on main program processing. */
     1366      1366    1                zbk_curr_con_section = save_curr_sec;
     1367      1367    1              return; }  /*end of the function zbk$zero_pseudo. */
     1368      1368
     1369      1369
     1370      1370
     1371      1371
     1372      1372             /*i*
     1373      1373                   name: zbk$set_equ_pseudo
     1374      1374                   purpose: This routine processes that equ code gen pseudo op
     1375      1375                   code. It gets the value to be associated with the symbol
     1376      1376                   that is associated with a numeric value and saves the
     1377      1377                   numeric value in the symbol table entry taht is associated
     1378      1378                   with the symbolic name.
     1379      1379             */
     1380      1380             zbk$set_equ_pseudo(char *sname, int size1)   {
     1381      1381    1        struct zbk_sym_tbl *sp;
     1382      1382    1
     1383      1383    1
     1384      1384    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,OLD_ID);
     1385      1385    1
     1386      1386    1
     1387      1387    1              /*  add pad of 8 for strind move stuff..*/
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=40 
     1388      1388    1              size1 += 8;
     1389      1389    1              sp->offset = size1; /* set the equate value into the symbol tbl. */
     1390      1390    1              sp->sym_class = EQU_CLASS ;
     1391      1391    1              return ;
     1392      1392    1              }   /* end of the function zbk$set_equ_pseudo.    */
     1393      1393
     1394      1394
     1395      1395             /*i*
     1396      1396                   name: zbk$set_debug_fun_info
     1397      1397                   purpose: This routine is used to setup info about the
     1398      1398                   function that we are about to process. this info is then used
     1399      1399                   in the building of the entdef and debug entry o.u. records.
     1400      1400
     1401      1401             */
     1402      1402             zbk$set_debug_fun_info(char *sname,int arg1,int arg2,int arg3,int arg4,int arg
                               5)   {
     1403      1403    1        struct zbk_sym_tbl *sp;
     1404      1404    1        int i;
     1405      1405    1        char tmp1[128];
     1406      1406    1        int j;
     1407      1407    1        int name_offset ;
     1408      1408    1
     1409      1409    1              zbk_ref_name_flag = 1;
     1410      1410    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,OLD_ID);
     1411      1411    1              zbk_ref_name_flag = 0;
     1412      1412    1              sp->ou_set_flag = -1;
     1413      1413    1              sp->sym_class = FUNCTION_CLASS;
     1414      1414    1
     1415      1415    1              /* symbl table entry is now in hand..  */
     1416      1416    1
     1417      1417    1              j = zbk$static_func_chk (sp);
     1418      1418    1              strcpy (tmp1, sp->name);
     1419      1419    1              if (j != 0) {
     1420      1420    2                 strcat (tmp1, "#");
     1421      1421    2                 strcat (tmp1, zbk_static_name);  }
     1422      1422    1              strcpy (zbk_progname, tmp1);
     1423      1423    1              /*  program o.u. init is done at theis time. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=41 
     1424      1424    1
     1425      1425    1              zbk$ouinit();
     1426      1426    1
     1427      1427    1              /* check for static function name.. */
     1428      1428    1
     1429      1429    1              sp->arg_checking = arg1 ; /* set the arg schecking flag */
     1430      1430    1              i  = arg2; /* get normal calling seq flag  */
     1431      1431    1              sp->glo_static_flag = arg3 ; /* global static ref flag  */
     1432      1432    1              if (sp->glo_static_flag == 0) { /* have static function. */
     1433      1433    2                zbk_static_function_flag = 1;  }
     1434      1434    1
     1435      1435    1              i  = arg4-16 ; /* number of bytes of parameters - mius fudge factor. */
     1436      1436    1        /*    if (sp->no_params = 0) { */ /* if set previously, don't set again. */
     1437      1437    1                 sp->no_param_words = (i+3)/4 ;  /* get no. of wrds of parameters. */
     1438      1438    1        /*    } */
     1439      1439    1              zbk_local_storage = ((arg5 )+3)/4;  /* get no. of
     1440      1440    1                                words of storage. */
     1441      1441    1
     1442      1442    1              if( j != 0) {
     1443      1443    2                sp->sym_class = FUNCTION_CLASS;
     1444      1444    2                sp->reloc_type = ENTREF_TYPE ;
     1445      1445    2                sp->reloc_section = -1 ; /* set for recursive subprogram call. */
     1446      1446    2                strcpy(tmp1, sp->name);
     1447      1447    2                strcat(tmp1, "#" );
     1448      1448    2                strcat(tmp1, zbk_static_name);
     1449      1449    2
     1450      1450    2                pl6str(tmp1);  /* convert c string to pl6 string. */
     1451      1451    2                XUO$DNAME (zbk_buffer, &name_offset);
     1452      1452    2                XUO$EDEF ( &zbk_procsec, &zbk_zero_val, &name_offset, &zbk_minus_one_v
                               al, &zbk_zero_val, &zbk_arg_check[sp->arg_checking],
     1453      1453    2                           &zbk_std_call, &sp->no_params );
     1454      1454    2
     1455      1455    2                strcpy (zbk_progname, sp->name);
     1456      1456    2                zbk_first_func_flag = -1;
     1457      1457    2              }
     1458      1458    1              return ;
     1459      1459    1              }   /* end of the zbk$set_debug_fun_info function. */
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=42 
     1460      1460
     1461      1461
     1462      1462             /*i*
     1463      1463                   name: zbk$set_ref_function
     1464      1464                   purpose: The purpose of this function is to get the
     1465      1465                   values for paramter checking for functions that are
     1466      1466                   referenced in this c compile file.
     1467      1467             */
     1468      1468             zbk$set_ref_function(char *sname,int arg1,int arg2,int arg3)  {
     1469      1469    1        int i;
     1470      1470    1        struct zbk_sym_tbl *sp;
     1471      1471    1
     1472      1472    1
     1473      1473    1              zbk_ref_name_flag = 1;
     1474      1474    1              sp = (struct zbk_sym_tbl *) zbk$scan_and_search_for_id(sname,OLD_ID);
     1475      1475    1              zbk_ref_name_flag = 0;
     1476      1476    1              sp->ou_set_flag = -1;
     1477      1477    1              sp->sym_class = FUNCTION_CLASS;
     1478      1478    1              sp->arg_checking = arg1 ;
     1479      1479    1              i = arg2 ;
     1480      1480    1              sp->no_params = arg3 ;
     1481      1481    1              return;
     1482      1482    1        }  /* end of the function zbk$set_ref_function. */
     1483      1483             /*i*
     1484      1484                   name:zbk$static_func_chk
     1485      1485                   purpose: The purpose of this routine is to check if the
     1486      1486                   function name that is currently being processed is a
     1487      1487                   static function name.
     1488      1488
     1489      1489             */
     1490      1490             zbk$static_func_chk (sp) struct zbk_sym_tbl *sp; {
     1491      1491    1        extern int zbk_static_func_count ;
     1492      1492    1        static_funcs_p p, next_p;
     1493      1493    1
     1494      1494    1              if (zbk_static_func_count == 0 ) return(0);
     1495      1495    1
     1496      1496    1              for (p = zbk_static_p; p != (static_funcs_p) 0; p = next_p) {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=43 
     1497      1497    2                next_p = p->next ;
     1498      1498    2                if (strcmp(sp->name, p->name_field.name) == 0 ) {
     1499      1499    3                  return (1); }
     1500      1500    2              }
     1501      1501    1
     1502      1502    1              return (0);
     1503      1503    1              } /* end of the staic_func_chk function. */
     1504      1504
     1505      1505
     1506      1506             /*i*
     1507      1507                   name: zbk$set_debug_blk_info
     1508      1508                   purpose: This routine sets the debug blk tbl info for the
     1509      1509                   debug schema taht is to be generated...
     1510      1510
     1511      1511             */
     1512      1512             zbk$set_debug_blk_info(int start_end_flag,int line_no,int stmt_no,int lex_dept
                               h) {
     1513      1513    1        int name_offset;
     1514      1514    1        int var_num;
     1515      1515    1
     1516      1516    1
     1517      1517    1
     1518      1518    1              if (start_end_flag == 0) { /* start debug block. */
     1519      1519    2        /*      if (zbk_blk_count != 0) {
     1520      1520    2                  zbk_blk_count++;
     1521      1521    2                  return;
     1522      1522    2                 }           */ /* >>>>>>> TEMP CODE <<<<<< */
     1523      1523    2                XUO$LOGBLKALLOC (&zbk_log_blk_num);
     1524      1524    2                zbk_next_log_blk_num[zbk_blk_count] = zbk_log_blk_num;
     1525      1525    2                pl6str(zbk_progname);
     1526      1526    2                lex_depth++;
     1527      1527    2                XUO$DBGNAME (zbk_buffer, &name_offset);
     1528      1528    2                XUO$LOGBLKEXSTINIT ( &zbk_log_blk_num, &zbk_stmt_count, &line_no,
     1529      1529    2                           &name_offset, &lex_depth);
     1530      1530    2                XUO$VREBLNUM( &var_num);
     1531      1531    2                zbk_blk_info[zbk_blk_count].first_line_no = line_no;
     1532      1532    2                zbk_blk_info[zbk_blk_count].stmt_no = stmt_no;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=44 
     1533      1533    2                zbk_blk_info[zbk_blk_count].lex_depth = lex_depth;
     1534      1534    2                zbk_blk_info[zbk_blk_count].log_blk_num = zbk_log_blk_num;
     1535      1535    2                zbk_blk_info[zbk_blk_count].name_offset = name_offset;
     1536      1536    2                zbk_blk_info[zbk_blk_count].stmt_count = zbk_stmt_count;
     1537      1537    2                zbk_blk_info[zbk_blk_count].first_var = var_num;
     1538      1538    2                XUO$LOGBLKVREBLINIT ( &zbk_log_blk_num, &var_num);
     1539      1539    2                zbk_blk_count++;
     1540      1540    2                }
     1541      1541    1              else {   /*  end debug block. */
     1542      1542    2        /*      if (zbk_blk_count > 1) {    >>>>>>> TEMP CODE <<<<<<<
     1543      1543    2                  zbk_blk_count--;
     1544      1544    2                  return;
     1545      1545    2                 }      */
     1546      1546    2
     1547      1547    2
     1548      1548    2                if (zbk_blk_count == 1) {
     1549      1549    3                  zbk$set_global_debug_vars();  }
     1550      1550    2                XUO$VREBLNUM( &var_num);
     1551      1551    2                if (zbk_blk_count > 1) {  /* finish blk stuff if outside the blk. */
     1552      1552    3
     1553      1553    3                  XUO$LOGBLKEXSTTERM ( &zbk_log_blk_num, &zbk_stmt_count, &zbk_last_li
                               ne_no);
     1554      1554    3                  XUO$LOGBLKVREBLTERM (&zbk_log_blk_num, &var_num);  }
     1555      1555    2                zbk_blk_count--;
     1556      1556    2                zbk_blk_info[zbk_blk_count].last_line_no = zbk_last_line_no;
     1557      1557    2                zbk_blk_info[zbk_blk_count].last_stmt_no = zbk_stmt_count;
     1558      1558    2                zbk_blk_info[zbk_blk_count].stmt_count = zbk_stmt_count;
     1559      1559    2                zbk_blk_info[zbk_blk_count].last_var = var_num;
     1560      1560    2                if (zbk_blk_count >= 1) {
     1561      1561    3                  zbk_log_blk_num = zbk_next_log_blk_num[zbk_blk_count-1]; }
     1562      1562    2
     1563      1563    2
     1564      1564    2                }
     1565      1565    1              return;
     1566      1566    1              }  /* end of the function zbk$set_debug_blk_info. */
     1567      1567
     1568      1568             /*i*
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=45 
     1569      1569                   name: zbk$close_debug_blks
     1570      1570                   purpose: This routine closes the debug blocks that are
     1571      1571                   associated with the object unit, and specify the range
     1572      1572                   of the debug information.
     1573      1573             */
     1574      1574             zbk$close_debug_blks () {
     1575      1575    1
     1576      1576    1                  XUO$LOGBLKEXSTTERM ( &zbk_blk_info[0].log_blk_num,
     1577      1577    1                     &zbk_actual_stmt_count, &zbk_blk_info[0].last_line_no);
     1578      1578    1                  XUO$LOGBLKVREBLTERM (&zbk_blk_info[0].log_blk_num,
     1579      1579    1                         &zbk_blk_info[0].last_var);
     1580      1580    1                  return;
     1581      1581    1        }
     1582      1582
     1583      1583
     1584      1584
     1585      1585             /*i*
     1586      1586                   name: zbk$set_label_info
     1587      1587                   purpose: this routine sets up the label info for the debug
     1588      1588                   tables. That is, the executable stmt entries that are made
     1589      1589                   for each statement.
     1590      1590
     1591      1591             */
     1592      1592             zbk$set_label_info(int line_no,int sub_stmt_no,char *str)   {
     1593      1593    1        char lbl_str[32];
     1594      1594    1        int lbl_offset ;
     1595      1595    1        struct zbk_line_tbl *lp;
     1596      1596    1        struct zbk_sub_lbl_tbl *slp, *slp_next, *last_slp;
     1597      1597    1        line_tbl_p zbk$get_line_tbl_entry();
     1598      1598    1
     1599      1599    1
     1600      1600    1              strcpy (lbl_str, str);
     1601      1601    1
     1602      1602    1              pl6str(lbl_str);
     1603      1603    1              XUO$DBGNAME ( zbk_buffer, &lbl_offset);
     1604      1604    1              zbk_active_label = lbl_offset;
     1605      1605    1
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=46 
     1606      1606    1              lp = (struct zbk_line_tbl *) zbk$get_line_tbl_entry(line_no);
     1607      1607    1
     1608      1608    1              if (sub_stmt_no == 0 ) {  /* no substmt number for lbl. */
     1609      1609    2                lp->lbl_name_offset = lbl_offset ;
     1610      1610    2                return;
     1611      1611    2               }
     1612      1612    1
     1613      1613    1              if (lp->sub_lbl_tbl_ptr == NULL )  { /* bld entry ofr the null string. *
                               /
     1614      1614    2                lp->sub_lbl_tbl_ptr = (struct zbk_sub_lbl_tbl *) zbk$myalloc(sizeof(st
                               ruct zbk_sub_lbl_tbl));
     1615      1615    2                slp = lp->sub_lbl_tbl_ptr;
     1616      1616    2                slp->next = NULL;
     1617      1617    2                slp->sub_stmt_no = sub_stmt_no;
     1618      1618    2                slp->lbl_name_offset = lbl_offset;
     1619      1619    2                return;
     1620      1620    2              } /* end of if test for null ptr. */
     1621      1621    1
     1622      1622    1              for (slp = lp->sub_lbl_tbl_ptr; slp != NULL; slp = slp_next) {
     1623      1623    2                slp_next = slp->next;
     1624      1624    2                last_slp = slp;
     1625      1625    2                if (slp->sub_stmt_no == sub_stmt_no) {
     1626      1626    3                  slp->lbl_name_offset = lbl_offset;
     1627      1627    3                  return;
     1628      1628    3                }
     1629      1629    2              }  /* end of the for loop */
     1630      1630    1              /* no match so build a new entry at this point. */
     1631      1631    1              slp = (struct zbk_sub_lbl_tbl *) zbk$myalloc(sizeof(struct zbk_sub_lbl_t
                               bl));
     1632      1632    1              slp->next = NULL;
     1633      1633    1              last_slp->next = &slp->next;
"zbk$tables:c.:ZBC3TSI", line 1633: (warning) incompatible pointers in =
     1634      1634    1              slp->sub_stmt_no = sub_stmt_no;
     1635      1635    1              slp->lbl_name_offset = lbl_offset;
     1636      1636    1              return;
     1637      1637    1              }  /* end of the function zbk$set_label_info. */
     1638      1638
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=47 
     1639      1639             /*i*
     1640      1640                   name: zbk$get_line_tbl_entry
     1641      1641                   purpose: This routine is the one to find the current line
     1642      1642                   number, or build a new line table entry for the current
     1643      1643                   line number.
     1644      1644
     1645      1645             */
     1646      1646             line_tbl_p  zbk$get_line_tbl_entry(line_no)  int line_no;  {
     1647      1647    1        struct zbk_line_tbl *lp, *next_lp, *last_lp;
     1648      1648    1
     1649      1649    1
     1650      1650    1              if (zbk_line_tbl_ptr == NULL)  {  /* first entry in table. */
     1651      1651    2                zbk_line_tbl_ptr =(struct zbk_line_tbl *) zbk$myalloc(sizeof(struct zb
                               k_line_tbl));
     1652      1652    2                lp = zbk_line_tbl_ptr;
     1653      1653    2                lp->line_no = line_no;
     1654      1654    2                lp->lbl_name_offset = -1;
     1655      1655    2                lp->next = NULL;
     1656      1656    2                lp->sub_lbl_tbl_ptr = NULL;
     1657      1657    2                return (lp);
     1658      1658    2              }  /* end of if test for first line tbl entry. */
     1659      1659    1
     1660      1660    1              /* search existing line tbl entries for match. */
     1661      1661    1              for (lp=zbk_line_tbl_ptr; lp != NULL; lp = next_lp) {
     1662      1662    2                next_lp = lp->next;
     1663      1663    2                last_lp = lp;
     1664      1664    2                if (lp->line_no == line_no)  { /* have match on line no. */
     1665      1665    3                  return (lp);
     1666      1666    3                 }
     1667      1667    2                }   /* end of the for loop . */
     1668      1668    1              /* if we get here, no match was found. build the next entry. */
     1669      1669    1              lp = (struct zbk_line_tbl *) zbk$myalloc(sizeof(struct zbk_line_tbl));
     1670      1670    1
     1671      1671    1              lp->next = NULL;
     1672      1672    1              last_lp->next = &lp->next ;
"zbk$tables:c.:ZBC3TSI", line 1672: (warning) incompatible pointers in =
     1673      1673    1              lp->sub_lbl_tbl_ptr =NULL;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=48 
     1674      1674    1              lp->line_no = line_no;
     1675      1675    1              lp->lbl_name_offset = -1;
     1676      1676    1
     1677      1677    1              return (lp);
     1678      1678    1              }  /* end of the zbk$get_line_tbl_entry function. */
     1679      1679
     1680      1680
     1681      1681             /*i*
     1682      1682                   name: zbk$set_debug_stmt_info
     1683      1683                   purpose: This routine sets the stmt number into into the
     1684      1684                   line number table entry. If stmt number already exist,
     1685      1685                   build sub stmt number entry.
     1686      1686
     1687      1687             */
     1688      1688             zbk$set_debug_stmt_info(int stmt_type,int line_no,int stmt_no)  {
     1689      1689    1        int sub_stmt_no;
     1690      1690    1        struct zbk_line_tbl *lp;
     1691      1691    1        struct zbk_sub_lbl_tbl *slp, *next_slp, *last_slp;
     1692      1692    1        int save_curr_sec;
     1693      1693    1
     1694      1694    1
     1695      1695    1              zbk_stmt_count++;
     1696      1696    1              lp = (struct zbk_line_tbl *) zbk$get_line_tbl_entry(line_no);
     1697      1697    1              zbk_last_line_no = line_no; /* save lin no of last stmt processed. */
     1698      1698    1
     1699      1699    1              if (zbk_stmt_count == 1) { /* save line no of first stmt in the prog. */

     1700      1700    2                zbk_prog_first_line_no = line_no; }
     1701      1701    1
     1702      1702    1              if (lp->stmt_type == 0)  {  /* NO previous stmt entry.. */
     1703      1703    2                lp->stmt_type = stmt_type;
     1704      1704    2                lp->stmt_no = stmt_no;
     1705      1705    2                if (zbk_active_label != 0) {
     1706      1706    3                  lp->lbl_name_offset = zbk_active_label; }
     1707      1707    2              if (zbk_first_prog_line != 0 ) {
     1708      1708    3                zbk_first_prog_line = 0;
     1709      1709    3                save_curr_sec = zbk_curr_con_section ;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=49 
     1710      1710    3                zbk_curr_con_section = zbk_procsec ;
     1711      1711    3                zbk$bld_debug_exec_tbl_entry (line_no, 0);
     1712      1712    3                zbk_curr_con_section = save_curr_sec; }
     1713      1713    2                zbk_active_label = 0;
     1714      1714    2                if (stmt_no != 0 ) {
     1715      1715    3                  last_slp = NULL;
     1716      1716    3                  sub_stmt_no = 0;
     1717      1717    3                  goto zbk$set_sub_stmt; }
     1718      1718    2                return;
     1719      1719    2               } /* end of test on stmt_tyep */
     1720      1720    1
     1721      1721    1              /* have stmt entry already in the line number table.
     1722      1722    1                 Walk the sub stmt thread to find match or build a
     1723      1723    1                 new entry.
     1724      1724    1              */
     1725      1725    1              last_slp = NULL;
     1726      1726    1              sub_stmt_no = 0;
     1727      1727    1              for (slp = lp->sub_lbl_tbl_ptr; slp != NULL; slp = next_slp)  {
     1728      1728    2                next_slp = slp->next ;
     1729      1729    2                last_slp = slp;
     1730      1730    2                sub_stmt_no ++;
     1731      1731    2                if (slp->stmt_type == 0)  {
     1732      1732    3                  slp->stmt_type = stmt_type;
     1733      1733    3                  return;
     1734      1734    3                }
     1735      1735    2               }  /* end of the for loop- did not find empty table entry.
     1736      1736    1                     Therefore, need to build new entry and set the start
     1737      1737    1                     stmt_type and sub_stmt_no fields...
     1738      1738    1                  */
     1739      1739    1        zbk$set_sub_stmt:
     1740      1740    1              slp = (struct zbk_sub_lbl_tbl *) zbk$myalloc(sizeof(struct zbk_sub_lbl_t
                               bl));
     1741      1741    1              sub_stmt_no++;
     1742      1742    1              if (last_slp != NULL)  {
     1743      1743    2                last_slp->next = &slp->next;
"zbk$tables:c.:ZBC3TSI", line 1743: (warning) incompatible pointers in =
     1744      1744    2              } else  {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=50 
     1745      1745    2                lp->sub_lbl_tbl_ptr = slp; }
     1746      1746    1              slp->next = NULL;
     1747      1747    1              slp->stmt_type = stmt_type;
     1748      1748    1              slp->sub_stmt_no = sub_stmt_no ;
     1749      1749    1              slp->lbl_name_offset = -1 ;
     1750      1750    1
     1751      1751    1              return ;
     1752      1752    1              }  /*   end of the set debug stmt info..  */
     1753      1753
     1754      1754
     1755      1755             /*i*
     1756      1756                   name: zbk$set_line
     1757      1757                   purpose: this is the routine to build the debug table
     1758      1758                   entries for executable statements. this is the rtuine
     1759      1759                   to process the line number entries from the code gen
     1760      1760                   input stream.
     1761      1761
     1762      1762             */
     1763      1763             zbk$set_line(int line_no)    {  /* process the line number fields on input. */

     1764      1764    1        int  sub_line_no ;
     1765      1765    1
     1766      1766    1
     1767      1767    1              if (zbk_debug_flag == 0) return; /* if no debug schema - exit. */
     1768      1768    1
     1769      1769    1              if (line_no == zbk_prog_first_line_no) { /* not really first line, so sk
                               ip. */
     1770      1770    2                zbk_curr_line_no = line_no;
     1771      1771    2                return; }
     1772      1772    1
     1773      1773    1              sub_line_no = line_no/262144;
     1774      1774    1              line_no = line_no%262144 ;
     1775      1775    1
     1776      1776    1              zbk_curr_line_no = line_no;
     1777      1777    1
     1778      1778    1              zbk_line_num = zbk_curr_line_no;
     1779      1779    1              zbk$bld_debug_exec_tbl_entry(line_no, sub_line_no);
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=51 
     1780      1780    1
     1781      1781    1              return;
     1782      1782    1              }  /* end of zbk$set_line funxtion. */
     1783      1783
     1784      1784
     1785      1785             /*i*
     1786      1786                   name: zbk$bld_debug_exec_tbl_entry
     1787      1787                   purpose: This routine is the one to build the o.u. debug
     1788      1788                   record entries for executable statements. It searches the
     1789      1789                   line # tbl looking for the match, and then uses the info
     1790      1790                   from the line no. tbl to build the debug record.
     1791      1791
     1792      1792             */
     1793      1793             zbk$bld_debug_exec_tbl_entry(line_no, sub_line_no)  int line_no;int sub_line_n
                               o;  {
     1794      1794    1        int opt_flag , offset_address;
     1795      1795    1        struct zbk_line_tbl *lp;
     1796      1796    1        struct zbk_sub_lbl_tbl *slp, *next_slp ;
     1797      1797    1
     1798      1798    1              lp = (struct zbk_line_tbl *) zbk$get_line_tbl_entry(line_no);
     1799      1799    1
     1800      1800    1              if (sub_line_no == 0) { /* build main line no debug stuff. */
     1801      1801    2                /*build exec stmt debug record.  */
     1802      1802    2                lp->section_no = zbk_curr_con_section;
     1803      1803    2                lp->addr_offset = zbk_s_s_table[zbk_curr_con_section].curr_offset;
     1804      1804    2                if (lp->stmt_type  == 101) { /* loop for proc stmt. */
     1805      1805    3                   lp->addr_offset = 0; }
     1806      1806    2
     1807      1807    2
     1808      1808    2                opt_flag = 0;
     1809      1809    2                if (lp->stmt_type == 1 || lp->stmt_type == 5 ||
     1810      1810    2                    lp->stmt_type ==35 )  {
     1811      1811    3                  opt_flag = -1; }
     1812      1812    2                XUO$EXST (&lp->section_no, &lp->addr_offset, &lp->lbl_name_offset,
     1813      1813    2                         &zbk_log_blk_num, &opt_flag, &lp->stmt_type, &line_no, &zbk_z
                               ero_val, &zbk_zero_val);
     1814      1814    2                zbk_actual_stmt_count++;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=52 
     1815      1815    2              }  /* this is the end of main line no debug processing. */
     1816      1816    1
     1817      1817    1              /* now walk the sub lbl tbl thread looking for sub stmts
     1818      1818    1                 for the current line number. */
     1819      1819    1
     1820      1820    1              if (sub_line_no == 0) { return; }
     1821      1821    1              for (slp= lp->sub_lbl_tbl_ptr ; slp != NULL; slp=next_slp) {
     1822      1822    2                next_slp = slp->next ;
     1823      1823    2                opt_flag = 0;
     1824      1824    2                if (sub_line_no == slp->sub_stmt_no ) {
     1825      1825    3                  if (slp->stmt_type == 1 || slp->stmt_type == 5 ||
     1826      1826    3                      slp->stmt_type ==35 )  {
     1827      1827    4                    opt_flag = -1; }
     1828      1828    3                  offset_address = zbk_s_s_table[zbk_curr_con_section].curr_offset;
     1829      1829    3                  XUO$EXST (&lp->section_no, &offset_address, &slp->lbl_name_offset,
     1830      1830    3                          &zbk_log_blk_num, &opt_flag, &slp->stmt_type, &line_no, &zbk
                               _zero_val, &zbk_zero_val);
     1831      1831    3                  zbk_actual_stmt_count++;
     1832      1832    3                  return; }
     1833      1833    2
     1834      1834    2              }  /* end of the for loop */
     1835      1835    1              return;
     1836      1836    1              }  /* end of the zbk$bld_debug_exec_tbl_entry. */
     1837      1837
     1838      1838
     1839      1839
     1840      1840
     1841      1841             /*i*
     1842      1842                   name: zbk$build_debug
     1843      1843                   purpose: This routine is used to build the ariable debug record
     1844      1844                   hat is needed for all variables that are used in the program.
     1845      1845                   It calls the XUO$VREBL routine whcih acutally puts the info
     1846      1846                   into the o.u. debug record.
     1847      1847             */
     1848      1848             zbk$build_debug(sp)  struct zbk_sym_tbl *sp; {
     1849      1849    1        struct zbk_sym_debug_tbl *dt;
     1850      1850    1        int d_address;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=53 
     1851      1851    1        int d_addr_type;
     1852      1852    1        int d_data_type;
     1853      1853    1        int d_ref_flag;
     1854      1854    1        int d_mod_flag;
     1855      1855    1        int d_log_size;
     1856      1856    1        int d_level_no;
     1857      1857    1        int d_align_type;
     1858      1858    1        int d_size_type_flag;
     1859      1859    1        int d_array_type;
     1860      1860    1        int d_operand_type;
     1861      1861    1        int d_operand;
     1862      1862    1        int d_imp_ptr;
     1863      1863    1        int d_ele_size;
     1864      1864    1        int d_scale_factor;
     1865      1865    1        int d_dims ;
     1866      1866    1        int d_name_offset;
     1867      1867    1        int d_elements;
     1868      1868    1        int d_offset;
     1869      1869    1        int d_multi[10];
     1870      1870    1        int i;
     1871      1871    1        int ele_bytes;
     1872      1872    1        int save_flag = 0;
     1873      1873    1        int save_reloc_type;
     1874      1874    1        int save_reloc_section;
     1875      1875    1        int save_storage_class;
     1876      1876    1
     1877      1877    1              if (zbk_static_data_flag != 0) return;
     1878      1878    1              dt = sp->debug;
     1879      1879    1              pl6str( sp->name);
     1880      1880    1
     1881      1881    1              XUO$DBGNAME (zbk_buffer, &d_name_offset); /* put name in debug name tbl
                               */
     1882      1882    1
     1883      1883    1              if (dt->addr_type == 1) {  /* static data entity.. */
     1884      1884    2                if (sp->storage_class == GLOBAL_STATIC_STORAGE) {
     1885      1885    3                   d_address = sp->offset * 36; }
     1886      1886    2                else {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=54 
     1887      1887    3                   d_address = sp->offset * 9; }  }
     1888      1888    1              else {
     1889      1889    2                d_address = dt->addr_byte*9 ; /* make a bit address. */
     1890      1890    2                if (dt->starting_bit != 0) {
     1891      1891    3                  d_address += dt->starting_bit; }
     1892      1892    2              }
     1893      1893    1              d_addr_type = zbk_addr_type_tbl[dt->addr_type];
     1894      1894    1              d_data_type = dt->data_type;
     1895      1895    1              d_ref_flag = -1;
     1896      1896    1              d_mod_flag = -1;
     1897      1897    1              d_ele_size = 0;
     1898      1898    1              d_level_no = dt->level_no;
     1899      1899    1              d_align_type = zbk_align_vals[d_data_type];
     1900      1900    1              d_size_type_flag = 0;
     1901      1901    1              if (d_data_type == STRUCTURE_DATA_TYPE && d_level_no == 1) {
     1902      1902    2                 zbk_curr_struct_type = d_addr_type;
     1903      1903    2                 zbk_curr_struct_reloc_type = sp->reloc_type;
     1904      1904    2                 zbk_curr_struct_reloc_section = sp->reloc_section;
     1905      1905    2                zbk_curr_offset_value = d_address ;
     1906      1906    2                 zbk_curr_storage_class = sp->storage_class ; }
     1907      1907    1              else {
     1908      1908    2                 if ( d_level_no > 1 ) {
     1909      1909    3                    d_addr_type = zbk_curr_struct_type;
     1910      1910    3                    if (d_addr_type != AUTO_TYPE) {
     1911      1911    4                      d_address  += zbk_curr_offset_value ; }
     1912      1912    3                    save_flag = 1;
     1913      1913    3                    save_reloc_type = sp->reloc_type;
     1914      1914    3                    save_reloc_section = sp->reloc_section;
     1915      1915    3                    save_storage_class = sp->storage_class;
     1916      1916    3                    sp->reloc_type = zbk_curr_struct_reloc_type;
     1917      1917    3                    sp->reloc_section = zbk_curr_struct_reloc_section;
     1918      1918    3                    sp->storage_class = zbk_curr_storage_class; }
     1919      1919    2               }
     1920      1920    1              ele_bytes = 1; /* set to default value of 1. */
     1921      1921    1              if (d_data_type == 1 ||
     1922      1922    1                  d_data_type == 3 ||
     1923      1923    1                  d_data_type == 13
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=55 
     1924      1924    1                                    ) {
     1925      1925    2                ele_bytes = 4; }
     1926      1926    1              else {
     1927      1927    2                if (d_data_type == 2 || d_data_type == 4) {
     1928      1928    3                  ele_bytes = 8; }
     1929      1929    2                }
     1930      1930    1              if (d_data_type == 24) {
     1931      1931    2                ele_bytes = 4 ; }
     1932      1932    1              if (d_data_type == 3 ||    /* single pre float */
     1933      1933    1                  d_data_type == 4  ||   /* double pre float */
     1934      1934    1                  d_data_type == 17      /* structure  */
     1935      1935    1                                    ) {
     1936      1936    2                  d_ele_size = dt->ele_size * 9; }
     1937      1937    1              else {
     1938      1938    2                 d_ele_size = dt->ele_size ; }
     1939      1939    1
     1940      1940    1              if (d_data_type == UBIN_DATA_TYPE || d_data_type == SBIN_DATA_TYPE) {
     1941      1941    2                d_log_size = dt->size_bytes; }
     1942      1942    1              else {
     1943      1943    2                d_log_size = d_ele_size;  }
     1944      1944    1              if (dt->array_rec_count != 0) {
     1945      1945    2                 /* have array variable. */
     1946      1946    2                 if (d_data_type == CHAR_DATA_TYPE) {
     1947      1947    3                   d_ele_size = 9; }
     1948      1948    2                 if (d_data_type == POINTER_DATA_TYPE) {
     1949      1949    3                   d_ele_size = 36; }
     1950      1950    2                 if (dt->array_rec_count == 1) {
     1951      1951    3                    d_dims = dt->array_size/ele_bytes;
     1952      1952    3                    d_array_type = VECTOR0_ARRAY; }
     1953      1953    2                 else {
     1954      1954    3                    d_array_type = GENERAL_ARRAY;
     1955      1955    3                    d_dims = dt->array_rec_count; }  }
     1956      1956    1              else {
     1957      1957    2                 d_ele_size = 0;
     1958      1958    2                 d_array_type = SCALAR_ARRAY ;
     1959      1959    2                 d_dims = 0; }
     1960      1960    1              d_operand_type = sp->reloc_type ;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=56 
     1961      1961    1              d_operand = sp->reloc_section ;
     1962      1962    1              if (d_data_type == POINTER_DATA_TYPE) {
     1963      1963    2                 d_log_size = 1;
     1964      1964    2                 d_imp_ptr = 0;
     1965      1965    2               }
     1966      1966    1
     1967      1967    1
     1968      1968    1              if (d_addr_type == 3) {  /* pointer address type.  */
     1969      1969    2                 d_imp_ptr = -1;
     1970      1970    2              } else {
     1971      1971    2                 d_imp_ptr = -1;
     1972      1972    2               }
     1973      1973    1
     1974      1974    1              d_scale_factor = 0;
     1975      1975    1
     1976      1976    1              XUO$VREBL (&d_address, &d_addr_type,
     1977      1977    1                 &d_data_type, &d_ref_flag,
     1978      1978    1                 &d_mod_flag,
     1979      1979    1                 &d_log_size,
     1980      1980    1                 &d_level_no,
     1981      1981    1                 &d_align_type,
     1982      1982    1                 &d_size_type_flag,
     1983      1983    1                 &d_array_type,
     1984      1984    1                 &d_operand_type,
     1985      1985    1                 &d_imp_ptr,
     1986      1986    1                 &d_operand,
     1987      1987    1                 &d_ele_size,
     1988      1988    1                 &d_scale_factor,
     1989      1989    1                 &d_dims ,
     1990      1990    1                 &d_name_offset );
     1991      1991    1              if (d_array_type == GENERAL_ARRAY ) {
     1992      1992    2                for (i=0; i <= 5; i++) {  /* zero init the array items. */
     1993      1993    3                  d_multi[i] = 0; }
     1994      1994    2                d_elements = dt->array_size/ele_bytes;
     1995      1995    2                d_offset = 0;
     1996      1996    2                d_multi[dt->array_rec_count-1] =1;
     1997      1997    2                for ( i= dt->array_rec_count-2; i >= 0; i--) {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=57 
     1998      1998    3                  d_multi[i] = dt->array_info[i+1]/ele_bytes;
     1999      1999    3                 }
     2000      2000    2                XUO$VREBL_CONT (&d_offset, &d_data_type,
     2001      2001    2                    &d_elements, &d_multi[0],
     2002      2002    2                    &d_multi[1], &d_multi[2],
     2003      2003    2                    &d_multi[3], &d_multi[4],
     2004      2004    2                    &d_multi[5] ) ;
     2005      2005    2              }   /* end of the array multipliers processing. */
     2006      2006    1
     2007      2007    1              if (save_flag != 0) {
     2008      2008    2                 sp->reloc_type = save_reloc_type;
     2009      2009    2                 sp->reloc_section = save_reloc_section;
     2010      2010    2                 sp->storage_class = save_storage_class;  }
     2011      2011    1              return ;
     2012      2012    1              }   /* end of the build debug routine     */
     2013      2013
     2014      2014
     2015      2015             /*i*
     2016      2016                   NAME:zbk$chk_entref_names
     2017      2017                   PURPOSE: This function checks if the static function names
     2018      2018                   are in the debug record. They will not be, so it then builds
     2019      2019                   the debug schema for all the static function names so that
     2020      2020                   the user can then reference all the static function names
     2021      2021                   via their 'correct' user reference name.
     2022      2022             */
     2023      2023             zbk$chk_entref_names() {
     2024      2024    1        int i;
     2025      2025    1        int eref_num, name_offset;
     2026      2026    1        int hash_value;
     2027      2027    1        char tmp1 [128];
     2028      2028    1        static_funcs_p p, next_p;
     2029      2029    1        struct zbk_sym_tbl *sp, *sp1, *sp2, *next ;
     2030      2030    1        struct zbk_sym_debug_tbl *dp;
     2031      2031    1
     2032      2032    1
     2033      2033    1              for (p = zbk_static_p; p != (static_funcs_p) 0; p = next_p ) {
     2034      2034    2                next_p = p->next;
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=58 
     2035      2035    2                sp1 = (struct zbk_sym_tbl *) zbk_symbol_hash[p->hash];
     2036      2036    2                strcpy (zbk_h_stuff.label_t, p->name_field.name);
     2037      2037    2                if (sp1 == NULL) {
     2038      2038    3                  hash_value = p->hash ;
     2039      2039    3                  sp = (struct zbk_sym_tbl *) zbk$bld_sym_tbl_entry(sp1,last_sp,hash_v
                               alue);
     2040      2040    3                  sp->debug = NULL ;
     2041      2041    3                  sp->next = NULL ;  }
     2042      2042    2                else {
     2043      2043    3                  /*  search for match.. */
     2044      2044    3                  for (sp2 = sp1; sp2 != NULL; sp2 = next) {
     2045      2045    4                    next =  sp2->next;
     2046      2046    4                    last_sp = sp2;
     2047      2047    4                    if (( i=strcmp (zbk_h_stuff.label_t, sp2->name)) == 0 ) {
     2048      2048    5                      /* have match on text names at this point. */
     2049      2049    5                      if (sp2->sym_class != FUNCTION_CLASS) { goto next_test; }
     2050      2050    5                      sp = sp2 ;
     2051      2051    5                      goto set_debug;
     2052      2052    5                    }  /* end of if test on string compare... */
     2053      2053    4        next_test:  ;
     2054      2054    4                  }  /* end of the for loop on matching.. */
     2055      2055    3                  /* at this point, no match was found so build new
     2056      2056    3                     new symbol table entry.  */
     2057      2057    3                  hash_value = p->hash ;
     2058      2058    3                  sp = (struct zbk_sym_tbl *) zbk$bld_sym_tbl_entry (sp1,last_sp,hash_
                               value);
     2059      2059    3
     2060      2060    3                  sp->debug = NULL ;
     2061      2061    3                  sp->next = NULL ;
     2062      2062    3                }  /* end of if test on sp1 == null  */
     2063      2063    2
     2064      2064    2                sp->addr_type = AUTO_TYPE;
     2065      2065    2                sp->sym_class = FUNCTION_CLASS;
     2066      2066    2
     2067      2067    2        set_debug:  /* at this point, we are setting the debug info. */
     2068      2068    2
     2069      2069    2                if (sp->debug == NULL ) {
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=59 
     2070      2070    3                  dp = (struct zbk_sym_debug_tbl *) zbk$myalloc(sizeof(struct zbk_sym_
                               debug_tbl));
     2071      2071    3                  sp->debug = dp;
     2072      2072    3                }
     2073      2073    2                /* set the values in the debug table entry for the symbol
     2074      2074    2                   so the proper debug info will be generated. */
     2075      2075    2                dp = sp->debug;
     2076      2076    2                dp->level_no = 1;
     2077      2077    2                dp->addr_type = STATIC_TYPE;
     2078      2078    2                dp->data_type = LABEL_DATA_TYPE;
     2079      2079    2                dp->ele_size = 1;
     2080      2080    2                sp->offset = 0;
     2081      2081    2
     2082      2082    2                if (sp->reloc_type == 0 || sp->reloc_section == -1)  { /* build entref
                                of external name. */
     2083      2083    3                  strcpy(tmp1, sp->name);
     2084      2084    3                  strcat(tmp1, "#");
     2085      2085    3                  strcat(tmp1, zbk_static_name);
     2086      2086    3                  pl6str(tmp1);
     2087      2087    3                  XUO$RNAME (zbk_buffer, &name_offset);
     2088      2088    3                  XUO$EREF (&name_offset, &zbk_zero_val, &zbk_minus_one_val, &zbk_zero
                               _val,
     2089      2089    3                     &zbk_std_call, &zbk_zero_val, &eref_num);
     2090      2090    3                  sp->reloc_section = eref_num ;
     2091      2091    3                  sp->reloc_type = ENTREF_TYPE;
     2092      2092    3                }  /* end of the build of the relocation directive... */
     2093      2093    2
     2094      2094    2                zbk$build_debug (sp);
     2095      2095    2                sp->addr_type = STATIC_TYPE;
     2096      2096    2              }  /* end of for loop on static function names. */
     2097      2097    1              return;
     2098      2098    1        }  /* end of the zbk$chk_entref_name function..  */
     2099      2099
     2100      2100             /*I*
     2101      2101                   NAME: GET_LAST_DEBUG_LINE
     2102      2102                   PURPOSE: This function gets the last executable line tbl
     2103      2103                   entry of the last o.u. that was created, and compares it
CC.C03    File=zbk$tables:c.:ZBC3TSI                                                Fri Aug 22 1997  Page=60 
     2104      2104                   with the passed line number. It sets a flag word that was
     2105      2105                   passed to indicate if a match was found. I returns 0 if
     2106      2106                   the <= condition was not found  with the compare. It returns
     2107      2107                   -1 it the last debug line is <= to the passed line number.
     2108      2108             */
     2109      2109             GET_LAST_DEBUG_LINE(line, flag) int *line, *flag; {
     2110      2110    1              if (zbk_curr_line_no < *line) {
     2111      2111    2                *flag = -1; }
     2112      2112    1              else {
     2113      2113    2                *flag = 0;}
     2114      2114    1              return;
     2115      2115    1        }
---  Include file information  ---

   stdio:h.:LIBRARY. is referenced
   string:h.:LIBRARY. is referenced
   zbk$ougen:h.:ZBC3TOU. is referenced
   zbk$tables:h.:ZBC3TOU. is referenced
   zb_cp6_object:h.:ZBC3TOU. is referenced

6 warnings were detected in the file zbk$tables:c.:ZBC3TSI
