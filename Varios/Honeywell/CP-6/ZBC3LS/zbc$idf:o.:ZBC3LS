

CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=1  
        1         1             /*
        2         2              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3         3              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4         4              */
        5         5             /* $Header: idf.c,v 3.18 87/03/26 11:05:28 ceriel Exp $ */
        6         6             /*  IDENTIFIER  FIDDLING & SYMBOL TABLE HANDLING */
        7         7
        8         8             #include  "nofloat.h"
        9         9             #include  "debug.h"
       10        10             #include  "idfsize.h"
       11        11             #include  "botch_free.h"
       12        12             #include  "nopp.h"
       13        13             #include  <alloc.h>
       14        14             #include  "arith.h"
       15        15             #include  "align.h"
       16        16             #include  "LLlex.h"
       17        17             #include  "level.h"
       18        18             #include  "stack.h"
       19        19             #include  "idf.h"
       20        20             #include  "label.h"
       21        21             #include  "def.h"
       22        22             #include  "type.h"
       23        23             #include  "struct.h"
       24        24             #include  "declar.h"
       25        25             #include  "decspecs.h"
       26        26             #include  "sizes.h"
       27        27             #include  "Lpars.h"
       28        28             #include  "assert.h"
       29        29             #include  "specials.h"   /* registration of special identifiers */
       30        30             #include  "noRoption.h"
       31        31             #include "zb_target:h"
       32        32
       33        33             int idfsize = IDFSIZE;
       34        34             extern char options[];
       35        35
       36        36             int  sp_occurred[SP_TOTAL]; /* indicate occurrence of special id */
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=2  
       37        37
       38        38             struct idf init_idf_val;
       39        39
       40        40             struct idf *idf_hashtable[HASHSIZE] = {
       41        41    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       42        42    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       43        43    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       44        44    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       45        45    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       46        46    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       47        47    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
       48        48    1         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
       49        49              /* All identifiers can in principle be reached through
       50        50                 idf_hashtable; idf_hashtable[hc] is the start of a chain of
       51        51                 idf's whose tags all hash to hc. Each idf is the start of
       52        52                 a chain of def's for that idf, sorted according to level,
       53        53                 with the most recent one on top.
       54        54                 Any identifier occurring on a level is entered into this
       55        55                 list, regardless of the nature of its declaration
       56        56                 (variable, selector, structure tag, etc.).
       57        57              */
       58        58
       59        59             struct idf *
       60        60             idf_hashed(tg, size, hc)
       61        61              char *tg;
       62        62              int size;      /* includes the '\0' character */
       63        63              int hc;
       64        64             {
       65        65    1         /* The tag tg with length size and known hash value hc is
       66        66    1            looked up in the identifier table; if not found, it is
       67        67    1            entered. A pointer to it is returned.
       68        68    1            The identifier has already been truncated to idfsize
       69        69    1            characters.
       70        70    1         */
       71        71    1         register struct idf **hook = &idf_hashtable[hc], *notch;
       72        72    1
       73        73    1         while ((notch = *hook)) {
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=3  
       74        74    2            register cmp = strcmp(tg, notch->id_text);
       75        75    2
       76        76    2            if (cmp < 0)
       77        77    2               break;
       78        78    2            else
       79        79    2            if (cmp == 0)  {
       80        80    3               /* suppose that special identifiers, as
       81        81    3                  "setjmp", are already inserted
       82        82    3               */
       83        83    3               int spec = notch->id_special;
       84        84    3               if (spec < 64)
       85        85    3                  sp_occurred[spec] = 1;
       86        86    3               return notch;
       87        87    3            }
       88        88    2            else
       89        89    2               hook = &notch->next;
       90        90    2         }
       91        91    1         /* a new struct idf must be inserted at the hook */
       92        92    1         notch = new_idf();
       93        93    1         *notch = init_idf_val;
       94        94    1         notch->next = *hook;
       95        95    1         *hook = notch;    /* hooked in */
       96        96    1         notch->id_text = Salloc(tg, (unsigned) size);
       97        97    1        #ifndef NOPP
       98        98    1         notch->id_resmac = 0;
       99        99    1        #endif NOPP
      100       100    1         return notch;
      101       101    1        }
      102       102
      103       103             #ifdef DEBUG
      104       104             hash_stat()
      105       105             {
      106       106    1         if (options['h']) {
      107       107    2            register int i;
      108       108    2
      109       109    2            print("Hash table tally:\n");
      110       110    2            for (i = 0; i < HASHSIZE; i++)   {
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=4  
      111       111    3               register struct idf *notch = idf_hashtable[i];
      112       112    3               int cnt = 0;
      113       113    3
      114       114    3               while (notch)  {
      115       115    4                  cnt++;
      116       116    4                  notch = notch->next;
      117       117    4               }
      118       118    3               print("%d %d\n", i, cnt);
      119       119    3            }
      120       120    2            print("End hash table tally\n");
      121       121    2         }
      122       122    1        }
      123       123             #endif DEBUG
      124       124
      125       125             struct idf *
      126       126             str2idf(tg)
      127       127              char tg[];
      128       128             {
      129       129    1         /* str2idf() returns an entry in the symbol table for the
      130       130    1            identifier tg.  If necessary, an entry is created.
      131       131    1            It is used where the text of the identifier is available
      132       132    1            but its hash value is not; otherwise idf_hashed() is to
      133       133    1            be used.
      134       134    1         */
      135       135    1         register char *cp = tg;
      136       136    1         register int hash;
      137       137    1         register int pos = -1;
      138       138    1         register int ch;
      139       139    1         char ntg[IDFSIZE + 1];
      140       140    1         register char *ncp = ntg;
      141       141    1
      142       142    1         hash = STARTHASH();
      143       143    1         while (++pos < idfsize && (ch = *cp++))   {
      144       144    2            *ncp++ = ch;
      145       145    2            hash = ENHASH(hash, ch, pos);
      146       146    2         }
      147       147    1         hash = STOPHASH(hash);
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=5  
      148       148    1         *ncp++ = '\0';
      149       149    1         return idf_hashed(ntg, ncp - ntg, hash);
      150       150    1        }
      151       151
      152       152             struct idf *
      153       153             gen_idf()
      154       154             {
      155       155    1         /* A new idf is created out of nowhere, to serve as an
      156       156    1            anonymous name.
      157       157    1         */
      158       158    1         static int name_cnt;
      159       159    1         char buff[100];
      160       160    1         char *sprint();
      161       161    1
      162       162    1         sprint(buff, "#%d", ++name_cnt, dot.tk_file, dot.tk_line);
      163       163    1         return str2idf(buff);
      164       164    1        }
      165       165
      166       166             int
      167       167             is_anon_idf(idf)
      168       168              struct idf *idf;
      169       169             {
      170       170    1         return idf->id_text[0] == '#';
      171       171    1        }
      172       172
      173       173             declare_idf(ds, dc, lvl)
      174       174              struct decspecs *ds;
      175       175              struct declarator *dc;
      176       176             {
      177       177    1         /* The identifier inside dc is declared on the level lvl, with
      178       178    1            properties deduced from the decspecs ds and the declarator
      179       179    1            dc.
      180       180    1            The level is given explicitly to be able to insert, e.g.,
      181       181    1            labels on the outermost level inside the function.
      182       182    1            This routine implements the rich semantics of C
      183       183    1            declarations.
      184       184    1         */
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=6  
      185       185    1         register struct idf *idf = dc->dc_idf;
      186       186    1         register int sc = ds->ds_sc;
      187       187    1         register int rsval = 0;
      188       188    1            /* This local copy is essential:
      189       189    1                  char b(), c;
      190       190    1               makes b GLOBAL and c AUTO.
      191       191    1            */
      192       192    1         register struct def *def = (sc==LABEL)? idf->id_label :idf->id_def;
      193       193    1         register struct type *type;
      194       194    1         struct stack_level *stl = stack_level_of(lvl);
      195       195    1         char formal_array = 0;
      196       196    1
      197       197    1         /* determine the present type */
      198       198    1         if (ds->ds_type == 0)   {
      199       199    2            /* at the L_FORMAL1 level there is no type specified yet
      200       200    2            */
      201       201    2            ASSERT(lvl == L_FORMAL1);
      202       202    2            type = int_type;  /* may change at L_FORMAL2 */
      203       203    2         }
      204       204    1         else  {
      205       205    2            /* combine the decspecs and the declarator into one type */
      206       206    2            type = declare_type(ds->ds_type, dc);
      207       207    2            if (type->tp_size <= (arith)0 &&
      208       208    2                actual_declaration(sc, type))   {
      209       209    3               if (type->tp_size == (arith) -1) {
      210       210    4                  /* the type is not yet known,
      211       211    4                     but it has to be:
      212       212    4                  */
      213       213    4                  extern char *symbol2str();
      214       214    4                  error("unknown %s-type",
      215       215    4                     symbol2str(type->tp_fund));
      216       216    4               }
      217       217    3               else if (type->tp_fund != LABEL) {
      218       218    4                  /* CJ */
      219       219    4                  warning("%s has size 0", idf->id_text);
      220       220    4               }
      221       221    3            }
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=7  
      222       222    2         }
      223       223    1
      224       224    1         /* some additional work for formal definitions */
      225       225    1         if (lvl == L_FORMAL2)   {
      226       226    2            switch (type->tp_fund)  {
      227       227    3            case FUNCTION:
      228       228    3               warning("%s is a pointer to a function",
      229       229    3                  idf->id_text);
      230       230    3               type = construct_type(POINTER, type, (arith)0, (struct formal*)0);
      231       231    3               break;
      232       232    3            case ARRAY: /* RM 10.1  */
      233       233    3               type = construct_type(POINTER, type->tp_up, (arith)0, (struct formal*)0
                               );
      234       234    3               formal_array = 1;
      235       235    3               break;
      236       236    3        #ifndef NOFLOAT
      237       237    3            case FLOAT: /* RM 10.1  */
      238       238    3               type = double_type;
      239       239    3               break;
      240       240    3        #endif NOFLOAT
      241       241    3            case CHAR:
      242       242    3            case SHORT:
      243       243    3               /* The RM is not clear about this: we must
      244       244    3                  convert the parameter from int (they have
      245       245    3                  been pushed as ints) to the specified type.
      246       246    3                  The conversion to type int or uint is not
      247       247    3                  allowed.
      248       248    3               */
      249       249    3               break;
      250       250    3            }
      251       251    2         }
      252       252    1         /* The tests on types, postponed from do_decspecs(), can now
      253       253    1            be performed.
      254       254    1         */
      255       255    1         /* update the storage class */
      256       256    1         if (type && type->tp_fund == FUNCTION) {
      257       257    2            if (sc == 0 || (ds->ds_sc_given && sc == AUTO)) /* RM 8.1 */
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=8  
      258       258    2               sc = GLOBAL;
      259       259    2            else
      260       260    2            if (sc == REGISTER) {
      261       261    3               error("function has illegal storage class");
      262       262    3               ds->ds_sc = sc = GLOBAL;
      263       263    3            }
      264       264    2         }
      265       265    1         else  /* non-FUNCTION */
      266       266    1            if (sc == 0)
      267       267    1               sc =  lvl == L_GLOBAL ? GLOBAL
      268       268    1                  : lvl == L_FORMAL1 || lvl == L_FORMAL2 ? FORMAL
      269       269    1                  : AUTO;
      270       270    1        #ifndef NOROPTION
      271       271    1         if (options['R']) { /* some special K & R tests */
      272       272    2            /* is it also an enum? */
      273       273    2            if (idf->id_enum && idf->id_enum->tg_level == level)
      274       274    2               warning("%s is also an enum tag", idf->id_text);
      275       275    2            /* is it a universal typedef? */
      276       276    2            if (def && def->df_level == L_UNIVERSAL)
      277       277    2               warning("redeclaring reserved word %s", idf->id_text);
      278       278    2         }
      279       279    1        #endif
      280       280    1         if (def && def->df_level >= lvl) {
      281       281    2            /* There is already a declaration for idf on this
      282       282    2               level, or even more inside.
      283       283    2               The rules differ for different levels.
      284       284    2            */
      285       285    2            switch (lvl)   {
      286       286    3            case L_GLOBAL:
      287       287    3               global_redecl(idf, sc, type, dc);
      288       288    3               break;
      289       289    3            case L_FORMAL1:   /* formal declaration */
      290       290    3               error("formal %s redeclared", idf->id_text);
      291       291    3               break;
      292       292    3            case L_FORMAL2:   /* formal definition */
      293       293    3            default: /* local */
      294       294    3               error("%s redeclared", idf->id_text);
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=9  
      295       295    3               break;
      296       296    3            }
      297       297    2         }
      298       298    1         else  /* the idf is unknown on this level */
      299       299    1         if (lvl == L_FORMAL2 && sc != ENUM && good_formal(def, idf)) {
      300       300    2            /* formal declaration, update only */
      301       301    2            def->df_type = type;
      302       302    2            def->df_formal_array = formal_array;
      303       303    2            def->df_sc = sc;
      304       304    2            def->df_level = L_FORMAL2; /* CJ */
      305       305    2            if (sc == REGISTER) def->df_register = REG_BONUS;
      306       306    2         }
      307       307    1         else
      308       308    1         if (  lvl >= L_LOCAL &&
      309       309    1            (type->tp_fund == FUNCTION || sc == EXTERN)
      310       310    1         )  {
      311       311    2            /* extern declaration inside function is treated the
      312       312    2               same way as global extern declaration
      313       313    2            */
      314       314    2        #ifndef NOROPTION
      315       315    2            if (  options['R'] &&
      316       316    2               (sc == STATIC && type->tp_fund == FUNCTION)
      317       317    2            )
      318       318    2               if (!is_anon_idf(idf))
      319       319    2                  warning("non-global static function %s",
      320       320    2                     idf->id_text);
      321       321    2        #endif
      322       322    2            if (def && def->df_level < lvl && def->df_level != L_GLOBAL) {
      323       323    3            /* Some other def exists between here and global level */
      324       324    3               struct def *vdef, *ndef, *make_new_def();
      325       325    3               while (def && def->df_level > L_GLOBAL)
      326       326    3                 def = def->next;   /* locate global def */
      327       327    3               if (!def)   {  /* there's no global version! */
      328       328    4                  def = make_new_def(idf, idf->id_def, L_GLOBAL, type, sc);
      329       329    4                  vdef = idf->id_def = def->next; /* shuffle GLOBAL def */
      330       330    4                  while (vdef->next && vdef->next->df_level > L_GLOBAL)
      331       331    4                     vdef = vdef->next;
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=10 
      332       332    4                  def->next = vdef->next;
      333       333    4                  vdef->next = def;
      334       334    4                  }
      335       335    3               else {
      336       336    4                  global_redecl(idf, sc, type, dc);
      337       337    4                  }
      338       338    3               vdef = make_new_def(idf, idf->id_def, lvl, def->df_type, sc);
      339       339    3               ndef = vdef->next;
      340       340    3               *vdef = *def;
      341       341    3               vdef->df_level = lvl;
      342       342    3               vdef->next = ndef;
      343       343    3               }
      344       344    2            else declare_idf(ds, dc, L_GLOBAL);
      345       345    2         }
      346       346    1         else  { /* fill in the def block */
      347       347    2            struct def *make_new_def();
      348       348    2            register struct def *newdef = make_new_def(idf, def, lvl, type, sc);
      349       349    2            /* We now calculate the address.
      350       350    2               Globals have names and don't get addresses, they
      351       351    2               get numbers instead (through data_label()).
      352       352    2               Formals are handled by declare_formals().
      353       353    2               So here we hand out local addresses only.
      354       354    2            */
      355       355    2            if (lvl >= L_LOCAL)  {
      356       356    3               ASSERT(sc);
      357       357    3               switch (sc) {
      358       358    4               case REGISTER:
      359       359    4               case AUTO:
      360       360    4                  if (type->tp_size == (arith)-1) {
      361       361    5                     if (type->tp_fund != ARRAY)
      362       362    5                        error("size of local %s unknown", idf->id_text);
      363       363    5                     else rsval = 1;
      364       364    5                  }
      365       365    4                  newdef->df_register = (sc == REGISTER) ? REG_BONUS : REG_DEFAULT;
      366       366    4                  if (!rsval)
      367       367    4                  newdef->df_address = stl->sl_local_offset =
      368       368    4                     -align(-stl->sl_local_offset + type->tp_size, type->tp_align);
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=11 
      369       369    4                  if (stl->sl_local_offset < stl->sl_max_block)
      370       370    4                     stl->sl_max_block = stl->sl_local_offset;
      371       371    4                  break;
      372       372    4               case STATIC:
      373       373    4                  newdef->df_address = (arith) data_label();
      374       374    4                  break;
      375       375    4               }
      376       376    3            }
      377       377    2         }
      378       378    1         return rsval;
      379       379    1        }
      380       380
      381       381              struct def *
      382       382             make_new_def(idf, def, lvl, tp, sc)
      383       383              register struct idf *idf;
      384       384              register struct def *def;
      385       385              register int lvl;
      386       386              register struct type *tp;
      387       387              register int sc;
      388       388             {
      389       389    1          register struct def *newdef = new_def();
      390       390    1          newdef->next = def;
      391       391    1          newdef->df_level = lvl;
      392       392    1          newdef->df_type = tp;
      393       393    1          newdef->df_sc = sc;
      394       394    1          newdef->df_schema = 0;
      395       395    1          newdef->df_file   = dot.tk_file;
      396       396    1          newdef->df_line   = dot.tk_line;
      397       397    1          newdef->df_debline = dot.tok_debline;
      398       398    1          if (finfo.StartLine != 0)
      399       399    1             newdef->df_debline = 0;
      400       400    1          if (lvl == L_FORMAL1) /* CJ */
      401       401    1             newdef->df_register = REG_DEFAULT;
      402       402    1          if (sc == LABEL) idf->id_label = newdef;
      403       403    1          else idf->id_def = newdef;
      404       404    1          update_ahead(idf);
      405       405    1          stack_idf(idf, stack_level_of(lvl));
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=12 
      406       406    1          return newdef;
      407       407    1        }
      408       408
      409       409             actual_declaration(sc, tp)
      410       410              int sc;
      411       411              struct type *tp;
      412       412             {
      413       413    1         /* An actual_declaration needs space, right here and now.
      414       414    1         */
      415       415    1         register int fund = tp->tp_fund;
      416       416    1
      417       417    1         if (sc == ENUM || sc == TYPEDEF) /* virtual declarations */
      418       418    1            return 0;
      419       419    1         if (fund == FUNCTION || fund == ARRAY)
      420       420    1            /* allocation solved in other ways */
      421       421    1            return 0;
      422       422    1         /* to be allocated */
      423       423    1         return 1;
      424       424    1        }
      425       425
      426       426             global_redecl(idf, new_sc, tp, dc)
      427       427              register struct idf *idf;
"zbc$idf:c.:ZBC3TSI", line 427: (warning) identifier "dc" is not used
      428       428              register struct type *tp;
      429       429              register struct declarator *dc;
      430       430             {
      431       431    1         /* A global identifier may be declared several times,
      432       432    1            provided the declarations do not conflict; they might
      433       433    1            conflict in type (or supplement each other in the case of
      434       434    1            an array) or they might conflict or supplement each other
      435       435    1            in storage class.
      436       436    1         */
      437       437    1         register struct def *def = idf->id_def;
      438       438    1         register struct def *vdef = def;
      439       439    1
      440       440    1         while (def && def->df_level > L_GLOBAL)
      441       441    1          def = def->next;
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=13 
      442       442    1
      443       443    1         if (!def) {
      444       444    2           error("redeclaration of %s with different type", idf->id_text);
      445       445    2           return;
      446       446    2           }
      447       447    1
      448       448    1         if (tp != def->df_type) {
      449       449    2            register struct type *otp = def->df_type;
      450       450    2            if (  tp->tp_fund != otp->tp_fund || (tp->tp_fund != FUNCTION &&
      451       451    2                 (tp->tp_fund != ARRAY        || tp->tp_up != otp->tp_up) )
      452       452    2            )  {
      453       453    3               error("redeclaration of %s with different type",
      454       454    3                  idf->id_text);
      455       455    3               return;
      456       456    3            }
      457       457    2            /* Multiple array declaration; this may be interesting */
      458       458    2            if (tp->tp_fund == FUNCTION)
      459       459    2               function_redecl(def, tp, otp, idf);
      460       460    2            else if (tp->tp_size < 0)  {  /* new decl has [] */
      461       461    3               /* nothing new */
      462       462    3            }
      463       463    2            else
      464       464    2            if (otp->tp_size < 0)   {  /* old decl has [] */
      465       465    3               def->df_type = tp;
      466       466    3            }
      467       467    2            else
      468       468    2            if (tp->tp_size != otp->tp_size)
      469       469    2               error("inconsistent size in redeclaration of array %s",
      470       470    2                  idf->id_text);
      471       471    2         }
      472       472    1         /* Now we may be able to update the storage class.
      473       473    1            Clean out this mess as soon as we know all the possibilities
      474       474    1            for new_sc.
      475       475    1            For now we have:
      476       476    1               EXTERN:     we have seen the word "extern"
      477       477    1               GLOBAL:     the item was declared on the outer
      478       478    1                     level, without either "extern" or
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=14 
      479       479    1                     "static".
      480       480    1               STATIC:     we have seen the word "static"
      481       481    1               IMPLICIT:   function declaration inferred from
      482       482    1                     call
      483       483    1         */
      484       484    1         if (new_sc != IMPLICIT)   {   /* New Information */
      485       485    2         switch (def->df_sc)  {  /* the old storage class */
      486       486    3         case EXTERN:
      487       487    3            switch (new_sc)   {  /* the new storage class */
      488       488    4            case EXTERN:
      489       489    4            case GLOBAL:
      490       490    4               break;
      491       491    4            case STATIC:
      492       492    4               if (def->df_initialized || vdef != def)   {
      493       493    5                  error("cannot redeclare %s to static", idf->id_text);
      494       494    5               }
      495       495    4               else  {
      496       496    5                  warning("%s redeclared to static", idf->id_text);
      497       497    5               }
      498       498    4               def->df_sc = new_sc;
      499       499    4               break;
      500       500    4            default:
      501       501    4               if (new_sc != ERRONEOUS && new_sc != FORMAL)
      502       502    4                  crash("bad storage class");
      503       503    4               return;
      504       504    4            }
      505       505    3            break;
      506       506    3         case GLOBAL:
      507       507    3            switch (new_sc)   {  /* the new storage class */
      508       508    4            case EXTERN:
      509       509    4               break;
      510       510    4            case GLOBAL:
      511       511    4               break;
      512       512    4            case STATIC:
      513       513    4               if (def->df_initialized || vdef != def)
      514       514    4                  error("cannot redeclare %s to static", idf->id_text);
      515       515    4               else  {
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=15 
      516       516    5        #ifndef NOROPTION
      517       517    5                  if (options['R'])
      518       518    5                     warning("%s redeclared to static",
      519       519    5                        idf->id_text);
      520       520    5        #endif
      521       521    5                  def->df_sc = STATIC;
      522       522    5               }
      523       523    4               break;
      524       524    4            default:
      525       525    4               if (new_sc != ERRONEOUS && new_sc != FORMAL)
      526       526    4                  crash("bad storage class");
      527       527    4               return;
      528       528    4            }
      529       529    3            break;
      530       530    3         case STATIC:
      531       531    3            switch (new_sc)   {  /* the new storage class */
      532       532    4            case EXTERN:
      533       533    4               if (def->df_initialized)
      534       534    4                  warning("cannot redeclare %s to extern", idf->id_text);
      535       535    4               else  {
      536       536    5                  warning("%s cannot be redeclared extern", idf->id_text);
      537       537    5                  /* def->df_sc = EXTERN;   */
      538       538    5               }
      539       539    4               break;
      540       540    4            case GLOBAL:
      541       541    4            case STATIC:
      542       542    4               if (def->df_type->tp_fund != FUNCTION)
      543       543    4                  warning("%s was already static",
      544       544    4                     idf->id_text);
      545       545    4               break;
      546       546    4            default:
      547       547    4               if (new_sc != ERRONEOUS && new_sc != FORMAL)
      548       548    4                  crash("bad storage class");
      549       549    4               return;
      550       550    4            }
      551       551    3            break;
      552       552    3         case IMPLICIT:
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=16 
      553       553    3            switch (new_sc)   {  /* the new storage class */
      554       554    4            case EXTERN:
      555       555    4            case GLOBAL:
      556       556    4               def->df_sc = new_sc;
      557       557    4               break;
      558       558    4            case STATIC:
      559       559    4        #ifndef NOROPTION
      560       560    4               if (options['R'])
      561       561    4                  warning("%s was implicitly declared as extern",
      562       562    4                     idf->id_text);
      563       563    4        #endif
      564       564    4               def->df_sc = new_sc;
      565       565    4               break;
      566       566    4            default:
      567       567    4               if (new_sc != ERRONEOUS && new_sc != FORMAL)
      568       568    4                  crash("bad storage class");
      569       569    4               return;
      570       570    4            }
      571       571    3            break;
      572       572    3         case ENUM:
      573       573    3         case TYPEDEF:
      574       574    3            error("illegal redeclaration of %s", idf->id_text);
      575       575    3            break;
      576       576    3         default:
      577       577    3               if (new_sc != ERRONEOUS && new_sc != FORMAL)
      578       578    3                  crash("bad storage class");
      579       579    3               return;
      580       580    3         }
      581       581    2         }
      582       582    1
      583       583    1        /* Finally update shadow defs of this global (if any)   */
      584       584    1          if (vdef != def) {   /* shadow defs may exist */
      585       585    2             do {
      586       586    3                if (vdef->df_sc == EXTERN || vdef->df_sc == GLOBAL)
      587       587    3                   if (vdef != def)  {
      588       588    4                      struct def *ndef = vdef->next;
      589       589    4                      int vlvl = vdef->df_level;
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=17 
      590       590    4                      *vdef = *def;
      591       591    4                      vdef->next = ndef;
      592       592    4                      vdef->df_level = vlvl;
      593       593    4                      }
      594       594    3                vdef = vdef->next;
      595       595    3                } while (vdef);
      596       596    2             }
      597       597    1        }
      598       598
      599       599
      600       600             function_redecl(def, tp, otp, idf)
      601       601               struct def *def;
      602       602               struct type *tp;
      603       603               struct type *otp;
      604       604               struct idf *idf;
      605       605             {
      606       606    1          struct formallist *ofl = otp->tp_formal;
      607       607    1          struct formallist *nfl =  tp->tp_formal;
      608       608    1
      609       609    1           if (def->df_used && nfl && !ofl)
      610       610    1              warning("function %s called before prototype definition", idf->id_text);

      611       611    1          if ((ofl && !nfl) || (!ofl && nfl)) {
      612       612    2             /* prototype on one, none on the other!   */
      613       613    2             struct formallist *fl = (nfl) ? nfl : ofl;
      614       614    2             int               fmn = fl->fl_num;
      615       615    2             int               fn;
      616       616    2
      617       617    2             for (fn = 0 ; fn < fmn ; ) {
      618       618    3                struct type *t = fl->fl_type[fn++];
      619       619    3                int       fund = t->tp_fund;
      620       620    3                switch (fund)  {
      621       621    4                case SHORT:
      622       622    4                case CHAR:
      623       623    4                case FLOAT:
      624       624    4                   warning("function %s parameter %d type not compatible with default
                               promotions", idf->id_text, fn);
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=18 
      625       625    4                   break;
      626       626    4                }
      627       627    3                }  /* end of for loop */
      628       628    2             if (fl->fl_elips)
      629       629    2                warning("function %s declared with and without elipsis", idf->id_text)
                               ;
      630       630    2             tp = (nfl) ? tp : otp;
      631       631    2             }
      632       632    1          else tp = compose_types(tp, otp);
      633       633    1          if (!tp) return;
      634       634    1          def->df_type = tp;
      635       635    1          return;
      636       636    1        }
      637       637
      638       638
      639       639             int
      640       640             good_formal(def, idf)
      641       641              register struct def *def;
      642       642              register struct idf *idf;
      643       643             {
      644       644    1         /* Succeeds if def is a proper L_FORMAL1 definition and
      645       645    1            gives an error message otherwise.
      646       646    1         */
      647       647    1         if (!def || def->df_level != L_FORMAL1)   { /* not in parameter list */
      648       648    2            if (!is_anon_idf(idf))
      649       649    2               error("%s not in parameter list", idf->id_text);
      650       650    2            return 0;
      651       651    2         }
      652       652    1         ASSERT(def->df_sc == FORMAL); /* CJ */
      653       653    1         return 1;
      654       654    1        }
      655       655
      656       656             declare_params(dc)
      657       657              register struct declarator *dc;
      658       658             {
      659       659    1         /* Declares the formal parameters if they exist.
      660       660    1         */
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=19 
      661       661    1         register struct formal *fm = dc->dc_formal;
      662       662    1
      663       663    1         if (fm && (fm->fm_type != void_type || fm->fm_idf || fm->next))
      664       664    1            while (fm)  {
      665       665    2               register struct type *tp = fm->fm_type;
      666       666    2               if (!fm->fm_idf)
      667       667    2                  error("Parameter name missing from function prototype!");
      668       668    2               else declare_parameter(fm->fm_idf, (tp) ? tp : int_type, (tp==0));
      669       669    2               fm = fm->next;
      670       670    2            }
      671       671    1            if (dc->dc_formal && !dc->dc_formal->fm_type)  {
      672       672    2               free_formals(dc->dc_formal);
      673       673    2               dc->dc_formal = 0;
      674       674    2            }
      675       675    1        }
      676       676
      677       677             init_idf(idf)
      678       678              register struct idf *idf;
      679       679             {
      680       680    1         /* The topmost definition of idf is set to initialized.
      681       681    1         */
      682       682    1         register struct def *def = idf->id_def;   /* the topmost */
      683       683    1
      684       684    1         if (def->df_initialized)
      685       685    1            error("multiple initialization of %s", idf->id_text);
      686       686    1         if (def->df_sc == TYPEDEF) {
      687       687    2            warning("typedef cannot be initialized");
      688       688    2            def->df_sc = EXTERN;    /* ??? *//* What else ? */
      689       689    2         }
      690       690    1         def->df_initialized = 1;
      691       691    1        }
      692       692
      693       693             declare_parameter(idf, fm_type)
      694       694             struct type *fm_type;
      695       695              struct idf *idf;
      696       696             {
      697       697    1         /* idf is declared as a formal.
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=20 
      698       698    1         */
      699       699    1         add_def(idf, FORMAL, fm_type, L_FORMAL1);
      700       700    1        }
      701       701
      702       702             declare_enum(tp, idf, l)
      703       703              struct type *tp;
      704       704              struct idf *idf;
      705       705              arith l;
      706       706             {
      707       707    1         /* idf is declared as an enum constant with value l.
      708       708    1         */
      709       709    1         add_def(idf, ENUM, tp, level);
      710       710    1         idf->id_def->df_address = l;
      711       711    1        }
      712       712
      713       713             declare_formals(fp, dc)
      714       714              arith *fp;
      715       715              struct declarator *dc;
      716       716             {
      717       717    1         /* Declares those formals as int that haven't been declared
      718       718    1            by the user.
      719       719    1            An address is assigned to each formal parameter.
      720       720    1            The total size of the formals is returned in *fp;
      721       721    1         */
      722       722    1         register struct stack_entry *se = stack_level_of(L_FORMAL1)->sl_entry;
      723       723    1         arith f_offset = (zb_target_sys==TARGET_CP6) ? (arith)16 : (arith)0;
      724       724    1         struct formal *fm = dc->dc_formal;
      725       725    1         struct formallist *fml = dc->dc_idf->id_def->df_type->tp_formal;
      726       726    1         int chk_proto = (!fm && fml) ? 1 : 0;
      727       727    1         int fmx = (fml) ? fml->fl_num : 0;
      728       728    1         int fmn = 0;
      729       729    1         int cvt = !fm || !fm->fm_type;
"zbc$idf:c.:ZBC3TSI", line 729: (warning) identifier "cvt" is not used
      730       730    1
      731       731    1        #ifdef DEBUG
      732       732    1         if (options['t'])
      733       733    1            dumpidftab("start declare_formals", 0);
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=21 
      734       734    1        #endif DEBUG
      735       735    1         while (se)  {
      736       736    2            register struct def *def = se->se_idf->id_def;
      737       737    2            register struct type *tp = def->df_type;
      738       738    2            register arith al = (tp->tp_align <= word_size) ? word_size : dword_size;
      739       739    2
      740       740    2            if (zb_target_sys == TARGET_CP6)
      741       741    2                 def->df_address = f_offset = align(f_offset,al);
      742       742    2            else def->df_address = f_offset;
      743       743    2            /* the alignment convention for parameters is: align on
      744       744    2               word boundaries, i.e. take care that the following
      745       745    2               parameter starts on a new word boundary.
      746       746    2            */
      747       747    2            f_offset = align(f_offset + def->df_type->tp_size, (int) word_size);
      748       748    2              if (!fml)
      749       749    2                 formal_cvt(def); /* cvt int to char or short, if necessary */
      750       750    2        /*   At this point, we should check to see if the function
      751       751    2             was declared previously with a prototype and if this
      752       752    2             declaration with without a prototype.  In this case,
      753       753    2             an error should occur if any declaration produces a
      754       754    2             non-default type (i.e. char, short or float arg).
      755       755    2        */
      756       756    2            if (chk_proto)  {
      757       757    3               if (fmn < fmx)    {   /* More prototype args? */
      758       758    4                  struct type *ftp = fml->fl_type[fmn++];
      759       759    4                  int         fund = tp->tp_fund;
      760       760    4                  switch (ftp->tp_fund) {
      761       761    5                  case SHORT:
      762       762    5                  case CHAR:
      763       763    5                     if (fund == ftp->tp_fund)
      764       764    5                        break;
      765       765    5                     goto proto_err;
      766       766    5                  case INT:
      767       767    5                  case ENUM:
      768       768    5                     if (fund==INT || fund==CHAR || fund==SHORT || fund==ENUM) {
      769       769    6                        formal_cvt(def);
      770       770    6                        break;
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=22 
      771       771    6                        }
      772       772    5                  case STRUCT:
      773       773    5                  case UNION:
      774       774    5                  case FLOAT:
      775       775    5                  case LONG:
      776       776    5                  case DOUBLE:
      777       777    5                     if (unqualified_type_of(ftp) != unqualified_type_of(tp) || fund==
                               FLOAT) {
      778       778    6        proto_err:
      779       779    6                        error("Prototype type not compatible with promoted defintion t
                               ype");
      780       780    6                        chk_proto = 0;
      781       781    6                        }   /* of if (unqalified_type_of(ftp)!=...    */
      782       782    5                  }         /* of switch(ftp->tp_fund)                */
      783       783    4               }            /* of if (fmn < fmx)                      */
      784       784    3            else if (!fml->fl_elips) {
      785       785    4               chk_proto = 0;
      786       786    4               error("Function definition has more parameters than prototype");
      787       787    4               }
      788       788    3            else formal_cvt(def);
      789       789    3            }    /* of if (chk_proto)    */
      790       790    2
      791       791    2            se = se->next;
      792       792    2            def->df_level = L_FORMAL2; /* CJ */
      793       793    2         }
      794       794    1         *fp = f_offset;
      795       795    1         if (zb_target_sys == TARGET_CP6)  {
      796       796    2           struct def *def;
      797       797    2           struct idf *idf = str2idf("__varyarg_ptr");
      798       798    2           add_def(idf,FORMAL,string_type,L_FORMAL1);
      799       799    2           def = idf->id_def;
      800       800    2           def->df_level = L_FORMAL2;
      801       801    2           def->df_address = 12;
      802       802    2           def->df_debline = 0;
      803       803    2           def->df_register = REG_NONE;  /* ego doesn't like mes 3 about non-parm */
      804       804    2         }
      805       805    1        }
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=23 
      806       806
      807       807             add_def(idf, sc, tp, lvl)
      808       808              struct idf *idf;
      809       809              struct type *tp;
      810       810              int lvl;
      811       811              int sc;
      812       812             {
      813       813    1         /* The identifier idf is declared on level lvl with storage
      814       814    1            class sc and type tp, through a faked C declaration.
      815       815    1            This is probably the wrong way to structure the problem,
      816       816    1            but it will have to do for the time being.
      817       817    1         */
      818       818    1         struct decspecs Ds; struct declarator Dc;
      819       819    1
      820       820    1         Ds = null_decspecs;
      821       821    1         Ds.ds_type = tp;
      822       822    1         Ds.ds_sc = sc;
      823       823    1         Dc = null_declarator;
      824       824    1         Dc.dc_idf = idf;
      825       825    1         declare_idf(&Ds, &Dc, lvl);
      826       826    1        }
      827       827
      828       828             update_ahead(idf)
      829       829              register struct idf *idf;
      830       830             {
      831       831    1         /* The tk_symb of the token ahead is updated in the light of new
      832       832    1            information about the identifier idf.
      833       833    1         */
      834       834    1         register int tk_symb = AHEAD;
      835       835    1
      836       836    1         if (  (tk_symb == IDENTIFIER || tk_symb == TYPE_IDENTIFIER) &&
      837       837    1            ahead.tk_idf == idf
      838       838    1         )
      839       839    1            AHEAD = idf->id_def && idf->id_def->df_sc == TYPEDEF ?
      840       840    1                  TYPE_IDENTIFIER : IDENTIFIER;
      841       841    1        }
      842       842
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=24 
      843       843             free_formals(fm)
      844       844              register struct formal *fm;
      845       845             {
      846       846    1         while (fm)  {
      847       847    2            struct formal *tmp = fm->next;
      848       848    2
      849       849    2            free_formal(fm);
      850       850    2            fm = tmp;
      851       851    2         }
      852       852    1        }
      853       853
      854       854             char hmask[IDFSIZE];
      855       855
      856       856             init_hmask()
      857       857             {
      858       858    1         /* A simple congruence random number generator, as
      859       859    1            described in Knuth, vol 2.
      860       860    1         */
      861       861    1         register int h, rnd = HASH_X;
      862       862    1
      863       863    1         for (h = 0; h < IDFSIZE; h++) {
      864       864    2            hmask[h] = rnd;
      865       865    2            rnd = (HASH_A * rnd + HASH_C) & HASHMASK;
      866       866    2         }
      867       867    1        }
      868       868
---  Include file information  ---

   zbc$nofloat:h.:ZBC3TOU. is referenced
   zbc$debug:h.:ZBC3TOU. is referenced
   zbc$idfsize:h.:ZBC3TOU. is referenced
   zbc$botch_free:h.:ZBC3TOU. is referenced
   zbc$nopp:h.:ZBC3TOU. is referenced
   alloc:h.:ZBC3TOU. is referenced
   zbc$arith:h.:ZBC3TOU. is referenced
   zbc$spec_arith:h.:ZBC3TOU. is referenced
   em_arith:h.:ZBC3TOU. is referenced
CC.C03    File=zbc$idf:c.:ZBC3TSI                                                   Fri Aug 22 1997  Page=25 
   zbc$align:h.:ZBC3TOU. is referenced
   zbc$nocross:h.:ZBC3TOU. is referenced
   zbc$target_sizes:h.:ZBC3TOU. is referenced
   zbc$LLlex:h.:ZBC3TOU. is referenced
   zbc$file_info:h.:ZBC3TOU. is referenced
   zbc$level:h.:ZBC3TOU. is referenced
   zbc$stack:h.:ZBC3TOU. is referenced
   zbc$idf:h.:ZBC3TOU. is referenced
   zbc$label:h.:ZBC3TOU. is referenced
   em_label:h.:ZBC3TOU. is referenced
   zbc$def:h.:ZBC3TOU. is referenced
   zbc$type:h.:ZBC3TOU. is referenced
   zbc$nobitfield:h.:ZBC3TOU. is referenced
   zbc$struct:h.:ZBC3TOU. is referenced
   zbc$declar:h.:ZBC3TOU. is referenced
   zbc$decspecs:h.:ZBC3TOU. is referenced
   zbc$sizes:h.:ZBC3TOU. is referenced
   zbc$Lpars:h.:ZBC3TOU. is referenced
   zbc$assert:h.:ZBC3TOU. is referenced
   zbc$specials:h.:ZBC3TOU. is referenced
   zbc$noRoption:h.:ZBC3TOU. is referenced
   zbc$zb_target:h.:ZBC3TOU. is referenced

2 warnings were detected in the file zbc$idf:c.:ZBC3TSI
