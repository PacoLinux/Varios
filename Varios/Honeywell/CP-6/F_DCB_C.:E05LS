

07:12 JUL 29 '97 F_DCB_C.:E05SI                                            1    
    1      /*M* F_DCB_C File Management M$DCB MACRO - Master file. */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* MEC,MOC,EXM=20,CLM=30,CRM=78               */
    8      /* TABS 7,9,11,21,77   (21 is EXM plus 1, 77 is CRM less 1.)                */
    9                          /*F* NAME: File_Management Services
   10
   11
   12                          ..::L1 "Introduction to File Management\\X"
   13
   14                          All I/O operations are performed by the
   15                          monitor for the user.  The user program never
   16                          directly accesses an I/O device, but rather
   17                          requests that the monitor do so.  This section
   18                          describes I/O and the I/O services provided by the
   19                          monitor and briefly describes related file
   20                          management concepts.  However, for a comprehensive
   21                          discussion of I/O management, refer to the CP-6
   22                          Programmer Reference Manual which presents file
   23                          formats, file access, file storage and allocation,
   24                          and pertinent IBEX commands.
   25
   26                          To request I/O, the user calls an I/O service
   27                          specifying a Function Parameter Table(FPT), which
   28                          in turn refers to a Data Control Block(DCB).  The
   29                          combination of the I/O service call, the FPT, and
   30                          the DCB provides the information that the monitor
   31                          needs to perform the requested operation.
   32                          Generally, the DCB contains the attributes of a
   33                          file or device.  For example, for output to a line
   34                          printer, the width of a printline is one value in
   35                          the DCB.  The FPT contains information that is
   36                          specific to the operation to be performed (e.g.,
   37                          the location of the buffer that is to be output to
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            2    
   38                          the printer in this specific operation).
   39
   40                          Separation of information into the DCB and the FPT
   41                          allows the user to create one DCB for a destination
   42                          and reference that DCB throughout his program,
   43                          whenever I/O for that destination is required.
   44
   45                          In addition to serving as a source of
   46                          information for the monitor in performing an I/O
   47                          operation, the DCB also provides a place for the
   48                          monitor to store information while it is
   49                          performing an I/O operation.  Some of the
   50                          information stored in the DCB by the monitor may
   51                          be of use to the user, and some has meaning
   52                          only to the monitor.
   53
   54                          The user is responsible for providing the name
   55                          of a properly initialized DCB with every call to
   56                          the monitor requesting an I/O operation. The user
   57                          may obtain a DCB by
   58
   59                          1.  Explicitly creating his own DCB at program
   60                          compilation time by invoking the M$DCB macro.
   61
   62                          2.  Specifying the DCB data type without a structure
   63                          to cause the linker to create a DCB.
   64
   65                          3.  Explicitly requesting creation of a DCB at run
   66                          time by calling the M$GETDCB monitor service.
   67
   68                          Monitor calls are provided to permit the user to
   69                          initialize or alter DCBs.
   70
   71                                                                             */
   72                                    /************************************/
   73                                    /* M$DCB -  DATA CONTROL BLOCK MACRO          */
   74                                    /************************************/
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            3    
   75                                    /**/
   76      %MACRO M$DCB  (DCBN=DCBNAME,
   77                STCLASS=DCB,
   78               EXIST(ERROR=1,OLDFILE=2,NEWFILE=3)=3,
   79                CTG(YES='1'B,NO='0'B)='0'B,
   80               SHARE(ALL=1,NONE=3,IN=2)=0,
   81                COMP(YES='1'B,NO='0'B)='0'B,
   82               ASN(FILE=1,TAPE=2,DEVICE=3,COMGROUP=4,FPAP=9)=3,
   83                TYPE=' ',
   84                RES='ME',
   85               DISP(SCRATCH=1,NAMED=2)=0,
   86               FUN(UPDATE=1,IN=2,CREATE=3)=0,
   87               ORG(CONSEC=1,KEYED=2,RANDOM=3,UR=4,RELATIVE=5,
   88                    INDEXED=6,IDS=7,TERMINAL=8,SYMB=9,FPRG=10,CG=11,
   89                    HANDLER=12,IREL=13,
   90                    FIXED=15,VARIABLE=16,UNDEF=17,RESTRICT=18,FREE=19,
   91                    DBGDCB=20,DBGCG=21,DBGSYSID=22,SE=23,X364=24,FORM=25)=0,
   92              BLOCKED(YES='1'B,NO='0'B)='1'B,
   93               SPANNED(YES='1'B,NO='0'B)='1'B,
   94              ACS(SEQUEN=1,DIRECT=2,BLOCK=3,JRNL=4,UBLOCK=12,
   95                  DS2=5,DS3=6,DS4=7,DS5=8,DS6=9,DS7=10,DS8=11)=0,
   96               LSTAOR(YES='1'B,NO='0'B)='0'B,
   97                KEYX=0,
   98                KEYL=0,
   99               LSLIDE=510,
  100               LRDL0=3,
  101               SPARE=1,
  102                BLKL=0,
  103                RECL=0,
  104               IXTNSIZE=2,
  105               XTNSIZE=2,
  106                NRECS=0,
  107                VOL=0,
  108                MAXVOL=0,
  109              AU(YES='1'B,NO='0'B)='0'B,
  110              QISS(YES='1'B,NO='0'B)='0'B,
  111              LOAD(YES='1'B,NO='0'B)='0'B,
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            4    
  112              IOERROK(YES='1'B,NO='0'B)='0'B,
  113              IGNOREFSN(YES='1'B,NO='0'B)='0'B,
  114            JRNLBYPASS(YES='1'B,NO='0'B)='0'B,
  115            GHSTACS(JRNLOPN=2,NONE=3,ANY)=0,
  116            ANSISPANSEQ(YES='1'B,NO='0'B)='1'B,
  117                XTEND(YES='1'B,NO='0'B)='0'B,
  118                CNVRT(YES='1'B,NO='0'B)='1'B,
  119                CVOL(YES='1'B,NO='0'B)='0'B,
  120                CHAIN=0,
  121                EXPIRE(NEVER=-1,ANY)=0,
  122                EBCDIC(YES='1'B,NO='0'B)='0'B,
  123                DENSITY(D800=2,D1600=3,D6250=4,D38000=5)=0,
  124                VOLACCESS(ALL=1,IN=2,NONE=3)=0,
  125                DVFC="BINASC(0)",
  126                SEQCOL=73,
  127                SEQ(YES='1'B,NO='0'B)='0'B,
  128                SEQID=' ',
  129                LINES=0,
  130                NAME=' ',
  131                ACCT=' ',
  132                PASS=' ',
  133                PSN=' ',
  134                WSN=' ',
  135               BUPM(YES='1'B,NO='0'B)='01'B,
  136             FSN=0,
  137                 KEYTYPE(FLDID=1,COORD=2) = 0,
  138                SEED='0'B,
  139                ATTR='0'B,
  140                UOPT0(YES='1'B,NO='0'B)='0'B,
  141                UOPT1(YES='1'B,NO='0'B)='0'B,
  142                UOPT2(YES='1'B,NO='0'B)='0'B,
  143                UOPT3(YES='1'B,NO='0'B)='0'B,
  144                UOPT4(YES='1'B,NO='0'B)='0'B,
  145                UOPT5(YES='1'B,NO='0'B)='0'B,
  146                UOPT6(YES='1'B,NO='0'B)='0'B,
  147                UOPT7(YES='1'B,NO='0'B)='0'B,
  148                UOPT8(YES='1'B,NO='0'B)='0'B);
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            5    
  149                                    /**/
  150
  151                          /*F* NAME: DCB Manipulation
  152
  153                          If the user program is written in COBOL or
  154                          FORTRAN, or most other higher level languages,
  155                          the compiler includes in the object unit
  156                          all necessary I/O service calls and supplies
  157                          initialized DCBs or DCB references to be satisfied
  158                          by the linker.  However, if the user program is
  159                          written in PL-6, the user must provide all I/O
  160                          calls and generate DCBs explicitly:
  161                          by invocation of the M$DCB macro, by specifying
  162                          the DCB storage class attribute, or by
  163                          calling the M$GETDCB monitor service at run time.
  164
  165                          The DCB contents can be set or modified in
  166                          various ways.  The sources of values for the DCB
  167                          and the order in which they are entered
  168                          into the DCB
  169                          are as follows:
  170
  171                            o  Default parameters supplied in the M$DCB
  172                               macro or the default values supplied by
  173                               the linker or the M$GETDCB service.
  174
  175                            o  Parameters supplied at invocation of the
  176                               M$DCB macro.
  177
  178                            o  An assign/merge record is entered into a DCB
  179                               at program invocation (as a result of a SET
  180                               command) or at M$GETDCB (if MERGE is
  181                               specified).
  182
  183                            o  Parameters in the FPT for the M$OPEN
  184                               monitor service.
  185
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            6    
  186                          The DCBs reside in the Read-Only segment which
  187                          cannot be modified directly by the user program.
  188                          The monitor services and the techniques mentioned
  189                          above are the only means for a user to modify a
  190                          DCB.
  191
  192                          When a DCB is opened in the INPUT or UPDATE mode, the
  193                          attributes of the disk or tape file or
  194                          device are returned to the user in the DCB
  195                          by the monitor.  The fields in the DCB may be inspected
  196                          by the user through a based structure of a DCB.  The
  197                          F$DCB macro in the file CP_6 provides such a structure.
  198                          ..::IX "F$DCB"
  199                          ..::IX "DCB, F$DCB"
  200
  201                          The user refers to a DCB by a name for most
  202                          monitor service calls.  The monitor, however,
  203                          assigns a number to the DCB for internal use.
  204                          DCBs defined by the user are assigned numbers
  205                          starting at DCB number 10.  All DCBs for a job are
  206                          included in a DCB pointer table created by the
  207                          system. (DCBs 1 to 9 are reserved for the monitor.)
  208
  209                          A number of DCB names are associated with common
  210                          I/O functions: M$LO for listing output, M$SI for input,
  211                          F$101, etc.  The system supplies initial values
  212                          for the DCB, if the user does not supply values.
  213                          For DCBs with the reserved names listed in
  214                          Table 3-1, appropriate values are supplied for the
  215                          function(FUN) and device name(RES) parameters; but only
  216                          when 1) the DCB is supplied by the linker or M$GETDCB
  217                          or 2) the DCB is "scrubbed" via M$OPEN.
  218                          The standard defaults for FUN and RES are used
  219                          whenever the M$DCB macro is invoked.
  220
  221                          Many DCB parameters may be set by the user during
  222                          macro invocation.  In the descriptions which
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            7    
  223                          follow, these are listed first.  The names
  224                          indicated are those of the macro parameters.  If
  225                          it is desirable to inspect such a value at run
  226                          time, please reference the description of the DCB
  227                          structure in volume II of this manual to obtain
  228                          the exact field name required.  There are
  229                          additional fields in the DCB which are always set
  230                          by the monitor.  For notational purposes only,
  231                          they are sorted to follow parameters set by the
  232                          user and are flagged for your attention by an
  233                          embedded period.  Since these fields cannot be set
  234                          by the user during macro invocation, they have no
  235                          corresponding macro parameter names.  Therefore,
  236                          the indicated names are those of the field names
  237                          in the DCB structure.
  238
  239                          The following discussion describes the M$DCB
  240                          macro and monitor services that permit DCB
  241                          manipulation:  getting and releasing DCBs
  242                          dynamically (M$GETDCB, M$RELDCB), checking for
  243                          correspondence of two DCBs to the same file or
  244                          device (M$CORRES), and supplying a file management account
  245                          which is the default if the user omits the account
  246                          on opening the DCB (M$SETFMA).
  247
  248
  249                          */
  250
  251                          /*F* NAME: M$DCB - Data Control Block.
  252
  253                          The DCB is the communication data block between the
  254                          user and the monitor concerning the attributes of
  255                          a disk file, labeled tape file, or device.
  256                          */
  257      DCL 1 DCBN STCLASS,
  258                          /*K* DCBN = DCBNAME.
  259                          Specifies the DCB name.  Any 1-31 character name
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            8    
  260                          that conforms to language requirements may be
  261                          used.  Certain DCB names result in defaults being
  262                          assumed for FUN and RES at M$OPEN.
  263
  264                          This parameter is required.
  265                                                                                  */
  266      /* Begin *K* names with #240 for returned information (before NAME#) */
  267                          /*K*
  268                                                                                 */
  269            2 ARS# SBIN INIT(0),
  270                          /*K*  ARS#.
  271                           Actual record size read in bytes.
  272                          Number of records skipped by M$PRECORD.
  273                           Number of records deleted by M$DELREC.
  274                          Approximate maximum record size in bytes after
  275                          M$OPEN, to the nearest page size.                       */
  276            2 FLPW# REDEF ARS# BIT(36), /* FINAL LIST POINTER WORD                */
  277                          /*K*  FLPW#.  Contains the final List Pointer
  278                          Word (LPW) from the channel mailbox.                    */
  279            2 TYC(0:1),             /* NO-WAIT AND WAIT TYCS                      */
  280                          /*K*  TYC.  Type completion codes returned
  281                          to the user upon completion of an I/O
  282                          operation through the DCB.
  283                          */
  284              3 EGV# BIT(1) INIT('0'B*0),
  285                          /*K*  TYC.EGV#.  Set if TYC not yet returned to user.   */
  286              3 OPER# BIT(1) INIT('0'B*0),
  287                          /*K*  TYC.OPER#.  Set if tape error occurred that
  288                          lost position.                                          */
  289              3 EOT# BIT(1) INIT('0'B*0),
  290                          /*K*  TYC.EOT#.  Set for end of tape.                   */
  291              3 BOT# BIT(1) INIT('0'B*0),
  292                          /*K*  TYC.BOT#.  Set for beginning of tape.             */
  293              3 BOF# BIT(1) INIT('0'B*0),
  294                          /*K*  TYC.BOF#.  Set for beginning of file.             */
  295              3 BLNKTP# BIT(1) INIT('0'B*0),
  296                          /*K*  TYC.BLNKTP#.  Set if blank tape on read.          */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            9    
  297              3 EOF# BIT(1) INIT('0'B*0),
  298                          /*K*  TYC.EOF#.  Set for end of file.                   */
  299              3 LD# BIT(1) INIT('0'B*0),
  300                          /*K*  TYC.LD#.  Set for lost data.                      */
  301              3 IOERR# BIT(1) INIT('0'B*0),
  302                          /*K*  TYC.IOERR#.  Set for I/O medium error.            */
  303              3 DI# BIT(1) INIT('0'B*0),
  304                          /*K*  TYC.DI#.  Set for file data inconsistency.        */
  305              3 EOD# BIT(1) INIT('0'B*0),
  306                          /*K*   TYC.EOD#.  Set if end-of-data encountered.       */
  307              3 MTRAP# BIT(1) INIT('0'B*0),
  308                          /*K*  TYC.MTRAP#.  Set for memory trap during I/O.      */
  309              3 LDISC# BIT(1) INIT('0'B*0),
  310                          /*K*  TYC.LDISC#.  Set upon line disconnect.            */
  311              3 DACT# BIT(1) INIT('0'B*0),
  312                /*K*   TYC.DACT#.  Set when I/O is cancelled by deactivation.     */
  313              3 TIMO# BIT(1) INIT('0'B*0),
  314                          /*K*  TYC.TIMO#.
  315                          Set when read times out.
  316                                                                                  */
  317              3 PROT# BIT(1) INIT('0'B*0),
  318                          /*K*   TYC.PROT#.  Set if tape is write-protected.      */
  319              3 FRAW# BIT(1) INIT('0'B*0),
  320                     /*K*   TYC.FRAW#.  Set if read after forward write on tape.  */
  321              3 LAST# BIT(1) INIT('0'B*0),
  322                /*K*   TYC.LAST#.  Set if an error occurred on previous operation
  323                       after the status was returned.                             */
  324              3 CDALRT# BIT(1) INIT('0'B*0),
  325                          /*K*  TYC.CDALRT#.  Set if a byte with high order bit
  326                          set was detected during a TAPE write of a format
  327                          which retains only the lower eight bits.                */
  328              3 XTRARD BIT(1) INIT('0'B*0),
  329                          /*K*  TYC.XTRARD.  Set if read with read pending.       */
  330              3 CGKEYV BIT(1) INIT('0'B*0),
  331                          /*K*  TYC.CGKEYV.  Set for COMGROUP key violation;
  332                          that is, read or write specifying illegal message
  333                          type or station.                                        */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            10   
  334              3 CGLWRV BIT(1) INIT('0'B*0),
  335                          /*K*  TYC.CGLWRV.  Set for COMGROUP LATCHed write
  336                          error; no input message to latch the write to,
  337                          or latched input message spawn depth or spawn
  338                          count exhausted, or wild-carded destination specified.  */
  339              3 CGFULL BIT(1) INIT('0'B*0),
  340                          /*K*  TYC.CGFULL.  Set on WRITE if the COMGROUP
  341                          is full; set on READ if the COMGROUP is too full
  342                          to allow fetching messages.                             */
  343              3 CGCRCW BIT(1) INIT('0'B*0),
  344                          /*K*  TYC.CGCRCW.  Set on COMGROUP READ if a
  345                          latched, continued write is awaiting its last
  346                          segment to be written.                                  */
  347              3 CGCWRV BIT(1) INIT('0'B*0),
  348                          /*K*  TYC.CGCWRV. Set on COMGROUP WRITE if continue
  349                          is specified, and a wild-carded destination is
  350                          supplied, or a different message type is supplied
  351                          from other writes for this same message.
  352                          Set on COMGROUP READ if CONT was specified but
  353                          there is no record to continue reading.                 */
  354              3 * BIT(11) INIT('0'B*0),
  355            2 DVBYTE,
  356                          /*K*  DVBYTE.  DVBYTE is returned to the DCB on reads
  357                          and informs the user about the nature of the record
  358                          read.                                                   */
  359              3 TOP# BIT(1) UNAL INIT('0'B),
  360                          /*K*  DVBYTE.TOP#.  This bit has two different meanings.
  361
  362                          If the record was read from a control command file
  363                          (F$DCB.DDEV.XEQ# set), this bit is set to indicate that
  364                          the record is the last one in the file.
  365
  366                          If the record was read from a unit-record file, this bit
  367                          is set to indicate that the record is the first one to be
  368                          printed on a page.
  369                                                                                  */
  370              3 * BIT(1) UNAL INIT('0'B),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            11   
  371              3 VFC# BIT(1) UNAL INIT('0'B),
  372                          /*K*  DVBYTE.VFC#.  Set if the first character of the
  373                          record read should be interpreted as a VFC character.   */
  374              3 BIN# BIT(1) UNAL INIT('0'B),
  375                          /*K*  DVBYTE.BIN#.  Set if the record was read in binary
  376                          mode.  This means that data was read bit-by-bit from
  377                          the medium into the buffer rather than one character
  378                          per 9 bit byte.                                         */
  379              3 TRANS# BIT(1) UNAL INIT('0'B),
  380                          /*K*  DVBYTE.TRANS#.  Set if the record was read in
  381                          transparent mode.  This means that no translation
  382                          was performed by the system and the data is that
  383                          which was read from the I/O medium. This bit is only
  384                          set in cases where the default read of the record
  385                          would cause a translation to be done, as with
  386                          time-sharing terminals.
  387                                                                                  */
  388              3 * BIT(3) UNAL INIT('0'B),
  389            2 BUPF BIT(1)INIT('0'B),
  390                     /*K*   BUPF.  Set if any backup is possible in this account. */
  391            2 RDL0# UBIN(9) UNAL INIT(0),
  392                          /*K*  RDL0#.  Number of granules read after
  393                reaching level 0 of the index of a KEYED or INDEXED disk file.    */
  394            2 SLIDE# UBIN(9) UNAL INIT(0),
  395                          /*K*  SLIDE#.  Number of granules on level 0
  396                          not in level 1 of the index of a KEYED
  397                          or INDEXED disk file.
  398                                                                                  */
  399            2 EOMCHAR# CHAR(1) UNAL INIT(BITASC('501'O)),
  400            2 EOMVAL# REDEF EOMCHAR# UNAL,
  401              3 VFLG# BIT(1) UNAL,
  402              3 VALUE# UBIN(8) UNAL,
  403                     /*K*   EOMCHAR#.  When a read is done to a terminal EOMCHAR#
  404                     is filled in with the activation character.  If there
  405                     is no activating character or if the read is not to a
  406                     terminal, EOMCHAR# is set to EOM_EOR# ('501'O).              */
  407
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            12   
  408            2 FFLG,
  409                          /*K*  FFLG. is a collection of access control
  410                           flags set by M$OPEN when it processes account
  411                      security checks and opens the DCB. These flags control the I/O
  412                      that a user may do when
  413                      the DCB  is open.
  414                      */
  415              3 READ# BIT(1) INIT('0'B),
  416                          /*K*  FFLG.READ#.
  417                          If set, records may be read.
  418                                                                                  */
  419              3 DELR# BIT(1) INIT('0'B),
  420                          /*K*  FFLG.DELR#.
  421                          If set, existing records may be
  422                          deleted.                                                */
  423              3 WNEW# BIT(1) INIT('0'B),
  424                          /*K*  FFLG.WNEW#.
  425                          If set, new records may be written.
  426                                                                                  */
  427              3 UPD# BIT(1) INIT('0'B),
  428                          /*K*  FFLG.UPD#.
  429                          If set, existing records may be
  430                          updated (overwritten).
  431                                                                                  */
  432              3 DELF# BIT(1) INIT('0'B),
  433                          /*K*  FFLG.DELF#.
  434                          If set, file may be deleted
  435                           or its name, password, or access control may
  436                           be changed (via these options on M$CLOSE:  DISP=RELEASE,
  437                           NAME, PASS, ACCESS, or ACSVEH).
  438                                                                                  */
  439              3 NOLIST# BIT(1) INIT('0'B),
  440                          /*K*  FFLG.NOLIST#.
  441                          If set, file appears not to exist.
  442                                                                                  */
  443              3 REATTR# BIT(1) INIT('0'B),
  444                          /*K*  FFLG.REATTR#.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            13   
  445                          If set, disk file attributes,
  446                          with the exception of ACCESS and ACSVEH, may be
  447                          modified at M$CLOSE.  For modification of ACCESS
  448                          and ACSVEH, see FFLG.DELF#.
  449                                                                                  */
  450              3 EXEC# BIT(1) INIT('0'B),
  451                          /*K*  FFLG.EXEC#.
  452                          If set, DCB was opened by
  453                          a process named in the access vehicle list
  454                          for this file. It indicates (to such processes)
  455                          that restricted access has been invoked and requires
  456                          that subsequent operations through the DCB be done by the
  457                          same process that opened it.
  458
  459                          It can also be used by the process to restrict
  460                          subsequent operations by the user.  For example,
  461                          the FETCH process uses this flag to preclude
  462                          the association of a debugger with an
  463                          "execute-only" run-unit.
  464                                                                                  */
  465              3 CREATE# BIT(1)INIT('0'B),
  466                          /*K*  FFLG.CREATE#.
  467                          If set, the opening user is permitted
  468                          to create new files in the DCB's account.
  469                          */
  470              3 AU# BIT(1)INIT('0'B),
  471                          /*K*  FFLG.AU#.
  472                          Meaningful for comgroups only.
  473                          If set, this user is allowed to be the
  474                          administrative user.
  475                          */
  476              3 AURD# BIT(1)INIT('0'B),
  477                          /*K*  FFLG.AURD#.
  478                          Meaningful for comgroups only.
  479                          If set, this user is allowed to issue monitor services
  480                          normally reserved for the administrative user
  481                          that examine but do not change the comgroup.            */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            14   
  482
  483              3 TCTL# BIT(1)INIT('0'B),
  484                          /*K*  FFLG.TCTL#.
  485                          Meaningful for comgroups only.
  486                          If set, this user is allowed to issue
  487                          terminal control monitor services (such as M$PROMPT
  488                          and M$STRMATTR).  For ORG=FPRG comgroups,
  489                          M$SETFP is allowed.                                     */
  490
  491              3 * BIT(6)INIT('0'B),
  492            2 DDEV,
  493                          /*K*  DDEV.  Is a collection of flags set by M$OPEN.
  494                          These flags are provided to help the user of the DCB
  495                          to take appropriate action.                             */
  496              3 LP# BIT(1)UNAL INIT('0'B),
  497                          /*K*  DDEV.LP#.  If set, this DCB has line printer
  498                          characteristics; vertical format control applies, and the
  499                          M$LINES question (where am I on the page?) may be
  500                          meaningfully asked.                                     */
  501              3 CP# BIT(1)UNAL INIT('0'B),
  502                          /*K*  DDEV.CP#.  If set, this DCB has card punch
  503                          characteristics; card sequencing may be meaningfully
  504                          specified.                                              */
  505              3 IC# BIT(1)UNAL INIT('0'B),
  506                          /*K*  DDEV.IC#.  If set, this DCB has interactive
  507                          terminal characteristics, in the sense that input is
  508                          already displayed.                                      */
  509              3 XEQ# BIT(1)UNAL INIT('0'B),
  510                          /*K*  DDEV.XEQ#.  If set, the last record read through
  511                          this DCB was a command created by the !XEQ process.     */
  512              3 UCOUT# BIT(1)UNAL INIT('0'B),
  513                          /*K*  DDEV.UCOUT#.  If set, output written through
  514                          this DCB is being written to the user's interactive
  515                          terminal.                                               */
  516              3 GR# BIT(1)UNAL INIT('0'B),
  517                          /*K*  DDEV.GR#.  If set, output written through
  518                          this DCB is treated as if it is going to a graphic
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            15   
  519                          device.                                                 */
  520              3 * BIT(3)UNAL INIT('0'B),
  521
  522            2 WIDTH# UBIN(9) UNAL INIT(0),
  523                          /*K*  WIDTH#.  Set to the number of columns on a
  524                          printable line or card.  Zero if WIDTH# is meaningless
  525                          for this device; e.g., zero for files.
  526                                                                                  */
  527            2 RETRYCNT# UBIN(18) HALIGNED INIT(0),
  528                          /*K*  RETRYCNT#.  Accumulates the number of retries when
  529                          physical IO errors occur.  This field is set to zero when
  530                     the DCB is opened and incremented by the retry count whenever
  531                     a recoverable IO error occurs.                               */
  532
  533            2 DESC,
  534                          /*B*  DESC. : Descriptor bits - 9 bits for disk
  535                          file directory descriptors and 9 bits for
  536                          FIT descriptors.                                        */
  537                                    /* FILE DIRECTORY DESCRIPTOR BITS             */
  538              3 DELF# BIT(1) INIT('0'B),
  539                          /*K*  DESC.DELF#.  Set if a deleted file was
  540                          found on NXTF open with SRCHCOND.                       */
  541              3 NOLIST# BIT(1) INIT('0'B),
  542                          /*K*  DESC.NOLIST#.  Set if this file has NOLIST
  543                          attribute.                                              */
  544              3 BUF# BIT(1) INIT('0'B),
  545                          /*K*  DESC.BUF#.  Set if file to be backed up.          */
  546              3 ODSTOW# BIT(1) INIT('0'B),
  547                          /*K*  DESC.ODSTOW#.  Set if the file is stowed on
  548                          optical disk.                                           */
  549              3 BAD# BIT(1) INIT('0'B),
  550                          /*K*  DESC.BAD#.  Set if file inconsistency found.      */
  551              3 QS# BIT(1) INIT('0'B),
  552                          /*K*  DESC.QS#.  Set if EFT ARCHIVE or RETRIEVE pending.
  553                          See DESC.FETCH# and DESC.ACTIVE# for further detail.    */
  554              3 * BIT(2) INIT('0'B),
  555
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            16   
  556              3 ARCHIVE# BIT(1) INIT('0'B),
  557                /*K*  DESC.ARCHIVE#.  Set if file is known in the ARCHIVE system. */
  558                                    /* Following are the FIT descriptor bits      */
  559              3 BUPM# BIT(1) INIT('0'B),
  560                          /*K*  DESC.BUPM#.  Set if the file is
  561                          to be backed up if modified.                            */
  562              3 NBUF# BIT(1) INIT('0'B),
  563                          /*K*  DESC.NBUF#.  Set by EFT in two cases.
  564                           1) If the file's "last modified" date is less than
  565                              its creation date, this is the FIT(only) for a
  566                              file in an account with the ACUP attribute;
  567                              if the packset is rebuilt, EFT can use this
  568                              FIT to insure that it rebuilds the file with
  569                              the correct "last accessed" date.
  570                           2) If the file's "last modified" date is greater
  571                              than or equal to its creation date, this is a
  572                              DUAL copy of a file that EFT was unable
  573                              to open during its last DUAL operation, and the
  574                              packsets have subsequently been switched.
  575                          */
  576              3 ACTIVE# BIT(1) INIT('0'B),
  577                          /*K*  DESC.ACTIVE#.  If DESC.QS# and DESC.FETCH# are
  578                          both true, the FETch request was made by a user
  579                          with the FMSEC privilege active at JOB rather than as
  580                          a function of the EFT processor privileges. This will
  581                          allow a privileged user to override the account granule
  582                          limits.
  583                          If DESC.QS# is true, and DESC.FETCH# is false, and
  584                          DESC.ACTIVE# is false, the file granules will be
  585                          released as a function of the close when the file
  586                          is closed after being ARChived.
  587                                                                                    */
  588              3 TPB# BIT(1) INIT('0'B),
  589                          /*K*  DESC.TPB#.  Set if last backup was to tape.       */
  590              3 TERMINATE# BIT(1) INIT('0'B),
  591                     /*K*  DESC.TERMINATE#.  Set if to be removed from ARCHIVE.   */
  592              3 FETCH# BIT(1) INIT('0'B),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            17   
  593                          /*K*  DESC.FETCH#.  Meaningful only if QS# is set.
  594                          Set if file needs to be RETRIEVED to service a
  595                          user FETCH request.  Reset if file needs to be
  596                          ARCHIVED to service a user STOW request.
  597                                                                                  */
  598              3 * BIT(3) INIT('0'B),
  599
  600            2 SETSTA$ PTR INIT(ADDR(NIL)),
  601                          /*K*  SETSTA$.  Points to a VLP_SETSTA
  602                          elsewhere in the read-only segment that supplies
  603                          STATION and MSGTYP defaults for COMGROUP I/O through
  604                          this DCB.  SETSTA$ is initialized via the !SET command
  605                          or M$OPEN FPT.
  606                                                                                  */
  607            2 LASTSTA$ PTR INIT(ADDR(NIL)),
  608                          /*K*  LASTSTA$.  Points to a VLP_STATION
  609                          elsewhere in the read-only segment that describes
  610                          the last message read or written via this DCB through
  611                          a COMGROUP.  If the destination station of an M$WRITE
  612                          is not supplied on the write or in SETSTA$ above,
  613                          LASTSTA$ is the default.
  614                                                                                  */
  615            2 TDEXTST$ REDEF LASTSTA$ PTR,
  616                          /*K*  TDEXTST$.  Points to an extended status structure
  617                          elsewhere in the read-only segment which contains
  618                          the extended status for the last T&D IO performed
  619                          for this DCB.
  620                                                                                  */
  621                                    /* INFO SUPPLIED BY OR AVAIL. TO USER         */
  622            2 NAME#,
  623              3 L UBIN(9) UNAL INIT(SIZEC(NAME)),
  624              3 C CHAR(31) UNAL INIT(NAME),
  625                          /*K* NAME = VALUE-CHAR(1-31)
  626                          .xeq F_CP6_C M$OPEN NAME                                */
  627
  628              3 C17 REDEF C UNAL, /* First 17 chars of name for ANS tape formats  */
  629                4 CC CHAR(17) UNAL,
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            18   
  630                4 * CHAR(14) UNAL,
  631
  632            2 ACCT# CHAR(8) UNAL INIT(ACCT),
  633                          /*K* ACCT = VALUE-CHAR(8).
  634                          .xeq F_CP6_C M$OPEN ACCT
  635
  636                          If ACCT is not specified, it is taken from the
  637                          user's File Management account which defaults to
  638                          the logon account but can be modified by the
  639                          M$SETFMA service or !DIRECTORY command.
  640                                                                                  */
  641
  642
  643            2 PASS# CHAR(8) INIT(PASS),
  644                          /*K* PASS= VALUE-CHAR(8)
  645                          .xeq F_CP6_C M$OPEN PASS
  646
  647                          The default is blanks which means no password is
  648                          required.
  649                                                                                  */
  650
  651            2 PSN# CHAR(6) UNAL INIT(PSN),
  652                          /*K* PSN = VALUE-CHAR(6)  Specifies
  653                          for a disk file, the pack set name if the account
  654                          is not in public storage.
  655                          For labeled or free tape, this parameter specifies the
  656                          serial number of the volume currently mounted.
  657
  658                          The default is blanks which means public disk
  659                          storage or scratch tape.
  660                                                                             */
  661            2 TYPE# CHAR(2) UNAL INIT(TYPE),
  662                          /*K* TYPE = VALUE-CHAR(2).
  663                          .xeq F_CP6_C M$OPEN TYPE
  664                          See M$OPEN, TYPE for the list of defined file
  665                          types.
  666                          The default is blanks.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            19   
  667                                                                                  */
  668            2 RES# CHAR(4) UNAL INIT(RES),
  669            2 RESNT REDEF RES# UNAL,
  670              3 TYP CHAR(2) UNAL,
  671              3 NUM CHAR(2) UNAL,
  672                          /*K* RES = VALUE-CHAR(4)
  673                          .xeq F_CP6_C M$OPEN RES                                 */
  674            2 WSN# CHAR(8) ALIGNED INIT(WSN),
  675                          /*K*WSN = VALUE-CHAR(8).
  676                          .xeq F_CP6_C M$OPEN WSN
  677                          The default is blanks.
  678                          */
  679
  680            2 TDSTAT# REDEF WSN# BIT(72),
  681                          /*K*  TDSTAT#.  Receives the hardware status
  682                          doubleword.  In addition to the hardware
  683                          status, TDSTAT# may be used to report the
  684                          following conditions:
  685
  686                          Lost Interrupt - The major status code is 8
  687                          (decimal).  Lost interrupts are detected by a
  688                          poller whose period is 5 seconds.
  689
  690                          System Fault - The major status code is 15
  691                          (decimal).  In this case the second word of
  692                          TDSTAT# is the hardware fault word (reported
  693                          via the Fault channel) with bit 0 set.
  694                          T&D DCB only.
  695                          */
  696
  697            2 IGNOREFSN# BIT(1) INIT(IGNOREFSN),
  698                          /*K* IGNOREFSN = {YES|NO}
  699                          .xeq F_CP6_C M$OPEN IGNOREFSN
  700                          The default is NO.
  701                                                                                  */
  702            2 AU# BIT(1) INIT(AU),
  703                          /*K* AU = {YES|NO}.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            20   
  704                          .xeq F_CP6_C M$OPEN AU                                  */
  705
  706            2 QISS# BIT(1) INIT(QISS),
  707                          /*K* QISS = {YES|NO}
  708                          .xeq F_CP6_C M$OPEN QISS
  709                          The default is NO.
  710                                                                                  */
  711
  712            2 LOAD# BIT(1) INIT(LOAD),
  713
  714            2 IOERROK# BIT(1) INIT(IOERROK),
  715                          /*K* IOERROK = {YES|NO}
  716                          .xeq F_CP6_C M$OPEN IOERROK
  717                          The default is NO.
  718                                                                                    */
  719                          /*K* LOAD = {YES|NO}
  720                          .xeq F_CP6_C M$OPEN LOAD
  721                          The default is NO.
  722                                                                                  */
  723
  724            2 AMRSETSTA BIT(1) INIT('0'B),
  725                          /*B* AMRSETSTA : Set by M$OPEN if a SET command
  726                               contains SETSTA information.
  727                                    */
  728            2 LSTAOR# BIT(1) INIT(LSTAOR),
  729                          /*K* LSTAOR = {YES|NO}
  730                          .xeq F_CP6_C M$OPEN LSTAOR
  731                          Default is NO.
  732                                                                                  */
  733
  734            2 VOLACCESS# UBIN(2) UNAL INIT(VOLACCESS),
  735                          /*K* VOLACCESS = OPTION.
  736                          .xeq F_CP6_C M$OPEN VOLACCESS
  737                                                                                  */
  738            2 UOPT#(0:8)BIT(1)INIT(UOPT0,UOPT1,UOPT2,UOPT3,UOPT4,UOPT5,UOPT6,
  739              UOPT7,UOPT8),
  740                          /*K* UOPT0 - UOPT8 = {YES|NO}.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            21   
  741                          .xeq F_CP6_C M$OPEN UOPT0
  742                           The default is NO.
  743                                                                                  */
  744            2 PASSF# BIT(1) INIT('0'B),
  745                          /*B* PASSF : Set by M$OPEN if the password
  746                          field in the DCB contains a scrambled
  747                          password (not the text supplied).
  748                                                                                  */
  749            2 CNVRT# BIT(1) UNAL INIT(CNVRT),
  750                          /*K* CNVRT = {YES|NO}.
  751                          .xeq F_CP6_C M$OPEN CNVRT
  752
  753                          The default is YES.
  754                                                                                  */
  755
  756            2 EBCDIC# BIT(1) UNAL INIT(EBCDIC),
  757                          /*K* EBCDIC = {YES|NO}.
  758                          .xeq F_CP6_C M$OPEN EBCDIC
  759
  760                          The default is NO.
  761                                                                                  */
  762
  763            2 FCI# BIT(1) INIT('0'B),
  764                          /*K*  FCI#.  Set if the DCB was successfully opened
  765                          by the last attempt to do so.
  766                                                                                  */
  767            2 FCD# BIT(1) INIT('0'B),
  768                          /*K*  FCD#.  Set if the DCB is currently open.          */
  769
  770            2 AMR# BIT(1) INIT('0'B),
  771                          /*K*  AMR#.  Set if !SET command information has been
  772                          merged into the DCB.                                    */
  773
  774            2 CTG# BIT(1) UNAL INIT(CTG),
  775                          /*K* CTG = {YES|NO}.
  776                          .xeq F_CP6_C M$OPEN CTG
  777
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            22   
  778                          The default is CTG = NO.
  779                                                                                  */
  780
  781            2 EXIST# UBIN(2) UNAL INIT(EXIST),
  782                          /*K* EXIST = OPTION.
  783                          .xeq F_CP6_C M$OPEN EXIST
  784
  785                          The default is EXIST=NEWFILE.
  786                                                                                  */
  787
  788            2 SHARE# UBIN(2) UNAL INIT(SHARE),
  789                          /*K* SHARE = OPTION.
  790                          .xeq F_CP6_C M$OPEN SHARE
  791                          (See Table 3-2 in the description of M$OPEN
  792                          for complete information on this topic.)
  793
  794                          The default is NONE for disk files and ALL for
  795                          comgroups.
  796                                                                                  */
  797
  798            2 COMP# BIT(1) INIT(COMP),
  799                          /*K* COMP = {YES|NO}.
  800                          .xeq F_CP6_C M$OPEN COMP
  801
  802                          The default is NO.
  803                                                                                  */
  804
  805            2 XTEND# BIT(1) UNAL INIT(XTEND),
  806                          /*K* XTEND = {YES|NO}.
  807                          .xeq F_CP6_C M$OPEN XTEND
  808                          The default is NO.
  809                                                                                  */
  810
  811            2 CVOL# BIT(1) UNAL INIT(CVOL),
  812                          /*K* CVOL = {YES|NO}.
  813                          .xeq F_CP6_C M$OPEN CVOL
  814
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            23   
  815                          The default is NO in which case volume changes are
  816                          done automatically.
  817                                                                                  */
  818            2 BLOCKED# BIT(1) UNAL INIT(BLOCKED),
  819                          /*K* BLOCKED = {YES|NO}.
  820                          .xeq F_CP6_C M$OPEN BLOCKED
  821
  822                          The default is YES which results in the most
  823                          efficient usage of tape records.
  824                                                                                  */
  825            2 SPANNED# BIT(1) UNAL INIT(SPANNED),
  826                          /*K* SPANNED = {YES|NO}.
  827                          .xeq F_CP6_C M$OPEN SPANNED
  828                          The default is YES which results in the most
  829                          efficient usage of tape records besides
  830                          permitting records of any length.
  831                                                                                  */
  832            2 BUPM# BIT(2) INIT(BUPM),
  833                          /*K* BUPM = {YES|NO}.
  834                          .xeq F_CP6_C M$OPEN BUPM
  835                          The default is an attribute of the file's account.
  836                                                                                  */
  837
  838            2 ORG# UBIN(9) UNAL INIT(ORG),
  839                          /*K* ORG = OPTION.
  840                          .xeq F_CP6_C M$OPEN ORG
  841
  842                          The default for disk and tape files is CONSEC.
  843                          The default for comgroups is TERMINAL.
  844                          The default for free tape is FREE.
  845                          The default for other devices is UR.
  846                                                                                  */
  847            2 DVTYPE# REDEF ORG# UBIN(9) UNAL,
  848                          /*K*  DVTYPE#.  Contains the device type for T & D DCBs
  849                          open for test and diagnostic services.
  850                          The DV_ constants in NI_DATA_C define the
  851                          possible values for DVTYPE#.                            */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            24   
  852
  853            2 FUN# UBIN(9) UNAL INIT(FUN),
  854                          /*K* FUN = OPTION.
  855                          .xeq F_CP6_C M$OPEN FUN
  856                          For the default, see M$OPEN, the DCB parameter.
  857                                                                                  */
  858            2 ASN# UBIN(9) UNAL INIT(ASN),
  859                          /*K* ASN = OPTION.
  860                          .xeq F_CP6_C M$OPEN ASN
  861
  862                          The default is DEVICE.
  863                                                                                  */
  864
  865
  866            2 DISP# UBIN(9) UNAL INIT(DISP),
  867                          /*K* DISP = OPTION.
  868                          .xeq F_CP6_C M$OPEN DISP
  869                          The default is DISP=NAMED.
  870                                                                                  */
  871            2 BLKL# UBIN(18) UNAL INIT(BLKL),
  872                          /*K* BLKL = VALUE-DEC(1-32764).
  873                          .xeq F_CP6_C M$OPEN BLKL
  874
  875                          If no BLKL (0) is specified, a format dependent
  876                          default will be supplied.
  877
  878                          For complete information on options and defaults
  879                          for ANS ASCII or IBM EBCDIC tapes, see
  880                          Host Monitor Services Reference Manual (CE75),
  881                          Appendix F.  That appendix also specifies the
  882                          maximum size for BLKL that is
  883                          also format dependent.  The default for CP-6
  884                          format tapes is 4096.
  885                                                                                  */
  886            2 RECL# UBIN(18) UNAL INIT(RECL),
  887                          /*K* RECL = VALUE-DEC(1-32K).
  888                          .xeq F_CP6_C M$OPEN RECL
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            25   
  889
  890                          If no RECL (0) is specified for unspanned files, a
  891                          format dependent default will be supplied.  The
  892                          maximum is also format dependent.
  893
  894                          For complete information on options related to
  895                          creating ANS ASCII or IBM ECBDIC tapes, see
  896                          Host Monitor Services Reference Manual (CE75),
  897                          Appendix F.  That appendix also specifies the
  898                          maximum size for RECL that is also format
  899                          dependent.
  900                                                                                  */
  901            2 FSN# UBIN(18) UNAL INIT(FSN),
  902                          /*K* FSN = VALUE-DEC(1-9999).
  903                          .xeq F_CP6_C M$OPEN FSN
  904                                                                                  */
  905
  906            2 DBGDCBNO# REDEF FSN# UBIN(18) UNAL,
  907            2 DBGSYSID# REDEF FSN# UBIN(18) UNAL,
  908            2 SYSID# REDEF FSN# UBIN(18) UNAL,
  909                          /*K* SYSID = VALUE(1-65535).
  910                               This contains the SYSID for the FPRG.
  911                          */
  912            2 FEXTX UBIN(9) UNAL INIT(0),
  913                          /*B* FEXTX : An offset into the JIT, pointing to
  914                          the file extension control bit for this
  915                          M$oplbl DCB. (does not apply to F$ DCBs)
  916                          If the bit is set, then file extension will
  917                          occur. If it is not set, then extension will
  918                          not occur (I.E. A new file will be created).
  919                          The bit in the JIT is reset whenever
  920                          a SET or ASSIGN is done explicitly to this
  921                          M$oplbl DCB.
  922                          File extension for M$oplbl DCBs is
  923                          effective only for CREATE, NEWFILE opens.
  924                                                                                  */
  925            2 BOL# UBIN(9) UNAL INIT(0),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            26   
  926                          /*B* BOL : The block offset length in bytes applies
  927                          only to blocked files on labeled tapes and is used
  928                          to store system information concerning the tape block.
  929                          For other file formats, BOL is zero.  For IN or UPDATE
  930                          opens BOL is determined from the file opened.
  931                                                                                  */
  932            2 EXPIRE# SBIN INIT(EXPIRE),
  933                          /*K* EXPIRE = {ddd|NEVER}.
  934                          .xeq F_CP6_C M$OPEN EXPIRE
  935
  936                          If the DCB is open to a deleted file (see M$OPEN, NXTF and
  937                          SRCHCOND.DELF) the UTS of deletion time is returned here.
  938                          (UTS, defined in Section 4 for M$TIME, is the
  939                          standard CP-6 notation for time.)
  940                                                                                  */
  941
  942
  943            2 KEYX# UBIN(18) UNAL INIT(KEYX),
  944                          /*K* KEYX = VALUE-DEC(0-32K).
  945                          .xeq F_CP6_C M$OPEN KEYX
  946                                                                                  */
  947            2 KEYL# UBIN(9) UNAL INIT(KEYL),
  948                          /*K* KEYL = VALUE-DEC(1-255).
  949                          .xeq F_CP6_C M$OPEN KEYL
  950                          The default is 0.
  951                                                                                  */
  952            2 ACS# UBIN(9) UNAL INIT(ACS),
  953                          /*K* ACS = OPTION.
  954                          .xeq F_CP6_C M$OPEN ACS
  955
  956                          .UNL 10
  957                          The default is ACS=SEQUEN.
  958                                                                                  */
  959
  960            2 XTNSIZE# UBIN(18) UNAL INIT(XTNSIZE),
  961                          /*K* XTNSIZE = VALUE-DEC(1-2**17).
  962                          .xeq F_CP6_C M$OPEN XTNSIZE
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            27   
  963                          The default is 2.
  964
  965                          .INL 0
  966                          A listing of additional fields in the DCB follows.
  967                          These fields are not set via parameters for M$DCB
  968                          but are available for access by users.  The names
  969                          indicated are those of the actual fields in the
  970                          DCB structure.
  971                          */
  972                          /*B* The previous comment should be moved under
  973                          the last parameter of the M$DCB in the case of an
  974                          update at a later date.                                 */
  975
  976            2 LSLIDE# UBIN(9) UNAL INIT(LSLIDE),
  977                          /*K* LSLIDE = VALUE-DEC(1-511).
  978                          .xeq F_CP6_C M$OPEN LSLIDE
  979                          The default is 510.
  980                                                                                  */
  981
  982            2 LRDL0# UBIN(9) UNAL INIT(LRDL0),
  983                          /*K* LRDL0 = VALUE-DEC(1-511).
  984                          .xeq F_CP6_C M$OPEN LRDL0
  985                          The default is 3.
  986                                                                                  */
  987
  988            2 SPARE# UBIN(9) UNAL INIT(SPARE),
  989                          /*K* SPARE = VALUE-DEC(1-511).
  990                          .xeq F_CP6_C M$OPEN SPARE
  991                          The default is 1.
  992                                                                                  */
  993
  994            2 WSR# UBIN(9) UNAL INIT(0),
  995                          /*K*  WSR#.  Set to the OPENer's working space register.
  996                          If the open was performed for an access vehicle
  997                          (F$DCB.FFLG.EXEC# set), subsequent access through this DCB
  998                          can only be by the access vehicle (i.e., same WSR).     */
  999      /* Strange use of CHARTEXT here is because FPTCON omits them from F$DCB */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            28   
 1000            2 %CHARTEXT('ATTR# BIT(18)') INIT(ATTR)
 1001                                    /*RESOURCE ATTRIBUTE MASK*/
 1002                          /*K* ATTR = VALUE-BIT(18).
 1003                          .xeq F_CP6_C M$OPEN ATTR
 1004                                                                                    */
 1005      %CHARTEXT('/*') ATTR
 1006      /* The previous line makes the name ATTR in F$DCBM, which keeps trailing # */
 1007            %CHARTEXT('*/,2 ATTR REDEF ATTR#'),
 1008              3 DENS# BIT(9) UNAL,
 1009              3 GRLGL# BIT(1) UNAL,
 1010                     /*K*  ATTR.GRLGL#.  If set, output through this DCB is treated
 1011                     as if it is for a graphics device.  This bit is automatically
 1012                     set in all graphic form records and propagated down.
 1013                     */
 1014              3 TRANSLGL# BIT(1),
 1015                     /*K*  ATTR.TRANSLGL#.  If set, the user can write out through
 1016                     this DCB transparently.  This will only affect symbiont files.
 1017                     */
 1018              3 NOXLATE# BIT(1) UNAL,
 1019                          /*K*  ATTR.NOXLATE#.  Set if there should not be any
 1020                          translation done on output to this device.
 1021                          */
 1022              3 UPPERCASE# BIT(1) UNAL,
 1023                          /*K*  ATTR.UPPERCASE#.  Set if all output should get
 1024                          translated to uppercase before delivery to output file
 1025                          or device.
 1026                          */
 1027              3 NATL# BIT(1) UNAL,
 1028                          /*K*  ATTR.NATL#.  Set if translation should be done
 1029                          according to the NATIONAL translation table.  This table
 1030                          is patchable by rumming the monitor variable NK_NATLTBL
 1031                          which is 512 characters long and is the translation
 1032                          table used in an internal CALL XLATE.
 1033                          See Table E-5 in Host Monitor Services Reference
 1034                          Manual, Volume 2 (CE75).
 1035                                                                                 */
 1036              3 TRUOVRPRT# BIT(1) UNAL,
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            29   
 1037                     /*K*  ATTR.TRUOVRPRT#.  Set if true overprinting is possible
 1038                     on this device.  On devices which cannot inhibit upspace
 1039                     or CRTs with destructive overprint, this bit is reset
 1040                     signifying that overprinted graphics will be represented
 1041                     by '*'.  Not currently implemented.                          */
 1042              3 APL# BIT(1) UNAL,
 1043                          /*K*  ATTR.APL#.  Set if device prints APL characters.  */
 1044              3 BIN# BIT(1) UNAL,
 1045                          /*K*  ATTR.BIN#.  Set if BIN is legal on M$WRITE.       */
 1046              3 LOWERCASE# BIT(1) UNAL,
 1047                     /*K*  ATTR.LOWERCASE#.  Set if device prints lower-case.     */
 1048            2 TDFLG REDEF %CHARTEXT('ATTR#/*')ATTR %CHARTEXT('*/'),
 1049                          /*K*  TDFLG. Test and Diagnostic flags.                 */
 1050              3 SDSK# BIT(1),
 1051                          /*K*  TDFLG.SDSK#.  If set, the T & D DCB is open to
 1052                          a disk that is part of a CP-6 packset.  Write
 1053                          access is only allowed to the T & D cylinder.           */
 1054              3 * BIT(17),
 1055            2 IXTNSIZE# SBIN WORD INIT(IXTNSIZE),
 1056                          /*K* IXTNSIZE = VALUE-DEC(1- ?).
 1057                          .xeq F_CP6_C M$OPEN IXTNSIZE
 1058                           The default is 2.
 1059                                                                                  */
 1060            2 CONNCT# REDEF IXTNSIZE# SBIN,
 1061                          /*K*  CONNCT#.  Number of connects accumulated
 1062                          on this T & D DCB since it was opened.                  */
 1063            2 NRECS# SBIN INIT(NRECS),
 1064                          /*K* NRECS = VALUE-DEC(1- ?).
 1065                          .xeq F_CP6_C M$OPEN NRECS
 1066                          When FUN=IN or UPDATE, this field is set to the
 1067                          number of records in a file.
 1068                                                                                  */
 1069            2 CHANTIME# REDEF NRECS# SBIN,
 1070                          /*K*  CHANTIME#.  Contains the accumulated channel
 1071                          time in microseconds since this T & D DCB was
 1072                          opened.                                                 */
 1073            2 VOL# UBIN(9) UNAL INIT(VOL),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            30   
 1074                          /*K* VOL = VALUE-DEC(1-511).
 1075                          .xeq F_CP6_C M$OPEN VOL
 1076                                                                                  */
 1077            2 MAXVOL# UBIN(9) UNAL INIT(MAXVOL),
 1078                          /*K* MAXVOL = VALUE-DEC(1-511).
 1079                          .xeq F_CP6_C M$OPEN MAXVOL
 1080                          The default is 0.
 1081                                                                                  */
 1082            2 CHAIN# UBIN(9) UNAL INIT(CHAIN),
 1083
 1084
 1085            2 DENSITY# UBIN(9) UNAL INIT(DENSITY),
 1086                          /*K* DENSITY = OPTION.
 1087                          .xeq F_CP6_C M$OPEN DENSITY
 1088
 1089                          The default is determined for the site by an
 1090                          option of the TIGR processor.
 1091                                                                                  */
 1092            2 LINES# UBIN(18) UNAL INIT(LINES),
 1093                          /*K* LINES = VALUE-DEC(1-32K).
 1094                          .xeq F_CP6_C M$OPEN LINES
 1095                          The default is the FORM definition value.
 1096                                                                                  */
 1097            2 DVFC# CHAR(1) UNAL INIT(DVFC),
 1098                          /*K* DVFC = VALUE-CHAR(1).
 1099                          .xeq F_CP6_C M$OPEN DVFC
 1100                          The default is not to use VFC.
 1101                                                                                  */
 1102            2 SEQ# BIT(1) UNAL INIT(SEQ),
 1103                          /*K* SEQ = {YES|NO}.
 1104                          .xeq F_CP6_C M$OPEN SEQ
 1105                          The default is NO.
 1106                                                                                  */
 1107            2 SEQCOL# UBIN(8) UNAL INIT(SEQCOL),
 1108                          /*K* SEQCOL = VALUE-DEC(1-255).
 1109                          .xeq F_CP6_C M$OPEN SEQCOL
 1110                          The default SEQCOL is 73.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            31   
 1111                                                                                  */
 1112
 1113            2 SEQID# CHAR(4) UNAL INIT(SEQID),
 1114                          /*K* SEQID = VALUE-CHAR(4).
 1115                          .xeq F_CP6_C M$OPEN SEQID
 1116                          The default is blank characters.
 1117                                                                                  */
 1118            2 HEADER$ PTR INIT(ADDR(NIL)),
 1119                          /*K*  HEADER$.  Points to a VLP_HDR elsewhere
 1120                          in the read-only segment that contains header information
 1121                          for a unit record device.  The information is
 1122                          provided by the !SET or !LDEV commands, M$OPEN
 1123                          or M$LDEV.
 1124                                                                                  */
 1125            2 DQH$ REDEF HEADER$ PTR,
 1126                          /*K*  DQH$.  Points to the DQH for the current
 1127                          T & D operation.                                        */
 1128            2 TAB$ PTR INIT(ADDR(NIL)),
 1129                          /*K*  TAB$.  Points to a VLP_TAB elsewhere
 1130                          in the read-only segment that describes TAB settings
 1131                          for a UR or TERMINAL DCB.  The VLP is obtained from
 1132                          the !SET or !LDEV command, or from M$OPEN or M$LDEV.
 1133                                                                                  */
 1134            2 DCT$ REDEF TAB$ PTR,
 1135                          /*K*  DCT$.  Points to the Device Control Table (DCT)
 1136                          for the device to which this T & D DCB is open.         */
 1137            2 FORM$ PTR INIT(ADDR(NIL)),
 1138                          /*K*  FORM$.  Points to a VLP_FORM elsewhere
 1139                          in the read-only segment that names the form to
 1140                          be mounted on this unit record device.  The form
 1141                          name is obtained from the !SET or !LDEV commands,
 1142                          or from M$OPEN or M$LDEV.
 1143                                                                                  */
 1144            2 MPC$ REDEF FORM$ PTR,
 1145                          /*K*  MPC$.  Points to the Device Control Table (DCT)
 1146                          for the Micro Programmed Controller (MPC) to which
 1147                          this T & D DCB is open.                                 */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            32   
 1148            2 LDCTX UBIN(18) UNAL INIT(0),
 1149                          /*B* LDCTX : LDCT table index for comgroup terminals    */
 1150            2 SETX UBIN(18) UNAL INIT(0),
 1151                          /*B* SETX: Set table index for disk files,
 1152                                     DCT table index for devices.                 */
 1153            2 DEVADR REDEF SETX,    /* DEVICE ADDRESS  (T & D DCB)                */
 1154              3 DVN# UBIN(6) UNAL,  /* DEVICE #                                   */
 1155                          /*K*  DEVADR.DVN#.  Specifies the device number.*/
 1156              3 IOM# UBIN(3) UNAL,  /* IOM #                                      */
 1157                          /*K*  DEVADR.IOM#.  Specifies the IOM number.           */
 1158          3 CHAN# UBIN(9) CALIGNED, /* CHANNEL #                                  */
 1159                          /*K*  DEVADR.CHAN#.  Specifies the channel number.*/
 1160            2 * BIT(9) CALIGNED INIT('0'B),
 1161            2 JRNLBYPASS# BIT(1) INIT(JRNLBYPASS),
 1162                          /*K* JRNLBYPASS = {YES|NO}.
 1163                          .xeq F_CP6_C M$OPEN JRNLBYPASS
 1164                                                                                  */
 1165            2 * BIT(4) INIT('0'B),
 1166            2 GHSTACS# UBIN(4) INIT(GHSTACS)UNAL,
 1167                          /*K* GHSTACS = VALUE-DEC(0-15).
 1168                          .xeq F_CP6_C M$OPEN GHSTACS
 1169                          The default is zero, which causes M$OPEN not to
 1170                          call the ghost.
 1171                                                                                  */
 1172            2 ALTKEYX UBIN(18) UNAL INIT(0),
 1173                          /*K*  ALTKEYX.  Contains the word offset
 1174                          into the read-only segment of a FITALTKEYS area
 1175                          describing the alternate key structure of an
 1176                          indexed file or an FMG$IRKEYS area describing the
 1177                          indexed relational keys of an IREL file.                */
 1178
 1179            2 CODE16$ PTR INIT(ADDR(NIL)),
 1180                          /*K*  CODE16$.  Points to a CODE16 area
 1181                          elsewhere in the read-only segment that contains
 1182                          information about current position of the unit-record
 1183                          medium this DCB is writing on.  CODE16$ is
 1184                          ADDR(NIL) if such a CODE16 is not available.            */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            33   
 1185            2 FPRGX UBIN HALF HALIGNED INIT(0),
 1186                          /*K*  FPRGX.
 1187                          Index into the read-only segment of the
 1188                          VLP_FPRG associated with this DCB.                      */
 1189            2 FIELDX UBIN HALF HALIGNED INIT(0),
 1190                          /*K*  FIELDX.  Word offset into the read-only
 1191                          segment of the start of a VLP_RECFIELD structure
 1192                          describing the physical layout of fields in a
 1193                          record.                                                 */
 1194            2 EVENT SBIN INIT(0),
 1195                          /*K* EVENT = VALUE-DEC(1-?).
 1196                          .xeq F_CP6_C M$OPEN EVENT
 1197                                                                                  */
 1198            2 VFCCHAR# CHAR(1) CALIGNED INIT(BINASC(0)),
 1199                          /*K*  VFCCHAR = VALUE-CHAR(1).
 1200                          The VFC character from the
 1201                               record.  See the STRPVFC option in M$READ.
 1202                          */
 1203            2 KEYTYPE# UBIN(9) CALIGNED INIT(KEYTYPE),
 1204                          /*K* KEYTYPE = {FLDID|COORD|BIN10|BINHLF|BIN521|STRING}.
 1205                          This field specifies the default
 1206                          KEYTYPE for reads and writes to a form device
 1207                          and the KEYTYPE for ORG=SE.  The KEYTYPEs are
 1208                          described below:
 1209
 1210                          FLDID refers to a field identifier (i.e.,
 1211                          FPT_DCLFLD.ID, a byte-aligned 2-byte value).
 1212                          See M$DCLFLD for details.
 1213
 1214                          COORD refers to the coordinates of a field (i.e.,
 1215                          a byte-aligned, 2-byte structure consists of the
 1216                          line and column of the field's location).
 1217
 1218                          BIN10 specifies that KEYINCR is to be divided by
 1219                          10 until it fits.  If KEYINCR=1000, then the first
 1220                          of 1000, 100, 10, and 1 that fits is used.
 1221
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            34   
 1222                          BINHLF specifies that KEYINCR is to be halved.  If
 1223                          KEYINCR=32, then the first of 32, 16, 8, 4, 2, and
 1224                          1 that is small enough will be used.
 1225
 1226                          BIN521 specifies that division by 5, 2.5, and 2 is
 1227                          to be repeated.  If KEYINCR=1000, then the sequence
 1228                          1000, 500, 200, 100, 50, 20, 10, 5, 2, and 1 is
 1229                          used.
 1230
 1231                          STRING specifies that key incrementation is not
 1232                          possible.
 1233                          */
 1234            2 KFIELDX UBIN(18) HALIGNED INIT(0),
 1235                          /*K*  KFIELDX.
 1236                          Word offset into the read-only segment of the
 1237                          start of FMG$KFIELD.                                    */
 1238            2 STARTX UBIN(18) HALIGNED INIT(0),
 1239                          /*K*  STARTX.
 1240                          Word offset into the read-only segment of the
 1241                          start of the FM$FIELD_START array. Elements of
 1242                          this array correspond to field elements in a
 1243                          VLP_RECFIELD structure and contain bit offsets
 1244                          from the start of a record to the start of a
 1245                          defined field, including necessary slack bits.*/
 1246            2 ACTPOS UBIN(18) HALIGNED INIT(0),
 1247                          /*K*  ACTPOS.  Contains the editing position
 1248                          within the input record when an M$READ operation
 1249                          to the user's terminal completed.  1 indicates
 1250                          the first character position in the record; 0
 1251                          indicates a position beyond the end of the record.
 1252                          */
 1253            2 AUTHFFLG REDEF ACTPOS,
 1254                          /*K*  AUTHFFLG.  Is a collection of access control
 1255                           flags set by M$OPEN when it processes account
 1256                      security checks and opens the DCB. These flags are different
 1257                      from those at F$DCB.FFLG in that they depend only on the
 1258                      access control settings, not on any other items in the DCB
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            35   
 1259                      (like F$DCB.FUN#).  This area is a REDEF of F$DCB.ACTPOS.
 1260                      */
 1261              3 READ# BIT(1) ,
 1262                          /*K*  AUTHFFLG.READ#.  If set, records may be read.
 1263                                                                                  */
 1264              3 DELR# BIT(1) ,
 1265                          /*K*  AUTHFFLG.DELR#.  If set, existing records may be
 1266                          deleted.                                                */
 1267              3 WNEW# BIT(1) ,
 1268                          /*K*  AUTHFFLG.WNEW#.  If set, new records may be written.
 1269                                                                                  */
 1270              3 UPD# BIT(1) ,
 1271                          /*K*  AUTHFFLG.UPD#.  If set, existing records may be
 1272                          updated (overwritten).
 1273                                                                                  */
 1274              3 DELF# BIT(1) ,
 1275                          /*K*  AUTHFFLG.DELF#.  If set, file may be deleted
 1276                           or its name, password, or access control may
 1277                           be changed (via these options on M$CLOSE:  DISP=RELEASE,
 1278                           NAME, PASS, ACCESS, or ACSVEH).
 1279                                                                                  */
 1280              3 NOLIST# BIT(1) ,
 1281                     /*K*  AUTHFFLG.NOLIST#.  If set, file appears not to exist.
 1282                                                                             */
 1283              3 REATTR# BIT(1) ,
 1284                     /*K*  AUTHFFLG.REATTR#.  If set, disk file attributes may be
 1285                     modified at M$CLOSE.
 1286                                                                             */
 1287              3 EXEC# BIT(1) ,
 1288                          /*K*  AUTHFFLG.EXEC#.  If set, DCB was opened by
 1289                          a system process(or) named in the access vehicle list
 1290                          for this file. It indicates (to such processes)
 1291                          that restricted access has been invoked and requires
 1292                          that subsequent operations through the DCB be done by the
 1293                          same process that opened it.
 1294                                                                                  */
 1295              3 CREATE# BIT(1),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            36   
 1296                          /*K*  AUTHFFLG.CREATE#.  If set, the opening user is
 1297                          permitted to create new files in the DCB's account.
 1298                          */
 1299              3 AU# BIT(1),
 1300                          /*K*  AUTHFFLG.AU#.  Meaningful for comgroups only.
 1301                          If set, this user is allowed to be the
 1302                          administrative user.
 1303                          */
 1304              3 AURD# BIT(1),
 1305                          /*K*  AUTHFFLG.AURD#.  Meaningful for comgroups only.
 1306                          If set, this user is allowed to issue monitor services
 1307                          normally reserved for the administrative user
 1308                          that examine but do not change the comgroup.            */
 1309
 1310              3 TCTL# BIT(1),
 1311                          /*K*  AUTHFFLG.TCTL#.  Meaningful for comgroups only.
 1312                          If set, this user is allowed to issue
 1313                          terminal control monitor services (such as M$PROMPT
 1314                          and M$STRMATTR).  For ORG=FPRG comgroups,
 1315                          M$SETFP is allowed.                                     */
 1316
 1317              3 * BIT(6),
 1318      2 DCB# UBIN(9) CALIGNED INIT(0), /* DCB number of this DCB                  */
 1319            2 * BIT(14) UNAL INIT('0'B),
 1320            2 ANSISPANSEQ# BIT(1) UNAL INIT(ANSISPANSEQ),
 1321                          /*K* ANSISPANSEQ = VALUE-BIT(1).
 1322                          .xeq F_CP6_C M$OPEN ANSISPANSEQ
 1323                          The default is YES, use ANSI spanning.
 1324                                          */
 1325            2 PATH,                 /* IOM/CHANNEL FOR CURRENT OPERATION          */
 1326              3 IOM# UBIN(3) UNAL INIT(0),
 1327                          /*K*  PATH.IOM#.  Logical IOM number for current
 1328                          operation for T & D DCBs.                               */
 1329              3 CHAN# UBIN(9) UNAL INIT(0),
 1330                          /*K*  PATH.CHAN#.  Channel number for current
 1331                          operation for T & D DCBs.                               */
 1332            2 IRRECX UBIN(18) HALIGNED INIT(0),
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            37   
 1333                          /*K*  IRRECX.
 1334                          Word offset into the read-only segment of the
 1335                          start of a VLP_IRREC structure describing the
 1336                          logical layout of fields in a record. This
 1337                          information is never used by file management, but
 1338                          only exists for the convenience of the user.            */
 1339            2 FLDID UBIN(18) HALIGNED INIT(0),
 1340                          /*K*  FLDID.  Contains the field
 1341                          ID reported by the most recent operation for an ORG=FORM
 1342                          DCB.  It is the same as that returned in KEY if
 1343                          KEYTYPE=FLDID, but is always returned here.  This is
 1344                          particularly useful for operations like M$DCLFLD that
 1345                          have no provision for returning a key.
 1346                          */
 1347            2 BADARS# REDEF FLDID UBIN(18) HALIGNED,
 1348                     /*K*  BADARS#.  In the event of an I/O error during a read or
 1349                      position operation when IOERROK is set, this field will
 1350                      contain the number of characters read or records positioned
 1351                      past, that were part of the tape block hit by the error.  In
 1352                      any event, ARS# will contain the total number of characters
 1353                      read or records processed.
 1354                      */
 1355            2 SEED# BIT(36) UNAL INIT(SEED),
 1356                          /*K* SEED = VALUE-BIT(36).
 1357                          .xeq F_CP6_C M$OPEN SEED
 1358                          The default is '0'B.
 1359                                                                                    */
 1360            2 * UBIN INIT(0),       /** USER AREA SPARE **/
 1361                                    /**********  WORK AREA  **********/
 1362                                    /**/
 1363                                    /****  NOT AVAILABLE TO USER  ****/
 1364      2 FEXT BIT(1) UNAL INIT('0'B), /* SET FOR FILE EXTENSION                    */
 1365      2 STARF BIT(1) UNAL INIT('0'B), /* SET IF STAR FILE                         */
 1366      2 SHARED BIT(1) UNAL INIT('0'B), /* SET IF SHARED FILE                      */
 1367      2 FMOD BIT(1) UNAL INIT('0'B), /* FILE HAS BEEN MODIFIED, POST FIT          */
 1368       2 GTYP UBIN(3) UNAL INIT(0), /* CONTROLS TYPE OF GRAN BEING READ           */
 1369        2 EOP UBIN(2) UNAL INIT(0), /* LAST OPERATION PERFORMED                   */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            38   
 1370                                    /* 3 = WRITE                                  */
 1371                                    /* 2 = PRECORD                                */
 1372                                    /* 1 = READ                                   */
 1373                                    /* 0 = OTHER                                  */
 1374            2 AMFLG,                /* INCOMPLETE MERGE OF ASSIGN/MERGE           */
 1375      3 ACCF BIT(1) UNAL INIT('0'B), /* ACCESS LIST IN AMR                        */
 1376      3 ACSF BIT(1) UNAL INIT('0'B), /* ACCESS VEHICLE IN AMR                     */
 1377      3 INSF BIT(1) UNAL INIT('0'B), /* INSTALLATION ATTR. IN AMR                 */
 1378      3 USRF BIT(1) UNAL INIT('0'B), /* USER ATTR. IN AMR                         */
 1379      3 SNLF BIT(1) UNAL INIT('0'B), /* SERIAL NO. LIST IN AMR                    */
 1380      3 PROF BIT(1) UNAL INIT('0'B), /* PROCESSOR ATTR. IN AMR                    */
 1381      2 SEZ_OK BIT(1) UNAL INIT('0'B), /* Passed flag                             */
 1382      2 MUST_CVOL BIT(1) UNAL INIT('0'B), /* CVOL before next write               */
 1383      2 NEW_FSECT BIT(1) UNAL INIT('0'B), /* New file section                     */
 1384      2 NOEOF BIT(1) UNAL INIT('0'B), /* File modified, no EOF labels             */
 1385      2 MOUNT REDEF NOEOF BIT(1) UNAL, /*N* DELETE THIS AFTER NTFM                */
 1386      2 OHDR BIT(1) UNAL INIT('0'B), /* IF SET, OVERRIDE HDR2 INFORMATION         */
 1387         2 LDFLG REDEF OHDR BIT(1), /* LOAD for files with alt indices            */
 1388      2 SPAN BIT(1) UNAL INIT('0'B), /* IF SET, SPANNED RECORD IN PROGRESS        */
 1389                               /* Also used if 1-gran keyed file was expanded.    */
 1390                                    /* Also used for UBLOCK consec file writes.   */
 1391         2 OWNER BIT(1) INIT('0'B), /* SET IF FIT NAME.ACCT=JIT NAME.ACCT         */
 1392                                    /* OR THIS DCB CREATED THE JOURNAL            */
 1393            2 RA BIT(1) INIT('0'B), /* SET IF READ-AHEAD PERMITTED                */
 1394          2 RPOS BIT(1) INIT('0'B), /* Controls record position                   */
 1395      2 STARX UBIN(3) UNAL INIT(0), /* SPECIAL STAR FILE INDEX                    */
 1396         2 CACHE BIT(1) INIT('0'B), /* Set if file gran was cached                */
 1397      2 ENQF BIT(1) UNAL INIT('0'B), /* ENQUEUE FLAG                              */
 1398         2 GRPOS BIT(1) INIT('0'B), /* RPOS for records within key                */
 1399          2 CONT BIT(1) INIT('0'B), /* SET IF NEXT WRITE IS TO CONTINUE           */
 1400       2 WAIT UBIN(1) UNAL INIT(1), /* SET IF USER SPECIFIED WAIT                 */
 1401       2 TRNC UBIN(2) UNAL INIT(0), /* 0 - no trunc, 1 - get buffer,              */
 1402                                    /*                2 - get buf/reread          */
 1403       2 AFTRBLK BIT(1) INIT('0'B), /* TAPE POSITIONED AFTER CURRENT BLOCK        */
 1404        2 LSTBLK BIT(1) INIT('0'B), /* CURRENT TAPE BLOCK IS LAST IN FILE         */
 1405            2 BORROW SBIN INIT(0),  /* For CREATE processes, this counts the      */
 1406                                    /* number of granules which can be borrowed   */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            39   
 1407                                    /* from a file to be released if the DCB      */
 1408                                    /* is closed with SAVE.                       */
 1409                               /* For UPDATE processes, this word is used to save */
 1410                                    /* BFR(1) during the creation of an AFIT      */
 1411       2 LASTKEY$ REDEF BORROW PTR, /* For keyed, SEQUEN tape files, pointer
 1412                                    to key of last record written (key in RO)     */
 1413       2 LASTKEY REDEF BORROW SBIN, /* For RANDOM, RESTRICT, IDS and RELATIVE
 1414                                    tape files, record # of last record written   */
 1415            2 FTAM REDEF BORROW,    /* For FTAM DCB, contains information sent to */
 1416                                    /* CASPER so he knows what to do next         */
 1417              3 CTX UBIN HALF UNAL, /* CASPER'S context number                    */
 1418              3 USR UBIN BYTE UNAL, /* DCB's user number.                         */
 1419              3 PMME UBIN(9) UNAL,  /* PMME code if from FMF, +100 if elsewhere   */
 1420        2 CFU$ PTR INIT(ADDR(NIL)), /* PTR TO CFU                                 */
 1421      2 TDALVL UBIN(3) UNAL INIT(0), /* LEVEL OF TDA (UPPER LEVEL TOP)            */
 1422        2 LVL UBIN(3) UNAL INIT(0), /* LVL OF GRAN TO BE READ BY REDBUF           */
 1423      2 LPOOL REDEF LVL UBIN(3) UNAL, /* Index of label processing buffer + 1     */
 1424      2 WRCMP BIT(1) UNAL INIT('0'B), /* COPY CFUA(CCT).ACCESS.WRCMP              */
 1425        2 WCDATA BIT(1) INIT('0'B), /* CFUA.ACCESS.WCDATA                         */
 1426         2 UCOUT BIT(1) INIT('0'B), /* Set if = M$UC for output                   */
 1427            2 TAPTYP,
 1428      3 RWASC BIT(1) UNAL INIT('0'B), /* Read/write ASCII data blocks             */
 1429      3 CP6F BIT(1) UNAL INIT('0'B), /* CP-6 format with FIT                      */
 1430      3 USRBUF BIT(1) UNAL INIT('0'B), /* Read/write from/into
 1431                                    user's buffer                                 */
 1432      3 HAVLASTKEY BIT(1) UNAL INIT('0'B), /* Have last key for
 1433                                    keyed, SEQUEN check                           */
 1434      3 NOCVOL BIT(1) UNAL INIT('0'B), /* Indicates no user CVOL control          */
 1435      3 MANAGED BIT(1) UNAL INIT('0'B), /* Indicates managed DEVICE tape          */
 1436      3 PASTFM BIT(1) UNAL INIT('0'B), /* Passed a file mark flag                 */
 1437              3 * BIT(2) UNAL INIT('0'B),
 1438            2 CRECX UBIN(18) UNAL INIT(0),
 1439                                    /* OFFSET TO CURRENT KEY OR RECORD CTL WD     */
 1440                                    /* INDEX INTO BFR1 CURRENT TAPE BLOCKING BUF  */
 1441            2 CBUFNUM UBIN(3) UNAL INIT(0),
 1442       2 IORG UBIN(6) UNAL INIT(0), /* INTERNAL FILE ORGANIZATION                 */
 1443       2 TDA UBIN(27) UNAL INIT(0), /* FILE REL DA OF INDEX GRAN AT TOP , ETC.    */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            40   
 1444      2 BYTESLEFT REDEF TDA UBIN(27) UNAL, /* Number of bytes left in record      */
 1445            2 CRECNO SBIN INIT(0),  /* CONSEC FILE CURRENT RECORD NUMBER          */
 1446            2 PRECNO SBIN INIT(0),  /* POSITIONING COUNT FOR TAPE                 */
 1447         2 CSEED REDEF PRECNO SBIN, /* INTERMEDIATE ENCRYPTION SEED               */
 1448      2 HASH UBIN(27) UNAL INIT(0), /* FILE NAME.ACCOUNT HASH                     */
 1449            2 FDCM UBIN(9) UNAL INIT(0),
 1450                                    /* NON-? MATCH FROM FD DURING OPEN INCRAC ACCT*/
 1451            2 FCN(0:1),             /* NO-WAIT AND WAIT FUNCTION COUNTS           */
 1452        3 F BIT(1) INIT('0'B,'0'B), /* SET BY SCHEDULER IF USER IS REG'D          */
 1453      3 CNT UBIN(8) UNAL INIT(0,0), /* # OUTSTANDING I/O OPERATIONS               */
 1454            2 BLKLEN UBIN(18) UNAL INIT(0),
 1455                                    /* ARS FROM TAPE BLOCK READ                   */
 1456         2 UB$ PTR INIT(ADDR(NIL)), /* USER BUFFER POINTER                        */
 1457            2 UBYTES UBIN INIT(0),  /* # BYTES IN USER BUFFER                     */
 1458      2 FSECT UBIN(18) UNAL INIT(0), /* CURRENT FILE SECTON NUMBER                */
 1459      2 INDX REDEF FSECT UBIN(18) UNAL, /* Last index used                        */
 1460      2 FPSTR UBIN(9) UNAL INIT(0), /* TEMP stream used for ORG=FPRG              */
 1461       2 STR# UBIN(9) UNAL INIT(0), /* Stream number for dcb                      */
 1462            2 NRECX UBIN(18) UNAL INIT(0),
 1463                                    /* NO. OF RECORDS DEBLOCKED FROM CURRENT BUF  */
 1464      2 MODCNT REDEF NRECX UBIN(18) UNAL,/* UPDATE COUNT FOR SHARED FILES         */
 1465      2 SEGX UBIN(18) UNAL INIT(0), /* Position of SEG$ for keyed files           */
 1466            2 GDISP UBIN INIT(0),   /* CONT OPTION CURRENT POSITION               */
 1467            2 LOGSEC BIT(1) UNAL INIT('0'B),
 1468                                    /* Security log indicator. Reset at the
 1469                                       start of an open. Set if security
 1470                                       logging performed during the open. Once
 1471                                       set, no further logging will be done
 1472                                       during the open.                           */
 1473       2 PRIVOPN BIT(1) INIT('0'B), /* Privilege has incremented FFLG during
 1474                                    this open (used for security logging).        */
 1475            2 OLDIOERR UBIN(2) UNAL INIT(0),
 1476                                    /* State of I/O error handling when IOERROK was
 1477                                       set:
 1478                                            0 - No previous I/O error for this file.
 1479                                            1 - Hit I/O error, still on bad block.
 1480                                            2 - 1 block past error.
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            41   
 1481                                            3 - Still in same file.               */
 1482            2 * BIT(21) UNAL INIT('0'B),
 1483            2 REALSPAN BIT(1) UNAL,
 1484                                    /* flag for span information. Used to
 1485                                       reduce amount of processing:
 1486                                       '1'B:  True ANSI format used,
 1487                                              Default is true ANSI.
 1488                                       '0'B:  IBM ANSI spanning used.             */
 1489      2 DECRYPT BIT(1) UNAL INIT('0'B), /* DECRYPT USER BUFFER AFTER READ         */
 1490      2 PGINGRAN UBIN BYTE UNAL INIT(0), /*PAGES IN CURRENT SYMB GRANULE*/
 1491       2 IFMT UBIN(9) UNAL INIT(0), /* Internal number for caseing various
 1492                                    types of DCB assignments.  See F_FMTCODE_C.   */
 1493      2 MEDIA UBIN(9) UNAL INIT(0), /* Type of media to which DCB
 1494                                    is assigned.  See F_FMTCODE_C.                */
 1495            2 IWL,             /* I-Was-Last; i.e., this DCB's formatting was     */
 1496                                    /* what the media was most recently sent.     */
 1497         3 TABIWL BIT(1)INIT('0'B), /* My Tabs were last                          */
 1498         3 SEQIWL BIT(1)INIT('0'B), /* My Sequencing was last                     */
 1499         3 HDRIWL BIT(1)INIT('0'B), /* My Page Headers were last                  */
 1500              3 * BIT(3)INIT('0'B),
 1501       2 CTLCMDIN BIT(1)INIT('0'B), /* Control Commands come from here            */
 1502      2 UNIQUEBLD BIT(1) UNAL INIT('0'B), /* INDICATES THAT UNIQUE
 1503                                    INDEXES NEED TO BE REBUILT                    */
 1504        2 UPDCNT BIT(1) INIT('0'B), /* DCB IS COUNTED IN CFUEXT.UPDCNT            */
 1505       2 IASN UBIN(9) UNAL INIT(0), /* WHICH MEDIUM IT GOES TO                    */
 1506         2 MOVED SBIN(18) HALIGNED, /* NUMBER OF WORDS KEY TABLE MOVED            */
 1507            2 * UBIN(9) CALIGNED,
 1508            2 CX UBIN(9) CALIGNED,
 1509            2 CWORD CHAR(4) ALIGNED,
 1510            2 RCSZ UBIN INIT(0),    /* TEMP FOR UBLOCK WRITES                     */
 1511            2 FEPSIZ REDEF RCSZ,    /* Sizes for no wait communication read       */
 1512              3 BUF UBIN HALF UNAL,
 1513              3 KEY UBIN HALF UNAL,
 1514            2 ID ALIGNED,           /* FOR REPOSITIONING IN SHARED FILES          */
 1515              3 GX UBIN(10) UNAL,
 1516              3 DA UBIN(26) UNAL,
 1517            2 FEPIO,           /* This area used for no wait reads from the FEP   */
07:12 JUL 29 '97 F_DCB_C.:E05SI                                            42   
 1518              3 EVENT UBIN INIT(0), /* The event number to report                 */
 1519              3 %CHARTEXT('KEYX/*') KEYX %CHARTEXT('*/')
 1520        UBIN HALF HALIGNED INIT(0), /* Key offset in $LS116 page                  */
 1521      3 BUFX UBIN HALF HALIGNED INIT(0), /* cOffset of buffer into $LS116         */
 1522      3 BPP(0:1) BIT(18) INIT('0'B*0), /* Phys Page#s to map data buffer          */
 1523      3 KPP(0:1) BIT(18) INIT('0'B*0), /* Phys Page#s to map key buffer           */
 1524            2 AGE SBIN INIT(0),
 1525                                    /* INDICATION OF RECENTNESS OF USE (J$CALCNT)*/
 1526                               /* LAST CAL TO THIS DCB. USED IN TRUNC DECISION    */
 1527            2 BFR(0:4) ,            /* FILE MANAGEMENT BUFFERS                    */
 1528       3 BUFUP BIT(1) INIT('0'B*0), /* HAS BEEN UPDATED                           */
 1529       3 SCRUB BIT(1) INIT('0'B*0), /* SCRUB AVAILABLE SPACE                      */
 1530        3 CHNG BIT(1) INIT('0'B*0), /* SET IF BUFFER HAS BEEN WRITTEN             */
 1531         3 CVM BIT(1) INIT('0'B*0), /* SET IF THIS BUFFER IS CVM'ED               */
 1532      3 BUFX UBIN(5) UNAL INIT(0*0), /* Buffer number                             */
 1533      3 DA UBIN(27) UNAL INIT(0*0), /* DISK ADDR FOR THIS BUFFER                  */
 1534            2 BFR1(0:4) ALIGNED,    /* ADDITIONAL POOL BUFFER TABLES              */
 1535              3 FLAGS,              /* Easy to zap                                */
 1536      4 ONE_WORD_HEADER BIT(1) INIT('0'B*0), /* Granule has 1wd hdr               */
 1537                4 * BIT(8) INIT('0'B*0),
 1538      3 SIZ UBIN(9) UNAL INIT(0*0), /* SIZE OF BUFFER IN PAGES                    */
 1539      3 CX UBIN(18) UNAL INIT(0*0), /* CACHE INDEX OF BUFFER                      */
 1540       2 FEPIO2 (0:3) UBIN ALIGNED, /* FEPIO data for 2nd fep I/O, or SPARES      */
 1541       2 FEPIO3 (0:3) UBIN ALIGNED, /* FEPIO data for third fep I/O, or SPARES    */
 1542            2 * SBIN INIT(29127),   /* FUNNY # FOR MUNGER                         */
 1543            2 DCBNAME DALIGNED,
 1544              3 X UBIN(3) UNAL,     /* COMMAND LINE DCB#                          */
 1545              3 S BIT(1) UNAL,      /* SCRUB AT THIS DCB AT JOBSTEP?              */
 1546              3 L UBIN(5) UNAL,
 1547      3 N CHAR(DCBN.DCBNAME.L) UNAL; /* DCBNAME FOLLOWS THE DCB ITSELF            */
 1548      %MEND;

