

13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         1    
    1      /*M*	dib.h - DIB includes 				*/
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* DDA */
    8
    9      #define Q_BASE 		0xf20000	/* Locate queues in I/O memory	*/
   10      #define Q_LIM		0xf40000	/* Upper limit of I/O memory    */
   11
   12      #define VMEVCTRREG	0xf40040	/* VME vector number register */
   13      #define VMEVCTR		100		/* VME vector number		*/
   14      #define VMEINT		0xf40080	/* VME interrupt trigger	*/
   15      #define RAMADRREG	0xf400c0	/* Local RAM buffer address 	*/
   16      #define DCIADRREG	0xf40100	/* DCI buffer address		*/
   17      #define DCISTTREG	0xf40140	/* DCI Status register		*/
   18      #define DCISTTRST	0xf40180	/* Reset DCI status interrupt	*/
   19      #define TCREG		0xf40200	/* Transfer counter		*/
   20      #define CTLREG		0xf40240	/* Control Register		*/
   21      #define FIFOREG		0xf40280	/* FIFO				*/
   22
   23      #define RDCSCSVC	0x7001		/* Read CSC service code	*/
   24      #define RDCLCSCSVC	0x7401		/* Read and clear CSC service	*/
   25      #define WRCSCSVC	0xb801		/* Write CSC service code	*/
   26      #define INTCSCSVC	0x5801		/* Interrupt CSC service code	*/
   27      #define RSTSVC		0x0081		/* Reset service code, unmask 	*/
   28      #define RSTSVCM		0x0001		/* Reset service code, masked	*/
   29      #define RSTCON		0x0005		/* Set RST_CON			*/
   30
   31      #define VCTRBASE	0xf00000	/* Interrupt vector base	*/
   32      #define CNCTVCTR	0xf00078	/* Connect vector		*/
   33      #define STTVCTR		0xf00074	/* DCI Status vector		*/
   34      #define BERRVCTR	0xf00070	/* Bus error vector		*/
   35      #define TCVCTR		0xf0006c	/* Trnasfer count runout vector */
   36
   37      #define RAMBASE		0xf20000	/* Ram buffer base address	*/
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         2    
   38      #define dib_adr(q)	(long *)(RAMBASE+q) /* buffer address macro     */
   39
   40      #define BINMDE		0		/* Binary transfer mode		*/
   41      #define ASCIMDE		1		/* ASCII transfer mode		*/
   42
   43      struct duart {
   44      	long	o_xxxx[1];
   45      	long	o_stat;
   46      	long	o_cra;
   47      	long	o_data;			/* Rx/Tx holding registers	*/
   48      	};
   49
   50      #define DUART ((struct duart *)0xf40000)
   51      #define RXRDY 0x00000001
   52      #define TXRDY 0x00000004
   53
   54      /*	DCI STATUS indicators						*/
   55
   56      #define DC_OPL		0x0001
   57      #define DC_TEST		0x0002
   58      #define CONNECT		0x0004
   59      #define DC_INIT		0x0008
   60      #define SYS_FLT		0x0010
   61      #define CMD_PAR_ERR	0x0020
   62      #define DTA_PAR_ERR	0x0040
   63      #define IOM_PAR_ERR	0x0080
   64      #define U_BUS_PAR_ERR	0x0100
   65
   66
   67      #define TERMINAL_ID_LEV_NONE_ 0  /* Use TERM_NAME                    */
   68      #define TERMINAL_ID_LEV_CHAN_ 1  /* Use just channel                 */
   69      #define TERMINAL_ID_LEV_SUBCHAN_ 2  /* Use just channel and subchannel*/
   70      #define TERMINAL_ID_LEV_SUBSUBCHAN_ 3  /* Use just channel,subchannel and subsubchannel */
   71      struct b_terminal_id{
   72               unsigned ttyp : 8;
   73                          /*K* TTYP = OPTION.  Specifies the terminal type.
   74                          EQUs for terminal types which begin with the
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         3    
   75                          prefix KLTY_ are available in KL_SUPER_C.:LIBRARY.
   76                          */
   77               unsigned lev : 8;
   78                          /*K* LEV = {1|2|3}.
   79                          Specifies whether TERM.SUBDEVICE
   80                          and TERM.SUBSUBDEVICE are meaningful.
   81
   82                     1 - TERM.SUBDEVICE and TERM.SUBSUBDEVICE are not meaningful
   83                     2 - TERM.SUBDEVICE is meaningful; TERM.SUBSUBDEVICE
   84                     }   is not meaningful
   85                     3 - TERM.SUBDEVICE and TERM.SUBSUBDEVICE are meaningful
   86
   87                     For HASP stations,LEV=2,i.e.,TERM.SUBDEVICE is
   88                     valid.  For IBM 3270-like devices,LEV=3;
   89                     TERM.SUBDEVICE identifies the controller and
   90                     TERM.SUBSUBDEVICE identifies a specific 3270-like
   91                     terminal device.
   92                     */
   93                  unsigned short channel;
   94                          /*K* TERM.CHANNEL = VALUE-DEC(0-65535).
   95                          Specifies the port to which the terminal is most directly
   96                          connected.
   97                          */
   98                  unsigned short subdevice;
   99                          /*K* TERM.SUBDEVICE = VALUE-DEC(0-65535).
  100                          Specifies the controller for the terminal (if any).
  101                          */
  102                  unsigned short subsubdevice;
  103                          /*K* TERM.SUBSUBDEVICE = VALUE-DEC(0-65535).
  104                          Specifies the device port through which the
  105                          terminal is connected to its controller.
  106                          */
  107                  char term_name[8];
  108                          /*K* TERM.TERM_NAME = VALUE-CHAR(8).
  109                          Specifies the LINE name specified to SUPER by the
  110                          system manager.
  111                          */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         4    
  112      };
  113      /*M* KL_MACRO_C Structures for HOST LOGON */
  114
  115
  116
  117                  /**********************************************/
  118                  /*F* NAME:      KL_RQSCHN                     */
  119                  /**********************************************/
  120      /**/
  121      /* KL_RQSCHN - Message sent from the Node Administrator to the
  122                     Network Manager,requesting information on a given
  123                     channel.
  124      */
  125      struct kl_rqschn{
  126           unsigned fcn : 8;
  127            /*K* FCN  Defines the type of function we are performing
  128            */
  129          unsigned  line_profile : 1;
  130            /*K* LINE_PROFILE  If set,this is a request for line profile
  131                               info for the specified terminal ID.
  132            */
  133          unsigned  config : 1;
  134            /*K* CONFIG  If set,this is a request for config info for
  135                         the specified terminal ID.
  136            */
  137          unsigned  dflthnd : 1;
  138            /*K* DFLTHND  If set,this is a request for the default info
  139                          for the handler whoose name is in HANDLER
  140            */
  141         unsigned  dfltchn : 1;
  142            /*K* DFLTCHN  If set,this specifies that default channel info
  143                          for this channel is to be sent via a CHNRSP
  144                          message
  145            */
  146         unsigned  scndcnfg : 1;
  147      /*K* SCNDCNFG - if set indicates that 2 config records exist in
  148           :NETCON for the indicated channel.  The record keyed off of
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         5    
  149           the terminal name will be super imposed on top of the the
  150           record keyed of the channel number.  This can cause unpredicable
  151           results and should therefore be avoided
  152      */
  153         unsigned  x : 3;
  154         char handler[8];
  155            /*K* HANDLER  Must be set on any but DFLTCHN,and returned in the
  156                          responce.
  157            */
  158      	struct b_terminal_id termid;
  159
  160        unsigned l : 8;
  161        char txt[100];
  162            /*K* SIGNON - If this is a request for LINE_PROFILEthis is optionally
  163                          set to indicate the remote signon string */
  164      };
  165
  166
  167                  /**********************************************/
  168                  /*F* NAME:      KL_HNDCMN_INFO                */
  169                  /**********************************************/
  170      /* KL_HNDCMN_INFO - This structure contains info on the KH_S_CHN fields that
  171                          are settable via NETCON.  This macro is used to generate
  172                          the KHA portion of the KL_S_LINCNFG structure that is
  173                          stored in :NETCON.  This structure is also stuffed into
  174                          the MESSAGE portion of the KL_EXTCHNRSP message in
  175                          response to a KL_RQSCHN with DFLTHND or CONFIG set.
  176      */
  177      struct kl_hndcmn_info{
  178               unsigned  flwcntrl : 2;
  179               unsigned  inp : 2;
  180               unsigned  otp : 2;
  181               unsigned  brkrq : 2;
  182               unsigned  re_enb : 2;
  183               unsigned  hard : 2;
  184               unsigned  clk : 2;
  185               unsigned  drpdtr : 2;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         6    
  186               unsigned  dbg : 2;
  187               unsigned  rmthst : 2;
  188               unsigned  speed_auto : 2;
  189               unsigned  enb : 2;
  190               unsigned  dsbhstdwn : 2;
  191               unsigned  kllhstdwn : 2;
  192               unsigned  x : 2;
  193               unsigned  x1 : 2;
  194                 short  bufsize;
  195                 short  delay;
  196                 short  redtimeout;
  197                 short  tptimout;
  198                 short  block;
  199                 short  unblock;
  200                 short  speed;
  201      };
  202
  203                  /**********************************************/
  204                  /*F* NAME:      KL_NA_INFO                    */
  205                  /**********************************************/
  206      /* KL_NA_INFO - This structure contains the Node Admin info that is settable
  207                      via NETCON.  This macro is used to generate the NA portion
  208                      of the KL_S_LINCNFG structure that is stored in :NETCON.
  209                      This structure is also stuffed into the NA field of the
  210                      KL_CHNRSP structure that is returned in responce to a
  211                      KL_RQSCHN with DFLTCHN set.
  212      */
  213      struct kl_na_info{
  214               unsigned  sndslt : 2;
  215               unsigned  echlgn : 2;
  216               unsigned  autlgn : 2;
  217               unsigned  rmtdbg : 2;
  218               unsigned  respres : 1;
  219               unsigned  attrpres : 1;
  220               unsigned  x : 2;
  221               unsigned  profile : 2;
  222               unsigned  cnfg_exists : 1;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         7    
  223               unsigned  x1 : 1;
  224               short  lgntimout;
  225               unsigned short attr;
  226               short res;
  227      };
  228
  229
  230                  /**********************************************/
  231                  /*F* NAME:      KL_CHNRSP                  */
  232                  /**********************************************/
  233      /* KL_CHNRSP - This strucutre is passed by the network manager
  234                        to node admin,and by node admin to handler common
  235                        in responce to a KL_RQSCHN message with any but the
  236                        default channel bit set.
  237      */
  238      struct kl_chnrsp{
  239               unsigned fcn : 8;
  240            /*K* FCN  Indicates the function being performed
  241            */
  242               unsigned  line_profile : 1;
  243            /*K* LINE_PROFILE  If set,this is a responce with line profile
  244                               info for the specified terminal ID.
  245            */
  246               unsigned  config : 1;
  247            /*K* CONFIG  If set,this is a responce with config info for
  248                         the specified terminal ID.
  249            */
  250               unsigned  dflthnd : 1;
  251            /*K* DFLTHND  If set,this is a responce with default info
  252                          for the handler whoose name is in HANDLER
  253            */
  254               unsigned  nak : 1;
  255            /*K* NAK  If set,the requested information is not available
  256                      for this terminal I.D.
  257            */
  258               unsigned  scndcnfg : 1;
  259      /*K*  SCNDCNFG - If set indicates this channel config is keyed off
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         8    
  260            of the node,channel and subdevices and not the term name.  Only
  261            applies to channels which have terminal names associated
  262      */
  263               unsigned  x : 3;
  264               char handler[8];
  265            /*K* HANDLER  Must be sent to indicate which handler the responce
  266                          is to be sent to.
  267            */
  268      struct b_terminal_id termid;
  269
  270      struct kl_na_info na;
  271
  272      struct kl_hndcmn_info hndcmn;
  273
  274      unsigned  char msgsize[2];
  275      char message[1] ;
  276              /*K* The data being passed
  277              */
  278
  279
  280      };
  281
  282                  /**********************************************/
  283                  /*F* NAME:      KL_HDR                        */
  284                  /**********************************************/
  285      		struct kl_hdr{
  286              unsigned code : 8;
  287              unsigned type : 8;
  288             unsigned srce_node : 8;
  289              unsigned dest_node : 8;
  290             char handler[8]; /* Which handler this is for */
  291              char origin[8]; /* NETCON station */
  292             char node[8]; /* Node that this is for */
  293      	int results;
  294            unsigned  msg_n_ : 16;
  295      };
  296      /*
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         9    
  297       *		kl_rue
  298       */
  299
  300      struct kl_rue {
  301      	struct kl_hdr hdr;
  302      	unsigned short sysid; /* aka pid */
  303      	unsigned char event;
  304      	};
  305
  306
  307                  /**********************************************/
  308                  /*F* NAME:      KL_CNFG_MSG                   */
  309                  /**********************************************/
  310      /* KL_CNFG_MSG - This strucutre is passed by the network manager
  311                       to node admin for on-the-fly CONFIG requests from
  312                       NETCON.  Part of the message is handled by Node
  313                       Admin,and the other part is passed on to the
  314                       appropriate handler.
  315      */
  316      struct kl_cnfg_msg{
  317      struct kl_hdr hdr;
  318
  319      struct b_terminal_id termid_lo;
  320
  321      struct b_terminal_id termid_hi;
  322
  323      struct kl_hndcmn_info kha;
  324
  325      struct kl_na_info na;
  326
  327      };
  328                  /**********************************************/
  329                  /*F* NAME:      KL_RQSPROFILE                 */
  330                  /**********************************************/
  331      /* KL_RQSPROFILE is sent to the Network Manager from Node Admin.  This
  332      is a request for the profile that has been established for a line or a
  333      handler via NETCON.                */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         10   
  334      struct kl_rqsprofile{
  335               unsigned fcn : 8;
  336            /*K* FCN  Indicates the function being performed.
  337            */
  338               unsigned x1 : 24;
  339      	struct b_terminal_id termid;
  340
  341              unsigned char nmid[4];
  342              char handler[8];
  343      };
  344
  345                  /**********************************************/
  346                  /*F* NAME:      KL_SGN                        */
  347                  /**********************************************/
  348      /* KL_SGN is sent by the Node Administrator to the Network Manager
  349         with information about the logon string for a device logging
  350         on.
  351      */
  352      struct kl_sgn{
  353               unsigned fcn : 8;
  354            /*K* FCN  Indicates the function being performed.
  355            */
  356               unsigned node : 8;
  357            /*K* NODE The node the user is attempting to log on to.
  358            */
  359                unsigned x : 8;
  360              unsigned def_node : 8;
  361      	struct b_terminal_id termid;
  362
  363               unsigned  autolgn : 1;
  364            /*K* AUTOLGN  If set,this is an autologon request and the
  365                          string should be ignored.
  366            */
  367               unsigned  profile : 1;
  368            /*K* PROFILE  If set,a profile was specified on the channel
  369                          so do not send the default profile
  370            */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         11   
  371               unsigned  x1 : 6;
  372             	unsigned sysid : 16;
  373       	char nmid[4];
  374
  375            /*K* NMID  This is passed to the network manager,so that it
  376                       can send it back to node admin to identify NAs context
  377                       for this logon attempt.
  378             */
  379        unsigned speed : 8;
  380            /*K* SPEED  The encoded speed of the device attempting logon.
  381            */
  382        unsigned x2 : 8;
  383        unsigned char lgnsiz;
  384        char lgntxt[100] ;
  385      };
  386
  387                  /**********************************************/
  388                  /*F* NAME:      KL_SGNRSP                     */
  389                  /**********************************************/
  390      /* KL_SGNRSP is sent by the Network Manager to the Node Administrator
  391         with information about the success or failure of a devices logon
  392         attempt.
  393      */
  394      struct kl_sgnrsp{
  395           unsigned char fcn;
  396            /*K* FCN  Indicates the function being performed.
  397            */
  398           unsigned  resource : 1;
  399            /*K* RESOURCE  If set,indicates that the device attempting
  400                           logon is a network resource.
  401            */
  402          unsigned  x : 7;
  403          unsigned  char nmid[4];
  404            /*K* NMID  This is passed to the network manager,so that it
  405                       can send it back to node admin to identify NAs context
  406                       for this logon attempt.
  407             */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         12   
  408      	struct rlcid {
  409                 unsigned char node;
  410              /*K* NODE  The node this device is logging on from
  411              */
  412                 unsigned char generation;
  413              /*K* GENERATION  The version of the running software
  414              */
  415                 unsigned short ldctx;
  416              /*K* LDCTX The LDCT index of the LDCT in the host to connect to
  417              */
  418      			} rlcid;
  419      	int errcode;
  420
  421      	struct b_terminal_id termid;
  422
  423        unsigned cos : 8;
  424                 unsigned char rspsiz;
  425                 char rsptxt[1] ;
  426      };
  427
  428                  /**********************************************/
  429                  /*              KL_AUTOFAIL                   */
  430                  /**********************************************/
  431
  432                  /**********************************************/
  433                  /*F* NAME:      KL_PRFRSP                     */
  434                  /**********************************************/
  435      /* KL_PRFRSP - Message sent from the Network Manager to the Node Administrator
  436                     with the profile for the user attempting logon
  437      */
  438      struct kl_prfrsp{
  439               unsigned fcn : 8;
  440            /*K* FCN  Indicates the function being performed.
  441            */
  442              unsigned  imp : 1;
  443              unsigned  more : 1;
  444               unsigned  x : 6;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         13   
  445               unsigned  char nmid[4];
  446            /*K* NMID  This is passed to the network manager,so that it
  447                       can send it back to node admin to identify NAs context
  448                       for this logon attempt.
  449             */
  450
  451      struct profile {
  452                 unsigned  prfsize : 16;
  453              /*K* PRFSIZE Number of bytes in the passed profile
  454              */
  455                char prftxt[1] ;
  456              /*K* PRFTXT The profile itself
  457              */
  458      			}profile;
  459
  460      };
  461
  462                  /**********************************************/
  463                  /*F* NAME:      KL_CONFIGRQS                  */
  464                  /**********************************************/
  465      /* KL_CONFIGRQS - Message sent from the Network Manager to the Node Administrator
  466                        requesting the configuration of a given channel and its
  467                        controller.
  468      */
  469      struct kl_configrqs{
  470                unsigned fcn : 8;
  471                  /*K* FCN  Indicates the function being performed. */
  472               unsigned x1 : 24;
  473               unsigned  msgid : 32;
  474                  /*K* MSGID = VALUE-DEC(0-?) specifies a unique value
  475                  associated with this message. */
  476               unsigned node : 8;
  477                  /*K* NODE = VALUE-DEC(0-255). Specifies the node number of
  478                  the node this information is being requested of. NODE is
  479                  overridden by non-blank NODENAME. */
  480               unsigned src_node : 8;
  481                  /*K* SRC_NODE = VALUE-DEC(0-255). Specifies the node number of
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         14   
  482                  the node requesting this information. */
  483                unsigned x2 : 16;
  484               char nodename[8];
  485                  /*K* NODENAME = VALUE-CHAR(8). Specifies the name of the
  486                  node this request is directed to. If this is all blanks,
  487                  this request is directed at node,NODE instead. */
  488               unsigned short channel;
  489                  /*K* CHANNEL  The channel the information is being requested for */
  490      };
  491
  492
  493                  /**********************************************/
  494                  /*F* NAME:      KL_NETERR                     */
  495                  /**********************************************/
  496      /* KL_NETERR - A structure used to contain a network error code with
  497                     enough information in it to distinguish between a HOST
  498                     error code and a FEP error code. */
  499      struct kl_neterr{
  500             unsigned  hosterr : 1;
  501                  /*K* HOSTERR = {YES|NO};. If set,indicates that ERR
  502                  contains an errcode in HOST form; if reset,indicates that
  503                  ERR.L6 contains an errcode in L6 form. */
  504             unsigned  x : 7;
  505      		struct err {
  506                        unsigned x : 8;
  507               			unsigned  l6 : 32;
  508      				} err;
  509                  /*K* L6 = An errcode in L6 form. See HOSTERR. */
  510      };
  511
  512                  /**********************************************/
  513                  /*F* NAME:      KL_CONFIGRSP                  */
  514                  /**********************************************/
  515      /* KL_CONFIGRSP - Message sent from the Node Administrator to the Network Manager
  516      */
  517      struct kl_configrsp{
  518               unsigned fcn : 8;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         15   
  519                  /*K* FCN  Indicates the function being performed. */
  520               unsigned x1 : 24;
  521              unsigned  msgid : 32;
  522                  /*K* MSGID = VALUE-DEC(0-?) specifies a unique value
  523                  associated with this message. */
  524              unsigned node : 8;
  525                  /*K* NODE = VALUE-DEC(0-255)  specifies the node number to
  526                  return this information to. */
  527              unsigned ctlr_status : 8;
  528                  /*K* CTLR_STATUS = VALUE-DEC(0-?) specifies the current state of
  529                  this channel's controller. */
  530              unsigned status : 8;
  531                  /*K* STATUS  The current state of this channel. */
  532               unsigned x : 8;
  533              unsigned  dvcid : 16;
  534                  /*K* DVCID  The device I.D. (hardware) of the device attached to
  535                  the channel. */
  536              unsigned  extdvcid : 16;
  537                  /*K* EXTDVCID The extended device I.D. of the device
  538                  attached to the channel. */
  539               unsigned x2 : 16;
  540      struct kl_neterr neterr;
  541
  542      };
  543
  544      /*F* NAME: KL_SETNODE
  545
  546      The KL_SETNODE macro gererates the structure
  547      for the message that is passed between the
  548      Network Manager on the host (SLUG) and BABOON
  549      on the FEP to set the node number and the name.
  550      */
  551
  552      struct kl_setnode{
  553               unsigned fcn : 8;
  554                  /*K* FCN  Indicates the function being performed. */
  555               unsigned x1 : 16;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         16   
  556              unsigned  my_node : 1;
  557                /*K* MY_NODE = (YES | NO). If this is yes it specifies
  558                          the node name for this node.  If no it specifies
  559                          the node name for some other node.
  560       */
  561              unsigned  host_node : 1;
  562                /*K* HOST_NODE = {YES | NO};. This specifies of the node
  563                is an host or not.
  564       */
  565              unsigned  invalid : 1;
  566           /* bit to indicate to nodeadmn whether the network table from
  567              slug is valid.  If not nodeadmn will use the host slug
  568              to do logon parsing */
  569               unsigned  x : 5;
  570              unsigned int nodeno;
  571                  /*K* NODE_N_ = VALUE-DEC(0-?) specifies the NODE_N_ of
  572                     this host */
  573              char node_name[8];
  574                /*K* NODE_NAME contains the node name for the host */
  575      };
  576
  577
  578                 /*F* NAME:      KL_STRTU
  579
  580                 The KL_STRTU macro generates the structure for the
  581                 message that is sent to NA requesting that a FEP
  582                 user be created.
  583
  584                 The fields in the KL_STRTU structure are:
  585                 */
  586
  587      struct kl_strtu{
  588               unsigned fcn : 8;
  589                          /*K* FCN - UBIN.
  590                          Contains the function code that indicates that
  591                          the message is a syslog message.  This value is
  592                          %IGA_STRTU (27) from the KL_AFCN_C include file.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         17   
  593                          */
  594              unsigned node : 8;
  595                          /*K* NODE - UBIN.
  596                          Contains the destination node number.
  597                          */
  598
  599                unsigned from_node : 8;
  600                unsigned from_generation : 8;
  601                unsigned  from_ldx : 16;
  602                          /*K* NETADR_FROM.
  603                          .XEQ G_JIT_M G_S_JIT HOST_NA
  604                          */
  605
  606
  607                unsigned to_node : 8;
  608                unsigned to_generation : 8;
  609                unsigned  to_ldx : 16;
  610                          /*K* NETADR_TO.
  611                          .XEQ G_JIT_M G_S_JIT FEP_NA
  612                          */
  613
  614              char uname[12];
  615                          /*K* UNAME - CHAR(12).
  616                          .XEQ G_JIT_M G_S_JIT UNAME
  617                          */
  618              char acct[8];
  619                          /*K* ACCT - CHAR(8).
  620                          .XEQ G_JIT_M G_S_JIT ACCN
  621                          */
  622              char db_acct[8];
  623                          /*K* DB_ACCT - CHAR(8).
  624                          .XEQ G_JIT_M G_S_JIT DB_ACCN
  625                          */
  626
  627              unsigned mode : 8;
  628                          /*K* MODE - UBIN.
  629                          .XEQ G_JIT_M G_S_JIT MODE
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         18   
  630                          */
  631
  632              unsigned str : 8;
  633                          /*K* STR - UBIN.
  634                          ????
  635                          */
  636
  637              unsigned  mrt : 32;
  638
  639                          /*K* MRT - UBIN.
  640                          .XEQ G_JIT_M G_S_JIT MRT
  641                           expressed how?  converted how?
  642                          */
  643
  644              unsigned  priv : 32;
  645                          /*K* PRIV - UBIN.
  646                          .XEQ G_JIT_M G_S_JIT PRIV.AUTH
  647                          */
  648
  649              unsigned  ppriv : 32;
  650                          /*K* PPRIV - UBIN.
  651                          .XEQ G_JIT_M G_S_JIT PPRIV
  652                          */
  653
  654              unsigned  mem : 16;
  655                          /*K* MEM - UBIN.
  656                          .XEQ G_JIT_M G_S_JIT MAXMEM
  657                          */
  658              unsigned ints : 8;
  659                          /*K* INTS - UBIN.
  660                          .XEQ G_JIT_M G_S_JIT MAXINTS
  661                          */
  662              unsigned macctfprg : 8;
  663                          /*K* MACCTFPRG - UBIN.
  664                          .XEQ GFR_DATA_M GFR_S_ACCT MAX_FPRGS
  665                          */
  666
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         19   
  667              unsigned  macctmem : 16;
  668                          /*K* MACCTMEM - UBIN.
  669                          .XEQ GFR_DATA_M GFR_S_ACCT MAX_MEM
  670                          */
  671
  672              char pseudo_name[8][8];
  673                          /*K* PSEUDO_NAME - ARRAY(0:7) CHAR(8).
  674                          Contains the name of each pseudo resource that
  675                          may be allocated by this user.
  676                          */
  677
  678              unsigned  char pseudo_max[8][2];
  679                          /*K* PSEUDO_MAX - ARRAY(0:7) UBIN.
  680                          .XEQ G_JIT_M G_S_JIT MAXSUDO
  681                          */
  682
  683              char bill[6];
  684                          /*K* BILL - CHAR(6).
  685                          .XEQ G_JIT_M G_S_ACC BILL
  686                          */
  687      			struct hname{
  688
  689                unsigned l : 8;
  690                char c[31];
  691                          /*K* HNAME - CHAR(6).
  692                          ?? where is this suppose to go??
  693                          */
  694      			}hname;
  695              char lang;
  696                          /*K* LANG - UBIN.
  697                          .XEQ G_JIT_M G_S_JIT LANG
  698                          */
  699      			struct flags {
  700                unsigned  stepacct : 1;
  701                          /*K* STEPACCT - BIT(1).
  702                          .XEQ G_JIT_M G_S_JIT JUNK.STEPACCT
  703                          */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         20   
  704                 unsigned  x : 7;
  705      			}flags;
  706      };
  707
  708      /*F* NAME: KL_FEPST
  709
  710      */
  711
  712      struct kl_fepst{
  713              unsigned fcn : 8;
  714                           /* Message function code                                */
  715              unsigned fep : 8;
  716                           /* FEP_N_                              */
  717              unsigned short prob;
  718              unsigned short state;
  719              unsigned short qos;
  720              unsigned short lnk_node;
  721              unsigned short alt_qos;
  722              unsigned  long  chan_n_;
  723      };
  724
  725                  /**********************************************/
  726                  /*F* NAME:      KL_S_ADMES                      */
  727                  /**********************************************/
  728                  /**********************************************/
  729                  /*F* NAME:      KL_MES                        */
  730                  /**********************************************/
  731      struct kl_mes{
  732             unsigned code : 8;
  733             unsigned type : 8;
  734      };
  735
  736                  /**********************************************/
  737                  /*F* NAME:      KL_ADMES                      */
  738                  /**********************************************/
  739      struct kl_admes{
  740
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         21   
  741              unsigned code_ : 8;
  742              unsigned typ_ : 8;
  743              char msg_[122];
  744      };
  745
  746                  /**********************************************/
  747                  /*F* NAME:      KL_ADMSR                      */
  748                  /**********************************************/
  749      struct kl_admsr{
  750
  751              unsigned code : 8;
  752              unsigned typ : 8;
  753              char msg_[120];
  754      };
  755                  /**********************************************/
  756                  /*F* NAME:      KL_ACQUIRE                    */
  757                  /**********************************************/
  758      /* KL_AQUIRE - This structure is passed back and fourth between the
  759                     handler and Node Admin to perform an aquire.  NOTE
  760                     that this structure is both the request and responce
  761                     structure.
  762      */
  763
  764      struct kl_acquire{
  765      struct kl_mes mes;
  766
  767             unsigned short chan;
  768                     /* CHAN :  The channel number of the returned channel.
  769                     This field will be zero if no channel of the requested
  770                     RES and ATTR is available.                                    */
  771             unsigned short highchan;
  772                     /* HIGHCHAN :  The highest channel number of the
  773                     requested RES and ATTR. */
  774             unsigned short lowchan;
  775                     /* LOWCHAN :  The lowest channel number of the
  776                     requested RES and ATTR. */
  777             unsigned  dvcid : 16;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         22   
  778                     /* DVCID :  The hardware device ID of the returned channel.   */
  779             unsigned  extdvcid : 16;
  780              /*K* EXTDVCID : This is passed back on the aquire responce to
  781                              indicate the extended device I.D. of the
  782                              device attached to this channel.
  783              */
  784             char res[2];
  785                     /* RES :  The software resource type being requested.         */
  786             unsigned  attr : 16;
  787                     /* ATTR :  The software attributes being requested.
  788                     Returned as the ATTRs actually obtained.                      */
  789             unsigned  diag : 1;
  790                     /* DIAG :  If set,this is a request for diagnostic access
  791                     to a channel. For use by a diagnostic handler only.           */
  792             unsigned  controller : 1;
  793                     /* CONTROLLER : If set,aquire the entire controller.
  794                        This is only honored if DIAG is also set
  795                     */
  796             unsigned  highlow : 1;
  797                     /* HIGHLOW:  If set,Node Admin will fill in HIGHCHAN
  798                        and LOWCHAN on this call
  799                     */
  800                     unsigned  x : 13;
  801            unsigned  errcode : 32;
  802            /*K* ERRCODE:  This field is passed back on an aquire responce
  803                           to indicate the success or failure of the operation.
  804            */
  805            unsigned short user_n_;
  806           /*K* USER_N_.  If this structure is being passed as a reult of
  807                        a user doing an MCL,this contains the user_N_ of
  808                        the calling user.
  809           */
  810
  811      };
  812
  813                  /**********************************************/
  814                  /*F* NAME:      KL_RELEASE                    */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         23   
  815                  /**********************************************/
  816      /* KL_RELEASE - This structure is passed back and fourth between the
  817                     handler and Node Admin to perform a release.  NOTE
  818                     that this structure is both the request and responce
  819                     structure.
  820      */
  821
  822      struct kl_release{
  823      struct kl_mes mes;
  824
  825              unsigned short chan;
  826                     /* CHAN :  The channel to be released
  827                     */
  828              unsigned  controller : 1;
  829                     /* CONTROLLER:  Indicates whether or not to release allchannels
  830                                     this controller.
  831                     */
  832                      unsigned  x : 15;
  833             unsigned short user_n_;
  834            /*K* USER_N_.  If this structure is being passed as a reult of
  835                        a user doing an MCL,this contains the user_N_ of
  836                        the calling user.
  837            */
  838             unsigned  errcode : 32;
  839                     /*K* ERRCODE:  To be passed back to the user.
  840                     */
  841      };
  842
  843                  /**********************************************/
  844                  /*F* NAME:      KL_ADMIN                      */
  845                  /**********************************************/
  846      /* Structure for Administrative msgs from the HOST to the handler  */
  847      struct kl_admin{
  848      struct kl_hdr hdr;
  849
  850             unsigned  fnc : 16; /* ENABLE,DISABLE,etc. */
  851      struct b_terminal_id termid_lo;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         24   
  852
  853      struct b_terminal_id termid_hi;
  854
  855      };
  856                  /**********************************************/
  857                  /*F* NAME:      KL_WRITE                      */
  858                  /**********************************************/
  859      /* KL_WRITE - Message passed from the network
  860                    manager to the node administrator indicating that
  861                    the text contained in the message is to be written
  862                    to the terminal attempting logon.
  863      */
  864      struct kl_write{
  865               unsigned fcn : 8;
  866            /*K* FCN  Indicates the function being performed.
  867            */
  868               unsigned x : 8;
  869               unsigned  char nmid[4];
  870            /*K* NMID  This is passed to the network manager,so that it
  871                       can send it back to node admin to identify NAs context
  872                       for this logon attempt.
  873             */
  874      	struct {
  875              unsigned msgsize : 8;
  876              /*K* MSGSIZE Number of bytes in the passed message
  877              */
  878              char msgtxt[1] ;
  879              /*K* MSGTXT The message itself
  880              */
  881      			} message;
  882
  883      };
  884
  885                  /**********************************************/
  886                  /*F* NAME:      KL_RETURN                     */
  887                  /**********************************************/
  888      /* KL_RETURN - This message is sent to all handlers when a return is
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         25   
  889                     done on a partitioned channel.
  890      */
  891      struct kl_return{
  892              unsigned fcn : 8;
  893            /*K* FCN  Indicates the function being performed.
  894            */
  895              unsigned x : 8;
  896              unsigned short channel;
  897            /*K* CHANNEL  The channel being returned
  898            */
  899              char res[2];
  900            /*K* RES  The resource type of the channel beig returned
  901            */
  902              unsigned  attr : 16;
  903            /*K* ATTR  The attributes of the channel being returned
  904            */
  905      };
  906
  907                  /**********************************************/
  908                  /*F* NAME:      KL_LINPROINFO                 */
  909                  /**********************************************/
  910      /* KL_LINPROINFO  This message is passed from handler common to
  911                        the node administrator with line profile
  912                        information for a channel that has subdevices
  913                        and subsubdevices (3270 or HASP).
  914      */
  915
  916
  917      struct kl_linproinfo{
  918               unsigned fcn : 8;
  919            /*K* FCN  Indicates the function being performed
  920            */
  921      struct b_terminal_id termid;
  922
  923      };
  924
  925                  /**********************************************/
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         26   
  926                  /*F* NAME:      KL_KEYMES - Keyin Message
  927           The KL_KEYMES macro in file KL_MACRO_C generates a structure
  928           for initiating and responding to messages to system consoles.
  929           This structure is passes as a parameter to KHA_S_DVCADM in the
  930           FEP library with a function of KHA_FNC_DVCERR. */
  931                  /**********************************************/
  932      struct kl_keymes{
  933               unsigned fnc : 8;
  934      /*K* FNC - UBIN BYTE.
  935           Indicates type of message.  Substitution strings for FNC are of
  936           the form IGA_ and are defined in KL_AFCN_C.:LIBRARY.  For device
  937           error messages FNC=IGA_KMSG.  The default is IGA_KMSG.
  938      */
  939
  940               unsigned short msg_n_;
  941      /*K* MSG_N_ - UBIN WORD.
  942           Indicates which "structure" KEYIN should use to generate the
  943           console message.  Values for MSG_N_
  944           are listed in the following table.
  945           ..::TB "^\Decimal  Meaning\Value\#"
  946           172      Unit Record Peripheral Status message.
  947           173      Unit Record Peripheral No Keyin message.
  948           174      3270 Line Printer message.
  949           ..::TB
  950      */
  951               unsigned  caddr : 18;
  952               unsigned  keyin_req : 1;
  953               unsigned  x : 5;
  954      /*K* CADDR - BIT(18).
  955           Is the console address.  CADDR indicates what type of console should
  956           receive this message.  Values for CADDR are listed
  957           in the following table.  The default is '004000'O.
  958           ..::TB "^\Octal\Value\#4\Meaning\#"
  959          .xeq OC_SUBS_C M_SUBS_C M_COMM
  960          .xeq OC_SUBS_C M_SUBS_C M_ADCOM
  961          .xeq OC_SUBS_C M_SUBS_C M_DEVC
  962          .xeq OC_SUBS_C M_SUBS_C M_SYS
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         27   
  963          .xeq OC_SUBS_C M_SUBS_C M_ADMIN
  964           ..::TB
  965           */
  966      /*K* KEYIN_REQ - BIT(1).
  967           If set,notifies SLUG/KEYIN that a keyin is required in response to
  968           to this error.  The default is 0.
  969      */
  970               unsigned cnsfnc : 8;
  971      /*K* CNSFNC - UBIN BYTE.
  972           Is the function keyin is to perform.  Values for CNSFNC are
  973           listed in the following table.
  974           ..::TB "^\Decimal  Meaning\Value\#"
  975          .xeq OC_SUBS_C OC_SUBS_S OC_STTM
  976          .xeq OC_SUBS_C OC_SUBS_S OC_WRTM
  977          .xeq OC_SUBS_C OC_SUBS_S OC_WR
  978          ..::TB
  979          */
  980      struct b_terminal_id termid;
  981
  982               unsigned nparms : 8;
  983               struct parms {
  984                unsigned type : 8;
  985                unsigned size : 8;
  986      			}parms[1];
  987      /*K* NPARMS - UBIN BYTE.
  988           Indicates how many user parameters follow the KEYMES
  989           structure.  These parameters indicate to keyin the
  990           state of the device and the text of the keyin according
  991           to the templates described in OC_MSG_S.
  992      */
  993      /*K* PARM - ARRAY(0:NPARM-1).
  994           Is an array whose elements correspond one to one with user
  995           appended data.
  996           This array has two fields:
  997          .spf 0
  998              TYPE - UBIN BYTE.
  999                 Indicates the data type of the corresponding appended
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         28   
 1000                 data parameter.  TYPE should always be 1.
 1001          .spf 0
 1002              SIZE - UBIN BYTE.
 1003                 Indicates the size (in bytes) of the corresponding data parameter.
 1004      */
 1005
 1006      };
 1007
 1008                  /**********************************************/
 1009                  /*F* NAME:      KL_DVCERRRSP                  */
 1010                  /**********************************************/
 1011      /* KL_DVCERRRSP This message is sent from the Network Manager
 1012         to Handler Common (via Node Admin) when a Keyin is received
 1013         for a FEP connected device.
 1014      */
 1015
 1016
 1017      struct kl_dvcerrrsp{
 1018               unsigned fnc : 8;
 1019               unsigned x : 8;
 1020               unsigned  long  kyn_n_;
 1021      struct b_terminal_id termid;
 1022
 1023      };
 1024
 1025
 1026      /*F*     NAME: KL_REQSTATS - Statistical Data Request Message
 1027
 1028                The KL_REQSTATS macro in file KL_MACRO_C generates a structure that
 1029                identifies a particular subset of FEP stats data.  It is the
 1030                structure sent by STATS through SLUG to the FEP to request stats
 1031                and to determine what data is requestedand is included as the header
 1032                of each stats message returned from the FEP to identify what part
 1033                of the FEP it came from.
 1034
 1035                This is the structure that is passed to the handler's
 1036                administrative routine when the value of KH_S_ADMIN_FPT.FNC
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         29   
 1037                is %KHA_FNC_REQSTATS.
 1038
 1039
 1040                The fields in the KL_REQSTATS structure are:
 1041      */
 1042
 1043      /*
 1044      The KL_REQSTATS macro generates all possible versions of the structure,
 1045      including all combinations of LVL,STCLASS,and L6 vs. HOST.
 1046      Because of the 32 bit to 36 bit word conversion performed in
 1047      STATS,all character data should be segregated at the beginning
 1048      of the structure.  All non-character data should be restricted
 1049      to the lower 32 bits of the word.
 1050      */
 1051
 1052      struct kl_reqstats{
 1053      	unsigned fnc : 8;
 1054
 1055      /*K* NODE_NUM - The node number of the FEP this message belongs to.
 1056                Used by SLUG to identify the destination of the request.
 1057                Used by STATS to identify the source of the response.
 1058      */
 1059      	unsigned node_num : 8;
 1060      	unsigned src_node : 8;
 1061      	unsigned x1 :8;
 1062
 1063      /*K* ERRCODE - Used by SLUG to indicate to STATS that an error occurred.
 1064      */
 1065      	int long errcode;
 1066
 1067
 1068      /*K* STATSSTA - The station name on CSCG of the instance of STATS this message
 1069                belongs to.  Used by SLUG to route responses back to STATS.
 1070      */
 1071      	char statssta[8];
 1072
 1073      /*K* FEPNAME - The name of the FEP this message belongs to.  Filled in by SLUG
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         30   
 1074                based on NODE_NUM.  Used by STATS for display purposes.
 1075      */
 1076      	char fepname[8];
 1077
 1078      /*K* HANDLER - Handler Name.  In the stats request, used to select a handler for
 1079                which stats are to be returned.  In most cases stats request will
 1080                contain blanks, meaning all handlers.  In the stats response, filled
 1081                in by NODEADMIN to identify the source of this chunk.
 1082      */
 1083      	char handler[8];
 1084
 1085      /*K* DSPMSK - BIT(32).  Contains display bits, by entity.
 1086                When set in the stats request, each bit requests that any selected
 1087                handlers return statistics for the entity corresponding to the bit.
 1088                In the stats response, one bit should be set to indicate to which
 1089                entity the data belongs.  This bit is used by STATS to select
 1090                the format in which to display the data.  To cause a DSPMSK bit
 1091                to be set, entity-name = DISP may be specified.  See SLCMSK for
 1092                more information.
 1093      */
 1094
 1095      	unsigned dspmsk : 32;
 1096
 1097      /*K* DSPENT.  Is DSPMSK redefined as a bit array indexed by %KH#ENTID_...
 1098              DSPENT is generated only when ARYDCL=YES, so that multi-dimension conflicts
 1099              may be avoided.  The default for ARYDCL is YES.
 1100      */
 1101
 1102
 1103      /*K* SLCMSK - BIT(32).  Contains select bits,by entity.
 1104                A handler is selected if there is a bit set in the stats request
 1105                for at least one entity belonging to the handler at each level.
 1106                In the stats response,select bits should be set for every entity
 1107                that can contribute activity to this chunk of stats data,i.e.,
 1108                the entity returning the data and everything above and below it.
 1109                Bits may be set in SLCMSK by specifying entity-name = SLCT or
 1110                entity-name = DISP.  A list of entity-names known by STATS and
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         31   
 1111                by the KL_REQSTATS macro follows:
 1112
 1113                .fif
 1114                name   layer        description
 1115                ----   -----        -----------
 1116                ASYNC  link         Asynchronous handler
 1117                BSC    link         Bisync handler
 1118                FEI    link         Coupler handler
 1119                HDLC   link         HDLC handler
 1120                URP    link         Unit record peripheral handler
 1121                X25    network      X25 protocol machine
 1122                ML     network      Multi-link protocol machine
 1123                VDH    presentation Virtual Device Handler
 1124                APE    presentation Application Protocol Engine
 1125                X29    application  X29 handler
 1126                IO     application  Device IO routines
 1127                NODADM application  Node administration handler
 1128                RBT    application  RBT handler
 1129                PLDVIP application  PLDVIP handler
 1130                T3270  application  3270 handler
 1131                MONITOR             LCP-6 operating system
 1132                .fin
 1133      */
 1134
 1135        	unsigned slcmsk : 32;	
 1136
 1137      /*K* SLCENT.  Is  SLCMSK redefined as a bit array indexed by %KH#ENTID_...
 1138              SLCENT is generated only when ARYDCL=YES, so that multi-dimension conflicts
 1139              may be avoided.  The default for ARYDCL is YES.
 1140      */
 1141
 1142      };
 1143                  /**********************************************/
 1144                  /*F* NAME:       KL_SYSLOG                     */
 1145                  /**********************************************/
 1146      /* KL_SYSLOG - Message send from handler to Network manager to put something in syslog
 1147      */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         32   
 1148      struct kl_syslog{
 1149                unsigned fcn : 8;
 1150                  /*K* FCN  Indicates the function being performed. */
 1151                unsigned x1 : 16;
 1152                unsigned filenum : 8;
 1153                     /*N* FILENUM = ERRLOG | ACCOUNTING. FILENUM specifies
 1154                     if the message is to go into the error log file or
 1155                     the accounting log file. */
 1156      };
 1157
 1158                  /**********************************************/
 1159                  /*F* NAME:       KL_ERRLOG                     */
 1160                  /**********************************************/
 1161      /* KL_ERRLOG - Format of the errlog buffer from the handler. */
 1162      struct kl_errlog{
 1163      	int errlog;
 1164      	unsigned uts : 32;
 1165
 1166      	struct b_terminal_id termid;
 1167      	short values[4];
 1168      };
 1169
 1170
 1171
 1172
 1173
 1174      /*F* NAME: KL_ERRMSG_RSP
 1175
 1176      The KL_ERRMSG_RSP macro generates the structure
 1177      for the message that is returned to the Node
 1178      Administer by the Network Manager in response to
 1179      a KL_ERRMSG_RQS.
 1180      */
 1181
 1182      struct kl_errmsg_rsp{
 1183               unsigned fcn : 8;
 1184                          /*K* FCN - UBIN.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         33   
 1185                          Contains the function code that indicates that
 1186                          the message is a syslog message.  This value is
 1187                          %IGA_ERRMSG_RSP (46) from the KL_AFCN_C include file.
 1188                          */
 1189              unsigned usr : 8;
 1190                          /*K* USR_N_ - UBIN BYTE.
 1191                          Contains the user number of the user making
 1192                          the request.
 1193                          */
 1194              unsigned message_sz : 8;
 1195                          /* MESSAGE_SZ - UBIN BYTE.
 1196                          Contains the byte size of MESSAGE.
 1197                          */
 1198
 1199
 1200               unsigned  x : 1;
 1201              unsigned  nofile : 1;
 1202                          /*K* NOFILE = VALUE-BIT(1)   if set specifies that
 1203                          M_S_ERRMSG  was unable to open the message file.
 1204                          */
 1205              unsigned  nomsg : 1;
 1206                          /*K* NOMSG = VALUE-BIT(1)   if set means that
 1207                          M_S_ERRMSG  was unable to find any message for the
 1208                          error code.
 1209                          */
 1210              unsigned  altmsg : 1;
 1211                          /*K* ALTMSG = VALUE-BIT(1)   if set means that
 1212                          M_S_ERRMSG  stored a substitute message in the user
 1213                          buffer.
 1214                          */
 1215              unsigned  msgcomp : 1;
 1216                          /*K* MSGCOMP = VALUE-BIT(1)   if set means that the
 1217                          entire message is stored in the user buffer.
 1218                          */
 1219              unsigned  nnative : 1;
 1220                          /*K* NNATIVE = VALUE-BIT(1)   if set means that the
 1221                          returned message is not in the user's native language.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         34   
 1222                          */
 1223              unsigned  no_nm : 1;
 1224                          /*K* NO_NM = VALUE-BIT(1)   if set specifies
 1225                          that the Network Manager is not active.
 1226                          */
 1227              unsigned  inerr : 1;
 1228                          /*K* INERR = VALUE-BIT(1)   if set specifies
 1229                          error on reading the message.
 1230                          */
 1231              char *ctx;
 1232              char message[120];
 1233      };
 1234
 1235
 1236                  /*F* NAME:       KL_NODEINFO                   */
 1237                  /**********************************************/
 1238      /* KL_NODINFO - Contains the node information for thisn node
 1239      */
 1240      struct kl_nodeinfo{
 1241                unsigned fcn : 8;
 1242                  /*K* FCN  Indicates the function being performed. */
 1243                unsigned x : 8;
 1244              unsigned boss : 8;
 1245                unsigned nodetype : 8;
 1246              unsigned mynode : 8;
 1247              char myname[8];
 1248      };
 1249
 1250
 1251      /*F* NAME: KL_NODECHG
 1252
 1253      Contains a change in state for a node
 1254      */
 1255      struct kl_nodechg{
 1256                unsigned fcn : 8;
 1257                  /*K* FCN  Indicates the function being performed. */
 1258              unsigned x1 : 16;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         35   
 1259              unsigned mynode : 8;
 1260              unsigned node : 8;
 1261              unsigned hostnode : 8;
 1262              unsigned qos : 8;
 1263      };
 1264                  /**********************************************/
 1265                  /*F* NAME:       KL_UPDCHG                    */
 1266                  /**********************************************/
 1267      /* KL_OSICHG - Contains osi route table update information
 1268      */
 1269
 1270      /*F*    NAME: KL_TIME
 1271              Purpose:
 1272                 The KL_TIME is used to set the time to a given node
 1273                                                                    */
 1274      struct kl_time{
 1275              unsigned fnc : 8;
 1276              unsigned  uts : 32;
 1277      };
 1278
 1279
 1280
 1281
 1282                  /**********************************************/
 1283                  /*F* NAME:      KL_AFD                        */
 1284                  /**********************************************/
 1285      /* KL_AFD - Message sent to Network Manager and then to Node Admin requesting
 1286                  Association of the Front-end Debugger (FD) and connection to
 1287                  the specified host network address.  */
 1288      struct kl_afd{
 1289                           /* Message function code                                */
 1290              unsigned fcn : 8;
 1291                           /* Destination node number                              */
 1292      	unsigned destnode :8;  /* was node : 8 */
 1293                unsigned node : 8;
 1294                unsigned generation : 8;
 1295                unsigned  ldx : 16;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         36   
 1296              unsigned  sysid : 16;
 1297              char acct[8];
 1298                          /* Logon account of the debugging user for access
 1299                             control checking. Blank if debugging user has
 1300                             the MSYS privilege turned on. */
 1301      };
 1302
 1303                  /**********************************************/
 1304                  /*F* NAME:      KL_CWNAK                      */
 1305                  /**********************************************/
 1306      /* KL_CWNAK - Message to Network Manager & BABOON erroring an SS_CW-REGged
 1307                    user. This message is used to error KL_STRTU messages and
 1308                    KL_AFD messages along with others. */
 1309      struct kl_cwnak{
 1310              unsigned fcn : 8;
 1311                           /* Message function code                                */
 1312               unsigned x : 8;
 1313            /* Source network address */
 1314                unsigned node : 8;
 1315                unsigned generation : 8;
 1316                unsigned  ldx : 16;
 1317      	unsigned h: 1;
 1318      	unsigned x1: 15;
 1319      	long neterr;
 1320
 1321      };
 1322
 1323
 1324      /*F* NAME: KL_CONTROL__ -  Control Parameter Request Message
 1325
 1326      The KL_CONTROL macro in file KL_MACRO_C generates a structure
 1327      for the message that is passed between
 1328      the NETCON processor on the Host and the Node Administrator on the
 1329      FEP when control parameters are to be displayed or reset.
 1330
 1331      This is the structure that is passed to the handler's
 1332      administrative routine when the value of KH_S_ADMIN_FPT.FNC
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         37   
 1333      is %KHA_FNC_CNTRLCHG.
 1334
 1335      The default storage class for this macro is STATIC.
 1336      The STCLASS=storage option may be used to reset the
 1337      storage class to BASED.
 1338
 1339      The KL_CONTROL structure contains the following fields:
 1340      */
 1341      struct kl_control{
 1342      struct kl_hdr hdr;
 1343
 1344              unsigned  cmd : 16; /* SET or DISPLAY   */
 1345              unsigned  parmx : 16; /* param index */
 1346              unsigned  indx : 16; /* index for indexed params */
 1347              unsigned  value : 16; /* value of param */
 1348              unsigned  ovalue : 16;     /* prev value of param*/
 1349      /*K* CMD - UBIN.
 1350      Contains one of the following EQUated values to indicate the
 1351      function that is to be performed:
 1352
 1353      .fif
 1354        01  KL_CONTROL_SET -     Reset the specified control parameter
 1355        02  KL_CONTROL_DISPLAY - Display the specified control parameter
 1356      .fin
 1357
 1358      The EQUs are in the file KL_CONTROL_C.
 1359      */
 1360
 1361      /*K* PARMX - UBIN.
 1362      Contains an index into the control parameter table for the
 1363      parameter that is to be reset or displayed.  See the description
 1364      of KL_HNDLRPARM_equ for the possible values and their meaning.
 1365      */
 1366      /*K* INDX - UBIN.
 1367      If the control parameter selected by the PARMX field is an
 1368      indexed type of parameter,this field will contain the index
 1369      to the parameter that is to be reset or displayed.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         38   
 1370      */
 1371      /*K* VALUE - UBIN(18).
 1372      If the function is reset,this field contains the new value.
 1373      If the function is display,this is where the handler is to
 1374      return the current value.
 1375      */
 1376      /*K* OVALUE - UBIN(18).
 1377      If the function is setthis field contains the value of the parameter
 1378      prior to issuing the SET command.*/
 1379      };
 1380
 1381      /* kl_control_init - initial control parameters for handlers		*/
 1382      /* defines 4 indexed parameters to duplicate the structure defined	*/
 1383      /* in KFF$FEBOOT and used to build data segment 1 for NODEADMN		*/
 1384
 1385       struct kl_control_init {
 1386      	unsigned char code;
 1387      	unsigned char type;
 1388      	unsigned char srce_node;
 1389      	unsigned char dest_node;
 1390      	char handler[8];
 1391      	char origin[8];
 1392      	char node[8];
 1393      	long results;
 1394      	short msg;
 1395      	short hndlrtyp;
 1396      	short num_fparam;
 1397      	short num_iparam;
 1398      	short fparam[29];
 1399      	struct {
 1400      		unsigned char array_sz;
 1401      		unsigned char param_sz;
 1402      		short offset;
 1403      	} iparam[4];
 1404      	short block[16];
 1405      	short unblock[16];
 1406      	short usrparm1[8];
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         39   
 1407      	short usrparm2[8];
 1408      };
 1409      /*m* dib_stt.h -  handler statistic item definitions         */
 1410      /*t***********************************************************/
 1411      /*t*							     */
 1412      /*t* Copyright, (c) Honeywell Bull Inc., 1987		     */
 1413      /*t*							     */
 1414      /*t***********************************************************/
 1415
 1416      /*f* name: kh_stt - statistical data structure
 1417
 1418      The kh_stt structure may be used to generate the
 1419      structure containing statistical data maintained by the
 1420      line or device handler (link layer).
 1421
 1422      This structure should be included in the handler's stats buffer in the
 1423      interest of having a common format for most statistics among the
 1424      various device handlers.
 1425
 1426      the kh_stt structure contains the following fields:
 1427      */
 1428
 1429      struct kh_stt {
 1430
 1431      	long inpintcnt;
 1432      		       /*k* inpintcnt - ubin
 1433      		       contains the input interrupt level count.*/
 1434      	long otpintcnt;
 1435      		       /*k* otpintcnt - ubin
 1436      		       contains the output interrupt level count.*/
 1437      	long inpintisatim;
 1438      		       /*k* inpintisatim - ubin.
 1439      		       contains the number of clock tics that have
 1440      		       occurred at the input interrupt level.	 */
 1441      	long otpintisatim;
 1442      		       /*k* otpintisatim - ubin.
 1443      		       contains the number of clock tics that have
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         40   
 1444      		       occurred at the output interrupt level.	 */
 1445      	long inpbfrbytutl;
 1446      		       /*k* inpbfrbyutl - ubin.
 1447      		       contains the input buffer byte utilization.
 1448      		       This is the total number of bytes currently
 1449      		       utilized for the input buffers in the line or
 1450      		       device handler.				 */
 1451      	long otpbfrbytutl;
 1452      		       /*k* otpbfrbytutl - ubin.
 1453      		       contains the output buffer byte utilization.
 1454      		       this is the total number of bytes currently utilized for
 1455      		       the output buffers in the line or device handler. */
 1456      	long ctxbytutl;
 1457      		       /*k* ctxbytutl - ubin.
 1458      		       contains the context byte utilization.
 1459      		       this is the total number of bytes currently utilized for
 1460      		       the context area in the line or device handler.	  */
 1461      	};
 1462
 1463
 1464      /*f* name: kl_reqstats
 1465
 1466      	  The kl_reqstats structure defines a common structure that
 1467      	  identifies a particular subset of fep stats data.  It is the
 1468      	  structure sent by stats through slug to the fep to request stats
 1469      	  and to determine which chunks are requested, and is included as the
 1470      	  header of each chunk returned from the fep to identify what part
 1471      	  of the fep it came from.
 1472
 1473      	  Because of the 32 bit to 36 bit word conversion performed in
 1474      	  stats, all character data should be segregated at the beginning
 1475      	  of the structure.  all non-character data should be restricted
 1476      	  to the lower 32 bits of the word.
 1477
 1478      	  The fields in the kl_reqstats structure are:
 1479      */
 1480
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         41   
 1481      struct kl_rqstats {
 1482
 1483      /*k* fnc - function code, by which slug recognizes the message as a stats
 1484      	  request.  the mandatory default is %iga_reqstats from the file
 1485      	  kl_afcn_c for both the request and the response.  this field
 1486      	  must be the first thing in the structure, so slug knows where to
 1487      	  look for it.
 1488      */
 1489            char fnc;
 1490
 1491      /*k* node_num - The node number of the fep this message belongs to.
 1492      	  Used by slug to identify the destination of the request.
 1493      	  Used by stats to identify the source of the response.
 1494      */
 1495            char node_num;
 1496
 1497            char srce_node;
 1498            char fill;
 1499
 1500      /*k* errcode - Used by slug to indicate to stats that an error occured.
 1501      */
 1502            long errcode;
 1503
 1504      /*k* statssta - The station name on cscg of the instance of stats this message
 1505      	  belongs to.  Used by slug to route responses back to stats.
 1506      */
 1507            char statssta[8];
 1508
 1509      /*k* fepname - The name of the fep this message belongs to.  filled in by slug
 1510      	  based on node_num.  used by stats for display purposes.
 1511      */
 1512            char fepname[8];
 1513
 1514      /*k* handler - handler name.  In the stats request, used to select a handler for
 1515      	  which stats are to be returned.  in most cases stats request will
 1516      	  contain blanks, meaning all handlers.  in the stats response, filled
 1517      	  in by node-admin to identify the source of this chunk.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         42   
 1518      */
 1519            char handler[8];
 1520
 1521      /*k* dspmsk - display bits, by entity.	a bit(32) bit-string.
 1522      	  when set in the stats request, each bit requests that the selected
 1523      	  handlers return stats for that entity.   in the stats response, one
 1524      	  bit should be set to indicate which entity this belongs to.
 1525      */
 1526            long dspmsk;
 1527
 1528      /*k* slcmsk - select bits, by entity.  a bit(32) bit-string.
 1529      	  a handler is selected if there is a bit set in the stats request
 1530      	  for at least one entity belonging to the handler at each level.
 1531      	  in the stats response, select bits should be set for every entity
 1532      	  that can contribute activity to this chunk of stats data, ie.,
 1533      	  the entity returning the data and everything above and below it.
 1534      */
 1535            long slcmsk;
 1536
 1537            };
 1538      /*M* dib_dat.h - direct interface board equates and structures. */
 1539      /*t***********************************************************/
 1540      /*t*                                                                */
 1541      /*t* Copyright, (c) Honeywell Bull Inc., 1987               */
 1542      /*t*                                                                */
 1543      /*t***********************************************************/
 1544
 1545      #define RCQ_SIZE 16000
 1546      #define SCQ_SIZE 16000
 1547
 1548
 1549      /* equates for mode */
 1550
 1551      #define KJ_MODE_ASCII 1
 1552      #define KJ_MODE_BIN   0
 1553
 1554      /* equates for clist operation codes */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         43   
 1555
 1556      #define DISCONNECTINT 2           /* discontinue io */
 1557      #define DATAL6_L66    56          /* write to L66 */
 1558      #define DATAL66_L6    48          /* read L66 */
 1559      #define READCLR_OR    52          /* read/clear L66, or to L6 */
 1560      #define JUMP         1            /* jump to dcw at l6 address */
 1561      #define NOP          0            /* no operation       */
 1562      #define INTL66       24           /* interrupt the host */
 1563
 1564      /* equates for interupt level into the host */
 1565
 1566      #define KJ_INTLVL_INIT 3      /* terminate interrupt, fei is initializing    */
 1567      #define KJ_INTLVL_DATA 7      /* marker interrupt, there is data  */
 1568      #define KJ_INTLVL_ERR  3      /* terminate interrupt, there is a problem  */
 1569
 1570      /* equates for various status conditions        */
 1571
 1572      #define KJ_STATUS_DR   1       /* Status for dia ready  */
 1573      #define KJ_STATUS_ATT  2        /* Status when io interrupted by fault */
 1574      #define KJ_STATUS_TT   4        /* Status when io timed out             */
 1575      #define KJ_STATUS_CNOP 8        /* Status when host goes not-operational */
 1576      #define KJ_STATUS_CON 16        /* Status when connect occured          */
 1577
 1578      /* equates for the state of the coupler */
 1579
 1580      #define KJ_STATE_MASKED   1                    /* coupler is masked        */
 1581      #define KJ_STATE_INIT    2                     /* coupler being initialized       */
 1582      #define KJ_STATE_RUNNING  3                    /* coupler running        */
 1583      #define KJ_STATE_RECOVERY 4                    /* coupler recovery        */
 1584
 1585      /* equates for current_function */
 1586
 1587      #define KJ_CF_NONE       0                     /* no function in progress       */
 1588      #define KJ_CF_INIT       1                     /* init coupler         */
 1589      #define KJ_CF_ROCQSIZE   2                     /* reading ocq size        */
 1590      #define KJ_CF_RICQSIZE   3                     /* reading icq size        */
 1591      #define KJ_CF_DATA       5                     /* transfering data        */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         44   
 1592      #define KJ_CF_BOOT       6             /* waiting for boot to start          */
 1593
 1594      /* equates for context flags                                     */
 1595
 1596      #define KJ_CX_BUFFULL    0x8000        /* buffer contains data  */
 1597
 1598      /*     screech code used by dib code                             */
 1599
 1600             struct dib_scode {
 1601                     unsigned fcg : 10;
 1602                     unsigned mid : 5;
 1603                     unsigned mon : 1;
 1604                     unsigned err_ : 13;
 1605                     unsigned sev : 3;
 1606             };
 1607
 1608      /*     Recovery Buffer                                          */
 1609
 1610      struct rv_fep_buff {
 1611             int dumpmap[128];
 1612                          /*K* DUMPMAP.  Specifies the physical pages
 1613                          to be dumped.  Each bit corresponds to a 2K byte sized
 1614                         segment to be dumped.  For example, if bit 100 is set then
 1615                          pages 400-403 of L6 FEP memory are to be included in the
 1616                         dump.
 1617                          */
 1618             short busy;
 1619             unsigned badpput : 1;
 1620             unsigned rfu : 15;
 1621                          /*K* BADPPUT.  Set if Physical Page Usage Table (PPUT) was
 1622                         found to be inconsistent.  Always set on DIB recovery.
 1623                          */
 1624             int screechuts;
 1625                          /*K* SCREECHUTS = VALUE-UTS.  The UTS at the time of entry
 1626                          to the monitor screech routine.  NA on DIB recovery.
 1627                          */
 1628             int scode;
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         45   
 1629                          /*K* SCODE.  Screech code generated by dib_scode.   */
 1630             short dumpbits;
 1631             short mhjitpp;
 1632                          /*K* MHJITPP = VALUE-UBIN WORD.  Monitor HJIT physical
 1633                          page.  Set to zero on DIB recovery.                       */
 1634             short cun;
 1635                          /*K* CUN - Current user number on screeching CPU          */
 1636             int tsa_;
 1637                          /*K* TSA$ - Pointer to TSA passed to GIR$SCREECH          */
 1638             short badppx;
 1639                          /*K* BADPPX - Index at which bad PPUT detected.           */
 1640             };
 1641
 1642      /* I/O control list structure */
 1643
 1644      struct ioclist {
 1645            unsigned int op :18;        /* operation code  */
 1646            unsigned int mode : 18;     /* mode, ASCII/binary */
 1647            int           tally;        /* transfer counter, (host words) */
 1648            int           l66a;         /* Host address                   */
 1649            int           l6a;          /* coupler sram address           */
 1650            } ;
 1651
 1652      /* DIB context structure  */
 1653
 1654      struct kj_ctx {
 1655            int state;
 1656            int current_function;    /* current function in progress       */
 1657            char host_node;          /* node number of host                */
 1658            char fep_node;           /* node number of fep                 */
 1659            char qos;                                /* qos for connection        */
 1660            char rfu1;
 1661            int flags;
 1662            struct  {
 1663                 long iptr;          /* host insert index                  */
 1664                 long rptr;          /* host removal index                 */
 1665                 long size;          /* host queue size                    */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         46   
 1666                 long offset;        /* offset to icq in the host          */
 1667                 int   buf;          /* pntr to icq buffer on board        */
 1668                 long new_rptr;      /* new removal ptr for handler cq     */
 1669                 } icq ;
 1670            struct  {
 1671                 long iptr;          /*  host insert index                 */
 1672                 long rptr;          /*  host removal index                */
 1673                 long size;          /*  host queue size                   */
 1674                 long offset;        /*  offset to ocq in the host         */
 1675                 int  flags;
 1676      #define KJ_OQ_QFULL  0x00800000 /* Host output queue full flag       */
 1677                 long rdsize;        /* size of area read in               */
 1678                 int  buf;          /* pntr to ocq buffer on board        */
 1679                 } ocq;
 1680            struct {
 1681                  int  buf;
 1682                 int size;
 1683                 int csize;
 1684                 } ibuf;             /* buffer for internal messages       */
 1685            long ioip;
 1686            long status1;            /* hardware status                    */
 1687            struct ioclist ptr_dcw[20]; /* dcws to read host pointers        */
 1688            long pcw[2];             /* pcw read from the host        */
 1689            long spacer;
 1690            struct rv_fep_buff rcvrbfr;              /* recovery buffer  */
 1691            char scrmsg[80];         /* screech message               */
 1692            } ;
 1693
 1694
 1695      /* offset into the host queue header for the pointers */
 1696
 1697      #define KJ_OFFSET_IOIP 2                       /* io in progress flag        */
 1698      #define KJ_OFFSET_NODE 3                       /* nodes                */
 1699      #define KJ_OFFSET_SIZE 5                       /* size of queue        */
 1700      #define KJ_OFFSET_RPTR 9                       /* removal pointer        */
 1701      #define KJ_OFFSET_IPTR 10                      /* insert pointer        */
 1702      #define KJ_OFFSET_FLAGS 11                     /* flags                */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         47   
 1703      #define KJ_OFFSET_DATA 16                      /* offset to the data in queue */
 1704
 1705      /* Hardwired control parameters */
 1706
 1707      struct kj_control {
 1708            int icqpgs;                              /* Pages for input circular quere     */
 1709            int ocqpgs;                              /* Pages for output circular quere    */
 1710            int intpgs;                              /* Pages for internal buffer       */
 1711            int intlvl;                              /* Interupt level        */
 1712            int chan;                                /* Channel              */
 1713            int nr_msg;                              /* # of messages before a interupt    */
 1714            int inthtime;                            /* Time inbetween host interupts      */
 1715            char res[2];
 1716            int attr;
 1717            int ocqdblksiz;
 1718            } ;
 1719
 1720      /* statistics  */
 1721
 1722      struct kj_stt_fei {
 1723             struct kl_reqstats reqstats;
 1724             struct kh_stt      usrstt;
 1725            long icq_msgs;               /* Messages into the host      */
 1726            long ocq_msgs;               /* Messages from the host      */
 1727            long icq_mbc;                /* Message bytes into host     */
 1728            long ocq_mbc;                /* Message bytes from host     */
 1729            long dcw_abrt;               /* DCW LIST ABORTS             */
 1730            long schxeqtim;              /* scheduled xeq time          */
 1731            long ruok;                   /* host query for fep okay     */
 1732            long odata;                  /* output data                 */
 1733            long nop;                    /* nops                        */
 1734            long tim;                    /* time messages from host     */
 1735            } ;
 1736
 1737      /*     host boot image offset table                              */
 1738
 1739      struct gi_offsets{
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         48   
 1740              unsigned long paramoffset;
 1741              unsigned long param_n;
 1742              unsigned long cntloffset;
 1743              unsigned long cntl_n;
 1744              unsigned long pseudooff;
 1745              unsigned long pseudo_n;
 1746              unsigned long sectoffset;
 1747              unsigned long sectsize;
 1748              unsigned long fex;
 1749              char nodename[8];
 1750              unsigned long hostnode;
 1751              char bootfid[40];
 1752              unsigned long nhandlers;
 1753              unsigned long tbloffset[3];
 1754             };
 1755
 1756      /*     host boot image rununit description                     */
 1757      /*     needed to find ds1 to read control structures           */
 1758
 1759      struct gi_setfp {
 1760             unsigned char fcn;
 1761             unsigned char f1_8;
 1762             long err;
 1763             struct {
 1764                     unsigned char l;
 1765                     char text[31];
 1766             } name;
 1767             char acct[8];
 1768             char pass[8];
 1769             char psn[6];            /* packset name */
 1770             long modtime;
 1771             long p__;               /* start address */
 1772             long priv;              /* processor priv */
 1773             short flags;
 1774             unsigned char pseudo_count;
 1775             unsigned char version;
 1776             char pseudo_text[8];
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         49   
 1777             short udcbnum;
 1778             short dcbres;
 1779             short tcbsize;
 1780             short vppgs;
 1781             short vdpgs;
 1782             short ros_sz;
 1783             short data_sz;
 1784             short proc_size;
 1785             long data_bias;
 1786             long data_bias_;
 1787             struct {
 1788                     unsigned char l;
 1789                     char text[31];
 1790             }lib_name;
 1791             long offset_ro;         /* offset into boot image to ro seg */
 1792             long offset_data;       /* offset into boot image to data */
 1793             long offset_proc;       /* offset into boot image to procedure */
 1794             long offset_lib_data;   /* offset into boot image to library data */
 1795             long offset_lib_proc;   /* offset into boot image to lib procedure */
 1796             long lib_data_siz;
 1797             long lib_proc_sz;
 1798             long offset_ds1;        /* offset into boot image to data seg 1 */
 1799             long ds1_sz;            /* size of ds1 data in short words */
 1800      };
 1801
 1802      /* data segment 1 from boot image                                */
 1803
 1804      #define DSEG1SZ 1200           /* nominal size of data seg 1    */
 1805
 1806      struct datseg1 {
 1807             long nhandlers;         /* number of handlers            */
 1808             long offsets[4];        /* offsets to handler data (shorts) */
 1809      };
 1810
 1811      /* process table info for recovery dumps    */
 1812
 1813      struct rcv_proc {
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         50   
 1814       unsigned  dib_wu : 9;  /* dib wakeup flag  */
 1815       unsigned  p_stat : 9;  /* Status of process.      */
 1816       unsigned  p_uid : 18;  /* real user id */
 1817       unsigned  p_pid : 18;  /* unique process id */
 1818       unsigned  p_ppid : 18;  /* process id of parent */
 1819       int  p_flag;  /* Flags defined below.      */
 1820       int  p_wchan; /* Wait addr for sleeping   */
 1821           /* processes.  That is,     */
 1822           /* address of semaphore.    */
 1823       int  p_w2chan; /* sleep addr of sleep call */
 1824           /* since p_wchan has addr   */
 1825           /* of sema used by sleep    */
 1826           /* used by sleep routine.   */
 1827       int  p_clktim; /* time to alarm clock signal */
 1828       unsigned  p_size : 18;  /* size of swappable image  */
 1829           /* in pages.      */
 1830       unsigned  dib_waitcount : 18;  /* dib wait counter     */
 1831       int dib_selproc; /* dib select flag     */
 1832
 1833      };
 1834      /*M*  dib_fcns.h - function codes for frontend interface  */
 1835
 1836      /*     these function codes duplicate those found in KJ_FCNS_C */
 1837
 1838      /*	FEIO TO FECP FUNCTION CODES  */
 1839
 1840
 1841      #define KJ_FCN_NOPI 0		     /*NOP to send to CP-6 at end buffer */
 1842      #define KJ_FCN_NOP 32		     /*NOP                        */
 1843      #define KJ_FCN_TIM 33		     /*TIME SETUP (AND LOOPBACK) */
 1844      #define KJ_FCN_RUOK 34		     /*ARE YOU OK FEP?*/
 1845      #define KJ_FCN_ODATA 35 	     /* Data transfer */
 1846
 1847
 1848      /*   FECP TO FEIO FUNCTION CODES  */
 1849
 1850
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         51   
 1851      #define KJ_FCN_NOPI 0		     /*NOP (CROSS BUFFER BOUNDARY)*/
 1852      #define KJ_FCN_TIMR 1		     /*TIME LOOPBACK RESPONSE	*/
 1853      #define KJ_FCN_IMOK 2		     /*FEP OK - NO BOOT*/
 1854      #define KJ_FCN_SDBG 3		     /*SET DEBUG MODE - NO TIMERS*/
 1855      #define KJ_FCN_RDBG 4		     /* Reset Debug, Timers back on */
 1856      #define KJ_FCN_IDATA 5		     /* Data transfer */
 1857
 1858
 1859      /* Equate for intrupt parameter from host */
 1860      #define KJ_IPARM_OCQ   1	     /* Scan OCQ */
 1861      #define KJ_IPARM_INIT	2	     /* Initialisze */
 1862      #define KJ_IPARM_SCR   3	     /* Screech */
 1863      #define KJ_IPARM_TO   4 	     /* Host detect time out */
 1864      #define KJ_IPARM_BADMSG   5	     /* Bad message in ICQ */
 1865      #define KJ_IPARM_FLT   6	     /* Host detect fault */
 1866      #define KJ_IPARM_OREQ	7	     /* Host user request */
 1867      #define KJ_IPARM_CNOP	8	     /* Central sys not operat'nl */
 1868
 1869      /*M* dib_hmi.h - structures for handler monitor interface */
 1870      /*t***********************************************************/
 1871      /*t*                                                                */
 1872      /*t* Copyright, (c) Honeywell Bull Inc., 1987 */
 1873      /*t*                                                                */
 1874      /*t***********************************************************/
 1875
 1876
 1877
 1878      #define N_DEV          32      /* number of minor device numbers */
 1879
 1880      #define LOAD_DEV       255     /* Load device, used to down load firmware */
 1881      #define CP6_DEV                254             /* CP-6 interface, allocates ldct */
 1882      #define UTIL_DEV       253     /* Utility device, non communications cmd*/
 1883
 1884      #define N_LDCTS                100             /* Number of LDCT entries  */
 1885      #define DIB_PRI        (PZERO-3)               /* Scheduler priority, block signals */
 1886
 1887
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         52   
 1888                     /*k* knh_mess
 1889
 1890                     knh_mess generates the structure for the control
 1891                     information that is at the beginning of each message in the
 1892                     circular queue.
 1893
 1894                     This structure must match the KNH$MESS structure in CP-6
 1895
 1896                    */
 1897
 1898      struct knh_mess {
 1899             unsigned : 1;
 1900             unsigned free : 1;
 1901             unsigned function : 16;
 1902                         /*k* function
 1903                         contains the code to indicate the type of message.
 1904                         */
 1905
 1906                          /* defines for  knh_mess.function    */
 1907
 1908      #define KN_FCN_INIT       1                    /* initiate connection  */
 1909      #define KN_FCN_INIT_ACK   2                    /* initiate acknowledge */
 1910      #define KN_FCN_TERM       3                    /* terminate connection */
 1911      #define KN_FCN_TERM_ACK   4                    /* terminate acknowledge */
 1912      #define KN_FCN_DATA       5                    /* send data     */
 1913      #define KN_FCN_NOP        6                    /* nop           */
 1914      #define KN_FCN_UNQ       7
 1915
 1916            unsigned ldctx : 18;
 1917                         /*k* ldctx
 1918                         contains the ldct index which represents an
 1919                         application's endpoint.
 1920                         */
 1921      /*     union  {
 1922                      long uid;
 1923                      char *uid_;
 1924                      struct {
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         53   
 1925                         char cq_hndid;
 1926                         char cq_hndctxid[3];
 1927                               } uidx;
 1928                     } uid;       */
 1929               unsigned uid :36;
 1930                         /*k* uid
 1931                         contains the application's user identification.
 1932                         */
 1933            unsigned rectype : 18;
 1934                         /*k* rectype
 1935                         */
 1936            unsigned  last_ptr : 18;
 1937                         /*k* last_ptr
 1938                         */
 1939            unsigned  fptsz :18;
 1940                         /*k* fptsize
 1941                         contains the byte size of the fpt portion of the
 1942                         message.  if no fpt, fptsz will be zero.
 1943                         */
 1944            unsigned  msgsz: 18;
 1945                         /*k* msgsz
 1946                         contains the byte size of the application data
 1947                         that follows the message header and optional fpt.
 1948                         if no data is associated with the message, msgsz
 1949                         will be zero.
 1950                         */
 1951            } ;
 1952
 1953                         /*F* NAME: knh_qhdr
 1954
 1955                         Structure to define the circular queue header
 1956                         which preceeds the circular queue data.
 1957                         This structure contains data describing the queues,
 1958                         and usage statistics.
 1959                         */
 1960
 1961      struct knh_qhdr {
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         54   
 1962             struct  {
 1963                   int iptr;
 1964                         /*K* iptr
 1965                         The insert pointer is a char offset from the
 1966                         the queue base where a message may be inserted.
 1967                         */
 1968                   int rptr;
 1969                         /*K* rptr
 1970                         The remove pointer is a char offset from the
 1971                         queue base where the next item is to be removed.
 1972                         */
 1973                   int sz;
 1974                         /*K* sz
 1975                         contains the size of the queue, in bytes.
 1976                         */
 1977                   int offset;
 1978                         /*K* offset
 1979                         contains the offset in bytes, from the base of the
 1980                         queue segment to the start of the queue.
 1981                         */
 1982                   }rcq ;
 1983
 1984             struct  {
 1985                   int iptr;
 1986                         /*K* iptr
 1987                         The insert pointer is a byte offset from the
 1988                         the queue base where a message may be inserted.
 1989                         */
 1990                   int rptr;
 1991                         /*K* rptr
 1992                         The remove pointer is a char offset from the
 1993                         queue base where the next item is to be removed.
 1994                         */
 1995                   int sz;
 1996                         /*K* sz
 1997                         contains the size, in char, of the queue.
 1998                         */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         55   
 1999                   int offset;
 2000                         /*K* offset
 2001                         contains the offset in char, from the base of the
 2002                         queue segment to the start of the queue.
 2003                         */
 2004                   int brdrptr;
 2005                         /*K* brdrptr
 2006                         The remove pointer used by the on board scan
 2007                         */
 2008                   } scq ;
 2009            int  rfu;
 2010
 2011            int scrfrm;   /*k* scrfrm
 2012                         address of screech frame
 2013                         */
 2014            int ctx_offset;
 2015                         /*k* ctx_offset
 2016                         contains the word offset from the base of the cq
 2017                         segment to the start of the context area.
 2018                         */
 2019            int ctx_sz;
 2020                         /*k* ctx_sz
 2021                         contains the size, in words, of the context area.
 2022                         */
 2023            int ctx_wu;
 2024                         /*k* ctx_wu
 2025                         wakeup on removal too.
 2026                         */
 2027            long msgs_scq;
 2028                         /*k* msgs_scq
 2029                         contains a count that is incremented every time a
 2030                         message is taken from the send circular queue.
 2031                         */
 2032            long mbc_scq;
 2033                         /*k* mbc_scq
 2034                         contains a count of the total number of bytes that
 2035                         have been taken from the send circular queue.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         56   
 2036                         */
 2037            long wrap_scq;
 2038                         /*k* wrap_scq
 2039                         contains a count of times the send circular queue
 2040                         has wrapped.
 2041                         */
 2042            long msgs_rcq;
 2043                         /*k* msgs_rcq
 2044                         contains a count that is incremented every time a
 2045                         message is put into the receive circular queue.
 2046                         */
 2047            long mbc_rcq;
 2048                         /*k* mbc_rcq
 2049                         contains a quad-byte of messages that
 2050                         have been put into the receive circular queue.
 2051                         */
 2052            long wrap_rcq;
 2053                         /*k* wrap_rcq
 2054                         contains a count of times the receive circular queue
 2055                         has wrapped.
 2056                         */
 2057            int last_rcqptr;
 2058                         /*k* last_rcqptr
 2059                         contains a doubleword offset from the start of
 2060                         the rcq to where the last item has been inserted.
 2061                         */
 2062            int last_scqptr;
 2063                         /*k* last_scqptr
 2064                         contains a doubleword offset from the start of
 2065                         the scq to where the last item has been inserted.
 2066                         */
 2067            struct {
 2068                     struct knh_mess mess;
 2069                     char    time[16];
 2070                     } timemsg;
 2071                         /*k* timemsg
 2072                         contains the last time message received from CP-6.
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         57   
 2073                         This mesage is returned to CP-6 as soon as possible.
 2074                         */
 2075            int timectr;
 2076                         /*k* timectr
 2077                         contains a count of time messages received but not
 2078                         not returned.
 2079                         */
 2080            } ;
 2081
 2082      /*     kn_ldct  Logical Device Control Table.                   */
 2083
 2084      struct kn_ldct {
 2085             char    state;          /* ldct state                    */
 2086             char    lck;
 2087             char    generation;
 2088             char    rfu;            /* unused                        */
 2089
 2090      /*     defines for kn_ldct state                                 */
 2091
 2092      #define KN_ST_NULL     0       /* not connected                 */
 2093      #define KN_ST_OWC      1       /* open, waiting connection      */
 2094      #define KN_ST_ACTIVE   2       /* connected to host             */
 2095      #define KN_ST_WIAFR    3       /* waiting for init ack          */
 2096      #define KN_ST_WTAFR    4       /* waiting for terminate ack     */
 2097      #define KN_ST_DTCHD    5       /* detached ldct                 */
 2098      #define KN_ST_TERM     6       /* connection terminated, waiting close */
 2099      #define KN_ST_WTAFL    7       /* term received from CP6, waiting      */
 2100      #define KN_ST_DTWFC    8       /* detached waiting for close    */
 2101
 2102             int     ldctx;          /* index of this entry           */
 2103             struct  {               /* host connection rlcid         */
 2104                     unsigned node : 9;
 2105                     unsigned generation : 9;
 2106                     unsigned ldctx : 18 ;
 2107                     } rlcid;
 2108             int     procp;    /* user process id pointer       */
 2109             int     fd;             /* users file descriptor number  */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         58   
 2110             int     fp;       /* ptr to file descriptor table entry */
 2111             int     wait_count;     /* number of waiting processes   */
 2112             int     wu;             /* set if something posted       */
 2113             int     reason;         /* init/term reason code         */
 2114             int     rescode;        /* init resource code            */
 2115             int     selproc;  /* sleeping on select proc       */
 2116             unsigned queued : 1;
 2117             unsigned str : 15;
 2118             unsigned :2;
 2119             };
 2120
 2121                             /*k* kn_netparm
 2122                             */
 2123
 2124      struct kn_netparm {
 2125             struct  kn_ldct *ldct;
 2126             struct  kn_ldct *sldct;
 2127             char    *msg;
 2128             int     msgsz;
 2129             char    *uhdr;
 2130             int     uhdrsz;
 2131             int     ldctx;
 2132             int rectype;
 2133             struct  {
 2134                     int     function;
 2135                     int     fex;
 2136                     } paramer;
 2137             int     errcode;
 2138             } ;
 2139
 2140      /*     defines for QDP type messages                             */
 2141
 2142      #define K_SQDP_DATA   0
 2143      #define K_SQDP_INIT   1
 2144      #define K_SQDP_INIT_ACK 2
 2145      #define K_SQDP_TERM   3
 2146
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         59   
 2147
 2148                             /*k* qdp_snhdr
 2149                                  This structure is the network and session portion
 2150                                  of qdp messages.
 2151                                                                       */
 2152
 2153      struct qdp_snhdr {
 2154             unsigned msgtyp: 9;                         /* network qdp header  */
 2155             unsigned hop_count : 9;
 2156             unsigned dest_node : 9;
 2157             unsigned source_node : 9;
 2158             unsigned ldct : 18;                           /* session qdp header  */
 2159             unsigned cntrl : 1;                     /* == 1 if session control message*/
 2160             unsigned qdp : 1;                       /* == 1 if qdp && init  */
 2161             unsigned type : 16;                     /* QDP type, K_SQDP_xxx  */
 2162             };
 2163
 2164
 2165                             /*k* qdp_data
 2166                                  This structure describes the header section of
 2167                                  data messages that come and go to the host.  It is
 2168                                  the qdp network and session headers
 2169                             */
 2170
 2171      struct qdp_data {
 2172             struct  qdp_snhdr sn;                   /* session/network portion */
 2173             short   length;                         /* length of remainder of message */
 2174             };
 2175
 2176
 2177      #define K_MSGTYP_CP6_QDP 254
 2178
 2179                             /*k* qdp_init_
 2180
 2181                                  This structure describes the header section of
 2182                                  init messages that go to the host.  It is
 2183                                  the qdp network and session headers
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         60   
 2184                             */
 2185
 2186      struct qdp_init {
 2187             struct  qdp_snhdr sn;                   /* session/network portion */
 2188             struct  {
 2189                     char    node;
 2190                     char    generation;
 2191                     short   ldctx;
 2192                     } rlcid;
 2193             short   sysid;
 2194             char    terminal_speed;
 2195             char    dest_generation;
 2196             char    node_name[8];
 2197             char    resource[8];
 2198             struct  b_terminal_id   terminal_id;
 2199             short   trlr_type;
 2200             short   length;                         /* length of remainder of message */
 2201             };
 2202
 2203                             /*k* qdp_term
 2204                                  This structure describes the header section of
 2205                                  terminate messages that go to the host.
 2206                             */
 2207
 2208      struct qdp_term {
 2209             struct  qdp_snhdr sn;                   /* session/network portion */
 2210             struct  {
 2211                     char    node;
 2212                     char    generation;
 2213                     int     ldctx;
 2214                     } rlcid;
 2215             short   reason;
 2216             short   trlr_type;
 2217             short   length;                         /* length of remainder of message */
 2218             };
 2219
 2220
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         61   
 2221                             /*k* qdp_init_ack
 2222                                  This structure describes the  init_ack
 2223                                  messages that comes from the host.  It is
 2224                                  the qdp network and session headers
 2225                             */
 2226
 2227      struct qdp_init_ack {
 2228             struct  qdp_snhdr sn;                   /* session/network portion */
 2229             struct  {
 2230                     char    node;
 2231                     char    generation;
 2232                     short   ldctx;
 2233                     } rlcid;
 2234             short   reason;
 2235             char    rfu;
 2236             char    rescode;
 2237             short   trlr_type;
 2238             short   length;                         /* length of remainder of message */
 2239             };
 2240
 2241      /*  error return codes for dib_hmi   */
 2242
 2243      #define HMIBUSY   1
 2244      #define BADSCQFMT 2
 2245      #define BADMFMT   3
 2246      #define CQFUL     4
 2247      #define ILLDCT    5
 2248
 2249
 2250      struct knh_devque {
 2251             struct  knh_qhdr        qhdr;
 2252             struct  kj_ctx          ctx;
 2253             struct  knh_mess        mess;
 2254             char                    rcq[RCQ_SIZE];
 2255             char                    scq[SCQ_SIZE];
 2256             };
 2257
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         62   
 2258      /*     structure to locate dib tables the kernel needs          */
 2259
 2260      struct knh_ctl {
 2261             struct knh_devque       *queues;
 2262             struct knh_hmi          *hmis;
 2263             struct kn_ldct          *ldcts;
 2264             long                    ipcflg;
 2265             };
 2266
 2267      /* allocation block header                                       */
 2268
 2269      struct bhdr {
 2270             int h_size;             /* block allocation size         */
 2271             int h_magic;            /* magic number to prove its ours */
 2272             int sz;                 /* record size                   */
 2273             struct bhdr *flnk;      /* buffer list forward link      */
 2274             struct bhdr *blnk;      /* buffer list backward link     */
 2275             };
 2276
 2277      /*      defines for dib user interface      */
 2278
 2279      /*      dib ioctl commands                  */
 2280
 2281      #define DIB_CMD_MAPINIT 1       /* Initialze buffer memory  */
 2282      #define DIB_CMD_INIT    2       /* Establish host connection  */
 2283      #define DIB_CMD_TERM    3       /* Terminate host connection  */
 2284      #define DIB_CMD_TERMALL 4       /* Terminate all host connections */
 2285      #define DIB_CMD_READ    5       /* Read message from host  */
 2286      #define DIB_CMD_DAT     6       /* Write message to host  */
 2287      #define DIB_CMD_ALLOC   7       /* Allocate buffer from buffer memory */
 2288      #define DIB_CMD_FREE    8       /* Return buffer to buffer memory */
 2289      #define DIB_CMD_NODE    9       /* Get host node number   */
 2290      #define DIB_CMD_ATTACH  11      /* Attach LDCT to fildes   */
 2291      #define DIB_CMD_DETACH  12      /* Detach LDCT from fildes  */
 2292      #define DIB_CMD_RSET    13      /* Reset board software   */
 2293      #define DIB_CMD_FEPNODE 14      /* return the node# of this node */
 2294      #define DIB_CMD_NODEINFO 15     /* return node info structure  */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         63   
 2295      #define DIB_CMD_SCREECH 16      /* make dib screech and tell host */
 2296      #define DIB_CMD_HSTSTT  17      /* get host state (recovery/running) */
 2297      #define DIB_CMD_CTL_INT 18      /* get control initial data  */
 2298
 2299      /*      dib_connect - establish host session connection   */
 2300
 2301              struct dib_connect {
 2302                      struct {
 2303                              char    node;   /* host node number  */
 2304                              char    gen;
 2305                              short   ldctx;  /* host ldct index  */
 2306                      } rlcid;
 2307                      struct b_terminal_id term_id;
 2308                      char    speed;
 2309                      int     reason;
 2310                      int     pid;
 2311              };
 2312
 2313              struct dib_connect_ack {
 2314                      unsigned reason :16;
 2315                      unsigned uid :32;
 2316                      unsigned :16;};
 2317
 2318      /*      dib_term - terminate session connection    */
 2319
 2320              struct dib_term {
 2321                      struct {
 2322                              char    node;   /* host node number  */
 2323                              char    gen;
 2324                              short   ldctx;  /* host ldct index  */
 2325                      } rlcid;
 2326                      int     reason;
 2327      #define KN_TERM_REASON_RETRY_EXHAUSTED 1
 2328      #define KN_TERM_REASON_CLOSE 2
 2329      #define KN_TERM_REASON_NTRNSPRT 3
 2330      #define KN_TERM_REASON_LST 4
 2331                      int cos;   /* cost of service */
13:58 NOV 16 '97 TCD$ddu:h.:TCA2SI                                         64   
 2332              };
 2333
 2334              struct dib_term_ack {
 2335                      unsigned reason :16;
 2336                      unsigned x :1 ; 
 2337                      };
 2338
 2339      /*      dib_desc - Descriptor of user memory buffer   */
 2340
 2341              struct dib_desc {
 2342                      int  size;      /* size of buffer   */
 2343                      char *dat;      /* ptr to buffer   */
 2344              };
 2345
 2346      /*      dib_dat - Array of buffer descriptors describing output message */
 2347
 2348              struct dib_dat {
 2349                      int  ndesc;     /* number of descriptors  */
 2350                      int  datsiz;    /* size of data portion of message */
 2351                      struct dib_desc desc[1]; /* descriptors   */
 2352              };
 2353
 2354      /*      dib_nodei - node information        */
 2355
 2356              struct dib_nodei {
 2357                      int  hostnode;  /* host node number   */
 2358                      int  fepnode;   /* fep node number   */
 2359                      char fepname[8]; /* fep name as 8 asci characters */
 2360              };
 2361
 2362      /*      dib_ctl_int - control information    */
 2363
 2364              struct dib_ctl_int {
 2365                      char name[8];   /* handler name    */
 2366                      struct dib_desc desc; /* descriptor for kl_control_init */
 2367              };

