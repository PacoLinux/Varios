/*M* LISTER_SI6 - Copy selected parts of UR files to printer */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* */
LISTER: PROC MAIN;
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
%INCLUDE FM$FIT;
%F$DCB;
%B$TCB;
%B$EXCFR;
%CODE16 (BASED="BASED(T$)");
%P_PCB (W=WORK, WSZ="SIZEW(WORK)",R=OPTIONS);
%PARSE$OUT (STCLASS="BASED(P_PCB.OUT$)");
%PARSE$SYM (STCLASS=BASED);
%FPT_READ (FPTN=READ_SI, BUF=LINE, DCB=M$SI);
%FPT_READ (FPTN=READ_STD, DCB=F$STD, BUF=THIS_FILE.TEXT);
%FPT_PRECORD (FPTN=PREC_SI, N=-1, DCB=M$SI);
%FPT_OPEN (FPTN=OPEN_SI, FPARAM=FPBUF, DCB=M$SI);
%FPT_OPEN (FPTN=SET_FIRST_FILE, DCB=M$SI, ASN=FILE, SETDCB=YES,
            NAME=INITIAL_FILE);
%FPT_OPEN (FPTN=SET_SI_NOQUES,DCB=M$SI,SETDCB=YES,NAME=FILENAME);
%FPT_OPEN (FPTN=SET_LO_TO_LP, DCB=M$LO, ASN=DEVICE, RES='LP  ', ORG=UR,
            SETDCB=YES, CTG=YES, IXTNSIZE=20, XTNSIZE=20);
%FPT_OPEN (FPTN=PERMIT_USER_OVERRIDE, DCB=M$LO, REASSIGN=YES,
            SETDCB=YES);
%FPT_OPEN (FPTN=OPEN_LO, DCB=M$LO);
%FPT_OPEN (FPTN=SET_LO_STAR, DCB=M$LO, ASN=FILE, FUN=CREATE, CTG=YES,
           ORG=UR, EXIST=NEWFILE, NAME=NAME_STAR, PASS=ERASE);
%FPT_OPEN (FPTN=OPEN_ME, DCB=M$ME, ASN=DEVICE, RES='ME  ', CTG=YES);
%FPT_OPEN (FPTN=SET_STD, DCB=M$SI, FUN=IN, NAME=THIS_FILE,
    SETDCB=YES, ASN=FILE);
%FPT_OPEN (FPTN=OPEN_STD,DCB=F$STD,FUN=IN,ACCT=FID_ACCT,
           NAME=FID_NAME,PASS=FID_PASS,SN=FID_SN,WSN=FID_WSN);
%FPT_RELDCB (DCB="DCBNUM(M$LO)", STCLASS=CONSTANT);
%FPT_GETDCB (DCBNAME=POUND3, MERGE=YES, STCLASS=CONSTANT);
%VLP_NAME (FPTN=POUND3, NAME='#3', STCLASS=CONSTANT);
%FPT_CLOSE (FPTN=CLOSE_SI, DCB=M$SI);
%FPT_CLOSE (FPTN=CLOSE_LO, DCB=M$LO);
%FPT_WRITE (FPTN=WRITE_LO, BUF=LINE, DCB=M$LO, VFC=YES);
%FPT_WRITE (FPTN=SKIP_TWO_LINES, BUF=SKIPPER, DCB=M$LO, VFC=YES);
%FPT_WRITE (FPTN=WRITE_BLANK, DCB=M$LO, BUF=BLNKS, VFC=YES);
%FPT_WRITE (FPTN=WRITE_ME, DCB=M$ME, BUF=THIS_FILE.TEXT);
%FPT_WRITE (FPTN=WRITE_LINE_ME, DCB=M$ME, BUF=LINE.TEXT);
%FPT_ERRMSG (FPTN=DEATH_RATTLE, DCB=M$SI, OUTDCB1=M$DO, BUF=LINE);
%FPT_DEVICE (FPTN=EJECT_PAGE, DCB=M$LO, PAGE=YES);
%FPT_DEVICE (FPTN=SET_HDR, HDR=VLP_HDR, DCB=M$LO, PAGE=YES, STCLASS=CONSTANT);
%FPT_CORRES (FPTN=CHECK_LO_VS_ME, DCB1=M$LO, DCB2=M$ME);
%FPT_LDEV;
%FPT_CMDVAR (NAME=CMDNAME,VALUE=CMDVALUE,FUN=STORE);
%FPT_LINK (ECHO=NO, CP_CMD=TEMPLINE, STCLASS=CONSTANT);
%FPT_FID (ACCT=FID_ACCT,ASN=OPEN_STD.V.ASN#,NAME=FID_NAME,
          PASS=FID_PASS,RES=OPEN_STD.V.RES#,SN=FID_SN,
          TEXTFID=LINE.TEXT,WSN=FID_WSN);
%VLP_NAME (FPTN=INITIAL_FILE, NAME='$');
%VLP_NAME (FPTN=FID_NAME);
%VLP_ACCT (FPTN=FID_ACCT);
%VLP_PASS (FPTN=FID_PASS);
%VLP_SN (FPTN=FID_SN);
%VLP_WSN (FPTN=FID_WSN);
%VLP_FORM  (FPTN=OUTPUT_FORM);
%VLP_HDR (LEN=140);
%SUB LOGICAL = "BIT(1) UNAL";
%SUB FOREVER="WHILE ('1'B)";
%EQU LS=0;
%EQU LO=1;
%EQU DM=2;
%EQU PM=3;
%EQU BA=4;
%EQU SET_OLD=5;
%EQU ONE_OLD=6;
%EQU ALL_OLD=7;
%EQU CR=8;
%EQU END=9;
%EQU BREAK=10;
%EQU CMDVAR=11;
%EQU EDGMRK=12;
%EQU STD=13;
%EQU OFFSETS=14;
%EQU LU=15;
%EQU MANY_FILES=33;
%EQU ALL=34;
%EQU NULL=35;
%EQU NO_TYPE=0;
%EQU PL6=1;
%EQU PARTRGE=2;
%EQU BMAP=3;
%EQU PL1=4;
%EQU GMAP6=5;
%EQU PL6_OLD=6;
%EQU PARTRGE_NEW = 7;
%EQU CC = 8;
%EQU MAXPROC = 8;
%EQU AP = 9;
%EQU ON_PREP=72;
%EQU OVER_PREP=73;
%EQU INTO_PREP=74;
%EQU OU_FID=75;
%EQU LO_FID=76;
/**/
%MACRO TEXTC (STRING=' ', LAST(YES=";", NO=",")=",");
        2 *,
          3 * UBIN BYTE UNAL INIT (LENGTHC(STRING)),
          3 * CHAR (39) INIT (STRING) LAST
%MEND;
DCL M$SI DCB;
DCL M$LO DCB;
DCL M$DO DCB;
DCL M$ME DCB;
DCL F$STD DCB;
DCL B$JIT$ PTR SYMREF;
DCL B$TCB$ PTR SYMREF;
DCL X$PARSE ENTRY (1) ALTRET;
DCL XSF$LOCCODP ENTRY (2) ALTRET;
DCL MABLE9 ENTRY (5) ALTRET;
DCL I UBIN;
DCL J UBIN;
DCL K UBIN;
DCL FINDX UBIN;
DCL ACCT CHAR(8) STATIC;
DCL FPBUF(0:1023) UBIN STATIC;
DCL WORK(0:1023) REDEF FPBUF UBIN;
DCL 1 EDGECMD STATIC,
      2 L UBIN(9) UNAL INIT(7),
      2 PREP CHAR(4) INIT('ON'),
      2 * CHAR(1) INIT(' '),
      2 FID CHAR(76) INIT('*G');
DCL PREPS(0:2) CONSTANT CHAR(4) INIT('ON  ','OVER','INTO');
DCL OU_EXISTS LOGICAL STATIC INIT(%NO#);
DCL 1 CMDNAME STATIC DALIGNED,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL 1 CMDVALUE STATIC DALIGNED,
      2 L UBIN(9) UNAL,
      2 C CHAR(31);
DCL EDGMRKEACH LOGICAL;
DCL 1 EDGMRKBUF,
      2 L UBIN(9) UNAL,
      2 C CHAR(119);
DCL 1 LINE STATIC,
      2 VFC CHAR (1),
      2 TEXT CHAR (139),
      2 T REDEF TEXT,
        3 XT CHAR (40),
        3 * CHAR (99),
      2 ARS UBIN;
DCL LINEC REDEF LINE CHAR(144);
DCL 1 OLDLINE STATIC,
      2 VFC CHAR(1),
      2 TEXT CHAR(139),
      2 ARS UBIN;
DCL 1 TEMPLINE STATIC,
      2 VFC CHAR(1),
      2 L REDEF VFC UBIN(9) UNAL,
      2 TEXT CHAR(139),
      2 ARS UBIN;
DCL 1 SAVLINE,
      2 VFC CHAR(1),
      2 TEXT CHAR(139),
      2 ARS UBIN;
DCL PROCNO CHAR(4);
DCL PROCNOT REDEF PROCNO SBIN;
DCL OFFSKBL LOGICAL;
DCL PUTHDR LOGICAL;
DCL PAGENO UBIN;
DCL PAGE_CHARS CONSTANT CHAR(0) INIT(' :=.#(*-/_<[{|~');
DCL FINDLU LOGICAL;
DCL SAVVFC CHAR(1) STATIC;
DCL PREVVFC CHAR(1) STATIC;
DCL PREVVFCO REDEF PREVVFC BIT(9);
DCL FORCE_EJECT LOGICAL STATIC;
DCL CHK_VFC LOGICAL STATIC;
DCL FIRST_REC LOGICAL STATIC;
DCL SKIPPER CHAR(0) CONSTANT INIT ('b');
DCL BLNKS CHAR(0) CONSTANT INIT('A ');
%VLP_NAME (FPTN=NAME_STAR,NAME='*LISTER_EDGMRK');
DCL L SBIN;
DCL C SBIN;
DCL T$ PTR STATIC;
DCL PAGEMAX UBIN STATIC INIT(1000);
DCL FID CHAR (31);
DCL BANNERFIDFLG LOGICAL STATIC INIT(%NO#);
DCL BANNERFID CHAR(31);
DCL BANNERFIDLEN UBIN;
DCL VERSION CHAR(14) STATIC;
DCL VERSIONLEN UBIN STATIC;
DCL STRIKE_PATTERN CHAR (0) STATIC INIT ('WM0#');
DCL OPTIONS BIT(36) SYMREF;
DCL MODE UBIN STATIC INIT (%LS);
DCL SAVEMODE UBIN STATIC INIT(%NULL);
DCL FILE_TYPE UBIN STATIC INIT (%NO_TYPE);
DCL PFLAG (0:35) LOGICAL;
DCL FORCE_OUT LOGICAL;
DCL BOLDFACE LOGICAL;
DCL FILE_FOUND LOGICAL STATIC INIT (%NO#);
DCL 1 FILENAME STATIC,
      2 LEN UBIN BYTE UNAL,
      2 TEXT CHAR (31);
DCL 1 THIS_FILE STATIC,
      2 LEN UBIN BYTE UNAL,
      2 TEXT CHAR (31);
DCL LAST_FILE CHAR (31) STATIC INIT ('zzzzzzzzzz');
DCL 1 TYPE_KEYWORDS CONSTANT UNAL,
%TEXTC;
%TEXTC (STRING='PL6.');
%TEXTC (STRING='PARTRGE VERSION');
%TEXTC (STRING=' BMAP VERSION ');
%TEXTC (STRING='CP6-PL/1');
%TEXTC (STRING='DIRECTORY AND SEGMENT LIST');
%TEXTC (STRING='PL6 VERSION');
%TEXTC (STRING='PARTRGE version');
%TEXTC (STRING='CC.', LAST=YES);
DCL 1 TYPE_KEYWORD (0:%MAXPROC) REDEF TYPE_KEYWORDS,
      2 LEN UBIN BYTE UNAL,
      2 STRING CHAR (39);
DCL 1 TEXTC BASED,
      2 LEN UBIN BYTE UNAL,
      2 TEXT CHAR (TEXTC.LEN) UNAL;
DCL M$SI$ PTR;
DCL M$LO$ PTR;
DCL F$STD$ PTR;
DCL COMPUNIT CHAR(3) STATIC INIT('   ');
DCL ERRCODE BIT(36) STATIC;
 
        CALL INITIALIZE;
 
        CALL PROCESS;
 
INITIALIZE: PROC;
 
        PFLAG = %NO#;
        PFLAG(%LS) = %YES#;
        PFLAG(%LU) = %YES#;
        CMDNAME = '0'B;
        CMDVALUE = '0'B;
        EDGMRKEACH = %YES#;
        EDGMRKBUF.L = 0;
        EDGMRKBUF.C = ' ';
        M$SI$ = DCBADDR(DCBNUM(M$SI));
        M$LO$ = DCBADDR(DCBNUM(M$LO));
        F$STD$ = DCBADDR(DCBNUM(F$STD));
        COMPUNIT = ' ';
 
        IF B$JIT.CCARS > 0
        THEN DO;
 
           P_PCB.TEXT$ = ADDR(B$JIT.CCBUF);
 
           P_PCB.NCHARS = B$JIT.CCARS;
 
           CALL X$PARSE (P_PCB) ALTRET (SYNTAX_ERROR);
 
           DO I = 0 TO OUT$BLK.NSUBLKS - 1;
 
              C = OUT$BLK.SUBLK$(I) -> OUT$BLK.CODE;
 
              DO CASE (C);
 
               CASE (%OFFSETS);
 
                 PFLAG(%LS) = %NO#;
                 PFLAG(%LO) = %YES#;
                 PFLAG(%OFFSETS) = %YES#;
 
               CASE (%BREAK);
 
                 CALL CHARBIN(PAGEMAX, OUT$BLK.SUBLK$(I)->OUT$BLK.SUBLK$(0)->
                   OUT$SYM.TEXT);
 
               CASE (%CMDVAR);
 
                 CMDNAME.L = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                   OUT$SYM.COUNT;
                 CMDNAME.C = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                   OUT$SYM.TEXT;
 
               CASE (%EDGMRK);
 
                 EDGMRKBUF.C = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                   OUT$SYM.TEXT;
                 EDGMRKBUF.L = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                   OUT$SYM.COUNT;
                 CALL INDEX (K, 'LEFT=''', EDGMRKBUF.C) WHENRETURN DO;
                    EDGMRKEACH = %NO#;
                    END;
 
               CASE (%ON_PREP, %OVER_PREP, %INTO_PREP);
 
                 EDGECMD.PREP = PREPS (C-%ON_PREP);
 
               CASE (%OU_FID, %LO_FID);
 
                 IF C=%LO_FID AND OU_EXISTS THEN EXIT;
                 IF C=%OU_FID THEN OU_EXISTS = %YES#;
                 EDGECMD.FID = OUT$BLK.SUBLK$(I) -> OUT$SYM.TEXT;
                 EDGECMD.L = OUT$BLK.SUBLK$(I) -> OUT$SYM.COUNT+5;
 
               CASE (%STD);
 
                 LINE.TEXT = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                   OUT$SYM.TEXT;
                 CALL M$FID (FPT_FID) ALTRET (BAD_FID);
                 CALL M$OPEN (OPEN_STD) ALTRET (BAD_FID);
                 PFLAG(%MANY_FILES) = %YES#;
                 PFLAG(%STD) = %YES#;
 
               CASE (%END);
 
                 PFLAG(%ALL) = %YES#;
                 IF OUT$BLK.SUBLK$(I) -> OUT$BLK.NSUBLKS = 1 THEN
                    LAST_FILE = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                      OUT$SYM.TEXT;
 
               CASE(%BA);
 
                 PFLAG(%BA) = %YES#;
 
                 IF OUT$BLK.SUBLK$(I) -> OUT$BLK.NSUBLKS = 1 THEN DO;
                    BANNERFID = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                      OUT$SYM.TEXT;
 
                    BANNERFIDLEN = OUT$BLK.SUBLK$(I) -> OUT$BLK.SUBLK$(0) ->
                      OUT$SYM.COUNT;
 
                    BANNERFIDFLG = %YES#;
 
                    END;
 
               CASE(%SET_OLD,%ALL_OLD,%ONE_OLD);
 
                 THIS_FILE.TEXT = 'Opts SET, ONE and ALL ignored';
 
                 CALL M$WRITE (WRITE_ME);
 
               CASE (ELSE);
 
                 IF C<36 THEN PFLAG(C) = %YES#;
                 ELSE PFLAG(C-36) = %NO#;
 
               END;
 
              END;
 
           END;
 
        IF EDGMRKBUF.L = 0 THEN DO;
           IF OU_EXISTS THEN DO;
/* Use OUDCB if it's explicitly specified. */
              CALL M$RELDCB (FPT_RELDCB);
              CALL M$GETDCB (FPT_GETDCB);
              END;
           CALL M$OPEN (SET_LO_TO_LP);
           CALL M$OPEN (PERMIT_USER_OVERRIDE);
           END;
 
        CALL M$OPEN (OPEN_ME);
 
        FILENAME = M$SI$ -> F$DCB.NAME#;
 
        IF PFLAG(%STD) THEN
           GOTO RET;
 
        CALL INDEX ( I, '?', FILENAME.TEXT ) ALTRET(RET);
 
        PFLAG(%MANY_FILES) = %YES#;
 
        FILENAME.LEN = I;
 
        CALL INSERT ( FILENAME.TEXT, I, , ' ' );
 
        CALL M$OPEN ( SET_SI_NOQUES );
 
RET:    ;
        RETURN;
 
SYNTAX_ERROR:
 
        LINE.TEXT = B$JIT.CCBUF;
        CALL M$WRITE (WRITE_LINE_ME);
        LINE.TEXT = ' ';
        CALL INSERT (LINE.TEXT, P_PCB.HI_CHAR, 1, '^');
        CALL M$WRITE (WRITE_LINE_ME);
        LINE.TEXT = ' Syntax error in LISTER options';
        CALL M$WRITE (WRITE_LINE_ME);
 
        CALL M$ERR;
 
BAD_FID: ;
        DEATH_RATTLE.CODE_ = VECTOR(ERRCODE);
        ERRCODE = B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR;
        LINE.TEXT = ' Bad standard file fid';
        CALL M$WRITE (WRITE_LINE_ME);
        CALL M$ERRMSG (DEATH_RATTLE);
        CALL M$ERR;
 
END INITIALIZE;
 
PROCESS: PROC;
 
        DO FOREVER;
 
           CALL OPEN_FILE ALTRET (FINI);
 
           IF M$SI$ -> F$DCB.ORG# = %UR#
           THEN DO;
 
              CALL CHECK_FILE ALTRET (FINI);
 
              FILE_FOUND = %YES#;
 
              CALL LIST_FILE;
 
              CALL M$CLOSE (CLOSE_LO);
 
              IF EDGMRKBUF.L ~= 0 AND EDGMRKEACH
              THEN CALL EDGMRKIT ALTRET (EDG_FAIL);
              ELSE
                 IF M$LO$->F$DCB.ASN#=%DEVICE# AND M$LO$->F$DCB.IASN=%STREAM#
                   AND M$LO$->F$DCB.CFU$~=DCBADDR(%M$UC#) THEN DO;
                    T$=M$LO$->F$DCB.CFU$->F$DCB.FORM$;
                    IF T$~=ADDR(NIL) THEN
                       IF CODE16.PAGENO>=PAGEMAX THEN DO;
                          IF SUBSTR(M$LO$->F$DCB.RES#,2,2)~=' ' THEN
                             FPT_LDEV.V.STREAMNAME#=M$LO$->F$DCB.RES#;
                          ELSE
                             FPT_LDEV.V.STREAMNAME#='LP01';
                          CALL M$LDEV(FPT_LDEV) ALTRET(CLS);
                          THIS_FILE.TEXT = 'Performing !LDEV of output strm';
                          CALL M$WRITE (WRITE_ME);
                          END;
                    END;
 
              END;
 
CLS:       ;
           CALL CLOSE_FILE;
 
           END;
 
FINI:
 
        IF NOT (FILE_FOUND)
        THEN DO;
 
           ACCT = M$SI$ -> F$DCB.ACCT#;
 
           IF ACCT = ' ' THEN
              ACCT = B$JIT.FACCN;
 
           CALL CONCAT(THIS_FILE.TEXT, 'No files to list in .', ACCT);
 
           CALL M$WRITE (WRITE_ME);
 
           END;
        ELSE IF NOT EDGMRKEACH
           THEN CALL EDGMRKIT ALTRET(EDG_FAIL);
 
        RETURN;
 
EDG_FAIL: ;
 
        DEATH_RATTLE.CODE_ = VECTOR(B$TCB$->B$TCB.ALT$->B$EXCFR.ERR);
        CALL M$ERRMSG (DEATH_RATTLE);
        CALL M$ERR;
 
END PROCESS;
 
OPEN_FILE: PROC ALTRET;
 
        FILE_TYPE = %NO_TYPE;
 
        MODE = %LS;
 
        IF PFLAG(%STD) THEN DO;
           CALL M$READ (READ_STD) ALTRET(STD_ERR);
           THIS_FILE.LEN = F$STD$->F$DCB.ARS#;
           IF THIS_FILE.LEN = 0 THEN
              ALTRETURN;
           CALL M$OPEN (SET_STD);
           END;
 
        ELSE
 
           IF OPEN_SI.V.OPER.NXTF#
           THEN
              OPEN_SI.V.OPER.THISF# = %NO#;
           ELSE
              IF PFLAG(%MANY_FILES) OR PFLAG(%ALL)
              THEN DO;
                 OPEN_SI.V.OPER.NXTF# = %YES#;
                 OPEN_SI.V.OPER.THISF# = %YES#;
                 END;
 
        CALL M$OPEN (OPEN_SI) ALTRET (NOT_OPENED);
 
        THIS_FILE = M$SI$ -> F$DCB.NAME#;
 
        RETURN;
 
NOT_OPENED:
 
        IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.CODE = %E$FDEOF
        THEN
           ALTRETURN;
 
ERR:    ;
        DEATH_RATTLE.CODE_ = VECTOR(B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR);
 
        CALL M$ERRMSG (DEATH_RATTLE);
 
        CALL M$ERR;
 
STD_ERR: ;
        IF B$TCB$ -> B$TCB.ALT$ -> B$EXCFR.ERR.CODE = %E$EOF THEN
           ALTRETURN;
        GOTO ERR;
 
END OPEN_FILE;
 
CHECK_FILE: PROC ALTRET;
 
        IF FILENAME.LEN > 0
          AND PFLAG(%MANY_FILES) AND NOT PFLAG(%ALL)
        THEN
           IF SUBSTR(THIS_FILE.TEXT, 0, FILENAME.LEN) >
             SUBSTR(FILENAME.TEXT, 0, FILENAME.LEN)
           THEN
              ALTRETURN;
 
        IF PFLAG(%ALL)
          AND THIS_FILE.TEXT > LAST_FILE
        THEN
           ALTRETURN;
 
        IF M$LO$->F$DCB.FORM$=ADDR(NIL) THEN DO;
 
/* Copy form to the output if not otherwise specified */
 
           T$ = ADDR(FPBUF);
 
           CALL XSF$LOCCODP (T$, 16) ALTRET (NO_CODE16);
 
           OUTPUT_FORM.FORM# = CODE16.FORM;
 
           OPEN_LO.FORM_ = VECTOR(OUTPUT_FORM);
           SET_LO_STAR.FORM_ = VECTOR(OUTPUT_FORM);
 
           EXIT;
 
NO_CODE16: OPEN_LO.FORM_ = VECTOR(ERASE);
           SET_LO_STAR.FORM_ = VECTOR(ERASE);
 
           END;
 
        IF EDGMRKBUF.L=0 THEN
           CALL M$OPEN (OPEN_LO);
        ELSE DO;
           CALL M$OPEN (SET_LO_STAR);
           IF NOT EDGMRKEACH
           THEN SET_LO_STAR.V.EXIST# = %OLDFILE#;
           END;
 
        CALL M$CORRES (CHECK_LO_VS_ME) ALTRET (SAME_ASSIGN);
 
        CALL M$WRITE (WRITE_ME);
 
SAME_ASSIGN: IF PFLAG (%LS) OR PFLAG (%OFFSETS)
        THEN DO;
 
           CALL EJECT;
 
           END;
 
        ELSE DO;
 
           CALL CONCAT (LINE.TEXT, 'File: ', THIS_FILE.TEXT);
 
           LINE.VFC = 'A';
 
           WRITE_LO.BUF_.BOUND = 40;
 
           CALL M$WRITE (SKIP_TWO_LINES);
 
           CALL M$WRITE (WRITE_LO);
 
           END;
 
        RETURN;
 
END CHECK_FILE;
 
PRINT_BANNER: PROC;
 
        IF NOT BANNERFIDFLG THEN DO;
 
           BANNERFID = THIS_FILE.TEXT;
 
           BANNERFIDLEN = THIS_FILE.LEN;
 
           END;
 
        IF NOT PFLAG(%BA) THEN
           RETURN;
 
        FID = ' ';
 
        IF BANNERFIDLEN <= 11 THEN
 
           CALL INSERT (FID, (11 - BANNERFIDLEN) / 2, , BANNERFID);
        ELSE
 
           FID = BANNERFID;
 
        IF SUBSTR(THIS_FILE.TEXT,0,1) = '*' THEN
           ACCT = ' ';
 
        ELSE
 
        DO;
 
           ACCT = M$SI$ -> F$DCB.ACCT#;
 
           IF ACCT = ' ' THEN
              ACCT = B$JIT.FACCN;
 
           END;
 
        LINE.VFC = '0';
 
        IF ACCT ~= ' ' THEN
           CALL CONCAT ( LINE.TEXT, '.', ACCT );
        ELSE
           LINE.TEXT = ' ';
 
        IF VERSIONLEN~=0 THEN DO;
           CALL INSERT( LINE.TEXT, 15, 8, 'Version ' );
           CALL INSERT( LINE.TEXT, 23, SIZEC(VERSION), VERSION );
           END;
 
        WRITE_LO.BUF_.BOUND = 23+SIZEC(VERSION)-1;
 
        CALL M$WRITE ( WRITE_LO );
 
        FINDX = 0;
 
        DO WHILE( FINDX < BANNERFIDLEN );
 
           DO I = 0 TO 8;
 
              CALL MABLE9 (I, SUBSTR(FID,FINDX,11), 11, LINE.TEXT, J);
 
              WRITE_LO.BUF_.BOUND = J - 1;
 
              DO J = 0 TO LENGTHC(STRIKE_PATTERN) - 1;
 
                 DO K = 0 TO LENGTHC(LINE.TEXT) - 1;
 
                    IF SUBSTR(LINE.TEXT, K, 1) ~= ' '
                    THEN
                       CALL INSERT (LINE.TEXT, K, 1, SUBSTR(STRIKE_PATTERN, J, 1));
 
                    END;
 
                 IF J = 0
                 THEN
                    IF I = 0
                    THEN
                       LINE.VFC = 'c';
                    ELSE
                       LINE.VFC = 'a';
                 ELSE
                    IF I = 8 AND J = LENGTHC(STRIKE_PATTERN) - 1
                    THEN
                       LINE.VFC = 'B';
                    ELSE
                       LINE.VFC = '`';
 
                 CALL M$WRITE (WRITE_LO);
 
                 END;
 
              END;
 
           FINDX = FINDX + 11;
 
           END;
 
        RETURN;
 
END PRINT_BANNER;
 
LIST_FILE: PROC;
 
 
        PUTHDR = %NO#;
        PAGENO = 0;
        PROCNOT = -1;
        FINDLU = %YES#;
        COMPUNIT = ' ';
        FORCE_EJECT = %NO#;
        FORCE_OUT = %NO#;
        CHK_VFC = %NO#;
        VERSIONLEN = 0;
        FIRST_REC = %YES#;
 
        DO FOREVER;
 
READREC:   ;
           CALL READ_REC ALTRET (FINI);
 
           IF FIRST_REC THEN DO;
              FIRST_REC = %NO#;
              IF SUBSTR(LINE.TEXT,0,8) = 'VERSION ' THEN DO;
                 CALL INDEX1(VERSIONLEN, ' ', SUBSTR(LINE.TEXT,8,LENGTHC(VERSION)));
                 VERSION = SUBSTR(LINE.TEXT, 8, VERSIONLEN);
                 IF VERSIONLEN~=0 AND CMDNAME.L~=0 THEN DO;
                    CMDVALUE.L=VERSIONLEN;
                    CMDVALUE.C=VERSION;
                    CALL M$CMDVAR(FPT_CMDVAR);
                    END;
                 END;
              TEMPLINE=LINE;
              CALL PRINT_BANNER;
              CALL PRINT_BANNER;
              LINE=TEMPLINE;
              IF VERSIONLEN~=0 THEN
                 GOTO READREC;
              END;
 
           CALL TEST_REC;
 
           CALL PRINT_REC;
 
           END;
 
FINI:   RETURN;
 
END LIST_FILE;
 
CLOSE_FILE: PROC;
 
        CALL M$CLOSE (CLOSE_SI);
 
        CALL M$CLOSE (CLOSE_LO);
 
        IF NOT PFLAG(%MANY_FILES) AND NOT PFLAG(%ALL)
        THEN
           CALL M$EXIT;
 
        RETURN;
 
END CLOSE_FILE;
 
READ_REC: PROC ALTRET;
 
        IF LINE.TEXT ~= ' ' THEN
           OLDLINE = LINE;
 
        LINEC = ' ';
 
        FORCE_OUT = %NO#;
        BOLDFACE = %NO#;
 
        CALL M$READ (READ_SI) ALTRET (EOF_HIT);
        LINE.ARS = M$SI$->F$DCB.ARS#;
 
        RETURN;
 
EOF_HIT: ALTRETURN;
 
END READ_REC;
 
EDGMRKIT: PROC ALTRET;
 
        TEMPLINE.TEXT = 'EDGEMARK.X    *LISTER_EDGMRK (';
        IF M$LO$->F$DCB.AMR# AND NOT B$JIT.PRFLAGS.OU AND NOT B$JIT.PRFLAGS.LS
        THEN K = 30;
        ELSE DO;
           CALL INSERT(TEMPLINE.TEXT,29,,SUBSTR(EDGECMD.PREP,0,EDGECMD.L),'(');
           K = EDGECMD.L+30;
           EDGECMD.PREP = 'INTO';
           END;
        CALL INDEX (I, 'LEFT=', EDGMRKBUF.C);
        IF I >= SIZEC(EDGMRKBUF.C) THEN DO;
           CALL INSERT (TEMPLINE.TEXT, K, , 'LEFT=''', BANNERFID);
           CALL INSERT (TEMPLINE.TEXT, K+6+BANNERFIDLEN, 1, '''');
           K = BANNERFIDLEN + K + 7;
           CALL INSERT (TEMPLINE.TEXT, K, 1, ',');
           K = K + 1;
           END;
        CALL INDEX (I, '=''VERS''', EDGMRKBUF.C);
        IF I < SIZEC(EDGMRKBUF.C) THEN DO;
           CALL INSERT (TEMPLINE.TEXT, K, , EDGMRKBUF.C);
           K = K + I + 2;
           CALL INSERT (TEMPLINE.TEXT, K, , VERSION);
           K = K + VERSIONLEN;
           CALL INSERT (TEMPLINE.TEXT, K, , SUBSTR(EDGMRKBUF.C,I+6));
           K = K + EDGMRKBUF.L - I - 6;
           END;
        ELSE DO;
           CALL INSERT (TEMPLINE.TEXT, K, , EDGMRKBUF.C);
           K = K + EDGMRKBUF.L;
           END;
        TEMPLINE.L = K;
        CALL M$LINK (FPT_LINK) WHENALTRETURN DO;
           ALTRETURN;
           END;
END EDGMRKIT;
 
TEST_REC: PROC;
 
DCL NULL UBIN;
 
 
TEST_AGAIN: ;
 
        IF MODE=%LS AND FINDLU AND LINE.VFC<'p' AND LINE.VFC>'/' THEN DO;
/* Look for a + in the first record's first 18 columns */
           FINDLU = %NO#;
           CALL INDEX (NULL, '+', SUBSTR(LINE.TEXT,0,18)) WHENRETURN DO;
              CALL CHNGMODE (%LU);
              IF NOT PFLAG(%LU) THEN FORCE_EJECT = %NO#;
              RETURN;
              END;
           END;
 
        IF MODE=%LU THEN IF FORCE_EJECT THEN CALL CHNGMODE (%LS);
           ELSE RETURN;
 
        DO CASE (FILE_TYPE);
 
         CASE (%PL6); GOTO PL6_FILE;
         CASE (%CC); GOTO PL6_FILE;
         CASE (%BMAP); GOTO BMAP_FILE;
         CASE (%PARTRGE); GOTO PARTRGE_FILE;
         CASE (%PL1); GOTO PL1_FILE;
         CASE (%GMAP6); GOTO GMAP6_FILE;
         CASE (%PL6_OLD); GOTO PL6_FILE;
         CASE (%PARTRGE_NEW); GOTO NEW_PARTRGE_FILE;
         CASE(%AP); RETURN;
 
         CASE (ELSE);
 
           IF SUBSTR(LINE.TEXT,0,7) = ' C01' THEN DO;
              FILE_TYPE = %AP;
              GOTO TEST_AGAIN;
              END;
 
           DO I = 1 TO %MAXPROC;
 
              CALL INDEX (NULL, SUBSTR(TYPE_KEYWORD.STRING(I), 0,
                TYPE_KEYWORD.LEN(I)), LINE.TEXT) ALTRET (NOT_THIS_TYPE);
 
              FILE_TYPE = I;
 
              GOTO TEST_AGAIN;
 
NOT_THIS_TYPE:
 
              END;
 
           IF LINE.TEXT=' ' THEN RETURN;
           IF LINE.VFC>'o' THEN FILE_TYPE = %PARTRGE_NEW;
           ELSE FILE_TYPE = %PL1;       /* Until PL1 has a header             */
           GOTO TEST_AGAIN;
 
         END;
 
PL6_FILE: ;
        IF NOT PFLAG(%OFFSETS) OR MODE~=%LO THEN GOTO NOT_OFFSETS;
        IF PROCNOT<0 THEN DO;           /* FIRST TIME HERE                    */
           OFFSKBL = %NO#;
           PROCNOT = 0;
           SAVLINE = LINE;
           CALL READ_REC;;
           GOTO TEST_AGAIN;
           END;
        TEMPLINE = SAVLINE;
        SAVLINE = LINE;
        IF LINE.VFC>'p' THEN DO;
           CALL READ_REC;
           IF LINE.VFC='`' THEN CALL M$PRECORD (PREC_SI);
           ELSE DO;
              PAGENO = PAGENO+1;
              SAVLINE = LINE;
              END;
           END;
        LINE = TEMPLINE;
        IF PROCNOT=0 THEN DO;           /* NO PROC SECTION NUMBER FOUND YET   */
           IF SUBSTR(LINE.TEXT,7,6)=' Proc ' THEN PROCNO=SUBSTR(LINE.TEXT,2,4);
           GOTO NOT_OFFSETS;
           END;
        ELSE IF SAVLINE.ARS=1 AND SAVLINE.VFC='A' THEN DO;
              CALL READ_REC;
              IF LINE.VFC>'p' THEN DO;
                 PAGENO = PAGENO+1;
                 CALL READ_REC;
                 END;
              IF SUBSTR (LINE.TEXT,8,4)=PROCNO
                OR SUBSTR (LINE.TEXT,7,4)=PROCNO THEN DO;
                 IF SUBSTR(LINE.TEXT,10,1)=' ' THEN I=7;
                 ELSE I=8;
                 CALL INSERT(TEMPLINE.TEXT, 12+BITBIN(FILE_TYPE=%CC),7,
                   SUBSTR(LINE.TEXT, I+4,6));
                 DO WHILE SUBSTR(LINEC,0,2)='A ' AND SUBSTR(LINE.TEXT,I,1)=' '
                   AND (LINE.ARS<13 OR SUBSTR(LINE.TEXT, 10,2)~=' ')
                   OR LINE.VFC>='p';
                    IF LINE.VFC>='p' THEN PAGENO = PAGENO+1;
                    CALL READ_REC;
                    END;
                 SAVLINE = LINE;
                 LINE = TEMPLINE;
                 CHK_VFC = %YES#;
                 OFFSKBL = %YES#;
                 END;
              ELSE DO;
                 IF OFFSKBL THEN SAVLINE = LINE;
                 ELSE CALL M$PRECORD (PREC_SI);
                 LINE = TEMPLINE;
                 END;
              END;
 
NOT_OFFSETS: ;
 
        IF MODE=%CR AND LINE.VFC='`' AND OLDLINE.VFC>='p'
        THEN CALL INDEX (NULL, 'XREF LISTING', LINE.TEXT) WHENRETURN DO;
              LINE.VFC = 'b';
              END;
 
        IF FILE_TYPE=%PL6_OLD THEN GOTO OLD_PL6;
 
        CALL INDEX (NULL, 'Object Unit name=', LINE.TEXT) ALTRET (NOT_NEW_LO);
        CALL CHNGMODE (%LO);
        RETURN;
 
NOT_NEW_LO: ;
        CALL INDEX (NULL, 'Procedure blocks', LINE.TEXT) ALTRET (NOT_NEW_PM);
        CALL CHNGMODE (%PM);
        RETURN;
 
NOT_NEW_PM: ;
        CALL INDEX (NULL, 'Variables and constants', LINE.TEXT) ALTRET (NOT_DM);
        CALL CHNGMODE (%DM);
        RETURN;
 
OLD_PL6: ;
        CALL INDEX (NULL, 'OBJECT UNIT NAME=', LINE.TEXT) ALTRET (NOT_LO);
        CALL CHNGMODE (%LO);
        RETURN;
 
NOT_LO: ;
 
        CALL INDEX (NULL, 'PROCEDURE BLOCKS', LINE.TEXT) ALTRET (NOT_PM);
        CALL CHNGMODE (%PM);
        RETURN;
 
NOT_PM: ;
        CALL INDEX (NULL, 'VARIABLES AND CONSTANTS', LINE.TEXT) ALTRET (NOT_DM);
        CALL CHNGMODE (%DM);
        RETURN;
 
NOT_DM: ;
        IF FILE_TYPE=%CC THEN DO;
           CALL INDEX(NULL, '", line ', LINE.TEXT) ALTRET (CHK_OLD_LS);
           GOTO PL6_ERR;
           END;
 
        CALL INDEX(NULL, 'CROSS REFERENCE LISTING', LINE.TEXT) ALTRET (NOT_CR);
        CALL CHNGMODE (%CR);
        RETURN;
 
NOT_CR: ;
        CALL INDEX (NULL, ' issued in procedure ', LINE.TEXT) ALTRET (NOT_DIAG);
        IF (( MODE=%LS AND ( NOT PFLAG(%LS) ) AND ( NOT PFLAG(%LO))) OR
          ( PFLAG(MODE) AND ( MODE=%LS OR MODE=%LO) ) )
        THEN FORCE_OUT = %YES#;
        IF MODE = %LO THEN
           CALL CHNGMODE(%NULL);
        BOLDFACE = %YES#;
 
        RETURN;
 
NOT_DIAG: ;
 
        CALL INDEX(NULL, ' words of local(', LINE.TEXT) ALTRET (NOT_SIZE);
        IF ( MODE = %LS AND PFLAG(%LS) )
        THEN FORCE_OUT = %YES#;
        ELSE IF ( MODE ~= %LS ) AND (PFLAG(%LO) OR PFLAG(%DM)) AND NOT PFLAG(MODE) THEN DO;
              TEMPLINE = LINE;
              LINE = OLDLINE;
              FORCE_OUT = %YES#;
              CALL PRINT_REC;
              LINE = TEMPLINE;
              FORCE_OUT = %YES#;
              END;
        IF PFLAG(MODE) THEN
           FORCE_OUT = %YES#;
        SAVEMODE = MODE;
        CALL CHNGMODE(%NULL);
        RETURN;
 
NOT_SIZE: ;
 
        IF SUBSTR(LINE.TEXT,13,2) ~= ' Z' AND SUBSTR(LINE.TEXT,12,2)~=' *' THEN
           GOTO NOT_ERR;
        IF SUBSTR(LINE.TEXT,12,6)~=' *** Z' AND
          SUBSTR(LINE.TEXT,12,5)~=' ** Z' AND
          SUBSTR(LINE.TEXT,12,4)~=' * Z' AND
          SUBSTR(LINE.TEXT,13,2)~=' Z' THEN
           GOTO NOT_ERR;
PL6_ERR: ;
        IF NOT PFLAG(MODE) THEN
           IF NOT ( MODE = %LS AND (NOT PFLAG(%LO))) THEN
              GOTO RET;
        IF OLDLINE.VFC>='p' THEN OLDLINE = SAVLINE;
        IF NOT PFLAG(MODE) AND SUBSTR(OLDLINE.TEXT,13,2) ~= ' Z'
          AND SUBSTR(OLDLINE.TEXT,0,1)~='"' /* for CC                         */
          AND SUBSTR(OLDLINE.TEXT,12,2)~=' *' THEN DO;
           TEMPLINE = LINE;
           LINE = OLDLINE;
           FORCE_OUT = %YES#;
           CALL PRINT_REC;
           LINE = TEMPLINE;
           END;
        FORCE_OUT = %YES#;
        BOLDFACE = %YES#;
        RETURN;
 
NOT_ERR: ;
        IF LINE.VFC < 'p' OR LINE.VFC > 'z' THEN
           GOTO CHK_OLD_LS;
        CALL INDEX (NULL, 'PL6.', LINE.TEXT) ALTRET(CHK_OLD_LS);
        CALL INDEX (NULL, '#', LINE.TEXT,NULL+1 ) ALTRET(CHK_OLD_LS);
        IF SUBSTR(LINE.TEXT,NULL+3,1)='=' THEN
           I=2;
        ELSE
           I=3;
        IF SUBSTR(LINE.TEXT, NULL+1, I) = COMPUNIT THEN
           GOTO CHK_OLD_LS;
        COMPUNIT = SUBSTR(LINE.TEXT, NULL+1, I);
        CALL CHNGMODE (%LS);
        RETURN;
 
CHK_OLD_LS: ;
        CALL INDEX(NULL,' detected in ',LINE.TEXT) ALTRET(NOTOT);
        IF FILE_TYPE=%CC THEN DO;
           IF SUBSTR(LINE.TEXT, NULL+13, 8)~='the file' THEN GOTO NOTOT;
           END;
        ELSE IF SUBSTR(LINE.TEXT, NULL+13, 5)~='file ' THEN GOTO NOTOT;
        IF (SAVEMODE = %LS) OR (MODE = %LS)
        THEN IF ( (NOT PFLAG(%LS)) AND (NOT PFLAG(%LO)) ) OR PFLAG(%LS)
           THEN FORCE_OUT = %YES#;
           ELSE;
        ELSE IF PFLAG(%LO) OR PFLAG(%DM)
           THEN FORCE_OUT = %YES#;
        CALL CHNGMODE (%NULL);
        SAVEMODE = %NULL;
        BOLDFACE = %YES#;
        RETURN;
 
NOTOT:  ;
 
        CALL INDEX (NULL, ' Include file information ', LINE.TEXT) ALTRET (RET);
 
        FORCE_EJECT = %NO#;
        OFFSKBL = %NO#;
        LINE.VFC = 'b';
 
        IF PFLAG(MODE) THEN
           FORCE_OUT = %YES#;
        RETURN;
 
 
RET:    ;
        RETURN;
 
PARTRGE_FILE:
 
        CALL INDEX (NULL, 'SOURCE LISTING', LINE.TEXT) ALTRET (NOT_PRT_LS);
        CALL CHNGMODE (%LS);
        RETURN;
 
NOT_PRT_LS: ;
        CALL INDEX (NULL, 'CROSS REFERENCE', LINE.TEXT) ALTRET (NOT_PRT_CR);
        CALL CHNGMODE (%CR);
        RETURN;
 
NOT_PRT_CR: ;
        CALL INDEX (NULL, 'SYMBOL MAP', LINE.TEXT) ALTRET (NOT_PRT_DM);
        CALL CHNGMODE (%DM);
        RETURN;
 
NOT_PRT_DM: ;
 
NOT_PARTRGE_KEYWORD: ;
 
        CALL INDEX (NULL, ' ERRORS ', LINE.TEXT) ALTRET (NOT_ERROR_PHRASE);
        FORCE_OUT = %YES#;
 
        CALL INDEX (NULL, 'NO ERRORS', LINE.TEXT) ALTRET (PART_ERRS);
        GOTO PART_ERR_RET;
 
PART_ERRS: ;
        BOLDFACE = %YES#;
 
PART_ERR_RET: ;
        RETURN;
 
NOT_ERROR_PHRASE: ;
 
        RETURN;
 
NEW_PARTRGE_FILE:
 
        CALL INDEX (NULL, 'Source listing', LINE.TEXT) ALTRET (NOT_NEW_PRT_LS);
        CALL CHNGMODE (%LS);
        RETURN;
 
NOT_NEW_PRT_LS: ;
        CALL INDEX (NULL, 'Cross Reference', LINE.TEXT) ALTRET (NOT_NEW_PRT_CR);
        CALL CHNGMODE (%CR);
        RETURN;
 
NOT_NEW_PRT_CR: ;
        CALL INDEX (NULL, 'Symbol Map', LINE.TEXT) ALTRET (NOT_NEW_PRT_DM);
        CALL CHNGMODE (%DM);
        RETURN;
 
NOT_NEW_PRT_DM: ;
 
NOT_NEW_PARTRGE_KEYWORD: ;
 
        CALL INDEX (NULL, ' error', LINE.TEXT) ALTRET (NOT_NEW_ERROR_PHRASE);
        FORCE_OUT = %YES#;
 
        CALL INDEX (NULL, 'No errors', LINE.TEXT) ALTRET (NEW_PART_ERRS);
        GOTO NEW_PART_ERR_RET;
 
NEW_PART_ERRS: ;
        BOLDFACE = %YES#;
 
NEW_PART_ERR_RET: ;
        RETURN;
 
NOT_NEW_ERROR_PHRASE: ;
 
        RETURN;
 
PL1_FILE:
 
        CALL INDEX (NULL, 'SYMBOL CROSS REFERENCE REPORT', LINE.T.XT)
          ALTRET (NOT_PL1_XREF);
 
        CALL CHNGMODE (%CR);
        RETURN;
 
NOT_PL1_XREF:
 
        CALL INDEX (NULL, 'SYMBOLIC LISTING OF GENERATED OBJECT CODE', LINE.TEXT)
          ALTRET (NOT_PL1_OBJECT);
 
        CALL CHNGMODE (%LO);
        RETURN;
 
NOT_PL1_OBJECT:
 
        CALL INDEX (NULL, ' ON LINE ', LINE.T.XT) ALTRET (NOT_PL1_WARNING);
 
        CALL INDEX (NULL, 'WARNING ', LINE.T.XT) ALTRET (NOT_PL1_DIAG2);
 
        GOTO PL1_DIAG_LINE;
 
NOT_PL1_DIAG2:
 
        CALL INDEX (NULL, 'ERROR ', LINE.T.XT) ALTRET (NOT_PL1_WARNING);
 
        GOTO PL1_DIAG_LINE;
 
NOT_PL1_WARNING:
 
        CALL INDEX (NULL, 'AN ERROR OF SEVERITY', LINE.T.XT) ALTRET (NOT_PL1_DIAG1);
 
        GOTO PL1_DIAG_LINE;
 
NOT_PL1_DIAG1:
 
        CALL INDEX (NULL, 'CODE GENERATION IS SUSPENDED', LINE.T.XT) ALTRET (NOT_PL1_DIAG);
 
        GOTO PL1_DIAG_LINE;
 
PL1_DIAG_LINE:
 
        BOLDFACE = %YES#;
        FORCE_OUT = %YES#;
 
        RETURN;
 
NOT_PL1_DIAG: ;
 
        RETURN;
 
BMAP_FILE:
 
        CALL INDEX (NULL, ' SYMBOL TABLE ', LINE.T.XT) ALTRET (NOT_BMAP_SYM);
        IF PFLAG(%CR) THEN
           CALL CHNGMODE (%CR);
        ELSE
           CALL CHNGMODE (%DM);
        RETURN;
 
NOT_BMAP_SYM: ;
        CALL INDEX (NULL, ' 1 ERROR ', LINE.T.XT) ALTRET (NOT_ONE_ERROR);
        GOTO BMAP_TROUBLE_LINE;
 
NOT_ONE_ERROR: ;
        CALL INDEX (NULL, '**** ERROR @', LINE.T.XT) ALTRET (NOT_BMAP_DIAG);
        BOLDFACE = %YES#;
        RETURN;
 
NOT_BMAP_DIAG: ;
        CALL INDEX (NULL, ' ERRORS   ', LINE.T.XT) ALTRET (NOT_BMAP_ERROR);
 
        CALL INDEX (NULL, ' NO ERRORS ', LINE.T.XT)
          ALTRET (BMAP_TROUBLE_LINE);
        GOTO BMAP_ERROR_LINE;
 
BMAP_TROUBLE_LINE: ;
        BOLDFACE = %YES#;
 
BMAP_ERROR_LINE: ;
        FORCE_OUT = %YES#;
 
        RETURN;
 
NOT_BMAP_ERROR: ;
 
        RETURN;
 
GMAP6_FILE:
 
        CALL INDEX (NULL, 'EXECUTION DELETED', LINE.TEXT) ALTRET (NOT_GMAP6_EX);
 
        BOLDFACE = %YES#;
        FORCE_OUT = %YES#;
        RETURN;
 
NOT_GMAP6_EX:
 
        CALL INDEX (NULL, 'WARNING FLAGS IN ', LINE.TEXT) ALTRET (GMAP6_END);
 
        BOLDFACE = %YES#;
        FORCE_OUT = %YES#;
 
        CALL INDEX (NULL, ' NO ', LINE.TEXT) ALTRET (GMAP6_END);
 
        BOLDFACE = %NO#;
 
GMAP6_END:
 
        RETURN;
 
END TEST_REC;
 
PRINT_REC: PROC;
 
        IF LINE.VFC>='p' AND LINE.VFC<='z' THEN DO; /* Header                 */
           IF NOT PFLAG(%OFFSETS) THEN SAVLINE = OLDLINE;
           J = 0;
           IF PAGENO>0 AND VLP_HDR.CTL.COUNT#>0 THEN DO;
              PAGENO = PAGENO+1;
              I = VLP_HDR.CTL.COUNT#-1;
              DO WHILE SUBSTR(LINE.TEXT,I,1)>='0' AND SUBSTR(LINE.TEXT,I,1)<':';
                 J = J*10+ASCBIN(SUBSTR(LINE.TEXT,I,1))-ASCBIN('0');
                 I = I+1;
                 END;
              IF J=PAGENO THEN EXIT;
              VLP_HDR.CTL.COUNT# = 0;
              PUTHDR = %YES#;
              END;
           IF VLP_HDR.CTL.COUNT#>0 AND VLP_HDR.CTL.COUNT#<VLP_HDR.TITL.L#
           THEN I = VLP_HDR.CTL.COUNT#-1;
           ELSE I = VLP_HDR.TITL.L#;
           IF NOT PUTHDR THEN DO;
              IF VLP_HDR.CTL.HEADERHEIGHT#~=ASCBIN(LINE.VFC)-112 THEN EXIT;
              IF SUBSTR(LINE.TEXT,0,I)~=SUBSTR(VLP_HDR.TITL.TITLE#,0,I) THEN EXIT;
              IF VLP_HDR.CTL.COUNT#~=0 AND I<LENGTHC(LINE.TEXT)-5
                AND SUBSTR(LINE.TEXT,I+5)=SUBSTR(VLP_HDR.TITL.TITLE#,I+5)
              THEN RETURN;         /* All the same except page#, ignore it    */
              END;
           PUTHDR = %YES#;
           VLP_HDR.CTL.HEADERHEIGHT# = ASCBIN(LINE.VFC)-112;
           VLP_HDR.TITL.TITLE# = LINE.TEXT;
           IF PAGENO=0 THEN DO;
              VLP_HDR.CTL.COUNT# = 0;
              I = 0;
              DO WHILE I<LENGTHC(LINE.TEXT);
                 CALL INDEX (I, '1   ', LINE.TEXT,I);
                 CALL INDEX (K, SUBSTR(LINE.TEXT,I-1,1), PAGE_CHARS);
                 IF K<LENGTHC(PAGE_CHARS) THEN EXIT;
                 I = I+4;
                 END;
              IF I>=LENGTHC(LINE.TEXT)
              THEN IF SUBSTR (LINE.TEXT, LINE.ARS-6, 6)~='_1____' THEN EXIT;
                 ELSE I = LINE.ARS-5;   /* XREF.X makes underscored headers   */
              PAGENO = PAGENO+1;
              VLP_HDR.CTL.COUNT# = I+1;
              VLP_HDR.CTL.RESETPAGE# = %YES#;
              IF SUBSTR(LINE.TEXT,I) = '1' THEN LINE.ARS = I+1;
              END;
           ELSE IF VLP_HDR.CTL.COUNT#~=0 THEN DO;
                 IF I<LENGTHC(VLP_HDR.TITL.TITLE#)-5
                 THEN SUBSTR(VLP_HDR.TITL.TITLE#,I,5) = ' ';
                 IF I=VLP_HDR.TITL.L# THEN LINE.ARS = I+1;
                 END;
           VLP_HDR.TITL.L# = LINE.ARS-1;
           RETURN;
           END;
 
        IF LINE.VFC='0' OR LINE.VFC='P' OR LINE.VFC=BITASC('032'O)
          OR LINE.VFC='`' AND OLDLINE.VFC>='p' THEN DO;
           IF LINE.VFC='`' THEN LINE.VFC = '0';
           IF LINE.TEXT~=' ' THEN EXIT;
           FORCE_EJECT=%YES#;
           RETURN;
           END;
 
        WRITE_LO.BUF_.BOUND=LINE.ARS;
 
        IF BOLDFACE THEN
           IF M$LO$->F$DCB.ASN#=%DEVICE# AND M$LO$->F$DCB.WIDTH#<
             LINE.ARS THEN
              BOLDFACE='0'B;
 
        IF FORCE_OUT THEN DO;
           PUTHDR='0'B;
           IF LINE.VFC>'b' AND LINE.VFC<='o' THEN
              LINE.VFC = 'b';
           GOTO PRNT;
           END;
 
        IF PFLAG(MODE) THEN DO;
           IF PUTHDR THEN DO;
              CALL M$DEVICE (SET_HDR);
              PUTHDR='0'B;
              VLP_HDR.CTL.RESETPAGE# = %NO#;
              IF M$LO$ -> F$DCB.LINES#=0 THEN EXIT;
              FORCE_EJECT=%NO#;
              CHK_VFC=%NO#;
              END;
           IF FORCE_EJECT THEN DO;
              FORCE_EJECT=%NO#;
              CALL EJECT;
              END;
PRNT:      IF CHK_VFC THEN DO;
              IF LINE.VFC>='A' AND LINE.VFC<='Z' AND
                ((PREVVFC>='`' AND PREVVFC<='o') OR PREVVFCO='036'O) THEN
                 CALL M$WRITE(WRITE_BLANK);
              ELSE
                 CHK_VFC=%NO#;
              END;
           IF BOLDFACE THEN DO;
              DO I=0 TO 3;
                 DO CASE(I);
                  CASE(0);
                    IF LINE.VFC>='A' AND LINE.VFC<='Z' THEN DO;
                       SAVVFC=LINE.VFC;
                       LINE.VFC='`';
                       END;
                    ELSE
                       SAVVFC='`';
                  CASE(1,2);
                    LINE.VFC='`';
                  CASE(3);
                    LINE.VFC=SAVVFC;
                  END;
                 CALL M$WRITE(WRITE_LO);
                 END;
              END;
           ELSE
              CALL M$WRITE(WRITE_LO);
           PREVVFC=LINE.VFC;
 
           IF FORCE_OUT THEN DO;
              FORCE_OUT=%NO#;
              CHK_VFC=%YES#;
              END;
           END;
 
        RETURN;
 
END PRINT_REC;
 
EJECT:  PROC;
 
        IF M$LO$ -> F$DCB.LINES#>0
        THEN
           CALL M$DEVICE (EJECT_PAGE);
        ELSE
           CALL M$WRITE (SKIP_TWO_LINES);
 
        RETURN;
 
END EJECT;
 
CHNGMODE: PROC(NEWMODE);
 
DCL NEWMODE UBIN;
 
        IF NEWMODE=%LS AND NEWMODE~=MODE THEN FINDLU = %YES#;
        IF PFLAG(NEWMODE) THEN
           IF NOT PFLAG(MODE) THEN
              CHK_VFC=%YES#;
 
        IF PROCNOT>0 THEN CALL M$PRECORD (PREC_SI);
        PROCNOT = -1;
        MODE = NEWMODE;
 
        RETURN;
 
END CHNGMODE;
 
 
END LISTER;
