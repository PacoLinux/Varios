VERSION A05

PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:1    
        1        1        /*M* VDE$RECORDS - Eval'r routines to handle records within blocks */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7
        8        8        /*X* MCR=NO, DMC=YES */
        9        9        /*T*/
       10       10
       11       11        /*P* NAME: VDE$RECORDS
       12       12            PURPOSE: Routines to handle records which lie within a block.
       13       13            DESCRIPTION:
       14       14                This module contains several external routines:
       15       15
       16       16                VDE$RREAD
       17       17                This is a correlate to VDA$LREAD, but limits reading to
       18       18                within a range.
       19       19                Given a stream, an enclosing range, an absolute location
       20       20                and a relative node count, will read the requested node
       21       21                from the stream.  Guarantees the returned node is within or
       22       22                after the enclosing range:  if the requested node is in front
       23       23                of the range, will instead return the first node in the range.
       24       24                If the requested node is after the range, will go ahead
       25       25                and return the bogus node; VDE$RGET will filter out such
       26       26                trash.
       27       27                After calling VDE$RREAD, you're all set for a call to VDE$RGET.
       28       28
       29       29                VDE$RGET
       30       30                Given stream and a range, will return that portion of the
       31       31                stream's record which is within the given range.  If the stream
       32       32                is at the end of the range, will return an empty
       33       33                node descriptor.
       34       34                Usually used to limit reading to the SourceBlock or the
       35       35                EditBlock.
       36       36
       37       37                VDE$RADJUST_LENGTH
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:2    
       38       38                Truncates or extends a record to a given length.  If truncating,
       39       39                the record loses its EOR-boundary (EOR-flag is set %FALSE).
       40       40                If extending, the record is filled with the $PAD character(s);
       41       41                if the extened length won't fit within the VD$BUFFER
       42       42                holding the record, we'll copy the record to a new VD$BUFFER
       43       43                which is large enough for the extended length.
       44       44
       45       45                VDE$RPUT
       46       46                Given a stream, an enclosing range, a record, and a starting
       47       47                record key, will write the record, guaranteeing that it ends
       48       48                up within the specified range.
       49       49                Used for writing records and making sure they're within the
       50       50                EditBlock.
       51       51        */
       52       52
       53       53        /*D* NAME: VDE$RREAD
       54       54            PARAMETERS:
       55       55                STREAM - VD$STREAM to read through.
       56       56                RANGE - VD$RANGE specifying the boundaries which we want
       57       57                    to remain within.
       58       58                ABSOLUTE - VD$LOCATION specifying the location to read.
       59       59                RELATIVE - SBIN WORD specifying the number of nodes to
       60       60                    move forward (RELATIVE > 0) or backward (RELATIVE < 0)
       61       61                    from ABSOLUTE.
       62       62            INPUT:
       63       63            OUTPUT:
       64       64                STREAM will be positioned to a node within RANGE, or to
       65       65                    EOF if we've fallen off the end of RANGE.
       66       66            DESCRIPTION:
       67       67                Call VDA$LREAD with ABSOLUTE and RELATIVE.
       68       68                Check STREAM's position (as returned by VDA$LREAD) to see
       69       69                    if it's before RANGE.  If it is, call VDA$LREAD again
       70       70                    to read the first node in RANGE.
       71       71        */
       72       72
       73       73        VDE$RREAD: PROC (STREAM, RANGE, ABSOLUTE, RELATIVE) ALTRET;
       74       74
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:3    
       75       75        %INCLUDE VD_MACROS_M;
       76     2290
       77     2291
       78     2292        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
       79     2398        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
       80     2467        %VD$LOCATION (NAME=ABSOLUTE, STCLASS=PARAM);
       81     2495    1   DCL RELATIVE SBIN;
       82     2496
       83     2497
       84     2498    1   DCL VDA$LREAD           ENTRY (4) ALTRET;
       85     2499    1   DCL VDG$COMPARE_LOCS    ENTRY (3) ALTRET;
       86     2500    1   DCL VDG$MEVAL_RREAD     ENTRY (4);
       87     2501    1   DCL VDG$MEVAL_RREAD_RETURN ENTRY (1);
       88     2502
       89     2503
       90     2504        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
       91     2549
       92     2550
       93     2551
       94     2552    1   DCL RCCL SBIN;
       95     2553
       96     2554
       97     2555
       98     2556    1           IF VD_$$MON_EVAL.V# > 0 THEN
       99     2557    1              CALL VDG$MEVAL_RREAD (STREAM, RANGE, ABSOLUTE, RELATIVE);
      100     2558
      101     2559    1           CALL VDA$LREAD (STREAM, ABSOLUTE, RELATIVE, %TRUE)
      102     2560    1             ALTRET (LREAD_FAILED);
      103     2561
      104     2562    1           CALL VDG$COMPARE_LOCS (STREAM.CURRENT, RANGE.START, RCCL)
      105     2563    1             ALTRET (COMPARE_LOCS_FAILED);
      106     2564    2           IF RCCL < %RCCL_EQUAL THEN DO;
      107     2565    2              CALL VDA$LREAD (STREAM, RANGE.START, 0, %TRUE)
      108     2566    2                ALTRET (LREAD_FAILED);
      109     2567    2              END;
      110     2568
      111     2569    1           IF VD_$$MON_EVAL.V# > 0 THEN
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:4    
      112     2570    1              CALL VDG$MEVAL_RREAD_RETURN (STREAM);
      113     2571
      114     2572    1           RETURN;
      115     2573
      116     2574
      117     2575
      118     2576    1   LREAD_FAILED: ;
      119     2577    1   COMPARE_LOCS_FAILED: ;
      120     2578    1           ALTRETURN;
      121     2579
      122     2580    1   END VDE$RREAD;
      123     2581        %EOD;

PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:5    
--  Include file information  --

   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RREAD.

   Procedure VDE$RREAD requires 48 words for executable code.
   Procedure VDE$RREAD requires 12 words of local(AUTO) storage.

PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:6    

 Object Unit name= VDE$RREAD                                  File name= VDE$RECORDS.:VDA5TOU
 UTS= JUL 04 '97 11:16:40.32 FRI                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    48     60  VDE$RREAD
    1  RoData even  none     4      4  VDE$RREAD

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        4  VDE$RREAD

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       4 VDG$MEVAL_RREAD
 yes     yes           Std       4 VDA$LREAD
         yes           Std       1 VDG$MEVAL_RREAD_RETURN
 yes     yes           Std       3 VDG$COMPARE_LOCS
                       nStd      0 X66_AUTO_4
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:7    

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     VD_$$MON_EVAL                         B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:8    


        1        1        /*M* VDE$RECORDS - Eval'r routines to handle records within blocks */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7
        8        8        /*X* MCR=NO, DMC=YES */
        9        9        /*T*/
       10       10
       11       11        /*P* NAME: VDE$RECORDS
       12       12            PURPOSE: Routines to handle records which lie within a block.
       13       13            DESCRIPTION:
       14       14                This module contains several external routines:
       15       15
       16       16                VDE$RREAD
       17       17                This is a correlate to VDA$LREAD, but limits reading to
       18       18                within a range.
       19       19                Given a stream, an enclosing range, an absolute location
       20       20                and a relative node count, will read the requested node
       21       21                from the stream.  Guarantees the returned node is within or
       22       22                after the enclosing range:  if the requested node is in front
       23       23                of the range, will instead return the first node in the range.
       24       24                If the requested node is after the range, will go ahead
       25       25                and return the bogus node; VDE$RGET will filter out such
       26       26                trash.
       27       27                After calling VDE$RREAD, you're all set for a call to VDE$RGET.
       28       28
       29       29                VDE$RGET
       30       30                Given stream and a range, will return that portion of the
       31       31                stream's record which is within the given range.  If the stream
       32       32                is at the end of the range, will return an empty
       33       33                node descriptor.
       34       34                Usually used to limit reading to the SourceBlock or the
       35       35                EditBlock.
       36       36
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:9    
       37       37                VDE$RADJUST_LENGTH
       38       38                Truncates or extends a record to a given length.  If truncating,
       39       39                the record loses its EOR-boundary (EOR-flag is set %FALSE).
       40       40                If extending, the record is filled with the $PAD character(s);
       41       41                if the extened length won't fit within the VD$BUFFER
       42       42                holding the record, we'll copy the record to a new VD$BUFFER
       43       43                which is large enough for the extended length.
       44       44
       45       45                VDE$RPUT
       46       46                Given a stream, an enclosing range, a record, and a starting
       47       47                record key, will write the record, guaranteeing that it ends
       48       48                up within the specified range.
       49       49                Used for writing records and making sure they're within the
       50       50                EditBlock.
       51       51        */
       52       52
       53       53        /*D* NAME: VDE$RREAD
       54       54            PARAMETERS:
       55       55                STREAM - VD$STREAM to read through.
       56       56                RANGE - VD$RANGE specifying the boundaries which we want
       57       57                    to remain within.
       58       58                ABSOLUTE - VD$LOCATION specifying the location to read.
       59       59                RELATIVE - SBIN WORD specifying the number of nodes to
       60       60                    move forward (RELATIVE > 0) or backward (RELATIVE < 0)
       61       61                    from ABSOLUTE.
       62       62            INPUT:
       63       63            OUTPUT:
       64       64                STREAM will be positioned to a node within RANGE, or to
       65       65                    EOF if we've fallen off the end of RANGE.
       66       66            DESCRIPTION:
       67       67                Call VDA$LREAD with ABSOLUTE and RELATIVE.
       68       68                Check STREAM's position (as returned by VDA$LREAD) to see
       69       69                    if it's before RANGE.  If it is, call VDA$LREAD again
       70       70                    to read the first node in RANGE.
       71       71        */
       72       72
       73       73        VDE$RREAD: PROC (STREAM, RANGE, ABSOLUTE, RELATIVE) ALTRET;
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:10   

     73  0 000000   000000 700200 xent  VDE$RREAD    TSX0  ! X66_AUTO_4
         0 000001   000014 000004                    ZERO    12,4

       74       74
       75       75        %INCLUDE VD_MACROS_M;
       76     2290
       77     2291
       78     2292        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
       79     2398        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
       80     2467        %VD$LOCATION (NAME=ABSOLUTE, STCLASS=PARAM);
       81     2495    1   DCL RELATIVE SBIN;
       82     2496
       83     2497
       84     2498    1   DCL VDA$LREAD           ENTRY (4) ALTRET;
       85     2499    1   DCL VDG$COMPARE_LOCS    ENTRY (3) ALTRET;
       86     2500    1   DCL VDG$MEVAL_RREAD     ENTRY (4);
       87     2501    1   DCL VDG$MEVAL_RREAD_RETURN ENTRY (1);
       88     2502
       89     2503
       90     2504        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
       91     2549
       92     2550
       93     2551
       94     2552    1   DCL RCCL SBIN;
       95     2553
       96     2554
       97     2555
       98     2556    1           IF VD_$$MON_EVAL.V# > 0 THEN

   2556  0 000002   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         0 000003   000010 604400 0                  TMOZ    s:2559

       99     2557    1              CALL VDG$MEVAL_RREAD (STREAM, RANGE, ABSOLUTE, RELATIVE);

   2557  0 000004   200003 630500                    EPPR0   @STREAM,,AUTO
         0 000005   000022 631400 xsym               EPPR1   B_VECTNIL+18
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:11   
         0 000006   000000 701000 xent               TSX1    VDG$MEVAL_RREAD
         0 000007   000000 011000                    NOP     0

      100     2558
      101     2559    1           CALL VDA$LREAD (STREAM, ABSOLUTE, RELATIVE, %TRUE)

   2559  0 000010   000000 236000 1                  LDQ     0
         0 000011   200006 235100                    LDA     @RELATIVE,,AUTO
         0 000012   200012 757100                    STAQ    RCCL+3,,AUTO
         0 000013   200005 236100                    LDQ     @ABSOLUTE,,AUTO
         0 000014   200003 235100                    LDA     @STREAM,,AUTO
         0 000015   200010 757100                    STAQ    RCCL+1,,AUTO
         0 000016   200010 630500                    EPPR0   RCCL+1,,AUTO
         0 000017   000022 631400 xsym               EPPR1   B_VECTNIL+18
         0 000020   000000 701000 xent               TSX1    VDA$LREAD
         0 000021   000057 702000 0                  TSX2    LREAD_FAILED

      102     2560    1             ALTRET (LREAD_FAILED);
      103     2561
      104     2562    1           CALL VDG$COMPARE_LOCS (STREAM.CURRENT, RANGE.START, RCCL)

   2562  0 000022   200007 630500                    EPPR0   RCCL,,AUTO
         0 000023   200012 450500                    STP0    RCCL+3,,AUTO
         0 000024   200004 236100                    LDQ     @RANGE,,AUTO
         0 000025   200011 756100                    STQ     RCCL+2,,AUTO
         0 000026   200003 236100                    LDQ     @STREAM,,AUTO
         0 000027   000006 036003                    ADLQ    6,DU
         0 000030   200010 756100                    STQ     RCCL+1,,AUTO
         0 000031   200010 630500                    EPPR0   RCCL+1,,AUTO
         0 000032   000021 631400 xsym               EPPR1   B_VECTNIL+17
         0 000033   000000 701000 xent               TSX1    VDG$COMPARE_LOCS
         0 000034   000057 702000 0                  TSX2    LREAD_FAILED

      105     2563    1             ALTRET (COMPARE_LOCS_FAILED);
      106     2564    2           IF RCCL < %RCCL_EQUAL THEN DO;

   2564  0 000035   200007 235100                    LDA     RCCL,,AUTO
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:12   
         0 000036   000050 605000 0                  TPL     s:2569

      107     2565    2              CALL VDA$LREAD (STREAM, RANGE.START, 0, %TRUE)

   2565  0 000037   000002 237000 1                  LDAQ    2
         0 000040   200012 757100                    STAQ    RCCL+3,,AUTO
         0 000041   200004 236100                    LDQ     @RANGE,,AUTO
         0 000042   200003 235100                    LDA     @STREAM,,AUTO
         0 000043   200010 757100                    STAQ    RCCL+1,,AUTO
         0 000044   200010 630500                    EPPR0   RCCL+1,,AUTO
         0 000045   000022 631400 xsym               EPPR1   B_VECTNIL+18
         0 000046   000000 701000 xent               TSX1    VDA$LREAD
         0 000047   000057 702000 0                  TSX2    LREAD_FAILED

      108     2566    2                ALTRET (LREAD_FAILED);
      109     2567    2              END;

      110     2568
      111     2569    1           IF VD_$$MON_EVAL.V# > 0 THEN

   2569  0 000050   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         0 000051   000056 604400 0                  TMOZ    s:2572

      112     2570    1              CALL VDG$MEVAL_RREAD_RETURN (STREAM);

   2570  0 000052   200003 630500                    EPPR0   @STREAM,,AUTO
         0 000053   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000054   000000 701000 xent               TSX1    VDG$MEVAL_RREAD_RETURN
         0 000055   000000 011000                    NOP     0

      113     2571
      114     2572    1           RETURN;

   2572  0 000056   000000 702200 xent               TSX2  ! X66_ARET

   2569  0 000057                       LREAD_FAILED null
   2569  0 000057                       COMPARE_LOC* null
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:13   
      115     2573
      116     2574
      117     2575
      118     2576    1   LREAD_FAILED: ;
      119     2577    1   COMPARE_LOCS_FAILED: ;
      120     2578    1           ALTRETURN;

   2578  0 000057   000000 702200 xent               TSX2  ! X66_AALT
      121     2579
      122     2580    1   END VDE$RREAD;
      123     2581        %EOD;

PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:14   
--  Include file information  --

   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RREAD.
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:15   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     5-0-0/w PTR         r     1 @ABSOLUTE                  4-0-0/w PTR         r     1 @RANGE
     6-0-0/w PTR         r     1 @RELATIVE                  3-0-0/w PTR         r     1 @STREAM
    *0-0-0/w STRC(324)   r     1 ABSOLUTE                  *0-0-0/w STRC(648)   r     1 RANGE
     7-0-0/w SBIN        r     1 RCCL                      *0-0-0/w SBIN        r     1 RELATIVE
    *0-0-0/w STRC(864)   r     1 STREAM

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 VD_$$MON_EVAL


   Procedure VDE$RREAD requires 48 words for executable code.
   Procedure VDE$RREAD requires 12 words of local(AUTO) storage.
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:16   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=VDE$RREAD File=VDE$RECORDS.:VDA5TSI                           FRI 07/04/97 11:16 Page:17   
          MINI XREF LISTING

ABSOLUTE
      2475**DCL        73--PROC     2557<>CALL     2559<>CALL
COMPARE_LOCS_FAILED
      2569**LABEL    2562--CALLALT
LREAD_FAILED
      2569**LABEL    2559--CALLALT  2565--CALLALT
RANGE
      2406**DCL        73--PROC     2557<>CALL
RANGE.START
      2420**DCL      2562<>CALL     2565<>CALL
RCCL
      2552**DCL      2562<>CALL     2564>>IF
RELATIVE
      2495**DCL        73--PROC     2557<>CALL     2559<>CALL
STREAM
      2300**DCL        73--PROC     2557<>CALL     2559<>CALL     2565<>CALL     2570<>CALL
STREAM.CURRENT
      2351**DCL      2562<>CALL
VDA$LREAD
      2498**DCL-ENT  2559--CALL     2565--CALL
VDG$COMPARE_LOCS
      2499**DCL-ENT  2562--CALL
VDG$MEVAL_RREAD
      2500**DCL-ENT  2557--CALL
VDG$MEVAL_RREAD_RETURN
      2501**DCL-ENT  2570--CALL
VD_$$MON_EVAL.V#
      2546**DCL      2556>>IF       2569>>IF

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:18   
      124        1        /*T***********************************************************/
      125        2        /*T*                                                         */
      126        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      127        4        /*T*                                                         */
      128        5        /*T***********************************************************/
      129        6
      130        7        /*D* NAME: VDE$RGET
      131        8            PARAMETERS:
      132        9                STREAM - VD$STREAM thru which we have just VDA$LREAD the record
      133       10                    to get.  OK if STREAM is currently at EOF.
      134       11                RANGE - VD$RANGE specifying the boundaries which we want to
      135       12                    remain within.
      136       13                NODE_DESC - An uninitialized VD$NODE_DESC.
      137       14        *N*     Someday should handle levels other than %LVL_EXT_REC.
      138       15        *N*     Someday should handle components other than %CO_DATA.
      139       16            INPUT:
      140       17                None.
      141       18            OUTPUT:
      142       19                NODE_DESC will be modified:
      143       20                If any part of STREAM's record is within RANGE:
      144       21                    NODE_DESC will specify the Key, Spec, and Data components
      145       22                    of the record.  The Data component will be truncated
      146       23                    on one or both ends (left and/or right) if not all of
      147       24                    the record lies within RANGE.  If the right end is
      148       25                    truncated, NODE_DESC.EOR will be FALSE; else it will be
      149       26                    TRUE.
      150       27                If no part of STREAM's record is within RANGE,
      151       28                or if STREAM is currently positioned at EOF:
      152       29                    NODE_DESC will be %CLEAR/NIL.  Specifically,
      153       30                    NODE_DESC.KEY is guaranteed to be %CLEAR.
      154       31            DESCRIPTION:
      155       32                Check the record in STREAM's PORT against RANGE:
      156       33                If any part is within range, make a new copy of the record
      157       34                    and attach it to NODE_DESC.
      158       35                If only part of the record is within the range, chop off
      159       36                    either or both the left and right parts of the record
      160       37                    in NODE_DESC's VD$BUFFER, so that what is returned is just
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:19   
      161       38                    the data which does lie within RANGE.
      162       39        */
      163       40
      164       41        VDE$RGET: PROC (STREAM, RANGE, NODE_DESC) ALTRET;
      165       42
      166       43        %INCLUDE VD_MACROS_M;
      167     2258        %INCLUDE VD_PERR_C;
      168     2406
      169     2407
      170     2408        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
      171     2514        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
      172     2583        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
      173     2625
      174     2626
      175     2627    1   DCL VDE$RADJUST_LENGTH  ENTRY (2) ALTRET;
      176     2628    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      177     2629    1   DCL VDG$OCOPY           ENTRY (2) ALTRET;
      178     2630    1   DCL VDG$OFREE           ENTRY (1) ALTRET;
      179     2631    1   DCL VDG$ESCREECH        ENTRY (3);
      180     2632    1   DCL VDG$MEVAL_RGET      ENTRY (2);
      181     2633    1   DCL VDG$MEVAL_RGET_RETURN ENTRY (2);
      182     2634
      183     2635
      184     2636    1   DCL VD_STATIC_TEMP CHAR(%NB_STATIC_TEMP) ALIGNED SYMREF;
      185     2637        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
      186     2682
      187     2683
      188     2684
      189     2685    1   DCL PORT_KEY$ PTR;
      190     2686    1   DCL START_KEY$ PTR;
      191     2687    1   DCL END_KEY$ PTR;
      192     2688    1   DCL NEW_LENGTH SBIN;
      193     2689    1   DCL NEW_START SBIN;
      194     2690
      195     2691
      196     2692        %VD$PORT (NAME=PORT, STCLASS="BASED(STREAM.PORT$)");
      197     2790        %VD$TEXTC (NAME=PORT$KEY, STCLASS="BASED(PORT_KEY$)");
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:20   
      198     2813        %VD$TEXTC (NAME=START$KEY, STCLASS="BASED(START_KEY$)");
      199     2836        %VD$TEXTC (NAME=END$KEY, STCLASS="BASED(END_KEY$)");
      200     2859        %VD$BUFFER (NAME=NODE$RECORD, STCLASS="BASED(NODE_DESC.DATA$)");
      201     2917        %VD$BUFFER;
      202     2975        %VD$BUFFER_HEADER;
      203     3011        %VD$TEXTC_REMOTE;
      204     3072        %VD$FILE_NODE;
      205     3165
      206     3166
      207     3167
      208     3168    1           IF VD_$$MON_EVAL.V# > 0 THEN
      209     3169    1              CALL VDG$MEVAL_RGET (STREAM, RANGE);
      210     3170
      211     3171    1           NODE_DESC = %CLEAR;
      212     3172    1           NODE_DESC.DATA$ = ADDR(NIL);
      213     3173
      214     3174    1           IF STREAM.CURRENT.EOF OR RANGE.START.EOF THEN
      215     3175    1              RETURN;      /* Record outside RANGE */
      216     3176
      217     3177    1           NEW_START = -1;
      218     3178    1           NEW_LENGTH = -1;
      219     3179                %GETKEY (KEY=PORT.CURRENT.KEY, INDX="%(LVL_EXT_REC-1)",
      220     3180                PTR=PORT_KEY$);
      221     3190                %GETKEY (KEY=RANGE.START.KEY, INDX="%(LVL_EXT_REC-1)",
      222     3191                PTR=START_KEY$);
      223     3201
      224     3202    1           IF PORT$KEY.BYTES < START$KEY.BYTES THEN
      225     3203    1              RETURN;      /* Record outside RANGE */
      226     3204    1           IF PORT$KEY.BYTES = START$KEY.BYTES THEN
      227     3205    1              NEW_START = RANGE.START.POSITION#;
      228     3206
      229     3207                /*
      230     3208                *   From now on, we can be sure that PORT$KEY >= START$KEY.
      231     3209                */
      232     3210
      233     3211    2           IF NOT RANGE.ENDD.EOF THEN DO;
      234     3212
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:21   
      235     3213                   %GETKEY (KEY=RANGE.ENDD.KEY, INDX="%(LVL_EXT_REC-1)",
      236     3214                   PTR=END_KEY$);
      237     3224
      238     3225    2              IF PORT$KEY.BYTES > END$KEY.BYTES THEN
      239     3226    2                 RETURN;   /* Record outside RANGE */
      240     3227
      241     3228                /*
      242     3229                *   From now on, we can be sure that:
      243     3230                *       PORT$KEY >= START$KEY
      244     3231                *   and PORT$KEY <= END$KEY
      245     3232                */
      246     3233
      247     3234    3              IF PORT$KEY.BYTES = END$KEY.BYTES THEN DO;
      248     3235    3                 NEW_LENGTH = RANGE.ENDD.POSITION#;
      249     3236    3                 IF NEW_LENGTH = 0 OR NEW_LENGTH = NEW_START THEN
      250     3237                   /* Range is empty, or ... */
      251     3238                   /* Range ends just before Port's record */
      252     3239    3                    RETURN; /* Record outside RANGE */
      253     3240    3                 END;
      254     3241    2              END;
      255     3242
      256     3243                /*
      257     3244                *   Now we know we're going to return some part of the record.
      258     3245                */
      259     3246
      260     3247                %COPYKEY (FKEY=PORT.CURRENT.KEY, FINDX="%(LVL_EXT_REC-1)",
      261     3248                TKEY=NODE_DESC.KEY);
      262     3264                %COPYSPEC (FSPEC=PORT.LEVEL.SPEC, FINDX=%LVL_EXT_REC,
      263     3265                TSPEC=NODE_DESC.SPEC);
      264     3281    2           IF PORT.LEVEL.DATA$ (%LVL_EXT_REC) = ADDR(NIL) THEN DO;
      265     3282    2              CALL VDG$OALLOC (%CLS_BUFFER, NODE_DESC.DATA$,
      266     3283    2                POFFW(PALIGNW(ADDR(NODE$RECORD.BYTES)), ADDR(NODE$RECORD)))
      267     3284    2                ALTRET (OALLOC_FAILED);
      268     3285    2              NODE_DESC.DATA$->VD$BUFFER.LENGTH# = 0;
      269     3286    2              END;
      270     3287    2           ELSE DO;
      271     3288    2              CALL VDG$OCOPY (PORT.LEVEL.DATA$ (%LVL_EXT_REC) -> VD$BUFFER,
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:22   
      272     3289    2                NODE_DESC.DATA$)
      273     3290    2                ALTRET (OCOPY_FAILED);
      274     3291    2              END;
      275     3292    1           IF PORT.DCB# = 0 THEN
      276     3293    1              NODE_DESC.EOR = PORT.LEVEL.INTERNAL$ (%LVL_EXT_REC) ->
      277     3294    1                VD$FILE_NODE.DESC.EOR;
      278     3295    1           ELSE
      279     3296    1              NODE_DESC.EOR = %TRUE;
      280     3297
      281     3298    2           IF NEW_LENGTH >= 0 THEN DO;
      282     3299    2              IF NEW_LENGTH ~=
      283     3300    3                NODE_DESC.DATA$->VD$BUFFER.LENGTH# THEN DO;
      284     3301    3                 CALL VDE$RADJUST_LENGTH (NODE_DESC, NEW_LENGTH)
      285     3302    3                   ALTRET (RADJUST_LENGTH_FAILED);
      286     3303    3                 END;
      287     3304                   /*
      288     3305                   *  Even if we extended the record, the fact that the
      289     3306                   *    RANGE.ENDD lies anywhere in the NODE_DESC record
      290     3307                   *    means that the returned record loses its
      291     3308                   *    EOR-boundary.
      292     3309                   */
      293     3310    2              NODE_DESC.EOR = %FALSE;
      294     3311    2              END;
      295     3312
      296     3313    2           IF NEW_START > 0 THEN DO;
      297     3314    2              IF NODE$RECORD.LENGTH# <= NEW_START THEN
      298     3315    2                 NODE$RECORD.LENGTH# = 0;
      299     3316    3              ELSE DO;
      300     3317    3                 NODE$RECORD.LENGTH# = NODE$RECORD.LENGTH# - NEW_START;
      301     3318    3                 SUBSTR (NODE$RECORD.BYTES, 0, NODE$RECORD.LENGTH#) =
      302     3319    3                   SUBSTR (NODE$RECORD.BYTES, NEW_START, NODE$RECORD.LENGTH#);
      303     3320    3                 END;
      304     3321
      305     3322    2              IF NODE_DESC.SPEC.TYPE# = %SPT_EXT_RECORD THEN
      306     3323                         /* Partial records not including byte 0 don't have VFC */
      307     3324    2                 NODE_DESC.SPEC = %CLEAR;
      308     3325    2              END;
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:23   
      309     3326
      310     3327    1           IF VD_$$MON_EVAL.V# > 0 THEN
      311     3328    1              CALL VDG$MEVAL_RGET_RETURN (STREAM, NODE_DESC);
      312     3329
      313     3330    1           RETURN;
      314     3331
      315     3332
      316     3333
      317     3334    1   OALLOC_FAILED: ;
      318     3335    1   OCOPY_FAILED: ;
      319     3336    1   RADJUST_LENGTH_FAILED: ;
      320     3337    1           ALTRETURN;
      321     3338
      322     3339    1   END VDE$RGET;
      323     3340        %EOD;

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:24   
--  Include file information  --

   VD_PERR_C.:VDA5TOU  is referenced.
   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RGET.

   Procedure VDE$RGET requires 250 words for executable code.
   Procedure VDE$RGET requires 20 words of local(AUTO) storage.

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:25   

 Object Unit name= VDE$RGET                                   File name= VDE$RECORDS.:VDA5TOU
 UTS= JUL 04 '97 11:16:45.92 FRI                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none   250    372  VDE$RGET
    1  RoData even  none     3      3  VDE$RGET

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        3  VDE$RGET

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 VDG$MEVAL_RGET
 yes     yes           Std       3 VDG$OALLOC
 yes     yes           Std       2 VDG$OCOPY
 yes     yes           Std       2 VDE$RADJUST_LENGTH
         yes           Std       2 VDG$MEVAL_RGET_RETURN
                       nStd      0 X66_AUTO_3
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:26   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     VD_$$MON_EVAL                         B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:27   


      124        1        /*T***********************************************************/
      125        2        /*T*                                                         */
      126        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      127        4        /*T*                                                         */
      128        5        /*T***********************************************************/
      129        6
      130        7        /*D* NAME: VDE$RGET
      131        8            PARAMETERS:
      132        9                STREAM - VD$STREAM thru which we have just VDA$LREAD the record
      133       10                    to get.  OK if STREAM is currently at EOF.
      134       11                RANGE - VD$RANGE specifying the boundaries which we want to
      135       12                    remain within.
      136       13                NODE_DESC - An uninitialized VD$NODE_DESC.
      137       14        *N*     Someday should handle levels other than %LVL_EXT_REC.
      138       15        *N*     Someday should handle components other than %CO_DATA.
      139       16            INPUT:
      140       17                None.
      141       18            OUTPUT:
      142       19                NODE_DESC will be modified:
      143       20                If any part of STREAM's record is within RANGE:
      144       21                    NODE_DESC will specify the Key, Spec, and Data components
      145       22                    of the record.  The Data component will be truncated
      146       23                    on one or both ends (left and/or right) if not all of
      147       24                    the record lies within RANGE.  If the right end is
      148       25                    truncated, NODE_DESC.EOR will be FALSE; else it will be
      149       26                    TRUE.
      150       27                If no part of STREAM's record is within RANGE,
      151       28                or if STREAM is currently positioned at EOF:
      152       29                    NODE_DESC will be %CLEAR/NIL.  Specifically,
      153       30                    NODE_DESC.KEY is guaranteed to be %CLEAR.
      154       31            DESCRIPTION:
      155       32                Check the record in STREAM's PORT against RANGE:
      156       33                If any part is within range, make a new copy of the record
      157       34                    and attach it to NODE_DESC.
      158       35                If only part of the record is within the range, chop off
      159       36                    either or both the left and right parts of the record
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:28   
      160       37                    in NODE_DESC's VD$BUFFER, so that what is returned is just
      161       38                    the data which does lie within RANGE.
      162       39        */
      163       40
      164       41        VDE$RGET: PROC (STREAM, RANGE, NODE_DESC) ALTRET;

     41  0 000000   000000 700200 xent  VDE$RGET     TSX0  ! X66_AUTO_3
         0 000001   000024 000003                    ZERO    20,3

      165       42
      166       43        %INCLUDE VD_MACROS_M;
      167     2258        %INCLUDE VD_PERR_C;
      168     2406
      169     2407
      170     2408        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
      171     2514        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
      172     2583        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
      173     2625
      174     2626
      175     2627    1   DCL VDE$RADJUST_LENGTH  ENTRY (2) ALTRET;
      176     2628    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      177     2629    1   DCL VDG$OCOPY           ENTRY (2) ALTRET;
      178     2630    1   DCL VDG$OFREE           ENTRY (1) ALTRET;
      179     2631    1   DCL VDG$ESCREECH        ENTRY (3);
      180     2632    1   DCL VDG$MEVAL_RGET      ENTRY (2);
      181     2633    1   DCL VDG$MEVAL_RGET_RETURN ENTRY (2);
      182     2634
      183     2635
      184     2636    1   DCL VD_STATIC_TEMP CHAR(%NB_STATIC_TEMP) ALIGNED SYMREF;
      185     2637        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
      186     2682
      187     2683
      188     2684
      189     2685    1   DCL PORT_KEY$ PTR;
      190     2686    1   DCL START_KEY$ PTR;
      191     2687    1   DCL END_KEY$ PTR;
      192     2688    1   DCL NEW_LENGTH SBIN;
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:29   
      193     2689    1   DCL NEW_START SBIN;
      194     2690
      195     2691
      196     2692        %VD$PORT (NAME=PORT, STCLASS="BASED(STREAM.PORT$)");
      197     2790        %VD$TEXTC (NAME=PORT$KEY, STCLASS="BASED(PORT_KEY$)");
      198     2813        %VD$TEXTC (NAME=START$KEY, STCLASS="BASED(START_KEY$)");
      199     2836        %VD$TEXTC (NAME=END$KEY, STCLASS="BASED(END_KEY$)");
      200     2859        %VD$BUFFER (NAME=NODE$RECORD, STCLASS="BASED(NODE_DESC.DATA$)");
      201     2917        %VD$BUFFER;
      202     2975        %VD$BUFFER_HEADER;
      203     3011        %VD$TEXTC_REMOTE;
      204     3072        %VD$FILE_NODE;
      205     3165
      206     3166
      207     3167
      208     3168    1           IF VD_$$MON_EVAL.V# > 0 THEN

   3168  0 000002   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         0 000003   000010 604400 0                  TMOZ    s:3171

      209     3169    1              CALL VDG$MEVAL_RGET (STREAM, RANGE);

   3169  0 000004   200003 630500                    EPPR0   @STREAM,,AUTO
         0 000005   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000006   000000 701000 xent               TSX1    VDG$MEVAL_RGET
         0 000007   000000 011000                    NOP     0

      210     3170
      211     3171    1           NODE_DESC = %CLEAR;

   3171  0 000010   200005 470500                    LDP0    @NODE_DESC,,AUTO
         0 000011   000100 100400                    MLR     fill='000'O
         0 000012   000002 000001 xsym               ADSC9   B_VECTNIL+2              cn=0,n=1
         0 000013   000000 000030                    ADSC9   0,,PR0                   cn=0,n=24

      212     3172    1           NODE_DESC.DATA$ = ADDR(NIL);

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:30   
   3172  0 000014   000001 236000 xsym               LDQ     B_VECTNIL+1
         0 000015   000004 756100                    STQ     4,,PR0

      213     3173
      214     3174    1           IF STREAM.CURRENT.EOF OR RANGE.START.EOF THEN

   3174  0 000016   200003 471500                    LDP1    @STREAM,,AUTO
         0 000017   100016 236100                    LDQ     14,,PR1
         0 000020   400000 316007                    CANQ    -131072,DL
         0 000021   000026 601000 0                  TNZ     s:3175
         0 000022   200004 473500                    LDP3    @RANGE,,AUTO
         0 000023   300010 236100                    LDQ     8,,PR3
         0 000024   400000 316007                    CANQ    -131072,DL
         0 000025   000027 600000 0                  TZE     s:3177

      215     3175    1              RETURN;      /* Record outside RANGE */

   3175  0 000026   000000 702200 xent               TSX2  ! X66_ARET

      216     3176
      217     3177    1           NEW_START = -1;

   3177  0 000027   000001 335007                    LCA     1,DL
         0 000030   200012 755100                    STA     NEW_START,,AUTO

      218     3178    1           NEW_LENGTH = -1;

   3178  0 000031   200011 755100                    STA     NEW_LENGTH,,AUTO

      219     3179                %GETKEY (KEY=PORT.CURRENT.KEY, INDX="%(LVL_EXT_REC-1)",
      220     3180                PTR=PORT_KEY$);

   3187  0 000032   100001 474500                    LDP4    1,,PR1
         0 000033   400012 720100                    LXL0    10,,PR4
         0 000034   000002 100003                    CMPX0   2,DU
         0 000035   000042 601000 0                  TNZ     s:3187+8

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:31   
   3187  0 000036   400013 475500                    LDP5    11,,PR4
         0 000037   500002 636500                    EPPR6   2,,PR5
         0 000040   200006 456500                    STP6    PORT_KEY$,,AUTO
         0 000041   000044 710000 0                  TRA     s:3198

   3187  0 000042   400013 635500                    EPPR5   11,,PR4
         0 000043   200006 455500                    STP5    PORT_KEY$,,AUTO

      221     3190                %GETKEY (KEY=RANGE.START.KEY, INDX="%(LVL_EXT_REC-1)",
      222     3191                PTR=START_KEY$);

   3198  0 000044   300000 721100                    LXL1    0,,PR3
         0 000045   000002 101003                    CMPX1   2,DU
         0 000046   000053 601000 0                  TNZ     s:3198+7

   3198  0 000047   300001 475500                    LDP5    1,,PR3
         0 000050   500002 636500                    EPPR6   2,,PR5
         0 000051   200007 456500                    STP6    START_KEY$,,AUTO
         0 000052   000056 710000 0                  TRA     s:3202

   3198  0 000053   200004 236100                    LDQ     @RANGE,,AUTO
         0 000054   000001 036003                    ADLQ    1,DU
         0 000055   200007 756100                    STQ     START_KEY$,,AUTO

      223     3201
      224     3202    1           IF PORT$KEY.BYTES < START$KEY.BYTES THEN

   3202  0 000056   200006 475500                    LDP5    PORT_KEY$,,AUTO
         0 000057   500000 236100                    LDQ     0,,PR5
         0 000060   000033 772000                    QRL     27
         0 000061   200007 476500                    LDP6    START_KEY$,,AUTO
         0 000062   000000 622006                    EAX2    0,QL
         0 000063   600000 236100                    LDQ     0,,PR6
         0 000064   000033 772000                    QRL     27
         0 000065   000000 623006                    EAX3    0,QL
         0 000066   040140 106540                    CMPC    fill='040'O
         0 000067   500000 200012                    ADSC9   0,,PR5                   cn=1,n=*X2
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:32   
         0 000070   600000 200013                    ADSC9   0,,PR6                   cn=1,n=*X3
         0 000071   000073 603000 0                  TRC     s:3204

      225     3203    1              RETURN;      /* Record outside RANGE */

   3203  0 000072   000000 702200 xent               TSX2  ! X66_ARET

      226     3204    1           IF PORT$KEY.BYTES = START$KEY.BYTES THEN

   3204  0 000073   000077 601000 0                  TNZ     s:3211

      227     3205    1              NEW_START = RANGE.START.POSITION#;

   3205  0 000074   300010 236100                    LDQ     8,,PR3
         0 000075   000022 732000                    QRS     18
         0 000076   200012 756100                    STQ     NEW_START,,AUTO

      228     3206
      229     3207                /*
      230     3208                *   From now on, we can be sure that PORT$KEY >= START$KEY.
      231     3209                */
      232     3210
      233     3211    2           IF NOT RANGE.ENDD.EOF THEN DO;

   3211  0 000077   300021 236100                    LDQ     17,,PR3
         0 000100   400000 316007                    CANQ    -131072,DL
         0 000101   000135 601000 0                  TNZ     s:3261

      234     3212
      235     3213                   %GETKEY (KEY=RANGE.ENDD.KEY, INDX="%(LVL_EXT_REC-1)",
      236     3214                   PTR=END_KEY$);

   3221  0 000102   300011 724100                    LXL4    9,,PR3
         0 000103   000002 104003                    CMPX4   2,DU
         0 000104   000111 601000 0                  TNZ     s:3221+7

   3221  0 000105   300012 477500                    LDP7    10,,PR3
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:33   
         0 000106   700002 630500                    EPPR0   2,,PR7
         0 000107   200010 450500                    STP0    END_KEY$,,AUTO
         0 000110   000114 710000 0                  TRA     s:3225

   3221  0 000111   200004 236100                    LDQ     @RANGE,,AUTO
         0 000112   000012 036003                    ADLQ    10,DU
         0 000113   200010 756100                    STQ     END_KEY$,,AUTO

      237     3224
      238     3225    2              IF PORT$KEY.BYTES > END$KEY.BYTES THEN

   3225  0 000114   200010 470500                    LDP0    END_KEY$,,AUTO
         0 000115   000000 236100                    LDQ     0,,PR0
         0 000116   000033 772000                    QRL     27
         0 000117   000000 625006                    EAX5    0,QL
         0 000120   040140 106540                    CMPC    fill='040'O
         0 000121   000000 200015                    ADSC9   0,,PR0                   cn=1,n=*X5
         0 000122   500000 200012                    ADSC9   0,,PR5                   cn=1,n=*X2
         0 000123   000125 603000 0                  TRC     s:3234

      239     3226    2                 RETURN;   /* Record outside RANGE */

   3226  0 000124   000000 702200 xent               TSX2  ! X66_ARET

      240     3227
      241     3228                /*
      242     3229                *   From now on, we can be sure that:
      243     3230                *       PORT$KEY >= START$KEY
      244     3231                *   and PORT$KEY <= END$KEY
      245     3232                */
      246     3233
      247     3234    3              IF PORT$KEY.BYTES = END$KEY.BYTES THEN DO;

   3234  0 000125   000135 601000 0                  TNZ     s:3261

      248     3235    3                 NEW_LENGTH = RANGE.ENDD.POSITION#;

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:34   
   3235  0 000126   300021 236100                    LDQ     17,,PR3
         0 000127   000022 732000                    QRS     18
         0 000130   200011 756100                    STQ     NEW_LENGTH,,AUTO

      249     3236    3                 IF NEW_LENGTH = 0 OR NEW_LENGTH = NEW_START THEN

   3236  0 000131   000134 600000 0                  TZE     s:3239
         0 000132   200012 116100                    CMPQ    NEW_START,,AUTO
         0 000133   000135 601000 0                  TNZ     s:3261

      250     3237                   /* Range is empty, or ... */
      251     3238                   /* Range ends just before Port's record */
      252     3239    3                    RETURN; /* Record outside RANGE */

   3239  0 000134   000000 702200 xent               TSX2  ! X66_ARET

      253     3240    3                 END;
      254     3241    2              END;
      255     3242
      256     3243                /*
      257     3244                *   Now we know we're going to return some part of the record.
      258     3245                */
      259     3246
      260     3247                %COPYKEY (FKEY=PORT.CURRENT.KEY, FINDX="%(LVL_EXT_REC-1)",
      261     3248                TKEY=NODE_DESC.KEY);

   3261  0 000135   100001 470500                    LDP0    1,,PR1
         0 000136   200005 474500                    LDP4    @NODE_DESC,,AUTO
         0 000137   000100 100500                    MLR     fill='000'O
         0 000140   000012 000010                    ADSC9   10,,PR0                  cn=0,n=8
         0 000141   400000 000010                    ADSC9   0,,PR4                   cn=0,n=8

   3261  0 000142   100001 470500                    LDP0    1,,PR1
         0 000143   000012 720100                    LXL0    10,,PR0
         0 000144   000002 100003                    CMPX0   2,DU
         0 000145   000161 601000 0                  TNZ     s:3278

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:35   
   3261  0 000146   000013 477500                    LDP7    11,,PR0
         0 000147   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000150   000001 036003                    ADLQ    1,DU
         0 000151   200015 756100                    STQ     NEW_START+3,,AUTO
         0 000152   200014 457500                    STP7    NEW_START+2,,AUTO
         0 000153   200014 630500                    EPPR0   NEW_START+2,,AUTO
         0 000154   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000155   000000 701000 xent               TSX1    VDG$OCOPY
         0 000156   000160 702000 0                  TSX2    s:3262
         0 000157   000161 710000 0                  TRA     s:3278

   3262  0 000160   000000 702200 xent               TSX2  ! X66_AALT

      262     3264                %COPYSPEC (FSPEC=PORT.LEVEL.SPEC, FINDX=%LVL_EXT_REC,
      263     3265                TSPEC=NODE_DESC.SPEC);

   3278  0 000161   200003 470500                    LDP0    @STREAM,,AUTO
         0 000162   000001 471500                    LDP1    1,,PR0
         0 000163   200005 473500                    LDP3    @NODE_DESC,,AUTO
         0 000164   000100 100500                    MLR     fill='000'O
         0 000165   100034 000010                    ADSC9   28,,PR1                  cn=0,n=8
         0 000166   300002 000010                    ADSC9   2,,PR3                   cn=0,n=8

   3278  0 000167   000001 471500                    LDP1    1,,PR0
         0 000170   100034 720100                    LXL0    28,,PR1
         0 000171   000002 100003                    CMPX0   2,DU
         0 000172   000206 601000 0                  TNZ     s:3281

   3278  0 000173   100035 474500                    LDP4    29,,PR1
         0 000174   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000175   000003 036003                    ADLQ    3,DU
         0 000176   200015 756100                    STQ     NEW_START+3,,AUTO
         0 000177   200014 454500                    STP4    NEW_START+2,,AUTO
         0 000200   200014 630500                    EPPR0   NEW_START+2,,AUTO
         0 000201   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000202   000000 701000 xent               TSX1    VDG$OCOPY
         0 000203   000205 702000 0                  TSX2    s:3279
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:36   
         0 000204   000206 710000 0                  TRA     s:3281

   3279  0 000205   000000 702200 xent               TSX2  ! X66_AALT

      264     3281    2           IF PORT.LEVEL.DATA$ (%LVL_EXT_REC) = ADDR(NIL) THEN DO;

   3281  0 000206   200003 470500                    LDP0    @STREAM,,AUTO
         0 000207   000001 471500                    LDP1    1,,PR0
         0 000210   100036 236100                    LDQ     30,,PR1
         0 000211   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000212   000254 601000 0                  TNZ     s:3288

      265     3282    2              CALL VDG$OALLOC (%CLS_BUFFER, NODE_DESC.DATA$,

   3282  0 000213   200005 473500                    LDP3    @NODE_DESC,,AUTO
         0 000214   300004 474500                    LDP4    4,,PR3
         0 000215   200014 454500                    STP4    NEW_START+2,,AUTO
         0 000216   200014 236100                    LDQ     NEW_START+2,,AUTO
         0 000217   000000 036000 1                  ADLQ    0
         0 000220   770000 036007                    ADLQ    -4096,DL
         0 000221   000001 376000 1                  ANQ     1
         0 000222   300004 471500                    LDP1    4,,PR3
         0 000223   200015 451500                    STP1    NEW_START+3,,AUTO
         0 000224   200016 756100                    STQ     NEW_START+4,,AUTO
         0 000225   200015 236100                    LDQ     NEW_START+3,,AUTO
         0 000226   000022 772000                    QRL     18
         0 000227   200017 756100                    STQ     NEW_START+5,,AUTO
         0 000230   200016 236100                    LDQ     NEW_START+4,,AUTO
         0 000231   000022 772000                    QRL     18
         0 000232   200017 136100                    SBLQ    NEW_START+5,,AUTO
         0 000233   200020 756100                    STQ     NEW_START+6,,AUTO
         0 000234   200020 635500                    EPPR5   NEW_START+6,,AUTO
         0 000235   200023 455500                    STP5    NEW_START+9,,AUTO
         0 000236   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000237   000004 036003                    ADLQ    4,DU
         0 000240   200022 756100                    STQ     NEW_START+8,,AUTO
         0 000241   000002 236000 1                  LDQ     2
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:37   
         0 000242   200021 756100                    STQ     NEW_START+7,,AUTO
         0 000243   200021 630500                    EPPR0   NEW_START+7,,AUTO
         0 000244   000021 631400 xsym               EPPR1   B_VECTNIL+17
         0 000245   000000 701000 xent               TSX1    VDG$OALLOC
         0 000246   000371 702000 0                  TSX2    OALLOC_FAILED

      266     3283    2                POFFW(PALIGNW(ADDR(NODE$RECORD.BYTES)), ADDR(NODE$RECORD)))
      267     3284    2                ALTRET (OALLOC_FAILED);
      268     3285    2              NODE_DESC.DATA$->VD$BUFFER.LENGTH# = 0;

   3285  0 000247   200005 470500                    LDP0    @NODE_DESC,,AUTO
         0 000250   000004 471500                    LDP1    4,,PR0
         0 000251   000000 220003                    LDX0    0,DU
         0 000252   100002 740100                    STX0    2,,PR1

      269     3286    2              END;

   3286  0 000253   000265 710000 0                  TRA     s:3292

      270     3287    2           ELSE DO;

      271     3288    2              CALL VDG$OCOPY (PORT.LEVEL.DATA$ (%LVL_EXT_REC) -> VD$BUFFER,

   3288  0 000254   100036 473500                    LDP3    30,,PR1
         0 000255   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000256   000004 036003                    ADLQ    4,DU
         0 000257   200015 756100                    STQ     NEW_START+3,,AUTO
         0 000260   200014 453500                    STP3    NEW_START+2,,AUTO
         0 000261   200014 630500                    EPPR0   NEW_START+2,,AUTO
         0 000262   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000263   000000 701000 xent               TSX1    VDG$OCOPY
         0 000264   000371 702000 0                  TSX2    OALLOC_FAILED

      272     3289    2                NODE_DESC.DATA$)
      273     3290    2                ALTRET (OCOPY_FAILED);
      274     3291    2              END;

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:38   
      275     3292    1           IF PORT.DCB# = 0 THEN

   3292  0 000265   200003 470500                    LDP0    @STREAM,,AUTO
         0 000266   000001 471500                    LDP1    1,,PR0
         0 000267   100004 720100                    LXL0    4,,PR1
         0 000270   000300 601000 0                  TNZ     s:3296

      276     3293    1              NODE_DESC.EOR = PORT.LEVEL.INTERNAL$ (%LVL_EXT_REC) ->

   3293  0 000271   100040 473500                    LDP3    32,,PR1
         0 000272   200005 474500                    LDP4    @NODE_DESC,,AUTO
         0 000273   300011 236100                    LDQ     9,,PR3
         0 000274   400005 676100                    ERQ     5,,PR4
         0 000275   400000 376003                    ANQ     -131072,DU
         0 000276   400005 656100                    ERSQ    5,,PR4
         0 000277   000303 710000 0                  TRA     s:3298

      277     3294    1                VD$FILE_NODE.DESC.EOR;
      278     3295    1           ELSE
      279     3296    1              NODE_DESC.EOR = %TRUE;

   3296  0 000300   200005 473500                    LDP3    @NODE_DESC,,AUTO
         0 000301   400000 236003                    LDQ     -131072,DU
         0 000302   300005 256100                    ORSQ    5,,PR3

      280     3297
      281     3298    2           IF NEW_LENGTH >= 0 THEN DO;

   3298  0 000303   200011 235100                    LDA     NEW_LENGTH,,AUTO
         0 000304   000326 604000 0                  TMI     s:3313

      282     3299    2              IF NEW_LENGTH ~=

   3299  0 000305   200005 471500                    LDP1    @NODE_DESC,,AUTO
         0 000306   100004 473500                    LDP3    4,,PR1
         0 000307   300002 236100                    LDQ     2,,PR3
         0 000310   000022 732000                    QRS     18
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:39   
         0 000311   200011 116100                    CMPQ    NEW_LENGTH,,AUTO
         0 000312   000323 600000 0                  TZE     s:3310

      283     3300    3                NODE_DESC.DATA$->VD$BUFFER.LENGTH# THEN DO;

      284     3301    3                 CALL VDE$RADJUST_LENGTH (NODE_DESC, NEW_LENGTH)

   3301  0 000313   200011 634500                    EPPR4   NEW_LENGTH,,AUTO
         0 000314   200015 454500                    STP4    NEW_START+3,,AUTO
         0 000315   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000316   200014 756100                    STQ     NEW_START+2,,AUTO
         0 000317   200014 630500                    EPPR0   NEW_START+2,,AUTO
         0 000320   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000321   000000 701000 xent               TSX1    VDE$RADJUST_LENGTH
         0 000322   000371 702000 0                  TSX2    OALLOC_FAILED

      285     3302    3                   ALTRET (RADJUST_LENGTH_FAILED);
      286     3303    3                 END;

      287     3304                   /*
      288     3305                   *  Even if we extended the record, the fact that the
      289     3306                   *    RANGE.ENDD lies anywhere in the NODE_DESC record
      290     3307                   *    means that the returned record loses its
      291     3308                   *    EOR-boundary.
      292     3309                   */
      293     3310    2              NODE_DESC.EOR = %FALSE;

   3310  0 000323   200005 470500                    LDP0    @NODE_DESC,,AUTO
         0 000324   000031 236000 xsym               LDQ     B_VECTNIL+25
         0 000325   000005 356100                    ANSQ    5,,PR0

      294     3311    2              END;

      295     3312
      296     3313    2           IF NEW_START > 0 THEN DO;

   3313  0 000326   200012 235100                    LDA     NEW_START,,AUTO
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:40   
         0 000327   000357 604400 0                  TMOZ    s:3327

      297     3314    2              IF NODE$RECORD.LENGTH# <= NEW_START THEN

   3314  0 000330   200005 470500                    LDP0    @NODE_DESC,,AUTO
         0 000331   000004 471500                    LDP1    4,,PR0
         0 000332   100002 236100                    LDQ     2,,PR1
         0 000333   000022 732000                    QRS     18
         0 000334   200012 116100                    CMPQ    NEW_START,,AUTO
         0 000335   000341 605400 0                  TPNZ    s:3317

      298     3315    2                 NODE$RECORD.LENGTH# = 0;

   3315  0 000336   000000 220003                    LDX0    0,DU
         0 000337   100002 740100                    STX0    2,,PR1
         0 000340   000352 710000 0                  TRA     s:3322

      299     3316    3              ELSE DO;

      300     3317    3                 NODE$RECORD.LENGTH# = NODE$RECORD.LENGTH# - NEW_START;

   3317  0 000341   200012 136100                    SBLQ    NEW_START,,AUTO
         0 000342   000000 620006                    EAX0    0,QL
         0 000343   100002 740100                    STX0    2,,PR1

      301     3318    3                 SUBSTR (NODE$RECORD.BYTES, 0, NODE$RECORD.LENGTH#) =

   3318  0 000344   000004 471500                    LDP1    4,,PR0
         0 000345   100002 220100                    LDX0    2,,PR1
         0 000346   100002 221100                    LDX1    2,,PR1
         0 000347   040140 100545                    MLR     fill='040'O
         0 000350   100002 400011                    ADSC9   2,A,PR1                  cn=2,n=*X1
         0 000351   100002 400010                    ADSC9   2,,PR1                   cn=2,n=*X0

      302     3319    3                   SUBSTR (NODE$RECORD.BYTES, NEW_START, NODE$RECORD.LENGTH#);
      303     3320    3                 END;

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:41   
      304     3321
      305     3322    2              IF NODE_DESC.SPEC.TYPE# = %SPT_EXT_RECORD THEN

   3322  0 000352   000002 220100                    LDX0    2,,PR0
         0 000353   000001 100003                    CMPX0   1,DU
         0 000354   000357 601000 0                  TNZ     s:3327

      306     3323                         /* Partial records not including byte 0 don't have VFC */
      307     3324    2                 NODE_DESC.SPEC = %CLEAR;

   3324  0 000355   000002 450100                    STZ     2,,PR0
         0 000356   000003 450100                    STZ     3,,PR0

      308     3325    2              END;

      309     3326
      310     3327    1           IF VD_$$MON_EVAL.V# > 0 THEN

   3327  0 000357   000003 236000 xsym               LDQ     VD_$$MON_EVAL+3
         0 000360   000370 604400 0                  TMOZ    s:3330

      311     3328    1              CALL VDG$MEVAL_RGET_RETURN (STREAM, NODE_DESC);

   3328  0 000361   200005 236100                    LDQ     @NODE_DESC,,AUTO
         0 000362   200003 235100                    LDA     @STREAM,,AUTO
         0 000363   200014 757100                    STAQ    NEW_START+2,,AUTO
         0 000364   200014 630500                    EPPR0   NEW_START+2,,AUTO
         0 000365   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000366   000000 701000 xent               TSX1    VDG$MEVAL_RGET_RETURN
         0 000367   000000 011000                    NOP     0

      312     3329
      313     3330    1           RETURN;

   3330  0 000370   000000 702200 xent               TSX2  ! X66_ARET

   3327  0 000371                       OALLOC_FAIL* null
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:42   
   3327  0 000371                       OCOPY_FAILED null
   3327  0 000371                       RADJUST_LEN* null
      314     3331
      315     3332
      316     3333
      317     3334    1   OALLOC_FAILED: ;
      318     3335    1   OCOPY_FAILED: ;
      319     3336    1   RADJUST_LENGTH_FAILED: ;
      320     3337    1           ALTRETURN;

   3337  0 000371   000000 702200 xent               TSX2  ! X66_AALT
      321     3338
      322     3339    1   END VDE$RGET;
      323     3340        %EOD;

PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:43   
--  Include file information  --

   VD_PERR_C.:VDA5TOU  is referenced.
   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RGET.
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:44   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     5-0-0/w PTR         r     1 @NODE_DESC                 4-0-0/w PTR         r     1 @RANGE
     3-0-0/w PTR         r     1 @STREAM                   10-0-0/w PTR         r     1 END_KEY$
    11-0-0/w SBIN        r     1 NEW_LENGTH                12-0-0/w SBIN        r     1 NEW_START
    *0-0-0/w STRC(216)   r     1 NODE_DESC                  6-0-0/w PTR         r     1 PORT_KEY$
    *0-0-0/w STRC(648)   r     1 RANGE                      7-0-0/w PTR         r     1 START_KEY$
    *0-0-0/w STRC(864)   r     1 STREAM

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 VD_$$MON_EVAL

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w ASTR(9)     r     1 END$KEY                    0-0-0/w ASTR(90)    r     1 NODE$RECORD
     0-0-0/w STRC(1944)  r     1 PORT                       0-0-0/w ASTR(9)     r     1 PORT$KEY
     0-0-0/w ASTR(9)     r     1 START$KEY                  0-0-0/w ASTR(90)    r     1 VD$BUFFER
     0-0-0/w STRC(468)   r     1 VD$FILE_NODE               0-0-0/w ASTR(81)    r     1 VD$TEXTC_REMOTE


   Procedure VDE$RGET requires 250 words for executable code.
   Procedure VDE$RGET requires 20 words of local(AUTO) storage.
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:45   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:46   
          MINI XREF LISTING

END$KEY.BYTES
      2854**DCL      3225>>IF       3234>>IF
END$KEY.LENGTH#
      2852**DCL      2854--IMP-SIZ  3225>>IF       3234>>IF
END_KEY$
      2687**DCL      2844--IMP-PTR  3221<<ASSIGN   3221<<ASSIGN   3225>>IF       3225>>IF       3234>>IF
      3234>>IF
NEW_LENGTH
      2688**DCL      3178<<ASSIGN   3235<<ASSIGN   3236>>IF       3236>>IF       3298>>IF       3299>>IF
      3301<>CALL
NEW_START
      2689**DCL      3177<<ASSIGN   3205<<ASSIGN   3236>>IF       3313>>IF       3314>>IF       3317>>ASSIGN
      3318>>ASSIGN
NODE$RECORD
      2884**DCL      3282--CALL
NODE$RECORD.BYTES
      2912**DCL      3282--CALL     3318<<ASSIGN   3318>>ASSIGN
NODE$RECORD.LENGTH#
      2910**DCL      2912--IMP-SIZ  3314>>IF       3315<<ASSIGN   3317<<ASSIGN   3317>>ASSIGN   3318>>ASSIGN
      3318>>ASSIGN   3318>>ASSIGN   3318>>ASSIGN
NODE_DESC
      2591**DCL        41--PROC     3171<<ASSIGN   3301<>CALL     3328<>CALL
NODE_DESC.DATA$
      2623**DCL      2884--IMP-PTR  3172<<ASSIGN   3282<>CALL     3282>>CALL     3282>>CALL     3285>>ASSIGN
      3288<>CALL     3299>>IF       3314>>IF       3315>>ASSIGN   3317>>ASSIGN   3317>>ASSIGN   3318>>ASSIGN
      3318>>ASSIGN   3318>>ASSIGN   3318>>ASSIGN   3318>>ASSIGN   3318>>ASSIGN
NODE_DESC.EOR
      2623**DCL      3293<<ASSIGN   3296<<ASSIGN   3310<<ASSIGN
NODE_DESC.KEY
      2605**DCL      3261<<ASSIGN
NODE_DESC.KEY.V$
      2607**DCL      3261<>CALL
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:47   
NODE_DESC.SPEC
      2619**DCL      3278<<ASSIGN   3324<<ASSIGN
NODE_DESC.SPEC.TYPE#
      2621**DCL      3322>>IF
NODE_DESC.SPEC.V$
      2621**DCL      3278<>CALL
OALLOC_FAILED
      3327**LABEL    3282--CALLALT
OCOPY_FAILED
      3327**LABEL    3288--CALLALT
PORT.CURRENT.KEY
      2765**DCL      3261>>ASSIGN
PORT.CURRENT.KEY.REP#
      2767**DCL      3187>>IF       3261>>IF
PORT.CURRENT.KEY.V$
      2767**DCL      3187>>ASSIGN   3187--ASSIGN   3261>>CALL     3261>>CALL
PORT.DCB#
      2727**DCL      3292>>IF
PORT.LEVEL.DATA$
      2787**DCL      3281>>IF       3288>>CALL     3288>>CALL
PORT.LEVEL.INTERNAL$
      2787**DCL      3293>>ASSIGN
PORT.LEVEL.SPEC
      2783**DCL      3278>>ASSIGN
PORT.LEVEL.SPEC.REP#
      2785**DCL      3278>>IF
PORT.LEVEL.SPEC.V$
      2785**DCL      3278>>CALL     3278>>CALL
PORT$KEY.BYTES
      2808**DCL      3202>>IF       3204>>IF       3225>>IF       3234>>IF
PORT$KEY.LENGTH#
      2806**DCL      2808--IMP-SIZ  3202>>IF       3204>>IF       3225>>IF       3234>>IF
PORT_KEY$
      2685**DCL      2798--IMP-PTR  3187<<ASSIGN   3187<<ASSIGN   3202>>IF       3202>>IF       3204>>IF
      3204>>IF       3225>>IF       3225>>IF       3234>>IF       3234>>IF
RADJUST_LENGTH_FAILED
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:48   
      3327**LABEL    3301--CALLALT
RANGE
      2522**DCL        41--PROC     3169<>CALL
RANGE.ENDD.EOF
      2580**DCL      3211>>IF
RANGE.ENDD.KEY.REP#
      2578**DCL      3221>>IF
RANGE.ENDD.KEY.V$
      2578**DCL      3221>>ASSIGN   3221--ASSIGN
RANGE.ENDD.POSITION#
      2580**DCL      3235>>ASSIGN
RANGE.START.EOF
      2552**DCL      3174>>IF
RANGE.START.KEY.REP#
      2550**DCL      3198>>IF
RANGE.START.KEY.V$
      2550**DCL      3198>>ASSIGN   3198--ASSIGN
RANGE.START.POSITION#
      2552**DCL      3205>>ASSIGN
START$KEY.BYTES
      2831**DCL      3202>>IF       3204>>IF
START$KEY.LENGTH#
      2829**DCL      2831--IMP-SIZ  3202>>IF       3204>>IF
START_KEY$
      2686**DCL      2821--IMP-PTR  3198<<ASSIGN   3198<<ASSIGN   3202>>IF       3202>>IF       3204>>IF
      3204>>IF
STREAM
      2416**DCL        41--PROC     3169<>CALL     3328<>CALL
STREAM.CURRENT.EOF
      2483**DCL      3174>>IF
STREAM.PORT$
      2442**DCL      2700--IMP-PTR  3187>>IF       3187>>ASSIGN   3187>>ASSIGN   3261>>ASSIGN   3261>>IF
      3261>>CALL     3261>>CALL     3278>>ASSIGN   3278>>IF       3278>>CALL     3278>>CALL     3281>>IF
      3288>>CALL     3288>>CALL     3292>>IF       3293>>ASSIGN
VD$BUFFER
      2942**DCL      3288<>CALL
PL6.E3A0      #002=VDE$RGET File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:16 Page:49   
VD$BUFFER.LENGTH#
      2968**DCL      2970--IMP-SIZ  3285<<ASSIGN   3288>>CALL     3299>>IF
VD$FILE_NODE.DESC.EOR
      3161**DCL      3293>>ASSIGN
VD$TEXTC_REMOTE
      3036**DCL      3261<>CALL     3278<>CALL
VD$TEXTC_REMOTE.LENGTH#
      3065**DCL      3067--IMP-SIZ  3187--ASSIGN   3198--ASSIGN   3221--ASSIGN   3261>>CALL     3278>>CALL
VDE$RADJUST_LENGTH
      2627**DCL-ENT  3301--CALL
VDG$MEVAL_RGET
      2632**DCL-ENT  3169--CALL
VDG$MEVAL_RGET_RETURN
      2633**DCL-ENT  3328--CALL
VDG$OALLOC
      2628**DCL-ENT  3282--CALL
VDG$OCOPY
      2629**DCL-ENT  3261--CALL     3278--CALL     3288--CALL
VD_$$MON_EVAL.V#
      2679**DCL      3168>>IF       3327>>IF

PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:50   
      324        1        /*T***********************************************************/
      325        2        /*T*                                                         */
      326        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      327        4        /*T*                                                         */
      328        5        /*T***********************************************************/
      329        6
      330        7        /*D* NAME: VDE$RADJUST_LENGTH
      331        8            PARAMETERS:
      332        9                NODE_DESC - VD$NODE_DESC describing the record to adjust.
      333       10                NEW_LENGTH - New length for the record (ubin WORD!!!!).
      334       11            INPUT:
      335       12                VD_$PAD - VD$BUFFER containing the current value of the $PAD
      336       13                    predefined name.  Value's length must be > 0.
      337       14            OUTPUT:
      338       15                NODE_DESC.DATA$'s VD$BUFFER will be changed.  In addition,
      339       16                NODE_DESC.DATA$ itself may be changed, and it's old VD$BUFFER
      340       17                    freed.
      341       18                NODE_DESC.EOR may be reset.
      342       19            DESCRIPTION:
      343       20                Truncate or extend NODE_DESC's record to NEW_LENGTH.
      344       21                If truncating, NODE_DESC.EOR will be reset.
      345       22                If extending, and NODE_DESC's data buffer is too small for the
      346       23                    extension, copy it to a new one.  Extend the record using
      347       24                    the value of $PAD.
      348       25        */
      349       26
      350       27        VDE$RADJUST_LENGTH: PROC (NODE_DESC, NEW_LENGTH) ALTRET;
      351       28
      352       29        %INCLUDE VD_MACROS_M;
      353     2244
      354     2245
      355     2246        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
      356     2288    1   DCL NEW_LENGTH SBIN;
      357     2289
      358     2290
      359     2291    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      360     2292    1   DCL VDG$OFREE           ENTRY (1) ALTRET;
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:51   
      361     2293    1   DCL VDG$ESCREECH        ENTRY (3);
      362     2294
      363     2295
      364     2296        %VD_BUFFER (NAME=VD_$PAD, STCLASS=SYMREF, MXNB=%MXNB_$PAD);
      365     2356
      366     2357
      367     2358
      368     2359
      369     2360    1   DCL OLD_LENGTH SBIN;
      370     2361    1   DCL OLD_OBJECT_SIZE SBIN;
      371     2362    1   DCL NEW_OBJECT_SIZE SBIN;
      372     2363    1   DCL NEW_BUFFER$ PTR;
      373     2364    1   DCL I SBIN;
      374     2365
      375     2366
      376     2367        %VD$BUFFER (NAME=DATA$BUFFER, STCLASS="BASED(NODE_DESC.DATA$)");
      377     2425        %VD$BUFFER (NAME=NEW$BUFFER, STCLASS="BASED(NEW_BUFFER$)");
      378     2483        %VD$BUFFER_HEADER;
      379     2519
      380     2520
      381     2521
      382     2522    2           IF NODE_DESC.DATA$ = ADDR(NIL) THEN DO;
      383     2523    2              OLD_LENGTH = 0;
      384     2524    2              OLD_OBJECT_SIZE = 0;
      385     2525    2              END;
      386     2526    2           ELSE DO;
      387     2527    2              OLD_LENGTH = DATA$BUFFER.LENGTH#;
      388     2528    2              OLD_OBJECT_SIZE = DATA$BUFFER.OBJECT.SIZE#;
      389     2529    2              END;
      390     2530
      391     2531    1           NEW_OBJECT_SIZE = (LENGTHC(VD$BUFFER_HEADER) + NEW_LENGTH +
      392     2532    1             %(NB_PER_WORD-1)) / %NB_PER_WORD;
      393     2533
      394     2534    2           IF NEW_OBJECT_SIZE > OLD_OBJECT_SIZE THEN DO;
      395     2535    2              CALL VDG$OALLOC (%CLS_BUFFER, NEW_BUFFER$, NEW_OBJECT_SIZE)
      396     2536    2                ALTRET (OALLOC_FAILED);
      397     2537    2              NEW$BUFFER.LENGTH# = OLD_LENGTH;
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:52   
      398     2538    3              IF NODE_DESC.DATA$ ~= ADDR(NIL) THEN DO;
      399     2539    3                 NEW$BUFFER.BYTES = DATA$BUFFER.BYTES;
      400     2540    3                 CALL VDG$OFREE (DATA$BUFFER)
      401     2541    3                   ALTRET (OFREE_FAILED);
      402     2542    3                 END;
      403     2543    2              NODE_DESC.DATA$ = NEW_BUFFER$;
      404     2544    2              END;
      405     2545
      406     2546    1           DATA$BUFFER.LENGTH# = NEW_LENGTH;
      407     2547    2           IF NEW_LENGTH < OLD_LENGTH THEN DO;
      408     2548                   /*
      409     2549                   *    We truncated the record:  it no longer has an EOR-boundary.
      410     2550                   */
      411     2551    2              NODE_DESC.EOR = %FALSE;
      412     2552    2              END;
      413     2553    2           ELSE IF NEW_LENGTH > OLD_LENGTH THEN DO;
      414     2554                      /*  We extended the record:  fill in with $PAD value */
      415     2555    2                 IF SUBSTR(VD_$PAD.BYTES, 0, VD_$PAD.LENGTH#) =
      416     2556    3                   %CHR_SPACE THEN DO;
      417     2557                         /*
      418     2558                         *    If $PAD is space, we can let INSERT fill for us.
      419     2559                         */
      420     2560    3                    CALL INSERT (DATA$BUFFER.BYTES, OLD_LENGTH, , %CHR_SPACE)
      421     2561    4                    WHENALTRETURN DO;
      422     2562    4                       CALL VDG$ESCREECH;
      423     2563    4                       END;
      424     2564    3                    END;
      425     2565    3                 ELSE DO;
      426     2566    4                    DO I = OLD_LENGTH TO (NEW_LENGTH-1) BY VD_$PAD.LENGTH#;
      427     2567    4                       CALL INSERT (DATA$BUFFER.BYTES, I, VD_$PAD.LENGTH#,
      428     2568    4                         SUBSTR(VD_$PAD.BYTES, 0, VD_$PAD.LENGTH#))
      429     2569    5                       WHENALTRETURN DO;
      430     2570    5                          CALL VDG$ESCREECH;
      431     2571    5                          END;
      432     2572    4                       END;
      433     2573    3                    END;
      434     2574    2                 END;
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:53   
      435     2575
      436     2576    1           RETURN;
      437     2577
      438     2578
      439     2579    1   OALLOC_FAILED: ;
      440     2580    1   OFREE_FAILED: ;
      441     2581    1           ALTRETURN;
      442     2582
      443     2583    1   END VDE$RADJUST_LENGTH;
      444     2584        %EOD;

PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:54   
--  Include file information  --

   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RADJUST_LENGTH.

   Procedure VDE$RADJUST_LENGTH requires 121 words for executable code.
   Procedure VDE$RADJUST_LENGTH requires 14 words of local(AUTO) storage.

PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:55   

 Object Unit name= VDE$RADJUST_LENGTH                         File name= VDE$RECORDS.:VDA5TOU
 UTS= JUL 04 '97 11:16:55.88 FRI                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none   121    171  VDE$RADJUST_LENGTH
    1  RoData even  none     1      1  VDE$RADJUST_LENGTH

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  VDE$RADJUST_LENGTH

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       3 VDG$OALLOC
 yes     yes           Std       1 VDG$OFREE
         yes           Std       3 VDG$ESCREECH
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     VD_$PAD                               B_VECTNIL
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:56   

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:57   


      324        1        /*T***********************************************************/
      325        2        /*T*                                                         */
      326        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      327        4        /*T*                                                         */
      328        5        /*T***********************************************************/
      329        6
      330        7        /*D* NAME: VDE$RADJUST_LENGTH
      331        8            PARAMETERS:
      332        9                NODE_DESC - VD$NODE_DESC describing the record to adjust.
      333       10                NEW_LENGTH - New length for the record (ubin WORD!!!!).
      334       11            INPUT:
      335       12                VD_$PAD - VD$BUFFER containing the current value of the $PAD
      336       13                    predefined name.  Value's length must be > 0.
      337       14            OUTPUT:
      338       15                NODE_DESC.DATA$'s VD$BUFFER will be changed.  In addition,
      339       16                NODE_DESC.DATA$ itself may be changed, and it's old VD$BUFFER
      340       17                    freed.
      341       18                NODE_DESC.EOR may be reset.
      342       19            DESCRIPTION:
      343       20                Truncate or extend NODE_DESC's record to NEW_LENGTH.
      344       21                If truncating, NODE_DESC.EOR will be reset.
      345       22                If extending, and NODE_DESC's data buffer is too small for the
      346       23                    extension, copy it to a new one.  Extend the record using
      347       24                    the value of $PAD.
      348       25        */
      349       26
      350       27        VDE$RADJUST_LENGTH: PROC (NODE_DESC, NEW_LENGTH) ALTRET;

     27  0 000000   000000 700200 xent  VDE$RADJUST* TSX0  ! X66_AUTO_2
         0 000001   000016 000002                    ZERO    14,2

      351       28
      352       29        %INCLUDE VD_MACROS_M;
      353     2244
      354     2245
      355     2246        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:58   
      356     2288    1   DCL NEW_LENGTH SBIN;
      357     2289
      358     2290
      359     2291    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      360     2292    1   DCL VDG$OFREE           ENTRY (1) ALTRET;
      361     2293    1   DCL VDG$ESCREECH        ENTRY (3);
      362     2294
      363     2295
      364     2296        %VD_BUFFER (NAME=VD_$PAD, STCLASS=SYMREF, MXNB=%MXNB_$PAD);
      365     2356
      366     2357
      367     2358
      368     2359
      369     2360    1   DCL OLD_LENGTH SBIN;
      370     2361    1   DCL OLD_OBJECT_SIZE SBIN;
      371     2362    1   DCL NEW_OBJECT_SIZE SBIN;
      372     2363    1   DCL NEW_BUFFER$ PTR;
      373     2364    1   DCL I SBIN;
      374     2365
      375     2366
      376     2367        %VD$BUFFER (NAME=DATA$BUFFER, STCLASS="BASED(NODE_DESC.DATA$)");
      377     2425        %VD$BUFFER (NAME=NEW$BUFFER, STCLASS="BASED(NEW_BUFFER$)");
      378     2483        %VD$BUFFER_HEADER;
      379     2519
      380     2520
      381     2521
      382     2522    2           IF NODE_DESC.DATA$ = ADDR(NIL) THEN DO;

   2522  0 000002   200003 470500                    LDP0    @NODE_DESC,,AUTO
         0 000003   000004 236100                    LDQ     4,,PR0
         0 000004   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000005   000011 601000 0                  TNZ     s:2527

      383     2523    2              OLD_LENGTH = 0;

   2523  0 000006   200005 450100                    STZ     OLD_LENGTH,,AUTO

PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:59   
      384     2524    2              OLD_OBJECT_SIZE = 0;

   2524  0 000007   200006 450100                    STZ     OLD_OBJECT_SIZE,,AUTO

      385     2525    2              END;

   2525  0 000010   000021 710000 0                  TRA     s:2531

      386     2526    2           ELSE DO;

      387     2527    2              OLD_LENGTH = DATA$BUFFER.LENGTH#;

   2527  0 000011   000004 471500                    LDP1    4,,PR0
         0 000012   100002 236100                    LDQ     2,,PR1
         0 000013   000022 732000                    QRS     18
         0 000014   200005 756100                    STQ     OLD_LENGTH,,AUTO

      388     2528    2              OLD_OBJECT_SIZE = DATA$BUFFER.OBJECT.SIZE#;

   2528  0 000015   100000 236100                    LDQ     0,,PR1
         0 000016   000022 736000                    QLS     18
         0 000017   000022 732000                    QRS     18
         0 000020   200006 756100                    STQ     OLD_OBJECT_SIZE,,AUTO

      389     2529    2              END;

      390     2530
      391     2531    1           NEW_OBJECT_SIZE = (LENGTHC(VD$BUFFER_HEADER) + NEW_LENGTH +

   2531  0 000021   200004 471500                    LDP1    @NEW_LENGTH,,AUTO
         0 000022   100000 236100                    LDQ     0,,PR1
         0 000023   000015 036007                    ADLQ    13,DL
         0 000024   000004 506007                    DIV     4,DL
         0 000025   200007 756100                    STQ     NEW_OBJECT_SIZE,,AUTO

      392     2532    1             %(NB_PER_WORD-1)) / %NB_PER_WORD;
      393     2533
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:60   
      394     2534    2           IF NEW_OBJECT_SIZE > OLD_OBJECT_SIZE THEN DO;

   2534  0 000026   200006 116100                    CMPQ    OLD_OBJECT_SIZE,,AUTO
         0 000027   000071 604400 0                  TMOZ    s:2546

      395     2535    2              CALL VDG$OALLOC (%CLS_BUFFER, NEW_BUFFER$, NEW_OBJECT_SIZE)

   2535  0 000030   200007 633500                    EPPR3   NEW_OBJECT_SIZE,,AUTO
         0 000031   200014 453500                    STP3    I+3,,AUTO
         0 000032   200010 634500                    EPPR4   NEW_BUFFER$,,AUTO
         0 000033   200013 454500                    STP4    I+2,,AUTO
         0 000034   000000 236000 1                  LDQ     0
         0 000035   200012 756100                    STQ     I+1,,AUTO
         0 000036   200012 630500                    EPPR0   I+1,,AUTO
         0 000037   000021 631400 xsym               EPPR1   B_VECTNIL+17
         0 000040   000000 701000 xent               TSX1    VDG$OALLOC
         0 000041   000170 702000 0                  TSX2    OALLOC_FAILED

      396     2536    2                ALTRET (OALLOC_FAILED);
      397     2537    2              NEW$BUFFER.LENGTH# = OLD_LENGTH;

   2537  0 000042   200005 720100                    LXL0    OLD_LENGTH,,AUTO
         0 000043   200010 470500                    LDP0    NEW_BUFFER$,,AUTO
         0 000044   000002 740100                    STX0    2,,PR0

      398     2538    3              IF NODE_DESC.DATA$ ~= ADDR(NIL) THEN DO;

   2538  0 000045   200003 470500                    LDP0    @NODE_DESC,,AUTO
         0 000046   000004 236100                    LDQ     4,,PR0
         0 000047   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000050   000066 600000 0                  TZE     s:2543

      399     2539    3                 NEW$BUFFER.BYTES = DATA$BUFFER.BYTES;

   2539  0 000051   200010 471500                    LDP1    NEW_BUFFER$,,AUTO
         0 000052   100002 221100                    LDX1    2,,PR1
         0 000053   000004 473500                    LDP3    4,,PR0
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:61   
         0 000054   300002 222100                    LDX2    2,,PR3
         0 000055   040140 100540                    MLR     fill='040'O
         0 000056   300002 400012                    ADSC9   2,,PR3                   cn=2,n=*X2
         0 000057   100002 400011                    ADSC9   2,,PR1                   cn=2,n=*X1

      400     2540    3                 CALL VDG$OFREE (DATA$BUFFER)

   2540  0 000060   000004 471500                    LDP1    4,,PR0
         0 000061   200012 451500                    STP1    I+1,,AUTO
         0 000062   200012 630500                    EPPR0   I+1,,AUTO
         0 000063   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000064   000000 701000 xent               TSX1    VDG$OFREE
         0 000065   000170 702000 0                  TSX2    OALLOC_FAILED

      401     2541    3                   ALTRET (OFREE_FAILED);
      402     2542    3                 END;

      403     2543    2              NODE_DESC.DATA$ = NEW_BUFFER$;

   2543  0 000066   200010 236100                    LDQ     NEW_BUFFER$,,AUTO
         0 000067   200003 470500                    LDP0    @NODE_DESC,,AUTO
         0 000070   000004 756100                    STQ     4,,PR0

      404     2544    2              END;

      405     2545
      406     2546    1           DATA$BUFFER.LENGTH# = NEW_LENGTH;

   2546  0 000071   000004 471500                    LDP1    4,,PR0
         0 000072   200004 473500                    LDP3    @NEW_LENGTH,,AUTO
         0 000073   300000 720100                    LXL0    0,,PR3
         0 000074   100002 740100                    STX0    2,,PR1

      407     2547    2           IF NEW_LENGTH < OLD_LENGTH THEN DO;

   2547  0 000075   300000 236100                    LDQ     0,,PR3
         0 000076   200005 116100                    CMPQ    OLD_LENGTH,,AUTO
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:62   
         0 000077   000103 605000 0                  TPL     s:2553

      408     2548                   /*
      409     2549                   *    We truncated the record:  it no longer has an EOR-boundary.
      410     2550                   */
      411     2551    2              NODE_DESC.EOR = %FALSE;

   2551  0 000100   000031 236000 xsym               LDQ     B_VECTNIL+25
         0 000101   000005 356100                    ANSQ    5,,PR0

      412     2552    2              END;

   2552  0 000102   000167 710000 0                  TRA     s:2576

      413     2553    2           ELSE IF NEW_LENGTH > OLD_LENGTH THEN DO;

   2553  0 000103   000167 604400 0                  TMOZ    s:2576

      414     2554                      /*  We extended the record:  fill in with $PAD value */
      415     2555    2                 IF SUBSTR(VD_$PAD.BYTES, 0, VD_$PAD.LENGTH#) =

   2555  0 000104   000002 220000 xsym               LDX0    VD_$PAD+2
         0 000105   040000 106440                    CMPC    fill='040'O
         0 000106   000002 400010 xsym               ADSC9   VD_$PAD+2                cn=2,n=*X0
         0 000107   000035 000001 xsym               ADSC9   B_VECTNIL+29             cn=0,n=1
         0 000110   000132 601000 0                  TNZ     s:2566

      416     2556    3                   %CHR_SPACE THEN DO;

      417     2557                         /*
      418     2558                         *    If $PAD is space, we can let INSERT fill for us.
      419     2559                         */
      420     2560    3                    CALL INSERT (DATA$BUFFER.BYTES, OLD_LENGTH, , %CHR_SPACE)

   2560  0 000111   000004 471500                    LDP1    4,,PR0
         0 000112   100002 221100                    LDX1    2,,PR1
         0 000113   000000 636011                    EAQ     0,X1
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:63   
         0 000114   000022 732000                    QRS     18
         0 000115   200005 136100                    SBLQ    OLD_LENGTH,,AUTO
         0 000116   000000 622006                    EAX2    0,QL
         0 000117   200005 235100                    LDA     OLD_LENGTH,,AUTO
         0 000120   040145 100400                    MLR     fill='040'O
         0 000121   000035 000001 xsym               ADSC9   B_VECTNIL+29             cn=0,n=1
         0 000122   100002 400012                    ADSC9   2,A,PR1                  cn=2,n=*X2
         0 000123   000000 116003                    CMPQ    0,DU
         0 000124   000126 604400 0                  TMOZ    s:2562
         0 000125   000131 710000 0                  TRA     s:2564

      421     2561    4                    WHENALTRETURN DO;

      422     2562    4                       CALL VDG$ESCREECH;

   2562  0 000126   000002 631400 xsym               EPPR1   B_VECTNIL+2
         0 000127   000000 701000 xent               TSX1    VDG$ESCREECH
         0 000130   000000 011000                    NOP     0

      423     2563    4                       END;

      424     2564    3                    END;

   2564  0 000131   000167 710000 0                  TRA     s:2576

      425     2565    3                 ELSE DO;

      426     2566    4                    DO I = OLD_LENGTH TO (NEW_LENGTH-1) BY VD_$PAD.LENGTH#;

   2566  0 000132   200005 235100                    LDA     OLD_LENGTH,,AUTO
         0 000133   200011 755100                    STA     I,,AUTO
         0 000134   000163 710000 0                  TRA     s:2572+4

      427     2567    4                       CALL INSERT (DATA$BUFFER.BYTES, I, VD_$PAD.LENGTH#,

   2567  0 000135   200003 470500                    LDP0    @NODE_DESC,,AUTO
         0 000136   000004 471500                    LDP1    4,,PR0
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:64   
         0 000137   100002 220100                    LDX0    2,,PR1
         0 000140   000002 221000 xsym               LDX1    VD_$PAD+2
         0 000141   200011 235100                    LDA     I,,AUTO
         0 000142   040145 100440                    MLR     fill='040'O
         0 000143   000002 400011 xsym               ADSC9   VD_$PAD+2                cn=2,n=*X1
         0 000144   100002 400011                    ADSC9   2,A,PR1                  cn=2,n=*X1
         0 000145   000002 236000 xsym               LDQ     VD_$PAD+2
         0 000146   000022 732000                    QRS     18
         0 000147   000011 402007                    MPY     9,DL
         0 000150   200012 756100                    STQ     I+1,,AUTO
         0 000151   200012 116100                    CMPQ    I+1,,AUTO
         0 000152   000154 604000 0                  TMI     s:2570
         0 000153   000157 710000 0                  TRA     s:2572

      428     2568    4                         SUBSTR(VD_$PAD.BYTES, 0, VD_$PAD.LENGTH#))
      429     2569    5                       WHENALTRETURN DO;

      430     2570    5                          CALL VDG$ESCREECH;

   2570  0 000154   000002 631400 xsym               EPPR1   B_VECTNIL+2
         0 000155   000000 701000 xent               TSX1    VDG$ESCREECH
         0 000156   000000 011000                    NOP     0

      431     2571    5                          END;

      432     2572    4                       END;

   2572  0 000157   000002 236000 xsym               LDQ     VD_$PAD+2
         0 000160   000022 732000                    QRS     18
         0 000161   200011 036100                    ADLQ    I,,AUTO
         0 000162   200011 756100                    STQ     I,,AUTO
         0 000163   200004 470500                    LDP0    @NEW_LENGTH,,AUTO
         0 000164   200011 236100                    LDQ     I,,AUTO
         0 000165   000000 116100                    CMPQ    0,,PR0
         0 000166   000135 604000 0                  TMI     s:2567

      433     2573    3                    END;
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:65   

      434     2574    2                 END;

      435     2575
      436     2576    1           RETURN;

   2576  0 000167   000000 702200 xent               TSX2  ! X66_ARET

   2568  0 000170                       OALLOC_FAIL* null
   2568  0 000170                       OFREE_FAILED null
      437     2577
      438     2578
      439     2579    1   OALLOC_FAILED: ;
      440     2580    1   OFREE_FAILED: ;
      441     2581    1           ALTRETURN;

   2581  0 000170   000000 702200 xent               TSX2  ! X66_AALT
      442     2582
      443     2583    1   END VDE$RADJUST_LENGTH;
      444     2584        %EOD;

PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:66   
--  Include file information  --

   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RADJUST_LENGTH.
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:67   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @NEW_LENGTH                3-0-0/w PTR         r     1 @NODE_DESC
    11-0-0/w SBIN        r     1 I                         10-0-0/w PTR         r     1 NEW_BUFFER$
    *0-0-0/w SBIN        r     1 NEW_LENGTH                 7-0-0/w SBIN        r     1 NEW_OBJECT_SIZE
    *0-0-0/w STRC(216)   r     1 NODE_DESC                  5-0-0/w SBIN        r     1 OLD_LENGTH
     6-0-0/w SBIN        r     1 OLD_OBJECT_SIZE

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w ASTR(90)    r     1 VD_$PAD

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w ASTR(90)    r     1 DATA$BUFFER                0-0-0/w ASTR(90)    r     1 NEW$BUFFER
     0-0-0/w STRC(90)    r     1 VD$BUFFER_HEADER


   Procedure VDE$RADJUST_LENGTH requires 121 words for executable code.
   Procedure VDE$RADJUST_LENGTH requires 14 words of local(AUTO) storage.
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:68   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:69   
          MINI XREF LISTING

DATA$BUFFER
      2392**DCL      2540<>CALL
DATA$BUFFER.BYTES
      2420**DCL      2539>>ASSIGN   2560<<CALLBLT  2567<<CALLBLT
DATA$BUFFER.LENGTH#
      2418**DCL      2420--IMP-SIZ  2527>>ASSIGN   2539>>ASSIGN   2540>>CALL     2546<<ASSIGN   2560>>CALLBLT
      2567>>CALLBLT
DATA$BUFFER.OBJECT.SIZE#
      2416**DCL      2528>>ASSIGN
I
      2364**DCL      2566<<DOINDEX  2567>>CALLBLT
NEW$BUFFER.BYTES
      2478**DCL      2539<<ASSIGN
NEW$BUFFER.LENGTH#
      2476**DCL      2478--IMP-SIZ  2537<<ASSIGN   2539>>ASSIGN
NEW_BUFFER$
      2363**DCL      2450--IMP-PTR  2535<>CALL     2537>>ASSIGN   2539>>ASSIGN   2539>>ASSIGN   2543>>ASSIGN
NEW_LENGTH
      2288**DCL        27--PROC     2531>>ASSIGN   2546>>ASSIGN   2547>>IF       2553>>IF       2566>>DOINDEX
NEW_OBJECT_SIZE
      2362**DCL      2531<<ASSIGN   2534>>IF       2535<>CALL
NODE_DESC
      2254**DCL        27--PROC
NODE_DESC.DATA$
      2286**DCL      2392--IMP-PTR  2522>>IF       2527>>ASSIGN   2528>>ASSIGN   2538>>IF       2539>>ASSIGN
      2539>>ASSIGN   2540>>CALL     2540>>CALL     2543<<ASSIGN   2546>>ASSIGN   2560>>CALLBLT  2560>>CALLBLT
      2567>>CALLBLT  2567>>CALLBLT
NODE_DESC.EOR
      2286**DCL      2551<<ASSIGN
OALLOC_FAILED
      2568**LABEL    2535--CALLALT
OFREE_FAILED
PL6.E3A0      #003=VDE$RADJUST_LENGTH File=VDE$RECORDS.:VDA5TSI                  FRI 07/04/97 11:16 Page:70   
      2568**LABEL    2540--CALLALT
OLD_LENGTH
      2360**DCL      2523<<ASSIGN   2527<<ASSIGN   2537>>ASSIGN   2547>>IF       2553>>IF       2560>>CALLBLT
      2566>>DOINDEX
OLD_OBJECT_SIZE
      2361**DCL      2524<<ASSIGN   2528<<ASSIGN   2534>>IF
VD$BUFFER_HEADER
      2491**DCL      2531--ASSIGN
VDG$ESCREECH
      2293**DCL-ENT  2562--CALL     2570--CALL
VDG$OALLOC
      2291**DCL-ENT  2535--CALL
VDG$OFREE
      2292**DCL-ENT  2540--CALL
VD_$PAD.BYTES
      2350**DCL      2555>>IF       2567>>CALLBLT
VD_$PAD.LENGTH#
      2348**DCL      2350--IMP-SIZ  2555>>IF       2555>>IF       2566>>DOINDEX  2567>>CALLBLT  2567>>CALLBLT
      2567>>CALLBLT

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:71   
      445        1        /*T***********************************************************/
      446        2        /*T*                                                         */
      447        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      448        4        /*T*                                                         */
      449        5        /*T***********************************************************/
      450        6
      451        7        /*D*  NAME: VDE$RPUT
      452        8            PARAMETERS:
      453        9                STREAM - VD$STREAM to write record thru.  It's position at
      454       10                    entry is irrelevant.
      455       11                RANGE - VD$RANGE specifying the enclosing range.  Usually
      456       12                    this is the range of the EditBlock; VDE$RPUT will
      457       13                    guarantee that the record is written within this range.
      458       14                OPTIONS - VD$ACCESS_OPTIONS for use when writing to STREAM.
      459       15        *N*         Someday, will use OPTIONS.COMPONENT#.  For now ...
      460       16                    Uses OPTIONS.KEY_INCR and .LEVEL#.
      461       17                NODE_DESC - VD$NODE_DESC containing record to write.  If you
      462       18                    don't want to change/write a component, omit it from
      463       19                    NODE_DESC (ie, to omit Spec, pass NODE_DESC.SPEC = %CLEAR;
      464       20                    to omit Data, pass NODE_DESC.DATA$ = ADDR(NIL)).
      465       21                    NODE_DESC.KEY must always be passed.
      466       22                SEQUENCE - An %SQ_ value, specifying if/how to generate a
      467       23                    new record key for the record:
      468       24                    %SQ_PREVIOUS - Generate a key which sorts before
      469       25                        NODE_DESC.KEY.
      470       26                    %SQ_CURRENT - Don't generate a new key:  use NODE_DESC.KEY.
      471       27                    %SQ_NEXT - Generate a key which sorts after NODE_DESC.KEY.
      472       28                EXISTING_KEY - Optional VD$KEY containing the next existing
      473       29                    key in the direction specified by SEQUENCE.  Only needed
      474       30                    if SEQUENCE ~= %SQ_CURRENT.  The new key is guaranteed
      475       31                    to be between NODE_DESC.KEY and EXISTING_KEY or
      476       32                    RANGE.START/ENDD, whichever is closer to NODE_DESC.KEY.
      477       33                    If there are no records between NODE_DESC.KEY and the
      478       34                    RANGE bound, EXISTING_KEY should be %CLEAR.
      479       35            INPUT:
      480       36                None.
      481       37            OUTPUT:
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:72   
      482       38                Upon normal return, NODE_DESC.SPEC will be %CLEARed and .DATA$ will
      483       39                    be NIL'd, 'cause we've passed the record to the Accessor, who
      484       40                    now "owns" it and will free it when it's good and ready.
      485       41                    Upon alternate return, NODE_DESC.SPEC and .DATA$ will be
      486       42                    untouched:  the caller still owns any dynamic storage they
      487       43                    refer to.
      488       44                NODE_DESC.KEY - If we generate a key (SEQUENCE ~= %SQ_CURRENT),
      489       45                    NODE_DESC.KEY will be modified to contain the key at
      490       46                    which the record was actually written.  (If the key is
      491       47                    remote, the old VD$TEXTC_REMOTE will be freed.)
      492       48            DESCRIPTION:
      493       49                If we need to generate a key (SEQUENCE ~= %SQ_CURRENT):
      494       50                    First, find the limiting key for key generation:  the key
      495       51                    which is closest to NODE_DESC.KEY.  Candidates are
      496       52                    EXISTING_KEY and either RANGE.START (for SQ_PREVIOUS) or
      497       53                    RANGE.ENDD (for SQ_NEXT).  Note that the RANGE location
      498       54                    can be %CLEAR, indicating BOF, or may have .EOF set.  Also,
      499       55                    EXISTING_KEY may be %CLEAR, indicating BOF for SQ_PREVIOUS
      500       56                    and EOF for SQ_NEXT.  The effect of EXISTING_KEY being
      501       57                    %CLEAR is to always use the appropriate RANGE location
      502       58                    as the limiting key.  This results in the following
      503       59                    decision matrices for determining the limiting key to
      504       60                    pass to GENERATE_KEY:
      505       61
      506       62                    For SQ_PREVIOUS:
      507       63                                                  RANGE.START
      508       64                                             ----------------------------
      509       65                                             %CLEAR
      510       66                                              (bof)     .EOF  otherwise
      511       67                                             ---------  ----  -----------
      512       68                    EXISTING | %CLEAR (bof):   mn        mx   RANGE.START
      513       69                      KEY    |
      514       70                             | otherwise   : EXISTING    mx   greater
      515       71
      516       72
      517       73                    For SQ_NEXT:
      518       74                                                  RANGE.ENDD
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:73   
      519       75                                             -----------------------------
      520       76                                             %CLEAR
      521       77                                              (bof)    .EOF     otherwise
      522       78                                             ------  ---------  ----------
      523       79                    EXISTING | %CLEAR (eof):   mn       mx      RANGE.ENDD
      524       80                      KEY    |
      525       81                             | otherwise   :   mn    EXISTING   lesser
      526       82
      527       83
      528       84                    Legend:
      529       85                        mn - Minimum possible key.  For numeric keys, this is
      530       86                            27 bits of 0; for string keys, this is a
      531       87                            zero-length key.
      532       88                        mx - Maximum possible key.  For numeric keys, this is
      533       89                            27 bits of 1; for string keys, this is 255 bytes
      534       90                            of '777'O.
      535       91                        RANGE.xxxx - The limiting key is the RANGE location.
      536       92                        EXISTING - The limiting key is EXISTING_KEY.
      537       93                        greater - The limiting key is the greater of
      538       94                            the RANGE location and EXISTING_KEY.
      539       95                        lesser - The limiting key is the lesser of the
      540       96                            RANGE location and EXISTING_KEY.
      541       97
      542       98
      543       99                    Call GENERATE_KEY to generate the new key.
      544      100                Write the NODE_DESC components using the generated or passed
      545      101                    key.
      546      102        */
      547      103
      548      104        VDE$RPUT: PROC (STREAM, RANGE, OPTIONS, NODE_DESC, SEQUENCE,
      549      105                  EXISTING_KEY) ALTRET;
      550      106
      551      107        %INCLUDE VD_MACROS_M;
      552     2322        %INCLUDE VD_PERR_C;
      553     2470
      554     2471
      555     2472        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:74   
      556     2578        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
      557     2647        %VD$ACCESS_OPTIONS (NAME=OPTIONS, STCLASS=PARAM);
      558     2676        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
      559     2718    1   DCL SEQUENCE SBIN;
      560     2719        %VD$KEY_NUMBER (NAME=EXISTING_KEY, STCLASS=PARAM);
      561     2734
      562     2735
      563     2736    1   DCL VDA$LWRITE          ENTRY (4) ALTRET;
      564     2737    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      565     2738    1   DCL VDG$ERRMSG          ENTRY (4) ALTRET;
      566     2739    1   DCL VDG$ESCREECH        ENTRY (3);
      567     2740    1   DCL VDG$MEVAL_RPUT      ENTRY (4);
      568     2741    1   DCL VDG$MEVAL_RPUT_EXISTING_KEY ENTRY (2);
      569     2742    1   DCL VDG$MEVAL_RPUT_RETURN ENTRY (2);
      570     2743
      571     2744
      572     2745        %VD$KEY (NAME=VD_KEY_NUMERIC_BOF, STCLASS=SYMREF);
      573     2759        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
      574     2804
      575     2805
      576     2806
      577     2807
      578     2808
      579     2809    1   DCL 1 LIMIT,
      580     2810    1         2 BYTES# UBIN;
      581     2811    1   DCL RANGE_KEY$ PTR;
      582     2812    1   DCL NODE_KEY$ PTR;
      583     2813        %VD$LOCATION (NAME=LOCATION, STCLASS=AUTO);
      584     2841    1   DCL SPEC$ PTR;
      585     2842
      586     2843
      587     2844
      588     2845        %VD$TEXTC_NUMBER (NAME=RANGE$KEY_NUMBER, STCLASS="BASED(RANGE_KEY$)");
      589     2859        %VD$TEXTC (NAME=RANGE$KEY, STCLASS="BASED(RANGE_KEY$)");
      590     2882        %VD$TEXTC (NAME=NODE$KEY, STCLASS="BASED(NODE_KEY$)");
      591     2905        %VD$TEXTC_NUMBER (NAME=NODE$KEY_NUMBER, STCLASS="BASED(NODE_KEY$)");
      592     2919        %VD$SPEC (NAME=SPEC, STCLASS="BASED(SPEC$)");
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:75   
      593     2933        %VD$BUFFER (NAME=DATA$BUFFER, STCLASS="BASED(NODE_DESC.DATA$)");
      594     2991        %VD$TEXTC_REMOTE;
      595     3052
      596     3053
      597     3054
      598     3055    1           IF VD_$$MON_EVAL.V# > 0 THEN
      599     3056    1              CALL VDG$MEVAL_RPUT (STREAM, RANGE, NODE_DESC, SEQUENCE);
      600     3057
      601     3058    1           IF ADDR(EXISTING_KEY) ~= ADDR(NIL)
      602     3059    1             AND VD_$$MON_EVAL.V# > 0 THEN
      603     3060    1              CALL VDG$MEVAL_RPUT_EXISTING_KEY (STREAM, EXISTING_KEY);
      604     3061
      605     3062    1           IF NODE_DESC.KEY = %CLEAR THEN
      606     3063    1              NODE_DESC.KEY = VD_KEY_NUMERIC_BOF;
      607     3064                %GETKEY (KEY=NODE_DESC.KEY, PTR=NODE_KEY$);
      608     3074
      609     3075
      610     3076    2           DO CASE (SEQUENCE);
      611     3077    2            CASE (%SQ_CURRENT);
      612     3078    2              IF RANGE.START.EOF THEN
      613     3079    2                 GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      614     3080                   %GETKEY (KEY=RANGE.START.KEY, INDX=OPTIONS.LEVEL#-1, PTR=RANGE_KEY$);
      615     3090    2              IF NODE$KEY.BYTES < RANGE$KEY.BYTES THEN
      616     3091    2                 GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      617     3092
      618     3093    3              IF RANGE.ENDD.EOF THEN DO;
      619     3094    3                 IF NODE$KEY_NUMBER.BYTES# >= %MX_EDITKEY THEN
      620     3095    3                    GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      621     3096    3                 END;
      622     3097    3              ELSE DO;
      623     3098                      %GETKEY (KEY=RANGE.ENDD.KEY, INDX=OPTIONS.LEVEL#-1,
      624     3099                      PTR=RANGE_KEY$);
      625     3109    3                 IF NODE$KEY.BYTES > RANGE$KEY.BYTES
      626     3110    3                   OR NODE$KEY.BYTES = RANGE$KEY.BYTES
      627     3111    3                   AND RANGE.ENDD.POSITION# = 0 THEN
      628     3112    3                    GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      629     3113    3                 END;
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:76   
      630     3114
      631     3115
      632     3116    2            CASE (%SQ_PREVIOUS);
      633     3117
      634     3118                   /* Assume EXISTING_KEY is closer */
      635     3119    2              LIMIT.BYTES# = EXISTING_KEY.BYTES#;
      636     3120
      637     3121    2              IF RANGE.START.EOF THEN
      638     3122    2                 LIMIT.BYTES# = %MX_EDITKEY;
      639     3123    3              ELSE IF RANGE.START = %CLEAR THEN DO; /* BOF */
      640     3124    3                    IF EXISTING_KEY = %CLEAR THEN
      641     3125    3                       LIMIT.BYTES# = %MN_EDITKEY;
      642     3126    3                    END;
      643     3127    3                 ELSE DO;
      644     3128                         %GETKEY (KEY=RANGE.START.KEY, INDX=OPTIONS.LEVEL#-1,
      645     3129                         PTR=RANGE_KEY$);
      646     3139    3                    IF EXISTING_KEY = %CLEAR
      647     3140    3                      OR RANGE$KEY_NUMBER.BYTES# > LIMIT.BYTES# THEN
      648     3141    3                       LIMIT.BYTES# = RANGE$KEY_NUMBER.BYTES#;
      649     3142    3                    END;
      650     3143
      651     3144    2              CALL GENERATE_KEY (NODE$KEY)
      652     3145    2                ALTRET (GENERATE_KEY_FAILED);
      653     3146
      654     3147
      655     3148    2            CASE (%SQ_NEXT);
      656     3149
      657     3150                   /* Assume EXISTING_KEY is closer */
      658     3151    2              LIMIT.BYTES# = EXISTING_KEY.BYTES#;
      659     3152
      660     3153    2              IF RANGE.ENDD = %CLEAR THEN /* BOF */
      661     3154    2                 LIMIT.BYTES# = %MN_EDITKEY;
      662     3155    3              ELSE IF RANGE.ENDD.EOF THEN DO;
      663     3156    3                    IF EXISTING_KEY = %CLEAR THEN /* EOF */
      664     3157    3                       LIMIT.BYTES# = %MX_EDITKEY;
      665     3158    3                    END;
      666     3159    3                 ELSE DO;
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:77   
      667     3160                         %GETKEY (KEY=RANGE.ENDD.KEY, INDX=OPTIONS.LEVEL#-1,
      668     3161                         PTR=RANGE_KEY$);
      669     3171    3                    IF EXISTING_KEY = %CLEAR
      670     3172    3                      OR RANGE$KEY_NUMBER.BYTES# < LIMIT.BYTES# THEN
      671     3173    3                       LIMIT.BYTES# = RANGE$KEY_NUMBER.BYTES#;
      672     3174    3                    END;
      673     3175
      674     3176    2              CALL GENERATE_KEY (NODE$KEY)
      675     3177    2                ALTRET (GENERATE_KEY_FAILED);
      676     3178
      677     3179
      678     3180    2            CASE (ELSE);
      679     3181    2              CALL VDG$ESCREECH (SEQUENCE);
      680     3182    2            END;
      681     3183
      682     3184    1           LOCATION = RANGE.START;
      683     3185    1           LOCATION.KEY (OPTIONS.LEVEL# - 1) = NODE_DESC.KEY;
      684     3186    1           IF NODE_DESC.SPEC = %CLEAR THEN
      685     3187    1              SPEC$ = ADDR(NIL);
      686     3188    1           ELSE
      687     3189    1              SPEC$ = ADDR(NODE_DESC.SPEC);
      688     3190    1           CALL VDA$LWRITE (STREAM, LOCATION, SPEC, DATA$BUFFER)
      689     3191    1             ALTRET (LWRITE_FAILED);
      690     3192
      691     3193                /*
      692     3194                *   Clear NODE_DESC.SPEC and DATA$ since the Accessor now owns them.
      693     3195                */
      694     3196
      695     3197    1           NODE_DESC.SPEC = %CLEAR;
      696     3198    1           NODE_DESC.DATA$ = ADDR(NIL);
      697     3199
      698     3200    1           IF VD_$$MON_EVAL.V# > 0 THEN
      699     3201    1              CALL VDG$MEVAL_RPUT_RETURN (STREAM, NODE_DESC.KEY);
      700     3202
      701     3203    1           RETURN;
      702     3204
      703     3205
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:78   
      704     3206    1   CURRENT_OUTSIDE_RANGE_FAILURE:
      705     3207    1           CALL VDG$ERRMSG (%E$CUTOFF);
      706     3208
      707     3209
      708     3210    1   GENERATE_KEY_FAILED: ;
      709     3211    1   LWRITE_FAILED: ;
      710     3212    1   OALLOC_FAILED: ;
      711     3213    1           ALTRETURN;
      712     3214
      713     3215        /*D* NAME:  GENERATE_KEY
      714     3216            PARAMETERS:
      715     3217                KEY - VD$TEXTC containing the starting key.
      716     3218                LIMIT - VD$TEXTC containing the limit key.
      717     3219            INPUT:
      718     3220                STREAM - VD$STREAM which is open to the file we're generating
      719     3221                    keys for.  File must have numeric keys; the file's
      720     3222                    org must be %ORG_KEYED or %ORG_CONSEC.  If %ORG_CONSEC,
      721     3223                    SEQUENCE must be %SQ_NEXT and LIMIT_KEY.BYTES# must be
      722     3224                    %MX_EDITKEY (indicating generating a new key at eof).
      723     3225                SEQUENCE - %SQ_ value specifying whether to generate a new key
      724     3226                    which sorts before KEY or after KEY.
      725     3227                OPTIONS - VD$ACCESS_OPTIONS for the block.
      726     3228                    If .KEY_INCR's value is 0, we'll use VD_$BY instead.
      727     3229                VD_$BY - VD$NUMBER containing the current value of the predefined
      728     3230                    name "$BY". If VD_$BY.V# is zero, we'll use a default key
      729     3231                    increment.
      730     3232            OUTPUT:
      731     3233                KEY will be modified:  it will contain the generated key.
      732     3234                If we can't generate a key that fits between KEY and LIMIT,
      733     3235                    we'll ALTRETURN.
      734     3236            DESCRIPTION:
      735     3237                Make sure we can generate keys for this file.
      736     3238                If so, generate the key.  How to do this depends on the file's
      737     3239                organization:
      738     3240                For CONSEC files, the key increment is always 1, and the LIMIT
      739     3241                    is always the maximum legal consecutive key.  Add 1 to
      740     3242                    KEY and make sure it's still legal.
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:79   
      741     3243                For KEYED files, use OPTIONS.KEY_INCR, or if
      742     3244                    that's zero use VD_$BY, or if that's zero, use a standard
      743     3245                    default.
      744     3246                    Based on SEQUENCE, either add or subtract the increment
      745     3247                    to/from KEY to get next key. Test to see if
      746     3248                    the value is still between KEY and LIMIT.
      747     3249                    If not, then divide the increment by 10 to get a new
      748     3250                    increment, and try again.  Keep dividing the increment
      749     3251                    by 10 until it's small enough.  If we can't get the
      750     3252                    increment small enough to fit between KEY and LIMIT,
      751     3253                    ALTRETURN.
      752     3254        */
      753     3255
      754     3256    1   GENERATE_KEY: PROC (KEY) ALTRET;
      755     3257
      756     3258    2   DCL 1 KEY ALIGNED,
      757     3259    2         2 LENGTH# UBIN BYTE CALIGNED,
      758     3260    2         2 BYTES# UBIN(27) CALIGNED;
      759     3261
      760     3262
      761     3263        %VD$NUMBER (NAME=VD_$BY, STCLASS=SYMREF);
      762     3308
      763     3309
      764     3310    2   DCL INCR_FLOORS (0:7) UBIN CONSTANT     /* 0 marks end of table */
      765     3311    2       INIT(1000000, 100000, 10000, 1000, 100, 10, 1, 0);
      766     3312
      767     3313
      768     3314    2   DCL INCR UBIN;
      769     3315    2   DCL I UBIN;
      770     3316
      771     3317
      772     3318        %VD$KEY_NUMBER;
      773     3333        %VD$PORT;
      774     3431
      775     3432
      776     3433
      777     3434    2   KT_CASES:
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:80   
      778     3435    3           DO CASE (STREAM.PORT$->VD$PORT.LEVEL.KEY_TYPE# (OPTIONS.LEVEL#));
      779     3436    3            CASE (%KT_NUMBER);
      780     3437    3              IF SEQUENCE ~= %SQ_NEXT
      781     3438    3                OR LIMIT.BYTES# ~= %MX_EDITKEY THEN
      782     3439    3                 GOTO GENKEY_CONFLICTS_W_ORGKT;
      783     3440    3              IF KEY.BYTES# + 1 > %MX_CONSEC_RECORDS THEN
      784     3441    3                 GOTO CONSEC_PAST_LIMIT;
      785     3442    3              KEY.BYTES# = KEY.BYTES# + 1;
      786     3443
      787     3444
      788     3445    3            CASE (%KT_EDITKEY);
      789     3446    3              INCR = ADDR(OPTIONS.KEY_INCR)->VD$KEY_NUMBER.BYTES#;
      790     3447    4              IF INCR = 0 THEN DO;
      791     3448    4                 INCR = VD_$BY.V#;
      792     3449    4                 IF INCR = 0 THEN
      793     3450    4                    INCR = %DFLT_$BY;
      794     3451    4                 END;
      795     3452
      796     3453    3              I = 0;
      797     3454
      798     3455    3   KEYED_SEQUENCE_CASES:
      799     3456    4              DO CASE (SEQUENCE);
      800     3457    4               CASE (%SQ_PREVIOUS);
      801     3458    5                 DO WHILE INCR > 0
      802     3459    5                   AND KEY.BYTES# - INCR <= LIMIT.BYTES#;
      803     3460    5                    INCR = INCR_FLOORS (I);
      804     3461    5                    I = I + 1;
      805     3462    5                    END;
      806     3463    4                 KEY.BYTES# = KEY.BYTES# - INCR;
      807     3464
      808     3465    4               CASE (%SQ_NEXT);
      809     3466    5                 DO WHILE INCR > 0
      810     3467    5                   AND KEY.BYTES# + INCR >= LIMIT.BYTES#;
      811     3468    5                    INCR = INCR_FLOORS (I);
      812     3469    5                    I = I + 1;
      813     3470    5                    END;
      814     3471    4                 KEY.BYTES# = KEY.BYTES# + INCR;
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:81   
      815     3472
      816     3473    4               CASE (ELSE);
      817     3474    4                 CALL VDG$ESCREECH (SEQUENCE);
      818     3475    4               END KEYED_SEQUENCE_CASES;
      819     3476
      820     3477    3              IF INCR = 0 THEN
      821     3478    3                 GOTO KEYED_PAST_LIMIT;
      822     3479
      823     3480
      824     3481    3            CASE (ELSE);
      825     3482    3              GOTO GENKEY_CONFLICTS_W_ORGKT;
      826     3483    3            END KT_CASES;
      827     3484
      828     3485    2           RETURN;
      829     3486
      830     3487
      831     3488    2   GENKEY_CONFLICTS_W_ORGKT:
      832     3489    2           CALL VDG$ERRMSG (%E$GENKEY_CONFLICTS_W_ORGKT);
      833     3490    2           ALTRETURN;
      834     3491
      835     3492
      836     3493    2   CONSEC_PAST_LIMIT: ;
      837     3494    2   KEYED_PAST_LIMIT: ;
      838     3495    2           CALL VDG$ERRMSG (%E$CUTOFF);
      839     3496
      840     3497    2   OALLOC_FAILED: ;
      841     3498    2           ALTRETURN;
      842     3499
      843     3500    2   END GENERATE_KEY;
      844     3501
      845     3502    1   END VDE$RPUT;

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:82   
--  Include file information  --

   VD_PERR_C.:VDA5TOU  is referenced.
   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RPUT.

   Procedure VDE$RPUT requires 415 words for executable code.
   Procedure VDE$RPUT requires 30 words of local(AUTO) storage.

    No errors detected in file VDE$RECORDS.:VDA5TSI    .

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:83   

 Object Unit name= VDE$RPUT                                   File name= VDE$RECORDS.:VDA5TOU
 UTS= JUL 04 '97 11:17:02.80 FRI                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0  RoData even  UTS      8     10  VDE$RPUT
    1   Proc  even  none   415    637  VDE$RPUT
    2  RoData even  none     6      6  VDE$RPUT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes    yes     yes      Std        6  VDE$RPUT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       4 VDG$MEVAL_RPUT
         yes           Std       2 VDG$MEVAL_RPUT_EXISTING_KEY
 yes     yes           Std       4 VDA$LWRITE
         yes           Std       3 VDG$ESCREECH
 yes     yes           Std       4 VDG$ERRMSG
         yes           Std       2 VDG$MEVAL_RPUT_RETURN
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:84   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     VD_KEY_NUMERIC_BOF                    VD_$$MON_EVAL                         VD_$BY
     B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:85   


      445        1        /*T***********************************************************/
      446        2        /*T*                                                         */
      447        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      448        4        /*T*                                                         */
      449        5        /*T***********************************************************/
      450        6
      451        7        /*D*  NAME: VDE$RPUT
      452        8            PARAMETERS:
      453        9                STREAM - VD$STREAM to write record thru.  It's position at
      454       10                    entry is irrelevant.
      455       11                RANGE - VD$RANGE specifying the enclosing range.  Usually
      456       12                    this is the range of the EditBlock; VDE$RPUT will
      457       13                    guarantee that the record is written within this range.
      458       14                OPTIONS - VD$ACCESS_OPTIONS for use when writing to STREAM.
      459       15        *N*         Someday, will use OPTIONS.COMPONENT#.  For now ...
      460       16                    Uses OPTIONS.KEY_INCR and .LEVEL#.
      461       17                NODE_DESC - VD$NODE_DESC containing record to write.  If you
      462       18                    don't want to change/write a component, omit it from
      463       19                    NODE_DESC (ie, to omit Spec, pass NODE_DESC.SPEC = %CLEAR;
      464       20                    to omit Data, pass NODE_DESC.DATA$ = ADDR(NIL)).
      465       21                    NODE_DESC.KEY must always be passed.
      466       22                SEQUENCE - An %SQ_ value, specifying if/how to generate a
      467       23                    new record key for the record:
      468       24                    %SQ_PREVIOUS - Generate a key which sorts before
      469       25                        NODE_DESC.KEY.
      470       26                    %SQ_CURRENT - Don't generate a new key:  use NODE_DESC.KEY.
      471       27                    %SQ_NEXT - Generate a key which sorts after NODE_DESC.KEY.
      472       28                EXISTING_KEY - Optional VD$KEY containing the next existing
      473       29                    key in the direction specified by SEQUENCE.  Only needed
      474       30                    if SEQUENCE ~= %SQ_CURRENT.  The new key is guaranteed
      475       31                    to be between NODE_DESC.KEY and EXISTING_KEY or
      476       32                    RANGE.START/ENDD, whichever is closer to NODE_DESC.KEY.
      477       33                    If there are no records between NODE_DESC.KEY and the
      478       34                    RANGE bound, EXISTING_KEY should be %CLEAR.
      479       35            INPUT:
      480       36                None.
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:86   
      481       37            OUTPUT:
      482       38                Upon normal return, NODE_DESC.SPEC will be %CLEARed and .DATA$ will
      483       39                    be NIL'd, 'cause we've passed the record to the Accessor, who
      484       40                    now "owns" it and will free it when it's good and ready.
      485       41                    Upon alternate return, NODE_DESC.SPEC and .DATA$ will be
      486       42                    untouched:  the caller still owns any dynamic storage they
      487       43                    refer to.
      488       44                NODE_DESC.KEY - If we generate a key (SEQUENCE ~= %SQ_CURRENT),
      489       45                    NODE_DESC.KEY will be modified to contain the key at
      490       46                    which the record was actually written.  (If the key is
      491       47                    remote, the old VD$TEXTC_REMOTE will be freed.)
      492       48            DESCRIPTION:
      493       49                If we need to generate a key (SEQUENCE ~= %SQ_CURRENT):
      494       50                    First, find the limiting key for key generation:  the key
      495       51                    which is closest to NODE_DESC.KEY.  Candidates are
      496       52                    EXISTING_KEY and either RANGE.START (for SQ_PREVIOUS) or
      497       53                    RANGE.ENDD (for SQ_NEXT).  Note that the RANGE location
      498       54                    can be %CLEAR, indicating BOF, or may have .EOF set.  Also,
      499       55                    EXISTING_KEY may be %CLEAR, indicating BOF for SQ_PREVIOUS
      500       56                    and EOF for SQ_NEXT.  The effect of EXISTING_KEY being
      501       57                    %CLEAR is to always use the appropriate RANGE location
      502       58                    as the limiting key.  This results in the following
      503       59                    decision matrices for determining the limiting key to
      504       60                    pass to GENERATE_KEY:
      505       61
      506       62                    For SQ_PREVIOUS:
      507       63                                                  RANGE.START
      508       64                                             ----------------------------
      509       65                                             %CLEAR
      510       66                                              (bof)     .EOF  otherwise
      511       67                                             ---------  ----  -----------
      512       68                    EXISTING | %CLEAR (bof):   mn        mx   RANGE.START
      513       69                      KEY    |
      514       70                             | otherwise   : EXISTING    mx   greater
      515       71
      516       72
      517       73                    For SQ_NEXT:
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:87   
      518       74                                                  RANGE.ENDD
      519       75                                             -----------------------------
      520       76                                             %CLEAR
      521       77                                              (bof)    .EOF     otherwise
      522       78                                             ------  ---------  ----------
      523       79                    EXISTING | %CLEAR (eof):   mn       mx      RANGE.ENDD
      524       80                      KEY    |
      525       81                             | otherwise   :   mn    EXISTING   lesser
      526       82
      527       83
      528       84                    Legend:
      529       85                        mn - Minimum possible key.  For numeric keys, this is
      530       86                            27 bits of 0; for string keys, this is a
      531       87                            zero-length key.
      532       88                        mx - Maximum possible key.  For numeric keys, this is
      533       89                            27 bits of 1; for string keys, this is 255 bytes
      534       90                            of '777'O.
      535       91                        RANGE.xxxx - The limiting key is the RANGE location.
      536       92                        EXISTING - The limiting key is EXISTING_KEY.
      537       93                        greater - The limiting key is the greater of
      538       94                            the RANGE location and EXISTING_KEY.
      539       95                        lesser - The limiting key is the lesser of the
      540       96                            RANGE location and EXISTING_KEY.
      541       97
      542       98
      543       99                    Call GENERATE_KEY to generate the new key.
      544      100                Write the NODE_DESC components using the generated or passed
      545      101                    key.
      546      102        */
      547      103
      548      104        VDE$RPUT: PROC (STREAM, RANGE, OPTIONS, NODE_DESC, SEQUENCE,

    104  1 000000   000000 700200 xent  VDE$RPUT     TSX0  ! X66_AUTO_N
         1 000001   000036 000006                    ZERO    30,6

      549      105                  EXISTING_KEY) ALTRET;
      550      106
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:88   
      551      107        %INCLUDE VD_MACROS_M;
      552     2322        %INCLUDE VD_PERR_C;
      553     2470
      554     2471
      555     2472        %VD$STREAM (NAME=STREAM, STCLASS=PARAM);
      556     2578        %VD$RANGE (NAME=RANGE, STCLASS=PARAM);
      557     2647        %VD$ACCESS_OPTIONS (NAME=OPTIONS, STCLASS=PARAM);
      558     2676        %VD$NODE_DESC (NAME=NODE_DESC, STCLASS=PARAM);
      559     2718    1   DCL SEQUENCE SBIN;
      560     2719        %VD$KEY_NUMBER (NAME=EXISTING_KEY, STCLASS=PARAM);
      561     2734
      562     2735
      563     2736    1   DCL VDA$LWRITE          ENTRY (4) ALTRET;
      564     2737    1   DCL VDG$OALLOC          ENTRY (3) ALTRET;
      565     2738    1   DCL VDG$ERRMSG          ENTRY (4) ALTRET;
      566     2739    1   DCL VDG$ESCREECH        ENTRY (3);
      567     2740    1   DCL VDG$MEVAL_RPUT      ENTRY (4);
      568     2741    1   DCL VDG$MEVAL_RPUT_EXISTING_KEY ENTRY (2);
      569     2742    1   DCL VDG$MEVAL_RPUT_RETURN ENTRY (2);
      570     2743
      571     2744
      572     2745        %VD$KEY (NAME=VD_KEY_NUMERIC_BOF, STCLASS=SYMREF);
      573     2759        %VD$NUMBER (NAME=VD_$$MON_EVAL, STCLASS=SYMREF);
      574     2804
      575     2805
      576     2806
      577     2807
      578     2808
      579     2809    1   DCL 1 LIMIT,
      580     2810    1         2 BYTES# UBIN;
      581     2811    1   DCL RANGE_KEY$ PTR;
      582     2812    1   DCL NODE_KEY$ PTR;
      583     2813        %VD$LOCATION (NAME=LOCATION, STCLASS=AUTO);
      584     2841    1   DCL SPEC$ PTR;
      585     2842
      586     2843
      587     2844
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:89   
      588     2845        %VD$TEXTC_NUMBER (NAME=RANGE$KEY_NUMBER, STCLASS="BASED(RANGE_KEY$)");
      589     2859        %VD$TEXTC (NAME=RANGE$KEY, STCLASS="BASED(RANGE_KEY$)");
      590     2882        %VD$TEXTC (NAME=NODE$KEY, STCLASS="BASED(NODE_KEY$)");
      591     2905        %VD$TEXTC_NUMBER (NAME=NODE$KEY_NUMBER, STCLASS="BASED(NODE_KEY$)");
      592     2919        %VD$SPEC (NAME=SPEC, STCLASS="BASED(SPEC$)");
      593     2933        %VD$BUFFER (NAME=DATA$BUFFER, STCLASS="BASED(NODE_DESC.DATA$)");
      594     2991        %VD$TEXTC_REMOTE;
      595     3052
      596     3053
      597     3054
      598     3055    1           IF VD_$$MON_EVAL.V# > 0 THEN

   3055  1 000002   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         1 000003   000015 604400 1                  TMOZ    s:3058

      599     3056    1              CALL VDG$MEVAL_RPUT (STREAM, RANGE, NODE_DESC, SEQUENCE);

   3056  1 000004   200006 237100                    LDAQ    @NODE_DESC,,AUTO
         1 000005   200034 757100                    STAQ    I+3,,AUTO
         1 000006   200004 236100                    LDQ     @RANGE,,AUTO
         1 000007   200003 235100                    LDA     @STREAM,,AUTO
         1 000010   200032 757100                    STAQ    I+1,,AUTO
         1 000011   200032 630500                    EPPR0   I+1,,AUTO
         1 000012   000022 631400 xsym               EPPR1   B_VECTNIL+18
         1 000013   000000 701000 xent               TSX1    VDG$MEVAL_RPUT
         1 000014   000000 011000                    NOP     0

      600     3057
      601     3058    1           IF ADDR(EXISTING_KEY) ~= ADDR(NIL)

   3058  1 000015   200010 236100                    LDQ     @EXISTING_KEY,,AUTO
         1 000016   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000017   000030 600000 1                  TZE     s:3062
         1 000020   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         1 000021   000030 604400 1                  TMOZ    s:3062

      602     3059    1             AND VD_$$MON_EVAL.V# > 0 THEN
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:90   
      603     3060    1              CALL VDG$MEVAL_RPUT_EXISTING_KEY (STREAM, EXISTING_KEY);

   3060  1 000022   200003 235100                    LDA     @STREAM,,AUTO
         1 000023   200032 757100                    STAQ    I+1,,AUTO
         1 000024   200032 630500                    EPPR0   I+1,,AUTO
         1 000025   000020 631400 xsym               EPPR1   B_VECTNIL+16
         1 000026   000000 701000 xent               TSX1    VDG$MEVAL_RPUT_EXISTING_KEY
         1 000027   000000 011000                    NOP     0

      604     3061
      605     3062    1           IF NODE_DESC.KEY = %CLEAR THEN

   3062  1 000030   200006 470500                    LDP0    @NODE_DESC,,AUTO
         1 000031   000000 106500                    CMPC    fill='000'O
         1 000032   000000 000010                    ADSC9   0,,PR0                   cn=0,n=8
         1 000033   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000034   000040 601000 1                  TNZ     s:3071

      606     3063    1              NODE_DESC.KEY = VD_KEY_NUMERIC_BOF;

   3063  1 000035   000100 100400                    MLR     fill='000'O
         1 000036   000000 000010 xsym               ADSC9   VD_KEY_NUMERIC_BOF       cn=0,n=8
         1 000037   000000 000010                    ADSC9   0,,PR0                   cn=0,n=8

      607     3064                %GETKEY (KEY=NODE_DESC.KEY, PTR=NODE_KEY$);

   3071  1 000040   000000 720100                    LXL0    0,,PR0
         1 000041   000002 100003                    CMPX0   2,DU
         1 000042   000047 601000 1                  TNZ     s:3071+7

   3071  1 000043   000001 471500                    LDP1    1,,PR0
         1 000044   100002 633500                    EPPR3   2,,PR1
         1 000045   200013 453500                    STP3    NODE_KEY$,,AUTO
         1 000046   000052 710000 1                  TRA     s:3076

   3071  1 000047   200006 236100                    LDQ     @NODE_DESC,,AUTO
         1 000050   000001 036003                    ADLQ    1,DU
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:91   
         1 000051   200013 756100                    STQ     NODE_KEY$,,AUTO

      608     3074
      609     3075
      610     3076    2           DO CASE (SEQUENCE);

   3076  1 000052   200007 471500                    LDP1    @SEQUENCE,,AUTO
         1 000053   100000 235100                    LDA     0,,PR1
         1 000054   000004 115007                    CMPA    4,DL
         1 000055   000057 602005 1                  TNC     s:3076+5,AL
         1 000056   000361 710000 1                  TRA     s:3181
         1 000057   000361 710000 1                  TRA     s:3181
         1 000060   000174 710000 1                  TRA     s:3119
         1 000061   000063 710000 1                  TRA     s:3078
         1 000062   000265 710000 1                  TRA     s:3151

      611     3077    2            CASE (%SQ_CURRENT);

      612     3078    2              IF RANGE.START.EOF THEN

   3078  1 000063   200004 473500                    LDP3    @RANGE,,AUTO
         1 000064   300010 236100                    LDQ     8,,PR3
         1 000065   400000 316007                    CANQ    -131072,DL
         1 000066   000446 601000 1                  TNZ     CURRENT_OUTSIDE_RANGE_FAILURE

      613     3079    2                 GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      614     3080                   %GETKEY (KEY=RANGE.START.KEY, INDX=OPTIONS.LEVEL#-1, PTR=RANGE_KEY$);

   3087  1 000067   200005 474500                    LDP4    @OPTIONS,,AUTO
         1 000070   400001 221100                    LDX1    1,,PR4
         1 000071   400001 021100                    ADLX1   1,,PR4
         1 000072   377776 722111                    LXL2    -2,X1,PR3
         1 000073   000002 102003                    CMPX2   2,DU
         1 000074   000103 601000 1                  TNZ     s:3087+12

   3087  1 000075   400001 221100                    LDX1    1,,PR4
         1 000076   400001 021100                    ADLX1   1,,PR4
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:92   
         1 000077   377777 475511                    LDP5    -1,X1,PR3
         1 000100   500002 636500                    EPPR6   2,,PR5
         1 000101   200012 456500                    STP6    RANGE_KEY$,,AUTO
         1 000102   000110 710000 1                  TRA     s:3090

   3087  1 000103   400001 221100                    LDX1    1,,PR4
         1 000104   400001 021100                    ADLX1   1,,PR4
         1 000105   777777 636011                    EAQ     -1,X1
         1 000106   200004 036100                    ADLQ    @RANGE,,AUTO
         1 000107   200012 756100                    STQ     RANGE_KEY$,,AUTO

      615     3090    2              IF NODE$KEY.BYTES < RANGE$KEY.BYTES THEN

   3090  1 000110   200013 475500                    LDP5    NODE_KEY$,,AUTO
         1 000111   500000 236100                    LDQ     0,,PR5
         1 000112   000033 772000                    QRL     27
         1 000113   200012 476500                    LDP6    RANGE_KEY$,,AUTO
         1 000114   000000 621006                    EAX1    0,QL
         1 000115   600000 236100                    LDQ     0,,PR6
         1 000116   000033 772000                    QRL     27
         1 000117   000000 622006                    EAX2    0,QL
         1 000120   040140 106540                    CMPC    fill='040'O
         1 000121   500000 200011                    ADSC9   0,,PR5                   cn=1,n=*X1
         1 000122   600000 200012                    ADSC9   0,,PR6                   cn=1,n=*X2
         1 000123   000446 602000 1                  TNC     CURRENT_OUTSIDE_RANGE_FAILURE

      616     3091    2                 GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      617     3092
      618     3093    3              IF RANGE.ENDD.EOF THEN DO;

   3093  1 000124   300021 236100                    LDQ     17,,PR3
         1 000125   400000 316007                    CANQ    -131072,DL
         1 000126   000134 600000 1                  TZE     s:3106

      619     3094    3                 IF NODE$KEY_NUMBER.BYTES# >= %MX_EDITKEY THEN

   3094  1 000127   500000 236100                    LDQ     0,,PR5
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:93   
         1 000130   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000131   000000 116000 2                  CMPQ    0
         1 000132   000446 603000 1                  TRC     CURRENT_OUTSIDE_RANGE_FAILURE

      620     3095    3                    GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      621     3096    3                 END;

   3096  1 000133   000365 710000 1                  TRA     s:3184

      622     3097    3              ELSE DO;

      623     3098                      %GETKEY (KEY=RANGE.ENDD.KEY, INDX=OPTIONS.LEVEL#-1,
      624     3099                      PTR=RANGE_KEY$);

   3106  1 000134   400001 236100                    LDQ     1,,PR4
         1 000135   000021 732000                    QRS     17
         1 000136   000001 376000 2                  ANQ     1
         1 000137   300007 723106                    LXL3    7,QL,PR3
         1 000140   000002 103003                    CMPX3   2,DU
         1 000141   000151 601000 1                  TNZ     s:3106+13

   3106  1 000142   400001 236100                    LDQ     1,,PR4
         1 000143   000021 732000                    QRS     17
         1 000144   000001 376000 2                  ANQ     1
         1 000145   300010 477506                    LDP7    8,QL,PR3
         1 000146   700002 630500                    EPPR0   2,,PR7
         1 000147   200012 450500                    STP0    RANGE_KEY$,,AUTO
         1 000150   000160 710000 1                  TRA     s:3109

   3106  1 000151   400001 236100                    LDQ     1,,PR4
         1 000152   000021 732000                    QRS     17
         1 000153   000001 376000 2                  ANQ     1
         1 000154   000022 736000                    QLS     18
         1 000155   000010 036003                    ADLQ    8,DU
         1 000156   200004 036100                    ADLQ    @RANGE,,AUTO
         1 000157   200012 756100                    STQ     RANGE_KEY$,,AUTO

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:94   
      625     3109    3                 IF NODE$KEY.BYTES > RANGE$KEY.BYTES

   3109  1 000160   200012 470500                    LDP0    RANGE_KEY$,,AUTO
         1 000161   000000 236100                    LDQ     0,,PR0
         1 000162   000033 772000                    QRL     27
         1 000163   000000 620006                    EAX0    0,QL
         1 000164   040140 106540                    CMPC    fill='040'O
         1 000165   000000 200010                    ADSC9   0,,PR0                   cn=1,n=*X0
         1 000166   500000 200011                    ADSC9   0,,PR5                   cn=1,n=*X1
         1 000167   000446 602000 1                  TNC     CURRENT_OUTSIDE_RANGE_FAILURE
         1 000170   000173 601000 1                  TNZ     s:3113
         1 000171   300021 222100                    LDX2    17,,PR3
         1 000172   000446 600000 1                  TZE     CURRENT_OUTSIDE_RANGE_FAILURE

      626     3110    3                   OR NODE$KEY.BYTES = RANGE$KEY.BYTES
      627     3111    3                   AND RANGE.ENDD.POSITION# = 0 THEN
      628     3112    3                    GOTO CURRENT_OUTSIDE_RANGE_FAILURE;
      629     3113    3                 END;

   3113  1 000173   000365 710000 1                  TRA     s:3184

      630     3114
      631     3115
      632     3116    2            CASE (%SQ_PREVIOUS);

      633     3117
      634     3118                   /* Assume EXISTING_KEY is closer */
      635     3119    2              LIMIT.BYTES# = EXISTING_KEY.BYTES#;

   3119  1 000174   200010 473500                    LDP3    @EXISTING_KEY,,AUTO
         1 000175   300001 236100                    LDQ     1,,PR3
         1 000176   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000177   200011 756100                    STQ     LIMIT,,AUTO

      636     3120
      637     3121    2              IF RANGE.START.EOF THEN

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:95   
   3121  1 000200   200004 474500                    LDP4    @RANGE,,AUTO
         1 000201   400010 236100                    LDQ     8,,PR4
         1 000202   400000 316007                    CANQ    -131072,DL
         1 000203   000207 600000 1                  TZE     s:3123

      638     3122    2                 LIMIT.BYTES# = %MX_EDITKEY;

   3122  1 000204   000000 235000 2                  LDA     0
         1 000205   200011 755100                    STA     LIMIT,,AUTO
         1 000206   000260 710000 1                  TRA     s:3144

      639     3123    3              ELSE IF RANGE.START = %CLEAR THEN DO; /* BOF */

   3123  1 000207   000000 106500                    CMPC    fill='000'O
         1 000210   400000 000044                    ADSC9   0,,PR4                   cn=0,n=36
         1 000211   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000212   000221 601000 1                  TNZ     s:3136

      640     3124    3                    IF EXISTING_KEY = %CLEAR THEN

   3124  1 000213   000000 106500                    CMPC    fill='000'O
         1 000214   300000 000010                    ADSC9   0,,PR3                   cn=0,n=8
         1 000215   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000216   000260 601000 1                  TNZ     s:3144

      641     3125    3                       LIMIT.BYTES# = %MN_EDITKEY;

   3125  1 000217   200011 450100                    STZ     LIMIT,,AUTO

      642     3126    3                    END;

   3126  1 000220   000260 710000 1                  TRA     s:3144

      643     3127    3                 ELSE DO;

      644     3128                         %GETKEY (KEY=RANGE.START.KEY, INDX=OPTIONS.LEVEL#-1,
      645     3129                         PTR=RANGE_KEY$);
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:96   

   3136  1 000221   200005 475500                    LDP5    @OPTIONS,,AUTO
         1 000222   500001 221100                    LDX1    1,,PR5
         1 000223   500001 021100                    ADLX1   1,,PR5
         1 000224   477776 722111                    LXL2    -2,X1,PR4
         1 000225   000002 102003                    CMPX2   2,DU
         1 000226   000235 601000 1                  TNZ     s:3136+12

   3136  1 000227   500001 221100                    LDX1    1,,PR5
         1 000230   500001 021100                    ADLX1   1,,PR5
         1 000231   477777 476511                    LDP6    -1,X1,PR4
         1 000232   600002 637500                    EPPR7   2,,PR6
         1 000233   200012 457500                    STP7    RANGE_KEY$,,AUTO
         1 000234   000242 710000 1                  TRA     s:3139

   3136  1 000235   500001 221100                    LDX1    1,,PR5
         1 000236   500001 021100                    ADLX1   1,,PR5
         1 000237   777777 636011                    EAQ     -1,X1
         1 000240   200004 036100                    ADLQ    @RANGE,,AUTO
         1 000241   200012 756100                    STQ     RANGE_KEY$,,AUTO

      646     3139    3                    IF EXISTING_KEY = %CLEAR

   3139  1 000242   000000 106500                    CMPC    fill='000'O
         1 000243   300000 000010                    ADSC9   0,,PR3                   cn=0,n=8
         1 000244   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000245   000254 600000 1                  TZE     s:3141
         1 000246   200012 476500                    LDP6    RANGE_KEY$,,AUTO
         1 000247   600000 236100                    LDQ     0,,PR6
         1 000250   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000251   200011 116100                    CMPQ    LIMIT,,AUTO
         1 000252   000260 602000 1                  TNC     s:3144
         1 000253   000260 600000 1                  TZE     s:3144

      647     3140    3                      OR RANGE$KEY_NUMBER.BYTES# > LIMIT.BYTES# THEN
      648     3141    3                       LIMIT.BYTES# = RANGE$KEY_NUMBER.BYTES#;

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:97   
   3141  1 000254   200012 476500                    LDP6    RANGE_KEY$,,AUTO
         1 000255   600000 236100                    LDQ     0,,PR6
         1 000256   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000257   200011 756100                    STQ     LIMIT,,AUTO

      649     3142    3                    END;

      650     3143
      651     3144    2              CALL GENERATE_KEY (NODE$KEY)

   3144  1 000260   200013 236100                    LDQ     NODE_KEY$,,AUTO
         1 000261   200027 756100                    STQ     SPEC$+2,,AUTO
         1 000262   000453 701000 1                  TSX1    GENERATE_KEY
         1 000263   000452 702000 1                  TSX2    GENERATE_KEY_FAILED
         1 000264   000365 710000 1                  TRA     s:3184

      652     3145    2                ALTRET (GENERATE_KEY_FAILED);
      653     3146
      654     3147
      655     3148    2            CASE (%SQ_NEXT);

      656     3149
      657     3150                   /* Assume EXISTING_KEY is closer */
      658     3151    2              LIMIT.BYTES# = EXISTING_KEY.BYTES#;

   3151  1 000265   200010 473500                    LDP3    @EXISTING_KEY,,AUTO
         1 000266   300001 236100                    LDQ     1,,PR3
         1 000267   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000270   200011 756100                    STQ     LIMIT,,AUTO

      659     3152
      660     3153    2              IF RANGE.ENDD = %CLEAR THEN /* BOF */

   3153  1 000271   200004 474500                    LDP4    @RANGE,,AUTO
         1 000272   000000 106500                    CMPC    fill='000'O
         1 000273   400011 000044                    ADSC9   9,,PR4                   cn=0,n=36
         1 000274   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:98   
         1 000275   000300 601000 1                  TNZ     s:3155

      661     3154    2                 LIMIT.BYTES# = %MN_EDITKEY;

   3154  1 000276   200011 450100                    STZ     LIMIT,,AUTO
         1 000277   000354 710000 1                  TRA     s:3176

      662     3155    3              ELSE IF RANGE.ENDD.EOF THEN DO;

   3155  1 000300   400021 236100                    LDQ     17,,PR4
         1 000301   400000 316007                    CANQ    -131072,DL
         1 000302   000312 600000 1                  TZE     s:3168

      663     3156    3                    IF EXISTING_KEY = %CLEAR THEN /* EOF */

   3156  1 000303   000000 106500                    CMPC    fill='000'O
         1 000304   300000 000010                    ADSC9   0,,PR3                   cn=0,n=8
         1 000305   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000306   000354 601000 1                  TNZ     s:3176

      664     3157    3                       LIMIT.BYTES# = %MX_EDITKEY;

   3157  1 000307   000000 235000 2                  LDA     0
         1 000310   200011 755100                    STA     LIMIT,,AUTO

      665     3158    3                    END;

   3158  1 000311   000354 710000 1                  TRA     s:3176

      666     3159    3                 ELSE DO;

      667     3160                         %GETKEY (KEY=RANGE.ENDD.KEY, INDX=OPTIONS.LEVEL#-1,
      668     3161                         PTR=RANGE_KEY$);

   3168  1 000312   200005 475500                    LDP5    @OPTIONS,,AUTO
         1 000313   500001 236100                    LDQ     1,,PR5
         1 000314   000021 732000                    QRS     17
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:99   
         1 000315   000001 376000 2                  ANQ     1
         1 000316   400007 721106                    LXL1    7,QL,PR4
         1 000317   000002 101003                    CMPX1   2,DU
         1 000320   000330 601000 1                  TNZ     s:3168+14

   3168  1 000321   500001 236100                    LDQ     1,,PR5
         1 000322   000021 732000                    QRS     17
         1 000323   000001 376000 2                  ANQ     1
         1 000324   400010 476506                    LDP6    8,QL,PR4
         1 000325   600002 637500                    EPPR7   2,,PR6
         1 000326   200012 457500                    STP7    RANGE_KEY$,,AUTO
         1 000327   000337 710000 1                  TRA     s:3171

   3168  1 000330   500001 236100                    LDQ     1,,PR5
         1 000331   000021 732000                    QRS     17
         1 000332   000001 376000 2                  ANQ     1
         1 000333   000022 736000                    QLS     18
         1 000334   000010 036003                    ADLQ    8,DU
         1 000335   200004 036100                    ADLQ    @RANGE,,AUTO
         1 000336   200012 756100                    STQ     RANGE_KEY$,,AUTO

      669     3171    3                    IF EXISTING_KEY = %CLEAR

   3171  1 000337   000000 106500                    CMPC    fill='000'O
         1 000340   300000 000010                    ADSC9   0,,PR3                   cn=0,n=8
         1 000341   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000342   000350 600000 1                  TZE     s:3173
         1 000343   200012 476500                    LDP6    RANGE_KEY$,,AUTO
         1 000344   600000 236100                    LDQ     0,,PR6
         1 000345   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000346   200011 116100                    CMPQ    LIMIT,,AUTO
         1 000347   000354 603000 1                  TRC     s:3176

      670     3172    3                      OR RANGE$KEY_NUMBER.BYTES# < LIMIT.BYTES# THEN
      671     3173    3                       LIMIT.BYTES# = RANGE$KEY_NUMBER.BYTES#;

   3173  1 000350   200012 476500                    LDP6    RANGE_KEY$,,AUTO
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:100  
         1 000351   600000 236100                    LDQ     0,,PR6
         1 000352   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000353   200011 756100                    STQ     LIMIT,,AUTO

      672     3174    3                    END;

      673     3175
      674     3176    2              CALL GENERATE_KEY (NODE$KEY)

   3176  1 000354   200013 236100                    LDQ     NODE_KEY$,,AUTO
         1 000355   200027 756100                    STQ     SPEC$+2,,AUTO
         1 000356   000453 701000 1                  TSX1    GENERATE_KEY
         1 000357   000452 702000 1                  TSX2    GENERATE_KEY_FAILED
         1 000360   000365 710000 1                  TRA     s:3184

      675     3177    2                ALTRET (GENERATE_KEY_FAILED);
      676     3178
      677     3179
      678     3180    2            CASE (ELSE);

      679     3181    2              CALL VDG$ESCREECH (SEQUENCE);

   3181  1 000361   200007 630500                    EPPR0   @SEQUENCE,,AUTO
         1 000362   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000363   000000 701000 xent               TSX1    VDG$ESCREECH
         1 000364   000000 011000                    NOP     0

      680     3182    2            END;

      681     3183
      682     3184    1           LOCATION = RANGE.START;

   3184  1 000365   200004 470500                    LDP0    @RANGE,,AUTO
         1 000366   000100 100500                    MLR     fill='000'O
         1 000367   000000 000044                    ADSC9   0,,PR0                   cn=0,n=36
         1 000370   200014 000044                    ADSC9   LOCATION,,AUTO           cn=0,n=36

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:101  
      683     3185    1           LOCATION.KEY (OPTIONS.LEVEL# - 1) = NODE_DESC.KEY;

   3185  1 000371   200005 471500                    LDP1    @OPTIONS,,AUTO
         1 000372   100001 236100                    LDQ     1,,PR1
         1 000373   000022 732000                    QRS     18
         1 000374   000001 736000                    QLS     1
         1 000375   000002 736000                    QLS     2
         1 000376   200006 473500                    LDP3    @NODE_DESC,,AUTO
         1 000377   000106 100500                    MLR     fill='000'O
         1 000400   300000 000010                    ADSC9   0,,PR3                   cn=0,n=8
         1 000401   200012 000010                    ADSC9   RANGE_KEY$,Q,AUTO        cn=0,n=8

      684     3186    1           IF NODE_DESC.SPEC = %CLEAR THEN

   3186  1 000402   000000 106500                    CMPC    fill='000'O
         1 000403   300002 000010                    ADSC9   2,,PR3                   cn=0,n=8
         1 000404   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         1 000405   000411 601000 1                  TNZ     s:3189

      685     3187    1              SPEC$ = ADDR(NIL);

   3187  1 000406   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000407   200025 756100                    STQ     SPEC$,,AUTO
         1 000410   000414 710000 1                  TRA     s:3190

      686     3188    1           ELSE
      687     3189    1              SPEC$ = ADDR(NODE_DESC.SPEC);

   3189  1 000411   200006 236100                    LDQ     @NODE_DESC,,AUTO
         1 000412   000002 036003                    ADLQ    2,DU
         1 000413   200025 756100                    STQ     SPEC$,,AUTO

      688     3190    1           CALL VDA$LWRITE (STREAM, LOCATION, SPEC, DATA$BUFFER)

   3190  1 000414   300004 474500                    LDP4    4,,PR3
         1 000415   200035 454500                    STP4    I+4,,AUTO
         1 000416   200034 756100                    STQ     I+3,,AUTO
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:102  
         1 000417   200014 635500                    EPPR5   LOCATION,,AUTO
         1 000420   200033 455500                    STP5    I+2,,AUTO
         1 000421   200003 236100                    LDQ     @STREAM,,AUTO
         1 000422   200032 756100                    STQ     I+1,,AUTO
         1 000423   200032 630500                    EPPR0   I+1,,AUTO
         1 000424   000022 631400 xsym               EPPR1   B_VECTNIL+18
         1 000425   000000 701000 xent               TSX1    VDA$LWRITE
         1 000426   000452 702000 1                  TSX2    GENERATE_KEY_FAILED

      689     3191    1             ALTRET (LWRITE_FAILED);
      690     3192
      691     3193                /*
      692     3194                *   Clear NODE_DESC.SPEC and DATA$ since the Accessor now owns them.
      693     3195                */
      694     3196
      695     3197    1           NODE_DESC.SPEC = %CLEAR;

   3197  1 000427   200006 470500                    LDP0    @NODE_DESC,,AUTO
         1 000430   000002 450100                    STZ     2,,PR0
         1 000431   000003 450100                    STZ     3,,PR0

      696     3198    1           NODE_DESC.DATA$ = ADDR(NIL);

   3198  1 000432   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000433   000004 756100                    STQ     4,,PR0

      697     3199
      698     3200    1           IF VD_$$MON_EVAL.V# > 0 THEN

   3200  1 000434   000003 235000 xsym               LDA     VD_$$MON_EVAL+3
         1 000435   000445 604400 1                  TMOZ    s:3203

      699     3201    1              CALL VDG$MEVAL_RPUT_RETURN (STREAM, NODE_DESC.KEY);

   3201  1 000436   200006 236100                    LDQ     @NODE_DESC,,AUTO
         1 000437   200003 235100                    LDA     @STREAM,,AUTO
         1 000440   200032 757100                    STAQ    I+1,,AUTO
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:103  
         1 000441   200032 630500                    EPPR0   I+1,,AUTO
         1 000442   000020 631400 xsym               EPPR1   B_VECTNIL+16
         1 000443   000000 701000 xent               TSX1    VDG$MEVAL_RPUT_RETURN
         1 000444   000000 011000                    NOP     0

      700     3202
      701     3203    1           RETURN;

   3203  1 000445   000000 702200 xent               TSX2  ! X66_ARET

      702     3204
      703     3205
      704     3206    1   CURRENT_OUTSIDE_RANGE_FAILURE:
      705     3207    1           CALL VDG$ERRMSG (%E$CUTOFF);

   3207  1 000446   000003 630400 2     CURRENT_OUT* EPPR0   3
         1 000447   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000450   000000 701000 xent               TSX1    VDG$ERRMSG
         1 000451   000000 011000                    NOP     0

   3200  1 000452                       GENERATE_KE* null
   3200  1 000452                       LWRITE_FAIL* null
   3200  1 000452                       OALLOC_FAIL* null
      706     3208
      707     3209
      708     3210    1   GENERATE_KEY_FAILED: ;
      709     3211    1   LWRITE_FAILED: ;
      710     3212    1   OALLOC_FAILED: ;
      711     3213    1           ALTRETURN;

   3213  1 000452   000000 702200 xent               TSX2  ! X66_AALT

      712     3214
      713     3215        /*D* NAME:  GENERATE_KEY
      714     3216            PARAMETERS:
      715     3217                KEY - VD$TEXTC containing the starting key.
      716     3218                LIMIT - VD$TEXTC containing the limit key.
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:104  
      717     3219            INPUT:
      718     3220                STREAM - VD$STREAM which is open to the file we're generating
      719     3221                    keys for.  File must have numeric keys; the file's
      720     3222                    org must be %ORG_KEYED or %ORG_CONSEC.  If %ORG_CONSEC,
      721     3223                    SEQUENCE must be %SQ_NEXT and LIMIT_KEY.BYTES# must be
      722     3224                    %MX_EDITKEY (indicating generating a new key at eof).
      723     3225                SEQUENCE - %SQ_ value specifying whether to generate a new key
      724     3226                    which sorts before KEY or after KEY.
      725     3227                OPTIONS - VD$ACCESS_OPTIONS for the block.
      726     3228                    If .KEY_INCR's value is 0, we'll use VD_$BY instead.
      727     3229                VD_$BY - VD$NUMBER containing the current value of the predefined
      728     3230                    name "$BY". If VD_$BY.V# is zero, we'll use a default key
      729     3231                    increment.
      730     3232            OUTPUT:
      731     3233                KEY will be modified:  it will contain the generated key.
      732     3234                If we can't generate a key that fits between KEY and LIMIT,
      733     3235                    we'll ALTRETURN.
      734     3236            DESCRIPTION:
      735     3237                Make sure we can generate keys for this file.
      736     3238                If so, generate the key.  How to do this depends on the file's
      737     3239                organization:
      738     3240                For CONSEC files, the key increment is always 1, and the LIMIT
      739     3241                    is always the maximum legal consecutive key.  Add 1 to
      740     3242                    KEY and make sure it's still legal.
      741     3243                For KEYED files, use OPTIONS.KEY_INCR, or if
      742     3244                    that's zero use VD_$BY, or if that's zero, use a standard
      743     3245                    default.
      744     3246                    Based on SEQUENCE, either add or subtract the increment
      745     3247                    to/from KEY to get next key. Test to see if
      746     3248                    the value is still between KEY and LIMIT.
      747     3249                    If not, then divide the increment by 10 to get a new
      748     3250                    increment, and try again.  Keep dividing the increment
      749     3251                    by 10 until it's small enough.  If we can't get the
      750     3252                    increment small enough to fit between KEY and LIMIT,
      751     3253                    ALTRETURN.
      752     3254        */
      753     3255
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:105  
      754     3256    1   GENERATE_KEY: PROC (KEY) ALTRET;

   3256  1 000453   200026 741300       GENERATE_KEY STX1  ! SPEC$+1,,AUTO

      755     3257
      756     3258    2   DCL 1 KEY ALIGNED,
      757     3259    2         2 LENGTH# UBIN BYTE CALIGNED,
      758     3260    2         2 BYTES# UBIN(27) CALIGNED;
      759     3261
      760     3262
      761     3263        %VD$NUMBER (NAME=VD_$BY, STCLASS=SYMREF);
      762     3308
      763     3309
      764     3310    2   DCL INCR_FLOORS (0:7) UBIN CONSTANT     /* 0 marks end of table */
      765     3311    2       INIT(1000000, 100000, 10000, 1000, 100, 10, 1, 0);
      766     3312
      767     3313
      768     3314    2   DCL INCR UBIN;
      769     3315    2   DCL I UBIN;
      770     3316
      771     3317
      772     3318        %VD$KEY_NUMBER;
      773     3333        %VD$PORT;
      774     3431
      775     3432
      776     3433
      777     3434    2   KT_CASES:
      778     3435    3           DO CASE (STREAM.PORT$->VD$PORT.LEVEL.KEY_TYPE# (OPTIONS.LEVEL#));

   3435  1 000454   200003 470500       KT_CASES     LDP0    @STREAM,,AUTO
         1 000455   000001 471500                    LDP1    1,,PR0
         1 000456   200005 473500                    LDP3    @OPTIONS,,AUTO
         1 000457   300001 236100                    LDQ     1,,PR3
         1 000460   000022 732000                    QRS     18
         1 000461   000007 402007                    MPY     7,DL
         1 000462   100023 720106                    LXL0    19,QL,PR1
         1 000463   000004 100003                    CMPX0   4,DU
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:106  
         1 000464   000466 602010 1                  TNC     KT_CASES+10,X0
         1 000465   000620 710000 1                  TRA     s:3482
         1 000466   000620 710000 1                  TRA     s:3482
         1 000467   000472 710000 1                  TRA     s:3437
         1 000470   000620 710000 1                  TRA     s:3482
         1 000471   000512 710000 1                  TRA     s:3446

      779     3436    3            CASE (%KT_NUMBER);

      780     3437    3              IF SEQUENCE ~= %SQ_NEXT

   3437  1 000472   200007 474500                    LDP4    @SEQUENCE,,AUTO
         1 000473   400000 235100                    LDA     0,,PR4
         1 000474   000003 115007                    CMPA    3,DL
         1 000475   000623 601000 1                  TNZ     GENKEY_CONFLICTS_W_ORGKT
         1 000476   200011 236100                    LDQ     LIMIT,,AUTO
         1 000477   000000 116000 2                  CMPQ    0
         1 000500   000623 601000 1                  TNZ     GENKEY_CONFLICTS_W_ORGKT

      781     3438    3                OR LIMIT.BYTES# ~= %MX_EDITKEY THEN
      782     3439    3                 GOTO GENKEY_CONFLICTS_W_ORGKT;
      783     3440    3              IF KEY.BYTES# + 1 > %MX_CONSEC_RECORDS THEN

   3440  1 000501   200027 475500                    LDP5    @KEY,,AUTO
         1 000502   500000 236100                    LDQ     0,,PR5
         1 000503   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000504   000032 116000 xsym               CMPQ    B_VECTNIL+26
         1 000505   000631 603000 1                  TRC     CONSEC_PAST_LIMIT

      784     3441    3                 GOTO CONSEC_PAST_LIMIT;
      785     3442    3              KEY.BYTES# = KEY.BYTES# + 1;

   3442  1 000506   500000 236100                    LDQ     0,,PR5
         1 000507   000001 036007                    ADLQ    1,DL
         1 000510   500000 552134                    STBQ    0,'34'O,PR5
         1 000511   000621 710000 1                  TRA     s:3485

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:107  
      786     3443
      787     3444
      788     3445    3            CASE (%KT_EDITKEY);

      789     3446    3              INCR = ADDR(OPTIONS.KEY_INCR)->VD$KEY_NUMBER.BYTES#;

   3446  1 000512   300004 236100                    LDQ     4,,PR3
         1 000513   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000514   200030 756100                    STQ     INCR,,AUTO

      790     3447    4              IF INCR = 0 THEN DO;

   3447  1 000515   000523 601000 1                  TNZ     s:3453

      791     3448    4                 INCR = VD_$BY.V#;

   3448  1 000516   000003 235000 xsym               LDA     VD_$BY+3
         1 000517   200030 755100                    STA     INCR,,AUTO

      792     3449    4                 IF INCR = 0 THEN

   3449  1 000520   000523 601000 1                  TNZ     s:3453

      793     3450    4                    INCR = %DFLT_$BY;

   3450  1 000521   023420 235007                    LDA     10000,DL
         1 000522   200030 755100                    STA     INCR,,AUTO

      794     3451    4                 END;

      795     3452
      796     3453    3              I = 0;

   3453  1 000523   200031 450100                    STZ     I,,AUTO

      797     3454
      798     3455    3   KEYED_SEQUENCE_CASES:
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:108  
      799     3456    4              DO CASE (SEQUENCE);

   3456  1 000524   200007 474500       KEYED_SEQUE* LDP4    @SEQUENCE,,AUTO
         1 000525   400000 235100                    LDA     0,,PR4
         1 000526   000004 115007                    CMPA    4,DL
         1 000527   000531 602005 1                  TNC     KEYED_SEQUENCE_CASES+5,AL
         1 000530   000611 710000 1                  TRA     s:3474
         1 000531   000611 710000 1                  TRA     s:3474
         1 000532   000535 710000 1                  TRA     s:3458
         1 000533   000611 710000 1                  TRA     s:3474
         1 000534   000564 710000 1                  TRA     s:3466

      800     3457    4               CASE (%SQ_PREVIOUS);

      801     3458    5                 DO WHILE INCR > 0

   3458  1 000535   000544 710000 1                  TRA     s:3462

      802     3459    5                   AND KEY.BYTES# - INCR <= LIMIT.BYTES#;
      803     3460    5                    INCR = INCR_FLOORS (I);

   3460  1 000536   200031 720100                    LXL0    I,,AUTO
         1 000537   000000 235010 0                  LDA     INCR_FLOORS,X0
         1 000540   200030 755100                    STA     INCR,,AUTO

      804     3461    5                    I = I + 1;

   3461  1 000541   200031 236100                    LDQ     I,,AUTO
         1 000542   000001 036007                    ADLQ    1,DL
         1 000543   200031 756100                    STQ     I,,AUTO

      805     3462    5                    END;

   3462  1 000544   200030 235100                    LDA     INCR,,AUTO
         1 000545   000556 600000 1                  TZE     s:3463
         1 000546   200027 470500                    LDP0    @KEY,,AUTO
         1 000547   000000 236100                    LDQ     0,,PR0
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:109  
         1 000550   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000551   200030 136100                    SBLQ    INCR,,AUTO
         1 000552   000536 604000 1                  TMI     s:3460
         1 000553   200011 116100                    CMPQ    LIMIT,,AUTO
         1 000554   000536 602000 1                  TNC     s:3460
         1 000555   000536 600000 1                  TZE     s:3460

      806     3463    4                 KEY.BYTES# = KEY.BYTES# - INCR;

   3463  1 000556   200027 470500                    LDP0    @KEY,,AUTO
         1 000557   000000 236100                    LDQ     0,,PR0
         1 000560   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000561   200030 136100                    SBLQ    INCR,,AUTO
         1 000562   000000 552134                    STBQ    0,'34'O,PR0
         1 000563   000615 710000 1                  TRA     s:3477

      807     3464
      808     3465    4               CASE (%SQ_NEXT);

      809     3466    5                 DO WHILE INCR > 0

   3466  1 000564   000573 710000 1                  TRA     s:3470

      810     3467    5                   AND KEY.BYTES# + INCR >= LIMIT.BYTES#;
      811     3468    5                    INCR = INCR_FLOORS (I);

   3468  1 000565   200031 720100                    LXL0    I,,AUTO
         1 000566   000000 235010 0                  LDA     INCR_FLOORS,X0
         1 000567   200030 755100                    STA     INCR,,AUTO

      812     3469    5                    I = I + 1;

   3469  1 000570   200031 236100                    LDQ     I,,AUTO
         1 000571   000001 036007                    ADLQ    1,DL
         1 000572   200031 756100                    STQ     I,,AUTO

      813     3470    5                    END;
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:110  

   3470  1 000573   200030 235100                    LDA     INCR,,AUTO
         1 000574   000603 600000 1                  TZE     s:3471
         1 000575   200027 470500                    LDP0    @KEY,,AUTO
         1 000576   000000 236100                    LDQ     0,,PR0
         1 000577   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000600   200030 036100                    ADLQ    INCR,,AUTO
         1 000601   200011 116100                    CMPQ    LIMIT,,AUTO
         1 000602   000565 603000 1                  TRC     s:3468

      814     3471    4                 KEY.BYTES# = KEY.BYTES# + INCR;

   3471  1 000603   200027 470500                    LDP0    @KEY,,AUTO
         1 000604   000000 236100                    LDQ     0,,PR0
         1 000605   000032 376000 xsym               ANQ     B_VECTNIL+26
         1 000606   200030 036100                    ADLQ    INCR,,AUTO
         1 000607   000000 552134                    STBQ    0,'34'O,PR0
         1 000610   000615 710000 1                  TRA     s:3477

      815     3472
      816     3473    4               CASE (ELSE);

      817     3474    4                 CALL VDG$ESCREECH (SEQUENCE);

   3474  1 000611   200007 630500                    EPPR0   @SEQUENCE,,AUTO
         1 000612   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000613   000000 701000 xent               TSX1    VDG$ESCREECH
         1 000614   000000 011000                    NOP     0

      818     3475    4               END KEYED_SEQUENCE_CASES;

      819     3476
      820     3477    3              IF INCR = 0 THEN

   3477  1 000615   200030 235100                    LDA     INCR,,AUTO
         1 000616   000631 600000 1                  TZE     CONSEC_PAST_LIMIT
         1 000617   000621 710000 1                  TRA     s:3485
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:111  

      821     3478    3                 GOTO KEYED_PAST_LIMIT;
      822     3479
      823     3480
      824     3481    3            CASE (ELSE);

      825     3482    3              GOTO GENKEY_CONFLICTS_W_ORGKT;

   3482  1 000620   000623 710000 1                  TRA     GENKEY_CONFLICTS_W_ORGKT

      826     3483    3            END KT_CASES;

      827     3484
      828     3485    2           RETURN;

   3485  1 000621   200026 221300                    LDX1  ! SPEC$+1,,AUTO
         1 000622   000001 702211                    TSX2  ! 1,X1

      829     3486
      830     3487
      831     3488    2   GENKEY_CONFLICTS_W_ORGKT:
      832     3489    2           CALL VDG$ERRMSG (%E$GENKEY_CONFLICTS_W_ORGKT);

   3489  1 000623   000005 630400 2     GENKEY_CONF* EPPR0   5
         1 000624   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000625   000000 701000 xent               TSX1    VDG$ERRMSG
         1 000626   000000 011000                    NOP     0

      833     3490    2           ALTRETURN;

   3490  1 000627   200026 221300                    LDX1  ! SPEC$+1,,AUTO
         1 000630   000000 702211                    TSX2  ! 0,X1

   3471  1 000631                       CONSEC_PAST* null
      834     3491
      835     3492
      836     3493    2   CONSEC_PAST_LIMIT: ;
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:112  
      837     3494    2   KEYED_PAST_LIMIT: ;

   3494  1 000631                       KEYED_PAST_* null
      838     3495    2           CALL VDG$ERRMSG (%E$CUTOFF);

   3495  1 000631   000003 630400 2                  EPPR0   3
         1 000632   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000633   000000 701000 xent               TSX1    VDG$ERRMSG
         1 000634   000000 011000                    NOP     0

   3494  1 000635                       OALLOC_FAIL* null
      839     3496
      840     3497    2   OALLOC_FAILED: ;
      841     3498    2           ALTRETURN;

   3498  1 000635   200026 221300                    LDX1  ! SPEC$+1,,AUTO
         1 000636   000000 702211                    TSX2  ! 0,X1
      842     3499
      843     3500    2   END GENERATE_KEY;
      844     3501
      845     3502    1   END VDE$RPUT;

PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:113  
--  Include file information  --

   VD_PERR_C.:VDA5TOU  is referenced.
   VD_MACROS_M.:VDA5TOU  is referenced.
   B$JIT_C.:E04TOU  was found in the system file and is never referenced.
   CP_6_C.:E04TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure VDE$RPUT.
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:114  

 **** Variables and constants ****

  ****  Section 000 RoData VDE$RPUT

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w UBIN        r     1 INCR_FLOORS(0:7)

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

    10-0-0/w PTR         r     1 @EXISTING_KEY             27-0-0/w PTR         r     1 @KEY
     6-0-0/w PTR         r     1 @NODE_DESC                 5-0-0/w PTR         r     1 @OPTIONS
     4-0-0/w PTR         r     1 @RANGE                     7-0-0/w PTR         r     1 @SEQUENCE
     3-0-0/w PTR         r     1 @STREAM                   *0-0-0/w STRC(72)    r     1 EXISTING_KEY
    31-0-0/w UBIN        r     1 I                         30-0-0/w UBIN        r     1 INCR
    *0-0-0/w STRC        r     1 KEY                       11-0-0/w STRC        r     1 LIMIT
    14-0-0/w STRC(324)   r     1 LOCATION                  *0-0-0/w STRC(216)   r     1 NODE_DESC
    13-0-0/w PTR         r     1 NODE_KEY$                 *0-0-0/w STRC(180)   r     1 OPTIONS
    *0-0-0/w STRC(648)   r     1 RANGE                     12-0-0/w PTR         r     1 RANGE_KEY$
    *0-0-0/w SBIN        r     1 SEQUENCE                  25-0-0/w PTR         r     1 SPEC$
    *0-0-0/w STRC(864)   r     1 STREAM

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 VD_$$MON_EVAL              0-0-0/w STRC(144)   r     1 VD_$BY
     0-0-0/w STRC(72)    r     1 VD_KEY_NUMERIC_BOF

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:115  
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w ASTR(90)    r     1 DATA$BUFFER                0-0-0/w ASTR(9)     r     1 NODE$KEY
     0-0-0/w STRC        r     1 NODE$KEY_NUMBER            0-0-0/w ASTR(9)     r     1 RANGE$KEY
     0-0-0/w STRC        r     1 RANGE$KEY_NUMBER           0-0-0/w STRC(72)    r     1 SPEC
     0-0-0/w STRC(72)    r     1 VD$KEY_NUMBER              0-0-0/w STRC(1944)  r     1 VD$PORT
     0-0-0/w ASTR(81)    r     1 VD$TEXTC_REMOTE


   Procedure VDE$RPUT requires 415 words for executable code.
   Procedure VDE$RPUT requires 30 words of local(AUTO) storage.

    No errors detected in file VDE$RECORDS.:VDA5TSI    .
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:116  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:117  
          MINI XREF LISTING

CONSEC_PAST_LIMIT IN PROCEDURE GENERATE_KEY
      3471**LABEL    3441--GOTO
CURRENT_OUTSIDE_RANGE_FAILURE
      3207**LABEL    3079--GOTO     3091--GOTO     3095--GOTO     3112--GOTO
DATA$BUFFER
      2958**DCL      3190<>CALL
DATA$BUFFER.LENGTH#
      2984**DCL      2986--IMP-SIZ  3190>>CALL
EXISTING_KEY
      2727**DCL       104--PROC     3058--IF       3060<>CALL     3124>>IF       3139>>IF       3156>>IF
      3171>>IF
EXISTING_KEY.BYTES#
      2731**DCL      3119>>ASSIGN   3151>>ASSIGN
GENERATE_KEY
      3256**PROC     3144--CALL     3176--CALL
GENERATE_KEY_FAILED
      3200**LABEL    3144--CALLALT  3176--CALLALT
GENKEY_CONFLICTS_W_ORGKT IN PROCEDURE GENERATE_KEY
      3489**LABEL    3439--GOTO     3482--GOTO
I IN PROCEDURE GENERATE_KEY
      3315**DCL      3453<<ASSIGN   3460>>ASSIGN   3461<<ASSIGN   3461>>ASSIGN   3468>>ASSIGN   3469<<ASSIGN
      3469>>ASSIGN
INCR IN PROCEDURE GENERATE_KEY
      3314**DCL      3446<<ASSIGN   3447>>IF       3448<<ASSIGN   3449>>IF       3450<<ASSIGN   3458>>DOWHILE
      3458>>DOWHILE  3460<<ASSIGN   3463>>ASSIGN   3466>>DOWHILE  3466>>DOWHILE  3468<<ASSIGN   3471>>ASSIGN
      3477>>IF
INCR_FLOORS IN PROCEDURE GENERATE_KEY
      3310**DCL      3460>>ASSIGN   3468>>ASSIGN
KEY IN PROCEDURE GENERATE_KEY
      3258**DCL      3256--PROC
KEY.BYTES# IN PROCEDURE GENERATE_KEY
      3260**DCL      3440>>IF       3442<<ASSIGN   3442>>ASSIGN   3458>>DOWHILE  3463<<ASSIGN   3463>>ASSIGN
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:118  
      3466>>DOWHILE  3471<<ASSIGN   3471>>ASSIGN
KEYED_PAST_LIMIT IN PROCEDURE GENERATE_KEY
      3494**LABEL    3478--GOTO
LIMIT.BYTES#
      2810**DCL      3119<<ASSIGN   3122<<ASSIGN   3125<<ASSIGN   3139>>IF       3141<<ASSIGN   3151<<ASSIGN
      3154<<ASSIGN   3157<<ASSIGN   3171>>IF       3173<<ASSIGN   3437>>IF       3458>>DOWHILE  3466>>DOWHILE
LOCATION
      2821**DCL      3184<<ASSIGN   3190<>CALL
LOCATION.KEY
      2835**DCL      3185<<ASSIGN
LWRITE_FAILED
      3200**LABEL    3190--CALLALT
NODE$KEY
      2890**DCL      3144<>CALL     3176<>CALL
NODE$KEY.BYTES
      2900**DCL      3090>>IF       3109>>IF       3109>>IF
NODE$KEY.LENGTH#
      2898**DCL      2900--IMP-SIZ  3090>>IF       3109>>IF       3109>>IF       3144>>CALL     3176>>CALL
NODE$KEY_NUMBER.BYTES#
      2917**DCL      3094>>IF
NODE_DESC
      2684**DCL       104--PROC     3056<>CALL
NODE_DESC.DATA$
      2716**DCL      2958--IMP-PTR  3190>>CALL     3190>>CALL     3198<<ASSIGN
NODE_DESC.KEY
      2698**DCL      3062>>IF       3063<<ASSIGN   3185>>ASSIGN   3201<>CALL
NODE_DESC.KEY.REP#
      2700**DCL      3071>>IF
NODE_DESC.KEY.V$
      2700**DCL      3071>>ASSIGN   3071--ASSIGN
NODE_DESC.SPEC
      2712**DCL      3186>>IF       3189--ASSIGN   3197<<ASSIGN
NODE_KEY$
      2812**DCL      2890--IMP-PTR  2913--IMP-PTR  3071<<ASSIGN   3071<<ASSIGN   3090>>IF       3090>>IF
      3094>>IF       3109>>IF       3109>>IF       3109>>IF       3109>>IF       3144>>CALL     3144>>CALL
      3176>>CALL     3176>>CALL
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:119  
OPTIONS
      2655**DCL       104--PROC
OPTIONS.KEY_INCR
      2671**DCL      3446--ASSIGN
OPTIONS.LEVEL#
      2659**DCL      3087>>IF       3087>>ASSIGN   3087>>ASSIGN   3106>>IF       3106>>ASSIGN   3106>>ASSIGN
      3136>>IF       3136>>ASSIGN   3136>>ASSIGN   3168>>IF       3168>>ASSIGN   3168>>ASSIGN   3185>>ASSIGN
      3435>>DOCASE
RANGE
      2586**DCL       104--PROC     3056<>CALL
RANGE.ENDD
      2628**DCL      3153>>IF
RANGE.ENDD.EOF
      2644**DCL      3093>>IF       3155>>IF
RANGE.ENDD.KEY.REP#
      2642**DCL      3106>>IF       3168>>IF
RANGE.ENDD.KEY.V$
      2642**DCL      3106>>ASSIGN   3106--ASSIGN   3168>>ASSIGN   3168--ASSIGN
RANGE.ENDD.POSITION#
      2644**DCL      3109>>IF
RANGE.START
      2600**DCL      3123>>IF       3184>>ASSIGN
RANGE.START.EOF
      2616**DCL      3078>>IF       3121>>IF
RANGE.START.KEY.REP#
      2614**DCL      3087>>IF       3136>>IF
RANGE.START.KEY.V$
      2614**DCL      3087>>ASSIGN   3087--ASSIGN   3136>>ASSIGN   3136--ASSIGN
RANGE$KEY.BYTES
      2877**DCL      3090>>IF       3109>>IF       3109>>IF
RANGE$KEY.LENGTH#
      2875**DCL      2877--IMP-SIZ  3090>>IF       3109>>IF       3109>>IF
RANGE$KEY_NUMBER.BYTES#
      2857**DCL      3139>>IF       3141>>ASSIGN   3171>>IF       3173>>ASSIGN
RANGE_KEY$
      2811**DCL      2853--IMP-PTR  2867--IMP-PTR  3087<<ASSIGN   3087<<ASSIGN   3090>>IF       3090>>IF
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:120  
      3106<<ASSIGN   3106<<ASSIGN   3109>>IF       3109>>IF       3109>>IF       3109>>IF       3136<<ASSIGN
      3136<<ASSIGN   3139>>IF       3141>>ASSIGN   3168<<ASSIGN   3168<<ASSIGN   3171>>IF       3173>>ASSIGN
SEQUENCE
      2718**DCL       104--PROC     3056<>CALL     3076>>DOCASE   3181<>CALL     3437>>IF       3456>>DOCASE
      3474<>CALL
SPEC
      2927**DCL      3190<>CALL
SPEC$
      2841**DCL      2927--IMP-PTR  3187<<ASSIGN   3189<<ASSIGN   3190>>CALL
STREAM
      2480**DCL       104--PROC     3056<>CALL     3060<>CALL     3190<>CALL     3201<>CALL
STREAM.PORT$
      2506**DCL      3435>>DOCASE
VD$KEY_NUMBER.BYTES# IN PROCEDURE GENERATE_KEY
      3330**DCL      3446>>ASSIGN
VD$PORT.LEVEL.KEY_TYPE# IN PROCEDURE GENERATE_KEY
      3412**DCL      3435>>DOCASE
VD$TEXTC_REMOTE.LENGTH#
      3045**DCL      3047--IMP-SIZ  3071--ASSIGN   3087--ASSIGN   3106--ASSIGN   3136--ASSIGN   3168--ASSIGN
VDA$LWRITE
      2736**DCL-ENT  3190--CALL
VDG$ERRMSG
      2738**DCL-ENT  3207--CALL     3489--CALL     3495--CALL
VDG$ESCREECH
      2739**DCL-ENT  3181--CALL     3474--CALL
VDG$MEVAL_RPUT
      2740**DCL-ENT  3056--CALL
VDG$MEVAL_RPUT_EXISTING_KEY
      2741**DCL-ENT  3060--CALL
VDG$MEVAL_RPUT_RETURN
      2742**DCL-ENT  3201--CALL
VD_$$MON_EVAL.V#
      2801**DCL      3055>>IF       3058>>IF       3200>>IF
VD_$BY.V# IN PROCEDURE GENERATE_KEY
      3305**DCL      3448>>ASSIGN
VD_KEY_NUMERIC_BOF
PL6.E3A0      #004=VDE$RPUT File=VDE$RECORDS.:VDA5TSI                            FRI 07/04/97 11:17 Page:121  
      2753**DCL      3063>>ASSIGN
