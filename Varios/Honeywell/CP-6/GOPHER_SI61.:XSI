/*M* GOPHER - Finds character strings in files */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
 
/*X* PLM=4,STI=2,IND=2,CTI=4,DCI=5,PRB=YES,ECI=3,CSI=3,THI=2,DTI=2,
     DIN=2,ENI=2,CLM=0,CCC,SQB,MCI,NTB,MOC,CCI=3,MCR=NO,NLB,MCL=0,EDMC  */
/*X* DDA */
 
GOPHER: PROC MAIN;
 
/**/
/* INCLUDE files */
/**/
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
/* CLUDE GOPHER_C61; */
%INCLUDE XU_FORMAT_C;
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE XUW_MACRO_C;
/**
 *                 TRANSLATE TABLE REQUIREMENTS
 **/
%INCLUDE B$TABLES_C;
/**/
%B$XL_EBC_ASC;               /* EBCDIC to ASCII translation table */
 
 
%LIST;
%INCLUDE GOPHER_C61;
%PLIST;
%EJECT;
/**/
/* Miscellaneous SUBs and EQUs */
/**/
%EQU MAX_UI_ACCTS            = 9;
%EQU MAX_ACCTS               = 8;
%EQU MAX_ITYPES              = 99;
%EQU MAX_SKIPS               = 99;
%EQU MAX_TYPES               = 99;
%EQU OBUFSIZ                 = 256;
%EQU E$STOWED_INACTIVE       = 130;
 
 
/**/
/* SUBs used to access the PCB */
/**/
 
%EQU BLK1_NSUBLKS = %CHARTEXT('BLK1$->P_OUT.NSUBLKS');
%EQU BLK1_SUBLK$  = %CHARTEXT('BLK1$->P_OUT.SUBLK$');
 
%EQU BLK2_NSUBLKS = %CHARTEXT('BLK2$->P_OUT.NSUBLKS');
%EQU BLK2_SUBLK$  = %CHARTEXT('BLK2$->P_OUT.SUBLK$');
%EQU BLK2_CODE    = %CHARTEXT('BLK2$->P_SYM.CODE');
%EQU BLK2_COUNT   = %CHARTEXT('BLK2$->P_SYM.COUNT');
%EQU BLK2_TEXT    = %CHARTEXT('SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)');
 
%EQU BLK3_NSUBLKS = %CHARTEXT('BLK3$->P_OUT.NSUBLKS');
%EQU BLK3_SUBLK$  = %CHARTEXT('BLK3$->P_OUT.SUBLK$');
%EQU BLK3_CODE    = %CHARTEXT('BLK3$->P_SYM.CODE');
%EQU BLK3_COUNT   = %CHARTEXT('BLK3$->P_SYM.COUNT');
%EQU BLK3_TEXT    = %CHARTEXT('SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)');
 
%EQU BLK4_NSUBLKS = %CHARTEXT('BLK4$->P_OUT.NSUBLKS');
%EQU BLK4_SUBLK$  = %CHARTEXT('BLK4$->P_OUT.SUBLK$');
%EQU BLK4_CODE    = %CHARTEXT('BLK4$->P_SYM.CODE');
%EQU BLK4_COUNT   = %CHARTEXT('BLK4$->P_SYM.COUNT');
%EQU BLK4_TEXT    = %CHARTEXT('SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT)');
%EJECT;
/**/
/* FPTs */
/**/
%FPT_FID     (FPTN                     = FID,
              ACCT=AN_ACCT,
              ASN=MERGEF.V.ASN#,
              NAME=BASE_NAME,
              PASS=A_PASS,
              RES=MERGEF.V.RES#,
              SN=A_SN,
              TEXTFID=STD_REC,
              WSN=A_WSN );
%VLP_ACCT    (FPTN                     = AN_ACCT );
%VLP_NAME    (FPTN                     = A_NAME );
%VLP_PASS    (FPTN                     = A_PASS );
%VLP_SN      (FPTN                     = A_SN );
%VLP_WSN     (FPTN                     = A_WSN );
 
%FPT_UNFID   (FPTN                     = UNFID,
              DCB=M$SI,
              LEN=STD_ARS,
              TEXTFID=STD_REC );
%FPT_UNFID   (FPTN                     = UNFID_INCLUDE,
              DCB=M$TEST);
%FPT_OPEN    (FPTN                     = OPEN_INCLUDE,
              DCB=M$TEST,
              ACCT=AN_ACCT,
              NAME=BASE_NAME,
              ASN=FILE,
              TEST=YES,
              PASS=A_PASS,
              SN=A_SN);
%FPT_CLOSE   (FPTN                     = CLOSE_INCLUDE,
              DCB=M$TEST);
%FPT_OPEN    (FPTN                     = MERGEF,
              ACCT=AN_ACCT,
              ASN=FILE,
              DCB=M$SI,
              FUN=IN,
              NAME=BASE_NAME,
              PASS=A_PASS,
              SETDCB=YES,
              SN=A_SN,
              WSN=A_WSN );
%FPT_OPEN    (FPTN                     = OPENASIS );
 
%FPT_OPEN    (FPTN                     = OPENF );
 
%VLP_ERRCODE (FPTN                     = ERRCODE );
 
%FPT_ERRMSG  (FPTN                     = FPT_ERRMSG,
              BUF=LO_BUF,
              CODE=ERRCODE,
              OUTDCB1=M$LO,
              OUTDCB2=M$DO,
              RESULTS=VLR_ERRMSG );
%VLR_ERRMSG;
 
%FPT_CORRES  (FPTN                     = CORRESLODO,
              DCB1=M$LO,
              DCB2=M$DO );
 
%FPT_EXIT    (FPTN                     = SET_STEPCC,
              STEPCC=OK );
 
%FPT_READ    (FPTN                     = READ_STD,
              BUF=STD_REC,
              DCB=F$STD );
 
%FPT_READ    (FPTN                     = READ_STRINGS,
              BUF=STRBUF.BUFF,
              DCB=M$STRING );
 
%FPT_WRITE   (FPTN                     = WRFNAME,
              DCB=M$LO );
 
%FPT_WRITE   (FPTN                     = FPT_WRERR,
              DCB=M$DO );
 
%FPT_CLOSE   (FPTN                     = FPT_CLSSAV,
              DISP=SAVE,
              RELG=YES );
%XUU_PARAM   (FPTN                     = XUU_PARAM,
              ALLOCATE=GOPHER$ALLOC,
              BASE=YES,
              CLOSE_ALL=YES,
              ERROR_PROC=GOPHER$ERR,
              FAST_BASE=YES,
              FAST_UPDATE=YES,
              OPT_UI=YES,
              RELEASE=GOPHER$REL );
%XUU$ENTRY;
 
%FPT_WRITE   (FPTN                     = FPT_LS,
              BUF=FILEBUF,
              DCB=M$LO );
 
%FPT_PROMPT  (FPTN                     = SET_PROMPT );
 
%FPT_INT     (FPTN                     = BREAK_CNTRL,
              UENTRY=GOPHER$BREAK );
 
%FPT_OPEN    (FPTN                     = OPEN_BASE,
              ASN=FILE,
              NXTF=YES,
              STCLASS=STATIC );
 
%FPT_OPEN    (FPTN                     = MERGE_UPD,
              ASN=FILE,
              FUN=IN,
              SETDCB=YES );
 
%FPT_OPEN    (FPTN                     = MERGE_SI_NAME,
              DCB=M$SI,
              NAME=A_NAME,
              SETDCB=YES );
 
%FPT_OPEN    (FPTN                     = MERGE_UI_NAME,
              DCB=M$UI,
              NAME=A_NAME,
              SETDCB=YES );
 
%FPT_CLOSE   (FPTN                     = CLOSE_BASE,
              DISP=SAVE,
              RELG=YES );
 
%VLP_NAME    (FPTN                     = BASE_NAME );
%FPT_CMDVAR  (FPTN                     = GET_DEFAULTS,
              FUN=FETCH,
              NAME=THIS_FILE );
           /* VALUE=TMP.DFLT ); */
%EJECT;
/**/
/* PARSEr stuff */
/**/
%P_PCB       (NAME                     = GOPHER_OPTS,
              R=GOPHER_R );
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS="BASED");
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS="BASED");
DCL GOPHER_R                 UBIN      SYMREF;
DCL PL6_INCLUDE              UBIN      SYMREF;
DCL FORT_INCLUDE             UBIN      SYMREF;
DCL COBOL_COPY               UBIN      SYMREF;
DCL X$PARSE                  ENTRY(1)  ALTRET;
 
/**/
/* WILDCARD stuff */
/**/
%XUW_WILDCARD(FPTN                     = XUW_WILDCARD );
 
/**/
/* FORMATer stuff */
/**/
%F_FDS       (NAME                     = F_FDS,
              BUF=LO_BUF,
              STCLASS=STATIC );
 
/**/
/* EXTERNAL items */
/**/
DCL F$STD                    DCB;
DCL M$DO                     DCB;
DCL M$LO                     DCB;
DCL M$SI                     DCB;
DCL M$STRING                 DCB;
DCL M$TEST                   DCB;
DCL M$UI                     DCB;
 
DCL GOPHER$ALLOC             ENTRY(1);
DCL GOPHER$BREAK             ENTRY     ASYNC;
DCL GOPHER$ERR               ENTRY(2);
DCL GOPHER$REL               ENTRY(1);
DCL X$WILDCMP                ENTRY(1)  ALTRET;
DCL X$WRITE                  ENTRY(22);
DCL XSF$LOCCODT              ENTRY(2)  ALTRET;
 
DCL B$JIT$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
%EJECT;
/**/
/* BASED */
/**/
DCL FILEBUFARS               CHAR(ARS) BASED(FILEBUF$);
DCL BUFI                     CHAR(I)   BASED;
DCL BUFK                     CHAR(K)   BASED;
 
 
/**/
/* BASED structures */
/**/
DCL 1 STRBUFECHO  BASED,
      2 *                    CHAR(1),
      2 BUFF                 CHAR(I);
DCL 1 FILEBUFECHO  BASED,
      2 KEY                  CHAR(10),
      2 SP                   CHAR(2),
      2 REC                  CHAR(ARS);
%EJECT;
/**/
/* BITs, STATIC */
/**/
DCL DONE                     BIT(1)    STATIC   SYMDEF   ALIGNED  INIT(%NO#);
DCL COUNTED                  BIT(1);
DCL FLG$ALL                  BIT(36)   STATIC INIT('0'B);
DCL FLG$LODO                 BIT(1)    STATIC   SYMDEF   ALIGNED;
DCL FLGS(0:71)               BIT(1)    ALIGNED STATIC SYMDEF;
DCL IGNORE_ORG(0:35)         BIT(1)    STATIC INIT('0'B*0);
DCL ORG(0:35)                BIT(1)    STATIC INIT('0'B*0);
DCL NO_CRITERIA              BIT(1)    STATIC INIT(%YES#);
DCL WE_SHOULD_QUIT_NOW       BIT(1)    STATIC   SYMDEF   ALIGNED  INIT('0'B);
%EJECT;
/**/
/* CHARacter, STATIC */
/**/
DCL BREAK_PRMPT              CHAR(0)   STATIC INIT(': ');
DCL FMT1                     CHAR(0)   STATIC INIT(
    '>>> Invalid fid %A at line %D of STD file %>A. <<<');
DCL FMT2                     CHAR(0)   STATIC INIT(
    '.. One match found in one of the %D file(s) searched.');
DCL FMT3                     CHAR(0)   STATIC INIT(
    '.. %D matches found in %D of the %D file(s) searched.');
DCL FMT4                     CHAR(0)   STATIC INIT(
    '.. No matches found in the %D file(s) searched.');
DCL FMT5                     CHAR(0)   STATIC INIT(
    '.. There were %D records which were too long to be searched completely.');
DCL FMT6                     CHAR(0)   STATIC INIT(
    '.. One Match found in %>A.');
DCL FMT7                     CHAR(0)   STATIC INIT(
    '.. %D Matches found in %>A.');
DCL FMT8                     CHAR(0)   STATIC INIT(
    ' ');
DCL FMT9                     CHAR(0)   STATIC INIT(
    ' ');
DCL FMT10                    CHAR(0)   STATIC INIT(
    'Current SI: %A  Current FMA: %A   Options: %A');
DCL INCLUDE_FID              CHAR(59);
DCL INT2                     CHAR(2);
DCL ITYPE(0:99)              CHAR(2);
DCL LAST_FID                 CHAR(31)  STATIC INIT('}}}}}}}}}}}}}}}}}}}}}}}}}');
DCL LO_BUF                   CHAR(132) STATIC;
DCL MSG1                     CHAR(0)   STATIC INIT(
    'WARNING: A ? appeared in 1 or more strings but the WILDCARD option was omitted.');
DCL MSG2                     CHAR(0)   STATIC INIT(
    '>>> *ERROR*  NO strings were specified; I quit! <<<');
DCL MSG4                     CHAR(0)   STATIC INIT(
    'Error opening M$UI');
DCL MSG6                     CHAR(0)   STATIC INIT(
    'Error reading M$SI');
DCL MSG7                     CHAR(0)   STATIC INIT(
    'Error reading M$UI');
DCL MSG9                     CHAR(0)   STATIC INIT(
    '** Too Many Strings for me, I quit.');
DCL ORIG_ACCT                CHAR(8);
DCL STD_REC                  CHAR(80)  STATIC;
DCL STRCHARS                 CHAR(1999);
DCL 1 TMP REDEF STRCHARS,
      2 USER,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 DFLT,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 ALL,
        3 OPTS_LEN           SBIN(9)   CALIGNED,
        3 OPTS               CHAR(255) CALIGNED,
      2 BUF                  CHAR(256) CALIGNED,
      2 *                    CHAR(975) CALIGNED;
DCL SUFFIX                   CHAR(2);
DCL TMP_BUF                  CHAR(256);
DCL TYPES(0:99)              CHAR(2);
DCL UPPERS(0:63) CONSTANT BIT(72) INIT(
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O,
    '000001002003004005006007'O,'010011012013014015016017'O,
    '020021022023024025026027'O,'030031032033034035036037'O,
    '040041042043044045046047'O,'050051052053054055056057'O,
    '060061062063064065066067'O,'070071072073074075076077'O,
    '100101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132133134135136137'O,
    '140101102103104105106107'O,'110111112113114115116117'O,
    '120121122123124125126127'O,'130131132173174175176177'O);
DCL WILDCHAR                 CHAR(1);
%EJECT;
/**/
/* PTRs, STATIC or CONSTANT */
/**/
DCL BASE$                    PTR;
DCL BLK1$                    PTR;
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL FILEBUF$                 PTR       CONSTANT INIT(ADDR(FILEBUF.REC));
DCL M$LO$                    PTR;
DCL M$SI$                    PTR       STATIC  SYMDEF;
DCL F$STD$                   PTR;
DCL M$STRING$                PTR;
DCL M$TEST$                  PTR;
DCL M$UI$                    PTR;
DCL STRING_PTR$(0:99)        PTR       STATIC INIT(ADDR(NIL)*0);
DCL SUBPTR$                  PTR;
DCL UPD$                     PTR;
%EJECT;
/**/
/* SBIN */
/**/
DCL AFTER                    UBIN      STATIC   INIT(0);
DCL BASE#                    SBIN;
DCL BEFORE                   UBIN      STATIC   INIT(0);
DCL BROKEN                   SBIN      STATIC   SYMDEF   INIT(0);
DCL CIRC_CNT                 SBIN      STATIC   INIT(0);
DCL CIRC_REC_NUM             SBIN      STATIC   INIT(18);
DCL CIRC_SIZE                SBIN      STATIC   INIT(0);
DCL FID_LEN                  SBIN;
DCL I                        SBIN      STATIC;
DCL INCLUDE_LEVEL            UBIN      STATIC SYMDEF;
DCL J                        SBIN      STATIC;
DCL K                        SBIN      STATIC;
DCL L                        SBIN      STATIC;
DCL LDCOUNT                  SBIN      STATIC SYMDEF INIT(0);
DCL M                        SBIN      STATIC;
DCL NRECS                    SBIN;
DCL DEPTH_TO_CHECK           SBIN;
DCL NUM_ACCTS                SBIN      STATIC INIT(0);
DCL NUM_FILES_SEARCHED       SBIN      SYMDEF STATIC INIT(0);
DCL NUM_ITYPES               SBIN      STATIC INIT(0);
DCL NUM_FILES_MATCHED        SBIN      STATIC INIT(0);
DCL NUM_MATCHES              SBIN      STATIC INIT(0);
DCL NUM_REMAINING            SBIN      STATIC INIT(0);
DCL NUM_SKIPS                SBIN      STATIC INIT(0);
DCL NUM_TYPES                SBIN      STATIC INIT(0);
DCL NUM_UI_ACCTS             SBIN;
DCL PASS                     SBIN;
DCL PROMPT_LEN               SBIN;
DCL QUES_POS                 SBIN;
DCL REC#(0:11)               SBIN      STATIC  SYMDEF  INIT(0*0);
DCL RELATION                 SBIN;
DCL STD_ARS                  SBIN      STATIC INIT(0);
DCL STD_CNT                  SBIN      STATIC INIT(0);
DCL TOTAL_LDCOUNT            SBIN      STATIC INIT(0);
DCL TOTAL_MATCHES            SBIN      STATIC INIT(0);
DCL UPD#                     SBIN;
DCL WILD_STRINGS             SBIN;
DCL WORK(0:1023)             SBIN;
DCL X                        UBIN;
%EJECT;
/**/
/* UBINs */
/**/
DCL ARS                      UBIN      STATIC   INIT(0);
DCL ERRDCB                   UBIN      STATIC INIT(0);
DCL LISTED                   UBIN      STATIC   SYMDEF INIT(2);
DCL STRING_LEN(0:99)         UBIN      STATIC INIT(0*0);
DCL STRING_LNK(0:99)         UBIN      STATIC INIT(0*0);
DCL STRSOFAR                 UBIN      STATIC INIT(0);
%EJECT;
/**/
/* STRUCTURES */
/**/
DCL 1 ACCT_LIST(0:9),
      2 ACCT                 CHAR(8),
      2 SN                   CHAR(6);
DCL 1 FILEBUF  STATIC,
      2 KEY                  CHAR(10),
      2 SP                   CHAR(2)          INIT('  '),
      2 REC                  CHAR(%OBUFSIZ);
DCL 1 CIRC_BUF(0:18),
      2 KEY                  CHAR(10),
      2 SP                   CHAR(2),
      2 REC                  CHAR(%OBUFSIZ),
      2 ARS                  UBIN;
DCL 1 INCLUDE_INFO(0:11) STATIC SYMDEF,
      2 NAME                 CHAR(59),
      2 NRECS                UBIN,
      2 LEN                  UBIN;
DCL 1 SAVEBUF,
      2 KEY                  CHAR(10),
      2 SP                   CHAR(2),
      2 REC                  CHAR(%OBUFSIZ);
DCL 1 SAVE_EBCDIC_BUF,
      2 KEY                  CHAR(10),
      2 SP                   CHAR(2),
      2 REC                  CHAR(%OBUFSIZ);
DCL 1 SKIP(0:99),
      2 L#                   UBIN(9)   UNAL,
      2 NAME#                CHAR(31)  UNAL,
      2 WILD                 BIT(9)    UNAL;
DCL 1 STRBUF  STATIC,
      2 *                    CHAR(1)          INIT('*'),
      2 BUFF                 CHAR(255);
DCL 1 START  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 FID                  CHAR(31)  UNAL;
 
DCL 1 TARGET,
      2 L#                   UBIN(9)   UNAL,
      2 NAME#                CHAR(31)  UNAL;
 
DCL 1 THIS_FILE  STATIC,
      2 L                    UBIN(9)   UNAL  INIT(LENGTHC('GOPHER_X_DEFAULTS')),
      2 C                    CHAR(31)  UNAL   INIT('GOPHER_X_DEFAULTS');
 
DCL 1 UI_LIST(0:%(MAX_UI_ACCTS-1)),
      2 ACCT                 CHAR(8),
      2 SN                   CHAR(6);
 
DCL 1 TEXTTBL,
      2 STR                  CHAR(512);
%EJECT;
/**/
/* VECTORs */
/**/
DCL FILEBUFVECT             BIT(72) DALIGNED CONSTANT INIT(VECTOR(FILEBUF.REC));
 
DCL FMT1_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT1));
DCL FMT2_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT2));
DCL FMT3_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT3));
DCL FMT4_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT4));
DCL FMT5_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT5));
DCL FMT6_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT6));
DCL FMT7_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT7));
DCL FMT8_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT8));
DCL FMT9_                    BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT9));
DCL FMT10_                   BIT(72)   STATIC DALIGNED INIT(VECTOR(FMT10));
 
DCL VEC1_                    BIT(72);
DCL VEC2_                    BIT(72);
DCL VEC3_                    BIT(72);
DCL VEC4_                    BIT(72);
DCL VEC5_                    BIT(72);
DCL VEC6_                    BIT(72);
DCL VEC7_                    BIT(72);
DCL VEC8_                    BIT(72);
DCL VEC9_                    BIT(72);
%EJECT;
START_HERE:
 
    CALL SETUP  ALTRET( CALL_ERRMSG ); /* OPEN M$LO,take BRK cntrl, init stuff*/
    CALL PARSE_THE_OPTIONS  ALTRET( SET_THE_STEPCC );
 
    CALL INFORM_EM;
 
    CALL GETSTRINGS;
 
    CALL READ_STD_REC  ALTRET( CALL_ERRMSG ); /* Set up M$SI and M$UI         */
 
    CALL M$INT( BREAK_CNTRL )  ALTRET( CALL_ERRMSG );
 
    DO WHILE( NOT DONE );
NEXT_FILE:
          CALL OPNIN  ALTRET( NEXT_STD_FILE );
          CALL DO_WE_WANT_THIS_FILE  ALTRET( ANOTHER );
          CALL READLOOK;
          TOTAL_MATCHES= TOTAL_MATCHES + NUM_MATCHES;
          NUM_MATCHES= 0;
ANOTHER:
          CALL XUU$CLOSE( XUU_PARAM );
          IF FLG$ALL  AND  (NOT DONE)  THEN
             GOTO NEXT_FILE;
NEXT_STD_FILE:
       IF WE_SHOULD_QUIT_NOW THEN
          DONE= %YES#;
       ELSE DO;
          DONE= %NO#;
          CALL READ_STD_REC  ALTRET( CLOSE_EM );
          END;
       END;
 
    DO WHILE('0'B);
CALL_ERRMSG:
       ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
       ERRDCB=  B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
       CALL REPORTERR;
SET_THE_STEPCC:
       SET_STEPCC.V.STEPCC#= 4;               /* Indicate some error occurred */
       END;
 
CLOSE_EM:
    VEC1_= VECTOR(TOTAL_MATCHES);
    VEC2_= VECTOR(NUM_FILES_MATCHED);
    VEC3_= VECTOR(NUM_FILES_SEARCHED);
    IF FLGS(%RESIDUAL##) AND FLGS(%QUIT##) THEN
       IF STRING_LEN(0) > 0 THEN DO;
          LO_BUF= '.. The following string(s) were NOT found:';
          FPT_WRERR.BUF_= VECTOR(SUBSTR(LO_BUF,0,42));
          CALL M$WRITE(FPT_WRERR);
          J= 0;
          DO WHILE( STRING_LEN(J) > 0 );
             I= STRING_LEN(J);
             FPT_WRERR.BUF_= VECTOR(STRING_PTR$(J)->BUFI);
             CALL M$WRITE(FPT_WRERR);
             J= J+1;
             END;
          END;
    IF NOT FLGS(%NO_SUMMARY##) THEN DO;
       IF TOTAL_MATCHES = 1 THEN
          CALL X$WRITE( F_FDS,FMT2_,VEC3_ );
       ELSE
          IF TOTAL_MATCHES = 0 THEN
             CALL X$WRITE( F_FDS,FMT4_,VEC3_ );
          ELSE
             CALL X$WRITE( F_FDS,FMT3_,VEC1_,VEC2_,VEC3_ );
       IF NOT FLGS(%MAKESTD##) THEN DO;
          WRFNAME.BUF_= VECTOR(SUBSTR(LO_BUF,1,F_FDS.BUFX-1));
          CALL M$WRITE( WRFNAME );
          END;
       IF NOT FLG$LODO THEN DO;
          FPT_WRERR.BUF_= VECTOR(SUBSTR(LO_BUF,1,F_FDS.BUFX-1));
          CALL M$WRITE( FPT_WRERR );
          END;
       END;
    CALL CLOSE(DCBNUM(M$LO));
    CALL CLOSE(DCBNUM(M$DO));
    CALL M$EXIT( SET_STEPCC );
%EJECT;
/*D*    NAME:    CLOSE
*       CALL:    CALL CLOSE(ODCB);
*       INPUT:   ODCB - DCB number of DCB to close
*       DESCRIPTION:  Closes the specified DCB with save if it is open
*/
 
CLOSE: PROC(ODCB);
 /* Parameters */
  DCL ODCB UBIN;
 
    IF DCBADDR(ODCB)->F$DCB.FCD# THEN DO;
       FPT_CLSSAV.V.DCB#=ODCB;
       CALL M$CLOSE(FPT_CLSSAV);
       END;
    RETURN;
END CLOSE;
 
 
%EJECT;
LISTER: PROC;
DCL I UBIN;
DCL LEN UBIN;
DCL WIDTH UBIN;
/* */
    LISTED=1;
       TMP_BUF=' ';
       IF M$LO$->F$DCB.WIDTH# = 0 THEN
          WIDTH=80;
       ELSE
          IF M$LO$->F$DCB.WIDTH# > 256 THEN
             WIDTH=256;
          ELSE
             WIDTH=M$LO$->F$DCB.WIDTH#;
 
       IF FLGS(%STD##) AND NOT (BASE$->F$DCB.ACCT# = ' ') THEN DO;
          CALL INSERT(TMP_BUF, 0, 59, SUBSTR(BASE$->F$DCB.NAME#.C, 0,
             BASE$->F$DCB.NAME#.L), '.',
             BASE$->F$DCB.ACCT#);
          CALL INDEX(LEN, ' ', TMP_BUF);
          END;
       ELSE DO;
          CALL INSERT(TMP_BUF, 0, 80, BASE$->F$DCB.NAME#.C);
          LEN=BASE$->F$DCB.NAME#.L;
          END;
       IF NUM_UI_ACCTS > 1  AND  UPD$->F$DCB.FCD# THEN DO;
          IF UPD$->F$DCB.ACCT# = ' ' THEN
             CALL INSERT( TMP_BUF,LEN, ,' (updates from .',B$JIT.FACCN );
          ELSE
             CALL INSERT( TMP_BUF,LEN, ,' (updates from .',UPD$->F$DCB.ACCT# );
          CALL INDEX( LEN,'  ',TMP_BUF );
          SUBSTR(TMP_BUF,LEN,1)= ')';
          LEN= LEN + LENGTHC(')');
          END;
 
       WRFNAME.BUF_.BUF$=ADDR(TMP_BUF);
       DO I=0 TO XUU_PARAM.LEVEL-1;
          IF INCLUDE_INFO.LEN(I)+LEN+4 > WIDTH THEN DO;
             WRFNAME.BUF_.BOUND=LEN-1;
             CALL M$WRITE(WRFNAME);
             LEN=0;
             END;
 
          CALL INSERT(TMP_BUF, LEN, 4, ' -> ');
          CALL INSERT(TMP_BUF, LEN+4, INCLUDE_INFO.LEN(I),
             INCLUDE_INFO.NAME(I));
          LEN=LEN+INCLUDE_INFO.LEN(I)+4;
       END;
 
       IF LEN > 0 THEN DO;
          WRFNAME.BUF_.BOUND=LEN-1;
          CALL M$WRITE(WRFNAME);
          END;
 
    RETURN;
END LISTER;
%EJECT;
 
DOLISTER: PROC;
    LISTED=2;
    IF FLGS(%STD##)  AND NOT (BASE$->F$DCB.ACCT# = ' ') THEN DO;
       CALL CONCAT( TMP_BUF,SUBSTR(BASE$->F$DCB.NAME#.C,0,BASE$->F$DCB.NAME#.L),
                             '.',BASE$->F$DCB.ACCT# );
       FPT_WRERR.BUF_= VECTOR(SUBSTR(TMP_BUF,0,BASE$->F$DCB.NAME#.L));
       END;
    ELSE
       FPT_WRERR.BUF_=VECTOR(BASE$->F$DCB.NAME#.C);
    CALL M$WRITE(FPT_WRERR);
    RETURN;
END DOLISTER;
%EJECT;
/*D*    NAME:    OPNIN
*       CALL:    CALL OPNIN;
*       DESCRIPTION:  Opens the appropriate input DCBs via the
*        Common Update Package.
*/
 
OPNIN: PROC ALTRET;
 
NEXTF:
    CALL XUU$CLOSE( XUU_PARAM )  ALTRET( ERR );
 
 
    LISTED=0;
 /*      If this is a single file (FLG$ALL not set), just set the
    base and UP_DATE flags for XUU$READ.
    If it is a many-file request, need to get the input dcbs
    pointing to the proper next file.  We have previously
    fixed it so that OPENSI$NEXT opens nextfile on the master
    dcb (M$SI or M$UI), and FPT_SETIN sets the master dcb's
    file name into the other dcb.
 */
    IF FLG$ALL THEN DO;
        CALL NEXT_BASE ALTRET(NXTERR);
        IF FLGS(%UI##) THEN
            CALL READY_UI_DCB;
        END;
    ELSE
       IF FLGS(%STD##)  AND  FLGS(%UI##) THEN
          CALL READY_UI_DCB;
    XUU_PARAM.FLAGS.BASE#='1'B;
    IF FLGS(%UI##) THEN
        XUU_PARAM.FLAGS.UP_DATE#='1'B;
    CALL XUU$OPEN(XUU_PARAM) ALTRET(ERR);
       INCLUDE_LEVEL=XUU_PARAM.LEVEL;
    RETURN;
%EJECT;
ERR:
    IF FLG$ALL THEN DO;
       IF XUU_PARAM.UI_ERRCODE.ERR# = %E$NOFILE THEN
          RETURN;
       IF XUU_PARAM.SI_ERRCODE.ERR# = %E$STOWED_INACTIVE THEN
          GOTO NEXTF;
       IF XUU_PARAM.UI_ERRCODE.ERR# = %E$STOWED_INACTIVE THEN
          GOTO NEXTF;
       END;
    IF XUU_PARAM.FLAGS.BASE# THEN DO;
        ERRCODE=XUU_PARAM.SI_ERRCODE;
        ERRDCB=DCBNUM(M$SI);
        CALL REPORTERR;
        END;
 
    IF XUU_PARAM.FLAGS.UP_DATE# THEN DO;
        ERRCODE=XUU_PARAM.UI_ERRCODE;
        ERRDCB=DCBNUM(M$UI);
        CALL REPORTERR(MSG4,SIZEC(MSG4));
        END;
    IF FLG$ALL THEN
       GOTO NEXTF;
NXTERR:
    ALTRETURN;
 
END OPNIN;
%EJECT;
/*D*    NAME:    READLOOK
*       CALL:    CALL READLOOK;
*       DESCRIPTION:  Reads input and looks for strings.
*/
READLOOK: PROC;
/**/
DCL DEPTH_CHECKED SBIN;
/**/
        NUM_FILES_SEARCHED= NUM_FILES_SEARCHED + 1;
        COUNTED= %NO#;
        REC#(0)= 0;
        DEPTH_CHECKED=0;
        IF CIRC_SIZE > 0 THEN                 /*Was BEFORE or AFTER specified?*/
           CIRC_REC_NUM= 18;                  /* Reset index into circular buf*/
        DO WHILE('1'B);
           CALL XUU$READ(XUU_PARAM,FILEBUFVECT) ALTRET(ERR);
           DEPTH_CHECKED=DEPTH_CHECKED+1;
           INCLUDE_LEVEL=XUU_PARAM.LEVEL;
           REC#(XUU_PARAM.LEVEL)=REC#(XUU_PARAM.LEVEL)+1;
           ARS=XUU_PARAM.ARS;
           IF CIRC_SIZE > 0 THEN DO; /* Was AFTER or BEFORE options specified?*/
              FILEBUF.SP= '  ';
              FILEBUF.KEY=XUU_PARAM.ASCII_KEY;
              CIRC_REC_NUM= MOD(CIRC_REC_NUM+1,CIRC_SIZE);
              CIRC_BUF(CIRC_REC_NUM)= FILEBUF;
              CIRC_BUF.ARS(CIRC_REC_NUM)= ARS;
              END;
/*
  This is where EBCDIC -> ASCII is done if an EBCDIC input file option was
specified.
*/
           IF FLGS(%EBCDIC##) THEN DO;
              SAVE_EBCDIC_BUF=FILEBUF;
              CALL XLATE (FILEBUF.REC,B$XL_EBC_ASC,FILEBUF.REC);
              END;
/*
  This is where the depth to check is ahndles if DEPTH was specified on
the command line.
*/
           IF FLGS(%DEPTH##) THEN
              IF DEPTH_CHECKED > DEPTH_TO_CHECK
                 THEN GOTO USER_SED_QUIT;
           IF FLGS(%UC##) THEN DO;
              SAVEBUF=FILEBUF;
              CALL XLATE(FILEBUF.REC,UPPERS,FILEBUF.REC);
              END;
           IF FLGS(%TEXT_FILES_ONLY##) THEN
              CALL SEARCH( J,J,TEXTTBL,FILEBUFARS )
              WHENRETURN DO;
                 GOTO USER_SED_QUIT; /* Oops, found non-text; quit */
                 END;
           J=0;
           DO WHILE (NOT (STRING_LEN(J)=0));
              K=STRING_LEN(J);
              CALL INDEX(L,STRING_PTR$(J)->BUFK,FILEBUFARS)  ALTRET(PQRST);
              IF NOT (STRING_LNK(J)=0) THEN DO;
                 M=STRING_LNK(J);
                 L=L+STRING_LEN(J);
                 SUBPTR$=PINCRC(ADDR(FILEBUF.REC),L);
                 I=ARS-L;
MOREWC:          K=STRING_LEN(M);
                 CALL INDEX(L,STRING_PTR$(M)->BUFK,SUBPTR$->BUFI) ALTRET(PQRST);
                 IF NOT (STRING_LNK(M)=0) THEN DO;
                    L=L+STRING_LEN(M);
                    I=I-L;
                    SUBPTR$=PINCRC(SUBPTR$,L);
                    M=STRING_LNK(M);
                    GOTO MOREWC;
                    END;
                 END;
              IF LISTED=0 THEN DO;
                 IF NOT FLGS(%TALLYONLY##) THEN
                    CALL LISTER;
                 IF NOT COUNTED THEN DO;
                    COUNTED= %YES#;
                    NUM_FILES_MATCHED= NUM_FILES_MATCHED + 1;
                    END;
                 END;
              IF FLGS(%UC##) THEN
                 FILEBUF=SAVEBUF;
              FILEBUF.KEY=XUU_PARAM.ASCII_KEY;
              NUM_MATCHES= NUM_MATCHES + 1;
              IF NOT (FLGS(%TALLYONLY##) OR FLGS(%MAKESTD##)) THEN DO;
                 IF CIRC_SIZE > 0 THEN DO;
                    IF CIRC_CNT = 0 THEN DO;
                       IF REC#(XUU_PARAM.LEVEL) >= BEFORE THEN
                          X= MOD(CIRC_REC_NUM + (CIRC_SIZE - BEFORE),
                                 CIRC_SIZE );
                       ELSE
                          X= 0;
                       DO WHILE(NOT (X = CIRC_REC_NUM));
                          FPT_LS.BUF_.BUF$= ADDR(CIRC_BUF(X));
                          FPT_LS.BUF_.BOUND= CIRC_BUF.ARS(X) + 11;
                          CALL M$WRITE( FPT_LS );
                          X= MOD( X + 1,CIRC_SIZE );
                       END;
 
                       FPT_LS.BUF_.BUF$= ADDR(FILEBUF);
                       CIRC_CNT= 1;
                       END;
 
                    FILEBUF.SP= '>>';
                    NUM_REMAINING= AFTER;
                    END;
 
                 FPT_LS.BUF_.BOUND=SIZEV(ADDR(FILEBUF)->FILEBUFECHO);
                 CALL M$WRITE(FPT_LS) ALTRET(LSERR);
                 END;
              IF FLGS(%QUIT##) THEN DO;
                 I=J;
                 DO WHILE (NOT (STRING_LEN(I)=0));
                   STRING_LEN(I) = STRING_LEN(I+1);
                   STRING_PTR$(I) = STRING_PTR$(I+1);
                   STRING_LNK(I) = STRING_LNK(I+1);
                   I=I+1;
                 END;
                 IF STRING_LEN(0)=0 THEN DO;
                   DONE = %YES#;
                   GOTO RE_TURN;
                 END;
                 J=J-1;
              END;
              GOTO VWXYZ;
PQRST:        J=J+1;
              END; /* DO WHILE(NOT (STRING_LEN(J) = 0)); */
 
           IF NUM_REMAINING > 0 THEN DO;
              FPT_LS.BUF_.BOUND= SIZEV(ADDR(FILEBUF)->FILEBUFECHO);
              CALL M$WRITE( FPT_LS ) ALTRET( LSERR );
              NUM_REMAINING= NUM_REMAINING - 1;
              END;
           IF CIRC_SIZE > 0  AND  NUM_REMAINING = 0  AND  CIRC_CNT > 0  THEN DO;
              CIRC_CNT= 0;
              FILEBUF.KEY= ' ';
              FPT_LS.BUF_.BOUND= 0;
              CALL M$WRITE( FPT_LS )  ALTRET( LSERR );
              END;
           IF FLGS(%SRCH##) THEN
              CALL SEARCH_INCLUDE;
VWXYZ:
           IF BROKEN > 0 THEN DO;
              IF BROKEN = 1 THEN              /* Just skipping this file?     */
                 BROKEN= 0;                   /* Pretend like they never BRKd */
              GOTO USER_SED_QUIT;
              END;
           END; /* DO WHILE( '1'B ); */
ERR: ;
    IF XUU_PARAM.ERRCODE.ERR# = %E$EOF THEN DO;
USER_SED_QUIT:
       IF NOT (LDCOUNT = 0) THEN DO;
          ERRCODE= '0'B;
          IF NOT FLGS(%IGNORE_ERRORS##) THEN DO;
             CALL X$WRITE( F_FDS,FMT5_,VECTOR(LDCOUNT) );
             CALL REPORTERR( SUBSTR(LO_BUF,1),F_FDS.BUFX-1 );
             END;
          TOTAL_LDCOUNT= TOTAL_LDCOUNT + LDCOUNT;
          LDCOUNT= 0;
          END;
       IF FLGS(%TALLY##)  AND  NUM_MATCHES > 0  THEN DO;
          VEC1_= VECTOR(NUM_MATCHES);
          VEC2_= VECTOR(BASE$->F$DCB.NAME#.C);
          IF NUM_MATCHES = 1 THEN
             CALL X$WRITE( F_FDS,FMT6_,VEC2_ );
          ELSE
             CALL X$WRITE( F_FDS,FMT7_,VEC1_,VEC2_ );
          CALL REPORTERR( SUBSTR(LO_BUF,1),F_FDS.BUFX-1 );
          END;
       END;
    ELSE DO;
       ERRCODE=XUU_PARAM.ERRCODE;
       IF XUU_PARAM.FLAGS.BASE# THEN DO;
          ERRDCB=DCBNUM(M$SI);
          CALL REPORTERR(MSG6,SIZEC(MSG6));
          END;
       ELSE
          IF XUU_PARAM.FLAGS.UP_DATE# THEN DO;
             ERRDCB=DCBNUM(M$UI);
             CALL REPORTERR(MSG7,SIZEC(MSG7));
             END;
          ELSE
             CALL REPORTERR;
       END;
RE_TURN:
    RETURN;
/**/
LSERR:  ERRDCB=DCBNUM(M$LO);
        ERRCODE=B$TCB$->B$TCB.ALT$->B$ALT.ERR;
        CALL REPORTERR;
        CALL M$ERR;
END READLOOK;
%EJECT;
SEARCH_INCLUDE: PROC;
DCL I UBIN;
 
       CALL INDEX(I, 'INCLUDE', FILEBUFARS) WHENALTRETURN DO;
          CALL INDEX( I, ' COPY ', FILEBUFARS)  ALTRET(NONE);
          END;
 
       GOPHER_OPTS.TEXT$=ADDR(FILEBUFARS);
       GOPHER_OPTS.NCHARS=ARS;
       GOPHER_OPTS.ROOT$=ADDR(PL6_INCLUDE);
       CALL X$PARSE(GOPHER_OPTS) WHENALTRETURN DO;
          GOPHER_OPTS.ROOT$=ADDR(FORT_INCLUDE);
          CALL X$PARSE(GOPHER_OPTS) WHENALTRETURN DO;
             IF ARS > LENGTHC('       COPY ') THEN DO;
                GOPHER_OPTS.TEXT$=PINCRC(ADDR(FILEBUFARS),LENGTHC('      '));
                GOPHER_OPTS.NCHARS= ARS - LENGTHC('      ');
                GOPHER_OPTS.ROOT$=ADDR(COBOL_COPY);
                CALL X$PARSE(GOPHER_OPTS) ALTRET(NONE);
                END;
             ELSE
                GOTO NONE;
             END;
          END;
 
       BLK1$=GOPHER_OPTS.OUT$;
       IF %BLK1_NSUBLKS > 1 THEN
          BLK2$=%BLK1_SUBLK$(1);
       ELSE
          BLK2$=BLK1$;
 
       INCLUDE_FID=%BLK2_TEXT;
       FID.TEXTFID_=VECTOR(INCLUDE_FID);
       CALL M$FID(FID) ALTRET(NONE);
       OPEN_INCLUDE.V.OPER.TEST#='1'B;
       IF NOT (AN_ACCT.ACCT# = ' ') THEN DO;
          CALL M$OPEN(OPEN_INCLUDE) ALTRET(ERR);
          END;
       ELSE DO;
LOOP:     DO I=0 TO NUM_ACCTS-1;
             AN_ACCT.ACCT#=ACCT_LIST.ACCT(I);
             A_SN.SN#(0)=ACCT_LIST.SN(I);
             CALL M$OPEN(OPEN_INCLUDE) ALTRET(NEXT);
             EXIT LOOP;
NEXT:     END;
          IF I > NUM_ACCTS THEN
             GOTO ERR;
          END;
 
       XUU_PARAM.O.FPT_PTR$=ADDR(OPEN_INCLUDE);
       OPEN_INCLUDE.V.OPER.TEST#='0'B;
 
       CALL M$OPEN(OPEN_INCLUDE) ALTRET(ERR);
       INCLUDE_INFO.NRECS(XUU_PARAM.LEVEL)=M$TEST$->F$DCB.NRECS#;
       UNFID_INCLUDE.TEXTFID_=VECTOR(INCLUDE_INFO.NAME(XUU_PARAM.LEVEL));
       UNFID_INCLUDE.LEN_=VECTOR(INCLUDE_INFO.LEN(XUU_PARAM.LEVEL));
       CALL M$UNFID(UNFID_INCLUDE) ALTRET(ERR);
       CALL M$CLOSE(CLOSE_INCLUDE) ALTRET(ERR);
 
       /*
           Check for possible %INCLUDE recursion which can happen when
           a %INCLUDE statement occurs as a comment inside a INCLUDE
           file (Eg. the file B$TABLES_C contains a comment that has a
           '%INCLUDE B$TABLES_C;' in it!).
       */
       DO I=0 TO XUU_PARAM.LEVEL-1;
          IF INCLUDE_INFO.NAME(I) = INCLUDE_INFO.NAME(XUU_PARAM.LEVEL) THEN
                                                          GOTO NONE;
          END;
 
       XUU_PARAM.FLAGS.INCLUDE#=%YES#;
       XUU_PARAM.FLAGS.FAST_INCLUDE#=%YES#;
       XUU_PARAM.FLAGS.BASE#=%NO#;
       XUU_PARAM.FLAGS.UP_DATE#=%NO#;
 
       CALL XUU$OPEN(XUU_PARAM);
       XUU_PARAM.FLAGS.INCLUDE#=%NO#;
       XUU_PARAM.FLAGS.FAST_INCLUDE#=%NO#;
       XUU_PARAM.FLAGS.BASE#=%YES#;
       XUU_PARAM.FLAGS.UP_DATE#=%YES#;
 
       INCLUDE_LEVEL=XUU_PARAM.LEVEL;
       REC#(XUU_PARAM.LEVEL)=0;
       LISTED=0;
 
NONE:  RETURN;
ERR:   ERRCODE=B$TCB$->B$TCB.ALT$->B$ALT.ERR;
       ERRDCB=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
       CALL REPORTERR;
       RETURN;
       END SEARCH_INCLUDE;
       %EJECT;
%EJECT;
GETSTRINGS:PROC  ALTRET;
 
    IF NOT M$STRING$->F$DCB.FCD# THEN DO;     /* Is M$STRING open?            */
       OPENASIS.V.DCB#=DCBNUM(M$STRING);      /* Nope.  OPEN it.              */
       OPENASIS.V.FUN#=%IN#;
       CALL M$OPEN(OPENASIS);
       END;
    STRCHARS= ' ';                            /* Clear string area            */
    WILD_STRINGS= 0;                          /* How many strings read had ?'s*/
    L=98;
    DO J=0 TO L;
GET_A_STRING:
       CALL READ_A_STRING( J+1 )  ALTRET( LASTSTRG );
       IF I=0 THEN
          GOTO LASTSTRG;
       IF FLGS(%UC##) THEN
          CALL XLATE(SUBSTR(STRBUF.BUFF,0,I),UPPERS,SUBSTR(STRBUF.BUFF,0,I));
       IF I+STRSOFAR>LENGTHC(STRCHARS) THEN
          GOTO RE_TURN;
       STRING_LEN(J)=I;
       STRING_PTR$(J)=ADDR(SUBSTR(STRCHARS,STRSOFAR));
       STRING_PTR$(J)->BUFI=STRBUF.BUFF;
       STRSOFAR=STRSOFAR+I;
       IF FLGS(%WILDCARD##) THEN DO;
          M=J;
MOREWILD: CALL INDEX1(K,WILDCHAR,STRING_PTR$(M)->BUFI)ALTRET(NOWC);
          IF K>0 THEN DO;
             IF J=L THEN
                GOTO NOWC;
             STRING_LNK(M)=L;
             STRING_LEN(L)=I-K-1;
             I=I-K-1;
             STRING_LEN(M)=K;
             STRING_PTR$(L)=PINCRC(STRING_PTR$(M),K+1);
             M=L;
             L=L-1;
             GOTO MOREWILD;
             END;
          IF I=1 THEN
             GOTO NOWC;
          I=I-1;
          STRING_PTR$(M)=PINCRC(STRING_PTR$(M),1);
          STRING_LEN(M)=STRING_LEN(M)-1;
          GOTO MOREWILD;
NOWC:     END;
       ELSE DO;
          CALL INDEX( M,'?',SUBSTR(STRBUF.BUFF,0,I) )  ALTRET( NOT_WILD );
          WILD_STRINGS= WILD_STRINGS + 1;
NOT_WILD:
          END;
       END;
    CALL REPORTERR(MSG9,SIZEC(MSG9));
    CALL M$ERR;
LASTSTRG:
    IF J < 1 THEN                             /* Any strings entered?         */
       IF M$STRING$->F$DCB.DDEV.IC# THEN      /* Nope, is there a warm body?  */
          GOTO GET_A_STRING;                  /* Yep, be persistent!          */
       ELSE DO;
          CALL REPORTERR(MSG2,SIZEC(MSG2));
          CALL M$ERR;
          END;
    IF WILD_STRINGS > 0  AND  NOT FLGS(%WILDCARD##) THEN DO;
       FPT_WRERR.BUF_= VECTOR(MSG1);
       CALL M$WRITE( FPT_WRERR );
       END;
RE_TURN:
    SET_PROMPT.PROMPT_= VECTOR(BREAK_PRMPT);
    CALL M$PROMPT( SET_PROMPT );
    RETURN;
END GETSTRINGS;
%EJECT;
READ_A_STRING: PROC( NUM )  ALTRET;
DCL NUM                      UBIN;
 
    IF FLGS(%NO_PROMPT##) THEN DO;
       LO_BUF= '*';
       PROMPT_LEN= LENGTHC('*');
       END;
    ELSE DO;
       CALL BINCHAR( INT2,NUM );
       IF NUM < 11 OR
          NUM > 13 THEN
            IF SUBSTR(INT2,1,1) = '1' THEN
                 SUFFIX= 'st';
            ELSE IF SUBSTR(INT2,1,1) = '2' THEN
                      SUFFIX= 'nd';
                 ELSE IF SUBSTR(INT2,1,1) = '3' THEN
                           SUFFIX= 'rd';
                      ELSE SUFFIX= 'th';
       ELSE SUFFIX= 'th';
       IF NUM < 10 THEN DO;
            CALL CONCAT( LO_BUF,SUBSTR(INT2,1,1),SUFFIX,' string? ' );
            PROMPT_LEN= 1 + LENGTHC(SUFFIX) + LENGTHC(' string? ');
            END;
       ELSE DO;
            CALL CONCAT( LO_BUF,INT2,SUFFIX,' string? ' );
            PROMPT_LEN= 2 + LENGTHC(SUFFIX) + LENGTHC(' string? ');
            END;
       END;
    SET_PROMPT.PROMPT_= VECTOR(SUBSTR(LO_BUF,0,PROMPT_LEN));
    IF M$STRING$->F$DCB.DDEV.IC# THEN         /* Is M$STRING set to ME?       */
         CALL M$PROMPT( SET_PROMPT );         /* Yep.                         */
    CALL M$READ( READ_STRINGS )  ALTRET( EOF_STRINGS );
    I= M$STRING$->F$DCB.ARS#;
    IF NOT (M$STRING$->F$DCB.DDEV.IC#  AND
            M$LO$->F$DCB.DDEV.UCOUT#)  THEN
         IF (B$JIT.CPFLAGS1 & %CP_ECHO#) AND (NOT FLGS(%MAKESTD##))  THEN DO;
              SUBSTR(LO_BUF,PROMPT_LEN-2,1)= '=';
              SUBSTR(LO_BUF,PROMPT_LEN)= ADDR(STRBUF)->STRBUFECHO.BUFF;
              WRFNAME.BUF_= VECTOR(SUBSTR(LO_BUF,0,PROMPT_LEN+I));
              CALL M$WRITE(WRFNAME);
              END;
    RETURN;
 
EOF_STRINGS:
    ALTRETURN;
 
END READ_A_STRING;
%EJECT;
/*I*    NAME: OPENSI$SETUPTEST
        CALL: CALL OEPNSI$SETUPTEST(DCB number) ALTRET;
        DESCRIPTION: OPENSI$SETUPTEST sets up internal tables for
           opening specified files through the passed DCB.  The
           DCB's name is a question-mark string.  The idea is that
           subsequent calls to OPENSI$NEXT will return with the
           DCB open to successive files which match the string,
           until it finally ALTRETs.  The OPENs will be TEST.
           FPARAMs will be returned in FPARAMBUF.
*/
SETUP_BASE_TEST: PROC  ALTRET;
 
DCL 1 FLG  STATIC,
      2 ATALL                BIT(1)  INIT('0'B), /* See if anything to do     */
      2 QUICKIE              BIT(1)  INIT('0'B), /* Set if one of these is tru*/
      2 THISF                BIT(1)  INIT('0'B), /* First time, leading non-? */
      2 ONEFILE              BIT(1)  INIT('0'B), /* Doing exactly one file    */
      2 ALLFILE              BIT(1)  INIT('0'B), /* Doing all files in account*/
      2 *                    BIT(31) INIT('0'B);
 
SET_TEST_BIT:
    OPEN_BASE.V.OPER.TEST#= '1'B;
SETUP_BASE: ENTRY ALTRET;
    FLG$ALL= '0'B;
    FLG= '10000'B;                            /* Clear all but FLG.ATALL      */
    CALL INDEX( QUES_POS,'?',BASE_NAME.NAME# )  ALTRET( NO_QUESMARK );
    FLG$ALL= '1'B;
    IF FLGS(%START##) THEN DO;
       BASE_NAME= START;
       OPEN_BASE.V.OPER.THISF#= '1'B;
       END;
    ELSE
       BASE_NAME.L#= QUES_POS;
    OPEN_BASE.V.OPER.NXTF#= '1'B;
    OPEN_BASE.V.SETDCB#= '1'B;
    OPEN_BASE.NAME_= VECTOR(BASE_NAME);
    CALL M$OPEN( OPEN_BASE );                 /* Merge the NAME into the DCB  */
    OPEN_BASE.V.SETDCB#= '0'B;
    OPEN_BASE.NAME_= VECTOR(NIL);
    IF FLGS(%START##) THEN
       BASE_NAME= TARGET;
 
    IF BASE_NAME.NAME# = '?' THEN DO;         /* Just a '?' ?                 */
       FLG.QUICKIE= '1'B;                     /* Yep.                         */
       IF FLGS(%START##)  OR  FLGS(%END##)  THEN
          ;
       ELSE
          FLG.ALLFILE= '1'B;
       END;
    ELSE
       IF QUES_POS > 0 THEN DO;               /* Is name 'xxx?'               */
          FLG.QUICKIE= '1'B;
          FLG.THISF= '1'B;
          OPEN_BASE.V.OPER.THISF#= '1'B;
          END;
    GOTO RE_TURN;
 
NO_QUESMARK:
    FLG.QUICKIE= '1'B;
    IF BASE_NAME.NAME# = ' ' THEN DO;
       BASE_NAME.NAME#= '?';
       GOTO SET_TEST_BIT;
       END;
    ELSE DO;                                  /* Just one file                */
       FLG.ONEFILE= '1'B;
       OPEN_BASE.V.OPER.NXTF#= '0'B;
       IF FLGS(%STD##) THEN DO;
          CALL M$OPEN( OPEN_BASE );           /* Merge the STD name into DCB  */
          END;
       ELSE
          DONE= %YES#;                        /* We'll be done after this file*/
       END;
    GOTO RE_TURN;
 
 
NEXT_BASE: ENTRY ALTRET;
 
    IF NOT FLG.ATALL THEN
       GOTO ALT_RETURN;
TRY$AGAIN:
    IF BASE$->F$DCB.FCD# THEN                 /* If BASE is OPEN,             */
       CALL M$CLOSE( CLOSE_BASE );            /*   CLOSE it.                  */
    CALL M$OPEN( OPEN_BASE )  ALTRET( NOT_THERE );
    THIS_FILE= BASE$->F$DCB.NAME#;
    IF FLG.QUICKIE THEN DO;
       IF FLG.ALLFILE THEN
          GOTO RE_TURN;
       ELSE
          IF FLG.ONEFILE THEN DO;
             FLG= '0'B;
             GOTO RE_TURN;
             END;
          ELSE DO;  /* FLG.THISF */
             FLG.QUICKIE= '0'B;
             OPEN_BASE.V.OPER.THISF#= '0'B;
             END;
       END;
 
    IF THIS_FILE.C > LAST_FID  OR
       (NOT (SUBSTR(BASE_NAME.NAME#,0,1) = '?'))  AND
       (NOT (SUBSTR(BASE_NAME.NAME#,0,QUES_POS)=SUBSTR(THIS_FILE.C,0,QUES_POS)))
       THEN GOTO ALL_DONE;
 
    XUW_WILDCARD.INPUT_= VECTOR(SUBSTR(THIS_FILE.C,0,THIS_FILE.L));
    XUW_WILDCARD.PATTERN_= VECTOR(SUBSTR(TARGET.NAME#,0,TARGET.L#));
    CALL X$WILDCMP(XUW_WILDCARD)  ALTRET( TRY$AGAIN );
 
RE_TURN:
    RETURN;
 
NOT_THERE:
    IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$FDEOF THEN
       GOTO ALT_RETURN;
    ELSE DO;
       ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
       ERRDCB=  BASE#;
       CALL REPORTERR;
       GOTO TRY$AGAIN;
       END;
 
ALL_DONE:
    DONE= %YES#;
ALT_RETURN:
    ALTRETURN;
 
END SETUP_BASE_TEST;
%EJECT;
/*D*    NAME:    REPORTERR
*       CALL:    CALL REPORTERR
*       DESCRIPTION:  Reports the error in ERRCODE.
*/
REPORTERR: PROC(MSG,MSGSIZ);
 /* Parameters */
  DCL MSG CHAR(MSGSIZ);
  DCL MSGSIZ UBIN;
 
    IF LISTED=0 THEN CALL LISTER;
    IF LISTED=1 AND (NOT FLG$LODO) AND (NOT FLGS(%TALLY##)) THEN CALL DOLISTER;
    FPT_ERRMSG.V.DCB#=ERRDCB;
    IF ERRCODE THEN
        CALL M$ERRMSG(FPT_ERRMSG);
    IF NOT (ADDR(MSG)=ADDR(NIL)) THEN DO;
        WRFNAME.BUF_=VECTOR(MSG);
        CALL M$WRITE(WRFNAME);
        IF NOT FLG$LODO THEN DO;
            FPT_WRERR.BUF_=VECTOR(MSG);
            CALL M$WRITE(FPT_WRERR);
            END;
        END;
    ERRCODE='0'B;
    ERRDCB=0;
    RETURN;
END REPORTERR;
%EJECT;
SETUP: PROC  ALTRET;
 
    M$LO$      = DCBADDR(DCBNUM(M$LO));
    M$SI$      = DCBADDR(DCBNUM(M$SI));
    M$UI$      = DCBADDR(DCBNUM(M$UI));
    M$STRING$ = DCBADDR(DCBNUM(M$STRING));
    M$TEST$   = DCBADDR(DCBNUM(M$TEST));
    BASE$= M$SI$;
    UPD$= M$UI$;
 
    ORIG_ACCT= M$SI$->F$DCB.ACCT#;
    IF M$UI$->F$DCB.AMR# THEN DO;
       NUM_UI_ACCTS= 1;
       IF M$UI$->F$DCB.ACCT# = ' ' THEN DO;
          UI_LIST.ACCT(0)= B$JIT.FACCN;
          UI_LIST.SN(0)= B$JIT.FPSN;
          END;
       ELSE DO;
          UI_LIST.ACCT(0)= M$UI$->F$DCB.NAME#.C;
          UI_LIST.SN(0)= M$UI$->F$DCB.PSN#;
          END;
       END;
    ELSE
       NUM_UI_ACCTS= 0;
 
    PASS= 1;
 
    FLG$LODO= '1'B;                    /* M$LO -> same place M$DO does        */
    CALL M$CORRES( CORRESLODO )  ALTRET( RE_TURN );
    FLG$LODO= '0'B;                    /* On second thought, no it doesn't    */
    FPT_ERRMSG.V.OUTDCB2#= DCBNUM(M$DO);
 
RE_TURN:
    RETURN;
 
END SETUP;
%EJECT;
SETUP_DCBS: PROC( BASENO,UPDNO,TRGET );
DCL BASENO                   UBIN;
DCL UPDNO                    UBIN;
DCL 1 TRGET,
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL;
 
    BASE#= BASENO;
    BASE$= DCBADDR(BASE#);
    UPD#=  UPDNO;
    UPD$=  DCBADDR(UPD#);
    IF NOT (ADDR(TRGET) = ADDR(NIL)) THEN DO;
       TRGET= BASE$->F$DCB.NAME#;
       IF TRGET.C = ' ' THEN DO;
          TRGET.L= LENGTHC('?');
          TRGET.C= '?';
          END;
       END;
 
    MERGE_UPD.V.DCB#= UPD#;
    MERGE_UPD.NAME_= VECTOR(BASE$->F$DCB.NAME#);
 
    CLOSE_BASE.V.DCB#= BASE#;
    OPEN_BASE.V.DCB#= BASE#;
    IF FLGS(%STD##) THEN DO;
       OPEN_BASE.V.SETDCB#= '1'B;
       OPEN_BASE.NAME_= VECTOR(BASE_NAME);
       OPEN_BASE.ACCT_= VECTOR(AN_ACCT);
       END;
    ELSE DO;
       BASE_NAME= BASE$->F$DCB.NAME#;
       CALL INDEX( QUES_POS,'?',BASE_NAME.NAME# );
       END;
RE_TURN:
    RETURN;
 
END SETUP_DCBS;
%EJECT;
READ_STD_REC: PROC  ALTRET;
 
    IF NOT FLGS(%STD##) THEN DO;
       STD_CNT= STD_CNT + 1;
       IF STD_CNT > 1 THEN
          GOTO EOF_STD;
       CALL INDEX( QUES_POS,'?',M$SI$->F$DCB.NAME#.C )  ALTRET( NOTALLSI );
       IF QUES_POS < LENGTHC(M$SI$->F$DCB.NAME#.C) THEN DO;
ALLSI:
          FLG$ALL= '1'B;
          CALL SETUP_DCBS( DCBNUM(M$SI),DCBNUM(M$UI),TARGET );
          CALL SETUP_BASE_TEST;
          END;
       ELSE DO;
NOTALLSI:
          IF NOT FLGS(%UI##)  THEN
             IF M$SI$->F$DCB.NAME#.C = ' ' THEN
                GOTO ALLSI;
             ELSE
                GOTO RE_TURN;
          CALL INDEX( QUES_POS,'?',M$UI$->F$DCB.NAME#.C )  ALTRET( NOTALLUI );
          IF QUES_POS < LENGTHC(M$UI$->F$DCB.NAME#.C) THEN DO;
             FLG$ALL= '1'B;
             CALL SETUP_DCBS( DCBNUM(M$UI),DCBNUM(M$SI),TARGET );
             CALL SETUP_BASE_TEST;
             END;
          ELSE DO;
NOTALLUI:
             IF M$SI$->F$DCB.NAME#.L=0  OR  M$SI$->F$DCB.NAME#.C=':'  THEN DO;
                IF M$UI$->F$DCB.NAME#.L=0 OR M$UI$->F$DCB.NAME#.C=':' THEN
                   GOTO ALLSI;
                CALL SETUP_DCBS( DCBNUM(M$UI),DCBNUM(M$SI) );
                BASE_NAME= UPD$->F$DCB.NAME#;
                TARGET= BASE_NAME;
                CALL M$OPEN( MERGE_UPD );
                END;
             ELSE
                IF M$UI$->F$DCB.NAME#.L=0 OR M$UI$->F$DCB.NAME#.C=':' THEN DO;
                   CALL SETUP_DCBS( DCBNUM(M$SI),DCBNUM(M$UI),TARGET );
                   CALL M$OPEN( MERGE_UPD );
                   END;
             END;
          END;
       END;
    ELSE DO;
       STD_REC= ' ';
       DO WHILE( STD_ARS <= 0  OR  SUBSTR(STD_REC,0,STD_ARS) = ' ' );
          STD_REC= ' ';
          CALL M$READ( READ_STD )  ALTRET( EOF_STD );
          STD_ARS= DCBADDR(DCBNUM(F$STD))->F$DCB.ARS#;
          STD_CNT= STD_CNT + 1;
          END;
       FLG$ALL= '0'B;
       FID.TEXTFID_= VECTOR(SUBSTR(STD_REC,0,STD_ARS));
       CALL M$FID( FID )  ALTRET( BAD_FID );
       IF AN_ACCT.ACCT# = '        ' THEN
          AN_ACCT.ACCT#= ORIG_ACCT;
       CALL INDEX( QUES_POS,'?',BASE_NAME.NAME# );
       IF QUES_POS < LENGTHC(BASE_NAME.NAME#) THEN
          FLG$ALL= '1'B;
       ELSE
          IF BASE_NAME.NAME# = ' ' THEN DO;
             FLG$ALL= '1'B;
             BASE_NAME.L#= LENGTHC('?');
             BASE_NAME.NAME#= '?';
             END;
       TARGET= BASE_NAME;
       CALL SETUP_DCBS( DCBNUM(M$SI),DCBNUM(M$UI) );
       CALL SETUP_BASE_TEST;
       END;
 
RE_TURN:
    RETURN;
 
BAD_FID:
    /* >>> Invalid fid %A at line %D of STD file %A. <<< */
    VEC1_= VECTOR(SUBSTR(STD_REC,0,STD_ARS));
    VEC2_= VECTOR(STD_CNT);
    VEC3_= VECTOR(DCBADDR(DCBNUM(F$STD))->F$DCB.NAME#.C);
    CALL X$WRITE( F_FDS,FMT1_,VEC1_,VEC2_,VEC3_ );
    CALL REPORTERR( SUBSTR(LO_BUF,1),F_FDS.BUFX-1 );
 
EOF_STD:
    DONE= %YES#;
ALT_RETURN:
    ALTRETURN;
 
END READ_STD_REC;
%EJECT;
PARSE_THE_OPTIONS: PROC  ALTRET;
 
    GOPHER_OPTS.WORK$= ADDR(WORK);
    GOPHER_OPTS.WKSZ= SIZEW(WORK);
    GOPHER_OPTS.TEXT$= ADDR(TMP.ALL.OPTS);
    FLGS= '0'B;
    FLGS(%UI##)= M$UI$->F$DCB.AMR#;
    TMP.USER.OPTS_LEN= B$JIT.CCARS - B$JIT.CCDISP - 1;
    TMP.USER.OPTS= SUBSTR(B$JIT.CCBUF,B$JIT.CCDISP+1);
    TMP.DFLT.OPTS= ' ';
    TMP.ALL= TMP.USER;
    IF TMP.USER.OPTS_LEN < 1 THEN
         GOTO TRY_DEFAULTS;
PARSE_IT:
    GOPHER_OPTS.NCHARS= TMP.ALL.OPTS_LEN;
    CALL X$PARSE( GOPHER_OPTS )  ALTRET( PARSE_ERR );
    BLK1$= GOPHER_OPTS.OUT$;
    DO I=0 TO %BLK1_NSUBLKS-1;
       BLK2$= %BLK1_SUBLK$(I);
       IF %BLK2_NSUBLKS > 0 THEN
          BLK3$= %BLK2_SUBLK$(0);
       FLGS(%BLK2_CODE)= %YES#;
       DO CASE( %BLK2_CODE );
 
          CASE( %AFTER## );
             CALL CHARBIN( AFTER,%BLK3_TEXT );
             IF AFTER = 0  AND  BEFORE = 0  THEN
                CIRC_SIZE= 0;
             ELSE
                CIRC_SIZE= 19;
 
          CASE( %ANY_FILE## );
             FLGS(%TEXT_FILES_ONLY##)= %NO#;
 
          CASE( %BEFORE## );
             CALL CHARBIN( BEFORE,%BLK3_TEXT );
             IF BEFORE = 0  AND  AFTER = 0  THEN
                CIRC_SIZE= 0;
             ELSE
                CIRC_SIZE= 19;
 
               CASE (%COUNTFILES##);
                         FLGS(%COUNTFILES##) = %YES#;
 
          CASE( %DEPTH## );
             NO_CRITERIA=%NO#;
             CALL CHARBIN( DEPTH_TO_CHECK,%BLK3_TEXT );
 
          CASE( %EBCDIC## );
 
          CASE( %ECHO## );
 
          CASE( %END## );
             LAST_FID= %BLK3_TEXT;
          CASE( %GREETING##);
             FLGS(%NO_GREETING##)= %NO#;
          CASE( %IGNORE_ERRORS## );
 
          CASE( %IGNORE_ORGS## );
             NO_CRITERIA= %NO#;
             IGNORE_ORG= '0'B;
             DO J=0 TO %BLK2_NSUBLKS-1;
                BLK3$= %BLK2_SUBLK$(J);
                IGNORE_ORG(%BLK3_CODE-%NULL_ORG##)= %YES#;
                IF ORG(%BLK3_CODE-%NULL_ORG##) THEN
                   GOTO OOPS;
                END;
          CASE( %IGNORE_TYPES## );
             NO_CRITERIA= %NO#;
             DO J=0 TO %BLK2_NSUBLKS-1;
                BLK3$= %BLK2_SUBLK$(J);
                NUM_ITYPES= NUM_ITYPES + 1;
                IF NUM_ITYPES > %MAX_ITYPES THEN
                   GOTO OOPS;
                BLK4$= BLK3$->P_OUT.SUBLK$(0);
                ITYPE(NUM_ITYPES)= %BLK4_TEXT;
                END;
          CASE( %LS_DEFAULTS## );
             FLGS(%NO_LS_DEFAULTS##)= %NO#;
          CASE( %MAKESTD## );
             FLGS(%IGNORE_ERRORS##)= %YES#;
             WRFNAME.V.DVBYTE.VFC#= %NO#;
             OPENASIS.V.ORG#= %CONSEC#;
             CALL CLOSE( DCBNUM(M$LO) );
             CALL OPEN( DCBNUM(M$LO),ERRCODE,%CREATE# )  ALTRET( OOPS );
          CASE( %NO_DEFAULTS## );
             PASS= 2;
          CASE( %NO_GREETING## );
          CASE( %NO_LS_DEFAULTS## );
          CASE( %NO_PROMPT## );
          CASE( %NO_SUMMARY## );
          CASE( %NRECS## );
             OPENASIS.V.ORG#= 0;
             NO_CRITERIA= %NO#;
             RELATION= %BLK3_CODE;
             BLK3$= %BLK2_SUBLK$(1);
             CALL CHARBIN( NRECS,%BLK3_TEXT );
          CASE( %ORG## );
             NO_CRITERIA= %NO#;
             ORG= '0'B;
             DO J=0 TO %BLK2_NSUBLKS-1;
                BLK3$= %BLK2_SUBLK$(J);
                ORG(%BLK3_CODE-%NULL_ORG##)= %YES#;
                IF IGNORE_ORG(%BLK3_CODE-%NULL_ORG##) THEN
                   GOTO OOPS;
                END;
          CASE( %PROMPT## );
             FLGS(%NO_PROMPT##)= %NO#;
          CASE( %QUIT## );
 
          CASE( %RESIDUAL## );
 
          CASE( %SKIP## );
             NO_CRITERIA= %NO#;
             DO J=0 TO %BLK2_NSUBLKS-1;
                BLK3$= %BLK2_SUBLK$(J);
                NUM_SKIPS= NUM_SKIPS + 1;
                IF NUM_SKIPS > %MAX_SKIPS THEN
                   GOTO OOPS;
                SKIP.L#(NUM_SKIPS)= %BLK3_COUNT;
                SKIP.NAME#(NUM_SKIPS)= %BLK3_TEXT;
                CALL INDEX1( QUES_POS,'?',%BLK3_TEXT );
                IF QUES_POS < LENGTHC(SKIP.NAME#(NUM_SKIPS)) THEN
                   SKIP.WILD(NUM_SKIPS)= %YES#;
                ELSE
                   SKIP.WILD(NUM_SKIPS)= %NO#;
                END;
          CASE( %SRCH## );
             IF %BLK2_NSUBLKS > 0 THEN DO;
                A_SN.SN#(0)='     ';
                DO J=0 TO %BLK2_NSUBLKS-1;
                   BLK3$= %BLK2_SUBLK$(J);
                   NUM_ACCTS=NUM_ACCTS+1;
                   IF NUM_ACCTS > %MAX_ACCTS THEN
                      GOTO OOPS;
                   CALL INSERT(STD_REC, 0, 80, %BLK3_TEXT);
                   CALL M$FID(FID) ALTRET(BAD_ACCT);
                   IF (NOT (BASE_NAME.NAME# = ' ')) OR
                      (NOT (A_PASS.PASS# = ' ')) OR
                      (NOT (MERGEF.V.RES# = %IGNORE_CHARVAL#) AND
                       (NOT (MERGEF.V.RES# = 'DP'))) OR
                      (NOT( A_WSN.WSN# = ' ')) THEN
                      GOTO BAD_ACCT;
                   ACCT_LIST.ACCT(J)=AN_ACCT.ACCT#;
                   ACCT_LIST.SN(J)=A_SN.SN#(0);
                END;
                NUM_ACCTS=%BLK2_NSUBLKS;
                END;
             ELSE
                NUM_ACCTS=0;
 
             ACCT_LIST.ACCT(NUM_ACCTS)=':LIBRARY';
             ACCT_LIST.SN(NUM_ACCTS)='      ';
             ACCT_LIST.ACCT(NUM_ACCTS+1)=B$JIT.FACCN;
             ACCT_LIST.SN(NUM_ACCTS+1)=B$JIT.FPSN;
             NUM_ACCTS=NUM_ACCTS+2;
          CASE( %START## );
             START.LEN= %BLK3_COUNT;
             START.FID= %BLK3_TEXT;
          CASE( %STD## );
             STD_REC= %BLK3_TEXT;
             FID_LEN= %BLK3_COUNT;
             IF DCBADDR(DCBNUM(F$STD))->F$DCB.FCD# THEN
                CALL CLOSE(DCBNUM(F$STD));
             CALL OPEN(DCBNUM(F$STD),ERRCODE,%IN#,STD_REC,FID_LEN) ALTRET(OOPS);
          CASE( %STRINGS## );
             STD_REC= %BLK3_TEXT;
             FID_LEN= %BLK3_COUNT;
             IF DCBADDR(DCBNUM(M$STRING))->F$DCB.FCD# THEN
                CALL CLOSE(DCBNUM(M$STRING));
             CALL OPEN( DCBNUM(M$STRING),ERRCODE,%IN#,STD_REC,FID_LEN )
                                                                 ALTRET( OOPS );
          CASE( %SUMMARY## );
             FLGS(%NO_SUMMARY##)= %NO#;
          CASE( %TALLY## );
 
          CASE( %TALLYONLY## );
 
          CASE( %TEXT_FILES_ONLY## );
             TEXTTBL= '0'B;
             SUBSTR(TEXTTBL.STR,0,7)= ' ';      /* NUL    - ACK    */
             SUBSTR(TEXTTBL.STR,10,16)= ' ';    /* LF     - EM     */
             SUBSTR(TEXTTBL.STR,27,3)= ' ';     /* ESC    - GS     */
             SUBSTR(TEXTTBL.STR,128,384)= ' ';  /* '200'O - '777'O */
             /*
                The BEL ('007'O), SUB ('032'O), RS ('036'O), US ('037'O)
                and DEL ('177'O) characters are treated as text because
                they may appear in ORG=UR files as VFC characters
             */
 
          CASE( %TYPE## );
             NO_CRITERIA= %NO#;
             DO J=0 TO %BLK2_NSUBLKS-1;
                BLK3$= %BLK2_SUBLK$(J);
                NUM_TYPES= NUM_TYPES + 1;
                IF NUM_TYPES > %MAX_TYPES THEN
                   GOTO OOPS;
                BLK4$= BLK3$->P_OUT.SUBLK$(0);
                TYPES(NUM_TYPES)= %BLK4_TEXT;
                END;
          CASE( %UC## );
 
          CASE( %UI## );
 
          CASE( %UISRCH## );
             FLGS(%UI##)= %YES#;
             IF %BLK2_NSUBLKS > 0 THEN DO;
                A_SN.SN#(0)='      ';
                DO J=0 TO %BLK2_NSUBLKS-1;
                   BLK3$= %BLK2_SUBLK$(J);
                   IF NUM_UI_ACCTS >= %MAX_UI_ACCTS THEN
                      GOTO OOPS;
                   CALL INSERT(STD_REC, 0, 80, %BLK3_TEXT);
                   CALL M$FID(FID) ALTRET(BAD_ACCT);
                   IF (NOT (BASE_NAME.NAME# = ' ')) OR
                      (NOT (A_PASS.PASS# = ' ')) OR
                      ((NOT (MERGEF.V.RES# = %IGNORE_CHARVAL#)) AND
                       (NOT (MERGEF.V.RES# = 'DP'))) OR
                      (NOT (A_WSN.WSN# = ' ')) THEN
                      GOTO BAD_ACCT;
                   UI_LIST.ACCT(NUM_UI_ACCTS)=AN_ACCT.ACCT#;
                   UI_LIST.SN(NUM_UI_ACCTS)=A_SN.SN#(0);
                   NUM_UI_ACCTS= NUM_UI_ACCTS + 1;
                END;
                END;
 
          CASE( %WARNINGS## );
             FLGS(%IGNORE_ERRORS##)= %NO#;
          CASE( %WILDCARD## );
             IF %BLK2_NSUBLKS > 0 THEN
                WILDCHAR= %BLK3_TEXT;
             ELSE
                WILDCHAR= '?';
          CASE( ELSE );
 
          END;
       END;
 
    IF PASS=1 THEN DO;
TRY_DEFAULTS:
       PASS= 2;
       GET_DEFAULTS.VALUE_= VECTOR(TMP.DFLT);
       CALL M$CMDVAR( GET_DEFAULTS )  ALTRET( RET );
       IF TMP.USER.OPTS = ' ' THEN
          TMP.ALL= TMP.DFLT;
       ELSE DO;
          CALL CONCAT( TMP.ALL.OPTS,SUBSTR(TMP.DFLT.OPTS,0,TMP.DFLT.OPTS_LEN),
                                    ',',
                                    SUBSTR(TMP.USER.OPTS,0,TMP.USER.OPTS_LEN) );
          TMP.ALL.OPTS_LEN=TMP.DFLT.OPTS_LEN + LENGTHC(',') + TMP.USER.OPTS_LEN;
          END;
       GOTO PARSE_IT;
       END;
RET:
    IF NOT FLGS(%NO_GREETING##) THEN DO;
       CALL CONCAT(TMP.BUF,'GOPHER C01 here (11/25/87) Defaults used: ',
                          TMP.DFLT.OPTS );
       IF NOT FLGS(%NO_LS_DEFAULTS##) AND (NOT (TMP.DFLT.OPTS = ' ')) THEN DO;
          I= LENGTHC(TMP.BUF)-1;
          DO WHILE( I>0 AND SUBSTR(TMP.BUF,I,1)=' ' );
             I=I-1;
             END;
          END;
       ELSE
          CALL INDEX(I,')',TMP.BUF);
       FPT_WRERR.BUF_= VECTOR(SUBSTR(TMP.BUF,0,I+1));
       CALL M$WRITE( FPT_WRERR );
       END;
    IF NOT M$LO$->F$DCB.FCD# THEN
       CALL OPEN( DCBNUM(M$LO),ERRCODE,%CREATE# )  ALTRET( OOPS );
    RETURN;
 
BAD_ACCT:
       TMP.BUF='Account names must be "[DP#psn/].acct"';
       FPT_LS.BUF_=VECTOR(SUBSTR(TMP.BUF, 0, 38));
       CALL M$WRITE(FPT_LS);
       ALTRETURN;
 
PARSE_ERR:
    CALL OPEN( DCBNUM(M$LO),ERRCODE,%CREATE# );
    TMP.BUF= ' ';
    IF PASS=1 OR GOPHER_OPTS.HI_CHAR>TMP.DFLT.OPTS_LEN+LENGTHC(',') THEN DO;
       I= LENGTHC('!') + B$JIT.CCDISP + GOPHER_OPTS.HI_CHAR;
       SUBSTR(TMP.BUF,I,1)= '^';
       FPT_LS.BUF_= VECTOR(SUBSTR(TMP.BUF,0,I+1));
       END;
    ELSE DO;
       CALL CONCAT( TMP.ALL.OPTS,'Default options: ',TMP.DFLT.OPTS );
       FPT_LS.BUF_= VECTOR(SUBSTR(TMP.ALL.OPTS,0,TMP.DFLT.OPTS_LEN+17));
       CALL M$WRITE(FPT_LS);
       SUBSTR(TMP.BUF,LENGTHC('Default options: ')+GOPHER_OPTS.HI_CHAR,1)= '^';
       FPT_LS.BUF_= VECTOR(SUBSTR(TMP.BUF,0,GOPHER_OPTS.HI_CHAR+18));
       END;
    CALL M$WRITE(FPT_LS);
    TMP.BUF= 'Syntax error about here';
    FPT_LS.BUF_= VECTOR(SUBSTR(TMP.BUF,0,23));
    CALL M$WRITE(FPT_LS);
OOPS:
    ALTRETURN;
 
END PARSE_THE_OPTIONS;
%EJECT;
OPEN: PROC( DCB#,ERR,HOW,THE_FID,FID_LEN )  ALTRET;
DCL DCB#                     SBIN;
DCL ERR                      BIT(36);
DCL HOW                      UBIN;
DCL THE_FID                  CHAR(FID_LEN);
DCL FID_LEN                  UBIN;
 
    ERR= '0'B;
    MERGEF.V.FUN#= HOW;
    OPENASIS.V.FUN#= HOW;
    IF ADDR(THE_FID) = ADDR(NIL) THEN
         IF DCB# > 0 THEN DO;
              OPENASIS.V.DCB#= DCB#;
              OPENASIS.V.FUN#= HOW;
              CALL M$OPEN( OPENASIS )  ALTRET( OOPS );
              END;
         ELSE DO;
              MERGEF.V.DCB#= -DCB#;
              CALL M$OPEN( MERGEF ) ALTRET( OOPS );
              END;
    ELSE DO;
         FID.TEXTFID_= VECTOR(THE_FID);
         CALL M$FID( FID )  ALTRET( OOPS );
         IF DCB# > 0 THEN DO;
              MERGEF.V.DCB#= DCB#;
              CALL M$OPEN( MERGEF )  ALTRET( OOPS );
              OPENASIS.V.DCB#= DCB#;
              CALL M$OPEN( OPENASIS )  ALTRET( OOPS );
              END;
         ELSE DO;
              MERGEF.V.DCB#= -DCB#;
              CALL M$OPEN( MERGEF )  ALTRET( OOPS );
              END;
         END;
RET:
    RETURN;
 
OOPS:
    ERR= B$TCB$->B$TCB.ALT$->B$ALT.ERR;
    ALTRETURN;
 
END OPEN;
%EJECT;
DO_WE_WANT_THIS_FILE: PROC  ALTRET;
 
    IF M$SI$->F$DCB.ORG# = %CG# THEN          /* Is it a ComGroup?            */
       GOTO NOT_THIS_FILE;                    /* Yep, skip it!                */
 
/**/
/* Were any file selection criteria specified via options? */
/**/
    IF NO_CRITERIA THEN
       GOTO LOOKS_OK;
 
/**/
/* See if this fid is to be SKIPped */
/**/
    IF FLGS(%SKIP##) THEN
       DO I=1 TO NUM_SKIPS;
          IF SKIP.WILD(I) THEN DO;
             XUW_WILDCARD.INPUT_= VECTOR(SUBSTR(THIS_FILE.C,0,THIS_FILE.L));
             XUW_WILDCARD.PATTERN_= VECTOR(SUBSTR(SKIP.NAME#(I),0,SKIP.L#(I)));
             CALL X$WILDCMP(XUW_WILDCARD)  ALTRET(NEXT_SKIP);
             GOTO NOT_THIS_FILE;
             END;
          IF SKIP.NAME#(I) = THIS_FILE.C THEN
             GOTO NOT_THIS_FILE;
   NEXT_SKIP:
          END;
 
/**/
/* See if it's a ORG to IGNORE */
/**/
    IF FLGS(%IGNORE_ORGS##) AND
       IGNORE_ORG(M$SI$->F$DCB.ORG#) THEN
       GOTO NOT_THIS_FILE;
 
/**/
/* See if it's a TYPE to IGNORE */
/**/
    IF FLGS(%IGNORE_TYPES##) THEN
       DO I=1 TO NUM_ITYPES;
          IF M$SI$->F$DCB.TYPE# = ITYPE(I) THEN
             GOTO NOT_THIS_FILE;
          IF SUBSTR(ITYPE(I),0,1) = '?' AND
             SUBSTR(M$SI$->F$DCB.TYPE#,1,1) = SUBSTR(ITYPE(I),1,1) THEN
             GOTO NOT_THIS_FILE;
          IF SUBSTR(ITYPE(I),1,1) = '?' AND
             SUBSTR(M$SI$->F$DCB.TYPE#,0,1) = SUBSTR(ITYPE(I),0,1) THEN
             GOTO NOT_THIS_FILE;
          END;
 
/**/
/* See if it's a TYPE specified */
/**/
    IF FLGS(%TYPE##) THEN DO;
       DO I=1 TO NUM_TYPES;
          IF M$SI$->F$DCB.TYPE# = TYPES(I) THEN
             GOTO CHECK_ORG;
          IF SUBSTR(TYPES(I),0,1) = '?' AND
             SUBSTR(M$SI$->F$DCB.TYPE#,1,1) = SUBSTR(TYPES(I),1,1) THEN
             GOTO CHECK_ORG;
          IF SUBSTR(TYPES(I),1,1) = '?' AND
             SUBSTR(M$SI$->F$DCB.TYPE#,0,1) = SUBSTR(TYPES(I),0,1) THEN
             GOTO CHECK_ORG;
          END;
       GOTO NOT_THIS_FILE;
       END;
 
/**/
/* See if it's a ORG specified */
/**/
CHECK_ORG:
    IF FLGS(%ORG##) AND
       NOT ORG(M$SI$->F$DCB.ORG#) THEN
       GOTO NOT_THIS_FILE;
 
/**/
/* See if it's a NRECS specified */
/**/
    IF FLGS(%NRECS##) THEN
       DO CASE( RELATION );
          CASE( %LESS## );
             IF M$SI$->F$DCB.NRECS# >= NRECS THEN
                GOTO NOT_THIS_FILE;
          CASE( %EQUAL## );
             IF (NOT (M$SI$->F$DCB.NRECS# = NRECS)) THEN
                GOTO NOT_THIS_FILE;
          CASE( %GREATER## );
             IF M$SI$->F$DCB.NRECS# <= NRECS THEN
                GOTO NOT_THIS_FILE;
          END;
 
LOOKS_OK:
    IF FLGS(%ECHO##)  AND  (NOT FLGS(%TALLYONLY##)) THEN
       CALL LISTER;
    RETURN;
 
NOT_THIS_FILE:
    ALTRETURN;
 
END DO_WE_WANT_THIS_FILE;
%EJECT;
READY_UI_DCB: PROC;
DCL I                        UBIN;
 
    IF NUM_UI_ACCTS = 1  AND  M$UI$->F$DCB.AMR#  THEN
       CALL M$OPEN( MERGE_UPD );            /* Only the NAME needs merging in */
    ELSE DO;
       MERGE_UPD.V.SETDCB#= %NO#;
       MERGE_UPD.V.OPER.TEST#= %YES#;
       MERGE_UPD.SN_= VECTOR(A_SN);
LOOP:  DO I=0 TO NUM_UI_ACCTS-1;
          MERGE_UPD.ACCT_= VECTOR(UI_LIST.ACCT(I));
          A_SN.SN#(0)= UI_LIST.SN(I);
          CALL M$OPEN(MERGE_UPD)  ALTRET( NEXT );
          EXIT LOOP;
NEXT:     END LOOP;
       END;
 
RE_TURN:
    RETURN;
 
END READY_UI_DCB;
%EJECT;
INFORM_EM: PROC;
 
DCL V1_ VECTOR;
DCL V2_ VECTOR;
DCL V3_ VECTOR;
 
DCL TEMP SBIN HALF;
DCL TEMP_STR CHAR(4) STATIC INIT('None');
DCL TEMP_LOC SBIN WORD WALIGNED;
 
    IF NOT (M$LO$->F$DCB.DDEV.IC# AND
            M$LO$->F$DCB.DDEV.UCOUT#) THEN DO;
 
       TEMP = F_FDS.DCB#;
       F_FDS.DCB# = DCBNUM(M$LO);
 
       VBASE(V1_)  = ADDR(M$SI$->F$DCB.NAME#.C);
       VBOUND(V1_) = M$SI$->F$DCB.NAME#.L;
 
       IF M$SI$->F$DCB.ACCT# = '        ' THEN
          VBASE(V2_) = ADDR(B$JIT$->B$JIT.ACCN);
       ELSE
          VBASE(V2_) = ADDR(M$SI$->F$DCB.ACCT#);
       VBOUND(V2_) = 7;
 
 
       IF TMP.USER.OPTS_LEN > 0 THEN DO;
          VBASE(V3_) = ADDR(TMP.USER.OPTS);
          CALL INDEX(TEMP_LOC,')',TMP.USER.OPTS)
          WHENRETURN DO;
             VBOUND(V3_) = TEMP_LOC - 1;
             END;
          WHENALTRETURN DO;
             VBOUND(V3_) = TMP.USER.OPTS_LEN;
             END;
          END;
       ELSE DO;
          VBASE(V3_) = ADDR(TEMP_STR);
          VBOUND(V3_) = LENGTHC(TEMP_STR) - 1;
          END;
 
       CALL X$WRITE (F_FDS, FMT10_, V1_, V2_, V3_);
 
       F_FDS.DCB# = TEMP;
 
       END;
 
RETURN;
END INFORM_EM;
END GOPHER;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GOPHER$BREAK: PROC  ASYNC;
 
%INCLUDE CP_6;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%INCLUDE GOPHER_C61;
%INCLUDE XU_FORMAT_C;
%INCLUDE XUD_UTS_M;
 
/**/
/* FPTs */
/**/
%FPT_READ    (FPTN                     = READUC,
              DCB=M$UC,
              STCLASS=STATIC );
%FPT_TIME    (FPTN                     = GET_TIME,
              DEST=UTS,
              SOURCE=CLOCK,
              TSTAMP=CUR_UTS );
%FPT_TRMPRG  (FPTN                     = ZEROBREAK,
              RSTBRK=YES,
              STCLASS=CONSTANT );
%FPT_WRITE   (FPTN                     = WRFNAME,
              DCB=M$UC,
              STCLASS=STATIC );
/**/
/* FORMATer stuff */
/**/
%F_FDS       (NAME=F_FDS,
              BUF=LO_BUF,
              STCLASS=STATIC );
 
/**/
/* Externals */
/**/
DCL BROKEN                   SBIN      SYMREF;
DCL NUM_FILES_SEARCHED       SBIN      SYMREF;
DCL DONE                     BIT(1)    SYMREF ALIGNED;
DCL 1 INCLUDE_INFO(0:11) SYMREF,
      2 NAME                 CHAR(59),
      2 NRECS                UBIN,
      2 LEN                  UBIN;
DCL INCLUDE_LEVEL            UBIN      SYMREF;
DCL M$SI                     DCB;
DCL M$SI$                    PTR       SYMREF;
DCL REC#(0:11)               SBIN      SYMREF;
DCL WE_SHOULD_QUIT_NOW       BIT(1)    SYMREF ALIGNED;
DCL LO_BUF                   CHAR(132) STATIC;
 
/**/
/* Locals */
/**/
DCL ARROWS                   CHAR(14);
DCL INT8                     CHAR(8);
DCL LOCAL_COUNT              CHAR(8);
DCL VEC3_                    BIT(72);
 
DCL CUR_UTS                  UBIN      STATIC;
DCL DIFF                     SBIN      STATIC   INIT(0);
DCL I                        SBIN;
DCL LOX                      SBIN;
DCL N                        UBIN;
DCL PREV_UTS                 UBIN      STATIC INIT(0);
DCL FLGS(0:71)               BIT(1)    ALIGNED SYMREF;
/**/
/* Entry Points */
/**/
DCL X$WRITE                  ENTRY(22);
 
/**/
%XUD$UTS_ENTRIES;
 
 
    IF DIFF > 0 THEN DO;
       DIFF= 1;              /* Force the C,F,Q or ? message later            */
       GOTO RE_TURN;
       END;
 
    CALL M$TIME( GET_TIME )  ALTRET( RE_TURN );
    CALL XUD$UTS_DIFF_SEC (DIFF, CUR_UTS, PREV_UTS);
    IF DIFF < 1 THEN
       DIFF= 1;              /* Force the C,F,Q or ? message later            */
 
     IF FLGS(%COUNTFILES##)
     THEN DO;
    CALL BINCHAR( LOCAL_COUNT,NUM_FILES_SEARCHED);
    CALL EDITSTR( LOCAL_COUNT,0,7,'107'O,LOCAL_COUNT );
    CALL INDEX1R( I,' ',LOCAL_COUNT );
    CALL CONCAT( LO_BUF,
                 ' ',SUBSTR(LOCAL_COUNT,I+1),
                 ' files have been searched so far.');
    WRFNAME.BUF_= VECTOR(LO_BUF);
    CALL M$WRITE( WRFNAME );
          END;
 
    IF M$SI$->F$DCB.FCD# THEN DO;
       CALL BINCHAR( INT8,REC#(0) );
       CALL EDITSTR( INT8,0,7,'107'O,INT8 );
       CALL INDEX1R( I,' ',INT8 );
       CALL CONCAT( LO_BUF,'@At record ',SUBSTR(INT8,I+1),' (' );
       CALL INDEX( LOX,'  ',LO_BUF );
       IF M$SI$->F$DCB.NRECS# - REC#(0) < 0 THEN
          INT8= '       ?';
       ELSE DO;
          CALL BINCHAR( INT8,M$SI$->F$DCB.NRECS#-REC#(0) );
          CALL EDITSTR( INT8,0,7,'107'O,INT8 );
          END;
       CALL INDEX1R( I,' ',INT8 );
       CALL INSERT( LO_BUF,LOX,,SUBSTR(INT8,I+1),' remain) in file ',
                       SUBSTR(M$SI$->F$DCB.NAME#.C,0,M$SI$->F$DCB.NAME#.L),
                       '.',M$SI$->F$DCB.ACCT# );
          DO N=0 TO INCLUDE_LEVEL-1;
             CALL INDEX(LOX, '  ', LO_BUF);
             WRFNAME.BUF_=VECTOR(SUBSTR(LO_BUF, 1, LOX-1));
             WRFNAME.V.DVBYTE.VFC#=%NO#;
             CALL M$WRITE(WRFNAME);
 
             CALL BINCHAR(INT8, REC#(N+1));
             CALL EDITSTR(INT8, 0, 7, '107'O, INT8);
             CALL INDEX1R( I, ' ', INT8);
             CALL INSERT(LO_BUF, N+1, 40, '->At record ',
                SUBSTR(INT8, I+1), ' (');
             CALL INDEX(LOX, '  ', LO_BUF);
             IF INCLUDE_INFO.NRECS(N)-REC#(N+1) < 0 THEN
                INT8='       ?';
             ELSE DO;
                CALL BINCHAR(INT8, INCLUDE_INFO.NRECS(N)-REC#(N+1));
                CALL EDITSTR(INT8, 0, 7, '107'O, INT8);
                END;
             CALL INDEX1R(I, ' ', INT8);
             CALL INSERT(LO_BUF, LOX,, SUBSTR(INT8, I+1),
                ' remain) in file ',
                INCLUDE_INFO.NAME(N));
          END;
       END;
    ELSE
       CALL CONCAT( LO_BUF,'@At file ',
                       SUBSTR(M$SI$->F$DCB.NAME#.C,0,M$SI$->F$DCB.NAME#.L),
                       '.',M$SI$->F$DCB.ACCT# );
    CALL INDEX( LOX,'  ',LO_BUF );
    IF DIFF <= 1 THEN DO;
       SUBSTR(LO_BUF,LOX)= '; Enter C,F,Q or ?';
       LOX= LOX + LENGTHC('; Enter C,F,Q or ?');
       WRFNAME.BUF_= VECTOR(SUBSTR(LO_BUF,0,LOX));
       WRFNAME.V.DVBYTE.VFC#= %YES#;
READ_UC:
       CALL M$WRITE( WRFNAME );
       READUC.BUF_= VECTOR(LO_BUF);
       LO_BUF= ' ';
       CALL M$READ( READUC )  ALTRET( XIT );
       DO SELECT( LO_BUF );
          SELECT( 'F', 'f', 'N', 'n' );
             BROKEN= 1;
          SELECT( 'Q', 'q', 'QUIT', 'quit' );
             BROKEN= 2;
             WE_SHOULD_QUIT_NOW= %YES#;
             DONE= %YES#;
          SELECT( '?','H','h','HELP','help' );
             WRFNAME.BUF_= VECTOR(LO_BUF);
             LO_BUF= 'AC to continue';
             CALL M$WRITE( WRFNAME );
             LO_BUF= 'AF to skip to the next File';
             CALL M$WRITE( WRFNAME );
             LO_BUF= 'AQ to Quit GOPHER NOW!';
             CALL M$WRITE( WRFNAME );
             LO_BUF= '@Enter C,F or Q';
             WRFNAME.BUF_= VECTOR(SUBSTR(LO_BUF,0,LENGTHC('@Enter C,F or Q')));
             GOTO READ_UC;
 
          END;
       END;
    ELSE DO;
       WRFNAME.BUF_= VECTOR(SUBSTR(LO_BUF,1,LOX-1));
       WRFNAME.V.DVBYTE.VFC#= %NO#;
       CALL M$WRITE( WRFNAME );
       END;
XIT:
    DIFF= 0;
    PREV_UTS= CUR_UTS;
RE_TURN:
    CALL M$TRMPRG( ZEROBREAK );
    RETURN;
 
END GOPHER$BREAK;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GOPHER$ERR:PROC( P_ERRCODE, P_BUF_ );
 
%INCLUDE CP_6;
%INCLUDE B_ERRORS_C;
 
%F$DCB;
  DCL M$LO DCB;
  DCL M$DO DCB;
  DCL M$SI DCB;
 
%FPT_ERRMSG(FPTN=ERR, BUF=BUF, RESULTS=RES, OUTDCB1=M$LO, OUTDCB2=M$DO ,
 FLAGLEV=2, FILEACCT=FA, FILENAME=FN );
%VLP_ACCT(FPTN=FA,ACCT='PL6GN   ');
%VLP_NAME(FPTN=FN,NAME='XUU_MESSAGES');
%VLR_ERRMSG(FPTN=RES);
  DCL BUF(0:3) CHAR(120) STATIC;
 
%VLP_ERRCODE( FPTN=P_ERRCODE, STCLASS=" " );
  DCL P_BUF_ VECTOR;
 
  DCL LISTED UBIN WORD SYMREF;
  DCL FLG$LODO BIT(1) ALIGNED SYMREF;
  DCL LDCOUNT SBIN WORD SYMREF;
 
  DCL 1 PRT_BUF STATIC ALIGNED,
        2 HEAD CHAR(0) CALIGNED INIT('** ERROR: '),
        2 BUF CHAR(256) CALIGNED;
  DCL BASED_CHARS CHAR(256) CALIGNED BASED;
 
%FPT_WRITE( FPTN=WRT );
 
 
    IF P_ERRCODE.MON AND P_ERRCODE.ERR# = %E$LD
      THEN DO;
        LDCOUNT = LDCOUNT + 1;
        RETURN;
        END;
 
 
    WRT.BUF_ = VECTOR(DCBADDR(DCBNUM(M$SI))->F$DCB.NAME#.C);
    IF LISTED < 1
      THEN DO;
        WRT.V.DCB# = DCBNUM(M$LO);
        CALL M$WRITE(WRT);
        LISTED = 1;
        END;
 
    IF ( LISTED < 2 ) AND NOT FLG$LODO
      THEN DO;
        WRT.V.DCB# = DCBNUM(M$DO);
        CALL M$WRITE(WRT);
        LISTED = 2;
        END;
 
    IF (NOT (ADDR(P_BUF_) = ADDR(NIL)))
      THEN DO;
        PRT_BUF.BUF = SUBSTR(VBASE(P_BUF_)->BASED_CHARS,0,VBOUND(P_BUF_)+1);
        WRT.BUF_ = VECTOR(PRT_BUF);
        WRT.BUF_.BOUND = SIZEC(PRT_BUF.HEAD) + VBOUND(P_BUF_);
        WRT.V.DCB# = DCBNUM(M$LO);
        CALL M$WRITE(WRT);
        IF NOT FLG$LODO
          THEN DO;
            WRT.V.DCB#=DCBNUM(M$DO);
            CALL M$WRITE(WRT);
            END;
        END;
 
    ERR.CODE_ = VECTOR(P_ERRCODE);
    CALL M$ERRMSG(ERR);
 
END GOPHER$ERR;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
GOPHER$ALLOC:PROC( P_BUF_ );
 
  DCL P_BUF_ VECTOR;
 
  DCL BUF_POOL(0:4) CHAR(%(4*1024)) CALIGNED STATIC;
  DCL NEXT_BUF UBIN WORD STATIC INIT(0);
 
 
    P_BUF_ = VECTOR(BUF_POOL(NEXT_BUF));
    NEXT_BUF = NEXT_BUF + 1;
 
    RETURN;
 
GOPHER$REL:ENTRY( P_BUF_ );
 
    NEXT_BUF = NEXT_BUF - 1;
 
END GOPHER$ALLOC;
