#-h-  ratfor                     4496  local   12/01/80  15:53:43
# Ratfor preprocessor
      include 'RATFOR_CR1.:XSI'
#---------------------------------------------------------------
# The definition STDEFNS defines the file which contains the
# standard definitions to be used when preprocessing a file.
# It is opened and read automatically by the ratfor preprocessor.
# Set STDEFNS to the name of the file in which the standard
# definitions reside.  If you don't want the preprocessor to
# automatically open this file, set STDENFS to "".
#
#---------------------------------------------------------------
#    If you want the preprocessor to output upper case only,
#    set the following definition:
#
#              define (UPPERC,)
#
#---------------------------------------------------------------
#  Some of the buffer sizes and other symbols might have to be
#  changed.  Especially check the following:
#
#        MAXDEF         (number of characters in a definition)
#        SBUFSIZE       (nbr string declarations allowed per module)
#        MAXSTRTBL      (size of table to buffer string declarations)
#        MAXSWITCH      (max stack for switch statement)
#
#-----------------------------------------------------------------
define (STDEFNS,"")        # name of file containing standard defns
define (UPPERC,)           # define if Fortran compiler wants upper case
define (RADIX,PERCENT)     # % indicates alternate radix
define (TOGGLE,PERCENT)    # toggle for literal lines
define (ARGFLAG,DOLLAR)
define (CUTOFF,3)          # min nbr of cases to generate branch table
                           # (for switch statement)
define (DENSITY,2)         # reciprocal of density necessary for
                           # branch table
define (FILLCHAR,DIG0)     # used in long-name uniquing
#define (MAXIDLENGTH,6)    # for Fortran 66 and 77
# Lexical items:
define (LEXBREAK,-8)
define (LEXCASE,-25)
define (LEXDEFAULT,-26)
define (LEXDIGITS,-9)
define (LEXDO,-10)
define (LEXELSE,-11)
define (LEXEND,-21)
define (LEXFOR,-16)
define (LEXIF,-19)
define (LEXLITERAL,-27)
define (LEXNEXT,-13)
define (LEXOTHER,-14)
define (LEXREPEAT,-17)
define (LEXRETURN,-20)
define (LEXSTOP,-22)
define (LEXSTRING,-23)
define (LEXSWITCH,-24)
define (LEXUNTIL,-18)
define (LEXWHILE,-15)
define (LSTRIPC,-10)
define (RSTRIPC,-11)
# Built-in macro functions:
define (DEFTYPE,-4)
define (MACTYPE,-10)
define (IFTYPE,-11)
define (INCTYPE,-12)
define (SUBTYPE,-13)
define (ARITHTYPE,-14)
define (IFDEFTYPE,-15)
define (IFNOTDEFTYPE,-16)
# Size-limiting definitions:
define (MEMSIZE,50000)     # space allotted to symbol tables and macro text
define (BUFSIZE,400)       # pushback buffer for ngetch and putbak
define (PBPOINT,400)       # point in buffer where pushback begins
define (SBUFSIZE,500)      # buffer for string statements
define (MAXDEF,400)       # max chars in a defn
define (MAXFORSTK,200)     # max space for for reinit clauses
define (MAXFNAMES, arith(NFILES,*,FILENAMESIZE))
define (MAXSTACK,100)      # max stack depth for parser
define (MAXSWITCH,1000)    # max stack for switch statement
define (MAXTOK,100)        # max chars in a token
define (NFILES,5)
define (MAXNBRSTR,20)      #max nbr string declarations per module
define (CALLSIZE,50)
define (ARGSIZE,100)
define (EVALSIZE,500)
# Where to find the common blocks:
define(COMMON_BLOCKS,'RATFOR_CR2.:XSI')
   include COMMON_BLOCKS
   COMMON /ECOUNT/ NERRORS
   DATA NERRORS /0/
   LOGICAL LISTS, LISTF, LISTL, LISTI, strng, keyseq
   COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, strng, keyseq
   integer open
   string defns STDEFNS # name of standard definitions file
   # Read file containing standard definitions
   # If this isn't desired, define (STDEFNS,"")
   call initst
   if (defns (1) != EOS) [
      infile (1) = open (defns, READ)
      if (infile (1) == ERR)
         call remark ("can't open standard definitions file.")
      else [
         call parse
         call close (infile (1))
         ]
      ]
   CALL STARTUP
   call initkw  # initialize variables
   INFILE (1) = STDIN
   CALL PARSE
   IF (NERRORS > 0)
      CALL EOUT (NERRORS)
   if (LISTL)
      call lndict
   call endst
   IF (NERRORS > 0)
      CALL EXIT (6)
   ELSE
      CALL EXIT (0)
   end
#-t-  ratfor                     4496  local   12/01/80  15:53:43
#-h-  addchr                      254  local   12/01/80  15:53:44
# addchr - put c in buf (bp) if it fits, increment bp
   subroutine addchr (c, buf, bp, maxsiz)
   integer bp, maxsiz
   character c, buf (ARB)
   if (bp > maxsiz)
      call baderr ("buffer overflow.")
   buf (bp) = c
   bp = bp + 1
   return
   end
#-t-  addchr                      254  local   12/01/80  15:53:44
#-h-  allblk                      486  local   12/01/80  15:53:44
# allblk - determine if line consists of all blanks
# this routine is called by outdon, and is here to fix
# a bug which sometimes occurs if two or more includes precede the
# first line of executable code.  Could not trace down the cause
   integer function allblk (buf)
   character buf (ARB)
   integer i
   allblk = YES
   for (i = 1; buf (i) != NEWLINE & buf (i) != EOS; i = i + 1)
      if (buf (i) != BLANK) [
         allblk = NO
         break
         ]
   return
   end
#-t-  allblk                      486  local   12/01/80  15:53:44
#-h-  alldig                      306  local   12/01/80  15:53:45
# alldig - return YES if str is all digits
   integer function alldig (str)
   character str (ARB)
   integer i
   alldig = NO
   if (str (1) == EOS)
      return
   for (i = 1; str (i) != EOS; i = i + 1)
      if (!IS_DIGIT(str (i)))
         return
   alldig = YES
   return
   end
#-t-  alldig                      306  local   12/01/80  15:53:45
#-h-  baderr                      144  local   12/01/80  15:53:45
# baderr --- report fatal error message, then die
   subroutine baderr (msg)
   character msg (ARB)
   call synerr (msg)
   call endst
   end
#-t-  baderr                      144  local   12/01/80  15:53:45
#-h-  balpar                      854  local   12/01/80  15:53:46
# balpar - copy balanced paren string
   subroutine balpar
   character t, token (MAXTOK)
   character gettok, gnbtok
   integer nlpar
   if (gnbtok (token, MAXTOK) != LPAREN) [
      call synerr ("missing left paren.")
      return
      ]
   call outstr (token)
   nlpar = 1
   repeat [
      t = gettok (token, MAXTOK)
      if (t == SEMICOL | t == LBRACE | t == RBRACE | t == EOF) [
         call pbstr (token)
         break
         ]
      if (t == NEWLINE)      # delete newlines
         token (1) = EOS
      else if (t == LPAREN)
         nlpar = nlpar + 1
      else if (t == RPAREN)
         nlpar = nlpar - 1
      if (t == ALPHA)
         call squash (token)
      # else nothing special
      call outstr (token)
      ] until (nlpar <= 0)
   if (nlpar != 0)
      call synerr ("missing parenthesis in condition.")
   return
   end
#-t-  balpar                      854  local   12/01/80  15:53:46
#-h-  brknxt                     1077  local   12/01/80  15:53:46
# brknxt - generate code for break n and next n; n = 1 is default
   subroutine brknxt (sp, lextyp, labval, token)
   integer labval (MAXSTACK), lextyp (MAXSTACK), sp, token
   integer i, n
   integer alldig, ctoi
   character t, ptoken (MAXTOK)
   character gnbtok
   include COMMON_BLOCKS
   n = 0
   t = gnbtok (ptoken, MAXTOK)
   if (alldig (ptoken) == YES) [     # have break n or next n
      i = 1
      n = ctoi (ptoken, i) - 1
      ]
   else if (t != SEMICOL)      # default case
      call pbstr (ptoken)
   DO i = sp, 1, -1
      if (lextyp (i) == LEXWHILE | lextyp (i) == LEXDO
        | lextyp (i) == LEXFOR | lextyp (i) == LEXREPEAT) [
         if (n > 0) [
            n = n - 1
            next             # seek proper level
            ]
         else if (token == LEXBREAK)
            call outgo (labval (i) + 1)
         else
            call outgo (labval (i))
         xfer = YES
         return
         ]
   if (token == LEXBREAK)
      call synerr ("illegal break.")
   else
      call synerr ("illegal next.")
   return
   end
#-t-  brknxt                     1077  local   12/01/80  15:53:46
#-h-  cascod                     1876  local   12/01/80  15:53:46
# cascod - generate code for case or default label
   subroutine cascod (lab, token)
   integer lab, token
   include COMMON_BLOCKS
   integer t, l, lb, ub, i, j, junk
   integer caslab, labgen, gnbtok
   character tok (MAXTOK)
   if (swtop <= 0) [
      call synerr ("illegal case or default.")
      return
      ]
   call outgo (lab + 1) # terminate previous case
   xfer = YES
   l = labgen (1)
   if (token == LEXCASE) [ # case nÜ,n!... : ...
      while (caslab (lb, t) != EOF) [
         ub = lb
         if (t == MINUS)
            junk = caslab (ub, t)
         if (lb > ub) [
            call synerr ("illegal range in case label.")
            ub = lb
            ]
         if (swlast + 3 > MAXSWITCH)
            call baderr ("switch table overflow.")
         FOR (I = SWTOP + 3; I < SWLAST; I = I + 3)
            if (lb <= swstak (i))
               break
            else if (lb <= swstak (i+1))
               call synerr ("duplicate case label.")
         if (i < swlast & ub >= swstak (i))
            call synerr ("duplicate case label.")
         FOR (J = SWLAST; J > I; J = J - 1)   # INSERT NEW ENTRY
            swstak (j+2) = swstak (j-1)
         swstak (i) = lb
         swstak (i + 1) = ub
         swstak (i + 2) = l
         swstak (swtop + 1) = swstak (swtop + 1)  +  1
         swlast = swlast + 3
         if (t == COLON)
            break
         else if (t != COMMA)
            call synerr ("illegal case syntax.")
         ]
      ]
   else [   # default : ...
      t = gnbtok (tok, MAXTOK)
      if (swstak (swtop + 2) != 0)
         call error ("multiple defaults in switch statement.")
      else
         swstak (swtop + 2) = l
      ]
   if (t == EOF)
      call synerr ("unexpected EOF.")
   else if (t != COLON)
      call error ("missing colon in case or default label.")
   xfer = NO
   call outcon (l)
   return
   end
#-t-  cascod                     1876  local   12/01/80  15:53:46
#-h-  caslab                      624  local   12/01/80  15:53:47
# caslab - get one case label
   integer function caslab (n, t)
   integer n, t
   character tok (MAXTOK)
   integer i, s
   integer gnbtok, ctoi
   t = gnbtok (tok, MAXTOK)
   while (t == NEWLINE)
      t = gnbtok (tok, MAXTOK)
   if (t == EOF)
      return (t)
   if (t == MINUS)
      s = -1
   else
      s = +1
   if (t == MINUS | t == PLUS)
      t = gnbtok (tok, MAXTOK)
   if (t != DIGIT) [
      call synerr ("invalid case label.")
      n = 0
      ]
   else [
      i = 1
      n = s * ctoi (tok, i)
      ]
   t = gnbtok (tok, MAXTOK)
   while (t == NEWLINE)
      t = gnbtok (tok, MAXTOK)
   return
   end
#-t-  caslab                      624  local   12/01/80  15:53:47
#-h-  deftok                     4116  local   12/01/80  15:53:47
# deftok - get token; process macro calls and invocations
# this routine has been disabled to allow defines with parameters to be added
#   character function deftok (token, toksiz)
#   character gtok
#   integer toksiz
#   character defn (MAXDEF), t, token (MAXTOK)
#   integer ludef
#   include COMMON_BLOCKS
#
#   for (t = gtok (token, toksiz); t!=EOF; t = gtok (token, toksiz)) [
#      if (t != ALPHA)   # non-alpha
#         break
#      if (ludef (token, defn, deftbl) == NO)     # undefined
#         break
#      if (defn (1) == DEFTYPE) [   # get definition
#         call getdef (token, toksiz, defn, MAXDEF)
#         call entdef (token, defn, deftbl)
#         ]
#      else
#         call pbstr (defn)   # push replacement onto input
#      ]
#   deftok = t
#   if (deftok == ALPHA)   # convert to single case
#      call fold (token)
#   return
#   end
# deftok - get token; process macro calls and invocations
   character function deftok (token, toksiz)
   character token (MAXTOK)
   integer toksiz
   include COMMON_BLOCKS
   character t, c, defn (MAXDEF), mdefn (MAXDEF)
   character gtok
   integer ap, argstk (ARGSIZE), callst (CALLSIZE),
      nlb, plev (CALLSIZE), ifl
   integer ludef, push, ifparm
   string balp "()"
   cp = 0
   ap = 1
   ep = 1
   for (t = gtok (token, toksiz); t != EOF; t = gtok (token, toksiz)) [
      if (t == ALPHA)
         if (ludef (token, defn, deftbl) == NO)
            if (cp == 0)
               break
            else
               call puttok (token)
         else if (defn (1) == DEFTYPE) [   # process defines directly
            call getdef (token, toksiz, defn, MAXDEF)
            call entdef (token, defn, deftbl)
            ]
         else if (defn (1) == IFDEFTYPE | defn (1) == IFNOTDEFTYPE) [
            c = defn (1)
            call getdef (token, toksiz, defn, MAXDEF)
            ifl = ludef (token, mdefn, deftbl)
            if ((ifl == YES & c == IFDEFTYPE) |
             (ifl == NO & c == IFNOTDEFTYPE))
               call pbstr (defn)
            ]
         else [
            cp = cp +  1
            if (cp > CALLSIZE)
               call baderr ("call stack overflow.")
            callst (cp) = ap
            ap = push (ep, argstk, ap)
            call puttok (defn)
            call putchr (EOS)
            ap = push (ep, argstk, ap)
            call puttok (token)
            call putchr (EOS)
            ap = push (ep, argstk, ap)
            t = gtok (token, toksiz)
            if (t == BLANK) [             # allow blanks before arguments
               t = gtok (token, toksiz)
               call pbstr (token)
               if (t != LPAREN)
                  call putbak (BLANK)
               ]
            else
               call pbstr (token)
            if (t != LPAREN)
               call pbstr (balp)
            else if (ifparm (defn) == NO)
               call pbstr (balp)
            plev (cp) = 0
            ]
      else if (t == LSTRIPC) [
         nlb = 1
         repeat [
            t = gtok (token, toksiz)
            if (t == LSTRIPC)
               nlb = nlb + 1
            else if (t == RSTRIPC) [
               nlb = nlb - 1
               if (nlb == 0)
                  break
               ]
            else if (t == EOF)
            call baderr ("EOF in string.")
            call puttok (token)
            ]
         ]
      else if (cp == 0)
         break
      else if (t == LPAREN) [
         if (plev (cp) > 0)
            call puttok (token)
         plev (cp) = plev (cp) + 1
         ]
      else if (t == RPAREN) [
         plev (cp) = plev (cp) - 1
         if (plev (cp) > 0)
            call puttok (token)
         else [
            call putchr (EOS)
            call evalr (argstk, callst (cp), ap - 1)
            ap = callst (cp)
            ep = argstk (ap)
            cp =  cp - 1
            ]
         ]
      else if (t == COMMA & plev (cp) == 1) [
         call putchr (EOS)
         ap = push (ep, argstk, ap)
         ]
      else
         call puttok (token)
      ]
   deftok = t
   if (t == ALPHA)
      call fold (token)
   return
   end
#-t-  deftok                     4116  local   12/01/80  15:53:47
#-h-  doarth                      636  local   12/01/80  15:53:48
# doarth - do arithmetic operation
   subroutine doarth (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer k, l
   integer ctoi
   character op
   k = argstk (i + 2)
   l = argstk (i + 4)
#  Revised 15JUL82 by Rob Janes.  The previous version did not permit
#    blanks before the operator of the ARITH function.
#    The form ARITH (something, +, something else) gave an arith error'
#  op = evalst (argstk (i + 3))
   j = argstk (i + 3)
   op = evalst (j)
   while (op == BLANK) [
      j = j + 1
      op = evalst (j)
      if (op == EOS)
         break
      ]
   if (op == PLUS)
      call pbnum (ctoi (evalst, k) + ctoi (evalst, l))
   else if (op == MINUS)
      call pbnum (ctoi (evalst, k) - ctoi (evalst, l))
   else if (op ==  STAR )
      call pbnum (ctoi (evalst, k) * ctoi (evalst, l))
   else if (op ==  SLASH )
      call pbnum (ctoi (evalst, k) / ctoi (evalst, l))
   else
      call remark ('arith error.')
   return
   end
#-t-  doarth                      636  local   12/01/80  15:53:48
#-h-  docode                      522  local   12/01/80  15:53:49
# docode - generate code for beginning of do
   subroutine docode (lab)
   integer lab
   integer labgen
   include COMMON_BLOCKS
   character gnbtok
   character lexstr (MAXTOK)
   string sdo "do"
   xfer = NO
   call outtab
   call outstr (sdo)
   call outch (BLANK)
   lab = labgen (2)
   if (gnbtok (lexstr, MAXTOK) == DIGIT) # check for fortran DO
      call outstr (lexstr)
   else [
      call pbstr (lexstr)
      call outnum (lab)
      ]
   call outch (BLANK)
   call eatup
   call outdon
   return
   end
#-t-  docode                      522  local   12/01/80  15:53:49
#-h-  doif                        458  local   12/01/80  15:53:49
# doif - select one of two (macro) arguments
   subroutine doif (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer a2, a3, a4, a5
   integer equal
   if (j - i < 5)
      return
   a2 = argstk (i + 2)
   a3 = argstk (i + 3)
   a4 = argstk (i + 4)
   a5 = argstk (i + 5)
   if (equal (evalst (a2), evalst (a3)) == YES)   # subarrays
      call pbstr (evalst (a4))
   else
      call pbstr (evalst (a5))
   return
   end
#-t-  doif                        458  local   12/01/80  15:53:49
#-h-  doincr                      246  local   12/01/80  15:53:49
# doincr - increment macro argument by 1
   subroutine doincr (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer k
   integer ctoi
   k = argstk (i + 2)
   call pbnum (ctoi (evalst, k) + 1)
   return
   end
#-t-  doincr                      246  local   12/01/80  15:53:49
#-h-  domac                       326  local   12/01/80  15:53:49
# domac - install macro definition in table
   subroutine domac (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer a2, a3
   if (j - i > 2) [
      a2 = argstk (i + 2)
      a3 = argstk (i + 3)
      call entdef (evalst (a2), evalst (a3), deftbl)     # subarrays
      ]
   return
   end
#-t-  domac                       326  local   12/01/80  15:53:49
#-h-  dostat                      156  local   12/01/80  15:53:50
# dostat - generate code for end of do statement
   subroutine dostat (lab)
   integer lab
   call outcon (lab)
   call outcon (lab + 1)
   return
   end
#-t-  dostat                      156  local   12/01/80  15:53:50
#-h-  dosub                       709  local   12/01/80  15:53:50
# dosub - select macro substring
   subroutine dosub (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer ap, fc, k, nc
   integer ctoi, length
   if (j - i < 3)
      return
   if (j - i < 4)
      nc = MAXTOK
   else [
      k = argstk (i + 4)
      nc = ctoi (evalst, k)      # number of characters
      ]
   k = argstk (i + 3)         # origin
   ap = argstk (i + 2)         # target string
   fc = ap + ctoi (evalst, k) - 1   # first char of substring
   if (fc >= ap & fc < ap + length (evalst (ap))) [   # subarrays
      k = fc + min (nc, length (evalst (fc))) - 1
       for ( ; k >= fc; k = k - 1)
          call putbak (evalst (k))
       ]
    return
    end
#-t-  dosub                       709  local   12/01/80  15:53:50
#-h-  eatup                      1137  local   12/01/80  15:53:50
# eatup - process rest of statement; interpret continuations
   subroutine eatup
   character ptoken (MAXTOK), t, token (MAXTOK)
   character gettok
   integer nlpar
   nlpar = 0
   repeat [
      t = gettok (token, MAXTOK)
      if (t == SEMICOL | t == NEWLINE)
         break
      if (t == RBRACE | t == LBRACE) [
         call pbstr (token)
         break
         ]
      if (t == EOF) [
         call synerr ("unexpected EOF.")
         call pbstr (token)
         break
         ]
      if (t == COMMA | t == PLUS | t == MINUS | t == STAR |
     t == LPAREN | t == AMPER | t == BAR | t == BANG | t ==TILDE
       | t == NOT | t == CARET | t == EQUALS | t == UNDERLINE) [
         while (gettok (ptoken, MAXTOK) == NEWLINE)
            ;
         call pbstr (ptoken)
         if (t == UNDERLINE)
            token (1) = EOS
         ]
      if (t == LPAREN)
         nlpar = nlpar + 1
      else if (t == RPAREN)
         nlpar = nlpar - 1
      if (t == ALPHA)
         call squash (token)
      call outstr (token)
      ] until (nlpar < 0)
   if (nlpar != 0)
      call synerr ("unbalanced parentheses.")
   return
   end
#-t-  eatup                      1137  local   12/01/80  15:53:50
#-h-  elseif                      155  local   12/01/80  15:53:51
# elseif - generate code for end of if before else
   subroutine elseif (lab)
   integer lab
   lab = 0
   call ELSE
   return
   end
#-t-  elseif                      155  local   12/01/80  15:53:51
#-h-  entdef                      387  local   12/01/80  15:53:51
# entdef - enter a new symbol definition, discarding any old one
   subroutine entdef (name, defn, table)
   character name (MAXTOK), defn (ARB)
   pointer table
   integer lookup
   pointer text
   pointer sdupl
   if (lookup (name, text, table) == YES)
      call dsfree (text)   # this is how to do UNDEFINE, by the way
   call enter (name, sdupl (defn), table)
   return
   end
#-t-  entdef                      387  local   12/01/80  15:53:51
#-h-  entdkw                      975  local   12/01/80  15:54:05
# entdkw --- install macro processor keywords
   subroutine entdkw
   character deft (2), inct (2), subt (2), ift (2), art (2), ifdft (2),
      ifndt (2), mact (2)
   string defnam "define"
   string macnam "mdefine"
   string incnam "incr"
   string subnam "substr"
   string ifnam "ifelse"
   string arnam "arith"
   string ifdfnm "ifdef"
   string ifndnm "ifnotdef"
   data deft (1), deft (2) /DEFTYPE, EOS/
   data mact (1), mact (2) /MACTYPE, EOS/
   data inct (1), inct (2) /INCTYPE, EOS/
   data subt (1), subt (2) /SUBTYPE, EOS/
   data ift (1), ift (2) /IFTYPE, EOS/
   data art (1), art (2) /ARITHTYPE, EOS/
   data ifdft (1), ifdft (2) /IFDEFTYPE, EOS/
   data ifndt (1), ifndt (2) /IFNOTDEFTYPE, EOS/
   call ulstal (defnam, deft)
   call ulstal (macnam, mact)
   call ulstal (incnam, inct)
   call ulstal (subnam, subt)
   call ulstal (ifnam, ift)
   call ulstal (arnam, art)
   call ulstal (ifdfnm, ifdft)
   call ulstal (ifndnm, ifndt)
   return
   end
#-t-  entdkw                      975  local   12/01/80  15:54:05
#-h-  entfkw                      981  local   12/01/80  15:54:06
# entfkw - place Fortran keywords in symbol table
   subroutine entfkw
   include COMMON_BLOCKS
   # Place in the following table any long (> 6 characters)
   #  keyword that is used by your Fortran compiler:
  string schar "character"
   string sconti "continue"
   string scompl "complex"
   string slogic "logical"
   string simpli "implicit"
   string sparam "parameter"
   string sexter "external"
   string sdimen "dimension"
   string sinteg "integer"
   string sequiv "equivalence"
   string sfunct "function"
   string ssubro "subroutine"
   string spreci "precision"
  call enter (schar, 0, fkwtbl)
   call enter (sconti, 0, fkwtbl)
   call enter (scompl, 0, fkwtbl)
   call enter (slogic, 0, fkwtbl)
   call enter (simpli, 0, fkwtbl)
   call enter (sparam, 0, fkwtbl)
   call enter (sexter, 0, fkwtbl)
   call enter (sdimen, 0, fkwtbl)
   call enter (sinteg, 0, fkwtbl)
   call enter (sequiv, 0, fkwtbl)
   call enter (sfunct, 0, fkwtbl)
   call enter (ssubro, 0, fkwtbl)
   call enter (spreci, 0, fkwtbl)
   return
   end
#-t-  entfkw                      981  local   12/01/80  15:54:06
#-h-  entrkw                     1003  local   12/01/80  15:54:06
# entrkw --- install Ratfor keywords in symbol table
   subroutine entrkw
   include COMMON_BLOCKS
 
   string sif "if"
   string selse "else"
   string swhile "while"
   string sdo "do"
   string sbreak "break"
   string snext "next"
   string sfor "for"
   string srept "repeat"
   string suntil "until"
   string sret "return"
   string sstr "string"
   string sswtch "switch"
   string scase "case"
   string sdeflt "default"
  logical lists, listf, listl, listi, strng, keyseq
  common /clist/ lists, listf, listl, listi, strng, keyseq
   call enter (sif, LEXIF, rkwtbl)
   call enter (selse, LEXELSE, rkwtbl)
   call enter (swhile, LEXWHILE, rkwtbl)
   call enter (sdo, LEXDO, rkwtbl)
   call enter (sbreak, LEXBREAK, rkwtbl)
   call enter (snext, LEXNEXT, rkwtbl)
   call enter (sfor, LEXFOR, rkwtbl)
   call enter (srept, LEXREPEAT, rkwtbl)
   call enter (suntil, LEXUNTIL, rkwtbl)
   call enter (sret, LEXRETURN, rkwtbl)
   if (strng)
      call enter (sstr, LEXSTRING, rkwtbl)
   call enter (sswtch, LEXSWITCH, rkwtbl)
   call enter (scase, LEXCASE, rkwtbl)
   call enter (sdeflt, LEXDEFAULT, rkwtbl)
   return
   end
#-t-  entrkw                     1003  local   12/01/80  15:54:06
#-h-  evalr                      1126  local   12/01/80  15:54:06
# evalr - expand args i through j: evaluate builtin or push back defn
   subroutine evalr (argstk, i, j)
   integer argstk (ARGSIZE), i, j
   include COMMON_BLOCKS
   integer argno, k, m, n, t, td
   integer indx, length
   string digits '0123456789'
   t = argstk (i)
   td = evalst (t)
   if (td == MACTYPE)
      call domac (argstk, i, j)
   else if (td == INCTYPE)
      call doincr (argstk, i, j)
   else if (td == SUBTYPE)
      call dosub (argstk, i, j)
   else if (td == IFTYPE)
      call doif (argstk, i, j)
   else if (td == ARITHTYPE)
      call doarth (argstk, i, j)
   else [
      for (k = t + length (evalst (t)) - 1; k > t; k = k - 1)
         if (evalst (k - 1) != ARGFLAG)
            call putbak (evalst (k))
         else [
            argno = indx (digits, evalst (k))  -  1
            if (argno >= 0 & argno < j - i) [
               n = i + argno + 1
               m = argstk (n)
               call pbstr (evalst (m))
               ]
            k = k - 1   # skip over $
            ]
      if (k == t)         # do last character
         call putbak (evalst (k))
      ]
   return
   end
#-t-  evalr                      1126  local   12/01/80  15:54:06
#-h-  finit                       432  local   12/01/80  15:54:07
# finit - initialize for each input file
   subroutine finit
   include COMMON_BLOCKS
   outp = 0  # output character pointer
   level = 1  # file control
   linect (1) = 0
   sbp  = 1
   fnamp = 2
   fnames (1) = EOS
   bp = PBPOINT
   buf (bp) = EOS    # to force a read on next call to 'ngetch'
   fordep = 0  # for stack
   fcname (1) = EOS # current function name
   swtop = 0  # switch stack
   swlast = 1
   return
   end
#-t-  finit                       432  local   12/01/80  15:54:07
#-h-  forcod                     2259  local   12/01/80  15:54:07
# forcod - beginning of for statement
   subroutine forcod (lab)
   integer lab
   include COMMON_BLOCKS
   character t, token (MAXTOK)
   character gettok, gnbtok
   integer i, j, nlpar
   integer length, labgen
   string ifnot "if (.not."
   lab = labgen (3)
   call outcon (0)
   if (gnbtok (token, MAXTOK) != LPAREN) [
      call synerr ("missing left paren.")
      return
      ]
   if (gnbtok (token, MAXTOK) != SEMICOL) [   # real init clause
      call pbstr (token)
      call outtab
      call eatup
      call outdon
      ]
   if (gnbtok (token, MAXTOK) == SEMICOL)   # empty condition
      call outcon (lab)
   else [   # non-empty condition
      call pbstr (token)
      call outnum (lab)
      call outtab
      call outstr (ifnot)
      call outch (LPAREN)
      nlpar = 0
      while (nlpar >= 0) [
         t = gettok (token, MAXTOK)
         if (t == SEMICOL)
            break
         if (t == LPAREN)
            nlpar = nlpar + 1
         else if (t == RPAREN)
            nlpar = nlpar - 1
         if (t == EOF) [
            call pbstr (token)
            return
            ]
         if (t == ALPHA)
            call squash (token)
         if (t != NEWLINE & t != UNDERLINE)
            call outstr (token)
         ]
      call outch (RPAREN)
      call outch (RPAREN)
      call outgo (lab+2)
      if (nlpar < 0)
         call synerr ("invalid for clause.")
      ]
   fordep = fordep + 1   # stack reinit clause
   j = 1
   DO i = 1, fordep-1   # find end
      j = j + length (forstk (j)) + 1
   forstk (j) = EOS   # null, in case no reinit
   nlpar = 0
   t = gnbtok (token, MAXTOK)
   call pbstr (token)
   while (nlpar >= 0) [
      t = gettok (token, MAXTOK)
      if (t == LPAREN)
         nlpar = nlpar + 1
      else if (t == RPAREN)
         nlpar = nlpar - 1
      if (t == EOF) [
         call pbstr (token)
         break
         ]
      if (nlpar >= 0 & t != NEWLINE & t != UNDERLINE) [
         if (t == ALPHA)
            call squash (token)
         if (j + length (token) >= MAXFORSTK)
            call baderr ("for clause too long.")
         call scopy (token, 1, forstk, j)
         j = j + length (token)
         ]
      ]
   lab = lab + 1   # label for next's
   return
   end
#-t-  forcod                     2259  local   12/01/80  15:54:07
#-h-  fors                        458  local   12/01/80  15:54:08
# fors - process end of for statement
   subroutine fors (lab)
   integer lab
   include COMMON_BLOCKS
   integer i, j
   integer length
   xfer = NO
   call outnum (lab)
   j = 1
   DO i = 1, fordep-1
      j = j + length (forstk (j)) + 1
   if (length (forstk (j)) > 0) [
      call outtab
      call outstr (forstk (j))
      call outdon
      ]
   call outgo (lab - 1)
   call outcon (lab + 1)
   fordep = fordep - 1
   return
   end
#-t-  fors                        458  local   12/01/80  15:54:08
#-h-  getdef                     1634  local   12/01/80  15:54:08
# getdef (for no arguments) - get name and definition
   subroutine getdef (token, toksiz, defn, defsiz)
   character token (MAXTOK), defn (MAXDEF)
   integer toksiz, defsiz
   include COMMON_BLOCKS
   character c, t, ptoken (MAXTOK)
   character gtok, ngetch
   integer i, nlpar
   call skpblk
   c = gtok (ptoken, MAXTOK)
   if (c == LPAREN)
      t = LPAREN             # define (name, defn)
   else [
      t = BLANK              # define name defn
      call pbstr (ptoken)
      ]
   call skpblk
   if (gtok (token, toksiz) != ALPHA)
      call baderr ("non-alphanumeric name.")
   call skpblk
   c = gtok (ptoken, MAXTOK)
   if (t == BLANK) [         # define name defn
      call pbstr (ptoken)
      i = 1
      repeat [
         c = ngetch (c)
         if (i > defsiz)
            call baderr ("definition too long.")
         defn (i) = c
         i = i + 1
         ] until (c == SHARP | c == NEWLINE | c == EOF)
      if (c == SHARP)
         call putbak (c)
      ]
   else if (t == LPAREN) [   # define (name, defn)
      if (c != COMMA)
         call baderr ("missing comma in define.")
      # else got (name,
      nlpar = 0
      for (i = 1; nlpar >= 0; i = i + 1)
         if (i > defsiz)
            call baderr ("definition too long.")
         else if (ngetch (defn (i)) == EOF)
            call baderr ("missing right paren.")
         else if (defn (i) == LPAREN)
            nlpar = nlpar + 1
         else if (defn (i) == RPAREN)
            nlpar = nlpar - 1
         # else normal character in defn (i)
      ]
   else
      call baderr ("getdef is confused.")
   defn (i - 1) = EOS
   return
   end
#-t-  getdef                     1634  local   12/01/80  15:54:08
#-h-  gettok                     2076  local   12/01/80  15:54:09
# gettok - get token. handles file inclusion and line numbers
   character function gettok (token, toksiz)
   character token (MAXTOK)
   integer toksiz
   include COMMON_BLOCKS
   integer i, len
   integer equal, open, length
   character name (MAXNAME), t
   character deftok
   string fncn "function"
   string incl "include"
   for ( ; level > 0; level = level - 1) [
      for (gettok = deftok (token, toksiz); gettok != EOF;
       gettok = deftok (token, toksiz)) [
         if (equal (token, fncn) == YES) [
            call skpblk
            t = deftok (fcname, MAXNAME)
            call pbstr (fcname)
            if (t != ALPHA)
               call synerr ("missing function name.")
            call putbak (BLANK)
            return
            ]
         else if (equal (token, incl) == NO)
            return
         # process 'include' statements:
         call skpblk
         t = deftok (name, MAXNAME)
         if (t == SQUOTE | t == DQUOTE) [
            len = length (name) - 1
            DO i = 1, len-1
               name (i) = name (i + 1)
            name (i) = EOS
            ]
         i = length (name) + 1
         if (level >= NFILES)
            call synerr ("includes nested too deeply.")
         else [
            infile (level + 1) = open (name, READ)
            linect (level + 1) = 0
            if (infile (level + 1) == ERR)
               call synerr ("can't open include.")
            else [
               level = level + 1
               if (fnamp + i <= MAXFNAMES) [
                  call scopy (name, 1, fnames, fnamp)
                  fnamp = fnamp + i    # push file name stack
                  ]
               ]
            ]
         ]
      if (level > 1) [      # close include file pop file name stack
         call close (infile (level))
         for (fnamp = fnamp - 1; fnamp > 1; fnamp = fnamp - 1)
            if (fnames (fnamp - 1) == EOS)
               break
         ]
      ]
   token (1) = EOF   # in case called more than once
   token (2) = EOS
   gettok = EOF
   return
   end
#-t-  gettok                     2076  local   12/01/80  15:54:09
#-h-  gnbtok                      237  local   12/01/80  15:54:09
# gnbtok - get nonblank token
   character function gnbtok (token, toksiz)
   character token (MAXTOK)
   integer toksiz
   include COMMON_BLOCKS
   character gettok
   call skpblk
   gnbtok = gettok (token, toksiz)
   return
   end
#-t-  gnbtok                      237  local   12/01/80  15:54:09
#-h-  gtok                       3278  local   12/01/80  15:54:10
# gtok - get token for Ratfor
   character function gtok (lexstr, toksiz)
   character lexstr (MAXTOK)
   integer toksiz
   include COMMON_BLOCKS
   character c
   character ngetch, clower
   integer i, b, n, d
   integer itoc, indx
   string digits "0123456789abcdefghijklmnopqrstuvwxyz"
   c = ngetch (lexstr (1))
   if (c == BLANK | c == TAB) [
      lexstr (1) = BLANK
      while (c == BLANK | c == TAB) # compress many blanks to one
         c = ngetch (c)
      if (c == SHARP)
         while (ngetch (c) != NEWLINE)   # strip comments
            ;
      if (c != NEWLINE)
         call putbak (c)
      else
         lexstr (1) = NEWLINE
      lexstr (2) = EOS
      gtok = lexstr (1)
      return
      ]
   i = 1
   if (IS_LETTER(c) ) [   # define ?
      DO i = 1, toksiz-3 [
         c = ngetch (lexstr (i + 1))
         if (!IS_LETTER(c) & !IS_DIGIT(c) & c != UNDERLINE )
            break
         ]
      call putbak (c)
      gtok = ALPHA
      ]
   else if (c == ATSIGN) [ # defines with periods allowed here
      DO i = 1, toksiz-3 [
         c = ngetch (lexstr (i+1))
         if (!IS_LETTER(c) & !IS_DIGIT(c) & c != UNDERLINE & c != PERIOD)
            break
         ]
      call putbak (c)
      gtok = ALPHA
      ]
   else if (IS_DIGIT(c)) [   # digits
      b = c - DIG0 # in case alternate base number
      DO i = 1, toksiz-3 [
         c = ngetch (lexstr (i + 1))
         if (!IS_DIGIT(c))
            break
         b = 10 * b + c - DIG0
         ]
      if (c == RADIX & b >= 2 & b <= 36) [   #n%ddd...
         n = 0
         repeat [
            d = indx (digits, clower (ngetch (c))) - 1
            if (d < 0)
               break
            n = b * n + d
            ]
         call putbak (c)
         i = itoc (n, lexstr, toksiz)
         ]
      else
         call putbak (c)
      gtok = DIGIT
      ]
   else if (c == LBRACK) [   # allow Ü for |
      lexstr (1) = LBRACE
      gtok = LBRACE
      ]
   else if (c == RBRACK) [   # allow ! for ]
      lexstr (1) = RBRACE
      gtok = RBRACE
      ]
   else if (c == DOLLAR) [    # $( and $) now used by macro processor
      if (ngetch (lexstr (2)) == LPAREN) [
         i = 2
         gtok = LBRACE
         ]
      else if (lexstr (2) == RPAREN) [
         i = 2
         gtok = RBRACE
         ]
      ELSE IF (LEXSTR(2) == RBRACK) [
         I = 2
         GTOK = RSTRIPC
         ]
      ELSE IF (LEXSTR(2) == LBRACE) [
         I = 2
         GTOK = LSTRIPC
         ]
      else [
         call putbak (lexstr (2))
         gtok = DOLLAR
         ]
      ]
   else if (c == SQUOTE | c == DQUOTE) [
      gtok = c
      for (i = 2; ngetch (lexstr (i)) != lexstr (1); i = i + 1) [
         IF (LEXSTR(I) == ATSIGN)
            CALL COLLECTTOKEN (LEXSTR, I)
         if (lexstr (i) == UNDERLINE)
            if (ngetch (c) == NEWLINE) [
               while (c == NEWLINE | c == BLANK | c == TAB)
                  c = ngetch (c)
               lexstr (i) = c
               IF (LEXSTR(I) == ATSIGN) [
                  CALL PUTBAK(LEXSTR(I))
                  I = I - 1
               ]
               ]
            else
               call putbak (c)
         if (lexstr (i) == NEWLINE | i >= toksiz - 1) [
            call synerr ("missing quote.")
            lexstr (i) = lexstr (1)
            call putbak (NEWLINE)
            break
            ]
         ]
      ]
   else if (c == SHARP) [   # strip comments
      while (ngetch (lexstr (1)) != NEWLINE)
         ;
      gtok = NEWLINE
      ]
   else if (c == GREATER | c == LESS | c == NOT | c == BANG |
    c==TILDE | c == CARET | c == EQUALS | c == AMPER | c == BAR)[
      call relate (lexstr, i)
      gtok = c
      ]
   else
      gtok = c
   if (i >= toksiz - 1)
      call synerr ("token too long.")
   lexstr (i + 1) = EOS
   # Note:  line number accounting is now done in 'ngetch'
   return
   end
#-t-  gtok                       3278  local   12/01/80  15:54:10
#-h-  ifcode                      198  local   12/01/80  15:54:10
# ifcode - generate initial code for if
   subroutine ifcode (lab)
   integer lab
   include COMMON_BLOCKS
   xfer = NO
   lab = 0
   call ifthen
   return
   end
#-t-  ifcode                      198  local   12/01/80  15:54:10
#-h-  ifgo                        347  local   12/01/80  15:54:11
# ifgo - generate "if (.not.(...))goto lab"
   subroutine ifgo (lab)
   integer lab
   string ifnot "if (.not."
   call outtab         # get to column 7
   call outstr (ifnot)      # " if (.not. "
   call balpar         # collect and output condition
   call outch (RPAREN)      # " ) "
   call outgo (lab)      # " goto lab "
   return
   end
#-t-  ifgo                        347  local   12/01/80  15:54:11
#-h-  ifparm                      689  local   12/01/80  15:54:11
# ifparm - determines if the defined symbol has arguments in its
# definition.  This effects how the macro is expanded.
   integer function ifparm (strng)
   character strng (ARB)
   character c
   integer i, indx, type
   c = strng (1)
   if (c ==INCTYPE | c ==SUBTYPE | c ==IFTYPE | c ==ARITHTYPE |
    c == MACTYPE)
      ifparm = YES
   else [
      ifparm = NO
      for (i = 1; indx (strng (i), ARGFLAG) > 0; ) [
         i = i + indx (strng (i), ARGFLAG) # i points at char after ARGFLAG
         if (type (strng (i)) == DIGIT)
         andif (type (strng (i + 1)) != DIGIT) [
            ifparm = YES
            break
            ]
         ]
      ]
   return
   end
#-t-  ifparm                      689  local   12/01/80  15:54:11
#-h-  initkw                      549  local   12/01/80  15:54:11
# initkw - initialize tables and important global variables
   subroutine initkw
   include COMMON_BLOCKS
   pointer mktabl
   call dsinit (MEMSIZE)
   deftbl = mktabl (1)     # symbol table for definitions
   call entdkw
   rkwtbl = mktabl (1)     # symbol table for Ratfor key words
   call entrkw
   fkwtbl = mktabl (0)     # symbol table for Fortran key words
   call entfkw
   namtbl = mktabl (1)     # symbol table for long identifiers
   gentbl = mktabl (0)     # symbol table for generated identifiers
   label = 23000
   return
   end
#-t-  initkw                      549  local   12/01/80  15:54:11
#-h-  labelc                      404  local   12/01/80  15:54:12
# labelc - output statement number
   subroutine labelc (lexstr)
   character lexstr (ARB)
   include COMMON_BLOCKS
   integer length
   xfer = NO   # can't suppress goto's now
   if (length (lexstr) == 5)   # warn about 23xxx labels
      if (lexstr (1) == DIG2 & lexstr (2) == DIG3)
         call synerr ("warning: possible label conflict.")
   call outstr (lexstr)
   call outtab
   return
   end
#-t-  labelc                      404  local   12/01/80  15:54:12
#-h-  labgen                      189  local   12/01/80  15:54:12
# labgen - generate  n  consecutive labels, return first one
   integer function labgen (n)
   integer n
   include COMMON_BLOCKS
   labgen = label
   label = label + n
   return
   end
#-t-  labgen                      189  local   12/01/80  15:54:12
#-h-  lex                         543  local   12/01/80  15:54:12
# lex - return lexical type of token
   integer function lex (lexstr)
   character lexstr (MAXTOK), TOKEN(MAXTOK)
   include COMMON_BLOCKS
   character gnbtok
   integer lookup
   LOGICAL PUSHBK
   SAVE LSAVE, TOKEN
   DATA PUSHBK/.FALSE./
   IF (PUSHBK) GO TO 10
   for (lex = gnbtok (lexstr, MAXTOK); lex == NEWLINE;
    lex = gnbtok (lexstr, MAXTOK))
      ;
   if (lex == EOF | lex == SEMICOL | lex == LBRACE | lex == RBRACE)
      return
   if (lex == DIGIT)
      lex = LEXDIGITS
   else if (lex == TOGGLE)
      lex = LEXLITERAL
   else if (lookup (lexstr, lex, rkwtbl) == YES)
      ;
   else
      lex = LEXOTHER
   return
10 PUSHBK = .FALSE.
   CALL SCOPY (TOKEN, 1, LEXSTR, 1)
   LEX = LSAVE
   RETURN
 
   ENTRY PBLEX (LTYPE, LEXSTR)
   PUSHBK = .TRUE.
   CALL SCOPY (LEXSTR, 1, TOKEN, 1)
   LSAVE = LTYPE
   PBLEX=0
   LEX = 0
   end
#-t-  lex                         543  local   12/01/80  15:54:12
#-h-  litral                      316  local   12/01/80  15:54:13
# litral - process literal Fortran line
   subroutine litral
   include COMMON_BLOCKS
   character ngetch
   # Finish off any left-over characters
   if (outp > 0)
      call outdon
   for (outp = 1; ngetch (outbuf (outp)) != NEWLINE; outp = outp + 1)
      ;
   outp = outp - 1
   call outdon
   return
   end
#-t-  litral                      316  local   12/01/80  15:54:13
#-h-  lndict                      678  local   12/01/80  15:54:13
# lndict - output long-name dictionary as a debugging aid
   subroutine lndict
   include COMMON_BLOCKS
   character sym (MAXTOK), c
   character cupper
   integer sctabl
   pointer posn, locn
   posn = 0
   while (sctabl (namtbl, sym, locn, posn) != EOF) [
      call putch (BIGC, LISTOUT)
      call putch (BLANK, LISTOUT)
      for (; mem (locn) != EOS; locn = locn + 1) [
         c = mem (locn) # kluge for people with LOGICAL*1 characters
         ifdef (UPPERC, c = cupper (c))
         call putch (c, LISTOUT)
         ]
      call putch (BLANK, LISTOUT)
      call putch (BLANK, LISTOUT)
      CALL UPPER (SYM)
      call putlin (sym, LISTOUT)
      call putch (NEWLINE, LISTOUT)
      ]
   return
   end
#-t-  lndict                      678  local   12/01/80  15:54:13
#-h-  ludef                       495  local   12/01/80  15:54:29
# ludef --- look up a defined identifier, return its definition
   integer function ludef (id, defn, table)
   character id (ARB), defn (ARB)
   pointer table
   include COMMON_BLOCKS
   integer i
   integer lookup
   pointer locn
   ludef = lookup (id, locn, table)
   if (ludef == YES) [
      i = 1
      for (; mem (locn) != EOS; locn = locn + 1) [
         defn (i) = mem (locn)
         i = i + 1
         ]
      defn (i) = EOS
      ]
   else
      defn (1) = EOS
   return
   end
#-t-  ludef                       495  local   12/01/80  15:54:29
#-h-  ngetch                      442  local   12/01/80  15:54:30
# ngetch - get a (possibly pushed back) character
   character function ngetch (c)
   character c
   include COMMON_BLOCKS
   integer getlin
   if (buf (bp) == EOS)
      if (getlin (buf (PBPOINT), infile (level)) == EOF)
         c = EOF
      else [
         c = buf (PBPOINT)
         bp = PBPOINT + 1
         linect (level) = linect (level) + 1
         CALL STORER (BUF(PBPOINT), INFILE(LEVEL), LINECT(LEVEL))
         ]
   else [
      c = buf (bp)
      bp = bp + 1
      ]
   return (c)
   end
#-t-  ngetch                      442  local   12/01/80  15:54:30
#-h-  otherc                      284  local   12/01/80  15:54:30
# otherc - output ordinary Fortran statement
   subroutine otherc (lexstr)
   character lexstr (ARB)
   include COMMON_BLOCKS
   xfer = NO
   call outtab
   if (IS_LETTER(lexstr (1)))
      call squash (lexstr)
   call outstr (lexstr)
   call eatup
   call outdon
   return
   end
#-t-  otherc                      284  local   12/01/80  15:54:30
#-h-  outch                       357  local   12/01/80  15:54:30
# outch - put one character into output buffer
   subroutine outch (c)
   character c
   include COMMON_BLOCKS
   integer i
   if (outp >= 72) [   # continuation card
      call outdon
      DO I = 1, 5
         outbuf (i) = BLANK
      outbuf (6) = STAR
      outp = 6
      ]
   outp = outp + 1
   outbuf (outp) = c
   return
   end
#-t-  outch                       357  local   12/01/80  15:54:30
#-h-  outcon                      332  local   12/01/80  15:54:31
# outcon - output "n   continue"
   subroutine outcon (n)
   integer n
   include COMMON_BLOCKS
 
   string contin "continue"
   xfer = NO
   if (n <= 0 & outp == 0)
      return            # don't need unlabeled continues
   if (n > 0)
      call outnum (n)
   call outtab
   call outstr (contin)
   call outdon
   return
   end
#-t-  outcon                      332  local   12/01/80  15:54:31
#-h-  outdon                      257  local   12/01/80  15:54:31
# outdon - finish off an output line
   subroutine outdon
   include COMMON_BLOCKS
   logical lists, listf, listl, listi, strng, keyseq
   common /clist/ lists, listf, listl, listi, strng, keyseq
   COMMON /KEYSTUFF/ KEY
   integer allblk
   outbuf (outp + 1) = NEWLINE
   outbuf (outp + 2) = EOS
    IF (ALLBLK (OUTBUF) == NO) [
       CALL STOREF (OUTBUF)
       IF (KEYSEQ) [
          DO I = OUTP+1, 72
             OUTBUF(I) = BLANK
          IF (LEVEL >= 1)
             I = LEVEL
          ELSE
             I = 1
          IF (KEY < 0) [
             CALL DECIMAL (LINECT(I), OUTBUF(73), 8)
             OUTBUF(81) = NEWLINE
             OUTBUF(82) = EOS
          ]
          ELSE [
             CALL DECIMAL (KEY/1000, OUTBUF(73), 5)
             CALL DECIMAL (MOD (KEY,1000)+1000, OUTBUF(78), 4)
             OUTBUF(78) = PERIOD   # COVER UP 1 OF THE 1,000
             OUTBUF(82) = NEWLINE
             OUTBUF(83) = EOS
          ]
       ]
       CALL PUTLIN (OUTBUF, STDOUT)
    ]
   outp = 0
   return
   end
#-t-  outdon                      257  local   12/01/80  15:54:31
#-h-  outgo                       239  local   12/01/80  15:54:31
# outgo - output "goto  n"
   subroutine outgo (n)
   integer n
   include COMMON_BLOCKS
 
   string sgoto "goto "
   if (xfer == YES)
      return
   call outtab
   call outstr (sgoto)
   call outnum (n)
   call outdon
   return
   end
#-t-  outgo                       239  local   12/01/80  15:54:31
#-h-  outnum                      381  local   12/01/80  15:54:32
# outnum - output decimal number
   subroutine outnum (n)
   integer n
   character chars (MAXCHARS)
   integer i, m
   m = iabs (n)
   i = 0
   repeat [
      i = i + 1
      chars (i) = mod (m, 10) + DIG0
      m = m / 10
      ] until (m == 0 | i >= MAXCHARS)
   if (n < 0)
      call outch (MINUS)
   for ( ; i > 0; i = i - 1)
      call outch (chars (i))
   return
   end
#-t-  outnum                      381  local   12/01/80  15:54:32
#-h-  outstr                      687  local   12/01/80  15:54:32
# outstr - output string; handles quoted literals
   subroutine outstr (str)
   character str (ARB)
   character c
   character cupper
   integer i, j
   for (i = 1; str (i) != EOS; i = i + 1) [
      c = str (i)
      if (c != SQUOTE & c != DQUOTE) [
                         # produce upper case fortran, if desired
         ifdef (UPPERC,
            c = cupper (c)
            )
         call outch (c)
         ]
      else [
         i = i + 1
         for (j = i; str (j) != c; j = j + 1)   # find end
            ;
         IF (C == SQUOTE)
            CALL OUTCH (SQUOTE)
         ELSE [
            call outnum (j - i)
            call outch (BIGH)
            ]
         for ( ; i < j; i = i + 1)
            call outch (str (i))
         IF (C == SQUOTE)
            CALL OUTCH (SQUOTE)
         ]
      ]
   return
   end
#-t-  outstr                      687  local   12/01/80  15:54:32
#-h-  outtab                      140  local   12/01/80  15:54:32
# outtab - get past column 6
   subroutine outtab
   include COMMON_BLOCKS
 
   while (outp < 6)
      call outch (BLANK)
   return
   end
#-t-  outtab                      140  local   12/01/80  15:54:32
#-h-  parse                      2627  local   12/01/80  15:54:32
# parse - parse Ratfor source program
   subroutine parse
    DIMENSION ISAVESP(MAXSTACK)
   include COMMON_BLOCKS
   character lexstr (MAXTOK)
   integer lab, labval (MAXSTACK), lextyp (MAXSTACK), sp, token, i
   integer lex, PBLEX
   call finit
   sp = 1
   lextyp (1) = EOF
    ISP = 0
   for (token = lex (lexstr); token != EOF; token = lex (lexstr)) [
      if (token == LEXIF)
         call ifcode (lab)
      else if (token == LEXDO)
         call docode (lab)
      else if (token == LEXWHILE)
         call whilec (lab)
      else if (token == LEXFOR)
         call forcod (lab)
      else if (token == LEXREPEAT)
         call repcod (lab)
      else if (token == LEXSWITCH)
         call swcode (lab)
      else if (token == LEXCASE | token == LEXDEFAULT) [
         DO i = sp, 1, -1   # find for most recent switch
            if (lextyp (i) == LEXSWITCH)
               break
         if (i == 0)
            call synerr ("illegal case or default.")
         else
            call cascod (labval (i), token)
         ]
      else if (token == LEXDIGITS)
         call labelc (lexstr)
      else if (token == LEXELSE) [
         if (lextyp (sp) == LEXIF)
            call elseif (labval (sp))
         else
            call synerr ("illegal else.")
         ]
      else if (token == LEXLITERAL)
         call litral
      if (token == LEXIF | token == LEXWHILE
        | token == LEXFOR | token == LEXREPEAT | token == LEXSWITCH
        | token == LEXDO | token == LEXDIGITS | token == LBRACE) [
         sp = sp + 1         # beginning of statement
         if (sp > MAXSTACK)
            call baderr ("stack overflow in parser.")
         lextyp (sp) = token      # stack type and value
         labval (sp) = lab
         ]
       ELSE IF (TOKEN == LEXELSE) [
          NEWTOKEN = LEX(LEXSTR)
          IF (NEWTOKEN != LEXIF) [
             CALL OUTDON
             ISP = ISP + 1
             ISAVESP(ISP) = sp + 1
             ]
          IDUMMY = PBLEX (NEWTOKEN, LEXSTR)
          sp = sp + 1
          IF (sp > MAXSTACK)
             CALL BADERR ("STACK OVERFLOW IN PARSER.")
          LEXTYP(sp) = TOKEN
          LABVAL(sp) = LAB
          ]
      else if (token != LEXCASE & token != LEXDEFAULT) [
         if (token == RBRACE) [
            if (lextyp (sp) == LBRACE)
               sp = sp - 1
            else if (lextyp (sp) == LEXSWITCH) [
               call swend (labval (sp))
               sp = sp - 1
               ]
            else
               call synerr ("illegal right brace.")
            ]
         else if (token == LEXOTHER)
            call otherc (lexstr)
         else if (token == LEXBREAK | token == LEXNEXT)
            call brknxt (sp, lextyp, labval, token)
         else if (token == LEXRETURN)
            call retcod
         else if (token == LEXSTRING)
            call strdcl
         token = lex (lexstr)      # peek at next token
         IDUMMY = PBLEX (TOKEN, lexstr)
          FOR (I=ISP; I>0; I=I-1)
             IF (ISAVESP(I) >= sp) [
                CALL IFEND
                ISP = ISP - 1
                ]
         call unstak (sp, lextyp, labval, token)
          FOR (I=ISP; I>0; I=I-1)
             IF (ISAVESP(I) >= sp) [
                CALL IFEND
                ISP = ISP - 1
                ]
         ]
      ]
   if (sp != 1)
      call synerr ("unexpected EOF.")
   return
   end
#-t-  parse                      2627  local   12/01/80  15:54:32
#-h-  pbnum                       304  local   12/01/80  15:54:33
# pbnum - convert number to string, push back on input
   subroutine pbnum (n)
   integer n
   integer m, num
   integer mod
   string digits '0123456789'
#     REVISED 29JUL82 BY ROB JANES  TO ALLOW PUSHING BACK NEGATIVE
#     NUMBERS.  THE ARITH FUNCTION COULDN'T HANDLE NEGATIVE RESULTS
#     CORRECTLY BECAUSE OF THIS.
   num = iabs (n)
   repeat [
      m = mod (num, 10)
      call putbak (digits (m + 1))
      num = num / 10
      ] until (num == 0)
#    CONTINUE OF THE REVISION TO ALLOW PUSHING BACK NEGATIVE VALUES
   if (n < 0)
      call putbak (MINUS)
   return
   end
#-t-  pbnum                       304  local   12/01/80  15:54:33
#-h-  pbstr                       207  local   12/01/80  15:54:33
# pbstr - push string back onto input
   subroutine pbstr (in)
   character in (ARB)
   integer i
   integer length
   DO i = length (in), 1, -1
      call putbak (in (i))
   return
   end
#-t-  pbstr                       207  local   12/01/80  15:54:33
#-h-  push                        249  local   12/01/80  15:54:34
# push - push ep onto argstk, return new pointer ap
   integer function push (ep, argstk, ap)
   integer ap, argstk (ARGSIZE), ep
   if (ap > ARGSIZE)
      call baderr ('arg stack overflow.')
   argstk (ap) = ep
   push = ap + 1
   return
   end
#-t-  push                        249  local   12/01/80  15:54:34
#-h-  putbak                      254  local   12/01/80  15:54:34
# putbak - push character back onto input
   subroutine putbak (c)
   character c
   include COMMON_BLOCKS
 
   if (bp <= 1)
      call baderr ("too many characters pushed back.")
   else [
      bp = bp - 1
      buf (bp) = c
      ]
   return
   end
#-t-  putbak                      254  local   12/01/80  15:54:34
#-h-  putchr                      233  local   12/01/80  15:54:34
# putchr - put single char into eval stack
   subroutine putchr (c)
   character c
   include COMMON_BLOCKS
 
   if (ep > EVALSIZE)
      call baderr ('evaluation stack overflow.')
   evalst (ep) = c
   ep = ep + 1
   return
   end
#-t-  putchr                      233  local   12/01/80  15:54:34
#-h-  puttok                      198  local   12/01/80  15:54:34
# puttok-put token into eval stack
    subroutine puttok (str)
    character str (MAXTOK)
    integer i
    for (i = 1; str (i) != EOS; i = i + 1)
       call putchr (str (i))
    return
    end
#-t-  puttok                      198  local   12/01/80  15:54:34
#-h-  relate                     1276  local   12/01/80  15:54:35
# relate - convert relational shorthands into long form
    SUBROUTINE RELATE (TOKEN, LAST)
    character TOKEN (ARB)
    INTEGER LAST
    character NGETCH
    INTEGER LENGTH
    INTEGER T1, T2
    STRING SAND '.AND.'
    STRING SOR '.OR.'
    STRING SNOT '.NOT.'
    STRING SLT '.LT.'
    STRING SGT '.GT.'
    STRING SGE '.GE.'
    STRING SLE '.LE.'
    STRING SEQ '.EQ.'
    STRING SNE '.NE.'
 
    IDUMMY = NGETCH (TOKEN(2))
    IF (TOKEN(2) != EQUALS &  TOKEN(2) != GREATER  &  TOKEN(2) != LESS) [
       CALL PUTBAK (TOKEN(2))
       TOKEN(2) = BLANK
       ]
 
    T1 = TOKEN(1)
    T2 = TOKEN(2)
 
    IF (T1 == TILDE | T1 == CARET)
       T1 = BANG
    IF (T1 == AMPER)   # &
       CALL SCOPY (SAND, 1, TOKEN, 1)
    ELSE IF (T1 == BANG  &  T2 == BLANK)  # ! Ý ~
       CALL SCOPY (SNOT, 1, TOKEN, 1)
    ELSE IF (T1 == BAR)    # |
       CALL SCOPY (SOR, 1, TOKEN, 1)
    ELSE IF (T1 == LESS  &  T2 == BLANK)  # <
       CALL SCOPY (SLT, 1, TOKEN, 1)
    ELSE IF (T1 == GREATER  &  T2 == BLANK)  # >
       CALL SCOPY (SGT, 1, TOKEN, 1)
    ELSE IF (T1 == BANG  &  T2 == EQUALS) # !=
       CALL SCOPY (SNE, 1, TOKEN, 1)
    ELSE IF (T1 == EQUALS &  T2 == EQUALS) # ==
       CALL SCOPY (SEQ, 1, TOKEN, 1)
    ELSE IF ((T1 == LESS  &  T2 == GREATER)  | # <> ><
             (T1 == GREATER  &  T2 == LESS))
       CALL SCOPY (SNE, 1, TOKEN, 1)
    ELSE IF ((T1 == GREATER  &  T2 == EQUALS) | # => >=
             (T1 == EQUALS &  T2 == GREATER))
       CALL SCOPY (SGE, 1, TOKEN, 1)
    ELSE IF ((T1 == LESS  &  T2 == EQUALS) | # <= =<
             (T1 == EQUALS &  T2 == LESS))
       CALL SCOPY (SLE, 1, TOKEN, 1)
    ELSE    # SHOULDN'T HAPPEN
       TOKEN(2) = EOS
    LAST = LENGTH (TOKEN)
    END
#-t-  relate                     1276  local   12/01/80  15:54:35
#-h-  repcod                      262  local   12/01/80  15:54:35
# repcod - generate code for beginning of repeat
   subroutine repcod (lab)
   integer lab
   integer labgen
   call outcon (0)   # in case there was a label
   lab = labgen (3)
   call outcon (lab)
   lab = lab + 1   # label to go on next's
   return
   end
#-t-  repcod                      262  local   12/01/80  15:54:35
#-h-  retcod                      580  local   12/01/80  15:54:35
# retcod - generate code for return
   subroutine retcod
   include COMMON_BLOCKS
   character token (MAXTOK), t
   character gnbtok
   string sret "return"
   t = gnbtok (token, MAXTOK)
   if (t != NEWLINE & t != SEMICOL & t != RBRACE) [
      call pbstr (token)
      call outtab
      call scopy (fcname, 1, token, 1)
      call squash (token)
      call outstr (token)
      call outch (EQUALS)
      call eatup
      call outdon
      ]
   else if (t == RBRACE)
      call pbstr (token)
   call outtab
   call outstr (sret)
   call outdon
   xfer = YES
   return
   end
#-t-  retcod                      580  local   12/01/80  15:54:35
#-h-  sdupl                       374  local   12/01/80  15:55:03
# sdupl --- duplicate a string in dynamic storage space
   pointer function sdupl (str)
   character str (ARB)
   DS_DECL(mem, MEMSIZE)
   integer i
   integer length
   pointer j
   pointer dsget
   j = dsget (length (str) + 1)
   sdupl = j
   for (i = 1; str (i) != EOS; i = i + 1) [
      mem (j) = str (i)
      j = j + 1
      ]
   mem (j) = EOS
   return
   end
#-t-  sdupl                       374  local   12/01/80  15:55:03
#-h-  skpblk                      247  local   12/01/80  15:55:04
# skpblk - skip blanks and tabs in current input file
   subroutine skpblk
   include COMMON_BLOCKS
   character c
   character ngetch
   for (c = ngetch (c); c == BLANK | c == TAB; c = ngetch (c))
      ;
   call putbak (c)
   return
   end
#-t-  skpblk                      247  local   12/01/80  15:55:04
#-h-  squash                     1515  local   12/01/80  15:55:04
# squash - convert a long or special identifier into a Fortran variable
   subroutine squash (id)
   character id (MAXTOK)
   include COMMON_BLOCKS
   COMMON /CMAXID/ MAXID
   integer junk, i, j
   integer lookup
   character newid (MAXTOK), recdid (MAXTOK)
   IF (MAXID == 0)
      RETURN
   j = 1
   for (i = 1; id (i) != EOS; i = i + 1)
      if (IS_LETTER(id (i)) | IS_DIGIT(id (i))) [
         newid (j) = id (i)
         j = j + 1
         ]
   newid (j) = EOS
   if (i - 1 < MAXID & i == j)
      return      # an ordinary (short) Fortran variable
   if (i - 1 == MAXID & i == j)
      if (id (MAXID) != FILLCHAR)
         return   # a 6-character variable, but no possible conflict
   # Otherwise, the identifier (1) is longer than Fortran allows,
   #  (2) contains special characters (_ or .), or (3) is exactly
   #  MAXID characters long and ends with the "fill character."
   #  The first two cases obviously call for name conversion; the last
   #  case requires conversion to avoid accidental conflicts with
   #  automatically generated names.
   if (lookup (id, junk, fkwtbl) == YES)  # Fortran key word?
      return                              # (must be treated as reserved)
   if (ludef (id, recdid, namtbl) == YES) [   # have we seen this before?
      call scopy (recdid, 1, id, 1)
      return
      ]
   call uniqid (newid)  # get an identifier never before seen
   call entdef (id, newid, namtbl)  # record it for posterity
   call scopy (newid, 1, id, 1)  # and substitute it for the old one
   return
   end
#-t-  squash                     1515  local   12/01/80  15:55:04
#-h-  strdcl                     2575  local   12/01/80  15:55:05
# strdcl - generate code for string declaration
   subroutine strdcl
   include COMMON_BLOCKS
   character t, token (MAXTOK), dchar (MAXTOK)
   character gnbtok
   integer i, j, k, n, len, PBLEX, addstr
   integer length, ctoi, lex
   string char "character/"
   string dat "data "
   string eoss "EOS/"
   t = gnbtok (token, MAXTOK)
   if (t != ALPHA)
      call synerr ("missing string token.")
   call squash (token)
   call outtab
   call pbstr (char) # use defined meaning of "character"
   repeat [
      t = gnbtok (dchar, MAXTOK)
      if (t == SLASH)
         break
      call outstr (dchar)
      ]
   call outch (BLANK)  # separator in declaration
   call outstr (token)
   idum = addstr (token, sbuf, sbp, SBUFSIZE)  # save for later
   call addchr (EOS, sbuf, sbp, SBUFSIZE)
   if (gnbtok (token, MAXTOK) != LPAREN) [  # make size same as initial value
      len = length (token) + 1
      if (token (1) == SQUOTE | token (1) == DQUOTE)
         len = len - 2
      ]
   else [ # form is string name (size) init
      t = gnbtok (token, MAXTOK)
      i = 1
      len = ctoi (token, i)
      if (token (i) != EOS)
         call synerr ("invalid string size.")
      if (gnbtok (token, MAXTOK) != RPAREN)
         call synerr ("missing right paren.")
      else
         t = gnbtok (token, MAXTOK)
      ]
   call outch (LPAREN)
   call outnum (len)
   call outch (RPAREN)
   call outdon
   if (token (1) == SQUOTE | token (1) == DQUOTE) [
      len = length (token)
      token (len) = EOS
      idum = addstr (token (2), sbuf, sbp, SBUFSIZE)
      ]
   else
      idum = addstr (token, sbuf, sbp, SBUFSIZE)
   call addchr (EOS, sbuf, sbp, SBUFSIZE)
   t = lex (token)   # peek at next token
   IDUMMY = PBLEX (T, token)
   if (t != LEXSTRING) [   # dump accumulated data statements
      for (i = 1; i < sbp; i = j + 1) [
         call outtab
         call outstr (dat)
         k = 1
         for (j = i + length (sbuf (i)) + 1; ; j = j + 1) [
            if (k > 1)
               call outch (COMMA)
            call outstr (sbuf (i))
            call outch (LPAREN)
            call outnum (k)
            call outch (RPAREN)
            call outch (SLASH)
            if (sbuf (j) == EOS)
               break
            n = sbuf (j)
            call outnum (n)
            call outch (SLASH)
            k = k + 1
            ]
         call pbstr (eoss) # use defined meaning of EOS
         repeat [
            t = gnbtok (token, MAXTOK)
            call outstr (token)
            ] until (t == SLASH)
         call outdon
         ]
      sbp = 1
      ]
   return
   end
#-t-  strdcl                     2575  local   12/01/80  15:55:05
#-h-  swcode                      746  local   12/01/80  15:55:06
# swcode - generate code for beginning of switch statement
   subroutine swcode (lab)
   integer lab, T
   include COMMON_BLOCKS
   character tok (MAXTOK)
   integer labgen, gnbtok
   lab = labgen (2)
   if (swlast + 3 > MAXSWITCH)
      call baderr ("switch table overflow.")
   swstak (swlast) = swtop
   swstak (swlast + 1) = 0
   swstak (swlast + 2) = 0
   swtop = swlast
   swlast = swlast + 3
   xfer = NO
   call outtab  # Innn=(e)
   call swvar (lab)
   call outch (EQUALS)
   call balpar
   call outdon
   call outgo (lab) # goto L
   xfer = YES
   REPEAT
      T = GNBTOK (TOK, MAXTOK)
   UNTIL (T .NE. NEWLINE)
   if (t != LBRACE) [
      call synerr ("missing left brace in switch statement.")
      call pbstr (tok)
      ]
   return
   end
#-t-  swcode                      746  local   12/01/80  15:55:06
#-h-  swend                      2714  local   12/01/80  15:55:07
# swend - finish off switch statement; generate dispatch code
   subroutine swend (lab)
   integer lab
   include COMMON_BLOCKS
   integer lb, ub, n, i, j
   string sif "if ("
   string slt ".lt.1.or."
   string sgt ".gt."
   string sgoto "goto ("
   string seq ".eq."
   string sge ".ge."
   string sle ".le."
   string sand ".and."
   lb = swstak (swtop + 3)
   ub = swstak (swlast - 2)
   n = swstak (swtop + 1)
   call outgo (lab + 1) # terminate last case
   if (swstak (swtop + 2) == 0)
      swstak (swtop + 2) = lab + 1  # default default label
   xfer = NO
   call outcon (lab)  # L   continue
   if (n >= CUTOFF & ub - lb + 1 < DENSITY * n) [ # output branch table
      if (lb != 1) [  # L  Innn=Innn-lb+1
         call outtab
         call swvar (lab)
         call outch (EQUALS)
         call swvar (lab)
         if (lb < 1)
            call outch (PLUS)
         call outnum (-lb + 1)
         call outdon
         ]
      call outtab  #  if (Innn.lt.1.or.Innn.gt.ub-lb+1)goto default
      call outstr (sif)
      call swvar (lab)
      call outstr (slt)
      call swvar (lab)
      call outstr (sgt)
      call outnum (ub - lb + 1)
      call outch (RPAREN)
      call outgo (swstak (swtop + 2))
      call outtab  #  goto (....),Innn
      call outstr (sgoto)
      j = lb
      FOR (I = SWTOP + 3; I < SWLAST; I = I + 3) [
         for ( ; j < swstak (i); j = j + 1) [ # fill in vacancies
            call outnum (swstak (swtop + 2))
            call outch (COMMA)
            ]
          FOR (J = SWSTAK(I + 1) - SWSTAK (I); J>=0; J = J -1) [
            call outnum (swstak (i + 2)) # fill in range
            IF (J > 0)
               CALL OUTCH (COMMA)
            ]
         j = swstak (i + 1) + 1
         if (i < swlast - 3)
            call outch (COMMA)
         ]
      call outch (RPAREN)
      call outch (COMMA)
      call swvar (lab)
      call outdon
      ]
   else if (n > 0) [  # output linear search form
      FOR (I = SWTOP + 3; I < SWLAST; I = I + 3) [
         call outtab  # if (Innn
         call outstr (sif)
         call swvar (lab)
         if (swstak (i) == swstak (i+1)) [
            call outstr (seq) #   .eq....
            call outnum (swstak (i))
            ]
         else [
            call outstr (sge) #   .ge.lb.and.Innn.le.ub
            call outnum (swstak (i))
            call outstr (sand)
            call swvar (lab)
            call outstr (sle)
            call outnum (swstak (i + 1))
            ]
         call outch (RPAREN) #    ) goto ...
         call outgo (swstak (i + 2))
         ]
      if (lab + 1 != swstak (swtop + 2))
         call outgo (swstak (swtop + 2))
      ]
   call outcon (lab + 1)   # L+1  continue
   swlast = swtop # pop switch stack
   swtop = swstak (swtop)
   return
   end
#-t-  swend                      2714  local   12/01/80  15:55:07
#-h-  swvar                       157  local   12/01/80  15:55:08
# swvar - output switch variable Innn, where nnn = lab
   subroutine swvar (lab)
   integer lab
   call outch (BIGI)
   call outnum (lab)
   return
   end
#-t-  swvar                       157  local   12/01/80  15:55:08
#-h-  synerr                      703  local   12/01/80  15:55:08
# synerr --- report non-fatal error
   subroutine synerr (msg)
   character msg (ARB)
   include COMMON_BLOCKS
   COMMON /ECOUNT/ NERRORS
   LOGICAL KEYFLAG
   COMMON /KEYEDIN/ KEYFLAG
   character lc (MAXCHARS)
   integer i, junk
   integer itoc
   string in " in "
   string errmsg " error at line "
   NERRORS = NERRORS + 1
   call putlin (errmsg, ERROUT)
   if (level >= 1)
      i = level
   else
      i = 1 # for EOF errors
   junk = itoc (linect (i), lc, MAXCHARS)
   call putlin (lc, ERROUT)
   for (i = fnamp - 1; i > 1; i = i - 1)
      if (fnames (i - 1) == EOS) [  # print file name
         call putlin (in, ERROUT)
         call putlin (fnames (i), ERROUT)
         break
         ]
   call putch (COLON, ERROUT)
   IF (KEYFLAG)
      CALL KEYOUT (STDIN, ERROUT)
   call putch (NEWLINE, ERROUT)
   call remark (msg)
   return
   end
#-t-  synerr                      703  local   12/01/80  15:55:08
#-h-  ulstal                      268  local   12/01/80  15:55:09
# ulstal - install lower and upper case versions of symbol
   subroutine ulstal (name, defn)
   character name (ARB), defn (ARB)
   include COMMON_BLOCKS
   call entdef (name, defn, deftbl)
   call upper (name)
   call entdef (name, defn, deftbl)
   return
   end
#-t-  ulstal                      268  local   12/01/80  15:55:09
#-h-  uniqid                     1825  local   12/01/80  15:55:09
# uniqid - convert an identifier to one never before seen
   subroutine uniqid (id)
   character id (MAXTOK)
   include COMMON_BLOCKS
   COMMON /CMAXID/ MAXID
   integer i, j, junk, idchl
   integer lookup, indx, length
   character start (MAXTOK)
   string idch "0123456789abcdefghijklmnopqrstuvwxyz" # legal id characters
   # Pad the identifer out to length 6 with FILLCHARs:
   for (i = 1; id (i) != EOS; i = i + 1)
      ;
   DO J = i, MAXID
      id (J) = FILLCHAR
   i = MAXID + 1
   id (i) = EOS
   id (i - 1) = FILLCHAR
   # Look it up in the table of generated names.  If it's not there,
   #  it's unique.  If it is there, it has been generated previously;
   #  modify it and try again.  Assume this procedure always succeeds,
   #  since to fail implies there are very, very many identifiers in
   #  the symbol table.
   #  Note that we must preserve the first and last characters of the
   #  id, so as not to disturb implicit typing and to provide a flag
   #  to catch potentially conflicting user-defined identifiers without
   #  a lookup.
   if (lookup (id, junk, gentbl) == YES) [   # (not very likely)
      idchl = length (idch)
      DO i = 2, MAXID-1
         start (i) = id (i)
      repeat [    # until we get a unique id
         DO i = MAXID-1, 2, -1 [
            j = mod (indx (idch, id (i)), idchl) + 1
            id (i) = idch (j)
            if (id (i) != start (i))
               break
            ]
         if (i == 1)
            call baderr ("cannot make identifier unique.")
         ] until (lookup (id, junk, gentbl) == NO)
      ]
   # At this point, 'id' contains a unique identifier, not previously
   #  seen in this compilation.  Save it for future reference.
   call enter (id, 0, gentbl)
   return
   end
#-t-  uniqid                     1825  local   12/01/80  15:55:09
#-h-  unstak                      854  local   12/01/80  15:55:10
# unstak - unstack at end of statement
   subroutine unstak (sp, lextyp, labval, token)
   integer labval (MAXSTACK), lextyp (MAXSTACK), sp, token
   for ( ; sp > 1; sp = sp - 1) [
      if (lextyp (sp) == LBRACE | lextyp (sp) == LEXSWITCH)
         break
      if (lextyp (sp) == LEXIF & token == LEXELSE)
         break
      if (lextyp (sp) == LEXIF)
         call IFEND
      else if (lextyp (sp) == LEXELSE) [
         if (sp > 2)
            sp = sp - 1
         ]
      else if (lextyp (sp) == LEXDO)
         call dostat (labval (sp))
      else if (lextyp (sp) == LEXWHILE)
         call whiles (labval (sp))
      else if (lextyp (sp) == LEXFOR)
         call fors (labval (sp))
      else if (lextyp (sp) == LEXREPEAT)
         call untils (labval (sp), token)
      ]
   return
   end
#-t-  unstak                      854  local   12/01/80  15:55:10
#-h-  untils                      397  local   12/01/80  15:55:11
# untils - generate code for until or end of repeat
   subroutine untils (lab, token)
   integer lab, token
   include COMMON_BLOCKS
   character ptoken (MAXTOK)
   integer junk
   integer lex
   xfer = NO
   call outnum (lab)
   if (token == LEXUNTIL) [
      junk = lex (ptoken)
      call ifgo (lab - 1)
      token = lex (ptoken)    # peek at next token just like PARSE
      idummy = pblex (token, ptoken)
      ]
   else
      call outgo (lab - 1)
   call outcon (lab + 1)
   return
   end
#-t-  untils                      397  local   12/01/80  15:55:11
#-h-  whilec                      262  local   12/01/80  15:55:11
# whilec - generate code for beginning of while
   subroutine whilec (lab)
   integer lab
   integer labgen
   call outcon (0)    # unlabeled continue, in case there was a label
   lab = labgen (2)
   call outnum (lab)
   CALL IFTHEN
   return
   end
#-t-  whilec                      262  local   12/01/80  15:55:11
#-h-  whiles                      148  local   12/01/80  15:55:12
# whiles - generate code for end of while
   subroutine whiles (lab)
   integer lab
   call outgo (lab)
   CALL IFEND
   call outcon (lab + 1)
   return
   end
#-t-  whiles                      148  local   12/01/80  15:55:12
#-t-  ratfor.r                  69694  local   12/01/80  15:56:25
    DEFINE(ITERMIN,105)
    DEFINE(ITERMOUT,108)
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: COMLINE
#
#  PURPOSE:
#      PROCESS COMMAND LINE.  THIS INCLUDES FILES SPECIFIED, AND OPTIONS.
#      FORM IS    FILE1 (ON, OVER, TO, INTO) FILE2,FILE3(OPTIONLIST).
#
#  BASIC APPROACH:
#      PARSE LINE INPUT BY CALLS TO DSTRING.  PERFORM PROCESSING FOR EACH ITEM
#      LOCATED
#
#  MAJOR PROGRAM VARIABLES:
#      ERROR - FLAG RETURNED BY SEVERAL ROUTINES
#      IPOS - POINTER INTO COMMAND LINE FOR WHERE PARSING IS UP TO. (USED BY
#            DSTRING
#      ITERMIN - UNIT NUMBER FOR TERMINAL INPUT
#      ITERMOUT - UNIT NUMBER FOR TERMINAL OUTPUT
#      LINE - COMMAND LINE INPUT FROM THE USER
#      MODE - FLAG FOR WHETHER PROGRAM IS USED ON-LINE OR IN BATCH
#      NAME - FILE (OR DEVICE) NAME RETURNED BY DSTRING
#      PREPOS - PREPOSITION RETURNED BY PARSE (ON, OVER, TO, INTO)
#
#  OUTPUT:
#      NOPTIONS - NUMBER OF OPTIONS LOCATED BY THE SCAN
#            OPTIONS (1,*) IS MAJOR COMMAND
#            OPTIONS (2,*) IS SUBCOMMAND (IF THERE IS ANY)
#            THE FORMAT IS
#            OPTIONS(1,1) OPTIONS(2,1)
#            MAJOR        MINOR 1
#                         MINOR 2
#            MAJOR
#            MAJOR
#            MAJOR        MINOR
#            MAJOR        MINOR 1
#            MAJOR        MINOR 2
#
#  ROUTINES CALLED:
#      CLOSE - SOFTWARE TOOLS ROUTINE TO CLOSE A FILE
#      DSTRING - LOCATED A TOKEN FROM A COMMAND LINE
#      OPENCALL - SETS UP FOR CALLING SOFTWARE TOOLS OPEN ROUTINE
#      OUTFILE - OPEN A FILE FOR OUTPUT USING THE PREPOSITION
#      PARSEOPT - PARSE THE OPTIONS
#
#  AUTHOR: ROB JANES
#  DATE:   29JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE COMLINE (NOPTIONS, OPTIONS, MAXOPTIONS)
    CHARACTER OPTIONS(2,MAXOPTIONS)*8, LINE*140, KEYCHAR*3
    LOGICAL BATCH, KEYFLAG
    COMMON /KEYEDIN/ KEYFLAG
 
#   PREPARE INPUT AND OUTPUT UNITS
    CALL OPENCALL ('DISC', 1, -1, ERROR)  # CHANNEL 1 FOR INPUT
    OPEN (5)
    INQUIRE (UNIT=5, KEYED=KEYCHAR)
    KEYFLAG = KEYCHAR == 'YES'
    CALL OPENCALL ('DISC', 2, -2, ERROR)  # CHANNEL 2 FOR OUTPUT
    CALL OPENCALL ('LIST', 7, -2, ERROR)  # CHANNEL 7 FOR OUTPUT
 
#   GET COMMAND LINE
    CALL GETCOM (LINE)
    IPOS = INDEX (LINE, '(')
 
#   ANY OPTIONS?
    IF (IPOS <= 0) [
       NOPTIONS = 0
       RETURN
    ]
 
#   PROCESS OPTIONS
    CALL PARSEOPT (LINE(IPOS:), MAXOPTIONS, NOPTIONS, OPTIONS, ISTATUS)
    IF (ISTATUS <> 0)
       GO TO 10
    RETURN
 
#   REPROMPT JUST FOR OPTIONS
10  IF (BATCH())
       STOP 'ERROR IN OPTIONS'
    WHILE (ISTATUS <> 0) [
       OUTPUT (ITERMOUT) 'REENTER OPTIONS'
       read (ITERMIN,'(A)') LINE
       CALL PARSEOPT (LINE, MAXOPTIONS, NOPTIONS, OPTIONS, ISTATUS)
    ]
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: STARTUP
#
#  PURPOSE:
#      INPUT AND PROCESS AN ENTIRE COMMAND LINE, FILES AND OPTIONS
#
#  BASIC APPROACH:
#      ROUTINE COMLINE FOR FILE PROCESSING AND PARSING OPTIONS
#      ROUTINE DOOPTIONS TO PROCESS OPTIONS SPECIFIED
#
#  MAJOR PROGRAM VARIABLES:
#      ERROR - DUMMY, NOT USED.
#      NOPTIONS - NUMBER OF OPTIONS LOCATED
#      OPTIONS  - LIST OF OPTIONS SPECIFIED
#
#  ROUTINES CALLED:
#      COMLINE - PROCESS FILE SPECIFICATIONS, AND PARSE OPTION LIST
#      DOOPTIONS - PROCESS OPTIONS SPECIFIED
#      OPENCALL - FORMAT DATA FOR PROCESSING A SOFTWARE TOOLS OPEN
#
#  AUTHOR: ROB JANES
#  DATE:   29JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE STARTUP
%      CHARACTER OPTIONS(2,10)*8
    LOGICAL ERROR
 
    OPEN (105, NAME='(ME)')
    OPEN (108, NAME='(LO)')
    CALL COMLINE (NOPTIONS, OPTIONS, 10)
    CALL DOOPTIONS (NOPTIONS, OPTIONS)
    CALL OPENCALL ('(LO)', 3, 2, ERROR)  # ERROUT UNIT
    CLOSE (105)
    CLOSE (108)
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: DOOPTION
#
#  PURPOSE:
#      SET FLAGS AND SUCH DEPENDING SO THAT PROGRAM RESPONDS APPROPRIATELY TO
#      THE OPTION LIST
#
#  BASIC APPROACH:
#      LOOP THROUGH OPTIONS LOCATED
#
#  MAJOR PROGRAM VARIABLES:
#      ERROR - FLAG RETURNED BY VARIOUS ROUTINES
#      ITERMIN  - UNIT NUMBER FOR TERMINAL INPUT
#      ITERMOUT - UNIT NUMBER FOR TERMINAL OUTPUT
#      LINE - LINE OF OPTIONS REINPUT BY USER IN CASE OF ERRORS
#      MODE - FLAG SIGNALING ON-LINE OR BATCH MODE
#
#  INPUT:
#      NOPTIONS - NUMBER OF OPTIONS TO PROCESS
#      OPTIONS -  OPTION LIST
#
#  OUTPUT:
#      KEYSEQ - FLAG WHETHER TO PUT RATFOR SOURCE LINE KEYS IN THE FORTRAN
#            SEQUENCE FIELD
#      LISTF - LIST FORTRAN SOURCE FLAG
#      LISTI - LIST INCLUDES FLAG
#      LISTL - LIST LONG NAME DICTIONARY FLAG
#      LISTS - LIST RATFOR SOURCE FLAG
#      MAXID - NUMBER OF CHARACTERS ALLOWED FOR VARIABLE NAMES
#      STRNG - IS STRING A RATFOR KEYWORD OR NOT.
#
#  ROUTINES CALLED:
#      GETID - FIND OUT IF ON-LINE OR BATCH MODE
#      PARSEOPT - PARSE OPTIONS IF USER HAS TO REENTER OPTIONS LINE
#
#  AUTHOR: ROB JANES
#  DATE:   29JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE DOOPTIONS (NOPTIONS, OPTIONS)
%      CHARACTER OPTIONS (2,1)*8, LINE*80
    LOGICAL LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
    LOGICAL BATCH
    COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
    COMMON /CMAXID/ MAXID
 
    MAXID = 0
    LISTS = .FALSE.
    LISTL = .FALSE.
    LISTF = .FALSE.
    LISTI = .FALSE.
    STRNG = .FALSE.
    KEYSEQ = .FALSE.
 
10  DO I = 1, NOPTIONS
       IF (OPTIONS(1,I) == 'LONGNAME')
          read (OPTIONS(2,I),'(I)') MAXID
       ELSE IF (OPTIONS(1,I) == 'NLS')
          LISTS = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'LS')
          LISTS = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'NLF')
          LISTF = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'LF')
          LISTF = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'NLL')
          LISTL = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'LL')
          LISTL = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'NLI')
          LISTI = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'LI')
          LISTI = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'STRING')
          STRNG = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'NSTRING')
          STRNG = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'KEYSEQ')
          KEYSEQ = .TRUE.
       ELSE IF (OPTIONS(1,I) == 'NKEYSEQ')
          KEYSEQ = .FALSE.
       ELSE IF (OPTIONS(1,I) == 'STOP')
          CALL EXIT
       ELSE IF (OPTIONS(1,I) == 'HELP')
          PRINT 900
       ELSE
          GO TO 20
    RETURN
 
#   REENTER OPTIONS IF AN ERROR WAS FOUND
20  OUTPUT 'INVALID OPTION ENTERED'
    write (ITERMOUT,'(1X,A)') OPTIONS(1,I)
    IF (BATCH())
       STOP 'ERROR IN OPTION LIST'
    OUTPUT 'REENTER OPTIONS'
    read (ITERMIN,'(A)') LINE
    CALL PARSEOPT (LINE, MAXOPTIONS, NOPTIONS, OPTIONS, ISTATUS)
    IF (ISTATUS <> 0)
       GO TO 20
    GO TO 10
 
900 FORMAT (' OPTIONS FOR RATFOR ARE:', /,
       ' (N)LS - LIST RATFOR SOURCE', /,
       ' (N)LF - LIST FORTRAN SOURCE', /,
       ' (N)LI - LIST RATFOR INCLUDES', /,
       ' (N)LL - LIST LONG NAMES DICTIONARY', /,
       ' (N)STRING - ALLOW THE STRING KEYWORD IN RATFOR', /,
       ' (N)KEYSEQ - PUT RATFOR SOURCE KEYS IN THE FORTRAN SOURCE ',
             'SEQUENCE FIELD (73-80)', /,
       ' LONGNAME=n - LENGTH OF FORTRAN VARIABLE NAMES TO GENERATE', //,
       ' DEFAULTS ARE:', /,
       ' NLS, NLF, NLI, NLL, NSTRING, NKEYSEQ, LONGNAME=0', //,
       ' STOP - EXIT RATFOR BACK TO THE SYSTEM', /,
       ' HELP - PRODUCE THIS PRINTOUT')
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: OPENCALL
#
#  PURPOSE:
#      FORMAT DATA FOR CALLING THE SOFTWARE TOOLS ASSIGN ROUTINE
#
#  BASIC APPROACH:
#      CONVERT FROM CHARACTER STRING TO SOFTWARE TOOLS FORMAT,
#      1 CHARACTER PER WORD, RIGHT JUSTIFIED, TERMINATED WITH AN EOS
#
#  MAJOR PROGRAM VARIABLES:
#      INAME - FILE NAME IN SOFTWARE TOOLS STRING FORMAT
#
#  INPUT:
#      IACCESS - TYPE OF ACCESS TO FILE
#            = 1, INPUT
#            = 2, OUTPUT
#            = 3, UPDATE
#            = 4, OUTPUT
#      ICHANNEL - SOFTWARE TOOLS CHANNEL NUMBER
#      NAME - FILE NAME TO BE OPENED, CHARACTER STRING
#
#  OUTPUT:
#      ERROR - FLAG RETURNED
#
#  ROUTINES CALLED:
#      ASSIGN - SOFTWARE TOOLS OPEN ROUTINE
#      LENSIG - .REUSER - SIGNIFICANT LENGTH
#
#  AUTHOR: ROB JANES
#  DATE:   29JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE OPENCALL (NAME, ICHANNEL, IACCESS, ERROR)
%      CHARACTER NAME*(*)
    DIMENSION INAME(51)
    INTEGER ASSIGN
    LOGICAL ERROR
 
    L = MIN (50, LEN (NAME))
    read (NAME,'(50R1)') (INAME(I), I = 1, L)
    INAME(LENSIG(NAME)+1) = EOS
    I = ASSIGN (INAME, ICHANNEL, IACCESS)
 
    ERROR = I == ERR
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: KEYOUT
#
#  PURPOSE:
#      OUTPUT TO THE SPECIFIED UNIT, AN EDIT KEY IN THE FORMAT NNNNN.NNN
#      WHERE THE KEY IS FOUND FROM THE UNIT SPECIFIED BY AN ARGUMENT
#
#  BASIC APPROACH:
#      INQUIRE TO FIND THE KEY AND OUTPUT IT IN 3 PIECES, NNNNN, '.', NNN
#
#  MAJOR PROGRAM VARIABLES:
#      ICHAR - WORKING ARRAY WHEN CONVERTING INTEGER TO CHARACTER
#      IUNIT - ARRAY FOR CONVERTING CHANNEL NUMBERS TO UNIT NUMBERS
#      KEY - KEY TO OUTPUT
#
#  INPUT:
#      INUNIT - CHANNEL NUMBER TO OUTPUT THE KEY FOR
#      IOUTUNIT - CHANNEL NUMBER WHERE TO OUTPUT THE KEY TO
#
#  ROUTINES CALLED:
#      ITOC - INTEGER TO CHARACTER
#      PUTCH - PUT CHARACTER TO OUTPUT STRING
#      PUTINT - OUTPUT AN INTEGER TO OUTPUT STREAM
#      PUTLIN - OUTPUT A STRING TO AN OUTPUT STREAM
#
#  AUTHOR: ROB JANES
#  DATE:   29JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE KEYOUT (INUNIT, IOUTUNIT)
    COMMON /KEYSTUFF/ KEY
 
    CALL KEYPRT (KEY, IOUTUNIT)
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: STORER (STORE RATFOR)
#
#  PURPOSE:
#      PRODUCE RATFOR SOURCE LISTINGS.  IF LIST FORTRAN OPTION IS
#      ALSO IN EFFECT, WORK IN CONJUNCTION WITH IT
#
#  BASIC APPROACH:
#      IF LISTING FORTRAN ALSO, SAVE AWAY LINE FOR LATER PRINTING.
#      IF JUST DOING RATFOR, FORMAT THE LINE AND PRINT IT OUT
#
#  MAJOR PROGRAM VARIABLES:
#      END1 - 'END' IN UPPER CASE
#      END2 - 'END' IN LOWER CASE
#      EOS - END-OF-STRING FLAG
#      ICOUNT - COUNT OF FORTRAN SOURCE LINES PRODUCED
#      ISAVEK - WHEN LISTING FORTRAN AND RATFOR, SAVE THE EDIT KEY
#            FOR THE RATFOR LINE SAVED
#      ISAVEL - SAVE RATFOR SOURCE LINE COUNT
#      IUNITS - ARRAY MAPPING RATFOR CHANNEL NUMBERS TO FORTRAN UNITS #'S
#      KEYSEQ - UNUSED IN THE ROUTINE
#      LISTF - LIST FORTRAN SOURCE FLAG
#      LISTI - LIST RATFOR INCLUDES FLAG
#      LISTL - UNUSED IN THIS ROUTINE
#      LISTOUT - RATFOR CHANNEL # FOR LISTING OUTPUT
#      LISTS - LIST RATFOR SOURCE FLAG
#      MAXOFILES - MAXIMUM # OF RATFOR CHANNEL NUMBERS
#      PAGE - FLAG WHICH SIGNALS WHEN PAGING IS NEEDED
#      PAGE1 - 'PAGE' IN UPPER CASE
#      PAGE2 - 'PAGE' IN LOWER CASE
#      RBUFF - WHEN LISTING FORTRAN AND RATFOR SOURCE, SAVE RATFOR
#            SOURCE HERE WHEN WAITING FOR FORTRAN LINE TO BE PRODUCED
#      RSAVE - FLAG WHICH INDICATES THAT A RATFOR LINE IS SAVED
#            ONLY USED WHEN LISTING RATFOR & FORTRAN SOURCE
#      STDIN - RATFOR CHANNEL # FOR PRIMARY INPUT
#      STRNG - UNUSED IN THIS ROUTINE
#
#  INPUT:
#      IBUFF - SOURCE LINE (RATFOR OR FORTRAN) TO BE LISTED
#      ILINES - LINE COUNT FOR RATFOR SOURCE
#      IUNIT - RATFOR CHANNEL # FROM WHICH RATFOR SOURCE CAME FROM
#            USUALLY STDIN, BUT DIFFERENT FOR INCLUDES
#
#  ROUTINES CALLED:
#      ENDF - CHECK FORTRAN LINE FOR AN END STATEMENT
#      EQUL - CHECK FOR EQUALITY OF CHARACTER STRINGS
#      KEYOUT - OUTPUT AN EDIT KEY TO THE CHANNEL SPECIFIED
#      PUTCH - OUTPUT A CHARACTER TO THE CHANNEL SPECIFIED
#      PUTINT - OUTPUT AN INTEGER TO THE CHANNEL SPECIFIED
#      PUTLINES - WHEN LISTING FORTRAN & RATFOR, OUTPUT A LINE OF
#            EACH
#      SCOPY - STRING COPY
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE STORER (IBUFF, IUNIT, ILINES)
    DIMENSION IBUFF(ARB)
    INTEGER RBUFF(ARB)
    STRING PAGE1 "#PAGE"
    STRING PAGE2 "#page"
    STRING END1 "END"
    STRING END2 "end"
    LOGICAL LISTS, LISTF, LISTL, LISTI, PAGE, RSAVE, ENDF, EQUL,
       STRNG, KEYSEQ
    COMMON /CLIST/ LISTS, LISTF, LISTL, LISTI, STRNG, KEYSEQ
    COMMON /IO/ IUNITS(MAXOFILES)
    LOGICAL KEYFLAG
    COMMON /KEYEDIN/ KEYFLAG
    SAVE ICOUNT, RSAVE, RBUFF, ISAVEL, ISAVEK
    DATA ICOUNT/0/, RSAVE/.FALSE./
 
    IF (! LISTS)
       RETURN
    IF (! LISTI  &  IUNIT .NE. STDIN)
       RETURN
 
    IF (LISTF) [
       IF (RSAVE)  # OUTPUT RATFOR LINE ALREADY SAVE, EOS FOR FORTRAN LINE
          CALL PUTLINES (RSAVE, RBUFF, ISAVEL, ISAVEK, EOS, ICOUNT)
       IF (EQUL (PAGE1, IBUFF)  | EQUL (PAGE2, IBUFF))
          write (IUNITS(LISTOUT),'(''1'')')
       ELSE [  # SAVE AWAY LINE
          CALL SCOPY (IBUFF, 1, RBUFF, 1)
          RSAVE = .TRUE.
          ISAVEL = ILINES
          IF (KEYFLAG)
             INQUIRE (IUNITS(IUNIT), NEXTREC=ISAVEK)
       ]
    ]
    ELSE [  # JUST LISTING RATFOR
       CALL PUTCH (BLANK, LISTOUT)
       CALL PUTINT (ILINES, 4, LISTOUT)  # LINE COUNT
       CALL PUTCH (BLANK, LISTOUT)
       IF (KEYFLAG)
          CALL KEYOUT (IUNIT, LISTOUT)  # EDIT KEY
       CALL PUTCH (BLANK, LISTOUT)
       CALL PUTINT (ICOUNT+1, 4, LISTOUT)  # FORTRAN LINE COUNT
       CALL PUTCH (BLANK, LISTOUT)
       CALL PUTLIN (IBUFF, LISTOUT)  # RATFOR LINE
       IF (EQUL (PAGE1, IBUFF)  | EQUL (PAGE2, IBUFF))  # #PAGE?
          write (IUNITS(LISTOUT),'(''1'')')
       FOR (I=1; IBUFF(I) == BLANK; I=I+1)
          IF (IBUFF(I) == EOS)
             RETURN
       IF (EQUL (END1, IBUFF(I)) | EQUL (END2, IBUFF(I)))  # PAGE AFTER END
          PAGE = .TRUE.
       ELSE
          PAGE = .FALSE.
       IF (PAGE & (IBUFF(I+3) == BLANK  | IBUFF(I+3) == EOS |
          IBUFF(I+3) == NEWLINE))
          write (IUNITS(LISTOUT), '(''1'')')
       ]
    RETURN
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: STOREF (STORE FORTRAN)
#
#  PURPOSE:
#      TAKE A FORTRAN SOURCE LINE READY TO BE OUTPUT AND LIST IT
#      IF RATFOR LISTING IS ALSO BEING PRODUCED, DO BOTH AT ONCE (IF
#      POSSIBLE
#
#  BASIC APPROACH:
#      CHECK TO SEE IF A RATFOR LINE IS SAVED AWAY
#
#  MAJOR PROGRAM VARIABLES:
#      SEE ABOVE
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    ENTRY STOREF (IBUFF)
 
    ICOUNT = ICOUNT + 1
    IF (! LISTF) [
       IF (ENDF (IBUFF))  # RESET COUNTER AFTER EVERY SUBROUTINE
          ICOUNT = 0
       RETURN
       ]
    IF (LISTS)  # LISTING FORTRAN & RATFOR
       CALL PUTLINES (RSAVE, RBUFF, ISAVEL, ISAVEK, IBUFF, ICOUNT)
    ELSE [  # JUST LISTING FORTRAN
       CALL PUTCH (BLANK, LISTOUT)
       CALL PUTINT (ICOUNT, 4, LISTOUT)
       CALL PUTCH (BLANK, LISTOUT)
       CALL PUTLIN (IBUFF, LISTOUT)
       IF (ENDF (IBUFF)) [
          write (IUNITS(LISTOUT),'(''1'')')
          ICOUNT = 0
          ]
       ]
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: PUTLINES
#
#  PURPOSE:
#      OUTPUT BOTH RATFOR AND FORTRAN SOURCE LINES
#
#  BASIC APPROACH:
#      SEE IF THERE WAS A RATFOR LINE SAVED.  IF SO, SEE IF BOTH
#      LINES CAN BE OUTPUT ON 1 PRINTER LINE.
#
#  MAJOR PROGRAM VARIABLES:
#      EOS - END-OF-STRING MARKER
#      IBUFF - STRING WITH FORTRAN SOURCE LINE
#      ICOUNT - FORTRAN SOURCE LINE COUNTER
#      ILINES - RATFOR SOURCE LINE COUNTER
#      IUNIT - RATFOR CHANNEL # FOR INPUT
#      IUNITS - ARRAY MAPPING CHANNEL #'S TO FORTRAN UNIT #'S
#      KEY - EDIT KEY FOR RATFOR SOURCE LINE
#      LISTOUT - CHANNEL # FOR LISTINGS
#      MAXOFILES - MAXIMUM # OF CHANNELS ALLOWED BY SOFTWARE TOOLS
#      RBUFF - STRING WITH RATFOR SOURCE LINE
#      RSAVE - INDICATES IF THERE IS A RATFOR SOURCE LINE IN RBUFF
#             EXTEND INTO THE FORTRAN LISTING AREA
#
#  ROUTINES CALLED:
#      ENDF - CHECK FOR FORTRAN END STATEMENT
#      KEYPRT - PRINT OUT EDIT KEY
#      LENGTH - FIND LENGTH OF RATFOR STRING
#      PUTCH - OUTPUT 1 CHARACTER TO CHANNEL SPECIFIED
#      PUTINT - OUTPUT AN INTEGER TO CHANNEL SPECIFIED
#      PUTLIN - OUTPUT A STRING TO CHANNEL SPECIFIED
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE PUTLINES (RSAVE, RBUFF, ILINES, KEY, IBUFF, ICOUNT)
    INTEGER RBUFF(ARB), IBUFF(ARB)
    LOGICAL RSAVE, SHORT, ENDF
    COMMON /IO/ IUNITS(MAXOFILES)
    LOGICAL KEYFLAG
    COMMON /KEYEDIN/ KEYFLAG
 
    SHORT = .TRUE.
    CALL PUTCH (BLANK, LISTOUT)   # CARRIAGE CONTROL
 
    IF (RSAVE) [  # RATFOR LINE SAVED
       CALL PUTINT (ILINES, 4, LISTOUT)  # LINE COUNT
       CALL PUTCH (BLANK, LISTOUT)
       IF (KEYFLAG)
          CALL KEYPRT (KEY, LISTOUT)  # EDIT KEY
       CALL PUTCH (BLANK, LISTOUT)
       L = LENGTH (RBUFF)
       IF (RBUFF(L) == NEWLINE) [ # REMOVE NEWLINE CHARACTER
          RBUFF(L) = EOS
          L = L - 1
          ]
       IF (L > 39)
          SHORT = .FALSE.
       CALL PUTLIN (RBUFF, LISTOUT)
       RSAVE = .FALSE.
       ]
    ELSE [  # NO RATFOR SOURCE LINE TO OUTPUT
       DO I = 1, 54
          CALL PUTCH (BLANK, LISTOUT)
       L = 40
       ]
 
#   FORTRAN LINE
    IF (IBUFF(1) == EOS) [
       CALL PUTCH (NEWLINE, LISTOUT)
       RETURN
       ]
#   SPACE OVER TO FORTRAN LISTING AREA
    IF (SHORT)
       DO I = L+1, 39
          CALL PUTCH (BLANK, LISTOUT)
    ELSE [
       CALL PUTCH (NEWLINE, LISTOUT)
       DO I = 1, 55
          CALL PUTCH (BLANK, LISTOUT)
       ]
    CALL PUTCH (BLANK, LISTOUT)
    CALL PUTINT (ICOUNT, 4, LISTOUT)  # FORTRAN LINE COUNT
    CALL PUTCH (BLANK, LISTOUT)
    CALL PUTLIN (IBUFF, LISTOUT)  # FORTRAN LINE
    IF (ENDF (IBUFF)) [
       write (IUNITS(LISTOUT),'(''1'')')
       ICOUNT = 0
       ]
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: KEYPRT
#
#  PURPOSE:
#      OUTPUT A SUPPLIED KEY TO THE CHANNEL SUPPLIED
#
#  BASIC APPROACH:
#      SEE KEYOUT
#
#  MAJOR PROGRAM VARIABLES:
#      ICHAR - WORKING ARRAY FOR INTEGER TO CHARACTER CONVERSION
#
#  INPUT:
#      IOUTUNIT - RATFOR CHANNEL # TO OUTPUT TO
#      KEY - EDIT KEY TO BE FORMATTED
#
#  ROUTINES CALLED:
#      ITOC - INTEGER TO CHARACTER CONVERSION
#      PUTCH - OUTPUT 1 CHARACTER TO CHANNEL SPECIFIED
#      PUTINT - OUTPUT AN INTEGER TO CHANNEL SPECIFIED
#      PUTLIN - OUTPUT A STRING TO THE CHANNEL SPECIFIED
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE KEYPRT (KEY, IOUTUNIT)
    DIMENSION ICHAR(10)
 
    IF (KEY <= 0)  # NOT A KEYED FILE
       DO I = 1, 9
          CALL PUTCH (BLANK, IOUTUNIT)
    ELSE [
       I = KEY/1000
       CALL PUTINT (I, 5, IOUTUNIT)
       CALL PUTCH (PERIOD, IOUTUNIT)
       J = MOD (KEY, 1000) + 1000    # FORCE LEADING ZEROS
       IDUM =  ITOC (J, ICHAR, 10)
       CALL PUTLIN (ICHAR(2), IOUTUNIT) # IGNORE 1 OF THE 1000
       ]
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: EQUL
#
#  PURPOSE:
#      CHECK FOR EQUALITY OF STRINGS
#
#  BASIC APPROACH:
#      FOR LOOP TO COMPARE STRINGS
#
#  INPUT:
#      ISTR1 - FIRST STRING TO COMPARE
#      ISTR2 - SECOND STRING TO COMPARE
#
#  OUTPUT:
#      EQUL - LOGICAL
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    LOGICAL FUNCTION EQUL (ISTR1, ISTR2)
    DIMENSION ISTR1(ARB), ISTR2(ARB)
 
    FOR (I=1; ISTR1(I) == ISTR2(I); I = I + 1)
       CONTINUE
    EQUL = ISTR1(I) == EOS
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: ENDF
#
#  PURPOSE:
#      CHECK FOR FORTRAN END STATEMENT
#
#  BASIC APPROACH:
#      CHECK FOR 'END' FOLLOWED BY A VALID TERMINATOR CHARACTER
#
#  MAJOR PROGRAM VARIABLES:
#      EOS - END-OF-STRING MARKER
#      STREND - 'END' IN SOFTWARE TOOLS CHARACTER STRING FORMAT
#
#  INPUT:
#      IBUFF - FORTRAN SOURCE LINE
#
#  ROUTINES CALLED:
#      EQUL - CHECK FOR EQUALITY OF STRINGS
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    LOGICAL FUNCTION ENDF (IBUFF)
    DIMENSION IBUFF(ARB)
    STRING STREND " END"
    LOGICAL EQUL
 
    IF (EQUL (STREND, IBUFF(6))  &  (IBUFF(10) == BLANK  |
        IBUFF(10) == EOS | IBUFF(10) == NEWLINE))
       ENDF = .TRUE.
    ELSE
       ENDF = .FALSE.
    END
#*******************************************************************************
#*******************************************************************************
#
#  ROUTINE NAME: DECIMAL
#
#  PURPOSE:
#      LIKE ROUTINE PUTDEC, ONLY SENDS THE DECIMAL STRING TO A
#      CHARACTER STRING RATHER THAN TO AN OUTPUT CHANNEL
#
#  BASIC APPROACH:
#      FOLLOW PATTERN OF PUTDEC
#
#  MAJOR PROGRAM VARIABLES:
#      ICHARS - WORKING ARRAY FOR CONVERTED CHARACTER STRING
#      ND - NUMBER OF DIGITS IN CONVERTED STRING
#
#  INPUT:
#      IDEC - DECIMAL NUMBER TO CONVERT TO A CHARACTER STRING
#      IWIDTH - WIDTH OF RESULTING STRING
#
#  OUTPUT:
#      ISTRING - FORMATTED CHARACTER STRING
#
#  ROUTINES CALLED:
#      ITOC - INTEGER TO CHARACTER
#
#  AUTHOR: ROB JANES
#  DATE:   30JUN81
#
#*******************************************************************************
#*******************************************************************************
    SUBROUTINE DECIMAL (IDEC, ISTRING, IWIDTH)
    DIMENSION ISTRING(1), ICHARS(10)
 
    ND = ITOC (IDEC, ICHARS, 10)
    DO I = ND+1, IWIDTH
       ISTRING(I-ND) = BLANK
    DO I = 1, ND
       ISTRING(I+IWIDTH-ND) = ICHARS(I)
    END
#***************************************************
    SUBROUTINE IFEND
    include COMMON_BLOCKS
 
    STRING SIFEND 'ENDIF'
 
    CALL OUTTAB
    CALL OUTSTR (SIFEND)
    CALL OUTDON
    XFER = NO
    END
#***************************************************
    SUBROUTINE IFTHEN
    STRING SIF 'IF '
    STRING STHEN ' THEN'
    CALL OUTTAB
    CALL OUTSTR (SIF)
    CALL BALPAR
    CALL OUTSTR (STHEN)
    CALL OUTDON
    END
#***************************************************
    SUBROUTINE EOUT (N)
    STRING MSG ' ERRORS FOUND'
 
    CALL PUTCH (BLANK, ERROUT)  # CARRIAGE CONTROL
    CALL PUTINT (N, 4, ERROUT)
    CALL PUTLIN (MSG, ERROUT)
    CALL PUTCH (NEWLINE, ERROUT)
    END
#***************************************************
    SUBROUTINE ELSE
    include COMMON_BLOCKS
    xfer = NO
    STRING SELSE "ELSE"
 
    CALL OUTTAB
    CALL OUTSTR (SELSE)
    END
#*******************************************************************************
#*******************************************************************************
#
#   ROUTINE NAME: COLLECTTOKEN
#
#   PURPOSE:
#       To allow DEFINEs and/or their definitions in quoted strings.
#
#   BASIC APPROACH:
#       When an atsign (@) is encountered, this routine begins
#       collecting a legal token. When the token is collected,
#       it is then looked up in the definition table. If the
#       token is found, it is replaced. If not, it just gets
#       pushed into the quoted string as before. If an actual
#       DEFINEd name is needed in the quoted string, a double atsign
#       (@@) should be used.
#
#   MAJOR PROGRAM VARIABLES:
#       CONTINUE - Logical flag that is set when the last character on a line
#           is the continuation character.
#       I - used as a pointer to LEXSTR.
#       IPLACEHOLDER - used to keep the starting position in LEXSTR
#           of the (possibly DEFINEd) token currently being tested.
#       LEXSTR - array used to store the quoted string.
#       REPLACEMENT - array used to store the token definitions.
#
#   ROUTINES CALLED:
#       IS_DIGIT - this is actually a DEFINE which tests for a legal digit.
#       IS_LETTER - this is actually a DEFINE which tests for a legal
#           character.
#       LUDEF - this function looks up a (possibly DEFINEd) constant in the
#           definition table. If the token is defined, YES is returned. If
#           not, NO is returned.
#       NGETCH - this function gets the next character in the quoted string.
#       PUTBAK - this routine puts the current character back on the input.
#
#   AUTHOR:  LES STEWART
#   DATE:    17JUN86
#
#*******************************************************************************
#*******************************************************************************
      SUBROUTINE COLLECTTOKEN (LEXSTR, I)
      IMPLICIT INTEGER (A-Z)
      DIMENSION LEXSTR(*)
      INCLUDE COMMON_BLOCKS
      DIMENSION REPLACEMENT(100)
      LOGICAL CONTINUE
 
      IPLACEHOLDER = I
      I = I + 1
      CH = NGETCH(LEXSTR(I))
 
      IF (LEXSTR(I) == ATSIGN) [
         I = I + 1
         CH = NGETCH(LEXSTR(I))
      ]
 
      WHILE (IS_LETTER (CH)  |  IS_DIGIT (CH)  |  CH == PERIOD  |
             CH == UNDERLINE) [
         I = I + 1
         CH = NGETCH(LEXSTR(I))
      ]
 
      CONTINUE = .FALSE.
      IF (LEXSTR(I) == NEWLINE) [
         IF (LEXSTR(I-1) == UNDERLINE) [
            CONTINUE = .TRUE.
            CALL PUTBAK (LEXSTR(I))
            I = I - 1
         ]
         ELSE
            CALL PUTBAK (LEXSTR(I))
      ]
      ELSE
         CALL PUTBAK (LEXSTR(I))
      LEXSTR(I) = EOS
 
      IF (LEXSTR(IPLACEHOLDER + 1) == ATSIGN) [
         IF (LUDEF (LEXSTR(IPLACEHOLDER + 1), REPLACEMENT, DEFTBL)
            == YES) [
            FOR (J = IPLACEHOLDER + 1;LEXSTR(J) != EOS;J = J + 1)
               LEXSTR(J - 1) = LEXSTR(J)
            I = J - 1
         ]
         IF (CONTINUE)
            LEXSTR(I) = UNDERLINE
      ]
 
      ELSE [
         IF (LUDEF (LEXSTR(IPLACEHOLDER), REPLACEMENT, DEFTBL) ==
            YES) [
            FOR (J = 1; REPLACEMENT(J) != EOS; J = J + 1) [
               LEXSTR(IPLACEHOLDER) = REPLACEMENT(J)
               IPLACEHOLDER = IPLACEHOLDER + 1
            ]
            IF (CONTINUE)
               LEXSTR(IPLACEHOLDER) = UNDERLINE
            I = IPLACEHOLDER
         ]
         ELSE
            IF (CONTINUE)
               LEXSTR(I) = UNDERLINE
      ]
 
      IF (!CONTINUE) [
         CH = NGETCH(LEXSTR(I))
         IF ((LEXSTR(I) == LEXSTR(1)) | (LEXSTR(I) == ATSIGN)) [
            CALL PUTBAK (LEXSTR(I))
            I = I - 1
         ]
      ]
      END
