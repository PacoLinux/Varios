VERSION E05

PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:1    
        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMR */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine reads command input and returns the output
       26       26                blocks generated by X$PARSE from the command read.  As
       27       27                command input is read it is echoed if either the input or
       28       28                output DCB is not assigned to an 'IC' type device.  The
       29       29                default input DCB is M$SI and the default output DCB is M$ME.
       30       30                These defaults may be changed with a call to XUR$SETDCBS.
       31       31                   Commands may be continued by ending a command line with a
       32       32                semicolon.  If commands are being read from other than an 'IC'
       33       33                device and the command input begins with the prompt string
       34       34                then the prompt string will be deleted from the input before
       35       35                it is passed to the parser.
       36       36                   There is a flag, SYNTAX which
       37       37                if set (by default) enables special syntax error processing.
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:2    
       38       38                If the flag is set when a syntax error occurs one of two
       39       39                things may happen.  If the character that caused the syntax
       40       40                to fail was a '?' then a list of possible syntax alternatives
       41       41                at the point of the syntax error will be printed through M$DO.
       42       42                Otherwise if the next input consists of the single character
       43       43                '?' then a list of syntax alternatives at the point of the
       44       44                previous syntax error is printed through M$DO.  If the flag
       45       45                is set then syntax errors will return the error code
       46       46                XUR-E$SYNERR-0 instead of XUP-E$SYNERR-0.
       47       47
       48       48                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       49       49                      the routines documented here.
       50       50                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       51       51                      which allows one to specify SYNTAX, as well as EPTR's for
       52       52                      routines for command abort (ABORT), command continue (CONTINUE),
       53       53                      special break message (BRKMSG), and/or a vector (WORK_) framing
       54       54                      a block of memory (even # of doublewords >= 500 words in size)
       55       55                      which XUR$GETCMD is to use for its parse control block, input
       56       56                      command buffer, and X$PARSE work area.  If break control is to be
       57       57                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       58       58                                                                           */
       59       59        /*D*    NAME: XUR$SETDCBS
       60       60                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB);
       61       61                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       62       62                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       63       63                DESCRIPTION:
       64       64                   This routine changes the input and output DCBs.  Either
       65       65                argument may be omitted if that DCB is not to be changed.
       66       66                                                                           */
       67       67        /*D*    NAME: XUR$INIT
       68       68                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       69       69                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       70       70                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       71       71                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       72       72                DESCRIPTION:
       73       73                    This routine may be called to initialize various aspects of XUR$GETCMD.
       74       74                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:3    
       75       75                flag may be set or reset;  the WORK_ vector may be used to require
       76       76                XUR$GETCMD to use a specific block of memory rather than acquiring a
       77       77                data segment for its own use; and the PCB$ pointer may be set to
       78       78                indicate that XUR$GETCMD is to use a user-provided parse control block
       79       79                in its calls to X$PARSE rather than constructing a PCB of its own in
       80       80                the work area.
       81       81                P_PCB$, if present, will receive the address of the PCB actually used
       82       82                (whether user-provided or built in the work area by XUR$INIT).
       83       83                PARAM$ will receive the PTR to the PARAM block (optional).
       84       84                An ABORT routine must be supplied if XUR$BREAK is used.
       85       85                XUR$INIT may be called more than once, if desired;  the settings of
       86       86                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       87       87                updated on each call;  the PCB$ pointer will be honored on each call
       88       88                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       89       89                set to the actual PCB address used.  The WORK_ vector will be honored
       90       90                only on the first call to XUR$INIT and only of XUR$INIT is called before
       91       91                the first call to XUR$GETCMD.  Other information (current error message,
       92       92                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
       93       93                but the other information (ERRMSG,etc.) will be remembered.
       94       94                                                                           */
       95       95        /*D*    NAME: XUR$ERRPTR
       96       96                CALL: XUR$ERRPTR(CPOS,OUTDCB);
       97       97                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
       98       98                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
       99       99                                OUT$BLK.CPOS.
      100      100                         OUTDCB - DCB TO OUTPUT THROUGH.
      101      101                DESCRIPTION:
      102      102                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      103      103                if CPOS is within the last line of the command a '^' is
      104      104                printed under the character at CPOS.  Otherwise fifteen characters
      105      105                on either side of CPOS are printed through OUTDCB and a '^' is
      106      106                printed under the offending character.  The CPOS argument
      107      107                may be omitted in which case P_PCB.HI_CHAR is used.
      108      108                                                                           */
      109      109        /*D*    NAME: XUR$ECHO
      110      110                CALL: CALL XUR$ECHO(OUTDCB);
      111      111                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:4    
      112      112                DESCRIPTION:
      113      113                   Writes the last command through OUTDCB.
      114      114                                                                           */
      115      115        /*D*    NAME: XUR$ECHOIF
      116      116                CALL: CALL XUR$ECHOIF(OUTDCB);
      117      117                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      118      118                DESCRIPTION:
      119      119                   If the last command has not already been written to
      120      120                the place to which OUTDCB is assigned the last command is
      121      121                written through OUTDCB.
      122      122                                                                           */
      123      123        /*D*    NAME: XUR$ECHOLAST
      124      124                CALL: CALL XUR$ECHOLAST(OUTDCB);
      125      125                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      126      126                DESCRIPTION:
      127      127                   Echos the last input line through OUTDCB.
      128      128                                                                           */
      129      129        /*D*    NAME: XUR$CORRES
      130      130                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      131      131                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      132      132                DESCRIPTION:
      133      133                   A default open is done on the DCBs if they are not open
      134      134                and the ALTRETURN is taken if the assignments of the DCBs
      135      135                correspond.
      136      136                                                                           */
      137      137        /*D*    NAME: XUR$BREAK
      138      138                CALL: ASYNC ENTRY ON BREAK
      139      139                DESCRIPTION:
      140      140                   XUR$BREAK is a generalized break handler for programs that
      141      141                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
      142      142                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      143      143                the message "Break!  C to continue" is output.  (Breaks are
      144      144                ignored from the time XUR$BREAK is entered until it exits.)
      145      145                Then input is read through M$UC.  A null input will cause the
      146      146                current command to be aborted.  The single character 'C' or 'c'
      147      147                will cause the current command to be continued.  Any other
      148      148                input will be parsed as a new command on the next call to
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:5    
      149      149                XUR$GETCMD.
      150      150
      151      151                If it is desireable to exit from the BREAK process without printing
      152      152                the "Break!  C to continue" message and inputing a response, the user
      153      153                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      154      154                a call to X66_TRTN;  this call will release the auto frame(s) for
      155      155                XUR$BREAK and the BRKMSG routine, and will then return control to the
      156      156                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      157      157                desirable to continue at the point of interruption with breaks enabled,
      158      158                XUR$CLRENABLE should be called before X66_TRTN.
      159      159
      160      160                XUR$BREAK is to be establised as the break routine by the user
      161      161                with an M$INT call.  The routine pointed to by XUR_ABORT is
      162      162                called to abort the current command after doing an M$CLRSTK.
      163      163                This routine must be present and should not return.  An optional
      164      164                routine pointed to by XUR_CONTINUE is called to continue
      165      165                commands.  If this routine returns or is not present an M$TRTN
      166      166                will be executed.
      167      167
      168      168                Breaks are ignored if input while reading a command.
      169      169                                                                           */
      170      170        /*D*    NAME: XUR$DISABLE
      171      171                CALL: CALL XUR$DISABLE
      172      172                DESCRIPTION:
      173      173                   Disables breaks for critical code.  Calls to XUR$DISABLE
      174      174                may be nested.
      175      175                                                                           */
      176      176        /*D*    NAME: XUR$ENABLE
      177      177                CALL: CALL XUR$ENABLE
      178      178                DESCRIPTION:
      179      179                   Counterpart to XUR$DISABLE.  If a break occured during
      180      180                disabled execution,  it will be processed at enable time.
      181      181                                                                           */
      182      182        /*D*    NAME: XUR$CLRENABLE
      183      183                CALL: CALL XUR$CLRENABLE
      184      184                DESCRIPTION:
      185      185                   Just like XUR$ENABLE except any breaks that occured while
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:6    
      186      186                disabled will be ignored.
      187      187                                                                           */
      188      188        /*D*    NAME: XUR$ERRMSG
      189      189                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      190      190                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      191      191                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      192      192                                CODE IS INCREMENTED.  IN THIS CASE THE
      193      193                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      194      194                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      195      195                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      196      196                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      197      197                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      198      198                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      199      199                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      200      200                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      201      201                         FLGLEV - Number of asterisks to print in front of the
      202      202                                  message (0-4).  Default is 0.
      203      203                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      204      204                DESCRIPTION:
      205      205                   A call is made to M$ERRMSG using the parameters passed by
      206      206                the caller.
      207      207                                                                           */
      208      208        /*D*    NAME: XUR$SETERRMSG
      209      209                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      210      210                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      211      211                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      212      212                DESCRIPTION:
      213      213                   If the FID argument is passed then M$FID is called to
      214      214                obtain the name, account and password of the error message
      215      215                file to be used on subsequent calls to XUR$ERRMSG.  If the
      216      216                FID argument is omitted then the M$ERRMSG default file will
      217      217                be used.  If the altreturn is taken then M$FID altreted and
      218      218                the error code may be found in the altret frame.
      219      219                                                                           */
      220      220        /*D*    NAME: XUR$HELP
      221      221                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
      222      222                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:7    
      223      223                DESCRIPTION:
      224      224                   This routine calls X$HELP.  The purpose of XUR$HELP is
      225      225                to keep track of whether the last message operation was
      226      226                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      227      227                will call XUR$ERRMSG with the error code in XUH_PARAM and
      228      228                then altreturn.  Otherwise the normal return will be taken.
      229      229                                                                           */
      230      230        /*D*    NAME: XUR$MOREMSG
      231      231                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      232      232                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      233      233                DESCRIPTION:
      234      234                   XUR$ERRMSG or X$HELP is called to get the next level of
      235      235                messages.  Trust me.  The altreturn is taken if no messages
      236      236                are available.
      237      237                                                                           */
      238      238        /*D*    NAME: XUR$ALLMSG
      239      239                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      240      240                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      241      241                DESCRIPTION:
      242      242                   XUR$ERRMSG or X$HELP is called to get all remaining
      243      243                messages.  Trust me.  The altreturn is taken if no messages
      244      244                are available.
      245      245                                                                           */
      246      246        /*D*    NAME: XUR$FINDDCB
      247      247                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      248      248                INPUT:   DCBNAME - TEXTC DCB NAME
      249      249                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      250      250                DESCRIPTION:
      251      251                   Searches DCB table for DCB specified by DCBNAME.  If it
      252      252                is found, DCB number is returned in DCB#.  If not present
      253      253                the altreturn will be taken.
      254      254                                                                           */
      255      255        /*D*    NAME: XUR$GETDCB
      256      256                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      257      257                INPUT:   DCBNAME - TEXTC DCB NAME
      258      258                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      259      259                DESCRIPTION:
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:8    
      260      260                   Searches DCB table for DCB specified by DCBNAME.  If it
      261      261                is found, DCB number is returned in DCB#.  If not present
      262      262                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      263      263                then XUR$GETDCB will altreturn and the error code may be
      264      264                found in the altret frame.
      265      265                                                                           */
      266      266        /*D*    NAME: XUR$CLOSE_DCBS;
      267      267                CALL: CALL XUR$CLOSE_DCBS;
      268      268                DESCRIPTION:
      269      269                   Closes all open dcbs with SAVE.
      270      270                                                                           */
      271      271        /*D*     NAME: XUR$ERRCNVRT
      272      272                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      273      273                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      274      274                       passed through the coupler.
      275      275                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      276      276                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      277      277                             stored in 36 bits with the high-order bit in each byte
      278      278                             being zero) into the equivalent CP-6 standard error code
      279      279                             format (36 bits).
      280      280        */
      281      281
      282      282        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:9    
      283      283        CXG$INIT: PROC (GETCMD, XUG_INIT) ALTRET;
      284      284        /**/
      285      285        %INCLUDE XU_MACRO_C ;
      286     3391
      287     3392        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      288     3730        %XUG_INIT (NAME=XUG_INIT, STCLASS=PARAM) ;
      289     4143        /**/
      290     4144    1   DCL XUG$INIT_COMMON ENTRY(2) ALTRET ;
      291     4145    1   DCL XUG$GETCMD_COMMON ENTRY(1) ALTRET ;
      292     4146    1   DCL XUG$ERRPTR_COMMON ENTRY(1) ALTRET ;
      293     4147    1   DCL XUG$ECHOIF_COMMON ENTRY(1) ALTRET ;
      294     4148    1   DCL XUG$ECHO_COMMON ENTRY(1) ALTRET ;
      295     4149
      296     4150    1           CALL XUG$INIT_COMMON(GETCMD, XUG_INIT) ALTRET(MALT) ;
      297     4151    1           RETURN;
      298     4152        %EJECT ;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:10   
      299     4153    1   CXG$GETCMD: ENTRY(GETCMD) ALTRET;
      300     4154    1   GETCMD:
      301     4155    1           CALL XUG$GETCMD_COMMON (GETCMD) ALTRET(MALT) ;
      302     4156    1           RETURN;
      303     4157        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:11   
      304     4158    1   CXG$ERRPTR: ENTRY(GETCMD) ALTRET;
      305     4159        /**/
      306     4160    1           CALL XUG$ERRPTR_COMMON (GETCMD) ALTRET(MALT) ;
      307     4161    1           RETURN;
      308     4162        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:12   
      309     4163    1   CXG$ECHOIF: ENTRY(GETCMD) ALTRET;
      310     4164    1           CALL XUG$ECHOIF_COMMON(GETCMD) ALTRET(MALT) ;
      311     4165    1           RETURN ;
      312     4166    1   CXG$ECHO: ENTRY(GETCMD) ALTRET;
      313     4167    1           CALL XUG$ECHO_COMMON(GETCMD) ALTRET(MALT) ;
      314     4168    1           RETURN;
      315     4169    1   MALT:   ALTRETURN ;
      316     4170        /**/
      317     4171    1   END CXG$INIT;
      318     4172        %EOD;

PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:13   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$INIT.

   Procedure CXG$INIT requires 36 words for executable code.
   Procedure CXG$INIT requires 6 words of local(AUTO) storage.

PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:14   

 Object Unit name= CXG$INIT                                   File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:15.68 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    36     44  CXG$INIT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  CXG$INIT
     0      7          yes     yes      Std        1  CXG$GETCMD
     0     16          yes     yes      Std        1  CXG$ERRPTR
     0     25          yes     yes      Std        1  CXG$ECHOIF
     0     34          yes     yes      Std        1  CXG$ECHO

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$INIT_COMMON
 yes     yes           Std       1 XUG$GETCMD_COMMON
 yes     yes           Std       1 XUG$ERRPTR_COMMON
 yes     yes           Std       1 XUG$ECHOIF_COMMON
 yes     yes           Std       1 XUG$ECHO_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:15   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:16   


        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMR */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine reads command input and returns the output
       26       26                blocks generated by X$PARSE from the command read.  As
       27       27                command input is read it is echoed if either the input or
       28       28                output DCB is not assigned to an 'IC' type device.  The
       29       29                default input DCB is M$SI and the default output DCB is M$ME.
       30       30                These defaults may be changed with a call to XUR$SETDCBS.
       31       31                   Commands may be continued by ending a command line with a
       32       32                semicolon.  If commands are being read from other than an 'IC'
       33       33                device and the command input begins with the prompt string
       34       34                then the prompt string will be deleted from the input before
       35       35                it is passed to the parser.
       36       36                   There is a flag, SYNTAX which
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:17   
       37       37                if set (by default) enables special syntax error processing.
       38       38                If the flag is set when a syntax error occurs one of two
       39       39                things may happen.  If the character that caused the syntax
       40       40                to fail was a '?' then a list of possible syntax alternatives
       41       41                at the point of the syntax error will be printed through M$DO.
       42       42                Otherwise if the next input consists of the single character
       43       43                '?' then a list of syntax alternatives at the point of the
       44       44                previous syntax error is printed through M$DO.  If the flag
       45       45                is set then syntax errors will return the error code
       46       46                XUR-E$SYNERR-0 instead of XUP-E$SYNERR-0.
       47       47
       48       48                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       49       49                      the routines documented here.
       50       50                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       51       51                      which allows one to specify SYNTAX, as well as EPTR's for
       52       52                      routines for command abort (ABORT), command continue (CONTINUE),
       53       53                      special break message (BRKMSG), and/or a vector (WORK_) framing
       54       54                      a block of memory (even # of doublewords >= 500 words in size)
       55       55                      which XUR$GETCMD is to use for its parse control block, input
       56       56                      command buffer, and X$PARSE work area.  If break control is to be
       57       57                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       58       58                                                                           */
       59       59        /*D*    NAME: XUR$SETDCBS
       60       60                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB);
       61       61                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       62       62                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       63       63                DESCRIPTION:
       64       64                   This routine changes the input and output DCBs.  Either
       65       65                argument may be omitted if that DCB is not to be changed.
       66       66                                                                           */
       67       67        /*D*    NAME: XUR$INIT
       68       68                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       69       69                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       70       70                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       71       71                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       72       72                DESCRIPTION:
       73       73                    This routine may be called to initialize various aspects of XUR$GETCMD.
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:18   
       74       74                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
       75       75                flag may be set or reset;  the WORK_ vector may be used to require
       76       76                XUR$GETCMD to use a specific block of memory rather than acquiring a
       77       77                data segment for its own use; and the PCB$ pointer may be set to
       78       78                indicate that XUR$GETCMD is to use a user-provided parse control block
       79       79                in its calls to X$PARSE rather than constructing a PCB of its own in
       80       80                the work area.
       81       81                P_PCB$, if present, will receive the address of the PCB actually used
       82       82                (whether user-provided or built in the work area by XUR$INIT).
       83       83                PARAM$ will receive the PTR to the PARAM block (optional).
       84       84                An ABORT routine must be supplied if XUR$BREAK is used.
       85       85                XUR$INIT may be called more than once, if desired;  the settings of
       86       86                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       87       87                updated on each call;  the PCB$ pointer will be honored on each call
       88       88                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       89       89                set to the actual PCB address used.  The WORK_ vector will be honored
       90       90                only on the first call to XUR$INIT and only of XUR$INIT is called before
       91       91                the first call to XUR$GETCMD.  Other information (current error message,
       92       92                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
       93       93                but the other information (ERRMSG,etc.) will be remembered.
       94       94                                                                           */
       95       95        /*D*    NAME: XUR$ERRPTR
       96       96                CALL: XUR$ERRPTR(CPOS,OUTDCB);
       97       97                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
       98       98                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
       99       99                                OUT$BLK.CPOS.
      100      100                         OUTDCB - DCB TO OUTPUT THROUGH.
      101      101                DESCRIPTION:
      102      102                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      103      103                if CPOS is within the last line of the command a '^' is
      104      104                printed under the character at CPOS.  Otherwise fifteen characters
      105      105                on either side of CPOS are printed through OUTDCB and a '^' is
      106      106                printed under the offending character.  The CPOS argument
      107      107                may be omitted in which case P_PCB.HI_CHAR is used.
      108      108                                                                           */
      109      109        /*D*    NAME: XUR$ECHO
      110      110                CALL: CALL XUR$ECHO(OUTDCB);
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:19   
      111      111                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
      112      112                DESCRIPTION:
      113      113                   Writes the last command through OUTDCB.
      114      114                                                                           */
      115      115        /*D*    NAME: XUR$ECHOIF
      116      116                CALL: CALL XUR$ECHOIF(OUTDCB);
      117      117                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      118      118                DESCRIPTION:
      119      119                   If the last command has not already been written to
      120      120                the place to which OUTDCB is assigned the last command is
      121      121                written through OUTDCB.
      122      122                                                                           */
      123      123        /*D*    NAME: XUR$ECHOLAST
      124      124                CALL: CALL XUR$ECHOLAST(OUTDCB);
      125      125                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      126      126                DESCRIPTION:
      127      127                   Echos the last input line through OUTDCB.
      128      128                                                                           */
      129      129        /*D*    NAME: XUR$CORRES
      130      130                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      131      131                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      132      132                DESCRIPTION:
      133      133                   A default open is done on the DCBs if they are not open
      134      134                and the ALTRETURN is taken if the assignments of the DCBs
      135      135                correspond.
      136      136                                                                           */
      137      137        /*D*    NAME: XUR$BREAK
      138      138                CALL: ASYNC ENTRY ON BREAK
      139      139                DESCRIPTION:
      140      140                   XUR$BREAK is a generalized break handler for programs that
      141      141                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
      142      142                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      143      143                the message "Break!  C to continue" is output.  (Breaks are
      144      144                ignored from the time XUR$BREAK is entered until it exits.)
      145      145                Then input is read through M$UC.  A null input will cause the
      146      146                current command to be aborted.  The single character 'C' or 'c'
      147      147                will cause the current command to be continued.  Any other
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:20   
      148      148                input will be parsed as a new command on the next call to
      149      149                XUR$GETCMD.
      150      150
      151      151                If it is desireable to exit from the BREAK process without printing
      152      152                the "Break!  C to continue" message and inputing a response, the user
      153      153                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      154      154                a call to X66_TRTN;  this call will release the auto frame(s) for
      155      155                XUR$BREAK and the BRKMSG routine, and will then return control to the
      156      156                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      157      157                desirable to continue at the point of interruption with breaks enabled,
      158      158                XUR$CLRENABLE should be called before X66_TRTN.
      159      159
      160      160                XUR$BREAK is to be establised as the break routine by the user
      161      161                with an M$INT call.  The routine pointed to by XUR_ABORT is
      162      162                called to abort the current command after doing an M$CLRSTK.
      163      163                This routine must be present and should not return.  An optional
      164      164                routine pointed to by XUR_CONTINUE is called to continue
      165      165                commands.  If this routine returns or is not present an M$TRTN
      166      166                will be executed.
      167      167
      168      168                Breaks are ignored if input while reading a command.
      169      169                                                                           */
      170      170        /*D*    NAME: XUR$DISABLE
      171      171                CALL: CALL XUR$DISABLE
      172      172                DESCRIPTION:
      173      173                   Disables breaks for critical code.  Calls to XUR$DISABLE
      174      174                may be nested.
      175      175                                                                           */
      176      176        /*D*    NAME: XUR$ENABLE
      177      177                CALL: CALL XUR$ENABLE
      178      178                DESCRIPTION:
      179      179                   Counterpart to XUR$DISABLE.  If a break occured during
      180      180                disabled execution,  it will be processed at enable time.
      181      181                                                                           */
      182      182        /*D*    NAME: XUR$CLRENABLE
      183      183                CALL: CALL XUR$CLRENABLE
      184      184                DESCRIPTION:
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:21   
      185      185                   Just like XUR$ENABLE except any breaks that occured while
      186      186                disabled will be ignored.
      187      187                                                                           */
      188      188        /*D*    NAME: XUR$ERRMSG
      189      189                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      190      190                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      191      191                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      192      192                                CODE IS INCREMENTED.  IN THIS CASE THE
      193      193                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      194      194                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      195      195                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      196      196                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      197      197                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      198      198                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      199      199                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      200      200                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      201      201                         FLGLEV - Number of asterisks to print in front of the
      202      202                                  message (0-4).  Default is 0.
      203      203                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      204      204                DESCRIPTION:
      205      205                   A call is made to M$ERRMSG using the parameters passed by
      206      206                the caller.
      207      207                                                                           */
      208      208        /*D*    NAME: XUR$SETERRMSG
      209      209                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      210      210                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      211      211                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      212      212                DESCRIPTION:
      213      213                   If the FID argument is passed then M$FID is called to
      214      214                obtain the name, account and password of the error message
      215      215                file to be used on subsequent calls to XUR$ERRMSG.  If the
      216      216                FID argument is omitted then the M$ERRMSG default file will
      217      217                be used.  If the altreturn is taken then M$FID altreted and
      218      218                the error code may be found in the altret frame.
      219      219                                                                           */
      220      220        /*D*    NAME: XUR$HELP
      221      221                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:22   
      222      222                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      223      223                DESCRIPTION:
      224      224                   This routine calls X$HELP.  The purpose of XUR$HELP is
      225      225                to keep track of whether the last message operation was
      226      226                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      227      227                will call XUR$ERRMSG with the error code in XUH_PARAM and
      228      228                then altreturn.  Otherwise the normal return will be taken.
      229      229                                                                           */
      230      230        /*D*    NAME: XUR$MOREMSG
      231      231                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      232      232                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      233      233                DESCRIPTION:
      234      234                   XUR$ERRMSG or X$HELP is called to get the next level of
      235      235                messages.  Trust me.  The altreturn is taken if no messages
      236      236                are available.
      237      237                                                                           */
      238      238        /*D*    NAME: XUR$ALLMSG
      239      239                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      240      240                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      241      241                DESCRIPTION:
      242      242                   XUR$ERRMSG or X$HELP is called to get all remaining
      243      243                messages.  Trust me.  The altreturn is taken if no messages
      244      244                are available.
      245      245                                                                           */
      246      246        /*D*    NAME: XUR$FINDDCB
      247      247                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      248      248                INPUT:   DCBNAME - TEXTC DCB NAME
      249      249                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      250      250                DESCRIPTION:
      251      251                   Searches DCB table for DCB specified by DCBNAME.  If it
      252      252                is found, DCB number is returned in DCB#.  If not present
      253      253                the altreturn will be taken.
      254      254                                                                           */
      255      255        /*D*    NAME: XUR$GETDCB
      256      256                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      257      257                INPUT:   DCBNAME - TEXTC DCB NAME
      258      258                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:23   
      259      259                DESCRIPTION:
      260      260                   Searches DCB table for DCB specified by DCBNAME.  If it
      261      261                is found, DCB number is returned in DCB#.  If not present
      262      262                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      263      263                then XUR$GETDCB will altreturn and the error code may be
      264      264                found in the altret frame.
      265      265                                                                           */
      266      266        /*D*    NAME: XUR$CLOSE_DCBS;
      267      267                CALL: CALL XUR$CLOSE_DCBS;
      268      268                DESCRIPTION:
      269      269                   Closes all open dcbs with SAVE.
      270      270                                                                           */
      271      271        /*D*     NAME: XUR$ERRCNVRT
      272      272                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      273      273                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      274      274                       passed through the coupler.
      275      275                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      276      276                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      277      277                             stored in 36 bits with the high-order bit in each byte
      278      278                             being zero) into the equivalent CP-6 standard error code
      279      279                             format (36 bits).
      280      280        */
      281      281
      282      282        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:24   
      283      283        CXG$INIT: PROC (GETCMD, XUG_INIT) ALTRET;

    283  0 000000   000000 700200 xent  CXG$INIT     TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      284      284        /**/
      285      285        %INCLUDE XU_MACRO_C ;
      286     3391
      287     3392        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      288     3730        %XUG_INIT (NAME=XUG_INIT, STCLASS=PARAM) ;
      289     4143        /**/
      290     4144    1   DCL XUG$INIT_COMMON ENTRY(2) ALTRET ;
      291     4145    1   DCL XUG$GETCMD_COMMON ENTRY(1) ALTRET ;
      292     4146    1   DCL XUG$ERRPTR_COMMON ENTRY(1) ALTRET ;
      293     4147    1   DCL XUG$ECHOIF_COMMON ENTRY(1) ALTRET ;
      294     4148    1   DCL XUG$ECHO_COMMON ENTRY(1) ALTRET ;
      295     4149
      296     4150    1           CALL XUG$INIT_COMMON(GETCMD, XUG_INIT) ALTRET(MALT) ;

   4150  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$INIT_COMMON
         0 000005   000043 702000 0                  TSX2    MALT

      297     4151    1           RETURN;

   4151  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      298     4152        %EJECT ;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:25   
      299     4153    1   CXG$GETCMD: ENTRY(GETCMD) ALTRET;

   4153  0 000007   000000 700200 xent  CXG$GETCMD   TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      300     4154    1   GETCMD:
      301     4155    1           CALL XUG$GETCMD_COMMON (GETCMD) ALTRET(MALT) ;

   4155  0 000011   200003 630500       GETCMD       EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$GETCMD_COMMON
         0 000014   000043 702000 0                  TSX2    MALT

      302     4156    1           RETURN;

   4156  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      303     4157        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:26   
      304     4158    1   CXG$ERRPTR: ENTRY(GETCMD) ALTRET;

   4158  0 000016   000000 700200 xent  CXG$ERRPTR   TSX0  ! X66_AUTO_2
         0 000017   000006 000002                    ZERO    6,2

      305     4159        /**/
      306     4160    1           CALL XUG$ERRPTR_COMMON (GETCMD) ALTRET(MALT) ;

   4160  0 000020   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ERRPTR_COMMON
         0 000023   000043 702000 0                  TSX2    MALT

      307     4161    1           RETURN;

   4161  0 000024   000000 702200 xent               TSX2  ! X66_ARET

      308     4162        %EJECT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:27   
      309     4163    1   CXG$ECHOIF: ENTRY(GETCMD) ALTRET;

   4163  0 000025   000000 700200 xent  CXG$ECHOIF   TSX0  ! X66_AUTO_2
         0 000026   000006 000002                    ZERO    6,2

      310     4164    1           CALL XUG$ECHOIF_COMMON(GETCMD) ALTRET(MALT) ;

   4164  0 000027   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000030   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000031   000000 701000 xent               TSX1    XUG$ECHOIF_COMMON
         0 000032   000043 702000 0                  TSX2    MALT

      311     4165    1           RETURN ;

   4165  0 000033   000000 702200 xent               TSX2  ! X66_ARET

      312     4166    1   CXG$ECHO: ENTRY(GETCMD) ALTRET;

   4166  0 000034   000000 700200 xent  CXG$ECHO     TSX0  ! X66_AUTO_2
         0 000035   000006 000002                    ZERO    6,2

      313     4167    1           CALL XUG$ECHO_COMMON(GETCMD) ALTRET(MALT) ;

   4167  0 000036   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000037   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000040   000000 701000 xent               TSX1    XUG$ECHO_COMMON
         0 000041   000043 702000 0                  TSX2    MALT

      314     4168    1           RETURN;

   4168  0 000042   000000 702200 xent               TSX2  ! X66_ARET

      315     4169    1   MALT:   ALTRETURN ;

   4169  0 000043   000000 702200 xent  MALT         TSX2  ! X66_AALT
      316     4170        /**/
      317     4171    1   END CXG$INIT;
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:28   
      318     4172        %EOD;

PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:29   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$INIT.
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:30   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                    4-0-0/w PTR         r     1 @XUG_INIT
    *0-0-0/d STRC(1512)  r     1 GETCMD                    *0-0-0/d STRC(1296)  r     1 XUG_INIT


   Procedure CXG$INIT requires 36 words for executable code.
   Procedure CXG$INIT requires 6 words of local(AUTO) storage.
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:31   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=CXG$INIT File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:32   
          MINI XREF LISTING

GETCMD
      4155**LABEL     283--PROC     4150<>CALL     4153--ENTRY    4155<>CALL     4158--ENTRY    4160<>CALL
      4163--ENTRY    4164<>CALL     4166--ENTRY    4167<>CALL
GETCMD.OUT$
      3410**DCL      3416--REDEF
MALT
      4169**LABEL    4150--CALLALT  4155--CALLALT  4160--CALLALT  4164--CALLALT  4167--CALLALT
XUG$ECHOIF_COMMON
      4147**DCL-ENT  4164--CALL
XUG$ECHO_COMMON
      4148**DCL-ENT  4167--CALL
XUG$ERRPTR_COMMON
      4146**DCL-ENT  4160--CALL
XUG$GETCMD_COMMON
      4145**DCL-ENT  4155--CALL
XUG$INIT_COMMON
      4144**DCL-ENT  4150--CALL
XUG_INIT
      3752**DCL       283--PROC     4150<>CALL

PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:33   
      319        1        /*T***********************************************************/
      320        2        /*T*                                                         */
      321        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      322        4        /*T*                                                         */
      323        5        /*T***********************************************************/
      324        6        /* ROUTINE TO DO CORRESPONDENCES, ECHO, ETC. */
      325        7        CXG$CORRES: PROC(DCB1,DCB2) ALTRET;
      326        8        /**/
      327        9    1   DCL DCB1 SBIN WORD ;
      328       10    1   DCL DCB2 SBIN WORD ;
      329       11        /**/
      330       12    1   DCL XUG$CORRES_COMMON ENTRY(2) ALTRET ;
      331       13    1   DCL XUG$ECHOLAST_COMMON ENTRY(1) ALTRET ;
      332       14
      333       15    1           CALL XUG$CORRES_COMMON(DCB1, DCB2) ALTRET(CORRES) ;
      334       16    1           RETURN;
      335       17        %EJECT;
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:34   
      336       18    1   CXG$ECHOLAST: ENTRY(DCB1) ALTRET;
      337       19    1           CALL XUG$ECHOLAST_COMMON(DCB1) ALTRET(CORRES) ;
      338       20    1           RETURN;
      339       21
      340       22    1   CORRES: ALTRETURN;
      341       23    1   END CXG$CORRES;
      342       24        %EOD;

PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:35   
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$CORRES.

   Procedure CXG$CORRES requires 15 words for executable code.
   Procedure CXG$CORRES requires 6 words of local(AUTO) storage.

PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:36   

 Object Unit name= CXG$CORRES                                 File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:31.56 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  CXG$CORRES

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  CXG$CORRES
     0      7          yes     yes      Std        1  CXG$ECHOLAST

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$CORRES_COMMON
 yes     yes           Std       1 XUG$ECHOLAST_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:37   


      319        1        /*T***********************************************************/
      320        2        /*T*                                                         */
      321        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      322        4        /*T*                                                         */
      323        5        /*T***********************************************************/
      324        6        /* ROUTINE TO DO CORRESPONDENCES, ECHO, ETC. */
      325        7        CXG$CORRES: PROC(DCB1,DCB2) ALTRET;

      7  0 000000   000000 700200 xent  CXG$CORRES   TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      326        8        /**/
      327        9    1   DCL DCB1 SBIN WORD ;
      328       10    1   DCL DCB2 SBIN WORD ;
      329       11        /**/
      330       12    1   DCL XUG$CORRES_COMMON ENTRY(2) ALTRET ;
      331       13    1   DCL XUG$ECHOLAST_COMMON ENTRY(1) ALTRET ;
      332       14
      333       15    1           CALL XUG$CORRES_COMMON(DCB1, DCB2) ALTRET(CORRES) ;

     15  0 000002   200003 630500                    EPPR0   @DCB1,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$CORRES_COMMON
         0 000005   000016 702000 0                  TSX2    CORRES

      334       16    1           RETURN;

     16  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      335       17        %EJECT;
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:38   
      336       18    1   CXG$ECHOLAST: ENTRY(DCB1) ALTRET;

     18  0 000007   000000 700200 xent  CXG$ECHOLAST TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      337       19    1           CALL XUG$ECHOLAST_COMMON(DCB1) ALTRET(CORRES) ;

     19  0 000011   200003 630500                    EPPR0   @DCB1,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$ECHOLAST_COMMON
         0 000014   000016 702000 0                  TSX2    CORRES

      338       20    1           RETURN;

     20  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      339       21
      340       22    1   CORRES: ALTRETURN;

     22  0 000016   000000 702200 xent  CORRES       TSX2  ! X66_AALT
      341       23    1   END CXG$CORRES;
      342       24        %EOD;

PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:39   
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$CORRES.
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:40   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @DCB1                      4-0-0/w PTR         r     1 @DCB2
    *0-0-0/w SBIN        r     1 DCB1                      *0-0-0/w SBIN        r     1 DCB2


   Procedure CXG$CORRES requires 15 words for executable code.
   Procedure CXG$CORRES requires 6 words of local(AUTO) storage.
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:41   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=CXG$CORRES File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:42   
          MINI XREF LISTING

CORRES
        22**LABEL      15--CALLALT    19--CALLALT
DCB1
         9**DCL         7--PROC       15<>CALL       18--ENTRY      19<>CALL
DCB2
        10**DCL         7--PROC       15<>CALL
XUG$CORRES_COMMON
        12**DCL-ENT    15--CALL
XUG$ECHOLAST_COMMON
        13**DCL-ENT    19--CALL

PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:43   
      343        1        /*T***********************************************************/
      344        2        /*T*                                                         */
      345        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      346        4        /*T*                                                         */
      347        5        /*T***********************************************************/
      348        6        CXG$BREAK: PROC (GETCMD) ;
      349        7        /**/
      350        8        %INCLUDE XU_MACRO_C ;
      351     3114        /**/
      352     3115        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      353     3453    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      354     3454        %EJECT;
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:44   
      355     3455    1           CALL XUG$BREAK_COMMON (GETCMD) ;
      356     3456    1           RETURN ;
      357     3457    1   END CXG$BREAK;
      358     3458        %EOD;

PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:45   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$BREAK.

   Procedure CXG$BREAK requires 7 words for executable code.
   Procedure CXG$BREAK requires 4 words of local(AUTO) storage.

PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:46   

 Object Unit name= CXG$BREAK                                  File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:34.08 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  CXG$BREAK

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        1  CXG$BREAK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$BREAK_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:47   


      343        1        /*T***********************************************************/
      344        2        /*T*                                                         */
      345        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      346        4        /*T*                                                         */
      347        5        /*T***********************************************************/
      348        6        CXG$BREAK: PROC (GETCMD) ;

      6  0 000000   000000 700200 xent  CXG$BREAK    TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      349        7        /**/
      350        8        %INCLUDE XU_MACRO_C ;
      351     3114        /**/
      352     3115        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      353     3453    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      354     3454        %EJECT;
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:48   
      355     3455    1           CALL XUG$BREAK_COMMON (GETCMD) ;

   3455  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$BREAK_COMMON
         0 000005   000000 011000                    NOP     0

      356     3456    1           RETURN ;

   3456  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      357     3457    1   END CXG$BREAK;
      358     3458        %EOD;

PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:49   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$BREAK.
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:50   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure CXG$BREAK requires 7 words for executable code.
   Procedure CXG$BREAK requires 4 words of local(AUTO) storage.
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:51   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=CXG$BREAK File=CXG$GETCMD.:E05TSI                             TUE 07/29/97 12:28 Page:52   
          MINI XREF LISTING

GETCMD
      3128**DCL         6--PROC     3455<>CALL
GETCMD.OUT$
      3133**DCL      3139--REDEF
XUG$BREAK_COMMON
      3453**DCL-ENT  3455--CALL

PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:53   
      359        1        /*T***********************************************************/
      360        2        /*T*                                                         */
      361        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      362        4        /*T*                                                         */
      363        5        /*T***********************************************************/
      364        6        CXG$DISABLE: PROC(GETCMD);
      365        7        /**/
      366        8        %INCLUDE XU_MACRO_C ;
      367     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      368     3452        /**/
      369     3453    1   DCL XUG$DISABLE_COMMON ENTRY(1) ;
      370     3454    1   DCL XUG$CLRENABLE_COMMON ENTRY(1) ;
      371     3455    1   DCL XUG$ENABLE_COMMON ENTRY(1) ;
      372     3456
      373     3457    1           CALL XUG$DISABLE_COMMON(GETCMD) ;
      374     3458    1           RETURN ;
      375     3459    1   CXG$CLRENABLE: ENTRY(GETCMD);
      376     3460    1           CALL XUG$CLRENABLE_COMMON(GETCMD) ;
      377     3461    1           RETURN ;
      378     3462    1   CXG$ENABLE: ENTRY(GETCMD);
      379     3463    1           CALL XUG$ENABLE_COMMON(GETCMD) ;
      380     3464    1           RETURN ;
      381     3465    1   END CXG$DISABLE;
      382     3466        %EOD;

PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:54   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$DISABLE.

   Procedure CXG$DISABLE requires 21 words for executable code.
   Procedure CXG$DISABLE requires 4 words of local(AUTO) storage.

PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:55   

 Object Unit name= CXG$DISABLE                                File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:41.20 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    21     25  CXG$DISABLE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        1  CXG$DISABLE
     0      7                  yes      Std        1  CXG$CLRENABLE
     0     16                  yes      Std        1  CXG$ENABLE

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$DISABLE_COMMON
         yes           Std       1 XUG$CLRENABLE_COMMON
         yes           Std       1 XUG$ENABLE_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:56   


      359        1        /*T***********************************************************/
      360        2        /*T*                                                         */
      361        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      362        4        /*T*                                                         */
      363        5        /*T***********************************************************/
      364        6        CXG$DISABLE: PROC(GETCMD);

      6  0 000000   000000 700200 xent  CXG$DISABLE  TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      365        7        /**/
      366        8        %INCLUDE XU_MACRO_C ;
      367     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      368     3452        /**/
      369     3453    1   DCL XUG$DISABLE_COMMON ENTRY(1) ;
      370     3454    1   DCL XUG$CLRENABLE_COMMON ENTRY(1) ;
      371     3455    1   DCL XUG$ENABLE_COMMON ENTRY(1) ;
      372     3456
      373     3457    1           CALL XUG$DISABLE_COMMON(GETCMD) ;

   3457  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$DISABLE_COMMON
         0 000005   000000 011000                    NOP     0

      374     3458    1           RETURN ;

   3458  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      375     3459    1   CXG$CLRENABLE: ENTRY(GETCMD);

   3459  0 000007   000000 700200 xent  CXG$CLRENAB* TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      376     3460    1           CALL XUG$CLRENABLE_COMMON(GETCMD) ;

PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:57   
   3460  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$CLRENABLE_COMMON
         0 000014   000000 011000                    NOP     0

      377     3461    1           RETURN ;

   3461  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      378     3462    1   CXG$ENABLE: ENTRY(GETCMD);

   3462  0 000016   000000 700200 xent  CXG$ENABLE   TSX0  ! X66_AUTO_1
         0 000017   000004 000001                    ZERO    4,1

      379     3463    1           CALL XUG$ENABLE_COMMON(GETCMD) ;

   3463  0 000020   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ENABLE_COMMON
         0 000023   000000 011000                    NOP     0

      380     3464    1           RETURN ;

   3464  0 000024   000000 702200 xent               TSX2  ! X66_ARET
      381     3465    1   END CXG$DISABLE;
      382     3466        %EOD;

PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:58   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$DISABLE.
PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:59   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure CXG$DISABLE requires 21 words for executable code.
   Procedure CXG$DISABLE requires 4 words of local(AUTO) storage.
PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:60   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=CXG$DISABLE File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:28 Page:61   
          MINI XREF LISTING

GETCMD
      3127**DCL         6--PROC     3457<>CALL     3459--ENTRY    3460<>CALL     3462--ENTRY    3463<>CALL
GETCMD.OUT$
      3132**DCL      3138--REDEF
XUG$CLRENABLE_COMMON
      3454**DCL-ENT  3460--CALL
XUG$DISABLE_COMMON
      3453**DCL-ENT  3457--CALL
XUG$ENABLE_COMMON
      3455**DCL-ENT  3463--CALL

PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:62   
      383        1        /*T***********************************************************/
      384        2        /*T*                                                         */
      385        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      386        4        /*T*                                                         */
      387        5        /*T***********************************************************/
      388        6        /* CXG$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      389        7        /**/
      390        8        CXG$ERRMSG: PROC (GETCMD) ALTRET;
      391        9        /**/
      392       10        %INCLUDE XU_MACRO_C ;
      393     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      394     3454        /**/
      395     3455    1   DCL XUG$ERRMSG_COMMON ENTRY(1) ALTRET ;
      396     3456    1   DCL XUG$SETERRMSG_COMMON ENTRY(1) ALTRET ;
      397     3457        /**/
      398     3458        %EJECT;
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:63   
      399     3459    1           CALL XUG$ERRMSG_COMMON(GETCMD) ALTRET(ALT) ;
      400     3460    1           RETURN;
      401     3461    1   CXG$SETERRMSG: ENTRY(GETCMD) ALTRET;
      402     3462    1           CALL XUG$SETERRMSG_COMMON(GETCMD) ALTRET(ALT) ;
      403     3463    1           RETURN ;
      404     3464    1   ALT:    ALTRETURN;
      405     3465    1   END CXG$ERRMSG;
      406     3466        %EOD;

PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:64   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRMSG.

   Procedure CXG$ERRMSG requires 15 words for executable code.
   Procedure CXG$ERRMSG requires 4 words of local(AUTO) storage.

PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:65   

 Object Unit name= CXG$ERRMSG                                 File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:47.76 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  CXG$ERRMSG

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  CXG$ERRMSG
     0      7          yes     yes      Std        1  CXG$SETERRMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$ERRMSG_COMMON
 yes     yes           Std       1 XUG$SETERRMSG_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:66   


      383        1        /*T***********************************************************/
      384        2        /*T*                                                         */
      385        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      386        4        /*T*                                                         */
      387        5        /*T***********************************************************/
      388        6        /* CXG$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      389        7        /**/
      390        8        CXG$ERRMSG: PROC (GETCMD) ALTRET;

      8  0 000000   000000 700200 xent  CXG$ERRMSG   TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      391        9        /**/
      392       10        %INCLUDE XU_MACRO_C ;
      393     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      394     3454        /**/
      395     3455    1   DCL XUG$ERRMSG_COMMON ENTRY(1) ALTRET ;
      396     3456    1   DCL XUG$SETERRMSG_COMMON ENTRY(1) ALTRET ;
      397     3457        /**/
      398     3458        %EJECT;
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:67   
      399     3459    1           CALL XUG$ERRMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3459  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$ERRMSG_COMMON
         0 000005   000016 702000 0                  TSX2    ALT

      400     3460    1           RETURN;

   3460  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      401     3461    1   CXG$SETERRMSG: ENTRY(GETCMD) ALTRET;

   3461  0 000007   000000 700200 xent  CXG$SETERRM* TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      402     3462    1           CALL XUG$SETERRMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3462  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$SETERRMSG_COMMON
         0 000014   000016 702000 0                  TSX2    ALT

      403     3463    1           RETURN ;

   3463  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      404     3464    1   ALT:    ALTRETURN;

   3464  0 000016   000000 702200 xent  ALT          TSX2  ! X66_AALT
      405     3465    1   END CXG$ERRMSG;
      406     3466        %EOD;

PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:68   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRMSG.
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:69   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure CXG$ERRMSG requires 15 words for executable code.
   Procedure CXG$ERRMSG requires 4 words of local(AUTO) storage.
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:70   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #005=CXG$ERRMSG File=CXG$GETCMD.:E05TSI                            TUE 07/29/97 12:28 Page:71   
          MINI XREF LISTING

ALT
      3464**LABEL    3459--CALLALT  3462--CALLALT
GETCMD
      3129**DCL         8--PROC     3459<>CALL     3461--ENTRY    3462<>CALL
GETCMD.OUT$
      3134**DCL      3140--REDEF
XUG$ERRMSG_COMMON
      3455**DCL-ENT  3459--CALL
XUG$SETERRMSG_COMMON
      3456**DCL-ENT  3462--CALL

PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:72   
      407        1        /*T***********************************************************/
      408        2        /*T*                                                         */
      409        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      410        4        /*T*                                                         */
      411        5        /*T***********************************************************/
      412        6        CXG$HELP: PROC(GETCMD) ALTRET;
      413        7        %INCLUDE XU_MACRO_C;
      414     3113        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      415     3451        /*
      416     3452        */
      417     3453    1   DCL XUG$HELP_COMMON ENTRY(1) ALTRET ;
      418     3454    1   DCL XUG$MOREMSG_COMMON ENTRY(1) ALTRET ;
      419     3455    1   DCL XUG$ALLMSG_COMMON ENTRY(1) ALTRET ;
      420     3456        /**/
      421     3457    1           CALL XUG$HELP_COMMON(GETCMD) ALTRET(ALT) ;
      422     3458    1           RETURN ;
      423     3459
      424     3460    1   CXG$MOREMSG: ENTRY(GETCMD) ALTRET;
      425     3461    1           CALL XUG$MOREMSG_COMMON(GETCMD) ALTRET(ALT) ;
      426     3462    1           RETURN ;
      427     3463        /**/
      428     3464    1   CXG$ALLMSG: ENTRY(GETCMD) ALTRET;
      429     3465    1           CALL XUG$ALLMSG_COMMON(GETCMD) ALTRET(ALT) ;
      430     3466    1           RETURN ;
      431     3467        /**/
      432     3468    1   ALT:    ALTRETURN;
      433     3469    1   END CXG$HELP;
      434     3470        %EOD;

PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:73   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$HELP.

   Procedure CXG$HELP requires 22 words for executable code.
   Procedure CXG$HELP requires 4 words of local(AUTO) storage.

PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:74   

 Object Unit name= CXG$HELP                                   File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:28:53.60 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    22     26  CXG$HELP

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  CXG$HELP
     0      7          yes     yes      Std        1  CXG$MOREMSG
     0     16          yes     yes      Std        1  CXG$ALLMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$HELP_COMMON
 yes     yes           Std       1 XUG$MOREMSG_COMMON
 yes     yes           Std       1 XUG$ALLMSG_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:75   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:76   


      407        1        /*T***********************************************************/
      408        2        /*T*                                                         */
      409        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      410        4        /*T*                                                         */
      411        5        /*T***********************************************************/
      412        6        CXG$HELP: PROC(GETCMD) ALTRET;

      6  0 000000   000000 700200 xent  CXG$HELP     TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      413        7        %INCLUDE XU_MACRO_C;
      414     3113        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      415     3451        /*
      416     3452        */
      417     3453    1   DCL XUG$HELP_COMMON ENTRY(1) ALTRET ;
      418     3454    1   DCL XUG$MOREMSG_COMMON ENTRY(1) ALTRET ;
      419     3455    1   DCL XUG$ALLMSG_COMMON ENTRY(1) ALTRET ;
      420     3456        /**/
      421     3457    1           CALL XUG$HELP_COMMON(GETCMD) ALTRET(ALT) ;

   3457  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$HELP_COMMON
         0 000005   000025 702000 0                  TSX2    ALT

      422     3458    1           RETURN ;

   3458  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      423     3459
      424     3460    1   CXG$MOREMSG: ENTRY(GETCMD) ALTRET;

   3460  0 000007   000000 700200 xent  CXG$MOREMSG  TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      425     3461    1           CALL XUG$MOREMSG_COMMON(GETCMD) ALTRET(ALT) ;
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:77   

   3461  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$MOREMSG_COMMON
         0 000014   000025 702000 0                  TSX2    ALT

      426     3462    1           RETURN ;

   3462  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      427     3463        /**/
      428     3464    1   CXG$ALLMSG: ENTRY(GETCMD) ALTRET;

   3464  0 000016   000000 700200 xent  CXG$ALLMSG   TSX0  ! X66_AUTO_1
         0 000017   000004 000001                    ZERO    4,1

      429     3465    1           CALL XUG$ALLMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3465  0 000020   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ALLMSG_COMMON
         0 000023   000025 702000 0                  TSX2    ALT

      430     3466    1           RETURN ;

   3466  0 000024   000000 702200 xent               TSX2  ! X66_ARET

      431     3467        /**/
      432     3468    1   ALT:    ALTRETURN;

   3468  0 000025   000000 702200 xent  ALT          TSX2  ! X66_AALT
      433     3469    1   END CXG$HELP;
      434     3470        %EOD;

PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:78   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$HELP.
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:79   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure CXG$HELP requires 22 words for executable code.
   Procedure CXG$HELP requires 4 words of local(AUTO) storage.
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:80   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #006=CXG$HELP File=CXG$GETCMD.:E05TSI                              TUE 07/29/97 12:28 Page:81   
          MINI XREF LISTING

ALT
      3468**LABEL    3457--CALLALT  3461--CALLALT  3465--CALLALT
GETCMD
      3126**DCL         6--PROC     3457<>CALL     3460--ENTRY    3461<>CALL     3464--ENTRY    3465<>CALL
GETCMD.OUT$
      3131**DCL      3137--REDEF
XUG$ALLMSG_COMMON
      3455**DCL-ENT  3465--CALL
XUG$HELP_COMMON
      3453**DCL-ENT  3457--CALL
XUG$MOREMSG_COMMON
      3454**DCL-ENT  3461--CALL

PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:82   
      435        1        /*T***********************************************************/
      436        2        /*T*                                                         */
      437        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      438        4        /*T*                                                         */
      439        5        /*T***********************************************************/
      440        6        CXG$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;
      441        7    1   DCL 1 DCBNAME,
      442        8    1         2 L UBIN BYTE UNAL,
      443        9    1         2 C CHAR(DCBNAME.L);
      444       10    1   DCL DCB# SBIN;
      445       11        /**/
      446       12    1   DCL XUG$FINDDCB_COMMON ENTRY(2) ALTRET ;
      447       13    1   DCL XUG$GETDCB_COMMON ENTRY(2) ALTRET ;
      448       14        /**/
      449       15    1           CALL XUG$FINDDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;
      450       16    1           RETURN ;
      451       17    1   CXG$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;
      452       18    1           CALL XUG$GETDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;
      453       19    1           RETURN;
      454       20    1   ALT:    ALTRETURN;
      455       21    1   END CXG$FINDDCB;
      456       22        %EOD;

PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:83   
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$FINDDCB.

   Procedure CXG$FINDDCB requires 15 words for executable code.
   Procedure CXG$FINDDCB requires 6 words of local(AUTO) storage.

PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:84   

 Object Unit name= CXG$FINDDCB                                File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:29:01.76 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  CXG$FINDDCB

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  CXG$FINDDCB
     0      7          yes     yes      Std        2  CXG$GETDCB

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$FINDDCB_COMMON
 yes     yes           Std       2 XUG$GETDCB_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:85   


      435        1        /*T***********************************************************/
      436        2        /*T*                                                         */
      437        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      438        4        /*T*                                                         */
      439        5        /*T***********************************************************/
      440        6        CXG$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;

      6  0 000000   000000 700200 xent  CXG$FINDDCB  TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      441        7    1   DCL 1 DCBNAME,
      442        8    1         2 L UBIN BYTE UNAL,
      443        9    1         2 C CHAR(DCBNAME.L);
      444       10    1   DCL DCB# SBIN;
      445       11        /**/
      446       12    1   DCL XUG$FINDDCB_COMMON ENTRY(2) ALTRET ;
      447       13    1   DCL XUG$GETDCB_COMMON ENTRY(2) ALTRET ;
      448       14        /**/
      449       15    1           CALL XUG$FINDDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;

     15  0 000002   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$FINDDCB_COMMON
         0 000005   000016 702000 0                  TSX2    ALT

      450       16    1           RETURN ;

     16  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      451       17    1   CXG$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;

     17  0 000007   000000 700200 xent  CXG$GETDCB   TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      452       18    1           CALL XUG$GETDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;

PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:86   
     18  0 000011   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000012   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000013   000000 701000 xent               TSX1    XUG$GETDCB_COMMON
         0 000014   000016 702000 0                  TSX2    ALT

      453       19    1           RETURN;

     19  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      454       20    1   ALT:    ALTRETURN;

     20  0 000016   000000 702200 xent  ALT          TSX2  ! X66_AALT
      455       21    1   END CXG$FINDDCB;
      456       22        %EOD;

PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:87   
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$FINDDCB.
PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:88   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @DCB#                      3-0-0/w PTR         r     1 @DCBNAME
    *0-0-0/w SBIN        r     1 DCB#                      *0-0-0/c ASTR(9)     r     1 DCBNAME


   Procedure CXG$FINDDCB requires 15 words for executable code.
   Procedure CXG$FINDDCB requires 6 words of local(AUTO) storage.
PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:89   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #007=CXG$FINDDCB File=CXG$GETCMD.:E05TSI                           TUE 07/29/97 12:29 Page:90   
          MINI XREF LISTING

ALT
        20**LABEL      15--CALLALT    18--CALLALT
DCB#
        10**DCL         6--PROC       15<>CALL       17--ENTRY      18<>CALL
DCBNAME
         7**DCL         6--PROC       15<>CALL       17--ENTRY      18<>CALL
DCBNAME.L
         8**DCL         9--IMP-SIZ    15>>CALL       18>>CALL
XUG$FINDDCB_COMMON
        12**DCL-ENT    15--CALL
XUG$GETDCB_COMMON
        13**DCL-ENT    18--CALL

PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:91   
      457        1        /*T***********************************************************/
      458        2        /*T*                                                         */
      459        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      460        4        /*T*                                                         */
      461        5        /*T***********************************************************/
      462        6        CXG$CLOSE_DCBS: PROC(GETCMD) ;
      463        7        /**/
      464        8        %INCLUDE XU_MACRO_C ;
      465     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      466     3452    1   DCL XUG$CLOSE_DCBS_COMMON ENTRY(1) ;
      467     3453        /**/
      468     3454    1           CALL XUG$CLOSE_DCBS_COMMON(GETCMD) ;
      469     3455    1           RETURN ;
      470     3456    1   END CXG$CLOSE_DCBS;
      471     3457        %EOD;

PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:92   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$CLOSE_DCBS.

   Procedure CXG$CLOSE_DCBS requires 7 words for executable code.
   Procedure CXG$CLOSE_DCBS requires 4 words of local(AUTO) storage.

PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:93   

 Object Unit name= CXG$CLOSE_DCBS                             File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:29:03.68 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  CXG$CLOSE_DCBS

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        1  CXG$CLOSE_DCBS

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$CLOSE_DCBS_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:94   


      457        1        /*T***********************************************************/
      458        2        /*T*                                                         */
      459        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      460        4        /*T*                                                         */
      461        5        /*T***********************************************************/
      462        6        CXG$CLOSE_DCBS: PROC(GETCMD) ;

      6  0 000000   000000 700200 xent  CXG$CLOSE_D* TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      463        7        /**/
      464        8        %INCLUDE XU_MACRO_C ;
      465     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      466     3452    1   DCL XUG$CLOSE_DCBS_COMMON ENTRY(1) ;
      467     3453        /**/
      468     3454    1           CALL XUG$CLOSE_DCBS_COMMON(GETCMD) ;

   3454  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$CLOSE_DCBS_COMMON
         0 000005   000000 011000                    NOP     0

      469     3455    1           RETURN ;

   3455  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      470     3456    1   END CXG$CLOSE_DCBS;
      471     3457        %EOD;

PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:95   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$CLOSE_DCBS.
PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:96   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure CXG$CLOSE_DCBS requires 7 words for executable code.
   Procedure CXG$CLOSE_DCBS requires 4 words of local(AUTO) storage.
PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:97   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #008=CXG$CLOSE_DCBS File=CXG$GETCMD.:E05TSI                        TUE 07/29/97 12:29 Page:98   
          MINI XREF LISTING

GETCMD
      3127**DCL         6--PROC     3454<>CALL
GETCMD.OUT$
      3132**DCL      3138--REDEF
XUG$CLOSE_DCBS_COMMON
      3452**DCL-ENT  3454--CALL

PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:99   
      472        1        /*T***********************************************************/
      473        2        /*T*                                                         */
      474        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      475        4        /*T*                                                         */
      476        5        /*T***********************************************************/
      477        6        CXG$BLANK_PASSWORD: PROC(GETCMD, P_B) ALTRET ;
      478        7        /**/
      479        8        %INCLUDE XU_MACRO_C ;
      480     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      481     3452        %PARSE$OUT (NAME=P_B, STCLASS=PARAM) ;
      482     3497
      483     3498    1   DCL XUG$BLANK_PASSWORD_COMMON ENTRY(2) ALTRET ;
      484     3499        /**/
      485     3500    1           CALL XUG$BLANK_PASSWORD_COMMON(GETCMD, P_B) ALTRET(BLANK_ALT) ;
      486     3501    1           RETURN ;
      487     3502
      488     3503    1   BLANK_ALT:
      489     3504    1           ALTRETURN ;
      490     3505    1   END CXG$BLANK_PASSWORD ;
      491     3506        %EOD ;

PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:100  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$BLANK_PASSWORD.

   Procedure CXG$BLANK_PASSWORD requires 8 words for executable code.
   Procedure CXG$BLANK_PASSWORD requires 6 words of local(AUTO) storage.

PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:101  

 Object Unit name= CXG$BLANK_PASSWORD                         File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:29:12.32 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     8     10  CXG$BLANK_PASSWORD

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  CXG$BLANK_PASSWORD

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$BLANK_PASSWORD_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:102  


      472        1        /*T***********************************************************/
      473        2        /*T*                                                         */
      474        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      475        4        /*T*                                                         */
      476        5        /*T***********************************************************/
      477        6        CXG$BLANK_PASSWORD: PROC(GETCMD, P_B) ALTRET ;

      6  0 000000   000000 700200 xent  CXG$BLANK_P* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      478        7        /**/
      479        8        %INCLUDE XU_MACRO_C ;
      480     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      481     3452        %PARSE$OUT (NAME=P_B, STCLASS=PARAM) ;
      482     3497
      483     3498    1   DCL XUG$BLANK_PASSWORD_COMMON ENTRY(2) ALTRET ;
      484     3499        /**/
      485     3500    1           CALL XUG$BLANK_PASSWORD_COMMON(GETCMD, P_B) ALTRET(BLANK_ALT) ;

   3500  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$BLANK_PASSWORD_COMMON
         0 000005   000007 702000 0                  TSX2    BLANK_ALT

      486     3501    1           RETURN ;

   3501  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      487     3502
      488     3503    1   BLANK_ALT:
      489     3504    1           ALTRETURN ;

   3504  0 000007   000000 702200 xent  BLANK_ALT    TSX2  ! X66_AALT
      490     3505    1   END CXG$BLANK_PASSWORD ;
      491     3506        %EOD ;

PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:103  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$BLANK_PASSWORD.
PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:104  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                    4-0-0/w PTR         r     1 @P_B
    *0-0-0/d STRC(1512)  r     1 GETCMD                    *0-0-0/w STRC(144)   r     1 P_B


   Procedure CXG$BLANK_PASSWORD requires 8 words for executable code.
   Procedure CXG$BLANK_PASSWORD requires 6 words of local(AUTO) storage.
PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:105  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #009=CXG$BLANK_PASSWORD File=CXG$GETCMD.:E05TSI                    TUE 07/29/97 12:29 Page:106  
          MINI XREF LISTING

BLANK_ALT
      3504**LABEL    3500--CALLALT
GETCMD
      3127**DCL         6--PROC     3500<>CALL
GETCMD.OUT$
      3132**DCL      3138--REDEF
P_B
      3458**DCL         6--PROC     3500<>CALL
XUG$BLANK_PASSWORD_COMMON
      3498**DCL-ENT  3500--CALL

PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:107  
      492        1        /*T***********************************************************/
      493        2        /*T*                                                         */
      494        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      495        4        /*T*                                                         */
      496        5        /*T***********************************************************/
      497        6        /*P*  NAME:       CXG$ERRCNVRT
      498        7              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      499        8        */
      500        9
      501       10        CXG$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);
      502       11
      503       12    1   DCL 1 LCP6_ERR ALIGNED,
      504       13    1         2 F1,
      505       14    1           3 * BIT (1),
      506       15    1           3 PART1 BIT (5),
      507       16    1         2 F2,
      508       17    1           3 PART1 BIT (3),
      509       18    1           3 * BIT (1),
      510       19    1           3 PART2 BIT (2),
      511       20    1         2 MID BIT (5),
      512       21    1         2 M BIT (1),
      513       22    1         2 * BIT (1),
      514       23    1         2 ERR#,
      515       24    1           3 PART1 BIT (8),
      516       25    1           3 * BIT (1),
      517       26    1           3 PART2 BIT (5),
      518       27    1         2 SEV BIT (3);
      519       28
      520       29    1   DCL 1 CP6_ERR ALIGNED,
      521       30    1         2 F1,
      522       31    1           3 * BIT (1),
      523       32    1           3 PART1 BIT (5),
      524       33    1         2 F2,
      525       34    1           3 * BIT (1),
      526       35    1           3 PART1 BIT (3),
      527       36    1           3 PART2 BIT (2),
      528       37    1         2 MID,
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:108  
      529       38    1           3 * BIT (1),
      530       39    1           3 PART1 BIT (5),
      531       40    1         2 M BIT (1),
      532       41    1         2 ERR#,
      533       42    1           3 * BIT (1),
      534       43    1           3 PART1 BIT (8),
      535       44    1           3 PART2 BIT (5),
      536       45    1         2 SEV BIT (3);
      537       46    1   DCL XUG$ERRCNVRT_COMMON ENTRY(2) ;
      538       47
      539       48    1           CALL XUG$ERRCNVRT_COMMON(LCP6_ERR, CP6_ERR) ;
      540       49    1           RETURN ;
      541       50
      542       51    1   END CXG$ERRCNVRT;
      543       52        %EOD;

PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:109  
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRCNVRT.

   Procedure CXG$ERRCNVRT requires 7 words for executable code.
   Procedure CXG$ERRCNVRT requires 6 words of local(AUTO) storage.

PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:110  

 Object Unit name= CXG$ERRCNVRT                               File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:29:24.52 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  CXG$ERRCNVRT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  CXG$ERRCNVRT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRCNVRT_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:111  


      492        1        /*T***********************************************************/
      493        2        /*T*                                                         */
      494        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      495        4        /*T*                                                         */
      496        5        /*T***********************************************************/
      497        6        /*P*  NAME:       CXG$ERRCNVRT
      498        7              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      499        8        */
      500        9
      501       10        CXG$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);

     10  0 000000   000000 700200 xent  CXG$ERRCNVRT TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      502       11
      503       12    1   DCL 1 LCP6_ERR ALIGNED,
      504       13    1         2 F1,
      505       14    1           3 * BIT (1),
      506       15    1           3 PART1 BIT (5),
      507       16    1         2 F2,
      508       17    1           3 PART1 BIT (3),
      509       18    1           3 * BIT (1),
      510       19    1           3 PART2 BIT (2),
      511       20    1         2 MID BIT (5),
      512       21    1         2 M BIT (1),
      513       22    1         2 * BIT (1),
      514       23    1         2 ERR#,
      515       24    1           3 PART1 BIT (8),
      516       25    1           3 * BIT (1),
      517       26    1           3 PART2 BIT (5),
      518       27    1         2 SEV BIT (3);
      519       28
      520       29    1   DCL 1 CP6_ERR ALIGNED,
      521       30    1         2 F1,
      522       31    1           3 * BIT (1),
      523       32    1           3 PART1 BIT (5),
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:112  
      524       33    1         2 F2,
      525       34    1           3 * BIT (1),
      526       35    1           3 PART1 BIT (3),
      527       36    1           3 PART2 BIT (2),
      528       37    1         2 MID,
      529       38    1           3 * BIT (1),
      530       39    1           3 PART1 BIT (5),
      531       40    1         2 M BIT (1),
      532       41    1         2 ERR#,
      533       42    1           3 * BIT (1),
      534       43    1           3 PART1 BIT (8),
      535       44    1           3 PART2 BIT (5),
      536       45    1         2 SEV BIT (3);
      537       46    1   DCL XUG$ERRCNVRT_COMMON ENTRY(2) ;
      538       47
      539       48    1           CALL XUG$ERRCNVRT_COMMON(LCP6_ERR, CP6_ERR) ;

     48  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRCNVRT_COMMON
         0 000005   000000 011000                    NOP     0

      540       49    1           RETURN ;

     49  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      541       50
      542       51    1   END CXG$ERRCNVRT;
      543       52        %EOD;

PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:113  
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRCNVRT.
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:114  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure CXG$ERRCNVRT requires 7 words for executable code.
   Procedure CXG$ERRCNVRT requires 6 words of local(AUTO) storage.
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:115  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #010=CXG$ERRCNVRT File=CXG$GETCMD.:E05TSI                          TUE 07/29/97 12:29 Page:116  
          MINI XREF LISTING

CP6_ERR
        29**DCL        10--PROC       48<>CALL
LCP6_ERR
        12**DCL        10--PROC       48<>CALL
XUG$ERRCNVRT_COMMON
        46**DCL-ENT    48--CALL

PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:117  
      544        1        /*T***********************************************************/
      545        2        /*T*                                                         */
      546        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      547        4        /*T*                                                         */
      548        5        /*T***********************************************************/
      549        6        /*P*  NAME:       CXG$ERRTOLCP6
      550        7              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      551        8        */
      552        9
      553       10        CXG$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);
      554       11
      555       12    1   DCL 1 LCP6_ERR ALIGNED,
      556       13    1         2 F1,
      557       14    1           3 * BIT (1),
      558       15    1           3 PART1 BIT (5),
      559       16    1         2 F2,
      560       17    1           3 PART1 BIT (3),
      561       18    1           3 * BIT (1),
      562       19    1           3 PART2 BIT (2),
      563       20    1         2 MID BIT (5),
      564       21    1         2 M BIT (1),
      565       22    1         2 * BIT (1),
      566       23    1         2 ERR#,
      567       24    1           3 PART1 BIT (8),
      568       25    1           3 * BIT (1),
      569       26    1           3 PART2 BIT (5),
      570       27    1         2 SEV BIT (3);
      571       28
      572       29    1   DCL 1 CP6_ERR ALIGNED,
      573       30    1         2 F1,
      574       31    1           3 * BIT (1),
      575       32    1           3 PART1 BIT (5),
      576       33    1         2 F2,
      577       34    1           3 * BIT (1),
      578       35    1           3 PART1 BIT (3),
      579       36    1           3 PART2 BIT (2),
      580       37    1         2 MID,
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:118  
      581       38    1           3 * BIT (1),
      582       39    1           3 PART1 BIT (5),
      583       40    1         2 M BIT (1),
      584       41    1         2 ERR#,
      585       42    1           3 * BIT (1),
      586       43    1           3 PART1 BIT (8),
      587       44    1           3 PART2 BIT (5),
      588       45    1         2 SEV BIT (3);
      589       46    1   DCL XUG$ERRTOLCP6_COMMON ENTRY(2) ;
      590       47
      591       48    1           CALL XUG$ERRTOLCP6_COMMON(LCP6_ERR, CP6_ERR) ;
      592       49    1           RETURN;
      593       50
      594       51    1   END CXG$ERRTOLCP6;

PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:119  
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRTOLCP6.

   Procedure CXG$ERRTOLCP6 requires 7 words for executable code.
   Procedure CXG$ERRTOLCP6 requires 6 words of local(AUTO) storage.

    No errors detected in file CXG$GETCMD.:E05TSI    .

PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:120  

 Object Unit name= CXG$ERRTOLCP6                              File name= CXG$GETCMD.:E05TOU
 UTS= JUL 29 '97 12:29:28.36 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  CXG$ERRTOLCP6

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  CXG$ERRTOLCP6

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRTOLCP6_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:121  


      544        1        /*T***********************************************************/
      545        2        /*T*                                                         */
      546        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      547        4        /*T*                                                         */
      548        5        /*T***********************************************************/
      549        6        /*P*  NAME:       CXG$ERRTOLCP6
      550        7              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      551        8        */
      552        9
      553       10        CXG$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);

     10  0 000000   000000 700200 xent  CXG$ERRTOLC* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      554       11
      555       12    1   DCL 1 LCP6_ERR ALIGNED,
      556       13    1         2 F1,
      557       14    1           3 * BIT (1),
      558       15    1           3 PART1 BIT (5),
      559       16    1         2 F2,
      560       17    1           3 PART1 BIT (3),
      561       18    1           3 * BIT (1),
      562       19    1           3 PART2 BIT (2),
      563       20    1         2 MID BIT (5),
      564       21    1         2 M BIT (1),
      565       22    1         2 * BIT (1),
      566       23    1         2 ERR#,
      567       24    1           3 PART1 BIT (8),
      568       25    1           3 * BIT (1),
      569       26    1           3 PART2 BIT (5),
      570       27    1         2 SEV BIT (3);
      571       28
      572       29    1   DCL 1 CP6_ERR ALIGNED,
      573       30    1         2 F1,
      574       31    1           3 * BIT (1),
      575       32    1           3 PART1 BIT (5),
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:122  
      576       33    1         2 F2,
      577       34    1           3 * BIT (1),
      578       35    1           3 PART1 BIT (3),
      579       36    1           3 PART2 BIT (2),
      580       37    1         2 MID,
      581       38    1           3 * BIT (1),
      582       39    1           3 PART1 BIT (5),
      583       40    1         2 M BIT (1),
      584       41    1         2 ERR#,
      585       42    1           3 * BIT (1),
      586       43    1           3 PART1 BIT (8),
      587       44    1           3 PART2 BIT (5),
      588       45    1         2 SEV BIT (3);
      589       46    1   DCL XUG$ERRTOLCP6_COMMON ENTRY(2) ;
      590       47
      591       48    1           CALL XUG$ERRTOLCP6_COMMON(LCP6_ERR, CP6_ERR) ;

     48  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRTOLCP6_COMMON
         0 000005   000000 011000                    NOP     0

      592       49    1           RETURN;

     49  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      593       50
      594       51    1   END CXG$ERRTOLCP6;

PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:123  
--  Include file information  --

   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure CXG$ERRTOLCP6.
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:124  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure CXG$ERRTOLCP6 requires 7 words for executable code.
   Procedure CXG$ERRTOLCP6 requires 6 words of local(AUTO) storage.

    No errors detected in file CXG$GETCMD.:E05TSI    .
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:125  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #011=CXG$ERRTOLCP6 File=CXG$GETCMD.:E05TSI                         TUE 07/29/97 12:29 Page:126  
          MINI XREF LISTING

CP6_ERR
        29**DCL        10--PROC       48<>CALL
LCP6_ERR
        12**DCL        10--PROC       48<>CALL
XUG$ERRTOLCP6_COMMON
        46**DCL-ENT    48--CALL
