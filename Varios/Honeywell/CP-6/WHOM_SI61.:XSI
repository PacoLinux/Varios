/*M* WHOM_SI61 - PL6 source file for WHOM.                         */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
/*M* WHOM - Program to display users on a system.                  */
/*F* NAME: WHOM                                                    */
/*D* This program is an extension of WHO.XX. It provides a view of */
/*   user jit information when a single user is specified. There  */
/*   are two modes of execution, TTY and CRT. TTY is scrolling    */
/*   and CRT is screen update. If the device is actually a TTY    */
/*   type terminal, the program exits after one display.          */
/*  Bill Baskett, Bull, @RMC Kingston    */
 
WHOM: PROC MAIN NOAUTO;
 
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE B$USER;
%INCLUDE B_MICROPS_C;
%SET LISTINC = '1'B ;
%INCLUDE SS_SCHED_C ;
%SET LISTINC = '0'B ;
%INCLUDE WHOM_C61;
%INCLUDE XU_MACRO_C;
%F$DCB;
%PARSE$OUT ( STCLASS=BASED );
%PARSE$SYM ( STCLASS=BASED );
 
%SUB yes = "'1'B";
%SUB  no = "'0'B";
%SUB BATCHandONLINE = "'0'B,'1'B,'0'B,'1'B,'0'B";
%SUB ONLINEandTP    = "'0'B,'0'B,'0'B,'1'B,'1'B";
%SUB AllModes       = "'0'B,'1'B,'1'B,'1'B,'1'B";
 
DCL XUR$GETCMD ENTRY (6) ALTRET;
DCL XUR$ERRPTR ENTRY (2) ALTRET;
DCL XUR$ERRMSG ENTRY (7) ALTRET;
DCL DAM$MAP    ENTRY (5) ALTRET;
DCL DAM$INIT   ENTRY     ALTRET;
DCL SCREENIN   ENTRY (2);
DCL SCREENUP   ENTRY (1);
DCL SCREECH    ENTRY;
DCL CURSOR     ENTRY (2);
DCL CRTFLSHX  ENTRY;
DCL TIME_CNVRT ENTRY (2);
DCL RIGHT      ENTRY (4);
DCL COMPARE_NAME ENTRY (2) ALTRET;
DCL COMPARE_ACCT ENTRY (2) ALTRET;
DCL BREAKER    ENTRY ASYNC;
DCL MAY_END    ENTRY ALTRET;
 
/*  MULTI_USER_INIT     INTERNAL */
/*  MULTI_USER_FORMAT   INTERNAL */
/*  MULTI_USER_DISPLAY  INTERNAL */
/*  SINGLE_USER_DISPLAY INTERNAL */
/*  SINGLE_USER_FORMAT  INTERNAL */
/*  UPDATE_TOTALS       INTERNAL */
 
DCL EXIT_NEXT  BIT (1) ALIGNED; /* Some exit condition met?   */
DCL FINISHED   BIT (1) ALIGNED; /* Exit main loop?            */
DCL SCROLL     BIT (1) ALIGNED; /* TTY type display?          */
DCL MULTI_USER BIT (1) ALIGNED; /* Original WHOM type display? */
DCL MULTI_TTY  BIT (1) ALIGNED; /* Special case TTY output    */
DCL GO_BACK_TO_SCREEN_MODE    BIT (1) ALIGNED; /* Going back to screen mode? */
DCL EVEN       BIT (1) ALIGNED; /* Left side multi user?      */
DCL NONE_SELECTED BIT (1) ALIGNED; /* Has user selected modes?*/
DCL WILD_NAME  BIT (1) ALIGNED; /* Wildcarded name?         */
DCL WILD_ACCT  BIT (1) ALIGNED; /* Wildcarded account number?*/
DCL NAME_PICKD BIT (1) ALIGNED; /* Name specified?          */
DCL ACCT_PICKD BIT (1) ALIGNED; /* Acct specified?          */
DCL INT_SPECD  BIT (1) ALIGNED; /* Interval specified?      */
DCL JUST_MEM   BIT (1) ALIGNED; /* MEMORY option?           */
DCL THIS_ACCT  BIT (1) ALIGNED; /* Used in conjunction with NOT ACCT*/
DCL THIS_NAME  BIT (1) ALIGNED; /* Used in conjunction with NOT NAME*/
DCL NAMES      BIT (1) ALIGNED STATIC INIT(no); /* Name or account? */
DCL PARTITION  BIT (1) ALIGNED;
DCL PART_ON    BIT (1) ALIGNED;
DCL BREAK_HIT  BIT (1) STATIC SYMDEF INIT(no);
 
DCL UNITS#     UBIN STATIC INIT(5);
DCL Z UBIN;
 
DCL MODES_SELECTED (0:4) BIT (1) STATIC UNAL INIT(no,no,no,no,no);
DCL MODES_R REDEF MODES_SELECTED UBIN (5) UNAL;
 
DCL DEFAULT_MODES (0:4) BIT (1) CONSTANT UNAL INIT(BATCHandONLINE);
DCL DEFAULT REDEF DEFAULT_MODES UBIN (5) UNAL;
 
DCL DEF_FEP_MODES (0:4) BIT (1) CONSTANT UNAL INIT(ONLINEandTP);
DCL FEP_MODES REDEF DEF_FEP_MODES UBIN (5) UNAL;
 
DCL ALL_MODES_X (0:4) BIT (1) CONSTANT UNAL INIT(AllModes);
DCL ALL_MODES REDEF ALL_MODES_X UBIN (5) UNAL;
 
DCL CCARS  UBIN WORD ALIGNED;
DCL COUNT  SBIN WORD ALIGNED;
DCL INVOKE UBIN SYMREF;
DCL DA_MUAIS SBIN SYMREF;
DCL I      UBIN WORD ALIGNED;
DCL HEIGHT UBIN;
DCL WIDTH  UBIN;
DCL MODE   UBIN;
DCL START  UBIN;
DCL UNUM   UBIN;
DCL UTS    UBIN STATIC;
DCL USER_COUNT UBIN;
DCL UWORD  UBIN;
DCL H      UBIN;
DCL X      UBIN;
DCL FEP    UBIN;
DCL R      UBIN;
DCL L      UBIN;
DCL TVAL   UBIN;
DCL LEN    UBIN;
 
DCL USER   SBIN WORD ALIGNED;
DCL USERU  UBIN  WORD ALIGNED;
DCL SWORD  SBIN;
 
DCL B$JIT$ PTR SYMREF;
DCL PCB$   PTR;
DCL PTR$   PTR;
DCL JIT$   PTR;
DCL U$LM$  PTR;
DCL USERT$ PTR STATIC;
DCL M$LM$  PTR;
 
DCL M$LM DCB;
DCL M$LO DCB;
 
DCL NOT_ENUF_PRIV CHAR (0) CONSTANT INIT(
 ' You do not have the necessary privilege for this processor.');
 
DCL FRAME CHAR (8) BASED;
DCL MYACCT UBIN;
DCL TIME CHAR (11) STATIC;
DCL U2   CHAR (2);
DCL U3   CHAR (3);
DCL U4   CHAR (4);
DCL U5   CHAR (5);
DCL U6   CHAR (6);
DCL S6   CHAR (6);
DCL S7   CHAR (7);
DCL S10  CHAR (10);
DCL S12  CHAR (12);
DCL ACCT CHAR (8);
DCL NAME CHAR (12);
 
DCL 1 TABLEO CONSTANT WALIGNED,
    2 * (0:511) UBIN (9) UNAL INIT(0*33,1*94,0*385);
DCL TABLE REDEF TABLEO CHAR (512) CALIGNED;
DCL 1 PART STATIC,
    2 * CHAR (1) INIT('*'),
    2 ITION CHAR (2),
    2 * CHAR (1) INIT('*');
DCL PARTR REDEF PART CHAR (4);
DCL BBUF CHAR (120);
DCL TEMPBUF CHAR (120);
 
DCL MODES_SUD (0:4) CHAR (6) CONSTANT INIT(
 '   bug',' Batch',' Ghost','Online','    TP');
DCL MODES_MUD (0:4) CHAR (1) CONSTANT INIT(
 '?','b','g',' ','t');
 
%S_STATE  ( FPTN = STATES ) ;
%S_RSTATE ( FPTN = RSTATES ) ;
 
DCL FAKE (0:27) CHAR (7) CONSTANT INIT(
 'E','EX','e','b','ex','B','EXAMINE','BUILD','C','L','COPY','DEL',
 'DELETE','MOD','MODIFY','REW','REWIND','MOUNT','RENAME','LYNX',
 'LOAD','MAP','BACKUP','FETCH','STOW','UNSTOW','RESTORE','RUN');
DCL REAL (0:27) CHAR(7) CONSTANT INIT(
 'EDIT'*8,'PCL'*11,'LINK'*3,'EFT'*5,'*L');
 
DCL 1 DP# STATIC,
    2 *    CHAR (3) INIT('DP#'),
    2 PAC  CHAR (6) INIT(' ');
DCL 1 WSN@ STATIC,
    2 *    CHAR (1) INIT('@'),
    2 WOO  CHAR (8) INIT(' ');
 
DCL 1 MEM STATIC DALIGNED,
    2 IN_USE UBIN,
    2 BY_MODE (0:4) UBIN,
    2 AVAIL UBIN;
DCL 1 MEM$INIT STATIC DALIGNED,
    2 * (0:6) UBIN INIT(0*7);
 
DCL OCTDIG (0:7) CHAR (1) CONSTANT INIT(
  '0','1','2','3','4','5','6','7');
DCL HEXDIG (0:15) CHAR (1) CONSTANT INIT(
  '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
 
DCL OCTCHAR (0:2) CHAR (1);
DCL OCTEDIT REDEF OCTCHAR CHAR (3);
 
DCL HEXCHAR (0:3) CHAR (1);
DCL HEXEDIT REDEF HEXCHAR CHAR (4);
 
DCL UNUM9 UBIN (9) STATIC UNAL;
DCL UNUM3 (0:2) REDEF UNUM9 UBIN (3) UNAL;
 
DCL UNUM16 UBIN (16) STATIC UNAL;
DCL UNUM4 (0:3) REDEF UNUM16 UBIN (4) UNAL;
 
DCL MOPS (0:4) BIT (9) CONSTANT CALIGNED INIT(
  %LTE5,'056'O,%MFLC2,%ENF10,%MVC1);
DCL OCTMOP REDEF MOPS CHAR (5) UNAL;
 
DCL SMOP7 (0:4) BIT (9) CONSTANT CALIGNED INIT(
  %LTE3,'040'O,%MFLS5,%ENF00,%MVC1);
DCL SIGNED_MOPS7 REDEF SMOP7 CHAR (5) UNAL;
 
DCL SMOP10 (0:4) BIT (9) CONSTANT CALIGNED INIT(
  %LTE3,'040'O,%MFLS8,%ENF00,%MVC1);
DCL SIGNED_MOPS10 REDEF SMOP10 CHAR (5) UNAL;
 
DCL SMOP12 (0:4) BIT (9) CONSTANT CALIGNED INIT(
  %LTE3,'040'O,%MFLS10,%ENF00,%MVC1);
DCL SIGNED_MOPS12 REDEF SMOP12 CHAR (5) UNAL;
 
DCL TMOP (0:8) BIT (9) CONSTANT CALIGNED INIT(
  %LTE6,'072'O,%LTE5,'040'O,%MFLC2,%ENF10,%MVC1,%INSB6,%MVC2);
DCL TIME_MOP REDEF TMOP CHAR (9) CALIGNED;
 
DCL UBINMOP6 (0:1) BIT (9) CONSTANT INIT(%MVZB5,%MVC1);
DCL UMOP6 REDEF UBINMOP6 CHAR (2);
 
DCL UBINMOP5 (0:1) BIT (9) CONSTANT INIT(%MVZB4,%MVC1);
DCL UMOP5 REDEF UBINMOP5 CHAR (2);
 
DCL UBINMOP4 (0:1) BIT (9) CONSTANT INIT(%MVZB3,%MVC1);
DCL UMOP4 REDEF UBINMOP4 CHAR (2);
 
DCL UBINMOP3 (0:1) BIT (9) CONSTANT INIT(%MVZB2,%MVC1);
DCL UMOP3 REDEF UBINMOP3 CHAR (2);
 
DCL UBINMOP2 (0:1) BIT (9) CONSTANT INIT(%MVZB1,%MVC1);
DCL UMOP2 REDEF UBINMOP2 CHAR (2);
 
 
DCL 1 TIMES STATIC,
    2 MM CHAR (7),
    2 SS CHAR (2);
DCL 1 TIMER REDEF TIMES,
    2 *  CHAR (4),
    2 VAL CHAR (5);
DCL 1 TIMEX,
    2 * CHAR (1),
    2 LEAST CHAR (6);
DCL TIME2 REDEF TIMEX CHAR (7);
 
DCL LOWERCASE BIT (9) CONSTANT INIT('040'O);
DCL PRIVS BIT (36) ALIGNED;
DCL PRIV_ON (0:35) REDEF PRIVS BIT (1) UNAL;
 
DCL PPRIV$PTRS (0:35) PTR STATIC INIT(
    ADDR(PP.RIV.ONE(0)),ADDR(PP.RIV.TWO(0)),
    ADDR(PP.RIV.ONE(1)),ADDR(PP.RIV.TWO(1)),
    ADDR(PP.RIV.ONE(2)),ADDR(PP.RIV.TWO(2)),
    ADDR(PP.RIV.ONE(3)),ADDR(PP.RIV.TWO(3)),
    ADDR(PP.RIV.ONE(4)),ADDR(PP.RIV.TWO(4)),
    ADDR(PP.RIV.ONE(5)),ADDR(PP.RIV.TWO(5)),
    ADDR(PP.RIV.ONE(6)),ADDR(PP.RIV.TWO(6)),
    ADDR(PP.RIV.ONE(7)),ADDR(PP.RIV.TWO(7)),
    ADDR(PP.RIV.ONE(8)),ADDR(PP.RIV.TWO(8)),
    ADDR(PP.RIV.ONE(9)),ADDR(PP.RIV.TWO(9)),
    ADDR(PP.RIV.ONE(10)),ADDR(PP.RIV.TWO(10)),
    ADDR(PP.RIV.ONE(11)),ADDR(PP.RIV.TWO(11)),
    ADDR(PP.RIV.ONE(12)),ADDR(PP.RIV.TWO(12)),
    ADDR(PP.RIV.ONE(13)),ADDR(PP.RIV.TWO(13)),
    ADDR(PP.RIV.ONE(14)),ADDR(PP.RIV.TWO(14)),
    ADDR(PP.RIV.ONE(15)),ADDR(PP.RIV.TWO(15)),
    ADDR(PP.RIV.ONE(16)),ADDR(PP.RIV.TWO(16)),
    ADDR(PP.RIV.ONE(17)),ADDR(PP.RIV.TWO(17)));
 
DCL PRIV$PTRS (0:35) PTR STATIC INIT(
    ADDR(P.RIV.ONE(0)),ADDR(P.RIV.TWO(0)),
    ADDR(P.RIV.ONE(1)),ADDR(P.RIV.TWO(1)),
    ADDR(P.RIV.ONE(2)),ADDR(P.RIV.TWO(2)),
    ADDR(P.RIV.ONE(3)),ADDR(P.RIV.TWO(3)),
    ADDR(P.RIV.ONE(4)),ADDR(P.RIV.TWO(4)),
    ADDR(P.RIV.ONE(5)),ADDR(P.RIV.TWO(5)),
    ADDR(P.RIV.ONE(6)),ADDR(P.RIV.TWO(6)),
    ADDR(P.RIV.ONE(7)),ADDR(P.RIV.TWO(7)),
    ADDR(P.RIV.ONE(8)),ADDR(P.RIV.TWO(8)),
    ADDR(P.RIV.ONE(9)),ADDR(P.RIV.TWO(9)),
    ADDR(P.RIV.ONE(10)),ADDR(P.RIV.TWO(10)),
    ADDR(P.RIV.ONE(11)),ADDR(P.RIV.TWO(11)),
    ADDR(P.RIV.ONE(12)),ADDR(P.RIV.TWO(12)),
    ADDR(P.RIV.ONE(13)),ADDR(P.RIV.TWO(13)),
    ADDR(P.RIV.ONE(14)),ADDR(P.RIV.TWO(14)),
    ADDR(P.RIV.ONE(15)),ADDR(P.RIV.TWO(15)),
    ADDR(P.RIV.ONE(16)),ADDR(P.RIV.TWO(16)),
    ADDR(P.RIV.ONE(17)),ADDR(P.RIV.TWO(17)));
 
DCL 1 SCRS STATIC DALIGNED,  /* Single user display screen */
    2 *           CHAR (13) INIT(' mode'),
    2 MODE        CHAR  (6) INIT(' '),
    2 *           CHAR  (9) INIT('  ccbuf !'),
    2 CCBUF       CHAR (51) INIT(' '),
    2 *           CHAR (16) INIT('  user#'),
    2 USER#       CHAR  (4) INIT(' '),
    2 *           CHAR  (6) INIT('  on@'),
    2 TIME        CHAR  (5) INIT(' '),
    2 *           CHAR  (1) INIT(' '),
    2 DATE        CHAR  (8) INIT(' '),
    2 *           CHAR (20) INIT('  ___PPrivileges___'),
    2 *           CHAR (21) INIT('  ____Privileges___'),
    2 *           CHAR (13) INIT(' sysid'),
    2 SYSID       CHAR  (6) INIT(' '),
    2 *           CHAR  (2) INIT(' '),
    2 LINEORPART  CHAR (11) INIT(' '),
    2 FEP         CHAR  (2) INIT(' '),
    2 DASH        CHAR  (1) INIT(' '),
    2 LINE        CHAR  (4) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (11) INIT(' accn'),
    2 ACCN        CHAR  (8) INIT(' '),
    2 *           CHAR  (2) INIT(' '),
    2 SPEED2      CHAR (13) INIT(' '),
    2 SPEED       CHAR  (5) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR  (7) INIT(' uname'),
    2 UNAME       CHAR (12) INIT(' '),
    2 *           CHAR  (9) INIT('  remtime'),
    2 REMTIME     CHAR (11) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR  (7) INIT(' jname'),
    2 JNAME       CHAR (12) INIT(' '),
    2 *           CHAR (13) INIT('  remlo'),
    2 REMLO       CHAR  (7) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (10) INIT(' woo'),
    2 WOO         CHAR  (9) INIT(' '),
    2 *           CHAR (13) INIT('  remdo'),
    2 REMDO       CHAR  (7) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (10) INIT(' hpsn'),
    2 HPSN        CHAR  (9) INIT(' '),
    2 *           CHAR (13) INIT('  rempo'),
    2 REMPO       CHAR  (7) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (10) INIT(' fpsn'),
    2 FPSN        CHAR  (9) INIT(' '),
    2 *           CHAR (10) INIT('  rempdisc'),
    2 REMPDISC    CHAR (10) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (11) INIT(' faccn'),
    2 FACCN       CHAR  (8) INIT(' '),
    2 *           CHAR (10) INIT('  remtdisc'),
    2 REMTDISC    CHAR (10) INIT(' '),
    2 *           CHAR(121) INIT(' '),
    2 *           CHAR (15) INIT(' state'),
    2 STATE       CHAR  (4) INIT(' '),
    2 *           CHAR (17) INIT('  stepcc'),
    2 STEPCC      CHAR  (3) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (12) INIT(' steps'),
    2 STEPS       CHAR  (7) INIT(' '),
    2 *           CHAR (14) INIT('  enqs'),
    2 ENQS        CHAR  (6) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (12) INIT(' inter'),
    2 INTER       CHAR  (7) INIT(' '),
    2 *           CHAR  (8) INIT('  pmmes'),
    2 PMMES       CHAR (12) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR  (9) INIT(' disc i/o'),
    2 DISCIO      CHAR (10) INIT(' '),
    2 *           CHAR (10) INIT('  tape i/o'),
    2 TAPEIO      CHAR (10) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR  (8) INIT(' pextm'),
    2 PEXTM       CHAR (11) INIT(' '),
    2 *           CHAR  (9) INIT('  uextm'),
    2 UEXTM       CHAR (11) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR  (8) INIT(' psvtm'),
    2 PSVTM       CHAR (11) INIT(' '),
    2 *           CHAR  (9) INIT('  usvtm'),
    2 USVTM       CHAR (11) INIT(' '),
    2 *           CHAR (41) INIT(' '),
    2 *           CHAR (12) INIT(' pcros'),
    2 PCROS       CHAR  (6) INIT(' '),
    2 *           CHAR (14) INIT('k  pcc'),
    2 PCC         CHAR  (6) INIT(' '),
    2 *           CHAR (42) INIT('k'),
    2 *           CHAR (12) INIT(' pcp'),
    2 PCP         CHAR  (6) INIT(' '),
    2 *           CHAR (14) INIT('k  pcd'),
    2 PCD         CHAR  (6) INIT(' '),
    2 *           CHAR (42) INIT('k'),
    2 *           CHAR (12) INIT(' pcdd'),
    2 PCDD        CHAR  (6) INIT(' '),
    2 *           CHAR (14) INIT('k  pcds'),
    2 PCDS        CHAR  (6) INIT(' '),
    2 *           CHAR (42) INIT('k'),
    2 *           CHAR (12) INIT(' jpeak'),
    2 JPEAK       CHAR  (6) INIT(' '),
    2 *           CHAR (14) INIT('k  speak'),
    2 SPEAK       CHAR  (6) INIT(' '),
    2 *           CHAR (42) INIT('k'),
    2 *           CHAR (80) INIT(' '),
    2 *           CHAR (16) INIT(' users  b   o'),
    2 *           CHAR (18) INIT('t   g    memory'),
    2 *           CHAR (18) INIT('b     o     t'),
    2 *           CHAR (17) INIT('g   avail  etmf'),
    2 TIME2       CHAR  (5) INIT(' '),
    2 *           CHAR  (2) INIT(' '),
    2 DAY         CHAR  (3) INIT(' '),
    2 LC (0:2) REDEF DAY BIT (9),
    2 *           CHAR  (3) INIT(' '),
    2 USERS       CHAR  (3) INIT(' '),
    2 *           CHAR  (1) INIT(' '),
    2 BUSERS      CHAR  (3) INIT(' '),
    2 *           CHAR  (1) INIT(' '),
    2 OUSERS      CHAR  (3) INIT(' '),
    2 *           CHAR  (1) INIT(' '),
    2 TUSERS      CHAR  (3) INIT(' '),
    2 *           CHAR  (1) INIT(' '),
    2 GUSERS      CHAR  (3) INIT(' '),
    2 *           CHAR  (3) INIT(' '),
    2 MEMORY      CHAR  (5) INIT(' '),
    2 *           CHAR  (1) INIT('k'),
    2 BMEM        CHAR  (5) INIT(' '),
    2 *           CHAR  (1) INIT('k'),
    2 OMEM        CHAR  (5) INIT(' '),
    2 *           CHAR  (1) INIT('k'),
    2 TMEM        CHAR  (5) INIT(' '),
    2 *           CHAR  (1) INIT('k'),
    2 GMEM        CHAR  (5) INIT(' '),
    2 *           CHAR  (3) INIT('k'),
    2 AVAIL       CHAR  (5) INIT(' '),
    2 *           CHAR  (2) INIT('k'),
    2 ETMF        CHAR  (3) INIT(' '),
    2 *           CHAR  (3) INIT(' '),
    2 DATE2       CHAR (10) INIT(' '),
    2 LC2 (0:9) REDEF DATE2 BIT (9),
    2 *           CHAR  (1) INIT(' ');
DCL 1 SCRM REDEF SCRS,
    2 *           CHAR (80),
    2 USER (0:39) CHAR (40),
    2 *           CHAR(240);
DCL 1 PP REDEF SCRS,
    2 *           CHAR(160),
    2 RIV (0:17),
    3 *           CHAR (41),
    3 ONE         CHAR (8),
    3 *           CHAR (1),
    3 TWO         CHAR (8),
    3 *           CHAR (22),
    2 *           CHAR(320);
DCL 1 P REDEF SCRS,
    2 *           CHAR(160),
    2 RIV (0:17),
    3 *           CHAR (61),
    3 ONE         CHAR (8),
    3 *           CHAR (1),
    3 TWO         CHAR (8),
    3 *           CHAR (2),
    2 *           CHAR(320);
DCL 1 TOTALS  REDEF SCRS,
    2 UPPER       CHAR (1680),
    2 LOWER       CHAR(240);
DCL TTYS (0:23) REDEF SCRS CHAR (80);
 
DCL TTY_BUF CHAR (80) STATIC INIT(' ');
DCL TTYR (0:1) REDEF TTY_BUF CHAR (40);
 
DCL 1 LINE STATIC,
    2 ACCT      CHAR (8) INIT(' '),
    2 SYSID     CHAR (6) INIT(' '),
    2 MODE      CHAR (1) INIT(' '),
    2 *         CHAR (1) INIT(' '),
    2 STATE     CHAR (4) INIT(' '),
    2 SIZE      CHAR (4) INIT(' '),
    2 *         CHAR (1) INIT('k'),
    2 TIME      CHAR (6) INIT(' '),
    2 *         CHAR (1) INIT(' '),
    2 PROGRAM   CHAR (7) INIT(' '),
    2 BAR       CHAR (1) INIT('|');
DCL LINER REDEF LINE CHAR (40);
 
DCL 1 HEAD CONSTANT,
    2 * CHAR (40) INIT(' account sysid state size  time program|'),
    2 * CHAR (40) INIT(' account sysid state size  time program ');
DCL HEADER REDEF HEAD CHAR (80);
 
DCL PRIV_STUFF (0:35) CHAR (8) CONSTANT INIT(
 'fmeft','fmblk','fmsec','fmdiag','fmread','mode','sysacct','domain',
 'bit-08','bit-09','bit-10','bit-11','snap','screech','dispjob',
 'gjob','syscon','asave','gpp','bit-19','syslog','mfep','cfep',
 'cq','intcon','ioqw','ioq','expm','pm','tnd','jit','bit-31',
 'msys','maxmem','exmm','spclmm');
 
DCL PPRIV_STUFF (0:35) CHAR (8) CONSTANT INIT(
 'cntrld','cntrlc','eft','elan','label','pigd','pigc','spiderd',
 'spiderc','super','netcon','superath','superwsn','superfrm',
 'padmin','superd','volinit','replay','rates','syscon','pigette',
 'bit-21','bit-22','bit-23','bit-24','bit-25','bit-26','bit-27',
 'bit-28','bit-29','bit-30','bit-31','bit-32','bit-33','bit-34',
 'bit-35');
 
DCL SPEEDS (0:15) CHAR (5) CONSTANT INIT(
 '   50','   75','  110','  134','  150','  200','  300','  600',
 ' 1050',' 1200',' 1800',' 2000',' 2400',' 4800',' 9600','19200');
 
%VLR_MONPTRS  ( FPTN=MONPTRS );
%VLR_MONINFO  ( FPTN=MEMRY );
%VLR_DISPLAY  ( FPTN=DI );
 
%FPT_MONINFO  ( FPTN=GET_USER_TABLE, MONPTRS=MONPTRS );
%FPT_MONINFO  ( FPTN=GET_MEMRY, MONINFO=MEMRY );
%FPT_DISPLAY  ( FPTN=DIUSERS, RESULTS=DI );
%FPT_PRIV     ( FPTN=SET_PRIV, AUTH=YES, PRIV=%PR_SPCLMM# );
%FPT_WRITE    ( FPTN=NOPRIV, DCB=M$UC, BUF=NOT_ENUF_PRIV );
%FPT_WRITE    ( FPTN=TTY, DCB=M$LO, BUF=TTY_BUF );
%FPT_WAIT     ( FPTN=INT, UNITS=1 );
%FPT_TIME     ( FPTN=LOGONTIME, SOURCE=UTS, DEST=LOCAL, TIME=TIME,
                DATE=SCRS.DATE, TSTAMP=UTS );
%FPT_TIME     ( FPTN=CURRENT, SOURCE=CLOCK, DEST=EXT, TIME=TIME,
                DATE=SCRS.DATE2, DAY=SCRS.DAY );
%FPT_INT      ( FPTN=BREAK_EXITS, UENTRY=BREAKER );
%FPT_EOM      (FPTN=NOW,DCB=M$UC,TIMEOUT=1,UTYPE=MIL10);
 
 
/*----------------------------------------------------------------
   First we will attempt to make SPCLMM priv active. Failing this
   we will attempt to make EXMM priv active. If this fails, we
   tell the user why we are exiting and do so. Otherwise goforit.
 ----------------------------------------------------------------*/
 
   CALL M$SPRIV ( SET_PRIV )
      WHENALTRETURN DO;
         SET_PRIV.V.PRIV# = %PR_EXMM#;
         CALL M$SPRIV ( SET_PRIV )
            WHENALTRETURN DO;
               CALL M$WRITE ( NOPRIV );
               CALL M$EXIT;
            END;
      END;
 
 
   M$LM$ = DCBADDR(DCBNUM(M$LM));           /* For finding RUname */
   MYACCT = B$JIT$->B$JIT.SYSID;
 
   CCARS = B$JIT.CCARS;                     /* Parse the ccbuf    */
 
   CALL XUR$GETCMD ( INVOKE, PCB$,, B$JIT.CCBUF, CCARS, )
      WHENALTRETURN DO;
         CALL XUR$ERRPTR ( ,DCBNUM(M$UC) ) WHENALTRETURN DO; END;
         CALL XUR$ERRMSG ( PCB$ ) WHENALTRETURN DO; END;
         CALL M$EXIT;
      END;
 
/*----------------------------------------------------------------
   If we got here, the options specified in the ccbuf are ok.
   So, lets pick up the various options specified.
 ----------------------------------------------------------------*/
 
   EXIT_NEXT = no;
   INT_SPECD = no;
   ACCT_PICKD = no;
   NAME_PICKD = no;
   THIS_ACCT = yes;
   THIS_NAME = yes;
   WILD_ACCT = no;
   WILD_NAME = no;
   SCROLL = no;
   FINISHED = no;
   MULTI_USER = yes;
   MULTI_TTY = no;
   GO_BACK_TO_SCREEN_MODE = no ;
   NONE_SELECTED = yes;
   PART_ON=NO;
   USERU = 0;
   USER = 0;
   FEP = 0;
   HEIGHT = 0;
   COUNT = 34359738367; /* Highest sbin value */
   JUST_MEM = no;
 
   DO I=0 TO PCB$->OUT$BLK.NSUBLKS - 1;
 
      PTR$ = PCB$->OUT$BLK.SUBLK$(I);
      DO CASE (PTR$->OUT$BLK.CODE);
 
         CASE (N_DOLLARS#);
            NAMES=yes;
 
         CASE (N_PART#);
            PARTITION=yes;
 
         CASE (N_ACCTNOT#);
            THIS_ACCT=no;
 
         CASE (N_NAMENOT#);
            THIS_NAME=no;
 
         CASE (N_SYSID#);
            S6 = PTR$->OUT$SYM.TEXT;
            CALL CHARBIN (USERU, SUBSTR(S6,0,PTR$->OUT$SYM.COUNT));
            USER=USERU;
            IF USER = 0 THEN EXIT_NEXT = yes;
            ELSE MULTI_USER = no;
 
         CASE (N_USER#);
            U4 = PTR$->OUT$SYM.TEXT;
            DO X=0 TO PTR$->OUT$SYM.COUNT-1;
               USERU = USERU * 8 + ASCBIN( SUBSTR( U4, X, 1)) - 48;
            END;
            USER = -USERU;
            IF USER = 0 THEN EXIT_NEXT = yes;
            ELSE MULTI_USER = no;
 
         CASE (N_LASTBATCH#);
            USER = B$JIT$->B$JIT.LBJID;
            IF USER=0 THEN EXIT_NEXT = yes;
            ELSE MULTI_USER = no;
 
         CASE (N_INTERVAL#);
            CALL CHARBIN (UNITS#, PTR$->OUT$SYM.TEXT);
            INT_SPECD = yes;
 
         CASE (N_COUNT#);
            CALL CHARBIN (X, PTR$->OUT$SYM.TEXT);
            COUNT=X;
            INT_SPECD = yes;
 
         CASE (N_BATCH#);
            MODES_SELECTED(%M_BATCH#) = yes;
            NONE_SELECTED = no;
 
         CASE (N_ONLINE#);
            MODES_SELECTED(%M_INT#) = yes;
            NONE_SELECTED = no;
 
         CASE (N_TP#);
            MODES_SELECTED(%M_TP#) = yes;
            NONE_SELECTED = no;
 
         CASE (N_GHOST#);
            MODES_SELECTED(%M_GHOST#) = yes;
            NONE_SELECTED = no;
 
         CASE (N_MEM#);    /* Bottom two lines and exit */
            EXIT_NEXT = yes;
            SCROLL = yes;
            JUST_MEM = yes;
            MULTI_TTY = yes;
 
         CASE (N_FEP#);
            CALL CHARBIN (FEP, PTR$->OUT$SYM.TEXT);
            MODES_R = FEP_MODES;
            NONE_SELECTED = no;
 
         CASE (N_EXIT#);
            EXIT_NEXT = yes;
 
         CASE (N_ACCT#);
            ACCT = PTR$->OUT$SYM.TEXT;
            ACCT_PICKD = yes;
            CALL INDEX (X, '?', ACCT)
               WHENRETURN DO;
                  WILD_ACCT = yes;
               END;
               WHENALTRETURN DO;
               END;
 
         CASE (N_NAME#);
            NAME = PTR$->OUT$SYM.TEXT;
            NAME_PICKD = yes;
            CALL INDEX (X, '?', NAME)
               WHENRETURN DO;
                  WILD_NAME = yes;
               END;
               WHENALTRETURN DO;
               END;
 
         CASE (N_ROLL#);
            SCROLL = yes;
            MULTI_TTY = yes;
 
         CASE (ELSE);
            EXIT_NEXT = yes;
 
      END; /* Do case */
 
   END; /* Do I=0 to.. */
 
   IF NONE_SELECTED THEN MODES_R = DEFAULT;
   IF JUST_MEM THEN DO;
      MULTI_USER = yes;
      MODES_R = 0;      /* Dont select anybody */
   END;
 
/*----------------------------------------------------------------
   Next, get memory size and a PTR to the user tables.     Then
   initialize the "screen". If the dimensions of the output device
   are not suitable, we will write the output line by line and
   exit after one full display, so check that out.
 ----------------------------------------------------------------*/
 
   CALL DAM$INIT;
   CALL M$MONINFO ( GET_USER_TABLE );
   CALL DAM$MAP ( MONPTRS.B$USRT$, USERT$ );
 
   IF NOT(SCROLL) THEN DO;
      IF B$JIT$->B$JIT.MODE = %M_INT# THEN CALL SCREENIN (WIDTH, HEIGHT);
      IF (HEIGHT = 0) THEN DO;
         SCROLL = yes;
         IF NOT(INT_SPECD) THEN EXIT_NEXT = yes;
         MULTI_TTY = yes;
      END;
   END;
   CALL M$EOM (NOW);
   CALL M$INT (BREAK_EXITS);
   IF BREAK_HIT THEN FINISHED = yes;
 
/*----------------------------------------------------------------
   Loop until some exit condition is met, displaying information
   according to input specification/defaults.
 ----------------------------------------------------------------*/
 
   DO WHILE NOT (FINISHED);
      MEM = MEM$INIT;
      CALL M$MONINFO (GET_MEMRY);
      MEM.AVAIL = MEMRY.ACORE#;
      CALL M$DISPLAY ( DIUSERS );
      IF MULTI_USER THEN CALL MULTI_USER_INIT;
 
      DO I=1 TO DA_MUAIS;
         CALL DAM$MAP ( B$JIT$, JIT$, -I, 0 )
            WHENRETURN DO;
               MODE = JIT$->B$JIT.MODE;
               MEM.BY_MODE(MODE) = MEM.BY_MODE(MODE) + USERT$->B$USER.PCT(I);
               IF MULTI_USER THEN CALL MULTI_USER_FORMAT;
            END;
            WHENALTRETURN DO; END;
      END;
 
      DO MODE=1 TO 4;
        MEM.IN_USE = MEM.IN_USE + MEM.BY_MODE(MODE);
      END;
      CALL UPDATE_TOTALS;
 
      IF MULTI_USER THEN CALL MULTI_USER_DISPLAY;
      ELSE CALL SINGLE_USER_DISPLAY;
 
      COUNT = COUNT - 1;
      IF (COUNT < 1) OR (EXIT_NEXT) OR (BREAK_HIT) THEN FINISHED = yes;
      ELSE DO;
         IF NOT(MULTI_TTY) THEN DO;
            CALL CURSOR (0,0);
            CALL CRTFLSHX;
         END;
         CALL MAY_END WHENALTRETURN DO; FINISHED=yes; END;
         Z=0;
         DO WHILE (Z<UNITS#)AND(NOT(FINISHED))AND(NOT(BREAK_HIT));
            CALL M$WAIT(INT);
            CALL MAY_END WHENALTRETURN DO; FINISHED=yes; END;
            Z=Z+1;
         END;
      END;
   END;
 
   IF MULTI_TTY THEN CALL M$EXIT;
 
   CALL SCREECH;
 
/*---------------------------------------------------------------*/
/* AND THATS ALL FOLKS...                                        */
/*                                     ... for the most part...  */
/*---------------------------------------------------------------*/
 
SINGLE_USER_DISPLAY: PROC;
 
/* Now we will get the user that we are monitoring and format    */
/* the info into our screen. Note that if we have a tty type     */
/* terminal, we output the screen 80 char line by line.          */
 
   START = 0; /* Initially, we intend to print all lines for TTY */
 
   CALL DAM$MAP ( B$JIT$, JIT$, USER, 0 )
      WHENRETURN DO;
         I = JIT$->B$JIT.USER;
         CALL SINGLE_USER_FORMAT;
      END;
      WHENALTRETURN DO;
         TOTALS.UPPER = ' ';     /* Blank out all except totals */
         START = 22;           /* Dont print blank lines for TTY */
         EXIT_NEXT=yes; /* The monitored user is not there, so... */
      END;
 
   IF SCROLL THEN
         DO X = START TO 23;
            TTY.BUF_ = VECTOR (TTYS(X));
            CALL M$WRITE (TTY);
         END;
   ELSE CALL SCREENUP (SCRS);
 
   RETURN;
 
END SINGLE_USER_DISPLAY;
 
/*---------------------------------------------------------------*/
 
SINGLE_USER_FORMAT: PROC;
 
/* This routine formats the information into the single user type */
/* display screen.                                                */
 
   MODE = JIT$->B$JIT.MODE;
   SCRS.MODE = MODES_SUD (MODE);
   SCRS.CCBUF = JIT$->B$JIT.CCBUF;
   UNUM9 = I;
   DO X=0 TO 2;
      OCTCHAR (X) = OCTDIG(UNUM3(X));
   END;
   CALL EDITSTR (SCRS.USER#, 0, 4, OCTMOP, OCTEDIT);
 
   UTS = JIT$->B$JIT.LOGONTIME;
   CALL M$TIME (LOGONTIME);
   SCRS.TIME = TIME;
   UWORD = JIT$->B$JIT.SYSID;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.SYSID, 0, 6, UMOP6, U6);
 
   DO CASE (MODE);
      CASE (%M_BATCH#);
         SCRS.LINEORPART = 'partition#';
         UWORD = JIT$->B$JIT.PNR + 1;
         CALL BINCHAR (U4, UWORD);
         CALL EDITSTR (SCRS.LINE, 0, 4, UMOP4, U4);
 
      CASE (%M_INT#, %M_TP#);
         SCRS.LINEORPART = 'line#';
         SCRS.SPEED2 = 'speed';
         UWORD = JIT$->B$JIT.TSLINE.FEX;
         IF UWORD ~= 0 THEN DO;
            CALL BINCHAR (U2, UWORD);
            CALL EDITSTR (SCRS.FEP, 0, 2, UMOP2, U2);
            IF USERT$->B$USER.FLG(I) & %U_SUSP THEN SCRS.DASH='*';
            ELSE SCRS.DASH = '-';
            UNUM16 = JIT$->B$JIT.TSLINE.PORT;
            DO X=0 TO 3;
               HEXCHAR (X) = HEXDIG (UNUM4 (X));
            END;
            SCRS.LINE = HEXEDIT;
            SCRS.SPEED = SPEEDS (JIT$->B$JIT.TSLINE.SPEED);
         END;
 
      CASE (%M_GHOST#, ELSE);
 
   END; /* Do case */
 
   CALL RIGHT (ADDR(SCRS.ACCN), 8, ADDR(JIT$->B$JIT.ACCN), 8);
   CALL RIGHT (ADDR(SCRS.UNAME), 12, ADDR(JIT$->B$JIT.UNAME), 12);
   CALL TIME_CNVRT (SCRS.REMTIME, USERT$->B$USER.MRT(I) );
   CALL RIGHT (ADDR(SCRS.JNAME), 12, ADDR(JIT$->B$JIT.JOBNAME), 12);
 
   SWORD = JIT$->B$JIT.REMLO;
   CALL BINXCHAR (S7, SWORD);
   CALL EDITXCHAR (SCRS.REMLO, 0, 7, SIGNED_MOPS7, S7);
 
   WSN@.WOO = JIT$->B$JIT.WOO;
   CALL RIGHT (ADDR(SCRS.WOO), 9, ADDR(WSN@), 9);
 
   SWORD = JIT$->B$JIT.REMDO;
   CALL BINXCHAR (S7, SWORD);
   CALL EDITXCHAR (SCRS.REMDO, 0, 7, SIGNED_MOPS7, S7);
 
   DP#.PAC = JIT$->B$JIT.HPSN;
   CALL RIGHT (ADDR(SCRS.HPSN), 9, ADDR(DP#), 9);
 
   SWORD = JIT$-> B$JIT.REMCPO;
   CALL BINXCHAR (S7, SWORD);
   CALL EDITXCHAR (SCRS.REMPO, 0, 7, SIGNED_MOPS7, S7);
 
   IF JIT$->B$JIT.FPSN = ' ' THEN SCRS.FPSN = ' ';
   ELSE DO;
      DP#.PAC = JIT$->B$JIT.FPSN;
      CALL RIGHT (ADDR(SCRS.FPSN), 9, ADDR(DP#), 9);
   END;
 
   CALL BINXCHAR (S10, JIT$->B$JIT.PRDPRM);
   CALL EDITXCHAR (SCRS.REMPDISC, 0, 10, SIGNED_MOPS10, S10);
 
   CALL RIGHT(ADDR(SCRS.FACCN),8,ADDR(JIT$->B$JIT.FACCN),8);
 
   SWORD = JIT$->B$JIT.MAXTMPDP - JIT$->B$JIT.CURTMPDP;
   CALL BINXCHAR (S10, SWORD);
   CALL EDITXCHAR(SCRS.REMTDISC,0,10,SIGNED_MOPS10,S10);
 
   CALL RIGHT (ADDR(SCRS.STATE), 4, ADDR( STATES (USERT$->B$USER.US(I))), 4);
   IF  SCRS.STATE = ' SQR' THEN
       CALL RIGHT ( ADDR(SCRS.STATE),4,ADDR(STATES ( USERT$ -> B$USER.SQ(I) ) ),4);
 
   UWORD = JIT$->B$JIT.STEPCC;
   CALL BINCHAR (U3, UWORD);
   CALL EDITSTR (SCRS.STEPCC, 0, 3, UMOP3, U3);
 
   SWORD = JIT$->B$JIT.STEPS;
   CALL BINXCHAR (S7, SWORD);
   CALL EDITXCHAR (SCRS.STEPS, 0, 7, SIGNED_MOPS7, S7);
 
   UWORD = JIT$->B$JIT.ENQS;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.ENQS, 0, 6, UMOP6, U6);
 
   SWORD = JIT$->B$JIT.INTER;
   CALL BINXCHAR (S7, SWORD);
   CALL EDITXCHAR (SCRS.INTER, 0, 7, SIGNED_MOPS7, S7);
 
   CALL BINXCHAR (S12, JIT$->B$JIT.CALCNT);
   CALL EDITXCHAR (SCRS.PMMES, 0, 12, SIGNED_MOPS12, S12);
 
   CALL BINXCHAR (S10, JIT$->B$JIT.ACCESS.PACKS);
   CALL EDITXCHAR (SCRS.DISCIO, 0, 10, SIGNED_MOPS10, S10);
 
   CALL BINXCHAR (S10, JIT$->B$JIT.ACCESS.TAPES);
   CALL EDITXCHAR (SCRS.TAPEIO, 0, 10, SIGNED_MOPS10, S10);
 
   CALL TIME_CNVRT (SCRS.PEXTM, JIT$->B$JIT.TPEXT);
   CALL TIME_CNVRT (SCRS.UEXTM, JIT$->B$JIT.TUEXT);
   CALL TIME_CNVRT (SCRS.PSVTM, JIT$->B$JIT.TPSVT);
   CALL TIME_CNVRT (SCRS.USVTM, JIT$->B$JIT.TUSVT);
 
   UWORD = JIT$->B$JIT.PCROS;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCROS, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.PCC;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCC, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.PCP;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCP, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.PCD;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCD, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.PCDD;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCDD, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.PCDS;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.PCDS, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.JPEAK;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.JPEAK, 0, 6, UMOP6, U6);
 
   UWORD = JIT$->B$JIT.SPEAK;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (SCRS.SPEAK, 0, 6, UMOP6, U6);
 
   PRIVS = JIT$->B$JIT.PPRIV;
   H=0;
   DO X=0 TO 35;
      IF PRIV_ON (X) THEN DO;
         PPRIV$PTRS(H)->FRAME = PPRIV_STUFF(X);
         H=H+1;
      END;
   END;
   DO X=H TO 35;
      PPRIV$PTRS(X)->FRAME = ' ';
   END;
 
   PRIVS = JIT$->B$JIT.PRIV.ACTIVE;
   H=0;
   DO X=0 TO 35;
      IF PRIV_ON (X) THEN DO;
         PRIV$PTRS(H)->FRAME = PRIV_STUFF(X);
         H=H+1;
      END;
   END;
   DO X=H TO 35;
      PRIV$PTRS(X)->FRAME = ' ';
   END;
 
   RETURN;
 
END SINGLE_USER_FORMAT;
 
/*---------------------------------------------------------------*/
 
UPDATE_TOTALS: PROC;
 
/* Format the bottom two lines of both types of display.          */
 
   CALL BINCHAR (U3, DI.USERS);
   CALL EDITSTR (SCRS.USERS, 0, 3, UMOP3, U3);
 
   CALL BINCHAR (U3, DI.BUSERS);
   CALL EDITSTR (SCRS.BUSERS, 0, 3, UMOP3, U3);
 
   CALL BINCHAR (U3, DI.OUSERS);
   CALL EDITSTR (SCRS.OUSERS, 0, 3, UMOP3, U3);
 
   CALL BINCHAR (U3, DI.TPUSERS);
   CALL EDITSTR (SCRS.TUSERS, 0, 3, UMOP3, U3);
 
   CALL BINCHAR (U3, DI.GUSERS);
   CALL EDITSTR (SCRS.GUSERS, 0, 3, UMOP3, U3);
 
   CALL BINCHAR (U5, MEM.IN_USE);
   CALL EDITSTR (SCRS.MEMORY, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U5, MEM.BY_MODE(%M_BATCH#));
   CALL EDITSTR (SCRS.BMEM, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U5, MEM.BY_MODE(%M_INT#));
   CALL EDITSTR (SCRS.OMEM, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U5, MEM.BY_MODE(%M_TP#));
   CALL EDITSTR (SCRS.TMEM, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U5, MEM.BY_MODE(%M_GHOST#));
   CALL EDITSTR (SCRS.GMEM, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U5, MEM.AVAIL);
   CALL EDITSTR (SCRS.AVAIL, 0, 5, UMOP5, U5);
 
   CALL BINCHAR (U3, DI.ETMF);
   CALL EDITSTR (SCRS.ETMF, 0, 3, UMOP3, U3);
 
   CALL M$TIME (CURRENT);
   SCRS.TIME2 = TIME;
   SCRS.LC2(1) = SCRS.LC2(1) | LOWERCASE;
   SCRS.LC2(2) = SCRS.LC2(2) | LOWERCASE;
   SCRS.LC(1) = SCRS.LC(1) | LOWERCASE; /* Convert last two */
   SCRS.LC(2) = SCRS.LC(2) | LOWERCASE; /* chars to lower   */
                                   /* case. E.g. Tue */
 
   RETURN;
 
END UPDATE_TOTALS;
 
/*---------------------------------------------------------------*/
 
MULTI_USER_INIT: PROC;
 
/* This routine initializes flags and/or writes the header if the */
/* terminal is a tty type.                                        */
 
   TOTALS.UPPER = ' ';
   IF MULTI_TTY AND NOT(SCROLL) THEN GO_BACK_TO_SCREEN_MODE = yes;
 
   USER_COUNT = 0;
   EVEN = yes;
   IF PARTITION THEN
      IF PART_ON THEN PART_ON=no;
      ELSE PART_ON=yes;
 
   IF SCROLL THEN DO;
      TTY_BUF = HEADER;
      IF NOT(JUST_MEM) THEN CALL M$WRITE (TTY);
      END;
   ELSE DO;
      MULTI_TTY = no;
      TTYS(0) = HEADER;
   END;
 
   RETURN;
 
END MULTI_USER_INIT;
 
/*---------------------------------------------------------------*/
 
MULTI_USER_FORMAT: PROC;
 
/* This routine formats the information into a buffer and then    */
/* decides whether or not to write it.                            */
 
   IF NOT(MODES_SELECTED(MODE)) THEN RETURN; /* Not right kind user*/
   IF FEP~=0 THEN
      IF JIT$->B$JIT.TSLINE.FEX ~= FEP THEN RETURN;
 
   IF ACCT_PICKD THEN DO;
     IF THIS_ACCT THEN DO;
         IF WILD_ACCT THEN CALL COMPARE_ACCT (ACCT, JIT$->B$JIT.ACCN)
                         WHENALTRETURN DO;
                            RETURN;
                         END;
         ELSE IF ACCT ~= JIT$->B$JIT.ACCN THEN RETURN;
         END;
     ELSE DO;
         IF WILD_ACCT THEN CALL COMPARE_ACCT (ACCT, JIT$->B$JIT.ACCN)
                         WHENRETURN DO;
                            RETURN;
                         END;
                         WHENALTRETURN DO;
                         END;
         ELSE IF ACCT = JIT$->B$JIT.ACCN THEN RETURN;
      END;
   END;
 
   IF NAME_PICKD THEN DO;
      IF THIS_NAME THEN DO;
         IF WILD_NAME THEN CALL COMPARE_NAME (NAME, JIT$->B$JIT.UNAME)
                         WHENALTRETURN DO;
                            RETURN;
                         END;
         ELSE IF NAME ~= JIT$->B$JIT.UNAME THEN RETURN;
         END;
      ELSE DO;
         IF WILD_NAME THEN CALL COMPARE_NAME (NAME, JIT$->B$JIT.UNAME)
                         WHENRETURN DO;
                            RETURN;
                         END;
                         WHENALTRETURN DO;
                         END;
         ELSE IF NAME = JIT$->B$JIT.UNAME THEN RETURN;
      END;
   END;
 
   IF JIT$->B$JIT.SYSID = MYACCT THEN LINE.ACCT = '  [SELF]';
   ELSE IF NAMES THEN CALL RIGHT (ADDR(LINE.ACCT),8,ADDR(JIT$->B$JIT.UNAME),8);
   ELSE CALL RIGHT (ADDR(LINE.ACCT), 8, ADDR(JIT$->B$JIT.ACCN), 8);
 
   UWORD = JIT$->B$JIT.SYSID;
   CALL BINCHAR (U6, UWORD);
   CALL EDITSTR (LINE.SYSID, 0, 6, UMOP6, U6);
 
   IF USERT$->B$USER.FLG(I) & %U_SUSP THEN LINE.MODE = 's';
   ELSE LINE.MODE = MODES_MUD(MODE);
 
   IF (PARTITION)AND(JIT$->B$JIT.MODE=%M_BATCH#)AND(PART_ON) THEN DO;
      UWORD=JIT$->B$JIT.PNR+1;
      CALL BINCHAR (U2,UWORD);
      CALL EDITSTR (PART.ITION,0,2,UMOP2,U2);
      LINE.STATE=PARTR;
      END;
   ELSE
      CALL RIGHT (ADDR(LINE.STATE),4,ADDR(STATES(USERT$->B$USER.US(I))),4);
 
   UWORD = USERT$->B$USER.PCT(I);
   CALL BINCHAR (U4, UWORD);
   CALL EDITSTR (LINE.SIZE, 0, 4, UMOP4, U4);
 
   UTS = USERT$->B$USER.UTSUSED(I);
   CALL BINCHAR (TIMES.MM, UTS/6000);
   CALL BINCHAR (TIMES.SS, MOD(UTS,6000)/100);
   CALL EDITSTR (TIME2, 0, 7, TIME_MOP, TIMER.VAL);
   LINE.TIME = TIMEX.LEAST;
 
   IF JIT$->B$JIT.CPFLAGS1 & %CP_JSTEP# THEN LINE.PROGRAM = ' ';
   ELSE DO;
      BBUF = JIT$->B$JIT.CCBUF;
      CALL SEARCHR (R, TVAL, TABLE, BBUF);
      CALL SEARCH  (L, TVAL, TABLE, BBUF);
      IF TVAL = 0 THEN LINE.PROGRAM = ' ';
      ELSE DO;
         LEN = R-L+1;
         BBUF = SUBSTR (JIT$->B$JIT.CCBUF, L, LEN);
         CALL INDEX (X, ' ', SUBSTR(BBUF, 0, LEN))
            WHENRETURN DO;
               IF X < 6 THEN DO;
                  TEMPBUF = SUBSTR(BBUF, 0, X);
                  IF (TEMPBUF='S') OR (TEMPBUF='START')
                     OR (TEMPBUF='RUN') THEN
                        CALL DAM$MAP (M$LM$, U$LM$, -I, 0)
                           WHENRETURN DO;
                              BBUF = U$LM$->F$DCB.NAME#.C;
                           END;
                           WHENALTRETURN DO;
                              BBUF = ' ';
                           END;
                  ELSE BBUF = TEMPBUF;
                  END;
               ELSE BBUF = SUBSTR (BBUF, 0, LEN);
            END;
            WHENALTRETURN DO;
            END;
         CALL INDEX (X, '.', BBUF)
            WHENRETURN DO;
               LINE.PROGRAM = SUBSTR(BBUF, 0, X);
            END;
            WHENALTRETURN DO;
               LINE.PROGRAM = BBUF;
               DO X=0 TO 27;
                  IF LINE.PROGRAM = FAKE(X) THEN LINE.PROGRAM = REAL(X);
               END;
            END;
      END;
   END;
 
   IF EVEN THEN DO;
      LINE.BAR = '|';
      EVEN = no;
      IF MULTI_TTY THEN TTYR(0) = LINER;
      ELSE SCRM.USER (USER_COUNT) = LINER;
      END;
   ELSE DO;
      LINE.BAR = ' ';
      EVEN = yes;
      IF MULTI_TTY THEN DO;
         TTYR(1) = LINER;
         CALL M$WRITE (TTY);
         END;
      ELSE SCRM.USER (USER_COUNT) = LINER;
   END;
 
   USER_COUNT = USER_COUNT + 1;
   IF (NOT(MULTI_TTY))AND(USER_COUNT>39) THEN DO;
      MULTI_TTY = yes;
      IF NOT(SCROLL) THEN GO_BACK_TO_SCREEN_MODE = yes;
      DO X=0 TO 20;
         TTY_BUF = TTYS(X);
         CALL M$WRITE (TTY);
      END;
   END;
   RETURN;
 
END MULTI_USER_FORMAT;
 
/*---------------------------------------------------------------*/
 
MULTI_USER_DISPLAY: PROC;
 
/* This routine dumps the screen if not a TTY type terminal. IF it*/
/* is, it checks for unwritten info and then dumps the totals.    */
 
   IF MULTI_TTY THEN DO;
      IF NOT(EVEN) THEN DO;
         TTYR(1) = ' ';
         CALL M$WRITE (TTY);
      END;
      TTY_BUF = ' ';
      CALL M$WRITE (TTY);
      TTY_BUF = TTYS (22);
      CALL M$WRITE (TTY);
      TTY_BUF = TTYS (23);
      CALL M$WRITE (TTY);
      END;
   ELSE DO;
      IF GO_BACK_TO_SCREEN_MODE THEN DO;
         CALL SCREENIN;
         GO_BACK_TO_SCREEN_MODE=no;
      END;
      CALL SCREENUP (SCRM);
   END;
 
   RETURN;
 
END MULTI_USER_DISPLAY;
 
END WHOM;
    %EOD;
/*M* RIGHT - Procedure for WHOM.                                   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
RIGHT: PROC ( DEST$, DEST_LEN, SOURCE$, SOURCE_LEN );
 
DCL SOURCE$ PTR;
DCL DEST$ PTR;
DCL SOURCE_LEN UBIN;
DCL DEST_LEN UBIN;
 
DCL DEST CHAR (DEST_LEN) BASED (DEST$);
DCL SOURCE CHAR (SOURCE_LEN) BASED (SOURCE$);
DCL BLANKS CHAR (OFFSET) BASED (DEST$);
DCL MOVES CHAR (SLEN) BASED;
 
DCL R UBIN;
DCL L UBIN;
DCL OFFSET UBIN;
DCL SLEN UBIN;
DCL TVAL UBIN;
 
DCL 1 TABLEO CONSTANT WALIGNED,
    2 * (0:511) UBIN (9) UNAL INIT(1*32,0,1*479);
DCL TABLE REDEF TABLEO CHAR (512) CALIGNED;
 
   CALL SEARCHR (R, TVAL, TABLE, SOURCE);
   CALL SEARCH (L, TVAL, TABLE, SOURCE);
 
   IF TVAL = 0 THEN DO;
     DEST = ' ';
     RETURN;
   END;
 
   IF R >= DEST_LEN THEN DO;
      DEST = SOURCE;
      RETURN;
   END;
 
   SLEN = R-L+1;
   OFFSET = DEST_LEN - SLEN;
   PINCRC(DEST$,OFFSET)->MOVES = PINCRC(SOURCE$,L)->MOVES;
   DEST$->BLANKS = ' ';
 
   RETURN;
 
END RIGHT;
    %EOD;
/*M* TIME_CNVRT - Procedure for WHOM.                              */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
TIME_CNVRT: PROC (DEST, UTS);
 
/* This routine converts a time from milliseconds to */
/* a digital display. The result is in the format    */
/*   HHHH:MM:SS with a minimum display of 0:00.      */
/* The output is modulo 416 days, which is more than */
/* sufficient for  its use in this program.          */
 
%INCLUDE B_MICROPS_C;
 
DCL DEST CHAR (11);
DCL 1 TIME  STATIC,
    2 HH CHAR (4),
    2 MM CHAR (2),
    2 SS CHAR (2);
DCL TIMER REDEF TIME CHAR (8);
DCL UTS UBIN;
 
DCL 1 MOP CONSTANT,
    2 * BIT (9) INIT(%LTE6),
    2 * BIT (9) INIT(%ASCBIT(':')),
    2 * BIT (9) INIT(%LTE5),
    2 * BIT (9) INIT('040'O),
    2 * BIT (9) INIT(%MFLC4),
    2 * BIT (9) INIT(%INSB6),
    2 * BIT (9) INIT(%MFLC1),
    2 * BIT (9) INIT(%ENF10),
    2 * BIT (9) INIT(%MVC1),
    2 * BIT (9) INIT(%INSB6),
    2 * BIT (9) INIT(%MVC2);
DCL TIME_MOP REDEF MOP CHAR (11);
 
    CALL BINCHAR (TIME.HH,UTS/360000);
    CALL BINCHAR (TIME.MM,MOD(UTS,360000)/6000);
    CALL BINCHAR (TIME.SS,MOD(UTS,6000)/100);
    CALL EDITSTR (DEST,0,11,TIME_MOP,TIMER);
    RETURN;
 
END TIME_CNVRT;
    %EOD;
/*M* COMPARE_ACCT - Procedure for WHOM.                            */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
COMPARE_ACCT: PROC (WILD_ACCT, COMPARE_ACCT) ALTRET;
 
/*                                                                */
/* This routine checks an jit acct with a wildcarded input acct.  */
/* If they match we return, else we altreturn.                    */
/*                                                                */
 
DCL WILD_X      UBIN BYTE;
DCL WILD_XC REDEF WILD_X CHAR(4);
DCL WILD_XP     UBIN BYTE;
DCL WILD_ACCT   CHAR (8);
DCL COMPARE_ACCT  CHAR (8);
DCL COMPARE_X   UBIN BYTE;
DCL COMPARE_XP  UBIN BYTE;
%INCLUDE FM$FIT;
 
   %WILD_COMPARE(WILD_CHARS=WILD_ACCT, COMPARE_CHARS=COMPARE_ACCT,
                 WILD_MAX=8,           COMPARE_MAX=8,
                 NO_MATCH=ALTRETURN);
   RETURN;
 
END COMPARE_ACCT;
    %EOD;
/*M* COMPARE_NAME - Procedure for WHOM.                            */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
COMPARE_NAME: PROC (WILD_NAME, COMPARE_NAME) ALTRET;
 
/*                                                                */
/* This routine checks an jit name with a wildcarded input name.  */
/* If they match we return, else we altreturn.                    */
/*                                                                */
 
DCL WILD_X      UBIN BYTE;
DCL WILD_XC REDEF WILD_X CHAR(4);
DCL WILD_XP     UBIN BYTE;
DCL WILD_NAME   CHAR (12);
DCL COMPARE_NAME   CHAR (12);
DCL COMPARE_X   UBIN BYTE;
DCL COMPARE_XP  UBIN BYTE;
%INCLUDE FM$FIT;
 
   %WILD_COMPARE(WILD_CHARS=WILD_NAME, COMPARE_CHARS=COMPARE_NAME,
                 WILD_MAX=12,           COMPARE_MAX=12,
                 NO_MATCH=ALTRETURN);
   RETURN;
 
END COMPARE_NAME;
    %EOD;
/*M* BREAKER - Procedure for WHOM.                                 */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
BREAKER: PROC ASYNC;
 
/*                                                                */
/* This routine is entered when the online user hits break. All   */
/* that we do here is set a flag so that we will exit on the next */
/* iteration of the main loop.                                    */
/*                                                                */
 
%INCLUDE CP_6;
DCL BREAK_HIT BIT (1) SYMREF;
 
%SUB yes = "'1'B";
 
   BREAK_HIT = yes;
   CALL M$TRTN;
 
END BREAKER;
    %EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
 
/*M* MAY_END - Procedure for WHOM.                                 */
/*X* DFC=YES, DMC=YES, EDMC=YES                                    */
MAY_END: PROC  ALTRET;
 
%INCLUDE CP_6;
%FPT_READ (FPTN=RD,DCB=M$UC,BUF=BUF,TRANS=YES);
 
DCL BUF CHAR (1) STATIC;
DCL BUFR REDEF BUF BIT (9) UNAL;
 
    CALL M$READ(RD)
       WHENRETURN DO;
          BUFR=BUFR&'001011111'B;
          IF (BUF='E') OR (BUF='Q') OR (BUF='X') THEN ALTRETURN;
       END;
       WHENALTRETURN DO;
          RETURN;
       END;
 
END MAY_END;
