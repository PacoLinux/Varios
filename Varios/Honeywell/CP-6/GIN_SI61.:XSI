/*M* GIN_SI61 - PL6 main for GIN.X */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* CLM=0,EXM=0,DIN=1,PLM=4,IND=0,IAD=4,STI=4,DCI=4,DTI=0,ENI=4,ECI=0 */
GIN: PROC MAIN;
 
/* Macros */
%MACRO B$RU_KEY (NAME=B$RU_KEY,STCLASS=STATIC,
    TYPE=0,
    OFF=0);
 DCL 1 NAME STCLASS,
       2 * UBIN BYTE INIT(5) CALIGNED, /* Key length                          */
       2 TYPE# UBIN BYTE INIT(TYPE) CALIGNED, /* Key type                     */
       2 OFF# UBIN INIT(OFF) CALIGNED; /* Offset field                        */
%MEND;
 
%MACRO PATCH_HDR (NAME=PATCH_HDR,STCLASS=STATIC);
 DCL 1 NAME STCLASS,
       2 HP$                   PTR,
       2 HP REDEF HP$, /* HOST                                                */
         3 OFF                 UBIN HALF UNAL,
         3 *                   BIT(18),
       2 FP# REDEF HP$ UBIN, /* For FEP                                       */
       2 FP REDEF HP$, /* FEP                                                 */
         3 *                   BIT(4),
         3 ARY(0:3)            UBIN(8)   UNAL,
       2 OFF UBIN, /* UBIN value of addr offset                               */
       2 SIZE                  UBIN,
       2 SZE         REDEF SIZE,
         3 *                   BIT(20),
         3 H                   UBIN(8)   UNAL,
         3 L                   UBIN(8)   UNAL;
%MEND;
 
/* SUBs and EQUs */
%EQU TRUE='1'B;
%EQU FALSE='0'B;
%SUB NEVER = "WHILE ('0'B)";
%SUB FOREVER = "WHILE ('1'B)";
 
/* Includes */
%INCLUDE CP_6;
 %B$TCB;
 %B$ALT;
 %F$DCB(STCLASS="BASED(F$DCB$)");
 %FPT_GDS(STCLASS=STATIC,
    RESULTS=RESULT);
%FPT_FDS(STCLASS=STATIC,
    RESULTS=RESULT);
 %VLP_NAME(FPTN=SOURCEFID,
    LEN=60);
 %VLP_VECTOR(FPTN=RESULT);
 
/* Patch VLP's */
 %VLP_NAME(FPTN=B_PATCHDH,STCLASS=CONSTANT,
    NAME='B_PATCHDH');
 %VLP_NAME(FPTN=B_PATCHIH,STCLASS=CONSTANT,
    NAME='B_PATCHIH');
 %VLP_NAME(FPTN=B_PATCHD,STCLASS=CONSTANT,
    NAME='B_PATCHD');
 %VLP_NAME(FPTN=B_PATCHI,STCLASS=CONSTANT,
    NAME='B_PATCHI');
 %VLP_NAME(FPTN=G_PATCHDH,STCLASS=CONSTANT,
    NAME='G_PATCHDH');
 %VLP_NAME(FPTN=G_PATCHIH,STCLASS=CONSTANT,
    NAME='G_PATCHIH');
 %VLP_NAME(FPTN=G_PATCHD,STCLASS=CONSTANT,
    NAME='G_PATCHD');
 %VLP_NAME(FPTN=G_PATCHI,STCLASS=CONSTANT,
    NAME='G_PATCHI');
 %VLP_NAME(FPTN=PATCHDH,
    L=9);
 %VLP_NAME(FPTN=PATCHIH,
    L=9);
 %VLP_NAME(FPTN=PATCHI,
    L=8);
 %VLP_NAME(FPTN=PATCHD,
    L=8);
%INCLUDE B$JIT;
%INCLUDE B$OBJECT_C;
 %RU_FLAVORS;
 %B$RECORDSUBS;
 %SUB_LINKFLAGS;
 %B$SDEF;
 %B$RU_DEF(STCLASS=BASED);
 %B$RUHEADKEY(STCLASS=CONSTANT);
 %B$HEAD(NAME=DA_HEADREC,STCLASS=SYMREF);
 %B$RU_KEY(NAME=SYMDEF_KEY,STCLASS=CONSTANT,
    TYPE=%TYPSDEF);
 %B$RU_KEY(NAME=ENTDEF_KEY,STCLASS=CONSTANT,
    TYPE=%TYPEDEF);
 %B$RU_KEY(NAME=RU_KEY,
    TYPE=%TYPPROG);
%INCLUDE XU_MACRO_C;
 %PARSE$OUT(NAME=OUT$BLK,STCLASS=BASED);
 %PARSE$SYM(NAME=OUT$SYM,STCLASS=BASED);
 %XUG_INIT(NAME=XUG_INIT,STCLASS=STATIC,
    WSEG=0);
 %XUG_GETCMD(NAME=XUG_GETCMD,STCLASS=STATIC SYMDEF,
    ERRMFID=ERRMFID,
    PROMPT=PROMPT);
%INCLUDE XUG_ENTRY;
%INCLUDE XU_PERR_C;
%INCLUDE CP_6_SUBS;
%INCLUDE B_ERRORS_C;
%INCLUDE GIN_C61;
 
/* DCL's */
 DCL M$LM DCB;
 DCL M$SI DCB;
 DCL M$RU DCB;
 DCL M$LO DCB;
 DCL B$JIT$ PTR SYMREF;
 DCL B$TCB$ PTR SYMREF;
 DCL GI_CMDS_WITH UBIN SYMREF;
 DCL GI_CMDS_WITHOUT UBIN SYMREF;
 DCL SLIDE ENTRY(3);
 DCL ERRMSG ENTRY(3);
 DCL ERRPTR ENTRY(3);
 DCL CONVERT ENTRY(2);
 
 DCL GI_FLAVOR UBIN;
 DCL FLAVOR_OPTION BIT(1) STATIC INIT(%FALSE);
 DCL DI_ONLY BIT(1) STATIC INIT(%FALSE);
 
 DCL PROMPT CHAR(0) INIT('hic>') CONSTANT;
 DCL F$DCB$ PTR;
 DCL M$LM$ PTR STATIC;
 DCL M$RU$ PTR STATIC;
 DCL BLK$ PTR STATIC;
 DCL B$ROS$ PTR STATIC INIT(ADDR(NIL));
 DCL DCB$(0:0) PTR BASED(B$ROS$);
 DCL DCBWORD(0:0) UBIN BASED(B$ROS$);
 DCL B$SEGDEF$ PTR STATIC INIT(ADDR(NIL));
 DCL 1 ERRMFID STATIC ALIGNED,
       2 L UBIN(9) CALIGNED,
       2 C CHAR(40) CALIGNED;
 DCL 1 B$PRIVS BASED ALIGNED,
       2 BITS(0:0) BIT(1) UNAL;
 DCL I UBIN;
 
/* ESP variables */
 DCL 1 RUREC STATIC,
       2 BUF CHAR(4096),
       2 PARY$(0:1023) REDEF BUF PTR,
       2 HARY(0:1023) REDEF BUF UBIN, /* HOST                                 */
       2 FARY(0:2047) REDEF BUF, /* FEP                                       */
         3 * BIT(1),
         3 H UBIN(8) UNAL,
         3 * BIT(1),
         3 L UBIN(8) UNAL;
 DCL RUREC_ VECTOR CONSTANT INIT(VECTOR(RUREC));
 DCL RUREC_ARS UBIN;
 DCL RUPAGLEN SBIN;
 DCL RURECLEN SBIN;
 DCL RUSEGLEN SBIN;
 DCL DAS$SYMINIT  ENTRY(2) ALTRET;
 DCL DAS$SDSRCH   ENTRY(2) ALTRET;
 DCL DAS$EDSRCH   ENTRY(2) ALTRET;
 DCL DAS$SDSRCHPTR ENTRY(2) ALTRET;
 DCL DAS$EDSRCHPTR ENTRY(2) ALTRET;
 DCL DA_DNAME$ PTR  SYMREF;
 DCL DA_ENTDEF$ PTR SYMREF;
 DCL DA_SYMDEF$ PTR SYMREF;
 DCL DA_MSCPG3 SBIN CONSTANT SYMDEF; /* For DAS PREF                          */
 DCL DA_ENTDEF_ VECTOR STATIC INIT(VECTOR(NIL));
 DCL DA_SYMDEF_ VECTOR STATIC INIT(VECTOR(NIL));
 DCL DA_SYMERR UBIN SYMREF;
 DCL IPH$ PTR;
 DCL DPH$ PTR;
 DCL DBSE SBIN;
 DCL IBOUND UBIN;
 DCL MEM_LIMIT UBIN;
 DCL SHARE_LIB_START UBIN;
%PATCH_HDR(NAME=IPATCHDR);
%PATCH_HDR(NAME=DPATCHDR);
 
%EJECT;
/*       Get error messages from run unit */
    CALL XUG$INIT(XUG_GETCMD,XUG_INIT) ALTRET(E_XUG);
    M$LM$=DCBADDR(DCBNUM(M$LM));
    CALL CONCAT(ERRMFID.C,
      SUBSTR(M$LM$->F$DCB.NAME#.C,0,M$LM$->F$DCB.NAME#.L),
      '.',
      M$LM$->F$DCB.ACCT#);
    CALL INDEX(I,' ',ERRMFID.C);
    ERRMFID.L=I;
    CALL XUG$SETERRMSG(XUG_GETCMD) ALTRET(E_XUG);
/*       Make sure user specified a file to be GINed */
    IF NOT B$JIT.PRFLAGS.SI THEN DO;
        CALL ERRMSG(%E$NO_RU);
/*E*
ERROR:  GI-E$NO_RU-0
MESSAGE:GIN what?  No source fid specified.
*/
        GOTO ALT;
        END;
/*       Get source fid for DAS$SYMBOL routines */
    M$RU$=DCBADDR(DCBNUM(M$RU));
    IF M$RU$->F$DCB.PSN# ~= ' ' THEN DO;
        CALL INSERT(SOURCEFID.NAME#,0,,'DP#',M$RU$->F$DCB.PSN#);
        CALL INDEX(I,' ',SOURCEFID.NAME#);
        SUBSTR(SOURCEFID.NAME#,I,1) = '/';
        I = I + 1;
        END;
    ELSE IF B$JIT.FPSN ~= ' ' AND M$RU$->F$DCB.ACCT# = ' ' THEN DO;
            CALL INSERT(SOURCEFID.NAME#,0,,'DP#',B$JIT.FPSN);
            CALL INDEX(I,' ',SOURCEFID.NAME#);
            SUBSTR(SOURCEFID.NAME#,I,1) = '/';
            I = I + 1;
            END;
        ELSE
            I = 0;
    SUBSTR(SOURCEFID.NAME#,I)=SUBSTR(M$RU$->F$DCB.NAME#.C,0,
      M$RU$->F$DCB.NAME#.L);
    I=I + M$RU$->F$DCB.NAME#.L;
    IF M$RU$->F$DCB.ACCT# = ' ' THEN
        CALL INSERT(SOURCEFID.NAME#,I,,'.',B$JIT.FACCN);
    ELSE
        CALL INSERT(SOURCEFID.NAME#,I,,'.',M$RU$->F$DCB.ACCT#);
    CALL INDEX(I,' ',SOURCEFID.NAME#);
    CALL INSERT(SOURCEFID.NAME#,I,,'.',M$RU$->F$DCB.PASS#);
    CALL INDEX(I,' ',SOURCEFID.NAME#);
    SOURCEFID.L#=I;
    CALL DAS$SYMINIT(SOURCEFID)
    WHENALTRETURN DO;
        END;
/*       Do some initialization, now that DAS has read in some tables */
    VBASE(DA_SYMDEF_)=DA_SYMDEF$;
    VBOUND(DA_SYMDEF_)=DA_HEADREC.EDRECSIZE*4-1;
    VBASE(DA_ENTDEF_)=DA_ENTDEF$;
    VBOUND(DA_ENTDEF_)=DA_HEADREC.EPRECSIZE*4-1;
/*       Open source file, couldn't do earlier because DAS$SYMBOL uses it */
    CALL OPEN_RU ALTRET(ALT);
/*       Check for options on command line */
    IF B$JIT.CCDISP~=B$JIT.CCARS THEN DO;
/*          Options present - One shot command */
        XUG_GETCMD.NODES$=ADDR(GI_CMDS_WITH);
        XUG_GETCMD.TEXT_=VECTOR(B$JIT.CCBUF);
        CALL XUG$GETCMD(XUG_GETCMD)
        WHENALTRETURN DO;
            XUG_GETCMD.ERR_CODE=XUG_GETCMD.ERR#;
            IF XUG_GETCMD.ERR_CODE.CODE#=%E$SYNERR THEN
                CALL ERRPTR(XUG_GETCMD.ERR#);
            ELSE
                CALL ERRMSG(XUG_GETCMD.ERR#);
            GOTO ALT;
            END;
        BLK$=XUG_GETCMD.OUT$->OUT$BLK.SUBLK$(2);
        CALL SEMANTICS(BLK$->OUT$BLK) ALTRET(ALT);
        GOTO MEXIT;
        END;
 
/*       No options - Read SI until finished */
    XUG_GETCMD.NODES$=ADDR(GI_CMDS_WITHOUT);
    DO FOREVER;
        CALL XUG$GETCMD(XUG_GETCMD)
        WHENALTRETURN DO;
            XUG_GETCMD.ERR_CODE=XUG_GETCMD.ERR#;
            IF XUG_GETCMD.ERR_CODE.CODE#=%E$EOF THEN GOTO MEXIT;
            IF XUG_GETCMD.ERR_CODE.CODE#=%E$SYNERR THEN
                CALL ERRPTR(XUG_GETCMD.ERR#);
            ELSE
                CALL ERRMSG(XUG_GETCMD.ERR#);
            GOTO RETRY;
            END;
        BLK$=XUG_GETCMD.OUT$->OUT$BLK.SUBLK$(0);
        CALL SEMANTICS(BLK$->OUT$BLK) ALTRET(ALT);
RETRY:  END;
 
MEXIT: CALL M$EXIT;
 
E_MONSER: CALL ERRMSG;
    GOTO ALT;
/* USED TO COME HERE ON ALTRET FROM DAS$SYMINIT
E_DAS:  CALL ERRMSG(DA_SYMERR);
        GOTO ALT;
               */
E_XUG: CALL ERRMSG(XUG_GETCMD.ERR#);
    GOTO ALT;
 
ALT: CALL M$EXIT;
 
%EJECT;
SEMANTICS: PROC(P_OUT$BLK) ALTRET;
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
%PARSE$OUT(NAME=OUT$BLK,STCLASS="BASED(BLK$)");
 
 DCL BLK$ PTR STATIC;
 DCL I UBIN STATIC;
 
 DCL FIRST_TIME BIT(1) STATIC INIT(%TRUE);
 
    CALL READ_REC(VECTOR(DA_HEADREC),B$RUHEADKEY) ALTRET(ALT);
 
    CALL PSEUDOFLAVOR(P_OUT$BLK);
 
    IF GI_FLAVOR=0 THEN DO;
        CALL ERRMSG(%E$YUCKY_USER_FLAVOR);
/*E*
ERROR:  GI-E$YUCKY_USER_FLAVOR-0
MESSAGE:I won't eat this run unit unless you tell me its flavor.
*/
        GOTO RET;
        END;
 
    IF FIRST_TIME THEN DO;
        CALL INITIALIZE;
        FIRST_TIME = %FALSE;
        END;
 
    IF P_OUT$BLK.CODE=%DI_CMDS THEN DO;
        CALL DI_CMDS(P_OUT$BLK);
        GOTO RET;
        END;
 
    IF DI_ONLY THEN DO;
        CALL ERRMSG(%E$CANT_CHANGE_THAT);
/*E*
ERROR:  GI-E$CANT_CHANGE_THAT-0
MESSAGE:Can't apply changes since open for display mode only.
*/
        GOTO RET;
        END;
/*E*
ERROR:  GI-E$ONLY_HOST-0
MESSAGE:I only know how to do that to HOST run units.  Ignored.
*/
    DO I=0 TO P_OUT$BLK.NSUBLKS-1;
        BLK$=P_OUT$BLK.SUBLK$(I);
        DO CASE(OUT$BLK.CODE);
         CASE(%DCB_CMDS);
            IF GI_FLAVOR=%HOST_RU THEN
                CALL DCB_CMDS(OUT$BLK.SUBLK$(0)->OUT$BLK);
            ELSE
                CALL ERRPTR(%E$ONLY_HOST,,OUT$BLK.CPOS);
         CASE(%HEAD_CMDS);
            CALL HEAD_CMDS(OUT$BLK.SUBLK$(0)->OUT$BLK);
         CASE(%DEF_CMDS);
            CALL DEF_CMDS(OUT$BLK);
         CASE(%ESP_CMDS);
            CALL ESP_CMDS(OUT$BLK.SUBLK$(0)->OUT$BLK);
        END; /* CASE                                                          */
        END; /* I                                                             */
 
    CALL WRITE_REC(VECTOR(DA_HEADREC),B$RUHEADKEY) ALTRET(ALT);
 
RET: RETURN;
ALT: ALTRETURN;
 
%EJECT;
INITIALIZE: PROC;
/*       Set some RU specific information (HOST/FEP) */
    IF GI_FLAVOR = %FEP_RU THEN DO;
        RUPAGLEN=256;
        RURECLEN=2048;
        RUSEGLEN=65536;
        DBSE=65536;
        MEM_LIMIT=%FEP_MEM_LIMIT;
        SHARE_LIB_START = %FEP_SHARE_LIB_START;
        PATCHD=G_PATCHD;
        PATCHI=G_PATCHI;
        PATCHDH=G_PATCHDH;
        PATCHIH=G_PATCHIH;
        END;
    ELSE DO;
        RUPAGLEN=1024;
        RURECLEN=1024;
        RUSEGLEN=1024;
        DBSE=0;
        MEM_LIMIT=%HOST_MEM_LIMIT;
        SHARE_LIB_START = %HOST_SHARE_LIB_START;
        PATCHD=B_PATCHD;
        PATCHI=B_PATCHI;
        PATCHDH=B_PATCHDH;
        PATCHIH=B_PATCHIH;
        END;
 
/*       Initialize patch header pointers */
    CALL DAS$SDSRCH(PATCHIH,IPH$)
    WHENALTRETURN DO;
        IPH$=ADDR(NIL);
        END;
    CALL DAS$SDSRCH(PATCHDH,DPH$)
    WHENALTRETURN DO;
        DPH$=ADDR(NIL);
        END;
 
END INITIALIZE;
END SEMANTICS;
%EJECT;
PSEUDOFLAVOR: PROC(P_OUT$BLK);
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
%PARSE$OUT(NAME=OUT$BLK,STCLASS="BASED(BLK$)");
 
 DCL BLK$ PTR STATIC;
 DCL I UBIN STATIC;
 DCL NEW_FLAVOR UBIN STATIC;
 
/*       Search input line looking for pseudo-flavor cmds */
    DO I=0 TO P_OUT$BLK.NSUBLKS-1;
        BLK$=P_OUT$BLK.SUBLK$(I);
        IF OUT$BLK.CODE=%PSEUDOFLAVOR_CMDS THEN DO;
            IF OUT$BLK.SUBLK$(0)->OUT$BLK.CODE=%HOST THEN
                NEW_FLAVOR=%HOST_RU;
            ELSE
                NEW_FLAVOR=%FEP_RU;
            IF FLAVOR_OPTION THEN
                CALL ERRMSG(%E$NEW_FLAVOR);
/*E*
ERROR:  GI-E$NEW_FLAVOR-0
MESSAGE:Pseudo-flavor already set, command ignored.
*/
            ELSE
                IF GI_FLAVOR~=0 THEN
                    IF GI_FLAVOR=NEW_FLAVOR THEN
                        CALL ERRMSG(%E$ALREADY_KNOW);
/*E*
ERROR:  GI-E$ALREADY_KNOW-0
MESSAGE:I already know the run unit is that flavor.
*/
                    ELSE
                        CALL ERRMSG(%E$LIAR);
/*E*
ERROR:  GI-E$LIAR-0
MESSAGE:I know better than to believe you about the flavor of this run unit.
*/
                ELSE
                    GI_FLAVOR=NEW_FLAVOR;
 
            FLAVOR_OPTION=%TRUE;
            END; /* IF                                                        */
        END; /* I                                                             */
 
END PSEUDOFLAVOR;
%EJECT;
DI_CMDS: PROC(P_OUT$BLK);
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
 
 DCL BUFFER CHAR(80) STATIC;
 DCL RUF CHAR(0) INIT('Run Unit Flavor: ') CONSTANT;
 DCL 1 TEXTC STATIC,
       2 L UBIN(9) CALIGNED,
       2 C CHAR(31) CALIGNED;
 DCL I UBIN STATIC;
 DCL IND UBIN STATIC;
 DCL TEMP UBIN STATIC;
 DCL 1 NAMES_TEXT CONSTANT,
       2 * CHAR(8) INIT('FMEFT'),
       2 * CHAR(8) INIT('FMBLK'),
       2 * CHAR(8) INIT('FMSEC'),
       2 * CHAR(8) INIT('FMDIAG'),
       2 * CHAR(8) INIT('FMREAD'),
       2 * CHAR(8) INIT('BIT5'),
       2 * CHAR(8) INIT('BIT6'),
       2 * CHAR(8) INIT('BIT7'),
       2 * CHAR(8) INIT('BIT8'),
       2 * CHAR(8) INIT('BIT9'),
       2 * CHAR(8) INIT('BIT10'),
       2 * CHAR(8) INIT('BIT11'),
       2 * CHAR(8) INIT('SNAP'),
       2 * CHAR(8) INIT('SCREECH'),
       2 * CHAR(8) INIT('DISPJOB'),
       2 * CHAR(8) INIT('BIT15'),
       2 * CHAR(8) INIT('SYSCON'),
       2 * CHAR(8) INIT('ASAVE'),
       2 * CHAR(8) INIT('GPP'),
       2 * CHAR(8) INIT('BIT19'),
       2 * CHAR(8) INIT('SYSLOG'),
       2 * CHAR(8) INIT('MFEP'),
       2 * CHAR(8) INIT('CFEP'),
       2 * CHAR(8) INIT('CQ'),
       2 * CHAR(8) INIT('INTCON'),
       2 * CHAR(8) INIT('IOQW'),
       2 * CHAR(8) INIT('IOQ'),
       2 * CHAR(8) INIT('EXPM'),
       2 * CHAR(8) INIT('PM'),
       2 * CHAR(8) INIT('TND'),
       2 * CHAR(8) INIT('JIT'),
       2 * CHAR(8) INIT('BIT31'),
       2 * CHAR(8) INIT('MSYS'),
       2 * CHAR(8) INIT('MAXMEM'),
       2 * CHAR(8) INIT('EXMM'),
       2 * CHAR(8) INIT('SPCLMM');
 DCL NAMES(0:35) REDEF NAMES_TEXT CHAR(8);
 DCL 1 OPTIONS STATIC,
       2 FLAVOR BIT(1) UNAL,
       2 LOCKS BIT(1) UNAL,
       2 PRIVS BIT(1) UNAL,
       2 FLAGS BIT(1) UNAL,
       2 SHA BIT(1) UNAL,
       2 ALT BIT(1) UNAL,
       2 TCB BIT(1) UNAL,
       2 DCBS BIT(1) UNAL,
       2 DPATCH BIT(1) UNAL,
       2 IPATCH BIT(1) UNAL,
       2 ALL BIT(1) UNAL;
 
%FPT_WRITE(FPTN=FPT_WRITELO,STCLASS=CONSTANT,
    BUF=BUFFER,
    DCB=M$LO);
 
%EJECT;
    OPTIONS=%FALSE;
    DO I=0 TO P_OUT$BLK.NSUBLKS-1;
        DO CASE(P_OUT$BLK.SUBLK$(I)->OUT$BLK.CODE);
         CASE(%DI_FLAVOR);
            OPTIONS.FLAVOR=%TRUE;
         CASE(%DI_LOCKS);
            OPTIONS.LOCKS=%TRUE;
         CASE(%DI_PRIVS);
            OPTIONS.PRIVS=%TRUE;
         CASE(%DI_FLAGS);
            OPTIONS.FLAGS=%TRUE;
         CASE(%DI_SHA);
            OPTIONS.SHA=%TRUE;
         CASE(%DI_ALT);
            OPTIONS.ALT=%TRUE;
         CASE(%DI_TCB);
            OPTIONS.TCB=%TRUE;
         CASE(%DI_DCBS);
            OPTIONS.DCBS=%TRUE;
         CASE(%DI_PATCHS);
            OPTIONS.DPATCH=%TRUE;
            OPTIONS.IPATCH=%TRUE;
         CASE(%DI_DPATCH);
            OPTIONS.DPATCH=%TRUE;
         CASE(%DI_IPATCH);
            OPTIONS.IPATCH=%TRUE;
         CASE(%DI_ALL);
            OPTIONS.ALL=%TRUE;
        END; /* CASE                                                          */
        END; /* I                                                             */
 
%EJECT;
    IF OPTIONS.FLAVOR OR OPTIONS.ALL THEN DO;
        IF DA_HEADREC.FLAVOR=%HOST_RU THEN
            CALL CONCAT(BUFFER,RUF,'HOST');
        ELSE
            IF DA_HEADREC.FLAVOR=%FEP_RU THEN
                CALL CONCAT(BUFFER,RUF,'FEP');
            ELSE DO;
                I=DA_HEADREC.FLAVOR;
                CALL CONVERT(TEXTC,I);
                CALL CONCAT(BUFFER,RUF,SUBSTR(TEXTC.C,0,TEXTC.L));
                END;
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.TCB OR OPTIONS.ALL THEN DO;
        I=DA_HEADREC.TCBSIZE;
        CALL CONVERT(TEXTC,I);
        CALL CONCAT(BUFFER,'TCB size: ',SUBSTR(TEXTC.C,0,TEXTC.L));
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.SHA OR OPTIONS.ALL THEN DO;
        BUFFER='Shared Library:';
        IF DA_HEADREC.LIBNAME.CNT~=0 THEN
            CALL INSERT(BUFFER,16,DA_HEADREC.LIBNAME.CNT,
              DA_HEADREC.LIBNAME.TXT);
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.ALT OR OPTIONS.ALL THEN DO;
        BUFFER='Alternate shared library:';
        IF DA_HEADREC.ASLNAME.CNT~=0 THEN
            CALL INSERT(BUFFER,26,DA_HEADREC.ASLNAME.CNT,
              DA_HEADREC.ASLNAME.TXT);
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.LOCKS OR OPTIONS.ALL THEN DO;
        IF DA_HEADREC.LOCK THEN DO;
            IF DA_HEADREC.STRONG_LOCK THEN
                BUFFER='Slock: ';
            ELSE
                BUFFER='Wlock: ';
            IND=7;
            DO I=0 TO 71;
                IF DA_HEADREC.LOCK(I) THEN DO;
                    CALL CONVERT(TEXTC,I+1);
                    CALL INSERT(BUFFER,IND,TEXTC.L+1,
                      SUBSTR(TEXTC.C,0,TEXTC.L),',');
                    IND=IND+TEXTC.L+1;
                    END; /* IF                                                */
                END; /* I                                                     */
            SUBSTR(BUFFER,IND-1,1)=' ';
            END; /* IF                                                        */
        ELSE
            BUFFER='Locks: None';
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.PRIVS OR OPTIONS.ALL THEN DO;
        IF DA_HEADREC.PRIV=%FALSE THEN DO;
            BUFFER='Privs: None';
            CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
            END;
        ELSE DO;
            BUFFER='Privs:';
            CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
            I=0;
            BUFFER=' ';
            DO IND=0 TO 35;
                IF ADDR(DA_HEADREC.PRIV)->B$PRIVS.BITS(IND) THEN DO;
                    CALL INSERT(BUFFER,
                      I*SIZEC(NAMES(1))+4,
                      SIZEC(NAMES(1)),
                      NAMES(IND));
                    I=I+1;
                    IF I=8 THEN DO;
                        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
                        BUFFER=' ';
                        I=0;
                        END; /* I                                             */
                    END; /* IF                                                */
                END; /* IND                                                   */
 
            IF I~=0 THEN CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
            END; /* DO                                                        */
        END;
 
    IF OPTIONS.FLAGS OR OPTIONS.ALL THEN DO;
        BUFFER='Flags:';
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        BUFFER=' ';
        IF DA_HEADREC.S THEN
            CALL INSERT(BUFFER,4,12,'SHAREABLE');
        ELSE
            CALL INSERT(BUFFER,4,12,'NSHAREABLE');
        I=1;
        IF DA_HEADREC.NSTDINVOC THEN DO;
            CALL INSERT(BUFFER,I*12+4,12,'STDINVOC');
            I=I+1;
            END;
        IF DA_HEADREC.PROCACC THEN DO;
            CALL INSERT(BUFFER,I*12+4,12,'PROCACC');
            I=I+1;
            END;
        IF DA_HEADREC.NOCHGPMEM THEN DO;
            CALL INSERT(BUFFER,I*12+4,12,'NOCHGPMEM');
            I=I+1;
            END;
        IF DA_HEADREC.PROCSURCHG THEN DO;
            CALL INSERT(BUFFER,I*12+4,12,'SURCHARGE');
            I=I+1;
            END;
        IF DA_HEADREC.LAUTO THEN DO;
            CALL INSERT(BUFFER,I*12+4,12,'LAUTO');
            I=I+1;
            END;
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.DPATCH OR OPTIONS.ALL THEN
DPTCH: DO;
        CALL GET_SYM_HDR_INFO(DPATCHDR,PATCHDH)
        WHENALTRETURN DO;
            CALL ERRMSG(%E$NODPATCH);
            EXIT DPTCH;
            END;
        BUFFER='Data Patch Space (in words):';
        CALL CONVERT(TEXTC,DPATCHDR.SIZE);
        CALL INSERT(BUFFER,29,TEXTC.L+1,TEXTC.C);
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.IPATCH OR OPTIONS.ALL THEN
IPTCH: DO;
        CALL GET_SYM_HDR_INFO(IPATCHDR,PATCHIH)
        WHENALTRETURN DO;
            CALL ERRMSG(%E$NOIPATCH);
            EXIT IPTCH;
            END;
        BUFFER='Instruction Patch Space (in words):';
        CALL CONVERT(TEXTC,IPATCHDR.SIZE);
        CALL INSERT(BUFFER,36,TEXTC.L+1,TEXTC.C);
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        END;
 
    IF OPTIONS.DCBS OR OPTIONS.ALL THEN DO;
        IF GI_FLAVOR=%FEP_RU THEN DO;
            CALL ERRMSG(%E$FEP_DCBS);
/*E*
ERROR:  GI-E$FEP_DCBS-0
MESSAGE:I don't know how to display FEP DCBs.
*/
            GOTO RET;
            END;
 
        TEMP=DA_HEADREC.DCBRES;
        CALL CONVERT(TEXTC,TEMP);
        CALL CONCAT(BUFFER,
          'Number of DCB slots reserved: ',
          SUBSTR(TEXTC.C,0,TEXTC.L));
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
 
        IF DA_HEADREC.UDCBNUM=0 THEN DO;
            BUFFER='The Run Unit contains no constant DCBS.';
            CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
            GOTO RET;
            END;
 
        BUFFER='Constant DCBs:';
        CALL M$WRITE(FPT_WRITELO) ALTRET(E_MONSER);
        CALL READ_ROSEG ALTRET(RET);
        BUFFER=' ';
        DO I=0 TO DA_HEADREC.UDCBNUM-1;
            F$DCB$=PINCRW(B$ROS$,DCBWORD(I)/262144);
            IF F$DCB.DCBNAME.X~=0 THEN DO;
                TEMP=F$DCB.DCBNAME.X;
                CALL CONVERT(TEXTC,TEMP);
                CALL INSERT(BUFFER,MOD(I,2)*36+4,36,
                  F$DCB.DCBNAME.N,
                  ' = #',
                  SUBSTR(TEXTC.C,0,TEXTC.L));
                END;
            ELSE
                CALL INSERT(BUFFER,MOD(I,2)*36+4,36,
                  F$DCB.DCBNAME.N);
            IF MOD(I,2)=1 THEN DO;
                CALL M$WRITE(FPT_WRITELO) ALTRET(ERR);
                BUFFER=' ';
                END;
            END; /* I                                                         */
        IF MOD(DA_HEADREC.UDCBNUM,2)=1 THEN
            CALL M$WRITE(FPT_WRITELO) ALTRET(ERR);
        CALL FREE_ROSEG ALTRET(RET);
        END;
 
RET: RETURN;
 
ERR: CALL ERRMSG;
    CALL FREE_ROSEG ALTRET(E_MONSER);
    GOTO RET;
 
E_MONSER: CALL ERRMSG;
    GOTO RET;
 
END DI_CMDS;
%EJECT;
RU_IO: PROC ALTRET;
 
%FPT_OPEN(FPTN=FPT_OPENRU,STCLASS=STATIC,
    DCB=M$RU,
    ASN=FILE,
    FUN=UPDATE,
    SHARE=IN);
 
%B$RU_KEY(NAME=ROS_KEY,
    TYPE=%TYPROS);
%B$RU_KEY(NAME=SEGDEF_KEY,STCLASS=CONSTANT,
    TYPE=%TYPSEGDEF);
 
 DCL SIZE SBIN STATIC;
 DCL BUF_ VECTOR STATIC INIT(VECTOR(NIL));
 
OPEN_RU: ENTRY ALTRET;
 
/*       Open the RU */
    CALL M$OPEN(FPT_OPENRU)
    WHENALTRETURN DO;
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#~=%E$FILEBUSY THEN
            GOTO E_MONSER;
        FPT_OPENRU.V.FUN#=%IN#;
        FPT_OPENRU.V.SHARE#=%IN#;
        CALL M$OPEN(FPT_OPENRU)
        WHENALTRETURN DO;
            IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#~=%E$FILEBUSY THEN
                GOTO E_MONSER;
            FPT_OPENRU.V.SHARE#=%ALL#;
            CALL M$OPEN(FPT_OPENRU) ALTRET(E_MONSER);
            END;
        END;
    M$RU$=DCBADDR(DCBNUM(M$RU));
    F$DCB$=M$RU$;
    IF F$DCB.ASN#~=%FILE# OR F$DCB.ORG#~=%KEYED# THEN DO;
        CALL ERRMSG(%E$NOT_A_RU);
/*E*
ERROR:  GI-E$NOT_A_RU-0
MESSAGE:That is not a valid run unit.
*/
        GOTO ALT;
        END;
 
    IF NOT (F$DCB.FFLG.UPD# AND F$DCB.FFLG.READ# AND
      F$DCB.FFLG.REATTR# AND F$DCB.FFLG.WNEW#) THEN
        IF NOT F$DCB.FFLG.READ# THEN DO;
            CALL ERRMSG(%E$NO_ACCESS);
/*E*
ERROR:  GI-E$NO_ACCESS-0
MESSAGE:Insufficient access to play with %FN.
*/
            GOTO ALT;
            END;
        ELSE DO;
            CALL ERRMSG(%E$DI_ONLY);
/*E*
ERROR:  GI-E$DI_ONLY-0
MESSAGE:Run unit is open for display only.
*/
            DI_ONLY=%TRUE;
            END;
 
/*       Check for C00 head record */
    IF DA_HEADREC.FLAVOR=0 THEN DO;
        CALL ERRMSG(%E$PRE_C00);
/*E*
ERROR:  GI-E$PRE_C00-0
MESSAGE:Cannot operate on pre C00 run units.
*/
        GOTO ALT;
        END;
 
/*       Set internally used flavor flag */
    IF DA_HEADREC.FLAVOR=%HOST_RU OR DA_HEADREC.FLAVOR=%FEP_RU THEN
        GI_FLAVOR=DA_HEADREC.FLAVOR;
    ELSE
        GI_FLAVOR=0;
    GOTO RET;
 
%EJECT;
READ_ROSEG: ENTRY ALTRET;
/*       Allocate a DS for ROS */
    IF B$ROS$~=ADDR(NIL) THEN GOTO E_ALLOCATED;
    IF DA_HEADREC.ROSIZE=0 THEN GOTO RET;
 
    RESULT=VECTOR(NIL);
    FPT_GDS.V.SEGSIZE#=((DA_HEADREC.ROSIZE+1023)/1024)*1024;
    CALL M$GDS(FPT_GDS) ALTRET(E_MONSER);
    B$ROS$=RESULT.PTR$;
/*      Read in the ROSEG records */
    ROS_KEY.OFF#=0;
    SIZE=DA_HEADREC.ROSIZE;
    DO WHILE SIZE>0;
        IF SIZE>1024 THEN
            VBOUND(BUF_)=1024*4-1;
        ELSE
            VBOUND(BUF_)=SIZE*4-1;
        VBASE(BUF_)=PINCRW(B$ROS$,ROS_KEY.OFF#);
        CALL READ_REC(BUF_,ROS_KEY) ALTRET(ALT);
        SIZE=SIZE-1024;
        ROS_KEY.OFF#=ROS_KEY.OFF#+1024;
        END;
    GOTO RET;
 
WRITE_ROSEG: ENTRY ALTRET;
/*      Write out the new ROSEG records */
    IF DA_HEADREC.ROSIZE=0 THEN GOTO RET;
 
    ROS_KEY.OFF#=0;
    SIZE=DA_HEADREC.ROSIZE;
    DO WHILE SIZE>0;
        IF SIZE>1024 THEN
            VBOUND(BUF_)=1024*4-1;
        ELSE
            VBOUND(BUF_)=SIZE*4-1;
        VBASE(BUF_)=PINCRW(B$ROS$,ROS_KEY.OFF#);
        CALL WRITE_REC(BUF_,ROS_KEY) ALTRET(ALT);
        SIZE=SIZE-1024;
        ROS_KEY.OFF#=ROS_KEY.OFF#+1024;
        END;
 
FREE_ROSEG: ENTRY ALTRET;
    RESULT.PTR$=B$ROS$;
    B$ROS$=ADDR(NIL);
    GOTO FREE_SEG;
 
%EJECT;
READ_SEGDEF: ENTRY ALTRET;
    IF B$SEGDEF$~=ADDR(NIL) THEN GOTO E_ALLOCATED;
    RESULT=VECTOR(NIL);
    FPT_GDS.V.SEGSIZE#=DA_HEADREC.SDRECSIZE;
    CALL M$GDS(FPT_GDS) ALTRET(E_MONSER);
    B$SEGDEF$=RESULT.PTR$;
/*      Read in the SEGDEF record. */
    VBASE(BUF_)=RESULT.PTR$;
    VBOUND(BUF_)=RESULT.W1.VSIZE#;
    CALL READ_REC(BUF_,SEGDEF_KEY)
    WHENALTRETURN DO;
        IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.ERR#=%E$NOKEY THEN DO;
            CALL ERRMSG(%E$NO_SEGDEFS);
/*E*
ERROR:  GI-E$NO_SEGDEFS-0
MESSAGE:There are no SEGDEF's/AREADEF's to process in the run unit.
*/
            GOTO ALT;
            END;
        ELSE
            GOTO E_MONSER;
        END;
    GOTO RET;
 
WRITE_SEGDEF: ENTRY ALTRET;
    IF B$SEGDEF$=ADDR(NIL) THEN GOTO RET;
    VBASE(BUF_)=B$SEGDEF$;
    VBOUND(BUF_)=(DA_HEADREC.SDRECSIZE*4)-1;
    CALL WRITE_REC(BUF_,SEGDEF_KEY) ALTRET(ALT);
 
FREE_SEGDEF: ENTRY ALTRET;
    RESULT.PTR$=B$SEGDEF$;
    B$SEGDEF$=ADDR(NIL);
    GOTO FREE_SEG;
 
%EJECT;
/*      Free up memory */
FREE_SEG: ;
    IF RESULT.PTR$~=ADDR(NIL) THEN DO;
        FPT_FDS.V.SEGSIZE#=0;
        CALL M$FDS(FPT_FDS) ALTRET(E_MONSER);
        FPT_FDS.V.SEGSIZE#=(RESULT.W1.VSIZE#+1)/4;
        CALL M$FDS(FPT_FDS) ALTRET(E_MONSER);
        END;
 
RET: RETURN;
 
E_MONSER: ;
    CALL ERRMSG;
    IF RESULT~=VECTOR(NIL) THEN DO;
        FPT_FDS.V.SEGSIZE#=0;
        CALL M$FDS(FPT_FDS) ALTRET(E_MONSER);
        FPT_FDS.V.SEGSIZE#=(RESULT.W1.VSIZE#+1)/4;
        CALL M$FDS(FPT_FDS) ALTRET(E_MONSER);
        END;
    GOTO ALT;
 
E_ALLOCATED: ;
    CALL ERRMSG(%E$ALREADY_ALLOCATED);
/*E*
ERROR:  GI-E$ALREADY_ALLOCATED-0
MESSAGE:An attempt was made to reallocate an already allocated
        RU record.  Internal error!
*/
    GOTO ALT;
 
ALT: ALTRETURN;
END RU_IO;
%EJECT;
DCB_CMDS: PROC(P_OUT$BLK) ALTRET;
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
 
%B$TREE_TABLE(STCLASS="BASED(B$TREE_HEADER$)");
 
 DCL BLK$ PTR STATIC;
 DCL B$TREE_HEADER$ PTR STATIC;
 DCL OLD$ PTR STATIC;
 DCL NEW$ PTR STATIC;
 
 DCL TOTALDCBS UBIN STATIC;
 DCL DELTADCBS SBIN STATIC;
 DCL SIZE UBIN STATIC;
 DCL FOUND BIT(1) STATIC;
 DCL DUMMY CHAR(1) BASED;
 DCL DCBNAME CHAR(32);
 
    IF DA_HEADREC.ROSIZE=0 THEN DO;
        CALL ERRPTR(%E$NO_DCBS,,P_OUT$BLK.CPOS+1);
/*E*
ERROR:  GI-E$NO_DCBS-0
MESSAGE:There are no DCB's in the Run Unit to play with.
*/
        GOTO RET;
        END;
 
    CALL READ_ROSEG ALTRET(RET);
    DO CASE(P_OUT$BLK.CODE);
     CASE(%DCBSLOTS);
        CALL CHARBIN(TOTALDCBS,P_OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
/*          Round off to even number */
        TOTALDCBS=((TOTALDCBS+1)/2)*2;
        IF TOTALDCBS < DA_HEADREC.UDCBNUM + 10 THEN DO;
            CALL ERRPTR(%E$MIN_DCBS,,P_OUT$BLK.CPOS+1);
/*E*
ERROR:  GI-E$MIN_DCBS-0
MESSAGE:Cannot set DCBSLOTS less than number of predefined DCBs plus 10.
*/
            GOTO RET;
            END;
        DELTADCBS = TOTALDCBS - DA_HEADREC.DCBRES;
        IF DELTADCBS > 0 THEN DO; /* adding DCB slots                         */
            RESULT=VECTOR(NIL);
            RESULT.PTR$=B$ROS$;
            FPT_GDS.V.SEGSIZE#=DELTADCBS;
            CALL M$GDS(FPT_GDS) ALTRET(E_MONSER);
            END;
 
/*          Fix the pointer in TREE_HEADER */
        B$TREE_HEADER$=PINCRW(B$ROS$,DA_HEADREC.TREEDISP);
        B$TREE_HEADER.LIB$=PINCRW(B$TREE_HEADER.LIB$,DELTADCBS);
 
/*          Fix the DCB's that were already allocated */
        DO I=0 TO DA_HEADREC.UDCBNUM-1;
            DCB$(I)=PINCRW(DCB$(I),DELTADCBS);
            END;
 
/*          Make room for the extra DCBS */
        OLD$=PINCRW(B$ROS$,DA_HEADREC.UDCBNUM);
        NEW$=PINCRW(OLD$,DELTADCBS);
        SIZE=(DA_HEADREC.ROSIZE-DA_HEADREC.UDCBNUM)*4;
        CALL SLIDE(OLD$->DUMMY,NEW$->DUMMY,SIZE);
 
/*          Change number of DCBS's, TREEDISP, and ROSIZE */
        DA_HEADREC.DCBRES=DA_HEADREC.DCBRES+DELTADCBS;
        DA_HEADREC.TREEDISP=DA_HEADREC.TREEDISP+DELTADCBS;
        DA_HEADREC.ROSIZE=DA_HEADREC.ROSIZE+DELTADCBS;
 
     CASE(%DCB#,%DCBN);
        FOUND=%FALSE;
I1:     DO I=0 TO DA_HEADREC.UDCBNUM-1;
            F$DCB$=PINCRW(B$ROS$,DCBWORD(I)/262144);
            BLK$=P_OUT$BLK.SUBLK$(1);
            IF BLK$->OUT$SYM.CODE=%DCBNUMBER THEN
                CALL CONCAT(DCBNAME,'F$',BLK$->OUT$SYM.TEXT);
            ELSE
                DCBNAME=BLK$->OUT$SYM.TEXT;
            IF F$DCB.DCBNAME.N=DCBNAME THEN DO;
                F$DCB.DCBNAME.X=P_OUT$BLK.SUBLK$(0)->OUT$SYM.CODE;
                FOUND=%TRUE;
                EXIT I1;
                END;
            END I1;
 
        IF FOUND THEN
I2:     DO I=0 TO DA_HEADREC.UDCBNUM-1;
            F$DCB$=PINCRW(B$ROS$,DCBWORD(I)/262144);
            IF F$DCB.DCBNAME.X=P_OUT$BLK.SUBLK$(0)->OUT$SYM.CODE AND
              F$DCB.DCBNAME.N~=DCBNAME THEN
                F$DCB.DCBNAME.X=0;
            END I2;
        ELSE
            GOTO NDCB;
 
     CASE(%NDCB#,%NDCBN);
        FOUND=%FALSE;
        DO I=0 TO DA_HEADREC.UDCBNUM-1;
            F$DCB$=PINCRW(B$ROS$,DCBWORD(I)/262144);
            IF F$DCB.DCBNAME.X=P_OUT$BLK.SUBLK$(0)->OUT$SYM.CODE THEN DO;
                F$DCB.DCBNAME.X=0;
                FOUND=%TRUE;
                END;
            END;
        IF NOT FOUND THEN DO;
NDCB:       CALL ERRPTR(%E$CANT_FIND_DCB,,P_OUT$BLK.SUBLK$(1)->OUT$SYM.CPOS);
/*E*
ERROR:  GI-E$CANT_FIND_DCB-0
MESSAGE:The specified DCB cannot be found.
*/
            END;
    END; /* CASE                                                              */
 
    CALL WRITE_ROSEG;
 
RET: RETURN;
 
E_MONSER: CALL ERRMSG;
    CALL FREE_ROSEG;
    GOTO RET;
 
END DCB_CMDS;
%EJECT;
DEF_CMDS: PROC(P_OUT$BLK) ALTRET;
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
 
%PARSE$OUT(NAME=OUT$BLK,STCLASS="BASED(BLK$)");
%PARSE$SYM(NAME=OUT$SYM,STCLASS="BASED(SYM$)");
%B$DNAME(NAME=DNAME,STCLASS="BASED(DNAME$)");
%B$EDEF(NAME=EDEF,STCLASS="BASED(EDEF$)");
%B$SDEF(NAME=SDEF,STCLASS="BASED(SDEF$)");
%B$SEGDEF(NAME=SEGDEF,STCLASS="BASED(SEGDEF$)");
 
 DCL BLK$ PTR;
 DCL SYM$ PTR;
 DCL DNAME$ PTR STATIC;
 DCL EDEF$ PTR STATIC;
 DCL SDEF$ PTR STATIC;
 DCL SEGDEF$ PTR STATIC;
 DCL END$ PTR STATIC;
 
 DCL FOUND BIT(1);
 DCL SOURCE UBIN;
 DCL FCN UBIN;
 DCL WILD BIT(1);
 
    FCN=P_OUT$BLK.SUBLK$(0)->OUT$BLK.CODE;
    CALL INIT_LIST;
 
    DO CASE(P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE);
%EJECT;
     CASE(%ENTDEF);
        CALL READ_REC(DA_ENTDEF_,ENTDEF_KEY) ALTRET(ALT);
        EDEF$=DA_ENTDEF$;
        END$=PINCRC(EDEF$,M$RU$->F$DCB.ARS#);
        DO WHILE(EDEF$<END$);
            DNAME$=PINCRW(DA_DNAME$,EDEF.NPOINTER);
            CALL FIND_LIST;
            DO CASE(FCN);
             CASE(%REMOVE);
                IF FOUND THEN DO;
                    IF EDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# AND
                      NOT WILD THEN DO;
                        CALL ERRPTR(%E$ALREADY_REMOVED,,OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$ALREADY_REMOVED-0
MESSAGE:The symbol was already removed.
*/
                        GOTO NEDEF;
                        END;
                    EDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    END;
             CASE(%KEEP);
                IF NOT FOUND THEN
                    EDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                ELSE
                    IF EDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN
                        EDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
             CASE(%REPLACE);
                IF FOUND THEN DO;
                    IF EDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN DO;
                        EDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                        GOTO NEDEF;
                        END;
                    IF NOT WILD THEN
                        CALL ERRPTR(%E$ALREADY_REPLACED,,OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$ALREADY_REPLACED-0
MESSAGE:The symbol does not need replacing.  It already exists.
*/
                    END;
             CASE(%PRIMARY);
                IF FOUND THEN DO;
                    IF EDEF.PRI AND NOT WILD THEN DO;
                        CALL ERRPTR(%E$ALREADY_PRIMARY,,OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$ALREADY_PRIMARY-0
MESSAGE:The symbol is already a primary ENTDEF.
*/
                        GOTO NEDEF;
                        END;
                    EDEF.PRI=%TRUE;
                    END;
             CASE(%SECONDARY);
                IF FOUND THEN DO;
                    IF NOT EDEF.PRI AND NOT WILD THEN DO;
                        CALL ERRPTR(%E$ALREADY_SECONDARY,,
                          OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$ALREADY_SECONDARY-0
MESSAGE:The symbol is already a secondary ENTDEF.
*/
                        GOTO NEDEF;
                        END;
                    EDEF.PRI=%FALSE;
                    END;
            END; /* CASE                                                      */
 
NEDEF:      EDEF$=PINCRW(EDEF$,SIZEW(EDEF));
            END;
 
        CALL WRITE_REC(DA_ENTDEF_,ENTDEF_KEY) ALTRET(ALT);
 
%EJECT;
     CASE(%SYMDEF);
        CALL READ_REC(DA_SYMDEF_,SYMDEF_KEY) ALTRET(ALT);
        SDEF$=DA_SYMDEF$;
        END$=PINCRC(SDEF$,M$RU$->F$DCB.ARS#);
        DO WHILE(SDEF$<END$);
            DNAME$=PINCRW(DA_DNAME$,SDEF.NPOINTER);
            CALL FIND_LIST;
            DO CASE(FCN);
             CASE(%REMOVE);
                IF FOUND THEN DO;
                    IF SDEF.CONSTNT THEN
                        SOURCE=SDEF.LFLAGS.SOURCE;
                    ELSE
                        SOURCE=SDEF.AD.LFLAGS.SOURCE;
                    IF SOURCE=%SOURCE_REMOVED# AND NOT WILD THEN DO;
                        CALL ERRPTR(%E$ALREADY_REMOVED,,OUT$SYM.CPOS+1);
                        GOTO NSDEF;
                        END;
                    IF SDEF.CONSTNT THEN
                        SDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    ELSE
                        SDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    END;
             CASE(%KEEP);
                IF NOT FOUND THEN
                    IF SDEF.CONSTNT THEN
                        SDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    ELSE
                        SDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                ELSE
                    IF SDEF.CONSTNT THEN
                        IF SDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN
                            SDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                        ELSE;
                    ELSE
                        IF SDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN
                            SDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
             CASE(%REPLACE);
                IF FOUND THEN DO;
                    IF SDEF.CONSTNT THEN
                        IF SDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN DO;
                            SDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                            GOTO NSDEF;
                            END;
                        ELSE;
                    ELSE
                        IF SDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN DO;
                            SDEF.AD.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                            GOTO NSDEF;
                            END;
                    IF NOT WILD THEN
                        CALL ERRPTR(%E$ALREADY_REPLACED,,
                          OUT$SYM.CPOS+1);
                    END;
            END; /* CASE                                                      */
 
NSDEF:      SDEF$=PINCRW(SDEF$,SIZEW(SDEF));
            END;
 
        CALL WRITE_REC(DA_SYMDEF_,SYMDEF_KEY) ALTRET(ALT);
 
%EJECT;
     CASE(%SEGDEF);
        CALL READ_SEGDEF ALTRET(ALT);
        SEGDEF$=B$SEGDEF$;
        END$=PINCRC(SEGDEF$,M$RU$->F$DCB.ARS#);
        DO WHILE(SEGDEF$<END$);
            DNAME$=PINCRW(DA_DNAME$,SEGDEF.NPOINTER);
            CALL FIND_LIST;
            DO CASE(FCN);
             CASE(%REMOVE);
                IF FOUND THEN DO;
                    IF SEGDEF.CONSTNT THEN
                        SOURCE=SEGDEF.LFLAGS.SOURCE;
                    ELSE
                        SOURCE=SEGDEF.AD.LFLAGS.SOURCE;
                    IF SOURCE=%SOURCE_REMOVED# AND NOT WILD THEN DO;
                        CALL ERRPTR(%E$ALREADY_REMOVED,,OUT$SYM.CPOS+1);
                        GOTO NSEGDEF;
                        END;
                    IF SEGDEF.CONSTNT THEN
                        SEGDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    ELSE
                        SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    END;
             CASE(%KEEP);
                IF NOT FOUND THEN
                    IF SEGDEF.CONSTNT THEN
                        SEGDEF.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                    ELSE
                        SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED#;
                ELSE
                    IF SEGDEF.CONSTNT THEN
                        IF SEGDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN
                            SEGDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                        ELSE;
                    ELSE
                        IF SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN
                            SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_OBJECT#;
             CASE(%REPLACE);
                IF FOUND THEN DO;
                    IF SEGDEF.CONSTNT THEN
                        IF SEGDEF.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN DO;
                            SEGDEF.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                            GOTO NSEGDEF;
                            END;
                        ELSE;
                    ELSE
                        IF SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED# THEN DO;
                            SEGDEF.AD.LFLAGS.SOURCE=%SOURCE_OBJECT#;
                            GOTO NSEGDEF;
                            END;
                    IF NOT WILD THEN
                        CALL ERRPTR(%E$ALREADY_REPLACED,,OUT$SYM.CPOS+1);
                    END;
            END; /* CASE                                                      */
 
NSEGDEF:    SEGDEF$=PINCRW(SEGDEF$,SIZEW(SEGDEF));
            END; /* WHILE                                                     */
 
        CALL WRITE_SEGDEF ALTRET(ALT);
    END; /* CASE                                                              */
 
RET: CALL CHECK_LIST;
    RETURN;
 
ALT: IF P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE = %SEGDEF THEN CALL FREE_SEGDEF;
    ALTRETURN;
 
%EJECT;
FIND_LIST: PROC;
 
%INCLUDE XUW_MACRO_C;
 %XUW_WILDCARD;
 %XUW_ENTRIES;
 
 DCL I UBIN;
 DCL J UBIN;
 DCL NSUBLKS UBIN;
 
    FOUND=%TRUE;
    WILD=%TRUE;
    IF P_OUT$BLK.NSUBLKS=3 THEN DO;
        BLK$=P_OUT$BLK.SUBLK$(2);
        NSUBLKS=BLK$->OUT$BLK.NSUBLKS;
        DO I=0 TO NSUBLKS-1;
            SYM$=BLK$->OUT$BLK.SUBLK$(I);
            CALL INDEX(J,'?',OUT$SYM.TEXT)
            WHENRETURN DO;
                WILD=%TRUE;
                END;
            WHENALTRETURN DO;
                WILD=%FALSE;
                END;
            XUW_WILDCARD.INPUT_.BOUND=DNAME.COUNT;
            XUW_WILDCARD.INPUT_.INPUT$=ADDR(DNAME.TEXT);
            XUW_WILDCARD.PATTERN_.BOUND=OUT$SYM.COUNT;
            XUW_WILDCARD.PATTERN_.PATTERN$=ADDR(OUT$SYM.TEXT);
            CALL X$WILDCMP(XUW_WILDCARD)
            WHENRETURN DO;
                OUT$SYM.SCRITCH=1;
                GOTO RET;
                END;
            END;
        FOUND=%FALSE;
        END;
    GOTO RET;
 
INIT_LIST: ENTRY;
    IF P_OUT$BLK.NSUBLKS=3 THEN DO;
        BLK$=P_OUT$BLK.SUBLK$(2);
        NSUBLKS=BLK$->OUT$BLK.NSUBLKS;
        DO I=0 TO NSUBLKS-1;
            SYM$=BLK$->OUT$BLK.SUBLK$(I);
            OUT$SYM.SCRITCH=0;
            END;
        END;
    GOTO RET;
 
CHECK_LIST: ENTRY;
    IF P_OUT$BLK.NSUBLKS=3 THEN DO;
        BLK$=P_OUT$BLK.SUBLK$(2);
        NSUBLKS=BLK$->OUT$BLK.NSUBLKS;
        DO I=0 TO NSUBLKS-1;
            SYM$=BLK$->OUT$BLK.SUBLK$(I);
            IF OUT$SYM.SCRITCH~=1 THEN
                CALL INDEX(J,'?',OUT$SYM.TEXT)
                WHENRETURN DO;
                    CALL ERRPTR(%E$CANT_MATCH_WILD,,OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$CANT_MATCH_WILD-0
MESSAGE:No matches were found for the wildcarded string within
        the type specified.
*/
                    END;
                WHENALTRETURN DO;
                    CALL ERRPTR(%E$CANT_FIND_SYMBOL,,OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$CANT_FIND_SYMBOL-C
MESSAGE:The symbol was not found within the type specified.
*/
                    END;
            END;
        END;
 
RET: RETURN;
 
END FIND_LIST;
END DEF_CMDS;
%EJECT;
HEAD_CMDS: PROC(P_OUT$BLK);
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
 
%PARSE$OUT(NAME=OUT$BLK,STCLASS="BASED(BLK$)");
 
 DCL BLK$ PTR STATIC;
 DCL I UBIN STATIC;
 DCL IND UBIN STATIC;
 DCL FLAG BIT(1) STATIC;
 
    DO CASE(P_OUT$BLK.CODE);
     CASE(%FLAVOR);
        DO CASE(P_OUT$BLK.SUBLK$(0)->OUT$SYM.CODE);
         CASE(%HOST);
            DA_HEADREC.FLAVOR=%HOST_RU;
         CASE(%FEP);
            DA_HEADREC.FLAVOR=%FEP_RU;
         CASE(ELSE); /* Set flavor to user specified number                   */
            BLK$=P_OUT$BLK.SUBLK$(0);
            CALL CHARBIN(IND,BLK$->OUT$SYM.TEXT);
            IF IND=0 THEN
                CALL ERRPTR(%E$INVALID_FLAVOR,,BLK$->OUT$SYM.CPOS+1);
/*E*
ERROR:  GI-E$INVALID_FLAVOR-0
MESSAGE:Flavor not allowed to be set to zero (0).  Statement ignored.
*/
            ELSE
                DA_HEADREC.FLAVOR=IND;
        END; /* CASE                                                          */
 
     CASE(%SHARELIB);
        DA_HEADREC.LIBNAME.TXT=P_OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
        DA_HEADREC.LIBNAME.CNT=P_OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
 
     CASE(%NOSHARELIB);
        DA_HEADREC.LIBNAME.TXT=' ';
        DA_HEADREC.LIBNAME.CNT=0;
 
     CASE(%ALTSHARELIB);
        DA_HEADREC.ASLNAME.TXT=P_OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT;
        DA_HEADREC.ASLNAME.CNT=P_OUT$BLK.SUBLK$(0)->OUT$SYM.COUNT;
 
     CASE(%NOALTSHARELIB);
        DA_HEADREC.ASLNAME.TXT=' ';
        DA_HEADREC.ASLNAME.CNT=0;
 
     CASE(%TCB);
        CALL CHARBIN(IND,P_OUT$BLK.SUBLK$(0)->OUT$SYM.TEXT);
        DA_HEADREC.TCBSIZE=IND;
 
     CASE(%HEADBITS);
        IF P_OUT$BLK.NSUBLKS=2 THEN
            IF P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE=%ON THEN
                FLAG=%TRUE;
            ELSE
                FLAG=%FALSE;
        ELSE
            FLAG=%TRUE;
 
        DO CASE(P_OUT$BLK.SUBLK$(0)->OUT$BLK.CODE);
         CASE(%SHAREABLE);
            DA_HEADREC.S=FLAG;
         CASE(%NSHAREABLE);
            DA_HEADREC.S=~FLAG;
         CASE(%STDINVOC);
            DA_HEADREC.NSTDINVOC=FLAG;
         CASE(%PROCACC);
            DA_HEADREC.PROCACC=FLAG;
         CASE(%NOCHGPMEM);
            DA_HEADREC.NOCHGPMEM=FLAG;
         CASE(%SURCHARGE);
            DA_HEADREC.PROCSURCHG=FLAG;
         CASE(%LAUTO);
            DA_HEADREC.LAUTO=FLAG;
        END; /* CASE                                                          */
 
     CASE(%WLOCK);
        DA_HEADREC.STRONG_LOCK=%FALSE;
        IF P_OUT$BLK.NSUBLKS=2 THEN
            IF P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE=%ON THEN
                FLAG=%TRUE;
            ELSE
                FLAG=%FALSE;
        ELSE
            FLAG=%TRUE;
 
        BLK$=P_OUT$BLK.SUBLK$(0);
        DO I=0 TO OUT$BLK.NSUBLKS-1;
            CALL CHARBIN(IND,OUT$BLK.SUBLK$(I)->OUT$SYM.TEXT);
            IF IND<1 OR IND>72 THEN DO;
                CALL ERRMSG(%E$LOCK_RANGE);
/*E*
ERROR:  GI-E$LOCK_RANGE-0
MESSAGE:Locks must be nubmered between 1 and 72.
*/
                GOTO RET;
                END;
            DA_HEADREC.LOCK(IND-1)=FLAG;
            END; /* I                                                         */
 
     CASE(%SLOCK);
        DA_HEADREC.STRONG_LOCK=%TRUE;
        IF P_OUT$BLK.NSUBLKS=2 THEN
            IF P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE=%ON THEN
                FLAG=%TRUE;
            ELSE
                FLAG=%FALSE;
        ELSE
            FLAG=%TRUE;
 
        BLK$=P_OUT$BLK.SUBLK$(0);
        DO I=0 TO OUT$BLK.NSUBLKS-1;
            CALL CHARBIN(IND,OUT$BLK.SUBLK$(I)->OUT$SYM.TEXT);
            IF IND<1 OR IND>72 THEN DO;
                CALL ERRMSG(%E$LOCK_RANGE);
                GOTO RET;
                END;
            DA_HEADREC.LOCK(IND-1)=FLAG;
            END; /* I                                                         */
 
     CASE(%PRIVS);
        IF P_OUT$BLK.NSUBLKS=2 THEN
            IF P_OUT$BLK.SUBLK$(1)->OUT$BLK.CODE=%ON THEN
                FLAG=%TRUE;
            ELSE
                FLAG=%FALSE;
        ELSE
            FLAG=%TRUE;
 
        BLK$=P_OUT$BLK.SUBLK$(0);
        DO I=0 TO BLK$->OUT$BLK.NSUBLKS-1;
            IND=BLK$->OUT$BLK.SUBLK$(I)->OUT$BLK.CODE;
            IF IND=36 THEN
                CALL CHARBIN(IND,BLK$->OUT$BLK.SUBLK$(I)->OUT$SYM.TEXT);
            IF IND>35 THEN DO;
                BLK$=BLK$->OUT$BLK.SUBLK$(I);
                CALL ERRPTR(%E$0_TO_35,,BLK$->OUT$BLK.CPOS);
/*E*
ERROR:  GI-E$0_TO_35-0
MESSAGE:Privlege bits must be between 0 and 35.  Ignored.
*/
                GOTO NEXTI;
                END;
 
            ADDR(DA_HEADREC.PRIV)->B$PRIVS.BITS(IND)=FLAG;
NEXTI:      END;
    END; /* CASE                                                              */
 
RET: RETURN;
 
END HEAD_CMDS;
%EJECT;
ESP_CMDS: PROC (P_OUT$BLK) ALTRET;
 
%PARSE$OUT(NAME=P_OUT$BLK,STCLASS=PARAM);
 
/* Library Stuff */
%INCLUDE B_SEGIDS_C;
 
%B$EXCFR;
%B$RUBIRTHKEY(STCLASS=CONSTANT);
%B$RUBIRTH(STCLASS=STATIC);
 
 DCL 1 PATCH_INFO,
       2 OLD_DP_SIZE SBIN,
       2 NEW_DP_SIZE SBIN,
       2 OLD_IP_SIZE SBIN,
       2 NEW_IP_SIZE SBIN;
 DCL P$ PTR;
 
%EJECT;
/*       Initialization */
    PATCH_INFO = '0'B;
/*       Determine if program is overlayed */
    IF DA_HEADREC.OVRL THEN DO;
        CALL ERRMSG(%E$OVRL);
/*E*
ERROR:  GI-E$OVRL-0
MESSAGE:This run unit is overlaid.  Can't add patch space.
*/
        GOTO RET;
        END /* OVRL */;
/*       If RU has been modified (RUM'ed), quit. */
    CALL READ_REC(VECTOR(B$RUBIRTH),B$RUBIRTHKEY) ALTRET(ALT);
    IF B$RUBIRTH.RUMED_UTS ~= 0 THEN DO;
        CALL ERRMSG(%E$NOTVIRGIN);
/*E*
ERROR:  GI-E$NOTVIRGIN-0
MESSAGE:This run unit has been modified.  No patch space will be added.
*/
        GOTO RET;
        END /* RUMed */;
 
/*       Perform routine(s) to increase appropriate space(s) */
    DO CASE(P_OUT$BLK.CODE);
     CASE(%DPATCH);
        CALL DATA_PATCH  ALTRET(ALT);
     CASE(%IPATCH);
        CALL INSTR_PATCH ALTRET(ALT);
     CASE(%PATCHS);
        CALL INSTR_PATCH ALTRET(ALT);
        CALL DATA_PATCH  ALTRET(ALT);
    END;
 
RET: RETURN;
ALT: ALTRETURN;
 
%EJECT;
INSTR_PATCH: PROC ALTRET;
 
%B$EDEF;
 DCL IBASE SBIN;
 DCL HDR_SIZE UBIN;
 
/*       Get Instruction Patch Header */
    CALL GET_SYM_HDR_INFO(IPATCHDR,B_PATCHIH)
    WHENALTRETURN DO;
        CALL ERRMSG(%E$NOIPATCH);
/*E*
ERROR:  GI-E$NOIPATCH-0
MESSAGE:No instruction patch space was found in this run unit.
*/
        GOTO RET;
        END /* WHENALTRETURN */;
/*       Remember current size of instruction patch space */
    PATCH_INFO.OLD_IP_SIZE = IPATCHDR.SIZE;
/*       Determine starting address of instructions */
    IF DA_HEADREC.RDATA = 0 THEN
        IBASE = DBSE;
    ELSE
        IF DA_HEADREC.LIB THEN
            IBASE = SHARE_LIB_START;
        ELSE
            IBASE = DBSE + ((DA_HEADREC.RDATA - 1) / RUSEGLEN + 1) * RUSEGLEN;
/*       Set upper bound on memory */
    IF DA_HEADREC.LIBNAME.CNT = 0 THEN
        IBOUND = MEM_LIMIT;
    ELSE
        IBOUND = SHARE_LIB_START;
/*       Determine size of RU header for patch space(s) */
    IF DPH$=ADDR(NIL) THEN
        IF GI_FLAVOR = %HOST_RU THEN /* Instructions Only                     */
            HDR_SIZE = 2; /* HOST                                             */
        ELSE
            HDR_SIZE = 3; /* FEP                                              */
    ELSE
        IF GI_FLAVOR = %HOST_RU THEN /* Instructions and Data                 */
            HDR_SIZE = 4; /* HOST                                             */
        ELSE
            HDR_SIZE = 6; /* FEP                                              */
/*       Determine where current IPATCH space is located */
    PATCH_INFO.NEW_IP_SIZE = IPATCHDR.SIZE;
    IF IPATCHDR.OFF+IPATCHDR.SIZE-IBASE+HDR_SIZE = DA_HEADREC.RPROC THEN DO;
/*           IPATCH space after instructions and before patch hdr ptrs */
/*           Move instr hdr to beginning of instr patch space */
        CALL ZERO_OLD_RU_HDR(PATCHIH) ALTRET(ALT);
        IPH$->B$SDEF.AD.ISADDR = IPATCHDR.OFF;
        IPATCHDR.OFF = IPATCHDR.OFF + HDR_SIZE;
        IF GI_FLAVOR = %HOST_RU THEN
            IPATCHDR.HP.OFF = IPATCHDR.OFF;
        ELSE
            IPATCHDR.FP# = IPATCHDR.OFF;
        CALL MODIFY_COPY(IPH$,DA_SYMDEF_);
/*           See if data patch space needs munged also */
        IF DPH$ ~= ADDR(NIL) THEN DO; /* There is DP space                    */
/*               Clear data patch RU pointers */
            CALL GET_SYM_HDR_INFO(DPATCHDR,PATCHDH) ALTRET(ALT);
            CALL ZERO_OLD_RU_HDR(PATCHDH) ALTRET(ALT);
/*               Adjust sym def pointer to point to new RU location of DP hdr */
            DPH$->B$SDEF.AD.ISADDR = IPATCHDR.OFF - HDR_SIZE / 2;
            CALL MODIFY_COPY(DPH$,DA_SYMDEF_);
/*               Move info to the new hdr in RU */
            CALL WRPHDR(DPATCHDR,PATCHDH);
            END;
/*           Store changes to patch hdr symdef entries */
        CALL WRITE_REC(DA_SYMDEF_,SYMDEF_KEY) ALTRET(ALT);
/*           Mark changes in B_PATCHI symbol def also */
        CALL DAS$EDSRCH(B_PATCHI,P$);
        P$->B$EDEF.ISADDR = IPATCHDR.OFF;
        CALL MODIFY_COPY(P$,DA_ENTDEF_);
        CALL WRITE_REC(DA_ENTDEF_,ENTDEF_KEY) ALTRET(ALT);
        END;
    ELSE
        IF IPATCHDR.OFF+IPATCHDR.SIZE-IBASE ~= DA_HEADREC.RPROC THEN DO;
/*           IPATCH space not after instructions, move it if possible */
            IF IBASE+DA_HEADREC.RPROC+MOD(DA_HEADREC.RPROC,2)+IPATCHDR.SIZE >=
              IBOUND THEN GOTO ISDONE;
            PATCH_INFO.NEW_IP_SIZE = 0;
            CALL MOVEPATCHSPACE(IPATCHDR,
              ENTDEF_KEY,
              IBASE+DA_HEADREC.RPROC,
              PATCHI) ALTRET(ALT);
            END;
/*       Loop around allocating space until new space is at least as large as */
/*       the previous IPATCH space                                            */
    RUREC = '0'B;
IWHLP: DO WHILE PATCH_INFO.NEW_IP_SIZE <= PATCH_INFO.OLD_IP_SIZE;
        IF MOD(DA_HEADREC.RPROC,RUPAGLEN) = 0 THEN DO; /* Allocate 1 page     */
            IF IBASE+DA_HEADREC.RPROC = IBOUND THEN GOTO ISDONE;
/*               More space, keep on allocat'en */
            PATCH_INFO.NEW_IP_SIZE = PATCH_INFO.NEW_IP_SIZE + RUPAGLEN;
            IF GI_FLAVOR = %HOST_RU OR
              MOD(DA_HEADREC.RPROC,RURECLEN) = 0 THEN DO;
/*                   Write a new page */
                RU_KEY.OFF# = IBASE+DA_HEADREC.RPROC;
                CALL WRITE_REC(RUREC_,RU_KEY,4096);
                END;
            DA_HEADREC.RPROC = DA_HEADREC.RPROC + RUPAGLEN;
            DA_HEADREC.VPPGS = DA_HEADREC.VPPGS + 1;
            END; /* Whole page                                                */
        ELSE DO; /* Allocate a partial page                                   */
            RU_KEY.OFF# = (IPATCHDR.OFF+PATCH_INFO.NEW_IP_SIZE)/ RURECLEN
              * RURECLEN;
            PATCH_INFO.NEW_IP_SIZE = PATCH_INFO.NEW_IP_SIZE +
              RUPAGLEN - MOD( PATCH_INFO.NEW_IP_SIZE+IPATCHDR.OFF,RUPAGLEN);
            DA_HEADREC.RPROC = DA_HEADREC.VPPGS * RUPAGLEN;
            CALL READ_REC(RUREC_,RU_KEY) ALTRET(ALT);
            CALL WRITE_REC(RUREC_,RU_KEY,4096) ALTRET(ALT);
            RUREC = '0'B;
            END; /* Partial page                                              */
        END; /* WHILE                                                         */
 
    IPATCHDR.SIZE = PATCH_INFO.NEW_IP_SIZE;
    CALL WRPHDR(IPATCHDR,PATCHIH) ALTRET(ALT);
 
RET: RETURN;
ISDONE: ;
    CALL ERRMSG(%E$ISDONE);
/*E*
ERROR:  GI-E$ISDONE-0
MESSAGE:This run unit ends at 256K.  Can't add patch space.
*/
ALT: ALTRETURN;
 
%EJECT;
ZERO_OLD_RU_HDR: PROC (PATCH_SYM) ALTRET;
 
 DCL 1 PATCH_SYM,
       2 L UBIN BYTE        CALIGNED,
       2 * CHAR(PATCH_SYM.L) CALIGNED;
 
%PATCH_HDR(NAME=ZERO_HDR,STCLASS=AUTO);
 
    ZERO_HDR.FP# = 0;
    ZERO_HDR.SIZE = 0;
 
    CALL WRPHDR(ZERO_HDR,PATCH_SYM)
    WHENALTRETURN DO;
        ALTRETURN;
        END;
 
END ZERO_OLD_RU_HDR;
END INSTR_PATCH;
%EJECT;
DATA_PATCH: PROC ALTRET;
/*       Determine if RU is shared library */
    IF DA_HEADREC.LIB THEN DO;
        CALL ERRMSG (%E$LIB);
/*E*
ERROR:  GI-E$LIB-0
MESSAGE:This is a shared library.  No data patch will be added.
*/
        GOTO RET;
        END;
/*       Get Data Patch Header */
    CALL GET_SYM_HDR_INFO(DPATCHDR,PATCHDH)
    WHENALTRETURN DO;
        CALL ERRMSG(%E$NODPATCH);
/*E*
ERROR:  GI-E$NODPATCH-0
MESSAGE:No data patch space was found in this run unit.
*/
        GOTO RET;
        END /* WHENALTRETURN */;
    PATCH_INFO.OLD_DP_SIZE = DPATCHDR.SIZE;
/*       See if any data space left */
    IF MOD(DA_HEADREC.RDATA,RUSEGLEN) = 0 THEN GOTO RET;
/*       See if data patch space is linked in (not simply a LINK option) */
    IF DPATCHDR.OFF+DPATCHDR.SIZE-DBSE ~= DA_HEADREC.RDATA THEN DO;
/*           Data space linked in as on OU */
/*           See if linked in space > space remaining at end of page in DS. */
        IF RUSEGLEN-MOD(DA_HEADREC.RDATA,RUSEGLEN)-MOD(DA_HEADREC.RDATA,2) <=
          DPATCHDR.SIZE THEN GOTO RET; /* Linked in space > leftover page     */
/*           Leftover page > linked space.  Move data patch space */
        CALL MOVEPATCHSPACE(DPATCHDR,
          SYMDEF_KEY,
          DBSE+DA_HEADREC.RDATA,
          PATCHD) ALTRET(ALT);
        END /* MOVE PATCH SPACE */;
    ELSE
        PATCH_INFO.NEW_DP_SIZE = PATCH_INFO.OLD_DP_SIZE;
/*       Increase and remember data patch space */
    RUREC = '0'B;
DWHLP: DO WHILE PATCH_INFO.NEW_DP_SIZE <= PATCH_INFO.OLD_DP_SIZE;
        IF MOD(DA_HEADREC.RDATA,RUPAGLEN) = 0 THEN DO; /* Allocate a page     */
            IF MOD(DA_HEADREC.RDATA,RUSEGLEN) = 0 THEN EXIT DWHLP;
            PATCH_INFO.NEW_DP_SIZE = PATCH_INFO.NEW_DP_SIZE + RUPAGLEN;
            IF GI_FLAVOR = %HOST_RU OR
              MOD(DA_HEADREC.RDATA,RUPAGLEN) = 0 THEN DO;
 /* Write a page                                                              */
                RU_KEY.OFF# = DBSE+DA_HEADREC.RDATA;
                CALL WRITE_REC(RUREC_,RU_KEY,4096);
                END;
            DA_HEADREC.RDATA = DA_HEADREC.RDATA + RUPAGLEN;
            DA_HEADREC.VDPGS = DA_HEADREC.VDPGS + 1;
            END;
        ELSE DO; /* Allocate partial page                                     */
            RU_KEY.OFF# = (DPATCHDR.OFF+PATCH_INFO.NEW_DP_SIZE)/ RURECLEN
              * RURECLEN;
            PATCH_INFO.NEW_DP_SIZE = PATCH_INFO.NEW_DP_SIZE +
              RUPAGLEN - MOD( PATCH_INFO.NEW_DP_SIZE+DPATCHDR.OFF,RUPAGLEN);
            DA_HEADREC.RDATA = DA_HEADREC.VDPGS * RUPAGLEN;
            CALL READ_REC(RUREC_,RU_KEY) ALTRET(ALT);
            CALL WRITE_REC(RUREC_,RU_KEY,4096);
            RUREC = '0'B;
            END;
        END;
 
    DPATCHDR.SIZE = PATCH_INFO.NEW_DP_SIZE;
    CALL WRPHDR(DPATCHDR,PATCHDH) ALTRET(ALT);
 
RET: RETURN;
ALT: ALTRETURN;
 
END DATA_PATCH;
%EJECT;
MOVEPATCHSPACE: PROC(PATCHDR,KEY,LOC,PATCH_SYM) ALTRET;
 
%PATCH_HDR(NAME=PATCHDR,STCLASS=PARAM);
 DCL 1 KEY,
       2 L UBIN BYTE UNAL,
       2 * CHAR(KEY.L) CALIGNED;
 DCL LOC UBIN;
 DCL 1 PATCH_SYM,
       2 L UBIN BYTE UNAL,
       2 * CHAR(PATCH_SYM.L) CALIGNED;
 
 DCL I UBIN;
 DCL P$ PTR;
 DCL V_ VECTOR STATIC INIT(VECTOR(NIL));
 
/*       If moving instr. space, use ENT PT srch routines */
    IF PATCH_SYM = PATCHI THEN DO;
        CALL DAS$EDSRCH(PATCH_SYM,P$);
        V_ = DA_ENTDEF_;
        END /* IF */;
    ELSE DO;
/*           Use SYM srch routines */
        CALL DAS$SDSRCH(PATCH_SYM,P$);
        V_ = DA_SYMDEF_;
        END /* ELSE */;
 
/*       Set patch space pointer */
    I = LOC + MOD(LOC,2);
    IF GI_FLAVOR = %HOST_RU THEN
        PATCHDR.HP.OFF = I;
    ELSE
        PATCHDR.FP# = I;
    PATCHDR.OFF = I;
    P$->B$SDEF.AD.ISADDR = I;
/*       Modify duplicate pointers */
    CALL MODIFY_COPY(P$,V_);
/*       Write out updated def record */
    CALL WRITE_REC(V_,KEY)
    WHENALTRETURN DO;
        ALTRETURN;
        END;
 
END MOVEPATCHSPACE;
%EJECT;
MODIFY_COPY: PROC (P$,V_);
 
 DCL P$  PTR;
 DCL V_  VECTOR;
 
 DCL LEN UBIN STATIC INIT(SIZEW(B$SDEF));
 
/*       Adjust the other copy of the B$SDEF structure that exists for        */
/*       certain symbols in the symdef and entdef records.                    */
 
    IF PINCRW(P$,LEN) < PINCRC(VBASE(V_),VBOUND(V_)+1) AND
      PINCRW(P$,LEN)->B$SDEF.NPOINTER = P$->B$SDEF.NPOINTER THEN
        PINCRW(P$,LEN)->B$SDEF.AD.ISADDR = P$->B$SDEF.AD.ISADDR;
    ELSE
        IF P$ > VBASE(V_) AND
          PINCRW(P$,-LEN)->B$SDEF.NPOINTER = P$->B$SDEF.NPOINTER THEN
            PINCRW(P$,-LEN)->B$SDEF.AD.ISADDR = P$->B$SDEF.AD.ISADDR;
 
END MODIFY_COPY;
%EJECT;
WRPHDR: PROC (PATCHDR,PATCH_SYM) ALTRET;
 
%PATCH_HDR(NAME=PATCHDR,STCLASS=PARAM);
 DCL 1 PATCH_SYM,
       2 L UBIN BYTE        CALIGNED,
       2 * CHAR(PATCH_SYM.L) CALIGNED;
 
 DCL I UBIN;
 DCL H$ PTR;
 DCL ZERO BIT(18) CONSTANT INIT('000000'O);
 
    IF PATCH_SYM = PATCHDH THEN
        H$ = DPH$;
    ELSE
        H$ = IPH$;
/*       Store information into RU recs */
    RU_KEY.OFF# = H$->B$SDEF.AD.ISADDR / RURECLEN * RURECLEN;
    CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
    I = MOD(H$->B$SDEF.AD.ISADDR,RURECLEN);
    IF GI_FLAVOR = %HOST_RU THEN /* HOST                                      */
        RUREC.PARY$(I) = PATCHDR.HP$;
    ELSE DO;/* FEP                                                            */
        RUREC.FARY(I) = ZERO; /* Zero out bits                                */
        RUREC.FARY.H(I) = PATCHDR.FP.ARY(0);
        RUREC.FARY.L(I) = PATCHDR.FP.ARY(1);
        END;
    IF I = RURECLEN-1 THEN DO; /* Split hdr 'tween 1st and 2nd word           */
        CALL WRITE_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
        RU_KEY.OFF# = RU_KEY.OFF# + RURECLEN;
        CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
        IF GI_FLAVOR = %HOST_RU THEN /* HOST                                  */
            RUREC.HARY(0) = PATCHDR.SIZE;
        ELSE DO; /* FEP                                                       */
            RUREC.FARY(0) = ZERO; /* Zero out bits                            */
            RUREC.FARY.H(0) = PATCHDR.FP.ARY(2);
            RUREC.FARY.L(0) = PATCHDR.FP.ARY(3);
            RUREC.FARY(1) = ZERO; /* Zero out bits                            */
            RUREC.FARY.H(1) = PATCHDR.SZE.H;
            RUREC.FARY.L(1) = PATCHDR.SZE.L;
            END;
        END /* SPLIT HDR */;
    ELSE /* Don't split hdr 'tween 1st and 2nd words                          */
        IF GI_FLAVOR = %HOST_RU THEN /* HOST                                  */
            RUREC.HARY(I+1) = PATCHDR.SIZE;
        ELSE DO; /* FEP                                                       */
            RUREC.FARY(I+1) = ZERO; /* Zero out bits                          */
            RUREC.FARY.H(I+1) = PATCHDR.FP.ARY(2);
            RUREC.FARY.L(I+1) = PATCHDR.FP.ARY(3);
            IF I+1 = RURECLEN-1 THEN DO; /* Split hdr 'tween 2nd & 3rd words  */
                CALL WRITE_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
                RU_KEY.OFF# = RU_KEY.OFF# + RURECLEN;
                CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
                RUREC.FARY(0) = ZERO; /* Zero out bits                        */
                RUREC.FARY.H(0) = PATCHDR.SZE.H;
                RUREC.FARY.L(0) = PATCHDR.SZE.L;
                END;
            ELSE DO;
                RUREC.FARY(I+2) = ZERO; /* Zero out bits                      */
                RUREC.FARY.H(I+2) = PATCHDR.SZE.H;
                RUREC.FARY.L(I+2) = PATCHDR.SZE.L;
                END;
            END;
 
    CALL WRITE_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
 
    RETURN;
ALT: ALTRETURN;
 
END WRPHDR;
END ESP_CMDS;
%EJECT;
GET_SYM_HDR_INFO: PROC (PATCHDR,PATCH_SYM) ALTRET;
 
%PATCH_HDR(NAME=PATCHDR,STCLASS=PARAM);
 DCL 1 PATCH_SYM,
       2 L UBIN BYTE        CALIGNED,
       2 * CHAR(PATCH_SYM.L) CALIGNED;
 
 DCL H$ PTR;
 DCL I UBIN;
 
/*       If symbol marked removed, altret this baby */
    IF PATCH_SYM = PATCHDH THEN
        H$ = DPH$;
    ELSE
        H$ = IPH$;
 
/*      Make sure symbol is exists and is valid */
    IF H$ = ADDR(NIL) OR /* No header */ NOT DA_HEADREC.LIB AND
      H$->B$SDEF.AD.LFLAGS.SOURCE=%SOURCE_REMOVED# /* Invalid Sym             */
    THEN GOTO ALT;
 
/*       Get symbol header information */
    RU_KEY.OFF# = H$->B$SDEF.AD.ISADDR / RURECLEN * RURECLEN;
    CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
    I = MOD(H$->B$SDEF.AD.ISADDR,RURECLEN);
    IF GI_FLAVOR = %HOST_RU THEN DO; /* HOST                                  */
        PATCHDR.HP$ = RUREC.PARY$(I);
        PATCHDR.OFF = PATCHDR.HP.OFF;
        IF I = RURECLEN-1 THEN DO; /* Split hdr                               */
            RU_KEY.OFF# = RU_KEY.OFF# + RURECLEN;
            CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
            PATCHDR.SIZE = RUREC.HARY(0);
            END /* SPLIT HDR */;
        ELSE /* Non-split hdr                                                 */
            PATCHDR.SIZE = RUREC.HARY(I+1);
        END; /* HOST                                                          */
    ELSE DO; /* FEP (hold onto you hats, 'cause this is a real bitch          */
        PATCHDR.FP# = 0; /* Clear upper 4 bits                                */
        PATCHDR.SIZE = 0; /* Clear upper 20 bits                              */
        PATCHDR.FP.ARY(0) = RUREC.FARY.H(I);
        PATCHDR.FP.ARY(1) = RUREC.FARY.L(I);
        IF I = RURECLEN-1 THEN DO; /* Hdr split between 1st and 2nd word      */
            RU_KEY.OFF# = RU_KEY.OFF# + RURECLEN;
            CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
            PATCHDR.FP.ARY(2) = RUREC.FARY.H(0);
            PATCHDR.FP.ARY(3) = RUREC.FARY.L(0);
            PATCHDR.SZE.H = RUREC.FARY.H(1);
            PATCHDR.SZE.L = RUREC.FARY.L(1);
            END /* SPLIT HDR */;
        ELSE DO; /* Hdr not split 'tween 1st and 2nd words                    */
            PATCHDR.FP.ARY(2) = RUREC.FARY.H(I+1);
            PATCHDR.FP.ARY(3) = RUREC.FARY.L(I+1);
            IF I+1 = RURECLEN-1 THEN DO; /* Hdr split 'tween 2nd and 3rd words */
                RU_KEY.OFF# = RU_KEY.OFF# + RURECLEN;
                CALL READ_REC(RUREC_,RU_KEY,RUREC_ARS) ALTRET(ALT);
                PATCHDR.SZE.H = RUREC.FARY.H(0);
                PATCHDR.SZE.L = RUREC.FARY.L(0);
                END;
            ELSE /* Non-split hdr                                             */
                PATCHDR.SZE.H = RUREC.FARY.H(I+2);
            PATCHDR.SZE.L = RUREC.FARY.L(I+2);
            END;
        PATCHDR.OFF = PATCHDR.FP#;
        END; /* FEP                                                           */
 
    RETURN;
ALT: ALTRETURN;
 
END GET_SYM_HDR_INFO;
%EJECT;
READ_REC: PROC(IOBUF_,KEY,ARS) ALTRET;
 
 DCL IOBUF_ VECTOR;
 DCL 1 KEY,
       2 L UBIN(9)    CALIGNED,
       2 * CHAR(KEY.L) CALIGNED;
 DCL ARS UBIN;
 
%FPT_READ (DCB=M$RU,
    KEYS=YES);
 
    FPT_READ.KEY_ = VECTOR(KEY);
    FPT_READ.BUF_ = IOBUF_;
 
    CALL M$READ(FPT_READ)
    WHENALTRETURN DO;
        CALL ERRMSG;
        ALTRETURN;
        END;
 
    IF ADDR(ARS) ~= ADDR(NIL) THEN ARS = DCBADDR(DCBNUM(M$RU))->F$DCB.ARS#;
 
END READ_REC;
%EJECT;
WRITE_REC: PROC(IOBUF_,KEY,ARS) ALTRET;
 
 DCL IOBUF_ VECTOR;
 DCL 1 KEY,
       2 L UBIN(9)    CALIGNED,
       2 * CHAR(KEY.L) CALIGNED;
 DCL ARS UBIN;
 
%FPT_WRITE(
    DCB=M$RU,
    ONEWKEY=YES);
 
    FPT_WRITE.KEY_ = VECTOR(KEY);
    FPT_WRITE.BUF_ = IOBUF_;
 
    IF ADDR(ARS) ~= ADDR(NIL) THEN FPT_WRITE.BUF_.BOUND = ARS - 1;
 
    CALL M$WRITE(FPT_WRITE)
    WHENALTRETURN DO;
        CALL ERRMSG;
        ALTRETURN;
        END;
 
END WRITE_REC;
END GIN;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*F*
NAME:   CONVERT
PURPOE: Convert numbers to characters in textc format.
*/
CONVERT: PROC(TEXTC,I);
 DCL 1 TEXTC,
       2 L UBIN(9) CALIGNED,
       2 C CHAR(31) CALIGNED;
 DCL I UBIN;
 DCL CHARS CHAR(32) STATIC;
 
 DCL J UBIN STATIC;
 
    CALL BINCHAR(CHARS,I);
J1: DO J=0 TO LENGTHC(CHARS)-1;
        IF SUBSTR(CHARS,J,1)~='0' THEN
            EXIT J1;
        END;
    IF J=LENGTHC(CHARS) THEN
        J=J-1;
    TEXTC.L=LENGTHC(CHARS)-J;
    TEXTC.C=SUBSTR(CHARS,J,TEXTC.L);
 
    RETURN;
END CONVERT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*D*
NAME:   ERRMSG
CALL:   CALL ERRMSG(ERR#,DCB#);
ENTRY:  CALL ERRPTR(ERR#,DCB#,CPOS);
INPUT:  ERR# - The error word or code.  Optional.  Default is B$TCB.
        DCB# - The DCB number.  Optional.  Default is M$RU.
        CPOS - The position to finger.  Optional.
DESCRIPTION:
    Forms a full word VLP_ERRMSG and issues the call to
    XUG_ERRMSG or XUG_ERRPTR accoudingly.
*/
ERRMSG: PROC(P_ERR,P_DCB#,P_CPOS);
%INCLUDE CP_6;
%F$DCB;
%B$TCB;
%B$ALT;
 
%VLP_ERRCODE(FPTN=GIERR,STCLASS=STATIC,
FCG='0711'O); /* 'GI'                                                         */
 
%INCLUDE XU_MACRO_C;
 %XUG_GETCMD(NAME=XUG_GETCMD,STCLASS=SYMREF);
%INCLUDE XUG_ENTRY;
 DCL B$TCB$ PTR SYMREF;
 DCL M$RU DCB;
 
 DCL 1 P_ERR,
       2 FCG BIT(18) HALIGNED,
       2 ERR# UBIN(18) HALIGNED;
 DCL P_DCB# UBIN;
 DCL P_CPOS UBIN;
 
 DCL FLAG BIT(1) STATIC;
 
    FLAG='1'B;
    GOTO COMMON;
 
ERRPTR: ENTRY(P_ERR,P_DCB#,P_CPOS);
    IF ADDR(P_CPOS)=ADDR(NIL) THEN
        XUG_GETCMD.USE_EPOS#='0'B;
    ELSE DO;
        XUG_GETCMD.USE_EPOS#='1'B;
        XUG_GETCMD.EPOS#=P_CPOS;
        END;
    FLAG='0'B;
 
COMMON: ;
 
    IF ADDR(P_ERR)=ADDR(NIL) THEN DO;
        XUG_GETCMD.ERR_CODE=B$TCB$->B$TCB.ALT$->B$ALT.ERR;
        XUG_GETCMD.ERRDCB#=B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
        END;
    ELSE DO;
        IF P_ERR.FCG THEN
            XUG_GETCMD.ERR_CODE=P_ERR;
        ELSE DO;
            XUG_GETCMD.ERR_CODE=GIERR;
            XUG_GETCMD.ERR_CODE.CODE#=P_ERR.ERR#;
            END;
        IF ADDR(P_DCB#)~=ADDR(NIL) THEN
            XUG_GETCMD.ERRDCB#=P_DCB#;
        ELSE
            XUG_GETCMD.ERRDCB#=DCBNUM(M$RU);
        END;
 
    IF ~FLAG THEN
        CALL XUG$ERRPTR(XUG_GETCMD);
    CALL XUG$ERRMSG(XUG_GETCMD);
RET:RETURN;
END ERRMSG;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
DAM$VPAGE: PROC(A,B,C,D,E) ALTRET;
/*F* NAME: DAM$VPAGE
     PURPOSE: Dummy entry to prevent having to haul in most of ANLZ
     just to use the DAS routines.
*/
 DCL A UBIN;
 DCL B UBIN;
 DCL C UBIN;
 DCL D UBIN;
 DCL E UBIN;
 
/* And a few data items that DAS refers to in ANLZ */
 
 DCL DA_INITIALIZED BIT(1) CONSTANT SYMDEF INIT('0'B);
 DCL DA_DFLT_RADIX UBIN STATIC SYMDEF INIT(8);
 DCL DA_WINDOWBASE UBIN CONSTANT SYMDEF INIT(0);
 
    RETURN;
END DAM$VPAGE;
