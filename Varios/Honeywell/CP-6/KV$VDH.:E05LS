

14:54 JUL 28 '97 KV$VDH.:E05SI                                             1    
    1      /*M* KV$VDH VDH-user to VDH request structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*F* NAME: KV_NAMTXT_VDH_FNC Names (in CHAR data type) of the KV_VDH_FNC EQUs */
    9      %MACRO KV_NAMTXT_VDH_FNC (NAME = KV_NAMTXT_VDH_FNC, LAST = ";", STCLASS = CONSTANT);
   10      %LSET LISTDIR = '0'B;
   11      %LSET LISTEXP = '1'B;
   12      %LSET LISTCOM = '0'B;
   13      %LSET LISTSUB = '1'B;
   14      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   15      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   16      %IF STC = 1;
   17      %LSET INIT = CHARTEXT(' INIT');
   18      %LSET ENIT = CHARTEXT('');
   19      %ELSE;
   20      %LSET INIT = CHARTEXT('/*');
   21      %LSET ENIT = CHARTEXT('*/');
   22      %ENDIF;
   23      DCL 1 NAME STCLASS,
   24      2 TXT_INT CALIGNED,
   25      3 * CHAR(26) %INIT('KV_VDH_FNC: none (0)')%ENIT  CALIGNED,
   26      3 * CHAR(26) %INIT('KV_VDH_FNC_CNC')%ENIT  CALIGNED,
   27      3 * CHAR(26) %INIT('KV_VDH_FNC_DAT')%ENIT  CALIGNED,
   28      3 * CHAR(26) %INIT('KV_VDH_FNC_DCLLCLPST')%ENIT  CALIGNED,
   29      3 * CHAR(26) %INIT('KV_VDH_FNC_DSC')%ENIT  CALIGNED,
   30      3 * CHAR(26) %INIT('KV_VDH_FNC: none')%ENIT  CALIGNED,
   31      3 * CHAR(26) %INIT('KV_VDH_FNC_EVT')%ENIT  CALIGNED,
   32      3 * CHAR(26) %INIT('KV_VDH_FNC_FNDINPTAB')%ENIT  CALIGNED,
   33      3 * CHAR(26) %INIT('KV_VDH_FNC_GETBFR')%ENIT  CALIGNED,
   34      3 * CHAR(26) %INIT('KV_VDH_FNC_GETPRM')%ENIT  CALIGNED,
   35      3 * CHAR(26) %INIT('KV_VDH_FNC_INT')%ENIT  CALIGNED,
   36      3 * CHAR(26) %INIT('KV_VDH_FNC_INTINPOPR')%ENIT  CALIGNED,
   37      3 * CHAR(26) %INIT('KV_VDH_FNC_OTPLCL')%ENIT  CALIGNED,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             2    
   38      3 * CHAR(26) %INIT('KV_VDH_FNC_OTPMRK')%ENIT  CALIGNED,
   39      3 * CHAR(26) %INIT('KV_VDH_FNC_PST')%ENIT  CALIGNED,
   40      3 * CHAR(26) %INIT('KV_VDH_FNC_RLSBFR')%ENIT  CALIGNED,
   41      3 * CHAR(26) %INIT('KV_VDH_FNC_RQSDAT')%ENIT  CALIGNED,
   42      3 * CHAR(26) %INIT('KV_VDH_FNC_SETCLK')%ENIT  CALIGNED,
   43      3 * CHAR(26) %INIT('KV_VDH_FNC_SETPRM')%ENIT  CALIGNED,
   44      3 * CHAR(26) %INIT('KV_VDH_FNC_SRCINPFNCID')%ENIT  CALIGNED,
   45      2 TXT(0:%KV_VDH_FNC_HI) REDEF TXT_INT CHAR(26) CALIGNED LAST
   46      %MEND;
   47      /*F* NAME: KV_NAMTXT_VDH_EVT_ID Names (in CHAR data type) of the KV_VDH_EVT_ID EQUs */
   48      %MACRO KV_NAMTXT_VDH_EVT_ID (NAME = KV_NAMTXT_VDH_EVT_ID, LAST = ";", STCLASS = CONSTANT);
   49      %LSET LISTDIR = '0'B;
   50      %LSET LISTEXP = '1'B;
   51      %LSET LISTCOM = '0'B;
   52      %LSET LISTSUB = '1'B;
   53      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   54      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   55      %IF STC = 1;
   56      %LSET INIT = CHARTEXT(' INIT');
   57      %LSET ENIT = CHARTEXT('');
   58      %ELSE;
   59      %LSET INIT = CHARTEXT('/*');
   60      %LSET ENIT = CHARTEXT('*/');
   61      %ENDIF;
   62      DCL 1 NAME STCLASS,
   63      2 TXT_INT CALIGNED,
   64      3 * CHAR(26) %INIT('KV_VDH_EVT_ID: none (0)')%ENIT  CALIGNED,
   65      3 * CHAR(26) %INIT('KV_VDH_EVT_ID_CMPOTP')%ENIT  CALIGNED,
   66      3 * CHAR(26) %INIT('KV_VDH_EVT_ID_RQSOTP')%ENIT  CALIGNED,
   67      3 * CHAR(26) %INIT('KV_VDH_EVT_ID_RLSVDI')%ENIT  CALIGNED,
   68      3 * CHAR(26) %INIT('KV_VDH_EVT_ID_ATN')%ENIT  CALIGNED,
   69      2 TXT(0:%KV_VDH_EVT_ID_HI) REDEF TXT_INT CHAR(26) CALIGNED LAST
   70      %MEND;
   71      /*F* NAME: VDI_VDH Overview
   72
   73      ..::L1 "VDH Concepts"
   74      A "protocol" is an understanding between two entities on the syntax,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             3    
   75      semantics, and sequence of control information exchanged between the
   76      entities.  This control information is usually passed as part of a
   77      data structure called a "message".
   78      ..::IX "Protocol"
   79      ..::IX "Message"
   80
   81      An "interface" directly connects two entities, usually by way of a
   82      call/return mechanism.  VDI (the Virtual Device Interface) is the
   83      interface between the device-oriented application/presentation entity (VDH, the
   84      Virtual Device Handler) and the device handlers themselves
   85      (VDH-users).  There is also an interface to the programmatic
   86      application/presentation entity (typically via monitor service calls) which is
   87      not described in this document.
   88      ..::IX "Interface"
   89      ..::IX "VDI"
   90      ..::IX "Virtual Device Handler"
   91
   92      The CP-6 network is the set of CP-6 communication entities exchanging control
   93      information prescribed by CP-6 protocols.  The virtual device
   94      handler (VDH) interfaces (via the virtual device interface) external
   95      entities (typically real device handlers) to the CP-6 network by
   96      translating the external entity's
   97      orders into application/presentation protocol elements (VDP, or Virtual Device
   98      Protocol) and session commands, and vice versa.
   99      ..::FG "CP-6 Upper-layer Architecture\35"
  100      }
  101      }            |                                         |
  102      }     __ ... ________                          ________________
  103      }     |      |      |                          |       |      |
  104      }     |         ALI |                    (VDI) | ALI          |
  105      } --------   |   --------   Application/    --------   |   --------
  106      }|Applica-|     | AL/PL  |  Presentation   | AL/PL  |     |  RDH   |
  107      }|tion    |  |  |        | <- Protocol --> | (VDH)  |  |  |        |
  108      } --------       --------                   --------       --------
  109      }            |      | | ^                      | ^ |       |      |
  110      }               SLI | | v Messages    Messages | v | SLI          |
  111      }            |   --------                   --------   |   --------
14:54 JUL 28 '97 KV$VDH.:E05SI                                             4    
  112      }               |   SL   | <-- Session --> |   SL   |     |  Real  |
  113      }            |  |        |    Protocol     |        |  |  | Device |
  114      }                --------                   --------       --------
  115      }            |      |                          |       |
  116      }                   . ^ |                      | ^ .
  117      }            |      . | Messages    Messages | .       |
  118      }                   . | v                      | v .
  119      }            |      _ |___________________________ |       |
  120      }
  121      }            |                                         |
  122      }
  123      }            |<------------ CP-6 Network ------------->|
  124      }
  125      }            |                                         |
  126      }
  127      }                               AL = Application layer
  128      }                               ALI = Application Layer Interface
  129      }                               PL = Presentation layer
  130      }                               RDH = Real Device Handler (VDH-user)
  131      }                               SL = Session layer
  132      }                               SLI = Session Layer Interface
  133      }                               VDH = Virtual Device Handler
  134      }                               VDI = Virtual Device Interface
  135      }
  136      ..::FG
  137      VDH provides multiple levels of abstraction from VDI to/from the
  138      session layer interface.  The level of abstraction used depends on
  139      the level of intimacy required
  140      between VDH and the user of VDH.  A card punch handler requires
  141      little.  The ASYNC handler requires much more.  The VDH-user must be
  142      isolated from the application and lower protocols, to allow for
  143      evolution of the protocols.
  144
  145      In Figure 2-1, the VDH AL/PL entity is doing most of the "work", including
  146      the more complex translations and the maintenance of detailed
  147      context.  To reduce future real device handler development and
  148      maintenance effort and costs, the VDH provides most of the device
14:54 JUL 28 '97 KV$VDH.:E05SI                                             5    
  149      handling functions that are otherwise common to various real device
  150      handlers.  As a result, the VDH to RDH interactions are more
  151      detailed and therefore more verbose (if expressed as a transmittable
  152      protocol) than the equivalent interactions (expressed in VDP as
  153      defined) that _ m_ u_ s_ t be transmittable.  These processes must
  154      be co-located to enable the VDH (in conjunction with the real device
  155      handler) to provide efficient, responsive support of the real
  156      device.  For the most part, VDH controls the activities of the
  157      application/presentation layer.  When a message is received from the distant
  158      CP-6 end, it is VDH that receives it, with the VDH-user having no
  159      visibility of the message.  The VDH-user cannot send a message; VDH
  160      sends messages as a result of an abstract request by the VDH-user,
  161      or as the result of receiving a message.  The VDH-user knows NOTHING
  162      about messages.  Often, when the VDH-user gets input data from a
  163      device, it simply passes the data to VDH which parses it and calls the
  164      VDH-user to do the primitive operations necessary for processing the
  165      input data.  When a message is received by VDH from the distant end,
  166      VDH abstracts the meaning of the message into the primitive
  167      operations understood by the VDH-user.  The VDH-user is often little
  168      more than a link handler.
  169
  170      The application/presentation layer entity closest to the application
  171      program (which can be in either the host or the FEP) is doing
  172      little more than a relatively simple translation of the
  173      application program's requests into VDP and vice versa; very little context
  174      is necessary.  Typically, the application is a user program doing
  175      M$READs and M$WRITEs, and the near AL/PL entity is contained in the
  176      operating system on which the program is running.
  177      ..::L2 "Using VDH"
  178      Some simple handlers may not need to use VDH.
  179      For example, the CP-6 program PIGLET allows a program in the host
  180      to access a floppy disk attached to the FEP without using VDH.  If all
  181      of the following conditions
  182      are met, VDH should not be used, but instead a user program
  183      communicating with the host via M$READ and M$WRITE monitor services
  184      should be used:
  185
14:54 JUL 28 '97 KV$VDH.:E05SI                                             6    
  186      .inl 4
  187      .unl 4
  188      1.  M$READ and M$WRITE are capable of exchanging with the host or FEP
  189      program all data and control information needed to support the
  190      handler's device.  For example, the host program and the device do
  191      not need host services such as the terminal control monitor services.
  192
  193      .unl 4
  194      2.  There is only one connection from the device to the host.
  195
  196      .unl 4
  197      3.  The number of devices supported is not large enough to cause
  198      excessive memory utilization in the FEP because of a large number of
  199      running users.
  200      .inl 0
  201
  202      Otherwise, VDH should probably be used.
  203
  204      While it is unlikely, it is possible that a CP-6 customer may need
  205      to provide the equivalent of the OSI network, link, and physical
  206      layers to connect two CP-6 FEPs together.  Doing so would require
  207      considerable knowledge of CP-6 FEP internal interfaces and protocols,
  208      a cursory overview of which follows.
  209
  210      VDH provides relatively direct access to the queues for handlers
  211      functioning as network layer entities.  The handler sends messages by
  212      calling the VDH routine KVM$SNDCQ, passing the argument structure
  213      KV$SNDCQ which allows the user to pass up to five buffers to be
  214      copied directly into the send circular queue.  When the handler is
  215      first making a connection to the transport layer, it send a KNH_MESS
  216      message containing the handler's circular-queue-handler-id in
  217      KNH_MESS.UIDX.CQ_HNDID.  Some CQ_HNDID values are defined in the
  218      KV$CQ_HNDID_E macro in the KV_GLBCNS_E include file.  When a message
  219      is received by VDH in the receive circular queue for this connection,
  220      VDH will call the handler, at the address contained in
  221      KV_CQ_HNDSBR$(KNH_MESS.UIDX.CQ_HNDID), which the handler is expected
  222      to have set up during its startup initialization.  The handler should
14:54 JUL 28 '97 KV$VDH.:E05SI                                             7    
  223      examine KNH_QHDR.RCQ.RPTR to locate the message to be processed.
  224      ..::L2 "VDI Perspective"
  225      VDI is described using the following terms:
  226
  227      Send - to send information from the local VDH to the distant VDH.
  228      .spf 0
  229      Note:  Occurrences of VDH are always (architecturally) paired.
  230
  231      Receive - to receive information at the local VDH from the distant
  232      VDH.
  233
  234      Input - data coming from the local device.
  235
  236      Output - data going to the local device.
  237
  238      Local - the nearer occurrence of VDH and the device handler.
  239
  240      Distant - the far end of the CP-6 network connection, e.g., the
  241      "Application" is at the distant end relative to VDH, and vice
  242      versa.
  243      .BRN 10
  244      ..::L2 "Coding Guidelines"
  245      Do not use explicitly pointer-qualified references to VDH's context
  246      unless necessary.  EQUs exist for most context structures that
  247      automatically provide the proper pointer qualification, and both
  248      simplify the RDH coder's task and protect the coder from changes
  249      in the future in how the context structures are located.
  250      Usually, when a context structure is declared and no NAME or
  251      STCLASS is specified, an EQU is generated whose name is xx_name
  252      for structure xx$name.  For example, to reference KV$VDI.PHSDSC,
  253      use %KV_VDI.PHSDSC, NOT KV$PTR$->KV$PTR.VDI$->KV$VDI.PHSDSC.
  254      (KV$PTR$ must be SYMREF'd from the library, not SYMDEF'd.)
  255      ..::L2 "Naming Conventions"
  256      Acronyms in VDH-related files are generally formed
  257      using the following abbreviation algorithm:
  258
  259      The object is to reduce English words to 3 characters.  For each word,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             8    
  260      from right to left,
  261
  262      .INL 4
  263      .UNL 4
  264      o    Change double characters to single (message -> mesage)
  265
  266      .UNL 4
  267      o    Delete vowels (mesage -> mesg -> msg)
  268
  269      .UNL 4
  270      o    Change  NT to T (except _NT... is _NT...), CK to K, and GH to H.
  271
  272      .UNL 4
  273      o    Delete consonants
  274
  275      .unl 4
  276      o    Append underscores to extend to three characters.
  277      .INL 0
  278
  279      The first character is never deleted.
  280
  281      The plural form is never used.
  282
  283      Common abbreviations are retained (e.g., central processing unit ->
  284      CPU)
  285
  286      Some common abbreviations for single words are left as is:
  287
  288      MAXIMUM -> MAX   not MXM
  289
  290      MINIMUM -> MIN   not MNM
  291
  292      HIGH -> HI  not HIH
  293
  294      INDEX -> X
  295
  296      Words with a distinct prefix are treated as two words; the prefix is
14:54 JUL 28 '97 KV$VDH.:E05SI                                             9    
  297      the first "word", and the root is the second.  Examples:
  298
  299      NON-RELEASABLE -> NONRLS
  300
  301      UNKNOWN -> UN_KNW
  302
  303      RE-TYPE -> RE_TYP
  304      ..::L2 "Guide to VDH INCLUDE Files"
  305      The following INCLUDE files may be of interest.  Many of them, with
  306      other files not in the following list, are contained in the PL-6
  307      system file KV_SYSTEMFILE.
  308
  309
  310      ..::TB "VDH Include Files\Module\#9\Contents"
  311      KV$GLB         Global structures and substructures
  312      KV$GLBCTX      Global context
  313      KV$INPFNC      Input function table structures and equates
  314      KV$INT         Translate table structures
  315      KV$USR         VDH to VDH-user request structures
  316      KV$VDH         VDH-user to VDH request structures
  317      KV$VDO         Presentation protocol definition
  318      KV_APLCHR_E    Equates for APL characters
  319      KV_ASCCHR_E    Equates for ASCII characters
  320      KV_EBCCHR_E    Equates for EBCDIC characters
  321      KV_GLBASM_E    ELSIE/CALF (assembler) compatible constants
  322      KV_GLBCNS_E    Constants
  323      KV_GLB_M       Macros
  324      KV_PRMID_E     Parameter ID definitions
  325      KV_PRMTBL_D    Parameter tables
  326      KV_TRNTBL_M    Translate table definitions
  327      ..::FG
  328      */
  329      /*F* NAME:  VDH_user_to_VDH Request Overview
  330
  331      To invoke VDH functions, the VDH-user calls KVV$VDI, passing as the
  332      only argument an FPT generated by a macro named KV$VDH_xx.  These FPTs
  333      and the VDH functions are described in this subsection.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             10   
  334      ..::IX "KVV$VDI"
  335
  336      The library contains CONSTANT copies of these structures
  337      with all default values for use by the RDH in initializing local
  338      copies, although their location is subject to change from release
  339      to release.
  340      The name of the CONSTANT copy is the same as the macro name, with
  341      the $ changed to _.  For example, the  user could specify:
  342
  343      .fif
  344         %KV$VDH_DAT (NAME = KV_VDH_DAT, STCLASS = SYMREF READONLY);
  345         %KV$VDH_DAT (STCLASS=AUTO);
  346         KV$VDH_DAT = KV_VDH_DAT;
  347         CALL KVV$VDI (KV$VDH_DAT);
  348      .fin
  349
  350      */
  351      /*F* NAME:  KV$VDH_CNC - Connect
  352
  353      VDH allocates and initializes session context (KV$SSN, etc.),
  354      initiates path creation, and (if specified) passes a logon
  355      string to the logon process.
  356      */
  357      %MACRO KV$VDH_CNC(NAME = KV$VDH_CNC, LAST = ";", STCLASS = BASED);
  358      %LSET LISTDIR = '0'B;
  359      %LSET LISTEXP = '1'B;
  360      %LSET LISTCOM = '0'B;
  361      %LSET LISTSUB = '1'B;
  362      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  363      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  364      %LSET INIT = CHARTEXT('INIT');
  365      %LSET ENIT = CHARTEXT('');
  366      %ELSE;
  367      %LSET INIT = CHARTEXT('/*');
  368      %LSET ENIT = CHARTEXT('*/');
  369      %ENDIF;
  370      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_CNC);
14:54 JUL 28 '97 KV$VDH.:E05SI                                             11   
  371      %KV$VECTOR(NAME = PRF_, LVL = 2, STCLASS = STCLASS, LAST = ",");
  372      /*K* PRF_ = VDH-vector (KV$VECTOR).  Profile vector.  This
  373      optional vector frames a profile structure
  374      to be applied before any textual I/O (e.g., salutation)
  375      occurs.  PRF_ is usually obtained from KH_PROFILE_.
  376      */
  377            2 * PTR %INIT(ADDR(NIL))%ENIT,
  378      /*N* Formerly VDI$, but currently unused. */
  379            2 LGN_ VECTOR %INIT(VECTOR(NIL))%ENIT,
  380      /*K* LGN_ = VECTOR.  Specifies a logon (string), if any exists. */
  381            2 SSNCNCINT BIT(1) UNAL %INIT('1'B)%ENIT,
  382      /*K* SSNCNCINT = VALUE-BIT(1).  Specifies ('1' B) that the local VDH
  383      is initiating the session connection, not receiving a session
  384      connection request.
  385      .spf 0
  386      Note:  The VDH-user should NOT modify this flag, but should simply
  387      use the value defaulted in the static version of this structure,
  388      which is a '1'B.
  389      */
  390            2 NEWSSN BIT(1) %INIT('0'B)%ENIT,
  391      /*K* NEWSSN = VALUE-BIT(1).  Specifies, if set, that the new
  392      connection is to be made
  393      using some of the context from the current one.  In particular,
  394      the stream is to be disassociated from the current one if
  395      the connection succeeds. */
  396            2 * BIT(6) %INIT('0'B)%ENIT,
  397            2 LINSPD UBIN BYTE CALIGNED %INIT(0)%ENIT,
  398      /*K* LINSPD = VALUE-DEC(0-15).  Specifies the line speed, using the units
  399      used by the asynchronous baud rate generator and the M$GLINEATTR
  400      monitor service.
  401      */
  402            %B$TERMINAL_ID (FPTN = LCLENDPNTID, LAST = ",", LVL = 2, ALGN = WALIGNED);
  403      /*K* LCLENDPNTID = B$TERMINAL_ID substructure.  Specifies the local
  404      (secondary network) end-point ID.  LCLENDPNTID is used in identifying
  405      what is logging on, and for later reference to what is logging on.
  406      The items subordinate to LCLENDPNTID
  407      are defined by B$TERMINAL_ID.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             12   
  408      */
  409            2 DSTNTWADR,
  410              3 * BIT(16) %INIT('0'B)%ENIT,
  411      /*K* DSTNTWADR = RLCID.  Specifies the distant (end) network
  412      address for this connection.  This is usually not known when using KV$VDH_CNC.
  413      */
  414              3 LDCTX UBIN WORD %INIT(0)%ENIT,
  415      /*K* DSTNTWADR.LDCTX = VALUE-DEC(0-65535).  Specifies the LDCTX to
  416      which a secondary session is to be connected.  LDCTX is used by VDH
  417      when SSNCNCINT = '0'B. */
  418            2 DSTNTWRSR CHAR(8) %INIT(' ')%ENIT LAST
  419      /*K* DSTNTWRSR = VALUE-CHAR(8).  Specifies the distant (end) network
  420      resource for this connection.  This is often 'LOGON'.
  421      */
  422      %MEND;
  423
  424      /*F* NAME:  KV$VDH_DAT - Accept Data
  425
  426      VDH accepts the associated data as input from the device.
  427      The data comprises one or more characters, a logical record, a block,
  428      or a completion code.
  429      Optionally specified (as appropriate) are
  430      a vector to the data, data buffer release instructions,
  431      error status, activation character, record identifier, VFC, etc.
  432      */
  433      %MACRO KV$VDH_DAT(NAME = KV$VDH_DAT, LVL = 1, LAST = ";", STCLASS = BASED,
  434      CMPCOD = 0,
  435      CNTFNCCHRS (YES='1'B, NO='0'B)='0'B,
  436      CTN (YES='1'B, NO='0'B) ='0'B,
  437      VDOVLPARY=,
  438      DATCTRCHRTYP = 0,
  439      DATMOD = 0,
  440      DATCTRCHR = ' ',
  441      HDR(YES='1'B, NO='0'B)='1'B);
  442      %LSET LISTDIR = '0'B;
  443      %LSET LISTEXP = '1'B;
  444      %LSET LISTCOM = '0'B;
14:54 JUL 28 '97 KV$VDH.:E05SI                                             13   
  445      %LSET LISTSUB = '1'B;
  446      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  447      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  448      %IF STC = 1;
  449      %LSET INIT = CHARTEXT('INIT');
  450      %LSET ENIT = CHARTEXT('');
  451      %ELSE;
  452      %LSET INIT = CHARTEXT('/*');
  453      %LSET ENIT = CHARTEXT('*/');
  454      %ENDIF;
  455      %LSET FEP = BITBIN(MODE_FEP);
  456      %LSET KA_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  457      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  458      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  459      %IF HDR;
  460      %KV$VDH_FNCHDR (NAME = NAME, LVL = LVL, STCLASS = STCLASS, FNC = KV_VDH_FNC_DAT);
  461      %ENDIF;
  462      %KV_FILBIT
  463            %(LVL+1) %CHARTEXT('CNTFNCCHRS') BIT(1) %INIT(CNTFNCCHRS)%ENIT,
  464      /*K* CNTFNCCHRS = {YES|NO}.
  465      Specifies whether to "Count (input)
  466      Function Characters".  CNTFNCCHRS=YES specifies that the count of
  467      characters processed as part, but not the first character, of an input
  468      escape sequence is to be tallied in KV$VDH_DAT.CMPCOD,
  469      for whatever purpose the caller wishes to make of that tally.
  470      The caller is responsible for reinitializing CMPCOD whenever that is desired.
  471      */
  472            %(LVL+1) %CHARTEXT('CTN') BIT(1) %INIT(CTN)%ENIT,
  473      /*K* CTN = {YES|NO}.
  474      Continue.  If CTN=YES, another block
  475      follows this block, and is logically
  476      part of the same group of data.  CTN is used only for block mode input.
  477      */
  478            %(LVL+1) %CHARTEXT('DATCTRCHRTYP') UBIN(2) %INIT(DATCTRCHRTYP)%ENIT UNAL,
  479      /*K* DATCTRCHRTYP = VALUE-DEC(0-3).
  480      Specifies the type of control character (if any) being passed.  EQUate
  481      identifiers for the DATCTRCHRTYP values are listed in the following
14:54 JUL 28 '97 KV$VDH.:E05SI                                             14   
  482      table.
  483      ..::TB "^\Identifier\#20\Meaning"
  484      .xeq KV$VDO KV_DATCTRCHRTYP_E DATCTRCHRTYP_ACT
  485      .xeq KV$VDO KV_DATCTRCHRTYP_E DATCTRCHRTYP_CNT
  486      .xeq KV$VDO KV_DATCTRCHRTYP_E DATCTRCHRTYP_NON
  487      .xeq KV$VDO KV_DATCTRCHRTYP_E DATCTRCHRTYP_VFC
  488      ..::TB
  489      */
  490            %(LVL+1) %CHARTEXT('DATMOD') UBIN(2) %INIT(DATMOD)%ENIT UNAL,
  491      /*K* DATMOD = VALUE-DEC(0-3).
  492      Specifies the mode of the data:  binary,
  493      transparent, or 'normal' (not binary or transparent).  EQUate identifiers for the DATMOD values are
  494      listed in the following table.
  495      ..::TB "^\Identifier\#15\Meaning"
  496      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_ANY
  497      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_BNR
  498      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_NRM
  499      .xeq KV_GLBCNS_E KV#DATMOD_E KV#DATMOD_TRN
  500      ..::TB
  501      */
  502            %(LVL+1) * BIT(1) %INIT('0'B)%ENIT,
  503      %LSET VDOVLP=LENGTHC(TEXTCHAR(VDOVLPARY))>0;
  504            %(LVL+1) VDOVLP BIT(1) %INIT(%VDOVLP)%ENIT,
  505      /*K* VDOVLP = VALUE-BIT(1).  Indicates to VDH that VDOVLPARY has been specified.
  506      */
  507      %LSET LVL1 = LVL+1;
  508      %KV$BFRDSC (NAME = DAT__, LVL = %LVL1, STCLASS = STCLASS, LAST = ",");
  509      /*K* DAT__ = KV$BFRDSC substructure.
  510      Specifies a VDH buffer descriptor
  511      describing the buffer containing the data.
  512      */
  513            %(LVL+1) %CHARTEXT('CMPCOD') UBIN BYTE UNAL %INIT(CMPCOD)%ENIT,
  514      /*K* CMPCOD = VALUE-DEC(0-255).
  515      Completion code.  EQUate identifiers for the CMPCOD values are listed in the following table.
  516      ..::TB "^\Identifier\#20\Meaning"
  517      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_BFRLMTEXC
  518      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_BFROVRRUN
14:54 JUL 28 '97 KV$VDH.:E05SI                                             15   
  519      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_CLS
  520      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DLT
  521      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DSC
  522      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DVCERR
  523      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_EOF
  524      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_NOTINP
  525      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_NRM
  526      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_PRTERR
  527      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_RATERR
  528      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_REDTIMOUT
  529      ..::TB
  530      */
  531      %IF NOT VDOVLP;
  532            %(LVL+1) %CHARTEXT('DATCTRCHR') CHAR(1) %INIT(DATCTRCHR)%ENIT LAST
  533      /*K* DATCTRCHR = VALUE-CHAR(1).
  534      Specifies the VFC or activation
  535      character, if any.
  536      */
  537      %ELSE;
  538            %(LVL+1) %CHARTEXT('DATCTRCHR') CHAR(1) %INIT(DATCTRCHR)%ENIT,
  539            %(LVL+1) VDOVLPARY$ PTR %INIT(ADDR(VDOVLPARY))%ENIT LAST
  540      /*K* VDOVLPARY = VARIABLE.  Initializes KV$VDH_DAT.VDOVLPARY$ to point
  541      to an array of pointers to VDOVLPs.  This is used only for record-mode
  542      input, when it is desired to attach things like MSGID to a record.
  543      The structure of the pointer array can be generated by invoking the
  544      KV$SND macro with HDR=NO and VLP=YES options.
  545      */
  546      %ENDIF;
  547      %MEND;
  548
  549      /*F* NAME:  KV$VDH_DCLLCLPST - Declare Local Position
  550
  551      The VDH-user uses KV$VDH_DCLLCLPST during block-mode input to inform
  552      VDH of the local position of the data that follow.  KV$VDH_DCLLCLPST
  553      does not cause any positioning to occur.
  554      */
  555
14:54 JUL 28 '97 KV$VDH.:E05SI                                             16   
  556      %MACRO KV$VDH_DCLLCLPST (NAME=KV$VDH_DCLLCLPST, CRSOFS=-1,
  557                              LAST=";", STCLASS=BASED);
  558      %LSET LISTDIR = '0'B;
  559      %LSET LISTEXP = '1'B;
  560      %LSET LISTCOM = '0'B;
  561      %LSET LISTSUB = '1'B;
  562      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  563      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  564      %LSET INIT = CHARTEXT('INIT');
  565      %LSET ENIT = CHARTEXT('');
  566      %ELSE;
  567      %LSET INIT = CHARTEXT('/*');
  568      %LSET ENIT = CHARTEXT('*/');
  569      %ENDIF;
  570      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_DCLLCLPST);
  571      %KV$PST (LVL=2, NAME=PHSPST, STCLASS=STCLASS, LAST=",");
  572      /*K* PHSPST = position (KV$PST substructure).  Specifies the physical position
  573      being declared.
  574      */
  575            2 %CHARTEXT('CRSOFS') SBIN %INIT(CRSOFS)%ENIT;
  576      /*K* CRSOFS = VALUE-DEC(-32768 - +32767).  Specifies the cursor position relative to
  577      PHSPST.
  578      */
  579      */
  580      %MEND;
  581
  582      /*F* NAME:  KV$VDH_DSC - Disconnect
  583
  584      VDH initiates a disconnect sequence.
  585      */
  586
  587      %MACRO KV$VDH_DSC (NAME=KV$VDH_DSC, LAST=";", STCLASS=BASED, RSN=0,
  588                    NO_IO(YES='1'B, NO='0'B)='0'B, ALLSSN(YES='1'B, NO='0'B)='0'B);
  589      %LSET LISTDIR = '0'B;
  590      %LSET LISTEXP = '1'B;
  591      %LSET LISTCOM = '0'B;
  592      %LSET LISTSUB = '1'B;
14:54 JUL 28 '97 KV$VDH.:E05SI                                             17   
  593      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  594      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  595      %LSET INIT = CHARTEXT('INIT');
  596      %LSET ENIT = CHARTEXT('');
  597      %ELSE;
  598      %LSET INIT = CHARTEXT('/*');
  599      %LSET ENIT = CHARTEXT('*/');
  600      %ENDIF;
  601      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_DSC);
  602              2 %CHARTEXT('RSN') UBIN BYTE CALIGNED %INIT(RSN)%ENIT,
  603      /*K* RSN = VALUE-DEC(0-255).  Reason for disconnect.  EQUate
  604      identifiers for the RSN values are listed in the following table.
  605      ..::TB "^\Identifier\#15\Meaning"
  606      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_FRG
  607      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_HRDERR
  608      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_LINDRP
  609      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_PRTERR
  610      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_PTH
  611      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_RSRSHR
  612      .xeq KV_GLBCNS_E KV_DSCRSN_E KV_DSCRSN_SFTERR
  613      ..::TB
  614      */
  615                2 %CHARTEXT('NO_IO') BIT(1) %INIT(NO_IO)%ENIT,
  616      /*K* NO_IO = {YES|NO}.  No IO.  NO_IO=YES means the VDH-user is not
  617      capable of any more I/O for this device.  For example, a line drop has
  618      occurred, or a device is no longer responding and is being dropped.
  619      */
  620                2 %CHARTEXT('ALLSSN') BIT(1) %INIT(ALLSSN)%ENIT,
  621      /*K* ALLSSN = {YES|NO}.  All sessions.  ALLSSN=YES means all sessions
  622      associated with this instance of VDI should be disconnected.
  623      */
  624                2 * BIT(14) %INIT('0'B)%ENIT LAST
  625      %MEND;
  626
  627      /*F* NAME:  KV$VDH_EVT - Event
  628
  629      The VDH-user passes an event ID to VDH by means of this function.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             18   
  630      */
  631
  632      %MACRO KV$VDH_EVT(NAME = KV$VDH_EVT, LAST = ";", STCLASS = BASED,
  633                        ID(KV_VDH_EVT_ID_CMPOTP = 1,
  634                           KV_VDH_EVT_ID_RQSOTP = 2,
  635                           KV_VDH_EVT_ID_RLSVDI = 3,
  636                           KV_VDH_EVT_ID_ATN = 4) = 0);
  637      %LSET LISTDIR = '0'B;
  638      %LSET LISTEXP = '1'B;
  639      %LSET LISTCOM = '0'B;
  640      %LSET LISTSUB = '1'B;
  641      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  642      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  643      %LSET INIT = CHARTEXT('INIT');
  644      %LSET ENIT = CHARTEXT('');
  645      %ELSE;
  646      %LSET INIT = CHARTEXT('/*');
  647      %LSET ENIT = CHARTEXT('*/');
  648      %ENDIF;
  649      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_EVT);
  650                2 %CHARTEXT('ID') UBIN BYTE CALIGNED %INIT(ID)%ENIT,
  651      /*K* ID = VALUE-DEC(0-255).  Event ID.  Identifies what event is being
  652      reported.  EQUate identifiers for Event IDs are as follows:
  653      ..::TB "^\Event ID\#10\Meaning\#"
  654      ..::IT "KV_VDH_EVT_ID_ATN"
  655      .xeq KV_GLBCNS_E KV__VDH_EVT KV_VDH_EVT_ID_ATN
  656      ..::IT "KV_VDH_EVT_ID_CMPOTP"
  657      .xeq KV_GLBCNS_E KV__VDH_EVT KV_VDH_EVT_ID_CMPOTP
  658      ..::IT "KV_VDH_EVT_ID_RLSVDI"
  659      .xeq KV_GLBCNS_E KV__VDH_EVT KV_VDH_EVT_ID_RLSVDI
  660      ..::IT "KV_VDH_EVT_ID_RQSOTP"
  661      .xeq KV_GLBCNS_E KV__VDH_EVT KV_VDH_EVT_ID_RQSOTP
  662      ..::TB
  663      */
  664                2 PRM UBIN WORD %INIT(0)%ENIT LAST
  665      /*K* PRM = VALUE-DEC(0-65535).  Parameter.  The meaning of this optional
  666      parameter is defined in the description of the event ID KV_VDH_EVT_ID_ATN.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             19   
  667      */
  668      %MEND;
  669
  670      /*F* NAME:  KV$VDH_GETBFR - Get Buffer
  671
  672      VDH gets a buffer for the user.
  673      */
  674
  675      %MACRO KV$VDH_GETBFR(NAME = KV$VDH_GETBFR, LAST = ";", STCLASS = BASED,
  676      BFR$ = NIL,
  677      BYTSIZ = 0,
  678      STRTYP = 0,
  679      SHRBFR_SRC (YES = '1'B, NO = '0'B) = '1'B,
  680      SHRBFR_GET (YES = '1'B, NO = '0'B) = '1'B,
  681      SHRBFR_ADD (YES = '1'B, NO = '0'B) = '1'B,
  682      ERR_LMTEXC (YES = '1'B, NO = '0'B) = '0'B,
  683      ERR_NO_MMR (YES = '1'B, NO = '0'B) = '0'B,
  684      ERR_NOT_FND (YES = '1'B, NO = '0'B) = '0'B,
  685      SCRNO_MMR (YES = '1'B, NO = '0'B) = '0'B);
  686      %LSET LISTDIR = '0'B;
  687      %LSET LISTEXP = '1'B;
  688      %LSET LISTCOM = '0'B;
  689      %LSET LISTSUB = '1'B;
  690      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  691      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  692      %LSET INIT = CHARTEXT('INIT');
  693      %LSET ENIT = CHARTEXT('');
  694      %ELSE;
  695      %LSET INIT = CHARTEXT('/*');
  696      %LSET ENIT = CHARTEXT('*/');
  697      %ENDIF;
  698      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_GETBFR);
  699                2 %CHARTEXT('BFR$') PTR %INIT(ADDR(BFR$))%ENIT,
  700      /*K* BFR$ = PTR.  Buffer pointer.  BFR$ points to the buffer
  701      allocated.  If BFR$ is null, no buffer is or was allocated.  If
  702      SHRBFR.ADD is set and SHRBFR.GET is not set, the address of the buffer
  703      to be added is passed in BFR$.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             20   
  704      */
  705                2 %CHARTEXT('BYTSIZ') UBIN WORD %INIT(BYTSIZ)%ENIT,
  706      /*K* BYTSIZ = VALUE-DEC(0-65535).  Byte size.  BYTSIZ specifies
  707      the size in bytes of the buffer to allocate.
  708      BYTSIZ is used only for buffers that are variable-sized and
  709      not shared, or for VDH-user buffers.  Variable-sized buffers are
  710      those for which size is not determined by STRTYP.
  711      BYTSIZ will contain the actual number of bytes (after possibly
  712      rounding up) allocated upon return.
  713      */
  714                2 STT$ PTR %INIT(ADDR(NIL))%ENIT,
  715      /*K* STT$ = PTR.  VDH statistics buffer pointer.  STT$ points to the
  716      KV$STT structure.
  717      .spf 0
  718      Note:  Only set up this pointer when VDH cannot find KV$STT through
  719      KV$VDI, i.e., only during early connect and late disconnect, or
  720      when KV$VDI is not usable or not present.
  721      */
  722                2 %CHARTEXT('STRTYP') UBIN BYTE CALIGNED %INIT(STRTYP)%ENIT,
  723      /*K* STRTYP = VALUE-DEC(0-255).  Structure type.  EQUate identifiers for
  724      the STRTYP values are listed in the
  725      following table.  In the case of certain shared buffers (TAB and HDR,
  726      for example) the option may be changed in the FPT by VDH to the type
  727      of the structure actually used.  In the table, items with * are not
  728      used; items with ** are the only ones likely to be of interest for
  729      an RDH call to GETBFR or RLSBFR.
  730      ..::TB "^\Identifier\#15\Meaning"
  731      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_ACTCHR
  732      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_DCB
  733      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_DCBHDN
  734      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_ENTSRD
  735      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_ERD
  736      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_ERR
  737      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_FLD
  738      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_FLDLST
  739      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_INPTAB
  740      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_LIN
14:54 JUL 28 '97 KV$VDH.:E05SI                                             21   
  741      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_LINLST
  742      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_MRD
  743      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_MSG
  744      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_MVD
  745      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_OTPTAB
  746      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_PAG
  747      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_PRM
  748      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_PTR
  749      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_RCR
  750      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_RCRLST
  751      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_REDBFR
  752      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_SRD
  753      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_SSN
  754      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_SSNHDN
  755      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_SSTINPFNCTBL
  756      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_STR
  757      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_TRCBFR
  758      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_TRMTAB
  759      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_TRNTBL
  760      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_TYPAHDBFR
  761      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_USRBFR
  762      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_USRINPFNCTBL
  763      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_USRSHRBFR
  764      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_VDI
  765      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_VFU
  766      .xeq KV_GLBCNS_E KV_STRTYP_E KV_STRTYP_X364
  767      ..::TB
  768      */
  769                2 SHRBFR,
  770      /*K* SHRBFR.  Contains the following shared buffer function flags.
  771      Typically all flags (SRC, GET, and ADD) are set, causing a search of
  772      the chain, and either incrementing of a user count or allocation of
  773      a buffer and copying of the data (DAT_).
  774      */
  775                3 %CHARTEXT('SRC') BIT(1) %INIT(SHRBFR_SRC)%ENIT,
  776      /*K* SHRBFR_SRC = {YES|NO}.  Search.  If SHRBFR_SRC=YES, part of (or
  777      all of) the function requested is to search the shared buffer chain.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             22   
  778      The default is YES.
  779      */
  780                3 %CHARTEXT('GET') BIT(1) %INIT(SHRBFR_GET)%ENIT,
  781      /*K* SHRBFR_GET = {YES|NO}.  Get.  If SHRBFR_GET=YES, get memory for a
  782      shared buffer, if a match is not found on the chain.  The default is
  783      YES.
  784      */
  785                3 %CHARTEXT('ADD') BIT(1) %INIT(SHRBFR_ADD)%ENIT,
  786      /*K* SHRBFR_ADD = {YES|NO}.  Add.  If SHRBFR_ADD=YES, add a buffer to the
  787      shared buffer chain if a buffer of the specified size is not found.
  788      The default is YES.
  789      */
  790                2 ERR,
  791      /*K* ERR.  Contains the following error flags:
  792      */
  793                3 %CHARTEXT('LMTEXC') BIT(1) %INIT(ERR_LMTEXC)%ENIT,
  794      /*K* ERR_LMTEXC = VALUE-BIT(1).  Limit exceeded.  Allocating this buffer would have caused
  795      VDH to exceed some limit on memory utilization.
  796      */
  797                3 %CHARTEXT('NO_MMR') BIT(1) %INIT(ERR_NO_MMR)%ENIT,
  798      /*K* ERR_NO_MMR = VALUE-BIT(1).  No memory.  The memory manager does not have the memory.
  799      */
  800                3 %CHARTEXT('NOT_FND') BIT(1) %INIT(ERR_NOT_FND)%ENIT,
  801      /*K* ERR_NOT_FND = VALUE-BIT(1).  A shared search failed, and "get" was not requested.
  802      */
  803                3 * BIT(1) %INIT('0'B)%ENIT,
  804                2 %CHARTEXT('SCRNO_MMR') BIT(1) %INIT(SCRNO_MMR)%ENIT,
  805      /*K* SCRNO_MMR = {YES|NO}.  SCRNO_MMR=YES causes a screech if no
  806      memory is available.
  807      */
  808      %KV$VECTOR(NAME = DAT_, LVL = 2, STCLASS = STCLASS, LAST = LAST);
  809      /*K* DAT_ = VDH-vector (KV$VECTOR).  Data vector.
  810      For shared buffers, DAT_ frames the caller's data to be used
  811      for matching and initializing.
  812      For non-shared buffers, DAT_ is used for initializing.
  813      */
  814      %MEND;
14:54 JUL 28 '97 KV$VDH.:E05SI                                             23   
  815
  816      /*F* NAME:  KV$VDH_GETPRM - Get Parameters
  817
  818      VDH returns the value of the specified parameter item
  819      or structure.
  820      */
  821
  822      %MACRO KV$VDH_GETPRM(NAME = KV$VDH_GETPRM, LAST = ";", STCLASS = BASED);
  823      %LSET LISTDIR = '0'B;
  824      %LSET LISTEXP = '1'B;
  825      %LSET LISTCOM = '0'B;
  826      %LSET LISTSUB = '1'B;
  827      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  828      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  829      %LSET INIT = CHARTEXT('INIT');
  830      %LSET ENIT = CHARTEXT('');
  831      %ELSE;
  832      %LSET INIT = CHARTEXT('/*');
  833      %LSET ENIT = CHARTEXT('*/');
  834      %ENDIF;
  835      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_GETPRM);
  836                2 BFRLMTEXC BIT(1) %INIT('0'B)%ENIT,
  837      /*K* BFRLMTEXC = VALUE-BIT(1).  Buffer limit exceeded.  If BFRLMTEXCT
  838      is set, the buffer size passed is too small to hold the structure
  839      requested.
  840      */
  841                2 PRMID UBIN WORD %INIT(0)%ENIT,
  842      /*K* PRMID = VALUE-DEC(0-65535).  Parameter ID.  PRMID specifies the
  843      item, structure, or array to be returned.
  844      For the definition of parameter items, structures, or arrays, see
  845      KV_PRMTBL_D.:LIBRARY which uses EQUate identifiers from
  846      KV_PRMID_E.:LIBRARY.  See the KV$VDH_SETPRM for a discussion of
  847      KV_PRMTBL_D.
  848      */
  849                2 VAL UBIN WORD %INIT(0)%ENIT,
  850      /*K* VAL = VALUE-DEC(0-65535).  Value of parameter.  VAL is used for
  851      parameters that are not structures and not arrays.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             24   
  852      */
  853      %KV$VECTOR(NAME = VAL_, LVL = 2, STCLASS = STCLASS, LAST = ",");
  854      /*K* VAL_ = VDH-vector (KV$VECTOR).  Vector to value of parameter.
  855      VAL_ is used for parameters that are structures or byte arrays.
  856      If VAL_ is non-null on the call, it frames the area supplied by the
  857      caller for the return of the parameters.
  858      */
  859                2 BFRHED$ PTR %INIT(ADDR(NIL))%ENIT,
  860      /*D* BFRHED$ = PTR.  Buffer (chain) head pointer.
  861      BFRHED$ is used when VDH is calling KVP$GETPRM,
  862      a null vector was passed to KVP$GETPRM, and the value(s) to be
  863      returned will not fit in VAL.  This parameter is used for requests
  864      from the distant end for get-parameter operations.  BFRHED$ points to
  865      a KV$GETPRM structure.
  866      */
  867                2 MAXBYTSIZ UBIN WORD %INIT(0)%ENIT,
  868      /*K* MAXBYTSIZ = VALUE-DEC(0-65535).  Maximum byte size.  If VAL_ is
  869      null, this value is the maximum
  870      byte size of the data (segments) to be returned.  It is used when
  871      processing a get-parameter request message, in which the other
  872      end has allocated a buffer with this size for the returned
  873      data segments.  Each buffer containing a KV$GETPRM structure
  874      must specify a DATBYTSIZ not exceeding this value.  If the
  875      requested structure will not fit within this size, BFRLMTEXC is set.
  876      This word is REDEFed as DATBYTSIZ, which is used when a buffer is supplied
  877      to return the amount of data actually stored therein.
  878      */
  879                2 DATBYTSIZ REDEF MAXBYTSIZ UBIN WORD LAST
  880      %MEND;
  881
  882      /*F* NAME:  KV$VDH_INT - Initialize VDH
  883
  884      VDH allocates and initializes an instance of VDI,
  885      including the KV$VDI (VDI context block).
  886
  887      Unlike other KV$VDH functions, the VDH-user calls KVV$INT to
  888      perform this function.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             25   
  889      ..::IX "KVV$INT"
  890      */
  891
  892
  893      %MACRO KV$VDH_INT(NAME = KV$VDH_INT, LAST = ";", STCLASS = BASED);
  894      %LSET LISTDIR = '0'B;
  895      %LSET LISTEXP = '1'B;
  896      %LSET LISTCOM = '0'B;
  897      %LSET LISTSUB = '1'B;
  898      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  899      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  900      %LSET INIT = CHARTEXT('INIT');
  901      %LSET ENIT = CHARTEXT('');
  902      %ELSE;
  903      %LSET INIT = CHARTEXT('/*');
  904      %LSET ENIT = CHARTEXT('*/');
  905      %ENDIF;
  906      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_INT);
  907                2 * BIT(1) %INIT('0'B)%ENIT,
  908                2 SHRTRCBFR BIT(1) %INIT('1'B)%ENIT,
  909      /*K* SHRTRCBFR = VALUE-BIT(1).  If set, one KV$TRCBFR structure
  910      should be shared between KV$VDH and KV$SSNs.
  911      Otherwise, each will have its own structure.  The default is '1'B.
  912      */
  913                2 * BIT(6) %INIT('0'B)%ENIT,
  914                2 CHN$ PTR %INIT(ADDR(NIL))%ENIT,
  915      /*K* CHN$ = PTR.  Channel table (KH$CHN) entry pointer.  CHN$ is used
  916      by VDH for satisfying parameter-get requests and doing selective
  917      tracing (based on KH$CHN.DBG).
  918      */
  919                2 USRCTX$ PTR %INIT(ADDR(NIL))%ENIT,
  920      /*K* USRCTX$ = PTR.  User context pointer.  USRCTX$ points to a context
  921      block in the user of VDH which identifies to the user which device,
  922      program, etc. is being referenced.  VDH has no knowledge
  923      of the structure of this context, but stores the pointer in KV$VDI
  924      for future reference by the RDH.
  925      */
14:54 JUL 28 '97 KV$VDH.:E05SI                                             26   
  926                2 VDI$ PTR %INIT(ADDR(NIL))%ENIT,
  927      /*K* VDI$ = PTR.  Points to VDI context (KV$VDI).  This is a parameter
  928      returned by VDH, to be used by the caller on later VDH requests (most
  929      notably KV$USRENT) to identify this occurrence of VDH.
  930      */
  931                2 USRPRM$ PTR %INIT(ADDR(NIL))%ENIT,
  932      /*K* USRPRM$ = PTR.  Points to user parameter table (KV$USRPRM).
  933      */
  934                2 RCVFLWCTRMAXCRD UBIN WORD %INIT(1000)%ENIT,
  935      /*K* RCVFLWCTRMAXCRD = VALUE-DEC(0-65535).  Receive flow control
  936      maximum credits.  In simple terms, this is the number
  937      of bytes that the other end can send before it has to
  938      wait for an acknowledgement of the data.
  939      This value should be set from a NETCON BLOCK parameter.
  940      See KV$RQSOTP elsewhere in this section for a discussion of
  941      RCVLWCTRMAXCRD and output control.
  942      */
  943                2 TRCBFRBYTSIZ UBIN WORD %INIT(64)%ENIT LAST
  944      /*K* TRCBFRBYTSIZ = VALUE-DEC(0-65535).  Specifies the trace buffer,
  945      KV$TRCBFR, byte size (VDHTRC).  This value should be set from the
  946      NETCON VDHTRC parameter.
  947      */
  948      %MEND;
  949
  950      /*F* NAME:  KV$VDH_INTINPOPR - Interpret Input Operator(s)
  951
  952      VDH interprets an input function operator.
  953      */
  954
  955      %MACRO KV$VDH_INTINPOPR(NAME = KV$VDH_INTINPOPR, LAST = ";", STCLASS = BASED);
  956      %LSET LISTDIR = '0'B;
  957      %LSET LISTEXP = '1'B;
  958      %LSET LISTCOM = '0'B;
  959      %LSET LISTSUB = '1'B;
  960      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  961      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  962      %LSET INIT = CHARTEXT('INIT');
14:54 JUL 28 '97 KV$VDH.:E05SI                                             27   
  963      %LSET ENIT = CHARTEXT('');
  964      %ELSE;
  965      %LSET INIT = CHARTEXT('/*');
  966      %LSET ENIT = CHARTEXT('*/');
  967      %ENDIF;
  968      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_INTINPOPR);
  969                2 IMD BIT(1) %INIT('1'B)%ENIT,
  970                2 * BIT(7) %INIT('0'B)%ENIT,
  971      /*K* IMD = VALUE-BIT(1).  Do immediate phase processing.  If IMD is set,
  972      VDH will perform only operators that specify immediate phase processing.
  973      Otherwise, operators that don't specify read phase processing will be
  974      skipped, except for the CHN specification.
  975      Whether read phase processing is done is determined by
  976      KV$VDI.USRRQSDAT.RED, which is examined before each input operator
  977      is processed.
  978      */
  979                2 INPFNCTBL$ PTR %INIT(ADDR(NIL))%ENIT,
  980      /*K* INPFNCTBL$ = PTR.  Input function table address.  VDH uses this
  981      pointer together with INPOPRX to access the actual
  982      input function operator data.  It need not point to a real KV$INPFNCTBL
  983      unless the interpreted operator specifies TYP=FLWON, PRMID=0, or
  984      TYP=VDHINPPRC and ID=KV_INPPRC_ESC, none of which is very useful when
  985      calling VDH directly for input function interpretation.
  986      */
  987                2 ORGCHR UBIN WORD %INIT(0)%ENIT,
  988      /*K* ORGCHR = VALUE-DEC(0-255).  Contains the original (untranslated)
  989      character.  VDH uses this only to construct an FPT to call the user if
  990      the interpreted operator is of type KV_USRINPPRC.
  991      */
  992                2 INPOPRX SBIN WORD %INIT(0)%ENIT,
  993      /*K* INPOPRX = VALUE-DEC(-32768-32767).  Input operator index.
  994      INPOPRX specifies the word offset from INPFNCTBL$ of the KV$INPOPR
  995      structure that is to be interpreted.
  996      */
  997                2 ACKCHR SBIN WORD %INIT(0)%ENIT LAST
  998      /*K* ACKCHR = VALUE-DEC(0-255).  Specifies the character to display
  999      between < and > if ACKnowledge is
14:54 JUL 28 '97 KV$VDH.:E05SI                                             28   
 1000      specified in the INPOPR definition.  For example, if ASYNC
 1001      <ESC> D is typed,  <D> will be displayed.
 1002      */
 1003      %MEND;
 1004
 1005      /*F* NAME:  KV$VDH_OTPLCL - Output Local
 1006
 1007      VDH outputs the specified text.  This
 1008      function is used for echo-plex, etc.
 1009      */
 1010
 1011      %MACRO KV$VDH_OTPLCL (NAME=KV$VDH_OTPLCL, LAST=";", STCLASS=BASED, LVL=1,
 1012                     NONVRT(YES = '1'B, NO = '0'B) = '0'B,
 1013                     TRN(YES = '1'B, NO = '0'B) = '0'B,
 1014                     HDN(YES = '1'B, NO = '0'B) = '0'B,
 1015                     NO_WRAP(YES = '1'B, NO = '0'B) = '0'B,
 1016                     EXTOTPTRN(YES = '1'B, NO = '0'B) = '0'B,
 1017                     TEXT = "BINASC(0)",
 1018                     BFR = NIL, BYTX = 0, BYTSIZ = 0);
 1019      %LSET LISTDIR = '0'B;
 1020      %LSET LISTEXP = '1'B;
 1021      %LSET LISTCOM = '0'B;
 1022      %LSET LISTSUB = '1'B;
 1023      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1024      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1025      %LSET INIT = CHARTEXT('INIT');
 1026      %LSET ENIT = CHARTEXT('');
 1027      %ELSE;
 1028      %LSET INIT = CHARTEXT('/*');
 1029      %LSET ENIT = CHARTEXT('*/');
 1030      %ENDIF;
 1031      %LSET X_ = CHARTEXT(TEXTCHAR(BYTX));
 1032      %LSET SIZ_ = CHARTEXT(TEXTCHAR(BYTSIZ));
 1033      %LSET BFR_ = CHARTEXT(TEXTCHAR(BFR));
 1034      %IF TEXT ~= BINASC(0) AND ENIT = CHARTEXT('');
 1035      %LSET BFR_ = CHARTEXT(CONCAT(TEXTCHAR(NAME), '_TEXT'));
 1036      DCL %BFR_ STCLASS CHAR(0) INIT(TEXT);
14:54 JUL 28 '97 KV$VDH.:E05SI                                             29   
 1037      %LSET X_ = 0;
 1038      %LSET SIZ_ = LENGTHC(TEXT);
 1039      %ENDIF;
 1040      %KV$VDH_FNCHDR (NAME=NAME, LVL=LVL, STCLASS=STCLASS, FNC=KV_VDH_FNC_OTPLCL);
 1041            %(LVL+1) %CHARTEXT('NONVRT') BIT(1)%INIT(NONVRT)%ENIT,
 1042      /*K* NONVRT = {YES|NO}.  Non-virtual output. If NONVRT=YES, the
 1043      characters are from a non_DCB operation (e.g., ESC-G response, ESC-Q
 1044      response). */
 1045            %(LVL+1) %CHARTEXT('TRN') BIT(1)%INIT(TRN)%ENIT,
 1046      /*K* TRN = {YES|NO}.  Transparent.  If TRN=YES, no character
 1047      translation should be done.
 1048      */
 1049            %(LVL+1) %CHARTEXT('HDN') BIT(1)%INIT(HDN)%ENIT,
 1050      /*K* HDN = {YES|NO}.  Hidden.
 1051      Setting HDN requests translation of all printing characters to blank.
 1052      This flag is used for non-echo-plex on CRTs and to simulate hidden fields
 1053      for forms on devices that do not have the hidden GRPRND facility.
 1054      */
 1055            %(LVL+1) %CHARTEXT('NO_WRAP') BIT(1) %INIT(NO_WRAP)%ENIT,
 1056      /*K* NO_WRAP = {YES|NO}.
 1057      NO_WRAP=YES requests a return to the caller with VDH_OTPLCL.BFR_
 1058      updated to frame the remainder of the character string in lieu of
 1059      performing any line-wrap operation.  The caller must notice changed
 1060      BYTX or BYTSIZ.*/
 1061            %(LVL+1) %CHARTEXT('EXTOTPTRN') BIT(1) %INIT(EXTOTPTRN)%ENIT,
 1062      /*K* EXTOTPTRN = {YES|NO}.  EXTOTPTRN=YES means this call is a result
 1063      of extended translation (see KV$USR_EXTOTPTRN.)  Further
 1064      extended translation is to be ignored to prevent endless recursion. */
 1065            %(LVL+1) * BIT(3) %INIT('0'B)%ENIT,
 1066      %LSET NXTLVL=LVL+1;
 1067      %KV$VECTOR (NAME=BFR_, LVL=NXTLVL, STCLASS=STCLASS, LAST=LAST, BFR=%BFR_,
 1068                  BYTX=%X_, BYTSIZ=%SIZ_);
 1069      /*K* BFR_ = VDH-vector (KV$VECTOR).
 1070      Buffer vector.  BFR_ points to the character string to be
 1071      translated and placed in the VDH-user's output buffer.
 1072      Macro options BFR, BYTX, and BYTSIZ may be used to initialize the fields
 1073      in BFR_, or the TEXT option may be used to create a CHAR item named name_TEXT,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             30   
 1074      initialized with the TEXT value, and framed by BFR_.
 1075      */
 1076      %MEND;
 1077
 1078      /*F* NAME:  KV$VDH_OTPMRK - Output Marker
 1079
 1080      This is used by the VDH-user when it has completed or otherwise
 1081      disposed of all output prior to the corresponding KV$USR_OTPMRK
 1082      marker in the output stream.
 1083      */
 1084
 1085      %MACRO KV$VDH_OTPMRK(NAME = KV$VDH_OTPMRK, LAST = ";", STCLASS = BASED);
 1086      %LSET LISTDIR = '0'B;
 1087      %LSET LISTEXP = '1'B;
 1088      %LSET LISTCOM = '0'B;
 1089      %LSET LISTSUB = '1'B;
 1090      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1091      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1092      %LSET INIT = CHARTEXT('INIT');
 1093      %LSET ENIT = CHARTEXT('');
 1094      %ELSE;
 1095      %LSET INIT = CHARTEXT('/*');
 1096      %LSET ENIT = CHARTEXT('*/');
 1097      %ENDIF;
 1098      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_OTPMRK);
 1099      %KV$OTPMRK(NAME = DAT, LVL = 2, STCLASS = STCLASS, LAST = ",");
 1100      /*K* DAT = KV$OTPMRK substructure.  Data.  This is the data that was
 1101      passed to the VDH-user on the KV$USR_OTPMRK.
 1102      */
 1103            2 CMPCOD UBIN WORD UNAL %INIT(0)%ENIT LAST
 1104      /*K* CMPCOD = VALUE-DEC(65535).  Completion code.  COMCOD specifies how the I/O
 1105      (or other operation) preceding this OTPMRK completed.  EQUate identifiers for
 1106      the CMPCOD values are listed in the following table.
 1107      ..::TB "^\Identifier\#20\Meaning"
 1108      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_BFRLMTEXC
 1109      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_BFROVRRUN
 1110      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_CLS
14:54 JUL 28 '97 KV$VDH.:E05SI                                             31   
 1111      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DLT
 1112      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DSC
 1113      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_DVCERR
 1114      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_EOF
 1115      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_NOTINP
 1116      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_NRM
 1117      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_PRTERR
 1118      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_RATERR
 1119      .xeq KV_GLBCNS_E KV_CMPCOD_E KV_CMPCOD_REDTIMOUT
 1120      ..::TB
 1121      */
 1122      %MEND;
 1123
 1124      /*F* NAME:  KV$VDH_PST - Position
 1125
 1126      VDH positions (both the context pointers and the cursor)
 1127      to the specified position.  Position may be:  n-lines
 1128      up/down, line-n, n-columns left/right, column-n,
 1129      to field-n, to previous field, to next field, to beginning
 1130      of field, to end of field, etc.
 1131      */
 1132      %MACRO KV$VDH_PST(NAME = KV$VDH_PST, STCLASS = BASED, LVL = 1, LAST = ";",
 1133                        VRTPSTVAL = 0, HRZPSTVAL = 0,
 1134                        PHSPSTMOD(SKP = 1, BLN = 2, ANY = 3) = 1,
 1135                        HRZPSTORG(ABS = 1, CRTPST = 2, SRD = 3) = 1,
 1136                        VRTPSTORG (ABS=1, CRTPST=2, SRD=3)=2,
 1137                        HRZPSTUNT(CLM = 1, FLD = 2, UN_PRTFLD = 3) = 1,
 1138                        VRTPSTUNT(LIN = 1, FLD = 2, UN_PRTFLD = 3) = 1,
 1139                        PSTIN_PLC (YES='1'B, NO ='0'B)='0'B,
 1140                        VRTPSTMOD(WHTSPCOVRSHT = 0, WHTSPC = 1, IN_PLC = 2, RSTVRTPST = 3) = 2,
 1141                        VRTSCRENB (YES = '1'B, NO = '0'B) = '1'B,
 1142                        VRT (YES='1'B, NO='0'B, ANY)='1'B);
 1143      %LSET LISTDIR = '0'B;
 1144      %LSET LISTEXP = '1'B;
 1145      %LSET LISTCOM = '0'B;
 1146      %LSET LISTSUB = '1'B;
 1147      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
14:54 JUL 28 '97 KV$VDH.:E05SI                                             32   
 1148      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1149      %LSET INIT = CHARTEXT('INIT');
 1150      %LSET ENIT = CHARTEXT('');
 1151      %ELSE;
 1152      %LSET INIT = CHARTEXT('/*');
 1153      %LSET ENIT = CHARTEXT('*/');
 1154      %ENDIF;
 1155      %KV$VDH_FNCHDR (NAME = NAME, LVL = LVL, STCLASS = STCLASS, FNC = KV_VDH_FNC_PST);
 1156            %(LVL+1) %CHARTEXT('VRT') BIT(1)%INIT(VRT)%ENIT,
 1157      /*K* VRT = {YES|NO}.  Virtual positioning.  If VRT=YES, line
 1158      and column information is in virtual rather than physical lines and
 1159      columns.  The default is YES.
 1160      */
 1161            %(LVL+1) %CHARTEXT('VRTPSTMOD') UBIN(2)UNAL %INIT(VRTPSTMOD)%ENIT,
 1162      /*K* VRTPSTMOD = VALUE-DEC(0-3).
 1163      Virtual positioning mode.  EQUate
 1164      identifiers for the VRTPSTMOD values are listed in the following table.
 1165      ..::TB "^\Identifier\#10\Meaning\#"
 1166      ..::IT "KV_VRTPSTMOD_IN_PLC"
 1167      .xeq KV$VDH KV_VRTPSTMOD_E KV_VRTPSTMOD_IN_PLC
 1168      ..::IT "KV_VRTPSTMOD_RSTVRTPST"
 1169      .xeq KV$VDH KV_VRTPSTMOD_E RSTVRTPST
 1170      ..::IT "KV_VRTPSTMOD_WHTSPCOVRSHT"
 1171      .xeq KV$VDH KV_VRTPSTMOD_E WHTSPCOVRSHT
 1172      ..::IT "KV_VRTPSTMOD_WHTSPC"
 1173      .xeq KV$VDH KV_VRTPSTMOD_E KV_VRTPSTMOD_WHTSPC
 1174      ..::TB
 1175      */
 1176            %(LVL+1) %CHARTEXT('PHSPSTMOD') UBIN(2)UNAL %INIT(PHSPSTMOD)%ENIT,
 1177      /*K* PHSPSTMOD = VALUE-DEC(0-3).
 1178      Physical positioning mode.  EQUate
 1179      identifiers for the PHSPSTMOD values are listed in the following table.
 1180      ..::TB "^\Identifier\#15\Meaning"
 1181      .xeq KV_GLBCNS_E KV_PHSPSTMOD_E KV_PHSPSTMOD_ANY
 1182      .xeq KV_GLBCNS_E KV_PHSPSTMOD_E KV_PHSPSTMOD_BLN
 1183      .xeq KV_GLBCNS_E KV_PHSPSTMOD_E KV_PHSPSTMOD_HRZSCR
 1184      .xeq KV_GLBCNS_E KV_PHSPSTMOD_E KV_PHSPSTMOD_SKP
14:54 JUL 28 '97 KV$VDH.:E05SI                                             33   
 1185      .xeq KV_GLBCNS_E KV_PHSPSTMOD_E KV_PHSPSTMOD_VRTSCR
 1186      ..::TB
 1187      */
 1188            %(LVL+1) %CHARTEXT('PSTIN_PLC') BIT(1)%INIT(PSTIN_PLC)%ENIT,
 1189      /*K* PSTIN_PLC = {YES|NO}.
 1190      Position in place.  PSTIN_PLC=YES
 1191      means "stay on top of text"; if positioning cannot
 1192      be done on top, go to white space.
 1193      */
 1194            %(LVL+1) %CHARTEXT('HRZPSTORG') UBIN(2)UNAL %INIT(HRZPSTORG)%ENIT,
 1195      /*K* HRZPSTORG = VALUE-DEC(0-3).
 1196      Horizontal positioning origin.
 1197      HRZPSTORG specifies the origin to which HRZPSTVAL refers.  Values
 1198      are as follows:
 1199      ..::TB "^\Identifier\#10\Meaning"
 1200      KV_PSTORG_ABS#HRZPSTVAL is an absolute column.
 1201      .spf 0
 1202      KV_PSTORG_CRTPST#HRZPSTVAL is relative to the current column.
 1203      .spf 0
 1204      KV_PSTORG_SRD#HRZPSTVAL is relative to the current window origin.
 1205      ..::TB
 1206      */
 1207      /*K* HRZPSTVAL = VALUE-DEC(-32768 - +32767).
 1208      Horizontal positioning
 1209      value.  HRZPSTVAL specifies the number of HRZPSTUNTs to move relative
 1210      to HRZPSTORG.
 1211      */
 1212            %(LVL+1) %CHARTEXT('HRZPSTUNT') UBIN(3)UNAL %INIT(HRZPSTUNT)%ENIT,
 1213      /*K* HRZPSTUNT = VALUE-DEC(0-7).
 1214      Horizontal positioning unit.  HRZPSTUNT
 1215      specifies the unit (column, field, etc.) of horizontal movement.
 1216      EQUate identifiers for the HRZPSTUNT values are listed in the following table.
 1217      ..::TB "^\Identifier\#15\Meaning"
 1218      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_CLM
 1219      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_FLD
 1220      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_UN_PRTFLD
 1221      ..::TB
14:54 JUL 28 '97 KV$VDH.:E05SI                                             34   
 1222      */
 1223            %(LVL+1) %CHARTEXT('VRTPSTORG') UBIN(2)UNAL %INIT(VRTPSTORG)%ENIT,
 1224      /*K* VRTPSTORG = VALUE-DEC(0-3).
 1225      Vertical positioning origin.
 1226      VRTPSTORG specifies the origin to which VRTPSTVAL refers.  Values
 1227      are as follows:
 1228      ..::TB "^\Identifier\#10\Meaning"
 1229      KV_PSTORG_ABS#VRTPSTVAL is an absolute line.
 1230      .spf 0
 1231      KV_PSTORG_CRTPST#VRTPSTVAL is relative to the current line.
 1232      .spf 0
 1233      KV_PSTORG_SRD#VRTPSTVAL is relative to KV$SRD.LFTMRGCLM - 1.
 1234      ..::TB
 1235      */
 1236      /*K* VRTPSTVAL = VALUE-DEC(-32768 - +32767).
 1237      Vertical positioning
 1238      value.  VRTPSTVAL specifies the number of VRTPSTUNTs to move relative
 1239      to VRTPSTORG.
 1240      */
 1241            %(LVL+1) %CHARTEXT('VRTSCRENB') BIT(1) %INIT(VRTSCRENB)%ENIT,
 1242      /*K* VRTSCRENB = {YES|NO}.  Vertical scroll enable.  Moving down
 1243      beyond the lower margin should cause scrolling to occur if scrolling
 1244      is otherwise enabled and possible.
 1245      Currently this flag is only examined for ORG = X364 virtual devices.
 1246      The default is YES.
 1247      */
 1248            %(LVL+1) %CHARTEXT('VRTPSTUNT') UBIN(2)UNAL %INIT(VRTPSTUNT)%ENIT,
 1249      /*K* VRTPSTUNT = VALUE-DEC(0-7).
 1250      Vertical positioning unit.
 1251      VRTPSTUNT specifies the unit of
 1252      vertical movement.  EQUate identifiers for the VRTPSTUNT values are
 1253      listed in the following table.
 1254      ..::TB "^\Identifier\#15\Meaning"
 1255      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_FLD
 1256      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_LIN
 1257      .xeq KV$VDH KV_PSTUNT_E KV_PSTUNT_UN_PRTFLD
 1258      ..::TB
14:54 JUL 28 '97 KV$VDH.:E05SI                                             35   
 1259      */
 1260
 1261      /* Position to position to, if VRT wasn't set. */
 1262
 1263      %LSET LVL1 = LVL+1;
 1264      %KV$PST (LVL = %LVL1, NAME = PSTVAL, STCLASS = STCLASS, LIN = VRTPSTVAL, CLM = HRZPSTVAL, LAST = LAST);
 1265      %MEND;
 1266      %MACRO KV_VRTPSTMOD_E;
 1267
 1268      /*F* NAME:  KV_VRTPSTMOD_E
 1269      Values for VRTPSTMOD. */
 1270
 1271      /*K* WHTSPCOVRSHT
 1272      Virtual positioning mode; if PSTIN_PLC is not specified,
 1273      stay on top of text unless overshot; then go to white space. */
 1274
 1275      %EQU KV_VRTPSTMOD_WHTSPCOVRSHT = 0;
 1276
 1277      /*K* KV_VRTPSTMOD_WHTSPC
 1278      Virtual positioning mode; if PSTIN_PLC is not specified,
 1279      go to white space. */
 1280
 1281      %EQU KV_VRTPSTMOD_WHTSPC = 1;
 1282
 1283      /*K* KV_VRTPSTMOD_IN_PLC
 1284      Virtual positioning mode; if PSTIN_PLC is not specified,
 1285      position in place (anyway).  If positioning cannot be done in
 1286      place, go to white space. */
 1287
 1288      %EQU KV_VRTPSTMOD_IN_PLC = 2;
 1289
 1290      /*K* RSTVRTPST
 1291      Virtual positioning mode - restore virtual position.
 1292      If RETYPOVR is specified, position in-place and erase to end of SRD
 1293      if HI_NONBLN was set by non-virtual output (E.G. ESC-G);
 1294      otherwise, position to white-space.*/
 1295
14:54 JUL 28 '97 KV$VDH.:E05SI                                             36   
 1296      %EQU KV_VRTPSTMOD_RSTVRTPST = 3;
 1297      %MEND;
 1298
 1299      %MACRO KV_PSTUNT_E;
 1300
 1301      /*F* NAME:  KV_PSTUNT_E
 1302      Values for positioning unit. */
 1303
 1304      %EQU KV_PSTUNT_CLM = 1;
 1305      /*K* KV_PSTUNT_CLM
 1306      KV_PSTUNT_CLM            Column
 1307      */
 1308      %EQU KV_PSTUNT_LIN = 1;
 1309      /*K* KV_PSTUNT_LIN
 1310      KV_PSTUNT_LIN            Line
 1311      */
 1312      %EQU KV_PSTUNT_FLD = 2;
 1313      /*K* KV_PSTUNT_FLD
 1314      KV_PSTUNT_FLD            Field
 1315      */
 1316      %EQU KV_PSTUNT_UN_PRTFLD = 3;
 1317      /*K* KV_PSTUNT_UN_PRTFLD
 1318      KV_PSTUNT_UN_PRTFLD      Unprotected field
 1319      */
 1320
 1321      %MEND;
 1322
 1323      /*F* NAME:  KV$VDH_RLSBFR - Release Buffer
 1324
 1325      VDH releases various types of buffers.
 1326      */
 1327
 1328      %MACRO KV$VDH_RLSBFR(NAME = KV$VDH_RLSBFR, LAST = ";", STCLASS = BASED);
 1329      %LSET LISTDIR = '0'B;
 1330      %LSET LISTEXP = '1'B;
 1331      %LSET LISTCOM = '0'B;
 1332      %LSET LISTSUB = '1'B;
14:54 JUL 28 '97 KV$VDH.:E05SI                                             37   
 1333      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1334      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1335      %LSET INIT = CHARTEXT('INIT');
 1336      %LSET ENIT = CHARTEXT('');
 1337      %ELSE;
 1338      %LSET INIT = CHARTEXT('/*');
 1339      %LSET ENIT = CHARTEXT('*/');
 1340      %ENDIF;
 1341      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_RLSBFR);
 1342              2 BFR$ PTR %INIT(ADDR(NIL))%ENIT,
 1343      /*K* BFR$ = PTR.  Buffer pointer.  BFR$ points to the beginning of the buffer to be
 1344      buffer to be released.
 1345      */
 1346                2 BYTSIZ UBIN WORD %INIT(0)%ENIT,
 1347      /*K* BYTSIZ = VALUE-DEC(0-65535).  Byte size.  BYTSIZ specifies the
 1348      size in bytes of the buffer to release.  BYTSIZ is
 1349      used only for buffers that are variable-sized and
 1350      not shared, or for VDH-user buffers.
 1351      */
 1352                2 STT$ PTR %INIT(ADDR(NIL))%ENIT,
 1353      /*K* STT$ = PTR.  VDH statistics buffer pointer.  STT$ points to the
 1354      KV$STT structure.
 1355      .spf 0
 1356      Note:  Only set up this pointer when VDH cannot otherwise find
 1357      KV$STT, i.e., only during early connect and late disconnect,
 1358      when KV$VDI is not usable or not present.
 1359      */
 1360                2 STRTYP UBIN BYTE CALIGNED %INIT(0)%ENIT,
 1361      /*K* STRTYP = VALUE-DEC(0-255).  Structure type.  Structure types are listed
 1362      in the description of KV$VDH_GETBFR.STRTYP.
 1363      */
 1364                2 SHRBFRSRC BIT(1) %INIT('1'B)%ENIT,
 1365      /*K* SHRBFRSRC = VALUE-BIT(1).  Shared buffer search.  SHRBFRSRC is
 1366      used only for shared buffer releases.  If this flag is set, VDH searches
 1367      the chain for the buffer specified by BFR$, and either
 1368      decrements a user count or releases the buffer.
 1369      If this flag is not set, the buffer is simply released.
14:54 JUL 28 '97 KV$VDH.:E05SI                                             38   
 1370      The common case is to set this flag.
 1371      */
 1372                2 * BIT(7) %INIT('0'B)%ENIT LAST
 1373      %MEND;
 1374
 1375      /*N* NAME:  KV$VDH_RQSDAT - Request data
 1376
 1377      The VDH-user uses this to request data.
 1378      */
 1379
 1380      %MACRO KV$VDH_RQSDAT(NAME = KV$VDH_RQSDAT, LAST = ";", STCLASS = BASED);
 1381      %LSET LISTDIR = '0'B;
 1382      %LSET LISTEXP = '1'B;
 1383      %LSET LISTCOM = '0'B;
 1384      %LSET LISTSUB = '1'B;
 1385      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1386      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1387      %LSET INIT = CHARTEXT('INIT');
 1388      %LSET ENIT = CHARTEXT('');
 1389      %ELSE;
 1390      %LSET INIT = CHARTEXT('/*');
 1391      %LSET ENIT = CHARTEXT('*/');
 1392      %ENDIF;
 1393      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_RQSDAT);
 1394                2 SIZ UBIN WORD %INIT(0)%ENIT LAST
 1395      /*N* SIZ = VALUE-DEC(0-65535).  Size (total number of bytes) of data being requested.
 1396      */
 1397      %MEND;
 1398
 1399      /*F* NAME:  KV$VDH_SETCLK - Set Clock
 1400
 1401      VDH asks to have a clock set for the specified period.
 1402      If the clock logic cannot set the clock, an ALTRET is given.
 1403      When the clock expires, the VDH-user is called with
 1404      KV_USR_EVT_ID_CLKEXP.
 1405      */
 1406
14:54 JUL 28 '97 KV$VDH.:E05SI                                             39   
 1407      %MACRO KV$VDH_SETCLK (NAME=KV$VDH_SETCLK, LAST=";", STCLASS=BASED,
 1408                            UNT=0, PRD=0, CLKNMB=0);
 1409      %LSET LISTDIR = '0'B;
 1410      %LSET LISTEXP = '1'B;
 1411      %LSET LISTCOM = '0'B;
 1412      %LSET LISTSUB = '1'B;
 1413      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1414      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1415      %LSET INIT = CHARTEXT('INIT');
 1416      %LSET ENIT = CHARTEXT('');
 1417      %ELSE;
 1418      %LSET INIT = CHARTEXT('/*');
 1419      %LSET ENIT = CHARTEXT('*/');
 1420      %ENDIF;
 1421      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_SETCLK);
 1422                2 %CHARTEXT('UNT') UBIN BYTE CALIGNED %INIT(UNT)%ENIT,
 1423      /*K* UNT = VALUE-DEC(0-255).  Units.  UNT specifies the units in
 1424      which the period (PRD) is expressed.  EQU identifiers for UNT are
 1425      as follows:
 1426      ..::TB "^\Identifier\#20\Meaning"
 1427      .xeq KV_GLBCNS_E KV_CLKUNT_E KV_CLKUNT_10_MS
 1428      .xeq KV_GLBCNS_E KV_CLKUNT_E KV_CLKUNT_MNT
 1429      .xeq KV_GLBCNS_E KV_CLKUNT_E KV_CLKUNT_SCN
 1430      ..::TB
 1431      */
 1432                2 %CHARTEXT('PRD') UBIN BYTE CALIGNED %INIT(PRD)%ENIT,
 1433      /*K* PRD = VALUE-DEC(0-255).  Period.  PRD specifies the length of the
 1434      clock period.
 1435      */
 1436                2 %CHARTEXT('CLKNMB') UBIN BYTE CALIGNED %INIT(CLKNMB)%ENIT LAST
 1437      /*K* CLKNMB = VALUE-DEC(0-7).  Clock number.  CLKNMB specifies which
 1438      of the eight VDH clocks associated with this KV$SSN is to be set.
 1439      0, 1, and 2 are used by VDH itself to time out logon-reads,
 1440      system-reads, and user-reads, respectively.  Any other clock can be
 1441      set by the user.  If it is already set (KV_SSN.CLKSET(CLKNMB) is true),
 1442      it will be restarted for the new expiration time.
 1443      */
14:54 JUL 28 '97 KV$VDH.:E05SI                                             40   
 1444
 1445      %MEND;
 1446
 1447      /*F* NAME:  KV$VDH_SETPRM - Set parameters
 1448
 1449      VDH sets the specified parameter to the specified value.
 1450      */
 1451
 1452      %MACRO KV$VDH_SETPRM(NAME = KV$VDH_SETPRM, LAST = ";", STCLASS = BASED,
 1453      PRMID = 0, VAL = 0, SCP = 0, STR = 0);
 1454      %LSET LISTDIR = '0'B;
 1455      %LSET LISTEXP = '1'B;
 1456      %LSET LISTCOM = '0'B;
 1457      %LSET LISTSUB = '1'B;
 1458      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1459      %IF (STC = 'STA')OR(STC = 'CON')OR(STC = 'EXT');
 1460      %LSET INIT = CHARTEXT('INIT');
 1461      %LSET ENIT = CHARTEXT('');
 1462      %ELSE;
 1463      %LSET INIT = CHARTEXT('/*');
 1464      %LSET ENIT = CHARTEXT('*/');
 1465      %ENDIF;
 1466      %KV$VDH_FNCHDR(NAME = NAME, STCLASS = STCLASS, FNC = KV_VDH_FNC_SETPRM);
 1467                2 %CHARTEXT('PRMID') UBIN WORD %INIT(PRMID)%ENIT,
 1468      /*K* PRMID = VALUE-DEC(0-65535).  Parameter ID.
 1469      For the definition of parameter items, structures, or arrays, see
 1470      KV_PRMTBL_D.:LIBRARY which uses EQUate identifiers from
 1471      KV_PRMID_E.:LIBRARY.  KV_PRMTBL_D provides information to relate
 1472      parameters to items in VLPs and VDH context as follows:
 1473
 1474      .inl 0
 1475      .inl 8
 1476      .unl 4
 1477      o   A VLP is represented in KV_PRMTBL_D by a KV_PARM line with
 1478      TYPE=STRUCT, followed by a list of elementary items contained in the
 1479      VLP.  Each such elementary item, a KV_SUBSTR line, specifies in
 1480      OFFSET the spelling of the parameter in the VLP, and in ID, the
14:54 JUL 28 '97 KV$VDH.:E05SI                                             41   
 1481      corresponding KV_PRMID_xx spelling.
 1482
 1483      .unl 4
 1484      o   An elementary item in KV_PRMTBL_D is represented by a KV_PARM
 1485      line with TYPE other than STRUCT or STRLST.  For these lines,
 1486      OFFSET specifies the spelling of the item in a VDH context structure,
 1487      and ID specifies the KV_PRMID_xx spelling.
 1488      .inl 0
 1489      */
 1490                2 %CHARTEXT('VAL') UBIN WORD %INIT(VAL)%ENIT,
 1491      /*K* VAL = VALUE-DEC(0-65535).  Value of parameter.  VAL is used for
 1492      parameters that are not structures and not arrays.
 1493      */
 1494      %KV$VECTOR(NAME = VAL_, LVL = 2, STCLASS = STCLASS, LAST = ",");
 1495      /*K* VAL_ = VDH-vector (KV$VECTOR).  Vector to value of parameter.
 1496      VAL_ is used for parameters that are structures or byte arrays.
 1497      */
 1498                2 %CHARTEXT('SCP') UBIN BYTE CALIGNED %INIT(SCP)%ENIT,
 1499      /*K* SCP = VALUE-DEC(0-255).
 1500      Scope.  If DMN is zero,
 1501      SCP specifies the scope of the parameter change, e.g., whether
 1502      the parameter is only to be changed on subordinate devices,
 1503      on only one stream, on all streams on this session, on all sessions,
 1504      etc.  EQUate identifiers for SCP values are listed in the following table.
 1505      ..::TB "^\Identifier\#10\Meaning"
 1506      ..::IT "KV_SCP_ALL"
 1507      .xeq KV_PRMID_E KV_SCP_E KV_SCP_ALL
 1508      ..::IT "KV_SCP_MRD"
 1509      .xeq KV_PRMID_E KV_SCP_E KV_SCP_MRD
 1510      ..::IT "KV_SCP_MVD"
 1511      .xeq KV_PRMID_E KV_SCP_E KV_SCP_MVD
 1512      ..::IT "KV_SCP_ONE_ONLY"
 1513      .xeq KV_PRMID_E KV_SCP_E KV_SCP_ONE_ONLY
 1514      ..::IT "KV_SCP_SRD"
 1515      .xeq KV_PRMID_E KV_SCP_E KV_SCP_SRD
 1516      ..::IT "KV_SCP_SSN"
 1517      .xeq KV_PRMID_E KV_SCP_E KV_SCP_SSN
14:54 JUL 28 '97 KV$VDH.:E05SI                                             42   
 1518      ..::IT "KV_SCP_STR"
 1519      .xeq KV_PRMID_E KV_SCP_E KV_SCP_STR
 1520      ..::IT "KV_SCP_SVD"
 1521      .xeq KV_PRMID_E KV_SCP_E KV_SCP_SVD
 1522      ..::TB
 1523      */
 1524                2 %CHARTEXT('DMN') UBIN BYTE CALIGNED %INIT(STR)%ENIT LAST
 1525      /*K* DMN = VALUE-DEC(0-255).
 1526      Domain.  DMN identifies which stream is to be affected.  Only context
 1527      subordinate to the stream where KV$STR.ID matches DMN is affected.
 1528      */
 1529      %MEND;
 1530
 1531      /*M* KV$VDH_FNCHDR function header substructure */
 1532
 1533      /* VDI function header substructure. */
 1534
 1535      /* Function.  Specifies the function being performed. */
 1536      /* The value for KV$USR_function is KV_USR_FNC_function. */
 1537      /* The value for KV$VDH_function is KV_VDH_FNC_function. */
 1538
 1539      %MACRO KV$VDH_FNCHDR(NAME = KV$VDH_FNCHDR, LVL = 1, LAST = ",", STCLASS = BASED,
 1540                      FNC(KV_VDH_FNC_CNC = 1,
 1541                      KV_VDH_FNC_DAT = 2,
 1542                      KV_VDH_FNC_DCLLCLPST = 3,
 1543                      KV_VDH_FNC_DSC = 4,
 1544                      KV_VDH_FNC_EVT = 6,
 1545                      KV_VDH_FNC_GETBFR = 8,
 1546                      KV_VDH_FNC_GETPRM = 9,
 1547                      KV_VDH_FNC_INT = 10,
 1548                      KV_VDH_FNC_INTINPOPR = 11,
 1549                      KV_VDH_FNC_OTPLCL = 12,
 1550                      KV_VDH_FNC_OTPMRK = 13,
 1551                      KV_VDH_FNC_PST = 14,
 1552                      KV_VDH_FNC_RLSBFR = 15,
 1553                      KV_VDH_FNC_RQSDAT = 16,
 1554                      KV_VDH_FNC_SETCLK = 17,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             43   
 1555                      KV_VDH_FNC_SETPRM = 18,
 1556                      KV_VDH_FNC_SRCINPFNCID = 19) = 0);
 1557      %LSET LISTDIR = '0'B;
 1558      %LSET LISTEXP = '1'B;
 1559      %LSET LISTCOM = '0'B;
 1560      %LSET LISTSUB = '1'B;
 1561      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1562      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1563      %LSET INIT = CHARTEXT('INIT');
 1564      %LSET ENIT = CHARTEXT('');
 1565      %ELSE;
 1566      %LSET INIT = CHARTEXT('/*');
 1567      %LSET ENIT = CHARTEXT('*/');
 1568      %ENDIF;
 1569      %IF LVL = 1;
 1570      DCL 1 NAME STCLASS ALIGNED,
 1571      %ELSE;
 1572      %(LVL) NAME ALIGNED,
 1573      %ENDIF;
 1574            %(LVL+1) %CHARTEXT('FNC') UBIN BYTE %INIT(FNC)%ENIT CALIGNED LAST
 1575      %MEND;
 1576
 1577      /*F* NAME:  KV$VDH_VDHINT - Parameters for Buffer and CQ Initialization
 1578
 1579      The KV$VDH_VDHINT macro in file KV$VDH generates the structure
 1580      passed by the handler to either the KVV$VDHINT routine or the
 1581      KVB$INT routine.
 1582
 1583      The KV$VDH_VDHINT structure may be initialized using the following
 1584      options:
 1585      */
 1586
 1587      %MACRO KV$VDH_VDHINT(NAME = KV$VDH_VDHINT, LAST = ";", STCLASS = BASED,
 1588                           RCVCQ_BYTSIZ = 4096, SNDCQ_BYTSIZ = 4096,
 1589                           BFRBGN = NIL, BFREND = NIL, MINBFR = 16, MAXPWR2 = 15,
 1590                           BUSYBFRS(YES = '1'B, NO = '0'B) = '0'B,
 1591                           BITMAPBFRS(YES = '1'B, NO = '0'B) = '1'B,
14:54 JUL 28 '97 KV$VDH.:E05SI                                             44   
 1592                           VLDBFR(YES = '1'B, NO = '0'B) = '0'B,
 1593                           VLDAFTGET(YES = '1'B, NO = '0'B) = '0'B,
 1594                           VLDAFTRLS(YES = '1'B, NO = '0'B) = '0'B);
 1595      %LSET LISTDIR = '0'B;
 1596      %LSET LISTEXP = '1'B;
 1597      %LSET LISTCOM = '0'B;
 1598      %LSET LISTSUB = '1'B;
 1599      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1600      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1601      %LSET INIT = CHARTEXT('INIT');
 1602      %LSET ENIT = CHARTEXT('');
 1603      %ELSE;
 1604      %LSET INIT = CHARTEXT('/*');
 1605      %LSET ENIT = CHARTEXT('*/');
 1606      %ENDIF;
 1607
 1608      DCL 1 NAME STCLASS ALIGNED,
 1609            2 BFRBGN$ PTR %INIT(ADDR(BFRBGN))%ENIT,
 1610      /*K* BFRBGN$ = PTR. Locates the first address of the free memory pool.
 1611      */
 1612            2 BFREND$ PTR %INIT(ADDR(BFREND))%ENIT,
 1613      /*K* BFREND$ = PTR. Locates the last address +1 of the free memory pool.
 1614      */
 1615            2 %CHARTEXT('MINBFR') UBIN BYTE CALIGNED %INIT(MINBFR)%ENIT,
 1616      /*K* MINBFR = VALUE-DEC(8-255).  Specifies the minimum buffer word
 1617      size.  MINBFR must be 16 for VDH.
 1618      */
 1619            2 %CHARTEXT('MAXPWR2') UBIN BYTE CALIGNED %INIT(MAXPWR2)%ENIT,
 1620      /*K* MAXPWR2 = VALUE-DEC(0-15). Specifies that the largest buffer allocatable
 1621           is 2 to the MAXPWR2 times MINBFR in size (up to 32768).  The
 1622           default is 15.
 1623      */
 1624            2 DBG,
 1625      /*K* DBG.  Contains a series of flags.  DBG should be initialized
 1626      from the NETCON parameter MMRINTCHC.*/
 1627              3 %CHARTEXT('BITMAPBFRS') BIT(1) %INIT(BITMAPBFRS)%ENIT,
 1628      /*K* DBG.BITMAPBFRS {YES|NO}.  Indicates whether a buffer usage bit-map is to be
14:54 JUL 28 '97 KV$VDH.:E05SI                                             45   
 1629      maintained.
 1630      */
 1631              3 %CHARTEXT('BUSYBFRS') BIT(1) %INIT(BUSYBFRS)%ENIT,
 1632      /*K* DBG.BUSYBFRS {YES|NO}.  Indicates whether allocated buffers are to be
 1633      initialized to a recognizable pattern containing the text 'BUSY' and
 1634      the hexadecimal double word 'BADxxxxx' where xxxxx is the address of
 1635      the call that got the buffer.
 1636      */
 1637              3 %CHARTEXT('VLDBFR') BIT(1) %INIT(VLDBFR)%ENIT,
 1638      /*K* DBG.VLDBFR {YES|NO}. Indicates whether the free buffer chains are to be
 1639      validated before every get or release operation
 1640      */
 1641              3 %CHARTEXT('VLDAFTGET') BIT(1) %INIT(VLDAFTGET)%ENIT,
 1642      /*K* DBG.VLDAFTGET {YES|NO}. Indicates whether the free buffer chains are to be
 1643      validated after every get operation
 1644      */
 1645              3 %CHARTEXT('VLDAFTRLS') BIT(1) %INIT(VLDAFTRLS)%ENIT,
 1646      /*K* DBG.VLDAFTRLS {YES|NO}. Indicates whether the free buffer chains are to be
 1647      validated after every release operation
 1648      */
 1649            2 * BIT(11) %INIT('0'B)%ENIT,
 1650            2 %CHARTEXT('RCVCQ_BYTSIZ') UBIN WORD %INIT(RCVCQ_BYTSIZ)%ENIT,
 1651      /*K* RCVCQ_BYTSIZ = VALUE-DEC(0-65535).  Specifies the receive circular queue
 1652      byte size.  (The receive circular queue is a circular queue used
 1653      by the monitor and session layer to deliver messages to VDH.)
 1654      This value should be initialized from the NETCON RCVCQBYTSIZ parameter.
 1655      This parameter is used on calls to KVV$VDHINT only; it is ignored
 1656      on calls to KVB$INT.
 1657      */
 1658            2 %CHARTEXT('SNDCQ_BYTSIZ') UBIN WORD %INIT(SNDCQ_BYTSIZ)%ENIT;
 1659      /*K* SNDCQ_BYTSIZ = VALUE-DEC(0-65535).  Specifies the send circular queue
 1660      byte size.  (The send circular queue is a circular queue used
 1661      by VDH to deliver messages to the monitor and session layer.)
 1662      This value should be initialized from the NETCON SNDCQBYTSIZ parameter.
 1663      This parameter is used on calls to KVV$VDHINT only; it is ignored
 1664      on calls to KVB$INT.
 1665      */
14:54 JUL 28 '97 KV$VDH.:E05SI                                             46   
 1666      %MEND;

