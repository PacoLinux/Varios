VERSION E05

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:1    
        1        1        /*M*          XUP$PARSE    GENERAL PURPOSE PARSING ROUTINE                    */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7
        8        8        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
        9        9        /*P*          NAME:    XUP$PARSE
       10       10        *
       11       11                      PURPOSE:    This file contains eight external procedures
       12       12                                  which, acting together, will perform a top-down
       13       13                                  recursive parse of an arbitrary input text line
       14       14                                  based on a user-input syntax tree.  The output
       15       15                                  is generated in a user-supplied work area.
       16       16                      DESCRIPTION:   The parser attempts to match character strings
       17       17                                  in the input text line with elements of the syntax
       18       18                                  graph which was provided by the caller.  The
       19       19                                  process continues until a match is made or no
       20       20                                  match is possible with the syntax graph.  The
       21       21                                  former case represents a successful parse, with
       22       22                                  meaningful output; the latter case is, by definition,
       23       23                                  a syntax error which will cause the parser to
       24       24                                  take the ALTRETURN exit from the routine.  Other
       25       25                                  ALTRETURNs include detection of null input text,
       26       26                                  null syntax graph, and insufficient size of the
       27       27                                  work area provided by the caller.
       28       28        */
       29       29        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:2    
       30       30        /*F*
       31       31            NAME: X$PARSE
       32       32            PURPOSE:
       33       33                To parse a command and return a tree of output blocks that
       34       34                represent its structure.
       35       35            DESCRIPTION:
       36       36                The X$PARSE routine is the external entry point to the parser.
       37       37                It sets up internal working storage, skips past any leading
       38       38                leading blanks and comments from the command to be parsed, and
       39       39                calls XUP$PARS, which is invoked recursively to perform the
       40       40                actual parse.  On return, X$PARSE sets up final information
       41       41                to be returned to the caller and exits.
       42       42
       43       43
       44       44                PARSER DATA STRUCTURES
       45       45
       46       46                The following data structures are used by the parser:
       47       47
       48       48                Global Data (G$D) -- contains all internal data items that are
       49       49                    passed across levels as nodes are parsed.  This structure
       50       50                    is alocated in the AUTO frame for X$PARSE, and is passed
       51       51                    as a parameter to all XUP$PARS calls.
       52       52
       53       53                Parse Control Block (PCB) -- contains data items passed to the
       54       54                    parser by the calling routine, or that are to be returned
       55       55                    to the caller.  This structure is provided by the caller,
       56       56                    passed as a parameter to X$PARSE, and passed to XUP$PARS
       57       57                    via G$D.PCB$ in the global data block.
       58       58
       59       59                Parse Nodes -- generated by PARTRGE from parse node source
       60       60                    definitions which specify the legal syntax for the command
       61       61                    being parsed.  The node for the root of the parse tree is
       62       62                    passed to X$PARSE by the caller in the PCB.  The address
       63       63                    of the node to be parsed by each invocation of XUP$PARS
       64       64                    is in G$D on entry to that routine.
       65       65
       66       66                Local Data -- values that pertain to a given invocation of
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:3    
       67       67                    XUP$PARS are kept in the AUTO stack for that invocation.
       68       68                    Since values in the blocks defined above are passed from
       69       69                    level to level, and can be changed at each level, a local
       70       70                    copy of any data that must be remembered at a given level
       71       71                    must be kept (e.g., G$D.NODE$ points to the node to parse
       72       72                    on entry, but may be changed for recursive calls to parse
       73       73                    subnodes, so the pointer for the node being parsed is kept
       74       74                    in a local copy, and that copy is always used to access
       75       75                    the node.)
       76       76
       77       77                Parse Work Area -- is a block of contiguous memory provided by
       78       78                    the caller which is used to hold output blocks, the parse
       79       79                    stack, and other dynamically allocated data.  The staring
       80       80                    address of the work area, and its size, are passed to the
       81       81                    parser in the PCB.
       82       82
       83       83
       84       84                PARSE WORK AREA LAYOUT
       85       85
       86       86                The parser builds several different dynamically allocated
       87       87                structures, so some clever memory management is needed to
       88       88                pack them all into a single block of memory.  There are two
       89       89                major parts to the work area, one growing up from the start
       90       90                of the work area, the other growing down from the top.  If
       91       91                the two collide, the work area is too small to complete the
       92       92                parse.  The caller can provide an exit routine to expand the
       93       93                work area if this happens.  If no such routine is available,
       94       94                the parse aborts if the work area fills up.
       95       95
       96       96                Output blocks are built starting at the beginning of the work
       97       97                area, and expanding up as necessary.  Since blocks created by
       98       98                attempts to parse a node that ultimately fails are released,
       99       99                this part of the work area is maintained using a free space
      100      100                chain, so that the space occupied by blocks that are released
      101      101                can be reused.  Other temporary structures, such as reducing
      102      102                alternative list flag blocks, are also kept in this part of
      103      103                the work area.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:4    
      104      104
      105      105                The parse stack is built starting at the end of the work area.
      106      106                It grows down as output block pointers are added to the stack,
      107      107                and back up as they are popped off the stack.
      108      108
      109      109                Pointers that delimit the parts of the work area are kept in
      110      110                the G$D block.  The work area layout is shown schematically
      111      111                as follows:
      112      112
      113      113                +--------------------+ <-- G$D.FREEANCHOR$ = PCB.WORK$
      114      114                | free chain header  |
      115      115                |--------------------|
      116      116                |                    |
      117      117                |       used         |
      118      118                |     workspace      |
      119      119                |                    |
      120      120                |--------------------| <-- G$D.LASTFREE$
      121      121                | free chain trailer |
      122      122                |--------------------| <-- G$D.HISPACE$
      123      123                |                    |
      124      124                |       unused       |
      125      125                |     workspace      |
      126      126                |                    |
      127      127                |--------------------| <-- G$D.STACKTOP$
      128      128                |                    |
      129      129                |     parse stack    |
      130      130                |                    |
      131      131                +--------------------+ <-- PCB.WORK$ + PCB.WKSZ
      132      132
      133      133
      134      134                REPARSING FOR LEGAL POSSIBILITIES
      135      135
      136      136                The parser can also be called to display a list of valid
      137      137                next nodes at a given point in a command.  This is normally
      138      138                done just after the command has failed to parse; information
      139      139                needed to do the reparse is taken from values returned in the
      140      140                PCB from the original parse.  In particular:
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:5    
      141      141
      142      142                PCB.HI_CHAR -- denotes the position in the command at which
      143      143                    legal possibilities are to be reported.
      144      144                PCB.WK_USED -- gives the offset into the work area where the
      145      145                    list of possible next nodes is to be built.  This field
      146      146                    is set to the high-water mark of G$D.HISPACE$ from the
      147      147                    original parse; since the reparse should duplicate (or be
      148      148                    a subset of) the original one, work space above this point
      149      149                    will not be used by the reparse.  The possibility list is
      150      150                    thus built in the unused workspace between the output area
      151      151                    and parse stack from the orginal parse.
      152      152
      153      153                When reparsing, XUP$PARS acts just as it did for the original
      154      154                parse up to the point of PCB.HI_CHAR, but any attempt to parse
      155      155                a node for a lexeme at that point is forced to fail, and the
      156      156                address of that node is added to the possibility list.  Thus
      157      157                a list of all possible nodes at that point is accumulated, and
      158      158                the parse always fails.  The syntax error logic in X$PARSE
      159      159                then calls XUP$DMPNXT to write out the list of accumulated
      160      160                possible nodes.
      161      161
      162      162            REFERENCE:
      163      163                User documentation for the parser, and descriptions of all
      164      164                externally visible data structures, can be found in the XUP
      165      165                section of Host Library Services Reference (CE71).
      166      166
      167      167                Parse nodes and PARTRGE are described in Appendix A of CE71.
      168      168        */
      169      169        /*F*
      170      170            NAME: XUP$PARS
      171      171            PURPOSE:
      172      172                To attempt to parse a node.
      173      173            DESCRIPTION:
      174      174                A command is parsed by recursive calls to this routine.  On
      175      175                each invocation, it attempts to match the command source text
      176      176                to the pattern specified by a given node.  If successful, it
      177      177                builds the output block (if any) for the node, and puts the
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:6    
      178      178                address of that block on the top of the parse stack.  If the
      179      179                attempted parse fails, it releases any output blocks that had
      180      180                been created during the attempted parse, and altreturns to
      181      181                indicate failure.
      182      182
      183      183                This routine is first called from X$PARSE to parse the root
      184      184                node for the command.  An altreturn from that call indicates
      185      185                a syntax error; no path through the nodes matches the command.
      186      186
      187      187                The root node typically defines a number of subnodes; XUP$PARS
      188      188                is called recursively to try to parse each subnode.  If those
      189      189                nodes also have subnodes, XUP$PARS is called again, and so on,
      190      190                for as many levels as there are subnodes.  An altreturn from
      191      191                an inner level call may or may not indicate a syntax error;
      192      192                if the node is optional, or one of a list of alternatives,
      193      193                the attempted parse of the calling node can continue with the
      194      194                next node or alternative.
      195      195
      196      196                Each invocation of XUP$PARS normally builds a single output
      197      197                block.  But, if the node for that call has subnodes, any
      198      198                number of output blocks can be built by lower level recursive
      199      199                calls.  If the parse at a given level succeeds, the output
      200      200                block for that level will contain pointers to the blocks for
      201      201                the next lower level.  The parse stack keeps track of blocks
      202      202                built at various levels.  When any block is created, a pointer
      203      203                to it is put on the top of the stack.  At each level, the
      204      204                current top-of-stack position is saved on entry; on exit, any
      205      205                stack entries above that point are either used in the block
      206      206                built for that call (on successful parse) or the blocks they
      207      207                point to are released (on failure).  On successful return from
      208      208                the top level call, the stack will contain the output block(s)
      209      209                for the root node.
      210      210
      211      211                (Note: Users of X$PARSE commonly call the tree it builds the
      212      212                "parse nodes" for a command.  Here, "nodes" refers to the blocks
      213      213                PARTRGE builds to define the command syntax; blocks built by
      214      214                X$PARSE are called "output blocks".)
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:7    
      215      215        */
      216      216        /*F*
      217      217            NAME: XUP$COMCHK
      218      218            PURPOSE:
      219      219                To check for leading blanks and comments.
      220      220            DESCRIPTION:
      221      221                This entry point into XUP$PARS is used by X$PARSE to take
      222      222                advantage of common subroutines for scanning past blanks and
      223      223                comments.
      224      224        */
      225      225        /*F*
      226      226            NAME: XUP$EXPAND_WORKAREA
      227      227            PURPOSE:
      228      228                To attempt to expand the work area.
      229      229            DESCRIPTION:
      230      230                This entry point into XUP$PARS is used by XUP$GETSPACE to take
      231      231                advantage of common logic for attempting to expand the parse
      232      232                work area.
      233      233        */
      234      234        /*F*
      235      235            NAME: XUP$GETSPACE
      236      236            PURPOSE:
      237      237                To allocate a block in the parse work area.
      238      238            DESCRIPTION:
      239      239                This routine is called to allocate space in the parse work
      240      240                area.  It first checks the free space chain to see if a block
      241      241                of the required size is available.  If so, the requested block
      242      242                is allocated out of the free space, otherwise it increased the
      243      243                amount of used work space and allocates the new block at the
      244      244                end.  If expanding the used space would collide with the parse
      245      245                stack, the routine tries to expand the work area by calling
      246      246                XUP$EXPAND_WORKAREA.
      247      247        */
      248      248        /*F*
      249      249            NAME: XUP$FREESPACE
      250      250            PURPOSE:
      251      251                To free a block in the parse work area.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:8    
      252      252            DESCRIPTION:
      253      253                This routine is called to release blocks in the parse work
      254      254                area, and add them to the free space chain.  If the block
      255      255                just freed is adjacent to a block already on the free chain,
      256      256                the blocks are combined to avoid unnecessary fragmentation.
      257      257        */
      258      258        /*F*
      259      259            NAME: XUP$FREEOUT
      260      260            PURPOSE:
      261      261                To free all blocks associated with a given parse output block.
      262      262            DESCRIPTION:
      263      263                This routine calls itself recursively to free any sub-blocks
      264      264                of the output block it is given, the calls XUP$FREESPACE to
      265      265                free the block itself.
      266      266        */
      267      267        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:9    
      268      268        XUP$PARSE:
      269      269            PROC(PCB)  ALTRET;
      270      270
      271      271        %INCLUDE      XU_MACRO_C;
      272     3377        %INCLUDE      XU_SUBS_C;
      273     3469        %INCLUDE      XU_PERR_C;
      274     3660        /*
      275     3661            ***       INPUT PARAMETER
      276     3662        */
      277     3663            %P$PCB(NAME=PCB,STCLASS=" ");
      278     3864
      279     3865        /*
      280     3866            ***       EXTERNAL ENTRY DEFINITION
      281     3867        */
      282     3868    1   DCL XUP$COMCHK ENTRY(1) ALTRET;
      283     3869    1   DCL XUP$DMPNXT ENTRY(1);
      284     3870    1   DCL XUP$PARS ENTRY(1) ALTRET;
      285     3871    1   DCL       XUP$GETSPACE   ENTRY(3);
      286     3872        /*
      287     3873            ***       LOCAL DATA
      288     3874        */
      289     3875    1   DCL     C$BUF    CHAR(PCB.NCHARS) BASED;
      290     3876    1   DCL       C$BUFA(0:0)    CHAR(1)     BASED;
      291     3877    1   DCL       BLK$     PTR   BASED;
      292     3878    1   DCL  WORDS(0:0)BASED ALIGNED UBIN;
      293     3879        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:10   
      294     3880        %LIST;
      295     3881        /*
      296     3882            ***       DEFINE ALL DATA WHICH IS TO BE GLOBAL TO X$PARSE ROUTINES
      297     3883            ***       IN THE DRIVER (X$PARSE) ROUTINE; THIS DATA STRUCTURE WILL
      298     3884            ***       THEN BE PASSED AS A PARAMETER TO ALL ROUTINES USING THE DATA.
      299     3885        */
      300     3886            %G$D(STCLASS=AUTO);
              3887        /*F*  NAME:     G$D
              3888              FUNCTION: a data structure owned and managed by X$PARSE, used to
              3889                  retain and pass useful information throughout the lifetime
              3890                  of a parsing operation.  Tampering with this structure's
              3891                  contents by a user-supplied routine will void the warranty,
              3892                  and may expose the programmer to high-voltage screams of
              3893                  anguish from the software-support staff.
              3894        */
              3895    1   DCL 1 NAME ALIGNED STCLASS,
              3896    1         2 PCB$ PTR,
              3897        /*K* PCB$ - pointer to Parse Control Block.
              3898        */
              3899    1         2 ERROR REMEMBER,
              3900        /*K* ERROR - error return point.  Any error other than a syntax error
              3901                    that is detected during parsing unwinds to G$D.ERROR
              3902                    after setting the error code and other error return
              3903                    information in the PCB; this results in an altreturn
              3904                    from X$PARSE.
              3905        */
              3906    1         2 NODE$ PTR,
              3907        /*K* NODE$ - pointer to node to attempt to parse.  This is reset for
              3908                    each call to XUP$PARS to pass it the node it is to try to
              3909                    parse.  Within XUP$PARS, a local copy of this pointer is
              3910                    used to access the node, since this field will be reset by
              3911                    subsequent recursive calls to attempt to parse subnodes.
              3912        */
              3913    1         2 FREEANCHOR$ PTR,
              3914        /*K* FREEANCHOR$ - pointer to the first block in the free space chain
              3915                    for the parse work area.
              3916        */
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:11   
              3917    1         2 LASTFREE$ PTR,
              3918        /*K* LASTFREE$ - pointer to the last block in the free space chain
              3919                    for the parse work area.
              3920        */
              3921    1         2 HISPACE$ PTR,
              3922        /*K* HISPACE$ - pointer to the next available word in the parse work area.
              3923        */
              3924    1         2 STACKTOP$ PTR,
              3925        /*K* STACKTOP$ - pointer to the top element in the parse stack at the
              3926                    end of the parse work area.
              3927        */
              3928    1         2 REDUCE$ PTR,
              3929        /*K* REDUCE$ - root address for the current reducing alternative flag
              3930                    block list; NIL if the list is empty.
              3931        */
              3932    1         2 SCRATCH SBIN WORD,
              3933        /*K* SCRATCH - scratch word for use by X$PARSE (redefinition of CNTUPOS).
              3934        */
              3935    1         2 CNTUPOS REDEF SCRATCH SBIN WORD,
              3936        /*K* CNTUPOS - offset of the start of the command text from the current
              3937                command text pointer (PCB.TEXT$).  If continuation lines are
              3938                appended to command text for previous lines, this will always
              3939                be zero.  If continuation lines overlay the previous lines,
              3940                this will be a negative number equal to the number of characters
              3941                in prior lines that have been lost in overlaid lines.
              3942        */
              3943    1         2 CCPOS SBIN WORD,
              3944        /*K* CCPOS - the current position in the command text.
              3945        */
              3946    1         2 CLEXPOS SBIN WORD,
              3947        /*K* CLEXPOS - the current lexical position in the command text; used
              3948                to determine if part of the text to be returned by an RTEXT
              3949                node has been overlaid by a continuation line.
              3950        */
              3951    1         2 CCHAR CHAR(1) CALIGNED,
              3952        /*K* CCHAR - the character at the current position in the command text.
              3953        */
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:12   
              3954    1         2 BLSKIP BIT(1) UNAL,
              3955        /*K* BLKSIP - blank skip flag; set if some whitespace has been skipped
              3956                at the end of the last lexeme parsed.
              3957        */
              3958    1         2 *       BIT(26) UNAL,
              3959    1         2 LDCMNT,
              3960        /*K* LDCMNT - the length (.CT) and text (.TX) of the leading comment delimiter.
              3961                    This is derived from PCB.COMMENT.LEAD when X$PARSE is first
              3962                    entered.
              3963        */
              3964    1           3 CT UBIN HALF HALIGNED,
              3965    1           3 TX CHAR(2) CALIGNED,
              3966    1           3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
              3967    1         2 TRCMNT,
              3968        /*K* TRCMNT - the length (.CT) and text (.TX) of the trailing comment delimiter.
              3969                    This is derived from PCB.COMMENT.LEAD when X$PARSE is first
              3970                    entered.
              3971        */
              3972    1           3 CT UBIN HALF HALIGNED,
              3973    1           3 TX CHAR(2) CALIGNED,
              3974    1           3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
              3975    1         2 TBUF CHAR(511);
              3976        /*K* TBUF - temporary buffer for various uses within XUP$PARS.
              3977                    (Defining it here rather than in local auto saves 128 words
              3978                    per invocation, which can become quite significant for such
              3979                    a highly recursive routine.)
              3980        */
      301     3982        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:13   
      302     3983        /*
      303     3984            ***       GENERATE THE BASED STRUCTURE USED TO BUILD AND UTILIZE
      304     3985            ***       THE SPACE-CHAIN IN THE USER-SUPPLIED WORK BUFFER.
      305     3986        */
      306     3987             %XUP$CHAIN;
              3988    1   DCL 1 FREE$HDR BASED ALIGNED,           /* FREE CHAIN BLOCK HEADER            */
              3989    1         2 NWORDS SBIN UNAL,               /* COUNT OF WORDS IN BLOCK            */
              3990    1         2 NEXT$ PTR UNAL,                 /* FORWARD LINK TO NEXT FREE BLOCK    */
              3991    1         2 PREV$ PTR;                 /* BACKWARD LINK TP PREVIOUS FREE BLOCK    */
      307     3993        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:14   
      308     3994        /*
      309     3995            ***       GENERATE THE BASED STRUCTURE USED TO DEFINE POSSIBLE
      310     3996            ***       ALTERNATIVE NODES AT THE POINT OF ERROR IN A COMMAND.
      311     3997        */
      312     3998            %XUP$POSS (NAME=POSS);
              3999    1   DCL 1 NAME STCLASS ALIGNED,     /* LEGAL POSSIBILITY LIST STRUCTURE */
              4000    1         2 COUNT SBIN,             /* NUMBER OF NODES IN LIST          */
              4001    1         2 NODES$ (0:0) PTR;       /* POSSIBLE NEXT NODE ARRAY         */
      313     4003        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:15   
      314     4004        %PLIST;
      315     4005        /*
      316     4006            ***       GENERATE THE BASED STRUCTURE USED TO GENERATE THE OUTPUT
      317     4007            ***       BLOCKS RETURNED TO THE USER IN HIS WORK BUFFER.
      318     4008        */
      319     4009            %PARSE$OUT(STCLASS=BASED);
      320     4054        /*
      321     4055            ***       MACRO TO GENERATE XUP ERROR CODES
      322     4056        */
      323     4057        %MACRO ERRCODE(NAME=' ',STCLASS="CONSTANT SYMDEF",CODE=0,SEV=0);
      324     4058        DCL 1 NAME ALIGNED STCLASS,
      325     4059              2 * BIT(12) UNAL INIT('3025'O), /*'XU'*/
      326     4060              2 * BIT(6) UNAL INIT('20'O),  /*'P'*/
      327     4061              2 * BIT(1) UNAL INIT('0'B),
      328     4062              2 * UBIN(14) UNAL INIT(CODE),
      329     4063              2 * UBIN(3) UNAL INIT(0);
      330     4064        %MEND;
      331     4065        /*
      332     4066            ***       GENERATE ERROR CODES RETURNED BY X$PARSE
      333     4067        */
      334     4068            %ERRCODE(NAME=SYN_ERR,CODE=%E$SYNERR);
      335     4076            %ERRCODE(NAME=NULL_ROOT,CODE=%E$NULLROOT);
      336     4084            %ERRCODE(NAME=BAD_NODE,CODE=%E$BADNODE);
      337     4092            %ERRCODE(NAME=OVER_FLOW,CODE=%E$WKOVERFLOW);
      338     4100            %ERRCODE(NAME=SMALL_WORK,CODE=%E$SMALLWORK);
      339     4108            %ERRCODE(NAME=NULL_U$$,CODE=%E$NULLU$$);
      340     4116            %ERRCODE(NAME=PRE_C00,CODE=%E$PCB_PRE_C00);
      341     4124            %ERRCODE(NAME=CANT_RTEXT,CODE=%E$CANT_RTEXT);
      342     4132            %ERRCODE(NAME=RTEXT_GT_511,CODE=%E$RTEXT_GT_511);
      343     4140            %ERRCODE(NAME=ILLEGAL_DYNAMIC_EXPANSION,CODE=%E$EXPAND_ERROR);
      344     4148        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:16   
      345     4149        /*D*          NAME:    X$PARSE
      346     4150        *
      347     4151                      CALL:    CALL X$PARSE(PCB) ALTRET(PARSE_ERR);
      348     4152        *
      349     4153                      INTERFACE:  XUP$PARS
      350     4154                                  XUP$COMCHK, XUP$GETSPACE
      351     4155                                  XUP$DMPNXT
      352     4156        *
      353     4157                      ENVIRONMENT:   Mapped, slave, caller's ISR.
      354     4158        *
      355     4159                      INPUT:   Parse Control Block(PCB), a user-generated table
      356     4160                               containing the information necessary to perform the
      357     4161                               parse.
      358     4162                      OUTPUT:  A pointer is established in the caller's PCB which
      359     4163                               defines the beginning of the output generated as a
      360     4164                               result of a successful parse; the content of the output
      361     4165                               is dependent on information (the syntax graph) which
      362     4166                               was contained in the PCB.
      363     4167        */
      364     4168    1   X$PARSE:
      365     4169    1       ENTRY(PCB) ALTRET;
      366     4170        /*
      367     4171            ***       BEGIN PROCEDURE          ***
      368     4172        */
      369     4173    1       G$D='0'B;
      370     4174    1       G$D.PCB$ = ADDR(PCB);
      371     4175        /*
      372     4176            ***       ESTABLISH THE ERROR HANDLER
      373     4177        */
      374     4178    1       REMEMBER ERROR IN G$D.ERROR;
      375     4179        /*
      376     4180                Check for obvious errors in parameters.
      377     4181        */
      378     4182    1       IF PCB.VERSION_CODE = 0
      379     4183    2       THEN DO;
      380     4184
      381     4185        /*E*     ERROR:   XUP-E$PCB_PRE_C00
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:17   
      382     4186                 MESSAGE: Parse control block is pre-C00;  cannot parse.
      383     4187                 MESSAGE1: The parse control block (PCB) passed to X$PARSE appears
      384     4188                          to be of pre-C00 vintage.  The format of X$PARSE nodes
      385     4189                          (produced by PARTRGE) was changed substantially for the
      386     4190                          C00 version of CP-6, and pre-C00 nodes/PCBs/PARSE$BLKs
      387     4191                          (etc.) are not compatible with this parser.  Your program
      388     4192                          must be updated if you wish to run it on a D00 (or later)
      389     4193                          version of CP-6.  This will require:
      390     4194
      391     4195                          1) Recompiling all PL-6 routines that use any of the parser's
      392     4196                             data structures;
      393     4197
      394     4198                          2) Re-PARTRGEing all of the program's parse nodes;  and
      395     4199
      396     4200                          3) Re-LINKing the run unit.
      397     4201
      398     4202                          Please see the "CP-6 C00 System Release Bulletin", or the
      399     4203                          Host Library Services manual (CE71) for the necessary
      400     4204                          information and procedures.
      401     4205        */
      402     4206    2           PCB.ERROR = PRE_C00;
      403     4207    2           ALTRETURN;
      404     4208
      405     4209    2       END;
      406     4210
      407     4211    1       IF PCB.WKSZ < (PCB.NCHARS + 4)/4 + 10 THEN
      408     4212    2       DO;
      409     4213
      410     4214        /*E*          ERROR:   XUP-E$SMALLWORK-C
      411     4215                      MESSAGE:    Work area too small for X$PARSE
      412     4216                      MESSAGE1:   Minimum size of work area required for X$PARSE
      413     4217                               must at least equal the size of the string to be
      414     4218                               parsed plus 10 words.
      415     4219        */
      416     4220
      417     4221    2           PCB.ERROR = SMALL_WORK;
      418     4222    2           ALTRETURN;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:18   
      419     4223    2       END;
      420     4224
      421     4225    1       IF PCB.ROOT$ = ADDR(NIL) THEN
      422     4226    2       DO;
      423     4227
      424     4228        /*E*          ERROR:   XUP-E$NULLROOT-C
      425     4229                      MESSAGE:    Null syntax tree passed to X$PARSE
      426     4230                      MESSAGE1:   Pointer to the syntax tree, which was passed in
      427     4231                               the Parse Control Block, is null.
      428     4232        */
      429     4233
      430     4234    2           PCB.ERROR = NULL_ROOT;
      431     4235    2           ALTRETURN;
      432     4236    2       END;
      433     4237        /*
      434     4238           *****   Initialize the free-space chain in the WORK area beginning
      435     4239           *****   at its beginning.  Establish the stack at the
      436     4240           *****   end of the WORK area (grows down from the end).
      437     4241        */
      438     4242    1       G$D.FREEANCHOR$ = PCB.WORK$;
      439     4243    1       G$D.FREEANCHOR$->FREE$HDR.PREV$ = ADDR(NIL);
      440     4244    1       G$D.FREEANCHOR$->FREE$HDR.NWORDS = 3;
      441     4245    1       G$D.LASTFREE$ = PINCRW(G$D.FREEANCHOR$,3);
      442     4246    1       G$D.FREEANCHOR$->FREE$HDR.NEXT$ = G$D.LASTFREE$;
      443     4247    1       G$D.LASTFREE$->FREE$HDR.NWORDS = 3;
      444     4248    1       G$D.LASTFREE$->FREE$HDR.PREV$ = G$D.FREEANCHOR$;
      445     4249    1       G$D.LASTFREE$->FREE$HDR.NEXT$ = ADDR(NIL);
      446     4250    1       G$D.HISPACE$ = PINCRW(G$D.LASTFREE$,2);
      447     4251    1       G$D.STACKTOP$ = PINCRW(PCB.WORK$,PCB.WKSZ);
      448     4252    1       G$D.REDUCE$ = ADDR(NIL);
      449     4253        /*
      450     4254            *****   Set up comment delimiters in a form more convenient for
      451     4255            *****   internal use.
      452     4256        */
      453     4257    1       IF SUBSTR(PCB.COMMENT.LEAD,0,1) = ' ' THEN
      454     4258    2       DO;
      455     4259    2           IF SUBSTR(PCB.COMMENT.LEAD,1,1) = ' ' THEN
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:19   
      456     4260    3           DO;
      457     4261    3               G$D.LDCMNT.CT = 0;
      458     4262    3               G$D.LDCMNT.TX = BINASC(0);
      459     4263    3           END;
      460     4264    2           ELSE
      461     4265    3           DO;
      462     4266    3               G$D.LDCMNT.CT = 1;
      463     4267    3               G$D.LDCMNT.TX = SUBSTR(PCB.COMMENT.LEAD,1,1);
      464     4268    3           END;
      465     4269    2       END;
      466     4270    1       ELSE
      467     4271    2       DO;
      468     4272    2           G$D.LDCMNT.CT = 2;
      469     4273    2           G$D.LDCMNT.TX = PCB.COMMENT.LEAD;
      470     4274    2       END;
      471     4275    1       IF SUBSTR(PCB.COMMENT.TRAIL,0,1) = ' ' THEN
      472     4276    2       DO;
      473     4277    2           IF SUBSTR(PCB.COMMENT.TRAIL,1,1) = ' ' THEN
      474     4278    2               G$D.TRCMNT.CT = 0;
      475     4279    2           ELSE
      476     4280    3           DO;
      477     4281    3               G$D.TRCMNT.CT = 1;
      478     4282    3               G$D.TRCMNT.TX = SUBSTR(PCB.COMMENT.TRAIL,1,1);
      479     4283    3           END;
      480     4284    2       END;
      481     4285    1       ELSE
      482     4286    2       DO;
      483     4287    2           G$D.TRCMNT.CT = 2;
      484     4288    2           G$D.TRCMNT.TX = PCB.COMMENT.TRAIL;
      485     4289    2       END;
      486     4290        /*
      487     4291        *****   Check for leading comment or comment only and adjust character
      488     4292        *****   position accordingly.
      489     4293        */
      490     4294    1       IF PCB.NOLEADBLANKS
      491     4295    1       THEN
      492     4296    1           IF PCB.NCHARS ~= 0
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:20   
      493     4297    1           THEN
      494     4298    1               G$D.CCHAR = PCB.TEXT$ -> C$BUFA(0);
      495     4299    1           ELSE
      496     4300    1               ;
      497     4301    1       ELSE
      498     4302    1           CALL XUP$COMCHK(G$D);
      499     4303        /*
      500     4304        ***           ATTEMPT THE PARSE
      501     4305        */
      502     4306    1       IF PCB.NXT
      503     4307    1       THEN
      504     4308    1           PINCRW(PCB.WORK$,PCB.WK_USED) -> POSS = '0'B;
      505     4309    2       ELSE DO;
      506     4310    2           PCB.HI_CHAR=G$D.CCPOS;
      507     4311    2           PCB.HINODE$ = ADDR(NIL);
      508     4312    2           PCB.WK_USED = 0;
      509     4313    2           PCB.ERROR = '0'B; /*CLEAR THE ERROR CODE */
      510     4314    2       END;
      511     4315    1       G$D.NODE$=PCB.ROOT$;
      512     4316    1       CALL XUP$PARS(G$D) ALTRET(SYNERR);
      513     4317        /*
      514     4318            *****   Clear out the node stack:
      515     4319                    If there is only one unassigned output node, it becomes
      516     4320                    the top level node.
      517     4321                    Otherwise, create a dummy output block to be the top level
      518     4322                    output node, containing all remaining unassigned nodes.
      519     4323        */
      520     4324    1       G$D.SCRATCH = PCB.WKSZ - POFFW(G$D.STACKTOP$, PCB.WORK$);
      521     4325    1       IF G$D.SCRATCH = 1 THEN
      522     4326    1           PCB.OUT$ = G$D.STACKTOP$->BLK$;
      523     4327    1       ELSE
      524     4328    2       DO;
      525     4329    2           CALL XUP$GETSPACE(G$D.SCRATCH + 3,PCB.OUT$,G$D);
      526     4330    2           PCB.OUT$->OUT$BLK.NSUBLKS = G$D.SCRATCH;
      527     4331    2           PCB.OUT$->OUT$BLK.TEMP = '1'B;
      528     4332    3           DO WHILE(G$D.SCRATCH > 0);
      529     4333    3               G$D.SCRATCH = G$D.SCRATCH - 1;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:21   
      530     4334    3               PCB.OUT$->OUT$BLK.SUBLK$(G$D.SCRATCH) =
      531     4335    3                 G$D.STACKTOP$->BLK$;
      532     4336    3               G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);
      533     4337    3           END;
      534     4338    2       END;
      535     4339    1       PCB.WK_USED = POFFW(G$D.HISPACE$,PCB.WORK$) + 3;
      536     4340    1       RETURN;
      537     4341        /*
      538     4342            *****   SYNTAX ERROR HANDLER
      539     4343        */
      540     4344    1   SYNERR:
      541     4345
      542     4346        /*E*          ERROR:   XUP-E$SYNERR-C
      543     4347                      MESSAGE:    Syntax error
      544     4348                      MESSAGE1:   X$PARSE failed to match the input text string with
      545     4349                               any branch of the syntax tree.
      546     4350        */
      547     4351
      548     4352    1       PCB.ERROR = SYN_ERR;
      549     4353    1       IF PCB.NXT AND NOT PCB.NXT_SZONLY
      550     4354    1       THEN
      551     4355    1           CALL XUP$DMPNXT (G$D);
      552     4356
      553     4357    1       PCB.WK_USED = POFFW(G$D.HISPACE$,PCB.WORK$) + 6;
      554     4358        /*
      555     4359            ***       ERROR HANDLER
      556     4360                      (Any error other than a syntax error unwinds to here)
      557     4361        */
      558     4362    1   ERROR:
      559     4363    1       ALTRETURN;
      560     4364    1   END   XUP$PARSE;
      561     4365        %EOD;

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:22   
--  Include file information  --

   XU_PERR_C.:E05TOU  is referenced.
   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$PARSE.

   Procedure XUP$PARSE requires 242 words for executable code.
   Procedure XUP$PARSE requires 152 words of local(AUTO) storage.

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:23   

 Object Unit name= XUP$PARSE                                  File name= XUP$PARSE.:E05TOU
 UTS= JUL 30 '97 09:37:12.36 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0  RoData even  UTS     10     12  XUP$PARSE
    1   Proc  even  none   242    362  XUP$PARSE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes    yes     yes      Std        1  XUP$PARSE
     1      3          yes     yes      Std        1  X$PARSE

  ****  Data defs  ****

 Sect OctLoc  Name                           Sect OctLoc  Name
    0      0  SYN_ERR                            0      1  NULL_ROOT
    0      2  BAD_NODE                           0      3  OVER_FLOW
    0      4  SMALL_WORK                         0      5  NULL_U$$
    0      6  PRE_C00                            0      7  CANT_RTEXT
    0     10  RTEXT_GT_511                       0     11  ILLEGAL_DYNAMIC_EXPANSION
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:24   

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUP$COMCHK
 yes     yes           Std       1 XUP$PARS
         yes           Std       3 XUP$GETSPACE
         yes           Std       1 XUP$DMPNXT
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AALT
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:25   


        1        1        /*M*          XUP$PARSE    GENERAL PURPOSE PARSING ROUTINE                    */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7
        8        8        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
        9        9        /*P*          NAME:    XUP$PARSE
       10       10        *
       11       11                      PURPOSE:    This file contains eight external procedures
       12       12                                  which, acting together, will perform a top-down
       13       13                                  recursive parse of an arbitrary input text line
       14       14                                  based on a user-input syntax tree.  The output
       15       15                                  is generated in a user-supplied work area.
       16       16                      DESCRIPTION:   The parser attempts to match character strings
       17       17                                  in the input text line with elements of the syntax
       18       18                                  graph which was provided by the caller.  The
       19       19                                  process continues until a match is made or no
       20       20                                  match is possible with the syntax graph.  The
       21       21                                  former case represents a successful parse, with
       22       22                                  meaningful output; the latter case is, by definition,
       23       23                                  a syntax error which will cause the parser to
       24       24                                  take the ALTRETURN exit from the routine.  Other
       25       25                                  ALTRETURNs include detection of null input text,
       26       26                                  null syntax graph, and insufficient size of the
       27       27                                  work area provided by the caller.
       28       28        */
       29       29        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:26   
       30       30        /*F*
       31       31            NAME: X$PARSE
       32       32            PURPOSE:
       33       33                To parse a command and return a tree of output blocks that
       34       34                represent its structure.
       35       35            DESCRIPTION:
       36       36                The X$PARSE routine is the external entry point to the parser.
       37       37                It sets up internal working storage, skips past any leading
       38       38                leading blanks and comments from the command to be parsed, and
       39       39                calls XUP$PARS, which is invoked recursively to perform the
       40       40                actual parse.  On return, X$PARSE sets up final information
       41       41                to be returned to the caller and exits.
       42       42
       43       43
       44       44                PARSER DATA STRUCTURES
       45       45
       46       46                The following data structures are used by the parser:
       47       47
       48       48                Global Data (G$D) -- contains all internal data items that are
       49       49                    passed across levels as nodes are parsed.  This structure
       50       50                    is alocated in the AUTO frame for X$PARSE, and is passed
       51       51                    as a parameter to all XUP$PARS calls.
       52       52
       53       53                Parse Control Block (PCB) -- contains data items passed to the
       54       54                    parser by the calling routine, or that are to be returned
       55       55                    to the caller.  This structure is provided by the caller,
       56       56                    passed as a parameter to X$PARSE, and passed to XUP$PARS
       57       57                    via G$D.PCB$ in the global data block.
       58       58
       59       59                Parse Nodes -- generated by PARTRGE from parse node source
       60       60                    definitions which specify the legal syntax for the command
       61       61                    being parsed.  The node for the root of the parse tree is
       62       62                    passed to X$PARSE by the caller in the PCB.  The address
       63       63                    of the node to be parsed by each invocation of XUP$PARS
       64       64                    is in G$D on entry to that routine.
       65       65
       66       66                Local Data -- values that pertain to a given invocation of
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:27   
       67       67                    XUP$PARS are kept in the AUTO stack for that invocation.
       68       68                    Since values in the blocks defined above are passed from
       69       69                    level to level, and can be changed at each level, a local
       70       70                    copy of any data that must be remembered at a given level
       71       71                    must be kept (e.g., G$D.NODE$ points to the node to parse
       72       72                    on entry, but may be changed for recursive calls to parse
       73       73                    subnodes, so the pointer for the node being parsed is kept
       74       74                    in a local copy, and that copy is always used to access
       75       75                    the node.)
       76       76
       77       77                Parse Work Area -- is a block of contiguous memory provided by
       78       78                    the caller which is used to hold output blocks, the parse
       79       79                    stack, and other dynamically allocated data.  The staring
       80       80                    address of the work area, and its size, are passed to the
       81       81                    parser in the PCB.
       82       82
       83       83
       84       84                PARSE WORK AREA LAYOUT
       85       85
       86       86                The parser builds several different dynamically allocated
       87       87                structures, so some clever memory management is needed to
       88       88                pack them all into a single block of memory.  There are two
       89       89                major parts to the work area, one growing up from the start
       90       90                of the work area, the other growing down from the top.  If
       91       91                the two collide, the work area is too small to complete the
       92       92                parse.  The caller can provide an exit routine to expand the
       93       93                work area if this happens.  If no such routine is available,
       94       94                the parse aborts if the work area fills up.
       95       95
       96       96                Output blocks are built starting at the beginning of the work
       97       97                area, and expanding up as necessary.  Since blocks created by
       98       98                attempts to parse a node that ultimately fails are released,
       99       99                this part of the work area is maintained using a free space
      100      100                chain, so that the space occupied by blocks that are released
      101      101                can be reused.  Other temporary structures, such as reducing
      102      102                alternative list flag blocks, are also kept in this part of
      103      103                the work area.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:28   
      104      104
      105      105                The parse stack is built starting at the end of the work area.
      106      106                It grows down as output block pointers are added to the stack,
      107      107                and back up as they are popped off the stack.
      108      108
      109      109                Pointers that delimit the parts of the work area are kept in
      110      110                the G$D block.  The work area layout is shown schematically
      111      111                as follows:
      112      112
      113      113                +--------------------+ <-- G$D.FREEANCHOR$ = PCB.WORK$
      114      114                | free chain header  |
      115      115                |--------------------|
      116      116                |                    |
      117      117                |       used         |
      118      118                |     workspace      |
      119      119                |                    |
      120      120                |--------------------| <-- G$D.LASTFREE$
      121      121                | free chain trailer |
      122      122                |--------------------| <-- G$D.HISPACE$
      123      123                |                    |
      124      124                |       unused       |
      125      125                |     workspace      |
      126      126                |                    |
      127      127                |--------------------| <-- G$D.STACKTOP$
      128      128                |                    |
      129      129                |     parse stack    |
      130      130                |                    |
      131      131                +--------------------+ <-- PCB.WORK$ + PCB.WKSZ
      132      132
      133      133
      134      134                REPARSING FOR LEGAL POSSIBILITIES
      135      135
      136      136                The parser can also be called to display a list of valid
      137      137                next nodes at a given point in a command.  This is normally
      138      138                done just after the command has failed to parse; information
      139      139                needed to do the reparse is taken from values returned in the
      140      140                PCB from the original parse.  In particular:
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:29   
      141      141
      142      142                PCB.HI_CHAR -- denotes the position in the command at which
      143      143                    legal possibilities are to be reported.
      144      144                PCB.WK_USED -- gives the offset into the work area where the
      145      145                    list of possible next nodes is to be built.  This field
      146      146                    is set to the high-water mark of G$D.HISPACE$ from the
      147      147                    original parse; since the reparse should duplicate (or be
      148      148                    a subset of) the original one, work space above this point
      149      149                    will not be used by the reparse.  The possibility list is
      150      150                    thus built in the unused workspace between the output area
      151      151                    and parse stack from the orginal parse.
      152      152
      153      153                When reparsing, XUP$PARS acts just as it did for the original
      154      154                parse up to the point of PCB.HI_CHAR, but any attempt to parse
      155      155                a node for a lexeme at that point is forced to fail, and the
      156      156                address of that node is added to the possibility list.  Thus
      157      157                a list of all possible nodes at that point is accumulated, and
      158      158                the parse always fails.  The syntax error logic in X$PARSE
      159      159                then calls XUP$DMPNXT to write out the list of accumulated
      160      160                possible nodes.
      161      161
      162      162            REFERENCE:
      163      163                User documentation for the parser, and descriptions of all
      164      164                externally visible data structures, can be found in the XUP
      165      165                section of Host Library Services Reference (CE71).
      166      166
      167      167                Parse nodes and PARTRGE are described in Appendix A of CE71.
      168      168        */
      169      169        /*F*
      170      170            NAME: XUP$PARS
      171      171            PURPOSE:
      172      172                To attempt to parse a node.
      173      173            DESCRIPTION:
      174      174                A command is parsed by recursive calls to this routine.  On
      175      175                each invocation, it attempts to match the command source text
      176      176                to the pattern specified by a given node.  If successful, it
      177      177                builds the output block (if any) for the node, and puts the
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:30   
      178      178                address of that block on the top of the parse stack.  If the
      179      179                attempted parse fails, it releases any output blocks that had
      180      180                been created during the attempted parse, and altreturns to
      181      181                indicate failure.
      182      182
      183      183                This routine is first called from X$PARSE to parse the root
      184      184                node for the command.  An altreturn from that call indicates
      185      185                a syntax error; no path through the nodes matches the command.
      186      186
      187      187                The root node typically defines a number of subnodes; XUP$PARS
      188      188                is called recursively to try to parse each subnode.  If those
      189      189                nodes also have subnodes, XUP$PARS is called again, and so on,
      190      190                for as many levels as there are subnodes.  An altreturn from
      191      191                an inner level call may or may not indicate a syntax error;
      192      192                if the node is optional, or one of a list of alternatives,
      193      193                the attempted parse of the calling node can continue with the
      194      194                next node or alternative.
      195      195
      196      196                Each invocation of XUP$PARS normally builds a single output
      197      197                block.  But, if the node for that call has subnodes, any
      198      198                number of output blocks can be built by lower level recursive
      199      199                calls.  If the parse at a given level succeeds, the output
      200      200                block for that level will contain pointers to the blocks for
      201      201                the next lower level.  The parse stack keeps track of blocks
      202      202                built at various levels.  When any block is created, a pointer
      203      203                to it is put on the top of the stack.  At each level, the
      204      204                current top-of-stack position is saved on entry; on exit, any
      205      205                stack entries above that point are either used in the block
      206      206                built for that call (on successful parse) or the blocks they
      207      207                point to are released (on failure).  On successful return from
      208      208                the top level call, the stack will contain the output block(s)
      209      209                for the root node.
      210      210
      211      211                (Note: Users of X$PARSE commonly call the tree it builds the
      212      212                "parse nodes" for a command.  Here, "nodes" refers to the blocks
      213      213                PARTRGE builds to define the command syntax; blocks built by
      214      214                X$PARSE are called "output blocks".)
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:31   
      215      215        */
      216      216        /*F*
      217      217            NAME: XUP$COMCHK
      218      218            PURPOSE:
      219      219                To check for leading blanks and comments.
      220      220            DESCRIPTION:
      221      221                This entry point into XUP$PARS is used by X$PARSE to take
      222      222                advantage of common subroutines for scanning past blanks and
      223      223                comments.
      224      224        */
      225      225        /*F*
      226      226            NAME: XUP$EXPAND_WORKAREA
      227      227            PURPOSE:
      228      228                To attempt to expand the work area.
      229      229            DESCRIPTION:
      230      230                This entry point into XUP$PARS is used by XUP$GETSPACE to take
      231      231                advantage of common logic for attempting to expand the parse
      232      232                work area.
      233      233        */
      234      234        /*F*
      235      235            NAME: XUP$GETSPACE
      236      236            PURPOSE:
      237      237                To allocate a block in the parse work area.
      238      238            DESCRIPTION:
      239      239                This routine is called to allocate space in the parse work
      240      240                area.  It first checks the free space chain to see if a block
      241      241                of the required size is available.  If so, the requested block
      242      242                is allocated out of the free space, otherwise it increased the
      243      243                amount of used work space and allocates the new block at the
      244      244                end.  If expanding the used space would collide with the parse
      245      245                stack, the routine tries to expand the work area by calling
      246      246                XUP$EXPAND_WORKAREA.
      247      247        */
      248      248        /*F*
      249      249            NAME: XUP$FREESPACE
      250      250            PURPOSE:
      251      251                To free a block in the parse work area.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:32   
      252      252            DESCRIPTION:
      253      253                This routine is called to release blocks in the parse work
      254      254                area, and add them to the free space chain.  If the block
      255      255                just freed is adjacent to a block already on the free chain,
      256      256                the blocks are combined to avoid unnecessary fragmentation.
      257      257        */
      258      258        /*F*
      259      259            NAME: XUP$FREEOUT
      260      260            PURPOSE:
      261      261                To free all blocks associated with a given parse output block.
      262      262            DESCRIPTION:
      263      263                This routine calls itself recursively to free any sub-blocks
      264      264                of the output block it is given, the calls XUP$FREESPACE to
      265      265                free the block itself.
      266      266        */
      267      267        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:33   
      268      268        XUP$PARSE:
      269      269            PROC(PCB)  ALTRET;

    269  1 000000   000000 700200 xent  XUP$PARSE    TSX0  ! X66_AUTO_1
         1 000001   000230 000001                    ZERO    152,1
         1 000002   000005 710000 1                  TRA     s:4173

      270      270
      271      271        %INCLUDE      XU_MACRO_C;
      272     3377        %INCLUDE      XU_SUBS_C;
      273     3469        %INCLUDE      XU_PERR_C;
      274     3660        /*
      275     3661            ***       INPUT PARAMETER
      276     3662        */
      277     3663            %P$PCB(NAME=PCB,STCLASS=" ");
      278     3864
      279     3865        /*
      280     3866            ***       EXTERNAL ENTRY DEFINITION
      281     3867        */
      282     3868    1   DCL XUP$COMCHK ENTRY(1) ALTRET;
      283     3869    1   DCL XUP$DMPNXT ENTRY(1);
      284     3870    1   DCL XUP$PARS ENTRY(1) ALTRET;
      285     3871    1   DCL       XUP$GETSPACE   ENTRY(3);
      286     3872        /*
      287     3873            ***       LOCAL DATA
      288     3874        */
      289     3875    1   DCL     C$BUF    CHAR(PCB.NCHARS) BASED;
      290     3876    1   DCL       C$BUFA(0:0)    CHAR(1)     BASED;
      291     3877    1   DCL       BLK$     PTR   BASED;
      292     3878    1   DCL  WORDS(0:0)BASED ALIGNED UBIN;
      293     3879        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:34   
      294     3880        %LIST;
      295     3881        /*
      296     3882            ***       DEFINE ALL DATA WHICH IS TO BE GLOBAL TO X$PARSE ROUTINES
      297     3883            ***       IN THE DRIVER (X$PARSE) ROUTINE; THIS DATA STRUCTURE WILL
      298     3884            ***       THEN BE PASSED AS A PARAMETER TO ALL ROUTINES USING THE DATA.
      299     3885        */
      300     3886            %G$D(STCLASS=AUTO);
              3887        /*F*  NAME:     G$D
              3888              FUNCTION: a data structure owned and managed by X$PARSE, used to
              3889                  retain and pass useful information throughout the lifetime
              3890                  of a parsing operation.  Tampering with this structure's
              3891                  contents by a user-supplied routine will void the warranty,
              3892                  and may expose the programmer to high-voltage screams of
              3893                  anguish from the software-support staff.
              3894        */
              3895    1   DCL 1 NAME ALIGNED STCLASS,
              3896    1         2 PCB$ PTR,
              3897        /*K* PCB$ - pointer to Parse Control Block.
              3898        */
              3899    1         2 ERROR REMEMBER,
              3900        /*K* ERROR - error return point.  Any error other than a syntax error
              3901                    that is detected during parsing unwinds to G$D.ERROR
              3902                    after setting the error code and other error return
              3903                    information in the PCB; this results in an altreturn
              3904                    from X$PARSE.
              3905        */
              3906    1         2 NODE$ PTR,
              3907        /*K* NODE$ - pointer to node to attempt to parse.  This is reset for
              3908                    each call to XUP$PARS to pass it the node it is to try to
              3909                    parse.  Within XUP$PARS, a local copy of this pointer is
              3910                    used to access the node, since this field will be reset by
              3911                    subsequent recursive calls to attempt to parse subnodes.
              3912        */
              3913    1         2 FREEANCHOR$ PTR,
              3914        /*K* FREEANCHOR$ - pointer to the first block in the free space chain
              3915                    for the parse work area.
              3916        */
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:35   
              3917    1         2 LASTFREE$ PTR,
              3918        /*K* LASTFREE$ - pointer to the last block in the free space chain
              3919                    for the parse work area.
              3920        */
              3921    1         2 HISPACE$ PTR,
              3922        /*K* HISPACE$ - pointer to the next available word in the parse work area.
              3923        */
              3924    1         2 STACKTOP$ PTR,
              3925        /*K* STACKTOP$ - pointer to the top element in the parse stack at the
              3926                    end of the parse work area.
              3927        */
              3928    1         2 REDUCE$ PTR,
              3929        /*K* REDUCE$ - root address for the current reducing alternative flag
              3930                    block list; NIL if the list is empty.
              3931        */
              3932    1         2 SCRATCH SBIN WORD,
              3933        /*K* SCRATCH - scratch word for use by X$PARSE (redefinition of CNTUPOS).
              3934        */
              3935    1         2 CNTUPOS REDEF SCRATCH SBIN WORD,
              3936        /*K* CNTUPOS - offset of the start of the command text from the current
              3937                command text pointer (PCB.TEXT$).  If continuation lines are
              3938                appended to command text for previous lines, this will always
              3939                be zero.  If continuation lines overlay the previous lines,
              3940                this will be a negative number equal to the number of characters
              3941                in prior lines that have been lost in overlaid lines.
              3942        */
              3943    1         2 CCPOS SBIN WORD,
              3944        /*K* CCPOS - the current position in the command text.
              3945        */
              3946    1         2 CLEXPOS SBIN WORD,
              3947        /*K* CLEXPOS - the current lexical position in the command text; used
              3948                to determine if part of the text to be returned by an RTEXT
              3949                node has been overlaid by a continuation line.
              3950        */
              3951    1         2 CCHAR CHAR(1) CALIGNED,
              3952        /*K* CCHAR - the character at the current position in the command text.
              3953        */
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:36   
              3954    1         2 BLSKIP BIT(1) UNAL,
              3955        /*K* BLKSIP - blank skip flag; set if some whitespace has been skipped
              3956                at the end of the last lexeme parsed.
              3957        */
              3958    1         2 *       BIT(26) UNAL,
              3959    1         2 LDCMNT,
              3960        /*K* LDCMNT - the length (.CT) and text (.TX) of the leading comment delimiter.
              3961                    This is derived from PCB.COMMENT.LEAD when X$PARSE is first
              3962                    entered.
              3963        */
              3964    1           3 CT UBIN HALF HALIGNED,
              3965    1           3 TX CHAR(2) CALIGNED,
              3966    1           3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
              3967    1         2 TRCMNT,
              3968        /*K* TRCMNT - the length (.CT) and text (.TX) of the trailing comment delimiter.
              3969                    This is derived from PCB.COMMENT.LEAD when X$PARSE is first
              3970                    entered.
              3971        */
              3972    1           3 CT UBIN HALF HALIGNED,
              3973    1           3 TX CHAR(2) CALIGNED,
              3974    1           3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
              3975    1         2 TBUF CHAR(511);
              3976        /*K* TBUF - temporary buffer for various uses within XUP$PARS.
              3977                    (Defining it here rather than in local auto saves 128 words
              3978                    per invocation, which can become quite significant for such
              3979                    a highly recursive routine.)
              3980        */
      301     3982        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:37   
      302     3983        /*
      303     3984            ***       GENERATE THE BASED STRUCTURE USED TO BUILD AND UTILIZE
      304     3985            ***       THE SPACE-CHAIN IN THE USER-SUPPLIED WORK BUFFER.
      305     3986        */
      306     3987             %XUP$CHAIN;
              3988    1   DCL 1 FREE$HDR BASED ALIGNED,           /* FREE CHAIN BLOCK HEADER            */
              3989    1         2 NWORDS SBIN UNAL,               /* COUNT OF WORDS IN BLOCK            */
              3990    1         2 NEXT$ PTR UNAL,                 /* FORWARD LINK TO NEXT FREE BLOCK    */
              3991    1         2 PREV$ PTR;                 /* BACKWARD LINK TP PREVIOUS FREE BLOCK    */
      307     3993        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:38   
      308     3994        /*
      309     3995            ***       GENERATE THE BASED STRUCTURE USED TO DEFINE POSSIBLE
      310     3996            ***       ALTERNATIVE NODES AT THE POINT OF ERROR IN A COMMAND.
      311     3997        */
      312     3998            %XUP$POSS (NAME=POSS);
              3999    1   DCL 1 NAME STCLASS ALIGNED,     /* LEGAL POSSIBILITY LIST STRUCTURE */
              4000    1         2 COUNT SBIN,             /* NUMBER OF NODES IN LIST          */
              4001    1         2 NODES$ (0:0) PTR;       /* POSSIBLE NEXT NODE ARRAY         */
      313     4003        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:39   
      314     4004        %PLIST;
      315     4005        /*
      316     4006            ***       GENERATE THE BASED STRUCTURE USED TO GENERATE THE OUTPUT
      317     4007            ***       BLOCKS RETURNED TO THE USER IN HIS WORK BUFFER.
      318     4008        */
      319     4009            %PARSE$OUT(STCLASS=BASED);
      320     4054        /*
      321     4055            ***       MACRO TO GENERATE XUP ERROR CODES
      322     4056        */
      323     4057        %MACRO ERRCODE(NAME=' ',STCLASS="CONSTANT SYMDEF",CODE=0,SEV=0);
      324     4058        DCL 1 NAME ALIGNED STCLASS,
      325     4059              2 * BIT(12) UNAL INIT('3025'O), /*'XU'*/
      326     4060              2 * BIT(6) UNAL INIT('20'O),  /*'P'*/
      327     4061              2 * BIT(1) UNAL INIT('0'B),
      328     4062              2 * UBIN(14) UNAL INIT(CODE),
      329     4063              2 * UBIN(3) UNAL INIT(0);
      330     4064        %MEND;
      331     4065        /*
      332     4066            ***       GENERATE ERROR CODES RETURNED BY X$PARSE
      333     4067        */
      334     4068            %ERRCODE(NAME=SYN_ERR,CODE=%E$SYNERR);
      335     4076            %ERRCODE(NAME=NULL_ROOT,CODE=%E$NULLROOT);
      336     4084            %ERRCODE(NAME=BAD_NODE,CODE=%E$BADNODE);
      337     4092            %ERRCODE(NAME=OVER_FLOW,CODE=%E$WKOVERFLOW);
      338     4100            %ERRCODE(NAME=SMALL_WORK,CODE=%E$SMALLWORK);
      339     4108            %ERRCODE(NAME=NULL_U$$,CODE=%E$NULLU$$);
      340     4116            %ERRCODE(NAME=PRE_C00,CODE=%E$PCB_PRE_C00);
      341     4124            %ERRCODE(NAME=CANT_RTEXT,CODE=%E$CANT_RTEXT);
      342     4132            %ERRCODE(NAME=RTEXT_GT_511,CODE=%E$RTEXT_GT_511);
      343     4140            %ERRCODE(NAME=ILLEGAL_DYNAMIC_EXPANSION,CODE=%E$EXPAND_ERROR);
      344     4148        %EJECT;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:40   
      345     4149        /*D*          NAME:    X$PARSE
      346     4150        *
      347     4151                      CALL:    CALL X$PARSE(PCB) ALTRET(PARSE_ERR);
      348     4152        *
      349     4153                      INTERFACE:  XUP$PARS
      350     4154                                  XUP$COMCHK, XUP$GETSPACE
      351     4155                                  XUP$DMPNXT
      352     4156        *
      353     4157                      ENVIRONMENT:   Mapped, slave, caller's ISR.
      354     4158        *
      355     4159                      INPUT:   Parse Control Block(PCB), a user-generated table
      356     4160                               containing the information necessary to perform the
      357     4161                               parse.
      358     4162                      OUTPUT:  A pointer is established in the caller's PCB which
      359     4163                               defines the beginning of the output generated as a
      360     4164                               result of a successful parse; the content of the output
      361     4165                               is dependent on information (the syntax graph) which
      362     4166                               was contained in the PCB.
      363     4167        */
      364     4168    1   X$PARSE:
      365     4169    1       ENTRY(PCB) ALTRET;

   4169  1 000003   000000 700200 xent  X$PARSE      TSX0  ! X66_AUTO_1
         1 000004   000230 000001                    ZERO    152,1

      366     4170        /*
      367     4171            ***       BEGIN PROCEDURE          ***
      368     4172        */
      369     4173    1       G$D='0'B;

   4173  1 000005   000100 100400                    MLR     fill='000'O
         1 000006   000002 000001 xsym               ADSC9   B_VECTNIL+2              cn=0,n=1
         1 000007   200004 001077                    ADSC9   G$D,,AUTO                cn=0,n=575

      370     4174    1       G$D.PCB$ = ADDR(PCB);

   4174  1 000010   200003 236100                    LDQ     @PCB,,AUTO
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:41   
         1 000011   200004 756100                    STQ     G$D,,AUTO

      371     4175        /*
      372     4176            ***       ESTABLISH THE ERROR HANDLER
      373     4177        */
      374     4178    1       REMEMBER ERROR IN G$D.ERROR;

   4178  1 000012   000361 635000 1                  EAA     ERROR
         1 000013   200006 452500                    STP2    G$D+2,,AUTO
         1 000014   200007 755100                    STA     G$D+3,,AUTO

      375     4179        /*
      376     4180                Check for obvious errors in parameters.
      377     4181        */
      378     4182    1       IF PCB.VERSION_CODE = 0

   4182  1 000015   200003 470500                    LDP0    @PCB,,AUTO
         1 000016   000010 236100                    LDQ     8,,PR0
         1 000017   740000 316007                    CANQ    -16384,DL
         1 000020   000024 601000 1                  TNZ     s:4211

      379     4183    2       THEN DO;

      380     4184
      381     4185        /*E*     ERROR:   XUP-E$PCB_PRE_C00
      382     4186                 MESSAGE: Parse control block is pre-C00;  cannot parse.
      383     4187                 MESSAGE1: The parse control block (PCB) passed to X$PARSE appears
      384     4188                          to be of pre-C00 vintage.  The format of X$PARSE nodes
      385     4189                          (produced by PARTRGE) was changed substantially for the
      386     4190                          C00 version of CP-6, and pre-C00 nodes/PCBs/PARSE$BLKs
      387     4191                          (etc.) are not compatible with this parser.  Your program
      388     4192                          must be updated if you wish to run it on a D00 (or later)
      389     4193                          version of CP-6.  This will require:
      390     4194
      391     4195                          1) Recompiling all PL-6 routines that use any of the parser's
      392     4196                             data structures;
      393     4197
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:42   
      394     4198                          2) Re-PARTRGEing all of the program's parse nodes;  and
      395     4199
      396     4200                          3) Re-LINKing the run unit.
      397     4201
      398     4202                          Please see the "CP-6 C00 System Release Bulletin", or the
      399     4203                          Host Library Services manual (CE71) for the necessary
      400     4204                          information and procedures.
      401     4205        */
      402     4206    2           PCB.ERROR = PRE_C00;

   4206  1 000021   000006 236000 0                  LDQ     PRE_C00
         1 000022   000006 756100                    STQ     6,,PR0

      403     4207    2           ALTRETURN;

   4207  1 000023   000000 702200 xent               TSX2  ! X66_AALT

      404     4208
      405     4209    2       END;
      406     4210
      407     4211    1       IF PCB.WKSZ < (PCB.NCHARS + 4)/4 + 10 THEN

   4211  1 000024   000011 236100                    LDQ     9,,PR0
         1 000025   000004 036007                    ADLQ    4,DL
         1 000026   000002 772000                    QRL     2
         1 000027   000012 036007                    ADLQ    10,DL
         1 000030   200224 756100                    STQ     G$D+144,,AUTO
         1 000031   000005 236100                    LDQ     5,,PR0
         1 000032   000022 772000                    QRL     18
         1 000033   200224 116100                    CMPQ    G$D+144,,AUTO
         1 000034   000040 603000 1                  TRC     s:4225

      408     4212    2       DO;

      409     4213
      410     4214        /*E*          ERROR:   XUP-E$SMALLWORK-C
      411     4215                      MESSAGE:    Work area too small for X$PARSE
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:43   
      412     4216                      MESSAGE1:   Minimum size of work area required for X$PARSE
      413     4217                               must at least equal the size of the string to be
      414     4218                               parsed plus 10 words.
      415     4219        */
      416     4220
      417     4221    2           PCB.ERROR = SMALL_WORK;

   4221  1 000035   000004 236000 0                  LDQ     SMALL_WORK
         1 000036   000006 756100                    STQ     6,,PR0

      418     4222    2           ALTRETURN;

   4222  1 000037   000000 702200 xent               TSX2  ! X66_AALT

      419     4223    2       END;
      420     4224
      421     4225    1       IF PCB.ROOT$ = ADDR(NIL) THEN

   4225  1 000040   000001 236100                    LDQ     1,,PR0
         1 000041   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000042   000046 601000 1                  TNZ     s:4242

      422     4226    2       DO;

      423     4227
      424     4228        /*E*          ERROR:   XUP-E$NULLROOT-C
      425     4229                      MESSAGE:    Null syntax tree passed to X$PARSE
      426     4230                      MESSAGE1:   Pointer to the syntax tree, which was passed in
      427     4231                               the Parse Control Block, is null.
      428     4232        */
      429     4233
      430     4234    2           PCB.ERROR = NULL_ROOT;

   4234  1 000043   000001 236000 0                  LDQ     NULL_ROOT
         1 000044   000006 756100                    STQ     6,,PR0

      431     4235    2           ALTRETURN;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:44   

   4235  1 000045   000000 702200 xent               TSX2  ! X66_AALT

      432     4236    2       END;
      433     4237        /*
      434     4238           *****   Initialize the free-space chain in the WORK area beginning
      435     4239           *****   at its beginning.  Establish the stack at the
      436     4240           *****   end of the WORK area (grows down from the end).
      437     4241        */
      438     4242    1       G$D.FREEANCHOR$ = PCB.WORK$;

   4242  1 000046   000002 236100                    LDQ     2,,PR0
         1 000047   200011 756100                    STQ     G$D+5,,AUTO

      439     4243    1       G$D.FREEANCHOR$->FREE$HDR.PREV$ = ADDR(NIL);

   4243  1 000050   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000051   200011 471500                    LDP1    G$D+5,,AUTO
         1 000052   100002 756100                    STQ     2,,PR1

      440     4244    1       G$D.FREEANCHOR$->FREE$HDR.NWORDS = 3;

   4244  1 000053   000003 235007                    LDA     3,DL
         1 000054   200011 471500                    LDP1    G$D+5,,AUTO
         1 000055   100000 755100                    STA     0,,PR1

      441     4245    1       G$D.LASTFREE$ = PINCRW(G$D.FREEANCHOR$,3);

   4245  1 000056   200011 236100                    LDQ     G$D+5,,AUTO
         1 000057   000003 036003                    ADLQ    3,DU
         1 000060   200012 756100                    STQ     G$D+6,,AUTO

      442     4246    1       G$D.FREEANCHOR$->FREE$HDR.NEXT$ = G$D.LASTFREE$;

   4246  1 000061   200011 471500                    LDP1    G$D+5,,AUTO
         1 000062   100001 756100                    STQ     1,,PR1

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:45   
      443     4247    1       G$D.LASTFREE$->FREE$HDR.NWORDS = 3;

   4247  1 000063   200012 471500                    LDP1    G$D+6,,AUTO
         1 000064   100000 755100                    STA     0,,PR1

      444     4248    1       G$D.LASTFREE$->FREE$HDR.PREV$ = G$D.FREEANCHOR$;

   4248  1 000065   200011 236100                    LDQ     G$D+5,,AUTO
         1 000066   200012 471500                    LDP1    G$D+6,,AUTO
         1 000067   100002 756100                    STQ     2,,PR1

      445     4249    1       G$D.LASTFREE$->FREE$HDR.NEXT$ = ADDR(NIL);

   4249  1 000070   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000071   200012 471500                    LDP1    G$D+6,,AUTO
         1 000072   100001 756100                    STQ     1,,PR1

      446     4250    1       G$D.HISPACE$ = PINCRW(G$D.LASTFREE$,2);

   4250  1 000073   200012 236100                    LDQ     G$D+6,,AUTO
         1 000074   000002 036003                    ADLQ    2,DU
         1 000075   200013 756100                    STQ     G$D+7,,AUTO

      447     4251    1       G$D.STACKTOP$ = PINCRW(PCB.WORK$,PCB.WKSZ);

   4251  1 000076   000005 220100                    LDX0    5,,PR0
         1 000077   000002 471500                    LDP1    2,,PR0
         1 000100   100000 633510                    EPPR3   0,X0,PR1
         1 000101   200014 453500                    STP3    G$D+8,,AUTO

      448     4252    1       G$D.REDUCE$ = ADDR(NIL);

   4252  1 000102   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000103   200015 756100                    STQ     G$D+9,,AUTO

      449     4253        /*
      450     4254            *****   Set up comment delimiters in a form more convenient for
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:46   
      451     4255            *****   internal use.
      452     4256        */
      453     4257    1       IF SUBSTR(PCB.COMMENT.LEAD,0,1) = ' ' THEN

   4257  1 000104   000007 236100                    LDQ     7,,PR0
         1 000105   777000 376003                    ANQ     -512,DU
         1 000106   040000 116003                    CMPQ    16384,DU
         1 000107   000131 601000 1                  TNZ     s:4272

      454     4258    2       DO;

      455     4259    2           IF SUBSTR(PCB.COMMENT.LEAD,1,1) = ' ' THEN

   4259  1 000110   000007 236100                    LDQ     7,,PR0
         1 000111   000777 376003                    ANQ     511,DU
         1 000112   000040 116003                    CMPQ    32,DU
         1 000113   000121 601000 1                  TNZ     s:4266

      456     4260    3           DO;

      457     4261    3               G$D.LDCMNT.CT = 0;

   4261  1 000114   000000 220003                    LDX0    0,DU
         1 000115   200022 740100                    STX0    G$D+14,,AUTO

      458     4262    3               G$D.LDCMNT.TX = BINASC(0);

   4262  1 000116   000040 221003                    LDX1    32,DU
         1 000117   200022 441100                    SXL1    G$D+14,,AUTO

      459     4263    3           END;

   4263  1 000120   000135 710000 1                  TRA     s:4275

      460     4264    2           ELSE
      461     4265    3           DO;

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:47   
      462     4266    3               G$D.LDCMNT.CT = 1;

   4266  1 000121   000001 220003                    LDX0    1,DU
         1 000122   200022 740100                    STX0    G$D+14,,AUTO

      463     4267    3               G$D.LDCMNT.TX = SUBSTR(PCB.COMMENT.LEAD,1,1);

   4267  1 000123   040100 100500                    MLR     fill='040'O
         1 000124   000007 200001                    ADSC9   7,,PR0                   cn=1,n=1
         1 000125   200224 000004                    ADSC9   G$D+144,,AUTO            cn=0,n=4
         1 000126   200224 221100                    LDX1    G$D+144,,AUTO
         1 000127   200022 441100                    SXL1    G$D+14,,AUTO

      464     4268    3           END;

      465     4269    2       END;

   4269  1 000130   000135 710000 1                  TRA     s:4275

      466     4270    1       ELSE
      467     4271    2       DO;

      468     4272    2           G$D.LDCMNT.CT = 2;

   4272  1 000131   000002 220003                    LDX0    2,DU
         1 000132   200022 740100                    STX0    G$D+14,,AUTO

      469     4273    2           G$D.LDCMNT.TX = PCB.COMMENT.LEAD;

   4273  1 000133   000007 221100                    LDX1    7,,PR0
         1 000134   200022 441100                    SXL1    G$D+14,,AUTO

      470     4274    2       END;

      471     4275    1       IF SUBSTR(PCB.COMMENT.TRAIL,0,1) = ' ' THEN

   4275  1 000135   000007 236100                    LDQ     7,,PR0
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:48   
         1 000136   777000 376007                    ANQ     -512,DL
         1 000137   040000 116007                    CMPQ    16384,DL
         1 000140   000160 601000 1                  TNZ     s:4287

      472     4276    2       DO;

      473     4277    2           IF SUBSTR(PCB.COMMENT.TRAIL,1,1) = ' ' THEN

   4277  1 000141   000007 236100                    LDQ     7,,PR0
         1 000142   000777 376007                    ANQ     511,DL
         1 000143   000040 116007                    CMPQ    32,DL
         1 000144   000150 601000 1                  TNZ     s:4281

      474     4278    2               G$D.TRCMNT.CT = 0;

   4278  1 000145   000000 222003                    LDX2    0,DU
         1 000146   200023 742100                    STX2    G$D+15,,AUTO
         1 000147   000164 710000 1                  TRA     s:4294

      475     4279    2           ELSE
      476     4280    3           DO;

      477     4281    3               G$D.TRCMNT.CT = 1;

   4281  1 000150   000001 222003                    LDX2    1,DU
         1 000151   200023 742100                    STX2    G$D+15,,AUTO

      478     4282    3               G$D.TRCMNT.TX = SUBSTR(PCB.COMMENT.TRAIL,1,1);

   4282  1 000152   040100 100500                    MLR     fill='040'O
         1 000153   000007 600001                    ADSC9   7,,PR0                   cn=3,n=1
         1 000154   200224 000004                    ADSC9   G$D+144,,AUTO            cn=0,n=4
         1 000155   200224 223100                    LDX3    G$D+144,,AUTO
         1 000156   200023 443100                    SXL3    G$D+15,,AUTO

      479     4283    3           END;

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:49   
      480     4284    2       END;

   4284  1 000157   000164 710000 1                  TRA     s:4294

      481     4285    1       ELSE
      482     4286    2       DO;

      483     4287    2           G$D.TRCMNT.CT = 2;

   4287  1 000160   000002 222003                    LDX2    2,DU
         1 000161   200023 742100                    STX2    G$D+15,,AUTO

      484     4288    2           G$D.TRCMNT.TX = PCB.COMMENT.TRAIL;

   4288  1 000162   000007 723100                    LXL3    7,,PR0
         1 000163   200023 443100                    SXL3    G$D+15,,AUTO

      485     4289    2       END;

      486     4290        /*
      487     4291        *****   Check for leading comment or comment only and adjust character
      488     4292        *****   position accordingly.
      489     4293        */
      490     4294    1       IF PCB.NOLEADBLANKS

   4294  1 000164   000005 236100                    LDQ     5,,PR0
         1 000165   100000 316007                    CANQ    32768,DL
         1 000166   000176 600000 1                  TZE     s:4302

      491     4295    1       THEN
      492     4296    1           IF PCB.NCHARS ~= 0

   4296  1 000167   000011 235100                    LDA     9,,PR0
         1 000170   000204 600000 1                  TZE     s:4306

      493     4297    1           THEN
      494     4298    1               G$D.CCHAR = PCB.TEXT$ -> C$BUFA(0);
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:50   

   4298  1 000171   000000 471500                    LDP1    0,,PR0
         1 000172   040100 100500                    MLR     fill='040'O
         1 000173   100000 000001                    ADSC9   0,,PR1                   cn=0,n=1
         1 000174   200021 000001                    ADSC9   G$D+13,,AUTO             cn=0,n=1
         1 000175   000204 710000 1                  TRA     s:4306

      495     4299    1           ELSE
      496     4300    1               ;
      497     4301    1       ELSE
      498     4302    1           CALL XUP$COMCHK(G$D);

   4302  1 000176   200004 631500                    EPPR1   G$D,,AUTO
         1 000177   200224 451500                    STP1    G$D+144,,AUTO
         1 000200   200224 630500                    EPPR0   G$D+144,,AUTO
         1 000201   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000202   000000 701000 xent               TSX1    XUP$COMCHK
         1 000203   000000 011000                    NOP     0

      499     4303        /*
      500     4304        ***           ATTEMPT THE PARSE
      501     4305        */
      502     4306    1       IF PCB.NXT

   4306  1 000204   200003 470500                    LDP0    @PCB,,AUTO
         1 000205   000005 236100                    LDQ     5,,PR0
         1 000206   040000 316007                    CANQ    16384,DL
         1 000207   000215 600000 1                  TZE     s:4310

      503     4307    1       THEN
      504     4308    1           PINCRW(PCB.WORK$,PCB.WK_USED) -> POSS = '0'B;

   4308  1 000210   000010 220100                    LDX0    8,,PR0
         1 000211   000002 471500                    LDP1    2,,PR0
         1 000212   100000 450110                    STZ     0,X0,PR1
         1 000213   100001 450110                    STZ     1,X0,PR1
         1 000214   000224 710000 1                  TRA     s:4315
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:51   

      505     4309    2       ELSE DO;

      506     4310    2           PCB.HI_CHAR=G$D.CCPOS;

   4310  1 000215   200017 235100                    LDA     G$D+11,,AUTO
         1 000216   000012 755100                    STA     10,,PR0

      507     4311    2           PCB.HINODE$ = ADDR(NIL);

   4311  1 000217   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000220   000013 756100                    STQ     11,,PR0

      508     4312    2           PCB.WK_USED = 0;

   4312  1 000221   000000 220003                    LDX0    0,DU
         1 000222   000010 740100                    STX0    8,,PR0

      509     4313    2           PCB.ERROR = '0'B; /*CLEAR THE ERROR CODE */

   4313  1 000223   000006 450100                    STZ     6,,PR0

      510     4314    2       END;

      511     4315    1       G$D.NODE$=PCB.ROOT$;

   4315  1 000224   000001 236100                    LDQ     1,,PR0
         1 000225   200010 756100                    STQ     G$D+4,,AUTO

      512     4316    1       CALL XUP$PARS(G$D) ALTRET(SYNERR);

   4316  1 000226   200004 631500                    EPPR1   G$D,,AUTO
         1 000227   200224 451500                    STP1    G$D+144,,AUTO
         1 000230   200224 630500                    EPPR0   G$D+144,,AUTO
         1 000231   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000232   000000 701000 xent               TSX1    XUP$PARS
         1 000233   000332 702000 1                  TSX2    SYNERR
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:52   

      513     4317        /*
      514     4318            *****   Clear out the node stack:
      515     4319                    If there is only one unassigned output node, it becomes
      516     4320                    the top level node.
      517     4321                    Otherwise, create a dummy output block to be the top level
      518     4322                    output node, containing all remaining unassigned nodes.
      519     4323        */
      520     4324    1       G$D.SCRATCH = PCB.WKSZ - POFFW(G$D.STACKTOP$, PCB.WORK$);

   4324  1 000234   200003 470500                    LDP0    @PCB,,AUTO
         1 000235   000002 236100                    LDQ     2,,PR0
         1 000236   000022 772000                    QRL     18
         1 000237   200224 756100                    STQ     G$D+144,,AUTO
         1 000240   200014 236100                    LDQ     G$D+8,,AUTO
         1 000241   000022 772000                    QRL     18
         1 000242   200224 136100                    SBLQ    G$D+144,,AUTO
         1 000243   200225 756100                    STQ     G$D+145,,AUTO
         1 000244   000005 236100                    LDQ     5,,PR0
         1 000245   000022 772000                    QRL     18
         1 000246   200225 136100                    SBLQ    G$D+145,,AUTO
         1 000247   200016 756100                    STQ     G$D+10,,AUTO

      521     4325    1       IF G$D.SCRATCH = 1 THEN

   4325  1 000250   000001 116007                    CMPQ    1,DL
         1 000251   000256 601000 1                  TNZ     s:4329

      522     4326    1           PCB.OUT$ = G$D.STACKTOP$->BLK$;

   4326  1 000252   200014 471500                    LDP1    G$D+8,,AUTO
         1 000253   100000 236100                    LDQ     0,,PR1
         1 000254   000003 756100                    STQ     3,,PR0
         1 000255   000321 710000 1                  TRA     s:4339

      523     4327    1       ELSE
      524     4328    2       DO;
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:53   

      525     4329    2           CALL XUP$GETSPACE(G$D.SCRATCH + 3,PCB.OUT$,G$D);

   4329  1 000256   000003 036007                    ADLQ    3,DL
         1 000257   200224 756100                    STQ     G$D+144,,AUTO
         1 000260   200004 631500                    EPPR1   G$D,,AUTO
         1 000261   200227 451500                    STP1    G$D+147,,AUTO
         1 000262   200003 236100                    LDQ     @PCB,,AUTO
         1 000263   000003 036003                    ADLQ    3,DU
         1 000264   200226 756100                    STQ     G$D+146,,AUTO
         1 000265   200224 633500                    EPPR3   G$D+144,,AUTO
         1 000266   200225 453500                    STP3    G$D+145,,AUTO
         1 000267   200225 630500                    EPPR0   G$D+145,,AUTO
         1 000270   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 000271   000000 701000 xent               TSX1    XUP$GETSPACE
         1 000272   000000 011000                    NOP     0

      526     4330    2           PCB.OUT$->OUT$BLK.NSUBLKS = G$D.SCRATCH;

   4330  1 000273   200003 470500                    LDP0    @PCB,,AUTO
         1 000274   000003 471500                    LDP1    3,,PR0
         1 000275   200016 720100                    LXL0    G$D+10,,AUTO
         1 000276   100001 740100                    STX0    1,,PR1

      527     4331    2           PCB.OUT$->OUT$BLK.TEMP = '1'B;

   4331  1 000277   000003 471500                    LDP1    3,,PR0
         1 000300   400000 236003                    LDQ     -131072,DU
         1 000301   100000 256100                    ORSQ    0,,PR1

      528     4332    3           DO WHILE(G$D.SCRATCH > 0);

   4332  1 000302   200016 235100                    LDA     G$D+10,,AUTO
         1 000303   000321 604400 1                  TMOZ    s:4339

      529     4333    3               G$D.SCRATCH = G$D.SCRATCH - 1;

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:54   
   4333  1 000304   000001 336007                    LCQ     1,DL
         1 000305   200016 056100                    ASQ     G$D+10,,AUTO

      530     4334    3               PCB.OUT$->OUT$BLK.SUBLK$(G$D.SCRATCH) =

   4334  1 000306   200003 470500                    LDP0    @PCB,,AUTO
         1 000307   000003 471500                    LDP1    3,,PR0
         1 000310   200014 473500                    LDP3    G$D+8,,AUTO
         1 000311   300000 236100                    LDQ     0,,PR3
         1 000312   200016 720100                    LXL0    G$D+10,,AUTO
         1 000313   100003 756110                    STQ     3,X0,PR1

      531     4335    3                 G$D.STACKTOP$->BLK$;
      532     4336    3               G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);

   4336  1 000314   200014 236100                    LDQ     G$D+8,,AUTO
         1 000315   000001 036003                    ADLQ    1,DU
         1 000316   200014 756100                    STQ     G$D+8,,AUTO

      533     4337    3           END;

   4337  1 000317   200016 235100                    LDA     G$D+10,,AUTO
         1 000320   000304 605400 1                  TPNZ    s:4333

      534     4338    2       END;

      535     4339    1       PCB.WK_USED = POFFW(G$D.HISPACE$,PCB.WORK$) + 3;

   4339  1 000321   000002 236100                    LDQ     2,,PR0
         1 000322   000022 772000                    QRL     18
         1 000323   200224 756100                    STQ     G$D+144,,AUTO
         1 000324   200013 236100                    LDQ     G$D+7,,AUTO
         1 000325   000022 772000                    QRL     18
         1 000326   200224 136100                    SBLQ    G$D+144,,AUTO
         1 000327   000003 620006                    EAX0    3,QL
         1 000330   000010 740100                    STX0    8,,PR0

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:55   
      536     4340    1       RETURN;

   4340  1 000331   000000 702200 xent               TSX2  ! X66_ARET

      537     4341        /*
      538     4342            *****   SYNTAX ERROR HANDLER
      539     4343        */
      540     4344    1   SYNERR:
      541     4345
      542     4346        /*E*          ERROR:   XUP-E$SYNERR-C
      543     4347                      MESSAGE:    Syntax error
      544     4348                      MESSAGE1:   X$PARSE failed to match the input text string with
      545     4349                               any branch of the syntax tree.
      546     4350        */
      547     4351
      548     4352    1       PCB.ERROR = SYN_ERR;

   4352  1 000332   000000 236000 0     SYNERR       LDQ     SYN_ERR
         1 000333   200003 470500                    LDP0    @PCB,,AUTO
         1 000334   000006 756100                    STQ     6,,PR0

      549     4353    1       IF PCB.NXT AND NOT PCB.NXT_SZONLY

   4353  1 000335   000005 236100                    LDQ     5,,PR0
         1 000336   040000 316007                    CANQ    16384,DL
         1 000337   000350 600000 1                  TZE     s:4357
         1 000340   002000 316007                    CANQ    1024,DL
         1 000341   000350 601000 1                  TNZ     s:4357

      550     4354    1       THEN
      551     4355    1           CALL XUP$DMPNXT (G$D);

   4355  1 000342   200004 631500                    EPPR1   G$D,,AUTO
         1 000343   200224 451500                    STP1    G$D+144,,AUTO
         1 000344   200224 630500                    EPPR0   G$D+144,,AUTO
         1 000345   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000346   000000 701000 xent               TSX1    XUP$DMPNXT
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:56   
         1 000347   000000 011000                    NOP     0

      552     4356
      553     4357    1       PCB.WK_USED = POFFW(G$D.HISPACE$,PCB.WORK$) + 6;

   4357  1 000350   200003 470500                    LDP0    @PCB,,AUTO
         1 000351   000002 236100                    LDQ     2,,PR0
         1 000352   000022 772000                    QRL     18
         1 000353   200224 756100                    STQ     G$D+144,,AUTO
         1 000354   200013 236100                    LDQ     G$D+7,,AUTO
         1 000355   000022 772000                    QRL     18
         1 000356   200224 136100                    SBLQ    G$D+144,,AUTO
         1 000357   000006 620006                    EAX0    6,QL
         1 000360   000010 740100                    STX0    8,,PR0

      554     4358        /*
      555     4359            ***       ERROR HANDLER
      556     4360                      (Any error other than a syntax error unwinds to here)
      557     4361        */
      558     4362    1   ERROR:
      559     4363    1       ALTRETURN;

   4363  1 000361   000000 702200 xent  ERROR        TSX2  ! X66_AALT
      560     4364    1   END   XUP$PARSE;
      561     4365        %EOD;

PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:57   
--  Include file information  --

   XU_PERR_C.:E05TOU  is referenced.
   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$PARSE.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:58   

 **** Variables and constants ****

  ****  Section 000 RoData XUP$PARSE

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     1-0-0/w STRC        r     1 NULL_ROOT                  6-0-0/w STRC        r     1 PRE_C00
     4-0-0/w STRC        r     1 SMALL_WORK                 0-0-0/w STRC        r     1 SYN_ERR

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @PCB                       4-0-0/d STRC(5175)  r     1 G$D
    *0-0-0/w STRC(504)   r     1 PCB

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 BLK$                       0-0-0/c CHAR        r     1 C$BUFA(0:0)
     0-0-0/w STRC(108)   r     1 FREE$HDR                   0-0-0/w STRC(144)   r     1 OUT$BLK
     0-0-0/w STRC(72)    r     1 POSS


   Procedure XUP$PARSE requires 242 words for executable code.
   Procedure XUP$PARSE requires 152 words of local(AUTO) storage.
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:59   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:60   
          MINI XREF LISTING

BLK$
      3877**DCL      4326>>ASSIGN   4334>>ASSIGN
C$BUFA
      3876**DCL      4298>>ASSIGN
ERROR
      4363**LABEL    4178--REMEMBR
FREE$HDR.NEXT$
      3990**DCL      4246<<ASSIGN   4249<<ASSIGN
FREE$HDR.NWORDS
      3989**DCL      4244<<ASSIGN   4247<<ASSIGN
FREE$HDR.PREV$
      3991**DCL      4243<<ASSIGN   4248<<ASSIGN
G$D
      3895**DCL      4173<<ASSIGN   4302<>CALL     4316<>CALL     4329<>CALL     4355<>CALL
G$D.CCHAR
      3951**DCL      4298<<ASSIGN
G$D.CCPOS
      3943**DCL      4310>>ASSIGN
G$D.ERROR
      3899**DCL      4178<<REMEMBR
G$D.FREEANCHOR$
      3913**DCL      4242<<ASSIGN   4243>>ASSIGN   4244>>ASSIGN   4245>>ASSIGN   4246>>ASSIGN   4248>>ASSIGN
G$D.HISPACE$
      3921**DCL      4250<<ASSIGN   4339>>ASSIGN   4357>>ASSIGN
G$D.LASTFREE$
      3917**DCL      4245<<ASSIGN   4246>>ASSIGN   4247>>ASSIGN   4248>>ASSIGN   4249>>ASSIGN   4250>>ASSIGN
G$D.LDCMNT.CT
      3964**DCL      4261<<ASSIGN   4266<<ASSIGN   4272<<ASSIGN
G$D.LDCMNT.TX
      3965**DCL      3966--REDEF    4262<<ASSIGN   4267<<ASSIGN   4273<<ASSIGN
G$D.NODE$
      3906**DCL      4315<<ASSIGN
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:61   
G$D.PCB$
      3896**DCL      4174<<ASSIGN
G$D.REDUCE$
      3928**DCL      4252<<ASSIGN
G$D.SCRATCH
      3932**DCL      3935--REDEF    4324<<ASSIGN   4325>>IF       4329>>CALL     4330>>ASSIGN   4332>>DOWHILE
      4333<<ASSIGN   4333>>ASSIGN   4334>>ASSIGN
G$D.STACKTOP$
      3924**DCL      4251<<ASSIGN   4324>>ASSIGN   4326>>ASSIGN   4334>>ASSIGN   4336<<ASSIGN   4336>>ASSIGN
G$D.TRCMNT.CT
      3972**DCL      4278<<ASSIGN   4281<<ASSIGN   4287<<ASSIGN
G$D.TRCMNT.TX
      3973**DCL      3974--REDEF    4282<<ASSIGN   4288<<ASSIGN
NULL_ROOT
      4077**DCL      4234>>ASSIGN
OUT$BLK.NSUBLKS
      4027**DCL      4330<<ASSIGN
OUT$BLK.SUBLK$
      4048**DCL      4334<<ASSIGN
OUT$BLK.TEMP
      4016**DCL      4331<<ASSIGN
PCB
      3682**DCL       268--PROC     4168--ENTRY    4174--ASSIGN
PCB.COMMENT.LEAD
      3800**DCL      4257>>IF       4259>>IF       4267>>ASSIGN   4273>>ASSIGN
PCB.COMMENT.TRAIL
      3808**DCL      4275>>IF       4277>>IF       4282>>ASSIGN   4288>>ASSIGN
PCB.ERROR
      3786**DCL      4206<<ASSIGN   4221<<ASSIGN   4234<<ASSIGN   4313<<ASSIGN   4352<<ASSIGN
PCB.HINODE$
      3840**DCL      4311<<ASSIGN
PCB.HI_CHAR
      3833**DCL      4310<<ASSIGN
PCB.NCHARS
      3829**DCL      3875--IMP-SIZ  4211>>IF       4296>>IF
PCB.NOLEADBLANKS
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:62   
      3727**DCL      4294>>IF
PCB.NXT
      3732**DCL      4306>>IF       4353>>IF
PCB.NXT_SZONLY
      3777**DCL      4353>>IF
PCB.OUT$
      3695**DCL      4326<<ASSIGN   4329<>CALL     4330>>ASSIGN   4331>>ASSIGN   4334>>ASSIGN
PCB.ROOT$
      3687**DCL      4225>>IF       4315>>ASSIGN
PCB.TEXT$
      3683**DCL      4298>>ASSIGN
PCB.VERSION_CODE
      3819**DCL      4182>>IF
PCB.WKSZ
      3712**DCL      4211>>IF       4251>>ASSIGN   4324>>ASSIGN
PCB.WK_USED
      3815**DCL      4308>>ASSIGN   4312<<ASSIGN   4339<<ASSIGN   4357<<ASSIGN
PCB.WORK$
      3691**DCL      4242>>ASSIGN   4251>>ASSIGN   4308>>ASSIGN   4324>>ASSIGN   4339>>ASSIGN   4357>>ASSIGN
POSS
      3999**DCL      4308<<ASSIGN
PRE_C00
      4117**DCL      4206>>ASSIGN
SMALL_WORK
      4101**DCL      4221>>ASSIGN
SYNERR
      4352**LABEL    4316--CALLALT
SYN_ERR
      4069**DCL      4352>>ASSIGN
XUP$COMCHK
      3868**DCL-ENT  4302--CALL
XUP$DMPNXT
      3869**DCL-ENT  4355--CALL
XUP$GETSPACE
      3871**DCL-ENT  4329--CALL
XUP$PARS
PL6.E3A0      #001=XUP$PARSE File=XUP$PARSE.:E05TSI                              WED 07/30/97 09:37 Page:63   
      3870**DCL-ENT  4316--CALL

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:64   
      562        1        /*T***********************************************************/
      563        2        /*T*                                                         */
      564        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      565        4        /*T*                                                         */
      566        5        /*T***********************************************************/
      567        6        XUP$PARS:
      568        7            PROC(G$D) ALTRET;
      569        8
      570        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      571       10        /*D*
      572       11            NAME: XUP$PARS
      573       12            CALL:
      574       13                CALL XUP$PARS (G$D) ALTRET(syntax error);
      575       14            PARAMETERS:
      576       15                G$D -- structure containing or pointing to all data needed for
      577       16                        parsing.
      578       17            INTERFACE:
      579       18                XUP$PARS (recursive calls)
      580       19                XUP$GETSPACE, XUP$FREESPACE, XUP$FREEOUT
      581       20            INPUT:
      582       21                Various information in G$D, PCB, etc.  In particlar:
      583       22                G$D.NODE$ -- point to node to attempt to parse
      584       23            OUTPUT:
      585       24                Various information in G$D, PCB, etc. updated. In particular,
      586       25                if the parse was successful, and built an output block, the
      587       26                block will be allocated in the work area, and its address will
      588       27                be on the top of the parse stack.
      589       28            DESCRIPTION:
      590       29                This routine attempts to match the source text of a command
      591       30                to the syntax specified for a given parse node.  If it can,
      592       31                it builds an output block for the node and returns normally,
      593       32                otherwise it altreturns.
      594       33        */
      595       34        %INCLUDE      B_SEGIDS_C;
      596      573        %INCLUDE B$TABLES_C;
      597      681        %INCLUDE XU_DATA_R;
      598      692        %INCLUDE      XU_MACRO_C;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:65   
      599     3798        %INCLUDE      XU_SUBS_C;
      600     3890        /*
      601     3891            ***       PARSE NODE STRUCTURES
      602     3892        */
      603     3893            %P$NODE(STCLASS="BASED(NODE$)");
      604     3987           %P$LIT(STCLASS="BASED(NODE$)", LEN="P$LIT.COUNT");
      605     4040           %P$SYM(STCLASS="BASED(NODE$)", LEN="P$SYM.COUNT");
      606     4119           %P$DSTR(STCLASS="BASED(NODE$)");
      607     4163        /*
      608     4164            ***       PARAMETER BLOCK
      609     4165        */
      610     4166        %G$D;
      611     4262        /*
      612     4263            ***       TRANSLATION TABLE
      613     4264        */
      614     4265        %B$XL_UPPER (NAME=TRANSTBL);
      615     4269        /*
      616     4270            ***       EXTERNAL PROCEDURES
      617     4271        */
      618     4272    1   DCL       XUP$FREEOUT ENTRY(2);
      619     4273    1   DCL       XUP$GETSPACE ENTRY(3);
      620     4274    1   DCL       XUP$FREESPACE ENTRY(2);
      621     4275        /*
      622     4276            ***       EXTERNAL VARIABLES (ERROR MESSAGE CODES)
      623     4277        */
      624     4278    1   DCL       BAD_NODE    BIT(36)     SYMREF;
      625     4279    1   DCL       NULL_U$$    BIT(36)     SYMREF;
      626     4280    1   DCL       OVER_FLOW      BIT(36)     SYMREF;
      627     4281    1   DCL     CANT_RTEXT   BIT (36) SYMREF;
      628     4282    1   DCL     RTEXT_GT_511 BIT (36) SYMREF;
      629     4283    1   DCL     ILLEGAL_DYNAMIC_EXPANSION BIT (36) SYMREF;
      630     4284
      631     4285        /*
      632     4286            ***       LOCAL VARIABLES
      633     4287        */
      634     4288        /* Fields to save fallback position, to be restored in G$D on failure: */
      635     4289    1   DCL SSAVEPOS    SBIN;   /* saves G$D.CCPOS before repeats           */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:66   
      636     4290    1   DCL SAVEPOS     SBIN;   /* saves G$D.CCPOS                          */
      637     4291    1   DCL SAVELEX     SBIN;   /* saves G$D.CLEXPOS                        */
      638     4292    1   DCL SKIPBL      BIT(1); /* saves G$D.SKIPBL                         */
      639     4293
      640     4294        /* Local copies of global fields, for quick access:                 */
      641     4295    1   DCL NODE$       PTR;    /* copy of G$D.NODE$ on entry               */
      642     4296    1   DCL PCB$        PTR;    /* copy of G$D.PCB$                         */
      643     4297    1   DCL CURCHAR     CHAR(1);/* copy of G$D.CCHAR                        */
      644     4298    1   DCL NCHARS      SBIN;   /* copy of PCB.NCHARS                       */
      645     4299
      646     4300        /* Parse stack sizes, to compute number of entries added for this node: */
      647     4301    1   DCL RP_STACK    UBIN;   /* stack size on initial entry              */
      648     4302    1   DCL MY_STACK    UBIN;   /* stack size at start of latest repetition */
      649     4303    1   DCL LIST_STK    UBIN;   /* stack size at start of latest list entry */
      650     4304
      651     4305        /* General purpose variables:                                       */
      652     4306    1   DCL I           SBIN;
      653     4307    1   DCL J           SBIN;
      654     4308    1   DCL JFLAG REDEF J BIT(36);  /* for easy access to alt subnode flags */
      655     4309    1   DCL BIT36 BIT(36) BASED ALIGNED; /* and a way to use it             */
      656     4310    1   DCL K           SBIN;
      657     4311    1   DCL COUNT       SBIN;
      658     4312    1   DCL P$          PTR;
      659     4313    1   DCL Q$          PTR;
      660     4314
      661     4315        /* Other local (auto) variables:                                    */
      662     4316    1   DCL NSUBLKS     SBIN;       /* number of subblocks for current block*/
      663     4317    1   DCL VALIDSYM    UBIN;       /* flag for special lexeme validation
      664     4318                                       (set to 0 before parsing lexeme;
      665     4319                                        set to 1 when lexeme proved valid)  */
      666     4320    1   DCL BLK$        PTR;        /* addr of block for this node          */
      667     4321    1   DCL REPEAT      BIT(1);     /* flag set on for a repeating node     */
      668     4322    1   DCL REPEATABLE  BIT(1);     /* flag set if we can continue repeatin */
      669     4323    1   DCL RDUCE$      PTR;        /* saves G$D.RDUCE$ when new R$BLK list
      670     4324                                       is needed for this node              */
      671     4325    1   DCL LISTCNT     SBIN;       /* number of list elements parsed       */
      672     4326    1   DCL DLIM        CHAR(1);    /* delimiter for a DSTRING lexeme       */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:67   
      673     4327
      674     4328        /* Local based variables:                                           */
      675     4329    1   DCL C$BUF CHAR(NCHARS) BASED;   /* access command text as a string
      676     4330                                           (usually based on PCB.TEXT$)     */
      677     4331    1   DCL C$BUFA (0:0) CHAR(1) BASED; /* access command text as a char array
      678     4332                                           (usually based on PCB.TEXT$)     */
      679     4333    1   DCL STACKARY$ (0:0) PTR BASED;  /* to access the parse stack (usually
      680     4334                                           based on G$D.STACKTOP$)          */
      681     4335
      682     4336        /* Reducing alternative flag block structure:                       */
      683     4337    1   DCL 1 R$BLK BASED(P$)ALIGNED,
      684     4338    1         2 FLINK$ PTR,
      685     4339    1         2 NODE$ PTR,
      686     4340    1         2 FLAG(0:0) BIT(1);
      687     4341        /* Address for unresolved data reference in parse nodes:            */
      688     4342    1   DCL 1 ISSID_PTR CONSTANT,
      689     4343    1         2 OFFSET UBIN (24) UNAL INIT (0),
      690     4344    1         2 SEGID BIT (12) INIT (%ISSID);
      691     4345    1   DCL B$IS$ REDEF ISSID_PTR PTR;
      692     4346        /*
      693     4347            ***       OUTPUT NODE STRUCTURES
      694     4348        */
      695     4349            %PARSE$OUT;
      696     4394            %PARSE$SYM;
      697     4432        /*
      698     4433            ***       OTHER PARSER STRUCTURES
      699     4434        */
      700     4435            %PARSE_PARAM(NAME=CPARAM,STCLASS=CONSTANT);
      701     4514            %P$PCB(STCLASS="BASED(PCB$)");
      702     4715            %P$NODE(NAME=PX$NODE,STCLASS=BASED);
      703     4809            %P$LIT(NAME=PX$LIT,STCLASS=BASED);
      704     4862            %P$SYM(NAME=PX$SYM,STCLASS=BASED);
      705     4941            %P$DSTR(NAME=PX$DSTR,STCLASS=BASED);
      706     4985            %PARSE$PARAM(NAME=PARSE$PARAM,STCLASS=AUTO);
      707     5066            %XUP$POSS(NAME=POSS,STCLASS="BASED(P$)");
      708     5071        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:68   
      709     5072        /*
      710     5073            ***       BEGIN PROCEDURE
      711     5074        */
      712     5075        /*D*
      713     5076            First do initialization for this invocation:
      714     5077
      715     5078            o   Get local copy of PCB$ and NCHARS for ease of reference.
      716     5079        */
      717     5080    1       PCB$ = G$D.PCB$;
      718     5081    1       NCHARS = P$PCB.NCHARS;
      719     5082        /*D*
      720     5083            o   A node isn't treated as repeating until at least one repetition
      721     5084                is successfully parsed.
      722     5085        */
      723     5086    1       REPEAT = '0'B;
      724     5087        /*D*
      725     5088            o   Save node address in local storage and make sure the node
      726     5089                address isn't unresolved.
      727     5090        */
      728     5091    1       NODE$=G$D.NODE$;
      729     5092    1       IF NODE$ = B$IS$ OR NODE$ = ADDR(NIL)
      730     5093    1       THEN
      731     5094    1           GOTO BADNODE;
      732     5095        /*D*
      733     5096            o   If the node can repeat, or it is a list, it might have subnodes
      734     5097                that are reducing alternatives.  Each such node needs a flag
      735     5098                block (R$BLK) to keep track of which alternatives have been
      736     5099                used in the node subtree under this node.
      737     5100
      738     5101                So, if this node can have its own R$BLK list, save the current
      739     5102                list pointer in local storage so it can be restored on exit,
      740     5103                and reset the global pointer to NIL to indicate no R$BLKS have
      741     5104                been allocated yet (allocation occurs when a reducing subnode
      742     5105                is processed).  Since NIL indicates an empty list, some other
      743     5106                value is needed to indicate that there is no list for this
      744     5107                node; ADDR(G$D) is used for that purpose.
      745     5108        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:69   
      746     5109    1       IF P$NODE.TYPE = %TYPE_LIST# OR P$NODE.RPEAT = '1'B THEN
      747     5110    2       DO;
      748     5111    2           RDUCE$ = G$D.REDUCE$;
      749     5112    2           G$D.REDUCE$ = ADDR(NIL);
      750     5113    2       END;
      751     5114    1       ELSE RDUCE$=ADDR(G$D);
      752     5115        /*D*
      753     5116            o   Save current parse stack size; the stack will be popped up to
      754     5117                this point when the parse fails or when an output block is
      755     5118                built for a successful parse.
      756     5119        */
      757     5120    1       RP_STACK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);
      758     5121    1       REPEATABLE = P$NODE.RPEAT;
      759     5122    1       SSAVEPOS = G$D.CCPOS-G$D.CNTUPOS;
      760     5123        /*D*
      761     5124            Next do initialization that must be done for each repetition of a
      762     5125            repeating node, in addition to being done on initial entry:
      763     5126
      764     5127            (Repeating nodes are unique because, instead of multiple recursive
      765     5128            calls to X$PARS to generate the subblocks of the output block for
      766     5129            this call, the subblocks are generated by looping back to this
      767     5130            point after each repetition is successfully parsed, and making the
      768     5131            blocks generated by all successful repetitions into subblocks of the
      769     5132            final output block for this call after an attempted repetition fails.)
      770     5133        */
      771     5134    1   REPARSE:
      772     5135        /*D*
      773     5136            o   Indicate no output block has been built yet.
      774     5137        */
      775     5138    1       BLK$ = ADDR(NIL);
      776     5139        /*D*
      777     5140            o   Save current parse stack size.  The stack will be popped up
      778     5141                to this point when the attempted repetition fails, or when
      779     5142                the output block is built for a successful repetition.
      780     5143                (This value will increase by one for each repetition, to
      781     5144                account for the output block built by the prior repetition.)
      782     5145        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:70   
      783     5146    1       MY_STACK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);
      784     5147        /*D*
      785     5148            o   Save current position in source text and blank skip status.
      786     5149                (Positions are biased by the number of characters lost when
      787     5150                continuation lines overlay the previous text, so that, if
      788     5151                another continuation line is read before falling back, the
      789     5152                fallback will reflect the condition after reading the continuation.)
      790     5153        */
      791     5154    1       SAVEPOS = G$D.CCPOS-G$D.CNTUPOS;
      792     5155    1       SAVELEX = G$D.CLEXPOS - G$D.CNTUPOS;
      793     5156    1       SKIPBL=G$D.BLSKIP;
      794     5157        /*D*
      795     5158                Get local copy of current character for quick access.
      796     5159        */
      797     5160    1       CURCHAR = G$D.CCHAR;
      798     5161        /*D*
      799     5162            o   If the node requests a user exit before attempting the parse,
      800     5163                call the exit routine.  If the routine rejects the node, go
      801     5164                directly to the failure logic, skipping the parts to release
      802     5165                accumulated output blocks (since there will be none) and to
      803     5166                add the node to the possibility list on a reparse (since nodes
      804     5167                rejected here aren't real possibilities).  A retry response is
      805     5168                treated the same as an accept response (since the node hasn't
      806     5169                been tried at all yet); both of these reset the current position
      807     5170                in the command text in case the exit routine changed it, and
      808     5171                continue on normally.
      809     5172        */
      810     5173    1       IF P$NODE.P_F = '1'B THEN
      811     5174    2       DO;
      812     5175    2           CALL USER_EXIT (%PRE#);
      813     5176    2           IF PARSE$PARAM.REJECT THEN
      814     5177    2               GOTO NONXT;
      815     5178    2       END;
      816     5179        /*D*
      817     5180                Fail this node if the current position in the command text is
      818     5181                negative.  (This can happen if continuation lines overlay the
      819     5182                continued text and failure to parse a node requires falling
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:71   
      820     5183                back to a position that was overlaid.  All subsequent attempts
      821     5184                at parsing fail in that case.
      822     5185        */
      823     5186    1       IF G$D.CCPOS < 0 THEN GOTO SYNFAIL;
      824     5187        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:72   
      825     5188        /*D*
      826     5189            Now attempt the parse.  Logic to do this depends on the node type:
      827     5190        */
      828     5191    2       DO CASE (P$NODE.TYPE);
      829     5192
      830     5193        /*D*
      831     5194            ALTERNATIVE or REDUCING ALTERNATIVE node:
      832     5195
      833     5196                Loop to attempt to parse each alternative, in the order defined.
      834     5197                Successfully parsing any subnode constitutes syntactic success.
      835     5198
      836     5199                    I = subnode counter
      837     5200                    J = flag word for precheck
      838     5201        */
      839     5202    2       CASE(%TYPE_ALTERN#,
      840     5203    2         %TYPE_RALTERN#);
      841     5204    2           I = 0;
      842     5205    2           LISTCNT = P$NODE.NSUBNDS; /* MAKE THE DO WHILE QUICKER */
      843     5206    2           IF P$PCB.NXT AND G$D.CCPOS=P$PCB.HI_CHAR
      844     5207    2           THEN
      845     5208    2               JFLAG = '752000000000'O;
      846     5209    2           ELSE
      847     5210    2               JFLAG = '052000000000'O;
      848     5211    3           DO WHILE(I<LISTCNT);
      849     5212        /*D*
      850     5213                Before going to the full overhead of a recursive call, see if
      851     5214                the current character could possibly begin this alternative:
      852     5215                follow the subtree down to the first lexeme, and check whether
      853     5216                the current character could begin that lexeme; if not, go on
      854     5217                to the next alternative without attempting the full parse.
      855     5218
      856     5219                This precheck must be skipped if the first lexeme is optional
      857     5220                (since the alternative won't necessarily fail if it is missing)
      858     5221                or if a preparse or failure exit is requested by any node
      859     5222                leading to the first lexeme (since the full parse is needed to
      860     5223                trigger the exit), or if we are reparsing for possible next
      861     5224                nodes (since the possibility list is built during failure
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:73   
      862     5225                processing for the subnodes).
      863     5226        */
      864     5227    3               P$ = P$NODE.SUBNDS$(I);
      865     5228
      866     5229    3   LOOP:
      867     5230    3               IF NOT P$->BIT36&JFLAG THEN /* WHICH IS EQUIVALENT TO..
      868     5231                      IF NOT P$->PX$NODE.OPT
      869     5232                            AND NOT P$->PX$NODE.P_F
      870     5233                            AND NOT P$->PX$NODE.F_F
      871     5234                            AND (NOT P$PCB.NXT
      872     5235                            OR G$D.CCPOS~=P$PCB.HI_CHAR) THEN
      873     5236                        */
      874     5237    4               DO CASE(P$->PX$NODE.TYPE);
      875     5238
      876     5239    4               CASE(%TYPE_KONCAT#);
      877     5240    4                   P$ = P$->PX$NODE.SUBNDS$(0);
      878     5241    4                   GOTO LOOP;
      879     5242
      880     5243    4               CASE(%TYPE_LIST#);
      881     5244    4                   P$ = P$->PX$NODE.SUBNDS$(1);
      882     5245    4                   GOTO LOOP;
      883     5246
      884     5247    4               CASE(%TYPE_LITERAL#);
      885     5248    4                   IF SUBSTR(P$->PX$LIT.TEXT,0,1) ~= CURCHAR
      886     5249    4                     AND SUBSTR(P$->PX$LIT.TEXT,0,1) ~= TRANSTBL.C(ASCBIN(CURCHAR))
              5249                              THEN
      887     5250    4                       GOTO MISS;
      888     5251
      889     5252    4               CASE(%TYPE_LEXEME#);
      890     5253    5                   DO CASE (P$ -> PX$SYM.LEXTYPE);
      891     5254    5                   CASE (%LEX_DSTRING#);
      892     5255    5                       IF (P$->PX$DSTR.DLIM ~= CURCHAR) AND
      893     5256    5                         (P$ -> PX$DSTR.DLIM ~= BINASC(0)
      894     5257    5                         OR NOT SYMTTBL.GENERIC_DSTRING(ASCBIN(CURCHAR))) THEN
      895     5258    5                           GOTO MISS;
      896     5259
      897     5260    5                   CASE(%LEX_NULL#,
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:74   
      898     5261    5                             %LEX_HEX#,
      899     5262    5                             %LEX_OCTAL#,
      900     5263    5                             %LEX_DECIMAL#,
      901     5264    5                             %LEX_ALPHA#,
      902     5265    5                             %LEX_ANUMERIC#,
      903     5266    5                             %LEX_SYMBOL#,
      904     5267    5                             %LEX_PL6SYM#,
      905     5268    5                             %LEX_FID#);
      906     5269    5                       VALIDSYM = 0;
      907     5270    5                       CALL CHKCHAR ALTRET(MISS);
      908     5271    5                   CASE (%LEX_ACCOUNT#,
      909     5272    5                         %LEX_JOBNAME#);
      910     5273    5                       VALIDSYM = 0;
      911     5274    5                       IF CURCHAR ~= ''''
      912     5275    5                       THEN
      913     5276    5                           CALL CHKCHAR ALTRET (MISS);
      914     5277    5                   CASE (%LEX_BLANK#, %LEX_END#, %LEX_ASYM#);
      915     5278    5                   CASE (ELSE);
      916     5279    5                       GOTO MISS;
      917     5280    5                   END;
      918     5281    4               END;
      919     5282        /*D*
      920     5283                If the precheck succeeds or must be bypassed, this alternative
      921     5284                might still be rejected if this is a reducing node...
      922     5285        */
      923     5286    3               IF P$NODE.TYPE = %TYPE_RALTERN# THEN
      924     5287    4               DO;
      925     5288        /*D*
      926     5289                o   Look for a reducing alternative flag block for this node.
      927     5290                    (To avoid the need to check for an empty list, the scan
      928     5291                    starts by treating the list root pointer in G$D as if it
      929     5292                    were an R$BLK; the root address is treated as the .FLINK$,
      930     5293                    and the next work in G$D could not possibly be a .NODE$,
      931     5294                    so this little trick manages to work.)
      932     5295        */
      933     5296    4                   P$ = ADDR(G$D.REDUCE$);
      934     5297    5                   DO WHILE(R$BLK.FLINK$ ~= ADDR(NIL)
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:75   
      935     5298    5                     AND R$BLK.NODE$ ~= ADDR(P$NODE));
      936     5299    5                       P$ = R$BLK.FLINK$;
      937     5300    5                   END;
      938     5301        /*D*
      939     5302                o   If there is an R$BLK, only try to parse this alternative
      940     5303                    if its flag isn't already set.
      941     5304        */
      942     5305    4                   IF R$BLK.NODE$ = ADDR(P$NODE) AND R$BLK.FLAG(I)
      943     5306    4                   THEN GOTO MISS;
      944     5307    4                   CALL PARS_SUBND ALTRET(MISS);
      945     5308        /*D*
      946     5309                o   If the parse succeeds, create an R$BLK if one doesn't
      947     5310                    already exist, and set the flag bit for this alternative.
      948     5311        */
      949     5312    5                   IF R$BLK.NODE$ ~= ADDR(P$NODE) THEN DO;
      950     5313    5                       COUNT = (P$NODE.NSUBNDS + 35)/36 + 2;
      951     5314    5                       CALL XUP$GETSPACE(COUNT,P$->R$BLK.FLINK$,G$D);
      952     5315    5                       P$ = P$->R$BLK.FLINK$;
      953     5316    5                       P$->R$BLK.NODE$ = ADDR(P$NODE);
      954     5317    5                       P$->R$BLK.FLINK$ = ADDR(NIL);
      955     5318    5                   END;
      956     5319    4                   R$BLK.FLAG(I) = '1'B;
      957     5320    4               END;
      958     5321        /*D*
      959     5322                For a non-reducing alternative node, always attempt to parse
      960     5323                the subblock if the preckeck passes or is skipped.
      961     5324        */
      962     5325    3               ELSE CALL PARS_SUBND ALTRET(MISS);
      963     5326        /*D*
      964     5327            If any alternative succeeds, so does this node.
      965     5328        */
      966     5329    3               GOTO SYNSUCCEED;
      967     5330        /*D*
      968     5331                If the attempt to parse an alternative fails or is bypassed,
      969     5332                go on to try the next alternative, if there is one.  If no
      970     5333                alternative can be successfully parsed, this node fails.
      971     5334        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:76   
      972     5335    3   MISS:
      973     5336    3               I = I + 1;
      974     5337    3           END;
      975     5338    2           GOTO SYNFAIL;
      976     5339        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:77   
      977     5340        /*D*
      978     5341            CONCATENATION node:
      979     5342
      980     5343                Loop to attempt parsing all subnodes in the order defined.
      981     5344                If all subnodes are successfully parsed, this node also
      982     5345                succeeds; if any subnode fails, so does this node.
      983     5346        */
      984     5347    2       CASE(%TYPE_KONCAT#);
      985     5348    2           I = 0;
      986     5349    3           DO WHILE(I < P$NODE.NSUBNDS);
      987     5350    3               CALL PARS_SUBND ALTRET(SYNFAIL);
      988     5351    3               I = I + 1;
      989     5352    3           END;
      990     5353    2           GOTO SYNSUCCEED;
      991     5354        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:78   
      992     5355        /*D*
      993     5356            LIST node:
      994     5357
      995     5358                Attempt to parse the list element subnode.
      996     5359                If that succeeds, attempt to parse the delimiter subnode.
      997     5360                If that succeeds, try to parse another list element.
      998     5361                Continue until something fails.
      999     5362        */
     1000     5363    2       CASE(%TYPE_LIST#);
     1001     5364    2           LIST_STK = MY_STACK;
     1002     5365    2           LISTCNT = 0;
     1003     5366    3           DO WHILE('1'B);
     1004     5367    3               I=1;
     1005     5368    3               CALL PARS_SUBND ALTRET(LISTEND);
     1006     5369        /*D*
     1007     5370                After each list element is successfully parsed, reset the
     1008     5371                fallback position, so that a subsequent failure will not
     1009     5372                roll back beyond this point.
     1010     5373        */
     1011     5374    3               LIST_STK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);
     1012     5375    3               SAVEPOS = G$D.CCPOS-G$D.CNTUPOS;
     1013     5376    3               SAVELEX = G$D.CCPOS-G$D.CNTUPOS;
     1014     5377    3               SKIPBL=G$D.BLSKIP;
     1015     5378
     1016     5379    3               LISTCNT = LISTCNT + 1;
     1017     5380    3               I=0;
     1018     5381    3               CALL PARS_SUBND ALTRET(LISTEND);
     1019     5382    3           END;
     1020     5383
     1021     5384    2   LISTEND:
     1022     5385        /*D*
     1023     5386                If a failure occurs before a single list element is parsed,
     1024     5387                this node fails too.
     1025     5388        */
     1026     5389    2           IF LISTCNT = 0 THEN
     1027     5390    2               GOTO SYNFAIL;
     1028     5391        /*D*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:79   
     1029     5392                Otherwise, this node succeeds syntactically.
     1030     5393                But, before doing success processing, remove any output blocks
     1031     5394                created by the final unsuccessful parse attempt, and restore
     1032     5395                the current position to what it was after the last list
     1033     5396                element was successfully parsed.
     1034     5397        */
     1035     5398    2           I = P$PCB.WKSZ - POFFW (G$D.STACKTOP$, P$PCB.WORK$) - LIST_STK;
     1036     5399    2           CALL FREESTACK (I);
     1037     5400    2           CALL SAVE_POS;
     1038     5401    2           GOTO SYNSUCCEED;
     1039     5402        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:80   
     1040     5403        /*D*
     1041     5404            LEXEME node:  The logic needed to parse a metasymbol depends on
     1042     5405            the metasymbol type.
     1043     5406
     1044     5407            (Note: The term "lexeme" is used ambiguously.  Here, it means a
     1045     5408            lexeme-type node, which is actually a misnomer for a PARTRGE
     1046     5409            metasymbol.  Elsewhere, it means a metasymbol or a literal, both
     1047     5410            of which consitute leaves on the node tree.)
     1048     5411        */
     1049     5412    2       CASE(%TYPE_LEXEME#);
     1050     5413    3           DO CASE (P$SYM.LEXTYPE);
     1051     5414        /*D*
     1052     5415            FID metasymbol:
     1053     5416
     1054     5417                A fid, for parsing purposes, is a concatenation of strings of
     1055     5418                characters legal in a fid with quoted strings (which can
     1056     5419                contain any character).  This logic will accept any legal fid,
     1057     5420                but won't reject lots of illegal ones; programs parsing fids
     1058     5421                must expect additional errors from M$FID or M$OPEN.
     1059     5422
     1060     5423                    I = number of characters in fid
     1061     5424                    J = current position in command text
     1062     5425        */
     1063     5426    3           CASE(%LEX_FID#);
     1064     5427        /*D*
     1065     5428                Force failure if reparsing for legal alternatives to put this
     1066     5429                node on the list of possibilities.
     1067     5430        */
     1068     5431    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR
     1069     5432    3               THEN
     1070     5433    3                   GOTO SYNFAIL;
     1071     5434        /*D*
     1072     5435                Also fail if the current character isn't legal in a fid.
     1073     5436                (This also fails at the end of the command, since then the
     1074     5437                current character is null.)
     1075     5438        */
     1076     5439    3               P$=ADDR(P$SYM);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:81   
     1077     5440    3               CALL CHKCHAR ALTRET(SYNFAIL);
     1078     5441
     1079     5442    3               I = 0;
     1080     5443    3               J = G$D.CCPOS;
     1081     5444        /*D*
     1082     5445                Eat characters until a quote, or a character that isn't legal in a fid
     1083     5446                (or the end of the command) is found, then go to common final
     1084     5447                processing for metasymbols.
     1085     5448        */
     1086     5449    4               DO WHILE(CURCHAR ~= '''');
     1087     5450    4   FID_LOOP:
     1088     5451    4                   I = I + 1;
     1089     5452    4                   J = J + 1;
     1090     5453    4                   IF J = NCHARS THEN
     1091     5454    4                       GOTO FID_BLOCK;
     1092     5455    4                   CURCHAR = P$PCB.TEXT$->C$BUFA(J);
     1093     5456    4                   CALL CHKCHAR ALTRET(FID_BLOCK);
     1094     5457    4               END;
     1095     5458        /*D*
     1096     5459                If a quote is found, eat characters up to the next quote, then
     1097     5460                re-enter the previous loop.  (If the end of the command is
     1098     5461                reached without finding another quote, fail due to unmatched
     1099     5462                quotes.)
     1100     5463
     1101     5464                Note that fids are returned with quotes intact, since that's
     1102     5465                the form they need to be in to pass through M$FID.
     1103     5466        */
     1104     5467    3   QT_LOOP:
     1105     5468    3               I = I + 1;
     1106     5469    3               J = J + 1;
     1107     5470    3               IF J = NCHARS THEN
     1108     5471    3                   GOTO SYNFAIL;
     1109     5472    3               CURCHAR = P$PCB.TEXT$->C$BUFA(J);
     1110     5473    3               IF CURCHAR ~= '''' THEN
     1111     5474    3                   GOTO QT_LOOP;
     1112     5475
     1113     5476    3               GOTO FID_LOOP;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:82   
     1114     5477
     1115     5478        /*D*
     1116     5479                Common final processing for metasymbols:
     1117     5480
     1118     5481                    I = number of characters in symbol parsed
     1119     5482        */
     1120     5483    3   FID_BLOCK:
     1121     5484        /*D*
     1122     5485                o   If the node contains the extra information word, and that
     1123     5486                    word specifies the maximum length, fail if the symbol
     1124     5487                    parsed is longer than the maximum.
     1125     5488        */
     1126     5489    3               IF P$SYM.XTRA
     1127     5490    3               THEN
     1128     5491    3                   IF P$SYM.MAXL > 0
     1129     5492    3                     AND P$SYM.MAXL < I
     1130     5493    3                   THEN
     1131     5494    3                       GOTO SYNFAIL;
     1132     5495        /*D*
     1133     5496                o   If the metasymbol requires an output block, allocate a
     1134     5497                    symbol-type block, move the symbol text into the block
     1135     5498                    (converting it to upper case if the node requests this),
     1136     5499                    and set other fields specific to a symbol block.  (Common
     1137     5500                    fields are set up later, during success processing.)
     1138     5501        */
     1139     5502    4               IF P$NODE.O_F THEN DO;
     1140     5503    4                   COUNT = (I + 20)/4;
     1141     5504    4                   CALL XUP$GETSPACE(COUNT,Q$,G$D);
     1142     5505    4                   BLK$ = Q$;
     1143     5506    4                   BLK$->OUT$SYM.COUNT = I;
     1144     5507    4                   IF P$SYM.MAKEUC
     1145     5508    4                   THEN
     1146     5509    4                       CALL XLATE (BLK$ -> OUT$SYM.TEXT, TRANSTBL,
     1147     5510    4                         SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I));
     1148     5511    4                   ELSE
     1149     5512    4                       BLK$ -> OUT$SYM.TEXT =
     1150     5513    4                         SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:83   
     1151     5514    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);
     1152     5515    4                   BLK$->OUT$SYM.NSUBLKS = 1;
     1153     5516
     1154     5517    4               END;
     1155     5518        /*D*
     1156     5519                o   Set current position in comment text to point past the
     1157     5520                    lexeme just parsed.
     1158     5521        */
     1159     5522    3               G$D.CCPOS = G$D.CCPOS+I;
     1160     5523        /*D*
     1161     5524                o   Go on to lexical success processing.
     1162     5525        */
     1163     5526    3               GOTO LEXSUCCEED;
     1164     5527        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:84   
     1165     5528        /*D*
     1166     5529            ASYM metasymbol:
     1167     5530
     1168     5531                To parse an anti-symbol, scan for all possible delimiters,
     1169     5532                such that each successive scan is delimited by the position
     1170     5533                of the first delimiter found by the prior scan, so that the
     1171     5534                result is the position of the first possible delimiter found
     1172     5535                (or the end of the command if no delimiters are found).
     1173     5536
     1174     5537                    I = index into command text of first delimiter found
     1175     5538                    J = index into delimiter list
     1176     5539        */
     1177     5540    3           CASE(%LEX_ASYM#);
     1178     5541    3               I = NCHARS;
     1179     5542    3               J = 0;
     1180     5543    3               IF P$SYM.XTRA THEN
     1181     5544    4               DO WHILE(J <P$SYM.COUNT);
     1182     5545    4                   CALL INDEX(I,
     1183     5546    4                     SUBSTR(P$SYM.TEXT,J,1),
     1184     5547    4                     SUBSTR(P$PCB.TEXT$->C$BUF,0,I),
     1185     5548    4                     G$D.CCPOS);
     1186     5549    4                   J = J + 1;
     1187     5550    4               END;
     1188     5551
     1189     5552    3               I = I-G$D.CCPOS;
     1190     5553    3               GOTO FID_BLOCK;
     1191     5554        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:85   
     1192     5555        /*D*
     1193     5556            ACCOUNT or JOBNAME metasymbol:
     1194     5557
     1195     5558                These are treated as normal lexemes unless they begin with a
     1196     5559                quote, in which case they follow the rules for a DSTRING
     1197     5560                metasymbol, with a quote at the delimiter.
     1198     5561        */
     1199     5562    3           CASE(%LEX_ACCOUNT#,
     1200     5563    3                 %LEX_JOBNAME#);
     1201     5564    3               IF CURCHAR = ''''
     1202     5565    4               THEN DO;
     1203     5566    4                   DLIM = '''';
     1204     5567    4                   GOTO DSTRING;
     1205     5568    4               END;
     1206     5569    3               ELSE
     1207     5570    3                   GOTO STDLEX;
     1208     5571        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:86   
     1209     5572        /*D*
     1210     5573            Other metasymbols:
     1211     5574
     1212     5575                For most metasymbols, common logic can be used to eat
     1213     5576                characters until one is found that is illegal for the
     1214     5577                metasymbol type.
     1215     5578
     1216     5579                    I = number of characters in symbol
     1217     5580                    COUNT = current position in command text
     1218     5581        */
     1219     5582    3           CASE(%LEX_NULL#,
     1220     5583    3                     %LEX_HEX#,
     1221     5584    3                     %LEX_OCTAL#,
     1222     5585    3                     %LEX_DECIMAL#,
     1223     5586    3                     %LEX_ALPHA#,
     1224     5587    3                     %LEX_ANUMERIC#,
     1225     5588    3                     %LEX_PL6SYM#,
     1226     5589    3                     %LEX_SYMBOL#);
     1227     5590    3   STDLEX:
     1228     5591        /*D*
     1229     5592                Force failure if reparsing for legal alternatives to put this
     1230     5593                node on the list of possibilities.
     1231     5594        */
     1232     5595    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR
     1233     5596    3               THEN
     1234     5597    3                   GOTO SYNFAIL;
     1235     5598        /*D*
     1236     5599            o   If not one character can be parsed for this lexeme, the node fails.
     1237     5600        */
     1238     5601    3               VALIDSYM = 0;
     1239     5602    3               P$=ADDR(P$SYM);
     1240     5603    3               CALL CHKCHAR ALTRET(SYNFAIL);
     1241     5604        /*D*
     1242     5605            o   Otherwise eat characters until one is found that isn't legal
     1243     5606                for the symbol being parsed.
     1244     5607        */
     1245     5608    3               COUNT=G$D.CCPOS+1;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:87   
     1246     5609    3               I=1;
     1247     5610    4               DO WHILE(COUNT<NCHARS);
     1248     5611    4                   CURCHAR=P$PCB.TEXT$->C$BUFA(COUNT);
     1249     5612    4                   CALL CHKCHAR ALTRET(MAKEBLK);
     1250     5613    4                   I = I + 1;
     1251     5614    4                   COUNT=COUNT+1;
     1252     5615    4               END;
     1253     5616        /*D*
     1254     5617            o   Alphanumeric and symbol lexemes need a special test to make
     1255     5618                sure at least one character parsed is a letter.
     1256     5619        */
     1257     5620    3   MAKEBLK:
     1258     5621    3               IF P$SYM.LEXTYPE = %LEX_ANUMERIC# OR P$SYM.LEXTYPE = %LEX_SYMBOL# THEN
     1259     5622    3                   IF VALIDSYM = 0 THEN
     1260     5623    3                       GOTO SYNFAIL;
     1261     5624        /*D*
     1262     5625            o   Continue with common final metasymbol processing.
     1263     5626        */
     1264     5627    3               GOTO FID_BLOCK;
     1265     5628        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:88   
     1266     5629        /*D*
     1267     5630            DELIMITED STRING metasymbol:
     1268     5631
     1269     5632                If a string beginning and ending with the proper delimiter
     1270     5633                can be parsed, build an output block for the symbol and go
     1271     5634                on to lexical success, otherwise indicate failure.
     1272     5635        */
     1273     5636    3           CASE(%LEX_DSTRING#);
     1274     5637        /*D*
     1275     5638            o   If current character isn't a delimiter, fail immediately.
     1276     5639        */
     1277     5640    3               IF (CURCHAR~=P$DSTR.DLIM) AND (P$DSTR.DLIM~=BINASC(0) OR
     1278     5641    3                 NOT SYMTTBL.GENERIC_DSTRING(ASCBIN(CURCHAR))) THEN
     1279     5642    3                   GOTO SYNFAIL;
     1280     5643    3               DLIM = CURCHAR;
     1281     5644    3   DSTRING:
     1282     5645        /*D*
     1283     5646                Force failure if reparsing for legal alternatives to put this
     1284     5647                node on the list of possibilities.
     1285     5648        */
     1286     5649    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR
     1287     5650    3               THEN
     1288     5651    3                   GOTO SYNFAIL;
     1289     5652    3               I = 0;
     1290     5653    3               J = G$D.CCPOS + 1;
     1291     5654        /*D*
     1292     5655            o   Loop to parse characters for a delimited string:
     1293     5656
     1294     5657                DELIM = delimiting character
     1295     5658                I = number of characters in the string (excluding
     1296     5659                    doubled embedded delimiters)
     1297     5660                J = position in command text to start scan for next delimiter
     1298     5661                K = position in command text of last delimiter found
     1299     5662        */
     1300     5663    3   DLIM_LOOP:
     1301     5664        /*D*
     1302     5665            o   Fail if no ending delimiter found before end of text.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:89   
     1303     5666        */
     1304     5667    3               IF J >= NCHARS
     1305     5668    3               THEN
     1306     5669    3                   GOTO SYNFAIL;
     1307     5670        /*D*
     1308     5671            o   Scan command from current position to end, looking for a delimiter.
     1309     5672        */
     1310     5673    3               CALL INDEX (K, DLIM, P$PCB.TEXT$ -> C$BUF, J) ALTRET (SYNFAIL);
     1311     5674        /*D*
     1312     5675            o   If a delimiter is found before the end of the command, and
     1313     5676                the next character is also the delimiter, then this pair
     1314     5677                of characters represents a single embedded delimter.  So,
     1315     5678                move the substring from the start of the scan, up to and
     1316     5679                including the first delimiter, into a temporary buffer,
     1317     5680                and continue scanning for the final delimiter.
     1318     5681        */
     1319     5682    3               IF K < NCHARS - 1
     1320     5683    3               THEN
     1321     5684    3                   IF P$PCB.TEXT$ -> C$BUFA(K+1) = DLIM
     1322     5685    4                   THEN DO;
     1323     5686    4                       IF I + K - J + 1 > LENGTHC(G$D.TBUF)
     1324     5687    4                       THEN
     1325     5688    4                           GOTO SYNFAIL;
     1326     5689    4                       SUBSTR(G$D.TBUF, I, K-J+1) = SUBSTR(P$PCB.TEXT$ -> C$BUF, J);
     1327     5690    4                       I = I + K - J + 1;
     1328     5691    4                       J = K + 2;
     1329     5692    4                       GOTO DLIM_LOOP;
     1330     5693    4                   END;
     1331     5694        /*D*
     1332     5695            o   When the final delimiter is found, move the last (or only)
     1333     5696                portion of the string into the temporary buffer.
     1334     5697        */
     1335     5698    3               IF I + K - J > LENGTHC(G$D.TBUF)
     1336     5699    3               THEN
     1337     5700    3                   GOTO SYNFAIL;
     1338     5701    3               SUBSTR(G$D.TBUF, I, K-J) = SUBSTR(P$PCB.TEXT$ -> C$BUF, J);
     1339     5702    3               I = I + K - J;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:90   
     1340     5703        /*D*
     1341     5704            o   DSTRING can't use the common lexeme termination logic,
     1342     5705                since the string is taken from the temporary buffer rather
     1343     5706                than the command text, due to the possibility of embedded
     1344     5707                delimiters.  So, logic to check the maximum length and to
     1345     5708                create the output block must be duplicated here.
     1346     5709
     1347     5710                Also, RTEXT processing is different for DSTRINGs, because
     1348     5711                here it means to return the entire string, including all
     1349     5712                delimiters.  (RTEXT can be ignored for other lexemes, since
     1350     5713                the same text is returned whether or not it is set.)
     1351     5714        */
     1352     5715    3               IF P$SYM.XTRA OR P$DSTR.LEXTYPE = %LEX_DSTRING#
     1353     5716    3               THEN
     1354     5717    3                   IF P$DSTR.MAXL > 0 THEN
     1355     5718    3                       IF I > P$DSTR.MAXL THEN
     1356     5719    3                           GOTO SYNFAIL;
     1357     5720    3               IF P$DSTR.RTEXT
     1358     5721    4               THEN DO;
     1359     5722    4                   I = K - G$D.CCPOS + 1;
     1360     5723    4                   IF I > 511
     1361     5724    4                   THEN
     1362     5725    4                       GOTO RTEXT_TOO_LONG;
     1363     5726    4                   COUNT = (I + 20) / 4;
     1364     5727    4                   CALL XUP$GETSPACE (COUNT, Q$, G$D);
     1365     5728    4                   BLK$ = Q$;
     1366     5729    4                   BLK$ -> OUT$SYM.COUNT = I;
     1367     5730    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR(Q$ -> OUT$SYM.COUNT);
     1368     5731    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;
     1369     5732    4                   BLK$ -> OUT$SYM.TEXT =
     1370     5733    4                     SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);
     1371     5734    4               END;
     1372     5735    4               ELSE DO;
     1373     5736    4                   COUNT = (I + 20)/4;
     1374     5737    4                   CALL XUP$GETSPACE(COUNT,Q$,G$D);
     1375     5738    4                   BLK$ = Q$;
     1376     5739    4                   BLK$ -> OUT$SYM.COUNT = I;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:91   
     1377     5740    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);
     1378     5741    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;
     1379     5742    4                   IF P$DSTR.MAKEUC
     1380     5743    4                   THEN
     1381     5744    4                       CALL XLATE (BLK$ -> OUT$SYM.TEXT, TRANSTBL,
     1382     5745    4                         SUBSTR (G$D.TBUF, 0, I));
     1383     5746    4                   ELSE
     1384     5747    4                       BLK$ -> OUT$SYM.TEXT = SUBSTR(G$D.TBUF, 0, I);
     1385     5748    4               END;
     1386     5749        /*D*
     1387     5750            o   Set current position in command text to just after the final
     1388     5751                delimiter.
     1389     5752        */
     1390     5753    3               G$D.CCPOS = K + 1;
     1391     5754    3               GOTO LEXSUCCEED;
     1392     5755        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:92   
     1393     5756        /*D*
     1394     5757            END metasymbol:
     1395     5758
     1396     5759                This succeeds (syntactically, not lexically) if the current
     1397     5760                position is at the end of the command text, otherwise it fails.
     1398     5761                (Lexical success processing could also be used, but that would
     1399     5762                go through spurious motions to reset the current position,
     1400     5763                which is never advanced in this case.)
     1401     5764        */
     1402     5765    3           CASE(%LEX_END#);
     1403     5766    3               IF G$D.CCPOS < NCHARS THEN GOTO SYNFAIL;
     1404     5767    3               GOTO SYNSUCCEED;
     1405     5768        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:93   
     1406     5769        /*D*
     1407     5770            BLANK metasymbol:
     1408     5771
     1409     5772                Try to skip over a blank or comment.  If that works, or if
     1410     5773                a blank or comment was eaten after parsing the prior node,
     1411     5774                go indicate lexical success, but bypass logic to reset the
     1412     5775                current position and skip blanks, because we've already done
     1413     5776                that here.
     1414     5777        */
     1415     5778    3           CASE(%LEX_BLANK#);
     1416     5779    3               CALL CHK_CONTUE;
     1417     5780    3               IF NOT G$D.BLSKIP THEN GOTO SYNFAIL;
     1418     5781    3               SAVEPOS=SAVEPOS+G$D.CNTUPOS;
     1419     5782    3               GOTO BLANKSUCC;
     1420     5783        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:94   
     1421     5784        /*D*
     1422     5785            Unknown metasymbol:
     1423     5786
     1424     5787                Abort the parse.
     1425     5788        */
     1426     5789    3           CASE(ELSE);
     1427     5790    3               GOTO BADNODE; /* bad lexical node */;
     1428     5791    3           END /* DO CASE (P$SYM.LEXTYPE) */;
     1429     5792        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:95   
     1430     5793        /*D*
     1431     5794            LITERAL node:
     1432     5795
     1433     5796                A literal succeeds lexically if it can be parsed up to its
     1434     5797                minimal abbreviation, otherwise it fails.
     1435     5798
     1436     5799                I = number of characters parsed
     1437     5800                J = number of characters in the literal (copied from node
     1438     5801                    for speed of access).
     1439     5802        */
     1440     5803    2       CASE (%TYPE_LITERAL#);
     1441     5804        /*D*
     1442     5805                At the end of the command, or at the failure point for a reparse,
     1443     5806                force failure.
     1444     5807        */
     1445     5808    2           IF G$D.CCPOS = NCHARS
     1446     5809    2             OR (G$D.CCPOS = P$PCB.HI_CHAR AND P$PCB.NXT)
     1447     5810    2           THEN
     1448     5811    2               GOTO SYNFAIL;
     1449     5812        /*D*
     1450     5813                Set number of matching characters needed to succeed, and put
     1451     5814                text to match in the temporary buffer (translating it to upper
     1452     5815                case if case insensitive conversion is to be done).
     1453     5816        */
     1454     5817    2           J = P$LIT.COUNT;
     1455     5818    2           IF P$LIT.UPRLOWR
     1456     5819    2           THEN
     1457     5820    2               CALL XLATE (SUBSTR(G$D.TBUF, 0, J), TRANSTBL,
     1458     5821    2                 SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS));
     1459     5822    2           ELSE
     1460     5823    2               SUBSTR(G$D.TBUF, 0, J) = SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS);
     1461     5824    2           IF P$LIT.ABREV = 0
     1462     5825    2           THEN
     1463     5826    2               I = J;
     1464     5827    2           ELSE
     1465     5828    2               I = P$LIT.ABREV;
     1466     5829        /*D*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:96   
     1467     5830                Fail if the minimum number of characters needed exceeds the
     1468     5831                number of characters left in the command text.
     1469     5832        */
     1470     5833    2           IF I > NCHARS - G$D.CCPOS
     1471     5834    2           THEN
     1472     5835    2               GOTO SYNFAIL;
     1473     5836        /*D*
     1474     5837                Fail if the minimum number of characters needed doesn't match
     1475     5838                the literal text.
     1476     5839        */
     1477     5840    2           IF SUBSTR(G$D.TBUF, 0, I) ~= SUBSTR(P$LIT.TEXT, 0, I)
     1478     5841    2           THEN
     1479     5842    2               GOTO SYNFAIL;
     1480     5843        /*D*
     1481     5844                Parse any characters beyond the minimum that also match the
     1482     5845                literal text.
     1483     5846        */
     1484     5847    3           DO WHILE (I < J);
     1485     5848    3               IF SUBSTR(G$D.TBUF,I,1) ~= SUBSTR(P$LIT.TEXT,I,1)
     1486     5849    3               THEN
     1487     5850    3                   EXIT;
     1488     5851    3               I=I+1;
     1489     5852    3           END;
     1490     5853        /*D*
     1491     5854                If an RTEXT block is to be returned, allocate a symbol block
     1492     5855                and fill in the fields specific to a symbol block. (Common
     1493     5856                fields will be filled in during success processing; if a
     1494     5857                normal output block is to be returned, the block itself will
     1495     5858                also be allocated by common success logic.)
     1496     5859        */
     1497     5860    2           IF P$LIT.O_F AND P$LIT.RTEXT
     1498     5861    3           THEN DO;
     1499     5862    3               COUNT = (I + 20) / 4;
     1500     5863    3               CALL XUP$GETSPACE (COUNT, Q$, G$D);
     1501     5864    3               BLK$ = Q$;
     1502     5865    3               BLK$ -> OUT$SYM.NSUBLKS = 1;
     1503     5866    3               BLK$ -> OUT$SYM.TEXTC$ = ADDR(Q$ -> OUT$SYM.COUNT);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:97   
     1504     5867    3               BLK$ -> OUT$SYM.COUNT = I;
     1505     5868    3               BLK$ -> OUT$SYM.TEXT = SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);
     1506     5869    3           END;
     1507     5870        /*D*
     1508     5871                Update current position to point past literal just parsed,
     1509     5872                and go to common lexical success processing.
     1510     5873        */
     1511     5874    2           G$D.CCPOS = G$D.CCPOS + I;
     1512     5875    2           GOTO LEXSUCCEED;
     1513     5876        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:98   
     1514     5877        /*D*
     1515     5878            UNKNOWN node:  Abort the parse.
     1516     5879        */
     1517     5880    2       CASE (ELSE);
     1518     5881
     1519     5882        /*E*          ERROR:   XUP-E$BADNODE-C
     1520     5883                      MESSAGE:    Illegal node encountered by X$PARSE
     1521     5884                      MESSAGE1: An illegal or undefined node was encountered by X$PARSE.
     1522     5885                                This may have one of three causes:
     1523     5886
     1524     5887                                1) The node's TYPE or LEXTYPE field is invalid;
     1525     5888                                2) The node's address is ADDR(NIL);
     1526     5889                                3) The node's address is at the base of the instruction
     1527     5890                                   segment, which means that the node is probably an
     1528     5891                                   unsatisfied SYMREF.
     1529     5892        */
     1530     5893
     1531     5894    2   BADNODE:
     1532     5895    2           G$D.PCB$->P$PCB.ERROR = BAD_NODE;
     1533     5896    2           P$PCB.HINODE$ = ADDR(P$NODE);
     1534     5897    2           P$PCB.HI_CHAR = G$D.CCPOS;
     1535     5898    2           UNWIND TO G$D.ERROR;
     1536     5899    2       END;     /* END OF NODE PROCESSING CASE GROUP */
     1537     5900        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:99   
     1538     5901        /*D*
     1539     5902            Syntactic Success Processing:
     1540     5903
     1541     5904                Control transfers to this point when a non-lexical node is
     1542     5905                successfully parsed.  Syntactic success is generally used
     1543     5906                when a node that can have subnodes is parsed.  If it generates
     1544     5907                an output block, it is an OUT$BLK.  No logic to change the
     1545     5908                current position is needed here; all progress through the
     1546     5909                command text is made during lexical success processing of the
     1547     5910                subnodes of syntax nodes.
     1548     5911        */
     1549     5912    1   SYNSUCCEED:
     1550     5913        /*D*
     1551     5914            If this is a repeating node, signal that repetition processing
     1552     5915            applies, now that at least one repetition has been successfully
     1553     5916            parsed.
     1554     5917        */
     1555     5918    1       IF P$NODE.RPEAT = '1'B THEN
     1556     5919    1           REPEAT = '1'B;
     1557     5920        /*D*
     1558     5921            For a repeated node, control transfers back to this point after
     1559     5922            failure processing for the last attempted repetition, in order
     1560     5923            to build the output block for the node.
     1561     5924        */
     1562     5925    1   RPEATSUC:
     1563     5926        /*D*
     1564     5927            Number of subblocks for this node's output block is the number of
     1565     5928            parse stack entries added since this invocation (or repetition)
     1566     5929            of X$PARS began.
     1567     5930        */
     1568     5931    1       NSUBLKS = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$) - MY_STACK;
     1569     5932        /*D*
     1570     5933            Create an output block is the node being parsed asks for one,
     1571     5934            or if there is more than one subblock and an uncompressed output
     1572     5935            tree is requested.
     1573     5936        */
     1574     5937    1       IF (NSUBLKS > 1 AND NOT P$PCB.CMPRS) OR
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:100  
     1575     5938    1         (P$NODE.O_F AND NOT REPEAT) THEN
     1576     5939    2       DO;
     1577     5940        /*D*
     1578     5941            o   If there is only one temporary subblock for this node, pop it off
     1579     5942               the parse stack and make it the output block for this node.
     1580     5943        */
     1581     5944    2           IF NSUBLKS = 1
     1582     5945    2             AND G$D.STACKTOP$->STACKARY$(0)->OUT$BLK.TEMP THEN
     1583     5946    3           DO;
     1584     5947    3               BLK$ = G$D.STACKTOP$->STACKARY$(0);
     1585     5948    3               G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);
     1586     5949    3           END;
     1587     5950    2           ELSE
     1588     5951    3           DO;
     1589     5952        /*D*
     1590     5953            o   Otherwise, a new output block must be allocated.  Logic for doing
     1591     5954                this differs for RTEXT nodes and others.
     1592     5955        */
     1593     5956    3               IF P$NODE.RTEXT
     1594     5957    4               THEN DO;
     1595     5958        /*D*
     1596     5959            o   For an RTEXT node...
     1597     5960
     1598     5961                o   If the text to be returned spans lines and continuation text
     1599     5962                    has overlaid part of that text, we can't return the full text.
     1600     5963        */
     1601     5964    4                   IF SAVEPOS + G$D.CNTUPOS > G$D.CLEXPOS
     1602     5965    4                   THEN
     1603     5966    4                       GOTO CANT_RETURN_TEXT;
     1604     5967        /*D*
     1605     5968                o   Free any output blocks that have been created for the node.
     1606     5969        */
     1607     5970    4                   CALL FREESTACK (NSUBLKS);
     1608     5971        /*D*
     1609     5972                o   Compute number of characters parsed for this node; abort the
     1610     5973                    parse if this size is too big.
     1611     5974        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:101  
     1612     5975    4                   I = G$D.CLEXPOS - G$D.CNTUPOS - SSAVEPOS;
     1613     5976    4                   IF I > 511
     1614     5977    4                   THEN
     1615     5978    4                       GOTO RTEXT_TOO_LONG;
     1616     5979        /*D*
     1617     5980            o       Allocate an symbol output block large enough to hold the text
     1618     5981                    to be reuturned, fill it in, and continue as if this were
     1619     5982                    lexical success.
     1620     5983        */
     1621     5984    4                   COUNT = (I + 20) / 4;
     1622     5985    4                   CALL XUP$GETSPACE (COUNT, Q$, G$D);
     1623     5986    4                   BLK$ = Q$;
     1624     5987    4                   BLK$ -> OUT$SYM.COUNT = I;
     1625     5988    4                   BLK$ -> OUT$SYM.TEXT =
     1626     5989    4                     SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CNTUPOS + SSAVEPOS, I);
     1627     5990    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);
     1628     5991    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;
     1629     5992    4                   BLK$ -> OUT$SYM.CODE = P$NODE.CODE;
     1630     5993    4                   BLK$ -> OUT$SYM.CPOS = SSAVEPOS;
     1631     5994    4                   BLK$ -> OUT$SYM.NDTYPE = %RTEXT#;
     1632     5995    4                   GOTO LEXSUCC2;
     1633     5996    4               END;
     1634     5997    4               ELSE DO;
     1635     5998        /*D*
     1636     5999            o   If this is a normal (non-RTEXT) node:
     1637     6000
     1638     6001                o   Allocate an output block large enough hold pointers to all
     1639     6002                    subblocks, and set the subblock count.
     1640     6003        */
     1641     6004    4                   CALL XUP$GETSPACE(NSUBLKS + 3,Q$,G$D);
     1642     6005    4                   BLK$ = Q$;
     1643     6006        /*D*
     1644     6007                o   Pop all subblock pointers off the parse stack and copy
     1645     6008                    them to the new block.
     1646     6009        */
     1647     6010    4                   BLK$->OUT$BLK.NSUBLKS = NSUBLKS;
     1648     6011    5                   DO WHILE(NSUBLKS > 0);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:102  
     1649     6012    5                       NSUBLKS = NSUBLKS - 1;
     1650     6013    5                       BLK$->OUT$BLK.SUBLK$(NSUBLKS) =
     1651     6014    5                         G$D.STACKTOP$->STACKARY$(0);
     1652     6015    5                       G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);
     1653     6016    5                   END;
     1654     6017    4               END;
     1655     6018    3           END;
     1656     6019        /*D*
     1657     6020            o   Set the temporary block flag if an output block wasn't explicitly
     1658     6021                requested for the node, and reset the flag if the block was
     1659     6022                explicitly requested (since this block could be a temporary
     1660     6023                block created for a subnode).
     1661     6024        */
     1662     6025    2           IF P$NODE.O_F = '1'B THEN
     1663     6026    2               BLK$->OUT$BLK.TEMP = '0'B;
     1664     6027    2           ELSE
     1665     6028    2               BLK$->OUT$BLK.TEMP = '1'B;
     1666     6029        /*D*
     1667     6030            o   Fill in remaining output block fields.
     1668     6031        */
     1669     6032    2           BLK$->OUT$BLK.CPOS = SAVEPOS+G$D.CNTUPOS;
     1670     6033    2           CALL OUTBLK_COMMON;
     1671     6034    2       END;
     1672     6035        /*D*
     1673     6036            Do common success processing. (Call the success exit routine if
     1674     6037            necessary, and push the new block, if any, on to the parse stack).
     1675     6038        */
     1676     6039    1       CALL SUCCEED_BLK;
     1677     6040    2       DO CASE (I);
     1678     6041    2       CASE (1);   /* success routine returned REJECT */
     1679     6042    2           GOTO SYNFAIL1;
     1680     6043    2       CASE (2);   /* success routine returned RETRY */
     1681     6044    2           GOTO REPARSE;
     1682     6045    2       END;
     1683     6046        /*D*
     1684     6047            If this is a repeating node, go back to try to parse another
     1685     6048            repetition (but, if this repetition managed to succeed without
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:103  
     1686     6049            advancing the position within the command, fail instead, to avoid
     1687     6050            an infinite loop).
     1688     6051        */
     1689     6052    1       IF REPEAT THEN
     1690     6053    2       DO;
     1691     6054    2           IF SAVEPOS~=G$D.CCPOS-G$D.CNTUPOS THEN
     1692     6055    2               GOTO REPARSE;
     1693     6056    2           BLK$=ADDR(NIL);
     1694     6057    2           GOTO SYNFAIL1;
     1695     6058    2       END;
     1696     6059        /*D*
     1697     6060            If this node could have reducing alternatives under it, release
     1698     6061            any R$BLK flag blocks that were created for this node.
     1699     6062        */
     1700     6063    1   ENDSUC:
     1701     6064    1       IF RDUCE$ ~= ADDR(G$D) THEN
     1702     6065    1           CALL RELRED;
     1703     6066        /*D*
     1704     6067            That's it!  Return normally to indicate a successful parse.
     1705     6068        */
     1706     6069    1       RETURN;
     1707     6070        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:104  
     1708     6071        /*D*
     1709     6072            Failure Processing:
     1710     6073
     1711     6074                Control transfers to this point when a node cannot be
     1712     6075                successfully parsed.  The same failure processing logic
     1713     6076                is used for "syntactic" and "lexical" nodes, although
     1714     6077                some parts of it apply more to one type than the other.
     1715     6078        */
     1716     6079    1   SYNFAIL:
     1717     6080        /*D*
     1718     6081            Start by resetting the current position in the command back to
     1719     6082            what it was at the beginning of the attempted parse.
     1720     6083
     1721     6084            This is skipped if the node fails due to rejection by a user exit
     1722     6085            routine (since then the position is already reset based on what
     1723     6086            exit routine returned) or if failure is due to a repeating node
     1724     6087            succeeding without advancing the position (in which case nothing
     1725     6088            needs to be reset).
     1726     6089        */
     1727     6090    1       CALL SAVE_POS;
     1728     6091    1   SYNFAIL1:;
     1729     6092    1       REPEATABLE = '0'B;
     1730     6093        /*D*
     1731     6094            Release any output blocks created for this node (or, in the case
     1732     6095            of a repeating node, for the final attempted repetition).
     1733     6096        */
     1734     6097    1       I = (P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$)) - MY_STACK;
     1735     6098    1       CALL FREESTACK (I);
     1736     6099        /*D*
     1737     6100            If we are reparsing to get a list of legal alternative next nodes
     1738     6101            at the current point in the command, and this node is a lexeme or
     1739     6102            a literal, it needs to be on the possibility list.
     1740     6103        */
     1741     6104    1       IF P$PCB.NXT AND NOT P$PCB.NXT_SZONLY AND G$D.CCPOS = P$PCB.HI_CHAR
     1742     6105    1         AND (P$NODE.TYPE = %TYPE_LITERAL# OR P$NODE.TYPE = %TYPE_LEXEME#)
     1743     6106    1       THEN
     1744     6107    2   POSSIBLE_NODE: DO;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:105  
     1745     6108        /*D*
     1746     6109            o   First scan the existing list to make sure this node isn't a duplicate:
     1747     6110        */
     1748     6111    2           P$ = PINCRW(P$PCB.WORK$, P$PCB.WK_USED);
     1749     6112    2           I = POSS.COUNT - 1;
     1750     6113    3           DO WHILE (I >= 0);
     1751     6114    3               Q$ = POSS.NODES$(I);
     1752     6115        /*D*
     1753     6116            o       If this node is already on the list, it's obviously a duplicate.
     1754     6117        */
     1755     6118    3               IF Q$ = NODE$
     1756     6119    3               THEN
     1757     6120    3                   EXIT POSSIBLE_NODE;
     1758     6121        /*D*
     1759     6122            o       If the node is the same type as one already on the list,
     1760     6123                    it's a duplicate if ...
     1761     6124        */
     1762     6125    3               IF P$NODE.TYPE = Q$ -> P$NODE.TYPE
     1763     6126    3               THEN
     1764     6127    4               DO CASE (P$NODE.TYPE);
     1765     6128        /*D*
     1766     6129            o       ... it's a literal and the size, text, and minimum length
     1767     6130                        are all identical.
     1768     6131        */
     1769     6132    4               CASE (%TYPE_LITERAL#);
     1770     6133    4                   IF P$LIT.ABREV = Q$ -> P$LIT.ABREV AND
     1771     6134    4                     P$LIT.COUNT = Q$ -> P$LIT.COUNT AND
     1772     6135    4                     P$LIT.TEXT = Q$ -> P$LIT.TEXT
     1773     6136    4                   THEN
     1774     6137    4                       EXIT POSSIBLE_NODE;
     1775     6138        /*D*
     1776     6139            o       ... it's a lexeme and the lexeme types are also the same, and ...
     1777     6140        */
     1778     6141    4               CASE (%TYPE_LEXEME#);
     1779     6142    4                   IF P$SYM.LEXTYPE = Q$ -> P$SYM.LEXTYPE
     1780     6143    4                   THEN
     1781     6144    5                   DO CASE (P$SYM.LEXTYPE);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:106  
     1782     6145        /*D*
     1783     6146            o           ... it's a BLANK or END lexeme.
     1784     6147        */
     1785     6148    5                   CASE (%LEX_BLANK#, %LEX_END#);
     1786     6149    5                       EXIT POSSIBLE_NODE;
     1787     6150        /*D*
     1788     6151            o           ... it's a DSTRING and the delimiters and maximum lengths
     1789     6152                            are also the same.
     1790     6153        */
     1791     6154    5                   CASE (%LEX_DSTRING#);
     1792     6155    5                       IF P$DSTR.MAXL = Q$ -> P$DSTR.MAXL
     1793     6156    5                         AND P$DSTR.DLIM = Q$ -> P$DSTR.DLIM
     1794     6157    5                       THEN
     1795     6158    5                           EXIT POSSIBLE_NODE;
     1796     6159        /*D*
     1797     6160            o           ... it's some other lexeme and the maximum lengths and
     1798     6161                            extra character sets are also the same.
     1799     6162        */
     1800     6163    5                   CASE (ELSE);
     1801     6164    5                       IF P$SYM.XTRA
     1802     6165    5                       THEN
     1803     6166    5                           IF Q$ -> P$SYM.XTRA
     1804     6167    5                           THEN
     1805     6168    5                               IF P$SYM.MAXL = Q$ -> P$SYM.MAXL AND
     1806     6169    5                                 P$SYM.COUNT = Q$ -> P$SYM.COUNT AND
     1807     6170    5                                 P$SYM.TEXT = Q$ -> P$SYM.TEXT
     1808     6171    5                               THEN
     1809     6172    5                                   EXIT POSSIBLE_NODE;
     1810     6173    5                               ELSE;
     1811     6174    5                           ELSE;
     1812     6175    5                       ELSE
     1813     6176    5                           IF NOT Q$ -> P$SYM.XTRA
     1814     6177    5                           THEN
     1815     6178    5                               EXIT POSSIBLE_NODE;
     1816     6179    5                   END /* do case p$sym.lextype */;
     1817     6180    4               END /* do case p$node.type */;
     1818     6181    3               I = I - 1;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:107  
     1819     6182    3           END /* do while (i >= 0) */;
     1820     6183        /*D*
     1821     6184            o   If this isn't a duplicate, expand the work area if there isn't
     1822     6185                enough room to add to the possibility list.
     1823     6186        */
     1824     6187    2           IF ADDR(POSS.NODES$(POSS.COUNT+1)) >= G$D.STACKTOP$
     1825     6188    2           THEN
     1826     6189    2               CALL EXPAND_WORKAREA;
     1827     6190        /*D*
     1828     6191            o   Add this node to the list and bump the list count.
     1829     6192        */
     1830     6193    2           POSS.NODES$(POSS.COUNT) = NODE$;
     1831     6194    2           POSS.COUNT = POSS.COUNT + 1;
     1832     6195    2       END POSSIBLE_NODE;
     1833     6196        /*D*
     1834     6197            Failure processing is entered at this point if a node is failed
     1835     6198            due to rejection by a preprocessing user exit routine.
     1836     6199        */
     1837     6200    1   NONXT: ;
     1838     6201        /*D*
     1839     6202            If this is a repeating node (and at least one repetition has been
     1840     6203            successfully parsed), failure doesn't mean the node has failed, it
     1841     6204            just means there are no more repetitions.  So, go to syntactic
     1842     6205            success processing to build the output block for the node, having
     1843     6206            the nodes built by all successful repetitions as subblocks.
     1844     6207        */
     1845     6208    1       IF REPEAT THEN
     1846     6209    2       DO;
     1847     6210    2           MY_STACK = RP_STACK;
     1848     6211    2           REPEAT = '0'B;
     1849     6212    2           GOTO RPEATSUC;
     1850     6213    2       END;
     1851     6214        /*D*
     1852     6215            If this node is optional, failing to parse it isn't an error, so
     1853     6216            return normally.
     1854     6217        */
     1855     6218    1       IF P$NODE.OPT THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:108  
     1856     6219    1           GOTO ENDSUC;
     1857     6220        /*D*
     1858     6221            If the node requests a user exit on failure, call the user routine.
     1859     6222        */
     1860     6223    1       IF P$NODE.F_F THEN
     1861     6224    2       DO;
     1862     6225    2           CALL USER_EXIT (%FAIL#);
     1863     6226        /*D*
     1864     6227            o   If the user routine specifies acceptance, continue as for
     1865     6228                syntactic success if there is no output block built yet for
     1866     6229                this node, or as for lexical success if there is (since only
     1867     6230                lexemes could create an output block prior to success processing,
     1868     6231                and success processing is pretty much the same for syntax
     1869     6232                nodes and lexemes that don't create a symbol block).
     1870     6233        */
     1871     6234    2           IF PARSE$PARAM.ACCEPT THEN
     1872     6235    3           DO;
     1873     6236    3               IF PARSE$PARAM.OUT$ = ADDR(NIL) THEN
     1874     6237    3                   GOTO SYNSUCCEED;
     1875     6238    3               BLK$ = PARSE$PARAM.OUT$;
     1876     6239    3               GOTO LEXSUCC2;
     1877     6240    3           END;
     1878     6241        /*D*
     1879     6242            o   If the user routine specifies a retry, go back and try the
     1880     6243                parse again.
     1881     6244        */
     1882     6245    2           IF PARSE$PARAM.RETRY THEN
     1883     6246    2               GOTO REPARSE;
     1884     6247    2       END;
     1885     6248        /*D*
     1886     6249            Release any repeating alternative blocks that might have been
     1887     6250            created under this node.
     1888     6251        */
     1889     6252    1       IF RDUCE$ ~= ADDR(G$D) THEN
     1890     6253    1           CALL RELRED;
     1891     6254        /*D*
     1892     6255            Altreturn to indicate failure to the caller.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:109  
     1893     6256        */
     1894     6257    1       ALTRETURN;
     1895     6258        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:110  
     1896     6259        /*D*
     1897     6260            Lexical Success Processing:
     1898     6261
     1899     6262                Control transfers to this point when a lexeme is successfully
     1900     6263                parsed.  Lexical success logic is used for nodes that have no
     1901     6264                subnodes, and so can only return a single output block created
     1902     6265                by this invocation of XUP$PARS.  Also, lexemes are the leaves
     1903     6266                of the parse tree, so only they can advance the current position
     1904     6267                in the command text.  If an output block is created, it will be an
     1905     6268                OUT$SYM block.
     1906     6269        */
     1907     6270    1   LEXSUCCEED:
     1908     6271        /*D*
     1909     6272            Reset position in source text to the character after the lexeme
     1910     6273            just parsed.
     1911     6274        */
     1912     6275    1       SAVEPOS=SAVEPOS+G$D.CNTUPOS;
     1913     6276        /*D*
     1914     6277            o   Reset current character to the one at the new current position
     1915     6278                (or to null at the end of the command).
     1916     6279        */
     1917     6280    1       IF G$D.CCPOS < NCHARS THEN
     1918     6281    1           G$D.CCHAR = P$PCB.TEXT$->C$BUFA(G$D.CCPOS);
     1919     6282    1       ELSE G$D.CCHAR = BINASC(0);
     1920     6283        /*D*
     1921     6284            o   If current position has advanced, indicate no white space has
     1922     6285                been skipped yet.
     1923     6286        */
     1924     6287    1       IF SAVEPOS~=G$D.CCPOS THEN G$D.BLSKIP='0'B;
     1925     6288        /*D*
     1926     6289            o   Reset lexical position before skipping whitespace, so that a
     1927     6290                syntactic RTEXT node including this one won't include any
     1928     6291                following whitespace.
     1929     6292        */
     1930     6293    1       G$D.CLEXPOS = G$D.CCPOS;
     1931     6294        /*D*
     1932     6295            o   Eat any whitespace following the lexeme, unless the node
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:111  
     1933     6296                doesn't allow any.
     1934     6297        */
     1935     6298    1       IF P$SYM.SKBL THEN
     1936     6299    1           CALL CHK_CONTUE;
     1937     6300        /*D*
     1938     6301            Lexical success is entered at this point after an explicit blank
     1939     6302            lexeme is parsed, since it does its own position resetting.
     1940     6303        */
     1941     6304    1   BLANKSUCC:;
     1942     6305        /*D*
     1943     6306            If the node requires an output block and one hasn't already been
     1944     6307            built, allocate a block with no symbol text.
     1945     6308        */
     1946     6309    1       IF P$NODE.O_F = '1'B AND BLK$ = ADDR(NIL) THEN
     1947     6310    2       DO;
     1948     6311    2           COUNT = 3;
     1949     6312    2           CALL XUP$GETSPACE(COUNT,Q$,G$D);
     1950     6313    2           BLK$ = Q$;
     1951     6314    2           BLK$->OUT$BLK.NSUBLKS = 0;
     1952     6315    2           BLK$->OUT$BLK.CPOS = SAVEPOS;
     1953     6316    2       END;
     1954     6317        /*D*
     1955     6318            If there is an output block for this node, fill in common fields.
     1956     6319        */
     1957     6320    1       IF BLK$ ~= ADDR(NIL) THEN
     1958     6321    2       DO;
     1959     6322    2           BLK$->OUT$BLK.CPOS = SAVEPOS;
     1960     6323    2           CALL OUTBLK_COMMON;
     1961     6324    2       END;
     1962     6325    1   LEXSUCC2:
     1963     6326        /*D*
     1964     6327            Do common success processing. (Call the success exit routine if
     1965     6328            necessary, and push the new block, if any, on to the parse stack).
     1966     6329        */
     1967     6330    1       CALL SUCCEED_BLK;
     1968     6331    2       DO CASE (I);
     1969     6332    2       CASE (1);   /* success routine returned REJECT */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:112  
     1970     6333    2           GOTO SYNFAIL1;
     1971     6334    2       CASE (2);   /* success routine returned RETRY */
     1972     6335    2           GOTO REPARSE;
     1973     6336    2       END;
     1974     6337        /*D*
     1975     6338            If parsing this lexeme takes us beyond the last high-water mark
     1976     6339            in the command text, save the new high position in the PCB.
     1977     6340        */
     1978     6341    1       IF G$D.CCPOS > P$PCB.HI_CHAR AND NOT P$PCB.NXT THEN
     1979     6342    2       DO;
     1980     6343    2           P$PCB.HI_CHAR = G$D.CCPOS;
     1981     6344    2           P$PCB.HINODE$ = ADDR(P$NODE);
     1982     6345    2       END;
     1983     6346        /*D*
     1984     6347            If this is a repeating node, go back to try to parse another
     1985     6348            repetition (but, if this repetition managed to succeed without
     1986     6349            advancing the position within the command, fail instead, to avoid
     1987     6350            an infinite loop).
     1988     6351        */
     1989     6352    1       IF REPEATABLE THEN
     1990     6353    2       DO;
     1991     6354    2           REPEAT = '1'B;
     1992     6355    2           IF SAVEPOS~=G$D.CCPOS THEN
     1993     6356    2               GOTO REPARSE;
     1994     6357    2           BLK$=ADDR(NIL);
     1995     6358    2           GOTO SYNFAIL1;
     1996     6359    2       END;
     1997     6360        /*D*
     1998     6361            That's it!  Return normally to indicate a successful parse to the caller.
     1999     6362        */
     2000     6363    1       RETURN;
     2001     6364        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:113  
     2002     6365        /*D*
     2003     6366            Error processing:
     2004     6367
     2005     6368                Errors (other than syntax errors) abort the parse by unwinding
     2006     6369                back to X$PARSE after saving the error code and current
     2007     6370                position in the PCB.
     2008     6371        */
     2009     6372
     2010     6373    1   CANT_RETURN_TEXT:
     2011     6374    1       P$PCB.ERROR = CANT_RTEXT;
     2012     6375    1       P$PCB.HI_CHAR = G$D.CCPOS;
     2013     6376    1       UNWIND TO G$D.ERROR;
     2014     6377
     2015     6378        /*E*    ERROR: XUP-E$CANT_RTEXT
     2016     6379                MESSAGE: Can't return node text - it has been overwritten.
     2017     6380                MESSAGE1: The "RTEXT" option of one of your nodes could not be honored.
     2018     6381                          Either part of your text string has been overwritten by your
     2019     6382                          command-continuation routine, or the "current character
     2020     6383                          position" has been modified in a strange fashion.  In either
     2021     6384                          case, X$PARSE can't figure out what text should be returned.
     2022     6385        */
     2023     6386
     2024     6387    1   RTEXT_TOO_LONG:
     2025     6388    1       P$PCB.ERROR = RTEXT_GT_511;
     2026     6389    1       P$PCB.HI_CHAR = G$D.CCPOS;
     2027     6390    1       UNWIND TO G$D.ERROR;
     2028     6391
     2029     6392        /*E*    ERROR: XUP-E$RTEXT_GT_511
     2030     6393                MESSAGE: Node text too long to return.
     2031     6394                MESSAGE1: The "RTEXT" option of one of your nodes could not be honored.
     2032     6395                          The portion of your input string which was accepted by this
     2033     6396                          node is longer than 511 characters, and cannot fit into
     2034     6397                          a parse output block.
     2035     6398        */
     2036     6399        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:114  
     2037     6400        /*I*
     2038     6401            NAME: RELRED
     2039     6402            PURPOSE: Release reducing alternative flag blocks.
     2040     6403            INPUT:
     2041     6404                G$D.REDUCE$ = root of R$BLK list for this node (NIL if none).
     2042     6405                RDUCE$ = root of R$BLK list for next higher level node.
     2043     6406            OUTPUT:
     2044     6407                G$D.RDUCE$ = copy of RDUCE$ on entry
     2045     6408                RDUCE$ = trash
     2046     6409            DESCRIPTION:
     2047     6410                This routine is called for any node that could have reducing
     2048     6411                alternative subnodes.  It releases any reducing alternative
     2049     6412                flag blocks (R$BLKs) that have been allocated since parsing
     2050     6413                for this node was initiated, and restores the R$BLK list root
     2051     6414                to what it was on entry.
     2052     6415        */
     2053     6416    1   RELRED:
     2054     6417    1       PROC;
     2055     6418    2       P$ = G$D.REDUCE$;
     2056     6419    2       G$D.REDUCE$ = RDUCE$;
     2057     6420    3       DO WHILE(P$ ~= ADDR(NIL));
     2058     6421    3           RDUCE$ = P$;
     2059     6422    3           P$ = P$->R$BLK.FLINK$;
     2060     6423    3           CALL XUP$FREESPACE(RDUCE$,G$D);
     2061     6424    3       END;
     2062     6425    2       RETURN;
     2063     6426    2   END   RELRED;
     2064     6427        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:115  
     2065     6428        /*I*
     2066     6429            NAME: CHK_CONTINUE
     2067     6430            PURPOSE: Eat any whitespace at the current position.
     2068     6431            CALL:
     2069     6432                CALL CHK_CONTINUE;
     2070     6433            INPUT:
     2071     6434                G$D.CCPOS -- current position in command text
     2072     6435                G$D.CCHAR, CURCHAR -- character at current position
     2073     6436            OUTPUT:
     2074     6437                G$D.BLSKIP -- set if any whitespace was skipped
     2075     6438                G$D.CCPOS, G$D.CCHAR, CURCHAR -- reset if whitespace was skipped
     2076     6439            INTERFACE:
     2077     6440                CHK_COMMENT, ADVCHAR called to eat comments and blanks, respectively.
     2078     6441                USER_EXIT called to get continuation lines, if needed
     2079     6442                SETCHAR called to reset current position variables.
     2080     6443            DESCRIPTION:
     2081     6444                This routine is called whenever whitespace can appear in the
     2082     6445                command text.  Whitespace can be blanks, comments, command line
     2083     6446                continuations, or any combination of these.  Any whitespace in
     2084     6447                the command, starting at the current character position, is
     2085     6448                skipped, and the various variables that control command position
     2086     6449                and blank skip status are reset accordingly.
     2087     6450        */
     2088     6451    1   CHK_CONTUE:
     2089     6452    1       PROC;
     2090     6453        /*D*
     2091     6454            Loop for as long as some sort of whitespace is found.
     2092     6455        */
     2093     6456    3       DO WHILE('1'B);
     2094     6457        /*D*
     2095     6458                First try to scan over a comment starting at the current position.
     2096     6459        */
     2097     6460    3           CALL CHK_COMMENT(G$D.CCPOS);
     2098     6461        /*D*
     2099     6462                If the command can be continued and the current character is
     2100     6463                a semicolon, it might be a continuation mark.
     2101     6464        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:116  
     2102     6465    3           IF G$D.CCHAR = ';'
     2103     6466    3             AND P$PCB.CONTINUE
     2104     6467    4             AND P$PCB.U$$ ~= ENTADDR(NIL) THEN DO;
     2105     6468        /*D*
     2106     6469                Semicolons are only continuation marks if they are followed by
     2107     6470                nothing but whitespace.  So, before reading a continuation
     2108     6471                line, scan the rest of the command line to see if it contains
     2109     6472                anything else.  This is done without advancing G$D.CCPOS, so
     2110     6473                that the position doesn't need to be reset if something else
     2111     6474                is found.
     2112     6475        */
     2113     6476    4               J = G$D.CCPOS + 1;
     2114     6477        /*D*
     2115     6478                o   First eat any blanks after the semicolon.  If this takes
     2116     6479                    us to the end of the line, we're ready to read try to
     2117     6480                    read a continuation line.
     2118     6481        */
     2119     6482    5               DO WHILE(J < NCHARS);
     2120     6483    6                   DO WHILE(P$PCB.TEXT$->C$BUFA(J) = ' ');
     2121     6484    6                       J = J + 1;
     2122     6485    6                       IF J = NCHARS THEN
     2123     6486    6                           GOTO CONTUE_GO;
     2124     6487    6                   END;
     2125     6488        /*D*
     2126     6489                o   If something other than blanks follow the semicolon, see
     2127     6490                    if it's a comment, and, if it is, go back to eat more
     2128     6491                    blanks, unless the comment takes us to the end of the
     2129     6492                    line.  Otherwise, the semicolon isn't a continuation
     2130     6493                    mark, so return without advancing past it.
     2131     6494        */
     2132     6495    5                   COUNT = J;
     2133     6496    5                   CALL CHK_COMMENT(J) ALTRET(CONTUE_GO);
     2134     6497    5                   IF COUNT = J THEN
     2135     6498    5                       GOTO CHK_BLK;
     2136     6499    5               END;
     2137     6500        /*D*
     2138     6501                Get a continuation line if a continuation mark is found:
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:117  
     2139     6502        */
     2140     6503    4   CONTUE_GO:
     2141     6504        /*D*
     2142     6505                o   Save current command text base address and position, for
     2143     6506                    use in recomputing the position once the new line is read.
     2144     6507        */
     2145     6508    4               J=G$D.CCPOS;
     2146     6509    4               P$=P$PCB.TEXT$;
     2147     6510    4               P$PCB.TEXT$->C$BUFA(G$D.CCPOS) = ' ';
     2148     6511        /*D*
     2149     6512            o   Call the user exit routine to read the continuation line.
     2150     6513        */
     2151     6514    4               CALL USER_EXIT (%INPUT#);
     2152     6515        /*D*
     2153     6516            o   Reset the position in the command text based on what the user
     2154     6517                routine returned.
     2155     6518        */
     2156     6519    4               P$PCB.HI_CHAR=G$D.CCPOS;
     2157     6520    4               G$D.BLSKIP='1'B;
     2158     6521    4               J=G$D.CCPOS-J+POFFC(P$PCB.TEXT$,P$);
     2159     6522    4               G$D.CNTUPOS=G$D.CNTUPOS+J;
     2160     6523    4           END;
     2161     6524        /*D*
     2162     6525                If, after eating any comment, the current character is neither
     2163     6526                a continuation mark nor a blank, there is no more whitespace
     2164     6527                at this point.
     2165     6528        */
     2166     6529    3           ELSE CHK_BLK: IF G$D.CCHAR~=' ' THEN RETURN;
     2167     6530        /*D*
     2168     6531                Otherwise, eat any blanks at the current position, and loop
     2169     6532                until there is no more whitespace.
     2170     6533        */
     2171     6534    4           DO WHILE(G$D.CCHAR = ' ');
     2172     6535    4               G$D.BLSKIP = '1'B;
     2173     6536    4               CALL ADVCHAR;
     2174     6537    4           END;
     2175     6538    3       END;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:118  
     2176     6539    2   END CHK_CONTUE;
     2177     6540        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:119  
     2178     6541        /*I*
     2179     6542            NAME: CHKCHAR
     2180     6543            PURPOSE: See if the current character is legal for a lexeme.
     2181     6544            CALL:
     2182     6545                CALL CHKCHAR ALTRET(illegal_char);
     2183     6546            INPUT:
     2184     6547                P$ = points to lexeme node being parsed
     2185     6548                CURCHAR = character to be checked
     2186     6549            DESCRIPTION:
     2187     6550                This routine checks whether the current character is legal for
     2188     6551                the lexeme being parsed.  It returns normally if the character
     2189     6552                is legal, otherwise it altreturns.
     2190     6553
     2191     6554                Most character validation is done via a table (SYMTBL) defined
     2192     6555                in XU_DATA_D that contains a word per ASCII character, each of
     2193     6556                which contains a bit flag for each lexeme that is set if the
     2194     6557                corresponding character is legal for that lexeme.
     2195     6558
     2196     6559                Some lexemes must begin with a specific character or contain
     2197     6560                at least one character from a subset of legal characters; the
     2198     6561                VALIDSYM flag word is used to control special checks for these
     2199     6562                lexemes.
     2200     6563
     2201     6564                If the character isn't legal according to the table, it still
     2202     6565                might be legal if the lexeme has an extra legal-character list
     2203     6566                and the character is in the list.  Note that the flag indicating
     2204     6567                the presence of this list is only present in P$SYM nodes, so
     2205     6568                this routine can only be called for nodes that are defined
     2206     6569                using that structure.
     2207     6570        */
     2208     6571    1   CHKCHAR:
     2209     6572    1       PROC ALTRET;
     2210     6573            %P$SYM(STCLASS="BASED(P$)", LEN="P$SYM.COUNT");
     2211     6652    2   DCL J SBIN;
     2212     6653        /*
     2213     6654                If the character is a 7-bit ASCII code, first try looking it
     2214     6655                up in the legal character table.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:120  
     2215     6656        */
     2216     6657    2       IF NOT ASCBIT(CURCHAR)&'600'O THEN
     2217     6658    3       DO CASE(P$SYM.LEXTYPE);
     2218     6659
     2219     6660    3       CASE(%LEX_NULL#,
     2220     6661    3         %LEX_ASYM#);
     2221     6662
     2222     6663    3       CASE(%LEX_OCTAL#);
     2223     6664    3           IF SYMTTBL.OCT(ASCBIN(CURCHAR)) THEN
     2224     6665    3               RETURN;
     2225     6666
     2226     6667    3       CASE(%LEX_DECIMAL#);
     2227     6668    3           IF SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN
     2228     6669    3               RETURN;
     2229     6670
     2230     6671    3       CASE(%LEX_ALPHA#);
     2231     6672    3           IF SYMTTBL.ALPHA(ASCBIN(CURCHAR)) THEN
     2232     6673    3               RETURN;
     2233     6674
     2234     6675    3       CASE(%LEX_ANUMERIC#);
     2235     6676    3           IF SYMTTBL.ALNUM(ASCBIN(CURCHAR)) THEN
     2236     6677    4           DO;
     2237     6678    4               IF NOT SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN
     2238     6679    4                   VALIDSYM = 1;
     2239     6680    4               RETURN;
     2240     6681    4           END;
     2241     6682
     2242     6683    3       CASE(%LEX_SYMBOL#);
     2243     6684    3           IF SYMTTBL.SYM(ASCBIN(CURCHAR)) THEN
     2244     6685    4           DO;
     2245     6686    4               IF NOT SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN
     2246     6687    4                   VALIDSYM = 1;
     2247     6688    4               RETURN;
     2248     6689    4           END;
     2249     6690
     2250     6691    3       CASE(%LEX_PL6SYM#);
     2251     6692    3           IF SYMTTBL.PL6SYM(ASCBIN(CURCHAR)) THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:121  
     2252     6693    3               IF VALIDSYM ~= 0 THEN RETURN;
     2253     6694    3               ELSE IF SYMTTBL.ALPHA(ASCBIN(CURCHAR)) THEN
     2254     6695    4                   DO;
     2255     6696    4                       VALIDSYM = 1;
     2256     6697    4                       RETURN;
     2257     6698    4                   END;
     2258     6699
     2259     6700    3       CASE(%LEX_FID#);
     2260     6701    3           IF SYMTTBL.FID(ASCBIN(CURCHAR)) THEN
     2261     6702    3               RETURN;
     2262     6703
     2263     6704    3       CASE (%LEX_ACCOUNT#);
     2264     6705    3           IF SYMTTBL.ACCOUNT(ASCBIN(CURCHAR))
     2265     6706    3           THEN
     2266     6707    3               RETURN;
     2267     6708
     2268     6709    3       CASE (%LEX_HEX#);
     2269     6710    3           IF SYMTTBL.HEX(ASCBIN(CURCHAR))
     2270     6711    3           THEN
     2271     6712    3               RETURN;
     2272     6713
     2273     6714    3       CASE (%LEX_JOBNAME#);
     2274     6715    3           IF SYMTTBL.JOBNAME(ASCBIN(CURCHAR))
     2275     6716    3           THEN
     2276     6717    3               RETURN;
     2277     6718
     2278     6719    3       END;
     2279     6720
     2280     6721        /*
     2281     6722                If the character isn't listed as legal in the table, and the
     2282     6723                lexeme has an extra legal-character list, see if the character
     2283     6724                is in the list.
     2284     6725        */
     2285     6726    2       IF P$SYM.XTRA THEN
     2286     6727    3       DO;
     2287     6728    3           CALL INDEX(J,CURCHAR,P$SYM.TEXT)
     2288     6729    3             ALTRET(NOTSYM);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:122  
     2289     6730    3           VALIDSYM = 1;
     2290     6731    3           RETURN;
     2291     6732    3       END;
     2292     6733
     2293     6734        /*
     2294     6735                If neither of the above tests succeed, altreturn to indicate
     2295     6736                an illegal character.
     2296     6737        */
     2297     6738    2   NOTSYM: ;
     2298     6739    2       ALTRETURN;
     2299     6740    2   END   CHKCHAR;
     2300     6741        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:123  
     2301     6742        /*I*
     2302     6743            NAME: PARS_SUBND
     2303     6744            PURPOSE: Recursively call XUP$PARS to parse a subnode.
     2304     6745            CALL:
     2305     6746                CALL PARS_SUBND ALTRET (parse-failed);
     2306     6747            INPUT:
     2307     6748                NODE$ -- address of current node
     2308     6749                I -- index of subnode to be parsed
     2309     6750            OUTPUT:
     2310     6751                On normal return, any output blocks and parse stack entries
     2311     6752                created for the subnode exist, and the position in the command
     2312     6753                text has been updated.  On altreturn, everything is (logically)
     2313     6754                the same as it was on entry.
     2314     6755            DESCRIPTION:
     2315     6756                This routine attempt to parse the specified subnode of the
     2316     6757                current node.
     2317     6758        */
     2318     6759    1   PARS_SUBND: PROC ALTRET;
     2319     6760
     2320     6761    2       G$D.NODE$ = P$NODE.SUBNDS$(I);
     2321     6762
     2322     6763        /*D*
     2323     6764                If the subnode to parse is the same node as the current node,
     2324     6765                and the current position hasn't advanced past what it was on
     2325     6766                entry to the parse of the current node, fail the parse without
     2326     6767                attempting the recursive call, to avoid an infinite loop.
     2327     6768        */
     2328     6769    2       IF G$D.NODE$ = NODE$
     2329     6770    2         AND SAVEPOS = G$D.CCPOS - G$D.CNTUPOS
     2330     6771    2       THEN
     2331     6772    2           ALTRETURN;
     2332     6773
     2333     6774        /*D*
     2334     6775                Attempt to parse the subnode.  Return normally or altreturn,
     2335     6776                according to how the subnode parse attempt returns.
     2336     6777        */
     2337     6778    2       CALL XUP$PARS (G$D) ALTRET (FAIL);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:124  
     2338     6779    2       RETURN;
     2339     6780
     2340     6781    2   FAIL: ;
     2341     6782    2       ALTRETURN;
     2342     6783
     2343     6784    2   END PARS_SUBND;
     2344     6785        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:125  
     2345     6786        /*I*
     2346     6787            NAME: ADVCHAR
     2347     6788            PURPOSE: Advance the current position in the command.
     2348     6789            CALL:
     2349     6790                CALL ADVCHAR;
     2350     6791            INPUT:
     2351     6792                G$D.CCHAR -- current position in command
     2352     6793            OUTPUT:
     2353     6794                G$D.CCHAR -- new position in command
     2354     6795                G$D.CCHAR, CURCHAR -- set to character at new position
     2355     6796            DESCRIPTION:
     2356     6797                This routine is called from CHK_CONTINUE if the current character
     2357     6798                is blank.  It bumps the current position, and eats any comment
     2358     6799                starting at that position.
     2359     6800        */
     2360     6801    1   ADVCHAR:
     2361     6802    1       PROC;
     2362     6803        /*
     2363     6804            ***       BEGIN PROCEDURE
     2364     6805        */
     2365     6806    2   RETRY: IF G$D.CCPOS < NCHARS - 1 THEN
     2366     6807    3       DO;
     2367     6808    3           G$D.CCPOS = G$D.CCPOS + 1;
     2368     6809    3           CALL CHK_COMMENT(G$D.CCPOS) ALTRET(NOMORETXT);
     2369     6810    3   STCHAR: ;
     2370     6811    3           CURCHAR = P$PCB.TEXT$->C$BUFA(G$D.CCPOS);
     2371     6812    3           G$D.CCHAR = CURCHAR;
     2372     6813    3           RETURN;
     2373     6814    3       END;
     2374     6815    2       GOTO NOMORETXT;
     2375     6816
     2376     6817        /*I*
     2377     6818            NAME: SAVE_POS
     2378     6819            PURPOSE: Reset position in command after failure.
     2379     6820            CALL:
     2380     6821                CALL SAVE_POS;
     2381     6822            INPUT:
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:126  
     2382     6823                SAVEPOS, SAVELEX, SKIPBL -- fallback values of correspoinding G$D fields
     2383     6824            OUTPUT:
     2384     6825                G$D.CCPOS, G$D.CLEXPOS, G$D.SKIPBL -- reset to fallback values
     2385     6826                G$D.CCHAR, CURCHAR -- reset to character at fallback position
     2386     6827            DESCRIPTION:
     2387     6828                This routine is called when an attempted parse fails.  It sets
     2388     6829                the current position in the command text back to what it was
     2389     6830                before the parse was attempted.
     2390     6831        */
     2391     6832    2   SAVE_POS: ENTRY;
     2392     6833    2       G$D.CCPOS=SAVEPOS+G$D.CNTUPOS;
     2393     6834    2       G$D.CLEXPOS = SAVELEX + G$D.CNTUPOS;
     2394     6835    2       G$D.BLSKIP=SKIPBL;
     2395     6836
     2396     6837        /*I*
     2397     6838            NAME: SET_CHAR
     2398     6839            PURPOSE: Reset the position in the command after a user exit.
     2399     6840            CALL:
     2400     6841                CALL SET_CHAR
     2401     6842            INPUT:
     2402     6843                P$PCB.NCHARS -- number of characters in the command text.
     2403     6844                G$D.CCPOS -- current position in command.
     2404     6845            OUTPUT:
     2405     6846                NCHARS -- reset to P$PCB.NCHARS
     2406     6847                G$D.CCHAR, CURCHAR -- set to character at current position.
     2407     6848            DESCRIPTION:
     2408     6849                This routine is called after an exit to the user routine to
     2409     6850                reset the command size and current character, in case the
     2410     6851                user routine changed them.
     2411     6852
     2412     6853                Note that, if CNTUPOS causes CCPOS to go negative (due to a
     2413     6854                continuation line overlaying the previous text), CCHARS is set
     2414     6855                to zero, which will cause all subsequent attempts to parse a
     2415     6856                lexeme (and therefore, anything at all) to fail.
     2416     6857        */
     2417     6858    2   SET_CHAR: ENTRY;
     2418     6859    2       NCHARS=P$PCB.NCHARS;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:127  
     2419     6860    2       IF G$D.CCPOS>=0 THEN
     2420     6861    2           IF G$D.CCPOS<NCHARS THEN GOTO STCHAR;
     2421     6862    2           ELSE
     2422     6863    2   NOMORETXT:
     2423     6864    2               G$D.CCPOS = NCHARS;
     2424     6865    2       G$D.CCHAR = BINASC(0);
     2425     6866    2       CURCHAR = BINASC(0);
     2426     6867    2       RETURN;
     2427     6868    2   END   ADVCHAR;
     2428     6869        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:128  
     2429     6870        /*I*
     2430     6871            NAME: XUP$COMCHK
     2431     6872            PURPOSE: Check for leading whitespace in the command text.
     2432     6873            CALL:
     2433     6874                CALL XUP$COMCHK (G$D) ALTRET(not-used);
     2434     6875            PARAMETERS:
     2435     6876                G$D -- Parser global data structure.
     2436     6877            INTERFACE:
     2437     6878                CHK_CONTINUE
     2438     6879            DESCRIPTION:
     2439     6880                This routine is called from X$PARSE to skip past any leading
     2440     6881                whitespace in the command being parsed.  It merely sets local
     2441     6882                variables used by CHK_CONTINUE and calls that routine.
     2442     6883        */
     2443     6884    1   XUP$COMCHK: ENTRY(G$D) ALTRET;
     2444     6885    1       PCB$=G$D.PCB$;
     2445     6886    1       NCHARS=P$PCB.NCHARS;
     2446     6887    2       IF NCHARS~=0 THEN DO;
     2447     6888    2           G$D.CCHAR=P$PCB.TEXT$->C$BUFA(0);
     2448     6889    2           NODE$=P$PCB.ROOT$;
     2449     6890    2           CALL CHK_CONTUE;
     2450     6891    2       END;
     2451     6892    1       RETURN;
     2452     6893        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:129  
     2453     6894        /*I*
     2454     6895            NAME: CHK_COMMENT
     2455     6896            PURPOSE: Skip past a comment in the command text.
     2456     6897            CALL:
     2457     6898                CALL CHK_COMMENT (INDX) ALTRET(end-of-line);
     2458     6899            PARAMETERS:
     2459     6900                INDX -- the position to check for the start of a comment.
     2460     6901            INPUT:
     2461     6902                NCHARS -- the number of characters in the command.
     2462     6903                G$D.LDCMNT -- defines the leading comment delimiter.
     2463     6904                G$D.TRCMNT -- defines the trailing comment delimiter.
     2464     6905            OUTPUT:
     2465     6906                G$D.BLKSIP -- set if a comment was found
     2466     6907                INDX -- points past the comment if one was found
     2467     6908            DESCRIPTION:
     2468     6909                This routine parses comments in the command text.
     2469     6910        */
     2470     6911    1   CHK_COMMENT:
     2471     6912    1       PROC(INDX) ALTRET;
     2472     6913    2   DCL     INDX  UBIN  WORD;
     2473     6914    2   DCL     TINDX UBIN  WORD;
     2474     6915        /*D*
     2475     6916            Loop until no comment is found.
     2476     6917        */
     2477     6918    3       DO WHILE('1'B);
     2478     6919        /*D*
     2479     6920            Return if there are not enough character left to begin a comment.
     2480     6921        */
     2481     6922    3           IF NCHARS<G$D.LDCMNT.CT+INDX THEN
     2482     6923    3               RETURN;
     2483     6924        /*D*
     2484     6925            Otherwise, try to parse a leading comment delimiter.
     2485     6926            Logic to do this depends on the number of characters in the delimiter:
     2486     6927        */
     2487     6928    4           DO CASE(G$D.LDCMNT.CT);
     2488     6929        /*D*
     2489     6930            o   Null leading delimiter: there can be no comments; return.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:130  
     2490     6931        */
     2491     6932    4           CASE(0);
     2492     6933    4               RETURN;
     2493     6934        /*D*
     2494     6935            o   Single leading delimiter character:
     2495     6936                Return if the current character isn't the delimiter.
     2496     6937        */
     2497     6938    4           CASE(1);
     2498     6939    4               IF P$PCB.TEXT$->C$BUFA(INDX) ~= G$D.LDCMNT.TXA(0) THEN
     2499     6940    4                   RETURN;
     2500     6941        /*D*
     2501     6942            o   If a leading delimier is found, bump past it and look for a
     2502     6943                trailing delimiter.
     2503     6944        */
     2504     6945    4   FIND_TRCMNT: INDX = INDX+1;
     2505     6946        /*D*
     2506     6947            o       If there are not enough character left for a trailing
     2507     6948                    delimiter, the comment continues to the end of the line.
     2508     6949        */
     2509     6950    4               IF NCHARS<G$D.TRCMNT.CT+INDX THEN
     2510     6951    4                   GOTO END_OF_TEXT;
     2511     6952        /*D*
     2512     6953            o       Otherwise, scan for the end of the comment.
     2513     6954                    Logic to do this depends on the number of characters in
     2514     6955                    the trailing delimiter:
     2515     6956        */
     2516     6957    5               DO CASE(G$D.TRCMNT.CT);
     2517     6958        /*D*
     2518     6959            o       Null trailing delimiter:
     2519     6960                    The comment extends to the end of the line.
     2520     6961        */
     2521     6962    5               CASE(0);
     2522     6963    5                   GOTO END_OF_TEXT;
     2523     6964        /*D*
     2524     6965            o       Single trailing delimiter character:
     2525     6966                    Scan the remainder of the command for the delimiter.
     2526     6967                    If found, set the character position to point past the delimiter.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:131  
     2527     6968                    Otherwise, the comment continues to the end of the line.
     2528     6969        */
     2529     6970    5               CASE(1);
     2530     6971    5                   CALL INDEX(TINDX,
     2531     6972    5                     G$D.TRCMNT.TXA(0),
     2532     6973    5                     P$PCB.TEXT$->C$BUF,
     2533     6974    5                     INDX) ALTRET(END_OF_TEXT);
     2534     6975    5                   INDX = TINDX + 1;
     2535     6976        /*D*
     2536     6977            o       Double character trailing delimiter:
     2537     6978                    Do the same as for a single character delimter, except
     2538     6979                    that the delimiter to scan for and skip is two characters.
     2539     6980        */
     2540     6981    5               CASE(2);
     2541     6982    5                   CALL INDEX(TINDX,
     2542     6983    5                     G$D.TRCMNT.TX,
     2543     6984    5                     P$PCB.TEXT$->C$BUF,
     2544     6985    5                     INDX) ALTRET(END_OF_TEXT);
     2545     6986    5                   INDX = TINDX + 2;
     2546     6987    5               END;
     2547     6988        /*D*
     2548     6989            o       If a trailing delimiter was found, and the comment being
     2549     6990                    parsed is part of the command text (i.e., we're not eating
     2550     6991                    a comment following a continuation mark), reset the current
     2551     6992                    character to the one following the comment.
     2552     6993        */
     2553     6994    4               IF INDX=G$D.CCPOS THEN
     2554     6995    4                   IF G$D.CCPOS<NCHARS THEN
     2555     6996    4                       G$D.CCHAR=P$PCB.TEXT$->C$BUFA(G$D.CCPOS);
     2556     6997    5                   ELSE DO;
     2557     6998        /*D*
     2558     6999            o       If the comment continues to the end of the line, set the
     2559     7000                    current position to the length of the line, null out the
     2560     7001                    current character, and altreturn.
     2561     7002        */
     2562     7003    5   END_OF_TEXT:        INDX = NCHARS;
     2563     7004    5                       G$D.BLSKIP='1'B;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:132  
     2564     7005    5                       G$D.CCHAR=BINASC(0);
     2565     7006    5                       ALTRETURN;
     2566     7007    5                   END;
     2567     7008        /*D*
     2568     7009            o   Double character leadiing delimiter:
     2569     7010                Process similar to a single character delimiter, except that
     2570     7011                the delimiter to check for and skip past is two characters long.
     2571     7012        */
     2572     7013    4           CASE(2);
     2573     7014    4               IF SUBSTR(P$PCB.TEXT$->C$BUF,INDX,2)~=
     2574     7015    4                 G$D.LDCMNT.TX THEN
     2575     7016    4                   RETURN;
     2576     7017    4               INDX=INDX+1;
     2577     7018    4               GOTO FIND_TRCMNT;
     2578     7019    4           END;
     2579     7020        /*D*
     2580     7021            If a comment is found, set G$D.BLSKIP to indicate that whitespace
     2581     7022            has been skipped.
     2582     7023        */
     2583     7024    3           G$D.BLSKIP='1'B;
     2584     7025    3       END;
     2585     7026    2   END CHK_COMMENT;
     2586     7027        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:133  
     2587     7028        /*I*
     2588     7029            NAME: OUTBLK_COMMON
     2589     7030            PURPOSE:
     2590     7031                Fill in common fields in output blocks.
     2591     7032            CALL:
     2592     7033                CALL OUTBLK_COMMON;
     2593     7034            INPUT:
     2594     7035                BLK$ -- points to block to be filled in.
     2595     7036        */
     2596     7037    1   OUTBLK_COMMON: PROC;
     2597     7038
     2598     7039    2       BLK$->OUT$BLK.CODE = P$NODE.CODE;
     2599     7040    2       IF P$NODE.RTEXT THEN
     2600     7041    2           BLK$ -> OUT$BLK.NDTYPE = %RTEXT#;
     2601     7042    2       ELSE
     2602     7043    3       DO CASE (P$NODE.TYPE);
     2603     7044    3       CASE (%TYPE_ALTERN#);
     2604     7045    3           BLK$ -> OUT$BLK.NDTYPE = %ALTERN#;
     2605     7046    3       CASE (%TYPE_RALTERN#);
     2606     7047    3           BLK$ -> OUT$BLK.NDTYPE = %RALTERN#;
     2607     7048    3       CASE (%TYPE_LIST#);
     2608     7049    3           BLK$ -> OUT$BLK.NDTYPE = %LIST#;
     2609     7050    3       CASE (%TYPE_KONCAT#);
     2610     7051    3           BLK$ -> OUT$BLK.NDTYPE = %KONCAT#;
     2611     7052    3       CASE (%TYPE_LITERAL#);
     2612     7053    3           BLK$ -> OUT$BLK.NDTYPE = %LITERAL#;
     2613     7054    3       CASE (%TYPE_LEXEME#);
     2614     7055    4           DO CASE (P$SYM.LEXTYPE);
     2615     7056    4           CASE (%LEX_DECIMAL#); BLK$ -> OUT$BLK.NDTYPE = %DEC#;
     2616     7057    4           CASE (%LEX_OCTAL#); BLK$ -> OUT$BLK.NDTYPE = %OCT#;
     2617     7058    4           CASE (%LEX_HEX#); BLK$ -> OUT$BLK.NDTYPE = %HEX#;
     2618     7059    4           CASE (%LEX_ALPHA#); BLK$ -> OUT$BLK.NDTYPE = %ALPHA#;
     2619     7060    4           CASE (%LEX_ANUMERIC#); BLK$ -> OUT$BLK.NDTYPE = %ALNUM#;
     2620     7061    4           CASE (%LEX_SYMBOL#); BLK$ -> OUT$BLK.NDTYPE = %SYM#;
     2621     7062    4           CASE (%LEX_PL6SYM#); BLK$ -> OUT$BLK.NDTYPE = %PL6SYM#;
     2622     7063    4           CASE (%LEX_FID#); BLK$ -> OUT$BLK.NDTYPE = %FID#;
     2623     7064    4           CASE (%LEX_ACCOUNT#); BLK$ -> OUT$BLK.NDTYPE = %ACCOUNT#;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:134  
     2624     7065    4           CASE (%LEX_JOBNAME#); BLK$ -> OUT$BLK.NDTYPE = %JOBNAME#;
     2625     7066    4           CASE (%LEX_ASYM#); BLK$ -> OUT$BLK.NDTYPE = %ASYM#;
     2626     7067    4           CASE (%LEX_NULL#); BLK$ -> OUT$BLK.NDTYPE = %NULL#;
     2627     7068    4           CASE (%LEX_BLANK#); BLK$ -> OUT$BLK.NDTYPE = %BLANK#;
     2628     7069    4           CASE (%LEX_END#); BLK$ -> OUT$BLK.NDTYPE = %EOL#;
     2629     7070    4           CASE (%LEX_DSTRING#); BLK$ -> OUT$BLK.NDTYPE = %DSTRING#;
     2630     7071    4           END;
     2631     7072    3       END;
     2632     7073    2       RETURN;
     2633     7074    2   END OUTBLK_COMMON;
     2634     7075        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:135  
     2635     7076        /*I*
     2636     7077            NAME: FREESTACK
     2637     7078            PURPOSE: Pop and release output blocks from parse stack.
     2638     7079            CALL:
     2639     7080                CALL FREESTACK (NSUBLKS);
     2640     7081            PARAMETERS:
     2641     7082                NSUBLKS -- number of parse stack blocks to free
     2642     7083            INTERFACE:
     2643     7084                XUP$FREEOUT
     2644     7085            DESCRIPTION:
     2645     7086                This routine pops the specified number of output blocks off
     2646     7087                the top of the parse stack, and releases the space consumed
     2647     7088                by them and all their subblocks.
     2648     7089        */
     2649     7090    1   FREESTACK: PROC (NSUBLKS);
     2650     7091
     2651     7092    2   DCL NSUBLKS UBIN;
     2652     7093    2   DCL I SBIN;
     2653     7094
     2654     7095    3       DO I = 0 TO NSUBLKS - 1;
     2655     7096    3           CALL XUP$FREEOUT (G$D.STACKTOP$ -> STACKARY$(I), G$D);
     2656     7097    3       END;
     2657     7098    2       G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$, NSUBLKS);
     2658     7099
     2659     7100    2       RETURN;
     2660     7101    2   END FREESTACK;
     2661     7102        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:136  
     2662     7103        /*I*
     2663     7104            NAME: SUCCEED_BLK
     2664     7105            PURPOSE: Common success processing for syntactic and lexical nodes.
     2665     7106            CALL:
     2666     7107                CALL SUCCEED_BLK;
     2667     7108            OUTPUT:
     2668     7109                I -- completion code:
     2669     7110                    0 = normal exit
     2670     7111                    1 = exit routine requested REJECT
     2671     7112                    2 = exit routine requested RETRY
     2672     7113            DESCRIPTION:
     2673     7114                This routine calls the user exit routine for successful parsing,
     2674     7115                if requested.  Then (if the exit routine doesn't force failure
     2675     7116                or a retry), it pushes the output block, if any, for the node
     2676     7117                onto the parse stack.
     2677     7118        */
     2678     7119    1   SUCCEED_BLK: PROC;
     2679     7120
     2680     7121    2       IF P$NODE.S_F = '1'B THEN
     2681     7122    3       DO;
     2682     7123    3           CALL USER_EXIT (%SUCC#);
     2683     7124    3           BLK$ = PARSE$PARAM.OUT$;
     2684     7125    3           IF PARSE$PARAM.REJECT THEN
     2685     7126    4           DO;
     2686     7127    4               I = 1;
     2687     7128    4               RETURN;
     2688     7129    4           END;
     2689     7130    3           IF PARSE$PARAM.RETRY THEN
     2690     7131    4           DO;
     2691     7132    4               I = (P$PCB.WKSZ - POFFW(G$D.STACKTOP$,P$PCB.WORK$)) - MY_STACK;
     2692     7133    4               CALL FREESTACK (I);
     2693     7134    4               I = 2;
     2694     7135    4               RETURN;
     2695     7136    4           END;
     2696     7137    3       END;
     2697     7138
     2698     7139    2       IF BLK$ ~= ADDR(NIL) THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:137  
     2699     7140    3       DO;
     2700     7141    3           G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,-1);
     2701     7142    3           IF G$D.STACKTOP$ <= G$D.HISPACE$ THEN
     2702     7143    3               CALL EXPAND_WORKAREA;
     2703     7144    3           ELSE IF P$PCB.NXT
     2704     7145    4               THEN DO;
     2705     7146    4                   P$ = PINCRW (P$PCB.WORK$, P$PCB.WK_USED);
     2706     7147    4                   IF ADDR(POSS.NODES$(POSS.COUNT+1)) >= G$D.STACKTOP$
     2707     7148    4                   THEN
     2708     7149    4                       CALL EXPAND_WORKAREA;
     2709     7150    4               END;
     2710     7151    3           G$D.STACKTOP$->STACKARY$(0) = BLK$;
     2711     7152    3       END;
     2712     7153    2       I = 0;
     2713     7154    2       RETURN;
     2714     7155
     2715     7156    2   END SUCCEED_BLK;
     2716     7157        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:138  
     2717     7158        /*I*
     2718     7159            NAME: USER_EXIT
     2719     7160            PURPOSE: Call the user exit routine.
     2720     7161            CALL:
     2721     7162                CALL USER_EXIT (TYPE) ALTRET(user-routine-altreturned);
     2722     7163            PARAMETERS:
     2723     7164                TYPE -- type code for reason exit routine is being called
     2724     7165            DESCRIPTION:
     2725     7166                This routine prepares the user exit parameter block, calls
     2726     7167                the exit routine, and resets the command size and current
     2727     7168                position in case they were changed by the user routine.
     2728     7169        */
     2729     7170    1   USER_EXIT:
     2730     7171    1       PROC (TYPE) ALTRET;
     2731     7172
     2732     7173    2   DCL       TYPE     UBIN  WORD;
     2733     7174        /*D*
     2734     7175                If there is no exit routine provided when a call to it is
     2735     7176                required, abort the parse.
     2736     7177        */
     2737     7178    2       IF P$PCB.U$$ = ENTADDR(NIL)
     2738     7179    3       THEN DO;
     2739     7180    3           P$PCB.ERROR = NULL_U$$;
     2740     7181    3           P$PCB.HINODE$ = ADDR(P$NODE);
     2741     7182    3           P$PCB.HI_CHAR = G$D.CCPOS;
     2742     7183    3           UNWIND TO G$D.ERROR;
     2743     7184    3       END;
     2744     7185        /*D*
     2745     7186                Set up parameter block for user routine.
     2746     7187        */
     2747     7188
     2748     7189    2       PARSE$PARAM = CPARAM;
     2749     7190    2       PARSE$PARAM.TYPE = TYPE;
     2750     7191    2       PARSE$PARAM.CODE = P$NODE.CODE;
     2751     7192    2       PARSE$PARAM.NODE$ = ADDR(P$NODE);
     2752     7193    2       PARSE$PARAM.OUT$ = BLK$;
     2753     7194    2       PARSE$PARAM.CHARPOS = G$D.CCPOS;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:139  
     2754     7195    2       PARSE$PARAM.GLOBAL$ = ADDR(G$D);
     2755     7196    2       PARSE$PARAM.PCB$ = G$D.PCB$;
     2756     7197    2       PARSE$PARAM.USER$ = PARSE$PARAM.PCB$->P$PCB.USER$;
     2757     7198    2       PARSE$PARAM.WKSZ = P$PCB.WKSZ;
     2758     7199        /*D*
     2759     7200                Call the user routine.  Altreturns are only relevant on calls
     2760     7201                to enlarge the work area.
     2761     7202        */
     2762     7203    2       CALL P$PCB.U$$(PARSE$PARAM)
     2763     7204    3       WHENALTRETURN DO;
     2764     7205    3           IF TYPE = %SPACE# THEN
     2765     7206    3               ALTRETURN;
     2766     7207    3       END;
     2767     7208        /*D*
     2768     7209                Reset current position in the command text in case it was
     2769     7210                altered by the user routine.
     2770     7211        */
     2771     7212    2       G$D.CCPOS = PARSE$PARAM.CHARPOS;
     2772     7213    2       CALL SET_CHAR;
     2773     7214    2       RETURN;
     2774     7215    2   END USER_EXIT;
     2775     7216        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:140  
     2776     7217        /*I*
     2777     7218            NAME: XUP$EXPAND_WORKAREA
     2778     7219            PURPOSE: Expand the parse work area.
     2779     7220            CALL:
     2780     7221                CALL XUP$EXPAND_WORKAREA (G$D) ALTRET(not-used);
     2781     7222            PARAMETERS:
     2782     7223                G$D -- the parser global data block
     2783     7224            INTERFACE:
     2784     7225                EXPAND_WORKAREA
     2785     7226            DESCRIPTION:
     2786     7227                This external entry point simply sets up local variables needed
     2787     7228                by EXPAND_WORKAREA and calls that routine.  It is called when
     2788     7229                work area expansion is needed by an external routine.
     2789     7230        */
     2790     7231    1   XUP$EXPAND_WORKAREA: ENTRY (G$D) ALTRET;
     2791     7232
     2792     7233    1       PCB$ = G$D.PCB$;
     2793     7234    1       NODE$ = G$D.NODE$;
     2794     7235
     2795     7236    1       CALL EXPAND_WORKAREA;
     2796     7237    1       RETURN;
     2797     7238
     2798     7239        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:141  
     2799     7240        /*I*
     2800     7241            NAME: EXPAND_WORKAREA
     2801     7242            PURPOSE: Expand the parse work area.
     2802     7243            CALL:
     2803     7244                CALL EXPAND_WORKAREA;
     2804     7245            DESCRIPTION:
     2805     7246                This routine is called when more space is needed in the parse
     2806     7247                work area.
     2807     7248        */
     2808     7249    1   EXPAND_WORKAREA: PROC ALTRET;
     2809     7250
     2810     7251    2   DCL BASE$ PTR;
     2811     7252    2   DCL I SBIN;
     2812     7253    2   DCL J SBIN;
     2813     7254    2   DCL K SBIN;
     2814     7255    2   DCL P$ PTR;
     2815     7256    2   DCL UBIN$WORD (0:0) UBIN BASED ALIGNED;
     2816     7257        /*D*
     2817     7258                If there is no user exit routine, or it doesn't permit dynamic
     2818     7259                expansion of the workarea, abort the parse.
     2819     7260        */
     2820     7261    2       IF P$PCB.U$$ = ENTADDR(NIL) OR NOT P$PCB.DYNMEM
     2821     7262    3       THEN DO;
     2822     7263    3   OVERFLOW:
     2823     7264    3           P$PCB.ERROR = OVER_FLOW;
     2824     7265    3           UNWIND TO G$D.ERROR;
     2825     7266    3       END;
     2826     7267
     2827     7268        /*E*    ERROR: XUP-E$WKOVERFLOW-C
     2828     7269                MESSAGE: X$PARSE needs more work area
     2829     7270                MESSAGE1:   The work area provided via the X$PARSE Control Block
     2830     7271                            is not large enough to complete the parse.
     2831     7272        */
     2832     7273
     2833     7274        /*D*
     2834     7275                Save current work area address, size, and stack size so they
     2835     7276                can be properly adjusted after the work area is expanded.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:142  
     2836     7277        */
     2837     7278    2       BASE$ = P$PCB.WORK$;
     2838     7279    2       J = P$PCB.WKSZ;
     2839     7280    2       K = J - POFFW (G$D.STACKTOP$, BASE$);
     2840     7281        /*D*
     2841     7282                Call the user exit routine to expand the work area.
     2842     7283                Abort the parse if the user routine altreturns.
     2843     7284        */
     2844     7285    2       CALL USER_EXIT (%SPACE#) ALTRET(OVERFLOW);
     2845     7286        /*D*
     2846     7287                Save the expanded work area size in the PCB.  If the routine
     2847     7288                didn't enlarge the work area, or it changed its base address,
     2848     7289                abort the parse.
     2849     7290        */
     2850     7291
     2851     7292    2       P$PCB.WKSZ = PARSE$PARAM.WKSZ;
     2852     7293
     2853     7294    2       IF P$PCB.WKSZ <= J OR P$PCB.WORK$ ~= BASE$
     2854     7295    3       THEN DO;
     2855     7296
     2856     7297    3           P$PCB.ERROR = ILLEGAL_DYNAMIC_EXPANSION;
     2857     7298    3           UNWIND TO G$D.ERROR;
     2858     7299
     2859     7300        /*E*  ERROR:   XUP-E$EXPAND_ERROR
     2860     7301              MESSAGE: Illegal expansion of parse work area.
     2861     7302              MESSAGE1: The user's U$$ routine RETURN'ed normally, indicating that the
     2862     7303                       work area in use by X$PARSE has been successfully expanded.
     2863     7304                       However, X$PARSE has determined that either (a) the size of the
     2864     7305                       work area has not been increased, or (b) the base of the work
     2865     7306                       area has been changed.  In either case, X$PARSE cannot proceed.
     2866     7307        */
     2867     7308
     2868     7309    3       END;
     2869     7310        /*D*
     2870     7311                Move the parse stack up to the end of the enlarged work area.
     2871     7312        */
     2872     7313    2       J = P$PCB.WKSZ - J;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:143  
     2873     7314    2       P$ = PINCRW (G$D.STACKTOP$, J);
     2874     7315
     2875     7316    3       DO I = K - 1 DOWNTO 0 BY -1;
     2876     7317
     2877     7318    3           P$ -> UBIN$WORD (I) = G$D.STACKTOP$ -> UBIN$WORD (I);
     2878     7319
     2879     7320    3       END;
     2880     7321
     2881     7322    2       G$D.STACKTOP$ = P$;
     2882     7323
     2883     7324    2       RETURN;
     2884     7325
     2885     7326    2   END EXPAND_WORKAREA;
     2886     7327
     2887     7328    1   END       XUP$PARS;
     2888     7329        %EOD;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:144  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   XU_DATA_R.:E05TOU  cannot be made into a system file and is referenced.
   B$TABLES_C.:E05TOU  cannot be made into a system file and is referenced.
   B_SEGIDS_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$PARS.

   Procedure XUP$PARS requires 2348 words for executable code.
   Procedure XUP$PARS requires 58 words of local(AUTO) storage.

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:145  

 Object Unit name= XUP$PARS                                   File name= XUP$PARSE.:E05TOU
 UTS= JUL 30 '97 09:37:33.36 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0  RoData even  UTS     11     13  XUP$PARS
    1   Proc  even  none  2348   4454  XUP$PARS
    2  RoData even  none    11     13  XUP$PARS

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes    yes     yes      Std        1  XUP$PARS
     1   3444          yes     yes      Std        1  XUP$COMCHK
     1   4324          yes     yes      Std        1  XUP$EXPAND_WORKAREA

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes          ~proc      0 B_POINTER
         yes          ~proc      0 XU_DATA_D
         yes           Std       3 XUP$GETSPACE
         yes           Std       2 XUP$FREESPACE
         yes           Std       2 XUP$FREEOUT
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AUNWIND
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:146  

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
r    XUP_SYMTBL                       r    B$XL_UPPER$                           BAD_NODE
     NULL_U$$                              OVER_FLOW                             CANT_RTEXT
     RTEXT_GT_511                          ILLEGAL_DYNAMIC_EXPANSION             B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     NULLSID                               ISSID
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:147  


      562        1        /*T***********************************************************/
      563        2        /*T*                                                         */
      564        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      565        4        /*T*                                                         */
      566        5        /*T***********************************************************/
      567        6        XUP$PARS:
      568        7            PROC(G$D) ALTRET;

      7  1 000000   000000 700200 xent  XUP$PARS     TSX0  ! X66_AUTO_1
         1 000001   000072 000001                    ZERO    58,1

      569        8
      570        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
      571       10        /*D*
      572       11            NAME: XUP$PARS
      573       12            CALL:
      574       13                CALL XUP$PARS (G$D) ALTRET(syntax error);
      575       14            PARAMETERS:
      576       15                G$D -- structure containing or pointing to all data needed for
      577       16                        parsing.
      578       17            INTERFACE:
      579       18                XUP$PARS (recursive calls)
      580       19                XUP$GETSPACE, XUP$FREESPACE, XUP$FREEOUT
      581       20            INPUT:
      582       21                Various information in G$D, PCB, etc.  In particlar:
      583       22                G$D.NODE$ -- point to node to attempt to parse
      584       23            OUTPUT:
      585       24                Various information in G$D, PCB, etc. updated. In particular,
      586       25                if the parse was successful, and built an output block, the
      587       26                block will be allocated in the work area, and its address will
      588       27                be on the top of the parse stack.
      589       28            DESCRIPTION:
      590       29                This routine attempts to match the source text of a command
      591       30                to the syntax specified for a given parse node.  If it can,
      592       31                it builds an output block for the node and returns normally,
      593       32                otherwise it altreturns.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:148  
      594       33        */
      595       34        %INCLUDE      B_SEGIDS_C;
      596      573        %INCLUDE B$TABLES_C;
      597      681        %INCLUDE XU_DATA_R;
      598      692        %INCLUDE      XU_MACRO_C;
      599     3798        %INCLUDE      XU_SUBS_C;
      600     3890        /*
      601     3891            ***       PARSE NODE STRUCTURES
      602     3892        */
      603     3893            %P$NODE(STCLASS="BASED(NODE$)");
      604     3987           %P$LIT(STCLASS="BASED(NODE$)", LEN="P$LIT.COUNT");
      605     4040           %P$SYM(STCLASS="BASED(NODE$)", LEN="P$SYM.COUNT");
      606     4119           %P$DSTR(STCLASS="BASED(NODE$)");
      607     4163        /*
      608     4164            ***       PARAMETER BLOCK
      609     4165        */
      610     4166        %G$D;
      611     4262        /*
      612     4263            ***       TRANSLATION TABLE
      613     4264        */
      614     4265        %B$XL_UPPER (NAME=TRANSTBL);
      615     4269        /*
      616     4270            ***       EXTERNAL PROCEDURES
      617     4271        */
      618     4272    1   DCL       XUP$FREEOUT ENTRY(2);
      619     4273    1   DCL       XUP$GETSPACE ENTRY(3);
      620     4274    1   DCL       XUP$FREESPACE ENTRY(2);
      621     4275        /*
      622     4276            ***       EXTERNAL VARIABLES (ERROR MESSAGE CODES)
      623     4277        */
      624     4278    1   DCL       BAD_NODE    BIT(36)     SYMREF;
      625     4279    1   DCL       NULL_U$$    BIT(36)     SYMREF;
      626     4280    1   DCL       OVER_FLOW      BIT(36)     SYMREF;
      627     4281    1   DCL     CANT_RTEXT   BIT (36) SYMREF;
      628     4282    1   DCL     RTEXT_GT_511 BIT (36) SYMREF;
      629     4283    1   DCL     ILLEGAL_DYNAMIC_EXPANSION BIT (36) SYMREF;
      630     4284
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:149  
      631     4285        /*
      632     4286            ***       LOCAL VARIABLES
      633     4287        */
      634     4288        /* Fields to save fallback position, to be restored in G$D on failure: */
      635     4289    1   DCL SSAVEPOS    SBIN;   /* saves G$D.CCPOS before repeats           */
      636     4290    1   DCL SAVEPOS     SBIN;   /* saves G$D.CCPOS                          */
      637     4291    1   DCL SAVELEX     SBIN;   /* saves G$D.CLEXPOS                        */
      638     4292    1   DCL SKIPBL      BIT(1); /* saves G$D.SKIPBL                         */
      639     4293
      640     4294        /* Local copies of global fields, for quick access:                 */
      641     4295    1   DCL NODE$       PTR;    /* copy of G$D.NODE$ on entry               */
      642     4296    1   DCL PCB$        PTR;    /* copy of G$D.PCB$                         */
      643     4297    1   DCL CURCHAR     CHAR(1);/* copy of G$D.CCHAR                        */
      644     4298    1   DCL NCHARS      SBIN;   /* copy of PCB.NCHARS                       */
      645     4299
      646     4300        /* Parse stack sizes, to compute number of entries added for this node: */
      647     4301    1   DCL RP_STACK    UBIN;   /* stack size on initial entry              */
      648     4302    1   DCL MY_STACK    UBIN;   /* stack size at start of latest repetition */
      649     4303    1   DCL LIST_STK    UBIN;   /* stack size at start of latest list entry */
      650     4304
      651     4305        /* General purpose variables:                                       */
      652     4306    1   DCL I           SBIN;
      653     4307    1   DCL J           SBIN;
      654     4308    1   DCL JFLAG REDEF J BIT(36);  /* for easy access to alt subnode flags */
      655     4309    1   DCL BIT36 BIT(36) BASED ALIGNED; /* and a way to use it             */
      656     4310    1   DCL K           SBIN;
      657     4311    1   DCL COUNT       SBIN;
      658     4312    1   DCL P$          PTR;
      659     4313    1   DCL Q$          PTR;
      660     4314
      661     4315        /* Other local (auto) variables:                                    */
      662     4316    1   DCL NSUBLKS     SBIN;       /* number of subblocks for current block*/
      663     4317    1   DCL VALIDSYM    UBIN;       /* flag for special lexeme validation
      664     4318                                       (set to 0 before parsing lexeme;
      665     4319                                        set to 1 when lexeme proved valid)  */
      666     4320    1   DCL BLK$        PTR;        /* addr of block for this node          */
      667     4321    1   DCL REPEAT      BIT(1);     /* flag set on for a repeating node     */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:150  
      668     4322    1   DCL REPEATABLE  BIT(1);     /* flag set if we can continue repeatin */
      669     4323    1   DCL RDUCE$      PTR;        /* saves G$D.RDUCE$ when new R$BLK list
      670     4324                                       is needed for this node              */
      671     4325    1   DCL LISTCNT     SBIN;       /* number of list elements parsed       */
      672     4326    1   DCL DLIM        CHAR(1);    /* delimiter for a DSTRING lexeme       */
      673     4327
      674     4328        /* Local based variables:                                           */
      675     4329    1   DCL C$BUF CHAR(NCHARS) BASED;   /* access command text as a string
      676     4330                                           (usually based on PCB.TEXT$)     */
      677     4331    1   DCL C$BUFA (0:0) CHAR(1) BASED; /* access command text as a char array
      678     4332                                           (usually based on PCB.TEXT$)     */
      679     4333    1   DCL STACKARY$ (0:0) PTR BASED;  /* to access the parse stack (usually
      680     4334                                           based on G$D.STACKTOP$)          */
      681     4335
      682     4336        /* Reducing alternative flag block structure:                       */
      683     4337    1   DCL 1 R$BLK BASED(P$)ALIGNED,
      684     4338    1         2 FLINK$ PTR,
      685     4339    1         2 NODE$ PTR,
      686     4340    1         2 FLAG(0:0) BIT(1);
      687     4341        /* Address for unresolved data reference in parse nodes:            */
      688     4342    1   DCL 1 ISSID_PTR CONSTANT,
      689     4343    1         2 OFFSET UBIN (24) UNAL INIT (0),
      690     4344    1         2 SEGID BIT (12) INIT (%ISSID);
      691     4345    1   DCL B$IS$ REDEF ISSID_PTR PTR;
      692     4346        /*
      693     4347            ***       OUTPUT NODE STRUCTURES
      694     4348        */
      695     4349            %PARSE$OUT;
      696     4394            %PARSE$SYM;
      697     4432        /*
      698     4433            ***       OTHER PARSER STRUCTURES
      699     4434        */
      700     4435            %PARSE_PARAM(NAME=CPARAM,STCLASS=CONSTANT);
      701     4514            %P$PCB(STCLASS="BASED(PCB$)");
      702     4715            %P$NODE(NAME=PX$NODE,STCLASS=BASED);
      703     4809            %P$LIT(NAME=PX$LIT,STCLASS=BASED);
      704     4862            %P$SYM(NAME=PX$SYM,STCLASS=BASED);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:151  
      705     4941            %P$DSTR(NAME=PX$DSTR,STCLASS=BASED);
      706     4985            %PARSE$PARAM(NAME=PARSE$PARAM,STCLASS=AUTO);
      707     5066            %XUP$POSS(NAME=POSS,STCLASS="BASED(P$)");
      708     5071        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:152  
      709     5072        /*
      710     5073            ***       BEGIN PROCEDURE
      711     5074        */
      712     5075        /*D*
      713     5076            First do initialization for this invocation:
      714     5077
      715     5078            o   Get local copy of PCB$ and NCHARS for ease of reference.
      716     5079        */
      717     5080    1       PCB$ = G$D.PCB$;

   5080  1 000002   200003 470500                    LDP0    @G$D,,AUTO
         1 000003   000000 236100                    LDQ     0,,PR0
         1 000004   200011 756100                    STQ     PCB$,,AUTO

      718     5081    1       NCHARS = P$PCB.NCHARS;

   5081  1 000005   200011 471500                    LDP1    PCB$,,AUTO
         1 000006   100011 235100                    LDA     9,,PR1
         1 000007   200013 755100                    STA     NCHARS,,AUTO

      719     5082        /*D*
      720     5083            o   A node isn't treated as repeating until at least one repetition
      721     5084                is successfully parsed.
      722     5085        */
      723     5086    1       REPEAT = '0'B;

   5086  1 000010   200030 450100                    STZ     REPEAT,,AUTO

      724     5087        /*D*
      725     5088            o   Save node address in local storage and make sure the node
      726     5089                address isn't unresolved.
      727     5090        */
      728     5091    1       NODE$=G$D.NODE$;

   5091  1 000011   000004 236100                    LDQ     4,,PR0
         1 000012   200010 756100                    STQ     NODE$,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:153  
      729     5092    1       IF NODE$ = B$IS$ OR NODE$ = ADDR(NIL)

   5092  1 000013   000000 116000 0                  CMPQ    ISSID_PTR
         1 000014   001736 600000 1                  TZE     BADNODE
         1 000015   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000016   001736 600000 1                  TZE     BADNODE

      730     5093    1       THEN
      731     5094    1           GOTO BADNODE;
      732     5095        /*D*
      733     5096            o   If the node can repeat, or it is a list, it might have subnodes
      734     5097                that are reducing alternatives.  Each such node needs a flag
      735     5098                block (R$BLK) to keep track of which alternatives have been
      736     5099                used in the node subtree under this node.
      737     5100
      738     5101                So, if this node can have its own R$BLK list, save the current
      739     5102                list pointer in local storage so it can be restored on exit,
      740     5103                and reset the global pointer to NIL to indicate no R$BLKS have
      741     5104                been allocated yet (allocation occurs when a reducing subnode
      742     5105                is processed).  Since NIL indicates an empty list, some other
      743     5106                value is needed to indicate that there is no list for this
      744     5107                node; ADDR(G$D) is used for that purpose.
      745     5108        */
      746     5109    1       IF P$NODE.TYPE = %TYPE_LIST# OR P$NODE.RPEAT = '1'B THEN

   5109  1 000017   200010 473500                    LDP3    NODE$,,AUTO
         1 000020   300000 236100                    LDQ     0,,PR3
         1 000021   700000 376003                    ANQ     -32768,DU
         1 000022   300000 116003                    CMPQ    98304,DU
         1 000023   000026 600000 1                  TZE     s:5111
         1 000024   300000 430100                    FSZN    0,,PR3
         1 000025   000033 605000 1                  TPL     s:5114

      747     5110    2       DO;

      748     5111    2           RDUCE$ = G$D.REDUCE$;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:154  
   5111  1 000026   000011 236100                    LDQ     9,,PR0
         1 000027   200032 756100                    STQ     RDUCE$,,AUTO

      749     5112    2           G$D.REDUCE$ = ADDR(NIL);

   5112  1 000030   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000031   000011 756100                    STQ     9,,PR0

      750     5113    2       END;

   5113  1 000032   000035 710000 1                  TRA     s:5120

      751     5114    1       ELSE RDUCE$=ADDR(G$D);

   5114  1 000033   200003 236100                    LDQ     @G$D,,AUTO
         1 000034   200032 756100                    STQ     RDUCE$,,AUTO

      752     5115        /*D*
      753     5116            o   Save current parse stack size; the stack will be popped up to
      754     5117                this point when the parse fails or when an output block is
      755     5118                built for a successful parse.
      756     5119        */
      757     5120    1       RP_STACK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);

   5120  1 000035   100002 236100                    LDQ     2,,PR1
         1 000036   000022 772000                    QRL     18
         1 000037   200066 756100                    STQ     TINDX+2,,AUTO
         1 000040   000010 236100                    LDQ     8,,PR0
         1 000041   000022 772000                    QRL     18
         1 000042   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 000043   200067 756100                    STQ     TINDX+3,,AUTO
         1 000044   100005 236100                    LDQ     5,,PR1
         1 000045   000022 772000                    QRL     18
         1 000046   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 000047   200014 756100                    STQ     RP_STACK,,AUTO

      758     5121    1       REPEATABLE = P$NODE.RPEAT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:155  

   5121  1 000050   300000 236100                    LDQ     0,,PR3
         1 000051   000010 736000                    QLS     8
         1 000052   400000 376003                    ANQ     -131072,DU
         1 000053   200031 756100                    STQ     REPEATABLE,,AUTO

      759     5122    1       SSAVEPOS = G$D.CCPOS-G$D.CNTUPOS;

   5122  1 000054   000013 236100                    LDQ     11,,PR0
         1 000055   000012 136100                    SBLQ    10,,PR0
         1 000056   200004 756100                    STQ     SSAVEPOS,,AUTO

      760     5123        /*D*
      761     5124            Next do initialization that must be done for each repetition of a
      762     5125            repeating node, in addition to being done on initial entry:
      763     5126
      764     5127            (Repeating nodes are unique because, instead of multiple recursive
      765     5128            calls to X$PARS to generate the subblocks of the output block for
      766     5129            this call, the subblocks are generated by looping back to this
      767     5130            point after each repetition is successfully parsed, and making the
      768     5131            blocks generated by all successful repetitions into subblocks of the
      769     5132            final output block for this call after an attempted repetition fails.)
      770     5133        */
      771     5134    1   REPARSE:
      772     5135        /*D*
      773     5136            o   Indicate no output block has been built yet.
      774     5137        */
      775     5138    1       BLK$ = ADDR(NIL);

   5138  1 000057   000001 236000 xsym  REPARSE      LDQ     B_VECTNIL+1
         1 000060   200027 756100                    STQ     BLK$,,AUTO

      776     5139        /*D*
      777     5140            o   Save current parse stack size.  The stack will be popped up
      778     5141                to this point when the attempted repetition fails, or when
      779     5142                the output block is built for a successful repetition.
      780     5143                (This value will increase by one for each repetition, to
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:156  
      781     5144                account for the output block built by the prior repetition.)
      782     5145        */
      783     5146    1       MY_STACK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);

   5146  1 000061   200011 470500                    LDP0    PCB$,,AUTO
         1 000062   000002 236100                    LDQ     2,,PR0
         1 000063   000022 772000                    QRL     18
         1 000064   200066 756100                    STQ     TINDX+2,,AUTO
         1 000065   200003 471500                    LDP1    @G$D,,AUTO
         1 000066   100010 236100                    LDQ     8,,PR1
         1 000067   000022 772000                    QRL     18
         1 000070   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 000071   200067 756100                    STQ     TINDX+3,,AUTO
         1 000072   000005 236100                    LDQ     5,,PR0
         1 000073   000022 772000                    QRL     18
         1 000074   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 000075   200015 756100                    STQ     MY_STACK,,AUTO

      784     5147        /*D*
      785     5148            o   Save current position in source text and blank skip status.
      786     5149                (Positions are biased by the number of characters lost when
      787     5150                continuation lines overlay the previous text, so that, if
      788     5151                another continuation line is read before falling back, the
      789     5152                fallback will reflect the condition after reading the continuation.)
      790     5153        */
      791     5154    1       SAVEPOS = G$D.CCPOS-G$D.CNTUPOS;

   5154  1 000076   100013 236100                    LDQ     11,,PR1
         1 000077   100012 136100                    SBLQ    10,,PR1
         1 000100   200005 756100                    STQ     SAVEPOS,,AUTO

      792     5155    1       SAVELEX = G$D.CLEXPOS - G$D.CNTUPOS;

   5155  1 000101   100014 236100                    LDQ     12,,PR1
         1 000102   100012 136100                    SBLQ    10,,PR1
         1 000103   200006 756100                    STQ     SAVELEX,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:157  
      793     5156    1       SKIPBL=G$D.BLSKIP;

   5156  1 000104   100015 236100                    LDQ     13,,PR1
         1 000105   000011 736000                    QLS     9
         1 000106   400000 376003                    ANQ     -131072,DU
         1 000107   200007 756100                    STQ     SKIPBL,,AUTO

      794     5157        /*D*
      795     5158                Get local copy of current character for quick access.
      796     5159        */
      797     5160    1       CURCHAR = G$D.CCHAR;

   5160  1 000110   100015 236100                    LDQ     13,,PR1
         1 000111   777000 376003                    ANQ     -512,DU
         1 000112   000000 276000 2                  ORQ     0
         1 000113   200012 756100                    STQ     CURCHAR,,AUTO

      798     5161        /*D*
      799     5162            o   If the node requests a user exit before attempting the parse,
      800     5163                call the exit routine.  If the routine rejects the node, go
      801     5164                directly to the failure logic, skipping the parts to release
      802     5165                accumulated output blocks (since there will be none) and to
      803     5166                add the node to the possibility list on a reparse (since nodes
      804     5167                rejected here aren't real possibilities).  A retry response is
      805     5168                treated the same as an accept response (since the node hasn't
      806     5169                been tried at all yet); both of these reset the current position
      807     5170                in the command text in case the exit routine changed it, and
      808     5171                continue on normally.
      809     5172        */
      810     5173    1       IF P$NODE.P_F = '1'B THEN

   5173  1 000114   200010 473500                    LDP3    NODE$,,AUTO
         1 000115   300000 236100                    LDQ     0,,PR3
         1 000116   040000 316003                    CANQ    16384,DU
         1 000117   000127 600000 1                  TZE     s:5186

      811     5174    2       DO;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:158  

      812     5175    2           CALL USER_EXIT (%PRE#);

   5175  1 000120   000001 236000 2                  LDQ     1
         1 000121   200057 756100                    STQ     P$+2,,AUTO
         1 000122   004224 701000 1                  TSX1    USER_EXIT
         1 000123   000000 011000                    NOP     0

      813     5176    2           IF PARSE$PARAM.REJECT THEN

   5176  1 000124   200035 236100                    LDQ     PARSE$PARAM,,AUTO
         1 000125   000200 316003                    CANQ    128,DU
         1 000126   002504 601000 1                  TNZ     NONXT

      814     5177    2               GOTO NONXT;
      815     5178    2       END;

      816     5179        /*D*
      817     5180                Fail this node if the current position in the command text is
      818     5181                negative.  (This can happen if continuation lines overlay the
      819     5182                continued text and failure to parse a node requires falling
      820     5183                back to a position that was overlaid.  All subsequent attempts
      821     5184                at parsing fail in that case.
      822     5185        */
      823     5186    1       IF G$D.CCPOS < 0 THEN GOTO SYNFAIL;

   5186  1 000127   200003 470500                    LDP0    @G$D,,AUTO
         1 000130   000013 235100                    LDA     11,,PR0
         1 000131   002240 604000 1                  TMI     SYNFAIL

      824     5187        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:159  
      825     5188        /*D*
      826     5189            Now attempt the parse.  Logic to do this depends on the node type:
      827     5190        */
      828     5191    2       DO CASE (P$NODE.TYPE);

   5191  1 000132   200010 471500                    LDP1    NODE$,,AUTO
         1 000133   100000 236100                    LDQ     0,,PR1
         1 000134   000041 772000                    QRL     33
         1 000135   000007 116007                    CMPQ    7,DL
         1 000136   000140 602006 1                  TNC     s:5191+6,QL
         1 000137   001736 710000 1                  TRA     BADNODE
         1 000140   001736 710000 1                  TRA     BADNODE
         1 000141   000147 710000 1                  TRA     s:5204
         1 000142   000147 710000 1                  TRA     s:5204
         1 000143   000477 710000 1                  TRA     s:5364
         1 000144   000457 710000 1                  TRA     s:5348
         1 000145   001544 710000 1                  TRA     s:5808
         1 000146   000571 710000 1                  TRA     s:5413

      829     5192
      830     5193        /*D*
      831     5194            ALTERNATIVE or REDUCING ALTERNATIVE node:
      832     5195
      833     5196                Loop to attempt to parse each alternative, in the order defined.
      834     5197                Successfully parsing any subnode constitutes syntactic success.
      835     5198
      836     5199                    I = subnode counter
      837     5200                    J = flag word for precheck
      838     5201        */
      839     5202    2       CASE(%TYPE_ALTERN#,

      840     5203    2         %TYPE_RALTERN#);
      841     5204    2           I = 0;

   5204  1 000147   200017 450100                    STZ     I,,AUTO

      842     5205    2           LISTCNT = P$NODE.NSUBNDS; /* MAKE THE DO WHILE QUICKER */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:160  

   5205  1 000150   100000 236100                    LDQ     0,,PR1
         1 000151   000020 772000                    QRL     16
         1 000152   000777 376007                    ANQ     511,DL
         1 000153   200033 756100                    STQ     LISTCNT,,AUTO

      843     5206    2           IF P$PCB.NXT AND G$D.CCPOS=P$PCB.HI_CHAR

   5206  1 000154   200011 473500                    LDP3    PCB$,,AUTO
         1 000155   300005 236100                    LDQ     5,,PR3
         1 000156   040000 316007                    CANQ    16384,DL
         1 000157   000167 600000 1                  TZE     s:5210
         1 000160   000013 236100                    LDQ     11,,PR0
         1 000161   000167 604000 1                  TMI     s:5210
         1 000162   300012 116100                    CMPQ    10,,PR3
         1 000163   000167 601000 1                  TNZ     s:5210

      844     5207    2           THEN
      845     5208    2               JFLAG = '752000000000'O;

   5208  1 000164   000011 236000 0                  LDQ     CPARAM+8
         1 000165   200020 756100                    STQ     J,,AUTO
         1 000166   000171 710000 1                  TRA     s:5211

      846     5209    2           ELSE
      847     5210    2               JFLAG = '052000000000'O;

   5210  1 000167   000012 236000 0                  LDQ     CPARAM+9
         1 000170   200020 756100                    STQ     J,,AUTO

      848     5211    3           DO WHILE(I<LISTCNT);

   5211  1 000171   200017 236100                    LDQ     I,,AUTO
         1 000172   200033 116100                    CMPQ    LISTCNT,,AUTO
         1 000173   000456 605000 1                  TPL     s:5338

      849     5212        /*D*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:161  
      850     5213                Before going to the full overhead of a recursive call, see if
      851     5214                the current character could possibly begin this alternative:
      852     5215                follow the subtree down to the first lexeme, and check whether
      853     5216                the current character could begin that lexeme; if not, go on
      854     5217                to the next alternative without attempting the full parse.
      855     5218
      856     5219                This precheck must be skipped if the first lexeme is optional
      857     5220                (since the alternative won't necessarily fail if it is missing)
      858     5221                or if a preparse or failure exit is requested by any node
      859     5222                leading to the first lexeme (since the full parse is needed to
      860     5223                trigger the exit), or if we are reparsing for possible next
      861     5224                nodes (since the possibility list is built during failure
      862     5225                processing for the subnodes).
      863     5226        */
      864     5227    3               P$ = P$NODE.SUBNDS$(I);

   5227  1 000174   200010 470500                    LDP0    NODE$,,AUTO
         1 000175   200017 720100                    LXL0    I,,AUTO
         1 000176   000001 236110                    LDQ     1,X0,PR0
         1 000177   200023 756100                    STQ     P$,,AUTO

      865     5228
      866     5229    3   LOOP:
      867     5230    3               IF NOT P$->BIT36&JFLAG THEN /* WHICH IS EQUIVALENT TO..

   5230  1 000200   200023 470500       LOOP         LDP0    P$,,AUTO
         1 000201   000000 236100                    LDQ     0,,PR0
         1 000202   200020 376100                    ANQ     J,,AUTO
         1 000203   000343 601000 1                  TNZ     s:5286

      868     5231                      IF NOT P$->PX$NODE.OPT
      869     5232                            AND NOT P$->PX$NODE.P_F
      870     5233                            AND NOT P$->PX$NODE.F_F
      871     5234                            AND (NOT P$PCB.NXT
      872     5235                            OR G$D.CCPOS~=P$PCB.HI_CHAR) THEN
      873     5236                        */
      874     5237    4               DO CASE(P$->PX$NODE.TYPE);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:162  

   5237  1 000204   000000 236100                    LDQ     0,,PR0
         1 000205   000041 772000                    QRL     33
         1 000206   000007 116007                    CMPQ    7,DL
         1 000207   000211 602006 1                  TNC     s:5237+5,QL
         1 000210   000343 710000 1                  TRA     s:5286
         1 000211   000343 710000 1                  TRA     s:5286
         1 000212   000343 710000 1                  TRA     s:5286
         1 000213   000343 710000 1                  TRA     s:5286
         1 000214   000223 710000 1                  TRA     s:5244
         1 000215   000220 710000 1                  TRA     s:5240
         1 000216   000226 710000 1                  TRA     s:5248
         1 000217   000242 710000 1                  TRA     s:5253

      875     5238
      876     5239    4               CASE(%TYPE_KONCAT#);

      877     5240    4                   P$ = P$->PX$NODE.SUBNDS$(0);

   5240  1 000220   000001 236100                    LDQ     1,,PR0
         1 000221   200023 756100                    STQ     P$,,AUTO

      878     5241    4                   GOTO LOOP;

   5241  1 000222   000200 710000 1                  TRA     LOOP

      879     5242
      880     5243    4               CASE(%TYPE_LIST#);

      881     5244    4                   P$ = P$->PX$NODE.SUBNDS$(1);

   5244  1 000223   000002 236100                    LDQ     2,,PR0
         1 000224   200023 756100                    STQ     P$,,AUTO

      882     5245    4                   GOTO LOOP;

   5245  1 000225   000200 710000 1                  TRA     LOOP
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:163  

      883     5246
      884     5247    4               CASE(%TYPE_LITERAL#);

      885     5248    4                   IF SUBSTR(P$->PX$LIT.TEXT,0,1) ~= CURCHAR

   5248  1 000226   040100 106500                    CMPC    fill='040'O
         1 000227   000001 200001                    ADSC9   1,,PR0                   cn=1,n=1
         1 000230   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1
         1 000231   000241 600000 1                  TZE     s:5248+11
         1 000232   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000233   000033 772000                    QRL     27
         1 000234   000000 471400 xsym               LDP1    B$XL_UPPER$
         1 000235   040106 106500                    CMPC    fill='040'O
         1 000236   000001 200001                    ADSC9   1,,PR0                   cn=1,n=1
         1 000237   100000 000001                    ADSC9   0,Q,PR1                  cn=0,n=1
         1 000240   000452 601000 1                  TNZ     MISS
         1 000241   000343 710000 1                  TRA     s:5286

      886     5249    4                     AND SUBSTR(P$->PX$LIT.TEXT,0,1) ~= TRANSTBL.C(ASCBIN(CURCHAR))
              5249                              THEN
      887     5250    4                       GOTO MISS;
      888     5251
      889     5252    4               CASE(%TYPE_LEXEME#);

      890     5253    5                   DO CASE (P$ -> PX$SYM.LEXTYPE);

   5253  1 000242   000000 236100                    LDQ     0,,PR0
         1 000243   000020 772000                    QRL     16
         1 000244   000037 376007                    ANQ     31,DL
         1 000245   000040 116007                    CMPQ    32,DL
         1 000246   000250 602006 1                  TNC     s:5253+6,QL
         1 000247   000342 710000 1                  TRA     s:5279
         1 000250   000342 710000 1                  TRA     s:5279
         1 000251   000326 710000 1                  TRA     s:5269
         1 000252   000326 710000 1                  TRA     s:5269
         1 000253   000326 710000 1                  TRA     s:5269
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:164  
         1 000254   000326 710000 1                  TRA     s:5269
         1 000255   000326 710000 1                  TRA     s:5269
         1 000256   000326 710000 1                  TRA     s:5269
         1 000257   000326 710000 1                  TRA     s:5269
         1 000260   000326 710000 1                  TRA     s:5269
         1 000261   000332 710000 1                  TRA     s:5273
         1 000262   000332 710000 1                  TRA     s:5273
         1 000263   000343 710000 1                  TRA     s:5286
         1 000264   000326 710000 1                  TRA     s:5269
         1 000265   000342 710000 1                  TRA     s:5279
         1 000266   000342 710000 1                  TRA     s:5279
         1 000267   000342 710000 1                  TRA     s:5279
         1 000270   000342 710000 1                  TRA     s:5279
         1 000271   000342 710000 1                  TRA     s:5279
         1 000272   000342 710000 1                  TRA     s:5279
         1 000273   000342 710000 1                  TRA     s:5279
         1 000274   000343 710000 1                  TRA     s:5286
         1 000275   000343 710000 1                  TRA     s:5286
         1 000276   000342 710000 1                  TRA     s:5279
         1 000277   000342 710000 1                  TRA     s:5279
         1 000300   000342 710000 1                  TRA     s:5279
         1 000301   000342 710000 1                  TRA     s:5279
         1 000302   000342 710000 1                  TRA     s:5279
         1 000303   000342 710000 1                  TRA     s:5279
         1 000304   000342 710000 1                  TRA     s:5279
         1 000305   000342 710000 1                  TRA     s:5279
         1 000306   000342 710000 1                  TRA     s:5279
         1 000307   000310 710000 1                  TRA     s:5255

      891     5254    5                   CASE (%LEX_DSTRING#);

      892     5255    5                       IF (P$->PX$DSTR.DLIM ~= CURCHAR) AND

   5255  1 000310   040100 106500                    CMPC    fill='040'O
         1 000311   000001 200001                    ADSC9   1,,PR0                   cn=1,n=1
         1 000312   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1
         1 000313   000325 600000 1                  TZE     s:5255+13
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:165  
         1 000314   000001 236100                    LDQ     1,,PR0
         1 000315   000777 376003                    ANQ     511,DU
         1 000316   000000 116003                    CMPQ    0,DU
         1 000317   000452 601000 1                  TNZ     MISS
         1 000320   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000321   000033 772000                    QRL     27
         1 000322   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 000323   000200 316003                    CANQ    128,DU
         1 000324   000452 600000 1                  TZE     MISS
         1 000325   000343 710000 1                  TRA     s:5286

      893     5256    5                         (P$ -> PX$DSTR.DLIM ~= BINASC(0)
      894     5257    5                         OR NOT SYMTTBL.GENERIC_DSTRING(ASCBIN(CURCHAR))) THEN
      895     5258    5                           GOTO MISS;
      896     5259
      897     5260    5                   CASE(%LEX_NULL#,

      898     5261    5                             %LEX_HEX#,
      899     5262    5                             %LEX_OCTAL#,
      900     5263    5                             %LEX_DECIMAL#,
      901     5264    5                             %LEX_ALPHA#,
      902     5265    5                             %LEX_ANUMERIC#,
      903     5266    5                             %LEX_SYMBOL#,
      904     5267    5                             %LEX_PL6SYM#,
      905     5268    5                             %LEX_FID#);
      906     5269    5                       VALIDSYM = 0;

   5269  1 000326   200026 450100                    STZ     VALIDSYM,,AUTO

      907     5270    5                       CALL CHKCHAR ALTRET(MISS);

   5270  1 000327   003134 701000 1                  TSX1    CHKCHAR
         1 000330   000452 702000 1                  TSX2    MISS
         1 000331   000343 710000 1                  TRA     s:5286

      908     5271    5                   CASE (%LEX_ACCOUNT#,

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:166  
      909     5272    5                         %LEX_JOBNAME#);
      910     5273    5                       VALIDSYM = 0;

   5273  1 000332   200026 450100                    STZ     VALIDSYM,,AUTO

      911     5274    5                       IF CURCHAR ~= ''''

   5274  1 000333   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000334   777000 376003                    ANQ     -512,DU
         1 000335   047000 116003                    CMPQ    19968,DU
         1 000336   000343 600000 1                  TZE     s:5286

      912     5275    5                       THEN
      913     5276    5                           CALL CHKCHAR ALTRET (MISS);

   5276  1 000337   003134 701000 1                  TSX1    CHKCHAR
         1 000340   000452 702000 1                  TSX2    MISS
         1 000341   000343 710000 1                  TRA     s:5286

      914     5277    5                   CASE (%LEX_BLANK#, %LEX_END#, %LEX_ASYM#);

      915     5278    5                   CASE (ELSE);

      916     5279    5                       GOTO MISS;

   5279  1 000342   000452 710000 1                  TRA     MISS

      917     5280    5                   END;

      918     5281    4               END;

      919     5282        /*D*
      920     5283                If the precheck succeeds or must be bypassed, this alternative
      921     5284                might still be rejected if this is a reducing node...
      922     5285        */
      923     5286    3               IF P$NODE.TYPE = %TYPE_RALTERN# THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:167  
   5286  1 000343   200010 470500                    LDP0    NODE$,,AUTO
         1 000344   000000 236100                    LDQ     0,,PR0
         1 000345   700000 376003                    ANQ     -32768,DU
         1 000346   200000 116003                    CMPQ    65536,DU
         1 000347   000447 601000 1                  TNZ     s:5325

      924     5287    4               DO;

      925     5288        /*D*
      926     5289                o   Look for a reducing alternative flag block for this node.
      927     5290                    (To avoid the need to check for an empty list, the scan
      928     5291                    starts by treating the list root pointer in G$D as if it
      929     5292                    were an R$BLK; the root address is treated as the .FLINK$,
      930     5293                    and the next work in G$D could not possibly be a .NODE$,
      931     5294                    so this little trick manages to work.)
      932     5295        */
      933     5296    4                   P$ = ADDR(G$D.REDUCE$);

   5296  1 000350   200003 236100                    LDQ     @G$D,,AUTO
         1 000351   000011 036003                    ADLQ    9,DU
         1 000352   200023 756100                    STQ     P$,,AUTO

      934     5297    5                   DO WHILE(R$BLK.FLINK$ ~= ADDR(NIL)

   5297  1 000353   000357 710000 1                  TRA     s:5300

      935     5298    5                     AND R$BLK.NODE$ ~= ADDR(P$NODE));
      936     5299    5                       P$ = R$BLK.FLINK$;

   5299  1 000354   200023 470500                    LDP0    P$,,AUTO
         1 000355   000000 236100                    LDQ     0,,PR0
         1 000356   200023 756100                    STQ     P$,,AUTO

      937     5300    5                   END;

   5300  1 000357   200023 470500                    LDP0    P$,,AUTO
         1 000360   000000 236100                    LDQ     0,,PR0
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:168  
         1 000361   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 000362   000366 600000 1                  TZE     s:5305
         1 000363   000001 236100                    LDQ     1,,PR0
         1 000364   200010 116100                    CMPQ    NODE$,,AUTO
         1 000365   000354 601000 1                  TNZ     s:5299

      938     5301        /*D*
      939     5302                o   If there is an R$BLK, only try to parse this alternative
      940     5303                    if its flag isn't already set.
      941     5304        */
      942     5305    4                   IF R$BLK.NODE$ = ADDR(P$NODE) AND R$BLK.FLAG(I)

   5305  1 000366   000001 236100                    LDQ     1,,PR0
         1 000367   200010 116100                    CMPQ    NODE$,,AUTO
         1 000370   000400 601000 1                  TNZ     s:5307
         1 000371   200017 235100                    LDA     I,,AUTO
         1 000372   000374 605000 1                  TPL     s:5305+6
         1 000373   000044 035003                    ADLA    36,DU
         1 000374   000000 066505                    CMPB    filb='0'B
         1 000375   000002 000001                    BDSC    2,A,PR0                  by=0,bit=0,n=1
         1 000376   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         1 000377   000452 601000 1                  TNZ     MISS

      943     5306    4                   THEN GOTO MISS;
      944     5307    4                   CALL PARS_SUBND ALTRET(MISS);

   5307  1 000400   003325 701000 1                  TSX1    PARS_SUBND
         1 000401   000452 702000 1                  TSX2    MISS

      945     5308        /*D*
      946     5309                o   If the parse succeeds, create an R$BLK if one doesn't
      947     5310                    already exist, and set the flag bit for this alternative.
      948     5311        */
      949     5312    5                   IF R$BLK.NODE$ ~= ADDR(P$NODE) THEN DO;

   5312  1 000402   200023 470500                    LDP0    P$,,AUTO
         1 000403   000001 236100                    LDQ     1,,PR0
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:169  
         1 000404   200010 116100                    CMPQ    NODE$,,AUTO
         1 000405   000440 600000 1                  TZE     s:5319

      950     5313    5                       COUNT = (P$NODE.NSUBNDS + 35)/36 + 2;

   5313  1 000406   200010 471500                    LDP1    NODE$,,AUTO
         1 000407   100000 236100                    LDQ     0,,PR1
         1 000410   000020 772000                    QRL     16
         1 000411   000777 376007                    ANQ     511,DL
         1 000412   000043 036007                    ADLQ    35,DL
         1 000413   000044 506007                    DIV     36,DL
         1 000414   000002 036007                    ADLQ    2,DL
         1 000415   200022 756100                    STQ     COUNT,,AUTO

      951     5314    5                       CALL XUP$GETSPACE(COUNT,P$->R$BLK.FLINK$,G$D);

   5314  1 000416   200003 236100                    LDQ     @G$D,,AUTO
         1 000417   200070 756100                    STQ     TINDX+4,,AUTO
         1 000420   200023 236100                    LDQ     P$,,AUTO
         1 000421   200067 756100                    STQ     TINDX+3,,AUTO
         1 000422   200022 633500                    EPPR3   COUNT,,AUTO
         1 000423   200066 453500                    STP3    TINDX+2,,AUTO
         1 000424   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 000425   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 000426   000000 701000 xent               TSX1    XUP$GETSPACE
         1 000427   000000 011000                    NOP     0

      952     5315    5                       P$ = P$->R$BLK.FLINK$;

   5315  1 000430   200023 470500                    LDP0    P$,,AUTO
         1 000431   000000 236100                    LDQ     0,,PR0
         1 000432   200023 756100                    STQ     P$,,AUTO

      953     5316    5                       P$->R$BLK.NODE$ = ADDR(P$NODE);

   5316  1 000433   200010 236100                    LDQ     NODE$,,AUTO
         1 000434   200023 470500                    LDP0    P$,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:170  
         1 000435   000001 756100                    STQ     1,,PR0

      954     5317    5                       P$->R$BLK.FLINK$ = ADDR(NIL);

   5317  1 000436   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 000437   000000 756100                    STQ     0,,PR0

      955     5318    5                   END;

      956     5319    4                   R$BLK.FLAG(I) = '1'B;

   5319  1 000440   200017 235100                    LDA     I,,AUTO
         1 000441   000443 605000 1                  TPL     s:5319+3
         1 000442   000044 035003                    ADLA    36,DU
         1 000443   003105 060400                    CSL     bolr='003'O
         1 000444   000030 000001 xsym               BDSC    B_VECTNIL+24             by=0,bit=0,n=1
         1 000445   000002 000001                    BDSC    2,A,PR0                  by=0,bit=0,n=1

      957     5320    4               END;

   5320  1 000446   000451 710000 1                  TRA     s:5329

      958     5321        /*D*
      959     5322                For a non-reducing alternative node, always attempt to parse
      960     5323                the subblock if the preckeck passes or is skipped.
      961     5324        */
      962     5325    3               ELSE CALL PARS_SUBND ALTRET(MISS);

   5325  1 000447   003325 701000 1                  TSX1    PARS_SUBND
         1 000450   000452 702000 1                  TSX2    MISS

      963     5326        /*D*
      964     5327            If any alternative succeeds, so does this node.
      965     5328        */
      966     5329    3               GOTO SYNSUCCEED;

   5329  1 000451   001751 710000 1                  TRA     SYNSUCCEED
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:171  

      967     5330        /*D*
      968     5331                If the attempt to parse an alternative fails or is bypassed,
      969     5332                go on to try the next alternative, if there is one.  If no
      970     5333                alternative can be successfully parsed, this node fails.
      971     5334        */
      972     5335    3   MISS:
      973     5336    3               I = I + 1;

   5336  1 000452   200017 054100       MISS         AOS     I,,AUTO

      974     5337    3           END;

   5337  1 000453   200017 236100                    LDQ     I,,AUTO
         1 000454   200033 116100                    CMPQ    LISTCNT,,AUTO
         1 000455   000174 604000 1                  TMI     s:5227

      975     5338    2           GOTO SYNFAIL;

   5338  1 000456   002240 710000 1                  TRA     SYNFAIL

      976     5339        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:172  
      977     5340        /*D*
      978     5341            CONCATENATION node:
      979     5342
      980     5343                Loop to attempt parsing all subnodes in the order defined.
      981     5344                If all subnodes are successfully parsed, this node also
      982     5345                succeeds; if any subnode fails, so does this node.
      983     5346        */
      984     5347    2       CASE(%TYPE_KONCAT#);

      985     5348    2           I = 0;

   5348  1 000457   200017 450100                    STZ     I,,AUTO

      986     5349    3           DO WHILE(I < P$NODE.NSUBNDS);

   5349  1 000460   100000 236100                    LDQ     0,,PR1
         1 000461   000020 772000                    QRL     16
         1 000462   000777 376007                    ANQ     511,DL
         1 000463   200017 116100                    CMPQ    I,,AUTO
         1 000464   000476 604400 1                  TMOZ    s:5353

      987     5350    3               CALL PARS_SUBND ALTRET(SYNFAIL);

   5350  1 000465   003325 701000 1                  TSX1    PARS_SUBND
         1 000466   002240 702000 1                  TSX2    SYNFAIL

      988     5351    3               I = I + 1;

   5351  1 000467   200017 054100                    AOS     I,,AUTO

      989     5352    3           END;

   5352  1 000470   200010 470500                    LDP0    NODE$,,AUTO
         1 000471   000000 236100                    LDQ     0,,PR0
         1 000472   000020 772000                    QRL     16
         1 000473   000777 376007                    ANQ     511,DL
         1 000474   200017 116100                    CMPQ    I,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:173  
         1 000475   000465 605400 1                  TPNZ    s:5350

      990     5353    2           GOTO SYNSUCCEED;

   5353  1 000476   001751 710000 1                  TRA     SYNSUCCEED

      991     5354        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:174  
      992     5355        /*D*
      993     5356            LIST node:
      994     5357
      995     5358                Attempt to parse the list element subnode.
      996     5359                If that succeeds, attempt to parse the delimiter subnode.
      997     5360                If that succeeds, try to parse another list element.
      998     5361                Continue until something fails.
      999     5362        */
     1000     5363    2       CASE(%TYPE_LIST#);

     1001     5364    2           LIST_STK = MY_STACK;

   5364  1 000477   200015 235100                    LDA     MY_STACK,,AUTO
         1 000500   200016 755100                    STA     LIST_STK,,AUTO

     1002     5365    2           LISTCNT = 0;

   5365  1 000501   200033 450100                    STZ     LISTCNT,,AUTO

     1003     5366    3           DO WHILE('1'B);

     1004     5367    3               I=1;

   5367  1 000502   000001 235007                    LDA     1,DL
         1 000503   200017 755100                    STA     I,,AUTO

     1005     5368    3               CALL PARS_SUBND ALTRET(LISTEND);

   5368  1 000504   003325 701000 1                  TSX1    PARS_SUBND
         1 000505   000542 702000 1                  TSX2    LISTEND

     1006     5369        /*D*
     1007     5370                After each list element is successfully parsed, reset the
     1008     5371                fallback position, so that a subsequent failure will not
     1009     5372                roll back beyond this point.
     1010     5373        */
     1011     5374    3               LIST_STK = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:175  

   5374  1 000506   200011 470500                    LDP0    PCB$,,AUTO
         1 000507   000002 236100                    LDQ     2,,PR0
         1 000510   000022 772000                    QRL     18
         1 000511   200066 756100                    STQ     TINDX+2,,AUTO
         1 000512   200003 471500                    LDP1    @G$D,,AUTO
         1 000513   100010 236100                    LDQ     8,,PR1
         1 000514   000022 772000                    QRL     18
         1 000515   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 000516   200067 756100                    STQ     TINDX+3,,AUTO
         1 000517   000005 236100                    LDQ     5,,PR0
         1 000520   000022 772000                    QRL     18
         1 000521   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 000522   200016 756100                    STQ     LIST_STK,,AUTO

     1012     5375    3               SAVEPOS = G$D.CCPOS-G$D.CNTUPOS;

   5375  1 000523   100013 236100                    LDQ     11,,PR1
         1 000524   100012 136100                    SBLQ    10,,PR1
         1 000525   200005 756100                    STQ     SAVEPOS,,AUTO

     1013     5376    3               SAVELEX = G$D.CCPOS-G$D.CNTUPOS;

   5376  1 000526   100013 236100                    LDQ     11,,PR1
         1 000527   100012 136100                    SBLQ    10,,PR1
         1 000530   200006 756100                    STQ     SAVELEX,,AUTO

     1014     5377    3               SKIPBL=G$D.BLSKIP;

   5377  1 000531   100015 236100                    LDQ     13,,PR1
         1 000532   000011 736000                    QLS     9
         1 000533   400000 376003                    ANQ     -131072,DU
         1 000534   200007 756100                    STQ     SKIPBL,,AUTO

     1015     5378
     1016     5379    3               LISTCNT = LISTCNT + 1;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:176  
   5379  1 000535   200033 054100                    AOS     LISTCNT,,AUTO

     1017     5380    3               I=0;

   5380  1 000536   200017 450100                    STZ     I,,AUTO

     1018     5381    3               CALL PARS_SUBND ALTRET(LISTEND);

   5381  1 000537   003325 701000 1                  TSX1    PARS_SUBND
         1 000540   000542 702000 1                  TSX2    LISTEND

     1019     5382    3           END;

   5382  1 000541   000502 710000 1                  TRA     s:5367

     1020     5383
     1021     5384    2   LISTEND:
     1022     5385        /*D*
     1023     5386                If a failure occurs before a single list element is parsed,
     1024     5387                this node fails too.
     1025     5388        */
     1026     5389    2           IF LISTCNT = 0 THEN

   5389  1 000542   200033 235100       LISTEND      LDA     LISTCNT,,AUTO
         1 000543   002240 600000 1                  TZE     SYNFAIL

     1027     5390    2               GOTO SYNFAIL;
     1028     5391        /*D*
     1029     5392                Otherwise, this node succeeds syntactically.
     1030     5393                But, before doing success processing, remove any output blocks
     1031     5394                created by the final unsuccessful parse attempt, and restore
     1032     5395                the current position to what it was after the last list
     1033     5396                element was successfully parsed.
     1034     5397        */
     1035     5398    2           I = P$PCB.WKSZ - POFFW (G$D.STACKTOP$, P$PCB.WORK$) - LIST_STK;

   5398  1 000544   200011 470500                    LDP0    PCB$,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:177  
         1 000545   000002 236100                    LDQ     2,,PR0
         1 000546   000022 772000                    QRL     18
         1 000547   200066 756100                    STQ     TINDX+2,,AUTO
         1 000550   200003 471500                    LDP1    @G$D,,AUTO
         1 000551   100010 236100                    LDQ     8,,PR1
         1 000552   000022 772000                    QRL     18
         1 000553   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 000554   200067 756100                    STQ     TINDX+3,,AUTO
         1 000555   000005 236100                    LDQ     5,,PR0
         1 000556   000022 772000                    QRL     18
         1 000557   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 000560   200016 136100                    SBLQ    LIST_STK,,AUTO
         1 000561   200017 756100                    STQ     I,,AUTO

     1036     5399    2           CALL FREESTACK (I);

   5399  1 000562   200017 633500                    EPPR3   I,,AUTO
         1 000563   200051 453500                    STP3    J+2,,AUTO
         1 000564   004052 701000 1                  TSX1    FREESTACK
         1 000565   000000 011000                    NOP     0

     1037     5400    2           CALL SAVE_POS;

   5400  1 000566   003403 701000 1                  TSX1    SAVE_POS
         1 000567   000000 011000                    NOP     0

     1038     5401    2           GOTO SYNSUCCEED;

   5401  1 000570   001751 710000 1                  TRA     SYNSUCCEED

     1039     5402        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:178  
     1040     5403        /*D*
     1041     5404            LEXEME node:  The logic needed to parse a metasymbol depends on
     1042     5405            the metasymbol type.
     1043     5406
     1044     5407            (Note: The term "lexeme" is used ambiguously.  Here, it means a
     1045     5408            lexeme-type node, which is actually a misnomer for a PARTRGE
     1046     5409            metasymbol.  Elsewhere, it means a metasymbol or a literal, both
     1047     5410            of which consitute leaves on the node tree.)
     1048     5411        */
     1049     5412    2       CASE(%TYPE_LEXEME#);

     1050     5413    3           DO CASE (P$SYM.LEXTYPE);

   5413  1 000571   100000 236100                    LDQ     0,,PR1
         1 000572   000020 772000                    QRL     16
         1 000573   000037 376007                    ANQ     31,DL
         1 000574   000040 116007                    CMPQ    32,DL
         1 000575   000577 602006 1                  TNC     s:5413+6,QL
         1 000576   001543 710000 1                  TRA     s:5790
         1 000577   001543 710000 1                  TRA     s:5790
         1 000600   001114 710000 1                  TRA     STDLEX
         1 000601   001114 710000 1                  TRA     STDLEX
         1 000602   001114 710000 1                  TRA     STDLEX
         1 000603   001114 710000 1                  TRA     STDLEX
         1 000604   001114 710000 1                  TRA     STDLEX
         1 000605   001114 710000 1                  TRA     STDLEX
         1 000606   001114 710000 1                  TRA     STDLEX
         1 000607   000637 710000 1                  TRA     s:5431
         1 000610   001105 710000 1                  TRA     s:5564
         1 000611   001105 710000 1                  TRA     s:5564
         1 000612   001033 710000 1                  TRA     s:5541
         1 000613   001114 710000 1                  TRA     STDLEX
         1 000614   001543 710000 1                  TRA     s:5790
         1 000615   001543 710000 1                  TRA     s:5790
         1 000616   001543 710000 1                  TRA     s:5790
         1 000617   001543 710000 1                  TRA     s:5790
         1 000620   001543 710000 1                  TRA     s:5790
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:179  
         1 000621   001543 710000 1                  TRA     s:5790
         1 000622   001543 710000 1                  TRA     s:5790
         1 000623   001531 710000 1                  TRA     s:5779
         1 000624   001525 710000 1                  TRA     s:5766
         1 000625   001543 710000 1                  TRA     s:5790
         1 000626   001543 710000 1                  TRA     s:5790
         1 000627   001543 710000 1                  TRA     s:5790
         1 000630   001543 710000 1                  TRA     s:5790
         1 000631   001543 710000 1                  TRA     s:5790
         1 000632   001543 710000 1                  TRA     s:5790
         1 000633   001543 710000 1                  TRA     s:5790
         1 000634   001543 710000 1                  TRA     s:5790
         1 000635   001543 710000 1                  TRA     s:5790
         1 000636   001171 710000 1                  TRA     s:5640

     1051     5414        /*D*
     1052     5415            FID metasymbol:
     1053     5416
     1054     5417                A fid, for parsing purposes, is a concatenation of strings of
     1055     5418                characters legal in a fid with quoted strings (which can
     1056     5419                contain any character).  This logic will accept any legal fid,
     1057     5420                but won't reject lots of illegal ones; programs parsing fids
     1058     5421                must expect additional errors from M$FID or M$OPEN.
     1059     5422
     1060     5423                    I = number of characters in fid
     1061     5424                    J = current position in command text
     1062     5425        */
     1063     5426    3           CASE(%LEX_FID#);

     1064     5427        /*D*
     1065     5428                Force failure if reparsing for legal alternatives to put this
     1066     5429                node on the list of possibilities.
     1067     5430        */
     1068     5431    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR

   5431  1 000637   200011 473500                    LDP3    PCB$,,AUTO
         1 000640   300005 236100                    LDQ     5,,PR3
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:180  
         1 000641   040000 316007                    CANQ    16384,DL
         1 000642   000647 600000 1                  TZE     s:5439
         1 000643   000013 236100                    LDQ     11,,PR0
         1 000644   000647 604000 1                  TMI     s:5439
         1 000645   300012 116100                    CMPQ    10,,PR3
         1 000646   002240 600000 1                  TZE     SYNFAIL

     1069     5432    3               THEN
     1070     5433    3                   GOTO SYNFAIL;
     1071     5434        /*D*
     1072     5435                Also fail if the current character isn't legal in a fid.
     1073     5436                (This also fails at the end of the command, since then the
     1074     5437                current character is null.)
     1075     5438        */
     1076     5439    3               P$=ADDR(P$SYM);

   5439  1 000647   200010 236100                    LDQ     NODE$,,AUTO
         1 000650   200023 756100                    STQ     P$,,AUTO

     1077     5440    3               CALL CHKCHAR ALTRET(SYNFAIL);

   5440  1 000651   003134 701000 1                  TSX1    CHKCHAR
         1 000652   002240 702000 1                  TSX2    SYNFAIL

     1078     5441
     1079     5442    3               I = 0;

   5442  1 000653   200017 450100                    STZ     I,,AUTO

     1080     5443    3               J = G$D.CCPOS;

   5443  1 000654   200003 470500                    LDP0    @G$D,,AUTO
         1 000655   000013 235100                    LDA     11,,PR0
         1 000656   200020 755100                    STA     J,,AUTO

     1081     5444        /*D*
     1082     5445                Eat characters until a quote, or a character that isn't legal in a fid
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:181  
     1083     5446                (or the end of the command) is found, then go to common final
     1084     5447                processing for metasymbols.
     1085     5448        */
     1086     5449    4               DO WHILE(CURCHAR ~= '''');

   5449  1 000657   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000660   777000 376003                    ANQ     -512,DU
         1 000661   047000 116003                    CMPQ    19968,DU
         1 000662   000703 600000 1                  TZE     QT_LOOP

     1087     5450    4   FID_LOOP:
     1088     5451    4                   I = I + 1;

   5451  1 000663   200017 054100       FID_LOOP     AOS     I,,AUTO

     1089     5452    4                   J = J + 1;

   5452  1 000664   200020 054100                    AOS     J,,AUTO

     1090     5453    4                   IF J = NCHARS THEN

   5453  1 000665   200020 236100                    LDQ     J,,AUTO
         1 000666   200013 116100                    CMPQ    NCHARS,,AUTO
         1 000667   000722 600000 1                  TZE     FID_BLOCK

     1091     5454    4                       GOTO FID_BLOCK;
     1092     5455    4                   CURCHAR = P$PCB.TEXT$->C$BUFA(J);

   5455  1 000670   200011 470500                    LDP0    PCB$,,AUTO
         1 000671   000000 471500                    LDP1    0,,PR0
         1 000672   040100 100506                    MLR     fill='040'O
         1 000673   100000 000001                    ADSC9   0,Q,PR1                  cn=0,n=1
         1 000674   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1

     1093     5456    4                   CALL CHKCHAR ALTRET(FID_BLOCK);

   5456  1 000675   003134 701000 1                  TSX1    CHKCHAR
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:182  
         1 000676   000722 702000 1                  TSX2    FID_BLOCK

     1094     5457    4               END;

   5457  1 000677   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000700   777000 376003                    ANQ     -512,DU
         1 000701   047000 116003                    CMPQ    19968,DU
         1 000702   000663 601000 1                  TNZ     FID_LOOP

     1095     5458        /*D*
     1096     5459                If a quote is found, eat characters up to the next quote, then
     1097     5460                re-enter the previous loop.  (If the end of the command is
     1098     5461                reached without finding another quote, fail due to unmatched
     1099     5462                quotes.)
     1100     5463
     1101     5464                Note that fids are returned with quotes intact, since that's
     1102     5465                the form they need to be in to pass through M$FID.
     1103     5466        */
     1104     5467    3   QT_LOOP:
     1105     5468    3               I = I + 1;

   5468  1 000703   200017 054100       QT_LOOP      AOS     I,,AUTO

     1106     5469    3               J = J + 1;

   5469  1 000704   200020 054100                    AOS     J,,AUTO

     1107     5470    3               IF J = NCHARS THEN

   5470  1 000705   200020 236100                    LDQ     J,,AUTO
         1 000706   200013 116100                    CMPQ    NCHARS,,AUTO
         1 000707   002240 600000 1                  TZE     SYNFAIL

     1108     5471    3                   GOTO SYNFAIL;
     1109     5472    3               CURCHAR = P$PCB.TEXT$->C$BUFA(J);

   5472  1 000710   200011 470500                    LDP0    PCB$,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:183  
         1 000711   000000 471500                    LDP1    0,,PR0
         1 000712   040100 100506                    MLR     fill='040'O
         1 000713   100000 000001                    ADSC9   0,Q,PR1                  cn=0,n=1
         1 000714   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1

     1110     5473    3               IF CURCHAR ~= '''' THEN

   5473  1 000715   200012 236100                    LDQ     CURCHAR,,AUTO
         1 000716   777000 376003                    ANQ     -512,DU
         1 000717   047000 116003                    CMPQ    19968,DU
         1 000720   000703 601000 1                  TNZ     QT_LOOP

     1111     5474    3                   GOTO QT_LOOP;
     1112     5475
     1113     5476    3               GOTO FID_LOOP;

   5476  1 000721   000663 710000 1                  TRA     FID_LOOP

     1114     5477
     1115     5478        /*D*
     1116     5479                Common final processing for metasymbols:
     1117     5480
     1118     5481                    I = number of characters in symbol parsed
     1119     5482        */
     1120     5483    3   FID_BLOCK:
     1121     5484        /*D*
     1122     5485                o   If the node contains the extra information word, and that
     1123     5486                    word specifies the maximum length, fail if the symbol
     1124     5487                    parsed is longer than the maximum.
     1125     5488        */
     1126     5489    3               IF P$SYM.XTRA

   5489  1 000722   200010 470500       FID_BLOCK    LDP0    NODE$,,AUTO
         1 000723   000000 236100                    LDQ     0,,PR0
         1 000724   000040 316003                    CANQ    32,DU
         1 000725   000735 600000 1                  TZE     s:5502

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:184  
     1127     5490    3               THEN
     1128     5491    3                   IF P$SYM.MAXL > 0

   5491  1 000726   000001 236100                    LDQ     1,,PR0
         1 000727   777000 316003                    CANQ    -512,DU
         1 000730   000735 600000 1                  TZE     s:5502
         1 000731   000001 236100                    LDQ     1,,PR0
         1 000732   000033 772000                    QRL     27
         1 000733   200017 116100                    CMPQ    I,,AUTO
         1 000734   002240 604000 1                  TMI     SYNFAIL

     1129     5492    3                     AND P$SYM.MAXL < I
     1130     5493    3                   THEN
     1131     5494    3                       GOTO SYNFAIL;
     1132     5495        /*D*
     1133     5496                o   If the metasymbol requires an output block, allocate a
     1134     5497                    symbol-type block, move the symbol text into the block
     1135     5498                    (converting it to upper case if the node requests this),
     1136     5499                    and set other fields specific to a symbol block.  (Common
     1137     5500                    fields are set up later, during success processing.)
     1138     5501        */
     1139     5502    4               IF P$NODE.O_F THEN DO;

   5502  1 000735   000000 236100                    LDQ     0,,PR0
         1 000736   004000 316003                    CANQ    2048,DU
         1 000737   001026 600000 1                  TZE     s:5522

     1140     5503    4                   COUNT = (I + 20)/4;

   5503  1 000740   200017 236100                    LDQ     I,,AUTO
         1 000741   000024 036007                    ADLQ    20,DL
         1 000742   000004 506007                    DIV     4,DL
         1 000743   200022 756100                    STQ     COUNT,,AUTO

     1141     5504    4                   CALL XUP$GETSPACE(COUNT,Q$,G$D);

   5504  1 000744   200003 236100                    LDQ     @G$D,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:185  
         1 000745   200070 756100                    STQ     TINDX+4,,AUTO
         1 000746   200024 631500                    EPPR1   Q$,,AUTO
         1 000747   200067 451500                    STP1    TINDX+3,,AUTO
         1 000750   200022 633500                    EPPR3   COUNT,,AUTO
         1 000751   200066 453500                    STP3    TINDX+2,,AUTO
         1 000752   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 000753   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 000754   000000 701000 xent               TSX1    XUP$GETSPACE
         1 000755   000000 011000                    NOP     0

     1142     5505    4                   BLK$ = Q$;

   5505  1 000756   200024 236100                    LDQ     Q$,,AUTO
         1 000757   200027 756100                    STQ     BLK$,,AUTO

     1143     5506    4                   BLK$->OUT$SYM.COUNT = I;

   5506  1 000760   200027 470500                    LDP0    BLK$,,AUTO
         1 000761   200017 236100                    LDQ     I,,AUTO
         1 000762   000033 736000                    QLS     27
         1 000763   000004 552140                    STBQ    4,'40'O,PR0

     1144     5507    4                   IF P$SYM.MAKEUC

   5507  1 000764   200010 471500                    LDP1    NODE$,,AUTO
         1 000765   100000 236100                    LDQ     0,,PR1
         1 000766   000100 316003                    CANQ    64,DU
         1 000767   001006 600000 1                  TZE     s:5512

     1145     5508    4                   THEN
     1146     5509    4                       CALL XLATE (BLK$ -> OUT$SYM.TEXT, TRANSTBL,

   5509  1 000770   000004 236100                    LDQ     4,,PR0
         1 000771   000033 772000                    QRL     27
         1 000772   200011 473500                    LDP3    PCB$,,AUTO
         1 000773   300000 474500                    LDP4    0,,PR3
         1 000774   200003 475500                    LDP5    @G$D,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:186  
         1 000775   500013 235100                    LDA     11,,PR5
         1 000776   200017 720100                    LXL0    I,,AUTO
         1 000777   000000 476400 xsym               LDP6    B$XL_UPPER$
         1 001000   000000 621006                    EAX1    0,QL
         1 001001   040140 160545                    MVT     fill='040'O
         1 001002   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 001003   000004 200011                    ADSC9   4,,PR0                   cn=1,n=*X1
         1 001004   600000 000100                    ARG     0,,PR6
         1 001005   001021 710000 1                  TRA     s:5514

     1147     5510    4                         SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I));
     1148     5511    4                   ELSE
     1149     5512    4                       BLK$ -> OUT$SYM.TEXT =

   5512  1 001006   000004 236100                    LDQ     4,,PR0
         1 001007   000033 772000                    QRL     27
         1 001010   200011 473500                    LDP3    PCB$,,AUTO
         1 001011   300000 474500                    LDP4    0,,PR3
         1 001012   200003 475500                    LDP5    @G$D,,AUTO
         1 001013   500013 235100                    LDA     11,,PR5
         1 001014   200017 720100                    LXL0    I,,AUTO
         1 001015   000000 621006                    EAX1    0,QL
         1 001016   040140 100545                    MLR     fill='040'O
         1 001017   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 001020   000004 200011                    ADSC9   4,,PR0                   cn=1,n=*X1

     1150     5513    4                         SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);
     1151     5514    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);

   5514  1 001021   200024 236100                    LDQ     Q$,,AUTO
         1 001022   000004 036003                    ADLQ    4,DU
         1 001023   000003 756100                    STQ     3,,PR0

     1152     5515    4                   BLK$->OUT$SYM.NSUBLKS = 1;

   5515  1 001024   000001 220003                    LDX0    1,DU
         1 001025   000001 740100                    STX0    1,,PR0
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:187  

     1153     5516
     1154     5517    4               END;

     1155     5518        /*D*
     1156     5519                o   Set current position in comment text to point past the
     1157     5520                    lexeme just parsed.
     1158     5521        */
     1159     5522    3               G$D.CCPOS = G$D.CCPOS+I;

   5522  1 001026   200003 470500                    LDP0    @G$D,,AUTO
         1 001027   000013 236100                    LDQ     11,,PR0
         1 001030   200017 036100                    ADLQ    I,,AUTO
         1 001031   000013 756100                    STQ     11,,PR0

     1160     5523        /*D*
     1161     5524                o   Go on to lexical success processing.
     1162     5525        */
     1163     5526    3               GOTO LEXSUCCEED;

   5526  1 001032   002544 710000 1                  TRA     LEXSUCCEED

     1164     5527        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:188  
     1165     5528        /*D*
     1166     5529            ASYM metasymbol:
     1167     5530
     1168     5531                To parse an anti-symbol, scan for all possible delimiters,
     1169     5532                such that each successive scan is delimited by the position
     1170     5533                of the first delimiter found by the prior scan, so that the
     1171     5534                result is the position of the first possible delimiter found
     1172     5535                (or the end of the command if no delimiters are found).
     1173     5536
     1174     5537                    I = index into command text of first delimiter found
     1175     5538                    J = index into delimiter list
     1176     5539        */
     1177     5540    3           CASE(%LEX_ASYM#);

     1178     5541    3               I = NCHARS;

   5541  1 001033   200013 235100                    LDA     NCHARS,,AUTO
         1 001034   200017 755100                    STA     I,,AUTO

     1179     5542    3               J = 0;

   5542  1 001035   200020 450100                    STZ     J,,AUTO

     1180     5543    3               IF P$SYM.XTRA THEN

   5543  1 001036   100000 236100                    LDQ     0,,PR1
         1 001037   000040 316003                    CANQ    32,DU
         1 001040   001100 600000 1                  TZE     s:5552

     1181     5544    4               DO WHILE(J <P$SYM.COUNT);

   5544  1 001041   100001 236100                    LDQ     1,,PR1
         1 001042   000022 772000                    QRL     18
         1 001043   000777 376007                    ANQ     511,DL
         1 001044   200020 116100                    CMPQ    J,,AUTO
         1 001045   001100 604400 1                  TMOZ    s:5552

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:189  
     1182     5545    4                   CALL INDEX(I,

   5545  1 001046   200010 470500                    LDP0    NODE$,,AUTO
         1 001047   000001 220100                    LDX0    1,,PR0
         1 001050   000777 360003                    ANX0    511,DU
         1 001051   200011 471500                    LDP1    PCB$,,AUTO
         1 001052   100000 473500                    LDP3    0,,PR1
         1 001053   200003 474500                    LDP4    @G$D,,AUTO
         1 001054   200017 236100                    LDQ     I,,AUTO
         1 001055   400013 136100                    SBLQ    11,,PR4
         1 001056   400013 235100                    LDA     11,,PR4
         1 001057   200066 756100                    STQ     TINDX+2,,AUTO
         1 001060   400013 236100                    LDQ     11,,PR4
         1 001061   200066 720100                    LXL0    TINDX+2,,AUTO
         1 001062   200067 756100                    STQ     TINDX+3,,AUTO
         1 001063   200020 236100                    LDQ     J,,AUTO
         1 001064   000106 124545                    SCM     mask='000'O
         1 001065   300000 000010                    ADSC9   0,A,PR3                  cn=0,n=*X0
         1 001066   000001 400001                    ADSC9   1,Q,PR0                  cn=2,n=1
         1 001067   200017 000100                    ARG     I,,AUTO
         1 001070   200067 236100                    LDQ     TINDX+3,,AUTO
         1 001071   200017 056100                    ASQ     I,,AUTO

     1183     5546    4                     SUBSTR(P$SYM.TEXT,J,1),
     1184     5547    4                     SUBSTR(P$PCB.TEXT$->C$BUF,0,I),
     1185     5548    4                     G$D.CCPOS);
     1186     5549    4                   J = J + 1;

   5549  1 001072   200020 054100                    AOS     J,,AUTO

     1187     5550    4               END;

   5550  1 001073   000001 236100                    LDQ     1,,PR0
         1 001074   000022 772000                    QRL     18
         1 001075   000777 376007                    ANQ     511,DL
         1 001076   200020 116100                    CMPQ    J,,AUTO
         1 001077   001046 605400 1                  TPNZ    s:5545
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:190  

     1188     5551
     1189     5552    3               I = I-G$D.CCPOS;

   5552  1 001100   200003 470500                    LDP0    @G$D,,AUTO
         1 001101   200017 236100                    LDQ     I,,AUTO
         1 001102   000013 136100                    SBLQ    11,,PR0
         1 001103   200017 756100                    STQ     I,,AUTO

     1190     5553    3               GOTO FID_BLOCK;

   5553  1 001104   000722 710000 1                  TRA     FID_BLOCK

     1191     5554        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:191  
     1192     5555        /*D*
     1193     5556            ACCOUNT or JOBNAME metasymbol:
     1194     5557
     1195     5558                These are treated as normal lexemes unless they begin with a
     1196     5559                quote, in which case they follow the rules for a DSTRING
     1197     5560                metasymbol, with a quote at the delimiter.
     1198     5561        */
     1199     5562    3           CASE(%LEX_ACCOUNT#,

     1200     5563    3                 %LEX_JOBNAME#);
     1201     5564    3               IF CURCHAR = ''''

   5564  1 001105   200012 236100                    LDQ     CURCHAR,,AUTO
         1 001106   777000 376003                    ANQ     -512,DU
         1 001107   047000 116003                    CMPQ    19968,DU
         1 001110   001114 601000 1                  TNZ     STDLEX

     1202     5565    4               THEN DO;

     1203     5566    4                   DLIM = '''';

   5566  1 001111   047000 236003                    LDQ     19968,DU
         1 001112   200034 756100                    STQ     DLIM,,AUTO

     1204     5567    4                   GOTO DSTRING;

   5567  1 001113   001212 710000 1                  TRA     DSTRING

     1205     5568    4               END;
     1206     5569    3               ELSE
     1207     5570    3                   GOTO STDLEX;
     1208     5571        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:192  
     1209     5572        /*D*
     1210     5573            Other metasymbols:
     1211     5574
     1212     5575                For most metasymbols, common logic can be used to eat
     1213     5576                characters until one is found that is illegal for the
     1214     5577                metasymbol type.
     1215     5578
     1216     5579                    I = number of characters in symbol
     1217     5580                    COUNT = current position in command text
     1218     5581        */
     1219     5582    3           CASE(%LEX_NULL#,

     1220     5583    3                     %LEX_HEX#,
     1221     5584    3                     %LEX_OCTAL#,
     1222     5585    3                     %LEX_DECIMAL#,
     1223     5586    3                     %LEX_ALPHA#,
     1224     5587    3                     %LEX_ANUMERIC#,
     1225     5588    3                     %LEX_PL6SYM#,
     1226     5589    3                     %LEX_SYMBOL#);
     1227     5590    3   STDLEX:
     1228     5591        /*D*
     1229     5592                Force failure if reparsing for legal alternatives to put this
     1230     5593                node on the list of possibilities.
     1231     5594        */
     1232     5595    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR

   5595  1 001114   200011 473500       STDLEX       LDP3    PCB$,,AUTO
         1 001115   300005 236100                    LDQ     5,,PR3
         1 001116   040000 316007                    CANQ    16384,DL
         1 001117   001124 600000 1                  TZE     s:5601
         1 001120   000013 236100                    LDQ     11,,PR0
         1 001121   001124 604000 1                  TMI     s:5601
         1 001122   300012 116100                    CMPQ    10,,PR3
         1 001123   002240 600000 1                  TZE     SYNFAIL

     1233     5596    3               THEN
     1234     5597    3                   GOTO SYNFAIL;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:193  
     1235     5598        /*D*
     1236     5599            o   If not one character can be parsed for this lexeme, the node fails.
     1237     5600        */
     1238     5601    3               VALIDSYM = 0;

   5601  1 001124   200026 450100                    STZ     VALIDSYM,,AUTO

     1239     5602    3               P$=ADDR(P$SYM);

   5602  1 001125   200010 236100                    LDQ     NODE$,,AUTO
         1 001126   200023 756100                    STQ     P$,,AUTO

     1240     5603    3               CALL CHKCHAR ALTRET(SYNFAIL);

   5603  1 001127   003134 701000 1                  TSX1    CHKCHAR
         1 001130   002240 702000 1                  TSX2    SYNFAIL

     1241     5604        /*D*
     1242     5605            o   Otherwise eat characters until one is found that isn't legal
     1243     5606                for the symbol being parsed.
     1244     5607        */
     1245     5608    3               COUNT=G$D.CCPOS+1;

   5608  1 001131   200003 470500                    LDP0    @G$D,,AUTO
         1 001132   000013 235100                    LDA     11,,PR0
         1 001133   000001 035007                    ADLA    1,DL
         1 001134   200022 755100                    STA     COUNT,,AUTO

     1246     5609    3               I=1;

   5609  1 001135   000001 236007                    LDQ     1,DL
         1 001136   200017 756100                    STQ     I,,AUTO

     1247     5610    4               DO WHILE(COUNT<NCHARS);

   5610  1 001137   200022 236100                    LDQ     COUNT,,AUTO
         1 001140   200013 116100                    CMPQ    NCHARS,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:194  
         1 001141   001157 605000 1                  TPL     MAKEBLK

     1248     5611    4                   CURCHAR=P$PCB.TEXT$->C$BUFA(COUNT);

   5611  1 001142   200011 470500                    LDP0    PCB$,,AUTO
         1 001143   000000 471500                    LDP1    0,,PR0
         1 001144   200022 235100                    LDA     COUNT,,AUTO
         1 001145   040100 100505                    MLR     fill='040'O
         1 001146   100000 000001                    ADSC9   0,A,PR1                  cn=0,n=1
         1 001147   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1

     1249     5612    4                   CALL CHKCHAR ALTRET(MAKEBLK);

   5612  1 001150   003134 701000 1                  TSX1    CHKCHAR
         1 001151   001157 702000 1                  TSX2    MAKEBLK

     1250     5613    4                   I = I + 1;

   5613  1 001152   200017 054100                    AOS     I,,AUTO

     1251     5614    4                   COUNT=COUNT+1;

   5614  1 001153   200022 054100                    AOS     COUNT,,AUTO

     1252     5615    4               END;

   5615  1 001154   200022 236100                    LDQ     COUNT,,AUTO
         1 001155   200013 116100                    CMPQ    NCHARS,,AUTO
         1 001156   001142 604000 1                  TMI     s:5611

     1253     5616        /*D*
     1254     5617            o   Alphanumeric and symbol lexemes need a special test to make
     1255     5618                sure at least one character parsed is a letter.
     1256     5619        */
     1257     5620    3   MAKEBLK:
     1258     5621    3               IF P$SYM.LEXTYPE = %LEX_ANUMERIC# OR P$SYM.LEXTYPE = %LEX_SYMBOL# THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:195  
   5621  1 001157   200010 470500       MAKEBLK      LDP0    NODE$,,AUTO
         1 001160   000000 236100                    LDQ     0,,PR0
         1 001161   000002 376000 2                  ANQ     2
         1 001162   000003 116000 2                  CMPQ    3
         1 001163   001166 600000 1                  TZE     s:5622
         1 001164   000004 116000 2                  CMPQ    4
         1 001165   001170 601000 1                  TNZ     s:5627

     1259     5622    3                   IF VALIDSYM = 0 THEN

   5622  1 001166   200026 235100                    LDA     VALIDSYM,,AUTO
         1 001167   002240 600000 1                  TZE     SYNFAIL

     1260     5623    3                       GOTO SYNFAIL;
     1261     5624        /*D*
     1262     5625            o   Continue with common final metasymbol processing.
     1263     5626        */
     1264     5627    3               GOTO FID_BLOCK;

   5627  1 001170   000722 710000 1                  TRA     FID_BLOCK

     1265     5628        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:196  
     1266     5629        /*D*
     1267     5630            DELIMITED STRING metasymbol:
     1268     5631
     1269     5632                If a string beginning and ending with the proper delimiter
     1270     5633                can be parsed, build an output block for the symbol and go
     1271     5634                on to lexical success, otherwise indicate failure.
     1272     5635        */
     1273     5636    3           CASE(%LEX_DSTRING#);

     1274     5637        /*D*
     1275     5638            o   If current character isn't a delimiter, fail immediately.
     1276     5639        */
     1277     5640    3               IF (CURCHAR~=P$DSTR.DLIM) AND (P$DSTR.DLIM~=BINASC(0) OR

   5640  1 001171   040100 106500                    CMPC    fill='040'O
         1 001172   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1
         1 001173   100001 200001                    ADSC9   1,,PR1                   cn=1,n=1
         1 001174   001206 600000 1                  TZE     s:5643
         1 001175   100001 236100                    LDQ     1,,PR1
         1 001176   000777 376003                    ANQ     511,DU
         1 001177   000000 116003                    CMPQ    0,DU
         1 001200   002240 601000 1                  TNZ     SYNFAIL
         1 001201   200012 236100                    LDQ     CURCHAR,,AUTO
         1 001202   000033 772000                    QRL     27
         1 001203   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 001204   000200 316003                    CANQ    128,DU
         1 001205   002240 600000 1                  TZE     SYNFAIL

     1278     5641    3                 NOT SYMTTBL.GENERIC_DSTRING(ASCBIN(CURCHAR))) THEN
     1279     5642    3                   GOTO SYNFAIL;
     1280     5643    3               DLIM = CURCHAR;

   5643  1 001206   200012 236100                    LDQ     CURCHAR,,AUTO
         1 001207   777000 376003                    ANQ     -512,DU
         1 001210   000000 276000 2                  ORQ     0
         1 001211   200034 756100                    STQ     DLIM,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:197  
     1281     5644    3   DSTRING:
     1282     5645        /*D*
     1283     5646                Force failure if reparsing for legal alternatives to put this
     1284     5647                node on the list of possibilities.
     1285     5648        */
     1286     5649    3               IF P$PCB.NXT AND G$D.CCPOS = P$PCB.HI_CHAR

   5649  1 001212   200011 473500       DSTRING      LDP3    PCB$,,AUTO
         1 001213   300005 236100                    LDQ     5,,PR3
         1 001214   040000 316007                    CANQ    16384,DL
         1 001215   001222 600000 1                  TZE     s:5652
         1 001216   000013 236100                    LDQ     11,,PR0
         1 001217   001222 604000 1                  TMI     s:5652
         1 001220   300012 116100                    CMPQ    10,,PR3
         1 001221   002240 600000 1                  TZE     SYNFAIL

     1287     5650    3               THEN
     1288     5651    3                   GOTO SYNFAIL;
     1289     5652    3               I = 0;

   5652  1 001222   200017 450100                    STZ     I,,AUTO

     1290     5653    3               J = G$D.CCPOS + 1;

   5653  1 001223   000013 235100                    LDA     11,,PR0
         1 001224   000001 035007                    ADLA    1,DL
         1 001225   200020 755100                    STA     J,,AUTO

     1291     5654        /*D*
     1292     5655            o   Loop to parse characters for a delimited string:
     1293     5656
     1294     5657                DELIM = delimiting character
     1295     5658                I = number of characters in the string (excluding
     1296     5659                    doubled embedded delimiters)
     1297     5660                J = position in command text to start scan for next delimiter
     1298     5661                K = position in command text of last delimiter found
     1299     5662        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:198  
     1300     5663    3   DLIM_LOOP:
     1301     5664        /*D*
     1302     5665            o   Fail if no ending delimiter found before end of text.
     1303     5666        */
     1304     5667    3               IF J >= NCHARS

   5667  1 001226   200020 236100       DLIM_LOOP    LDQ     J,,AUTO
         1 001227   200013 116100                    CMPQ    NCHARS,,AUTO
         1 001230   002240 605000 1                  TPL     SYNFAIL

     1305     5668    3               THEN
     1306     5669    3                   GOTO SYNFAIL;
     1307     5670        /*D*
     1308     5671            o   Scan command from current position to end, looking for a delimiter.
     1309     5672        */
     1310     5673    3               CALL INDEX (K, DLIM, P$PCB.TEXT$ -> C$BUF, J) ALTRET (SYNFAIL);

   5673  1 001231   200011 470500                    LDP0    PCB$,,AUTO
         1 001232   000000 471500                    LDP1    0,,PR0
         1 001233   200013 236100                    LDQ     NCHARS,,AUTO
         1 001234   200020 136100                    SBLQ    J,,AUTO
         1 001235   200066 756100                    STQ     TINDX+2,,AUTO
         1 001236   200020 236100                    LDQ     J,,AUTO
         1 001237   200066 720100                    LXL0    TINDX+2,,AUTO
         1 001240   200020 235100                    LDA     J,,AUTO
         1 001241   000100 124545                    SCM     mask='000'O
         1 001242   100000 000010                    ADSC9   0,A,PR1                  cn=0,n=*X0
         1 001243   200034 000001                    ADSC9   DLIM,,AUTO               cn=0,n=1
         1 001244   200021 000100                    ARG     K,,AUTO
         1 001245   200021 056100                    ASQ     K,,AUTO
         1 001246   002240 606400 1                  TTN     SYNFAIL

     1311     5674        /*D*
     1312     5675            o   If a delimiter is found before the end of the command, and
     1313     5676                the next character is also the delimiter, then this pair
     1314     5677                of characters represents a single embedded delimter.  So,
     1315     5678                move the substring from the start of the scan, up to and
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:199  
     1316     5679                including the first delimiter, into a temporary buffer,
     1317     5680                and continue scanning for the final delimiter.
     1318     5681        */
     1319     5682    3               IF K < NCHARS - 1

   5682  1 001247   200013 236100                    LDQ     NCHARS,,AUTO
         1 001250   000001 136007                    SBLQ    1,DL
         1 001251   200021 116100                    CMPQ    K,,AUTO
         1 001252   001315 604400 1                  TMOZ    s:5698

     1320     5683    3               THEN
     1321     5684    3                   IF P$PCB.TEXT$ -> C$BUFA(K+1) = DLIM

   5684  1 001253   000000 471500                    LDP1    0,,PR0
         1 001254   200021 235100                    LDA     K,,AUTO
         1 001255   040100 106505                    CMPC    fill='040'O
         1 001256   100000 200001                    ADSC9   0,A,PR1                  cn=1,n=1
         1 001257   200034 000001                    ADSC9   DLIM,,AUTO               cn=0,n=1
         1 001260   001315 601000 1                  TNZ     s:5698

     1322     5685    4                   THEN DO;

     1323     5686    4                       IF I + K - J + 1 > LENGTHC(G$D.TBUF)

   5686  1 001261   200017 236100                    LDQ     I,,AUTO
         1 001262   200021 036100                    ADLQ    K,,AUTO
         1 001263   200020 136100                    SBLQ    J,,AUTO
         1 001264   000776 116007                    CMPQ    510,DL
         1 001265   002240 605400 1                  TPNZ    SYNFAIL

     1324     5687    4                       THEN
     1325     5688    4                           GOTO SYNFAIL;
     1326     5689    4                       SUBSTR(G$D.TBUF, I, K-J+1) = SUBSTR(P$PCB.TEXT$ -> C$BUF, J);

   5689  1 001266   200021 236100                    LDQ     K,,AUTO
         1 001267   200020 136100                    SBLQ    J,,AUTO
         1 001270   200066 756100                    STQ     TINDX+2,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:200  
         1 001271   200013 236100                    LDQ     NCHARS,,AUTO
         1 001272   200020 136100                    SBLQ    J,,AUTO
         1 001273   200066 720100                    LXL0    TINDX+2,,AUTO
         1 001274   000001 621010                    EAX1    1,X0
         1 001275   000000 622006                    EAX2    0,QL
         1 001276   200020 236100                    LDQ     J,,AUTO
         1 001277   200003 473500                    LDP3    @G$D,,AUTO
         1 001300   200017 235100                    LDA     I,,AUTO
         1 001301   040145 100546                    MLR     fill='040'O
         1 001302   100000 000012                    ADSC9   0,Q,PR1                  cn=0,n=*X2
         1 001303   300020 000011                    ADSC9   16,A,PR3                 cn=0,n=*X1

     1327     5690    4                       I = I + K - J + 1;

   5690  1 001304   200017 236100                    LDQ     I,,AUTO
         1 001305   200021 036100                    ADLQ    K,,AUTO
         1 001306   200020 136100                    SBLQ    J,,AUTO
         1 001307   000001 036007                    ADLQ    1,DL
         1 001310   200017 756100                    STQ     I,,AUTO

     1328     5691    4                       J = K + 2;

   5691  1 001311   200021 235100                    LDA     K,,AUTO
         1 001312   000002 035007                    ADLA    2,DL
         1 001313   200020 755100                    STA     J,,AUTO

     1329     5692    4                       GOTO DLIM_LOOP;

   5692  1 001314   001226 710000 1                  TRA     DLIM_LOOP

     1330     5693    4                   END;
     1331     5694        /*D*
     1332     5695            o   When the final delimiter is found, move the last (or only)
     1333     5696                portion of the string into the temporary buffer.
     1334     5697        */
     1335     5698    3               IF I + K - J > LENGTHC(G$D.TBUF)

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:201  
   5698  1 001315   200017 236100                    LDQ     I,,AUTO
         1 001316   200021 036100                    ADLQ    K,,AUTO
         1 001317   200020 136100                    SBLQ    J,,AUTO
         1 001320   000777 116007                    CMPQ    511,DL
         1 001321   002240 605400 1                  TPNZ    SYNFAIL

     1336     5699    3               THEN
     1337     5700    3                   GOTO SYNFAIL;
     1338     5701    3               SUBSTR(G$D.TBUF, I, K-J) = SUBSTR(P$PCB.TEXT$ -> C$BUF, J);

   5701  1 001322   200021 236100                    LDQ     K,,AUTO
         1 001323   200020 136100                    SBLQ    J,,AUTO
         1 001324   000000 471500                    LDP1    0,,PR0
         1 001325   200066 756100                    STQ     TINDX+2,,AUTO
         1 001326   200013 236100                    LDQ     NCHARS,,AUTO
         1 001327   200020 136100                    SBLQ    J,,AUTO
         1 001330   000000 620006                    EAX0    0,QL
         1 001331   200020 235100                    LDA     J,,AUTO
         1 001332   200003 473500                    LDP3    @G$D,,AUTO
         1 001333   200066 721100                    LXL1    TINDX+2,,AUTO
         1 001334   200017 236100                    LDQ     I,,AUTO
         1 001335   040146 100545                    MLR     fill='040'O
         1 001336   100000 000010                    ADSC9   0,A,PR1                  cn=0,n=*X0
         1 001337   300020 000011                    ADSC9   16,Q,PR3                 cn=0,n=*X1

     1339     5702    3               I = I + K - J;

   5702  1 001340   200017 236100                    LDQ     I,,AUTO
         1 001341   200021 036100                    ADLQ    K,,AUTO
         1 001342   200020 136100                    SBLQ    J,,AUTO
         1 001343   200017 756100                    STQ     I,,AUTO

     1340     5703        /*D*
     1341     5704            o   DSTRING can't use the common lexeme termination logic,
     1342     5705                since the string is taken from the temporary buffer rather
     1343     5706                than the command text, due to the possibility of embedded
     1344     5707                delimiters.  So, logic to check the maximum length and to
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:202  
     1345     5708                create the output block must be duplicated here.
     1346     5709
     1347     5710                Also, RTEXT processing is different for DSTRINGs, because
     1348     5711                here it means to return the entire string, including all
     1349     5712                delimiters.  (RTEXT can be ignored for other lexemes, since
     1350     5713                the same text is returned whether or not it is set.)
     1351     5714        */
     1352     5715    3               IF P$SYM.XTRA OR P$DSTR.LEXTYPE = %LEX_DSTRING#

   5715  1 001344   200010 471500                    LDP1    NODE$,,AUTO
         1 001345   100000 236100                    LDQ     0,,PR1
         1 001346   000040 316003                    CANQ    32,DU
         1 001347   001354 601000 1                  TNZ     s:5717
         1 001350   100000 236100                    LDQ     0,,PR1
         1 001351   000002 376000 2                  ANQ     2
         1 001352   000002 116000 2                  CMPQ    2
         1 001353   001363 601000 1                  TNZ     s:5720

     1353     5716    3               THEN
     1354     5717    3                   IF P$DSTR.MAXL > 0 THEN

   5717  1 001354   100001 236100                    LDQ     1,,PR1
         1 001355   777000 316003                    CANQ    -512,DU
         1 001356   001363 600000 1                  TZE     s:5720

     1355     5718    3                       IF I > P$DSTR.MAXL THEN

   5718  1 001357   100001 236100                    LDQ     1,,PR1
         1 001360   000033 772000                    QRL     27
         1 001361   200017 116100                    CMPQ    I,,AUTO
         1 001362   002240 604000 1                  TMI     SYNFAIL

     1356     5719    3                           GOTO SYNFAIL;
     1357     5720    3               IF P$DSTR.RTEXT

   5720  1 001363   100000 236100                    LDQ     0,,PR1
         1 001364   000200 316003                    CANQ    128,DU
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:203  
         1 001365   001440 600000 1                  TZE     s:5736

     1358     5721    4               THEN DO;

     1359     5722    4                   I = K - G$D.CCPOS + 1;

   5722  1 001366   200021 236100                    LDQ     K,,AUTO
         1 001367   300013 136100                    SBLQ    11,,PR3
         1 001370   000001 036007                    ADLQ    1,DL
         1 001371   200017 756100                    STQ     I,,AUTO

     1360     5723    4                   IF I > 511

   5723  1 001372   000777 116007                    CMPQ    511,DL
         1 001373   002714 605400 1                  TPNZ    RTEXT_TOO_LONG

     1361     5724    4                   THEN
     1362     5725    4                       GOTO RTEXT_TOO_LONG;
     1363     5726    4                   COUNT = (I + 20) / 4;

   5726  1 001374   000024 036007                    ADLQ    20,DL
         1 001375   000004 506007                    DIV     4,DL
         1 001376   200022 756100                    STQ     COUNT,,AUTO

     1364     5727    4                   CALL XUP$GETSPACE (COUNT, Q$, G$D);

   5727  1 001377   200003 236100                    LDQ     @G$D,,AUTO
         1 001400   200070 756100                    STQ     TINDX+4,,AUTO
         1 001401   200024 634500                    EPPR4   Q$,,AUTO
         1 001402   200067 454500                    STP4    TINDX+3,,AUTO
         1 001403   200022 635500                    EPPR5   COUNT,,AUTO
         1 001404   200066 455500                    STP5    TINDX+2,,AUTO
         1 001405   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 001406   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 001407   000000 701000 xent               TSX1    XUP$GETSPACE
         1 001410   000000 011000                    NOP     0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:204  
     1365     5728    4                   BLK$ = Q$;

   5728  1 001411   200024 236100                    LDQ     Q$,,AUTO
         1 001412   200027 756100                    STQ     BLK$,,AUTO

     1366     5729    4                   BLK$ -> OUT$SYM.COUNT = I;

   5729  1 001413   200027 470500                    LDP0    BLK$,,AUTO
         1 001414   200017 236100                    LDQ     I,,AUTO
         1 001415   000033 736000                    QLS     27
         1 001416   000004 552140                    STBQ    4,'40'O,PR0

     1367     5730    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR(Q$ -> OUT$SYM.COUNT);

   5730  1 001417   200024 236100                    LDQ     Q$,,AUTO
         1 001420   000004 036003                    ADLQ    4,DU
         1 001421   000003 756100                    STQ     3,,PR0

     1368     5731    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;

   5731  1 001422   000001 220003                    LDX0    1,DU
         1 001423   000001 740100                    STX0    1,,PR0

     1369     5732    4                   BLK$ -> OUT$SYM.TEXT =

   5732  1 001424   000004 236100                    LDQ     4,,PR0
         1 001425   000033 772000                    QRL     27
         1 001426   200011 471500                    LDP1    PCB$,,AUTO
         1 001427   100000 473500                    LDP3    0,,PR1
         1 001430   200003 474500                    LDP4    @G$D,,AUTO
         1 001431   400013 235100                    LDA     11,,PR4
         1 001432   200017 721100                    LXL1    I,,AUTO
         1 001433   000000 622006                    EAX2    0,QL
         1 001434   040140 100545                    MLR     fill='040'O
         1 001435   300000 000011                    ADSC9   0,A,PR3                  cn=0,n=*X1
         1 001436   000004 200012                    ADSC9   4,,PR0                   cn=1,n=*X2

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:205  
     1370     5733    4                     SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);
     1371     5734    4               END;

   5734  1 001437   001520 710000 1                  TRA     s:5753

     1372     5735    4               ELSE DO;

     1373     5736    4                   COUNT = (I + 20)/4;

   5736  1 001440   200017 236100                    LDQ     I,,AUTO
         1 001441   000024 036007                    ADLQ    20,DL
         1 001442   000004 506007                    DIV     4,DL
         1 001443   200022 756100                    STQ     COUNT,,AUTO

     1374     5737    4                   CALL XUP$GETSPACE(COUNT,Q$,G$D);

   5737  1 001444   200003 236100                    LDQ     @G$D,,AUTO
         1 001445   200070 756100                    STQ     TINDX+4,,AUTO
         1 001446   200024 634500                    EPPR4   Q$,,AUTO
         1 001447   200067 454500                    STP4    TINDX+3,,AUTO
         1 001450   200022 635500                    EPPR5   COUNT,,AUTO
         1 001451   200066 455500                    STP5    TINDX+2,,AUTO
         1 001452   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 001453   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 001454   000000 701000 xent               TSX1    XUP$GETSPACE
         1 001455   000000 011000                    NOP     0

     1375     5738    4                   BLK$ = Q$;

   5738  1 001456   200024 236100                    LDQ     Q$,,AUTO
         1 001457   200027 756100                    STQ     BLK$,,AUTO

     1376     5739    4                   BLK$ -> OUT$SYM.COUNT = I;

   5739  1 001460   200027 470500                    LDP0    BLK$,,AUTO
         1 001461   200017 236100                    LDQ     I,,AUTO
         1 001462   000033 736000                    QLS     27
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:206  
         1 001463   000004 552140                    STBQ    4,'40'O,PR0

     1377     5740    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);

   5740  1 001464   200024 236100                    LDQ     Q$,,AUTO
         1 001465   000004 036003                    ADLQ    4,DU
         1 001466   000003 756100                    STQ     3,,PR0

     1378     5741    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;

   5741  1 001467   000001 220003                    LDX0    1,DU
         1 001470   000001 740100                    STX0    1,,PR0

     1379     5742    4                   IF P$DSTR.MAKEUC

   5742  1 001471   200010 471500                    LDP1    NODE$,,AUTO
         1 001472   100000 236100                    LDQ     0,,PR1
         1 001473   000100 316003                    CANQ    64,DU
         1 001474   001510 600000 1                  TZE     s:5747

     1380     5743    4                   THEN
     1381     5744    4                       CALL XLATE (BLK$ -> OUT$SYM.TEXT, TRANSTBL,

   5744  1 001475   000004 236100                    LDQ     4,,PR0
         1 001476   000033 772000                    QRL     27
         1 001477   200003 473500                    LDP3    @G$D,,AUTO
         1 001500   200017 721100                    LXL1    I,,AUTO
         1 001501   000000 474400 xsym               LDP4    B$XL_UPPER$
         1 001502   000000 622006                    EAX2    0,QL
         1 001503   040140 160540                    MVT     fill='040'O
         1 001504   300020 000011                    ADSC9   16,,PR3                  cn=0,n=*X1
         1 001505   000004 200012                    ADSC9   4,,PR0                   cn=1,n=*X2
         1 001506   400000 000100                    ARG     0,,PR4
         1 001507   001520 710000 1                  TRA     s:5753

     1382     5745    4                         SUBSTR (G$D.TBUF, 0, I));
     1383     5746    4                   ELSE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:207  
     1384     5747    4                       BLK$ -> OUT$SYM.TEXT = SUBSTR(G$D.TBUF, 0, I);

   5747  1 001510   000004 236100                    LDQ     4,,PR0
         1 001511   000033 772000                    QRL     27
         1 001512   200003 473500                    LDP3    @G$D,,AUTO
         1 001513   200017 721100                    LXL1    I,,AUTO
         1 001514   000000 622006                    EAX2    0,QL
         1 001515   040140 100540                    MLR     fill='040'O
         1 001516   300020 000011                    ADSC9   16,,PR3                  cn=0,n=*X1
         1 001517   000004 200012                    ADSC9   4,,PR0                   cn=1,n=*X2

     1385     5748    4               END;

     1386     5749        /*D*
     1387     5750            o   Set current position in command text to just after the final
     1388     5751                delimiter.
     1389     5752        */
     1390     5753    3               G$D.CCPOS = K + 1;

   5753  1 001520   200003 471500                    LDP1    @G$D,,AUTO
         1 001521   200021 235100                    LDA     K,,AUTO
         1 001522   000001 035007                    ADLA    1,DL
         1 001523   100013 755100                    STA     11,,PR1

     1391     5754    3               GOTO LEXSUCCEED;

   5754  1 001524   002544 710000 1                  TRA     LEXSUCCEED

     1392     5755        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:208  
     1393     5756        /*D*
     1394     5757            END metasymbol:
     1395     5758
     1396     5759                This succeeds (syntactically, not lexically) if the current
     1397     5760                position is at the end of the command text, otherwise it fails.
     1398     5761                (Lexical success processing could also be used, but that would
     1399     5762                go through spurious motions to reset the current position,
     1400     5763                which is never advanced in this case.)
     1401     5764        */
     1402     5765    3           CASE(%LEX_END#);

     1403     5766    3               IF G$D.CCPOS < NCHARS THEN GOTO SYNFAIL;

   5766  1 001525   000013 236100                    LDQ     11,,PR0
         1 001526   200013 116100                    CMPQ    NCHARS,,AUTO
         1 001527   002240 604000 1                  TMI     SYNFAIL

     1404     5767    3               GOTO SYNSUCCEED;

   5767  1 001530   001751 710000 1                  TRA     SYNSUCCEED

     1405     5768        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:209  
     1406     5769        /*D*
     1407     5770            BLANK metasymbol:
     1408     5771
     1409     5772                Try to skip over a blank or comment.  If that works, or if
     1410     5773                a blank or comment was eaten after parsing the prior node,
     1411     5774                go indicate lexical success, but bypass logic to reset the
     1412     5775                current position and skip blanks, because we've already done
     1413     5776                that here.
     1414     5777        */
     1415     5778    3           CASE(%LEX_BLANK#);

     1416     5779    3               CALL CHK_CONTUE;

   5779  1 001531   002756 701000 1                  TSX1    CHK_CONTUE
         1 001532   000000 011000                    NOP     0

     1417     5780    3               IF NOT G$D.BLSKIP THEN GOTO SYNFAIL;

   5780  1 001533   200003 470500                    LDP0    @G$D,,AUTO
         1 001534   000015 236100                    LDQ     13,,PR0
         1 001535   000400 316003                    CANQ    256,DU
         1 001536   002240 600000 1                  TZE     SYNFAIL

     1418     5781    3               SAVEPOS=SAVEPOS+G$D.CNTUPOS;

   5781  1 001537   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 001540   000012 036100                    ADLQ    10,,PR0
         1 001541   200005 756100                    STQ     SAVEPOS,,AUTO

     1419     5782    3               GOTO BLANKSUCC;

   5782  1 001542   002600 710000 1                  TRA     BLANKSUCC

     1420     5783        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:210  
     1421     5784        /*D*
     1422     5785            Unknown metasymbol:
     1423     5786
     1424     5787                Abort the parse.
     1425     5788        */
     1426     5789    3           CASE(ELSE);

     1427     5790    3               GOTO BADNODE; /* bad lexical node */;

   5790  1 001543   001736 710000 1                  TRA     BADNODE

     1428     5791    3           END /* DO CASE (P$SYM.LEXTYPE) */;

     1429     5792        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:211  
     1430     5793        /*D*
     1431     5794            LITERAL node:
     1432     5795
     1433     5796                A literal succeeds lexically if it can be parsed up to its
     1434     5797                minimal abbreviation, otherwise it fails.
     1435     5798
     1436     5799                I = number of characters parsed
     1437     5800                J = number of characters in the literal (copied from node
     1438     5801                    for speed of access).
     1439     5802        */
     1440     5803    2       CASE (%TYPE_LITERAL#);

     1441     5804        /*D*
     1442     5805                At the end of the command, or at the failure point for a reparse,
     1443     5806                force failure.
     1444     5807        */
     1445     5808    2           IF G$D.CCPOS = NCHARS

   5808  1 001544   000013 236100                    LDQ     11,,PR0
         1 001545   200013 116100                    CMPQ    NCHARS,,AUTO
         1 001546   002240 600000 1                  TZE     SYNFAIL
         1 001547   200011 473500                    LDP3    PCB$,,AUTO
         1 001550   000000 116003                    CMPQ    0,DU
         1 001551   001557 604000 1                  TMI     s:5817
         1 001552   300012 116100                    CMPQ    10,,PR3
         1 001553   001557 601000 1                  TNZ     s:5817
         1 001554   300005 236100                    LDQ     5,,PR3
         1 001555   040000 316007                    CANQ    16384,DL
         1 001556   002240 601000 1                  TNZ     SYNFAIL

     1446     5809    2             OR (G$D.CCPOS = P$PCB.HI_CHAR AND P$PCB.NXT)
     1447     5810    2           THEN
     1448     5811    2               GOTO SYNFAIL;
     1449     5812        /*D*
     1450     5813                Set number of matching characters needed to succeed, and put
     1451     5814                text to match in the temporary buffer (translating it to upper
     1452     5815                case if case insensitive conversion is to be done).
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:212  
     1453     5816        */
     1454     5817    2           J = P$LIT.COUNT;

   5817  1 001557   100001 236100                    LDQ     1,,PR1
         1 001560   000033 772000                    QRL     27
         1 001561   200020 756100                    STQ     J,,AUTO

     1455     5818    2           IF P$LIT.UPRLOWR

   5818  1 001562   100000 236100                    LDQ     0,,PR1
         1 001563   000100 316003                    CANQ    64,DU
         1 001564   001601 600000 1                  TZE     s:5823

     1456     5819    2           THEN
     1457     5820    2               CALL XLATE (SUBSTR(G$D.TBUF, 0, J), TRANSTBL,

   5820  1 001565   300000 474500                    LDP4    0,,PR3
         1 001566   200013 236100                    LDQ     NCHARS,,AUTO
         1 001567   000013 136100                    SBLQ    11,,PR0
         1 001570   000013 235100                    LDA     11,,PR0
         1 001571   000000 620006                    EAX0    0,QL
         1 001572   000000 475400 xsym               LDP5    B$XL_UPPER$
         1 001573   200020 721100                    LXL1    J,,AUTO
         1 001574   040140 160545                    MVT     fill='040'O
         1 001575   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 001576   000020 000011                    ADSC9   16,,PR0                  cn=0,n=*X1
         1 001577   500000 000100                    ARG     0,,PR5
         1 001600   001612 710000 1                  TRA     s:5824

     1458     5821    2                 SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS));
     1459     5822    2           ELSE
     1460     5823    2               SUBSTR(G$D.TBUF, 0, J) = SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CCPOS);

   5823  1 001601   300000 474500                    LDP4    0,,PR3
         1 001602   200013 236100                    LDQ     NCHARS,,AUTO
         1 001603   000013 136100                    SBLQ    11,,PR0
         1 001604   000013 235100                    LDA     11,,PR0
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:213  
         1 001605   000000 620006                    EAX0    0,QL
         1 001606   200020 721100                    LXL1    J,,AUTO
         1 001607   040140 100545                    MLR     fill='040'O
         1 001610   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 001611   000020 000011                    ADSC9   16,,PR0                  cn=0,n=*X1

     1461     5824    2           IF P$LIT.ABREV = 0

   5824  1 001612   100000 236100                    LDQ     0,,PR1
         1 001613   000005 316000 2                  CANQ    5
         1 001614   001620 601000 1                  TNZ     s:5828

     1462     5825    2           THEN
     1463     5826    2               I = J;

   5826  1 001615   200020 235100                    LDA     J,,AUTO
         1 001616   200017 755100                    STA     I,,AUTO
         1 001617   001624 710000 1                  TRA     s:5833

     1464     5827    2           ELSE
     1465     5828    2               I = P$LIT.ABREV;

   5828  1 001620   100000 236100                    LDQ     0,,PR1
         1 001621   000020 772000                    QRL     16
         1 001622   000377 376007                    ANQ     255,DL
         1 001623   200017 756100                    STQ     I,,AUTO

     1466     5829        /*D*
     1467     5830                Fail if the minimum number of characters needed exceeds the
     1468     5831                number of characters left in the command text.
     1469     5832        */
     1470     5833    2           IF I > NCHARS - G$D.CCPOS

   5833  1 001624   200013 236100                    LDQ     NCHARS,,AUTO
         1 001625   000013 136100                    SBLQ    11,,PR0
         1 001626   200017 116100                    CMPQ    I,,AUTO
         1 001627   002240 604000 1                  TMI     SYNFAIL
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:214  

     1471     5834    2           THEN
     1472     5835    2               GOTO SYNFAIL;
     1473     5836        /*D*
     1474     5837                Fail if the minimum number of characters needed doesn't match
     1475     5838                the literal text.
     1476     5839        */
     1477     5840    2           IF SUBSTR(G$D.TBUF, 0, I) ~= SUBSTR(P$LIT.TEXT, 0, I)

   5840  1 001630   100001 236100                    LDQ     1,,PR1
         1 001631   000033 772000                    QRL     27
         1 001632   200017 720100                    LXL0    I,,AUTO
         1 001633   040140 106540                    CMPC    fill='040'O
         1 001634   000020 000010                    ADSC9   16,,PR0                  cn=0,n=*X0
         1 001635   100001 200010                    ADSC9   1,,PR1                   cn=1,n=*X0
         1 001636   002240 601000 1                  TNZ     SYNFAIL

     1478     5841    2           THEN
     1479     5842    2               GOTO SYNFAIL;
     1480     5843        /*D*
     1481     5844                Parse any characters beyond the minimum that also match the
     1482     5845                literal text.
     1483     5846        */
     1484     5847    3           DO WHILE (I < J);

   5847  1 001637   200017 236100                    LDQ     I,,AUTO
         1 001640   200020 116100                    CMPQ    J,,AUTO
         1 001641   001657 605000 1                  TPL     s:5860

     1485     5848    3               IF SUBSTR(G$D.TBUF,I,1) ~= SUBSTR(P$LIT.TEXT,I,1)

   5848  1 001642   200010 470500                    LDP0    NODE$,,AUTO
         1 001643   000001 236100                    LDQ     1,,PR0
         1 001644   000033 772000                    QRL     27
         1 001645   200003 471500                    LDP1    @G$D,,AUTO
         1 001646   200017 235100                    LDA     I,,AUTO
         1 001647   040105 106505                    CMPC    fill='040'O
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:215  
         1 001650   100020 000001                    ADSC9   16,A,PR1                 cn=0,n=1
         1 001651   000001 200001                    ADSC9   1,A,PR0                  cn=1,n=1
         1 001652   001657 601000 1                  TNZ     s:5860

     1486     5849    3               THEN
     1487     5850    3                   EXIT;
     1488     5851    3               I=I+1;

   5851  1 001653   200017 054100                    AOS     I,,AUTO

     1489     5852    3           END;

   5852  1 001654   200017 236100                    LDQ     I,,AUTO
         1 001655   200020 116100                    CMPQ    J,,AUTO
         1 001656   001642 604000 1                  TMI     s:5848

     1490     5853        /*D*
     1491     5854                If an RTEXT block is to be returned, allocate a symbol block
     1492     5855                and fill in the fields specific to a symbol block. (Common
     1493     5856                fields will be filled in during success processing; if a
     1494     5857                normal output block is to be returned, the block itself will
     1495     5858                also be allocated by common success logic.)
     1496     5859        */
     1497     5860    2           IF P$LIT.O_F AND P$LIT.RTEXT

   5860  1 001657   200010 470500                    LDP0    NODE$,,AUTO
         1 001660   000000 236100                    LDQ     0,,PR0
         1 001661   004000 316003                    CANQ    2048,DU
         1 001662   001731 600000 1                  TZE     s:5874
         1 001663   000200 316003                    CANQ    128,DU
         1 001664   001731 600000 1                  TZE     s:5874

     1498     5861    3           THEN DO;

     1499     5862    3               COUNT = (I + 20) / 4;

   5862  1 001665   200017 236100                    LDQ     I,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:216  
         1 001666   000024 036007                    ADLQ    20,DL
         1 001667   000004 506007                    DIV     4,DL
         1 001670   200022 756100                    STQ     COUNT,,AUTO

     1500     5863    3               CALL XUP$GETSPACE (COUNT, Q$, G$D);

   5863  1 001671   200003 236100                    LDQ     @G$D,,AUTO
         1 001672   200070 756100                    STQ     TINDX+4,,AUTO
         1 001673   200024 631500                    EPPR1   Q$,,AUTO
         1 001674   200067 451500                    STP1    TINDX+3,,AUTO
         1 001675   200022 633500                    EPPR3   COUNT,,AUTO
         1 001676   200066 453500                    STP3    TINDX+2,,AUTO
         1 001677   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 001700   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 001701   000000 701000 xent               TSX1    XUP$GETSPACE
         1 001702   000000 011000                    NOP     0

     1501     5864    3               BLK$ = Q$;

   5864  1 001703   200024 236100                    LDQ     Q$,,AUTO
         1 001704   200027 756100                    STQ     BLK$,,AUTO

     1502     5865    3               BLK$ -> OUT$SYM.NSUBLKS = 1;

   5865  1 001705   000001 220003                    LDX0    1,DU
         1 001706   200027 470500                    LDP0    BLK$,,AUTO
         1 001707   000001 740100                    STX0    1,,PR0

     1503     5866    3               BLK$ -> OUT$SYM.TEXTC$ = ADDR(Q$ -> OUT$SYM.COUNT);

   5866  1 001710   200024 236100                    LDQ     Q$,,AUTO
         1 001711   000004 036003                    ADLQ    4,DU
         1 001712   000003 756100                    STQ     3,,PR0

     1504     5867    3               BLK$ -> OUT$SYM.COUNT = I;

   5867  1 001713   200017 236100                    LDQ     I,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:217  
         1 001714   000033 736000                    QLS     27
         1 001715   000004 552140                    STBQ    4,'40'O,PR0

     1505     5868    3               BLK$ -> OUT$SYM.TEXT = SUBSTR (P$PCB.TEXT$ -> C$BUF, G$D.CCPOS, I);

   5868  1 001716   000004 236100                    LDQ     4,,PR0
         1 001717   000033 772000                    QRL     27
         1 001720   200011 471500                    LDP1    PCB$,,AUTO
         1 001721   100000 473500                    LDP3    0,,PR1
         1 001722   200003 474500                    LDP4    @G$D,,AUTO
         1 001723   400013 235100                    LDA     11,,PR4
         1 001724   200017 721100                    LXL1    I,,AUTO
         1 001725   000000 622006                    EAX2    0,QL
         1 001726   040140 100545                    MLR     fill='040'O
         1 001727   300000 000011                    ADSC9   0,A,PR3                  cn=0,n=*X1
         1 001730   000004 200012                    ADSC9   4,,PR0                   cn=1,n=*X2

     1506     5869    3           END;

     1507     5870        /*D*
     1508     5871                Update current position to point past literal just parsed,
     1509     5872                and go to common lexical success processing.
     1510     5873        */
     1511     5874    2           G$D.CCPOS = G$D.CCPOS + I;

   5874  1 001731   200003 470500                    LDP0    @G$D,,AUTO
         1 001732   000013 236100                    LDQ     11,,PR0
         1 001733   200017 036100                    ADLQ    I,,AUTO
         1 001734   000013 756100                    STQ     11,,PR0

     1512     5875    2           GOTO LEXSUCCEED;

   5875  1 001735   002544 710000 1                  TRA     LEXSUCCEED

     1513     5876        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:218  
     1514     5877        /*D*
     1515     5878            UNKNOWN node:  Abort the parse.
     1516     5879        */
     1517     5880    2       CASE (ELSE);

     1518     5881
     1519     5882        /*E*          ERROR:   XUP-E$BADNODE-C
     1520     5883                      MESSAGE:    Illegal node encountered by X$PARSE
     1521     5884                      MESSAGE1: An illegal or undefined node was encountered by X$PARSE.
     1522     5885                                This may have one of three causes:
     1523     5886
     1524     5887                                1) The node's TYPE or LEXTYPE field is invalid;
     1525     5888                                2) The node's address is ADDR(NIL);
     1526     5889                                3) The node's address is at the base of the instruction
     1527     5890                                   segment, which means that the node is probably an
     1528     5891                                   unsatisfied SYMREF.
     1529     5892        */
     1530     5893
     1531     5894    2   BADNODE:
     1532     5895    2           G$D.PCB$->P$PCB.ERROR = BAD_NODE;

   5895  1 001736   000000 471500       BADNODE      LDP1    0,,PR0
         1 001737   000000 236000 xsym               LDQ     BAD_NODE
         1 001740   100006 756100                    STQ     6,,PR1

     1533     5896    2           P$PCB.HINODE$ = ADDR(P$NODE);

   5896  1 001741   200010 236100                    LDQ     NODE$,,AUTO
         1 001742   200011 471500                    LDP1    PCB$,,AUTO
         1 001743   100013 756100                    STQ     11,,PR1

     1534     5897    2           P$PCB.HI_CHAR = G$D.CCPOS;

   5897  1 001744   000013 235100                    LDA     11,,PR0
         1 001745   100012 755100                    STA     10,,PR1

     1535     5898    2           UNWIND TO G$D.ERROR;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:219  

   5898  1 001746   000002 237300                    LDAQ  ! 2,,PR0
         1 001747   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 001750   000000 000200                    ZERO    0,128

     1536     5899    2       END;     /* END OF NODE PROCESSING CASE GROUP */

     1537     5900        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:220  
     1538     5901        /*D*
     1539     5902            Syntactic Success Processing:
     1540     5903
     1541     5904                Control transfers to this point when a non-lexical node is
     1542     5905                successfully parsed.  Syntactic success is generally used
     1543     5906                when a node that can have subnodes is parsed.  If it generates
     1544     5907                an output block, it is an OUT$BLK.  No logic to change the
     1545     5908                current position is needed here; all progress through the
     1546     5909                command text is made during lexical success processing of the
     1547     5910                subnodes of syntax nodes.
     1548     5911        */
     1549     5912    1   SYNSUCCEED:
     1550     5913        /*D*
     1551     5914            If this is a repeating node, signal that repetition processing
     1552     5915            applies, now that at least one repetition has been successfully
     1553     5916            parsed.
     1554     5917        */
     1555     5918    1       IF P$NODE.RPEAT = '1'B THEN

   5918  1 001751   200010 470500       SYNSUCCEED   LDP0    NODE$,,AUTO
         1 001752   000000 430100                    FSZN    0,,PR0
         1 001753   001756 605000 1                  TPL     RPEATSUC

     1556     5919    1           REPEAT = '1'B;

   5919  1 001754   400000 236003                    LDQ     -131072,DU
         1 001755   200030 756100                    STQ     REPEAT,,AUTO

     1557     5920        /*D*
     1558     5921            For a repeated node, control transfers back to this point after
     1559     5922            failure processing for the last attempted repetition, in order
     1560     5923            to build the output block for the node.
     1561     5924        */
     1562     5925    1   RPEATSUC:
     1563     5926        /*D*
     1564     5927            Number of subblocks for this node's output block is the number of
     1565     5928            parse stack entries added since this invocation (or repetition)
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:221  
     1566     5929            of X$PARS began.
     1567     5930        */
     1568     5931    1       NSUBLKS = P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$) - MY_STACK;

   5931  1 001756   200011 470500       RPEATSUC     LDP0    PCB$,,AUTO
         1 001757   000002 236100                    LDQ     2,,PR0
         1 001760   000022 772000                    QRL     18
         1 001761   200066 756100                    STQ     TINDX+2,,AUTO
         1 001762   200003 471500                    LDP1    @G$D,,AUTO
         1 001763   100010 236100                    LDQ     8,,PR1
         1 001764   000022 772000                    QRL     18
         1 001765   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 001766   200067 756100                    STQ     TINDX+3,,AUTO
         1 001767   000005 236100                    LDQ     5,,PR0
         1 001770   000022 772000                    QRL     18
         1 001771   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 001772   200015 136100                    SBLQ    MY_STACK,,AUTO
         1 001773   200025 756100                    STQ     NSUBLKS,,AUTO

     1569     5932        /*D*
     1570     5933            Create an output block is the node being parsed asks for one,
     1571     5934            or if there is more than one subblock and an uncompressed output
     1572     5935            tree is requested.
     1573     5936        */
     1574     5937    1       IF (NSUBLKS > 1 AND NOT P$PCB.CMPRS) OR

   5937  1 001774   000001 116007                    CMPQ    1,DL
         1 001775   002001 604400 1                  TMOZ    s:5937+5
         1 001776   000005 236100                    LDQ     5,,PR0
         1 001777   400000 316007                    CANQ    -131072,DL
         1 002000   002007 600000 1                  TZE     s:5944
         1 002001   200010 473500                    LDP3    NODE$,,AUTO
         1 002002   300000 236100                    LDQ     0,,PR3
         1 002003   004000 316003                    CANQ    2048,DU
         1 002004   002205 600000 1                  TZE     s:6039
         1 002005   200030 234100                    SZN     REPEAT,,AUTO
         1 002006   002205 604000 1                  TMI     s:6039
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:222  

     1575     5938    1         (P$NODE.O_F AND NOT REPEAT) THEN
     1576     5939    2       DO;

     1577     5940        /*D*
     1578     5941            o   If there is only one temporary subblock for this node, pop it off
     1579     5942               the parse stack and make it the output block for this node.
     1580     5943        */
     1581     5944    2           IF NSUBLKS = 1

   5944  1 002007   200025 235100                    LDA     NSUBLKS,,AUTO
         1 002010   000001 115007                    CMPA    1,DL
         1 002011   002024 601000 1                  TNZ     s:5956
         1 002012   100010 473500                    LDP3    8,,PR1
         1 002013   300000 474500                    LDP4    0,,PR3
         1 002014   400000 234100                    SZN     0,,PR4
         1 002015   002024 605000 1                  TPL     s:5956

     1582     5945    2             AND G$D.STACKTOP$->STACKARY$(0)->OUT$BLK.TEMP THEN
     1583     5946    3           DO;

     1584     5947    3               BLK$ = G$D.STACKTOP$->STACKARY$(0);

   5947  1 002016   300000 236100                    LDQ     0,,PR3
         1 002017   200027 756100                    STQ     BLK$,,AUTO

     1585     5948    3               G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);

   5948  1 002020   100010 236100                    LDQ     8,,PR1
         1 002021   000001 036003                    ADLQ    1,DU
         1 002022   100010 756100                    STQ     8,,PR1

     1586     5949    3           END;

   5949  1 002023   002164 710000 1                  TRA     s:6025

     1587     5950    2           ELSE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:223  
     1588     5951    3           DO;

     1589     5952        /*D*
     1590     5953            o   Otherwise, a new output block must be allocated.  Logic for doing
     1591     5954                this differs for RTEXT nodes and others.
     1592     5955        */
     1593     5956    3               IF P$NODE.RTEXT

   5956  1 002024   200010 473500                    LDP3    NODE$,,AUTO
         1 002025   300000 236100                    LDQ     0,,PR3
         1 002026   000200 316003                    CANQ    128,DU
         1 002027   002124 600000 1                  TZE     s:6004

     1594     5957    4               THEN DO;

     1595     5958        /*D*
     1596     5959            o   For an RTEXT node...
     1597     5960
     1598     5961                o   If the text to be returned spans lines and continuation text
     1599     5962                    has overlaid part of that text, we can't return the full text.
     1600     5963        */
     1601     5964    4                   IF SAVEPOS + G$D.CNTUPOS > G$D.CLEXPOS

   5964  1 002030   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 002031   100012 036100                    ADLQ    10,,PR1
         1 002032   100014 116100                    CMPQ    12,,PR1
         1 002033   002705 605400 1                  TPNZ    CANT_RETURN_TEXT

     1602     5965    4                   THEN
     1603     5966    4                       GOTO CANT_RETURN_TEXT;
     1604     5967        /*D*
     1605     5968                o   Free any output blocks that have been created for the node.
     1606     5969        */
     1607     5970    4                   CALL FREESTACK (NSUBLKS);

   5970  1 002034   200025 634500                    EPPR4   NSUBLKS,,AUTO
         1 002035   200051 454500                    STP4    J+2,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:224  
         1 002036   004052 701000 1                  TSX1    FREESTACK
         1 002037   000000 011000                    NOP     0

     1608     5971        /*D*
     1609     5972                o   Compute number of characters parsed for this node; abort the
     1610     5973                    parse if this size is too big.
     1611     5974        */
     1612     5975    4                   I = G$D.CLEXPOS - G$D.CNTUPOS - SSAVEPOS;

   5975  1 002040   200003 470500                    LDP0    @G$D,,AUTO
         1 002041   000014 236100                    LDQ     12,,PR0
         1 002042   000012 136100                    SBLQ    10,,PR0
         1 002043   200004 136100                    SBLQ    SSAVEPOS,,AUTO
         1 002044   200017 756100                    STQ     I,,AUTO

     1613     5976    4                   IF I > 511

   5976  1 002045   000777 116007                    CMPQ    511,DL
         1 002046   002714 605400 1                  TPNZ    RTEXT_TOO_LONG

     1614     5977    4                   THEN
     1615     5978    4                       GOTO RTEXT_TOO_LONG;
     1616     5979        /*D*
     1617     5980            o       Allocate an symbol output block large enough to hold the text
     1618     5981                    to be reuturned, fill it in, and continue as if this were
     1619     5982                    lexical success.
     1620     5983        */
     1621     5984    4                   COUNT = (I + 20) / 4;

   5984  1 002047   000024 036007                    ADLQ    20,DL
         1 002050   000004 506007                    DIV     4,DL
         1 002051   200022 756100                    STQ     COUNT,,AUTO

     1622     5985    4                   CALL XUP$GETSPACE (COUNT, Q$, G$D);

   5985  1 002052   200003 236100                    LDQ     @G$D,,AUTO
         1 002053   200070 756100                    STQ     TINDX+4,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:225  
         1 002054   200024 631500                    EPPR1   Q$,,AUTO
         1 002055   200067 451500                    STP1    TINDX+3,,AUTO
         1 002056   200022 633500                    EPPR3   COUNT,,AUTO
         1 002057   200066 453500                    STP3    TINDX+2,,AUTO
         1 002060   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 002061   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 002062   000000 701000 xent               TSX1    XUP$GETSPACE
         1 002063   000000 011000                    NOP     0

     1623     5986    4                   BLK$ = Q$;

   5986  1 002064   200024 236100                    LDQ     Q$,,AUTO
         1 002065   200027 756100                    STQ     BLK$,,AUTO

     1624     5987    4                   BLK$ -> OUT$SYM.COUNT = I;

   5987  1 002066   200027 470500                    LDP0    BLK$,,AUTO
         1 002067   200017 236100                    LDQ     I,,AUTO
         1 002070   000033 736000                    QLS     27
         1 002071   000004 552140                    STBQ    4,'40'O,PR0

     1625     5988    4                   BLK$ -> OUT$SYM.TEXT =

   5988  1 002072   000004 236100                    LDQ     4,,PR0
         1 002073   000033 772000                    QRL     27
         1 002074   200011 471500                    LDP1    PCB$,,AUTO
         1 002075   100000 473500                    LDP3    0,,PR1
         1 002076   200003 474500                    LDP4    @G$D,,AUTO
         1 002077   000000 620006                    EAX0    0,QL
         1 002100   400012 236100                    LDQ     10,,PR4
         1 002101   200004 036100                    ADLQ    SSAVEPOS,,AUTO
         1 002102   200017 721100                    LXL1    I,,AUTO
         1 002103   040140 100546                    MLR     fill='040'O
         1 002104   300000 000011                    ADSC9   0,Q,PR3                  cn=0,n=*X1
         1 002105   000004 200010                    ADSC9   4,,PR0                   cn=1,n=*X0

     1626     5989    4                     SUBSTR(P$PCB.TEXT$ -> C$BUF, G$D.CNTUPOS + SSAVEPOS, I);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:226  
     1627     5990    4                   BLK$ -> OUT$SYM.TEXTC$ = ADDR (Q$ -> OUT$SYM.COUNT);

   5990  1 002106   200024 236100                    LDQ     Q$,,AUTO
         1 002107   000004 036003                    ADLQ    4,DU
         1 002110   000003 756100                    STQ     3,,PR0

     1628     5991    4                   BLK$ -> OUT$SYM.NSUBLKS = 1;

   5991  1 002111   000001 221003                    LDX1    1,DU
         1 002112   000001 741100                    STX1    1,,PR0

     1629     5992    4                   BLK$ -> OUT$SYM.CODE = P$NODE.CODE;

   5992  1 002113   200010 473500                    LDP3    NODE$,,AUTO
         1 002114   300000 722100                    LXL2    0,,PR3
         1 002115   177777 362003                    ANX2    65535,DU
         1 002116   000000 442100                    SXL2    0,,PR0

     1630     5993    4                   BLK$ -> OUT$SYM.CPOS = SSAVEPOS;

   5993  1 002117   200004 235100                    LDA     SSAVEPOS,,AUTO
         1 002120   000002 755100                    STA     2,,PR0

     1631     5994    4                   BLK$ -> OUT$SYM.NDTYPE = %RTEXT#;

   5994  1 002121   000034 236003                    LDQ     28,DU
         1 002122   000000 752110                    STCQ    0,'10'O,PR0

     1632     5995    4                   GOTO LEXSUCC2;

   5995  1 002123   002642 710000 1                  TRA     LEXSUCC2

     1633     5996    4               END;
     1634     5997    4               ELSE DO;

     1635     5998        /*D*
     1636     5999            o   If this is a normal (non-RTEXT) node:
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:227  
     1637     6000
     1638     6001                o   Allocate an output block large enough hold pointers to all
     1639     6002                    subblocks, and set the subblock count.
     1640     6003        */
     1641     6004    4                   CALL XUP$GETSPACE(NSUBLKS + 3,Q$,G$D);

   6004  1 002124   000003 035007                    ADLA    3,DL
         1 002125   200066 755100                    STA     TINDX+2,,AUTO
         1 002126   200003 236100                    LDQ     @G$D,,AUTO
         1 002127   200071 756100                    STQ     TINDX+5,,AUTO
         1 002130   200024 634500                    EPPR4   Q$,,AUTO
         1 002131   200070 454500                    STP4    TINDX+4,,AUTO
         1 002132   200066 635500                    EPPR5   TINDX+2,,AUTO
         1 002133   200067 455500                    STP5    TINDX+3,,AUTO
         1 002134   200067 630500                    EPPR0   TINDX+3,,AUTO
         1 002135   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 002136   000000 701000 xent               TSX1    XUP$GETSPACE
         1 002137   000000 011000                    NOP     0

     1642     6005    4                   BLK$ = Q$;

   6005  1 002140   200024 236100                    LDQ     Q$,,AUTO
         1 002141   200027 756100                    STQ     BLK$,,AUTO

     1643     6006        /*D*
     1644     6007                o   Pop all subblock pointers off the parse stack and copy
     1645     6008                    them to the new block.
     1646     6009        */
     1647     6010    4                   BLK$->OUT$BLK.NSUBLKS = NSUBLKS;

   6010  1 002142   200025 720100                    LXL0    NSUBLKS,,AUTO
         1 002143   200027 470500                    LDP0    BLK$,,AUTO
         1 002144   000001 740100                    STX0    1,,PR0

     1648     6011    5                   DO WHILE(NSUBLKS > 0);

   6011  1 002145   200025 235100                    LDA     NSUBLKS,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:228  
         1 002146   002164 604400 1                  TMOZ    s:6025

     1649     6012    5                       NSUBLKS = NSUBLKS - 1;

   6012  1 002147   000001 336007                    LCQ     1,DL
         1 002150   200025 056100                    ASQ     NSUBLKS,,AUTO

     1650     6013    5                       BLK$->OUT$BLK.SUBLK$(NSUBLKS) =

   6013  1 002151   200003 470500                    LDP0    @G$D,,AUTO
         1 002152   000010 471500                    LDP1    8,,PR0
         1 002153   100000 236100                    LDQ     0,,PR1
         1 002154   200027 473500                    LDP3    BLK$,,AUTO
         1 002155   200025 720100                    LXL0    NSUBLKS,,AUTO
         1 002156   300003 756110                    STQ     3,X0,PR3

     1651     6014    5                         G$D.STACKTOP$->STACKARY$(0);
     1652     6015    5                       G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,1);

   6015  1 002157   000010 236100                    LDQ     8,,PR0
         1 002160   000001 036003                    ADLQ    1,DU
         1 002161   000010 756100                    STQ     8,,PR0

     1653     6016    5                   END;

   6016  1 002162   200025 235100                    LDA     NSUBLKS,,AUTO
         1 002163   002147 605400 1                  TPNZ    s:6012

     1654     6017    4               END;

     1655     6018    3           END;

     1656     6019        /*D*
     1657     6020            o   Set the temporary block flag if an output block wasn't explicitly
     1658     6021                requested for the node, and reset the flag if the block was
     1659     6022                explicitly requested (since this block could be a temporary
     1660     6023                block created for a subnode).
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:229  
     1661     6024        */
     1662     6025    2           IF P$NODE.O_F = '1'B THEN

   6025  1 002164   200010 470500                    LDP0    NODE$,,AUTO
         1 002165   000000 236100                    LDQ     0,,PR0
         1 002166   004000 316003                    CANQ    2048,DU
         1 002167   002174 600000 1                  TZE     s:6028

     1663     6026    2               BLK$->OUT$BLK.TEMP = '0'B;

   6026  1 002170   200027 471500                    LDP1    BLK$,,AUTO
         1 002171   000031 236000 xsym               LDQ     B_VECTNIL+25
         1 002172   100000 356100                    ANSQ    0,,PR1
         1 002173   002177 710000 1                  TRA     s:6032

     1664     6027    2           ELSE
     1665     6028    2               BLK$->OUT$BLK.TEMP = '1'B;

   6028  1 002174   200027 471500                    LDP1    BLK$,,AUTO
         1 002175   400000 236003                    LDQ     -131072,DU
         1 002176   100000 256100                    ORSQ    0,,PR1

     1666     6029        /*D*
     1667     6030            o   Fill in remaining output block fields.
     1668     6031        */
     1669     6032    2           BLK$->OUT$BLK.CPOS = SAVEPOS+G$D.CNTUPOS;

   6032  1 002177   200003 473500                    LDP3    @G$D,,AUTO
         1 002200   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 002201   300012 036100                    ADLQ    10,,PR3
         1 002202   100002 756100                    STQ     2,,PR1

     1670     6033    2           CALL OUTBLK_COMMON;

   6033  1 002203   003657 701000 1                  TSX1    OUTBLK_COMMON
         1 002204   000000 011000                    NOP     0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:230  
     1671     6034    2       END;

     1672     6035        /*D*
     1673     6036            Do common success processing. (Call the success exit routine if
     1674     6037            necessary, and push the new block, if any, on to the parse stack).
     1675     6038        */
     1676     6039    1       CALL SUCCEED_BLK;

   6039  1 002205   004105 701000 1                  TSX1    SUCCEED_BLK
         1 002206   000000 011000                    NOP     0

     1677     6040    2       DO CASE (I);

   6040  1 002207   200017 235100                    LDA     I,,AUTO
         1 002210   000003 115007                    CMPA    3,DL
         1 002211   002213 602005 1                  TNC     s:6040+4,AL
         1 002212   002220 710000 1                  TRA     s:6052
         1 002213   002220 710000 1                  TRA     s:6052
         1 002214   002216 710000 1                  TRA     s:6042
         1 002215   002217 710000 1                  TRA     s:6044

     1678     6041    2       CASE (1);   /* success routine returned REJECT */

     1679     6042    2           GOTO SYNFAIL1;

   6042  1 002216   002242 710000 1                  TRA     SYNFAIL1

     1680     6043    2       CASE (2);   /* success routine returned RETRY */

     1681     6044    2           GOTO REPARSE;

   6044  1 002217   000057 710000 1                  TRA     REPARSE

     1682     6045    2       END;

     1683     6046        /*D*
     1684     6047            If this is a repeating node, go back to try to parse another
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:231  
     1685     6048            repetition (but, if this repetition managed to succeed without
     1686     6049            advancing the position within the command, fail instead, to avoid
     1687     6050            an infinite loop).
     1688     6051        */
     1689     6052    1       IF REPEAT THEN

   6052  1 002220   200030 234100                    SZN     REPEAT,,AUTO
         1 002221   002232 605000 1                  TPL     ENDSUC

     1690     6053    2       DO;

     1691     6054    2           IF SAVEPOS~=G$D.CCPOS-G$D.CNTUPOS THEN

   6054  1 002222   200003 470500                    LDP0    @G$D,,AUTO
         1 002223   000013 236100                    LDQ     11,,PR0
         1 002224   000012 136100                    SBLQ    10,,PR0
         1 002225   200005 116100                    CMPQ    SAVEPOS,,AUTO
         1 002226   000057 601000 1                  TNZ     REPARSE

     1692     6055    2               GOTO REPARSE;
     1693     6056    2           BLK$=ADDR(NIL);

   6056  1 002227   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 002230   200027 756100                    STQ     BLK$,,AUTO

     1694     6057    2           GOTO SYNFAIL1;

   6057  1 002231   002242 710000 1                  TRA     SYNFAIL1

     1695     6058    2       END;
     1696     6059        /*D*
     1697     6060            If this node could have reducing alternatives under it, release
     1698     6061            any R$BLK flag blocks that were created for this node.
     1699     6062        */
     1700     6063    1   ENDSUC:
     1701     6064    1       IF RDUCE$ ~= ADDR(G$D) THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:232  
   6064  1 002232   200032 236100       ENDSUC       LDQ     RDUCE$,,AUTO
         1 002233   200003 116100                    CMPQ    @G$D,,AUTO
         1 002234   002237 600000 1                  TZE     s:6069

     1702     6065    1           CALL RELRED;

   6065  1 002235   002725 701000 1                  TSX1    RELRED
         1 002236   000000 011000                    NOP     0

     1703     6066        /*D*
     1704     6067            That's it!  Return normally to indicate a successful parse.
     1705     6068        */
     1706     6069    1       RETURN;

   6069  1 002237   000000 702200 xent               TSX2  ! X66_ARET

     1707     6070        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:233  
     1708     6071        /*D*
     1709     6072            Failure Processing:
     1710     6073
     1711     6074                Control transfers to this point when a node cannot be
     1712     6075                successfully parsed.  The same failure processing logic
     1713     6076                is used for "syntactic" and "lexical" nodes, although
     1714     6077                some parts of it apply more to one type than the other.
     1715     6078        */
     1716     6079    1   SYNFAIL:
     1717     6080        /*D*
     1718     6081            Start by resetting the current position in the command back to
     1719     6082            what it was at the beginning of the attempted parse.
     1720     6083
     1721     6084            This is skipped if the node fails due to rejection by a user exit
     1722     6085            routine (since then the position is already reset based on what
     1723     6086            exit routine returned) or if failure is due to a repeating node
     1724     6087            succeeding without advancing the position (in which case nothing
     1725     6088            needs to be reset).
     1726     6089        */
     1727     6090    1       CALL SAVE_POS;

   6090  1 002240   003403 701000 1     SYNFAIL      TSX1    SAVE_POS
         1 002241   000000 011000                    NOP     0

   6064  1 002242                       SYNFAIL1     null
     1728     6091    1   SYNFAIL1:;
     1729     6092    1       REPEATABLE = '0'B;

   6092  1 002242   200031 450100                    STZ     REPEATABLE,,AUTO

     1730     6093        /*D*
     1731     6094            Release any output blocks created for this node (or, in the case
     1732     6095            of a repeating node, for the final attempted repetition).
     1733     6096        */
     1734     6097    1       I = (P$PCB.WKSZ - POFFW(G$D.STACKTOP$, P$PCB.WORK$)) - MY_STACK;

   6097  1 002243   200011 470500                    LDP0    PCB$,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:234  
         1 002244   000002 236100                    LDQ     2,,PR0
         1 002245   000022 772000                    QRL     18
         1 002246   200066 756100                    STQ     TINDX+2,,AUTO
         1 002247   200003 471500                    LDP1    @G$D,,AUTO
         1 002250   100010 236100                    LDQ     8,,PR1
         1 002251   000022 772000                    QRL     18
         1 002252   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 002253   200067 756100                    STQ     TINDX+3,,AUTO
         1 002254   000005 236100                    LDQ     5,,PR0
         1 002255   000022 772000                    QRL     18
         1 002256   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 002257   200015 136100                    SBLQ    MY_STACK,,AUTO
         1 002260   200017 756100                    STQ     I,,AUTO

     1735     6098    1       CALL FREESTACK (I);

   6098  1 002261   200017 633500                    EPPR3   I,,AUTO
         1 002262   200051 453500                    STP3    J+2,,AUTO
         1 002263   004052 701000 1                  TSX1    FREESTACK
         1 002264   000000 011000                    NOP     0

     1736     6099        /*D*
     1737     6100            If we are reparsing to get a list of legal alternative next nodes
     1738     6101            at the current point in the command, and this node is a lexeme or
     1739     6102            a literal, it needs to be on the possibility list.
     1740     6103        */
     1741     6104    1       IF P$PCB.NXT AND NOT P$PCB.NXT_SZONLY AND G$D.CCPOS = P$PCB.HI_CHAR

   6104  1 002265   200011 470500                    LDP0    PCB$,,AUTO
         1 002266   000005 236100                    LDQ     5,,PR0
         1 002267   040000 316007                    CANQ    16384,DL
         1 002270   002504 600000 1                  TZE     NONXT
         1 002271   002000 316007                    CANQ    1024,DL
         1 002272   002504 601000 1                  TNZ     NONXT
         1 002273   200003 471500                    LDP1    @G$D,,AUTO
         1 002274   100013 236100                    LDQ     11,,PR1
         1 002275   002504 604000 1                  TMI     NONXT
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:235  
         1 002276   000012 116100                    CMPQ    10,,PR0
         1 002277   002504 601000 1                  TNZ     NONXT
         1 002300   200010 473500                    LDP3    NODE$,,AUTO
         1 002301   300000 236100                    LDQ     0,,PR3
         1 002302   700000 376003                    ANQ     -32768,DU
         1 002303   500000 116003                    CMPQ    -98304,DU
         1 002304   002307 600000 1                  TZE     POSSIBLE_NODE
         1 002305   600000 116003                    CMPQ    -65536,DU
         1 002306   002504 601000 1                  TNZ     NONXT

     1742     6105    1         AND (P$NODE.TYPE = %TYPE_LITERAL# OR P$NODE.TYPE = %TYPE_LEXEME#)
     1743     6106    1       THEN
     1744     6107    2   POSSIBLE_NODE: DO;

   6107  1 002307                       POSSIBLE_NO* null
     1745     6108        /*D*
     1746     6109            o   First scan the existing list to make sure this node isn't a duplicate:
     1747     6110        */
     1748     6111    2           P$ = PINCRW(P$PCB.WORK$, P$PCB.WK_USED);

   6111  1 002307   000010 220100                    LDX0    8,,PR0
         1 002310   000002 474500                    LDP4    2,,PR0
         1 002311   400000 635510                    EPPR5   0,X0,PR4
         1 002312   200023 455500                    STP5    P$,,AUTO

     1749     6112    2           I = POSS.COUNT - 1;

   6112  1 002313   500000 235100                    LDA     0,,PR5
         1 002314   000001 135007                    SBLA    1,DL
         1 002315   200017 755100                    STA     I,,AUTO

     1750     6113    3           DO WHILE (I >= 0);

   6113  1 002316   002464 604000 1                  TMI     s:6187

     1751     6114    3               Q$ = POSS.NODES$(I);

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:236  
   6114  1 002317   200023 470500                    LDP0    P$,,AUTO
         1 002320   200017 720100                    LXL0    I,,AUTO
         1 002321   000001 236110                    LDQ     1,X0,PR0
         1 002322   200024 756100                    STQ     Q$,,AUTO

     1752     6115        /*D*
     1753     6116            o       If this node is already on the list, it's obviously a duplicate.
     1754     6117        */
     1755     6118    3               IF Q$ = NODE$

   6118  1 002323   200010 116100                    CMPQ    NODE$,,AUTO
         1 002324   002504 600000 1                  TZE     NONXT

     1756     6119    3               THEN
     1757     6120    3                   EXIT POSSIBLE_NODE;
     1758     6121        /*D*
     1759     6122            o       If the node is the same type as one already on the list,
     1760     6123                    it's a duplicate if ...
     1761     6124        */
     1762     6125    3               IF P$NODE.TYPE = Q$ -> P$NODE.TYPE

   6125  1 002325   200024 471500                    LDP1    Q$,,AUTO
         1 002326   200010 473500                    LDP3    NODE$,,AUTO
         1 002327   300000 236100                    LDQ     0,,PR3
         1 002330   100000 676100                    ERQ     0,,PR1
         1 002331   700000 376003                    ANQ     -32768,DU
         1 002332   002461 601000 1                  TNZ     s:6181

     1763     6126    3               THEN
     1764     6127    4               DO CASE (P$NODE.TYPE);

   6127  1 002333   300000 236100                    LDQ     0,,PR3
         1 002334   000041 772000                    QRL     33
         1 002335   000005 136007                    SBLQ    5,DL
         1 002336   000002 116007                    CMPQ    2,DL
         1 002337   002341 602006 1                  TNC     s:6127+6,QL
         1 002340   002461 710000 1                  TRA     s:6181
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:237  
         1 002341   002343 710000 1                  TRA     s:6133
         1 002342   002366 710000 1                  TRA     s:6142

     1765     6128        /*D*
     1766     6129            o       ... it's a literal and the size, text, and minimum length
     1767     6130                        are all identical.
     1768     6131        */
     1769     6132    4               CASE (%TYPE_LITERAL#);

     1770     6133    4                   IF P$LIT.ABREV = Q$ -> P$LIT.ABREV AND

   6133  1 002343   300000 236100                    LDQ     0,,PR3
         1 002344   100000 676100                    ERQ     0,,PR1
         1 002345   000005 376000 2                  ANQ     5
         1 002346   002365 601000 1                  TNZ     s:6133+18
         1 002347   300001 236100                    LDQ     1,,PR3
         1 002350   100001 676100                    ERQ     1,,PR1
         1 002351   777000 376003                    ANQ     -512,DU
         1 002352   002365 601000 1                  TNZ     s:6133+18
         1 002353   300001 236100                    LDQ     1,,PR3
         1 002354   000033 772000                    QRL     27
         1 002355   000000 621006                    EAX1    0,QL
         1 002356   100001 236100                    LDQ     1,,PR1
         1 002357   000033 772000                    QRL     27
         1 002360   000000 622006                    EAX2    0,QL
         1 002361   040140 106540                    CMPC    fill='040'O
         1 002362   300001 200011                    ADSC9   1,,PR3                   cn=1,n=*X1
         1 002363   100001 200012                    ADSC9   1,,PR1                   cn=1,n=*X2
         1 002364   002504 600000 1                  TZE     NONXT
         1 002365   002461 710000 1                  TRA     s:6181

     1771     6134    4                     P$LIT.COUNT = Q$ -> P$LIT.COUNT AND
     1772     6135    4                     P$LIT.TEXT = Q$ -> P$LIT.TEXT
     1773     6136    4                   THEN
     1774     6137    4                       EXIT POSSIBLE_NODE;
     1775     6138        /*D*
     1776     6139            o       ... it's a lexeme and the lexeme types are also the same, and ...
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:238  
     1777     6140        */
     1778     6141    4               CASE (%TYPE_LEXEME#);

     1779     6142    4                   IF P$SYM.LEXTYPE = Q$ -> P$SYM.LEXTYPE

   6142  1 002366   300000 236100                    LDQ     0,,PR3
         1 002367   100000 676100                    ERQ     0,,PR1
         1 002370   000002 376000 2                  ANQ     2
         1 002371   002461 601000 1                  TNZ     s:6181

     1780     6143    4                   THEN
     1781     6144    5                   DO CASE (P$SYM.LEXTYPE);

   6144  1 002372   300000 236100                    LDQ     0,,PR3
         1 002373   000020 772000                    QRL     16
         1 002374   000037 376007                    ANQ     31,DL
         1 002375   000024 136007                    SBLQ    20,DL
         1 002376   000014 116007                    CMPQ    12,DL
         1 002377   002401 602006 1                  TNC     s:6144+7,QL
         1 002400   002427 710000 1                  TRA     s:6164
         1 002401   002415 710000 1                  TRA     s:6149
         1 002402   002415 710000 1                  TRA     s:6149
         1 002403   002427 710000 1                  TRA     s:6164
         1 002404   002427 710000 1                  TRA     s:6164
         1 002405   002427 710000 1                  TRA     s:6164
         1 002406   002427 710000 1                  TRA     s:6164
         1 002407   002427 710000 1                  TRA     s:6164
         1 002410   002427 710000 1                  TRA     s:6164
         1 002411   002427 710000 1                  TRA     s:6164
         1 002412   002427 710000 1                  TRA     s:6164
         1 002413   002427 710000 1                  TRA     s:6164
         1 002414   002416 710000 1                  TRA     s:6155

     1782     6145        /*D*
     1783     6146            o           ... it's a BLANK or END lexeme.
     1784     6147        */
     1785     6148    5                   CASE (%LEX_BLANK#, %LEX_END#);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:239  

     1786     6149    5                       EXIT POSSIBLE_NODE;

   6149  1 002415   002504 710000 1                  TRA     NONXT

     1787     6150        /*D*
     1788     6151            o           ... it's a DSTRING and the delimiters and maximum lengths
     1789     6152                            are also the same.
     1790     6153        */
     1791     6154    5                   CASE (%LEX_DSTRING#);

     1792     6155    5                       IF P$DSTR.MAXL = Q$ -> P$DSTR.MAXL

   6155  1 002416   300001 236100                    LDQ     1,,PR3
         1 002417   100001 676100                    ERQ     1,,PR1
         1 002420   777000 376003                    ANQ     -512,DU
         1 002421   002426 601000 1                  TNZ     s:6155+8
         1 002422   300001 236100                    LDQ     1,,PR3
         1 002423   100001 676100                    ERQ     1,,PR1
         1 002424   000777 376003                    ANQ     511,DU
         1 002425   002504 600000 1                  TZE     NONXT
         1 002426   002461 710000 1                  TRA     s:6181

     1793     6156    5                         AND P$DSTR.DLIM = Q$ -> P$DSTR.DLIM
     1794     6157    5                       THEN
     1795     6158    5                           EXIT POSSIBLE_NODE;
     1796     6159        /*D*
     1797     6160            o           ... it's some other lexeme and the maximum lengths and
     1798     6161                            extra character sets are also the same.
     1799     6162        */
     1800     6163    5                   CASE (ELSE);

     1801     6164    5                       IF P$SYM.XTRA

   6164  1 002427   300000 236100                    LDQ     0,,PR3
         1 002430   000040 316003                    CANQ    32,DU
         1 002431   002456 600000 1                  TZE     s:6176
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:240  

     1802     6165    5                       THEN
     1803     6166    5                           IF Q$ -> P$SYM.XTRA

   6166  1 002432   100000 236100                    LDQ     0,,PR1
         1 002433   000040 316003                    CANQ    32,DU
         1 002434   002461 600000 1                  TZE     s:6181

     1804     6167    5                           THEN
     1805     6168    5                               IF P$SYM.MAXL = Q$ -> P$SYM.MAXL AND

   6168  1 002435   300001 236100                    LDQ     1,,PR3
         1 002436   100001 676100                    ERQ     1,,PR1
         1 002437   777000 376003                    ANQ     -512,DU
         1 002440   002455 601000 1                  TNZ     s:6168+16
         1 002441   300001 236100                    LDQ     1,,PR3
         1 002442   100001 676100                    ERQ     1,,PR1
         1 002443   000777 376003                    ANQ     511,DU
         1 002444   002455 601000 1                  TNZ     s:6168+16
         1 002445   300001 221100                    LDX1    1,,PR3
         1 002446   000777 361003                    ANX1    511,DU
         1 002447   100001 222100                    LDX2    1,,PR1
         1 002450   000777 362003                    ANX2    511,DU
         1 002451   040140 106540                    CMPC    fill='040'O
         1 002452   300001 400011                    ADSC9   1,,PR3                   cn=2,n=*X1
         1 002453   100001 400012                    ADSC9   1,,PR1                   cn=2,n=*X2
         1 002454   002504 600000 1                  TZE     NONXT
         1 002455   002461 710000 1                  TRA     s:6181

     1806     6169    5                                 P$SYM.COUNT = Q$ -> P$SYM.COUNT AND
     1807     6170    5                                 P$SYM.TEXT = Q$ -> P$SYM.TEXT
     1808     6171    5                               THEN
     1809     6172    5                                   EXIT POSSIBLE_NODE;
     1810     6173    5                               ELSE;
     1811     6174    5                           ELSE;
     1812     6175    5                       ELSE
     1813     6176    5                           IF NOT Q$ -> P$SYM.XTRA
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:241  

   6176  1 002456   100000 236100                    LDQ     0,,PR1
         1 002457   000040 316003                    CANQ    32,DU
         1 002460   002504 600000 1                  TZE     NONXT

     1814     6177    5                           THEN
     1815     6178    5                               EXIT POSSIBLE_NODE;
     1816     6179    5                   END /* do case p$sym.lextype */;

     1817     6180    4               END /* do case p$node.type */;

     1818     6181    3               I = I - 1;

   6181  1 002461   000001 336007                    LCQ     1,DL
         1 002462   200017 056100                    ASQ     I,,AUTO

     1819     6182    3           END /* do while (i >= 0) */;

   6182  1 002463   002317 605000 1                  TPL     s:6114

     1820     6183        /*D*
     1821     6184            o   If this isn't a duplicate, expand the work area if there isn't
     1822     6185                enough room to add to the possibility list.
     1823     6186        */
     1824     6187    2           IF ADDR(POSS.NODES$(POSS.COUNT+1)) >= G$D.STACKTOP$

   6187  1 002464   200023 470500                    LDP0    P$,,AUTO
         1 002465   000000 235100                    LDA     0,,PR0
         1 002466   200003 471500                    LDP1    @G$D,,AUTO
         1 002467   000044 733000                    LRS     36
         1 002470   000022 736000                    QLS     18
         1 002471   000002 036003                    ADLQ    2,DU
         1 002472   200023 036100                    ADLQ    P$,,AUTO
         1 002473   100010 116100                    CMPQ    8,,PR1
         1 002474   002477 602000 1                  TNC     s:6193

     1825     6188    2           THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:242  
     1826     6189    2               CALL EXPAND_WORKAREA;

   6189  1 002475   004336 701000 1                  TSX1    EXPAND_WORKAREA
         1 002476   000000 011000                    NOP     0

     1827     6190        /*D*
     1828     6191            o   Add this node to the list and bump the list count.
     1829     6192        */
     1830     6193    2           POSS.NODES$(POSS.COUNT) = NODE$;

   6193  1 002477   200023 470500                    LDP0    P$,,AUTO
         1 002500   000000 235100                    LDA     0,,PR0
         1 002501   200010 236100                    LDQ     NODE$,,AUTO
         1 002502   000001 756105                    STQ     1,AL,PR0

     1831     6194    2           POSS.COUNT = POSS.COUNT + 1;

   6194  1 002503   000000 054100                    AOS     0,,PR0

     1832     6195    2       END POSSIBLE_NODE;

   6193  1 002504                       NONXT        null
     1833     6196        /*D*
     1834     6197            Failure processing is entered at this point if a node is failed
     1835     6198            due to rejection by a preprocessing user exit routine.
     1836     6199        */
     1837     6200    1   NONXT: ;
     1838     6201        /*D*
     1839     6202            If this is a repeating node (and at least one repetition has been
     1840     6203            successfully parsed), failure doesn't mean the node has failed, it
     1841     6204            just means there are no more repetitions.  So, go to syntactic
     1842     6205            success processing to build the output block for the node, having
     1843     6206            the nodes built by all successful repetitions as subblocks.
     1844     6207        */
     1845     6208    1       IF REPEAT THEN

   6208  1 002504   200030 234100                    SZN     REPEAT,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:243  
         1 002505   002512 605000 1                  TPL     s:6218

     1846     6209    2       DO;

     1847     6210    2           MY_STACK = RP_STACK;

   6210  1 002506   200014 235100                    LDA     RP_STACK,,AUTO
         1 002507   200015 755100                    STA     MY_STACK,,AUTO

     1848     6211    2           REPEAT = '0'B;

   6211  1 002510   200030 450100                    STZ     REPEAT,,AUTO

     1849     6212    2           GOTO RPEATSUC;

   6212  1 002511   001756 710000 1                  TRA     RPEATSUC

     1850     6213    2       END;
     1851     6214        /*D*
     1852     6215            If this node is optional, failing to parse it isn't an error, so
     1853     6216            return normally.
     1854     6217        */
     1855     6218    1       IF P$NODE.OPT THEN

   6218  1 002512   200010 470500                    LDP0    NODE$,,AUTO
         1 002513   000000 236100                    LDQ     0,,PR0
         1 002514   002000 316003                    CANQ    1024,DU
         1 002515   002232 601000 1                  TNZ     ENDSUC

     1856     6219    1           GOTO ENDSUC;
     1857     6220        /*D*
     1858     6221            If the node requests a user exit on failure, call the user routine.
     1859     6222        */
     1860     6223    1       IF P$NODE.F_F THEN

   6223  1 002516   010000 316003                    CANQ    4096,DU
         1 002517   002536 600000 1                  TZE     s:6252
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:244  

     1861     6224    2       DO;

     1862     6225    2           CALL USER_EXIT (%FAIL#);

   6225  1 002520   000006 236000 2                  LDQ     6
         1 002521   200057 756100                    STQ     P$+2,,AUTO
         1 002522   004224 701000 1                  TSX1    USER_EXIT
         1 002523   000000 011000                    NOP     0

     1863     6226        /*D*
     1864     6227            o   If the user routine specifies acceptance, continue as for
     1865     6228                syntactic success if there is no output block built yet for
     1866     6229                this node, or as for lexical success if there is (since only
     1867     6230                lexemes could create an output block prior to success processing,
     1868     6231                and success processing is pretty much the same for syntax
     1869     6232                nodes and lexemes that don't create a symbol block).
     1870     6233        */
     1871     6234    2           IF PARSE$PARAM.ACCEPT THEN

   6234  1 002524   200035 236100                    LDQ     PARSE$PARAM,,AUTO
         1 002525   000400 316003                    CANQ    256,DU
         1 002526   002534 600000 1                  TZE     s:6245

     1872     6235    3           DO;

     1873     6236    3               IF PARSE$PARAM.OUT$ = ADDR(NIL) THEN

   6236  1 002527   200037 236100                    LDQ     PARSE$PARAM+2,,AUTO
         1 002530   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 002531   001751 600000 1                  TZE     SYNSUCCEED

     1874     6237    3                   GOTO SYNSUCCEED;
     1875     6238    3               BLK$ = PARSE$PARAM.OUT$;

   6238  1 002532   200027 756100                    STQ     BLK$,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:245  
     1876     6239    3               GOTO LEXSUCC2;

   6239  1 002533   002642 710000 1                  TRA     LEXSUCC2

     1877     6240    3           END;
     1878     6241        /*D*
     1879     6242            o   If the user routine specifies a retry, go back and try the
     1880     6243                parse again.
     1881     6244        */
     1882     6245    2           IF PARSE$PARAM.RETRY THEN

   6245  1 002534   000100 316003                    CANQ    64,DU
         1 002535   000057 601000 1                  TNZ     REPARSE

     1883     6246    2               GOTO REPARSE;
     1884     6247    2       END;

     1885     6248        /*D*
     1886     6249            Release any repeating alternative blocks that might have been
     1887     6250            created under this node.
     1888     6251        */
     1889     6252    1       IF RDUCE$ ~= ADDR(G$D) THEN

   6252  1 002536   200032 236100                    LDQ     RDUCE$,,AUTO
         1 002537   200003 116100                    CMPQ    @G$D,,AUTO
         1 002540   002543 600000 1                  TZE     s:6257

     1890     6253    1           CALL RELRED;

   6253  1 002541   002725 701000 1                  TSX1    RELRED
         1 002542   000000 011000                    NOP     0

     1891     6254        /*D*
     1892     6255            Altreturn to indicate failure to the caller.
     1893     6256        */
     1894     6257    1       ALTRETURN;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:246  
   6257  1 002543   000000 702200 xent               TSX2  ! X66_AALT

     1895     6258        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:247  
     1896     6259        /*D*
     1897     6260            Lexical Success Processing:
     1898     6261
     1899     6262                Control transfers to this point when a lexeme is successfully
     1900     6263                parsed.  Lexical success logic is used for nodes that have no
     1901     6264                subnodes, and so can only return a single output block created
     1902     6265                by this invocation of XUP$PARS.  Also, lexemes are the leaves
     1903     6266                of the parse tree, so only they can advance the current position
     1904     6267                in the command text.  If an output block is created, it will be an
     1905     6268                OUT$SYM block.
     1906     6269        */
     1907     6270    1   LEXSUCCEED:
     1908     6271        /*D*
     1909     6272            Reset position in source text to the character after the lexeme
     1910     6273            just parsed.
     1911     6274        */
     1912     6275    1       SAVEPOS=SAVEPOS+G$D.CNTUPOS;

   6275  1 002544   200003 470500       LEXSUCCEED   LDP0    @G$D,,AUTO
         1 002545   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 002546   000012 036100                    ADLQ    10,,PR0
         1 002547   200005 756100                    STQ     SAVEPOS,,AUTO

     1913     6276        /*D*
     1914     6277            o   Reset current character to the one at the new current position
     1915     6278                (or to null at the end of the command).
     1916     6279        */
     1917     6280    1       IF G$D.CCPOS < NCHARS THEN

   6280  1 002550   000013 236100                    LDQ     11,,PR0
         1 002551   200013 116100                    CMPQ    NCHARS,,AUTO
         1 002552   002561 605000 1                  TPL     s:6282

     1918     6281    1           G$D.CCHAR = P$PCB.TEXT$->C$BUFA(G$D.CCPOS);

   6281  1 002553   200011 471500                    LDP1    PCB$,,AUTO
         1 002554   100000 473500                    LDP3    0,,PR1
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:248  
         1 002555   040100 100506                    MLR     fill='040'O
         1 002556   300000 000001                    ADSC9   0,Q,PR3                  cn=0,n=1
         1 002557   000015 000001                    ADSC9   13,,PR0                  cn=0,n=1
         1 002560   002563 710000 1                  TRA     s:6287

     1919     6282    1       ELSE G$D.CCHAR = BINASC(0);

   6282  1 002561   000000 236003                    LDQ     0,DU
         1 002562   000015 552140                    STBQ    13,'40'O,PR0

     1920     6283        /*D*
     1921     6284            o   If current position has advanced, indicate no white space has
     1922     6285                been skipped yet.
     1923     6286        */
     1924     6287    1       IF SAVEPOS~=G$D.CCPOS THEN G$D.BLSKIP='0'B;

   6287  1 002563   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 002564   000013 116100                    CMPQ    11,,PR0
         1 002565   002570 600000 1                  TZE     s:6293

   6287  1 002566   000007 236000 2                  LDQ     7
         1 002567   000015 356100                    ANSQ    13,,PR0

     1925     6288        /*D*
     1926     6289            o   Reset lexical position before skipping whitespace, so that a
     1927     6290                syntactic RTEXT node including this one won't include any
     1928     6291                following whitespace.
     1929     6292        */
     1930     6293    1       G$D.CLEXPOS = G$D.CCPOS;

   6293  1 002570   000013 235100                    LDA     11,,PR0
         1 002571   000014 755100                    STA     12,,PR0

     1931     6294        /*D*
     1932     6295            o   Eat any whitespace following the lexeme, unless the node
     1933     6296                doesn't allow any.
     1934     6297        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:249  
     1935     6298    1       IF P$SYM.SKBL THEN

   6298  1 002572   200010 471500                    LDP1    NODE$,,AUTO
         1 002573   100000 236100                    LDQ     0,,PR1
         1 002574   000400 316003                    CANQ    256,DU
         1 002575   002600 600000 1                  TZE     BLANKSUCC

     1936     6299    1           CALL CHK_CONTUE;

   6299  1 002576   002756 701000 1                  TSX1    CHK_CONTUE
         1 002577   000000 011000                    NOP     0

   6298  1 002600                       BLANKSUCC    null
     1937     6300        /*D*
     1938     6301            Lexical success is entered at this point after an explicit blank
     1939     6302            lexeme is parsed, since it does its own position resetting.
     1940     6303        */
     1941     6304    1   BLANKSUCC:;
     1942     6305        /*D*
     1943     6306            If the node requires an output block and one hasn't already been
     1944     6307            built, allocate a block with no symbol text.
     1945     6308        */
     1946     6309    1       IF P$NODE.O_F = '1'B AND BLK$ = ADDR(NIL) THEN

   6309  1 002600   200010 470500                    LDP0    NODE$,,AUTO
         1 002601   000000 236100                    LDQ     0,,PR0
         1 002602   004000 316003                    CANQ    2048,DU
         1 002603   002632 600000 1                  TZE     s:6320
         1 002604   200027 236100                    LDQ     BLK$,,AUTO
         1 002605   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 002606   002632 601000 1                  TNZ     s:6320

     1947     6310    2       DO;

     1948     6311    2           COUNT = 3;

   6311  1 002607   000003 235007                    LDA     3,DL
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:250  
         1 002610   200022 755100                    STA     COUNT,,AUTO

     1949     6312    2           CALL XUP$GETSPACE(COUNT,Q$,G$D);

   6312  1 002611   200003 236100                    LDQ     @G$D,,AUTO
         1 002612   200070 756100                    STQ     TINDX+4,,AUTO
         1 002613   200024 631500                    EPPR1   Q$,,AUTO
         1 002614   200067 451500                    STP1    TINDX+3,,AUTO
         1 002615   200022 633500                    EPPR3   COUNT,,AUTO
         1 002616   200066 453500                    STP3    TINDX+2,,AUTO
         1 002617   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 002620   000021 631400 xsym               EPPR1   B_VECTNIL+17
         1 002621   000000 701000 xent               TSX1    XUP$GETSPACE
         1 002622   000000 011000                    NOP     0

     1950     6313    2           BLK$ = Q$;

   6313  1 002623   200024 236100                    LDQ     Q$,,AUTO
         1 002624   200027 756100                    STQ     BLK$,,AUTO

     1951     6314    2           BLK$->OUT$BLK.NSUBLKS = 0;

   6314  1 002625   000000 220003                    LDX0    0,DU
         1 002626   200027 470500                    LDP0    BLK$,,AUTO
         1 002627   000001 740100                    STX0    1,,PR0

     1952     6315    2           BLK$->OUT$BLK.CPOS = SAVEPOS;

   6315  1 002630   200005 235100                    LDA     SAVEPOS,,AUTO
         1 002631   000002 755100                    STA     2,,PR0

     1953     6316    2       END;

     1954     6317        /*D*
     1955     6318            If there is an output block for this node, fill in common fields.
     1956     6319        */
     1957     6320    1       IF BLK$ ~= ADDR(NIL) THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:251  

   6320  1 002632   200027 236100                    LDQ     BLK$,,AUTO
         1 002633   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 002634   002642 600000 1                  TZE     LEXSUCC2

     1958     6321    2       DO;

     1959     6322    2           BLK$->OUT$BLK.CPOS = SAVEPOS;

   6322  1 002635   200005 235100                    LDA     SAVEPOS,,AUTO
         1 002636   200027 470500                    LDP0    BLK$,,AUTO
         1 002637   000002 755100                    STA     2,,PR0

     1960     6323    2           CALL OUTBLK_COMMON;

   6323  1 002640   003657 701000 1                  TSX1    OUTBLK_COMMON
         1 002641   000000 011000                    NOP     0

     1961     6324    2       END;

     1962     6325    1   LEXSUCC2:
     1963     6326        /*D*
     1964     6327            Do common success processing. (Call the success exit routine if
     1965     6328            necessary, and push the new block, if any, on to the parse stack).
     1966     6329        */
     1967     6330    1       CALL SUCCEED_BLK;

   6330  1 002642   004105 701000 1     LEXSUCC2     TSX1    SUCCEED_BLK
         1 002643   000000 011000                    NOP     0

     1968     6331    2       DO CASE (I);

   6331  1 002644   200017 235100                    LDA     I,,AUTO
         1 002645   000003 115007                    CMPA    3,DL
         1 002646   002650 602005 1                  TNC     s:6331+4,AL
         1 002647   002655 710000 1                  TRA     s:6341
         1 002650   002655 710000 1                  TRA     s:6341
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:252  
         1 002651   002653 710000 1                  TRA     s:6333
         1 002652   002654 710000 1                  TRA     s:6335

     1969     6332    2       CASE (1);   /* success routine returned REJECT */

     1970     6333    2           GOTO SYNFAIL1;

   6333  1 002653   002242 710000 1                  TRA     SYNFAIL1

     1971     6334    2       CASE (2);   /* success routine returned RETRY */

     1972     6335    2           GOTO REPARSE;

   6335  1 002654   000057 710000 1                  TRA     REPARSE

     1973     6336    2       END;

     1974     6337        /*D*
     1975     6338            If parsing this lexeme takes us beyond the last high-water mark
     1976     6339            in the command text, save the new high position in the PCB.
     1977     6340        */
     1978     6341    1       IF G$D.CCPOS > P$PCB.HI_CHAR AND NOT P$PCB.NXT THEN

   6341  1 002655   200011 470500                    LDP0    PCB$,,AUTO
         1 002656   200003 471500                    LDP1    @G$D,,AUTO
         1 002657   000012 236100                    LDQ     10,,PR0
         1 002660   002672 604000 1                  TMI     s:6352
         1 002661   100013 116100                    CMPQ    11,,PR1
         1 002662   002672 605000 1                  TPL     s:6352
         1 002663   000005 236100                    LDQ     5,,PR0
         1 002664   040000 316007                    CANQ    16384,DL
         1 002665   002672 601000 1                  TNZ     s:6352

     1979     6342    2       DO;

     1980     6343    2           P$PCB.HI_CHAR = G$D.CCPOS;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:253  
   6343  1 002666   100013 235100                    LDA     11,,PR1
         1 002667   000012 755100                    STA     10,,PR0

     1981     6344    2           P$PCB.HINODE$ = ADDR(P$NODE);

   6344  1 002670   200010 236100                    LDQ     NODE$,,AUTO
         1 002671   000013 756100                    STQ     11,,PR0

     1982     6345    2       END;

     1983     6346        /*D*
     1984     6347            If this is a repeating node, go back to try to parse another
     1985     6348            repetition (but, if this repetition managed to succeed without
     1986     6349            advancing the position within the command, fail instead, to avoid
     1987     6350            an infinite loop).
     1988     6351        */
     1989     6352    1       IF REPEATABLE THEN

   6352  1 002672   200031 234100                    SZN     REPEATABLE,,AUTO
         1 002673   002704 605000 1                  TPL     s:6363

     1990     6353    2       DO;

     1991     6354    2           REPEAT = '1'B;

   6354  1 002674   400000 236003                    LDQ     -131072,DU
         1 002675   200030 756100                    STQ     REPEAT,,AUTO

     1992     6355    2           IF SAVEPOS~=G$D.CCPOS THEN

   6355  1 002676   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 002677   100013 116100                    CMPQ    11,,PR1
         1 002700   000057 601000 1                  TNZ     REPARSE

     1993     6356    2               GOTO REPARSE;
     1994     6357    2           BLK$=ADDR(NIL);

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:254  
   6357  1 002701   000001 236000 xsym               LDQ     B_VECTNIL+1
         1 002702   200027 756100                    STQ     BLK$,,AUTO

     1995     6358    2           GOTO SYNFAIL1;

   6358  1 002703   002242 710000 1                  TRA     SYNFAIL1

     1996     6359    2       END;
     1997     6360        /*D*
     1998     6361            That's it!  Return normally to indicate a successful parse to the caller.
     1999     6362        */
     2000     6363    1       RETURN;

   6363  1 002704   000000 702200 xent               TSX2  ! X66_ARET

     2001     6364        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:255  
     2002     6365        /*D*
     2003     6366            Error processing:
     2004     6367
     2005     6368                Errors (other than syntax errors) abort the parse by unwinding
     2006     6369                back to X$PARSE after saving the error code and current
     2007     6370                position in the PCB.
     2008     6371        */
     2009     6372
     2010     6373    1   CANT_RETURN_TEXT:
     2011     6374    1       P$PCB.ERROR = CANT_RTEXT;

   6374  1 002705   000000 236000 xsym  CANT_RETURN* LDQ     CANT_RTEXT
         1 002706   000006 756100                    STQ     6,,PR0

     2012     6375    1       P$PCB.HI_CHAR = G$D.CCPOS;

   6375  1 002707   100013 235100                    LDA     11,,PR1
         1 002710   000012 755100                    STA     10,,PR0

     2013     6376    1       UNWIND TO G$D.ERROR;

   6376  1 002711   100002 237300                    LDAQ  ! 2,,PR1
         1 002712   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 002713   000000 000200                    ZERO    0,128

     2014     6377
     2015     6378        /*E*    ERROR: XUP-E$CANT_RTEXT
     2016     6379                MESSAGE: Can't return node text - it has been overwritten.
     2017     6380                MESSAGE1: The "RTEXT" option of one of your nodes could not be honored.
     2018     6381                          Either part of your text string has been overwritten by your
     2019     6382                          command-continuation routine, or the "current character
     2020     6383                          position" has been modified in a strange fashion.  In either
     2021     6384                          case, X$PARSE can't figure out what text should be returned.
     2022     6385        */
     2023     6386
     2024     6387    1   RTEXT_TOO_LONG:
     2025     6388    1       P$PCB.ERROR = RTEXT_GT_511;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:256  

   6388  1 002714   000000 236000 xsym  RTEXT_TOO_L* LDQ     RTEXT_GT_511
         1 002715   200011 470500                    LDP0    PCB$,,AUTO
         1 002716   000006 756100                    STQ     6,,PR0

     2026     6389    1       P$PCB.HI_CHAR = G$D.CCPOS;

   6389  1 002717   200003 471500                    LDP1    @G$D,,AUTO
         1 002720   100013 235100                    LDA     11,,PR1
         1 002721   000012 755100                    STA     10,,PR0

     2027     6390    1       UNWIND TO G$D.ERROR;

   6390  1 002722   100002 237300                    LDAQ  ! 2,,PR1
         1 002723   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 002724   000000 000200                    ZERO    0,128

     2028     6391
     2029     6392        /*E*    ERROR: XUP-E$RTEXT_GT_511
     2030     6393                MESSAGE: Node text too long to return.
     2031     6394                MESSAGE1: The "RTEXT" option of one of your nodes could not be honored.
     2032     6395                          The portion of your input string which was accepted by this
     2033     6396                          node is longer than 511 characters, and cannot fit into
     2034     6397                          a parse output block.
     2035     6398        */
     2036     6399        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:257  
     2037     6400        /*I*
     2038     6401            NAME: RELRED
     2039     6402            PURPOSE: Release reducing alternative flag blocks.
     2040     6403            INPUT:
     2041     6404                G$D.REDUCE$ = root of R$BLK list for this node (NIL if none).
     2042     6405                RDUCE$ = root of R$BLK list for next higher level node.
     2043     6406            OUTPUT:
     2044     6407                G$D.RDUCE$ = copy of RDUCE$ on entry
     2045     6408                RDUCE$ = trash
     2046     6409            DESCRIPTION:
     2047     6410                This routine is called for any node that could have reducing
     2048     6411                alternative subnodes.  It releases any reducing alternative
     2049     6412                flag blocks (R$BLKs) that have been allocated since parsing
     2050     6413                for this node was initiated, and restores the R$BLK list root
     2051     6414                to what it was on entry.
     2052     6415        */
     2053     6416    1   RELRED:

   6416  1 002725   200046 741300       RELRED       STX1  ! PARSE$PARAM+9,,AUTO

     2054     6417    1       PROC;
     2055     6418    2       P$ = G$D.REDUCE$;

   6418  1 002726   200003 470500                    LDP0    @G$D,,AUTO
         1 002727   000011 236100                    LDQ     9,,PR0
         1 002730   200023 756100                    STQ     P$,,AUTO

     2056     6419    2       G$D.REDUCE$ = RDUCE$;

   6419  1 002731   200032 236100                    LDQ     RDUCE$,,AUTO
         1 002732   000011 756100                    STQ     9,,PR0

     2057     6420    3       DO WHILE(P$ ~= ADDR(NIL));

   6420  1 002733   002751 710000 1                  TRA     s:6424

     2058     6421    3           RDUCE$ = P$;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:258  

   6421  1 002734   200023 236100                    LDQ     P$,,AUTO
         1 002735   200032 756100                    STQ     RDUCE$,,AUTO

     2059     6422    3           P$ = P$->R$BLK.FLINK$;

   6422  1 002736   200023 470500                    LDP0    P$,,AUTO
         1 002737   000000 236100                    LDQ     0,,PR0
         1 002740   200023 756100                    STQ     P$,,AUTO

     2060     6423    3           CALL XUP$FREESPACE(RDUCE$,G$D);

   6423  1 002741   200003 236100                    LDQ     @G$D,,AUTO
         1 002742   200067 756100                    STQ     TINDX+3,,AUTO
         1 002743   200032 630500                    EPPR0   RDUCE$,,AUTO
         1 002744   200066 450500                    STP0    TINDX+2,,AUTO
         1 002745   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 002746   000020 631400 xsym               EPPR1   B_VECTNIL+16
         1 002747   000000 701000 xent               TSX1    XUP$FREESPACE
         1 002750   000000 011000                    NOP     0

     2061     6424    3       END;

   6424  1 002751   200023 236100                    LDQ     P$,,AUTO
         1 002752   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 002753   002734 601000 1                  TNZ     s:6421

     2062     6425    2       RETURN;

   6425  1 002754   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 002755   000001 702211                    TSX2  ! 1,X1

     2063     6426    2   END   RELRED;
     2064     6427        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:259  
     2065     6428        /*I*
     2066     6429            NAME: CHK_CONTINUE
     2067     6430            PURPOSE: Eat any whitespace at the current position.
     2068     6431            CALL:
     2069     6432                CALL CHK_CONTINUE;
     2070     6433            INPUT:
     2071     6434                G$D.CCPOS -- current position in command text
     2072     6435                G$D.CCHAR, CURCHAR -- character at current position
     2073     6436            OUTPUT:
     2074     6437                G$D.BLSKIP -- set if any whitespace was skipped
     2075     6438                G$D.CCPOS, G$D.CCHAR, CURCHAR -- reset if whitespace was skipped
     2076     6439            INTERFACE:
     2077     6440                CHK_COMMENT, ADVCHAR called to eat comments and blanks, respectively.
     2078     6441                USER_EXIT called to get continuation lines, if needed
     2079     6442                SETCHAR called to reset current position variables.
     2080     6443            DESCRIPTION:
     2081     6444                This routine is called whenever whitespace can appear in the
     2082     6445                command text.  Whitespace can be blanks, comments, command line
     2083     6446                continuations, or any combination of these.  Any whitespace in
     2084     6447                the command, starting at the current character position, is
     2085     6448                skipped, and the various variables that control command position
     2086     6449                and blank skip status are reset accordingly.
     2087     6450        */
     2088     6451    1   CHK_CONTUE:

   6451  1 002756   200046 741300       CHK_CONTUE   STX1  ! PARSE$PARAM+9,,AUTO

     2089     6452    1       PROC;
     2090     6453        /*D*
     2091     6454            Loop for as long as some sort of whitespace is found.
     2092     6455        */
     2093     6456    3       DO WHILE('1'B);

     2094     6457        /*D*
     2095     6458                First try to scan over a comment starting at the current position.
     2096     6459        */
     2097     6460    3           CALL CHK_COMMENT(G$D.CCPOS);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:260  

   6460  1 002757   200003 236100                    LDQ     @G$D,,AUTO
         1 002760   000013 036003                    ADLQ    11,DU
         1 002761   200063 756100                    STQ     @TYPE+4,,AUTO
         1 002762   003466 701000 1                  TSX1    CHK_COMMENT
         1 002763   000000 011000                    NOP     0

     2098     6461        /*D*
     2099     6462                If the command can be continued and the current character is
     2100     6463                a semicolon, it might be a continuation mark.
     2101     6464        */
     2102     6465    3           IF G$D.CCHAR = ';'

   6465  1 002764   200003 470500                    LDP0    @G$D,,AUTO
         1 002765   000015 236100                    LDQ     13,,PR0
         1 002766   777000 376003                    ANQ     -512,DU
         1 002767   073000 116003                    CMPQ    30208,DU
         1 002770   003106 601000 1                  TNZ     CHK_BLK
         1 002771   200011 471500                    LDP1    PCB$,,AUTO
         1 002772   100005 236100                    LDQ     5,,PR1
         1 002773   200000 316007                    CANQ    65536,DL
         1 002774   003106 600000 1                  TZE     CHK_BLK
         1 002775   100004 236100                    LDQ     4,,PR1
         1 002776   000002 116000 xsym               CMPQ    B_VECTNIL+2
         1 002777   003106 600000 1                  TZE     CHK_BLK

     2103     6466    3             AND P$PCB.CONTINUE
     2104     6467    4             AND P$PCB.U$$ ~= ENTADDR(NIL) THEN DO;

     2105     6468        /*D*
     2106     6469                Semicolons are only continuation marks if they are followed by
     2107     6470                nothing but whitespace.  So, before reading a continuation
     2108     6471                line, scan the rest of the command line to see if it contains
     2109     6472                anything else.  This is done without advancing G$D.CCPOS, so
     2110     6473                that the position doesn't need to be reset if something else
     2111     6474                is found.
     2112     6475        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:261  
     2113     6476    4               J = G$D.CCPOS + 1;

   6476  1 003000   000013 235100                    LDA     11,,PR0
         1 003001   000001 035007                    ADLA    1,DL
         1 003002   200020 755100                    STA     J,,AUTO

     2114     6477        /*D*
     2115     6478                o   First eat any blanks after the semicolon.  If this takes
     2116     6479                    us to the end of the line, we're ready to read try to
     2117     6480                    read a continuation line.
     2118     6481        */
     2119     6482    5               DO WHILE(J < NCHARS);

   6482  1 003003   200020 236100                    LDQ     J,,AUTO
         1 003004   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003005   003043 605000 1                  TPL     CONTUE_GO

     2120     6483    6                   DO WHILE(P$PCB.TEXT$->C$BUFA(J) = ' ');

   6483  1 003006   200011 470500                    LDP0    PCB$,,AUTO
         1 003007   000000 471500                    LDP1    0,,PR0
         1 003010   200020 235100                    LDA     J,,AUTO
         1 003011   040000 106505                    CMPC    fill='040'O
         1 003012   100000 000001                    ADSC9   0,A,PR1                  cn=0,n=1
         1 003013   000035 000001 xsym               ADSC9   B_VECTNIL+29             cn=0,n=1
         1 003014   003027 601000 1                  TNZ     s:6495

     2121     6484    6                       J = J + 1;

   6484  1 003015   200020 054100                    AOS     J,,AUTO

     2122     6485    6                       IF J = NCHARS THEN

   6485  1 003016   200020 236100                    LDQ     J,,AUTO
         1 003017   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003020   003043 600000 1                  TZE     CONTUE_GO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:262  
     2123     6486    6                           GOTO CONTUE_GO;
     2124     6487    6                   END;

   6487  1 003021   200011 470500                    LDP0    PCB$,,AUTO
         1 003022   000000 471500                    LDP1    0,,PR0
         1 003023   040000 106506                    CMPC    fill='040'O
         1 003024   100000 000001                    ADSC9   0,Q,PR1                  cn=0,n=1
         1 003025   000035 000001 xsym               ADSC9   B_VECTNIL+29             cn=0,n=1
         1 003026   003015 600000 1                  TZE     s:6484

     2125     6488        /*D*
     2126     6489                o   If something other than blanks follow the semicolon, see
     2127     6490                    if it's a comment, and, if it is, go back to eat more
     2128     6491                    blanks, unless the comment takes us to the end of the
     2129     6492                    line.  Otherwise, the semicolon isn't a continuation
     2130     6493                    mark, so return without advancing past it.
     2131     6494        */
     2132     6495    5                   COUNT = J;

   6495  1 003027   200020 235100                    LDA     J,,AUTO
         1 003030   200022 755100                    STA     COUNT,,AUTO

     2133     6496    5                   CALL CHK_COMMENT(J) ALTRET(CONTUE_GO);

   6496  1 003031   200020 631500                    EPPR1   J,,AUTO
         1 003032   200063 451500                    STP1    @TYPE+4,,AUTO
         1 003033   003466 701000 1                  TSX1    CHK_COMMENT
         1 003034   003043 702000 1                  TSX2    CONTUE_GO

     2134     6497    5                   IF COUNT = J THEN

   6497  1 003035   200022 236100                    LDQ     COUNT,,AUTO
         1 003036   200020 116100                    CMPQ    J,,AUTO
         1 003037   003106 600000 1                  TZE     CHK_BLK

     2135     6498    5                       GOTO CHK_BLK;
     2136     6499    5               END;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:263  

   6499  1 003040   200020 236100                    LDQ     J,,AUTO
         1 003041   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003042   003006 604000 1                  TMI     s:6483

     2137     6500        /*D*
     2138     6501                Get a continuation line if a continuation mark is found:
     2139     6502        */
     2140     6503    4   CONTUE_GO:
     2141     6504        /*D*
     2142     6505                o   Save current command text base address and position, for
     2143     6506                    use in recomputing the position once the new line is read.
     2144     6507        */
     2145     6508    4               J=G$D.CCPOS;

   6508  1 003043   200003 470500       CONTUE_GO    LDP0    @G$D,,AUTO
         1 003044   000013 235100                    LDA     11,,PR0
         1 003045   200020 755100                    STA     J,,AUTO

     2146     6509    4               P$=P$PCB.TEXT$;

   6509  1 003046   200011 471500                    LDP1    PCB$,,AUTO
         1 003047   100000 236100                    LDQ     0,,PR1
         1 003050   200023 756100                    STQ     P$,,AUTO

     2147     6510    4               P$PCB.TEXT$->C$BUFA(G$D.CCPOS) = ' ';

   6510  1 003051   100000 473500                    LDP3    0,,PR1
         1 003052   000013 235100                    LDA     11,,PR0
         1 003053   040105 100400                    MLR     fill='040'O
         1 003054   000035 000001 xsym               ADSC9   B_VECTNIL+29             cn=0,n=1
         1 003055   300000 000001                    ADSC9   0,A,PR3                  cn=0,n=1

     2148     6511        /*D*
     2149     6512            o   Call the user exit routine to read the continuation line.
     2150     6513        */
     2151     6514    4               CALL USER_EXIT (%INPUT#);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:264  

   6514  1 003056   000010 236000 2                  LDQ     8
         1 003057   200057 756100                    STQ     P$+2,,AUTO
         1 003060   004224 701000 1                  TSX1    USER_EXIT
         1 003061   000000 011000                    NOP     0

     2152     6515        /*D*
     2153     6516            o   Reset the position in the command text based on what the user
     2154     6517                routine returned.
     2155     6518        */
     2156     6519    4               P$PCB.HI_CHAR=G$D.CCPOS;

   6519  1 003062   200003 470500                    LDP0    @G$D,,AUTO
         1 003063   000013 235100                    LDA     11,,PR0
         1 003064   200011 471500                    LDP1    PCB$,,AUTO
         1 003065   100012 755100                    STA     10,,PR1

     2157     6520    4               G$D.BLSKIP='1'B;

   6520  1 003066   000400 236003                    LDQ     256,DU
         1 003067   000015 256100                    ORSQ    13,,PR0

     2158     6521    4               J=G$D.CCPOS-J+POFFC(P$PCB.TEXT$,P$);

   6521  1 003070   000013 236100                    LDQ     11,,PR0
         1 003071   200020 136100                    SBLQ    J,,AUTO
         1 003072   200066 756100                    STQ     TINDX+2,,AUTO
         1 003073   200023 236100                    LDQ     P$,,AUTO
         1 003074   000020 772000                    QRL     16
         1 003075   200067 756100                    STQ     TINDX+3,,AUTO
         1 003076   100000 236100                    LDQ     0,,PR1
         1 003077   000020 772000                    QRL     16
         1 003100   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 003101   200066 036100                    ADLQ    TINDX+2,,AUTO
         1 003102   200020 756100                    STQ     J,,AUTO

     2159     6522    4               G$D.CNTUPOS=G$D.CNTUPOS+J;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:265  

   6522  1 003103   000012 036100                    ADLQ    10,,PR0
         1 003104   000012 756100                    STQ     10,,PR0

     2160     6523    4           END;

   6523  1 003105   003115 710000 1                  TRA     s:6534

     2161     6524        /*D*
     2162     6525                If, after eating any comment, the current character is neither
     2163     6526                a continuation mark nor a blank, there is no more whitespace
     2164     6527                at this point.
     2165     6528        */
     2166     6529    3           ELSE CHK_BLK: IF G$D.CCHAR~=' ' THEN RETURN;

   6529  1 003106   200003 470500       CHK_BLK      LDP0    @G$D,,AUTO
         1 003107   000015 236100                    LDQ     13,,PR0
         1 003110   777000 376003                    ANQ     -512,DU
         1 003111   040000 116003                    CMPQ    16384,DU
         1 003112   003115 600000 1                  TZE     s:6534

   6529  1 003113   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 003114   000001 702211                    TSX2  ! 1,X1

     2167     6530        /*D*
     2168     6531                Otherwise, eat any blanks at the current position, and loop
     2169     6532                until there is no more whitespace.
     2170     6533        */
     2171     6534    4           DO WHILE(G$D.CCHAR = ' ');

   6534  1 003115   000015 236100                    LDQ     13,,PR0
         1 003116   777000 376003                    ANQ     -512,DU
         1 003117   040000 116003                    CMPQ    16384,DU
         1 003120   002757 601000 1                  TNZ     s:6460

     2172     6535    4               G$D.BLSKIP = '1'B;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:266  
   6535  1 003121   200003 470500                    LDP0    @G$D,,AUTO
         1 003122   000400 236003                    LDQ     256,DU
         1 003123   000015 256100                    ORSQ    13,,PR0

     2173     6536    4               CALL ADVCHAR;

   6536  1 003124   003353 701000 1                  TSX1    ADVCHAR
         1 003125   000000 011000                    NOP     0

     2174     6537    4           END;

   6537  1 003126   200003 470500                    LDP0    @G$D,,AUTO
         1 003127   000015 236100                    LDQ     13,,PR0
         1 003130   777000 376003                    ANQ     -512,DU
         1 003131   040000 116003                    CMPQ    16384,DU
         1 003132   003121 600000 1                  TZE     s:6535

     2175     6538    3       END;

   6538  1 003133   002757 710000 1                  TRA     s:6460

     2176     6539    2   END CHK_CONTUE;
     2177     6540        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:267  
     2178     6541        /*I*
     2179     6542            NAME: CHKCHAR
     2180     6543            PURPOSE: See if the current character is legal for a lexeme.
     2181     6544            CALL:
     2182     6545                CALL CHKCHAR ALTRET(illegal_char);
     2183     6546            INPUT:
     2184     6547                P$ = points to lexeme node being parsed
     2185     6548                CURCHAR = character to be checked
     2186     6549            DESCRIPTION:
     2187     6550                This routine checks whether the current character is legal for
     2188     6551                the lexeme being parsed.  It returns normally if the character
     2189     6552                is legal, otherwise it altreturns.
     2190     6553
     2191     6554                Most character validation is done via a table (SYMTBL) defined
     2192     6555                in XU_DATA_D that contains a word per ASCII character, each of
     2193     6556                which contains a bit flag for each lexeme that is set if the
     2194     6557                corresponding character is legal for that lexeme.
     2195     6558
     2196     6559                Some lexemes must begin with a specific character or contain
     2197     6560                at least one character from a subset of legal characters; the
     2198     6561                VALIDSYM flag word is used to control special checks for these
     2199     6562                lexemes.
     2200     6563
     2201     6564                If the character isn't legal according to the table, it still
     2202     6565                might be legal if the lexeme has an extra legal-character list
     2203     6566                and the character is in the list.  Note that the flag indicating
     2204     6567                the presence of this list is only present in P$SYM nodes, so
     2205     6568                this routine can only be called for nodes that are defined
     2206     6569                using that structure.
     2207     6570        */
     2208     6571    1   CHKCHAR:

   6571  1 003134   200046 741300       CHKCHAR      STX1  ! PARSE$PARAM+9,,AUTO

     2209     6572    1       PROC ALTRET;
     2210     6573            %P$SYM(STCLASS="BASED(P$)", LEN="P$SYM.COUNT");
     2211     6652    2   DCL J SBIN;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:268  
     2212     6653        /*
     2213     6654                If the character is a 7-bit ASCII code, first try looking it
     2214     6655                up in the legal character table.
     2215     6656        */
     2216     6657    2       IF NOT ASCBIT(CURCHAR)&'600'O THEN

   6657  1 003135   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003136   777000 376003                    ANQ     -512,DU
         1 003137   600000 376003                    ANQ     -65536,DU
         1 003140   003305 601000 1                  TNZ     s:6726

     2217     6658    3       DO CASE(P$SYM.LEXTYPE);

   6658  1 003141   200023 470500                    LDP0    P$,,AUTO
         1 003142   000000 236100                    LDQ     0,,PR0
         1 003143   000020 772000                    QRL     16
         1 003144   000037 376007                    ANQ     31,DL
         1 003145   000013 116007                    CMPQ    11,DL
         1 003146   003150 602006 1                  TNC     s:6658+7,QL
         1 003147   003305 710000 1                  TRA     s:6726
         1 003150   003305 710000 1                  TRA     s:6726
         1 003151   003171 710000 1                  TRA     s:6668
         1 003152   003163 710000 1                  TRA     s:6664
         1 003153   003271 710000 1                  TRA     s:6710
         1 003154   003177 710000 1                  TRA     s:6672
         1 003155   003205 710000 1                  TRA     s:6676
         1 003156   003222 710000 1                  TRA     s:6684
         1 003157   003237 710000 1                  TRA     s:6692
         1 003160   003257 710000 1                  TRA     s:6701
         1 003161   003277 710000 1                  TRA     s:6715
         1 003162   003264 710000 1                  TRA     s:6705

     2218     6659
     2219     6660    3       CASE(%LEX_NULL#,

     2220     6661    3         %LEX_ASYM#);
     2221     6662
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:269  
     2222     6663    3       CASE(%LEX_OCTAL#);

     2223     6664    3           IF SYMTTBL.OCT(ASCBIN(CURCHAR)) THEN

   6664  1 003163   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003164   000033 772000                    QRL     27
         1 003165   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003166   010000 316003                    CANQ    4096,DU
         1 003167   003305 600000 1                  TZE     s:6726

     2224     6665    3               RETURN;

   6665  1 003170   000001 702211                    TSX2  ! 1,X1

     2225     6666
     2226     6667    3       CASE(%LEX_DECIMAL#);

     2227     6668    3           IF SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN

   6668  1 003171   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003172   000033 772000                    QRL     27
         1 003173   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003174   020000 316003                    CANQ    8192,DU
         1 003175   003305 600000 1                  TZE     s:6726

     2228     6669    3               RETURN;

   6669  1 003176   000001 702211                    TSX2  ! 1,X1

     2229     6670
     2230     6671    3       CASE(%LEX_ALPHA#);

     2231     6672    3           IF SYMTTBL.ALPHA(ASCBIN(CURCHAR)) THEN

   6672  1 003177   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003200   000033 772000                    QRL     27
         1 003201   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:270  
         1 003202   040000 316003                    CANQ    16384,DU
         1 003203   003305 600000 1                  TZE     s:6726

     2232     6673    3               RETURN;

   6673  1 003204   000001 702211                    TSX2  ! 1,X1

     2233     6674
     2234     6675    3       CASE(%LEX_ANUMERIC#);

     2235     6676    3           IF SYMTTBL.ALNUM(ASCBIN(CURCHAR)) THEN

   6676  1 003205   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003206   000033 772000                    QRL     27
         1 003207   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003210   100000 316003                    CANQ    32768,DU
         1 003211   003305 600000 1                  TZE     s:6726

     2236     6677    4           DO;

     2237     6678    4               IF NOT SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN

   6678  1 003212   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003213   000033 772000                    QRL     27
         1 003214   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003215   020000 316003                    CANQ    8192,DU
         1 003216   003221 601000 1                  TNZ     s:6680

     2238     6679    4                   VALIDSYM = 1;

   6679  1 003217   000001 235007                    LDA     1,DL
         1 003220   200026 755100                    STA     VALIDSYM,,AUTO

     2239     6680    4               RETURN;

   6680  1 003221   000001 702211                    TSX2  ! 1,X1

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:271  
     2240     6681    4           END;
     2241     6682
     2242     6683    3       CASE(%LEX_SYMBOL#);

     2243     6684    3           IF SYMTTBL.SYM(ASCBIN(CURCHAR)) THEN

   6684  1 003222   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003223   000033 772000                    QRL     27
         1 003224   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003225   200000 316003                    CANQ    65536,DU
         1 003226   003305 600000 1                  TZE     s:6726

     2244     6685    4           DO;

     2245     6686    4               IF NOT SYMTTBL.DEC(ASCBIN(CURCHAR)) THEN

   6686  1 003227   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003230   000033 772000                    QRL     27
         1 003231   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003232   020000 316003                    CANQ    8192,DU
         1 003233   003236 601000 1                  TNZ     s:6688

     2246     6687    4                   VALIDSYM = 1;

   6687  1 003234   000001 235007                    LDA     1,DL
         1 003235   200026 755100                    STA     VALIDSYM,,AUTO

     2247     6688    4               RETURN;

   6688  1 003236   000001 702211                    TSX2  ! 1,X1

     2248     6689    4           END;
     2249     6690
     2250     6691    3       CASE(%LEX_PL6SYM#);

     2251     6692    3           IF SYMTTBL.PL6SYM(ASCBIN(CURCHAR)) THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:272  
   6692  1 003237   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003240   000033 772000                    QRL     27
         1 003241   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003242   004000 316003                    CANQ    2048,DU
         1 003243   003305 600000 1                  TZE     s:6726

     2252     6693    3               IF VALIDSYM ~= 0 THEN RETURN;

   6693  1 003244   200026 235100                    LDA     VALIDSYM,,AUTO
         1 003245   003247 600000 1                  TZE     s:6694

   6693  1 003246   000001 702211                    TSX2  ! 1,X1

     2253     6694    3               ELSE IF SYMTTBL.ALPHA(ASCBIN(CURCHAR)) THEN

   6694  1 003247   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003250   000033 772000                    QRL     27
         1 003251   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003252   040000 316003                    CANQ    16384,DU
         1 003253   003305 600000 1                  TZE     s:6726

     2254     6695    4                   DO;

     2255     6696    4                       VALIDSYM = 1;

   6696  1 003254   000001 236007                    LDQ     1,DL
         1 003255   200026 756100                    STQ     VALIDSYM,,AUTO

     2256     6697    4                       RETURN;

   6697  1 003256   000001 702211                    TSX2  ! 1,X1

     2257     6698    4                   END;
     2258     6699
     2259     6700    3       CASE(%LEX_FID#);

     2260     6701    3           IF SYMTTBL.FID(ASCBIN(CURCHAR)) THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:273  

   6701  1 003257   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003260   000033 772000                    QRL     27
         1 003261   000000 234006 xsym               SZN     XUP_SYMTBL,QL
         1 003262   003305 605000 1                  TPL     s:6726

     2261     6702    3               RETURN;

   6702  1 003263   000001 702211                    TSX2  ! 1,X1

     2262     6703
     2263     6704    3       CASE (%LEX_ACCOUNT#);

     2264     6705    3           IF SYMTTBL.ACCOUNT(ASCBIN(CURCHAR))

   6705  1 003264   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003265   000033 772000                    QRL     27
         1 003266   000000 430006 xsym               FSZN    XUP_SYMTBL,QL
         1 003267   003305 605000 1                  TPL     s:6726

     2265     6706    3           THEN
     2266     6707    3               RETURN;

   6707  1 003270   000001 702211                    TSX2  ! 1,X1

     2267     6708
     2268     6709    3       CASE (%LEX_HEX#);

     2269     6710    3           IF SYMTTBL.HEX(ASCBIN(CURCHAR))

   6710  1 003271   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003272   000033 772000                    QRL     27
         1 003273   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003274   000400 316003                    CANQ    256,DU
         1 003275   003305 600000 1                  TZE     s:6726

     2270     6711    3           THEN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:274  
     2271     6712    3               RETURN;

   6712  1 003276   000001 702211                    TSX2  ! 1,X1

     2272     6713
     2273     6714    3       CASE (%LEX_JOBNAME#);

     2274     6715    3           IF SYMTTBL.JOBNAME(ASCBIN(CURCHAR))

   6715  1 003277   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003300   000033 772000                    QRL     27
         1 003301   000000 236006 xsym               LDQ     XUP_SYMTBL,QL
         1 003302   002000 316003                    CANQ    1024,DU
         1 003303   003305 600000 1                  TZE     s:6726

     2275     6716    3           THEN
     2276     6717    3               RETURN;

   6717  1 003304   000001 702211                    TSX2  ! 1,X1

     2277     6718
     2278     6719    3       END;

     2279     6720
     2280     6721        /*
     2281     6722                If the character isn't listed as legal in the table, and the
     2282     6723                lexeme has an extra legal-character list, see if the character
     2283     6724                is in the list.
     2284     6725        */
     2285     6726    2       IF P$SYM.XTRA THEN

   6726  1 003305   200023 470500                    LDP0    P$,,AUTO
         1 003306   000000 236100                    LDQ     0,,PR0
         1 003307   000040 316003                    CANQ    32,DU
         1 003310   003323 600000 1                  TZE     NOTSYM

     2286     6727    3       DO;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:275  

     2287     6728    3           CALL INDEX(J,CURCHAR,P$SYM.TEXT)

   6728  1 003311   000001 220100                    LDX0    1,,PR0
         1 003312   000777 360003                    ANX0    511,DU
         1 003313   000100 124540                    SCM     mask='000'O
         1 003314   000001 400010                    ADSC9   1,,PR0                   cn=2,n=*X0
         1 003315   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1
         1 003316   200047 000100                    ARG     J,,AUTO
         1 003317   003323 606400 1                  TTN     NOTSYM

     2288     6729    3             ALTRET(NOTSYM);
     2289     6730    3           VALIDSYM = 1;

   6730  1 003320   000001 235007                    LDA     1,DL
         1 003321   200026 755100                    STA     VALIDSYM,,AUTO

     2290     6731    3           RETURN;

   6731  1 003322   000001 702211                    TSX2  ! 1,X1

   6726  1 003323                       NOTSYM       null
     2291     6732    3       END;
     2292     6733
     2293     6734        /*
     2294     6735                If neither of the above tests succeed, altreturn to indicate
     2295     6736                an illegal character.
     2296     6737        */
     2297     6738    2   NOTSYM: ;
     2298     6739    2       ALTRETURN;

   6739  1 003323   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 003324   000000 702211                    TSX2  ! 0,X1

     2299     6740    2   END   CHKCHAR;
     2300     6741        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:276  
     2301     6742        /*I*
     2302     6743            NAME: PARS_SUBND
     2303     6744            PURPOSE: Recursively call XUP$PARS to parse a subnode.
     2304     6745            CALL:
     2305     6746                CALL PARS_SUBND ALTRET (parse-failed);
     2306     6747            INPUT:
     2307     6748                NODE$ -- address of current node
     2308     6749                I -- index of subnode to be parsed
     2309     6750            OUTPUT:
     2310     6751                On normal return, any output blocks and parse stack entries
     2311     6752                created for the subnode exist, and the position in the command
     2312     6753                text has been updated.  On altreturn, everything is (logically)
     2313     6754                the same as it was on entry.
     2314     6755            DESCRIPTION:
     2315     6756                This routine attempt to parse the specified subnode of the
     2316     6757                current node.
     2317     6758        */
     2318     6759    1   PARS_SUBND: PROC ALTRET;

   6759  1 003325   200046 741300       PARS_SUBND   STX1  ! PARSE$PARAM+9,,AUTO

     2319     6760
     2320     6761    2       G$D.NODE$ = P$NODE.SUBNDS$(I);

   6761  1 003326   200010 470500                    LDP0    NODE$,,AUTO
         1 003327   200017 720100                    LXL0    I,,AUTO
         1 003330   000001 236110                    LDQ     1,X0,PR0
         1 003331   200003 471500                    LDP1    @G$D,,AUTO
         1 003332   100004 756100                    STQ     4,,PR1

     2321     6762
     2322     6763        /*D*
     2323     6764                If the subnode to parse is the same node as the current node,
     2324     6765                and the current position hasn't advanced past what it was on
     2325     6766                entry to the parse of the current node, fail the parse without
     2326     6767                attempting the recursive call, to avoid an infinite loop.
     2327     6768        */
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:277  
     2328     6769    2       IF G$D.NODE$ = NODE$

   6769  1 003333   200010 116100                    CMPQ    NODE$,,AUTO
         1 003334   003343 601000 1                  TNZ     s:6778
         1 003335   100013 236100                    LDQ     11,,PR1
         1 003336   100012 136100                    SBLQ    10,,PR1
         1 003337   200005 116100                    CMPQ    SAVEPOS,,AUTO
         1 003340   003343 601000 1                  TNZ     s:6778

     2329     6770    2         AND SAVEPOS = G$D.CCPOS - G$D.CNTUPOS
     2330     6771    2       THEN
     2331     6772    2           ALTRETURN;

   6772  1 003341   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 003342   000000 702211                    TSX2  ! 0,X1

     2332     6773
     2333     6774        /*D*
     2334     6775                Attempt to parse the subnode.  Return normally or altreturn,
     2335     6776                according to how the subnode parse attempt returns.
     2336     6777        */
     2337     6778    2       CALL XUP$PARS (G$D) ALTRET (FAIL);

   6778  1 003343   200003 630500                    EPPR0   @G$D,,AUTO
         1 003344   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 003345   000000 701000 1                  TSX1    s:7
         1 003346   003351 702000 1                  TSX2    FAIL

     2338     6779    2       RETURN;

   6779  1 003347   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 003350   000001 702211                    TSX2  ! 1,X1

   6769  1 003351                       FAIL         null
     2339     6780
     2340     6781    2   FAIL: ;
     2341     6782    2       ALTRETURN;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:278  

   6782  1 003351   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 003352   000000 702211                    TSX2  ! 0,X1

     2342     6783
     2343     6784    2   END PARS_SUBND;
     2344     6785        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:279  
     2345     6786        /*I*
     2346     6787            NAME: ADVCHAR
     2347     6788            PURPOSE: Advance the current position in the command.
     2348     6789            CALL:
     2349     6790                CALL ADVCHAR;
     2350     6791            INPUT:
     2351     6792                G$D.CCHAR -- current position in command
     2352     6793            OUTPUT:
     2353     6794                G$D.CCHAR -- new position in command
     2354     6795                G$D.CCHAR, CURCHAR -- set to character at new position
     2355     6796            DESCRIPTION:
     2356     6797                This routine is called from CHK_CONTINUE if the current character
     2357     6798                is blank.  It bumps the current position, and eats any comment
     2358     6799                starting at that position.
     2359     6800        */
     2360     6801    1   ADVCHAR:

   6801  1 003353   200060 741300       ADVCHAR      STX1  ! @TYPE+1,,AUTO

     2361     6802    1       PROC;
     2362     6803        /*
     2363     6804            ***       BEGIN PROCEDURE
     2364     6805        */
     2365     6806    2   RETRY: IF G$D.CCPOS < NCHARS - 1 THEN

   6806  1 003354   200003 470500       RETRY        LDP0    @G$D,,AUTO
         1 003355   200013 236100                    LDQ     NCHARS,,AUTO
         1 003356   000001 136007                    SBLQ    1,DL
         1 003357   000013 116100                    CMPQ    11,,PR0
         1 003360   003402 604400 1                  TMOZ    s:6815

     2366     6807    3       DO;

     2367     6808    3           G$D.CCPOS = G$D.CCPOS + 1;

   6808  1 003361   000013 054100                    AOS     11,,PR0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:280  
     2368     6809    3           CALL CHK_COMMENT(G$D.CCPOS) ALTRET(NOMORETXT);

   6809  1 003362   200003 236100                    LDQ     @G$D,,AUTO
         1 003363   000013 036003                    ADLQ    11,DU
         1 003364   200063 756100                    STQ     @TYPE+4,,AUTO
         1 003365   003466 701000 1                  TSX1    CHK_COMMENT
         1 003366   003433 702000 1                  TSX2    NOMORETXT

   6808  1 003367                       STCHAR       null
     2369     6810    3   STCHAR: ;
     2370     6811    3           CURCHAR = P$PCB.TEXT$->C$BUFA(G$D.CCPOS);

   6811  1 003367   200011 470500                    LDP0    PCB$,,AUTO
         1 003370   000000 471500                    LDP1    0,,PR0
         1 003371   200003 473500                    LDP3    @G$D,,AUTO
         1 003372   300013 235100                    LDA     11,,PR3
         1 003373   040100 100505                    MLR     fill='040'O
         1 003374   100000 000001                    ADSC9   0,A,PR1                  cn=0,n=1
         1 003375   200012 000001                    ADSC9   CURCHAR,,AUTO            cn=0,n=1

     2371     6812    3           G$D.CCHAR = CURCHAR;

   6812  1 003376   200012 236100                    LDQ     CURCHAR,,AUTO
         1 003377   300015 552140                    STBQ    13,'40'O,PR3

     2372     6813    3           RETURN;

   6813  1 003400   200060 221300                    LDX1  ! @TYPE+1,,AUTO
         1 003401   000001 702211                    TSX2  ! 1,X1

     2373     6814    3       END;
     2374     6815    2       GOTO NOMORETXT;

   6815  1 003402   003433 710000 1                  TRA     NOMORETXT

     2375     6816
     2376     6817        /*I*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:281  
     2377     6818            NAME: SAVE_POS
     2378     6819            PURPOSE: Reset position in command after failure.
     2379     6820            CALL:
     2380     6821                CALL SAVE_POS;
     2381     6822            INPUT:
     2382     6823                SAVEPOS, SAVELEX, SKIPBL -- fallback values of correspoinding G$D fields
     2383     6824            OUTPUT:
     2384     6825                G$D.CCPOS, G$D.CLEXPOS, G$D.SKIPBL -- reset to fallback values
     2385     6826                G$D.CCHAR, CURCHAR -- reset to character at fallback position
     2386     6827            DESCRIPTION:
     2387     6828                This routine is called when an attempted parse fails.  It sets
     2388     6829                the current position in the command text back to what it was
     2389     6830                before the parse was attempted.
     2390     6831        */
     2391     6832    2   SAVE_POS: ENTRY;

   6832  1 003403   200060 741300       SAVE_POS     STX1  ! @TYPE+1,,AUTO

     2392     6833    2       G$D.CCPOS=SAVEPOS+G$D.CNTUPOS;

   6833  1 003404   200003 470500                    LDP0    @G$D,,AUTO
         1 003405   200005 236100                    LDQ     SAVEPOS,,AUTO
         1 003406   000012 036100                    ADLQ    10,,PR0
         1 003407   000013 756100                    STQ     11,,PR0

     2393     6834    2       G$D.CLEXPOS = SAVELEX + G$D.CNTUPOS;

   6834  1 003410   200006 236100                    LDQ     SAVELEX,,AUTO
         1 003411   000012 036100                    ADLQ    10,,PR0
         1 003412   000014 756100                    STQ     12,,PR0

     2394     6835    2       G$D.BLSKIP=SKIPBL;

   6835  1 003413   200007 236100                    LDQ     SKIPBL,,AUTO
         1 003414   000011 772000                    QRL     9
         1 003415   000015 676100                    ERQ     13,,PR0
         1 003416   000400 376003                    ANQ     256,DU
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:282  
         1 003417   000015 656100                    ERSQ    13,,PR0
         1 003420   003422 710000 1                  TRA     s:6859

     2395     6836
     2396     6837        /*I*
     2397     6838            NAME: SET_CHAR
     2398     6839            PURPOSE: Reset the position in the command after a user exit.
     2399     6840            CALL:
     2400     6841                CALL SET_CHAR
     2401     6842            INPUT:
     2402     6843                P$PCB.NCHARS -- number of characters in the command text.
     2403     6844                G$D.CCPOS -- current position in command.
     2404     6845            OUTPUT:
     2405     6846                NCHARS -- reset to P$PCB.NCHARS
     2406     6847                G$D.CCHAR, CURCHAR -- set to character at current position.
     2407     6848            DESCRIPTION:
     2408     6849                This routine is called after an exit to the user routine to
     2409     6850                reset the command size and current character, in case the
     2410     6851                user routine changed them.
     2411     6852
     2412     6853                Note that, if CNTUPOS causes CCPOS to go negative (due to a
     2413     6854                continuation line overlaying the previous text), CCHARS is set
     2414     6855                to zero, which will cause all subsequent attempts to parse a
     2415     6856                lexeme (and therefore, anything at all) to fail.
     2416     6857        */
     2417     6858    2   SET_CHAR: ENTRY;

   6858  1 003421   200060 741300       SET_CHAR     STX1  ! @TYPE+1,,AUTO

     2418     6859    2       NCHARS=P$PCB.NCHARS;

   6859  1 003422   200011 470500                    LDP0    PCB$,,AUTO
         1 003423   000011 235100                    LDA     9,,PR0
         1 003424   200013 755100                    STA     NCHARS,,AUTO

     2419     6860    2       IF G$D.CCPOS>=0 THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:283  
   6860  1 003425   200003 471500                    LDP1    @G$D,,AUTO
         1 003426   100013 235100                    LDA     11,,PR1
         1 003427   003436 604000 1                  TMI     s:6865

     2420     6861    2           IF G$D.CCPOS<NCHARS THEN GOTO STCHAR;

   6861  1 003430   100013 236100                    LDQ     11,,PR1
         1 003431   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003432   003367 604000 1                  TMI     STCHAR

     2421     6862    2           ELSE
     2422     6863    2   NOMORETXT:
     2423     6864    2               G$D.CCPOS = NCHARS;

   6864  1 003433   200003 470500       NOMORETXT    LDP0    @G$D,,AUTO
         1 003434   200013 235100                    LDA     NCHARS,,AUTO
         1 003435   000013 755100                    STA     11,,PR0

     2424     6865    2       G$D.CCHAR = BINASC(0);

   6865  1 003436   200003 470500                    LDP0    @G$D,,AUTO
         1 003437   000000 236003                    LDQ     0,DU
         1 003440   000015 552140                    STBQ    13,'40'O,PR0

     2425     6866    2       CURCHAR = BINASC(0);

   6866  1 003441   200012 756100                    STQ     CURCHAR,,AUTO

     2426     6867    2       RETURN;

   6867  1 003442   200060 221300                    LDX1  ! @TYPE+1,,AUTO
         1 003443   000001 702211                    TSX2  ! 1,X1

     2427     6868    2   END   ADVCHAR;
     2428     6869        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:284  
     2429     6870        /*I*
     2430     6871            NAME: XUP$COMCHK
     2431     6872            PURPOSE: Check for leading whitespace in the command text.
     2432     6873            CALL:
     2433     6874                CALL XUP$COMCHK (G$D) ALTRET(not-used);
     2434     6875            PARAMETERS:
     2435     6876                G$D -- Parser global data structure.
     2436     6877            INTERFACE:
     2437     6878                CHK_CONTINUE
     2438     6879            DESCRIPTION:
     2439     6880                This routine is called from X$PARSE to skip past any leading
     2440     6881                whitespace in the command being parsed.  It merely sets local
     2441     6882                variables used by CHK_CONTINUE and calls that routine.
     2442     6883        */
     2443     6884    1   XUP$COMCHK: ENTRY(G$D) ALTRET;

   6884  1 003444   000000 700200 xent  XUP$COMCHK   TSX0  ! X66_AUTO_1
         1 003445   000072 000001                    ZERO    58,1

     2444     6885    1       PCB$=G$D.PCB$;

   6885  1 003446   200003 470500                    LDP0    @G$D,,AUTO
         1 003447   000000 236100                    LDQ     0,,PR0
         1 003450   200011 756100                    STQ     PCB$,,AUTO

     2445     6886    1       NCHARS=P$PCB.NCHARS;

   6886  1 003451   200011 471500                    LDP1    PCB$,,AUTO
         1 003452   100011 235100                    LDA     9,,PR1
         1 003453   200013 755100                    STA     NCHARS,,AUTO

     2446     6887    2       IF NCHARS~=0 THEN DO;

   6887  1 003454   003465 600000 1                  TZE     s:6892

     2447     6888    2           G$D.CCHAR=P$PCB.TEXT$->C$BUFA(0);

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:285  
   6888  1 003455   100000 473500                    LDP3    0,,PR1
         1 003456   040100 100500                    MLR     fill='040'O
         1 003457   300000 000001                    ADSC9   0,,PR3                   cn=0,n=1
         1 003460   000015 000001                    ADSC9   13,,PR0                  cn=0,n=1

     2448     6889    2           NODE$=P$PCB.ROOT$;

   6889  1 003461   100001 236100                    LDQ     1,,PR1
         1 003462   200010 756100                    STQ     NODE$,,AUTO

     2449     6890    2           CALL CHK_CONTUE;

   6890  1 003463   002756 701000 1                  TSX1    CHK_CONTUE
         1 003464   000000 011000                    NOP     0

     2450     6891    2       END;

     2451     6892    1       RETURN;

   6892  1 003465   000000 702200 xent               TSX2  ! X66_ARET

     2452     6893        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:286  
     2453     6894        /*I*
     2454     6895            NAME: CHK_COMMENT
     2455     6896            PURPOSE: Skip past a comment in the command text.
     2456     6897            CALL:
     2457     6898                CALL CHK_COMMENT (INDX) ALTRET(end-of-line);
     2458     6899            PARAMETERS:
     2459     6900                INDX -- the position to check for the start of a comment.
     2460     6901            INPUT:
     2461     6902                NCHARS -- the number of characters in the command.
     2462     6903                G$D.LDCMNT -- defines the leading comment delimiter.
     2463     6904                G$D.TRCMNT -- defines the trailing comment delimiter.
     2464     6905            OUTPUT:
     2465     6906                G$D.BLKSIP -- set if a comment was found
     2466     6907                INDX -- points past the comment if one was found
     2467     6908            DESCRIPTION:
     2468     6909                This routine parses comments in the command text.
     2469     6910        */
     2470     6911    1   CHK_COMMENT:

   6911  1 003466   200062 741300       CHK_COMMENT  STX1  ! @TYPE+3,,AUTO

     2471     6912    1       PROC(INDX) ALTRET;
     2472     6913    2   DCL     INDX  UBIN  WORD;
     2473     6914    2   DCL     TINDX UBIN  WORD;
     2474     6915        /*D*
     2475     6916            Loop until no comment is found.
     2476     6917        */
     2477     6918    3       DO WHILE('1'B);

     2478     6919        /*D*
     2479     6920            Return if there are not enough character left to begin a comment.
     2480     6921        */
     2481     6922    3           IF NCHARS<G$D.LDCMNT.CT+INDX THEN

   6922  1 003467   200063 470500                    LDP0    @INDX,,AUTO
         1 003470   200003 471500                    LDP1    @G$D,,AUTO
         1 003471   100016 236100                    LDQ     14,,PR1
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:287  
         1 003472   000022 772000                    QRL     18
         1 003473   000000 036100                    ADLQ    0,,PR0
         1 003474   003477 604000 1                  TMI     s:6923
         1 003475   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003476   003501 604400 1                  TMOZ    s:6928

     2482     6923    3               RETURN;

   6923  1 003477   200062 221300                    LDX1  ! @TYPE+3,,AUTO
         1 003500   000001 702211                    TSX2  ! 1,X1

     2483     6924        /*D*
     2484     6925            Otherwise, try to parse a leading comment delimiter.
     2485     6926            Logic to do this depends on the number of characters in the delimiter:
     2486     6927        */
     2487     6928    4           DO CASE(G$D.LDCMNT.CT);

   6928  1 003501   100016 220100                    LDX0    14,,PR1
         1 003502   000003 100003                    CMPX0   3,DU
         1 003503   003505 602010 1                  TNC     s:6928+4,X0
         1 003504   003654 710000 1                  TRA     s:7024
         1 003505   003510 710000 1                  TRA     s:6933
         1 003506   003512 710000 1                  TRA     s:6939
         1 003507   003640 710000 1                  TRA     s:7014

     2488     6929        /*D*
     2489     6930            o   Null leading delimiter: there can be no comments; return.
     2490     6931        */
     2491     6932    4           CASE(0);

     2492     6933    4               RETURN;

   6933  1 003510   200062 221300                    LDX1  ! @TYPE+3,,AUTO
         1 003511   000001 702211                    TSX2  ! 1,X1

     2493     6934        /*D*
     2494     6935            o   Single leading delimiter character:
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:288  
     2495     6936                Return if the current character isn't the delimiter.
     2496     6937        */
     2497     6938    4           CASE(1);

     2498     6939    4               IF P$PCB.TEXT$->C$BUFA(INDX) ~= G$D.LDCMNT.TXA(0) THEN

   6939  1 003512   200011 473500                    LDP3    PCB$,,AUTO
         1 003513   300000 474500                    LDP4    0,,PR3
         1 003514   000000 235100                    LDA     0,,PR0
         1 003515   040100 106505                    CMPC    fill='040'O
         1 003516   400000 000001                    ADSC9   0,A,PR4                  cn=0,n=1
         1 003517   100016 400001                    ADSC9   14,,PR1                  cn=2,n=1
         1 003520   003523 600000 1                  TZE     FIND_TRCMNT

     2499     6940    4                   RETURN;

   6940  1 003521   200062 221300                    LDX1  ! @TYPE+3,,AUTO
         1 003522   000001 702211                    TSX2  ! 1,X1

     2500     6941        /*D*
     2501     6942            o   If a leading delimier is found, bump past it and look for a
     2502     6943                trailing delimiter.
     2503     6944        */
     2504     6945    4   FIND_TRCMNT: INDX = INDX+1;

   6945  1 003523   200063 470500       FIND_TRCMNT  LDP0    @INDX,,AUTO
         1 003524   000000 235100                    LDA     0,,PR0
         1 003525   000001 035007                    ADLA    1,DL
         1 003526   000000 755100                    STA     0,,PR0

     2505     6946        /*D*
     2506     6947            o       If there are not enough character left for a trailing
     2507     6948                    delimiter, the comment continues to the end of the line.
     2508     6949        */
     2509     6950    4               IF NCHARS<G$D.TRCMNT.CT+INDX THEN

   6950  1 003527   200003 471500                    LDP1    @G$D,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:289  
         1 003530   100017 236100                    LDQ     15,,PR1
         1 003531   000022 772000                    QRL     18
         1 003532   000000 036100                    ADLQ    0,,PR0
         1 003533   003626 604000 1                  TMI     END_OF_TEXT
         1 003534   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003535   003626 605400 1                  TPNZ    END_OF_TEXT

     2510     6951    4                   GOTO END_OF_TEXT;
     2511     6952        /*D*
     2512     6953            o       Otherwise, scan for the end of the comment.
     2513     6954                    Logic to do this depends on the number of characters in
     2514     6955                    the trailing delimiter:
     2515     6956        */
     2516     6957    5               DO CASE(G$D.TRCMNT.CT);

   6957  1 003536   100017 220100                    LDX0    15,,PR1
         1 003537   000003 100003                    CMPX0   3,DU
         1 003540   003542 602010 1                  TNC     s:6957+4,X0
         1 003541   003611 710000 1                  TRA     s:6994
         1 003542   003545 710000 1                  TRA     s:6963
         1 003543   003546 710000 1                  TRA     s:6971
         1 003544   003567 710000 1                  TRA     s:6982

     2517     6958        /*D*
     2518     6959            o       Null trailing delimiter:
     2519     6960                    The comment extends to the end of the line.
     2520     6961        */
     2521     6962    5               CASE(0);

     2522     6963    5                   GOTO END_OF_TEXT;

   6963  1 003545   003626 710000 1                  TRA     END_OF_TEXT

     2523     6964        /*D*
     2524     6965            o       Single trailing delimiter character:
     2525     6966                    Scan the remainder of the command for the delimiter.
     2526     6967                    If found, set the character position to point past the delimiter.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:290  
     2527     6968                    Otherwise, the comment continues to the end of the line.
     2528     6969        */
     2529     6970    5               CASE(1);

     2530     6971    5                   CALL INDEX(TINDX,

   6971  1 003546   200011 473500                    LDP3    PCB$,,AUTO
         1 003547   300000 474500                    LDP4    0,,PR3
         1 003550   200013 236100                    LDQ     NCHARS,,AUTO
         1 003551   000000 136100                    SBLQ    0,,PR0
         1 003552   200066 756100                    STQ     TINDX+2,,AUTO
         1 003553   000000 236100                    LDQ     0,,PR0
         1 003554   200066 720100                    LXL0    TINDX+2,,AUTO
         1 003555   000100 124545                    SCM     mask='000'O
         1 003556   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 003557   100017 400001                    ADSC9   15,,PR1                  cn=2,n=1
         1 003560   200064 000100                    ARG     TINDX,,AUTO
         1 003561   200064 056100                    ASQ     TINDX,,AUTO
         1 003562   003626 606400 1                  TTN     END_OF_TEXT

     2531     6972    5                     G$D.TRCMNT.TXA(0),
     2532     6973    5                     P$PCB.TEXT$->C$BUF,
     2533     6974    5                     INDX) ALTRET(END_OF_TEXT);
     2534     6975    5                   INDX = TINDX + 1;

   6975  1 003563   200064 235100                    LDA     TINDX,,AUTO
         1 003564   000001 035007                    ADLA    1,DL
         1 003565   000000 755100                    STA     0,,PR0
         1 003566   003611 710000 1                  TRA     s:6994

     2535     6976        /*D*
     2536     6977            o       Double character trailing delimiter:
     2537     6978                    Do the same as for a single character delimter, except
     2538     6979                    that the delimiter to scan for and skip is two characters.
     2539     6980        */
     2540     6981    5               CASE(2);

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:291  
     2541     6982    5                   CALL INDEX(TINDX,

   6982  1 003567   200011 473500                    LDP3    PCB$,,AUTO
         1 003570   300000 474500                    LDP4    0,,PR3
         1 003571   200013 236100                    LDQ     NCHARS,,AUTO
         1 003572   000000 136100                    SBLQ    0,,PR0
         1 003573   200066 756100                    STQ     TINDX+2,,AUTO
         1 003574   000000 236100                    LDQ     0,,PR0
         1 003575   200066 720100                    LXL0    TINDX+2,,AUTO
         1 003576   000100 120545                    SCD
         1 003577   400000 000010                    ADSC9   0,A,PR4                  cn=0,n=*X0
         1 003600   100017 400002                    ADSC9   15,,PR1                  cn=2,n=2
         1 003601   200064 000100                    ARG     TINDX,,AUTO
         1 003602   200064 056100                    ASQ     TINDX,,AUTO
         1 003603   003606 607000 1                  TTF     s:6986
         1 003604   200064 054100                    AOS     TINDX,,AUTO
         1 003605   003626 710000 1                  TRA     END_OF_TEXT

     2542     6983    5                     G$D.TRCMNT.TX,
     2543     6984    5                     P$PCB.TEXT$->C$BUF,
     2544     6985    5                     INDX) ALTRET(END_OF_TEXT);
     2545     6986    5                   INDX = TINDX + 2;

   6986  1 003606   200064 235100                    LDA     TINDX,,AUTO
         1 003607   000002 035007                    ADLA    2,DL
         1 003610   000000 755100                    STA     0,,PR0

     2546     6987    5               END;

     2547     6988        /*D*
     2548     6989            o       If a trailing delimiter was found, and the comment being
     2549     6990                    parsed is part of the command text (i.e., we're not eating
     2550     6991                    a comment following a continuation mark), reset the current
     2551     6992                    character to the one following the comment.
     2552     6993        */
     2553     6994    4               IF INDX=G$D.CCPOS THEN

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:292  
   6994  1 003611   000000 236100                    LDQ     0,,PR0
         1 003612   003654 604000 1                  TMI     s:7024
         1 003613   100013 116100                    CMPQ    11,,PR1
         1 003614   003654 601000 1                  TNZ     s:7024

     2554     6995    4                   IF G$D.CCPOS<NCHARS THEN

   6995  1 003615   100013 236100                    LDQ     11,,PR1
         1 003616   200013 116100                    CMPQ    NCHARS,,AUTO
         1 003617   003626 605000 1                  TPL     END_OF_TEXT

     2555     6996    4                       G$D.CCHAR=P$PCB.TEXT$->C$BUFA(G$D.CCPOS);

   6996  1 003620   200011 473500                    LDP3    PCB$,,AUTO
         1 003621   300000 474500                    LDP4    0,,PR3
         1 003622   040100 100506                    MLR     fill='040'O
         1 003623   400000 000001                    ADSC9   0,Q,PR4                  cn=0,n=1
         1 003624   100015 000001                    ADSC9   13,,PR1                  cn=0,n=1
         1 003625   003654 710000 1                  TRA     s:7024

     2556     6997    5                   ELSE DO;

     2557     6998        /*D*
     2558     6999            o       If the comment continues to the end of the line, set the
     2559     7000                    current position to the length of the line, null out the
     2560     7001                    current character, and altreturn.
     2561     7002        */
     2562     7003    5   END_OF_TEXT:        INDX = NCHARS;

   7003  1 003626   200013 235100       END_OF_TEXT  LDA     NCHARS,,AUTO
         1 003627   200063 470500                    LDP0    @INDX,,AUTO
         1 003630   000000 755100                    STA     0,,PR0

     2563     7004    5                       G$D.BLSKIP='1'B;

   7004  1 003631   200003 471500                    LDP1    @G$D,,AUTO
         1 003632   000400 236003                    LDQ     256,DU
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:293  
         1 003633   100015 256100                    ORSQ    13,,PR1

     2564     7005    5                       G$D.CCHAR=BINASC(0);

   7005  1 003634   000000 236003                    LDQ     0,DU
         1 003635   100015 552140                    STBQ    13,'40'O,PR1

     2565     7006    5                       ALTRETURN;

   7006  1 003636   200062 221300                    LDX1  ! @TYPE+3,,AUTO
         1 003637   000000 702211                    TSX2  ! 0,X1

     2566     7007    5                   END;
     2567     7008        /*D*
     2568     7009            o   Double character leadiing delimiter:
     2569     7010                Process similar to a single character delimiter, except that
     2570     7011                the delimiter to check for and skip past is two characters long.
     2571     7012        */
     2572     7013    4           CASE(2);

     2573     7014    4               IF SUBSTR(P$PCB.TEXT$->C$BUF,INDX,2)~=

   7014  1 003640   200011 473500                    LDP3    PCB$,,AUTO
         1 003641   300000 474500                    LDP4    0,,PR3
         1 003642   000000 235100                    LDA     0,,PR0
         1 003643   040100 106505                    CMPC    fill='040'O
         1 003644   400000 000002                    ADSC9   0,A,PR4                  cn=0,n=2
         1 003645   100016 400002                    ADSC9   14,,PR1                  cn=2,n=2
         1 003646   003651 600000 1                  TZE     s:7017

     2574     7015    4                 G$D.LDCMNT.TX THEN
     2575     7016    4                   RETURN;

   7016  1 003647   200062 221300                    LDX1  ! @TYPE+3,,AUTO
         1 003650   000001 702211                    TSX2  ! 1,X1

     2576     7017    4               INDX=INDX+1;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:294  

   7017  1 003651   000001 035007                    ADLA    1,DL
         1 003652   000000 755100                    STA     0,,PR0

     2577     7018    4               GOTO FIND_TRCMNT;

   7018  1 003653   003523 710000 1                  TRA     FIND_TRCMNT

     2578     7019    4           END;

     2579     7020        /*D*
     2580     7021            If a comment is found, set G$D.BLSKIP to indicate that whitespace
     2581     7022            has been skipped.
     2582     7023        */
     2583     7024    3           G$D.BLSKIP='1'B;

   7024  1 003654   000400 236003                    LDQ     256,DU
         1 003655   100015 256100                    ORSQ    13,,PR1

     2584     7025    3       END;

   7025  1 003656   003467 710000 1                  TRA     s:6922

     2585     7026    2   END CHK_COMMENT;
     2586     7027        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:295  
     2587     7028        /*I*
     2588     7029            NAME: OUTBLK_COMMON
     2589     7030            PURPOSE:
     2590     7031                Fill in common fields in output blocks.
     2591     7032            CALL:
     2592     7033                CALL OUTBLK_COMMON;
     2593     7034            INPUT:
     2594     7035                BLK$ -- points to block to be filled in.
     2595     7036        */
     2596     7037    1   OUTBLK_COMMON: PROC;

   7037  1 003657   200046 741300       OUTBLK_COMM* STX1  ! PARSE$PARAM+9,,AUTO

     2597     7038
     2598     7039    2       BLK$->OUT$BLK.CODE = P$NODE.CODE;

   7039  1 003660   200010 470500                    LDP0    NODE$,,AUTO
         1 003661   000000 720100                    LXL0    0,,PR0
         1 003662   177777 360003                    ANX0    65535,DU
         1 003663   200027 471500                    LDP1    BLK$,,AUTO
         1 003664   100000 440100                    SXL0    0,,PR1

     2599     7040    2       IF P$NODE.RTEXT THEN

   7040  1 003665   000000 236100                    LDQ     0,,PR0
         1 003666   000200 316003                    CANQ    128,DU
         1 003667   003673 600000 1                  TZE     s:7043

     2600     7041    2           BLK$ -> OUT$BLK.NDTYPE = %RTEXT#;

   7041  1 003670   000034 236003                    LDQ     28,DU
         1 003671   100000 752110                    STCQ    0,'10'O,PR1
         1 003672   004050 710000 1                  TRA     s:7073

     2601     7042    2       ELSE
     2602     7043    3       DO CASE (P$NODE.TYPE);

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:296  
   7043  1 003673   000000 236100                    LDQ     0,,PR0
         1 003674   000041 772000                    QRL     33
         1 003675   000007 116007                    CMPQ    7,DL
         1 003676   003700 602006 1                  TNC     s:7043+5,QL
         1 003677   004050 710000 1                  TRA     s:7073
         1 003700   004050 710000 1                  TRA     s:7073
         1 003701   003707 710000 1                  TRA     s:7045
         1 003702   003712 710000 1                  TRA     s:7047
         1 003703   003715 710000 1                  TRA     s:7049
         1 003704   003720 710000 1                  TRA     s:7051
         1 003705   003723 710000 1                  TRA     s:7053
         1 003706   003726 710000 1                  TRA     s:7055

     2603     7044    3       CASE (%TYPE_ALTERN#);

     2604     7045    3           BLK$ -> OUT$BLK.NDTYPE = %ALTERN#;

   7045  1 003707   000001 236003                    LDQ     1,DU
         1 003710   100000 752110                    STCQ    0,'10'O,PR1
         1 003711   004050 710000 1                  TRA     s:7073

     2605     7046    3       CASE (%TYPE_RALTERN#);

     2606     7047    3           BLK$ -> OUT$BLK.NDTYPE = %RALTERN#;

   7047  1 003712   000010 236003                    LDQ     8,DU
         1 003713   100000 752110                    STCQ    0,'10'O,PR1
         1 003714   004050 710000 1                  TRA     s:7073

     2607     7048    3       CASE (%TYPE_LIST#);

     2608     7049    3           BLK$ -> OUT$BLK.NDTYPE = %LIST#;

   7049  1 003715   000003 236003                    LDQ     3,DU
         1 003716   100000 752110                    STCQ    0,'10'O,PR1
         1 003717   004050 710000 1                  TRA     s:7073

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:297  
     2609     7050    3       CASE (%TYPE_KONCAT#);

     2610     7051    3           BLK$ -> OUT$BLK.NDTYPE = %KONCAT#;

   7051  1 003720   000002 236003                    LDQ     2,DU
         1 003721   100000 752110                    STCQ    0,'10'O,PR1
         1 003722   004050 710000 1                  TRA     s:7073

     2611     7052    3       CASE (%TYPE_LITERAL#);

     2612     7053    3           BLK$ -> OUT$BLK.NDTYPE = %LITERAL#;

   7053  1 003723   000004 236003                    LDQ     4,DU
         1 003724   100000 752110                    STCQ    0,'10'O,PR1
         1 003725   004050 710000 1                  TRA     s:7073

     2613     7054    3       CASE (%TYPE_LEXEME#);

     2614     7055    4           DO CASE (P$SYM.LEXTYPE);

   7055  1 003726   000000 236100                    LDQ     0,,PR0
         1 003727   000020 772000                    QRL     16
         1 003730   000037 376007                    ANQ     31,DL
         1 003731   000040 116007                    CMPQ    32,DL
         1 003732   003734 602006 1                  TNC     s:7055+6,QL
         1 003733   004050 710000 1                  TRA     s:7073
         1 003734   004050 710000 1                  TRA     s:7073
         1 003735   003774 710000 1                  TRA     s:7056
         1 003736   003777 710000 1                  TRA     s:7057
         1 003737   004002 710000 1                  TRA     s:7058
         1 003740   004005 710000 1                  TRA     s:7059
         1 003741   004010 710000 1                  TRA     s:7060
         1 003742   004013 710000 1                  TRA     s:7061
         1 003743   004016 710000 1                  TRA     s:7062
         1 003744   004021 710000 1                  TRA     s:7063
         1 003745   004027 710000 1                  TRA     s:7065
         1 003746   004024 710000 1                  TRA     s:7064
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:298  
         1 003747   004032 710000 1                  TRA     s:7066
         1 003750   004035 710000 1                  TRA     s:7067
         1 003751   004050 710000 1                  TRA     s:7073
         1 003752   004050 710000 1                  TRA     s:7073
         1 003753   004050 710000 1                  TRA     s:7073
         1 003754   004050 710000 1                  TRA     s:7073
         1 003755   004050 710000 1                  TRA     s:7073
         1 003756   004050 710000 1                  TRA     s:7073
         1 003757   004050 710000 1                  TRA     s:7073
         1 003760   004040 710000 1                  TRA     s:7068
         1 003761   004043 710000 1                  TRA     s:7069
         1 003762   004050 710000 1                  TRA     s:7073
         1 003763   004050 710000 1                  TRA     s:7073
         1 003764   004050 710000 1                  TRA     s:7073
         1 003765   004050 710000 1                  TRA     s:7073
         1 003766   004050 710000 1                  TRA     s:7073
         1 003767   004050 710000 1                  TRA     s:7073
         1 003770   004050 710000 1                  TRA     s:7073
         1 003771   004050 710000 1                  TRA     s:7073
         1 003772   004050 710000 1                  TRA     s:7073
         1 003773   004046 710000 1                  TRA     s:7070

     2615     7056    4           CASE (%LEX_DECIMAL#); BLK$ -> OUT$BLK.NDTYPE = %DEC#;

   7056  1 003774   000022 236003                    LDQ     18,DU
         1 003775   100000 752110                    STCQ    0,'10'O,PR1
         1 003776   004050 710000 1                  TRA     s:7073

     2616     7057    4           CASE (%LEX_OCTAL#); BLK$ -> OUT$BLK.NDTYPE = %OCT#;

   7057  1 003777   000021 236003                    LDQ     17,DU
         1 004000   100000 752110                    STCQ    0,'10'O,PR1
         1 004001   004050 710000 1                  TRA     s:7073

     2617     7058    4           CASE (%LEX_HEX#); BLK$ -> OUT$BLK.NDTYPE = %HEX#;

   7058  1 004002   000031 236003                    LDQ     25,DU
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:299  
         1 004003   100000 752110                    STCQ    0,'10'O,PR1
         1 004004   004050 710000 1                  TRA     s:7073

     2618     7059    4           CASE (%LEX_ALPHA#); BLK$ -> OUT$BLK.NDTYPE = %ALPHA#;

   7059  1 004005   000023 236003                    LDQ     19,DU
         1 004006   100000 752110                    STCQ    0,'10'O,PR1
         1 004007   004050 710000 1                  TRA     s:7073

     2619     7060    4           CASE (%LEX_ANUMERIC#); BLK$ -> OUT$BLK.NDTYPE = %ALNUM#;

   7060  1 004010   000024 236003                    LDQ     20,DU
         1 004011   100000 752110                    STCQ    0,'10'O,PR1
         1 004012   004050 710000 1                  TRA     s:7073

     2620     7061    4           CASE (%LEX_SYMBOL#); BLK$ -> OUT$BLK.NDTYPE = %SYM#;

   7061  1 004013   000025 236003                    LDQ     21,DU
         1 004014   100000 752110                    STCQ    0,'10'O,PR1
         1 004015   004050 710000 1                  TRA     s:7073

     2621     7062    4           CASE (%LEX_PL6SYM#); BLK$ -> OUT$BLK.NDTYPE = %PL6SYM#;

   7062  1 004016   000030 236003                    LDQ     24,DU
         1 004017   100000 752110                    STCQ    0,'10'O,PR1
         1 004020   004050 710000 1                  TRA     s:7073

     2622     7063    4           CASE (%LEX_FID#); BLK$ -> OUT$BLK.NDTYPE = %FID#;

   7063  1 004021   000026 236003                    LDQ     22,DU
         1 004022   100000 752110                    STCQ    0,'10'O,PR1
         1 004023   004050 710000 1                  TRA     s:7073

     2623     7064    4           CASE (%LEX_ACCOUNT#); BLK$ -> OUT$BLK.NDTYPE = %ACCOUNT#;

   7064  1 004024   000033 236003                    LDQ     27,DU
         1 004025   100000 752110                    STCQ    0,'10'O,PR1
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:300  
         1 004026   004050 710000 1                  TRA     s:7073

     2624     7065    4           CASE (%LEX_JOBNAME#); BLK$ -> OUT$BLK.NDTYPE = %JOBNAME#;

   7065  1 004027   000032 236003                    LDQ     26,DU
         1 004030   100000 752110                    STCQ    0,'10'O,PR1
         1 004031   004050 710000 1                  TRA     s:7073

     2625     7066    4           CASE (%LEX_ASYM#); BLK$ -> OUT$BLK.NDTYPE = %ASYM#;

   7066  1 004032   000027 236003                    LDQ     23,DU
         1 004033   100000 752110                    STCQ    0,'10'O,PR1
         1 004034   004050 710000 1                  TRA     s:7073

     2626     7067    4           CASE (%LEX_NULL#); BLK$ -> OUT$BLK.NDTYPE = %NULL#;

   7067  1 004035   000020 236003                    LDQ     16,DU
         1 004036   100000 752110                    STCQ    0,'10'O,PR1
         1 004037   004050 710000 1                  TRA     s:7073

     2627     7068    4           CASE (%LEX_BLANK#); BLK$ -> OUT$BLK.NDTYPE = %BLANK#;

   7068  1 004040   000007 236003                    LDQ     7,DU
         1 004041   100000 752110                    STCQ    0,'10'O,PR1
         1 004042   004050 710000 1                  TRA     s:7073

     2628     7069    4           CASE (%LEX_END#); BLK$ -> OUT$BLK.NDTYPE = %EOL#;

   7069  1 004043   000006 236003                    LDQ     6,DU
         1 004044   100000 752110                    STCQ    0,'10'O,PR1
         1 004045   004050 710000 1                  TRA     s:7073

     2629     7070    4           CASE (%LEX_DSTRING#); BLK$ -> OUT$BLK.NDTYPE = %DSTRING#;

   7070  1 004046   000005 236003                    LDQ     5,DU
         1 004047   100000 752110                    STCQ    0,'10'O,PR1

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:301  
     2630     7071    4           END;

     2631     7072    3       END;

     2632     7073    2       RETURN;

   7073  1 004050   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 004051   000001 702211                    TSX2  ! 1,X1

     2633     7074    2   END OUTBLK_COMMON;
     2634     7075        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:302  
     2635     7076        /*I*
     2636     7077            NAME: FREESTACK
     2637     7078            PURPOSE: Pop and release output blocks from parse stack.
     2638     7079            CALL:
     2639     7080                CALL FREESTACK (NSUBLKS);
     2640     7081            PARAMETERS:
     2641     7082                NSUBLKS -- number of parse stack blocks to free
     2642     7083            INTERFACE:
     2643     7084                XUP$FREEOUT
     2644     7085            DESCRIPTION:
     2645     7086                This routine pops the specified number of output blocks off
     2646     7087                the top of the parse stack, and releases the space consumed
     2647     7088                by them and all their subblocks.
     2648     7089        */
     2649     7090    1   FREESTACK: PROC (NSUBLKS);

   7090  1 004052   200050 741300       FREESTACK    STX1  ! J+1,,AUTO

     2650     7091
     2651     7092    2   DCL NSUBLKS UBIN;
     2652     7093    2   DCL I SBIN;
     2653     7094
     2654     7095    3       DO I = 0 TO NSUBLKS - 1;

   7095  1 004053   200052 450100                    STZ     I,,AUTO
         1 004054   004071 710000 1                  TRA     s:7097+1

     2655     7096    3           CALL XUP$FREEOUT (G$D.STACKTOP$ -> STACKARY$(I), G$D);

   7096  1 004055   200003 470500                    LDP0    @G$D,,AUTO
         1 004056   000010 471500                    LDP1    8,,PR0
         1 004057   200003 236100                    LDQ     @G$D,,AUTO
         1 004060   200067 756100                    STQ     TINDX+3,,AUTO
         1 004061   200052 720100                    LXL0    I,,AUTO
         1 004062   100000 633510                    EPPR3   0,X0,PR1
         1 004063   200066 453500                    STP3    TINDX+2,,AUTO
         1 004064   200066 630500                    EPPR0   TINDX+2,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:303  
         1 004065   000020 631400 xsym               EPPR1   B_VECTNIL+16
         1 004066   000000 701000 xent               TSX1    XUP$FREEOUT
         1 004067   000000 011000                    NOP     0

     2656     7097    3       END;

   7097  1 004070   200052 054100                    AOS     I,,AUTO
         1 004071   200051 470500                    LDP0    @NSUBLKS,,AUTO
         1 004072   200052 236100                    LDQ     I,,AUTO
         1 004073   004055 604000 1                  TMI     s:7096
         1 004074   000000 116100                    CMPQ    0,,PR0
         1 004075   004055 602000 1                  TNC     s:7096

     2657     7098    2       G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$, NSUBLKS);

   7098  1 004076   000000 720100                    LXL0    0,,PR0
         1 004077   200003 471500                    LDP1    @G$D,,AUTO
         1 004100   100010 473500                    LDP3    8,,PR1
         1 004101   300000 634510                    EPPR4   0,X0,PR3
         1 004102   100010 454500                    STP4    8,,PR1

     2658     7099
     2659     7100    2       RETURN;

   7100  1 004103   200050 221300                    LDX1  ! J+1,,AUTO
         1 004104   000001 702211                    TSX2  ! 1,X1

     2660     7101    2   END FREESTACK;
     2661     7102        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:304  
     2662     7103        /*I*
     2663     7104            NAME: SUCCEED_BLK
     2664     7105            PURPOSE: Common success processing for syntactic and lexical nodes.
     2665     7106            CALL:
     2666     7107                CALL SUCCEED_BLK;
     2667     7108            OUTPUT:
     2668     7109                I -- completion code:
     2669     7110                    0 = normal exit
     2670     7111                    1 = exit routine requested REJECT
     2671     7112                    2 = exit routine requested RETRY
     2672     7113            DESCRIPTION:
     2673     7114                This routine calls the user exit routine for successful parsing,
     2674     7115                if requested.  Then (if the exit routine doesn't force failure
     2675     7116                or a retry), it pushes the output block, if any, for the node
     2676     7117                onto the parse stack.
     2677     7118        */
     2678     7119    1   SUCCEED_BLK: PROC;

   7119  1 004105   200046 741300       SUCCEED_BLK  STX1  ! PARSE$PARAM+9,,AUTO

     2679     7120
     2680     7121    2       IF P$NODE.S_F = '1'B THEN

   7121  1 004106   200010 470500                    LDP0    NODE$,,AUTO
         1 004107   000000 236100                    LDQ     0,,PR0
         1 004110   020000 316003                    CANQ    8192,DU
         1 004111   004157 600000 1                  TZE     s:7139

     2681     7122    3       DO;

     2682     7123    3           CALL USER_EXIT (%SUCC#);

   7123  1 004112   000011 236000 2                  LDQ     9
         1 004113   200057 756100                    STQ     P$+2,,AUTO
         1 004114   004224 701000 1                  TSX1    USER_EXIT
         1 004115   000000 011000                    NOP     0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:305  
     2683     7124    3           BLK$ = PARSE$PARAM.OUT$;

   7124  1 004116   200037 236100                    LDQ     PARSE$PARAM+2,,AUTO
         1 004117   200027 756100                    STQ     BLK$,,AUTO

     2684     7125    3           IF PARSE$PARAM.REJECT THEN

   7125  1 004120   200035 236100                    LDQ     PARSE$PARAM,,AUTO
         1 004121   000200 316003                    CANQ    128,DU
         1 004122   004127 600000 1                  TZE     s:7130

     2685     7126    4           DO;

     2686     7127    4               I = 1;

   7127  1 004123   000001 235007                    LDA     1,DL
         1 004124   200017 755100                    STA     I,,AUTO

     2687     7128    4               RETURN;

   7128  1 004125   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 004126   000001 702211                    TSX2  ! 1,X1

     2688     7129    4           END;
     2689     7130    3           IF PARSE$PARAM.RETRY THEN

   7130  1 004127   000100 316003                    CANQ    64,DU
         1 004130   004157 600000 1                  TZE     s:7139

     2690     7131    4           DO;

     2691     7132    4               I = (P$PCB.WKSZ - POFFW(G$D.STACKTOP$,P$PCB.WORK$)) - MY_STACK;

   7132  1 004131   200011 470500                    LDP0    PCB$,,AUTO
         1 004132   000002 236100                    LDQ     2,,PR0
         1 004133   000022 772000                    QRL     18
         1 004134   200066 756100                    STQ     TINDX+2,,AUTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:306  
         1 004135   200003 471500                    LDP1    @G$D,,AUTO
         1 004136   100010 236100                    LDQ     8,,PR1
         1 004137   000022 772000                    QRL     18
         1 004140   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 004141   200067 756100                    STQ     TINDX+3,,AUTO
         1 004142   000005 236100                    LDQ     5,,PR0
         1 004143   000022 772000                    QRL     18
         1 004144   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 004145   200015 136100                    SBLQ    MY_STACK,,AUTO
         1 004146   200017 756100                    STQ     I,,AUTO

     2692     7133    4               CALL FREESTACK (I);

   7133  1 004147   200017 633500                    EPPR3   I,,AUTO
         1 004150   200051 453500                    STP3    @NSUBLKS,,AUTO
         1 004151   004052 701000 1                  TSX1    FREESTACK
         1 004152   000000 011000                    NOP     0

     2693     7134    4               I = 2;

   7134  1 004153   000002 235007                    LDA     2,DL
         1 004154   200017 755100                    STA     I,,AUTO

     2694     7135    4               RETURN;

   7135  1 004155   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 004156   000001 702211                    TSX2  ! 1,X1

     2695     7136    4           END;
     2696     7137    3       END;
     2697     7138
     2698     7139    2       IF BLK$ ~= ADDR(NIL) THEN

   7139  1 004157   200027 236100                    LDQ     BLK$,,AUTO
         1 004160   000001 116000 xsym               CMPQ    B_VECTNIL+1
         1 004161   004221 600000 1                  TZE     s:7153

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:307  
     2699     7140    3       DO;

     2700     7141    3           G$D.STACKTOP$ = PINCRW(G$D.STACKTOP$,-1);

   7141  1 004162   200003 470500                    LDP0    @G$D,,AUTO
         1 004163   000010 236100                    LDQ     8,,PR0
         1 004164   777777 036003                    ADLQ    -1,DU
         1 004165   000010 756100                    STQ     8,,PR0

     2701     7142    3           IF G$D.STACKTOP$ <= G$D.HISPACE$ THEN

   7142  1 004166   000007 116100                    CMPQ    7,,PR0
         1 004167   004171 600000 1                  TZE     s:7143
         1 004170   004174 603000 1                  TRC     s:7144

     2702     7143    3               CALL EXPAND_WORKAREA;

   7143  1 004171   004336 701000 1                  TSX1    EXPAND_WORKAREA
         1 004172   000000 011000                    NOP     0
         1 004173   004215 710000 1                  TRA     s:7151

     2703     7144    3           ELSE IF P$PCB.NXT

   7144  1 004174   200011 471500                    LDP1    PCB$,,AUTO
         1 004175   100005 236100                    LDQ     5,,PR1
         1 004176   040000 316007                    CANQ    16384,DL
         1 004177   004215 600000 1                  TZE     s:7151

     2704     7145    4               THEN DO;

     2705     7146    4                   P$ = PINCRW (P$PCB.WORK$, P$PCB.WK_USED);

   7146  1 004200   100010 220100                    LDX0    8,,PR1
         1 004201   100002 473500                    LDP3    2,,PR1
         1 004202   300000 634510                    EPPR4   0,X0,PR3
         1 004203   200023 454500                    STP4    P$,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:308  
     2706     7147    4                   IF ADDR(POSS.NODES$(POSS.COUNT+1)) >= G$D.STACKTOP$

   7147  1 004204   400000 235100                    LDA     0,,PR4
         1 004205   000044 733000                    LRS     36
         1 004206   000022 736000                    QLS     18
         1 004207   000002 036003                    ADLQ    2,DU
         1 004210   200023 036100                    ADLQ    P$,,AUTO
         1 004211   000010 116100                    CMPQ    8,,PR0
         1 004212   004215 602000 1                  TNC     s:7151

     2707     7148    4                   THEN
     2708     7149    4                       CALL EXPAND_WORKAREA;

   7149  1 004213   004336 701000 1                  TSX1    EXPAND_WORKAREA
         1 004214   000000 011000                    NOP     0

     2709     7150    4               END;

     2710     7151    3           G$D.STACKTOP$->STACKARY$(0) = BLK$;

   7151  1 004215   200003 470500                    LDP0    @G$D,,AUTO
         1 004216   000010 471500                    LDP1    8,,PR0
         1 004217   200027 236100                    LDQ     BLK$,,AUTO
         1 004220   100000 756100                    STQ     0,,PR1

     2711     7152    3       END;

     2712     7153    2       I = 0;

   7153  1 004221   200017 450100                    STZ     I,,AUTO

     2713     7154    2       RETURN;

   7154  1 004222   200046 221300                    LDX1  ! PARSE$PARAM+9,,AUTO
         1 004223   000001 702211                    TSX2  ! 1,X1

     2714     7155
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:309  
     2715     7156    2   END SUCCEED_BLK;
     2716     7157        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:310  
     2717     7158        /*I*
     2718     7159            NAME: USER_EXIT
     2719     7160            PURPOSE: Call the user exit routine.
     2720     7161            CALL:
     2721     7162                CALL USER_EXIT (TYPE) ALTRET(user-routine-altreturned);
     2722     7163            PARAMETERS:
     2723     7164                TYPE -- type code for reason exit routine is being called
     2724     7165            DESCRIPTION:
     2725     7166                This routine prepares the user exit parameter block, calls
     2726     7167                the exit routine, and resets the command size and current
     2727     7168                position in case they were changed by the user routine.
     2728     7169        */
     2729     7170    1   USER_EXIT:

   7170  1 004224   200056 741300       USER_EXIT    STX1  ! P$+1,,AUTO

     2730     7171    1       PROC (TYPE) ALTRET;
     2731     7172
     2732     7173    2   DCL       TYPE     UBIN  WORD;
     2733     7174        /*D*
     2734     7175                If there is no exit routine provided when a call to it is
     2735     7176                required, abort the parse.
     2736     7177        */
     2737     7178    2       IF P$PCB.U$$ = ENTADDR(NIL)

   7178  1 004225   200011 470500                    LDP0    PCB$,,AUTO
         1 004226   000004 236100                    LDQ     4,,PR0
         1 004227   000002 116000 xsym               CMPQ    B_VECTNIL+2
         1 004230   004243 601000 1                  TNZ     s:7189

     2738     7179    3       THEN DO;

     2739     7180    3           P$PCB.ERROR = NULL_U$$;

   7180  1 004231   000000 236000 xsym               LDQ     NULL_U$$
         1 004232   000006 756100                    STQ     6,,PR0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:311  
     2740     7181    3           P$PCB.HINODE$ = ADDR(P$NODE);

   7181  1 004233   200010 236100                    LDQ     NODE$,,AUTO
         1 004234   000013 756100                    STQ     11,,PR0

     2741     7182    3           P$PCB.HI_CHAR = G$D.CCPOS;

   7182  1 004235   200003 471500                    LDP1    @G$D,,AUTO
         1 004236   100013 235100                    LDA     11,,PR1
         1 004237   000012 755100                    STA     10,,PR0

     2742     7183    3           UNWIND TO G$D.ERROR;

   7183  1 004240   100002 237300                    LDAQ  ! 2,,PR1
         1 004241   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 004242   000000 000200                    ZERO    0,128

     2743     7184    3       END;
     2744     7185        /*D*
     2745     7186                Set up parameter block for user routine.
     2746     7187        */
     2747     7188
     2748     7189    2       PARSE$PARAM = CPARAM;

   7189  1 004243   000100 100400                    MLR     fill='000'O
         1 004244   000001 000036 0                  ADSC9   CPARAM                   cn=0,n=30
         1 004245   200035 000036                    ADSC9   PARSE$PARAM,,AUTO        cn=0,n=30

     2749     7190    2       PARSE$PARAM.TYPE = TYPE;

   7190  1 004246   200057 471500                    LDP1    @TYPE,,AUTO
         1 004247   100000 236100                    LDQ     0,,PR1
         1 004250   000033 736000                    QLS     27
         1 004251   200035 552140                    STBQ    PARSE$PARAM,'40'O,AUTO

     2750     7191    2       PARSE$PARAM.CODE = P$NODE.CODE;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:312  
   7191  1 004252   200010 473500                    LDP3    NODE$,,AUTO
         1 004253   300000 720100                    LXL0    0,,PR3
         1 004254   177777 360003                    ANX0    65535,DU
         1 004255   200035 440100                    SXL0    PARSE$PARAM,,AUTO

     2751     7192    2       PARSE$PARAM.NODE$ = ADDR(P$NODE);

   7192  1 004256   200010 236100                    LDQ     NODE$,,AUTO
         1 004257   200036 756100                    STQ     PARSE$PARAM+1,,AUTO

     2752     7193    2       PARSE$PARAM.OUT$ = BLK$;

   7193  1 004260   200027 236100                    LDQ     BLK$,,AUTO
         1 004261   200037 756100                    STQ     PARSE$PARAM+2,,AUTO

     2753     7194    2       PARSE$PARAM.CHARPOS = G$D.CCPOS;

   7194  1 004262   200003 474500                    LDP4    @G$D,,AUTO
         1 004263   400013 235100                    LDA     11,,PR4
         1 004264   200041 755100                    STA     PARSE$PARAM+4,,AUTO

     2754     7195    2       PARSE$PARAM.GLOBAL$ = ADDR(G$D);

   7195  1 004265   200003 236100                    LDQ     @G$D,,AUTO
         1 004266   200040 756100                    STQ     PARSE$PARAM+3,,AUTO

     2755     7196    2       PARSE$PARAM.PCB$ = G$D.PCB$;

   7196  1 004267   400000 236100                    LDQ     0,,PR4
         1 004270   200042 756100                    STQ     PARSE$PARAM+5,,AUTO

     2756     7197    2       PARSE$PARAM.USER$ = PARSE$PARAM.PCB$->P$PCB.USER$;

   7197  1 004271   200042 475500                    LDP5    PARSE$PARAM+5,,AUTO
         1 004272   500014 236100                    LDQ     12,,PR5
         1 004273   200043 756100                    STQ     PARSE$PARAM+6,,AUTO

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:313  
     2757     7198    2       PARSE$PARAM.WKSZ = P$PCB.WKSZ;

   7198  1 004274   000005 222100                    LDX2    5,,PR0
         1 004275   200044 742100                    STX2    PARSE$PARAM+7,,AUTO

     2758     7199        /*D*
     2759     7200                Call the user routine.  Altreturns are only relevant on calls
     2760     7201                to enlarge the work area.
     2761     7202        */
     2762     7203    2       CALL P$PCB.U$$(PARSE$PARAM)

   7203  1 004276   200035 636500                    EPPR6   PARSE$PARAM,,AUTO
         1 004277   200066 456500                    STP6    TINDX+2,,AUTO
         1 004300   200066 630500                    EPPR0   TINDX+2,,AUTO
         1 004301   200011 477500                    LDP7    PCB$,,AUTO
         1 004302   700004 223100                    LDX3    4,,PR7
         1 004303   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 004304   000000 701013                    TSX1    0,X3
         1 004305   004307 702000 1                  TSX2    s:7205
         1 004306   004315 710000 1                  TRA     s:7212

     2763     7204    3       WHENALTRETURN DO;

     2764     7205    3           IF TYPE = %SPACE# THEN

   7205  1 004307   200057 470500                    LDP0    @TYPE,,AUTO
         1 004310   000000 235100                    LDA     0,,PR0
         1 004311   000005 115007                    CMPA    5,DL
         1 004312   004315 601000 1                  TNZ     s:7212

     2765     7206    3               ALTRETURN;

   7206  1 004313   200056 221300                    LDX1  ! P$+1,,AUTO
         1 004314   000000 702211                    TSX2  ! 0,X1

     2766     7207    3       END;
     2767     7208        /*D*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:314  
     2768     7209                Reset current position in the command text in case it was
     2769     7210                altered by the user routine.
     2770     7211        */
     2771     7212    2       G$D.CCPOS = PARSE$PARAM.CHARPOS;

   7212  1 004315   200041 235100                    LDA     PARSE$PARAM+4,,AUTO
         1 004316   200003 470500                    LDP0    @G$D,,AUTO
         1 004317   000013 755100                    STA     11,,PR0

     2772     7213    2       CALL SET_CHAR;

   7213  1 004320   003421 701000 1                  TSX1    SET_CHAR
         1 004321   000000 011000                    NOP     0

     2773     7214    2       RETURN;

   7214  1 004322   200056 221300                    LDX1  ! P$+1,,AUTO
         1 004323   000001 702211                    TSX2  ! 1,X1

     2774     7215    2   END USER_EXIT;
     2775     7216        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:315  
     2776     7217        /*I*
     2777     7218            NAME: XUP$EXPAND_WORKAREA
     2778     7219            PURPOSE: Expand the parse work area.
     2779     7220            CALL:
     2780     7221                CALL XUP$EXPAND_WORKAREA (G$D) ALTRET(not-used);
     2781     7222            PARAMETERS:
     2782     7223                G$D -- the parser global data block
     2783     7224            INTERFACE:
     2784     7225                EXPAND_WORKAREA
     2785     7226            DESCRIPTION:
     2786     7227                This external entry point simply sets up local variables needed
     2787     7228                by EXPAND_WORKAREA and calls that routine.  It is called when
     2788     7229                work area expansion is needed by an external routine.
     2789     7230        */
     2790     7231    1   XUP$EXPAND_WORKAREA: ENTRY (G$D) ALTRET;

   7231  1 004324   000000 700200 xent  XUP$EXPAND_* TSX0  ! X66_AUTO_1
         1 004325   000072 000001                    ZERO    58,1

     2791     7232
     2792     7233    1       PCB$ = G$D.PCB$;

   7233  1 004326   200003 470500                    LDP0    @G$D,,AUTO
         1 004327   000000 236100                    LDQ     0,,PR0
         1 004330   200011 756100                    STQ     PCB$,,AUTO

     2793     7234    1       NODE$ = G$D.NODE$;

   7234  1 004331   000004 236100                    LDQ     4,,PR0
         1 004332   200010 756100                    STQ     NODE$,,AUTO

     2794     7235
     2795     7236    1       CALL EXPAND_WORKAREA;

   7236  1 004333   004336 701000 1                  TSX1    EXPAND_WORKAREA
         1 004334   000000 011000                    NOP     0

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:316  
     2796     7237    1       RETURN;

   7237  1 004335   000000 702200 xent               TSX2  ! X66_ARET

     2797     7238
     2798     7239        %EJECT;
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:317  
     2799     7240        /*I*
     2800     7241            NAME: EXPAND_WORKAREA
     2801     7242            PURPOSE: Expand the parse work area.
     2802     7243            CALL:
     2803     7244                CALL EXPAND_WORKAREA;
     2804     7245            DESCRIPTION:
     2805     7246                This routine is called when more space is needed in the parse
     2806     7247                work area.
     2807     7248        */
     2808     7249    1   EXPAND_WORKAREA: PROC ALTRET;

   7249  1 004336   200050 741300       EXPAND_WORK* STX1  ! J+1,,AUTO

     2809     7250
     2810     7251    2   DCL BASE$ PTR;
     2811     7252    2   DCL I SBIN;
     2812     7253    2   DCL J SBIN;
     2813     7254    2   DCL K SBIN;
     2814     7255    2   DCL P$ PTR;
     2815     7256    2   DCL UBIN$WORD (0:0) UBIN BASED ALIGNED;
     2816     7257        /*D*
     2817     7258                If there is no user exit routine, or it doesn't permit dynamic
     2818     7259                expansion of the workarea, abort the parse.
     2819     7260        */
     2820     7261    2       IF P$PCB.U$$ = ENTADDR(NIL) OR NOT P$PCB.DYNMEM

   7261  1 004337   200011 470500                    LDP0    PCB$,,AUTO
         1 004340   000004 236100                    LDQ     4,,PR0
         1 004341   000002 116000 xsym               CMPQ    B_VECTNIL+2
         1 004342   004346 600000 1                  TZE     OVERFLOW
         1 004343   000005 236100                    LDQ     5,,PR0
         1 004344   020000 316007                    CANQ    8192,DL
         1 004345   004355 601000 1                  TNZ     s:7278

     2821     7262    3       THEN DO;

     2822     7263    3   OVERFLOW:
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:318  
     2823     7264    3           P$PCB.ERROR = OVER_FLOW;

   7264  1 004346   000000 236000 xsym  OVERFLOW     LDQ     OVER_FLOW
         1 004347   200011 470500                    LDP0    PCB$,,AUTO
         1 004350   000006 756100                    STQ     6,,PR0

     2824     7265    3           UNWIND TO G$D.ERROR;

   7265  1 004351   200003 471700                    LDP1  ! @G$D,,AUTO
         1 004352   100002 237300                    LDAQ  ! 2,,PR1
         1 004353   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 004354   000000 000200                    ZERO    0,128

     2825     7266    3       END;
     2826     7267
     2827     7268        /*E*    ERROR: XUP-E$WKOVERFLOW-C
     2828     7269                MESSAGE: X$PARSE needs more work area
     2829     7270                MESSAGE1:   The work area provided via the X$PARSE Control Block
     2830     7271                            is not large enough to complete the parse.
     2831     7272        */
     2832     7273
     2833     7274        /*D*
     2834     7275                Save current work area address, size, and stack size so they
     2835     7276                can be properly adjusted after the work area is expanded.
     2836     7277        */
     2837     7278    2       BASE$ = P$PCB.WORK$;

   7278  1 004355   000002 236100                    LDQ     2,,PR0
         1 004356   200051 756100                    STQ     BASE$,,AUTO

     2838     7279    2       J = P$PCB.WKSZ;

   7279  1 004357   000005 236100                    LDQ     5,,PR0
         1 004360   000022 772000                    QRL     18
         1 004361   200053 756100                    STQ     J,,AUTO

     2839     7280    2       K = J - POFFW (G$D.STACKTOP$, BASE$);
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:319  

   7280  1 004362   200051 235100                    LDA     BASE$,,AUTO
         1 004363   000022 771000                    ARL     18
         1 004364   200066 755100                    STA     TINDX+2,,AUTO
         1 004365   200003 471500                    LDP1    @G$D,,AUTO
         1 004366   100010 236100                    LDQ     8,,PR1
         1 004367   000022 772000                    QRL     18
         1 004370   200066 136100                    SBLQ    TINDX+2,,AUTO
         1 004371   200067 756100                    STQ     TINDX+3,,AUTO
         1 004372   200053 236100                    LDQ     J,,AUTO
         1 004373   200067 136100                    SBLQ    TINDX+3,,AUTO
         1 004374   200054 756100                    STQ     K,,AUTO

     2840     7281        /*D*
     2841     7282                Call the user exit routine to expand the work area.
     2842     7283                Abort the parse if the user routine altreturns.
     2843     7284        */
     2844     7285    2       CALL USER_EXIT (%SPACE#) ALTRET(OVERFLOW);

   7285  1 004375   000012 236000 2                  LDQ     10
         1 004376   200057 756100                    STQ     @TYPE,,AUTO
         1 004377   004224 701000 1                  TSX1    USER_EXIT
         1 004400   004346 702000 1                  TSX2    OVERFLOW

     2845     7286        /*D*
     2846     7287                Save the expanded work area size in the PCB.  If the routine
     2847     7288                didn't enlarge the work area, or it changed its base address,
     2848     7289                abort the parse.
     2849     7290        */
     2850     7291
     2851     7292    2       P$PCB.WKSZ = PARSE$PARAM.WKSZ;

   7292  1 004401   200044 220100                    LDX0    PARSE$PARAM+7,,AUTO
         1 004402   200011 470500                    LDP0    PCB$,,AUTO
         1 004403   000005 740100                    STX0    5,,PR0

     2852     7293
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:320  
     2853     7294    2       IF P$PCB.WKSZ <= J OR P$PCB.WORK$ ~= BASE$

   7294  1 004404   000005 236100                    LDQ     5,,PR0
         1 004405   000022 772000                    QRL     18
         1 004406   200053 116100                    CMPQ    J,,AUTO
         1 004407   004413 604400 1                  TMOZ    s:7297
         1 004410   000002 236100                    LDQ     2,,PR0
         1 004411   200051 116100                    CMPQ    BASE$,,AUTO
         1 004412   004421 600000 1                  TZE     s:7313

     2854     7295    3       THEN DO;

     2855     7296
     2856     7297    3           P$PCB.ERROR = ILLEGAL_DYNAMIC_EXPANSION;

   7297  1 004413   000000 236000 xsym               LDQ     ILLEGAL_DYNAMIC_EXPANSION
         1 004414   000006 756100                    STQ     6,,PR0

     2857     7298    3           UNWIND TO G$D.ERROR;

   7298  1 004415   200003 471700                    LDP1  ! @G$D,,AUTO
         1 004416   100002 237300                    LDAQ  ! 2,,PR1
         1 004417   000000 700200 xent               TSX0  ! X66_AUNWIND
         1 004420   000000 000200                    ZERO    0,128

     2858     7299
     2859     7300        /*E*  ERROR:   XUP-E$EXPAND_ERROR
     2860     7301              MESSAGE: Illegal expansion of parse work area.
     2861     7302              MESSAGE1: The user's U$$ routine RETURN'ed normally, indicating that the
     2862     7303                       work area in use by X$PARSE has been successfully expanded.
     2863     7304                       However, X$PARSE has determined that either (a) the size of the
     2864     7305                       work area has not been increased, or (b) the base of the work
     2865     7306                       area has been changed.  In either case, X$PARSE cannot proceed.
     2866     7307        */
     2867     7308
     2868     7309    3       END;
     2869     7310        /*D*
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:321  
     2870     7311                Move the parse stack up to the end of the enlarged work area.
     2871     7312        */
     2872     7313    2       J = P$PCB.WKSZ - J;

   7313  1 004421   000005 236100                    LDQ     5,,PR0
         1 004422   000022 772000                    QRL     18
         1 004423   200053 136100                    SBLQ    J,,AUTO
         1 004424   200053 756100                    STQ     J,,AUTO

     2873     7314    2       P$ = PINCRW (G$D.STACKTOP$, J);

   7314  1 004425   200003 471500                    LDP1    @G$D,,AUTO
         1 004426   100010 473500                    LDP3    8,,PR1
         1 004427   300000 634506                    EPPR4   0,QL,PR3
         1 004430   200055 454500                    STP4    P$,,AUTO

     2874     7315
     2875     7316    3       DO I = K - 1 DOWNTO 0 BY -1;

   7316  1 004431   200054 235100                    LDA     K,,AUTO
         1 004432   000001 135007                    SBLA    1,DL
         1 004433   200052 755100                    STA     I,,AUTO
         1 004434   004445 710000 1                  TRA     s:7320+2

     2876     7317
     2877     7318    3           P$ -> UBIN$WORD (I) = G$D.STACKTOP$ -> UBIN$WORD (I);

   7318  1 004435   200003 470500                    LDP0    @G$D,,AUTO
         1 004436   000010 471500                    LDP1    8,,PR0
         1 004437   200052 720100                    LXL0    I,,AUTO
         1 004440   200055 473500                    LDP3    P$,,AUTO
         1 004441   100000 235110                    LDA     0,X0,PR1
         1 004442   300000 755110                    STA     0,X0,PR3

     2878     7319
     2879     7320    3       END;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:322  
   7320  1 004443   000001 336007                    LCQ     1,DL
         1 004444   200052 056100                    ASQ     I,,AUTO
         1 004445   200052 235100                    LDA     I,,AUTO
         1 004446   004435 605000 1                  TPL     s:7318

     2880     7321
     2881     7322    2       G$D.STACKTOP$ = P$;

   7322  1 004447   200055 236100                    LDQ     P$,,AUTO
         1 004450   200003 470500                    LDP0    @G$D,,AUTO
         1 004451   000010 756100                    STQ     8,,PR0

     2882     7323
     2883     7324    2       RETURN;

   7324  1 004452   200050 221300                    LDX1  ! J+1,,AUTO
         1 004453   000001 702211                    TSX2  ! 1,X1
     2884     7325
     2885     7326    2   END EXPAND_WORKAREA;
     2886     7327
     2887     7328    1   END       XUP$PARS;
     2888     7329        %EOD;

PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:323  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
   XU_DATA_R.:E05TOU  cannot be made into a system file and is referenced.
   B$TABLES_C.:E05TOU  cannot be made into a system file and is referenced.
   B_SEGIDS_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$PARS.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:324  

 **** Variables and constants ****

  ****  Section 000 RoData XUP$PARS

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 B$IS$                      1-0-0/w STRC(270)   r     1 CPARAM
     0-0-0/b STRC        r     1 ISSID_PTR

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @G$D                      63-0-0/w PTR         r     1 @INDX
    51-0-0/w PTR         r     1 @NSUBLKS                  57-0-0/w PTR         r     1 @TYPE
    51-0-0/w PTR         r     1 BASE$                     27-0-0/w PTR         r     1 BLK$
    22-0-0/w SBIN        r     1 COUNT                     12-0-0/c CHAR        r     1 CURCHAR
    34-0-0/c CHAR        r     1 DLIM                      *0-0-0/d STRC(5175)  r     1 G$D
    17-0-0/w SBIN        r     1 I                         52-0-0/w SBIN        r     1 I
    52-0-0/w SBIN        r     1 I                         *0-0-0/w UBIN        r     1 INDX
    20-0-0/w SBIN        r     1 J                         47-0-0/w SBIN        r     1 J
    53-0-0/w SBIN        r     1 J                         20-0-0/w BIT         r     1 JFLAG
    21-0-0/w SBIN        r     1 K                         54-0-0/w SBIN        r     1 K
    33-0-0/w SBIN        r     1 LISTCNT                   16-0-0/w UBIN        r     1 LIST_STK
    15-0-0/w UBIN        r     1 MY_STACK                  13-0-0/w SBIN        r     1 NCHARS
    10-0-0/w PTR         r     1 NODE$                     25-0-0/w SBIN        r     1 NSUBLKS
    *0-0-0/w UBIN        r     1 NSUBLKS                   23-0-0/w PTR         r     1 P$
    55-0-0/w PTR         r     1 P$                        35-0-0/w STRC(270)   r     1 PARSE$PARAM
    11-0-0/w PTR         r     1 PCB$                      24-0-0/w PTR         r     1 Q$
    32-0-0/w PTR         r     1 RDUCE$                    30-0-0/b BIT         r     1 REPEAT
    31-0-0/b BIT         r     1 REPEATABLE                14-0-0/w UBIN        r     1 RP_STACK
     6-0-0/w SBIN        r     1 SAVELEX                    5-0-0/w SBIN        r     1 SAVEPOS
     7-0-0/b BIT         r     1 SKIPBL                     4-0-0/w SBIN        r     1 SSAVEPOS
    64-0-0/w UBIN        r     1 TINDX                     *0-0-0/w UBIN        r     1 TYPE
    26-0-0/w UBIN        r     1 VALIDSYM
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:325  

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 B$XL_UPPER$                0-0-0/b BIT         r     1 BAD_NODE
     0-0-0/b BIT         r     1 CANT_RTEXT
     0-0-0/b BIT         r     1 ILLEGAL_DYNAMIC_EXPANSION
     0-0-0/b BIT         r     1 NULL_U$$                   0-0-0/b BIT         r     1 OVER_FLOW
     0-0-0/b BIT         r     1 RTEXT_GT_511               0-0-0/b STRC        r     1 SYMTTBL(0:127)
     0-0-0/b BIT         r     1 XUP_SYMTBL(0:127)

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w BIT         r     1 BIT36                      0-0-0/c ACHR        r     1 C$BUF
     0-0-0/c CHAR        r     1 C$BUFA(0:0)                0-0-0/w STRC(144)   r     1 OUT$BLK
     0-0-0/w ASTR(153)   r     1 OUT$SYM                    0-0-0/w STRC(54)    r     1 P$DSTR
     0-0-0/w ASTR(45)    r     1 P$LIT                      0-0-0/w STRC(72)    r     1 P$NODE
     0-0-0/w STRC(504)   r     1 P$PCB                      0-0-0/w ASTR(54)    r     1 P$SYM
     0-0-0/w ASTR(54)    r     1 P$SYM                      0-0-0/w STRC(72)    r     1 POSS
     0-0-0/w STRC(54)    r     1 PX$DSTR                    0-0-0/w STRC(63)    r     1 PX$LIT
     0-0-0/w STRC(72)    r     1 PX$NODE                    0-0-0/w STRC(72)    r     1 PX$SYM
     0-0-0/w STRC(73)    r     1 R$BLK
     0-0-0/w PTR         r     1 STACKARY$(0:0)
     0-0-0/d STRC(4608)  r     1 TRANSTBL
     0-0-0/w UBIN        r     1 UBIN$WORD(0:0)


   Procedure XUP$PARS requires 2348 words for executable code.
   Procedure XUP$PARS requires 58 words of local(AUTO) storage.
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:326  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:327  
          MINI XREF LISTING

ADVCHAR
      6802**PROC     6536--CALL
B$IS$
      4345**DCL      5092>>IF
B$XL_UPPER$
      4266**DCL      4267--IMP-PTR  5248>>IF       5509>>CALLBLT  5744>>CALLBLT  5820>>CALLBLT
BADNODE
      5895**LABEL    5094--GOTO     5790--GOTO
BAD_NODE
      4278**DCL      5895>>ASSIGN
BASE$ IN PROCEDURE EXPAND_WORKAREA
      7251**DCL      7278<<ASSIGN   7280>>ASSIGN   7294>>IF
BIT36
      4309**DCL      5230>>IF
BLANKSUCC
      6298**LABEL    5782--GOTO
BLK$
      4320**DCL      4355--IMP-PTR  4401--IMP-PTR  5138<<ASSIGN   5505<<ASSIGN   5506>>ASSIGN   5509>>CALLBLT
      5509>>CALLBLT  5512>>ASSIGN   5512>>ASSIGN   5514>>ASSIGN   5515>>ASSIGN   5728<<ASSIGN   5729>>ASSIGN
      5730>>ASSIGN   5731>>ASSIGN   5732>>ASSIGN   5732>>ASSIGN   5738<<ASSIGN   5739>>ASSIGN   5740>>ASSIGN
      5741>>ASSIGN   5744>>CALLBLT  5744>>CALLBLT  5747>>ASSIGN   5747>>ASSIGN   5864<<ASSIGN   5865>>ASSIGN
      5866>>ASSIGN   5867>>ASSIGN   5868>>ASSIGN   5868>>ASSIGN   5947<<ASSIGN   5986<<ASSIGN   5987>>ASSIGN
      5988>>ASSIGN   5988>>ASSIGN   5990>>ASSIGN   5991>>ASSIGN   5992>>ASSIGN   5993>>ASSIGN   5994>>ASSIGN
      6005<<ASSIGN   6010>>ASSIGN   6013>>ASSIGN   6026>>ASSIGN   6028>>ASSIGN   6032>>ASSIGN   6056<<ASSIGN
      6238<<ASSIGN   6309>>IF       6313<<ASSIGN   6314>>ASSIGN   6315>>ASSIGN   6320>>IF       6322>>ASSIGN
      6357<<ASSIGN   7039>>ASSIGN   7041>>ASSIGN   7045>>ASSIGN   7047>>ASSIGN   7049>>ASSIGN   7051>>ASSIGN
      7053>>ASSIGN   7056>>ASSIGN   7057>>ASSIGN   7058>>ASSIGN   7059>>ASSIGN   7060>>ASSIGN   7061>>ASSIGN
      7062>>ASSIGN   7063>>ASSIGN   7064>>ASSIGN   7065>>ASSIGN   7066>>ASSIGN   7067>>ASSIGN   7068>>ASSIGN
      7069>>ASSIGN   7070>>ASSIGN   7124<<ASSIGN   7139>>IF       7151>>ASSIGN   7193>>ASSIGN
C$BUF
      4329**DCL      5509>>CALLBLT  5512>>ASSIGN   5545>>CALLBLT  5673>>CALLBLT  5689>>ASSIGN   5701>>ASSIGN
      5732>>ASSIGN   5820>>CALLBLT  5823>>ASSIGN   5868>>ASSIGN   5988>>ASSIGN   6971>>CALLBLT  6982>>CALLBLT
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:328  
      7014>>IF
C$BUFA
      4331**DCL      5455>>ASSIGN   5472>>ASSIGN   5611>>ASSIGN   5684>>IF       6281>>ASSIGN   6483>>DOWHILE
      6510<<ASSIGN   6811>>ASSIGN   6888>>ASSIGN   6939>>IF       6996>>ASSIGN
CANT_RETURN_TEXT
      6374**LABEL    5966--GOTO
CANT_RTEXT
      4281**DCL      6374>>ASSIGN
CHKCHAR
      6572**PROC     5270--CALL     5276--CALL     5440--CALL     5456--CALL     5603--CALL     5612--CALL
CHK_BLK IN PROCEDURE CHK_CONTUE
      6529**LABEL    6498--GOTO
CHK_COMMENT
      6912**PROC     6460--CALL     6496--CALL     6809--CALL
CHK_CONTUE
      6452**PROC     5779--CALL     6299--CALL     6890--CALL
CONTUE_GO IN PROCEDURE CHK_CONTUE
      6508**LABEL    6486--GOTO     6496--CALLALT
COUNT
      4311**DCL      5313<<ASSIGN   5314<>CALL     5503<<ASSIGN   5504<>CALL     5608<<ASSIGN   5610>>DOWHILE
      5611>>ASSIGN   5614<<ASSIGN   5614>>ASSIGN   5726<<ASSIGN   5727<>CALL     5736<<ASSIGN   5737<>CALL
      5862<<ASSIGN   5863<>CALL     5984<<ASSIGN   5985<>CALL     6311<<ASSIGN   6312<>CALL     6495<<ASSIGN
      6497>>IF
CPARAM
      4453**DCL      7189>>ASSIGN
CURCHAR
      4297**DCL      5160<<ASSIGN   5248>>IF       5248>>IF       5255>>IF       5255>>IF       5274>>IF
      5449>>DOWHILE  5455<<ASSIGN   5472<<ASSIGN   5473>>IF       5564>>IF       5611<<ASSIGN   5640>>IF
      5640>>IF       5643>>ASSIGN   6657>>IF       6664>>IF       6668>>IF       6672>>IF       6676>>IF
      6678>>IF       6684>>IF       6686>>IF       6692>>IF       6694>>IF       6701>>IF       6705>>IF
      6710>>IF       6715>>IF       6728>>CALLBLT  6811<<ASSIGN   6812>>ASSIGN   6866<<ASSIGN
DLIM
      4326**DCL      5566<<ASSIGN   5643<<ASSIGN   5673>>CALLBLT  5684>>IF
DLIM_LOOP
      5667**LABEL    5692--GOTO
DSTRING
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:329  
      5649**LABEL    5567--GOTO
ENDSUC
      6064**LABEL    6219--GOTO
END_OF_TEXT IN PROCEDURE CHK_COMMENT
      7003**LABEL    6951--GOTO     6963--GOTO     6971--CALLALT  6982--CALLALT
EXPAND_WORKAREA
      7249**PROC     6189--CALL     7143--CALL     7149--CALL     7236--CALL
FAIL IN PROCEDURE PARS_SUBND
      6769**LABEL    6778--CALLALT
FID_BLOCK
      5489**LABEL    5454--GOTO     5456--CALLALT  5553--GOTO     5627--GOTO
FID_LOOP
      5451**LABEL    5476--GOTO
FIND_TRCMNT IN PROCEDURE CHK_COMMENT
      6945**LABEL    7018--GOTO
FREESTACK
      7090**PROC     5399--CALL     5970--CALL     6098--CALL     7133--CALL
G$D
      4175**DCL         6--PROC     5114--ASSIGN   5314<>CALL     5504<>CALL     5727<>CALL     5737<>CALL
      5863<>CALL     5985<>CALL     6004<>CALL     6064--IF       6252--IF       6312<>CALL     6423<>CALL
      6778<>CALL     6884--ENTRY    7096<>CALL     7195--ASSIGN   7231--ENTRY
G$D.BLSKIP
      4234**DCL      5156>>ASSIGN   5377>>ASSIGN   5780>>IF       6287<<ASSIGN   6520<<ASSIGN   6535<<ASSIGN
      6835<<ASSIGN   7004<<ASSIGN   7024<<ASSIGN
G$D.CCHAR
      4231**DCL      5160>>ASSIGN   6281<<ASSIGN   6282<<ASSIGN   6465>>IF       6529>>IF       6534>>DOWHILE
      6812<<ASSIGN   6865<<ASSIGN   6888<<ASSIGN   6996<<ASSIGN   7005<<ASSIGN
G$D.CCPOS
      4223**DCL      5122>>ASSIGN   5154>>ASSIGN   5186>>IF       5206>>IF       5375>>ASSIGN   5376>>ASSIGN
      5431>>IF       5443>>ASSIGN   5509>>CALLBLT  5512>>ASSIGN   5522<<ASSIGN   5522>>ASSIGN   5545>>CALLBLT
      5552>>ASSIGN   5595>>IF       5608>>ASSIGN   5649>>IF       5653>>ASSIGN   5722>>ASSIGN   5732>>ASSIGN
      5753<<ASSIGN   5766>>IF       5808>>IF       5808>>IF       5820>>CALLBLT  5823>>ASSIGN   5833>>IF
      5868>>ASSIGN   5874<<ASSIGN   5874>>ASSIGN   5897>>ASSIGN   6054>>IF       6104>>IF       6280>>IF
      6281>>ASSIGN   6287>>IF       6293>>ASSIGN   6341>>IF       6343>>ASSIGN   6355>>IF       6375>>ASSIGN
      6389>>ASSIGN   6460<>CALL     6476>>ASSIGN   6508>>ASSIGN   6510>>ASSIGN   6519>>ASSIGN   6521>>ASSIGN
      6769>>IF       6806>>IF       6808<<ASSIGN   6808>>ASSIGN   6809<>CALL     6811>>ASSIGN   6833<<ASSIGN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:330  
      6860>>IF       6861>>IF       6864<<ASSIGN   6994>>IF       6995>>IF       6996>>ASSIGN   7182>>ASSIGN
      7194>>ASSIGN   7212<<ASSIGN
G$D.CLEXPOS
      4226**DCL      5155>>ASSIGN   5964>>IF       5975>>ASSIGN   6293<<ASSIGN   6834<<ASSIGN
G$D.CNTUPOS
      4215**DCL      5122>>ASSIGN   5154>>ASSIGN   5155>>ASSIGN   5375>>ASSIGN   5376>>ASSIGN   5781>>ASSIGN
      5964>>IF       5975>>ASSIGN   5988>>ASSIGN   6032>>ASSIGN   6054>>IF       6275>>ASSIGN   6522<<ASSIGN
      6522>>ASSIGN   6769>>IF       6833>>ASSIGN   6834>>ASSIGN
G$D.ERROR
      4179**DCL      5898>>UNWIND   6376>>UNWIND   6390>>UNWIND   7183>>UNWIND   7265>>UNWIND   7298>>UNWIND
G$D.HISPACE$
      4201**DCL      7142>>IF
G$D.LDCMNT.CT
      4244**DCL      6922>>IF       6928>>DOCASE
G$D.LDCMNT.TX
      4245**DCL      4246--REDEF    7014>>IF
G$D.LDCMNT.TXA
      4246**DCL      6939>>IF
G$D.NODE$
      4186**DCL      5091>>ASSIGN   6761<<ASSIGN   6769>>IF       7234>>ASSIGN
G$D.PCB$
      4176**DCL      5080>>ASSIGN   5895>>ASSIGN   6885>>ASSIGN   7196>>ASSIGN   7233>>ASSIGN
G$D.REDUCE$
      4208**DCL      5111>>ASSIGN   5112<<ASSIGN   5296--ASSIGN   6418>>ASSIGN   6419<<ASSIGN
G$D.SCRATCH
      4212**DCL      4215--REDEF
G$D.STACKTOP$
      4204**DCL      5120>>ASSIGN   5146>>ASSIGN   5374>>ASSIGN   5398>>ASSIGN   5931>>ASSIGN   5944>>IF
      5947>>ASSIGN   5948<<ASSIGN   5948>>ASSIGN   6013>>ASSIGN   6015<<ASSIGN   6015>>ASSIGN   6097>>ASSIGN
      6187>>IF       7096>>CALL     7098<<ASSIGN   7098>>ASSIGN   7132>>ASSIGN   7141<<ASSIGN   7141>>ASSIGN
      7142>>IF       7147>>IF       7151>>ASSIGN   7280>>ASSIGN   7314>>ASSIGN   7318>>ASSIGN   7322<<ASSIGN
G$D.TBUF
      4255**DCL      5686--IF       5689<<ASSIGN   5698--IF       5701<<ASSIGN   5744>>CALLBLT  5747>>ASSIGN
      5820<<CALLBLT  5823<<ASSIGN   5840>>IF       5848>>IF
G$D.TRCMNT.CT
      4252**DCL      6950>>IF       6957>>DOCASE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:331  
G$D.TRCMNT.TX
      4253**DCL      4254--REDEF    6982>>CALLBLT
G$D.TRCMNT.TXA
      4254**DCL      6971>>CALLBLT
I
      4306**DCL      5204<<ASSIGN   5211>>DOWHILE  5227>>ASSIGN   5305>>IF       5319>>ASSIGN   5336<<ASSIGN
      5336>>ASSIGN   5348<<ASSIGN   5349>>DOWHILE  5351<<ASSIGN   5351>>ASSIGN   5367<<ASSIGN   5380<<ASSIGN
      5398<<ASSIGN   5399<>CALL     5442<<ASSIGN   5451<<ASSIGN   5451>>ASSIGN   5468<<ASSIGN   5468>>ASSIGN
      5491>>IF       5503>>ASSIGN   5506>>ASSIGN   5509>>CALLBLT  5512>>ASSIGN   5522>>ASSIGN   5541<<ASSIGN
      5545<<CALLBLT  5545>>CALLBLT  5552<<ASSIGN   5552>>ASSIGN   5609<<ASSIGN   5613<<ASSIGN   5613>>ASSIGN
      5652<<ASSIGN   5686>>IF       5689>>ASSIGN   5690<<ASSIGN   5690>>ASSIGN   5698>>IF       5701>>ASSIGN
      5702<<ASSIGN   5702>>ASSIGN   5718>>IF       5722<<ASSIGN   5723>>IF       5726>>ASSIGN   5729>>ASSIGN
      5732>>ASSIGN   5736>>ASSIGN   5739>>ASSIGN   5744>>CALLBLT  5747>>ASSIGN   5826<<ASSIGN   5828<<ASSIGN
      5833>>IF       5840>>IF       5840>>IF       5847>>DOWHILE  5848>>IF       5848>>IF       5851<<ASSIGN
      5851>>ASSIGN   5862>>ASSIGN   5867>>ASSIGN   5868>>ASSIGN   5874>>ASSIGN   5975<<ASSIGN   5976>>IF
      5984>>ASSIGN   5987>>ASSIGN   5988>>ASSIGN   6040>>DOCASE   6097<<ASSIGN   6098<>CALL     6112<<ASSIGN
      6113>>DOWHILE  6114>>ASSIGN   6181<<ASSIGN   6181>>ASSIGN   6331>>DOCASE   6761>>ASSIGN   7127<<ASSIGN
      7132<<ASSIGN   7133<>CALL     7134<<ASSIGN   7153<<ASSIGN
I IN PROCEDURE EXPAND_WORKAREA
      7252**DCL      7316<<DOINDEX  7318>>ASSIGN   7318>>ASSIGN
I IN PROCEDURE FREESTACK
      7093**DCL      7095<<DOINDEX  7096>>CALL
ILLEGAL_DYNAMIC_EXPANSION
      4283**DCL      7297>>ASSIGN
INDX IN PROCEDURE CHK_COMMENT
      6913**DCL      6912--PROC     6922>>IF       6939>>IF       6945<<ASSIGN   6945>>ASSIGN   6950>>IF
      6971>>CALLBLT  6975<<ASSIGN   6982>>CALLBLT  6986<<ASSIGN   6994>>IF       7003<<ASSIGN   7014>>IF
      7017<<ASSIGN   7017>>ASSIGN
ISSID_PTR
      4342**DCL      4345--REDEF
J
      4307**DCL      4308--REDEF    5443<<ASSIGN   5452<<ASSIGN   5452>>ASSIGN   5453>>IF       5455>>ASSIGN
      5469<<ASSIGN   5469>>ASSIGN   5470>>IF       5472>>ASSIGN   5542<<ASSIGN   5544>>DOWHILE  5545>>CALLBLT
      5549<<ASSIGN   5549>>ASSIGN   5653<<ASSIGN   5667>>IF       5673>>CALLBLT  5686>>IF       5689>>ASSIGN
      5689>>ASSIGN   5690>>ASSIGN   5691<<ASSIGN   5698>>IF       5701>>ASSIGN   5701>>ASSIGN   5702>>ASSIGN
      5817<<ASSIGN   5820>>CALLBLT  5823>>ASSIGN   5826>>ASSIGN   5847>>DOWHILE  6476<<ASSIGN   6482>>DOWHILE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:332  
      6483>>DOWHILE  6484<<ASSIGN   6484>>ASSIGN   6485>>IF       6495>>ASSIGN   6496<>CALL     6497>>IF
      6508<<ASSIGN   6521<<ASSIGN   6521>>ASSIGN   6522>>ASSIGN
J IN PROCEDURE CHKCHAR
      6652**DCL      6728<<CALLBLT
J IN PROCEDURE EXPAND_WORKAREA
      7253**DCL      7279<<ASSIGN   7280>>ASSIGN   7294>>IF       7313<<ASSIGN   7313>>ASSIGN   7314>>ASSIGN
JFLAG
      4308**DCL      5208<<ASSIGN   5210<<ASSIGN   5230>>IF
K
      4310**DCL      5673<<CALLBLT  5682>>IF       5684>>IF       5686>>IF       5689>>ASSIGN   5690>>ASSIGN
      5691>>ASSIGN   5698>>IF       5701>>ASSIGN   5702>>ASSIGN   5722>>ASSIGN   5753>>ASSIGN
K IN PROCEDURE EXPAND_WORKAREA
      7254**DCL      7280<<ASSIGN   7316>>DOINDEX
LEXSUCC2
      6330**LABEL    5995--GOTO     6239--GOTO
LEXSUCCEED
      6275**LABEL    5526--GOTO     5754--GOTO     5875--GOTO
LISTCNT
      4325**DCL      5205<<ASSIGN   5211>>DOWHILE  5365<<ASSIGN   5379<<ASSIGN   5379>>ASSIGN   5389>>IF
LISTEND
      5389**LABEL    5368--CALLALT  5381--CALLALT
LIST_STK
      4303**DCL      5364<<ASSIGN   5374<<ASSIGN   5398>>ASSIGN
LOOP
      5230**LABEL    5241--GOTO     5245--GOTO
MAKEBLK
      5621**LABEL    5612--CALLALT
MISS
      5336**LABEL    5250--GOTO     5258--GOTO     5270--CALLALT  5276--CALLALT  5279--GOTO     5306--GOTO
      5307--CALLALT  5325--CALLALT
MY_STACK
      4302**DCL      5146<<ASSIGN   5364>>ASSIGN   5931>>ASSIGN   6097>>ASSIGN   6210<<ASSIGN   7132>>ASSIGN
NCHARS
      4298**DCL      4329--IMP-SIZ  5081<<ASSIGN   5453>>IF       5470>>IF       5509>>CALLBLT  5512>>ASSIGN
      5541>>ASSIGN   5545>>CALLBLT  5610>>DOWHILE  5667>>IF       5673>>CALLBLT  5682>>IF       5689>>ASSIGN
      5701>>ASSIGN   5732>>ASSIGN   5766>>IF       5808>>IF       5820>>CALLBLT  5823>>ASSIGN   5833>>IF
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:333  
      5868>>ASSIGN   5988>>ASSIGN   6280>>IF       6482>>DOWHILE  6485>>IF       6806>>IF       6859<<ASSIGN
      6861>>IF       6864>>ASSIGN   6886<<ASSIGN   6887>>IF       6922>>IF       6950>>IF       6971>>CALLBLT
      6982>>CALLBLT  6995>>IF       7003>>ASSIGN   7014>>IF
NODE$
      4295**DCL      3911--IMP-PTR  3997--IMP-PTR  4050--IMP-PTR  4126--IMP-PTR  5091<<ASSIGN   5092>>IF
      5092>>IF       5109>>IF       5109>>IF       5121>>ASSIGN   5173>>IF       5191>>DOCASE   5205>>ASSIGN
      5227>>ASSIGN   5286>>IF       5297>>DOWHILE  5305>>IF       5312>>IF       5313>>ASSIGN   5316>>ASSIGN
      5349>>DOWHILE  5413>>DOCASE   5439>>ASSIGN   5489>>IF       5491>>IF       5491>>IF       5502>>IF
      5507>>IF       5543>>IF       5544>>DOWHILE  5545>>CALLBLT  5545>>CALLBLT  5602>>ASSIGN   5621>>IF
      5621>>IF       5640>>IF       5640>>IF       5715>>IF       5715>>IF       5717>>IF       5718>>IF
      5720>>IF       5742>>IF       5817>>ASSIGN   5818>>IF       5824>>IF       5828>>ASSIGN   5840>>IF
      5840>>IF       5848>>IF       5848>>IF       5860>>IF       5860>>IF       5896>>ASSIGN   5918>>IF
      5937>>IF       5956>>IF       5992>>ASSIGN   6025>>IF       6104>>IF       6104>>IF       6118>>IF
      6125>>IF       6127>>DOCASE   6133>>IF       6133>>IF       6133>>IF       6133>>IF       6142>>IF
      6144>>DOCASE   6155>>IF       6155>>IF       6164>>IF       6168>>IF       6168>>IF       6168>>IF
      6168>>IF       6193>>ASSIGN   6218>>IF       6223>>IF       6298>>IF       6309>>IF       6344>>ASSIGN
      6761>>ASSIGN   6769>>IF       6889<<ASSIGN   7039>>ASSIGN   7040>>IF       7043>>DOCASE   7055>>DOCASE
      7121>>IF       7181>>ASSIGN   7191>>ASSIGN   7192>>ASSIGN   7234<<ASSIGN
NOMORETXT IN PROCEDURE ADVCHAR
      6864**LABEL    6809--CALLALT  6815--GOTO
NONXT
      6193**LABEL    5177--GOTO
NOTSYM IN PROCEDURE CHKCHAR
      6726**LABEL    6728--CALLALT
NSUBLKS
      4316**DCL      5931<<ASSIGN   5937>>IF       5944>>IF       5970<>CALL     6004>>CALL     6010>>ASSIGN
      6011>>DOWHILE  6012<<ASSIGN   6012>>ASSIGN   6013>>ASSIGN
NSUBLKS IN PROCEDURE FREESTACK
      7092**DCL      7090--PROC     7095>>DOINDEX  7098>>ASSIGN
NULL_U$$
      4279**DCL      7180>>ASSIGN
OUT$BLK.CODE
      4363**DCL      7039<<ASSIGN
OUT$BLK.CPOS
      4381**DCL      6032<<ASSIGN   6315<<ASSIGN   6322<<ASSIGN
OUT$BLK.NDTYPE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:334  
      4358**DCL      7041<<ASSIGN   7045<<ASSIGN   7047<<ASSIGN   7049<<ASSIGN   7051<<ASSIGN   7053<<ASSIGN
      7056<<ASSIGN   7057<<ASSIGN   7058<<ASSIGN   7059<<ASSIGN   7060<<ASSIGN   7061<<ASSIGN   7062<<ASSIGN
      7063<<ASSIGN   7064<<ASSIGN   7065<<ASSIGN   7066<<ASSIGN   7067<<ASSIGN   7068<<ASSIGN   7069<<ASSIGN
      7070<<ASSIGN
OUT$BLK.NSUBLKS
      4367**DCL      6010<<ASSIGN   6314<<ASSIGN
OUT$BLK.SUBLK$
      4388**DCL      6013<<ASSIGN
OUT$BLK.TEMP
      4356**DCL      5944>>IF       6026<<ASSIGN   6028<<ASSIGN
OUT$SYM.CODE
      4407**DCL      5992<<ASSIGN
OUT$SYM.COUNT
      4424**DCL      4427--IMP-SIZ  5506<<ASSIGN   5509>>CALLBLT  5512>>ASSIGN   5514--ASSIGN   5729<<ASSIGN
      5730--ASSIGN   5732>>ASSIGN   5739<<ASSIGN   5740--ASSIGN   5744>>CALLBLT  5747>>ASSIGN   5866--ASSIGN
      5867<<ASSIGN   5868>>ASSIGN   5987<<ASSIGN   5988>>ASSIGN   5990--ASSIGN
OUT$SYM.CPOS
      4416**DCL      5993<<ASSIGN
OUT$SYM.NDTYPE
      4404**DCL      5994<<ASSIGN
OUT$SYM.NSUBLKS
      4410**DCL      5515<<ASSIGN   5731<<ASSIGN   5741<<ASSIGN   5865<<ASSIGN   5991<<ASSIGN
OUT$SYM.TEXT
      4427**DCL      5509<<CALLBLT  5512<<ASSIGN   5732<<ASSIGN   5744<<CALLBLT  5747<<ASSIGN   5868<<ASSIGN
      5988<<ASSIGN
OUT$SYM.TEXTC$
      4419**DCL      5514<<ASSIGN   5730<<ASSIGN   5740<<ASSIGN   5866<<ASSIGN   5990<<ASSIGN
OUTBLK_COMMON
      7037**PROC     6033--CALL     6323--CALL
OVERFLOW IN PROCEDURE EXPAND_WORKAREA
      7264**LABEL    7285--CALLALT
OVER_FLOW
      4280**DCL      7264>>ASSIGN
P$
      4312**DCL      4337--IMP-PTR  5067--IMP-PTR  5227<<ASSIGN   5230>>IF       5237>>DOCASE   5240<<ASSIGN
      5240>>ASSIGN   5244<<ASSIGN   5244>>ASSIGN   5248>>IF       5248>>IF       5253>>DOCASE   5255>>IF
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:335  
      5255>>IF       5296<<ASSIGN   5297>>DOWHILE  5297>>DOWHILE  5299<<ASSIGN   5299>>ASSIGN   5305>>IF
      5305>>IF       5312>>IF       5314>>CALL     5315<<ASSIGN   5315>>ASSIGN   5316>>ASSIGN   5317>>ASSIGN
      5319>>ASSIGN   5439<<ASSIGN   5602<<ASSIGN   6111<<ASSIGN   6112>>ASSIGN   6114>>ASSIGN   6187>>IF
      6187>>IF       6193>>ASSIGN   6193>>ASSIGN   6194>>ASSIGN   6194>>ASSIGN   6418<<ASSIGN   6420>>DOWHILE
      6421>>ASSIGN   6422<<ASSIGN   6422>>ASSIGN   6509<<ASSIGN   6521>>ASSIGN   6583--IMP-PTR  6658>>DOCASE
      6726>>IF       6728>>CALLBLT  6728>>CALLBLT  7146<<ASSIGN   7147>>IF       7147>>IF
P$ IN PROCEDURE EXPAND_WORKAREA
      7255**DCL      7314<<ASSIGN   7318>>ASSIGN   7322>>ASSIGN
P$DSTR.DLIM
      4150**DCL      5640>>IF       5640>>IF       6155>>IF       6155>>IF
P$DSTR.LEXTYPE
      4144**DCL      5715>>IF
P$DSTR.MAKEUC
      4142**DCL      5742>>IF
P$DSTR.MAXL
      4149**DCL      5717>>IF       5718>>IF       6155>>IF       6155>>IF
P$DSTR.RTEXT
      4141**DCL      5720>>IF
P$LIT.ABREV
      4021**DCL      5824>>IF       5828>>ASSIGN   6133>>IF       6133>>IF
P$LIT.COUNT
      4028**DCL      4031--IMP-SIZ  5817>>ASSIGN   5840>>IF       5848>>IF       6133>>IF       6133>>IF
      6133>>IF       6133>>IF
P$LIT.O_F
      4008**DCL      5860>>IF
P$LIT.RTEXT
      4012**DCL      5860>>IF
P$LIT.TEXT
      4031**DCL      5840>>IF       5848>>IF       6133>>IF       6133>>IF
P$LIT.UPRLOWR
      4013**DCL      5818>>IF
P$NODE
      3911**DCL      5297--DOWHILE  5305--IF       5312--IF       5316--ASSIGN   5896--ASSIGN   6344--ASSIGN
      7181--ASSIGN   7192--ASSIGN
P$NODE.CODE
      3972**DCL      5992>>ASSIGN   7039>>ASSIGN   7191>>ASSIGN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:336  
P$NODE.F_F
      3931**DCL      6223>>IF
P$NODE.NSUBNDS
      3969**DCL      5205>>ASSIGN   5313>>ASSIGN   5349>>DOWHILE
P$NODE.OPT
      3947**DCL      6218>>IF
P$NODE.O_F
      3936**DCL      5502>>IF       5937>>IF       6025>>IF       6309>>IF
P$NODE.P_F
      3919**DCL      5173>>IF
P$NODE.RPEAT
      3952**DCL      5109>>IF       5121>>ASSIGN   5918>>IF
P$NODE.RTEXT
      3962**DCL      5956>>IF       7040>>IF
P$NODE.SUBNDS$
      3977**DCL      5227>>ASSIGN   6761>>ASSIGN
P$NODE.S_F
      3925**DCL      7121>>IF
P$NODE.TYPE
      3915**DCL      5109>>IF       5191>>DOCASE   5286>>IF       6104>>IF       6104>>IF       6125>>IF
      6125>>IF       6127>>DOCASE   7043>>DOCASE
P$PCB.CMPRS
      4568**DCL      5937>>IF
P$PCB.CONTINUE
      4574**DCL      6465>>IF
P$PCB.DYNMEM
      4600**DCL      7261>>IF
P$PCB.ERROR
      4637**DCL      5895<<ASSIGN   6374<<ASSIGN   6388<<ASSIGN   7180<<ASSIGN   7264<<ASSIGN   7297<<ASSIGN
P$PCB.HINODE$
      4691**DCL      5896<<ASSIGN   6344<<ASSIGN   7181<<ASSIGN
P$PCB.HI_CHAR
      4684**DCL      5206>>IF       5431>>IF       5595>>IF       5649>>IF       5808>>IF       5897<<ASSIGN
      6104>>IF       6341>>IF       6343<<ASSIGN   6375<<ASSIGN   6389<<ASSIGN   6519<<ASSIGN   7182<<ASSIGN
P$PCB.NCHARS
      4680**DCL      5081>>ASSIGN   6859>>ASSIGN   6886>>ASSIGN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:337  
P$PCB.NXT
      4583**DCL      5206>>IF       5431>>IF       5595>>IF       5649>>IF       5808>>IF       6104>>IF
      6341>>IF       7144>>IF
P$PCB.NXT_SZONLY
      4628**DCL      6104>>IF
P$PCB.ROOT$
      4538**DCL      6889>>ASSIGN
P$PCB.TEXT$
      4534**DCL      5455>>ASSIGN   5472>>ASSIGN   5509>>CALLBLT  5512>>ASSIGN   5545>>CALLBLT  5611>>ASSIGN
      5673>>CALLBLT  5684>>IF       5689>>ASSIGN   5701>>ASSIGN   5732>>ASSIGN   5820>>CALLBLT  5823>>ASSIGN
      5868>>ASSIGN   5988>>ASSIGN   6281>>ASSIGN   6483>>DOWHILE  6509>>ASSIGN   6510>>ASSIGN   6521>>ASSIGN
      6811>>ASSIGN   6888>>ASSIGN   6939>>IF       6971>>CALLBLT  6982>>CALLBLT  6996>>ASSIGN   7014>>IF
P$PCB.U$$
      4551**DCL      6465>>IF       7178>>IF       7203>>CALL     7261>>IF
P$PCB.USER$
      4700**DCL      7197>>ASSIGN
P$PCB.WKSZ
      4563**DCL      5120>>ASSIGN   5146>>ASSIGN   5374>>ASSIGN   5398>>ASSIGN   5931>>ASSIGN   6097>>ASSIGN
      7132>>ASSIGN   7198>>ASSIGN   7279>>ASSIGN   7292<<ASSIGN   7294>>IF       7313>>ASSIGN
P$PCB.WK_USED
      4666**DCL      6111>>ASSIGN   7146>>ASSIGN
P$PCB.WORK$
      4542**DCL      5120>>ASSIGN   5146>>ASSIGN   5374>>ASSIGN   5398>>ASSIGN   5931>>ASSIGN   6097>>ASSIGN
      6111>>ASSIGN   7132>>ASSIGN   7146>>ASSIGN   7278>>ASSIGN   7294>>IF
P$SYM
      4050**DCL      5439--ASSIGN   5602--ASSIGN
P$SYM.COUNT
      4100**DCL      4104--IMP-SIZ  5544>>DOWHILE  5545>>CALLBLT  6168>>IF       6168>>IF       6168>>IF
      6168>>IF
P$SYM.LEXTYPE
      4081**DCL      5413>>DOCASE   5621>>IF       5621>>IF       6142>>IF       6142>>IF       6144>>DOCASE
      7055>>DOCASE
P$SYM.MAKEUC
      4066**DCL      5507>>IF
P$SYM.MAXL
      4094**DCL      5491>>IF       5491>>IF       6168>>IF       6168>>IF
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:338  
P$SYM.SKBL
      4064**DCL      6298>>IF
P$SYM.TEXT
      4104**DCL      5545>>CALLBLT  6168>>IF       6168>>IF
P$SYM.XTRA
      4072**DCL      5489>>IF       5543>>IF       5715>>IF       6164>>IF       6166>>IF       6176>>IF
P$SYM.COUNT IN PROCEDURE CHKCHAR
      6633**DCL      6637--IMP-SIZ  6728>>CALLBLT
P$SYM.LEXTYPE IN PROCEDURE CHKCHAR
      6614**DCL      6658>>DOCASE
P$SYM.TEXT IN PROCEDURE CHKCHAR
      6637**DCL      6728>>CALLBLT
P$SYM.XTRA IN PROCEDURE CHKCHAR
      6605**DCL      6726>>IF
PARSE$PARAM
      5004**DCL      7189<<ASSIGN   7203<>CALL
PARSE$PARAM.ACCEPT
      5011**DCL      6234>>IF
PARSE$PARAM.CHARPOS
      5042**DCL      7194<<ASSIGN   7212>>ASSIGN
PARSE$PARAM.CODE
      5025**DCL      7191<<ASSIGN
PARSE$PARAM.GLOBAL$
      5038**DCL      7195<<ASSIGN
PARSE$PARAM.NODE$
      5030**DCL      7192<<ASSIGN
PARSE$PARAM.OUT$
      5034**DCL      6236>>IF       6238>>ASSIGN   7124>>ASSIGN   7193<<ASSIGN
PARSE$PARAM.PCB$
      5048**DCL      7196<<ASSIGN   7197>>ASSIGN
PARSE$PARAM.REJECT
      5016**DCL      5176>>IF       7125>>IF
PARSE$PARAM.RETRY
      5020**DCL      6245>>IF       7130>>IF
PARSE$PARAM.TYPE
      5005**DCL      7190<<ASSIGN
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:339  
PARSE$PARAM.USER$
      5052**DCL      7197<<ASSIGN
PARSE$PARAM.WKSZ
      5057**DCL      7198<<ASSIGN   7292>>ASSIGN
PARS_SUBND
      6759**PROC     5307--CALL     5325--CALL     5350--CALL     5368--CALL     5381--CALL
PCB$
      4296**DCL      4533--IMP-PTR  5080<<ASSIGN   5081>>ASSIGN   5120>>ASSIGN   5120>>ASSIGN   5146>>ASSIGN
      5146>>ASSIGN   5206>>IF       5206>>IF       5374>>ASSIGN   5374>>ASSIGN   5398>>ASSIGN   5398>>ASSIGN
      5431>>IF       5431>>IF       5455>>ASSIGN   5472>>ASSIGN   5509>>CALLBLT  5512>>ASSIGN   5545>>CALLBLT
      5595>>IF       5595>>IF       5611>>ASSIGN   5649>>IF       5649>>IF       5673>>CALLBLT  5684>>IF
      5689>>ASSIGN   5701>>ASSIGN   5732>>ASSIGN   5808>>IF       5808>>IF       5820>>CALLBLT  5823>>ASSIGN
      5868>>ASSIGN   5896>>ASSIGN   5897>>ASSIGN   5931>>ASSIGN   5931>>ASSIGN   5937>>IF       5988>>ASSIGN
      6097>>ASSIGN   6097>>ASSIGN   6104>>IF       6104>>IF       6104>>IF       6111>>ASSIGN   6111>>ASSIGN
      6281>>ASSIGN   6341>>IF       6341>>IF       6343>>ASSIGN   6344>>ASSIGN   6374>>ASSIGN   6375>>ASSIGN
      6388>>ASSIGN   6389>>ASSIGN   6465>>IF       6465>>IF       6483>>DOWHILE  6509>>ASSIGN   6510>>ASSIGN
      6519>>ASSIGN   6521>>ASSIGN   6811>>ASSIGN   6859>>ASSIGN   6885<<ASSIGN   6886>>ASSIGN   6888>>ASSIGN
      6889>>ASSIGN   6939>>IF       6971>>CALLBLT  6982>>CALLBLT  6996>>ASSIGN   7014>>IF       7132>>ASSIGN
      7132>>ASSIGN   7144>>IF       7146>>ASSIGN   7146>>ASSIGN   7178>>IF       7180>>ASSIGN   7181>>ASSIGN
      7182>>ASSIGN   7198>>ASSIGN   7203>>CALL     7233<<ASSIGN   7261>>IF       7261>>IF       7264>>ASSIGN
      7278>>ASSIGN   7279>>ASSIGN   7292>>ASSIGN   7294>>IF       7294>>IF       7297>>ASSIGN   7313>>ASSIGN
POSS.COUNT
      5068**DCL      6112>>ASSIGN   6187>>IF       6193>>ASSIGN   6194<<ASSIGN   6194>>ASSIGN   7147>>IF
POSS.NODES$
      5069**DCL      6114>>ASSIGN   6187--IF       6193<<ASSIGN   7147--IF
POSSIBLE_NODE
      6107**LABEL    6120--EXIT     6137--EXIT     6149--EXIT     6158--EXIT     6172--EXIT     6178--EXIT
PX$DSTR.DLIM
      4972**DCL      5255>>IF       5255>>IF
PX$LIT.TEXT
      4853**DCL      5248>>IF       5248>>IF
PX$NODE.SUBNDS$
      4799**DCL      5240>>ASSIGN   5244>>ASSIGN
PX$NODE.TYPE
      4737**DCL      5237>>DOCASE
PX$SYM.LEXTYPE
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:340  
      4903**DCL      5253>>DOCASE
Q$
      4313**DCL      5504<>CALL     5505>>ASSIGN   5514>>ASSIGN   5727<>CALL     5728>>ASSIGN   5730>>ASSIGN
      5737<>CALL     5738>>ASSIGN   5740>>ASSIGN   5863<>CALL     5864>>ASSIGN   5866>>ASSIGN   5985<>CALL
      5986>>ASSIGN   5990>>ASSIGN   6004<>CALL     6005>>ASSIGN   6114<<ASSIGN   6118>>IF       6125>>IF
      6133>>IF       6133>>IF       6133>>IF       6133>>IF       6142>>IF       6155>>IF       6155>>IF
      6166>>IF       6168>>IF       6168>>IF       6168>>IF       6168>>IF       6176>>IF       6312<>CALL
      6313>>ASSIGN
QT_LOOP
      5468**LABEL    5474--GOTO
R$BLK.FLAG
      4340**DCL      5305>>IF       5319<<ASSIGN
R$BLK.FLINK$
      4338**DCL      5297>>DOWHILE  5299>>ASSIGN   5314<>CALL     5315>>ASSIGN   5317<<ASSIGN   6422>>ASSIGN
R$BLK.NODE$
      4339**DCL      5297>>DOWHILE  5305>>IF       5312>>IF       5316<<ASSIGN
RDUCE$
      4323**DCL      5111<<ASSIGN   5114<<ASSIGN   6064>>IF       6252>>IF       6419>>ASSIGN   6421<<ASSIGN
      6423<>CALL
RELRED
      6417**PROC     6065--CALL     6253--CALL
REPARSE
      5138**LABEL    6044--GOTO     6055--GOTO     6246--GOTO     6335--GOTO     6356--GOTO
REPEAT
      4321**DCL      5086<<ASSIGN   5919<<ASSIGN   5937>>IF       6052>>IF       6208>>IF       6211<<ASSIGN
      6354<<ASSIGN
REPEATABLE
      4322**DCL      5121<<ASSIGN   6092<<ASSIGN   6352>>IF
RPEATSUC
      5931**LABEL    6212--GOTO
RP_STACK
      4301**DCL      5120<<ASSIGN   6210>>ASSIGN
RTEXT_GT_511
      4282**DCL      6388>>ASSIGN
RTEXT_TOO_LONG
      6388**LABEL    5725--GOTO     5978--GOTO
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:341  
SAVELEX
      4291**DCL      5155<<ASSIGN   5376<<ASSIGN   6834>>ASSIGN
SAVEPOS
      4290**DCL      5154<<ASSIGN   5375<<ASSIGN   5781<<ASSIGN   5781>>ASSIGN   5964>>IF       6032>>ASSIGN
      6054>>IF       6275<<ASSIGN   6275>>ASSIGN   6287>>IF       6315>>ASSIGN   6322>>ASSIGN   6355>>IF
      6769>>IF       6833>>ASSIGN
SAVE_POS IN PROCEDURE ADVCHAR
      6832**ENTRY    5400--CALL     6090--CALL
SET_CHAR IN PROCEDURE ADVCHAR
      6858**ENTRY    7213--CALL
SKIPBL
      4292**DCL      5156<<ASSIGN   5377<<ASSIGN   6835>>ASSIGN
SSAVEPOS
      4289**DCL      5122<<ASSIGN   5975>>ASSIGN   5988>>ASSIGN   5993>>ASSIGN
STACKARY$
      4333**DCL      5944>>IF       5947>>ASSIGN   6013>>ASSIGN   7096<>CALL     7151<<ASSIGN
STCHAR IN PROCEDURE ADVCHAR
      6808**LABEL    6861--GOTO
STDLEX
      5595**LABEL    5570--GOTO
SUCCEED_BLK
      7119**PROC     6039--CALL     6330--CALL
SYMTTBL.ACCOUNT
       690**DCL      6705>>IF
SYMTTBL.ALNUM
       690**DCL      6676>>IF
SYMTTBL.ALPHA
       690**DCL      6672>>IF       6694>>IF
SYMTTBL.DEC
       690**DCL      6668>>IF       6678>>IF       6686>>IF
SYMTTBL.FID
       689**DCL      6701>>IF
SYMTTBL.GENERIC_DSTRING
       690**DCL      5255>>IF       5640>>IF
SYMTTBL.HEX
       690**DCL      6710>>IF
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:342  
SYMTTBL.JOBNAME
       690**DCL      6715>>IF
SYMTTBL.OCT
       690**DCL      6664>>IF
SYMTTBL.PL6SYM
       690**DCL      6692>>IF
SYMTTBL.SYM
       689**DCL      6684>>IF
SYNFAIL
      6090**LABEL    5186--GOTO     5338--GOTO     5350--CALLALT  5390--GOTO     5433--GOTO     5440--CALLALT
      5471--GOTO     5494--GOTO     5597--GOTO     5603--CALLALT  5623--GOTO     5642--GOTO     5651--GOTO
      5669--GOTO     5673--CALLALT  5688--GOTO     5700--GOTO     5719--GOTO     5766--GOTO     5780--GOTO
      5811--GOTO     5835--GOTO     5842--GOTO
SYNFAIL1
      6064**LABEL    6042--GOTO     6057--GOTO     6333--GOTO     6358--GOTO
SYNSUCCEED
      5918**LABEL    5329--GOTO     5353--GOTO     5401--GOTO     5767--GOTO     6237--GOTO
TINDX IN PROCEDURE CHK_COMMENT
      6914**DCL      6971<<CALLBLT  6975>>ASSIGN   6982<<CALLBLT  6986>>ASSIGN
TRANSTBL
      4267**DCL      5509>>CALLBLT  5744>>CALLBLT  5820>>CALLBLT
TRANSTBL.C
      4267**DCL      5248>>IF
TYPE IN PROCEDURE USER_EXIT
      7173**DCL      7171--PROC     7190>>ASSIGN   7205>>IF
UBIN$WORD IN PROCEDURE EXPAND_WORKAREA
      7256**DCL      7318<<ASSIGN   7318>>ASSIGN
USER_EXIT
      7171**PROC     5175--CALL     6225--CALL     6514--CALL     7123--CALL     7285--CALL
VALIDSYM
      4317**DCL      5269<<ASSIGN   5273<<ASSIGN   5601<<ASSIGN   5622>>IF       6679<<ASSIGN   6687<<ASSIGN
      6693>>IF       6696<<ASSIGN   6730<<ASSIGN
XUP$FREEOUT
      4272**DCL-ENT  7096--CALL
XUP$FREESPACE
      4274**DCL-ENT  6423--CALL
PL6.E3A0      #002=XUP$PARS File=XUP$PARSE.:E05TSI                               WED 07/30/97 09:37 Page:343  
XUP$GETSPACE
      4273**DCL-ENT  5314--CALL     5504--CALL     5727--CALL     5737--CALL     5863--CALL     5985--CALL
      6004--CALL     6312--CALL
XUP$PARS
         6**PROC     6778--CALL
XUP_SYMTBL
       689**DCL       689--REDEF

PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:344  
     2889        1        /*T***********************************************************/
     2890        2        /*T*                                                         */
     2891        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     2892        4        /*T*                                                         */
     2893        5        /*T***********************************************************/
     2894        6        XUP$GETSPACE:
     2895        7            PROC(COUNT,OUTBLK$,G$D);
     2896        8
     2897        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     2898       10        /*D*
     2899       11            NAME: XUP$GETSPACE
     2900       12            CALL:
     2901       13                CALL XUP$GETSPACE (COUNT, OUTBLK$, G$D);
     2902       14            PARAMETERS:
     2903       15                COUNT -- the number of words needed for the new block
     2904       16                OUTBLK$ -- returns a pointer to the block allocated
     2905       17                G$D -- the parser global data structure
     2906       18            INTERFACE:
     2907       19                XUP$EXPAND_WORKAREA
     2908       20            OUTPUT:
     2909       21                A new block of the requested size is allocated in the parse
     2910       22                work area.
     2911       23            DESCRIPTION:
     2912       24                This routine allocates blocks in the parse work area.
     2913       25        */
     2914       26        %INCLUDE      XU_MACRO_C;
     2915     3132        %INCLUDE      XU_SUBS_C;
     2916     3224        /*
     2917     3225            ***       PARAMETERS
     2918     3226        */
     2919     3227    1   DCL       COUNT    SBIN;
     2920     3228    1   DCL       OUTBLK$  PTR;
     2921     3229            %G$D;
     2922     3325        /*
     2923     3326            ***       LOCAL VARIABLES
     2924     3327        */
     2925     3328    1   DCL       ICOUNT   SBIN;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:345  
     2926     3329    1   DCL       BLK$     PTR;
     2927     3330    1   DCL       BLK$INIT(0:0)  UBIN  WORD  BASED  ALIGNED;
     2928     3331        /*
     2929     3332            ***        Entry references
     2930     3333        */
     2931     3334    1   DCL       XUP$EXPAND_WORKAREA ENTRY (1) ALTRET;
     2932     3335        /*
     2933     3336            ***       Parser data structures
     2934     3337        */
     2935     3338            %XUP$CHAIN;
     2936     3344            %P$PCB(STCLASS=BASED);
     2937     3545        %EJECT;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:346  
     2938     3546        /*
     2939     3547        ***           BEGIN PROCEDURE
     2940     3548        */
     2941     3549        /*D*
     2942     3550            Make sure the block will be large enough to be a free chain block.
     2943     3551        */
     2944     3552    1   X$GETSPACE: ENTRY(COUNT,OUTBLK$,G$D);
     2945     3553    1       ICOUNT = MAXIMUM (COUNT+1, 3);
     2946     3554        /*D*
     2947     3555            Scan the free space chain for a block of at least the requested size.
     2948     3556        */
     2949     3557    1       BLK$ = G$D.FREEANCHOR$->FREE$HDR.NEXT$;
     2950     3558    2       DO WHILE(BLK$ ~= G$D.LASTFREE$
     2951     3559    2         AND BLK$->FREE$HDR.NWORDS < ICOUNT);
     2952     3560    2           BLK$ = BLK$->FREE$HDR.NEXT$;
     2953     3561    2       END;
     2954     3562        /*D*
     2955     3563            If no suitable free block is found ...
     2956     3564        */
     2957     3565    1       IF BLK$ = G$D.LASTFREE$ THEN
     2958     3566    2       DO;
     2959     3567        /*D*
     2960     3568            o   Expand the output block area by the size of the new block.
     2961     3569        */
     2962     3570    2           G$D.HISPACE$ = PINCRW( G$D.HISPACE$,ICOUNT);
     2963     3571        /*D*
     2964     3572            o   If there is not enough room in the work area to hold the new
     2965     3573                block, try to expand the work area.
     2966     3574        */
     2967     3575    3           DO WHILE G$D.HISPACE$ >= G$D.STACKTOP$;
     2968     3576    3               CALL XUP$EXPAND_WORKAREA (G$D);
     2969     3577    3           END;
     2970     3578        /*D*
     2971     3579            o   Rebuild the free chain trailer block following the new block.
     2972     3580        */
     2973     3581
     2974     3582    2           G$D.LASTFREE$ = PINCRW(G$D.HISPACE$,-2);
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:347  
     2975     3583    2           G$D.LASTFREE$->FREE$HDR.NEXT$ = ADDR(NIL);
     2976     3584    2           G$D.LASTFREE$->FREE$HDR.PREV$ =
     2977     3585    2             BLK$->FREE$HDR.PREV$;
     2978     3586    2           G$D.LASTFREE$->FREE$HDR.NWORDS = 3;
     2979     3587    2           BLK$->FREE$HDR.NWORDS = ICOUNT;
     2980     3588    2           BLK$->FREE$HDR.PREV$ ->FREE$HDR.NEXT$ =
     2981     3589    2             G$D.LASTFREE$;
     2982     3590    2       END;
     2983     3591        /*D*
     2984     3592            If a free block large enough to hold the new block is found ...
     2985     3593        */
     2986     3594    1       ELSE
     2987     3595    2       DO;
     2988     3596        /*D*
     2989     3597            o   If the block found is too small to create a new free chain
     2990     3598                block after the block being allocated, reuse the whole block.
     2991     3599        */
     2992     3600    2           IF BLK$->FREE$HDR.NWORDS - ICOUNT < 3 THEN
     2993     3601    3           DO;
     2994     3602    3               BLK$->FREE$HDR.PREV$->FREE$HDR.NEXT$ =
     2995     3603    3                 BLK$->FREE$HDR.NEXT$;
     2996     3604    3               BLK$->FREE$HDR.NEXT$->FREE$HDR.PREV$ =
     2997     3605    3                 BLK$->FREE$HDR.PREV$;
     2998     3606    3           END;
     2999     3607        /*D*
     3000     3608            o   Otherwise, build a new free chain block at the end of the block
     3001     3609                being allocated, and reduce its size accordingly.  Links don't
     3002     3610                change in this case.
     3003     3611        */
     3004     3612    2           ELSE
     3005     3613    3           DO;
     3006     3614    3               BLK$->FREE$HDR.NWORDS =
     3007     3615    3                 BLK$->FREE$HDR.NWORDS - ICOUNT ;
     3008     3616    3               BLK$ = PINCRW(BLK$,BLK$->FREE$HDR.NWORDS);
     3009     3617    3               BLK$->FREE$HDR.NWORDS = ICOUNT;
     3010     3618    3           END;
     3011     3619    2       END;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:348  
     3012     3620        /*D*
     3013     3621            Clear the new block to zeros.
     3014     3622        */
     3015     3623    1       ICOUNT = ICOUNT - 1;
     3016     3624    2       DO WHILE(ICOUNT > 0);
     3017     3625    2           BLK$->BLK$INIT(ICOUNT) = 0;
     3018     3626    2           ICOUNT = ICOUNT - 1;
     3019     3627    2       END;
     3020     3628        /*D*
     3021     3629            Bump the block address returned to the caller past the block size
     3022     3630            word, so that this word will remain intact for use by XUP$FREESPACE.
     3023     3631        */
     3024     3632    1       OUTBLK$ = PINCRW(BLK$, 1);
     3025     3633    1   END XUP$GETSPACE;
     3026     3634        %EOD;

PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:349  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$GETSPACE.

   Procedure XUP$GETSPACE requires 98 words for executable code.
   Procedure XUP$GETSPACE requires 8 words of local(AUTO) storage.

PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:350  

 Object Unit name= XUP$GETSPACE                               File name= XUP$PARSE.:E05TOU
 UTS= JUL 30 '97 09:38:41.84 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    98    142  XUP$GETSPACE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        3  XUP$GETSPACE
     0      3                  yes      Std        3  X$GETSPACE

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUP$EXPAND_WORKAREA
                       nStd      0 X66_AUTO_3
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:351  


     2889        1        /*T***********************************************************/
     2890        2        /*T*                                                         */
     2891        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     2892        4        /*T*                                                         */
     2893        5        /*T***********************************************************/
     2894        6        XUP$GETSPACE:
     2895        7            PROC(COUNT,OUTBLK$,G$D);

      7  0 000000   000000 700200 xent  XUP$GETSPACE TSX0  ! X66_AUTO_3
         0 000001   000010 000003                    ZERO    8,3
         0 000002   000005 710000 0                  TRA     s:3553

     2896        8
     2897        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     2898       10        /*D*
     2899       11            NAME: XUP$GETSPACE
     2900       12            CALL:
     2901       13                CALL XUP$GETSPACE (COUNT, OUTBLK$, G$D);
     2902       14            PARAMETERS:
     2903       15                COUNT -- the number of words needed for the new block
     2904       16                OUTBLK$ -- returns a pointer to the block allocated
     2905       17                G$D -- the parser global data structure
     2906       18            INTERFACE:
     2907       19                XUP$EXPAND_WORKAREA
     2908       20            OUTPUT:
     2909       21                A new block of the requested size is allocated in the parse
     2910       22                work area.
     2911       23            DESCRIPTION:
     2912       24                This routine allocates blocks in the parse work area.
     2913       25        */
     2914       26        %INCLUDE      XU_MACRO_C;
     2915     3132        %INCLUDE      XU_SUBS_C;
     2916     3224        /*
     2917     3225            ***       PARAMETERS
     2918     3226        */
     2919     3227    1   DCL       COUNT    SBIN;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:352  
     2920     3228    1   DCL       OUTBLK$  PTR;
     2921     3229            %G$D;
     2922     3325        /*
     2923     3326            ***       LOCAL VARIABLES
     2924     3327        */
     2925     3328    1   DCL       ICOUNT   SBIN;
     2926     3329    1   DCL       BLK$     PTR;
     2927     3330    1   DCL       BLK$INIT(0:0)  UBIN  WORD  BASED  ALIGNED;
     2928     3331        /*
     2929     3332            ***        Entry references
     2930     3333        */
     2931     3334    1   DCL       XUP$EXPAND_WORKAREA ENTRY (1) ALTRET;
     2932     3335        /*
     2933     3336            ***       Parser data structures
     2934     3337        */
     2935     3338            %XUP$CHAIN;
     2936     3344            %P$PCB(STCLASS=BASED);
     2937     3545        %EJECT;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:353  
     2938     3546        /*
     2939     3547        ***           BEGIN PROCEDURE
     2940     3548        */
     2941     3549        /*D*
     2942     3550            Make sure the block will be large enough to be a free chain block.
     2943     3551        */
     2944     3552    1   X$GETSPACE: ENTRY(COUNT,OUTBLK$,G$D);

   3552  0 000003   000000 700200 xent  X$GETSPACE   TSX0  ! X66_AUTO_3
         0 000004   000010 000003                    ZERO    8,3

     2945     3553    1       ICOUNT = MAXIMUM (COUNT+1, 3);

   3553  0 000005   200003 470500                    LDP0    @COUNT,,AUTO
         0 000006   000000 236100                    LDQ     0,,PR0
         0 000007   000001 036007                    ADLQ    1,DL
         0 000010   000003 116007                    CMPQ    3,DL
         0 000011   000013 605000 0                  TPL     s:3553+6
         0 000012   000003 236007                    LDQ     3,DL
         0 000013   200006 756100                    STQ     ICOUNT,,AUTO

     2946     3554        /*D*
     2947     3555            Scan the free space chain for a block of at least the requested size.
     2948     3556        */
     2949     3557    1       BLK$ = G$D.FREEANCHOR$->FREE$HDR.NEXT$;

   3557  0 000014   200005 471500                    LDP1    @G$D,,AUTO
         0 000015   100005 473500                    LDP3    5,,PR1
         0 000016   300001 236100                    LDQ     1,,PR3
         0 000017   200007 756100                    STQ     BLK$,,AUTO

     2950     3558    2       DO WHILE(BLK$ ~= G$D.LASTFREE$

   3558  0 000020   000024 710000 0                  TRA     s:3561

     2951     3559    2         AND BLK$->FREE$HDR.NWORDS < ICOUNT);
     2952     3560    2           BLK$ = BLK$->FREE$HDR.NEXT$;
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:354  

   3560  0 000021   200007 470500                    LDP0    BLK$,,AUTO
         0 000022   000001 236100                    LDQ     1,,PR0
         0 000023   200007 756100                    STQ     BLK$,,AUTO

     2953     3561    2       END;

   3561  0 000024   200005 470500                    LDP0    @G$D,,AUTO
         0 000025   000006 116100                    CMPQ    6,,PR0
         0 000026   000033 600000 0                  TZE     s:3565
         0 000027   200007 471500                    LDP1    BLK$,,AUTO
         0 000030   100000 236100                    LDQ     0,,PR1
         0 000031   200006 116100                    CMPQ    ICOUNT,,AUTO
         0 000032   000021 604000 0                  TMI     s:3560

     2954     3562        /*D*
     2955     3563            If no suitable free block is found ...
     2956     3564        */
     2957     3565    1       IF BLK$ = G$D.LASTFREE$ THEN

   3565  0 000033   200007 236100                    LDQ     BLK$,,AUTO
         0 000034   000006 116100                    CMPQ    6,,PR0
         0 000035   000077 601000 0                  TNZ     s:3600

     2958     3566    2       DO;

     2959     3567        /*D*
     2960     3568            o   Expand the output block area by the size of the new block.
     2961     3569        */
     2962     3570    2           G$D.HISPACE$ = PINCRW( G$D.HISPACE$,ICOUNT);

   3570  0 000036   000007 471500                    LDP1    7,,PR0
         0 000037   200006 720100                    LXL0    ICOUNT,,AUTO
         0 000040   100000 633510                    EPPR3   0,X0,PR1
         0 000041   000007 453500                    STP3    7,,PR0

     2963     3571        /*D*
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:355  
     2964     3572            o   If there is not enough room in the work area to hold the new
     2965     3573                block, try to expand the work area.
     2966     3574        */
     2967     3575    3           DO WHILE G$D.HISPACE$ >= G$D.STACKTOP$;

   3575  0 000042   000007 236100                    LDQ     7,,PR0
         0 000043   000010 116100                    CMPQ    8,,PR0
         0 000044   000055 602000 0                  TNC     s:3582

     2968     3576    3               CALL XUP$EXPAND_WORKAREA (G$D);

   3576  0 000045   200005 630500                    EPPR0   @G$D,,AUTO
         0 000046   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000047   000000 701000 xent               TSX1    XUP$EXPAND_WORKAREA
         0 000050   000000 011000                    NOP     0

     2969     3577    3           END;

   3577  0 000051   200005 470500                    LDP0    @G$D,,AUTO
         0 000052   000007 236100                    LDQ     7,,PR0
         0 000053   000010 116100                    CMPQ    8,,PR0
         0 000054   000045 603000 0                  TRC     s:3576

     2970     3578        /*D*
     2971     3579            o   Rebuild the free chain trailer block following the new block.
     2972     3580        */
     2973     3581
     2974     3582    2           G$D.LASTFREE$ = PINCRW(G$D.HISPACE$,-2);

   3582  0 000055   777776 036003                    ADLQ    -2,DU
         0 000056   000006 756100                    STQ     6,,PR0

     2975     3583    2           G$D.LASTFREE$->FREE$HDR.NEXT$ = ADDR(NIL);

   3583  0 000057   000006 471500                    LDP1    6,,PR0
         0 000060   000001 236000 xsym               LDQ     B_VECTNIL+1
         0 000061   100001 756100                    STQ     1,,PR1
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:356  

     2976     3584    2           G$D.LASTFREE$->FREE$HDR.PREV$ =

   3584  0 000062   000006 471500                    LDP1    6,,PR0
         0 000063   200007 473500                    LDP3    BLK$,,AUTO
         0 000064   300002 236100                    LDQ     2,,PR3
         0 000065   100002 756100                    STQ     2,,PR1

     2977     3585    2             BLK$->FREE$HDR.PREV$;
     2978     3586    2           G$D.LASTFREE$->FREE$HDR.NWORDS = 3;

   3586  0 000066   000006 471500                    LDP1    6,,PR0
         0 000067   000003 235007                    LDA     3,DL
         0 000070   100000 755100                    STA     0,,PR1

     2979     3587    2           BLK$->FREE$HDR.NWORDS = ICOUNT;

   3587  0 000071   200006 236100                    LDQ     ICOUNT,,AUTO
         0 000072   300000 756100                    STQ     0,,PR3

     2980     3588    2           BLK$->FREE$HDR.PREV$ ->FREE$HDR.NEXT$ =

   3588  0 000073   300002 471500                    LDP1    2,,PR3
         0 000074   000006 236100                    LDQ     6,,PR0
         0 000075   100001 756100                    STQ     1,,PR1

     2981     3589    2             G$D.LASTFREE$;
     2982     3590    2       END;

   3590  0 000076   000124 710000 0                  TRA     s:3623

     2983     3591        /*D*
     2984     3592            If a free block large enough to hold the new block is found ...
     2985     3593        */
     2986     3594    1       ELSE
     2987     3595    2       DO;

PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:357  
     2988     3596        /*D*
     2989     3597            o   If the block found is too small to create a new free chain
     2990     3598                block after the block being allocated, reuse the whole block.
     2991     3599        */
     2992     3600    2           IF BLK$->FREE$HDR.NWORDS - ICOUNT < 3 THEN

   3600  0 000077   200007 471500                    LDP1    BLK$,,AUTO
         0 000100   100000 236100                    LDQ     0,,PR1
         0 000101   200006 136100                    SBLQ    ICOUNT,,AUTO
         0 000102   000003 116007                    CMPQ    3,DL
         0 000103   000113 605000 0                  TPL     s:3614

     2993     3601    3           DO;

     2994     3602    3               BLK$->FREE$HDR.PREV$->FREE$HDR.NEXT$ =

   3602  0 000104   100002 473500                    LDP3    2,,PR1
         0 000105   100001 236100                    LDQ     1,,PR1
         0 000106   300001 756100                    STQ     1,,PR3

     2995     3603    3                 BLK$->FREE$HDR.NEXT$;
     2996     3604    3               BLK$->FREE$HDR.NEXT$->FREE$HDR.PREV$ =

   3604  0 000107   100001 473500                    LDP3    1,,PR1
         0 000110   100002 236100                    LDQ     2,,PR1
         0 000111   300002 756100                    STQ     2,,PR3

     2997     3605    3                 BLK$->FREE$HDR.PREV$;
     2998     3606    3           END;

   3606  0 000112   000124 710000 0                  TRA     s:3623

     2999     3607        /*D*
     3000     3608            o   Otherwise, build a new free chain block at the end of the block
     3001     3609                being allocated, and reduce its size accordingly.  Links don't
     3002     3610                change in this case.
     3003     3611        */
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:358  
     3004     3612    2           ELSE
     3005     3613    3           DO;

     3006     3614    3               BLK$->FREE$HDR.NWORDS =

   3614  0 000113   100000 236100                    LDQ     0,,PR1
         0 000114   200006 136100                    SBLQ    ICOUNT,,AUTO
         0 000115   100000 756100                    STQ     0,,PR1

     3007     3615    3                 BLK$->FREE$HDR.NWORDS - ICOUNT ;
     3008     3616    3               BLK$ = PINCRW(BLK$,BLK$->FREE$HDR.NWORDS);

   3616  0 000116   000022 736000                    QLS     18
         0 000117   200007 036100                    ADLQ    BLK$,,AUTO
         0 000120   200007 756100                    STQ     BLK$,,AUTO

     3009     3617    3               BLK$->FREE$HDR.NWORDS = ICOUNT;

   3617  0 000121   200007 471500                    LDP1    BLK$,,AUTO
         0 000122   200006 235100                    LDA     ICOUNT,,AUTO
         0 000123   100000 755100                    STA     0,,PR1

     3010     3618    3           END;

     3011     3619    2       END;

     3012     3620        /*D*
     3013     3621            Clear the new block to zeros.
     3014     3622        */
     3015     3623    1       ICOUNT = ICOUNT - 1;

   3623  0 000124   000001 336007                    LCQ     1,DL
         0 000125   200006 056100                    ASQ     ICOUNT,,AUTO

     3016     3624    2       DO WHILE(ICOUNT > 0);

   3624  0 000126   000135 604400 0                  TMOZ    s:3632
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:359  

     3017     3625    2           BLK$->BLK$INIT(ICOUNT) = 0;

   3625  0 000127   200007 470500                    LDP0    BLK$,,AUTO
         0 000130   200006 720100                    LXL0    ICOUNT,,AUTO
         0 000131   000000 450110                    STZ     0,X0,PR0

     3018     3626    2           ICOUNT = ICOUNT - 1;

   3626  0 000132   000001 336007                    LCQ     1,DL
         0 000133   200006 056100                    ASQ     ICOUNT,,AUTO

     3019     3627    2       END;

   3627  0 000134   000127 605400 0                  TPNZ    s:3625

     3020     3628        /*D*
     3021     3629            Bump the block address returned to the caller past the block size
     3022     3630            word, so that this word will remain intact for use by XUP$FREESPACE.
     3023     3631        */
     3024     3632    1       OUTBLK$ = PINCRW(BLK$, 1);

   3632  0 000135   200007 236100                    LDQ     BLK$,,AUTO
         0 000136   000001 036003                    ADLQ    1,DU
         0 000137   200004 470500                    LDP0    @OUTBLK$,,AUTO
         0 000140   000000 756100                    STQ     0,,PR0

     3025     3633    1   END XUP$GETSPACE;

   3633  0 000141   000000 702200 xent               TSX2  ! X66_ARET
     3026     3634        %EOD;

PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:360  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$GETSPACE.
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:361  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @COUNT                     5-0-0/w PTR         r     1 @G$D
     4-0-0/w PTR         r     1 @OUTBLK$                   7-0-0/w PTR         r     1 BLK$
    *0-0-0/w SBIN        r     1 COUNT                     *0-0-0/d STRC(5175)  r     1 G$D
     6-0-0/w SBIN        r     1 ICOUNT                    *0-0-0/w PTR         r     1 OUTBLK$

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w UBIN        r     1 BLK$INIT(0:0)
     0-0-0/w STRC(108)   r     1 FREE$HDR


   Procedure XUP$GETSPACE requires 98 words for executable code.
   Procedure XUP$GETSPACE requires 8 words of local(AUTO) storage.
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:362  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:363  
          MINI XREF LISTING

BLK$
      3329**DCL      3557<<ASSIGN   3558>>DOWHILE  3558>>DOWHILE  3560<<ASSIGN   3560>>ASSIGN   3565>>IF
      3584>>ASSIGN   3587>>ASSIGN   3588>>ASSIGN   3600>>IF       3602>>ASSIGN   3602>>ASSIGN   3604>>ASSIGN
      3604>>ASSIGN   3614>>ASSIGN   3614>>ASSIGN   3616<<ASSIGN   3616>>ASSIGN   3616>>ASSIGN   3617>>ASSIGN
      3625>>ASSIGN   3632>>ASSIGN
BLK$INIT
      3330**DCL      3625<<ASSIGN
COUNT
      3227**DCL         6--PROC     3552--ENTRY    3553>>ASSIGN
FREE$HDR.NEXT$
      3341**DCL      3557>>ASSIGN   3560>>ASSIGN   3583<<ASSIGN   3588<<ASSIGN   3602<<ASSIGN   3602>>ASSIGN
      3604>>ASSIGN
FREE$HDR.NWORDS
      3340**DCL      3558>>DOWHILE  3586<<ASSIGN   3587<<ASSIGN   3600>>IF       3614<<ASSIGN   3614>>ASSIGN
      3616>>ASSIGN   3617<<ASSIGN
FREE$HDR.PREV$
      3342**DCL      3584<<ASSIGN   3584>>ASSIGN   3588>>ASSIGN   3602>>ASSIGN   3604<<ASSIGN   3604>>ASSIGN
G$D
      3238**DCL         6--PROC     3552--ENTRY    3576<>CALL
G$D.FREEANCHOR$
      3256**DCL      3557>>ASSIGN
G$D.HISPACE$
      3264**DCL      3570<<ASSIGN   3570>>ASSIGN   3575>>DOWHILE  3582>>ASSIGN
G$D.LASTFREE$
      3260**DCL      3558>>DOWHILE  3565>>IF       3582<<ASSIGN   3583>>ASSIGN   3584>>ASSIGN   3586>>ASSIGN
      3588>>ASSIGN
G$D.LDCMNT.TX
      3308**DCL      3309--REDEF
G$D.SCRATCH
      3275**DCL      3278--REDEF
G$D.STACKTOP$
      3267**DCL      3575>>DOWHILE
PL6.E3A0      #003=XUP$GETSPACE File=XUP$PARSE.:E05TSI                           WED 07/30/97 09:38 Page:364  
G$D.TRCMNT.TX
      3316**DCL      3317--REDEF
ICOUNT
      3328**DCL      3553<<ASSIGN   3558>>DOWHILE  3570>>ASSIGN   3587>>ASSIGN   3600>>IF       3614>>ASSIGN
      3617>>ASSIGN   3623<<ASSIGN   3623>>ASSIGN   3624>>DOWHILE  3625>>ASSIGN   3626<<ASSIGN   3626>>ASSIGN
OUTBLK$
      3228**DCL         6--PROC     3552--ENTRY    3632<<ASSIGN
XUP$EXPAND_WORKAREA
      3334**DCL-ENT  3576--CALL

PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:365  
     3027        1        /*T***********************************************************/
     3028        2        /*T*                                                         */
     3029        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     3030        4        /*T*                                                         */
     3031        5        /*T***********************************************************/
     3032        6        XUP$FREESPACE:
     3033        7            PROC(INBLK$,G$D);
     3034        8
     3035        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     3036       10        /*D*
     3037       11            NAME: XUP$FREESPACE
     3038       12            CALL:
     3039       13                CALL XUP$FREESPACE (INBLK$, G$D);
     3040       14            PARAMETERS:
     3041       15                INBLK$ -- address of block to be freed
     3042       16                G$D -- the parser global data structure
     3043       17            OUTPUT:
     3044       18                Space occupied by the block has been put on the parse work
     3045       19                area's free space chain.
     3046       20            DESCRIPTION:
     3047       21                This routine frees a block in the parse work area by adding
     3048       22                it to the free space chain.
     3049       23        */
     3050       24        %INCLUDE      XU_MACRO_C;
     3051     3130        %INCLUDE      XU_SUBS_C;
     3052     3222        /*
     3053     3223            ***       PARAMETERS
     3054     3224        */
     3055     3225    1   DCL       INBLK$   PTR;
     3056     3226            %G$D;
     3057     3322        /*
     3058     3323            ***       LOCAL VARIABLES
     3059     3324        */
     3060     3325    1   DCL       BLK$     PTR;
     3061     3326    1   DCL       P$       PTR;
     3062     3327             %XUP$CHAIN;
     3063     3333            %P$PCB(STCLASS=BASED);
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:366  
     3064     3534        %EJECT;
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:367  
     3065     3535        /*
     3066     3536            ***       BEGIN PROCEDURE
     3067     3537        */
     3068     3538        /*D*
     3069     3539            Every block is preceded with a word containing its size, so start
     3070     3540            by backing up the block pointer to that word (which makes it the
     3071     3541            base address for a free chain header structure).
     3072     3542        */
     3073     3543    1       INBLK$ = PINCRW (INBLK$, -1);
     3074     3544    1       BLK$ = INBLK$;
     3075     3545        /*D*
     3076     3546            Scan the free space chain to find the last free block that physically
     3077     3547            precedes the one being freed.
     3078     3548        */
     3079     3549    1       P$ = G$D.FREEANCHOR$->FREE$HDR.NEXT$;
     3080     3550    2       DO WHILE (P$ < BLK$ AND P$ ~= G$D.LASTFREE$);
     3081     3551    2           P$ = P$->FREE$HDR.NEXT$;
     3082     3552    2       END;
     3083     3553        /*D*
     3084     3554            Link this block into the free chain at that point.
     3085     3555        */
     3086     3556    1       BLK$->FREE$HDR.NEXT$ = P$;
     3087     3557    1       BLK$->FREE$HDR.PREV$ = P$->FREE$HDR.PREV$;
     3088     3558        /*D*
     3089     3559            If this block is contiguous with the next free block, merge that
     3090     3560            block into this one.
     3091     3561        */
     3092     3562    1       IF P$ ~= G$D.LASTFREE$ THEN
     3093     3563    2       DO;
     3094     3564    2           IF PINCRW(BLK$,BLK$->FREE$HDR.NWORDS) = P$ THEN
     3095     3565    3           DO;
     3096     3566    3               BLK$->FREE$HDR.PREV$ = P$->FREE$HDR.PREV$;
     3097     3567    3               BLK$->FREE$HDR.NEXT$ = P$->FREE$HDR.NEXT$;
     3098     3568    3               BLK$->FREE$HDR.NWORDS = BLK$->FREE$HDR.NWORDS
     3099     3569    3                 + P$->FREE$HDR.NWORDS;
     3100     3570    3           END;
     3101     3571    2       END;
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:368  
     3102     3572        /*D*
     3103     3573            If this block is contiguous with the prior free block, merge this
     3104     3574            block into that one.
     3105     3575        */
     3106     3576    1       IF BLK$->FREE$HDR.PREV$ ~= G$D.FREEANCHOR$ THEN
     3107     3577    2       DO;
     3108     3578    2           IF PINCRW(P$->FREE$HDR.PREV$,P$->FREE$HDR.PREV$->
     3109     3579    2             FREE$HDR.NWORDS) = BLK$ THEN
     3110     3580    3           DO;
     3111     3581    3               P$ = P$->FREE$HDR.PREV$;
     3112     3582    3               P$->FREE$HDR.NWORDS = P$->FREE$HDR.NWORDS
     3113     3583    3                 +BLK$->FREE$HDR.NWORDS;
     3114     3584    3               P$->FREE$HDR.NEXT$ = BLK$->FREE$HDR.NEXT$;
     3115     3585    3               BLK$ = P$;
     3116     3586    3           END;
     3117     3587    2       END;
     3118     3588        /*D*
     3119     3589            Reset pointers to next and prior free blocks to reflect any merging we did.
     3120     3590        */
     3121     3591    1       BLK$->FREE$HDR.PREV$->FREE$HDR.NEXT$ = BLK$;
     3122     3592    1       BLK$->FREE$HDR.NEXT$->FREE$HDR.PREV$ = BLK$;
     3123     3593    1   END XUP$FREESPACE;
     3124     3594        %EOD;

PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:369  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$FREESPACE.

   Procedure XUP$FREESPACE requires 68 words for executable code.
   Procedure XUP$FREESPACE requires 10 words of local(AUTO) storage.

PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:370  

 Object Unit name= XUP$FREESPACE                              File name= XUP$PARSE.:E05TOU
 UTS= JUL 30 '97 09:38:47.84 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    68    104  XUP$FREESPACE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUP$FREESPACE

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
                       nStd      0 X66_AUTO_2
                       nStd      0 X66_ARET
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:371  


     3027        1        /*T***********************************************************/
     3028        2        /*T*                                                         */
     3029        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     3030        4        /*T*                                                         */
     3031        5        /*T***********************************************************/
     3032        6        XUP$FREESPACE:
     3033        7            PROC(INBLK$,G$D);

      7  0 000000   000000 700200 xent  XUP$FREESPA* TSX0  ! X66_AUTO_2
         0 000001   000012 000002                    ZERO    10,2

     3034        8
     3035        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     3036       10        /*D*
     3037       11            NAME: XUP$FREESPACE
     3038       12            CALL:
     3039       13                CALL XUP$FREESPACE (INBLK$, G$D);
     3040       14            PARAMETERS:
     3041       15                INBLK$ -- address of block to be freed
     3042       16                G$D -- the parser global data structure
     3043       17            OUTPUT:
     3044       18                Space occupied by the block has been put on the parse work
     3045       19                area's free space chain.
     3046       20            DESCRIPTION:
     3047       21                This routine frees a block in the parse work area by adding
     3048       22                it to the free space chain.
     3049       23        */
     3050       24        %INCLUDE      XU_MACRO_C;
     3051     3130        %INCLUDE      XU_SUBS_C;
     3052     3222        /*
     3053     3223            ***       PARAMETERS
     3054     3224        */
     3055     3225    1   DCL       INBLK$   PTR;
     3056     3226            %G$D;
     3057     3322        /*
     3058     3323            ***       LOCAL VARIABLES
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:372  
     3059     3324        */
     3060     3325    1   DCL       BLK$     PTR;
     3061     3326    1   DCL       P$       PTR;
     3062     3327             %XUP$CHAIN;
     3063     3333            %P$PCB(STCLASS=BASED);
     3064     3534        %EJECT;
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:373  
     3065     3535        /*
     3066     3536            ***       BEGIN PROCEDURE
     3067     3537        */
     3068     3538        /*D*
     3069     3539            Every block is preceded with a word containing its size, so start
     3070     3540            by backing up the block pointer to that word (which makes it the
     3071     3541            base address for a free chain header structure).
     3072     3542        */
     3073     3543    1       INBLK$ = PINCRW (INBLK$, -1);

   3543  0 000002   200003 470500                    LDP0    @INBLK$,,AUTO
         0 000003   000000 236100                    LDQ     0,,PR0
         0 000004   777777 036003                    ADLQ    -1,DU
         0 000005   000000 756100                    STQ     0,,PR0

     3074     3544    1       BLK$ = INBLK$;

   3544  0 000006   200005 756100                    STQ     BLK$,,AUTO

     3075     3545        /*D*
     3076     3546            Scan the free space chain to find the last free block that physically
     3077     3547            precedes the one being freed.
     3078     3548        */
     3079     3549    1       P$ = G$D.FREEANCHOR$->FREE$HDR.NEXT$;

   3549  0 000007   200004 471500                    LDP1    @G$D,,AUTO
         0 000010   100005 473500                    LDP3    5,,PR1
         0 000011   300001 236100                    LDQ     1,,PR3
         0 000012   200006 756100                    STQ     P$,,AUTO

     3080     3550    2       DO WHILE (P$ < BLK$ AND P$ ~= G$D.LASTFREE$);

   3550  0 000013   000017 710000 0                  TRA     s:3552

     3081     3551    2           P$ = P$->FREE$HDR.NEXT$;

   3551  0 000014   200006 470500                    LDP0    P$,,AUTO
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:374  
         0 000015   000001 236100                    LDQ     1,,PR0
         0 000016   200006 756100                    STQ     P$,,AUTO

     3082     3552    2       END;

   3552  0 000017   200005 116100                    CMPQ    BLK$,,AUTO
         0 000020   000024 603000 0                  TRC     s:3556
         0 000021   200004 470500                    LDP0    @G$D,,AUTO
         0 000022   000006 116100                    CMPQ    6,,PR0
         0 000023   000014 601000 0                  TNZ     s:3551

     3083     3553        /*D*
     3084     3554            Link this block into the free chain at that point.
     3085     3555        */
     3086     3556    1       BLK$->FREE$HDR.NEXT$ = P$;

   3556  0 000024   200005 470500                    LDP0    BLK$,,AUTO
         0 000025   000001 756100                    STQ     1,,PR0

     3087     3557    1       BLK$->FREE$HDR.PREV$ = P$->FREE$HDR.PREV$;

   3557  0 000026   200006 471500                    LDP1    P$,,AUTO
         0 000027   100002 236100                    LDQ     2,,PR1
         0 000030   000002 756100                    STQ     2,,PR0

     3088     3558        /*D*
     3089     3559            If this block is contiguous with the next free block, merge that
     3090     3560            block into this one.
     3091     3561        */
     3092     3562    1       IF P$ ~= G$D.LASTFREE$ THEN

   3562  0 000031   200004 473500                    LDP3    @G$D,,AUTO
         0 000032   200006 236100                    LDQ     P$,,AUTO
         0 000033   300006 116100                    CMPQ    6,,PR3
         0 000034   000051 600000 0                  TZE     s:3576

     3093     3563    2       DO;
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:375  

     3094     3564    2           IF PINCRW(BLK$,BLK$->FREE$HDR.NWORDS) = P$ THEN

   3564  0 000035   000000 236100                    LDQ     0,,PR0
         0 000036   000022 736000                    QLS     18
         0 000037   200005 036100                    ADLQ    BLK$,,AUTO
         0 000040   200006 116100                    CMPQ    P$,,AUTO
         0 000041   000051 601000 0                  TNZ     s:3576

     3095     3565    3           DO;

     3096     3566    3               BLK$->FREE$HDR.PREV$ = P$->FREE$HDR.PREV$;

   3566  0 000042   100002 236100                    LDQ     2,,PR1
         0 000043   000002 756100                    STQ     2,,PR0

     3097     3567    3               BLK$->FREE$HDR.NEXT$ = P$->FREE$HDR.NEXT$;

   3567  0 000044   100001 236100                    LDQ     1,,PR1
         0 000045   000001 756100                    STQ     1,,PR0

     3098     3568    3               BLK$->FREE$HDR.NWORDS = BLK$->FREE$HDR.NWORDS

   3568  0 000046   000000 236100                    LDQ     0,,PR0
         0 000047   100000 036100                    ADLQ    0,,PR1
         0 000050   000000 756100                    STQ     0,,PR0

     3099     3569    3                 + P$->FREE$HDR.NWORDS;
     3100     3570    3           END;

     3101     3571    2       END;

     3102     3572        /*D*
     3103     3573            If this block is contiguous with the prior free block, merge this
     3104     3574            block into that one.
     3105     3575        */
     3106     3576    1       IF BLK$->FREE$HDR.PREV$ ~= G$D.FREEANCHOR$ THEN
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:376  

   3576  0 000051   000002 236100                    LDQ     2,,PR0
         0 000052   300005 116100                    CMPQ    5,,PR3
         0 000053   000075 600000 0                  TZE     s:3591

     3107     3577    2       DO;

     3108     3578    2           IF PINCRW(P$->FREE$HDR.PREV$,P$->FREE$HDR.PREV$->

   3578  0 000054   100002 474500                    LDP4    2,,PR1
         0 000055   400000 236100                    LDQ     0,,PR4
         0 000056   400000 635506                    EPPR5   0,QL,PR4
         0 000057   200010 455500                    STP5    P$+2,,AUTO
         0 000060   200010 236100                    LDQ     P$+2,,AUTO
         0 000061   200005 116100                    CMPQ    BLK$,,AUTO
         0 000062   000075 601000 0                  TNZ     s:3591

     3109     3579    2             FREE$HDR.NWORDS) = BLK$ THEN
     3110     3580    3           DO;

     3111     3581    3               P$ = P$->FREE$HDR.PREV$;

   3581  0 000063   100002 236100                    LDQ     2,,PR1
         0 000064   200006 756100                    STQ     P$,,AUTO

     3112     3582    3               P$->FREE$HDR.NWORDS = P$->FREE$HDR.NWORDS

   3582  0 000065   200006 471500                    LDP1    P$,,AUTO
         0 000066   100000 236100                    LDQ     0,,PR1
         0 000067   000000 036100                    ADLQ    0,,PR0
         0 000070   100000 756100                    STQ     0,,PR1

     3113     3583    3                 +BLK$->FREE$HDR.NWORDS;
     3114     3584    3               P$->FREE$HDR.NEXT$ = BLK$->FREE$HDR.NEXT$;

   3584  0 000071   000001 236100                    LDQ     1,,PR0
         0 000072   100001 756100                    STQ     1,,PR1
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:377  

     3115     3585    3               BLK$ = P$;

   3585  0 000073   200006 236100                    LDQ     P$,,AUTO
         0 000074   200005 756100                    STQ     BLK$,,AUTO

     3116     3586    3           END;

     3117     3587    2       END;

     3118     3588        /*D*
     3119     3589            Reset pointers to next and prior free blocks to reflect any merging we did.
     3120     3590        */
     3121     3591    1       BLK$->FREE$HDR.PREV$->FREE$HDR.NEXT$ = BLK$;

   3591  0 000075   200005 470500                    LDP0    BLK$,,AUTO
         0 000076   000002 474500                    LDP4    2,,PR0
         0 000077   200005 236100                    LDQ     BLK$,,AUTO
         0 000100   400001 756100                    STQ     1,,PR4

     3122     3592    1       BLK$->FREE$HDR.NEXT$->FREE$HDR.PREV$ = BLK$;

   3592  0 000101   000001 474500                    LDP4    1,,PR0
         0 000102   400002 756100                    STQ     2,,PR4

     3123     3593    1   END XUP$FREESPACE;

   3593  0 000103   000000 702200 xent               TSX2  ! X66_ARET
     3124     3594        %EOD;

PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:378  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$FREESPACE.
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:379  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @G$D                       3-0-0/w PTR         r     1 @INBLK$
     5-0-0/w PTR         r     1 BLK$                      *0-0-0/d STRC(5175)  r     1 G$D
    *0-0-0/w PTR         r     1 INBLK$                     6-0-0/w PTR         r     1 P$

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(108)   r     1 FREE$HDR


   Procedure XUP$FREESPACE requires 68 words for executable code.
   Procedure XUP$FREESPACE requires 10 words of local(AUTO) storage.
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:380  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=XUP$FREESPACE File=XUP$PARSE.:E05TSI                          WED 07/30/97 09:38 Page:381  
          MINI XREF LISTING

BLK$
      3325**DCL      3544<<ASSIGN   3550>>DOWHILE  3556>>ASSIGN   3557>>ASSIGN   3564>>IF       3564>>IF
      3566>>ASSIGN   3567>>ASSIGN   3568>>ASSIGN   3568>>ASSIGN   3576>>IF       3578>>IF       3582>>ASSIGN
      3584>>ASSIGN   3585<<ASSIGN   3591>>ASSIGN   3591>>ASSIGN   3592>>ASSIGN   3592>>ASSIGN
FREE$HDR.NEXT$
      3330**DCL      3549>>ASSIGN   3551>>ASSIGN   3556<<ASSIGN   3567<<ASSIGN   3567>>ASSIGN   3584<<ASSIGN
      3584>>ASSIGN   3591<<ASSIGN   3592>>ASSIGN
FREE$HDR.NWORDS
      3329**DCL      3564>>IF       3568<<ASSIGN   3568>>ASSIGN   3568>>ASSIGN   3578>>IF       3582<<ASSIGN
      3582>>ASSIGN   3582>>ASSIGN
FREE$HDR.PREV$
      3331**DCL      3557<<ASSIGN   3557>>ASSIGN   3566<<ASSIGN   3566>>ASSIGN   3576>>IF       3578>>IF
      3578>>IF       3581>>ASSIGN   3591>>ASSIGN   3592<<ASSIGN
G$D
      3235**DCL         6--PROC
G$D.FREEANCHOR$
      3253**DCL      3549>>ASSIGN   3576>>IF
G$D.LASTFREE$
      3257**DCL      3550>>DOWHILE  3562>>IF
G$D.LDCMNT.TX
      3305**DCL      3306--REDEF
G$D.SCRATCH
      3272**DCL      3275--REDEF
G$D.TRCMNT.TX
      3313**DCL      3314--REDEF
INBLK$
      3225**DCL         6--PROC     3543<<ASSIGN   3543>>ASSIGN   3544>>ASSIGN
P$
      3326**DCL      3549<<ASSIGN   3550>>DOWHILE  3550>>DOWHILE  3551<<ASSIGN   3551>>ASSIGN   3556>>ASSIGN
      3557>>ASSIGN   3562>>IF       3564>>IF       3566>>ASSIGN   3567>>ASSIGN   3568>>ASSIGN   3578>>IF
      3578>>IF       3581<<ASSIGN   3581>>ASSIGN   3582>>ASSIGN   3582>>ASSIGN   3584>>ASSIGN   3585>>ASSIGN

PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:382  
     3125        1        /*T***********************************************************/
     3126        2        /*T*                                                         */
     3127        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     3128        4        /*T*                                                         */
     3129        5        /*T***********************************************************/
     3130        6        XUP$FREEOUT:
     3131        7            PROC (BLK$,G$D);
     3132        8
     3133        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     3134       10        /*D*
     3135       11            NAME: XUP$FREEOUT
     3136       12            CALL:
     3137       13                CALL XUP$FREEOUT (BLK$, G$D);
     3138       14            PARAMETERS:
     3139       15                BLK$ -- pointer to the output block to be freed
     3140       16                G$D -- the parser global data structure
     3141       17            OUTPUT:
     3142       18                The entire output block subtree rooted in the specified block
     3143       19                has been freed.
     3144       20            INTERFACE:
     3145       21                XUP$FREEOUT (recursively)
     3146       22                XUP$FREESPACE
     3147       23            DESCRIPTION:
     3148       24                If the block passed is one that could have subblocks, first free
     3149       25                all subblocks by recursive calls.  Then, free the block itself.
     3150       26        */
     3151       27        %INCLUDE      XU_MACRO_C;
     3152     3133        %INCLUDE      XU_SUBS_C;
     3153     3225        /*
     3154     3226            ***       PARAMETERS
     3155     3227        */
     3156     3228    1   DCL       BLK$     PTR;     /* ADDR OF ROOT OUT$BLK TO FREE */
     3157     3229            %G$D;
     3158     3325        /*
     3159     3326            ***       LOCAL DATA
     3160     3327        */
     3161     3328    1   DCL       I        SBIN;
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:383  
     3162     3329        /*
     3163     3330            ***       EXTERNAL ENTRY DEFINITIONS
     3164     3331        */
     3165     3332    1   DCL       XUP$FREESPACE ENTRY(2);
     3166     3333
     3167     3334            %PARSE$OUT (STCLASS="BASED(BLK$)");
     3168     3379        %EJECT;
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:384  
     3169     3380        /*
     3170     3381        ***           BEGIN PROCEDURE
     3171     3382        */
     3172     3383    2       DO CASE (OUT$BLK.NDTYPE);
     3173     3384    2       CASE(%ALTERN#,
     3174     3385    2         %RALTERN#,
     3175     3386    2         %LIST#,
     3176     3387    2         %KONCAT#);
     3177     3388    3           DO I = OUT$BLK.NSUBLKS-1 DOWNTO 0;
     3178     3389    3               CALL XUP$FREEOUT (OUT$BLK.SUBLK$(I), G$D);
     3179     3390    3           END;
     3180     3391    2       END;
     3181     3392    1       CALL XUP$FREESPACE (BLK$, G$D);
     3182     3393    1   END XUP$FREEOUT;

PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:385  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$FREEOUT.

   Procedure XUP$FREEOUT requires 43 words for executable code.
   Procedure XUP$FREEOUT requires 8 words of local(AUTO) storage.

    No errors detected in file XUP$PARSE.:E05TSI    .

PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:386  

 Object Unit name= XUP$FREEOUT                                File name= XUP$PARSE.:E05TOU
 UTS= JUL 30 '97 09:38:53.00 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    43     53  XUP$FREEOUT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUP$FREEOUT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUP$FREESPACE
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:387  


     3125        1        /*T***********************************************************/
     3126        2        /*T*                                                         */
     3127        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     3128        4        /*T*                                                         */
     3129        5        /*T***********************************************************/
     3130        6        XUP$FREEOUT:
     3131        7            PROC (BLK$,G$D);

      7  0 000000   000000 700200 xent  XUP$FREEOUT  TSX0  ! X66_AUTO_2
         0 000001   000010 000002                    ZERO    8,2

     3132        8
     3133        9        /*X* DMC,PLM=4,IND=4,CTI=2,DTI=0,ENI=0,ECI=0,CSI=0,MCI,DCI=4 */
     3134       10        /*D*
     3135       11            NAME: XUP$FREEOUT
     3136       12            CALL:
     3137       13                CALL XUP$FREEOUT (BLK$, G$D);
     3138       14            PARAMETERS:
     3139       15                BLK$ -- pointer to the output block to be freed
     3140       16                G$D -- the parser global data structure
     3141       17            OUTPUT:
     3142       18                The entire output block subtree rooted in the specified block
     3143       19                has been freed.
     3144       20            INTERFACE:
     3145       21                XUP$FREEOUT (recursively)
     3146       22                XUP$FREESPACE
     3147       23            DESCRIPTION:
     3148       24                If the block passed is one that could have subblocks, first free
     3149       25                all subblocks by recursive calls.  Then, free the block itself.
     3150       26        */
     3151       27        %INCLUDE      XU_MACRO_C;
     3152     3133        %INCLUDE      XU_SUBS_C;
     3153     3225        /*
     3154     3226            ***       PARAMETERS
     3155     3227        */
     3156     3228    1   DCL       BLK$     PTR;     /* ADDR OF ROOT OUT$BLK TO FREE */
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:388  
     3157     3229            %G$D;
     3158     3325        /*
     3159     3326            ***       LOCAL DATA
     3160     3327        */
     3161     3328    1   DCL       I        SBIN;
     3162     3329        /*
     3163     3330            ***       EXTERNAL ENTRY DEFINITIONS
     3164     3331        */
     3165     3332    1   DCL       XUP$FREESPACE ENTRY(2);
     3166     3333
     3167     3334            %PARSE$OUT (STCLASS="BASED(BLK$)");
     3168     3379        %EJECT;
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:389  
     3169     3380        /*
     3170     3381        ***           BEGIN PROCEDURE
     3171     3382        */
     3172     3383    2       DO CASE (OUT$BLK.NDTYPE);

   3383  0 000002   200003 470500                    LDP0    @BLK$,,AUTO
         0 000003   000000 471500                    LDP1    0,,PR0
         0 000004   100000 220100                    LDX0    0,,PR1
         0 000005   000077 360003                    ANX0    63,DU
         0 000006   000011 100003                    CMPX0   9,DU
         0 000007   000011 602010 0                  TNC     s:3383+7,X0
         0 000010   000046 710000 0                  TRA     s:3392
         0 000011   000046 710000 0                  TRA     s:3392
         0 000012   000022 710000 0                  TRA     s:3388
         0 000013   000022 710000 0                  TRA     s:3388
         0 000014   000022 710000 0                  TRA     s:3388
         0 000015   000046 710000 0                  TRA     s:3392
         0 000016   000046 710000 0                  TRA     s:3392
         0 000017   000046 710000 0                  TRA     s:3392
         0 000020   000046 710000 0                  TRA     s:3392
         0 000021   000022 710000 0                  TRA     s:3388

     3173     3384    2       CASE(%ALTERN#,

     3174     3385    2         %RALTERN#,
     3175     3386    2         %LIST#,
     3176     3387    2         %KONCAT#);
     3177     3388    3           DO I = OUT$BLK.NSUBLKS-1 DOWNTO 0;

   3388  0 000022   100001 236100                    LDQ     1,,PR1
         0 000023   000022 772000                    QRL     18
         0 000024   000001 136007                    SBLQ    1,DL
         0 000025   200005 756100                    STQ     I,,AUTO
         0 000026   000044 710000 0                  TRA     s:3390+2

     3178     3389    3               CALL XUP$FREEOUT (OUT$BLK.SUBLK$(I), G$D);

PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:390  
   3389  0 000027   200003 470500                    LDP0    @BLK$,,AUTO
         0 000030   000000 471500                    LDP1    0,,PR0
         0 000031   200004 236100                    LDQ     @G$D,,AUTO
         0 000032   200007 756100                    STQ     I+2,,AUTO
         0 000033   200005 720100                    LXL0    I,,AUTO
         0 000034   100003 633510                    EPPR3   3,X0,PR1
         0 000035   200006 453500                    STP3    I+1,,AUTO
         0 000036   200006 630500                    EPPR0   I+1,,AUTO
         0 000037   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000040   000000 701000 0                  TSX1    s:7
         0 000041   000000 011000                    NOP     0

     3179     3390    3           END;

   3390  0 000042   000001 336007                    LCQ     1,DL
         0 000043   200005 056100                    ASQ     I,,AUTO
         0 000044   200005 235100                    LDA     I,,AUTO
         0 000045   000027 605000 0                  TPL     s:3389

     3180     3391    2       END;

     3181     3392    1       CALL XUP$FREESPACE (BLK$, G$D);

   3392  0 000046   200003 630500                    EPPR0   @BLK$,,AUTO
         0 000047   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000050   000000 701000 xent               TSX1    XUP$FREESPACE
         0 000051   000000 011000                    NOP     0

     3182     3393    1   END XUP$FREEOUT;

   3393  0 000052   000000 702200 xent               TSX2  ! X66_ARET

PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:391  
--  Include file information  --

   XU_SUBS_C.:E05TOU  is referenced.
   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUP$FREEOUT.
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:392  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @BLK$                      4-0-0/w PTR         r     1 @G$D
    *0-0-0/w PTR         r     1 BLK$                      *0-0-0/d STRC(5175)  r     1 G$D
     5-0-0/w SBIN        r     1 I

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 OUT$BLK


   Procedure XUP$FREEOUT requires 43 words for executable code.
   Procedure XUP$FREEOUT requires 8 words of local(AUTO) storage.

    No errors detected in file XUP$PARSE.:E05TSI    .
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:393  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #005=XUP$FREEOUT File=XUP$PARSE.:E05TSI                            WED 07/30/97 09:38 Page:394  
          MINI XREF LISTING

BLK$
      3228**DCL         6--PROC     3340--IMP-PTR  3383>>DOCASE   3388>>DOINDEX  3389>>CALL     3392<>CALL
G$D
      3238**DCL         6--PROC     3389<>CALL     3392<>CALL
G$D.LDCMNT.TX
      3308**DCL      3309--REDEF
G$D.SCRATCH
      3275**DCL      3278--REDEF
G$D.TRCMNT.TX
      3316**DCL      3317--REDEF
I
      3328**DCL      3388<<DOINDEX  3389>>CALL
OUT$BLK.NDTYPE
      3343**DCL      3383>>DOCASE
OUT$BLK.NSUBLKS
      3352**DCL      3388>>DOINDEX
OUT$BLK.SUBLK$
      3373**DCL      3389<>CALL
XUP$FREEOUT
         6**PROC     3389--CALL
XUP$FREESPACE
      3332**DCL-ENT  3392--CALL
