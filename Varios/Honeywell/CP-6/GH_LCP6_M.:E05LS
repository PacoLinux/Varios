

14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          1    
    1      /*M* GH_LCP6_M  System Architecture Macros.         */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100                */
    9
   10
   11                          /*P*   NAME: GH_LCP6_M.
   12
   13                          The file GH_LCP6_M contains the macro definitions
   14                          to be used to generate the structures
   15                          relating to the Level 6 architecture.
   16
   17                          As many of these structures are to be made
   18                          available to the user, this file is to be
   19                          included in the user system macro library.
   20                          */
   21
   22                          /*F* NAME: SYSTEM_PROGRAMMERS REFERENCE MANUAL
   23
   24                          The following services are available only to the
   25                          Honeywell supplied LCP-6 programs.
   26
   27                          */
   28
   29
   30
   31                          /*F*  NAME: System_Data
   32
   33                          The LCP_6 system macro library contains
   34                          macros that allow the systems
   35                          programmer to generate structures for the
   36                          elements relating to the hardware
   37                          at the most basic level.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          2    
   38                          Macros are also provided to generate the
   39                          structures used by LCP-6 software that include these
   40                          more basic elements.
   41
   42                          A description of each of these macros follows.
   43                          */
   44
   45
   46
   47
   48                          /*F*   NAME: G$ASDT
   49
   50                          The G$ASDT macro may be used to generate an array
   51                          of uninitialized segment descriptors.
   52                          */
   53
   54      %MACRO G$ASDT (FPTN=G$ASDT,
   55        NDESC=30,
   56        ALGN=WALIGNED,
   57        STCLASS=BASED);
   58
   59      %LSET LISTDIR='0'B;
   60      %LSET LISTEXP='1'B;
   61      %LSET LISTCOM='0'B;
   62      %LSET LISTSUB='1'B;
   63
   64      DCL 1 FPTN(0:NDESC) STCLASS ALGN ,
   65        %G$SEGDESC (FPTN=DESC,LVL=2,LAST=YES,STCLASS=STCLASS);
   66      %MEND;
   67
   68
   69
   70
   71
   72
   73
   74                          /*P*   NAME: G$ASDT_MON.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          3    
   75
   76                          The G$ASDT_MON macro may be used to generate a
   77                          structure defining the monitor's Address
   78                          Space Descriptor Table.
   79                          */
   80
   81
   82      %MACRO G$ASDT_MON (FPTN=G$ASDT_MON,
   83        LVL=1,
   84        LAST(YES=";",NO=",",ANY)=";",
   85        ALGN=WALIGNED,
   86        STCLASS=BASED);
   87
   88      %LSET LISTDIR='0'B;
   89      %LSET LISTEXP='1'B;
   90      %LSET LISTCOM='0'B;
   91      %LSET LISTSUB='1'B;
   92
   93      %IF LVL=1;
   94      DCL 1 FPTN STCLASS ALGN,
   95      %ELSE;
   96              %LVL FPTN,
   97      %ENDIF;
   98      %LSET ASDTM_NXT_LVL=LVL+1;
   99
  100                %G$SEGDESC (FPTN=NULLSEG,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  101                V=YES,SIZE=0,RP=G_RING0#,WP=G_RING0#,EP=G_RING0#);
  102      /* The Valid flag in NULLSEG is reset by GIBFOOT if not running a 9X CPU */
  103
  104              %G$SEGDESC (FPTN=ROS,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  105              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_RING0#);
  106
  107              %G$SEGDESC (FPTN=RDB_DS,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  108              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  109
  110              %G$SEGDESC (FPTN=LOW_MEM,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  111              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          4    
  112
  113              %G$SEGDESC (FPTN=TSTACKM,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  114              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  115
  116              %G$SEGDESC (FPTN=UMHJIT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  117              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  118
  119              %G$SEGDESC (FPTN=MHJIT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  120              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  121
  122              %G$SEGDESC (FPTN=MHJIT2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  123              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  124
  125              %G$SEGDESC (FPTN=MON_ENTRY_DATA,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  126              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  127
  128              %G$SEGDESC (FPTN=MON_ENTRY,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  129              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  130
  131              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  132
  133              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  134
  135              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  136
  137              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  138
  139              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  140
  141              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  142
  143              %G$SEGDESC (FPTN=MON_STATIC1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  144              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  145
  146              %G$SEGDESC (FPTN=MON_STATIC2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  147              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  148
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          5    
  149              %G$SEGDESC (FPTN=MON_PROC1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  150              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  151
  152              %G$SEGDESC (FPTN=MON_PROC2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  153              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  154
  155              %G$SEGDESC (FPTN=MON_PROC3,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  156              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  157
  158              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  159
  160              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  161
  162              %G$SEGDESC (FPTN=DB_PROC,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  163              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  164
  165              %G$SEGDESC (FPTN=WINDOW1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  166              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  167
  168
  169              %G$SEGDESC (FPTN=PPUT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  170              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  171
  172              %G$SEGDESC (FPTN=CBUFFER,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  173              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  174
  175              %G$SEGDESC (FPTN=BOBCAT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  176              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  177
  178              %G$SEGDESC (FPTN=HAND_Q,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  179              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  180
  181              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  182              %G$SEGDESC (FPTN=BIGFOOT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=LAST,
  183              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_R_MON#);
  184      %MEND;
  185
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          6    
  186
  187
  188
  189
  190
  191                          /*P*   NAME: G$ASDT_MCL.
  192
  193                          The G$ASDT_MCL macro may be used to generate a
  194                          structure defining the Address Space Descriptor
  195                          to be used by the monitor for MCL processing.
  196                          */
  197
  198
  199      %MACRO G$ASDT_MCL (FPTN=G$ASDT_MCL,
  200        LVL=1,
  201        LAST(YES=";",NO=",",ANY)=";",
  202        ALGN=WALIGNED,
  203        STCLASS=BASED);
  204
  205      %LSET LISTDIR='0'B;
  206      %LSET LISTEXP='1'B;
  207      %LSET LISTCOM='0'B;
  208      %LSET LISTSUB='1'B;
  209
  210      %IF LVL=1;
  211      DCL 1 FPTN STCLASS ALGN,
  212      %ELSE;
  213              %LVL FPTN,
  214      %ENDIF;
  215      %LSET ASDTM_NXT_LVL=LVL+1;
  216
  217                %G$SEGDESC (FPTN=NULLSEG,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  218                V=YES,SIZE=0,RP=G_RING0#,WP=G_RING0#,EP=G_RING0#);
  219      /* The Valid flag in NULLSEG is reset by GIBFOOT if not running a 9X CPU */
  220
  221              %G$SEGDESC (FPTN=ROS,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  222              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_RING0#);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          7    
  223
  224              %G$SEGDESC (FPTN=RDB_DS,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  225              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  226
  227              %G$SEGDESC (FPTN=LOW_MEM,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  228              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  229
  230              %G$SEGDESC (FPTN=TSTACKU,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  231              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  232
  233              %G$SEGDESC (FPTN=UHJIT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  234              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  235
  236              %G$SEGDESC (FPTN=MHJIT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  237              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  238
  239              %G$SEGDESC (FPTN=MHJIT2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  240              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  241
  242              %G$SEGDESC (FPTN=MON_ENTRY_DATA,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  243              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  244
  245              %G$SEGDESC (FPTN=MON_ENTRY,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  246              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  247
  248              %G$SEGDESC (FPTN=LPAR1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  249              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  250
  251              %G$SEGDESC (FPTN=LPAR2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  252              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  253
  254              %G$SEGDESC (FPTN=LPAR3,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  255              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  256
  257              %G$SEGDESC (FPTN=LPAR4,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  258              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  259
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          8    
  260              %G$SEGDESC (FPTN=LPAR5,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  261              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  262
  263              %G$SEGDESC (FPTN=LPAR6,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  264              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  265
  266              %G$SEGDESC (FPTN=MON_STATIC1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  267              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  268
  269              %G$SEGDESC (FPTN=MON_STATIC2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  270              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  271
  272              %G$SEGDESC (FPTN=MON_PROC1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  273              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  274
  275              %G$SEGDESC (FPTN=MON_PROC2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  276              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  277
  278              %G$SEGDESC (FPTN=MON_PROC3,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  279              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  280
  281              %G$SEGDESC (FPTN=BPAR1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  282              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  283
  284              %G$SEGDESC (FPTN=BPAR2,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  285              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  286
  287              %G$SEGDESC (FPTN=DB_PROC,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  288              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  289
  290              %G$SEGDESC (FPTN=WINDOW1,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  291              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  292
  293
  294              %G$SEGDESC (FPTN=PPUT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  295              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  296
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          9    
  297              %G$SEGDESC (FPTN=CBUFFER,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  298              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  299
  300              %G$SEGDESC (FPTN=BOBCAT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  301              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  302
  303              %G$SEGDESC (FPTN=HAND_Q,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,
  304              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  305
  306              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=NO,V=NO);
  307              %G$SEGDESC (FPTN=BIGFOOT,STCLASS=STCLASS,LVL=ASDTM_NXT_LVL,LAST=LAST,
  308              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_R_MON#);
  309      %MEND;
  310
  311                          /*F*   NAME: G$ASDT_USR
  312
  313                          The G$ASDT_USR macro may be used to generate a
  314                          structure defining the user's Address
  315                          Space Descriptor Table.
  316                          */
  317
  318
  319      %MACRO G$ASDT_USR (FPTN=G$ASDT_USR,
  320        LVL=1,
  321        LAST(YES=";",NO=",",ANY)=";",
  322        ALGN=WALIGNED,
  323        STCLASS=BASED);
  324
  325      %LSET LISTDIR='0'B;
  326      %LSET LISTEXP='1'B;
  327      %LSET LISTCOM='0'B;
  328      %LSET LISTSUB='1'B;
  329
  330      %IF LVL=1;
  331      DCL 1 FPTN STCLASS ALGN,
  332      %ELSE;
  333              %LVL FPTN,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          10   
  334      %ENDIF;
  335      %LSET ASDTU_NXT_LVL=LVL+1;
  336
  337                %G$SEGDESC (FPTN=NULLSEG,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  338                V=YES,SIZE=0,RP=G_RING0#,WP=G_RING0#,EP=G_RING0#);
  339      /* The Valid flag in NULLSEG is reset by GIBFOOT if not running a 9X CPU */
  340
  341              %G$SEGDESC (FPTN=ROS,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  342              V=YES,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_RING0#);
  343
  344              %G$SEGDESC (FPTN=DB_DS,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  345              V=NO,SIZE=0,RP=G_R_CPDB#,WP=G_R_CPDB#,EP=G_RING0#);
  346
  347              %G$SEGDESC (FPTN=LOW_MEM,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  348              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  349
  350              %G$SEGDESC (FPTN=TSTACKU,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  351              V=YES,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  352
  353              %G$SEGDESC (FPTN=UHJIT,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  354              V=YES,SIZE=0,RP=G_R_CPDB#,WP=G_R_CPDB#,EP=G_RING0#);
  355
  356              %G$SEGDESC (FPTN=MHJIT,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  357              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  358
  359              %G$SEGDESC (FPTN=MHJIT2,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  360              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  361
  362              %G$SEGDESC (FPTN=MON_ENTRY_DATA,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  363              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  364
  365              %G$SEGDESC (FPTN=MON_ENTRY,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  366              V=NO,SIZE=0,RP=G_R_MON#,WP=G_RING0#,EP=G_R_MON#);
  367
  368              %G$SEGDESC (FPTN=USR_DS1,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  369              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  370
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          11   
  371              %G$SEGDESC (FPTN=USR_DS2,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  372              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  373
  374              %G$SEGDESC (FPTN=CP_DS,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  375              V=NO,SIZE=0,RP=G_R_CPDB#,WP=G_R_CPDB#,EP=G_RING0#);
  376
  377              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,V=NO);
  378
  379              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,V=NO);
  380
  381              %G$SEGDESC (FPTN=*,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,V=NO);
  382
  383              %G$SEGDESC (FPTN=ISR1,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  384              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  385
  386              %G$SEGDESC (FPTN=ISR2,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  387              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  388
  389              %G$SEGDESC (FPTN=ISR3,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  390              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_CPDB#,EP=G_R_USR#);
  391
  392              %G$SEGDESC (FPTN=ISR4,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  393              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_CPDB#,EP=G_R_USR#);
  394
  395              %G$SEGDESC (FPTN=ISR5,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  396              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_CPDB#,EP=G_R_USR#);
  397
  398              %G$SEGDESC (FPTN=ISR6,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  399              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_R_USR#);
  400
  401              %G$SEGDESC (FPTN=ISR7,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  402              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_R_USR#);
  403
  404              %G$SEGDESC (FPTN=DB_PROC,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  405              V=NO,SIZE=0,RP=G_R_CPDB#,WP=G_R_MON#,EP=G_R_CPDB#);
  406
  407              %G$SEGDESC (FPTN=CP_PROC,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          12   
  408              V=NO,SIZE=0,RP=G_R_CPDB#,WP=G_R_MON#,EP=G_R_CPDB#);
  409
  410              %G$SEGDESC (FPTN=UAUTO_DS,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  411              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  412
  413              %G$SEGDESC (FPTN=USR_DS3,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  414              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  415
  416              %G$SEGDESC (FPTN=USR_DS4,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  417              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_USR#,EP=G_RING0#);
  418
  419
  420              %G$SEGDESC (FPTN=HAND_Q,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  421              V=NO,SIZE=0,RP=G_R_MON#,WP=G_R_MON#,EP=G_RING0#);
  422
  423              %G$SEGDESC (FPTN=LIBIS1,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=NO,
  424              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_R_USR#);
  425              %G$SEGDESC (FPTN=LIBIS2,STCLASS=STCLASS,LVL=ASDTU_NXT_LVL,LAST=LAST,
  426              V=NO,SIZE=0,RP=G_R_USR#,WP=G_R_MON#,EP=G_R_USR#);
  427      %MEND;
  428
  429
  430
  431
  432
  433
  434                          /*F*   NAME: G$CI_REG.
  435
  436                          The G$CI_REG macro may be used to generate
  437                          a structure that contains the Commercial
  438                          Instruction Processor Indicator Register.
  439
  440                          The fields of the CIP Indicator Register are:
  441                          */
  442
  443      %MACRO G$CI_REG (FPTN=G$CI_REG,
  444        OV(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          13   
  445        TR(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  446        SF(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  447        G(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  448        L(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  449        QLT(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  450        LVL=1,
  451        LAST(YES=";",NO=",",ANY)=";",
  452        ALGN=WALIGNED,
  453        STCLASS=BASED);
  454
  455      %LSET LISTDIR='0'B;
  456      %LSET LISTEXP='1'B;
  457      %LSET LISTCOM='0'B;
  458      %LSET LISTSUB='1'B;
  459
  460      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  461      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  462      %LSET INIT=CHARTEXT(' INIT');
  463      %LSET EINIT=CHARTEXT('');
  464      %ELSE;
  465      %LSET INIT=CHARTEXT('/*');
  466      %LSET EINIT=CHARTEXT('*/');
  467      %ENDIF;
  468
  469      %IF LVL=1;
  470      DCL 1 FPTN STCLASS ALGN,
  471      %ELSE;
  472              %LVL FPTN,
  473      %ENDIF;
  474                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
  475                %(LVL+1) %CHARTEXT('OV BIT(1)') %INIT(OV)%EINIT,
  476                          /*K* OV = VALUE-BIT(1)
  477                          if set, indicates that an
  478                          overflow occurred during a decimal instruction.
  479                          .XEQ
  480
  481                          When generating a STATIC or CONSTANT structure, this
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          14   
  482                          field may be initialized by specifying G={G_ON# | G_OFF#}.
  483                          Default = G_OFF#.
  484                          */
  485                %(LVL+1) %CHARTEXT('TR BIT(1)') %INIT(TR)%EINIT,
  486                          /*K* TR = VALUE-BIT(1)
  487                          if set, indicates that the
  488                          alphanumeric result was truncated.
  489                          .XEQ
  490
  491                          When generating a STATIC or CONSTANT structure, this
  492                          field may be initialized by specifying G={G_ON# | G_OFF#}.
  493                          Default = G_OFF#.
  494                          */
  495                %(LVL+1) %CHARTEXT('SF BIT(1)') %INIT(SF)%EINIT,
  496                          /*K* SF = VALUE-BIT(1)
  497                          if set, indicates that a
  498                          sign fault occurred (negative operand is stored in
  499                          unsigned field).
  500                          .XEQ
  501
  502                          When generating a STATIC or CONSTANT structure, this
  503                          field may be initialized by specifying L={G_ON# | G_OFF#}.
  504                          Default = G_OFF#.
  505                          */
  506                %(LVL+1) * BIT(2) %INIT('0'B)%EINIT,
  507                %(LVL+1) %CHARTEXT('G BIT(1)') %INIT(G)%EINIT,
  508                          /*K* G = VALUE-BIT(1)
  509                          is the Greater-than Indicator that
  510                          contains the results of the last compare instruction
  511                          executed by the computer.
  512                          .XEQ
  513
  514                          When generating a STATIC or CONSTANT structure, this
  515                          field may be initialized by specifying G={G_ON# | G_OFF#}.
  516                          Default = G_OFF#.
  517                          */
  518                %(LVL+1) %CHARTEXT('L BIT(1)') %INIT(L)%EINIT,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          15   
  519                          /*K* L = VALUE-BIT(1)
  520                          is the Less-than Indicator that
  521                          contains the results of the last compare instruction
  522                          executed by the computer.
  523                          .XEQ
  524
  525                          When generating a STATIC or CONSTANT structure, this
  526                          field may be initialized by specifying L={G_ON# | G_OFF#}.
  527                          Default = G_OFF#.
  528                          */
  529                %(LVL+1) %CHARTEXT('QLT BIT(1)') %INIT(QLT)%EINIT LAST
  530                          /*K* QLT = VALUE-BIT(1)
  531                               indicates whether the CIP has successfully
  532                               completed its Quality Logic Test or not:
  533
  534                              }    0 = QLT successfully completed.
  535                              }    1 = QLT either still running or failed
  536
  537                          .XEQ
  538
  539                          Default='0'B.
  540                          */
  541      %MEND;
  542
  543
  544
  545
  546
  547                          /*F*   NAME: G$DEV
  548
  549                          The G$DEV macro may be used to generate
  550                          a structure for the Device word that
  551                          is stored in the Interrupt Save Area.
  552
  553                          The fields within DEV are:
  554                          */
  555
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          16   
  556      %MACRO G$DEV (FPTN=G$DEV,
  557        CHN=0,
  558        IL=0,
  559        LVL=1,
  560        LAST(YES=";",NO=",",ANY)=";",
  561        ALGN=WALIGNED,
  562        STCLASS=BASED);
  563
  564      %LSET LISTDIR='0'B;
  565      %LSET LISTEXP='1'B;
  566      %LSET LISTCOM='0'B;
  567      %LSET LISTSUB='1'B;
  568
  569      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  570      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  571      %LSET INIT=CHARTEXT(' INIT');
  572      %LSET EINIT=CHARTEXT('');
  573      %ELSE;
  574      %LSET INIT=CHARTEXT('/*');
  575      %LSET EINIT=CHARTEXT('*/');
  576      %ENDIF;
  577
  578      %IF LVL=1;
  579      DCL 1 FPTN STCLASS ALGN,
  580      %ELSE;
  581              %LVL FPTN,
  582      %ENDIF;
  583                %(LVL+1) %CHARTEXT('CHN UBIN(10)UNAL') %INIT(CHN)%EINIT,
  584                          /*K* CHN - UBIN(10)
  585                          contains the interrupting channel.
  586                          .XEQ
  587                          The default is 0.
  588                          */
  589                %(LVL+1) %CHARTEXT('IL UBIN(6)UNAL') %INIT(IL)%EINIT LAST
  590                          /*K* IL - UBIN(6)
  591                          contains the Interrupting Level number.
  592                          .XEQ
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          17   
  593                          The default is 0.
  594                          */
  595      %MEND;
  596
  597
  598
  599
  600
  601
  602                          /*F*   NAME: G$INDICATOR_REG
  603
  604                          The G$INDICATOR_REG macro may be used to generate
  605                          a structure that contains the Indicator Register.
  606
  607                          The fields of the Indicator Register are:
  608                          */
  609
  610      %MACRO G$INDICATOR_REG (FPTN=G$INDICATOR_REG,
  611        TRAP#=0,
  612        OV(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  613        C(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  614        B(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  615        IO(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  616        G(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  617        L(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  618        U(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
  619        LVL=1,
  620        LAST(YES=";",NO=",",ANY)=";",
  621        ALGN=WALIGNED,
  622        STCLASS=BASED);
  623
  624      %LSET LISTDIR='0'B;
  625      %LSET LISTEXP='1'B;
  626      %LSET LISTCOM='0'B;
  627      %LSET LISTSUB='1'B;
  628
  629      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          18   
  630      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  631      %LSET INIT=CHARTEXT(' INIT');
  632      %LSET EINIT=CHARTEXT('');
  633      %ELSE;
  634      %LSET INIT=CHARTEXT('/*');
  635      %LSET EINIT=CHARTEXT('*/');
  636      %ENDIF;
  637
  638      %IF LVL=1;
  639      DCL 1 FPTN STCLASS ALGN,
  640      %ELSE;
  641              %LVL FPTN,
  642      %ENDIF;
  643                %(LVL+1) %CHARTEXT('TRAP# UBIN(8)UNAL') %INIT(TRAP#)%EINIT,
  644                          /*K* TRAP# = VALUE-UBIN(8)
  645                          contains the trap number
  646                          associated with the trap.  The hardware stores the
  647                          trap number as '40'X - Trap Vector#.  This number
  648                          is then converted to the Trap Vector# by the software.
  649                          The following EQUs may be used to determine the
  650                          type of trap:
  651                          .fif
  652
  653                          %G_MCL#             MCL
  654                          %G_TRACE#           Trace Breakpoint Trap
  655                          %G_NO_SIP#          Uninstalled SIP Trap
  656                          %G_TROT#            Watch Dog Timer Runout
  657                          %G_UNIMPL#          Unimplemented Instruction Trap
  658                          %G_INT_REG_OV#      Integer Register Overflow Trap
  659                          %G_S_DBZ#           SIP Divide by Zero Trap
  660                          %G_S_EXP_OV#        SIP Exponent Overflow Trap
  661                          %G_STK_UF#          Stack Underflow Trap
  662                          %G_STK_OV#          Stack Overflow Trap
  663                          %G_REMOTE_DESC#     Remote Data Descriptor Trap
  664                          %G_PRIV#            Privilege Violation Trap
  665                          %G_MEM_PROT#        Memory Protection Trap
  666                          %G_INT_UR#          Internal Unavailable Resource Trap
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          19   
  667                          %G_PROG_ERR#        Program Error Trap
  668                          %G_INT_MBE#         Internal Memory or Bus Error Trap
  669                          %G_S_EXP_UF#        SIP Exponent Underflow Trap
  670                          %G_S_PROG_ERR#      SIP Program Error Trap
  671                          %G_S_SIGNIF#        SIP Significance Error Trap
  672                          %G_S_PRECISION#     SIP Precision Error Trap
  673                          %G_EXT_UR#          External (CIP or SIP) Unavailable Resource
  674                          %G_EXT_MBE#         External (CIP or SIP) Memory or Bus
  675                          %G_C_DBZ#           CIP Divide by Zero Trap
  676                          %G_C_SPEC#          CIP Illegal Specification Trap
  677                          %G_C_CHAR#          CIP Illegal Character Trap
  678                          %G_C_TRUNC#         CIP Truncation Trap
  679                          %G_C_OV#            CIP Overflow Trap
  680                          %G_CIP_QLT#         CIP QLT Fault
  681                          %G_SIP_QLT#         SIP QLT Fault
  682                          %G_EXT_PROT#        CIP or SIP Memory Protect Trap
  683                          %G_S_ARG#           SIP Illegal Argument Trap
  684                          .fin
  685                          .XEQ
  686
  687
  688                          This field is undefined in the Indicator Register as
  689                          stored in the Interrupt Save Area.
  690
  691                          When generating a STATIC or CONSTANT structure, this
  692                          field may be initialized by specifying TRAP#=value.
  693                          Default = 0.
  694                          */
  695                %(LVL+1) %CHARTEXT('OV BIT(1)') %INIT(OV)%EINIT,
  696                          /*K* OV = VALUE-BIT(1)
  697                          is the overflow indicator that
  698                          is set when any of the seven general registers
  699                          overflows its "arithmetic" capacity.
  700                          .XEQ
  701
  702                          When generating a STATIC or CONSTANT structure, this
  703                          field may be initialized by specifying OV={G_ON# | G_OFF#}.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          20   
  704                          Default = G_OFF#.
  705                          */
  706                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
  707                %(LVL+1) %CHARTEXT('C BIT(1)') %INIT(C)%EINIT,
  708                          /*K* C = VALUE-BIT(1)
  709                          is the carry indicator that is
  710                          set when the "logical" capacity of any of the
  711                          seven general registers is exceeded.
  712                          .XEQ
  713
  714                          When generating a STATIC or CONSTANT structure, this
  715                          field may be initialized by specifying C={G_ON# | G_OFF#}.
  716                          Default = G_OFF#.
  717                          */
  718                %(LVL+1) %CHARTEXT('B BIT(1)') %INIT(B)%EINIT,
  719                          /*K* B = VALUE-BIT(1)
  720                          may be considered to be
  721                          a one-bit register loaded by load bit instructions.
  722                          .XEQ
  723
  724                          When generating a STATIC or CONSTANT structure, this
  725                          field may be initialized by specifying B={G_ON# | G_OFF#}.
  726                          Default = G_OFF#.
  727                          */
  728                %(LVL+1) %CHARTEXT('IO BIT(1)') %INIT(IO)%EINIT,
  729                          /*K* IO = VALUE-BIT(1)
  730                          is the Input/Output Indicator that is
  731                          set if the last I/O operation was successful.
  732                          .XEQ
  733
  734                          When generating a STATIC or CONSTANT structure, this
  735                          field may be initialized by specifying IO={G_ON# | G_OFF#}.
  736                          Default = G_OFF#.
  737                          */
  738                %(LVL+1) %CHARTEXT('G BIT(1)') %INIT(G)%EINIT,
  739                          /*K* G = VALUE-BIT(1)
  740                          is the Greater-than Indicator that
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          21   
  741                          contains the results of the last compare instruction
  742                          executed by the computer.
  743                          .XEQ
  744
  745                          When generating a STATIC or CONSTANT structure, this
  746                          field may be initialized by specifying G={G_ON# | G_OFF#}.
  747                          Default = G_OFF#.
  748                          */
  749                %(LVL+1) %CHARTEXT('L BIT(1)') %INIT(L)%EINIT,
  750                          /*K* L = VALUE-BIT(1)
  751                          is the Less-than Indicator that
  752                          contains the results of the last compare instruction
  753                          executed by the computer.
  754                          .XEQ
  755
  756                          When generating a STATIC or CONSTANT structure, this
  757                          field may be initialized by specifying L={G_ON# | G_OFF#}.
  758                          Default = G_OFF#.
  759                          */
  760                %(LVL+1) %CHARTEXT('U BIT(1)') %INIT(U)%EINIT LAST
  761                          /*K* U = VALUE-BIT(1)
  762                          is the Unlike-sign Indicator that
  763                          contains the results of the last compare instruction
  764                          executed by the computer.
  765                          .XEQ
  766
  767                          When generating a STATIC or CONSTANT structure, this
  768                          field may be initialized by specifying U={G_ON# | G_OFF#}.
  769                          Default = G_OFF#.
  770                          */
  771      %MEND;
  772
  773
  774
  775
  776
  777
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          22   
  778                          /*F*   NAME: G$INTERRUPT_VECTOR.
  779
  780                          The G$INTERRUPT_VECTOR macro may be used to generate
  781                          The Interrupt Vector.
  782
  783                          The following labels may be used to address
  784                          individual pointers within the Interrupt Vector:
  785                          */
  786
  787      %MACRO G$INTERRUPT_VECTOR (FPTN=G$INTERRUPT_VECTOR,
  788        LVL=1,
  789        LAST(YES=";",NO=",",ANY)=";",
  790        ALGN=WALIGNED,
  791        STCLASS=BASED);
  792
  793      %LSET LISTDIR='0'B;
  794      %LSET LISTEXP='1'B;
  795      %LSET LISTCOM='0'B;
  796      %LSET LISTSUB='1'B;
  797
  798      %IF LVL=1;
  799      DCL 1 FPTN STCLASS ALGN,
  800      %ELSE;
  801              %LVL FPTN,
  802      %ENDIF;
  803                %(LVL+1) IL$(0:63) PTR,
  804                          /*K* IL$ = ARRAY(0:63) PTR contains the pointer to
  805                          the Interrupt Save Area for each of the interrupts 0-63.
  806                          This array is REDEFed as INT with the following subfields:
  807                          */
  808                %(LVL+1) INT REDEF IL$,
  809                %(LVL+2) I#00$ PTR,
  810                %(LVL+2) PFS$ REDEF I#00$ PTR,
  811                          /*K* INT.PFS$ = PTR contains the address of the LCP-6
  812                          Power Failure Interrupt ISA - Interrupt Vector 0.
  813                          */
  814                %(LVL+2) I#01$ PTR,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          23   
  815                %(LVL+2) WDOG$ REDEF I#01$ PTR,
  816                          /*K* INT.WDOG$ = PTR contains the address of the LCP-6
  817                          Watchdog Timer Runout ISA - Interrupt Vector 1.
  818                          */
  819                %(LVL+2) I#02$ PTR,
  820                %(LVL+2) TSA_OV$ REDEF I#02$ PTR,
  821                          /*K* INT.TSA_OV$ = PTR contains the address of the LCP-6
  822                          Trap Save Area Overflow ISA - Interrupt Vector 2.
  823                          */
  824                %(LVL+2) I#03$ PTR,
  825                %(LVL+2) BIGFOOT$ REDEF I#03$ PTR,
  826                          /*K* INT.BIGFOOT$ = PTR is reserved for
  827                          BIGFOOT - Interrupt Vector 3.
  828                          */
  829                %(LVL+2) I#04$ PTR,
  830                %(LVL+2) INHIBIT$ REDEF I#04$ PTR,
  831                %(LVL+2) I#05$ PTR,
  832                %(LVL+2) INHIBIT1$ REDEF I#05$ PTR,
  833                          /*K* INT.INHIBIT$ = PTR is reserved for the LCP-6
  834                          inhibit level - Interrupt Vectors 4 and 5.
  835                          */
  836                %(LVL+2) HANDLER$(0:54) PTR,
  837                          /*K* INT.HANDLER$ = ARRAY(0:54) PTR contains the address
  838                          of the ISA for each interrupt connected to a handler by
  839                          a user - Interrupt Vectors 6 -> 60.
  840                          */
  841                %(LVL+2) I#61$ PTR,
  842                %(LVL+2) RT_CLOCK$ REDEF I#61$ PTR,
  843                          /*K* INT.RT_CLOCK$ = PTR contains the address of the LCP-6
  844                          Real-time Clock Handler ISA - Interrupt Vector 61.
  845                          */
  846                %(LVL+2) I#62$ PTR,
  847                %(LVL+2) SCHD$ REDEF I#62$ PTR,
  848                          /*K* INT.SCHD$ = PTR contains the address of the LCP-6
  849                          Scheduler Interrupt Handler ISA - Interrupt Vector 62.
  850                          */
  851                %(LVL+2) I#63$ PTR,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          24   
  852                %(LVL+2) USER$ REDEF I#63$ PTR LAST
  853                          /*K* INT.USER$ = PTR contains the address of the current
  854                          user's ISA - Interrupt Vector 63.
  855                          */
  856      %MEND;
  857
  858
  859
  860
  861
  862
  863
  864                          /*F*   NAME: G$ISA
  865
  866                          The G$ISA macro may be used to generate
  867                          a structure that defines the entire
  868                          Interrupt Save Area.
  869
  870                          */
  871                                    /*
  872                                    The G$ISA_HDR macro is invoked using
  873                                    the name specified via the FPTN parameter
  874                                    which will determine the name of the
  875                                    structure.  This is followed by the
  876                                    following fields:
  877                                    */
  878
  879      %MACRO G$ISA (FPTN=G$ISA,
  880        SAVE_SIP(YES=1,NO=0,ANY)=0,
  881        ASV$=NIL,MMU(YES='1'B,NO='0'B)='1'B,
  882        NATSAP_SEL(G_NATSAP_MON#=0,G_NATSAP_HND#=2,G_NATSAP_USR#=1,ANY)=0,
  883        RING(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B,ANY)='00'B,
  884        P$$=NIL,
  885       P=0,
  886        LVL=1,
  887        LAST(YES=";",NO=",",ANY)=";",
  888        ALGN=WALIGNED,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          25   
  889        STCLASS=BASED);
  890
  891      %LSET LISTDIR='0'B;
  892      %LSET LISTEXP='1'B;
  893      %LSET LISTCOM='0'B;
  894      %LSET LISTSUB='1'B;
  895
  896      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  897      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  898      %LSET INIT=CHARTEXT(' INIT');
  899      %LSET EINIT=CHARTEXT('');
  900      %ELSE;
  901      %LSET INIT=CHARTEXT('/*');
  902      %LSET EINIT=CHARTEXT('*/');
  903      %ENDIF;
  904
  905                %G$ISA_HDR (FPTN=FPTN,ASV$=ASV$,LVL=LVL,STCLASS=STCLASS,LAST=",");
  906
  907      %LSET ISA_NXT_LVL=LVL+1;
  908
  909              %G$DEV (FPTN=DEV,STCLASS=STCLASS,LVL=ISA_NXT_LVL,LAST=",");
  910                          /*K*  DEV - BIT(16)
  911                          contains the contents of the Device word
  912                          stored by the hardware:
  913                          */
  914                          /*K* DEV.CHN - UBIN(10)
  915                          .XEQ GH_LCP6_M G$DEV CHN
  916                          */
  917                          /*K* DEV.IL - UBIN(6)
  918                          .XEQ GH_LCP6_M G$DEV IL
  919                          */
  920              %G$ISM1 (FPTN=ISM1,STCLASS=STCLASS,LVL=ISA_NXT_LVL,LAST=",");
  921                          /*K* ISM1 - BIT(16) contains the Interrupt Save
  922                          Mask 1.  See G$ISM1 for the names and meanings of
  923                          the bits within this word.
  924                          */
  925              %G$ISM2 (FPTN=ISM2,STCLASS=STCLASS,LVL=ISA_NXT_LVL,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          26   
  926              NATSAP_SEL=NATSAP_SEL, MMU=MMU, LAST=NO);
  927                          /*K* ISM2 - BIT(16) contains the Interrupt Save
  928                          Mask 2.  See G$ISM2 for the names and meanings of
  929                          the bits within this word.
  930                          */
  931      %IF P=0;
  932              %(LVL+1) %CHARTEXT('P$$ EPTR') %INIT(ENTADDR(P$$)*0)%EINIT,
  933              %(LVL+1) P$ REDEF %CHARTEXT('P$$ PTR'),
  934      %ELSE;
  935              %(LVL+1) %CHARTEXT('P UBIN(32)') %INIT(P*0)%EINIT,
  936              %(LVL+1) %CHARTEXT('P$$') REDEF %CHARTEXT('P EPTR'),
  937              %(LVL+1) %CHARTEXT('P$') REDEF %CHARTEXT('P PTR'),
  938      %ENDIF;
  939                          /*K*   P$$ - EPTR contains the contents of the Program
  940                          Counter at the time of the interrupt.
  941                          This field is REDEFed as P$ PTR.
  942                          */
  943      %G$STATUS_REG (FPTN=S,RING=RING,STCLASS=STCLASS,LVL=ISA_NXT_LVL,LAST=",");
  944                          /*K* S - BIT(16) contains the contents of the
  945                          Status Register at the time of the interrupt:
  946                          */
  947                          /*K* S.QLT - BIT(1)
  948                          .XEQ GH_LCP6_M G$STATUS_REG QLT
  949                          */
  950                          /*K* S.RING - BIT(2)
  951                          .XEQ GH_LCP6_M G$STATUS_REG RING
  952                          */
  953                          /*K* S.ID - BIT(2)
  954                          .XEQ GH_LCP6_M G$STATUS_REG ID
  955                          */
  956                          /*K* S.LEVEL - UBIN(6)
  957                          .XEQ GH_LCP6_M G$STATUS_REG LEVEL
  958                          */
  959              %VLP_REGISTERS (FPTN=REGS,STCLASS=STCLASS,LVL=ISA_NXT_LVL,
  960              SAVE_SIP=SAVE_SIP,LAST=LAST);
  961                          /*K* REGS -
  962                          contains the contents of the hardware registers at
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          27   
  963                          the time of the interrupt.
  964                          Note that the bit settings within
  965                          ISM1 and ISM2 determine the the contents of REGS.
  966                          */
  967                          /*K* REGS.Bn$ - PTR
  968                          (where n = 1-7)
  969                          contains the contents of the base registers.
  970                          */
  971                          /*K* REGS.I - BIT(16)
  972                          is an 8 bit indicator register that contains the overflow
  973                          and program status indicators:
  974                          */
  975                          /*K* REGS.I.TRAP# - UBIN(8)
  976                          .XEQ GH_LCP6_M G$INDICATOR_REG TRAP#
  977                          */
  978                          /*K* REGS.I.OV - BIT(1)
  979                          .XEQ GH_LCP6_M G$INDICATOR_REG OV
  980                          */
  981                          /*K* REGS.I.C - BIT(1)
  982                          .XEQ GH_LCP6_M G$INDICATOR_REG C
  983                          */
  984                          /*K* REGS.I.B - BIT(1)
  985                          .XEQ GH_LCP6_M G$INDICATOR_REG B
  986                          */
  987                          /*K* REGS.I.IO - BIT(1)
  988                          .XEQ GH_LCP6_M G$INDICATOR_REG IO
  989                          */
  990                          /*K* REGS.I.G - BIT(1)
  991                          .XEQ GH_LCP6_M G$INDICATOR_REG G
  992                          */
  993                          /*K* REGS.I.L - BIT(1)
  994                          .XEQ GH_LCP6_M G$INDICATOR_REG L
  995                          */
  996                          /*K* REGS.I.U - BIT(1)
  997                          .XEQ GH_LCP6_M G$INDICATOR_REG U
  998                          */
  999                          /*K* REGS.Rn - UBIN WORD
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          28   
 1000                          (where n = 1-7)
 1001                          contains the contents of the 16 bit general registers.
 1002                          */
 1003                          /*K* REGS.M1 -
 1004                          The M1 register enables and disables the Trace
 1005                          Trap and the General Register Overflow Trap:
 1006                          */
 1007                          /*K* REGS.M1.J - BIT(1)
 1008                          .XEQ GH_LCP6_M G$M1_REG J
 1009                          */
 1010                          /*K* REGS.M1.Rn_OV - BIT(1) (where n = 1-7)
 1011                          .XEQ GH_LCP6_M G$M1_REG Rn_OV
 1012                          */
 1013                          /*K* REGS.M3 -
 1014                          The M3 register contains the control
 1015                          information for the Commercial Instruction Processor(CIP):
 1016                          */
 1017                          /*K* REGS.M3.CIP_OV - BIT(1)
 1018                          .XEQ GH_LCP6_M G$M3_REG CIP_OV
 1019                          */
 1020                          /*K* REGS.M3.CIP_TR - BIT(1)
 1021                          .XEQ GH_LCP6_M G$M3_REG CIP_TR
 1022                          */
 1023                          /*K* REGS.T$ - PTR
 1024                          is the Stack Address Register and contains
 1025                          the address of the first word of the stack header.
 1026                          */
 1027                          /*K* REGS.CI - BIT(8)
 1028                          contains the Commercial Indicator
 1029                          register bits which are set and reset by the CIP:
 1030                          */
 1031                          /*K* REGS.CI.OV - BIT(1)
 1032                          .XEQ GH_LCP6_M G$CI_REG OV
 1033                          */
 1034                          /*K* REGS.CI.TR - BIT(1)
 1035                          .XEQ GH_LCP6_M G$CI_REG TR
 1036                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          29   
 1037                          /*K* REGS.CI.SF - BIT(1)
 1038                          .XEQ GH_LCP6_M G$CI_REG SF
 1039                          */
 1040                          /*K* REGS.CI.G - BIT(1)
 1041                          .XEQ GH_LCP6_M G$CI_REG G
 1042                          */
 1043                          /*K* REGS.CI.L - BIT(1)
 1044                          .XEQ GH_LCP6_M G$CI_REG L
 1045                          */
 1046                          /*K* REGS.CI.QLT - BIT(1)
 1047                          .XEQ GH_LCP6_M G$CI_REG QLT
 1048                          */
 1049                          /*K* REGS.RDBR$ - PTR
 1050                          specifies the Remote Descriptor Base register and
 1051                          is used by the CIP to locate a remote descriptor array.
 1052                          */
 1053
 1054      %MEND;
 1055
 1056
 1057
 1058
 1059
 1060
 1061                          /*F*   NAME: G$ISA_HDR
 1062
 1063                          The G$ISA_HDR macro may be used to generate
 1064                          a structure that contains the words in
 1065                          the Interrupt Save Area prior to the one
 1066                          pointed to by the interrupt save vector.
 1067
 1068                          The fields in the Interrupt Save Area header are:
 1069                          */
 1070
 1071      %MACRO G$ISA_HDR (FPTN=G$ISA_HDR,
 1072        ASV$=NIL,
 1073        TSAP$=NIL,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          30   
 1074        LVL=1,
 1075        LAST(YES=";",NO=",",ANY)=";",
 1076        ALGN=WALIGNED,
 1077        STCLASS=BASED);
 1078
 1079      %LSET LISTDIR='0'B;
 1080      %LSET LISTEXP='1'B;
 1081      %LSET LISTCOM='0'B;
 1082      %LSET LISTSUB='1'B;
 1083
 1084      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1085      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1086      %LSET INIT=CHARTEXT(' INIT');
 1087      %LSET EINIT=CHARTEXT('');
 1088      %ELSE;
 1089      %LSET INIT=CHARTEXT('/*');
 1090      %LSET EINIT=CHARTEXT('*/');
 1091      %ENDIF;
 1092
 1093      %IF LVL=1;
 1094      DCL 1 FPTN STCLASS ALGN,
 1095      %ELSE;
 1096              %LVL FPTN,
 1097      %ENDIF;
 1098                %(LVL+1) %CHARTEXT('ASV$ PTR') %INIT(ADDR(ASV$)*0)%EINIT,
 1099                          /*K* ASV$ - PTR
 1100                          contains the Address Space Vector.
 1101                          This pointer specifies the base of an MMU image in memory.
 1102                          .XEQ
 1103                          The default is NIL.
 1104                          */
 1105                %(LVL+1) * BIT(16) %INIT('0'B*0)%EINIT,
 1106                %(LVL+1) %CHARTEXT('TSAP$ PTR') %INIT(ADDR(TSAP$)*0)%EINIT LAST
 1107                          /*K* TSAP$ - PTR
 1108                          contains the Trap Save Area Pointer.
 1109                          This pointer is null until a trap occurs, at which time
 1110                          the address of the Trap Save Area used for the trap is
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          31   
 1111                          stored here by the hardware.
 1112                          .XEQ
 1113                          The default is NIL.
 1114                          */
 1115      %MEND;
 1116
 1117
 1118
 1119
 1120
 1121
 1122
 1123
 1124
 1125                          /*F*   NAME: G$ISA_MINI
 1126
 1127                          The G$ISA_MINI macro may be used to generate
 1128                          a structure that defines the Interrupt Save
 1129                          Area for a centrally connected interrupt
 1130                          handler.
 1131
 1132                          The mini ISA must reside in the monitor's
 1133                          HJIT so that it may be addressed from
 1134                          all interrupt levels.
 1135
 1136                          The G$ISA_HDR macro is invoked using
 1137                          the name specified via the FPTN parameter
 1138                          which will determine the name of the
 1139                          structure.  The header is followed by the
 1140                          following fields:
 1141                          */
 1142
 1143      %MACRO G$ISA_MINI (FPTN=G$ISA_MINI,
 1144        P$$=NIL,
 1145        P=0,
 1146        ASV$=NIL,
 1147        RING(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B,ANY)='00'B,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          32   
 1148        NATSAP_SEL(G_NATSAP_MON#=0,G_NATSAP_HND#=2,G_NATSAP_USR#=1,ANY)=2,
 1149        MMU(YES='1'B,NO='0'B)='0'B,
 1150        IL=0,
 1151        LVL=1,
 1152        LAST(YES=";",NO=",",ANY)=";",
 1153        ALGN=WALIGNED,
 1154        STCLASS=BASED);
 1155
 1156      %LSET LISTDIR='0'B;
 1157      %LSET LISTEXP='1'B;
 1158      %LSET LISTCOM='0'B;
 1159      %LSET LISTSUB='1'B;
 1160
 1161      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1162      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1163      %LSET INIT=CHARTEXT(' INIT');
 1164      %LSET EINIT=CHARTEXT('');
 1165      %ELSE;
 1166      %LSET INIT=CHARTEXT('/*');
 1167      %LSET EINIT=CHARTEXT('*/');
 1168      %ENDIF;
 1169
 1170                %G$ISA_HDR (FPTN=FPTN,ASV$=ASV$,LVL=LVL,STCLASS=STCLASS,LAST=",");
 1171
 1172      %LSET ISA_NXT_LVL=LVL+1;
 1173
 1174              %G$DEV (FPTN=DEV,STCLASS=STCLASS,IL=IL,LVL=ISA_NXT_LVL,LAST=",");
 1175                          /*K*  DEV - BIT(16) contains the contents of
 1176                          the Device word stored by the hardware.  See
 1177                          G$DEV for details.  Only IL may be initialized.
 1178                          */
 1179              %ISA_NXT_LVL ISM1 BIT(16)%INIT('0'B*0)%EINIT,
 1180                          /*K* ISM1 - BIT(16) contains the Interrupt Save
 1181                          Mask 1.  See G$ISM1 for the names and meanings of
 1182                          the bits within this word.
 1183                          In a mini ISA, all mask bits are reset.
 1184                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          33   
 1185                %G$ISM2 (FPTN=ISM2,STCLASS=STCLASS,LVL=ISA_NXT_LVL,
 1186                CIP=G_OFF#,NATSAP_SEL=NATSAP_SEL,LAST=",",
 1187                MMU=MMU,SIP=G_OFF#,T=G_OFF#,M2_M7=G_OFF#);
 1188                          /*K* ISM2 - BIT(16) contains the Interrupt Save
 1189                          Mask 2.  See G$ISM2 for the names and meanings of
 1190                          the bits within this word.
 1191                          In a mini ISA, the MMU bit is reset,
 1192                          the NATSAP_SEL value is set to %G_NATSAP_HND%,
 1193                          and all other mask bits are reset.
 1194                          */
 1195      %IF P=0;
 1196              %(LVL+1) %CHARTEXT('P$$ EPTR') %INIT(ENTADDR(P$$)*0)%EINIT,
 1197              %(LVL+1) P$ REDEF %CHARTEXT('P$$ PTR'),
 1198      %ELSE;
 1199              %(LVL+1) %CHARTEXT('P UBIN(32)') %INIT(P*0)%EINIT,
 1200              %(LVL+1) %CHARTEXT('P$$') REDEF %CHARTEXT('P EPTR'),
 1201              %(LVL+1) %CHARTEXT('P$') REDEF %CHARTEXT('P PTR'),
 1202      %ENDIF;
 1203                          /*K*   P$$ - EPTR contains the contents of the Program
 1204                          Counter to be loaded at the time of the interrupt.
 1205                          This is to be the address of the Common Interrupt
 1206                          Handler in the MON_ENTRY Segment.
 1207                          This field is REDEFed as P$ PTR.
 1208                          The default is NIL.
 1209                          */
 1210      %G$STATUS_REG (FPTN=S,RING=RING,STCLASS=STCLASS,LVL=ISA_NXT_LVL,LAST=LAST);
 1211                          /*K* S - BIT(16) contains an image of a Status
 1212                          Register which would be stored if the ISA were ever
 1213                          interrupted.  Otherwise, only the RING field is used,
 1214                          and thus only it can be initialized.
 1215                          */
 1216                          /*K* S.QLT - BIT(1)
 1217                          .XEQ GH_LCP6_M G$STATUS_REG QLT
 1218                          */
 1219                          /*K* S.RING - BIT(2)
 1220                          .XEQ GH_LCP6_M G$STATUS_REG RING
 1221                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          34   
 1222                          /*K* S.ID - BIT(2)
 1223                          .XEQ GH_LCP6_M G$STATUS_REG ID
 1224                          */
 1225                          /*K* S.LEVEL - UBIN(6)
 1226                          .XEQ GH_LCP6_M G$STATUS_REG LEVEL
 1227                          */
 1228      %MEND;
 1229
 1230
 1231
 1232
 1233
 1234
 1235
 1236
 1237
 1238                          /*F*   NAME: G$ISM1
 1239
 1240                          The G$ISM1 macro may be used to generate
 1241                          a structure that contains the Interrupt Save Mask 1.
 1242                          When generating a CONSTANT or STATIC structure,
 1243                          each field within ISM1 may be set or reset by
 1244                          specifying  field-name = {G_ON# | G_OFF#}.  The
 1245                          default in each case is G_ON#.
 1246
 1247                          The fields of ISM1 are:
 1248                          */
 1249
 1250      %MACRO G$ISM1 (FPTN=G$ISM1,
 1251        M1(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1252        R1(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1253        R2(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1254        R3(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1255        R4(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1256        R5(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1257        R6(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1258        R7(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          35   
 1259        I(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1260        B1(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1261        B2(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1262        B3(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1263        B4(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1264        B5(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1265        B6(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1266        B7(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1267        LVL=1,
 1268        LAST(YES=";",NO=",",ANY)=";",
 1269        ALGN=WALIGNED,
 1270        STCLASS=BASED);
 1271
 1272      %LSET LISTDIR='0'B;
 1273      %LSET LISTEXP='1'B;
 1274      %LSET LISTCOM='0'B;
 1275      %LSET LISTSUB='1'B;
 1276
 1277      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1278      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1279      %LSET INIT=CHARTEXT(' INIT');
 1280      %LSET EINIT=CHARTEXT('');
 1281      %ELSE;
 1282      %LSET INIT=CHARTEXT('/*');
 1283      %LSET EINIT=CHARTEXT('*/');
 1284      %ENDIF;
 1285
 1286      %IF LVL=1;
 1287      DCL 1 FPTN STCLASS ALGN,
 1288      %ELSE;
 1289              %LVL FPTN,
 1290      %ENDIF;
 1291                %(LVL+1) %CHARTEXT('M1 BIT(1)') %INIT(M1)%EINIT,
 1292                          /*K* M1 - BIT(1) indicates, if set, that the contents
 1293                          of Mode Control Register M1 is to be saved and restored.
 1294                          The default is G_ON#.
 1295                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          36   
 1296                %(LVL+1) %CHARTEXT('R1 BIT(1)') %INIT(R1)%EINIT,
 1297                          /*K* Rn - BIT(1) indicates, if set,
 1298                          that the contents of the general register Rn
 1299                          (where n = 1-7) is to be
 1300                          saved and restored.
 1301                          The default is G_ON#.
 1302                          */
 1303                %(LVL+1) %CHARTEXT('R2 BIT(1)') %INIT(R2)%EINIT,
 1304                %(LVL+1) %CHARTEXT('R3 BIT(1)') %INIT(R3)%EINIT,
 1305                %(LVL+1) %CHARTEXT('R4 BIT(1)') %INIT(R4)%EINIT,
 1306                %(LVL+1) %CHARTEXT('R5 BIT(1)') %INIT(R5)%EINIT,
 1307                %(LVL+1) %CHARTEXT('R6 BIT(1)') %INIT(R6)%EINIT,
 1308                %(LVL+1) %CHARTEXT('R7 BIT(1)') %INIT(R7)%EINIT,
 1309                %(LVL+1) %CHARTEXT('I BIT(1)') %INIT(I)%EINIT,
 1310                          /*K* I - BIT(1) indicates, if set, that the contents
 1311                          of the Indicator Register is to be saved and restored.
 1312                          The default is G_ON#.
 1313                          */
 1314                %(LVL+1) %CHARTEXT('B1 BIT(1)') %INIT(B1)%EINIT,
 1315                          /*K* Bn - BIT(1) indicates, if set,
 1316                          that the contents of the base register Bn
 1317                          (where n = 1-7) is to be
 1318                          saved and restored.
 1319                          The default is G_ON#.
 1320                          */
 1321                %(LVL+1) %CHARTEXT('B2 BIT(1)') %INIT(B2)%EINIT,
 1322                %(LVL+1) %CHARTEXT('B3 BIT(1)') %INIT(B3)%EINIT,
 1323                %(LVL+1) %CHARTEXT('B4 BIT(1)') %INIT(B4)%EINIT,
 1324                %(LVL+1) %CHARTEXT('B5 BIT(1)') %INIT(B5)%EINIT,
 1325                %(LVL+1) %CHARTEXT('B6 BIT(1)') %INIT(B6)%EINIT,
 1326                %(LVL+1) %CHARTEXT('B7 BIT(1)') %INIT(B7)%EINIT LAST
 1327      %MEND;
 1328
 1329
 1330
 1331
 1332
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          37   
 1333
 1334                          /*F*   NAME: G$ISM2
 1335
 1336                          The G$ISM2 macro may be used to generate
 1337                          a structure that contains the Interrupt Save Mask 2.
 1338                          When generating a CONSTANT or STATIC structure,
 1339                          the fields that control the saving and restoring
 1340                          of the registers may be set or reset by specifying
 1341                          field-name = {G_ON# | G_OFF#}.  The default in each case
 1342                          is G_ON#.
 1343
 1344                          The fields of ISM2 are:
 1345                          */
 1346
 1347      %MACRO G$ISM2 (FPTN=G$ISM2,
 1348        MMU(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1349        SIP(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 1350        CIP(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1351        T(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1352        M2_M7(G_ON#='1'B,G_OFF#='0'B,ANY)='1'B,
 1353        NATSAP_SEL(G_NATSAP_MON#=0,G_NATSAP_USR#=1,ANY)=0,
 1354        LVL=1,
 1355        LAST(YES=";",NO=",",ANY)=";",
 1356        ALGN=WALIGNED,
 1357        STCLASS=BASED);
 1358
 1359      %LSET LISTDIR='0'B;
 1360      %LSET LISTEXP='1'B;
 1361      %LSET LISTCOM='0'B;
 1362      %LSET LISTSUB='1'B;
 1363
 1364      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1365      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1366      %LSET INIT=CHARTEXT(' INIT');
 1367      %LSET EINIT=CHARTEXT('');
 1368      %ELSE;
 1369      %LSET INIT=CHARTEXT('/*');
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          38   
 1370      %LSET EINIT=CHARTEXT('*/');
 1371      %ENDIF;
 1372
 1373      %IF LVL=1;
 1374      DCL 1 FPTN STCLASS ALGN,
 1375      %ELSE;
 1376              %LVL FPTN,
 1377      %ENDIF;
 1378                %(LVL+1) %CHARTEXT('MMU BIT(1)') %INIT(MMU*0)%EINIT,
 1379                          /*K* MMU - BIT(1) indicates, if set, that the MMU context
 1380                          is to be loaded when an interrupt level change takes place.
 1381                          Note, however, that MMU context is never stored.
 1382                          The default is G_ON#.
 1383                          */
 1384                %(LVL+1) %CHARTEXT('NATSAP_SEL UBIN(3)UNAL') %INIT(NATSAP_SEL*0)%EINIT,
 1385                          /*K* NATSAP_SEL - UBIN(3) contains an index to the pool
 1386                          of Trap Save Areas to be used when a trap occurs while this
 1387                          interrupt level is active.  The default is 0.
 1388                          */
 1389                %(LVL+1) * BIT(2) %INIT('0'B*0)%EINIT,
 1390                %(LVL+1) %CHARTEXT('SIP BIT(1)') %INIT(SIP*0)%EINIT,
 1391                          /*N* SIP = VALUE-BIT(1).  If set, indicates that the SIP context
 1392                          is to be saved and restored.
 1393                          The default is G_OFF#.
 1394                          */
 1395                %(LVL+1) %CHARTEXT('CIP BIT(1)') %INIT(CIP*0)%EINIT,
 1396                          /*K* CIP - BIT(1) indicates, if set, that the CIP context
 1397                          is to be saved and restored.
 1398                          The default is G_ON#.
 1399                          */
 1400                %(LVL+1) * BIT(6) %INIT('0'B*0)%EINIT,
 1401                %(LVL+1) %CHARTEXT('T BIT(1)') %INIT(T*0)%EINIT,
 1402                          /*K* T - BIT(1) indicates, if set, that the contents
 1403                          of the Stack Address Register is to be saved and restored.
 1404                          The default is G_ON#.
 1405                          */
 1406                %(LVL+1) %CHARTEXT('M2_M7 BIT(1)') %INIT(M2_M7*0)%EINIT LAST
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          39   
 1407                          /*K* M2_M7 - BIT(1) indicates, if set, that the contents
 1408                          of Mode Control Registers M1 to M7 is to be saved and restored.
 1409                          The default is G_ON#.
 1410                          */
 1411      %MEND;
 1412
 1413
 1414
 1415
 1416
 1417                          /*F*   NAME: G$LOW_MEM.
 1418
 1419                          The G$LOW_MEM macro may be used to generate a
 1420                          structure of the hardware dedicated memory
 1421                          locations in low core.  No initial values may
 1422                          be specified.
 1423
 1424                          This structure contains the following fields:
 1425                          */
 1426
 1427      %MACRO G$LOW_MEM (FPTN=G$LOW_MEM,
 1428        ALGN=WALIGNED,
 1429        STCLASS=BASED);
 1430
 1431      %LSET LISTDIR='0'B;
 1432      %LSET LISTEXP='1'B;
 1433      %LSET LISTCOM='0'B;
 1434      %LSET LISTSUB='1'B;
 1435
 1436      DCL 1 FPTN STCLASS ALGN,
 1437            2 PSF_ENT$ PTR,
 1438                          /*K* PSF_ENT$ = PTR is an entry to the Power Failsafe Routine.
 1439                          This is the address to be entered on power-up.
 1440                          */
 1441            2 NATSAP7$ PTR,
 1442                          /*K* NATSAPn$ = PTR (where n = 0-7) contains the address
 1443                          of a pool of available Trap Save Areas.  When a trap
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          40   
 1444                          occurs, the firmware uses the NATSAP_SEL field in ISM2
 1445                          to access one of the pools 0-7.  The linkage between TSAs
 1446                          in a pool is initialized by the LCP-6 software and
 1447                          maintained by the firmware.
 1448
 1449                          NATSAP0$ will be set to the address of MHJIT.TSA_MON
 1450                          and NATSAP1$ will be set to the address of UHJIT.TSA_USR.
 1451
 1452                          NATSAP4$ through NAPTSAP7$ are Reserved for Future Use.
 1453
 1454                          */
 1455            2 NATSAP6$ PTR,
 1456            2 NATSAP5$ PTR,
 1457            2 NATSAP4$ PTR,
 1458            2 NATSAP3$ PTR,
 1459            2 NATSAP2$ PTR,
 1460            2 NATSAP1$ PTR,
 1461            2 NATSAP0$ PTR,
 1462            2 *(0:1) UBIN WORD,
 1463                                    /* RHU                                                              */
 1464            2 RTC_INIT UBIN WORD,
 1465                          /*K* RTC_INIT = VALUE-UBIN WORD contains the Real time clock
 1466                               initial value.
 1467                          */
 1468            2 RTC_CURR UBIN WORD,
 1469                          /*K* RTC_CURR = VALUE-UBIN WORD contains the Real time clock
 1470                               current value.
 1471                          */
 1472            2 RTC_LVL UBIN WORD,
 1473                          /*K* RTC_LVL = VALUE-UBIN WORD contains the Real time clock
 1474                               interrupt level.
 1475                          */
 1476            2 WDT_CURR UBIN WORD,
 1477                          /*K* WDT_CURR = VALUE-UBIN WORD contains the Watchdog Timer
 1478                               current value.
 1479                          */
 1480            2 *(0:6) UBIN WORD,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          41   
 1481                                    /* RHU                                                              */
 1482            2 MEM_ERR_CNT SBIN WORD,
 1483                          /*K* MEM_ERR_CNT = VALUE-SBIN WORD contains the
 1484                               hardware count of memory errors.
 1485                          */
 1486            2 LVL_ACT(0:63) BIT(1),
 1487                          /*K* LVL_ACT = ARRAY(0:63)-BIT(1) set when the corresponding
 1488                               interrupt level is active.
 1489                          */
 1490            %G$TRAP_VECTOR (FPTN=TV,LVL=2,LAST=",");
 1491                          /*K* TV = The trap vector.  Refer to G$TRAP_VECTOR
 1492                          for the fields within the trap vector.
 1493                          */
 1494            %G$INTERRUPT_VECTOR (FPTN=IV,LVL=2,LAST=";");
 1495                          /*K* IV = The interrupt vector.  Refer to G$INTERRUPT_VECTOR
 1496                          for the fields within the interrupt vector.
 1497                          */
 1498      %MEND;
 1499
 1500
 1501
 1502
 1503
 1504                          /*F*   NAME: G$M1_REG.
 1505
 1506                          The G$M1_REG macro may be used to generate a
 1507                          structure for the Mode Control Register 1.
 1508                          This register enables and disables the Trace
 1509                          Trap and the General Register Overflow Traps.
 1510
 1511                          The fields of the M1 Register are:
 1512                          */
 1513
 1514
 1515      %MACRO G$M1_REG (FPTN=G$M1_REG,
 1516        J(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1517        R1_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          42   
 1518        R2_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1519        R3_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1520        R4_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1521        R5_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1522        R6_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1523        R7_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1524        LVL=1,
 1525        LAST(YES=";",NO=",",ANY)=";",
 1526        ALGN=WALIGNED,
 1527        STCLASS=BASED);
 1528
 1529      %LSET LISTDIR='0'B;
 1530      %LSET LISTEXP='1'B;
 1531      %LSET LISTCOM='0'B;
 1532      %LSET LISTSUB='1'B;
 1533
 1534      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1535      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1536      %LSET INIT=CHARTEXT(' INIT');
 1537      %LSET EINIT=CHARTEXT('');
 1538      %ELSE;
 1539      %LSET INIT=CHARTEXT('/*');
 1540      %LSET EINIT=CHARTEXT('*/');
 1541      %ENDIF;
 1542
 1543      %IF LVL=1;
 1544      DCL 1 FPTN STCLASS ALGN,
 1545      %ELSE;
 1546              %LVL FPTN,
 1547      %ENDIF;
 1548                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
 1549                %(LVL+1) %CHARTEXT('J BIT(1)') %INIT(J)%EINIT,
 1550                          /*K* J = VALUE-BIT(1)
 1551                          is the Trace Trap control
 1552                          bit;  0 = Trace Trap disabled, 1 = Trace Trap enabled.
 1553                          .XEQ
 1554
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          43   
 1555                          This field may be initialized by specifying either
 1556                          J={G_ENABLE# | G_DISABLE#}.  Default=G_DISABLE#.
 1557                          */
 1558                %(LVL+1) %CHARTEXT('R1_OV BIT(1)') %INIT(R1_OV)%EINIT,
 1559                          /*K* Rn_OV = VALUE-BIT(1) (where n = 1-7)
 1560                          are the
 1561                          overflow trap control bits for the seven general registers;
 1562                          0 = trap disabled, 1 = trap enabled.
 1563                          .XEQ
 1564
 1565                          This field may be initialized by specifying either
 1566                          Rn_OV={G_ENABLE# | G_DISABLE#}.  Default=G_DISABLE#.
 1567                          */
 1568                %(LVL+1) %CHARTEXT('R2_OV BIT(1)') %INIT(R2_OV)%EINIT,
 1569                %(LVL+1) %CHARTEXT('R3_OV BIT(1)') %INIT(R3_OV)%EINIT,
 1570                %(LVL+1) %CHARTEXT('R4_OV BIT(1)') %INIT(R4_OV)%EINIT,
 1571                %(LVL+1) %CHARTEXT('R5_OV BIT(1)') %INIT(R5_OV)%EINIT,
 1572                %(LVL+1) %CHARTEXT('R6_OV BIT(1)') %INIT(R6_OV)%EINIT,
 1573                %(LVL+1) %CHARTEXT('R7_OV BIT(1)') %INIT(R7_OV)%EINIT LAST
 1574
 1575      %MEND;
 1576
 1577
 1578
 1579
 1580
 1581
 1582                          /*F*   NAME: G$M3_REG.
 1583
 1584                          The G$M3_REG macro may be used to generate a
 1585                          structure for the Mode Control Register 3.
 1586                          This register contains the control information
 1587                          for the Commercial Instruction Processor (CIP).
 1588
 1589                          The fields of the M3 Register are:
 1590                          */
 1591
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          44   
 1592      %MACRO G$M3_REG (FPTN=G$M3_REG,
 1593        CIP_OV(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1594        CIP_TR(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1595        LVL=1,
 1596        LAST(YES=";",NO=",",ANY)=";",
 1597        ALGN=WALIGNED,
 1598        STCLASS=BASED);
 1599
 1600      %LSET LISTDIR='0'B;
 1601      %LSET LISTEXP='1'B;
 1602      %LSET LISTCOM='0'B;
 1603      %LSET LISTSUB='1'B;
 1604
 1605      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1606      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1607      %LSET INIT=CHARTEXT(' INIT');
 1608      %LSET EINIT=CHARTEXT('');
 1609      %ELSE;
 1610      %LSET INIT=CHARTEXT('/*');
 1611      %LSET EINIT=CHARTEXT('*/');
 1612      %ENDIF;
 1613
 1614      %IF LVL=1;
 1615      DCL 1 FPTN STCLASS ALGN,
 1616      %ELSE;
 1617              %LVL FPTN,
 1618      %ENDIF;
 1619                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
 1620                %(LVL+1) %CHARTEXT('CIP_OV BIT(1)') %INIT(CIP_OV)%EINIT,
 1621                          /*K* CIP_OV = VALUE-BIT(1)
 1622                          is the CIP Overflow
 1623                          Trap Mask; 0 = trap disabled, 1 = trap enabled.
 1624                          .XEQ
 1625
 1626                          This field may be initialized by specifying either
 1627                          CIP_OV={G_ENABLE# | G_DISABLE#}.  Default=G_DISABLE#.
 1628                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          45   
 1629                %(LVL+1) %CHARTEXT('CIP_TR BIT(1)') %INIT(CIP_TR)%EINIT,
 1630                          /*K* CIP_TR = VALUE-BIT(1)
 1631                          is the CIP Truncation
 1632                          Trap Mask; 0 = trap disabled, 1 = trap enabled.
 1633                          .XEQ
 1634
 1635                          This field may be initialized by specifying either
 1636                          CIP_TR={G_ENABLE# | G_DISABLE#}.  Default=G_DISABLE#.
 1637                          */
 1638                %(LVL+1) RFU BIT(6) %INIT('0'B)%EINIT LAST
 1639      %MEND;
 1640
 1641
 1642
 1643
 1644
 1645
 1646                          /*N*   NAME: G$M4_REG.
 1647
 1648                          The G$M4_REG macro may be used to generate a
 1649                          structure for the Mode Control Register 4.
 1650                          This register is the Mode Control Register
 1651                          for the Scientific Instruction Processor (SIP).
 1652
 1653                          The fields of the M4 Register are:
 1654                          */
 1655
 1656
 1657      %MACRO G$M4_REG (FPTN=G$M4_REG,
 1658        RT='0'B,
 1659        SA1_ML='0'B,
 1660        SA1_AL='0'B,
 1661        SA2_ML='0'B,
 1662        SA2_AL='0'B,
 1663        SA3_ML='0'B,
 1664        SA3_AL='0'B,
 1665        LVL=1,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          46   
 1666        LAST(YES=";",NO=",",ANY)=";",
 1667        ALGN=WALIGNED,
 1668        STCLASS=BASED);
 1669
 1670      %LSET LISTDIR='0'B;
 1671      %LSET LISTEXP='1'B;
 1672      %LSET LISTCOM='0'B;
 1673      %LSET LISTSUB='1'B;
 1674
 1675      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1676      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1677      %LSET INIT=CHARTEXT(' INIT');
 1678      %LSET EINIT=CHARTEXT('');
 1679      %ELSE;
 1680      %LSET INIT=CHARTEXT('/*');
 1681      %LSET EINIT=CHARTEXT('*/');
 1682      %ENDIF;
 1683
 1684      %IF LVL=1;
 1685      DCL 1 FPTN STCLASS ALGN,
 1686      %ELSE;
 1687              %LVL FPTN,
 1688      %ENDIF;
 1689                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
 1690                %(LVL+1) %CHARTEXT('RT BIT(1)') %INIT(RT)%EINIT,
 1691                          /*N* RT = VALUE-BIT(1).  Round/Truncation Mode;
 1692                          0 = Truncate, 1 = Round.
 1693                          */
 1694                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
 1695                          /*N* SAn_  Where n = 1 -> 3.  The Scientific Accumulators,
 1696                          which contain the following:
 1697                          */
 1698                %(LVL+1) %CHARTEXT('SA1_ML BIT(1)') %INIT(SA1_ML)%EINIT,
 1699                          /*N* SAn_ML = VALUE-BIT(1).  Memory length of main memory
 1700                          data field associated with this SA; 0 = two words, 1= four words.
 1701                          */
 1702                %(LVL+1) %CHARTEXT('SA1_AL BIT(1)') %INIT(SA1_AL)%EINIT,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          47   
 1703                          /*N* SAn_AL = VALUE-BIT(1).  Length of the value in the
 1704                          Scientific Accumulator; 0 = two words, 1 = four words.
 1705                          */
 1706                %(LVL+1) %CHARTEXT('SA2_ML BIT(1)') %INIT(SA2_ML)%EINIT,
 1707                %(LVL+1) %CHARTEXT('SA2_AL BIT(1)') %INIT(SA2_AL)%EINIT,
 1708                %(LVL+1) %CHARTEXT('SA3_ML BIT(1)') %INIT(SA3_ML)%EINIT,
 1709                %(LVL+1) %CHARTEXT('SA3_AL BIT(1)') %INIT(SA3_AL)%EINIT LAST
 1710      %MEND;
 1711
 1712
 1713
 1714
 1715
 1716
 1717                          /*N*   NAME: G$M5_REG.
 1718
 1719                          The G$M5_REG macro may be used to generate a
 1720                          structure for the Mode Control Register 5.
 1721                          This register is the Trap Mask Register
 1722                          for the Scientific Instruction Processor (SIP).
 1723
 1724                          The fields of the M5 Register are:
 1725                          */
 1726
 1727
 1728      %MACRO G$M5_REG (FPTN=G$M5_REG,
 1729        EUM(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1730        SEM(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1731        PEM(G_ENABLE#='1'B,G_DISABLE#='0'B,ANY)='0'B,
 1732        LVL=1,
 1733        LAST(YES=";",NO=",",ANY)=";",
 1734        ALGN=WALIGNED,
 1735        STCLASS=BASED);
 1736
 1737      %LSET LISTDIR='0'B;
 1738      %LSET LISTEXP='1'B;
 1739      %LSET LISTCOM='0'B;
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          48   
 1740      %LSET LISTSUB='1'B;
 1741
 1742      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1743      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1744      %LSET INIT=CHARTEXT(' INIT');
 1745      %LSET EINIT=CHARTEXT('');
 1746      %ELSE;
 1747      %LSET INIT=CHARTEXT('/*');
 1748      %LSET EINIT=CHARTEXT('*/');
 1749      %ENDIF;
 1750
 1751      %IF LVL=1;
 1752      DCL 1 FPTN STCLASS ALGN,
 1753      %ELSE;
 1754              %LVL FPTN,
 1755      %ENDIF;
 1756                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
 1757                %(LVL+1) %CHARTEXT('EUM BIT(1)') %INIT(EUM)%EINIT,
 1758                          /*N* EUM = VALUE-BIT(1).  SIP Exponent Underflow
 1759                          Trap Mask; 0 = disabled, 1 = enabled.
 1760                          */
 1761                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
 1762                %(LVL+1) %CHARTEXT('SEM BIT(1)') %INIT(SEM)%EINIT,
 1763                          /*N* SEM = VALUE-BIT(1).  SIP Significance Error
 1764                          Trap Mask; 0 = disabled, 1 = enabled.
 1765                          */
 1766                %(LVL+1) %CHARTEXT('PEM BIT(1)') %INIT(PEM)%EINIT,
 1767                          /*N* PEM = VALUE-BIT(1).  SIP Precision Error
 1768                          Trap Mask; 0 = disabled, 1 = enabled.
 1769                          */
 1770                %(LVL+1) RFU BIT(4) %INIT('0'B)%EINIT LAST
 1771      %MEND;
 1772
 1773
 1774
 1775
 1776
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          49   
 1777
 1778                          /*F*   NAME: VLP_REGISTERS
 1779
 1780                          The M$TRTN monitor service
 1781                          allows the user to specify that the values of
 1782                          the base registers, the general registers,
 1783                          the mode control registers, etc. are to be
 1784                          replaced with values supplied by the user.
 1785
 1786                          The VLP_REGISTERS macro may be used to define the area
 1787                          to contain these values.  No initial values are
 1788                          provided for in this macro as the values must
 1789                          always be supplied at run time.  Generally, the
 1790                          data area defined by the VLP_REGISTERS macro will be
 1791                          initialized from the TCB frame (G$EXCFR.REGS) and selected
 1792                          values replaced.  The monitor service FPT can then be
 1793                          modified to point to this area (or can be initialized
 1794                          at compile time to point to this area).
 1795
 1796                          For example, the following PL-6 statements would cause
 1797                          the contents of general register 7 to be set to zero
 1798                          and the overflow trap for general register 7 to be
 1799                          disabled on returning to the point of interruption:
 1800
 1801                          .fif
 1802                          %INCLUDE LCP_6;
 1803                          %G$TCB;
 1804                          %G$EXCFR;
 1805                          %VLP_REGISTERS;
 1806                          %FPT_TRTN;
 1807
 1808                          DCL G$TCB$ PTR SYMREF;
 1809
 1810                          VLP_REGISTERS = G$TCB$->G$TCB.STK$->G$EXCFR.REGS;
 1811                          VLP_REGISTERS.R7 = 0;
 1812                          VLP_REGISTERS.M1.R7_OV = '0'B;
 1813                          FPT_TRTN.REGS_ = VECTOR(VLP_REGISTERS);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          50   
 1814                          CALL M$TRTN(FPT_TRTN);
 1815                          .fin
 1816
 1817                          The fields within the VLP_REGISTERS structure are as
 1818                          follows:
 1819                          */
 1820
 1821      %MACRO VLP_REGISTERS (FPTN=VLP_REGISTERS,
 1822        B7$=NIL,
 1823        B6$=NIL,
 1824        B5$=NIL,
 1825        B4$=NIL,
 1826        B3$=NIL,
 1827        B2$=NIL,
 1828        B1$=NIL,
 1829        T$=NIL,
 1830        RDBR$=NIL,
 1831        SAVE_SIP(YES=1,NO=0,ANY)=0,
 1832        SAVE_ISM2(YES=1,NO=0,ANY)=1,
 1833        LVL=1,
 1834        LAST(YES=";",NO=",",ANY)=";",
 1835        ALGN=WALIGNED,
 1836        STCLASS=STATIC);
 1837
 1838      %LSET LISTDIR='0'B;
 1839      %LSET LISTEXP='1'B;
 1840      %LSET LISTCOM='0'B;
 1841      %LSET LISTSUB='1'B;
 1842
 1843      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1844      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1845      %LSET INIT=CHARTEXT(' INIT');
 1846      %LSET EINIT=CHARTEXT('');
 1847      %ELSE;
 1848      %LSET INIT=CHARTEXT('/*');
 1849      %LSET EINIT=CHARTEXT('*/');
 1850      %ENDIF;
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          51   
 1851
 1852      %IF LVL=1;
 1853      DCL 1 FPTN STCLASS ALGN,
 1854      %ELSE;
 1855              %LVL FPTN,
 1856      %ENDIF;
 1857      %LSET REGS_NXT_LVL=LVL+1;
 1858
 1859                %(LVL+1) %CHARTEXT('B7$ PTR') %INIT(ADDR(B7$))%EINIT,
 1860                %(LVL+1) %CHARTEXT('B6$ PTR') %INIT(ADDR(B6$))%EINIT,
 1861                %(LVL+1) %CHARTEXT('B5$ PTR') %INIT(ADDR(B5$))%EINIT,
 1862                %(LVL+1) %CHARTEXT('B4$ PTR') %INIT(ADDR(B4$))%EINIT,
 1863                %(LVL+1) %CHARTEXT('B3$ PTR') %INIT(ADDR(B3$))%EINIT,
 1864                %(LVL+1) %CHARTEXT('B2$ PTR') %INIT(ADDR(B2$))%EINIT,
 1865                %(LVL+1) %CHARTEXT('B1$ PTR') %INIT(ADDR(B1$))%EINIT,
 1866                          /*K* Bn$ - PTR
 1867                          (where n = 1-7)
 1868                          contains the contents of the base registers.
 1869                          */
 1870                %G$INDICATOR_REG (FPTN=I,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1871                          /*K* I - BIT(16)
 1872                          is an 8 bit indicator register that contains the overflow
 1873                          and program status indicators:
 1874                          */
 1875                          /*K* I.TRAP# - UBIN(8)
 1876                          .XEQ GH_LCP6_M G$INDICATOR_REG TRAP#
 1877                          */
 1878                          /*K* I.OV - BIT(1)
 1879                          .XEQ GH_LCP6_M G$INDICATOR_REG OV
 1880                          */
 1881                          /*K* I.C - BIT(1)
 1882                          .XEQ GH_LCP6_M G$INDICATOR_REG C
 1883                          */
 1884                          /*K* I.B - BIT(1)
 1885                          .XEQ GH_LCP6_M G$INDICATOR_REG B
 1886                          */
 1887                          /*K* I.IO - BIT(1)
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          52   
 1888                          .XEQ GH_LCP6_M G$INDICATOR_REG IO
 1889                          */
 1890                          /*K* I.G - BIT(1)
 1891                          .XEQ GH_LCP6_M G$INDICATOR_REG G
 1892                          */
 1893                          /*K* I.L - BIT(1)
 1894                          .XEQ GH_LCP6_M G$INDICATOR_REG L
 1895                          */
 1896                          /*K* I.U - BIT(1)
 1897                          .XEQ GH_LCP6_M G$INDICATOR_REG U
 1898                          */
 1899              %(LVL+1) R7 UBIN WORD %INIT(0)%EINIT,
 1900              %(LVL+1) R6 UBIN WORD %INIT(0)%EINIT,
 1901              %(LVL+1) R5 UBIN WORD %INIT(0)%EINIT,
 1902              %(LVL+1) R4 UBIN WORD %INIT(0)%EINIT,
 1903              %(LVL+1) R3 UBIN WORD %INIT(0)%EINIT,
 1904              %(LVL+1) R2 UBIN WORD %INIT(0)%EINIT,
 1905              %(LVL+1) R1 UBIN WORD %INIT(0)%EINIT,
 1906                          /*K* Rn - UBIN WORD
 1907                          (where n = 1-7)
 1908                          contains the contents of the 16 bit general registers.
 1909                          .XEQ
 1910                          R1 - R3 may be used as index
 1911                          registers.  R6 and R7 may be used as a double word.
 1912                          */
 1913                          /*N* Mn = VALUE-BIT(8).  Where n = 1 -> 7.  The Mode
 1914                          Control/Trap Enable Registers are all 8 bit registers.
 1915                          It should be noted, however, that a full word is required
 1916                          to store the contents of each register.
 1917                          */
 1918      %IF     SAVE_ISM2=0;
 1919                          /*N* SAVE_ISM2 - {YES|NO}  specifies if space is to be
 1920                          reserved for those items that cannot be saved with a SAVE
 1921                          instruction.  The default is YES.
 1922                          */
 1923              %G$M1_REG (FPTN=M1,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=LAST);
 1924      %ELSE;
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          53   
 1925              %G$M1_REG (FPTN=M1,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1926                          /*K* M1 -
 1927                          The M1 register enables and disables the Trace
 1928                          Trap and the General Register Overflow Trap:
 1929                          */
 1930                          /*K* M1.J - BIT(1)
 1931                          .XEQ GH_LCP6_M G$M1_REG J
 1932                          */
 1933                          /*K* M1.Rn_OV - BIT(1) (where n = 1-7)
 1934                          .XEQ GH_LCP6_M G$M1_REG Rn_OV
 1935                          */
 1936              %(LVL+1) M2 BIT(16) %INIT('0'B)%EINIT,
 1937                          /*N* M2.  The M2 Register is reserved for future use.
 1938                          */
 1939      %G$M3_REG (FPTN=M3,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1940                          /*K* M3 -
 1941                          The M3 register contains the control
 1942                          information for the Commercial Instruction Processor(CIP):
 1943                          */
 1944                          /*K* M3.CIP_OV - BIT(1)
 1945                          .XEQ GH_LCP6_M G$M3_REG CIP_OV
 1946                          */
 1947                          /*K* M3.CIP_TR - BIT(1)
 1948                          .XEQ GH_LCP6_M G$M3_REG CIP_TR
 1949                          */
 1950              %G$M4_REG (FPTN=M4,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1951                          /*N* M4. The M4 Register is the Mode Control Register
 1952                          for the Scientific Instruction Processor (SIP).
 1953                          Refer to G$M4_REG for the names and meanings of the
 1954                          individual fields within M4.
 1955                          */
 1956              %G$M5_REG (FPTN=M5,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1957                          /*N* M5.  The M5 Register is the SIP Mask Trap Register.
 1958                          Refer to G$M5_REG for the names and meanings of the
 1959                          individual fields within M5.
 1960                          */
 1961              %(LVL+1) M6 BIT(16) %INIT('0'B)%EINIT,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          54   
 1962                          /*N* M6.  The M6 Register is reserved for future use.
 1963                          */
 1964              %(LVL+1) M7 BIT(16) %INIT('0'B)%EINIT,
 1965                          /*N* M7.  The M7 Register is reserved for future use.
 1966                          */
 1967              %(LVL+1) %CHARTEXT('T$ PTR') %INIT(ADDR(T$))%EINIT,
 1968                          /*K* T$ - PTR
 1969                          is the Stack Address Register and contains
 1970                          the address of the first word of the stack header.
 1971                          */
 1972      %G$CI_REG (FPTN=CI,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 1973                          /*K* CI - BIT(8)
 1974                          contains the Commercial Indicator
 1975                          register bits which are set and reset by the CIP:
 1976                          */
 1977                          /*K* CI.OV - BIT(1)
 1978                          .XEQ GH_LCP6_M G$CI_REG OV
 1979                          */
 1980                          /*K* CI.TR - BIT(1)
 1981                          .XEQ GH_LCP6_M G$CI_REG TR
 1982                          */
 1983                          /*K* CI.SF - BIT(1)
 1984                          .XEQ GH_LCP6_M G$CI_REG SF
 1985                          */
 1986                          /*K* CI.G - BIT(1)
 1987                          .XEQ GH_LCP6_M G$CI_REG G
 1988                          */
 1989                          /*K* CI.L - BIT(1)
 1990                          .XEQ GH_LCP6_M G$CI_REG L
 1991                          */
 1992                          /*K* CI.QLT - BIT(1)
 1993                          .XEQ GH_LCP6_M G$CI_REG QLT
 1994                          */
 1995      %IF SAVE_SIP=0;
 1996                          /*N* SAVE_SIP = {YES|NO}   specifies if space for SIP context
 1997                          is to be generated.  The default is NO.
 1998                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          55   
 1999              %(LVL+1) %CHARTEXT('RDBR$ PTR') %INIT(ADDR(RDBR$))%EINIT LAST
 2000                          /*K* RDBR$ - PTR
 2001                          specifies the Remote Descriptor Base register and
 2002                          is used by the CIP to locate a remote descriptor array.
 2003                          */
 2004      %ELSE;
 2005              %(LVL+1) %CHARTEXT('RDBR$ PTR') %INIT(ADDR(RDBR$))%EINIT,
 2006      %G$SI_REG (FPTN=SI,LVL=REGS_NXT_LVL,STCLASS=STCLASS,LAST=",");
 2007                          /*N* SI = VALUE-BIT(8).  The Scientific Indicator
 2008                          Register bits are set and rest by the SIP.
 2009                          Refer to G$SI_REG for the names and meanings of the
 2010                          individual fields within SI.
 2011                          */
 2012              %(LVL+1) SA1(0:3) BIT(16) %INIT('0'B*4)%EINIT,
 2013                          /*N* SA1 = ARRAY(0:3) UBIN WORD.  Scientific Accumulator 1.
 2014                          */
 2015              %(LVL+1) SA2(0:3) BIT(16) %INIT('0'B*4)%EINIT,
 2016                          /*N* SA2 = ARRAY(0:3) UBIN WORD.  Scientific Accumulator 2.
 2017                          */
 2018              %(LVL+1) SA3(0:3) BIT(16) %INIT('0'B*4)%EINIT LAST
 2019                          /*N* SA3 = ARRAY(0:3) UBIN WORD.  Scientific Accumulator 3.
 2020                          */
 2021      %ENDIF;
 2022      %ENDIF;
 2023      %MEND;
 2024
 2025
 2026
 2027
 2028
 2029                          /*F*   NAME: G$SEGDESC
 2030
 2031                          The G$SEGDESC macro may be used to generate a
 2032                          single Address Space Descriptor.
 2033
 2034                          The fields within an Address Space Descriptor
 2035                          are:
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          56   
 2036                          */
 2037
 2038      %MACRO G$SEGDESC (FPTN=G$SEGDESC,
 2039        BASE=0,
 2040        SIZE=0,
 2041        V(YES='1'B,NO='0'B)='1'B,
 2042        RP(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B)='11'B,
 2043        WP(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B)='11'B,
 2044        EP(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B)='11'B,
 2045        LVL=1,
 2046        LAST(YES=";",NO=",",ANY)=";",
 2047        ALGN=WALIGNED,
 2048        STCLASS=BASED);
 2049
 2050      %LSET LISTDIR='0'B;
 2051      %LSET LISTEXP='1'B;
 2052      %LSET LISTCOM='0'B;
 2053      %LSET LISTSUB='1'B;
 2054
 2055      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2056      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2057      %LSET INIT=CHARTEXT(' INIT');
 2058      %LSET EINIT=CHARTEXT('');
 2059      %ELSE;
 2060      %LSET INIT=CHARTEXT('/*');
 2061      %LSET EINIT=CHARTEXT('*/');
 2062      %ENDIF;
 2063
 2064      %IF LVL=1;
 2065      DCL 1 FPTN STCLASS ALGN,
 2066      %ELSE;
 2067              %LVL FPTN,
 2068      %ENDIF;
 2069                %(LVL+1) %CHARTEXT('V BIT(1)') %INIT(V)%EINIT,
 2070                          /*K* V - BIT(1) is the segment validity bit which is set
 2071                               if the segment is valid; reset if the segment
 2072                               does not exist.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          57   
 2073                               This field may be initialized by specifying
 2074                               V={YES|NO}.  The default is YES.
 2075                          */
 2076                %(LVL+1) %CHARTEXT('BASE UBIN(15)UNAL') %INIT(BASE)%EINIT,
 2077                          /*K* BASE - UBIN(15) contains the
 2078                               starting address of the segment in real memory,
 2079                               in units of 256 words.  The default is 0.
 2080                          */
 2081                %(LVL+1) %CHARTEXT('RP BIT(2)') %INIT(RP)%EINIT,
 2082                          /*K* RP - BIT(2) contains the lowest privilege
 2083                               Ring number in which the processor must be operating
 2084                               in order to read data within this segment.  Ring
 2085                               number is encoded as ones complement.
 2086                               This field may be initialized by specifying
 2087                               {G_RING0# | G_R_MON# | G_R_DB# | G_R_USR#}.  The default is G_RING0#.
 2088                          */
 2089                %(LVL+1) %CHARTEXT('WP BIT(2)') %INIT(WP)%EINIT,
 2090                          /*K* WP - BIT(2) contains the lowest privilege
 2091                               Ring number in which the processor must be operating
 2092                               in order to write data within this segment.  Ring
 2093                               number is encoded as ones complement.
 2094                               This field may be initialized by specifying
 2095                               {G_RING0# | G_R_MON# | G_R_DB# | G_R_USR#}.  The default is G_RING0#.
 2096                          */
 2097                %(LVL+1) %CHARTEXT('EP BIT(2)') %INIT(EP)%EINIT,
 2098                          /*K* EP - BIT(2) contains the lowest privilege
 2099                               Ring number in which the processor must be operating
 2100                               in order to execute within this segment.  Ring
 2101                               number is encoded as ones complement; therefore:
 2102                               }
 2103                               }  Ring 0 (Monitor) - 11
 2104                               }  Ring 1 (Monitor) - 10
 2105                               }  Ring 2 (Debugger)- 01
 2106                               }  Ring 3 (User)    - 00
 2107                               }
 2108                               This field may be initialized by specifying
 2109                               {G_RING0# | G_R_MON# | G_R_DB# | G_R_USR#}.  The default is G_RING0#.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          58   
 2110                          */
 2111                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
 2112                %(LVL+1) %CHARTEXT('SIZE UBIN(9)UNAL') %INIT(SIZE)%EINIT LAST
 2113                          /*K* SIZE - UBIN(9) contains the size of the segment
 2114                               in units of 256 words.  The default is 0.
 2115                          */
 2116      %MEND;
 2117
 2118
 2119
 2120
 2121                          /*N*   NAME: G$SI_REG.
 2122
 2123                          The G$SI_REG macro may be used to generate
 2124                          a structure that contains the Scientific
 2125                          Instruction Processor Indicator Register (SIP).
 2126
 2127                          The fields of the SIP Indicator Register are:
 2128                          */
 2129
 2130      %MACRO G$SI_REG (FPTN=G$SI_REG,
 2131        EUF(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 2132        SE(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 2133        PE(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 2134        G(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 2135        L(G_ON#='1'B,G_OFF#='0'B,ANY)='0'B,
 2136        LVL=1,
 2137        LAST(YES=";",NO=",",ANY)=";",
 2138        ALGN=WALIGNED,
 2139        STCLASS=BASED);
 2140
 2141      %LSET LISTDIR='0'B;
 2142      %LSET LISTEXP='1'B;
 2143      %LSET LISTCOM='0'B;
 2144      %LSET LISTSUB='1'B;
 2145
 2146      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          59   
 2147      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2148      %LSET INIT=CHARTEXT(' INIT');
 2149      %LSET EINIT=CHARTEXT('');
 2150      %ELSE;
 2151      %LSET INIT=CHARTEXT('/*');
 2152      %LSET EINIT=CHARTEXT('*/');
 2153      %ENDIF;
 2154
 2155      %IF LVL=1;
 2156      DCL 1 FPTN STCLASS ALGN,
 2157      %ELSE;
 2158              %LVL FPTN,
 2159      %ENDIF;
 2160                %(LVL+1) * BIT(8) %INIT('0'B)%EINIT,
 2161                %(LVL+1) %CHARTEXT('EUF BIT(1)') %INIT(EUF)%EINIT,
 2162                          /*N* EUF = VALUE-BIT(1).  Set on Exponent Underflow;
 2163                          i.e. when the result of an operation has an exponent
 2164                          value of 128 too large.
 2165                          When generating a STATIC or CONSTANT structure, this
 2166                          field may be initialized by specifying EUF={G_ON# | G_OFF#}.
 2167                          */
 2168                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
 2169                %(LVL+1) %CHARTEXT('SE BIT(1)') %INIT(SE)%EINIT,
 2170                          /*N* SE = VALUE-BIT(1).  Set on Significance Error.
 2171                          */
 2172                %(LVL+1) %CHARTEXT('PE BIT(1)') %INIT(PE)%EINIT,
 2173                          /*N* PE = VALUE-BIT(1).  Set on a Precision Error.
 2174                          */
 2175                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT,
 2176                %(LVL+1) %CHARTEXT('G BIT(1)') %INIT(G)%EINIT,
 2177                          /*N* G = VALUE-BIT(1).  The Greater-than Indicator
 2178                          contains the results of the last compare instruction
 2179                          executed by the computer.
 2180                          When generating a STATIC or CONSTANT structure, this
 2181                          field may be initialized by specifying G={G_ON# | G_OFF#}.
 2182                          */
 2183                %(LVL+1) %CHARTEXT('L BIT(1)') %INIT(L)%EINIT,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          60   
 2184                          /*N* L = VALUE-BIT(1).  The Less-than Indicator
 2185                          contains the results of the last compare instruction
 2186                          executed by the computer.
 2187                          When generating a STATIC or CONSTANT structure, this
 2188                          field may be initialized by specifying L={G_ON# | G_OFF#}.
 2189                          */
 2190                %(LVL+1) * BIT(1) %INIT('0'B)%EINIT LAST
 2191      %MEND;
 2192
 2193
 2194
 2195
 2196
 2197                          /*F*   NAME: G$STACK_HDR
 2198                          The G$STACK_HDR macro may be used to generate
 2199                          a structure for the header for the header of a
 2200                          stack that is to be managed by the hardware
 2201                          stack instructions.
 2202                          */
 2203
 2204      %MACRO G$STACK_HDR (FPTN=G$STACK_HDR,
 2205                          STCLASS=BASED,ALGN=ALIGNED);
 2206
 2207      %LSET LISTDIR='0'B;
 2208      %LSET LISTEXP='1'B;
 2209      %LSET LISTCOM='0'B;
 2210      %LSET LISTSUB='1'B;
 2211      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2212      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2213      %LSET INIT=CHARTEXT(' INIT');
 2214      %LSET EINIT=CHARTEXT('');
 2215      %ELSE;
 2216      %LSET INIT=CHARTEXT('/*');
 2217      %LSET EINIT=CHARTEXT('*/');
 2218      %ENDIF;
 2219
 2220      DCL 1 FPTN STCLASS ALGN,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          61   
 2221            2 %CHARTEXT('CW') SBIN %INIT(CW)%EINIT,
 2222                          /*K*  CW - SBIN contains the current number of words in use
 2223                                for the stack.
 2224                          */
 2225            2 %CHARTEXT('MW UBIN') %INIT(MW)%EINIT,
 2226                          /*K*  MW - UBIN contains the maximum stack size in words.
 2227                          */
 2228            2 MBN1 PTR %INIT(ADDR(NIL))%EINIT,
 2229            2 MBN2 PTR %INIT(ADDR(NIL))%EINIT;
 2230
 2231      %MEND;
 2232
 2233
 2234
 2235                          /*F*   NAME: G$STATUS_REG
 2236
 2237                          The G$STATUS_REG macro may be used to generate
 2238                          a structure that contains the Status Register.
 2239
 2240                          The fields of the Status Register are:
 2241                          */
 2242
 2243      %MACRO G$STATUS_REG (FPTN=G$STATUS_REG,
 2244        QLT='0'B,
 2245        ID='00'B,
 2246        LEVEL=0,
 2247        RING(G_RING0#='11'B,G_R_MON#='10'B,G_R_CPDB#='01'B,G_R_USR#='00'B,ANY)='00'B,
 2248        LVL=1,
 2249        LAST(YES=";",NO=",",ANY)=";",
 2250        ALGN=WALIGNED,
 2251        STCLASS=BASED);
 2252
 2253      %LSET LISTDIR='0'B;
 2254      %LSET LISTEXP='1'B;
 2255      %LSET LISTCOM='0'B;
 2256      %LSET LISTSUB='1'B;
 2257
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          62   
 2258      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2259      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2260      %LSET INIT=CHARTEXT(' INIT');
 2261      %LSET EINIT=CHARTEXT('');
 2262      %ELSE;
 2263      %LSET INIT=CHARTEXT('/*');
 2264      %LSET EINIT=CHARTEXT('*/');
 2265      %ENDIF;
 2266
 2267      %IF LVL=1;
 2268      DCL 1 FPTN STCLASS ALGN,
 2269      %ELSE;
 2270              %LVL FPTN,
 2271      %ENDIF;
 2272                %(LVL+1) %CHARTEXT('QLT BIT(1)') %INIT(QLT*0)%EINIT,
 2273                          /*K* QLT = VALUE-BIT(1)
 2274                               indicates whether a unit in the system has successfully
 2275                               completed its Quality Logic Test or not.
 2276                              }
 2277                              }    0 = QLT successfully completed.
 2278                              }    1 = QLT either still running or failed
 2279                              }
 2280                               .XEQ
 2281                               Default = '0'B.
 2282                          */
 2283                %(LVL+1) %CHARTEXT('RING BIT(2)') %INIT(RING*0)%EINIT,
 2284                          /*K* RING = VALUE-BIT(2)
 2285                               contains the currently active
 2286                               Ring value.  Note that ring values are always
 2287                               encoded as ones complement whenever they appear.
 2288                               Thus this field will contain one of the following:
 2289                              }
 2290                              }     11 = Ring 0 - the most privileged; used by the Monitor
 2291                              }     10 = Ring 1 - also privileged and used by the Monitor
 2292                              }     01 = Ring 2 - Command Processor or Debugger
 2293                              }     00 = Ring 3 - User
 2294                              }
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          63   
 2295                               .XEQ
 2296                               This field may be initialized by specifying
 2297                               {G_RING0# | G_R_MON# | G_R_CPDB# | G_R_USR#}.
 2298                               The default is G_R_USR#.
 2299                          */
 2300                %(LVL+1) * BIT(5) %INIT('0'B*0)%EINIT,
 2301                %(LVL+1) %CHARTEXT('ID BIT(2)') %INIT(ID*0)%EINIT,
 2302                          /*K* ID = VALUE-BIT(2)
 2303                               is the processor identification which
 2304                               is hard-wired and cannot be changed under
 2305                               program control.  These 2 bits are used as the least
 2306                               significant bits of the 10-bit channel number for
 2307                               the processor itself, where the 8 high order bits
 2308                               are always ZERO.
 2309                               .XEQ
 2310                               The default is '00'B.
 2311                          */
 2312                %(LVL+1) %CHARTEXT('LEVEL UBIN(6)UNAL') %INIT(LEVEL*0)%EINIT LAST
 2313                          /*K* LEVEL = VALUE-UBIN(6)
 2314                               contains the interrupt priority level on which the processor
 2315                               is currently executing.  Level 0 is the highest
 2316                               priority level and 63 is the lowest.
 2317                               .XEQ
 2318                               The default is 0.
 2319                          */
 2320      %MEND;
 2321
 2322
 2323
 2324
 2325
 2326
 2327                          /*F*   NAME: G$TRAP_VECTOR.
 2328
 2329                          The G$TRAP_VECTOR macro may be used to generate
 2330                          the trap vector.
 2331
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          64   
 2332                          The following labels may be used to address
 2333                          individual pointers within the Trap Vector:
 2334                          */
 2335
 2336      %MACRO G$TRAP_VECTOR (FPTN=G$TRAP_VECTOR,
 2337        LVL=1,
 2338        LAST(YES=";",NO=",",ANY)=";",
 2339        ALGN=WALIGNED,
 2340        STCLASS=BASED);
 2341
 2342      %LSET LISTDIR='0'B;
 2343      %LSET LISTEXP='1'B;
 2344      %LSET LISTCOM='0'B;
 2345      %LSET LISTSUB='1'B;
 2346
 2347      %IF LVL=1;
 2348      DCL 1 FPTN STCLASS ALGN,
 2349      %ELSE;
 2350              %LVL FPTN,
 2351      %ENDIF;
 2352                %(LVL+1) RFU_1(0:12) PTR,
 2353                %(LVL+1) T#32$ PTR,
 2354                %(LVL+1) EXT_PROT$ REDEF T#32$ PTR,
 2355                          /*K* EXT_PROT$ = PTR.  Contains the address of the routine
 2356                          to be entered on an external protection trap.
 2357                          */
 2358                %(LVL+1) T#33$ PTR,
 2359                %(LVL+1) S_ARG$ REDEF T#33$ PTR,
 2360                          /*N* S_ARG$ = PTR.  Contains the address of the routine
 2361                          to be entered on a SIP illegal argument trap.
 2362                          */
 2363                %(LVL+1) T#31$ PTR,
 2364                %(LVL+1) SIP_QLT$ REDEF T#31$ PTR,
 2365                          /*N* SIP_QLT$ = PTR.  Contains the address of the routine
 2366                          to be entered on a SIP QLT failure.
 2367                          */
 2368                %(LVL+1) T#30$ PTR,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          65   
 2369                %(LVL+1) CIP_QLT$ REDEF T#30$ PTR,
 2370                          /*K* CIP_QLT$ = PTR contains the address of the
 2371                          routine to be entered on a CIP QLT failure.
 2372                          */
 2373                %(LVL+1) T#29$ PTR,
 2374                %(LVL+1) C_OV$ REDEF T#29$ PTR,
 2375                          /*K* C_OV$ = PTR contains the address of the
 2376                          routine to be entered on a Commercial Overflow trap.
 2377                          */
 2378                %(LVL+1) T#28$ PTR,
 2379                %(LVL+1) C_TRUNC$ REDEF T#28$ PTR,
 2380                          /*K* C_TRUNC$ = PTR contains the address of the
 2381                          routine to be entered on a CIP Truncation error.
 2382                          */
 2383                %(LVL+1) T#27$ PTR,
 2384                %(LVL+1) C_CHAR$ REDEF T#27$ PTR,
 2385                          /*K* C_CHAR$ = PTR contains the address of the
 2386                          routine to be entered on a CIP Illegal Character trap.
 2387                          */
 2388                %(LVL+1) T#26$ PTR,
 2389                %(LVL+1) C_SPEC$ REDEF T#26$ PTR,
 2390                          /*K* C_SPEC$ = PTR contains the address of the
 2391                          routine to be entered on the occurrence of a CIP
 2392                          Illegal Specification trap.
 2393                          */
 2394                %(LVL+1) T#25$ PTR,
 2395                %(LVL+1) C_DBZ$ REDEF T#25$ PTR,
 2396                          /*K* C_DBZ$ = PTR contains the address of the
 2397                          routine to be entered on a CIP Divide by Zero trap.
 2398                          */
 2399                %(LVL+1) T#24$ PTR,
 2400                %(LVL+1) EXT_MBE$ REDEF T#24$ PTR,
 2401                          /*K* EXT_MBE$ = PTR contains the address of the
 2402                          routine to be entered on an external (CIP or SIP)
 2403                          Memory or Bus error.
 2404                          */
 2405                %(LVL+1) T#23$ PTR,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          66   
 2406                %(LVL+1) EXT_UR$ REDEF T#23$ PTR,
 2407                          /*K* EXT_UR$ = PTR contains the address of the
 2408                          routine to be entered on an external (CIP or SIP)
 2409                          reference to an unavailable resource.
 2410                          */
 2411                %(LVL+1) T#22$ PTR,
 2412                %(LVL+1) S_PRECISION$ REDEF T#22$ PTR,
 2413                          /*N* S_PRECISION$ = PTR.  Contains the address of the
 2414                          routine to be entered on the occurrence of a SIP
 2415                          precision error.
 2416                          */
 2417                %(LVL+1) T#21$ PTR,
 2418                %(LVL+1) S_SIGNIF$ REDEF T#21$ PTR,
 2419                          /*N* S_SIGNIF$ = PTR.  Contains the address of the
 2420                          routine to be entered on the occurrence of a SIP
 2421                          significance error.
 2422                          */
 2423                %(LVL+1) T#20$ PTR,
 2424                %(LVL+1) S_PROG_ERR$ REDEF T#20$ PTR,
 2425                          /*N* S_PROG_ERR$ = PTR.  Contains the address of the
 2426                          routine to be entered on a SIP Program Error trap.
 2427                          */
 2428                %(LVL+1) T#19$ PTR,
 2429                %(LVL+1) S_EXP_UF$ REDEF T#19$ PTR,
 2430                          /*N* S_EXP_UF$ = PTR.  Contains the address of the
 2431                          routine to be entered on a SIP Exponent Underflow trap.
 2432                          */
 2433                %(LVL+1) T#18$ PTR,
 2434                                    /* RFU                                                              */
 2435                %(LVL+1) T#17$ PTR,
 2436                %(LVL+1) INT_MBE$ REDEF T#17$ PTR,
 2437                          /*K* INT_MBE$ = PTR contains the address of the
 2438                          routine to be entered on an internal Memory or
 2439                          Bus error.
 2440                          */
 2441                %(LVL+1) T#16$ PTR,
 2442                %(LVL+1) PROG_ERR$ REDEF T#16$ PTR,
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          67   
 2443                          /*K* PROG_ERR$ = PTR contains the address of the
 2444                          routine to be entered on a Program Error trap.
 2445                          */
 2446                %(LVL+1) T#15$ PTR,
 2447                %(LVL+1) INT_UR$ REDEF T#15$ PTR,
 2448                          /*K* INT_UR$ = PTR contains the address of the
 2449                          routine to be entered on an internal reference
 2450                          to an unavailable resource.
 2451                          */
 2452                %(LVL+1) T#14$ PTR,
 2453                %(LVL+1) MEM_PROT$ REDEF T#14$ PTR,
 2454                          /*K* MEM_PROT$ = PTR contains the address of the
 2455                          routine to be entered on an unauthorized reference
 2456                          to protected memory.
 2457                          */
 2458                %(LVL+1) T#13$ PTR,
 2459                %(LVL+1) PRIV$ REDEF T#13$ PTR,
 2460                          /*K* PRIV$ = PTR contains the address of the routine
 2461                          to be entered on a privilege violation.
 2462                          */
 2463                %(LVL+1) T#12$ PTR,
 2464                %(LVL+1) REMOTE_DESC$ REDEF T#12$ PTR,
 2465                          /*K*   REMOTE_DESC$ = PTR contains the address of
 2466                          the routine to be entered on a Remote Descriptor trap.
 2467                          */
 2468                %(LVL+1) T#11$ PTR,
 2469                                    /* RFU                                                              */
 2470                %(LVL+1) T#10$ PTR,
 2471                %(LVL+1) STK_OV$ REDEF T#10$ PTR,
 2472                          /*K* STK_OV$ = PTR contains the address of the routine
 2473                          to be entered on the occurrence of a Stack Overflow error.
 2474                          */
 2475                %(LVL+1) T#09$ PTR,
 2476                %(LVL+1) STK_UF$ REDEF T#09$ PTR,
 2477                          /*K* STK_UF$ = PTR contains the address of the routine
 2478                          to be entered on the occurrence of a Stack Underflow error.
 2479                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          68   
 2480                %(LVL+1) T#08$ PTR,
 2481                %(LVL+1) S_EXP_OV$ REDEF T#08$ PTR,
 2482                          /*N* S_EXP_OV$ = PTR.  Contains the address of the routine
 2483                          to be entered on the occurrence of a SIP Exponent Overflow error.
 2484                          */
 2485                %(LVL+1) T#07$ PTR,
 2486                %(LVL+1) S_DBZ$ REDEF T#07$ PTR,
 2487                          /*N* S_DBZ$ = PTR.  Contains the address of the
 2488                          routine to be entered on a SIP Divide by Zero trap.
 2489                          */
 2490                %(LVL+1) T#06$ PTR,
 2491                %(LVL+1) INT_REG_OV$ REDEF T#06$ PTR,
 2492                          /*K* INT_REG_OV$ = PTR contains the address of
 2493                          the routine to be entered of the occurrence of an
 2494                          integer register overflow.
 2495                          */
 2496                %(LVL+1) T#05$ PTR,
 2497                %(LVL+1) UNIMPL$ REDEF T#05$ PTR,
 2498                          /*K* UNIMPL$ = PTR contains the address of the routine
 2499                          to be entered on an unimplemented instruction trap.
 2500                          */
 2501                %(LVL+1) T#04$ PTR,
 2502                                    /* RSU                                                              */
 2503                %(LVL+1) T#03$ PTR,
 2504                %(LVL+1) NO_SIP$ REDEF T#03$ PTR,
 2505                          /*K* NO_SIP$ = PTR contains to address of the routine
 2506                          to be entered on an Uninstalled SIP instruction.
 2507                          */
 2508                %(LVL+1) T#02$ PTR,
 2509                %(LVL+1) TRACE$ REDEF T#02$ PTR,
 2510                          /*K* TRACE$ = PTR contains the address of the routine
 2511                          to be entered when a jump or branch is executed.
 2512                          */
 2513                %(LVL+1) T#01$ PTR,
 2514                %(LVL+1) MCL$ REDEF T#01$ PTR LAST
 2515                          /*K* MCL$ = PTR contains the address of the
 2516                          routine to be entered when a Monitor Call instruction
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          69   
 2517                          is executed.
 2518                          */
 2519      %MEND;
 2520
 2521
 2522
 2523
 2524
 2525
 2526                          /*F*   NAME: G$TSA
 2527
 2528                          The G$TSA macro may be used to generate
 2529                          a structure that defines the entire
 2530                          Trap Save Area.  This includes the
 2531                          header where information is stored
 2532                          by the hardware, and the extension
 2533                          where the rest of the environment is
 2534                          stored by the LCP-6 trap handler.
 2535
 2536                          */
 2537                                    /*
 2538                                    The G$TSA_HDR macro is invoked using
 2539                                    the name specified via the FPTN parameter
 2540                                    which will determine the name of the
 2541                                    structure.  This is followed by the
 2542                                    following fields:
 2543                                    */
 2544
 2545      %MACRO G$TSA (FPTN=G$TSA,
 2546        SAVE_SIP(YES=1,NO=0,ANY)=0,
 2547        TSAL$=NIL,
 2548        LVL=1,
 2549        LAST(YES=";",NO=",",ANY)=";",
 2550        ALGN=WALIGNED,
 2551        STCLASS=BASED);
 2552
 2553      %LSET LISTDIR='0'B;
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          70   
 2554      %LSET LISTEXP='1'B;
 2555      %LSET LISTCOM='0'B;
 2556      %LSET LISTSUB='1'B;
 2557
 2558      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2559      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2560      %LSET INIT=CHARTEXT(' INIT');
 2561      %LSET EINIT=CHARTEXT('');
 2562      %ELSE;
 2563      %LSET INIT=CHARTEXT('/*');
 2564      %LSET EINIT=CHARTEXT('*/');
 2565      %ENDIF;
 2566
 2567                %G$TSA_HDR (FPTN=FPTN,TSAL$=TSAL$,LVL=LVL,STCLASS=STCLASS,LAST=",");
 2568                          /*K* TSAL$ - PTR
 2569                          .XEQ GH_LCP6_M G$TSA_HDR TSAL$
 2570                          */
 2571                          /*K* I - BIT(16)
 2572                          .XEQ GH_LCP6_M G$TSA_HDR I
 2573                          */
 2574                          /*K* I.TRAP# - UBIN(8)
 2575                          .XEQ GH_LCP6_M G$INDICATOR_REG TRAP#
 2576                          */
 2577                          /*K* I.OV - BIT(1)
 2578                          .XEQ GH_LCP6_M G$INDICATOR_REG OV
 2579                          */
 2580                          /*K* I.C - BIT(1)
 2581                          .XEQ GH_LCP6_M G$INDICATOR_REG C
 2582                          */
 2583                          /*K* I.B - BIT(1)
 2584                          .XEQ GH_LCP6_M G$INDICATOR_REG B
 2585                          */
 2586                          /*K* I.IO - BIT(1)
 2587                          .XEQ GH_LCP6_M G$INDICATOR_REG IO
 2588                          */
 2589                          /*K* I.G - BIT(1)
 2590                          .XEQ GH_LCP6_M G$INDICATOR_REG G
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          71   
 2591                          */
 2592                          /*K* I.L - BIT(1)
 2593                          .XEQ GH_LCP6_M G$INDICATOR_REG L
 2594                          */
 2595                          /*K* I.U - BIT(1)
 2596                          .XEQ GH_LCP6_M G$INDICATOR_REG U
 2597                          */
 2598                          /*K* R3 - UBIN WORD
 2599                          .XEQ GH_LCP6_M G$TSA_HDR R3
 2600                          */
 2601                          /*K* INST - UBIN WORD
 2602                          .XEQ GH_LCP6_M G$TSA_HDR INST
 2603                          */
 2604                          /*K* Z - BIT(16)
 2605                          .XEQ GH_LCP6_M G$TSA_HDR Z
 2606                          */
 2607                          /*K* Z.REG - BIT(1)
 2608                          .XEQ GH_LCP6_M G$TSA_HDR Z.REG
 2609                          */
 2610                          /*K* Z.BI - BIT(4)
 2611                          .XEQ GH_LCP6_M G$TSA_HDR Z.BI
 2612                          */
 2613                          /*K* Z.R - BIT(2)
 2614                          .XEQ GH_LCP6_M G$TSA_HDR Z.R
 2615                          */
 2616                          /*K* Z.IS - UBIN(4)
 2617                          .XEQ GH_LCP6_M G$TSA_HDR Z.IS
 2618                          */
 2619                          /*K* A$ - PTR
 2620                          .XEQ GH_LCP6_M G$TSA_HDR A$
 2621                          */
 2622                          /*K* P$$ - EPTR
 2623                          .XEQ GH_LCP6_M G$TSA_HDR P$$
 2624                          */
 2625                          /*K* B3$ - PTR
 2626                          .XEQ GH_LCP6_M G$TSA_HDR B3$
 2627                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          72   
 2628
 2629      %LSET TSA_NXT_LVL=LVL+1;
 2630
 2631              %G$STATUS_REG (FPTN=S,STCLASS=STCLASS,LVL=TSA_NXT_LVL,LAST=",");
 2632                          /*K* S - BIT(16) contains the contents of the
 2633                          Status Register at the time of the trap:
 2634                          */
 2635                          /*K* S.QLT - BIT(1)
 2636                          .XEQ GH_LCP6_M G$STATUS_REG QLT
 2637                          */
 2638                          /*K* S.RING - BIT(2)
 2639                          .XEQ GH_LCP6_M G$STATUS_REG RING
 2640                          */
 2641                          /*K* S.ID - BIT(2)
 2642                          .XEQ GH_LCP6_M G$STATUS_REG ID
 2643                          */
 2644                          /*K* S.LEVEL - UBIN(6)
 2645                          .XEQ GH_LCP6_M G$STATUS_REG LEVEL
 2646                          */
 2647              %G$ISA (FPTN=ISA,STCLASS=STCLASS,LVL=TSA_NXT_LVL,
 2648              SAVE_SIP=SAVE_SIP,LAST=LAST);
 2649                          /*K* ISA contains the contents of the hardware environment
 2650                          as stored by a level change within the trap handler.
 2651                          See G$ISA
 2652                          for the names and meanings of the individual fields
 2653                          within ISA.
 2654                          */
 2655      %MEND;
 2656
 2657
 2658
 2659
 2660
 2661
 2662                          /*F*   NAME: G$TSA_HDR
 2663
 2664                          The G$TSA_HDR macro may be used to generate
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          73   
 2665                          a structure that contains the environment
 2666                          as saved by the hardware when a trap occurs.
 2667
 2668                          After saving the following words, the
 2669                          hardware will set B3 to point to G$TSA_HDR.A$:
 2670                          */
 2671
 2672      %MACRO G$TSA_HDR (FPTN=G$TSA_HDR,
 2673        TSAL$=NIL,
 2674        LVL=1,
 2675        LAST(YES=";",NO=",",ANY)=";",
 2676        ALGN=WALIGNED,
 2677        STCLASS=BASED);
 2678
 2679      %LSET LISTDIR='0'B;
 2680      %LSET LISTEXP='1'B;
 2681      %LSET LISTCOM='0'B;
 2682      %LSET LISTSUB='1'B;
 2683
 2684      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2685      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2686      %LSET INIT=CHARTEXT(' INIT');
 2687      %LSET EINIT=CHARTEXT('');
 2688      %ELSE;
 2689      %LSET INIT=CHARTEXT('/*');
 2690      %LSET EINIT=CHARTEXT('*/');
 2691      %ENDIF;
 2692
 2693      %IF LVL=1;
 2694      DCL 1 FPTN STCLASS ALGN,
 2695      %ELSE;
 2696              %LVL FPTN,
 2697      %ENDIF;
 2698      %LSET TSAH_NXT_LVL=LVL+1;
 2699
 2700                %(LVL+1) %CHARTEXT('TSAL$ PTR') %INIT(ADDR(TSAL$))%EINIT,
 2701                          /*K* TSAL$ -  PTR
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          74   
 2702                          contains the Trap Save Area Link.
 2703                          When the TSA is in use, this pointer will be null if this
 2704                          is the only or last trap save area connected to the ISA, or
 2705                          it will point to the next TSA connected to the ISA.
 2706                          .XEQ
 2707                          The default is NIL.
 2708                          */
 2709                %G$INDICATOR_REG (FPTN=I,STCLASS=STCLASS,LVL=TSAH_NXT_LVL,LAST=",");
 2710                          /*K* I - BIT(16)
 2711                          contains the trap number
 2712                          and the contents of the Indicator Register at the
 2713                          time of the trap:
 2714                          */
 2715                          /*K* I.TRAP# - UBIN(8)
 2716                          .XEQ GH_LCP6_M G$INDICATOR_REG TRAP#
 2717                          */
 2718                          /*K* I.OV - BIT(1)
 2719                          .XEQ GH_LCP6_M G$INDICATOR_REG OV
 2720                          */
 2721                          /*K* I.C - BIT(1)
 2722                          .XEQ GH_LCP6_M G$INDICATOR_REG C
 2723                          */
 2724                          /*K* I.B - BIT(1)
 2725                          .XEQ GH_LCP6_M G$INDICATOR_REG B
 2726                          */
 2727                          /*K* I.IO - BIT(1)
 2728                          .XEQ GH_LCP6_M G$INDICATOR_REG IO
 2729                          */
 2730                          /*K* I.G - BIT(1)
 2731                          .XEQ GH_LCP6_M G$INDICATOR_REG G
 2732                          */
 2733                          /*K* I.L - BIT(1)
 2734                          .XEQ GH_LCP6_M G$INDICATOR_REG L
 2735                          */
 2736                          /*K* I.U - BIT(1)
 2737                          .XEQ GH_LCP6_M G$INDICATOR_REG U
 2738                          */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          75   
 2739              %(LVL+1) R3 UBIN WORD %INIT(0)%EINIT,
 2740                          /*K* R3 - UBIN WORD
 2741                          contains the contents of R3 register at the time
 2742                          of the trap.
 2743                          */
 2744              %(LVL+1) INST,
 2745                          /*K* INST - UBIN WORD
 2746                          contains the first word of the current instruction.
 2747                          */
 2748              %(LVL+2) H1 BIT(4) %INIT('0'B)%EINIT,
 2749              %(LVL+2) OP_CODE BIT(5) %INIT('0'B)%EINIT,
 2750              %(LVL+2) * BIT(7) %INIT('0'B)%EINIT,
 2751              %(LVL+1) Z,
 2752                          /*K* Z - BIT(16)
 2753                          contains miscellaneous information
 2754                          relative to the trap as follows:
 2755                          */
 2756              %(LVL+2) REG BIT(1) %INIT('0'B)%EINIT,
 2757                          /*K* Z.REG - BIT(1)
 2758                          indicates, if set, that address A is
 2759                          meaningless (e.g. Register address form).
 2760                          */
 2761              %(LVL+2) * BIT(3) %INIT('0'B)%EINIT,
 2762              %(LVL+2) BI BIT(4) %INIT('0'B)%EINIT,
 2763                          /*K* Z.BI - BIT(4)
 2764                          has the following meaning when indexing is
 2765                          specified in the AS:
 2766                              }
 2767                              }    For bit instructions:  4 low order bits of the selected
 2768                              }                           index register.
 2769                              }    For byte instructions: 1st bit contains low order bit
 2770                              }                           of the selected index register.
 2771                              }
 2772                          */
 2773              %(LVL+2) R BIT(2) %INIT('0'B)%EINIT,
 2774                          /*K* Z.R - BIT(2)
 2775                          contains the saved ring number from
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          76   
 2776                          the System Status Register of the trapped procedure.
 2777                          */
 2778              %(LVL+2) * BIT(2) %INIT('0'B)%EINIT,
 2779              %(LVL+2) %CHARTEXT('IS UBIN(4)UNAL') %INIT(0)%EINIT,
 2780                          /*K* Z.IS - UBIN(4)
 2781                          contains the trapping Instruction Size.
 2782                          */
 2783              %(LVL+1) A$ PTR %INIT(ADDR(NIL))%EINIT,
 2784                          /*K* A$ - PTR
 2785                          contains an address associated with the trap.
 2786                          */
 2787              %(LVL+1) P$$ EPTR %INIT(ENTADDR(NIL))%EINIT,
 2788              %(LVL+1) P$ REDEF P$$ PTR,
 2789              %(LVL+1) P REDEF P$$ SBIN(32),
 2790                          /*K* P$$ - EPTR
 2791                          contains the Program Counter at the time of the trap.
 2792                          */
 2793              %(LVL+1) B3$ PTR %INIT(ADDR(NIL))%EINIT LAST
 2794                          /*K* B3$ - PTR
 2795                          contains the contents of the B3 register at the
 2796                          time of the trap.
 2797                          */
 2798      %MEND;
 2799
 2800
 2801
 2802                          /*F*   NAME:   G$VECTOR
 2803
 2804                          The G$VECTOR macro generates a structure that
 2805                          defines the LCP-6 vector.
 2806
 2807                          There are no provisions for specification of
 2808                          initial values.  The default for STCLASS is BASED.
 2809
 2810                          The fields within this structure are as follows:
 2811                          */
 2812
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          77   
 2813      %MACRO G$VECTOR (FPTN=G$VECTOR,STCLASS=BASED);
 2814
 2815      DCL 1 FPTN STCLASS ALIGNED,
 2816            2 BND UBIN WORD,
 2817                          /*K* BND - UBIN  contains the bound
 2818                          (size-1) of the area framed by this vector.
 2819                          */
 2820            2 BASE$ PTR,
 2821                          /*K* BASE$ - PTR  contains the base
 2822                          address of the data framed by this vector.
 2823                          This field is REDEFed as CPTR$ and CBASE.
 2824                          */
 2825            2 CPTR$ REDEF BASE$ CPTR,
 2826                          /*K* CPTR$ - CPTR redefines BASE$.
 2827                          */
 2828            2 CBASE REDEF BASE$,
 2829              3 C BIT(1) UNAL,
 2830                          /*K* CBASE.C - BIT(1)  indicates, if set,
 2831                          that the pointer is a character pointer.
 2832                          */
 2833              3 MBZ UBIN(11) UNAL,
 2834              3 ADDRS UBIN(20) UNAL;
 2835                          /*K* CBASE.ADDRS - VALUE-UBIN(20)  contains a
 2836                          UBIN value for the base address of the
 2837                          data framed by this vector.
 2838                          */
 2839      %MEND;
 2840
 2841
 2842
 2843
 2844
 2845                          /*F*   NAME: G$INTCON - INTERRUPT CONTROL TABLE.
 2846
 2847                          The G$INTCON MACRO generates that portion of MHJIT
 2848                          containing the information used by the common interrupt
 2849                          handler to dispatch the interrupts.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          78   
 2850
 2851                          The data-generating form initializes everything to default.
 2852                          The only option is whether the structure is to be an array
 2853                          and is spelled "ARRAYED=YES or NO".
 2854                          */
 2855      %MACRO G$INTCON(FPTN=G$INTCON,STCLASS=BASED,LVL=1,
 2856                    ARRAYED=YES,LAST(YES=";",NO=",",ANY)=";");
 2857      %LSET LISTDIR='0'B;
 2858      %LSET LISTEXP='1'B;
 2859      %LSET LISTSUB='1'B;
 2860      %LSET LISTCOM='0'B;
 2861      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2862      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2863      %LSET INIT=CHARTEXT(' INIT');
 2864      %LSET EINIT=CHARTEXT('');
 2865      %ELSE;
 2866      %LSET INIT=CHARTEXT('/*');
 2867      %LSET EINIT=CHARTEXT('*/');
 2868      %ENDIF;
 2869
 2870      %LSET FPTN=CHARTEXT(TEXTCHAR(FPTN));
 2871      %LSET ILS=0;
 2872      %IF TEXTCHAR(ARRAYED)='YES';
 2873      %LSET FPTN=CHARTEXT(CONCAT(TEXTCHAR(FPTN),'(0:48)'));
 2874      %LSET ILS='12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,';
 2875      %LSET ILS=CONCAT(ILS,'31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,');
 2876      %LSET ILS=CHARTEXT(CONCAT(ILS,'51,52,53,54,55,56,57,58,59,60'));
 2877      %ENDIF;
 2878              %G$ISA_MINI(FPTN=%FPTN,STCLASS=STCLASS,LAST=NO,P$$=GHI$CIH_RECV,
 2879              IL=%ILS,RING=G_R_MON#,LVL=LVL);
 2880              %(LVL+1) HHJIT UBIN %INIT(0*0)%EINIT,
 2881              %(LVL+1) HJIT_PG REDEF HHJIT,
 2882                 %(LVL+2) V BIT(1) UNAL,
 2883                 %(LVL+2) * BIT(3) UNAL,
 2884                 %(LVL+2) BASE UBIN(12) UNAL,
 2885                          /*B* HHJIT - The page# of the HHJIT associated with the
 2886                          interrupt control. High bit is set, MMU-style.                                */
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          79   
 2887             %(LVL+1) USER UBIN(8) UNAL %INIT(0*0)%EINIT,
 2888                          /*B* USER - user-number allocated to the level.                               */
 2889             %(LVL+1) RUNLEVEL UBIN(8) UNAL %INIT(0*0)%EINIT,
 2890                          /*B* RUNLEVEL - See FPT_INTCON.                                               */
 2891             %(LVL+1) IENTRY EPTR %INIT(ENTADDR(NIL)*0)%EINIT,
 2892                          /*B* IENTRY - See M$INTCON.                                                   */
 2893             %(LVL+1) ALLOCATED BIT(1) %INIT('0'B*0)%EINIT,
 2894                          /*B* ALLOCATED - BIT(1). Indicates M$INTCON successfully
 2895                          executed for this level.                                                      */
 2896             %(LVL+1) PRIVILEGED BIT(1) %INIT('0'B*0)%EINIT,
 2897                          /*B* PRIVILEGED - See M$INTCON.                                               */
 2898             %(LVL+1) DOMYIO BIT(1) %INIT('0'B*0)%EINIT,
 2899                          /*B* DOMYIO - See M$INTCON.                                                   */
 2900             %(LVL+1) RUNNING BIT(1) %INIT('0'B*0)%EINIT,
 2901                          /*B* RUNNING - BIT(1). Set if an interrupt has occurred at
 2902                          this level and M$INTRET or auto-cleanup hasn't.                               */
 2903             %(LVL+1) CLEANUP BIT(1) %INIT('0'B*0)%EINIT,
 2904                          /*B* CLEANUP - BIT(1). Set to indicate that LEVEL-1 hasn't
 2905                          been cleaned up yet.                                                          */
 2906             %(LVL+1) RUNONLY BIT(1) %INIT('0'B*0)%EINIT,
 2907                          /*B* RUNONLY - BIT(1). Set if this is only a RUNLEVEL.
 2908                          If this flag is set, RUNLEVEL is actually the user#.                          */
 2909             %(LVL+1) MORE_FLAGS BIT(10) %INIT('0'B*0)%EINIT LAST
 2910      %MEND;
 2911
 2912
 2913
 2914                          /*F*   NAME: Special Services
 2915                          ..::L1 "Introduction\\X"
 2916                          The monitor services described in this section
 2917                          are intended for use only by the advanced system
 2918                          programmer and therefore, they are restricted.
 2919                          In many cases, the user must have special
 2920                          privileges before these services can be executed.
 2921
 2922                          */
 2923
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          80   
 2924
 2925                          /*F*   NAME: M$INTCON - Connect to Interrupt
 2926
 2927                          The M$INTCON service allows a user to specify the
 2928                          entry address of an interrupt processing routine
 2929                          that receives control when an interrupt of the
 2930                          specified level occurs on the user's CPU.
 2931
 2932                          The INTCON privilege is required to use this service.
 2933
 2934                          The form of the call for this service is:
 2935
 2936                          CALL M$INTCON (FPT_INTCON) [ALTRET (label)];
 2937
 2938                          The parameters for this service are as follows:
 2939
 2940                          */
 2941      %MACRO FPT_INTCON(FPTN=FPT_INTCON,STCLASS=STATIC,
 2942                    VECTORS=YES,
 2943                    LEVEL=0,
 2944                    IENTRY=NIL,
 2945                    RUNLEVEL=0,
 2946                    PRIVILEGED(YES='1'B,NO='0'B)='1'B,
 2947                    DOMYIO(YES='1'B,NO='0'B)='0'B);
 2948      %LSET LISTDIR='0'B;
 2949      %LSET LISTEXP='1'B;
 2950      %LSET LISTSUB='1'B;
 2951      %LSET LISTCOM='0'B;
 2952      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 2953      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 2954      %LSET INIT=CHARTEXT(' INIT');
 2955      %LSET EINIT=CHARTEXT('');
 2956      %ELSE;
 2957      %LSET INIT=CHARTEXT('/*');
 2958      %LSET EINIT=CHARTEXT('*/');
 2959      %ENDIF;
 2960
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          81   
 2961      DCL 1 FPTN STCLASS,
 2962      %IF TEXTCHAR(VECTORS)='YES';
 2963            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 2964      %ENDIF;
 2965            2 V,
 2966
 2967              3 IENTRY$ EPTR %INIT(ENTADDR(IENTRY))%EINIT,
 2968                          /*K* IENTRY = ENTRY specifies the interrupt procedure
 2969                          entry address.  A NIL specification relinquishes control
 2970                          of the interrupt level(s) otherwise specified in this FPT.
 2971                          The default is NIL.
 2972                          */
 2973              3 %CHARTEXT('LEVEL UBIN')%INIT(LEVEL)%EINIT,
 2974                          /*K* LEVEL = VALUE-DEC(12-59) specifies the interrupt
 2975                          level for which control is requested.  A value of zero
 2976                          (the default) indicates that this service request means
 2977                          only to allocate a RUNLEVEL.
 2978                          The default is 0.
 2979                          */
 2980              3 %CHARTEXT('RUNLEVEL UBIN')%INIT(RUNLEVEL)%EINIT,
 2981                          /*K* RUNLEVEL = VALUE-DEC(12-59) specifies the level at
 2982                          which IENTRY is to be entered as a result of an interrupt
 2983                          at LEVEL.  The default value of zero implies RUNLEVEL=LEVEL.
 2984
 2985                          This facility is NOT the same as a disable to RUNLEVEL, in
 2986                          that an enable instruction (LEV '803F'X,IMO) is equivalent
 2987                          to M$INTRET, not a return to execution at LEVEL.
 2988
 2989                          If RUNLEVEL is specified but LEVEL is not, then RUNLEVEL
 2990                          is simply reserved for this user as a disable level, to
 2991                          avoid conflicts with other users.
 2992                          The default is 0.
 2993                          */
 2994              3 %CHARTEXT('PRIVILEGED BIT(1)')%INIT(PRIVILEGED)%EINIT,
 2995                          /*K* PRIVILEGED = {YES|NO} specifies, if yes, that IENTRY
 2996                          is to be entered in RING-1 instead of RING-3. YES requires
 2997                          that the user be allowed to enter master mode (MSYS privilege).
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          82   
 2998                          The default is YES.
 2999                          */
 3000              3 %CHARTEXT('DOMYIO BIT(1)')%INIT(DOMYIO)%EINIT,
 3001                          /*N* DOMYIO = {YES|NO} specifies, if yes and (probably)
 3002                          PRIVILEGED is no, that the system trap handler is to
 3003                          execute the IO and IOLD instructions executed by IENTRY
 3004                          if they are of the same form as those in GHH$IO.
 3005                          The default is NO.
 3006                          */
 3007              3 * BIT(30) %INIT('0'B)%EINIT;
 3008      %MEND;
 3009                          /*F*   NAME: M$INTRET - Return from Interrupt
 3010
 3011                          The M$INTRET service should be used by a user
 3012                          interrupt processing routine to relinquish the CPU and
 3013                          wait for the next interrupt. It provides options to
 3014                          inform the main user program, if desired.
 3015
 3016                          The form of the call for this service is:
 3017
 3018                          CALL M$INTRET (FPT_INTRET) [ALTRET (label)];
 3019
 3020                          The parameters for this service are as follows:
 3021
 3022                          */
 3023      %MACRO FPT_INTRET(FPTN=FPT_INTRET,STCLASS=STATIC,
 3024                    VECTORS=YES,
 3025                    EVENT=0,
 3026                    WAKEME(YES='1'B,NO='0'B)='0'B,
 3027                    CHECKME(YES='1'B,NO='0'B)='0'B);
 3028      %LSET LISTDIR='0'B;
 3029      %LSET LISTEXP='1'B;
 3030      %LSET LISTSUB='1'B;
 3031      %LSET LISTCOM='0'B;
 3032      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3033      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3034      %LSET INIT=CHARTEXT(' INIT');
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          83   
 3035      %LSET EINIT=CHARTEXT('');
 3036      %ELSE;
 3037      %LSET INIT=CHARTEXT('/*');
 3038      %LSET EINIT=CHARTEXT('*/');
 3039      %ENDIF;
 3040
 3041      DCL 1 FPTN STCLASS,
 3042      %IF TEXTCHAR(VECTORS)='YES';
 3043            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 3044      %ENDIF;
 3045            2 V,
 3046
 3047              3 * UBIN %INIT(0)%EINIT,
 3048              3 %CHARTEXT('EVENT') SBIN %INIT(EVENT)%EINIT,
 3049                          /*K* EVENT = VALUE-DEC(1-n) specifies the event to be
 3050                          reported to the user main program to indicate the occurrence
 3051                          of the interrupt.
 3052
 3053                          EVENT and WAKEME are mutually exclusive options.  If both
 3054                          are specified, EVENT is honored and WAKEME is ignored.
 3055                          The default is 0.
 3056                          */
 3057              3 %CHARTEXT('WAKEME BIT(1)')%INIT(WAKEME)%EINIT,
 3058                          /*K* WAKEME = {YES|NO} specifies, if yes, that the user
 3059                          main program is to be awakened (if asleep) without
 3060                          reporting an event (see the EVENT option).
 3061                          The default is NO.
 3062                          */
 3063              3 %CHARTEXT('CHECKME BIT(1)')%INIT(CHECKME)%EINIT,
 3064                          /*N* CHECKME = {YES|NO} specifies, if yes that LCP-6 is to
 3065                          check that every level used during the processing of the
 3066                          interrupt was allocated by this user as a RUNLEVEL or an
 3067                          interrupt level (see M$INTCON).
 3068                          The default is NO.
 3069                          */
 3070              3 * BIT(30) %INIT('0'B)%EINIT;
 3071      %MEND;
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          84   
 3072                          /*F*   NAME: M$INTREL - Release Interrupt Control.
 3073
 3074                          The M$INTREL service is the complement of M$INTCON,
 3075                          providing a mechanism to release control of an interrupt
 3076                          level.
 3077
 3078                          The form of the call for this service is:
 3079
 3080                          CALL M$INTREL (FPT_INTREL) [ALTRET (label)];
 3081
 3082                          The parameters for this service are as follows:
 3083
 3084                          */
 3085      %MACRO FPT_INTREL(FPTN=FPT_INTREL,STCLASS=STATIC,
 3086                    VECTORS=YES,
 3087                    LEVEL=0);
 3088      %LSET LISTDIR='0'B;
 3089      %LSET LISTEXP='1'B;
 3090      %LSET LISTSUB='1'B;
 3091      %LSET LISTCOM='0'B;
 3092      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3093      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3094      %LSET INIT=CHARTEXT(' INIT');
 3095      %LSET EINIT=CHARTEXT('');
 3096      %ELSE;
 3097      %LSET INIT=CHARTEXT('/*');
 3098      %LSET EINIT=CHARTEXT('*/');
 3099      %ENDIF;
 3100
 3101      DCL 1 FPTN STCLASS,
 3102      %IF TEXTCHAR(VECTORS)='YES';
 3103            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 3104      %ENDIF;
 3105            2 V,
 3106
 3107              3 %CHARTEXT('LEVEL UBIN')%INIT(LEVEL)%EINIT;
 3108                          /*K* LEVEL = VALUE-DEC(12-59) specifies the level whose
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          85   
 3109                          control is to be relinquished.  The user must own the level
 3110                          to avoid an ALTRET.
 3111                          The default is 0.
 3112                          */
 3113      %MEND;
 3114                          /*F*   NAME: M$SYS - Enter Privileged Mode
 3115
 3116                          The M$SYS service provides a sufficiently privileged
 3117                          user the ability to enter privileged mode (in ring 1).
 3118
 3119                          The MSYS privilege is required to use this service.
 3120
 3121                          There is no FPT for M$SYS.
 3122
 3123                          The form of the call for this service is:
 3124
 3125                          CALL M$SYS [ALTRET (label)];
 3126                          */
 3127
 3128                          /*P*   NAME:   GH_MCL_E.
 3129
 3130                          The GH_MCL_E macro generates the specific values
 3131                          for the individual monitor service requests within
 3132                          the GH Functional Code Group.
 3133                          */
 3134
 3135      %MACRO GH_MCL_E;
 3136      %EQU G_MCL_INTRET# = G_FCG_H#*64+0;
 3137      %EQU G_MCL_INTCON# = G_FCG_H#*64+1;
 3138      %EQU G_MCL_INTREL# = G_FCG_H#*64+2;
 3139      %EQU G_MCL_SYS# = G_FCG_H#*64+3;
 3140      %MEND;
 3141
 3142
 3143
 3144
 3145
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          86   
 3146                          /*P*   NAME: GH$ENTS.
 3147
 3148                          The GH$ENTS macro generates the ENTRY declarations
 3149                          for the Monitor Services belonging to the GH
 3150                          Functional Code Group.
 3151                          */
 3152
 3153      %MACRO GH$ENTS;
 3154      DCL M$INTCON ENTRY(1) CONV(1,1,%G_MCL_INTCON#) ALTRET;
 3155      DCL M$INTRET ENTRY(1) CONV(1,1,%G_MCL_INTRET#) ALTRET;
 3156      DCL M$INTREL ENTRY(1) CONV(1,1,%G_MCL_INTREL#) ALTRET;
 3157      DCL M$SYS ENTRY(1) CONV(1,1,%G_MCL_SYS#) ALTRET;
 3158      %MEND;
 3159
 3160
 3161
 3162
 3163
 3164                          /*P*   NAME: GH_FPTS.
 3165
 3166                          The GH_FPTS macro provides the LCL-6 monitor services
 3167                          decoder with the information required to build the
 3168                          segment descriptors and pointers for each FPT within
 3169                          the GH Functional Code Group.
 3170                          */
 3171
 3172      %MACRO GH_FPTS (FPTN=GH_FPTS);
 3173
 3174      /* Generate the FCG_GH header word */
 3175      %GUD_FCG_INFO(C=%G_MCL_SYS#,FPTN=FPTN);
 3176      %GUD_MCL_INFO(C=%G_MCL_INTRET#,HAND=GHM$INTRET,V=1);
 3177      %GUD_VECT_INFO(BND=3);
 3178      %GUD_MCL_INFO(C=%G_MCL_INTCON#,HAND=GHM$INTCON,V=1);
 3179      %GUD_VECT_INFO(BND=9,MAND=YES);
 3180      %GUD_MCL_INFO(C=%G_MCL_INTREL#,HAND=GHM$INTREL,V=1);
 3181      %GUD_VECT_INFO(BND=1);
 3182      %GUD_MCL_INFO(C=%G_MCL_SYS#,HAND=GHM$SYS,V=0);
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          87   
 3183
 3184      %MEND;
 3185
 3186
 3187
 3188
 3189
 3190                          /*P*   NAME: GH$HANDLERS.
 3191
 3192                          The GH$HANDLERS macro generates the ENTRY declarations
 3193                          for the GH MCL handlers.
 3194                          */
 3195
 3196      %MACRO GH$HANDLERS;
 3197      DCL GHM$INTCON ENTRY(1) ALTRET;
 3198      DCL GHM$INTRET ENTRY(1) ALTRET;
 3199      DCL GHM$INTREL ENTRY(1) ALTRET;
 3200      DCL GHM$SYS ENTRY(1) ALTRET;
 3201      %MEND;
 3202
 3203      /*F* Name:  Calling Sequences for LCP-6
 3204      This document will define a number of standards for LCP-6.  There are
 3205      many similarities to the CP-6 operating system on the host but also
 3206      differences.  The following things are defined in this document:
 3207      ..::IX "calling^sequences"
 3208
 3209      .INL 4
 3210      .unl 4
 3211      1.  Certain system wide register conventions.
 3212      .unl 4
 3213      2.  Standard Calling and Receiving Sequences.
 3214      .unl 4
 3215      3.  Monitor Calling Sequences.
 3216      .unl 4
 3217      4.  Definition of formats of certain PL-6 data types with system
 3218      dependencies.
 3219      .inl 0
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          88   
 3220
 3221      Some of the motivations implicit in the following definition
 3222      of calling sequences are listed below:
 3223
 3224      .INL 4
 3225      .unl 4
 3226      1.  The calling sequences must take account of mixed
 3227      language programs with mixed storage types (static, automatic,
 3228      based).
 3229
 3230      .unl 4
 3231      2.  The linker should be able to verify calling sequence
 3232      matches, but mismatches should not cause disaster.
 3233
 3234      .unl 4
 3235      3.  Calling sequences will be generally in pure procedure
 3236      and thus must be run time constant, but must allow specification
 3237      of run time calculated addresses.
 3238
 3239      .unl 4
 3240      4.  The overhead associated with calling sequence interpretation
 3241      should be commensurate with the complexity of the call.
 3242      ..::L1 "Register^Conventions"
 3243      The following register usages will be adhered to in LCP-6:
 3244      ..::TB "LCP-6 Register Conventions\ Register\#3\Usage\#24\Saved on Calls\#"
 3245      .fif
 3246      }B7         Automatic Storage Pointer    Updated as necessary.
 3247      }                                        Saved on Monitor
 3248      }                                        calls.  Never modified
 3249      }                                        elsewhere.
 3250      }
 3251      }B6*        Link register to             Never
 3252      }           subroutines
 3253      }
 3254      }B5*        Link to intimate operators   Never
 3255      }           (e.g., allocate AUTO,etc.)
 3256      }
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          89   
 3257      }B4         Locates descriptor list      Never
 3258      }           described below.  Also
 3259      }           used as link register for
 3260      }           transfers to ALTRET code.
 3261      }
 3262      }B3         Locates pointer list         Saved on Monitor
 3263      }           described below.  Also       Calls.
 3264      }           locates FPT (vector list)
 3265      }           for Monitor Calls.
 3266      }
 3267      }B2,B1      Available                    Never
 3268      }
 3269      }R7-R4      Available                    Never
 3270      }
 3271      }R3         Monitor Service Code         Saved on Monitor
 3272      }                                        Calls.
 3273      }
 3274      }R2,R1      Available                    Never
 3275      }
 3276      }T          Used to control allocation   Never modified
 3277      }           of automatic storage.        except by auto
 3278      }                                        management
 3279      }                                        routines.
 3280      }
 3281      * Note that both LNJ,B6 and LNJ,B5 instructions are expected to be
 3282      followed by non-executable data words in a _l _l _ cases.  In the case of
 3283      LNJ,B6, the P-relative altret address or a value of 1 follows (one
 3284      word).  In the case of LNJ,B5, the contents depend on the function
 3285      but two words always follow.
 3286      .fin
 3287      ..::TB
 3288      ..::L1 "Calls^to Unknown^Routines"
 3289      All calls to external unknown routines must use the following
 3290      formats.  Calls to routines for performing intrinsic functions
 3291      or to internal (well known) subroutines may
 3292      deviate as required.  PL-6 will use the described calling
 3293      sequence for all external subroutine calls (except monitor calls).
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          90   
 3294
 3295      .brn 14
 3296      The basic form of the call is as follows:
 3297      .spf
 3298      .fif
 3299      }   Instruction             Comment
 3300      }   -----------             -------
 3301      .spf
 3302      }   [LAB,B3    PTR_LIST]    list of pointers to actual
 3303      }                           arguments.
 3304      }
 3305      }    LAB,B4    DESC_LIST    descriptors of actual
 3306      }                           arguments.
 3307      }
 3308      }    LNJ,B6    routine
 3309      }
 3310      }    DC        altret,PREL  Contains 1 if no ALTRET
 3311      .fin
 3312
 3313      .brn 7
 3314      where:
 3315      .spf
 3316      PTR_LIST^^^^is the list of PTRs and/or CPTRs to actual arguments
 3317      being passed.  This list of pointers is made up as necessary depending
 3318      on the complexity of the call.  When all arguments being passed are
 3319      in STATIC or CONSTANT storage, the list should be compiled as a
 3320      block of literals in constant storage.  The list must be
 3321      word aligned.
 3322
 3323      DESC_LIST^^^^defines the number of arguments being passed, and
 3324      optionally describes them in terms of data type, size, etc.
 3325      The list must be word aligned.  The number of arguments must be
 3326      specified.  The format of the description list at its present
 3327      state of definition is as follows:
 3328
 3329      .fif
 3330      }                ____________________________________
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          91   
 3331      }    DESC_LIST   | _# _  _o _f _  _a _r _g _u _m _e _n _t _s _  _| _  _# _  _o _f _  _d _e _s _c _r _i _p _t _i _o _n _s _| _
 3332      }                 0             7 8               15
 3333      .fin
 3334      ..::L2 "Receiving^Sequences"
 3335      The receiving sequence for all PL-6 subroutines will be one of
 3336      the following forms depending upon the form of storage used and the
 3337      type of procedure.
 3338
 3339      Note that the receiving sequences documented here are those that
 3340      will be used by PL-6 programs.  Other languages, while using the
 3341      same basic calling sequence, may alter the receiving sequences as
 3342      required by the language.
 3343      ..::TB "Procedure Entry Routines\Procedure Type\#6\Using AUTO\#5\Using STATIC (NOAUTO)\#"
 3344      .fif
 3345      MAIN                X6A_MAUTO      X6A_MSTATIC
 3346
 3347      ASYNC               X6A_AAUTO      X6A_ASTATIC
 3348
 3349      Callable -          X6A_AUTO_0     X6A_STATIC_0
 3350      0 Args Expected
 3351
 3352      Callable -          X6A_AUTO_1     X6A_STATIC_1
 3353      1 Arg Expected
 3354
 3355      Callable -          X6A_AUTO_2     X6A_STATIC_2
 3356      2 Args Expected
 3357
 3358      Callable -          X6A_AUTO_3     X6A_STATIC_3
 3359      3 Args Expected
 3360
 3361      Callable -          X6A_AUTO_N     X6A_STATIC_N
 3362      N Args Expected
 3363      ..::IX "Procedure^Entry^Routines"
 3364      ..::IX "X6A_MAUTO"
 3365      ..::IX "X6A_MSTATIC"
 3366      ..::TB
 3367      Each of the AUTO procedure entry routines listed above is entered
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          92   
 3368      upon procedure activation with the following sequence:
 3369
 3370      .fif
 3371      }    LNJ,B5   X6A_xxx
 3372      }    DC       Frameinfo
 3373      }    DC       Numargs
 3374      .fin
 3375
 3376      The following is the format for the setup for a NOAUTO procedure,
 3377      except those requiring X6A_STATIC_N:
 3378      .fif
 3379
 3380      }    LNJ,B5   X6A_xxx
 3381      }    doubleword Frameinfo
 3382      .fin
 3383
 3384      The following is the format for the setup using X6A_STATIC_N:
 3385      .fif
 3386
 3387      }    LNJ,B5   X6A_STATIC_N
 3388      }    doubleword Frameinfo
 3389      }    X   B    X+2,SPREL
 3390      }    DC       Numargs
 3391      .fin
 3392
 3393      .brn 9
 3394      where:
 3395      .spf
 3396      Frameinfo^^^^defines the procedure activation frame.  If
 3397      the routine is an AUTO routine, Frameinfo is the required size of
 3398      the AUTO frame and is a 1 word value.  If the routine is a NOAUTO routine, Frameinfo is
 3399      the address in the instruction segment where return address and
 3400      parameters are to be stored and is a doubleword (PTR).
 3401      .spf
 3402      Numargs^^^^is the number of arguments expected by the routine.
 3403
 3404      If fewer arguments than expected are passed, ADDR(NIL) will be
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          93   
 3405      supplied for the unspecified arguments.
 3406      ..::L2 "Return^Sequences"
 3407      The following table defines the exit sequences from various
 3408      types of procedures:
 3409      ..::TB "Procedure Return Routines\Procedure Type\#5\Using AUTO\#11\Using STATIC (NOAUTO)\#"
 3410      .fif
 3411      MAIN               LNJ,B4 X6A_MARET     LNJ,B4 X6A_MSRET
 3412      RETURN
 3413
 3414      ASYNC              LNJ,B4 X6A_AARET     LNJ,B4 X6A_ASRET
 3415      RETURN
 3416
 3417      Callable           LNJ,B4 X6A_ARET      LDB,B6 frame
 3418      RETURN                                  LNJ,B4 1,B6
 3419
 3420      Function           LNJ,B4 X6A_FARET     LDB,B6 frame
 3421      RETURN                                  LNJ,B4 1,B6
 3422
 3423      MAIN               LNJ,B4 X6A_MAALT     LNJ,B4 X6A_MSALT
 3424      ALTRETURN
 3425
 3426      ASYNC              LNJ,B4 X6A_AAALT     LNJ,B4 X6A_ASALT
 3427      ALTRETURN
 3428
 3429      Callable           LNJ,B4 X6A_AALT      LDB,B6 frame
 3430      ALTRETURN                               LDR,R1 ,B6
 3431      }                                       LNJ,B4 ,B6,R1
 3432      ..::IX "Procedure^Return^Routines"
 3433      ..::IX "X6A_MARET"
 3434      ..::IX "X6A_MSRET"
 3435      ..::TB
 3436      ..::L2 "Unwind^Routines"
 3437      The following table defines the routine names to be entered for
 3438      the execution of an UNWIND statement for various cases.  In all
 3439      cases B3 locates a REMEMBER variable and the routines are
 3440      entered via LNJ,B4.
 3441      ..::TB "Unwind Routines\Procedure Type\#6\AUTO\#13\NOAUTO\#"
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          94   
 3442      .fif
 3443      MAIN                X6A_MAUNWIND     X6A_MSUNWIND
 3444
 3445      ASYNC               X6A_AAUNWIND     X6A_ASUNWIND
 3446      .FIN
 3447      ..::IX "X6A_MAUNWIND"
 3448      ..::IX "X6A_MSUNWIND"
 3449      ..::TB
 3450      ..::L2 "Routines^for^Exit^from^ASYNC^Procedures^Specifying^FPT"
 3451      If an ASYNC procedure must specify an FPT to exit, it can do so while
 3452      allowing the AUTO stack to be properly cleaned up as follows:
 3453
 3454      .fif
 3455      For M$INTRET,      CALL X6A_INTRET (FPT)
 3456      For M$TRTN,        CALL X6A_TRTN (FPT)
 3457      For M$MERCS,       CALL X6A_MERCS (FPT)
 3458      .fin
 3459      ..::L2 "Registers^Used"
 3460      All of the routines assume that Base Register 7 locates the current
 3461      external automatic frame and the the T register controls all of
 3462      auto storage.  Thus all programs should leave B7 undisturbed.
 3463      ..::L1 "Automatic^Storage^Layout"
 3464      Most of the following information is in GH_LCP6_M, but included here.
 3465      Figure H-1 is a DRAW of the AUTO structure.
 3466      The layout of automatic storage which is assumed by the
 3467      calling/receiving sequences is as follows:
 3468
 3469      .inl 4
 3470      .UNL 4
 3471      1.  T controls all of Automatic Storage.
 3472
 3473      .unl 4
 3474      2.  B7 locates the current external frame which may include
 3475      several internal frames.
 3476
 3477      .unl 4
 3478      3.  Static (NOAUTO) frames have the same format as auto frames.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          95   
 3479
 3480      .unl 4
 3481      4.  The external frame is defined by the G$FRAME macro; see "G$FRAME
 3482      Structure" later in this section.
 3483      .SPB
 3484      .UNL 4
 3485      5.  The base of the automatic storage segment
 3486      contains certain global information about all of
 3487      automatic storage.  It, for example, locates the
 3488      stack head and the bottom frame, and also defines
 3489      the type of stack.  The first fifteen words are
 3490      described in the G$BASE macro, which is discussed later in this
 3491      section.
 3492      .SPB
 3493      .UNL 4
 3494      6.  As AUTOmatic storage is used, additional
 3495      frames are allocated within the currently
 3496      allocated portion of the AUTO segment to the
 3497      extent possible.  When a new frame cannot be
 3498      allocated, the AUTO segment is extended and
 3499      the AUTO head and BASE are updated.  The
 3500      G$AUTO_HEAD macro is illustrative; see "G$AUTO_HEAD Structure" later
 3501      in this section.
 3502      .spb
 3503      .unl 4
 3504      7.  Figure H-1 gives a picture of AUTO storage as
 3505      a whole.
 3506      The MONITOR_AUTO_LAYOUT and USER_AUTO_LAYOUT macros have no
 3507      operational value, but describe the
 3508      layout of the entire automatic storage segment.
 3509      .inl 0
 3510      ..::FG "Automatic Storage Layout"
 3511
 3512             **** TO BE SUPPLIED *****
 3513                          .IBL D:MONITOR_AUTO_LAYOUT
 3514                          .IBL D:USER_AUTO_LAYOUT
 3515
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          96   
 3516      ..::FG
 3517      */
 3518                          /*F* Name: G$BASE Structure
 3519                          The G$BASE macro can be used to generate a description
 3520                          of the base of the automatic storage segment.
 3521                          */
 3522      %MACRO G$BASE (FPTN = G$BASE,
 3523               LVL = 1,
 3524               LAST (YES=";",NO=",")= ";",
 3525               STCLASS = BASED);
 3526      %IF LVL = 1;
 3527      DCL 1 FPTN STCLASS ALIGNED,
 3528      %ELSE;
 3529              %LVL FPTN,
 3530      %ENDIF;
 3531                %(LVL+1) %CHARTEXT ('CUR_T_REG PTR'),
 3532
 3533                          /*K* CUR_T_REG - PTR.  This field always contains the pointer
 3534                          which is the proper contents of the T (stack) register.
 3535                          */
 3536                %(LVL+1) %CHARTEXT ('BOTTOM_FRAME$ PTR') LAST
 3537                          /*K* BOTTOM_FRAME$ - PTR.  This field always  contains
 3538                          a pointer to the bottom frame of the auto stack, which is
 3539                          usually a frame for a MAIN procedure.
 3540                          */
 3541                %(LVL+1) %CHARTEXT ('AUTO_TYPE UBIN') LAST
 3542                          /*K* AUTO_TYPE - UBIN.  This field indicates which
 3543                          type of auto stack this is. There are two types of
 3544                          auto stack because of interaction between the memory
 3545                          management hardware and the stack hardware. This field
 3546                          takes on two values. AUTO_TYPE = 0 indicates a 'fixed'
 3547                          type of auto stack which cannot be expanded.  This type has
 3548                          the following characteristics:
 3549                          }
 3550                          .fif
 3551                          1) It is managed by X6A$CSEQM.
 3552                          ..::IX "X6A$CSEQM"
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          97   
 3553                          2) It is used primarily by the monitor.
 3554                          3) No further storage can be allocated for new demands.
 3555                          4) Frames are added using ACQ.
 3556                          5) Frames are removed using RLQ.
 3557                          }
 3558                          .fin
 3559                          AUTO_TYPE = 1 indicates a 'variable' type of auto stack
 3560                          which can be expanded (up to 64kw) as needed. This type
 3561                          has the following characteristics:
 3562                          }
 3563                          .fif
 3564                          1) It is managed by X6A$CSEQU.
 3565                          ..::IX "X6A$CSEQU"
 3566                          2) It is used by user programs, handlers, etc.
 3567                          3) Storage is allocated as needed.
 3568                          4) Frames are added using RLQ.
 3569                          5) Frames are removed using ACQ.
 3570                          .fin
 3571                          */
 3572                %(LVL+1) %CHARTEXT ('SPARE(0:4) PTR') LAST
 3573      %MEND;
 3574
 3575
 3576                          /*F* Name: G$FRAME Structure
 3577                          The G$FRAME macro can be used to describe the automatic
 3578                          storage frame header.
 3579                          */
 3580      %MACRO G$FRAME (FPTN = G$FRAME,
 3581               LVL = 1,
 3582               LAST (YES=";",NO=",")= ";",
 3583               STCLASS = BASED);
 3584      %IF LVL = 1;
 3585      DCL 1 FPTN STCLASS ALIGNED,
 3586      %ELSE;
 3587              %LVL FPTN,
 3588      %ENDIF;
 3589                %(LVL+1) %CHARTEXT ('RET_ADDR EPTR'),
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          98   
 3590
 3591                          /*K* RET_ADDR - EPTR.  This field contains the return
 3592                          address for the call which invoked the procedure to which
 3593                          this frame belongs. In the case of Main or Async procedure,
 3594                          this field contains the address of the procedure activation.
 3595                          */
 3596                %(LVL+1) %CHARTEXT ('TYPE UBIN'),
 3597
 3598                          /*K* TYPE = UBIN.  This field contains a value
 3599                          which indicates the type of frame.
 3600                          The currently defined values are:
 3601
 3602                           .fif
 3603                                    0 - Standard procedure invoked by CALL
 3604                                   -1 - Main procedure
 3605                                   -2 - Async procedure
 3606                           .fin
 3607                          */
 3608                %(LVL+1) %CHARTEXT ('PREV_FR_SIZ UBIN'),
 3609                          /*K* PREV_FR_SIZ - UBIN.  This field is only used
 3610                          and maintained for the variable type of stack. It contains
 3611                          the size of the previous frame (not including size word)
 3612                          and is used for procedure exit to remove a frame.
 3613                          */
 3614
 3615                %(LVL+1) %CHARTEXT ('PARAMS(0:0) PTR'),
 3616
 3617                          /*K* PARAMS = PTR Array.  This array contains the
 3618                          pointers to the parameters passed to this procedure.
 3619                          */
 3620                %(LVL+1) %CHARTEXT ('VAR_TEMP(0:24) UBIN') LAST
 3621      %MEND;
 3622
 3623
 3624                          /*F* Name: G$AUTO_HEAD Structure
 3625                          This macro is used to describe the header portion
 3626                          of automatic storage. The T register will point to this header.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          99   
 3627                          The meaning is different for the two formats.
 3628                          */
 3629      %MACRO G$AUTO_HEAD (FPTN = G$AUTO_HEAD,
 3630               LVL = 1,
 3631               LAST (YES=";",NO=",")= ";",
 3632               STCLASS = BASED);
 3633      %IF LVL = 1;
 3634      DCL 1 FPTN STCLASS ALIGNED,
 3635      %ELSE;
 3636              %LVL FPTN,
 3637      %ENDIF;
 3638                %(LVL+1) %CHARTEXT ('CUR_USED UBIN'),
 3639
 3640                          /*K* CUR_USED - UBIN.  This field is the 'current used'
 3641                          field maintained by the stack hardware.  Its meaning is
 3642                          dependent on the type of auto stack. For both types, this
 3643                          field locates the current top frame. However, for the fixed
 3644                          type of stack, this also indicates the amount of auto
 3645                          space currently in use. But for the variable type of stack,
 3646                          this field minus current frame size is the current amount
 3647                          available for allocation.
 3648                          */
 3649                %(LVL+1) %CHARTEXT ('MAX_ALLOWED UBIN'),
 3650
 3651                          /*K* MAX_ALLOWED - UBIN.  This field contains the
 3652                          maximum amount of space currently allocated for auto
 3653                          storage. This includes the space currently in use.
 3654                          */
 3655                %(LVL+1) %CHARTEXT ('MUST_BE_NIL(0:1) PTR') LAST
 3656
 3657                          /*K* MUST_BE_NIL - PTR Array.  These fields are reserved
 3658                          for future use and must contain NIL pointers.
 3659                          */
 3660
 3661      %MEND;
 3662
 3663                          /*F* Name: MONITOR_AUTO_LAYOUT and USER_AUTO_LAYOUT.
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          100  
 3664                          The MONITOR_AUTO_LAYOUT and USER_AUTO_LAYOUT
 3665                          macros have no operational value, but can be used
 3666                          to illustrate the layout of the entire automatic
 3667                          storage segment.
 3668                          */
 3669      %MACRO MONITOR_AUTO_LAYOUT;
 3670      DCL 1 MONITOR_AUTO_LAYOUT BASED,
 3671      %G$BASE (FPTN = BASE , LVL = 2 , LAST = NO);
 3672            2 AVAILABLE (0:63) UBIN,
 3673            2 FR_3_SIZE UBIN,
 3674      %G$FRAME (FPTN = FRAME_3 , LVL = 2 , LAST = NO);
 3675            2 FR_2_SIZE UBIN,
 3676      %G$FRAME (FPTN = FRAME_2 , LVL = 2 , LAST = NO);
 3677            2 FR_1_SIZE UBIN,
 3678      %G$FRAME (FPTN = FRAME_1 , LVL = 2 , LAST = NO);
 3679      %G$AUTO_HEAD (FPTN = AUTO_HEAD , LVL = 2);
 3680      %MEND;
 3681      %MACRO USER_AUTO_LAYOUT;
 3682      DCL 1 USER_AUTO_LAYOUT BASED,
 3683      %G$BASE (FPTN = BASE , LVL = 2 , LAST = NO);
 3684            2 FR_1_SIZE UBIN,
 3685      %G$FRAME (FPTN = FRAME_1 , LVL = 2 , LAST = NO);
 3686            2 FR_2_SIZE UBIN,
 3687      %G$FRAME (FPTN = FRAME_2 , LVL = 2 , LAST = NO);
 3688            2 FR_3_SIZE UBIN,
 3689      %G$FRAME (FPTN = FRAME_3 , LVL = 2 , LAST = NO);
 3690            2 AVAILABLE (0:63) UBIN,
 3691      %G$AUTO_HEAD (FPTN = AUTO_HEAD , LVL = 2);
 3692      %MEND;
 3693      /*F* Name:  Initializing Automatic Storage
 3694      All PL-6 programs with the attribute MAIN will automatically call
 3695      the routine X6A_MAUTO or X6A_MSTATIC to initialize automatic storage.
 3696      Other main programs must include a call to X6A_MAUTO or X6A_MSTATIC
 3697      to insure proper operation if PL-6 subroutines are to be called.
 3698      ..::L1 "Usage^of^Parameters"
 3699      Parameters behave very much like implicitly based variables.
 3700      A Base Register must be loaded before the actual parameter can be
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          101  
 3701      accessed.  When a parameter to one routine is passed as an argument to
 3702      another routine, the pointer which represents the parameter is
 3703      simply copied.
 3704      ..::L1 "General^Function Calling^Sequences"
 3705      Returns from function subroutines should be done by a transfer to
 3706      X6A_FARET if the function subroutine uses AUTO storage.
 3707      ..::L1 "Monitor Calling^Sequences"
 3708      Monitor calls will take the following form:
 3709
 3710      .fif
 3711      }    LDR,3 = NVECTORS*1024+MCL_CODE
 3712      }   [LDB,3   FPT_PTR]       Need not be present
 3713      }   [LAB,3   FPT]           if NVECTORS=0.
 3714      }    MCL
 3715      }    DC      altret,PREL    Contains 0 if no ALTRET
 3716      .fin
 3717
 3718      .brn 6
 3719      where:
 3720      .spf
 3721      NVECTORS^^^^specifies the number of contiguous vectors in the FPT, The
 3722      first vector will, in general, locate the V (value) area of the FPT.
 3723      .spf
 3724      MCL_CODE^^^^specifies which monitor service is being invoked.
 3725
 3726      FPT_PTR^^^^locates the first vector.
 3727
 3728      MCL^^^^is the LCP-6 monitor call instruction.
 3729
 3730      DC altret,PREL^^^^is the offset from the MCL itself to the altret label.
 3731      ..::L1 "Certain^PL-6^Data^Types"
 3732      The following PL-6 data types are defined in PL-6 terms for
 3733      conciseness of expression.  This does not imply that these field
 3734      names will have any special significance or that the fields will
 3735      be individually referenceable, although they will in some cases.
 3736
 3737      .trf :*
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          102  
 3738      .fif
 3739      }DCL 1 PTR,                     /:Pointer to ALIGNED item:/
 3740      }      2 MBZ BIT(12),             /:Must be zero:/
 3741      }      2 ADDRESS BIT(20);         /:Word Address:/
 3742      }
 3743      }DCL 1 CPTR,                    /:Pointer to CALIGNED item:/
 3744      }      2 CHAR_OFFSET BIT(1),      /:Character Offset in Word:/
 3745      }      2 MBZ BIT(11),             /:Must be zero:/
 3746      }      2 ADDRESS BIT(20);         /:Word Address:/
 3747      }
 3748      }DCL 1 EPTR,                      /:Entry Pointer:/
 3749      }      2 MBZ BIT(12),             /:Must be zero:/
 3750      }      2 ADDRESS BIT(20);         /:Word Address of Procedure:/
 3751      }
 3752      }DCL 1 VECTOR ALIGNED,            /:Vector for framing storage
 3753      }                                   area.  Note word alignment
 3754      }                                   is minimum:/
 3755      }
 3756      }      2 VBOUND UBIN,             /:PINCRC (VECTOR.VBASE,
 3757      }                                   VECTOR.VBOUND) yields
 3758      }                                   CPTR to last byte framed:/
 3759      }      2 VBASE CPTR;              /:CPTR to first byte framed:/
 3760      }
 3761      }DCL 1 REMEMBER ALIGNED,          /:Variable to be used in
 3762      }                                   REMEMBER and UNWIND
 3763      }                                   statements:/
 3764      }      2 AUTO PTR,                /:Auto pointer (B7) at the
 3765      }                                   time the REMEMBER statement
 3766      }                                   is executed:/
 3767      }      2 STMT EPTR;               /:Address of the statement
 3768      }                                   remembered:/
 3769      .fin
 3770      .trf ::
 3771
 3772      Note also that ADDR(NIL), ENTADDR(NIL), and VECTOR(NIL) all have
 3773      0 values.  VECTOR(ERASE) has VBOUND of 1 and VBASE of 0.
 3774      ..::L1 "Other^PL-6^Library^Routines"
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          103  
 3775      There are other library routines contained in the module
 3776      X6A$CSEQ which deal with certain complex operations
 3777      involving bits, characters, and double word arithmetic.  All
 3778      are invoked by LNJ,B5 and return via B6 for exception condition (if any).
 3779
 3780      .inl 4
 3781      .unl 4
 3782      1.  Double Word Operations.
 3783
 3784      .fif
 3785      }X6D_CID - Compare R67 to double word located by
 3786      }          B1.  Set G,L,U indicators so signed or
 3787      }          unsigned tests can follow.
 3788      }
 3789      }X6D_DID - Divides R67 by double word located by
 3790      }          B1.  Quotient returned in R67.
 3791      }
 3792      }X6D_MID - Multiplies R67 by double word located by
 3793      }          B1.  Product returned in R67.
 3794
 3795      .unl 4
 3796      2.  Byte String Operations Too Long For CIP.
 3797      The following operations assume the operands are specified as
 3798      follows:
 3799
 3800
 3801      }First Operand  - Source for move and translate, left operand
 3802      }                 for compare, string being searched for search.
 3803      }
 3804      }           B2  - base address
 3805      }           R2  - byte offset from B1
 3806      }           R6  - length in bytes
 3807      }
 3808      }Second Operand - Destination for move and translate, right operand
 3809      }                 for compare, string being searched for search.
 3810      }
 3811      }           B3  - base address
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          104  
 3812      }           R3  - byte offset
 3813      }           R7  - length
 3814      }
 3815      }Third Operand  - Translate table for translate, 6 word temporary area
 3816      }                 for search.
 3817      }
 3818      }           B1  - base address
 3819      }           R1  - byte offset
 3820      }
 3821      }      X6C_ACM  - Compare with blank fill.  Set
 3822      }                 CPU G&L indicators so CPU
 3823      }                 unsigned branches may follow.
 3824      }
 3825      }     X6C_ACMZ  - same except zero fill.
 3826      }
 3827      }      X6C_ALR  - move with blank fill.
 3828      }
 3829      }     X6C_ALRZ  - move with zero fill.
 3830      }
 3831      }      X6C_MAT  - move and translate. Exception if source
 3832      }                 string is longer than destination.
 3833      }
 3834      }     X6C_SRCH  - search string for another. Exception if string
 3835      }                 not found. If found, index returned in R6.
 3836      }
 3837      .brn 7
 3838      .unl 4
 3839      3.  Bit String Operations
 3840      The following operations assume the same operand specification
 3841      as for character strings except that offsets and lengths are
 3842      in bits.
 3843
 3844      .fif
 3845      }     X6B_BCM     Compare with '0'B fill.
 3846      }     X6B_BLR     Move with '0'B fill.
 3847      .fin
 3848      .INL 0
14:34 JUL 28 '97 GH_LCP6_M.:E05SI                                          105  
 3849      */

