FOXI (FOrtran Xsa Interface) makes the CP-6 fast sequential file services
available to FORTRAN (or PL-6 or COBOL) application programs.
FOXI is provided as a LEMUR library which must be linked with your application
program.  To get the FOXI routines, simply include them in your LINK commands:
 
      !LINK FRED, WILMA OVER PEBBLES (UNSAT=(FOXI.X))
 
To get detailed information about FOXI, try
 
          !HELP (FOXI.X) ROUTINES
 
or
 
          !HELP (FOXI.X) TOPICS
 
A generalized overview of FOXI follows; type ? for more.
FOXI (FOrtran XSA Interface) provides FORTRAN, COBOL, and PL-6 programs with
simplified access to the XSA Fast Sequential File Access routines.  Up to 10
files may be open at one time.  FOXI manages its own buffers in the next
available user data segment; programs that use all the data segments are SOL.
Space is reclaimed when a file is closed (adjacent free areas are automatically
combined), and will be available for use with subsequent files.
The XSA routines provide fast sequential access to keyed, indexed, relative,
and consec files.  They may be used on other types of files, but to no
advantage (relative to PL-6 monitor I/O; they would still be faster than
FORTRAN reads with an '(A)' format).  The speed is obtained at the expense of
function; the only operations permitted are reading and writing sequentially,
positioning by record count, and positioning to one or the other end of the
file.
 
The XSA package opens files in block mode (i.e. it reads the raw granules of
the file), and interprets the internal structure of the file without the help
of the monitor; in output mode, XSA constructs a file in its buffers, then
writes it block by block to disk.  This buffer space used by XSA must be
provided by the user; FOXI handles the details of this, requiring only that the
FOXI user pass in a count of pages to be used for data (and, optionally, for
keys).
The XSA package itself is documented in the Host Library Services Manual, order
number CE71; consult that opus for a complete description of the XSA routines.
This help file will concern itself only with the interface provided by FOXI.
 
To obtain a brief description of the FOXI subroutine calls, type:
 
      !HELP  (FOXI.X)  ROUTINES
 
Each routine is documented in its own topic, with subtopics describing the
arguments in detail.  For example, to see the topic describing the Open
routine, type:
 
      !HELP  (FOXI.X)  FAST$OPEN
 
HELPful hints on when and how to use FOXI to the best advantage may be found in
the topics TECHNIQUES and RATIONALE.
FOXI FOXI (FOrtran XSA Interface) provides FORTRAN programs with access to the
XSA Fast Sequential File Access routines.
 **************************************************************
 *                                                            *
 *  Copyright (c) Bull HN Information Systems Inc., 1989      *
 *                                                            *
 **************************************************************
KUDOS
ROUTINES
09/01/88 Fixed up the XCon processing, to account for the fact that XCon
         screws up StepCC values.  This involved adding two more routines,
         FAST$XCON_SET and FAST$XCON_RESET.
08/01/88 Added support for Unfast# bit --
         This involved a new parameter for Fast$Open, and two new routines,
         UNFAST$ERROR and UNFAST$CONTINUE.
11/02/87 Fixed FIND$DCB to find its own DCBs.
10/26/87 Modified all routines to AltReturn iff IOSTAT set ~= 0
         Took the B_POINTER_D.:LIBRARY junk out of FOXI_CRU, since
           Link can just as easily find it in :LIB_SYSTEM.:SYS.
06/26/87 Modified FAST$OPEN to:
 - use the KBUFSIZE value as IXTNSIZ for Create opens;
 - let DBUFSIZE default if not present;
 - let FID default to blanks if not present;
 - add some error checking for negative values on DBUFSIZE and KBUFSIZE;
 - allow Fun=Update and Share=All (although FSFA mode will be off).
06/25/87 Modified FOXI_CRU to copy B_POINTER_D.:LIBRARY into FOXI, and added a
Conv(5) call to B_POINTER in FAST$OPEN; this eliminates the need for specifying
B_POINTER_D.:LIBRARY as an OU on every link.
03/19/87 Fixed a bug with not specifying KBufSize on FAST$OPEN calls.
When called from Fortran code, FOXI routines always return to the statement
following the call.  The only way to determine that an error has occured is to
examine the value returned by FOXI in the IOSTAT variable.  If this value is
zero, no error has occured.  If the value is a small negative number (-1..-13),
the FOXI routines have detected an error (see the IOStat subtopic in the topic
FAST$OPEN for details).  Otherwise, a Monitor I/O error (e.g. END-OF-FILE,
LOST-DATA) has occured.  (The CP-6 Programmer's Reference Manual contains a
list of possible Monitor errors; in addition, the Reference Manuals for Fortran
and COBOL detail the errors that may be encountered when using native I/O
calls.  Consult these works for further information.)
 
The Monitor I/O error of most interest to the FOXI user is E$EOF, or End of
File.  This error code (in all of its flavors) has an error number of 6.  The
following code, then, will detect End of File on a FAST$READ (as well as handle
any other errors that might occur):
 
      CALL  FAST$READ  (IOS888 . . . .
      IF (IOS888 .NE. 0 ) THEN
         IF (IOS888 .LT. 0 .AND. IOS888 .GE. -10) THEN
C           FOXI error . . .
         ELSE
            IERR888 = IOSDCODE (IOS888)
            IF (IERR888 .EQ. 6) THEN
               GO TO E$EOF888
            ELSE
C              Other I/O error . . .
            END IF
         END IF
      END IF
 
The FOXI routines will AltReturn if IOSTAT is non-zero; thus, PL6 programmers
may use the standard AltRet/WhenAltReturn clauses to field FOXI errors.  The
IOSTAT value returned is in standard CP-6 error code format.
00002
CHECKING_FOR_END_OF_FILE
FAST$CLOSE
FOXI can be used to read and write files specified on the command line, using
standard rununit-invocation syntax.  However, FORTRAN will not automatically
create DCBs for unit numbers used in FOXI calls; therefore, Link will not be
able to set up correspondences between these units and the four command-line
dcbs (i.e. via the DCB1/SIDCB, etc. Link options).  To force FORTRAN to
generate a DCB for a unit used only in FOXI calls, use the Unit FORTRAN
compiler option.  For example, to force FORTRAN to create DCBS for units 200
and 400, use a command like:
 
    !FORTRAN  source  OVER  object  (....,Unit (200, 400))
/********************************************************************
*                                                                   *
* This program  is a gratuitous contribution and  is offered as is. *
* Zenith  makes  no  representations  or  warranties  of  any kind, *
* express  or  implied,  relating  to  freedom  from  infringement, *
* accuracy,  error-freedom  or   performance,  and  shall  have  no *
* liability  or responsibility  to users  for damages  of any kind, *
* including special, indirect or consequential damages, arising out *
* of  or resulting  from use,  modification or  reproduction of the *
* program.                                                          *
*                                                                   *
* No  warranty  is  made  by  the  contributor  as to the accuracy, *
* maintenance, and functioning of the program and related material. *
* No  responsibility is  assumed by  the contributor  in connection *
* therewith.                                                        *
*                                                                   *
********************************************************************/
TECHNIQUES
CHECKING_FOR_END_OF_FILE
FSFA creates files behind the monitor's back.  These files are opened
Ctg=No, so if the program aborts or exits without closing a file, the
contents of the file will be lost.  FOXI can protect the user from this
by taking exit control via M$XCON, and closing all the user's files
(if any are left open) whenever the program exits abnormally.  This mode
is established by calling FAST$XCON_SET, and revoked by calling
FAST$XCON_RESET.  (It is only necessary to revoke FOXI's exit control if
you intend to set a StepCC value at exit, e.g. via FORTRAN's CALL EXIT
routine.)
 
Note that this protection applies only to abnormal exits; since all files
are closed as part of a "normal" (e.g. FORTRAN STOP, M$Exit, M$Err) exit,
any files currently being created by FOXI will be destroyed before the
XCon routine can save them.
 
FOXI's exit control routine is well-behaved, in that it saves any
previous exit-control address and restores it after cleaning up its
act.
Call:
 
      CALL FAST$CLOSE (IOSTAT, UNIT [, DISP ] )
 
FAST$CLOSE closes a DCB that was opened previously by FAST$OPEN.  If the DCB
cannot be found in FOXI's internal tables, or if it is not open, this routine
returns an error.  The optional argument DISP determines whether the file will
be saved or deleted (output only).
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for info on DISP.
DISP <INTEGER>
 
DISP determines whether the file being created should be saved (DISP=2) or
released (DISP=1) during the close.  Any other value will result in an error
return, with IOSTAT=-10.  If DISP is not specified, the default is DISP=2
(SAVE).
 
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
00002
00002
00001
00002
00002
00001
00002
Call:
 
      CALL FAST$OPEN (IOSTAT, UNIT [, FID, DBUFSIZE, (*)KBUFSIZE,
                      FUN, SHARE, EXIST, UNFAST ] )
 
FAST$OPEN opens a DCB to the named file (or to whatever is already in the DCB,
if FID is blank or not present).  DBUFSIZE and KBUFSIZE specify the number of
pages to use for data and key buffers, respectively (large numbers cut down on
the number of actual I/O calls issued).  FUN, SHARE, and EXIST specify how the
file is to be opened.  UNFAST determines the action to be taken if a subsequent
FOXI call requests a service not provided by the XSA package.
The last seven options are optional; any or all of them may be omitted.  PL-6
callers may simply specify null parameters (i.e. two or more consecutive
commas); calls from languages that do not allow omission of arguments within an
argument list may use the value -1 to indicate omission of an argument (except
for the FID parameter, for which a single blank is the sign of omission).
Omitted arguments will be ignored when the file is actually opened, thus
allowing these parameters (except for DBUFSIZE and KBUFSIZE) to be set
externally (via !Set or command-line DCB correspondences).
 
(*) Key Buffers are not used when Fun=Create (FUN=1); therefore, KBUFSIZE is
used to specify the Initial Extent Size (IXTNSIZ) for the new file.  The size
of supplementary extents (XTNSIZE) will be determined by the value set in the
DCB (via !Set or !Adjust).
 
Note:  IOSTAT and UNIT are required for all FOXI calls; they will be described
here only.
IOSTAT <INTEGER>
 
IOSTAT returns a standard CP-6 error code if a monitor or XSA error occurs;
this code may be displayed via the ERROROUT FORTRAN subroutine, or, in Delta,
via the \J format specifier, as:  'D IOSTAT\J'.  IOSTAT also returns the
following special codes for FOXI errors:
 
 IOSTAT   Meaning
 
    -1    Error returned by Find$DCB (all routines)
    -2    DCB not open               (all except FAST$OPEN)
    -3    DCB not in table           (all except FAST$OPEN)
    -4    DCB already open           (FAST$OPEN only)
    -5    DCB table full             (FAST$OPEN only)
    -6    Data Segment full          (FAST$OPEN only)
    -7    Invalid Fun value          (FAST$OPEN only)
    -8    Invalid Share value        (FAST$OPEN only)
    -9    Invalid Exist value        (FAST$OPEN only)
   -10    Invalid Disp value         (FAST$CLOSE only)
   -11    DBufSize < 0               (FAST$OPEN only)
   -12    KBufSize (IXtnSize) < 0    (FAST$OPEN only)
   -13    Invalid UnFast value       (FAST$OPEN only)
 
UNIT
 
Either an INTEGER FORTRAN Unit Number (E.g. 100 for F$100), a blank-terminated
text DCB name (as, 'F$100 '), or a DCB number shifted into the upper halfword
of an INTEGER variable (or occupying an entire INTEGER*2 variable).  It is most
efficient to provide the DCB number; FIND$DCB may be used to obtain the DCB
number corresponding to any Unit or DCB Name (see the FIND$DCB  and TECHNIQUES
topics in this HELP file).
 
FID <CHARACTER*(*)>
 
FID must contain either a valid CP-6 fid, or blanks.  If FID is blank or not
present, FAST$OPEN will attempt to open the DCB "as is"; this is useful for
opening DCBS that are defined as command-line DCBs.  FAST$OPEN parses the
complete fid; if any errors occur, the open is aborted and the monitor error is
returned in IOSTAT.
 
When FAST$OPEN is called from a COBOL74 routine, FID must contain at least one
blank following the actual CP-6 fid.  (This restriction applies as well to PL-6
routines that do not specify Conv(0) on the Entry Dcl for this routine; see the
macro FOXI$Ents in FOXI_C.X for the proper Dcls.)
DBUFSIZE <INTEGER>
 
DBUFSIZE specifies the number of pages that should be used by XSA for cacheing
this file's data granules.  This must be at least one, and should be at least
two.  The more pages that are available to XSA, the fewer disk I/O calls it
must do; however, if space is at a premium, smaller buffers may be used.  If
DBUFSIZE is not specified (or is specified with the value -1), the default is
five (5) pages.
 
KBUFSIZE <INTEGER>
 
KBUFSIZE specifies the number of pages that should be used by XSA for cacheing
this file's key granules.  If the file is not keyed, this number may be zero;
otherwise, it must be at least one, and should be at least two.  The more pages
that are available to XSA, the fewer disk I/O calls it must do; however, if
space is at a premium, smaller buffers may be used.  If KBUFSIZE is not
specified (or is specified with the value -1), the default is zero (0).
 
On Fun=Create (FUN=1) opens, KBUFSIZE is used to specify the initial size of
the file (IXTNSIZE); the default in this case is to use the CP-6 default, which
is two (2) granules.
 
FUN <INTEGER>
 
FUN specifies whether the file is to be opened for input (FUN=0), output
(FUN=1), or update (FUN=2).  Values other than these will abort the open with
IOSTAT=-7.  If FUN is not specified (or is specified with the value -1), the
default is to use whatever is currently in the DCB.
 
Note that if FUN=2 (update), the XSA routines will use normal Monitor I/O
rather than FSFA mode; this does not preclude any performance gains over
FORTRAN I/O, since all FORMAT scanning and other overhead will be eliminated,
but the gains will not be as pronounced.
 
SHARE <INTEGER>
 
SHARE specifies, for input only, whether other users may read the file at the
same time (SHARE=1, in) or not (SHARE=0, none); the file may be shared with
updaters, too, by specifying SHARE=2.  Values other than these will abort the
open with IOSTAT=-8. If SHARE is not specified (or is specified with the value
-1), the default is to use whatever is currently in the DCB.
 
Note that if SHARE=2 (all), the XSA routines will use normal Monitor I/O rather
than FSFA mode; this does not preclude any performance gains over FORTRAN I/O,
since all FORMAT scanning and other overhead will be eliminated, but the gains
will not be as pronounced.
 
EXIST <INTEGER>
 
EXIST specifies, for output only, what to do if the named file already exists.
The options are to create a new file (EXIST=1), append to the old file
(EXIST=2), or return an error to the user (EXIST=0).  Values other than zero,
one, or two will abort the open with IOSTAT=-9.  If EXIST is not specified (or
is specified with the value -1), the default is to use whatever is currently in
the DCB.
 
UNFAST <INTEGER>
 
UNFAST specifies the action to be taken by the XSA routines if a FOXI call
requests a service that the XSA routines do not provide.  The options are to
close and reopen the file, and continue using normal monitor I/O (UNFAST=0), or
to return an error to the user (UNFAST=1).  Values other than zero or one will
abort the open with IOSTAT=-13.  If UNFAST is not specified (or is specified
with the value -1), the default is to continue (UNFAST=0).
00005
00005
00003
00003
00003
00003
00002
00009
00004
00004
00007
00007
00006
00002
00006
00006
00006
00007
00008
00010
00003
Call:
 
      CALL FAST$PFIL (IOSTAT, UNIT [, BOF ] )
 
FAST$PFIL positions to either the beginning (BOF=.TRUE.) or the end
(BOF=.FALSE.) of the specified file.
 
Alternate Call:
 
      CALL FAST$REWIND (IOSTAT, UNIT)
 
FAST$REWIND is equivalent to FAST$PFIL (IOSTAT, UNIT, .TRUE.).
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
BOF <LOGICAL>
 
Specifies whether to position to the beginning (.TRUE.)  or the end (.FALSE.)
of the file.  If BOF is not specified, the default is .TRUE.  If the LOGICAL
data type is not available in the caller's language, the INTEGER (aka COMP-6)
values -1 and 0 (zero), may be substituted for .TRUE. and .FALSE., respect-
ively.
 
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
00001
00001
00002
00002
00002
00002
00002
Call:
 
      CALL FAST$PRECORD (IOSTAT, UNIT, COUNT [, KBUFFER, KLEN ] )
 
FAST$PRECORD moves the current position in the file by COUNT records, and
optionally, returns the key of the record which would be read next.  Attempting
to position beyond either end of the file will result in a monitor error.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
COUNT <INTEGER>
 
COUNT specifies how many records, and in which direction, to position.  If
COUNT is positive, the direction is toward the end of the file; if COUNT is
negative, the direction is toward the beginning.
 
(WARNING:  The XSA routines do not currently support counts less than zero;
specification of a negative count (backspace operation) will result in the file
being closed and re-opened for "normal" monitor I/O, unless UNFAST=ERROR has
been specified (either on the Fast$Open call, or via the UNFAST$ERROR routine),
in which case an error will result).
 
KBUFFER <CHARACTER*(KBLEN)>
 
This returns the key of the record which would be read next.  The key is
returned in TextC format, with a leading length byte followed by the bytes of
the key; therefor, KBLEN must be one greater than the length of the longest key
expected.
 
KBLEN <INTEGER>
 
This is the size, in bytes, of the key buffer (KBUFFER).  The length of the
actual key is returned in the first byte of KBUFFER, followed by the bytes of
the actual key; thus, KBLEN must be one greater than the length of the longest
key expected.  The valid range for KBLEN is 2 - 512.
 
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
00001
00004
00004
00004
00004
00003
00002
00002
00003
00001
00004
Call:
 
      CALL FAST$READ (IOSTAT, UNIT, BUFFER, BLEN [, ARS, DVBYTE,
                       EOMCHAR, KBUFFER, KBLEN ] )
 
FAST$READ reads a record from the specifed file, and optionally returns various
information about the record read.  The last five arguments are optional;
however, if KBUFFER is specified, KBLEN must be, as well.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
BUFFER <CHARACTER*(BLEN)>
 
FAST$READ reads data into this buffer.  If the buffer is too small for the next
data record, an error code will be returned in IOSTAT.  BLEN specifies the
physical length of the buffer; ARS returns the count of bytes actually read.
The buffer is not blank-filled before reading; this is the user's
responsibility.
 
BLEN <INTEGER>
 
 This is the physical size of BUFFER (the max number of bytes that can be read
in).
 
ARS <INTEGER>
 
This returns the number of bytes actually read into BUFFER.  If ARS is less
than BLEN, the remaining bytes in BUFFER will not be changed; no blank filling
is performed.
 
DVBYTE <INTEGER>
 
 This returns a collection of flags describing the record read; these are
described in the Monitor Services manual, order number CE74, under Additional
Fields in the DCB.  The nine bits from XSA_PARAM.DvByte are stored in the least
significant byte of DVBYTE; the upper three bytes are zero filled.
 
EOMCHAR <CHARACTER*(1)>
 
This returns the value from XSA_PARAM.EOMCHAR, the meaning of which is somewhat
obscure.
 
*
KBUFFER <CHARACTER*(KBLEN)>
 
This returns the key of the record read.  The key is returned in TextC format,
with a leading length byte followed by the bytes of the key; therefor, KBLEN
must be one greater than the length of the longest key expected.
 
KBLEN <INTEGER>
 
This is the size, in bytes, of the key buffer (KBUFFER).  The length of the
actual key is returned in the first byte of KBUFFER, followed by the bytes of
the actual key; thus, KBLEN must be one greater than the length of the longest
key expected.  Valid ranges for KBLEN are 2 - 512.
 
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
00003
00003
00002
00001
00002
00008
00008
00004
00005
00008
00008
00007
00006
00006
00007
00003
00008
FAST$PFIL
Call:
 
      CALL FAST$WRITE (IOSTAT, UNIT, BUFFER, BLEN [, VFC, BIN, TRANS ] )
 
FAST$WRITE writes a record from BUFFER (1:BLEN) to the current file;
optionally, the data record may be written with the VFC, BIN, or TRANS flags
set.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Type ? for more.
BUFFER <CHARACTER*(BLEN)>
 
FAST$WRITE writes data from the first BLEN bytes of this buffer.
 
BLEN <INTEGER>
 
This is the logical size of BUFFER (the number of bytes that are to be
written).
 
VFC <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the VFC attribute.  If VFC is not specified, the default is .FALSE.  If
the LOGICAL data type is not available in the caller's language, the INTEGER
(aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE. and
.FALSE., respectively.
 
BIN <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the BIN (binary) attribute.  If BIN is not specified, the default is
 .FALSE.  If the LOGICAL data type is not available in the caller's language,
 the INTEGER (aka COMP-6) values -1 and 0 (zero), may be substituted for
.TRUE. and .FALSE., respectively.
 
TRANS <LOGICAL>
 
This specifies whether (.TRUE.) or not (.FALSE.) the record is to be written
with the TRANS (transparent) attribute.  If TRANS is not specified, the default
is .FALSE. If the LOGICAL data type is not available in the caller's language,
the INTEGER (aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE.
and .FALSE., respectively.
 
IOSTAT and UNIT are described under the FAST$OPEN topic; type:
 
      !HELP  (FOXI.X)  FAST$OPEN  UNIT
 or
      !HELP  (FOXI.X)  FAST$OPEN  IOSTAT
00004
00002
00001
00002
00006
00006
00006
00006
00005
00006
00003
Call:
 
       CALL  FAST$XCON_RESET
 
FAST$XCON_RESET turns off FOXI's protection against accidental loss of newly
created files.  This is necessary in order to set the StepCC at exit (e.g.
via FORTRAN's  CALL EXIT  procedure.)
Call:
 
        CALL  FAST$XCON_SET
 
FAST$XCON_SET invokes protection against accidental loss of files created by
FOXI.  If a program abort occurs after this routine is called, all FOXI files
currently open will be saved; without this protection, any files being created
at the time of the abort would be destroyed.
 
This protection persists until a call to FAST$XCON_RESET.  Normally, it is not
necessary to call FAST$XCON_RESET; however, if you wish to set the Step
Condition Code (StepCC), e.g. via FORTRAN's  CALL EXIT  routine, you must first
disable FOXI's exit control.
 
Call:
 
      CALL FIND$DCB (UNIT, DCBNUMBER [, BUILDFLAG ] )
 
FIND$DCB takes in either a FORTRAN unit number, a text DCB name, or a COBOL FIB
(i.e. a DCB number in a halfword on a word boundary(*)), and returns an Integer
(or SBin) DCB number.  If BUILDFLAG is not specified, or is specified and is
 .TRUE., FIND$DCB will create the DCB if it does not exist; otherwise, if the
DCB does not exist, FIND$DCB will return a -1 as the DCB number.
 
(*) A true COBOL FIB is on a word boundary; this routine will accept values
aligned to a half-word boundary.  (Note that this routine will NOT work with
DCB numbers greater than 511.)
 
UNIT
 
One of the following:
 
a) An INTEGER FORTRAN unit number (e.g. 105, representing F$105);
 
b) A blank-terminated CHARACTER DCB name (e.g. 'F$105 ');
 
c) A DCB number in the upper halfword of an INTEGER word (this is what COBOL
passes when an FD name is specified as an argument in an ENTER PL-6 style call;
it is also what COBOL85 passes when the _DCBNUM construct is used), or in an
INTEGER*2 variable.
 
DCBNUMBER <INTEGER>
 
Returns the DCB number for the specified DCB.  If the DCB does not exist (or
cannot be created), DCBNUMBER returns -1.
 
WARNING!  If the DCBNUMBER returned by FIND$DCB is greater than 511, it must
NOT be shifted left and passed to a FOXI routine.  This is an artifact of the
algorithm used by FIND$DCB itself.
BUILDFLAG  <LOGICAL>
 
Specifies whether (.TRUE.) or not (.FALSE.) to create the specifed DCB if it
does not already exist.  If BUILDFLAG is not present, the default is .TRUE.  If
the LOGICAL data type is not available in the caller's language, the INTEGER
(aka COMP-6) values -1 and 0 (zero), may be substituted for .TRUE. and .FALSE.,
respectively.
 
00003
00003
00001
00001
00002
00002
00002
00001
Call:
 
      IERRNUMB = IOSDCODE (IOSTAT)
 
IOSDCODE returns the error number portion of a standard CP-6 error code.  This
is useful for testing for end-of-file, for example, since the error number is a
much smaller, easier to remember constant than is the full error code (when
expressed as an Integer value).
 
Both the argument and the result are integers; the argument may be any IOSTAT
variable returned by either a FORTRAN I/O statement or FOXI call.
Many thanks to John Joseph for his assistance in making this Help file more
readable.
FOXI is a Lemur-style library; it may be referenced either as a library in the
UnSat option of a Link command, or as an object unit on the link.  Some rununit
space may be saved by linking FOXI as a library, but only if not all the FOXI
routines will be called; otherwise, there is no advantage to treating FOXI as a
library.
 
Examples:
 
      !Link Fred, Wilma to Pebbles (UNSAT=(FOXI.X))   - or -
      !Link Barney, FOXI.X over Bedrock
 
FAST$OPEN
Andrew Birner, Zenith Electronics Corporation
FAST$PFIL
SUITABILITY_ANALYSIS
COMMAND_LINE_DCBS
FAST$PRECORD
FORTRAN formatted I/O is expensive, even when the FORMAT consists of nothing
but a single 'A' format.  FORTRAN always has to go through code to figure out
that it doesn't need to do anything.  For applications where the user wants
only to read or write a character record, with no formatting, FOXI provides
significant performance gains.  (Note that any buffer may be used, including a
COMMON block containing data items of arbitrary types.)
 
One test program, which simply copied one file to another (adding even parity),
took 110 CPU seconds using FORTRAN sequential I/O with '(A)' formats; when
converted to FOXI, this same program took only 14 CPU seconds!  Clearly,
dramatic savings in processing time can be achieved with relatively little
effort, especially in cases where the program is I/O intensive (such as our
test case).  In any event, the I/O overhead incurred by the FORTRAN Library is
eliminated for any units that are converted to FOXI I/O.  (See the topic
TEST_RESULTS for further info on the test case cited above.)
 
FORTRAN unformatted (binary) I/O is faster than FORMATted I/O, but will only
work in cases where the record lengths are known in advance; FOXI can process
variable-length as well as fixed-length records.
 
PL-6 programmers may find FOXI useful as a somewhat simplified front end for
the XSA routines.  FOXI takes care of the details of memory and FPT management
for the programmer, thus freeing his or her mind for more productive tasks.  To
make FOXI more useful for the PL-6 programmer, all the routines will AltReturn
when the IOSTAT parameter is set to a non-zero value.  In addition, Entry DCLs
for the FOXI routines are defined in the macro Foxi$Ents, in the file FOXI_C.X.
 
COBOL uses the XSA package for its runtime I/O, when applicable, so FOXI will
provide little speed advantage.  However, FOXI permits the program to specify
filenames dynamically, at runtime, while COBOL74 does not; FOXI also has very
little overhead associated with I/O calls, and MAY be somewhat faster than
COBOL's I/O.
 
NOTE:  When FAST$OPEN is called from a COBOL routine, the FID parameter (if
passed) must contain at least one trailing blank (following the actual CP-6
fid).
00003
00002
FAST$READ
FAST$PFIL
The routines in the FOXI library are:
 
      FAST$OPEN         Open a file
      FAST$CLOSE        Close a file
      FAST$READ         Read a record from a file
      FAST$WRITE        Write a record to a file
      FAST$PFIL         Position to the beginning or end of a file
      FAST$PRECORD      Position forward or backward in the file
 
      UNFAST$ERROR      Cause FOXI routines to return an error on
      (UNFAST$ALTRET)     subsequent calls that would otherwise cause
                          XSA to return to "normal" monitor I/O.
 
      UNFAST$CONTINUE   Cause FOXI routines to continue processing in
      (UNFAST$MONITOR)    UnFast mode when unsupported services are
                          requested.
 
Type ? for more . . .
Utility routines also provided (and used internally):
 
      FIND$DCB          Utility routine to get a DCB number, given a
                        FORTRAN unit number or a text DCB name.
 
      IOSDCODE          Function to grab the error number out of an
                        IOSTAT variable.
 
For information on a particular routine, type:
 
      !HELP  (FOXI.X)  routinename
 
PMON.X is a useful tool for estimating the savings that might be achieved by
converting to FOXI.  PMON must be installed as a Debugger by your System
Manager; if it has not been, contact him or her regarding the possibility of
making PMON available.   To evaluate a program for Foxi use, try the following:
 
    !Under PMON      "associate the PMON debugger
    !your_run_unit. . . .   "run your standard FORTRAN application
    !PMDISP.X  your_run_unit., *PM_DATA   "display the performance statistics
 
The third step will produce a listing of procedures and the time spent in each,
sorted by descending CPU time.  All the routines with names like XFG_5FSCAN or
XFG_7IEDIT are FORTRAN I/O routines; they would be eliminated if all program
I/O were done via FOXI routines.
 
This topic is a repository for hints on improving the efficiency of programs
that use FOXI.  These "tricks of the trade" are described in the following
sub-topics; type '?' for the next trick, or '??' for all of them.
FOXI accepts three different constructs as UNIT specifiers:  Text DCB names,
FORTRAN INTEGER unit specifiers, and Cobol-style DCB numbers (imitation FIBs).
This virtuosity is not without its price, however; FOXI must determine, for
each call, what it has been passed, and deal with it.  Not all of the options
require the same amount of processing; in fact, the FORTRAN-style unit numbers
are the MOST expensive of the three!  The cheapest alternative is the COBOL-
style call; fortunately, this form can be used from FORTRAN programs, as well.
 
Type ? for more . . .
 
The routine FIND$DCB, described elsewhere in this HELP file, may be used to
obtain the DCB number corresponding to a particular FORTRAN Unit; this may,
after suitable processing, be used on subsequent calls to FOXI routines, to
speed things up.  The code (for unit F$555) would look something like this:
 
      CALL  FAST$OPEN  (IOSTAT, 555, . . . .)
      CALL  FIND$DCB   (555, IDCB555)
      IDCB555 = ISL (IDCB555, 18)
      CALL  FAST$READ  (IOSTAT, IDCB555, . . .)
 
 -or-
 
      INTEGER*2 IDCB555
       .
      CALL  FAST$OPEN  (IOSTAT, 555, . . . .)
      CALL  FIND$DCB   (555, ITEMP)
      IDCB555 = ITEMP
      CALL  FAST$READ  (IOSTAT, IDCB555, . . .)
 
HOWEVER:  If you have more than 511 DCBs in your program, this trick will NOT
work!  If the DCB number returned by FIND$DCB is greater than 511, you must use
one of the other forms of UNIT specifier.
00001
This topic describes the results of putting FOXI into a simple I/O bound
program.  The same source is used to generate three rununits; the different
versions are, of course, determined by FORTRAN conditional compilation
statements.  The three flavors are:
 
 FOXI_TST_Y     Standard FORTRAN I/O.
 FOXI_TST_XZ    FOXI I/O, using the integer value 200 as the Unit
 FOXI_TST_X     FOXI I/O, using the DCB number of F$200 as the Unit
 
(For more information on the difference between the X and XZ cases, see the
topic TECHNIQUES in this HELP file.)
 
Type ? for a summary of the test results . . .
 
    Test          CPU time      % Improvement
    -----------   -----------   ----------------
    FOXI_TST_Y    01:53.14        ----
    FOXI_TST_XZ   00:30.40        73.1%
    FOXI_TST_X    00:26.69        76.4%  (12.2% vs. XZ)
 
                  % Execution time/
    Test          (time in seconds)       % Improvement
    -----------   -----------------       ----------------
    FOXI_TST_Y     65.49% (0:74.10)         ----
    FOXI_TST_XZ    42.99% (0:13.07)         82.4%
    FOXI_TST_X     39.04% (0:10.42)         86.9%  (20.0% vs. XZ)
 
                  % Service time/
    Test          (time in seconds)       % Improvement
    -----------   -----------------       ----------------
    FOXI_TST_Y     44.51% (0:39.04)         ----
    FOXI_TST_XZ    57.01% (0:17.33)         55.6%
    FOXI_TST_X     60.96% (0:16.27)         58.0%  (06.1% vs. XZ)
 
Type ? for more . . .
 
The rest of this topic is a Dribble of the test session; it is broken into the
following subtopics:
 
  !HELP (FOXI.X) TEST_RESULTS COMPILE          The compilation phase
  !HELP (FOXI.X) TEST_RESULTS LINK             The linking
  !HELP (FOXI.X) TEST_RESULTS EXECUTION        The running
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_X       The results for X
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_XZ      The results for XZ
  !HELP (FOXI.X) TEST_RESULTS FOXI_TST_Y       The results for Y
 
Peruse at your own risk . . .
 
DRIBBLE ON @  16:13 11/02/87
!ECHO
!XEQ FOXI_TST_JCL
$JOB NAME=FOXI_TST_JCL
$RES TIME=10, MEM=256
$"
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_X  (NLS,X,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
 X-STATEMENTS COMPILED: 20
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_XZ (NLS,X,Z,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
 X-STATEMENTS COMPILED: 20
 Z-STATEMENTS COMPILED: 2
$FORTRAN FOXI_TST_SIF1 OVER FOXI_TST_OUF1_Y  (NLS,Y,UNIT(200,400))
FORTRAN 77 VERSION D00  NOV 02 '87
* INFO:          INFID is declared but never used.  No storage allocated.
* INFO:          OUTFID is declared but never used.  No storage allocated.
* INFO:          DCB200 is declared but never used.  No storage allocated.
* INFO:          DCB400 is declared but never used.  No storage allocated.
 Y-STATEMENTS COMPILED: 11
$"
$LINK FOXI_TST_OUF1_X  OVER FOXI_TST_X  (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  Library file :LIB_SYSTEM.:SYS used.
*  No linking errors.
*  Total program size = 8K.
*  Plovering ....
$LINK FOXI_TST_OUF1_XZ OVER FOXI_TST_XZ (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  Library file :LIB_SYSTEM.:SYS used.
*  No linking errors.
*  Total program size = 8K.
*  Plovering ....
$LINK FOXI_TST_OUF1_Y  OVER FOXI_TST_Y  (UN=FOXI, SIDCB=F$200, OUDCB=F$400)
LINK D00 here
*  :SHARED_COMMON.:SYS (Shared Library) associated.
*  Library file FOXI used.
*  No linking errors.
*  Total program size = 3K.
$"
$DEL *PM_DATA, *PM_DATA_X
  File *PM_DATA does not exist
  File *PM_DATA_X does not exist
$Under PMON
$FOXI_TST_X. FOXI_SI61 OVER *JUNK1
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_X
*PM_DATA -> *PM_DATA_X
$"
$DEL *PM_DATA, *PM_DATA_XZ
  File *PM_DATA does not exist
  File *PM_DATA_XZ does not exist
$Under PMON
$FOXI_TST_XZ. FOXI_SI61 OVER *JUNK1
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_XZ
*PM_DATA -> *PM_DATA_XZ
$"
$DEL *PM_DATA, *PM_DATA_Y
  File *PM_DATA does not exist
  File *PM_DATA_Y does not exist
$Under PMON
$FOXI_TST_Y. FOXI_SI61 OVER *JUNK2
 PMON version B01.
--> 9389  records processed!
 PMON sez:  Everything finished up ok.
$MOD *PM_DATA TO *PM_DATA_Y
*PM_DATA -> *PM_DATA_Y
$"
$PMDISP.X FOXI_TST_X,  *PM_DATA_X
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  39.04%, Service time=  60.96%.
 
  Total data points=    1007., Total time used=00:00:26.69.
 
 
LIST OF MODULES
 
  77.95% XSA$FSF
   8.64% FAST$READ
   5.96% FIND$DCB
   5.26% FAST$WRITE
   1.89% FOXI_TST
    .10% XFY_7ATLIST_
    .10% XPM_1TRAP_
    .10% XPM_1EXIT_
    .00% No Module ID
 ------- ---------------------------------------
 100.00% Total
$PMDISP.X FOXI_TST_XZ, *PM_DATA_XZ
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  42.99%, Service time=  57.01%.
 
  Total data points=    1146., Total time used=00:00:30.40.
 
 
LIST OF MODULES
 
  92.15% XSA$FSF
   3.40% FIND$DCB
           1.31% (  38.46%) [2]  GET_THE_DCB_NUMBER
   2.27% FAST$READ
   1.05% FAST$WRITE
    .70% FOXI_TST
    .17% FAST$OPEN
    .09% XFF_7INITL_
    .09% XPM_1EXIT_
    .09% XPM_1FVP_
    .00% No Module ID
 ------- ---------------------------------------
 100.01% Total
$PMDISP.X FOXI_TST_Y,  *PM_DATA_Y
 
PM EXECUTION RUN STATISTICS
 
 
  Execution time=  65.49%, Service time=  34.51%.
 
  Total data points=    4362., Total time used=00:01:53.14.
 
 
LIST OF MODULES
 
  24.00% XPM_1READ_SEQ_
  19.07% XPM_1WRITE_SEQ_
  11.78% XFY_7ATLIST_
   9.51% XFG_5DATA_
   8.96% XFG_7IO_SETUP_
   6.19% XFG_7INNAME
   5.14% XFG_7OEDIT_
   4.63% XFG_5FSCAN
   2.06% XPZ_2GETARG_
   1.86% XFY_6FIND_UBLOCK_
   1.33% XFY_5VERIFY_PARAMETERS_
   1.24% XPM_2DCB_UOPT_
    .99% XFG_7IEDIT_
    .69% XFG_5WRSEQ_
    .44% XFG_5RDSEQ_
    .39% XPM_2DCB_ACS_
    .32% XPM_2DCB_ORG_
    .32% XPM_2DCB_ARS_
    .32% FOXI_TST
    .28% XPM_2DCB_ASN_
    .16% XPM_1REW_
    .14% XPM_2DCB_LP_
    .07% XPM_1OPEN_PFILE_
    .05% XPM_1CLOSE_
    .02% XPM_2MONITOR_INFO_
    .02% XPM_1GETDCB_
    .02% XPM_1EXIT_
    .00% No Module ID
 ------- ---------------------------------------
 100.00% Total
$"
!Dont Dribble
DRIBBLE OFF @ 16:21 11/02/87
00004
00004
00006
00006
00007
00008
00009
00005
TECHNIQUES
UNFAST$ERROR
Call:
 
      CALL  UNFAST$CONTINUE ( IOSTAT, UNIT )
 -or-
      CALL  UNFAST$MONITOR  ( IOSTAT, UNIT )
 
UNFAST$CONTINUE resets the UnFast# flag for the specified unit.  When this flag
is reset, subsequent calls that request services not supported by the XSA
routines will cause the routines to revert to normal monitor I/O, rather than
incur a library error.  (The FOXI routine most likely to cause this condition
is FAST$PRECORD with a negative count.)
 
This call cancels the effect of UNFAST$ERROR (or UNFAST=1 on the call to
FAST$OPEN).  Note also that UNFAST$MONITOR is simply a synonym for
UNFAST$CONTINUE; either name may be used, with identical effect.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
Call:
 
      CALL  UNFAST$ERROR  ( IOSTAT, UNIT )
 -or-
      CALL  UNFAST$ALTRET ( IOSTAT, UNIT )
 
UNFAST$ERROR sets the UnFast# flag for the specified unit.  When this flag is
set, subsequent calls that would otherwise cause the XSA routines to revert to
normal monitor I/O (principally backspace operations via FAST$PRECORD) will
incur a library error (XSA-00097-0) instead.  The effect of this call may be
reversed at any time by a call to UNFAST$CONTINUE.
 
Note that UNFAST$ALTRET is a synonym for UNFAST$ERROR; either name may be used,
with identical effect.
 
The options IOSTAT and UNIT are as for FAST$OPEN; see that topic for details.
UNFAST$CONTINUE
RATIONALE
FAST$WRITE
EXIT_CONTROL
FOXI.X
AID=PROGRAMMING
FAST_IO
TOOL=FOXI
FOrtran Xsa Interface is the interface to the Fast Sequential File Access
package.
