/*M* CP6-EXTRACT_SI61 - CP6EXT, EXTRACT, GETCMT                   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* AND  */
/***
***/
/******************************************************************/
/*P*     NAME: EXTRACT_SI61
         DESCRIPTION: Contains CP6EXT, EXTRACT, and GETCMT modules.
***/
/***/
/*F*     NAME: CP6EXT
         PURPOSE: Mainline of EXTRACT. This procedure gets the
                   command, defines the command and intiates the
                   proper routines to produce the users request.
                                                                  */
 
CP6EXT : PROC MAIN;
 
/******************************************************************/
/***               SYMDEFS OF GLOBAL DATA                       ***/
/******************************************************************/
 
%INCLUDE CP_6;
%INCLUDE CP_6_SUBS;
%INCLUDE XU_MACRO_C;
%F$DCB(DCBN=F$DCB);
%FPT_ENQ(DCB=M$LM,RNAME=DBRNAM,WAIT_TIME=60);
%FPT_DEQ(DCB=M$LM);
DCL M$LM DCB;
%FPT_EXIT(STEPCC=ERROR);
%INCLUDE F$JIT_C;
DCL B$JIT$ PTR SYMREF;
 
/*******/                               /* I/O UNITS                          */
DCL M$DO           DCB;                 /* DOUNIT                             */
DCL F$5            DCB;                 /* SIUNIT                             */
DCL F$6            DCB;                 /* LOUNIT                             */
DCL F$102          DCB;                 /* R1UNIT                             */
DCL F$105          DCB;                 /* R2UNIT                             */
DCL M$SI           DCB;                 /* EXUNIT                             */
DCL F$107          DCB;                 /* LSUNIT                             */
DCL F$108          DCB;                 /* DATUNT                             */
DCL F$109          DCB;                 /* TXTUNT                             */
DCL F$112          DCB;                 /* AP1UNT                             */
DCL F$113          DCB;                 /* AP2UNT                             */
DCL F$114          DCB;                 /* AP3UNT                             */
DCL M$UI           DCB;                 /* UIUNIT                             */
 
DCL DOUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$DO)) ;
DCL SIUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$5  ));
DCL LOUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$6  ));
DCL R1UNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$102));
DCL R2UNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$105));
DCL EXUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$SI)) ;
DCL LSUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$107));
DCL DATUNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$108));
DCL TXTUNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$109));
DCL AP1UNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$112));
DCL AP2UNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$113));
DCL AP3UNT UBIN CONSTANT SYMDEF INIT(DCBNUM(F$114));
DCL UIUNIT UBIN CONSTANT SYMDEF INIT(DCBNUM(M$UI)) ;
 
DCL UNUM#(0:12) UBIN CONSTANT SYMDEF INIT(DCBNUM(M$DO)
                                   ,DCBNUM(F$102)
                                   ,DCBNUM(F$5)
                                   ,DCBNUM(F$6)
                                   ,DCBNUM(F$105)
                                   ,DCBNUM(M$SI)
                                   ,DCBNUM(F$107)
                                   ,DCBNUM(F$108)
                                   ,DCBNUM(F$109)
                                   ,DCBNUM(F$112)
                                   ,DCBNUM(F$113)
                                   ,DCBNUM(F$114)
                                   ,DCBNUM(M$UI));
 
DCL INUNIT UBIN STATIC SYMDEF INIT(0);
 
/*******/                               /* INPUT RECORD DATA                  */
DCL 1 TOKEN STATIC SYMDEF ALIGNED,      /* TOKEN IS THE CURRENT TOKEN         */
      2 CHR CHAR(35) UNAL,              /* ACTUAL CHARACTER STRING            */
      2 LEN UBIN BYTE UNAL,             /* LENGHT OF STRING                   */
      2 VAL SBIN BYTE UNAL,             /* -1 IF UNDEFINED, n IF IN CMD_TBL   */
      2 ID  UBIN BYTE UNAL;             /* 0 = SPLCHR, 1 = NAME, 2 = DIGIT    */
 
DCL RECORD(0:139) CHAR(1) STATIC SYMDEF;
DCL RECORDC REDEF RECORD CHAR(140);
DCL RECNBR UBIN STATIC SYMDEF;
DCL RECPOS SBIN STATIC SYMDEF;
DCL RECLEN SBIN STATIC SYMDEF;
DCL 1 RECKEY ALIGNED STATIC SYMDEF,
      2 DEC CHAR(5) UNAL,
      2 PT  CHAR(1) INIT('.') UNAL,
      2 FRC CHAR(3) UNAL;
DCL RECCHR CHAR(1) STATIC SYMDEF;
DCL TCHAR CHAR(TOKEN.LEN) BASED UNAL;
DCL SPL BIT(36) STATIC SYMDEF;     /* 0 = '-'
                                          1 = '_'
                                          2 = ':'
                                          3 = '.'
                                          4 = '#'
                                          5 = '@' */
 
/*******/                               /* DATA BASE INFO                     */
DCL 1 DT_LST BASED ALIGNED,             /* 19 WRDS                            */
      2 MUD CHAR(31) UNAL,
      2 * UBIN BYTE UNAL,
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LINE UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
 
 
DCL 1 NEW_REC STATIC SYMDEF ALIGNED,    /* 19 WRDS                            */
      2 MUD CHAR(31) UNAL,
      2 * CHAR(1) UNAL INIT(' '),
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LINE UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
 
DCL NUMRECS SBIN STATIC SYMDEF INIT(-1);
DCL NEW_BLK# UBIN STATIC SYMDEF;
DCL NEW_BYT# UBIN STATIC SYMDEF;
DCL NEW_CMT$ PTR STATIC SYMDEF;         /* POINTER TO NEW COMMENT START       */
 
/*******/                               /* FLAGS                              */
DCL TRUE     BIT(1) CONSTANT SYMDEF INIT('1'B);
DCL FALSE    BIT(1) CONSTANT SYMDEF INIT('0'B);
 
DCL BRKFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL BASOPN   BIT(1) STATIC SYMDEF INIT('0'B);
DCL OLDFIL   BIT(1) STATIC SYMDEF INIT('0'B);
DCL BLDFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL APPFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL MANFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL DOCFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL HAVDAT   BIT(1) STATIC SYMDEF INIT('0'B);
DCL BRIEF    BIT(1) STATIC SYMDEF INIT('0'B);
DCL DELFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL LSTFIL   BIT(1) STATIC SYMDEF INIT('0'B);
DCL EORFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL EOFFLG   BIT(1) STATIC SYMDEF INIT('0'B);
DCL OK       BIT(1) STATIC SYMDEF INIT('0'B);
DCL MON_BIT  BIT(1) STATIC SYMDEF INIT('0'B);
DCL SUBFLG   BIT(1) STATIC SYMDEF INIT('1'B);
 
DCL WRTFLG   BIT(1) STATIC SYMDEF INIT('1'B);
/*******/                               /* COMMENT INFO                       */
DCL CMTTBL(0:23) CHAR(1) CONSTANT SYMDEF INIT('M','P','F','D',
                                              'K','B','E','S',
                                              'I','O','C','V',
                                              'Q','N',' ',' ',
                                              '*','T','X','!',
                                              ' '*0);
DCL CMTID CHAR(1) STATIC SYMDEF;
DCL CMTMAX UBIN CONSTANT SYMDEF INIT(13);
DCL P_CMT UBIN CONSTANT SYMDEF INIT(1);
DCL F_CMT UBIN CONSTANT SYMDEF INIT(2);
DCL D_CMT UBIN CONSTANT SYMDEF INIT(3);
DCL K_CMT UBIN CONSTANT SYMDEF INIT(4);
DCL E_CMT UBIN CONSTANT SYMDEF INIT(6);
DCL S_CMT UBIN CONSTANT SYMDEF INIT(7);
DCL I_CMT UBIN CONSTANT SYMDEF INIT(8);
 
/*******/                               /* POINTERS AND BASED STRUCTURES      */
DCL C1 CHAR(1) BASED UNAL;
DCL C2 CHAR(2) BASED UNAL;
DCL C3 CHAR(3) BASED UNAL;
DCL C4 CHAR(4) BASED UNAL;
DCL C5 CHAR(5) BASED UNAL;
DCL C7 CHAR(7) BASED UNAL;
 
DCL U1 UBIN BYTE BASED UNAL;
 
DCL W1 UBIN WORD BASED ALIGNED;
 
/*******/                               /* FILE INFO                          */
DCL FNAME CHAR(31) STATIC SYMDEF;
DCL FACCT CHAR(8)  STATIC SYMDEF;
DCL FPASS CHAR(8)  STATIC SYMDEF;
DCL FNLN  UBIN     STATIC SYMDEF;
 
DCL UIACCT CHAR(8)  STATIC SYMDEF;
DCL R2NAME CHAR(31) SYMREF;
 
DCL FILNAM CHAR(31) STATIC SYMDEF;
DCL FILACT CHAR(8)  STATIC SYMDEF;
DCL FILNLN UBIN     STATIC SYMDEF;
 
/*******/                               /* EXTRA STUFF FOR EXTRACTION         */
DCL 1 OP_LST STATIC SYMDEF ALIGNED,
      2 NAM(0:1) CHAR(35) UNAL,
      2 TYP,
        3 T# SBIN BYTE UNAL,
        3 T$(0:12) CHAR(1) UNAL,
      2 MUD(0:1) CHAR(31) UNAL,
      2 LIN(0:1) UBIN;
 
DCL SAV_NAM CHAR(35) STATIC SYMDEF;
DCL SAV_LEN UBIN STATIC SYMDEF;
DCL NEW_NAM CHAR(35) STATIC SYMDEF;
DCL NEW_LEN UBIN STATIC SYMDEF;
DCL DBRNAM CHAR(40) STATIC SYMDEF;
DCL DE_NAME CHAR(35) STATIC SYMDEF;
DCL DE_LEN  UBIN STATIC SYMDEF;
DCL TITEM(0:139) CHAR(1) STATIC SYMDEF;
DCL LITEM UBIN STATIC SYMDEF;
DCL CHAR_LEN UBIN;
DCL CCHAR CHAR(CHAR_LEN) BASED;
DCL PTR1$ PTR;
DCL PTR2$ PTR;
 
DCL BUFFER CHAR(4096) STATIC SYMDEF;
DCL OUT_BUFFER CHAR(140) STATIC SYMDEF;
DCL NULL CHAR(1) CONSTANT SYMDEF INIT(';');
DCL 1 SECT# STATIC SYMDEF ALIGNED,
      2 L UBIN BYTE UNAL,
      2 C CHAR(79) UNAL;
DCL MAN_NRECS UBIN STATIC SYMDEF;
 
DCL 1 MD_HDR STATIC SYMDEF,
      2 L UBIN BYTE CALIGNED,
      2 C CHAR(79);
DCL DOC_NRECS UBIN STATIC SYMDEF;
%MACRO ADTXT(T=' ');
%SET TX=CONCAT(SUBSTR(TX,0,LENGTHC(TX)-1),BINASC(LENGTHC(T)),T,BINASC(0));
%MEND;
%MACRO A1TXT(T=' ');
%SET TX=CONCAT(BINASC(LENGTHC(T)),T,BINASC(0));
%MEND;
DCL 1 MD_INIT CONSTANT SYMDEF,
      2 A_PRE$ PTR INIT(ADDR(A0TXT)),
      2 F_PRE$ PTR INIT(ADDR(F0TXT)),
      2 K_PRE$ PTR INIT(ADDR(K0TXT)),
      2 A_POST$ PTR INIT(ADDR(A1TXT)),
      2 F_POST$ PTR INIT(ADDR(F1TXT)),
      2 K_POST$ PTR INIT(ADDR(K1TXT));
DCL 1 MD_PTRS STATIC SYMDEF,
      2 A_PRE$ PTR INIT(ADDR(A0TXT)),
      2 F_PRE$ PTR INIT(ADDR(F0TXT)),
      2 K_PRE$ PTR INIT(ADDR(K0TXT)),
      2 A_POST$ PTR INIT(ADDR(A1TXT)),
      2 F_POST$ PTR INIT(ADDR(F1TXT)),
      2 K_POST$ PTR INIT(ADDR(F1TXT)),
      2 X_POST$ PTR INIT(ADDR(K1TXT));
DCL MD_PTR$(0:6) REDEF MD_PTRS PTR;
DCL MD_CHARS CHAR(0) CONSTANT INIT('<*<F<K>*>F>K');
%A1TXT(T='.HBB');
%ADTXT(T='||%HH|');
%ADTXT(T='||%W0|');
%ADTXT(T='.HBE');
%ADTXT(T='.ALL');
%ADTXT(T='.SPB 7');
%ADTXT(T='.FBB');
%ADTXT(T='||%SS%PAGENO%|');
%ADTXT(T='.FBE');
DCL A0TXT CONSTANT CHAR(0) INIT(%TX);
DCL A1TXT CONSTANT CHAR(0) INIT(%BINASC(0));
%A1TXT(T='.INL 5');
%ADTXT(T='.UNL 5');
DCL K0TXT CONSTANT CHAR(0) INIT(%TX);
%A1TXT(T='.SPB');
DCL K1TXT CONSTANT CHAR(0) INIT(%TX);
%A1TXT(T='.HBB');
%ADTXT(T='||%HH|');
%ADTXT(T='||%W0|');
%ADTXT(T='.HBE');
%ADTXT(T='.BRP');
%ADTXT(T=' ');
%ADTXT(T='.INL 0');
DCL F0TXT CONSTANT CHAR(0) INIT(%TX);
%A1TXT(T='.SPB');
DCL F1TXT CONSTANT CHAR(0) INIT(%TX);
DCL MD_BUF CHAR(2048);
 
/*******/                               /* CONSTANT DATA FOR EXTRACTION       */
DCL SCRTYP UBIN UNAL STATIC SYMDEF;
DCL PL6    UBIN UNAL CONSTANT SYMDEF INIT(1);
DCL BASIC  UBIN UNAL CONSTANT SYMDEF INIT(2);
DCL NONPL6 UBIN UNAL CONSTANT SYMDEF INIT(3);
 
%LIST;
 
%INCLUDE EXTRACT_C2;
 
%PLIST;
/* Information messages with NUMRECS in %U2 */
/*E*      ERROR: EXH-HELLO-0
          MESSAGE0::
         CP-6 EXTRACT Version B03 - February 1982
 
*/
/*E*      ERROR: EXT-DB_DELETED-0
          MESSAGE0:  - %U2 Records in Data Base %U1 - Deleted.
*/
/*E*      ERROR: EXT-DB_SAVED-0
          MESSAGE0:  - %U2 Records in Data Base %U1 - Saved.
*/
/*E*      ERROR: EXT-OLD_DB-0
          MESSAGE0:  - Old Data Base - %U1
*/
/*E*      ERROR: EXT-NEW_DB-0
          MESSAGE0:  - New Data Base - %U1
*/
/*E*      ERROR: EXT-EX_FROM-0
          MESSAGE0:  - Extracting from - %UF %with updates from .%U3%
*/
/*E*      ERROR: EXT-GOOD_BYE-0
          MESSAGE0:  - Good Bye.
 
*/
/*E*     ERROR: EXT-MA_NOT_CREATED-0
         MESSAGE0:  - Manual File %FN not Created.
*/
/*E*     ERROR: EXT-MA_CREATED-0
         MESSAGE0:  - Manual File %FN Created.
*/
/*E*     ERROR: EXT-DO_NOT_CREATED-0
         MESSAGE0:  - Document file %FN not Created.
*/
/*E*     ERROR: EXT-DO_CREATED-0
         MESSAGE0:  - Document file %FN Created.
*/
/*E*      ERROR: EXT-WAITING-0
          MESSAGE0:  - Queued for access to Data Base %U1.
*/
/*E*      ERROR: EXT-BXABORT-4
          MESSAGE0:*** Extract non-interactive abort.
*/
/* With KOUNT in %U2 */
/*E*      ERROR: EXT-BREAK-1
          MESSAGE0:!!! Break.
 
*/
/*E*      ERROR: EXT-N_FOUND-0
          MESSAGE0:  - %U2 Records Found.
*/
/*E*      ERROR: EXT-N_DELETED-0
          MESSAGE0:  - %U2 Records Deleted.
*/
/* Errors */
/*E*      ERROR: EXT-NOT_CMT_TYP-7
          MESSAGE0:*** Unrecognized Comment Type at Line %U1(%U2).
*/
/*E*      ERROR: EXT-NOT_KEYWRD-7
          MESSAGE0:*** Missing Keyword (%U3) or : at Line %U1(%U2).
*/
/*E*      ERROR: EXT-NO_NAME-7
          MESSAGE0:*** Malformed Name at Line %U1(%U2).
*/
/*E*      ERROR: EXT-LINE_NO-7
          MESSAGE0:     - after Line %U1(%U2).
*/
/*E*      ERROR: EXT-DUP_ERR_MESS-7
          MESSAGE0:*** Duplicate Message for %U3 at Line %U1.
*/
/*E*      ERROR: EXT-NO_MESSAGE-7
          MESSAGE0:  - No Message for %U3 at Line %U1.
*/
/*E*      ERROR: EXT-No_err_sub-7
          MESSAGE0:*** No %SUB, %EQU, or %SET for %U3 at Line %U1.
*/
/*E*     ERROR: EXT-BAD_TEST_ERR-7
         MESSAGE0:*** Test NAME %U3 not Alphanumeric,$, or : at Line %U1.
*/
/*E*      ERROR: EXT-%bad_error-7
          MESSAGE:*** SCREECH/ERROR Code %U3 Malformed at Line %U1.
*/
/*E*      ERROR: EXT-BAD_TYP-7
          MESSAGE0:*** %U3 is not a Comment Type.
*/
/*E*      ERROR: EXT-BAD_NAME-7
          MESSAGE0:*** Name expected at %U3.
*/
/*E*      ERROR: EXT-NO_DB-7
          MESSAGE0:*** No Data Base Has Been Specified.
*/
/*E*      ERROR: EXT-CAN_NOT_DEL_DB-7
          MESSAGE0:*** Cannot Delete Data Base %U1
*/
/*E*      ERROR: EXT-NOT_CMD-7
          MESSAGE0:*** %U3 Is Not a Valid Command.
*/
/*E*      ERROR: EXT-DB_NO_GOOD-7
          MESSAGE0:*** Data Base Is Not Healthy, I/O Error occured.
*/
/*E*      ERROR: EXT-AB_NORM_EXIT-7
          MESSAGE0:*** Abnormal Exit ???
*/
/*E*      ERROR: EXT-FIL_TO_LONG-7
          MESSAGE0:*** File Name Exceeds 31 Characters.
*/
/*E*      ERROR: EXT-EX_FIL_NAME-7
          MESSAGE0:*** Expected File Name is Missing.
*/
/*E*      ERROR: EXT-ACT_TO_LONG-7
          MESSAGE0:*** Account Exceeds 8 Characters.
*/
/*E*      ERROR: EXT-NOT_OPT_NAME-7
          MESSAGE0:*** %U3 is Not an OPTION.
*/
/*E*      ERROR: EXT-TOO_MANY_OPT-7
          MESSAGE0:*** Only Four(4) Options are Allowed.
*/
/*E*      ERROR: EXT-TOO_MANY_TYP-7
          MESSAGE0:*** There are only 13 Valid Comment Types.
*/
/*E*      ERROR: EXT-NAME_RANGE_BAD-7
          MESSAGE0:*** Name Range is Backwards.
*/
/*E*      ERROR: EXT-MOD_RANGE_BAD-7
          MESSAGE0:*** Module Range is Backwards.
*/
/*E*      ERROR: EXT-LINE_RANGE_BAD-7
          MESSAGE0:*** Line Range is Backwards.
*/
/*E*      ERROR: EXT-NO_MOD-7
          MESSAGE0:*** No Module Name Specified.
*/
/*E*      ERROR: EXT-NO_NUMBR-7
          MESSAGE0:*** No Line Number Specified.
*/
/*E*      ERROR: EXT-NUMBR_TO_BIG-7
          MESSAGE0:*** Line Number Must be Less Than 999999
*/
/*E*      ERROR: EXT-NO_RANGE_W_WLD-7
          MESSAGE0:*** Wild Card (?) not Allowed with Range.
*/
/*E*      ERROR: EXT-NO_STATUS-7
          MESSAGE0:*** ON, INTO, or OVER Not Specified.
*/
/*E*      ERROR: EXT-NO_TYPE-7
          MESSAGE0:*** MONitor, PROcessor, or SCReech Not Specified.
*/
/*E*      ERROR: EXT-FIL_EMPTY-7
          MESSAGE0:*** %UF is Empty.
*/
/*E*      ERROR: EXT-DB_EMPTY-7
          MESSAGE0:*** Data Base %U1 is Empty.
*/
/*E*     ERROR: EXT-NO_MORE_HELP-7
         MESSAGE0:*** No More Help on That Subject is Available.
*/
/*E*     ERROR: EXT-NO_ACCESS-7
         MESSAGE0:  - Data base is open for inspection only.
*/
/*E*     ERROR: EXT-NO_XEQ_CMT-7
         MESSAGE0:*** XEQ Comment %U3 isn't in Data Base %U1.
*/
/*E*     ERROR: EXH-E$DA-HELP
         MESSAGE0::
DA[ata_base] Name[.Account] ( Name must be less than 27 characters ).
 
         MESSAGE1::
Opens two files: Name$DAT and Name$TXT. If these files do not exist, they will
be created.  If the files cannot be opened for update, this will be indicated
and will preclude the use of EXtract, Xlist, DFile, and DElete commands.
 
*/
/*E*     ERROR: EXH-E$EX-HELP
         MESSAGE0::
EX[tract] Fid       ( Fid is any valid CP6 File ID ).
 
         MESSAGE1::
Extracts from the source file Fid into the data base. If Fid has no account,
the one in M$SI is used.  You must have write access to the data base.
If M$UI is SET to a file fid, updates will be applied from its account
if a file of the same name exists there.
 
         MESSAGE3::
Extractable comment syntax: <Cmt start><Comment type>*<text><Cmt end>.
If the 'Cmt start' does not end with a '*' then you(the programmer
must add one. For example in FORTRAN : 'C*M*' would be the style for
'M' type comments.
 
In non-PL6 code, lines that are continuations of a previous commented
line must use either a ',' as the comment or the SAME letter to inform
EXTRACT that this is part of the last comment set.
The use of the same keyword as started it will terminate the current comment
and begin a new one if the types are the same.
 
         MESSAGE4::
Lines will be copied without leading or trailing blanks, blank-asterisks, or
comment definition characters with the following exceptions:
   1. Leading character stripping stops at the position of the first
non-(blank or *) of the first record of the packet (usually NAME:).
   2. Leading * and blank stripping is suppressed following a line ending
in a double colon (::). Comment definition (e.g *,*) is still stripped.
 
A name is required for most comment types, but is obtained in various ways,
usually following a keyword:
   M,P - not needed.
   F,I,Q - keyword (NAME:) - required.
   D - keyword (NAME:) - optional. If absent, previous D-name is used, or none.
   K,B,V,N - whatever is where a keyword should appear.
   E - keyword (ERROR:) - required, name format restricted (see below).
   S - keyword (SCREECH_CODE:) - required, format restricted also.
   O - keyword (MESSAGE:) - required, use quotes to include blank, *, etc.
   C - keyword (VERSION:) - required.
 
Keywords may be spelled with lower case characters if desired, so long
as the same spelling is used to start a new packet of the same type.
The name for E and S comments consists of three parts: prefix, code, and
severity.  The parts may be separated by dash (-) or underscore (_), but
not both, and if severity is present and underscore is used, severity
must be one character long (since code may properly contain underscores).
Only code is required, and may be a name or a number, optionally preceded
by a percent (%).  A name is not permitted to begin with a digit.  The
prefix is limited to four characters, although the fourth character is
reserved for use in Quacery and causes a BUild command error otherwise.
 
         MESSAGE5::
Examples:
*M* EXAMPLE This is an example of non-PL6 code
*T* ......
*P* NAME: EXAMPLE of non-PL6 extract code
*,*       so that EXTRACT knows this belongs
*,*       with the 'P' comment we use ','
 
         ENTDEF EXTRACT
         SYMDEF .......
*,*       This also belongs to 'P' comment
*D* NAME: This is a new comment type 'D'
*,*       Second line of type 'D'
*D*       Third line of type 'D'
*D* NAME: New type 'D' comment
 
 
*D* NAME: Another new 'D' comment
*,* Some more of the 'D' comment
 
         MESSAGE2::
EXTRACT will determine the source type by the first non-blank source line.
 
         PL6     - /* or ; ...   (anywhere)
         FORTRAN - C .........   (in column 1)
         BASIC   - REM or ! ..   (in column 1, See Note)
         APL     - $COM ......   (in column 1)
         CP6PROC - " or !" ...   (in column 1, most CP-6 utilities)
         TEXT    - . (dot)....   (in column 1)
         IDL     - -- (dashes)   (in column 1)
         other   - * .........   (in column 1 or 7)
 
Notes:
1. The first line must uniquely determine the source type - e.g. a PL6
program whose first line is: C:   PROC   looks like a FORTRAN program.
2. For Basic Programs the first record MUST NOT have a line number.
EXTRACT will skip over them on subsequent records.
 
Comments for all subsequent records may start anywhere but must be the
first non-blank characters of the record.
 
*/
/*E*     ERROR: EXH-E$XL-HELP
         MESSAGE0::
XL[ist] Fid         ( Fid is any valid CP6 File ID ).
 
         MESSAGE1::
EXtracts using Fid as a listfile. Each record of Fid is of the form:
 
         Filename[.Account][anything]
 
If a '.' does not follow the file name then the rest of the line is
ignored and the account then in the M$SI DCB is used.  As in EXtract,
M$UI may be SET to include updates if present.
 
*/
/*E*     ERROR: EXH-E$OU-HELP
         MESSAGE0::
OU[tput] Fid
         MESSAGE1::
Only works for REport,WHat,DElete since Build,Document,Manual use the
same DCB and reset it to ME afterwards.
 
*/
/*E*     ERROR: EXH-E$RWD-HELP
         MESSAGE0::
RE[port] [options] or WH[at] [options] or DE[lete] [options]
 
         MESSAGE1::
Options: (separated by commas, only one of each)
 
   TYPE list
Selects what comment types are to be reported, e.g. TYPE MFKB.
POSSIBLE TYPES: V, M, P, F, D, I, E, S, B, K, O, C, Q, N.
 
   LINE [start][ - end]
Selects source file line numbers, start <= end <= 999999.
End = start if absent.
 
   MODULE [start][ - end]
Selects by module name (source file name).
 
   NAME [start][ - end]
Selects by comment name (usually set by NAME: keyword).
 
A '?' may appear instead of  - end for NAME or MODULE to specify a prefix.
 
         MESSAGE2::
Output information is routed through F$102, which is scrubbed after being
used for Build, Document, and Manual commands. It may be reassigned with
the Output command until the next Build, Document, or Manual command.
*/
/*E*     ERROR: EXH-E$BU-HELP
         MESSAGE0::
BU[ild] status Fid1 [, [Fid2] [,Fid3]] type [,App1 [,App2 [,App3]]]
 
         MESSAGE1::
   status = ON   - create a new message file. If one exists, abort the command.
            INTO - update an existing file.
            OVER - create a new file. If one exists, overwrite it.
 
   fid1 is the output file name ( valid CP6 fid )
   fid2 is the file identifier for %SUBs file. It may be spelled with '??'
as the first two characters, which will be replaced by FCG of the
module name (e.g. ??_PERR_C is CP_PERR_C for IBEX but VP_PERR_C for PCL).
   fid3 is a listfile (or prefix+?) to use a subset of the data base.
 
   type = SCR[eech]   - use *S* comments and set the monitor bit.
          MON[itor]   - use *E* comments and set the monitor bit.
          PRO[cessor] - use *E* comments and reset the monitor bit.
          TEST        - use *E* comments and build a QUAC testing error file
                        that ONLY DONALD.:QUACM can understand.
   App1 = Fid for appendix file type A. (First line, number sort).
   App2 = Fid for appendix file type B. (All lines, number-FCG sort).
   App3 = Fid for appendix file type C. (First line, name sort).
If any Appn is null but its comma is present, -NO, -MS, or -NM will
be concatenated to fid1. To get App2 but not App1, say ',NO,fid'.
If F$112 is SET with RECL>50, then all three Apps will be wrapped that wide.
 
*/
/*E*     ERROR: EXH-E$MADO-HELP
         MESSAGE0::
MA[nual] Fid1,Fid2  or DO[cument] Fid1,Fid2
 
         MESSAGE1::
   fid1 is the command file. Its first two records may be:
      SECTION=<character string> (maximum 78 characters)
      HEADING=<character string> (maximum 79 characters)
Thereafter is a listfile of *F* comment names to be included in the
manual.  If the name ends in ?, it is treated as a prefix and for a Manual
command *K* comments associated with selected *F*'s are also included.
For DOcument, *P*, *F*, *D*, and *I* are always included.
For MAnual, the SECTION/HEADING information may be replaced or combined
with any number of control directives whose first three characters consist
of "*", followed by ">" or "<", followed by "*", "F", or "K".  The
default set of directives is:
*<*.HBB
*<*||%HH|
*<*||%W0|
*<*.HBE
*<*.ALL
*<*.SPB 7
*<*.FBB
*<*||%SS%PAGENO%|
*<*.FBE
*<F.HBB
*<F||%HH|
*<F||%W0|
*<F.HBE
*<F.BRP
*<F
*<F.INL 0
*<K.INL 5
*<K.UNL 5
*>K.SPB
*>F.SPB
 
Anything after the first three characters will be placed in the output
before (if *<x) or after (if *>x) the text of every corresponding comment
type (F or K, but *<* means only the first F-type, and *>* means only the
last of any type).  Substitutions are performed for %HH, %SS, %Wn, and
%Nn, which are SECTION, HEADING, Word-n of the NAME: comment line, and
F-name (N1) or K-name (N2), respectively.  If n is 0 then all words will
be substituted.  If any substitutions are requested but none are satisfied,
the entire line will be suppressed.  If %W0 appears, the NAME: comment
line and any blank lines following will be suppressed.  If any %Wn has n
too large, a preceding blank will be suppressed.
 
   fid2 is the output (TEXT input) file and must not already exist.
 
         MESSAGE2::
For both MA and DO commands, if a line of extracted commentary begins
with .XEQ (case-blind) then the rest of the line will be interpreted
as the fully qualified comment name of a commentary packet that is to
replace this line, starting with the first non-blank line after the
first line of the packet.  A fully qualified name consists of the
module-name, *F*-or-*P*-name, and any *K*-*D*-*I*-name, in that order,
separated by blanks.  If no name follows the .XEQ, the line is ignored
unless a .XEQ is in effect, in which case it is terminated.  .XEQ may
be nested 15 levels.
 
For MAnual only, if any line of extracted commentary ends in "~x",
where "x" is any character, that line will be excluded from the output
if "x" appears in the name of the file to which F$EXCLUDE is assigned.
If the excluded line is the first of a packet, then the entire packet
will be excluded.  In any case, the "~x" is excluded from the output.
This feature is also available for conditional .XEQ by spelling it
".XEQ~x comment-name".
         MESSAGE3::
Sample command file for the first few pages of Monitor Services section 3:
 
SECTION=3
HEADING=Monitor Services Reference Manual
FILE  (MANAGEMENT SERVICES)
DCB  (MANIPULATION)
M$DCB?
<eof>
 
Sample JCL to produce the document for various page sizes:
 
!TEXT ME ON fid
.PD lines-per-page,spaces-per-line (define page dimensions)
.VM 2,2,1,1   (define header and footer spacing and size)
.IFI fid2 (insert the unformatted file)
<eof>
 
*/
/*E*     ERROR: EXH-E$DF-HELP
         MESSAGE0::
DF[ile]  deletes the current data base (both files).
         MESSAGE1::
         !! C a u t i o n !!
This command has no safeguards - once a Data Base is gone it's gone.
 
*/
/*E*     ERROR: EXH-E$DCBS-HELP
         MESSAGE0::
The following DCBS are used by EXTRACT:
----------------------------------------------------------
M$DO       Error Reporting
F$5        Terminal Input
F$6        Terminal Output
F$102      Report,What,Delete,Build,Manual,Document Output
F$105      SUBS Input for Build
F$107      Listfile Input
F$108      $DAT File
F$109      $TXT File
F$112      Appendix type A - One liners by number
F$113      Appendix type B - Full description
F$114      Appendix type C - One liners by name
M$SI       Extract Source Input (Command line #1)
M$UI       Extract Update Input (Command line #2)
F$EXCLUDE  MAnual Command Exclusion Codes
 
Assignments are not useful for F$105 - F$114, except RECL on F$112.
----------------------------------------------------------
*/
/*E*     ERROR: EXH-HELLO-HELP
         MESSAGE1::
   EXTRACT is a program tool manipulate the extractable commentary in source
files. It can extract the commentary into a compact data base which it can
then use to create Error message files (with optional sorted appendices),
Manual files (to be formatted by TEXT), and selective content reports.
It is designed to provide efficient access to EXTRACT data bases and thus
minimize the necessity for reference to EXTRACT listings on microfiche.
All commands and keywords may be abbreviated to the least ambiguous
number of characters except where noted.  Type ? for more information.
 
*/
/*E*     ERROR: EXH-E$HELP-HELP
         MESSAGE0::
   The HELP feature in EXTRACT is similar to the rest of the
CP6 system. Type 'HELP' for help, 'HELP cmd' for help with a specific
command or '?' for more detail of the current help or error message.
         MESSAGE1::
Help information is available for the following:
COMMANDS           - Lists commands and their purpose
DCBS               - Lists DCBs used and their function
ALL                - Abstract of EXTRACT
HELP               - This table
command-name       - Details for the command
 
*/
/*E*     ERROR: EXH-E$CMDS-HELP
         MESSAGE0::
Commands understood by EXTRACT:
----------------------------------------------------------------------
DA[ta_base]            Opens a Data Base
EX[ract]               Extracts comments from source
XL[ist]                Extracts comments from source by listfile
OU[tput]               Changes output destination.
RE[port]               Displays entries in the Data Base
WH[at]                 Lists names of entries in Data Base
DE[lete]               Deletes entries from Data Base
BU[ild]                Creates a Error Message File and Appendices
MA[nual]               Creates a TEXT file for services Manuals (*F*,*K*)
DO[cument]             Creates a TEXT file for Documentation (*P*,*F*,*D*)
DF[il]                 Deletes entire Data Base
HE[lp]                 Reports help information
QU[it], E[nd], or X    Exits EXTRACT
----------------------------------------------------------------------
*/
/*E*     ERROR: EXH-E$QEX-HELP
         MESSAGE0::
Q[uit], E[nd], X, or <eof>
         MESSAGE1::
QUIT, END X, or <eof> will end the EXTRACT processing.
All files are closed and saved upon exit.
 
*/
/*E*       ERROR: EXH-9999-space
         MESSAGE0::
The following is a list of EXTRACT messages:
*/
 
/*******/                               /* COMMANDS                           */
%EQU DA = 0;                            /* DAta_base                          */
%EQU EX = 1;                            /* EXtract                            */
%EQU XL = 2;                            /* XList                              */
%EQU OU = 3;                            /* OUtput                             */
%EQU RE = 4;                            /* REport                             */
%EQU WH = 5;                            /* WHat                               */
%EQU DE = 6;                            /* DElete                             */
%EQU BU = 7;                            /* BUild                              */
%EQU MA = 8;                            /* MAnaual                            */
%EQU DF = 9;                            /* DFile                              */
%EQU HE = 10;                           /* HElp  ?                            */
%EQU DO = 11;                           /* DOcument                           */
%EQU TY = 20;                           /* TYpe                               */
%EQU NA = 21;                           /* NAme                               */
%EQU MO = 22;                           /* MOduale                            */
%EQU LI = 23;                           /* LIne                               */
%EQU ON = 24;                           /* ON                                 */
%EQU IN = 25;                           /* INto                               */
%EQU OV = 26;                           /* OVer                               */
%EQU MON = 27;                          /* MONitor                            */
%EQU SCR = 28;                          /* SCRecch                            */
%EQU PRO = 29;                          /* PROcessor                          */
%EQU TEST = 30;                         /* TEST                               */
%EQU CO = 40;                           /* COmmands                           */
%EQU DC = 41;                           /* DCbs                               */
%EQU AL = 43;                           /* ALl                                */
%EQU QU = 50;                           /* Quit, End                          */
 
DCL CMD_MAX UBIN CONSTANT SYMDEF INIT(53);
DCL CMD_TBL(0:52) CHAR(9) CONSTANT SYMDEF INIT('DATA_BASE', /* 0 COMMANDS     */
                           'EXTRACT  ', /* 1                                  */
                           'XLIST    ', /* 2                                  */
                           'OUTPUT   ', /* 3                                  */
                           'REPORT   ', /* 4                                  */
                           'WHAT     ', /* 5                                  */
                           'DELETE   ', /* 6                                  */
                           'BUILD    ', /* 7                                  */
                           'MANUAL   ', /* 8                                  */
                           'DFILE    ', /* 9                                  */
                           'HELP     ', /* 10                                 */
                           'DOCUMENT ', /* 11                                 */
                          '         '*8,/*12 - 19                             */
                           'TYPE     ', /* 20 OPTIONS                         */
                           'NAME     ', /* 21                                 */
                           'MODULE   ', /* 22                                 */
                           'LINE     ', /* 23                                 */
                           'ON       ', /* 24                                 */
                           'INTO     ', /* 25                                 */
                           'OVER     ', /* 26                                 */
                           'MONITOR  ', /* 27                                 */
                           'SCREECH  ', /* 28                                 */
                           'PROCESSOR', /* 29                                 */
                           'TEST     ', /* 30                                 */
                          '         '*9,/* 31 - 39                            */
                           'COMMANDS ', /* 40 HELPS                           */
                           'DCBS     ', /* 41                                 */
                           '         ', /* 42                                 */
                           'ALL      ', /* 43                                 */
                          '         '*6,/* 44 - 49                            */
                           'QUIT     ', /* 50 EXITS                           */
                           'END      ', /* 51                                 */
                           'X        ');/* 52                                 */
 
DCL HELP_TBL(0:52) CONSTANT UBIN INIT(
%E$DA,%E$EX,%E$XL,%E$OU,%E$RWD*3,%E$BU,%E$MADO,%E$DF,%E$HELP,
%E$MADO,%E$HELP*28,%E$CMDS,%E$DCBS,%HELLO*8,%E$QEX*3);
DCL APP_ENDS(0:2)CONSTANT CHAR(3)INIT('-NO','-MS','-NM');
 
DCL INITIAL ENTRY;
DCL FLINT ENTRY ALTRET;
DCL NXTTKN ENTRY;
DCL ALL_DONE ENTRY;
DCL STPDB ENTRY;
DCL RDYDB ENTRY;
DCL BLDMAN ENTRY(1);
DCL TELLER ENTRY(1);
DCL GETFID ENTRY;
DCL OPNFIL ENTRY(8);
DCL CLSFIL ENTRY(2);
DCL EXTRACT ENTRY;
DCL REPORT ENTRY;
DCL UUSUBS ENTRY;
DCL DBREAD ENTRY(3);
DCL READ_FILE ENTRY ALTRET;
 
%XUU_PARAM(FPTN=XUDATA,STCLASS="STATIC SYMDEF",BASE=YES,CLOSE_ALL=YES);
%XUU$ENTRY;
 
DCL STAT UBIN STATIC SYMDEF INIT(0);
DCL TIP  UBIN STATIC SYMDEF INIT(0);
DCL KEEP# UBIN;
DCL WHAT SBIN BYTE;
DCL I SBIN; DCL J SBIN; DCL K SBIN; DCL L SBIN;
 
/**************** START **************************************/
/* INITIALIZE FLAGS, DCBS, AND DATA */
        CALL INITIAL;
        OK = TRUE;
GET_CMD:
        IF NOT OK AND NOT DCBADDR(SIUNIT)->F$DCB.DDEV.IC# THEN DO;
           CALL TELLER(%BXABORT);
           CALL M$EXIT(FPT_EXIT);
        END;
        INUNIT = SIUNIT;
        CALL FLINT;
        SPL = '202'O;
        HAVDAT = FALSE;
        CALL NXTTKN;
        IF ADDR(TOKEN.CHR)->TCHAR = '?'
        THEN DO;
           TOKEN.VAL = %HE;
           TOKEN.ID  = 1;
        END;
        BRKFLG = FALSE;
        IF EOFFLG OR TOKEN.VAL = %QU
        THEN DO; /* EOF OR 'END' FOUND *//* STOP                              */
           CALL BAS_CLOSE;
           CALL M$EXIT;
        END;
        IF EORFLG THEN GOTO GET_CMD;
        IF TOKEN.ID ~= 1 THEN TOKEN.VAL = -1;
        DELFLG = FALSE;
        LSTFIL = FALSE;
        BLDFLG = FALSE;
        MANFLG = FALSE;
        DOCFLG = FALSE;
        BRIEF  = FALSE;
        OK = TRUE;
        DO CASE(TOKEN.VAL);
         CASE(%EX);                     /* EXTRACT                            */
           CALL BAS_UPDATE ALTRET(GET_CMD);
           CALL GETFID;
           IF NOT OK THEN GOTO GET_CMD;
           CALL OPNFIL(EXUNIT,%IN#);
           IF NOT OK THEN GOTO GET_CMD;
           INUNIT = EXUNIT;
           XUDATA.FLAGS.BASE# = %YES#;
           XUDATA.FLAGS.UP_DATE# = %NO#;
           IF UIACCT ~= '        '
           THEN DO;
              CALL OPNFIL(UIUNIT,%IN#);
              IF OK THEN XUDATA.FLAGS.UP_DATE# = %YES#;
           END;
           CALL XUU$OPEN(XUDATA) WHENRETURN DO;
              CALL EXTRACT;
           END; WHENALTRETURN DO;
              CALL TELLER(-1);
           END;
           XUDATA.FLAGS.CLOSE_ALL# = %YES#;
           CALL XUU$CLOSE(XUDATA);
           CALL STPDB;
         CASE(%XL);                     /* XLIST                              */
           CALL BAS_UPDATE ALTRET(GET_CMD);
           CALL GETFID;
           IF NOT OK THEN GOTO GET_CMD;
           CALL OPNFIL(LSUNIT,%IN#);
           IF NOT OK THEN GOTO GET_CMD;
           LSTFIL = TRUE;
XL_1:      INUNIT = LSUNIT;
           CALL FLINT;
           CALL GETFID;
           IF NOT LSTFIL THEN GOTO PASS_XL;
           IF NOT OK THEN GOTO XL_1;
           CALL OPNFIL(EXUNIT,%IN#);
           IF NOT OK THEN GOTO XL_1;
           INUNIT = EXUNIT;
           XUDATA.FLAGS.BASE# = %YES#;
           XUDATA.FLAGS.UP_DATE# = %NO#;
           IF UIACCT ~= '        '
           THEN DO;
              CALL OPNFIL(UIUNIT,%IN#);
              IF OK THEN XUDATA.FLAGS.UP_DATE# = %YES#;
           END;
           CALL XUU$OPEN(XUDATA) WHENRETURN DO;
              CALL EXTRACT;
           END; WHENALTRETURN DO;
              CALL TELLER(-1);
           END;
           XUDATA.FLAGS.CLOSE_ALL# = %YES#;
           CALL XUU$CLOSE(XUDATA);
           IF NOT BRKFLG THEN GOTO XL_1;
PASS_XL:
           CALL STPDB;
           CALL CLSFIL(LSUNIT,%SAVE#);
         CASE(%DA);                     /* DATA_BASE                          */
           CALL BAS_CLOSE;
PASS_DA:   CALL GETFID;
           IF NOT OK THEN GOTO GET_CMD;
           IF FNLN > 27 THEN FNLN = 27;
           IF FACCT = ' ' THEN FACCT = DCBADDR(TXTUNT)->F$DCB.ACCT#;
           IF FACCT = ' ' THEN FACCT = B$JIT.FACCN;
           CALL M$DEQ(FPT_DEQ)ALTRET(IDGAS);
IDGAS:     CALL INSERT(DBRNAM,1,39,FNAME);
           CALL INSERT(DBRNAM,FNLN+1,9,'.',FACCT);
           CALL INDEX1(I,' ',FACCT);
           CALL INSERT(DBRNAM,0,1,BINASC(I+FNLN+1));
           FPT_ENQ.V.SHARE#=%ALL#;
           FPT_ENQ.V.WAIT_TIME# = 0;
           CALL M$ENQ(FPT_ENQ)ALTRET(NO_DA);
           IF FALSE THEN DO;
NO_DA:        IF FPT_ENQ.V.WAIT_TIME# = 0 THEN DO;
                 CALL TELLER(%WAITING);
                 FPT_ENQ.V.WAIT_TIME# = -1;
                 CALL M$ENQ(FPT_ENQ)ALTRET(NO_DA);
              END;
              ELSE DO;
                 IF NOT BRKFLG THEN CALL TELLER(-1);
                 OK = FALSE;
                 GOTO GET_CMD;
              END;
           END;
           PINCRC(ADDR(FNAME),FNLN)->C4 = '$TXT';
           FNLN = FNLN+4;
           CALL OPNFIL(TXTUNT,%CREATE#,%OLDFILE#,%RANDOM#);
           IF NOT OK THEN GOTO GET_CMD;
           SUBSTR(FNAME,FNLN-3,2) = 'DA';
           CALL OPNFIL(DATUNT,%CREATE#,%OLDFILE#,%INDEXED#);
           IF OK THEN KEEP# = %SAVE#;
           ELSE KEEP# = 0;
           CALL CLSFIL(DATUNT,KEEP#);
           CALL CLSFIL(TXTUNT,KEEP#);
           IF NOT OK THEN GOTO GET_CMD;
           IF OLDFIL THEN CALL TELLER(%OLD_DB);
           ELSE CALL TELLER(%NEW_DB);
           BASOPN = TRUE;
           HAVDAT = FALSE;
           IF NOT WRTFLG THEN CALL TELLER(%NO_ACCESS);
         CASE(%DF);                     /* DFILE                              */
           CALL BAS_UPDATE ALTRET(GET_CMD);
           IF OLDFIL THEN CALL RDYDB;
           CALL CLSFIL(TXTUNT,%RELEASE#);
           IF NOT OK
           THEN DO;
              CALL TELLER(%CAN_NOT_DEL_DB);
              GOTO GET_CMD;
           END;
           CALL CLSFIL(DATUNT,%RELEASE#);
           BASOPN = FALSE; WRTFLG = TRUE;
           OLDFIL = FALSE; HAVDAT = FALSE;
           NUMRECS = NUMRECS + 1;
           CALL TELLER(%DB_DELETED);
           NUMRECS = -1;
         CASE(%OU);                     /* OUTPUT                             */
           CALL GETFID;
           IF NOT OK THEN GOTO GET_CMD;
           CALL CLSFIL(R1UNIT,%SAVE#);
           CALL OPNFIL(R1UNIT,%CREATE#,%ERROR#,%CONSEC#);
           IF NOT OK
           THEN CALL OPNFIL(R1UNIT,0,,,'ME',2);
         CASE(%RE,%WH,%DE);             /* REPORT, WHAT, DELETE               */
                                        /* INITIALIZE DEFAULT OP_LST          */
           OP_LST.NAM(0) = ' ';
           OP_LST.MUD(0) = OP_LST.NAM(0);
           OP_LST.LIN(0) = 0;
           OP_LST.LIN(1) = 9999999;
           OP_LST.NAM(1) = 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
           OP_LST.MUD(1) = OP_LST.NAM(1);
           OP_LST.TYP.T# = -1;
           WHAT = TOKEN.VAL;
                                        /* I is the number of options. Max 4  */
           I = 0;
RE_1:
           SPL = '002'O;
           CALL NXTTKN;
           IF ADDR(TOKEN.CHR)->TCHAR = ',' THEN GOTO RE_1;
           IF EORFLG THEN GOTO RE_2;
           IF TOKEN.ID ~= 1 THEN TOKEN.VAL = CMD_MAX;
           I = I + 1;
           IF I > 4
           THEN DO;
              CALL TELLER(%TOO_MANY_OPT);
              GOTO PASS_RE;
           END;
           IF RECCHR = '=' THEN RECPOS = RECPOS+1;
           DO CASE(TOKEN.VAL - 20);
            CASE(0);                    /* TYPE                               */
              CALL NXTTKN;
              IF TOKEN.LEN > 14
              THEN DO;
                 CALL TELLER(%TOO_MANY_TYP);
                 GOTO PASS_RE;
              END;
              DO J = 0 TO TOKEN.LEN - 1;
                 DO K = 0 TO CMTMAX;
                    IF CMTTBL(K) = PINCRC(ADDR(TOKEN.CHR),J)->C1 THEN GOTO TY_1;
                 END;
                 TOKEN.CHR = PINCRC(ADDR(TOKEN.CHR),J)->C1;
                 TOKEN.LEN = 1;
                 CALL TELLER(%BAD_TYP);
                 GOTO PASS_RE;
TY_1:
                 OP_LST.TYP.T$(J) = PINCRC(ADDR(TOKEN.CHR),J)->C1;
              END;
              OP_LST.TYP.T# = TOKEN.LEN - 1;
            CASE(1);                    /* NAME                               */
              SPL = '772'O;
              CALL NXTTKN;
              IF TOKEN.ID ~= 1
              THEN DO;
NA_1:
                 CALL TELLER(%BAD_NAME);
                 GOTO PASS_RE;
              END;
              IF PINCRC(ADDR(TOKEN.CHR),TOKEN.LEN - 1)->C1 = '?'
              THEN CHAR_LEN = TOKEN.LEN - 1;
              ELSE CHAR_LEN = 35;
              ADDR(OP_LST.NAM(0))->CCHAR = ADDR(TOKEN.CHR)->TCHAR;
              IF RECORD(RECPOS) = '-'
              THEN DO;
                 IF PINCRC(ADDR(TOKEN.CHR),TOKEN.LEN)->C1 = '?'
                 THEN DO;
                    CALL TELLER(%NO_RANGE_W_WLD);
                    GOTO PASS_RE;
                 END;
                 CALL NXTTKN;
                 CALL NXTTKN;
                 IF TOKEN.ID ~= 1 THEN GOTO NA_1;
                 IF OP_LST.NAM(0) > TOKEN.CHR
                 THEN DO;
                    CALL TELLER(%NAME_RANGE_BAD);
                    GOTO PASS_RE;
                 END;
                 CHAR_LEN = 35;
              END;
              ADDR(OP_LST.NAM(1))->CCHAR = ADDR(TOKEN.CHR)->TCHAR;
            CASE(2);                    /* MODULE                             */
              SPL = '702'O;
              CALL NXTTKN;
              IF ADDR(TOKEN.CHR)->TCHAR = '*'
              THEN DO;
                 CALL NXTTKN;
                 FNAME = TOKEN.CHR;
                 CALL CONCAT(TOKEN.CHR,'*',FNAME);
                 TOKEN.LEN = TOKEN.LEN + 1;
              END;
              IF TOKEN.ID ~= 1
              THEN DO;
MO_1:
                 CALL TELLER(%NO_MOD);
                 GOTO PASS_RE;
              END;
              IF PINCRC(ADDR(TOKEN.CHR),TOKEN.LEN - 1)->C1 = '?'
              THEN DO;
                 TOKEN.LEN = TOKEN.LEN - 1;
                 CHAR_LEN = TOKEN.LEN;
              END;
              ELSE CHAR_LEN = 31;
              ADDR(OP_LST.MUD(0))->CCHAR = ADDR(TOKEN.CHR)->TCHAR;
              IF RECORD(RECPOS) = '-'
              THEN DO;
                 IF PINCRC(ADDR(TOKEN.CHR),TOKEN.LEN)->C1 = '?'
                 THEN DO;
                    CALL TELLER(%NO_RANGE_W_WLD);
                    GOTO PASS_RE;
                 END;
                 CALL NXTTKN;
                 CALL NXTTKN;
                 IF TOKEN.ID ~= 1 THEN GOTO MO_1;
                 IF OP_LST.MUD(0) > TOKEN.CHR
                 THEN DO;
                    CALL TELLER(%MOD_RANGE_BAD);
                    GOTO PASS_RE;
                 END;
                 CHAR_LEN = 31;
              END;
              ADDR(OP_LST.MUD(1))->CCHAR = ADDR(TOKEN.CHR)->TCHAR;
            CASE(3);                    /* LINE                               */
              SPL = '002'O;
              CALL NXTTKN;
              IF TOKEN.ID ~= 2
              THEN DO;
LI_1:
                 CALL TELLER(%NO_NUMBR);
                 GOTO PASS_RE;
              END;
              IF TOKEN.LEN > 7
              THEN DO;
LI_2:
                 CALL TELLER(%NUMBR_TO_BIG);
                 GOTO PASS_RE;
              END;
              CALL CHARBIN(OP_LST.LIN(0),ADDR(TOKEN.CHR)->TCHAR);
              IF RECORD(RECPOS) = '-'
              THEN DO;
                 CALL NXTTKN;
                 CALL NXTTKN;
                 IF TOKEN.ID ~= 2 THEN GOTO LI_1;
                 IF TOKEN.LEN > 7 THEN GOTO LI_2;
                 CALL CHARBIN(OP_LST.LIN(1),ADDR(TOKEN.CHR)->TCHAR);
                 IF OP_LST.LIN(0) > OP_LST.LIN(1)
                 THEN DO;
                    CALL TELLER(%LINE_RANGE_BAD);
                    GOTO PASS_RE;
                 END;
              END;
              ELSE OP_LST.LIN(1) = OP_LST.LIN(0);
            CASE(ELSE);
              CALL TELLER(%NOT_OPT_NAME);
              GOTO PASS_RE;
           END;
           GOTO RE_1;
RE_2:
           BRIEF = TRUE;
           DELFLG = FALSE;
           IF WHAT = %RE THEN BRIEF = FALSE;
           IF WHAT = %DE
           THEN DO;
              CALL BAS_UPDATE ALTRET(GET_CMD);
              DELFLG = TRUE;
           END;
           ELSE CALL BAS_INPUT ALTRET(GET_CMD);
           CALL REPORT;
PASS_RE:   ;
 
         CASE(%BU);                     /* BUILD                              */
           CALL BAS_INPUT ALTRET(GET_CMD);
           LSTFIL = FALSE;
           OP_LST.LIN(0) = 0;
           OP_LST.LIN(1) = 9999999;
           OP_LST.NAM(0) = ' ';
           OP_LST.NAM(1) = 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
           OP_LST.MUD(0) = OP_LST.NAM(0);
           OP_LST.MUD(1) = OP_LST.NAM(1);
           CALL NXTTKN;
           IF TOKEN.VAL < %ON OR TOKEN.VAL > %OV
           THEN DO;
              CALL TELLER(%NO_STATUS);
              GOTO PASS_BU3;
           END;
           STAT = TOKEN.VAL - %ON + 1;
           CALL GETFID;
           IF NOT OK THEN GOTO PASS_BU3;
           CALL CLSFIL(R1UNIT,%SAVE#);
           CALL OPNFIL(R1UNIT,%CREATE#,STAT,%KEYED#);
           IF NOT OK THEN GOTO PASS_BU2;
           IF RECORD(RECPOS) = ','      /* FID FOLLOWS                        */
           THEN DO;
              RECPOS = RECPOS + 1;
              IF RECORD(RECPOS) = ','   /* NO %SUBS FID                       */
              THEN GOTO BU_1;
              CALL GETFID;
              IF NOT OK THEN GOTO PASS_BU1;
              R2NAME=' ';
              CALL OPNFIL(R2UNIT,%IN#);
              IF NOT OK THEN GOTO PASS_BU1;
              IF RECORD(RECPOS) ~= ',' THEN GOTO BU_2;
BU_1:
              RECPOS = RECPOS + 1;
              CALL GETFID;
              IF NOT OK THEN GOTO PASS_BU0;
              IF SUBSTR(FNAME,FNLN-1,1)='?' THEN DO;
                 OP_LST.MUD(0)=SUBSTR(FNAME,0,FNLN-1);
                 CALL CONCAT(OP_LST.MUD(1),SUBSTR(FNAME,0,FNLN-1),BINASC(511));
                 GOTO BU_2;
              END;
              CALL OPNFIL(LSUNIT,%IN#);
              IF NOT OK THEN GOTO PASS_BU0;
              LSTFIL = TRUE;
           END;
BU_2:
           CALL NXTTKN;
           IF TOKEN.VAL < %MON OR TOKEN.VAL > %TEST
           THEN DO;
              CALL TELLER(%NO_TYPE);
              GOTO BU_5;
           END;
           IF TOKEN.VAL = %SCR THEN OP_LST.TYP.T$(0) = CMTTBL(S_CMT);
           ELSE OP_LST.TYP.T$(0) = CMTTBL(E_CMT);
           OP_LST.TYP.T# = 0;
           IF TOKEN.VAL = %PRO OR
             TOKEN.VAL = %TEST THEN MON_BIT = FALSE;
           ELSE MON_BIT = TRUE;
           TIP = TOKEN.VAL - %MON;
           APPFLG = TRUE;
           IF RECORD(RECPOS) ~= ',' THEN APPFLG = FALSE;
           ELSE DO I = 0 TO 2;
              FNAME = DCBADDR(R1UNIT)->F$DCB.NAME#.C;
              FNLN = DCBADDR(R1UNIT)->F$DCB.NAME#.L + SIZEC(APP_ENDS(0));
              FACCT = DCBADDR(R1UNIT)->F$DCB.ACCT#;
              CALL INSERT(FNAME,FNLN-SIZEC(APP_ENDS(0)),
                SIZEC(APP_ENDS(0)),APP_ENDS(I));
              IF RECPOS < RECLEN THEN CALL NXTTKN;
              ELSE DO;
                 FNAME = 'NO'; FNLN = 2; FACCT = ' ';
              END;
              IF RECPOS < RECLEN AND RECORD(RECPOS) ~= ',' THEN CALL GETFID;
              CALL OPNFIL(UNUM#(I+9),%CREATE#,STAT,%KEYED#);
              IF NOT OK THEN GOTO PASS_BU1;
           END;
           IF NOT LSTFIL THEN GOTO BU_4;
BU_3:
           INUNIT = LSUNIT;
           CALL FLINT;
           CALL GETFID;
           IF SUBSTR(FNAME,FNLN-1,1) ~= '?' THEN CHAR_LEN = FNLN;
           ELSE CHAR_LEN = FNLN - 1;
           OP_LST.MUD(0) = ADDR(FNAME)->CCHAR;
           CALL INSERT(FNAME,CHAR_LEN,1,BINASC(511));
           OP_LST.MUD(1) = SUBSTR(FNAME,0,FNLN);
BU_4:
           BLDFLG = TRUE;
           IF OK THEN CALL REPORT;
           IF LSTFIL THEN GOTO BU_3;
BU_5:      ;                            /* ALL DONE                           */
           CALL CLSFIL(LSUNIT,%SAVE#);
           CALL UUSUBS;
PASS_BU0:
           CALL CLSFIL(R2UNIT,%SAVE#);
PASS_BU1:
           IF BLDFLG THEN DO;
              CALL CLSFIL(R1UNIT,%SAVE#);
              CALL CLSFIL(AP1UNT,%SAVE#);
              CALL CLSFIL(AP2UNT,%SAVE#);
              CALL CLSFIL(AP3UNT,%SAVE#);
           END;
           ELSE DO;
              CALL CLSFIL(R1UNIT,0);
              CALL CLSFIL(AP1UNT,0);
              CALL CLSFIL(AP2UNT,0);
              CALL CLSFIL(AP3UNT,0);
           END;
PASS_BU2:
           CALL OPNFIL(R1UNIT,0,,,'ME',2);
PASS_BU3:  ;
           OK = BLDFLG;
         CASE(%MA,%DO);                 /* MANUAL, DOCUMENT                   */
           CALL BAS_INPUT ALTRET(GET_CMD);
           IF TOKEN.VAL = %MA THEN MANFLG = TRUE;
           ELSE DOCFLG = TRUE;
           OP_LST.TYP.T$(0) = CMTTBL(F_CMT);
           IF MANFLG THEN OP_LST.TYP.T$(1) = CMTTBL(K_CMT);
           ELSE OP_LST.TYP.T$(1) = CMTTBL(P_CMT);
           OP_LST.TYP.T$(2) = CMTTBL(D_CMT);
           OP_LST.TYP.T$(3) = CMTTBL(I_CMT);
           OP_LST.TYP.T# = 3;
           OP_LST.NAM(0) = ' ';
           OP_LST.NAM(1) = 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
           OP_LST.MUD(0) = ' ';
           OP_LST.MUD(1) = 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz';
           OP_LST.LIN(0) = 0;
           OP_LST.LIN(1) = 9999999;
           MD_HDR.L = 0;
           MD_PTRS = MD_INIT;
           SECT#.L = 0;
           PTR2$ = ADDR(MD_BUF);
           I = 1;
           DOC_NRECS = 0;
           MAN_NRECS = 0;
           CALL GETFID;
           IF NOT OK THEN GOTO PASS_MA2;
           CALL OPNFIL(LSUNIT,%IN#);
           IF NOT OK THEN GOTO PASS_MA2;
           IF RECORD(RECPOS) = ',' THEN CALL NXTTKN;
           CALL GETFID;
           IF NOT OK THEN GOTO PASS_MA1;
           CALL CLSFIL(R1UNIT,%SAVE#);
           CALL OPNFIL(R1UNIT,%CREATE#,%ERROR#,%CONSEC#);
           IF NOT OK THEN GOTO PASS_MA2;
           INUNIT = LSUNIT;
           CALL READ_FILE ALTRET(NO_FILE);
           IF FALSE THEN DO;
NO_FILE:
              CALL TELLER(%FIL_EMPTY);
              GOTO PASS_MA0;
           END;
           DO WHILE(SUBSTR(RECORDC,0,7)='SECTION' OR
             SUBSTR(RECORDC,0,2)='*<' OR
             SUBSTR(RECORDC,0,2)='*>' OR
             SUBSTR(RECORDC,0,7)='HEADING');
              IF SUBSTR(RECORDC,0,7)='SECTION' THEN DO;
                 IF RECLEN > SIZEC(SECT#.C)+7 THEN RECLEN = SIZEC(SECT#.C)+7;
                 SECT#.L = RECLEN - 7;
                 CALL CONCAT(SECT#.C,SUBSTR(RECORDC,8,SECT#.L-1),'-');
              END;
              ELSE IF SUBSTR(RECORDC,0,1)~='*' THEN DO;
                    CHAR_LEN = RECLEN - 8;
                    IF CHAR_LEN > SIZEC(MD_HDR.C)
                    THEN CHAR_LEN = SIZEC(MD_HDR.C);
                    MD_HDR.L = CHAR_LEN;
                    MD_HDR.C = SUBSTR(RECORDC,8);
                 END;
                 ELSE DO;
                    DO WHILE (SUBSTR(RECORDC,RECLEN-1,1)=' ');
                       RECLEN = RECLEN - 1;
                    END;
                    IF SUBSTR(RECORDC,1,2)~=SUBSTR(MD_CHARS,I,2) THEN DO;
                       CALL INDEX2(I,SUBSTR(RECORDC,1,2),MD_CHARS);
                       MD_PTR$(I/2) = PTR2$;
                    END;
                    ELSE PTR2$ = PINCRC(PTR2$,-1);
                    RECLEN = RECLEN-3;
                    CALL INSERT(PTR2$->CCHAR,0,140,BINASC(RECLEN),
                      SUBSTR(RECORDC,3,RECLEN),BINASC(0));
                    PTR2$ = PINCRC(PTR2$,RECLEN+2);
                 END;
              CALL READ_FILE;
           END;
           DO WHILE (TRUE);
              CALL INDEX1(RECLEN,' ',SUBSTR(RECORDC,0,35));
              IF MANFLG THEN IF RECORD(RECLEN - 1) = '?'
                 THEN DO;
                    CHAR_LEN = RECLEN - 1; OP_LST.TYP.T# = 1; /* F AND K CMT'S */
                    OP_LST.NAM(0) = ADDR(RECORD)->CCHAR;
                    CALL CONCAT(OP_LST.NAM(1),ADDR(RECORD)->CCHAR,BINASC(511));
                 END;
                 ELSE DO;
                    CHAR_LEN = RECLEN; OP_LST.TYP.T# = 0; /* ONLY F CMT'S WANTED */
                    OP_LST.NAM(0) = ADDR(RECORD)->CCHAR;
                    OP_LST.NAM(1) = OP_LST.NAM(0);
                 END;
              ELSE DO;
                 IF RECORD(RECLEN-1) ~= '?' THEN CHAR_LEN = RECLEN;
                 ELSE CHAR_LEN = RECLEN - 1;
                 RECORD(CHAR_LEN) = BINASC(511);
                 OP_LST.MUD(0) =ADDR(RECORD)->CCHAR;
                 CHAR_LEN = RECLEN;
                 OP_LST.MUD(1) = ADDR(RECORD)->CCHAR;
              END;
              CALL REPORT;
              IF BRKFLG THEN GOTO PASS_MA0;
              CALL READ_FILE ALTRET(PASS_MA0);
           END;
PASS_MA0:
           INUNIT = R1UNIT;
           IF MAN_NRECS + DOC_NRECS = 0
           THEN DO;
              CALL CLSFIL(R1UNIT,%RELEASE#);
              IF MANFLG THEN CALL TELLER(%MA_NOT_CREATED);
              ELSE CALL TELLER(%DO_NOT_CREATED);
           END;
           ELSE DO;
              IF MANFLG THEN CALL BLDMAN;
              CALL CLSFIL(R1UNIT,%SAVE#);
              IF MANFLG THEN CALL TELLER(%MA_CREATED);
              ELSE CALL TELLER(%DO_CREATED);
           END;
PASS_MA1:
           CALL OPNFIL(R1UNIT,0,,,'ME',2);
PASS_MA2:
           CALL CLSFIL(LSUNIT,0);
PASS_MA3:  ;                            /* END OF MANUAL                      */
         CASE(%HE);                     /* HELP                               */
           IF ADDR(TOKEN.CHR)->TCHAR = '?'
           THEN CALL TELLER(-2);
           ELSE DO;
              CALL NXTTKN;
              IF EORFLG OR EOFFLG OR TOKEN.VAL = -1
              THEN I = %HE;
              ELSE I = TOKEN.VAL;
              CALL TELLER(HELP_TBL(I));
           END;
         CASE (ELSE);
           CALL TELLER(%NOT_CMD);
           OK = FALSE;
        END;                            /* END DO CASE(TOKEN.ID)              */
        GOTO GET_CMD;
%EJECT;
BAS_CLOSE: PROC ALTRET;
        IF BASOPN
        THEN DO;
           TOKEN.VAL = %QU;
           IF WRTFLG THEN CALL BAS_UPDATE ALTRET(NO_UP);
           ELSE DO;
NO_UP:        CALL BAS_INPUT ALTRET(NO_OPN);
           END;
           CALL RDYDB;
           IF DCBADDR(TXTUNT)->F$DCB.FFLG.DELF# THEN WRTFLG = %YES#;
           ELSE WRTFLG = %NO#;
           IF NUMRECS < 0 THEN KEEP# = %RELEASE#;
           ELSE KEEP# = %SAVE#;
           CALL CLSFIL(TXTUNT,KEEP#);
           CALL CLSFIL(DATUNT,KEEP#);
           NUMRECS = NUMRECS + 1;
           IF NUMRECS < 1 AND WRTFLG THEN CALL TELLER(%DB_DELETED);
           ELSE CALL TELLER(%DB_SAVED);
NO_OPN:    BASOPN = FALSE; WRTFLG = TRUE;
           OLDFIL = FALSE; HAVDAT = FALSE;
           OK = TRUE;
           NUMRECS = -1;
        END;
        RETURN;
END BAS_CLOSE;
BAS_UPDATE: PROC ALTRET;
DCL B$TCB$ PTR SYMREF;
%B$TCB(STCLASS="BASED(B$TCB$)");
%B$ALT;
%FPT_OPEN(FPTN=OPEN_IT);
%INCLUDE B_ERRORS_C;
        FPT_ENQ.V.SHARE# = %NONE#;
        WRTFLG = TRUE;
        KEEP# = %CREATE#;
        GOTO BAS_INUP;
BAS_INPUT: ENTRY ALTRET;
        KEEP# = %IN#;
        FPT_ENQ.V.SHARE# = %ALL#;
BAS_INUP:
        IF NOT BASOPN THEN DO;
           CALL TELLER(%NO_DB);
           OK = %NO#;
           ALTRETURN;
        END;
        IF DCBADDR(TXTUNT)->F$DCB.FUN# ~= KEEP# THEN DO;
           CALL CLSFIL(TXTUNT,0);
           CALL CLSFIL(DATUNT,0);
        END;
        FPT_ENQ.V.WAIT_TIME# = 0;
ENQ:    CALL M$ENQ(FPT_ENQ)ALTRET(NO_OPEN);
        IF NOT DCBADDR(TXTUNT)->F$DCB.FCD# THEN DO;
           OPEN_IT.V.FUN# = KEEP#;
           OPEN_IT.V.DCB# = TXTUNT;
           CALL M$OPEN(OPEN_IT)ALTRET(NO_OPEN);
           OPEN_IT.V.DCB# = DATUNT;
           CALL M$OPEN(OPEN_IT)ALTRET(NO_OPEN);
        END;
        IF NOT DCBADDR(TXTUNT)->F$DCB.FFLG.DELF# THEN WRTFLG = %NO#;
        IF KEEP# ~= %IN# AND NOT WRTFLG THEN DO;
           CALL TELLER(%NO_ACCESS);
           OK = %NO#;
           ALTRETURN;
        END;
        OK = %YES#;
        RETURN;
NO_OPEN:
        IF BRKFLG THEN TOKEN.VAL = %QU;
        IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$TIMELIMIT THEN DO;
           CALL TELLER(%WAITING);
           FPT_ENQ.V.WAIT_TIME# = -1;
           GOTO ENQ;
        END;
        OK = %NO#;
        IF TOKEN.VAL~=%QU OR KEEP# = %IN# THEN CALL TELLER(-1);
        CALL CLSFIL(TXTUNT,0);
        ALTRETURN;
END;
END CP6EXT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/******************************************************************/
/***/
/*F*     NAME: EXTRACT
         PURPOSE: This procedure will set up the input file, read
                   each record looking for *x* comments. When it
                   finds one it then calls GETCMT to put it in
                   the data bases.
                                                                  */
EXTRACT : PROC;
 
%INCLUDE EXTRACT_C1;
 
 
%FPT_DELREC(FPTN=DELREC,STCLASS=CONSTANT,KEY=KEYL,LKEY=KEYH,DCB=F$108);
DCL F$108 DCB;
 
DCL RECPOS SBIN SYMREF;
DCL RECORD(0:139) CHAR(1) SYMREF;
DCL RECORDC REDEF RECORD CHAR(140);
DCL RECCHR CHAR(1)SYMREF;
DCL RECLEN SBIN SYMREF;
DCL NUMRECS SBIN SYMREF;
DCL SCRTYP UBIN SYMREF;
DCL PL6 UBIN SYMREF;
DCL BASIC UBIN SYMREF;
 
DCL TELLER ENTRY(1);
DCL RDYDB ENTRY;
DCL FLINT ENTRY ALTRET;
DCL NXTCHR ENTRY ALTRET;
DCL GETCMT ENTRY;
 
DCL FNAME CHAR(31) SYMREF;
DCL FNLN UBIN SYMREF;
DCL DE_LEN UBIN SYMREF;
DCL SAV_LEN UBIN SYMREF;
DCL INDXED BIT(1) SYMREF;
DCL CMT_CHRS CHAR(0)CONSTANT SYMDEF INIT('$R-/*C.!"');
DCL CMT_CHRSLNG UBIN CONSTANT SYMDEF INIT(LENGTHC(CMT_CHRS));
DCL CMT_TXTSZ UBIN CONSTANT SYMDEF INIT(SIZEW(CMT_TXT));
DCL CMT_TXT(0:2)CONSTANT SYMDEF CHAR(4)INIT('COM','EM','-');
DCL CMT_LEN(0:2)CONSTANT SYMDEF UBIN INIT(3,2,1);
DCL 1 KEYL STATIC,
      2 L UBIN BYTE UNAL,
      2 T CHAR(35);
DCL KEYLI REDEF KEYL CHAR(36);
DCL 1 KEYH STATIC,
      2 L UBIN BYTE UNAL,
      2 T CHAR(35);
DCL KEYHI REDEF KEYH CHAR(36);
 
/*******/
 
        DE_LEN = 0;
        SAV_LEN = 0;
        IF NOT HAVDAT THEN CALL RDYDB;
        CALL FLINT;
        IF DCBADDR(UIUNIT)->F$DCB.FCD# = %YES#
        THEN DO;
           TOKEN.LEN = 8;
           TOKEN.CHR = DCBADDR(UIUNIT)->F$DCB.ACCT#;
        END;
        ELSE TOKEN.LEN = 0;
        CALL TELLER(%EX_FROM);
        KEYL.L = FNLN;
        KEYL.T = FNAME;
        IF SUBSTR(KEYL.T,0,1)='*' THEN DO;
           KEYL.T = SUBSTR(KEYL.T,1);
           KEYL.L = KEYL.L-1;
        END;
        KEYH = KEYL;
        KEYH.L = KEYH.L+1;
        CALL INSERT(KEYH.T,KEYL.L,1,BINASC(ASCBIN(' ')+1));
        IF INDXED THEN DO;
           KEYLI = KEYL.T;
           KEYHI = KEYH.T;
        END;
        CALL M$DELREC(DELREC) ALTRET(EX_1);
        NUMRECS = NUMRECS - DCBADDR(DATUNT)->F$DCB.ARS#;
EX_1:
        RECPOS = RECLEN + 1;
        CALL NXTCHR ALTRET(EX_2);
        IF BRKFLG OR (NOT OK)
        THEN DO;
EX_2:
           RETURN;
        END;
        IF RECCHR = ' ' THEN IF RECPOS >= RECLEN THEN GOTO EX_1;
           ELSE CALL NXTCHR;
        CALL INDEX1(I,RECCHR,CMT_CHRS)ALTRET(EX_1);
        IF I<CMT_TXTSZ THEN IF SUBSTR(RECORDC,RECPOS,CMT_LEN(I)) ~= CMT_TXT(I)
           THEN GOTO EX_1;
           ELSE RECPOS = RECPOS + CMT_LEN(I);
/* WE HAVE A POSS. COMMENT */
/* GET '*' */
        IF RECCHR ~= '*' THEN CALL NXTCHR;
           DO WHILE (RECCHR = '"' AND SCRTYP = BASIC OR RECCHR = ' ');
              CALL NXTCHR ALTRET(EX_1);
           END;
        IF RECCHR ~= '*'
          OR RECORD(RECPOS + 1) ~= '*' THEN GOTO EX_1;
        CALL NXTCHR;
/* WE GOT ONE, NOW PUT IT INTO DATA BASE */
        IF NOT EORFLG THEN CALL GETCMT;
        IF EOFFLG THEN GOTO EX_2;
        GOTO EX_1;
END EXTRACT;
%EOD;
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/******************************************************************/
/***/
/*F*     NAME: GETCMT
         PURPOSE: GETCMT will continue to extract the comment
                   from the code until the comment end is found.
                  When the comment end is found the record is
                   added to the 'in-core' record list and the
                   last byte of the text section is marked with
                   a zero.
                                                                 */
GETCMT : PROC;
 
%INCLUDE EXTRACT_C1;
 
DCL SPL BIT(36) SYMREF;
DCL RECCHR CHAR(1) SYMREF;
DCL RECLEN SBIN SYMREF;
DCL RECPOS SBIN SYMREF;
DCL RECNBR UBIN SYMREF;
DCL RECORD(0:139) CHAR(1) SYMREF;
DCL RECORDC REDEF RECORD CHAR(140);
DCL TRCPOS SBIN;
DCL SCRTYP UBIN SYMREF;
DCL PL6 UBIN SYMREF;
DCL BASIC UBIN SYMREF;
DCL CMTTBL CHAR(24) SYMREF;
DCL CMTMAX UBIN SYMREF;
DCL CMT_CHRS CHAR(CMT_CHRSLNG)SYMREF;
DCL CMT_TXT(0:0)CHAR(4)SYMREF;
DCL CMT_LEN(0:0)UBIN SYMREF;
DCL CMT_CHRSLNG UBIN SYMREF;
DCL CMT_TXTSZ UBIN SYMREF;
DCL NEW_NAM CHAR(35) SYMREF;
DCL SAV_NAM CHAR(35) SYMREF;
DCL DE_NAME CHAR(35) SYMREF;
DCL NEW_LEN UBIN SYMREF;
DCL SAV_LEN UBIN SYMREF;
DCL DE_LEN  UBIN SYMREF;
DCL NEW_BLK# UBIN SYMREF;
DCL NEW_BYT# UBIN SYMREF;
DCL FILNAM CHAR(31) SYMREF;
DCL 1 NEW_REC SYMREF ALIGNED,
      2 MUD CHAR(31) UNAL,
      2 * UBIN BYTE UNAL,
      2 NAM CHAR(35) UNAL,
      2 TYP UBIN BYTE UNAL,
      2 LINE UBIN(27) UNAL,
      2 BLK# UBIN(27) UNAL,
      2 BYT# UBIN(18) UNAL;
DCL TRANSTBL(0:511) CHAR(1) UNAL SYMREF;
 
DCL KEY_ID CHAR(35);
DCL KEY_IDS(0:15)CHAR(12)CONSTANT INIT(
  ' ','NAME'*3,                         /* M, P, F, D                         */
  ' '*2,'ERROR','SCREECH_CODE',         /* K, B, E, S                         */
  'NAME','MESSAGE','VERSION',' ',       /* I, O, C, V                         */
  'NAME',' '*0);                        /* Q, N                               */
DCL LOW_2_UP(0:7)CONSTANT SYMDEF CHAR(16)INIT(
' '*2,' !"#$%&''()*+,-./','0123456789:;<=>?',
'@ABCDEFGHIJKLMNO','PQRSTUVWXYZ[\]^_',
'`ABCDEFGHIJKLMNO','PQRSTUVWXYZ{|}~ ');
 
DCL TELLER ENTRY(1);
DCL NXTTKN ENTRY;
DCL ADD_LINE ENTRY(2);
DCL NXTCHR ENTRY ALTRET;
DCL NXTREC ENTRY ALTRET;
DCL ADD_LST ENTRY;
/*******/
 
AGAIN:
        CALL INDEX1(I,RECCHR,CMTTBL)ALTRET(NO_CMT);
        IF I > CMTMAX THEN DO;
           RETURN;
NO_CMT:
           IF RECCHR >= 'a' THEN DO;
              RECCHR = BINASC(ASCBIN(RECCHR)-32);
              GOTO AGAIN;
           END;
           CALL TELLER(%NOT_CMT_TYP);
           GOTO TERR;
        END;
        NEW_REC.LINE = RECNBR;
        NEW_REC.TYP = I;
        NEW_REC.MUD = FILNAM;
        NEW_REC.BYT# = NEW_BYT#;
        NEW_REC.BLK# = NEW_BLK#;
/* PASS OVER '*'s AND ' 's */
CLEAR:
        DO WHILE (RECPOS < RECLEN AND
          (RECORD(RECPOS) = ' ' OR RECORD(RECPOS) = '*'));
           RECPOS = RECPOS + 1;
        END;
        IF RECPOS >= RECLEN
        THEN DO;
           IF SCRTYP ~= PL6
           THEN CALL NXTLIN WHENRETURN DO;
                 GOTO CLEAR; END;
              WHENALTRETURN DO;
                 IF EOFFLG THEN GOTO RETRET;
                 GOTO AGAIN; END;
           CALL NXTREC ALTRET(RETRET);
           IF RECCHR ~= ' ' THEN RECPOS=RECPOS-1;
           IF SUBSTR(RECORDC,RECPOS,2) = '*/' THEN RETURN;
           GOTO CLEAR;
        END;
/* GET KEYWORD */
        TRCPOS = RECPOS;
        KEY_ID = KEY_IDS(I);
        IF KEY_ID = ' ' THEN GOTO GET_NAME;
        SPL = '202'O;
        CALL NXTTKN;
        IF TOKEN.CHR ~= KEY_ID
        THEN DO;
           CALL XLATE(NEW_NAM,LOW_2_UP,TOKEN.CHR);
           IF NEW_NAM ~= KEY_ID THEN DO;
              IF I=3 THEN DO;
                 TOKEN.CHR = SUBSTR(DE_NAME,0,DE_LEN);
                 GOTO KBNAM;
              END;
NO_KWD:
              TOKEN.CHR = KEY_ID;
              CALL INDEX1(I,' ',KEY_ID);
              TOKEN.LEN = I;
              CALL TELLER(%NOT_KEYWRD);
TERR:
              CHAR_LEN = RECLEN;
              CALL CONCAT(OUT_BUFFER,'A',ADDR(RECORD)->CCHAR);
              CALL TELLER(0);
              RETURN;
           END;
           KEY_ID = TOKEN.CHR;
        END;
        CALL NXTCHR ALTRET(NO_KWD);
        IF RECCHR = ' ' THEN CALL NXTCHR ALTRET(NO_KWD);
        IF RECCHR ~= ':' THEN GOTO NO_KWD;
GET_NAME:
        SPL = '772'O;
        CALL NXTTKN;
/* 160 IS CP6 SORT CHARACTER, 26 IS CPV'S */
        IF ADDR(TOKEN.CHR)->U1 = 26
        THEN DO;
           RECPOS = RECPOS - 1;
           RECORD(RECPOS) = BINASC(160);
           CALL NXTTKN;
        END;
        IF ADDR(TOKEN.CHR)->C1 = '('
        THEN DO;
           CALL NXTTKN;
           NEW_NAM = TOKEN.CHR;
           NEW_LEN  = TOKEN.LEN;
           CALL NXTTKN;
           IF ADDR(TOKEN.CHR)->C1 ~= ')'
           THEN DO;
              TOKEN.CHR = NEW_NAM;
              TOKEN.LEN = NEW_LEN;
           END;
           ELSE DO;
              CALL INSERT(TOKEN.CHR,0,35,'(',SUBSTR(NEW_NAM,0,NEW_LEN),')');
              TOKEN.LEN = NEW_LEN + 2;
           END;
           TOKEN.ID = 1;
        END;
        IF TOKEN.ID~=1 AND I>=2 AND I~=13 THEN DO;
           CALL TELLER(%NO_NAME);
           GOTO TERR;
        END;
        IF TOKEN.LEN>1 AND SUBSTR(TOKEN.CHR,TOKEN.LEN-1,1)='.'
        THEN DO;
           TOKEN.LEN = TOKEN.LEN-1;
           SUBSTR(TOKEN.CHR,TOKEN.LEN,1) = ' ';
        END;
        DO CASE(I);
         CASE(0);                       /* M                                  */
           NEW_REC.NAM = ' ';
         CASE(1,2);                     /* P, F                               */
           SAV_NAM = TOKEN.CHR;
           SAV_LEN = TOKEN.LEN;
           IF I = 2 THEN NEW_REC.NAM = SAV_NAM;
           ELSE NEW_REC.NAM = ' ';
           DE_LEN = 0;
         CASE(4,5,8,13);                /* K, B, I, N                         */
KBNAM:     IF SAV_NAM = TOKEN.CHR AND SAV_LEN ~= 0
           THEN NEW_REC.NAM = SAV_NAM;
           ELSE IF SAV_LEN=0 THEN NEW_REC.NAM = TOKEN.CHR;
              ELSE CALL CONCAT(NEW_REC.NAM,SUBSTR(SAV_NAM,0,SAV_LEN),
                   ' ',TOKEN.CHR);
         CASE(6,7);                     /* E, S                               */
           NEW_REC.NAM = TOKEN.CHR;
           CALL INDEX (J,'-',TOKEN.CHR) WHENALTRETURN DO;
              CALL INDEX (J,'_',TOKEN.CHR) WHENALTRETURN DO;
BAD_ERROR:       CALL TELLER (%NO_NAME);
                 GOTO TERR;
              END;
           END;
           IF J>4 THEN GOTO BAD_ERROR;
           J = J+1;
           IF J=TOKEN.LEN THEN IF RECCHR~='%' THEN GOTO BAD_ERROR;
              ELSE DO;
                 RECPOS = RECPOS+1;     /* SKIP THE %                         */
                 CALL NXTTKN;
                 IF TOKEN.ID~=1 THEN GOTO BAD_ERROR;
                 CALL INSERT (NEW_REC.NAM,J,,TOKEN.CHR);
                 TOKEN.LEN = J+TOKEN.LEN;
              END;
           IF SUBSTR(NEW_REC.NAM,J-1,1)='_' THEN DO;
              SUBSTR(NEW_REC.NAM,J-1,1) = '-';
              IF SUBSTR(NEW_REC.NAM,TOKEN.LEN-2,1)='_'
              THEN SUBSTR(NEW_REC.NAM,TOKEN.LEN-2,1) = '-';
           END;
           CALL XLATE (SUBSTR(NEW_REC.NAM,J),TRANSTBL,SUBSTR(NEW_REC.NAM,J));
           IF SUBSTR(NEW_REC.NAM,J,1)<='9' AND SUBSTR(NEW_REC.NAM,J,1)>='0'
           THEN DO WHILE J<TOKEN.LEN AND SUBSTR(NEW_REC.NAM,J,1)~='-';
              IF SUBSTR(NEW_REC.NAM,J,1)>'9' OR SUBSTR(NEW_REC.NAM,J,1)<'0'
              THEN GOTO BAD_ERROR;
              J = J+1;
           END;
         CASE(3);                       /* D                                  */
           DE_NAME = TOKEN.CHR;
           DE_LEN  = TOKEN.LEN;
           GOTO KBNAM;
         CASE(ELSE);
           NEW_REC.NAM = TOKEN.CHR;
        END;
ANYMORE:CALL ADD_LINE(TRCPOS,RECLEN-1);
        IF SCRTYP = PL6 AND (KEY_ID = ' '
          OR SUBSTR(RECORDC,RECLEN-2,2) ~= '*/')
        THEN DO;
           DO WHILE(SUBSTR(RECORDC,RECLEN - 2,2) ~= '*/');
              IF SUBSTR(RECORDC,RECLEN-2,2) = '::' THEN TRCPOS = 0;
              CALL NXTREC ALTRET(DONE);
              IF RECCHR ~= ' ' THEN RECPOS = 0;
              DO WHILE(RECPOS < RECLEN AND (SUBSTR(RECORDC,RECPOS,1)=' '
                OR SUBSTR(RECORDC,RECPOS,2)='*'));
                 RECPOS = RECPOS + 1;
              END;
              IF RECPOS < TRCPOS THEN DO;
                 IF I=6 OR I=7          /* *E* *S*                            */
                   OR SUBSTR(RECORDC,RECPOS,3) = 'TU'
                   OR SUBSTR(RECORDC,RECPOS,3) = 'tu'
                 THEN TRCPOS=RECPOS;
                 CALL ADD_LINE(RECPOS,RECLEN-1);
              END;
              ELSE CALL ADD_LINE(TRCPOS,RECLEN - 1);
           END;
DONE:
           CALL ADD_LST;
RETRET:    RETURN;
        END;
        CALL NXTLIN WHENALTRETURN DO;
           IF NOT EOFFLG THEN GOTO STP;
           GOTO DONE;
        END;
        IF SUBSTR(RECORDC,RECPOS,4)=SUBSTR(KEY_ID,0,4) THEN DO;
           SPL = '202'O;
           CALL NXTTKN;
           IF TOKEN.CHR = KEY_ID
           THEN DO;
              CALL INDEX1(RECPOS,'*',RECORDC);
              RECPOS = RECPOS + 2;
              RECCHR = SUBSTR(CMTTBL,I,1);
STP:          CALL ADD_LST;
              GOTO AGAIN;
           END;
        END;
        GOTO ANYMORE;
%EJECT;
NXTLIN: PROC ALTRET;
GET_NXT_LN:
        IF EOFFLG THEN ALTRETURN;
        CALL NXTREC ALTRET(GET_NXT_LN);
        DO WHILE RECCHR = ' ';
           CALL NXTCHR ALTRET(GET_NXT_LN);
        END;
        CALL INDEX1(J,RECCHR,CMT_CHRS)ALTRET(GET_NXT_LN);
        IF J<CMT_TXTSZ THEN IF SUBSTR(RECORDC,RECPOS,CMT_LEN(J)) ~= CMT_TXT(J)
           THEN GOTO GET_NXT_LN;
           ELSE RECPOS = RECPOS + CMT_LEN(J);
        IF RECCHR ~= '*' THEN CALL NXTCHR ALTRET(GET_NXT_LN);
           DO WHILE (RECCHR = '"' AND SCRTYP = BASIC OR RECCHR = ' ');
              CALL NXTCHR ALTRET(GET_NXT_LN);
           END;
        IF RECCHR ~= '*'
          OR RECORD(RECPOS + 1) ~= '*' THEN GOTO GET_NXT_LN;
        CALL NXTCHR ALTRET(GET_NXT_LN);
        IF RECCHR ~= ',' AND RECCHR ~= SUBSTR(CMTTBL,I,1)
          AND BINASC(ASCBIN(RECCHR)-32) ~= SUBSTR(CMTTBL,I,1) THEN ALTRETURN;
        RECPOS = RECPOS+1;
        IF SUBSTR(RECORDC,RECLEN-2,2) = '::' THEN TRCPOS = RECPOS;
        CALL NXTCHR ALTRET(GET_NXT_LN);
        IF RECCHR ~= ' ' THEN RECPOS=RECPOS-1;
        IF TRCPOS > RECPOS THEN TRCPOS = RECPOS;
        RETURN;
END NXTLIN;
END GETCMT;
