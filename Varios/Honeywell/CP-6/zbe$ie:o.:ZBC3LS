

CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=1  
        1         1             /*M* zbe$ie:c - invariant expression optimization procedure.
        2         2             /*p*
        3         3                   name: zbe$ie:c
        4         4                   purpose: This is the procedure to indentify invariant expressions
        5         5                   and move them to the head of the loop.
        6         6                   The invariant expression and movement is based on that
        7         7                   suggested by Aho and Ullman in their book, Principles of
        8         8                   compiler design.
        9         9             */
       10        10
       11        11
       12        12
       13        13             #include <stdio:h>
       14        14             #include "types:h"
       15        15             #include "cset:h"
       16        16             #include "debug:h"
       17        17             #include "global:h"
       18        18             #include "init_glob:h"
       19        19             #include "locals:h"
       20        20             #include "files:h"
       21        21             #include "get:h"
       22        22             #include "put:h"
       23        23             #include "lset:h"
       24        24             #include "map:h"
       25        25             #include "alloc:h"
       26        26             #include "go:h"
       27        27             #include "ie:h"
       28        28             #include "em_mnem:h"
       29        29             #include "em_pseu:h"
       30        30             #include "em_spec:h"
       31        31
       32        32
       33        33             extern line_p int_line();
       34        34             /* data defs for the invariant expression procession. */
       35        35
       36        36             bblock_p cur_b;
       37        37             proc_p cur_p;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=2  
       38        38             loop_p cur_lp;
       39        39             lset   invars;
       40        40             int  Sie ;
       41        41             invar_t_p  invar_tbl_start;
       42        42             invar_t_p  last_invar_tbl;
       43        43             STATIC bool ie_is_def();
       44        44             STATIC bool ie_indir_use();
       45        45
       46        46
       47        47             struct bext_ie bext_ie_init = { (cset) 0, (cset) 0, (cset) 0,
       48        48    1                                        (cset) 0, (cset) 0 };
       49        49
       50        50             /*i*
       51        51                   name: iemain
       52        52                   purpose: This is the driver routine for the invariant expression
       53        53                   processing. This is the main routine for the processing of invariant
       54        54                   expressions.
       55        55             */
       56        56             iemain(int argc, char *argv) {
       57        57    1        void ie_optimize();
       58        58    1              Sie = 0;
       59        59    1              go (argc, argv, init_globals, ie_optimize, no_action, no_action);
       60        60    1              report ("invariant expression optimizations, %d \n", Sie);
       61        61    1              return;
       62        62    1        }
       63        63
       64        64
       65        65             /*i*
       66        66                   name: ie_optimize
       67        67                   purpose: This routine is the one the sets up the tables
       68        68                   for the invariant expression processing and also does the
       69        69                   calling of the rotuines to do the actual invariant expression
       70        70                   checking.
       71        71             */
       72        72             ie_optimize( proc_p p) {
"zbe$ie:c.:ZBC3TSI", line 72: (warning) function ie_optimize called before prototype definition
       73        73    1              make_localtab (p);
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=3  
       74        74    1
       75        75    1              invar_tbl_start = (invar_t_p) 0;
       76        76    1              invars = (lset) 0;
       77        77    1              nrvars = nrlocals + nrglobals;
       78        78    1
       79        79    1              cur_p = p;  /* save current proc setting. */
       80        80    1              ie_extblocks(p);
       81        81    1              ie_extproc(p);
       82        82    1              /* call the rotuine to look for and do invar exp processing. */
       83        83    1              ie_loop_blocks(p);
       84        84    1              ie_invar_do(p);  /* go see how many invars there are, and move them
       85        85    1                                  if any are found. */
       86        86    1              ie_clearproc (p);
       87        87    1              ie_clearblocks (p);
       88        88    1              if (invars != (lset) 0) {
       89        89    2                 Ldeleteset(invars); }
       90        90    1
       91        91    1              return;
       92        92    1
       93        93    1        }
       94        94
       95        95
       96        96             /*i*
       97        97                   name: ie_extblocks
       98        98                   purpose: This routine sets up the blocks that are assoc. with
       99        99                   the extend for the block table.
      100       100             */
      101       101             ie_extblocks(proc_p p) {
"zbe$ie:c.:ZBC3TSI", line 101: (warning) function ie_extblocks called before prototype definition
      102       102    1        bblock_p b;
      103       103    1
      104       104    1              for (b = p->p_start; b != (bblock_p) 0; b = b->b_next) {
      105       105    2                b->b_extend = newiebx();
      106       106    2                b->b_extend->bx_ie = bext_ie_init;
      107       107    2              }
      108       108    1              return;
      109       109    1        }
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=4  
      110       110
      111       111
      112       112             /*i*
      113       113                   name: ie_extproc
      114       114                   purpose: This routine sets up the extend for the loops that
      115       115                   are in the current procedure that is being processed.
      116       116             */
      117       117             ie_extproc(proc_p p)  {
"zbe$ie:c.:ZBC3TSI", line 117: (warning) function ie_extproc called before prototype definition
      118       118    1        loop_p lp;
      119       119    1        Lindex pi;
      120       120    1
      121       121    1              for (pi = Lfirst(p->p_loops); pi != (Lindex) 0;
      122       122    1                        pi = Lnext (pi, p->p_loops))  {
      123       123    2                lp = (loop_p) Lelem(pi);
      124       124    2                lp->lp_extend = newielpx ();
      125       125    2                lp->LP_BLOCKS = (lset) 0;
      126       126    2                lp->LP_DONE = 0;
      127       127    2                lp->LP_CAL = 0;
      128       128    2                lp->LP_INSTR = (line_p) 0;
      129       129    2                lp->LP_HEADER = (bblock_p) 0;
      130       130    2                lp->LP_DEF = Cempty_set(nrvars);
      131       131    2                lp->LP_REF = Cempty_set(nrvars);
      132       132    2                lp->LP_BOE = Cempty_set(nrvars);
      133       133    2                lp->LP_DDEF = Cempty_set(nrvars);
      134       134    2                lp->LP_KILL = Cempty_set(nrvars);
      135       135    2              }
      136       136    1              return;
      137       137    1        }
      138       138
      139       139
      140       140             /*i*
      141       141                   name: ie_loop_blocks
      142       142                   purpose: this routine sets the blocks with the appropriate
      143       143                   loop.
      144       144             */
      145       145             ie_loop_blocks(proc_p p) {
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=5  
"zbe$ie:c.:ZBC3TSI", line 145: (warning) function ie_loop_blocks called before prototype definition
      146       146    1        bblock_p b;
      147       147    1        Lindex i;
      148       148    1
      149       149    1              for (b = p->p_start; b != (bblock_p) 0; b = b->b_next) {
      150       150    2                for (i = Lfirst(b->b_loops); i != (Lindex) 0;
      151       151    2                         i = Lnext(i, b->b_loops)) {
      152       152    3                  Ladd (b, &(((loop_p) Lelem(i))->LP_BLOCKS));
      153       153    3                }
      154       154    2              }
      155       155    1              return;
      156       156    1        }     /* end of ie_loop_blocks. */
      157       157
      158       158
      159       159
      160       160             /*i*
      161       161                   name: ie_invar_do(proc_p p)
      162       162                   purpose: This is the driver/processor routine for all the
      163       163                   loops in the procedure. The loops are processed one at a time.
      164       164                    o First find how the ids are used int the loop (scan the loop).
      165       165                    o 2nd, note if any external calls are used in the function.
      166       166                    o 3rd, walk the loop looking for invariant expressions.
      167       167                      Put the found ones on an invariant thread.
      168       168                    o 4th, walk them invariant thread and move the invariant
      169       169                      expressions/subexpressions. For subexpressions, store result
      170       170                      into temp and replace the origianl subexpression with a
      171       171                      load of the local temp into which the intermediate value
      172       172                      was stored.
      173       173                    o Repeat the above procedure for all the loops in the function
      174       174                      (procedure).
      175       175             */
      176       176             /*    The outermost loops are processed first, working inward. */
      177       177             ie_invar_do(proc_p p) {
"zbe$ie:c.:ZBC3TSI", line 177: (warning) function ie_invar_do called before prototype definition
      178       178    1        Lindex i;
      179       179    1        loop_p lp, outermost;
      180       180    1        int min_level;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=6  
      181       181    1
      182       182    1              for (;;) {
      183       183    2                min_level = 1000;
      184       184    2                for (i = Lfirst(p->p_loops); i != (Lindex) 0; i = Lnext(i,p->p_loops))
                                {
      185       185    3                  lp = (loop_p) Lelem(i);
      186       186    3                  if ( ! lp->LP_DONE && lp->lp_level < min_level) {
      187       187    4                    min_level = lp->lp_level;
      188       188    4                    outermost = lp;
      189       189    4                  }
      190       190    3                }
      191       191    2                if (min_level == 1000) break;
      192       192    2                ie_do_loop (outermost);
      193       193    2                outermost->LP_DONE = TRUE;
      194       194    2                OUTTRACE ("loop %d processed in ie, \n", outermost->lp_id);
      195       195    2              }
      196       196    1              return;
      197       197    1        }     /* end of the function ie_invar_do.  */
      198       198
      199       199
      200       200
      201       201             /*i*
      202       202                   name: ie_do_loop
      203       203                   purpose: this function sets up the info on how ids are used
      204       204                   within the block. Is the actual driver routine in setting up
      205       205                   info and actualling calling the rotuines to do the moves of
      206       206                   the invariant expressions.
      207       207             */
      208       208             ie_do_loop (loop_p lp) {
"zbe$ie:c.:ZBC3TSI", line 208: (warning) function ie_do_loop called before prototype definition
      209       209    1        bool ie_mark_invar();
      210       210    1
      211       211    1              ie_set_use(lp); /* rotuine to set how ids are used in the loop. */
      212       212    1
      213       213    1              if (lp->LP_CAL) return; /* no invar opt if external calls exist. */
      214       214    1
      215       215    1              ie_mark_invar (lp);
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=7  
      216       216    1              /* at this point we are ready to call the routine to move the
      217       217    1                 invaiant expressions to the loop head. */
      218       218    1
      219       219    1              ie_chk_valid_invar (lp);  /* chk if ok to do invars - not busy on entry.
                                */
      220       220    1              ie_move_invars (lp);
      221       221    1              ie_release_loop_tmps(lp);
      222       222    1
      223       223    1              return;
      224       224    1        }
      225       225
      226       226
      227       227             /*i*
      228       228                   name: ie_set_use
      229       229                   purpose: This routine sets how ids are used within the program.
      230       230                   Block usage of the ids is noted, and then block usage is merged
      231       231                   with loop table usage of the ids.
      232       232             */
      233       233             ie_set_use (loop_p lp) {
"zbe$ie:c.:ZBC3TSI", line 233: (warning) function ie_set_use called before prototype definition
      234       234    1        Lindex i;
      235       235    1        bblock_p b;
      236       236    1        line_p l;
      237       237    1        int v;
      238       238    1        bool found;
      239       239    1
      240       240    1              for (i=Lfirst(lp->LP_BLOCKS); i != (Lindex) 0; i = Lnext(i,lp->LP_BLOCKS
                               )) {
      241       241    2                b = (bblock_p) Lelem(i);
      242       242    2                B_DEF(b) = Cempty_set(nrvars);
      243       243    2                B_REF(b) = Cempty_set(nrvars);
      244       244    2                B_BOE(b) = Cempty_set(nrvars);
      245       245    2                B_DDEF(b) = Cempty_set(nrvars);
      246       246    2                B_KILL(b) = Cempty_set(nrvars);
      247       247    2                for (l = b->b_start; l != (line_p) 0; l = l->l_next) {
      248       248    3                  if (ie_is_def(l)) {
      249       249    4                    var_nr(l, &v, &found);
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=8  
      250       250    4                    if (found) {
      251       251    5                      if (! Cis_elem(v,  B_DEF(b))) {
      252       252    6                        Cadd(v, &B_DEF(b));
      253       253    6                        if (Cis_elem(v,lp->LP_DEF)) {
      254       254    7                          Cadd (v,&lp->LP_DDEF); } }
      255       255    5                      else {
      256       256    6                        Cadd (v,&B_DDEF(b));
      257       257    6                        Cadd (v,&lp->LP_DDEF);
      258       258    6                      }
      259       259    5                    } }
      260       260    3                  else {  /*  use of the id. */
      261       261    4                    if (is_dir_use(l)) {
      262       262    5                      var_nr(l,&v,&found);
      263       263    5                      if (found) {
      264       264    6                        Cadd (v,&B_REF(b));
      265       265    6                        if (! Cis_elem(v, B_DEF(b))) {
      266       266    7                          Cadd (v, &B_BOE(b)); }
      267       267    6                      }  /* end of is_dir_use test. */ }
      268       268    4                    if (ie_indir_use(l)) {
      269       269    5                      if (INSTR(l) == op_cal) {
      270       270    6                        lp->LP_CAL = 1; }
      271       271    5                      /* if call, will not do invar exp moves. */
      272       272    5                    }
      273       273    4                    } /* end of else on def test. */
      274       274    3                  }  /* end of loop on l    */
      275       275    2                 ie_merge_blk_uses(b, lp);
      276       276    2
      277       277    2              }  /* end of loop on blocks in the loop. */
      278       278    1
      279       279    1              return;
      280       280    1        }  /* end of the function ie_set_use. */
      281       281
      282       282
      283       283             /*i*
      284       284                   name: ie_merge_blk_uses
      285       285                   purpose this routine merges the block uses with the loops
      286       286                   uses of the ids in the program.
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=9  
      287       287             */
      288       288             ie_merge_blk_uses (bblock_p b, loop_p lp) {
"zbe$ie:c.:ZBC3TSI", line 288: (warning) function ie_merge_blk_uses called before prototype definition
      289       289    1
      290       290    1              Cjoin (B_DEF(b), &lp->LP_DEF);
      291       291    1              Cjoin (B_REF(b), &lp->LP_REF);
      292       292    1              Cjoin (B_BOE(b), &lp->LP_BOE);
      293       293    1              Cjoin (B_DDEF(b), &lp->LP_DDEF);
      294       294    1
      295       295    1              return;
      296       296    1        }
      297       297
      298       298
      299       299
      300       300             /*i*
      301       301                   name: ie_mark_invar
      302       302                   purpose: This routine walks the blocks in the loop looking
      303       303                   for invariant expressions.
      304       304             */
      305       305             ie_mark_invar(loop_p lp) {
"zbe$ie:c.:ZBC3TSI", line 305: (warning) function ie_mark_invar called before prototype definition
      306       306    1        bool ie_chk_opt();
      307       307    1        bool ie_chk_inv_exp();
      308       308    1        int type;
      309       309    1        Lindex i;
      310       310    1        bblock_p b;
      311       311    1        line_p l;
      312       312    1
      313       313    1              invars = Lempty_set();
      314       314    1              cur_lp = lp;
      315       315    1              for (i = Lfirst(lp->LP_BLOCKS); i != (Lindex) 0; i = Lnext(i,lp->LP_BLOC
                               KS)) {
      316       316    2                b = (bblock_p) Lelem(i);
      317       317    2                cur_b = b;
      318       318    2                for (l = b->b_start; l != (line_p) 0; l = l->l_next) {
      319       319    3                 if (ie_chk_inside_if(b, l)) goto skip_it;
      320       320    3                  if (ie_chk_opt(l, &type)) {
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=10 
      321       321    4                    if (ie_chk_inv_exp(l, type)) {
      322       322    5                    }
      323       323    4                  }
      324       324    3        skip_it:    ;
      325       325    3                }
      326       326    2              }
      327       327    1              return;
      328       328    1        }     /* end of function ie_mark_invar. */
      329       329
      330       330
      331       331
      332       332             /*i*
      333       333                   name: ie_chk_opt
      334       334                   purpose: This routine if the current operator is a potential
      335       335                   invariant expression entity.
      336       336             */
      337       337             ie_chk_opt (line_p l, int *type)  {
"zbe$ie:c.:ZBC3TSI", line 337: (warning) function ie_chk_opt called before prototype definition
      338       338    1
      339       339    1              switch (INSTR(l))  {
      340       340    2                case op_sde:
      341       341    2                case op_sdl:
      342       342    2                case op_ste:
      343       343    2                case op_stl:
      344       344    2                case op_zre:
      345       345    2                case op_zrl:
      346       346    2                  *type = IE_STORE;
      347       347    2                  return TRUE;
      348       348    2                case op_adi:
      349       349    2                case op_sbi:
      350       350    2                case op_mli:
      351       351    2                case op_dvi:
      352       352    2                case op_rmi:
      353       353    2                case op_sli:
      354       354    2                case op_sri:
      355       355    2                  *type = IE_INT_ARITH;
      356       356    2                  return TRUE;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=11 
      357       357    2                case op_adf:
      358       358    2                case op_sbf:
      359       359    2                case op_mlf:
      360       360    2                case op_dvf:
      361       361    2                  *type = IE_FLT_ARITH;
      362       362    2                  return TRUE;
      363       363    2              }   /* END OF THE swith statement. */
      364       364    1              *type = 0;
      365       365    1              return FALSE;
      366       366    1
      367       367    1        }     /*  end of the function ie_chk_opt.  */
      368       368
      369       369
      370       370
      371       371             /*i*
      372       372                   name: ie_chk_inv_exp
      373       373                   purpose: To find if the operand associated with the current
      374       374                   operator is invariant.
      375       375
      376       376             */
      377       377             ie_chk_inv_exp (line_p l, int type)  {
"zbe$ie:c.:ZBC3TSI", line 377: (warning) function ie_chk_inv_exp called before prototype definition
      378       378    1        bool ie_sto_zero();
      379       379    1        bool ie_sto_chk();
      380       380    1        bool ie_2arg_arith();
      381       381    1        bool ie_1arg_arith();
      382       382    1
      383       383    1              switch(type)  {
      384       384    2                case IE_STORE:
      385       385    2                  switch (INSTR(l)) {
      386       386    3                    case op_sde:
      387       387    3                    case op_ste:
      388       388    3                      if (ie_sto_chk(l)) return TRUE;
      389       389    3                      return FALSE;
      390       390    3                    case op_sdl:
      391       391    3                    case op_stl:
      392       392    3                      if (ie_sto_chk(l)) return TRUE;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=12 
      393       393    3                      return FALSE;
      394       394    3                    case op_zre:
      395       395    3                    case op_zrl:
      396       396    3                      if (ie_sto_zero(l)) return TRUE;
      397       397    3                      return FALSE;
      398       398    3                  }
      399       399    2                  return FALSE;
      400       400    2                case IE_INT_ARITH:
      401       401    2                  switch (INSTR(l)) {
      402       402    3                    case op_adi:
      403       403    3                    case op_sbi:
      404       404    3                    case op_mli:
      405       405    3                    case op_dvi:
      406       406    3                    case op_rmi:
      407       407    3                      if (ie_2arg_arith(l)) return TRUE;
      408       408    3                      return FALSE;
      409       409    3                    case op_sli:
      410       410    3                    case op_sri:
      411       411    3                      if (ie_2arg_arith(l)) return TRUE;
      412       412    3                      return FALSE;
      413       413    3                  }
      414       414    2                  return FALSE;
      415       415    2                case IE_FLT_ARITH:
      416       416    2                  if (ie_2arg_arith(l)) return TRUE;
      417       417    2                  return FALSE;
      418       418    2              }
      419       419    1              /* SHOULD not get here. */
      420       420    1        }     /* end of function ie_chk_inv_exp. */
      421       421
      422       422
      423       423
      424       424             /*i*
      425       425                   name: ie_sto_zero
      426       426                   purpose: checks to see if the operand associated with the
      427       427                   store zero instruction is an invariant.
      428       428             */
      429       429             bool ie_sto_zero (line_p l) {
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=13 
"zbe$ie:c.:ZBC3TSI", line 429: (warning) function ie_sto_zero called before prototype definition
      430       430    1        bool found;
      431       431    1        int v;
      432       432    1
      433       433    1              var_nr(l,&v,&found);
      434       434    1              if (! found || Cis_elem(v,cur_lp->LP_DDEF)) return FALSE;
      435       435    1
      436       436    1              if (Cis_elem(v,B_BOE(cur_b))) return FALSE;
      437       437    1
      438       438    1              if (cur_b == cur_lp->lp_entry || ( 1 == Lnrelems(cur_b->b_pred) &&
      439       439    1                 Lis_elem(cur_lp->lp_entry, cur_b->b_pred) ) ) {
      440       440    2                Ladd (l, &invars);
      441       441    2                ie_add_invar (l, cur_b);
      442       442    2                return TRUE;
      443       443    2              }
      444       444    1              return FALSE;
      445       445    1        }     /* END of function ie_sto_zero. */
      446       446
      447       447
      448       448
      449       449             /*I*
      450       450                   NAME: ie_sto_chk
      451       451                   purpose: This routine is the one to operands associated with the
      452       452                   store operator to see if they are invariant.
      453       453             */
      454       454             bool ie_sto_chk(line_p l) {
"zbe$ie:c.:ZBC3TSI", line 454: (warning) function ie_sto_chk called before prototype definition
      455       455    1        bool found;
      456       456    1        int v, v1;
      457       457    1        line_p p_l;
      458       458    1
      459       459    1              ie_prev_lt(l, p_l);
      460       460    1              v1 = 0;
      461       461    1              switch (INSTR(p_l)) { /* chk operator of prev instruction. */
      462       462    2                case op_loe:
      463       463    2                case op_lol:
      464       464    2                  var_nr(p_l, &v1, &found);
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=14 
      465       465    2                  if (!found || Cis_elem(v1, cur_lp->LP_DEF))
      466       466    2                    return FALSE;
      467       467    2                  break;
      468       468    2                case op_loc:
      469       469    2                  break;
      470       470    2                case op_adi:
      471       471    2                case op_sbi:
      472       472    2                case op_mli:
      473       473    2                case op_dvi:
      474       474    2                case op_rmi:
      475       475    2                case op_sli:
      476       476    2                case op_sri:
      477       477    2                case op_adf:
      478       478    2                case op_sbf:
      479       479    2                case op_mlf:
      480       480    2                case op_dvf:
      481       481    2                  if (!Lis_elem (p_l, invars)) return FALSE;
      482       482    2                  v1 = -1;
      483       483    2                  break;
      484       484    2                default:
      485       485    2                  return FALSE;
      486       486    2              }
      487       487    1
      488       488    1              found = 0;
      489       489    1              var_nr (l, &v,&found);
      490       490    1              if (! found || Cis_elem(v,cur_lp->LP_DDEF)) return FALSE;
      491       491    1              if (Cis_elem(v, B_BOE(cur_b))) return FALSE;
      492       492    1
      493       493    1              if (cur_b == cur_lp->lp_entry || ( 1 == Lnrelems(cur_b->b_pred) &&
      494       494    1                 Lis_elem(cur_lp->lp_entry, cur_b->b_pred) ) ) {
      495       495    2                Ladd (l, &invars);
      496       496    2                ie_add_invar(l, cur_b);
      497       497    2                return TRUE;
      498       498    2              }
      499       499    1              return FALSE;
      500       500    1        }
      501       501
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=15 
      502       502
      503       503
      504       504             /*i*
      505       505                   name: ie_2arg_arith
      506       506                   purpose: This routine makes sure that the operands that are
      507       507                   assoicated with the current arithmetic operator are invariant
      508       508                   entities.
      509       509             */
      510       510             bool ie_2arg_arith(line_p l)  {
"zbe$ie:c.:ZBC3TSI", line 510: (warning) function ie_2arg_arith called before prototype definition
      511       511    1        bool found;
      512       512    1        int v,v1;
      513       513    1        line_p p_l,p_l1;
      514       514    1
      515       515    1              ie_prev_lt(l, p_l);
      516       516    1              v = 0;
      517       517    1              switch (INSTR(p_l)) {
      518       518    2                case op_lol:
      519       519    2                case op_loe:
      520       520    2                  var_nr(p_l, &v, &found);
      521       521    2                  if (!found || Cis_elem(v, cur_lp->LP_DEF)) return FALSE;
      522       522    2                  if ( INSTR(p_l) == op_dvi || INSTR(p_l) == op_dvf) {
      523       523    3                     if (cur_b == cur_lp->lp_entry || ( 1 == Lnrelems(cur_b->b_pred) &
                               &
      524       524    3                        Lis_elem(cur_lp->lp_entry, cur_b->b_pred) ) ) {
      525       525    4                     } else {
      526       526    4                       return FALSE; }
      527       527    3                  }
      528       528    2                  break;
      529       529    2                case op_loc:
      530       530    2                  if (INSTR(p_l) == op_dvi || INSTR(p_l) == op_dvf) {
      531       531    3                     if (p_l->l_a.la_offset == 0) return FALSE; }
      532       532    2                  break;
      533       533    2                default:
      534       534    2                  return FALSE;
      535       535    2              }
      536       536    1
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=16 
      537       537    1              /* check the 2nd operand of the arith op. */
      538       538    1              ie_prev_lt (p_l, p_l1);
      539       539    1              switch (INSTR(p_l1)) {
      540       540    2                case op_lol:
      541       541    2                case op_loe:
      542       542    2                  var_nr (p_l1, &v1, &found);
      543       543    2                  if (!found || Cis_elem(v1, cur_lp->LP_DEF)) return FALSE;
      544       544    2                  break;
      545       545    2                case op_loc:
      546       546    2                  break;
      547       547    2                case op_adi:
      548       548    2                case op_sbi:
      549       549    2                case op_mli:
      550       550    2                case op_dvi:
      551       551    2                case op_rmi:
      552       552    2                case op_sli:
      553       553    2                case op_sri:
      554       554    2                case op_adf:
      555       555    2                case op_sbf:
      556       556    2                case op_mlf:
      557       557    2                case op_dvf:
      558       558    2                  if(!Lis_elem(p_l1, invars)) return FALSE;
      559       559    2                  v1 = -1;
      560       560    2                  break;
      561       561    2                default:
      562       562    2                  return FALSE;
      563       563    2              }  /* end of case on instr type of 1st operand. */
      564       564    1
      565       565    1              Ladd (l, &invars);
      566       566    1              ie_add_invar(l, cur_b);
      567       567    1              return TRUE;
      568       568    1        }     /* end of function ie_2arg_arith. */
      569       569
      570       570
      571       571
      572       572             /*i*
      573       573                   name: ie_1arg_arith
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=17 
      574       574                   purpose: To check if the one aarg that is associated with
      575       575                   the shift arith instruction is invariant.
      576       576             */
      577       577             bool ie_1arg_arith (line_p l) {
      578       578    1        bool found;
      579       579    1        int v;
      580       580    1        line_p p_l;
      581       581    1
      582       582    1              if (l->l_next != (line_p) 0 && INSTR(l->l_next) == op_ads) return FALSE;

      583       583    1              ie_prev_lt (l, p_l);
      584       584    1              v = 0;
      585       585    1              switch (INSTR(p_l))  {
      586       586    2                case op_loe:
      587       587    2                case op_lol:
      588       588    2                  var_nr (p_l, &v, &found);
      589       589    2                  if (!found || Cis_elem(v, cur_lp->LP_DEF)) return FALSE;
      590       590    2                  break;
      591       591    2                case op_loc:
      592       592    2                  break;
      593       593    2                case op_adi:
      594       594    2                case op_sbi:
      595       595    2                case op_mli:
      596       596    2                case op_dvi:
      597       597    2                case op_rmi:
      598       598    2                case op_sli:
      599       599    2                case op_sri:
      600       600    2                case op_adf:
      601       601    2                case op_sbf:
      602       602    2                case op_mlf:
      603       603    2                case op_dvf:
      604       604    2                  if(!Lis_elem (p_l, invars)) return FALSE;
      605       605    2                  v = -1;
      606       606    2                  break;
      607       607    2                default:
      608       608    2                  return FALSE;
      609       609    2              }  /* end of switch on operand operator type. */
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=18 
      610       610    1              Ladd (l, &invars);
      611       611    1              ie_add_invar(l, cur_b);
      612       612    1              return TRUE;
      613       613    1        }     /* end of function ie_1arg_arith. */
      614       614
      615       615
      616       616
      617       617             /*i*
      618       618                   name: ie_release_loop_tmps
      619       619                   purpose: This routine releases the temps that are used
      620       620                   in the processing of the loops when looking for invariant
      621       621                   epressions/sbuexpressions.
      622       622             */
      623       623             ie_release_loop_tmps(loop_p lp)  {
"zbe$ie:c.:ZBC3TSI", line 623: (warning) function ie_release_loop_tmps called before prototype definition
      624       624    1        bblock_p b;
      625       625    1        Lindex i;
      626       626    1        invar_t_p inv;
      627       627    1
      628       628    1              for (i=Lfirst (lp->LP_BLOCKS); i != (Lindex) 0; i = Lnext(i,lp->LP_BLOCK
                               S)) {
      629       629    2                b = (bblock_p) Lelem(i);
      630       630    2                Cdeleteset (B_DEF(b));
      631       631    2                Cdeleteset (B_REF(b));
      632       632    2                Cdeleteset (B_DDEF(b));
      633       633    2                Cdeleteset (B_BOE(b));
      634       634    2                Cdeleteset (B_KILL(b));
      635       635    2              }
      636       636    1              for (inv = invar_tbl_start; inv != (invar_t_p) 0; inv = inv->i_next) {
      637       637    2                oldstruct (invar_t, inv);
      638       638    2              }
      639       639    1
      640       640    1              invar_tbl_start = (invar_t_p) 0;
      641       641    1
      642       642    1              return;
      643       643    1        }     /* end of the routine ie_release_loop_tmps. */
      644       644
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=19 
      645       645
      646       646
      647       647             /*i*
      648       648                   name: ie_move_invars
      649       649                   prupose: this is the routine that moves the invariant
      650       650                   expressions from the body of the loop to the head of the
      651       651                   loop. For subexpressions, it also store the result of the
      652       652                   subexpression into a temp loc, and replaces the subexpression
      653       653                   in the body of the loop with a load of the temp that was
      654       654                   set at the head of the loop.
      655       655             */
      656       656             ie_move_invars (loop_p lp)  {
"zbe$ie:c.:ZBC3TSI", line 656: (warning) function ie_move_invars called before prototype definition
      657       657    1        invar_t_p inv_exp, inv_next;
      658       658    1        line_p ll,l1,l2,l3,l4,l5,ltop,lt1,lt2;
      659       659    1        line_p lnext;
      660       660    1        int tmp;
      661       661    1
      662       662    1              if (invars == (lset) 0) return; /* if not invars, exit. */
      663       663    1
      664       664    1              if (invar_tbl_start == (invar_t_p) 0) return;
      665       665    1
      666       666    1              make_header(lp); /* make sure that there is a header block
      667       667    1                                  associated with inv exp moves. */
      668       668    1              for (inv_exp = invar_tbl_start; inv_exp != (invar_t_p) 0;
      669       669    1                             inv_exp = inv_next)  {
      670       670    2                inv_next = inv_exp->i_next;
      671       671    2                ll = inv_exp->i_line;
      672       672    2                cur_b = inv_exp->i_block;
      673       673    2                switch (INSTR(ll))  {  /* find instruc. type to be moved. */
      674       674    3                  case op_zre:
      675       675    3                  case op_zrl:
      676       676    3                    l1 = ll->l_prev;
      677       677    3                    l2 = ll->l_next;
      678       678    3                    if (l1 != (line_p) 0)  {
      679       679    4                      l1->l_next = l2; }
      680       680    3                    else {
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=20 
      681       681    4                      cur_b->b_start = l2; }
      682       682    3                    if (l2 != (line_p) 0) {
      683       683    4                      l2->l_prev = l1; }
      684       684    3                    ll->l_next = (line_p) 0;
      685       685    3                    ie_move_to_header(ll, lp, ll);
      686       686    3                    break;
      687       687    3                  case op_stl:
      688       688    3                  case op_ste:
      689       689    3                    if (ll->l_prev == (line_p) 0) {return; }
      690       690    3                    ie_prev_line(ll, l1);
      691       691    3                    ie_prev_line(l1, l2);
      692       692    3                    /* look for the simple case of load,load, arith op. */
      693       693    3                    if (INSTR(l1) == op_lol || INSTR(l1) == op_loe ||
      694       694    3                        INSTR(l1) == op_loc) {
      695       695    4                      l3 = ll->l_next;
      696       696    4                      if (l3 != (line_p) 0) {
      697       697    5                        l3->l_prev = l2; }
      698       698    4                      if (l2 != (line_p) 0) {
      699       699    5                        l2->l_next = l3; }
      700       700    4                      else {
      701       701    5                        cur_b->b_start = l3; }
      702       702    4                      ll->l_next = (line_p) 0;
      703       703    4                      ie_move_to_header (l1,lp, ll);
      704       704    4                      break;
      705       705    4                    } else {
      706       706    4                      for (ltop = l1; INSTR(ltop) != op_loe && INSTR(ltop) != op_lol &
                               & INSTR(ltop) != op_loc;
      707       707    4                           ltop = lnext) {
      708       708    5                        switch (INSTR(ltop)) {
      709       709    6                          case op_adi:
      710       710    6                          case op_sbi:
      711       711    6                          case op_mli:
      712       712    6                          case op_dvi:
      713       713    6                          case op_rmi:
      714       714    6                          case op_adf:
      715       715    6                          case op_sbf:
      716       716    6                          case op_mlf:
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=21 
      717       717    6                          case op_dvf:
      718       718    6                            ie_prev_line(ltop, lt1);
      719       719    6                            ie_prev_line(lt1, lnext);
      720       720    6                            break;
      721       721    6                          case op_sli:
      722       722    6                          case op_sri:
      723       723    6                            ie_prev_line(ltop, lt1);
      724       724    6                            ie_prev_line(lt1, lnext);
      725       725    6                            break;
      726       726    6                        }
      727       727    5                      }      /* at this point ltop is a pointer to 1st
      728       728    4                                instruction of invariant expression. ll
      729       729    4                                points to the last instruction of the
      730       730    4                                invariant expression.  */
      731       731    4                      ie_prev_line(ltop, lt2);
      732       732    4                      if (lt2 != (line_p) 0) {
      733       733    5                        lt2->l_next = ll->l_next; }
      734       734    4                      else {
      735       735    5                        cur_b->b_start = ll->l_next; }
      736       736    4                      if (ll->l_next != (line_p) 0) {
      737       737    5                        PREV(ll->l_next) = lt2; }
      738       738    4
      739       739    4                      ll->l_next = (line_p) 0;
      740       740    4                      ie_move_to_header (ltop,lp,ll);
      741       741    4                      break;
      742       742    4                    }  /* end of else on instruction type for store. */
      743       743    3                  case op_adi:
      744       744    3                  case op_sbi:
      745       745    3                  case op_mli:
      746       746    3                  case op_dvi:
      747       747    3                  case op_rmi:
      748       748    3                  case op_adf:
      749       749    3                  case op_sbf:
      750       750    3                  case op_mlf:
      751       751    3                  case op_dvf:
      752       752    3                    /* check if next entity on invar thread is using this
      753       753    3                       invar operaor as an invariant operand. that is,
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=22 
      754       754    3                          l = a*b*c+d
      755       755    3                       where a,b,c,d are all invariants. */
      756       756    3                    if (ie_chk_next_invar(inv_exp, &inv_next)) {
      757       757    4                      /* at this point a true return means that we are to
      758       758    4                         skip over processing this invar, and go to the next
      759       759    4                         one.
      760       760    4                      */
      761       761    4                      goto try_next; }
      762       762    3                    /* process arith invar, and store into a temp. also do
      763       763    3                       a lol of the temp at the point where the subexpression
      764       764    3                       was wxtracted and moved to the head of the loop. */
      765       765    3                    tmp = tmplocal (cur_p, 8); /* get 8 byte temp for safty. */
      766       766    3                    ie_gen_mes_reg (cur_p, tmp);
      767       767    3                    /* the above generated a mes,3 for reg message. */
      768       768    3                    ie_prev_line(ll, l1);
      769       769    3                    ie_prev_line(l1, l2);
      770       770    3                    if (INSTR(l2) == op_lol || INSTR(l2) == op_loe || INSTR(l2) == op_
                               loc) {
      771       771    4                      l3 = PREV(l2);
      772       772    4                      if (l3 != (line_p) 0) { l3->l_next = ll->l_next; }
      773       773    4                      else {
      774       774    5                        cur_b->b_start = ll->l_next; }
      775       775    4                      if (ll->l_next != (line_p) 0) {
      776       776    5                        ll->l_next->l_prev = l3; }
      777       777    4                      /* add store to temp to the string to be moved. */
      778       778    4                      l4 = int_line(tmp); /* get new instruction. */
      779       779    4                      l4->l_instr = op_stl;
      780       780    4                      l4->l_prev = ll;
      781       781    4                      l4->l_next = (line_p) 0;
      782       782    4                      l1 = l4;
      783       783    4                      ll->l_next = l4; /* set next link. */
      784       784    4                      /* get lol for insert. */
      785       785    4                      l4 = int_line(tmp);
      786       786    4                      l4->l_instr = op_lol;
      787       787    4                      if (l3 != (line_p) 0) {
      788       788    5                        l5 = l3->l_next;
      789       789    5                        l3->l_next = l4;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=23 
      790       790    5                        l4->l_prev = l3;
      791       791    5                        l4->l_next = l5;  }
      792       792    4                      else {
      793       793    5                        l5 = cur_b->b_start;
      794       794    5                        cur_b->b_start = l4;
      795       795    5                        l4->l_prev = (line_p) 0;
      796       796    5                        l4->l_next = l5;
      797       797    5                      }
      798       798    4                      if (l5 != (line_p) 0)  {
      799       799    5                        l5->l_prev = l4;  }
      800       800    4                      ie_move_to_header (l2, lp, l1);
      801       801    4
      802       802    4                      break;
      803       803    4                    }    /* end of test on instr type. */
      804       804    3                    /* loop through the instructions looking for the 1st
      805       805    3                       instruction in the block of code to be moved to
      806       806    3                       the header.  */
      807       807    3                    for (ltop = l2; INSTR(ltop) != op_loe && INSTR(ltop) != op_lol &&
                               INSTR(ltop) != op_loc;
      808       808    3                                 ltop = lnext)  {
      809       809    4                      switch (INSTR(ltop)) {
      810       810    5                        case op_adi:
      811       811    5                        case op_sbi:
      812       812    5                        case op_mli:
      813       813    5                        case op_dvi:
      814       814    5                        case op_rmi:
      815       815    5                        case op_adf:
      816       816    5                        case op_sbf:
      817       817    5                        case op_mlf:
      818       818    5                        case op_dvf:
      819       819    5                          ie_prev_line(ltop, lt1);
      820       820    5                          ie_prev_line(lt1, lnext);
      821       821    5                          break;
      822       822    5                        case op_sli:
      823       823    5                        case op_sri:
      824       824    5                          ie_prev_line(ltop, lt1);
      825       825    5                          ie_prev_line(lt1, lnext);
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=24 
      826       826    5                          break;
      827       827    5                      }
      828       828    4                    }
      829       829    3                    /*  at his point we have the bounds of the entities
      830       830    3                        that need to be moved. */
      831       831    3                    ie_move_code_and_insert(ll, ltop, tmp,lp); /* go
      832       832    3                                      move the code into the top spot. */
      833       833    3                    /* code hass been moved, and the stored into entity
      834       834    3                       has been set on return form the call to the above
      835       835    3                       routine. */
      836       836    3                    break;
      837       837    3
      838       838    3                  /* the following is where the shift instrs are processed. */
      839       839    3                  case op_sli:
      840       840    3                  case op_sri:
      841       841    3                    /* chk if next entity on the invar thread is using this
      842       842    3                       inar operation as an invariant operand. */
      843       843    3                    if (ie_chk_next_invar(inv_exp, &inv_next))  {
      844       844    4                      /* true return means skip over the processing of this
      845       845    4                         so go get the next invar. */
      846       846    4                      goto try_next;
      847       847    4                    }
      848       848    3                    tmp = tmplocal (cur_p, 4);
      849       849    3                    ie_gen_mes_reg (cur_p, tmp);
      850       850    3                    /* the above generated a mes,3 for reg message. */
      851       851    3                    /* get rand associated with this.. */
      852       852    3                    ie_prev_line(ll, l2);
      853       853    3                    ie_prev_line(l2, l1);
      854       854    3                    if (INSTR(l1) == op_lol || INSTR(l1) == op_loe || INSTR(l1) == op_
                               loc) {
      855       855    4                      ie_move_code_and_insert (ll,l1,tmp,lp);
      856       856    4                      break;  }
      857       857    3                    for (ltop = l1; INSTR(ltop) != op_loe && INSTR(ltop) != op_lol &&
                               INSTR(ltop) != op_loc;
      858       858    3                                   ltop = lnext)  {
      859       859    4                      switch (INSTR(ltop)) {
      860       860    5                        case op_adi:
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=25 
      861       861    5                        case op_sbi:
      862       862    5                        case op_mli:
      863       863    5                        case op_dvi:
      864       864    5                        case op_adf:
      865       865    5                        case op_sbf:
      866       866    5                        case op_mlf:
      867       867    5                        case op_dvf:
      868       868    5                        case op_rmi:
      869       869    5                          ie_prev_line(ltop, lt1);
      870       870    5                          ie_prev_line(lt1, lnext);
      871       871    5                          break;
      872       872    5                        case op_sli:
      873       873    5                        case op_sri:
      874       874    5                          ie_prev_line(ltop, lt1);
      875       875    5                          ie_prev_line(lt1, lnext);
      876       876    5                          break;
      877       877    5                      }
      878       878    4                    }
      879       879    3                    ie_move_code_and_insert(ll, ltop, tmp,lp);
      880       880    3                    break;
      881       881    3                  }  /* end of switch on instruction of operator. */
      882       882    2        try_next: ;
      883       883    2              }    /* end of for loop processing invars. */
      884       884    1              return;
      885       885    1
      886       886    1        }     /* end of the function ie_move_invars. */
      887       887
      888       888
      889       889
      890       890             /*i*
      891       891                   name: ie_move_code_and_insert
      892       892                   purpose: This routine moves code from the body of the
      893       893                   loop to the loop head, and for subexpressions it store
      894       894                   result in a temp loc (in the head of the loop), and
      895       895                   also puts the load of the temp into the body of the
      896       896                   loop at the point where the subexpression was extracted.
      897       897             */
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=26 
      898       898             ie_move_code_and_insert (line_p ll,line_p ltop,int tmp,loop_p lp) {
"zbe$ie:c.:ZBC3TSI", line 898: (warning) function ie_move_code_and_insert called before prototype definition
      899       899    1        line_p l1,l4,l5,lt2;
      900       900    1
      901       901    1              l4 = int_line(tmp);  /* get new instruction. */
      902       902    1              l4->l_instr = op_stl;
      903       903    1              l4->l_prev = ll;
      904       904    1              l4->l_next = (line_p) 0;
      905       905    1              l1 = l4;
      906       906    1
      907       907    1              lt2 = PREV(ltop);
      908       908    1              if (lt2 != (line_p) 0)  {
      909       909    2                lt2->l_next = ll->l_next; }
      910       910    1              else {
      911       911    2                cur_b->b_start = ll->l_next; }
      912       912    1
      913       913    1              if (ll->l_next != (line_p) 0)  {
      914       914    2                PREV(ll->l_next) = lt2;  }
      915       915    1
      916       916    1              ll->l_next = l4;  /* set instruct thread to point to move instruct. */
      917       917    1
      918       918    1              /* get lol for insert of load of the temp to replace the moved
      919       919    1                 code in the spot where the moved code previously resided. */
      920       920    1
      921       921    1              l4 = int_line(tmp);
      922       922    1              l4->l_instr = op_lol;
      923       923    1              if (lt2 != (line_p) 0)  {
      924       924    2                l5 = lt2->l_next;
      925       925    2                lt2->l_next = l4;
      926       926    2                l4->l_prev =lt2;
      927       927    2                l4->l_next = l5;
      928       928    2              } else {
      929       929    2                l5 = cur_b->b_start;
      930       930    2                cur_b->b_start = l4;
      931       931    2                l4->l_prev = (line_p) 0;
      932       932    2                l4->l_next = l5;
      933       933    2              }
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=27 
      934       934    1              if (l5 != (line_p) 0) {
      935       935    2                l5->l_prev = l4; }
      936       936    1
      937       937    1              ie_move_to_header (ltop,lp,l1) ;
      938       938    1
      939       939    1              return;
      940       940    1        }     /* end of the function ie_move_code_and_insert. */
      941       941
      942       942
      943       943
      944       944             /*i*
      945       945                   name: ie_move_to_header
      946       946                   purpose: This is the routine to move the passed string
      947       947                   of instructions to the header block that is associated
      948       948                   with the loop.
      949       949             */
      950       950             ie_move_to_header(line_p ll, loop_p lp,line_p llast)  {
"zbe$ie:c.:ZBC3TSI", line 950: (warning) function ie_move_to_header called before prototype definition
      951       951    1        line_p *l1 ;
      952       952    1
      953       953    1              l1 = &lp->LP_INSTR;
      954       954    1              if (*l1 == (line_p) 0)  {
      955       955    2                lp->LP_HEADER->b_start = ll;
      956       956    2                ll->l_prev = (line_p) 0;
      957       957    2              } else {
      958       958    2                (*l1)->l_next = ll;
      959       959    2                PREV(ll) = *l1;
      960       960    2              }
      961       961    1
      962       962    1              *l1 = llast;
      963       963    1
      964       964    1              return;
      965       965    1        }     /* end of the function ie_move_to_header. */
      966       966
      967       967
      968       968
      969       969             /*i*
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=28 
      970       970                   name: ie_add_invar
      971       971                   purpose: This routine adds the just identified invariant
      972       972                   expression to the invariant expression table.
      973       973             */
      974       974             ie_add_invar(line_p l,bblock_p b)  {
"zbe$ie:c.:ZBC3TSI", line 974: (warning) function ie_add_invar called before prototype definition
      975       975    1        invar_t_p inv;
      976       976    1
      977       977    1              if (invar_tbl_start == (invar_t_p) 0)  {
      978       978    2                inv = (invar_t_p) newstruct(invar_t);
      979       979    2                invar_tbl_start = inv;
      980       980    2                inv->i_next = (invar_t_p) 0;
      981       981    2                inv->i_prev = (invar_t_p) 0;
      982       982    2                inv->i_line = l;
      983       983    2                inv->i_block = b;
      984       984    2                last_invar_tbl = inv;
      985       985    2              } else {
      986       986    2                inv = (invar_t_p)newstruct(invar_t);
      987       987    2                last_invar_tbl->i_next = inv;
      988       988    2                inv->i_next = (invar_t_p) 0;
      989       989    2                inv->i_prev = last_invar_tbl;
      990       990    2                inv->i_line = l;
      991       991    2                inv->i_block = b;
      992       992    2                last_invar_tbl = inv;
      993       993    2              }
      994       994    1
      995       995    1              return;
      996       996    1        }     /* end of function ie_add_invar. */
      997       997
      998       998
      999       999
     1000      1000             /*i*
     1001      1001                   name: ie_chk_next_invar
     1002      1002                   purpose: this routine is the one to check if the next invariant
     1003      1003                   immediately follows the current one.
     1004      1004             */
     1005      1005             bool ie_chk_next_invar(invar_t_p inv_exp, invar_t_p *inv_next)  {
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=29 
"zbe$ie:c.:ZBC3TSI", line 1005: (warning) function ie_chk_next_invar called before prototype definition
     1006      1006    1        invar_t_p inv;
     1007      1007    1        line_p l,l1,l2;
     1008      1008    1        bblock_p b;
     1009      1009    1
     1010      1010    1              l = inv_exp->i_line;
     1011      1011    1              b = inv_exp->i_block;
     1012      1012    1              inv = inv_exp->i_next;
     1013      1013    1              if (inv == (invar_t_p) 0) return FALSE;
     1014      1014    1              l1 = l->l_next;
     1015      1015    1              if (l1 == (line_p) 0) return FALSE;
     1016      1016    1              if (INSTR(l1) == op_ste || INSTR(l1) == op_stl ||
     1017      1017    1                  INSTR(l1) == op_sde || INSTR(l1) == op_sdl )  {
     1018      1018    2                if (inv->i_line == l1 )  { *inv_next = inv; return TRUE; }
     1019      1019    2              }
     1020      1020    1              if (INSTR(l1) == op_lol || INSTR(l1) == op_loe || INSTR(l1) == op_loc)
                               {
     1021      1021    2                l2 = l1->l_next;
     1022      1022    2                switch (INSTR(l2))  {
     1023      1023    3                  case op_adi:
     1024      1024    3                  case op_sbi:
     1025      1025    3                  case op_mli:
     1026      1026    3                  case op_dvi:
     1027      1027    3                  case op_sli:
     1028      1028    3                  case op_sri:
     1029      1029    3                  case op_adf:
     1030      1030    3                  case op_sbf:
     1031      1031    3                  case op_mlf:
     1032      1032    3                  case op_dvf:
     1033      1033    3                    if (inv->i_line == l2)  {
     1034      1034    4                      *inv_next = inv;
     1035      1035    4                      return TRUE;
     1036      1036    4                    }
     1037      1037    3                  default:
     1038      1038    3                    return FALSE;
     1039      1039    3                }   /* end of switch statement. */
     1040      1040    2              }  /* end of test on stmt type. */
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=30 
     1041      1041    1              if (INSTR(l1) == op_sli || INSTR(l1) == op_sri) {
     1042      1042    2                if (inv->i_line == l1) {
     1043      1043    3                  *inv_next = inv;
     1044      1044    3                  return TRUE;
     1045      1045    3                }
     1046      1046    2              }
     1047      1047    1
     1048      1048    1              return FALSE;
     1049      1049    1        }     /* end of the function ie_chk_next_invar. */
     1050      1050
     1051      1051
     1052      1052
     1053      1053
     1054      1054             /*i*
     1055      1055                   name: ie_cleanproc
     1056      1056                   purpose: This rotuine cleans up the loop table extends,
     1057      1057                   by releasing them.
     1058      1058
     1059      1059             */
     1060      1060             ie_clearproc(proc_p p)  {
"zbe$ie:c.:ZBC3TSI", line 1060: (warning) function ie_clearproc called before prototype definition
     1061      1061    1
     1062      1062    1        loop_p lp;
     1063      1063    1        Lindex pi;
     1064      1064    1
     1065      1065    1              for (pi = Lfirst(p->p_loops); pi != (Lindex) 0; pi = Lnext(pi,p->p_loops
                               )) {
     1066      1066    2                lp = (loop_p) Lelem(pi);
     1067      1067    2                oldielpx (lp->lp_extend);
     1068      1068    2                lp->lp_extend = (lpext_p) 0;
     1069      1069    2              }
     1070      1070    1              return;
     1071      1071    1        }     /* end of the function ie_clearproc. */
     1072      1072
     1073      1073
     1074      1074
     1075      1075             /*i*
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=31 
     1076      1076                   name: ie_clearblocks (proc_p p) {
     1077      1077                   purpose: This routine is used to clear the blocks that have
     1078      1078                   been added to the block extend.
     1079      1079             */
     1080      1080             ie_clearblocks(proc_p p)  {
"zbe$ie:c.:ZBC3TSI", line 1080: (warning) function ie_clearblocks called before prototype definition
     1081      1081    1        bblock_p b;
     1082      1082    1
     1083      1083    1              for (b = p->p_start; b != (bblock_p) 0; b = b->b_next) {
     1084      1084    2                oldiebx (b->b_extend);
     1085      1085    2                b->b_extend = (bext_p) 0;
     1086      1086    2              }
     1087      1087    1              return;
     1088      1088    1        }     /* end of the function ie_clearblocks. */
     1089      1089
     1090      1090
     1091      1091             STATIC bool ie_is_def(l)
     1092      1092              line_p l;
     1093      1093             {
     1094      1094    1         /* See if l does a direct definition */
     1095      1095    1
     1096      1096    1         switch(INSTR(l)) {
     1097      1097    2            case op_sde:
     1098      1098    2            case op_sdl:
     1099      1099    2            case op_ste:
     1100      1100    2            case op_stl:
     1101      1101    2            case op_inl:
     1102      1102    2            case op_ine:
     1103      1103    2            case op_dee:
     1104      1104    2            case op_del:
     1105      1105    2            case op_zre:
     1106      1106    2            case op_zrl:
     1107      1107    2               return TRUE;
     1108      1108    2            default:
     1109      1109    2               return FALSE;
     1110      1110    2         }
     1111      1111    1         /* NOTREACHED */
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=32 
     1112      1112    1        }
     1113      1113
     1114      1114             ie_gen_mes_reg (p, tmp)
     1115      1115             proc_p p;
     1116      1116             int tmp;
     1117      1117             {
     1118      1118    1        line_p l,pro;
     1119      1119    1        extern line_p reg_mes();
     1120      1120    1
     1121      1121    1              l = reg_mes (tmp, 4, 0, 0);
     1122      1122    1              pro = p->p_start->b_start;
     1123      1123    1              l->l_next = pro->l_next;
     1124      1124    1              PREV(l->l_next) = l;
     1125      1125    1              pro->l_next = l;
     1126      1126    1              PREV(l) = pro;
     1127      1127    1        }
     1128      1128
     1129      1129             STATIC bool ie_indir_use(l)
     1130      1130              line_p l;
     1131      1131             {
     1132      1132    1         /* See if instruction l uses some variable(s) indirectly,
     1133      1133    1          * i.e. through a pointer or via a procedure call.
     1134      1134    1          */
     1135      1135    1
     1136      1136    1         switch(INSTR(l)) {
     1137      1137    2            case op_blm:
     1138      1138    2            case op_bls:
     1139      1139    2            case op_cai:
     1140      1140    2            case op_cal:
     1141      1141    2            case op_lar:
     1142      1142    2            case op_ldf:
     1143      1143    2            case op_lil:
     1144      1144    2          case op_lal:
     1145      1145    2            case op_lof:
     1146      1146    2            case op_loi:
     1147      1147    2            case op_los:
     1148      1148    2            case op_mon:
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=33 
     1149      1149    2               return TRUE;
     1150      1150    2            default:
     1151      1151    2               return FALSE;
     1152      1152    2         }
     1153      1153    1         /* NOTREACHED */
     1154      1154    1        }
     1155      1155
     1156      1156             /*I*
     1157      1157                   name: ie_chk_valid_invar
     1158      1158                   purpose: This routine chks the previous blocks to make sure that
     1159      1159                   the selected invariant ids are not busy on entry. That is, make
     1160      1160                   sure that if this is a zero trip loop, we not not accidently put
     1161      1161                   something out that we should not pull out of the loop.
     1162      1162             */
     1163      1163             ie_chk_valid_invar(lp) loop_p lp; {
     1164      1164    1        invar_t_p inv_exp;
     1165      1165    1        int inv_count, iii;
     1166      1166    1        int inv_off[100];
     1167      1167    1        invar_t_p  inv_ptr[100];
     1168      1168    1        line_p l1;
     1169      1169    1        Lindex ii, next;
     1170      1170    1        bblock_p b, bb;
     1171      1171    1
     1172      1172    1
     1173      1173    1              if (invar_tbl_start == (invar_t_p) 0) return;
     1174      1174    1              inv_count = 0;
     1175      1175    1              for (inv_exp = invar_tbl_start;inv_exp != (invar_t_p) 0; inv_exp = inv_e
                               xp->i_next) {
     1176      1176    2                switch (INSTR(inv_exp->i_line)) {
     1177      1177    3                  case op_zrl:
     1178      1178    3                  case op_zre:
     1179      1179    3                  case op_ste:
     1180      1180    3                  case op_stl:
     1181      1181    3                    inv_ptr[inv_count] = inv_exp;
     1182      1182    3                    inv_off[inv_count++] = inv_exp->i_line->l_a.la_offset;
     1183      1183    3                }
     1184      1184    2              }
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=34 
     1185      1185    1              if (inv_count == 0) return;
     1186      1186    1
     1187      1187    1              /* At this point, we have an id invar expression. Check if it is
     1188      1188    1                 set prior to the current loop. If so, don't do the invar stuff. */
     1189      1189    1
     1190      1190    1              ii = Lfirst(lp->LP_BLOCKS);
     1191      1191    1              b = (bblock_p) Lelem(ii);
     1192      1192    1              /* make sure that we point to code ahead of the loop head block. */
     1193      1193    1              ii = Lfirst(b->b_pred);
     1194      1194    1              bb = (bblock_p) Lelem(ii);
     1195      1195    1              if (bb->b_id < b->b_id) {
     1196      1196    2                 b = bb; }
     1197      1197    1              /* should have correct block at this point.   */
     1198      1198    1              for (ii = Lfirst(b->b_pred); ii != (Lindex) 0; ii = next) {
     1199      1199    2                next =Lnext(ii, b->b_pred);
     1200      1200    2                bb = (bblock_p) Lelem(ii);
     1201      1201    2                for (l1 = bb->b_start; l1 != (line_p) 0; l1 = l1->l_next) {
     1202      1202    3                  switch (INSTR(l1) ) {
     1203      1203    4                    case op_zrl:
     1204      1204    4                    case op_zre:
     1205      1205    4                    case op_ste:
     1206      1206    4                    case op_stl:
     1207      1207    4                      for (iii = 0; iii < inv_count; iii++) {
     1208      1208    5                        if (l1->l_a.la_offset == inv_off[iii]) {
     1209      1209    6                          inv_exp = inv_ptr[iii];
     1210      1210    6                          if (inv_exp->i_prev == (invar_t_p) 0) {
     1211      1211    7                            invar_tbl_start = inv_exp->i_prev; }
     1212      1212    6                          else {
     1213      1213    7                            inv_exp->i_prev->i_next = inv_exp->i_next; }
     1214      1214    6                          if (inv_exp->i_next != (invar_t_p) 0) {
     1215      1215    7                            inv_exp->i_next->i_prev = inv_exp->i_prev;}
     1216      1216    6                        }   /* end of if test on offsets. */
     1217      1217    5                      }   /* end of for loop on iii. */
     1218      1218    4                  }     /* end of switch on l1. */
     1219      1219    3                }     /* end of for loop on l1. */
     1220      1220    2              }      /*  end of for loop on ii. */
     1221      1221    1              return;
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=35 
     1222      1222    1        }     /* end of the function ie_chk_valid_invar. */
     1223      1223
     1224      1224
     1225      1225             /*i*
     1226      1226                   name: ie_chk_inside_if
     1227      1227                   purpose: To see if the preceeding block is an if (look
     1228      1228                   for branch em op codes at the end of the preceeding block).
     1229      1229             */
     1230      1230             ie_chk_inside_if (bblock_p b, line_p l) {
"zbe$ie:c.:ZBC3TSI", line 1230: (warning) function ie_chk_inside_if called before prototype definition
     1231      1231    1        Lindex i,next;
     1232      1232    1        bblock_p bb;
     1233      1233    1        line_p l1,l2;
     1234      1234    1
     1235      1235    1              switch (INSTR(l)) {
     1236      1236    2                case op_ste:
     1237      1237    2                case op_stl:
     1238      1238    2                case op_sdl:
     1239      1239    2                case op_sde:
     1240      1240    2                case op_zre:
     1241      1241    2                case op_zrl:
     1242      1242    2                  break;
     1243      1243    2                default:
     1244      1244    2                  return FALSE;
     1245      1245    2              }
     1246      1246    1
     1247      1247    1              for (i=Lfirst(b->b_pred); i != (Lindex) 0; i = next) {
     1248      1248    2                next = Lnext(i, b->b_pred);
     1249      1249    2                bb = (bblock_p) Lelem(i);
     1250      1250    2                for (l1 = bb->b_start; l1 != (line_p) 0; l1 = l1->l_next) {
     1251      1251    3                  l2 = l1; /* save the last op code looked at. */
     1252      1252    3                }
     1253      1253    2                switch (INSTR(l2)) {
     1254      1254    3                  case op_beq:
     1255      1255    3                  case op_bne:
     1256      1256    3                  case op_blt:
     1257      1257    3                  case op_ble:
CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=36 
     1258      1258    3                  case op_bgt:
     1259      1259    3                  case op_bge:
     1260      1260    3                  case op_zge:
     1261      1261    3                  case op_zgt:
     1262      1262    3                  case op_zne:
     1263      1263    3                  case op_zeq:
     1264      1264    3                  case op_zlt:
     1265      1265    3                  case op_zle:
     1266      1266    3                    return TRUE;
     1267      1267    3                }
     1268      1268    2              }
     1269      1269    1
     1270      1270    1              return FALSE;
     1271      1271    1        }     /* end of the function ie_chk_inside if... */
     1272      1272
---  Include file information  ---

   stdio:h.:LIBRARY. is referenced
   zbe$types:h.:ZBC3TOU. is referenced
   zbe$cset:h.:ZBC3TOU. is referenced
   zbe$debug:h.:ZBC3TOU. is referenced
   zbe$global:h.:ZBC3TOU. is referenced
   zbe$init_glob:h.:ZBC3TOU. is referenced
   zbe$locals:h.:ZBC3TOU. is referenced
   zbe$files:h.:ZBC3TOU. is referenced
   zbe$get:h.:ZBC3TOU. is referenced
   zbe$put:h.:ZBC3TOU. is referenced
   zbe$lset:h.:ZBC3TOU. is referenced
   zbe$map:h.:ZBC3TOU. is referenced
   zbe$alloc:h.:ZBC3TOU. is referenced
   zbe$go:h.:ZBC3TOU. is referenced
   zbe$ie:h.:ZBC3TOU. is referenced
   em_mnem:h.:ZBC3TOU. is referenced
   em_pseu:h.:ZBC3TOU. is referenced
   em_spec:h.:ZBC3TOU. is referenced

CC.C03    File=zbe$ie:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=37 
23 warnings were detected in the file zbe$ie:c.:ZBC3TSI
