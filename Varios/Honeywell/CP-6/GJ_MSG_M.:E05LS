

14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           1    
    1      /*M* GJ_MSG_M   LCP-6 Job Step host message structures   */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100       */
    9
   10
   11
   12
   13
   14                          /*F*   NAME:  GJ_MSG_M.
   15
   16                          The file GJ_MSG_M contains the macro definitions
   17                          that are used to generate the data structures and
   18                          corresponding EQU statements that are used by the
   19                          LCP-6 Job Step modules for communicating with the host.
   20
   21                          Macros contained in this file include the following:
   22                          }
   23                          } GJ_FCN_MSG
   24                          } GJ_SETFP_MSG
   25                          } GJ_PROGKEY_MSG
   26                          } GJ_LDTRC_MSG
   27                          } GJ_ALIB_MSG
   28                          } GJ_ALIB_DATA
   29                          } GJ_FCN#
   30                          }
   31                          */
   32
   33
   34
   35
   36                          /*F* NAME: GJ_FCN_MSG
   37
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           2    
   38                          The GJ_FCN_MSG is used for synchronization.  The
   39                          only contents of this structure are the function
   40                          code and an error code, and some optional flags.
   41
   42                          Note, however, that this structure is the
   43                          header for all other messages defined in
   44                          this file.
   45                          */
   46
   47      %MACRO GJ_FCN_MSG (FPTN=GJ_FCN_MSG,
   48          FCN=0,
   49          STCLASS=STATIC,
   50          LAST(YES=";",NO=",",ANY)=";",
   51          ALGN=WALIGNED);
   52
   53      %LSET LISTDIR='0'B;
   54      %LSET LISTEXP='1'B;
   55      %LSET LISTCOM='0'B;
   56      %LSET LISTSUB='1'B;
   57      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
   58      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
   59      %LSET INIT=CHARTEXT(' INIT');
   60      %LSET EINIT=CHARTEXT('');
   61      %ELSE;
   62      %LSET INIT=CHARTEXT('/*');
   63      %LSET EINIT=CHARTEXT('*/');
   64      %ENDIF;
   65
   66      DCL 1 FPTN STCLASS ALGN,
   67            2 %CHARTEXT('FCN ') UBIN BYTE UNAL %INIT(FCN)%EINIT,
   68                          /*K* FCN = UBIN BYTE.  Contains the messge function code.
   69                          See the GJ_FCN# macro documentation.
   70                          */
   71
   72              %IF NOT(MODE_FEP);
   73            2 * BIT(1) %INIT('0'B)%EINIT,
   74              %ENDIF;
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           3    
   75
   76                          /*K* F1 through F8 - BIT(1).
   77                          Flags F1 through F8 have meaning only for specific
   78                          message types.  See GJ_LDTRC_MSG, for example.
   79                          */
   80            2 F1 BIT(1) UNAL %INIT('0'B)%EINIT,
   81            2 F2 BIT(1) UNAL %INIT('0'B)%EINIT,
   82            2 F3 BIT(1) UNAL %INIT('0'B)%EINIT,
   83            2 F4 BIT(1) UNAL %INIT('0'B)%EINIT,
   84            2 F5 BIT(1) UNAL %INIT('0'B)%EINIT,
   85            2 F6 BIT(1) UNAL %INIT('0'B)%EINIT,
   86            2 F7 BIT(1) UNAL %INIT('0'B)%EINIT,
   87            2 F8 BIT(1) UNAL %INIT('0'B)%EINIT,
   88
   89
   90      %IF NOT(MODE_FEP);
   91            2 ERR BIT(36) UNAL %INIT('0'B)%EINIT LAST
   92            %ELSE;
   93            %VLP_ERRCODE (FPTN=ERR,LVL=2,LAST=LAST,STCLASS=STCLASS);
   94            %ENDIF;
   95                          /*K* ERR = BIT(32).  Contains the error code in LCP-6 format.
   96                          */
   97      %MEND;
   98
   99
  100
  101
  102                          /*F* NAME: GJ_SETFP_MSG
  103
  104                          The GJ_SETFP_MSG macro generates the structure
  105                          for the message sent from the Host to LCP-6 Job
  106                          Step routines that specifies the FEP run-unit that
  107                          is to be down-line loaded for the current user.
  108                          The FCN field in this message will be GJ_SETFP#.
  109
  110                          The BOOT=YES option may be specified to generate a
  111                          structure that is used in the boot process to convey
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           4    
  112                          information about the initial LCP-6 users that are
  113                          included in the boot image.  When this option is
  114                          specified, an additional 4 words will be generated to
  115                          indicate where in the boot image the user program records
  116                          reside.
  117
  118                          This structure consists of the standard header followed by:
  119                          */
  120
  121      /* This message is used by the following modules:
  122             GIB$BIGFOOT
  123             GJS$STEP
  124             KFF$FEBOOT
  125             KIF$FPRG
  126      */
  127      %MACRO GJ_SETFP_MSG (FPTN=GJ_SETFP_MSG,
  128          FCN=0,
  129          ACCT=':SYS    ',
  130          LIB_ACCT=':SYS    ',
  131          BOOT(YES=1,NO=0,ANY)=0,
  132          STCLASS=STATIC);
  133
  134      %LSET LISTDIR='0'B;
  135      %LSET LISTEXP='1'B;
  136      %LSET LISTCOM='0'B;
  137      %LSET LISTSUB='1'B;
  138      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  139      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  140      %LSET INIT=CHARTEXT(' INIT');
  141      %LSET EINIT=CHARTEXT('');
  142      %ELSE;
  143      %LSET INIT=CHARTEXT('/*');
  144      %LSET EINIT=CHARTEXT('*/');
  145      %ENDIF;
  146      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  147              2 NAME,
  148                3 L UBIN BYTE UNAL %INIT(0)%EINIT,
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           5    
  149                3 TEXT CHAR(31) UNAL %INIT(' ')%EINIT,
  150                          /*K* NAME = TEXTC(31).  Contains the file NAME of the run-unit.
  151                          */
  152                2 %CHARTEXT('ACCT ') CHAR(8) UNAL %INIT(ACCT)%EINIT,
  153                          /*K* ACCT = CHAR(8).  Contains the ACCounT from where the
  154                          run-unit was fetched.
  155                          */
  156                2 PASS CHAR(8) UNAL %INIT(' ')%EINIT,
  157                          /*K* PASS = CHAR(8).  Contains the PASSword associated with
  158                          the run-unit.
  159                          */
  160                2 PSN CHAR(6) UNAL %INIT(' ')%EINIT,
  161                          /*K* PSN = CHAR(8).  Contains the Pack Set Name of the
  162                          pack set on which the run-unit resides.
  163                          */
  164            %IF NOT(MODE_FEP);
  165                2 MODTIME(0:3),
  166                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  167                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  168            %ELSE;
  169                2 MODTIME UBIN(32) %INIT(0)%EINIT,
  170            %ENDIF;
  171                          /*K* MODTIME = VALUE-UBIN(32).  Contains the MODification
  172                          TIME of the run-unit to be associated.
  173                          */
  174            %IF NOT(MODE_FEP);
  175                2 START(0:3),
  176                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  177                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  178            %ELSE;
  179                2 P$$ EPTR %INIT(ENTADDR(NIL))%EINIT,
  180            %ENDIF;
  181                          /*K* P$$ - EPTR.  Contains the start address of
  182                          the run-unit.  This field is initialized from
  183                          B$HEAD.START.
  184                          */
  185
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           6    
  186            %IF NOT(MODE_FEP);
  187                2 PRIV(0:3),
  188                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  189                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  190            %ELSE;
  191                2 PRIV BIT(32) %INIT('0'B)%EINIT,
  192             %ENDIF;
  193                          /*K* PRIV = VALUE-UBIN(32).  Contains the processor privileges
  194                          associated with this run-unit by the linker.  This
  195                          field is set from B$HEAD.PRIV only if the run-unit
  196                          resides in the :SYS account.
  197                          */
  198
  199
  200                2 FLAGS,
  201
  202              %IF NOT(MODE_FEP);
  203                3 * BIT(1) %INIT('0'B)%EINIT,
  204              %ENDIF;
  205
  206                3 S BIT(1) UNAL %INIT('0'B)%EINIT,
  207                          /*K* FLAGS.S = BIT(1).  Set if the run unit may
  208                          be shared.  From B$HEAD.S.
  209                          */
  210                3 LIB BIT(1) UNAL %INIT('0'B)%EINIT,
  211                          /*K* FLAGS.LIB = BIT(1).  Set if the run-unit is
  212                          a run-time library.  From B$HEAD.LIB.
  213                          */
  214                3 XEQ_ONLY BIT(1) UNAL %INIT('0'B)%EINIT,
  215                          /*K* FLAGS.XEQ_ONLY = BIT(1).  Set if this is an execute
  216                          only run-unit.  From F$DCB.FFLG.EXEC.
  217                          */
  218                3 CMDPROC BIT(1) UNAL %INIT('0'B)%EINIT,
  219                          /*K* FLAGS.CMDPROC = BIT(1).  Set if the run unit is
  220                          a Command Processor.  From B$HEAD.CMDPROC.
  221                          */
  222                3 DEBUGGER BIT(1) UNAL %INIT('0'B)%EINIT,
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           7    
  223                          /*K* FLAGS.DEBUGGER = BIT(1).  Set if the run unit is
  224                          a Debugger.  From B$HEAD.DEBUGGER.
  225                          */
  226                3 PROCACC BIT(1) UNAL %INIT('0'B)%EINIT,
  227                          /*K* FLAGS.PROCACC = BIT(1).  Set if the processor accounting
  228                          is required for this processor.  This bit is set from
  229                          B$HEAD.PROCACC only if the run-unit resides in the :SYS
  230                          account.
  231                          */
  232                3 NOCHRPMEM BIT(1) UNAL %INIT('0'B)%EINIT,
  233                          /*K* FLAGS.NOCHGPMEM = BIT(1).  Set if the LCP-6 user
  234                          is not to be charged for memory for this processor's
  235                          procedure.  This bit is set from B$HEAD.NOCHGPMEM only
  236                          if the fun-unit resides in the :SYS account.
  237                          */
  238                3 PROCSURCHG BIT(1) UNAL %INIT('0'B)%EINIT,
  239                          /*K* FLAGS.PROCSURCHG = BIT(1).  Set if a processor
  240                          accounting record is to be written to :ACCTLG when
  241                          the run-unit is terminated.  This bit is set from
  242                          B$HEAD.PROCSURCHG only if the run-unit resides in
  243                          the :SYS account.
  244                          */
  245
  246              %IF NOT(MODE_FEP);
  247                3 * BIT(1) %INIT('0'B)%EINIT,
  248              %ENDIF;
  249
  250                3 * BIT(5) UNAL %INIT('0'B)%EINIT,
  251                3 LAUTO BIT(1) UNAL %INIT('0'B)%EINIT,
  252                          /*K* FLAGS.LAUTO = BIT(1).  Set if user auto is in
  253                          a little segment.  From B$HEAD.LAUTO.
  254                          */
  255                3 CCBUF BIT(1) UNAL %INIT('0'B)%EINIT,
  256                          /*K* FLAGS.CCBUF = BIT(1).  Set if the contents of
  257                          JIT.CCBUF are to be read from the Host when this
  258                          program is put into execution.
  259                          */
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           8    
  260                3 DEBUG BIT(1) UNAL %INIT('0'B)%EINIT,
  261
  262
  263
  264                2 PSEUDO_COUNT UBIN BYTE UNAL %INIT(0)%EINIT,
  265                          /*K* PSEUDO_COUNT - UBIN BYTE.  Contains the number of
  266                          of pseudo resources required to execute this run-unit
  267                          From B$HEAD.PSEUDO_COUNT.
  268                          */
  269
  270                2 VERSION UBIN BYTE UNAL %INIT(0)%EINIT,
  271                          /*K* VERSION - UBIN BYTE.  Contains the version of
  272                          the FEPLINK that created this run unit.  From
  273                          B$HEAD.VERSION.
  274                          */
  275
  276                2 PSEUDO_TEXT CHAR(8) UNAL %INIT(' ')%EINIT,
  277                          /*K* PSEUDO_TEXT = CHAR(8).  Contains the text of the
  278                          pseudo resource required to execute this run-unit.
  279                          */
  280
  281
  282            %IF NOT(MODE_FEP);
  283                2 UDCBNUM(0:1),
  284                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  285                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  286            %ELSE;
  287                2 UDCBNUM UBIN(16) %INIT(0)%EINIT,
  288            %ENDIF;
  289                          /*K* UDCBNUM - UBIN(16).  Contains the number of
  290                          user defined DCBs in the Read Only Segment.  From
  291                          B$HEAD.UDCBNUM.
  292                          */
  293
  294            %IF NOT(MODE_FEP);
  295                2 DCBRES(0:1),
  296                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           9    
  297                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  298            %ELSE;
  299                2 DCBRES UBIN(16) %INIT(0)%EINIT,
  300            %ENDIF;
  301                          /*K* DCBRES - UBIN(16).  Contains the number of
  302                          additional DCB pointers defined in the DCBTABLE
  303                          portion of the Read Only Segment.  From B$HEAD.DCBRES.
  304                          */
  305
  306            %IF NOT(MODE_FEP);
  307                2 TCBSIZE(0:1),
  308                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  309                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  310            %ELSE;
  311                2 TCBSIZE UBIN(16) %INIT(0)%EINIT,
  312            %ENDIF;
  313                          /*K* TCBSIZE - UBIN(16).  Contains the number of
  314                          Exceptional Condition frames that are to be allocated
  315                          in the TCB portion of the Read Only Segment.
  316                          From B$HEAD.TCBSIZE.
  317                          */
  318
  319            %IF NOT(MODE_FEP);
  320                2 VPPGS(0:1),
  321                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  322                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  323            %ELSE;
  324                2 VPPGS UBIN(16) %INIT(0)%EINIT,
  325            %ENDIF;
  326                          /*K* VPPGS - UBIN(16).  Contains the number of
  327                          virtual pages (256 L6 words) of procedure.
  328                          From B$HEAD.VPPGS.
  329                          */
  330
  331            %IF NOT(MODE_FEP);
  332                2 VDPGS(0:1),
  333                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           10   
  334                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  335            %ELSE;
  336                2 VDPGS UBIN(16) %INIT(0)%EINIT,
  337            %ENDIF;
  338                          /*K* VDPGS - UBIN(16).  Contains the number of
  339                          virtual pages (256 L6 words) of data.
  340                          From B$HEAD.VDPGS.
  341                          */
  342            %IF NOT(MODE_FEP);
  343                2 ROS_SZ(0:1),
  344                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  345                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  346            %ELSE;
  347                2 ROS_SZ UBIN(16) %INIT(0)%EINIT,
  348            %ENDIF;
  349                          /*K* ROS_SZ - UBIN(16).  Contains the size of the
  350                          run-unit Read Only Segment record in units of L6 WORDS.
  351                          This word is initialized from B$HEAD.ROSIZE.
  352                          */
  353
  354            %IF NOT(MODE_FEP);
  355                2 DATA_SZ(0:3),
  356                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  357                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  358            %ELSE;
  359                2 DATA_SZ UBIN(32) %INIT(0)%EINIT,
  360            %ENDIF;
  361                          /*K* DATA_SZ - UBIN(32).  Contains the size of the
  362                          run-unit program data in units of L6 WORDS.
  363                          This word is initialized from B$HEAD.RDATA.
  364                          */
  365
  366            %IF NOT(MODE_FEP);
  367                2 PROC_SZ(0:3),
  368                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  369                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  370            %ELSE;
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           11   
  371                2 PROC_SZ UBIN(32) %INIT(0)%EINIT,
  372            %ENDIF;
  373                          /*K* PROC_SZ - UBIN(32).  Contains the size of the
  374                          run-unit program procedure in units of L6 WORDS.
  375                          This word is initialized from B$HEAD.RPROC.
  376                          */
  377
  378            %IF NOT(MODE_FEP);
  379                2 DATA_BIAS(0:3),
  380                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  381                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  382            %ELSE;
  383                2 DATA_BIAS UBIN(32) %INIT(0)%EINIT,
  384                2 DATA_BIAS$ REDEF DATA_BIAS PTR,
  385            %ENDIF;
  386                          /*K* DATA_BIAS - UBIN(32).  Contains the address
  387                          within the instruction segment of the beginning of
  388                          the data.  This word is from B$HEAD.BIAS.
  389                          */
  390
  391
  392
  393                2 LIB_NAME,
  394      %IF BOOT=0;
  395                3 L UBIN BYTE UNAL %INIT(0)%EINIT,
  396                3 TEXT CHAR(31) UNAL %INIT(' ')%EINIT;
  397      %ELSE;
  398              3 L UBIN BYTE UNAL %INIT(0)%EINIT,
  399              3 TEXT CHAR(31) UNAL %INIT(' ')%EINIT,
  400                          /*K* LIB_NAME = TEXTC(31).  Contains the name of the LIBrary
  401                          to be associated with this run_unit.
  402                          */
  403
  404            %IF NOT(MODE_FEP);
  405            2 OFFSET_RO(0:3),
  406              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  407              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           12   
  408            %ELSE;
  409            2 OFFSET_RO UBIN(32) %INIT(0)%EINIT,
  410            %ENDIF;
  411                          /*K* OFFSET_RO - UBIN(32).  Contains the offset into
  412                          the boot image for the Read Only data of the LCP-6 Handler.
  413                          */
  414
  415            %IF NOT(MODE_FEP);
  416            2 OFFSET_DATA(0:3),
  417              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  418              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  419            %ELSE;
  420            2 OFFSET_DATA UBIN(32) %INIT(0)%EINIT,
  421            %ENDIF;
  422                          /*K* OFFSET_DATA - UBIN(32).  Contains the offset into
  423                          the boot image for the data of the LCP-6 Handler.
  424                          */
  425
  426            %IF NOT(MODE_FEP);
  427            2 OFFSET_PROC(0:3),
  428              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  429              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  430            %ELSE;
  431            2 OFFSET_PROC UBIN(32) %INIT(0)%EINIT,
  432            %ENDIF;
  433                          /*K* OFFSET_PROC - UBIN(32).  Contains the offset into
  434                          the boot image for the procedure of the LCP-6 Handler.
  435                          */
  436
  437            %IF NOT(MODE_FEP);
  438            2 OFFSET_LIB_DATA(0:3),
  439              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  440              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  441            %ELSE;
  442            2 OFFSET_LIB_DATA UBIN(32) %INIT(0)%EINIT,
  443            %ENDIF;
  444                          /*K* OFFSET_LIB_DATA - UBIN(32).  Contains the offset into
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           13   
  445                          the boot image of the library data for the library
  446                          associated with the handler.
  447                          */
  448
  449            %IF NOT(MODE_FEP);
  450            2 OFFSET_LIB_PROC(0:3),
  451              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  452              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  453            %ELSE;
  454            2 OFFSET_LIB_PROC UBIN(32) %INIT(0)%EINIT,
  455            %ENDIF;
  456                          /*K* OFFSET_LIB_PROC - UBIN(32).  Contains the offset into
  457                          the boot image of the library procedure for the library
  458                          associated with the handler.
  459                          */
  460
  461            %IF NOT(MODE_FEP);
  462            2 LIB_DATA_SZ(0:3),
  463              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  464              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  465            %ELSE;
  466            2 LIB_DATA_SZ UBIN(32) %INIT(0)%EINIT,
  467            %ENDIF;
  468                          /*K* LIB_DATA_SZ - UBIN(32).  Contains the size of the
  469                          the library data in units of L6 words.  This word is
  470                          initialized from B$HEAD.RDATA of the run-unit
  471                          specified in the LIB_NAME field.
  472                          The bias for this procedure is assumed to be '10000'X.
  473                          */
  474
  475            %IF NOT(MODE_FEP);
  476            2 LIB_PROC_SZ(0:3),
  477              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  478              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  479            %ELSE;
  480            2 LIB_PROC_SZ UBIN(32) %INIT(0)%EINIT,
  481            %ENDIF;
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           14   
  482                          /*K* LIB_PROC_SZ - UBIN(32).  Contains the size of the
  483                          the library procedure in units of L6 WORDS.  This word is
  484                          initialized from B$HEAD.RPROC of the run-unit
  485                          specified in the LIB_NAME field.
  486                          The bias for this procedure is assumed to be 'E0000'X.
  487                          */
  488
  489            %IF NOT(MODE_FEP);
  490            2 OFFSET_DS1(0:3),
  491              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  492              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  493            %ELSE;
  494            2 OFFSET_DS1 UBIN(32) %INIT(0)%EINIT,
  495            %ENDIF;
  496                          /*K* OFFSET_DS1 - UBIN(32).  Contains the offset
  497                          into the boot image for this handler's
  498                          initial dynamic data segment 1.
  499                          */
  500
  501            %IF NOT(MODE_FEP);
  502            2 DS1_SZ(0:3),
  503              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  504              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT;
  505            %ELSE;
  506            2 DS1_SZ UBIN(32) %INIT(0)%EINIT;
  507            %ENDIF;
  508                          /*K* DS1_SZ - UBIN(32).  Contains the size of the
  509                          the inital data segment in units of L6 words.
  510                          The bias for this data is assumed to be 'A000'X.
  511                          */
  512
  513      %ENDIF;
  514
  515      %MEND;
  516
  517
  518
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           15   
  519
  520
  521                          /*F* NAME: GJ_PROGKEY_MSG
  522
  523                          The GJ_PROGKEY_MSG macro generates the structure for
  524                          the message that is sent from LCP-6 Job Step to the Host
  525                          that indicates the key of the next record in the
  526                          run-unit that is to be sent to the FEP.
  527                          }
  528                          The FCN field in this message will be one of the following:
  529                          } GJ_GETPROG# - Read from user program run-unit
  530                          } GJ_GETLIB#  - Read from run-time library run-unit
  531                          } GJ_GETDB#   - Read from Debugger run-unit
  532                          } GJ_GETCP#   - Read from Command Processor run-unit
  533                          }
  534
  535                          This structure consists of the standard header followed by:
  536                          */
  537      %MACRO GJ_PROGKEY_MSG (FPTN=GJ_PROGKEY_MSG,
  538          FCN=0,
  539          KEYSIZ=5,
  540          TYPE=10,
  541          STCLASS=STATIC);
  542
  543      %LSET LISTDIR='0'B;
  544      %LSET LISTEXP='1'B;
  545      %LSET LISTCOM='0'B;
  546      %LSET LISTSUB='1'B;
  547      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  548      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  549      %LSET INIT=CHARTEXT(' INIT');
  550      %LSET EINIT=CHARTEXT('');
  551      %ELSE;
  552      %LSET INIT=CHARTEXT('/*');
  553      %LSET EINIT=CHARTEXT('*/');
  554      %ENDIF;
  555
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           16   
  556      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  557              2 RU_KEY,
  558                3 %CHARTEXT('KEYSIZ ') UBIN BYTE UNAL %INIT(KEYSIZ)%EINIT,
  559                          /*K* RU_KEY.KEYSZ = UBIN BYTE.  Contains the size
  560                          of the key.  This is always 5.
  561                          */
  562
  563                3 %CHARTEXT('TYPE ') UBIN BYTE UNAL %INIT(TYPE)%EINIT,
  564                          /*K* RU_KEY.TYPE = UBIN BYTE.  Contains the type
  565                          of record as defined by the B$RECORDSUBS macro in
  566                          file B$OBJECT_C.
  567                          */
  568                %IF NOT(MODE_FEP);
  569                3 PAGE(0:3),
  570                4 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  571                4 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  572              %ELSE;
  573                3 PAGE UBIN(32) UNAL %INIT(0)%EINIT,
  574                3 USRADDR$ REDEF PAGE PTR,
  575              %ENDIF;
  576                          /*K* RU_KEY.USRADDR$ PTR.
  577                          This is the address within
  578                          the user virtual area at which this record is to
  579                          be placed.
  580                          Each record is the page size as specified in the head
  581                          record (the final piece will contain only the residue).
  582                          */
  583            %IF NOT(MODE_FEP);
  584                2 READ_BYSZ(0:3),
  585                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  586                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  587            %ELSE;
  588                2 READ_BYSZ UBIN(32),
  589            %ENDIF;
  590                          /*K* READ_BYSZ = UBIN(32).  Contains the byte size of
  591                          the records that are to be sent from the Host.
  592                          */
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           17   
  593            %IF NOT(MODE_FEP);
  594                2 SECT_BYSZ(0:3),
  595                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  596                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT;
  597            %ELSE;
  598            2 SECT_BYSZ UBIN(32);
  599            %ENDIF;
  600                          /*K* SECT_BYSZ = UBIN(32).  Contains the byte size of
  601                          the program section.
  602                          */
  603
  604      %MEND;
  605
  606
  607
  608
  609
  610                          /*F* NAME: GJ_LDTRC_MSG
  611
  612                          The GJ_LDTRC_MSG macro generates the structure
  613                          for the message sent from LCP-6 to the Host
  614                          that specifies the name of the FEP run-unit
  615                          that is the object of an M$LDTRC request
  616                          from the current user.
  617
  618                          The FCN field in this message will be GJ_LDTRC_FP#.
  619
  620                          The F1 flag bit will be set if the NO_MICROFPL
  621                          option was set on the M$LDTRC service request.
  622
  623                          Upon receiving this message, the Host will send a
  624                          GJ_SETFP_MSG to LCP-6 with the complete run-unit
  625                          information.
  626
  627                          This same macro is used to generate the structure for
  628                          the message that is sent from LCP-6 to the Host that
  629                          specifies the name of the FEP run-unit that is
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           18   
  630                          currently in execution.  This is the message that is
  631                          sent in response to a GJ_GETDB message from the host.
  632                          The only difference in the two messages is that this
  633                          one contains the MODTIME field.  To get MODTIME in the
  634                          structure the GJ_LDTRC_MSG macro must be invoked with
  635                          GEN_MODTIME=YES specified.
  636
  637                          The GJ_LDTRC_MSG structure consists of the
  638                          standard header followed by:
  639                          */
  640
  641      %MACRO GJ_LDTRC_MSG (FPTN=GJ_LDTRC_MSG,
  642          FCN=0,
  643          ACCT=':SYS    ',
  644          GEN_MODTIME(YES=1,NO=0,ANY)=0,
  645          STCLASS=STATIC);
  646
  647      %LSET LISTDIR='0'B;
  648      %LSET LISTEXP='1'B;
  649      %LSET LISTCOM='0'B;
  650      %LSET LISTSUB='1'B;
  651      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  652      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  653      %LSET INIT=CHARTEXT(' INIT');
  654      %LSET EINIT=CHARTEXT('');
  655      %ELSE;
  656      %LSET INIT=CHARTEXT('/*');
  657      %LSET EINIT=CHARTEXT('*/');
  658      %ENDIF;
  659      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  660              2 NAME,
  661                3 L UBIN BYTE UNAL %INIT(0)%EINIT,
  662                3 TEXT CHAR(31) UNAL %INIT(' ')%EINIT,
  663                          /*K* NAME = TEXTC(31).  Contains the file NAME of the run-unit.
  664                          */
  665                2 %CHARTEXT('ACCT ') CHAR(8) UNAL %INIT(ACCT)%EINIT,
  666                          /*K* ACCT = CHAR(8).  Contains the ACCounT from where the
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           19   
  667                          run-unit was fetched.
  668                          */
  669                2 PASS CHAR(8) UNAL %INIT(' ')%EINIT,
  670                          /*K* PASS = CHAR(8).  Contains the PASSword associated with
  671                          the run-unit.
  672                          */
  673                %IF GEN_MODTIME=0;
  674                2 PSN CHAR(6) UNAL %INIT(' ')%EINIT;
  675             %ELSE;
  676            2 PSN CHAR(6) UNAL %INIT(' ')%EINIT,
  677             %IF NOT(MODE_FEP);
  678            2 MODTIME(0:3),
  679              3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  680              3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT;
  681             %ELSE;
  682            2 MODTIME UBIN(32);
  683             %ENDIF;
  684             %ENDIF;
  685                          /*K* MODTIME = VALUE-UBIN(32).  Contains the MODification
  686                          TIME of the currently executing run-unit. This
  687                          field is generated only if GEN_MODTIME=YES is specified.
  688                          */
  689                          /*K* PSN = CHAR(8).  Contains the Pack Set Name of the
  690                          pack set on which the run-unit resides.
  691                          */
  692      %MEND;
  693
  694
  695
  696
  697
  698                          /*F* NAME: GJ_ALIB_MSG
  699
  700                          The GJ_ALIB_MSG macro generates  the structure for
  701                          the message sent from the host to LCP-6 that specifies
  702                          the name of the FEP debugger that is to be associated
  703                          with the current FPRG.
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           20   
  704                          The FCN field of this message will be GJ_GETDB#.
  705
  706
  707                          The GJ_ALIB_MSG structure consists of the standard
  708                          header followed by:
  709                          */
  710
  711      %MACRO GJ_ALIB_MSG (FPTN=GJ_ALIB_MSG,
  712          FCN=0,
  713          STCLASS=STATIC);
  714
  715      %LSET LISTDIR='0'B;
  716      %LSET LISTEXP='1'B;
  717      %LSET LISTCOM='0'B;
  718      %LSET LISTSUB='1'B;
  719      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  720      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  721      %LSET INIT=CHARTEXT(' INIT');
  722      %LSET EINIT=CHARTEXT('');
  723      %ELSE;
  724      %LSET INIT=CHARTEXT('/*');
  725      %LSET EINIT=CHARTEXT('*/');
  726      %ENDIF;
  727      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  728              2 NAME,
  729                3 L UBIN BYTE UNAL %INIT(0)%EINIT,
  730                3 TEXT CHAR(31) UNAL %INIT(' ')%EINIT;
  731                          /*K* NAME = TEXTC(31).  Contains the file NAME of the debugger.
  732                          */
  733      %MEND;
  734
  735
  736
  737
  738
  739                          /*F* NAME:  GJ_ALIB_DATA
  740
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           21   
  741                          The GJ_ALIB_DATA macro generates the structure
  742                          for the message that is sent from the host to
  743                          LCP-6 in response to a GJ_ssp_DATA request that
  744                          specifies the size of the procedure of the
  745                          processor.  The FCN field of this message should
  746                          be that of the request; i.e. GJ_LIB_DATA or
  747                          GJ_DB_DATA.
  748
  749                          The GJ_ALIB_DATA structure consists of the standard
  750                          header followed by:
  751                          */
  752
  753      %MACRO GJ_ALIB_DATA (FPTN=GJ_ALIB_DATA,
  754          FCN=0,
  755          STCLASS=STATIC);
  756
  757      %LSET LISTDIR='0'B;
  758      %LSET LISTEXP='1'B;
  759      %LSET LISTCOM='0'B;
  760      %LSET LISTSUB='1'B;
  761      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  762      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  763      %LSET INIT=CHARTEXT(' INIT');
  764      %LSET EINIT=CHARTEXT('');
  765      %ELSE;
  766      %LSET INIT=CHARTEXT('/*');
  767      %LSET EINIT=CHARTEXT('*/');
  768      %ENDIF;
  769      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  770            %IF NOT(MODE_FEP);
  771              2 PROC_SZ(0:3 ),
  772                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  773                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT,
  774                %ELSE;
  775                2 PROC_SZ UBIN(32) %INIT(0)%EINIT,
  776            %ENDIF;
  777
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           22   
  778                          /*K* PROC_SZ - UBIN(32).  Contains the size of the
  779                          the processor procedure in units of L6 WORDS.  This word is
  780                          initialized from B$HEAD.RPROC of the processor.
  781                          */
  782
  783            %IF NOT(MODE_FEP);
  784                2 DATA_SZ(0:3 ),
  785                3 * BIT(1) UNAL %INIT('0'B*0)%EINIT,
  786                3 BYT UBIN(8) UNAL %INIT(0*0)%EINIT;
  787            %ELSE;
  788            2 DATA_SZ UBIN(32) %INIT(0)%EINIT;
  789            %ENDIF;
  790
  791                          /*K* DATA_SZ - UBIN(32).  Contains the size of the
  792                          the processor procedure in units of L6 words.  This word is
  793                          initialized from B$HEAD.RDATA of the processor.
  794                          */
  795      %MEND;
  796
  797
  798
  799                          /*F* NAME: GJ_PROFILE_MSG
  800
  801                          The GJ_PROFILE_MSG macro generates the structure for
  802                          the message sent from LCP-6 to the host in response
  803                          to a %GJ_PROFILE# request.  The FCN field of this
  804                          message will be the same of the FCN field in the request
  805                          message received from the host, %GJ_PROFILE#.
  806
  807                          The GJ_PROFILE_MSG structure consists of the standard
  808                          header followed by:
  809                          */
  810
  811      %MACRO GJ_PROFILE_MSG (FPTN=GJ_PROFILE_MSG,
  812          FCN=0,
  813          STCLASS=STATIC);
  814
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           23   
  815      %LSET LISTDIR='0'B;
  816      %LSET LISTEXP='1'B;
  817      %LSET LISTCOM='0'B;
  818      %LSET LISTSUB='1'B;
  819      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  820      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  821      %LSET INIT=CHARTEXT(' INIT');
  822      %LSET EINIT=CHARTEXT('');
  823      %ELSE;
  824      %LSET INIT=CHARTEXT('/*');
  825      %LSET EINIT=CHARTEXT('*/');
  826      %ENDIF;
  827      %GJ_FCN_MSG (FPTN=FPTN,STCLASS=STCLASS,LAST=NO,FCN=FCN);
  828              2 PROFILE,
  829                3 L UBIN BYTE UNAL %INIT(0)%EINIT,
  830                3 TEXT CHAR(11) UNAL %INIT(' ')%EINIT;
  831                          /*K* PROFILE = TEXTC(11).  Contains the profile name.
  832                          */
  833      %MEND;
  834
  835
  836
  837                          /*F* NAME: GJ_FCN#
  838
  839                          The GJ_FCN# macro generates the values for the
  840                          FCN field in messages to/from the Host and LCP-6
  841                          Job Step.  This macro generates EQUs for the
  842                          following:
  843                          }
  844                          }  Mnemonic      Decimal   Hex     Octal
  845                          } ____________   ________  ___     _____
  846                          } GJ_SETFP#          0      00      000
  847                          } GJ_GETPROG#        1      01      001
  848                          } GJ_GETLIB#         2      02      002
  849                          } GJ_GETDB#          3      03      003
  850                          } GJ_GETCP#          4      04      004
  851                          } GJ_GETDONE#        5      05      005
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           24   
  852                          } GJ_PROG_EXIT#      6      06      006
  853                          } GJ_PROG_ABRT#      7      07      007
  854                          } GJ_PROG_LDTRC#     8      08      010
  855                          } GJ_LDTRC_FP#       9      09      011
  856                          } GJ_GETCCBUF#      10      0A      012
  857                          } GJ_LIB_DATA#      11      0B      013
  858                          } GJ_DB_DATA#       12      0C      014
  859                          } GJ_CP_DATA#       13      0D      015
  860                          } GJ_GETLIB_DONE#   14      0E      016
  861                          } GJ_GETDB_DONE#    15      0F      017
  862                          } GJ_GETCP_DONE#    16      10      020
  863                          } GJ_WAKEDB#        17      11      021
  864                          } GJ_RUND#          18      12      022
  865                          } GJ_RTNFID#        19      13      023
  866                          } GJ_PROFILE#       20      14      024
  867                          } GJ_MICROFPL#      21      15      025
  868                          }
  869                          } GJ_ACK#           28      1C      142
  870                          } GJ_NAK#           29      1D      035
  871                          }
  872                          */
  873      %MACRO GJ_FCN#;
  874      %EQU GJ_SETFP#=0;
  875      %EQU GJ_GETPROG#=1;
  876      %EQU GJ_GETLIB#=2;
  877      %EQU GJ_GETDB#=3;
  878      %EQU GJ_GETCP#=4;
  879      %EQU GJ_GETDONE#=5;
  880      %EQU GJ_PROG_EXIT#=6;
  881      %EQU GJ_PROG_ABRT#=7;
  882      %EQU GJ_PROG_LDTRC#=8;
  883      %EQU GJ_LDTRC_FP#=9;
  884      %EQU GJ_GETCCBUF#=10;
  885      %EQU GJ_LIB_DATA#=11;
  886      %EQU GJ_DB_DATA#=12;
  887      %EQU GJ_CP_DATA#=13;
  888      %EQU GJ_GETLIB_DONE#=14;
14:35 JUL 28 '97 GJ_MSG_M.:E05SI                                           25   
  889      %EQU GJ_GETDB_DONE#=15;
  890      %EQU GJ_GETCP_DONE#=16;
  891      %EQU GJ_WAKEDB#=17;
  892      %EQU GJ_RUND#=18;
  893      %EQU GJ_RTNFID#=19;
  894      %EQU GJ_PROFILE#=20;
  895      %EQU GJ_MICROFPL#=21;
  896
  897      %EQU GJ_ACK#=28;
  898      %EQU GJ_NAK#=29;
  899      %MEND;

