/*M* LARK_SI603 LARK_CREATE_CMD  Comgroup creation processing */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*T*/
/*X* DDA */
/*F*
   NAME:          LARK_CREATE_CMD
   PURPOSE:       Process the CREATE command
   DESCRIPTION:   This module receives the parse tree for a CREATE command
                  and processes it into data structures used with the M$OPEN.
*/
/*D*
   NAME:          LARK_CREATE_CMD
   CALL:          CALL LARK_CREATE_CMD ( PARSE$OUT )
   PARAMETERS:    PARSE$OUT is an X$PARSE macro which gives access to the
                     output blocks generated by X$PARSE
   INTERFACE:     LARK_GET_DATA_SEGMENT
                  LARK_INTERNAL_ERROR
                  LARK_PROCESS_FID
                  LARK_RELEASE_DATA_SEGMENT
                  LARK_REPORT_CMD_ERROR
                  LARK_REPORT_PMME_ERROR
   INPUT:         PARSE$OUT
   OUTPUT:        LARK$GETCMD_ (information in structure is important for "?")
   SCRATCH:       VLP$ACCT_CG
                  VLP$NAME_CG
                  VLP$PASS_CG
                  VLP$SN_CG
                  VLP$WSN_CG
   DESCRIPTION:   CREATE_CMD syntax =
                     'CRE/ATE' ;
                     CG_FID ;
                     [ CREATE_OPTION_LIST ]
*/
 
%EJECT ;
LARK_CREATE_CMD : PROC ( P_OUT$BLK ) ALTRET ;
 
/*
   Includes
*/
 
%INCLUDE CP_6 ;
%INCLUDE CP_6_SUBS ;
 
%INCLUDE LARK_C61 ;
%INCLUDE LARK_C62 ;
%INCLUDE LARK_C63 ;
 
%INCLUDE XU_MACRO_C ;
%INCLUDE XUG_ENTRY ;
 
/*
   Entries
*/
 
%LARK_GET_DATA_SEGMENT ;
%LARK_INTERNAL_ERROR ;
%LARK_PROCESS_FID ;
%LARK_RELEASE_DATA_SEGMENT ;
%LARK_REPORT_CMD_ERROR ;
%LARK_REPORT_PMME_ERROR ;
 
/*
   Parameters
*/
 
%PARSE$OUT
       ( NAME              = P_OUT$BLK,
         STCLASS           = "" );
 
/*
   Error Messages
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_EXPIRE_VALUE#-3
   MESSAGE0:      0 is an unacceptable expiration value
   MESSAGE1:      Choose a number of days between 1 and ddd
   DESCRIPTION:   User must select a value of 1-ddd.
*/
 
/*E*
   ERROR:         LAR-E$LARK_BAD_IXTNSIZE_VALUE#-3
   MESSAGE0:      0 is an unacceptable granule size
   MESSAGE1:      Choose a number of granules > 0
   DESCRIPTION:   User must select a value of 1-?.
*/
 
/*E*
   ERROR:         LAR-E$LARK_TOO_MANY_ACCESS_ACCT#-3
   MESSAGE0:      Too many account access descriptions have been used
   MESSAGE1:      A LARK limitation has been reached
   MESSAGE2:      No more space exists in present access data segment
   DESCRIPTION:   If this error ever occurs (doubtful), the data segment
                  can be expanded.  Remember that the FIT is of limited
                  size and must contain this information.
*/
 
/*
   Structures
*/
 
%LARK_GLOBALS ;
 
%LARK_PARSEBLKS ;
 
%B$ALT ;
 
%B$TCB ;
 
%FPT_CLOSE
       ( FPTN                 = FPT_CLOSE_CG,
         STCLASS              = CONSTANT,
         DCB                  = M$CG,
         DISP                 = SAVE ) ;
 
%FPT_CLOSE
       ( FPTN                 = FPTCLOSE_CG,
         STCLASS              = AUTO ) ;
 
%FPT_OPEN
       ( FPTN                 = FPT_OPEN_CREATE_CG,
         STCLASS              = CONSTANT,
         ASN                  = COMGROUP,
         AU                   = YES,
         DCB                  = M$CG,
         EXIST                = ERROR,
         FUN                  = CREATE,
         JRNLBYPASS           = YES,
         SCRUB                = YES,
         SHARE                = NONE ) ;
 
%FPT_OPEN
       ( FPTN                 = FPTOPEN_CREATE_CG,
         STCLASS              = AUTO ) ;
 
%VLP_ATTR
       ( FPTN                 = VLP_ATTR_CG,
         STCLASS              = BASED ) ;
 
%VLP_ACCESS
       ( FPTN                 = VLP_ACCESS_GARBAGE,
         STCLASS              = BASED,
         LAST                 = ";" ) ;
 
DCL   1  NULL_ATTR            BASED,
         2  Q,
 
%VLP_ACCESS
       ( FPTN                 = VLP_ACCESS_CG,
         STCLASS              = BASED,
         LAST                 = ";" ) ;
 
%VLP_ATTR
       ( FPTN                 = VLP_ATTR,
         STCLASS              = CONSTANT ) ;
 
 
%VLP_ACCESS
       ( FPTN                 = VLP_ACCESS,
         STCLASS              = CONSTANT,
         LAST                 = ";" ) ;
 
%VLP_VECTOR
       ( FPTN                 = VLP_VECTOR_ACCESS,
         STCLASS              = CONSTANT ) ;
 
%VLP_VECTOR
       ( FPTN                 = VLPVECTOR_ACCESS,
         STCLASS              = AUTO ) ;
 
/*
   Local data
*/
 
%EQU     ACCESS_DSEG_SIZE     = 251 ;
 
DCL      ACCESS$              PTR ;
DCL      ACCESS_COUNT         SBIN ;
DCL      B$TCB$               PTR SYMREF ;
DCL      BLK$                 PTR ;
DCL      I                    SBIN ;
DCL      OPTION_ALTRET        BIT ( 1 ) ;
DCL      SUBLK$               PTR ;
DCL      SYM$                 PTR ;
 
%EJECT ;
IF ( P_OUT$BLK.CODE ~= %CREATE_CMD ) OR
   ( P_OUT$BLK.NSUBLKS < 1 ) OR ( P_OUT$BLK.NSUBLKS > 2 ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT ;
END ;
 
/*
   Processing the CG_FID.
*/
 
BLK$ = P_OUT$BLK.SUBLK$ ( 0 ) ;
 
IF ( BLK$->OUT$SYM.CODE ~= %CG_FID ) THEN DO ;
   CALL LARK_INTERNAL_ERROR ;
   GOTO ALT;
END ;
 
CALL LARK_PROCESS_FID ( VECTOR ( BLK$->OUT$SYM.TEXT ) )
      ALTRET ( ALT ) ;
 
FPTOPEN_CREATE_CG = FPT_OPEN_CREATE_CG ;
FPTOPEN_CREATE_CG.V_ = VECTOR ( FPTOPEN_CREATE_CG.V ) ;
FPTOPEN_CREATE_CG.ACCT_ = VECTOR ( VLP$ACCT_CG ) ;
FPTOPEN_CREATE_CG.NAME_ = VECTOR ( VLP$NAME_CG ) ;
FPTOPEN_CREATE_CG.PASS_ = VECTOR ( VLP$PASS_CG ) ;
FPTOPEN_CREATE_CG.SN_ = VECTOR ( VLP$SN_CG ) ;
FPTOPEN_CREATE_CG.WSN_ = VECTOR ( VLP$WSN_CG ) ;
VLPVECTOR_ACCESS = VLP_VECTOR_ACCESS ;
 
/*
   Processing the CREATE_OPTION_LIST if it was included in the command.
*/
 
IF ( P_OUT$BLK.NSUBLKS = 2 ) THEN DO ;
 
   BLK$ = P_OUT$BLK.SUBLK$ ( 1 ) ;
 
   IF ( BLK$->OUT$BLK.CODE ~= %CREATE_OPTION_LIST ) OR
      ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   /*
      Allocating the data segment for the VLP_ACCESS
   */
 
   CALL LARK_GET_DATA_SEGMENT ( VLPVECTOR_ACCESS,
                               %ACCESS_DSEG_SIZE )
         ALTRET ( ALT ) ;
   FPTOPEN_CREATE_CG.ACCESS_ = VLPVECTOR_ACCESS ;
   VLPVECTOR_ACCESS.PTR$->VLP_ATTR_CG = VLP_ATTR ;
   VLPVECTOR_ACCESS.PTR$->VLP_ATTR_CG.SIZ# = 0 ;
   ACCESS$ = PINCRW ( VLPVECTOR_ACCESS.PTR$, 1 ) ;
   ACCESS_COUNT = 0 ;
 
   OPTION_ALTRET = %FALSE ;
   DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
      SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
      IF ( SUBLK$->OUT$BLK.NSUBLKS < 1 ) OR ( SUBLK$->OUT$BLK.NSUBLKS > 2 ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
         GOTO ALT ;
      END ;
      SYM$ = SUBLK$->OUT$BLK.SUBLK$ ( 0 ) ;
      CALL INSTALL_CREATE_OPT ( SUBLK$->OUT$BLK,
                                SYM$->OUT$SYM,
                                OPTION_ALTRET )
            WHENALTRETURN DO ;
               CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
               GOTO ALT ;
            END ;
   END ;
 
   IF OPTION_ALTRET THEN DO ;
      CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
      GOTO ALT ;
   END ;
 
   VLPVECTOR_ACCESS.PTR$->VLP_ATTR_CG.SIZ# =
         ( ACCESS_COUNT * SIZEC ( VLP_ATTR_CG.Q.VLP_ACCESS_GARBAGE ) + 3 ) / 4 ;
 
END ;
 
/*
   Creating the comgroup.
*/
 
CALL M$OPEN ( FPTOPEN_CREATE_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                      M$CG_DCBNUM ) ;
         CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
         GOTO ALT ;
      END ;
 
FPTCLOSE_CG = FPT_CLOSE_CG ;
FPTCLOSE_CG.V_ = VECTOR ( FPTCLOSE_CG.V ) ;
CALL M$CLOSE ( FPTCLOSE_CG )
      WHENALTRETURN DO ;
         CALL LARK_REPORT_PMME_ERROR ( B$TCB$->B$TCB.ALT$->B$ALT.ERR,
                                      M$CG_DCBNUM ) ;
         CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
         GOTO ALT ;
      END ;
 
CALL LARK_RELEASE_DATA_SEGMENT ( VLPVECTOR_ACCESS ) ;
 
RETURN ;
 
ALT:
   ALTRETURN ;
 
%EJECT ;
/*I*
   NAME:          INSTALL_CREATE_OPT
   PURPOSE:       To install the specified option value in the M$OPEN
                  structures.
   CALL:          CALL INSTALL_CREATE_OPT ( OPTION$BLK,
                                            VALUE$SYM,
                                            LOW_SEV_ALT )
   PARAMETERS:    OPTION$BLK is the block containing the selected option
                  VALUE$SYM is the block containing the value for the selected
                     option
                  LOW_SEV_ALT flags a semantics error and allows option
                     processing to continue
   INPUT:         OPTION$BLK
                  VALUE$SYM
   OUTPUT:        FPTOPEN_CREATE_CG
                  VLP$ACCESS_CREATE_CG
                  LOW_SEV_ALT
   DESCRIPTION:   Retrieves information from the supplied blocks to initialize
                  a given field of the M$OPEN structures to a value specified
                  by the user.  These option specifications are intended to
                  alter the defaults.  ( NOTE that the default value for
                  EXIST has been changed to ERROR so that comgroups are not
                  accidentally destroyed.  Also, SHARE has been changed to
                  NONE. )
*/
 
%EJECT ;
INSTALL_CREATE_OPT : PROC ( OPTION$BLK, VALUE$SYM, LOW_SEV_ALT ) ALTRET ;
 
   %PARSE$SYM
          ( NAME              = VALUE$SYM,
            STCLASS           = PARAM ) ;
 
   %PARSE$OUT
          ( NAME              = OPTION$BLK,
            STCLASS           = PARAM ) ;
 
   DCL      LOW_SEV_ALT       BIT ( 1 ) ;
 
   DCL      TEMP              SBIN ;
 
%EJECT ;
   DO CASE OPTION$BLK.CODE ;
 
      CASE ( %ACCT_ACCESS_OPT ) ;
         CALL PROCESS_ACCT_ACCESS ( OPTION$BLK )
               ALTRET ( ALT ) ;
 
      CASE ( %EXIST_OPT ) ;
         DO CASE VALUE$SYM.CODE ;
            CASE ( %ERROR ) ;
               FPTOPEN_CREATE_CG.V.EXIST# = %ERROR# ;
            CASE ( %NEWFILE ) ;
               FPTOPEN_CREATE_CG.V.EXIST# = %NEWFILE# ;
            CASE ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
 
      CASE ( %EXPIRE_OPT ) ;
         DO CASE VALUE$SYM.CODE ;
            CASE ( %NEVER ) ;
               FPTOPEN_CREATE_CG.V.EXPIRE# = %NEVER# ;
            CASE ( %NUMDAYS ) ;
               CALL CHARBIN ( TEMP,
                              VALUE$SYM.TEXT ) ;
               IF ( TEMP = 0 ) THEN DO ;
                  CALL LARK_REPORT_CMD_ERROR ( %E$LARK_BAD_EXPIRE_VALUE#,
                                              3 ) ;
                  LOW_SEV_ALT = %TRUE ;
               END ; ELSE DO ;
                  FPTOPEN_CREATE_CG.V.EXPIRE# = TEMP ;
               END ;
            CASE ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
 
      CASE ( %IXTNSIZE_OPT ) ;
         CALL CHARBIN ( TEMP,
                        VALUE$SYM.TEXT ) ;
         IF ( TEMP = 0 ) THEN DO ;
            CALL LARK_REPORT_CMD_ERROR ( %E$LARK_BAD_IXTNSIZE_VALUE#,
                                        3 ) ;
            LOW_SEV_ALT = %TRUE ;
         END ; ELSE DO ;
            FPTOPEN_CREATE_CG.V.IXTNSIZE# = TEMP ;
         END ;
 
      CASE ( %JOURNAL_OPT ) ;
         IF ( VALUE$SYM.CODE = %YES ) THEN DO ;
            FPTOPEN_CREATE_CG.V.GHSTACS# = %JRNLOPN# ;
         END ; ELSE DO ;
            FPTOPEN_CREATE_CG.V.GHSTACS# = 0 ;
         END ;
 
      CASE ( %QISS_OPT ) ;
         IF ( VALUE$SYM.CODE = %YES ) THEN DO ;
            FPTOPEN_CREATE_CG.V.QISS# = %YES# ;
         END ; ELSE DO ;
            FPTOPEN_CREATE_CG.V.QISS# = %NO# ;
         END ;
 
      CASE ( ELSE ) ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
 
   END ;
 
   RETURN ;
 
   ALT:
      ALTRETURN ;
 
   END INSTALL_CREATE_OPT ;
 
%EJECT ;
/*I*
   NAME:          PROCESS_ACCT_ACCESS
   PURPOSE:       To process the access information for a given account.
   CALL:          CALL PROCESS_ACCT_ACCESS ( ACCESS$BLK )
   PARAMETERS:    ACCESS$BLK is the block containing the ACCT_ACCESS option
   INPUT:         ACCESS$BLK
   DESCRIPTION:   Uses the information found in the sub-blocks to build a
                  VLP_ACCESS entry in the corresponding data segment.
*/
 
%EJECT ;
PROCESS_ACCT_ACCESS : PROC ( ACCESS$BLK ) ALTRET ;
 
   %PARSE$OUT
          ( NAME              = ACCESS$BLK,
            STCLASS           = PARAM ) ;
 
   DCL      BLK$              PTR ;
   DCL      I                 SBIN ;
   DCL      SUBLK$            PTR ;
   DCL      SYM$              PTR ;
   DCL      TEMP_YES_NO       BIT ( 1 ) ;
 
%EJECT ;
   IF ( ACCESS$BLK.CODE ~= %ACCT_ACCESS_OPT ) OR
      ( ACCESS$BLK.NSUBLKS < 1 ) OR ( ACCESS$BLK.NSUBLKS > 2 ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
 
   ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG = VLP_ATTR.Q.VLP_ACCESS ;
 
   /*
      Putting ACCT in ACCESS structure.
   */
 
   SYM$ = ACCESS$BLK.SUBLK$ ( 0 ) ;
   IF ( SYM$->OUT$BLK.CODE ~= %ACCT_NAME_WILDC ) THEN DO ;
      CALL LARK_INTERNAL_ERROR ;
      GOTO ALT ;
   END ;
   ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.ACCT# = SYM$->OUT$SYM.TEXT ;
 
   /*
      Processing the ACCESS_OPTION_LIST if it was included in the command.
   */
 
   IF ( ACCESS$BLK.NSUBLKS = 2 ) THEN DO ;
 
      BLK$ = ACCESS$BLK.SUBLK$ ( 1 ) ;
 
      IF ( BLK$->OUT$BLK.CODE ~= %ACCESS_OPTION_LIST ) OR
         ( BLK$->OUT$BLK.NSUBLKS < 1 ) THEN DO ;
         CALL LARK_INTERNAL_ERROR ;
         GOTO ALT ;
      END ;
 
      DO I = 0 TO ( BLK$->OUT$BLK.NSUBLKS - 1 ) ;
         SUBLK$ = BLK$->OUT$BLK.SUBLK$ ( I ) ;
         IF ( SUBLK$->OUT$BLK.NSUBLKS ~= 1 ) THEN DO ;
            CALL LARK_INTERNAL_ERROR ;
            GOTO ALT ;
         END ;
         DO SELECT ( SUBLK$->OUT$BLK.SUBLK$( 0 )->OUT$BLK.CODE ) ;
            SELECT ( %YES ) ;
               TEMP_YES_NO = %YES# ;
            SELECT ( %NO ) ;
               TEMP_YES_NO = %NO# ;
            SELECT ( ELSE ) ;
               CALL LARK_INTERNAL_ERROR ;
               GOTO ALT ;
         END ;
         DO CASE ( SUBLK$->OUT$BLK.CODE ) ;
            CASE ( %ACC_AU_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.AU# = TEMP_YES_NO ;
            CASE ( %ACC_AURD_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.AURD# = TEMP_YES_NO ;
            CASE ( %ACC_DELF_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.DELF# = TEMP_YES_NO ;
            CASE ( %ACC_DELR_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.DELR# = TEMP_YES_NO ;
            CASE ( %ACC_EXEC_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.EXEC# = TEMP_YES_NO ;
            CASE ( %ACC_NOLIST_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.NOLIST# = TEMP_YES_NO ;
            CASE ( %ACC_READ_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.READ# = TEMP_YES_NO ;
            CASE ( %ACC_REATTR_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.REATTR# = TEMP_YES_NO ;
            CASE ( %ACC_TCTL_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.TCTL# = TEMP_YES_NO ;
            CASE ( %ACC_UPD_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.UPD# = TEMP_YES_NO ;
            CASE ( %ACC_WNEW_OPT ) ;
               ACCESS$->NULL_ATTR.Q.VLP_ACCESS_CG.FFLG.WNEW# = TEMP_YES_NO ;
         END ;
      END ;
   END ;
 
   ACCESS_COUNT = ACCESS_COUNT + 1 ;
   IF ( ( ( %ACCESS_DSEG_SIZE - 1 ) * 4 / SIZEC ( NULL_ATTR.Q.VLP_ACCESS_CG ) ) >
        ACCESS_COUNT ) THEN DO ;
      ACCESS$ = PINCRC ( ACCESS$,
                         SIZEC ( NULL_ATTR.Q.VLP_ACCESS_CG ) ) ;
   END ; ELSE DO ;
      CALL LARK_REPORT_CMD_ERROR ( %E$LARK_TOO_MANY_ACCESS_ACCT#,
                                  3 ) ;
      GOTO ALT ;
   END ;
 
   RETURN ;
 
   ALT: ;
      ALTRETURN ;
 
   END PROCESS_ACCT_ACCESS ;
 
END LARK_CREATE_CMD ;
