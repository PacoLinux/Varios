

CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=1  
        1         1             /*
        2         2              * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
        3         3              * See the copyright notice in the ACK home directory, in the file "Copyright"
                               .
        4         4              */
        5         5             /* $Header: domacro.c,v 1.6 87/04/07 09:08:28 ceriel Exp $ */
        6         6             /* PREPROCESSOR: CONTROLLINE INTERPRETER */
        7         7
        8         8             #include "interface:h"
        9         9             #include <em_arith:h>
       10        10             #include "LLlex:h"
       11        11             #include "Lpars:h"
       12        12             #include "debug:h"
       13        13             #include "idf:h"
       14        14             #include "input:h"
       15        15
       16        16             #include "ifdepth:h"
       17        17             #include "botch_free:h"
       18        18             #include "nparams:h"
       19        19             #include "parbufsize:h"
       20        20             #include "textsize:h"
       21        21             #include "idfsize:h"
       22        22             #include "ASSERT:h"
       23        23             #include <alloc:h>
       24        24             #include "class:h"
       25        25             #include "macro:h"
       26        26             #include "bits:h"
       27        27
       28        28             int dont_skip_spaces; /* referenced in LLlex:c */
       29        29             extern int zb_skipping;  /* declared in main */
       30        30             int dont_replace_directives = 0;
       31        31             IMPORT char *inctable[]; /* list of include directories      */
       32        32             IMPORT char *getwdir();
       33        33             PRIVATE char ifstack[IFDEPTH]; /* if-stack: the content of an entry is */
       34        34                       /* 1 if a corresponding ELSE has been  */
       35        35                       /* encountered.            */
       36        36                 /* 2 while the if-expr is true. */
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=2  
       37        37             PRIVATE int nestlevel = -1; /* initially no nesting level.    */
       38        38             int tok;
       39        39
       40        40             PRIVATE char *
       41        41             GetIdentifier()
       42        42             {
       43        43    1         /* returns a pointer to the descriptor of the identifier that is
       44        44    1            read from the input stream. A null-pointer is returned if
       45        45    1            the input does not contain an identifier.
       46        46    1            The substitution of macros is disabled.
       47        47    1         */
       48        48    1         struct token tk;
       49        49    1
       50        50    1         ReplaceMacros = 0;
       51        51    1         tok = GetToken(&tk);
       52        52    1         ReplaceMacros = 1;
       53        53    1         return tok == IDENTIFIER ? tk.tk_str : (char *)0;
       54        54    1        }
       55        55
       56        56             /*  domacro() is the control line interpreter. The '#' has already
       57        57              been read by the lexical analyzer by which domacro() is called.
       58        58              The token appearing directly after the '#' is obtained by calling
       59        59              the basic lexical analyzing function GetToken() and is interpreted
       60        60              to perform the action belonging to that token.
       61        61              An error message is produced when the token is not recognized,
       62        62              i.e. it is not one of "define" .. "undef" , integer or newline.
       63        63             */
       64        64             EXPORT
       65        65             domacro()
       66        66             {
       67        67    1         struct token tk;  /* the token itself        */
       68        68    1         register struct idf *id;
       69        69    1
       70        70    1         dont_replace_directives = 1;
       71        71    1         switch(GetToken(&tk)) {    /* select control line action */
       72        72    2         case IDENTIFIER:     /* is it a macro keyword?  */
       73        73    2            id = findidf(tk.tk_str);
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=3  
       74        74    2            if (!id) {
       75        75    3               error("%s: unknown control", tk.tk_str);
       76        76    3               PushBack();
       77        77    3               skipline();
       78        78    3               vfree(tk.tk_str);
       79        79    3               break;
       80        80    3            }
       81        81    2            vfree(tk.tk_str);
       82        82    2            switch (id->id_resmac) {
       83        83    3            case K_DEFINE:          /* "define" */
       84        84    3               do_define();
       85        85    3               break;
       86        86    3            case K_ELIF:            /* "elif"   */
       87        87    3               do_elif();
       88        88    3               break;
       89        89    3            case K_ELSE:            /* "else"   */
       90        90    3               do_else();
       91        91    3               break;
       92        92    3            case K_ENDIF:           /* "endif"  */
       93        93    3               do_endif();
       94        94    3               break;
       95        95    3            case K_IF:           /* "if"     */
       96        96    3               do_if();
       97        97    3               break;
       98        98    3            case K_IFDEF:           /* "ifdef"  */
       99        99    3               do_ifdef(1);
      100       100    3               break;
      101       101    3            case K_IFNDEF:          /* "ifndef" */
      102       102    3               do_ifdef(0);
      103       103    3               break;
      104       104    3            case K_INCLUDE:            /* "include"   */
      105       105    3               do_include();
      106       106    3               break;
      107       107    3            case K_LINE:            /* "line"   */
      108       108    3               /* set LineNumber and FileName according to
      109       109    3                  the arguments.
      110       110    3               */
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=4  
      111       111    3               if ((tok = GetToken(&tk)) != INTEGER) {
      112       112    4                  error("#line without linenumber");
      113       113    4            if (tok != EOI) {
      114       114    5                  PushBack();
      115       115    5                  skipline();
      116       116    5            }
      117       117    4               }
      118       118    3               else
      119       119    3                  do_line((unsigned int)tk.tk_val);
      120       120    3               break;
      121       121    3            case K_UNDEF:           /* "undef"  */
      122       122    3               do_undef();
      123       123    3               break;
      124       124    3          case K_PRAGMA : /* "pragma " */
      125       125    3           do_pragma();
      126       126    3           break;
      127       127    3          case K_ERROR  : /* "error"   */
      128       128    3           do_error();
      129       129    3           break;
      130       130    3            default:
      131       131    3               /* invalid word seen after the '#'  */
      132       132    3               error("%s: unknown control", id->id_text);
      133       133    3               PushBack();
      134       134    3               skipline();
      135       135    3            }
      136       136    2            break;
      137       137    2         case INTEGER:     /* # <integer> [<filespecifier>]?   */
      138       138    2            do_line((unsigned int)tk.tk_val);
      139       139    2            break;
      140       140    2         case EOF:   /* only `#' on this line: do nothing, ignore */
      141       141    2            break;
      142       142    2         default: /* invalid token following '#'      */
      143       143    2            error("illegal # line");
      144       144    2            PushBack();
      145       145    2            skipline();
      146       146    2         }
      147       147    1         dont_replace_directives = 0;
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=5  
      148       148    1        }
      149       149
      150       150             PRIVATE
      151       151             skip_block()
      152       152             {
      153       153    1         /* skip_block() skips the input from
      154       154    1            1) a false #if, #ifdef, #ifndef or #elif until the
      155       155    1               corresponding #elif (resulting in true), #else or
      156       156    1               #endif is read.
      157       157    1            2) a #else or a #elif corresponding to a true #if, #ifdef,
      158       158    1               #ifndef or #elif until the corresponding #endif is
      159       159    1               seen.
      160       160    1         */
      161       161    1        #define Corresponding_Ifexpr_Is_False (!(ifstack[nestlevel] & 2))
      162       162    1         register int ch;
      163       163    1         register int skiplevel = nestlevel; /* current nesting level */
      164       164    1         struct token tk;
      165       165    1         struct idf *id;
      166       166    1         extern char options[];
      167       167    1
      168       168    1         NoUnstack++;
      169       169    1         zb_skipping ++;
      170       170    1         for (;;) {
      171       171    2            LoadChar(ch);  /* read first character after newline  */
      172       172    2          ch = skipspaces(ch);
      173       173    2            if (ch != '#') {
      174       174    3               if (ch == EOI) {
      175       175    4                  NoUnstack--;
      176       176    4            zb_skipping --;
      177       177    4                  return;
      178       178    4               }
      179       179    3               PushBack();
      180       180    3               skipline();
      181       181    3               continue;
      182       182    3            }
      183       183    2          dont_replace_directives = 1;
      184       184    2            if ((tok = GetToken(&tk)) != IDENTIFIER) {
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=6  
      185       185    3           if (tok != EOI) {
      186       186    4               PushBack();
      187       187    4               skipline();
      188       188    4           }
      189       189    3           dont_replace_directives = 0;
      190       190    3               continue;
      191       191    3            }
      192       192    2          dont_replace_directives = 0;
      193       193    2            /* an IDENTIFIER: look for #if, #ifdef and #ifndef
      194       194    2               without interpreting them.
      195       195    2               Interpret #else, #elif and #endif if they occur
      196       196    2               on the same level.
      197       197    2            */
      198       198    2            id = findidf(tk.tk_str);
      199       199    2            vfree(tk.tk_str);
      200       200    2            if (id) switch(id->id_resmac) {
      201       201    3            case K_IF:
      202       202    3            case K_IFDEF:
      203       203    3            case K_IFNDEF:
      204       204    3               push_if();
      205       205    3               continue;
      206       206    3            case K_ELIF:
      207       207    3               if (nestlevel == skiplevel) {
      208       208    4           if (Corresponding_Ifexpr_Is_False) {
      209       209    5                  nestlevel--;
      210       210    5                  push_if();
      211       211    5            NoUnstack--;
      212       212    5                  if (ifexpr()) {
      213       213    6             ifstack[nestlevel] |= 2;
      214       214    6             zb_skipping --;
      215       215    6                     return;
      216       216    6                  }
      217       217    5            else
      218       218    5               NoUnstack++;
      219       219    5           }
      220       220    4           else {
      221       221    5            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=7  
      222       222    6               error("only one identifier and new-line character allowed after \"elif\
                               "");
      223       223    6            }
      224       224    5            if (tok != EOI) {
      225       225    6                PushBack();
      226       226    6                skipline();
      227       227    6            }
      228       228    5           }
      229       229    4               }
      230       230    3               break;
      231       231    3            case K_ELSE:
      232       232    3           ifstack[nestlevel] |= 1;
      233       233    3               if (nestlevel == skiplevel) {
      234       234    4           if (Corresponding_Ifexpr_Is_False) {
      235       235    5            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      236       236    6               error("only one identifier and new-line character allowed after \"else\
                               "");
      237       237    6            }
      238       238    5            if (tok != EOI) {
      239       239    6                  PushBack();
      240       240    6                  skipline();
      241       241    6            }
      242       242    5                  NoUnstack--;
      243       243    5            zb_skipping --;
      244       244    5                  return;
      245       245    5           }
      246       246    4           else {
      247       247    5            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      248       248    6               error("only one identifier and new-line character allowed after \"else\
                               "");
      249       249    6            }
      250       250    5            if (tok != EOI) {
      251       251    6                PushBack();
      252       252    6                skipline();
      253       253    6            }
      254       254    5           }
      255       255    4               }
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=8  
      256       256    3               break;
      257       257    3            case K_ENDIF:
      258       258    3               assert(nestlevel >= 0);
      259       259    3               if (nestlevel == skiplevel) {
      260       260    4            if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      261       261    5               error("only one identifier and new-line character allowed after \"endif
                               \"");
      262       262    5            }
      263       263    4            if (tok != EOI) {
      264       264    5                  PushBack();
      265       265    5                  skipline();
      266       266    5            }
      267       267    4                  nestlevel--;
      268       268    4                  NoUnstack--;
      269       269    4            zb_skipping --;
      270       270    4                  return;
      271       271    4               }
      272       272    3               nestlevel--;
      273       273    3               break;
      274       274    3            }
      275       275    2         }
      276       276    1        }
      277       277
      278       278             PRIVATE
      279       279             ifexpr()
      280       280             {
      281       281    1         /* ifexpr() returns whether the restricted constant
      282       282    1            expression following #if or #elif evaluates to true.  This
      283       283    1            is done by calling the LLgen generated subparser for
      284       284    1            constant expressions.  The result of this expression will
      285       285    1            be given in the extern long variable "ifval".
      286       286    1         */
      287       287    1         IMPORT arith ifval;
      288       288    1         int errors = err_occurred;
      289       289    1
      290       290    1         ifval = (arith)0;
      291       291    1         AccDefined = 1;
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=9  
      292       292    1         UnknownIdIsZero = 1;
      293       293    1         PushLex();  /* NEW parser */
      294       294    1         If_expr();  /* invoke constant expression parser   */
      295       295    1         PopLex();   /* OLD parser */
      296       296    1         AccDefined = 0;
      297       297    1         UnknownIdIsZero = 0;
      298       298    1         return (errors == err_occurred) && (ifval != (arith)0);
      299       299    1        }
      300       300
      301       301             PRIVATE
      302       302             do_include()
      303       303             {
      304       304    1         /* do_include() performs the inclusion of a file.
      305       305    1         */
      306       306    1         char *filenm;
      307       307    1         char *result;
      308       308    1         int tok;
      309       309    1         struct token tk;
      310       310    1         extern char options[];
      311       311    1
      312       312    1         AccFileSpecifier = 1;
      313       313    1         if (((tok = GetToken(&tk)) == FILESPECIFIER) || tok == STRING)
      314       314    1            filenm = tk.tk_str;
      315       315    1         else {
      316       316    2            error("bad include syntax");
      317       317    2            filenm = (char *)0;
      318       318    2         }
      319       319    1         AccFileSpecifier = 0;
      320       320    1         if (tok != EOI) {
      321       321    2         PushBack();
      322       322    2         skipline();
      323       323    2         }
      324       324    1         inctable[0] = WorkingDir;
      325       325    1         if (filenm) {
      326       326    2        /* inctable[0] contains the curent directory, if Unix search option
      327       327    2         * is on and the filename is enclosed by double quotes, then search
      328       328    2         * from the current directory then the search list, otherwise
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=10 
      329       329    2         * search the search list first (i.e. inctable[1])
      330       330    2         */
      331       331    2            if (!InsertFile(filenm, &inctable[ !( tok==STRING && options['X']) ], &res
                               ult)){
      332       332    3               error("cannot find include file \"%s\"", filenm);
      333       333    3            }
      334       334    2            else {
      335       335    3               WorkingDir = getwdir(result);
      336       336    3               FileName = result;
      337       337    3               LineNumber = 1;
      338       338    3            }
      339       339    2         }
      340       340    1        }
      341       341
      342       342             PRIVATE
      343       343             do_define()
      344       344             {
      345       345    1         /* do_define() interprets a #define control line.
      346       346    1         */
      347       347    1         char *str;
      348       348    1         int nformals = -1;   /* keep track of the number of formals */
      349       349    1         char *formals[NPARAMS]; /* pointers to the names of the formals */
      350       350    1         char parbuf[PARBUFSIZE];      /* names of formals  */
      351       351    1         char *repl_text;  /* start of the replacement text */
      352       352    1         int length;    /* length of the replacement text   */
      353       353    1         register ch;
      354       354    1         char *get_text();
      355       355    1
      356       356    1         /* read the #defined macro's name   */
      357       357    1         dont_skip_spaces = 1;
      358       358    1         if (!(str = GetIdentifier())) {
      359       359    2          dont_skip_spaces = 0;
      360       360    2            error("#define: illegal macro name");
      361       361    2          if (tok != EOI) {
      362       362    3            PushBack();
      363       363    3            skipline();
      364       364    3          }
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=11 
      365       365    2            return;
      366       366    2         }
      367       367    1         dont_skip_spaces = 0;
      368       368    1         /* there is a formal parameter list if the identifier is
      369       369    1            followed immediately by a '('.
      370       370    1         */
      371       371    1         LoadChar(ch);
      372       372    1         if (ch == '(') {
      373       373    2            if ((nformals = getparams(formals, parbuf)) == -1) {
      374       374    3               PushBack();
      375       375    3               skipline();
      376       376    3               vfree(str);
      377       377    3               return;  /* an error occurred */
      378       378    3            }
      379       379    2            LoadChar(ch);
      380       380    2         }
      381       381    1         /* read the replacement text if there is any       */
      382       382    1         ch = skipspaces(ch); /* find first character of the text */
      383       383    1         assert(ch != EOI);
      384       384    1         if (class(ch) == STNL) {
      385       385    2            /* Treat `#define something' as `#define something ""'
      386       386    2            */
      387       387    2            repl_text = "";
      388       388    2            length = 0;
      389       389    2         }
      390       390    1         else {
      391       391    2            PushBack();
      392       392    2            repl_text = get_text((nformals > 0) ? formals : 0, &length, str);
      393       393    2         }
      394       394    1         macro_def(str2idf(str, 0), formals, repl_text, nformals, length, NOFLAG);
      395       395    1         LineNumber++;
      396       396    1        }
      397       397
      398       398             PRIVATE
      399       399             push_if()
      400       400             {
      401       401    1         if (nestlevel >= IFDEPTH)
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=12 
      402       402    1            fatal("too many nested #if/#ifdef/#ifndef");
      403       403    1         else
      404       404    1            ifstack[++nestlevel] = 0;
      405       405    1        }
      406       406
      407       407             PRIVATE
      408       408             do_elif()
      409       409             {
      410       410    1         if (nestlevel < 0 || (ifstack[nestlevel] & 1)) {
      411       411    2            error("#elif without corresponding #if");
      412       412    2            PushBack();
      413       413    2            skipline();
      414       414    2         }
      415       415    1         else { /* restart at this level as if a #if is detected.  */
      416       416    2            skip_block();
      417       417    2         }
      418       418    1        }
      419       419
      420       420             PRIVATE
      421       421             do_else()
      422       422             {
      423       423    1         struct token tk;
      424       424    1
      425       425    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      426       426    2            error("only one identifier and new-line character allowed after \"else\"")
                               ;
      427       427    2         }
      428       428    1         if (tok != EOI) {
      429       429    2         PushBack();
      430       430    2         skipline();
      431       431    2         }
      432       432    1         if (nestlevel < 0 || (ifstack[nestlevel] & 1))
      433       433    1            error("#else without corresponding #if");
      434       434    1         else {   /* mark this level as else-d     */
      435       435    2          ifstack[nestlevel] |= 1;
      436       436    2            skip_block();
      437       437    2         }
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=13 
      438       438    1        }
      439       439
      440       440             PRIVATE
      441       441             do_endif()
      442       442             {
      443       443    1         struct token tk;
      444       444    1
      445       445    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      446       446    2            error("only one identifier and new-line character allowed after \"endif\""
                               );
      447       447    2         }
      448       448    1         if (tok != EOI) {
      449       449    2         PushBack();
      450       450    2         skipline();
      451       451    2         ifstack[nestlevel] = 0;
      452       452    2         }
      453       453    1         if (nestlevel-- < 0)
      454       454    1            error("#endif without corresponding #if");
      455       455    1        }
      456       456
      457       457             PRIVATE
      458       458             do_if()
      459       459             {
      460       460    1         push_if();
      461       461    1         if (!ifexpr()) /* a false #if/#elif expression */
      462       462    1            skip_block();
      463       463    1         else
      464       464    1          ifstack[nestlevel] |= 2;
      465       465    1        }
      466       466
      467       467             PRIVATE
      468       468             do_ifdef(how)
      469       469             {
      470       470    1         register struct idf *id;
      471       471    1         char *str;
      472       472    1         struct token tk;
      473       473    1
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=14 
      474       474    1         /* how == 1 : ifdef; how == 0 : ifndef
      475       475    1         */
      476       476    1         push_if();
      477       477    1         str = GetIdentifier();
      478       478    1         if (!str) {
      479       479    2          if (how) {
      480       480    3             error("illegal #ifdef construction");
      481       481    3          }
      482       482    2          else {
      483       483    3             error("illegal #ifndef construction");
      484       484    3          }
      485       485    2            id = 0;
      486       486    2         }
      487       487    1         else  {
      488       488    2            id = findidf(str);
      489       489    2            vfree(str);
      490       490    2         }
      491       491    1         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      492       492    2            if (how) {
      493       493    3              error("only one identifier and new-line character allowed after \"ifdef\
                               "");
      494       494    3            }
      495       495    2            else {
      496       496    3              error("only one identifier and new-line character allowed after \"ifndef
                               \"");
      497       497    3            }
      498       498    2         }
      499       499    1
      500       500    1         /* The next test is a shorthand for:
      501       501    1            (how && !id->id_macro) || (!how && id->id_macro)
      502       502    1         */
      503       503    1         if (how ^ (id && id->id_macro != 0))
      504       504    1            skip_block();
      505       505    1         else {
      506       506    2          ifstack[nestlevel] |= 2;
      507       507    2          if (tok != EOI) {
      508       508    3            PushBack();
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=15 
      509       509    3            skipline();
      510       510    3          }
      511       511    2         }
      512       512    1        }
      513       513             PRIVATE
      514       514             do_pragma()
      515       515             {
      516       516    1          /* The current options include :
      517       517    1             #pragma LIST ON
      518       518    1             #pragma LIST OFF
      519       519    1             #pragma LIST INCLUDE_ON
      520       520    1             #pragma LIST INCLUDE_OFF
      521       521    1             #pragma LIST SPACE
      522       522    1             #pragma LIST SPACE n
      523       523    1             #pragma LIST EJECT
      524       524    1          */
      525       525    1          /* Some recommendations:
      526       526    1             #pragma LIST EJECT, INCLUDE_ON
      527       527    1
      528       528    1             #pragma LIST OFF
      529       529    1             #pragma LIST INCLUDE_ON still get a listing
      530       530    1          */
      531       531    1
      532       532    1         extern int zb_LS_flag;          /* 1 - LIST ON, 0 - LIST OFF */
      533       533    1         extern int zb_LS_include_flag;  /* 1 - LIST INCLUDE_ON, 0 - LIST INCLUDE_OFF
                               */
      534       534    1         extern void zb_listing_eject(); /* LIST should be ON */
      535       535    1         extern void zb_listing_space(); /* n = 1 for LIST SPACE */
      536       536    1         struct idf *id;
      537       537    1         struct token tk;
      538       538    1         char *str = GetIdentifier();
      539       539    1
      540       540    1         if (str && (id = findidf(str))) { /* we are looking for "LIST" */
      541       541    2          if (!strcmp(id->id_text, "LIST")) {
      542       542    3            if (!((str=GetIdentifier()) && (id=findidf(str)))) { /* #pragma LIST */
      543       543    4               zb_LS_flag = 1;
      544       544    4            }
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=16 
      545       545    3            else {
      546       546    4               switch (*(id->id_text)) {
      547       547    5
      548       548    5               case 'O': /* ON or OFF */
      549       549    5
      550       550    5                         if ( !strcmp(id->id_text, "ON")) { /* LIST ON */
      551       551    6                            zb_LS_flag = 1;
      552       552    6                         }
      553       553    5                         else
      554       554    5                         if ( !strcmp(id->id_text, "OFF")){ /* LIST OFF */
      555       555    6                            zb_LS_flag = 0;
      556       556    6                         }
      557       557    5                         break;
      558       558    5
      559       559    5               case 'I': /* INCLUDE_ON or INCLUDE_OFF */
      560       560    5
      561       561    5                         if ( !strcmp(id->id_text, "INCLUDE_ON")) { /* INCLUDE_ON */
      562       562    6                            zb_LS_include_flag = 1;
      563       563    6                         }
      564       564    5                         else
      565       565    5                         if ( !strcmp(id->id_text, "INCLUDE_OFF")){ /* INCLUDE_OFF */
      566       566    6                            zb_LS_include_flag = 0;
      567       567    6                         }
      568       568    5                         break;
      569       569    5
      570       570    5               case 'S': /* SPACE */
      571       571    5
      572       572    5                         if (!strcmp(id->id_text, "SPACE")) {
      573       573    6                            if ((tok = GetToken(&tk) != INTEGER)) {
      574       574    7                               zb_listing_space(1);
      575       575    7                            }
      576       576    6                            else {
      577       577    7                               zb_listing_space(tk.tk_val);
      578       578    7                            }
      579       579    6                         }
      580       580    5                         break;
      581       581    5
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=17 
      582       582    5               case 'E': /* EJECT */
      583       583    5
      584       584    5                         zb_listing_eject();
      585       585    5                         break;
      586       586    5
      587       587    5               default :
      588       588    5                          break;
      589       589    5              } /* switch */
      590       590    4            } /* else */
      591       591    3          } /* "LIST" */
      592       592    2         } /* if */
      593       593    1         if (tok != EOI) {
      594       594    2            PushBack();
      595       595    2            skipline();
      596       596    2         }
      597       597    1
      598       598    1        }/* do_pragma */
      599       599
      600       600
      601       601             PRIVATE
      602       602             do_undef()
      603       603             {
      604       604    1         register struct idf *id;
      605       605    1         register char *str = GetIdentifier();
      606       606    1         struct token tk;
      607       607    1
      608       608    1         /* Forget a macro definition. */
      609       609    1         if (str) {
      610       610    2            if (id = findidf(str)) {
      611       611    3               if (id->id_macro) { /* forget the macro */
      612       612    4                  free_macro(id->id_macro);
      613       613    4                  id->id_macro = (struct macro *) 0;
      614       614    4               } /* else: don't complain */
      615       615    3         if (options['A'] && ((tok = GetToken(&tk)) != EOI)) {
      616       616    4            error("only one identifier and new-line character allowed after \"else\"")
                               ;
      617       617    4         }
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=18 
      618       618    3            }
      619       619    2            vfree(str);
      620       620    2         }
      621       621    1         else
      622       622    1            error("illegal #undef construction");
      623       623    1         if (tok != EOI) {
      624       624    2         PushBack();
      625       625    2         skipline();
      626       626    2         }
      627       627    1        }
      628       628
      629       629             PRIVATE
      630       630             do_line(l)
      631       631              unsigned int l;
      632       632             {
      633       633    1         struct token tk;
      634       634    1
      635       635    1         LineNumber = l - 2;
      636       636    1         AccFileSpecifier = 1;
      637       637    1         if ((tok = GetToken(&tk)) == STRING)   /* is there a filespecifier? */
      638       638    1            FileName = tk.tk_str;
      639       639    1         AccFileSpecifier = 0;
      640       640    1         if (tok != EOI) {
      641       641    2         PushBack();
      642       642    2         skipline();
      643       643    2         }
      644       644    1        }
      645       645
      646       646             do_error()
      647       647             {
      648       648    1        /* do_error interprets a #error control line, this #error
      649       649    1           directive produces a compile-time error message that
      650       650    1           will include the string constant that is an argument
      651       651    1           to #error.
      652       652    1        */
      653       653    1
      654       654    1        int i=0;
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=19 
      655       655    1
      656       656    1        char buffer[2048];
      657       657    1        char c;
      658       658    1
      659       659    1        LoadChar(c);
      660       660    1        while (class(c) != STNL && c!= EOI) {
      661       661    2              buffer[i++] = c;
      662       662    2              LoadChar(c);
      663       663    2        }
      664       664    1        buffer[i] = '\0';
      665       665    1        error("%s\n", buffer);
      666       666    1
      667       667    1        PushBack();
      668       668    1        skipline();
      669       669    1        }
      670       670
      671       671             PRIVATE int
      672       672             getparams(buf, parbuf)
      673       673              char *buf[];
      674       674              char parbuf[];
      675       675             {
      676       676    1         /* getparams() reads the formal parameter list of a macro
      677       677    1            definition.
      678       678    1            The number of parameters is returned.
      679       679    1            As a formal parameter list is expected when calling this
      680       680    1            routine, -1 is returned if an error is detected, for
      681       681    1            example:
      682       682    1               #define one(1), where 1 is not an identifier.
      683       683    1            Note that the '(' has already been eaten.
      684       684    1            The names of the formal parameters are stored into parbuf.
      685       685    1         */
      686       686    1         register char **pbuf = &buf[0];
      687       687    1         register char **epbuf = &buf[NPARAMS];
      688       688    1         register int c;
      689       689    1         register char *ptr = &parbuf[0];
      690       690    1         register char **pbuf2;
      691       691    1
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=20 
      692       692    1         LoadChar(c);
      693       693    1         c = skipspaces(c);
      694       694    1         if (c == ')') {      /* no parameters: #define name() */
      695       695    2            *pbuf = (char *) 0;
      696       696    2            return 0;
      697       697    2         }
      698       698    1         for (;;) {     /* eat the formal parameter list */
      699       699    2            if (class(c) != STIDF) {   /* not an identifier */
      700       700    3               error("#define: bad formal parameter");
      701       701    3               return -1;
      702       702    3            }
      703       703    2            *pbuf = ptr;   /* name of the formal   */
      704       704    2            *ptr++ = c;
      705       705    2            if (ptr >= &parbuf[PARBUFSIZE])
      706       706    2               fatal("formal parameter buffer overflow");
      707       707    2            do {        /* eat the identifier name */
      708       708    3               LoadChar(c);
      709       709    3               *ptr++ = c;
      710       710    3               if (ptr >= &parbuf[PARBUFSIZE])
      711       711    3                  fatal("formal parameter buffer overflow");
      712       712    3            } while (in_idf(c));
      713       713    2            *(ptr - 1) = '\0';   /* mark end of the name    */
      714       714    2
      715       715    2            /* Check if this formal parameter is already used.
      716       716    2               Usually, macros do not have many parameters, so ...
      717       717    2            */
      718       718    2            for (pbuf2 = pbuf - 1; pbuf2 >= &buf[0]; pbuf2--) {
      719       719    3               if (!strcmp(*pbuf2, *pbuf)) {
      720       720    4                  warning("formal parameter \"%s\" already used",
      721       721    4                     *pbuf);
      722       722    4               }
      723       723    3            }
      724       724    2
      725       725    2            pbuf++;
      726       726    2            if (pbuf >= epbuf) {
      727       727    3               error("#define: too many parameters");
      728       728    3               return -1;
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=21 
      729       729    3               }
      730       730    2            c = skipspaces(c);
      731       731    2            if (c == ')') {   /* end of the formal parameter list */
      732       732    3               *pbuf = (char *) 0;
      733       733    3               return pbuf - buf;
      734       734    3            }
      735       735    2            if (c != ',') {
      736       736    3               error("#define: bad formal parameter list");
      737       737    3               return -1;
      738       738    3            }
      739       739    2            LoadChar(c);
      740       740    2            c = skipspaces(c);
      741       741    2         }
      742       742    1         /*NOTREACHED*/
      743       743    1        }
      744       744
      745       745             EXPORT
      746       746             macro_def(id, formals, text, nformals, length, flags)
      747       747              register struct idf *id;
      748       748              char *formals[];
      749       749              char *text;
      750       750             {
      751       751    1         /* macro_def() puts the contents and information of a macro
      752       752    1            definition into a structure and stores it into the symbol
      753       753    1            table entry belonging to the name of the macro.
      754       754    1            A warning is given if the definition overwrites another.
      755       755    1         */
      756       756    1         register struct macro *newdef = id->id_macro;
      757       757    1
      758       758    1         if (id->id_macundef == 0) newdef = 0;
      759       759    1         if (newdef) {     /* is there a redefinition?   */
      760       760    2          if (nformals != newdef->mc_nps) {
      761       761    3             if (nformals == -1) {
      762       762    4                   error("redefine a function-like macro as an object-like macro");
      763       763    4             }
      764       764    3             else
      765       765    3             if (newdef->mc_nps == -1) {
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=22 
      766       766    4                   error("redefine an object-like macro as a function-like macro");
      767       767    4             }
      768       768    3             else {
      769       769    4                   error("redefine a function-like macro with different number of para
                               meters");
      770       770    4             }
      771       771    3             return;
      772       772    3          }
      773       773    2          else
      774       774    2          if (newdef->mc_nps > 0 && formals) {
      775       775    3          /* function-like macros with same name and same num. of params. */
      776       776    3             char **ip = &formals[0];
      777       777    3             char **jp = &(newdef->mc_formals)[0];
      778       778    3
      779       779    3             while (*ip) {
      780       780    4                if (!macroeq(*jp++, *ip++)) {
      781       781    5                   error("different spelling of parameters of function-like macros");
      782       782    5                   return;
      783       783    5                }
      784       784    4             }
      785       785    3          }
      786       786    2            if (macroeq(newdef->mc_text, text))
      787       787    2               return;
      788       788    2            warning("redefine \"%s\"", id->id_text);
      789       789    2         }
      790       790    1         else {
      791       791    2        #ifdef DOBITS
      792       792    2            register char *p = id->id_text;
      793       793    2        #define setbit(bx) if (!*p) goto go_on; bits[*p++] |= (bx)
      794       794    2            setbit(bit0);
      795       795    2            setbit(bit1);
      796       796    2            setbit(bit2);
      797       797    2            setbit(bit3);
      798       798    2            setbit(bit4);
      799       799    2            setbit(bit5);
      800       800    2            setbit(bit6);
      801       801    2            setbit(bit7);
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=23 
      802       802    2
      803       803    2         go_on:
      804       804    2        #endif
      805       805    2            id->id_macro = newdef = new_macro();
      806       806    2            newdef->next = 0;
      807       807    2            newdef->mc_text = 0;
      808       808    2          newdef->mc_name = 0;
      809       809    2          if (nformals > 0 && formals) { /* store formal parameters list */
      810       810    3             char **ip = &formals[0];
      811       811    3             char **jp = &(newdef->mc_formals)[0];
      812       812    3
      813       813    3             while (*ip) {
      814       814    4                *jp = Malloc(1+strlen(*ip));
      815       815    4                strcpy(*jp++, *ip++);
      816       816    4             }
      817       817    3             *jp = 0;
      818       818    3          }
      819       819    2
      820       820    2         }
      821       821    1         newdef->mc_name = id->id_text;  /* macro name */
      822       822    1         newdef->mc_text = text;    /* replacement text  */
      823       823    1         newdef->mc_nps  = nformals;   /* nr of formals  */
      824       824    1         newdef->mc_length = length;   /* length of repl. text */
      825       825    1         newdef->mc_flag = flags;   /* special flags  */
      826       826    1         newdef->mc_count = 0;
      827       827    1        }
      828       828
      829       829             PRIVATE int
      830       830             find_name(nm, index)
      831       831              char *nm, *index[];
      832       832             {
      833       833    1         /* find_name() returns the index of "nm" in the namelist
      834       834    1            "index" if it can be found there.  0 is returned if it is
      835       835    1            not there.
      836       836    1         */
      837       837    1         register char **ip = &index[0];
      838       838    1
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=24 
      839       839    1         while (*ip)
      840       840    1            if (strcmp(nm, *ip++) == 0)
      841       841    1               return ip - &index[0];
      842       842    1         /* arrived here, nm is not in the name list. */
      843       843    1         return 0;
      844       844    1        }
      845       845
      846       846             PRIVATE char *
      847       847             get_text(formals, length, macro_name)
      848       848              char *formals[];
      849       849              int *length;
      850       850              char *macro_name;
      851       851             {
      852       852    1         /* get_text() copies the replacement text of a macro
      853       853    1            definition with zero, one or more parameters, thereby
      854       854    1            substituting each formal parameter by a special character
      855       855    1            (non-ascii: 0200 & (order-number in the formal parameter
      856       856    1            list)) in order to substitute this character later by the
      857       857    1            actual parameter.  The replacement text is copied into
      858       858    1            itself because the copied text will contain fewer or the
      859       859    1            same amount of characters.  The length of the replacement
      860       860    1            text is returned.
      861       861    1
      862       862    1          There are five special markers being used in
      863       863    1          replacement lists when it is necessary:
      864       864    1
      865       865    1          0377 or DBL_POUND:
      866       866    1
      867       867    1          This marker represents double pound operator ##
      868       868    1          which is the catenation operator of macro definition.
      869       869    1
      870       870    1          0376 or SGL_POUND:
      871       871    1
      872       872    1          This marker represents single pound operator #
      873       873    1          which is the stringization operator of macro definition.
      874       874    1
      875       875    1          0375:
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=25 
      876       876    1
      877       877    1          This is the recursion marker.  If an identifier name is
      878       878    1          found in the replacement list and it's the same as the
      879       879    1          macro name being defined, this marker will be inserted
      880       880    1          right before that identifier name to prevent recursive
      881       881    1          replacement.
      882       882    1
      883       883    1          0373:
      884       884    1
      885       885    1          This marker will be inserted between a formal parameter
      886       886    1          and an open parenthesis.  The usage of this marker is
      887       887    1          to prevent expand a macro name which is an actual
      888       888    1          parameter of itself.
      889       889    1
      890       890    1          0372:
      891       891    1
      892       892    1          This is end of replacement list marker.
      893       893    1
      894       894    1            Implementation:
      895       895    1            finite automaton : we are only interested in
      896       896    1            identifiers, because they might be replaced by some actual
      897       897    1            parameter.  Other tokens will not be seen as such.
      898       898    1         */
      899       899    1         register int c;
      900       900    1         register unsigned int text_size;
      901       901    1         char *text = Malloc(text_size = ITEXTSIZE);
      902       902    1         register unsigned int pos = 0;
      903       903    1         register unsigned int string_literal = 0;
      904       904    1         extern char options[];
      905       905    1         register unsigned int formal_param_pushed = 0;
      906       906    1            /* true if top of text is a formal parameter */
      907       907    1         register unsigned int single_pound_pushed = 0;
      908       908    1            /* true if top of text is a '#' operator */
      909       909    1         register int single_pound_position = 0;
      910       910    1         register int dont_fetch_c = 0;
      911       911    1         register int kr = options['K'];
      912       912    1
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=26 
      913       913    1        #define RESET_fpp {if (formal_param_pushed) formal_param_pushed = 0;}
      914       914    1        #define check_spp {\
      915       914    1         if (single_pound_pushed) {\
      916       914    1          single_pound_pushed = 0;\
      917       914    1          if (string_literal) text[single_pound_position] = '#';\
      918       914    1        }}
      919       919    1
      920       920    1         LoadChar(c);
      921       921    1
      922       922    1
      923       923    1        /*
      924       924    1          The following "while" loop scans the define replacement text
      925       925    1          producing the saved replacement text with special marks for
      926       926    1          actions required at expansion time.  The following special
      927       927    1          characters are handled:
      928       928    1
      929       929    1          1) \ followed by a newline character indicates that the
      930       930    1             definition is to extend to the next line.
      931       931    1
      932       932    1          2) if we are within a "string" or a 'string' then no special
      933       933    1             handling of the string contents is performed, we simply
      934       934    1             look for the end of the string.
      935       935    1
      936       936    1          3) if a / is followed by a *, then we skip the comment
      937       937    1             replacing it with a single blank (or nothing if restricted
      938       938    1             K&R mode is required).
      939       939    1
      940       940    1          4) if a # is found, it is expanded into either a stringization
      941       941    1             (single #) or an identifier merge (double ##).
      942       942    1
      943       943    1          5) if a ( is found following a formal parameter name, it is
      944       944    1             marked with a FORMAL_OPEN flag.
      945       945    1
      946       946    1          6) if an identifier is found, it is first determined whether it
      947       947    1             is an identifier or a formal paramter.  Formal parameters are
      948       948    1             marked with their parameter position, otherwise, the name of
      949       949    1             the identifier is copied (preceded by a RECURSIVE marker if
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=27 
      950       950    1             the identifier is the name of the macro being defined).
      951       951    1        */
      952       952    1
      953       953    1          while ( (c != EOI)  &&  (class(c) != STNL) )   {
      954       954    2
      955       955    2            if (string_literal && '\\' != c  && ( !kr || STIDF != class(c))) {
      956       956    3              if (c == string_literal)
      957       957    3                string_literal = 0;
      958       958    3              text[pos++] = c;
      959       959    3            }
      960       960    2            else
      961       961    2            switch (c)  {   /***  actions on '\', '''', '"', '/', '#' and '(' */
      962       962    3
      963       963    3            case '\\':      /** check for continuation of definition **/
      964       964    3              LoadChar(c);
      965       965    3              if ('\n' == c) {
      966       966    4                  text[pos++] = ' ';
      967       967    4                  ++LineNumber;
      968       968    4                  break;
      969       969    4                }
      970       970    3              formal_param_pushed = 0;
      971       971    3              check_spp;
      972       972    3              text[pos++] = '\\';
      973       973    3              dont_fetch_c++;
      974       974    3              if (c && c == string_literal)
      975       975    3                string_literal = 0;  /* will restart literal next! */
      976       976    3              break;
      977       977    3
      978       978    3            case '\'':   /** a quoted int       **/
      979       979    3            case '"':    /** a quoted string    **/
      980       980    3              text[pos++] = c;
      981       981    3              string_literal = c;
      982       982    3              break;
      983       983    3
      984       984    3            case '/':    /** a possible comment **/
      985       985    3              LoadChar(c);
      986       986    3              if ('*' == c) {
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=28 
      987       987    4                skipcomment();
      988       988    4                if (!kr)
      989       989    4                  text[pos++] = ' ';
      990       990    4                break;
      991       991    4              }
      992       992    3              dont_fetch_c++;  /* got next char already! */
      993       993    3              text[pos++] = '/';
      994       994    3              formal_param_pushed = 0;
      995       995    3              check_spp;
      996       996    3              break;
      997       997    3
      998       998    3            case '#':    /** stringization or identifier merge **/
      999       999    3              LoadChar(c);
     1000      1000    3              if (c == '#') {          /* merge into single identifier */
     1001      1001    4                check_spp;
     1002      1002    4                while (pos && ('\n' == text[pos-1] || class(text[pos-1])==STSKIP))
     1003      1003    4                  pos--;
     1004      1004    4                if (!pos) {
     1005      1005    5                  warning("## at start of define text");
     1006      1006    5                  break;
     1007      1007    5                }
     1008      1008    4                text[pos++] = DBL_POUND;                /*merge*/
     1009      1009    4                LoadChar(c);
     1010      1010    4              } /** end of merge ## */
     1011      1011    3
     1012      1012    3              else {                   /*  stringization  */
     1013      1013    4                if (!single_pound_pushed++) {
     1014      1014    5                  single_pound_position = pos;
     1015      1015    5                  text[pos++] = SGL_POUND;           /*stringization*/
     1016      1016    5                }
     1017      1017    4                else warning("formal parameter expected after # in define text");
     1018      1018    4              }  /** end of stringization # */
     1019      1019    3
     1020      1020    3              /* for both stringizing and merging, we skip whitespace */
     1021      1021    3              while ( STSKIP == class(c) || '/' == c) {
     1022      1022    4                if ('/' == c) {
     1023      1023    5                  LoadChar(c);
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=29 
     1024      1024    5                  if ('*' != c) { /** comment-whitespace? **/
     1025      1025    6                    if (pos >= text_size)
     1026      1026    6                      text = Srealloc(text, text_size += ITEXTSIZE*2);
     1027      1027    6                    text[pos++] = '/';
     1028      1028    6                    break;
     1029      1029    6                  }
     1030      1030    5                  else skipcomment();
     1031      1031    5                }
     1032      1032    4                LoadChar(c);
     1033      1033    4              }  /** end of skipping whitespace **/
     1034      1034    3
     1035      1035    3              dont_fetch_c++;
     1036      1036    3              break;
     1037      1037    3
     1038      1038    3            case '(':
     1039      1039    3              if (formal_param_pushed)  {  /* formal param with args */
     1040      1040    4                text[pos++] = FORMAL_OPEN;
     1041      1041    4                if (pos >= text_size)
     1042      1042    4                  text = Srealloc(text, text_size += ITEXTSIZE*2 );
     1043      1043    4              } /** fall through and push the '(' **/
     1044      1044    3
     1045      1045    3        /*    WARNING: fall through into the default case for '('      */
     1046      1046    3
     1047      1047    3            default:  /**  identifiers and other misc chars handled **/
     1048      1048    3
     1049      1049    3              if (STIDF == class(c)) {  /** process an identifier **/
     1050      1050    4                char id_buf[IDFSIZE+4];
     1051      1051    4                register id_size = 0, n;
     1052      1052    4
     1053      1053    4                while (in_idf(c)) {
     1054      1054    5                  if (id_size <= IDFSIZE)
     1055      1055    5                    id_buf[id_size++] = c;
     1056      1056    5                  LoadChar(c);
     1057      1057    5                }
     1058      1058    4                id_buf[id_size] = 0;
     1059      1059    4                dont_fetch_c++;
     1060      1060    4                if (formals && (n = find_name(id_buf, formals))) {
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=30 
     1061      1061    5                  text[pos++] = FORMALP | (char)n;
     1062      1062    5                  formal_param_pushed++;
     1063      1063    5                  single_pound_pushed = 0;
     1064      1064    5                  break;   /* done if it was a formal parameter */
     1065      1065    5                }
     1066      1066    4                if (single_pound_pushed)  /* # should be followed by formal name */
     1067      1067    4                  warning("formal parameter expected after # in define text");
     1068      1068    4                check_spp;
     1069      1069    4                if (0 == strcmp(macro_name, id_buf))
     1070      1070    4                  text[pos++] = RECURSION;
     1071      1071    4
     1072      1072    4                /* Since it isn't a formal parameter, we have to stuff the
     1073      1073    4                   entire name into the output buffer!
     1074      1074    4                */
     1075      1075    4
     1076      1076    4                if (pos + id_size  > text_size)
     1077      1077    4                  text = Srealloc(text,
     1078      1078    4                                  text_size += (IDFSIZE>ITEXTSIZE) ?
     1079      1079    4                                  IDFSIZE*2 : ITEXTSIZE*2 );
     1080      1080    4
     1081      1081    4                memcpy(text+pos, id_buf, id_size);
     1082      1082    4                pos += id_size;
     1083      1083    4              }  /* end of if this starts an identifier */
     1084      1084    3
     1085      1085    3              else {  /** this is not an identifier  **/
     1086      1086    4                text[pos++] = c;
     1087      1087    4                formal_param_pushed = 0;
     1088      1088    4                if (STSKIP != class(c))
     1089      1089    4                  check_spp;                                         /*?*/
     1090      1090    4              }  /** end of "else" not an identifier **/
     1091      1091    3              break;
     1092      1092    3
     1093      1093    3            }    /** end of "switch (c) {" **/
     1094      1094    2
     1095      1095    2            if (pos >= text_size)
     1096      1096    2              text = Srealloc(text, text_size += ITEXTSIZE*2 );
     1097      1097    2
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=31 
     1098      1098    2            if ( !dont_fetch_c )
     1099      1099    2              LoadChar(c);
     1100      1100    2            dont_fetch_c = 0;
     1101      1101    2          }    /** end of: "while ( (c != EOI)  && ...) {"  **/
     1102      1102    1
     1103      1103    1          if (string_literal && STNL == class(c))
     1104      1104    1            error("new line inside string literal");
     1105      1105    1
     1106      1106    1          /* neither double pound (identifier merge) nor single pound
     1107      1107    1             (stringization) are allowed as the last non-blank token
     1108      1108    1             in a replacement list.
     1109      1109    1          */
     1110      1110    1          c = pos;
     1111      1111    1          while (c > 0 && (STSKIP == class(text[c-1]) || '\n' == text[c-1]))
     1112      1112    1            c--;
     1113      1113    1          if (text[c] == SGL_POUND) {
     1114      1114    2            text[c] = ' ';
     1115      1115    2            warning("'#' ignored at end of define text");
     1116      1116    2          }
     1117      1117    1          else if (text[c] == DBL_POUND) {
     1118      1118    2            text[c] = ' ';
     1119      1119    2            warning("'##' ignored at end of define text");
     1120      1120    2          }
     1121      1121    1
     1122      1122    1          if (pos+2 >= text_size)
     1123      1123    1            text = Srealloc(text, text_size += 2);
     1124      1124    1
     1125      1125    1          text[pos++] = EOR;
     1126      1126    1          text[pos] = 0;
     1127      1127    1          *length = pos;
     1128      1128    1          return text;
     1129      1129    1        }
     1130      1130
     1131      1131             #define   BLANK(ch)   ((ch == ' ') || (ch == '\t') || (ch == EOR))
     1132      1132
     1133      1133             /*  macroeq() decides whether two macro replacement texts are
     1134      1134              identical.  This version compares the texts, which occur
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=32 
     1135      1135              as strings, without taking care of the leading and trailing
     1136      1136              blanks (spaces and tabs).
     1137      1137             */
     1138      1138             PRIVATE
     1139      1139             macroeq(s, t)
     1140      1140              register char *s, *t;
     1141      1141             {
     1142      1142    1
     1143      1143    1         /* skip leading spaces  */
     1144      1144    1         while (BLANK(*s)) s++;
     1145      1145    1         while (BLANK(*t)) t++;
     1146      1146    1         /* first non-blank encountered in both strings  */
     1147      1147    1         /* The actual comparison loop:         */
     1148      1148    1         while (*s && *s == *t)
     1149      1149    1            s++, t++;
     1150      1150    1         /* two cases are possible when arrived here: */
     1151      1151    1         if (*s == '\0')   {  /* *s == '\0'     */
     1152      1152    2            while (BLANK(*t)) t++;
     1153      1153    2            return *t == '\0';
     1154      1154    2         }
     1155      1155    1         else  {     /* *s != *t    */
     1156      1156    2            while (BLANK(*s)) s++;
     1157      1157    2            while (BLANK(*t)) t++;
     1158      1158    2            return (*s == '\0') && (*t == '\0');
     1159      1159    2         }
     1160      1160    1        }
     1161      1161
---  Include file information  ---

   zbp$interface:h.:ZBC3TOU. is referenced
   em_arith:h.:ZBC3TOU. is referenced
   zbp$LLlex:h.:ZBC3TOU. is referenced
   zbp$file_info:h.:ZBC3TOU. is referenced
   zbp$Lpars:h.:ZBC3TOU. is referenced
   zbp$debug:h.:ZBC3TOU. is referenced
   zbp$idf:h.:ZBC3TOU. is referenced
   idf_pkg:spec.:ZBC3TOU. is referenced
CC.C03    File=zbp$domacro:c.:ZBC3TSI                                               Fri Aug 22 1997  Page=33 
   zbp$input:h.:ZBC3TOU. is referenced
   zbp$inputtype:h.:ZBC3TOU. is referenced
   inp_pkg:spec.:ZBC3TOU. is referenced
   zbp$ifdepth:h.:ZBC3TOU. is referenced
   zbp$botch_free:h.:ZBC3TOU. is referenced
   zbp$nparams:h.:ZBC3TOU. is referenced
   zbp$parbufsize:h.:ZBC3TOU. is referenced
   zbp$textsize:h.:ZBC3TOU. is referenced
   zbp$idfsize:h.:ZBC3TOU. is referenced
   ASSERT:h.:ZBC3TOU. is referenced
   alloc:h.:ZBC3TOU. is referenced
   zbp$class:h.:ZBC3TOU. is referenced
   charoffset:h.:ZBC3TOU. is referenced
   zbp$macro:h.:ZBC3TOU. is referenced
   zbp$bits:h.:ZBC3TOU. is referenced
   zbp$dobits:h.:ZBC3TOU. is referenced

No diagnostics were issued in the file zbp$domacro:c.:ZBC3TSI
