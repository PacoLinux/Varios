

rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=1  
A        1         1             /*M*    make_evaluate:c      -- evaluates expressions for :if    */
A        2         2             /*T***************************************************************/
A        3         3             /*T*                                                             */
A        4         4             /*T*  Copyright (c) Bull HN Information Systems Inc., 1989       */
A        5         5             /*T*                                                             */
A        6         6             /*T***************************************************************/
A        7         7
A        8         8             #include   <stdio.h>
A        9         9             #include   <setjmp.h>
A       10        10             #include   <stdlib.h>
A       11        11             #include   <xu_cp6_c.h>
A       12        12             #include   <xu_macro_c.h>
A       13        13             #include   <xu_subs_c.h>
A       14        14             #ifndef TEST
A       15        15             #include   "MAKE_Cc14"
A       16        16             #endif
A       17        17
A       18        18
A       19        19             struct value input_integer(char *, int);
A       20        20             struct value evaluate(struct parse_out *);
A       21        21             struct value arith_type(struct value);
A       22        22             struct value idf2int(struct value *);
A       23        23             struct value idf2str(struct value *);
A       24        24
A       25        25
A       26        26             /**
A       27        27              **  The preprocessor variable TEST is used to provide a
A       28        28              **  mechanism to check out the expression analysis.
A       29        29              **  When TEST is defined, this file produces a run-unit
A       30        30              **  that accepts simple expressions with constant or
A       31        31              **  string operands and prints the result.
A       32        32              **/
A       33        33
A       34        34             #ifdef TEST
A       35        35   *S*       extern  int   X$PARSE();
A       36        36   *S*
A       37        37   *S*       int  UserParse();
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=2  
A       38        38   *S*       int  ReportParseLexemes();
A       39        39   *S*
A       40        40   *S*       extern struct p_node EXPRESSION;
A       41        41   *S*       char *ParseWork = 0;
A       42        42   *S*       int   ParseWorkSize = 0;
A       43        43   *S*       jmp_buf ExpandParseRetry;
A       44        44   *S*
A       45        45   *S*       struct p_pcb  CommandPCB =
A       46        46   *S*                   {0, &EXPRESSION, 0, 0, UserParse, 0, 1, 0, 0, 0, 1,
A       47        47   *S*                    0, 0, {0,0,0,0,0}, {0,0,0,0}, 0, 1, 0, 0, 0, 0, 0,
A       48        48   *S*                    ReportParseLexemes};
A       49        49   *S*
A       50        50   *S*
A       51        51   *S*       /*B* NAME:       struct value
A       52        52   *S*            PURPOSE:    To hold a value token.  It may represent the
A       53        53   *S*                     following kinds of values:
A       54        54   *S*                     VAL_CONST               an integer value
A       55        55   *S*                     VAL_IDF                 an identifier
A       56        56   *S*                     VAL_STR                 a  "string"
A       57        57   *S*                     VAL_ERROR               an illegal expression
A       58        58   *S*       */
A       59        59   *S*
A       60        60   *S*       struct  value {
A       61        61   *S*         int   vtype;   /* type of value: VAL_CONST, VAL_STR, VAL_IDF   */
A       62        62   *S*         union {
A       63        63   *S*            int   ival;                /* VAL_CONST   */
A       64        64   *S*            struct   {                 /* VAL_IDF     */
A       65        65   *S*               struct sym_macro *mc;
A       66        66   *S*               struct parse_sym *name;
A       67        67   *S*               } macro;
A       68        68   *S*            struct   {                 /* VAL_STR     */
A       69        69   *S*               int   st_len;
A       70        70   *S*               char *str;
A       71        71   *S*               }  string;
A       72        72   *S*            } val;
A       73        73   *S*         };
A       74        74   *S*
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=3  
A       75        75   *S*       #define VAL_CONST   0
A       76        76   *S*       #define VAL_IDF     1
A       77        77   *S*       #define VAL_STR     2
A       78        78   *S*       #define VAL_ERROR   5
A       79        79   *S*
A       80        80   *S*       #endif
A       81        81
A       82        82             /*
A       83        83             **   The following definitions track the parse node definitions
A       84        84             **   for the specified functions.  The numbers associated indicate
A       85        85             **   the precedence for the function where a lower number indicates
A       86        86             **   a higher precedence.  Note the precedence is truly a function
A       87        87             **   of the code, the actual precedence is the code divided by 8.
A       88        88             **/
A       89        89
A       90        90
A       91        91             #define OP_PARENTHESIS  9
A       92        92
A       93        93             #define OP_CONSTANT    16
A       94        94             #define OP_QUOTED      17
A       95        95             #define OP_STRING      18
A       96        96             #define OP_IDENTIFIER  19
A       97        97
A       98        98             #define OP_NEGATE      24
A       99        99             #define OP_NULL        25
A      100       100             #define OP_NOT         26
A      101       101             #define OP_COMPL       27
A      102       102
A      103       103             #define OP_DEFINED     30
A      104       104             #define OP_SIZEOF      31
A      105       105
A      106       106             #define OP_MULTIPLY    32
A      107       107             #define OP_DIVIDE      33
A      108       108             #define OP_MODULUS     34
A      109       109
A      110       110             #define OP_ADD         40
A      111       111             #define OP_SUBTRACT    41
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=4  
A      112       112
A      113       113             #define OP_LEFT        48
A      114       114             #define OP_RIGHT       49
A      115       115
A      116       116             #define OP_LESS        56
A      117       117             #define OP_GREAT       57
A      118       118             #define OP_LESSEQ      58
A      119       119             #define OP_GREATEQ     59
A      120       120
A      121       121             #define OP_EQUAL       64
A      122       122             #define OP_NOTEQUAL    65
A      123       123
A      124       124             #define OP_AND         72
A      125       125             #define OP_XOR         80
A      126       126             #define OP_OR          88
A      127       127             #define OP_ANDAND      96
A      128       128             #define OP_OROR       104
A      129       129
A      130       130             #define OP_CPAREN     120
A      131       131             #define OP_DONE       128
A      132       132
A      133       133
A      134       134
A      135       135             /*F*    NAME:    get_primary
A      136       136                     PURPOSE: To obtain a value token.
A      137       137                     DESCRIPTION:
A      138       138                        This function takes as input a (struct parse_sym *)
A      139       139                        which represents one of the following:
A      140       140
A      141       141                        OP_CONSTANT:  an integer constant
A      142       142                        OP_QUOTED:    an integer constant input as 'ascii'
A      143       143                        OP_STRING:    a character string input as "string"
A      144       144                        OP_IDENTIFIER: a variable name
A      145       145                        OP_PARENTHESIS: a parenthesized expression
A      146       146
A      147       147                        The output of this function is a (struct value).
A      148       148             */
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=5  
A      149       149
A      150       150             struct  value
A      151       151             get_primary(struct parse_sym *p)
A      152       152             {
A      153       153    1          struct value rs;
A      154       154    1
A      155       155    1          switch   (p->code)   {
A      156       156    2
A      157       157    2          case OP_CONSTANT:
A      158       158    2             rs = input_integer( &(p->text[1]), p->text[0] );
A      159       159    2             break;
A      160       160    2
A      161       161    2          case OP_QUOTED:
A      162       162    2          {
A      163       163    3             unsigned rv = 0;
A      164       164    3             int i, cnt = p->text[0];
A      165       165    3
A      166       166    3             for (i=0; i<cnt ; i++)
A      167       167    3                rv = rv<<9 + p->text[i+1];
A      168       168    3
A      169       169    3             rs.vtype = VAL_CONST;
A      170       170    3             rs.val.ival = rv;
A      171       171    3             break;
A      172       172    3          }
A      173       173    2
A      174       174    2        #ifndef TEST
A      175       175    2
A      176       176    2          case OP_IDENTIFIER:
A      177       177    2          {
A      178       178    3             struct   sym_macro   *mc;
A      179       179    3             mc = lookup_sym_macro( &(p->text[1]), p->text[0], 4);
A      180       180    3             rs.vtype = VAL_IDF;
A      181       181    3             rs.val.macro.mc = mc;
A      182       182    3             rs.val.macro.name = p;
A      183       183    3             break;
A      184       184    3          }
A      185       185    2
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=6  
A      186       186    2        #endif
A      187       187    2
A      188       188    2          case OP_STRING:
A      189       189    2             rs.vtype = VAL_STR;
A      190       190    2             rs.val.string.st_len  = p->text[0];
A      191       191    2             rs.val.string.str     = &p->text[1];
A      192       192    2             break;
A      193       193    2
A      194       194    2          case OP_PARENTHESIS:
A      195       195    2             rs = evaluate( (struct parse_out *) p );
A      196       196    2             break;
A      197       197    2
A      198       198    2          default:
A      199       199    2
A      200       200    2        #ifndef TEST
A      201       201    2             error("\"%s\" line %d: unknown primary token (%d) in :if expresion\n",
A      202       202    2                file_table[InputNo].fid, file_table[InputNo].recno, p->code          )
A                               ;
A      203       203    2        #else
A      204       204   *S*            printf("** Error: unknown primary token (%d) in parse nodes\n", p->code )
A                               ;
A      205       205   *S*       #endif
A      206       206    2             rs.vtype = VAL_ERROR;
A      207       207    2             break;
A      208       208    2             }
A      209       209    1          return rs;
A      210       210    1        }
A      211       211
A      212       212             /*F*    NAME:       get_unary
A      213       213                     PURPOSE:    To return a value token from a unary item.
A      214       214                     DESCRIPTION:
A      215       215                        A unary includes all of the value tokens handled by
A      216       216                        get_primary in addition to the following monadic
A      217       217                        functions:
A      218       218
A      219       219                        OP_NEGATE:     negation as in -3.
A      220       220                        OP_NULL:       nothing as in +3.
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=7  
A      221       221                        OP_NOT:        not as in !3
A      222       222                        OP_COMPL:      two's complement.
A      223       223                        OP_DEFINED:    1 if argument is a variable, else 0
A      224       224                        OP_SIZEOF:     integer length of string or variable value
A      225       225
A      226       226             */
A      227       227
A      228       228             struct value
A      229       229             get_unary(struct parse_out *po, int *pi)
A      230       230             {
A      231       231    1          struct parse_sym *p = (struct parse_sym *) po->sublk[ (*pi)++ ];
A      232       232    1          struct value rs;
A      233       233    1
A      234       234    1          switch (p->code)  {
A      235       235    2
A      236       236    2          case  OP_CONSTANT:
A      237       237    2          case  OP_QUOTED:
A      238       238    2          case  OP_STRING:
A      239       239    2          case  OP_IDENTIFIER:
A      240       240    2          case  OP_PARENTHESIS:
A      241       241    2             rs = get_primary( p );
A      242       242    2             break;
A      243       243    2
A      244       244    2          case  OP_NEGATE:
A      245       245    2             rs = get_unary( po, pi );
A      246       246    2             rs = arith_type( rs );
A      247       247    2             if (rs.vtype == VAL_CONST)   rs.val.ival = 0 - rs.val.ival;
A      248       248    2             break;
A      249       249    2
A      250       250    2          case OP_NULL:
A      251       251    2             rs = get_unary( po, pi );
A      252       252    2             break;
A      253       253    2
A      254       254    2          case OP_NOT:
A      255       255    2             rs = get_unary( po, pi );
A      256       256    2             rs = arith_type( rs );
A      257       257    2             if (rs.vtype == VAL_CONST) rs.val.ival = !rs.val.ival;
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=8  
A      258       258    2             break;
A      259       259    2
A      260       260    2          case OP_COMPL:
A      261       261    2             rs = get_unary( po, pi );
A      262       262    2             rs = arith_type(rs);
A      263       263    2             if (rs.vtype == VAL_CONST) rs.val.ival = ~rs.val.ival;
A      264       264    2             break;
A      265       265    2
A      266       266    2        #ifndef TEST
A      267       267    2
A      268       268    2          case OP_DEFINED:
A      269       269    2             {
A      270       270    3             struct parse_sym *q = (struct parse_sym*)((struct parse_out *) p)->sublk[
A                               0];
A      271       271    3             rs.vtype = VAL_CONST;
A      272       272    3             rs.val.ival = (lookup_sym_macro(&(q->text[1]),q->text[0],4)) ?1:0;
A      273       273    3             }
A      274       274    2             break;
A      275       275    2
A      276       276    2          case OP_SIZEOF:
A      277       277    2             {
A      278       278    3             struct   sym_macro   *mc;
A      279       279    3             struct parse_sym *q = (struct parse_sym*)((struct parse_out *) p)->sublk[
A                               0];
A      280       280    3             rs.vtype = VAL_CONST;
A      281       281    3             switch (q->code)  {
A      282       282    4                case OP_IDENTIFIER:
A      283       283    4                   mc = lookup_sym_macro( &(q->text[1]), q->text[0], 4);
A      284       284    4                   rs.val.ival = (mc) ? mc->mc_deflen : 0;
A      285       285    4                   break;
A      286       286    4                case OP_STRING:
A      287       287    4                   rs.val.ival = q->text[0];
A      288       288    4                   break;
A      289       289    4                default:
A      290       290    4                   error("\"%s\" line %d: Illegal operand (%d) to sizeof function\n",
A      291       291    4                      file_table[InputNo].fid,  file_table[InputNo].recno, q->code   )
A                               ;
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=9  
A      292       292    4                   rs.vtype = VAL_ERROR;
A      293       293    4                   break;
A      294       294    4                }  /* End of switch (q->code)... */
A      295       295    3             }     /* End of case OP_SIZEOF      */
A      296       296    2             break;
A      297       297    2
A      298       298    2        #endif
A      299       299    2
A      300       300    2          default:
A      301       301    2
A      302       302    2        #ifndef TEST
A      303       303    2             error("\"%s\" line %d: unknown unary token (%d) in :if expression\n",
A      304       304    2                    file_table[InputNo].fid,  file_table[InputNo].recno, p->code   );
A      305       305    2        #else
A      306       306   *S*            printf("** Error: unknown unary token (%d) in parse nodes\n", p->code );
A      307       307   *S*       #endif
A      308       308    2
A      309       309    2             rs.vtype = VAL_ERROR;
A      310       310    2             break;
A      311       311    2          }
A      312       312    1          return rs;
A      313       313    1        }
A      314       314
A      315       315
A      316       316             /*F*    NAME:          arith_type
A      317       317                     PURPOSE:       To guarantee that the argument value is
A      318       318                                    suitable for arithmetic.
A      319       319                     DESCRIPTION:
A      320       320                        An error token is created if it is not.
A      321       321             */
A      322       322
A      323       323             struct value
A      324       324             arith_type(struct value val)
A      325       325             {
A      326       326    1          switch  (val.vtype)  {
A      327       327    2
A      328       328    2          case VAL_ERROR:
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=10 
A      329       329    2          case VAL_CONST:
A      330       330    2             break;
A      331       331    2
A      332       332    2          case  VAL_STR:
A      333       333    2
A      334       334    2        #ifndef TEST
A      335       335    2             error("\"%s\" line %d: string cannot be used with arithmetic function\n",
A
A      336       336    2                 file_table[InputNo].fid,  file_table[InputNo].recno
A                               );
A      337       337    2        #else
A      338       338   *S*            printf("** Error: string cannot be used with arithmetic function\n");
A      339       339   *S*       #endif
A      340       340    2             val.vtype = VAL_ERROR;
A      341       341    2             break;
A      342       342    2
A      343       343    2        #ifndef TEST
A      344       344    2          case  VAL_IDF:
A      345       345    2             val = idf2int( &val );
A      346       346    2             break;
A      347       347    2        #endif
A      348       348    2
A      349       349    2          }
A      350       350    1          return val;
A      351       351    1        }
A      352       352
A      353       353             /*F*    NAME:          input_integer
A      354       354                     PURPOSE:       To return an integer value from a character
A      355       355                                    string.
A      356       356                     DESCRIPTION:
A      357       357                        Check for the obvious overflow and illegal characters.
A      358       358             */
A      359       359
A      360       360             struct value
A      361       361             input_integer( char *str, int stlen )
A      362       362             {
A      363       363    1          struct value rval;
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=11 
A      364       364    1          unsigned rs = 0, oldrs = 0;
A      365       365    1          int      i, ovfl = 0, badc = 0;
A      366       366    1
A      367       367    1          for (i=0 ; i<stlen ; )  {
A      368       368    2             char c = *str++;
A      369       369    2             if (c < '0' || c > '9') badc++;
A      370       370    2             rs = rs * 10 + c - '0';
A      371       371    2             i++;
A      372       372    2             if (oldrs && rs <= oldrs) ovfl++;
A      373       373    2             oldrs = rs;
A      374       374    2             }
A      375       375    1
A      376       376    1          if (badc)
A      377       377    1        #ifndef TEST
A      378       378    1             error("\"%s\" line %d: variable contains illegal digits\n",
A      379       379    1                    file_table[InputNo].fid,  file_table[InputNo].recno  );
A      380       380    1        #else
A      381       381   *S*            printf("** Error: variable contains illegal digits\n");
A      382       382   *S*       #endif
A      383       383    1          else if (ovfl)
A      384       384    1        #ifndef TEST
A      385       385    1             error("\"%s\" line %d: integer constant too big\n",
A      386       386    1                    file_table[InputNo].fid,  file_table[InputNo].recno);
A      387       387    1        #else
A      388       388   *S*            printf("** Error: integer constant too big\n");
A      389       389   *S*       #endif
A      390       390    1          rval.vtype = (ovfl + badc) ? VAL_ERROR : VAL_CONST;
A      391       391    1          rval.val.ival = rs;
A      392       392    1          return rval;
A      393       393    1        }
A      394       394
A      395       395
A      396       396
A      397       397             #ifndef TEST
A      398       398
A      399       399             /*F*    NAME:          idf2str
A      400       400                     PURPOSE:       To return a character string value from the
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=12 
A      401       401                                    value associated with a variable.
A      402       402                     DESCRIPTION:   An error is reported if the variable is
A      403       403                              undefined.
A      404       404             */
A      405       405
A      406       406             struct value
A      407       407             idf2str(struct value *v)
A      408       408             {
A      409       409    1          struct value rs;
A      410       410    1          struct sym_macro *mc = v->val.macro.mc;
A      411       411    1          if (mc)  {
A      412       412    2             rs.vtype = VAL_STR;
A      413       413    2             rs.val.string.st_len = mc->mc_deflen;
A      414       414    2             rs.val.string.str    = mc->mc_def;
A      415       415    2             }
A      416       416    1          else {
A      417       417    2             error("\"%s\" line %d: variable \"%s\" is undefined in relational expr\n"
A                               ,
A      418       418    2                    file_table[InputNo].fid,  file_table[InputNo].recno,
A      419       419    2                    &v->val.macro.name->text[1]                           );
A      420       420    2             rs.vtype = VAL_ERROR;
A      421       421    2             }
A      422       422    1          return rs;
A      423       423    1        }
A      424       424
A      425       425
A      426       426
A      427       427
A      428       428             /*F*    NAME:          idf2int
A      429       429                     PURPOSE:       To return an integer constant value from the
A      430       430                                    value of a variable.
A      431       431                     DESCRIPTION:
A      432       432                           Report an error if the variable is undefined.
A      433       433             */
A      434       434
A      435       435             struct value
A      436       436             idf2int(struct value *v)
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=13 
A      437       437             {
A      438       438    1          struct value rs;
A      439       439    1          struct sym_macro *mc = v->val.macro.mc;
A      440       440    1          if (!mc)  {
A      441       441    2             error("\"%s\" line %d: variable \"%s\" is undefined in arithmetic expr\n"
A                               ,
A      442       442    2                    file_table[InputNo].fid,  file_table[InputNo].recno,
A      443       443    2                    &v->val.macro.name->text[1]                          );
A      444       444    2             rs.vtype = VAL_ERROR;
A      445       445    2             }
A      446       446    1          else rs = input_integer( mc->mc_def, mc->mc_deflen );
A      447       447    1          return rs;
A      448       448    1        }
A      449       449
A      450       450             #endif
A      451       451
A      452       452
A      453       453
A      454       454             /*F*    NAME:          same_type
A      455       455                     PURPOSE:       To coerse the two value arguments to be
A      456       456                                    suitable for comparison.
A      457       457                     DESCRIPTION:
A      458       458                        Both arguments must be representable as integers or
A      459       459                        strings.  The actual direction is dependent upon which
A      460       460                        (if either) is a variable.  If neither are variables it's
A      461       461                        easy!
A      462       462             */
A      463       463
A      464       464             void
A      465       465             same_type(struct value *v1, struct value *v2)
A      466       466             {
A      467       467    1          int vt1 = v1->vtype, vt2 = v2->vtype;
A      468       468    1
A      469       469    1          if (vt1 == vt2)   {
A      470       470    2        #ifndef TEST
A      471       471    2             if (vt1 == VAL_IDF)  {
A      472       472    3                *v1 = idf2str(v1);
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=14 
A      473       473    3                *v2 = idf2str(v2);
A      474       474    3                }
A      475       475    2        #endif
A      476       476    2             }
A      477       477    1          else if (vt1 == VAL_ERROR || vt2 == VAL_ERROR)
A      478       478    1             v1->vtype = VAL_ERROR;
A      479       479    1        #ifndef TEST
A      480       480    1          else if (vt1 == VAL_IDF)   {
A      481       481    2             if (vt2 == VAL_CONST)
A      482       482    2                *v1 = idf2int( v1 );
A      483       483    2             else *v1 = idf2str(v1);
A      484       484    2             }
A      485       485    1          else if (vt2 == VAL_IDF)   {
A      486       486    2             if (vt1 == VAL_CONST)
A      487       487    2                *v2 = idf2int( v2 );
A      488       488    2             else *v2 = idf2str( v2 );
A      489       489    2             }
A      490       490    1        #endif
A      491       491    1          else  {
A      492       492    2        #ifndef TEST
A      493       493    2             error("\"%s\" line %d: operands of function must have same type\n",
A      494       494    2                   file_table[InputNo].fid,  file_table[InputNo].recno          );
A      495       495    2        #else
A      496       496   *S*            printf("** Error: operands of function must have same type\n");
A      497       497   *S*       #endif
A      498       498    2             v1->vtype = VAL_ERROR;
A      499       499    2             }
A      500       500    1          return;
A      501       501    1        }
A      502       502
A      503       503
A      504       504
A      505       505
A      506       506
A      507       507             /*F*       NAME:             compare_values
A      508       508                        PURPOSE:          To compare the two argument value tokens.
A      509       509                        DESCRIPTION:
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=15 
A      510       510                              The result of this function is -1, 0 or 1 depending
A      511       511                              upon whether A<B, A==B or A>B.
A      512       512             */
A      513       513
A      514       514             int
A      515       515             compare_values( struct value v1, struct value v2)
A      516       516             {
A      517       517    1          int   rs;
A      518       518    1        /*   Assumes that the types are the same!   */
A      519       519    1          if (v1.vtype == VAL_CONST) {
A      520       520    2             int   vv1 = v1.val.ival, vv2 = v2.val.ival;
A      521       521    2             if (vv1 < vv2)
A      522       522    2                rs = -1;
A      523       523    2             else if (vv1 == vv2)
A      524       524    2                rs = 0;
A      525       525    2             else rs = 1;
A      526       526    2             }
A      527       527    1          else  {     /*    Comparing strings... */
A      528       528    2             int   ss1 = v1.val.string.st_len, ss2 = v2.val.string.st_len;
A      529       529    2             char  *s1 = v1.val.string.str,    *s2 = v2.val.string.str;
A      530       530    2             int   clen = (ss1 > ss2) ? ss2 : ss1;
A      531       531    2
A      532       532    2             rs = memcmp(s1, s2, clen);
A      533       533    2             if (rs == 0 && ss1 != ss2)
A      534       534    2                rs = (ss1 > ss2) ? 1 : -1;
A      535       535    2             }
A      536       536    1          return rs;
A      537       537    1        }
A      538       538
A      539       539
A      540       540
A      541       541
A      542       542
A      543       543             /*F*    NAME:          eval_logl
A      544       544                     PURPOSE:       To return a truth value for a value token.
A      545       545                     DESCRIPTION:
A      546       546                        It all ends here!  The value returned by this function
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=16 
A      547       547                        is true or false depending upon:
A      548       548
A      549       549                        1.    If the value is an integer then the result is 0
A      550       550                           if the value is 0, otherwise 1.
A      551       551
A      552       552                        2.    If the value is a string, the result is 1, else 0.
A      553       553
A      554       554                        3.    If the value is an identifier, the result is 1 if
A      555       555                           the variable is defined, else 0.
A      556       556
A      557       557                        4.    If the value is an error, the result is 0.
A      558       558             */
A      559       559
A      560       560             unsigned
A      561       561             eval_logl(struct value v)
A      562       562             {
A      563       563    1          unsigned rs = 0;
A      564       564    1          if (v.vtype == VAL_CONST)
A      565       565    1             rs = v.val.ival != 0;
A      566       566    1          else if (v.vtype == VAL_IDF)
A      567       567    1             rs = v.val.macro.mc != 0;
A      568       568    1          else if (v.vtype == VAL_STR)
A      569       569    1             rs = 1;
A      570       570    1          return rs;
A      571       571    1        }
A      572       572
A      573       573
A      574       574
A      575       575             /*F*    NAME:          eval_fun
A      576       576                     PURPOSE:       To evaluate the argument function using the
A      577       577                                 two value token arguments.
A      578       578                     DESCRIPTION:
A      579       579                           The result is a new value token.
A      580       580             */
A      581       581
A      582       582             struct value
A      583       583             eval_fun( int f, struct value v1, struct value v2)
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=17 
A      584       584             {
A      585       585    1        /*   First coerse arguments to correct types      */
A      586       586    1          if (f <= OP_RIGHT || f >= OP_AND && f <= OP_OR) {
A      587       587    2             v1 = arith_type(v1);
A      588       588    2             v2 = arith_type(v2);
A      589       589    2             }
A      590       590    1          else if (f >= OP_LESS && f <= OP_NOTEQUAL)
A      591       591    1             same_type(&v1, &v2);
A      592       592    1
A      593       593    1          if (v1.vtype != VAL_ERROR)
A      594       594    1          switch (f)  {
A      595       595    2
A      596       596    2          case  OP_MULTIPLY:
A      597       597    2             v1.val.ival *= v2.val.ival;                     break;
A      598       598    2          case  OP_DIVIDE:
A      599       599    2             if (v2.val.ival == 0)   {
A      600       600    3                v1.vtype = VAL_ERROR;
A      601       601    3        #ifndef TEST
A      602       602    3                error("\"%s\" line %d: division by zero\n",
A      603       603    3                      file_table[InputNo].fid,  file_table[InputNo].recno   );
A      604       604    3        #else
A      605       605   *S*               printf("** Error: division by zero\n");
A      606       606   *S*       #endif
A      607       607    3                }
A      608       608    2             else v1.val.ival /= v2.val.ival;
A      609       609    2             break;
A      610       610    2
A      611       611    2          case  OP_MODULUS:
A      612       612    2             if (v2.val.ival == 0)   {
A      613       613    3                v1.vtype = VAL_ERROR;
A      614       614    3        #ifndef TEST
A      615       615    3                error("\"%s\" line %d: division by zero\n",
A      616       616    3                      file_table[InputNo].fid,  file_table[InputNo].recno   );
A      617       617    3        #else
A      618       618   *S*               printf("** Error: division by zero\n");
A      619       619   *S*       #endif
A      620       620    3                }
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=18 
A      621       621    2             else v1.val.ival %= v2.val.ival;
A      622       622    2             break;
A      623       623    2          case  OP_ADD:
A      624       624    2             v1.val.ival += v2.val.ival;                        break;
A      625       625    2          case  OP_SUBTRACT:
A      626       626    2             v1.val.ival -= v2.val.ival;                        break;
A      627       627    2          case  OP_LEFT:
A      628       628    2             v1.val.ival <<= v2.val.ival;                       break;
A      629       629    2          case  OP_RIGHT:
A      630       630    2             v1.val.ival >>= v2.val.ival;                       break;
A      631       631    2          case  OP_AND:
A      632       632    2             v1.val.ival &= v2.val.ival;                        break;
A      633       633    2          case  OP_XOR:
A      634       634    2             v1.val.ival ^= v2.val.ival;                        break;
A      635       635    2          case  OP_OR:
A      636       636    2             v1.val.ival |= v2.val.ival;                        break;
A      637       637    2          case  OP_LESS:
A      638       638    2             v1.val.ival = compare_values(v1, v2) < 0;  v1.vtype = VAL_CONST; break;
A      639       639    2          case  OP_GREAT:
A      640       640    2             v1.val.ival = compare_values(v1, v2) > 0;  v1.vtype = VAL_CONST; break;
A      641       641    2          case  OP_LESSEQ:
A      642       642    2             v1.val.ival = compare_values(v1, v2) <= 0; v1.vtype = VAL_CONST; break;
A      643       643    2          case  OP_GREATEQ:
A      644       644    2             v1.val.ival = compare_values(v1, v2) >= 0; v1.vtype = VAL_CONST; break;
A      645       645    2          case  OP_EQUAL:
A      646       646    2             v1.val.ival = compare_values(v1, v2) == 0; v1.vtype = VAL_CONST; break;
A      647       647    2          case  OP_NOTEQUAL:
A      648       648    2             v1.val.ival = compare_values(v1, v2) != 0; v1.vtype = VAL_CONST; break;
A      649       649    2          case  OP_ANDAND:
A      650       650    2          case  OP_OROR:
A      651       651    2             {
A      652       652    3                unsigned rv1 = eval_logl(v1);
A      653       653    3                unsigned rv2 = eval_logl(v2);
A      654       654    3                v1.vtype = VAL_CONST;
A      655       655    3                if (f == OP_ANDAND)
A      656       656    3                   v1.val.ival = rv1 & rv2;
A      657       657    3                else v1.val.ival = rv1 | rv2;
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=19 
A      658       658    3             }
A      659       659    2             break;
A      660       660    2
A      661       661    2          default:
A      662       662    2
A      663       663    2        #ifndef TEST
A      664       664    2             error("\"%s\" line %d: unknown binary function (%d) in :if expression\n",
A
A      665       665    2                   file_table[InputNo].fid,  file_table[InputNo].recno, f
A                               );
A      666       666    2        #else
A      667       667   *S*            printf("** Error: unknown binary function (%d) in parse nodes\n", f
A                               );
A      668       668   *S*       #endif
A      669       669    2             v1.vtype = VAL_ERROR;
A      670       670    2          }
A      671       671    1
A      672       672    1          return v1;
A      673       673    1        }
A      674       674
A      675       675
A      676       676
A      677       677
A      678       678             /*F*    NAME:          evaluate
A      679       679                     PURPOSE:       To evaluate an expression.
A      680       680                     DESCRIPTION:
A      681       681                        This function uses:
A      682       682
A      683       683                        get_unary      to get the next value token.
A      684       684                        eval_fun       to evaluate a function with two arguments
A      685       685
A      686       686                        The execution is performed with two stacks.  The value
A      687       687                        stack holds value tokens and the function stack holds
A      688       688                        the functions which cannot be evaluated because their
A      689       689                        arguments are missing or their precedence is too low.
A      690       690
A      691       691                        When the end of the expression is reached the value stack
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=20 
A      692       692                        contains one item which is the result.
A      693       693                        The stacks need only be large enough to hold a value for
A      694       694                        each unique precedence value since recursion is used to
A      695       695                        evaluate parenthesized expressions.
A      696       696             */
A      697       697
A      698       698             struct value
A      699       699             evaluate( struct parse_out *p )
A      700       700             {
A      701       701    1          int pnum = p->nsublks;
A      702       702    1          int pi   = 0;
A      703       703    1          int vi   = 0,  fi = 0,  f  = 0,  prio = 0;
A      704       704    1          struct value vstk[12];
A      705       705    1          int          fstk[12];
A      706       706    1
A      707       707    1          if (p->code == 0 || p->code == 9)
A      708       708    1          while (pi < pnum) {
A      709       709    2             vstk[ vi++ ] = get_unary( p, &pi );
A      710       710    2
A      711       711    2             if (pi < pnum)
A      712       712    2                f = p->sublk[pi++]->code;
A      713       713    2             else f = OP_DONE;
A      714       714    2
A      715       715    2             prio = f >> 3;
A      716       716    2
A      717       717    2             while ( vi > 1 && prio >= (fstk[fi-1] >> 3)  )  {
A      718       718    3                vi = vi - 1;
A      719       719    3                vstk[vi-1] = eval_fun( fstk[--fi], vstk[vi-1], vstk[vi+0]);
A      720       720    3                }
A      721       721    2
A      722       722    2             if (pi < pnum) fstk[fi++] = f;
A      723       723    2             }
A      724       724    1          else vstk[0] = get_primary( (struct parse_sym *) p );
A      725       725    1
A      726       726    1          return vstk[0];
A      727       727    1        }
A      728       728
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=21 
A      729       729             PrintExpr( FILE *f, struct value *v )
A      730       730             {
A      731       731    1          char  *cp, buf[84];
A      732       732    1          int     i, j;
A      733       733    1
A      734       734    1          switch (v->vtype)  {
A      735       735    2
A      736       736    2          case VAL_CONST:   fprintf(f,"%d", v->val.ival); break;
A      737       737    2          case VAL_ERROR:                                 break;
A      738       738    2
A      739       739    2        #ifndef TEST
A      740       740    2
A      741       741    2          case VAL_IDF:
A      742       742    2             if (v->val.macro.mc)
A      743       743    2                fprintf(f,"%s", v->val.macro.mc->mc_def);
A      744       744    2             break;
A      745       745    2
A      746       746    2        #endif
A      747       747    2
A      748       748    2          case VAL_STR:
A      749       749    2             cp = v->val.string.str;
A      750       750    2             i  = v->val.string.st_len;
A      751       751    2             while (i)   {
A      752       752    3                j = (i > 80) ? 80 : i;
A      753       753    3                memcpy(buf, cp, j);
A      754       754    3                buf[j] = 0;
A      755       755    3                fprintf(f,"%s", buf);
A      756       756    3                cp += j;
A      757       757    3                i  -= j;
A      758       758    3                }
A      759       759    2             break;
A      760       760    2          }
A      761       761    1        }
A      762       762
A      763       763
A      764       764             #ifdef TEST
A      765       765   *S*
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=22 
A      766       766   *S*
A      767       767   *S*       /*D*    NAME:          UserParse
A      768       768   *S*               PURPOSE:       A generic routine to handle entries from
A      769       769   *S*                        X$PARSE to expand the parser work area.
A      770       770   *S*               DESCRIPTION:
A      771       771   *S*                  In order to use this function, the user must be using
A      772       772   *S*                  ParseWork and ParseWorkSize.  If the workarea has moved
A      773       773   *S*                  during expansion, this routine unwinds (longjumps)
A      774       774   *S*                  through ExpandParseRetry which is expected to re-start
A      775       775   *S*                  the parse of this command.
A      776       776   *S*       */
A      777       777   *S*
A      778       778   *S*       int
A      779       779   *S*       UserParse(p)
A      780       780   *S*         struct parse_param *p;
A      781       781   *S*       {
A      782       782   *S*         char *q;
A      783       783   *S*
A      784       784   *S*         switch (p->type)  {
A      785       785   *S*
A      786       786   *S*         case CP6_SPACE:
A      787       787   *S*
A      788       788   *S*            q = ParseWork;
A      789       789   *S*            if (!(ParseWork = (char *) realloc(ParseWork, (ParseWorkSize <<=1))))
A      790       790   *S*               crash("Out of Memory: UserParse");
A      791       791   *S*
A      792       792   *S*            if (q != ParseWork) longjmp(ExpandParseRetry, 1);
A      793       793   *S*            p->wksz = ParseWorkSize >> 2;
A      794       794   *S*            break;
A      795       795   *S*         }
A      796       796   *S*         return 0;
A      797       797   *S*       }
A      798       798   *S*
A      799       799   *S*
A      800       800   *S*       /*D*    NAME:       ReportParseLexemes(line)
A      801       801   *S*               PURPOSE:    To print the syntax alternatives indicated by
A      802       802   *S*                           X$PARSE.
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=23 
A      803       803   *S*       */
A      804       804   *S*       int
A      805       805   *S*       ReportParseLexemes(line)
A      806       806   *S*         char *line;
A      807       807   *S*       {
A      808       808   *S*         int i = 79;
A      809       809   *S*         char buf[84];
A      810       810   *S*
A      811       811   *S*         memcpy(buf, line, 80);
A      812       812   *S*         while (buf[i] == ' ') i--;
A      813       813   *S*         buf[++i] = 0;
A      814       814   *S*         printf("%s\n",buf);
A      815       815   *S*         return 0;
A      816       816   *S*       }
A      817       817   *S*
A      818       818   *S*       crash(char *s)   {
A      819       819   *S*         printf("%s\n",s);
A      820       820   *S*         exit(0);
A      821       821   *S*       }
A      822       822   *S*
A      823       823   *S*
A      824       824   *S*
A      825       825   *S*       main()  {
A      826       826   *S*         char  line[120];
A      827       827   *S*
A      828       828   *S*         int   len = 0;
A      829       829   *S*
A      830       830   *S*
A      831       831   *S*         while ( fgets(line, 120, stdin) )   {
A      832       832   *S*            len = strlen(line);
A      833       833   *S*            CommandPCB.text = line;
A      834       834   *S*            CommandPCB.nchars = len-1;
A      835       835   *S*            setjmp(ExpandParseRetry);
A      836       836   *S*
A      837       837   *S*            if (!ParseWork)   {
A      838       838   *S*               ParseWork = malloc(512);
A      839       839   *S*               ParseWorkSize = 512;
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=24 
A      840       840   *S*               }
A      841       841   *S*
A      842       842   *S*            CommandPCB.work = ParseWork;
A      843       843   *S*            CommandPCB.wksz = ParseWorkSize >> 2;
A      844       844   *S*
A      845       845   *S*            if (!X$PARSE(&CommandPCB)) {
A      846       846   *S*               ReportParseErr(&CommandPCB);
A      847       847   *S*               }
A      848       848   *S*            else  {
A      849       849   *S*               struct value v;
A      850       850   *S*               v = evaluate(CommandPCB.out);
A      851       851   *S*               PrintExprVal(v);
A      852       852   *S*               }
A      853       853   *S*            }
A      854       854   *S*         exit(0);
A      855       855   *S*       }
A      856       856   *S*
A      857       857   *S*       PrintExprVal(struct value v)
A      858       858   *S*       {
A      859       859   *S*         switch (v.vtype)  {
A      860       860   *S*
A      861       861   *S*         case VAL_ERROR:
A      862       862   *S*               printf("****** Error Result ********\n");       break;
A      863       863   *S*         case VAL_IDF:
A      864       864   *S*               printf("****** IDF Result?  ********\n");       break;
A      865       865   *S*         case VAL_STR:
A      866       866   *S*               printf("* String: %s\n", v.val.string.str);     break;
A      867       867   *S*         case  VAL_CONST:
A      868       868   *S*               printf("* Integer: %d\n", v.val.ival);          break;
A      869       869   *S*         default:
A      870       870   *S*               printf("****** Unknown result type: %d\n", v.vtype); break;
A      871       871   *S*         }
A      872       872   *S*       }
A      873       873   *S*
A      874       874   *S*
A      875       875   *S*
A      876       876   *S*
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=25 
A      877       877   *S*       /*D*    NAME:       ReportParseErr(pcb)
A      878       878   *S*               PURPOSE:    To report an error detected by X$PARSE.
A      879       879   *S*       */
A      880       880   *S*
A      881       881   *S*       int
A      882       882   *S*       ReportParseErr(struct p_pcb *pcb)
A      883       883   *S*       {
A      884       884   *S*         char  preview[40];
A      885       885   *S*         static const char marker[] = " <-*-> ";
A      886       886   *S*         unsigned ep = pcb->hi_char;
A      887       887   *S*         unsigned sc = (ep > 15) ? ep - 15 : 0;
A      888       888   *S*         unsigned lp = pcb->nchars;
A      889       889   *S*         unsigned ec = ((ep+12)>lp) ? lp : ep+12;
A      890       890   *S*         char *ins = preview;
A      891       891   *S*         char *src = pcb->text;
A      892       892   *S*         int   l;
A      893       893   *S*
A      894       894   *S*         if ((ec - sc)>0)  {
A      895       895   *S*            if ((l = ep - sc) > 0)
A      896       896   *S*               memcpy(ins, src+sc, l), ins += l;
A      897       897   *S*            memcpy(ins, marker, 7), ins += 7;
A      898       898   *S*            if ((l = ec - ep) > 0)
A      899       899   *S*               memcpy(ins, src+ep, l), ins += l;
A      900       900   *S*            *ins = 0;
A      901       901   *S*            printf("Error: \"%s\"\n",preview);
A      902       902   *S*            }
A      903       903   *S*         pcb->nxt = 1;
A      904       904   *S*         X$PARSE(pcb);
A      905       905   *S*         pcb->nxt = 0;
A      906       906   *S*         return;
A      907       907   *S*       }
A      908       908   *S*
A      909       909   *S*       #endif
A---  Include file information  ---
A
A   stdio:h.:LIBRARY. is referenced
A   setjmp:h.:LIBRARY. is referenced
rCC.C03    File=MAKE_SIc18.:XSI                                                      Thu Nov 20 1997  Page=26 
A   stdlib:h.:LIBRARY. is referenced
A   xu_cp6_c:h.:LIBRARY. is referenced
A   xu_macro_c:h.:LIBRARY. is referenced
A   xu_subs_c:h.:LIBRARY. is referenced
A   MAKE_Cc14.:XSI. is referenced
A   MAKE_Cc13.:XSI. is referenced
C
ANo diagnostics were issued in the file MAKE_SIc18.:XSI
