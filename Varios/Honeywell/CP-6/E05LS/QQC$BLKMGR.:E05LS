VERSION E05

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:1    
        1        1        /*M* QQC$BLKMGR - Memory management routines */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* IND=2, DCI=4, CSU=2, ECU=4, DTI=2, CTI=4, AND */
        8        8        /*P*     NAME:  BLKMGR
        9        9                 PURPOSE:  BLKMGR is a set of three subroutines (INIT_BLKMGR,
       10       10                      GET_BLK, and RLS_BLK) which together form an
       11       11                      implementation of a First FIT dynamic space algorithm
       12       12                      described in KNUTH, volume 1.  The algorithms in
       13       13                      these subroutines use the double linked list with
       14       14                      boundary tags approach to dynamic space allocation.
       15       15                      In addition, this implementation of the block manager
       16       16                      supports any number of data pools which may be managed
       17       17                      separately.
       18       18                 REFERENCE:  "THE ARE OF COMPUTER PROGRAMMING, FUNDAMENTAL
       19       19                      ALGORITHMS, VOLUME 1", Donald E. Knuth, second edition
       20       20                      1973, pages 435-451. */
       21       21
       22       22        QQC$INIT_BLKMGR: PROC (P_POOL$, P_POOL_SIZE) NOAUTO;
       23       23
       24       24        /*F*     NAME:  QQC$INIT_BLKMGR
       25       25                      INIT_BLKMGR initializes the pool from which subsequent
       26       26                      GET_BLK and RLS_BLK requests can be made.  N.B.  A
       27       27                      call to INIT_BLKMGR must be the first call to the
       28       28                      BLKMGR routines.  In addition, only one call to this
       29       29                      routine should ever be made for a pool. */
       30       30        /*D*     NAME:  QQC$INIT_BLKMGR
       31       31                      INIT_BLKMGR initializes the pool of memory which is
       32       32                      pointed to by P_POOL$.  The size of the pool is contained
       33       33                      in P_POOL_SIZE.  These cells are passed to the block
       34       34                      manager by the caller. */
       35       35    1   DCL P_POOL$ PTR;              /* Parameter, pointer to the pool to initialize */
       36       36    1   DCL P_POOL_SIZE SBIN WORD;         /* Parameter, size (in words) of the pool  */
       37       37
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:2    
       38       38    1   DCL 1 LIST$HDR BASED(P_POOL$),
       39       39    1         2 TAG SBIN WORD,
       40       40    1         2 SIZE SBIN WORD,
       41       41    1         2 FLINK$ PTR,                     /* AVAIL$                             */
       42       42    1         2 BLINK$ PTR,
       43       43    1         2 ROVER$ PTR;
       44       44
       45       45    1   DCL 1 BLK$HEAD BASED,
       46       46    1         2 TAG SBIN WORD,
       47       47    1         2 SIZE SBIN WORD,
       48       48    1         2 FLINK$ PTR,
       49       49    1         2 BLINK$ PTR;
       50       50
       51       51    1   DCL 1 BLK$TAIL BASED,
       52       52    1         2 TAG SBIN WORD,
       53       53    1         2 SIZE SBIN WORD;
       54       54
       55       55    1   DCL POOL$ PTR STATIC;              /* Points to the first available block     */
       56       56    1   DCL TAIL$ PTR STATIC;         /* Pointer to the tail of the available pool    */
       57       57
       58       58        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
       59       59        %EQU UNAVAILABLE = CHARTEXT('-1 /* UNAVAILABLE */');
       60       60
       61       61        %EJECT;
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:3    
       62       62    1   BEGIN:
       63       63        /*
       64       64        Initialize the list header (LIST$HDR)
       65       65        */
       66       66    2           DO INHIBIT;
       67       67    2             POOL$ = PINCRW(P_POOL$, SIZEW(LIST$HDR));
       68       68    2             LIST$HDR.TAG = %UNAVAILABLE;
       69       69    2             LIST$HDR.SIZE = 0;
       70       70    2             LIST$HDR.FLINK$ = POOL$;
       71       71    2             LIST$HDR.BLINK$ = POOL$;
       72       72    2             LIST$HDR.ROVER$ = P_POOL$;    /* ADDR(LIST$HDR)                     */
       73       73
       74       74        /*
       75       75        Initialize the head of the pool
       76       76        */
       77       77    2             POOL$->BLK$HEAD.TAG = %AVAILABLE;
       78       78    2             POOL$->BLK$HEAD.SIZE = P_POOL_SIZE - SIZEW(LIST$HDR);
       79       79    2             POOL$->BLK$HEAD.FLINK$ = P_POOL$;
       80       80    2             POOL$->BLK$HEAD.BLINK$ = P_POOL$;
       81       81
       82       82        /*
       83       83        Initialize the tail of the pool
       84       84        */
       85       85    2             TAIL$ = PINCRW(POOL$, (POOL$->BLK$HEAD.SIZE - (SIZEW(BLK$TAIL))));
       86       86    2             TAIL$->BLK$TAIL.TAG = %AVAILABLE;
       87       87    2             TAIL$->BLK$TAIL.SIZE = POOL$->BLK$HEAD.SIZE;
       88       88
       89       89    2             RETURN;
       90       90    2           END /* INHIBIT */;
       91       91
       92       92    1   END QQC$INIT_BLKMGR;
       93       93        %EOD;

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:4    
      No diagnostics issued in procedure QQC$INIT_BLKMGR.

   Procedure QQC$INIT_BLKMGR requires 42 words for executable code.
   Procedure QQC$INIT_BLKMGR is declared NOAUTO and requires 6 words of local(STATIC) storage.

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:5    

 Object Unit name= QQC$INIT_BLKMGR                            File name= QQC$BLKMGR.:E05TOU
 UTS= JUL 30 '97 05:39:00.80 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Data  even  none     6      6  QQC$INIT_BLKMGR
    1   Proc  even  none    42     52  QQC$INIT_BLKMGR

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes            yes      Std        2  QQC$INIT_BLKMGR

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
                       nStd      0 X66_STATIC_2
                       Std       0 B_CONSPOOL_D

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:6    


        1        1        /*M* QQC$BLKMGR - Memory management routines */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* IND=2, DCI=4, CSU=2, ECU=4, DTI=2, CTI=4, AND */
        8        8        /*P*     NAME:  BLKMGR
        9        9                 PURPOSE:  BLKMGR is a set of three subroutines (INIT_BLKMGR,
       10       10                      GET_BLK, and RLS_BLK) which together form an
       11       11                      implementation of a First FIT dynamic space algorithm
       12       12                      described in KNUTH, volume 1.  The algorithms in
       13       13                      these subroutines use the double linked list with
       14       14                      boundary tags approach to dynamic space allocation.
       15       15                      In addition, this implementation of the block manager
       16       16                      supports any number of data pools which may be managed
       17       17                      separately.
       18       18                 REFERENCE:  "THE ARE OF COMPUTER PROGRAMMING, FUNDAMENTAL
       19       19                      ALGORITHMS, VOLUME 1", Donald E. Knuth, second edition
       20       20                      1973, pages 435-451. */
       21       21
       22       22        QQC$INIT_BLKMGR: PROC (P_POOL$, P_POOL_SIZE) NOAUTO;

     22  1 000000   000000 700200 xent  QQC$INIT_BL* TSX0  ! X66_STATIC_2
         1 000001   000000 000002 0                  ZERO    0,2

       23       23
       24       24        /*F*     NAME:  QQC$INIT_BLKMGR
       25       25                      INIT_BLKMGR initializes the pool from which subsequent
       26       26                      GET_BLK and RLS_BLK requests can be made.  N.B.  A
       27       27                      call to INIT_BLKMGR must be the first call to the
       28       28                      BLKMGR routines.  In addition, only one call to this
       29       29                      routine should ever be made for a pool. */
       30       30        /*D*     NAME:  QQC$INIT_BLKMGR
       31       31                      INIT_BLKMGR initializes the pool of memory which is
       32       32                      pointed to by P_POOL$.  The size of the pool is contained
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:7    
       33       33                      in P_POOL_SIZE.  These cells are passed to the block
       34       34                      manager by the caller. */
       35       35    1   DCL P_POOL$ PTR;              /* Parameter, pointer to the pool to initialize */
       36       36    1   DCL P_POOL_SIZE SBIN WORD;         /* Parameter, size (in words) of the pool  */
       37       37
       38       38    1   DCL 1 LIST$HDR BASED(P_POOL$),
       39       39    1         2 TAG SBIN WORD,
       40       40    1         2 SIZE SBIN WORD,
       41       41    1         2 FLINK$ PTR,                     /* AVAIL$                             */
       42       42    1         2 BLINK$ PTR,
       43       43    1         2 ROVER$ PTR;
       44       44
       45       45    1   DCL 1 BLK$HEAD BASED,
       46       46    1         2 TAG SBIN WORD,
       47       47    1         2 SIZE SBIN WORD,
       48       48    1         2 FLINK$ PTR,
       49       49    1         2 BLINK$ PTR;
       50       50
       51       51    1   DCL 1 BLK$TAIL BASED,
       52       52    1         2 TAG SBIN WORD,
       53       53    1         2 SIZE SBIN WORD;
       54       54
       55       55    1   DCL POOL$ PTR STATIC;              /* Points to the first available block     */
       56       56    1   DCL TAIL$ PTR STATIC;         /* Pointer to the tail of the available pool    */
       57       57
       58       58        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
       59       59        %EQU UNAVAILABLE = CHARTEXT('-1 /* UNAVAILABLE */');
       60       60
       61       61        %EJECT;
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:8    
       62       62    1   BEGIN:
       63       63        /*
       64       64        Initialize the list header (LIST$HDR)
       65       65        */
       66       66    2           DO INHIBIT;

     66  1 000002                       BEGIN        null
       67       67    2             POOL$ = PINCRW(P_POOL$, SIZEW(LIST$HDR));

     67  1 000002   000001 470600 0                  LDP0  ! @P_POOL$
         1 000003   000000 236300                    LDQ   ! 0,,PR0
         1 000004   000005 036203                    ADLQ  ! 5,DU
         1 000005   000003 756200 0                  STQ   ! POOL$

       68       68    2             LIST$HDR.TAG = %UNAVAILABLE;

     68  1 000006   000000 471700                    LDP1  ! 0,,PR0
         1 000007   000001 335207                    LCA   ! 1,DL
         1 000010   100000 755300                    STA   ! 0,,PR1

       69       69    2             LIST$HDR.SIZE = 0;

     69  1 000011   000000 471700                    LDP1  ! 0,,PR0
         1 000012   100001 450300                    STZ   ! 1,,PR1

       70       70    2             LIST$HDR.FLINK$ = POOL$;

     70  1 000013   000000 471700                    LDP1  ! 0,,PR0
         1 000014   100002 756300                    STQ   ! 2,,PR1

       71       71    2             LIST$HDR.BLINK$ = POOL$;

     71  1 000015   000000 471700                    LDP1  ! 0,,PR0
         1 000016   100003 756300                    STQ   ! 3,,PR1

       72       72    2             LIST$HDR.ROVER$ = P_POOL$;    /* ADDR(LIST$HDR)                     */

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:9    
     72  1 000017   000000 471700                    LDP1  ! 0,,PR0
         1 000020   000000 236300                    LDQ   ! 0,,PR0
         1 000021   100004 756300                    STQ   ! 4,,PR1

       73       73
       74       74        /*
       75       75        Initialize the head of the pool
       76       76        */
       77       77    2             POOL$->BLK$HEAD.TAG = %AVAILABLE;

     77  1 000022   000001 236207                    LDQ   ! 1,DL
         1 000023   000003 471600 0                  LDP1  ! POOL$
         1 000024   100000 756300                    STQ   ! 0,,PR1

       78       78    2             POOL$->BLK$HEAD.SIZE = P_POOL_SIZE - SIZEW(LIST$HDR);

     78  1 000025   000002 473600 0                  LDP3  ! @P_POOL_SIZE
         1 000026   300000 235300                    LDA   ! 0,,PR3
         1 000027   000005 135207                    SBLA  ! 5,DL
         1 000030   100001 755300                    STA   ! 1,,PR1

       79       79    2             POOL$->BLK$HEAD.FLINK$ = P_POOL$;

     79  1 000031   000000 236300                    LDQ   ! 0,,PR0
         1 000032   100002 756300                    STQ   ! 2,,PR1

       80       80    2             POOL$->BLK$HEAD.BLINK$ = P_POOL$;

     80  1 000033   000000 236300                    LDQ   ! 0,,PR0
         1 000034   100003 756300                    STQ   ! 3,,PR1

       81       81
       82       82        /*
       83       83        Initialize the tail of the pool
       84       84        */
       85       85    2             TAIL$ = PINCRW(POOL$, (POOL$->BLK$HEAD.SIZE - (SIZEW(BLK$TAIL))));

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:10   
     85  1 000035   100001 236300                    LDQ   ! 1,,PR1
         1 000036   000022 736200                    QLS   ! 18
         1 000037   000002 136203                    SBLQ  ! 2,DU
         1 000040   000003 036200 0                  ADLQ  ! POOL$
         1 000041   000004 756200 0                  STQ   ! TAIL$

       86       86    2             TAIL$->BLK$TAIL.TAG = %AVAILABLE;

     86  1 000042   000001 235207                    LDA   ! 1,DL
         1 000043   000004 474600 0                  LDP4  ! TAIL$
         1 000044   400000 755300                    STA   ! 0,,PR4

       87       87    2             TAIL$->BLK$TAIL.SIZE = POOL$->BLK$HEAD.SIZE;

     87  1 000045   100001 235300                    LDA   ! 1,,PR1
         1 000046   400001 755300                    STA   ! 1,,PR4

       88       88
       89       89    2             RETURN;

     89  1 000047   000000 221200 0                  LDX1  ! 0
         1 000050   000001 702211                    TSX2  ! 1,X1

       90       90    2           END /* INHIBIT */;

       91       91
       92       92    1   END QQC$INIT_BLKMGR;

     92  1 000051   000001 702211                    TSX2  ! 1,X1
       93       93        %EOD;

PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:11   
      No diagnostics issued in procedure QQC$INIT_BLKMGR.
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:12   

 **** Variables and constants ****

  ****  Section 000  Data  QQC$INIT_BLKMGR

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     1-0-0/w PTR         r     1 @P_POOL$                   2-0-0/w PTR         r     1 @P_POOL_SIZE
     3-0-0/w PTR         r     1 POOL$                     *0-0-0/w PTR         r     1 P_POOL$
    *0-0-0/w SBIN        r     1 P_POOL_SIZE                4-0-0/w PTR         r     1 TAIL$

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 BLK$HEAD                   0-0-0/w STRC(72)    r     1 BLK$TAIL
     0-0-0/w STRC(180)   r     1 LIST$HDR


   Procedure QQC$INIT_BLKMGR requires 42 words for executable code.
   Procedure QQC$INIT_BLKMGR is declared NOAUTO and requires 6 words of local(STATIC) storage.
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:13   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:14   
          MINI XREF LISTING

BLK$HEAD.BLINK$
        49**DCL        80<<ASSIGN
BLK$HEAD.FLINK$
        48**DCL        79<<ASSIGN
BLK$HEAD.SIZE
        47**DCL        78<<ASSIGN     85>>ASSIGN     87>>ASSIGN
BLK$HEAD.TAG
        46**DCL        77<<ASSIGN
BLK$TAIL
        51**DCL        85--ASSIGN
BLK$TAIL.SIZE
        53**DCL        87<<ASSIGN
BLK$TAIL.TAG
        52**DCL        86<<ASSIGN
LIST$HDR
        38**DCL        67--ASSIGN     78--ASSIGN
LIST$HDR.BLINK$
        42**DCL        71<<ASSIGN
LIST$HDR.FLINK$
        41**DCL        70<<ASSIGN
LIST$HDR.ROVER$
        43**DCL        72<<ASSIGN
LIST$HDR.SIZE
        40**DCL        69<<ASSIGN
LIST$HDR.TAG
        39**DCL        68<<ASSIGN
POOL$
        55**DCL        67<<ASSIGN     70>>ASSIGN     71>>ASSIGN     77>>ASSIGN     78>>ASSIGN     79>>ASSIGN
        80>>ASSIGN     85>>ASSIGN     85>>ASSIGN     87>>ASSIGN
P_POOL$
        35**DCL        22--PROC       38--IMP-PTR    67>>ASSIGN     68>>ASSIGN     69>>ASSIGN     70>>ASSIGN
        71>>ASSIGN     72>>ASSIGN     72>>ASSIGN     79>>ASSIGN     80>>ASSIGN
PL6.E3A0      #001=QQC$INIT_BLKMGR File=QQC$BLKMGR.:E05TSI                       WED 07/30/97 05:39 Page:15   
P_POOL_SIZE
        36**DCL        22--PROC       78>>ASSIGN
TAIL$
        56**DCL        85<<ASSIGN     86>>ASSIGN     87>>ASSIGN

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:16   
       94        1        /*T***********************************************************/
       95        2        /*T*                                                         */
       96        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
       97        4        /*T*                                                         */
       98        5        /*T***********************************************************/
       99        6        QQC$GET_BLK: PROC (P_POOL$, P_ACT_REQSIZE, P_RESHEAD$) NOAUTO ALTRET;
      100        7
      101        8        /*F*     NAME:  QQC$GET_BLK
      102        9                      GET_BLK may be called to request a block of memory
      103       10                      from 1 to n words in length.  (N is limited by the
      104       11                      size of the pool from which we are allocating
      105       12                      memory.)  */
      106       13        /*D*     NAME:  QQC$GET_BLK
      107       14                      Three parameters must be passed to GET_BLK.  The first
      108       15                      is P_POOL$ which is a pointer to the pool from which
      109       16                      the request is to be satisfied.  The second parameter
      110       17                      is P_ACT_REQSIZE which should contain an integer
      111       18                      specifying the number of words requested.  The third
      112       19                      is P_RESHEAD$ which will be returned containing a
      113       20                      pointer to the first available cell in the allocated
      114       21                      block.
      115       22
      116       23                      One will note when examining the code in GET_BLK
      117       24                      that the request size is increased by six words
      118       25                      to accomodate the boundary tags, flinks and blinks.
      119       26                      These words must not be destroyed. */
      120       27
      121       28    1   DCL 1 LIST$HDR BASED(P_POOL$),
      122       29    1         2 TAG SBIN WORD,
      123       30    1         2 SIZE SBIN WORD,
      124       31    1         2 FLINK$ PTR,                     /* AVAIL$                             */
      125       32    1         2 BLINK$ PTR,
      126       33    1         2 ROVER$ PTR;                /* A roving pointer to available blocks    */
      127       34
      128       35    1   DCL 1 BLK$HEAD BASED,
      129       36    1         2 TAG SBIN WORD,
      130       37    1         2 SIZE SBIN WORD,
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:17   
      131       38    1         2 FLINK$ PTR,
      132       39    1         2 BLINK$ PTR;
      133       40
      134       41    1   DCL 1 BLK$TAIL BASED,
      135       42    1         2 TAG SBIN WORD,
      136       43    1         2 SIZE SBIN WORD;
      137       44
      138       45    1   DCL P_POOL$ PTR;                   /* Points to the first available block     */
      139       46    1   DCL P_RESHEAD$ PTR;      /* Parameter, returned pointing to block reserved    */
      140       47    1   DCL P_ACT_REQSIZE SBIN WORD;       /* Parameter, contains size of request     */
      141       48
      142       49    1   DCL AV_HEAD$ PTR STATIC;                /* Pointer to available blocks        */
      143       50    1   DCL AV_TAIL$ PTR STATIC;           /* Points to new tail of available block   */
      144       51    1   DCL RES_TAIL$ PTR STATIC;               /* Points to tail of block reserved   */
      145       52    1   DCL K SBIN WORD STATIC;  /* Contains available block size after reservation   */
      146       53    1   DCL C SBIN WORD CONSTANT INIT(10);      /* C MUST BE >= 6                     */
      147       54    1   DCL F SBIN WORD STATIC;                 /* A flag                             */
      148       55    1   DCL REQSIZE SBIN WORD STATIC;      /* Request size after tags are added in    */
      149       56
      150       57        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
      151       58        %EQU UNAVAILABLE = CHARTEXT('-1 /* UNAVAILABLE */');
      152       59
      153       60        %EJECT;
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:18   
      154       61    1   BEGIN:
      155       62    2           DO INHIBIT;
      156       63    2             REQSIZE = P_ACT_REQSIZE + (SIZEW(BLK$HEAD)) + (SIZEW(BLK$TAIL));
      157       64    2             AV_HEAD$ = LIST$HDR.ROVER$;
      158       65    2             F = 0;
      159       66
      160       67        /*
      161       68        Using a circular search (from LIST$HDR.ROVER$ to LIST$HDR.ROVER$) find a
      162       69        block that is big enough to satisfy the request.
      163       70        */
      164       71    3             DO WHILE (AV_HEAD$->BLK$HEAD.SIZE < REQSIZE);
      165       72    3               IF AV_HEAD$ = LIST$HDR.ROVER$ THEN
      166       73    4                 DO;
      167       74    4                   IF F = 0 THEN
      168       75    5                     DO;
      169       76    5                       F = 1;
      170       77    5                     END /* THEN DO */;
      171       78    4                   ELSE
      172       79    5                     DO;
      173       80    5                       GOTO NO_SPACE;
      174       81    5                     END /* ELSE DO */;
      175       82    4                 END /* THEN DO */;
      176       83    3               AV_HEAD$ = AV_HEAD$->BLK$HEAD.FLINK$;
      177       84    3             END /* DO WHILE */;
      178       85
      179       86    2   A4:
      180       87    2             LIST$HDR.ROVER$ = AV_HEAD$->BLK$HEAD.FLINK$;
      181       88    2             K = AV_HEAD$->BLK$HEAD.SIZE - REQSIZE;
      182       89    2             IF K < C THEN
      183       90    3               DO;
      184       91    3                 AV_HEAD$->BLK$HEAD.BLINK$->BLK$HEAD.FLINK$ = LIST$HDR.ROVER$;
      185       92    3                 LIST$HDR.ROVER$->BLK$HEAD.BLINK$ = AV_HEAD$->BLK$HEAD.BLINK$;
      186       93    3                 P_RESHEAD$ = AV_HEAD$;
      187       94    3                 RES_TAIL$ = PINCRW(AV_HEAD$, (AV_HEAD$->BLK$HEAD.SIZE - (SIZEW(
                94                          BLK$TAIL))));
      188       95    3               END /* THEN DO */;
      189       96    2             ELSE
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:19   
      190       97    3               DO;
      191       98    3                 P_RESHEAD$ = PINCRW(AV_HEAD$, K);
      192       99    3                 AV_HEAD$->BLK$HEAD.SIZE = K;
      193      100    3                 AV_TAIL$ = PINCRW(P_RESHEAD$, -(SIZEW(BLK$TAIL)));
      194      101    3                 AV_TAIL$->BLK$TAIL.SIZE = K;
      195      102    3                 AV_TAIL$->BLK$TAIL.TAG = %AVAILABLE;
      196      103    3                 P_RESHEAD$->BLK$HEAD.SIZE = REQSIZE;
      197      104    3                 RES_TAIL$ = PINCRW(P_RESHEAD$, (REQSIZE - (SIZEW(BLK$TAIL))));
      198      105    3                 RES_TAIL$->BLK$TAIL.SIZE = REQSIZE;
      199      106    3               END /* ELSE DO */;
      200      107    2             P_RESHEAD$->BLK$HEAD.TAG = %UNAVAILABLE;
      201      108    2             RES_TAIL$->BLK$TAIL.TAG = %UNAVAILABLE;
      202      109
      203      110    2             P_RESHEAD$ = PINCRW(P_RESHEAD$, (SIZEW(BLK$HEAD)));
      204      111
      205      112    2             RETURN;
      206      113    2           END /* INHIBIT */;
      207      114
      208      115    1   NO_SPACE:
      209      116    1           P_RESHEAD$ = ADDR(NIL);
      210      117    1           ALTRETURN;
      211      118
      212      119    1   END QQC$GET_BLK;
      213      120        %EOD;

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:20   
      No diagnostics issued in procedure QQC$GET_BLK.

   Procedure QQC$GET_BLK requires 96 words for executable code.
   Procedure QQC$GET_BLK is declared NOAUTO and requires 10 words of local(STATIC) storage.

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:21   

 Object Unit name= QQC$GET_BLK                                File name= QQC$BLKMGR.:E05TOU
 UTS= JUL 30 '97 05:39:03.08 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Data  even  none    10     12  QQC$GET_BLK
    1  RoData even  UTS      1      1  QQC$GET_BLK
    2   Proc  even  none    96    140  QQC$GET_BLK

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     2      0   yes    yes     yes      Std        3  QQC$GET_BLK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
                       nStd      0 X66_STATIC_3
                       Std       0 B_CONSPOOL_D

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:22   


       94        1        /*T***********************************************************/
       95        2        /*T*                                                         */
       96        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
       97        4        /*T*                                                         */
       98        5        /*T***********************************************************/
       99        6        QQC$GET_BLK: PROC (P_POOL$, P_ACT_REQSIZE, P_RESHEAD$) NOAUTO ALTRET;

      6  2 000000   000000 700200 xent  QQC$GET_BLK  TSX0  ! X66_STATIC_3
         2 000001   000000 000003 0                  ZERO    0,3

      100        7
      101        8        /*F*     NAME:  QQC$GET_BLK
      102        9                      GET_BLK may be called to request a block of memory
      103       10                      from 1 to n words in length.  (N is limited by the
      104       11                      size of the pool from which we are allocating
      105       12                      memory.)  */
      106       13        /*D*     NAME:  QQC$GET_BLK
      107       14                      Three parameters must be passed to GET_BLK.  The first
      108       15                      is P_POOL$ which is a pointer to the pool from which
      109       16                      the request is to be satisfied.  The second parameter
      110       17                      is P_ACT_REQSIZE which should contain an integer
      111       18                      specifying the number of words requested.  The third
      112       19                      is P_RESHEAD$ which will be returned containing a
      113       20                      pointer to the first available cell in the allocated
      114       21                      block.
      115       22
      116       23                      One will note when examining the code in GET_BLK
      117       24                      that the request size is increased by six words
      118       25                      to accomodate the boundary tags, flinks and blinks.
      119       26                      These words must not be destroyed. */
      120       27
      121       28    1   DCL 1 LIST$HDR BASED(P_POOL$),
      122       29    1         2 TAG SBIN WORD,
      123       30    1         2 SIZE SBIN WORD,
      124       31    1         2 FLINK$ PTR,                     /* AVAIL$                             */
      125       32    1         2 BLINK$ PTR,
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:23   
      126       33    1         2 ROVER$ PTR;                /* A roving pointer to available blocks    */
      127       34
      128       35    1   DCL 1 BLK$HEAD BASED,
      129       36    1         2 TAG SBIN WORD,
      130       37    1         2 SIZE SBIN WORD,
      131       38    1         2 FLINK$ PTR,
      132       39    1         2 BLINK$ PTR;
      133       40
      134       41    1   DCL 1 BLK$TAIL BASED,
      135       42    1         2 TAG SBIN WORD,
      136       43    1         2 SIZE SBIN WORD;
      137       44
      138       45    1   DCL P_POOL$ PTR;                   /* Points to the first available block     */
      139       46    1   DCL P_RESHEAD$ PTR;      /* Parameter, returned pointing to block reserved    */
      140       47    1   DCL P_ACT_REQSIZE SBIN WORD;       /* Parameter, contains size of request     */
      141       48
      142       49    1   DCL AV_HEAD$ PTR STATIC;                /* Pointer to available blocks        */
      143       50    1   DCL AV_TAIL$ PTR STATIC;           /* Points to new tail of available block   */
      144       51    1   DCL RES_TAIL$ PTR STATIC;               /* Points to tail of block reserved   */
      145       52    1   DCL K SBIN WORD STATIC;  /* Contains available block size after reservation   */
      146       53    1   DCL C SBIN WORD CONSTANT INIT(10);      /* C MUST BE >= 6                     */
      147       54    1   DCL F SBIN WORD STATIC;                 /* A flag                             */
      148       55    1   DCL REQSIZE SBIN WORD STATIC;      /* Request size after tags are added in    */
      149       56
      150       57        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
      151       58        %EQU UNAVAILABLE = CHARTEXT('-1 /* UNAVAILABLE */');
      152       59
      153       60        %EJECT;
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:24   
      154       61    1   BEGIN:
      155       62    2           DO INHIBIT;

     62  2 000002                       BEGIN        null
      156       63    2             REQSIZE = P_ACT_REQSIZE + (SIZEW(BLK$HEAD)) + (SIZEW(BLK$TAIL));

     63  2 000002   000002 470600 0                  LDP0  ! @P_ACT_REQSIZE
         2 000003   000000 235300                    LDA   ! 0,,PR0
         2 000004   000006 035207                    ADLA  ! 6,DL
         2 000005   000011 755200 0                  STA   ! REQSIZE

      157       64    2             AV_HEAD$ = LIST$HDR.ROVER$;

     64  2 000006   000001 471600 0                  LDP1  ! @P_POOL$
         2 000007   100000 473700                    LDP3  ! 0,,PR1
         2 000010   300004 236300                    LDQ   ! 4,,PR3
         2 000011   000004 756200 0                  STQ   ! AV_HEAD$

      158       65    2             F = 0;

     65  2 000012   000010 450200 0                  STZ   ! F

      159       66
      160       67        /*
      161       68        Using a circular search (from LIST$HDR.ROVER$ to LIST$HDR.ROVER$) find a
      162       69        block that is big enough to satisfy the request.
      163       70        */
      164       71    3             DO WHILE (AV_HEAD$->BLK$HEAD.SIZE < REQSIZE);

     71  2 000013   000004 474600 0                  LDP4  ! AV_HEAD$
         2 000014   400001 236300                    LDQ   ! 1,,PR4
         2 000015   000011 116200 0                  CMPQ  ! REQSIZE
         2 000016   000041 605200 2                  TPL   ! A4

      165       72    3               IF AV_HEAD$ = LIST$HDR.ROVER$ THEN

     72  2 000017   000001 470600 0                  LDP0  ! @P_POOL$
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:25   
         2 000020   000000 471700                    LDP1  ! 0,,PR0
         2 000021   000004 236200 0                  LDQ   ! AV_HEAD$
         2 000022   100004 116300                    CMPQ  ! 4,,PR1
         2 000023   000032 601200 2                  TNZ   ! s:83

      166       73    4                 DO;

      167       74    4                   IF F = 0 THEN

     74  2 000024   000010 235200 0                  LDA   ! F
         2 000025   000031 601200 2                  TNZ   ! s:80

      168       75    5                     DO;

      169       76    5                       F = 1;

     76  2 000026   000001 235207                    LDA   ! 1,DL
         2 000027   000010 755200 0                  STA   ! F

      170       77    5                     END /* THEN DO */;

     77  2 000030   000032 710200 2                  TRA   ! s:83

      171       78    4                   ELSE
      172       79    5                     DO;

      173       80    5                       GOTO NO_SPACE;

     80  2 000031   000133 710200 2                  TRA   ! NO_SPACE

      174       81    5                     END /* ELSE DO */;
      175       82    4                 END /* THEN DO */;
      176       83    3               AV_HEAD$ = AV_HEAD$->BLK$HEAD.FLINK$;

     83  2 000032   000004 473600 0                  LDP3  ! AV_HEAD$
         2 000033   300002 236300                    LDQ   ! 2,,PR3
         2 000034   000004 756200 0                  STQ   ! AV_HEAD$
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:26   

      177       84    3             END /* DO WHILE */;

     84  2 000035   000004 473600 0                  LDP3  ! AV_HEAD$
         2 000036   300001 236300                    LDQ   ! 1,,PR3
         2 000037   000011 116200 0                  CMPQ  ! REQSIZE
         2 000040   000017 604200 2                  TMI   ! s:72

      178       85
      179       86    2   A4:
      180       87    2             LIST$HDR.ROVER$ = AV_HEAD$->BLK$HEAD.FLINK$;

     87  2 000041   000001 470600 0     A4           LDP0  ! @P_POOL$
         2 000042   000000 471700                    LDP1  ! 0,,PR0
         2 000043   000004 473600 0                  LDP3  ! AV_HEAD$
         2 000044   300002 236300                    LDQ   ! 2,,PR3
         2 000045   100004 756300                    STQ   ! 4,,PR1

      181       88    2             K = AV_HEAD$->BLK$HEAD.SIZE - REQSIZE;

     88  2 000046   300001 236300                    LDQ   ! 1,,PR3
         2 000047   000011 136200 0                  SBLQ  ! REQSIZE
         2 000050   000007 756200 0                  STQ   ! K

      182       89    2             IF K < C THEN

     89  2 000051   000000 116200 1                  CMPQ  ! C
         2 000052   000074 605200 2                  TPL   ! s:98

      183       90    3               DO;

      184       91    3                 AV_HEAD$->BLK$HEAD.BLINK$->BLK$HEAD.FLINK$ = LIST$HDR.ROVER$;

     91  2 000053   300003 471700                    LDP1  ! 3,,PR3
         2 000054   000000 474700                    LDP4  ! 0,,PR0
         2 000055   400004 236300                    LDQ   ! 4,,PR4
         2 000056   100002 756300                    STQ   ! 2,,PR1
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:27   

      185       92    3                 LIST$HDR.ROVER$->BLK$HEAD.BLINK$ = AV_HEAD$->BLK$HEAD.BLINK$;

     92  2 000057   000000 471700                    LDP1  ! 0,,PR0
         2 000060   100004 474700                    LDP4  ! 4,,PR1
         2 000061   300003 236300                    LDQ   ! 3,,PR3
         2 000062   400003 756300                    STQ   ! 3,,PR4

      186       93    3                 P_RESHEAD$ = AV_HEAD$;

     93  2 000063   000004 236200 0                  LDQ   ! AV_HEAD$
         2 000064   000003 471600 0                  LDP1  ! @P_RESHEAD$
         2 000065   100000 756300                    STQ   ! 0,,PR1

      187       94    3                 RES_TAIL$ = PINCRW(AV_HEAD$, (AV_HEAD$->BLK$HEAD.SIZE - (SIZEW(
                94                          BLK$TAIL))));

     94  2 000066   300001 236300                    LDQ   ! 1,,PR3
         2 000067   000022 736200                    QLS   ! 18
         2 000070   000002 136203                    SBLQ  ! 2,DU
         2 000071   000004 036200 0                  ADLQ  ! AV_HEAD$
         2 000072   000006 756200 0                  STQ   ! RES_TAIL$

      188       95    3               END /* THEN DO */;

     95  2 000073   000121 710200 2                  TRA   ! s:107

      189       96    2             ELSE
      190       97    3               DO;

      191       98    3                 P_RESHEAD$ = PINCRW(AV_HEAD$, K);

     98  2 000074   000022 736200                    QLS   ! 18
         2 000075   000004 036200 0                  ADLQ  ! AV_HEAD$
         2 000076   000003 471600 0                  LDP1  ! @P_RESHEAD$
         2 000077   100000 756300                    STQ   ! 0,,PR1

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:28   
      192       99    3                 AV_HEAD$->BLK$HEAD.SIZE = K;

     99  2 000100   000007 235200 0                  LDA   ! K
         2 000101   300001 755300                    STA   ! 1,,PR3

      193      100    3                 AV_TAIL$ = PINCRW(P_RESHEAD$, -(SIZEW(BLK$TAIL)));

    100  2 000102   100000 236300                    LDQ   ! 0,,PR1
         2 000103   777776 036203                    ADLQ  ! -2,DU
         2 000104   000005 756200 0                  STQ   ! AV_TAIL$

      194      101    3                 AV_TAIL$->BLK$TAIL.SIZE = K;

    101  2 000105   000005 474600 0                  LDP4  ! AV_TAIL$
         2 000106   400001 755300                    STA   ! 1,,PR4

      195      102    3                 AV_TAIL$->BLK$TAIL.TAG = %AVAILABLE;

    102  2 000107   000001 235207                    LDA   ! 1,DL
         2 000110   400000 755300                    STA   ! 0,,PR4

      196      103    3                 P_RESHEAD$->BLK$HEAD.SIZE = REQSIZE;

    103  2 000111   100000 475700                    LDP5  ! 0,,PR1
         2 000112   000011 235200 0                  LDA   ! REQSIZE
         2 000113   500001 755300                    STA   ! 1,,PR5

      197      104    3                 RES_TAIL$ = PINCRW(P_RESHEAD$, (REQSIZE - (SIZEW(BLK$TAIL))));

    104  2 000114   100000 475700                    LDP5  ! 0,,PR1
         2 000115   577776 636705                    EPPR6 ! -2,AL,PR5
         2 000116   000006 456600 0                  STP6  ! RES_TAIL$

      198      105    3                 RES_TAIL$->BLK$TAIL.SIZE = REQSIZE;

    105  2 000117   000011 235200 0                  LDA   ! REQSIZE
         2 000120   600001 755300                    STA   ! 1,,PR6
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:29   

      199      106    3               END /* ELSE DO */;

      200      107    2             P_RESHEAD$->BLK$HEAD.TAG = %UNAVAILABLE;

    107  2 000121   100000 474700                    LDP4  ! 0,,PR1
         2 000122   000001 335207                    LCA   ! 1,DL
         2 000123   400000 755300                    STA   ! 0,,PR4

      201      108    2             RES_TAIL$->BLK$TAIL.TAG = %UNAVAILABLE;

    108  2 000124   000006 474600 0                  LDP4  ! RES_TAIL$
         2 000125   400000 755300                    STA   ! 0,,PR4

      202      109
      203      110    2             P_RESHEAD$ = PINCRW(P_RESHEAD$, (SIZEW(BLK$HEAD)));

    110  2 000126   100000 236300                    LDQ   ! 0,,PR1
         2 000127   000004 036203                    ADLQ  ! 4,DU
         2 000130   100000 756300                    STQ   ! 0,,PR1

      204      111
      205      112    2             RETURN;

    112  2 000131   000000 221200 0                  LDX1  ! 0
         2 000132   000001 702211                    TSX2  ! 1,X1

      206      113    2           END /* INHIBIT */;

      207      114
      208      115    1   NO_SPACE:
      209      116    1           P_RESHEAD$ = ADDR(NIL);

    116  2 000133   000001 236000 xsym  NO_SPACE     LDQ     B_VECTNIL+1
         2 000134   000003 471400 0                  LDP1    @P_RESHEAD$
         2 000135   100000 756100                    STQ     0,,PR1

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:30   
      210      117    1           ALTRETURN;

    117  2 000136   000000 221200 0                  LDX1  ! 0
         2 000137   000000 702211                    TSX2  ! 0,X1
      211      118
      212      119    1   END QQC$GET_BLK;
      213      120        %EOD;

PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:31   
      No diagnostics issued in procedure QQC$GET_BLK.
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:32   

 **** Variables and constants ****

  ****  Section 000  Data  QQC$GET_BLK

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     2-0-0/w PTR         r     1 @P_ACT_REQSIZE             1-0-0/w PTR         r     1 @P_POOL$
     3-0-0/w PTR         r     1 @P_RESHEAD$                4-0-0/w PTR         r     1 AV_HEAD$
     5-0-0/w PTR         r     1 AV_TAIL$                  10-0-0/w SBIN        r     1 F
     7-0-0/w SBIN        r     1 K                         *0-0-0/w SBIN        r     1 P_ACT_REQSIZE
    *0-0-0/w PTR         r     1 P_POOL$                   *0-0-0/w PTR         r     1 P_RESHEAD$
    11-0-0/w SBIN        r     1 REQSIZE                    6-0-0/w PTR         r     1 RES_TAIL$

  ****  Section 001 RoData QQC$GET_BLK

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w SBIN        r     1 C

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 BLK$HEAD                   0-0-0/w STRC(72)    r     1 BLK$TAIL
     0-0-0/w STRC(180)   r     1 LIST$HDR


   Procedure QQC$GET_BLK requires 96 words for executable code.
   Procedure QQC$GET_BLK is declared NOAUTO and requires 10 words of local(STATIC) storage.
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:33   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:34   
          MINI XREF LISTING

AV_HEAD$
        49**DCL        64<<ASSIGN     71>>DOWHILE    72>>IF         83<<ASSIGN     83>>ASSIGN     87>>ASSIGN
        88>>ASSIGN     91>>ASSIGN     92>>ASSIGN     93>>ASSIGN     94>>ASSIGN     94>>ASSIGN     98>>ASSIGN
        99>>ASSIGN
AV_TAIL$
        50**DCL       100<<ASSIGN    101>>ASSIGN    102>>ASSIGN
BLK$HEAD
        35**DCL        63--ASSIGN    110--ASSIGN
BLK$HEAD.BLINK$
        39**DCL        91>>ASSIGN     92<<ASSIGN     92>>ASSIGN
BLK$HEAD.FLINK$
        38**DCL        83>>ASSIGN     87>>ASSIGN     91<<ASSIGN
BLK$HEAD.SIZE
        37**DCL        71>>DOWHILE    88>>ASSIGN     94>>ASSIGN     99<<ASSIGN    103<<ASSIGN
BLK$HEAD.TAG
        36**DCL       107<<ASSIGN
BLK$TAIL
        41**DCL        63--ASSIGN     94--ASSIGN    100--ASSIGN    104--ASSIGN
BLK$TAIL.SIZE
        43**DCL       101<<ASSIGN    105<<ASSIGN
BLK$TAIL.TAG
        42**DCL       102<<ASSIGN    108<<ASSIGN
C
        53**DCL        89>>IF
F
        54**DCL        65<<ASSIGN     74>>IF         76<<ASSIGN
K
        52**DCL        88<<ASSIGN     89>>IF         98>>ASSIGN     99>>ASSIGN    101>>ASSIGN
LIST$HDR.ROVER$
        33**DCL        64>>ASSIGN     72>>IF         87<<ASSIGN     91>>ASSIGN     92>>ASSIGN
NO_SPACE
       116**LABEL      80--GOTO
PL6.E3A0      #002=QQC$GET_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:35   
P_ACT_REQSIZE
        47**DCL         6--PROC       63>>ASSIGN
P_POOL$
        45**DCL         6--PROC       28--IMP-PTR    64>>ASSIGN     72>>IF         87>>ASSIGN     91>>ASSIGN
        92>>ASSIGN
P_RESHEAD$
        46**DCL         6--PROC       93<<ASSIGN     98<<ASSIGN    100>>ASSIGN    103>>ASSIGN    104>>ASSIGN
       107>>ASSIGN    110<<ASSIGN    110>>ASSIGN    116<<ASSIGN
REQSIZE
        55**DCL        63<<ASSIGN     71>>DOWHILE    88>>ASSIGN    103>>ASSIGN    104>>ASSIGN    105>>ASSIGN
RES_TAIL$
        51**DCL        94<<ASSIGN    104<<ASSIGN    105>>ASSIGN    108>>ASSIGN

PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:36   
      214        1        /*T***********************************************************/
      215        2        /*T*                                                         */
      216        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      217        4        /*T*                                                         */
      218        5        /*T***********************************************************/
      219        6        QQC$RLS_BLK: PROC (P_POOL$, P_BLK2RLS$) NOAUTO;
      220        7
      221        8        /*F*     NAME:  QQC$RLS_BLK
      222        9                      RLS_BLK may be called to release a block of memory
      223       10                      previously reserved by GET_BLK. */
      224       11        /*D*     NAME:  QQC$RLS_BLK
      225       12                      RLS_BLK expects two parameters.  The first parameter
      226       13                      must be a pointer to the pool to which the block is
      227       14                      to be returned.  The second parameter is a pointer
      228       15                      to the block to release. */
      229       16
      230       17    1   DCL 1 LIST$HDR BASED(P_POOL$),
      231       18    1         2 TAG SBIN WORD,
      232       19    1         2 SIZE SBIN WORD,
      233       20    1         2 FLINK$ PTR,                     /* AVAIL$                             */
      234       21    1         2 BLINK$ PTR,
      235       22    1         2 ROVER$ PTR;                /* A roving pointer to available blocks    */
      236       23
      237       24    1   DCL 1 BLK$HEAD BASED,
      238       25    1         2 TAG SBIN WORD,
      239       26    1         2 SIZE SBIN WORD,
      240       27    1         2 FLINK$ PTR,
      241       28    1         2 BLINK$ PTR;
      242       29
      243       30    1   DCL 1 BLK$TAIL BASED,
      244       31    1         2 TAG SBIN WORD,
      245       32    1         2 SIZE SBIN WORD;
      246       33
      247       34    1   DCL P_POOL$ PTR;                   /* Points to the first available block     */
      248       35    1   DCL P_BLK2RLS$ PTR;                /* Parameter, points to blk to release     */
      249       36
      250       37    1   DCL BLK2RLS_H$ PTR STATIC;/* Points to the actual head of the block to release */
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:37   
      251       38    1   DCL BLK2RLS_T$ PTR STATIC;/* Points to the tail of the block we are releasing */
      252       39    1   DCL NEXTBLK_H$ PTR STATIC;/* Points to the head of the next adjacent block    */
      253       40    1   DCL PREVBLK_T$ PTR STATIC;/* Points to the tail of the preceding adjacent block */
      254       41    1   DCL S_FLINK$ PTR STATIC;                /* A scratch used to hold a FLINK     */
      255       42    1   DCL S_BLINK$ PTR STATIC;                /* A scratch used to hold a BLINK     */
      256       43    1   DCL S_SIZE SBIN WORD STATIC;       /* A scratch used to hold a computed size  */
      257       44
      258       45        /*
      259       46        The following diagram may assist in understanding the code
      260       47        that follows.
      261       48
      262       49            |     PREVBLK       |      BLK2RLS      |      NEXTBLK      |
      263       50            |----|---------|----|----|---------|----|----|---------|----|
      264       51            |    |         |    |    |         |    |    |         |    |
      265       52            |----|---------|----|----|---------|----|----|---------|----|
      266       53            | |               | | |               | | |               | |
      267       54            | |->BLK$HEAD     | | |->BLK$HEAD     | | |->BLK$HEAD     | |
      268       55            |       BLK$TAIL<-| |       BLK$TAIL<-| |       BLK$TAIL<-| |
      269       56        */
      270       57
      271       58        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
      272       59
      273       60        %EJECT;
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:38   
      274       61    1   BEGIN:
      275       62
      276       63    2           DO INHIBIT;
      277       64    2             BLK2RLS_H$ = PINCRW(P_BLK2RLS$, -(SIZEW(BLK$HEAD))); /* Back to tags */
      278       65    2             S_SIZE = BLK2RLS_H$->BLK$HEAD.SIZE;
      279       66    2             NEXTBLK_H$ = PINCRW(BLK2RLS_H$, S_SIZE);
      280       67    2             PREVBLK_T$ = PINCRW(BLK2RLS_H$, -(SIZEW(BLK$TAIL)));
      281       68
      282       69    2             IF NEXTBLK_H$->BLK$HEAD.TAG = %AVAILABLE THEN
      283       70    3               DO;
      284       71    3                 S_SIZE = S_SIZE + NEXTBLK_H$->BLK$HEAD.SIZE;
      285       72    3                 S_FLINK$ = NEXTBLK_H$->BLK$HEAD.FLINK$;
      286       73    3                 S_BLINK$ = NEXTBLK_H$->BLK$HEAD.BLINK$;
      287       74    3                 IF NEXTBLK_H$ = LIST$HDR.ROVER$ THEN
      288       75    3                   LIST$HDR.ROVER$ = ADDR(LIST$HDR);
      289       76    3                 NEXTBLK_H$ = PINCRW(NEXTBLK_H$, NEXTBLK_H$->BLK$HEAD.SIZE);
      290       77    3                 IF PREVBLK_T$->BLK$TAIL.TAG = %AVAILABLE THEN
      291       78    4                   DO;
      292       79    4                     S_BLINK$->BLK$HEAD.FLINK$ = S_FLINK$;
      293       80    4                     S_FLINK$->BLK$HEAD.BLINK$ = S_BLINK$;
      294       81    4                     GOTO PREV_AVAIL;
      295       82    4                   END /* THEN DO */;
      296       83    3                 ELSE
      297       84    3                   GOTO PREV_UNAV;         /* PREVBLK IS UNAVAILABLE             */
      298       85    3               END /* THEN DO */;
      299       86
      300       87    2   NEXT_UNAV:
      301       88    2             IF PREVBLK_T$->BLK$TAIL.TAG = %AVAILABLE THEN
      302       89    2               GOTO PREV_AVAIL;
      303       90
      304       91    2   BOTH_UNAV:
      305       92    2             S_FLINK$ = LIST$HDR.FLINK$;   /* AVAIL$                             */
      306       93    2             S_BLINK$ = ADDR(LIST$HDR);
      307       94
      308       95    2   PREV_UNAV:
      309       96    2             BLK2RLS_H$->BLK$HEAD.FLINK$ = S_FLINK$;
      310       97    2             BLK2RLS_H$->BLK$HEAD.BLINK$ = S_BLINK$;
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:39   
      311       98    2             S_FLINK$->BLK$HEAD.BLINK$ = BLK2RLS_H$;
      312       99    2             S_BLINK$->BLK$HEAD.FLINK$ = BLK2RLS_H$;
      313      100    2             GOTO FINISH_UP;
      314      101
      315      102    2   PREV_AVAIL:
      316      103    2             S_SIZE = S_SIZE + PREVBLK_T$->BLK$TAIL.SIZE;
      317      104    2             BLK2RLS_H$ = PINCRW(BLK2RLS_H$, -(PREVBLK_T$->BLK$TAIL.SIZE));
      318      105
      319      106    2   FINISH_UP:
      320      107    2             BLK2RLS_H$->BLK$HEAD.SIZE = S_SIZE;
      321      108    2             BLK2RLS_H$->BLK$HEAD.TAG = %AVAILABLE;
      322      109    2             BLK2RLS_T$ = PINCRW(NEXTBLK_H$, -(SIZEW(BLK$TAIL)));
      323      110    2             BLK2RLS_T$->BLK$TAIL.SIZE = S_SIZE;
      324      111    2             BLK2RLS_T$->BLK$TAIL.TAG = %AVAILABLE;
      325      112
      326      113    2             RETURN;
      327      114    2           END /* INHIBIT */;
      328      115    1   END QQC$RLS_BLK;

PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:40   
      No diagnostics issued in procedure QQC$RLS_BLK.

   Procedure QQC$RLS_BLK requires 93 words for executable code.
   Procedure QQC$RLS_BLK is declared NOAUTO and requires 10 words of local(STATIC) storage.

    No errors detected in file QQC$BLKMGR.:E05TSI    .

PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:41   

 Object Unit name= QQC$RLS_BLK                                File name= QQC$BLKMGR.:E05TOU
 UTS= JUL 30 '97 05:39:06.24 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Data  even  none    10     12  QQC$RLS_BLK
    1   Proc  even  none    93    135  QQC$RLS_BLK

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes            yes      Std        2  QQC$RLS_BLK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
                       nStd      0 X66_STATIC_2
                       Std       0 B_CONSPOOL_D

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:42   


      214        1        /*T***********************************************************/
      215        2        /*T*                                                         */
      216        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      217        4        /*T*                                                         */
      218        5        /*T***********************************************************/
      219        6        QQC$RLS_BLK: PROC (P_POOL$, P_BLK2RLS$) NOAUTO;

      6  1 000000   000000 700200 xent  QQC$RLS_BLK  TSX0  ! X66_STATIC_2
         1 000001   000000 000002 0                  ZERO    0,2

      220        7
      221        8        /*F*     NAME:  QQC$RLS_BLK
      222        9                      RLS_BLK may be called to release a block of memory
      223       10                      previously reserved by GET_BLK. */
      224       11        /*D*     NAME:  QQC$RLS_BLK
      225       12                      RLS_BLK expects two parameters.  The first parameter
      226       13                      must be a pointer to the pool to which the block is
      227       14                      to be returned.  The second parameter is a pointer
      228       15                      to the block to release. */
      229       16
      230       17    1   DCL 1 LIST$HDR BASED(P_POOL$),
      231       18    1         2 TAG SBIN WORD,
      232       19    1         2 SIZE SBIN WORD,
      233       20    1         2 FLINK$ PTR,                     /* AVAIL$                             */
      234       21    1         2 BLINK$ PTR,
      235       22    1         2 ROVER$ PTR;                /* A roving pointer to available blocks    */
      236       23
      237       24    1   DCL 1 BLK$HEAD BASED,
      238       25    1         2 TAG SBIN WORD,
      239       26    1         2 SIZE SBIN WORD,
      240       27    1         2 FLINK$ PTR,
      241       28    1         2 BLINK$ PTR;
      242       29
      243       30    1   DCL 1 BLK$TAIL BASED,
      244       31    1         2 TAG SBIN WORD,
      245       32    1         2 SIZE SBIN WORD;
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:43   
      246       33
      247       34    1   DCL P_POOL$ PTR;                   /* Points to the first available block     */
      248       35    1   DCL P_BLK2RLS$ PTR;                /* Parameter, points to blk to release     */
      249       36
      250       37    1   DCL BLK2RLS_H$ PTR STATIC;/* Points to the actual head of the block to release */
      251       38    1   DCL BLK2RLS_T$ PTR STATIC;/* Points to the tail of the block we are releasing */
      252       39    1   DCL NEXTBLK_H$ PTR STATIC;/* Points to the head of the next adjacent block    */
      253       40    1   DCL PREVBLK_T$ PTR STATIC;/* Points to the tail of the preceding adjacent block */
      254       41    1   DCL S_FLINK$ PTR STATIC;                /* A scratch used to hold a FLINK     */
      255       42    1   DCL S_BLINK$ PTR STATIC;                /* A scratch used to hold a BLINK     */
      256       43    1   DCL S_SIZE SBIN WORD STATIC;       /* A scratch used to hold a computed size  */
      257       44
      258       45        /*
      259       46        The following diagram may assist in understanding the code
      260       47        that follows.
      261       48
      262       49            |     PREVBLK       |      BLK2RLS      |      NEXTBLK      |
      263       50            |----|---------|----|----|---------|----|----|---------|----|
      264       51            |    |         |    |    |         |    |    |         |    |
      265       52            |----|---------|----|----|---------|----|----|---------|----|
      266       53            | |               | | |               | | |               | |
      267       54            | |->BLK$HEAD     | | |->BLK$HEAD     | | |->BLK$HEAD     | |
      268       55            |       BLK$TAIL<-| |       BLK$TAIL<-| |       BLK$TAIL<-| |
      269       56        */
      270       57
      271       58        %EQU AVAILABLE = CHARTEXT('1 /* AVAILABLE */');
      272       59
      273       60        %EJECT;
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:44   
      274       61    1   BEGIN:
      275       62
      276       63    2           DO INHIBIT;

     63  1 000002                       BEGIN        null
      277       64    2             BLK2RLS_H$ = PINCRW(P_BLK2RLS$, -(SIZEW(BLK$HEAD))); /* Back to tags */

     64  1 000002   000002 470600 0                  LDP0  ! @P_BLK2RLS$
         1 000003   000000 236300                    LDQ   ! 0,,PR0
         1 000004   777774 036203                    ADLQ  ! -4,DU
         1 000005   000003 756200 0                  STQ   ! BLK2RLS_H$

      278       65    2             S_SIZE = BLK2RLS_H$->BLK$HEAD.SIZE;

     65  1 000006   000003 471600 0                  LDP1  ! BLK2RLS_H$
         1 000007   100001 235300                    LDA   ! 1,,PR1
         1 000010   000011 755200 0                  STA   ! S_SIZE

      279       66    2             NEXTBLK_H$ = PINCRW(BLK2RLS_H$, S_SIZE);

     66  1 000011   000011 236200 0                  LDQ   ! S_SIZE
         1 000012   000022 736200                    QLS   ! 18
         1 000013   000003 036200 0                  ADLQ  ! BLK2RLS_H$
         1 000014   000005 756200 0                  STQ   ! NEXTBLK_H$

      280       67    2             PREVBLK_T$ = PINCRW(BLK2RLS_H$, -(SIZEW(BLK$TAIL)));

     67  1 000015   000003 236200 0                  LDQ   ! BLK2RLS_H$
         1 000016   777776 036203                    ADLQ  ! -2,DU
         1 000017   000006 756200 0                  STQ   ! PREVBLK_T$

      281       68
      282       69    2             IF NEXTBLK_H$->BLK$HEAD.TAG = %AVAILABLE THEN

     69  1 000020   000005 473600 0                  LDP3  ! NEXTBLK_H$
         1 000021   300000 235300                    LDA   ! 0,,PR3
         1 000022   000001 115207                    CMPA  ! 1,DL
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:45   
         1 000023   000060 601200 1                  TNZ   ! NEXT_UNAV

      283       70    3               DO;

      284       71    3                 S_SIZE = S_SIZE + NEXTBLK_H$->BLK$HEAD.SIZE;

     71  1 000024   000011 236200 0                  LDQ   ! S_SIZE
         1 000025   300001 036300                    ADLQ  ! 1,,PR3
         1 000026   000011 756200 0                  STQ   ! S_SIZE

      285       72    3                 S_FLINK$ = NEXTBLK_H$->BLK$HEAD.FLINK$;

     72  1 000027   300002 236300                    LDQ   ! 2,,PR3
         1 000030   000007 756200 0                  STQ   ! S_FLINK$

      286       73    3                 S_BLINK$ = NEXTBLK_H$->BLK$HEAD.BLINK$;

     73  1 000031   300003 236300                    LDQ   ! 3,,PR3
         1 000032   000010 756200 0                  STQ   ! S_BLINK$

      287       74    3                 IF NEXTBLK_H$ = LIST$HDR.ROVER$ THEN

     74  1 000033   000001 474600 0                  LDP4  ! @P_POOL$
         1 000034   400000 475700                    LDP5  ! 0,,PR4
         1 000035   000005 236200 0                  LDQ   ! NEXTBLK_H$
         1 000036   500004 116300                    CMPQ  ! 4,,PR5
         1 000037   000041 601200 1                  TNZ   ! s:76

      288       75    3                   LIST$HDR.ROVER$ = ADDR(LIST$HDR);

     75  1 000040   500004 455700                    STP5  ! 4,,PR5

      289       76    3                 NEXTBLK_H$ = PINCRW(NEXTBLK_H$, NEXTBLK_H$->BLK$HEAD.SIZE);

     76  1 000041   300001 236300                    LDQ   ! 1,,PR3
         1 000042   000022 736200                    QLS   ! 18
         1 000043   000005 036200 0                  ADLQ  ! NEXTBLK_H$
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:46   
         1 000044   000005 756200 0                  STQ   ! NEXTBLK_H$

      290       77    3                 IF PREVBLK_T$->BLK$TAIL.TAG = %AVAILABLE THEN

     77  1 000045   000006 473600 0                  LDP3  ! PREVBLK_T$
         1 000046   300000 235300                    LDA   ! 0,,PR3
         1 000047   000001 115207                    CMPA  ! 1,DL
         1 000050   000071 601200 1                  TNZ   ! PREV_UNAV

      291       78    4                   DO;

      292       79    4                     S_BLINK$->BLK$HEAD.FLINK$ = S_FLINK$;

     79  1 000051   000007 236200 0                  LDQ   ! S_FLINK$
         1 000052   000010 475600 0                  LDP5  ! S_BLINK$
         1 000053   500002 756300                    STQ   ! 2,,PR5

      293       80    4                     S_FLINK$->BLK$HEAD.BLINK$ = S_BLINK$;

     80  1 000054   000010 236200 0                  LDQ   ! S_BLINK$
         1 000055   000007 476600 0                  LDP6  ! S_FLINK$
         1 000056   600003 756300                    STQ   ! 3,,PR6

      294       81    4                     GOTO PREV_AVAIL;

     81  1 000057   000103 710200 1                  TRA   ! PREV_AVAIL

      295       82    4                   END /* THEN DO */;
      296       83    3                 ELSE
      297       84    3                   GOTO PREV_UNAV;         /* PREVBLK IS UNAVAILABLE             */
      298       85    3               END /* THEN DO */;
      299       86
      300       87    2   NEXT_UNAV:
      301       88    2             IF PREVBLK_T$->BLK$TAIL.TAG = %AVAILABLE THEN

     88  1 000060   000006 474600 0     NEXT_UNAV    LDP4  ! PREVBLK_T$
         1 000061   400000 235300                    LDA   ! 0,,PR4
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:47   
         1 000062   000001 115207                    CMPA  ! 1,DL
         1 000063   000103 600200 1                  TZE   ! PREV_AVAIL

      302       89    2               GOTO PREV_AVAIL;
      303       90
      304       91    2   BOTH_UNAV:
      305       92    2             S_FLINK$ = LIST$HDR.FLINK$;   /* AVAIL$                             */

     92  1 000064   000001 475600 0     BOTH_UNAV    LDP5  ! @P_POOL$
         1 000065   500000 476700                    LDP6  ! 0,,PR5
         1 000066   600002 236300                    LDQ   ! 2,,PR6
         1 000067   000007 756200 0                  STQ   ! S_FLINK$

      306       93    2             S_BLINK$ = ADDR(LIST$HDR);

     93  1 000070   000010 456600 0                  STP6  ! S_BLINK$

      307       94
      308       95    2   PREV_UNAV:
      309       96    2             BLK2RLS_H$->BLK$HEAD.FLINK$ = S_FLINK$;

     96  1 000071   000007 236200 0     PREV_UNAV    LDQ   ! S_FLINK$
         1 000072   100002 756300                    STQ   ! 2,,PR1

      310       97    2             BLK2RLS_H$->BLK$HEAD.BLINK$ = S_BLINK$;

     97  1 000073   000010 236200 0                  LDQ   ! S_BLINK$
         1 000074   100003 756300                    STQ   ! 3,,PR1

      311       98    2             S_FLINK$->BLK$HEAD.BLINK$ = BLK2RLS_H$;

     98  1 000075   000003 236200 0                  LDQ   ! BLK2RLS_H$
         1 000076   000007 473600 0                  LDP3  ! S_FLINK$
         1 000077   300003 756300                    STQ   ! 3,,PR3

      312       99    2             S_BLINK$->BLK$HEAD.FLINK$ = BLK2RLS_H$;

PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:48   
     99  1 000100   000010 474600 0                  LDP4  ! S_BLINK$
         1 000101   400002 756300                    STQ   ! 2,,PR4

      313      100    2             GOTO FINISH_UP;

    100  1 000102   000115 710200 1                  TRA   ! FINISH_UP

      314      101
      315      102    2   PREV_AVAIL:
      316      103    2             S_SIZE = S_SIZE + PREVBLK_T$->BLK$TAIL.SIZE;

    103  1 000103   000006 473600 0     PREV_AVAIL   LDP3  ! PREVBLK_T$
         1 000104   000011 236200 0                  LDQ   ! S_SIZE
         1 000105   300001 036300                    ADLQ  ! 1,,PR3
         1 000106   000011 756200 0                  STQ   ! S_SIZE

      317      104    2             BLK2RLS_H$ = PINCRW(BLK2RLS_H$, -(PREVBLK_T$->BLK$TAIL.SIZE));

    104  1 000107   300001 236300                    LDQ   ! 1,,PR3
         1 000110   000022 736200                    QLS   ! 18
         1 000111   000027 676200 xsym               ERQ   ! B_VECTNIL+23
         1 000112   000001 036207                    ADLQ  ! 1,DL
         1 000113   000003 036200 0                  ADLQ  ! BLK2RLS_H$
         1 000114   000003 756200 0                  STQ   ! BLK2RLS_H$

      318      105
      319      106    2   FINISH_UP:
      320      107    2             BLK2RLS_H$->BLK$HEAD.SIZE = S_SIZE;

    107  1 000115   000003 471600 0     FINISH_UP    LDP1  ! BLK2RLS_H$
         1 000116   000011 235200 0                  LDA   ! S_SIZE
         1 000117   100001 755300                    STA   ! 1,,PR1

      321      108    2             BLK2RLS_H$->BLK$HEAD.TAG = %AVAILABLE;

    108  1 000120   000001 235207                    LDA   ! 1,DL
         1 000121   100000 755300                    STA   ! 0,,PR1
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:49   

      322      109    2             BLK2RLS_T$ = PINCRW(NEXTBLK_H$, -(SIZEW(BLK$TAIL)));

    109  1 000122   000005 236200 0                  LDQ   ! NEXTBLK_H$
         1 000123   777776 036203                    ADLQ  ! -2,DU
         1 000124   000004 756200 0                  STQ   ! BLK2RLS_T$

      323      110    2             BLK2RLS_T$->BLK$TAIL.SIZE = S_SIZE;

    110  1 000125   000004 473600 0                  LDP3  ! BLK2RLS_T$
         1 000126   000011 235200 0                  LDA   ! S_SIZE
         1 000127   300001 755300                    STA   ! 1,,PR3

      324      111    2             BLK2RLS_T$->BLK$TAIL.TAG = %AVAILABLE;

    111  1 000130   000001 235207                    LDA   ! 1,DL
         1 000131   300000 755300                    STA   ! 0,,PR3

      325      112
      326      113    2             RETURN;

    113  1 000132   000000 221200 0                  LDX1  ! 0
         1 000133   000001 702211                    TSX2  ! 1,X1

      327      114    2           END /* INHIBIT */;

      328      115    1   END QQC$RLS_BLK;

    115  1 000134   000001 702211                    TSX2  ! 1,X1

PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:50   
      No diagnostics issued in procedure QQC$RLS_BLK.
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:51   

 **** Variables and constants ****

  ****  Section 000  Data  QQC$RLS_BLK

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     2-0-0/w PTR         r     1 @P_BLK2RLS$                1-0-0/w PTR         r     1 @P_POOL$
     3-0-0/w PTR         r     1 BLK2RLS_H$                 4-0-0/w PTR         r     1 BLK2RLS_T$
     5-0-0/w PTR         r     1 NEXTBLK_H$                 6-0-0/w PTR         r     1 PREVBLK_T$
    *0-0-0/w PTR         r     1 P_BLK2RLS$                *0-0-0/w PTR         r     1 P_POOL$
    10-0-0/w PTR         r     1 S_BLINK$                   7-0-0/w PTR         r     1 S_FLINK$
    11-0-0/w SBIN        r     1 S_SIZE

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(144)   r     1 BLK$HEAD                   0-0-0/w STRC(72)    r     1 BLK$TAIL
     0-0-0/w STRC(180)   r     1 LIST$HDR


   Procedure QQC$RLS_BLK requires 93 words for executable code.
   Procedure QQC$RLS_BLK is declared NOAUTO and requires 10 words of local(STATIC) storage.

    No errors detected in file QQC$BLKMGR.:E05TSI    .
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:52   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:53   
          MINI XREF LISTING

BLK$HEAD
        24**DCL        64--ASSIGN
BLK$HEAD.BLINK$
        28**DCL        73>>ASSIGN     80<<ASSIGN     97<<ASSIGN     98<<ASSIGN
BLK$HEAD.FLINK$
        27**DCL        72>>ASSIGN     79<<ASSIGN     96<<ASSIGN     99<<ASSIGN
BLK$HEAD.SIZE
        26**DCL        65>>ASSIGN     71>>ASSIGN     76>>ASSIGN    107<<ASSIGN
BLK$HEAD.TAG
        25**DCL        69>>IF        108<<ASSIGN
BLK$TAIL
        30**DCL        67--ASSIGN    109--ASSIGN
BLK$TAIL.SIZE
        32**DCL       103>>ASSIGN    104>>ASSIGN    110<<ASSIGN
BLK$TAIL.TAG
        31**DCL        77>>IF         88>>IF        111<<ASSIGN
BLK2RLS_H$
        37**DCL        64<<ASSIGN     65>>ASSIGN     66>>ASSIGN     67>>ASSIGN     96>>ASSIGN     97>>ASSIGN
        98>>ASSIGN     99>>ASSIGN    104<<ASSIGN    104>>ASSIGN    107>>ASSIGN    108>>ASSIGN
BLK2RLS_T$
        38**DCL       109<<ASSIGN    110>>ASSIGN    111>>ASSIGN
FINISH_UP
       107**LABEL     100--GOTO
LIST$HDR
        17**DCL        75--ASSIGN     93--ASSIGN
LIST$HDR.FLINK$
        20**DCL        92>>ASSIGN
LIST$HDR.ROVER$
        22**DCL        74>>IF         75<<ASSIGN
NEXTBLK_H$
        39**DCL        66<<ASSIGN     69>>IF         71>>ASSIGN     72>>ASSIGN     73>>ASSIGN     74>>IF
        76<<ASSIGN     76>>ASSIGN     76>>ASSIGN    109>>ASSIGN
PL6.E3A0      #003=QQC$RLS_BLK File=QQC$BLKMGR.:E05TSI                           WED 07/30/97 05:39 Page:54   
PREVBLK_T$
        40**DCL        67<<ASSIGN     77>>IF         88>>IF        103>>ASSIGN    104>>ASSIGN
PREV_AVAIL
       103**LABEL      81--GOTO       89--GOTO
PREV_UNAV
        96**LABEL      84--GOTO
P_BLK2RLS$
        35**DCL         6--PROC       64>>ASSIGN
P_POOL$
        34**DCL         6--PROC       17--IMP-PTR    74>>IF         75>>ASSIGN     75>>ASSIGN     92>>ASSIGN
        93>>ASSIGN
S_BLINK$
        42**DCL        73<<ASSIGN     79>>ASSIGN     80>>ASSIGN     93<<ASSIGN     97>>ASSIGN     99>>ASSIGN
S_FLINK$
        41**DCL        72<<ASSIGN     79>>ASSIGN     80>>ASSIGN     92<<ASSIGN     96>>ASSIGN     98>>ASSIGN
S_SIZE
        43**DCL        65<<ASSIGN     66>>ASSIGN     71<<ASSIGN     71>>ASSIGN    103<<ASSIGN    103>>ASSIGN
       107>>ASSIGN    110>>ASSIGN
