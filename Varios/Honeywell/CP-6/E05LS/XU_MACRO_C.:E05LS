

15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      1    
    1      /*M* XU_MACRO_C - MACROS DEFINING COMMON LIBRARY PARAMETERS */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      %MACRO P_PCB(NAME=P_PCB,
    9                   STCLASS="STATIC SYMDEF",
   10                   T=NIL,
   11                   R=NIL,
   12                   W=NIL,
   13                   U$=NIL,
   14                   WSZ=0,
   15                   C(YES='1'B,NO='0'B)='1'B,
   16                   N#=0,
   17                   C_LD=' "',
   18                   C_TL=' "',
   19                   CNTU(YES='1'B,NO='0'B)='1'B,
   20                   NBL(YES='1'B,NO='0'B)='0'B,
   21                   NX(YES='1'B,NO='0'B)='0'B,
   22                   DYNAMIC(YES='1'B,NO='0'B)='0'B,
   23                   KEYSCAN(YES='1'B,NO='0'B)='0'B,
   24                   OUTDCB=NIL,
   25                   USERPTR=NIL,
   26                   OUTENT=NIL);
   27
   28      /*F*  NAME:     P_PCB
   29            FUNCTION: Parse Control Block.  This structure is used to pass data
   30                to the X$PARSE utility, and to receive X$PARSE's responses.
   31      */
   32       %LSET LISTDIR='0'B;
   33       %LSET LISTEXP='1'B;
   34       %LSET LISTCOM='0'B;
   35       %LSET LISTSUB='1'B;
   36       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
   37       %IF (SUBSTR(STR,0,6)='STATIC') OR
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      2    
   38       (SUBSTR(STR,0,8)='CONSTANT') OR
   39       (SUBSTR(STR,0,3)='EXT');
   40       %LSET INIT=CHARTEXT('INIT');
   41       %ELSE;
   42       %LSET INIT=CHARTEXT('/*');
   43       %ENDIF;
   44       %LSET ENDINIT=CHARTEXT(CONCAT('/**','/'));
   45
   46      DCL 1 NAME STCLASS ALIGNED,
   47            2 TEXT$ PTR %INIT(ADDR(T))%ENDINIT,
   48      /*K* TEXT$ - Points to the beginning of the buffer which contains the
   49                text to be parsed.
   50      */
   51            2 ROOT$ PTR %INIT(ADDR(R))%ENDINIT,
   52      /*K* ROOT$ - Points to the root of the tree of nodes (built by PARTRGE)
   53                which describes the format of the commands(s) being parsed.
   54      */
   55            2 WORK$ PTR %INIT(ADDR(W))%ENDINIT,
   56      /*K* WORK$ - Points to the beginning of the "work area" somewhere in
   57                the user's memory.
   58      */
   59            2 OUT$ PTR %INIT(ADDR(NIL))%ENDINIT,
   60      /*K* OUT$ - Upon a successful return from X$PARSE, OUT$ points to the
   61                root of a tree of blocks built by the parser, which contain
   62                the result of the parsing operation.
   63      */
   64            2 U$$ EPTR %INIT(ENTADDR(U$))%ENDINIT,
   65      /*K* U$$ - A PL-6 "EPTR" variable passed to X$PARSE;  should contain the
   66                ENTADDR of a user-supplied subroutine.  X$PARSE will call
   67                the user's routine through this EPTR to handle command
   68                continuation, mid-parse intervention, and work-area expansion.
   69                .cba
   70                X$PARSE uses the following call to enter the user-supplied
   71                subroutine:
   72
   73                CALL p_pcb.U$$ ( parse_param );
   74
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      3    
   75                where parse_param is a PARSE$PARAM parameter block.
   76                .cbf
   77      */
   78            2 WKSZ UBIN(18) UNAL %INIT(WSZ)%ENDINIT,
   79      /*K* WKSZ - When X$PARSE is called, WKSZ must contain the number of words
   80                of workspace available to X$PARSE (starting at the location
   81                pointed to by P_PCB.WORK$).
   82      */
   83            2 CMPRS BIT(1) UNAL %INIT(C)%ENDINIT,
   84      /*K* CMPRS - A boolean [BIT(1)] variable, which indicates whether
   85                X$PARSE should "compress" the tree of blocks it builds by
   86                collapsing "temporary" blocks.  The default is to compress the
   87                tree.
   88      */
   89            2 CONTINUE BIT(1) UNAL %INIT(CNTU)%ENDINIT,
   90      /*K* CONTINUE - A boolean [BIT(1)] variable which indicates whether or not the
   91                user wishes the parser to handle "continued" commands.
   92      */
   93            2 NOLEADBLANKS BIT(1) UNAL %INIT(NBL)%ENDINIT,
   94      /*K* NOLEADBLANKS - A boolean variable which indicates whether the parser is to
   95                permit commands to have leading blanks (and/or comments) before
   96                the first significant keyword or token.
   97      */
   98            2 NXT BIT(1) UNAL %INIT(NX)%ENDINIT,
   99      /*K* NXT - A boolean variable which (if true) indicates that the parser
  100                is being asked to display the legal alternatives, after a
  101                parse failure occurs.
  102
  103                NOTE!  This option will function correctly if, and only if
  104                the following conditions hold true when X$PARSE is called
  105                with NXT set to '1'B:
  106
  107                1) P_PCB.WKSZ, P_PCB.WK_USED, and P_PCB.HI_CHAR must contain the
  108                   same values that they held at the time X$PARSE altreturned
  109                   with a "Syntax error" code in P_PCB.ERR;
  110
  111                2) P_PCB.ROOT$ must point to the same node as it did during the
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      4    
  112                   unsuccessful parsing operation;
  113
  114                3) The behavior of the user's U$$ routine (which services
  115                   pre-parsing, success- and failed-node intervention, and
  116                   other useful functions) must be IDENTICAL to its behavior
  117                   during the original (unsuccessful) parsing operation.
  118      */
  119            2 DYNMEM BIT(1) UNAL %INIT(DYNAMIC)%ENDINIT,
  120      /*K* DYNMEM - A boolean variable which specifies whether or not the user's
  121                U$$ routine is capable of expanding the parse work area
  122                "on the fly" if the parser runs out of space.
  123      */
  124            2 KEYWORDS BIT (1) %INIT (KEYSCAN) %ENDINIT,
  125      /*K*  KEYWORDS - Requests that X$PARSE make available a list of
  126            literals (keywords) which are legal at the point at
  127            which a previous parse failed.
  128
  129            The KEYWORDS flag (set by KEYSCAN=YES) is
  130            meaningful only if P_PCB.NXT is set (that is, X$PARSE
  131            is being asked to determine the literals and lexemes which
  132            would be legal at the point at which a previous parsing
  133            operation failed due to a syntax error.  If NXT='1'B and
  134            KEYWORDS='1'B, X$PARSE will not display the list of
  135            literals and lexemes;  instead, it will construct a table
  136            of literal information and pointers (formatted per
  137            P$KEYWORDS), and will set P_PCB.OUT$ equal to the
  138            ADDR of this P$KEYWORDS table.
  139      */
  140            2 BLANKONLY BIT (1),
  141      /*K*  BLANKONLY - this flag is meaningful only upon return from a call
  142            to X$PARSE in which the "next alternatives, please" flag (P_PCB.NXT)
  143            was set.  P_PCB.BLANKONLY will be set if the only legal alternative
  144            that the parser located was a "required blank", and will be reset if
  145            anything other than a "required blank" would be legal at the point
  146            of error.
  147      */
  148            2 NXT_SZONLY BIT(1) UNAL %INIT('0'B)%ENDINIT,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      5    
  149      /*K* NXT_SZONLY -  If the NXT bit is also set, X$PARSE fails all nodes
  150           when the current position in the text is .HI_CHAR but does not
  151           actually collect the alternatives at that point.  This is needed
  152           when GETCMD reports spelling alternatives, since the reparse does
  153           not duplicate the original one in that case, so the command must
  154           first be reparsed to reset .WK_USED to the proper size.
  155      */
  156            2 * BIT (10) %INIT ('0'B) %ENDINIT,
  157            2 ERROR ALIGNED,
  158      /*K* ERROR - A standard CP-6 error code structure.  If X$PARSE is unable
  159                to successfully parse its input string, it will store an error
  160                code in P_PCB.ERROR and perform an ALTRETURN.
  161      */
  162              3 FCG BIT(12) UNAL %INIT('0'B)%ENDINIT,
  163              3 MID BIT(6) UNAL %INIT('0'B)%ENDINIT,
  164              3 MON BIT(1) UNAL %INIT('0'B)%ENDINIT,
  165              3 CODE UBIN(14) UNAL %INIT(0)%ENDINIT,
  166              3 SEV UBIN(3) UNAL %INIT(0)%ENDINIT,
  167            2 COMMENT ALIGNED,
  168      /*K* COMMENT - Specifies the character(s) which introduce and terminate
  169                comments within a command.
  170      */
  171              3 LEAD CHAR(2) UNAL %INIT(C_LD)%ENDINIT,
  172      /*K* LEAD - Specifies the 1- or 2-character sequence which begins a comment.
  173                If a comment begins with a single character, this field must
  174                be initialized with that character preceded by a blank
  175                (eg. ' "' indicates that a double-quote character introduces
  176                a comment).  If this field is completely blank, X$PARSE assumes
  177                that the command may not contain comments of any sort.
  178      */
  179              3 TRAIL CHAR(2) UNAL %INIT(C_TL)%ENDINIT,
  180      /*K* TRAIL - Specifies the 1- or 2-character sequence which terminates a
  181                comment.  1-character comment terminators must be right-justified
  182                (see P_PCB.COMMENT.LEAD).  If this field is blank, X$PARSE
  183                assumes that comments are terminated only by the end of the
  184                command (and thus cannot appear in the middle of a command).
  185      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      6    
  186            2 WK_USED UBIN(18) UNAL %INIT(0)%ENDINIT,
  187      /*K* WK_USED - Upon a successful RETURN from X$PARSE, this field contains
  188                the number of words of workspace actually used by the parser.
  189      */
  190            2 VERSION_CODE UBIN(4) UNAL %INIT(1)%ENDINIT,
  191      /*K* VERSION_CODE - Specifies which version of the P_PCB structure this is.
  192                The B03 (and earlier) versions of X$PARSE use a VERSION_CODE
  193                of 0;  the C00 version has a VERSION_CODE of 1.
  194      */
  195            2 OUTDCB# UBIN(14) UNAL %INIT(DCBNUM(OUTDCB))%ENDINIT,
  196      /*K* OUTDCB# - Contains the DCBNUMber of the DCB through which X$PARSE is
  197                to write the "permissible syntax alternatives" (see
  198                P_PCB.NXT).
  199      */
  200            2 NCHARS UBIN WORD %INIT(N#)%ENDINIT,
  201      /*K* NCHARS - When X$PARSE is called, NCHARS must contain the number of
  202                characters in the input string pointed to by TEXT$.
  203      */
  204            2 HI_CHAR UBIN WORD %INIT(0)%ENDINIT,
  205      /*K* HI_CHAR - Upon return from X$PARSE, P_PCB.HI_CHAR contains the index
  206                into the text string (pointed to by P_PCB.TEXT$) of the
  207                last character successfully parsed.  If X$PARSE altreturns,
  208                the character(s) immediately following the HI_CHAR position
  209                are the ones which X$PARSE was unable to parse successfully.
  210      */
  211            2 HINODE$ PTR %INIT(ADDR(NIL))%ENDINIT,
  212      /*K* HINODE$ - points to the P$NODE (or P$SYM, etc.) structure which
  213                corresponds to the last node successfully parsed, EXCEPT
  214                in the case of P_PCB.ERR.COEE = %E$BADNODE, in which case
  215                HINODE$ points to a node which X$PARSE has decided is illegal
  216                (contains a bad node or lexeme type, performs an immediate
  217                left recursion, or is located at ADDR(NIL) or at location 0 within
  218                the user's instruction segment).
  219      */
  220            2 USER$ PTR %INIT(ADDR(USERPTR))%ENDINIT,
  221      /*K* USER$ - pointer to an optional user-owned block of memory.  If
  222                this pointer is non-NIL when X$PARSE is called, the indicated
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      7    
  223                block of memory will be passed (as a parameter) to the user's
  224                parse-intervention routine (identified by P_PCB.U$$).
  225      */
  226            2 OUTENT$ EPTR %INIT(ENTADDR(OUTENT))%ENDINIT;
  227      /*K* OUTENT$ - an EPTR which contains the address of an (optional)
  228                user-supplied "output" routine.  If present, this routine
  229                will be called by X$PARSE to display "legal syntax
  230                alternatives" when X$PARSE has been called with P_PCB.NXT
  231                set to '1'B.
  232      */
  233      %MEND;
  234
  235      %MACRO P$PCB(NAME=P$PCB,
  236                   STCLASS=AUTO);
  237      %P_PCB(NAME=NAME,STCLASS=STCLASS);
  238      %MEND;
  239
  240      %MACRO PARSE$OUT(NAME=OUT$BLK,SCRMODE="UBIN HALF",SCRALGN=HALIGNED,SUBLK$=SUBLK$,NDTYPE=NDTYPE,
  241                       NSUBLKS=NSUBLKS,SCRITCH=SCRITCH,STCLASS="BASED(BLK$)");
  242      /*F*  NAME:     PARSE$OUT
  243            FUNCTION: a structure built by X$PARSE which corresponds to a "list",
  244                "alternative", "reducing alternative", or "koncat" node in
  245                the user's parse tree.
  246      */
  247      DCL 1 NAME STCLASS ALIGNED,
  248            2 TEMP BIT(1) UNAL,
  249            2 * BIT (11) UNAL,
  250            2 NDTYPE UBIN (6) UNAL,
  251      /*K* NDTYPE - specifies the type of parse node to which this PARSE$OUT
  252                block corresponds.  See the XU_SUBS_C file for the
  253                %EQU symbols whose values may appear in this field.
  254      */
  255            2 CODE UBIN HALF HALIGNED,
  256      /*K* CODE - Contains the numeric "node code" specified by the user when
  257                the corresponding parse-node was defined.
  258      */
  259            2 NSUBLKS UBIN HALF HALIGNED,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      8    
  260      /*K* NSUBLKS - "number of sub-blocks".  This field contains the count of
  261                pointers actually available in the PARSE$OUT.SUBLK$ array.
  262      */
  263            2 SCRITCH SCRMODE SCRALGN,
  264      /*K* SCRITCH - an 18-bit scratch field reserved for the user.  X$PARSE
  265                initializes this field to zero when the PARSE$OUT structure
  266                is allocated, and never sets or examines it thereafter.
  267                The name of this field may be changed when the PARSE$OUT macro
  268                is invoked by the user (say "SCRITCH=yourname"), and its data
  269                type may also be changed (say "SCRMODE=pl6datatype" and
  270                "SCRALGN=alignment").  BEWARE: this field MUST be 18-bits long,
  271                and be UNALIGNED, CALIGNED, or HALIGNED.
  272      */
  273            2 CPOS UBIN WORD,
  274      /*K* CPOS - "character position" of this block.  This field will contain
  275                a character index (starting at 0) into the original parse
  276                string;  the index identifies the first character of the
  277                string which was accepted by this node (or by any of its
  278                sub-nodes).
  279      */
  280            2 SUBLK$(0:0) PTR UNAL;
  281      /*K* SUBLK$ - an array of PL-6 PTRs.  The number of elements in this array
  282                is found in OUT$BLK.NSUBLKS;  each PTR will point to another
  283                OUT$BLK structure, or to an OUT$SYM structure.
  284      */
  285      %MEND;
  286
  287      %MACRO PARSE$SYM(NAME=OUT$SYM,SCRMODE="UBIN HALF",SCRALGN=HALIGNED,SUBLK$=SUBLK$,NDTYPE=NDTYPE,
  288                       SCRITCH=SCRITCH,STCLASS="BASED(BLK$)");
  289      /*F*  NAME:     PARSE$SYM
  290            FUNCTION: holds "parse symbols".  Structures of this form are created
  291                by X$PARSE to hold those portions of the string being parsed
  292                which must be returned to the user - quoted strings, decimal
  293                or octal numbers, PL-6 identifiers, etc.
  294      */
  295      DCL 1 NAME STCLASS ALIGNED,
  296            2 TEMP BIT(1) UNAL,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      9    
  297            2 * BIT (11) UNAL,
  298            2 NDTYPE UBIN (6) UNAL,
  299      /*K* NDTYPE - see OUT$BLK.NDTYPE for details.
  300      */
  301            2 CODE UBIN HALF HALIGNED,
  302      /*K* CODE - see OUT$BLK.CODE for details.
  303      */
  304            2 NSUBLKS UBIN HALF HALIGNED,
  305      /*K* NSUBLKS - always contains the value 1.
  306      */
  307            2 SCRITCH SCRMODE SCRALGN,
  308      /*K* SCRITCH - see OUT$BLK.SCRITCH for details.
  309      */
  310            2 CPOS UBIN WORD,
  311      /*K* CPOS - see OUT$BLK.CPOS for details.
  312      */
  313            2 TEXTC$ PTR,
  314      /*K* TEXTC$ - a pointer to a TEXTC-type string (a 1-byte count field
  315                followed by a variable number of characters).  Always
  316                points to OUT$SYM.COUNT in the current OUT$SYM block.
  317      */
  318            2 COUNT UBIN BYTE CALIGNED,
  319      /*K* COUNT - contains the number of characters in OUT$SYM.TEXT.
  320      */
  321            2 TEXT CHAR(NAME.COUNT) CALIGNED;
  322      /*K* TEXT - contains the text of a string, decimal number, PL-6
  323                identifier, or some other parser "symbol".
  324      */
  325      %MEND;
  326
  327      %MACRO PARSE_PARAM(NAME=PARSE_PARAM,
  328                         STCLASS=STATIC);
  329      /*F*  NAME:     PARSE_PARAM
  330            FUNCTION: a data structure used to communicate between X$PARSE and the
  331                user's mid-parse intervention routine (see P_PCB.U$$).
  332      */
  333
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      10   
  334       %LSET LISTDIR='0'B;
  335       %LSET LISTEXP='1'B;
  336       %LSET LISTCOM='0'B;
  337       %LSET LISTSUB='1'B;
  338       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  339       %IF (SUBSTR(STR,0,6)='STATIC') OR
  340       (SUBSTR(STR,0,8)='CONSTANT') OR
  341       (SUBSTR(STR,0,3)='EXT');
  342       %LSET INIT=CHARTEXT('INIT');
  343       %ELSE;
  344       %LSET INIT=CHARTEXT('/*');
  345       %ENDIF;
  346       %LSET ENDINIT=CHARTEXT(CONCAT('/**','/'));
  347
  348      DCL 1 NAME STCLASS ALIGNED,
  349            2 TYPE UBIN(9) UNAL %INIT(0)%ENDINIT,
  350      /*K* TYPE - specifies the type of operation that X$PARSE is giving the
  351                user a chance to perform (eg. read more input;  expand
  352                work area; etc.).  See file XU_SUBS_C for the values that
  353                this field may contain.
  354      */
  355            2 ACCEPT BIT(1) UNAL %INIT('0'B)%ENDINIT,
  356      /*K* ACCEPT - a Boolean which indicates that the user's routine wishes
  357                to tell the parser, "OK - go ahead".  If ACCEPT is set,
  358                both REJECT and RETRY must be reset.
  359      */
  360            2 REJECT BIT(1) UNAL %INIT('0'B)%ENDINIT,
  361      /*K* REJECT - a Boolean which indicates that the user's routine wishes
  362                to tell the parser, "No , I don't want this alternative".
  363      */
  364            2 RETRY BIT(1) UNAL %INIT('0'B)%ENDINIT,
  365      /*K* RETRY - a Boolean which indicates that the user's routine wishes
  366                to tell the parser, "Try that one again, please".
  367      */
  368            2 * BIT(6) UNAL %INIT('0'B)%ENDINIT,
  369            2 CODE UBIN HALF HALIGNED %INIT(0)%ENDINIT,
  370      /*K* CODE - if PARAM.TYPE = %PRE#, %SUCC#, or %FAIL#, this field will
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      11   
  371                contain the "node code" value of the syntax node being
  372                parsed.
  373      */
  374            2 NODE$ PTR UNAL %INIT(ADDR(NIL))%ENDINIT,
  375      /*K* NODE$ - points to the P$NODE structure for the syntax node being
  376                parsed.
  377      */
  378            2 OUT$ PTR UNAL %INIT(ADDR(NIL))%ENDINIT,
  379      /*K* OUT$ - if non-NIL, points to the output block (OUT$BLK or OUT$SYM)
  380                just created by X$PARSE.
  381      */
  382            2 GLOBAL$ PTR UNAL %INIT(ADDR(NIL))%ENDINIT,
  383      /*K* GLOBAL$ - points to a G$D structure owned by X$PARSE.  DON'T tamper with
  384                the G$D structure unless you KNOW what you're doing!
  385      */
  386            2 CHARPOS UBIN WORD %INIT(0)%ENDINIT,
  387      /*K* CHARPOS - contains the index into the parse buffer at which X$PARSE
  388                is currently looking.  May be changed by the user's routine
  389                to cause X$PARSE to skip over or re-examine a portion of the
  390                input string.
  391      */
  392            2 PCB$ PTR %INIT(ADDR(NIL))%ENDINIT,
  393      /*K* PCB$ - points to the P_PCB structure which controls this parsing
  394                operation.
  395      */
  396            2 USER$ PTR %INIT(ADDR(NIL))%ENDINIT,
  397      /*K* USER$ - points to an (optional) user-owned block of data, as
  398                originally identified by P_PCB.USER$.  Management of this
  399                block of data is entirely up to the user's routine(s).
  400      */
  401            2 WKSZ UBIN HALF HALIGNED %INIT(0)%ENDINIT;
  402      /*K* WKSZ - on entry to the user's routine, this field contains the
  403                current size (in words) of the parse work area.  If the
  404                user's routine has been called with PARAM.TYPE=%SPACE#,
  405                the user's routine may extend the work area, and set the
  406                WKSZ field equal to the new (larger) size.
  407      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      12   
  408      %MEND;
  409
  410      %MACRO PARSE$PARAM(NAME=PARSE$PARAM,
  411                         STCLASS=" ");
  412      %PARSE_PARAM (NAME=NAME,STCLASS=STCLASS);
  413      %MEND;
  414
  415      %MACRO XUP$CHAIN;
  416      DCL 1 FREE$HDR BASED ALIGNED,           /* FREE CHAIN BLOCK HEADER            */
  417            2 NWORDS SBIN UNAL,               /* COUNT OF WORDS IN BLOCK            */
  418            2 NEXT$ PTR UNAL,                 /* FORWARD LINK TO NEXT FREE BLOCK    */
  419            2 PREV$ PTR;                 /* BACKWARD LINK TP PREVIOUS FREE BLOCK    */
  420      %MEND;
  421
  422      %MACRO XUP$POSS (NAME=XUP$POSS,STCLASS=BASED);
  423      DCL 1 NAME STCLASS ALIGNED,     /* LEGAL POSSIBILITY LIST STRUCTURE */
  424            2 COUNT SBIN,             /* NUMBER OF NODES IN LIST          */
  425            2 NODES$ (0:0) PTR;       /* POSSIBLE NEXT NODE ARRAY         */
  426      %MEND;
  427
  428      %MACRO G$D(NAME=G$D,STCLASS=" ");
  429      /*F*  NAME:     G$D
  430            FUNCTION: a data structure owned and managed by X$PARSE, used to
  431                retain and pass useful information throughout the lifetime
  432                of a parsing operation.  Tampering with this structure's
  433                contents by a user-supplied routine will void the warranty,
  434                and may expose the programmer to high-voltage screams of
  435                anguish from the software-support staff.
  436      */
  437      DCL 1 NAME ALIGNED STCLASS,
  438            2 PCB$ PTR,
  439      /*K* PCB$ - pointer to Parse Control Block.
  440      */
  441            2 ERROR REMEMBER,
  442      /*K* ERROR - error return point.  Any error other than a syntax error
  443                  that is detected during parsing unwinds to G$D.ERROR
  444                  after setting the error code and other error return
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      13   
  445                  information in the PCB; this results in an altreturn
  446                  from X$PARSE.
  447      */
  448            2 NODE$ PTR,
  449      /*K* NODE$ - pointer to node to attempt to parse.  This is reset for
  450                  each call to XUP$PARS to pass it the node it is to try to
  451                  parse.  Within XUP$PARS, a local copy of this pointer is
  452                  used to access the node, since this field will be reset by
  453                  subsequent recursive calls to attempt to parse subnodes.
  454      */
  455            2 FREEANCHOR$ PTR,
  456      /*K* FREEANCHOR$ - pointer to the first block in the free space chain
  457                  for the parse work area.
  458      */
  459            2 LASTFREE$ PTR,
  460      /*K* LASTFREE$ - pointer to the last block in the free space chain
  461                  for the parse work area.
  462      */
  463            2 HISPACE$ PTR,
  464      /*K* HISPACE$ - pointer to the next available word in the parse work area.
  465      */
  466            2 STACKTOP$ PTR,
  467      /*K* STACKTOP$ - pointer to the top element in the parse stack at the
  468                  end of the parse work area.
  469      */
  470            2 REDUCE$ PTR,
  471      /*K* REDUCE$ - root address for the current reducing alternative flag
  472                  block list; NIL if the list is empty.
  473      */
  474            2 SCRATCH SBIN WORD,
  475      /*K* SCRATCH - scratch word for use by X$PARSE (redefinition of CNTUPOS).
  476      */
  477            2 CNTUPOS REDEF SCRATCH SBIN WORD,
  478      /*K* CNTUPOS - offset of the start of the command text from the current
  479              command text pointer (PCB.TEXT$).  If continuation lines are
  480              appended to command text for previous lines, this will always
  481              be zero.  If continuation lines overlay the previous lines,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      14   
  482              this will be a negative number equal to the number of characters
  483              in prior lines that have been lost in overlaid lines.
  484      */
  485            2 CCPOS SBIN WORD,
  486      /*K* CCPOS - the current position in the command text.
  487      */
  488            2 CLEXPOS SBIN WORD,
  489      /*K* CLEXPOS - the current lexical position in the command text; used
  490              to determine if part of the text to be returned by an RTEXT
  491              node has been overlaid by a continuation line.
  492      */
  493            2 CCHAR CHAR(1) CALIGNED,
  494      /*K* CCHAR - the character at the current position in the command text.
  495      */
  496            2 BLSKIP BIT(1) UNAL,
  497      /*K* BLKSIP - blank skip flag; set if some whitespace has been skipped
  498              at the end of the last lexeme parsed.
  499      */
  500            2 *       BIT(26) UNAL,
  501            2 LDCMNT,
  502      /*K* LDCMNT - the length (.CT) and text (.TX) of the leading comment delimiter.
  503                  This is derived from PCB.COMMENT.LEAD when X$PARSE is first
  504                  entered.
  505      */
  506              3 CT UBIN HALF HALIGNED,
  507              3 TX CHAR(2) CALIGNED,
  508              3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
  509            2 TRCMNT,
  510      /*K* TRCMNT - the length (.CT) and text (.TX) of the trailing comment delimiter.
  511                  This is derived from PCB.COMMENT.LEAD when X$PARSE is first
  512                  entered.
  513      */
  514              3 CT UBIN HALF HALIGNED,
  515              3 TX CHAR(2) CALIGNED,
  516              3 TXA(0:1) REDEF TX CHAR(1) CALIGNED,
  517            2 TBUF CHAR(511);
  518      /*K* TBUF - temporary buffer for various uses within XUP$PARS.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      15   
  519                  (Defining it here rather than in local auto saves 128 words
  520                  per invocation, which can become quite significant for such
  521                  a highly recursive routine.)
  522      */
  523      %MEND;
  524
  525      %MACRO P$NODE(NAME=P$NODE,STCLASS=" ",LEV=1,LAST=NO,
  526                    NDTYPE(ALTERN=1,RALTERN=2,LIST=3,KONCAT=4,LITERAL=5,LEXEME=6)=0,
  527                    PRE(YES='1'B,NO='0'B)='0'B,
  528                    SUCC(YES='1'B,NO='0'B)='0'B,
  529                    FAIL(YES='1'B,NO='0'B)='0'B,
  530                    OUTPUT_BLOCK(YES='1'B,NO='0'B)='0'B,
  531                    OPTIONAL(YES='1'B,NO='0'B)='0'B,
  532                    REPEATABLE(YES='1'B,NO='0'B)='0'B,
  533                    SKIP_BLANKS(YES='1'B,NO='0'B)='0'B,
  534                    RETURN_TEXT(YES='1'B,NO='0'B)='0'B,
  535                    #SUBNODES=1,
  536                    NODE_CODE=0,
  537                    SUBNODES="ADDR(NIL)");
  538      /*F*  NAME:     P$NODE
  539            FUNCTION: a structure used to describe syntax nodes, as built by
  540                PARTRGE and interrogated by X$PARSE.  This structure may be
  541                used to examine all of the attributes of nodes of several
  542                types:  koncat, list, alternative, and reducing alternative.
  543                It may also be used to examine a few of the attributes of
  544                symbol and delimited-string nodes, as indicated.
  545      */
  546      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  547      %IF (SUBSTR(STR,0,6)='STATIC')OR(SUBSTR(STR,0,8)='CONSTANT')OR(SUBSTR(STR,0,3)='EXT');
  548      %LSET INIT=CHARTEXT('INIT');
  549      %LSET ENDINIT=CHARTEXT('');
  550      %ELSE;
  551      %LSET INIT=CHARTEXT('/*');
  552      %LSET ENDINIT=CHARTEXT('*/');
  553      %ENDIF;
  554      %IF LEV=1;
  555      DCL 1 NAME STCLASS ALIGNED,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      16   
  556      %ELSE;
  557       LEV NAME ALIGNED,
  558      %ENDIF;
  559            %(LEV+1) TYPE UBIN(3) UNAL %INIT(NDTYPE)%ENDINIT,
  560      /*K* TYPE - specifies the "major type" of this node.  See the XU_SUBS_C
  561                file for the permissible values in this field (%TYPE_whatever#).
  562      */
  563            %(LEV+1) P_F BIT(1) UNAL %INIT(PRE)%ENDINIT,
  564      /*K* P_F - specifies that the user wants to be able to "pre-approve"
  565                any attempt to match this node.  This flag is set if the
  566                user supplied the "(PRE)" option in jhir PARTRGE definition
  567                of this node.
  568      */
  569            %(LEV+1) S_F BIT(1) UNAL %INIT(SUCC)%ENDINIT,
  570      /*K* S_F - specifies that the user wants to be able to "post-approve"
  571                any successful attempts to match this node;  set if the user
  572                supplied the "(SUCC)" option in the PARTRGE definition of this
  573                node.
  574      */
  575            %(LEV+1) F_F BIT(1) UNAL %INIT(FAIL)%ENDINIT,
  576      /*K* F_F - specifies that the user wants to be notified of any
  577                failed attempts to match this node;  set if the user specified
  578                the "(FAIL)" option in the PARTRGE definition of this node.
  579      */
  580            %(LEV+1) O_F BIT(1) UNAL %INIT(OUTPUT_BLOCK)%ENDINIT,
  581      /*K* O_F - specifies that this node is to result in the creation of
  582                a block in the X$PARSE output tree.  The setting of this
  583                flag is controlled by several PARTRGE attributes:  the
  584                "OUT" option, the "NOUT" option, the "code" option, and the
  585                node's basic type.  If the user specifies "OUT", this flag
  586                will be set;  if the user specifies "NOUT", this flag will
  587                not be set;  if the user specifies neither "OUT" nor "NOUT",
  588                this flag will be set if the "code" option was specified or
  589                if the node is of the "delimited string" or "symbol" varieties.
  590      */
  591            %(LEV+1) OPT BIT(1) UNAL %INIT(OPTIONAL)%ENDINIT,
  592      /*K* OPT - set if this node is "optional".  This flag is set if the
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      17   
  593                PARTRGE definition of this node was enclosed in a set
  594                of [square-brackets].
  595      */
  596            %(LEV+1) RPEAT BIT(1) UNAL %INIT(REPEATABLE)%ENDINIT,
  597      /*K* RPEAT - specifies that this node can be repeated (may occur more than
  598                once).  This flag is set of the PARTRGE definition of this node
  599                was enclosed in a set of *asterisks*.
  600      */
  601            %(LEV+1) SKBL BIT(1) UNAL %INIT(SKIP_BLANKS)%ENDINIT,
  602      /*K* SKBL - specifies that blanks (and/or comments) may legally appear
  603                after this node.  This flag is set unless the PARTRGE
  604                definition of this node included a trailing hyphen-.
  605      */
  606            %(LEV+1) RTEXT BIT(1) UNAL %INIT(RETURN_TEXT)%ENDINIT,
  607      /*K* RTEXT - specifies that this node should produce an OUT$SYM block
  608                incorporating all of the text (and blanks and/or comments)
  609                accepted by this node, with no editing or case conversion.
  610                This flag is set if the PARTRGE definition of this node
  611                included the "(RTEXT)" option.
  612      */
  613            %(LEV+1) NSUBNDS UBIN BYTE UNAL %INIT(#SUBNODES)%ENDINIT,
  614      /*K* NSUBNDS - specifies the number of sub-nodes within this parse block.
  615      */
  616            %(LEV+1) CODE UBIN (16) UNAL %INIT(NODE_CODE)%ENDINIT,
  617      /*K* CODE - specifies the "code number" for this parse node.  This
  618                value will be returned in OUT$BLK.CODE (or OUT$SYM.CODE) in
  619                any parse block built by X$PARSE which corresponds to this node.
  620      */
  621            %(LEV+1) SUBNDS$(0:0) PTR UNAL %INIT(SUBNODES)%ENDINIT
  622      /*K* SUBNDS$ - an array of PTRs, which point to the NSUBNDS sub-nodes of
  623                this parse node.
  624      */
  625      %IF (LEV=1) | (TEXTCHAR(LAST)='YES');
  626            ;
  627      %ELSE;
  628            ,
  629      %ENDIF;
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      18   
  630      %MEND;
  631
  632      %MACRO P$LIT(NAME=P$LIT,STCLASS=" ",LEN=2,LEV=1,LAST=NO);
  633      /*F*  NAME:     P$LIT
  634            FUNCTION: a structure used to describe "literal" parse nodes, as
  635                built by PARTRGE and interrogated by X$PARSE.  The P$LIT
  636                structure is a sort of "overlay" of P$NODE;  these structures
  637                have many sub-fields in common (TYPE, P_F, S_F, O_F,
  638                OPT, RPEAT, SKBL, and RTEXT).  Documentation for these
  639                common sub-fields may be found under the P$NODE structure.
  640      */
  641      %IF LEV=1;
  642      DCL 1 NAME STCLASS ALIGNED,
  643      %ELSE;
  644       LEV NAME ALIGNED,
  645      %ENDIF;
  646            %(LEV+1) TYPE UBIN(3) UNAL,
  647      /*K* TYPE - identifies the type of this P$LIT node.  This field always
  648                contains the value %TYPE_LITERAL# as found in XU_SUBS_C.
  649      */
  650            %(LEV+1) P_F BIT(1) UNAL,
  651            %(LEV+1) S_F BIT(1) UNAL,
  652            %(LEV+1) F_F BIT(1) UNAL,
  653            %(LEV+1) O_F BIT(1) UNAL,
  654            %(LEV+1) OPT BIT(1) UNAL,
  655            %(LEV+1) RPEAT BIT(1) UNAL,
  656            %(LEV+1) SKBL BIT(1) UNAL,
  657            %(LEV+1) RTEXT BIT(1) UNAL,
  658            %(LEV+1) UPRLOWR BIT(1) UNAL,
  659      /*K* UPRLOWR - specifies that this node is to be compared to the input
  660                string in a case-insensitive fashion;  upper- and lower-case
  661                characters are considered equivalent.  This option is normally
  662                set for all 'literal' nodes;  it is reset if the first character
  663                of a literal node is an '=' character, which indicates that
  664                the literal text must be matched '=ExactLy'.
  665      */
  666            %(LEV+1) ABREV UBIN (8) UNAL,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      19   
  667      /*K* ABREV - an integer field which contains either 0, or the minimum
  668                length of an acceptable abbreviation of this literal.
  669                For example:  the PARTRGE literal 'ABCDEF' has an ABREV of 0;
  670                the literal 'ABC/DEF' has an ABREV of 3.
  671      */
  672            %(LEV+1) CODE UBIN (16) UNAL,
  673            %(LEV+1) COUNT UBIN BYTE CALIGNED,
  674      /*K* COUNT - the number of characters in this literal.
  675      */
  676            %(LEV+1) TEXT CHAR(LEN)
  677      /*K* TEXT - a CHAR variable which contains the text of this literal.
  678      */
  679      %IF (LEV=1) | (TEXTCHAR(LAST)='YES');
  680            ;
  681      %ELSE;
  682            ,
  683      %ENDIF;
  684      %MEND;
  685
  686      %MACRO P$SYM(NAME=P$SYM,STCLASS=" ",LEN=2,LEV=1,LAST=NO);
  687      /*F*  NAME:     P$SYM
  688            FUNCTION: a structure used to describe an X$PARSE "symbol" of one sort
  689                or another.  "Symbols" include such specific things as:
  690                decimal integers, PL-6 identifiers, hexadecimal numbers,
  691                account identifiers, job names, etc.  The P$SYM structure has
  692                many sub-fields in common with P$NODE;  these are documented
  693                in the P$NODE structure itself.
  694      */
  695      %IF LEV=1;
  696      DCL 1 NAME STCLASS ALIGNED,
  697      %ELSE;
  698       LEV NAME ALIGNED,
  699      %ENDIF;
  700            %(LEV+1) TYPE UBIN(3) UNAL,
  701      /*K* TYPE - identifies this node as a P$SYM.  This field always
  702                contains the value %TYPE_LEXEME# as found in XU_SUBS_C.
  703      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      20   
  704            %(LEV+1) P_F BIT(1) UNAL,
  705            %(LEV+1) S_F BIT(1) UNAL,
  706            %(LEV+1) F_F BIT(1) UNAL,
  707            %(LEV+1) O_F BIT(1) UNAL,
  708            %(LEV+1) OPT BIT(1) UNAL,
  709            %(LEV+1) RPEAT BIT(1) UNAL,
  710            %(LEV+1) SKBL BIT(1) UNAL,
  711            %(LEV+1) RTEXT BIT(1) UNAL,
  712            %(LEV+1) MAKEUC BIT(1) UNAL,
  713      /*K* MAKEUC - contains '1'B to indicate "force this symbol to upper-case
  714                when building an output block".  This option is controlled
  715                by the "MAKEUC" option on this node, within the PARTRGE
  716                definition.
  717      */
  718            %(LEV+1) XTRA BIT(1) UNAL,
  719      /*K* XTRA - indicates that this P$SYM structure contains "extra"
  720                information (i.e., a "maximum length" count MAXL,
  721                and/or a set of additional legal characters "TEXT").
  722                If this flag is not set, the MAXL, COUNT, and TEXT subfields
  723                do not exist within this P$SYM structure, and should not
  724                be examined.
  725      */
  726            %(LEV+1) * BIT (2),
  727            %(LEV+1) LEXTYPE UBIN (5) UNAL,
  728      /*K* LEXTYPE - specifies the "flavor" of this P$SYM block;  that is, the
  729                actual type of symbol or lexeme that this block must
  730                match.  Values which may appear in this field are defined
  731                as %LEX_whatever# in the XU_SUBS_C file;  examples include
  732                %LEX_DECIMAL#, %LEX_OCTAL#, %LEX_JOBNAME#, etc.
  733      */
  734            %(LEV+1) CODE UBIN (16) UNAL,
  735      /*
  736         N.B. - the following fields MAXL, COUNT, and TEXT will be
  737         present only if P$SYM.XTRA is set.  If P$SYM.XTRA is reset,
  738         values of MAXL=0, COUNT=0, and TEXT='' should be assumed.
  739      */
  740            %(LEV+1) MAXL UBIN BYTE CALIGNED,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      21   
  741      /*K* MAXL - specifies the maximum length of the symbol that may be
  742                accepted by this node.  If this field contains 0, or
  743                is not present (P$SYM.XTRA='0'B), a symbol of up to 511
  744                characters may be accepted.
  745      */
  746            %(LEV+1) COUNT UBIN BYTE CALIGNED,
  747      /*K* COUNT - contains the number of "additional" characters which are
  748                stored in the P$SYM.TEXT field.
  749      */
  750            %(LEV+1) TEXT CHAR(LEN)
  751      /*K* TEXT - contains 0 or more "additional" characters, which may appear
  752                within a string accepted by this P$SYM block.  For example,
  753                the PARTRGE definition "TOUCHTONE=.decimal+'#*'" would
  754                have the following values:  XTRA='1'B, MAXL=0, COUNT=2,
  755                TEXT='#*';  X$PARSE would accept any string composed of
  756                the digits 0 through 9 and/or the characters '#' and/or
  757                '*' as being a legal "TOUCHTONE" entry.
  758      */
  759      %IF (LEV=1) | (TEXTCHAR(LAST)='YES');
  760            ;
  761      %ELSE;
  762            ,
  763      %ENDIF;
  764      %MEND;
  765
  766      %MACRO P$DSTR(NAME=P$DSTR,STCLASS=" ",LEV=1,LAST=NO);
  767      /*F*  NAME:     P$DSTR
  768            FUNCTION: a structure used to describe a "delimited string" node.
  769                Many of P$DSTR's subfields are identical to those of P$NODE
  770                or P$SYM, and are documented within those structures.
  771      */
  772      %IF LEV=1;
  773      DCL 1 NAME STCLASS ALIGNED,
  774      %ELSE;
  775       LEV NAME ALIGNED,
  776      %ENDIF;
  777            %(LEV+1) TYPE UBIN(3) UNAL,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      22   
  778      /*K* TYPE - identifies this node as a P$DSTR.  This field always
  779                contains the value %TYPE_LEXEME#.
  780      */
  781            %(LEV+1) P_F BIT(1) UNAL,
  782            %(LEV+1) S_F BIT(1) UNAL,
  783            %(LEV+1) F_F BIT(1) UNAL,
  784            %(LEV+1) O_F BIT(1) UNAL,
  785            %(LEV+1) OPT BIT(1) UNAL,
  786            %(LEV+1) RPEAT BIT(1) UNAL,
  787            %(LEV+1) SKBL BIT(1) UNAL,
  788            %(LEV+1) RTEXT BIT(1) UNAL,
  789            %(LEV+1) MAKEUC BIT(1) UNAL,
  790            %(LEV+1) * BIT (3),
  791            %(LEV+1) LEXTYPE UBIN (5) UNAL,
  792      /*K* LEXTYPE - identifies this "lexical" block as a delimited string.
  793                This field always contains the value %LEX_DSTRING#.
  794      */
  795            %(LEV+1) CODE UBIN (16) UNAL,
  796            %(LEV+1) MAXL UBIN BYTE CALIGNED,
  797            %(LEV+1) DLIM CHAR (1) CALIGNED
  798      /*K* DLIM - specifies the character which delimits this string.
  799               If P$DSTR.DLIM = BINASC(0), a "generic" delimited string is
  800               being requested;  such a string may be delimited by any
  801               printable character which does not belong to the "alphanumeric"
  802               class (A-Z, a-z, 0-9).
  803      */
  804      %IF (LEV=1) | (TEXTCHAR(LAST)='YES');
  805            ;
  806      %ELSE;
  807            ,
  808      %ENDIF;
  809      %MEND;
  810
  811      %MACRO P$KEYWORDS (NAME=P$KEYWORDS, STCLASS=BASED);
  812      DCL 1 NAME STCLASS ALIGNED,
  813      /*F*    NAME: P$KEYWORDS
  814              FUNCTION: Contains information about the literals (keywords)
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      23   
  815                        which would be legal at the parse-failure point.
  816      */
  817            2 KEYWORD_COUNT SBIN WORD,
  818      /*K* KEYWORD_COUNT - contains the number of keywords which would
  819           be legal at the parse-error point. */
  820            2 LEGAL$ PTR,
  821      /* LEGAL$ - points to a word-aligned scratch area at least
  822         "KEYWORD_COUNT" bits long. */
  823            2 KEYWORDS$ (0:0) PTR;
  824      /* KEYWORDS$ - an array of effective dimension (0:KEYWORD_COUNT-1).
  825         Each element in this array is a pointer to a TEXTC string which
  826         contains a keyword which would be legal at the parse-error
  827         point. */
  828      %MEND;
  829      /*
  830            Following %MACROs are provided to yield compatibility with
  831            pre-C00 parse nodes.
  832      */
  833
  834      %EJECT;

15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      24   
  835      /*F* NAME: XUU_PARAM
  836      DESCRIPTION:
  837         XUU_PARAM is a macro invoked to build and
  838         initialize the parameter block passed to XUU$OPEN,
  839         XUU$READ and XUU$CLOSE.
  840
  841         It should be noted that the XUU
  842         services use the fields in the parameter block extensively
  843         for returning values to the user.  This means that the XUU_PARAM
  844         block passed to an XUU service should not be defined in
  845         constant storage and initialized values should
  846         not be counted upon once the PARAM block has been passed
  847         to an XUU service.
  848      */
  849
  850      %MACRO XUU_PARAM (FPTN=XUU_PARAM,
  851                        STCLASS=STATIC,
  852                        BASE(YES='1'B,NO='0'B)='0'B,
  853                        UPDATE(YES='1'B,NO='0'B)='0'B,
  854                        INCLUDE(YES='1'B,NO='0'B)='0'B,
  855                        BLANK_FILL(YES='1'B,NO='0'B)='0'B,
  856                        SOURCE_OUT(YES='1'B,NO='0'B)='0'B,
  857                        CLOSE_ALL(YES='1'B,NO='0'B)='0'B,
  858                        LU_FIRST(YES='1'B,NO='0'B)='0'B,
  859                        LU_WHILE(YES='1'B,NO='0'B)='0'B,
  860                        OPT_UI(YES='1'B,NO='0'B)='0'B,
  861                        FAST_BASE(YES='1'B,NO='0'B)='0'B,
  862                        FAST_UPDATE(YES='1'B,NO='0'B)='0'B,
  863                        FAST_INCLUDE(YES='1'B,NO='0'B)='0'B,
  864                        ERROR_PROC=NIL,
  865                        ALLOCATE=NIL,
  866                        RELEASE=NIL,
  867                        DCB=0);
  868
  869      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  870      %IF (STR='STA') OR (STR='CON') OR (STR='EXT');
  871        %LSET INIT=CHARTEXT('INIT');
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      25   
  872        %LSET EINIT=CHARTEXT(' ');
  873      %ELSE;
  874        %LSET INIT=CHARTEXT('/*');
  875        %LSET EINIT=CHARTEXT('*/');
  876      %ENDIF;
  877
  878      DCL 1 FPTN STCLASS ALIGNED,
  879            2 FLAGS,
  880              3 BASE# BIT(1) UNAL %INIT(BASE)%EINIT,
  881      /*K*      FLAGS.BASE# - BIT(1)
  882
  883                At a call to XUU$OPEN, specifies that a base source file is
  884                to be opened using M$SI.
  885
  886                On return from XUU$READ, is set if the record was
  887                read from the base source file.
  888
  889                At a call to XUU$CLOSE, specifies that the base source file
  890                is to be closed.
  891
  892                If FLAGS.BASE# is set on ALTRETURN from any XUU service,
  893                the ERRCODE field contains an error that was encountered
  894                while operating on the base source file.
  895
  896                The field is initialized in the XUU_PARAM block with BASE={YES|NO}.
  897                The default is NO.
  898      */
  899              3 UP_DATE# BIT(1) UNAL %INIT(UPDATE)%EINIT,
  900      /*K*      FLAGS.UP_DATE# - BIT(1)
  901
  902                At a call to XUU$OPEN, specifies that an update file is
  903                to be opened using M$UI.  If both a base source file and
  904                an update file are to be opened, they both must be opened
  905                on the same call to XUU$OPEN.  (Set both FLAGS.BASE# and
  906                FLAGS.UP_DATE# for the call.)
  907
  908                On return from XUU$READ, is set if the record was
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      26   
  909                read from the update file.
  910
  911                At a call to XUU$CLOSE, specifies that the update file
  912                is to be closed.
  913
  914                If FLAGS.UP_DATE# is set on ALTRETURN from any XUU service,
  915                the ERRCODE field contains an error that was encountered
  916                while operating on the update file.
  917
  918                The field is initialized in the XUU_PARAM block with UPDATE={YES|NO}.
  919                The default is NO.
  920      */
  921              3 INCLUDE# BIT(1) UNAL %INIT(INCLUDE)%EINIT,
  922      /*K*      FLAGS.INCLUDE# - BIT(1)
  923
  924                At a call to XUU$OPEN, specifies that a DCB is to be
  925                dynamically acquired and opened to the INCLUDE file.
  926                The field XUU_PARAM.O.FPT_PTR$ must contain a pointer to
  927                an FPT_OPEN for the INCLUDE file.  (The FPT must not be in
  928                constant storage.)  Include files must be opened separately
  929                from the source and update files.  Setting FLAGS.INCLUDE#
  930                and either FLAGS.BASE# or FLAGS.UP_DATE# will result in
  931                an error.
  932
  933                On return from XUU$READ, is set if the record was
  934                read from an include file.
  935
  936                At a call to XUU$CLOSE, specifies that the highest level
  937                include file is to be closed.
  938
  939                If FLAGS.INCLUDE# is set on ALTRETURN from any XUU service,
  940                the ERRCODE field contains an error that was encountered
  941                while operating on the include file at level LEVEL.
  942
  943                The field is initialized in the XUU_PARAM block with INCLUDE={YES|NO}.
  944                The default is NO.
  945      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      27   
  946              3 BLANK_FILL# BIT(1) UNAL %INIT(BLANK_FILL)%EINIT,
  947      /*K*      FLAGS.BLANK_FILL - BIT(1)
  948
  949                At a call to XUU$READ, specifies that the buffer is to
  950                be blank-filled from the end of the record read to the
  951                end of the buffer.
  952
  953                The field is initialized in the XUU_PARAM block with
  954                BLANK_FILL={YES|NO}.
  955                The default is NO.
  956      */
  957              3 SOURCE_OUT# BIT(1) UNAL %INIT(SOURCE_OUT)%EINIT,
  958      /*K*      FLAGS.SOURCE_OUT# - BIT(1)
  959
  960                At a call to XUU$READ, specifies that the source
  961                records, with the exception of INCLUDE file records,
  962                are to be written through M$SO.  If M$SO is not already
  963                open, it is opened with EXIST=NEWFILE which causes an
  964                existing file to be overwritten.  If M$SO is set to a
  965                keyed file, then the new source output file is created
  966                with EDIT format keys beginning with 1.000 and
  967                incremented by 1.000 with each write.  This flag,
  968                if used, should be set for all calls to XUU$READ.
  969                Failure to do so will result in missing records in
  970                the source output file.
  971
  972                At a call to XUU$CLOSE, specifies that the source
  973                output file is to be closed.
  974
  975                The field is initialized in the XUU_PARAM block with
  976                SOURCE_OUT={YES|NO}.
  977                The default is NO.
  978      */
  979              3 CLOSE_ALL# BIT(1) UNAL %INIT(CLOSE_ALL)%EINIT,
  980      /*K*      FLAGS.CLOSE_ALL# - BIT(1)
  981
  982                At a call to  XUU$CLOSE, specifies that all open files
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      28   
  983                used in the source update process are to be closed.
  984
  985                The field is initialized in the XUU_PARAM block with
  986                CLOSE_ALL={YES|NO}.
  987                The default is NO.
  988      */
  989              3 KEY_REC# BIT(1) UNAL %INIT('0'B)%EINIT,
  990      /*K*      FLAGS.KEY_REC# - BIT(1)
  991
  992                On return from XUU$READ, set if the returned record
  993                came from a keyed file.
  994      */
  995              3 SO_ERR# BIT(1) UNAL %INIT('0'B)%EINIT,
  996      /*K*      FLAGS.SO_ERR# - BIT(1)
  997
  998                If FLAGS.SO_ERR# is set on ALTRETURN from any XUU service,
  999                the ERRCODE field contains an error that was encountered
 1000                while operating on the source output file.
 1001      */
 1002              3 XUU_ERR# BIT(1) UNAL %INIT('0'B)%EINIT,
 1003      /*K*      FLAGS.XUU_ERR# - BIT(1)
 1004
 1005                If FLAGS.XUU_ERR# is set on ALTRETURN from any XUU service,
 1006                the ERRCODE field contains an error that was not attributable
 1007                to a specific file being operated upon.  This will include
 1008                plus card errors, XUU_PARAM errors and internal errors.
 1009      */
 1010              3 LU_FIRST# BIT(1) UNAL %INIT(LU_FIRST)%EINIT,
 1011      /*K*      FLAGS.LU_FIRST# - BIT(1)
 1012
 1013                At a call to XUU$OPEN, specifies that a list of updates
 1014                is to be made through the DCB specified (via the
 1015                parameter DCB) when M$UI is first opened.  For CP-6
 1016                managed files, each record is read from M$UI,
 1017                formatted and written through the specified DCB until an
 1018                end-of-file on M$UI is encountered.  Then M$UI is
 1019                positioned to the beginning of the file.  For unmanaged
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      29   
 1020                files, an intermediate file must be created by XUU$OPEN
 1021                to produce the LU_FIRST type of LU listing.  A dynamic
 1022                DCB will be acquired for this purpose, and the M$UI
 1023                records will be written to a scratch file through this
 1024                DCB.
 1025
 1026                The field is initialized in the XUU_PARAM block with
 1027                LU_FIRST={YES|NO}.
 1028                The default is NO.
 1029      */
 1030              3 LU_WHILE# BIT(1) UNAL %INIT(LU_WHILE)%EINIT,
 1031      /*K*      FLAGS.LU_WHILE# - BIT(1)
 1032
 1033                At a call to XUU$OPEN, specifies that a listing of
 1034                updates is to be made through the DCB specified (via
 1035                the parameter DCB) concurrently with processing of
 1036                source/update records.
 1037
 1038                The processor must produce the source listing in an
 1039                intermediate file to avoid the update record images
 1040                being inter-mixed with the source listing.  Most CP-6
 1041                language processors already do this, thus the LU_WHILE
 1042                option is meaningful to them.
 1043
 1044                Updates will be listed as they are used rather than as-read
 1045                which means that they will be listed in sync
 1046                with the lines returned to the user of XUU$READ.
 1047
 1048                The field is initialized in the XUU_PARAM block with
 1049                LU_WHILE={YES|NO}.
 1050                The default is NO.
 1051      */
 1052              3 OPT_UI# BIT(1) UNAL %INIT(OPT_UI)%EINIT,
 1053      /*K*      FLAGS.OPT_UI# - BIT(1)
 1054
 1055                At a call to XUU$OPEN, specifies that when UPDATE=YES is
 1056                specified and the update file does not exist, the
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      30   
 1057                error is to be ignored.
 1058
 1059                The field is initialized in the XUU_PARAM block with
 1060                OPT_UI={YES|NO}.
 1061                The default is NO.
 1062      */
 1063              3 FAST_BASE# BIT(1) UNAL %INIT(FAST_BASE) %EINIT,
 1064      /*K*      FLAGS.FAST_BASE# - BIT(1)
 1065
 1066                At a call to XUU$OPEN, if set, specifies that fast I/O is
 1067                to be used for the base source file, if possible.
 1068                If this flag is set, the fields ALLOCATE$$ and RELEASE$$
 1069                must also be set.  Failure to do so will result in an
 1070                error or an IPR fault.
 1071
 1072                The field is initialized in the XUU_PARAM block with
 1073                FAST_BASE={YES|NO}.
 1074                The default is NO.
 1075      */
 1076              3 FAST_UPDATE# BIT(1) UNAL %INIT(FAST_UPDATE) %EINIT,
 1077      /*K*      FLAGS.FAST_UPDATE# - BIT(1)
 1078
 1079                At a call to XUU$OPEN, if set, specifies that fast I/O is
 1080                to be used for the update file, if possible.
 1081                If this flag is set, the fields ALLOCATE$$ and RELEASE$$
 1082                must also be set.  Failure to do so will result in an
 1083                error or an IPR fault.
 1084
 1085                The field is initialized in the XUU_PARAM block with
 1086                FAST_UPDATE={YES|NO}.
 1087                The default is NO.
 1088      */
 1089              3 FAST_INCLUDE# BIT(1) UNAL %INIT(FAST_INCLUDE) %EINIT,
 1090      /*K*      FLAGS.FAST_INCLUDE# - BIT(1)
 1091
 1092                At a call to XUU$OPEN, if set, specifies that fast I/O is
 1093                to be used for the include files, if possible.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      31   
 1094                If this flag is set, the fields ALLOCATE$$ and RELEASE$$
 1095                must also be set.  Failure to do so will result in an
 1096                error or an IPR fault.
 1097
 1098                The field is initialized in the XUU_PARAM block with
 1099                FAST_INCLUDE={YES|NO}.
 1100                The default is NO.
 1101      */
 1102              3 * BIT(1) UNAL %INIT('0'B) %EINIT,
 1103              3 BAD_UPDATE# BIT(1) UNAL %INIT('0'B) %EINIT,
 1104      /*K*      FLAGS.BAD_UPDATE# - BIT(1)
 1105
 1106                On return from XUU$READ, if set, indicates that there currently
 1107                is a bad "plus" record in the buffer that the user may want
 1108                to print.
 1109      */
 1110              3 * BIT(1) UNAL %INIT('0'B)%EINIT,
 1111            2 LEVEL UBIN BYTE UNAL %INIT(0)%EINIT,
 1112      /*K*    LEVEL - UBIN BYTE
 1113
 1114              On return from XUU$OPEN, returns the nesting level
 1115              of the include file if an include file was just opened.
 1116
 1117              On return from XUU$READ, returns the nesting level
 1118              of the include file which the returned record was read
 1119              from.  Valid only if FLAGS.INCLUDE# is set.
 1120
 1121              FLAGS.LEVEL is set on any ALTRETURN from an XUU service
 1122              which also has FLAGS.INCLUDE# set.
 1123      */
 1124            2 ARS UBIN BYTE UNAL %INIT(0)%EINIT,
 1125      /*K*    ARS - UBIN BYTE
 1126
 1127              On return from XUU$READ, contains the size of the returned
 1128              record in bytes.
 1129      */
 1130            2 SI_ERRCODE,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      32   
 1131      /*K*    SI_ERRCODE - Standard CP-6 error code
 1132
 1133              This field exists for backward compatibility reasons only.
 1134              It contains the errcode of an error encountered on the base
 1135              source file.  It is only valid on an ALTRETURN from an XUU
 1136              service and only when FLAGS.BASE# is also set.
 1137              New users should always use ERRCODE to find their error codes.
 1138      */
 1139              3 FCG BIT(12) UNAL %INIT('0'B)%EINIT,
 1140              3 MID BIT(6) UNAL %INIT('0'B)%EINIT,
 1141              3 MON BIT(1) UNAL %INIT('0'B)%EINIT,
 1142              3 ERR# UBIN(14) UNAL %INIT(0)%EINIT,
 1143              3 SEV UBIN(3) UNAL %INIT(0)%EINIT,
 1144            2 SEQ_REC# REDEF SI_ERRCODE,
 1145              3 BASE# UBIN HALF UNAL,
 1146      /*K*      SEQ_REC#.BASE# - UBIN(18)
 1147
 1148                On return from XUU$READ, returns the sequential record number
 1149                last read from the base source file.
 1150      */
 1151              3 UP_INCL# UBIN HALF UNAL,
 1152      /*K*      SEQ_REC#.UP_INCL# - UBIN(18)
 1153
 1154                On return from XUU$READ, returns the sequential record number
 1155                last read from the update file if FLAGS.UP_DATE# is set
 1156                or from an include file if FLAGS.INCLUDE# is set.
 1157      */
 1158            2 UI_ERRCODE,
 1159      /*K*    UI_ERRCODE - Standard CP-6 error code
 1160
 1161              This field exists for backward compatibility reasons only.
 1162              It contains the errcode of an error encountered on the update
 1163              file.  It is only valid on an ALTRETURN from an XUU
 1164              service and only when FLAGS.UP_DATE# is also set.
 1165              New users should always use ERRCODE to find their error codes.
 1166      */
 1167              3 FCG BIT(12) UNAL %INIT('0'B)%EINIT,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      33   
 1168              3 MID BIT(6) UNAL %INIT('0'B)%EINIT,
 1169              3 MON BIT(1) UNAL %INIT('0'B)%EINIT,
 1170              3 ERR# UBIN(14) UNAL %INIT(0)%EINIT,
 1171              3 SEV UBIN(3) UNAL %INIT(0)%EINIT,
 1172            2 ERRCODE REDEF UI_ERRCODE,
 1173      /*K*    ERRCODE - A standard CP-6 error code
 1174
 1175              This field is always set with a standard CP-6 error code when an
 1176              XUU service ALTRETURNS.  The source of the error is indicated
 1177              by one of these flags:
 1178
 1179              .FIF
 1180              FLAGS.BASE#
 1181              FLAGS.UP_DATE#
 1182              FLAGS.INCLUDE#
 1183              FLAGS.SO_ERR#
 1184              FLAGS.XUU_ERR#
 1185              .FIN
 1186
 1187              The DCB# field may be necessary, in addition to ERRCODE, in order
 1188              to report the complete error message.
 1189      */
 1190              3 FCG BIT(12) UNAL,
 1191              3 MID BIT(6) UNAL,
 1192              3 MON BIT(1) UNAL,
 1193              3 ERR# UBIN(14) UNAL,
 1194              3 SEV UBIN(3) UNAL,
 1195            2 ASCII_KEY CHAR(10) %INIT(' ')%EINIT,
 1196      /*K*    ASCII_KEY - CHAR(10)
 1197
 1198              On return from XUU$READ, contains the ASCII text
 1199              for the EDIT key or sequential record number of the record
 1200              read.  The format may be determined from FLAGS.KEY_REC#.
 1201      */
 1202            2 RE_ASCII_KEY REDEF ASCII_KEY,
 1203      /*K*    RE_ASCII_KEY - Structure
 1204
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      34   
 1205              RE_ASCII_KEY is an alternate definition of ASCII_KEY.
 1206
 1207              RE_ASCII_KEY.CHAR1_9 contains the text of the key.
 1208
 1209              RE_ASCII_KEY.CHAR(10) contains a 1 character code as follows:
 1210              .SPF
 1211              .FIF
 1212              Blank - from source file
 1213              *     - from update file
 1214              +     - from include file
 1215              .FIN
 1216      */
 1217              3 CHAR1_9 CHAR(9),
 1218              3 CHAR10 CHAR(1),
 1219            2 O REDEF ASCII_KEY,
 1220              3 INCL_ERRCODE,
 1221      /*K*      O.INCL_ERRCODE - Standard CP-6 error code
 1222
 1223                This field exists for backward compatibility reasons only.
 1224                It contains the errcode of an error encountered on an
 1225                include file.  It is only valid on an ALTRETURN from an XUU
 1226                service and only when FLAGS.INCLUDE# is also set.
 1227                New users should always use ERRCODE to find their error codes.
 1228      */
 1229                4 FCG BIT(12) UNAL,
 1230                4 MID BIT(6) UNAL,
 1231                4 MON BIT(1) UNAL,
 1232                4 ERR# UBIN(14) UNAL,
 1233                4 SEV UBIN(3) UNAL,
 1234              3 FPT_PTR$ PTR UNAL,
 1235      /*K*      O.FPT_PTR$ - PTR
 1236
 1237                At a call to XUU$OPEN, supplies XUU$OPEN with a pointer to
 1238                an FPT_OPEN containing all the information necessary to open
 1239                an include file.  It is required that the FPT be supplied
 1240                when calling XUU$OPEN with FLAGS.INCLUDE# set.  It is also
 1241                required that the FPT not be in constant storage.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      35   
 1242      */
 1243              3 * BIT(18),
 1244            2 C REDEF ASCII_KEY,
 1245              3 INCL_ERRCODE,
 1246      /*K*      C.INCL_ERRCODE - Standard CP-6 error code
 1247
 1248                This field exists for backward compatibility reasons only.
 1249                It contains the errcode of an error encountered on an
 1250                include file.  It is only valid on an ALTRETURN from an XUU
 1251                service and only when FLAGS.INCLUDE# is also set.
 1252                New users should always use ERRCODE to find their error codes.
 1253      */
 1254                4 FCG BIT(12) UNAL,
 1255                4 MID BIT(6) UNAL,
 1256                4 MON BIT(1) UNAL,
 1257                4 ERR# UBIN(14) UNAL,
 1258                4 SEV UBIN(3) UNAL,
 1259              3 SO_ERRCODE,
 1260      /*K*      C.SO_ERRCODE - Standard CP-6 error code
 1261
 1262                This field exists for backward compatibility reasons only.
 1263                It contains the errcode of an error encountered on the source
 1264                output file.  It is only valid on an ALTRETURN from an XUU
 1265                service and only when FLAGS.SO_ERR# is also set.
 1266                New users should always use ERRCODE to find their error codes.
 1267      */
 1268                4 FCG BIT(12) UNAL,
 1269                4 MID BIT(6) UNAL,
 1270                4 MON BIT(1) UNAL,
 1271                4 ERR# UBIN(14) UNAL,
 1272                4 SEV UBIN(3) UNAL,
 1273              3 * BIT(18),
 1274            2 DCB# UBIN HALF UNAL %INIT(DCB)%EINIT,
 1275      /*K*    DCB# - UBIN HALF
 1276
 1277              At a call to XUU$OPEN, specifies the number of the DCB
 1278              through which to list updates when LU_FIRST or LU_WHILE
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      36   
 1279              is set.  The specified DCB must be initialized with any
 1280              header image, page number, default VFC character, etc.
 1281              The M$LO DCB is typically used for LU_FIRST.
 1282
 1283              The DCB# field may be initialized in the XUU_PARAM structure
 1284              with DCB=dcbnum.
 1285
 1286              On any altreturn condition involving an I/O error on a file,
 1287              DCB# will be set with the DCBNUM of the error so that the
 1288              user may pass it on to M$ERRMSG in order to get the fields
 1289              placed properly in the message.  The user should pass DCB#
 1290              on to M$ERRMSG with ERRCODE if DCB#~=DCBADDR(NIL) and
 1291              FLAGS.BASE#, .UP_DATE#, .INCLUDE#, or .SO_ERR# are set.
 1292      */
 1293            2 ALLOCATE$$ EPTR ALIGNED %INIT(ENTADDR(ALLOCATE)) %EINIT,
 1294      /*K*    ALLOCATE$$ - EPTR
 1295
 1296              At a call to XUU$OPEN or XUU$READ, specifies a routine to be
 1297              called to allocate fast I/O context buffers.  This routine will
 1298              be called as follows:
 1299
 1300              CALL XUU_PARAM.ALLOCATE$$(ret_vect, alloc_type);
 1301
 1302              Where:
 1303
 1304              ret_vect^^^^VECTOR ALIGNED which is to be filled in by the user's routine
 1305                        with a VECTOR framing the allocated area.
 1306
 1307              alloc_type^^^^a suggestion by XUU on the useful size of the area
 1308                           (see the macro XUU$ALLOC_TYPES).  This is only a
 1309                           suggested size; XUU will use whatever is framed by the
 1310                           returned vector as long as it is aligned on a word
 1311                           boundary and frames a multiple of 1024 words.
 1312
 1313              If ALLOCATE$$ is not specified and if one or more of the
 1314              flags:
 1315
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      37   
 1316              .FIF
 1317              FLAGS.FAST_BASE#
 1318              FLAGS.FAST_INCLUDE#
 1319              FLAGS.FAST_UPDATE#
 1320
 1321              .FIN
 1322              is set, an error or IPR fault will result.
 1323
 1324              The ALLOCATE$$ field may be initialized in XUU_PARAM with
 1325              ALLOCATE=proc-name.
 1326              The default is NIL.
 1327      */
 1328            2 RELEASE$$ EPTR ALIGNED %INIT(ENTADDR(RELEASE)) %EINIT,
 1329      /*K*    RELEASE$$ - EPTR
 1330
 1331              At a call to XUU$OPEN, XUU$READ or XUU$CLOSE, specifies
 1332              a procedure to be called to release fast I/O context buffers.
 1333              The routine will be called as follows:
 1334
 1335              CALL XUU_PARAM.RELEASE$$(rel_vect);
 1336
 1337              Where:
 1338
 1339                 rel_vect^^^^a VECTOR ALIGNED which frames the area to be
 1340                            released.
 1341
 1342              The context areas will always be released in the exact opposite
 1343              order that they were allocated, thus the user may assume that
 1344              the memory that XUU is allocating and releasing is being treated
 1345              as a stack.
 1346
 1347              If RELEASE$$ is not specified and one or more of the flags:
 1348
 1349              .FIF
 1350              FLAGS.FAST_BASE#
 1351              FLAGS.FAST_INCLUDE#
 1352              FLAGS.FAST_UPDATE#
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      38   
 1353
 1354              .FIN
 1355              is set, an error or IPR fault will result.
 1356
 1357              The RELEASE$$ field in the XUU_PARAM structure may be initialized
 1358              with RELEASE=proc name.
 1359              The default is NIL.
 1360      */
 1361            2 ERROR_PROC$$ EPTR ALIGNED %INIT(ENTADDR(ERROR_PROC)) %EINIT,
 1362      /*K*    ERROR_PROC$$ - EPTR
 1363
 1364              The ERROR_PROC$$ field specifies an optional routine to be called
 1365              to allow the user's program to report a recoverable
 1366              error encountered during XUU processing.  It will be called
 1367              as follows:
 1368
 1369              CALL XUU_PARAM.ERROR_PROC$$(errcode [,buf_vect]) ALTRET(QUIT)
 1370
 1371              Where:
 1372
 1373                errcode^^^^is an error code parameter in standard VLP_ERRCODE
 1374                        format containing the error.
 1375
 1376                buf_vect^^^^is an optional parameter which, if passed, is
 1377                         a vector framing the record that caused the error.
 1378
 1379              If no ERROR_PROC is supplied to XUU, or the ERROR_PROC altreturns
 1380              to XUU, XUU will assume that the error is fatal.
 1381      */
 1382            2 FULL_ARS UBIN %INIT(0)%EINIT,
 1383      /*K*    FULL_ARS - UBIN WORD
 1384
 1385              Contains a full word copy of ARS, for use when records can
 1386              exceed 511 characters.
 1387      */
 1388            2 * (0:3) UBIN %INIT(0*0)%EINIT;
 1389      /*N*    RFU */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      39   
 1390      %MEND;
 1391
 1392      %MACRO XUU$PARAM (FPTN=XUU$PARAM,
 1393                        STCLASS=BASED);
 1394      %XUU_PARAM (FPTN=FPTN,STCLASS=STCLASS);
 1395      %MEND;
 1396
 1397      /*F*
 1398      NAME: XUU$ENTRY
 1399      PURPOSE: Describe the XUU service entry points.
 1400      DESCRIPTION:
 1401         When the XUU$ENTRY macro is invoked, it declares all of the
 1402        XUU service entry points.
 1403      */
 1404      %MACRO XUU$ENTRY;
 1405      DCL XUU$OPEN ENTRY(1) ALTRET;
 1406      DCL XUU$READ ENTRY(2) ALTRET;
 1407      DCL XUU$CLOSE ENTRY(1) ALTRET;
 1408      %MEND;
 1409
 1410      /*F*
 1411      NAME: XUU$ALLOC_TYPES
 1412      PURPOSE:
 1413         This macro contains the EQUs for the different types of
 1414        buffer allocation that can be requested by XUU$READ for
 1415        doing fast file IO.
 1416      DESCRIPTION:
 1417        XUU$READ requests the user to allocate buffer space if the
 1418        user has requested fast file IO. XUU does this by calling
 1419        the EPTR, XUU$PARAM.ALLOCATE$$.  It passes two parameters
 1420        to this routine, a vector which is to be filled in by the
 1421        users allocation routine, and a UBIN WORD which contains
 1422        one of the EQUs set up in this macro. The user may choose
 1423        for himself the size buffer he wishes to allocate for each
 1424        different type, the only restriction is that all buffers
 1425        must be a multiple of 1024 words long.
 1426      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      40   
 1427
 1428      %MACRO XUU$ALLOC_TYPES;
 1429
 1430      %EQU XUU#ONE_PAGE      = 0 ;
 1431      /*K* XUU#ONE_PAGE - When this type allocation is requested the
 1432           user should allocate only one page since anything additional
 1433           will never be used.
 1434      */
 1435
 1436      %EQU XUU#N_PAGE_BASE   = 1 ;
 1437      /*K* XUU#N_PAGE_BASE - This type will be requested when opening the
 1438           base file and the base file is such that performance may be
 1439           improved by using a buffer which is larger than one page.
 1440           Suggested size is 4 pages, but the user must decide where
 1441           the tradeoff between memory usage and performance should be
 1442           made for his particular application.
 1443      */
 1444
 1445      %EQU XUU#N_PAGE_UPDATE = 2 ;
 1446      /*K* XUU#N_PAGE_UPDATE - Same as XUU#N_PAGE_BASE except for
 1447           the update file rather than the base source file.
 1448      */
 1449
 1450      %EQU XUU#N_PAGE_INCL   = 3 ;
 1451      /*K* XUU#N_PAGE_INCL - Same as XUU#N_PAGE_BASE except for
 1452           include files rather than for the base source file.
 1453      */
 1454
 1455      %MEND;
 1456
 1457      %EJECT;

15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      41   
 1458
 1459      %MACRO XUR_INIT (NAME=XUR_INIT,
 1460               ABORT = NIL,
 1461               CONTINUE = NIL,
 1462               BRKMSG = NIL,
 1463               PREPROCESS(YES='1'B,NO='0'B)='0'B,
 1464               COMMANDS(YES='1'B,NO='0'B)='1'B,
 1465               DONT_REREAD_CCBUF(YES='1'B,NO='0'B)='0'B,
 1466               DONT_STRIP_PROMPT(YES='1'B,NO='0'B)='0'B,
 1467               INHIBIT_DATE (YES='1'B, NO='0'B) = '0'B,
 1468               INHIBIT_DIRECTORY (YES='1'B, NO='0'B) = '0'B,
 1469               INHIBIT_DO (YES='1'B, NO='0'B) = '0'B,
 1470               INHIBIT_END (YES='1'B, NO='0'B) = '0'B,
 1471               INHIBIT_ERASE (YES='1'B, NO='0'B) = '0'B,
 1472               INHIBIT_HELP (YES='1'B, NO='0'B) = '0'B,
 1473               INHIBIT_NULL (YES='1'B, NO='0'B) = '0'B,
 1474               INHIBIT_OUTPUT (YES='1'B, NO='0'B) = '0'B,
 1475               INHIBIT_PRINT (YES='1'B, NO='0'B) = '0'B,
 1476               INHIBIT_QMARK (YES='1'B, NO='0'B) = '0'B,
 1477               INHIBIT_ENTER (YES='1'B, NO='0'B) = '0'B,
 1478               GOODCMD(YES='1'B,NO='0'B)='0'B,
 1479               ECHO(HONOR_FLAG=0,ALWAYS_ECHO=1,NEVER_ECHO=2)=0,
 1480               PASS(LEAVE=0,BLANK=1,MODE=2)=0,
 1481               SYNTAX (YES='1'B,NO='0'B)='1'B,
 1482               SPELLING(YES='1'B, NO='0'B)='1'B,
 1483               PCB = NIL,
 1484               WORK = NIL,
 1485               PRE_EXEC = NIL,
 1486               PPCB = NIL,
 1487               POST_EXEC = NIL,
 1488               MOREMEM = NIL,
 1489               PROCNAME = NIL,
 1490               PROCACCT = NIL,
 1491               PP_DCB = NIL,
 1492               PREPROCESSOR = NIL,
 1493               ADAPT =,
 1494               STCLASS = STATIC);
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      42   
 1495
 1496       %LSET LISTDIR='0'B;
 1497       %LSET LISTEXP='1'B;
 1498       %LSET LISTCOM='0'B;
 1499       %LSET LISTSUB='1'B;
 1500       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1501       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1502       (SUBSTR(STR,0,8)='CONSTANT') OR
 1503       (SUBSTR(STR,0,3)='EXT');
 1504       %LSET INIT=CHARTEXT('INIT');
 1505       %ELSE;
 1506       %LSET INIT=CHARTEXT('/*');
 1507       %ENDIF;
 1508
 1509      %IF LENGTHC(TEXTCHAR(ADAPT))=0;
 1510       %LSET ADAPT_ENT=CHARTEXT('ENTADDR(XTX$ADAPT)');
 1511       %IF XU$ADAPT_DEFINED='0'B AND INIT=CHARTEXT('INIT');
 1512        %SET XU$ADAPT_DEFINED='1'B;
 1513        DCL XTX$ADAPT ENTRY(2) ALTRET;
 1514       %ENDIF;
 1515      %ELSE;
 1516       %LSET ADAPT_ENT=CHARTEXT(CONCAT('ENTADDR(',TEXTCHAR(ADAPT),')'));
 1517      %ENDIF;
 1518
 1519      DCL 1 NAME DALIGNED STCLASS,
 1520               2 SYNTAX# BIT(1) %INIT(SYNTAX)%CHARTEXT('/**/'),
 1521               2 PREPROCESS# BIT(1) %INIT(PREPROCESS)%CHARTEXT('/**/'),
 1522            2 COMMANDS# BIT(1) %INIT(COMMANDS)%CHARTEXT('/**/'),
 1523            2 GOODCMD# BIT(1) %INIT(GOODCMD)%CHARTEXT('/**/'),
 1524            2 SPELLING# BIT(1) %INIT(SPELLING)%CHARTEXT('/**/'),
 1525            2 DONT_REREAD_CCBUF# BIT(1) %INIT(DONT_REREAD_CCBUF)%CHARTEXT('/**/'),
 1526            2 DONT_STRIP_PROMPT# BIT(1) %INIT(DONT_STRIP_PROMPT)%CHARTEXT('/**/'),
 1527            2 RFUBIT# BIT(20) %INIT('0'B)%CHARTEXT('/**/'),
 1528            2 VERSION_CODE UBIN BYTE CALIGNED %INIT(1)%CHARTEXT('/**/'),
 1529               2 ABORT$ EPTR %INIT(ENTADDR(ABORT))%CHARTEXT('/**/'),
 1530               2 CONTINUE$ EPTR %INIT(ENTADDR(CONTINUE))%CHARTEXT('/**/'),
 1531               2 BRKMSG$ EPTR %INIT(ENTADDR(BRKMSG))%CHARTEXT('/**/'),
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      43   
 1532               2 PCB$ PTR %INIT(ADDR(PCB))%CHARTEXT('/**/'),
 1533               2 WORKR_ VECTOR ALIGNED %INIT(VECTOR(WORK))%CHARTEXT('/**/'),
 1534               2 WORK_ REDEF WORKR_,
 1535                  3 BOUND UBIN (20) UNAL ,
 1536                  3 * BIT (16),
 1537                  3 PTR$ PTR ,
 1538            2 PRE_EXEC$$ EPTR %INIT(ENTADDR(PRE_EXEC))%CHARTEXT('/**/'),
 1539               2 PPCB$ PTR %INIT(ADDR(PPCB))%CHARTEXT('/**/'),
 1540            2 POST_EXEC$$ EPTR %INIT(ENTADDR(POST_EXEC))%CHARTEXT('/**/'),
 1541            2 MOREMEM$$ EPTR %INIT(ENTADDR(MOREMEM))%CHARTEXT('/**/'),
 1542            2 PROCNAME_ VECTOR %INIT(VECTOR(PROCNAME))%CHARTEXT('/**/'),
 1543               2 PP_DCB# UBIN HALF HALIGNED %INIT(DCBNUM(PP_DCB))%CHARTEXT('/**/'),
 1544               2 ECHO# UBIN HALF HALIGNED %INIT(ECHO)%CHARTEXT('/**/'),
 1545            2 PASS# UBIN HALF HALIGNED %INIT(PASS)%CHARTEXT('/**/'),
 1546            2 RFU10# UBIN HALF HALIGNED %INIT(0)%CHARTEXT('/**/'),
 1547               2 PROCACCT_ VECTOR %INIT(VECTOR(PROCACCT))%CHARTEXT('/**/'),
 1548               2 PREPROCESSOR$$ EPTR %INIT(ENTADDR(PREPROCESSOR))%CHARTEXT('/**/'),
 1549               2 INHIBITS,
 1550                  3 DATE# BIT (1) UNAL %INIT(INHIBIT_DATE)%CHARTEXT('/**/'),
 1551                  /*K*  INHIBIT_DATE = {YES | NO}  Specifies that the built-in
 1552                  commands DATE and TIME should not be recognized or executed.
 1553                  */
 1554                  3 DIRECTORY# BIT (1) UNAL %INIT(INHIBIT_DIRECTORY)%CHARTEXT('/**/'),
 1555                  /*K*  INHIBIT_DIRECTORY = {YES | NO}  Specifies that the built-in
 1556                  command DIRECTORY should not be recognized or executed.
 1557                  */
 1558                  3 DO# BIT (1) UNAL %INIT(INHIBIT_DO)%CHARTEXT('/**/'),
 1559                  /*K*  INHIBIT_DO = {YES | NO}  Specifies that the built-in
 1560                  commands DO and ! should not be recognized or executed.
 1561                  */
 1562                  3 END# BIT (1) UNAL %INIT(INHIBIT_END)%CHARTEXT('/**/'),
 1563                  /*K*  INHIBIT_END = {YES | NO}  Specifies that the built-in
 1564                  commands END, XIT, and QUIT should not be recognized or executed.*/
 1565                  3 ERASE# BIT (1) UNAL %INIT(INHIBIT_ERASE)%CHARTEXT('/**/'),
 1566                  /*K*  INHIBIT_ERASE = {YES | NO}  Specifies that the built-in
 1567                  command ERASE should not be recognized or executed.
 1568                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      44   
 1569                  3 HELP# BIT (1) UNAL %INIT(INHIBIT_HELP)%CHARTEXT('/**/'),
 1570                  /*K*  INHIBIT_HELP = {YES | NO}  Specifies that the built-in
 1571                  command HELP should not be recognized or executed.
 1572                  */
 1573                  3 NULL# BIT (1) UNAL %INIT(INHIBIT_NULL)%CHARTEXT('/**/'),
 1574                  /*K*  INHIBIT_NULL = {YES | NO}  Specifies that the built-in
 1575                  null (empty) command should not be recognized or executed.
 1576                  */
 1577                  3 OUTPUT# BIT (1) UNAL %INIT(INHIBIT_OUTPUT)%CHARTEXT('/**/'),
 1578                  /*K*  INHIBIT_OUTPUT = {YES | NO}  Specifies that the built-in
 1579                  command OUTPUT should not be recognized or executed.
 1580                  */
 1581                  3 PRINT# BIT (1) UNAL %INIT(INHIBIT_PRINT)%CHARTEXT('/**/'),
 1582                  /*K*  INHIBIT_PRINT = {YES | NO}  Specifies that the built-in
 1583                  command PRINT should not be recognized or executed.
 1584                  */
 1585                  3 QMARK# BIT (1) UNAL %INIT(INHIBIT_QMARK)%CHARTEXT('/**/'),
 1586                  /*K*  INHIBIT_QMARK = {YES | NO}  Specifies that the built-in
 1587                  commands ? and ?? should not be recognized or executed.
 1588                  */
 1589                  3 ENTER# BIT (1) UNAL %INIT(INHIBIT_ENTER)%CHARTEXT('/**/'),
 1590                  /*K*  INHIBIT_ENTER = {YES | NO}  Specifies that the built-in
 1591                  command ENTER should not be recognized or executed.
 1592                  */
 1593               2 ADAPT$$ EPTR %INIT(%ADAPT_ENT)%CHARTEXT('/**/'),
 1594               2 RFU_C00 (0:17) UBIN WORD %INIT(0*0)%CHARTEXT('/**/');
 1595      %MEND;
 1596                  /*F* NAME: XUG_GETCMD
 1597                  */
 1598      %MACRO XUG_GETCMD (NAME=XUG_GETCMD,
 1599               NODES = NIL,
 1600               ERRMFID = NIL,
 1601               XUH = NIL,
 1602               USE_EPOS (YES='1'B, NO='0'B) = '0'B,
 1603               TREAD (YES='1'B, NO='0'B) = '1'B,
 1604               CONTINUE_OK (YES='1'B, NO='0'B) = '1'B,
 1605               PROMPT_VFC (YES='1'B, NO='0'B) = '0'B,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      45   
 1606               SKIP_PREPROCESS (YES='1'B, NO='0'B)= '0'B,
 1607               ALWAYS_SET_PROMPT (YES='1'B, NO='0'B) = '0'B,
 1608               INFOMSG (YES='1'B, NO='0'B) = '0'B,
 1609               FLGLEV = 0,
 1610               EPOS = 0,
 1611               ERRMSG_VFC = ' ',
 1612               FCG = '0'B,
 1613               MON = '0'B,
 1614               CODE = 0,
 1615               SEV = 0,
 1616               ERRDCB = NIL,
 1617               INDCB = NIL,
 1618               OUTDCB = NIL,
 1619               DCB_PARAM = NIL,
 1620               DCB2_PARAM = NIL,
 1621               DISP(RELEASE=1, SCRATCH=1, SAVE=2, ANY) = 0,
 1622               F1 = NIL,
 1623               F2 = NIL,
 1624               F3 = NIL,
 1625               PROMPT = NIL,
 1626               RPROMPT = NIL,
 1627               PP_FUN = NIL,
 1628               READR = NIL,
 1629               SFROUTINE = NIL,
 1630               TEXT = NIL,
 1631       FPT = NIL,
 1632       UTIL = NIL,
 1633               STCLASS = STATIC);
 1634
 1635       %LSET LISTDIR='0'B;
 1636       %LSET LISTEXP='1'B;
 1637       %LSET LISTCOM='0'B;
 1638       %LSET LISTSUB='1'B;
 1639       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1640       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1641       (SUBSTR(STR,0,8)='CONSTANT') OR
 1642       (SUBSTR(STR,0,3)='EXT');
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      46   
 1643       %LSET INIT=CHARTEXT('INIT');
 1644       %ELSE;
 1645       %LSET INIT=CHARTEXT('/*');
 1646       %ENDIF;
 1647
 1648      DCL 1 NAME DALIGNED STCLASS,
 1649            2 NODES$ PTR %INIT(ADDR(NODES))%CHARTEXT('/**/'),
 1650                  /*K* NODES = PTR  Points to the top of the parse
 1651                  nodes.
 1652                  */
 1653            2 OUT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1654                  /*K*  OUT$ - PTR  Is a pointer returned by XUG$GETCMD into
 1655                  which either P_PCB.OUT$ or an error code
 1656                  is stored.  ERR# is a REDEF
 1657                  of OUT$ for the error code.
 1658                  */
 1659            2 ERR# REDEF OUT$,
 1660              3 FCG# BIT(18),
 1661              3 MON# BIT(1),
 1662              3 CODE# UBIN(14) UNAL,
 1663              3 SEV# UBIN(3) UNAL,
 1664                  /*K*  ERR# - standard CP-6 error code.  Is the error code that caused
 1665                  XUG$GETCMD to ALTRETURN.
 1666                  */
 1667            2 ERRMFID$ PTR %INIT(ADDR(ERRMFID))%CHARTEXT('/**/'),
 1668                  /*K*  ERRMFID = PTR  Points to the TEXTC string
 1669                  containing the fid of the error message file to be used
 1670                  on subsequent calls to XUG$ERRMSG. If ERRMFID$ = ADDR(NIL),
 1671                  the default error message file will be used.
 1672                  */
 1673            2 PCB$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1674                  /*K*  PCB$ - PTR  Is a pointer which will be set
 1675                  to the address of the X$PARSE Parse Control Block which
 1676                  was used by XUG$GETCMD.  If the PCB$ field in the XUG_INIT
 1677                  structure was non-NIL when XUG$INIT was called, PCB$ will
 1678                  be set equal to XUG_INIT.PCB$; otherwise, PCB$ will be set
 1679                  to the address of a PCB built in the XUG$GETCMD work area.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      47   
 1680                  */
 1681            2 WORK$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1682                  /*  WORK$       Pointer to the work area used by
 1683                  XUG$GETCMD_COMMON. This must be set by XUG$GETCMD or
 1684                  CXG$GETCMD before calling XUG$GETCMD_COMMON.
 1685                  */
 1686            2 XUH$ PTR %INIT(ADDR(XUH))%CHARTEXT('/**/'),
 1687                  /*K* XUH = PTR  Points to the parameter block
 1688                  passed to X$HELP and described in the discussion of the
 1689                  X$HELP service.
 1690                  */
 1691            2 USE_EPOS# BIT(1)%INIT(USE_EPOS)%CHARTEXT('/**/'),
 1692                  /*K*  USE_EPOS = {YES|NO}  Specifies, if set, to use EPOS#
 1693                  for the character position at which the error occurred.
 1694                  If reset, then P_PCB.HI_CHAR is to be used. The default
 1695                  is NO.
 1696                  */
 1697            2 TREAD# BIT(1) %INIT(TREAD)%CHARTEXT('/**/'),
 1698                  /*K*  TREAD = {YES|NO}  Specifies whether the command was
 1699                  read from a terminal or a file.  This determines whether
 1700                  or not the command line needs to be echoed.  If TREAD is
 1701                  set, the command came directly from the user's terminal,
 1702                  so it does not need to be echoed.  If TREAD is reset, the
 1703                  command may need to be echoed, subject to the setting of
 1704                  ECHO.  TREAD is maintained by the routine that reads
 1705                  command lines.  If that is a READR$ routine, that routine
 1706                  must set or reset XUG_GETCMD.TREAD# each time it is called.
 1707                  */
 1708            2 CONTINUED# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1709                  /*K*  CONTINUED# - BIT(1)  Specifies, if set, that XUG$GETCMD has read a
 1710                  continued command.  This flag is maintained by XUG$GETCMD.
 1711                  */
 1712            2 CONTINUE_OK# BIT(1) %INIT(CONTINUE_OK)%CHARTEXT('/**/'),
 1713                  /*K*  CONTINUE_OK = {YES|NO}  Specifies, if set, that the command can be
 1714                  continued. The default is YES. If NO is specified, XUG$GETCMD will
 1715                  return to the calling routine without getting another record.
 1716                  The flag CONTINUED# will be set.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      48   
 1717                  */
 1718            2 RCVD_PROMPT# BIT(1) %INIT('0'B)%CHARTEXT('/**/'),
 1719                  /*K*  RCVD_PROMPT# - BIT(1)  If set, specifies that XUG$GETCMD received
 1720                  the prompt specified by XUR_GETCMD.PROMPT_.  This flag is
 1721                  maintained by XUG$GETCMD.
 1722                  */
 1723            2 PROMPT_VFC# BIT(1) %INIT(PROMPT_VFC)%CHARTEXT('/**/'),
 1724                  /*K*  PROMPT_VFC = {YES|NO}  Specifies, if set, that the first character
 1725                  of the prompt and replacement prompt text is to be used as
 1726                  a VFC character.  The default
 1727                  is NO.
 1728                  */
 1729            2 SKIP_PREPROCESS# BIT(1) %INIT(SKIP_PREPROCESS)%CHARTEXT('/**/'),
 1730                /*K*  SKIP_PREPROCESS = {YES|NO}  Specifies that XUG$GETCMD is not to
 1731                do PRE-PROCESSing on the first record, but to do
 1732                PRE-PROCESSing on subsequent reads.  XUG$GETCMD will reset this bit
 1733                after XUG$GETCMD recognizes that it was set and XUG$GETCMD passed on
 1734                doing the PRE-PROCESSing.
 1735                */
 1736            2 ALWAYS_SET_PROMPT# BIT (1) %INIT(ALWAYS_SET_PROMPT)%CHARTEXT('/**/'),
 1737               /*K*  ALWAYS_SET_PROMPT = {YES|NO}  Is initialized by
 1738                     XUG$INIT from the ALWAYS_SET_PROMPT field in the
 1739                     XUG_INIT structure.  This field indicates that
 1740                     XUG$GETCMD must always issue
 1741                     an M$PROMPT before reading a command, even if the prompt
 1742                     specified does not appear to have been changed.
 1743               */
 1744            2 INFOMSG# BIT(1) %INIT(INFOMSG)%CHARTEXT('/**/'),
 1745              /*K* INFOMSG = {YES|NO}  Specifies that XUG$ERRMSG is not to
 1746              save the error code of the message issued.  The prior saved
 1747              error code, if any, remains unchanged.  (The saved error code
 1748              controls display of additional message levels in response to a
 1749              "?" command, and is passed to the dialog manager to indicate
 1750              command errors.)  It is reset on each call to XUG$ERRMSG after
 1751              it has been examined.  The default is NO.
 1752              */
 1753            2 FLGLEV# UBIN BYTE CALIGNED %INIT(FLGLEV)%CHARTEXT('/**/'),
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      49   
 1754                  /*K*  FLGLEV = VALUE-DEC(0-4)  Specifies
 1755                  the number of asterisks to print in front of the error
 1756                  message.  The default is 0.
 1757                  */
 1758            2 EPOS# UBIN HALF HALIGNED %INIT(EPOS)%CHARTEXT('/**/'),
 1759                  /*K*  EPOS = VALUE-DEC(0-?)  On return, specifies the
 1760                  character position at which an error occurred. Refer to
 1761                  USE_EPOS#.
 1762                  */
 1763            2 ERRMSG_VFC# CHAR(1) CALIGNED %INIT(ERRMSG_VFC)%CHARTEXT('/**/'),
 1764                  /*K*  ERRMSG_VFC = VALUE-CHAR(1)  Specifies a VFC character to be used
 1765                  by M$ERRMSG.  If ERRMSG_VFC = ' ', the default VFC character
 1766                  will be used.
 1767                  */
 1768            2 ECHO UBIN (2) UNAL %INIT(0)%CHARTEXT('/**/'),
 1769                  /*K* ECHO - {HONOR_FLAG|ALWAYS_ECHO|NEVER_ECHO}  Is
 1770                        initialized by XUG$INIT from the ECHO field in the
 1771                        XUG_INIT structure.  HONOR_FLAG indicates that
 1772                        XUG$GETCMD will echo the command if, and only if
 1773                        the user's echo flag is set.  ALWAYS_ECHO indicates
 1774                        that XUG$GETCMD will echo the command through the
 1775                        user's echo DCB.  NEVER_ECHO indicates that
 1776                        XUG$GETCMD will not echo the command.
 1777                  */
 1778            2 PASS UBIN (2) UNAL %INIT(0)%CHARTEXT('/**/'),
 1779                  /*K* PASS - {LEAVE|BLANK|MODE}  Is initialized by XUG$INIT
 1780                       from the PASS field in the XUG_INIT structure.  BLANK
 1781                       indicates the passwords will be blanked.  LEAVE
 1782                       indicates that the passwords should not be blanked.
 1783                       MODE means that passwords will be blanked according
 1784                       to the mode:  they will be blanked for all modes
 1785                       except ONLINE.
 1786                  */
 1787            2 RFUBIT2 BIT (5) UNAL,
 1788            2 EOMCHAR# CHAR (1),
 1789                 /*K* EOMCHAR# - CHAR(1).  Is a value maintained by XUG$GETCMD
 1790                       which contains the activation character that
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      50   
 1791                       completed the most recent command.  If XUG$GETCMD
 1792                       receives its command from an activation-less source (e.g., a disk file),
 1793                       EOMCHAR# will contain %EOM_EOR# ('501'O).
 1794                 */
 1795            2 RFUBYTE UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
 1796            2 ERR_CODE ALIGNED,
 1797              3 FCG# BIT(18) %INIT(FCG) %CHARTEXT('/**/'),
 1798              3 MON# BIT(1) %INIT(MON) %CHARTEXT('/**/'),
 1799              3 CODE# UBIN(14) UNAL %INIT(CODE) %CHARTEXT('/**/'),
 1800              3 SEV# UBIN(3) UNAL %INIT(SEV) %CHARTEXT('/**/'),
 1801                  /*K*  ERR_CODE - standard CP-6
 1802                  error code.  If set to '0'B, causes the severity field of
 1803                  the last code to be incremented.  In this case, if the
 1804                  severity field exceeds 7 or no message is found,
 1805                  the alternate return is taken.
 1806                  */
 1807            2 ERRDCB# SBIN %INIT(DCBNUM(ERRDCB)) %CHARTEXT('/**/'),
 1808                  /*K*  ERRDCB = VALUE-DEC(0-?)  Is the DCB number of the DCB
 1809                  on which the error occurred. ERRDCB# is used to obtain
 1810                  variable information which is substituted into the
 1811                  message for special strings %FN, %AC, etc.  If an error
 1812                  message contains those special strings and ERRDCB# = DCBNUM(NIL),
 1813                  the default, then blanks are substituted, or the
 1814                  conditional phrase is not printed.
 1815                  For a discussion of Field and Phrase Substitution, see
 1816                  M$ERRMSG in the Host Monitor Services Reference Manual
 1817                  (CE74).
 1818                  */
 1819            2 INDCB# SBIN %INIT(DCBNUM(INDCB)) %CHARTEXT('/**/'),
 1820                  /*K*  INDCB = VALUE-DEC(0-?)  Is the DCB number of the input
 1821                  DCB.  The default is DCBNUM(NIL), in which case M$SI
 1822                  is used.
 1823                  */
 1824            2 OUTDCB# SBIN %INIT(DCBNUM(OUTDCB)) %CHARTEXT('/**/'),
 1825                  /*K* OUTDCB = VALUE-DEC(0-?)  Is the DCB number of the output
 1826                  DCB.  The default is DCBNUM(NIL).
 1827                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      51   
 1828            2 DCB_PARAM# SBIN %INIT(DCBNUM(DCB_PARAM)) %CHARTEXT('/**/'),
 1829                  /*K* DCB_PARAM = VALUE-DEC(0-?)  The DCB number of the DCB to be used by
 1830                  the routine being called as the output DCB.  The default is
 1831                  DCBNUM(NIL).
 1832                  */
 1833            2 DCB2_PARAM# SBIN %INIT(DCBNUM(DCB2_PARAM)) %CHARTEXT('/**/'),
 1834                  /*K* DCB2_PARAM = VALUE-DEC(0-?)  Is the DCB number of the
 1835                  second DCB
 1836                  parameter to be used by a routine that has two DCB parameters,
 1837                  e.g., XUG$ERRMSG.  The default is DCBNUM(NIL).
 1838                  */
 1839            2 DISP# UBIN WORD %INIT(DISP) %CHARTEXT('/**/'),
 1840                  /*K* DISP = {SAVE|RELEASE}  Is the DISP to be used by XUG$CLOSE_DCBS.
 1841                  For legal %EQUs, see M$CLOSE in the Host Monitor Services
 1842                  Reference Manual (CE74).  The default is 0, which
 1843                  means SAVE unless FPRG.
 1844                  */
 1845            2 F1_ VECTOR ALIGNED %INIT(VECTOR(F1))%CHARTEXT('/**/'),
 1846                  /*K*  F1 = VARIABLE   Is a vector framing the TEXTC string for
 1847                  %U1 substitution.
 1848                  */
 1849            2 F2_ VECTOR ALIGNED %INIT(VECTOR(F2))%CHARTEXT('/**/'),
 1850                  /*K*  F2 = VARIABLE   Is a vector framing the TEXTC string for
 1851                  %U2 substitution.
 1852                  */
 1853            2 F3_ VECTOR ALIGNED %INIT(VECTOR(F3))%CHARTEXT('/**/'),
 1854                  /*K*  F3 = VARIABLE   Is a vector framing the TEXTC string for
 1855                  %U3 substitution.
 1856                  */
 1857            2 PROMPT_ VECTOR ALIGNED %INIT(VECTOR(PROMPT))%CHARTEXT('/**/'),
 1858                  /*K*  PROMPT = VARIABLE   Frames the prompt to use when
 1859                 reading commands from the terminal.
 1860                  */
 1861            2 RPROMPT_ VECTOR ALIGNED %INIT(VECTOR(RPROMPT))%CHARTEXT('/**/'),
 1862                  /*K*  RPROMPT = VARIABLE   Is a vector framing the replacement
 1863                  prompt.  If specified, this string replaces the actual
 1864                  prompt when the command is echoed.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      52   
 1865                  */
 1866            2 PP_FUN$$ EPTR %INIT(ENTADDR(PP_FUN))%CHARTEXT('/**/'),
 1867                  /*K*  PP_FUN = EPTR  Points to the
 1868                  user-supplied routine to handle user-defined preprocessor
 1869                  functions, as described under the X$EVAL service.
 1870                  */
 1871            2 READR$$ EPTR %INIT(ENTADDR(READR))%CHARTEXT('/**/'),
 1872                  /*K*  READR = EPTR  Points to a procedure
 1873                  to be called to get the command record to be parsed, usually
 1874                  NOT from COMMAND STREAM.
 1875                  If the last record is continued, XUG$GETCMD will use
 1876                  FPT_GETCMD.READR$$ to decide where to get the next record.
 1877                  Every time that the READR$ is called, XUG$GETCMD must receive a
 1878                  record.  It is the READR$ routine's responsibility to set
 1879                  the XUG_GETCMD.TREAD# flag to indicate whether the command
 1880                  was read from the terminal or not.
 1881                  All VFC and PROMPT characters must be removed from
 1882                  the buffer before return to XUG$GETCMD.
 1883
 1884                  The READR$ routine is called as follows:
 1885
 1886                  CALL READR$ (buf,ars,readr$[,err][,eomchar]) ALTRET (label);
 1887
 1888                  where:
 1889
 1890                  buf^^^^is a vector framing a 300 character buffer to
 1891                  contain the record read.
 1892
 1893                  ars^^^^ is an SBIN word to contain the actual record size
 1894                  of the record read.
 1895
 1896                  readr$^^^^is an EPTR initialized to the address of the
 1897                  READR$ routine, that is used to reset SUB_GETCMD.READR$
 1898                  on return.
 1899
 1900                  err^^^^returns a standard CP-6 error code to be passed on
 1901                  to the caller of XUG$GETCMD when the routine altreturns.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      53   
 1902
 1903                  eomchar^^^^returns the activation character that completes
 1904                  the read.
 1905                  */
 1906            2 SFROUTINE$ EPTR %INIT(ENTADDR(SFROUTINE))%CHARTEXT('/**/'),
 1907                  /*K*  SFROUTINE = EPTR  Points to a procedure
 1908                  to be called for success, failure, and preparse nodes.
 1909
 1910                  .cba
 1911                  The calling sequence is
 1912
 1913                  CALL user_routine ( parse_param );
 1914
 1915                  where:
 1916
 1917                  parse_param^^^^is the PARSE$PARAM parameter block supplied
 1918                  by X$PARSE,
 1919                  ..::HL "as described in Section 10 of this manual.\"
 1920                  ..::HL "\as described in HELP (HOSTLIB) X$PARSE."
 1921                  .cbf
 1922                  */
 1923            2 TEXT_ VECTOR ALIGNED %INIT(VECTOR(TEXT))%CHARTEXT('/**/') ,
 1924                  /*K* TEXT = VARIABLE  Is a vector framing a text string to be
 1925                  used as the first line of input to the parser when input is
 1926                  to be read from other than the input DCB (e.g., from JIT.CCBUF).
 1927                  The default is VECTOR(NIL).
 1928                  */
 1929            2 XT_PARAM$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1930                  /*K* XT_PARAM$ - PTR  Points the the parameter block
 1931                  passed to XTX$ADAPT when the program is running under a
 1932                  dialog.  See the CP-6 ADAPT Reference (HA12) for more
 1933                  information.
 1934                  */
 1935                                              /*    RFU - Reserved for Future Use.  */
 1936            2 RFU2$ EPTR %INIT(ENTADDR(NIL))%CHARTEXT('/**/'),
 1937            2 BUF$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1938              /*K* BUF$ - PTR   Returns the address of the buffer containing
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      54   
 1939                   the command read by XUG$GETCMD.   RLT$ points to an array
 1940                   containing information on how to interpret this buffer.
 1941              */
 1942            2 RLT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1943              /*K* RLT$ - PTR   Returns the address of an array containing
 1944                   the length of each line of a command read by XUG$GETCMD.
 1945                   The XUG_RLT macro describes the structure of this array.
 1946                   The NLINES field in this structure defines the size of
 1947                   the array.
 1948              */
 1949            2 SYNERR_NODES$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1950               /*K* SYNERR_NODES$ - PTR  Is a pointer returned by GETCMD, which
 1951                     points to the root of the syntax tree on which the most recent
 1952                     syntax error occurred.  This value is retained so that the
 1953                     "enter a ? for spelling correction and/or legal choices" code
 1954                     will work correctly even if the NODES$ pointer is altered by
 1955                     the user between calls to XUG$GETCMD.
 1956               */
 1957             2 FPT$ PTR %INIT(ADDR(FPT))%CHARTEXT('/**/'),
 1958               /*K* FPT$ - PTR  Points to a monitor service FPT
 1959                    for use by the routine called.
 1960               */
 1961             2 UTIL$ PTR %INIT(ADDR(UTIL))%CHARTEXT('/**/'),
 1962               /*K* UTIL = VARIABLE  Locates an additional parameter
 1963                    for use by the routine called.
 1964               */
 1965            2 PP_ROOT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 1966                 /*K*  PP_ROOT$ - PTR  Is initialized by XUG$INIT from the PP_ROOT
 1967                       parameter of XUG_INIT.  Holds a pointer to the root of the
 1968                       function tree which is to be passed to X$PRE_PROCESS.
 1969                       (See XUE_PPCB.ROOT$ for details).  If PP_ROOT$ is
 1970                       NIL, GETCMD will
 1971                       pass the standard function tree (XUE_PREEXP) to X$PRE_PROCESS.
 1972                       This field is ignored if a non-NIL PPCB was specified in the
 1973                       XUG_INIT structure;  in this case, the ROOT$ field in that
 1974                       PPCB is honored.
 1975                 */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      55   
 1976            2 NLINES SBIN HALF HALIGNED %INIT(0)%CHARTEXT('/**/'),
 1977              /*K* NLINES - SBIN HALF   Returns the number of lines of a
 1978                   command read by XUG$GETCMD.
 1979              */
 1980            2 RFU9# UBIN HALF HALIGNED %INIT(0)%CHARTEXT('/**/'),
 1981            2 RFU10# UBIN %INIT(0)%CHARTEXT('/**/'),
 1982            2 RFU11# UBIN %INIT(0)%CHARTEXT('/**/'),
 1983            2 RFU12# UBIN %INIT(0)%CHARTEXT('/**/');
 1984      %MEND;
 1985
 1986
 1987                 /*F* NAME:  XUG_INIT
 1988                 */
 1989      %MACRO XUG_INIT (NAME=XUG_INIT,
 1990               ABORT = NIL,
 1991               CONTINUE = NIL,
 1992               BRKMSG = NIL,
 1993               SPHANDLE = NIL,
 1994               PRE_EXEC = NIL,
 1995               POST_EXEC = NIL,
 1996               MOREMEM = NIL,
 1997               PREPROCESSOR = NIL,
 1998               ADAPT =,
 1999               PROCNAME = NIL,
 2000               PROCACCT = NIL,
 2001               WORK = NIL,
 2002               PCB = NIL,
 2003               PPCB = NIL,
 2004               PP_PROCNAME = NIL,
 2005               PP_ROOT = NIL,
 2006               CMDSZ = 300,
 2007               ADDL_NRECS = 100,
 2008               ECHO(HONOR_FLAG=0,ALWAYS_ECHO=1,NEVER_ECHO=2)=0,
 2009               PASS(LEAVE=0,BLANK=1,MODE=2)=0,
 2010               INIT_NRECS = 100,
 2011               PP_DCB = NIL,
 2012               WSEG = 0,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      56   
 2013               COMMANDS(YES='1'B, NO='0'B)='1'B,
 2014               INHIBIT_DATE (YES='1'B, NO='0'B) = '0'B,
 2015               INHIBIT_DIRECTORY (YES='1'B, NO='0'B) = '0'B,
 2016               INHIBIT_DO (YES='1'B, NO='0'B) = '0'B,
 2017               INHIBIT_END (YES='1'B, NO='0'B) = '0'B,
 2018               INHIBIT_ERASE (YES='1'B, NO='0'B) = '0'B,
 2019               INHIBIT_HELP (YES='1'B, NO='0'B) = '0'B,
 2020               INHIBIT_NULL (YES='1'B, NO='0'B) = '0'B,
 2021               INHIBIT_OUTPUT (YES='1'B, NO='0'B) = '0'B,
 2022               INHIBIT_PRINT (YES='1'B, NO='0'B) = '0'B,
 2023               INHIBIT_QMARK (YES='1'B, NO='0'B) = '0'B,
 2024               INHIBIT_ENTER (YES='1'B, NO='0'B) = '0'B,
 2025               PREPROCESS(YES='1'B,NO='0'B)='0'B,
 2026               REQ_PROMPT(YES='1'B, NO='0'B)='0'B,
 2027               SYNTAX (YES='1'B,NO='0'B)='1'B,
 2028               GOODCMD (YES='1'B,NO='0'B)='0'B,
 2029               SPELLING (YES='1'B,NO='0'B)='1'B,
 2030               ALWAYS_SET_PROMPT (YES='1'B, NO='0'B)='0'B,
 2031               NO_DOWNGRADE (YES='1'B, NO='0'B) = '0'B,
 2032               DONT_REREAD_CCBUF (YES='1'B, NO='0'B) = '0'B,
 2033               DONT_STRIP_PROMPT (YES='1'B, NO='0'B) = '0'B,
 2034               STCLASS = STATIC);
 2035
 2036       %LSET LISTDIR='0'B;
 2037       %LSET LISTEXP='1'B;
 2038       %LSET LISTCOM='0'B;
 2039       %LSET LISTSUB='1'B;
 2040       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2041       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2042       (SUBSTR(STR,0,8)='CONSTANT') OR
 2043       (SUBSTR(STR,0,3)='EXT');
 2044       %LSET INIT=CHARTEXT('INIT');
 2045       %ELSE;
 2046       %LSET INIT=CHARTEXT('/*');
 2047       %ENDIF;
 2048
 2049      %IF LENGTHC(TEXTCHAR(ADAPT))=0;
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      57   
 2050       %LSET ADAPT_ENT=CHARTEXT('ENTADDR(XTX$ADAPT)');
 2051       %IF XU$ADAPT_DEFINED='0'B AND INIT=CHARTEXT('INIT');
 2052        %SET XU$ADAPT_DEFINED='1'B;
 2053        DCL XTX$ADAPT ENTRY(2) ALTRET;
 2054       %ENDIF;
 2055      %ELSE;
 2056       %LSET ADAPT_ENT=CHARTEXT(CONCAT('ENTADDR(',TEXTCHAR(ADAPT),')'));
 2057      %ENDIF;
 2058
 2059      DCL 1 NAME DALIGNED STCLASS,
 2060            2 ABORT$ EPTR %INIT(ENTADDR(ABORT))%CHARTEXT('/**/'),
 2061                  /*K*  ABORT = EPTR  Points to a procedure to
 2062                  be called when the user wants to abort the command being
 2063                  read.  ABORT must not be NIL and must not RETURN or
 2064                  ALTRETURN if XUG$BREAK is to be used.  The BREAK frame
 2065                  will be removed from the TCB before XUG$GETCMD_COMMON
 2066                  calls the ABORT routine.
 2067                  */
 2068            2 CONTINUE$ EPTR %INIT(ENTADDR(CONTINUE))%CHARTEXT('/**/'),
 2069                  /*K*  CONTINUE = EPTR  Points to a procedure to
 2070                  be called when a user wants to continue after interruption
 2071                  due to a break. CONTINUE is optional.  The BREAK frame
 2072                  will still be present on the TCB when the continue routine
 2073                  is entered after the call by XUG$GETCMD_COMMON.
 2074                  */
 2075            2 BRKMSG$ EPTR %INIT(ENTADDR(BRKMSG))%CHARTEXT('/**/'),
 2076                  /*K*  BRKMSG = EPTR  Points to a procedure to
 2077                  be called to output a break message when a break has been
 2078                  received.  BRKMSG is optional; if it is not supplied, or if the
 2079                  BRKMSG routine altreturns, the standard message "Break!  C to
 2080                  continue." is output.
 2081                  */
 2082            2 SPHANDLE$ EPTR %INIT(ENTADDR(SPHANDLE))%CHARTEXT('/**/'),
 2083                  /*K*  SPHANDLE = EPTR  Points to a procedure
 2084                  to be called before another record is read on a continued
 2085                  command.
 2086
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      58   
 2087                  .cba
 2088                  The calling sequence is
 2089
 2090                  CALL user_routine ( xug_getcmd , parse_param );
 2091
 2092                  where:
 2093
 2094                  xug_getcmd^^^^is the XUG_GETCMD structure passed to XUG$GETCMD.
 2095
 2096                  parse_param^^^^is the PARSE$PARAM parameter block supplied
 2097                  by X$PARSE,
 2098                  ..::HL "as described in Section 10 of this manual.\"
 2099                  ..::HL "\as described in HELP (HOSTLIB) X$PARSE."
 2100                  .cbf
 2101                  */
 2102            2 PRE_EXEC$$ EPTR %INIT(ENTADDR(PRE_EXEC))%CHARTEXT('/**/'),
 2103                  /*K*  PRE_EXEC = EPTR  Points to a procedure
 2104                  to be called BEFORE one of the built-in commands is
 2105                  executed.
 2106
 2107                  .cba
 2108                  The calling sequence is
 2109
 2110                  CALL user_routine ( xug_getcmd , node-code ) [ ALTRET ( label ) ];
 2111
 2112                  where:
 2113
 2114                  xug_getcmd^^^^is the XUG_GETCMD structure passed to
 2115                  XUG$GETCMD.
 2116
 2117                  node-code^^^^is the parse node code for the built-in
 2118                  command being processed, as defined by EQUs of the form
 2119                  %XUG_CMD_? in the XU_SUBS_C include file.
 2120
 2121                  Note:  If an ALTRETurn occurs, the error code in
 2122                  xug_getcmd.ERR# will be reported in the same way as other
 2123                  errors in processing a built-in command.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      59   
 2124                  .cbf
 2125                  */
 2126            2 POST_EXEC$$ EPTR %INIT(ENTADDR(POST_EXEC))%CHARTEXT('/**/'),
 2127                  /*K*  POST_EXEC = EPTR  Points to a procedure
 2128                  to be called AFTER one of the built-in commands is
 2129                  executed.
 2130
 2131                  .cba
 2132                  The calling sequence is
 2133
 2134                  CALL user_routine ( xug_getcmd , node-code ) [ ALTRET ( label ) ];
 2135
 2136                  where:
 2137
 2138                  xug_getcmd^^^^is the XUG_GETCMD structure passed to
 2139                  XUG$GETCMD.
 2140
 2141                  node-code^^^^is the parse node code for the built-in
 2142                  command being processed, as defined by EQUs of the form
 2143                  %XUG_CMD_? in the XU_SUBS_C include file.
 2144
 2145                  Note:  If an ALTRETurn occurs, the error code in
 2146                  xug_getcmd.ERR# will be reported in the same way as other
 2147                  errors in processing a built-in command.
 2148                  .cbf
 2149                  */
 2150            2 MOREMEM$$ EPTR %INIT(ENTADDR(MOREMEM))%CHARTEXT('/**/'),
 2151                  /*K*  MOREMEM = EPTR  Points to a procedure
 2152                  to be called if XUG$GETCMD needs more memory and the user
 2153                  maintains the memory for XUG$GETCMD.
 2154
 2155                  .cba
 2156                  The calling sequence is
 2157
 2158                  CALL user_routine ( words-needed , work-vector , errcode ) [ALTRET ( label )];
 2159
 2160                  where:
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      60   
 2161
 2162                  words-needed^^^^is a  SBIN WORD containing the number of
 2163                  words needed.  If positive, this is a request to allocate
 2164                  more memory.  If negative, this is a request to free
 2165                  memory.
 2166
 2167                  work-vector^^^^returns a vector framing the entire work
 2168                  area on a normal return.  The returned vector is checked
 2169                  to insure that an area of the proper size has
 2170                  been allocated or freed contiguous with the old
 2171                  work area.
 2172
 2173                  errcode^^^^returns a standard CP-6 error code to be passed
 2174                  back to the caller of XUG$GETCMD when the MOREMEM routine
 2175                  altreturns.
 2176                  .cbf
 2177                  */
 2178            2 PREPROCESSOR$$ EPTR %INIT(ENTADDR(PREPROCESSOR))%CHARTEXT('/**/'),
 2179                  /*K*  PREPROCESSOR = EPTR  Points to a procedure
 2180                  to be called to do XUG$GETCMD's preprocessing.
 2181                  If PREPROCESSOR = NIL then no preprocessing will be
 2182                  performed; if PREPROCESSOR is equal to the ENTADDR of a
 2183                  pre-processing routine (normally X$PRE_PROCESS), then the
 2184                  specified routine will be called to perform any necessary
 2185                  pre-processing.  The default is NIL.
 2186                  */
 2187            2 PROCNAME_ VECTOR %INIT(VECTOR(PROCNAME))%CHARTEXT('/**/'),
 2188                  /*K*  PROCNAME_ = VARIABLE    Locates a VLP_NAME area
 2189                  containing the name of the processor for which a HELP
 2190                  message is requested.
 2191                  */
 2192            2 PROCACCT_ VECTOR %INIT(VECTOR(PROCACCT))%CHARTEXT('/**/'),
 2193                  /*K*  PROCACCT_ = VARIABLE    Locates a VLP_ACCT area
 2194                  containing the account of the processor for which a HELP
 2195                  message is requested.  The default, NIL, is the account of
 2196                  the currently running processor.
 2197                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      61   
 2198            2 PARAMS$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2199                  /*K*  PARAMS$ - PTR  Is a pointer into which the
 2200                  address of the XUG_PARAMS structure will be returned.
 2201                  */
 2202            2 WORK_ VECTOR ALIGNED %INIT (VECTOR(WORK)) %CHARTEXT('/**/'),
 2203                  /*K*  WORK = VARIABLE  Locates an area of memory
 2204                  (which must be at least 500 words long and must contain
 2205                  an integral number of doublewords) which XUG$GETCMD is
 2206                  to use for its parse control block, input buffer,
 2207                  parse work area, and other data.
 2208                  This field is optional.  If WORK_ is set to
 2209                  VECTOR(NIL), the default, then XUG$GETCMD will allocate
 2210                  a work area using the segment number specified in
 2211                  XUG_INIT.WSEG#.  If the user specifies a work area
 2212                  through WORK_, this area will not be expanded by
 2213                  XUG$GETCMD_COMMON.
 2214                  */
 2215            2 PCB$ PTR %INIT(ADDR(PCB))%CHARTEXT('/**/'),
 2216                  /*K*  PCB = PTR  Is an optional pointer which, if
 2217                  present, will point to the Parse Control Block which
 2218                  XUG$GETCMD  is to use when calling X$PARSE. The default
 2219                  is NIL, which indicates that XUG$INIT is to build a PCB
 2220                  in its work area.
 2221                  */
 2222            2 PPCB$ PTR %INIT(ADDR(PPCB))%CHARTEXT('/**/'),
 2223                  /*K*  PPCB = PTR  Points to the Preprocessor's
 2224                  Control Block. This is passed to X$PRE_PROCESS if the flag
 2225                  PREPROCESS# is set.
 2226                  */
 2227            2 PP_PROCNAME_ VECTOR ALIGNED %INIT(VECTOR(PP_PROCNAME))%CHARTEXT('/**/'),
 2228                  /*K*    PP_PROCNAME = VARIABLE  Is a vector framing the name
 2229                  of the processor that is using X$EVAL. The name must be in
 2230                  TEXTC form, preferrably stored in a VLP_NAME structure.  If
 2231                  PP_PROCNAME is NIL then the default will be taken from M$LM.
 2232                  */
 2233            2 CMDSZ# UBIN WORD ALIGNED %INIT(CMDSZ)%CHARTEXT('/**/'),
 2234                  /*K*  CMDSZ = VALUE-DEC(0-?)  Specifies the length of a command
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      62   
 2235                  line.  For commands greater than CMDSZ# in length the command
 2236                  will have to be continued. The maximum value possible for
 2237                  CMDSZ# is 300, the default.
 2238                  */
 2239            2 ADDL_NRECS# UBIN HALF CALIGNED %INIT(ADDL_NRECS)%CHARTEXT('/**/'),
 2240                  /*K*  ADDL_NRECS = VALUE-DEC(0-?)  Specifies the number of entries
 2241                  to be added to the array for the character position table of
 2242                  the records read due to continuation. The default is 100.
 2243                  This number specifies how many continued records
 2244                  can be read before having to expand the table again.
 2245                  */
 2246            2 INIT_NRECS# UBIN HALF CALIGNED %INIT(INIT_NRECS)%CHARTEXT('/**/'),
 2247                  /*K*  INIT_NRECS = VALUE-DEC(0-?)  Specifies the initial number of
 2248                  entries in the array for the character position table of the
 2249                  records read due to continuation.  This
 2250                  number specifies how many continued records can be read before
 2251                  having to expand the table.  The default is 100.
 2252                  */
 2253            2 ECHO# UBIN BYTE CALIGNED %INIT(ECHO)%CHARTEXT('/**/'),
 2254                  /*K*  ECHO = {HONOR_FLAG|ALWAYS_ECHO|NEVER_ECHO}  Indicates
 2255                  whether to ECHO the
 2256                  command or not.  HONOR_FLAG indicates
 2257                  that XUG$GETCMD will echo the command if, and only if the
 2258                  user's ECHO flags is set.  ALWAYS_ECHO indicates that
 2259                  XUG$GETCMD will echo the command through the user's echo
 2260                  DCB.  NEVER_ECHO indicates that XUG$GETCMD will not echo
 2261                  the command.  The default is HONOR_FLAG.
 2262                  */
 2263            2 PASS# UBIN BYTE CALIGNED %INIT(PASS)%CHARTEXT('/**/'),
 2264                  /*K*  PASS = {LEAVE|BLANK|MODE}  Indicates whether the PASSWORD
 2265                  should be blanked or not.  BLANK indicates the passwords will
 2266                  be blanked.  LEAVE indicates that the passwords should not be
 2267                  blanked.  MODE means that passwords will be blanked according
 2268                  to the mode:  they will be blanked for all modes except ONLINE.
 2269                  The default is LEAVE.
 2270                  */
 2271            2 PP_DCB# SBIN BYTE CALIGNED %INIT(DCBNUM(PP_DCB))%CHARTEXT('/**/'),
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      63   
 2272                  /*K*  PP_DCB = VALUE-DEC(0-?)  Is a DCB number for X$PRE_PROCESS
 2273                  to use for test opens on such functions as $FID_EXIST.
 2274                  If X$PRE_PROCESS needs a DCB (e.g., for a test open), and
 2275                  the user has not specified a DCB number, then XUG$GETCMD
 2276                  acquires a DCB and passes its number to X$PRE_PROCESS.
 2277                  (The dynamically acquired DCB is released when
 2278                  X$PREPROCESS returns control to XUG$GETCMD.)
 2279                  */
 2280            2 WSEG# UBIN BYTE CALIGNED %INIT(WSEG)%CHARTEXT('/**/'),
 2281                  /*K*  WSEG = VALUE-DEC(0-8)  Specifies what data segment to use
 2282                  as the work area instead of the user supplying one.
 2283                  Acceptable values are (0, 3, 4, 5, 6, 7, 8) (i.e. 3 specifies
 2284                  that Data Segment 3 is to be used to allocate are to use for
 2285                  the work space.) If 0 is specified, then the
 2286                  XUG$INIT_COMMON will use the next available data segment.
 2287                  XUG_INIT.WSEG# will only be used if XUG_INIT.WORK$ is
 2288                  set to VECTOR(NIL).
 2289                  */
 2290            2 COMMANDS# BIT(1) %INIT(COMMANDS)%CHARTEXT('/**/'),
 2291                  /*K*  COMMANDS = {YES|NO}  Indicates that if the command has
 2292                  failed to match any of the syntax of the user's parse nodes,
 2293                  then XUG$GETCMD should compare the command to its parse
 2294                  nodes of built-in commands.  The parse nodes describe the
 2295                  commands listed below, except for commands eliminated by
 2296                  INHIBIT_commandname=YES options.  The default is
 2297                  COMMANDS=YES.  The built-in commands are as follows:
 2298
 2299                  .FIF
 2300                          DATE
 2301                          {DIR|DIRECTORY}
 2302                          {DO|!}
 2303                          {E|EN|END}
 2304                          ENTER
 2305                          ERASE
 2306                          {[E]X|[E]XI|[E]XIT}
 2307                          TIME
 2308                          {H|HE|HEL|HELP}
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      64   
 2309                          {OUT|OUTP|OUTPU|OUTPUT}
 2310                          PRINT
 2311                          {Q|QU|QUI|QUIT}
 2312                          ?
 2313                          ??
 2314                  .FIN
 2315
 2316                  The functions performed by these commands are as described
 2317                  for IBEX.
 2318                  ..::HL "See the CP-6 Programmer Reference (CE40) for details.\"
 2319                  ..::HL "\See the IBEX HELP facility for details."
 2320                  The {DO|!} passes the command to the command processor for
 2321                  processing.  If used in an
 2322                  XEQ or BATCH job, the "!" must not be in column one or the
 2323                  user can use DO.  The ! command
 2324                  may be preceded by blanks or by the processor's prompt.
 2325                  .FIN
 2326                  */
 2327            2 PREPROCESS# BIT(1) %INIT(PREPROCESS)%CHARTEXT('/**/'),
 2328                  /*K*  PREPROCESS = {YES|NO}  Indicates, if YES, that the
 2329                  user wants XUG$GETCMD to do preprocessing on lines
 2330                  containing a percent (%) sign.  The type of preprocessing
 2331                  depends on the value given for PREPROCESSOR.  The default
 2332                  is NO.
 2333                  */
 2334            2 REQ_PROMPT# BIT(1) %INIT(REQ_PROMPT)%CHARTEXT('/**/'),
 2335                  /*K*  REQ_PROMPT = {YES|NO}  Indicates that the prompt must
 2336                  be the first character(s) of the command line, beginning
 2337                  in column 1. Default is NO. If REQ_PROMPT is set to YES,
 2338                  and the prompt is not at the beginning of the command
 2339                  line, XUG$GETCMD will ALTRETURN without doing any parsing.
 2340                  */
 2341            2 SYNTAX# BIT(1) %INIT(SYNTAX)%CHARTEXT('/**/'),
 2342                  /*K*  SYNTAX = {YES|NO}  Specifies whether the special
 2343                  command-syntax feature of XUG$GETCMD is to be used. The
 2344                  default is YES.
 2345                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      65   
 2346            2 GOODCMD# BIT(1) %INIT(GOODCMD)%CHARTEXT('/**/'),
 2347                  /*K*  GOODCMD = {YES|NO}  Specifies, if YES, that XUG$GETCMD
 2348                  should detect errors itself, without returning to the
 2349                  caller.  Note that XUG$GETCMD can only process "simple"
 2350                  errors (syntax errors, invalid
 2351                  preprocessor expressions, errors in built-in commands, etc.)
 2352                  in commands entered from the terminal (i.e., the TREAD# flag is
 2353                  set).  Errors occurring in non-interactive commands, and serious
 2354                  (monitor) errors occurring in any command, will result in an
 2355                  ALTRETURN regardless of the setting of the GOODCMD flag.
 2356                  The default is NO.
 2357                  */
 2358            2 SPELLING# BIT (1) %INIT(SPELLING)%CHARTEXT('/**/'),
 2359                  /*K*  SPELLING = {YES|NO}    Indicates whether XUG$GETCMD should
 2360                        attempt to identify and report misspelled keywords in
 2361                        commands.  The default is YES.
 2362                  */
 2363            2 ALWAYS_SET_PROMPT# BIT (1) %INIT(ALWAYS_SET_PROMPT) %CHARTEXT('/**/'),
 2364                  /*K*  ALWAYS_SET_PROMPT = {YES|NO}   Indicates whether XUG$GETCMD
 2365                        should always issue an M$PROMPT before reading, even if the
 2366                        current prompt maintained by XUG$GETCMD does not appear to have
 2367                        been changed.  The default is NO.
 2368                  */
 2369            2 NO_DOWNGRADE# BIT (1) %INIT(NO_DOWNGRADE)%CHARTEXT('/**/'),
 2370                  /*K* NO_DOWNGRADE = {YES|NO}  Specifies, if YES, that
 2371                  only the most-severe (highest flaglevel) error message for
 2372                  each command should be remembered; less-severe messages
 2373                  will be considered to be additional information, and will
 2374                  not be remembered for display of additional message levels
 2375                  if the user subsequently enters "?" or "??".  The default
 2376                  is NO.
 2377            */
 2378            2 DONT_REREAD_CCBUF# BIT(1) %INIT(DONT_REREAD_CCBUF)%CHARTEXT('/**/'),
 2379                  /*K* DONT_REREAD_CCBUF = {YES|NO}  Specifies, if YES, that
 2380                  only the text actually parsed is to be placed in the reread
 2381                  buffer after a syntax error parsing the program's invocation
 2382                  command line.  The default is NO, indicating that the entire
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      66   
 2383                  command line is to be reread, even if only the options portion
 2384                  of it was parsed.
 2385                  */
 2386            2 DONT_STRIP_PROMPT# BIT(1) %INIT(DONT_STRIP_PROMPT)%CHARTEXT('/**/'),
 2387                  /*K* DONT_STRIP_PROMPT = {YES|NO}  Specifies whether the
 2388                  logic to remove the program's prompt from the beginning of
 2389                  commands is to be overridden.  YES specifies no check for
 2390                  a prompt at the beginning of each command line.  NO specifies
 2391                  that the prompt is to be removed if it is present.
 2392                  The default is NO.
 2393                  */
 2394            2 RFUBIT BIT(26) %INIT('0'B)%CHARTEXT('/**/'),
 2395            2 ADAPT$$ EPTR %INIT(%ADAPT_ENT)%CHARTEXT('/**/'),
 2396                 /*K* ADAPT = EPTR  Points to the dialog manager procedure
 2397                 to be called if the program is started under an ADAPT
 2398                 dialog, or if the ENTER built-in commnd is used to start a
 2399                 dialog within the program.  The default is XTX$ADAPT.
 2400                 Programs that cannot run under ADAPT dialogs must specify
 2401                 ADAPT=NIL.  See the CP-6 ADAPT Reference (HA12) for more
 2402                 information.
 2403                 */
 2404            2 RFU2$ EPTR %INIT(ENTADDR(NIL))%CHARTEXT('/**/'),
 2405            2 RFU3$ EPTR %INIT(ENTADDR(NIL))%CHARTEXT('/**/'),
 2406            2 RFU4$ EPTR %INIT(ENTADDR(NIL))%CHARTEXT('/**/'),
 2407            2 RFU5$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2408               2 PP_ROOT$ PTR %INIT (ADDR(PP_ROOT)) %CHARTEXT('/**/'),
 2409                  /*K* PP_ROOT = VARIABLE  Identifies the node which lies at the
 2410                  root of a PARTRGE tree that defines non-standard preprocessor
 2411                  functions (see XUE_PPCB.ROOT$ for details).
 2412                  */
 2413            2 RFU6$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2414            2 RFU7$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2415            2 RFU8$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 2416               2 INHIBITS,
 2417                  3 DATE# BIT (1) UNAL %INIT(INHIBIT_DATE)%CHARTEXT('/**/'),
 2418                  /*K*  INHIBIT_DATE = {YES|NO}  Specifies that the built-in
 2419                  commands DATE and TIME should not be recognized or executed.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      67   
 2420                  The default is NO.
 2421                  */
 2422                  3 DIRECTORY# BIT (1) UNAL %INIT(INHIBIT_DIRECTORY)%CHARTEXT('/**/'),
 2423                  /*K*  INHIBIT_DIRECTORY = {YES|NO}  Specifies that the built-in
 2424                  command DIRECTORY should not be recognized or executed.
 2425                  The default is NO.
 2426                  */
 2427                  3 DO# BIT (1) UNAL %INIT(INHIBIT_DO)%CHARTEXT('/**/'),
 2428                  /*K*  INHIBIT_DO = {YES|NO}  Specifies that the built-in
 2429                  commands DO and ! should not be recognized or executed.
 2430                  The default is NO.
 2431                  */
 2432                  3 END# BIT (1) UNAL %INIT(INHIBIT_END)%CHARTEXT('/**/'),
 2433                  /*K*  INHIBIT_END = {YES|NO}  Specifies that the built-in
 2434                  commands END, XIT, and QUIT should not be recognized or
 2435                  executed.  The default is NO.
 2436                  */
 2437                  3 ERASE# BIT (1) UNAL %INIT(INHIBIT_ERASE)%CHARTEXT('/**/'),
 2438                  /*K*  INHIBIT_ERASE = {YES|NO}  Specifies that the built-in
 2439                  command ERASE should not be recognized or executed.
 2440                  The default is NO.
 2441                  */
 2442                  3 HELP# BIT (1) UNAL %INIT(INHIBIT_HELP)%CHARTEXT('/**/'),
 2443                  /*K*  INHIBIT_HELP = {YES|NO}  Specifies that the built-in
 2444                  command HELP should not be recognized or executed.
 2445                  The default is NO.
 2446                  */
 2447                  3 NULL# BIT (1) UNAL %INIT(INHIBIT_NULL)%CHARTEXT('/**/'),
 2448                  /*K*  INHIBIT_NULL = {YES|NO}  Specifies that the built-in
 2449                  null (empty) command should not be recognized or executed.
 2450                  The default is NO.
 2451                  */
 2452                  3 OUTPUT# BIT (1) UNAL %INIT(INHIBIT_OUTPUT)%CHARTEXT('/**/'),
 2453                  /*K*  INHIBIT_OUTPUT = {YES|NO}  Specifies that the built-in
 2454                  command OUTPUT should not be recognized or executed.
 2455                  The default is NO.
 2456                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      68   
 2457                  3 PRINT# BIT (1) UNAL %INIT(INHIBIT_PRINT)%CHARTEXT('/**/'),
 2458                  /*K*  INHIBIT_PRINT = {YES|NO}  Specifies that the built-in
 2459                  command PRINT should not be recognized or executed.
 2460                  The default is NO.
 2461                  */
 2462                  3 QMARK# BIT (1) UNAL %INIT(INHIBIT_QMARK)%CHARTEXT('/**/'),
 2463                  /*K*  INHIBIT_QMARK = {YES|NO}  Specifies that the built-in
 2464                  commands ? and ?? should not be recognized or executed.
 2465                  The default is NO.
 2466                  */
 2467                  3 ENTER# BIT (1) UNAL %INIT(INHIBIT_ENTER)%CHARTEXT('/**/'),
 2468                  /*K*  INHIBIT_ENTER = {YES|NO}  Specifies that the built-in
 2469                  command ENTER should not be recognized or executed.
 2470                  */
 2471            2 RFU10# UBIN %INIT(0)%CHARTEXT('/**/'),
 2472            2 RFU11# UBIN %INIT(0)%CHARTEXT('/**/'),
 2473            2 RFU12# UBIN %INIT(0)%CHARTEXT('/**/');
 2474      %MEND;
 2475
 2476
 2477                  /*F* NAME: XUG_PARAMS
 2478                  */
 2479      %MACRO XUG_PARAMS(NAME=XUG,STCLASS="BASED(XUG$)");
 2480      /*
 2481      */
 2482
 2483      DCL 1 NAME DALIGNED STCLASS,
 2484            2 BUFVEC VECTOR,
 2485                  /*  BUFVEC        VECTOR of the Command record buffer.
 2486                  */
 2487            2 READVEC VECTOR,
 2488                  /*  READVEC       VECTOR of area to read the next command
 2489                                    record into.
 2490                  */
 2491            2 LAST VECTOR,
 2492                  /*  LAST          VECTOR of the LAST command record read.
 2493                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      69   
 2494            2 GDSVEC VECTOR,
 2495                  /* GDSVEC         VECTOR for GET DATA SEGMENT Monitor calls.
 2496                  */
 2497            2 PARSEVEC VECTOR,
 2498                  /* PARSEVEC       VECTOR describing the Work area for the
 2499                                    PARSER.
 2500                  */
 2501            2 RLTVEC VECTOR,
 2502                  /*  RLTVEC        VECTOR describing the area allocated for the
 2503                                    Record-Length Table. The table of record
 2504                                    lengths for the commands read into the
 2505                                    record buffer for a continued command.
 2506                  */
 2507            2 REM_PARSE REMEMBER,
 2508                  /*  REM_PARSE     PARSE ALTRETURN REMEMBER variable.
 2509                  */
 2510            2 * BIT(72),
 2511            2 ABORT EPTR,
 2512                  /*  ABORT         ABORT handling routine for BREAKs.
 2513                  */
 2514            2 CONTINUE EPTR,
 2515                  /*  CONTINUE      Optional routine to be called if a user
 2516                                    wants to CONTINUE after a BREAK.
 2517                  */
 2518            2 BRKMSG EPTR,
 2519                  /*  BRKMSG        Optional routine to handle BREAK messages.
 2520                  */
 2521            2 PREPROCESSOR$$ EPTR,
 2522                  /*  PREPROCESSOR$$  Optional routine to handle PREPROCESSing.
 2523                  */
 2524            2 SFROUTINE EPTR,
 2525                  /*  SFROUTINE     Success-Fail routine.
 2526                  */
 2527            2 SPHANDLE EPTR,
 2528                  /*  SPHANDLE      Optional routine to be called before the
 2529                                    next command record is read during a
 2530                                    continued command.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      70   
 2531                  */
 2532            2 PRE_EXEC EPTR,
 2533                  /* PRE_EXEC       Entry pointer to a procedure to be called
 2534                                    BEFORE one of the BUILT-IN commands is executed.
 2535                  */
 2536            2 POST_EXEC EPTR,
 2537                  /* POST_EXEC      Entry pointer to a procedure to be called
 2538                                    AFTER one of the BUILT-IN commands is executed.
 2539                  */
 2540            2 MOREMEM EPTR,
 2541                  /* MOREMEM        Entry pointer to procedure to be called
 2542                                    if GETCMD needs more memory and the user
 2543                                    maintains the memory for GETCMD.
 2544                  */
 2545            2 ROOT_NODE ALIGNED,
 2546              3 FLAGS BIT(36),
 2547              3 USER_NODE$ PTR,
 2548              3 GETCMD_NODE$ PTR,
 2549                  /* ROOT_NODE      Structure to be used for the concatenation
 2550                                    of the USER's nodes and GETCMD's nodes.
 2551                                    A based P$NODE structure will be used to init.
 2552                                    this area.  Before the PARSER is called
 2553                                    P_PCB.ROOT$ must point to ROOT_NODE.
 2554                  */
 2555            2 DUMMY_NODE ALIGNED,
 2556              3 FLAGS BIT(36),
 2557              3 SUBND$ PTR,
 2558                  /* DUMMY_NODE     Subnode structure to be used for the
 2559                                    concatenation of the USER's nodes and
 2560                                    GETCMD's nodes.  Before the PARSER is called
 2561                                    XUG.ROOT_NODE.USER_NODE$ must point to
 2562                                    DUMMY_NODE, and XUG.DUMMY_NODE.SUBND$
 2563                                    must be set to GETCMD.NODES$.
 2564                  */
 2565            2 POFF SBIN,
 2566                  /*  POFF          PROMPT offset.
 2567                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      71   
 2568            2 PROMPT CHAR(94),
 2569                  /*  PROMPT        The PROMPT that may preceed the command
 2570                                    record being input.
 2571                  */
 2572            2 ERRSAVE ALIGNED,
 2573              3 FCG BIT(18),
 2574              3 MON BIT(1),
 2575              3 CODE UBIN(14) UNAL,
 2576              3 SEV UBIN(3) UNAL,
 2577                  /*  ERRSAVE       Locatton to remember the ERROR code in.
 2578                  */
 2579            2 ERRDCB UBIN WORD,
 2580                  /*  ERRDCB        DCB number that the ERROR occurred on.
 2581                  */
 2582            2 HELP,
 2583              3 LAST BIT(1),
 2584              3 TOPICS BIT(1),
 2585                  /* TOPICS         Flag that indicates the user wants HELP
 2586                                    message of the TOPICS.
 2587                  */
 2588            2 GOTCMD BIT (1),
 2589                  /*  GOTCMD        Flag that indicates XUG$GETCMD GOT a
 2590                                    COMMAND through the BREAK routine.
 2591                  */
 2592            2 BREAK BIT(1),
 2593                  /*  BREAK         Flag that indicates we received a BREAK.
 2594                  */
 2595            2 COMMANDS BIT(1),
 2596                  /*  COMMANDS      Flag that indicates that the BUILT-IN commands
 2597                                    are to be used.
 2598                  */
 2599            2 SYNTAX BIT(1),
 2600                  /*  SYNTAX        Flag that indicates the user wants SYNTAX
 2601                                    alternatives upon receipt of '?', question
 2602                                    mark.
 2603                  */
 2604            2 SYNERR BIT(1),
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      72   
 2605                  /*  SYNERR        Flag that indicates the user wants
 2606                                    alternatives be output upon '?'.
 2607                  */
 2608            2 PREPROCESS BIT(1),
 2609                  /*  PREPROCESS    Flag to indicate that preprocessing
 2610                                    is to be done.
 2611                  */
 2612            2 REQ_PROMPT BIT(1),
 2613                  /*  REQ_PROMPT    Flag to indicate that a PROMPT is
 2614                                    REQUIRED.
 2615                  */
 2616            2 REP_PROMPT BIT(1),
 2617                  /*  REP_PROMPT    Flag to indicate that the PROMPT has been
 2618                                    REPLACED by the REPLACEMENT PROMPT.
 2619                  */
 2620            2 XUG_OWNS_MEMORY BIT(1),
 2621                  /*  XUG_OWNS_MEMORY   Flag to indicate that the user did not
 2622                                    specify a work area.
 2623                  */
 2624            2 DOCMD_SYNERR BIT(1),
 2625                  /*  DOCMD_SYNERR      Flag to indicate that the last DO cmd
 2626                                        had a syntax error.
 2627                  */
 2628            2 REREAD BIT(1),
 2629                  /*  REREAD            Flag to indicate the M$SINPUT was called
 2630                                        after a DO command.
 2631                  */
 2632            2 NEED_ECHO BIT(1),
 2633                  /*  NEED_ECHO         Flag to indicate that this command has
 2634                                        NOT been echoed.
 2635                  */
 2636            2 GOODCMD BIT(1),
 2637                  /*  GOODCMD           Flag to indicate that GETCMD should catch and
 2638                                        diagnose non-monitor-type errors in commands
 2639                                        entered from an interactive terminal, without
 2640                                        ALTRETURNing to the caller.
 2641                  */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      73   
 2642            2 PROMPT_VFC BIT(1),
 2643                  /*  PROMPT_VFC        Flag to indicate that the first character
 2644                                        of the prompt string is to be used as the
 2645                                        VFC character.  This flag is used to
 2646                                        help determine if M$PROMPT should be called.
 2647                  */
 2648            2 SPELLING BIT(1),
 2649                  /*  SPELLING          Flag to indicate that spelling-error detection
 2650                                        is to be performed after a syntax error occurs.
 2651                  */
 2652            2 SPELLING_TRIED BIT(1),
 2653                  /*  SPELLING_TRIED    Flag to indicate that spelling-error detection
 2654                                        has already been tried once for the current
 2655                                        syntax error.
 2656                  */
 2657            2 DIVERT_TO_HELP BIT(1),
 2658                  /*  DIVERT_TO_HELP   Flag indicating that when the next "no error
 2659                                       messages available" condition occurs on a
 2660                                       "?" command, an attempt should be made to
 2661                                       display HELP information for the topic
 2662                                       currently in XUG.HELP_TOPIC.
 2663                  */
 2664            2 POINTED_TO_SYNERR BIT (1),
 2665                  /*   POINTED_TO_SYNERR        Flag indicates that the most recent
 2666                                                call to XUG$ERRPTR was to point out
 2667                                                a syntax error;  if this flag is
 2668                                                set, XUG$ERRMSG will suppress the
 2669                                                XUG-E$SYNERR message.
 2670                  */
 2671            2 QM_AFTER_SYNERR BIT (1),
 2672                  /*   QM_AFTER_SYNERR          Flag indicates that the most recent
 2673                                                command contained a "?" which caused
 2674                                                the parse to fail, and that X$PARSE
 2675                                                and/or XUS$CORRECT_SPELLING was
 2676                                                called to display legal alternatives.
 2677                                                If this bit is set, XUG$ERRPTR and
 2678                                                XUG$ERRMSG will suppress the "syntax
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      74   
 2679                                                error" diagnostic.
 2680                  */
 2681            2 PARSING_FREE_COMMAND BIT (1),
 2682                  /* PARSING_FREE_COMMAND - if set, indicates that the parser has
 2683                     reached the first "free command" node in the parse tree.
 2684                  */
 2685            2 INHIBITS,
 2686               3 DATE# BIT (1),
 2687                  /* INHIBITS.DATE, and those which follow - inhibit recognition
 2688                     and execution of specific free commands.
 2689                  */
 2690               3 DIRECTORY# BIT (1),
 2691               3 DO# BIT (1),
 2692               3 END# BIT (1),
 2693               3 ERASE# BIT (1),
 2694               3 HELP# BIT (1),
 2695               3 NULL# BIT (1),
 2696               3 OUTPUT# BIT (1),
 2697               3 PRINT# BIT (1),
 2698               3 QMARK# BIT (1),
 2699               3 ENTER# BIT(1),
 2700            2 NO_DOWNGRADE BIT (1),
 2701                  /* NO_DOWNGRADE - if set, the second (and subsequent) errors
 2702                     detected in a command should be remembered only if their
 2703                     flag levels exceed those of the currently-remembered error.
 2704                  */
 2705            2 FIRST_ERROR BIT (1),
 2706                  /* HAVE_ERROR - set if at least one error had been detected
 2707                     during execution of the current command.
 2708                  */
 2709            2 NO_INCREMENT BIT (1),
 2710                  /* NO_INCREMENT - set if the currently-remembered error code's
 2711                     severity should not be incremented before M$ERRMSG is called
 2712                     to handle a "?" or "??" command.
 2713                  */
 2714            2 P_PCB$ PTR,
 2715                  /*  P_PCB$        Pointer to P_PCB used by X$PARSE.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      75   
 2716                  */
 2717            2 PPCB$ PTR,
 2718                  /*  PPCB$         Pointer to PPCB used by X$PREPROCESS
 2719                  */
 2720            2 PP_PROCNAME_ VECTOR,
 2721                  /*  PP_PROCNAME_ Vector framing the PROCNAME for the
 2722                                   pre_processing.
 2723                  */
 2724            2 USER$ PTR,
 2725                  /* USER$          Pointer to the USER's parameter to be used
 2726                                    in Success, Fail, etc. routines as a save
 2727                                    location.
 2728                  */
 2729            2 PP_DCB UBIN,
 2730                  /*  PP_DCB        DCB number of the DCB for X$PRE_PROCESS
 2731                                    to use on test OPENs.
 2732                  */
 2733            2 PP_ERR,
 2734              3 FCG BIT (12),
 2735              3 MID BIT (6),
 2736              3 MON BIT (1),
 2737              3 CODE UBIN (14) UNAL,
 2738              3 SEV UBIN (3) UNAL,
 2739                  /*  PP_ERR        The PRE-PROCESS ERROR.
 2740                  */
 2741            2 BRKARS SBIN,
 2742                  /*  BRKARS        The ARS for the record read at BREAK time.
 2743                  */
 2744            2 BIP SBIN,
 2745                  /*  BIP           BREAK In Progress count.
 2746                  */
 2747            2 DISLVL SBIN,
 2748                  /*  DISLVL        Disable Level count with respect to
 2749                                    disabling BREAKs.
 2750                  */
 2751            2 CPOS SBIN,
 2752                  /*  CPOS          Character Position used for ERROR messages.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      76   
 2753                  */
 2754            2 PREV_CPOS SBIN,
 2755                  /*  PREV_CPOS     Character Position returned from the PARSER
 2756                  upon continuation, PARSE_PARAM.CHARPOS.
 2757                  */
 2758            2 NLINES SBIN,
 2759                  /*  NLINES        Number of LINES of continued command
 2760                                    records have been read.
 2761                  */
 2762            2 RLTCNT SBIN,
 2763                  /*  RLTCNT        TOTAL Number of entries in the array
 2764                                    RLT (Record Length Table)
 2765                  */
 2766            2 ADDL_RLTCNT SBIN,
 2767                  /*  ADDL_RLTCNT   The number of ADDitionaL RTL entries to
 2768                                    expand the Record-Length Table by.
 2769                  */
 2770            2 CMDSZ UBIN,
 2771                  /*  CMDSZ         The allowable length of a command line.
 2772                  */
 2773            2 NDCBS SBIN,
 2774                  /*  NDCBS         Number of DCBs used for ECHOing purposes.
 2775                  */
 2776            2 DCBS (0:9) ALIGNED,
 2777              3 NUM UBIN HALF HALIGNED,
 2778              3 ERRPTR_CPOS SBIN HALF HALIGNED,
 2779              3 CPOS SBIN HALF HALIGNED,
 2780              3 * BIT (18),
 2781                    /*  DCBS        Array of DCBs. Used for ECHOing purposes.
 2782                    */
 2783            2 FILENAME,
 2784              3 C UBIN BYTE CALIGNED,
 2785              3 TX CHAR(31),
 2786                  /*  FILENAME      ERROR Message file filename.
 2787                  */
 2788            2 FILEACCT CHAR(8),
 2789                  /*  FILEACCT      ACCOUNT name for the ERROR Message file.
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      77   
 2790                  */
 2791            2 FILEPASS CHAR(8),
 2792                  /*  FILEPASS      PASSWORD for the ERROR Message file.
 2793                  */
 2794            %XUH_PARAM (NAME=XUH_PARAM, LVL=2, STCLASS=AUTO) ;
 2795                  /* XUH_PARAM      Parameter for X$HELP in BUILTIN commands.
 2796                  */
 2797            2 HELP_TOPIC,
 2798                  /*  HELP_TOPIC    A TEXTC-like structure used to hold the first
 2799                                    word of the user's command, after a syntax
 2800                                    error has occurred.  Repeated use of "?" will
 2801                                    cause XUG to route the user off into HELP for
 2802                                    this keyword, if such exists.
 2803                  */
 2804               3 COUNT UBIN BYTE CALIGNED,
 2805               3 TEXT CHAR (63),
 2806           2 GOTCMD_EOMCHAR CHAR (1),
 2807                  /* GOTCMD_EOMCHAR - contains M$UC.EOMCHAR# after GETCMD has
 2808                     read a command during "break key" processing.
 2809                  */
 2810           2 LAST_FLAGLEV UBIN BYTE CALIGNED,
 2811                  /* LAST_FLAGLEV - contains the flag-level (asterisk count) of the
 2812                     error message currently remembered in .ERRSAVE
 2813                  */
 2814           2 PARSING_FREE_CMDS BIT (1),
 2815                  /* PARSING_FREE_CMDS - set if GETCMD has received "pre-parse"
 2816                     control for the free commands.  Used to control
 2817                     processing of free-command inhibit flags.
 2818                  */
 2819           2 DEFER_SETTING_PROMPT BIT (1) UNAL,
 2820                  /* DEFER_SETTING_PROMPT - set if a GETCMD call establishes
 2821                     a new prompt when the command comes from a text string.
 2822                     The prompt is remembered ('cause IBEX needs it), but is
 2823                     not issued via M$PROMPT until it is actually needed for
 2824                     a read, so that the input file is not opened unnecessarily.
 2825                  */
 2826           2 DONT_REREAD_CCBUF BIT (1) UNAL,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      78   
 2827                  /* DONT_REREAD_CCBUF - set if the user requests suppression
 2828                     of the feature to reread all of JIT.CCBUF after a syntax
 2829                     error, even of only the options portion was parsed.
 2830                  */
 2831           2 DONT_STRIP_PROMPT BIT (1) UNAL,
 2832                  /* DONT_STRIP_PROMPT - set if the user requests suppression
 2833                     of the feature to strip the processors's prompt from the
 2834                     start of command lines.
 2835                  */
 2836           2 * BIT (14) UNAL,
 2837           2 CCBUF_OFFC SBIN HALF HALIGNED,
 2838                  /* CCBUF_OFFC - Number of characters of JIT.CCBUF that are
 2839                     not part of the parse text, but that are to be put into
 2840                     the reread buffer after a syntax error.
 2841                  */
 2842           2 CCBUF_REST SBIN HALF HALIGNED,
 2843                  /* CCBUF_REST - Like CCBUF_OFFC, but contains the number
 2844                     of JIT.CCBUF characters that follow the parse text.
 2845                  */
 2846            2 ADAPT$$ EPTR,
 2847                  /* ADAPT$$  Optional routine to handle menu/dialog command
 2848                               entry.
 2849                  */
 2850            2 F1SAVE VECTOR,
 2851                  /* F1SAVE   Save area for F1_ vector associated with ERRSAVE.
 2852                  */
 2853            2 F2SAVE VECTOR,
 2854                  /* F2SAVE   Save area for F2_ vector associated with ERRSAVE.
 2855                  */
 2856            2 F3SAVE VECTOR,
 2857                  /* F3SAVE   Save area for F3_ vector associated with ERRSAVE.
 2858                  */
 2859            2 BUF CHAR(300),
 2860                  /*  BUF           BUFFER used to read a record into.
 2861                  */
 2862            2 BUFA(0:299) REDEF BUF CHAR(1);
 2863      %MEND;
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      79   
 2864
 2865
 2866      %MACRO    XUG_RLT (NAME=XUG_RLT, STCLASS=BASED);
 2867      /*
 2868      */
 2869      DCL 1 NAME (0:0) UBIN BYTE CALIGNED STCLASS;
 2870                  /*  XUG_RLT       Record Length Table.
 2871                  */
 2872      %MEND ;
 2873
 2874      %EJECT;

15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      80   
 2875      /*F*
 2876      NAME:   XUD_PARAM Structure
 2877
 2878              The XUD_PARAM macro describes the structure that is used with
 2879              most XUD services to pass and return various fields.
 2880              Parameters may be used to initialize all fields that pass
 2881              values to the services.  These fields will not be altered
 2882              by the XUD services.  Note that an XUD_PARAM structure in
 2883              constant storage must not be passed to an XUD service,
 2884              since some fields are used to return values to the caller.
 2885      */
 2886      %MACRO XUD_PARAM( NAME=XUD_PARAM, STCLASS=STATIC,
 2887              SIZE = 0,
 2888              PIC = NIL,
 2889              WORK = NIL,
 2890              UTS_TYPE( UTS=4, NEWUTS=7 ) = 0, /* same values as for M$TIME */
 2891    *         ASSUME_UTS( YES='1'B, NO='0'B ) = '0'B,
 2892              TIMESPAN( YES='1'B, NO='0'B ) = '0'B,
 2893              PIC_TEXTC( YES='1'B, NO='0'B ) = '0'B,
 2894              PIC_SIZE = 0,
 2895              INIT_PIC( YES='1'B, NO='0'B ) = '0'B,
 2896              TEXTC( YES='1'B, NO='0'B ) = '0'B );
 2897
 2898      %LSET LISTDIR = '0'B;
 2899      %LSET LISTEXP = '1'B;
 2900      %LSET LISTCOM = '0'B;
 2901      %LSET LISTSUB = '1'B;
 2902      %LSET STR = SUBSTR( CONCAT( TEXTCHAR(STCLASS), '   ' ), 0, 3 );
 2903      %IF STR='STA' OR STR='CON' OR STR='EXT';
 2904          %LSET INIT = CHARTEXT( 'INIT' );
 2905          %LSET EINIT = CHARTEXT( ' ' );
 2906      %ELSE;
 2907          %LSET INIT = CHARTEXT( '/*' );
 2908          %LSET EINIT = CHARTEXT( '*/' );
 2909      %ENDIF;
 2910
 2911      DCL 1 NAME STCLASS ALIGNED,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      81   
 2912          2 PIC$ PTR %INIT(ADDR(PIC))%EINIT,
 2913      /*K*    PIC$ - PTR
 2914
 2915              On calls for conversion to or from character, specifies the
 2916              picture to be used to control the conversion.
 2917
 2918              This field is initialized in the XUD_PARAM block with
 2919              PIC=picture. The default is NIL.
 2920      */
 2921          2 %CHARTEXT('TEXTC') BIT(1) UNAL %INIT(TEXTC)%EINIT,
 2922      /*K*    TEXTC - BIT(1)
 2923
 2924              On calls for conversion to or from character, specifies
 2925              whether the character operand is a fixed length or a TEXTC string.
 2926              If TEXTC is set, the string is in TEXTC format, otherwise it
 2927              is a fixed length string.
 2928
 2929              This field is initialized in the XUD_PARAM block with
 2930              TEXTC={YES|NO}.  The default is NO.
 2931      */
 2932          2 %CHARTEXT('INIT_PIC') BIT(1) UNAL %INIT(INIT_PIC)%EINIT,
 2933      /*K*    INIT_PIC - BIT(1)
 2934
 2935              When PIC is not NIL on calls for conversion to or from character,
 2936              specifies whether or not the picture has been previously
 2937              initialized.  If INIT_PIC is set, the picture will be initialized.
 2938              Otherwise, it is assumed to have been initialized by a prior
 2939              call to XUD$INIT_PIC.
 2940
 2941              If the same picture is to be used repetitively,
 2942              considerable execution time can be saved by initializing the
 2943              picture one time only, before it is used by any conversion
 2944              service.
 2945
 2946              This field is initialized in the XUD_PARAM block with
 2947              INIT_PIC={YES|NO}.  The default is NO.
 2948      */
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      82   
 2949          2 %CHARTEXT('TIMESPAN') BIT(1) UNAL %INIT(TIMESPAN)%EINIT,
 2950      /*K*    TIMESPAN - BIT(1)
 2951
 2952              If set, specifies that the conversion involves a time span value.
 2953              Otherwise, the conversion is assumed to involve a date/time value.
 2954
 2955              This field is initialized in the XUD_PARAM block with
 2956              TIMESPAN={YES|NO}.  The default is NO.
 2957      */
 2958    *     2 %CHARTEXT('ASSUME_UTS') BIT(1) UNAL %INIT(ASSUME_UTS)%EINIT,
 2959    * /*K*    ASSUME_UTS - BIT(1)
 2960    *
 2961    *         If set, ambiguous (< 4 digit) years are interpreted using rules
 2962    *         similar to M$TIME, instead of assuming the current century. It
 2963    *         will map the years: 00-20 -> 2000-2020, 78-99 -> 1978-1999,
 2964    *         21-77 -> current century.
 2965    *
 2966    *         This field is initialized in the XUD_PARAM block with
 2967    *         ASSUME_UTS={YES|NO}.  The default is NO.
 2968    * */
 2969    *     2 * BIT(4) UNAL %INIT('0'B)%EINIT,
 2970          2 %CHARTEXT('PIC_TEXTC') BIT(1) UNAL %INIT(PIC_TEXTC)%EINIT,
 2971      /*K*    PIC_TEXTC - BIT(1)
 2972
 2973              On calls that involve picture initialization, specifies whether
 2974              the picture to be initialized is a fixed length string or is in
 2975              TEXTC form.  If PIC_TEXTC is set, the picture is treated as
 2976              a TEXTC string,
 2977              otherwise it is assumed to be a fixed length string.
 2978
 2979              This field is initialized in the XUD_PARAM block with
 2980              PIC_TEXTC={YES|NO}.  The default is NO.
 2981      */
 2982          2 %CHARTEXT('PIC_SIZE') UBIN BYTE CALIGNED %INIT(PIC_SIZE)%EINIT,
 2983      /*K*    PIC_SIZE - UBIN BYTE
 2984
 2985              If PIC_TEXTC is not set on calls that involve picture initialization,
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      83   
 2986              specifies the size in characters of the picture to be initialized.
 2987              The size must be between 1 and 63.
 2988
 2989              This field is initialized in the XUD_PARAM block with
 2990              PIC_SIZE=number.  The default is zero.
 2991      */
 2992          2 %CHARTEXT('SIZE') UBIN BYTE CALIGNED %INIT(SIZE)%EINIT,
 2993      /*K*    SIZE - UBIN BYTE
 2994
 2995              If TEXTC is not set on calls for conversion from character,
 2996              specifies the size in characters of the string to be converted.
 2997              On calls for conversion to character, specifies the maximum
 2998              number of characters in the converted string.  The size must
 2999              be between 1 and 63.
 3000
 3001              This field is initialized in the XUD_PARAM block with
 3002              SIZE=number.  The default is zero.
 3003      */
 3004          2 MAX_SIZE UBIN BYTE CALIGNED %INIT(0)%EINIT,
 3005      /*K*    MAX_SIZE - UBIN BYTE
 3006
 3007              On calls to XUD$INIT_PIC, returns the nominal maximum size in
 3008              characters for strings to be converted using the initialized
 3009              picture.
 3010      */
 3011          2 DATA_SIZE REDEF MAX_SIZE UBIN BYTE CALIGNED,
 3012      /*K*    DATA_SIZE - UBIN BYTE
 3013
 3014              On calls for conversion to character, returns the actual size
 3015              in characters of the converted string.  Note that if TEXTC is
 3016              set, the same value is saved in the count byte of the resulting
 3017              TEXTC string.
 3018      */
 3019          2 ERR           ALIGNED,
 3020      /*K*    ERR - A standard CP-6 error code
 3021
 3022              Contains the error code in case of an ALTRETURN.  The error
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      84   
 3023              code is set to zero on a normal return.
 3024      */
 3025              3 FCG BIT(12) UNAL %INIT('0'B)%EINIT,
 3026              3 MID BIT(6) UNAL %INIT('0'B)%EINIT,
 3027              3 MON BIT(1) UNAL %INIT('0'B)%EINIT,
 3028              3 ERR# UBIN(14) UNAL %INIT(0)%EINIT,
 3029              3 SEV UBIN(3) UNAL %INIT(0)%EINIT,
 3030          2 WORK$ PTR %INIT(ADDR(WORK))%EINIT,
 3031      /*N* WORK = ADDRESS.  Pointer to a work area to hold text of month
 3032              and weekday names in the user's natural language.  It sets
 3033              the XUD_PARAM.WORK$ pointer.  The default is NIL.
 3034
 3035              This value is only meaningful on conversion calls where the
 3036              picture references the month or weekday name.  It is never
 3037              used on picture initialization calls or on timespan conversions.
 3038              If WORK is omitted, an internal work ares is used on calls where
 3039              it is needed.  The internal area must be reinitialized with the
 3040              text for all names on each call where is is needed.  If WORK is
 3041              supplied, the work area only needs to be initialized once the
 3042              first time it is needed, which can result in considerable savings
 3043              of execution time.  To be effective, the same address must be
 3044              supplied on all calls in which the area could be used, but it
 3045              is not necessary to use the same parameter block on all calls.
 3046
 3047              The first word of the work area must be initialized by the caller
 3048              to contain the total number of words in the area.  This area
 3049              must never be altered by the caller thereafter.  The recommended
 3050              work area size is 100 words.
 3051      */
 3052          2 * PTR %INIT(ADDR(NIL))%EINIT,
 3053          2 * PTR %INIT(ADDR(NIL))%EINIT,
 3054          2 %CHARTEXT('UTS_TYPE') UBIN BYTE CALIGNED %INIT(UTS_TYPE)%EINIT,
 3055      /*K*    UTS_TYPE - UBIN BYTE
 3056
 3057              On calls for conversion to or from UTS, this specifies the
 3058              resolution of UTS values: either UTS for resolution to a 100th
 3059              of a second and a range of 21 years, or NEWUTS for resolution
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      85   
 3060              to a 25th of a second and a potential range of 84 years.  The
 3061              values are the same as the corresponding type codes for M$TIME.
 3062
 3063              This field is initialized in the XUD_PARAM block with
 3064              UTS_TYPE={UTS|NEWUTS}.  The default is the same as the system
 3065              default resolution (i.e., UTS for E02, and NEWUTS for future
 3066              releases).
 3067      */
 3068          2 * UBIN (27) CALIGNED %INIT(0)%EINIT,
 3069          2 * UBIN WORD %INIT(0)%EINIT;
 3070
 3071      %MEND;
 3072
 3073      /*F*
 3074      NAME:   XUD_ENTRY
 3075
 3076              The XUD_ENTRY macro generates entry point definitions for all
 3077              XUD service routines, except the XUD$UTS service routines.
 3078      */
 3079      %MACRO XUD_ENTRY;
 3080
 3081      DCL XUD$CHAR_UTS ENTRY( 3 ) ALTRET;
 3082      DCL XUD$CHAR_DATE ENTRY( 3 ) ALTRET;
 3083      DCL XUD$DATE_UTS ENTRY( 3 ) ALTRET;
 3084      DCL XUD$UTS_CHAR ENTRY( 3 ) ALTRET;
 3085      DCL XUD$UTS_DATE ENTRY( 3 ) ALTRET;
 3086      DCL XUD$DATE_CHAR ENTRY( 3 ) ALTRET;
 3087      DCL XUD$CLOCK_UTS ENTRY( 2 ) ALTRET;
 3088      DCL XUD$CLOCK_DATE ENTRY( 2 ) ALTRET;
 3089      DCL XUD$CLOCK_CHAR ENTRY( 2 ) ALTRET;
 3090      DCL XUD$INIT_PIC ENTRY( 3 ) ALTRET;
 3091      DCL XUD$ADD_DATE_DATE ENTRY( 2 ) ALTRET;
 3092      DCL XUD$ADD_DATE_TICS ENTRY( 2 ) ALTRET;
 3093      DCL XUD$SUB_DATE_DATE ENTRY( 2 ) ALTRET;
 3094      DCL XUD$SUB_DATE_TICS ENTRY( 2 ) ALTRET;
 3095      DCL XUD$TO_DATE ENTRY( 3 ) ALTRET;
 3096      DCL XUD$FROM_DATE ENTRY( 3 ) ALTRET;
15:25 JUL 28 '97 XU_MACRO_C.:E05SI/XU_MACRO_C.:E05TUI                      86   
 3097      DCL XUD$CMPR_DATES ENTRY( 3 ) ALTRET;
 3098
 3099      %MEND;
 3100
 3101      /*
 3102          Initialize XU$ADAPT_DEFINED SET for use in generating ENTRY for XTX$ADAPT
 3103          in XUR_INIT or XUG_INIT, but only once per proc.
 3104      */
 3105      %SET XU$ADAPT_DEFINED = '0'B ;

