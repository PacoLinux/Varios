

07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          1    
    1      /*M* UM_CP6_C - FPTs for UM (misc.) PMMEs */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* MEC,MOC,EXM=20,CLM=30,CRM=78           */
    8                               /**************************************************/
    9                                    /*      MISCELLANEOUS USER SERVICE PROCEDURES */
   10                               /**************************************************/
   11
   12
   13                               /**************************************************/
   14                                    /*      ERROR MESSAGE REPORTING SERVICE       */
   15                               /**************************************************/
   16
   17
   18
   19
   20                          /*F* NAME: M$ERRMSG - Error Message Reporting.
   21
   22                     The CP-6 system provides comprehensive error reporting, which
   23                     is available to report monitor service errors,
   24                     shared processor errors, or errors in a user
   25                     program.  The error reporting facility is not
   26                     limited to error messages; it can be used to
   27                     output messages that conform to the requirements
   28                     explained here.
   29
   30                     In the case of monitor service errors, the monitor
   31                     service passes an error code to the user,
   32                     typically in the ALTRET frame of the TCB. The
   33                     user calls the M$ERRMSG service specifying as
   34                     parameters the error code stored in the ALTRET
   35                     frame and a user buffer.  The following discussion
   36                     presents the full information needed by users who
   37                     are reporting errors on monitor service calls.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          2    
   38                     For users who intend to define their own error
   39                     codes and error message file, additional
   40                     information is given under later headings.
   41
   42                     ERROR CODE
   43
   44                     The 1-word code specified as a parameter for
   45                     M$ERRMSG must conform to this format:
   46
   47                     TU
   48                     Field                     Content
   49                     -----                     -------
   50                     Functional Code Group     VALUE-BIT(12), that is, 2 characters
   51                     }                         composed of the low-order 6 bits
   52                     }                         of the ASCII code
   53
   54                     Module ID                 VALUE-BIT(6), that is, 1 character
   55                     }                         composed of the low-order 6 bits
   56                     }                         of the ASCII code
   57
   58                     Monitor Flag              VALUE-BIT(1)
   59
   60                     Error Number              VALUE-DEC(0-16383)
   61
   62                     Severity Level            VALUE-DEC(0-7)
   63                     TF
   64
   65                     User's reporting monitor service errors do not
   66                     alter the error code.  However a processor or user
   67                     can supply an error message file and manipulate
   68                     the severity level to provide increasingly
   69                     informative messages in response to requests from
   70                     a time-sharing user.  The processor or user
   71                     displays one of several messages associated with
   72                     the same error number but with an increasingly
   73                     higher severity code (0-7) at each call to
   74                     M$ERRMSG.  (The HELP facility is provided through
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          3    
   75                     use of a message file with multiple messages
   76                     associated with each error condition.)
   77                     .SPB
   78                     .SPB
   79                     ERROR DISPLAY
   80                     .SPF
   81                     The format of the error display resulting from the
   82                     M$ERRMSG service is shown below.  The text is
   83                     always displayed (if found); other fields are
   84                     optional.  If the text is not found, the error
   85                     code is displayed.  The full form of the display
   86                     is as follows:
   87
   88                     }****fff-Mnnnn-s text
   89
   90                     where
   91
   92                     .inl 8
   93                     .unl 8
   94                     }****    indicates the seriousness of the error
   95                     }        by 0 to 4 asterisks.  Asterisks may be omitted;
   96                     }        however, by convention the asterisks are used as
   97                     }        follows:
   98                     }
   99                     }         * - information only
  100                     }        ** - warning message
  101                     }       *** - serious error
  102                     }      **** - fatal error
  103                     }
  104                     }        The FLAGLEV parameter determines the number of
  105                     }        asterisks output by M$ERRMSG.
  106                     }
  107                     .unl 8
  108                     }fff-Mnnnn-s   represents the error code passed
  109                     }        to the M$ERRMSG service as explained above.  fff
  110                     }        represents the functional code group (FCG) and
  111                     }        Module ID (MID) codes.  The letter M  precedes the
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          4    
  112                     }        error number (nnnnn) for monitor service errors.
  113                     }        The severity code(s) follows the error number.
  114                     }        The INCLCODE parameter determines whether this
  115                     }        code is part of the message output by M$ERRMSG.
  116                     }
  117                     .unl 8
  118                     }text    is the message obtained from the message
  119                     }        file identified by the FILENAME parameter.  The
  120                     }        text may include:
  121                     }
  122                     }        o  Text characters.
  123                     }
  124                     }        o  Substitution names represented by %FN, %AC,
  125                     }           %DC, %U1, etc.
  126                     }
  127                     }        o  Conditional fields framed by % symbols and
  128                     }           containing the substitution character
  129                     }           strings.
  130
  131                     .inl 0
  132
  133                     M$ERRMSG
  134                     .SPF 1
  135                     The M$ERRMSG service obtains an error message
  136                     based on the error code supplied as a parameter,
  137                     and stores the message in the user buffer.
  138                     M$ERRMSG allows phrase and message substitution,
  139                     allows override of vertical format control, and
  140                     allows suppression of portions of the error
  141                     display.  The output of the M$ERRMSG service is
  142                     returned in RESULTS area.
  143
  144                     The M$ERRMSG service sends the error display
  145                     through one or two DCBs specified for output.
  146                     Correspondence checking is performed to determine
  147                     if the DCB assignments are identical. Errors
  148                     encountered in writing through the OUTDCBs are
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          5    
  149                     indicated in the RESULTS area. If no output DCBs
  150                     are specified, the M$ERRMSG service simply stores
  151                     the message in the buffer and returns.
  152
  153                     The form of the call for this service is as follows:
  154
  155                     CALL M$ERRMSG (FPT_ERRMSG) [ALTRET(label)];
  156
  157                     The required parameters for the service are CODE
  158                     and BUF. All other parameters are optional.                  */
  159       %MACRO FPT_ERRMSG (FPTN = FPT_ERRMSG,
  160               CODE = NIL,
  161               BUF = NIL,
  162               FILENAME = NIL,
  163               FILEACCT = NIL,
  164               FILEPASS = NIL,
  165               FIELD1 = NIL,
  166               FIELD2 = NIL,
  167               FIELD3 = NIL,
  168               RESULTS = NIL,
  169               DCB = NIL,
  170               OUTDCB1 = NIL,
  171               OUTDCB2 = NIL,
  172               ALTCODE = NIL,
  173               FLAGLEV = 0,
  174               VFC="BINASC(0)",
  175               SUBFN (YES='1'B,NO='0'B)= '1'B,
  176               SUBAC (YES='1'B,NO='0'B)= '1'B,
  177               SUBDC (YES='1'B,NO='0'B)= '1'B,
  178               SUBSN (YES='1'B,NO='0'B)= '1'B,
  179               INCLCODE (YES='1'B,NO='0'B)= '1'B,
  180               LEAVETOKEN (YES='1'B,NO='0'B)= '0'B,
  181               TYC (YES='1'B,NO='0'B)= '0'B,
  182               L6_CODE (YES='1'B,NO='0'B)= '0'B,
  183               L6_ALTCODE (YES='1'B,NO='0'B)= '0'B,
  184               SUBMESS (YES='1'B,NO='0'B)= '1'B,
  185               MY_LANG (YES='1'B,NO='0'B)= '1'B,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          6    
  186               LANG=' ',
  187               SUBLANG (YES='1'B,NO='0'B)= '1'B,
  188               SUBFILE (YES='1'B,NO='0'B)= '1'B,
  189               STCLASS = STATIC,
  190               POINTER = 0,
  191               NREAD (YES='1'B,NO='0'B)= '0'B,
  192               SOURCE (PASS=0,TRAP=1,ALTRET=2)= 0,
  193               YES (YES='1'B,NO='0'B)= '1'B,NO= '0'B);
  194
  195       %LSET LISTDIR='0'B;
  196       %LSET LISTEXP='1'B;
  197       %LSET LISTCOM='0'B;
  198       %LSET LISTSUB='1'B;
  199       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  200       %IF (SUBSTR(STR,0,6)='STATIC') OR
  201       (SUBSTR(STR,0,8)='CONSTANT') OR
  202       (SUBSTR(STR,0,3)='EXT');
  203       %LSET INIT=CHARTEXT('INIT');
  204       %ELSE;
  205       %LSET INIT=CHARTEXT('/*');
  206       %ENDIF;
  207
  208                                    /**/
  209      DCL 1 FPTN STCLASS,
  210            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  211            2 CODE_ BIT(72) %INIT(VECTOR(CODE))%CHARTEXT('/**/'),
  212                          /*K* CODE = VARIABLE specifies the 1-word area in
  213                          memory containing the error code identifying the
  214                          message to be read from the file. It is used to
  215                          form the key to read the file.  To generate the
  216                          structure for the error code, use the VLP_ERRCODE
  217                          macro described in this section; or, for monitor service
  218                          errors, the B$ALT macro discussed in Section 6.         */
  219            2 BUF_ BIT(72) %INIT(VECTOR(BUF))%CHARTEXT('/**/'),
  220                          /*K* BUF = VARIABLE specifies the buffer used when
  221                          reading the file. BUF must have a minimum size
  222                          of 120 bytes, the maximum size of any record in
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          7    
  223                          the file. Because some error messages may
  224                          consist of multiple records in the file, a
  225                          120-byte buffer will not always be large enough
  226                          to hold the whole message. The caller may
  227                          alleviate this condition by specifying a larger
  228                          buffer.
  229
  230                          Records from the file are read into the buffer at
  231                          120-byte offsets until the buffer is full or the
  232                          message is complete. Status is returned to the
  233                          caller indicating how many records are in the
  234                          buffer, and whether or not the message is
  235                          complete. If the buffer is not large enough to
  236                          hold all of the records of the message, then the
  237                          contents of the buffer will vary depending on
  238                          whether the caller supplied OUTDCBs through which
  239                          to output the messages. Given a buffer with
  240                          enough space for n records, if no OUTDCBs have
  241                          been specified, the buffer will contain the first
  242                          n records of the message. If OUTDCBs have been
  243                          specified, then the buffer will contain the first
  244                          n-1 records in the first n-1 slots, and the last
  245                          record of the message in the nth slot.
  246
  247                          Example:
  248
  249                          Suppose the user passes a 360-byte buffer and
  250                          tries to read varying size error messages.
  251
  252                          TU
  253                          1.   2-record error message
  254
  255                                 1          Record 1         120
  256                               121          Record 2         240
  257                               241                           360
  258                          TF
  259
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          8    
  260                          On a normal return, the RESULTS area indicates
  261                          that the buffer contains the complete message and
  262                          it is two records.
  263
  264                          TU
  265                          2.   4-record error message - no OUTDCBs specified.
  266
  267                                 1          Record 1         120
  268                               121          Record 2         240
  269                               241          Record 3         360
  270
  271                          TF
  272                          On an alternate return, the RESULTS area indicates
  273                          that the buffer holds three records but that the
  274                          message is incomplete.
  275
  276                          TU
  277                          3.   4-record error message - OUTDCBs specified.
  278
  279                                 1          Record 1         120
  280                               121          Record 2         240
  281                               241          Record 4         360
  282
  283                          TF
  284                          On a normal return, the RESULTS area indicates
  285                          that the buffer contains three records but that
  286                          the message is incomplete.  With OUTDCBs
  287                          specified, a normal return from M$ERRMSG occurs
  288                          after the complete 4-record message is written
  289                          through the user DCBs.                                  */
  290            2 FILENAME_ BIT(72) %INIT(VECTOR(FILENAME))%CHARTEXT('/**/'),
  291                          /*K* FILENAME = VARIABLE specifies the area containing
  292                          the TEXTC name of a file to be read for the error
  293                          message.  The VLP_NAME macro may be invoked to
  294                          generate this area. If the named file cannot be
  295                          opened or if no error message or default message
  296                          can be found in the file, this condition is
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          9    
  297                          treated as if no FILENAME were specified.  If
  298                          FILENAME is not specified or is NIL or if MON is
  299                          not 0, M$ERRMSG
  300                          analyzes the FCG of the CODE passed to it.  If
  301                          the first letter of the FCG is
  302
  303                          .FIF
  304                          Q (forms)
  305                          V (except VC [IMP], VE [EDIT], VP [PCL],
  306                             VX [LINK], VY [LEMUR] which search for their
  307                             own error message files)
  308                          Y (installation-specific)
  309                          X (libraries)
  310                          Z (language processors)
  311                          .FIN
  312
  313                          the error message file is assumed to be:
  314                          xxERRMSG, where xx stands for the 2-character FCG
  315                          (for example, ZF for Fortran).  If the first
  316                          letter of the FCG in CODE is not one mentioned in
  317                          the previous sentence or if MON='1'B, the monitor
  318                          service error
  319                          message file (:ERRMSG) is used.  The default is NIL.
  320
  321                          NOTE: The system permits foreign language
  322                          versions of error message files.  Each user may
  323                          optionally have a single character in the JIT
  324                          which specifies his native language.  If this
  325                          language character is specified, it is used to
  326                          select the error message file.  For example, if
  327                          the user's language character is 'F' for French,
  328                          then instead of :ERRMSG, the file :ERRMSGF, which
  329                          can be defined to contain French text, is
  330                          accessed.                                               */
  331            2 FILEACCT_ BIT(72) %INIT(VECTOR(FILEACCT))%CHARTEXT('/**/'),
  332                          /*K* FILEACCT = VARIABLE specifies the area containing
  333                          the account for the error message file. The
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          10   
  334                          VLP_ACCT macro may be invoked to generate this
  335                          area.  The default is NIL.                              */
  336            2 FILEPASS_ BIT(72) %INIT(VECTOR(FILEPASS))%CHARTEXT('/**/'),
  337                          /*K* FILEPASS = VARIABLE specifies the area containing
  338                          the password for the error message file. The
  339                          VLP_PASS macro may be invoked to generate this
  340                          area.  The default is NIL.                              */
  341            2 FIELD1_ BIT(72) %INIT(VECTOR(FIELD1))%CHARTEXT('/**/'),
  342                          /*K* FIELD1 = VARIABLE  specifies the location of the
  343                          TEXTC field (up to 31 characters of text) to be
  344                          substituted into the error
  345                          message for the special string %U1. If an error
  346                          message contains any special string %Ux and the
  347                          corresponding FIELDx is not supplied, then blanks
  348                          are substituted, or the conditional phrase is not
  349                          printed.  The default is NIL.                           */
  350            2 FIELD2_ BIT(72) %INIT(VECTOR(FIELD2))%CHARTEXT('/**/'),
  351                          /*K* FIELD2 = VARIABLE  specifies the location of the
  352                          TEXTC field (up to 31 characters of text) to be
  353                          substituted for %U2.
  354                          The default is NIL.                                     */
  355            2 FIELD3_ BIT(72) %INIT(VECTOR(FIELD3))%CHARTEXT('/**/'),
  356                          /*K* FIELD3 = VARIABLE specifies the location of the
  357                          TEXTC field (up to 31 characters of text) to be
  358                          substituted for %U3.
  359                          The default is NIL.                                     */
  360            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
  361                          /*K* RESULTS = VARIABLE specifies an area in the
  362                          user's data where any status information about a
  363                          call to M$ERRMSG is returned to the caller.  The
  364                          information returned consists of bits indicating
  365                          unusual conditions encountered in the processing
  366                          of the CALL, and a field containing the count of
  367                          records from the message file returned in the
  368                          user's buffer.  The VLR_ERRMSG macro described
  369                          later in this section can be invoked to generate
  370                          this area.  The default is NIL.                         */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          11   
  371            2 ALTCODE_ BIT(72) %INIT(VECTOR(ALTCODE))%CHARTEXT('/**/'),
  372                          /*K* ALTCODE = VARIABLE specifies the 1-word area in
  373                          memory containing the error code identifying the
  374                          alternate message to be read from the file. It is used
  375                          to form the key to read the file if no message can
  376                          be found for CODE.  To generate the
  377                          structure for the error code, use the VLP_ERRCODE
  378                          macro described in this section; or, for monitor service
  379                          errors, the B$ALT macro discussed in Section 6.
  380                          The default is NIL.                                     */
  381            2 V DALIGNED,
  382              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
  383                          /*K* DCB = DCBNAME specifies the DCB on which the
  384                          error condition occurred. DCB is used to obtain
  385                          variable information which is substituted into
  386                          the error message for special strings %FN, %AC, %TA,
  387                          %UF, %DC and %SN. If an error message contains these
  388                          special strings and DCB is not specified, then
  389                          blanks are substituted, or the conditional phrase
  390                          is not printed.  The default is NIL.                    */
  391              3 OUTDCB1# UBIN(18) UNAL %INIT(DCBNUM(OUTDCB1))%CHARTEXT('/**/'),
  392                          /*K* OUTDCB1 = DCBNAME specifies the first DCB through
  393                          which to output the error message.  The default is NIL. */
  394              3 OUTDCB2# UBIN(18) UNAL %INIT(DCBNUM(OUTDCB2))%CHARTEXT('/**/'),
  395                          /*K* OUTDCB2 = DCBNAME specifies the second DCB
  396                          through which to output the error message.
  397                          The default is NIL.                                     */
  398              3 FLAGLEV# UBIN(9) UNAL %INIT(FLAGLEV)%CHARTEXT('/**/'),
  399                          /*K* FLAGLEV = VALUE-DEC(0-4) Error messages may be
  400                          preceded by some number of asterisks (*).  The
  401                          number is an indication of the seriousness of the
  402                          message.  FLAGLEV gives the number of asterisks,
  403                          from 0-4, that precede the message.  The default is 0.
  404                          */
  405
  406              3 VFC# CHAR(1) UNAL %INIT(VFC)%CHARTEXT('/**/'),
  407                          /*K* VFC = VALUE-CHAR(1)    may be specified when
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          12   
  408                          writing the error message.  This code is used
  409                          when writing the message through either or both
  410                          OUTDCBs.  The default is zero meaning that the
  411                          user's default VFC will be used.                        */
  412              3 LEAVETOKEN# BIT(1) UNAL %INIT(LEAVETOKEN)%CHARTEXT('/**/'),
  413              3 SUBFILE# BIT(1) UNAL %INIT(SUBFILE)%CHARTEXT('/**/'),
  414                          /*K* SUBFILE = {YES|NO} specifies, if YES, to use
  415                          the default system error message file if the file
  416                          passed by the user does not contain a message for
  417                          the code passed in this call.  The default is YES.
  418                          */
  419              3 SUBFN# BIT(1) UNAL %INIT(SUBFN)%CHARTEXT('/**/'),
  420                          /*K* SUBFN = {YES|NO}   specifies, if YES, that %FN in
  421                          the error message is to be considered a candidate
  422                          for substitution.  %FN (file name) is obtained
  423                          from the data control block specified by the DCB
  424                          parameter.  If SUBFN=NO, the %FN is blanked out
  425                          or the conditional phrase that contains %FN is
  426                          eliminated.  The default is YES.                        */
  427              3 SUBAC# BIT(1) UNAL %INIT(SUBAC)%CHARTEXT('/**/'),
  428                          /*K* SUBAC = {YES|NO}   specifies, if YES, that %AC in
  429                          the error message is to be considered a candidate
  430                          for substitution.  %AC (account) is obtained from
  431                          the data control block specified by the DCB
  432                          parameter.  If SUBAC=NO, the %AC is blanked out
  433                          or the conditional phrase that contains %AC is
  434                          eliminated.  The default is YES.                        */
  435              3 SUBDC# BIT(1) UNAL %INIT(SUBDC)%CHARTEXT('/**/'),
  436                          /*K* SUBDC = {YES|NO}  specifies, if YES, that %DC in
  437                          the error message is to be considered a candidate
  438                          for substitution.  %DC (DCB name) is obtained from
  439                          the DCB parameter.  If SUBDC=NO, the %DC is
  440                          blanked out or the conditional phrase that
  441                          contains %DC is eliminated.  The default is YES.        */
  442              3 SUBSN# BIT(1) UNAL %INIT(SUBSN)%CHARTEXT('/**/'),
  443                          /*K* SUBSN = {YES|NO}   specifies, if YES, that %SN in
  444                          the error message is to be considered a candidate
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          13   
  445                          for substitution.  %SN (serial number or set
  446                          name) is obtained from the DCB parameter. If
  447                          SUBSN=NO, %SN is blanked out or the conditional
  448                          phrase that contains %SN is eliminated.
  449                          The default is YES.                                     */
  450              3 INCLCODE# BIT(1) UNAL %INIT(INCLCODE)%CHARTEXT('/**/'),
  451                          /*K* INCLCODE = {YES|NO} indicates whether or not the
  452                          error code should be output before the error
  453                          message.  The default is YES.                           */
  454              3 TYC# BIT(1) UNAL %INIT(TYC)%CHARTEXT('/**/'),
  455                          /*K* TYC = {YES|NO}  specifies, if YES, the TYC (type of
  456                          completion) information from the specified DCB
  457                          should be output after the error message.  TYC is
  458                          meaningful only if DCB was specified.
  459                          The default is NO.                                      */
  460              3 SUBMESS# BIT(1) UNAL %INIT(SUBMESS)%CHARTEXT('/**/'),
  461                          /*K* SUBMESS = {YES|NO} specifies, if YES, to use a
  462                          substitute message, (i.e., one with less severity)
  463                          or the default message, if the error message file
  464                          contains no message corresponding to the CODE
  465                          specified.  The default is YES.  If NO substitute
  466                          message is available, the text of the error code
  467                          is used (See INCLCODE).                                 */
  468              3 POINTER# UBIN(9) UNAL %INIT(POINTER)%CHARTEXT('/**/'),
  469                          /*K* POINTER = VALUE-DEC(0-LENGTHC(BUF))
  470                          .trf ^^
  471                          specifies,
  472                          if non-zero, that a pointer (^) should be output
  473                          on a line before the error message and in which
  474                          character position it should be placed.  If POINTER
  475                          is zero, or greater than LENGTHC(BUF), no pointer
  476                          is output.  If the requested message cannot be found,
  477                          the pointer is output and M$ERRMSG will ALTRETURN after
  478                          printing the pointer.  Note that this option will
  479                          not work with NREAD = YES.  The default is 0.
  480                          .trf ^                                                  */
  481              3 NREAD# BIT(1) UNAL %INIT(NREAD)%CHARTEXT('/**/'),
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          14   
  482                          /*K* NREAD = {YES|NO} specifies, if YES, that the buffer
  483                          contents should be output as passed, without reading
  484                          the error message file but with substitution.  The
  485                          default is NO.                                          */
  486
  487              3 SOURCE# UBIN(3) UNAL %INIT(SOURCE)%CHARTEXT('/**/'),
  488                          /*K* SOURCE = {PASS|TRAP|ALTRET} specifies where
  489                          M$ERRMSG should look for the error code and DCB
  490                          to report on.  PASS, the default, indicates that the
  491                          error code will be passed in CODE.  TRAP indicates
  492                          that M$ERRMSG should look in B$EXCFR.ERR for the
  493                          error code.  ALTRET tells M$ERRMSG to look in
  494                          B$ALT.ERR for the error code and DCB.
  495
  496                          The fully qualified name of this field is
  497                          FPT_ERRMSG.V.SOURCE#.  Acceptable EQUs are
  498                          SOURCE_PASS#, SOURCE_TRAP#, and SOURCE_ALTRET#.
  499                          */
  500              3 SUBLANG# BIT(1) UNAL %INIT(SUBLANG)%CHARTEXT('/**/'),
  501                          /*K* SUBLANG = {YES|NO}. Specifies, if YES, that a
  502                          message will be in the default language if the user's
  503                          native language is not available.  The default
  504                          is YES.                                                 */
  505              3 * BIT(10) UNAL %INIT('1'B)%CHARTEXT('/**/'), /* SPARES            */
  506              3 L6_CODE# BIT(1) UNAL %INIT(L6_CODE)%CHARTEXT('/**/'),
  507                          /*K* L6_CODE = {YES|NO}  specifies, if YES, that the
  508                          code specified by the CODE parameter is in unpacked
  509                          LCP-6 error code format.  Default = NO.
  510                          */
  511              3 L6_ALTCODE# BIT(1) UNAL %INIT(L6_CODE)%CHARTEXT('/**/'),
  512                          /*K* L6_ALTCODE = {YES|NO}  specifies, if YES, that the
  513                          code specified by the ALTCODE parameter is in unpacked
  514                          LCP-6 error code format.  Default = NO.
  515                          */
  516              3 MY_LANG# BIT(1) UNAL %INIT(MY_LANG)%CHARTEXT('/**/'),
  517                          /*K* MY_LANG = {YES|NO}   specifies, if YES, that the
  518                          default native language key is that of the user making
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          15   
  519                          the M$ERRMSG request.  NO specifies that the character
  520                          specified via the LANG option is to be used in selecting
  521                          the error message file.  The default is YES.
  522                          */
  523              3 LANG# CHAR(1) UNAL %INIT(LANG)%CHARTEXT('/**/'),
  524                     /*K* LANG = VALUE-CHAR(1)   specifies the character that is
  525                     to be assumed to be the native language when selecting the
  526                     error message file.
  527                     */
  528              3 * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'); /* SPARES            */
  529
  530                          /*F* NAME: Error Message Field and Phrase Substitution.
  531
  532                          An error message record may contain one or more
  533                          special strings which indicate that text is to be
  534                          substituted in their place. This text may be
  535                          either passed by the user or obtained from a DCB.
  536                          The following is a list of these special strings.
  537
  538                          User passed:
  539                          .inl 6
  540                          .unl 6
  541                          %U1 - specifies text passed in FIELD1 is to be
  542                          inserted in the message in this place.
  543                          .unl 6
  544                          %U2 - specifies text passed as FIELD2.
  545                          .unl 6
  546                          %U3 - specifies text passed as FIELD3.
  547
  548                          .unl 6
  549                          From DCB:
  550                          .unl 6
  551                          %FN - the text substituted for this string will
  552                          be FILENAME[.ACCOUNT] from the passed DCB.
  553                          The account is appended if it is not the
  554                          current File Management account.
  555                          .unl 6
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          16   
  556                          %DC - specifies the text DCB name of the passed
  557                          DCB.
  558                          .unl 6
  559                          %AC - specifies that the text account from the
  560                          passed DCB is to be placed in the message.
  561                          .unl 6
  562                          %SN - specifies the text serial number from the DCB.
  563                          .unl 6
  564                          %TA - the text to be substituted will take one of
  565                          these forms:
  566                          .inl 8
  567                          .unl 6
  568                          FT#xxxxxx - if the passed DCB is open to
  569                          a free-form tape.
  570                          .unl 6
  571                          LT#xxxxxx/filename - if the passed DCB is
  572                          open to a labeled tape.
  573                          .unl 6
  574                          MT#xxxxxx - if the passed DCB is open to
  575                          a managed tape.
  576                          .inl 6
  577                          .unl 6
  578                          %UF - specifies that an M$UNFID function is to be
  579                          performed on the passed DCB and the resulting
  580                          text is to be placed in the message.
  581                          .inl 0
  582
  583                          The M$ERRMSG service makes field and phrase
  584                          substitutions to the record read from the message
  585                          file, depending on parameters specified. However,
  586                          if the expanded record exceeds the size of one buffer
  587                          slot, the substitution is truncated.  A record
  588                          shown in the following example demonstrates the
  589                          various substitutions that can occur for one
  590                          record in the message file.
  591
  592                          Example:
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          17   
  593
  594                          End of File %on file %FN %%on DCB %DC%
  595
  596                          contains two conditional phrases of which
  597                          neither, either or both may appear in the final
  598                          message. The finished message will be one of the
  599                          following:
  600
  601                          TU
  602                          M$ERRMSG Parameters
  603                          SUBFN    SUBDC      Message
  604
  605                          =NO      =NO        End of File
  606
  607                          =YES     =NO        End of File on file FILE.ACCT
  608
  609                          =NO      =YES       End of File on DCB M$EI
  610
  611                          =YES     =YES       End of File on file FILE.ACCT
  612                          }                   on DCB M$EI
  613                          TF
  614
  615                          When calculating the length of a record in the
  616                          message file, the user must consider the maximum
  617                          size of the message after substitutions are
  618                          performed. The record must not produce an actual
  619                          text message of more than 120 characters.
  620
  621                          .brn 4
  622                          SUBMESS OPTION
  623                          .spf
  624                          The M$ERRMSG service attempts to find a message
  625                          in the message file with a key that reflects the
  626                          exact error code specified in the CODE parameters.
  627                          If there is no such message and if the SUBMESS=YES
  628                          parameter is specified, the service searches the
  629                          file for a suitable replacement message. On a
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          18   
  630                          normal return following use of a substitute
  631                          message, the returned status indicates that an
  632                          alternate message was used.
  633
  634                          The messages suitable for substitution are listed
  635                          below in the order of the search.
  636
  637                          1.  A record with the same FCG-MID and ERR# as
  638                          the requested CODE but a smaller severity (SEV);
  639                          that is, a less verbose message for the same
  640                          error.
  641
  642                          2.  A record with the same FCG, ERR# and SEV but a
  643                          null MID.  This is the default message for this
  644                          error from this functional code group.  A
  645                          processor which detects the same error in many
  646                          modules need only have one entry in the message
  647                          file for the error.
  648
  649                          3.  A record with the same FCG and ERR# but a null
  650                          MID and smaller SEV field than the passed code.
  651                          This is a less verbose FCG default message.
  652
  653                          4.  A record with the same ERR# and SEV but a null
  654                          FCG-MID field; that is, the default message for
  655                          this error condition and level of detail.
  656
  657                          5.  A record with the same ERR# but a null FCG-MID
  658                          and a smaller severity; that is, a less verbose
  659                          default message for this error condition.
  660
  661                          6.  The text version of the error code (as if
  662                          INCLCODE has been set).
  663
  664                          */
  665       %MEND;
  666                                    /**/
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          19   
  667                          /*F* NAME: VLR_ERRMSG
  668
  669                          The VLR_ERRMSG macro generates an area which
  670                          receives the results of the M$ERRMSG service. The
  671                          area contains these fields:                             */
  672                                    /**/
  673       %MACRO VLR_ERRMSG (FPTN = VLR_ERRMSG,
  674                         STCLASS = STATIC);
  675
  676       %LSET LISTDIR='0'B;
  677       %LSET LISTEXP='1'B;
  678       %LSET LISTCOM='0'B;
  679       %LSET LISTSUB='1'B;
  680       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  681       %IF (SUBSTR(STR,0,6)='STATIC') OR
  682       (SUBSTR(STR,0,8)='CONSTANT') OR
  683       (SUBSTR(STR,0,3)='EXT');
  684       %LSET INIT=CHARTEXT('INIT');
  685       %ELSE;
  686       %LSET INIT=CHARTEXT('/*');
  687       %ENDIF;
  688
  689      DCL 1 FPTN STCLASS DALIGNED,
  690            2 BADCALL BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ILLEGAL PARAMETERS */
  691                          /*K* BADCALL = VALUE-BIT(1)   if set specifies that
  692                          the call contained one or more illegal
  693                          parameters.                                             */
  694            2 NOFILE BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* UNABLE TO OPEN FILE */
  695                          /*K* NOFILE = VALUE-BIT(1)   if set specifies that
  696                          M$ERRMSG  was unable to open the message file.          */
  697            2 NOMSG BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* UNABLE TO FIND ANY MESSAGE */
  698                          /*K* NOMSG = VALUE-BIT(1)   if set means that
  699                          M$ERRMSG  was unable to find any message for the
  700                          error code.                                             */
  701            2 ALTMSG BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* SUBSTITUTE MESSAGE USED */
  702                          /*K* ALTMSG = VALUE-BIT(1)   if set means that
  703                          M$ERRMSG  stored a substitute message in the user
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          20   
  704                          buffer.                                                 */
  705            2 MSGCOMP BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ENTIRE MESSAGE IS IN BUFFER */
  706                          /*K* MSGCOMP = VALUE-BIT(1)   if set means that the
  707                          entire message is stored in the user buffer.            */
  708            2 OUTERR1 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON OUTDCB1 */
  709                          /*K* OUTERR1 = VALUE-BIT(1)   if set specifies an
  710                          error on OUTDCB1.                                       */
  711            2 OUTERR2 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON OUTDCB2 */
  712                          /*K* OUTERR2 = VALUE-BIT(1)   if set specifies
  713                          error on OUTDCB2.                                       */
  714            2 NNATIVE BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* MESSAGE PROVIDED IS NOT IN NATIVE LANGUAGE */
  715                          /*K* NNATIVE = VALUE-BIT(1)   if set means that the
  716                          returned message is not in the user's native language.  */
  717            2 BUFERR BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* BUFFER PASSED IS MALFORMED */
  718                          /*K* BUFERR = VALUE-BIT(1)   if set specifies that
  719                          the buffer is not there or bad.                         */
  720            2 INERR BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON INPUT   */
  721                          /*K* INERR = VALUE-BIT(1)   if set specifies
  722                          error on reading the message.                           */
  723            2 TRUNCSUB BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* TRUNCATED SUB */
  724                          /*K* TRUNCSUB = VALUE-BIT(1)   if set specifies
  725                          that one or more substitution fields were truncated
  726                          because expanding them would have overflowed the
  727                          buffer slot.                                            */
  728            2 BADPOINT BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* BAD POINTER   */
  729                          /*K* BADPOINT = VALUE-BIT(1)   if set specifies
  730                          that the POINTER option is bad.                         */
  731            2 BADUSUB BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* BAD USER SUB   */
  732                          /*K* BADUSUB = VALUE-BIT(1)   if set specifies
  733                     that a bad user substitution field has been encountered.     */
  734            2 * BIT(14) UNAL,       /* SPARE BITS                                 */
  735            2 RECCNT UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'), /* COUNT OF RECORDS READ INTO BUFFER */
  736                          /*K* RECCNT = VALUE-DEC(0-n)   specifies a count of
  737                          records read into the user buffer.                      */
  738            2 ERRCODE1 UNAL,        /* ERROR CODE FOR ERRORS ON OUTDCB1           */
  739                          /*K* ERRCODE1   specifies the error code for OUTDCB1,
  740                          in the normal format for monitor service errors.        */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          21   
  741              3 FCG BIT(12) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  742              3 MID BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  743              3 MON BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  744              3 ERR# UBIN(14) UNAL %INIT(0)%CHARTEXT('/**/'),
  745              3 SEV UBIN(3) UNAL %INIT(0)%CHARTEXT('/**/'),
  746            2 ERRCODE2 UNAL,        /* ERROR CODE FOR ERRORS ON OUTDCB2           */
  747                          /*K* ERRCODE2   specifies the error code for OUTDCB2,
  748                          in the normal format for monitor service errors.        */
  749              3 FCG BIT(12) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  750              3 MID BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  751              3 MON BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  752              3 ERR# UBIN(14) UNAL %INIT(0)%CHARTEXT('/**/'),
  753              3 SEV UBIN(3) UNAL %INIT(0)%CHARTEXT('/**/'),
  754            2 CODEUSED UNAL,        /* CODE FOR MESSAGE USED                      */
  755                          /*K* CODEUSED  specifies the code for the message
  756                          that was in fact output to the caller. CODEUSED is
  757                          in the normal format for monitor service errors.        */
  758              3 FCG BIT(12) UNAL,
  759              3 MID BIT(6) UNAL,
  760              3 MON BIT(1) UNAL,
  761              3 ERR# UBIN(14) UNAL,
  762              3 SEV UBIN(3) UNAL;
  763       %MEND;
  764                          /*F* NAME: VLP_ERRCODE
  765
  766                          The VLP_ERRCODE macro generates a standard CP-6
  767                          error code.  This is the code that will be returned
  768                          to the user in the altreturn frame. It is also
  769                          passed to M$ERRMSG to identify a message.               */
  770
  771      %MACRO VLP_ERRCODE (FPTN = VLP_ERRCODE,
  772                          STCLASS = STATIC,
  773                          ALGN=ALIGNED,
  774                          LVL = 1,
  775                          LAST = ";",
  776                          FCG = '0'B,
  777                          MID = '0'B,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          22   
  778                          MON = '0'B,
  779                          ERR# = 0,
  780                          SEV = 0);
  781
  782       %LSET LISTDIR='0'B;
  783       %LSET LISTEXP='1'B;
  784       %LSET LISTCOM='0'B;
  785       %LSET LISTSUB='1'B;
  786       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  787       %IF (SUBSTR(STR,0,6)='STATIC') OR
  788       (SUBSTR(STR,0,8)='CONSTANT') OR
  789       (SUBSTR(STR,0,3)='EXT');
  790       %LSET INIT=CHARTEXT('INIT');
  791       %ELSE;
  792       %LSET INIT=CHARTEXT('/*');
  793       %ENDIF;
  794
  795       %IF LVL=1;
  796      DCL 1 FPTN STCLASS ALGN,
  797       %ELSE;
  798              %LVL FPTN ALGN,
  799       %ENDIF;
  800
  801      %LSET FCG#=CONCAT(TEXTCHAR(FCG),BINASC(0),BINASC(0));
  802      %LSET L=LENGTHC(TEXTCHAR(FCG))-1;
  803      %IF L<1;
  804      %ELSEIF SUBSTR(FCG#,0,1)='''' AND(SUBSTR(FCG#,L,1)='''');
  805      %LSET FCG#=CONCAT(SUBSTR(FCG#,1,L-1),BINASC(0));
  806      %LSET L=L-2;
  807      %ENDIF;
  808      %IF SUBSTR(FCG#,0,1)~='''' AND(L<2);
  809      %LSET FCG#=CONCAT(SUBBIT(ASCBIT(SUBSTR(FCG#,0,1)),3,6),SUBBIT(ASCBIT(SUBSTR(FCG#,1,1)),3,6));
  810      %ELSE;
  811      %LSET FCG#=FCG;
  812      %ENDIF;
  813                %(LVL+1) %CHARTEXT('FCG ') BIT(12) %INIT(%FCG#) %CHARTEXT('/**/') UNAL,
  814                          /*K* FCG = VALUE-BIT(12).  This field
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          23   
  815                          contains the two special six bit characters that
  816                          identify the functional code group that is
  817                          reporting the error.  For convenience, it may be
  818                          specified as text or as a quote string (e.g., FCG=FM).  */
  819      %LSET MID#=CONCAT(TEXTCHAR(MID),BINASC(0));
  820      %LSET L=LENGTHC(TEXTCHAR(MID))-1;
  821      %IF L<1;
  822      %ELSEIF SUBSTR(MID#,0,1)='''' AND(SUBSTR(MID#,L,1)='''');
  823      %LSET MID#=SUBSTR(MID#,1,L-1);
  824      %LSET L=L-2;
  825      %ENDIF;
  826      %IF SUBSTR(MID#,0,1)~='''' AND(L<2);
  827      %LSET MID#=SUBBIT(ASCBIT(SUBSTR(MID#,0,1)),3,6);
  828      %ELSE;
  829      %LSET MID#=MID;
  830      %ENDIF;
  831                %(LVL+1) %CHARTEXT('MID ') BIT(6) %INIT(%MID#) %CHARTEXT('/**/') UNAL,
  832                          /*K* MID = VALUE-BIT(6).  This field
  833                          contains the special six bit character that identifies
  834                          which module in the functional code group is
  835                          reporting the error.  For convenience, it may be
  836                          specified as text or as a quote string (e.g., MID='M'). */
  837                %(LVL+1) %CHARTEXT('MON ') BIT(1) %INIT(MON) %CHARTEXT('/**/') UNAL,
  838                          /*K* MON = VALUE-BIT(1).  This bit
  839                          is set if this error is reported by the monitor.        */
  840                %(LVL+1) %CHARTEXT('ERR# ') UBIN(14) %INIT(ERR#) %CHARTEXT('/**/') UNAL,
  841                          /*K* ERR# = VALUE-DEC(0-16383).  This field
  842                          contains the number that identifies a particular
  843                          error condition.  The file B_ERRORS_C contains a
  844                          list of these ERR#s for the monitor.                    */
  845                %(LVL+1) %CHARTEXT('SEV ') UBIN(3) %INIT(SEV) %CHARTEXT('/**/') UNAL LAST
  846                          /*K* SEV = VALUE-DEC(0-7).  This field
  847                          serves a double purpose.  Within the monitor it is
  848                          used to indicate the seriousness of an error.  When
  849                          passed by the user to M$ERRMSG it indicates the level
  850                          of detail requested in the error message.               */
  851
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          24   
  852      %MEND;
  853                          /*F* NAME: Creating User Error Message Files.
  854
  855                          The user may use M$ERRMSG to report error
  856                          conditions detected in his own program by
  857                          performing these steps:
  858
  859                          1.  Including error commentary in the user source
  860                              code in the format described below.
  861
  862                          2.  Creating a %SUBs file of error mnemonics and
  863                              corresponding error numbers (if the source
  864                              code refers to error conditions by mnemonics).
  865
  866                          3.  Creating a data base of error commentary in
  867                              the source code via the EXTRACT processor.
  868
  869                          4.  Creating an error message file via the EXTRACT
  870                              processor, using the error commentary data
  871                              base and the %SUBs file as input.
  872
  873                          Error Commentary and %SUBs Error Codes
  874
  875                          At the first occurrence of the error in the user
  876                          procedure, the user supplies error commentary in
  877                          the format shown below for a PL-6 program:
  878                          TU
  879
  880                          *E*      ERROR:  fff-name-s
  881                             MESSAGE:  text of message
  882                            MESSAGE1:  text of message
  883                            .
  884                            .
  885                            MESSAGE7:  text of message
  886                          DESCRIPTION:  text of description (ignored by EXTRACT) *
  887
  888                          where
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          25   
  889
  890                          .INL 5
  891                          .unl 5
  892                          }*E*...*  delimits each error comment in PL-6 source
  893                          code.
  894
  895                          .unl 5
  896                          fff     is the 2- or 3-character FCG-MID or is
  897                          blank.
  898
  899                          .unl 5
  900                          name   is the mnemonic or code associated with the
  901                          error condition.  If a mnemonic is associated with the
  902                          error in the source code, a separate file %SUBs
  903                          must be supplied to define a 1- to 5-digit error
  904                          number for each error mnemonic.  If a 1- to
  905                          5-digit error number is associated with the error
  906                          in the source code, the %SUB file is unnecessary.
  907
  908                          .unl 5
  909                          s       is the severity code associated with the
  910                          error condition.
  911
  912                          .unl 5
  913                          MESSAGE...MESSAGE7    provide up to eight
  914                          messages for a single error number.  The levels
  915                          of messages area intended to allow the user to
  916                          request increasingly detailed messages pertaining
  917                          to the error condition, from the briefest
  918                          (MESSAGE) to the most explanatory (MESSAGE7).
  919                          Each message consists of one or more lines.  Each
  920                          line can contain up to a maximum of 116
  921                          characters, which includes substitution phrases.
  922                          The maximum size of substitution fields is shown
  923                          below.
  924
  925                          TU
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          26   
  926                          Type                         Maximum Characters
  927
  928                          %FN  FID                           40
  929                          %AC  Account                        8
  930                          %SN  Serial number/Set name         6
  931                          %TA  Tape ID                       41
  932                          %DC  Data Control Block            31
  933                          %U1  User field 1                  31
  934                          %U2  User field 2                  31
  935                          %U3  User field 3                  31
  936                          TF
  937                          .inl 0
  938
  939                          When EXTRACT processes a multi-line message, the
  940                          space following MESSAGE: is considered as
  941                          column one; EXTRACT deletes leading blanks and
  942                          asterisks from any continuation lines.
  943
  944                          Example:
  945
  946                          TU
  947                          MESSAGE:text1
  948                          text2
  949                          *       text3
  950                          moretext
  951
  952                          results in a message:
  953
  954                          text1
  955                          text2
  956                          text3
  957                          moretext
  958
  959                           without preceding blanks.
  960                          TF
  961
  962
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          27   
  963                          GENERATING ERROR COMMENTARY DATA BASE AND ERROR
  964                          MESSAGE FILE
  965
  966                          The error commentary in the user's source code may
  967                          define one to eight messages for each error
  968                          mnemonic (or code).  The user can also code
  969                          default messages pertaining to:
  970
  971                          o  All occurrences of the same error condition
  972                             within all modules in a functional code
  973                             group.  In this case the  Module ID is set
  974                             to NIL.
  975
  976                          o  All occurrences of the same error condition
  977                             within all functional code groups in the
  978                             user procedure.  In this case, the
  979                             Functional Code Group and Module ID are set
  980                             to NIL.
  981
  982                          The method used by M$ERRMSG to determine which
  983                          message to display is described under the heading
  984                          SUBMESS Option.  The 2-step process to create the
  985                          error message file involves commands furnished to
  986                          the EXTRACT processor.
  987
  988                          As a first step, the user creates the error
  989                          commentary data base, via the EXTRACT or XLIST
  990                          command.  The syntax of the EXTRACT command is:
  991
  992                          EXTRACT fid
  993
  994                          where
  995
  996                          .inl 5
  997                          .unl 5
  998                          fid     is the file identification of the user's
  999                          source file which contains procedure and
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          28   
 1000                          error commentary.
 1001                          .inl 0
 1002
 1003
 1004                          As the second step, the user creates the error
 1005                          message file by requesting the BUILD command.  The
 1006                          syntax of the BUILD command is:
 1007
 1008                          BU[ILD] status fid1[,[fid2][,fid3]] type
 1009
 1010                          where
 1011
 1012                          .inl 5
 1013                          .unl 5
 1014                          status   is one of the following:
 1015
 1016                          ON  - Create a new file.  If one already exists,
 1017                          abort the command.
 1018
 1019                          INTO - Update an existing file.  If one does not
 1020                          exist, then create it.
 1021
 1022                          OVER - Overwrite an existing file.  If one does
 1023                          not exist, then create it.
 1024
 1025                          .unl 5
 1026                          fid1    is a legal file identifier.  This
 1027                          specifies the name of the error message file to
 1028                          be created.
 1029
 1030                          .unl 5
 1031                          fid2    is a legal file identifier.  It optionally
 1032                          specifies the name of the %SUB file that
 1033                          correlates error mnemonics with error numbers.
 1034                          (If error mnemonics are not used, fid2 can be
 1035                          omitted.)
 1036
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          29   
 1037                          .unl 5
 1038                          fid3    is a legal file identifier.  This
 1039                          optionally specifies a listfile.  If fid3 is
 1040                          specified, only the error comments from those
 1041                          modules named in this file are sent to the output
 1042                          file.  If fid3 is not specified, all error
 1043                          comments in the data base area processed.  fid3
 1044                          is a COPYSTD type file.
 1045
 1046                          Type is one of the following:
 1047
 1048
 1049                          PRO[CESSOR]   specifies that the output file is
 1050                          to be built from *E* type comments.
 1051
 1052                          MON[ITOR]   is reserved for Honeywell Bull internal
 1053                          use only. This option specifies that the
 1054                          output file is to be built from *E* type
 1055                          comments and the monitor bit in the key is to be
 1056                          set. Additional processing by EXTRACT produces
 1057                          default error messages.
 1058
 1059                          SCR[EECH]   is reserved for Honeywell Bull internal
 1060                          use only. This option specifies that the
 1061                          output file is to be built from *S*
 1062                          type comments in a special format.
 1063                          .inl 0
 1064
 1065                          No defaults exist because of the special function
 1066                          of this command.
 1067
 1068                          The following sample sequence of EXTRACT commands
 1069                          shows the creation of an error commentary data
 1070                          base. In the example, the asterisks are prompts
 1071                          from EXTRACT; underscored portions of the example
 1072                          are generated by the system; the remainder is
 1073                          entered by the user.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          30   
 1074
 1075                          Example:
 1076
 1077                          The following sequence creates an error commentary
 1078                          data base.  The data base must be in the
 1079                          running account.
 1080
 1081                          .fif
 1082                          !EXTRACT.X
 1083                          CP-6 EXTRACT
 1084                          *DATA_BASE BASE
 1085                          *EXTRACT SOURCE
 1086                          *END
 1087                          !
 1088                          .fin
 1089
 1090                          The next sample sequence creates an error message
 1091                          file. The DATA_BASE command opens the BASE file
 1092                          previously created.
 1093
 1094                          .fif
 1095                          !EXTRACT.X
 1096                          CP-6 EXTRACT
 1097                          *DATA_BASE BASE
 1098                          *BUILD ON ER_MSG,ER_SUB PROCESSOR
 1099                          *END
 1100                          !
 1101                          .fin
 1102
 1103                          Following this procedure, the call to M$ERRMSG
 1104                          specifying FILENAME=ER_MSG can be executed.
 1105                          */
 1106                               /**************************************************/
 1107                                    /*      HELP MESSAGE REPORTING SERVICE        */
 1108                               /**************************************************/
 1109
 1110                          /*F* NAME:  M$HELP - HELP Message Reporting.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          31   
 1111
 1112                The CP-6 system provides a comprehensive HELP facility for display
 1113                of information stored in a central location.  HELP is used primarily
 1114                to provide quick reference information on system or user processors.
 1115                HELP messages for a each processor are stored in a separate database
 1116                which may be available throughout the system and capable of
 1117                being utilized to produce other forms of documentation.
 1118
 1119                To respond to a HELP command, a processor may call the X$HELP
 1120                library service, which in turn parses the parameters of the
 1121                HELP command and calls the M$HELP monitor service.  X$HELP
 1122                isolates the calling processor from
 1123                the complexities of M$HELP and provides uniform handling
 1124                of HELP commands by all processors.
 1125
 1126                .brn 7
 1127                FILE OF HELP MESSAGES
 1128                .spf
 1129                The file of HELP messages is a keyed file created by
 1130                HERMAN.X.  The file typically contains the
 1131                following:
 1132
 1133                o  Abstract describing the processor and how to request
 1134                further HELP.  There may be breaks between increasingly
 1135                detailed levels of information within the abstract.
 1136
 1137                o  Topics describing the major topics of interest
 1138                concerning a processor.  Each topic is assigned a
 1139                keyword.
 1140
 1141                o  Subtopics containing information related to the
 1142                previous topic.  A subtopic that is assigned
 1143                a keyword is a message that can be obtained by a
 1144                specific request naming the keyword and the topic that it is under.
 1145                A subtopic without a keyword creates a break between levels of
 1146                messages related to a topic.
 1147
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          32   
 1148                o  Synonyms providing alternate ways to request a
 1149                topic or subtopic.
 1150
 1151       For an explanation of how to create a HELP message file, refer to the CP-6
 1152       Programmer Guide.
 1153
 1154       M$HELP
 1155
 1156       The caller of M$HELP normally specifies the processor name (PROCNAME)
 1157       and optionally, the account and password.  Based on this information
 1158       M$HELP determines which HELP file to read.  The form of the filename
 1159       is HELP:name:l.  Name is the processor name (PROCNAME) passed
 1160       by the caller and l is the optional native language byte from the JIT.
 1161       The account for a HELP message file defaults to :SYS.
 1162
 1163       The caller must also
 1164       specify a buffer (BUF) to receive the text and an area (RESULTS) to
 1165       receive status information.  The RESULTS area is generated
 1166       by invoking the VLR_HELP macro.
 1167
 1168       M$HELP provides two categories of functions:  (1) obtaining HELP messages
 1169       and (2) listing information about HELP.  To obtain HELP messages
 1170       the following parameters apply:  KEY1, KEY2, RANGE, ALL,
 1171       MORE, SUBTOPIC, SUBSTOPIC; LIST=NO, the default, must be taken.
 1172       The following functions may be requested by using the parameters indicated:
 1173
 1174       o  Access all messages for a range of topics (RANGE=YES; KEY1, KEY2
 1175       are meaningful).
 1176
 1177       o  Access first level message for a topic specified by keyword
 1178       (i.e., KEY1; SUBTOPIC is meaningful).
 1179
 1180       o  Access first level message for a subtopic specified by
 1181       keywords (i.e., KEY1 identifying the topic, KEY2 identifying
 1182       the subtopic; SUBTOPIC and SUBSTOPIC are meaningful).
 1183
 1184       o  For a previously requested topic or subtopic, access the
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          33   
 1185       next level message (MORE=YES; RESULTS area which must be unchanged
 1186       since previous call to M$HELP indicates how much information
 1187       has already been displayed).
 1188
 1189       o  For a previously requested topic or subtopic, access the
 1190       remainder of messages for that topic (ALL=YES; RESULTS area which must
 1191       be unchanged since previous call to M$HELP indicates how much
 1192       information has already been displayed).
 1193
 1194       The SUBTOPIC and SUBSTOPIC parameters permit the caller to
 1195       request use of a default or substitution message if the
 1196       requested message cannot be found.  If SUBTOPIC=YES and
 1197       M$HELP cannot find the requested keyword, M$HELP
 1198       supplies the default message (abstract).  If SUBSTOPIC=YES
 1199       and if KEY2 is specified but KEY2 cannot be found, M$HELP
 1200       re-accesses the HELP message file, disregarding KEY2, to obtain a
 1201       substitute message.  In these cases,  the RESULTS area indicates
 1202       that the original request was met with a default or substitute
 1203       message.
 1204
 1205       After the text is read into the buffer,
 1206       M$HELP performs output if the user supplied OUTDCB1 and OUTDCB2
 1207       parameters.  The discussion of the BUF parameter describes
 1208       how the output function is performed.  If no DCBs are
 1209       specified and the buffer is large enough to contain the text
 1210       requested, M$HELP returns so that the caller may perform the
 1211       output operation.
 1212
 1213       On return to the caller, the RESULTS area reflects the status
 1214       of the service call.  On a normal return, the RESULTS area contains
 1215       information to allow a subsequent call for M$HELP to respond to
 1216       the timesharing user's entry of ? (MORE=YES) or ?? (ALL=YES).
 1217
 1218       The alternate return is taken in the following situations:  if no
 1219       OUTDCBs are specified and the buffer is too small to
 1220       contain the text requested; if OUTDCB1 or OUTDCB2 is specified and
 1221       output cannot be completed through either DCB (M$HELP performs correspondence
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          34   
 1222       checking and also verifies that the OUTDCBs are actually DCBs) and the
 1223       buffer is too small to contain the requested test; if
 1224       there are database errors, or if bad parameters are passed.
 1225       Information in the RESULTS area and TCB indicate the reason
 1226       for the alternate return.
 1227
 1228       To list information about the available HELP messages, the caller of
 1229       M$HELP specifies a buffer and RESULTS area.  These
 1230       functions may be requested by using the additional
 1231       parameters indicated:
 1232
 1233       o  List processor names that provide HELP (LIST=YES, PROCNAME=
 1234       NIL; PROCACCT, KEY1, KEY2, and RANGE are meaningful).
 1235
 1236       o  List TOPICS (i.e., topic keywords) for a specific processor requested
 1237       by range or by (possibly) truncated keyword (LIST=YES;
 1238       PROCNAME, PROCACCT, RANGE, KEY1, KEY2 are meaningful).
 1239
 1240       This list of processor names or keywords is presented to the user
 1241       in the same way that the message text is presented.
 1242
 1243       The form of the call for this service is as follows:
 1244
 1245       CALL M$HELP (FPT_HELP) [ALTRET (label)];
 1246
 1247       The parameters for this service are as follows:
 1248       */
 1249       %MACRO FPT_HELP (FPTN = FPT_HELP,
 1250               BUF = NIL,
 1251
 1252                /*K* BUF = VARIABLE specifies the buffer used when reading the file
 1253                of help messages.  BUF must have a minimum size of 79 bytes, the
 1254                maximum size of any record in the file.  Because the text requested
 1255           may consist of multiple records in the file, a 79-byte buffer will not
 1256           always be large enough to hold the whole message.  The caller may
 1257           alleviate this condition by specifying a larger buffer.
 1258
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          35   
 1259           Records from the file are read into the buffer at 79-byte
 1260           offsets until the buffer is full or the message is complete.
 1261           Status is returned to the caller indicating how may records are
 1262           in the buffer, and whether or not the message is complete.  If
 1263           the buffer is not large enough to hold all of the records of
 1264           the message, then the contents of the buffer will vary depending
 1265           on whether the caller supplied OUTDCBs through which to output the
 1266           messages.  Given a buffer with enough space for n records, if no
 1267           OUTDCBs have been specified, the buffer will contain the first n
 1268           records of the message.  If OUTDCBs have been specified, then the
 1269           buffer will contain the first n-1 records in the first n-1 slots,
 1270           and the last record of the message in the nth slot.
 1271
 1272           EXAMPLE:
 1273
 1274           Suppose the user passes a 237-byte buffer and tries to read
 1275           varying size text.
 1276
 1277           1.  2-record error text.
 1278           }
 1279           }       1          Record 1           79
 1280           }     121          Record 2          158
 1281           }     159                            237
 1282           }
 1283           On a normal return, the RESULTS area indicates that the
 1284           buffer contains the complete message and it is two records.
 1285
 1286           2.  4-record text - no OUTDCBs specified.
 1287           }
 1288           }       1          Record 1           79
 1289           }      80          Record 2          158
 1290           }     159          Record 3          237
 1291           }
 1292           On an alternate return, the RESULTS area indicates that the
 1293           buffer holds three records but that the message is
 1294           incomplete.
 1295
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          36   
 1296           3.  4-record error message - OUTDCBs specified.
 1297           }
 1298           }       1          Record 1           79
 1299           }      80          Record 2          158
 1300           }     159          Record 4          237
 1301           }
 1302           On a normal return, the RESULTS area indicates that the buffer
 1303           contains three records but that the message is incomplete.
 1304           With OUTDCBs specified, a normal return from M$HELP occurs after
 1305           the complete 4-record message is written through the user DCBs.
 1306           */
 1307
 1308              PROCNAME = NIL,
 1309
 1310                     /*K* PROCNAME = VARIABLE locates a VLP_NAME area containing the
 1311                name of the processor for which HELP is requested.  The processor
 1312                name must not exceed 24 characters in length.
 1313                */
 1314
 1315              PROCACCT = NIL,
 1316
 1317                     /*K* PROCACCT = VARIABLE locates a VLP_ACCT area containing the
 1318                     account of the processor for which HELP is requested.
 1319                     */
 1320
 1321              PROCPSN = NIL,
 1322
 1323                /*K* PROCPSN = VARIABLE locates a six-character area containing the
 1324                packset of the processor for which HELP is requested.
 1325                */
 1326
 1327              PROCPASS = NIL,
 1328
 1329                     /*K* PROCPASS = VARIABLE locates a VLP_PASS area containing the
 1330                     password for the processor for which HELP is requested.
 1331                     */
 1332
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          37   
 1333               KEY1 = NIL,
 1334
 1335                     /*K* KEY1 = VARIABLE locates a TEXTC area containing the first
 1336                keyword.  When used in conjunction with RANGE, RANGE = YES indicates
 1337                the first in a range of requested HELP items.  When RANGE = YES and
 1338                KEY1 is blank or omitted, the first existing HELP item is obtained.
 1339                RANGE = NO indicates that KEY1 frames the main topic word that, with
 1340                any existing sub-topic word (KEY2), defines a single HELP item if
 1341           LIST = NO.  When LIST = YES, KEY1 frames the starting characters of a
 1342           wildcard.
 1343           */
 1344
 1345               ALL (YES='1'B,NO='0'B)= '0'B,
 1346
 1347                          /*K* ALL = {YES|NO} indicates, if YES, that all remaining
 1348                          HELP on the current topic is to be output.  This is valid
 1349                          only for HELP text (LIST = NO).  The default is NO.
 1350                          */
 1351
 1352               MORE (YES='1'B,NO='0'B)= '0'B,
 1353
 1354                /*K* MORE = {YES|NO} indicates, if YES, that the next message(s)
 1355                of HELP text for the current topic is to be output.  This is
 1356                valid only for HELP text.  The default is NO.
 1357                */
 1358
 1359               RANGE (YES='1'B,NO='0'B)= '0'B,
 1360
 1361                     /*K* RANGE = {YES|NO} is used in combination with KEY1 and KEY2
 1362                to set limits on the data output.  If RANGE is YES, KEY1 and KEY2
 1363                are to be used as inclusive limits on a range of items to display.
 1364                If RANGE = NO and LIST = YES, KEY1 may be provided as a wildcard;
 1365                in this case, any item in the display list that starts with the
 1366                keyword is printed.  If RANGE = NO and LIST = NO, the keywords
 1367                are used to select a single message by topic and subtopic.
 1368                The default is NO.
 1369                */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          38   
 1370
 1371               LIST (YES='1'B,NO='0'B)= '0'B,
 1372
 1373                     /*K* LIST = {YES|NO} indicates, if YES, that the user wishes
 1374                to see a list of the available topics for the HELPing processor.
 1375                If the PROCNAME is blank or omitted, M$HELP will list the processors
 1376           in the account indicated by PROCACCT, for which HELP exists.  If NO, the
 1377           user wishes to see the actual HELP text.  The default is NO.
 1378           */
 1379
 1380               KEY2 = NIL,
 1381
 1382                     /*K* KEY2 = VARIABLE locates a TEXTC area containing the second
 1383                keyword.  When used in conjunction with RANGE, RANGE = YES indicates
 1384                the last in a range of requested HELP items.  When RANGE = YES and
 1385                KEY2 is blank or omitted, the last existing HELP item is obtained.
 1386                RANGE = NO indicates the entry is the subtopic word that, with any
 1387                existing topic word (KEY1), defines a single HELP item.
 1388                */
 1389
 1390               XLATEKEY (YES='1'B,NO='0'B)= '1'B,
 1391
 1392                /*K* XLATEKEY = {YES|NO} indicates, if YES, that the user wishes
 1393                M$HELP to translate the passed KEYWORDs into upper case and try
 1394                again if a message isn't found the first time.  The default is YES.
 1395                */
 1396
 1397               SUBTOPIC (YES='1'B,NO='0'B)= '0'B,
 1398
 1399                          /*K* SUBTOPIC = {YES|NO} indicates whether or not to use
 1400                          the default message if the requested topic does not exist.
 1401                          The default is NO.
 1402                          */
 1403
 1404               SUBSTOPIC (YES='1'B,NO='0'B)= '1'B,
 1405
 1406                          /*K* SUBSTOPIC = {YES|NO} indicates whether or not to use
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          39   
 1407                     a substitute message (i.e., the one that would have resulted
 1408                     if KEY2 were not passed) if M$HELP is unable to find the
 1409                     specified one.  SUBSTOPIC = YES is valid only when LIST = NO
 1410                     and RANGE = NO.  The default is YES.
 1411                     */
 1412
 1413               LANG = ' ',
 1414
 1415                     /*K* LANG = VALUE-CHAR(1) specifies user native language byte
 1416                          from the JIT.  LANG is used to select a HELP file in the
 1417                          user's own language.  The default is blank, meaning no
 1418                          special language.                                       */
 1419
 1420               OUTDCB1 = NIL,
 1421
 1422                          /*K* OUTDCB1 = DCBNAME is the first DCB through which to
 1423                          output the HELP message.
 1424                          */
 1425
 1426               OUTDCB2 = NIL,
 1427
 1428                          /*K* OUTDCB2 = DCBNAME is the second DCB through which to
 1429                          output the HELP messages.
 1430                          */
 1431
 1432               RESULTS = NIL,
 1433
 1434                     /*K* RESULTS = VARIABLE locates a VLR_HELP area passed by the
 1435                     user where status information about the call to M$HELP is
 1436                     returned.   Because this also contains scratch area for M$HELP,
 1437                     it is required for callers who wish to use the MORE or ALL
 1438                     functions or do their own output.
 1439                     */
 1440
 1441               STCLASS = STATIC);
 1442
 1443       %LSET LISTDIR='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          40   
 1444       %LSET LISTEXP='1'B;
 1445       %LSET LISTCOM='0'B;
 1446       %LSET LISTSUB='1'B;
 1447       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1448       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1449       (SUBSTR(STR,0,8)='CONSTANT') OR
 1450       (SUBSTR(STR,0,3)='EXT');
 1451       %LSET INIT=CHARTEXT('INIT');
 1452       %ELSE;
 1453       %LSET INIT=CHARTEXT('/*');
 1454       %ENDIF;
 1455
 1456                                    /**/
 1457      DCL 1 FPTN STCLASS DALIGNED,
 1458            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1459            2 KEY1_ BIT(72) %INIT(VECTOR(KEY1))%CHARTEXT('/**/'),
 1460            2 KEY2_ BIT(72) %INIT(VECTOR(KEY2))%CHARTEXT('/**/'),
 1461            2 BUF_ BIT(72) %INIT(VECTOR(BUF))%CHARTEXT('/**/'),
 1462            2 PROCNAME_ BIT(72) %INIT(VECTOR(PROCNAME))%CHARTEXT('/**/'),
 1463            2 PROCACCT_ BIT(72) %INIT(VECTOR(PROCACCT))%CHARTEXT('/**/'),
 1464            2 PROCPASS_ BIT(72) %INIT(VECTOR(PROCPASS))%CHARTEXT('/**/'),
 1465            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
 1466            2 PROCPSN_ BIT(72) %INIT(VECTOR(PROCPSN))%CHARTEXT('/**/'),
 1467            2 V DALIGNED,
 1468              3 OUTDCB1# UBIN(18) UNAL %INIT(DCBNUM(OUTDCB1))%CHARTEXT('/**/'),
 1469              3 OUTDCB2# UBIN(18) UNAL %INIT(DCBNUM(OUTDCB2))%CHARTEXT('/**/'),
 1470              3 LANG# CHAR(1) %INIT(LANG)%CHARTEXT('/**/'),
 1471              3 * BIT(21) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1472              3 XLATEKEY# BIT(1) UNAL %INIT(XLATEKEY)%CHARTEXT('/**/'),
 1473              3 SUBTOPIC# BIT(1) UNAL %INIT(SUBTOPIC)%CHARTEXT('/**/'),
 1474              3 LIST# BIT(1) UNAL %INIT(LIST)%CHARTEXT('/**/'),
 1475              3 ALL# BIT(1) UNAL %INIT(ALL)%CHARTEXT('/**/'),
 1476              3 MORE# BIT(1) UNAL %INIT(MORE)%CHARTEXT('/**/'),
 1477              3 RANGE# BIT(1) UNAL %INIT(RANGE)%CHARTEXT('/**/'),
 1478              3 SUBSTOPIC# BIT(1) UNAL %INIT(SUBSTOPIC)%CHARTEXT('/**/'),
 1479              3 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1480              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          41   
 1481
 1482       %MEND;
 1483                                    /**/
 1484
 1485
 1486                          /*F* NAME:  VLR_HELP.
 1487
 1488                          The VLR_HELP macro generates an area which receives the
 1489                          results of the M$HELP.  The area contains these fields:
 1490                          */
 1491
 1492       %MACRO VLR_HELP (FPTN = VLR_HELP,
 1493                       LAST = ";",
 1494                       LVL = 1,
 1495                         STCLASS = STATIC);
 1496
 1497       %LSET LISTDIR='0'B;
 1498       %LSET LISTEXP='1'B;
 1499       %LSET LISTCOM='0'B;
 1500       %LSET LISTSUB='1'B;
 1501       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1502       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1503       (SUBSTR(STR,0,8)='CONSTANT') OR
 1504       (SUBSTR(STR,0,3)='EXT');
 1505       %LSET INIT=CHARTEXT('INIT');
 1506       %ELSE;
 1507       %LSET INIT=CHARTEXT('/*');
 1508       %ENDIF;
 1509
 1510      %IF LVL = 1;
 1511
 1512      DCL 1 FPTN STCLASS DALIGNED,
 1513
 1514      %ELSE;
 1515
 1516              %LVL FPTN ALIGNED,
 1517
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          42   
 1518      %ENDIF;
 1519
 1520                %(LVL+1) BADCALL BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ILLEGAL PARAMETERS */
 1521                          /*K* BADCALL = VALUE-BIT(1)   if set specifies that
 1522                          the call contained one or more illegal
 1523                          parameters.                                             */
 1524                %(LVL+1) NOFILE BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* UNABLE TO OPEN FILE */
 1525                          /*K* NOFILE = VALUE-BIT(1)   if set specifies that
 1526                          M$HELP was unable to open the message
 1527                          file.                                                   */
 1528                %(LVL+1) NOMSG BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* UNABLE TO FIND ANY MESSAGE */
 1529                          /*K* NOMSG = VALUE-BIT(1)   if set means that
 1530                          M$HELP was unable to find any message for the
 1531                          error code.                                             */
 1532                %(LVL+1) ALTMSG BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* SUBSTITUTE MESSAGE USED */
 1533                          /*K* ALTMSG = VALUE-BIT(1)   if set means that
 1534                          M$HELP stored a substitute message in the user
 1535                          buffer.                                                 */
 1536                %(LVL+1) MSGCOMP BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ENTIRE MESSAGE IS IN BUFFER */
 1537                          /*K* MSGCOMP = VALUE-BIT(1)   if set means that the
 1538                          entire message is stored in the user buffer.            */
 1539                %(LVL+1) OUTERR1 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON OUTDCB1 */
 1540                          /*K* OUTERR1 = VALUE-BIT(1)   if set specifies an
 1541                          error on OUTDCB1.                                       */
 1542                %(LVL+1) OUTERR2 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON OUTDCB2 */
 1543                          /*K* OUTERR2 = VALUE-BIT(1)   if set specifies
 1544                          error on OUTDCB2.                                       */
 1545                %(LVL+1) NNATIVE BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* MESSAGE PROVIDED IS NOT IN NATIVE LANGUAGE */
 1546                          /*K* NNATIVE = VALUE-BIT(1)   if set means that the
 1547                          returned message is not in the user's native language.  */
 1548                %(LVL+1) BUFERR BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* BUFFER PASSED IS MALFORMED */
 1549                          /*K* BUFERR = VALUE-BIT(1)   if set specifies that
 1550                          the buffer is not there or bad.                         */
 1551                %(LVL+1) INERR BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* ERROR ON INPUT */
 1552                          /*K* INERR = VALUE-BIT(1)   if set specifies
 1553                          error on reading the message.                           */
 1554                %(LVL+1) * BIT(17) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* SPARE BITS */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          43   
 1555                %(LVL+1) * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'), /* SPARE BITS */
 1556                %(LVL+1) RECCNT UBIN(18) UNAL %INIT(0)%CHARTEXT('/**/'), /* COUNT OF RECORDS READ */
 1557                          /*K* RECCNT = VALUE-DEC(0-n)   specifies a count of
 1558                          records read into the user buffer.                      */
 1559                %(LVL+1) ERRCODE1 UNAL, /* ERROR CODE FOR ERRORS ON OUTDCB1       */
 1560                          /*K* ERRCODE1   specifies the error code for OUTDCB1,
 1561                          in the normal format for monitor service errors.        */
 1562                %(LVL+2) FCG BIT(12) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1563                %(LVL+2) MID BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1564                %(LVL+2) MON BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1565                %(LVL+2) ERR# UBIN(14) UNAL %INIT(0)%CHARTEXT('/**/'),
 1566                %(LVL+2) SEV UBIN(3) UNAL %INIT(0)%CHARTEXT('/**/'),
 1567                %(LVL+1) ERRCODE2 UNAL, /* ERROR CODE FOR ERRORS ON OUTDCB2       */
 1568                          /*K* ERRCODE2   specifies the error code for OUTDCB2,
 1569                          in the normal format for monitor service errors.        */
 1570                %(LVL+2) FCG BIT(12) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1571                %(LVL+2) MID BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1572                %(LVL+2) MON BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1573                %(LVL+2) ERR# UBIN(14) UNAL %INIT(0)%CHARTEXT('/**/'),
 1574                %(LVL+2) SEV UBIN(3) UNAL %INIT(0)%CHARTEXT('/**/'),
 1575                %(LVL+1) CODEUSED UNAL, /* CODE FOR MESSAGE USED                  */
 1576                                    /* USED FOR 'ALL' & 'MORE'                    */
 1577                %(LVL+2) LEN UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'),
 1578                %(LVL+2) TEXT CHAR(34) UNAL %INIT(' ')%CHARTEXT('/**/'),
 1579                %(LVL+1) * UBIN(9) UNAL %INIT(0)%CHARTEXT('/**/'), /* SPARE BITS  */
 1580                %(LVL+1) * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/') LAST /* SPARE BITS */
 1581       %MEND;
 1582                                    /*********************************/
 1583                                    /*  Monitor M$FID service                     */
 1584                                    /*********************************/
 1585
 1586
 1587                          /*F* NAME: M$FID - Convert FID to DCB File ID.
 1588
 1589                          For all types of files and devices, the
 1590                          monitor provides services to convert the file
 1591                          identification (FID) from the format used with the
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          44   
 1592                          IBEX SET command to the format in which this
 1593                          information is stored in the DCB. The M$FID
 1594                          service performs this conversion; the M$UNFID
 1595                          service converts the information in DCB format to
 1596                          FID format.
 1597
 1598                          M$FID is used by processors to convert a FID
 1599                          into a format needed to initialize a DCB via the
 1600                          M$OPEN monitor service. The user supplies areas
 1601                          to receive the file name (NAME), account (ACCT),
 1602                          password (PASS), serial number list (SN), work
 1603                          station (WSN), assignment type (ASN), and resource
 1604                          type (RES). Modifications to these areas are
 1605                          reflected in a RESULTS area, also supplied by the
 1606                          user in the M$FID FPT.
 1607
 1608                          In addition, the M$FID service permits the
 1609                          user to request scrubbing of any portion of the
 1610                          file identification parameter area. Scrubbing
 1611                          sets the area to a value meaning that the
 1612                          parameter is not used and if it already exists in
 1613                          the DCB, it is to be removed. The scrub options
 1614                          are useful when a user wishes not to have to check
 1615                          the RESULTS area following the call to M$FID. The
 1616                          user instead calls M$FID, and barring an alternate
 1617                          return condition, calls M$OPEN with no intervening
 1618                          steps.
 1619
 1620                          The M$FID service performs no character set
 1621                          validation for any portion of the FID. The
 1622                          RESULTS returned by M$FID consists of seven bits
 1623                          corresponding to the seven parameters created from
 1624                          the FID. If a RESULTS bit is set, the parameter
 1625                          has been filled. If a RESULTS bit is reset, the
 1626                          parameter is unchanged if scrubbing was not
 1627                          requested; or the parameter contains a NIL value
 1628                          if scrubbing was requested. The RESULTS bit for
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          45   
 1629                          ASN is always set for a valid call to M$FID.
 1630
 1631                          The alternate return is taken if the TEXTFID
 1632                          parameter does not contain a valid FID, if TEXTFID
 1633                          is NIL, or if any area provided to receive the
 1634                          converted FID is too small to contain the
 1635                          pertinent information. An appropriate error code
 1636                          is returned in the ALTRET frame if an error occurs.
 1637
 1638                          The service call is of the form:
 1639
 1640                          CALL M$FID (FPT_FID) [ALTRET (label)];
 1641
 1642                          The parameters for this service area as follows:        */
 1643       %MACRO FPT_FID(
 1644               FPTN    = FPT_FID,
 1645               TEXTFID = NIL,
 1646               NAME    = NIL,
 1647               ACCT    = NIL,
 1648               PASS    = NIL,
 1649               SN      = NIL,
 1650               WSN     = NIL,
 1651               ASN     = NIL,
 1652               RES     = NIL,
 1653               RESULTS = NIL,
 1654               SNAME (YES='1'B,NO='0'B)= '1'B,
 1655               SACCT (YES='1'B,NO='0'B)= '1'B,
 1656               SPASS (YES='1'B,NO='0'B)= '1'B,
 1657               SSN   (YES='1'B,NO='0'B)= '1'B,
 1658               SWSN  (YES='1'B,NO='0'B)= '1'B,
 1659               SRES  (YES='1'B,NO='0'B)= '1'B,
 1660               CPARTS  (YES='1'B,NO='0'B)= '0'B,
 1661               PAOSF  (YES='1'B,NO='0'B)= '0'B,
 1662               PPOSF  (YES='1'B,NO='0'B)= '0'B,
 1663               AWODF  (YES='1'B,NO='0'B)= '0'B,
 1664               CCHARS  (YES='1'B,NO='0'B)= '0'B,
 1665               STCLASS = STATIC);
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          46   
 1666
 1667       %LSET LISTDIR='0'B;
 1668       %LSET LISTEXP='1'B;
 1669       %LSET LISTCOM='0'B;
 1670       %LSET LISTSUB='1'B;
 1671       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1672       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1673       (SUBSTR(STR,0,8)='CONSTANT') OR
 1674       (SUBSTR(STR,0,3)='EXT');
 1675       %LSET INIT=CHARTEXT('INIT');
 1676       %ELSE;
 1677       %LSET INIT=CHARTEXT('/*');
 1678       %ENDIF;
 1679
 1680      DCL 1 FPTN STCLASS DALIGNED,
 1681            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1682            2 TEXTFID_ BIT(72) %INIT(VECTOR(TEXTFID))%CHARTEXT('/**/'),
 1683                          /*K* TEXTFID = VARIABLE  Locates a string to parse as
 1684                          a fid.  It must not be null.  This is a TEXT string.
 1685                          Its length is indicated by the VECTOR that frames it.
 1686                          Any leading blanks are ignored.
 1687                          */
 1688            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 1689                          /*K* NAME = VARIABLE   locates a VLP_NAME area
 1690                          which may be referenced within an FPT for
 1691                          M$OPEN.                                                 */
 1692            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 1693                          /*K* ACCT = VARIABLE   locates a VLP_ACCT area
 1694                          which may be referenced within an FPT for
 1695                          M$OPEN.                                                 */
 1696            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
 1697                          /*K* PASS = VARIABLE   locates a VLP_PASS area
 1698                          which may be referenced within an FPT for
 1699                          M$OPEN.                                                 */
 1700            2 SN_ BIT(72) %INIT(VECTOR(SN))%CHARTEXT('/**/'),
 1701                          /*K* SN = VARIABLE locates a VLP_SN area which
 1702                          may be referenced within an FPT for M$OPEN.             */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          47   
 1703            2 WSN_ BIT(72) %INIT(VECTOR(WSN))%CHARTEXT('/**/'),
 1704                          /*K* WSN = VARIABLE Locates a VLP_WSN area. See
 1705                          M$DCB for definition of WSN.                            */
 1706            2 ASN_ BIT(72) %INIT(VECTOR(ASN))%CHARTEXT('/**/'),
 1707                          /*K* ASN = VARIABLE      locates an ASN area which
 1708                          may be within an FPT for M$OPEN.  This parameter
 1709                          is mandatory.                                           */
 1710            2 RES_ BIT(72) %INIT(VECTOR(RES))%CHARTEXT('/**/'),
 1711                          /*K* RES = VARIABLE   locates a RES area which may
 1712                          be within an FPT for M$OPEN.  See M$OPEN for more
 1713                          details.                                                */
 1714            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
 1715                          /*K* RESULTS = VARIABLE  locates an area which
 1716                          may be generated by the VLR_FID macro
 1717                          discussed next.  The RESULTS parameter is optional.
 1718                          */
 1719            2 V DALIGNED,
 1720              3 SCRUB,
 1721                          /*K* SCRUB. specifies a mask of bits that are
 1722                          used to select what parameters are to be scrubbed.
 1723                          The name SCRUB. is not used as a keyword but
 1724                          provides a superstructure for the series of mask
 1725                          bit fields in the M$FID FPT. The user sets mask
 1726                          bits via the keywords listed below. For example,
 1727                          SNAME=YES sets the SCRUB.SNAME field in the M$FID
 1728                          FPT. As a result M$FID sets the vector-located
 1729                          parameter NAME to a NIL value.                          */
 1730                4 SNAME# BIT(1) UNAL %INIT(SNAME)%CHARTEXT('/**/'),
 1731                          /*K* SCRUB.SNAME = {YES|NO} YES requests
 1732                          scrubbing of the NAME area.  The default is
 1733                          YES.                                                    */
 1734                4 SACCT# BIT(1) UNAL %INIT(SACCT)%CHARTEXT('/**/'),
 1735                          /*K* SCRUB.SACCT = {YES|NO} YES requests scrubbing
 1736                          of the ACCT area.  The default is YES.                  */
 1737                4 SPASS# BIT(1) UNAL %INIT(SPASS)%CHARTEXT('/**/'),
 1738                          /*K* SCRUB.SPASS = {YES|NO} YES requests
 1739                          scrubbing of the PASS area.  The default is
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          48   
 1740                          YES.                                                    */
 1741                4 SSN# BIT(1) UNAL %INIT(SSN)%CHARTEXT('/**/'),
 1742                          /*K* SCRUB.SSN = {YES|NO} YES requests scrubbing
 1743                          of the SN area.  The default is YES.                    */
 1744                4 SWSN# BIT(1) UNAL %INIT(SWSN)%CHARTEXT('/**/'),
 1745                          /*K* SCRUB.SWSN = {YES|NO} YES requests scrubbing
 1746                          of the WSN area.  The default is YES.                   */
 1747                4 SRES# BIT(1) UNAL %INIT(SRES)%CHARTEXT('/**/'),
 1748                          /*K* SCRUB.SRES = {YES|NO} YES requests scrubbing
 1749                          of the RES area.  The default is YES.                   */
 1750                4 SSPARE3# BIT(1) UNAL %INIT('1'B)%CHARTEXT('/**/'),
 1751                4 SSPARE2# BIT(1) UNAL %INIT('1'B)%CHARTEXT('/**/'),
 1752                4 SSPARE1# BIT(1) UNAL %INIT('1'B)%CHARTEXT('/**/'),
 1753              3 * BIT(9) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1754              3 CHECK,
 1755                          /*K* CHECK. specifies a mask of bits that are
 1756                          used to select what types of checking are to be
 1757                          performed to detect malformed FIDs.  The name CHECK
 1758                          provides a superstructure for the series of mask
 1759                          bit fields in the M$FID FPT. The user sets mask
 1760                          bits via the keywords listed below. For example,
 1761                          CCHARS=YES sets the CCHARS.SCRUB field in the M$FID
 1762                          FPT. As a result M$FID will check for certain
 1763                          illegal characters in the FID.                          */
 1764                4 CCHARS# BIT(1) UNAL %INIT(CCHARS)%CHARTEXT('/**/'),
 1765                          /*K* CHECK.CCHARS = {YES|NO} YES requests
 1766                          checking for certain characters illegal in a
 1767                          FID.  Currently, this only checks for '?' in a file
 1768                          name.  Enclosing a field (the NAME for example) in
 1769                          single quotes indicates that the field is to be
 1770                          taken literally.  In that case, the checking is
 1771                          skipped, regardless of the CCHARS option.  The
 1772                          default is NO.                                          */
 1773                4 CPARTS# BIT(1) UNAL %INIT(CPARTS)%CHARTEXT('/**/'),
 1774                                    /* CHECK.CPARTS is currently unused.          */
 1775                4 PAOSF# BIT(1) UNAL %INIT(PAOSF)%CHARTEXT('/**/'),
 1776                          /*K* CHECK.PAOSF = {YES|NO} YES prohibits
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          49   
 1777                          the use of an account with a star-file,
 1778                          an illegal combination.  The default is NO.             */
 1779                4 PPOSF# BIT(1) UNAL %INIT(PPOSF)%CHARTEXT('/**/'),
 1780                          /*K* CHECK.PPOSF = {YES|NO} YES prohibits
 1781                          the use of an packset with a star file,
 1782                          an illegal combination.  The default is NO.             */
 1783                4 AWODF# BIT(1) UNAL %INIT(AWODF)%CHARTEXT('/**/'),
 1784                          /*K* CHECK.AWODF = {YES|NO} YES allows a
 1785                          a workstation with a disk FID, an illegal
 1786                          combination.  The default is NO.                        */
 1787                4 * BIT(4) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1788              3 * BIT(9) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1789              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1790              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1791       %MEND;
 1792                          /*F* NAME: VLR_FID
 1793
 1794                          This macro generates a VLR area definition for the
 1795                          RESULTS parameter of M$FID service.
 1796                                                                             */
 1797       %MACRO VLR_FID(
 1798              FPTN = VLR_FID,
 1799              STCLASS = STATIC);
 1800
 1801       %LSET LISTDIR='0'B;
 1802       %LSET LISTEXP='1'B;
 1803       %LSET LISTCOM='0'B;
 1804       %LSET LISTSUB='1'B;
 1805       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1806       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1807       (SUBSTR(STR,0,8)='CONSTANT') OR
 1808       (SUBSTR(STR,0,3)='EXT');
 1809       %LSET INIT=CHARTEXT('INIT');
 1810       %ELSE;
 1811       %LSET INIT=CHARTEXT('/*');
 1812       %ENDIF;
 1813
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          50   
 1814      DCL 1 FPTN STCLASS DALIGNED,
 1815            2 NAME BIT(1),
 1816                     /*K* NAME = VALUE-BIT(1)  Set if NAME was found in TEXTFID.
 1817                     */
 1818            2 ACCT BIT(1),
 1819                     /*K* ACCT = VALUE-BIT(1)  Set if ACCT was found in TEXTFID.
 1820                     */
 1821            2 PASS BIT(1),
 1822                     /*K* PASS = VALUE-BIT(1)  Set if PASS was found in TEXTFID.
 1823                     */
 1824            2 SN BIT(1),
 1825                          /*K* SN = VALUE-BIT(1)  Set if SN was found in TEXTFID.
 1826                          */
 1827            2 WSN BIT(1),
 1828                          /*K* WSN = VALUE-BIT(1)  Set if WSN was found in TEXTFID.
 1829                          */
 1830            2 ASN BIT(1),
 1831                /*K* ASN = VALUE-BIT(1)  Set if ASN was found in TEXTFID.  Always
 1832                set on a successful return.                                       */
 1833            2 RES BIT(1),
 1834                          /*K* RES = VALUE-BIT(1)  Set if RES was found in TEXTFID.
 1835                          */
 1836            2 SPARE3 BIT(1) UNAL,
 1837            2 SPARE2 BIT(1) UNAL,
 1838            2 SPARE1 BIT(1) UNAL,
 1839            2 * BIT(8) UNAL,
 1840            2 TYPE UNAL,
 1841                          /*K* TYPE  Describes the input format of each
 1842                          portion of the FID.  UMF$SIMPLE_STRING# indicates a
 1843                          a simple string of characters.  UMF$QUOTED_STRING#
 1844                     indicates a quoted string.  UMF$OCTAL_STRING# indicates that
 1845                     the field was entered in OCTAL.
 1846                     TYPE contains the following fields:  TYPE.ACCT,
 1847                     TYPE.NAME, TYPE.PASS, TYPE.RES, TYPE.SN, and
 1848                     TYPE.WSN.
 1849                     */
 1850              3 NAME UBIN(9) CALIGNED,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          51   
 1851              3 ACCT UBIN(9) CALIGNED,
 1852              3 PASS UBIN(9) CALIGNED,
 1853              3 SN UBIN(9) CALIGNED,
 1854              3 WSN UBIN(9) CALIGNED,
 1855              3 RES UBIN(9) CALIGNED,
 1856              3 SPARE3 UBIN(9) CALIGNED,
 1857              3 SPARE2 UBIN(9) CALIGNED,
 1858              3 SPARE1 UBIN(9) CALIGNED,
 1859            2 SINDEX UNAL,
 1860                          /*K* SINDEX  Indicates the starting byte index,
 1861                          beginning at 0, in the TEXTFID string of each
 1862                          portion of the FID.  SINDEX contains the
 1863                          following fields:  SINDEX.ACCT, SINDEX.NAME,
 1864                          SINDEX.PASS, SINDEX.RES, SINDEX.SN, and
 1865                          SINDEX.WSN.  Each of these fields is a UBIN(9)
 1866                          value.
 1867                          */
 1868              3 NAME UBIN(9) CALIGNED,
 1869              3 ACCT UBIN(9) CALIGNED,
 1870              3 PASS UBIN(9) CALIGNED,
 1871              3 SN UBIN(9) CALIGNED,
 1872              3 WSN UBIN(9) CALIGNED,
 1873              3 RES UBIN(9) CALIGNED,
 1874              3 SPARE3 UBIN(9) CALIGNED,
 1875              3 SPARE2 UBIN(9) CALIGNED,
 1876              3 SPARE1 UBIN(9) CALIGNED,
 1877            2 CLENGTH UNAL,
 1878                          /*K* CLENGTH  Indicates the length in bytes of
 1879                          each portion of the FID.  CLENGTH contains the
 1880                          following fields:  CLENGTH.ACCT, CLENGTH.NAME,
 1881                          CLENGTH.PASS, CLENGTH.RES, CLENGTH.SN, and
 1882                          CLENGTH.WSN.  Each of these fields is a UBIN (9)
 1883                          value.
 1884                          */
 1885              3 NAME UBIN(9) CALIGNED,
 1886              3 ACCT UBIN(9) CALIGNED,
 1887              3 PASS UBIN(9) CALIGNED,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          52   
 1888              3 SN UBIN(9) CALIGNED,
 1889              3 WSN UBIN(9) CALIGNED,
 1890              3 RES UBIN(9) CALIGNED,
 1891              3 SPARE3 UBIN(9) CALIGNED,
 1892              3 SPARE2 UBIN(9) CALIGNED,
 1893              3 SPARE1 UBIN(9) CALIGNED,
 1894            2 * CHAR(2) CALIGNED,
 1895            2 * BIT(9) UNAL,
 1896            2 * BIT(36) UNAL;
 1897       %MEND;
 1898                                    /***************************************/
 1899                                    /*        M$UNFID - BUILD A FID               */
 1900                                    /***************************************/
 1901
 1902                          /*F* NAME: M$UNFID - Convert DCB File ID to FID.
 1903
 1904                          The M$UNFID service converts file identification in DCB
 1905                          format to a character string in FID format. The
 1906                          user supplies the file identification in one of
 1907                          two ways: by naming a DCB or by specifying
 1908                          parameters that correspond to the FPT for M$OPEN
 1909                          (that is, name, account, password, assignment,
 1910                          resource type, serial number list, and work
 1911                          station). If a DCB is specified, the M$UNFID
 1912                          service obtains FID information only from the DCB
 1913                          and ignores other parameters.
 1914
 1915                          M$UNFID requires a valid assignment type in
 1916                          the DCB or the ASN parameter. For other
 1917                          unspecified identification fields, the service
 1918                          supplies defaults. For resource type (RES), the
 1919                          following defaults are used: 'DP' if ASN=FILE,
 1920                          'LT' if ASN=TAPE, and 'CG' if ASN=COMGROUP. For
 1921                          account (ACCT), the default is taken from the file
 1922                          management account field in the JIT (JIT.FACCN)
 1923                          in the case of DCB UNFIDs or if FORCE is requested.
 1924
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          53   
 1925                          If the user supplies a DCB, two anomalies
 1926                          should be noted. The FID will not contain a
 1927                          password, because the password is irreversibly
 1928                          encrypted and does not appear in the DCB. For a
 1929                          closed tape DCB, only the last active serial
 1930                          number is reported.
 1931
 1932                          The alternate return is taken from the M$UNFID
 1933                          service if the assignment (ASN) is invalid or is
 1934                          not supplied in the DCB or the ASN parameter, if
 1935                          the TEXTFID area is too small to contain the FID
 1936                          generated or if the TEXTFID parameter is not
 1937                          supplied.
 1938
 1939                          The form of the call for this service is as follows:
 1940
 1941                          CALL M$UNFID (FPT_UNFID) [ALTRET (label)];
 1942
 1943                          The parameters for this service are as follows:         */
 1944       %MACRO FPT_UNFID(
 1945               FPTN    = FPT_UNFID,
 1946               TEXTFID = NIL,
 1947               NAME    = NIL,
 1948               ACCT    = NIL,
 1949               PASS    = NIL,
 1950               SN      = NIL,
 1951               WSN     = NIL,
 1952               ASN     = NIL,
 1953               RES     = NIL,
 1954               LEN     = NIL,
 1955               DCB     = NIL,
 1956               FORCE (YES='1'B,NO='0'B)= '0'B,
 1957               STCLASS = STATIC);
 1958
 1959       %LSET LISTDIR='0'B;
 1960       %LSET LISTEXP='1'B;
 1961       %LSET LISTCOM='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          54   
 1962       %LSET LISTSUB='1'B;
 1963       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1964       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1965       (SUBSTR(STR,0,8)='CONSTANT') OR
 1966       (SUBSTR(STR,0,3)='EXT');
 1967       %LSET INIT=CHARTEXT('INIT');
 1968       %ELSE;
 1969       %LSET INIT=CHARTEXT('/*');
 1970       %ENDIF;
 1971
 1972      DCL 1 FPTN STCLASS DALIGNED,
 1973            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1974            2 TEXTFID_ BIT(72) %INIT(VECTOR(TEXTFID))%CHARTEXT('/**/'),
 1975                          /*K* TEXTFID = VARIABLE locates an area in which
 1976                          the textual representation of the FID is to
 1977                          be returned.  This is a TEXT string.  Its size
 1978                          is indicated by the VECTOR framing it.  After
 1979                          return, the number of characters actually used
 1980                          in this buffer is returned in LEN.
 1981                                                                                  */
 1982            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 1983                          /*K* NAME = VARIABLE locates a VLP_NAME area
 1984                          which may be referenced within an FPT for
 1985                          the M$OPEN service.                                     */
 1986            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 1987                          /*K* ACCT = VARIABLE locates a VLP_ACCT area
 1988                          which may be referenced within an FPT for
 1989                          the M$OPEN service.                                     */
 1990            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
 1991                          /*K* PASS = VARIABLE locates a VLP_PASS area
 1992                          which may be referenced within an FPT for
 1993                          the M$OPEN service.                                     */
 1994            2 SN_ BIT(72) %INIT(VECTOR(SN))%CHARTEXT('/**/'),
 1995                          /*K* SN = VARIABLE Locates a VLP_SN area which may
 1996                          be referenced within an FPT for the
 1997                          M$OPEN service.                                         */
 1998            2 WSN_ BIT(72) %INIT(VECTOR(WSN))%CHARTEXT('/**/'),
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          55   
 1999                          /*K* WSN = VARIABLE locates a VLP_WSN area which
 2000                          may be referenced within an FPT for the
 2001                          M$OPEN service.  ('@' is not valid as a WSN
 2002                          parameter.)                                             */
 2003            2 ASN_ BIT(72) %INIT(VECTOR(ASN))%CHARTEXT('/**/'),
 2004                          /*K* ASN = VARIABLE locates an ASN area which
 2005                          may be a field within an FPT for the M$OPEN
 2006                          service.                                                */
 2007            2 RES_ BIT(72) %INIT(VECTOR(RES))%CHARTEXT('/**/'),
 2008                          /*K* RES = VARIABLE locates a RES area which may
 2009                          be a field within an FPT for the M$OPEN
 2010                          service.                                                */
 2011            2 LEN_ BIT(72) %INIT(VECTOR(LEN))%CHARTEXT('/**/'),
 2012                          /*K* LEN = VARIABLE locates an optional UBIN WORD
 2013                          area in which to store the returned fids length.        */
 2014            2 V DALIGNED,
 2015              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 2016                          /*K* DCB = DCBNAME specifies that the FID is to
 2017                          be built from information in the DCB.  If
 2018                          no DCB is specified, the FID is built from
 2019                          other parameters supplied in the FPT.                   */
 2020              3 FORCE# BIT(1) UNAL %INIT(FORCE)%CHARTEXT('/**/'),
 2021                          /*K* FORCE = {YES|NO} YES requests that default
 2022                          values for PSN and ACCT should be used if no values
 2023                          are passed or found in the DCB.  The default is NO.     */
 2024              3 * BIT(17) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2025       %MEND;
 2026
 2027
 2028                                    /*******************************************/
 2029                                    /*  M$OCMSG - WRITE SPECIAL MESSAGE ON OC     */
 2030                                    /*******************************************/
 2031
 2032
 2033                          /*F* NAME: M$OCMSG - Special Write to Console.
 2034
 2035                          The M$OCMSG service is used by special processors
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          56   
 2036                          (command processors, debuggers, and ASLs) to write
 2037                          messages on consoles without getting the standard
 2038                          M$KEYIN (user) template.  User-domain programs can
 2039                          use M$OCMSG if the user has the MSYS privilege active
 2040                          when calling M$OCMSG.
 2041                          The procedure call is of the form:
 2042
 2043                          CALL M$OCMSG (FPT_OCMSG) [ALTRET (label)];
 2044
 2045                          For use in KEYIN templates the parameters passed
 2046                          to KEYIN are:
 2047
 2048                          .FIF
 2049                          1,T       Account from JIT
 2050                          2,T       User name from JIT
 2051                          3,D       Mode from JIT (Console ghost = 5)
 2052                          4,D       User number
 2053                          5,D       SUBC from M$OCMSG
 2054                          6,D       FEP number from JIT (if mode is T.S.)
 2055                          7,4H      Port number from JIT (if mode is T.S.)
 2056                          8,T       Node name for FEP (if mode is T.S.)
 2057                          9,D       Level of port information (if mode is T.S.)
 2058                          10,D      Terminal type (if mode is T.S.)
 2059                          11,D      Sub-device (if mode is T.S.)
 2060                          12,D      Sub-sub-device (if mode is T.S.)
 2061                          13,T      User-specified text #1
 2062                          14,T      User-specified text #2
 2063                          S,D       Sysid from JIT
 2064                          .FIN
 2065
 2066                          The parameters for this service are as follows:
 2067                          */
 2068
 2069
 2070       %MACRO FPT_OCMSG (FPTN=FPT_OCMSG,
 2071              MSG=9999,
 2072                USERTEXT1  = NIL,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          57   
 2073                USERTEXT2  = NIL,
 2074           OCTYPE(ADMIN=0,SYSTEM=1,DEVICE=2,LIBRN=3,COMM=4,TAPE=5,DISK=6,UNITREC=7,ADCOM=8,TP=9)=0,
 2075              SUBC=0,
 2076              STCLASS=STATIC);
 2077
 2078       %LSET LISTDIR='0'B;
 2079       %LSET LISTEXP='1'B;
 2080       %LSET LISTCOM='0'B;
 2081       %LSET LISTSUB='1'B;
 2082       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2083       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2084       (SUBSTR(STR,0,8)='CONSTANT') OR
 2085       (SUBSTR(STR,0,3)='EXT');
 2086       %LSET INIT=CHARTEXT('INIT');
 2087       %ELSE;
 2088       %LSET INIT=CHARTEXT('/*');
 2089       %ENDIF;
 2090
 2091
 2092      DCL 1 FPTN STCLASS DALIGNED,
 2093            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2094            2 USERTEXT1_ BIT(72) %INIT(VECTOR(USERTEXT1))%CHARTEXT('/**/'),
 2095            2 USERTEXT2_ BIT(72) %INIT(VECTOR(USERTEXT2))%CHARTEXT('/**/'),
 2096                          /*K* USERTEXT1 = VARIABLE Locates a text area which
 2097                          contains the 1-31 characters used to fill in the 13th
 2098                          parameter in the output message block.                  */
 2099                          /*K* USERTEXT2 = VARIABLE Locates a text area which
 2100                          contains the 1-31 characters used to fill in the 14th
 2101                          parameter in the output message block.                  */
 2102            2 V,
 2103              3 MSG# UBIN WORD %INIT(MSG)%CHARTEXT('/**/'),
 2104                          /*K* MSG = VALUE-DEC(0-?) Specifies the output template
 2105                          message number of the message to be printed.            */
 2106              3 * UBIN(5) UNAL %INIT(0)%CHARTEXT('/**/'),
 2107              3 OCTYPE# UBIN(4) UNAL %INIT(OCTYPE)%CHARTEXT('/**/'),
 2108                          /*K* OCTYPE = OPTION  Specifies the type of
 2109                          console at which the message is to be printed.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          58   
 2110                          The options are as follows:
 2111
 2112
 2113                          DEVICE     specifies a console which receives
 2114                          messages about devices (e.g., ERROR, MOUNTs)
 2115                          and is allowed to perform device keyins (e.g.,
 2116                          RETRY, MOUNT).
 2117
 2118                          SYSTEM     specifies a console which receives
 2119                          messages about central site operations
 2120                          (e.g., :SYS,LJS LOGGED ON), and is allowed
 2121                          to perform keyins pertaining to central site
 2122                          operations (e.g., ZAP, START CPU 1).
 2123
 2124                          ADMIN      specifies a console that controls a
 2125                          workstation.  ADMIN consoles can display and
 2126                          alter (e.g., PRIO, DELETE) only their own
 2127                          workstation's jobs and can control users
 2128                          whose workstation of origin matches this
 2129                          console's WSN.
 2130
 2131                          TAPE    specifies console attributes which
 2132                          presently have the same meaning as DEVICE.
 2133
 2134                          DISK    specifies console attributes which
 2135                          presently have the same meaning as DEVICE.
 2136
 2137                          UNITREC    specifies console attributes which
 2138                          presently have the same meaning as DEVICE.
 2139
 2140                          COMM    specifies a console which is able to
 2141                          control and display the status of communications
 2142                          equipment connected to the CP-6 system, in
 2143                          particular the Front-End Processor(s).
 2144
 2145                          ADCOM    specifies a console that performs ADMIN
 2146                          and COMM functions.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          59   
 2147
 2148                          TP       specifies a console that deals with
 2149                          transaction processing related functions.
 2150                          For example, sending messages to TPAs,
 2151                          and receiving messages about TP stations.
 2152
 2153                          The default is ADMIN.                                   */
 2154              3 SUBC# UBIN(9) UNAL %INIT(SUBC)%CHARTEXT('/**/'),
 2155                          /*K* SUBC = VALUE-DEC (0-511)  Used to select message
 2156                          modifications of the MSG template.                      */
 2157              3 * UBIN(18) UNAL %INIT(0)%CHARTEXT('/**/'),
 2158              3 * BIT(72) %INIT('0'B)%CHARTEXT('/**/');
 2159       %MEND;
 2160
 2161
 2162
 2163
 2164
 2165
 2166                                    /****************************************
 2167                                     ***                                  ***
 2168                                     ***           M$PATHCON              ***
 2169                                     ***                                  ***
 2170                                     ****************************************/
 2171
 2172
 2173                          /*F*  NAME:  M$PATHCON - Special Service used by SLUG.
 2174
 2175                          The M$PATHCON service is used by the system ghost
 2176                          SLUG to attach a communications path to its
 2177                          appropriate process in the host, as the final
 2178                          part of host logon.  SLUG is the only user
 2179                          authorized to use this service.
 2180
 2181                          The form of the call for this service is:
 2182
 2183                          CALL M$PATHCON (FPT_PATHCON) [ALTRET (label)];
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          60   
 2184
 2185                          The parameters are as follows:                          */
 2186
 2187      %MACRO FPT_PATHCON (FPTN=FPT_PATHCON,
 2188               RESULTS   = NIL,
 2189               PCD       = NIL,
 2190               STCLASS   = STATIC);
 2191
 2192       %LSET LISTDIR='0'B;
 2193       %LSET LISTEXP='1'B;
 2194       %LSET LISTCOM='0'B;
 2195       %LSET LISTSUB='1'B;
 2196       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2197       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2198       (SUBSTR(STR,0,8)='CONSTANT') OR
 2199       (SUBSTR(STR,0,3)='EXT');
 2200       %LSET INIT=CHARTEXT('INIT');
 2201       %ELSE;
 2202       %LSET INIT=CHARTEXT('/*');
 2203       %ENDIF;
 2204
 2205      DCL 1 FPTN STCLASS DALIGNED,
 2206            2 V_ BIT(72) UNAL %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2207
 2208            2 RESULTS_ BIT(72) UNAL %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
 2209                          /*K* RESULTS = VARIABLE locates a VLR_PATHCON
 2210                          area which will receive certain results information.
 2211                          The default is NIL.                                     */
 2212
 2213            2 PCD_,
 2214              3 BOUND UBIN(20) UNAL %INIT(SIZEV(PCD))%CHARTEXT('/**/'),
 2215              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 2216              3 PCD$ PTR %INIT(ADDR(PCD))%CHARTEXT('/**/'),
 2217                          /*K* PCD = VARIABLE locates a KL_PCD area
 2218                          which contains the information identifying the
 2219                          entity which is logging on.  The default is NIL.        */
 2220
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          61   
 2221            2 V DALIGNED,
 2222
 2223              3 * (0:1) UBIN %INIT(0*0)%CHARTEXT('/**/');
 2224
 2225      %MEND;
 2226
 2227                          /*F* NAME: VLR_PATHCON
 2228
 2229                          This macro generates an area which receives the
 2230                          results of the M$PATHCON service.
 2231                          */
 2232
 2233      %MACRO VLR_PATHCON (FPTN=VLR_PATHCON,
 2234               STCLASS   = STATIC);
 2235
 2236       %LSET LISTDIR='0'B;
 2237       %LSET LISTEXP='1'B;
 2238       %LSET LISTCOM='0'B;
 2239       %LSET LISTSUB='1'B;
 2240       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2241       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2242       (SUBSTR(STR,0,8)='CONSTANT') OR
 2243       (SUBSTR(STR,0,3)='EXT');
 2244       %LSET INIT=CHARTEXT('INIT');
 2245       %ELSE;
 2246       %LSET INIT=CHARTEXT('/*');
 2247       %ENDIF;
 2248
 2249      DCL 1 FPTN STCLASS DALIGNED,
 2250
 2251            2 RLCID,
 2252              3 NODE UBIN BYTE UNAL %INIT(0) %CHARTEXT('/**/'),
 2253              3 GENERATION UBIN BYTE UNAL %INIT(0) %CHARTEXT('/**/'),
 2254              3 LDCTX UBIN HALF UNAL %INIT(0) %CHARTEXT('/**/');
 2255      %MEND;
 2256
 2257
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          62   
 2258                                    /****************************************
 2259                                     ***                                  ***
 2260                                     ***           M$EXHUME               ***
 2261                                     ***                                  ***
 2262                                     ****************************************/
 2263
 2264
 2265                          /*F* NAME: M$EXHUME - Special Service used by ELF.
 2266
 2267                          The M$EXHUME service is used by the system ghost
 2268                          ELF to attach a device to its desired comgroup
 2269                          now that the comgroup has become available.  ELF
 2270                          is the only user authorized to use this service.
 2271
 2272                          The form of the call for this service is:
 2273
 2274                          CALL M$EXHUME (FPT_EXHUME) [ALTRET (label)];
 2275
 2276                          The parameters are as follows:                          */
 2277
 2278      %MACRO FPT_EXHUME (FPTN=FPT_EXHUME,
 2279               RENT      = NIL,
 2280               CGID      = NIL,
 2281               STCLASS   = STATIC);
 2282
 2283       %LSET LISTDIR='0'B;
 2284       %LSET LISTEXP='1'B;
 2285       %LSET LISTCOM='0'B;
 2286       %LSET LISTSUB='1'B;
 2287       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2288       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2289       (SUBSTR(STR,0,8)='CONSTANT') OR
 2290       (SUBSTR(STR,0,3)='EXT');
 2291       %LSET INIT=CHARTEXT('INIT');
 2292       %ELSE;
 2293       %LSET INIT=CHARTEXT('/*');
 2294       %ENDIF;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          63   
 2295
 2296      DCL 1 FPTN STCLASS DALIGNED,
 2297            2 V_ BIT(72) UNAL %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2298
 2299            2 RENT_ BIT(72) UNAL %INIT(VECTOR(RENT))%CHARTEXT('/**/'),
 2300                          /*K* RENT = VARIABLE locates an EL$RENT area
 2301                          in which the following information must be
 2302                          provided:
 2303                          .FIF
 2304
 2305                          o DKEY.LDX     is the device LDCT index
 2306                          o DKEY.DEVNM   is the device name.
 2307                          o CGINF        is the connect info for the
 2308                                         comgroup AU (framed by B$CGAUCI).
 2309
 2310                          .FIN
 2311                          The default is NIL.                                     */
 2312
 2313            2 CGID_ BIT(72) UNAL %INIT(VECTOR(CGID))%CHARTEXT('/**/'),
 2314                          /*K* CGID = VARIABLE locates a KC$CGID area
 2315                          which identifies the target comgroup.
 2316                          The default is NIL.                                     */
 2317
 2318            2 V DALIGNED,
 2319
 2320              3 * (0:1) UBIN WORD %INIT(0*0)%CHARTEXT('/**/');
 2321
 2322      %MEND;
 2323
 2324
 2325                                    /*****************************************/
 2326                                    /* M$JOBSTATS - JOB STATUS PMME'S             */
 2327                                    /*****************************************/
 2328
 2329
 2330
 2331
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          64   
 2332                          /*F* NAME: M$JOBSTATS - Job Status.
 2333
 2334                          The M$JOBSTATS service has several functions, all
 2335                          involved with job
 2336                          status operations.  The function to be performed
 2337                          is selected by ORDER in the FPT.
 2338
 2339                          Some initial concepts are required in order to
 2340                          use this service properly.  For the purposes of
 2341                          this service, the term 'job' is defined as
 2342                          follows:  a 'job' is either a batch job (together
 2343                          with its input symbiont file, and output symbiont
 2344                          files if any) or the symbiont output produced by
 2345                          a non-batch user.  In other words, if a non-batch
 2346                          user with sysid X produces symbiont output, then
 2347                          this service considers the 'job' of sysid X to be
 2348                          those output symbiont files, and they are precisely
 2349                          what can be manipulated and/or checked by the use
 2350                          of this service.  On the other hand, a batch 'job'
 2351                          is considered by this service to be not only the
 2352                          symbiont output produced by the batch user, but
 2353                          also the user himself and his input control command
 2354                          (symbiont) file.  Thus, this service can manipulate
 2355                          and/or check the status of the batch user,
 2356                          as well as his symbiont output; for example the
 2357                          CANCEL function of M$JOBSTATS, if directed at a batch
 2358                          'job' can abort the batch user, or delete his symbiont
 2359                          output, or both.
 2360
 2361                          A batch 'job' is defined for the purposes of this
 2362                          service to be either 'current' or 'obsolete'.  A batch
 2363                          'job' becomes current upon receipt by PRESCAN.
 2364                          If it fails PRESCAN, it becomes obsolete immediately.
 2365                          After passing PRESCAN the job enters the waiting-to-run
 2366                          state and remains current thereafter until:
 2367
 2368                          1- It is cancelled before being run.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          65   
 2369
 2370                          or
 2371
 2372                          .inl 3
 2373                          .unl 3
 2374                          2- It is run to completion (note that 'completion'
 2375                             can include being aborted or Xed) and all of its
 2376                             symbiont output (if any) has been disposed of,
 2377                             either through being printed, or through being
 2378                             deleted (via CANCEL).
 2379                          .inl 0
 2380
 2381                          The only access to the status of 'current' jobs is
 2382                          through this service.  Once a job becomes 'obsolete',
 2383                          its final status is written into the :JOBSTATS file
 2384                          in :SYS, and its status is no longer available through
 2385                          this service.  Note that if a batch job fails PRESCAN,
 2386                          it becomes immediately obsolete and its record is written
 2387                     into the job statistics file, :JOBSTATS, with an indication of
 2388                     exactly why it failed PRESCAN.  The structure of the
 2389                     obsolete file is defined elsewhere.  Note also that
 2390                     when a batch job terminates its run and has created
 2391                     symbiont output, information pertinent to the run is
 2392                     available in the obsolete file even though the status
 2393                     of its still-current symbiont output is accessible via
 2394                     this service.
 2395
 2396                     Jobs can be accessed (both through this service
 2397                     and within the obsolete file) either by SYSID
 2398                     or by JOBNAME and ACCOUNT.  A jobname is only
 2399                     unique within a specific account.  However, in
 2400                     the obsolete file within a given account, only
 2401                     one record of a given jobname is kept (that of
 2402                     the most recently submitted job with that name);
 2403                     on the other hand, the job queues can clearly
 2404                     contain more than one job of a given jobname
 2405                     and account at a specific time.  It is important
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          66   
 2406                     to note that when a job is accessed by jobname,
 2407                     only one job of that name is affected, namely
 2408                     the job which is highest in the queues; in other
 2409                     words, for those M$JOBSTATS functions which
 2410                     access a single job by name, only the first
 2411                     job of the given name and account which is found,
 2412                     is affected.  Since the order of submittal of two
 2413                     such jobs is not necessarily the order in which
 2414                     they will appear in the queues, it is important
 2415                     to be aware of this detail.
 2416
 2417                     The form of the call for this service is:
 2418
 2419                     CALL M$JOBSTATS (FPT_JOBSTATS) [ALTRET (label)];
 2420
 2421                     The parameters for this service are as follows:              */
 2422
 2423       %MACRO FPT_JOBSTATS (FPTN = FPT_JOBSTATS,
 2424               STCLASS   = STATIC,
 2425               ORDER     (REMAP=0,CHECK=1,SRCH=2,CANCEL=3,UNHOLD=4,SPILL=5,
 2426                          SPILLED=6,CHECKF=7,CANCELF=8,UNHOLDF=9,FILL=10,ANY)=0,
 2427               DISP      (REQUEUE=0,SPILLED=1,REMOVE=2,ANY)=0,
 2428               NUM       = 0,
 2429               SYSID     = 0,
 2430               STATSEG   = 0,
 2431               OUTPUT    (YES='1'B,NO='0'B)= '0'B,
 2432               BUF       = NIL,
 2433               RESULTS   = NIL,
 2434               CRITERIA  = NIL,
 2435               JOBNAME   = NIL,
 2436               ACCT      = NIL,
 2437               SNLIST    = NIL,
 2438               RESLIST   = NIL);
 2439
 2440       %LSET LISTDIR='0'B;
 2441       %LSET LISTEXP='1'B;
 2442       %LSET LISTCOM='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          67   
 2443       %LSET LISTSUB='1'B;
 2444       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2445       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2446       (SUBSTR(STR,0,8)='CONSTANT') OR
 2447       (SUBSTR(STR,0,3)='EXT');
 2448       %LSET INIT=CHARTEXT('INIT');
 2449       %ELSE;
 2450       %LSET INIT=CHARTEXT('/*');
 2451       %ENDIF;
 2452
 2453      DCL 1 FPTN STCLASS DALIGNED,
 2454            2 V_ BIT(72) UNAL %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2455            2 BUF_ BIT(72) UNAL %INIT(VECTOR(BUF))%CHARTEXT('/**/'),
 2456                          /*K* BUF = VARIABLE  Locates the buffer to be mapped
 2457                          when a REMAP function is executed.                      */
 2458            2 RESULTS_ BIT(72) UNAL %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
 2459                          /*K* RESULTS = VARIABLE  Locates a VLR_JOBSTATS_OSRCH
 2460                          or VLR_JOBSTATS_ISRCH area when a SRCH function is
 2461                          being executed.  This area receives the
 2462                          results of the search.  RESULTS locates a
 2463                          VLR_JOBSTATS_CHECK area when a CHECK/CHECKF function is
 2464                          being performed; this area receives the result of
 2465                          the CHECK.  RESULTS locates a VLR_JOBSTATS_OSRCH
 2466                          area when a SPILL function is being performed;
 2467                          this area receives the results of the SPILL.            */
 2468            2 CRITERIA_ BIT(72) UNAL %INIT(VECTOR(CRITERIA))%CHARTEXT('/**/'),
 2469                          /*K* CRITERIA = VARIABLE  Locates a VLP_CRITERIA area
 2470                     when a SRCH or SPILL function is being executed.  This area
 2471                     defines the criteria which control exactly which
 2472                     jobs are returned by the search.                             */
 2473            2 JOBNAME_ BIT(72) UNAL %INIT(VECTOR(JOBNAME))%CHARTEXT('/**/'),
 2474                          /*K* JOBNAME = VARIABLE  Locates a VLP_JOBNAME area.
 2475                          If JOBNAME is specified on a CANCEL or CHECK function,
 2476                          then the job is being identified by jobname, not by
 2477                          SYSID.                                                  */
 2478            2 ACCT_ BIT(72) UNAL %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 2479                          /*K* ACCT = VARIABLE  Locates a VLP_ACCT area.  If
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          68   
 2480                          a job is being CHECKed or CANCELled by jobname,
 2481                          then ACCT specifies the account in which the named
 2482                          job is to be found.  The default, if not specified,
 2483                          is the account of the service call issuer.              */
 2484            2 SNLIST_ BIT(72) UNAL %INIT(VECTOR(SNLIST))%CHARTEXT('/**/'),
 2485                          /*K* SNLIST = VARIABLE  Locates a VLR_JOBSTATS_ISRCH_SN
 2486                          area.  If SNLIST is specified on a batch queue (OUTPUT=NO)
 2487                          SRCH function, then the packset lists for
 2488                          the returned jobs are deposited in this area.           */
 2489            2 RESLIST_ BIT(72) UNAL %INIT(VECTOR(RESLIST))%CHARTEXT('/**/'),
 2490                          /*K* RESLIST = VARIABLE  Locates a VLR_JOBSTATS_ISRCH_RES
 2491                     area.  If RESLIST is specified on a batch queue (OUTPUT=NO)
 2492                     SRCH function, then the virtual resource requirement
 2493                     lists for the returned jobs are deposited in this area.      */
 2494            2 * (0:3) BIT(72) UNAL %INIT(VECTOR(NIL)*0)%CHARTEXT('/**/'),
 2495            2 V DALIGNED,
 2496              3 ORDER# UBIN WORD UNAL %INIT(ORDER)%CHARTEXT('/**/'),
 2497                          /*K* ORDER = OPTION  Specifies which of the various
 2498                          M$JOBSTATS functions is to be performed.
 2499                          The available options are:
 2500
 2501                          CHECK - This function checks the status of a job.
 2502                          The job is identified by jobname if JOBNAME is specified,
 2503                          and otherwise by sysid, via the SYSID parameter.
 2504                          If the job is not current, this is not considered
 2505                          an error.  The RESULTS area receives the current
 2506                          status of the job (see VLR_JOBSTATS_CHECK for the
 2507                          definition of the returned status).
 2508                          Note that if the checked job is not from the
 2509                          service call issuer's account, then if the
 2510                          issuer does not have the PR_DISPJOB privilege,
 2511                          a 'not found' status is returned.
 2512
 2513                          CHECKF - This function checks the status of a particular
 2514                          output symbiont file.  The job which produced the file
 2515                          is identified as for CHECK, and the particular file
 2516                          is specified by the NUM parameter (the files produced
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          69   
 2517                          by a job have NUMs of 1,2, etc.).  The RESULTS area
 2518                          receives the current status of the job, just as for
 2519                          CHECK, but also receives the status of the specified
 2520                          file.  If the specified job is not found, the RESULTS
 2521                          area receives a status of 'not found' for both job
 2522                          and file.  If the specified job does exist but the
 2523                          specified file was not found, then the RESULTS area
 2524                          receives the status of the job, and a 'not found'
 2525                          status for the file.
 2526
 2527                          CANCEL - This function cancels a job, the job being
 2528                          identified as for CHECK.  The OUTPUT parameter specifies
 2529                          whether or not the job's output is to be cancelled. Note
 2530                          that in the case of a non-batch 'job', this function with
 2531                          OUTPUT=NO  causes no action since the 'job' consists
 2532                          only of output.  For a batch job, the job is deleted if
 2533                     it is waiting to run, and aborted if it is running.  If the job
 2534                     has already run and OUTPUT is not selected, an error is
 2535                     returned indicating that no action has been taken.  Note
 2536                     that if OUTPUT is selected and the batch job is running but
 2537                     has yet to produce any output, then the job is aborted
 2538                     and its output discarded.  Finally, note that the account
 2539                     of the job must match the account of the issuer of the
 2540                     service call or MSYS privilege must be active;
 2541                     otherwise, an error is returned and no action is taken.
 2542
 2543                     CANCELF - This function cancels (deletes) a particular
 2544                     output symbiont file, identified as for CHECKF.
 2545                     If the specified
 2546                     file is not found, a 'not found' error is returned.
 2547                     The account of the job that created the file must match
 2548                     the account of the issuer of the service call or MSYS
 2549                     privilege must be active; otherwise, an error is
 2550                     returned and no action is taken.
 2551
 2552                     UNHOLD - This function removes a job's symbiont output
 2553                     from HOLD status (via LDEV, a user can specify that a
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          70   
 2554                     certain number of copies of an output symbiont file are
 2555                     to be printed, after which the file is put in HOLD state,
 2556                     to be printed only via operator intervention, or by use
 2557                     of this service).  The job is identified as for CHECK.
 2558                     The job's output is removed from HOLD and becomes a
 2559                     candidate for printing.  If the job has no current
 2560                     current output, an error is returned.  The job's
 2561                     account must match that of the service call issuer
 2562                     or MSYS privilege must be active; otherwise, an error
 2563                     is returned and no action is taken.
 2564
 2565                     UNHOLDF - This function removes from hold a particular
 2566                     output symbiont file, identified as for CHECKF.
 2567                     If the specified
 2568                     file is not found, a 'not found' error is returned.
 2569                     The account of the job that created the file must
 2570                     match the account of the issuer of the service call or
 2571                     MSYS privilege must be active; otherwise, an error is
 2572                     returned and no action is taken.
 2573
 2574                     SRCH - This function searches the queue of current
 2575                     output (OUTPUT=YES) or waiting batch jobs (OUTPUT=NO),
 2576                     according to the criteria specified by CRITERIA.  Each
 2577                     job in the selected queue which meets the specified
 2578                     criteria causes a frame of information concerning the
 2579                     job to be deposited in the RESULTS area.  An error is
 2580                     returned if no such jobs are found.  Note that if the
 2581                     service call issuer does not possess the special authorization
 2582                     (PR_DISPJOB), jobs not in his account are not returned
 2583                     in the results area.
 2584
 2585                     SPILL - This function may only be issued by a user
 2586                     having PR_FMEFT privilege.  Its purpose is to mark
 2587                     a portion of the output symbiont queues for spill.  The files
 2588                     to be spilled are selected in the same way as for
 2589                     the SRCH function, that is, by means of VLP_CRITERIA.
 2590                     For a given set of criteria, the same set of files
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          71   
 2591                     will be selected by SRCH and SPILL, except that SPILL
 2592                     will not receive files which are currently being
 2593                     output, or which are in concurrent mode, or which
 2594                     have been marked as SPILLED (see ORDER=SPILLED) function;
 2595                     the SPILL issuer need not have the PR_DISPJOB privilege
 2596                     to receive files not in his account.
 2597                     The SPILL function returns one frame into the RESULTS
 2598                     area for each file found, and simultaneously marks
 2599                     each such file for SPILL, so that it will not be
 2600                     output.  Note that this marking of the file is done
 2601                     in such a way that it is not remembered across system
 2602                     recoveries.  Note also that the SPILL function will
 2603                     return files which are already marked for SPILL.
 2604
 2605                     SPILLED - This function may only be issued by a user
 2606                     having PR_FMEFT privilege.  Its purpose is to notify
 2607                     the system of the final disposition of a file which
 2608                     has been marked for SPILL (see the SPILL function).
 2609                     The DISP parameter tells the system the desired
 2610                     disposition.  The file is identified as for CHECKF,
 2611                     and an error is returned if that
 2612                     file is not already marked for SPILL.
 2613
 2614                     FILL - This function may only be issued by a user
 2615                     having PR_FMEFT privilege.  Its purpose is to notify
 2616                     the system that an output symbiont file which was
 2617                     previously spilled, has now been restored.  The file
 2618                     is identified as for ORDER=SPILLED, and an error occurs
 2619                     if it is not found or not marked as having been
 2620                     spilled.  This function causes the system to re-queue
 2621                     the file for printing.
 2622
 2623                     REMAP - This function may only be issued by the SLUG
 2624                     and OUTSYM system ghosts.  Its purpose is to map or
 2625                     remap a segment of the memory-resident job status
 2626                     information
 2627                     into the monitor WSQ page table used by the other functions
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          72   
 2628                     of this service.  The segment to be mapped is identified
 2629                     by STATSEG, and BUF frames the segment.  If the page table
 2630                     contains insufficient room to perform the mapping, an error
 2631                     is returned.  The default is REMAP.
 2632                     */
 2633
 2634              3 SYSID# UBIN WORD UNAL %INIT(SYSID)%CHARTEXT('/**/'),
 2635                          /*K* SYSID = VALUE-DEC(0-n).  SYSID identifies the job for
 2636                          the UNHOLD, CANCEL, and CHECK functions, in the absence
 2637                          of the JOBNAME.
 2638                          */
 2639              3 STATSEG# UBIN WORD UNAL %INIT(STATSEG)%CHARTEXT('/**/'),
 2640                          /*K* STATSEG = OPTION  STATSEG is used with the REMAP
 2641                          function to identify the segment to be mapped.  The
 2642                          options are defined in FOS_SUBS_C.                      */
 2643              3 OUTPUT# BIT(1) UNAL %INIT(OUTPUT)%CHARTEXT('/**/'),
 2644                          /*K* OUTPUT = {YES|NO}  For the CANCEL function, this
 2645                          specifies whether (YES) or not (NO) the job's output
 2646                          is to be deleted.  For the SRCH function, it specifies
 2647                          which queue is to be searched, the output symbiont queues
 2648                          (OUTPUT=YES), or the batch queue (OUTPUT=NO).
 2649                          The default is NO.                                      */
 2650              3 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2651              3 NUM# UBIN HALF UNAL %INIT(NUM)%CHARTEXT('/**/'),
 2652                          /*K* NUM = VALUE-DEC(0-?) Specifies the output
 2653                          symbiont file NUM for the CHECKF, CANCELF, UNHOLDF,
 2654                          SPILLED, and FILL functions.  The default is 0.
 2655                          */
 2656
 2657              3 DISP# UBIN HALF UNAL %INIT(DISP)%CHARTEXT('/**/'),
 2658                          /*K* DISP = OPTION Specifies the final disposition
 2659                          of the selected file for an ORDER=SPILLED function.
 2660                          The available options are:
 2661
 2662                          REQUEUE - The file is to be marked as eligible
 2663                          for output
 2664
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          73   
 2665                          REMOVE - The file is to be deleted
 2666
 2667                          SPILLED - The file is to be placed on the SPILLED
 2668                          queue, marked as having been spilled, and deleted
 2669                          except for its FIT.  Note that in this case, the
 2670                          file can still be status-checked by M$JOBSTATS
 2671                          CHECK, and retrieved by M$JOBSTATS SRCH but not
 2672                          by M$JOBSTATS SPILL.
 2673
 2674                          The default is REQUEUE.
 2675                          */
 2676
 2677              3 * (0:6) UBIN WORD UNAL %INIT(0*0)%CHARTEXT('/**/');
 2678       %MEND;
 2679
 2680
 2681
 2682
 2683                          /*F* NAME: VLP_CRITERIA
 2684
 2685                          The macro generates an area for use with the SPILL or
 2686                          SRCH function of the M$JOBSTATS service.  It contains the
 2687                          criteria according to which the selected queue is to be
 2688                          searched.  All of the specified criteria are logically
 2689                          ANDed together, that is, only those jobs meeting all of
 2690                          the specified criteria are returned by the service.
 2691                          Each criterion is specified as a VALUE of appropriate
 2692                     type, with the default value indicating that this criterion
 2693                     is not to be applied to the search.                          */
 2694       %MACRO VLP_CRITERIA (FPTN = VLP_CRITERIA,
 2695               STCLASS   = STATIC,
 2696               %LVL=1,
 2697               %LAST=";",
 2698               TNAME     = ' ',
 2699               WSN       = '        ',
 2700               ACCT      = '        ',
 2701               FORM      = '      ',
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          74   
 2702               SYSID     = 0,
 2703               SYSID1    = 0,
 2704               NORUN     (YES='1'B,NO='0'B)= '0'B,
 2705               NSFORM    (YES='1'B,NO='0'B)= '0'B,
 2706               MFW       (YES='1'B,NO='0'B)= '0'B,
 2707               HOLD      (YES='1'B,NO='0'B)= '0'B,
 2708               RUNAFTER  (YES='1'B,NO='0'B)= '0'B,
 2709               RUNNING   (YES='1'B,NO='0'B)= '0'B,
 2710               SPILLED   (YES='1'B,NO='0'B)= '0'B,
 2711               WPS       (YES='1'B,NO='0'B)= '0'B,
 2712               NOTWSN    (YES='1'B,NO='0'B)= '0'B,
 2713               NOTACCT   (YES='1'B,NO='0'B)= '0'B,
 2714               NOTTNAME  (YES='1'B,NO='0'B)= '0'B,
 2715               NOTFORM   (YES='1'B,NO='0'B)= '0'B,
 2716               DEVTYP    = '  ',
 2717               PRIO      = 255,
 2718               PRIO1     = 255);
 2719
 2720       %LSET LISTDIR='0'B;
 2721       %LSET LISTEXP='1'B;
 2722       %LSET LISTCOM='0'B;
 2723       %LSET LISTSUB='1'B;
 2724       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2725       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2726       (SUBSTR(STR,0,8)='CONSTANT') OR
 2727       (SUBSTR(STR,0,3)='EXT');
 2728       %LSET INIT=CHARTEXT('INIT');
 2729       %ELSE;
 2730       %LSET INIT=CHARTEXT('/*');
 2731       %ENDIF;
 2732                                    /*!* VP Y                                     */
 2733      %IF LVL=1;
 2734      DCL 1 FPTN STCLASS DALIGNED,
 2735      %ELSE;
 2736              %LVL FPTN ALIGNED,
 2737      %ENDIF;
 2738                                    /*!* VP N                                     */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          75   
 2739                %(LVL+1) TNAME# CHAR(8) UNAL %INIT(TNAME)%CHARTEXT('/**/'),
 2740                          /*K* TNAME = VALUE-CHAR(8).  For an output queue search,
 2741                          specifies the TNAME (terminal name) of the
 2742                          desired output files.                                   */
 2743                %(LVL+1) WSN# CHAR(8) UNAL %INIT(WSN)%CHARTEXT('/**/'),
 2744                          /*K* WSN = VALUE-CHAR(8).  For a batch queue search,
 2745                          specifies the workstation of origin or the WSN of
 2746                          the desired jobs.  Jobs whose WOO or WSN match the
 2747                          given value are returned.  For an output queue
 2748                          search, WSN specifies the workstation of destination
 2749                          or the WOD of the desired jobs.  Jobs whose WOD
 2750                          match the given value
 2751                          are returned.  Note that the supplied
 2752                          WSN may be wild-carded, that is, if WSN contains
 2753                          a '?' character, then it selects all workstations
 2754                          matching the given string up to the '?'.                */
 2755                %(LVL+1) ACCT# CHAR(8) UNAL %INIT(ACCT)%CHARTEXT('/**/'),
 2756                          /*K* ACCT = VALUE-CHAR(8).  Specifies the account of
 2757                          the desired jobs.                                       */
 2758                %(LVL+1) SYSID# UBIN WORD UNAL %INIT(SYSID)%CHARTEXT('/**/'),
 2759                          /*K* SYSID = VALUE-DEC(0-n).  Specifies the low end of the
 2760                          desired sysid range.                                    */
 2761                %(LVL+1) SYSID1# UBIN WORD UNAL %INIT(SYSID1)%CHARTEXT('/**/'),
 2762                          /*K* SYSID1 = VALUE-DEC(0-n).  Specifies the high end of
 2763                          the desired sysid range, that is, jobs with sysid
 2764                          X such that SYSID <= X <= SYSID1 are to be returned.    */
 2765                %(LVL+1) NORUN# BIT(1) UNAL %INIT(NORUN)%CHARTEXT('/**/'),
 2766                          /*K* NORUN= {YES|NO}.  For a batch queue search, NORUN=YES
 2767                          requests that the only jobs to be returned are
 2768                          those which require either partition change,
 2769                          or a (currently unmounted) shared packset, in order
 2770                          to run.  Note that this criterion will NOT detect
 2771                          jobs requiring non-available physical resources
 2772                          (e.g., resource line printers).                         */
 2773                %(LVL+1) RUNAFTER# BIT(1) UNAL %INIT(RUNAFTER)%CHARTEXT('/**/'),
 2774                          /*K* RUNAFTER = {YES|NO}.  For a batch queue search,
 2775                          specifies that only jobs in the 'runafter' queue
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          76   
 2776                          are to be returned.  See also PRIO1.                    */
 2777                %(LVL+1) MFW# BIT(1) UNAL %INIT(MFW)%CHARTEXT('/**/'),
 2778                     /*K* MFW = {YES|NO}.  For an output queue search, specifies
 2779                     that only files in the multi-file wait queue (i.e., waiting
 2780                     for a concurrent output mode file to be finished) are to be
 2781                     returned.  See also PRIO1.                                   */
 2782                %(LVL+1) HOLD# BIT(1) UNAL %INIT(HOLD)%CHARTEXT('/**/'),
 2783                     /*K* HOLD = {YES|NO}.  For an output queue search, specifies
 2784                     that only files in HOLD are to be returned.
 2785                     See also PRIO1.
 2786                     */
 2787
 2788                %(LVL+1) NSFORM# BIT(1) UNAL %INIT(NSFORM)%CHARTEXT('/**/'),
 2789                     /*K* NSFORM = {YES|NO}.  For an output queue search, NSFORM=YES
 2790                     requests that only files with non-standard FORM
 2791                     be returned.                                                 */
 2792                %(LVL+1) RUNNING# BIT(1) UNAL %INIT(RUNNING)%CHARTEXT('/**/'),
 2793                          /*K* RUNNING = {YES|NO}.  For a batch queue search,
 2794                          RUNNING=YES requests that only jobs which
 2795                          are currently running be returned.  See PRIO1.
 2796                                                                                  */
 2797                %(LVL+1) SPILLED# BIT(1) UNAL %INIT(SPILLED)%CHARTEXT('/**/'),
 2798                          /*K* SPILLED = {YES|NO}.  For an output queue search,
 2799                          specifies that only files which have been spilled are
 2800                          to be returned.  See also PRIO1.                        */
 2801                %(LVL+1) WPS# BIT(1) UNAL %INIT(WPS)%CHARTEXT('/**/'),
 2802                          /*K* WPS = {YES|NO}.  For a batch queue search,
 2803                          WPS = YES requests that only jobs waiting for
 2804                          a shared packset be returned. See also PRIO1.           */
 2805                %(LVL+1) NOTACCT# BIT(1) UNAL %INIT(NOTACCT)%CHARTEXT('/**/'),
 2806                          /*K* NOTACCT = {YES|NO}.  Applies only if an account
 2807                          is supplied.  If NOTACCT=YES, causes entities NOT
 2808                          from the specified account to be selected.
 2809                          The default is NO.                                      */
 2810                %(LVL+1) NOTWSN# BIT(1) UNAL %INIT(NOTWSN)%CHARTEXT('/**/'),
 2811                          /*K* NOTWSN = {YES|NO}.  Applies only if a workstation
 2812                          is supplied.  If NOTWSN=YES, causes entities NOT
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          77   
 2813                          from the specified workstation to be selected.
 2814                          The default is NO.                                      */
 2815                %(LVL+1) NOTTNAME# BIT(1) UNAL %INIT(NOTTNAME)%CHARTEXT('/**/'),
 2816                          /*K* NOTTNAME = {YES|NO}.  Applies only if a TNAME
 2817                          is supplied.  If NOTTNAME=YES, causes entities NOT
 2818                          from the specified TNAME to be selected.
 2819                          The default is NO.                                      */
 2820                %(LVL+1) NOTFORM# BIT(1) UNAL %INIT(NOTFORM)%CHARTEXT('/**/'),
 2821                          /*K* NOTFORM = {YES|NO}.  Applies only if a formname
 2822                          is supplied.  If NOTFORM=YES, causes entities NOT
 2823                          for the specified formname to be selected.
 2824                          The default is NO.                                      */
 2825                %(LVL+1) * BIT(24) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2826                %(LVL+1) PRIO# UBIN WORD UNAL %INIT(PRIO)%CHARTEXT('/**/'),
 2827                /*K* PRIO = VALUE-DEC(0-15).  Specifies the low end of the range
 2828                of priorities for jobs which are to be returned (applies
 2829                to batch queue and output file searches). See PRIO1.              */
 2830                %(LVL+1) PRIO1# UBIN WORD UNAL %INIT(PRIO1)%CHARTEXT('/**/'),
 2831                     /*K* PRIO1 = VALUE-DEC(1-15).  Specifies the high end of the
 2832                     range of priorities for jobs which are to be returned.
 2833                     Note that the values for PRIO and PRIO1 must lie  between
 2834                     0 and 15, which are the limits for batch and output
 2835                     priorities.  One consequence of this is that one cannot,
 2836                     for example, use priority range to select batch jobs
 2837                     waiting for 'runafter' time, or output files in HOLD,
 2838                     for the 'priorities' of these entities lie outside the
 2839                     range 0-15.  To select such jobs,  other criteria must
 2840                     be specified (see NORUN, MFW, HOLD, RUNAFTER, WPS,
 2841                     and SPILLED).
 2842                     Note that the criteria NORUN, MFW, HOLD, RUNAFTER, WPS,
 2843                     RUNNING, SPILLED, PRIO, and PRIO1 select which queues are
 2844                     to be searched, and thus are mutually exclusive.
 2845                     The default, achieved by specifying none of these,
 2846                     is to search all queues, subject to the other
 2847                     criteria.                                                    */
 2848                %(LVL+1) DEVTYP# CHAR(2) UNAL %INIT(DEVTYP)%CHARTEXT('/**/'),
 2849                          /*K* DEVTYP = VALUE-CHAR(2).  For an output queue
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          78   
 2850                          search, specifies the two-character device type
 2851                          (e.g., LP) destination of the desired files.            */
 2852                %(LVL+1) * UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 2853                %(LVL+1) FORM# CHAR(6) UNAL %INIT(FORM)%CHARTEXT('/**/'),
 2854                          /*K* FORM = VALUE-CHAR(6).  For an output queue
 2855                          search, specifies the device FORM required
 2856                          by the desired files.                                   */
 2857                %(LVL+1) * (0:4) UBIN WORD UNAL %INIT(0*0)%CHARTEXT('/**/') LAST
 2858       %MEND;
 2859
 2860
 2861
 2862
 2863
 2864
 2865
 2866
 2867
 2868                          /*F* NAME: VLP_JOBNAME
 2869
 2870                          This macro generates an area for use with the
 2871                          CHECK, CHECKF, UNHOLD, UNHOLDF, CANCEL, and CANCELF
 2872                          functions of the M$JOBSTATS
 2873                          service, containing a jobname.  In identifying a batch
 2874                          job, the jobname is always qualified by an account, and
 2875                          the two together uniquely identify a batch job, provided
 2876                          that the JOB card of that job specified a jobname.      */
 2877       %MACRO VLP_JOBNAME (FPTN = VLP_JOBNAME,
 2878               STCLASS   = STATIC,
 2879               JOBNAME   = '        ');
 2880
 2881       %LSET LISTDIR='0'B;
 2882       %LSET LISTEXP='1'B;
 2883       %LSET LISTCOM='0'B;
 2884       %LSET LISTSUB='1'B;
 2885       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2886       %IF (SUBSTR(STR,0,6)='STATIC') OR
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          79   
 2887       (SUBSTR(STR,0,8)='CONSTANT') OR
 2888       (SUBSTR(STR,0,3)='EXT');
 2889       %LSET INIT=CHARTEXT('INIT');
 2890       %ELSE;
 2891       %LSET INIT=CHARTEXT('/*');
 2892       %ENDIF;
 2893
 2894      DCL 1 FPTN STCLASS DALIGNED,
 2895            2 * UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
 2896            2 JOBNAME# CHAR(31) CALIGNED %INIT(JOBNAME)%CHARTEXT('/**/');
 2897                          /*K* JOBNAME = VALUE-CHAR(31)  Specifies the name of the
 2898                          desired job.                                            */
 2899       %MEND;
 2900
 2901
 2902
 2903
 2904
 2905
 2906
 2907
 2908
 2909                          /*F* NAME: VLR_JOBSTATS_CHECK
 2910
 2911                          This macro generates an area which
 2912                          receives the results of the CHECK and CHECKF
 2913                          functions of the M$JOBSTATS service.                    */
 2914       %MACRO VLR_JOBSTATS_CHECK (FPTN = VLR_JOBSTATS_CHECK,
 2915               STCLASS   = STATIC);
 2916
 2917       %LSET LISTDIR='0'B;
 2918       %LSET LISTEXP='1'B;
 2919       %LSET LISTCOM='0'B;
 2920       %LSET LISTSUB='1'B;
 2921       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2922       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2923       (SUBSTR(STR,0,8)='CONSTANT') OR
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          80   
 2924       (SUBSTR(STR,0,3)='EXT');
 2925       %LSET INIT=CHARTEXT('INIT');
 2926       %ELSE;
 2927       %LSET INIT=CHARTEXT('/*');
 2928       %ENDIF;
 2929
 2930      DCL 1 FPTN STCLASS DALIGNED,
 2931            2 CODE UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 2932                          /*K* CODE = VALUE-DEC(0-n).  Set to the status code for
 2933                               the job.  These codes are listed in CP_6_SUBS
 2934                               as JS_XXXX#, and have the following meanings:
 2935
 2936                          o JS_RUN - Running
 2937
 2938                          o JS_WAIT - Waiting to run
 2939
 2940                          o JS_PRT - The job has finished running and at
 2941                          least one output file is printing
 2942
 2943                          o JS_PWAIT - The job has finished running and
 2944                          has at least one output file, but none
 2945                          currently printing
 2946
 2947                          o JS_SPILLED - The job has finished running and
 2948                          has one or more output files, all of which
 2949                          have been spilled.
 2950
 2951                          o JS_AP - The job is awaiting PRESCAN
 2952
 2953                          o JS_NOTF - The job is not current and cannot
 2954                          be found; it may be listed in the obsolete
 2955                          file.                                                   */
 2956            2 * UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 2957            2 IPRIO UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2958                          /*K* IPRIO = VALUE-DEC(0-n)    is the priority queue
 2959                          which the job is either currently in, or is waiting
 2960                          to be placed in.                                        */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          81   
 2961            2 PRIO UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 2962                          /*K* PRIO = VALUE-DEC(0-n).  Set to the job's priority
 2963                          if CODE is JS_WAIT (waiting to run).  See JP_XXXX in
 2964                          CP_6_SUBS.                                              */
 2965            2 AHEAD UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 2966                          /*K* AHEAD = VALUE-DEC(0-n).  For the CHECK function,
 2967                          AHEAD is set to the number of jobs ahead of the
 2968                          checked job if the status is JS_WAIT, and is set to
 2969                          the number of output files ahead of the checked job's
 2970                          highest-priority output file if the status is JS_PRT
 2971                          or JS_PWAIT.
 2972                          For CHECKF, AHEAD is set to the number of output files
 2973                          ahead of the checked output file.                       */
 2974            2 SYSID UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 2975                /*K* SYSID = VALUE-DEC(0-n)  Set to the checked job's SYSID unless
 2976                the status is 'not found'.  This is useful if the
 2977                job was identified by jobname, and the user wishes
 2978                to know the sysid.                                                */
 2979            2 FCODE UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 2980                     /*K* FCODE = VALUE-DEC(0-n)  Set to the status of the specified
 2981                     output file by the CHECKF function (not meaningful
 2982                     during a CHECK function).  The status codes
 2983                     are in CP_6_SUBS as FS_XXXX.                                 */
 2984            2 FPRIO UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 2985                /*K* FPRIO = VALUE-DEC(0-n)  Set to the priority of the specified
 2986                output file by the CHECKF function (not meaningful
 2987                during a CHECK function).  The priorities are
 2988                defined in CP_6_SUBS as FP_XXXX.                                  */
 2989            2 NOF UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 2990                     /*K* NOF = VALUE-DEC(0-n)  Set to the total number of output
 2991                     symbiont files thus far produced by the checked
 2992                     job.  Note that this count is only guaranteed to be
 2993                     correct for batch jobs, since other (e.g., on-line
 2994                     or ghost) users do not have their output file
 2995                     counts accumulated throughout their entire session.          */
 2996            2 NOFDONE UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 2997                          /*K* NOFDONE = VALUE-DEC(0-n)  Set to the number of output
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          82   
 2998                          symbiont files which were produced by the checked
 2999                          job and have been completely dealt with (e.g.,
 3000                          finished output or cancelled).                          */
 3001            2 NOFPRINTING UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3002                     /*K* NOFPRINTING = VALUE-DEC(0-n)  Set to the number of output
 3003                     symbiont files produced by the checked job which
 3004                     are currently being output.                                  */
 3005            2 NOFSPILLED UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3006                     /*K* NOFSPILLED = VALUE-DEC(0-n)  Set to the number of output
 3007                     symbiont files produced by the checked job which
 3008                     have been spilled.                                           */
 3009            2 DEVNAME CHAR(4) UNAL %INIT('    ')%CHARTEXT('/**/'),
 3010                /*K* DEVNAME = VALUE-CHAR(4)  For the CHECK function, set to the
 3011                name of an output symbiont device on which one
 3012                of the job's output files is printing, provided
 3013                that the job's status is 'printing'. (If at least
 3014                one of the currently-printing files is being output
 3015                on a device of type 'LP', then one of these is
 3016                chosen).  For the CHECKF function, set to the name
 3017                of the device on which the checked file is printing,
 3018                if the file's status is 'printing'.                               */
 3019            2 DEVAVAIL BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3020                          /*K* DEVAVAIL = VALUE-BIT(1).  For CHECK, if the status
 3021                          is JS_PWAIT, DEVAVAIL is set if there are currently any
 3022                          output symbiont devices capable of writing any of the
 3023                          job's output files, and is reset if not.
 3024                          For CHECKF, DEVAVAIL is set if there are currently any
 3025                          output symbiont devices capable of writing the checked
 3026                          file, and is reset if not.                              */
 3027            2 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3028            2 TNAME CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/');
 3029                          /*K* TNAME = VALUE-CHAR(8).  For the CHECK function,
 3030                          TNAME is the name of the TERMINAL to which the
 3031                          device given in DEVNAME belongs.                        */
 3032       %MEND;
 3033
 3034
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          83   
 3035
 3036
 3037
 3038
 3039
 3040
 3041
 3042                          /*F* NAME: VLR_JOBSTATS_OSRCH
 3043
 3044                          This macro defines an area to receive
 3045                          the results of the SPILL and SRCH (OUTPUT=YES)
 3046                          functions of the M$JOBSTATS service.  NFIL is the
 3047                          number of file frames to be allocated in the area.  Note
 3048                          that the service will return an error if the number of
 3049                          files selected by the criteria exceeds the number of
 3050                          frames allocated.                                       */
 3051       %MACRO VLR_JOBSTATS_OSRCH (FPTN = VLR_JOBSTATS_OSRCH,
 3052               STCLASS   = STATIC,
 3053               NFIL      = 0);
 3054
 3055       %LSET LISTDIR='0'B;
 3056       %LSET LISTEXP='1'B;
 3057       %LSET LISTCOM='0'B;
 3058       %LSET LISTSUB='1'B;
 3059       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3060       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3061       (SUBSTR(STR,0,8)='CONSTANT') OR
 3062       (SUBSTR(STR,0,3)='EXT');
 3063       %LSET INIT=CHARTEXT('INIT');
 3064       %ELSE;
 3065       %LSET INIT=CHARTEXT('/*');
 3066       %ENDIF;
 3067
 3068      DCL 1 FPTN STCLASS DALIGNED,
 3069            2 FOUND UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3070                          /*K* FOUND = VALUE-DEC(0-n).  Set to the number of
 3071                          files found.                                            */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          84   
 3072            2 * UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'), /* DALIGN F             */
 3073            2 F (0:NFIL) CHAR(112) UNAL;
 3074                          /*K* F = ARRAY(0:NFIL) CHAR(104) is the array of
 3075                          file frames to be filled as a
 3076                          result of the search.  Note that an element of F
 3077                          is a structure defined by VLA_JOBSTATS_OSRCH.
 3078                          NFIL is the number of file
 3079                          frames to be allocated in the area.                     */
 3080       %MEND;
 3081
 3082
 3083
 3084
 3085
 3086
 3087
 3088
 3089
 3090
 3091                          /*F* NAME: VLA_JOBSTATS_OSRCH
 3092
 3093                          This macro defines the structure of an
 3094                          element of the array VLR_JOBSTATS_OSRCH.F.  The based
 3095                     form of this structure must be used to reference any of the
 3096                     individual items of an array element.  Each array element
 3097                     is an even number of words in length.                        */
 3098       %MACRO VLA_JOBSTATS_OSRCH (FPTN=VLA_JOBSTATS_OSRCH,
 3099               STCLASS   = STATIC);
 3100
 3101       %LSET LISTDIR='0'B;
 3102       %LSET LISTEXP='1'B;
 3103       %LSET LISTCOM='0'B;
 3104       %LSET LISTSUB='1'B;
 3105       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3106       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3107       (SUBSTR(STR,0,8)='CONSTANT') OR
 3108       (SUBSTR(STR,0,3)='EXT');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          85   
 3109       %LSET INIT=CHARTEXT('INIT');
 3110       %ELSE;
 3111       %LSET INIT=CHARTEXT('/*');
 3112       %ENDIF;
 3113
 3114      DCL 1 FPTN STCLASS ALIGNED,
 3115            2 TNAME CHAR(8) UNAL,
 3116                          /*K* TNAME = VALUE-CHAR(8) is the destination TNAME
 3117                          (terminal name).                                        */
 3118            2 DEVTYP CHAR(2) UNAL,
 3119                          /*K* DEVTYP = VALUE-CHAR(2)    specifies the destination
 3120                          device type (e.g., 'LP').                               */
 3121            2 COPIES UBIN BYTE UNAL,
 3122                          /*K* COPIES = VALUE-DEC (0-n)    specifies the number of
 3123                          copies to be printed.                                   */
 3124            2 * UBIN BYTE UNAL,
 3125            2 SAPCOPIES UBIN BYTE UNAL,
 3126                          /*K* SAPCOPIES = VALUE-DEC(0-n)    specifies the number
 3127                          of copies to be printed before
 3128                          putting the file into HOLD, if FLG.SAP is set.          */
 3129            2 PRIO UBIN BYTE UNAL,
 3130                          /*K* PRIO = VALUE-DEC(0-n)     is the priority of the
 3131                          file.  See FP_XXXX in CP_6_SUBS.                        */
 3132            2 ATTR BIT(18) UNAL,
 3133                          /*K* ATTR = VALUE-BIT(18)     is the mask of required
 3134                          device attributes.                                      */
 3135            2 FLG,
 3136                          /*K* FLG contains the following flags:                  */
 3137              3 GLC BIT(1) UNAL,
 3138                          /*K* FLG.GLC = VALUE-BIT(1)     set if OUTSYM has
 3139                          received the last chunk
 3140                          of this file (reset for a concurrent mode file whose
 3141                          last chunk has not yet been received.)                  */
 3142              3 SAP BIT(1) UNAL,
 3143                          /*K* FLG.SAP = VALUE-BIT(1)     set if file is to be
 3144                          placed in HOLD after SAPCOPIES copies have been printed.
 3145                          */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          86   
 3146              3 SPILL BIT(1) UNAL,
 3147                          /*K* FLG.SPILL = VALUE-BIT(1)   set if the file
 3148                          has been marked for spill by an M$JOBSTATS SPILL
 3149                          function.                                               */
 3150              3 DEVAVAIL BIT(1) UNAL,
 3151                          /*K* FLG.DEVAVAIL = VALUE-BIT(1) set if there are
 3152                          currently any output symbiont devices capable of
 3153                          writing this file, and reset if not.                    */
 3154              3 * BIT(1) UNAL,
 3155            2 MODE UBIN(4) UNAL,
 3156                          /*K* MODE = VALUE-DEC(0-n)   is the mode of the
 3157                     user who created this file.  See MODE_XXX# in CP_6_SUBS.     */
 3158            2 BOOTID CHAR(3) UNAL,
 3159                     /*K* BOOTID = VALUE-CHAR(3) is the first 3 characters of the
 3160                     file name in :SYMO.                                          */
 3161            2 SYSID UBIN HALF UNAL,
 3162                          /*K* SYSID = VALUE-DEC(0-n)     is the sysid of the user
 3163                          who produced the file.                                  */
 3164            2 NUM UBIN HALF UNAL,
 3165                          /*K* NUM = VALUE-DEC(0-n)    corresponds to the second
 3166                          part
 3167                          of the file's name in account :SYMO (output symbiont
 3168                          file names are of the form BBBSSSSSSNNNNNNCCC where
 3169                          BBB is the bootid (a value for this boot),
 3170                          SSSSSS is the sysid, NNNNNN is the NUM, and CCC is
 3171                          the concurrent mode chunk number).                      */
 3172            2 HICNUM UBIN HALF UNAL,
 3173                          /*K* HICNUM = VALUE-DEC(0-n)     is the CCC part of the
 3174                          name of the last-received
 3175                          concurrent mode chunk for this file.                    */
 3176            2 GRANS UBIN HALF UNAL,
 3177                          /*K* GRANS = VALUE-DEC(0-n)     is the size of the file
 3178                          in granules.                                            */
 3179            2 FORM CHAR(6) UNAL,
 3180                          /*K* FORM = VALUE-CHAR(6) is the name of the
 3181                          required device form for this file.                     */
 3182            2 DEVNAME CHAR(2) UNAL,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          87   
 3183                          /*K* DEVNAME = VALUE-CHAR(2) if the file is not
 3184                          currently being output, is blanks.  Otherwise
 3185                          it is the last half of the name of the device
 3186                          on which the file is being output (the first
 3187                          half being DEVTYP).                                     */
 3188            2 ACCT CHAR(8) UNAL,
 3189                          /*K* ACCT = VALUE-CHAR(8)     is the account of the
 3190                          user who created the file.                              */
 3191            2 JNAME CHAR(31) UNAL,
 3192                          /*K* JNAME = VALUE-CHAR(31)   is the jobname of
 3193                          the batch job which created this file (if the
 3194                          creator was not a batch job, or if it was a batch
 3195                          job with no jobname, this field is blanks).             */
 3196            2 * UBIN BYTE CALIGNED,
 3197            2 AHEAD UBIN HALF UNAL,
 3198                          /*K* AHEAD = VALUE-DEC(0-n) is the number of output files
 3199                          ahead of this one in the queue for this terminal.       */
 3200            2 * UBIN HALF UNAL,
 3201            2 CREATED UBIN WORD,
 3202                          /*K* CREATED = VALUE-DEC(0-n) is the system time
 3203                          stamp corresponding to the file's creation time.        */
 3204            2 WOD CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3205                     /*K* WOD = VALUE-CHAR(8)    is the job's WSN of destination.*/
 3206            2 * (0:4) UBIN WORD;
 3207       %MEND;
 3208
 3209
 3210
 3211
 3212
 3213
 3214
 3215
 3216
 3217                          /*F* NAME: VLR_JOBSTATS_ISRCH_SN
 3218
 3219                          This macro defines an area to be used
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          88   
 3220                          with the batch queue (OUTPUT=NO) form of the SRCH function
 3221                          of the M$JOBSTATS service.  It defines a number (NSN) of
 3222                          frames for packsets, and receives, for returned jobs which
 3223                          require packsets, information about those sets.         */
 3224       %MACRO VLR_JOBSTATS_ISRCH_SN (FPTN=VLR_JOBSTATS_ISRCH_SN,
 3225               STCLASS   = STATIC,
 3226               NSN       = 0);
 3227
 3228       %LSET LISTDIR='0'B;
 3229       %LSET LISTEXP='1'B;
 3230       %LSET LISTCOM='0'B;
 3231       %LSET LISTSUB='1'B;
 3232       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3233       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3234       (SUBSTR(STR,0,8)='CONSTANT') OR
 3235       (SUBSTR(STR,0,3)='EXT');
 3236       %LSET INIT=CHARTEXT('INIT');
 3237       %ELSE;
 3238       %LSET INIT=CHARTEXT('/*');
 3239       %ENDIF;
 3240
 3241      DCL 1 FPTN STCLASS DALIGNED,
 3242            2 S (0:NSN),
 3243                          /*K* S = ARRAY(0:NSN) is the array of packset
 3244                          frames returned.  Each job
 3245                          returned which requires packsets causes the service to
 3246                          store into S one frame for each packset required by the
 3247                          job.  The job frame in VLR_JOBSTATS_ISRCH.J will contain
 3248                          the number of packsets found, and the index into the
 3249                          VLR_JOBSTATS_ISRCH_SN.S array of the first
 3250                          packset frame.  Each element of the array is an
 3251                          even number of words in length.                         */
 3252              3 NAME CHAR(6) UNAL,
 3253                          /*K* S.NAME = VALUE-CHAR(6)     is the packset name.    */
 3254              3 FLG,
 3255                          /*K* S.FLG contains the following flags describing the
 3256                          use of the packset.                                     */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          89   
 3257                4 PUB BIT(1) UNAL,
 3258                          /*K* S.FLG.PUB = VALUE-BIT(1)     set if the packset
 3259                          is to be public or shared.
 3260                                                                                 */
 3261                4 EXCL BIT(1) UNAL,
 3262                          /*K* S.FLG.EXCL = VALUE-BIT(1)     set if the packset
 3263                          is to be exclusive.                                     */
 3264                4 * BIT(16) UNAL;
 3265       %MEND;
 3266
 3267
 3268
 3269
 3270
 3271
 3272
 3273
 3274
 3275                          /*F* NAME: VLR_JOBSTATS_ISRCH_RES
 3276
 3277                          This macro defines an area to be used
 3278                          with the batch queue (OUTPUT=NO) form of the SRCH function
 3279                          of the M$JOBSTATS service.  It defines a number (NRES) of
 3280                          frames for resources, and receives, for returned
 3281                          jobs which require resources, information about
 3282                          those requirements.                                     */
 3283       %MACRO VLR_JOBSTATS_ISRCH_RES (FPTN=VLR_JOBSTATS_ISRCH_RES,
 3284               STCLASS   = STATIC,
 3285               NRES      = 0);
 3286
 3287       %LSET LISTDIR='0'B;
 3288       %LSET LISTEXP='1'B;
 3289       %LSET LISTCOM='0'B;
 3290       %LSET LISTSUB='1'B;
 3291       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3292       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3293       (SUBSTR(STR,0,8)='CONSTANT') OR
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          90   
 3294       (SUBSTR(STR,0,3)='EXT');
 3295       %LSET INIT=CHARTEXT('INIT');
 3296       %ELSE;
 3297       %LSET INIT=CHARTEXT('/*');
 3298       %ENDIF;
 3299
 3300      DCL 1 FPTN STCLASS DALIGNED,
 3301            2 R (0:NRES),
 3302                          /*K* R = ARRAY(0:NRES) is the array of resource
 3303                          frames returned.  Each
 3304                          job returned which requires resources causes the
 3305                          service to store into R one frame for each resource
 3306                     required by the job.  The job frame in VLR_JOBSTATS_ISRCH.J
 3307                     will contain the number of resources required, and the index
 3308                     into the VLR_JOBSTATS_ISRCH_RES.R array of the first
 3309                     resource frame.  Each element of the array is an
 3310                     even number of words in length.                              */
 3311              3 TYP CHAR(2) UNAL,
 3312                          /*K* R.TYP = VALUE-CHAR(2)    is the resource type name
 3313                          (e.g., 'MT').                                           */
 3314              3 VNUM CHAR(2) UNAL,
 3315                          /*K* R.VNUM = VALUE-CHAR(2)     is the resource
 3316                          number with respect
 3317                          to this type of resource (e.g., if the user requests
 3318                          a virtual tape drive 'MT03', this field for that
 3319                          resource will be '03').                                 */
 3320              3 ATTR BIT(18) UNAL,
 3321                          /*K* R.ATTR = VALUE-BIT(18)    is the mask of required
 3322                          attributes for this
 3323                          resource (e.g., if the resource is 'LP', then these are
 3324                          the required device attributes).                        */
 3325              3 * BIT(18) UNAL;
 3326       %MEND;
 3327
 3328
 3329
 3330
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          91   
 3331
 3332
 3333
 3334
 3335
 3336                          /*F* NAME: VLR_JOBSTATS_ISRCH
 3337
 3338                          This macro defines an area to be used
 3339                          with the batch queue (OUTPUT=NO) form of the SRCH function
 3340                          of the M$JOBSTATS service.  It defines a number (NJOB) of
 3341                          of frames for jobs, and receives one frame for each job
 3342                          which is returned.                                      */
 3343       %MACRO VLR_JOBSTATS_ISRCH (FPTN=VLR_JOBSTATS_ISRCH,
 3344               STCLASS   = STATIC,
 3345               NJOB      = 0);
 3346
 3347       %LSET LISTDIR='0'B;
 3348       %LSET LISTEXP='1'B;
 3349       %LSET LISTCOM='0'B;
 3350       %LSET LISTSUB='1'B;
 3351       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3352       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3353       (SUBSTR(STR,0,8)='CONSTANT') OR
 3354       (SUBSTR(STR,0,3)='EXT');
 3355       %LSET INIT=CHARTEXT('INIT');
 3356       %ELSE;
 3357       %LSET INIT=CHARTEXT('/*');
 3358       %ENDIF;
 3359
 3360      DCL 1 FPTN STCLASS DALIGNED,
 3361            2 FOUND UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3362                          /*K* FOUND = VALUE-DEC(0-n)     is the number of jobs
 3363                          returned.                                               */
 3364            2 * UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'), /* DALIGN J             */
 3365            2 J (0:NJOB) CHAR(256) UNAL;
 3366                          /*K* J = ARRAY(0:NJOB) CHAR(256) is the array of
 3367                          job frames returned, each entry
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          92   
 3368                          corresponding to one job.  Note that the structure
 3369                          of an entry is defined by VLA_JOBSTATS_ISRCH.
 3370                          NJOB specifies the number
 3371                          of frames for jobs.                                     */
 3372       %MEND;
 3373
 3374
 3375
 3376
 3377
 3378
 3379
 3380
 3381
 3382
 3383                          /*F* NAME:  VLA_JOBSTATS_ISRCH
 3384
 3385                          This macro defines the structure of
 3386                          an element of the array VLR_JOBSTATS_ISRCH.J.  The based
 3387                          version of this structure must be used to reference any
 3388                          of the individual fields in an array element.  Each array
 3389                          element is an even number of words in length.           */
 3390       %MACRO VLA_JOBSTATS_ISRCH (FPTN=VLA_JOBSTATS_ISRCH,
 3391               STCLASS   = STATIC);
 3392
 3393       %LSET LISTDIR='0'B;
 3394       %LSET LISTEXP='1'B;
 3395       %LSET LISTCOM='0'B;
 3396       %LSET LISTSUB='1'B;
 3397       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3398       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3399       (SUBSTR(STR,0,8)='CONSTANT') OR
 3400       (SUBSTR(STR,0,3)='EXT');
 3401       %LSET INIT=CHARTEXT('INIT');
 3402       %ELSE;
 3403       %LSET INIT=CHARTEXT('/*');
 3404       %ENDIF;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          93   
 3405
 3406      DCL 1 FPTN STCLASS ALIGNED,
 3407            2 NSN UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3408                          /*K* NSN = VALUE-DEC(0-n)     is the number of packsets
 3409                          required by this job.                                   */
 3410            2 SNX UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3411                          /*K* SNX = VALUE-DEC(0-n)     is the index into the
 3412                          VLR_JOBSTATS_ISRCH_SN.S array of the first packset for
 3413                          for this job.                                           */
 3414            2 NRES UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3415                          /*K* NRES = VALUE-DEC(0-n)     is the number of
 3416                          different types of resources required by this
 3417                          job.                                                    */
 3418            2 RESX UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3419                          /*K* RESX = VALUE-DEC(0-n)     is the index into the
 3420                          VLR_JOBSTATS_ISRCH_RES.R array of the first
 3421                          resource frame for this job.                            */
 3422            2 U UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3423                          /*K* U = VALUE-DEC(0-n)     is the user number of the
 3424                          job, if it is running.                                  */
 3425            2 * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3426            2 PART BIT(16) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3427                          /*K* PART = VALUE-BIT(16)     is the job's eligible
 3428                          partition mask.                                         */
 3429            2 PNUM UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 3430                          /*K* PNUM = VALUE-DEC(0-n)     is the selected partition
 3431                          number.                                                 */
 3432            2 PI UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 3433                          /*K* PI = VALUE-DEC(0-n)    is the current value
 3434                          of the priority increment accumulator.                  */
 3435            2 IPRIO UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 3436                          /*K* IPRIO = VALUE-DEC(0-n)    is the priority queue
 3437                          which the job is either currently in, or is waiting
 3438                          to be placed in.                                        */
 3439            2 PRIO UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 3440                          /*K* PRIO = VALUE-DEC(0-n)    is the current priority
 3441                          of the job.  See JP_XXXX in CP_6_SUBS.                  */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          94   
 3442            2 SUBMIT_TIME UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3443                          /*K* SUBMIT_TIME = VALUE-DEC(0-n)     is the job
 3444                          submittal time in UTS format.                           */
 3445            2 START_TIME UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3446                          /*K* START_TIME = VALUE-DEC(0-n)     is the time the
 3447                          job started running, in UTS format.                     */
 3448            2 FLG,
 3449                          /*K* FLG is a mask of the following flags:              */
 3450              3 O1 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3451                          /*K* FLG.O1 = VALUE-BIT(1)     set if ORDER specified.*/
 3452              3 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3453              3 O3 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3454                          /*K* FLG.03 = VALUE-BIT(1)    set if FOLLOW specified.  */
 3455              3 ACC BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3456                          /*K* FLG.ACC = VALUE-BIT(1)    set if ACCOUNT specified.
 3457                          */
 3458              3 RR BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3459                          /*K* FLG.RR = VALUE-BIT(1)    set if RERUN was specified.
 3460                          */
 3461              3 RR2 BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3462                          /*K* FLG.RR2 = VALUE-BIT(1)    set if currently being
 3463                          rerun.                                                  */
 3464              3 NPI BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3465                          /*K* FLG.NPI = VALUE-BIT(1)     set if NPI (no priority
 3466                          increment) specified.                                   */
 3467              3 RA BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3468                          /*K* FLG.RA = VALUE-BIT(1)    set if DEFER specified.
 3469                                                                                  */
 3470              3 * BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3471            2 NFOLL UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 3472                          /*K* NFOLL = VALUE-DEC(1-8) is the number of
 3473                          elements within the JDID array if FLG.O3 is set.        */
 3474            2 SYSID UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3475                          /*K* SYSID = VALUE-DEC(0-n)     is the job's sysid.     */
 3476            2 AHEAD UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3477                          /*K* AHEAD = VALUE-DEC(0-n)     is the number of jobs
 3478                          ahead of this one in
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          95   
 3479                               the queue. It does not count running jobs.         */
 3480            2 ACCT CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3481                          /*K* ACCT = VALUE-CHAR(8)     is the job's account.*/
 3482            2 UNAME CHAR(12) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3483                          /*K* UNAME = VALUE-CHAR(12)     is the job's user name.*/
 3484            2 WOO CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3485                          /*K* WOO = VALUE-CHAR(8)    is the job's WSN of origin.*/
 3486            2 WSN CHAR(8) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3487                          /*K* WSN = VALUE-CHAR(8)     is the job's effective WSN.*/
 3488            2 JNAME CHAR(31) UNAL %INIT(' ')%CHARTEXT('/**/'),
 3489                          /*K* JNAME = VALUE-CHAR(31)    is the jobname, if any.  */
 3490            2 * UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
 3491            2 RATIM UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3492                          /*K* RATIM = VALUE-DEC(0-n)     is the time in UTS
 3493                          format after which the job may be run, if FLG.RA is
 3494                          set.                                                    */
 3495            2 RRT (0:11) UBIN HALF UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3496                          /*K* RRT = ARRAY(0:11)UBIN(18)  Is the table of resource
 3497                          requirements, indexed by resource type:
 3498
 3499                          TU
 3500                          0      Memory
 3501                          1      Spindles
 3502                          2      Tapes
 3503                          3      Other physical devices
 3504                          4-11   Pseudos 1-8
 3505                          TF
 3506                          */
 3507            2 TIM UBIN WORD UNAL %INIT(0)%CHARTEXT('/**/'),
 3508                     /*K* TIM = VALUE-DEC(0-n) is the maximum runtime of the job, in
 3509                     units of 1/100 seconds.                                      */
 3510            2 JDID (0:7),
 3511                          /*K* JDID = ARRAY  is an array describing the FOLLOW
 3512                          dependencies (if FLG.O3 is set), with one entry
 3513                          for each follow condition specified by this job.        */
 3514              3 RELATION UBIN(3) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3515                     /*K* JDID.RELATION = VALUE-DEC(0-n) is the relation with the
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          96   
 3516                     followed job's final STEPCC (if JDID.FOLLOW_TYPE(k) is
 3517                     0); for example, '>='
 3518                     indicates that the followed job's final STEPCC
 3519                     must be greater than or equal to n for this
 3520                     job to run, n being the contents of JDSTEPCC(k)
 3521                     where this entry is JDID(k).  The codes are:
 3522
 3523                     TU
 3524                     0          <
 3525                     1          <=
 3526                     2          =
 3527                     3          ~= ~?
 3528                     4          >=
 3529                     5          >
 3530                     other      undefined
 3531                     TF
 3532                     */
 3533              3 FOLLOW_TYPE UBIN(3) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3534                          /*K* JDID.FOLLOW_TYPE = VALUE-DEC(0-n) is the type of
 3535                          FOLLOW relation specified.  The codes are:
 3536
 3537                          TU
 3538                          0          STEPCC condition
 3539                          1          OK
 3540                          2          ERROR
 3541                          3          ABORT
 3542                          4          follow all jobs in this job's account
 3543                          other      undefined
 3544                          TF
 3545                          */
 3546              3 * UBIN(11) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3547              3 SATISFIED BIT(1) UNAL %INIT('0'B*0)%CHARTEXT('/**/'),
 3548                          /*K* JDID.SATISFIED = VALUE-BIT(1) indicates whether (set)
 3549                          or not (reset) this dependency has been satisfied.      */
 3550              3 SYSID UBIN(18) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3551                     /*K* JDID.SYSID = VALUE-DEC(0-n) is the sysid of the job to be
 3552                     followed.  If JDID.FOLLOW_TYPE(k) = 4, JDID.SYSID(k) = 0.    */
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          97   
 3553            2 JDSTEPCC (0:7) UBIN(9) UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3554                          /*K* JDSTEPCC = ARRAY  is an array of final STEPCC values
 3555                          of the jobs to be followed, parallel to JDID,
 3556                          for those followed jobs with JDID.FOLLOW_TYPE = 0.      */
 3557            2 * (0:20) UBIN WORD UNAL %INIT(0*0)%CHARTEXT('/**/');
 3558       %MEND;
 3559
 3560
 3561                                    /******************************************/
 3562                                    /*  M$SYMBIO - CONTROL SYMBIONT BLOCK I/O     */
 3563                                    /******************************************/
 3564
 3565
 3566                          /*F* NAME: M$SYMBIO  Special PMME used only by OUTSYM   */
 3567
 3568       %MACRO FPT_SYMBIO (FPTN=FPT_SYMBIO,
 3569               DCB       = NIL,
 3570               NXEXT     = NIL,
 3571               BUF       = NIL,
 3572               STATION   = NIL,
 3573               RECORD    = NIL,
 3574               FORM      = NIL,
 3575               FPRG      = NIL,
 3576               ORDER     = 0,
 3577               SPACEPAGES= 0,
 3578               SETX      = 0,
 3579               BLK       = 0,
 3580               REC       = 0,
 3581               PGDONE    = 0,
 3582               THROTTLE_TIME = 0,
 3583               THROTTLE_CNT  = 0,
 3584               SPACEREC  = 0,
 3585               STCLASS   = STATIC);
 3586
 3587       %LSET LISTDIR='0'B;
 3588       %LSET LISTEXP='1'B;
 3589       %LSET LISTCOM='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          98   
 3590       %LSET LISTSUB='1'B;
 3591       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3592       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3593       (SUBSTR(STR,0,8)='CONSTANT') OR
 3594       (SUBSTR(STR,0,3)='EXT');
 3595       %LSET INIT=CHARTEXT('INIT');
 3596       %ELSE;
 3597       %LSET INIT=CHARTEXT('/*');
 3598       %ENDIF;
 3599
 3600
 3601      DCL 1 FPTN STCLASS DALIGNED,
 3602            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3603            2 NXEXT_ BIT(72) %INIT(VECTOR(NXEXT))%CHARTEXT('/**/'),
 3604            2 BUF_,
 3605              3 BOUND UBIN(20) UNAL %INIT(SIZEV(BUF))%CHARTEXT('/**/'),
 3606              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 3607              3 BUF$ PTR %INIT(ADDR(BUF))%CHARTEXT('/**/'),
 3608            2 STATION_ BIT(72) %INIT(VECTOR(STATION))%CHARTEXT('/**/'),
 3609            2 RECORD_ BIT(72) %INIT(VECTOR(RECORD))%CHARTEXT('/**/'),
 3610            2 FORM_   BIT(72) %INIT(VECTOR(FORM  ))%CHARTEXT('/**/'),
 3611            2 FPRG_   BIT(72) %INIT(VECTOR(FPRG  ))%CHARTEXT('/**/'),
 3612            2 * (0:1) BIT(72) %INIT(VECTOR(NIL )*0)%CHARTEXT('/**/'),
 3613            2 V DALIGNED,
 3614              3 DCB# UBIN HALF UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 3615              3 *    UBIN HALF UNAL %INIT(0)%CHARTEXT('/**/'),
 3616              3 * (0:1) UBIN WORD UNAL %INIT(0*0)%CHARTEXT('/**/'),
 3617              3 ORDER# UBIN(18) UNAL %INIT(ORDER)%CHARTEXT('/**/'),
 3618              3 SETX# UBIN(18) UNAL %INIT(SETX)%CHARTEXT('/**/'),
 3619              3 * UBIN(32) UNAL %INIT(0)%CHARTEXT('/**/'),
 3620              3 TOKEN# BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3621              3 ACK#   BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3622              3 CPVFC# BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3623              3 PAGES# BIT(1) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3624              3 SPACEPAGES# SBIN WORD UNAL %INIT(SPACEPAGES)%CHARTEXT('/**/'),
 3625              3 BLKREC UNAL,
 3626                4 BLK# UBIN(18) UNAL %INIT(BLK)%CHARTEXT('/**/'),
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          99   
 3627                4 REC# UBIN(18) UNAL %INIT(REC)%CHARTEXT('/**/'),
 3628              3 PGDONE# UBIN WORD %INIT(PGDONE)%CHARTEXT('/**/'),
 3629              3 THROTTLE_TIME# UBIN WORD %INIT(THROTTLE_TIME)%CHARTEXT('/**/'),
 3630              3 THROTTLE_CNT# UBIN WORD %INIT(THROTTLE_CNT)%CHARTEXT('/**/'),
 3631              3 SPACEREC# UBIN WORD %INIT(SPACEREC)%CHARTEXT('/**/');
 3632       %MEND;
 3633
 3634      %MACRO VLP_SYMBWRITE                    (FPTN=VLP_SYMBWRITE,
 3635               STCLASS   = STATIC,
 3636               TOF       (YES='1'B,NO='0'B)= '0'B,
 3637               REPEATS   = 1,
 3638               REC       = ' ');
 3639
 3640       %LSET LISTDIR='0'B;
 3641       %LSET LISTEXP='1'B;
 3642       %LSET LISTCOM='0'B;
 3643       %LSET LISTSUB='1'B;
 3644       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3645       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3646       (SUBSTR(STR,0,8)='CONSTANT') OR
 3647       (SUBSTR(STR,0,3)='EXT');
 3648       %LSET INIT=CHARTEXT('INIT');
 3649       %ELSE;
 3650       %LSET INIT=CHARTEXT('/*');
 3651       %ENDIF;
 3652
 3653      DCL 1 FPTN STCLASS DALIGNED,
 3654            2 TOF# BIT(1) UNAL %INIT(TOF)%CHARTEXT('/**/'),
 3655            2 * BIT(17) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 3656            2 REPEATS# UBIN BYTE UNAL %INIT(REPEATS)%CHARTEXT('/**/'),
 3657            2 RECL# UBIN BYTE UNAL %INIT(LENGTHC(REC))%CHARTEXT('/**/'),
 3658            2 REC# CHAR(140) UNAL %INIT(REC)%CHARTEXT('/**/');
 3659      %MEND;
 3660
 3661       %MACRO VLP_SYMBEXTENT (FPTN=VLP_SYMBEXTENT,
 3662               STCLASS   = STATIC);
 3663
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          100  
 3664       %LSET LISTDIR='0'B;
 3665       %LSET LISTEXP='1'B;
 3666       %LSET LISTCOM='0'B;
 3667       %LSET LISTSUB='1'B;
 3668       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3669       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3670       (SUBSTR(STR,0,8)='CONSTANT') OR
 3671       (SUBSTR(STR,0,3)='EXT');
 3672       %LSET INIT=CHARTEXT('INIT');
 3673       %ELSE;
 3674       %LSET INIT=CHARTEXT('/*');
 3675       %ENDIF;
 3676
 3677      DCL 1 FPTN STCLASS DALIGNED,
 3678            2 GRANS# UBIN BYTE UNAL,
 3679            2 DAD# UBIN(27) UNAL,
 3680            2 STAMP,
 3681              3 HASH# UBIN(27) UNAL,
 3682              3 FRDAD# UBIN BYTE UNAL;
 3683       %MEND;
 3684
 3685
 3686
 3687                                    /****************************/
 3688                                    /* M$GJOB - START GHOST OR TP JOB             */
 3689                                    /****************************/
 3690
 3691
 3692
 3693
 3694                          /*F*  NAME: M$GJOB - Start Ghost or TP Job
 3695
 3696                          The M$GJOB monitor service allows users to start
 3697                          GHOST or TP jobs by logging them onto the system.
 3698                          The user being started must be defined in :USERS by
 3699                          SUPER as a valid logon for the mode desired, GHOST
 3700                          or TP, unless FPT_GJOB.V.SLEAZE# is set. This bit,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          101  
 3701                          honored for system ghosts only, specifies that the
 3702                          user is not to go through logon. System ghosts may
 3703                          also specify FPT_GJOB.V.PRIINC# as a base priority
 3704                          increment for the ghost being started.
 3705                          In general, the user may specify ACCT, NAME, PASS
 3706                          of the user to be logged on. A free command, CCBUF,
 3707                          is also allowed.
 3708
 3709                          The call is of the form:
 3710
 3711                          CALL M$GJOB (FPT_GJOB) [ALTRET (label)];
 3712
 3713                          The parameters for this service are as follows:         */
 3714
 3715
 3716       %MACRO FPT_GJOB (FPTN=FPT_GJOB,
 3717            ACCT=NIL,
 3718            NAME=NIL,
 3719            PASS=NIL,
 3720            CCBUF=NIL,
 3721            RESULTS=NIL,
 3722            TPU(YES='1'B,NO='0'B)='0'B,
 3723            SLEAZE(YES='1'B,NO='0'B)='0'B,
 3724            PRIINC=0,
 3725            STCLASS=STATIC);
 3726
 3727       %LSET LISTDIR='0'B;
 3728       %LSET LISTEXP='1'B;
 3729       %LSET LISTCOM='0'B;
 3730       %LSET LISTSUB='1'B;
 3731       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3732       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3733       (SUBSTR(STR,0,8)='CONSTANT') OR
 3734       (SUBSTR(STR,0,3)='EXT');
 3735       %LSET INIT=CHARTEXT('INIT');
 3736       %ELSE;
 3737       %LSET INIT=CHARTEXT('/*');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          102  
 3738       %ENDIF;
 3739
 3740      DCL 1 FPTN STCLASS DALIGNED,
 3741            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3742            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 3743                          /*K* ACCT = VARIABLE. Locates a VLP_ACCT area containing
 3744                          the account of the user to be logged on. If NIL,
 3745                          the caller's ACCT will be used.                         */
 3746            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 3747                          /*K*  NAME = VARIABLE. Locates a VLP_NAME area containing
 3748                          the user name for the user to be started. If NIL,
 3749                          the caller's NAME will be used.
 3750                          Names are limited to twelve characters.                 */
 3751            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
 3752                          /*K* PASS = VARIABLE. Locates a VLP_PASS area containing
 3753                          the password of the user to be started. If NIL,
 3754                          a password of all blanks will be used. All blanks is
 3755                          legal if the user to be started is the same ACCT,NAME
 3756                          as the caller or if the user to be started has no
 3757                          password.                                               */
 3758            2 CCBUF_ BIT(72) %INIT(VECTOR(CCBUF))%CHARTEXT('/**/'),
 3759                          /*K* CCBUF = VARIABLE.  Locates a text string to be
 3760                          placed into JIT.CCBUF for the user. This is analogous
 3761                          to the "first command" option to SUPER. If CCBUF is
 3762                          NIL, the first command specified by SUPER for this
 3763                          user will be used; if not NIL, this will override any
 3764                          first command specified by SUPER.
 3765                          The CCBUF string is limited to 256 characters.          */
 3766            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/'),
 3767                          /*K* RESULTS = VARIABLE. Locates a VLR_GJOB area into
 3768                          which the sysid of the started user is returned.        */
 3769            2 V,
 3770              3 TPU# BIT(1) %INIT(TPU)%CHARTEXT('/**/'),
 3771                          /*K* TPU = {YES|NO}.  YES specifies that a transaction
 3772                          processing user rather than a ghost is to be started.   */
 3773              3 SLEAZE# BIT(1) %INIT(SLEAZE)%CHARTEXT('/**/'),
 3774                          /*K* SLEAZE = {YES|NO}. YES specifies that the ghost
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          103  
 3775                          being started is not to go through logon. It does
 3776                          not need to be defined by SUPER. This option is honored
 3777                          only if the caller is a system ghost.                   */
 3778              3 * BIT(7) %INIT('0'B)%CHARTEXT('/**/'),
 3779              3 PRIINC# UBIN BYTE UNAL %INIT(PRIINC)%CHARTEXT('/**/'),
 3780                          /*K* PRIINC = VALUE-DEC. Specifies the boost to base
 3781                          scheduling priority to give the ghost being started.
 3782                          This option is honored only if the caller is a system
 3783                          ghost.                                                  */
 3784              3 * BIT(18) %INIT('0'B)%CHARTEXT('/**/'),
 3785              3 * BIT(36) %INIT('0'B)%CHARTEXT('/**/');
 3786       %MEND;
 3787
 3788                          /*F* NAME:  VLR_GJOB
 3789
 3790                          This macro generates a VLR area definition for
 3791                          RESULTS parameter of the M$GJOB service.                */
 3792
 3793       %MACRO VLR_GJOB (FPTN=VLR_GJOB,
 3794            STCLASS=STATIC);
 3795
 3796       %LSET LISTDIR='0'B;
 3797       %LSET LISTEXP='1'B;
 3798       %LSET LISTCOM='0'B;
 3799       %LSET LISTSUB='1'B;
 3800       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3801       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3802       (SUBSTR(STR,0,8)='CONSTANT') OR
 3803       (SUBSTR(STR,0,3)='EXT');
 3804       %LSET INIT=CHARTEXT('INIT');
 3805       %ELSE;
 3806       %LSET INIT=CHARTEXT('/*');
 3807       %ENDIF;
 3808
 3809      DCL 1 FPTN STCLASS DALIGNED,
 3810            2 SYSID UBIN(18) UNAL,
 3811           /*K* SYSID = VALUE-DEC(0-n)  Contains the  SYSID of the ghost started
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          104  
 3812           by a successful M$GJOB monitor service.
 3813                          */
 3814            2 * UBIN(18) UNAL,
 3815            2 * UBIN WORD;
 3816       %MEND;
 3817
 3818
 3819                                    /**********************************/
 3820                                    /* GET NEXT USER SLOT PROCEDURE               */
 3821                                    /************************************/
 3822
 3823                          /*F* NAME: M$NXTUSR Special PMME used only by SLUG      */
 3824
 3825       %MACRO FPT_NXTUSR (FPTN=FPT_NXTUSR,
 3826                          STCLASS=STATIC,
 3827                          RESULTS=NIL);
 3828
 3829       %LSET LISTDIR='0'B;
 3830       %LSET LISTEXP='1'B;
 3831       %LSET LISTCOM='0'B;
 3832       %LSET LISTSUB='1'B;
 3833       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3834       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3835       (SUBSTR(STR,0,8)='CONSTANT') OR
 3836       (SUBSTR(STR,0,3)='EXT');
 3837       %LSET INIT=CHARTEXT('INIT');
 3838       %ELSE;
 3839       %LSET INIT=CHARTEXT('/*');
 3840       %ENDIF;
 3841
 3842
 3843      DCL 1 FPTN STCLASS DALIGNED,
 3844            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/');
 3845       %MEND;
 3846                          /*F* NAME:  VLR_NXTUSR.
 3847
 3848                          This macro generates a VLR area definition for
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          105  
 3849                          RESULTS parameter of the M$NXTUSR service.              */
 3850
 3851       %MACRO VLR_NXTUSR (FPTN=VLR_NXTUSR,
 3852            STCLASS=STATIC);
 3853
 3854       %LSET LISTDIR='0'B;
 3855       %LSET LISTEXP='1'B;
 3856       %LSET LISTCOM='0'B;
 3857       %LSET LISTSUB='1'B;
 3858       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3859       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3860       (SUBSTR(STR,0,8)='CONSTANT') OR
 3861       (SUBSTR(STR,0,3)='EXT');
 3862       %LSET INIT=CHARTEXT('INIT');
 3863       %ELSE;
 3864       %LSET INIT=CHARTEXT('/*');
 3865       %ENDIF;
 3866
 3867      DCL 1 FPTN STCLASS DALIGNED,
 3868            2 MODE SBIN WORD,
 3869                          /*K* MODE = VALUE-DEC. Represents the MODE of the user
 3870                          slot to allocate.  BATCH, GHOST, INTERACTIVE or TP
 3871                                                                                  */
 3872            2 ERR UBIN WORD,
 3873                          /*K* ERR = VALUE-DEC. Error code from M$NXTUSR.
 3874                                 0 = No errors,
 3875                                 1 = No user slots available,
 3876                                 2 = No user slots available for this mode,
 3877                                 3 = No sysids available.                         */
 3878            2 SYSID UBIN WORD,
 3879                          /*K* SYSID = VALUE-DEC. The sysid is returned here.     */
 3880            2 USR UBIN WORD;
 3881                          /*K* USR = VALUE-DEC. The user number is returned here. */
 3882       %MEND;
 3883                                    /**************************************/
 3884                                    /*         REPORT USER EVENT SERVICE          */
 3885                                    /**************************************/
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          106  
 3886
 3887                          /*F* NAME: M$RUE - Report User Event
 3888
 3889                          The M$RUE service is for use by system processors
 3890                          to report execution scheduler events on a specified
 3891                          user.  Equates for the possible scheduler events
 3892                          are listed in the following table.  Extreme
 3893                          caution should be used with this service, as its
 3894                          misuse could cause system screeches.
 3895                          ..::TB "^\Event\#8\Value\#4\Meaning"
 3896                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_ABRT
 3897                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_AP
 3898                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_APA
 3899                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_AU
 3900                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CA
 3901                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CAN
 3902                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CBA
 3903                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CBF
 3904                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CBK
 3905                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CBL
 3906                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CEC
 3907                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CIC
 3908                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CRD
 3909                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CUB
 3910                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_CW
 3911                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_DISC
 3912                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_DISCP
 3913                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_DU
 3914                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_ERR
 3915                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_FC
 3916                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_FPEVNT
 3917                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_FPLDTRC
 3918                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_IIP
 3919                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_IIPC
 3920                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_IIPCA
 3921                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_IOC
 3922                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_IOCU
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          107  
 3923                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_MP
 3924                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_NAP
 3925                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_NC
 3926                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_NQP
 3927                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_NQR
 3928                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_NQW
 3929                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_QA
 3930                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_QC
 3931                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_QE
 3932                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_QMF
 3933                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_QPA
 3934                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_SL
 3935                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_SLPMME
 3936                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_UQA
 3937                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_UQC
 3938                          .xeq SS_SCHED_C SS_SCHED_EVENT  SS_WU
 3939                          ..::TB
 3940                          */
 3941       %MACRO FPT_RUE(FPTN=FPT_RUE,
 3942                    STCLASS=STATIC,
 3943                    USER=0,
 3944                    EVENT=0);
 3945
 3946       %LSET LISTDIR='0'B;
 3947       %LSET LISTEXP='1'B;
 3948       %LSET LISTCOM='0'B;
 3949       %LSET LISTSUB='1'B;
 3950       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3951       %IF (SUBSTR(STR,0,6)='STATIC') OR
 3952       (SUBSTR(STR,0,8)='CONSTANT') OR
 3953       (SUBSTR(STR,0,3)='EXT');
 3954       %LSET INIT=CHARTEXT('INIT');
 3955       %ELSE;
 3956       %LSET INIT=CHARTEXT('/*');
 3957       %ENDIF;
 3958
 3959
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          108  
 3960      DCL 1 FPTN STCLASS DALIGNED,
 3961            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3962            2 V DALIGNED,
 3963                          /*K* USER = VALUE-DEC(1-128K) Specifies the SYSID
 3964                          of a user on whom the event is reported.                */
 3965              3 USER# UBIN(18) UNAL %INIT(USER)%CHARTEXT('/**/'),
 3966              3 EVENT# UBIN(9) UNAL %INIT(EVENT)%CHARTEXT('/**/');
 3967                          /*K* EVENT = VALUE-DEC(1-510) Specifies an execution
 3968                          scheduler event number.                                 */
 3969       %MEND;
 3970                                    /************************************/
 3971                                    /**       ENQ MONITOR SERVICE      **/
 3972                                    /************************************/
 3973
 3974                          /*F* NAME:  Resource Control Services
 3975
 3976                          This section explains all monitor services for
 3977                          resource management. The services provided for
 3978                          general use are presented first; restrictions
 3979                          on the use of the remaining services are
 3980                          clearly stated.
 3981                          */
 3982
 3983                          /*F* NAME: M$ENQ - Enqueue for Resource.
 3984
 3985                          The enqueue/dequeue services permit users to coordinate
 3986                          shared use of a resource.  These services
 3987                          are used to coordinate sharing of a disk file by
 3988                          several jobs that run simultaneously.
 3989
 3990                          All users of a resource must refer to it by the
 3991                          same name.  The resource names for M$ENQ and M$DEQ are
 3992                          in no way related to physical resource
 3993                          names.  Instead the resource names are defined by
 3994                          users of the resource to suit their own
 3995                          requirements.  For example, in a random file
 3996                          called DATA FILE, its granules might be considered
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          109  
 3997                          as resources and referred to as 000,001, 002, etc.
 3998
 3999                          When a user enqueues on a resource name, he is
 4000                          effectively put in a queue to wait for availability
 4001                          of the resource.  He remains in the queue until
 4002                          he specifically dequeues naming the resource
 4003                          or until the monitor automatically dequeues
 4004                          him at the end of the job step.
 4005
 4006                          M$ENQ
 4007
 4008                          The M$ENQ service enters the user into the
 4009                          appropriate queue for the resource specified
 4010                          by the RNAME parameter.  Either the user is put to
 4011                          sleep until the resource is available to him
 4012                          (WAIT=YES), or an event is reported when the
 4013                          resource becomes available to that user (WAIT=NO).
 4014                          Once the resource becomes available to the user,
 4015                          it remains available to him until he dequeues
 4016                          or is dequeued by the monitor (as described
 4017                          above).
 4018
 4019                     The user specifies conditions for his use of the resource by
 4020                     specifying the SHARE parameter and the LIMITED_COM
 4021                     parameter.  The simplest use of enqueue/dequeue allows one
 4022                     group of users to have exclusive use of the resource.
 4023                     For users of a disk file, the SHARE parameter can
 4024                     be assigned as follows.  (The LIMITED_COM
 4025                     parameter can be allowed to default.)
 4026
 4027                     }SHARE=ALL        Readers of the resource who want to
 4028                     }                 share the file with other readers but
 4029                     }                 not with updaters.
 4030                     }
 4031                     }SHARE=NONE       Updaters who do not want any other
 4032                     }                 users.
 4033                     }
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          110  
 4034                     A more complex use of M$ENQ parameters gives greater
 4035                     flexibility in coordinating users that share a
 4036                     resource.  For instance, for users of a disk file
 4037                     the SHARE and LIMITED_COM parameters could be
 4038                     assigned as follows:
 4039
 4040                     }SHARE=ALL        Readers who do not care if the file
 4041                     }LIMITED_COM=YES  is being updated as they read
 4042                     }                 (statistical read).
 4043                     }
 4044                     }SHARE=LIMITED    Readers who do not want updates
 4045                     }LIMITED_COM=YES  (exact read).
 4046                     }
 4047                     }SHARE=LIMITED    Updaters who do not care that
 4048                     }                 there may be statistical
 4049                     }                 readers.
 4050                     }
 4051                     }SHARE=NONE       Updaters who do not want any other
 4052                     }                 users.
 4053                     }
 4054
 4055                     The following table fully defines the
 4056                     parameter combinations for simultaneous (Y)
 4057                     and exclusive (N) use of the resource.  In the table,
 4058                     the SHARE parameter is shown as simply the value
 4059                     ALL, LIMITED, or NONE; the LIMITED_COM parameter is
 4060                     represented by YES or NO.  All requests for the
 4061                     use of a resource are satisfied in the order submitted,
 4062                     even if it means delaying a request that is compatible
 4063                     with all current users of the resource.
 4064
 4065
 4066                     .BRN 18
 4067                     TU
 4068                     }        ALL     ALL     LIMITED LIMITED  NONE
 4069                     }        YES     NO      YES     NO
 4070                     ----------------------------------------------
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          111  
 4071                     ALL
 4072                     YES       Y       Y       Y        Y       N
 4073                     ----------------------------------------------
 4074                     ALL
 4075                     NO        Y       Y       N        N       N
 4076                     ----------------------------------------------
 4077                     LIMITED
 4078                     YES       Y       N       Y        N       N
 4079                     ----------------------------------------------
 4080                     LIMITED
 4081                     NO        Y       N       N        N       N
 4082                     ----------------------------------------------
 4083
 4084                     NONE      N       N       N        N       N
 4085                     ----------------------------------------------
 4086
 4087                     TF
 4088
 4089                     Two types of deadlock are possible with
 4090                     enqueue/dequeue:  multi-queue and single queue.
 4091                     A multi-queue deadlock occurs if two or more
 4092                     users have at least one resource and are waiting
 4093                     for at least one resource such that none
 4094                     of the users involved can ever get the resource
 4095                     for which they are waiting.  This deadlock
 4096                     condition causes an alternate return from M$ENQ.
 4097                     The user receiving the error is responsible for
 4098                     unblocking the deadlock.
 4099
 4100                     The single queue deadlock occurs when two or more
 4101                     users have been granted access to a resource and two of
 4102                     these users are attempting to upgrade their
 4103                     access to SHARE=NONE (by re-issuing M$ENQ without
 4104                     first calling M$DEQ).  Since they cannot get
 4105                     exclusive access so long as there are SHARE=ALL
 4106                     or SHARE=LIMITED users of the resource, and since
 4107                     they have not relinquished their existing SHARE
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          112  
 4108                     positions in the queue, deadlock is created
 4109                     and M$ENQ returns an error.
 4110
 4111                     The form of the call for this service is:
 4112
 4113                     CALL M$ENQ (FPT_ENQ) [ALTRET (label)];
 4114
 4115                     The parameters for this service are as follows:
 4116                     */
 4117
 4118
 4119
 4120
 4121
 4122
 4123
 4124       %MACRO FPT_ENQ(   FPTN=FPT_ENQ,
 4125                         DCB=NIL,
 4126                         RNAME=NIL,
 4127                         SHARE(ALL=1,LIMITED=2,NONE=3)=0,
 4128                         LIMITED_COM(YES='1'B,NO='0'B)='0'B,
 4129                         NO_DOWNGRADE(YES='1'B,NO='0'B)='0'B,
 4130                         NO_UPGRADE(YES='1'B,NO='0'B)='0'B,
 4131                         WAIT(YES='1'B,NO='0'B)='1'B,
 4132                         WAIT_TIME=-1,
 4133                         EVENT=0,
 4134                         MESSAGE=NIL,
 4135                         STCLASS=STATIC);
 4136
 4137       %LSET LISTDIR='0'B;
 4138       %LSET LISTEXP='1'B;
 4139       %LSET LISTCOM='0'B;
 4140       %LSET LISTSUB='1'B;
 4141       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4142       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4143       (SUBSTR(STR,0,8)='CONSTANT') OR
 4144       (SUBSTR(STR,0,3)='EXT');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          113  
 4145       %LSET INIT=CHARTEXT('INIT');
 4146       %ELSE;
 4147       %LSET INIT=CHARTEXT('/*');
 4148       %ENDIF;
 4149
 4150      DCL 1 FPTN STCLASS,
 4151            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4152            2 RNAME_ BIT(72) %INIT(VECTOR(RNAME))%CHARTEXT('/**/'),
 4153                          /*K* RNAME = VARIABLE  specifies an area containing the
 4154                           TEXTC name of the resource that is to be shared.  This
 4155                          area may be generated by invoking the VLP_NAME
 4156                          macro.  This  parameter must be specified.
 4157                          */
 4158            2 MESSAGE_ BIT(72) %INIT(VECTOR(MESSAGE))%CHARTEXT('/**/'),
 4159                          /*K* MESSAGE = VARIABLE specifies, if WAIT=YES, the
 4160                          location of a 1-word area where a message is to
 4161                          be placed from  the user who last issued a DEQ
 4162                          from the resource.  If WAIT=NO, this message will
 4163                          be in the TCB.  The default is NIL.
 4164                          */
 4165            2 V DALIGNED,
 4166              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 4167                          /*K* DCB = DCBNAME    is a required parameter.  This
 4168                          parameter must specify the DCB for an open disk file.
 4169                                                                                  */
 4170              3 WAIT# BIT(1) UNAL %INIT(WAIT)%CHARTEXT('/**/'),
 4171                          /*K* WAIT = {YES|NO}    specifies, if YES, that the
 4172                          program is to wait for an  unavailable resource
 4173                          for a period of time designated by the WAIT_TIME
 4174                          parameter.  If NO, the user is placed in the
 4175                          queue, control is returned to the user, and when
 4176                          the request for the resource can be granted, an
 4177                          event is posted that causes an asynchronous entry
 4178                          into the user.  The default is YES.
 4179                          */
 4180              3 NO_DOWNGRADE# BIT(1) UNAL %INIT(NO_DOWNGRADE)%CHARTEXT('/**/'),
 4181                          /*K* NO_DOWNGRADE = {YES|NO} specifies, if YES, that
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          114  
 4182                          if RNAME was named in a previous enqueue request,
 4183                          and this enqueue request would
 4184                          cause a downgrade of the user's access or no change
 4185                     in the user's access, the alternate return should be taken.
 4186                     If NO_DOWNGRADE = NO is specified, this enqueue
 4187                     request could cause a downgrade.  The default is NO.         */
 4188              3 SHARE# UBIN(2) UNAL %INIT(SHARE)%CHARTEXT('/**/'),
 4189                          /*K* SHARE= OPTION  Three options exist for the SHARE
 4190                          parameter:
 4191
 4192                          ALL specifies that the user will share (1) with any
 4193                          other user who has specified SHARE=ALL, and
 4194                          (2) with any other user who has specified
 4195                          SHARE=LIMITED, if LIMITED_COM=YES on the
 4196                          current call.
 4197
 4198                          LIMITED specifies that the user will share with
 4199                          any user who has specified LIMITED_COM=YES.
 4200
 4201                          NONE specifies that the user desires exclusive
 4202                          use of the resource.
 4203
 4204                          */
 4205              3 LIMITED_COM# BIT(1) UNAL %INIT(LIMITED_COM)%CHARTEXT('/**/'),
 4206                          /*K* LIMITED_COM = {YES|NO}   specifies, if YES, that
 4207                          the user can share with other users who specified
 4208                          SHARE=LIMITED.  The default is NO.
 4209                          */
 4210              3 NO_UPGRADE# BIT(1) UNAL %INIT(NO_UPGRADE)%CHARTEXT('/**/'),
 4211                          /*K* NO_UPGRADE = {YES|NO} specifies, if YES, that
 4212                          if RNAME was named in a previous enqueue request,
 4213                          and this enqueue request would
 4214                          cause an upgrade of the user's access,
 4215                          the alternate return should be taken.
 4216                          If NO_UPGRADE = NO is specified, this enqueue
 4217                          request could cause an upgrade.  The default is NO.     */
 4218              3 * BIT(12) UNAL %INIT('0'B)%CHARTEXT('/**/'),
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          115  
 4219              3 WAIT_TIME# SBIN WORD %INIT(WAIT_TIME)%CHARTEXT('/**/'),
 4220                          /*K* WAIT_TIME = VALUE-DEC(0-n)     specifies, in
 4221                          seconds, the maximum time that a user who specified
 4222                          WAIT=YES  is willing to wait before the request is
 4223                           automatically cancelled.  The upper range of this
 4224                          time is a system parameter determined at system
 4225                          definition.  WAIT_TIME=-1 indicates that the user
 4226                          wants the maximum time available.
 4227                          The default is -1.
 4228                          */
 4229
 4230              3 EVENT# SBIN WORD %INIT(EVENT)%CHARTEXT('/**/'),
 4231              3 * SBIN WORD %INIT(0)%CHARTEXT('/**/');
 4232                          /*K* EVENT = VALUE-DEC(0-n) specifies an event
 4233                          identification to be reported back to the user when a
 4234                          WAIT=NO resource request is allocated.  It is also used
 4235                          in conjunction with the SELECTIVE option of M$DEQ to
 4236                          identify sets of resources.  The default is 0.
 4237                          */
 4238       %MEND;
 4239
 4240
 4241
 4242
 4243
 4244
 4245
 4246
 4247
 4248                                    /************************************/
 4249                                    /**       DEQ MONITOR SERVICE      **/
 4250                                    /************************************/
 4251
 4252                          /*F* NAME: M$DEQ - Dequeue for Resource.
 4253
 4254                          The  M$DEQ service allows a user to dequeue for a
 4255                          particular resource or group of resources.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          116  
 4256
 4257                          The form of the call for this service is:
 4258
 4259                          CALL M$DEQ (FPT_DEQ) [ALTRET (label)];
 4260
 4261                          The parameters for this service are as follows:
 4262                          */
 4263
 4264
 4265
 4266
 4267
 4268
 4269
 4270       %MACRO FPT_DEQ(   FPTN=FPT_DEQ,
 4271                         DCB=NIL,
 4272                         RNAME=NIL,
 4273                         RELRES(YES='1'B,NO='0'B)='1'B,
 4274                         CANCEL(YES='1'B,NO='0'B)='0'B,
 4275                         SELECTIVE(YES='1'B,NO='0'B)='0'B,
 4276                         SELECT_ID=0,
 4277                         MESSAGE=NIL,
 4278                         STCLASS=STATIC);
 4279
 4280       %LSET LISTDIR='0'B;
 4281       %LSET LISTEXP='1'B;
 4282       %LSET LISTCOM='0'B;
 4283       %LSET LISTSUB='1'B;
 4284       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4285       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4286       (SUBSTR(STR,0,8)='CONSTANT') OR
 4287       (SUBSTR(STR,0,3)='EXT');
 4288       %LSET INIT=CHARTEXT('INIT');
 4289       %ELSE;
 4290       %LSET INIT=CHARTEXT('/*');
 4291       %ENDIF;
 4292
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          117  
 4293      DCL 1 FPTN STCLASS,
 4294            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4295            2 RNAME_ BIT(72) %INIT(VECTOR(RNAME))%CHARTEXT('/**/'),
 4296                          /*K* RNAME = VARIABLE  specifies an area containing the
 4297                          name of the resource that  is to be affected by
 4298                          the DEQ.  This area may be generated by invoking
 4299                          the VLP_NAME macro.  If RNAME is not specified
 4300                          and SELECTIVE = NO,
 4301                          the DEQ applies to all resources associated with
 4302                          the DCB.
 4303                          */
 4304            2 MESSAGE_ BIT(72) %INIT(VECTOR(MESSAGE))%CHARTEXT('/**/'),
 4305                          /*K* MESSAGE = VARIABLE  specifies the location of a
 4306                          36-bit message that  can be passed to the next
 4307                          user of the resource.  This parameter is only
 4308                          applicable if RELRES = YES.  The default is NIL.
 4309                          */
 4310
 4311            2 V DALIGNED,
 4312              3 DCB# UBIN(18) UNAL %INIT(DCBNUM(DCB))%CHARTEXT('/**/'),
 4313                          /*K* DCB = DCBNAME    specifies a DCB that is open to
 4314                          a disk file.                                            */
 4315              3 RELRES# BIT(1) UNAL %INIT(RELRES)%CHARTEXT('/**/'),
 4316                          /*K* RELRES = {YES|NO}  specifies, if YES, that
 4317                          designated resource element(s) are  to be
 4318                          de-allocated.  The default is YES.
 4319                          */
 4320              3 CANCEL# BIT(1) UNAL %INIT(CANCEL)%CHARTEXT('/**/'),
 4321                          /*K* CANCEL = {YES|NO}  specifies, if YES, that any of
 4322                          the caller's unsatisfied requests for the
 4323                          designated resource element(s) are to be canceled.
 4324                          The default is NO.
 4325                          */
 4326              3 SELECTIVE# BIT(1)UNAL %INIT(SELECTIVE)%CHARTEXT('/**/'),
 4327                          /*K* SELECTIVE = {YES|NO} specifies, if YES and RNAME
 4328                          is NIL, that the DEQ applies to all resources associated
 4329                          with the DCB that were enqueued with EVENT the same
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          118  
 4330                          as this DEQ's SELECT_ID.  The default is NO.            */
 4331              3 * BIT(15) %INIT('0'B)%CHARTEXT('/**/'),
 4332              3 SELECT_ID# UBIN(18)UNAL %INIT(SELECT_ID)%CHARTEXT('/**/'),
 4333                          /*K* SELECT_ID = VALUE-DEC(0-n) specifies the set of
 4334                     resources to be dequeued if SELECTIVE = YES and RNAME = NIL.
 4335                     The resources selected are those that were enqueued
 4336                     with EVENT = SELECT_ID.  The default is 0.                   */
 4337              3 * BIT(18)UNAL %INIT('0'B)%CHARTEXT('/**/');
 4338       %MEND;
 4339                          /*F* NAME: Miscellaneous
 4340
 4341                          The environment in which programs run can be
 4342                          analyzed and, in some cases, influenced by the
 4343                          monitor services described in the remainder of
 4344                          this section.
 4345                          */
 4346                                    /*                                            */
 4347                                    /* TIME AND DATE SERVICE                      */
 4348                                    /*                                            */
 4349                          /*F* NAME: M$TIME - Time and Date.
 4350
 4351                          The M$TIME service returns date and time
 4352                          information, obtained from one of several possible
 4353                          sources, in several optional formats. The source
 4354                          of the date and time may be an input from the
 4355                          calling program or the current system elapsed time
 4356                          clock. The output format options include three
 4357                          character string formats and two binary formats.
 4358                          .spf
 4359                          Note:  For new development, the XUD date format is
 4360                          recommended for use, because it avoids problems
 4361                          with UTS rollover.  Please see the CP-6 Host
 4362                          Library Services Reference (CE71) for more
 4363                          information on the XUD services.
 4364
 4365                          One of the possible source and output formats is
 4366                          the CP-6 Universal Time Stamp (UTS), which is a 36
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          119  
 4367                          bit binary value indicating the elapsed time since
 4368    *                     a base date and time, using mixed units of 1/100th second
 4369    *                     and 1/25th seconds. UTS data is used throughout the CP-6
 4370    *                     system as the standard notation for time.
 4371    *
 4372    *                     Until Host release E03, the UTS was stored only in
 4373    *                     centisecond (1/100th second) units.  Because the UTS was
 4374    *                     approaching overflow of its 36-bit container, the decision
 4375    *                     was made to drop the resolution to 1/25th second to extend
 4376    *                     the range.  In Host release E02 a NEWUTS datum was
 4377    *                     introduced, using this 1/25th second resolution over its
 4378    *                     entire range.  This solution proved unsatisfactory due to
 4379    *                the large number of UTS values stored by the system, all of
 4380    *                which would have had to be converted to the new form.  As
 4381    *                of Host release E03, the NEWUTS feature is no longer
 4382    *                supported, and will fail to compile.
 4383    *
 4384    *                To correct this problem, the UTS will remain in centisecond
 4385    *                units until a cusp instant, at which point the units in
 4386    *                which additional ticks are added will change to 1/25th
 4387    *                second.  All UTS values that represent times before the
 4388    *                cusp will remain valid after the cusp.  Any UTS values
 4389    *                calculated for instants after the cusp become invalid with
 4390    *                host release E03.  Any such values must be converted to the
 4391    *                new system, using the new XUD Library Services mentioned
 4392    *                below.  The cusp instant will occur at midnight, December
 4393    *                31, 1992.
 4394    *
 4395    *                Because a UTS is not stored in constant units, it is not
 4396    *                possible to perform simple addition or subtraction upon
 4397    *                them and have meaningful results.  Five new XUD Library
 4398    *                Services have been provided to perform these functions.
 4399    *                Please see the CP-6 Host Library Services Reference (CE71)
 4400    *                for details on these services.
 4401
 4402                     Another type of UTS format, denoted by the FUTS option
 4403                     is provided to facilitate exchange of times between host
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          120  
 4404                     and FEP systems.  The FEP UTS is a 32 bit value expressing
 4405                     elapsed time in units of .133 seconds.  In CP-6 host systems
 4406                     the FEP UTS is contained in one word with bits 0-3 set
 4407                     to zero.
 4408
 4409                     The M$TIME service takes the alternate return if the
 4410                     source date is prior to January 1, 1978. (Dates prior
 4411                     to that time can occur when processing data from other
 4412                     systems and cannot be converted to UTS).
 4413                     The form of the call for this service is as follows:
 4414
 4415                     CALL M$TIME (FPT_TIME) [ALTRET (label)];
 4416
 4417                     The parameters for M$TIME are:                               */
 4418       %MACRO FPT_TIME
 4419                 (FPTN=FPT_TIME,
 4420                  STCLASS=STATIC,
 4421                 SOURCE(CLOCK=0,ANS=2,LOCAL=3,UTS=4,TUN=5,FUTS=6,UNQUTS=8)=0,
 4422                 DEST(EXT=1,ANS=2,LOCAL=3,UTS=4,TUN=5,FUTS=6)=1,
 4423                 SOURCE_BASIS(LOCAL=0,UTC=1)=0,
 4424                 DEST_BASIS(LOCAL=0,UTC=1)=0,
 4425                  DATE=NIL,
 4426                  TIME=NIL,
 4427                  DAY=NIL,
 4428                  TSTAMP=NIL);
 4429
 4430       %LSET LISTDIR='0'B;
 4431       %LSET LISTEXP='1'B;
 4432       %LSET LISTCOM='0'B;
 4433       %LSET LISTSUB='1'B;
 4434       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4435       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4436       (SUBSTR(STR,0,8)='CONSTANT') OR
 4437       (SUBSTR(STR,0,3)='EXT');
 4438       %LSET INIT=CHARTEXT('INIT');
 4439       %ELSE;
 4440       %LSET INIT=CHARTEXT('/*');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          121  
 4441       %ENDIF;
 4442
 4443      DCL 1 FPTN STCLASS,
 4444            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4445            2 DATE_,
 4446              3 BOUND UBIN(20) UNAL %INIT(SIZEV(DATE))%CHARTEXT('/**/'),
 4447              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 4448              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 4449              3 DATE$ PTR %INIT(ADDR(DATE))%CHARTEXT('/**/'),
 4450                          /*K* DATE = VARIABLE specifies a character string
 4451                          buffer to contain the month, day and year. The
 4452                          size must be that shown in the table for the
 4453                          selected DEST format and must correctly describe
 4454                          the input character string when used with the
 4455                          SOURCE=LOCAL or SOURCE = ANS option.  The default is NIL.
 4456                          */
 4457
 4458            2 TIME_,
 4459              3 BOUND UBIN(20) UNAL %INIT(SIZEV(TIME))%CHARTEXT('/**/'),
 4460              3 * BIT(12) %INIT('7772'O)%CHARTEXT('/**/'),
 4461              3 * BIT(4) %INIT('0'B)%CHARTEXT('/**/'),
 4462              3 TIME$ PTR %INIT(ADDR(TIME))%CHARTEXT('/**/'),
 4463                          /*K* TIME = VARIABLE specifies a character string
 4464                          buffer to contain the time of day.  The size must
 4465                          be that shown in the table for the selected
 4466                          DEST format and must correctly describe the input
 4467                          character string when used with the SOURCE=LOCAL
 4468                          or SOURCE=ANS option.  The default is NIL.
 4469                          */
 4470
 4471            2 DAY_ BIT(72) %INIT(VECTOR(DAY))%CHARTEXT('/**/'),
 4472                          /*K* DAY = VARIABLE specifies a character string
 4473                          buffer for the day of the week for LOCAL or EXT format
 4474                          or the Julian date for ANS format outputs.  The size
 4475                          must be that shown in the table for the selected
 4476                          format. The default is NIL.                             */
 4477            2 TSTAMP_ BIT(72) %INIT(VECTOR(TSTAMP))%CHARTEXT('/**/'),
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          122  
 4478                          /*K* TSTAMP = VARIABLE specifies a 1-word buffer to
 4479                          contain either a host or FEP UTS, or milliseconds since
 4480                          midnight. The default is NIL.                           */
 4481
 4482
 4483            2 V DALIGNED,
 4484              3 SOURCE# UBIN(9) %INIT(SOURCE)%CHARTEXT('/**/') UNAL,
 4485                          /*K* SOURCE = OPTION  Indicates the source of the
 4486                          date and time.  The options are as follows:
 4487
 4488                          .INL +10
 4489                          .UNL 10
 4490                          CLOCK    specifies that the current date and
 4491                                   time, obtained from the system
 4492                                   elapsed time clock, are to be returned.
 4493                                   Note that there is no guarantee that the
 4494                                   UTS value produced will be unique.
 4495
 4496                          .UNL 10
 4497                          UTS      specifies that the date and time are to
 4498                                   be calculated from an input UTS
 4499                                   value found in the TSTAMP buffer.
 4500
 4501                          .UNL 10
 4502
 4503                          FUTS     specifies that the date and time are to
 4504                                   be calculated from an input FEP UTS
 4505                                   value found in the TSTAMP buffer.
 4506
 4507                          .UNL 10
 4508                          LOCAL    specifies that the date and time are to
 4509                                   be calculated from input character
 4510                                   string data found in the DATE and TIME
 4511                                   buffers. Input data must be in the LOCAL
 4512                                   format described in the table above
 4513                                   except that TIME is optional and defaults
 4514                                   to zero.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          123  
 4515                                   (Note that leading zeros may be omitted
 4516                                   from any field and the seconds or
 4517                                   hundredths of seconds fields may be
 4518                                   omitted, in which case zero is assumed).
 4519                                   The exact length of the string must be
 4520                                   reflected in TIME_.BOUND.  Output data
 4521                                   will be stored into the DATE and TIME buffers
 4522                         if the EXT, ANS, or LOCAL options are specified for DEST.
 4523
 4524                         .UNL 10
 4525    *                    ANS      specifies that the date and time are to be
 4526    *                    calculated from input character string data passed in.
 4527    *                    The date is calculated from the DATE buffer, and if the
 4528    *                    buffer is not specified, then the date is calculated from
 4529    *                    the DAY buffer.  The time is calculated from the TIME
 4530    *                    buffer, which is optional and defaults to zero.  Input
 4531    *                    data must be in the ANS format described in the table
 4532    *                    above.  Output data will be stored into the DATE, TIME
 4533    *                    and DAY buffers if the EXT, ANS, or LOCAL options are
 4534    *                    specified for DEST.
 4535
 4536                         .UNL 10
 4537                         TUN      specifies that the input for time is a
 4538                         binary value of milliseconds since
 4539                         midnight to be found in the TSTAMP
 4540                         buffer.  Date is to be the current date.
 4541
 4542                         .UNL 10
 4543                         UNQUTS   specifies that the input for time is a
 4544                         system-maintained UNIQUE UTS.  No two users or
 4545                         single program can ever get the same value from
 4546                         calling M$TIME with this option.  The system-unique
 4547                         UTS is derived from the system clock.  If multiple
 4548                         UNQUTS calls are made within the same 1/25th second
 4549                         span, the calling program will be parked until the
 4550                         system clock can provide a unique UTS for it (in
 4551                         effect, this is a brief, forced M$WAIT).
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          124  
 4552                         .INL -10
 4553
 4554
 4555                         The default is CLOCK.
 4556                         */
 4557              3 DEST# UBIN(9) %INIT(DEST)%CHARTEXT('/**/') UNAL,
 4558                          /*K* DEST = OPTION    Specifies the format of
 4559                          the results of the
 4560                          M$TIME service. The table below illustrates the
 4561                          formats and gives the size, in characters, of the
 4562                          buffer. Results are not returned if a buffer is
 4563                          not specified. The default is EXT.  The options
 4564                          are listed below.
 4565
 4566                          EXT, ANS, LOCAL   are described in the following
 4567                          table.
 4568
 4569                          .BRN 11
 4570                          TU
 4571                          OPTION  BUFFER  SIZE  FORMAT         EXAMPLE
 4572
 4573                          EXT     DATE     10   'MON DD ''YY'  DEC 31 '77
 4574                                  TIME     11   'HH:MM:SS.SS'  23:59:59.99
 4575                                  DAY       3   'DAY'          SUN
 4576                          LOCAL   DATE      8   'MM/DD/YY'     12/31/77
 4577                                  TIME     11   'HH:MM:SS.SS'  23:59:59.99
 4578                                  DAY       3   'DAY'          SUN
 4579                          ANS     DATE      6   'YYMMDD'       771231
 4580                                  TIME      8   'HHMMSSSS'     23595999
 4581                                  DAY       5   'YYDDD'        80366
 4582                          TF
 4583
 4584                          UTS   specifies that a UTS is to be computed
 4585                          from the specified input and returned in the
 4586                          TSTAMP buffer.
 4587
 4588                          FUTS  specifies that an FEP UTS is to be computed
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          125  
 4589                          from the specified input and returned in the
 4590                          TSTAMP buffer.
 4591
 4592                          TUN    specifies that the timer since midnight,
 4593                          in milliseconds, is to be computed from the
 4594                          specified input and returned in the TSTAMP buffer.
 4595                          */
 4596              3 SOURCE_BASIS# UBIN(3) UNAL %INIT(SOURCE_BASIS)%CHARTEXT('/**/'),
 4597                          /*K* SOURCE_BASIS = OPTION   Specifies the basis
 4598                          of the timestamp to be converted.  The options are:
 4599
 4600                          LOCAL  specifies a source timestamp based on the
 4601                          site's local time; no UTC conversion is required.
 4602                          This is the default.
 4603
 4604                          UTC    specifies that the source is a UTC-relative
 4605                          timestamp.
 4606
 4607                          USER   specifies that the source is in the user's
 4608                          local time.  (unimplemented)
 4609                          */
 4610              3 DEST_BASIS# UBIN(3) UNAL %INIT(DEST_BASIS)%CHARTEXT('/**/'),
 4611                          /*K* DEST_BASIS = OPTION   Specifies the basis to
 4612                          be used for the timestamp that is returned.  The
 4613                          options are:
 4614
 4615                          LOCAL  requests that the timestamp be returned in
 4616                          the site's local time, without any UTC conversion.
 4617                          This is the default.
 4618
 4619                          UTC    requests that a UTC-relative timestamp be
 4620                          returned.
 4621
 4622                          USER   requests that the timestamp be returned in
 4623                          the user's local time.  (unimplemented)
 4624                          */
 4625              3 * UBIN(12) UNAL %INIT(0)%CHARTEXT('/**/');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          126  
 4626       %MEND;
 4627
 4628
 4629                                    /*                                            */
 4630                                    /* MONITOR SYSTEM LOAD DISPLAY SERVICE        */
 4631                                    /*                                            */
 4632                          /*F* NAME: M$DISPLAY - Display System Information.
 4633
 4634                          The M$DISPLAY service returns the current values
 4635                          of three system load parameters:
 4636
 4637                          1.  The current number of active users and the current
 4638                              number of active users of each type,
 4639
 4640                          2.  The execution time multiplication factor,
 4641
 4642                          3.  The number of milliseconds within which 90
 4643                              percent of the responses to terminal requests
 4644                              are made.
 4645
 4646                          The response time and ETMF values apply to all
 4647                          operations during the last full minute of system
 4648                          usage.
 4649
 4650                          The form of the call for this service is as
 4651                          follows:
 4652
 4653                          CALL M$DISPLAY (FPT_DISPLAY);
 4654
 4655                          The parameter for this service is:                      */
 4656
 4657       %MACRO FPT_DISPLAY
 4658            (FPTN=FPT_DISPLAY,
 4659             STCLASS=STATIC,
 4660             RESULTS=NIL);
 4661
 4662       %LSET LISTDIR='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          127  
 4663       %LSET LISTEXP='1'B;
 4664       %LSET LISTCOM='0'B;
 4665       %LSET LISTSUB='1'B;
 4666       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4667       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4668       (SUBSTR(STR,0,8)='CONSTANT') OR
 4669       (SUBSTR(STR,0,3)='EXT');
 4670       %LSET INIT=CHARTEXT('INIT');
 4671       %ELSE;
 4672       %LSET INIT=CHARTEXT('/*');
 4673       %ENDIF;
 4674
 4675
 4676      DCL 1 FPTN STCLASS DALIGNED,
 4677            2 RESULTS_ BIT(72) %INIT(VECTOR(RESULTS))%CHARTEXT('/**/');
 4678                          /*K* RESULTS = VARIABLE.  Specifies an area in the
 4679                          user's data area where the results of the
 4680                          M$DISPLAY service are to be stored. This area
 4681                          may be generated by invoking the VLR_DISPLAY
 4682                          macro. The default is NIL.                              */
 4683       %MEND;
 4684                                    /*                                            */
 4685                                    /* M$DISPLAY RESULTS AREA                     */
 4686                                    /*                                            */
 4687                          /*F* NAME: VLR_DISPLAY
 4688
 4689                          The VLR_DISPLAY macro generates an area
 4690                          containing the following fields:                        */
 4691
 4692       %MACRO VLR_DISPLAY
 4693            (FPTN=VLR_DISPLAY,
 4694             STCLASS=STATIC);
 4695
 4696       %LSET LISTDIR='0'B;
 4697       %LSET LISTEXP='1'B;
 4698       %LSET LISTCOM='0'B;
 4699       %LSET LISTSUB='1'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          128  
 4700       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4701       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4702       (SUBSTR(STR,0,8)='CONSTANT') OR
 4703       (SUBSTR(STR,0,3)='EXT');
 4704       %LSET INIT=CHARTEXT('INIT');
 4705       %ELSE;
 4706       %LSET INIT=CHARTEXT('/*');
 4707       %ENDIF;
 4708
 4709
 4710      DCL 1 FPTN STCLASS DALIGNED,
 4711            2 USERS UBIN(36) ,
 4712                          /*K* USERS = VALUE-DEC(1-n).   Contains the total
 4713                          number of currently active users.                       */
 4714            2 ETMF UBIN(36) ,
 4715                          /*K* ETMF = VALUE-DEC(1-n)   contains the current
 4716                          execution time multiplication factor.                   */
 4717            2 RESP UBIN(36),
 4718                          /*K* RESP = VALUE-DEC(0-n)   contains the number of
 4719                          milliseconds that just exceeds the response time of
 4720                          90 percent of the responses to terminal requests.       */
 4721            2 BUSERS UBIN(36),
 4722                          /*K* BUSERS = VALUE-DEC(0-n).  Contains the number
 4723                          of currently active batch users.                        */
 4724            2 GUSERS UBIN(36),
 4725                          /*K* GUSERS = VALUE-DEC(0-n).  Contains the number
 4726                          of currently active ghost users.                        */
 4727            2 OUSERS UBIN(36),
 4728                          /*K* OUSERS = VALUE-DEC(0-n).  Contains the number
 4729                          of currently active online users.                       */
 4730            2 TPUSERS UBIN(36);
 4731                          /*K* TPUSERS = VALUE-DEC(0-n).  Contains the number
 4732                          of currently active Transaction Processing users.       */
 4733       %MEND;
 4734                          /*F* NAME: M$XEQTIME - Execution Time.
 4735
 4736                          The Execution Time service returns, in microseconds,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          129  
 4737                          the amount of execution and service time expended
 4738                          during the current job, in microseconds.
 4739                          The times are either processor or user times,
 4740                          depending on the mode of the caller.
 4741
 4742                          The form of the call for this service is as
 4743                          follows:
 4744
 4745                          CALL M$XEQTIME (FPT_XEQTIME) [ALTRET (label)];
 4746
 4747                          The parameter for this service is:                      */
 4748
 4749       %MACRO FPT_XEQTIME (FPTN=FPT_XEQTIME,
 4750                      STCLASS=STATIC,
 4751                      BUF=NIL);
 4752
 4753       %LSET LISTDIR='0'B;
 4754       %LSET LISTEXP='1'B;
 4755       %LSET LISTCOM='0'B;
 4756       %LSET LISTSUB='1'B;
 4757       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4758       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4759       (SUBSTR(STR,0,8)='CONSTANT') OR
 4760       (SUBSTR(STR,0,3)='EXT');
 4761       %LSET INIT=CHARTEXT('INIT');
 4762       %ELSE;
 4763       %LSET INIT=CHARTEXT('/*');
 4764       %ENDIF;
 4765
 4766      DCL 1 FPTN STCLASS DALIGNED,
 4767            2 BUF_ BIT(72) %INIT(VECTOR(BUF))%CHARTEXT('/**/');
 4768                          /*K* BUF = VARIABLE specifies a two-doubleword
 4769                          buffer. The first double word contains execution
 4770                          time; the second double word contains service
 4771                          time. Both values are in microseconds.                  */
 4772       %MEND;
 4773
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          130  
 4774      /*F* NAME: M$STATE - User State Information.
 4775
 4776           The User State Information service returns information describing
 4777           the current execution state, the amount of time expended and the
 4778           amount of time remaining, for a specified user.
 4779
 4780           The form of the call for this service is as follows:
 4781
 4782           CALL M$STATE (FPT_STATE) [ALTRET(label)];
 4783
 4784           The parameters for this service are:
 4785                                                                            */
 4786      %MACRO FPT_STATE (FPTN=FPT_STATE,
 4787              STCLASS=STATIC,
 4788              BUF=NIL,
 4789              SYSID=0);
 4790
 4791       %LSET LISTDIR='0'B;
 4792       %LSET LISTEXP='1'B;
 4793       %LSET LISTCOM='0'B;
 4794       %LSET LISTSUB='1'B;
 4795       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4796       %IF (SUBSTR(STR,0,6)='STATIC') OR
 4797       (SUBSTR(STR,0,8)='CONSTANT') OR
 4798       (SUBSTR(STR,0,3)='EXT');
 4799       %LSET INIT=CHARTEXT('INIT');
 4800       %ELSE;
 4801       %LSET INIT=CHARTEXT('/*');
 4802       %ENDIF;
 4803
 4804      DCL 1 FPTN STCLASS DALIGNED,
 4805            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4806            2 BUF_ BIT(72) %INIT(VECTOR(BUF))%CHARTEXT('/**/'),
 4807                          /*K* BUF = VARIABLE  specifies a four word block of memory
 4808                     to contain the results of the M$STATE service.  The contents
 4809                     of BUF will be:
 4810                     .SPB 0
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          131  
 4811                     Word 0 will contain the execution state number of the specified
 4812                     user (UBIN WORD).
 4813                     .SPB 0
 4814                Word 1 will contain a four character mnemonic state name (CHAR (4)).
 4815                .SPB 0
 4816                Word 2 will contain the execution time remaining in the job or
 4817                session in 1/100 second units (UBIN WORD).
 4818                .SPB 0
 4819                Word 3 will contain the execution time used during the job or
 4820                session in 1/100 second units (UBIN WORD).
 4821                */
 4822            2 V DALIGNED,
 4823              3 SYSID# UBIN WORD UNAL %INIT(SYSID)%CHARTEXT('/**/'),
 4824                /*K* SYSID = VALUE-DEC(0-n)  is the SYSID of a user whose current
 4825                execution state and time parameters are to be returned.
 4826                */
 4827              3 * BIT(36)%INIT('0'B)%CHARTEXT('/**/');
 4828      %MEND;
 4829                /*F* NAME: M$MONINFO - Get Information About the Running Monitor.
 4830
 4831                The M$MONINFO service returns information about the site and the
 4832                running monitor.  There are five information structures that may be
 4833                obtained.  The information returned in each of these structures is
 4834           described in the VLR_SITEINFO, VLR_MONINFO, VLR_MONPTRS, VLR_SYMBINFO,
 4835           and VLR_HEADER structures.  Any user may obtain the information
 4836           in SITEINFO and HEADER.  The
 4837           SPCLMM or EXMM privilege is required to obtain MONINFO, MONPTRS or
 4838           SYMBINFO.
 4839           */
 4840      /**/
 4841      %MACRO FPT_MONINFO (FPTN=FPT_MONINFO,
 4842                          STCLASS=STATIC,
 4843                          SITEINFO=NIL,
 4844                          MONINFO=NIL,
 4845                          MONPTRS=NIL,
 4846                          SYMBINFO=NIL,
 4847                          STYPE=NIL,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          132  
 4848                          HEADER=NIL);
 4849      %LSET LISTDIR='0'B;
 4850      %LSET LISTEXP='1'B;
 4851      %LSET LISTCOM='0'B;
 4852      %LSET LISTSUB='1'B;
 4853      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4854      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4855          (SUBSTR(STR,0,8)='CONSTANT') OR
 4856          (SUBSTR(STR,0,3)='EXT');
 4857      %LSET INIT=CHARTEXT('INIT');
 4858      %ELSE;
 4859      %LSET INIT=CHARTEXT('/*');
 4860      %ENDIF;
 4861
 4862      DCL 1 FPTN STCLASS DALIGNED,
 4863            2 SITEINFO_ BIT(72) %INIT(VECTOR(SITEINFO))%CHARTEXT('/**/'),
 4864                          /*K* SITEINFO = VARIABLE  specifies the location
 4865                          of the area that is to receive the site information.
 4866                          The contents of this area is described in the
 4867                          VLR_SITEINFO macro.                                     */
 4868            2 MONINFO_ BIT(72) %INIT(VECTOR(MONINFO))%CHARTEXT('/**/'),
 4869                          /*K* MONINFO = VARIABLE  specifies the location
 4870                          of the area that is to receive the information about
 4871                          the running monitor.  The information returned is
 4872                          described in the VLR_MONINFO macro.                     */
 4873            2 MONPTRS_ BIT(72) %INIT(VECTOR(MONPTRS))%CHARTEXT('/**/'),
 4874                          /*K* MONPTRS = VARIABLE  specifies the location of
 4875                          the area that is to receive pointers to various
 4876                          monitor tables.  The pointers returned are described
 4877                          in the VLR_MONPTRS macro.  These pointers are
 4878                          monitor linkage segment pointers and are not
 4879                     directly usable by user programs.  The M$SAD monitor service
 4880                     may be used to access the data pointed to by these
 4881                     pointers.                                                    */
 4882            2 SYMBINFO_ BIT(72) %INIT(VECTOR(SYMBINFO))%CHARTEXT('/**/'),
 4883                          /*K* SYMBINFO = VARIABLE  specifies the location of
 4884                          the area that is to receive the symbiont scheduling
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          133  
 4885                          information.  The contents of this area are described
 4886                          in the VLR_SYMBINFO macro.                              */
 4887            2 STYPE_ BIT(72) %INIT(VECTOR(STYPE))%CHARTEXT('/**/'),
 4888            2 HEADER_ BIT(72) %INIT(VECTOR(HEADER))%CHARTEXT('/**/');
 4889                          /*K* HEADER = VARIABLE.
 4890                          Specifies the location that
 4891                          receives the current header for the system.
 4892                          The structure that is returned is defined by the
 4893                          VLR_HEADER macro.
 4894                          This area may be generated via the VLR_HEADER
 4895                          macro which is described later in this section.
 4896                                                                                  */
 4897
 4898
 4899      %MEND;
 4900                          /*F* NAME:  VLR_HEADER
 4901                          This macro defines the structure for the current system
 4902                          header as returned by the M$MONINFO service.
 4903                          */
 4904
 4905      %MACRO VLR_HEADER (FPTN=VLR_HEADER,
 4906                           STCLASS=STATIC,
 4907                             HEADER=' ');
 4908      %LSET LISTDIR='0'B;
 4909      %LSET LISTEXP='1'B;
 4910      %LSET LISTCOM='0'B;
 4911      %LSET LISTSUB='1'B;
 4912      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4913      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4914          (SUBSTR(STR,0,8)='CONSTANT') OR
 4915          (SUBSTR(STR,0,3)='EXT');
 4916      %LSET INIT=CHARTEXT('INIT');
 4917      %ELSE;
 4918      %LSET INIT=CHARTEXT('/*');
 4919      %ENDIF;
 4920
 4921      DCL 1 FPTN STCLASS DALIGNED,
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          134  
 4922            2 CNT UBIN BYTE UNAL %INIT(SIZEC(HEADER))%CHARTEXT('/**/'),
 4923                /*K* CNT - (0-120). CNT is the size in bytes of the current header
 4924                                    in VLR_HEADER.HEADER#.
 4925                */
 4926            2 HEADER# CHAR(120) UNAL %INIT(HEADER)%CHARTEXT('/**/');
 4927                /*K* HEADER = VALUE-CHAR(120).  HEADER is the current system header.
 4928                */
 4929      %MEND;
 4930                          /*F* NAME:  VLR_SITEINFO
 4931
 4932                     This macro defines the structure for the SITEINFO returned by
 4933                the M$MONINFO service.  This information is available to any user.
 4934                */
 4935
 4936      %MACRO VLR_SITEINFO (FPTN=VLR_SITEINFO,
 4937                           STCLASS=STATIC,
 4938                             MINI_ID=' ',
 4939                           SITE_ID=' ',
 4940                           SITE_NAME=' ',
 4941                           SALUTATION=' ***CP-6 AT YOUR SERVICE! ',
 4942                           ANSPROT(UNPROTECTED=0,SEMI=1,FULL=2)=0,
 4943                           VERSION=' ',
 4944                           CPU_TYPE=0,
 4945                           MON_UTS=0,
 4946                           TIMEZONE='    ',
 4947                           UTC_OFFSET=0);
 4948      %LSET LISTDIR='0'B;
 4949      %LSET LISTEXP='1'B;
 4950      %LSET LISTCOM='0'B;
 4951      %LSET LISTSUB='1'B;
 4952      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4953      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4954          (SUBSTR(STR,0,8)='CONSTANT') OR
 4955          (SUBSTR(STR,0,3)='EXT');
 4956      %LSET INIT=CHARTEXT('INIT');
 4957      %ELSE;
 4958      %LSET INIT=CHARTEXT('/*');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          135  
 4959      %ENDIF;
 4960
 4961      DCL 1 FPTN STCLASS DALIGNED,
 4962            2 MINI_ID# CHAR(3) %INIT(MINI_ID)%CHARTEXT('/**/'),
 4963                          /*K* MINI_ID = VALUE-CHAR(3).  Is the identifier
 4964                          of the mini-integration for this system.  This is
 4965                          used by Bull during development and should always
 4966                          be blanks for released (non-beta) systems.
 4967                                                               */
 4968            2 * CHAR(1) %INIT(' ')%CHARTEXT('/**/'),
 4969            2 SITE_NAME# ALIGNED,
 4970              3 L UBIN BYTE UNAL %INIT(LENGTHC(SITE_NAME))%CHARTEXT('/**/'),
 4971              3 C CHAR(119) %INIT(SITE_NAME)%CHARTEXT('/**/'),
 4972           /*K* SITE_NAME = VALUE-CHAR(119)  Receives the site name in TEXTC format.
 4973           */
 4974            2 SALUTATION# ALIGNED,
 4975              3 L UBIN BYTE UNAL %INIT(LENGTHC(SALUTATION))%CHARTEXT('/**/'),
 4976              3 C CHAR(79) %INIT(SALUTATION)%CHARTEXT('/**/'),
 4977           /*K* SALUTATION = VALUE-CHAR(79)  Receives the TEXTC logon salutation.
 4978           */
 4979            2 ANSPROT# SBIN %INIT(ANSPROT)%CHARTEXT('/**/'),
 4980      /*K* ANSPROT = VALUE-DEC(0-3)  Receives the level of ANS tape protection in
 4981      the system.  The levels are:
 4982
 4983      TU
 4984                 0 - Unprotected system
 4985                 1 - Semi-protected system
 4986                 2 - Fully protected system
 4987      TF
 4988      */
 4989            2 VERSION# CHAR(4) %INIT(VERSION)%CHARTEXT('/**/'),
 4990      /*K* VERSION = VALUE-CHAR(4)  Receives the system version.  The first three
 4991      characters are the version of the CP-6 system.  The fourth character
 4992      is set to 'A' for a "new files" boot (i.e., the user responds Y to
 4993      NEW FILE SYSTEM?) and incremented for each boot "under
 4994      files" (i.e., when the user responds N or S to NEW FILE SYSTEM?).
 4995      The fourth character is incremented from A-Z, a-z, 0-9.
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          136  
 4996      */
 4997            2 MON_UTS# UBIN %INIT(MON_UTS)%CHARTEXT('/**/'),
 4998                     /*K* MON_UTS = VALUE-DEC(0-n)  Receives the UTS time/date of
 4999                     the creation of M:MON.
 5000                     */
 5001            2 SITE_ID# CHAR(6) %INIT(SITE_ID)%CHARTEXT('/**/'),
 5002           /*K* SITE_ID = VALUE-CHAR(6)  Receives the installation SITE ID.  Each
 5003           installation is assigned a unique SITE ID by Bull.
 5004           */
 5005            2 CPU_TYPE# UBIN BYTE UNAL %INIT(CPU_TYPE)%CHARTEXT('/**/'),
 5006                          /*K* CPU_TYPE = VALUE-DEC(0-n)  Receives the CPU
 5007                               type with which the system was booted.
 5008                               The legal values for this field
 5009                               are listed below.
 5010                               ..::TB "^\Type\#10\Value\#4\Meaning"
 5011                               .xeq B_STRINGS_C CPU_TYPE ADP
 5012                               .xeq B_STRINGS_C CPU_TYPE DPSE
 5013                               .xeq B_STRINGS_C CPU_TYPE DPS8000
 5014                               .xeq B_STRINGS_C CPU_TYPE DPS90
 5015                               .xeq B_STRINGS_C CPU_TYPE DPS90XA
 5016                               .xeq B_STRINGS_C CPU_TYPE ELS1
 5017                               .xeq B_STRINGS_C CPU_TYPE L66
 5018                               ..::TB
 5019                          */
 5020            2 * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 5021            2 PATCHWEEK# CHAR(4) %INIT('0000')%CHARTEXT('/**/'),
 5022           /*K* PATCHWEEK = VALUE-CHAR(4)  Contains the installation's current patch
 5023           revision week.  This field cannot be set using the macro invocation.
 5024           */
 5025      /*K* TIMEZONE = VALUE-CHAR(4)  Receives the acronym identifying the
 5026      timezone in effect at the location of the CP-6 system.
 5027      */
 5028            2 TIMEZONE# CHAR(4) %INIT(TIMEZONE)%CHARTEXT('/**/'),
 5029      /*K* UTC_OFFSET = VALUE-DEC  Receives a signed integer number of
 5030      centiseconds which indicates how far ahead, if positive, or behind,
 5031      if negative, the timezone named in TIMEZONE is, relative to UTC
 5032      (Coordinated Universal Time, nee GMT).
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          137  
 5033      */
 5034            2 UTC_OFFSET# SBIN WORD %INIT(UTC_OFFSET)%CHARTEXT('/**/'),
 5035            2 * (0:2) UBIN WORD %INIT(0*0)%CHARTEXT('/**/');
 5036      %MEND;
 5037
 5038
 5039                          /*F* NAME:  VLR_MONINFO
 5040
 5041                     This macro defines the structure for the MONINFO returned by
 5042                the M$MONINFO service.  This information is available only to users
 5043                with SPCLMM or EXMM privilege.
 5044                */
 5045
 5046      %MACRO VLR_MONINFO (FPTN=VLR_MONINFO,
 5047                          STCLASS=STATIC,
 5048                          INIT_UTS=0,
 5049                          SCOUNT=0,
 5050                          ACORE=0,
 5051                          PCORE=0,
 5052                          NOUSERS (YES='1'B,NO='0'B)='0'B,
 5053                          LADCFLG=0);
 5054      %LSET LISTDIR='0'B;
 5055      %LSET LISTEXP='1'B;
 5056      %LSET LISTCOM='0'B;
 5057      %LSET LISTSUB='1'B;
 5058      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5059      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5060          (SUBSTR(STR,0,8)='CONSTANT') OR
 5061          (SUBSTR(STR,0,3)='EXT');
 5062      %LSET INIT=CHARTEXT('INIT');
 5063      %ELSE;
 5064      %LSET INIT=CHARTEXT('/*');
 5065      %ENDIF;
 5066
 5067      DCL 1 FPTN STCLASS DALIGNED,
 5068            2 INIT_UTS# UBIN %INIT(INIT_UTS)%CHARTEXT('/**/'),
 5069                          /*K* INIT_UTS = VALUE-DEC(0-n)  Receives the UTS time/date
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          138  
 5070                          of the last system initialization (full recovery, disk
 5071                          boot, or tape boot).
 5072                          */
 5073            2 SUA_UTS# UBIN %INIT(0)%CHARTEXT('/**/'),
 5074                          /*K* SUA_UTS = VALUE=DEC(0-n)  Receives the UTS time/date
 5075                          of the last single user abort.
 5076                          */
 5077            2 SCOUNT# UBIN %INIT(SCOUNT)%CHARTEXT('/**/'),
 5078                     /*K* SCOUNT = VALUE-DEC(0-n)  Receives the number of screeches
 5079                     since the last tape boot.
 5080                     */
 5081            2 ACORE# UBIN %INIT(ACORE)%CHARTEXT('/**/'),
 5082                     /*K* ACORE = VALUE-DEC(0-n)  Receives the number of unallocated
 5083                     physical pages of memory that are available to users.
 5084                     */
 5085            2 PCORE# UBIN %INIT(PCORE)%CHARTEXT('/**/'),
 5086                          /*K* PCORE = VALUE=DEC(0-n)  Receives the highest physical
 5087                          page number.
 5088                          */
 5089            2 LADCFLG# UBIN %INIT(LADCFLG)%CHARTEXT('/**/'),
 5090                          /*B* LADCFLG - Reserved for future use.
 5091                          */
 5092            2 BOOTFLAG# UBIN %INIT(0)%CHARTEXT('/**/'),
 5093                          /*K* BOOTFLG - UBIN  Receives the type of system boot
 5094                     (IT_BOOTFLG).  The values defined for BOOTFLG are in I_SUBS_C.
 5095                     */
 5096            2 MUAIS# UBIN %INIT(0)%CHARTEXT('/**/'),
 5097                          /*K* MUAIS - UBIN  Receives the number of user slots.   */
 5098            2 NOUSERS# BIT(1) UNAL %INIT(NOUSERS)%CHARTEXT('/**/'),
 5099                          /*K* NOUSERS = {YES|NO} indicates whether (YES)
 5100                          or not (NO), the system is preventing users from
 5101                          logging on.  This bit is set by a 'N' response to
 5102                          the 'DO YOU WANT USERS' question asked by
 5103                          AARDVARK, and by the NOUSERS keyin.  When set,
 5104                          the ON TS, ON BA, etc numbers are set to
 5105                          zero, and no users are permitted to start
 5106                          (this means no logons accepted - all types;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          139  
 5107                          no batch jobs started; no initial STARTUP
 5108                          processing by GOOSE).  The first ON XX N
 5109                          keyin with N nonzero will reset this flag.              */
 5110
 5111            2 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5112
 5113            2 NODE# UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 5114                     /*K* NODE# = VALUE-DEC(0-255) is the node number for this node.
 5115                     */
 5116            2 NODE_NAME CHAR(8) %INIT(' ') %CHARTEXT('/**/'),
 5117                     /*K* NODE_NAME = VALUE-CHAR(8) is the node name for this node.
 5118                     */
 5119            2 NUM_NODES UBIN WORD %INIT(0*0)%CHARTEXT('/**/'),
 5120           /*K* NUM_NODES = VALUE-DEC(0-255) is the number of nodes in the network.
 5121           */
 5122            2 * (0:1) UBIN WORD %INIT(0*0)%CHARTEXT('/**/');
 5123      %MEND;
 5124
 5125
 5126                          /*F* NAME:  VLR_MONPTRS
 5127
 5128                     This macro defines the structure for the MONPTRS returned by
 5129                     the M$MONINFO service.  This information is available only to
 5130                     users with SPCLMM or EXMM privilege.  Note that the level 2
 5131                     names in this structure do not end with the '#' character.
 5132                     */
 5133
 5134      %MACRO VLR_MONPTRS (FPTN=VLR_MONPTRS,
 5135                          STCLASS=STATIC);
 5136      %LSET LISTDIR='0'B;
 5137      %LSET LISTEXP='1'B;
 5138      %LSET LISTCOM='0'B;
 5139      %LSET LISTSUB='1'B;
 5140      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5141      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5142          (SUBSTR(STR,0,8)='CONSTANT') OR
 5143          (SUBSTR(STR,0,3)='EXT');
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          140  
 5144      %LSET INIT=CHARTEXT('INIT');
 5145      %ELSE;
 5146      %LSET INIT=CHARTEXT('/*');
 5147      %ENDIF;
 5148
 5149      DCL 1 FPTN STCLASS DALIGNED,
 5150            2 N$DCT$$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 5151                          /*K* N$DCT$$  Points to the array of pointers indexed by
 5152                          the DCT index for peripheral devices.
 5153                          */
 5154            2 NI$CHT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 5155                          /*K* NI$CHT$  Points to the channel table.
 5156                          */
 5157            2 NI$DVT$$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 5158                     /*K* NI$DVT$$  Points to the array of DVT pointers indexed by
 5159                     DCT.DVTX.
 5160                     */
 5161            2 B$USRT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 5162                          /*K* B$USRT$  Points to the beginning of the user tables.
 5163                          */
 5164            2 B$P$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
 5165                     /*K* B$P$  Points to the beginning of the processor tables.
 5166                     */
 5167            2 * (0:7) PTR %INIT(ADDR(NIL)*0)%CHARTEXT('/**/');
 5168      %MEND;
 5169                          /*F* NAME:  VLR_SYMBINFO
 5170
 5171                          This macro defines the structure of the SYMBINFO results
 5172                          area of the M$MONINFO service.  It contains the data
 5173                          associated with output symbiont file priority assignment
 5174                          set up by CONTROL.
 5175                          */
 5176      %MACRO VLR_SYMBINFO (FPTN=VLR_SYMBINFO,
 5177               HOLDEXPIRE= 36,
 5178               GRANSCHED = 1,
 5179               WATCH     (YES='1'B,NO='0'B)= '0'B,
 5180               STCLASS   = STATIC);
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          141  
 5181
 5182       %LSET LISTDIR='0'B;
 5183       %LSET LISTEXP='1'B;
 5184       %LSET LISTCOM='0'B;
 5185       %LSET LISTSUB='1'B;
 5186       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5187       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5188       (SUBSTR(STR,0,8)='CONSTANT') OR
 5189       (SUBSTR(STR,0,3)='EXT');
 5190       %LSET INIT=CHARTEXT('INIT');
 5191       %ELSE;
 5192       %LSET INIT=CHARTEXT('/*');
 5193       %ENDIF;
 5194
 5195      DCL 1 FPTN STCLASS ALIGNED,
 5196            2 GRANSCHED# UBIN WORD UNAL %INIT(GRANSCHED)%CHARTEXT('/**/'),
 5197                          /*K* GRANSCHED = VALUE-DEC(0-n)  instructs OUTSYM
 5198                          whether (~0) or not (0) to assign output symbiont
 5199                          file priorities by granule count or by submittal
 5200                          priority.  If GRANSCHED is zero, then the GRANLOW
 5201                          array values are meaningless.                           */
 5202            2 GRANLOW# (0:14) UBIN WORD UNAL %INIT(0,1000,500,400,300,200,
 5203              100,75,50,30,20,10,5,3,2)%CHARTEXT('/**/'),
 5204                          /*K* GRANLOW (0:14) = VALUE-DEC(0-n) is an array of
 5205                          granule counts.  The 0th element is unused; the other
 5206                          elements must be assigned values in a strictly decreasing
 5207                          fashion (i.e., if k > m then GRANLOW(k) < GRANLOW(m)).
 5208                          OUTSYM uses this table if GRANSCHED is nonzero to
 5209                          assign priorities to output symbiont files according
 5210                          to their granule count, as follows:  the priority
 5211                          assigned to a K-granule file is the minimum N such
 5212                          that K > GRANLOW(N), unless the submittal priority
 5213                          is 0 or 15 (in which case submittal priority is used).
 5214                          (Note that for this purpose, K is the granule size
 5215                          of the file times the number of copies.)                */
 5216            2 STREAMFILEID# CHAR(3) UNAL %INIT('$$$')%CHARTEXT('/**/'),
 5217                          /*K* STREAMFILEID = VALUE-CHAR(3) is the output
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          142  
 5218                          symbiont file BOOTID being used currently.              */
 5219            2 * UBIN BYTE UNAL %INIT(0)%CHARTEXT('/**/'),
 5220
 5221            2 WATCH# BIT(36) UNAL %INIT(WATCH)%CHARTEXT('/**/'),
 5222                          /*K* WATCH = {YES|NO} indicates whether (YES)
 5223                          or not (NO), a message is to be printed on the
 5224                          appropriate device console whenever an output
 5225                          symbiont device commences or ceases output of
 5226                          a file.  The message names the file and the
 5227                          device, and is for informational purposes
 5228                          only.
 5229
 5230                          The default is NO.                                      */
 5231
 5232            2 HOLDEXPIRE# UBIN %INIT(HOLDEXPIRE)%CHARTEXT('/**/'),
 5233                          /*K* HOLDEXPIRE = VALUE-DEC(0-n) specifies
 5234                          the time interval in hours for which the
 5235                          'HOLD' attribute for symbiont output will
 5236                          be honored.  After the specified number
 5237                          of hours has elapsed from the time of
 5238                          submittal, the file will be taken out
 5239                          of hold status and made a candidate for
 5240                          output.  HOLDEXPIRE is intended for use
 5241                          in situations where the system manager
 5242                          wishes to prevent files being 'held'
 5243                          for arbitrarily long periods of time.
 5244                          A value of zero specifies that no
 5245                          expiration is to be performed.
 5246
 5247                          The default is 36.                                      */
 5248
 5249            2 * (0:12) UBIN WORD UNAL %INIT(0*0)%CHARTEXT('/**/');
 5250      %MEND;
 5251                                    /************************************/
 5252                                    /**    CMDVAR MONITOR SERVICE      **/
 5253                                    /************************************/
 5254
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          143  
 5255                          /*F* NAME: M$CMDVAR - Manipulate Command Variables.
 5256
 5257                          M$CMDVAR service manipulates command variables.  The
 5258                          variables are stored in character format in the
 5259                          user-inaccessible file, *S.  This service
 5260                          stores, fetches, and deletes command variables
 5261                          from the *S file.
 5262
 5263                          The form of the call for this service is as follows:
 5264
 5265                          CALL M$CMDVAR (FPT_CMDVAR) [ALTRET (label)];
 5266
 5267                          The parameters for this service are as follows:         */
 5268
 5269
 5270       %MACRO FPT_CMDVAR (FPTN=FPT_CMDVAR,
 5271            NAME=NIL,
 5272            VALUE=NIL,
 5273            FUN(STORE=1,FETCH=2,DELETE=3,LIST=4)=2,
 5274            PNAME=NIL,
 5275            PACCT=NIL,
 5276            PPSN=NIL,
 5277            PRIVATE(NO='0'B,YES='1'B)='0'B,
 5278            STCLASS=STATIC);
 5279
 5280       %LSET LISTDIR='0'B;
 5281       %LSET LISTEXP='1'B;
 5282       %LSET LISTCOM='0'B;
 5283       %LSET LISTSUB='1'B;
 5284       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5285       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5286       (SUBSTR(STR,0,8)='CONSTANT') OR
 5287       (SUBSTR(STR,0,3)='EXT');
 5288       %LSET INIT=CHARTEXT('INIT');
 5289       %ELSE;
 5290       %LSET INIT=CHARTEXT('/*');
 5291       %ENDIF;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          144  
 5292
 5293      DCL 1 FPTN STCLASS DALIGNED,
 5294            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5295            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 5296                          /*K*  NAME = VARIABLE locates a TEXTC area containing the
 5297                          name of the command variable to be affected.  The
 5298                          name is limited to 31 characters and must start with
 5299                          an alphabetic character.                                */
 5300
 5301            2 VALUE_ BIT(72) %INIT(VECTOR(VALUE))%CHARTEXT('/**/'),
 5302                          /*K* VALUE = VARIABLE locates a TEXTC string to be
 5303                          used as a value on STORE operations and filled on
 5304                          FETCH or list operations.  The string may be up to 511
 5305                          characters in length.  There are no restrictions
 5306                          on content.
 5307
 5308                          Note that longer command variable values (or those
 5309                          containing special characters) may cause problems if
 5310                          invoked in the IBEX command stream.  They may, however,
 5311                          be used to pass instructions or parameters to other
 5312                          routines within the JOB.
 5313                          */
 5314            2 PNAME_ BIT(72) %INIT(VECTOR(PNAME))%CHARTEXT('/**/'),
 5315                          /*K* PNAME = VARIABLE.  Locates a VLP_NAME to be
 5316                          used for private (processor local) command variables.
 5317                          */
 5318            2 PACCT_ BIT(72) %INIT(VECTOR(PACCT))%CHARTEXT('/**/'),
 5319                          /*K* PACCT = VARIABLE.  Locates a VLP_ACCT to be
 5320                          used for private (processor local) command variables.
 5321                          */
 5322            2 PPSN_ BIT(72) %INIT(VECTOR(PPSN))%CHARTEXT('/**/'),
 5323                          /*K* PPSN  = VARIABLE.  Locates a VLP_SN to be
 5324                          used for private (processor local) command variables.
 5325                          */
 5326            2 V DALIGNED,
 5327              3 FUN# UBIN(9) UNAL %INIT(FUN)%CHARTEXT('/**/'),
 5328                          /*K* FUN = {STORE|FETCH|DELETE|LIST}.  STORE specifies
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          145  
 5329                          that the contents of VALUE are to become the new
 5330                          value of the NAMEd command variable.  FETCH fills
 5331                          VALUE with the current value of the NAMEd command
 5332                          variable.  DELETE removes the NAMEd command variable.
 5333                          LIST returns in the VALUE field the name of the command
 5334                          variable following the NAMEd one.
 5335
 5336                          The fully qualified name of this field is
 5337                          FPT_CMDVAR.V.FUN#.  Acceptable EQUs are CMD_STORE#,
 5338                          CMD_FETCH#, CMD_DELETE#, and CMD_LIST#.
 5339                          */
 5340              3 PRIVATE# BIT(1) UNAL %INIT(PRIVATE)%CHARTEXT('/**/'),
 5341                          /*K* PRIVATE = {YES|NO}.  YES specifies that the
 5342                          command variable is to be local to the calling
 5343                          processor and not an IBEX command variable.  If
 5344                          YES is specified, PNAME, PACCT and PPSN tell which
 5345                          processor's private command variables are to be
 5346                          accessed.
 5347                          */
 5348              3 * BIT(26) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5349              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 5350       %MEND;
 5351
 5352
 5353
 5354                                    /************************************/
 5355                                    /**    M$SYSID MONITOR SERVICE     **/
 5356                                    /************************************/
 5357
 5358                          /*F* NAME:  M$SYSID - SYSID Control.
 5359                          The M$SYSID service provides an interface for system
 5360                          ghosts to control SYSID allocation on the system.
 5361                          The service actually performs three separate functions.
 5362                          These are:
 5363                             o Querying for currently running SYSIDs.
 5364                             o Setting the BOOTID at system initialization.
 5365                             o Setting the available SYSID range by affecting
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          146  
 5366                               S_SYSID and S_NSYSIDS. These two values are
 5367                               used by UMS$NXTSID in allocating new SYSIDs.
 5368
 5369                          Usage of this service is restricted to system ghosts
 5370                          OUTSYM and GHOST1. The setting of BOOTID is further
 5371                          restricted to GHOST1 only.
 5372
 5373                          SYSIDs on the system are allocated at the current value
 5374                          of S_SYSID. The list of available SYSIDs on the system
 5375                          starts at S_SYSID and continues for S_NSYSIDS SYSIDs.
 5376                          SYSIDs 1 through 99999 are the only SYSIDs possible
 5377                          and only the system ghosts may use the SYSIDs 1 through
 5378                          JG_MING#. For this reason, the next available SYSID past
 5379                          99999 is JG_MING#+1.
 5380
 5381                          When M$SYSID is called to re-establish the available
 5382                          SYSID range, the 'new' range is checked to see if it
 5383                          directly follows the 'current' range. If it does, the
 5384                          two ranges are made into one range and that is the new
 5385                          available SYSID range. If the two are not adjacent,
 5386                          the old range is thrown out and the new range is used.  */
 5387
 5388
 5389
 5390      %MACRO FPT_SYSID (FPTN=FPT_SYSID,
 5391            STCLASS       = STATIC,
 5392            SETSYSID      (YES='1'B,NO='0'B)='0'B,
 5393            SETBOOTID     (YES='1'B,NO='0'B)='0'B,
 5394            GETSYSIDS     (YES='1'B,NO='0'B)='0'B,
 5395            SYSID         = 0,
 5396            NSYSIDS       = 0,
 5397            BOOTID        = '$$$',
 5398            SYSIDBUF      = NIL);
 5399
 5400       %LSET LISTDIR='0'B;
 5401       %LSET LISTEXP='1'B;
 5402       %LSET LISTCOM='0'B;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          147  
 5403       %LSET LISTSUB='1'B;
 5404       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5405       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5406       (SUBSTR(STR,0,8)='CONSTANT') OR
 5407       (SUBSTR(STR,0,3)='EXT');
 5408       %LSET INIT=CHARTEXT('INIT');
 5409       %ELSE;
 5410       %LSET INIT=CHARTEXT('/*');
 5411       %ENDIF;
 5412
 5413      DCL 1 FPTN STCLASS DALIGNED,
 5414            2 V_ BIT(72) UNAL %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5415
 5416            2 SYSIDBUF_ BIT(72) UNAL %INIT(VECTOR(SYSIDBUF))%CHARTEXT('/**/'),
 5417                          /*K* SYSIDBUF = VARIABLE. Locates a VLR_SYSID area
 5418                          in which to return the currently running SYSIDs.
 5419                          This area will be filled in if FPTN.V.GETSYSIDS#
 5420                          is set.                                                 */
 5421
 5422            2 V DALIGNED,
 5423              3 GETSYSIDS# BIT(1) UNAL %INIT(GETSYSIDS)%CHARTEXT('/**/'),
 5424                          /*K* GETSYSIDS = OPTION indicates that the SYSIDBUF_
 5425                          framed area is to be filled in with all running
 5426                          SYSIDs.                                                 */
 5427
 5428              3 SETSYSID# BIT(1) UNAL %INIT(SETSYSID)%CHARTEXT('/**/'),
 5429                          /*K* SETSYSID = OPTION indicates that
 5430                          FPTN.V.SYSID# and FPTN.V.NSYSIDS# are to be used
 5431                          in setting the new SYSID range used by UMS$NXTSID on
 5432                          allocating new SYSIDs.                                  */
 5433
 5434              3 SETBOOTID# BIT(1) UNAL %INIT(SETBOOTID)%CHARTEXT('/**/'),
 5435                          /*K* SETBOOTID = OPTION indicates that
 5436                          FPTN.V.BOOTID# is to be used as the system's
 5437                          S_STREAMFILEID. This is the 3 character prefix for
 5438                          all files built in .:SYMO.                              */
 5439
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          148  
 5440              3 * BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5441
 5442              3 BOOTID# CHAR(3) %INIT(BOOTID)%CHARTEXT('/**/'),
 5443                          /*K* BOOTID = VALUE-CHAR(3). The value to be used
 5444                          as S_STREAMFILEID, the prefix for all files created
 5445                          in .:SYMO. Also placed into FO_SYMBINFO.STREAMFILEID#.  */
 5446
 5447              3 SYSID# UBIN HALF HALIGNED %INIT(SYSID)%CHARTEXT('/**/'),
 5448                          /*K* SYSID = VALUE-DEC. Start of SYSID range
 5449                          to be used in setting up new SYSID range. If the caller
 5450                          is GHOST1, the new S_SYSID is also placed into
 5451                          ROSEG.STREAMFILENO so that all MING ghosts will
 5452                          have unique filenames for their .:SYMO files.           */
 5453
 5454              3 NSYSIDS# UBIN HALF HALIGNED %INIT(NSYSIDS)%CHARTEXT('/**/');
 5455                          /*K* NSYSIDS = VALUE-DEC. Number of adjacent SYSIDs
 5456                          in the range of SYSIDs to be used in determining
 5457                          the new range of available SYSIDs.                      */
 5458      %MEND;
 5459
 5460
 5461
 5462                          /*F* NAME:   VLR_SYSID.
 5463                          Used by FPT_SYSID as the structure in which to return
 5464                          the list of currently running SYSIDs.                   */
 5465
 5466      %MACRO VLR_SYSID (FPTN=VLR_SYSID,
 5467               STCLASS     = STATIC,
 5468               %N=1);
 5469
 5470       %LSET LISTDIR='0'B;
 5471       %LSET LISTEXP='1'B;
 5472       %LSET LISTCOM='0'B;
 5473       %LSET LISTSUB='1'B;
 5474       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5475       %IF (SUBSTR(STR,0,6)='STATIC') OR
 5476       (SUBSTR(STR,0,8)='CONSTANT') OR
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          149  
 5477       (SUBSTR(STR,0,3)='EXT');
 5478       %LSET INIT=CHARTEXT('INIT');
 5479       %ELSE;
 5480       %LSET INIT=CHARTEXT('/*');
 5481       %ENDIF;
 5482
 5483      DCL 1 FPTN STCLASS ALIGNED,
 5484            2 NSYSIDS UBIN WORD %INIT(0)%CHARTEXT('/**/'),
 5485                          /*K* NSYSIDS = VALUE-DEC. Indicates the number
 5486                          of SYSIDsreturned in FPTN.SYSIDS.                       */
 5487
 5488            2 SYSIDS(0:%(N-1)) UBIN HALF HALIGNED %INIT(0*0)%CHARTEXT('/**/');
 5489                          /*K* SYSIDS = VALUE-DEC. An array of currently
 5490                          running SYSIDs.                                         */
 5491      %MEND;
 5492
 5493      %MACRO SP_EQUS_C;
 5494      %EQU APL_IDS# = '000000000001'O; /* IDS-APL INTERFACE                       */
 5495      %EQU FORTRAN_IDS# = '000000000002'O; /* IDS-FORTRAN INTERFACE               */
 5496      %EQU BASIC_IDS# = '000000000004'O; /* IDS-BASIC INTERFACE                   */
 5497      %EQU IDP_IDS# = '000000000010'O; /* IDS-IDP INTERFACE                       */
 5498      %EQU SORT_IDS# = '000000000020'O; /* IDS-SORT INTERFACE                     */
 5499      %MEND;
 5500
 5501
 5502                                    /****************************/
 5503                                    /*    SYSTEM  CALLS                           */
 5504                                    /****************************/
 5505
 5506      DCL M$ERRMSG ENTRY(1) CONV(1,11,8192) ALTRET;
 5507      DCL M$HELP ENTRY(1) CONV(1,9,8212) ALTRET;
 5508      DCL M$FID ENTRY(1) CONV(1,10,8193) ALTRET;
 5509      DCL M$UNFID ENTRY(1) CONV(1,10,8209) ALTRET;
 5510      DCL M$OCMSG ENTRY(1) CONV(1,3,40961) ALTRET;
 5511      DCL M$PATHCON ENTRY(1) CONV(1,3,45056) ALTRET;
 5512      DCL M$EXHUME  ENTRY(1) CONV(1,3,45057) ALTRET;
 5513      DCL M$JOBSTATS ENTRY(1) CONV(1,12,61441) ALTRET;
07:33 JUL 29 '97 UM_CP6_C.:E05SI/UM_CP6_C.:E05TUI                          150  
 5514      DCL M$SYMBIO ENTRY(1) CONV(1,8,61440) ALTRET;
 5515      DCL M$GJOB ENTRY(1) CONV(1,6,8210) ALTRET;
 5516      DCL M$NXTUSR ENTRY(1) CONV(1,1,8197) ALTRET;
 5517      DCL M$RUE ENTRY(1) CONV(1,1,8208) ALTRET;
 5518      DCL M$ENQ ENTRY(1) CONV(1,3,8194) ALTRET;
 5519      DCL M$DEQ ENTRY(1) CONV(1,3,8195) ALTRET;
 5520      DCL M$TIME ENTRY(1) CONV(1,5,8196) ALTRET;
 5521      DCL   M$DISPLAY ENTRY(1) CONV(1,1,8199) ALTRET;
 5522      DCL   M$STATE ENTRY(1) CONV(1,2,8200) ALTRET;
 5523      DCL   M$XEQTIME ENTRY(1) CONV(1,1,8201) ALTRET;
 5524      DCL M$MONINFO ENTRY(1) CONV(1,6,8211) ALTRET;
 5525      DCL M$CMDVAR ENTRY(1) CONV(1,6,8213) ALTRET;
 5526      DCL M$SYSID ENTRY(1) CONV(1,2,8214) ALTRET;

