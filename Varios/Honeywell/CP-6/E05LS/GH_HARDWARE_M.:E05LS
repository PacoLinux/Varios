

14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      1    
    1      /*M* GH_HARDWARE_M - Macros for hardware instructions */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*P*    NAME:  GH_HARDWARE_M
    8              PURPOSE:  Provide data structures for calls to routines
    9                        to perform special hardware instructions.
   10              DESCRIPTION:
   11                 This module contains macros for data structures describing
   12              the single parameters to assembly language routines that
   13              issue hardware instructions that cannot be generated by PL-6
   14              such as IO and IOLD.  The macro name in each case is
   15              GH_instruction-name and the name of the assembly language
   16              routine is GHH$instruction-name.  For example, the macro that
   17              generates the data structure necessary to issue an IOLD
   18              instruction is GH_IOLD and the routine that issues an IOLD is
   19              GHH$IOLD.
   20                                                                         */
   21      /*F*    NAME:  GH_IO
   22              PURPOSE:  Generate FPT for IO instruction
   23                                                                         */
   24      %MACRO GH_IO (FPTN=GH_IO,
   25                    STCLASS=STATIC,ALGN=ALIGNED,
   26                    CHN=0,
   27                    FNC=0,
   28                    LCTADR=0,
   29                    LCTDAT=0);
   30      %LSET LISTDIR='0'B;
   31      %LSET LISTEXP='1'B;
   32      %LSET LISTCOM='0'B;
   33      %LSET LISTSUB='1'B;
   34      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
   35      %IF (SUBSTR(STR,0,6)='STATIC') OR
   36          (SUBSTR(STR,0,8)='CONSTANT') OR
   37          (SUBSTR(STR,0,3)='EXT');
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      2    
   38      %LSET INIT=CHARTEXT('INIT');
   39      %ELSE;
   40      %LSET INIT=CHARTEXT('/*');
   41      %ENDIF;
   42
   43      DCL 1 FPTN STCLASS ALIGNED,
   44            2 CAS,
   45              3 %CHARTEXT('CHN ')UBIN(10) UNAL %INIT(CHN)%CHARTEXT('/**/'),
   46
   47      /*K*  CHN = VALUE-DEC(0-1023)  Channel to issue IO instruction for.
   48            Referenced in structure as GH_IO.CAS.CHN.                   */
   49
   50              3 XCHN REDEF %CHARTEXT('CHN '),
   51                4 %CHARTEXT('CHN ') UBIN(9) UNAL,
   52                4 OUTPUT BIT(1),             /* SET FOR OUTPUT CHANNEL */
   53
   54              3 %CHARTEXT('FNC ')UBIN(6) UNAL %INIT(FNC)%CHARTEXT('/**/'),
   55
   56      /*K*  FNC = VALUE-DEC(0-63)  IO function code.  Referenced in
   57            structure as GH_IO.CAS.FNC.                                 */
   58
   59            2 DAS,
   60              3 %CHARTEXT('LCTDAT ')UBIN BYTE UNAL %INIT(LCTDAT)%CHARTEXT('/**/'),
   61
   62      /*K*  LCTDAT = VALUE-DEC(0-255)  Data value associated with INPUT/
   63            OUTPUT LCT byte IOs.  Referenced in structure as
   64            GH_IO.DAS.LCTDAT.  DAS is returned only on calls to GHH$IO_IN
   65                                                                         */
   66
   67              3 %CHARTEXT('LCTADR ')UBIN(8) UNAL %INIT(LCTADR)%CHARTEXT('/**/'),
   68
   69      /*K*  LCTADR = VALUE-DEC(0-63)  Address of LCT byte to be input or
   70            output.  Referenced in structure as GH_IO.DAS.LCTADR.       */
   71            2 RANGE REDEF DAS UBIN WORD,
   72            2 STATUS REDEF DAS BIT(16);
   73      %MEND;
   74
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      3    
   75
   76
   77      /*F*    NAME:  GH_IOLD
   78              PURPOSE:  Generate FPT for IOLD instruction.              */
   79      %MACRO GH_IOLD (FPTN=GH_IOLD,
   80                      STCLASS=STATIC,ALGN=ALIGNED,
   81                      CHN=0,
   82                      FNC=9,
   83                      BUF=NIL,
   84                      BYTX=0,
   85                      BUFSIZE=0);
   86
   87      %LSET LISTDIR='0'B;
   88      %LSET LISTEXP='1'B;
   89      %LSET LISTCOM='0'B;
   90      %LSET LISTSUB='1'B;
   91      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
   92      %IF (SUBSTR(STR,0,6)='STATIC') OR
   93          (SUBSTR(STR,0,8)='CONSTANT') OR
   94          (SUBSTR(STR,0,3)='EXT');
   95      %LSET INIT=CHARTEXT('INIT');
   96      %ELSE;
   97      %LSET INIT=CHARTEXT('/*');
   98      %ENDIF;
   99
  100      DCL 1 FPTN STCLASS ALGN,
  101            2 %CHARTEXT('CHN ')UBIN(10) UNAL %INIT(CHN)%CHARTEXT('/**/'),
  102
  103      /*K*  CHN = VALUE-DEC(0-1023)  Channel number for IOLD instruction. */
  104
  105            2 XCHN REDEF %CHARTEXT('CHN '),
  106              3 * UBIN(9) UNAL,
  107              3 OUTPUT BIT(1),               /* SET FOR OUTPUT CHANNEL */
  108
  109            2 %CHARTEXT('FNC ')UBIN(6) UNAL %INIT(FNC)%CHARTEXT('/**/'),
  110
  111      /*K*  FNC = VALUE-DEC(0-63)  Function code for IOLD instruction.     */
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      4    
  112
  113            2 BUF$ PTR %INIT(ADDR(BUF))%CHARTEXT('/**/'),
  114
  115      /*K*  BUF = PTR  Buffer pointer.                                     */
  116
  117            2 %CHARTEXT('BYTX ')UBIN WORD %INIT(BYTX)%CHARTEXT('/**/'),
  118
  119      /*K*  BYTX = VALUE-DEC(0-65535)  Byte offset from BUF$ to beginning of
  120            buffer.  This is in lieu of using a CPTR for BUF$.           */
  121
  122            2 %CHARTEXT('BUFSIZE ')UBIN WORD %INIT(BUFSIZE)%CHARTEXT('/**/');
  123
  124      /*K*  BUFSIZE = VALUE-DEC(0-65535)  Buffer range for IOLD instruction. */
  125
  126      %MEND;
  127
  128
  129
  130      /*F*    NAME:  GH_LEV
  131              PURPOSE:  Generate FPT for LEV instruction.
  132                                                                         */
  133      %MACRO GH_LEV (FPTN=GH_LEV,
  134                     STCLASS=STATIC,ALGN=ALIGNED,
  135                     TYPE(TRIGGER=0,
  136                          DEFER=256,
  137                          INHIBIT=2,
  138                          SUSPEND=1512,
  139                          ENABLE=1512,
  140                          SUSPEND_INHIBIT=514,
  141                          TRIGGER_SUSPEND=512)=0,
  142                     LEVEL=63);
  143
  144      %LSET LISTDIR='0'B;
  145      %LSET LISTEXP='1'B;
  146      %LSET LISTCOM='0'B;
  147      %LSET LISTSUB='1'B;
  148      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      5    
  149      %IF (SUBSTR(STR,0,6)='STATIC') OR
  150          (SUBSTR(STR,0,8)='CONSTANT') OR
  151          (SUBSTR(STR,0,3)='EXT');
  152      %LSET INIT=CHARTEXT('INIT');
  153      %ELSE;
  154      %LSET INIT=CHARTEXT('/*');
  155      %ENDIF;
  156
  157      %IF (TYPE=1512);       /* BOGUS TYPE FOR SUSPEND */
  158      %LSET TYP=512;
  159      %LSET INTLV=63;
  160      %ERROR (%(LEVEL~=63),'LEVEL may not be specified for ENABLE or SUSPEND',4);
  161      %ELSE;
  162      %LSET TYP=TYPE;
  163      %LSET INTLV=LEVEL;
  164      %ENDIF;
  165
  166      DCL 1 FPTN STCLASS ALGN,
  167            2 %CHARTEXT('TYPE ')UBIN(10) UNAL %INIT(%TYP)%CHARTEXT('/**/'),
  168
  169      /*K*  TYPE = TRIGGER|DEFER|INHIBIT|SUSPEND|SUSPEND_INHIBIT|
  170            TRIGGER_SUSPEND  Determines which type of LEV instruction
  171            to issue.  The default is TRIGGER.  The options and their
  172            correspondence to the different forms of the LEV instruction
  173            are:
  174                TRIGGER - Schedule Interrupt Level, Scan, and Dispatch.
  175                DEFER - Schedule Interrupt Level, Defer Interrupt.
  176                INHIBIT - Inhibit.
  177                SUSPEND - Suspend, Scan, and Dispatch.
  178                ENABLE - Suspend, Scan and Dispatch.
  179                SUSPEND_INHIBIT - Suspend, Inhibit.
  180                TRIGGER_SUSPEND - Schedule Interrupt Level, Suspend,
  181                                  Scan, and Dispatch.
  182                                                                         */
  183            2 %CHARTEXT('LEVEL ')UBIN(6) UNAL %INIT(%INTLV)%CHARTEXT('/**/');
  184
  185      /*K*  LEVEL = VALUE-DEC(0-63)  Interrupt level to be set.  LEVEL is
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      6    
  186            forced to 63 if TYPE=SUSPEND.                                */
  187
  188      %MEND;
  189      /*F*    NAME:  GH_CPLDCW
  190              PURPOSE:  Generate coupler DCW.  For more information on the
  191              parameters to this macro see the EPS-1 for the L6/L66 Coupler  */
  192      %MACRO GH_CPLDCW (FPTN=GH_CPLDCW,
  193                        STCLASS="",ALGN=ALIGNED,LVL=1,
  194                        LAST(YES=";",NO=",",ANY)=";",
  195                        OC=0,
  196                        MODE=0,
  197                        TALLY=0,
  198                        CN=0,
  199                        A66=0,
  200                        BN=0,
  201                        A6=0);
  202      %LSET LISTDIR='0'B;
  203      %LSET LISTEXP='1'B;
  204      %LSET LISTCOM='0'B;
  205      %LSET LISTSUB='1'B;
  206      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  207      %IF (SUBSTR(STR,0,6)='STATIC') OR
  208          (SUBSTR(STR,0,8)='CONSTANT') OR
  209          (SUBSTR(STR,0,3)='EXT');
  210      %LSET INIT=CHARTEXT('INIT');
  211      %ELSE;
  212      %LSET INIT=CHARTEXT('/*');
  213      %ENDIF;
  214
  215      %IF (LVL=1);
  216      DCL 1 FPTN STCLASS ALGN,
  217      %ELSE;
  218            LVL FPTN ALGN,
  219      %ENDIF;
  220              %(LVL+1) %CHARTEXT('OC ')UBIN BYTE UNAL %INIT(OC)%CHARTEXT('/**/'),
  221      /*K*  OC = VALUE-DEC(0-255)  Order Code.                           */
  222              %(LVL+1) %CHARTEXT('MODE ')UBIN BYTE UNAL %INIT(MODE)%CHARTEXT('/**/'),
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      7    
  223      /*K*  MODE = VALUE-DEC(0-255)  Transfer mode.                      */
  224              %(LVL+1) %CHARTEXT('TALLY ')UBIN WORD UNAL %INIT(TALLY)%CHARTEXT('/**/'),
  225      /*K*  TALLY = VALUE-DEC(0-65535)  Bytes or words to transfer
  226            (depends on mode.)                                           */
  227              %(LVL+1) * UBIN(6) UNAL %INIT(0)%CHARTEXT('/**/'),
  228              %(LVL+1) %CHARTEXT('CN ')UBIN(2) UNAL %INIT(CN)%CHARTEXT('/**/'),
  229      /*K*  CN = VALUE-DEC(0-3)  Character number (L66).                 */
  230              %(LVL+1) %CHARTEXT('A66 ')UBIN(24) UNAL %INIT(A66)%CHARTEXT('/**/'),
  231      /*K*  A66 = VALUE-DEC  L66 address.                                */
  232              %(LVL+1) * UBIN(7) UNAL %INIT(0)%CHARTEXT('/**/'),
  233              %(LVL+1) %CHARTEXT('BN ')UBIN(1) UNAL %INIT(BN)%CHARTEXT('/**/'),
  234      /*K*  BN = VALUE-DEC(0-1)  Byte number (L6).                       */
  235              %(LVL+1) * UBIN(1) UNAL %INIT(0)%CHARTEXT('/**/'),
  236              %(LVL+1) %CHARTEXT('A6 ')UBIN(23) UNAL %INIT(A6)%CHARTEXT('/**/')
  237      /*K*  A6 = VALUE-DEC  L6 address.                                  */
  238              LAST
  239      %MEND;
  240      /*F*    NAME:  GH_VLD
  241              PURPOSE:  Generate FPT for VLD instructions
  242                                                                         */
  243      %MACRO GH_VLD (FPTN=GH_VLD,
  244                    STCLASS=STATIC,ALGN=ALIGNED,
  245                    ADR=NIL,
  246                    RANGE=0,
  247                    RING=0,
  248                    STATUS=0);
  249      %LSET LISTDIR='0'B;
  250      %LSET LISTEXP='1'B;
  251      %LSET LISTCOM='0'B;
  252      %LSET LISTSUB='1'B;
  253      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  254      %IF (SUBSTR(STR,0,6)='STATIC') OR
  255          (SUBSTR(STR,0,8)='CONSTANT') OR
  256          (SUBSTR(STR,0,3)='EXT');
  257      %LSET INIT=CHARTEXT('INIT');
  258      %ELSE;
  259      %LSET INIT=CHARTEXT('/*');
14:34 JUL 28 '97 GH_HARDWARE_M.:E05SI                                      8    
  260      %ENDIF;
  261
  262      DCL 1 FPTN STCLASS ALIGNED,
  263            2 %CHARTEXT('ADR$ ') PTR %INIT(ADDR(ADR))%CHARTEXT('/**/'),
  264      /*K*  ADR = PTR Address to be checked.  Referenced in structure as
  265            GH_VLD.ADR
  266                                                                                    */
  267            2 %CHARTEXT('RANGE ')UBIN %INIT(RANGE)%CHARTEXT('/**/'),
  268      /*K*  RANGE = VALUE-DEC (>0) Number of bytes beyond base ADR to be
  269            validated.  Referenced in structure as GH_VLD.RANGE
  270                                                                                    */
  271            2 %CHARTEXT('RING ')UBIN UNAL %INIT(RING)%CHARTEXT('/**/'),
  272      /*K*  RING = VALUE-DEC (0-3) The ring being operated in.  Referenced
  273            in structure as GH_VLD.RING
  274                                                                                    */
  275            2 %CHARTEXT('STATUS ')SBIN UNAL;
  276      /*K*  STATUS = VALUE-DEC (-1,0,+2,-2).  This cell contains the result of
  277            the validate instruction as follows:
  278            -1 = Invalid address
  279             0 = Read permitted, not write
  280             2 = Read/Write permitted
  281            -2 = No read permitted
  282            Referenced in structure as GH_VLD.STATUS
  283                                                                                    */
  284      %MEND;

