VERSION E05

PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:1    
        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMR */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine reads command input and returns the output
       26       26                blocks generated by X$PARSE from the command read.  As
       27       27                command input is read it is echoed if either the input or
       28       28                output DCB is not assigned to an 'IC' type device.  The
       29       29                default input DCB is M$SI and the default output DCB is M$ME.
       30       30                These defaults may be changed with a call to XUR$SETDCBS.
       31       31                   Commands may be continued by ending a command line with a
       32       32                semicolon.  If commands are being read from other than an 'IC'
       33       33                device and the command input begins with the prompt string
       34       34                then the prompt string will be deleted from the input before
       35       35                it is passed to the parser.
       36       36                   There is a flag, SYNTAX which
       37       37                if set (by default) enables special syntax error processing.
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:2    
       38       38                If the flag is set when a syntax error occurs one of two
       39       39                things may happen.  If the character that caused the syntax
       40       40                to fail was a '?' then a list of possible syntax alternatives
       41       41                at the point of the syntax error will be printed through M$DO.
       42       42                Otherwise if the next input consists of the single character
       43       43                '?' then a list of syntax alternatives at the point of the
       44       44                previous syntax error is printed through M$DO.  If the flag
       45       45                is set then syntax errors will return the error code
       46       46                XUR-E$SYNERR-0 instead of XUP-E$SYNERR-0.
       47       47
       48       48                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       49       49                      the routines documented here.
       50       50                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       51       51                      which allows one to specify SYNTAX, as well as EPTR's for
       52       52                      routines for command abort (ABORT), command continue (CONTINUE),
       53       53                      special break message (BRKMSG), and/or a vector (WORK_) framing
       54       54                      a block of memory (even # of doublewords >= 500 words in size)
       55       55                      which XUR$GETCMD is to use for its parse control block, input
       56       56                      command buffer, and X$PARSE work area.  If break control is to be
       57       57                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       58       58                                                                           */
       59       59        /*D*    NAME: XUR$SETDCBS
       60       60                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB);
       61       61                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       62       62                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       63       63                DESCRIPTION:
       64       64                   This routine changes the input and output DCBs.  Either
       65       65                argument may be omitted if that DCB is not to be changed.
       66       66                                                                           */
       67       67        /*D*    NAME: XUR$INIT
       68       68                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       69       69                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       70       70                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       71       71                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       72       72                DESCRIPTION:
       73       73                    This routine may be called to initialize various aspects of XUR$GETCMD.
       74       74                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:3    
       75       75                flag may be set or reset;  the WORK_ vector may be used to require
       76       76                XUR$GETCMD to use a specific block of memory rather than acquiring a
       77       77                data segment for its own use; and the PCB$ pointer may be set to
       78       78                indicate that XUR$GETCMD is to use a user-provided parse control block
       79       79                in its calls to X$PARSE rather than constructing a PCB of its own in
       80       80                the work area.
       81       81                P_PCB$, if present, will receive the address of the PCB actually used
       82       82                (whether user-provided or built in the work area by XUR$INIT).
       83       83                PARAM$ will receive the PTR to the PARAM block (optional).
       84       84                An ABORT routine must be supplied if XUR$BREAK is used.
       85       85                XUR$INIT may be called more than once, if desired;  the settings of
       86       86                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       87       87                updated on each call;  the PCB$ pointer will be honored on each call
       88       88                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       89       89                set to the actual PCB address used.  The WORK_ vector will be honored
       90       90                only on the first call to XUR$INIT and only of XUR$INIT is called before
       91       91                the first call to XUR$GETCMD.  Other information (current error message,
       92       92                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
       93       93                but the other information (ERRMSG,etc.) will be remembered.
       94       94                                                                           */
       95       95        /*D*    NAME: XUR$ERRPTR
       96       96                CALL: XUR$ERRPTR(CPOS,OUTDCB);
       97       97                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
       98       98                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
       99       99                                OUT$BLK.CPOS.
      100      100                         OUTDCB - DCB TO OUTPUT THROUGH.
      101      101                DESCRIPTION:
      102      102                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      103      103                if CPOS is within the last line of the command a '^' is
      104      104                printed under the character at CPOS.  Otherwise fifteen characters
      105      105                on either side of CPOS are printed through OUTDCB and a '^' is
      106      106                printed under the offending character.  The CPOS argument
      107      107                may be omitted in which case P_PCB.HI_CHAR is used.
      108      108                                                                           */
      109      109        /*D*    NAME: XUR$ECHO
      110      110                CALL: CALL XUR$ECHO(OUTDCB);
      111      111                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:4    
      112      112                DESCRIPTION:
      113      113                   Writes the last command through OUTDCB.
      114      114                                                                           */
      115      115        /*D*    NAME: XUR$ECHOIF
      116      116                CALL: CALL XUR$ECHOIF(OUTDCB);
      117      117                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      118      118                DESCRIPTION:
      119      119                   If the last command has not already been written to
      120      120                the place to which OUTDCB is assigned the last command is
      121      121                written through OUTDCB.
      122      122                                                                           */
      123      123        /*D*    NAME: XUR$ECHOLAST
      124      124                CALL: CALL XUR$ECHOLAST(OUTDCB);
      125      125                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      126      126                DESCRIPTION:
      127      127                   Echos the last input line through OUTDCB.
      128      128                                                                           */
      129      129        /*D*    NAME: XUR$CORRES
      130      130                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      131      131                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      132      132                DESCRIPTION:
      133      133                   A default open is done on the DCBs if they are not open
      134      134                and the ALTRETURN is taken if the assignments of the DCBs
      135      135                correspond.
      136      136                                                                           */
      137      137        /*D*    NAME: XUR$BREAK
      138      138                CALL: ASYNC ENTRY ON BREAK
      139      139                DESCRIPTION:
      140      140                   XUR$BREAK is a generalized break handler for programs that
      141      141                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
      142      142                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      143      143                the message "Break!  C to continue" is output.  (Breaks are
      144      144                ignored from the time XUR$BREAK is entered until it exits.)
      145      145                Then input is read through M$UC.  A null input will cause the
      146      146                current command to be aborted.  The single character 'C' or 'c'
      147      147                will cause the current command to be continued.  Any other
      148      148                input will be parsed as a new command on the next call to
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:5    
      149      149                XUR$GETCMD.
      150      150
      151      151                If it is desireable to exit from the BREAK process without printing
      152      152                the "Break!  C to continue" message and inputing a response, the user
      153      153                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      154      154                a call to X66_TRTN;  this call will release the auto frame(s) for
      155      155                XUR$BREAK and the BRKMSG routine, and will then return control to the
      156      156                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      157      157                desirable to continue at the point of interruption with breaks enabled,
      158      158                XUR$CLRENABLE should be called before X66_TRTN.
      159      159
      160      160                XUR$BREAK is to be establised as the break routine by the user
      161      161                with an M$INT call.  The routine pointed to by XUR_ABORT is
      162      162                called to abort the current command after doing an M$CLRSTK.
      163      163                This routine must be present and should not return.  An optional
      164      164                routine pointed to by XUR_CONTINUE is called to continue
      165      165                commands.  If this routine returns or is not present an M$TRTN
      166      166                will be executed.
      167      167
      168      168                Breaks are ignored if input while reading a command.
      169      169                                                                           */
      170      170        /*D*    NAME: XUR$DISABLE
      171      171                CALL: CALL XUR$DISABLE
      172      172                DESCRIPTION:
      173      173                   Disables breaks for critical code.  Calls to XUR$DISABLE
      174      174                may be nested.
      175      175                                                                           */
      176      176        /*D*    NAME: XUR$ENABLE
      177      177                CALL: CALL XUR$ENABLE
      178      178                DESCRIPTION:
      179      179                   Counterpart to XUR$DISABLE.  If a break occured during
      180      180                disabled execution,  it will be processed at enable time.
      181      181                                                                           */
      182      182        /*D*    NAME: XUR$CLRENABLE
      183      183                CALL: CALL XUR$CLRENABLE
      184      184                DESCRIPTION:
      185      185                   Just like XUR$ENABLE except any breaks that occured while
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:6    
      186      186                disabled will be ignored.
      187      187                                                                           */
      188      188        /*D*    NAME: XUR$ERRMSG
      189      189                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      190      190                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      191      191                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      192      192                                CODE IS INCREMENTED.  IN THIS CASE THE
      193      193                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      194      194                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      195      195                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      196      196                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      197      197                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      198      198                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      199      199                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      200      200                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      201      201                         FLGLEV - Number of asterisks to print in front of the
      202      202                                  message (0-4).  Default is 0.
      203      203                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      204      204                DESCRIPTION:
      205      205                   A call is made to M$ERRMSG using the parameters passed by
      206      206                the caller.
      207      207                                                                           */
      208      208        /*D*    NAME: XUR$SETERRMSG
      209      209                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      210      210                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      211      211                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      212      212                DESCRIPTION:
      213      213                   If the FID argument is passed then M$FID is called to
      214      214                obtain the name, account and password of the error message
      215      215                file to be used on subsequent calls to XUR$ERRMSG.  If the
      216      216                FID argument is omitted then the M$ERRMSG default file will
      217      217                be used.  If the altreturn is taken then M$FID altreted and
      218      218                the error code may be found in the altret frame.
      219      219                                                                           */
      220      220        /*D*    NAME: XUR$HELP
      221      221                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
      222      222                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:7    
      223      223                DESCRIPTION:
      224      224                   This routine calls X$HELP.  The purpose of XUR$HELP is
      225      225                to keep track of whether the last message operation was
      226      226                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      227      227                will call XUR$ERRMSG with the error code in XUH_PARAM and
      228      228                then altreturn.  Otherwise the normal return will be taken.
      229      229                                                                           */
      230      230        /*D*    NAME: XUR$MOREMSG
      231      231                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      232      232                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      233      233                DESCRIPTION:
      234      234                   XUR$ERRMSG or X$HELP is called to get the next level of
      235      235                messages.  Trust me.  The altreturn is taken if no messages
      236      236                are available.
      237      237                                                                           */
      238      238        /*D*    NAME: XUR$ALLMSG
      239      239                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      240      240                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      241      241                DESCRIPTION:
      242      242                   XUR$ERRMSG or X$HELP is called to get all remaining
      243      243                messages.  Trust me.  The altreturn is taken if no messages
      244      244                are available.
      245      245                                                                           */
      246      246        /*D*    NAME: XUR$FINDDCB
      247      247                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      248      248                INPUT:   DCBNAME - TEXTC DCB NAME
      249      249                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      250      250                DESCRIPTION:
      251      251                   Searches DCB table for DCB specified by DCBNAME.  If it
      252      252                is found, DCB number is returned in DCB#.  If not present
      253      253                the altreturn will be taken.
      254      254                                                                           */
      255      255        /*D*    NAME: XUR$GETDCB
      256      256                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      257      257                INPUT:   DCBNAME - TEXTC DCB NAME
      258      258                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      259      259                DESCRIPTION:
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:8    
      260      260                   Searches DCB table for DCB specified by DCBNAME.  If it
      261      261                is found, DCB number is returned in DCB#.  If not present
      262      262                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      263      263                then XUR$GETDCB will altreturn and the error code may be
      264      264                found in the altret frame.
      265      265                                                                           */
      266      266        /*D*    NAME: XUR$CLOSE_DCBS;
      267      267                CALL: CALL XUR$CLOSE_DCBS;
      268      268                DESCRIPTION:
      269      269                   Closes all open dcbs with SAVE.
      270      270                                                                           */
      271      271        /*D*     NAME: XUR$ERRCNVRT
      272      272                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      273      273                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      274      274                       passed through the coupler.
      275      275                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      276      276                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      277      277                             stored in 36 bits with the high-order bit in each byte
      278      278                             being zero) into the equivalent CP-6 standard error code
      279      279                             format (36 bits).
      280      280        */
      281      281
      282      282        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:9    
      283      283        XUG$INIT: PROC (GETCMD, XUG_INIT) ALTRET;
      284      284        /**/
      285      285        %INCLUDE XU_MACRO_C ;
      286     3391
      287     3392        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      288     3730        %XUG_INIT (NAME=XUG_INIT, STCLASS=PARAM) ;
      289     4143        /**/
      290     4144    1   DCL XUG$INIT_COMMON ENTRY(2) ALTRET ;
      291     4145    1   DCL XUG$GETCMD_COMMON ENTRY(1) ALTRET ;
      292     4146    1   DCL XUG$ERRPTR_COMMON ENTRY(1) ALTRET ;
      293     4147    1   DCL XUG$ECHOIF_COMMON ENTRY(1) ALTRET ;
      294     4148    1   DCL XUG$ECHO_COMMON ENTRY(1) ALTRET ;
      295     4149    1   DCL XUG_WORK$ PTR STATIC SYMDEF ;
      296     4150
      297     4151    1           CALL XUG$INIT_COMMON(GETCMD, XUG_INIT) ALTRET(MALT) ;
      298     4152    1           XUG_WORK$ = GETCMD.WORK$ ;
      299     4153    1           RETURN;
      300     4154        %EJECT ;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:10   
      301     4155    1   XUG$GETCMD: ENTRY(GETCMD) ALTRET;
      302     4156    1   GETCMD:
      303     4157    1           CALL XUG$GETCMD_COMMON (GETCMD) ALTRET(MALT) ;
      304     4158    1           RETURN;
      305     4159        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:11   
      306     4160    1   XUG$ERRPTR: ENTRY(GETCMD) ALTRET;
      307     4161        /**/
      308     4162    1           CALL XUG$ERRPTR_COMMON (GETCMD) ALTRET(MALT) ;
      309     4163    1           RETURN;
      310     4164        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:12   
      311     4165    1   XUG$ECHOIF: ENTRY(GETCMD) ALTRET;
      312     4166    1           CALL XUG$ECHOIF_COMMON(GETCMD) ALTRET(MALT) ;
      313     4167    1           RETURN ;
      314     4168    1   XUG$ECHO: ENTRY(GETCMD) ALTRET;
      315     4169    1           CALL XUG$ECHO_COMMON(GETCMD) ALTRET(MALT) ;
      316     4170    1           RETURN;
      317     4171    1   MALT:   ALTRETURN ;
      318     4172        /**/
      319     4173    1   END XUG$INIT;
      320     4174        %EOD;

PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:13   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$INIT.

   Procedure XUG$INIT requires 39 words for executable code.
   Procedure XUG$INIT requires 6 words of local(AUTO) storage.

PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:14   

 Object Unit name= XUG$INIT                                   File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:17:52.64 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Data  even  none     1      1  XUG$INIT
    1   Proc  even  none    39     47  XUG$INIT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     1      0   yes    yes     yes      Std        2  XUG$INIT
     1     12          yes     yes      Std        1  XUG$GETCMD
     1     21          yes     yes      Std        1  XUG$ERRPTR
     1     30          yes     yes      Std        1  XUG$ECHOIF
     1     37          yes     yes      Std        1  XUG$ECHO

  ****  Data defs  ****

 Sect OctLoc  Name                           Sect OctLoc  Name
    0      0  XUG_WORK$
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:15   

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$INIT_COMMON
 yes     yes           Std       1 XUG$GETCMD_COMMON
 yes     yes           Std       1 XUG$ERRPTR_COMMON
 yes     yes           Std       1 XUG$ECHOIF_COMMON
 yes     yes           Std       1 XUG$ECHO_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:16   


        1        1        /*M* XUR$GETCMD - COMMAND READING AND ERROR REPORTING ROUTINES */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMR */
        8        8        /**/
        9        9        /*D*    NAME: XUR$GETCMD
       10       10                CALL: CALL XUR$GETCMD(NODES,OUT$,PROMPT,TXT,TSIZ,ROUTINE) ALTRET;
       11       11                INPUT:   NODES - INPUT NODES FOR X$PARSE
       12       12                         OUT$ - CELL INTO WHICH P_PCB.OUT$ IS STORED OR ERROR
       13       13                                CODE IN CASE OF ALTRET.
       14       14                         PROMPT - VECTOR FRAMING PROMPT STRING OR TEXTC PROMPT
       15       15                                  STRING.  IF TEXTC PROMPT STRING THEN BIT 0
       16       16                                  OF THE LENGTH MAY BE SET TO INDICATE THE FIRST
       17       17                                  CHARACTER OF THE PROMPT STRING IS VFC.
       18       18                         TXT - TEXT STRING TO BE USED AS FIRST LINE OF INPUT TO
       19       19                               PARSER.  MAY BE USED IF IT IS DESIRED TO PARSE
       20       20                               JIT.CCBUF FOR EXAMPLE.  (OPTIONAL)
       21       21                         TSIZ - SIZE OF TXT IN CHARACTERS.  IF OMITTED USE P_PCB.NCHARS.
       22       22                         ROUTINE - EPTR TO ROUTINE TO BE CALLED FOR SUCCESS AND
       23       23                                   FAILURE NODES.  (OPTIONAL)
       24       24                DESCRIPTION:
       25       25                   This routine reads command input and returns the output
       26       26                blocks generated by X$PARSE from the command read.  As
       27       27                command input is read it is echoed if either the input or
       28       28                output DCB is not assigned to an 'IC' type device.  The
       29       29                default input DCB is M$SI and the default output DCB is M$ME.
       30       30                These defaults may be changed with a call to XUR$SETDCBS.
       31       31                   Commands may be continued by ending a command line with a
       32       32                semicolon.  If commands are being read from other than an 'IC'
       33       33                device and the command input begins with the prompt string
       34       34                then the prompt string will be deleted from the input before
       35       35                it is passed to the parser.
       36       36                   There is a flag, SYNTAX which
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:17   
       37       37                if set (by default) enables special syntax error processing.
       38       38                If the flag is set when a syntax error occurs one of two
       39       39                things may happen.  If the character that caused the syntax
       40       40                to fail was a '?' then a list of possible syntax alternatives
       41       41                at the point of the syntax error will be printed through M$DO.
       42       42                Otherwise if the next input consists of the single character
       43       43                '?' then a list of syntax alternatives at the point of the
       44       44                previous syntax error is printed through M$DO.  If the flag
       45       45                is set then syntax errors will return the error code
       46       46                XUR-E$SYNERR-0 instead of XUP-E$SYNERR-0.
       47       47
       48       48                NOTE: The include file XUR_ENTRY contains ENTRY DCLs for all
       49       49                      the routines documented here.
       50       50                NOTE: The include file XU_MACRO_C contains a macro, XUR_INIT,
       51       51                      which allows one to specify SYNTAX, as well as EPTR's for
       52       52                      routines for command abort (ABORT), command continue (CONTINUE),
       53       53                      special break message (BRKMSG), and/or a vector (WORK_) framing
       54       54                      a block of memory (even # of doublewords >= 500 words in size)
       55       55                      which XUR$GETCMD is to use for its parse control block, input
       56       56                      command buffer, and X$PARSE work area.  If break control is to be
       57       57                      given to XUR$BREAK, an ABORT EPTR *must* be specified.
       58       58                                                                           */
       59       59        /*D*    NAME: XUR$SETDCBS
       60       60                CALL: CALL XUR$SETDCBS(INDCB,OUTDCB);
       61       61                INPUT:   INDCB - DCB NUMBER OF INPUT DCB.
       62       62                         OUTDCB - DCB NUMBER OF OUTPUT DCB.
       63       63                DESCRIPTION:
       64       64                   This routine changes the input and output DCBs.  Either
       65       65                argument may be omitted if that DCB is not to be changed.
       66       66                                                                           */
       67       67        /*D*    NAME: XUR$INIT
       68       68                CALL: CALL XUR$INIT(XUR_INIT , P_PCB$ , PARAM$ ) ALTRET;
       69       69                INPUT:   XUR_INIT - THE STRUCTURE XUR_INIT TO INIT VARIOUS THINGS.
       70       70                OUTPUT:  P_PCB$ - PTR TO THE PARSE CONTROL BLOCK (OPTIONAL).
       71       71                          PARAM$ - PTR TO THE PARAMETER BLOCK.
       72       72                DESCRIPTION:
       73       73                    This routine may be called to initialize various aspects of XUR$GETCMD.
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:18   
       74       74                EPTR's may be specified for ABORT, CONTINUE, and BRKMSG;  the SYNTAX
       75       75                flag may be set or reset;  the WORK_ vector may be used to require
       76       76                XUR$GETCMD to use a specific block of memory rather than acquiring a
       77       77                data segment for its own use; and the PCB$ pointer may be set to
       78       78                indicate that XUR$GETCMD is to use a user-provided parse control block
       79       79                in its calls to X$PARSE rather than constructing a PCB of its own in
       80       80                the work area.
       81       81                P_PCB$, if present, will receive the address of the PCB actually used
       82       82                (whether user-provided or built in the work area by XUR$INIT).
       83       83                PARAM$ will receive the PTR to the PARAM block (optional).
       84       84                An ABORT routine must be supplied if XUR$BREAK is used.
       85       85                XUR$INIT may be called more than once, if desired;  the settings of
       86       86                the ABORT, CONTINUE, and BRKMSG EPTR's and the SYNTAX flag will be
       87       87                updated on each call;  the PCB$ pointer will be honored on each call
       88       88                (whether NIL or non-NIL) and the P_PCB$ pointer, if present, will be
       89       89                set to the actual PCB address used.  The WORK_ vector will be honored
       90       90                only on the first call to XUR$INIT and only of XUR$INIT is called before
       91       91                the first call to XUR$GETCMD.  Other information (current error message,
       92       92                DCB identifies, etc.) will not be affected by calls to XUR$INIT.
       93       93                but the other information (ERRMSG,etc.) will be remembered.
       94       94                                                                           */
       95       95        /*D*    NAME: XUR$ERRPTR
       96       96                CALL: XUR$ERRPTR(CPOS,OUTDCB);
       97       97                INPUT:   CPOS - CHARACTER POSTITION AT WHICH ERROR OCCURED.
       98       98                                MOST LIKELY OBTAINED FROM P_PCB.HI_CHAR OR
       99       99                                OUT$BLK.CPOS.
      100      100                         OUTDCB - DCB TO OUTPUT THROUGH.
      101      101                DESCRIPTION:
      102      102                   XUR$ECHOIF is called with OUTDCB as the parameter.  Then,
      103      103                if CPOS is within the last line of the command a '^' is
      104      104                printed under the character at CPOS.  Otherwise fifteen characters
      105      105                on either side of CPOS are printed through OUTDCB and a '^' is
      106      106                printed under the offending character.  The CPOS argument
      107      107                may be omitted in which case P_PCB.HI_CHAR is used.
      108      108                                                                           */
      109      109        /*D*    NAME: XUR$ECHO
      110      110                CALL: CALL XUR$ECHO(OUTDCB);
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:19   
      111      111                INPUT:   OUTDCB - OUTPUT DCB NUMBER.
      112      112                DESCRIPTION:
      113      113                   Writes the last command through OUTDCB.
      114      114                                                                           */
      115      115        /*D*    NAME: XUR$ECHOIF
      116      116                CALL: CALL XUR$ECHOIF(OUTDCB);
      117      117                INPUT:   OUTDCB - DCB NUMBER OF OUTPUT DCB.
      118      118                DESCRIPTION:
      119      119                   If the last command has not already been written to
      120      120                the place to which OUTDCB is assigned the last command is
      121      121                written through OUTDCB.
      122      122                                                                           */
      123      123        /*D*    NAME: XUR$ECHOLAST
      124      124                CALL: CALL XUR$ECHOLAST(OUTDCB);
      125      125                INPUT:   OUTDCB - DCB TO OUTPUT THROUGH
      126      126                DESCRIPTION:
      127      127                   Echos the last input line through OUTDCB.
      128      128                                                                           */
      129      129        /*D*    NAME: XUR$CORRES
      130      130                CALL: XUR$CORRES(DCB1,DCB2) ALTRET;
      131      131                INPUT:   DCB1 AND DCB2 ARE DCB NUMBERS.
      132      132                DESCRIPTION:
      133      133                   A default open is done on the DCBs if they are not open
      134      134                and the ALTRETURN is taken if the assignments of the DCBs
      135      135                correspond.
      136      136                                                                           */
      137      137        /*D*    NAME: XUR$BREAK
      138      138                CALL: ASYNC ENTRY ON BREAK
      139      139                DESCRIPTION:
      140      140                   XUR$BREAK is a generalized break handler for programs that
      141      141                use XUR$GETCMD.  When XUR$BREAK is entered the user routine
      142      142                pointed to by XUR_BRKMSG is called if it is not NIL,  otherwise
      143      143                the message "Break!  C to continue" is output.  (Breaks are
      144      144                ignored from the time XUR$BREAK is entered until it exits.)
      145      145                Then input is read through M$UC.  A null input will cause the
      146      146                current command to be aborted.  The single character 'C' or 'c'
      147      147                will cause the current command to be continued.  Any other
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:20   
      148      148                input will be parsed as a new command on the next call to
      149      149                XUR$GETCMD.
      150      150
      151      151                If it is desireable to exit from the BREAK process without printing
      152      152                the "Break!  C to continue" message and inputing a response, the user
      153      153                of XUR$BREAK may opt to "bail out" from his BRKMSG routine by issuing
      154      154                a call to X66_TRTN;  this call will release the auto frame(s) for
      155      155                XUR$BREAK and the BRKMSG routine, and will then return control to the
      156      156                interrupted code with breaks disabled (a la XUR$DISABLE).  If it is
      157      157                desirable to continue at the point of interruption with breaks enabled,
      158      158                XUR$CLRENABLE should be called before X66_TRTN.
      159      159
      160      160                XUR$BREAK is to be establised as the break routine by the user
      161      161                with an M$INT call.  The routine pointed to by XUR_ABORT is
      162      162                called to abort the current command after doing an M$CLRSTK.
      163      163                This routine must be present and should not return.  An optional
      164      164                routine pointed to by XUR_CONTINUE is called to continue
      165      165                commands.  If this routine returns or is not present an M$TRTN
      166      166                will be executed.
      167      167
      168      168                Breaks are ignored if input while reading a command.
      169      169                                                                           */
      170      170        /*D*    NAME: XUR$DISABLE
      171      171                CALL: CALL XUR$DISABLE
      172      172                DESCRIPTION:
      173      173                   Disables breaks for critical code.  Calls to XUR$DISABLE
      174      174                may be nested.
      175      175                                                                           */
      176      176        /*D*    NAME: XUR$ENABLE
      177      177                CALL: CALL XUR$ENABLE
      178      178                DESCRIPTION:
      179      179                   Counterpart to XUR$DISABLE.  If a break occured during
      180      180                disabled execution,  it will be processed at enable time.
      181      181                                                                           */
      182      182        /*D*    NAME: XUR$CLRENABLE
      183      183                CALL: CALL XUR$CLRENABLE
      184      184                DESCRIPTION:
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:21   
      185      185                   Just like XUR$ENABLE except any breaks that occured while
      186      186                disabled will be ignored.
      187      187                                                                           */
      188      188        /*D*    NAME: XUR$ERRMSG
      189      189                CALL: CALL XUR$ERRMSG(CODE,DCB#,OUTDCB,F1,F2,F3,FLGLEV) ALTRET;
      190      190                INPUT:   CODE - ERROR CODE.  (OPTIONAL.  IF THIS ARGUMENT
      191      191                                IS OMITTED THE SEVERITY FIELD OF THE LAST
      192      192                                CODE IS INCREMENTED.  IN THIS CASE THE
      193      193                                ALTRETURN IS TAKEN IF THE SEVERITY FIELD
      194      194                                EXCEEDS 7 OR NO MESSAGE IS FOUND.)
      195      195                         DCB# - DCB ON WHICH ERROR OCCURED. (OPTIONAL)
      196      196                         OUTDCB - DCB THAT ERROR MESSEAGE IS TO BE WRITTEN
      197      197                                  THROUGH.  (OPTIONAL.  DEFAULT IS M$DO.)
      198      198                         F1 - VECTOR FRAMING TEXTC TO BE USED FOR %U1 SUBSTITUTION.
      199      199                         F2 - VECTOR FRAMING TEXTC TO BE USED FOR %U2 SUBSTITUTION.
      200      200                         F3 - VECTOR FRAMING TEXTC TO BE USED FOR %U3 SUBSTITUTION.
      201      201                         FLGLEV - Number of asterisks to print in front of the
      202      202                                  message (0-4).  Default is 0.
      203      203                         F1, F2, F3 AND FLGLEV ARE OPTIONAL.
      204      204                DESCRIPTION:
      205      205                   A call is made to M$ERRMSG using the parameters passed by
      206      206                the caller.
      207      207                                                                           */
      208      208        /*D*    NAME: XUR$SETERRMSG
      209      209                CALL: CALL XUR$SETERRMSG(FID) ALTRET;
      210      210                INPUT:   FID - TEXTC FID OF ERROR MESSAGE FILE TO BE USED
      211      211                               ON SUBSEQUENT CALLS TO XUR$ERRMSG.
      212      212                DESCRIPTION:
      213      213                   If the FID argument is passed then M$FID is called to
      214      214                obtain the name, account and password of the error message
      215      215                file to be used on subsequent calls to XUR$ERRMSG.  If the
      216      216                FID argument is omitted then the M$ERRMSG default file will
      217      217                be used.  If the altreturn is taken then M$FID altreted and
      218      218                the error code may be found in the altret frame.
      219      219                                                                           */
      220      220        /*D*    NAME: XUR$HELP
      221      221                CALL: CALL XUR$HELP(XUH_PARAM) ALTRET;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:22   
      222      222                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      223      223                DESCRIPTION:
      224      224                   This routine calls X$HELP.  The purpose of XUR$HELP is
      225      225                to keep track of whether the last message operation was
      226      226                M$ERRMSG or M$HELP.  If X$HELP altreturns then XUR$HELP
      227      227                will call XUR$ERRMSG with the error code in XUH_PARAM and
      228      228                then altreturn.  Otherwise the normal return will be taken.
      229      229                                                                           */
      230      230        /*D*    NAME: XUR$MOREMSG
      231      231                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      232      232                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      233      233                DESCRIPTION:
      234      234                   XUR$ERRMSG or X$HELP is called to get the next level of
      235      235                messages.  Trust me.  The altreturn is taken if no messages
      236      236                are available.
      237      237                                                                           */
      238      238        /*D*    NAME: XUR$ALLMSG
      239      239                CALL: CALL XUR$MOREMSG(XUH_PARAM) ALTRET;
      240      240                INPUT:   XUH_PARAM - INPUT PARAMETER TO X$HELP
      241      241                DESCRIPTION:
      242      242                   XUR$ERRMSG or X$HELP is called to get all remaining
      243      243                messages.  Trust me.  The altreturn is taken if no messages
      244      244                are available.
      245      245                                                                           */
      246      246        /*D*    NAME: XUR$FINDDCB
      247      247                CALL: CALL XUR$FINDDCB(DCBNAME,DCB#) ALTRET;
      248      248                INPUT:   DCBNAME - TEXTC DCB NAME
      249      249                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
      250      250                DESCRIPTION:
      251      251                   Searches DCB table for DCB specified by DCBNAME.  If it
      252      252                is found, DCB number is returned in DCB#.  If not present
      253      253                the altreturn will be taken.
      254      254                                                                           */
      255      255        /*D*    NAME: XUR$GETDCB
      256      256                CALL: CALL XUR$GETDCB(DCBNAME,DCB#) ALTRET;
      257      257                INPUT:   DCBNAME - TEXTC DCB NAME
      258      258                OUTPUT:  DCB# - DCB NUMBER (SBIN WORD)
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:23   
      259      259                DESCRIPTION:
      260      260                   Searches DCB table for DCB specified by DCBNAME.  If it
      261      261                is found, DCB number is returned in DCB#.  If not present
      262      262                M$GETDCB will be called to get it.  If M$GETDCB altreturns
      263      263                then XUR$GETDCB will altreturn and the error code may be
      264      264                found in the altret frame.
      265      265                                                                           */
      266      266        /*D*    NAME: XUR$CLOSE_DCBS;
      267      267                CALL: CALL XUR$CLOSE_DCBS;
      268      268                DESCRIPTION:
      269      269                   Closes all open dcbs with SAVE.
      270      270                                                                           */
      271      271        /*D*     NAME: XUR$ERRCNVRT
      272      272                 CALL: CALL XUR$ERRCNVRT (LCP6_ERROR_CODE, ERROR_CODE);
      273      273                 INPUT: LCP6_ERROR_CODE - an LCP-6 error code (fcg/mid/m/err/sev) as
      274      274                       passed through the coupler.
      275      275                 OUTPUT: ERROR_CODE - error code converted to CP-6 standard format.
      276      276                 DESCRIPTION: This routine will convert an LCP-6 error code (32 bits,
      277      277                             stored in 36 bits with the high-order bit in each byte
      278      278                             being zero) into the equivalent CP-6 standard error code
      279      279                             format (36 bits).
      280      280        */
      281      281
      282      282        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:24   
      283      283        XUG$INIT: PROC (GETCMD, XUG_INIT) ALTRET;

    283  1 000000   000000 700200 xent  XUG$INIT     TSX0  ! X66_AUTO_2
         1 000001   000006 000002                    ZERO    6,2

      284      284        /**/
      285      285        %INCLUDE XU_MACRO_C ;
      286     3391
      287     3392        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      288     3730        %XUG_INIT (NAME=XUG_INIT, STCLASS=PARAM) ;
      289     4143        /**/
      290     4144    1   DCL XUG$INIT_COMMON ENTRY(2) ALTRET ;
      291     4145    1   DCL XUG$GETCMD_COMMON ENTRY(1) ALTRET ;
      292     4146    1   DCL XUG$ERRPTR_COMMON ENTRY(1) ALTRET ;
      293     4147    1   DCL XUG$ECHOIF_COMMON ENTRY(1) ALTRET ;
      294     4148    1   DCL XUG$ECHO_COMMON ENTRY(1) ALTRET ;
      295     4149    1   DCL XUG_WORK$ PTR STATIC SYMDEF ;
      296     4150
      297     4151    1           CALL XUG$INIT_COMMON(GETCMD, XUG_INIT) ALTRET(MALT) ;

   4151  1 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         1 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         1 000004   000000 701000 xent               TSX1    XUG$INIT_COMMON
         1 000005   000046 702000 1                  TSX2    MALT

      298     4152    1           XUG_WORK$ = GETCMD.WORK$ ;

   4152  1 000006   200003 470500                    LDP0    @GETCMD,,AUTO
         1 000007   000004 236100                    LDQ     4,,PR0
         1 000010   000000 756000 0                  STQ     XUG_WORK$

      299     4153    1           RETURN;

   4153  1 000011   000000 702200 xent               TSX2  ! X66_ARET

      300     4154        %EJECT ;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:25   
      301     4155    1   XUG$GETCMD: ENTRY(GETCMD) ALTRET;

   4155  1 000012   000000 700200 xent  XUG$GETCMD   TSX0  ! X66_AUTO_2
         1 000013   000006 000002                    ZERO    6,2

      302     4156    1   GETCMD:
      303     4157    1           CALL XUG$GETCMD_COMMON (GETCMD) ALTRET(MALT) ;

   4157  1 000014   200003 630500       GETCMD       EPPR0   @GETCMD,,AUTO
         1 000015   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000016   000000 701000 xent               TSX1    XUG$GETCMD_COMMON
         1 000017   000046 702000 1                  TSX2    MALT

      304     4158    1           RETURN;

   4158  1 000020   000000 702200 xent               TSX2  ! X66_ARET

      305     4159        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:26   
      306     4160    1   XUG$ERRPTR: ENTRY(GETCMD) ALTRET;

   4160  1 000021   000000 700200 xent  XUG$ERRPTR   TSX0  ! X66_AUTO_2
         1 000022   000006 000002                    ZERO    6,2

      307     4161        /**/
      308     4162    1           CALL XUG$ERRPTR_COMMON (GETCMD) ALTRET(MALT) ;

   4162  1 000023   200003 630500                    EPPR0   @GETCMD,,AUTO
         1 000024   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000025   000000 701000 xent               TSX1    XUG$ERRPTR_COMMON
         1 000026   000046 702000 1                  TSX2    MALT

      309     4163    1           RETURN;

   4163  1 000027   000000 702200 xent               TSX2  ! X66_ARET

      310     4164        %EJECT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:27   
      311     4165    1   XUG$ECHOIF: ENTRY(GETCMD) ALTRET;

   4165  1 000030   000000 700200 xent  XUG$ECHOIF   TSX0  ! X66_AUTO_2
         1 000031   000006 000002                    ZERO    6,2

      312     4166    1           CALL XUG$ECHOIF_COMMON(GETCMD) ALTRET(MALT) ;

   4166  1 000032   200003 630500                    EPPR0   @GETCMD,,AUTO
         1 000033   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000034   000000 701000 xent               TSX1    XUG$ECHOIF_COMMON
         1 000035   000046 702000 1                  TSX2    MALT

      313     4167    1           RETURN ;

   4167  1 000036   000000 702200 xent               TSX2  ! X66_ARET

      314     4168    1   XUG$ECHO: ENTRY(GETCMD) ALTRET;

   4168  1 000037   000000 700200 xent  XUG$ECHO     TSX0  ! X66_AUTO_2
         1 000040   000006 000002                    ZERO    6,2

      315     4169    1           CALL XUG$ECHO_COMMON(GETCMD) ALTRET(MALT) ;

   4169  1 000041   200003 630500                    EPPR0   @GETCMD,,AUTO
         1 000042   000017 631400 xsym               EPPR1   B_VECTNIL+15
         1 000043   000000 701000 xent               TSX1    XUG$ECHO_COMMON
         1 000044   000046 702000 1                  TSX2    MALT

      316     4170    1           RETURN;

   4170  1 000045   000000 702200 xent               TSX2  ! X66_ARET

      317     4171    1   MALT:   ALTRETURN ;

   4171  1 000046   000000 702200 xent  MALT         TSX2  ! X66_AALT
      318     4172        /**/
      319     4173    1   END XUG$INIT;
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:28   
      320     4174        %EOD;

PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:29   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$INIT.
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:30   

 **** Variables and constants ****

  ****  Section 000  Data  XUG$INIT

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 XUG_WORK$

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                    4-0-0/w PTR         r     1 @XUG_INIT
    *0-0-0/d STRC(1512)  r     1 GETCMD                    *0-0-0/d STRC(1296)  r     1 XUG_INIT


   Procedure XUG$INIT requires 39 words for executable code.
   Procedure XUG$INIT requires 6 words of local(AUTO) storage.
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:31   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=XUG$INIT File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:17 Page:32   
          MINI XREF LISTING

GETCMD
      4157**LABEL     283--PROC     4151<>CALL     4155--ENTRY    4157<>CALL     4160--ENTRY    4162<>CALL
      4165--ENTRY    4166<>CALL     4168--ENTRY    4169<>CALL
GETCMD.OUT$
      3410**DCL      3416--REDEF
GETCMD.WORK$
      3438**DCL      4152>>ASSIGN
MALT
      4171**LABEL    4151--CALLALT  4157--CALLALT  4162--CALLALT  4166--CALLALT  4169--CALLALT
XUG$ECHOIF_COMMON
      4147**DCL-ENT  4166--CALL
XUG$ECHO_COMMON
      4148**DCL-ENT  4169--CALL
XUG$ERRPTR_COMMON
      4146**DCL-ENT  4162--CALL
XUG$GETCMD_COMMON
      4145**DCL-ENT  4157--CALL
XUG$INIT_COMMON
      4144**DCL-ENT  4151--CALL
XUG_INIT
      3752**DCL       283--PROC     4151<>CALL
XUG_WORK$
      4149**DCL      4152<<ASSIGN

PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:33   
      321        1        /*T***********************************************************/
      322        2        /*T*                                                         */
      323        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      324        4        /*T*                                                         */
      325        5        /*T***********************************************************/
      326        6        /* ROUTINE TO DO CORRESPONDENCES, ECHO, ETC. */
      327        7        XUG$CORRES: PROC(DCB1,DCB2) ALTRET;
      328        8        /**/
      329        9    1   DCL DCB1 SBIN WORD ;
      330       10    1   DCL DCB2 SBIN WORD ;
      331       11        /**/
      332       12    1   DCL XUG$CORRES_COMMON ENTRY(2) ALTRET ;
      333       13    1   DCL XUG$ECHOLAST_COMMON ENTRY(1) ALTRET ;
      334       14
      335       15    1           CALL XUG$CORRES_COMMON(DCB1, DCB2) ALTRET(CORRES) ;
      336       16    1           RETURN;
      337       17        %EJECT;
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:34   
      338       18    1   XUG$ECHOLAST: ENTRY(DCB1) ALTRET;
      339       19    1           CALL XUG$ECHOLAST_COMMON(DCB1) ALTRET(CORRES) ;
      340       20    1           RETURN;
      341       21
      342       22    1   CORRES: ALTRETURN;
      343       23    1   END XUG$CORRES;
      344       24        %EOD;

PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:35   
      No diagnostics issued in procedure XUG$CORRES.

   Procedure XUG$CORRES requires 15 words for executable code.
   Procedure XUG$CORRES requires 6 words of local(AUTO) storage.

PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:36   

 Object Unit name= XUG$CORRES                                 File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:07.12 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  XUG$CORRES

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  XUG$CORRES
     0      7          yes     yes      Std        1  XUG$ECHOLAST

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$CORRES_COMMON
 yes     yes           Std       1 XUG$ECHOLAST_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:37   


      321        1        /*T***********************************************************/
      322        2        /*T*                                                         */
      323        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      324        4        /*T*                                                         */
      325        5        /*T***********************************************************/
      326        6        /* ROUTINE TO DO CORRESPONDENCES, ECHO, ETC. */
      327        7        XUG$CORRES: PROC(DCB1,DCB2) ALTRET;

      7  0 000000   000000 700200 xent  XUG$CORRES   TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      328        8        /**/
      329        9    1   DCL DCB1 SBIN WORD ;
      330       10    1   DCL DCB2 SBIN WORD ;
      331       11        /**/
      332       12    1   DCL XUG$CORRES_COMMON ENTRY(2) ALTRET ;
      333       13    1   DCL XUG$ECHOLAST_COMMON ENTRY(1) ALTRET ;
      334       14
      335       15    1           CALL XUG$CORRES_COMMON(DCB1, DCB2) ALTRET(CORRES) ;

     15  0 000002   200003 630500                    EPPR0   @DCB1,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$CORRES_COMMON
         0 000005   000016 702000 0                  TSX2    CORRES

      336       16    1           RETURN;

     16  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      337       17        %EJECT;
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:38   
      338       18    1   XUG$ECHOLAST: ENTRY(DCB1) ALTRET;

     18  0 000007   000000 700200 xent  XUG$ECHOLAST TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      339       19    1           CALL XUG$ECHOLAST_COMMON(DCB1) ALTRET(CORRES) ;

     19  0 000011   200003 630500                    EPPR0   @DCB1,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$ECHOLAST_COMMON
         0 000014   000016 702000 0                  TSX2    CORRES

      340       20    1           RETURN;

     20  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      341       21
      342       22    1   CORRES: ALTRETURN;

     22  0 000016   000000 702200 xent  CORRES       TSX2  ! X66_AALT
      343       23    1   END XUG$CORRES;
      344       24        %EOD;

PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:39   
      No diagnostics issued in procedure XUG$CORRES.
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:40   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @DCB1                      4-0-0/w PTR         r     1 @DCB2
    *0-0-0/w SBIN        r     1 DCB1                      *0-0-0/w SBIN        r     1 DCB2


   Procedure XUG$CORRES requires 15 words for executable code.
   Procedure XUG$CORRES requires 6 words of local(AUTO) storage.
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:41   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=XUG$CORRES File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:42   
          MINI XREF LISTING

CORRES
        22**LABEL      15--CALLALT    19--CALLALT
DCB1
         9**DCL         7--PROC       15<>CALL       18--ENTRY      19<>CALL
DCB2
        10**DCL         7--PROC       15<>CALL
XUG$CORRES_COMMON
        12**DCL-ENT    15--CALL
XUG$ECHOLAST_COMMON
        13**DCL-ENT    19--CALL

PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:43   
      345        1        /*T***********************************************************/
      346        2        /*T*                                                         */
      347        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      348        4        /*T*                                                         */
      349        5        /*T***********************************************************/
      350        6        XUG$BREAK: PROC ASYNC ;
      351        7        /**/
      352        8        %INCLUDE XU_MACRO_C ;
      353     3114        /**/
      354     3115    1   DCL XUG_WORK$ PTR SYMREF ;
      355     3116    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      356     3117        %EJECT;
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:44   
      357     3118    2           DO INHIBIT;
      358     3119    2              CALL XUG$BREAK_COMMON (XUG_WORK$) ;
      359     3120    2              RETURN;
      360     3121    2              END;
      361     3122    1   END XUG$BREAK;
      362     3123        %EOD;

PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:45   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$BREAK.

   Procedure XUG$BREAK requires 8 words for executable code.
   Procedure XUG$BREAK requires 4 words of local(AUTO) storage.

PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:46   

 Object Unit name= XUG$BREAK                                  File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:09.20 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     8     10  XUG$BREAK
    1  RoData even  none     1      1  XUG$BREAK

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes     Async       0  XUG$BREAK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$BREAK_COMMON
                       nStd      0 X66_AAUTO
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     XUG_WORK$                             B_VECTNIL
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:47   

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:48   


      345        1        /*T***********************************************************/
      346        2        /*T*                                                         */
      347        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      348        4        /*T*                                                         */
      349        5        /*T***********************************************************/
      350        6        XUG$BREAK: PROC ASYNC ;

      6  0 000000   000000 700200 xent  XUG$BREAK    TSX0  ! X66_AAUTO
         0 000001   000004 000000                    ZERO    4,0

      351        7        /**/
      352        8        %INCLUDE XU_MACRO_C ;
      353     3114        /**/
      354     3115    1   DCL XUG_WORK$ PTR SYMREF ;
      355     3116    1   DCL XUG$BREAK_COMMON ENTRY(1) ;
      356     3117        %EJECT;
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:49   
      357     3118    2           DO INHIBIT;

      358     3119    2              CALL XUG$BREAK_COMMON (XUG_WORK$) ;

   3119  0 000002   000000 630600 1                  EPPR0 ! 0
         0 000003   000017 631600 xsym               EPPR1 ! B_VECTNIL+15
         0 000004   000000 701200 xent               TSX1  ! XUG$BREAK_COMMON
         0 000005   000000 011200                    NOP   ! 0

      359     3120    2              RETURN;

   3120  0 000006   000000 702200 xent               TSX2  ! X66_AARET

      360     3121    2              END;

      361     3122    1   END XUG$BREAK;

   3122  0 000007   000000 702200 xent               TSX2  ! X66_AARET
      362     3123        %EOD;

PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:50   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$BREAK.
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:51   

 **** Variables and constants ****

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 XUG_WORK$


   Procedure XUG$BREAK requires 8 words for executable code.
   Procedure XUG$BREAK requires 4 words of local(AUTO) storage.
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:52   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=XUG$BREAK File=XUG$GETCMD.:E05TSI                             WED 07/30/97 09:18 Page:53   
          MINI XREF LISTING

XUG$BREAK_COMMON
      3116**DCL-ENT  3119--CALL
XUG_WORK$
      3115**DCL      3119<>CALL

PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:54   
      363        1        /*T***********************************************************/
      364        2        /*T*                                                         */
      365        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      366        4        /*T*                                                         */
      367        5        /*T***********************************************************/
      368        6        XUG$DISABLE: PROC(GETCMD);
      369        7        /**/
      370        8        %INCLUDE XU_MACRO_C ;
      371     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      372     3452        /**/
      373     3453    1   DCL XUG$DISABLE_COMMON ENTRY(1) ;
      374     3454    1   DCL XUG$CLRENABLE_COMMON ENTRY(1) ;
      375     3455    1   DCL XUG$ENABLE_COMMON ENTRY(1) ;
      376     3456    1   DCL XUG$SIMULATE_BREAK_COMMON ENTRY (1);
      377     3457
      378     3458    1           CALL XUG$DISABLE_COMMON(GETCMD) ;
      379     3459    1           RETURN ;
      380     3460    1   XUG$CLRENABLE: ENTRY(GETCMD);
      381     3461    1           CALL XUG$CLRENABLE_COMMON(GETCMD) ;
      382     3462    1           RETURN ;
      383     3463    1   XUG$ENABLE: ENTRY(GETCMD);
      384     3464    1           CALL XUG$ENABLE_COMMON(GETCMD) ;
      385     3465    1           RETURN ;
      386     3466    1   XUG$SIMULATE_BREAK: ENTRY (GETCMD);
      387     3467    1           CALL XUG$SIMULATE_BREAK_COMMON (GETCMD);
      388     3468    1           RETURN;
      389     3469    1   END XUG$DISABLE;
      390     3470        %EOD;

PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:55   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$DISABLE.

   Procedure XUG$DISABLE requires 28 words for executable code.
   Procedure XUG$DISABLE requires 4 words of local(AUTO) storage.

PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:56   

 Object Unit name= XUG$DISABLE                                File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:16.16 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    28     34  XUG$DISABLE

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        1  XUG$DISABLE
     0      7                  yes      Std        1  XUG$CLRENABLE
     0     16                  yes      Std        1  XUG$ENABLE
     0     25                  yes      Std        1  XUG$SIMULATE_BREAK

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$DISABLE_COMMON
         yes           Std       1 XUG$CLRENABLE_COMMON
         yes           Std       1 XUG$SIMULATE_BREAK_COMMON
         yes           Std       1 XUG$ENABLE_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:57   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:58   


      363        1        /*T***********************************************************/
      364        2        /*T*                                                         */
      365        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      366        4        /*T*                                                         */
      367        5        /*T***********************************************************/
      368        6        XUG$DISABLE: PROC(GETCMD);

      6  0 000000   000000 700200 xent  XUG$DISABLE  TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      369        7        /**/
      370        8        %INCLUDE XU_MACRO_C ;
      371     3114        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      372     3452        /**/
      373     3453    1   DCL XUG$DISABLE_COMMON ENTRY(1) ;
      374     3454    1   DCL XUG$CLRENABLE_COMMON ENTRY(1) ;
      375     3455    1   DCL XUG$ENABLE_COMMON ENTRY(1) ;
      376     3456    1   DCL XUG$SIMULATE_BREAK_COMMON ENTRY (1);
      377     3457
      378     3458    1           CALL XUG$DISABLE_COMMON(GETCMD) ;

   3458  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$DISABLE_COMMON
         0 000005   000000 011000                    NOP     0

      379     3459    1           RETURN ;

   3459  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      380     3460    1   XUG$CLRENABLE: ENTRY(GETCMD);

   3460  0 000007   000000 700200 xent  XUG$CLRENAB* TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      381     3461    1           CALL XUG$CLRENABLE_COMMON(GETCMD) ;
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:59   

   3461  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$CLRENABLE_COMMON
         0 000014   000000 011000                    NOP     0

      382     3462    1           RETURN ;

   3462  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      383     3463    1   XUG$ENABLE: ENTRY(GETCMD);

   3463  0 000016   000000 700200 xent  XUG$ENABLE   TSX0  ! X66_AUTO_1
         0 000017   000004 000001                    ZERO    4,1

      384     3464    1           CALL XUG$ENABLE_COMMON(GETCMD) ;

   3464  0 000020   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ENABLE_COMMON
         0 000023   000000 011000                    NOP     0

      385     3465    1           RETURN ;

   3465  0 000024   000000 702200 xent               TSX2  ! X66_ARET

      386     3466    1   XUG$SIMULATE_BREAK: ENTRY (GETCMD);

   3466  0 000025   000000 700200 xent  XUG$SIMULAT* TSX0  ! X66_AUTO_1
         0 000026   000004 000001                    ZERO    4,1

      387     3467    1           CALL XUG$SIMULATE_BREAK_COMMON (GETCMD);

   3467  0 000027   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000030   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000031   000000 701000 xent               TSX1    XUG$SIMULATE_BREAK_COMMON
         0 000032   000000 011000                    NOP     0
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:60   

      388     3468    1           RETURN;

   3468  0 000033   000000 702200 xent               TSX2  ! X66_ARET
      389     3469    1   END XUG$DISABLE;
      390     3470        %EOD;

PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:61   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$DISABLE.
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:62   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUG$DISABLE requires 28 words for executable code.
   Procedure XUG$DISABLE requires 4 words of local(AUTO) storage.
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:63   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=XUG$DISABLE File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:64   
          MINI XREF LISTING

GETCMD
      3127**DCL         6--PROC     3458<>CALL     3460--ENTRY    3461<>CALL     3463--ENTRY    3464<>CALL
      3466--ENTRY    3467<>CALL
GETCMD.OUT$
      3132**DCL      3138--REDEF
XUG$CLRENABLE_COMMON
      3454**DCL-ENT  3461--CALL
XUG$DISABLE_COMMON
      3453**DCL-ENT  3458--CALL
XUG$ENABLE_COMMON
      3455**DCL-ENT  3464--CALL
XUG$SIMULATE_BREAK_COMMON
      3456**DCL-ENT  3467--CALL

PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:65   
      391        1        /*T***********************************************************/
      392        2        /*T*                                                         */
      393        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      394        4        /*T*                                                         */
      395        5        /*T***********************************************************/
      396        6        /* XUG$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      397        7        /**/
      398        8        XUG$ERRMSG: PROC (GETCMD) ALTRET;
      399        9        /**/
      400       10        %INCLUDE XU_MACRO_C ;
      401     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      402     3454        /**/
      403     3455    1   DCL XUG$ERRMSG_COMMON ENTRY(1) ALTRET ;
      404     3456    1   DCL XUG$SETERRMSG_COMMON ENTRY(1) ALTRET ;
      405     3457        /**/
      406     3458        %EJECT;
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:66   
      407     3459    1           CALL XUG$ERRMSG_COMMON(GETCMD) ALTRET(ALT) ;
      408     3460    1           RETURN ;
      409     3461
      410     3462    1   XUG$SETERRMSG: ENTRY(GETCMD) ALTRET;
      411     3463    1           CALL XUG$SETERRMSG_COMMON(GETCMD) ALTRET(ALT) ;
      412     3464    1           RETURN ;
      413     3465    1   ALT:    ALTRETURN;
      414     3466    1   END XUG$ERRMSG;
      415     3467        %EOD;

PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:67   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$ERRMSG.

   Procedure XUG$ERRMSG requires 15 words for executable code.
   Procedure XUG$ERRMSG requires 4 words of local(AUTO) storage.

PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:68   

 Object Unit name= XUG$ERRMSG                                 File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:25.88 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  XUG$ERRMSG

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  XUG$ERRMSG
     0      7          yes     yes      Std        1  XUG$SETERRMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$ERRMSG_COMMON
 yes     yes           Std       1 XUG$SETERRMSG_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:69   


      391        1        /*T***********************************************************/
      392        2        /*T*                                                         */
      393        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      394        4        /*T*                                                         */
      395        5        /*T***********************************************************/
      396        6        /* XUG$ERRMSG - ERROR MESSAGE HANDLING ROUTINES FOR DEF */
      397        7        /**/
      398        8        XUG$ERRMSG: PROC (GETCMD) ALTRET;

      8  0 000000   000000 700200 xent  XUG$ERRMSG   TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      399        9        /**/
      400       10        %INCLUDE XU_MACRO_C ;
      401     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      402     3454        /**/
      403     3455    1   DCL XUG$ERRMSG_COMMON ENTRY(1) ALTRET ;
      404     3456    1   DCL XUG$SETERRMSG_COMMON ENTRY(1) ALTRET ;
      405     3457        /**/
      406     3458        %EJECT;
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:70   
      407     3459    1           CALL XUG$ERRMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3459  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$ERRMSG_COMMON
         0 000005   000016 702000 0                  TSX2    ALT

      408     3460    1           RETURN ;

   3460  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      409     3461
      410     3462    1   XUG$SETERRMSG: ENTRY(GETCMD) ALTRET;

   3462  0 000007   000000 700200 xent  XUG$SETERRM* TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      411     3463    1           CALL XUG$SETERRMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3463  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$SETERRMSG_COMMON
         0 000014   000016 702000 0                  TSX2    ALT

      412     3464    1           RETURN ;

   3464  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      413     3465    1   ALT:    ALTRETURN;

   3465  0 000016   000000 702200 xent  ALT          TSX2  ! X66_AALT
      414     3466    1   END XUG$ERRMSG;
      415     3467        %EOD;

PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:71   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$ERRMSG.
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:72   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUG$ERRMSG requires 15 words for executable code.
   Procedure XUG$ERRMSG requires 4 words of local(AUTO) storage.
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:73   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #005=XUG$ERRMSG File=XUG$GETCMD.:E05TSI                            WED 07/30/97 09:18 Page:74   
          MINI XREF LISTING

ALT
      3465**LABEL    3459--CALLALT  3463--CALLALT
GETCMD
      3129**DCL         8--PROC     3459<>CALL     3462--ENTRY    3463<>CALL
GETCMD.OUT$
      3134**DCL      3140--REDEF
XUG$ERRMSG_COMMON
      3455**DCL-ENT  3459--CALL
XUG$SETERRMSG_COMMON
      3456**DCL-ENT  3463--CALL

PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:75   
      416        1        /*T***********************************************************/
      417        2        /*T*                                                         */
      418        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      419        4        /*T*                                                         */
      420        5        /*T***********************************************************/
      421        6        XUG$HELP: PROC(GETCMD) ALTRET;
      422        7        %INCLUDE XU_MACRO_C;
      423     3113        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      424     3451        /*
      425     3452        */
      426     3453    1   DCL XUG$HELP_COMMON ENTRY(1) ALTRET ;
      427     3454    1   DCL XUG$MOREMSG_COMMON ENTRY(1) ALTRET ;
      428     3455    1   DCL XUG$ALLMSG_COMMON ENTRY(1) ALTRET ;
      429     3456        /**/
      430     3457    1           CALL XUG$HELP_COMMON(GETCMD) ALTRET(ALT) ;
      431     3458    1           RETURN ;
      432     3459
      433     3460    1   XUG$MOREMSG: ENTRY(GETCMD) ALTRET;
      434     3461    1           CALL XUG$MOREMSG_COMMON(GETCMD) ALTRET(ALT) ;
      435     3462    1           RETURN ;
      436     3463        /**/
      437     3464    1   XUG$ALLMSG: ENTRY(GETCMD) ALTRET;
      438     3465    1           CALL XUG$ALLMSG_COMMON(GETCMD) ALTRET(ALT) ;
      439     3466    1           RETURN ;
      440     3467        /**/
      441     3468    1   ALT:    ALTRETURN;
      442     3469    1   END XUG$HELP;
      443     3470        %EOD;

PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:76   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$HELP.

   Procedure XUG$HELP requires 22 words for executable code.
   Procedure XUG$HELP requires 4 words of local(AUTO) storage.

PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:77   

 Object Unit name= XUG$HELP                                   File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:34.36 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    22     26  XUG$HELP

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  XUG$HELP
     0      7          yes     yes      Std        1  XUG$MOREMSG
     0     16          yes     yes      Std        1  XUG$ALLMSG

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$HELP_COMMON
 yes     yes           Std       1 XUG$MOREMSG_COMMON
 yes     yes           Std       1 XUG$ALLMSG_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:78   

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:79   


      416        1        /*T***********************************************************/
      417        2        /*T*                                                         */
      418        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      419        4        /*T*                                                         */
      420        5        /*T***********************************************************/
      421        6        XUG$HELP: PROC(GETCMD) ALTRET;

      6  0 000000   000000 700200 xent  XUG$HELP     TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      422        7        %INCLUDE XU_MACRO_C;
      423     3113        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      424     3451        /*
      425     3452        */
      426     3453    1   DCL XUG$HELP_COMMON ENTRY(1) ALTRET ;
      427     3454    1   DCL XUG$MOREMSG_COMMON ENTRY(1) ALTRET ;
      428     3455    1   DCL XUG$ALLMSG_COMMON ENTRY(1) ALTRET ;
      429     3456        /**/
      430     3457    1           CALL XUG$HELP_COMMON(GETCMD) ALTRET(ALT) ;

   3457  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$HELP_COMMON
         0 000005   000025 702000 0                  TSX2    ALT

      431     3458    1           RETURN ;

   3458  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      432     3459
      433     3460    1   XUG$MOREMSG: ENTRY(GETCMD) ALTRET;

   3460  0 000007   000000 700200 xent  XUG$MOREMSG  TSX0  ! X66_AUTO_1
         0 000010   000004 000001                    ZERO    4,1

      434     3461    1           CALL XUG$MOREMSG_COMMON(GETCMD) ALTRET(ALT) ;
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:80   

   3461  0 000011   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000012   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000013   000000 701000 xent               TSX1    XUG$MOREMSG_COMMON
         0 000014   000025 702000 0                  TSX2    ALT

      435     3462    1           RETURN ;

   3462  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      436     3463        /**/
      437     3464    1   XUG$ALLMSG: ENTRY(GETCMD) ALTRET;

   3464  0 000016   000000 700200 xent  XUG$ALLMSG   TSX0  ! X66_AUTO_1
         0 000017   000004 000001                    ZERO    4,1

      438     3465    1           CALL XUG$ALLMSG_COMMON(GETCMD) ALTRET(ALT) ;

   3465  0 000020   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000021   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000022   000000 701000 xent               TSX1    XUG$ALLMSG_COMMON
         0 000023   000025 702000 0                  TSX2    ALT

      439     3466    1           RETURN ;

   3466  0 000024   000000 702200 xent               TSX2  ! X66_ARET

      440     3467        /**/
      441     3468    1   ALT:    ALTRETURN;

   3468  0 000025   000000 702200 xent  ALT          TSX2  ! X66_AALT
      442     3469    1   END XUG$HELP;
      443     3470        %EOD;

PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:81   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$HELP.
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:82   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUG$HELP requires 22 words for executable code.
   Procedure XUG$HELP requires 4 words of local(AUTO) storage.
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:83   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #006=XUG$HELP File=XUG$GETCMD.:E05TSI                              WED 07/30/97 09:18 Page:84   
          MINI XREF LISTING

ALT
      3468**LABEL    3457--CALLALT  3461--CALLALT  3465--CALLALT
GETCMD
      3126**DCL         6--PROC     3457<>CALL     3460--ENTRY    3461<>CALL     3464--ENTRY    3465<>CALL
GETCMD.OUT$
      3131**DCL      3137--REDEF
XUG$ALLMSG_COMMON
      3455**DCL-ENT  3465--CALL
XUG$HELP_COMMON
      3453**DCL-ENT  3457--CALL
XUG$MOREMSG_COMMON
      3454**DCL-ENT  3461--CALL

PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:85   
      444        1        /*T***********************************************************/
      445        2        /*T*                                                         */
      446        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      447        4        /*T*                                                         */
      448        5        /*T***********************************************************/
      449        6        XUG$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;
      450        7    1   DCL 1 DCBNAME,
      451        8    1         2 L UBIN BYTE UNAL,
      452        9    1         2 C CHAR(DCBNAME.L);
      453       10    1   DCL DCB# SBIN;
      454       11        /**/
      455       12    1   DCL XUG$FINDDCB_COMMON ENTRY(2) ALTRET ;
      456       13    1   DCL XUG$GETDCB_COMMON ENTRY(2) ALTRET ;
      457       14        /**/
      458       15    1           CALL XUG$FINDDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;
      459       16    1           RETURN ;
      460       17    1   XUG$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;
      461       18    1           CALL XUG$GETDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;
      462       19    1           RETURN;
      463       20    1   ALT:    ALTRETURN;
      464       21    1   END XUG$FINDDCB;
      465       22        %EOD;

PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:86   
      No diagnostics issued in procedure XUG$FINDDCB.

   Procedure XUG$FINDDCB requires 15 words for executable code.
   Procedure XUG$FINDDCB requires 6 words of local(AUTO) storage.

PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:87   

 Object Unit name= XUG$FINDDCB                                File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:43.64 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none    15     17  XUG$FINDDCB

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  XUG$FINDDCB
     0      7          yes     yes      Std        2  XUG$GETDCB

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$FINDDCB_COMMON
 yes     yes           Std       2 XUG$GETDCB_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:88   


      444        1        /*T***********************************************************/
      445        2        /*T*                                                         */
      446        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      447        4        /*T*                                                         */
      448        5        /*T***********************************************************/
      449        6        XUG$FINDDCB: PROC(DCBNAME,DCB#) ALTRET;

      6  0 000000   000000 700200 xent  XUG$FINDDCB  TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      450        7    1   DCL 1 DCBNAME,
      451        8    1         2 L UBIN BYTE UNAL,
      452        9    1         2 C CHAR(DCBNAME.L);
      453       10    1   DCL DCB# SBIN;
      454       11        /**/
      455       12    1   DCL XUG$FINDDCB_COMMON ENTRY(2) ALTRET ;
      456       13    1   DCL XUG$GETDCB_COMMON ENTRY(2) ALTRET ;
      457       14        /**/
      458       15    1           CALL XUG$FINDDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;

     15  0 000002   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$FINDDCB_COMMON
         0 000005   000016 702000 0                  TSX2    ALT

      459       16    1           RETURN ;

     16  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      460       17    1   XUG$GETDCB: ENTRY(DCBNAME,DCB#) ALTRET;

     17  0 000007   000000 700200 xent  XUG$GETDCB   TSX0  ! X66_AUTO_2
         0 000010   000006 000002                    ZERO    6,2

      461       18    1           CALL XUG$GETDCB_COMMON(DCBNAME, DCB#) ALTRET(ALT) ;

PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:89   
     18  0 000011   200003 630500                    EPPR0   @DCBNAME,,AUTO
         0 000012   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000013   000000 701000 xent               TSX1    XUG$GETDCB_COMMON
         0 000014   000016 702000 0                  TSX2    ALT

      462       19    1           RETURN;

     19  0 000015   000000 702200 xent               TSX2  ! X66_ARET

      463       20    1   ALT:    ALTRETURN;

     20  0 000016   000000 702200 xent  ALT          TSX2  ! X66_AALT
      464       21    1   END XUG$FINDDCB;
      465       22        %EOD;

PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:90   
      No diagnostics issued in procedure XUG$FINDDCB.
PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:91   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @DCB#                      3-0-0/w PTR         r     1 @DCBNAME
    *0-0-0/w SBIN        r     1 DCB#                      *0-0-0/c ASTR(9)     r     1 DCBNAME


   Procedure XUG$FINDDCB requires 15 words for executable code.
   Procedure XUG$FINDDCB requires 6 words of local(AUTO) storage.
PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:92   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #007=XUG$FINDDCB File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:18 Page:93   
          MINI XREF LISTING

ALT
        20**LABEL      15--CALLALT    18--CALLALT
DCB#
        10**DCL         6--PROC       15<>CALL       17--ENTRY      18<>CALL
DCBNAME
         7**DCL         6--PROC       15<>CALL       17--ENTRY      18<>CALL
DCBNAME.L
         8**DCL         9--IMP-SIZ    15>>CALL       18>>CALL
XUG$FINDDCB_COMMON
        12**DCL-ENT    15--CALL
XUG$GETDCB_COMMON
        13**DCL-ENT    18--CALL

PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:94   
      466        1        /*T***********************************************************/
      467        2        /*T*                                                         */
      468        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      469        4        /*T*                                                         */
      470        5        /*T***********************************************************/
      471        6        XUG$CLOSE_DCBS: PROC(GETCMD) ;
      472        7        /**/
      473        8    1   DCL XUG$CLOSE_DCBS_COMMON ENTRY(1) ;
      474        9        /**/
      475       10        %INCLUDE XU_MACRO_C ;
      476     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      477     3454        /**/
      478     3455    1           CALL XUG$CLOSE_DCBS_COMMON(GETCMD) ;
      479     3456    1           RETURN ;
      480     3457    1   END XUG$CLOSE_DCBS;
      481     3458        %EOD;

PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:95   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$CLOSE_DCBS.

   Procedure XUG$CLOSE_DCBS requires 7 words for executable code.
   Procedure XUG$CLOSE_DCBS requires 4 words of local(AUTO) storage.

PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:96   

 Object Unit name= XUG$CLOSE_DCBS                             File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:46.04 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  XUG$CLOSE_DCBS

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        1  XUG$CLOSE_DCBS

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       1 XUG$CLOSE_DCBS_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:97   


      466        1        /*T***********************************************************/
      467        2        /*T*                                                         */
      468        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      469        4        /*T*                                                         */
      470        5        /*T***********************************************************/
      471        6        XUG$CLOSE_DCBS: PROC(GETCMD) ;

      6  0 000000   000000 700200 xent  XUG$CLOSE_D* TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      472        7        /**/
      473        8    1   DCL XUG$CLOSE_DCBS_COMMON ENTRY(1) ;
      474        9        /**/
      475       10        %INCLUDE XU_MACRO_C ;
      476     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      477     3454        /**/
      478     3455    1           CALL XUG$CLOSE_DCBS_COMMON(GETCMD) ;

   3455  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$CLOSE_DCBS_COMMON
         0 000005   000000 011000                    NOP     0

      479     3456    1           RETURN ;

   3456  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      480     3457    1   END XUG$CLOSE_DCBS;
      481     3458        %EOD;

PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:98   
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$CLOSE_DCBS.
PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:99   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUG$CLOSE_DCBS requires 7 words for executable code.
   Procedure XUG$CLOSE_DCBS requires 4 words of local(AUTO) storage.
PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:100  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #008=XUG$CLOSE_DCBS File=XUG$GETCMD.:E05TSI                        WED 07/30/97 09:18 Page:101  
          MINI XREF LISTING

GETCMD
      3129**DCL         6--PROC     3455<>CALL
GETCMD.OUT$
      3134**DCL      3140--REDEF
XUG$CLOSE_DCBS_COMMON
         8**DCL-ENT  3455--CALL

PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:102  
      482        1        /*T***********************************************************/
      483        2        /*T*                                                         */
      484        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      485        4        /*T*                                                         */
      486        5        /*T***********************************************************/
      487        6        XUG$BLANK_PASSWORD: PROC(GETCMD, P_B) ALTRET ;
      488        7        /**/
      489        8    1   DCL XUG$BLANK_PASSWORD_COMMON ENTRY(2) ALTRET ;
      490        9        /**/
      491       10        %INCLUDE XU_MACRO_C ;
      492     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      493     3454        %PARSE$OUT (NAME=P_B, STCLASS=PARAM) ;
      494     3499        /**/
      495     3500    1           CALL XUG$BLANK_PASSWORD_COMMON(GETCMD, P_B) ALTRET(BLANK_ALT) ;
      496     3501    1           RETURN ;
      497     3502
      498     3503    1   BLANK_ALT:
      499     3504    1           ALTRETURN ;
      500     3505    1   END XUG$BLANK_PASSWORD ;
      501     3506        %EOD;

PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:103  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$BLANK_PASSWORD.

   Procedure XUG$BLANK_PASSWORD requires 8 words for executable code.
   Procedure XUG$BLANK_PASSWORD requires 6 words of local(AUTO) storage.

PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:104  

 Object Unit name= XUG$BLANK_PASSWORD                         File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:18:55.00 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     8     10  XUG$BLANK_PASSWORD

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        2  XUG$BLANK_PASSWORD

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XUG$BLANK_PASSWORD_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:105  


      482        1        /*T***********************************************************/
      483        2        /*T*                                                         */
      484        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      485        4        /*T*                                                         */
      486        5        /*T***********************************************************/
      487        6        XUG$BLANK_PASSWORD: PROC(GETCMD, P_B) ALTRET ;

      6  0 000000   000000 700200 xent  XUG$BLANK_P* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      488        7        /**/
      489        8    1   DCL XUG$BLANK_PASSWORD_COMMON ENTRY(2) ALTRET ;
      490        9        /**/
      491       10        %INCLUDE XU_MACRO_C ;
      492     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS=PARAM) ;
      493     3454        %PARSE$OUT (NAME=P_B, STCLASS=PARAM) ;
      494     3499        /**/
      495     3500    1           CALL XUG$BLANK_PASSWORD_COMMON(GETCMD, P_B) ALTRET(BLANK_ALT) ;

   3500  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$BLANK_PASSWORD_COMMON
         0 000005   000007 702000 0                  TSX2    BLANK_ALT

      496     3501    1           RETURN ;

   3501  0 000006   000000 702200 xent               TSX2  ! X66_ARET

      497     3502
      498     3503    1   BLANK_ALT:
      499     3504    1           ALTRETURN ;

   3504  0 000007   000000 702200 xent  BLANK_ALT    TSX2  ! X66_AALT
      500     3505    1   END XUG$BLANK_PASSWORD ;
      501     3506        %EOD;

PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:106  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$BLANK_PASSWORD.
PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:107  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                    4-0-0/w PTR         r     1 @P_B
    *0-0-0/d STRC(1512)  r     1 GETCMD                    *0-0-0/w STRC(144)   r     1 P_B


   Procedure XUG$BLANK_PASSWORD requires 8 words for executable code.
   Procedure XUG$BLANK_PASSWORD requires 6 words of local(AUTO) storage.
PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:108  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #009=XUG$BLANK_PASSWORD File=XUG$GETCMD.:E05TSI                    WED 07/30/97 09:18 Page:109  
          MINI XREF LISTING

BLANK_ALT
      3504**LABEL    3500--CALLALT
GETCMD
      3129**DCL         6--PROC     3500<>CALL
GETCMD.OUT$
      3134**DCL      3140--REDEF
P_B
      3460**DCL         6--PROC     3500<>CALL
XUG$BLANK_PASSWORD_COMMON
         8**DCL-ENT  3500--CALL

PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:110  
      502        1        /*T***********************************************************/
      503        2        /*T*                                                         */
      504        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      505        4        /*T*                                                         */
      506        5        /*T***********************************************************/
      507        6        /*P*  NAME:       XUG$ERRCNVRT
      508        7              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      509        8        */
      510        9
      511       10        XUG$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);
      512       11
      513       12    1   DCL 1 LCP6_ERR ALIGNED,
      514       13    1         2 F1,
      515       14    1           3 * BIT (1),
      516       15    1           3 PART1 BIT (5),
      517       16    1         2 F2,
      518       17    1           3 PART1 BIT (3),
      519       18    1           3 * BIT (1),
      520       19    1           3 PART2 BIT (2),
      521       20    1         2 MID BIT (5),
      522       21    1         2 M BIT (1),
      523       22    1         2 * BIT (1),
      524       23    1         2 ERR#,
      525       24    1           3 PART1 BIT (8),
      526       25    1           3 * BIT (1),
      527       26    1           3 PART2 BIT (5),
      528       27    1         2 SEV BIT (3);
      529       28
      530       29    1   DCL 1 CP6_ERR ALIGNED,
      531       30    1         2 F1,
      532       31    1           3 * BIT (1),
      533       32    1           3 PART1 BIT (5),
      534       33    1         2 F2,
      535       34    1           3 * BIT (1),
      536       35    1           3 PART1 BIT (3),
      537       36    1           3 PART2 BIT (2),
      538       37    1         2 MID,
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:111  
      539       38    1           3 * BIT (1),
      540       39    1           3 PART1 BIT (5),
      541       40    1         2 M BIT (1),
      542       41    1         2 ERR#,
      543       42    1           3 * BIT (1),
      544       43    1           3 PART1 BIT (8),
      545       44    1           3 PART2 BIT (5),
      546       45    1         2 SEV BIT (3);
      547       46    1   DCL XUG$ERRCNVRT_COMMON ENTRY(2) ;
      548       47
      549       48    1           CALL XUG$ERRCNVRT_COMMON(LCP6_ERR, CP6_ERR) ;
      550       49    1           RETURN ;
      551       50
      552       51    1   END XUG$ERRCNVRT;
      553       52        %EOD;

PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:112  
      No diagnostics issued in procedure XUG$ERRCNVRT.

   Procedure XUG$ERRCNVRT requires 7 words for executable code.
   Procedure XUG$ERRCNVRT requires 6 words of local(AUTO) storage.

PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:113  

 Object Unit name= XUG$ERRCNVRT                               File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:19:03.24 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  XUG$ERRCNVRT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUG$ERRCNVRT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRCNVRT_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:114  


      502        1        /*T***********************************************************/
      503        2        /*T*                                                         */
      504        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      505        4        /*T*                                                         */
      506        5        /*T***********************************************************/
      507        6        /*P*  NAME:       XUG$ERRCNVRT
      508        7              PURPOSE:    Convert LCP-6 error code to CP-6 equivalent
      509        8        */
      510        9
      511       10        XUG$ERRCNVRT: PROC (LCP6_ERR, CP6_ERR);

     10  0 000000   000000 700200 xent  XUG$ERRCNVRT TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      512       11
      513       12    1   DCL 1 LCP6_ERR ALIGNED,
      514       13    1         2 F1,
      515       14    1           3 * BIT (1),
      516       15    1           3 PART1 BIT (5),
      517       16    1         2 F2,
      518       17    1           3 PART1 BIT (3),
      519       18    1           3 * BIT (1),
      520       19    1           3 PART2 BIT (2),
      521       20    1         2 MID BIT (5),
      522       21    1         2 M BIT (1),
      523       22    1         2 * BIT (1),
      524       23    1         2 ERR#,
      525       24    1           3 PART1 BIT (8),
      526       25    1           3 * BIT (1),
      527       26    1           3 PART2 BIT (5),
      528       27    1         2 SEV BIT (3);
      529       28
      530       29    1   DCL 1 CP6_ERR ALIGNED,
      531       30    1         2 F1,
      532       31    1           3 * BIT (1),
      533       32    1           3 PART1 BIT (5),
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:115  
      534       33    1         2 F2,
      535       34    1           3 * BIT (1),
      536       35    1           3 PART1 BIT (3),
      537       36    1           3 PART2 BIT (2),
      538       37    1         2 MID,
      539       38    1           3 * BIT (1),
      540       39    1           3 PART1 BIT (5),
      541       40    1         2 M BIT (1),
      542       41    1         2 ERR#,
      543       42    1           3 * BIT (1),
      544       43    1           3 PART1 BIT (8),
      545       44    1           3 PART2 BIT (5),
      546       45    1         2 SEV BIT (3);
      547       46    1   DCL XUG$ERRCNVRT_COMMON ENTRY(2) ;
      548       47
      549       48    1           CALL XUG$ERRCNVRT_COMMON(LCP6_ERR, CP6_ERR) ;

     48  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRCNVRT_COMMON
         0 000005   000000 011000                    NOP     0

      550       49    1           RETURN ;

     49  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      551       50
      552       51    1   END XUG$ERRCNVRT;
      553       52        %EOD;

PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:116  
      No diagnostics issued in procedure XUG$ERRCNVRT.
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:117  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure XUG$ERRCNVRT requires 7 words for executable code.
   Procedure XUG$ERRCNVRT requires 6 words of local(AUTO) storage.
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:118  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #010=XUG$ERRCNVRT File=XUG$GETCMD.:E05TSI                          WED 07/30/97 09:19 Page:119  
          MINI XREF LISTING

CP6_ERR
        29**DCL        10--PROC       48<>CALL
LCP6_ERR
        12**DCL        10--PROC       48<>CALL
XUG$ERRCNVRT_COMMON
        46**DCL-ENT    48--CALL

PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:120  
      554        1        /*T***********************************************************/
      555        2        /*T*                                                         */
      556        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      557        4        /*T*                                                         */
      558        5        /*T***********************************************************/
      559        6        /*P*  NAME:       XUG$ERRTOLCP6
      560        7              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      561        8        */
      562        9
      563       10        XUG$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);
      564       11
      565       12    1   DCL 1 LCP6_ERR ALIGNED,
      566       13    1         2 F1,
      567       14    1           3 * BIT (1),
      568       15    1           3 PART1 BIT (5),
      569       16    1         2 F2,
      570       17    1           3 PART1 BIT (3),
      571       18    1           3 * BIT (1),
      572       19    1           3 PART2 BIT (2),
      573       20    1         2 MID BIT (5),
      574       21    1         2 M BIT (1),
      575       22    1         2 * BIT (1),
      576       23    1         2 ERR#,
      577       24    1           3 PART1 BIT (8),
      578       25    1           3 * BIT (1),
      579       26    1           3 PART2 BIT (5),
      580       27    1         2 SEV BIT (3);
      581       28
      582       29    1   DCL 1 CP6_ERR ALIGNED,
      583       30    1         2 F1,
      584       31    1           3 * BIT (1),
      585       32    1           3 PART1 BIT (5),
      586       33    1         2 F2,
      587       34    1           3 * BIT (1),
      588       35    1           3 PART1 BIT (3),
      589       36    1           3 PART2 BIT (2),
      590       37    1         2 MID,
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:121  
      591       38    1           3 * BIT (1),
      592       39    1           3 PART1 BIT (5),
      593       40    1         2 M BIT (1),
      594       41    1         2 ERR#,
      595       42    1           3 * BIT (1),
      596       43    1           3 PART1 BIT (8),
      597       44    1           3 PART2 BIT (5),
      598       45    1         2 SEV BIT (3);
      599       46    1   DCL XUG$ERRTOLCP6_COMMON ENTRY(2) ;
      600       47
      601       48    1           CALL XUG$ERRTOLCP6_COMMON(LCP6_ERR, CP6_ERR) ;
      602       49    1           RETURN;
      603       50
      604       51    1   END XUG$ERRTOLCP6;
      605       52        %EOD;

PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:122  
      No diagnostics issued in procedure XUG$ERRTOLCP6.

   Procedure XUG$ERRTOLCP6 requires 7 words for executable code.
   Procedure XUG$ERRTOLCP6 requires 6 words of local(AUTO) storage.

PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:123  

 Object Unit name= XUG$ERRTOLCP6                              File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:19:05.84 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     7      7  XUG$ERRTOLCP6

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes            yes      Std        2  XUG$ERRTOLCP6

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes           Std       2 XUG$ERRTOLCP6_COMMON
                       nStd      0 X66_AUTO_2
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:124  


      554        1        /*T***********************************************************/
      555        2        /*T*                                                         */
      556        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      557        4        /*T*                                                         */
      558        5        /*T***********************************************************/
      559        6        /*P*  NAME:       XUG$ERRTOLCP6
      560        7              PURPOSE:    Convert CP-6 error code to LCP-6 equivalent
      561        8        */
      562        9
      563       10        XUG$ERRTOLCP6: PROC (LCP6_ERR, CP6_ERR);

     10  0 000000   000000 700200 xent  XUG$ERRTOLC* TSX0  ! X66_AUTO_2
         0 000001   000006 000002                    ZERO    6,2

      564       11
      565       12    1   DCL 1 LCP6_ERR ALIGNED,
      566       13    1         2 F1,
      567       14    1           3 * BIT (1),
      568       15    1           3 PART1 BIT (5),
      569       16    1         2 F2,
      570       17    1           3 PART1 BIT (3),
      571       18    1           3 * BIT (1),
      572       19    1           3 PART2 BIT (2),
      573       20    1         2 MID BIT (5),
      574       21    1         2 M BIT (1),
      575       22    1         2 * BIT (1),
      576       23    1         2 ERR#,
      577       24    1           3 PART1 BIT (8),
      578       25    1           3 * BIT (1),
      579       26    1           3 PART2 BIT (5),
      580       27    1         2 SEV BIT (3);
      581       28
      582       29    1   DCL 1 CP6_ERR ALIGNED,
      583       30    1         2 F1,
      584       31    1           3 * BIT (1),
      585       32    1           3 PART1 BIT (5),
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:125  
      586       33    1         2 F2,
      587       34    1           3 * BIT (1),
      588       35    1           3 PART1 BIT (3),
      589       36    1           3 PART2 BIT (2),
      590       37    1         2 MID,
      591       38    1           3 * BIT (1),
      592       39    1           3 PART1 BIT (5),
      593       40    1         2 M BIT (1),
      594       41    1         2 ERR#,
      595       42    1           3 * BIT (1),
      596       43    1           3 PART1 BIT (8),
      597       44    1           3 PART2 BIT (5),
      598       45    1         2 SEV BIT (3);
      599       46    1   DCL XUG$ERRTOLCP6_COMMON ENTRY(2) ;
      600       47
      601       48    1           CALL XUG$ERRTOLCP6_COMMON(LCP6_ERR, CP6_ERR) ;

     48  0 000002   200003 630500                    EPPR0   @LCP6_ERR,,AUTO
         0 000003   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000004   000000 701000 xent               TSX1    XUG$ERRTOLCP6_COMMON
         0 000005   000000 011000                    NOP     0

      602       49    1           RETURN;

     49  0 000006   000000 702200 xent               TSX2  ! X66_ARET
      603       50
      604       51    1   END XUG$ERRTOLCP6;
      605       52        %EOD;

PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:126  
      No diagnostics issued in procedure XUG$ERRTOLCP6.
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:127  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @CP6_ERR                   3-0-0/w PTR         r     1 @LCP6_ERR
    *0-0-0/w STRC        r     1 CP6_ERR                   *0-0-0/w STRC        r     1 LCP6_ERR


   Procedure XUG$ERRTOLCP6 requires 7 words for executable code.
   Procedure XUG$ERRTOLCP6 requires 6 words of local(AUTO) storage.
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:128  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #011=XUG$ERRTOLCP6 File=XUG$GETCMD.:E05TSI                         WED 07/30/97 09:19 Page:129  
          MINI XREF LISTING

CP6_ERR
        29**DCL        10--PROC       48<>CALL
LCP6_ERR
        12**DCL        10--PROC       48<>CALL
XUG$ERRTOLCP6_COMMON
        46**DCL-ENT    48--CALL

PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:130  
      606        1        /*T***********************************************************/
      607        2        /*T*                                                         */
      608        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      609        4        /*T*                                                         */
      610        5        /*T***********************************************************/
      611        6        XUG$OPENOUT: PROC(GETCMD) ALTRET;
      612        7
      613        8    1   DCL XUG$OPENOUT_COMMON ENTRY(1) ALTRET;
      614        9
      615       10        %INCLUDE XU_MACRO_C ;
      616     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS="");
      617     3454
      618     3455    1           CALL XUG$OPENOUT_COMMON(GETCMD)
      619     3456    2           WHENALTRETURN DO;
      620     3457    2              ALTRETURN;
      621     3458    2              END;
      622     3459    1           RETURN ;
      623     3460    1   END XUG$OPENOUT;

PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:131  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$OPENOUT.

   Procedure XUG$OPENOUT requires 9 words for executable code.
   Procedure XUG$OPENOUT requires 4 words of local(AUTO) storage.

    No errors detected in file XUG$GETCMD.:E05TSI    .

PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:132  

 Object Unit name= XUG$OPENOUT                                File name= XUG$GETCMD.:E05TOU
 UTS= JUL 30 '97 09:19:08.24 WED                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none     9     11  XUG$OPENOUT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  XUG$OPENOUT

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       1 XUG$OPENOUT_COMMON
                       nStd      0 X66_AUTO_1
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AALT
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     B_VECTNIL
PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:133  


      606        1        /*T***********************************************************/
      607        2        /*T*                                                         */
      608        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      609        4        /*T*                                                         */
      610        5        /*T***********************************************************/
      611        6        XUG$OPENOUT: PROC(GETCMD) ALTRET;

      6  0 000000   000000 700200 xent  XUG$OPENOUT  TSX0  ! X66_AUTO_1
         0 000001   000004 000001                    ZERO    4,1

      612        7
      613        8    1   DCL XUG$OPENOUT_COMMON ENTRY(1) ALTRET;
      614        9
      615       10        %INCLUDE XU_MACRO_C ;
      616     3116        %XUG_GETCMD (NAME=GETCMD, STCLASS="");
      617     3454
      618     3455    1           CALL XUG$OPENOUT_COMMON(GETCMD)

   3455  0 000002   200003 630500                    EPPR0   @GETCMD,,AUTO
         0 000003   000017 631400 xsym               EPPR1   B_VECTNIL+15
         0 000004   000000 701000 xent               TSX1    XUG$OPENOUT_COMMON
         0 000005   000007 702000 0                  TSX2    s:3457
         0 000006   000010 710000 0                  TRA     s:3459

      619     3456    2           WHENALTRETURN DO;

      620     3457    2              ALTRETURN;

   3457  0 000007   000000 702200 xent               TSX2  ! X66_AALT

      621     3458    2              END;
      622     3459    1           RETURN ;

   3459  0 000010   000000 702200 xent               TSX2  ! X66_ARET
      623     3460    1   END XUG$OPENOUT;

PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:134  
--  Include file information  --

   XU_MACRO_C.:E05TOU  is referenced.
      No diagnostics issued in procedure XUG$OPENOUT.
PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:135  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     3-0-0/w PTR         r     1 @GETCMD                   *0-0-0/d STRC(1512)  r     1 GETCMD


   Procedure XUG$OPENOUT requires 9 words for executable code.
   Procedure XUG$OPENOUT requires 4 words of local(AUTO) storage.

    No errors detected in file XUG$GETCMD.:E05TSI    .
PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:136  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #012=XUG$OPENOUT File=XUG$GETCMD.:E05TSI                           WED 07/30/97 09:19 Page:137  
          MINI XREF LISTING

GETCMD
      3129**DCL         6--PROC     3455<>CALL
GETCMD.OUT$
      3134**DCL      3140--REDEF
XUG$OPENOUT_COMMON
         8**DCL-ENT  3455--CALL
