

07:10 JUL 29 '97 FM$FIT.:E05SI                                             1    
    1      /*M* FM$FIT - Based definitions of FIT                                     */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* MOC,CLM=25,MEC,EXM=15,CRM=78 */
    8                               /******************/
    9                               /* FORMAT OF FIT                                   */
   10                               /******************/
   11                     /*F* NAME: FIT - File Information Table.
   12                      ..::L1 "\\A"
   13                     Portions of the File Information Table (FIT) can be viewed by
   14                     calling the M$OPEN monitor service specifying FPARAM.
   15                     Library services discussed next give access to the
   16                     FIT data returned in the FPARAM buffer.
   17
   18                     FIT data is organized by sections each of which
   19                     is associated with a code.  The FIT contents varies
   20                     for each file type.  The FIT for one file type may
   21                     include 02 and 03 data; whereas the FIT for another
   22                     file type may include 03 and 04 data.  Macros which
   23                     define each data section are discussed in this
   24                     section and are identified by code number.
   25
   26                     After file opening, the user calls one of the library
   27                     services provided to obtain access to the desired
   28                     data section within the FPARAM buffer.  By
   29                     invoking a macro for the appropriate data section
   30                     (e.g., %CODE03; ), the user can access the data
   31                     using the defined names (e.g., CODE03.DESC.QS) for
   32                     that particular section of the FIT.
   33                     */
   34                     /*F* NAME: D_FM$FIT
   35                     .IBL D:FM$FIT
   36                     */
   37                     /*F* NAME: FM$FIT
07:10 JUL 29 '97 FM$FIT.:E05SI                                             2    
   38
   39                     The FPARAM buffer includes a header preceding
   40                     the data section(s).  The structure of the
   41                     header, which may be of interest to some
   42                     users, can be generated by invoking the FM$FIT
   43                     macro.
   44
   45                     FM$FIT defines an array CODES which contains
   46                     an entry for each FIT data section.
   47                     The array is of size (0:N).  The default
   48                     value of N is 30, which may be changed by
   49                     specifying N=value on the macro invocation
   50                     line.
   51                     The array CODES contains:
   52                     */
   53      %MACRO FM$FIT (N=30,BASED=BASED,FM$FIT=FM$FIT);
   54      DCL 1 FM$FIT BASED ALIGNED,
   55                               /* # of control words is CODE of 0th item          */
   56                               /* NAW of FIT is NAW of 0th item.                  */
   57                               /* NDW of FIT is NDW of 0th item.                  */
   58            2 CODES(0:N),      /*NUMBER OF CONTROL WORDS IS VARIABLE              */
   59              3 CODE UBIN(5) UNAL,
   60                     /*K* CODE = VALUE-DEC(1-31)  Contains the data
   61                     section number.  CODE(0) contains the
   62                     number of entries in the CODES array.
   63                     */
   64              3 * BIT(1) UNAL,
   65              3 NAW UBIN(10) UNAL,
   66                     /*K* NAW = VALUE-DEC(0-1023)  Contains the
   67                     number of available words in the data section.
   68                     NAW is always equal to NDW in FPARAM.  In
   69                     IFPARAM, it may be set to reserve space in the
   70                     FIT.  NAW(0) is the total number of words occupied
   71                     by the FIT.
   72                     */
   73              3 NDW UBIN(10) UNAL,
   74                     /*K* NDW = VALUE-DEC(0-1023)  Contains the number
07:10 JUL 29 '97 FM$FIT.:E05SI                                             3    
   75                     of significant words in the data section.
   76                     NDW(0) in FPARAM is the total number of words
   77                     occupied by the FPARAM information.
   78                     */
   79              3 ITEMX UBIN(10) UNAL;
   80                     /*K* ITEMX = VALUE-DEC(1-1020)  Contains the
   81                     word index of the start of the data section
   82                     relative to the beginning of the FIT header.
   83                     */
   84       %MEND;
   85      %MACRO FM_FITCODE (STCLASS=CONSTANT,
   86                         NAME=FM_FITCODE,
   87                         CODE=0,
   88                         NAW=0,
   89                         NDW=0,
   90                         ITEMX=0);
   91                               /**********************************/
   92                               /* DATA GENERATING VERSION OF FIT                  */
   93                               /**********************************/
   94      DCL 1 NAME STCLASS,
   95            2 * UBIN(5) UNAL INIT(CODE),
   96            2 * UBIN(11) UNAL INIT(NAW),
   97            2 * UBIN(10) UNAL INIT(NDW),
   98            2 * UBIN(10) UNAL INIT(ITEMX);
   99      %MEND;
  100      /**/
  101      %MACRO CODE01 (BASED=BASED,CODE01=CODE01);
  102      DCL 1 CODE01 BASED ALIGNED,
  103                     /*F* NAME: D_CODE01
  104                     .IBL D:CODE01
  105                     */
  106                     /*F* NAME: CODE01 - Not in FPARAM
  107
  108                     CODE01 contains items which are always in the FIT,
  109                     but are not included in the FPARAM buffer.
  110                     */
  111            2 NXTNTS UBIN(9) UNAL,
07:10 JUL 29 '97 FM$FIT.:E05SI                                             4    
  112                /*B* CODE01.NXTNTS number of extent words which make up the file. */
  113            2 HASH UBIN(27) UNAL,
  114                /*B* CODE01.HASH hashed file name is not reversible to full name.
  115                It is contained in FIT for RMA purpose of verification.           */
  116            2 XTNT (0:14) ALIGNED,
  117           /*B* CODE01.XTNT initial extent is zeroth entry in list of extents.    */
  118              3 XTNSIZE UBIN(9) UNAL,
  119                     /*B* CODE01.XTNT.XTNSIZE number of granules in extent. Zero if
  120                     following word contains the size.                            */
  121              3 XTNSDA UBIN(27) UNAL,
  122      /*B* CODE01.XTNT.XTNSDA set relative disk address of 1st gran in extent.    */
  123            2 EXTNT REDEF XTNT,
  124              3 * SBIN,
  125              3 XTNSIZE (0:13) SBIN;
  126                /*B* CODE01.EXTNT.XTNSIZE number of granules in extent if > 511.  */
  127       %MEND;
  128      /**/
  129      %MACRO CODE02 (BASED=BASED,CODE02=CODE02);
  130      DCL 1 CODE02 BASED ALIGNED,
  131                     /*F* NAME: D_CODE02
  132                     .IBL D:CODE02
  133                     */
  134                     /*F* NAME: CODE02 - Keyed Files
  135
  136                     CODE02 contains items which are in the FIT and FPARAM
  137                     buffer for KEYED and INDEXED files.
  138                     */
  139            2 LSLIDE UBIN(9) UNAL,
  140                     /*K* LSLIDE = VALUE-DEC(1-511)  See M$OPEN.
  141                     */
  142            2 LRDL0 UBIN(9) UNAL,
  143                     /*K* LRDL0 = VALUE-DEC(1-511)  See M$OPEN.
  144                     */
  145            2 SPARE UBIN(9) UNAL,
  146                     /*K* SPARE = VALUE-DEC(0-511)  See M$OPEN.
  147                     */
  148            2 SLIDE UBIN(9) UNAL,
07:10 JUL 29 '97 FM$FIT.:E05SI                                             5    
  149                     /*K* SLIDE = VALUE-DEC(0-511)  Contains the number of
  150                level 0 Master Index granules in the file if level 1 does not exist.
  151                Otherwise, SLIDE contains the number of level 0 Master Index
  152                granules which have been added since the last
  153                time the upper level index was rebuilt.
  154                */
  155            2 TDALVL UBIN(9) UNAL,
  156                     /*K* TDALVL = VALUE-DEC(0-511)  Contains the level number
  157                     of the top level of a multi-level key structure,
  158                     i.e., the level of TDA.
  159                     */
  160            2 TDA UBIN(27) UNAL,
  161                     /*K* TDA = VALUE-DEC(0-n)  Contains the  file
  162                     relative disk address of the first index granule at
  163                     the top of the multi-level index structure.
  164                     If no such structure exists, TDA contains zero.
  165                     */
  166            2 * BIT(9) UNAL,
  167            2 GDA UBIN(27) UNAL,
  168                     /*K* GDA = VALUE-DEC(0-n)  Contains the file
  169                     relative disk address of the last unfilled data
  170                     blocking granule.
  171                     */
  172            2 KEYX UBIN(18) UNAL,
  173                     /*K* KEYX = VALUE-DEC(0-32K)  See M$OPEN.
  174                     */
  175            2 KEYL UBIN(9) UNAL;
  176                     /*K* KEYL = VALUE-DEC(1-255)  See M$OPEN.
  177                     */
  178       %MEND;
  179      /**/
  180      %MACRO CODE03 (BASED=BASED,CODE03=CODE03);
  181      DCL 1 CODE03 BASED ALIGNED,
  182                     /*F* NAME: D_CODE03
  183                     .IBL D:CODE03
  184                     */
  185                     /*F* NAME: CODE03 - Always in FPARAM
07:10 JUL 29 '97 FM$FIT.:E05SI                                             6    
  186
  187                     CODE03 contains items which are always in the FIT
  188                     and the FPARAM buffer.
  189                                                                                  */
  190            2 ORG UBIN(9) UNAL,
  191                     /*K* ORG = OPTION  See M$OPEN.
  192                     */
  193            2 UGRANS UBIN(27) UNAL,
  194                     /*K* UGRANS = VALUE-DEC(1-n)  Contains the
  195                     current number of granules occupied.  UGRANS does
  196                     not include NGAVAL.
  197                     */
  198            2 DESC,
  199              3 DELF BIT(1),   /* DELETED FILE                                    */
  200                     /*K* DESC.DELF = VALUE-BIT(1)  See M$DCB.
  201                     */
  202              3 NOLIST BIT(1), /* NOLIST ATTR                                     */
  203                     /*K* DESC.NOLIST = VALUE-BIT(1)  See M$DCB.
  204                     */
  205              3 BUF BIT(1),    /* TO BE BACKED UP                                 */
  206                     /*K* DESC.BUF = VALUE-BIT(1)  See M$DCB.
  207                     */
  208              3 ODSTOW BIT(1), /* Stowed on optical disk                          */
  209                     /*K* DESC.ODSTOW = VALUE-BIT(1)  See M$DCB.
  210                     ..::IX "Optical Disk\CODE03.DESC.ODSTOW"
  211                     */
  212              3 BAD BIT(1),    /* FILE INCONSISTENCY                              */
  213                     /*K* DESC.BAD = VALUE-BIT(1)  See M$DCB.
  214                     */
  215              3 QS BIT(1),
  216                     /*K* DESC.QS = VALUE-BIT(1).  See M$DCB.
  217                     */
  218              3 * BIT(2),
  219
  220              3 ARCHIVE BIT(1),
  221                     /*K* DESC.ARCHIVE = VALUE-BIT(1).  See M$DCB.
  222                     */
07:10 JUL 29 '97 FM$FIT.:E05SI                                             7    
  223              3 BUPM BIT(1),   /* BACKUP IF MODIFIED                              */
  224                     /*K* DESC.BUPM = VALUE-BIT(1)  See M$DCB.
  225                     */
  226              3 NBUF BIT(1),   /* NO BACKUP COPY EXISTS                           */
  227                     /*K* DESC.NBUF = VALUE-BIT(1)  See M$DCB.
  228                     */
  229              3 ACTIVE BIT(1),
  230                     /*K* DESC.ACTIVE = VALUE-BIT(1).  See M$DCB.
  231                     */
  232              3 TPB BIT(1),
  233                     /*K* DESC.TPB = VALUE-BIT(1).  See M$DCB.
  234                     */
  235              3 TERMINATE BIT(1),
  236                     /*K* DESC.TERMINATE = VALUE-BIT(1).  See M$DCB.
  237                     */
  238              3 FETCH BIT(1),
  239                     /*K* DESC.FETCH = VALUE-BIT(1).  See M$DCB.
  240                     */
  241              3 * BIT(3),
  242
  243            2 TYPE CHAR(2) UNAL,
  244                     /*K* TYPE = VALUE-CHAR(2)  See M$OPEN.
  245                     */
  246            2 NRECS SBIN,
  247                     /*K* NRECS = VALUE-DEC(0-n)  Contains the current
  248                     number of records or total number of records
  249                     if the file is RELATIVE.
  250                     */
  251            2 RCSZ UBIN(9) UNAL,
  252                     /*K* RCSZ = VALUE-DEC(0-511)  Contains a value
  253                     one less than the number of pages (1024 words) required
  254                     to contain the largest record in the file.
  255                     */
  256            2 NGAVAL UBIN(27) UNAL,
  257                     /*K* NGAVAL = VALUE-DEC(1-n)  Contains the
  258                     number of unused granules available.
  259                     */
07:10 JUL 29 '97 FM$FIT.:E05SI                                             8    
  260            2 COMP BIT(1),
  261                     /*K* COMP = {YES|NO}  See M$OPEN.
  262                     */
  263            2 * BIT(4),
  264            2 GHSTACS UBIN(4) UNAL,
  265                     /*K* GHSTACS = VALUE-DEC(0-15)  See M$OPEN.
  266                     */
  267            2 LDA UBIN(27) UNAL,
  268                     /*K* LDA = VALUE-DEC(0-n)  Contains
  269                     the file relative disk address of the last level 0
  270                     granule.
  271                     */
  272            2 XTNSIZE UBIN(18) UNAL,
  273                     /*K* XTNSIZE = VALUE-DEC(1-32K)  See M$OPEN.
  274                     */
  275            2 RECL UBIN HALF UNAL,
  276                     /*K* RECL = VALUE-DEC(1-32K)  See M$OPEN.
  277                     */
  278            2 NSTAMP UBIN,
  279                     /*K* NSTAMP = Irreversibly scrambled name for
  280                     RMA purposes.
  281                     */
  282            2 EXPIRE SBIN HALF UNAL,
  283                     /*K* EXPIRE = VALUE-DEC(<0-16K)  See M$OPEN.
  284                     */
  285            2 *(0:2) BIT(18);
  286       %MEND;
  287      /**/
  288      %MACRO CODE04 (LEVEL=1,END=";",BASED=BASED,CODE04=CODE04,
  289                     ACCESS=ACCESS,
  290                     TIME=TIME,
  291                     MODIFY=MODIFY,
  292                     CREATION=CREATION,
  293                     UBIN=UBIN,
  294                     CREATOR=CREATOR,
  295                     ACCT=ACCT,
  296                     NAME=NAME,
07:10 JUL 29 '97 FM$FIT.:E05SI                                             9    
  297                     SVMODIFY=SVMODIFY,
  298                     CHAR=CHAR,
  299                     GAC=GAC,
  300                     N=N);
  301      %LSET LEV=CHARBIN(TEXTCHAR(LEVEL));
  302      %IF LEV=1;
  303      DCL 1 CODE04 BASED ALIGNED,
  304      %ENDIF;
  305                     /*F* NAME: D_CODE04
  306                     .IBL D:CODE04
  307                     */
  308                     /*F* NAME: CODE04 - Dates
  309
  310                     CODE04 contains dates which are required by
  311                     or supplied by the monitor. This entry is not made
  312                     for STAR files.
  313                     Each DATE/TIME field is represented as a UTS, which
  314                     can be converted to other forms via the M$TIME service.
  315                     Only CREATION, MODIFY, and ACCESS are moved to FPARAM
  316                     unless the user has FMSEC privilege.
  317                     */
  318            2 ACCESS,
  319                     /*K* ACCESS.TIME = VALUE-DEC(0-n)  Contains the UTS date/time
  320                     of the last non-TEST open unless CODE14.ACCESS.NOACUP
  321                     is set for the account.
  322                     */
  323              3 TIME UBIN(36) ALIGNED,
  324                               /* CP6 UTS value (see M$TIME)                      */
  325            2 MODIFY,
  326                     /*K* MODIFY.TIME = VALUE-DEC(0-n)  Contains the UTS date/time
  327                     of the last file update or file directory modification.
  328                     */
  329              3 TIME UBIN(36) ALIGNED,
  330                               /* CP6 UTS value (see M$TIME)                      */
  331            2 CREATION,
  332                     /*K* CREATION.TIME = VALUE-DEC(0-n)  Contains the UTS date/time
  333                     of file or directory creation.
07:10 JUL 29 '97 FM$FIT.:E05SI                                             10   
  334                     */
  335              3 TIME UBIN(36) ALIGNED,
  336                               /* CP6 UTS value (see M$TIME)                      */
  337            2 CREATOR,
  338              3 ACCT CHAR(8) UNAL,
  339                     /*K* CREATOR.ACCT = VALUE-CHAR(8)  Contains the
  340                     account of the creator of the file.  This field is used
  341                     for accounting purposes and is not returned in
  342                     in the FPARAM buffer.
  343                     */
  344              3 NAME CHAR(12) UNAL,
  345                     /*K* CREATOR.NAME = VALUE-CHAR(12)  Contains
  346                     the name of the creator of the file.  This field
  347                     is used for accounting purposes and is not returned in
  348                     the FPARAM buffer.
  349                     */
  350            2 SVMODIFY,
  351                     /*K* SVMODIFY.TIME = VALUE-DEC(0-n)  Contains the value of
  352                     MODIFY at the time the file is opened for updating.
  353                     At that time, MODIFY is changed to reflect the date/time
  354                     at the open.  At file closing if the file was not modified,
  355                     MODIFY is reset to SVMODIFY so that it appears that the
  356                     file was not opened for updating.
  357                     */
  358              3 TIME UBIN,
  359                               /* CP6 UTS value (see M$TIME)                      */
  360            2 GAC,
  361              3 N UBIN,
  362                     /*K* GAC.N = VALUE-DEC(0-n)  Contains the storage
  363                     integral in floating point form, i.e., the number of
  364                     granules occupied by the file multiplied by the number
  365                     of .01 second intervals since the last granule
  366                     accounting function was performed for the packset.  See
  367                     the System Support Reference Manual for further
  368                     information on PIG.
  369                     */
  370              3 TIME UBIN END
07:10 JUL 29 '97 FM$FIT.:E05SI                                             11   
  371                     /*K* GAC.TIME = VALUE-DEC(0-n)  Contains the UTS date/time
  372                     of the last update to GAC.N.
  373                     */
  374       %MEND;
  375      /**/
  376      %MACRO CODE05 (BASED=BASED,CODE05=CODE05);
  377      DCL 1 CODE05 BASED ALIGNED,
  378                     /*F* NAME: D_CODE05
  379                     .IBL D:CODE05
  380                     */
  381                     /*F* NAME: CODE05 - Backup Date and Reel
  382
  383                CODE05 contains the backup date/time and reel or packset number.
  384                This entry is not made for STAR files.
  385                */
  386            2 BACKUP,
  387              3 TIME UBIN(36) ALIGNED,
  388                     /*K* BACKUP.TIME = VALUE-DEC(0-n)  Contains the UTS
  389                     date/time at which file backup occurred.
  390                     */
  391              3 REEL CHAR(6) UNAL,
  392                     /*K* BACKUP.REEL = VALUE-CHAR(6)  Contains the
  393                     reel number or packset name of the backup medium,
  394                     left-justified.
  395                     */
  396              3 EFT,
  397                4 CROSS BIT(1) UNAL,
  398                     /*K*  BACKUP.EFT.CROSS = VALUE-BIT(1) Is set when the
  399                     file spans more than one tape volume.
  400                     */
  401                4 * BIT(3) UNAL,
  402                4 FSN UBIN(14) UNAL;
  403                     /*K*  BACKUP.EFT.FSN = VALUE-DEC(0-n) Contains the tape
  404                     file sequence number containing the "BACKED UP" copy of
  405                     the file.
  406                     */
  407       %MEND;
07:10 JUL 29 '97 FM$FIT.:E05SI                                             12   
  408      /**/
  409      %MACRO CODE06 (BASED=BASED,CODE06=CODE06);
  410      DCL 1 CODE06 BASED ALIGNED,
  411                     /*F* NAME: D_CODE06
  412                     .IBL D:CODE06
  413                     */
  414                     /*F* NAME: CODE06 - Stow Date and Reel
  415
  416                     CODE06 contains the STOWed UTS date/time and reel number.
  417                     This entry is not made for STAR files.  For STOWed
  418                     inactive files, this is the only entry in the FPARAM buffer.
  419                     */
  420            2 STOW,
  421              3 TIME UBIN(36) ALIGNED,
  422                               /* CP6 UTS value (see M$TIME)                      */
  423              3 REEL CHAR(6) ,
  424                     /*K* STOW.REEL = VALUE-CHAR(6)  Contains the
  425                     reel number of the STOW tape, left-justified.
  426                     */
  427              3 EFT,
  428                4 CROSS BIT(1) UNAL,
  429                     /*K* STOW.EFT.CROSS = VALUE-BIT(1) Is set when the
  430                     file spans more than one tape volume.
  431                     */
  432                4 INACTIVE BIT(1) UNAL,
  433                     /*K*  STOW.EFT.INACTIVE = VALUE-BIT(1) Is set when the
  434                     file is stowed inactive.
  435                     */
  436                4 * BIT(2) UNAL,
  437                4 FSN UBIN(14) UNAL,
  438                     /*K* STOW.EFT.FSN = VALUE-DEC(1-9999) Contains the File
  439                     Sequence Number of the file on the archive volume set
  440                     which contains this file.
  441                     */
  442              3 ODFSN REDEF EFT UBIN(18) UNAL;
  443                     /*K* STOW.ODFSN = VALUE-DEC(1-262143) Contains the File
  444                     Sequence Number of the file on the archive volume set
07:10 JUL 29 '97 FM$FIT.:E05SI                                             13   
  445                     which contains this file.  This is only used for files
  446                     stowed on optical disk.
  447                     ..::IX "Optical Disk\CODE06.STOW.ODFSN"
  448                     */
  449       %MEND;
  450      /**/
  451      %MACRO CODE07 (BASED=BASED,CODE07=CODE07);
  452      DCL 1 CODE07 BASED ALIGNED,
  453                     /*F* NAME: D_CODE07
  454                     .IBL D:CODE07
  455                     */
  456                     /*F* NAME: CODE07 - Password
  457
  458                     CODE07 contains the scrambled password.
  459                     This entry is not made for STAR files.
  460                     */
  461            2 PASS CHAR(8) UNAL;
  462                     /*K* PASS = VALUE-CHAR(8)  Contains the irreversibly
  463                     scrambled password.
  464                     */
  465       %MEND;
  466      /**/
  467      %MACRO FITALTKEYS (BASED=BASED,FITALTKEYS=FITALTKEYS);
  468      DCL 1 FITALTKEYS BASED ALIGNED,
  469                     /*F* NAME: D_CODE08
  470                     .IBL D:FITALTKEYS
  471                     */
  472                     /*F* NAME: CODE08 - FITALTKEYS
  473
  474                     The macro FITALTKEYS contains alternate index
  475                     information for indexed files.
  476                     The code for this entry is 8.                                */
  477            2 NUMWRDS UBIN(9) UNAL,
  478                     /*K* NUMWRDS = VALUE-DEC(1-511) Number of words in
  479                     this structure.                                              */
  480
  481            2 ALTBLD BIT(1),
07:10 JUL 29 '97 FM$FIT.:E05SI                                             14   
  482                     /*K* ALTBLD = VALUE-BIT(1).  Set if alternate indices
  483                     must be built or rebuilt.
  484                           */
  485            2 NUMENTS UBIN(8) UNAL,
  486                     /*K* NUMENTS = VALUE-DEC(1-21)  Number of indices currently
  487                     defined.                                                     */
  488            2 UNIQUEBLD BIT(1) UNAL,
  489                     /*K* UNIQUEBLD = VALUE-BIT(1) Indicates whether or not
  490                     indexes marked as UNIQUE need to be rebuilt.                 */
  491
  492            2 * BIT(5) UNAL,
  493
  494            2 MINWRSIZ UBIN(12) UNAL,
  495                     /*K* MINWRSIZE = VALUE-DEC(1-4095)  The minimum record
  496                     size that can be written.  Calculated by finding the
  497                     largest value for KEYX+KEYL for all indices.                 */
  498            2 K(0:20),
  499                     /*K* K = ARRAY(0:511)  One entry per index currently
  500                     defined.  Entry number zero (of the array K) is the
  501                     primary index of the file (corresponding to INDX=1
  502                     on data manipulation Monitor Services). Entry number n
  503                     is the nth alternate index and corresponds to INDX=n+1.      */
  504              3 KEYL UBIN(9) UNAL,
  505                /*K* K.KEYL = VALUE-DEC(0-255)  Length of key for this index.     */
  506              3 FDA UBIN(27) UNAL,
  507                     /*K* K.FDA = VALUE-DEC  Disk address of beginning of
  508                     this index.                                                  */
  509              3 LDA UBIN(27) UNAL,
  510                     /*K* K.LDA = VALUE-DEC  Disk address of end of this index.   */
  511              3 TDA UBIN(27) UNAL,
  512                     /*K* K.TDA = VALUE-DEC  Disk address of top of upper level
  513                     index structure for this index.                              */
  514              3 KEYX UBIN(18) UNAL,
  515                     /*K* K.KEYX = VALUE-DEC(0-65000).  Byte index in record
  516                     to start of this index's key.                                */
  517              3 TDALVL UBIN(9) UNAL,
  518                     /*K* K.TDALVL = VALUE-DEC(1-4).  Level number of the
07:10 JUL 29 '97 FM$FIT.:E05SI                                             15   
  519                     granule pointed to by TDA.                                   */
  520              3 UNIQUE BIT(1),
  521                     /*K* K.UNIQUE = VALUE-BIT(1)  Set if keys in this
  522                     index are to be unique.                                      */
  523              3 RPOS BIT(1),
  524                               /* Position flag - not meaningful in FIT           */
  525              3 DUPKEY BIT(1),
  526                     /*K* K.DUPKEY = VALUE-BIT(1)  Set if any duplicate
  527                     keys were found in this index the last time it
  528                     was built or rebuilt.                                        */
  529
  530              3 INDXCHNG BIT(1),
  531                               /* Index changed on rewrite of record, not meaningful
  532                                  in the FIT.                                     */
  533              3 * BIT(23),
  534              3 CRECX UBIN(18) UNAL,
  535                               /* Index to current key - not meaningful in FIT    */
  536              3 SEGX UBIN(18) UNAL,
  537                               /* Index to current record - not meaningful in FIT */
  538              3 CDA UBIN;
  539                               /* Current disk address - not meaningful in FIT    */
  540      %MEND;
  541      /**/
  542      %MACRO CODE09 (BASED=BASED,CODE09=CODE09);
  543      DCL 1 CODE09 BASED,
  544                     /*F* NAME: D_CODE09
  545                     .IBL D:CODE09
  546                     */
  547                     /*F* NAME: CODE09 - Access Control Lists
  548
  549                     CODE09 describes one entry of an account access
  550                     control list.
  551                     CODE09 is repeated (UNALIGNED) as many times as required.
  552                     This information, if present, is moved to FPARAM buffer.     */
  553            2 FFLG,
  554              3 READ BIT(1),
  555                     /*K* FFLG.READ = VALUE-BIT(1)  See M$DCB.
07:10 JUL 29 '97 FM$FIT.:E05SI                                             16   
  556                     */
  557              3 DELR BIT(1),
  558                     /*K* FFLG.DELR = VALUE-BIT(1)  See M$DCB.
  559                     */
  560              3 WNEW BIT(1),
  561                     /*K* FFLG.WNEW = VALUE-BIT(1)  See M$DCB.
  562                     */
  563              3 UPD BIT(1),
  564                     /*K* FFLG.UPD = VALUE-BIT(1)  See M$DCB.
  565                     */
  566              3 DELF BIT(1),
  567                     /*K* FFLG.DELF = VALUE-BIT(1)  See M$DCB.
  568                     */
  569              3 NOLIST BIT(1),
  570                     /*K* FFLG.NOLIST = VALUE-BIT(1)  If set, in a file,
  571                     the file's existence cannot be determined.  If set in a
  572                     directory, files appear not to exist and access cannot be
  573                     gained via specific file access control.  If
  574                     CODE09.FFLG for a directory contains all zeros or if only
  575                     CODE09.FFLG.CREATE is set, the default access to the files
  576                     is NOLIST, but this can be overridden by specific
  577                     access control.
  578                     */
  579              3 REATTR BIT(1),
  580                     /*K* FFLG.REATTR = VALUE-BIT(1)  See M$DCB.
  581                     */
  582              3 EXEC BIT(1),
  583                     /*K* FFLG.EXEC = VALUE-BIT(1)  See M$DCB.
  584                     */
  585              3 CREATE BIT(1),
  586                     /*K* FFLG.CREATE = VALUE-BIT(1)  See M$DCB.
  587                     */
  588              3 AU BIT(1),
  589                     /*K* FFLG.AU = VALUE-BIT(1)  See M$DCB.
  590                     */
  591              3 AURD BIT(1),
  592                     /*K* FFLG.AURD = VALUE-BIT(1)  See M$DCB.
07:10 JUL 29 '97 FM$FIT.:E05SI                                             17   
  593                     */
  594              3 TCTL BIT(1),
  595                     /*K* FFLG.TCTL = VALUE-BIT(1)  See M$DCB.
  596                     */
  597              3 * BIT(6),
  598                               /* SPARE                                           */
  599            2 ACCT CHAR(8);
  600                     /*K* ACCT = VALUE-CHAR(8)  Contains the account
  601                     to which the CODE09.FFLG bits apply.
  602                     */
  603       %MEND;
  604      /**/
  605      %MACRO CODE10 (BASED=BASED,CODE10=CODE10);
  606      DCL 1 CODE10 BASED,
  607                     /*F* NAME: D_CODE10
  608                     .IBL D:CODE10
  609                     */
  610                     /*F* NAME: CODE10 - Access Vehicle Control List
  611
  612                     CODE10 describes one entry of the
  613                     vehicle access control list.
  614                     The format is repeated as necessary.
  615                     Only the space required is used.
  616                     */
  617            2 FFLG,
  618                               /* Access bits                                     */
  619                               /* COMMENTARY IN CODE09                            */
  620              3 READ BIT(1),
  621                     /*K* FFLG.READ = VALUE-BIT(1)  See M$DCB.
  622                     */
  623              3 DELR BIT(1),
  624                     /*K* FFLG.DELR = VALUE-BIT(1)  See M$DCB.
  625                     */
  626              3 WNEW BIT(1),
  627                     /*K* FFLG.WNEW = VALUE-BIT(1)  See M$DCB.
  628                     */
  629              3 UPD BIT(1),
07:10 JUL 29 '97 FM$FIT.:E05SI                                             18   
  630                     /*K* FFLG.UPD = VALUE-BIT(1)  See M$DCB.
  631                     */
  632              3 DELF BIT(1),
  633                     /*K* FFLG.DELF = VALUE-BIT(1)  See M$DCB.
  634                     */
  635              3 NOLIST BIT(1),
  636                     /*K* FFLG.NOLIST = VALUE-BIT(1)  See M$DCB.
  637                     */
  638              3 REATTR BIT(1),
  639                     /*K* FFLG.REATTR = VALUE-BIT(1)  See M$DCB.
  640                     */
  641              3 EXEC BIT(1),
  642                     /*K* FFLG.EXEC = VALUE-BIT(1)  See M$DCB.
  643                     */
  644              3 * BIT(1),      /* CREATE                                          */
  645              3 AU BIT(1),
  646                     /*K* FFLG.AU = VALUE-BIT(1)  See M$DCB.
  647                     */
  648              3 AURD BIT(1),
  649                     /*K* FFLG.AURD = VALUE-BIT(1)  See M$DCB.
  650                     */
  651              3 TCTL BIT(1),
  652                     /*K* FFLG.TCTL = VALUE-BIT(1)  See M$DCB.
  653                     */
  654              3 * BIT(6),
  655            2 ACSVEH,
  656                     /*K* ACSVEH   Contains the access vehicle (processor)
  657                     name in TEXTC format.  The vehicle is assumed to be
  658                     in the system account, the same account as the file
  659                     being accessed, or the specified account, depending
  660                     on the format of the vehicle name. 'Name' implies the
  661                     system account, 'name.' implies the account of the file,
  662                     and 'name.account' specifies the account explicitly.
  663                     */
  664              3 C UBIN BYTE UNAL,
  665              3 T CHAR(CODE10.ACSVEH.C);
  666       %MEND;
07:10 JUL 29 '97 FM$FIT.:E05SI                                             19   
  667                     /*F* NAME: CODE11 - UATTR Information
  668
  669                     CODE11 contains information specified by UATTR on M$OPEN
  670                     or M$CLOSE. No structure is provided as it is not used
  671                     by the CP-6 system.                                          */
  672                     /*F* NAME: CODE12 - INSTATTR Information
  673
  674                     CODE12 contains information specified by INSTATTR on M$OPEN
  675                     or M$CLOSE. No structure is provided as it is not used
  676                     by the CP-6 system.                                          */
  677                     /*F* NAME: CODE13 - PROCATTR Information
  678
  679                     CODE13 contains information specified by PROCATTR on M$OPEN
  680                     or M$CLOSE. No structure is provided as it is not used
  681                     by the CP-6 system.                                          */
  682      /**/
  683      %MACRO CODE14 (LEVEL=1,END=";",MAX=0,BASED=BASED,
  684                     ACCESS=ACCESS,
  685                     WCDATA=WCDATA,
  686                     LIST=LIST,
  687                     WRCMP=WRCMP,
  688                     BUPF=BUPF,
  689                     BUPM=BUPM,
  690                     NPUR=NPUR,
  691                     OWNERF=OWNERF,
  692                     NOACUP=NOACUP,
  693                     NOSTOW=NOSTOW,
  694                     MERGEAC=MERGEAC,
  695                     X=X,
  696                     GACSHELF=GACSHELF,
  697                     NEWFD=NEWFD,
  698                     DFLTALL=DFLTALL,
  699                     CGMEM=CGMEM,
  700                     MGRANS=MGRANS,
  701                     CGRANS=CGRANS,
  702                     OWNER=OWNER,
  703                     ACCT=ACCT,
07:10 JUL 29 '97 FM$FIT.:E05SI                                             20   
  704                     NAME=NAME,
  705                     CHAR=CHAR);
  706      %LSET LEV=CHARBIN(TEXTCHAR(LEVEL));
  707      %IF LEV=1;
  708      DCL 1 CODE14 BASED ALIGNED,
  709      %ENDIF;
  710                     /*F* NAME: D_CODE14
  711                     .IBL D:CODE14
  712                     */
  713                     /*F* NAME: CODE14 - Account and File Directory Information
  714
  715                     CODE14 contains the account and file directory information.
  716                                                                                  */
  717            2 ACCESS,
  718              3 WCDATA BIT(1),
  719                     /*K* ACCESS.WCDATA = VALUE-BIT(1)  If set, specifies
  720                     that non-directory writes for the account are to be
  721                     done with checkwrite operations.
  722                     */
  723              3 LIST BIT(1),
  724                     /*K* ACCESS.LIST = VALUE-BIT(1)  If set, a
  725                     CODE09 access control list exists for the directory
  726                     */
  727              3 WRCMP BIT(1),
  728                     /*K* ACCESS.WRCMP = VALUE-BIT(1)  If set, specifies
  729                     that directory writes for the account are to be
  730                     done with checkwrite operations.
  731                     */
  732              3 BUPF BIT(1),
  733                     /*K* ACCESS.BUPF = VALUE-BIT(1)  If set, specifies
  734                     that file backup is permitted.
  735                     */
  736              3 BUPM BIT(1),
  737                     /*K* ACCESS.BUPM = VALUE-BIT(1)  Contains the
  738                     default for BUPM.
  739                     */
  740              3 NPUR BIT(1),
07:10 JUL 29 '97 FM$FIT.:E05SI                                             21   
  741                     /*K* ACCESS.NPUR = VALUE-BIT(1)  If set, files are not
  742                     to be purged.
  743                     */
  744              3 OWNERF BIT(1),
  745                     /*K* ACCESS.OWNERF = VALUE-BIT(1)  If set, users
  746                     in the account own its files.
  747                     */
  748              3 NOACUP BIT(1),
  749                     /*K* ACCESS.NOACUP = VALUE-BIT(1)  If set, the
  750                     access date is not to be maintained.
  751                     */
  752              3 NOSTOW BIT(1),
  753                     /*K* ACCESS.NOSTOW = VALUE-BIT(1)  If set, files
  754                     in the account may not be stowed.
  755                     */
  756              3 MERGEAC BIT(1),
  757                     /*K* ACCESS.MERGEAC = VALUE-BIT(1)  If set, file access control
  758                     (CODE09) appears to be concatenated on the end of the account
  759                     access control (also CODE09), instead of replacing it.
  760                     */
  761              3 X BIT(6),      /*UNUESD*/
  762              3 GACSHELF BIT(1),
  763                     /*K* ACCESS.GACSHELF = VALUE-BIT(1)  Applies to
  764                     the account directory only.  If set, shelf-time
  765                     is to be accounted separately from on-line time, which means
  766                     that a GAC run is required every time the packset
  767                     is mounted.
  768                     */
  769              3 NEWFD BIT(1),
  770                     /*K* ACCESS.NEWFD = VALUE-BIT(1)  Applies to the
  771                     account directory only.  If set, new file directories
  772                     may be created automatically.
  773                     */
  774            2 DFLTALL BIT(18),
  775                     /*K* DFLTALL = VALUE-BIT(18)  Contains default access control
  776                     flags for files.  The DFLTALL flags can be overridden
  777                by a CODE09 entry in the directory or by a specific file's access
07:10 JUL 29 '97 FM$FIT.:E05SI                                             22   
  778                control. See CODE09.FFLG for the format and
  779                meaning of the DFLTALL flags.
  780                */
  781            2 CGMEM UBIN(9)UNAL,
  782      %SET CGMEMSIZ=8;
  783                     /*K* CGMEM = VALUE-DEC(0-511)  Contains the maximum memory
  784                     (measured in %CGMEMSIZK increments)
  785                     permitted to comgroups in this account at any given time.
  786                     */
  787            2 MGRANS UBIN(27) UNAL,
  788                     /*K* MGRANS = VALUE-DEC(0-n)  Contains the maximum
  789                     granules occupied by files within an account.
  790                     MGRANS is specified in the account directory for
  791                     use when a new file directory is created.
  792                     MGRANS is specified in a file directory as the
  793                     granule authorization for the account.
  794                     */
  795            2 CGRANS SBIN WORD,
  796                     /*K* CGRANS = VALUE-DEC(0-n)  Applies to file
  797                     directories only.  CGRANS specifies the current
  798                     number of granules in this account.
  799                     */
  800            2 OWNER(0:MAX),
  801                     /*K* OWNER   Contains an array of the account/
  802                     name of user(s) authorized to modify account/set
  803                     attributes.  This information is not returned in
  804                     the FPARAM buffer.  The array is of size
  805                     (0:MAX).  The default for MAX is zero, and
  806                     may be changed by specifying MAX=value on
  807                     the macro invocation line.
  808                     */
  809              3 ACCT CHAR(8),
  810                     /*K* OWNER.ACCT = VALUE-CHAR(8) Contains the
  811                     account of an owner.
  812                     */
  813              3 NAME CHAR(12)END
  814                     /*K* OWNER.NAME = VALUE-CHAR(12) Contains the
07:10 JUL 29 '97 FM$FIT.:E05SI                                             23   
  815                     name of an owner.
  816                     */
  817       %MEND;
  818      /**/
  819      %MACRO CODE15 (BASED=BASED,CODE15=CODE15);
  820      DCL 1 CODE15 BASED ALIGNED,
  821                     /*F* NAME: D_CODE15
  822                     .IBL D:CODE15
  823                     */
  824                     /*F* NAME: CODE15 - COMGROUP File Information
  825
  826                     CODE15 contains Comgroup file information.
  827                                                                                  */
  828
  829            2 CGORG UBIN(9) UNAL,
  830                     /*K* CGORG = OPTION (see ORG in M$DCB).                      */
  831            2 QISS BIT(1),
  832                     /*K* QISS = {YES|NO}.  See QISS in M$DCB.                    */
  833            2 * BIT(26),
  834            2 *(0:2) UBIN;
  835      %MEND;
  836      /**/
  837      %MACRO CODE16 (BASED=BASED,CODE16=CODE16);
  838      DCL 1 CODE16 BASED ALIGNED,
  839                     /*F* NAME: D_CODE16
  840                     .IBL D:CODE16
  841                     */
  842                     /*F* NAME: CODE16 - Device Attributes
  843
  844                     This information is in the FIT and FPARAM buffer, and is
  845                     moved to a memory area pointed to by F$DCB.FORM$ when
  846                     a DCB is open to the file.
  847                     */
  848            2 FORM CHAR(6),
  849                     /*K* FORM = VALUE-CHAR(6)  Contains the name of the
  850                     form to be mounted on the device.
  851                     */
07:10 JUL 29 '97 FM$FIT.:E05SI                                             24   
  852            2 * CHAR(6),
  853            2 DDEV BIT(9),
  854                     /*K* DDEV = VALUE-BIT(9)  See M$DCB.
  855                     */
  856            2 * BIT(9),
  857            2 ATTR BIT(18) UNAL,
  858                     /*K* ATTR = VALUE-BIT(18)  See M$OPEN.
  859                     */
  860            2 RECNO UBIN UNAL,
  861                     /*K* RECNO = VALUE-DEC(0-n)  Contains the number of
  862                     punch records in the file.
  863                     */
  864            2 PAGENO UBIN(18) UNAL,
  865                     /*K* PAGENO = VALUE-DEC(0-n)  Contains the
  866                     number of printer pages in the file.
  867                     */
  868            2 LINENO UBIN(18) UNAL,
  869                     /*K* LINENO = VALUE-DEC(0-n)  Contains the
  870                     current line number in a printer file.
  871                     */
  872            2 PAGEBASE UBIN(18)UNAL,
  873                     /*K* PAGEBASE = VALUE-DEC(0-n)  Contains a number
  874                     to be subtracted from PAGENO to produce printer
  875                     page numbering.
  876                     */
  877            2 LINES UBIN(18) UNAL,
  878                     /*K* LINES = VALUE-DEC(1-32K)  Contains the number
  879                     of lines in a printer page.
  880                     */
  881            2 NOTCOL1 BIT(1),
  882                     /*K* NOTCOL1 = VALUE-BIT(1)  Set if the current
  883                     printer line has been printed on.
  884                     */
  885            2 COMODE BIT(1),
  886                     /*K* COMODE = VALUE-BIT(1)  Set if concurrent output mode.
  887                     */
  888            2 NSDEV BIT(1),
07:10 JUL 29 '97 FM$FIT.:E05SI                                             25   
  889                     /*B* NSDEV  Set if destination is not a streamname.
  890                     */
  891            2 NSFORM BIT(1),
  892                     /*K* NSFORM = VALUE-BIT(1)  Set if FORM is not the
  893                     installation's standard form for device type DEV
  894                     at workstation WSN.
  895                     */
  896            2 NSDDF BIT(1),
  897                     /*B* NSDDF  Set if have DDF in LDEV.
  898                     */
  899            2 F01 BIT(1),      /*for expansion*/
  900            2 F02 BIT(1),
  901            2 BANNER_CHARGES BIT (1) UNAL,
  902                     /*K* BANNER_CHARGES = VALUE-BIT(1)  if BANNER_CHARGES
  903                     is '1'B then the number of pages in BANNER_REPEATS
  904                     should be added to the number of pages accounted for
  905                     in this file.  If BANNER_CHARGES is '0'B, then no
  906                     charge is made.
  907                     */
  908            2 CONTFORM BIT(1),
  909                     /*K* CONTFORM = VALUE-BIT(1)  Set if the form describes
  910                     continuous line-printer paper (Limbo and Firstline zero)
  911                     */
  912            2 COPIES UBIN(9) UNAL,
  913                     /*K* COPIES = VALUE-DEC(1-511)  Contains the number
  914                     of times output is to be sent to the destination
  915                     device.
  916                     */
  917            2 BANNER_REPEATS UBIN (9) UNAL,
  918                     /*K* BANNER_REPEATS = VALUE-DEC(1-511)  This field is
  919                      kept for accounting purposes only.  It contains the
  920                      number of repeats for the banner to print at the
  921                      start of output.
  922                     */
  923            2 OLDSEQ,
  924              3 SEQCOL UBIN(9)UNAL,
  925                     /*K* OLDSEQ.SEQCOL = VALUE-DEC(1-255)  Contains the
07:10 JUL 29 '97 FM$FIT.:E05SI                                             26   
  926                     SEQCOL value from the last Set Sequencing record
  927                     written to the file.  This must be appended to the next
  928                     Set Sequencing record so that punch symbiont files can
  929                     be efficiently backspaced.
  930                     */
  931              3 SEQID CHAR(4) UNAL,
  932                     /*K* OLDSEQ.SEQID = VALUE-CHAR(4)  Contains the SEQID
  933                     from the last Set Sequencing record written to  the
  934                     file.  This must be appended to the next Sequencing
  935                     record so that punch symbiont files can be efficiently
  936                     backspaced.
  937                     */
  938            2 NBANNER_RECS UBIN (18) UNAL,
  939                     /*K* NBANNER_RECS = VALUE-UBIN(18)  Contains the number
  940                     of records in the banner of a symbiont file.  This is
  941                     used to eliminate symbiont files which only have banner
  942                     information in them after recovery from a crash.
  943                     */
  944            2 DEV CHAR(2),
  945                     /*K* DEV = VALUE-CHAR(2)  Contains the destination
  946                     device type.
  947                     */
  948            2 WSN CHAR(8),
  949                     /*K* WSN = VALUE-CHAR(8)  Contains the destination
  950                     workstation.
  951                     */
  952            2 OLDTABS,
  953                     /*K* OLDTABS = ARRAY(0:31)  Contains the tab settings
  954                     from the last Set Tabs record written to the file.
  955                     This information must be appended to the next
  956                     Set Tabs record so that symbiont files can be
  957                     efficiently backspaced.
  958                     */
  959              3 *(0:31)UBIN(9)UNAL,
  960            2 STEPPAGENO UBIN(18) UNAL,
  961                     /*K* STEPPAGENO = VALUE-DEC(0-n)  Contains the
  962                     last PAGENO tallied for accounting purposes.
07:10 JUL 29 '97 FM$FIT.:E05SI                                             27   
  963                     */
  964            2 STEPRECNO UBIN,
  965                     /*K* STEPRECNO = VALUE-DEC(0-n)  Contains the
  966                     last RECNO tallied for accounting purposes.
  967                     */
  968            2 DVFC CHAR(1) UNAL,
  969                     /*K* DVFC = VALUE-CHAR(1)  Contains the default
  970                     printer VFC character.
  971                     */
  972            2 WIDTH UBIN(9) UNAL,
  973                     /*K* WIDTH = VALUE-DEC(1-511)  Contains the output
  974                     width of the device.
  975                     */
  976            2 GOOD BIT(1),
  977                     /*K* GOOD = VALUE-BIT(1)  Is an internal flag
  978                     for form verification.
  979                     */
  980            2 IWL BIT(8),
  981                     /*B*  IWL = VALUE-BIT(3)  Corresponds to the internal
  982                     IWL bits in the DCB, and is used to remember which
  983                     formatting records where last written to a symbiont
  984                     file through a logical device.  The three bits
  985                     are for tabs, sequencing and page headers.  If the
  986                     IWL.TABIWL bit is set, tab settings specified in
  987                     LDEV were last sent; if it is reset, some user DCB's
  988                     tabs were last sent, so the LDEV tabs must be written
  989                     prior to a write through a user DCB with no tabs.
  990                     The bit for sequencing is used in a similar way.
  991                     Page headers are currently written directly, so
  992                     this bit is not meaningful.
  993                     */
  994            2 * BIT(9),
  995            2 VFCIM,
  996              3 LINE (0:31)UBIN(9) UNAL,
  997                     /*K* VFCIM.LINE = ARRAY(0:31)  Contains an array of
  998                     line numbers (1-511).  Entries 1 through 15
  999                     are the line numbers of the first occurrences of
07:10 JUL 29 '97 FM$FIT.:E05SI                                             28   
 1000                     channels 1 through 15 in the VFC image.  Entries
 1001                     16 through 31 are for not-first occurrences, linked
 1002                     through VFCIM.NEXT.
 1003                     */
 1004              3 NEXT (0:31)UBIN(9) UNAL;
 1005                     /*K* VFCIM.NEXT = ARRAY(0:31)  Contains an array of
 1006                     indexes into VFCIM.  A non-zero entry means that
 1007                     there is another occurrence of the channel at
 1008                     line number VFCIM.LINE (this value).
 1009                     */
 1010       %MEND;
 1011                     /*F* NAME: CODE17 - FPRG Information
 1012
 1013                     CODE17 contains information specified by FPRG on M$OPEN.
 1014                     The VLP_FPRG macro is used to generate the CODE17 structure.
 1015                     This information is found in the FIT and the FPARAM buffer
 1016                     and is moved into the read-only segment during open. It may
 1017                     be located at an offset of F$DCB.FPRGX from B$ROSEG$.        */
 1018      %MACRO CODE18 (BASED=BASED, CODE18=CODE18);
 1019                     /*F* NAME: D_CODE18
 1020                     .IBL D:CODE18
 1021                     */
 1022                     /*F* NAME: CODE18 - Physical Field Organization of a Record
 1023
 1024                     This information is in the FIT and FPARAM buffer.  It may
 1025                     be in Keyed, Indexed, Consecutive, Relative, and IREL
 1026                     files.  It represents the physical order of fields in a
 1027                     record, including a data type and length for each field
 1028                     specified. Its structure is identical to VLP_RECFIELD.
 1029                     */
 1030      DCL 1 CODE18 BASED ALIGNED,
 1031            2 VLPID   UBIN(9) CALIGNED,
 1032                     /*K* VLPID = VALUE-DEC(511) specifies the identifier
 1033                     which differentiates a VLP_RECFIELD from other VLPs
 1034                     which may be specified in the same vector location on
 1035                     an M$OPEN or M$CLOSE. Although this value is only
 1036                     useful in a VLP_RECFIELD, it is carried in the
07:10 JUL 29 '97 FM$FIT.:E05SI                                             29   
 1037                     CODE18 as well.                                              */
 1038
 1039            2 NFIELDS UBIN(27) CALIGNED,
 1040                     /*K* NFIELDS = VALUE-DEC(0-511) specifies the number of
 1041                     elements in the CODE18.FIELD or CODE18.DECFIELD array.
 1042                     */
 1043
 1044            2 DECFIELD(0:0),
 1045                     /*K* DECFIELD - The array used for decimal fields in a
 1046                     record.  Length values are in bytes for data types:
 1047                     UDNS, UDLS, UDTS, UDLO, UDTO, and UDFLT.  Length values
 1048                     are in nibbles for data types:  PDTA, PDTE, PDNS, PDLA,
 1049                     PDLE, PDFLT, DATE, and TIME.                                 */
 1050
 1051              3 TYPE UBIN(6) UNAL,
 1052                     /*K* DECFIELD.TYPE = VALUE-DEC(0-63) specifies the data
 1053                     type of the field.  Use data type definitions found in
 1054                     the %VREBL_DATATYPES macro in the B$OBJECT_C include file.   */
 1055
 1056              3 LEN UBIN(6) UNAL,
 1057                     /*K* DECFIELD.LEN = VALUE-DEC(1-63) The length of the
 1058                     field.                                                       */
 1059
 1060              3 SCALE SBIN(6) UNAL,
 1061                     /*K* DECFIELD.SCALE = VALUE-DEC(-32 - 31) The scale factor
 1062                     for decimal fields.                                          */
 1063
 1064            2 FIELD(0:0) REDEF DECFIELD,
 1065                     /*K* FIELD - The array used for non-decimal fields in a
 1066                     record. Length values are in bytes for data types:  NO,
 1067                     SFLT, DFLT, CHAR, TEXTC, and TEXTH. The length value
 1068                     for data type LIST determines the number of elements
 1069                     in the list (array).  The length for data type VLIST
 1070                     contains the index into CODE18.FIELD or CODE18.DECFIELD
 1071                     of the count field which determines the number of
 1072                     elements in the variable length list.  Length values
 1073                     are in bits for data types: SBIN, UBIN, and UTS.             */
07:10 JUL 29 '97 FM$FIT.:E05SI                                             30   
 1074
 1075              3 TYPE UBIN(6) UNAL,
 1076                     /*K* FIELD.TYPE = VALUE-DEC(0-63) specifies the data
 1077                     type of the field.  Use data type definitions found in
 1078                     the %VREBL_DATATYPES macro in the B$OBJECT_C include file.   */
 1079
 1080              3 LEN UBIN(12) UNAL;
 1081                     /*K* FIELD.LEN = VALUE-DEC(1-4095) The length of the
 1082                     field.                                                       */
 1083
 1084      %MEND;
 1085      /* */
 1086      %MACRO CODE19 (BASED=BASED, CODE19=CODE19);
 1087                     /*F* NAME: D_CODE19
 1088                     .IBL D:CODE19
 1089                     */
 1090                     /*F* NAME: CODE19 - IREL Keys, Part 1
 1091
 1092                     This information is in the FIT and FPARAM buffer.  It
 1093                     applies to IREL files only.  It contains user supplied
 1094                     information about the keys and is identical to VLP_IRKEYS.
 1095
 1096                     */
 1097      DCL 1 CODE19 BASED ALIGNED,
 1098            2 NKEYS UBIN,
 1099                     /*K* NKEYS = VALUE-DEC(0-n)  Contains the number of keys
 1100                     defined in the file.                                         */
 1101            2 K(0:0),
 1102
 1103              3 KEYEND BIT(1) UNAL,
 1104                     /*K* KEYEND = VALUE-BIT(1) Specifies the end of a new
 1105                     key definition.                                              */
 1106              3 UNIQUE BIT(1) UNAL,
 1107                     /*K* UNIQUE = VALUE-BIT(1) Specifies that this key must
 1108                     be unique.  UNIQUE is only meaningful for the first
 1109                     field of a key.                                              */
 1110              3 * BIT(7) UNAL,
07:10 JUL 29 '97 FM$FIT.:E05SI                                             31   
 1111
 1112              3 FIELDN UBIN(9) CALIGNED;
 1113                     /*K* FIELDN = VALUE-DEC(0-511)  Specifies the field number
 1114                     (index into a CODE18 or VLP_RECFIELD field array) for
 1115                     this key fragment.                                           */
 1116      %MEND;
 1117      /* */
 1118      %MACRO CODE20 (BASED=BASED, CODE20=CODE20);
 1119                     /*F* NAME: D_CODE20
 1120                     .IBL D:CODE20
 1121                     */
 1122                     /*F* NAME: CODE20 - IREL Keys, Part 2
 1123
 1124                     This information is in the FIT only.  It applies to
 1125                     IREL files only.  CODE20 contains information
 1126                     necessary for file management, but not the user.
 1127                     */
 1128      DCL 1 CODE20 BASED ALIGNED,
 1129            2 NKEYS UBIN,
 1130                     /*K* NKEYS = VALUE-DEC(0-n)  Contains the number of
 1131                     keys defined.                                                */
 1132            2 ALTBLD BIT(1) UNAL,
 1133                     /*K* ALTBLD = VALUE-BIT(1)  Indicates whether the alternate
 1134                     keys need to be rebuilt.                                     */
 1135
 1136            2 UNIQUEBLD BIT(1) UNAL,
 1137                     /*K* UNIQUEBLD = VALUE-BIT(1) Indicates whether or not
 1138                     the unique indexes need to be rebuilt.                       */
 1139
 1140            2 * BIT(34) UNAL,
 1141            2 K(0:0) ALIGNED,
 1142
 1143              3 TDALVL UBIN(9) CALIGNED,
 1144                     /*K* TDALVL = VALUE-DEC(0-511)  The top level number for
 1145                     the upper level structure.                                   */
 1146              3 TDA UBIN(27) CALIGNED,
 1147                     /*K* TDA = VALUE-DEC(0-n)  Contains the file relative
07:10 JUL 29 '97 FM$FIT.:E05SI                                             32   
 1148                     disk address of the first index granule at the top of
 1149                     the multi-level structure.  If no such structure exists,
 1150                      TDA contains zero.                                          */
 1151              3 FDA UBIN(27) CALIGNED,
 1152                     /*K* CDA = VALUE-DEC(0-n)  Contains the file relative
 1153                     disk address of the first index granule for this index.      */
 1154              3 LDA UBIN(27) CALIGNED,
 1155                     /*K* LDA = VALUE-DEC(0-n)  Contains the file relative
 1156                     disk address of the last index granule for this index.       */
 1157              3 DEGENERATE BIT(1) UNAL,
 1158                     /*K* DEGENERATE = VALUE-BIT(1)  Indicates that this index is
 1159                     entirely composed of fields whose data types allow them to be
 1160                     compared using a normal ASCII compare, rather than needing
 1161                     special effort.
 1162                     ..::IX "Optical Disk\CODE20.CONTIGUOUS"
 1163                     */
 1164              3 CONTIGUOUS BIT(1) UNAL,
 1165                     /*K* CONTIGUOUS = VALUE-BIT(1)  Indicates that this key is
 1166                     entirely composed of fields that are contiguous within the data
 1167                     record, allowing them to be compared as a unit, rather than
 1168                     field-by-field.
 1169                     ..::IX "Optical Disk\CODE20.DEGENERATE"
 1170                     */
 1171              3 * UBIN(7) UNAL,
 1172              3 * UBIN(9) CALIGNED;
 1173      %MEND;
 1174      /**/
 1175      %MACRO CODE21 (BASED=BASED, CODE21=CODE21);
 1176                     /*F* NAME: D_CODE21
 1177                     .IBL D:CODE21
 1178                     */
 1179                     /*F* NAME: CODE21 - Logical Field Organization of a Record
 1180
 1181                     This information is in the FIT and FPARAM buffer.  It
 1182                     may be in Keyed, Indexed, Consecutive, Relative, and
 1183                     IREL files.  It represents the logical order of fields
 1184                     in a record.  This information is never used by file
07:10 JUL 29 '97 FM$FIT.:E05SI                                             33   
 1185                     management and is solely for the convenience of
 1186                     various processors and/or the user.  Its structure is
 1187                     identical to VLP_IRREC.
 1188                     */
 1189      DCL 1 CODE21 BASED ALIGNED,
 1190            2 VLPID   UBIN(9) CALIGNED,
 1191                     /*K* VLPID = VALUE-DEC(511) specifies the identifier
 1192                     which differentiates a VLP_IRREC from other VLPs
 1193                     which may be specified in the same vector location on
 1194                     an M$OPEN or M$CLOSE. Although this value is only
 1195                     useful in a VLP_IRREC, it is carried in the CODE21
 1196                     as well.                                                     */
 1197
 1198            2 NFIELDS UBIN(27) CALIGNED,
 1199                     /*K* NFIELDS = VALUE-DEC(0-511)  Specifies the number
 1200                     of elements in the CODE21.FIELDN array.  This value may
 1201                     be less than or equal to CODE18.NFIELDS.                     */
 1202
 1203            2 FIELDN(0:0) UBIN BYTE CALIGNED;
 1204                     /*K* FIELDN - An array of field indexes.  Each element
 1205                     contains an index into the corresponding CODE18.FIELD
 1206                     or CODE18.DECFIELD array.  Hence, element values range
 1207                     from 0-511.                                                  */
 1208      %MEND;
 1209      /**/
 1210                     /*F* NAME: WILD_COMPARE a chunk of code that compares two
 1211                     character strings, one of which may contain the wildcard
 1212                     character '?' or be the all-matching string 'ALL'. Each string
 1213                     is terminated by a blank or the size limit of the variable. The
 1214                     code drops through if a match is found. Optionally, the number
 1215                     of -wildcard matching characters is returned. The following
 1216                     substitutions are useful:
 1217                COMP_COUNT = UBIN variable in which to return non-wild match count.
 1218                Default is NO, implying no count returned.
 1219                NO_MATCH = any PL6 statement, executed if the strings don't match.
 1220                Default is ALTRETURN.
 1221                WILD_CHARS = CHAR variable containing the wildcard character string.
07:10 JUL 29 '97 FM$FIT.:E05SI                                             34   
 1222                WILD_MAX = UBIN expression of the size limit of WILD_CHARS.
 1223                Default is 0, which generates SIZEC(WILD_CHARS).
 1224                COMPARE_CHARS and COMPARE_MAX as above, but for the other string.
 1225                WILD_X,WILD_XP,COMPARE_X,COMPARE_XP = UBIN variables required
 1226                to do the comparison.  WILD_XC is a CHAR(4) redef of WILD_X
 1227                used in the Host to make the ALL string case-insensitive.
 1228                In the Fep, it is a CHAR(2) redef of WILD_X.
 1229
 1230                */
 1231      /* */
 1232      %MACRO WILD_COMPARE (COMP_COUNT=NO,
 1233           NO_MATCH=ALTRETURN,
 1234           WILD_CHARS=WILD_CHARS,
 1235           COMPARE_CHARS=COMPARE_CHARS,
 1236           WILD_X=WILD_X,WILD_XP=WILD_XP,WILD_XC=WILD_XC,
 1237           COMPARE_X=COMPARE_X,COMPARE_XP=COMPARE_XP,
 1238           WILD_MAX=0,
 1239           COMPARE_MAX=0);
 1240      %LSET LISTDIR='0'B;
 1241      %LSET LISTEXP='1'B;
 1242      %LSET LISTSUB='1'B;
 1243      %LSET COUNT=TEXTCHAR(COMP_COUNT);
 1244      %LSET CMAX=TEXTCHAR(COMPARE_MAX);
 1245      %IF CMAX='0';
 1246      %LSET CMAX=CHARTEXT(CONCAT('SIZEC(',TEXTCHAR(COMPARE_CHARS),')'));
 1247      %ELSE;
 1248      %LSET CMAX=CHARTEXT(%CMAX);
 1249      %ENDIF;
 1250      %LSET WMAX=TEXTCHAR(WILD_MAX);
 1251      %IF WMAX='0';
 1252      %LSET WMAX=CHARTEXT(CONCAT('SIZEC(',TEXTCHAR(WILD_CHARS),')'));
 1253      %ELSE;
 1254      %LSET WMAX=CHARTEXT(%WMAX);
 1255      %ENDIF;
 1256      /*!C!*/
 1257      %IF NOT MODE_FEP;
 1258              WILD_XC=WILD_CHARS;
07:10 JUL 29 '97 FM$FIT.:E05SI                                             35   
 1259              IF (BINBIT(WILD_X,36)&'737737737777'O)='101114114040'O THEN DO;
 1260                 WILD_X=3;
 1261                 WILD_XP=2;
 1262                 END;
 1263      %ELSE;
 1264              WILD_XC=SUBSTR(WILD_CHARS,0,2);
 1265              IF (BINBIT(WILD_X,16)&'DFDF'X)='414C'X THEN DO;
 1266                 WILD_XC=SUBSTR(WILD_CHARS,2,2);
 1267                 IF (BINBIT(WILD_X,16)&'DFDF'X)~='4C20'X THEN EXIT;
 1268                 WILD_X=3;
 1269                 WILD_XP=2;
 1270                 END;
 1271      %ENDIF;
 1272              ELSE DO;
 1273                 WILD_X=0;
 1274                 WILD_XP=%WMAX;
 1275                 END;
 1276              COMPARE_X=0;
 1277              COMPARE_XP=0;
 1278      %IF COUNT~='NO';
 1279              COMP_COUNT=0;
 1280      %ENDIF;
 1281              DO WHILE(WILD_X<%WMAX AND SUBSTR(WILD_CHARS,WILD_X,1)~=' '
 1282                OR COMPARE_X<%CMAX AND SUBSTR(COMPARE_CHARS,COMPARE_X,1)~=' ');
 1283                 IF WILD_X<%WMAX AND SUBSTR(WILD_CHARS,WILD_X,1)='?' THEN DO;
 1284                    WILD_XP=WILD_X;
 1285                    END;
 1286                 ELSE DO;
 1287                    IF WILD_X=WILD_XP+1 THEN COMPARE_XP=COMPARE_X;
 1288                    IF WILD_X>=%WMAX
 1289                      OR COMPARE_X>=%CMAX
 1290                      OR SUBSTR(WILD_CHARS,WILD_X,1) ~=
 1291                      SUBSTR(COMPARE_CHARS,COMPARE_X,1) THEN DO;
 1292                       IF WILD_XP=%WMAX OR COMPARE_XP=%CMAX
 1293                       THEN NO_MATCH;
 1294                       WILD_X=WILD_XP;
 1295      %IF COUNT~='NO';
07:10 JUL 29 '97 FM$FIT.:E05SI                                             36   
 1296                       COMP_COUNT=COMP_COUNT-COMPARE_X+COMPARE_XP;
 1297      %ENDIF;
 1298                       COMPARE_X=COMPARE_XP;
 1299                       END;
 1300      %IF COUNT~='NO';
 1301                    ELSE COMP_COUNT=COMP_COUNT+1;
 1302      %ENDIF;
 1303                    COMPARE_X=COMPARE_X+1;
 1304                    END;
 1305                 IF WILD_X<%WMAX THEN WILD_X=WILD_X+1;
 1306      END;
 1307      %IF COUNT~='NO';
 1308              IF WILD_XP=%WMAX THEN COMP_COUNT=%WMAX;
 1309      %ENDIF;
 1310      /*!!*/
 1311      %MEND;
 1312                     /*F* NAME: XSF$LOCCODx - Get FIT Data or FIT Index
 1313
 1314                     Several services are provided to access data in
 1315                     the FIT and FIT header.  These services have the
 1316                     form:
 1317
 1318                     CALL XSF$LOCCODx (FIT$,CODE) ALTRET (label);
 1319
 1320                     where
 1321
 1322                     XSF$LOCCODx  is the service name.  The various names and the
 1323                         function of each service are described in the table below.
 1324
 1325                FIT$  Is a pointer to the beginning of the FPARAM buffer.  For the
 1326                contents of FIT$ on return from the service, see the table
 1327                below.
 1328
 1329                CODE  Contains the code of a FIT data section, right-justified
 1330                in one word.  For the contents of CODE on return from the
 1331                service, see the table below.
 1332
07:10 JUL 29 '97 FM$FIT.:E05SI                                             37   
 1333
 1334                .INL +27
 1335                .UNL 27
 1336                Service               Result
 1337                .UNL 27
 1338                -------------------------------------------------------------------
 1339                .UNL 27
 1340                XSF$LOCCODE           FIT$ points to the FIT data section specified
 1341                by CODE
 1342                .UNL 5
 1343                CODE contains the index of the data section
 1344                entry in FIT header
 1345                }
 1346                .UNL 27
 1347                XSF$LOCCODX           FIT$ is unchanged
 1348                .UNL 5
 1349                CODE contains the index of the data section
 1350                entry in the FIT header
 1351                }
 1352                .UNL 27
 1353                XSF$LOCCODT           FIT$ points to the data section specified by
 1354                CODE if there is significant data
 1355                in the section (i.e., if FM$FIT.CODES.NDW
 1356                is not zero)
 1357                .UNL 5
 1358                CODE is unchanged.
 1359                }
 1360                .UNL 27
 1361                XSF$LOCCODP           FIT$ points to the data section specified by
 1362                CODE
 1363                .UNL 5
 1364                CODE is unchanged.
 1365                .INL -27
 1366
 1367
 1368                The alternate return is taken if the data section
 1369                requested by CODE is not contained in the FPARAM
07:10 JUL 29 '97 FM$FIT.:E05SI                                             38   
 1370                buffer.  The alternate return is also taken
 1371                for XSF$LOCCODT if the requested data section
 1372                contains no significant data.
 1373                */
 1374                     /*B* FMO$LOCCODx  - The monitor service names are
 1375                     as follows:  FMO$LOCCODE, FMO$LOCCODX, FMO$LOCCODT,
 1376                     FMO$LOCCODP.   Their functions are identical to
 1377                     the library services with the prefix XSF$.
 1378                     */
 1379      %MACRO LOCCODE(PREF=XSF);
 1380      %LSET LISTDIR='0'B;
 1381      %LSET LISTEXP='1'B;
 1382      %LSET LISTSUB='1'B;
 1383      %LSET LOCE=CHARTEXT(CONCAT(TEXTCHAR(PREF),'$LOCCODE'));
 1384      %LSET LOCX=CHARTEXT(CONCAT(TEXTCHAR(PREF),'$LOCCODX'));
 1385      %LSET LOCT=CHARTEXT(CONCAT(TEXTCHAR(PREF),'$LOCCODT'));
 1386      %LSET LOCP=CHARTEXT(CONCAT(TEXTCHAR(PREF),'$LOCCODP'));
 1387      /*!C!*/
 1388      %LOCE:  PROC(FIT$,CODE) ALTRET;
 1389      DCL FIT$ PTR;
 1390      DCL CODE UBIN;
 1391      DCL I UBIN;
 1392      DCL NC UBIN;
 1393      DCL ENTNO UBIN;
 1394      %LSET LISTMAC='0'B;
 1395      %FM$FIT(BASED="BASED(FIT$)");
 1396      %LIST;
 1397              ENTNO=0;
 1398              GOTO MAINLOOP;
 1399      %LOCX:  ENTRY(FIT$,CODE) ALTRET;
 1400              ENTNO=2;
 1401              GOTO MAINLOOP;
 1402      %LOCT:  ENTRY(FIT$,CODE)ALTRET;
 1403              ENTNO=3;
 1404              GOTO MAINLOOP;
 1405      %LOCP:  ENTRY(FIT$,CODE) ALTRET;
 1406              ENTNO=1;
07:10 JUL 29 '97 FM$FIT.:E05SI                                             39   
 1407      MAINLOOP:
 1408              NC=FM$FIT.CODES.CODE(0);
 1409              DO I= 1 TO NC;
 1410                 IF FM$FIT.CODES.CODE(I)=CODE THEN DO CASE(ENTNO);
 1411                  CASE(0);
 1412                    FIT$=PINCRW(FIT$,FM$FIT.CODES.ITEMX(I));
 1413                    CODE=I;
 1414                    RETURN;
 1415                  CASE(1);
 1416                    FIT$=PINCRW(FIT$,FM$FIT.CODES.ITEMX(I));
 1417                    RETURN;
 1418                  CASE(2);
 1419                    CODE=I;
 1420                    RETURN;
 1421                  CASE(3);
 1422                    IF FM$FIT.CODES.NDW(I)=0 THEN ALTRETURN;
 1423                    FIT$=PINCRW(FIT$,FM$FIT.CODES.ITEMX(I));
 1424                    RETURN;
 1425                  END;
 1426                 END;
 1427              ALTRETURN;
 1428      END %LOCE;
 1429      /*!!*/
 1430      %MEND;

