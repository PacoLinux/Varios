

14:55 JUL 28 '97 KV$VDO.:E05SI                                             1    
    1      /*M* KV$VDO CP-6 Presentation protocol definition */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*F* NAME: KV$VDO - VDO Header.
    8
    9      */
   10      %MACRO KV$VDO(NAME = KV$VDO, LVL = 1, LAST = ";", STCLASS = BASED,
   11      FNC = 0, VLP = '0'B, STR = 0);
   12      %LSET LISTDIR = '0'B;
   13      %LSET LISTEXP = '1'B;
   14      %LSET LISTCOM = '0'B;
   15      %LSET LISTSUB = '1'B;
   16      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   17      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   18      %IF STC = 1;
   19      %LSET INIT = CHARTEXT(' INIT');
   20      %LSET ENIT = CHARTEXT('');
   21      %ELSE;
   22      %LSET INIT = CHARTEXT('/*');
   23      %LSET ENIT = CHARTEXT('*/');
   24      %ENDIF;
   25      %LSET FEP = BITBIN(MODE_FEP);
   26      %SET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
   27      %SET KV_DBLBYT = 18-2*FEP;
   28      %SET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
   29      %SET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
   30      %IF LVL = 1;
   31      DCL 1 NAME STCLASS %KV_DBLBYTALG,
   32      %ELSE;
   33      %LVL NAME %KV_DBLBYTALG,
   34      %ENDIF;
   35      %(LVL+1) %CHARTEXT('FNC') UBIN BYTE %INIT(FNC)%ENIT CALIGNED,
   36      /*K* FNC = value.  Function of this VDO.
   37      */
14:55 JUL 28 '97 KV$VDO.:E05SI                                             2    
   38         %KV_FILBIT
   39      %(LVL+1) %CHARTEXT('VLP') BIT(1) %INIT(VLP)%ENIT UNAL,
   40      /*K* VLP = YES or NO.  YES specifies that VLPs are present.
   41      */
   42      %(LVL+1) %CHARTEXT('STR') UBIN(7) %INIT(STR)%ENIT UNAL LAST
   43      /*K* STR = value.  Identifies what stream this VDO is addressed to.
   44      */
   45      %MEND;
   46      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             3    
   47      /*F* NAME:  KV$VDO_BLKDAT - Block data (for flow control). (E)
   48      Function values:  KV_VDO_FNC_BLKDAT.
   49      Legal VLPs:  CG_MSGTYP, CG_STA.
   50      */
   51      %MACRO KV$VDO_BLKDAT(NAME = KV$VDO_BLKDAT, LVL = 1, LAST = ";", STCLASS = BASED,
   52      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
   53      FNC(KV_VDO_FNC_BLKDAT = %KV_VDO_FNC_BLKDAT) = %KV_VDO_FNC_BLKDAT,
   54      RSN = 0,
   55      RCRBYTSIZ = 0);
   56      %LSET LISTDIR = '0'B;
   57      %LSET LISTEXP = '1'B;
   58      %LSET LISTCOM = '0'B;
   59      %LSET LISTSUB = '1'B;
   60      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   61      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
   62      %LSET INIT = CHARTEXT(' INIT');
   63      %LSET ENIT = CHARTEXT('');
   64      %ELSE;
   65      %LSET INIT = CHARTEXT('/*');
   66      %LSET ENIT = CHARTEXT('*/');
   67      %ENDIF;
   68      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
   69      %(LVL+1) %CHARTEXT('RCRBYTSIZ') UBIN(%KV_DBLBYT) %INIT(RCRBYTSIZ)%ENIT %KV_DBLBYTALG,
   70      /*K* RCRBYTSIZ = value.  Specifies the byte size of the
   71      record that was to be sent but got blocked.
   72      */
   73      %(LVL+1) %CHARTEXT('RSN') UBIN BYTE CALIGNED %INIT(RSN)%ENIT,
   74      /*K* RSN = value.  Specifies the reason for blocking.  Values are
   75      KV_BLKRSN_...
   76      */
   77      %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%ENIT LAST
   78      %MEND;
   79      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             4    
   80      /*F* NAME:  KV$VDO_CLSSSN - close session. (NOT E)
   81      Function values:  KV_VDO_FNC_CLSSSN_RQS, KV_VDO_FNC_CLSSSN_RSP.
   82      Legal VLPs:  MRK.
   83      */
   84      %MACRO KV$VDO_CLSSSN(NAME = KV$VDO_CLSSSN, LVL = 1, LAST = ";", STCLASS = BASED,
   85      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
   86      RSN=0,
   87      FNC(KV_VDO_FNC_CLSSSN_RQS = %KV_VDO_FNC_CLSSSN_RQS,
   88       KV_VDO_FNC_CLSSSN_RSP = %KV_VDO_FNC_CLSSSN_RSP) = );
   89      %LSET LISTDIR = '0'B;
   90      %LSET LISTEXP = '1'B;
   91      %LSET LISTCOM = '0'B;
   92      %LSET LISTSUB = '1'B;
   93      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   94      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
   95      %LSET INIT = CHARTEXT(' INIT');
   96      %LSET ENIT = CHARTEXT('');
   97      %ELSE;
   98      %LSET INIT = CHARTEXT('/*');
   99      %LSET ENIT = CHARTEXT('*/');
  100      %ENDIF;
  101      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  102      %(LVL+1) %CHARTEXT('RSN') UBIN(%KV_DBLBYT) %INIT(RSN)%ENIT %KV_DBLBYTALG LAST
  103      /*K* RSN = value.  If non-zero, indicates an error code that caused the
  104      session to be closed. */
  105      %MEND;
  106      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             5    
  107      /*F* NAME:  KV$VDO_CLSSTR - close a stream. (NOT E)
  108      Function values:  KV_VDO_FNC_CLSSTR.
  109      Legal VLPs:  MRK.
  110      */
  111      %MACRO KV$VDO_CLSSTR (NAME = KV$VDO_CLSSTR, LVL = 1, LAST = ";", STCLASS = BASED,
  112       DLT (YES = '1'B, NO = '0'B) = '0'B, NEWSSN (YES = '1'B, NO = '0'B) = '0'B,
  113       VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  114       FNC (KV_VDO_FNC_CLSSTR = %KV_VDO_FNC_CLSSTR) = %KV_VDO_FNC_CLSSTR);
  115      %LSET LISTDIR = '0'B;
  116      %LSET LISTEXP = '1'B;
  117      %LSET LISTCOM = '0'B;
  118      %LSET LISTSUB = '1'B;
  119      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  120      %IF STC = 'STA' OR STC = 'CON' OR STC = 'EXT';
  121      %LSET INIT = CHARTEXT('INIT');
  122      %LSET ENIT = CHARTEXT('');
  123      %ELSE;
  124      %LSET INIT = CHARTEXT('/*');
  125      %LSET ENIT = CHARTEXT('*/');
  126      %ENDIF;
  127      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  128         %KV_FILBIT
  129      %(LVL+1) %CHARTEXT('DLT') BIT(1) %INIT(DLT)%ENIT,
  130      /*K* DLT = {YES|NO}.  Specifies whether the stream (and its window, if it has
  131      one) is to be removed.  This parameter is ignored if NEWSSN = YES. */
  132      %(LVL+1) %CHARTEXT('NEWSSN') BIT(1) %INIT(NEWSSN)%ENIT,
  133      /*K* NEWSSN = {YES|NO}.  Specifies whether this stream (and its window, if
  134      it has one) is to be disassociated from the current session and used to start
  135      a new session.  The optional ??? may be used to specify where to connect
  136      the new session. */
  137      %(LVL+1) * BIT(%(KV_DBLBYT/2+6)) %INIT('0'B)%ENIT LAST
  138      %MEND;
  139      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             6    
  140      /*F* NAME:  KV$VDO_DAT - Data. (E)
  141      Function values:  KV_VDO_FNC_DAT, KV_VDO_FNC_DAT_IMD.
  142      Legal VLPs:  CG_MSGTYP, CG_STA, DAT1, DAT2, ERR, {FLDID | KEY}, MRK.
  143      */
  144      %MACRO KV$VDO_DAT(NAME = KV$VDO_DAT, LVL = 1, LAST = ";", STCLASS = BASED,
  145      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  146       FNC(KV_VDO_FNC_DAT = %KV_VDO_FNC_DAT,
  147      KV_VDO_FNC_DAT_IMD = %KV_VDO_FNC_DAT_IMD) = ,
  148      CTN_NXT(YES = '1'B, NO = '0'B) = '0'B,
  149      CTN_PRV(YES = '1'B, NO = '0'B) = '0'B,
  150      DCBHDR(YES = '1'B, NO = '0'B) = '0'B,
  151      DATCTRCHRTYP = %KV_DATCTRCHRTYP_NON,
  152      DATMOD(NRM = %KV_DATMOD_NRM, TRN = %KV_DATMOD_TRN,
  153             BNR = %KV_DATMOD_BNR, ANY = %KV_DATMOD_ANY) = %KV_DATMOD_NRM,
  154      DATCTRCHR = ' ');
  155      %LSET LISTDIR = '0'B;
  156      %LSET LISTEXP = '1'B;
  157      %LSET LISTCOM = '0'B;
  158      %LSET LISTSUB = '1'B;
  159      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  160      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  161      %LSET INIT = CHARTEXT(' INIT');
  162      %LSET ENIT = CHARTEXT('');
  163      %ELSE;
  164      %LSET INIT = CHARTEXT('/*');
  165      %LSET ENIT = CHARTEXT('*/');
  166      %ENDIF;
  167      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  168         %KV_FILBIT
  169      %(LVL+1) %CHARTEXT('CTN') UNAL,
  170      %(LVL+2) %CHARTEXT('NXT') BIT(1) %INIT(CTN_NXT)%ENIT UNAL,
  171      /*K* CTN.NXT = YES or NO.  YES indicates this is not the last portion of a
  172      continued record.  See CTN.PRV.  Continuation is a process invoked
  173      by the presentation layer user via DVBYTE.CONT.
  174      */
  175      %(LVL+2) %CHARTEXT('PRV') BIT(1) %INIT(CTN_PRV)%ENIT UNAL,
  176      /*K* CTN.PRV = YES or NO.  YES indicates this is not the first
14:55 JUL 28 '97 KV$VDO.:E05SI                                             7    
  177      portion of a continued record.  A record that isn't
  178      continued has both CTN.NXT and CTN.PRV reset.  A record
  179      that is continued but isn't the first or the last
  180      portion has both CTN.NXT and CTN.PRV set.
  181      */
  182      %(LVL+1) %CHARTEXT('DCBHDR') BIT(1) %INIT(DCBHDR)%ENIT UNAL,
  183      /*K* DCBHDR = YES or NO.  YES indicates this is a write through
  184      a DCB other than M$UC for which a header has been set.
  185      */
  186      %(LVL+1) * BIT(1) %INIT('0'B)%ENIT UNAL,
  187      %(LVL+1) %CHARTEXT('DATCTRCHRTYP') UBIN(2) %INIT(DATCTRCHRTYP)%ENIT UNAL,
  188      /*K* DATCTRCHRTYP = value.  Specifies the type of control character
  189      (if any) being passed.  Values are KV_DATCTRCHRTYP_...,
  190      specifying, for instance, VFC character, activation character,
  191      or no character passed.
  192      */
  193      %(LVL+1) %CHARTEXT('DATMOD') UBIN(2) %INIT(DATMOD)%ENIT UNAL,
  194      /*K* DATMOD = value.  Specifies the mode of the data:
  195      Binary, transparent, or 'normal' (not binary or transparent).
  196      Values are KV_DATMOD_...
  197      */
  198      %(LVL+1) %CHARTEXT('DATCTRCHR') CHAR(1) %INIT(DATCTRCHR)%ENIT CALIGNED LAST
  199      /*K* DATCTRCHR = value.  Specifies the VFC or activation character,
  200      if any.
  201      */
  202      %MEND;
  203      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             8    
  204      /*F* NAME:  KV$VDO_DCLFLD - declare field. (NOT E)
  205      Function values:  KV_VDO_FNC_DCLFLD.
  206      Legal VLPs:  DAT1, DAT2, {FLDID | KEY}, MRK.
  207      */
  208      %MACRO KV$VDO_DCLFLD(NAME = KV$VDO_DCLFLD, LVL = 1, LAST = ";", STCLASS = BASED,
  209      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  210      FNC(KV_VDO_FNC_DCLFLD = %KV_VDO_FNC_DCLFLD) = %KV_VDO_FNC_DCLFLD,
  211      LIN = 0, CLM = 0, ID = 0, WDT = 0);
  212      %LSET LISTDIR = '0'B;
  213      %LSET LISTEXP = '1'B;
  214      %LSET LISTCOM = '0'B;
  215      %LSET LISTSUB = '1'B;
  216      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  217      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  218      %LSET INIT = CHARTEXT(' INIT');
  219      %LSET ENIT = CHARTEXT('');
  220      %ELSE;
  221      %LSET INIT = CHARTEXT('/*');
  222      %LSET ENIT = CHARTEXT('*/');
  223      %ENDIF;
  224      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  225
  226      /* Line that this field starts in, relative to the origin of */
  227      /* the elementary virtual device. */
  228
  229      %(LVL+1) %CHARTEXT('LIN') UBIN(%KV_DBLBYT) %INIT(LIN)%ENIT %KV_DBLBYTALG,
  230
  231      /* Column that this field starts in, relative to the origin of */
  232      /* the elementary virtual device. */
  233
  234      %(LVL+1) %CHARTEXT('CLM') UBIN(%KV_DBLBYT) %INIT(CLM)%ENIT %KV_DBLBYTALG,
  235
  236      /* Width of field (in columns) */
  237
  238      %(LVL+1) %CHARTEXT('WDT') SBIN(%KV_DBLBYT) %INIT(WDT)%ENIT %KV_DBLBYTALG,
  239         %KV_FILBIT
  240      %LSET NXTLVL = LVL+1;
14:55 JUL 28 '97 KV$VDO.:E05SI                                             9    
  241      %G$QLF (NAME = QLF, LVL = NXTLVL, STCLASS = STCLASS, LAST = ",");
  242         %KV_FILBIT
  243
  244      %LSET NXTLVL = LVL+1;
  245      %G$GRPRND (NAME = GRPRND, LVL = NXTLVL, STCLASS = STCLASS, LAST = ",");
  246
  247      /* Field identifier. */
  248
  249      %(LVL+1) %CHARTEXT('ID') UBIN(%KV_DBLBYT) %INIT(ID)%ENIT %KV_DBLBYTALG LAST
  250      %MEND;
  251      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             10   
  252      /*F* NAME:  KV$VDO_DCLSTR - declare new stream. (NOT E)
  253      Function values:  KV_VDO_FNC_DCLSTR.
  254      Legal VLPs:  MRK.
  255      */
  256      %MACRO KV$VDO_DCLSTR (NAME = KV$VDO_DCLSTR, LVL = 1, LAST = ";", STCLASS = BASED,
  257       VLP(YES='1'B, NO='0'B)='0'B, STR=0, STRID=0, RE_STR(YES='1'B, NO='0'B)='0'B,
  258       FNC (KV_VDO_FNC_DCLSTR = %KV_VDO_FNC_DCLSTR) = %KV_VDO_FNC_DCLSTR);
  259      %LSET LISTDIR = '0'B;
  260      %LSET LISTEXP = '1'B;
  261      %LSET LISTCOM = '0'B;
  262      %LSET LISTSUB = '1'B;
  263      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  264      %IF STC = 'STA' OR STC = 'CON' OR STC = 'EXT';
  265      %LSET INIT = CHARTEXT('INIT');
  266      %LSET ENIT = CHARTEXT('');
  267      %ELSE;
  268      %LSET INIT = CHARTEXT('/*');
  269      %LSET ENIT = CHARTEXT('*/');
  270      %ENDIF;
  271      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  272      %(LVL+1) %CHARTEXT('STRID') UBIN BYTE CALIGNED %INIT(STRID)%ENIT,
  273      /*K* STRID = value.  Specifies the stream-id for the new stream.  The stream
  274      will be created streaming through the same virtual device as STR (the stream
  275      this VDO was received for.  SETPRM with PRMID_WINDOW may be used to create
  276      a MVD-SRD pair to separate this stream from its original one. */
  277       %KV_FILBIT
  278      %(LVL+1) %CHARTEXT('RE_STR') BIT(1) %INIT(RE_STR)%ENIT,
  279      /*K* RE_STR = YES or NO.  YES specifies that this is to be a re-streaming
  280      operation.  The stream along which this was sent (STR) is to be streamed
  281      through the virtual device through which STRID is currently streamed.  If
  282      Both streams must currently be closed or open to ORG=UR/TERMINAL devices.
  283      If the restreaming results in an unused virtual device, that device and
  284      any associated window will be deleted. */
  285      %(LVL+1) * BIT(7) %INIT('0'B)%ENIT LAST
  286      %MEND;
  287      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             11   
  288      /*F* NAME:  KV$VDO_DLT - delete. (NOT E)
  289      Function values:  KV_VDO_FNC_DLT.
  290      Legal VLPs:  MRK.
  291      */
  292      %MACRO KV$VDO_DLT(NAME = KV$VDO_DLT, LVL = 1, LAST = ";", STCLASS = BASED,
  293      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  294      FNC(KV_VDO_FNC_DLT = %KV_VDO_FNC_DLT) = %KV_VDO_FNC_DLT,
  295      DLTINP(YES = '1'B, NO = '0'B) = '0'B,
  296      DLTOTP(YES = '1'B, NO = '0'B) = '0'B,
  297      ABRRED(YES = '1'B, NO = '0'B) = '0'B,
  298      CRSHER(YES = '1'B, NO = '0'B) = '0'B,
  299      RSTBRKCNT(YES = '1'B, NO = '0'B) = '0'B);
  300      %LSET LISTDIR = '0'B;
  301      %LSET LISTEXP = '1'B;
  302      %LSET LISTCOM = '0'B;
  303      %LSET LISTSUB = '1'B;
  304      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  305      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  306      %LSET INIT = CHARTEXT(' INIT');
  307      %LSET ENIT = CHARTEXT('');
  308      %ELSE;
  309      %LSET INIT = CHARTEXT('/*');
  310      %LSET ENIT = CHARTEXT('*/');
  311      %ENDIF;
  312      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  313      %(LVL+1) CTLFLG UNAL,
  314      %(LVL+2) * BIT(%(4-BITBIN(MODE_FEP)))%INIT('0'B)%ENIT,
  315      %(LVL+2) %CHARTEXT('CRSHER') BIT(1) %INIT(CRSHER)%ENIT,
  316      /*K* CRSHER = YES or NO.  YES indicates the current session should be made
  317      the active one.
  318      */
  319      %(LVL+2) %CHARTEXT('ABRRED') BIT(1) %INIT(ABRRED)%ENIT UNAL,
  320      /*K* ABRRED = YES or NO.  YES indicates the current no-wait read should
  321      be terminated with an E$OPER error.
  322      */
  323      %(LVL+2) %CHARTEXT('RSTBRKCNT') BIT(1) %INIT(RSTBRKCNT)%ENIT UNAL,
  324      /*K* RSTBRKCNT = YES or NO.  YES indicates the break count
14:55 JUL 28 '97 KV$VDO.:E05SI                                             12   
  325      should be reset.
  326      */
  327      %(LVL+2) %CHARTEXT('DLTINP') BIT(1) %INIT(DLTINP)%ENIT UNAL,
  328      /*K* DLTINP = YES or NO.  YES indicates input (e.g., type-ahead)
  329      should be deleted.
  330      */
  331      %(LVL+2) %CHARTEXT('DLTOTP') BIT(1) %INIT(DLTOTP)%ENIT UNAL,
  332      /*K* DLTOTP = YES or NO.  YES indicates output
  333      should be deleted.
  334      */
  335      %(LVL+1) * BIT(%(KV_DBLBYT/2)) %INIT('0'B)%ENIT LAST
  336      %MEND;
  337      /*F* NAME:  KV$VDO_DSC - disconnect. (NOT E)
  338      Function values:  KV_VDO_FNC_DSC_RQS, KV_VDO_FNC_DSC_RSP.
  339      Legal VLPs:  ERR, MRK.
  340
  341      The disconnect sequence is normally initiated with DSC_RQS.
  342      When DSC_RQS is sent or received, the sender or receiver:
  343      1  Can no longer solicit specific data (do a "read") from the
  344         distant end.
  345      2  Must abort, with no response (no DAT VDO), any request
  346         previously received from the distant end for specific data
  347         ("read"), and disallow future requests for specific data.
  348
  349      Either end can send DSC_RQS.  Only 1 end needs to send it,
  350      i.e., once DSC_RQS has been received, it shouldn't be sent.
  351      If DSC_RQS is received after having been sent (the collision case),
  352      the DSC_RQS sent by the end that DIDN'T send the KN_FCN_INIT
  353      is ignored (i.e., session-initiator wins collisions).
  354
  355      When the recipient of DSC_RQS no longer wants to send any
  356      request-type messages, it sends DSC_RSP.  It can still respond
  357      to requests (except for specific data) from the distant end.
  358
  359      When the recipient of DSC_RSP no longer wants to send any request-type
  360      messages, and has received any desired responses to previous
  361      requests, and is ready to complete the disconnection including
14:55 JUL 28 '97 KV$VDO.:E05SI                                             13   
  362      releasing the session connection, it sends KN_FCN_TERM.  It can
  363      no longer send any messages.
  364
  365      When the recipient of KN_FCN_TERM is ready to complete the
  366      disconnection, it sends KN_FCN_TERM_ACK, thereby releasing the
  367      session connection.
  368
  369      Receipt of KN_FCN_TERM_ACK indicates the session connection has
  370      been released.
  371
  372      The disconnect sequence may (in the abnormal case) be accelerated.
  373      In this case, KN_FCN_TERM_ACK is sent without sending DSC_RQS and/or
  374      DSC_RSP and/or KN_FCN_TERM_ACK.  The effects of sending/receiving
  375      DSC_RQS and/or DSC_RSP and/or KN_FCN_TERM
  376      should be simulated.
  377      */
  378      %MACRO KV$VDO_DSC(NAME = KV$VDO_DSC, LVL = 1, LAST = ";", STCLASS = BASED,
  379      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  380      FNC(KV_VDO_FNC_DSC_RQS = %KV_VDO_FNC_DSC_RQS,
  381       KV_VDO_FNC_DSC_RSP = %KV_VDO_FNC_DSC_RSP) = ,
  382      INTPHSDSC (YES = '1'B, NO = '0'B) = '0'B);
  383      %LSET LISTDIR = '0'B;
  384      %LSET LISTEXP = '1'B;
  385      %LSET LISTCOM = '0'B;
  386      %LSET LISTSUB = '1'B;
  387      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  388      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  389      %LSET INIT = CHARTEXT(' INIT');
  390      %LSET ENIT = CHARTEXT('');
  391      %ELSE;
  392      %LSET INIT = CHARTEXT('/*');
  393      %LSET ENIT = CHARTEXT('*/');
  394      %ENDIF;
  395      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  396         %KV_FILBIT
  397      %(LVL+1) %CHARTEXT('INTPHSDSC') BIT(1) %INIT(INTPHSDSC)%ENIT UNAL,
  398      /*K* INTPHSDSC = YES or NO.  YES indicates the recipient should initiate
14:55 JUL 28 '97 KV$VDO.:E05SI                                             14   
  399      a physical disconnect (e.g., disconnect the telephone line).
  400      */
  401      %(LVL+1) * BIT(%(KV_DBLBYT/2+7)) %INIT('0'B)%ENIT LAST
  402      %MEND;
  403      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             15   
  404      /*F* NAME:  KV$VDO_ERS - erase. (NOT E)
  405      Function values:  KV_VDO_FNC_ERS.
  406      Legal VLPs:  {FLDID | KEY}, MRK.
  407      */
  408      %MACRO KV$VDO_ERS(NAME = KV$VDO_ERS, LVL = 1, LAST = ";", STCLASS = BASED,
  409      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  410      FNC(KV_VDO_FNC_ERS = %KV_VDO_FNC_ERS) = %KV_VDO_FNC_ERS,
  411      PRT(YES = '1'B, NO = '0'B) = '0'B,
  412      CNS(YES = '1'B, NO = '0'B) = '0'B);
  413      %LSET LISTDIR = '0'B;
  414      %LSET LISTEXP = '1'B;
  415      %LSET LISTCOM = '0'B;
  416      %LSET LISTSUB = '1'B;
  417      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  418      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  419      %LSET INIT = CHARTEXT(' INIT');
  420      %LSET ENIT = CHARTEXT('');
  421      %ELSE;
  422      %LSET INIT = CHARTEXT('/*');
  423      %LSET ENIT = CHARTEXT('*/');
  424      %ENDIF;
  425      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  426         %KV_FILBIT
  427
  428      /* Erase protected fields.  (Erasing unprotected is implicit.) */
  429
  430      %(LVL+1) %CHARTEXT('PRT') BIT(1) %INIT('0'B)%ENIT UNAL,
  431
  432      /* Erase constant fields.  Erasing unprotected fields, and */
  433      /* erasing protected but not constant fields is implicit. */
  434
  435      %(LVL+1) %CHARTEXT('CNS') BIT(1) %INIT('0'B)%ENIT UNAL,
  436      %(LVL+1) * BIT(%(KV_DBLBYT/2+6)) %INIT('0'B)%ENIT UNAL LAST
  437      %MEND;
  438      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             16   
  439      /*F* NAME:  KV$VDO_EVT - event. (NOT E)
  440      Function values:  KV_VDO_FNC_EVT.
  441      Legal VLPs:  MRK.
  442      */
  443      %MACRO KV$VDO_EVT(NAME = KV$VDO_EVT, LVL = 1, LAST = ";", STCLASS = BASED,
  444      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  445      FNC(KV_VDO_FNC_EVT = %KV_VDO_FNC_EVT) = %KV_VDO_FNC_EVT,
  446      BRKCNT = 0, TYP (KV_EVTTYP_BRK = %KV_EVTTYP_BRK,
  447       KV_EVTTYP_MNTATN = %KV_EVTTYP_MNTATN) = 0);
  448      %LSET LISTDIR = '0'B;
  449      %LSET LISTEXP = '1'B;
  450      %LSET LISTCOM = '0'B;
  451      %LSET LISTSUB = '1'B;
  452      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  453      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  454      %LSET INIT = CHARTEXT(' INIT');
  455      %LSET ENIT = CHARTEXT('');
  456      %ELSE;
  457      %LSET INIT = CHARTEXT('/*');
  458      %LSET ENIT = CHARTEXT('*/');
  459      %ENDIF;
  460      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  461      %(LVL+1) %CHARTEXT('BRKCNT') UBIN BYTE %INIT(BRKCNT)%ENIT CALIGNED,
  462      /*K* BRKCNT - value.  For KV_EVTTYP_BRK, BRKCNT specifies the
  463      contiguous break count.
  464      */
  465      %(LVL+1) %CHARTEXT('TYP') UBIN BYTE %INIT(TYP)%ENIT CALIGNED LAST
  466      /*K* TYP = value.  Specifies the type of event (e.g., break,
  467      monitor attention, etc.).
  468      Values are KV_EVTTYP_...
  469      */
  470      %MEND;
  471      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             17   
  472      /*F* NAME:  KV$VDO_MRK - marker. (NOT E)
  473      Function values:  KV_VDO_FNC_MRK.
  474      Legal VLPs:  ERR, MRK.
  475      MRK is the only legal VDO for returning ENDACK markers.
  476      MRK is used for returning markers (KV$VDOVLP_MRK).
  477      */
  478      %MACRO KV$VDO_MRK(NAME = KV$VDO_MRK, LVL = 1, LAST = ";", STCLASS = BASED,
  479      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  480      FNC (KV_VDO_FNC_MRK = %KV_VDO_FNC_MRK) = %KV_VDO_FNC_MRK);
  481      %LSET LISTDIR = '0'B;
  482      %LSET LISTEXP = '1'B;
  483      %LSET LISTCOM = '0'B;
  484      %LSET LISTSUB = '1'B;
  485      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  486      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  487      %LSET INIT = CHARTEXT(' INIT');
  488      %LSET ENIT = CHARTEXT('');
  489      %ELSE;
  490      %LSET INIT = CHARTEXT('/*');
  491      %LSET ENIT = CHARTEXT('*/');
  492      %ENDIF;
  493      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  494      %MEND;
  495      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             18   
  496      /*F* NAME:  KV$VDO_HVPS - horizontal vertical position, short. (NOT E)
  497      Function values:  KV_VDO_FNC_HVPS.
  498      Legal VLPs:  MRK.
  499      */
  500      %MACRO KV$VDO_HVPS(NAME = KV$VDO_HVPS, LVL = 1, LAST = ";", STCLASS = BASED,
  501      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  502      FNC(KV_VDO_FNC_HVPS = %KV_VDO_FNC_HVPS) = %KV_VDO_FNC_HVPS,
  503      LIN = 0, CLM = 0);
  504      %LSET LISTDIR = '0'B;
  505      %LSET LISTEXP = '1'B;
  506      %LSET LISTCOM = '0'B;
  507      %LSET LISTSUB = '1'B;
  508      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  509      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  510      %LSET INIT = CHARTEXT(' INIT');
  511      %LSET ENIT = CHARTEXT('');
  512      %ELSE;
  513      %LSET INIT = CHARTEXT('/*');
  514      %LSET ENIT = CHARTEXT('*/');
  515      %ENDIF;
  516      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  517
  518      /* Line (on page or screen). */
  519
  520            %(LVL+1) %CHARTEXT('LIN') UBIN BYTE CALIGNED %INIT(LIN)%ENIT,
  521
  522      /* Column. */
  523
  524            %(LVL+1) %CHARTEXT('CLM') UBIN BYTE CALIGNED %INIT(CLM)%ENIT LAST
  525      %MEND;
  526      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             19   
  527      /*F* NAME:  KV$VDO_NOP - No operation. (NOT E)
  528      Function values:  KV_VDO_FNC_NOP.
  529      Legal VLPs:  MRK.
  530      This VDO is used when only a VLP needs to be conveyed, and the
  531      action to take is implied by the VLP.
  532      */
  533      %MACRO KV$VDO_NOP(NAME = KV$VDO_NOP, LVL = 1, LAST = ";", STCLASS = BASED,
  534      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  535      FNC(KV_VDO_FNC_NOP = %KV_VDO_FNC_NOP) = %KV_VDO_FNC_NOP);
  536      %LSET LISTDIR = '0'B;
  537      %LSET LISTEXP = '1'B;
  538      %LSET LISTCOM = '0'B;
  539      %LSET LISTSUB = '1'B;
  540      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  541      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  542      %LSET INIT = CHARTEXT(' INIT');
  543      %LSET ENIT = CHARTEXT('');
  544      %ELSE;
  545      %LSET INIT = CHARTEXT('/*');
  546      %LSET ENIT = CHARTEXT('*/');
  547      %ENDIF;
  548      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  549      %MEND;
  550      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             20   
  551      /*F* NAME:  KV$VDO_OPNSSN - open session. (NOT E)
  552      Function values:  KV_VDO_FNC_OPNSSN_RQS, KV_VDO_FNC_OPNSSN_RSP.
  553      Legal VLPs:  MRK.
  554      */
  555      %MACRO KV$VDO_OPNSSN(NAME = KV$VDO_OPNSSN, LVL = 1, LAST = ";", STCLASS = BASED,
  556      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  557      FNC(KV_VDO_FNC_OPNSSN_RQS = %KV_VDO_FNC_OPNSSN_RQS,
  558       KV_VDO_FNC_OPNSSN_RSP = %KV_VDO_FNC_OPNSSN_RSP) = );
  559      %LSET LISTDIR = '0'B;
  560      %LSET LISTEXP = '1'B;
  561      %LSET LISTCOM = '0'B;
  562      %LSET LISTSUB = '1'B;
  563      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  564      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  565      %LSET INIT = CHARTEXT(' INIT');
  566      %LSET ENIT = CHARTEXT('');
  567      %ELSE;
  568      %LSET INIT = CHARTEXT('/*');
  569      %LSET ENIT = CHARTEXT('*/');
  570      %ENDIF;
  571      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  572      %(LVL+1) * BIT(%KV_DBLBYT) %INIT('0'B)%ENIT LAST
  573      /*N* Things to do with opn:
  574      Set MAXBLKBYTSIZ
  575      Set MAXRCRBYTSIZ (1 for transparent, 1 for non-transparent,
  576         used when RQSDAT DATMOD = ANY)
  577      Negotiate
  578         Concatenation
  579         Segmenatation
  580         Input/output legal
  581         TWS/TWA
  582         FLWCTR for non-essential control messages?
  583         Protocol version/level
  584      */
  585      %MEND;
  586      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             21   
  587      /*F* NAME:  KV$VDO_PRM - Parameters. (E)
  588      Function values:  KV_VDO_FNC_PRM_SET, KV_VDO_FNC_PRM_RSP.
  589      Legal VLPs:  CG_MSGTYP, CG_STA, DAT1, DAT2, ERR, MRK.
  590      The parameter structures are passed via KV$VDOVLP_DAT1
  591      or KV$VDOVLP_DAT2.
  592      */
  593      %MACRO KV$VDO_PRM(NAME = KV$VDO_PRM, LVL = 1, LAST = ";", STCLASS = BASED,
  594      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  595      FNC(KV_VDO_FNC_PRM_RSP = %KV_VDO_FNC_PRM_RSP,
  596       KV_VDO_FNC_PRM_SET = %KV_VDO_FNC_PRM_SET) = );
  597      %LSET LISTDIR = '0'B;
  598      %LSET LISTEXP = '1'B;
  599      %LSET LISTCOM = '0'B;
  600      %LSET LISTSUB = '1'B;
  601      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  602      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  603      %LSET INIT = CHARTEXT(' INIT');
  604      %LSET ENIT = CHARTEXT('');
  605      %ELSE;
  606      %LSET INIT = CHARTEXT('/*');
  607      %LSET ENIT = CHARTEXT('*/');
  608      %ENDIF;
  609      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  610      %MEND;
  611      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             22   
  612      /*F* NAME:  KV$VDO_OPNSTR - begin use of a stream. (NOT E)
  613      Function values:  KV_VDO_FNC_OPNSTR.
  614      Legal VLPs:  MRK.
  615      */
  616      %MACRO KV$VDO_OPNSTR (NAME = KV$VDO_OPNSTR, LVL = 1, LAST = ";", STCLASS = BASED,
  617       VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0, ORG = 0, NRECS = 0, KEYL = 0, SPARE = 0,
  618       FNC (KV_VDO_FNC_OPNSTR = %KV_VDO_FNC_OPNSTR) = %KV_VDO_FNC_OPNSTR);
  619      %LSET LISTDIR = '0'B;
  620      %LSET LISTEXP = '1'B;
  621      %LSET LISTCOM = '0'B;
  622      %LSET LISTSUB = '1'B;
  623      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  624      %IF STC = 'STA' OR STC = 'CON' OR STC = 'EXT';
  625      %LSET INIT = CHARTEXT('INIT');
  626      %LSET ENIT = CHARTEXT('');
  627      %ELSE;
  628      %LSET INIT = CHARTEXT('/*');
  629      %LSET ENIT = CHARTEXT('*/');
  630      %ENDIF;
  631      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  632      %(LVL+1) %CHARTEXT('ORG') UBIN BYTE CALIGNED %INIT(ORG)%ENIT,
  633      /*K* ORG = value.  Specifies the intended use of the stream using the EQUs
  634      from the KV#VD_ORG_E macro in KV_GLBCNS_E.  If ORG is not TERMINAL, only one
  635      DCB may be open to the stream at once.  This should be checked before sending
  636      this VDO, as VDH can only enforce it at the stream level.
  637
  638
  639       */
  640      %(LVL+1) %CHARTEXT('NRECS') UBIN BYTE CALIGNED %INIT(NRECS)%ENIT,
  641      /*K* NRECS = value.  Specifies, for ORG=SE, the requested size of the  VDH
  642      record set.  VDH limits this value to between the screen length and 50. */
  643      %(LVL+1) %CHARTEXT('KEYL') UBIN BYTE CALIGNED %INIT(KEYL)%ENIT,
  644      /*K* KEYL = value.  Specifies, for ORG=SE, the length of the keys to be used.
  645      VDH limits this value to between 1 and 4, inclusive. */
  646      %(LVL+1) %CHARTEXT('SPARE') UBIN BYTE CALIGNED %INIT(SPARE)%ENIT LAST
  647      /*K* SPARE = value.  Specifies, for ORG=SE, the number of records that may
  648      be missing from VDH's record set below which E$RECORDS_NEEDED will not occur.
14:55 JUL 28 '97 KV$VDO.:E05SI                                             23   
  649      VDH limits this value to between 1 and NREC/4. */
  650      %MEND;
  651      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             24   
  652      /*F* NAME:  KV$VDO_RLSFLD - release field. (NOT E)
  653      Function values:  KV_VDO_FNC_RLSFLD.
  654      Legal VLPs:  {FLDID | KEY}, MRK.
  655      */
  656      %MACRO KV$VDO_RLSFLD(NAME = KV$VDO_RLSFLD, LVL = 1, LAST = ";", STCLASS = BASED,
  657      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  658      FNC(KV_VDO_FNC_RLSFLD = %KV_VDO_FNC_RLSFLD) = %KV_VDO_FNC_RLSFLD);
  659      %LSET LISTDIR = '0'B;
  660      %LSET LISTEXP = '1'B;
  661      %LSET LISTCOM = '0'B;
  662      %LSET LISTSUB = '1'B;
  663      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  664      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  665      %LSET INIT = CHARTEXT(' INIT');
  666      %LSET ENIT = CHARTEXT('');
  667      %ELSE;
  668      %LSET INIT = CHARTEXT('/*');
  669      %LSET ENIT = CHARTEXT('*/');
  670      %ENDIF;
  671      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  672      %MEND;
  673      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             25   
  674      /*F* NAME:  KV$VDO_RMS - reset mode, short. (NOT E)
  675      Function values:  KV_VDO_FNC_RMS.
  676      Legal VLPs:  {FLDID | KEY}, MRK.
  677      */
  678      %MACRO KV$VDO_RMS(NAME = KV$VDO_RMS, LVL = 1, LAST = ";", STCLASS = BASED,
  679      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  680      FNC(KV_VDO_FNC_RMS = %KV_VDO_FNC_RMS) = %KV_VDO_FNC_RMS);
  681      %LSET LISTDIR = '0'B;
  682      %LSET LISTEXP = '1'B;
  683      %LSET LISTCOM = '0'B;
  684      %LSET LISTSUB = '1'B;
  685      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  686      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  687      %LSET INIT = CHARTEXT(' INIT');
  688      %LSET ENIT = CHARTEXT('');
  689      %ELSE;
  690      %LSET INIT = CHARTEXT('/*');
  691      %LSET ENIT = CHARTEXT('*/');
  692      %ENDIF;
  693      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  694      %MEND;
  695      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             26   
  696      /*F* NAME:  KV$VDO_RQSDAT - Request data. (E)
  697      Function values:  KV_VDO_FNC_RQSDAT.
  698      Legal VLPs:  CG_MSGTYP, CG_STA, {FLDID | KEY}, MRK.
  699      */
  700      %MACRO KV$VDO_RQSDAT(NAME = KV$VDO_RQSDAT, LVL = 1, LAST = ";", STCLASS = BASED,
  701      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  702      FNC(KV_VDO_FNC_RQSDAT = %KV_VDO_FNC_RQSDAT) = %KV_VDO_FNC_RQSDAT,
  703      MAXRCRBYTSIZ = 0,
  704      MAXNMBRCR = 0,
  705      MAXNMBBYT = 0,
  706      INCMAXNMBRCR(YES = '1'B, NO = '0'B) = '0'B,
  707      INCMAXNMBBYT(YES = '1'B, NO = '0'B) = '0'B,
  708      RE_RED(YES = '1'B, NO = '0'B) = '0'B,
  709      BP(YES = '1'B, NO = '0'B) = '0'B,
  710      DATMOD(NRM = %KV_DATMOD_NRM, TRN = %KV_DATMOD_TRN,
  711             BNR = %KV_DATMOD_BNR, ANY = %KV_DATMOD_ANY) = %KV_DATMOD_ANY,
  712      EOFNO_DAT(YES = '1'B, NO = '0'B) = '0'B,
  713      READMLT(YES = '1'B, NO = '0'B) = '0'B,
  714      WAT(YES = '1'B, NO = '0'B) = '1'B);
  715      %LSET LISTDIR = '0'B;
  716      %LSET LISTEXP = '1'B;
  717      %LSET LISTCOM = '0'B;
  718      %LSET LISTSUB = '1'B;
  719      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  720      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  721      %LSET INIT = CHARTEXT(' INIT');
  722      %LSET ENIT = CHARTEXT('');
  723      %ELSE;
  724      %LSET INIT = CHARTEXT('/*');
  725      %LSET ENIT = CHARTEXT('*/');
  726      %ENDIF;
  727      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  728      %(LVL+1) %CHARTEXT('MAXRCRBYTSIZ') UBIN(%KV_DBLBYT) %INIT(MAXRCRBYTSIZ)%ENIT %KV_DBLBYTALG,
  729      /*K* MAXRCRBYTSIZ = value.  Specifies the maximum record byte size
  730      acceptable.
  731      */
  732      %(LVL+1) %CHARTEXT('MAXNMBRCR') UBIN(%KV_DBLBYT) %INIT(MAXNMBRCR)%ENIT %KV_DBLBYTALG,
14:55 JUL 28 '97 KV$VDO.:E05SI                                             27   
  733      /*K* MAXNMBRCR = value.  Specifies the maximum number of records
  734      that can be sent by the recipient of this message before being
  735      told it can send more.
  736      */
  737      %(LVL+1) %CHARTEXT('MAXNMBBYT') UBIN(%KV_DBLBYT) %INIT(MAXNMBBYT)%ENIT %KV_DBLBYTALG,
  738      /*K* MAXNMBBYT = value.  Specifies the maximum number of bytes
  739      that can be sent by the recipient of this message before being
  740      told it can send more.
  741      */
  742         %KV_FILBIT
  743      %(LVL+1) %CHARTEXT('INCMAXNMBRCR') BIT(1) %INIT(INCMAXNMBRCR)%ENIT UNAL,
  744      /*K* INCMAXNMBRCR = YES or NO.  YES specifies that MAXNMBRCR is an
  745      increment, else MAXNMBRCR is the new absolute value.
  746      */
  747      %(LVL+1) %CHARTEXT('INCMAXNMBBYT') BIT(1) %INIT(INCMAXNMBBYT)%ENIT UNAL,
  748      /*K* INCMAXNMBBYT = YES or NO.  YES specifies that MAXNMBBYT is an
  749      increment, else MAXNMBBYT is the new absolute value.
  750      */
  751      %(LVL+1) %CHARTEXT('RE_RED') BIT(1) %INIT(RE_RED)%ENIT UNAL,
  752      /*K* RE_RED = YES or NO.  YES indicates the input edit buffer for
  753      this stream should be copied to the current read buffer and
  754      displayed as input.
  755      */
  756      %(LVL+1) %CHARTEXT('DATMOD') UBIN(2) %INIT(DATMOD)%ENIT UNAL,
  757      /*K* DATMOD = value.  Specifies the mode of the data:
  758      Binary, transparent, 'normal' (not binary or transparent,
  759      or 'any' (for data requests where no specific mode is
  760      required).  Values are KV_DATMOD_...
  761      */
  762      %(LVL+1) %CHARTEXT('EOFNO_DAT') BIT(1) %INIT(EOFNO_DAT)%ENIT UNAL,
  763      /*K* EOFNO_DAT = YES or NO.  YES specifies that if there is no data to
  764      send, and immediate EOF (end of file) should be reported.
  765      */
  766      %(LVL+1) %CHARTEXT('WAT') BIT(1) %INIT(WAT)%ENIT UNAL,
  767      /*K* WAT = YES or NO.  YES specifies that the request for data
  768      must be satisfied before any other synchronous data transfer
  769      is legal.  NO specifies that the request for data isn't enabled
14:55 JUL 28 '97 KV$VDO.:E05SI                                             28   
  770      until data for it starts to become available.
  771      */
  772      %(LVL+1) %CHARTEXT('BP') BIT(1) %INIT(BP)%ENIT,
  773      /*K* BP = YES or NO.  Specifies (currently only implemented for ORG=SE) that
  774      trailing blanks are not to be stripped from returned records, and that null
  775      records at end of file are to be returned.  */
  776         %KV_FILBIT
  777      %(LVL+1) %CHARTEXT('READMLT') BIT(1) %INIT(READMLT)%ENIT,
  778      /*K* READMLT = YES or NO.  YES specifies that more than one VDO_DAT may
  779      be returned at a time.  MAXNMBBYT specifies the total buffer available for
  780      the VDOs.  READMLT is only useful if it is possible for more than one data
  781      record to become available at once, as occurs with ORG=FORM and perhaps
  782      ORG=SE.  INPUNT=RCR might also someday benefit from READMLT.
  783      */
  784      %(LVL+1) * BIT(7) %INIT('0'B)%ENIT LAST
  785      %MEND;
  786      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             29   
  787      /*F* NAME:  KV$VDO_RQSMRK - request marker. (NOT E)
  788      Function values:  KV_VDO_FNC_RQSMRK.
  789      Legal VLPs:  MRK.
  790      The KV$VDO_RQSMRK VDO always passes a KV$VDOVLP_MRK.  KV$VDOVLP_MRK.MRKTYP
  791      passes the type of marker to be returned via a KV$VDO_MRK VDO.
  792      */
  793      %MACRO KV$VDO_RQSMRK(NAME = KV$VDO_RQSMRK, LVL = 1, LAST = ";", STCLASS = BASED,
  794      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  795      FNC (KV_VDO_FNC_RQSMRK = %KV_VDO_FNC_RQSMRK) = %KV_VDO_FNC_RQSMRK);
  796      %LSET LISTDIR = '0'B;
  797      %LSET LISTEXP = '1'B;
  798      %LSET LISTCOM = '0'B;
  799      %LSET LISTSUB = '1'B;
  800      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  801      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  802      %LSET INIT = CHARTEXT(' INIT');
  803      %LSET ENIT = CHARTEXT('');
  804      %ELSE;
  805      %LSET INIT = CHARTEXT('/*');
  806      %LSET ENIT = CHARTEXT('*/');
  807      %ENDIF;
  808      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  809      %MEND;
  810      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             30   
  811      /*F* NAME:  KV$VDO_RQSPRM - Request parameters. (NOT E)
  812      Function values:  KV_VDO_FNC_RQSPRM.
  813      Legal VLPs:  CG_MSGTYP, CG_STA, MRK.
  814      */
  815      %MACRO KV$VDO_RQSPRM(NAME = KV$VDO_RQSPRM, LVL = 1, LAST = ";", STCLASS = BASED,
  816      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  817      FNC(KV_VDO_FNC_RQSPRM = %KV_VDO_FNC_RQSPRM) = %KV_VDO_FNC_RQSPRM,
  818      PRMID = 0,
  819      MAXNMBBYT = 0);
  820      %LSET LISTDIR = '0'B;
  821      %LSET LISTEXP = '1'B;
  822      %LSET LISTCOM = '0'B;
  823      %LSET LISTSUB = '1'B;
  824      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  825      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  826      %LSET INIT = CHARTEXT(' INIT');
  827      %LSET ENIT = CHARTEXT('');
  828      %ELSE;
  829      %LSET INIT = CHARTEXT('/*');
  830      %LSET ENIT = CHARTEXT('*/');
  831      %ENDIF;
  832      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  833      %(LVL+1) %CHARTEXT('PRMID') UBIN BYTE %INIT(PRMID)%ENIT CALIGNED,
  834      /*K* PRMID = value.  Specifies what parameter is being requested.
  835      Values are KV_PRMID_...
  836      The requested parameters will be returned via KV$VDO_PRM.
  837      */
  838      %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%ENIT,
  839      %(LVL+1) %CHARTEXT('MAXNMBBYT') UBIN(%KV_DBLBYT) %INIT(MAXNMBBYT)%ENIT %KV_DBLBYTALG LAST
  840      /*K* MAXNMBBYT = value.  Specifies the maximum number of bytes
  841      of parameters to return.
  842      */
  843      %MEND;
  844      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             31   
  845      /*F* NAME:  KV$VDO_RQSSTT - request status. (NOT E)
  846      Function values:  KV_VDO_FNC_RQSSTT.
  847      Legal VLPs:  MRK.
  848      */
  849      %MACRO KV$VDO_RQSSTT(NAME = KV$VDO_RQSSTT, LVL = 1, LAST = ";", STCLASS = BASED,
  850      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  851      FNC(KV_VDO_FNC_RQSSTT = %KV_VDO_FNC_RQSSTT) = %KV_VDO_FNC_RQSSTT);
  852      %LSET LISTDIR = '0'B;
  853      %LSET LISTEXP = '1'B;
  854      %LSET LISTCOM = '0'B;
  855      %LSET LISTSUB = '1'B;
  856      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  857      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  858      %LSET INIT = CHARTEXT(' INIT');
  859      %LSET ENIT = CHARTEXT('');
  860      %ELSE;
  861      %LSET INIT = CHARTEXT('/*');
  862      %LSET ENIT = CHARTEXT('*/');
  863      %ENDIF;
  864      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  865      %MEND;
  866      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             32   
  867      /*F* NAME:  KV$VDO_SLCFLD - select field. (NOT E)
  868      Function values:  KV_VDO_FNC_SLCFLD.
  869      Legal VLPs:  {FLDID | KEY}, MRK.
  870
  871      KEY or FLDID identifies what field is to be selected.
  872      The KEY format is established at open time to be field-id,
  873      line/column coordinates, etc.
  874
  875      The absence of a FLDID or KEY causes all fields to be selected.
  876      */
  877      %MACRO KV$VDO_SLCFLD(NAME = KV$VDO_SLCFLD, LVL = 1, LAST = ";", STCLASS = BASED,
  878      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  879      FNC(KV_VDO_FNC_SLCFLD = %KV_VDO_FNC_SLCFLD) = %KV_VDO_FNC_SLCFLD);
  880      %LSET LISTDIR = '0'B;
  881      %LSET LISTEXP = '1'B;
  882      %LSET LISTCOM = '0'B;
  883      %LSET LISTSUB = '1'B;
  884      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  885      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  886      %LSET INIT = CHARTEXT(' INIT');
  887      %LSET ENIT = CHARTEXT('');
  888      %ELSE;
  889      %LSET INIT = CHARTEXT('/*');
  890      %LSET ENIT = CHARTEXT('*/');
  891      %ENDIF;
  892      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  893      %MEND;
  894      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             33   
  895      /*F* NAME:  KV$VDO_SLCGRPRND - select graphic rendition. (NOT E)
  896      Function values:  KV_VDO_FNC_SLCGRPRND.
  897      Legal VLPs:  {FLDID | KEY}, MRK.
  898      */
  899      %MACRO KV$VDO_SLCGRPRND(NAME = KV$VDO_SLCGRPRND, LVL = 1, LAST = ";", STCLASS = BASED,
  900      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  901      FNC(KV_VDO_FNC_SLCGRPRND = %KV_VDO_FNC_SLCGRPRND) = %KV_VDO_FNC_SLCGRPRND);
  902      %LSET LISTDIR = '0'B;
  903      %LSET LISTEXP = '1'B;
  904      %LSET LISTCOM = '0'B;
  905      %LSET LISTSUB = '1'B;
  906      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  907      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  908      %LSET INIT = CHARTEXT(' INIT');
  909      %LSET ENIT = CHARTEXT('');
  910      %ELSE;
  911      %LSET INIT = CHARTEXT('/*');
  912      %LSET ENIT = CHARTEXT('*/');
  913      %ENDIF;
  914      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  915         %KV_FILBIT
  916
  917      %LSET NXTLVL = LVL+1;
  918      %G$GRPRND (NAME = GRPRND, LVL = NXTLVL, STCLASS = STCLASS, LAST = ",");
  919      %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%ENIT LAST
  920      %MEND;
  921      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             34   
  922      /*F* NAME:  KV$VDO_SLCQLF - select qualification. (NOT E)
  923      Function values:  KV_VDO_FNC_SLCQLF.
  924      Legal VLPs:  {FLDID | KEY}, MRK.
  925      */
  926      %MACRO KV$VDO_SLCQLF(NAME = KV$VDO_SLCQLF, LVL = 1, LAST = ";", STCLASS = BASED,
  927      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  928      FNC(KV_VDO_FNC_SLCQLF = %KV_VDO_FNC_SLCQLF) = %KV_VDO_FNC_SLCQLF);
  929      %LSET LISTDIR = '0'B;
  930      %LSET LISTEXP = '1'B;
  931      %LSET LISTCOM = '0'B;
  932      %LSET LISTSUB = '1'B;
  933      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  934      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  935      %LSET INIT = CHARTEXT(' INIT');
  936      %LSET ENIT = CHARTEXT('');
  937      %ELSE;
  938      %LSET INIT = CHARTEXT('/*');
  939      %LSET ENIT = CHARTEXT('*/');
  940      %ENDIF;
  941      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  942         %KV_FILBIT
  943      %LSET NXTLVL = LVL+1;
  944      %G$QLF (NAME = QLF, LVL = NXTLVL, STCLASS = STCLASS, LAST = ",");
  945      %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%ENIT LAST
  946      %MEND;
  947      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             35   
  948      /*F* NAME:  KV$VDO_SMS - set mode, short. (NOT E)
  949      Function values:  KV_VDO_FNC_SMS.
  950      Legal VLPs:  MRK.
  951      */
  952      %MACRO KV$VDO_SMS(NAME = KV$VDO_SMS, LVL = 1, LAST = ";", STCLASS = BASED,
  953      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  954      FNC(KV_VDO_FNC_SMS = %KV_VDO_FNC_SMS) = %KV_VDO_FNC_SMS);
  955      %LSET LISTDIR = '0'B;
  956      %LSET LISTEXP = '1'B;
  957      %LSET LISTCOM = '0'B;
  958      %LSET LISTSUB = '1'B;
  959      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  960      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  961      %LSET INIT = CHARTEXT(' INIT');
  962      %LSET ENIT = CHARTEXT('');
  963      %ELSE;
  964      %LSET INIT = CHARTEXT('/*');
  965      %LSET ENIT = CHARTEXT('*/');
  966      %ENDIF;
  967      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",", FNC = FNC, VLP = VLP, STR = STR);
  968      %(LVL+1) * BIT(%KV_DBLBYT) %INIT('0'B)%ENIT LAST
  969      %MEND;
  970      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             36   
  971      /*F* NAME:  KV$VDO_STT - status. (NOT E)
  972      Function values:  KV_VDO_FNC_STT.
  973      Legal VLPs:  DAT1, DAT2, MRK.
  974      */
  975      %MACRO KV$VDO_STT(NAME = KV$VDO_STT, LVL = 1, LAST = ";", STCLASS = BASED,
  976      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  977      FNC(KV_VDO_FNC_STT = %KV_VDO_FNC_STT) = %KV_VDO_FNC_STT);
  978      %LSET LISTDIR = '0'B;
  979      %LSET LISTEXP = '1'B;
  980      %LSET LISTCOM = '0'B;
  981      %LSET LISTSUB = '1'B;
  982      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  983      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
  984      %LSET INIT = CHARTEXT(' INIT');
  985      %LSET ENIT = CHARTEXT('');
  986      %ELSE;
  987      %LSET INIT = CHARTEXT('/*');
  988      %LSET ENIT = CHARTEXT('*/');
  989      %ENDIF;
  990      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
  991      %MEND;
  992      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             37   
  993      /*F* NAME:  KV$VDO_UPDRELDVC - update real device. (NOT E)
  994      Function values:  KV_VDO_FNC_UPDRELDVC.
  995      Legal VLPs:  MRK.
  996      */
  997      %MACRO KV$VDO_UPDRELDVC(NAME = KV$VDO_UPDRELDVC, LVL = 1, LAST = ";", STCLASS = BASED,
  998      VLP (YES = '1'B, NO = '0'B) = '0'B, STR = 0,
  999      FNC(KV_VDO_FNC_UPDRELDVC = %KV_VDO_FNC_UPDRELDVC) = %KV_VDO_FNC_UPDRELDVC);
 1000      %LSET LISTDIR = '0'B;
 1001      %LSET LISTEXP = '1'B;
 1002      %LSET LISTCOM = '0'B;
 1003      %LSET LISTSUB = '1'B;
 1004      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1005      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1006      %LSET INIT = CHARTEXT(' INIT');
 1007      %LSET ENIT = CHARTEXT('');
 1008      %ELSE;
 1009      %LSET INIT = CHARTEXT('/*');
 1010      %LSET ENIT = CHARTEXT('*/');
 1011      %ENDIF;
 1012      %KV$VDO (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, FNC = FNC, VLP = VLP, STR = STR);
 1013      %MEND;
 1014      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             38   
 1015      /*F* NAME:  KV$VDOVLP - VDO VLP header definition.
 1016
 1017      */
 1018      %MACRO KV$VDOVLP(NAME = KV$VDOVLP, LVL = 1, LAST = ";", STCLASS = BASED,
 1019      TYP = , LST (YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = , VDOVLPHDRTYP = 1,
 1020            DAT (YES = '1'B, NO = '0'B) = '0'B);
 1021      %LSET LISTDIR = '0'B;
 1022      %LSET LISTEXP = '1'B;
 1023      %LSET LISTCOM = '0'B;
 1024      %LSET LISTSUB = '1'B;
 1025      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1026      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1027      %IF STC = 1;
 1028      %LSET INIT = CHARTEXT(' INIT');
 1029      %LSET ENIT = CHARTEXT('');
 1030      %ELSE;
 1031      %LSET INIT = CHARTEXT('/*');
 1032      %LSET ENIT = CHARTEXT('*/');
 1033      %ENDIF;
 1034      %LSET FEP = BITBIN(MODE_FEP);
 1035      %SET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1036      %SET KV_DBLBYT = 18-2*FEP;
 1037      %SET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1038      %SET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
 1039      %LSET LSST = CONCAT(TEXTCHAR(LAST), ', ');
 1040      %LSET LSST = CHARTEXT(SUBSTR(LSST, BITBIN(DAT), 1));
 1041      %IF LVL = 1;
 1042      DCL 1 NAME STCLASS %KV_DBLBYTALG,
 1043      %ELSE;
 1044      %(LVL) NAME,
 1045      %ENDIF;
 1046         %KV_FILBIT
 1047      %(LVL+1) %CHARTEXT('LST') BIT(1) %INIT(LST)%ENIT UNAL,
 1048      /*K* LST = YES or NO.  YES indicates this is the last VDOVLP for this VDO.
 1049      */
 1050      %(LVL+1) %CHARTEXT('TYP') UBIN(7) %INIT(TYP)%ENIT UNAL,
 1051      /*K* Type of VDOVLP.
14:55 JUL 28 '97 KV$VDO.:E05SI                                             39   
 1052      */
 1053      %IF VDOVLPHDRTYP = 1;
 1054      %(LVL+1) %CHARTEXT('BYTSIZ') UBIN BYTE %INIT(BYTSIZ)%ENIT CALIGNED %LSST
 1055      %ELSEIF %VDOVLPHDRTYP = 2;
 1056      %(LVL+1) %CHARTEXT('BYTSIZ') UBIN(%KV_DBLBYT) %INIT(BYTSIZ)%ENIT %KV_DBLBYTALG %LSST
 1057      %ENDIF;
 1058      /*K* BYTSIZ = value.  Byte size for this VDOVLP, not including
 1059      the VLP header (TYP and BYTSIZ) or other fixed length items in
 1060      the VLP.  Therefore, the total size of a VLP is BYTSIZ +
 1061      SIZEC(KV$VDOVLP_name).
 1062      */
 1063      %IF DAT;
 1064      %(LVL+1) %CHARTEXT('DAT') CHAR(NAME.%CHARTEXT('BYTSIZ')) LAST
 1065      %ENDIF;
 1066      %MEND;
 1067      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             40   
 1068      /*F* NAME:  KV$VDOVLP_ACTPOS - (NOT E)
 1069
 1070      */
 1071      %MACRO KV$VDOVLP_ACTPOS(NAME = KV$VDOVLP_ACTPOS, LVL = 1, LAST = ";", STCLASS = BASED,
 1072      LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 2,
 1073      ACTPOS = 0);
 1074      %LSET LISTDIR = '0'B;
 1075      %LSET LISTEXP = '1'B;
 1076      %LSET LISTCOM = '0'B;
 1077      %LSET LISTSUB = '1'B;
 1078      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1079      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1080      %LSET INIT = CHARTEXT(' INIT');
 1081      %LSET ENIT = CHARTEXT('');
 1082      %ELSE;
 1083      %LSET INIT = CHARTEXT('/*');
 1084      %LSET ENIT = CHARTEXT('*/');
 1085      %ENDIF;
 1086      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1087      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_ACTPOS, LST = LST, BYTSIZ = BYTSIZ);
 1088      %(LVL+1) %CHARTEXT('ACTPOS') UBIN(%KV_DBLBYT) %INIT(ACTPOS)%ENIT %KV_DBLBYTALG LAST
 1089      /*K* ACTPOS = value.  The column position at which activation took place.
 1090      Only ever accompanies VDO_DAT.  If absent, cursor was beyond the last column.
 1091      */
 1092      %MEND;
 1093      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             41   
 1094      /*F* NAME:  KV$VDOVLP_CG_MSGID - (NOT E?)
 1095
 1096      */
 1097      %MACRO KV$VDOVLP_CG_MSGID(NAME = KV$VDOVLP_CG_MSGID, LVL = 1, LAST = ";", STCLASS = BASED,
 1098      LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0,
 1099      RSP(YES = '1'B, NO = '0'B) = '0'B, CG_MSGID = 0, CG_MSGIDXT = '0'B);
 1100      %LSET LISTDIR = '0'B;
 1101      %LSET LISTEXP = '1'B;
 1102      %LSET LISTCOM = '0'B;
 1103      %LSET LISTSUB = '1'B;
 1104      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1105      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1106      %LSET INIT = CHARTEXT(' INIT');
 1107      %LSET ENIT = CHARTEXT('');
 1108      %ELSE;
 1109      %LSET INIT = CHARTEXT('/*');
 1110      %LSET ENIT = CHARTEXT('*/');
 1111      %ENDIF;
 1112      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1113      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_CG_MSGID, LST = LST, BYTSIZ = 0);
 1114         %KV_FILBIT
 1115      %(LVL+1) %CHARTEXT('RSP') BIT(1) %INIT(RSP)%ENIT UNAL,
 1116      /*K* RSP = YES or NO.  YES specifies this is the reponse to a
 1117      previous VDOVLP_CG_MSGID.
 1118      */
 1119      %(LVL+1) %CHARTEXT('CG_MSGID') UBIN(%(KV_DBLBYT*2)) %INIT(CG_MSGID)%ENIT %KV_DBLBYTALG,
 1120      /*K* CG_MSGID = 32/36 bit value.  CG_MSGID is comgroup message ID.
 1121      */
 1122      %(LVL+1) %CHARTEXT('CG_MSGIDXT') BIT(%(KV_DBLBYT*2)) %INIT(CG_MSGIDXT)%ENIT CALIGNED LAST
 1123      /*K* CG_MSGID = 32/36 bit string.  CG_MSGID is comgroup message ID extension.
 1124      */
 1125      %MEND;
 1126      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             42   
 1127      /*F* NAME:  KV$VDOVLP_CG_MSGTYP - (NOT E?)
 1128
 1129      */
 1130      %MACRO KV$VDOVLP_CG_MSGTYP(NAME = KV$VDOVLP_CG_MSGTYP, LVL = 1, LAST = ";", STCLASS = BASED,
 1131      LST(YES = '1'B, NO = '0'B) = '0'B,
 1132      RSP(YES = '1'B, NO = '0'B) = '0'B, CG_MSGTYP = ' ');
 1133      %LSET LISTDIR = '0'B;
 1134      %LSET LISTEXP = '1'B;
 1135      %LSET LISTCOM = '0'B;
 1136      %LSET LISTSUB = '1'B;
 1137      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1138      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1139      %LSET INIT = CHARTEXT(' INIT');
 1140      %LSET ENIT = CHARTEXT('');
 1141      %ELSE;
 1142      %LSET INIT = CHARTEXT('/*');
 1143      %LSET ENIT = CHARTEXT('*/');
 1144      %ENDIF;
 1145      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1146      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_CG_MSGTYP, LST = LST, BYTSIZ = 0);
 1147         %KV_FILBIT
 1148      %(LVL+1) %CHARTEXT('RSP') BIT(1) %INIT(RSP)%ENIT UNAL,
 1149      /*K* RSP = YES or NO.  YES specifies this is the reponse to a
 1150      previous VDOVLP_CG_MSGTYP.
 1151      */
 1152      %(LVL+1) %CHARTEXT('CG_MSGTYP') CHAR(8) %INIT(CG_MSGTYP)%ENIT %KV_DBLBYTALG LAST
 1153      /*K* CG_MSGTYP = character string.  CG_MSGTYP is comgroup message type.
 1154      */
 1155      %MEND;
 1156      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             43   
 1157      /*F* NAME:  KV$VDOVLP_CG_STA - (NOT E?)
 1158
 1159      */
 1160      %MACRO KV$VDOVLP_CG_STA(NAME = KV$VDOVLP_CG_STA, LVL = 1, LAST = ";", STCLASS = BASED,
 1161      LST(YES = '1'B, NO = '0'B) = '0'B,
 1162      RSP(YES = '1'B, NO = '0'B) = '0'B, CG_STA = ' ');
 1163      %LSET LISTDIR = '0'B;
 1164      %LSET LISTEXP = '1'B;
 1165      %LSET LISTCOM = '0'B;
 1166      %LSET LISTSUB = '1'B;
 1167      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1168      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1169      %LSET INIT = CHARTEXT(' INIT');
 1170      %LSET ENIT = CHARTEXT('');
 1171      %ELSE;
 1172      %LSET INIT = CHARTEXT('/*');
 1173      %LSET ENIT = CHARTEXT('*/');
 1174      %ENDIF;
 1175      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1176      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_CG_STA, LST = LST, BYTSIZ = 0);
 1177         %KV_FILBIT
 1178      %(LVL+1) %CHARTEXT('RSP') BIT(1) %INIT(RSP)%ENIT UNAL,
 1179      /*K* RSP = YES or NO.  YES specifies this is the reponse to a
 1180      previous VDOVLP_CG_MSGTYP.
 1181      */
 1182      %(LVL+1) %CHARTEXT('CG_STA') CHAR(8) %INIT(CG_STA)%ENIT %KV_DBLBYTALG LAST
 1183      /*K* CG_STA = character string.  CG_STA is the comgroup station.
 1184      */
 1185      %MEND;
 1186      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             44   
 1187      /*F* NAME:  KV$VDOVLP_DAT1 - (E)
 1188      The user data immediately follows the structure declared by
 1189      KV$VDOVLP_DAT1; the byte size of the data is indicated by
 1190      BYTSIZ.
 1191
 1192      */
 1193      %MACRO KV$VDOVLP_DAT1(NAME = KV$VDOVLP_DAT1, LVL = 1, LAST = ";", STCLASS = BASED,
 1194      DAT(YES = '1'B, NO = '0'B) = '0'B, LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0);
 1195      %LSET LISTDIR = '0'B;
 1196      %LSET LISTEXP = '1'B;
 1197      %LSET LISTCOM = '0'B;
 1198      %LSET LISTSUB = '1'B;
 1199      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1200      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1201      %LSET INIT = CHARTEXT(' INIT');
 1202      %LSET ENIT = CHARTEXT('');
 1203      %ELSE;
 1204      %LSET INIT = CHARTEXT('/*');
 1205      %LSET ENIT = CHARTEXT('*/');
 1206      %ENDIF;
 1207      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, DAT = DAT,
 1208      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_DAT1, LST = LST, BYTSIZ = BYTSIZ);
 1209      %MEND;
 1210      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             45   
 1211      /*F* NAME:  KV$VDOVLP_DAT2 - (E)
 1212      The user data immediately follows the structure declared by
 1213      KV$VDOVLP_DAT2; the byte size of the data is indicated by
 1214      BYTSIZ.
 1215
 1216      */
 1217      %MACRO KV$VDOVLP_DAT2(NAME = KV$VDOVLP_DAT2, LVL = 1, LAST = ";", STCLASS = BASED,
 1218      DAT(YES = '1'B, NO = '0'B) = '0'B, LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0);
 1219      %LSET LISTDIR = '0'B;
 1220      %LSET LISTEXP = '1'B;
 1221      %LSET LISTCOM = '0'B;
 1222      %LSET LISTSUB = '1'B;
 1223      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1224      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1225      %LSET INIT = CHARTEXT(' INIT');
 1226      %LSET ENIT = CHARTEXT('');
 1227      %ELSE;
 1228      %LSET INIT = CHARTEXT('/*');
 1229      %LSET ENIT = CHARTEXT('*/');
 1230      %ENDIF;
 1231      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, DAT = DAT,
 1232      VDOVLPHDRTYP = 2, TYP = %KV_VDOVLP_TYP_DAT2, LST = LST, BYTSIZ = BYTSIZ);
 1233      %MEND;
 1234      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             46   
 1235      /*F* NAME:  KV$VDOVLP_ENTSRD
 1236      The enter-SRD character string immediately follows the structure declared by
 1237      KV$VDOVLP_ENTSRD; the byte size of the string is indicated by
 1238      BYTSIZ.
 1239
 1240      */
 1241      %MACRO KV$VDOVLP_ENTSRD(NAME = KV$VDOVLP_ENTSRD, LVL = 1, LAST = ";", STCLASS = BASED,
 1242      DAT(YES = '1'B, NO = '0'B) = '0'B, LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0);
 1243      %LSET LISTDIR = '0'B;
 1244      %LSET LISTEXP = '1'B;
 1245      %LSET LISTCOM = '0'B;
 1246      %LSET LISTSUB = '1'B;
 1247      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1248      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1249      %LSET INIT = CHARTEXT(' INIT');
 1250      %LSET ENIT = CHARTEXT('');
 1251      %ELSE;
 1252      %LSET INIT = CHARTEXT('/*');
 1253      %LSET ENIT = CHARTEXT('*/');
 1254      %ENDIF;
 1255      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, DAT = DAT,
 1256      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_ENTSRD, LST = LST, BYTSIZ = BYTSIZ);
 1257      %MEND;
 1258      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             47   
 1259      /*F* NAME:  KV$VDOVLP_ERR - (NOT E)
 1260
 1261      */
 1262      %MACRO KV$VDOVLP_ERR(NAME = KV$VDOVLP_ERR, LVL = 1, LAST = ";", STCLASS = BASED,
 1263      LST(YES = '1'B, NO = '0'B) = '0'B,
 1264      FCG = , MID = , MON = '0'B, ERR# = 0, SEV = 0);
 1265      %LSET LISTDIR = '0'B;
 1266      %LSET LISTEXP = '1'B;
 1267      %LSET LISTCOM = '0'B;
 1268      %LSET LISTSUB = '1'B;
 1269      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1270      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1271      %LSET INIT = CHARTEXT(' INIT');
 1272      %LSET ENIT = CHARTEXT('');
 1273      %ELSE;
 1274      %LSET INIT = CHARTEXT('/*');
 1275      %LSET ENIT = CHARTEXT('*/');
 1276      %ENDIF;
 1277      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1278      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_ERR, LST = LST, BYTSIZ = 0);
 1279      %LSET NXTLVL = LVL+1;
 1280      %VLP_ERRCODE (FPTN = ERRCODE,
 1281      ALGN = CALIGNED,
 1282      LVL = NXTLVL, LAST = LAST, STCLASS = STCLASS,
 1283      FCG = FCG, MID = MID, MON = MON, ERR# = ERR#, SEV = SEV);
 1284      %MEND;
 1285      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             48   
 1286      /*F* NAME:  KV$VDOVLP_FLDID - (NOT E)
 1287
 1288      */
 1289      %MACRO KV$VDOVLP_FLDID(NAME = KV$VDOVLP_FLDID, LVL = 1, LAST = ";", STCLASS = BASED,
 1290      LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 2,
 1291      FLDID = 0);
 1292      %LSET LISTDIR = '0'B;
 1293      %LSET LISTEXP = '1'B;
 1294      %LSET LISTCOM = '0'B;
 1295      %LSET LISTSUB = '1'B;
 1296      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1297      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1298      %LSET INIT = CHARTEXT(' INIT');
 1299      %LSET ENIT = CHARTEXT('');
 1300      %ELSE;
 1301      %LSET INIT = CHARTEXT('/*');
 1302      %LSET ENIT = CHARTEXT('*/');
 1303      %ENDIF;
 1304      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1305      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_FLDID, LST = LST, BYTSIZ = BYTSIZ);
 1306      %(LVL+1) %CHARTEXT('FLDID') UBIN(%KV_DBLBYT) %INIT(FLDID)%ENIT %KV_DBLBYTALG LAST
 1307      /*K* FLDID = value.  The field ID used to select/identify a particular field
 1308      on a FORMs virtual device.
 1309      */
 1310      %MEND;
 1311      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             49   
 1312      /*F* NAME:  KV$VDOVLP_KEY - (NOT E)
 1313      The KEY immediately follows the structure declared by
 1314      KV$VDOVLP_KEY; the byte size of the KEY is indicated by
 1315      BYTSIZ.
 1316
 1317      */
 1318      %MACRO KV$VDOVLP_KEY(NAME = KV$VDOVLP_KEY, LVL = 1, LAST = ";", STCLASS = BASED,
 1319      DAT(YES = '1'B, NO = '0'B) = '0'B, LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0);
 1320      %LSET LISTDIR = '0'B;
 1321      %LSET LISTEXP = '1'B;
 1322      %LSET LISTCOM = '0'B;
 1323      %LSET LISTSUB = '1'B;
 1324      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1325      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1326      %LSET INIT = CHARTEXT(' INIT');
 1327      %LSET ENIT = CHARTEXT('');
 1328      %ELSE;
 1329      %LSET INIT = CHARTEXT('/*');
 1330      %LSET ENIT = CHARTEXT('*/');
 1331      %ENDIF;
 1332      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = LAST, DAT = DAT,
 1333      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_KEY, LST = LST, BYTSIZ = BYTSIZ);
 1334      %MEND;
 1335      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             50   
 1336      /*F* NAME:  KV$VDOVLP_MRK - (NOT E)
 1337
 1338      */
 1339      %MACRO KV$VDOVLP_MRK(NAME = KV$VDOVLP_MRK, LVL = 1, LAST = ";", STCLASS = BASED,
 1340      LST(YES = '1'B, NO = '0'B) = '0'B, BYTSIZ = 0,
 1341      RSP(YES = '1'B, NO = '0'B) = '0'B, MRKTYP = 0);
 1342      %LSET LISTDIR = '0'B;
 1343      %LSET LISTEXP = '1'B;
 1344      %LSET LISTCOM = '0'B;
 1345      %LSET LISTSUB = '1'B;
 1346      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1347      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1348      %LSET INIT = CHARTEXT(' INIT');
 1349      %LSET ENIT = CHARTEXT('');
 1350      %ELSE;
 1351      %LSET INIT = CHARTEXT('/*');
 1352      %LSET ENIT = CHARTEXT('*/');
 1353      %ENDIF;
 1354      %KV$VDOVLP (NAME = NAME, LVL = LVL, STCLASS = STCLASS, LAST = ",",
 1355      VDOVLPHDRTYP = 1, TYP = %KV_VDOVLP_TYP_MRK, LST = LST, BYTSIZ = BYTSIZ);
 1356         %KV_FILBIT
 1357      %(LVL+1) %CHARTEXT('RSP') BIT(1) %INIT(RSP)%ENIT UNAL,
 1358      /*K* RSP = YES or NO.  YES specifies this is the response to a
 1359      previous VDOVLP_MRK.
 1360      */
 1361      %(LVL+1) * BIT(7) %INIT('0'B)%ENIT,
 1362      %(LVL+1) %CHARTEXT('MRKTYP') UBIN BYTE %INIT(MRKTYP)%ENIT CALIGNED,
 1363      /*K* MRKTYP = value.  Specifies what type of marker this is.
 1364      Values are KV_VDOMRKTYP_...
 1365      */
 1366      %(LVL+1) %CHARTEXT('ID') %KV_DBLBYTALG,
 1367      /*K* ID = BIT(36/32).  Specifies the identifier associated with this
 1368      marker (e.g., marker number, block/record number, etc.).
 1369      */
 1370      %(LVL+2) UBIN_DBLBYT UBIN(%KV_DBLBYT) %INIT(0)%ENIT UNAL,
 1371      /*K* UBIN_DBLBYT = 2-byte UBIN value.  This item is part of ID,
 1372      and is defined for the convenience of the sender of VDOVLP_MRK
14:55 JUL 28 '97 KV$VDO.:E05SI                                             51   
 1373      (who is later the recipient of the corresponding VDOVLP_MRK
 1374      with .RSP set), when the sender doesn't need 36/32 bits of ID.
 1375      */
 1376      %(LVL+2) UBIN_DBLBYT2 UBIN(%KV_DBLBYT) %INIT(0)%ENIT UNAL LAST
 1377      %MEND;
 1378      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             52   
 1379      /*N* get rid of the following table, use KV$VDP */
 1380      /*F* NAME:  KV_VDOBYTSIZ - VDO byte sizes.
 1381      KV_VDOBYTSIZ, indexed by KV_VDO_FNC_..., yields the
 1382      byte size of the corresponding KV$VDO structure.
 1383      */
 1384      %MACRO KV_VDOBYTSIZ(NAME = KV_VDOBYTSIZ, STCLASS = SYMREF);
 1385      %LSET LISTDIR = '0'B;
 1386      %LSET LISTEXP = '1'B;
 1387      %LSET LISTCOM = '0'B;
 1388      %LSET LISTSUB = '1'B;
 1389      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1390      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1391      %LSET INIT = CHARTEXT(' INIT');
 1392      %LSET ENIT = CHARTEXT('');
 1393      %ELSE;
 1394      %LSET INIT = CHARTEXT('/*');
 1395      %LSET ENIT = CHARTEXT('*/');
 1396      %ENDIF;
 1397      DCL NAME (0:%KV_VDO_FNC_HI) UBIN BYTE CALIGNED STCLASS %INIT(
 1398      0,
 1399      0,
 1400      SIZEC(KV$VDO_BLKDAT),
 1401      SIZEC(KV$VDO_CLSSSN),
 1402      SIZEC(KV$VDO_CLSSSN),
 1403      SIZEC(KV$VDO_DAT),
 1404      SIZEC(KV$VDO_DAT),
 1405      SIZEC(KV$VDO_DCLFLD),
 1406      SIZEC(KV$VDO_DCLSTR),
 1407      SIZEC(KV$VDO_DLT),
 1408      SIZEC(KV$VDO_DSC),
 1409      SIZEC(KV$VDO_DSC),
 1410      SIZEC(KV$VDO_ERS),
 1411      SIZEC(KV$VDO_EVT),
 1412      SIZEC(KV$VDO_HVPS),
 1413      SIZEC(KV$VDO_NOP),
 1414      SIZEC(KV$VDO_OPNSSN),
 1415      SIZEC(KV$VDO_OPNSSN),
14:55 JUL 28 '97 KV$VDO.:E05SI                                             53   
 1416      SIZEC(KV$VDO_PRM),
 1417      SIZEC(KV$VDO_PRM),
 1418      SIZEC(KV$VDO_RLSFLD),
 1419      SIZEC(KV$VDO_RMS),
 1420      SIZEC(KV$VDO_RQSDAT),
 1421      SIZEC(KV$VDO_RQSPRM),
 1422      SIZEC(KV$VDO_RQSSTT),
 1423      SIZEC(KV$VDO_SLCFLD),
 1424      SIZEC(KV$VDO_SLCGRPRND),
 1425      SIZEC(KV$VDO_SLCQLF),
 1426      SIZEC(KV$VDO_SMS),
 1427      SIZEC(KV$VDO_STT),
 1428      SIZEC(KV$VDO_UPDRELDVC),
 1429      SIZEC(KV$VDO_MRK),
 1430      SIZEC(KV$VDO_RQSMRK),
 1431      SIZEC(KV$VDO_OPNSTR),
 1432      SIZEC(KV$VDO_CLSSTR)
 1433      )%ENIT;
 1434      %MEND;
 1435      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             54   
 1436      /*F* NAME:  KV_VDOVLPBYTLNG - VDOVLP byte lengths (PL-6 LENGTHC).
 1437      KV_VDOVLPBYTLNG, indexed by KV_VDOVLP_TYP_..., yields the
 1438      byte length of the corresponding KV$VDOVLP structure.
 1439      */
 1440      %MACRO KV_VDOVLPBYTLNG(NAME = KV_VDOVLPBYTLNG, STCLASS = SYMREF);
 1441      %LSET LISTDIR = '0'B;
 1442      %LSET LISTEXP = '1'B;
 1443      %LSET LISTCOM = '0'B;
 1444      %LSET LISTSUB = '1'B;
 1445      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1446      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1447      %LSET INIT = CHARTEXT(' INIT');
 1448      %LSET ENIT = CHARTEXT('');
 1449      %ELSE;
 1450      %LSET INIT = CHARTEXT('/*');
 1451      %LSET ENIT = CHARTEXT('*/');
 1452      %ENDIF;
 1453      DCL NAME (0:%KV_VDOVLP_TYP_HI) UBIN BYTE CALIGNED STCLASS %INIT(
 1454      0,
 1455      LENGTHC(KV$VDOVLP_CG_MSGID),
 1456      LENGTHC(KV$VDOVLP_CG_MSGTYP),
 1457      LENGTHC(KV$VDOVLP_CG_STA),
 1458      LENGTHC(KV$VDOVLP_DAT1),
 1459      LENGTHC(KV$VDOVLP_DAT2),
 1460      LENGTHC(KV$VDOVLP_ERR),
 1461      LENGTHC(KV$VDOVLP_FLDID),
 1462      LENGTHC(KV$VDOVLP_KEY),
 1463      LENGTHC(KV$VDOVLP_MRK),
 1464      LENGTHC(KV$VDOVLP_ENTSRD),
 1465      LENGTHC(KV$VDOVLP_ACTPOS)
 1466      )%ENIT;
 1467      %MEND;
 1468      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             55   
 1469      /*F* NAME:  KV_VDOVLPBYTSIZ - VDOVLP byte sizes (PL-6 SIZEC).
 1470      KV_VDOVLPBYTSIZ, indexed by KV_VDOVLP_TYP_..., yields the
 1471      byte size of the corresponding KV$VDOVLP structure.
 1472      */
 1473      %MACRO KV_VDOVLPBYTSIZ(NAME = KV_VDOVLPBYTSIZ, STCLASS = SYMREF);
 1474      %LSET LISTDIR = '0'B;
 1475      %LSET LISTEXP = '1'B;
 1476      %LSET LISTCOM = '0'B;
 1477      %LSET LISTSUB = '1'B;
 1478      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1479      %IF (STC = 'STA') OR (STC = 'CON') OR (STC = 'EXT');
 1480      %LSET INIT = CHARTEXT(' INIT');
 1481      %LSET ENIT = CHARTEXT('');
 1482      %ELSE;
 1483      %LSET INIT = CHARTEXT('/*');
 1484      %LSET ENIT = CHARTEXT('*/');
 1485      %ENDIF;
 1486      DCL NAME (0:%KV_VDOVLP_TYP_HI) UBIN BYTE CALIGNED STCLASS %INIT(
 1487      0,
 1488      SIZEC(KV$VDOVLP_CG_MSGID),
 1489      SIZEC(KV$VDOVLP_CG_MSGTYP),
 1490      SIZEC(KV$VDOVLP_CG_STA),
 1491      SIZEC(KV$VDOVLP_DAT1),
 1492      SIZEC(KV$VDOVLP_DAT2),
 1493      SIZEC(KV$VDOVLP_ERR),
 1494      SIZEC(KV$VDOVLP_FLDID),
 1495      SIZEC(KV$VDOVLP_KEY),
 1496      SIZEC(KV$VDOVLP_MRK),
 1497      SIZEC(KV$VDOVLP_ENTSRD),
 1498      SIZEC(KV$VDOVLP_ACTPOS)
 1499      )%ENIT;
 1500      %MEND;
 1501      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             56   
 1502      /*F* NAME: KV_NAMTXT_VDO_FNC Names (in CHAR data type) of the KV_VDO_FNC EQUs */
 1503      %MACRO KV_NAMTXT_VDO_FNC (NAME = KV_NAMTXT_VDO_FNC, LAST = ";", STCLASS = CONSTANT);
 1504      %LSET LISTDIR = '0'B;
 1505      %LSET LISTEXP = '1'B;
 1506      %LSET LISTCOM = '0'B;
 1507      %LSET LISTSUB = '1'B;
 1508      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1509      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1510      %IF STC = 1;
 1511      %LSET INIT = CHARTEXT(' INIT');
 1512      %LSET ENIT = CHARTEXT('');
 1513      %ELSE;
 1514      %LSET INIT = CHARTEXT('/*');
 1515      %LSET ENIT = CHARTEXT('*/');
 1516      %ENDIF;
 1517      DCL 1 NAME STCLASS,
 1518      2 TXT_INT CALIGNED,
 1519      3 * CHAR(26) %INIT('KV_VDO_FNC: none (0)')%ENIT  CALIGNED,
 1520      3 * CHAR(26) %INIT('KV_VDO_FNC: none')%ENIT  CALIGNED,
 1521      3 * CHAR(26) %INIT('KV_VDO_FNC_BLKDAT')%ENIT  CALIGNED,
 1522      3 * CHAR(26) %INIT('KV_VDO_FNC_CLSSSN_RQS')%ENIT  CALIGNED,
 1523      3 * CHAR(26) %INIT('KV_VDO_FNC_CLSSSN_RSP')%ENIT  CALIGNED,
 1524      3 * CHAR(26) %INIT('KV_VDO_FNC_DAT')%ENIT  CALIGNED,
 1525      3 * CHAR(26) %INIT('KV_VDO_FNC_DAT_IMD')%ENIT  CALIGNED,
 1526      3 * CHAR(26) %INIT('KV_VDO_FNC_DCLFLD')%ENIT  CALIGNED,
 1527      3 * CHAR(26) %INIT('KV_VDO_FNC_DCLSTR')%ENIT  CALIGNED,
 1528      3 * CHAR(26) %INIT('KV_VDO_FNC_DLT')%ENIT  CALIGNED,
 1529      3 * CHAR(26) %INIT('KV_VDO_FNC_DSC_RQS')%ENIT  CALIGNED,
 1530      3 * CHAR(26) %INIT('KV_VDO_FNC_DSC_RSP')%ENIT  CALIGNED,
 1531      3 * CHAR(26) %INIT('KV_VDO_FNC_ERS')%ENIT  CALIGNED,
 1532      3 * CHAR(26) %INIT('KV_VDO_FNC_EVT')%ENIT  CALIGNED,
 1533      3 * CHAR(26) %INIT('KV_VDO_FNC_HVPS')%ENIT  CALIGNED,
 1534      3 * CHAR(26) %INIT('KV_VDO_FNC_NOP')%ENIT  CALIGNED,
 1535      3 * CHAR(26) %INIT('KV_VDO_FNC_OPNSSN_RQS')%ENIT  CALIGNED,
 1536      3 * CHAR(26) %INIT('KV_VDO_FNC_OPNSSN_RSP')%ENIT  CALIGNED,
 1537      3 * CHAR(26) %INIT('KV_VDO_FNC_PRM_RSP')%ENIT  CALIGNED,
 1538      3 * CHAR(26) %INIT('KV_VDO_FNC_PRM_SET')%ENIT  CALIGNED,
14:55 JUL 28 '97 KV$VDO.:E05SI                                             57   
 1539      3 * CHAR(26) %INIT('KV_VDO_FNC_RLSFLD')%ENIT  CALIGNED,
 1540      3 * CHAR(26) %INIT('KV_VDO_FNC_RMS')%ENIT  CALIGNED,
 1541      3 * CHAR(26) %INIT('KV_VDO_FNC_RQSDAT')%ENIT  CALIGNED,
 1542      3 * CHAR(26) %INIT('KV_VDO_FNC_RQSPRM')%ENIT  CALIGNED,
 1543      3 * CHAR(26) %INIT('KV_VDO_FNC_RQSSTT')%ENIT  CALIGNED,
 1544      3 * CHAR(26) %INIT('KV_VDO_FNC_SLCFLD')%ENIT  CALIGNED,
 1545      3 * CHAR(26) %INIT('KV_VDO_FNC_SLCGRPRND')%ENIT  CALIGNED,
 1546      3 * CHAR(26) %INIT('KV_VDO_FNC_SLCQLF')%ENIT  CALIGNED,
 1547      3 * CHAR(26) %INIT('KV_VDO_FNC_SMS')%ENIT  CALIGNED,
 1548      3 * CHAR(26) %INIT('KV_VDO_FNC_STT')%ENIT  CALIGNED,
 1549      3 * CHAR(26) %INIT('KV_VDO_FNC_UPDRELDVC')%ENIT  CALIGNED,
 1550      3 * CHAR(26) %INIT('KV_VDO_FNC_MRK')%ENIT  CALIGNED,
 1551      3 * CHAR(26) %INIT('KV_VDO_FNC_RQSMRK')%ENIT  CALIGNED,
 1552      3 * CHAR(26) %INIT('KV_VDO_FNC_OPNSTR')%ENIT  CALIGNED,
 1553      3 * CHAR(26) %INIT('KV_VDO_FNC_CLSSTR')%ENIT  CALIGNED,
 1554      2 TXT(0:%KV_VDO_FNC_HI) REDEF TXT_INT CHAR(26) CALIGNED LAST
 1555      %MEND;
 1556      /*
 1557      EQUs for VDO functions.
 1558      WARNING:  When updating this list of EQUs, update KV_NAMTXT_VDO_FNC.
 1559      */
 1560      %MACRO KV_VDO_E;
 1561      /* 1 is no longer used */
 1562      %EQU KV_VDO_FNC_BLKDAT = 2;
 1563      %EQU KV_VDO_FNC_CLSSSN_RQS = 3;
 1564      %EQU KV_VDO_FNC_CLSSSN_RSP = 4;
 1565      %EQU KV_VDO_FNC_DAT = 5;
 1566      %EQU KV_VDO_FNC_DAT_IMD = 6;
 1567      %EQU KV_VDO_FNC_DCLFLD = 7;
 1568      %EQU KV_VDO_FNC_DCLSTR = 8;
 1569      %EQU KV_VDO_FNC_DLT = 9;
 1570      %EQU KV_VDO_FNC_DSC_RQS = 10;
 1571      %EQU KV_VDO_FNC_DSC_RSP = 11;
 1572      %EQU KV_VDO_FNC_ERS = 12;
 1573      %EQU KV_VDO_FNC_EVT = 13;
 1574      %EQU KV_VDO_FNC_HVPS = 14;
 1575      %EQU KV_VDO_FNC_MRK = 31;
14:55 JUL 28 '97 KV$VDO.:E05SI                                             58   
 1576      %EQU KV_VDO_FNC_NOP = 15;
 1577      %EQU KV_VDO_FNC_OPNSSN_RQS = 16;
 1578      %EQU KV_VDO_FNC_OPNSSN_RSP = 17;
 1579      %EQU KV_VDO_FNC_PRM_RSP = 18;
 1580      %EQU KV_VDO_FNC_PRM_SET = 19;
 1581      %EQU KV_VDO_FNC_RLSFLD = 20;
 1582      %EQU KV_VDO_FNC_RMS = 21;
 1583      %EQU KV_VDO_FNC_RQSDAT = 22;
 1584      %EQU KV_VDO_FNC_RQSMRK = 32;
 1585      %EQU KV_VDO_FNC_RQSPRM = 23;
 1586      %EQU KV_VDO_FNC_RQSSTT = 24;
 1587      %EQU KV_VDO_FNC_SLCFLD = 25;
 1588      %EQU KV_VDO_FNC_SLCGRPRND = 26;
 1589      %EQU KV_VDO_FNC_SLCQLF = 27;
 1590      %EQU KV_VDO_FNC_SMS = 28;
 1591      %EQU KV_VDO_FNC_STT = 29;
 1592      %EQU KV_VDO_FNC_UPDRELDVC = 30;
 1593      %EQU KV_VDO_FNC_OPNSTR = 33;
 1594      %EQU KV_VDO_FNC_CLSSTR = 34;
 1595      %EQU KV_VDO_FNC_HI = 34;                /* HI value                           */
 1596      %MEND;
 1597      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             59   
 1598      /*
 1599      EQUs for VDO VLP types.
 1600      */
 1601      %MACRO KV_VDOVLP_E;
 1602      %EQU KV_VDOVLP_TYP_CG_MSGID = 1;
 1603      %EQU KV_VDOVLP_TYP_CG_MSGTYP = 2;
 1604      %EQU KV_VDOVLP_TYP_CG_STA = 3;
 1605      %EQU KV_VDOVLP_TYP_DAT1 = 4;
 1606      %EQU KV_VDOVLP_TYP_DAT2 = 5;
 1607      %EQU KV_VDOVLP_TYP_ERR = 6;
 1608      %EQU KV_VDOVLP_TYP_FLDID = 7;
 1609      %EQU KV_VDOVLP_TYP_KEY = 8;
 1610      %EQU KV_VDOVLP_TYP_MRK = 9;
 1611      %EQU KV_VDOVLP_TYP_ENTSRD = 10;
 1612      %EQU KV_VDOVLP_TYP_ACTPOS = 11;
 1613      %EQU KV_VDOVLP_TYP_HI = 11;
 1614      %MEND;
 1615      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             60   
 1616      /*
 1617      EQUs for marker types (KV$VDOVLP_MRK.MRKTYP).
 1618      */
 1619      %MACRO KV_VDOMRKTYP_E;
 1620      %EQU KV_VDOMRKTYP_ENDACK = 1;
 1621      %EQU KV_VDOMRKTYP_LSTRCRID = 2;
 1622      %EQU KV_VDOMRKTYP_MRK = 3;
 1623      %EQU KV_VDOMRKTYP_SNDLSTRCRID = 4;
 1624      %MEND;
 1625      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             61   
 1626      /*
 1627      EQUs for event types (KV$VDO_EVT.EVTTYP).
 1628      */
 1629      %MACRO KV_EVTTYP_E;
 1630      %EQU KV_EVTTYP_BRK = 1;
 1631      %EQU KV_EVTTYP_MNTATN = 2;
 1632
 1633      %MEND;
 1634      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             62   
 1635      /*
 1636      EQUs for data modes (KV$VDO_RQSDAT.DATMOD and KV$VDO_DAT.DATMOD).
 1637      */
 1638      %MACRO KV_DATMOD_E;
 1639      %EQU KV_DATMOD_NRM = 0;                 /* Normal (not transparent or binary) */
 1640      %EQU KV_DATMOD_TRN = 1;                 /* Transparent                        */
 1641      %EQU KV_DATMOD_BNR = 2;                 /* Binary                             */
 1642      %EQU KV_DATMOD_ANY = 3;                 /* Any (for requests only)            */
 1643      %MEND;
 1644      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             63   
 1645      /*F* NAME: KV_DATCTRCHRTYP_E
 1646      EQUs for data control character types (KV_VDO_DAT.DATCTRCHRTYP).
 1647      */
 1648      %MACRO KV_DATCTRCHRTYP_E;
 1649      /* In following commentary DATCTRCHRTYP_xx names lack KV_ prefix */
 1650      /* to meet an EXTRACT length restriction.  Manual is OK.  */
 1651      /*K* DATCTRCHRTYP_NON
 1652      KV_DATCTRCHRTYP_NON           None                          */
 1653      %EQU KV_DATCTRCHRTYP_NON = 0;           /* None                               */
 1654      /*K* DATCTRCHRTYP_ACT
 1655      KV_DATCTRCHRTYP_ACT           Activation character          */
 1656      %EQU KV_DATCTRCHRTYP_ACT = 1;           /* Activation character               */
 1657      /*K* DATCTRCHRTYP_VFC
 1658      KV_DATCTRCHRTYP_VFC           VFC character                 */
 1659      %EQU KV_DATCTRCHRTYP_VFC = 2;           /* VFC character                      */
 1660      /*K* DATCTRCHRTYP_CNT
 1661      KV_DATCTRCHRTYP_CNT           Signed count to be placed in ARS   */
 1662      %EQU KV_DATCTRCHRTYP_CNT = 3;           /* Signed count to be placed in ARS.  */
 1663      %MEND;
 1664      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             64   
 1665      /*
 1666      Block reasons (for KV$VDO_BLKDAT).
 1667      */
 1668      %MACRO KV_BLKRSN_E;
 1669      %EQU KV_BLKRSN_MAXNMBBYT = 1;  /* Max # bytes exceeded */
 1670      %EQU KV_BLKRSN_MAXNMBRCR = 2;  /* Max # records exceeded */
 1671      %EQU KV_BLKRSN_MAXRCRBYTSIZ = 3;  /* Max record byte size exceeded */
 1672      %MEND;
 1673      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             65   
 1674      /*
 1675      Invoke all constant-defining MACROs defined in this INCLUDE file.
 1676      */
 1677      %MACRO KV_VDO_ALL_E;
 1678      %KV_VDO_E;
 1679      %KV_VDOVLP_E;
 1680      %KV_VDOMRKTYP_E;
 1681      %KV_EVTTYP_E;
 1682      %KV_DATMOD_E;
 1683      %KV_DATCTRCHRTYP_E;
 1684      %KV_BLKRSN_E;
 1685      %MEND;
 1686      %EJECT;

14:55 JUL 28 '97 KV$VDO.:E05SI                                             66   
 1687      /*
 1688      Invoke all MACROs defined in this INCLUDE file.
 1689      */
 1690      %MACRO KV_VDO_ALL (NAME = KV$VDO%FNC, STCLASS = BASED, VLPSTCLASS = BASED,
 1691                         DAT(YES = '1'B, NO = '0'B) = '0'B);
 1692      %KV_VDO_ALL_E;
 1693      %LSET FNC = CHARTEXT('');
 1694      %KV$VDO (NAME = NAME, STCLASS = STCLASS);
 1695      %LSET FNC = CHARTEXT('_BLKDAT');
 1696      %KV$VDO_BLKDAT (NAME = NAME, STCLASS = STCLASS);
 1697      %LSET FNC = CHARTEXT('_CLSSSN');
 1698      %KV$VDO_CLSSSN (NAME = NAME, STCLASS = STCLASS);
 1699      %LSET FNC = CHARTEXT('_CLSSTR');
 1700      %KV$VDO_CLSSTR (NAME = NAME, STCLASS = STCLASS);
 1701      %LSET FNC = CHARTEXT('_DAT');
 1702      %KV$VDO_DAT (NAME = NAME, STCLASS = STCLASS);
 1703      %LSET FNC = CHARTEXT('_DCLFLD');
 1704      %KV$VDO_DCLFLD (NAME = NAME, STCLASS = STCLASS);
 1705      %LSET FNC = CHARTEXT('_DCLSTR');
 1706      %KV$VDO_DCLSTR (NAME = NAME, STCLASS = STCLASS);
 1707      %LSET FNC = CHARTEXT('_DLT');
 1708      %KV$VDO_DLT (NAME = NAME, STCLASS = STCLASS);
 1709      %LSET FNC = CHARTEXT('_DSC');
 1710      %KV$VDO_DSC (NAME = NAME, STCLASS = STCLASS);
 1711      %LSET FNC = CHARTEXT('_ERS');
 1712      %KV$VDO_ERS (NAME = NAME, STCLASS = STCLASS);
 1713      %LSET FNC = CHARTEXT('_EVT');
 1714      %KV$VDO_EVT (NAME = NAME, STCLASS = STCLASS);
 1715      %LSET FNC = CHARTEXT('_HVPS');
 1716      %KV$VDO_HVPS (NAME = NAME, STCLASS = STCLASS);
 1717      %LSET FNC = CHARTEXT('_MRK');
 1718      %KV$VDO_MRK (NAME = NAME, STCLASS = STCLASS);
 1719      %LSET FNC = CHARTEXT('_NOP');
 1720      %KV$VDO_NOP (NAME = NAME, STCLASS = STCLASS);
 1721      %LSET FNC = CHARTEXT('_OPNSSN');
 1722      %KV$VDO_OPNSSN (NAME = NAME, STCLASS = STCLASS);
 1723      %LSET FNC = CHARTEXT('_OPNSTR');
14:55 JUL 28 '97 KV$VDO.:E05SI                                             67   
 1724      %KV$VDO_OPNSTR (NAME = NAME, STCLASS = STCLASS);
 1725      %LSET FNC = CHARTEXT('_PRM');
 1726      %KV$VDO_PRM (NAME = NAME, STCLASS = STCLASS);
 1727      %LSET FNC = CHARTEXT('_RLSFLD');
 1728      %KV$VDO_RLSFLD (NAME = NAME, STCLASS = STCLASS);
 1729      %LSET FNC = CHARTEXT('_RMS');
 1730      %KV$VDO_RMS (NAME = NAME, STCLASS = STCLASS);
 1731      %LSET FNC = CHARTEXT('_RQSDAT');
 1732      %KV$VDO_RQSDAT (NAME = NAME, STCLASS = STCLASS);
 1733      %LSET FNC = CHARTEXT('_RQSMRK');
 1734      %KV$VDO_RQSMRK (NAME = NAME, STCLASS = STCLASS);
 1735      %LSET FNC = CHARTEXT('_RQSPRM');
 1736      %KV$VDO_RQSPRM (NAME = NAME, STCLASS = STCLASS);
 1737      %LSET FNC = CHARTEXT('_RQSSTT');
 1738      %KV$VDO_RQSSTT (NAME = NAME, STCLASS = STCLASS);
 1739      %LSET FNC = CHARTEXT('_SLCFLD');
 1740      %KV$VDO_SLCFLD (NAME = NAME, STCLASS = STCLASS);
 1741      %LSET FNC = CHARTEXT('_SLCGRPRND');
 1742      %KV$VDO_SLCGRPRND (NAME = NAME, STCLASS = STCLASS);
 1743      %LSET FNC = CHARTEXT('_SLCQLF');
 1744      %KV$VDO_SLCQLF (NAME = NAME, STCLASS = STCLASS);
 1745      %LSET FNC = CHARTEXT('_SMS');
 1746      %KV$VDO_SMS (NAME = NAME, STCLASS = STCLASS);
 1747      %LSET FNC = CHARTEXT('_STT');
 1748      %KV$VDO_STT (NAME = NAME, STCLASS = STCLASS);
 1749      %LSET FNC = CHARTEXT('_UPDRELDVC');
 1750      %KV$VDO_UPDRELDVC (NAME = NAME, STCLASS = STCLASS);
 1751      %LSET FNC = CHARTEXT('VLP');
 1752      %KV$VDOVLP (NAME = NAME, STCLASS = VLPSTCLASS);
 1753      %LSET FNC = CHARTEXT('VLP_ACTPOS');
 1754      %KV$VDOVLP_ACTPOS (NAME = NAME, STCLASS = VLPSTCLASS);
 1755      %LSET FNC = CHARTEXT('VLP_CG_MSGID');
 1756      %KV$VDOVLP_CG_MSGID (NAME = NAME, STCLASS = VLPSTCLASS);
 1757      %LSET FNC = CHARTEXT('VLP_CG_MSGTYP');
 1758      %KV$VDOVLP_CG_MSGTYP (NAME = NAME, STCLASS = VLPSTCLASS);
 1759      %LSET FNC = CHARTEXT('VLP_CG_STA');
 1760      %KV$VDOVLP_CG_STA (NAME = NAME, STCLASS = VLPSTCLASS);
14:55 JUL 28 '97 KV$VDO.:E05SI                                             68   
 1761      %LSET FNC = CHARTEXT('VLP_DAT1');
 1762      %KV$VDOVLP_DAT1 (NAME = NAME, STCLASS = VLPSTCLASS, DAT = DAT);
 1763      %LSET FNC = CHARTEXT('VLP_DAT2');
 1764      %KV$VDOVLP_DAT2 (NAME = NAME, STCLASS = VLPSTCLASS, DAT = DAT);
 1765      %LSET FNC = CHARTEXT('VLP_ENTSRD');
 1766      %KV$VDOVLP_ENTSRD (NAME = NAME, STCLASS = VLPSTCLASS, DAT = DAT);
 1767      %LSET FNC = CHARTEXT('VLP_ERR');
 1768      %KV$VDOVLP_ERR (NAME = NAME, STCLASS = VLPSTCLASS);
 1769      %LSET FNC = CHARTEXT('VLP_FLDID');
 1770      %KV$VDOVLP_FLDID (NAME = NAME, STCLASS = VLPSTCLASS);
 1771      %LSET FNC = CHARTEXT('VLP_KEY');
 1772      %KV$VDOVLP_KEY (NAME = NAME, STCLASS = VLPSTCLASS, DAT = DAT);
 1773      %LSET FNC = CHARTEXT('VLP_MRK');
 1774      %KV$VDOVLP_MRK (NAME = NAME, STCLASS = VLPSTCLASS);
 1775      %MEND;

