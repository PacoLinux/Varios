VERSION E05

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:1    
        1        1        /*M* GJS$READ_RU  Get the pieces of the run-unit from the host  */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* PLM=3,IND=5,ENU=0,ECU=0,CRM=70   */
        8        8
        9        9        /*F* NAME: GJS$READ_RU
       10       10
       11       11             PURPOSE:  To read the Read Only Segment, the data and the
       12       12                       procedure portions of a run-unit.
       13       13
       14       14        */
       15       15        GJS$READ_RU: PROC(P) ALTRET;
       16       16
       17       17        %INCLUDE GH_HARDWARE_M;
       18      115        %INCLUDE GH_IOFNC_E;
       19      184 S      %INCLUDE GH_LCP6_M;
       20      185        %INCLUDE GJ_MACROS_M;
       21      658        %INCLUDE GJ_MSG_M;
       22      971 S      %INCLUDE GU_LCP6_M;
       23      972        %INCLUDE G_JIT_M;
       24     1237 S      %INCLUDE G_LCP6_E;
       25     1238        %INCLUDE GM_VIRTUAL_E;
       26     1448        %INCLUDE F_ERRORS_C;
       27     1688        %INCLUDE B$OBJECT_C;
       28     5118
       29     5119                                                /* Input Parameters         */
       30     5120        %GJ_READ_PARAMS (FPTN=P,STCLASS= );
       31     5217                                                /* AUTO Storage             */
       32     5218    1   DCL I UBIN;
       33     5219    1   DCL J UBIN;
       34     5220    1   DCL N UBIN;
       35     5221    1   DCL ASDT_INDX UBIN;
       36     5222    1   DCL MY_LOC$ PTR;
       37     5223    1   DCL MY_LOC REDEF MY_LOC$ UBIN(32);
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:2    
       38     5224    1   DCL KEY_BUF_ VECTOR;
       39     5225    1   DCL PROG_BUF_ VECTOR;
       40     5226    1   DCL BPAR1$ PTR;
       41     5227    1   DCL THIS_BYSZ UBIN(32);
       42     5228    1   DCL REMAINING_BYSZ UBIN(32);
       43     5229    1   DCL USR_VBASE UBIN(32);
       44     5230    1   DCL USR_OFFSET UBIN(32);
       45     5231    1   DCL A6 UBIN(32);
       46     5232    1   DCL A66 UBIN(32);
       47     5233    1   DCL THIS_WDSZ UBIN(32);
       48     5234
       49     5235        %GJ_PROGKEY_MSG (FPTN=KEY_MSG,
       50     5236           STCLASS=AUTO);
       51     5336
       52     5337    1   DCL 1 STATUS ALIGNED,
       53     5338    1         2 WD1 BIT(16),
       54     5339    1         2 WD2 BIT(16);
       55     5340
       56     5341    1   DCL NAK BIT(1) ALIGNED;
       57     5342
       58     5343
       59     5344                                                /* External data            */
       60     5345    1   DCL G$SEG$(0:30) PTR SYMREF READONLY;
       61     5346    1   DCL G$ASDT_USR$ PTR SYMREF READONLY;
       62     5347    1   DCL G$ASDT_MCL$ PTR SYMREF READONLY;
       63     5348    1   DCL G$JIT$ PTR SYMREF READONLY;
       64     5349    1   DCL GJ_FETCH_SZ UBIN SYMREF;
       65     5350
       66     5351
       67     5352
       68     5353                                                /* Constant Data            */
       69     5354
       70     5355
       71     5356                                                /* BASED Structures         */
       72     5357        %G$ASDT_MCL (STCLASS="BASED(G$ASDT_MCL$)");
       73     6051        %G$ASDT (FPTN=G$ASDT_USR,STCLASS="BASED(G$ASDT_USR$)");
       74     6080        %G$JIT (STCLASS="BASED(G$JIT$)");
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:3    
       75     6494
       76     6495                                                /*   External Procedures    */
       77     6496    1   DCL GI_READBOOT EPTR SYMREF;
       78     6497    1   DCL KNA$READ ENTRY(4) ALTRET;
       79     6498    1   DCL KNA$WRITE ENTRY(4) ALTRET;
       80     6499
       81     6500                                                /* String Substitutions     */
       82     6501        %B$RECORDSUBS;
       83     6529        %G$JIT_E;
       84     6591        %GJ_FCN#;
       85     6617        %PLIST;
       86     6618
       87     6619        %EJECT;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:4    
       88     6620    1      IF P.TOT_SECTSZ = 0 THEN RETURN;
       89     6621
       90     6622        /*   Copy input parameters to AUTO so we may modify them.
       91     6623        */
       92     6624    1      REMAINING_BYSZ = P.TOT_SECTSZ * 2;
       93     6625    1      MY_LOC$ = P.USR_LOC$;
       94     6626
       95     6627        /*   Initialize the run-unit key message.
       96     6628        */
       97     6629    1      IF G$JIT.PROG_ENTRY ~= %G_PE_BF#
       98     6630    2      THEN DO;
       99     6631    2           KEY_BUF_ = VECTOR(KEY_MSG);
      100     6632    2           KEY_MSG.FCN = P.PROG_TYPE;
      101     6633    2           KEY_MSG.RU_KEY.KEYSIZ = 5;
      102     6634    2           KEY_MSG.RU_KEY.TYPE = %TYPPROG;
      103     6635    2           END;
      104     6636
      105     6637        /*   Or, initialize the DCWs if reading an initial user from
      106     6638             the boot image.
      107     6639        */
      108     6640    2      ELSE DO;
      109     6641    2           A66 = P.HOST_OFFSET ;
      110     6642
      111     6643    2           END;
      112     6644
      113     6645
      114     6646        /*   If this is Read Only Segment data, the key of the first
      115     6647             record will be the bias of Read Only Segment.  If program
      116     6648             data or procedure, the key will be as computed by GJS$STEP.
      117     6649        */
      118     6650    1      IF MY_LOC >= %GM_ISR1_BASE
      119     6651    1      THEN KEY_MSG.RU_KEY.USRADDR$ = MY_LOC$;
      120     6652    1      ELSE KEY_MSG.RU_KEY.PAGE = %GM_ROS_BASE;
      121     6653
      122     6654        /*   If this program is to be read from KIF$FPRG on the host,
      123     6655             the size of each chunk read is 512 bytes (256 L6 words).
      124     6656             If reading from the boot images the size of each chunk is
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:5    
      125     6657             4096 bytes (2048 L6 words).
      126     6658        */
      127     6659    1      IF G$JIT.PROG_ENTRY = %G_PE_BF#
      128     6660    1      THEN THIS_BYSZ = 512*256;            /* a large segment          */
      129     6661
      130     6662    2      ELSE DO;
      131     6663    2           THIS_BYSZ = GJ_FETCH_SZ;
      132     6664
      133     6665        /*   Write a message to the Host indicating what record to read.
      134     6666        */
      135     6667    2           KEY_MSG.READ_BYSZ = GJ_FETCH_SZ;
      136     6668    2           KEY_MSG.SECT_BYSZ = REMAINING_BYSZ;
      137     6669
      138     6670    2           CALL KNA$WRITE(P.DCB#,KEY_BUF_,P.ERR)
      139     6671    3           WHENALTRETURN DO;
      140     6672    3                ALTRETURN;
      141     6673    3                END;
      142     6674    2           END/*do if reading from host*/;
      143     6675
      144     6676
      145     6677        /*   Compute the number of records to read.
      146     6678        */
      147     6679    1      N = (REMAINING_BYSZ + THIS_BYSZ -2) / THIS_BYSZ;
      148     6680
      149     6681    2      DO I = 1 TO N;
      150     6682
      151     6683        /*   If this is the last record, its size is the size remianing.
      152     6684        */
      153     6685    2           IF REMAINING_BYSZ < THIS_BYSZ
      154     6686    3           THEN DO;
      155     6687    3                THIS_BYSZ = REMAINING_BYSZ;
      156     6688    3                END;
      157     6689
      158     6690    3           ELSE DO;
      159     6691    3                REMAINING_BYSZ = REMAINING_BYSZ - THIS_BYSZ;
      160     6692    3                END;
      161     6693
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:6    
      162     6694        /*  Now, based on the address specified within the user's virtual
      163     6695            area, set up an index into the user's base level ASDT and compute
      164     6696            the virtual base address of that segment.
      165     6697        */
      166     6698    2           IF MY_LOC >= %GM_ISR1_BASE
      167     6699    3           THEN DO;
      168     6700    3                ASDT_INDX = (MY_LOC / (1024 * 64)) + 15;
      169     6701    3                USR_VBASE = (ASDT_INDX - 15) * (1024 * 64);
      170     6702    3                END;
      171     6703    3           ELSE DO;
      172     6704    3                ASDT_INDX = (MY_LOC / (1024 * 4) );
      173     6705    3                USR_VBASE = (ASDT_INDX) * (1024 * 4);
      174     6706    3                END;
      175     6707
      176     6708    2           USR_OFFSET = MY_LOC - USR_VBASE;
      177     6709
      178     6710        /*   If this is not an initial LCP-6 user, the record is
      179     6711             then read as follows:
      180     6712        */
      181     6713    2           IF G$JIT.PROG_ENTRY ~= %G_PE_BF#
      182     6714    3           THEN DO;
      183     6715        /*   Get the descriptor from ASDT_USR and move it to ASDT_MCL.BPAR1.
      184     6716        */
      185     6717    3                G$ASDT_MCL.BPAR1 = G$ASDT_USR.DESC(ASDT_INDX);
      186     6718
      187     6719        /* Build a pointer to BPAR1 to pass to the read routine.
      188     6720        */
      189     6721    3                BPAR1$ = PINCRW(G$SEG$(%GM_BPAR1#),USR_OFFSET);
      190     6722    3                VBASE(PROG_BUF_) = BPAR1$;
      191     6723    3                VBOUND(PROG_BUF_) = THIS_BYSZ -1;
      192     6724
      193     6725        /*   And now, read that record.
      194     6726        */
      195     6727    3                CALL KNA$READ(P.DCB#,PROG_BUF_,P.ERR)
      196     6728    4                WHENALTRETURN DO;
      197     6729
      198     6730        /*   Since the data or procedure sections may have gaps caused
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:7    
      199     6731             by rounding up to the next segment boundry, we allow those
      200     6732             errors and continue processing.
      201     6733        */
      202     6734    4                     IF MY_LOC >= %GM_ISR1_BASE
      203     6735    5                     THEN DO;
      204     6736    5                          IF (P.ERR.ERR# = %E$NOKEY) OR (P.ERR.ERR# = %E$EOD/*??*/)
      205     6737    5                          THEN P.ERR = '0'B;
      206     6738    5                          ELSE ALTRETURN;
      207     6739    5                          END;
      208     6740    4                     ELSE ALTRETURN;
      209     6741    4                     END;
      210     6742    3                END /* DO if a normal user */;
      211     6743
      212     6744        /*   If this is an initial LCP-6 user then the record is read
      213     6745             from the boot image.
      214     6746        */
      215     6747    3           ELSE DO;
      216     6748    3                A6 = (G$ASDT_USR.DESC.BASE(ASDT_INDX) * 256) + USR_OFFSET;
      217     6749    3                THIS_WDSZ=THIS_BYSZ/2;
      218     6750    3                CALL GI_READBOOT(A66,A6,THIS_WDSZ);
      219     6751
      220     6752    3                A66 = A66 + THIS_BYSZ /4;
      221     6753    3                END /* DO if an initial user */;
      222     6754
      223     6755        /*   Update the pointer into the user's area by the number of
      224     6756             words of data we just read.  It will now point at a 1024
      225     6757             word segment boundry if we just read a little first record.
      226     6758        */
      227     6759    2           MY_LOC$ = PINCRW(MY_LOC$,THIS_BYSZ /2);
      228     6760
      229     6761
      230     6762    2           END /*DO I = 1 to N */;
      231     6763    1      RETURN;
      232     6764    1   END GJS$READ_RU;

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:8    
--  Include file information  --

   B$OBJECT_C.:E05TOU  is referenced.
   F_ERRORS_C.:E05TOU  is referenced.
   GM_VIRTUAL_E.:E05TOU  is referenced.
   G_JIT_M.:E05TOU  is referenced.
   GJ_MSG_M.:E05TOU  is referenced.
   GJ_MACROS_M.:E05TOU  is referenced.
   GH_IOFNC_E.:E05TOU  is referenced.
   GH_HARDWARE_M.:E05TOU  is referenced.
   G_LCP6_E.:E05TOU  was found in the system file and is referenced.
   GT_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   KI_CP6.:E05TOU  was found in the system file and is never referenced.
   GF_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GM_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GU_LCP6_M.:E05TOU  was found in the system file and is referenced.
   GJ_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GH_LCP6_M.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure GJS$READ_RU.

   Procedure GJS$READ_RU requires 399 words for executable code.
   Procedure GJS$READ_RU requires 70 words of local(AUTO) storage.

    No errors detected in file GJS$READ_RU.:E05TSI    .

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:9    

 Object Unit name= GJS$READ_RU                                File name= GJS$READ_RU.:E05TOU
 UTS= JUL 29 '97 21:59:31.40 TUE                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_LCP6_SYSTEM                               Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size HexSiz  Section name
    0   Proc  even  none   399    18F  GJS$READ_RU

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect HexLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        1  GJS$READ_RU

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       4 KNA$WRITE
 yes     yes           Std       4 KNA$READ
                       nStd      0 X6A_AUTO_1
                       nStd      0 X6A_ARET
                       nStd      0 X6A_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
r    G$SEG$                           r    G$ASDT_USR$                      r    G$ASDT_MCL$
r    G$JIT$                                GJ_FETCH_SZ                           GI_READBOOT
r    G$ROS$
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:10   


        1        1        /*M* GJS$READ_RU  Get the pieces of the run-unit from the host  */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* PLM=3,IND=5,ENU=0,ECU=0,CRM=70   */
        8        8
        9        9        /*F* NAME: GJS$READ_RU
       10       10
       11       11             PURPOSE:  To read the Read Only Segment, the data and the
       12       12                       procedure portions of a run-unit.
       13       13
       14       14        */
       15       15        GJS$READ_RU: PROC(P) ALTRET;

     15   0 000000  D380 0000 0000  xent GJS$READ_RU     LNJ,B5   X6A_AUTO_1
          0 000003       0046 0001                       DC       70,1

       16       16
       17       17        %INCLUDE GH_HARDWARE_M;
       18      115        %INCLUDE GH_IOFNC_E;
       19      184 S      %INCLUDE GH_LCP6_M;
       20      185        %INCLUDE GJ_MACROS_M;
       21      658        %INCLUDE GJ_MSG_M;
       22      971 S      %INCLUDE GU_LCP6_M;
       23      972        %INCLUDE G_JIT_M;
       24     1237 S      %INCLUDE G_LCP6_E;
       25     1238        %INCLUDE GM_VIRTUAL_E;
       26     1448        %INCLUDE F_ERRORS_C;
       27     1688        %INCLUDE B$OBJECT_C;
       28     5118
       29     5119                                                /* Input Parameters         */
       30     5120        %GJ_READ_PARAMS (FPTN=P,STCLASS= );
       31     5217                                                /* AUTO Storage             */
       32     5218    1   DCL I UBIN;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:11   
       33     5219    1   DCL J UBIN;
       34     5220    1   DCL N UBIN;
       35     5221    1   DCL ASDT_INDX UBIN;
       36     5222    1   DCL MY_LOC$ PTR;
       37     5223    1   DCL MY_LOC REDEF MY_LOC$ UBIN(32);
       38     5224    1   DCL KEY_BUF_ VECTOR;
       39     5225    1   DCL PROG_BUF_ VECTOR;
       40     5226    1   DCL BPAR1$ PTR;
       41     5227    1   DCL THIS_BYSZ UBIN(32);
       42     5228    1   DCL REMAINING_BYSZ UBIN(32);
       43     5229    1   DCL USR_VBASE UBIN(32);
       44     5230    1   DCL USR_OFFSET UBIN(32);
       45     5231    1   DCL A6 UBIN(32);
       46     5232    1   DCL A66 UBIN(32);
       47     5233    1   DCL THIS_WDSZ UBIN(32);
       48     5234
       49     5235        %GJ_PROGKEY_MSG (FPTN=KEY_MSG,
       50     5236           STCLASS=AUTO);
       51     5336
       52     5337    1   DCL 1 STATUS ALIGNED,
       53     5338    1         2 WD1 BIT(16),
       54     5339    1         2 WD2 BIT(16);
       55     5340
       56     5341    1   DCL NAK BIT(1) ALIGNED;
       57     5342
       58     5343
       59     5344                                                /* External data            */
       60     5345    1   DCL G$SEG$(0:30) PTR SYMREF READONLY;
       61     5346    1   DCL G$ASDT_USR$ PTR SYMREF READONLY;
       62     5347    1   DCL G$ASDT_MCL$ PTR SYMREF READONLY;
       63     5348    1   DCL G$JIT$ PTR SYMREF READONLY;
       64     5349    1   DCL GJ_FETCH_SZ UBIN SYMREF;
       65     5350
       66     5351
       67     5352
       68     5353                                                /* Constant Data            */
       69     5354
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:12   
       70     5355
       71     5356                                                /* BASED Structures         */
       72     5357        %G$ASDT_MCL (STCLASS="BASED(G$ASDT_MCL$)");
       73     6051        %G$ASDT (FPTN=G$ASDT_USR,STCLASS="BASED(G$ASDT_USR$)");
       74     6080        %G$JIT (STCLASS="BASED(G$JIT$)");
       75     6494
       76     6495                                                /*   External Procedures    */
       77     6496    1   DCL GI_READBOOT EPTR SYMREF;
       78     6497    1   DCL KNA$READ ENTRY(4) ALTRET;
       79     6498    1   DCL KNA$WRITE ENTRY(4) ALTRET;
       80     6499
       81     6500                                                /* String Substitutions     */
       82     6501        %B$RECORDSUBS;
       83     6529        %G$JIT_E;
       84     6591        %GJ_FCN#;
       85     6617        %PLIST;
       86     6618
       87     6619        %EJECT;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:13   
       88     6620    1      IF P.TOT_SECTSZ = 0 THEN RETURN;

   6620   0 000005  ECC7 0004                            LDB,B6   @P,AUTO
          0 000007  8CC6 0005                            LDI      5,B6
          0 000009  84F0 0000 0000                       SID      0,IMO
          0 00000C  6981 0006                            BNEZ,R6  s:6624,PREL
          0 00000E  7981 0004                            BNEZ,R7  s:6624,PREL

   6620   0 000010  C380 0000 0000  xent                 LNJ,B4   X6A_ARET

       89     6621
       90     6622        /*   Copy input parameters to AUTO so we may modify them.
       91     6623        */
       92     6624    1      REMAINING_BYSZ = P.TOT_SECTSZ * 2;

   6624   0 000013  8CC6 0005                            LDI      5,B6
          0 000015  7081                                 DOL,R7   1
          0 000016  8D47 0016                            SDI      REMAINING_BYSZ,AUTO

       93     6625    1      MY_LOC$ = P.USR_LOC$;

   6625   0 000018  DCC6 0007                            LDB,B5   7,B6
          0 00001A  DFC7 000A                            STB,B5   MY_LOC$,AUTO

       94     6626
       95     6627        /*   Initialize the run-unit key message.
       96     6628        */
       97     6629    1      IF G$JIT.PROG_ENTRY ~= %G_PE_BF#

   6629   0 00001C  CC80 0000 0000  xsym                 LDB,B4   G$JIT$
          0 00001F  82C4 0003                            LB,'00FF'X        3,B4
          0 000021       00FF
          0 000022  0581 001B                            BBF      s:6641,PREL

       98     6630    2      THEN DO;

       99     6631    2           KEY_BUF_ = VECTOR(KEY_MSG);
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:14   

   6631   0 000024  BBC7 0022                            LAB,B3   KEY_MSG,AUTO
          0 000026  BFC7 0031                            STB,B3   KEY_MSG+15,AUTO
          0 000028  5C13                                 LDV,R5   19
          0 000029  DF47 0030                            STR,R5   KEY_MSG+14,AUTO
          0 00002B  ABC7 0030                            LAB,B2   KEY_MSG+14,AUTO
          0 00002D  2C00                                 LDV,R2   0
          0 00002E  6C06                                 LDV,R6   6
          0 00002F  BB87                                 LAB,B3   ,AUTO
          0 000030  3C18                                 LDV,R3   24
          0 000031  0008                                 MMM

      100     6632    2           KEY_MSG.FCN = P.PROG_TYPE;

   6632   0 000032  E806                                 LDR,R6   ,B6
          0 000033  E7C7 0022                            STH,R6   KEY_MSG,AUTO

      101     6633    2           KEY_MSG.RU_KEY.KEYSIZ = 5;

   6633   0 000035  6C05                                 LDV,R6   5
          0 000036  E7C7 0025                            STH,R6   KEY_MSG+3,AUTO

      102     6634    2           KEY_MSG.RU_KEY.TYPE = %TYPPROG;

   6634   0 000038  4C0A                                 LDV,R4   10
          0 000039  CAC7 0025                            SRM,R4,'00FF'X    KEY_MSG+3,AUTO
          0 00003B       00FF

      103     6635    2           END;

   6635   0 00003C  0F81 0005                            B        s:6650,PREL

      104     6636
      105     6637        /*   Or, initialize the DCWs if reading an initial user from
      106     6638             the boot image.
      107     6639        */
      108     6640    2      ELSE DO;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:15   

      109     6641    2           A66 = P.HOST_OFFSET ;

   6641   0 00003E  8CC6 0009                            LDI      9,B6
          0 000040  8D47 001E                            SDI      A66,AUTO

      110     6642
      111     6643    2           END;

      112     6644
      113     6645
      114     6646        /*   If this is Read Only Segment data, the key of the first
      115     6647             record will be the bias of Read Only Segment.  If program
      116     6648             data or procedure, the key will be as computed by GJS$STEP.
      117     6649        */
      118     6650    1      IF MY_LOC >= %GM_ISR1_BASE

   6650   0 000042  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 000044  84F0 0001 0000                       SID      65536,IMO
          0 000047  0681 0007                            BCF      s:6652,PREL

      119     6651    1      THEN KEY_MSG.RU_KEY.USRADDR$ = MY_LOC$;

   6651   0 000049  DCC7 000A                            LDB,B5   MY_LOC$,AUTO
          0 00004B  DFC7 0026                            STB,B5   KEY_MSG+4,AUTO
          0 00004D  0F81 0006                            B        s:6659,PREL

      120     6652    1      ELSE KEY_MSG.RU_KEY.PAGE = %GM_ROS_BASE;

   6652   0 00004F  8CF0 0000 1000                       LDI      4096,IMO
          0 000052  8D47 0026                            SDI      KEY_MSG+4,AUTO

      121     6653
      122     6654        /*   If this program is to be read from KIF$FPRG on the host,
      123     6655             the size of each chunk read is 512 bytes (256 L6 words).
      124     6656             If reading from the boot images the size of each chunk is
      125     6657             4096 bytes (2048 L6 words).
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:16   
      126     6658        */
      127     6659    1      IF G$JIT.PROG_ENTRY = %G_PE_BF#

   6659   0 000054  82C4 0003                            LB,'00FF'X        3,B4
   6659   0 000056       00FF
          0 000057  0501 0008                            BBT      s:6663,PREL

      128     6660    1      THEN THIS_BYSZ = 512*256;            /* a large segment          */

   6660   0 000059  8CF0 0002 0000                       LDI      131072,IMO
          0 00005C  8D47 0014                            SDI      THIS_BYSZ,AUTO
          0 00005E  0F81 002A                            B        s:6679,PREL

      129     6661
      130     6662    2      ELSE DO;

      131     6663    2           THIS_BYSZ = GJ_FETCH_SZ;

   6663   0 000060  F800 0000 0000  xsym                 LDR,R7   GJ_FETCH_SZ
          0 000063  6C00                                 LDV,R6   0
          0 000064  8D47 0014                            SDI      THIS_BYSZ,AUTO

      132     6664
      133     6665        /*   Write a message to the Host indicating what record to read.
      134     6666        */
      135     6667    2           KEY_MSG.READ_BYSZ = GJ_FETCH_SZ;

   6667   0 000066  F800 0000 0000  xsym                 LDR,R7   GJ_FETCH_SZ
          0 000069  6C00                                 LDV,R6   0
          0 00006A  8D47 0028                            SDI      KEY_MSG+6,AUTO

      136     6668    2           KEY_MSG.SECT_BYSZ = REMAINING_BYSZ;

   6668   0 00006C  8CC7 0016                            LDI      REMAINING_BYSZ,AUTO
          0 00006E  8D47 002A                            SDI      KEY_MSG+8,AUTO

      137     6669
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:17   
      138     6670    2           CALL KNA$WRITE(P.DCB#,KEY_BUF_,P.ERR)

   6670   0 000070  DBC6 000C                            LAB,B5   12,B6
          0 000072  DFC7 0034                            STB,B5   KEY_MSG+18,AUTO
          0 000074  BBC7 000C                            LAB,B3   KEY_BUF_,AUTO
          0 000076  BFC7 0032                            STB,B3   KEY_MSG+16,AUTO
          0 000078  ABC6 000B                            LAB,B2   11,B6
          0 00007A  AFC7 0030                            STB,B2   KEY_MSG+14,AUTO
          0 00007C  BBC7 0030                            LAB,B3   KEY_MSG+14,AUTO
          0 00007E  CBF0 0300                            LAB,B4   768,IMO
          0 000080  E380 0000 0000  xent                 LNJ,B6   KNA$WRITE
          0 000083       0003                            DC       s:6672,PREL
          0 000084  0F81 0004                            B        s:6679,PREL

      139     6671    3           WHENALTRETURN DO;

      140     6672    3                ALTRETURN;

   6672   0 000086  C380 0000 0000  xent                 LNJ,B4   X6A_AALT

      141     6673    3                END;
      142     6674    2           END/*do if reading from host*/;

      143     6675
      144     6676
      145     6677        /*   Compute the number of records to read.
      146     6678        */
      147     6679    1      N = (REMAINING_BYSZ + THIS_BYSZ -2) / THIS_BYSZ;

   6679   0 000089  8CC7 0016                            LDI      REMAINING_BYSZ,AUTO
          0 00008B  8447 0014                            AID      THIS_BYSZ,AUTO
          0 00008D  8470 FFFF FFFE                       AID      -2,IMO
          0 000090  8D47 0042                            SDI      KEY_MSG+32,AUTO
          0 000092  0027                                 CBD      ;
          0 000093       0407 0014                                BINARY(THIS_BYSZ,AUTO,,4),;
          0 000095       4C07 0030                                UNPACKED(KEY_MSG+14,AUTO,,12,LEADING)
          0 000097  0027                                 CBD      ;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:18   
          0 000098       0407 0042                                BINARY(KEY_MSG+32,AUTO,,4),;
          0 00009A       4C07 0036                                UNPACKED(KEY_MSG+20,AUTO,,12,LEADING)
          0 00009C  002B                                 DDV      ;
          0 00009D       4C07 0030                                UNPACKED(KEY_MSG+14,AUTO,,12,LEADING),;
          0 00009F       4C07 0036                                UNPACKED(KEY_MSG+20,AUTO,,12,LEADING),;
          0 0000A1       4C07 003C                                UNPACKED(KEY_MSG+26,AUTO,,12,LEADING)
          0 0000A3  002A                                 CDB      ;
          0 0000A4       4C07 003C                                UNPACKED(KEY_MSG+26,AUTO,,12,LEADING),;
          0 0000A6       0407 0044                                BINARY(KEY_MSG+34,AUTO,,4)
          0 0000A8  437F                                 CSYNC    s:6679+30,SPREL
          0 0000A9  D847 0045                            LDR,R5   KEY_MSG+35,AUTO
          0 0000AB  DF47 0008                            STR,R5   N,AUTO

      148     6680
      149     6681    2      DO I = 1 TO N;

   6681   0 0000AD  4C01                                 LDV,R4   1
          0 0000AE  CF47 0006                            STR,R4   I,AUTO
          0 0000B0  0F81 00D5                            B        s:6762+2,PREL

      150     6682
      151     6683        /*   If this is the last record, its size is the size remianing.
      152     6684        */
      153     6685    2           IF REMAINING_BYSZ < THIS_BYSZ

   6685   0 0000B2  8CC7 0016                            LDI      REMAINING_BYSZ,AUTO
          0 0000B4  84C7 0014                            SID      THIS_BYSZ,AUTO
          0 0000B6  0601 0007                            BCT      s:6691,PREL

      154     6686    3           THEN DO;

      155     6687    3                THIS_BYSZ = REMAINING_BYSZ;

   6687   0 0000B8  8CC7 0016                            LDI      REMAINING_BYSZ,AUTO
          0 0000BA  8D47 0014                            SDI      THIS_BYSZ,AUTO

      156     6688    3                END;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:19   

   6688   0 0000BC  0F81 0007                            B        s:6698,PREL

      157     6689
      158     6690    3           ELSE DO;

      159     6691    3                REMAINING_BYSZ = REMAINING_BYSZ - THIS_BYSZ;

   6691   0 0000BE  8CC7 0016                            LDI      REMAINING_BYSZ,AUTO
          0 0000C0  84C7 0014                            SID      THIS_BYSZ,AUTO
          0 0000C2  8D47 0016                            SDI      REMAINING_BYSZ,AUTO

      160     6692    3                END;

      161     6693
      162     6694        /*  Now, based on the address specified within the user's virtual
      163     6695            area, set up an index into the user's base level ASDT and compute
      164     6696            the virtual base address of that segment.
      165     6697        */
      166     6698    2           IF MY_LOC >= %GM_ISR1_BASE

   6698   0 0000C4  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 0000C6  84F0 0001 0000                       SID      65536,IMO
          0 0000C9  0681 0014                            BCF      s:6704,PREL

      167     6699    3           THEN DO;

      168     6700    3                ASDT_INDX = (MY_LOC / (1024 * 64)) + 15;

   6700   0 0000CB  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 0000CD  70D0                                 DOR,R7   16
          0 0000CE  8470 0000 000F                       AID      15,IMO
          0 0000D1  E857                                 LDR,R6   R7
          0 0000D2  EF47 0009                            STR,R6   ASDT_INDX,AUTO

      169     6701    3                USR_VBASE = (ASDT_INDX - 15) * (1024 * 64);

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:20   
   6701   0 0000D4  F856                                 LDR,R7   R6
          0 0000D5  6C00                                 LDV,R6   0
          0 0000D6  7090                                 DOL,R7   16
          0 0000D7  8470 FFF1 0000                       AID      -983040,IMO
          0 0000DA  8D47 0018                            SDI      USR_VBASE,AUTO

      170     6702    3                END;

   6702   0 0000DC  0F81 000C                            B        s:6708,PREL

      171     6703    3           ELSE DO;

      172     6704    3                ASDT_INDX = (MY_LOC / (1024 * 4) );

   6704   0 0000DE  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 0000E0  70CC                                 DOR,R7   12
          0 0000E1  E857                                 LDR,R6   R7
          0 0000E2  EF47 0009                            STR,R6   ASDT_INDX,AUTO

      173     6705    3                USR_VBASE = (ASDT_INDX) * (1024 * 4);

   6705   0 0000E4  F856                                 LDR,R7   R6
          0 0000E5  6C00                                 LDV,R6   0
          0 0000E6  708C                                 DOL,R7   12
          0 0000E7  8D47 0018                            SDI      USR_VBASE,AUTO

      174     6706    3                END;

      175     6707
      176     6708    2           USR_OFFSET = MY_LOC - USR_VBASE;

   6708   0 0000E9  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 0000EB  84C7 0018                            SID      USR_VBASE,AUTO
          0 0000ED  8D47 001A                            SDI      USR_OFFSET,AUTO

      177     6709
      178     6710        /*   If this is not an initial LCP-6 user, the record is
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:21   
      179     6711             then read as follows:
      180     6712        */
      181     6713    2           IF G$JIT.PROG_ENTRY ~= %G_PE_BF#

   6713   0 0000EF  EC80 0000 0000  xsym                 LDB,B6   G$JIT$
          0 0000F2  82C6 0003                            LB,'00FF'X        3,B6
          0 0000F4       00FF
          0 0000F5  0581 0057                            BBF      s:6748,PREL

      182     6714    3           THEN DO;

      183     6715        /*   Get the descriptor from ASDT_USR and move it to ASDT_MCL.BPAR1.
      184     6716        */
      185     6717    3                G$ASDT_MCL.BPAR1 = G$ASDT_USR.DESC(ASDT_INDX);

   6717   0 0000F7  DC80 0000 0000  xsym                 LDB,B5   G$ASDT_USR$
          0 0000FA  B847 0009                            LDR,R3   ASDT_INDX,AUTO
          0 0000FC  8CB5                                 LDI      ,B5,R3
          0 0000FD  CC80 0000 0000  xsym                 LDB,B4   G$ASDT_MCL$
          0 000100  8D44 002A                            SDI      42,B4

      186     6718
      187     6719        /* Build a pointer to BPAR1 to pass to the read routine.
      188     6720        */
      189     6721    3                BPAR1$ = PINCRW(G$SEG$(%GM_BPAR1#),USR_OFFSET);

   6721   0 000102  8C80 0000 002A  xsym                 LDI      G$SEG$+42
          0 000105  8447 001A                            AID      USR_OFFSET,AUTO
          0 000107  8D47 0012                            SDI      BPAR1$,AUTO

      190     6722    3                VBASE(PROG_BUF_) = BPAR1$;

   6722   0 000109  BCC7 0012                            LDB,B3   BPAR1$,AUTO
          0 00010B  BFC7 0010                            STB,B3   PROG_BUF_+1,AUTO

      191     6723    3                VBOUND(PROG_BUF_) = THIS_BYSZ -1;

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:22   
   6723   0 00010D  8CC7 0014                            LDI      THIS_BYSZ,AUTO
          0 00010F  8470 FFFF FFFF                       AID      -1,IMO
          0 000112  E857                                 LDR,R6   R7
          0 000113  EF47 000F                            STR,R6   PROG_BUF_,AUTO

      192     6724
      193     6725        /*   And now, read that record.
      194     6726        */
      195     6727    3                CALL KNA$READ(P.DCB#,PROG_BUF_,P.ERR)

   6727   0 000115  ACC7 0004                            LDB,B2   @P,AUTO
          0 000117  9BC2 000C                            LAB,B1   12,B2
          0 000119  9FC7 0034                            STB,B1   KEY_MSG+18,AUTO
          0 00011B  EBC7 000F                            LAB,B6   PROG_BUF_,AUTO
          0 00011D  EFC7 0032                            STB,B6   KEY_MSG+16,AUTO
          0 00011F  EBC2 000B                            LAB,B6   11,B2
          0 000121  EFC7 0030                            STB,B6   KEY_MSG+14,AUTO
          0 000123  BBC7 0030                            LAB,B3   KEY_MSG+14,AUTO
          0 000125  CBF0 0300                            LAB,B4   768,IMO
          0 000127  E380 0000 0000  xent                 LNJ,B6   KNA$READ
          0 00012A       0003                            DC       s:6734,PREL
          0 00012B  0F81 001F                            B        s:6742,PREL

      196     6728    4                WHENALTRETURN DO;

      197     6729
      198     6730        /*   Since the data or procedure sections may have gaps caused
      199     6731             by rounding up to the next segment boundry, we allow those
      200     6732             errors and continue processing.
      201     6733        */
      202     6734    4                     IF MY_LOC >= %GM_ISR1_BASE

   6734   0 00012D  8CC7 000A                            LDI      MY_LOC$,AUTO
          0 00012F  84F0 0001 0000                       SID      65536,IMO
          0 000132  0681 0015                            BCF      s:6740,PREL

      203     6735    5                     THEN DO;
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:23   

      204     6736    5                          IF (P.ERR.ERR# = %E$NOKEY) OR (P.ERR.ERR# = %E$EOD/*??*/)

   6736   0 000134  ECC7 0004                            LDB,B6   @P,AUTO
          0 000136  E846 000D                            LDR,R6   13,B6
          0 000138  6043                                 SOR,R6   3
          0 000139  6D42                                 CMV,R6   66
          0 00013A  0901 0004                            BE       s:6737,PREL
          0 00013C  6D0A                                 CMV,R6   10
          0 00013D  0981 0007                            BNE      s:6738,PREL

      205     6737    5                          THEN P.ERR = '0'B;

   6737   0 00013F  8746 000C                            CL       12,B6
          0 000141  8746 000D                            CL       13,B6
          0 000143  0F81 0007                            B        s:6742,PREL

      206     6738    5                          ELSE ALTRETURN;

   6738   0 000145  C380 0000 0000  xent                 LNJ,B4   X6A_AALT

      207     6739    5                          END;
      208     6740    4                     ELSE ALTRETURN;

   6740   0 000148  C380 0000 0000  xent                 LNJ,B4   X6A_AALT

      209     6741    4                     END;
      210     6742    3                END /* DO if a normal user */;

   6742   0 00014B  0F81 0031                            B        s:6759,PREL

      211     6743
      212     6744        /*   If this is an initial LCP-6 user then the record is read
      213     6745             from the boot image.
      214     6746        */
      215     6747    3           ELSE DO;

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:24   
      216     6748    3                A6 = (G$ASDT_USR.DESC.BASE(ASDT_INDX) * 256) + USR_OFFSET;

   6748   0 00014D  DC80 0000 0000  xsym                 LDB,B5   G$ASDT_USR$
          0 000150  B847 0009                            LDR,R3   ASDT_INDX,AUTO
          0 000152  3001                                 SOL,R3   1
          0 000153  F835                                 LDR,R7   ,B5,R3
          0 000154  F570 7FFF                            AND,R7   32767,IMO
          0 000156  6C00                                 LDV,R6   0
          0 000157  7088                                 DOL,R7   8
          0 000158  8447 001A                            AID      USR_OFFSET,AUTO
          0 00015A  8D47 001C                            SDI      A6,AUTO

      217     6749    3                THIS_WDSZ=THIS_BYSZ/2;

   6749   0 00015C  8CC7 0014                            LDI      THIS_BYSZ,AUTO
          0 00015E  70C1                                 DOR,R7   1
          0 00015F  8D47 0020                            SDI      THIS_WDSZ,AUTO

      218     6750    3                CALL GI_READBOOT(A66,A6,THIS_WDSZ);

   6750   0 000161  CBC7 0020                            LAB,B4   THIS_WDSZ,AUTO
          0 000163  CFC7 0034                            STB,B4   KEY_MSG+18,AUTO
          0 000165  BBC7 001C                            LAB,B3   A6,AUTO
          0 000167  BFC7 0032                            STB,B3   KEY_MSG+16,AUTO
          0 000169  ABC7 001E                            LAB,B2   A66,AUTO
          0 00016B  AFC7 0030                            STB,B2   KEY_MSG+14,AUTO
          0 00016D  BBC7 0030                            LAB,B3   KEY_MSG+14,AUTO
          0 00016F  9C80 0000 0000  xsym                 LDB,B1   GI_READBOOT
          0 000172  CBF0 0300                            LAB,B4   768,IMO
          0 000174  E381                                 LNJ,B6   ,B1
          0 000175       0001                            DC       s:6752,PREL

      219     6751
      220     6752    3                A66 = A66 + THIS_BYSZ /4;

   6752   0 000176  8CC7 0014                            LDI      THIS_BYSZ,AUTO
          0 000178  70C2                                 DOR,R7   2
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:25   
          0 000179  8447 001E                            AID      A66,AUTO
          0 00017B  8D47 001E                            SDI      A66,AUTO

      221     6753    3                END /* DO if an initial user */;

      222     6754
      223     6755        /*   Update the pointer into the user's area by the number of
      224     6756             words of data we just read.  It will now point at a 1024
      225     6757             word segment boundry if we just read a little first record.
      226     6758        */
      227     6759    2           MY_LOC$ = PINCRW(MY_LOC$,THIS_BYSZ /2);

   6759   0 00017D  8CC7 0014                            LDI      THIS_BYSZ,AUTO
          0 00017F  70C1                                 DOR,R7   1
          0 000180  8447 000A                            AID      MY_LOC$,AUTO
          0 000182  8D47 000A                            SDI      MY_LOC$,AUTO

      228     6760
      229     6761
      230     6762    2           END /*DO I = 1 to N */;

   6762   0 000184  8AC7 0006                            INC      I,AUTO
          0 000186  E847 0006                            LDR,R6   I,AUTO
          0 000188  E947 0008                            CMR,R6   N,AUTO
          0 00018A  0381 FF27                            BLE      s:6685,PREL

      231     6763    1      RETURN;

   6763   0 00018C  C380 0000 0000  xent                 LNJ,B4   X6A_ARET
      232     6764    1   END GJS$READ_RU;

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:26   
--  Include file information  --

   B$OBJECT_C.:E05TOU  is referenced.
   F_ERRORS_C.:E05TOU  is referenced.
   GM_VIRTUAL_E.:E05TOU  is referenced.
   G_JIT_M.:E05TOU  is referenced.
   GJ_MSG_M.:E05TOU  is referenced.
   GJ_MACROS_M.:E05TOU  is referenced.
   GH_IOFNC_E.:E05TOU  is referenced.
   GH_HARDWARE_M.:E05TOU  is referenced.
   G_LCP6_E.:E05TOU  was found in the system file and is referenced.
   GT_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   KI_CP6.:E05TOU  was found in the system file and is never referenced.
   GF_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GM_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GU_LCP6_M.:E05TOU  was found in the system file and is referenced.
   GJ_LCP6_M.:E05TOU  was found in the system file and is never referenced.
   GH_LCP6_M.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure GJS$READ_RU.
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:27   

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
HexLoc.c.b A Datatyp(siz) R M Lvl/name                 HexLoc.c.b A Datatyp(siz) R M Lvl/name

     4-0-0/w PTR         r     1 @P                        1C-0-0/w UBIN(32)    r     1 A6
    1E-0-0/w UBIN(32)    r     1 A66                        9-0-0/w UBIN(16)    r     1 ASDT_INDX
    12-0-0/w PTR         r     1 BPAR1$                     6-0-0/w UBIN(16)    r     1 I
     C-0-0/w VECT        r     1 KEY_BUF_                  22-0-0/w STRC(160)   r     1 KEY_MSG
     A-0-0/w UBIN(32)    r     1 MY_LOC                     A-0-0/w PTR         r     1 MY_LOC$
     8-0-0/w UBIN(16)    r     1 N                         *0-0-0/w STRC(224)   r     1 P
     F-0-0/w VECT        r     1 PROG_BUF_                 16-0-0/w UBIN(32)    r     1 REMAINING_BYSZ
    14-0-0/w UBIN(32)    r     1 THIS_BYSZ                 20-0-0/w UBIN(32)    r     1 THIS_WDSZ
    1A-0-0/w UBIN(32)    r     1 USR_OFFSET                18-0-0/w UBIN(32)    r     1 USR_VBASE

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
HexLoc.c.b A Datatyp(siz) R M Lvl/name                 HexLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 G$ASDT_MCL$                0-0-0/w PTR         r     1 G$ASDT_USR$
     0-0-0/w PTR         r     1 G$JIT$                     0-0-0/w PTR         r     1 G$SEG$(0:30)
     0-0-0/w EPTR        r     1 GI_READBOOT                0-0-0/w UBIN(16)    r     1 GJ_FETCH_SZ

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
HexLoc.c.b A Datatyp(siz) R M Lvl/name                 HexLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(992)   r     1 G$ASDT_MCL
     0-0-0/w STRC(32)    r     1 G$ASDT_USR(0:30)
     0-0-0/w STRC(5616)  r     1 G$JIT

PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:28   

   Procedure GJS$READ_RU requires 399 words for executable code.
   Procedure GJS$READ_RU requires 70 words of local(AUTO) storage.

    No errors detected in file GJS$READ_RU.:E05TSI    .
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:29   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:30   
          MINI XREF LISTING

A6
      5231**DCL      6748<<ASSIGN   6750<>CALL
A66
      5232**DCL      6641<<ASSIGN   6750<>CALL     6752<<ASSIGN   6752>>ASSIGN
ASDT_INDX
      5221**DCL      6700<<ASSIGN   6701>>ASSIGN   6704<<ASSIGN   6705>>ASSIGN   6717>>ASSIGN   6748>>ASSIGN
BPAR1$
      5226**DCL      6721<<ASSIGN   6722>>ASSIGN
G$ASDT_MCL.BPAR1
      5846**DCL      6717<<ASSIGN
G$ASDT_MCL$
      5347**DCL      5363--IMP-PTR  6717>>ASSIGN
G$ASDT_USR.DESC
      6073**DCL      6717>>ASSIGN
G$ASDT_USR.DESC.BASE
      6075**DCL      6748>>ASSIGN
G$ASDT_USR$
      5346**DCL      6056--IMP-PTR  6717>>ASSIGN   6748>>ASSIGN
G$JIT.ERRLOG
      6424**DCL      6427--REDEF
G$JIT.JSUNIT
      6163**DCL      6164--REDEF
G$JIT.MCLS
      6162**DCL      6162--REDEF
G$JIT.PROG_ENTRY
      6151**DCL      6629>>IF       6659>>IF       6713>>IF
G$JIT.TMRZ
      6431**DCL      6432--REDEF
G$JIT.USER_EXTIME
      6155**DCL      6156--REDEF
G$JIT.USER_MEMTIME
      6158**DCL      6158--REDEF
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:31   
G$JIT.USER_SVTIME
      6157**DCL      6157--REDEF
G$JIT$
      5348**DCL      6094--IMP-PTR  6629>>IF       6659>>IF       6713>>IF
G$SEG$
      5345**DCL      6721>>ASSIGN
GI_READBOOT
      6496**DCL      6750>>CALL
GJ_FETCH_SZ
      5349**DCL      6663>>ASSIGN   6667>>ASSIGN
I
      5218**DCL      6681<<DOINDEX
KEY_BUF_
      5224**DCL      6631<<ASSIGN   6670<>CALL
KEY_MSG
      5262**DCL      6631--ASSIGN
KEY_MSG.FCN
      5262**DCL      6632<<ASSIGN
KEY_MSG.READ_BYSZ
      5328**DCL      6667<<ASSIGN
KEY_MSG.RU_KEY.KEYSIZ
      5319**DCL      6633<<ASSIGN
KEY_MSG.RU_KEY.PAGE
      5323**DCL      5323--REDEF    6652<<ASSIGN
KEY_MSG.RU_KEY.TYPE
      5319**DCL      6634<<ASSIGN
KEY_MSG.RU_KEY.USRADDR$
      5323**DCL      6651<<ASSIGN
KEY_MSG.SECT_BYSZ
      5333**DCL      6668<<ASSIGN
KNA$READ
      6497**DCL-ENT  6727--CALL
KNA$WRITE
      6498**DCL-ENT  6670--CALL
MY_LOC
      5223**DCL      6650>>IF       6698>>IF       6700>>ASSIGN   6704>>ASSIGN   6708>>ASSIGN   6734>>IF
PL6.E3A0      #001=GJS$READ_RU File=GJS$READ_RU.:E05TSI                          TUE 07/29/97 21:59 Page:32   
MY_LOC$
      5222**DCL      5223--REDEF    6625<<ASSIGN   6651>>ASSIGN   6759<<ASSIGN   6759>>ASSIGN
N
      5220**DCL      6679<<ASSIGN   6681>>DOINDEX
P
      5125**DCL        15--PROC
P.DCB#
      5163**DCL      6670<>CALL     6727<>CALL
P.ERR
      5183**DCL      6670<>CALL     6727<>CALL     6737<<ASSIGN
P.ERR.ERR#
      5210**DCL      6736>>IF       6736>>IF
P.HOST_OFFSET
      5157**DCL      6641>>ASSIGN
P.PROG_TYPE
      5126**DCL      6632>>ASSIGN
P.TOT_SECTSZ
      5147**DCL      6620>>IF       6624>>ASSIGN
P.USR_LOC$
      5151**DCL      5152--REDEF    6625>>ASSIGN
PROG_BUF_
      5225**DCL      6722<<ASSIGN   6723<<ASSIGN   6727<>CALL
REMAINING_BYSZ
      5228**DCL      6624<<ASSIGN   6668>>ASSIGN   6679>>ASSIGN   6685>>IF       6687>>ASSIGN   6691<<ASSIGN
      6691>>ASSIGN
THIS_BYSZ
      5227**DCL      6660<<ASSIGN   6663<<ASSIGN   6679>>ASSIGN   6679>>ASSIGN   6685>>IF       6687<<ASSIGN
      6691>>ASSIGN   6723>>ASSIGN   6749>>ASSIGN   6752>>ASSIGN   6759>>ASSIGN
THIS_WDSZ
      5233**DCL      6749<<ASSIGN   6750<>CALL
USR_OFFSET
      5230**DCL      6708<<ASSIGN   6721>>ASSIGN   6748>>ASSIGN
USR_VBASE
      5229**DCL      6701<<ASSIGN   6705<<ASSIGN   6708>>ASSIGN
