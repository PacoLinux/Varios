

14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          1    
    1      /*M* KN_DATA_M - Macros for FEP communications related structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*DMC,PLM=6,IND=2,ENU=2,DCI=4,CSU=2,ECU=2,THI=2,DTI=0*/
    8
    9      /*F* NAME: KN_DATA_M
   10
   11      The file KN_DATA_M contains the macros used to generate
   12      the data structures that relate to the Fep communications
   13      modules.  This includes the context data structures and macros
   14      to generate text for the ANLZ routines that format this data.
   15
   16      .fif
   17         KN$NETPARM  - Structure used to pass parameters through
   18                       the Fep communication layers.
   19         KN_DATA_TBL - Statistical data relating to IOP, SSN, LDCT and
   20                       TCTX usage.
   21         KN$DCT$     - Structure of the LDCT pointer array
   22         KN$LDCT     - Structure of an LDCT
   23         K$TCTX      - Structure of Transport Context Data
   24         KN$IOP      - Structure of an IO Packet
   25
   26         KN_CNTYPE_TXT    - Used by ANLZ
   27         KN_ST_TXT        - Used by ANLZ
   28         KNA_IOPFLAG_TEXT - Used by ANLZ
   29
   30      .fin
   31      This file also contains EQU and SET statements that may be used to
   32      reference some of the fields in the generated data structures.
   33      */
   34
   35
   36      /*F* NAME: KN$NETPARM - Parameters for Fep Communication Layers
   37
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          2    
   38      The KN$NETPARM macro in file KN_DATA_M generates the
   39      structure that is used to pass parameters between
   40      the various communication layers on the FEP.
   41
   42      Basically, the parameter structure contains the
   43      addresses of the headers for the various layers
   44      and the sizes of the headers.
   45
   46      There is no similar structure on the Host; the header
   47      information for the layers is contained in the Host
   48      version of the K$RWPARM structure.
   49
   50      This parameter structure contains the following:
   51      */
   52
   53      %MACRO KN$NETPARM (NAME=KN$NETPARM,STCLASS="");
   54       %LSET LISTDIR='0'B;
   55       %LSET LISTEXP='1'B;
   56       %LSET LISTCOM='0'B;
   57       %LSET LISTSUB='1'B;
   58       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
   59       %IF (SUBSTR(STR,0,6)='STATIC') OR
   60       (SUBSTR(STR,0,8)='CONSTANT') OR
   61       (SUBSTR(STR,0,3)='EXT');
   62       %LSET INIT=CHARTEXT('INIT');
   63       %ELSE;
   64       %LSET INIT=CHARTEXT('/*');
   65       %ENDIF;
   66
   67      DCL 1 NAME STCLASS ALIGNED,
   68            2 LDCT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
   69                          /*K* LDCT$ - PTR.
   70                          Contains a pointer to the LDCT associated
   71                          with the originating communications I/O
   72                          request.
   73                          */
   74            2 MSG$ CPTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          3    
   75                          /*K* MSG$ - CPTR.
   76                          Contains the address of the user's
   77                          applicatation data.
   78                          */
   79            2 MSGW$ REDEF MSG$ PTR,
   80                          /*K* MSGW$ - PTR.
   81                          This is a REDEF of MSG$.
   82                          Contains the address of the user's
   83                          applicatation data.
   84                          */
   85            2 MSGSZ UBIN WORD %INIT(0)%CHARTEXT('/**/'),
   86                          /*K* MSGSZ - UBIN.
   87                          Contains the byte size of the message
   88                          located by KN$NETPARM.MSG$.
   89                          */
   90            2 UHDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
   91            2 UHDR_C$ REDEF UHDR$ CPTR,
   92                          /*K* UHDR$ - PTR.
   93                          Contains the address of the presentation header.
   94                          See KV$VDOxxx in file KNA_DATA_D.
   95
   96                          For KNB$ACTION, UHDR$ will contain the address of
   97                          either KL_CONTROL, KL_CONTROL_INIT, KL_REQSTATS,
   98                          KL_TIME or KL_NODE.
   99                          */
  100            2 UHDRSZ UBIN %INIT(0)%CHARTEXT('/**/'),
  101                          /*K* UHDRSZ - UBIN.
  102                          Contains the byte size of the header located
  103                          via KN$NETPARM.UHDR$.
  104                          */
  105            2 SHDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  106            2 SHDR_C$ REDEF SHDR$ CPTR,
  107                          /*K* SHDR$ - PTR.
  108                          Contains the address of the Session Header.
  109                          See KNS$SQDP_xxx in file K_QDPHDRS_M.
  110                          */
  111            2 SHDRSZ UBIN %INIT(0)%CHARTEXT('/**/'),
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          4    
  112                          /*K* SHDRSZ - UBIN.
  113                          Contains the byte size of the header located
  114                          via KN$NETPARM.SHDR$.
  115                          */
  116            2 THDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  117            2 THDR_C$ REDEF THDR$ CPTR,
  118                          /*K* THDR$ - PTR.
  119                          Contains the address of the Transport Header.
  120                          See K$TPDU_xxx in file K_TRANSPORT_M.
  121                          */
  122            2 THDRSZ UBIN %INIT(0)%CHARTEXT('/**/'),
  123                          /*K* THDRSZ - UBIN.
  124                          Contains the byte size of the header located
  125                          via KN$NETPARM.THDR$.
  126                          */
  127            2 NHDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  128            2 NHDR_C$ REDEF NHDR$ CPTR,
  129                          /*K* NHDR$ - PTR.
  130                          Contains the address of the Network Header.
  131                          See K$NQDP_HDR in file K_QDPHDRS_M.
  132                          */
  133            2 NHDRSZ UBIN %INIT(0)%CHARTEXT('/**/'),
  134                          /*K* NHDRSZ - UBIN.
  135                          Contains the byte size of the header located
  136                          via KN$NETPARM.NHDR$.
  137                          */
  138            2 TCTX_ID UBIN %INIT(0)%CHARTEXT('/**/') ,
  139                          /*K* TCTX_ID - UBIN(16).    ??? delete, use TCTX$ ???
  140                          Contains the index into KN_TCTS$$ for this
  141                          transport connection.
  142                          */
  143            2 FLAGS,
  144              3 * BIT(7) UNAL,
  145              3 CONS BIT(1) UNAL,
  146                          /*K* FLAGS.CONS - BIT(1).
  147                          Indicates to transport and network that this
  148                          transport connection is to use the Connection
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          5    
  149                          Oriented Network Service.
  150                          */
  151
  152            2 QOS UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
  153                          /*K* QOS - UBIN BYTE.
  154                          */
  155            2 RECTYPE UBIN WORD %INIT(0)%CHARTEXT('/**/'),
  156                          /*K* RECTYPE - UBIN.
  157                          KNH$SCAN sets KN$NETPARM.RECTYPE from KNH$MESS.RECTYPE.
  158                          KNH$SEND sets KNH$MESS.RECTYPE from KN$NETPARM.RECTYPE.
  159
  160                          KNN$RECV assumes a special function if called
  161                          with FUNCTION = DATA and KN$NETPARM.RECTYPE non-zero.
  162                          The only one it responds to is KJ_FCN_TIM, and it
  163                          responds by calling KNH$SEND.
  164                          */
  165            2 FUNCTION SBIN %INIT(0)%CHARTEXT('/**/'),
  166                          /*K* FUNCTION - SBIN.
  167                          Contains the function code for this call.
  168
  169                          .xeq KNH_MACRO_C KN_FCN_equ
  170
  171                          .xeq K_INTERFACE_M K_Tfunction_equ
  172
  173                          .xeq K_INTERFACE_M K_Nfunction_equ
  174                          */
  175            2 NODE SBIN %INIT(0)%CHARTEXT('/**/'),
  176                          /*K* NODE - SBIN.
  177                          Contains the destination node number.
  178                          Set from FPT_CONNECT.RLCID.NODE by KNS$SEND or KNT$SEND.
  179                          */
  180            2 ERRCODE UBIN WORD %INIT(0)%CHARTEXT('/**/'),
  181                          /*K* ERRCODE - UBIN.
  182                          Contains the error code returned to the
  183                          calling routine by KNN$SEND, KNS$SEND,
  184                          KNT$SEND and KNT$RECV.
  185
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          6    
  186                          See KN_ERR_xxx and KNT_ER_xxx in file KN_DATA_M.
  187                          */
  188            2 SLDCT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  189                          /*K* SLDCT$ - PTR.
  190                          Contains a pointer to the source LDCT.  This
  191                          is initialized from KN$NETPARM.LDCT$.
  192                          */
  193            2 FPT$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  194                          /*K* FPT$ - PTR.
  195                          Contains the address of the FPT associated with
  196                          this request.
  197                          */
  198            2 TCTX$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  199                          /*K* TCTX$ - PTR.
  200                          Contains the address of the transport context
  201                          block, K$TCTX, for this transport connection.
  202                          */
  203            2 SRC_ADDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/'),
  204                          /*K* SRC_ADDR$ - PTR.
  205                          Contains a pointer to the source network address (NSAP).
  206                          Used only with OSI Session connctions.
  207                          */
  208            2 DST_ADDR$ PTR %INIT(ADDR(NIL))%CHARTEXT('/**/');
  209                          /*K* DST_ADDR$ - PTR.
  210                          Contains a pointer to the destination network address (NSAP).
  211                          Used only with OSI Session connctions.
  212                          */
  213      %MEND;
  214
  215
  216      /*F* NAME: KN$NETPARM_ERROCDE_equ
  217
  218      The KN_DATA_M Include file contains %EQU statements
  219      that are used by the network layers in the fep to
  220      indicate the type of error that has occured.  These
  221      are the values that are stored in KN$NETPARM.ERRCODE.
  222      */
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          7    
  223
  224      %EQU KN_ERR_NOQ = 1;     /* No circular queue available */
  225                               /* Set by KNH$SEND when no room in RCQ */
  226                               /* Set by KNT$SEND if queued for connect confirm */
  227                               /* Set by KNB$BABOON when KN_BUFFER is busy */
  228
  229      %EQU KN_ERR_INVFCN = 2;  /* SSN state incompatible with requested service. */
  230                               /* Set by KNS$SEND and KNT$SEND    */
  231
  232      %EQU KN_ERR_NORTE = 3;   /* No route available                        */
  233                               /* KNN$SEND returns this code to KNA$OPEN    */
  234
  235      %EQU KN_ERR_Q2SMALL = 4; /* This message is too big to ever be sent */
  236                               /* Set by KNH$SEND when msg too big for RCQ */
  237
  238      %EQU KN_ERR_NOLDCT = 5;  /* Out of LDCTs - can't open circuit */
  239                               /* Set by KNN$SEND                 */
  240
  241      %EQU KN_ERR_NOTCTX = 6;  /* Out of TCTXs - can't open transport */
  242                               /* Set by KNT$SEND and KNT$RECV    */
  243
  244      %EQU KN_ERR_NOQ2 = 7;    /* Queued by transport-wait for tpdu_cc or ak*/
  245                               /* Queued by transport -wait for buffer space*/
  246                               /* Queued by KNH$SEND when no room in RCQ and   */
  247                               /* LDCT is already queued.                  */
  248
  249
  250      /*F* NAME: KN_DATA_TBL
  251
  252      The macro is used to generate the data that defines
  253      the limits and usage of the I/O Packets, Session
  254      Context Blocks, Logical Device Control Tables and
  255      Transport Context Blocks.
  256
  257      This macro may also be used to generate a BASED
  258      structure that defines that data.  The pointers
  259      G$BOBCAT.IOPDATA$, G$BOBCAT.SSNDATA$, G$BOBCAT.LDCTDATA$
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          8    
  260      and G$BOBCAT.TCTXDATA$ will contain the addresses of
  261      the data.
  262
  263      To generate the data in monitor static data the
  264      only options to specify are TYPE=DATA and FPTN=context,
  265      where `context' is IOP, LDCT, SSN or TCTX.
  266
  267      To generate a BASED structure of the data, the options
  268      to specify are TYPE=STRUCTURE and FPTN=name.
  269      */
  270
  271
  272      %MACRO KN_DATA_TBL
  273        (TYPE(DATA='0'B,STRUCTURE='1'B,ANY)='0'B,
  274         STCLASS=BASED,
  275         FPTN=KN$DATA);
  276
  277      %LSET LISTDIR='0'B;
  278      %LSET LISTEXP='1'B;
  279      %LSET LISTCOM='0'B;
  280      %LSET LISTSUB='1'B;
  281
  282      %IF TYPE='1'B;
  283      DCL 1 FPTN STCLASS ALIGNED,
  284      %LSET LVL=CHARTEXT('2 ');
  285      %LSET INIT=CHARTEXT(',');
  286      %LSET PINIT=CHARTEXT(',');
  287      %LSET TERM=CHARTEXT(';');
  288
  289      %ELSE;
  290      %LSET LVL=CHARTEXT(CONCAT('DCL 1 KN_',TEXTCHAR(FPTN),'_'));
  291      %LSET INIT=CHARTEXT(' INIT(0) STATIC SYMDEF;');
  292      %LSET PINIT=CHARTEXT(' INIT(ADDR(NIL)) STATIC SYMDEF;');
  293      %LSET TERM=CHARTEXT(CONCAT(' INIT(''',TEXTCHAR(FPTN),''') STATIC SYMDEF;'));
  294      %ENDIF;
  295
  296            %(LVL)START$ PTR%PINIT
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          9    
  297                          /*K* START$ -PTR.
  298                          Contains the address of the first Context Block in
  299                          the BOBCAT data segment.  Setup by BIGFOOT.
  300                          */
  301            %(LVL)END$ PTR%PINIT
  302                          /*K* END$ -PTR.
  303                          Contains the address of the last Context Block in
  304                          the BOBCAT data segment.  Setup by BIGFOOT.
  305                          */
  306            %(LVL)HEAD$ PTR%PINIT
  307                          /*K* HEAD$ -PTR.
  308                          Contains the address of the first in the chain of
  309                          free Context Blocks.  Setup by BIGFOOT; maintained by
  310                          the KNA$GET_CNTX and KNA$RLS_CNTX routines.
  311                          */
  312
  313            %(LVL)MAX# UBIN(16) CALIGNED%INIT
  314                          /*K* MAX# -UBIN WORD.
  315                          Contains the number of Context Blocks in the BOBCAT
  316                          segment.  Set by BIGFOOT.
  317                          */
  318            %(LVL)USE# UBIN(16) CALIGNED%INIT
  319                          /*K* USE# - UBIN WORD.
  320                          Contains the number of Context Blocks currently in use.
  321                          */
  322            %(LVL)PEAK# UBIN(16) CALIGNED%INIT
  323                          /*K* PEAK# - UBIN WORD.
  324                          Contains the maximum number of Context Blocks ever in use at
  325                          at any one time.
  326                          */
  327            %(LVL)CHECK UBIN(16) CALIGNED%INIT
  328                          /*K* CHECK -UBIN WORD.
  329                          Can be set non-zero to activate the routine that
  330                          checks for inconsistancy in the chain of unused
  331                          context blocks.
  332                          */
  333            %(LVL)LNK# UBIN(16) CALIGNED%INIT
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          10   
  334                          /*K* LNK# -UBIN WORD.
  335                          Contains the offset from the start of the context
  336                          block to the word that contains the link (.LNK$) to
  337                          to the next unused context block.
  338                          */
  339            %(LVL)NAME CHAR(4) CALIGNED%TERM
  340                          /*K* NAME - CHAR(4).
  341                          Used for ANLZ reports.
  342                          */
  343      %MEND;
  344
  345
  346
  347
  348      /*F* NAME: KN$DCT$
  349
  350      The KN$DCT$ macro in file KN_DATA_M defines an array of
  351      LDCT pointers based on the KN_DCT$$ pointer.  This
  352      pointer array is allocated in the BOBCAT data segment
  353      when the fep is booted.
  354      The array size is the number of LDCTs +1 (0:LDCT#).
  355      Entry zero is not used.
  356
  357      Each entry is initialized to NIL at boot time.  The
  358      LDCTs are allocated in the BOBCAT data segment following
  359      the KN$DCT$ pointer array.  These LDCTs are chained
  360      together through KN$LDCT.LNK$; the head of the free
  361      LDCT chain is in KN_LDCT_HEAD$.
  362
  363
  364      When an LDCT is allocated,
  365      the array entry is set to the address of the LDCT.  When
  366      the LDCT is released, the array entry is again set to NIL.
  367      Note, however, that the released LDCT will not be added to
  368      the chain of free LDCT entries if FLAG.QUEUED is set.
  369      */
  370
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          11   
  371      %MACRO KN$DCT$ (FPTN=KN$DCT$,STCLASS="BASED(KN_DCT$$)");
  372
  373      DCL FPTN (0:0) PTR STCLASS;
  374
  375      %MEND;
  376
  377
  378
  379      /*F* NAME: KN$LDCT - Fep Logical Device Control Table
  380
  381      The Logical Device Control Table contains an entry for
  382      each end point that terminates in this fep.
  383
  384      Space for the LDCTs is reserved in the BOBCAT data segment
  385      when the fep is booted.
  386      The number of LDCTs to be allocated is specified by the
  387      LDCT option of NETCON's SET BOOTP command.
  388
  389      .xeq KN_DATA_M KN$DCT$
  390
  391      An LDCT is allocated when:
  392
  393      .fif
  394      }   - The monitor establishes a connection with NODEADMN.
  395      }
  396      }   - A user opens a DCB.  Note that all DCBs open to the same
  397      }     network address will share the same KNA$SSN context block,
  398      }     and therefore the same LDCT.
  399      }
  400      }   - A handler establishes a connection by placing a message in
  401      }     its send circular queue with function INIT.
  402      }
  403      }   - Session must wait for circular queue space to terminate
  404      }     a connection.
  405      .fin
  406
  407
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          12   
  408      The KN$LDCT macro in file KN_DATA_M defines the structure
  409      for the Logical Device Control Table in the FEP.
  410
  411      Each LDCT contains the following:
  412      */
  413
  414
  415      %MACRO KN$LDCT (NAME=KN$LDCT,STCLASS=BASED,SUBSCRIPT="",USER_ENTRY=NIL);
  416       %LSET LISTDIR='0'B;
  417       %LSET LISTEXP='1'B;
  418       %LSET LISTCOM='0'B;
  419       %LSET LISTSUB='1'B;
  420       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  421       %IF (SUBSTR(STR,0,6)='STATIC') OR
  422       (SUBSTR(STR,0,8)='CONSTANT') OR
  423       (SUBSTR(STR,0,3)='EXT');
  424       %LSET INIT=CHARTEXT('INIT');
  425      %LSET EINIT = CHARTEXT(' ');
  426       %ELSE;
  427       %LSET INIT=CHARTEXT('/*');
  428      %LSET EINIT = CHARTEXT('*/');
  429       %ENDIF;
  430      DCL 1 NAME SUBSCRIPT STCLASS ALIGNED,
  431            2 CONN_TYPE UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
  432                          /*K* CONN_TYPE - UBIN BYTE.
  433                          Indicates the type of connection.
  434                          This will be one of the equated values from the file KN_DATA_M:
  435
  436                          .fif
  437                          }   1 KN_CNTYPE_APE      User level connection
  438                          }   2 KN_CNTYPE_SESS     Handler CQ connection
  439                          }   3 KN_CNTYPE_D00      D00 connection (no longer used)
  440                          }   4 KN_CNTYPE_SNETW    Secondary Network connection (RFU)
  441                          }   5 KN_CNTYPE_QDP      Couplers QDP connection
  442                          }   6 KN_CNTYPE_LINK     Network link connection
  443                          }   7 KN_CNTYPE_CIRCUIT  Virtual Circuit Connection
  444                          .fin
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          13   
  445                          */
  446            2 STATE UBIN BYTE CALIGNED %INIT(0)%EINIT,
  447                          /*K* STATE - UBIN BYTE.
  448                          Contains a vlue to indicate the state of the connection:
  449                          This will be one of the equated values from the file KN_DATA_M:
  450
  451                          .fif
  452                           0   KN_ST_NULL        Inactive
  453                           1   KN_ST_WIAFR       Waiting init ack from remote
  454                           2   KN_ST_WIAFL       Waiting init ack from local
  455                           3   KN_ST_WTAFR       Waiting terminate ack from remote
  456                           4   KN_ST_WTAFL       Waiting terminate ack from local
  457                           5   KN_ST_ACTIVE      Active
  458                           6   KN_ST_WTAFLNT     Waiting term ack from local-no transport
  459                           7   KN_ST_WIAFLNT     Waiting init ack from local-no transport
  460                          .fin
  461
  462                          See KN_ST_equs for more detail.
  463
  464                          Note that the STATE for LINK connections is always
  465                          set to NULL even though the link is actually ACTIVE.
  466                          */
  467            2 RLCID,
  468                          /*K* RLCID - Remote Logical Connection Identifier.
  469                          The RLCID identifies the LDCT associated
  470                          with the other end point.  The RLCID is made
  471                          up of the following fields:
  472                          */
  473              3 NODE UBIN BYTE CALIGNED %INIT(0)%EINIT,
  474                          /*K* RLCID.NODE - UBIN BYTE.
  475                          Contains the number identifying the node
  476                          on which the other endpoint resides if this
  477                          is CONN_TYPE is APE, SESS or QDP.
  478
  479                          If CONN_TYPE is LINK, this field contains
  480                          one of the following equated values from the
  481                          file KNH_MACRO_C:
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          14   
  482
  483                          .fif
  484                              000              COUPLER Connection to Host
  485                              253 K_CNC_IS#    X.25 VC Connection to IS
  486                          .*  254 K_CNC_VC#    X.25 VC Connection to foreign NW (RFU)
  487                              255 K_CNC_LINK#  X.25 Link Level Connection
  488                          .fin
  489
  490                          If CONN_TYPE is CIRUIT, this field contains zero.
  491                          */
  492              3 GENERATION UBIN BYTE CALIGNED %INIT(0)%EINIT,
  493                          /*K* RLCID.GENERATION - UBIN BYTE.
  494                          Contains the generation number of the remote LDCT
  495                          for APE and SESS connections.  For LINK connections,
  496                          this field contains the node number of this endpoint.
  497                          */
  498              3 LDCTX UBIN(16) CALIGNED %INIT(0)%EINIT,
  499                          /*K* RLCID.LDCTX - UBIN(16).
  500                          Contains the number of the LDCT for the other endpoint
  501                          for APE and SESS connections.
  502
  503                          This field is redefined as RLCID.FLAGS for LINK
  504                          connections and as RLCID.TCTX# for CIRCUIT connections.
  505                          */
  506              3 TCTX# REDEF LDCTX UBIN(16) CALIGNED,
  507                          /*K* RLCID.TCTX# - UBIN(16).
  508                          Contains the index into the transport pointer array
  509                          for the intermediate CONS transport context.
  510                          Used only when TYPE is CIRCUIT.
  511                          RLCID.NODE and .GENERATION will be zero.
  512
  513                          This field is redefined as RLCID.FLAGS and RLCID.LDCTX.
  514                          */
  515              3 FLAGS REDEF LDCTX,
  516      %IF NOT(MODE_FEP);
  517                4 * BIT(1),
  518      %ENDIF;
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          15   
  519                4 HOST_NODE BIT(1) UNAL,
  520                          /*K* RLCID.FLAGS.HOST_NODE - BIT(1).
  521                          Set in LDCTs for LINK connections if the
  522                          remote endpoint is a Host.
  523                          */
  524                4 VIRCIR BIT(1) UNAL,
  525                          /*K* FLAGS.VIRCIR - BIT(1).
  526                          Indicates that the link context created is
  527                          associated with an x25 virtual circuit.
  528                           */
  529                4 * BIT(6) UNAL,
  530      %IF NOT(MODE_FEP);
  531                4 * BIT(1) UNAL,
  532      %ENDIF;
  533                4 * BIT(8) UNAL,
  534            2 TRANSPORT_ID UBIN(16) CALIGNED %INIT(0)%EINIT,
  535                          /*K* TRANSPORT_ID - UBIN(16).
  536                          Contains an index into the Transport Context
  537                          pointer array for the TCTX for this connection.
  538                          This field is valid for CONN_TYPE set to APE or
  539                          SESS only.  LINK_ID is a REDEF of this field and
  540                          is used for CONN_TYPE of LINK.
  541                          */
  542            2 LINK_ID REDEF TRANSPORT_ID UBIN(16) CALIGNED,
  543                          /*K* LINK_ID - UBIN(16).
  544                          Contains an index into the the Link Tables
  545                          in BOBCAT data for the link for this connection.
  546                          This field is valid for CONN_TYPE of LINK or D00 only.
  547                          Also see TRANSPORT_ID.
  548                          */
  549            2 GENERATION UBIN BYTE CALIGNED %INIT(0)%EINIT,
  550                          /*K* GENERATION - UBIN BYTE.
  551                          Contains the generation number of this LDCT.
  552                          This value is incremented by one every time this
  553                          LDCT is re-allocated.
  554                          */
  555      %IF NOT(MODE_FEP);
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          16   
  556            2 * BIT(1),
  557      %ENDIF;
  558            2 RESCOD UBIN(4) UNAL %INIT(0)%EINIT,
  559                          /*K* RESCOD - UBIN(4).
  560                          When the other endpoint is on the host, RESCOD
  561                          will contain the value from the host NK$LDCT.RESCOD.
  562                          */
  563            2 * UBIN(4) UNAL %INIT(0)%EINIT,
  564            2 UID UBIN(32) CALIGNED %INIT(0)%EINIT,
  565            2 UID$ REDEF UID PTR CALIGNED,
  566                          /*K* UID$ - PTR.
  567                          When the CONN_TYPE is SESS or LINK, UID$ is the
  568                          value supplied by the user in KNH$MESS.UID.
  569                          This is used by the LCP-6 handlers to point to the
  570                          handler context for this connection.
  571
  572                          This field is redefined as SSN$ for use with LDCTs
  573                          where CONN_TYPE is APE.
  574                          */
  575            2 SSN$ REDEF UID PTR CALIGNED,
  576                          /*K* SSN$ - PTR.
  577                          When the CONN_TYPE is APE, SSN$ contains the
  578                          address of the Session Context Block associated with
  579                          this connection.  See UID$ for the use of this field
  580                          when CONN_TYPE is SESS or LINK.
  581                          */
  582            2 LDCTX UBIN(16) CALIGNED %INIT(0)%EINIT,
  583                          /*K* LDCTX - UBIN(16).
  584                          Contains the index into KN$DCT$ for this LDCT.
  585                          */
  586            2 LNK$ PTR CALIGNED %INIT(ADDR(NIL))%EINIT,
  587                          /*K* LNK$ - PTR.
  588                          When the LDCT is on the chain of free LDCTs, this
  589                          pointer contains the address of the next LDCT on
  590                          the free chain.  The head of the chain is in KN_LDCT_HEAD$.
  591
  592                          When the LDCT has been queued by KNH$HMI because
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          17   
  593                          we could not move the message to the link handler's
  594                          RCQ, this pointer contains the address of the next
  595                          LDCT on the chain of LDCTs waiting for RCQ space.
  596                          The head of the chain will be in KNH$HMI.WAIT_HEAD$
  597                          for the link handler.
  598
  599                          When the LDCT has been queued by Transport because
  600                          we are waiting for the connection open to complete,
  601                          this pointer contains the address of the next LDCT
  602                          on the chian of LDCTs queued waiting for the open.
  603                          The head of the chain is in KN$TCTX.LNK$.
  604
  605                          When the LDCT has been queued by Transport because
  606                          we are waiting for credits in the send window
  607                          this pointer contains the address of the next LDCT
  608                          on the chian of LDCTs queued waiting to send data.
  609                          The head of the chain is in KN$TCTX.LNK$.
  610
  611                          When the LDCT has been queued by Transport because
  612                          we are out of transport buffers, this pointer contains
  613                          the address of the next LDCT on the chain of those
  614                          waiting for transport buffer space.  The head of the
  615                          chain is in KNT_WAIT_HEAD$.
  616                          */
  617            2 FLAGS,
  618      %IF NOT(MODE_FEP);
  619              3 * BIT(1),
  620      %ENDIF;
  621              3 QUEUED BIT(1) UNAL %INIT('0'B)%EINIT,
  622                          /*K* FLAGS.QUEUED - BIT(1).
  623                          Set by KNH$SEND when an LDCT is added to
  624                          the chain of LDCTs that are waiting for
  625                          space on another user's Receive Circular Queue.
  626
  627                          Set by KNT$SEND when the LDCT is queued
  628                          waiting for a transport connect confirmation.
  629                          */
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          18   
  630              3 REL BIT(1) UNAL %INIT('0'B)%EINIT,
  631                          /*K* FLAGS.REL - BIT(1).
  632                          Set when an LDCT is released if FLAGS.QUEUED
  633                          is set.  In this case the released LDCT is not
  634                          added to the chain of free LDCTs.  The LDCT will
  635                          eventually be released by either KNH$SCAN or
  636                          KNS$RECV.
  637                          */
  638              3 * BIT(6) UNAL %INIT('0'B)%EINIT,
  639      %IF NOT(MODE_FEP);
  640              3 * BIT(1),
  641      %ENDIF;
  642              3 * BIT(8) UNAL %INIT('0'B)%EINIT,
  643      %IF NOT(MODE_FEP);
  644              3 * BIT(1),
  645      %ENDIF;
  646              3 * BIT(8) UNAL %INIT('0'B)%EINIT,
  647      %IF NOT(MODE_FEP);
  648              3 * BIT(1),
  649      %ENDIF;
  650              3 * BIT(8) UNAL %INIT('0'B)%EINIT,
  651            2 USER_ENTRY$ EPTR CALIGNED %INIT(ENTADDR(USER_ENTRY))%EINIT,
  652                          /*K* USER_ENTRY$ - EPTR.
  653                          Contains the address to be called from KNS$RECV
  654                          for application level processing of inbound messages.
  655
  656                          The routine to be entered is dependent on CONN_TYPE:
  657                          .fif
  658                          }   KNA$IN     - KN_CNTYPE_APE
  659                          }   KNH$SEND   - KN_CNTYPE_SSN and KN_CNTYPE_LINK
  660                          }   KNB$ACTION - Used for the monitor connection to NODEADMN
  661                          }   KNS$TERM   - Used after KNS$RECV has received a TERM Function
  662                          .fin
  663                          */
  664            2 USER# UBIN(16) CALIGNED %INIT(0)%EINIT,
  665                          /*K* USER# - UBIN(16).
  666                          Contains the user number of the owner of
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          19   
  667                          this LDCT.
  668                          */
  669            2 CQPTR SBIN(16) CALIGNED %INIT(-1)%EINIT;
  670                          /*K* CQPTR - SBIN(16).
  671                          Contains the Send Circular Queue Removal Pointer
  672                          when the LDCT has been queued by KNH$SEND.
  673                          Contains -1 if the LDCT is not queued.
  674                          */
  675
  676      %MEND;
  677      /*F* NAME: KN_CNTYPE_equs - for KN$LDCT.CONN_TYPE
  678      */
  679
  680      /* note that these are not the same as those
  681         used for FPT_CONNECT.TYPE  See KN_CON_TYPE_equ
  682         in file KNH_MACRO_C.
  683      */
  684      %EQU KN_CNTYPE_APE = 1;        /* APE connection */
  685      %EQU KN_CNTYPE_SESS = 2;       /* Handler connection */
  686      %EQU KN_CNTYPE_D00  = 3;       /* D00 link connection (no longer used) */
  687      %EQU KN_CNTYPE_SNETW = 4;      /* Secondary Network connection */
  688      %EQU KN_CNTYPE_QDP = 5;        /* Couplers QDP connection      */
  689      %EQU KN_CNTYPE_LINK = 6;       /* Network link connection */
  690      %EQU KN_CNTYPE_CIRCUIT = 7;    /* Virtual Circuit connection */
  691
  692
  693
  694      /*F* NAME: KN_CNTYPE_TXT
  695
  696      The KN_CNTYPE_TXT macro generates the text for the KN_CNTYPE_equ
  697      values.  These values have meaning for KN$LDCT.CONN_TYPE.
  698      */
  699
  700      %MACRO KN_CNTYPE_TXT (FPTN=KN_CONTYPE_TXT, STCLASS=CONSTANT);
  701
  702       %LSET LISTDIR='0'B;
  703       %LSET LISTEXP='1'B;
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          20   
  704       %LSET LISTCOM='0'B;
  705       %LSET LISTSUB='1'B;
  706
  707       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  708       %IF (SUBSTR(STR,0,6)='STATIC') OR
  709       (SUBSTR(STR,0,8)='CONSTANT') OR
  710       (SUBSTR(STR,0,3)='EXT');
  711
  712      DCL 1 FPTN(0:7) CHAR(5) STCLASS INIT(
  713         '0    ', 'APE  ', 'SESS ', 'D00  ', 'SNETW', 'QDP  ','LINK ', 'VCIR ');
  714
  715      %ELSE;
  716      DCL 1 FPTN(0:0) CHAR(5) STCLASS ALIGNED;
  717      %ENDIF;
  718      %MEND;
  719
  720
  721      /*F* NAME: KN$LDCT_STATE_equ
  722
  723      The file KN_DATA_M contains a set of EQUs that may be used to
  724      reference KN$LDCT.STATE.  Each EQU is of the form KN_ST_state,
  725      where the equated values and their meanings for connection type
  726      APE, SESS or QDP are:
  727
  728      .fif
  729      }state     value  meaning
  730      }--------  ----- ---------------------------------------------------
  731      }NULL        0   The LDCT is not active
  732      }
  733      }WIAFR       1   Waiting Init Ack from Remote.  Set by KNS$SEND
  734      }                when session has been called from the higher layers
  735      }                with function set to KN_FCN_INIT.
  736      }
  737      }WIAFL      2    Waiting Init Ack from Local.  Set by KNS$RECV
  738      }                when session has been called from the lower layers
  739      }                with a DATA function and a session letter type of
  740      }                Initiate Connection Request.
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          21   
  741      }
  742      }WTAFR      3    Waiting Term Ack from Remote.  Set by KNS$SEND
  743      }                when session has been called from the higher layers
  744      }                with function set to KN_FCN_TERM.
  745      }
  746      }WTAFL      4    Waiting Term Ack from Local.  Set by KNS$RECV
  747      }                when session has been called from the lower layers
  748      }                with a DATA function and a session letter type of
  749      }                Terminate Connection.
  750      }
  751      }ACTIVE     5    Active.  Set by KNS$SEND when session has been
  752      }                called from the higher layers with function set to
  753      }                KN_FCN_INIT_ACK.  Also set when KNS$RECV has been
  754      }                called from the lower layers with a DATA function
  755      }                and a session letter type of Initiate Ack.
  756      }
  757      }WTAFLNT    6    Waiting Term Ack from Local to terminate.  Set by
  758      }                KNS$RECV when session has been called from the
  759      }                lower layers with the function set to KN_FCN_TERM and
  760      }                the LDCT state is currently active.  Also set by
  761      }                KNS$SEND when session has been called by the
  762      }                higher levels with function set to KN_FCN_INIT_ACK
  763      }                and the current state of the LDCT is waiting init ack
  764      }                from local to terminate.
  765      }
  766      }WIAFLNT    7    Waiting Init Ack from Local to terminate.  Set by
  767      }                KNS$RECV when session has been called from the
  768      }                lower layers with function set to KN_FCN_TERM and the
  769      }                LDCT state is currently waiting init ack from local.
  770      .fin
  771      */
  772      %EQU KN_ST_NULL     = 0;
  773      %EQU KN_ST_WIAFR    = 1;
  774      %EQU KN_ST_WIAFL    = 2;
  775      %EQU KN_ST_WTAFR    = 3;
  776      %EQU KN_ST_WTAFL    = 4;
  777      %EQU KN_ST_ACTIVE   = 5;
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          22   
  778      %EQU KN_ST_WTAFLNT  = 6;
  779      %EQU KN_ST_WIAFLNT  = 7;
  780      %EQU KN_ST_WTIAFLNT = 7;/*pre E00*/
  781      %EQU KN_ST_OPEN     = 8;
  782      %EQU KN_ST_OPENING  = 9;
  783
  784
  785
  786      /*F* NAME: KN_ST_TXT
  787
  788      The KN_ST_TXT macro generates the text for the KN_ST_equ
  789      values.  These values have meaning for KN$LDCT.STATE
  790      */
  791
  792      %MACRO KN_ST_TXT (FPTN=KN_ST_TXT, STCLASS=CONSTANT);
  793
  794       %LSET LISTDIR='0'B;
  795       %LSET LISTEXP='1'B;
  796       %LSET LISTCOM='0'B;
  797       %LSET LISTSUB='1'B;
  798
  799       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  800       %IF (SUBSTR(STR,0,6)='STATIC') OR
  801       (SUBSTR(STR,0,8)='CONSTANT') OR
  802       (SUBSTR(STR,0,3)='EXT');
  803
  804      DCL 1 FPTN(0:9) CHAR(8) STCLASS INIT(
  805         'NULL    ',   'WIAFR   ',   'WIAFL   ',   'WTAFR   ',
  806         'WTAFL   ',   'ACTIVE  ',   'WTAFLNT ',   'WIAFLNT',
  807         'OPEN    ',   'OPENING ');
  808      %ELSE;
  809      DCL 1 FPTN(0:0) CHAR(8) STCLASS ALIGNED;
  810      %ENDIF;
  811
  812      %MEND;
  813
  814
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          23   
  815
  816      /*F* NAME: K$TCTX - Fep Transport Context Blocks
  817
  818      A Transport ConTeXt blocks on the Fep may be for a
  819      primary transport connection that terminates in this
  820      Fep or for an intermediate transport connection that
  821      has one end-point on the adjacent host and the other
  822      endpoint either on a remote CP-6 fep, a remote CP-6
  823      host or a foreign OSI node.
  824
  825      Space for the TCTCXs is reserved in the BOBCAT data
  826      segment when the fep is booted.  The number of TCTX
  827      blocks to be reserved is specified by the TCTX
  828      option of NETCON's SET BOOTP command.
  829
  830      A pointer array that will be used to locate an active
  831      TCTX is also allocated in the BOBCAT data segment at
  832      boot time.  The array size is the number of TCTXs +1
  833      (0:TCTX#).  Entry zero is not used.  Each entry in the
  834      pointer array is initialized to NIL at boot time.  The
  835      TCTXs are allocated in BOBCAT memory immediately following
  836      this pointer array.  These unallocated TCTXs are chained
  837      together through K$TCTX.LNK$;  the head of the first TCTX
  838      in the free chain is in KN_TCTX_HEAD$.
  839
  840      When a TCTX is allocated, the corresponding pointer array
  841      entry is set to the address of the TCTX.  When the TCTX is
  842      released the array entry is again set to NIL.
  843
  844      The K$TCTX macro in the file KN_DATA_M defines the structure
  845      for the Transport Context Block on the Fep.
  846
  847      Each TCTX contains the following:
  848      */
  849
  850      /*
  851      This macro is used by at least the following modules:
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          24   
  852         DBD$FMT_KN
  853         KNT_FMT_E
  854         GIM$MONINIT
  855         KNA$SUBS
  856         KNT$MISC
  857         KNT$SEND
  858         KNT$RECV
  859      */
  860
  861      %MACRO K$TCTX (NAME=K$TCTX,STCLASS=BASED,ALGN=ALIGNED);
  862
  863       %LSET LISTDIR='0'B;
  864       %LSET LISTEXP='1'B;
  865       %LSET LISTCOM='0'B;
  866       %LSET LISTSUB='1'B;
  867
  868
  869      DCL 1 NAME STCLASS ALGN,
  870            2 STATE UBIN BYTE CALIGNED,
  871                          /*K* STATE- UBIN BYTE.
  872                          Contains a value that reflects the state of the
  873                          transport connection.
  874
  875                          .xeq KN_DATA_M KN$TCTX_STATE_equ VALUES
  876                          */
  877            2 NODE UBIN BYTE CALIGNED,
  878                          /*K* NODE - UBIN(16).
  879                          For normal CP-6 connections, NODE contains the
  880                          number identifying the node on which the other
  881                          endpoint resides.  The endpoint on the other node
  882                          (TCTX#) is identified by K$TCTX.DST_REF.
  883
  884                          If K$TCTX.OPTION.OSI and K$TCTX.OPTION.CONS is
  885                          reset, this is the node number of the boundry
  886                          fep, which may be the same as the one on which
  887                          this context block resides.
  888
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          25   
  889                          See LDCTX# (a redef of NODE) for the meaning when
  890                          this is a CONS network connection for OSI.
  891                          */
  892            2 LDCTX# REDEF NODE UBIN BYTE CALIGNED,
  893                          /*K* LDCTX# - UBIN(16).
  894                          Contains the LDCT index for the CIRCUIT LDCT when
  895                          the OSI transport connection uses the CONS network
  896                          service.  Also see NODE.
  897                          */
  898            2 DST_REF UBIN(16) CALIGNED,
  899                          /*K* DST_REF - UBIN(16).
  900                          contains the TRANSPORT_ID of the peer of this
  901                          transport connection.  This is provided by the
  902                          peer in the connect request or in the connect
  903                          confirm fragment.  It is then used to identify the
  904                          various fragments sent to the peer.
  905                          */
  906
  907            2 SRC_REF UBIN(16) CALIGNED,
  908                          /*K* SRC_REF - UBIN(16).
  909                          contains the TRANSPORT_ID for this end of the
  910                          transport connection.  This is the index into
  911                          the K$TCTX$$ pointer array for this Transport
  912                          Context Block and is the value used as the
  913                          source reference on fragments sent to the peer.
  914                          */
  915            2 HOST_REF UBIN(16) CALIGNED,
  916                          /*K* HOST_REF - UBIN(16).
  917                          contains the TRANSPORT_ID for the transport
  918                          context block on HOST_NODE.  This is used only
  919                          when this is an intermediate transport context
  920                          block.
  921                          */
  922            2 HOST_NODE UBIN BYTE CALIGNED,
  923                          /*K* HOST_NODE - UBIN BYTE.
  924                          contains the node number of the host when this
  925                          is an intermediate transport context block.
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          26   
  926                          This is maintained for debugging purposes only.
  927                          */
  928
  929            2 QOS UBIN BYTE CALIGNED,
  930                          /*K* QOS- UBIN BYTE.
  931                          Contains a value representing the requsted Quality
  932                          of Service for this transport connection.
  933
  934                          This value is set from K$FPT_CONNECT_OSI.QOS
  935                          on the host OSI session connections, or from
  936                          FPT_CONNECT.SERVICE on CP-6 connections on the
  937                          fep, and is to be passed on to Network; or, for
  938                          inbound OSI connection requests, is supplied by
  939                          Network.
  940                          */
  941            2 CLASS UBIN BYTE CALIGNED,
  942                          /*K* CLASS - UBIN BYTE.
  943                          Inidcates the Transport Class.  If this is a CP-6
  944                          QDP connection, the CLASS will be 4.  If this is
  945                          an OSI connection the CLASS may be 0, 2 or 4.
  946                          */
  947            2 RCV_WINDOW_SZ UBIN BYTE CALIGNED,
  948                          /*K* RCV_WINDOW_SZ - UBIN BYTE.
  949                          Contains the receive window size.
  950                          This is the initial credit value sent to the
  951                          other transport end-point in the CR TPDU when
  952                          initiating a transport connection or in the
  953                          CC TPDU when responding to a transport connect
  954                          request.  This value is then used by the receiving
  955                          end-point to initialize the value of SEND_UWE.
  956
  957                          The default initial value is obtained from
  958                          KNT_WINDOW_EXTENDED or KNT_WINDOW_NORMAL.
  959                          */
  960            2 LNK$ PTR CALIGNED,
  961                          /*K* LNK$ -PTR.
  962                          When the TCTX is on the chain of available TCTXs,
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          27   
  963                          LNK$ contains the address of the next available TCTX.
  964                          The head of this chain is in KN_TCTX_HEAD$ and the
  965                          TCTXs are linked through KN$TCTX.LNK$.
  966
  967                          When the TCTX is waiting for the other endpoint
  968                          to complete the connection, LNK$ contains the address
  969                          of the first LDCT on the chain of LDCTs waiting for
  970                          the transport connection.  These LDCTs are linked
  971                          through KN$LDCT.LNK$.  KN$TCTX.WAIT_4OPEN will be set.
  972
  973                          When the TCTX is waiting for the send window to
  974                          open, LNK$ contains the address of the first LDCT
  975                          on the chain of LDCTs waiting to send data.
  976                          These LDCTs are linked through KN$LDCT.LNK$.
  977                          KN$TCTX.FLOW_CONTROLLED will be set.
  978                          */
  979            2 VERS UBIN BYTE CALIGNED,
  980            2 TPDUSZ_PARM UBIN BYTE CALIGNED,
  981            2 TPDUSZ UBIN(16) CALIGNED,
  982            2 MAXSEQ UBIN(32) CALIGNED,
  983
  984            2 OPTION,
  985      %IF NOT(MODE_FEP);
  986              3 * BIT(1),
  987      %ENDIF;
  988              3 * BIT(8),
  989      %IF NOT(MODE_FEP);
  990              3 * BIT(1),
  991      %ENDIF;
  992              3 * BIT(1),
  993              3 TRACE BIT(1),
  994                          /*K* TRACE - BIT(1).
  995                          Set if the trace option is enabled for this transport
  996                          connection.
  997                          */
  998              3 CONS BIT(1) UNAL,
  999                          /*K* CONS - BIT(1).
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          28   
 1000                          Set if this transport connection is to use the
 1001                          Connection Oriented Network Service.  If reset,
 1002                          the Connectionless Mode Network Service is to be
 1003                          used.  This flag is always reset for CP-6 transport
 1004                          connections and always set for Class 0 OSI transport
 1005                          connections.
 1006                          */
 1007              3 OSI BIT(1) UNAL,
 1008                          /*K* OSI - BIT(1).
 1009                          Set if this transport block is associated with
 1010                          an OSI Session connection; reset if CP-6 style
 1011                          Session connection.
 1012                          */
 1013                          /*
 1014                          For E00, this will never be set if PRIMARY is also
 1015                          set as we will only have QDP session on the fep.
 1016                          */
 1017              3 CLASS_2_FLOW BIT(1) UNAL,
 1018                          /*K* CLASS_2_FLOW - BIT(1).
 1019                          Set if the use of explicit flow control in class 2
 1020                          has been selected.
 1021                          */
 1022              3 EXTENDED BIT(1) UNAL,
 1023                          /*K* EXTENDED - BIT(1).
 1024                          Set if the use of extended TPDU formats are to be used
 1025                          on this connection.  The default is to use the extended
 1026                          formats.  This bit is reset only if non-use is specified
 1027                          via the CR or CC TPDU.
 1028
 1029                          This option is valid for classes 2, 3 and 4.
 1030                          */
 1031              3 EXPEDITED BIT(1) UNAL,
 1032                          /*K* EXPEDITED - BIT(1).
 1033                          Set if the use of expedited data is to be allowed
 1034                          on this connection.  The default is to use expedited
 1035                          data.  This bit is reset only if session requests
 1036                          the non-use of expedited data (the CC TPDU must
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          29   
 1037                          agree) or if the received CR TPDU requests the
 1038                          non-use of expedited data.
 1039
 1040                          This option is valid for all classes except class 0,
 1041                          and is specified via the Option Parameter of
 1042                          the CR or CC TPDU.
 1043                          */
 1044              3 CHKSUM BIT(1) UNAL,
 1045                          /*K* CHKSUM - BIT(1).
 1046                          Set if the use of the checksum parameter is to be used
 1047                          on this connection.  The default is to use the checksum
 1048                          parameter.  This bit is reset only if session requests
 1049                          the non-use of the checksum parameter (the CC TPDU must
 1050                          agree) or if the received CR TPDU requests the
 1051                          non-use of the checksum parameter.
 1052
 1053                          This option is valid for class 4 only, and is specified
 1054                          via the Option Parameter of the CR or CC TPDU.
 1055                          */
 1056      %IF NOT(MODE_FEP);
 1057      %LSET FLGLVL=3;
 1058            2 FLAGS,
 1059              3 * BIT(1) UNAL,
 1060      %ELSE;
 1061      %LSET FLGLVL=2;
 1062      %ENDIF;
 1063            %(FLGLVL) * BIT(8) UNAL,
 1064      %IF NOT(MODE_FEP);
 1065              3 * BIT(1) UNAL,
 1066      %ENDIF;
 1067            %(FLGLVL) LOST_TPDU BIT(1) UNAL,
 1068                          /*K* LOST_TPDU - BIT(1).
 1069                          Set if transport has been has received a tpdu
 1070                          out of sequence and has sent an ACK with reduced
 1071                          credits to the other end-point.
 1072
 1073                          Reset when all out of sequence TPDUs have been
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          30   
 1074                          received.
 1075                          */
 1076            %(FLGLVL) NEED_ASSMBUF BIT(1) UNAL,
 1077                          /*K* NEED_ASSMBUF - BIT(1).
 1078                          Set if transport has been unable to forward a
 1079                          message to host session or local session because
 1080                          there was not a transport buffer available to
 1081                          reassemble fragmented TPDUs.
 1082
 1083                          Reset by the KNT$UNQUEUE routine.
 1084                          */
 1085            %(FLGLVL) WAIT_4OPEN BIT(1) UNAL,
 1086                          /*K* WAIT_4OPEN - BIT(1).
 1087                          Set if transport has been unable to forward an
 1088                          outbound message to network because the transport
 1089                          connection is not yet open (WFCC or AKWAIT).
 1090
 1091                          The data has been saved in a transport buffer in the
 1092                          chain of byffers located by SEND_HEAD$ or SEND_EHEAD$
 1093                          if this is an intermediate transport connection.
 1094
 1095                          The data has not been save in a transport buffer if
 1096                          this is a primary transport connection, and the LDCTs
 1097                          that are queued waiting for this transprt connection
 1098                          to open are chained on KN$TCTX.LNK$.
 1099
 1100                          Reset when a TPDU_CC, TPDU_AK, TPDU_DT or TPDU_ED arrives.
 1101                          */
 1102            %(FLGLVL) FLOW_CONTROLLED BIT(1) UNAL,
 1103                          /*K* FLOW_CONTROLLED - BIT(1).
 1104                          Set if transport has been unable to forward an
 1105                          outbound message to network
 1106                          because there are no credits in the send window.
 1107
 1108                          The data has been saved in a transport buffer in the
 1109                          chain of byffers located by SEND_HEAD$ or SEND_EHEAD$
 1110                          if this is an intermediate connection.
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          31   
 1111
 1112                          The data has not been saved if this is a primary
 1113                          connection, and the LDCTs queued waiting for the
 1114                          send window to open are queued on KN$TCTX.LNK$.
 1115
 1116                          Reset when a TPDU_AK or TPDU_EA arrives.
 1117                          */
 1118            %(FLGLVL) HOST_CQ_FULL BIT(1) UNAL,
 1119                          /*K* HOST_CQ_FULL - BIT(1).
 1120                          Set if transport has been unable to forward an inbound
 1121                          message to host session.  This would be because
 1122                          the coupler's receive circular queue is full.  The
 1123                          data has been saved in a transport buffer in the
 1124                          chain of buffers located by RECV_HEAD$.
 1125
 1126                          Reset when the UNQ function is received by KNT$RECV.
 1127                          */
 1128            %(FLGLVL) OUTBOUND BIT(1) UNAL,
 1129                          /*K* OUTBOUND - BIT(1).
 1130                          Set if the TPDU_CR was sent from this node.
 1131                          */
 1132            %(FLGLVL) INBOUND BIT(1) UNAL,
 1133                          /*K* INBOUND - BIT(1).
 1134                          Set if the TPDU_CC was sent from this node.
 1135                          */
 1136            %(FLGLVL) PRIMARY BIT(1) UNAL,
 1137                          /*K* PRIMARY - BIT(1).
 1138                          Set if this is a primary fep transport context
 1139                          block; reset if this is a secondary host transport
 1140                          context block.
 1141                          */
 1142
 1143            2 REASON UBIN BYTE CALIGNED,
 1144                          /*K* REASON - UBIN BYTE
 1145                          Contains a code to be reported as the
 1146                          reason for a transport disconnect request.
 1147                          .xeq K_TRANSPORT_E K$TCTX_REASON_equ VALUES
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          32   
 1148                          */
 1149            2 ERR UBIN BYTE CALIGNED,
 1150                          /*K* ERR - UBIN BYTE
 1151                          Contains a code to be reported as the clearing
 1152                          information for a transport disconnect request.
 1153                          .xeq K_TRANSPORT_E K$TCTX_ERR_equ VALUES
 1154                          */
 1155
 1156            2 SERR CALIGNED,
 1157              3 NOT_OPEN UBIN(16) CALIGNED,
 1158                          /*K* SERR.NOT_OPEN - UBIN(16).
 1159                          Contains a count of the number of TPDU_DTs that
 1160                          could not be send immediately because the
 1161                          transport connection was not yet open.
 1162                          */
 1163              3 NOBUF UBIN(16) CALIGNED,
 1164                          /*K* SERR.NOBUF - UBIN(16).
 1165                          Contains a count of the number of times a transport
 1166                          buffer could not be obtained for retaining a copy
 1167                          of a TPDU for later retranmission.
 1168                          */
 1169              3 BUF_OVFLOW UBIN(16) CALIGNED,
 1170                          /*K* SERR.BUF_OVFLOW - UBIN(16).
 1171                          Contains a count of the number of times transport
 1172                          was called to send a tpdu and the tpdus already
 1173                          buffered for this connection exceeded twice the
 1174                          value of RCV_WINDOW_SZ.
 1175
 1176                          If this is a primary connection, the request was
 1177                          rejected (KNT_ER_QD).  If an intermediate connection,
 1178                          the data was buffered anyway (ERROR_FLOW).
 1179                          */
 1180              3 DT_NWINDOW UBIN(16) CALIGNED,
 1181                          /*K* SERR.DT_NWINDOW - UBIN(16).
 1182                          Contains a count of the number of TPDU_DTs that
 1183                          could not be send immediately because they were
 1184                          outside of the send window limits.
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          33   
 1185                          */
 1186              3 NOQ UBIN(16) CALIGNED,
 1187                          /*K* SERR.NOQ - UBIN(16).
 1188                          Contains a count of the number of TPDUs that could
 1189                          not be send immediately because of an altret from
 1190                          KNN$SEND.  If class 4, these TPDUs had already been
 1191                          buffered, so did not remain in the sending CQ.  If
 1192                          class 0 or 2, the TPDU remains in the CQ.
 1193                          */
 1194              3 RETRAN UBIN(16) CALIGNED,
 1195                          /*K* SERR.RETRAN - UBIN(16).
 1196                          Contains a count of the number of TPDU_DTs or TPDU_EDs
 1197                          that have been retransmitted.
 1198                          */
 1199
 1200            2 RERR CALIGNED,
 1201              3 CHKSUM UBIN(16) CALIGNED,
 1202                          /*K* RERR.CHKSUM - UBIN(16).
 1203                          Contains a count of the number of TPDUs associated
 1204                          with this transport connection have been discarded
 1205                          because of checksum error.
 1206                          */
 1207              3 NOBUF UBIN(16) CALIGNED,
 1208                          /*K* RERR.NOBUF - UBIN(16).
 1209                          Contains a count of the number of times a transport
 1210                          buffer could not be obtained for reassembling
 1211                          fragmented TPDUs or out of sequence TPDUs.
 1212                          */
 1213              3 DT_NWINDOW UBIN(16) CALIGNED,
 1214                          /*K* RERR.DT_NWINDOW - UBIN(16).
 1215                          Contains a count of the number of TPDU_DTs that
 1216                          have been discarded because they were received
 1217                          outside of the receive window limits or because they
 1218                          were duplicates of a tpdu on the receive chain.
 1219                          */
 1220
 1221              3 LOST_TPDU UBIN(16) CALIGNED,
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          34   
 1222                          /*K* RERR.LOST_TPDU - UBIN(16).
 1223                          Contains a count of the number of times that
 1224                          data TPDUs have been received out of sequence.
 1225                          */
 1226
 1227              3 AK_NWINDOW UBIN(16) CALIGNED,
 1228                          /*K* RERR.AK_NWINDOW - UBIN(16).
 1229                          Contains a count of the number of TPDU_AKs that
 1230                          have been discarded because they were received
 1231                          outside of the send window limits.
 1232                          */
 1233
 1234              3 AK_SUBSEQ UBIN(16) CALIGNED,
 1235                          /*K* RERR.AK_SUBSEQ - UBIN(16).
 1236                          Contains a count of the number of TPDU_AKs that
 1237                          have been discarded because the subsequence
 1238                          parameter was less than the last received subsequence.
 1239                          */
 1240
 1241              3 TBUF_NOQ UBIN(16) CALIGNED,
 1242                          /*K* RERR.TBUF_NOQ - UBIN(16).
 1243                          Contains a count of the number of TPDUs that could
 1244                          not be send immediately because of an altret from
 1245                          KNN$SEND.  These are buffered out of sequence or
 1246                          reassembled TPDUs awaiting delivery to the host.
 1247                          */
 1248              3 NBUF_NOQ UBIN(16) CALIGNED,
 1249                          /*K* RERR.NBUF_NOQ - UBIN(16).
 1250                          Contains a count of the number of TPDUs that could
 1251                          not be send immediately because of an altret from
 1252                          KNN$SEND.  These are non-buffered TPDUs that remain
 1253                          on the sending CQ awaiting delivery to the host.
 1254                          */
 1255              3 NSESS_CDT UBIN(16) CALIGNED,
 1256                          /*K* RERR.NSESS_CDT - UBIN(16).
 1257                          Contains a count of the number of TSDUs that could
 1258                          not be send to host session immediately because
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          35   
 1259                          SSN_CRDT was <= zero.  These TPDUs have been buffered
 1260                          and chained onto the receive queue.
 1261                          */
 1262
 1263            2 RECV_BUFF,
 1264              3 CUR UBIN(16) CALIGNED,
 1265
 1266              3 PEAK UBIN(16) CALIGNED,
 1267
 1268              3 BYTES_CUR UBIN(16) CALIGNED,
 1269
 1270              3 BYTES_PEAK UBIN(16) CALIGNED,
 1271
 1272            2 RECV_LWE UBIN(32) CALIGNED,
 1273                          /*K* RECV_LWE - UBIN(32).
 1274                          The Receive Lower Window Edge contains the sequence
 1275                          number of the next DT TPDU that is expected to be
 1276                          received from the other transport end-point.  This
 1277                          number is initialized to zero and incremented when
 1278                          ever an in-sequence DT TPDU is received and either
 1279                          delivered to session or stored in the transport
 1280                          buffers for reassembly or session flow control.
 1281                          */
 1282            2 RECV_UWE UBIN(32) CALIGNED,
 1283                          /*K* RECV_UWE - UBIN(32).
 1284                          The Receive Upper Window Edge is initialized from
 1285                          the default initialization value of RCV_WINDOW_SZ.
 1286                          The value is reset to the value of RECV_LWE + cdt
 1287                          each time an AK TPDU is send (where cdt is the
 1288                          difference between the the initial RCV_WINDOW_SZ value
 1289                          and the unused credits (RECV_LWE - RECV_NEXT).
 1290                          */
 1291            2 RECV_NEXT UBIN(32) CALIGNED,
 1292                          /*K* RECV_NEXT - UBIN(32).
 1293                          Contains the value of the sequence number in the next
 1294                          DT TPDU that is to be delivered to session.  This
 1295                          value is initialized to zero and is incrmented
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          36   
 1296                          after a message has been successfully delivered to
 1297                          session.
 1298
 1299                          Note that there may be unassembled or flow-controled
 1300                          messages with sequence numbers higher than RECV_NEXT
 1301                          sitting in the transport buffers waiting for delivery.
 1302                          */
 1303            2 RECV_EXPD UBIN(32) CALIGNED,
 1304                          /*K* RECV_EXPD - UBIN(32).
 1305                          Contains the sequence number of the next ED TPDU
 1306                          expected from the other end-point.  There is no
 1307                          windowing on expedited data, so this is also the
 1308                          sequence number of the next ED TPDU to be delivered
 1309                          to session.
 1310                          */
 1311            2 RECV_HEAD$ PTR CALIGNED,
 1312                          /*K* RECV_HEAD$ - PTR.
 1313                          Contains the address of the first in a chain of
 1314                          transport buffers that contain TPDUs that have
 1315                          been received from the other end-point but have
 1316                          not yet been delivered to session.  These TPDUs
 1317                          may have been not delived because either they
 1318                          have been received out of sequence or because
 1319                          the COUPLER RCQ was full and we couldn't forward
 1320                          the message to the host.
 1321                          */
 1322            2 RECV_EHEAD$ PTR CALIGNED,
 1323                          /*N* RECV_EHEAD$ - PTR.
 1324                          There is no flow control on expedited data; if
 1325                          session is not prepared to accept it the ED TPDU
 1326                          is thrown in the bit bucket.
 1327                          */
 1328
 1329
 1330            2 SEND_BUFF,
 1331              3 CUR UBIN(16) CALIGNED,
 1332
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          37   
 1333              3 PEAK UBIN(16) CALIGNED,
 1334
 1335              3 BYTES_CUR UBIN(16) CALIGNED,
 1336
 1337              3 BYTES_PEAK UBIN(16) CALIGNED,
 1338
 1339
 1340            2 SEND_LWE  UBIN(32) CALIGNED,
 1341                          /*K* SEND_LWE - UBIN(32).
 1342                          The Send Lower Window Edge is initialized to zero
 1343                          and reset to the value received in the YR_TU_NR
 1344                          field in a received Data Acknowledgement TPDU.
 1345                          */
 1346            2 SEND_UWE  UBIN(32) CALIGNED,
 1347                          /*K* SEND_UWE - UBIN(32).
 1348                          The Send Upper Window Edge is initialized from
 1349                          the value received in the CDT field of the Connect
 1350                          Request (inbound connections) or the Connect Confirm
 1351                          (outbound connections) TPDU.
 1352                          The Send Upper Window Edge is reset with the sum
 1353                          of the YR_TU_NR and CDT fields of a received Data
 1354                          Acknowledgement TPDU.
 1355                          */
 1356            2 SEND_NEXT UBIN(32) CALIGNED,
 1357                          /*K* SEND_NEXT - UBIN(32).
 1358                          Contains the value to be used in the next
 1359                          Data TPDU sent over this connection.  This
 1360                          value is incremented after the Data TPDU is
 1361                          created until it exceeds the value in
 1362                          MAXSEQ, at which time the value for SEND_NEXT
 1363                          is reset to zero.
 1364                          */
 1365            2 SEND_EXPD UBIN(32) CALIGNED,
 1366                          /*K* SEND_EXPD - UBIN(32).
 1367                          Contains the value to be used in the next Expedited
 1368                          Data TPDU sent over this connection.  This value is
 1369                          incremented after the Expedited Data TPDU is created
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          38   
 1370                          until it exceeds the value in MAXSEQ, at which time
 1371                          the value for SEND_EXPD is reset to zero.
 1372                          */
 1373
 1374            2 SEND_HEAD$ PTR CALIGNED,
 1375                          /*K* SEND_HEAD$ - PTR.
 1376                          Contains the address of the transport buffer that
 1377                          contains the first DT TPDU that has been sent,
 1378                          but not ACKed.  This is the one to retransmit
 1379                          should the Retran Timer expire and there are no
 1380                          ED TPDUs in the chain identified by SEND_EHEAD$.
 1381                          */
 1382            2 SEND_TAIL$ PTR CALIGNED,
 1383                          /*K* SEND_TAIL$ - PTR.
 1384                          Contains the address of the transport buffer that
 1385                          contains the last DT TPDU that has been passed
 1386                          from session and accepted by transport.
 1387                          It appears that there is no limit to the number of
 1388                          outbound messages we will buffer for session.  We
 1389                          will keep doing it until unable to get a buffer.
 1390                          */
 1391            2 SEND_NOTSENT$ PTR CALIGNED,
 1392                          /*K* SEND_NOTSENT$ - PTR.
 1393                          Contains the address of the transport buffer that
 1394                          contains the first flow-stopped message in the
 1395                          chain of tranmsport buffers bounded by SEND_HEAD$
 1396                          and SEND_TAIL$.  These messages have never been
 1397                          forwarded to network.
 1398                          */
 1399            2 SEND_EHEAD$ PTR CALIGNED,
 1400                          /*K* SEND_EHEAD$ - PTR.
 1401                          Contains the address of the transport buffer that
 1402                          contains the first ED TPDU that has been sent,
 1403                          but not ACKed.  This is the one to retransmit
 1404                          should the Retran Timer expire.
 1405                          */
 1406            2 SEND_ETAIL$ PTR CALIGNED,
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          39   
 1407                          /*K* SEND_ETAIL$ - PTR.
 1408                          Contains the address of the transport buffer that
 1409                          contains the last ED TPDU that has been passed
 1410                          from session and accepted by transport.
 1411                          */
 1412            2 SEND_ENOTSENT$ PTR CALIGNED,
 1413                          /*K* SEND_ENOTSENT$ - PTR.
 1414                          Contains the address of the transport buffer that
 1415                          contains the first flow-stopped message in the
 1416                          chain of tranmsport buffers bounded by SEND_EHEAD$
 1417                          and SEND_ETAIL$.  These messages have never been
 1418                          forwarded to network.
 1419                          */
 1420
 1421            2 SGMENT_TSDUS UBIN(16) CALIGNED,
 1422                          /*K* SGMENT_TSDUS - UBIN(16).
 1423                          Contains a count of the number of TSDUs that have
 1424                          been segmented into smaller TPDUs to accomodate a
 1425                          smaller maximum TPDU size.
 1426                          */
 1427            2 SGMENT_FRAGS UBIN(16) CALIGNED,
 1428                          /*K* SGMENT_FRAGS - UBIN(16).
 1429                          Contains a count of the number of TPDUs that have
 1430                          been formed by segmenting larger TSDUs to accomodate a
 1431                          smaller maximum TPDU size.
 1432                          */
 1433            2 REASSM_TSDUS UBIN(16) CALIGNED,
 1434                          /*K* REASSM_TSDUS - UBIN(16).
 1435                          Contains a count of the number of TSDUs that have
 1436                          been reassembled from smaller TPDUs.
 1437                          */
 1438            2 REASSM_FRAGS UBIN(16) CALIGNED,
 1439                          /*K* REASSM_FRAGS - UBIN(16).
 1440                          Contains a count of the number of TPDUs that have
 1441                          been reassembled into larger TSDUs.
 1442                          */
 1443
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          40   
 1444            2 SSN_CRDT SBIN(16) CALIGNED,
 1445                          /*K* SSN_CRDT - SBIN(16).
 1446                          Contains the current value of the number of credits
 1447                          that ISO session has given to transport.  Data may be
 1448                          delivered to ISO session only if SSN_CRDT is greater than zero.
 1449                          SSN_CRDT is initialized to 1 and decremented when
 1450                          a TPDU is delivered only when OPTION.OSI_FLOW is set.
 1451                          */
 1452            2 * SBIN(16) CALIGNED,
 1453
 1454            2 SEND_SUBSEQ UBIN(16) CALIGNED,
 1455                          /*K* SEND_SUBSEQ - UBIN BYTE.
 1456                          Contains the value from the subsequence parameter
 1457                          of the last received AK TPDU, or zero if the last
 1458                          AK TPDU did not contains the subsequence parameter.
 1459                          */
 1460            2 SEND_RETRY_COUNT UBIN BYTE CALIGNED,
 1461                          /*K* SEND_RETRY_COUNT - UBIN BYTE.
 1462                          Contains a count of the number of times a TPDU
 1463                          (or set of TPDUs, in the case of retransmitting
 1464                          lost TPDUs) has been retransmitted.  Transport
 1465                          will attempt to retransmit the TPDU(s) each time
 1466                          the Retransmission Timer expires until this value
 1467                          reaches that in KNT_MAX_RETRY.
 1468                          Reset to zero when a TPDU_AK is received for the
 1469                          TPDU that is being retransmitted.
 1470                          */
 1471            2 * UBIN BYTE CALIGNED,
 1472            2 TMR_COUNT(0:3) UBIN BYTE CALIGNED,
 1473                          /*K* TMR_COUNT - ARRAY(0:3) UBIN.
 1474                          Contains a count of the number of times each of
 1475                          the transport timers associated with this transport
 1476                          connection has expired.  This array is indexed by
 1477                          the values for the various transport timers as
 1478                          defined by the EQUated values in K_TRANSPORT_E.
 1479                          */
 1480
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          41   
 1481
 1482            %GH$TMR_BLK (FPTN=TMR_RETRAN, LVL=2, STCLASS=STCLASS, LAST=NO, ALGN=CALIGNED);
 1483                          /*K* TMR_RETRAN - GH$TMR_BLK Structure.
 1484                          The Retransmission Timer is used to determine when
 1485                          an outbound TPDU should be retransmitted because
 1486                          the peer endpoint has failed to acknowledge it.
 1487                          Default is 10 seconds.
 1488                          */
 1489            %GH$TMR_BLK (FPTN=TMR_WINDOW, LVL=2, STCLASS=STCLASS, LAST=NO, ALGN=CALIGNED);
 1490                          /*K* TMR_WINDOW - GH$TMR_BLK Structure.
 1491                          The Window Timer is used to determine when an
 1492                          ACK TPDU containsing the window (credit and
 1493                          flow control) information needs to be sent to
 1494                          the peer endpoint.
 1495                          Default is 10 seconds.
 1496                          */
 1497            %GH$TMR_BLK (FPTN= TMR_INACTIVITY, LVL=2, STCLASS=STCLASS, LAST=NO, ALGN=CALIGNED);
 1498                          /*K* TMR_INACTIVITY - GH$TMR_BLK Structure.
 1499                          The Inactivity Timer is used to quard against
 1500                          unsignalled network failures or failure of the
 1501                          peer endpoint.  This timer is reset whenever
 1502                          there is any traffic on the transport connection.
 1503                          Default is 30 seconds.
 1504                          */
 1505            %GH$TMR_BLK (FPTN=TMR_REFERENCE, LVL=2, STCLASS=STCLASS, LAST=NO, ALGN=CALIGNED);
 1506                          /*K* TMR_REFERENCE - GH$TMR_BLK Structure.
 1507                          The Reference Timer is used after a
 1508                          connection is closed to discard incoming
 1509                          messages for the connection.  While this
 1510                          timer is running the transport context
 1511                          block will not be reallocated for use
 1512                          by another transport connection.
 1513                          Default is 30 seconds.
 1514                          */
 1515
 1516             %K$TSAP(NAME=SRC_TSAP,LVL=2,LAST=",",ALGN=CALIGNED);
 1517                          /*K* SRC_TSAP - TSAP.
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          42   
 1518                          TSAP specified by the user originating the transport
 1519                          connection.  This is maintained in the fep intermediate
 1520                          OSI transport context for information only.
 1521
 1522                          Set from K$FPT_CONNECT_OSI.SRC_TSAP and used to
 1523                          build CALLING_TSAP parm for the TPDU_CR.
 1524
 1525                          Set from CALLING_TSAP parm of incoming TPDU_CR and
 1526                          used to build CALLED_TSAP parm for TPDU_CC.
 1527                          */
 1528             %K$TSAP(NAME=DST_TSAP,LVL=2,LAST=",",ALGN=CALIGNED);
 1529                          /*K* DST_TSAP - TSAP.
 1530                          TSAP specified by the user responding to the transport
 1531                          connect requset.  This is maintained in the fep
 1532                          OSI intermediate transport context for information only.
 1533
 1534                          Set from K$FPT_CONNECT_OSI.DST_TSAP and used to
 1535                          build CALLED_TSAP parm for the TPDU_CR.
 1536
 1537                          Set from CALLED_TSAP parm of incoming TPDU_CR and
 1538                          used to build CALLING_TSAP parm for TPDU_CC.
 1539                          */
 1540             %K$NSAP (FPTN=SRC_NSAP,LVL=2,LAST=",");
 1541                          /*K* SRC_NSAP - NSAP.
 1542                          Source NSAP - Used with OSI connections only.
 1543                          Set when a transport connection is established and
 1544                          maintained here for later use by Network.
 1545
 1546                          For Class 4 connections, set from KN$NETPARM.SRC_ADDR$
 1547                          when an outbound TPDU_CR is received at KNT$SEND_4HOST;
 1548                          set from KN$NETPARM.DST_ADDR$ when an incoming TPDU_CR
 1549                          is received at KNT$RECV_4HOST.
 1550
 1551                          For Class 0 connections, set from FPT_CONNECT.LADR
 1552                          when KNT$RECV_4HOST is entered with the K_NCONNECT_IND
 1553                          function code.
 1554                          */
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          43   
 1555             %K$NSAP (FPTN=DST_NSAP,LVL=2);
 1556                          /*K* DST_NSAP - NSAP.
 1557                          Destination NSAP - Used with OSI connections only.
 1558                          Set when a transport connection is established and
 1559                          maintained here for later use by Network.
 1560
 1561                          For Class 4 connections, set from KN$NETPARM.DST_ADDR$
 1562                          when an outbound TPDU_CR is received at KNT$SEND_4HOST;
 1563                          set from KN$NETPARM.SRC_ADDR$ when an incoming TPDU_CR
 1564                          is received at KNT$RECV_4HOST.
 1565
 1566                          For Class 0 connections, set from FPT_CONNECT.DEST
 1567                          when KNT$RECV_4HOST is entered with the K_NCONNECT_IND
 1568                          function code.
 1569                          */
 1570      %MEND;
 1571
 1572
 1573
 1574      /*F* NAME: KN$TCTX_STATE_equ - Fep TCTX States
 1575
 1576      The file KN_DATA_M contains a set of EQUs that may be used to
 1577      reference KN$TCTX.STATE.  Each EQU is of the form K_TSTATE_state
 1578      where the equated values and their meanings are:
 1579      */
 1580
 1581      /*K* VALUES -
 1582      .fif
 1583
 1584      }state     value  meaning
 1585      }--------  ----- ---------------------------------------------------
 1586      }NULL        0   The TCTX is not active
 1587      }REFWAIT     1   Waiting for frozen reference time
 1588      }CLOSED      2   Transport connection is closed
 1589      }WFCC        3   Waiting for the CC TPDU
 1590      }WBCL        4   Waiting for the CC TPDU before sending the DR TPDU
 1591      }OPEN        5   Transport connection is open
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          44   
 1592      }WFTRESP     6   Wait for T_CONNECT response
 1593      }AKWAIT      7   Wait for acknowledgement of CC TPDU
 1594      }CLOSING     8   Release in progress
 1595      }WFNC        9   Wait for network connection
 1596      }WFCC_R     10   Wait for connect simultaneous (not OSI)
 1597      }WFCR_TPDU  11   Wait for class 0 TPDU_CR (not OSI)
 1598      .fin
 1599      */
 1600      /*  See page 101 of OSI spec.   */
 1601      %EQU K_TSTATE_NULL = 0;
 1602      %EQU K_TSTATE_REFWAIT = 1 ;
 1603      %EQU K_TSTATE_CLOSED = 2;
 1604      %EQU K_TSTATE_WFCC = 3;
 1605      %EQU K_TSTATE_WBCL = 4;
 1606      %EQU K_TSTATE_OPEN = 5;
 1607      %EQU K_TSTATE_WFTRESP = 6;
 1608      %EQU K_TSTATE_AKWAIT = 7;
 1609      %EQU K_TSTATE_CLOSING = 8;
 1610      %EQU K_TSTATE_WFNC = 9;  /*Class 0 */
 1611      %EQU K_TSTATE_WFCC_R = 10;  /*WTCCS*/
 1612      %EQU K_TSTATE_WFCR_TPDU = 11; /*Class 0 */
 1613
 1614
 1615
 1616      /*F* NAME: K_TCTX_ST_TXT
 1617
 1618      The K_TCTX_ST_TXT macro generates the text for the KN$TCTX_STATE_equ
 1619      values.  These values have meaning for K$TCTX.STATE.
 1620
 1621      This macro is intended for use with ANLZ routines written in PL6.
 1622      */
 1623
 1624      %MACRO K_TCTX_ST_TXT (FPTN=K_TCTX_ST_TXT, STCLASS=CONSTANT);
 1625
 1626       %LSET LISTDIR='0'B;
 1627       %LSET LISTEXP='1'B;
 1628       %LSET LISTCOM='0'B;
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          45   
 1629       %LSET LISTSUB='1'B;
 1630
 1631       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1632       %IF (SUBSTR(STR,0,6)='STATIC') OR
 1633       (SUBSTR(STR,0,8)='CONSTANT') OR
 1634       (SUBSTR(STR,0,3)='EXT');
 1635
 1636      DCL 1 FPTN(0:11) CHAR(8) STCLASS INIT(
 1637         'NULL    ',   'REFWAIT ',   'CLOSED  ',   'WFCC    ',
 1638         'WBCL    ',   'OPEN    ',   'WFTRESP ',   'AKWAIT ',
 1639         'CLOSING ',   'WFNC    ',   'WFCC_R',      'WF_CR ');
 1640      %ELSE;
 1641      DCL 1 FPTN(0:0) CHAR(8) STCLASS ALIGNED;
 1642      %ENDIF;
 1643
 1644      %MEND;
 1645
 1646
 1647      /*F* NAME: KN_TCTX_ST_TXT
 1648
 1649      The KN_TCTX_ST_TXT macro generates the text for the K$TCTX_STATE_equ
 1650      values.  These values have meaning for K$TCTX.STATE.
 1651
 1652      This macro is intended for use with ANLZ routines written for CRAWDAD.
 1653      */
 1654
 1655      %MACRO KN_TCTX_ST_TXT (FPTN=K_TCTX_ST_TXT, VALUE=X);
 1656
 1657       %LSET LISTDIR='0'B;
 1658       %LSET LISTEXP='1'B;
 1659       %LSET LISTCOM='0'B;
 1660       %LSET LISTSUB='1'B;
 1661
 1662      %LIST;
 1663
 1664            '%0.' VALUE '[NULL    '
 1665              '%1?REFWAIT '
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          46   
 1666              '%2?CLOSED  '
 1667              '%3?WFCC    '
 1668              '%4?WBCL    '
 1669              '%5?OPEN    '
 1670              '%6?WFTRESP '
 1671              '%7?AKWAIT  '
 1672              '%8?CLOSING '
 1673              '%9?WFNC    '
 1674              '%10?WFCC_R  '
 1675              '%11?WF_CR   '
 1676              '%?x       '
 1677              '%]'
 1678      %MEND;
 1679
 1680
 1681
 1682
 1683      /*F* NAME: KN$IOP
 1684
 1685      The KN$IOP macro defines the structure of a FEP
 1686      I/O Packet.
 1687      */
 1688      %MACRO KN$IOP (NAME=KN$IOP,ALGN=ALIGNED,STCLASS=BASED);
 1689
 1690      DCL 1 NAME STCLASS ALGN,
 1691      %IF MODE_FEP;
 1692           %VLP_ERRCODE (FPTN=ERRCODE,STCLASS=STCLASS,LVL=2,LAST=",");
 1693      %ELSE;
 1694            2 ERR,
 1695              3 FCG BIT(12) UNAL,
 1696              3 MID BIT(6) UNAL,
 1697              3 MON BIT(1) UNAL,
 1698              3 ERR# UBIN(14) UNAL,
 1699              3 SEV UBIN(3) UNAL,
 1700      %ENDIF;
 1701            2 ARS UBIN(16) CALIGNED,
 1702            2 KEYTYPE REDEF ARS UBIN(16) CALIGNED,
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          47   
 1703            2 FLDID REDEF ARS UBIN(16) CALIGNED,
 1704            2 FLAGS,
 1705      %IF NOT(MODE_FEP);
 1706              3 * BIT(1),
 1707      %ENDIF;
 1708              3 TRUNC BIT(1),
 1709              3 WAIT BIT(1),
 1710              3 RDDONE BIT(1) UNAL,
 1711              3 INUSE BIT(1),
 1712              3 READMLT BIT(1),
 1713              3 * BIT(3),
 1714              3 * UBIN BYTE CALIGNED,
 1715      %IF MODE_FEP;
 1716            2 BUF_ VECTOR,
 1717      %ELSE;
 1718            2 BUF,
 1719              3 BND UBIN(16) CALIGNED,
 1720              3 BASE$ PTR CALIGNED,
 1721      %ENDIF;
 1722      %IF MODE_FEP;
 1723            2 KEY_ VECTOR,
 1724      %ELSE;
 1725            2 KEY,
 1726              3 BND UBIN(16) CALIGNED,
 1727              3 BASE$ PTR CALIGNED,
 1728      %ENDIF;
 1729            2 DCB$ PTR CALIGNED,
 1730            2 MSGID UBIN(32) CALIGNED,
 1731            2 LNK$ PTR CALIGNED,
 1732            2 L REDEF LNK$,
 1733              3 *     UBIN(16) CALIGNED,
 1734              3 *     UBIN BYTE CALIGNED,
 1735              3 USER# UBIN BYTE CALIGNED,
 1736      %IF MODE_FEP;
 1737            %G$SEGDESC(FPTN= BUFSEGDES,STCLASS=STCLASS,LAST=",",LVL=2);
 1738            %G$SEGDESC(FPTN= KEYSEGDES,STCLASS=STCLASS,LAST=",",LVL=2);
 1739            %G$SEGDESC(FPTN= DCBSEGDES,STCLASS=STCLASS,LAST=",",LVL=2);
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          48   
 1740      %ELSE;
 1741            2 BUFSEGDES,
 1742              3 W1 UBIN(16) CALIGNED,
 1743              3 W2 UBIN(16) CALIGNED,
 1744            2 KEYSEGDES,
 1745              3 W1 UBIN(16) CALIGNED,
 1746              3 W2 UBIN(16) CALIGNED,
 1747            2 DCBSEGDES,
 1748              3 W1 UBIN(16) CALIGNED,
 1749              3 W2 UBIN(16) CALIGNED,
 1750      %ENDIF;
 1751            2 MSGTYPE CHAR(8) CALIGNED,
 1752            2 EVENT UBIN(16) CALIGNED;
 1753
 1754      %MEND;
 1755
 1756
 1757
 1758
 1759
 1760
 1761      /*F* NAME: KNA_IOPFLAG_TEXT
 1762
 1763      The KNA_IOPFLAG_TEXT macro generates the text for the
 1764      bit settings in KN$IOP.FLAGS.
 1765      */
 1766
 1767      %MACRO KNA_IOPFLAG_TEXT (NAME=KNA_IOPFLAG_TEXT, STCLASS=CONSTANT);
 1768
 1769      %LSET LISTDIR='0'B;
 1770      %LSET LISTEXP='1'B;
 1771      %LSET LISTCOM='0'B;
 1772      %LSET LISTSUB='1'B;
 1773
 1774      DCL 1 NAME STCLASS,
 1775            2 * CHAR(0) INIT('FLAGS  '),
 1776            2 SREST CHAR(0) UNAL INIT('set:     '),
14:51 JUL 28 '97 KN_DATA_M.:E05SI                                          49   
 1777            2 * CHAR(0) INIT('%1N(%)'),
 1778            2 * CHAR(0) INIT('%1N(Trunc   %)'),
 1779            2 * CHAR(0) INIT('%1N(Wait    %)'),
 1780            2 * CHAR(0) INIT('%1N(Rddone  %)'),
 1781            2 * CHAR(0) INIT('%1N(Inuse   %)'),
 1782            2 * CHAR(0) INIT('%1N(Readmlt %)'),
 1783            2 * CHAR(0) INIT('%S');
 1784      %MEND;
 1785

