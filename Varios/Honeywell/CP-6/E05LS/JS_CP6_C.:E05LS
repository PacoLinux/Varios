

07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           1    
    1      /*M*   JS_CP6_C   FPT Macros for Job Step Control PMMEs  */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100                */
    8      /*******************************************************************/
    9      /*                                                                 */
   10      /*                 *** CP-6 EXECUTION CONTROL ***                  */
   11      /*                                                                 */
   12      /*     Execution Control Monitor Service Calls                     */
   13      /*******************************************************************/
   14
   15
   16                          /*F* NAME: M$EXIT - Terminate Program Normally
   17
   18                          The M$EXIT service provides for normal
   19                          termination of the current program.  When
   20                          called bv the user program, M$EXIT typically
   21                          enters job step processing, following execution of
   22                          any exit control procedure(s).  If the exiting
   23                          program was called by M$LINK, the M$EXIT service
   24                          returns to the calling program, following
   25                          execution of any exit control procedure(s).
   26
   27                          For complete information on exit control, see the
   28                          discussion of M$XCON in Section 6.  That
   29                          discussion includes a description of exit control
   30                          in both the user program and Alternate Shared
   31                          Library.
   32
   33                          The FPT_EXIT parameters allow for explicit setting
   34                          of the Step Condition Code and the error code to be
   35                          used by the HELP facility of IBEX.
   36                          If no FPT is specified, the Step Condition Code and
   37                          the error code are both set to zero.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           2    
   38                          The memory in use by the terminating program
   39                          is released; post association of a debugger is
   40                          not possible if a program is terminated via M$EXIT.
   41
   42                          No FPT is required by M$EXIT but one may be
   43                          specified to provide for an explicit setting of
   44                          the Step Condition Code or HELP error code if desired.
   45
   46                          The form of the call for this service is:
   47
   48                          CALL M$EXIT;
   49
   50                          or
   51
   52                          CALL M$EXIT (FPT_EXIT);
   53
   54                          When the FPT is specified, the parameters are as
   55                          follows:                                                                      */
   56
   57
   58      %MACRO FPT_EXIT(FPTN=FPT_EXIT,
   59                    STCLASS=STATIC,
   60                    CODE=NIL,
   61                    STEPCC(OK=0,ERROR=4,ABORT=6,ANY)=0);
   62
   63      %LSET LISTDIR='0'B;
   64      %LSET LISTEXP='1'B;
   65      %LSET LISTCOM='0'B;
   66      %LSET LISTSUB='1'B;
   67      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
   68      %IF (SUBSTR(STR,0,6)='STATIC') OR
   69       (SUBSTR(STR,0,8)='CONSTANT') OR
   70       (SUBSTR(STR,0,3)='EXT');
   71       %LSET INIT=CHARTEXT('INIT');
   72      %ELSE;
   73       %LSET INIT=CHARTEXT('/*');
   74      %ENDIF;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           3    
   75
   76
   77      DCL 1 FPTN STCLASS DALIGNED,
   78            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
   79            2 CODE_ BIT(72) %INIT(VECTOR(CODE))%CHARTEXT('/**/'),
   80                          /*K* CODE = VARIABLE specifies the 1-word area in
   81                          memory containing the error code to be returned
   82                          to the user when requested via the HELP facility
   83                          of IBEX.   The VLP_ERRCODE macro may be used to
   84                          generate a structure for the error code.
   85                          The severity field in the error code should
   86                          reflect the lowest level of the error message
   87                          that is to be reported by IBEX in response to
   88                          '?'.
   89                          The default is NIL.
   90                          */
   91            2 V DALIGNED,
   92              3 STEPCC# UBIN(9) UNAL %INIT(STEPCC)%CHARTEXT('/**/'),
   93              3 CODE# REDEF STEPCC# BIT(9),
   94                          /*K*  STEPCC = {OK|ERROR|ABORT}   specifies how the Step
   95                          Condition Code is to be set:  OK=0, ERROR=4,
   96                          ABORT=6.  The parameter may also be specified as
   97                          a decimal value (0-511).  The default is 0.                                   */
   98              3 * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'),
   99              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
  100      %MEND;
  101
  102
  103
  104
  105
  106                          /*F* NAME: M$ERR_ - Error Job Step
  107
  108                          The M$ERR service provides for error
  109                          termination of the current job step. M$ERR passes
  110                          control as specified for M$EXIT. In addition,
  111                          M$ERR sets the Step Condition Code to 4 if
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           4    
  112                          no FPT is specified.  M$ERR sends an appropriate
  113                          message to the listing device if the CODE option
  114                          is not specified.
  115                          The memory used by the terminating program is not
  116                          released until the initiation of the next job
  117                          step; post-association of a debugger is therefore
  118                          allowed with a program that terminates via M$ERR.
  119
  120                          At error termination of a program (STEPCC>=4) for
  121                          a batch job, processing proceeds to the next job
  122                          step, unless there is an overriding IF command in
  123                          the command file (see CP-6 Programmer Reference for
  124                          details).  At error termination in the
  125                          course of an online job, the Command Processor
  126                          returns to the user for the next command.
  127
  128                          No FPT is required by M$ERR, but one may be
  129                          specified if explicit setting of the Step
  130                          Condition Code or HELP error code if desired.
  131                          The form of the call for this service is:
  132
  133                          CALL M$ERR;
  134
  135                          or
  136
  137                          CALL M$ERR (FPT_ERR);
  138
  139                          When the FPT is specified, the parameters are as
  140                          follows:                                                                      */
  141
  142
  143      %MACRO FPT_ERR(FPTN=FPT_ERR,
  144                    STCLASS=STATIC,
  145                    CODE=NIL,
  146                    STEPCC(OK=0,ERROR=4,ABORT=6,ANY)=0);
  147
  148      %LSET LISTDIR='0'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           5    
  149      %LSET LISTEXP='1'B;
  150      %LSET LISTCOM='0'B;
  151      %LSET LISTSUB='1'B;
  152      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  153      %IF (SUBSTR(STR,0,6)='STATIC') OR
  154       (SUBSTR(STR,0,8)='CONSTANT') OR
  155       (SUBSTR(STR,0,3)='EXT');
  156       %LSET INIT=CHARTEXT('INIT');
  157      %ELSE;
  158       %LSET INIT=CHARTEXT('/*');
  159      %ENDIF;
  160
  161
  162      DCL 1 FPTN STCLASS DALIGNED,
  163            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  164            2 CODE_ BIT(72) %INIT(VECTOR(CODE))%CHARTEXT('/**/'),
  165                          /*K* CODE = VARIABLE specifies the 1-word area in
  166                          memory containing the error code to be returned
  167                          to the user when requested via the HELP facility
  168                          of IBEX.   The VLP_ERRCODE macro may be used to
  169                          generate a structure for the error code.
  170                          The severity field in the error code should
  171                          reflect the lowest level of the error message
  172                          that is to be reported by IBEX in response to
  173                          '?'.
  174                          The default is NIL.
  175                          */
  176            2 V DALIGNED,
  177              3 STEPCC# UBIN(9) UNAL %INIT(STEPCC)%CHARTEXT('/**/'),
  178              3 CODE# REDEF STEPCC# BIT(9),
  179                          /*K*  STEPCC = {OK|ERROR|ABORT}   specifies how the Step
  180                          Condition Code is to be set: OK=0, ERROR=4,
  181                          ABORT=6. The parameter may also be specified as
  182                          a decimal value (0-511). The default is 0.                                    */
  183              3 * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  184              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
  185      %MEND;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           6    
  186
  187
  188
  189
  190
  191                          /*F* NAME: M$XXX - Abort Job
  192
  193                           The M$XXX service allows the user to abort the
  194                           current job.  M$XXX passes control as
  195                           specified for M$EXIT.  In addition, M$XXX sets the
  196                           Step Condition Code to 6 if no FPT is specified.
  197                           M$XXX also sends an appropriate message to
  198                           the listing device if the CODE option is not specified.
  199                           The memory in use by the terminating program is
  200                           not released prior to entry to the associated
  201                           command processor.  Post-association of a debugger
  202                           with a program that terminates via M$XXX is allowed.
  203
  204                           At a program abort condition (STEPCC>=6), the
  205                           current job step is aborted.  For a batch job, all
  206                           subsequent job steps are also aborted,
  207                           unless there is an overriding IF command in the
  208                           command file.  An online user is returned to the
  209                           Command Processor for the next command.
  210
  211                           No FPT is required for M$XXX, but one may be
  212                           specified if explicit setting of the Step
  213                           Condition Code or HELP error code if desired.
  214
  215                          The form of the call for this service is:
  216
  217                           CALL M$XXX;
  218
  219                           or
  220
  221                           CALL M$XXX (FPT_XXX);
  222
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           7    
  223                           When the FPT is specified, the parameters are as
  224                           follows:                                                                     */
  225
  226
  227
  228      %MACRO FPT_XXX(FPTN=FPT_XXX,
  229                    STCLASS=STATIC,
  230                    CODE=NIL,
  231                    STEPCC(OK=0,ERROR=4,ABORT=6,ANY)=0);
  232
  233      %LSET LISTDIR='0'B;
  234      %LSET LISTEXP='1'B;
  235      %LSET LISTCOM='0'B;
  236      %LSET LISTSUB='1'B;
  237      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  238      %IF (SUBSTR(STR,0,6)='STATIC') OR
  239       (SUBSTR(STR,0,8)='CONSTANT') OR
  240       (SUBSTR(STR,0,3)='EXT');
  241       %LSET INIT=CHARTEXT('INIT');
  242      %ELSE;
  243       %LSET INIT=CHARTEXT('/*');
  244      %ENDIF;
  245
  246
  247      DCL 1 FPTN STCLASS DALIGNED,
  248            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  249            2 CODE_ BIT(72) %INIT(VECTOR(CODE))%CHARTEXT('/**/'),
  250                          /*K* CODE = VARIABLE specifies the 1-word area in
  251                          memory containing the error code to be returned
  252                          to the user when requested via the HELP facility
  253                          of IBEX.   The VLP_ERRCODE macro may be used to
  254                          generate a structure for the error code.
  255                          The severity field in the error code should
  256                          reflect the lowest level of the error message
  257                          that is to be reported by IBEX in response to
  258                          '?'.
  259                          The default is NIL.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           8    
  260                          */
  261            2 V DALIGNED,
  262              3 STEPCC# UBIN(9) UNAL %INIT(STEPCC)%CHARTEXT('/**/'),
  263                          /*K* STEPCC = {OK|ERROR|ABORT}   specifies how the Step
  264                          Condition Code is to be set:  OK=0, ERROR=4,
  265                          ABORT=6.  The parameter may also be specified as
  266                          a decimal value (0-511).  The default is 0.
  267
  268
  269                          */
  270              3 CODE# REDEF STEPCC# BIT(9),
  271              3 * BIT(27) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  272              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
  273      %MEND;
  274
  275
  276
  277
  278
  279                          /*F* NAME: M$CPEXIT - Exit from Command Processor
  280
  281                          A Command Processor becomes associated with a
  282                          user whenever:
  283
  284                          1.  The Command Processor has been specified
  285                              via the SUPER user authorization CPROC option.
  286
  287                          2.  One Command Processor issues an M$CPEXIT Service
  288                              Request specifying another Command Processor be
  289                              associated with the user.
  290
  291                          Once associated with a user, a command processor will
  292                          be entered at its start address under any of the
  293                          following conditions:
  294
  295                          1.  The user is at Job Step (as will be the case on the
  296                              initial entry to the Command Processor).
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           9    
  297
  298                          2.  The user has aborted and is about to be rundown.
  299
  300                          3.  A time-sharing user has typed a Control-Y sequence
  301                              on his terminal.
  302
  303                          4.  A user program has issued an M$YC service request.
  304
  305                          5.  A user program has issued an M$LINK or M$LDTRC
  306                              monitor service request using the CP_CMD option.
  307
  308                          The CP-6 monitor communicates the reason for entry to
  309                          the command processor via bit settings in B$JIT.CPFLAGS1
  310                          as follows:
  311
  312                            }    CP_JSTEP#    the user is at Job Step.
  313
  314                            }    CP_RUND#     the user is about to be rundown.
  315
  316                            }    CP_YC#       the time-sharing user has typed a
  317                            }                 Control-Y sequence.
  318
  319                            }    CP_YCPMME#   the user program has issued an M$YC.
  320
  321                            }    CP_LNKPMME#  the user run unit has issued an M$LINK
  322                            }                 or M$LDTRC with a command to be parsed.
  323
  324
  325                          Another interesting bit in B$JIT.CPFLAGS1 is CP_LOGOFF#.  This
  326                          bit is set whenever the system has detected a line hang-up
  327                          of a time-sharing terminal or an operator abort of a user.
  328                          This bit may be set in conjunction with any of the other
  329                          bits mentioned above.  When set it indicates to the command
  330                          processor that no more job steps are allowed.
  331
  332                          The Command Processor communicates the action to be taken
  333                          for this user via the various options of M$CPEXIT.  This
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           10   
  334                          monitor service is used to:
  335
  336                            o  Initiate execution of a user program or shared
  337                               processor.
  338
  339                            o  Resume execution of an interrupted program
  340                               (following Control-Y or an M$YC service call).
  341
  342                            o  Associate a debugger with a (possibly
  343                               interrupted) user program.
  344
  345                            o  Remove a user from the system.
  346
  347                            o  Save the user environment on disk storage
  348
  349                          Before a Command Processor issues an M$CPEXIT, it
  350                          must have closed all its DCBs and, in general, have
  351                          cleaned up.  Data Segments that have been obtained
  352                          via M$GDS will be released unless CP_KEEPDS# has
  353                          been set in B$JIT.CPFLAGS1.
  354
  355                          The form of the call for this service is:
  356
  357                          CALL M$CPEXIT (FPT_CPEXIT) [ALTRET (label)];
  358
  359                          The parameters for this service are as follows:
  360                          */
  361
  362
  363      %MACRO FPT_CPEXIT(FPTN=FPT_CPEXIT,
  364                      STCLASS=STATIC,
  365                      VECTORS=YES,
  366                      NAME=NIL,
  367                      ACCT=NIL,
  368                      PASS=NIL,
  369                      PSID=NIL,
  370                      DEBUG=NIL,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           11   
  371                      CONT(YES='1'B,NO='0'B)='0'B,
  372                      QUIT(YES='1'B,NO='0'B)='0'B,
  373                      ALTRTN(YES='1'B,NO='0'B)='0'B,
  374                      CPOFF(YES='1'B,NO='0'B)='0'B,
  375                      SAVEFLG(YES='1'B,NO='0'B)='0'B,
  376                      GETFLG(YES='1'B,NO='0'B)='0'B,
  377                      LINK(YES='1'B,NO='0'B)='0'B,
  378                      FCG='0000'O,
  379                      MID='00'O,
  380                      CODE=0,
  381                       SEV=0);
  382
  383      %LSET LISTDIR='0'B;
  384      %LSET LISTEXP='1'B;
  385      %LSET LISTCOM='0'B;
  386      %LSET LISTSUB='1'B;
  387      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  388      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  389      %LSET INIT=CHARTEXT(' INIT');
  390      %LSET EINIT=CHARTEXT('');
  391      %ELSE;
  392      %LSET INIT=CHARTEXT('/*');
  393      %LSET EINIT=CHARTEXT('*/');
  394      %ENDIF;
  395
  396
  397      DCL 1 FPTN STCLASS DALIGNED,
  398      %IF TEXTCHAR(VECTORS)='YES';
  399            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%EINIT,
  400                          /*K* NAME = VARIABLE specifies the location of a TEXTC string
  401                          of up to 31 characters, designating the requested
  402                          run unit or shared processor.  The default is NIL.
  403
  404                          M$CPEXIT issued with no NAME and all flags specified
  405                          as NO (the default) constitutes a request to remove the
  406                          user from the system.  This request must never be
  407                          issued if the user is not at job step.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           12   
  408                          */
  409            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%EINIT,
  410                          /*K* ACCT = VARIABLE  specifies location of a TEXT string
  411                          of eight characters, designating the account
  412                          in which the run unit resides (:SYS is specified
  413                          for shared processors).  The default is NIL.
  414                          */
  415            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%EINIT,
  416                          /*K* PASS = VARIABLE  specifies the location of a TEXT string
  417                          of eight characters, designating the
  418                          password associated with the run unit.
  419                          The default is NIL.
  420                          */
  421            2 PSID_ BIT(72) %INIT(VECTOR(PSID))%EINIT,
  422                          /*K* PSID = VARIABLE  specifies the location of a TEXT string
  423                          of six characters, designating the identification
  424                          of the pack set on which the run unit is located.
  425                          The default is NIL.
  426                          */
  427            2 DEBUG_ BIT(72) %INIT(VECTOR(DEBUG))%EINIT,
  428                          /*K* DEBUG = VARIABLE  specifies the VLP containing a TEXTC string
  429                          of up to 11 characters, designating a debugger to
  430                          be associated with the user.  The default is NIL.
  431                          */
  432            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%EINIT,
  433            2 V DALIGNED,
  434      %LSET LVL=3;
  435      %ELSE;
  436      %LSET LVL=2;
  437      %ENDIF;
  438              %(LVL) CONT# BIT(1) UNAL %INIT(CONT)%EINIT,
  439                          /*K* CONT =  {YES|NO}   specifies, if YES, that the
  440                          currently interrupted program is to be resumed,
  441                          possibly under control of a debugger.
  442                          If both CONT and ALTRTN are specified, the ALTRTN
  443                          option is ignored.
  444                          The default is NO.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           13   
  445                          */
  446
  447              %(LVL) QUIT# BIT(1) UNAL %INIT(QUIT)%EINIT,
  448                          /*K* QUIT =  {YES|NO}   specifies, if YES, that the
  449                          currently interrupted program has been errored
  450                          (Control-Y  followed by QUIT).  Any Exit Control
  451                          established by the user program and/or ASL will be
  452                          honored.  The Command Processor will then be
  453                          re-entered.  The default is NO.
  454                          */
  455              %(LVL) ALTRTN# BIT(1) UNAL %INIT(ALTRTN)%EINIT,
  456                          /*K* ALTRTN =  {YES|NO}  specifies, if YES, that an
  457                          ALTRET to the user's M$YC service is to be taken.
  458                          When ALTRTN is specified, the error code to be returned
  459                          to the user may also be specified via the FCG, MID,
  460                          CODE and SEV options.
  461                          This option is ignored if CONT is also specified.
  462                          The default is NO.
  463                          */
  464              %(LVL) SAVEFLG# BIT(1) UNAL %INIT(SAVEFLG)%EINIT,
  465                          /*K* SAVEFLG =  {YES|NO}   specifies, if YES, that the
  466                          Command Processor is requesting the monitor to
  467                          perform a SAVE upon the
  468                          currently running user program, with the
  469                          FID in the M$CPEXIT FPT used as the FID for the
  470                          SAVE file.  The default is NO.
  471                          */
  472              %(LVL) GETFLG# BIT(1) UNAL %INIT(GETFLG)%EINIT,
  473                          /*K* GETFLG =  {YES|NO}   specifies,
  474                          if YES, that the
  475                          Command Processor is requesting the monitor to
  476                          restore (GET) a previously
  477                          saved program, using the FID specified in the
  478                          M$CPEXIT FPT.  The default is NO.
  479                          */
  480              %(LVL) CPOFF# BIT(1) UNAL %INIT(CPOFF)%EINIT,
  481                          /*K* CPOFF = {YES|NO}  specifies, if YES, that the
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           14   
  482                          Operator Abort sequence is to be initiated.
  483                          When CPOFF = YES is specified, the error code to be returned
  484                          to the user may also be specified via the FCG, MID,
  485                          CODE and SEV options.
  486                          The default is NO.
  487                          */
  488              %(LVL) LINK# BIT(1) UNAL %INIT(LINK)%EINIT,
  489                          /*K* LINK = {YES|NO}   specifies, if YES, that
  490                          the environment of the current run-unit is
  491                          to be saved on disk storage in the *N file;
  492                          i.e. the M$LINK process is to be simulated.
  493                          After the image is saved control will return
  494                          to the command processor at the normal return
  495                          of the M$CPEXIT.
  496                          Default = NO.
  497                          */
  498
  499              %(LVL) * UBIN(29) UNAL %INIT(0)%EINIT,
  500              %(LVL) JERR,
  501                %(LVL+1) FCG# BIT(12) UNAL %INIT(FCG)%EINIT,
  502                          /*K* FCG = VALUE-BIT(12).  specifies the value for
  503                          the function code group in the error code.  This
  504                          parameter is only valid if CPOFF=YES or
  505                          ALTRTN=YES, and allows the Command Processor to generate a
  506                          specific error code.
  507                          */
  508                %(LVL+1) MID# BIT(6) UNAL %INIT(MID)%EINIT,
  509                          /*K* MID = VALUE-BIT(6).  specifies the value for the
  510                          module ID in the error code.
  511                          This parameter is only valid if CPOFF=YES or ALTRTN=YES, and
  512                          allows the Command Processor to generate a specific error code.
  513                          */
  514                %(LVL+1) CODE# UBIN(15) UNAL %INIT(CODE)%EINIT,
  515                          /*K* CODE = VALUE-DEC(0-16383) specifies the value
  516                          of the error number in the error code.
  517                          This parameter is only valid if CPOFF=YES or ALTRTN=YES, and
  518                          allows the Command Processor to generate a specific error code.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           15   
  519                          */
  520                %(LVL+1) SEV# UBIN(3) UNAL %INIT(SEV)%EINIT;
  521                          /*K* SEV = VALUE-DEC(0-7) specifies the value for
  522                          the severity level in the error code.
  523                          This parameter is only valid if CPOFF=YES or ALTRTN=YES, and
  524                          allows the user to generate a specific error code.
  525                          */
  526      %MEND;
  527
  528
  529                          /*F* NAME: M$YC - Simulate CONTROL-Y
  530
  531                          The M$YC monitor service simulates a Control-Y
  532                          sequence and causes control to be given to the
  533                          Command Processor so that a specific command can
  534                          be processed.
  535
  536                          If the Command Processor does not accept M$YC or
  537                          CMD=NIL, the alternate return is taken.  The
  538                          Command Processor can also signal the monitor to
  539                          take the alternate return.
  540                          The error code specified by the command processor
  541                          will be in the TCB ALTRET frame.
  542
  543                          If the command is completed successfully, the
  544                          normal return is taken, except if the command is
  545                          QUIT or OFF (in IBEX).  In this case, the program
  546                          enters standard exit processing.
  547
  548                          The form of the call for this service is:
  549
  550                          CALL M$YC (FPT_YC) [ALTRET (label)];
  551
  552                          The parameters for this service are as follows:                               */
  553
  554
  555      %MACRO FPT_YC (FPTN=FPT_YC,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           16   
  556                   STCLASS=STATIC,
  557                   ECHO(YES='1'B,NO='0'B)='0'B,
  558                   NOERR(YES='1'B,NO='0'B)='0'B,
  559                   LINK(YES='1'B,NO='0'B)='0'B,
  560                   REPARSE(YES='1'B,NO='0'B)='0'B,
  561                   REPLY=NIL,
  562                   CMD=NIL);
  563
  564      %LSET LISTDIR='0'B;
  565      %LSET LISTEXP='1'B;
  566      %LSET LISTCOM='0'B;
  567      %LSET LISTSUB='1'B;
  568      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  569      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  570      %LSET INIT=CHARTEXT(' INIT');
  571      %LSET EINIT=CHARTEXT('');
  572      %ELSE;
  573      %LSET INIT=CHARTEXT('/*');
  574      %LSET EINIT=CHARTEXT('*/');
  575      %ENDIF;
  576
  577
  578      DCL 1 FPTN STCLASS DALIGNED,
  579            2 CMD_ BIT(72) %INIT(VECTOR(CMD))%EINIT,
  580                          /*K* CMD = VARIABLE  specifies an area containing a
  581                          TEXT string of up to 256 characters that is passed to
  582                          the Command Processor. This string cannot
  583                          contain a continuation character.
  584
  585                          Default = NIL.
  586                          */
  587            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%EINIT,
  588            2 REPLY_ VECTOR %INIT(VECTOR(REPLY))%EINIT,
  589                          /*K* REPLY = VARIABLE  specifies an area into which
  590                          the Command Processor may store a reply to the
  591                          command.  When the command is processed by the IBEX
  592                          command processor, the VLR_YC macro should
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           17   
  593                          be used to generate the area.
  594
  595                          Default = NIL.
  596                          */
  597            2 V DALIGNED,
  598              3 ECHO# BIT(1) UNAL %INIT(ECHO)%EINIT,
  599                          /*K* ECHO =  {YES|NO}   specifies, if YES, that the
  600                          command specified via the CMD parameter is to
  601                          be echoed through the M$LL DCB.  The default is NO.
  602
  603                          Default = NO.
  604                          */
  605
  606              3 NOERR# BIT(1) UNAL %INIT(NOERR)%EINIT,
  607                          /*K* NOERR =  {YES|NO}   specifies, if YES, that any error
  608                          detected while processing the CMD parameter is not to
  609                          be printed through the M$DO DCB.  The default is NO (i.e., print
  610                          the error message).  When an error is detected by
  611                          the IBEX Command Processor, the ALTRET to the M$YC
  612                          Service Request will be taken.
  613
  614                          Default = NO.
  615                          */
  616              3 LINK# BIT(1) UNAL %INIT(LINK)%EINIT,
  617                          /*K* LINK = {YES|NO}   specifies, if YES, that if the
  618                          command would normally require running down the current
  619                          run-unit, then the environment of the current run-unit is
  620                          to be saved on disk storage prior to processing the command;
  621                          i.e. the M$LINK process is to be simulated.
  622                          If NO is specified, and the command would require the current
  623                          process to be run down, the M$YC ALTRET procedure will be
  624                          entered.
  625
  626                          Default = NO.
  627                          */
  628
  629              3 REPARSE# BIT(1) UNAL %INIT(REPARSE)%EINIT,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           18   
  630                          /*K* REPARSE = {YES|NO}.
  631                          The reparse option is used only when the command
  632                          specified by the CMD option is known to contain an
  633                          error.  REPARSE=YES specifies that the
  634                          Command Processor is to print the legal syntax
  635                          alternatives through the M$LL DCB
  636                          and to take no other action on the
  637                          command.
  638
  639                          Default = NO.
  640                          */
  641              3 * UBIN(32) UNAL %INIT(0)%EINIT;
  642      %MEND;
  643
  644
  645                          /*F* NAME: VLR_YC
  646
  647                          The VLR_YC macro generates storage that may
  648                          be used as a REPLY area for the M$YC monitor service.
  649
  650                          Fields in the structure are as follows:
  651                          */
  652
  653      %MACRO VLR_YC
  654          (FPTN=VLR_YC,
  655           STCLASS=STATIC);
  656
  657       %LSET LISTDIR='0'B;
  658       %LSET LISTEXP='1'B;
  659       %LSET LISTCOM='0'B;
  660       %LSET LISTSUB='1'B;
  661
  662      DCL 1 FPTN STCLASS DALIGNED,
  663            2 CPOS UBIN UNAL,
  664                          /*K* CPOS = VALUE-UBIN.  This field will contain
  665                          an index into the command that indicates where an
  666                          error was detected.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           19   
  667
  668                          This field is valid only on the alternate return to
  669                          M$YC.
  670                          */
  671            2 * BIT(36) UNAL;
  672
  673      %MEND;
  674
  675
  676                          /*F* NAME: Program_Structure Control
  677
  678                          The monitor provides services to transfer control
  679                          within the user program or to transfer control to
  680                          the command processor.  The CP-6 system permits the user
  681                          to structure code as follows:
  682
  683                              o  As a single run unit which can be loaded
  684                                 in its entirety into available memory in the
  685                                 Instruction Segment.  Monitor services
  686                                 described next are not required in such a
  687                                 program.
  688
  689                              o  As multiple run units.  In the course of a single
  690                                 job step, several run units can be called.  For
  691                                 instance, the user program may call other programs
  692                                 or processors such as SORT.  The called program
  693                                 completely replaces the calling program in
  694                                 memory. The M$LINK and M$LDTRC monitor services
  695                                 are available to transfer control between
  696                                 programs.  Note that a program may determine
  697                                 if it was called via M$LINK or M$LDTRC by
  698                                 inspecting B$JIT.PROG_ENTRY.
  699
  700                              o  As a single overlaid run unit.  The user program
  701                                 contains a root node which is always memory-resident,
  702                                 and a number of overlays.  An overlaid program has a
  703                                 well-defined tree structure, as discussed in the CP-6
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           20   
  704                                 Programmer Reference Manual.  The M$OLAY
  705                                 service transfers control between overlays.
  706                                                                                  */
  707                          /*F* NAME: M$OLAY - CALL/CANCEL Overlay
  708
  709                          The M$OLAY service calls or releases a specified
  710                          overlay. For a program linked with the NOBREF
  711                          option, the user must load and transfer control to
  712                          overlays via explicit calls to M$OLAY. (When the
  713                          BREF option is used, the linker supplies all calls
  714                          to M$OLAY.)
  715
  716                          M$OLAY with CANCEL=NO brings in both the data and
  717                          procedure portions of the overlay, unless they are
  718                          already in memory. If CANCEL=YES, the routine
  719                          releases the overlay and its forward path. If an
  720                          error occurs while executing the OLAY routine or
  721                          if the specified overlay is not found, the
  722                          alternate return is taken. (If no ALTRET is
  723                          specified, the job is aborted.)
  724
  725                          The form of the call for this service is:
  726                          follows:
  727
  728                          CALL M$OLAY (FPT_OLAY) [ALTRET (label)];
  729
  730                          The parameters for this service are as follows:                               */
  731
  732
  733      %MACRO FPT_OLAY(FPTN=FPT_OLAY,
  734                     STCLASS=STATIC,
  735                     ONAME=NIL,
  736                     NOPATH(YES='1'B,NO='0'B)='0'B,
  737                     ENTER(YES='1'B,NO='0'B)='0'B,
  738                     CANCEL(YES='1'B,NO='0'B)='0'B);
  739
  740      %LSET LISTDIR='0'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           21   
  741      %LSET LISTEXP='1'B;
  742      %LSET LISTCOM='0'B;
  743      %LSET LISTSUB='1'B;
  744      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  745      %IF (SUBSTR(STR,0,6)='STATIC') OR
  746       (SUBSTR(STR,0,8)='CONSTANT') OR
  747       (SUBSTR(STR,0,3)='EXT');
  748       %LSET INIT=CHARTEXT('INIT');
  749      %ELSE;
  750       %LSET INIT=CHARTEXT('/*');
  751      %ENDIF;
  752
  753
  754      DCL 1 FPTN STCLASS DALIGNED,
  755            2 ONAME_ BIT(72) %INIT(VECTOR(ONAME))%CHARTEXT('/**/'), /* OVERLAY NAME (TEXTC)             */
  756                          /*K* ONAME = VARIABLE specifies the area containing a
  757                          TEXTC string designating the desired overlay.
  758                          The area can be generated by invoking the
  759                          VLP_NAME macro. (An overlay name is limited to
  760                          31 characters in length.)  The default is NIL.                                */
  761            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
  762            2 V DALIGNED,
  763              3 FLGS,
  764                4 * BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  765                4 NOPATH# BIT(1) UNAL %INIT(NOPATH)%CHARTEXT('/**/'),
  766                          /*K* NOPATH = {YES|NO}  specifies, if YES, that no
  767                          overlays on the backward path of the called
  768                          overlay are to be brought in. If NOPATH=NO,
  769                          M$OLAY brings in the called overlay and its
  770                          entire backward path. (Cancelling an overlay
  771                          obtained with NOPATH=YES releases only that
  772                          overlay.) The default is NO.                                                  */
  773                4 ENTER# BIT(1) UNAL %INIT(ENTER)%CHARTEXT('/**/'),
  774                          /*K* ENTER = {YES|NO}  is meaningful only when
  775                          CANCEL=NO. ENTER=YES specifies that M$OLAY is to
  776                          transfer control to the first ENTDEF in the
  777                          overlay; the X1 register is set to the location
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           22   
  778                          of the instruction following the call to M$OLAY.
  779                          When writing in PL-6, the programmer should specify
  780                          ALTRET on the call to M$OLAY and ALTRET on the PL-6
  781                          overlay procedure to insure proper return
  782                          when the overlay exits.
  783
  784                          If ENTER=NO, M$OLAY calls in the overlay but
  785                          returns control to the instruction following the
  786                          call to M$OLAY, not to the called overlay.
  787                          The default is NO.                                                            */
  788                4 CANCEL# BIT(1) UNAL %INIT(CANCEL)%CHARTEXT('/**/'),
  789                          /*K* CANCEL = {YES|NO}  specifies, if NO, that the overlay
  790                          is to be loaded into memory along with its
  791                          backward path. YES specifies that the overlay
  792                          and its forward path are to be released.
  793                          However, if the overlay was brought in with the
  794                          NOPATH = YES option,
  795                          only the overlay itself is released.
  796                          The default is NO.                                                            */
  797              3 * UBIN(27) UNAL %INIT(0)%CHARTEXT('/**/'),
  798              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
  799      %MEND;
  800
  801
  802
  803
  804
  805                          /*F* NAME: M$LINK - Link to Program
  806
  807                          The M$LINK monitor service causes the calling
  808                          program's memory (procedure, program
  809                          data and data segments - except the common
  810                          segment) to be saved on disk storage making the calling
  811                          program's memory available for the called
  812                          program. The called program is then loaded into
  813                          memory and control is transferred to it.
  814                          When that program is terminated, control is
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           23   
  815                          returned to the program making the M$LINK request.
  816
  817                          M$LINK may only be issued from the user domain.
  818                          Standard shared processors may use M$LINK;
  819                          special shared processors may not.
  820
  821                          Any communication between the calling and called
  822                          programs must be accomplished through
  823                          the common data segment or the Control
  824                          Command Buffer.  The called program may determine
  825                          that it has been entered via M$LINK as the value
  826                          of B$JIT.PROG_ENTRY will have been set to %PE_LINK#.
  827
  828                          The program to be put into execution may be specified
  829                          either by using the CP_CMD option or by using the
  830                          NAME, ACCT, PASS, and PSID options.  The choice of
  831                          which to use will depend on whether the calling program
  832                          wishes to convey DCB assignment information over the
  833                          M$LINK process.
  834
  835                          If the CP_CMD option is used, the command processor
  836                          will parse the command line and build the assign merge
  837                          records as specified if the command is presented in standard
  838                          syntax.  When the linked to program is entered
  839                          the SI, UI, OU, LS and NSSYNTAX bits in B$JIT.PRFLAGS
  840                          will be set accordingly.
  841
  842                          If the NAME, ACCT, PASS, PSID, and CMD options are used,
  843                          the command will not be parsed by the command processor.
  844                          The NSSYNTAX bit will be reset in B$JIT.PRFLAGS; the NOSCAN bit will
  845                          be set in B$JIT.PRFLAGS.  If the requested run unit was built
  846                          with the STDINVOC option, that run unit will not be put into
  847                          execution; the M$LINK ALTRET code
  848                          sequence will be entered.
  849
  850                          The assign/merge records for #1, #2, #3 and #4 will be written to
  851                          the image file as part of the M$LINK process.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           24   
  852
  853                          If the CP_CMD option was specified on the M$LINK command, these
  854                          records will then be deleted from the *A file and PRFLAGS will be
  855                          reset.  When an image file is restored, these assign/merge
  856                          records will be re-written into the *A file.
  857
  858                          If the NAME option is used, the records are not
  859                          deleted from the *A file and
  860                          PRFLAGS will not be reset.  The NSSYNTAX and NOSCAN
  861                          bits in PRFLAGS will be set.
  862
  863                          If the specified program cannot be put into
  864                          execution (i.e. the program cannot be found,
  865                          the specified program is not a valid program,
  866                          or an I/O error occurs while attempting to read
  867                          the program), the ALTRET will be taken or the
  868                          job will be aborted if an ALTRET was not specified.
  869
  870                          A normal return is made to the calling program
  871                          when the called program exits normally.
  872
  873                          When the M$LINKing program is restored, the SI, UI, OU, LS,
  874                          NSSYNTAX and NOSCAN bits in B$JIT.PRFLAGS will be restored to
  875                          the values that existed at the time of the M$LINK.  The processor
  876                          privilege bits (B$JIT.PRIV.PRC) will also be restored to the
  877                          values that existed at the time of the link.  B$JIT.PRIV.ACTIVE
  878                          will be set to those that were active at the time of the link
  879                          ORed with those that may have been set via an IBEX command while
  880                          the linked to program was active (B$JIT.PRIV.JOB).
  881                          The contents of B$JIT.CCBUF, .CCARS and .CCDISP will be restored
  882                          unless the linked to program was aborted via the user typing a
  883                          YC - QUIT sequence or any command processor command that implied
  884                          QUIT.
  885
  886                          The following terminal attributes for M$UC are restored to the
  887                          values as they existed at the time of the link:
  888
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           25   
  889                          .FIF
  890                             M$PROMPT - all options
  891                             M$EOM - all options
  892                             M$STRMCTL - these options:  ACTONTRN, AUTOTABCLM,
  893                                         DISPINPUT, ENBENTEXTSRDCHR, HSCROLL,
  894                                         HSMARGIN, HSSHIFT, NOOPTMIZ, TRUNCATE,
  895                                         WORDWRAPCLM
  896                             M$DEVICE - HDR option
  897                             LDEV - TITLE option
  898                             .FIN
  899
  900                          If the called program terminates via M$EXIT, M$ERR
  901                          or M$XXX specifying an error code,
  902                          the calling program will be re-entered
  903                          at the M$LINK ALTRET code sequence.  The severity of the
  904                          error code in the ALTRET frame will remain as set by
  905                          the linked to program, which may or may not be zero.
  906                          The CP_EXIT# bit will be set in B$JIT.CPFLAGS1.
  907
  908                          If the called program aborts for any reason
  909                          (i.e. calls M$ERR or M$XXX with no error code,
  910                          calls M$MERC or M$MERCS, or encounters a monitor
  911                          service error or a fault for which no handling is
  912                          specified), the calling program will be re-entered
  913                          at the M$LINK ALTRET code sequence.
  914                          The CP_EXIT# bit will be reset in B$JIT.CPFLAGS1.
  915                          The severity of the
  916                          error code in the ALTRET frame will have been
  917                          reduced to zero.  Thus the calling program's ALTRET
  918                          code sequence can determine if the requested program was
  919                          put into execution or not by inspecting the value
  920                          of the error code severity.  However, note that if the
  921                          the called program aborts and the calling program
  922                          had not specified ALTRET on the M$LINK request, the
  923                          calling program will not be aborted as the severity
  924                          of the error has been set to zero.
  925
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           26   
  926                          The return to the calling program will be to that
  927                          program's exit control procedure if any of the
  928                          following conditions should occur while executing
  929                          the linked to program:
  930
  931                               1.   When the running user was the target of an
  932                                    operator "X" key-in.
  933
  934                               2.   When a line disconnect occurs while executing
  935                                    the called program and the user is not
  936                                    "autosaved", or if his program image was saved
  937                                    but he allowed it to time out or explicitly
  938                                    deleted it.
  939
  940                               3.   When the linked-to program enlarged the size
  941                                    of the common data segment such that restoring
  942                                    the calling program has caused the authorized
  943                                    memory limit to be exceeded.
  944
  945                               4.   When the job step has been aborted via a
  946                                    Control-Y QUIT command.
  947
  948                          Note that if any of these conditions should occur and
  949                          the calling program does not have exit control, the
  950                          calling program will be aborted.
  951
  952                          Unlike M$LDTRC, the issuing of an M$LINK
  953                          will not cause control to be passed to
  954                          the effective Exit Control procedure of the calling program.
  955
  956                          If an Alternate Shared Library is associated with
  957                          the program calling M$LINK, the ASL remains associated
  958                          when the calling program is restored.
  959
  960                          If a debugger is associated with the user,
  961                          the debugger will also be associated with the
  962                          associated when the calling program is restored.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           27   
  963
  964                          If one or more FPRG DCBs are open when an M$LINK
  965                          is issued, the DCBs will remain open but
  966                          inaccessible to the called program.  Any data
  967                          which is sent via those FPRG DCBs is
  968                          discarded.  When the calling program is restored,
  969                          it should verify that its FPRG DCBs are still open.
  970                          In general, they will be open unless the FPRG
  971                          itself exited or aborted.
  972                          only.  In any case, the debugger will remain
  973                          associated when the calling program is restored.
  974
  975                          If one or more FPRG DCBs are open when an M$LINK
  976                          is issued, the DCBs will remain open but
  977                          inaccessible to the called program.  Any data
  978                          sent by those FPRG is
  979                          discarded.  When the calling program is restored,
  980                          it should verify that its FPRG DCBs are still open.
  981                          In general, they will be open unless the FPRG
  982                          itself exited or aborted.
  983
  984                          The form of the call for this service is:
  985
  986                          CALL M$LINK (FPT_LINK) [ALTRET (label)];
  987
  988                          The parameters for this service are as follows:                               */
  989
  990
  991      %MACRO FPT_LINK(FPTN=FPT_LINK,
  992                    STCLASS=STATIC,
  993                    NAME=NIL,
  994                    ACCT=NIL,
  995                    PASS=NIL,
  996                    PSID=NIL,
  997                    CMD=NIL,
  998                    ECHO(YES='1'B,NO='0'B,ANY)='1'B,
  999                    TEXTC(YES='1'B,NO='0'B,ANY)='1'B,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           28   
 1000                    CP_CMD=NIL);
 1001
 1002      %LSET LISTDIR='0'B;
 1003      %LSET LISTEXP='1'B;
 1004      %LSET LISTCOM='0'B;
 1005      %LSET LISTSUB='1'B;
 1006      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1007      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1008      %LSET INIT=CHARTEXT(' INIT');
 1009      %LSET EINIT=CHARTEXT('');
 1010      %ELSE;
 1011      %LSET INIT=CHARTEXT('/*');
 1012      %LSET EINIT=CHARTEXT('*/');
 1013      %ENDIF;
 1014
 1015      DCL 1 FPTN STCLASS DALIGNED,
 1016            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%EINIT,
 1017                          /*K* NAME = VARIABLE  specifies an area containing a
 1018                          TEXTC string of up to 31 characters, designating
 1019                          the program to which control is to be
 1020                          transferred. The area may be generated by
 1021                          invoking the VLP_NAME macro.
 1022                          This parameter is ignored if the CP_CMD option is specified.
 1023                          Default = NIL.
 1024                          */
 1025            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%EINIT,
 1026                          /*K* ACCT = VARIABLE specifies the location of a TEXT string
 1027                          consisting of eight characters, designating the account
 1028                          from which the program is to be obtained. The
 1029                          area may be generated by invoking the VLP_ACCT
 1030                          macro.
 1031                          This parameter is ignored if the CP_CMD option is specified.
 1032                          The default is NIL.
 1033                          */
 1034            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%EINIT,
 1035                          /*K* PASS = VARIABLE specifies location of a TEXT string of
 1036                          eight characters, designating the password
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           29   
 1037                          associated with the program. The area may be
 1038                          generated by invoking the VLP_PASS macro.
 1039                          This parameter is ignored if the CP_CMD option is specified.
 1040                          The default is NIL.
 1041                          */
 1042            2 PSID_ BIT(72) %INIT(VECTOR(PSID))%EINIT,
 1043                          /*K* PSID = VARIABLE specifies location of a
 1044                          six-character TEXT string, designating the
 1045                          identification of the pack set on which the
 1046                          program is located.
 1047                          This parameter is ignored if the CP_CMD option is specified.
 1048                          The default is NIL.
 1049                          */
 1050            2 CMD_ BIT(72) %INIT(VECTOR(CMD))%EINIT,
 1051                          /*K* CMD = VARIABLE specifies the location
 1052                          containing a string of up to 256 characters that is
 1053                          to be passed in the Control Command Buffer
 1054                          to the called program.  This string may be
 1055                          in either TEXT or TEXTC format as specified by
 1056                          the TEXTC option.
 1057                          This parameter is ignored if the CP_CMD option is specified.
 1058                          If neither the CMD nor CP_CMD option is specified, the TEXT
 1059                          name of the program specified via the NAME option
 1060                          will be moved to the Control Command Buffer.
 1061                          Default = NIL.
 1062                          */
 1063            2 CP_CMD_ BIT(72) %INIT(VECTOR(CP_CMD))%EINIT,
 1064                          /*K* CP_CMD = VARIABLE  specifies the location
 1065                          containing the string of up to 256 characters
 1066                          that is to be placed in the Control Command Buffer
 1067                          and parsed by the associated command processor.
 1068                          This command must be in the standard program invocation
 1069                          format if the program to be put into execution has
 1070                          been linked using the STDINVOC option.
 1071                          In any case, the command must begin with the fid of
 1072                          the requested program.
 1073                          The command may be in either TEXT or TEXTC format
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           30   
 1074                          as specified by the TEXTC option.
 1075
 1076                          When the CP_CMD option is specified, all other options
 1077                          except for TEXTC and ECHO are ignored.
 1078
 1079                          Default = NIL.
 1080                          */
 1081            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%EINIT,
 1082            2 V DALIGNED,
 1083              3 TEXTC# BIT(1) UNAL %INIT(TEXTC)%EINIT,
 1084                          /*K* TEXTC = {YES|NO}   specifies if the command
 1085                          specified via either the CMD or CP_CMD option
 1086                          is in TEXTC (if YES) or TEXT (if NO) format.
 1087                          Default = YES.
 1088                          */
 1089              3 ECHO# BIT(1) UNAL %INIT(ECHO)%EINIT,
 1090                          /*K* ECHO = {YES|NO}  specifies, if yes, that the
 1091                          command specified via the CP_CMD parameter is to
 1092                          be echoed through the M$LL DCB.
 1093                          This option is ignored if echoing has previously
 1094                          been inhibited by the DONT ECHO command.
 1095                          The default is YES.
 1096                          */
 1097              3 * BIT(34) UNAL %INIT('0'B)%EINIT,
 1098              3 * BIT(36) UNAL %INIT('0'B)%EINIT;
 1099      %MEND;
 1100
 1101
 1102
 1103
 1104                          /*F* NAME: M$LDTRC - Load and Transfer to Program
 1105
 1106                          The M$LDTRC monitor service causes the calling
 1107                          program's memory (procedure, program
 1108                          data and data segments - except the common
 1109                          segment) to be released making the calling
 1110                          program's memory available for the called program.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           31   
 1111                          The called program is then loaded into
 1112                          memory and control is transferred to it.
 1113                          There is no return to the calling program.
 1114
 1115                          If Exit Control has been established in the
 1116                          calling program, the issuing of an M$LDTRC
 1117                          will cause control to be passed to the
 1118                          effective Exit Control procedure.  The M$LDTRC
 1119                          occurs on exit from the Exit Control procedure, via
 1120                          M$EXIT or M$TRTN.
 1121
 1122                          If an Alternate Shared Library is associated
 1123                          with the user program, control is transferred
 1124                          to the ASL exit control procedure (if any).  The
 1125                          ASL is disassociated from the user as part of
 1126                          the M$LDTRC process.
 1127
 1128                          M$LDTRC may only be issued from the user domain.
 1129                          Standard shared processors may use M$LDTRC;
 1130                          special shared processors may not.
 1131
 1132                          The program to be put into execution may be specified
 1133                          either by using the CP_CMD option or by using the
 1134                          NAME, ACCT, PASS, and PSID options.  The choice of
 1135                          which to use will depend on whether the calling program
 1136                          wishes to convey DCB assignment information over the
 1137                          M$LDTRC process.
 1138
 1139                          If the CP_CMD option is used, the command processor
 1140                          will parse the command line and build the assign merge
 1141                          records as specified if the command is presented in standard
 1142                          syntax.  When the linked to program is entered
 1143                          the SI, UI, OU, LS and NSSYNTAX bits in B$JIT.PRFLAGS
 1144                          will be set accordingly.
 1145
 1146                          If the NAME, ACCT, PASS, PSID, and CMD options are used,
 1147                          the command will not be parsed by the command processor.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           32   
 1148                          NSSYNTAX bit will be reset in B$JIT.PRFLAGS; the NOSCAN bit will
 1149                          be set in B$JIT.PRFLAGS.  If the requested run unit was built
 1150                          with the STDINVOC option, that run unit will not be put into
 1151                          execution and the job step will be aborted.
 1152
 1153                          The called program
 1154                          may determine that it has been entered via M$LDTRC
 1155                          as the value of B$JIT.PROG_ENTRY will have been
 1156                          set to %PE_LDTRC#.
 1157
 1158                          If a debugger is associated with the user,
 1159                          the debugger will also be associated with the
 1160                          called program, unless that program is execute
 1161                          only.
 1162
 1163                          The M$LDTRC process requires up to 118 words in the
 1164                          user's TCB under any of the following conditions:
 1165
 1166                            o  Exit control has been established.
 1167
 1168                            o  An ASL is associated.
 1169
 1170                            o  The user program is executing under DELTA.
 1171
 1172                          If none of these conditions exist, there is
 1173                          no TCB requirement.
 1174
 1175                          If the called program is not found or an I/O
 1176                          error occurs in executing the LDTRC routine, the
 1177                          job is aborted.
 1178
 1179                          The form of the call for this service is:
 1180
 1181                          CALL M$LDTRC (FPT_LDTRC) [ALTRET (label)];
 1182
 1183                          The parameters for this service are as follows:                               */
 1184
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           33   
 1185
 1186      %MACRO FPT_LDTRC(FPTN=FPT_LDTRC,
 1187                     STCLASS=STATIC,
 1188                     NAME=NIL,
 1189                     ACCT=NIL,
 1190                     PASS=NIL,
 1191                     PSID=NIL,
 1192                     CMD=NIL,
 1193                    ECHO(YES='1'B,NO='0'B,ANY)='0'B,
 1194                     TEXTC(YES='1'B,NO='0'B,ANY)='1'B,
 1195                     CP_CMD=NIL);
 1196
 1197      %LSET LISTDIR='0'B;
 1198      %LSET LISTEXP='1'B;
 1199      %LSET LISTCOM='0'B;
 1200      %LSET LISTSUB='1'B;
 1201      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1202      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1203      %LSET INIT=CHARTEXT(' INIT');
 1204      %LSET EINIT=CHARTEXT('');
 1205      %ELSE;
 1206      %LSET INIT=CHARTEXT('/*');
 1207      %LSET EINIT=CHARTEXT('*/');
 1208      %ENDIF;
 1209
 1210
 1211      DCL 1 FPTN STCLASS DALIGNED,
 1212            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%EINIT,
 1213                          /*K* NAME = VARIABLE  specifies an area containing a
 1214                          TEXTC string consisting of up to 31 characters, designating the
 1215                          program to which control is to be transferred.
 1216                          The area may be generated by invoking the
 1217                          VLP_NAME macro.
 1218                          This parameter is ignored if the CP_CMD option is specified.
 1219                          The default is NIL.
 1220                          */
 1221            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%EINIT,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           34   
 1222                          /*K* ACCT = VARIABLE specifies an area containing a
 1223                          TEXT string consisting of eight characters, designating the
 1224                          account from which the program is to be
 1225                          obtained. The area may be generated by invoking
 1226                          the VLP_ACCT macro.
 1227                          This parameter is ignored if the CP_CMD option is specified.
 1228                          The default is NIL.
 1229                          */
 1230            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%EINIT,
 1231                          /*K* PASS = VARIABLE  Specifies the location of a string consisting of
 1232                          eight characters, designating the password
 1233                          associated with the program.  The area may be
 1234                          generated by invoking the VLP_PASS macro.
 1235                          This parameter is ignored if the CP_CMD option is specified.
 1236                          The default is NIL.
 1237                          */
 1238            2 PSID_ BIT(72) %INIT(VECTOR(PSID))%EINIT,
 1239                          /*K* PSID = VARIABLE  Specifies the location of a
 1240                          6-character string designating the
 1241                          identification of the pack set on which the
 1242                          program is located.
 1243                          This parameter is ignored if the CP_CMD option is specified.
 1244                          The default is NIL.
 1245                          */
 1246            2 CMD_ BIT(72) %INIT(VECTOR(CMD))%EINIT,
 1247                          /*K* CMD = VARIABLE specifies the location
 1248                          containing a string of up to 256 characters that is
 1249                          to be passed in the Control Command Buffer
 1250                          to the called program.  This string may be
 1251                          in either TEXT or TEXTC format as specified by
 1252                          the TEXTC option.
 1253                          This parameter is ignored if the CP_CMD option is specified.
 1254                          If neither the CMD nor CP_CMD option is specified, the TEXT
 1255                          name of the program specified via the NAME option
 1256                          will be moved to the Control Command Buffer.
 1257                          The default is NIL.
 1258                          */
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           35   
 1259            2 CP_CMD_ BIT(72) %INIT(VECTOR(CP_CMD))%EINIT,
 1260                          /*K* CP_CMD = VARIABLE  specifies the location
 1261                          containing the string of up to 256 characters
 1262                          that is to be placed in the Control Command Buffer
 1263                          and parsed by the associated command processor.
 1264                          This command must be in the standard program invocation
 1265                          format if the program to be put into execution has
 1266                          been linked using the STDINVOC option.
 1267                          In any case, the command must begin with the fid of
 1268                          the requested program.
 1269                          The command may be in either TEXT or TEXTC format
 1270                          as specified by the TEXTC option.
 1271
 1272                          When the CP_CMD option is specified, all other options
 1273                          except for TEXTC and ECHO are ignored.
 1274
 1275                          Default = NIL.
 1276                          */
 1277            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%EINIT,
 1278            2 V DALIGNED,
 1279              3 TEXTC# BIT(1) UNAL %INIT(TEXTC)%EINIT,
 1280                          /*K* TEXTC = {YES|NO}   specifies if the command
 1281                          specified via either the CMD or CP_CMD option
 1282                          is in TEXTC (if YES) or TEXT (if NO) format.
 1283                          Default = YES.
 1284                          */
 1285              3 ECHO# BIT(1) UNAL %INIT(ECHO)%EINIT,
 1286                          /*K* ECHO = {YES|NO}  specifies, if yes, that the
 1287                          command specified via the CP_CMD parameter is to
 1288                          be echoed through the M$LL DCB.
 1289                          This option is ignored if echoing has previously
 1290                          been inhibited by the DONT ECHO command.
 1291                          The default is NO.
 1292                          */
 1293              3 * BIT(34) UNAL %INIT('0'B)%EINIT,
 1294              3 * BIT(36) UNAL %INIT('0'B)%EINIT;
 1295      %MEND;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           36   
 1296
 1297
 1298
 1299                          /*F* NAME: M$ALIB - Associate Library/Processor.
 1300
 1301                          In addition to the options provided by the linker
 1302                          to associate shared libraries and Alternate Shared
 1303                          Libraries, the monitor provides the capability to
 1304                          associate or disassociate these libraries and also
 1305                          debuggers at run-time.
 1306
 1307                          The M$ALIB service allows a user program to
 1308                          control the association of a shared library,
 1309                          Alternate Shared Library or a debugger with his
 1310                          user program.
 1311
 1312                          If the processor to be associated is a shared
 1313                          library and requires disassociation of the current
 1314                          library, both association and disassociation will
 1315                          take place and the alternate return is taken.  If
 1316                          ALTRET is not specified, the condition is ignored.
 1317                          Note, however, that if the processor to
 1318                          be associated is an Alternate
 1319                          Shared Library or a debugger and a different
 1320                          processor of the same type is currently
 1321                          associated, the alternate return is taken.  If
 1322                          ALTRET is not specified, the program is errored.
 1323
 1324                          If a debugger is to be associated, the M$ALIB FPT
 1325                          may specify a command to be passed to the
 1326                          debugger.  DELTA's interface with M$ALIB is
 1327                          described in the DELTA reference manual.
 1328
 1329                          If a processor with the specified name cannot be
 1330                          found or if either virtual memory or physical
 1331                          memory is not available, the M$ALIB ALTRET code
 1332                          sequence is entered.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           37   
 1333
 1334                          The form of the call for this service is:
 1335
 1336                          CALL M$ALIB (FPT_ALIB) [ALTRET (label)];
 1337
 1338                          The parameters for this service are as follows:                               */
 1339
 1340
 1341      %MACRO FPT_ALIB (FPTN=FPT_ALIB,
 1342                    STCLASS=STATIC,
 1343                    LIBNAME=NIL,
 1344                   CMD=NIL,
 1345                   REPLY=NIL,
 1346                   ECHO(YES='1'B,NO='0'B)='0'B,
 1347                   QUIET(YES='1'B,NO='0'B)='0'B,
 1348                   NOSCAN(YES='1'B,NO='0'B)='0'B,
 1349                   RETRN(YES='1'B,NO='0'B)='1'B,
 1350                   DLIB(YES='1'B,NO='0'B)='0'B);
 1351
 1352      %LSET LISTDIR='0'B;
 1353      %LSET LISTEXP='1'B;
 1354      %LSET LISTCOM='0'B;
 1355      %LSET LISTSUB='1'B;
 1356      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1357      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1358       (SUBSTR(STR,0,8)='CONSTANT') OR
 1359       (SUBSTR(STR,0,3)='EXT');
 1360       %LSET INIT=CHARTEXT('INIT');
 1361      %ELSE;
 1362       %LSET INIT=CHARTEXT('/*');
 1363      %ENDIF;
 1364
 1365
 1366      DCL 1 FPTN STCLASS DALIGNED,
 1367            2 LIBNAME_ BIT(72) %INIT(VECTOR(LIBNAME))%CHARTEXT('/**/'), /*TEXTC LIBRARY NAME            */
 1368                          /*K* LIBNAME = VARIABLE   locates an area containing
 1369                          the TEXTC run-unit name of the processor or library to
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           38   
 1370                          be associated.  This area can be generated by
 1371                          invoking the VLP_NAME macro.  The default is NIL.                             */
 1372            2 CMD_ BIT(72) %INIT(VECTOR(CMD))%CHARTEXT('/**/'), /*COMMAND TO PASS TO DEBUGGER           */
 1373                          /*K* CMD = VARIABLE specifies the area containing a
 1374                          TEXT command to be passed to the debugger.  This option
 1375                          is ignored if associating a shared library or Alternate
 1376                          Shared Library.
 1377                          */
 1378            2 REPLY_ BIT(72) %INIT(VECTOR(REPLY))%CHARTEXT('/**/'),
 1379                          /*K* REPLY = VARIABLE  locates an area into which the
 1380                          debugger may store a reply to some special commands.
 1381                          This option is ignored if associating a shared
 1382                          library or Alternate Shared Library.
 1383                          */
 1384            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1385            2 V DALIGNED,
 1386              3 RETRN# BIT(1) UNAL %INIT(RETRN)%CHARTEXT('/**/'),
 1387                          /*K* RETRN  =  {YES|NO}  specifies, if YES,
 1388                          that the debugger
 1389                          is to return to the user after processing the single
 1390                          command that has been specified via the CMD parameter.
 1391                          The default is YES.
 1392
 1393                          This option is ignored if the M$ALIB request is to associate
 1394                          a shared library or an Alternate Shared Library.
 1395                          */
 1396              3 DLIB# BIT(1) UNAL %INIT(DLIB)%CHARTEXT('/**/'),
 1397                          /*K* DLIB =  {YES|NO}   specifies, if YES,
 1398                          that the debugger
 1399                          is to be disassociated from the user after processing the
 1400                          command that has been specified via the CMD parameter.
 1401                          This option is ignored if the program making
 1402                          the request is executing under control of the
 1403                          debugger; (i.e., the program was started under
 1404                          control of the debugger or the debugger was
 1405                          invoked via the Command Processor).  The default is NO.
 1406
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           39   
 1407                          This option is ignored if the M$ALIB request is to associate
 1408                          a shared library or an Alternate Shared Library.
 1409                          */
 1410
 1411              3 NOSCAN# BIT(1) UNAL %INIT(NOSCAN)%CHARTEXT('/**/'),
 1412              3 ECHO# BIT(1) UNAL %INIT(ECHO)%CHARTEXT('/**/'), /* ECHO FLAG                            */
 1413                          /*K* ECHO =  {YES|NO}   specifies, if YES, that the
 1414                          command specified via the CMD parameter is to
 1415                          be echoed through the M$DO DCB.  The default is NO.
 1416
 1417                          This option is ignored if the M$ALIB request is to associate
 1418                          a shared library or an Alternate Shared Library.
 1419                          */
 1420              3 QUIET# BIT(1) UNAL %INIT(QUIET)%CHARTEXT('/**/'),
 1421                          /*K*  QUIET = {YES|NO}  specifies, if YES, that the
 1422                           debugger is to write only error messages to the user.
 1423                           The default is NO.
 1424
 1425                           This option is ignored if the M$ALIB request is to associate
 1426                           a shared library or an Alternate Shared Library.
 1427                           */
 1428              3 * BIT(31) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1429              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1430      %MEND;
 1431
 1432
 1433
 1434                          /*F* NAME: M$DLIB - Disassociate Library/Processor
 1435
 1436                          The M$DLIB service allows a user program to
 1437                          disassociate a shared library, alternate shared
 1438                          library or a debugger.
 1439
 1440                          If the processor to be disassociated is an
 1441                          alternate shared library or a debugger and that
 1442                          processor has established exit control, the
 1443                          processor's exit control logic will be entered.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           40   
 1444                          Should the processor exit his exit control logic
 1445                          other than via M$EXIT, the M$DLIB ALTRET code
 1446                          sequence is entered with the TCB frame containing an
 1447                          error code set to reflect the processor's exit
 1448                          condition. Note, however, that the processor will
 1449                          have been disassociated.
 1450
 1451                          If the processor to be disassociated is a
 1452                          debugger and the program making the request is
 1453                          executing under control of that debugger, i.e.
 1454                          the program was started under control of the
 1455                          debugger or the debugger was invoked via the
 1456                          Command Processor, the disassociation will not
 1457                          take place.  DELTA's interface with M$DLIB is
 1458                          described in detail in the "Operational Considerations"
 1459                          appendix to the DELTA reference manual.
 1460
 1461                          If a processor with the specified name cannot be
 1462                          found or if the specified processor is not
 1463                          currently associated, the M$DLIB ALTRET code
 1464                          sequence is entered.
 1465
 1466                          The form of the call for this service is:
 1467
 1468                          CALL M$DLIB (FPT_DLIB) [ALTRET (label)];
 1469
 1470                          The parameter for this service is as follows:                                 */
 1471
 1472
 1473      %MACRO FPT_DLIB (FPTN=FPT_DLIB,
 1474                    STCLASS=STATIC,
 1475                    LIBNAME=NIL);
 1476
 1477      %LSET LISTDIR='0'B;
 1478      %LSET LISTEXP='1'B;
 1479      %LSET LISTCOM='0'B;
 1480      %LSET LISTSUB='1'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           41   
 1481      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1482      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1483       (SUBSTR(STR,0,8)='CONSTANT') OR
 1484       (SUBSTR(STR,0,3)='EXT');
 1485       %LSET INIT=CHARTEXT('INIT');
 1486      %ELSE;
 1487       %LSET INIT=CHARTEXT('/*');
 1488      %ENDIF;
 1489
 1490
 1491      DCL 1 FPTN STCLASS DALIGNED,
 1492            2 LIBNAME_ BIT(72) %INIT(VECTOR(LIBNAME))%CHARTEXT('/**/'); /*TEXTC LIBRARY NAME            */
 1493                          /*K* LIBNAME = VARIABLE locates an area containing a
 1494                          TEXTC string designating the processor to be
 1495                          disassociated. This area can be generated by
 1496                          invoking the VLP_NAME macro. The default is NIL.                              */
 1497      %MEND;
 1498
 1499
 1500                          /*F* NAME: M$PROCNAME - Return Processor Names
 1501
 1502                          The M$PROCNAME service returns the names of the Shared
 1503                          Processors associated with the program in execution.
 1504
 1505                          Each parameter for this service locates a VARIABLE where
 1506                          the TEXTC name of a processor is to be returned to the
 1507                          user.  If no processor of a given type is associated,
 1508                          the byte count field of this TEXTC area is set to zero
 1509                          and the text is set to all blanks.
 1510
 1511                          The VLP_NAME macro may be used to generate this
 1512                          area.  The size must be large enough to contain the
 1513                          full 31 character name.
 1514
 1515                          The form of the call for this service is:
 1516
 1517                          CALL M$PROCNAME (FPT_PROCNAME) [ALTRET(label)];
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           42   
 1518
 1519                          The parameters are as follows:
 1520                          */
 1521
 1522      %MACRO FPT_PROCNAME (FPTN=FPT_PROCNAME,
 1523                           STCLASS=STATIC,
 1524                           SHAREPROC=NIL,
 1525                           SHARELIB=NIL,
 1526                           ASL=NIL,
 1527                           DB=NIL,
 1528                           CP=NIL);
 1529
 1530      %LSET LISTDIR='0'B;
 1531      %LSET LISTEXP='1'B;
 1532      %LSET LISTCOM='0'B;
 1533      %LSET LISTSUB='1'B;
 1534      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1535      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1536       (SUBSTR(STR,0,8)='CONSTANT') OR
 1537       (SUBSTR(STR,0,3)='EXT');
 1538       %LSET INIT=CHARTEXT('INIT');
 1539      %ELSE;
 1540       %LSET INIT=CHARTEXT('/*');
 1541      %ENDIF;
 1542
 1543      DCL 1 FPTN STCLASS DALIGNED,
 1544            2 SHAREPROC_ BIT(72) %INIT(VECTOR(SHAREPROC))%CHARTEXT('/**/'),
 1545                          /*K* SHAREPROC = VARIABLE.  Locates the area where
 1546                          the TEXTC name of the associated Standard Processor
 1547                          is to be returned.  The default is NIL.
 1548                          */
 1549            2 SHARELIB_ BIT(72) %INIT(VECTOR(SHARELIB))%CHARTEXT('/**/'),
 1550                          /*K* SHARELIB = VARIABLE.  Locates the area where
 1551                          the TEXTC name of the associated Shared Library is
 1552                          to be returned.  The default is NIL.
 1553                          */
 1554            2 ASL_ BIT(72) %INIT(VECTOR(ASL))%CHARTEXT('/**/'),
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           43   
 1555                          /*K* ASL = VARIABLE.  Locates the area where the TEXTC
 1556                          name of the associated Alternate Shared Library is
 1557                          to be returned.  The default is NIL.
 1558                          */
 1559            2 DB_ BIT(72) %INIT(VECTOR(DB))%CHARTEXT('/**/'),
 1560                          /*K* DB = VARIABLE.  Locates the area where the TEXTC
 1561                          name of the associated Interactive Debugger is to be
 1562                          returned.  The default is NIL.
 1563                          */
 1564            2 CP_ BIT(72) %INIT(VECTOR(CP))%CHARTEXT('/**/');
 1565                          /*K* CP = VARIABLE.  Locates the area where the TEXTC
 1566                          name of the associated Interactive Command Processor is
 1567                          to be returned.  The default is NIL.
 1568                          */
 1569      %MEND;
 1570
 1571
 1572                          /*F* NAME: M$FINDPROC - Find Shared Processor
 1573
 1574                          The M$FINDPROC service allows a program
 1575                          to either:
 1576
 1577                          1.  Determine a processor number and/or processor
 1578                              type given a processor name.
 1579
 1580                          2.  Determine a processor name given the processor
 1581                              number, and optionally determine the type.
 1582
 1583                          The function that is performed is determined by the
 1584                          contents of the NAME parameter.
 1585
 1586                          The form of the call for this service is:
 1587
 1588                          CALL M$FINDPROC (FPT_FINDPROC) [ALTRET (label)];
 1589
 1590                          The parameters for this service are as follows:
 1591                          */
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           44   
 1592
 1593      %MACRO FPT_FINDPROC(FPTN=FPT_FINDPROC,
 1594                      STCLASS=STATIC,
 1595                      RTYPE=NIL,
 1596                      NAME=NIL,
 1597                      ACCT=NIL,
 1598                      PNUM=NIL,
 1599                      MLINK(YES='1'B,
 1600                            NO='0'B)
 1601                            ='0'B,
 1602                      PTYPE(P_SP='040000'O,
 1603                            P_LIB='100000'O,
 1604                            P_ASL='200000'O,
 1605                            P_DB='020000'O,
 1606                            P_CP='400000'O)
 1607                            ='000000'O);
 1608
 1609      %LSET LISTDIR='0'B;
 1610      %LSET LISTEXP='1'B;
 1611      %LSET LISTCOM='0'B;
 1612      %LSET LISTSUB='1'B;
 1613      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1614      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1615       (SUBSTR(STR,0,8)='CONSTANT') OR
 1616       (SUBSTR(STR,0,3)='EXT');
 1617       %LSET INIT=CHARTEXT('INIT');
 1618      %ELSE;
 1619       %LSET INIT=CHARTEXT('/*');
 1620      %ENDIF;
 1621
 1622
 1623      DCL 1 FPTN STCLASS DALIGNED,
 1624            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1625            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'), /* NAME (TEXTC) OF RUN UNIT           */
 1626                          /*K* NAME = VARIABLE  specifies the location of a TEXTC string
 1627                          of up to 31 characters, designating the name of the
 1628                          shared processor.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           45   
 1629
 1630                          If the length byte in this TEXTC location is non-zero,
 1631                          the shared processor tables will be searched for a
 1632                          processor from the account specified by the
 1633                          ACCT parameter.
 1634                          If a shared processor of this name
 1635                          cannot be found in the system shared processor tables
 1636                          the ALTRET routine will be entered.
 1637
 1638                          If the length byte in this TEXTC field is zero, the
 1639                          name of the processor specified by the PNUM parameter
 1640                          will be returned in this location.
 1641
 1642                          The default is NIL.
 1643                                                                                       */
 1644            2 RTYPE_ BIT(72) %INIT(VECTOR(RTYPE))%CHARTEXT('/**/'),
 1645                          /*K* RTYPE = VARIABLE specifies the location of an
 1646                          area where the processor type may optionally be returned.
 1647                          This area may be generated using the VLR_RTYPE macro.
 1648                          The bit strings for the processor type are defined in
 1649                          the file CP_6_SUBS.  The default is NIL.
 1650                          */
 1651            2 PNUM_ VECTOR %INIT(VECTOR(PNUM))%CHARTEXT('/**/'),
 1652                          /*K* PNUM = VARIABLE  specifies the location of an area that
 1653                          contains the processor number of the processor whose name is
 1654                          to be returned in the area specified via the NAME option.
 1655
 1656                          If this is a request to determine the processor type, the processor
 1657                          number will be returned here if this parameter is not NIL.
 1658
 1659                          This area should be defined as UBIN(9) DALIGNED.
 1660
 1661                          Default = NIL.
 1662                          */
 1663            2 ACCT_ VECTOR %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 1664                          /*K* ACCT = VARIABLE  specifies the location of an
 1665                          area containing 8 TEXT characters, designating the
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           46   
 1666                          account of the shared processor.
 1667
 1668                          If the call to M$FINDPROC was to search the shared processor
 1669                          tables for the processor specified by the NAME parameter, this
 1670                          ACCT parameter may be used to qualify NAME.  If the ACCT
 1671                          parameter is omitted, :SYS will be assumed.
 1672
 1673                          If the call to M$FINDPROC was to return the processor name of
 1674                          the processor specified by the PNUM parameter, the account will
 1675                          be returned in the area specified by ACCT.
 1676
 1677                          The default is NIL.
 1678                          */
 1679            2 V DALIGNED,
 1680              3 PTYPE# BIT(18) UNAL %INIT(PTYPE)%CHARTEXT('/**/'),
 1681                          /*K* PTYPE = OPTION specifies the processor
 1682                          type as follows:
 1683                          TU
 1684
 1685                             P_SP  - Standard Shared Processor
 1686                             P_LIB - Run-time Library
 1687                             P_ASL - Alternate Shared Library
 1688                             P_DB  - Debugger
 1689                             P_CP  - Command Processor
 1690
 1691                          TF
 1692                          If a shared processor of the name or number specified is found
 1693                          but is not of the type specified, the ALTRET routine
 1694                          is entered.  If this parameter is not specified, no
 1695                          check is made of the processor type;  this is the
 1696                          default.
 1697                               */
 1698              3 MLINK# BIT(1) UNAL %INIT(MLINK)%CHARTEXT('/**/'),
 1699                          /*K* MLINK = {YES|NO}  YES specifies that the search
 1700                          is to take place in the M$LINK history to see
 1701                          if the desired processor is in the call path.
 1702                          MLINK=NO indicates that the search is to take
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           47   
 1703                          in the installed system.
 1704
 1705                          NO is the default.
 1706                               */
 1707              3 * BIT(17) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1708              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1709      %MEND;
 1710
 1711                          /*F* NAME: VLR_RTYPE
 1712
 1713                          The VLR_RTYPE macro generates an 18-bit area which receives
 1714                          the processor type as a result of a call to M$FINDPROC.
 1715                          For the processor types that may be returned, see the
 1716                          PTYPE parameter of M$FINDPROC.
 1717                          */
 1718
 1719      %MACRO VLR_RTYPE (FPTN=VLR_RTYPE,
 1720                         STCLASS=STATIC);
 1721
 1722
 1723      DCL 1 FPTN STCLASS BIT(18) DALIGNED;
 1724
 1725      %MEND;
 1726
 1727
 1728                          /*F* NAME: M$UNSHARE - Unshare Library or Program
 1729
 1730                          The M$UNSHARE service allows the user to unshare
 1731                          a program if it is currently being shared. The
 1732                          FPT will specify if the program or the shared library
 1733                          is to be unshared.
 1734
 1735                          The form of the call for this service is:
 1736
 1737                          CALL M$UNSHARE (FPT_UNSHARE) [ALTRET (label)];
 1738
 1739                          The parameters for this service are as follows:                               */
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           48   
 1740
 1741
 1742      %MACRO FPT_UNSHARE(FPTN=FPT_UNSHARE,
 1743                     STCLASS=STATIC,
 1744                     PROG(YES='1'B,NO='0'B)='0'B,
 1745                     LIB(YES='1'B,NO='0'B)='0'B);
 1746
 1747      %LSET LISTDIR='0'B;
 1748      %LSET LISTEXP='1'B;
 1749      %LSET LISTCOM='0'B;
 1750      %LSET LISTSUB='1'B;
 1751      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1752      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1753       (SUBSTR(STR,0,8)='CONSTANT') OR
 1754       (SUBSTR(STR,0,3)='EXT');
 1755       %LSET INIT=CHARTEXT('INIT');
 1756      %ELSE;
 1757       %LSET INIT=CHARTEXT('/*');
 1758      %ENDIF;
 1759
 1760
 1761      DCL 1 FPTN STCLASS DALIGNED,
 1762            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1763            2 V DALIGNED,
 1764              3 FLGS,
 1765                4 * BIT(7) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1766                4 PROG# BIT(1) UNAL %INIT(PROG)%CHARTEXT('/**/'),
 1767                          /*K* PROG = {YES|NO}  specifies, if YES, that the
 1768                          current running program is to be unshared.
 1769                          The default is NO.                                                            */
 1770                4 LIB# BIT(1) UNAL %INIT(LIB)%CHARTEXT('/**/'),
 1771                          /*K* LIB = {YES|NO}  Indicates if the currently
 1772                          associated shared library is to be unshared.
 1773                          The default is NO.                                                            */
 1774              3 * UBIN(27) UNAL %INIT(0)%CHARTEXT('/**/'),
 1775              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1776      %MEND;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           49   
 1777
 1778
 1779
 1780
 1781
 1782
 1783                          /*F* NAME: Special Services.
 1784
 1785                          The monitor services in this section are intended
 1786                          for use solely by the advanced system programmer and
 1787                          therefore, they are restricted.  In many cases, the
 1788                          user must have special privileges before these
 1789                          services can be executed within the user domain.
 1790                          */
 1791
 1792
 1793
 1794                          /*F* NAME: M$FSUSER - Find Suspended User
 1795
 1796                          This monitor procedure is available only to the
 1797                          host log-on processor for the purpose of finding
 1798                          whether or not a newly logged-on user has a
 1799                          suspended program as a result of an earlier line
 1800                          disconnect.
 1801
 1802                          M$FSUSER returns normally if a suspended
 1803                          program was found for the current user;
 1804                          otherwise it takes the alternate return.
 1805
 1806                          The form of the call for this service is:
 1807
 1808                          CALL M$FSUSER [ALTRET (label)];
 1809
 1810                          There is no FPT for M$FSUSER.  This service obtains the
 1811                          user's account and name from the JIT.                                         */
 1812
 1813
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           50   
 1814
 1815
 1816
 1817
 1818                          /*F* NAME: M$ASUSER - Associate Suspended User
 1819
 1820                          This monitor routine is available only to the host
 1821                          log-on processor for the purpose of associating a
 1822                          newly logged-on user with a suspended program
 1823                          saved as a result of an earlier line disconnect.
 1824                          It is intended to be used following a successful
 1825                          return from M$FSUSER.
 1826
 1827                          M$ASUSER, upon finding the user's suspended program,
 1828                          "attaches" it to the communication line owned by the
 1829                          newly logged on user and awakens the program.  After
 1830                          the user is reconnected to the saved program, the
 1831                          skeletal user program formed to accomplish the new
 1832                          log-on is disconnected from any communication line.
 1833                          Thus, upon a successful return from M$ASUSER, the user
 1834                          will be communicating with his previously saved program.
 1835
 1836                          In the unlikely event that the user's suspended
 1837                          program timed out between the time the M$FSUSER
 1838                          and M$ASUSER calls were made, the alternate
 1839                          return is taken.
 1840
 1841                          The form of the call for this service is:
 1842
 1843                          CALL M$ASUSER [ALTRET (label)];
 1844
 1845                          There is no FPT for M$ASUSER.  This service obtains the
 1846                          user's account and name from the JIT, and assumes that
 1847                          the M$UC DCB is open.                                                         */
 1848
 1849
 1850
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           51   
 1851
 1852
 1853
 1854                          /*F* NAME: M$DSUSER - Delete Suspended User
 1855
 1856                          This monitor routine is available only to the host
 1857                          log-on processor for the purpose of deleting the current
 1858                          user's suspended program.  In the event that a
 1859                          suspended program for the user does not exist, the
 1860                          alternate return is taken.
 1861
 1862                          The form of the call for this service is:
 1863
 1864                          CALL M$DSUSER [ALTRET(label)];
 1865
 1866                          There is no FPT for M$DSUSER.  This service obtains the
 1867                          user's account and name from the JIT.                                         */
 1868
 1869
 1870
 1871
 1872
 1873
 1874                          /*F* NAME: Program_Save
 1875
 1876                          The monitor provides facilities to interrupt
 1877                          program execution, save the program image,
 1878                          later restore it, and restart program execution.
 1879                          The SAVE/GET facilities save and restore the
 1880                          essential portions of the user's work space (as
 1881                          discussed in detail later). The SAVE process is
 1882                          available via the M$SAVE monitor service or the
 1883                          IBEX SAVE command. The GET process is performed
 1884                          via the IBEX GET command.
 1885
 1886                          The SAVE/GET facility provides these optional
 1887                          features:
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           52   
 1888
 1889                            o  The user program may request that its exit
 1890                               control procedure receive control prior to
 1891                               the SAVE, to do cleanup and its own
 1892                               checkpointing.  (See M$SCON with XCON=YES.)
 1893
 1894                            o  If the preceding feature is used, at a GET
 1895                               command the program is restarted at its exit
 1896                               control procedure with a code indicating that a
 1897                               GET occurred.  The exit control procedure can
 1898                               restore any checkpoint data prior to resuming
 1899                               execution at the point of interruption.
 1900
 1901                            o  The user program may save itself at
 1902                               appropriate points by calling M$SAVE and
 1903                               continue execution.
 1904
 1905                            o  The user program may prevent program SAVEs by
 1906                               calling M$SCON with SAVEFLG=NO.
 1907
 1908                          The M$SAVE and M$SCON services and also the GET
 1909                          process are discussed next. The IBEX SAVE and GET
 1910                          commands are discussed in the CP-6 Programmer
 1911                          Reference Manual.                                                             */
 1912
 1913                          /*F* NAME: M$SAVE - Save Program
 1914
 1915                          The M$SAVE service interrupts program execution
 1916                          and optionally gives control to the user's exit
 1917                          control procedure before the program image is saved.
 1918                          The contents of the SAVE file are discussed later
 1919                          in this section.
 1920
 1921                          NOTE: The M$SAVE service may be called by the
 1922                          user program only, not by special shared
 1923                          processors. However, if an Alternate Shared
 1924                          Library is associated with the user program,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           53   
 1925                          control is transferred to the ASL exit control
 1926                          routine (if any) prior to the SAVE. The ASL is
 1927                          disassociated from the user program as a part of
 1928                          the SAVE process.
 1929
 1930                          The SAVE process requires 87 words in the user's
 1931                          TCB under any of the following conditions:
 1932
 1933                          o  Exit Control for SAVE is requested.
 1934
 1935                          o  An ASL is associated.
 1936
 1937                          o  The program is executing under DELTA.
 1938
 1939                          If none of these conditions exist there is no
 1940                          TCB requirement.
 1941
 1942                          When the SAVE occurs without entry to the user's
 1943                          exit control procedure, execution will
 1944                          resume at the point of interruption. More detail
 1945                          on SAVE with entry to the user's exit control
 1946                          procedure is included below.
 1947
 1948                          If a SAVE is attempted and the user previously
 1949                          called the M$SCON service with SAVEFLG=NO, the
 1950                          alternate return is taken from M$SAVE. If the
 1951                          user requested exit control before the SAVE and
 1952                          the TCB is full, the alternate return is taken
 1953                          from M$SAVE.
 1954
 1955                          The form of the call for this service is:
 1956
 1957                          CALL M$SAVE (FPT_SAVE) [ALTRET (label)];
 1958
 1959                          The parameters for this service are:                                          */
 1960
 1961
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           54   
 1962      %MACRO FPT_SAVE(FPTN=FPT_SAVE,
 1963                    STCLASS=STATIC,
 1964                    NAME=NIL,
 1965                    ACCT=NIL,
 1966                    PASS=NIL,
 1967                    PSID=NIL);
 1968
 1969      %LSET LISTDIR='0'B;
 1970      %LSET LISTEXP='1'B;
 1971      %LSET LISTCOM='0'B;
 1972      %LSET LISTSUB='1'B;
 1973      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1974      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1975       (SUBSTR(STR,0,8)='CONSTANT') OR
 1976       (SUBSTR(STR,0,3)='EXT');
 1977       %LSET INIT=CHARTEXT('INIT');
 1978      %ELSE;
 1979       %LSET INIT=CHARTEXT('/*');
 1980      %ENDIF;
 1981
 1982      DCL 1 FPTN STCLASS DALIGNED,
 1983            2 NAME_ BIT(72) %INIT(VECTOR(NAME))%CHARTEXT('/**/'),
 1984                          /*K* NAME = VARIABLE   specifies an area containing a
 1985                          TEXTC string consisting of up to 31 characters, designating the
 1986                          name of the SAVE file to be created. This area
 1987                          may be generated by invoking the VLP_NAME macro.
 1988                          The default is NIL.                                                           */
 1989            2 ACCT_ BIT(72) %INIT(VECTOR(ACCT))%CHARTEXT('/**/'),
 1990                          /*K* ACCT = VARIABLE specifies location of a TEXT string consisting
 1991                          of eight characters, designating the account
 1992                          in which the SAVE file is to be created. This
 1993                          area may be generated by invoking the VLP_ACCT
 1994                          macro.  The default is NIL.                                                   */
 1995            2 PASS_ BIT(72) %INIT(VECTOR(PASS))%CHARTEXT('/**/'),
 1996                          /*K* PASS = VARIABLE specifies location of a TEXT string consisting
 1997                          of eight characters, designating the password
 1998                          associated with the SAVE file. This area may be
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           55   
 1999                          generated by invoking the VLP_PASS macro.
 2000                                                                                       */
 2001            2 PSID_ BIT(72) %INIT(VECTOR(PSID))%CHARTEXT('/**/');
 2002                          /*K* PSID = VARIABLE specifies location of a TEXT string consisting
 2003                          of six characters, designating the identification of
 2004                          the packset on which the SAVE file is to be
 2005                          located.  The default is NIL.                                                 */
 2006
 2007      %MEND;
 2008
 2009
 2010                          /*F* NAME: XCON: SAVE Files, GET Process.
 2011
 2012                          XCON Before SAVE
 2013                          .spf
 2014                          When a SAVE is requested and the user previously
 2015                          called M$SCON with XCON=YES, the user's exit
 2016                          control procedure takes control with a code set to
 2017                          indicating that a SAVE was requested.
 2018                          (B$XCON.CECCB.SAVE if M$SAVE; B$XCON.CECCB.CPSAVE
 2019                          if Control-Y SAVE).  The actual
 2020                          SAVE of the program image occurs on exit from this
 2021                          routine, when M$EXIT or M$TRTN is called.
 2022
 2023                          The user must be aware of several rules which
 2024                          apply to monitor service calls in the user's exit
 2025                          control procedure following a SAVE or GET request:
 2026
 2027                          1. To suspend a program after it is saved, the
 2028                          user's exit control procedure calls M$EXIT:
 2029
 2030                           o  After the program has been saved as a
 2031                              result of a Command Processor SAVE request,
 2032                              control returns to the Command Processor
 2033                              without running down the user program.  A
 2034                              subsequent GO command causes the same
 2035                              results as if a GET command had been issued.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           56   
 2036
 2037                           o  After the program has been saved as a
 2038                              result of an M$SAVE monitor service request,
 2039                              the user program is run down.  A GET command
 2040                              is required to restart the program.
 2041
 2042                          2. To continue the program immediately after it is
 2043                          saved, the user's exit control procedure calls
 2044                          M$TRTN.
 2045
 2046                           o  After the program has been saved as a
 2047                              result of a Command Processor SAVE request,
 2048                              control returns to the Command Processor
 2049                              without running down the user program.  A
 2050                              subsequent GO command causes the same
 2051                              results as if a GET command had been issued.
 2052
 2053                           o  After the program has been saved as a
 2054                              result of an M$SAVE monitor service request,
 2055                              the user's exit control will again be
 2056                              entered.  B$XCON.CECCB.GET will be set.
 2057
 2058                          3. When entered with a code indicating a GET
 2059                          command occurred, the user's exit control
 2060                          procedure returns control to the user program at
 2061                          the point of interruption for the SAVE, when the
 2062                          M$TRTN call is issued.
 2063
 2064                          4. M$LINK and M$LDTRC are not permitted in an
 2065                          exit control procedure entered because of a
 2066                          SAVE.
 2067
 2068
 2069                          SAVE File
 2070                          .spf
 2071                          The SAVE file contains Read-Only Segment data,
 2072                          program data, program procedure, program dynamic
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           57   
 2073                          data (M$GDP or M$GVP pages), user and debugger
 2074                          data segments.  A header record is also written to
 2075                          the file which contains various control
 2076                          information, including the names (not processor
 2077                          numbers) of all associated processors.  Pages
 2078                          mapped into the user work space by M$CVM are saved
 2079                          and restored.  That is, the physical-to-virtual
 2080                          mapping is preserved, but the contents of the
 2081                          pages are not written to the file.
 2082
 2083                          An associated debugger is remembered and
 2084                          its data is saved.  The debugger is associated and
 2085                          the debugger data is restored upon a GET.
 2086
 2087                          GET Process
 2088                          .spf
 2089                          At an IBEX GET command, the monitor opens the SAVE
 2090                          file specified.  The
 2091                          system version of the file's header is checked
 2092                          against that of the running system and the run unit
 2093                          that was in execution at the time of the SAVE is
 2094                          reopened.  If the program was saved under an older
 2095                          version of the operating system, or if the run unit
 2096                          is not the same version, the image cannot be restored
 2097                          and the GET process must be aborted.
 2098                          Otherwise, the user's
 2099                          saved program image is restored in a process
 2100                          similar to that used by the return path for
 2101                          M$LINK.
 2102
 2103                          DCBs that were open at the time of the SAVE will
 2104                          be closed when the restored program is given
 2105                          control.  File repositioning is not performed.
 2106                          This is one of the functions the user program
 2107
 2108                          Terminal options that are restored include all
 2109                          terminal control options except these:  EDITOVR,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           58   
 2110                          FULLDUXPAPERTAPE, HALFDUXPAPERTAPE, OUTPUTDISCARD,
 2111                          and PARITYCHECK.  (The saved program must have
 2112                          been created by a SAVE request or by a LINE
 2113                          disconnect, not by a FEP disconnect.)
 2114
 2115                          When the program image has been restored, the
 2116                          program resumes execution at the SAVE point or at
 2117                          its XCON procedure, depending on how the SAVE was
 2118                          performed.                                                                    */
 2119
 2120
 2121
 2122
 2123
 2124
 2125
 2126                          /*F* NAME: M$SCON - Set Save Control
 2127
 2128                          The M$SCON service establishes parameters for
 2129                          later use, when a request occurs to save the
 2130                          program image.
 2131
 2132                          The form of the call for this service is:
 2133
 2134                          CALL M$SCON (FPT_SCON) [ALTRET (label)];
 2135
 2136                          The parameters are as follows:                                                */
 2137
 2138
 2139      %MACRO FPT_SCON(FPTN=FPT_SCON,
 2140                    STCLASS=STATIC,
 2141                    XCON(YES='1'B,NO='0'B)='0'B,
 2142                    SAVEFLG(YES='1'B,NO='0'B)='1'B);
 2143
 2144      %LSET LISTDIR='0'B;
 2145      %LSET LISTEXP='1'B;
 2146      %LSET LISTCOM='0'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           59   
 2147      %LSET LISTSUB='1'B;
 2148      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2149      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2150       (SUBSTR(STR,0,8)='CONSTANT') OR
 2151       (SUBSTR(STR,0,3)='EXT');
 2152       %LSET INIT=CHARTEXT('INIT');
 2153      %ELSE;
 2154       %LSET INIT=CHARTEXT('/*');
 2155      %ENDIF;
 2156
 2157
 2158      DCL 1 FPTN STCLASS DALIGNED,
 2159            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2160            2 V DALIGNED,
 2161              3 XCON# BIT(1) UNAL %INIT(XCON)%CHARTEXT('/**/'),
 2162                          /*K* XCON = {YES|NO}  specifies, if YES, that the user's
 2163                          exit control procedure is to be entered prior to a
 2164                          SAVE. This parameter applies
 2165                          to user programs only, as the ASL exit control
 2166                          procedure is always entered on a SAVE.  The default is NO.                    */
 2167              3 SAVEFLG# BIT(1) UNAL %INIT(SAVEFLG)%CHARTEXT('/**/'),
 2168                          /*K* SAVEFLG = {YES|NO}  specifies, if YES, that the
 2169                          program may be saved. An Alternate Shared
 2170                          Library or any program which does not wish to
 2171                          allow SAVEs may call M$SCON specifying
 2172                          SAVEFLG=NO. This specification may not be reset
 2173                          once NO is specified.  The default is YES.
 2174                                                                                  */
 2175              3 * BIT(34) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2176              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2177      %MEND;
 2178
 2179
 2180                          /*F* NAME: M$INTRTN - Interrupt Return
 2181
 2182                          The M$INTRTN monitor service allows an Alternate
 2183                          Shared Library to pass break control down to the
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           60   
 2184                          user level domain.  This service is designed for
 2185                          use by Alternate Shared Libraries that have no
 2186                          special use for the Break-key interrupt but wish
 2187                          to establish Break Control (M$INT) to allow
 2188                          a program running under DELTA to be responsive
 2189                          to user requests for DELTA while ensuring that the
 2190                          library itself will not be interrupted while accessing
 2191                          user supplied data.
 2192
 2193                          The Alternate Shared Library relinquishes control
 2194                          with this Monitor Service; i.e., the monitor will
 2195                          perform the return form of the CLIMB instruction
 2196                          for the library.
 2197                          Note that the Alternate Shared Library should have
 2198                          removed the interrupt frame from his TCB (M$TRTN or
 2199                          M$CLRSTK) prior to issuing the M$INTRTN service request.
 2200
 2201                          There is no FPT associated with the M$INTRTN service.
 2202                          The alternate return is taken if the request is
 2203                          made from a domain other than that of the ASL.
 2204
 2205                          The form of the call for this service is:
 2206
 2207                          CALL M$INTRTN [ALTRET (label)];
 2208
 2209                          */
 2210
 2211
 2212
 2213                          /*F* NAME: M$XCONRTN - Exit Control Return
 2214
 2215                          The M$XCONRTN monitor service allows a Special Shared
 2216                          Processor to defer exit control processing until
 2217                          after all user exit control processing is completed.
 2218                          This service is designed to be used by a Special
 2219                          Shared Processor that has been interrupted for exit
 2220                          control (B$XCON.ECSC=0) for conditions other then
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           61   
 2221                          those caused by the processor itself; i.e., Operator
 2222                          abort, limit exceeded, QUIT or SAVE commands to the
 2223                          Command Processor, etc.
 2224
 2225                          Prior to issuing the M$XCONRTN request the processor should
 2226                          have removed the exit control frame from its TCB (M$TRTN or
 2227                          M$CLRSTK).
 2228
 2229                          Any exit control limit increments that had been given to
 2230                          the Special Shared Processor will be removed and the
 2231                          user's exit control logic (if any) will be entered with
 2232                          limits incremented for the user if appropriate.  When
 2233                          the user's exit control processing is complete the
 2234                          Special Shared Processor will again be entered at its
 2235                          exit control procedure (B$XCON.ECSC=1) with a new set of
 2236                          exit control limit increments.
 2237
 2238                          The M$XCONRTN procedure call is of the form:
 2239
 2240                          CALL M$XCONRTN(FPT_XCONRTN) [ALTRET(label)];
 2241
 2242                          The parameters for this service are as follows:
 2243
 2244                          */
 2245
 2246
 2247      %MACRO FPT_XCONRTN (FPTN=FPT_XCONRTN,
 2248                    STCLASS=STATIC,
 2249                    JERR=NIL,
 2250                    NOENTRY(YES='1'B,NO='0'B)='0'B);
 2251
 2252      %LSET LISTDIR='0'B;
 2253      %LSET LISTEXP='1'B;
 2254      %LSET LISTCOM='0'B;
 2255      %LSET LISTSUB='1'B;
 2256      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2257      %IF (SUBSTR(STR,0,6)='STATIC') OR
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           62   
 2258       (SUBSTR(STR,0,8)='CONSTANT') OR
 2259       (SUBSTR(STR,0,3)='EXT');
 2260       %LSET INIT=CHARTEXT('INIT');
 2261      %ELSE;
 2262       %LSET INIT=CHARTEXT('/*');
 2263      %ENDIF;
 2264
 2265
 2266      DCL 1 FPTN STCLASS DALIGNED,
 2267            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2268            2 JERR_ BIT(72) %INIT(VECTOR(JERR))%CHARTEXT('/**/'),
 2269                          /*K*  JERR = VARIABLE
 2270                          Locates the word that contains the error
 2271                          code to be passed to the user.  Generally
 2272                          this should be the error code from the
 2273                          Special Shared Processor's exit control
 2274                          frame, i.e. the limit exceeded, operator
 2275                          abort, etc. error code.
 2276                          The default is NIL.
 2277                          */
 2278            2 V DALIGNED,
 2279              3 NOENTRY# BIT(1) UNAL %INIT(NOENTRY)%CHARTEXT('/**/'),
 2280                          /*K* NOENTRY=   {YES|NO}
 2281                          Specifies, if YES, that no more entries to the
 2282                          Special Shared Processor are to be allowed prior
 2283                          to entry for deferred exit control processing.
 2284                          The default is NIL.
 2285                          */
 2286              3 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2287              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2288
 2289      %MEND;
 2290
 2291
 2292
 2293
 2294                          /*F* NAME: M$SCREECH - Recovery
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           63   
 2295
 2296                          The M$SCREECH monitor service allows the CP-6
 2297                          System Ghosts and Special Shared Processors
 2298                          and users with Extended MM Privilege to
 2299                          cause entry to recovery to create a CP-6 dump file.
 2300
 2301                          The highest Screech Severity allowed to Special
 2302                          Shared Processors is 6 (SUA).  Privileged users
 2303                          may only specify a severity of 5 (SNAP).
 2304
 2305                          The M$SCREECH procedure call is of the form:
 2306
 2307                          CALL M$SCREECH(FPT_SCREECH) [ALTRET(label)];
 2308
 2309                          The ALTRET is taken if the user is not authorized
 2310                          to call M$SCREECH or if the Dump Area on the
 2311                          system disk is busy when calling Screech to
 2312                          take a Snapshot Dump.
 2313
 2314                          The parameters for this service are as follows:
 2315
 2316                          */
 2317
 2318      %MACRO FPT_SCREECH
 2319                      (FPTN=FPT_SCREECH,
 2320                       SCODE=NIL,
 2321                       JERR=NIL,
 2322                       SCREECHID=NIL,
 2323                       STCLASS=STATIC);
 2324
 2325      %LSET LISTDIR='0'B;
 2326      %LSET LISTEXP='1'B;
 2327      %LSET LISTCOM='0'B;
 2328      %LSET LISTSUB='1'B;
 2329      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2330      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2331       (SUBSTR(STR,0,8)='CONSTANT') OR
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           64   
 2332       (SUBSTR(STR,0,3)='EXT');
 2333       %LSET INIT=CHARTEXT('INIT');
 2334      %ELSE;
 2335       %LSET INIT=CHARTEXT('/*');
 2336      %ENDIF;
 2337
 2338
 2339      DCL 1 FPTN STCLASS DALIGNED,
 2340            2 SCODE_ BIT(72) %INIT(VECTOR(SCODE))%CHARTEXT('/**/'),
 2341                          /*K*  SCODE = VARIABLE
 2342                          Locates the doubleword Recovery Code.  The
 2343                          Recovery Code contains an identifier to be output
 2344                          on the operator's console.  This code also
 2345                          contains bit settings indicating what portions of
 2346                          memory are to be dumped.
 2347
 2348                          The VLP_SCODE macro should be used to generate
 2349                          the recovery code.
 2350                          The default is NIL.
 2351                          */
 2352            2 JERR_ BIT(72) %INIT(VECTOR(JERR))%CHARTEXT('/**/'),
 2353                          /*K*  JERR = VARIABLE
 2354                          Locates the word that contains the error
 2355                          code to be placed in the JIT.
 2356                          The VLP_ERRCODE macro should be used to generate
 2357                          the errcode.
 2358                          The default is NIL.
 2359                          */
 2360            2 SCREECHID_ BIT(72) %INIT(VECTOR(SCREECHID))%CHARTEXT('/**/');
 2361                          /*K*   SCREECHID = VARIABLE
 2362                          Locates the area where the TEXTC name of
 2363                          the snapshot dump file is to be returned.
 2364                          This area must be at least 11 bytes in
 2365                          length.  The VLP_NAME macro may be used
 2366                          to generate this area.
 2367                          The default is NIL.
 2368                          */
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           65   
 2369      %MEND;
 2370
 2371
 2372
 2373
 2374                          /*F* NAME: VLP_SCODE
 2375
 2376                          The VLP_SCODE macro generates the structure describing
 2377                          a standard CP-6
 2378                          recovery code.  This is the code passed to the
 2379                          monitor on a call to M$SCREECH.
 2380
 2381                          The recovery code is either two or four words
 2382                          in length.  The four word format is used only
 2383                          when portions of a user (other than the current
 2384                          user) are to be dumped.
 2385
 2386                          The first word contains an identifier in
 2387                          VLP_ERRCODE format.  This code will be reported
 2388                          on the operator console by M$SCREECH.
 2389                          The FCG, MID, MON, CODE and SEV options allow
 2390                          initialization of this word.
 2391
 2392                          The second word contains
 2393                          bit settings indicating what portions of
 2394                          memory are to be dumped.
 2395
 2396                          The Monitor Page Table, JIT, HJIT, TSTACK, ISR
 2397                          data and TIGR data are always dumped by default.
 2398                          The LRM, CFUS, ASAVE, ENQ, LDCTS, PPUT, SHJIT,
 2399                          CWSPT, CGDATA, CURCG, PMST, and PMDATA options
 2400                          may be used to specify that other portions of the
 2401                          monitor are to be written to the dump file.  These
 2402                          options are generally of no interest to the
 2403                          M$SCREECH user.
 2404
 2405                          The CUSR, CUSRS, IOUSRS, or ALLUSR option may be
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           66   
 2406                          used to select what users are to be dumped. The
 2407                          SPBUF, FMBUF, ROSEG, ISEG, DDSEG, DBSEG, ASLSEG,
 2408                          and CPSEG options then select what portions of
 2409                          the selected user(s) are to be dumped.
 2410
 2411                          If a selected user (other than the current user)
 2412                          is to be dumped, the AUSER option is used
 2413                          to indicate this.  Specifying AUSER=YES causes
 2414                          a four word recovery code to be generated.  Word
 2415                          three is to contain the user number of the user
 2416                          to be dumped in bits 0-8.  The user number may
 2417                          be specified by the USER=value option.
 2418                          Generally, this user number would not be known
 2419                          at compile time and would be specified at run
 2420                          time by setting fpt_name.USER# to the desired user's
 2421                          number.
 2422
 2423                          The default values for VLP_SCODE are all null.
 2424                          For convenience the recovery code structure may be generated
 2425                          using the VLP_SCREECH macro which has a default SEV of
 2426                          SEV_SCREECH and defaults to everything being
 2427                          dumped.  The VLP_SUA macro also generates a
 2428                          recovery code.  This macro has the default SEV
 2429                          set to SEV_SUA and defaults to dumping all parts
 2430                          of the current user.
 2431
 2432                          The following options allow initialization
 2433                          of VLP_SCODE:
 2434                          */
 2435
 2436      %MACRO VLP_SCODE (FPTN = VLP_SCODE,
 2437                        STCLASS = STATIC,
 2438                        YES='1'B,NO='0'B,
 2439                        FCG = '0'B,
 2440                        MID = '0'B,
 2441                        MON(YES='1'B,NO='0'B,ANY)='1'B,
 2442                        CODE = 0,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           67   
 2443                        SEV(SEV_SCREECH=7,SEV_SUA=6,SEV_SNAP=5,SEV_ZAP=4,SEV_FESNAP=3,ANY)=5,
 2444                        AUSER(YES='1'B,NO='0'B,ANY)='0'B,
 2445                        USER=0,
 2446                        LRM(YES='1'B,NO='0'B,ANY)='0'B,
 2447                        CFUS(YES='1'B,NO='0'B,ANY)='0'B,
 2448                        ASAVE(YES='1'B,NO='0'B,ANY)='0'B,
 2449                        ENQ(YES='1'B,NO='0'B,ANY)='0'B,
 2450                        DS4(YES='1'B,NO='0'B,ANY)='0'B,
 2451                        DS5(YES='1'B,NO='0'B,ANY)='0'B,
 2452                        DS6(YES='1'B,NO='0'B,ANY)='0'B,
 2453                        DS7(YES='1'B,NO='0'B,ANY)='0'B,
 2454                        LDCTS(YES='1'B,NO='0'B,ANY)='0'B,
 2455                        PPUT(YES='1'B,NO='0'B,ANY)='0'B,
 2456                        SHJIT(YES='1'B,NO='0'B,ANY)='0'B,
 2457                        CWSPT(YES='1'B,NO='0'B,ANY)='0'B,
 2458                        CGDATA(YES='1'B,NO='0'B,ANY)='0'B,
 2459                        CURCG(YES='1'B,NO='0'B,ANY)='0'B,
 2460                        PMST(YES='1'B,NO='0'B,ANY)='0'B,
 2461                        PMDATA(YES='1'B,NO='0'B,ANY)='0'B,
 2462                        MPROC(YES='1'B,NO='0'B,ANY)='0'B,
 2463                        CUSR(YES='1'B,NO='0'B,ANY)='0'B,
 2464                        CUSRS(YES='1'B,NO='0'B,ANY)='0'B,
 2465                        IOUSRS(YES='1'B,NO='0'B,ANY)='0'B,
 2466                        ALLUSR(YES='1'B,NO='0'B,ANY)='0'B,
 2467                        SPBUF(YES='1'B,NO='0'B,ANY)='0'B,
 2468                        FMBUF(YES='1'B,NO='0'B,ANY)='0'B,
 2469                        ROSEG(YES='1'B,NO='0'B,ANY)='0'B,
 2470                        ISEG(YES='1'B,NO='0'B,ANY)='0'B,
 2471                        DDSEG(YES='1'B,NO='0'B,ANY)='0'B,
 2472                        DBSEG(YES='1'B,NO='0'B,ANY)='0'B,
 2473                        ASLSEG(YES='1'B,NO='0'B,ANY)='0'B,
 2474                        CPSEG(YES='1'B,NO='0'B,ANY)='0'B);
 2475
 2476       %LSET LISTDIR='0'B;
 2477       %LSET LISTEXP='1'B;
 2478       %LSET LISTCOM='0'B;
 2479       %LSET LISTSUB='1'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           68   
 2480
 2481      %IF AUSER='1'B;
 2482      %ENDIF;
 2483      %IF USER=0;
 2484      %ENDIF;
 2485
 2486       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2487       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2488       (SUBSTR(STR,0,8)='CONSTANT') OR
 2489       (SUBSTR(STR,0,3)='EXT');
 2490       %LSET INIT=CHARTEXT('INIT');
 2491       %ELSE;
 2492       %LSET INIT=CHARTEXT('/*');
 2493       %ENDIF;
 2494
 2495      DCL 1 FPTN STCLASS DALIGNED,
 2496      %LSET FCG#=CONCAT(TEXTCHAR(FCG),BINASC(0),BINASC(0));
 2497      %LSET L=LENGTHC(TEXTCHAR(FCG))-1;
 2498      %IF L<1;
 2499      %ELSEIF SUBSTR(FCG#,0,1)='''' AND(SUBSTR(FCG#,L,1)='''');
 2500      %LSET FCG#=CONCAT(SUBSTR(FCG#,1,L-1),BINASC(0));
 2501      %LSET L=L-2;
 2502      %ENDIF;
 2503      %IF SUBSTR(FCG#,0,1)~='''' AND(L<2);
 2504      %LSET FCG#=CONCAT(SUBBIT(ASCBIT(SUBSTR(FCG#,0,1)),3,6),SUBBIT(ASCBIT(SUBSTR(FCG#,1,1)),3,6));
 2505      %ELSE;
 2506      %LSET FCG#=FCG;
 2507      %ENDIF;
 2508            2 %CHARTEXT('FCG# ') BIT(12) %INIT(%FCG#) %CHARTEXT('/**/') UNAL,
 2509                          /*K* FCG = VALUE-BIT(12).  This field
 2510                          contains the two special six-bit characters that
 2511                          identify the functional code group that is
 2512                          initiating recovery.  For convenience, it may be
 2513                          specified as text or as a quote string (e.g., FCG=FM).
 2514                          */
 2515      %LSET MID#=CONCAT(TEXTCHAR(MID),BINASC(0));
 2516      %LSET L=LENGTHC(TEXTCHAR(MID))-1;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           69   
 2517      %IF L<1;
 2518      %ELSEIF SUBSTR(MID#,0,1)='''' AND(SUBSTR(MID#,L,1)='''');
 2519      %LSET MID#=SUBSTR(MID#,1,L-1);
 2520      %LSET L=L-2;
 2521      %ENDIF;
 2522      %IF SUBSTR(MID#,0,1)~='''' AND(L<2);
 2523      %LSET MID#=SUBBIT(ASCBIT(SUBSTR(MID#,0,1)),3,6);
 2524      %ELSE;
 2525      %LSET MID#=MID;
 2526      %ENDIF;
 2527            2 %CHARTEXT('MID# ') BIT(6) %INIT(%MID#) %CHARTEXT('/**/') UNAL,
 2528                          /*K* MID = VALUE-BIT(6).  This field
 2529                          contains the special six bit character that identifies
 2530                          which module in the functional code group is
 2531                          initiating recovery.  For convenience, it may be
 2532                          specified as text or as a quote string (e.g., MID='M').
 2533                          */
 2534            2 %CHARTEXT('MON# ') BIT(1) %INIT(MON) %CHARTEXT('/**/') UNAL,
 2535                          /*K* MON = {YES|NO}.
 2536                          Specifies that Recovery was called by the Monitor
 2537                          if set to 1 or by a Ghost or Special Shared
 2538                          Processor if set to 0.  Default = YES.
 2539                          */
 2540            2 %CHARTEXT('CODE# ') UBIN(14) %INIT(CODE) %CHARTEXT('/**/') UNAL,
 2541                          /*K* CODE = VALUE-DEC(0-16383).  This field
 2542                          contains the number that identifies a particular
 2543                          recovery condition.  The file B_SCODE_C contains a
 2544                          list of these CODEs for the monitor.
 2545                          */
 2546            2 %CHARTEXT('SEV# ') UBIN(3) %INIT(SEV) %CHARTEXT('/**/') UNAL,
 2547                          /*K* SEV = VALUE-DEC(0-7).
 2548                          Specifies the severity of the Recovery code:
 2549
 2550                          }    4 = Zap
 2551                          }    5 = Snapshot Dump
 2552                          }    6 = Single User Abort
 2553                          }    7 = Full Recovery
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           70   
 2554
 2555                          One of the following should be specified:
 2556
 2557                          }  SEV_ZAP
 2558                          }  SEV_SNAP
 2559                          }  SEV_SUA
 2560                          }  SEV_SCREECH
 2561                          }  SEV_FESNAP
 2562                          }
 2563                          Default = SEV_SNAP.
 2564                          */
 2565                                    /* MONITOR DATA                                                     */
 2566            2 LRM# BIT(1) UNAL %INIT(LRM)%CHARTEXT('/**/'),
 2567                          /*K*   LRM = {YES|NO}.
 2568                          Specifies that low real memory (Pages 0-3) is
 2569                          to be written to the dump file.
 2570                          Default=NO.                                                                   */
 2571            2 CFUS# BIT(1) UNAL %INIT(CFUS)%CHARTEXT('/**/'),
 2572                          /*K*   CFUS = {YES|NO}.
 2573                          Specifies that the CFUs (Monitor Data Segment #1)
 2574                          are to be written to the dump file.
 2575                          Default=NO.                                                                   */
 2576            2 ASAVE# BIT(1) UNAL %INIT(ASAVE)%CHARTEXT('/**/'),
 2577                          /*K*   ASAVE = {YES|NO}.
 2578                          Specifies that the Auto-save Tables (Monitor
 2579                          Data Segment #2) are to be written to the
 2580                          dump file.
 2581                          Default=NO.                                                                   */
 2582            2 ENQ# BIT(1) UNAL %INIT(ENQ)%CHARTEXT('/**/'),
 2583                          /*K*   ENQ = {YES|NO}.
 2584                          Specifies that the ENQ-DEQ Tables (Monitor Data
 2585                          Segment #3) are to be written to the dump file.
 2586                          Default=NO.                                                                   */
 2587            2 DS4# BIT(1) UNAL %INIT(DS4)%CHARTEXT('/**/'),
 2588            2 DS5# BIT(1) UNAL %INIT(DS5)%CHARTEXT('/**/'),
 2589            2 DS6# BIT(1) UNAL %INIT(DS6)%CHARTEXT('/**/'),
 2590            2 DS7# BIT(1) UNAL %INIT(DS7)%CHARTEXT('/**/'),
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           71   
 2591            2 LDCTS# BIT(1) UNAL %INIT(LDCTS)%CHARTEXT('/**/'),
 2592                          /*K*   LDCTS = {YES|NO}.
 2593                          Specifies that the LDCTs, logical device control table.
 2594                          (Monitor Data
 2595                          Segment #8) are to be written to the dump file.
 2596                          Default=NO.                                                                   */
 2597            2 PPUT# BIT(1) UNAL %INIT(PPUT)%CHARTEXT('/**/'),
 2598                          /*K*   PPUT = {YES|NO}.
 2599                          Specifies that the Monitor Page Table Chains
 2600                          (MM_PPUT) are to be written to the dump file.
 2601                          Default=NO.                                                                   */
 2602            2 SHJIT# BIT(1) UNAL %INIT(SHJIT)%CHARTEXT('/**/'),
 2603                          /*K*   SHJIT = {YES|NO}.
 2604                          Specifies that the Monitor Page Table, JIT, HJIT
 2605                          and TSTACK for the slave CPUs are to be written to
 2606                          the dump file.
 2607                          Default=NO.                                                                   */
 2608            2 CWSPT# BIT(1) UNAL %INIT(CWSPT)%CHARTEXT('/**/'),
 2609                          /*K*   CWSPT = {YES|NO}.
 2610                          Specifies that the Communication WSQ Page
 2611                          Tables are to be written to the dump file.
 2612                          Default=NO.                                                                   */
 2613            2 CGDATA# BIT(1) UNAL %INIT(CGDATA)%CHARTEXT('/**/'),
 2614                          /*K*   CGDATA = {YES|NO}.
 2615                          Specifies that the Comgroup WSQ Page Tables and
 2616                          context area are to be written to the dump file.
 2617                          Default=NO.                                                                   */
 2618            2 CURCG# BIT(1) UNAL %INIT(CURCG)%CHARTEXT('/**/'),
 2619                          /*K*   CURCG = {YES|NO}.
 2620                          Specifies that the data for the current
 2621                          Comgroup is to be written to the dump file.
 2622                          Default=NO.                                                                   */
 2623            2 PMST# BIT(1) UNAL %INIT(PMST)%CHARTEXT('/**/'),
 2624                          /*K*   PMST = {YES|NO}.
 2625                          Specifies that the Performance Monitor State
 2626                          Tables are to be written to the dump file.
 2627                          Default=NO.                                                                   */
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           72   
 2628            2 PMDATA# BIT(1) UNAL %INIT(PMDATA)%CHARTEXT('/**/'),
 2629                          /*K*   PMDATA = {YES|NO}.
 2630                          Specifies that the Performance Monitor Data
 2631                          is to be written to the dump file.
 2632                          Default=NO.                                                                   */
 2633            2 MPROC# BIT(1) UNAL %INIT(MPROC)%CHARTEXT('/**/'),
 2634            2 * BIT(3) UNAL %INIT(NO)%CHARTEXT('/**/'),
 2635            2 CUSR# BIT(1) UNAL %INIT(CUSR)%CHARTEXT('/**/'),
 2636                          /*K*   CUSR = {YES|NO}.
 2637                          Specifies that only the current user is to be
 2638                          dumped.  Redundant if CUSRS or ALLUSR is
 2639                          also specified.
 2640                          Default=NO.                                                                   */
 2641            2 CUSRS# BIT(1) UNAL %INIT(CUSRS)%CHARTEXT('/**/'),
 2642                          /*K*   CUSRS = {YES|NO}.
 2643                          Specifies that the current user on all CPUs
 2644                          are to be dumped.  Redundant if ALLUSR is
 2645                          specified.
 2646                          Default=NO.                                                                   */
 2647            2 IOUSRS# BIT(1) UNAL %INIT(IOUSRS)%CHARTEXT('/**/'),
 2648                          /*K*   IOUSRS = {YES|NO}.
 2649                          Specifies that all IO Busy users are to be
 2650                          dumped.  Redundant if ALLUSR is specified.
 2651                          Default=NO.                                                                   */
 2652            2 ALLUSR# BIT(1) UNAL %INIT(ALLUSR)%CHARTEXT('/**/'),
 2653                          /*K*   ALLUSR = {YES|NO}.
 2654                          Specifies that all users are to be dumped.
 2655                          Default=NO.                                                                   */
 2656            2 SPBUF# BIT(1) UNAL %INIT(SPBUF)%CHARTEXT('/**/'),
 2657                          /*K*   SPBUF = {YES|NO}.
 2658                          Specifies that the STEP Special Buffers are
 2659                          to be written to the dump file.
 2660                          Default=NO.                                                                   */
 2661            2 FMBUF# BIT(1) UNAL %INIT(FMBUF)%CHARTEXT('/**/'),
 2662                          /*K*   FMBUF = {YES|NO}.
 2663                          Specifies that the File Management Buffers
 2664                          are to be written to the dump file.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           73   
 2665                          Default=NO.                                                                   */
 2666            2 ROSEG# BIT(1) UNAL %INIT(ROSEG)%CHARTEXT('/**/'),
 2667                          /*K*   ROSEG = {YES|NO}.
 2668                          Specifies that the users Read-Only Segment is to be
 2669                          written to the dump file.
 2670                          Default=NO.                                                                   */
 2671            2 ISEG# BIT(1) UNAL %INIT(ISEG)%CHARTEXT('/**/'),
 2672                          /*K*   ISEG = {YES|NO}.
 2673                          Specifies that the users Instruction Segment
 2674                          is to be written to the dump file.
 2675                          Default=NO.                                                                   */
 2676            2 DDSEG# BIT(1) UNAL %INIT(DDSEG)%CHARTEXT('/**/'),
 2677                          /*K*   DDSEG = {YES|NO}.
 2678                          Specifies that the user's Dynamic Data Segments
 2679                          are to be written to the dump file.
 2680                          Default=NO.                                                                   */
 2681            2 DBSEG# BIT(1) UNAL %INIT(DBSEG)%CHARTEXT('/**/'),
 2682                          /*K*   DBSEG = {YES|NO}.
 2683                          Specifies that the Debugger Dynamic Data Segments
 2684                          are to be written to the dump file.
 2685                          Default=NO.                                                                   */
 2686            2 ASLSEG# BIT(1) UNAL %INIT(ASLSEG)%CHARTEXT('/**/'),
 2687                          /*K*   ASLSEG = {YES|NO}.
 2688                          Specifies that the Alternate Shared Library
 2689                          Dynamic Data Segments are to be written to
 2690                          the dump file.
 2691                          Default=NO.                                                                   */
 2692            2 CPSEG# BIT(1) UNAL %INIT(CPSEG)%CHARTEXT('/**/'),
 2693                          /*K*   CPSEG = {YES|NO}.
 2694                          Specifies that the Command Processor Dynamic
 2695                          Data Segments are to be written to the dump
 2696                          file.
 2697                          Default=NO.                                                                   */
 2698            2 * BIT(3) UNAL %INIT(NO)%CHARTEXT('/**/'),
 2699      %IF AUSER='0'B;
 2700            2 AUSER# BIT(1) UNAL %INIT(AUSER)%CHARTEXT('/**/');
 2701      %ELSE;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           74   
 2702            2 AUSER# BIT(1) UNAL %INIT(AUSER)%CHARTEXT('/**/'),
 2703                          /*K* AUSER = {YES|NO}.
 2704                          Specifies that the user selected by the USER
 2705                          option is to be dumped.
 2706                          Default=NO.
 2707                          */
 2708            2 USER# UBIN(9) UNAL %INIT(USER)%CHARTEXT('/**/'),
 2709                          /*K* USER = VALUE-DEC(0-?).
 2710                          Specifies the user number of the user that is
 2711                          to be dumped.  This option is ignored if AUSER
 2712                          is not also specified.
 2713                          Default = 0.
 2714                          */
 2715            2 * BIT(27) UNAL %INIT(NO)%CHARTEXT('/**/'),
 2716            2 * BIT(36) UNAL %INIT(NO)%CHARTEXT('/**/');
 2717      %ENDIF;
 2718      %MEND;
 2719
 2720
 2721
 2722                          /*F* NAME: VLP_SCREECH
 2723
 2724                          The VLP_SCREECH macro generates a CP-6 recovery code that is
 2725                          passed to the monitor on an M$SCREECH request.
 2726
 2727                          The only difference between the VLP_SCODE and VLP_SCREECH macros
 2728                          is in the defaults for the various options.  Please refer
 2729                          the description of VLP_SCODE for the names and meanings of
 2730                          the options.  The default for all {YES|NO} options
 2731                          when using the VLP_SCREECH macro is YES.
 2732
 2733                          */
 2734
 2735      %MACRO VLP_SCREECH (FPTN = VLP_SCREECH,
 2736                        STCLASS = STATIC,
 2737                        FCG = '0'B,
 2738                        MID = '0'B,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           75   
 2739                        MON(YES='1'B,NO='0'B,ANY)='1'B,
 2740                        CODE = 0,
 2741                        SEV(SEV_SCREECH=7,SEV_SUA=6,SEV_SNAP=5,SEV_ZAP=4,SEV_FESNAP=3,ANY)=7,
 2742                        AUSER(YES='1'B,NO='0'B,ANY)='0'B,
 2743                        USER=0,
 2744                        LRM(YES='1'B,NO='0'B,ANY)='1'B,
 2745                        CFUS(YES='1'B,NO='0'B,ANY)='1'B,
 2746                        ASAVE(YES='1'B,NO='0'B,ANY)='1'B,
 2747                        ENQ(YES='1'B,NO='0'B,ANY)='1'B,
 2748                        DS4(YES='1'B,NO='0'B,ANY)='1'B,
 2749                        DS5(YES='1'B,NO='0'B,ANY)='1'B,
 2750                        DS6(YES='1'B,NO='0'B,ANY)='1'B,
 2751                        DS7(YES='1'B,NO='0'B,ANY)='1'B,
 2752                        LDCTS(YES='1'B,NO='0'B,ANY)='1'B,
 2753                        PPUT(YES='1'B,NO='0'B,ANY)='1'B,
 2754                        SHJIT(YES='1'B,NO='0'B,ANY)='1'B,
 2755                        CWSPT(YES='1'B,NO='0'B,ANY)='1'B,
 2756                        CGDATA(YES='1'B,NO='0'B,ANY)='1'B,
 2757                        CURCG(YES='1'B,NO='0'B,ANY)='1'B,
 2758                        PMST(YES='1'B,NO='0'B,ANY)='1'B,
 2759                        PMDATA(YES='1'B,NO='0'B,ANY)='1'B,
 2760                        MPROC(YES='1'B,NO='0'B,ANY)='1'B,
 2761                        CUSR(YES='1'B,NO='0'B,ANY)='1'B,
 2762                        CUSRS(YES='1'B,NO='0'B,ANY)='1'B,
 2763                        IOUSRS(YES='1'B,NO='0'B,ANY)='1'B,
 2764                        ALLUSR(YES='1'B,NO='0'B,ANY)='1'B,
 2765                        SPBUF(YES='1'B,NO='0'B,ANY)='1'B,
 2766                        FMBUF(YES='1'B,NO='0'B,ANY)='1'B,
 2767                        ROSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2768                        ISEG(YES='1'B,NO='0'B,ANY)='1'B,
 2769                        DDSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2770                        DBSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2771                        ASLSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2772                        CPSEG(YES='1'B,NO='0'B,ANY)='1'B);
 2773
 2774       %LSET LISTDIR='0'B;
 2775       %LSET LISTEXP='1'B;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           76   
 2776       %LSET LISTCOM='0'B;
 2777       %LSET LISTSUB='1'B;
 2778
 2779      %VLP_SCODE (FPTN=FPTN,
 2780                  STCLASS=STCLASS,
 2781                  FCG=FCG,
 2782                  MID=MID,
 2783                  MON=MON,
 2784                  CODE=CODE,
 2785                  SEV=SEV,
 2786                  LRM=LRM,CFUS=CFUS,ASAVE=ASAVE,ENQ=ENQ,LDCTS=LDCTS,
 2787                  DS4=DS4,DS5=DS5,DS6=DS6,DS7=DS7,
 2788                  PPUT=PPUT,SHJIT=SHJIT,CWSPT=CWSPT,CGDATA=CGDATA,
 2789                  CURCG=CURCG,PMST=PMST,PMDATA=PMDATA,MPROC=MPROC,
 2790                  CUSR=CUSR,CUSRS=CUSRS,IOUSRS=IOUSRS,ALLUSR=ALLUSR,
 2791                  SPBUF=SPBUF,FMBUF=FMBUF,ROSEG=ROSEG,ISEG=ISEG,
 2792                  DDSEG=DDSEG,DBSEG=DBSEG,ASLSEG=ASLSEG,CPSEG=CPSEG,
 2793                  AUSER=AUSER,USER=USER);
 2794
 2795      %MEND;
 2796
 2797
 2798
 2799
 2800
 2801
 2802                          /*F* NAME: VLP_SUA
 2803
 2804                          The VLP_SUA macro generates a CP-6 recovery code that is
 2805                          passed to the monitor on an M$SCREECH request.
 2806
 2807                          The only difference between the VLP_SCODE and VLP_SUA macros
 2808                          is in the defaults for the various options.  Please refer
 2809                          the description of VLP_SCODE for the names and meanings of
 2810                          the options.  Those options that default to YES when
 2811                          using the VLP_SUA macro are:
 2812
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           77   
 2813                          }   CGDATA
 2814                          }   CURCG
 2815                          }   CUSR
 2816                          }   SPBUF
 2817                          }   FMBUF
 2818                          }   ROSEG
 2819                          }   ISEG
 2820                          }   DDSEG
 2821                          }   DBSEG
 2822                          }   ASLSEG
 2823                          }   CPSEG
 2824                          */
 2825
 2826      %MACRO VLP_SUA (FPTN = VLP_SUA,
 2827                        STCLASS = STATIC,
 2828                        FCG = '0'B,
 2829                        MID = '0'B,
 2830                        MON(YES='1'B,NO='0'B,ANY)='1'B,
 2831                        CODE = 0,
 2832                        SEV(SEV_SCREECH=7,SEV_SUA=6,SEV_SNAP=5,SEV_ZAP=4,SEV_FESNAP=3,ANY)=6,
 2833                        AUSER(YES='1'B,NO='0'B,ANY)='0'B,
 2834                        USER=0,
 2835                        LRM(YES='1'B,NO='0'B,ANY)='0'B,
 2836                        CFUS(YES='1'B,NO='0'B,ANY)='0'B,
 2837                        ASAVE(YES='1'B,NO='0'B,ANY)='0'B,
 2838                        ENQ(YES='1'B,NO='0'B,ANY)='0'B,
 2839                        DS4(YES='1'B,NO='0'B,ANY)='0'B,
 2840                        DS5(YES='1'B,NO='0'B,ANY)='0'B,
 2841                        DS6(YES='1'B,NO='0'B,ANY)='0'B,
 2842                        DS7(YES='1'B,NO='0'B,ANY)='0'B,
 2843                        LDCTS(YES='1'B,NO='0'B,ANY)='0'B,
 2844                        PPUT(YES='1'B,NO='0'B,ANY)='0'B,
 2845                        SHJIT(YES='1'B,NO='0'B,ANY)='0'B,
 2846                        CWSPT(YES='1'B,NO='0'B,ANY)='0'B,
 2847                        CGDATA(YES='1'B,NO='0'B,ANY)='1'B,
 2848                        CURCG(YES='1'B,NO='0'B,ANY)='1'B,
 2849                        PMST(YES='1'B,NO='0'B,ANY)='0'B,
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           78   
 2850                        PMDATA(YES='1'B,NO='0'B,ANY)='0'B,
 2851                        MPROC(YES='1'B,NO='0'B,ANY)='0'B,
 2852                        CUSR(YES='1'B,NO='0'B,ANY)='1'B,
 2853                        CUSRS(YES='1'B,NO='0'B,ANY)='0'B,
 2854                        IOUSRS(YES='1'B,NO='0'B,ANY)='0'B,
 2855                        ALLUSR(YES='1'B,NO='0'B,ANY)='0'B,
 2856                        SPBUF(YES='1'B,NO='0'B,ANY)='1'B,
 2857                        FMBUF(YES='1'B,NO='0'B,ANY)='1'B,
 2858                        ROSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2859                        ISEG(YES='1'B,NO='0'B,ANY)='1'B,
 2860                        DDSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2861                        DBSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2862                        ASLSEG(YES='1'B,NO='0'B,ANY)='1'B,
 2863                        CPSEG(YES='1'B,NO='0'B,ANY)='1'B);
 2864
 2865       %LSET LISTDIR='0'B;
 2866       %LSET LISTEXP='1'B;
 2867       %LSET LISTCOM='0'B;
 2868       %LSET LISTSUB='1'B;
 2869
 2870      %VLP_SCODE (FPTN=FPTN,
 2871                  STCLASS=STCLASS,
 2872                  FCG=FCG,
 2873                  MID=MID,
 2874                  MON=MON,
 2875                  CODE=CODE,
 2876                  SEV=SEV,
 2877                  LRM=LRM,CFUS=CFUS,ASAVE=ASAVE,ENQ=ENQ,LDCTS=LDCTS,
 2878                  DS4=DS4,DS5=DS5,DS6=DS6,DS7=DS7,
 2879                  PPUT=PPUT,SHJIT=SHJIT,CWSPT=CWSPT,CGDATA=CGDATA,
 2880                  CURCG=CURCG,PMST=PMST,PMDATA=PMDATA,MPROC=MPROC,
 2881                  CUSR=CUSR,CUSRS=CUSRS,IOUSRS=IOUSRS,ALLUSR=ALLUSR,
 2882                  SPBUF=SPBUF,FMBUF=FMBUF,ROSEG=ROSEG,ISEG=ISEG,
 2883                  DDSEG=DDSEG,DBSEG=DBSEG,ASLSEG=ASLSEG,CPSEG=CPSEG,
 2884                  AUSER=AUSER,USER=USER);
 2885
 2886      %MEND;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           79   
 2887
 2888
 2889
 2890
 2891
 2892
 2893                          /*F* NAME: M$ACCT - Gathering Accounting Statistics on a User.
 2894
 2895
 2896                               The purpose of M$ACCT is to gather and place in a standard
 2897                               form, accounting statistics on a user.
 2898
 2899                               The M$ACCT monitor service is for use by
 2900                               the CP-6 monitor, CP-6 recovery and Command Processors
 2901                               for the purpose of gathering and presenting in a standard
 2902                               format, accounting statistics on a user at various times
 2903                               throughout his job. The CP-6 monitor uses M$MACCT to produce
 2904                               and place into the *S file an accounting record at each of
 2905                               the following times:
 2906
 2907                                   1) At the beginning of each step. This record is
 2908                                      produced if (B$JIT.CPFLAGS1 & %CP_STEPACCT#) is set or if
 2909                                      B$JIT.SSLEV~=%AZ_NONE#.
 2910
 2911                                   2) At the end of each step. This record is produced
 2912                                      if (B$JIT.CPFLAGS1 & %CP_STEPACCT#) is set or if
 2913                                      B$JIT.SSLEV~=%AZ_NONE#.  Both
 2914                                      the step-start and the step-end records if used
 2915                                      together may be used to produce step statistics on
 2916                                      the user.
 2917
 2918                                   3) At the beginning of any proprietary accounting
 2919                                      period.
 2920
 2921                                   4) At the end of any proprietary accounting period.
 2922                                      A proprietary accounting period is defined in the CP-6 system as
 2923                                      that period of time during which a proprietarily
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           80   
 2924                                      charged processor FETCHed from account :SYS is
 2925                                      in control during a job step. A proprietary  processor
 2926                                      is a processor which has been designated (in it's
 2927                                      HEAD record) as such. This may be done by LINK or
 2928                                      CONTROL. Due to the effects of that processor
 2929                                      calling M$LINK and the subsequent return to the
 2930                                      proprietary processor from the linked-to processor,
 2931                                      there may be several proprietary-start and
 2932                                      proprietary-end records for a proprietary processor
 2933                                      during a job step. These proprietary-start and
 2934                                      proprietary-stop records may be used to obtain and
 2935                                      charge for accounting statistics caused by that
 2936                                      proprietary processor.
 2937                                         Whenever M$ACCT writes a proprietary-start record,
 2938                                      (B$JIT.CPFLAGS1 & %CP_STARPROC#) is set to so indicate.
 2939                                      This may be used by a Command Processor as an
 2940                                      indication that some proprietary accounting
 2941                                      records exist in the *S file.
 2942
 2943                                     M$ACCT is also used by CP-6 recovery in order to
 2944                                  do accounting for jobs caught in a system SCREECH.
 2945
 2946                                     Finally, M$ACCT may be called by Command Processors
 2947                                  at JOBEND in order to gather accounting statistics
 2948                                  for the running user.
 2949
 2950                                     As stated before, M$ACCT when called by the CP-6
 2951                                  monitor will write the accounting information record
 2952                                  into the *S file. These records are in the format
 2953                                  described further by the CP6_JSP Macro in AZ_MACRO_C and
 2954                                  keyed by the ACCT_KEY Macro also in AZ_MACRO_C.
 2955                                     Records produced for CP-6 recovery are also presented
 2956                                  in CP6_JSP format but are returned to Recovery in a BUFfer
 2957                                  specified in the FPT.
 2958
 2959                                     For Command Processors calling M$ACCT to obtain
 2960                                  JOBEND statistics, the record, as always, is in CP6_JSP
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           81   
 2961                                  format. The record itself may be either returned to
 2962                                  the Command Processor via the specified BUFfer as for
 2963                                  Recovery or, if desired, be written to the *S file for
 2964                                  later processing. For information on
 2965                                  macros in AZ_MACRO_C, see the System
 2966                                  Manager Handbook.
 2967
 2968                                  The form of the call for this service is as follows:
 2969
 2970                                  CALL M$ACCT (FPT_ACCT) [ALTRET (label)];
 2971
 2972                                  The parameters for this service are as follows:
 2973                                  */
 2974      %MACRO FPT_ACCT  (FPTN=FPT_ACCT,
 2975               STCLASS=STATIC,
 2976               BUF=NIL,
 2977               LEN=NIL,
 2978               PNAME=NIL,
 2979               JIT=NIL,
 2980               UTS=0,
 2981               TYP(PSTART=1,PSTOP=2,SSTART=3,SSTOP=4,JOBEND=5,RCVRY=6)=5,
 2982               STAROUT(YES='1'B,NO='0'B)='0'B);
 2983
 2984       %LSET LISTDIR='0'B;
 2985       %LSET LISTEXP='1'B;
 2986       %LSET LISTCOM='0'B;
 2987       %LSET LISTSUB='1'B;
 2988       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2989       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2990       (SUBSTR(STR,0,8)='CONSTANT') OR
 2991       (SUBSTR(STR,0,3)='EXT');
 2992       %LSET INIT=CHARTEXT('INIT');
 2993       %ELSE;
 2994       %LSET INIT=CHARTEXT('/*');
 2995       %ENDIF;
 2996
 2997
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           82   
 2998      DCL 1 FPTN STCLASS DALIGNED,
 2999            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3000            2 BUF_ BIT(72) %INIT(VECTOR(BUF))%CHARTEXT('/**/'),
 3001                          /*K* BUF = VARIABLE. Locates a buffer in which to return
 3002                          the information accumulated by this service if STAROUT=NO.
 3003                          The CP6_JSP macro from AZ_MACRO_C should be used to examine
 3004                          this buffer.
 3005                          */
 3006            2 LEN_ BIT(72) %INIT(VECTOR(LEN))%CHARTEXT('/**/'),
 3007                                    /* LEN = VARIABLE. Locates an SBIN WORD in which to return
 3008                                    the length of the CP6_JSP record returned (or attempted to be
 3009                                    returned in the case of a %E$LD altreturn) to the caller's BUF.
 3010                                    This may be useful in allocating more space if another try at
 3011                                    the service is desired. LEN is useful only if STAROUT=NO.
 3012                                    */
 3013            2 PNAME_ BIT(72) %INIT(VECTOR(PNAME))%CHARTEXT('/**/'),
 3014                          /*K* PNAME = VARIABLE. Locates a VLP_NAME structure containing
 3015                          the name of the processor running during the accounting
 3016                          period this call is to describe. It is used only for TYP =
 3017                          PSTART and SSTART. If unspecified in these cases, JSP.PROCNAME
 3018                          will be empty.
 3019                          */
 3020            2 JIT_ BIT(72) %INIT(VECTOR(JIT))%CHARTEXT('/**/'),
 3021                          /*K* JIT = VARIABLE. Locates the JIT to use to gather
 3022                          the information needed for this service if TYP=RCVRY only.
 3023                          For all other TYPs, the caller's JIT will be used.
 3024                          */
 3025            2 V,
 3026              3 UTS# UBIN WORD %INIT(UTS)%CHARTEXT('/**/'),
 3027                          /*K* UTS = VALUE-DEC. Specifies a UTS to be used for
 3028                          current time in all time differencing calculations for TYP=RCVRY
 3029                          only.  The value should be the UTS of the crash this recovery
 3030                          is handling. The system UTS is used for all other TYPs.
 3031                          */
 3032              3 TYP# UBIN BYTE UNAL %INIT(TYP)%CHARTEXT('/**/'),
 3033                          /*K* TYP = OPTION. Specifies type of M$ACCT call. Possible
 3034                          values are PSTART, PSTOP, SSTART, SSTOP, JOBEND and RCVRY.
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           83   
 3035                          This value also is used in the KEY for the record written
 3036                          to the *S file.  PSTART and PSTOP are for start and
 3037                          stop of a charge period for a proprietary processor.
 3038                          SSTART and SSTOP are for start and stop of a job step.
 3039                          JOBEND is for use at job end and RCVRY is for use by recovery.
 3040                          JOBEND may be used by Command Processors; all others are
 3041                          for monitor use only.
 3042                          */
 3043              3 STAROUT# BIT(1) %INIT(STAROUT)%CHARTEXT('/**/'),
 3044                          /*K* STAROUT = {YES|NO}. If YES, specifies that the JSP record
 3045                          generated is to be written to the *S file. If so, the key
 3046                          is described as %ACCT_KEY macro in AZ_MACRO_C.
 3047                          If NO, the record will be written into the caller's BUF with
 3048                          the data's length written into LEN.
 3049                          */
 3050              3 * UBIN(26) UNAL %INIT(0)%CHARTEXT('/**/');
 3051      %MEND;
 3052
 3053
 3054                                    /****************************/
 3055                                    /*    SYSTEM  CALLS                                                 */
 3056                                    /****************************/
 3057
 3058      DCL M$EXIT ENTRY(1) CONV(1,2,1);
 3059      DCL M$ERR ENTRY(1) CONV(1,2,2);
 3060      DCL M$XXX ENTRY(1) CONV(1,2,3);
 3061      DCL M$OLAY ENTRY(1) CONV(1,2,4) ALTRET;
 3062      DCL M$LINK ENTRY(1) CONV(1,7,5) ALTRET;
 3063      DCL M$LDTRC ENTRY(1) CONV(1,7,6) ALTRET;
 3064      DCL M$ALIB ENTRY(1) CONV(1,4,7) ALTRET;
 3065      DCL M$DLIB ENTRY(1) CONV(1,1,8) ALTRET;
 3066      DCL M$YC ENTRY(1) CONV(1,3,9) ALTRET;
 3067      DCL M$CPEXIT ENTRY(1) CONV(1,6,10) ALTRET;
 3068      DCL M$SCREECH ENTRY(1) CONV(1,3,11) ALTRET;
 3069      DCL M$FSUSER ENTRY CONV(1,0,12) ALTRET;
 3070      DCL M$ASUSER ENTRY CONV(1,0,13) ALTRET;
 3071      DCL M$DSUSER ENTRY CONV(1,0,14) ALTRET;
07:19 JUL 29 '97 JS_CP6_C.:E05SI                                           84   
 3072      DCL M$SAVE ENTRY(1) CONV(1,4,15) ALTRET;
 3073      DCL M$SCON ENTRY(1) CONV(1,1,16) ALTRET;
 3074      DCL M$INTRTN ENTRY CONV(1,0,17) ALTRET;
 3075      DCL M$XCONRTN ENTRY(1) CONV(1,2,18) ALTRET;
 3076      DCL M$PROCNAME ENTRY(1) CONV(1,5,19) ALTRET;
 3077      DCL M$FINDPROC ENTRY(1) CONV(1,5,20) ALTRET;
 3078      DCL M$ACCT ENTRY(1) CONV(1,5,22) ALTRET;
 3079      DCL M$UNSHARE ENTRY(1) CONV(1,1,21) ALTRET;
 3080
 3081                                    /* END OF EXECUTION CONTROL SERVICE CALL PROCEDURES                 */

