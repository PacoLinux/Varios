

14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          1    
    1      /*M* GM_LCP6_M Macros for Memory Management Services  */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*X* MEC,MOC,EXM=20,CLM=30,CRM=100,XBO=YES,FRA=YES    */
    9
   10                          /*P* NAME: GM_LCP6_M
   11
   12                          The file GM_LCP6_M contains the macros that
   13                          relate to memory management services.  This
   14                          includes:
   15                          }
   16                          }   FPT_GDS
   17                          }   FPT_FDS
   18                          }   FPT_GAUTO
   19                          }   FPT_FAUTO
   20                          }   FPT_GDDL
   21                          }   FPT_PDS
   22                          }   FPT_CVM
   23                          }
   24                          */
   25
   26
   27
   28
   29
   30
   31
   32
   33                          /*F* NAME: Memory Management Services
   34                          ..::L1 "Introduction\\X"
   35                          The appendix of this manual entitled "User Virtual
   36                          Memory" describes in detail the memory
   37                          segmentation and memory protection of user memory.
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          2    
   38                          The following discussion focuses on the concepts
   39                          necessary to perform user dynamic memory
   40                          allocation.
   41                          ..VA$M_FOOTER "\Introduction"
   42
   43                          The virtual memory available for dynamic allocation
   44                          within the users virtual work space includes the
   45                          four dedicated dynamic data segments, the AUTO
   46                          segment, and any IS segments not allocated to
   47                          procedure or static data.
   48
   49                          Dynamic data may be allocated in 256 word (page) increments.
   50                          Two segments have a maximum size of 4096 words each and
   51                          are referred to as the "little data segments".
   52                          The remaining segments may contain up to
   53                          65,536 words each and are referred to as
   54                          the "big data segments".
   55                          Each of these segments may be allocated independently,
   56                          or, where there are two or more contiguous unallocated
   57                          big segments, allocated with two or more segments forming
   58                          a "memory extent".
   59
   60                          These data segments are virtual spaces that may be
   61                          created, enlarged, and deallocated under
   62                          programmer control.  Since data segments are
   63                          addressed independently of the Instruction
   64                          Segment, the user must reference these segments
   65                          via PL-6 pointer variables.  It is suggested that
   66                          the user address these segments by SYMREFs to the
   67                          pointers that are defined in the object unit
   68                          G_UPTRS_D in the :LIBRARY account.  The names of
   69                          the pointers for the little data segments are
   70                          G$DS1$ and G$DS2$.  The pointer for the AUTO
   71                          segment is G$AUTO_DS$ and the pointers for
   72                          the other big data segments are G$DS3$, G$DS4$
   73                          and G$ISR1$ through G$ISR7$.  Note that dynamic allocation
   74                          of the ISR segments is dependent on the size
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          3    
   75                          of the users procedure and static data and therefore
   76                          it is not always possible to know beforehand
   77                          which IS segments will be available.
   78                          */
   79                          /*F* NAME: M$GDS - Get / Enlarge Data Segment
   80
   81                          The M$GDS service provides for allocation
   82                          of memory from an unallocated memory extent in
   83                          the user's virtual memory.
   84                          This service may be used for the initial allocation
   85                          of a memory extent, or to enlarge the current allocation
   86                          of an extent.
   87
   88                          The number of pages to allocate is always specified
   89                          via the PAGES parameter.  The area of memory to be
   90                          allocated may be specified in either the
   91                          VLP_SEGMENT.BASE field of the RESULTS parameter or
   92                          by using the NEXT parameter.
   93
   94                          The form of the call for this service is:
   95
   96                          CALL M$GDS (FPT_GDS) [ALTRET (label)];
   97
   98                          The parameters for this service are as follows:
   99                          */
  100
  101      %MACRO FPT_GDS (FPTN=FPT_GDS,
  102         STCLASS=STATIC,
  103         ALGN=WALIGNED,
  104         VECTORS=YES,
  105         RESULTS=NIL,
  106         PAGES=0,
  107         FREE(YES='1'B,NO='0'B,ANY)='0'B,
  108         PARK(YES='1'B,NO='0'B,ANY)='1'B,
  109         IOBUF(YES='1'B,NO='0'B,ANY)='0'B,
  110         NEXT(EITHER=0,LITTLE=1,BIG=2,ANY)=0);
  111
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          4    
  112      %LSET LISTDIR='0'B;
  113      %LSET LISTEXP='1'B;
  114      %LSET LISTCOM='0'B;
  115      %LSET LISTSUB='1'B;
  116      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  117      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  118      %LSET INIT=CHARTEXT('INIT');
  119      %LSET EINIT=CHARTEXT('');
  120      %ELSE;
  121      %LSET INIT=CHARTEXT('/*');
  122      %LSET EINIT=CHARTEXT('*/');
  123      %ENDIF;
  124
  125      DCL 1 FPTN STCLASS ALGN,
  126
  127      %IF TEXTCHAR(VECTORS)='YES';
  128      %LSET LVL=3;
  129
  130            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  131            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT,
  132                          /*K* RESULTS = VARIABLE specifies the location of
  133                          the area of memory which is used both as an input
  134                          parameter and an output results area.
  135                          The VLP_SEGMENT macro is used to generate this
  136                          area.
  137
  138                          On input, the
  139                          BASE field in this area (VLP_SEGMENT.BASE) is
  140                          used to identify the memory extent to obtain or enlarge.
  141                          If the BASE field is equal to the ADDR (NIL)
  142                          or to zero, then
  143                          the NEXT parameter will be used to determine where
  144                          memory is to be allocated.  Note that
  145                          this is an optional parameter; if not specified,
  146                          the NEXT parameter must be used.
  147
  148                          On normal return from this monitor service request
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          5    
  149                          the VLP_SEGMENT.BASE field will contain a pointer
  150                          to the first page of the allocated extent.
  151                          The VLP_SEGMENT.PAGES field will contain the number
  152                          of pages currently allocated in the memory extent.
  153
  154                          Normally, the VLP_SEGMENT area will not be modified
  155                          upon return when the alternate return is taken.
  156                          See the description of the FREE parameter for
  157                          the exception.
  158
  159                          The default is NIL.
  160                          */
  161            2 V,
  162
  163      %ELSE;
  164
  165      %LSET LVL=2;
  166
  167      %ENDIF;
  168
  169              %LVL %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT,
  170                          /*K* PAGES = VALUE-DEC(0-n) specifies the number
  171                          of pages to obtain.  A value of 0 is considered to
  172                          be a status request, thus no memory will be
  173                          allocated; information reflecting the current
  174                          allocation of the specified memory extent will be
  175                          returned in the area specified via the RESULTS
  176                          parameter.  Default is 0.
  177                          */
  178                %LVL %CHARTEXT('FREE') BIT(1) UNAL %INIT(FREE)%EINIT,
  179                          /*K* FREE = {YES|NO} specifies, if YES, that if
  180                          the requested memory is not available (user or
  181                          installation memory limit reached), then no memory
  182                          at all is to be allocated.
  183
  184                          The default (FREE=NO)
  185                          causes as much memory as possible to be allocated
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          6    
  186                          before taking the alternate return with an error code
  187                          indicating that the entire requested amount was unavailable.
  188                          The VLP_SEGMENT area, as specified via the RESULTS
  189                          parameter, may be inspected to determine how many
  190                          pages were actually allocated.
  191                          */
  192                %LVL %CHARTEXT('PARK') BIT(1) UNAL %INIT(PARK)%EINIT,
  193                          /*N* PARK = {YES|NO} specifies, if NO, that a handler is
  194                          not to be parked by the scheduler when there is
  195                          insufficient physical memory available to satisfy
  196                          the request.  Instead of being parked, the
  197                          ALTRETURN will be taken.  The default (PARK=YES)
  198                          causes the user to be parked by the scheduler
  199                          until the request can be satisfied.
  200
  201                          The option is ignored if the user mode is not HANDLER.
  202                          */
  203                %LVL %CHARTEXT('IOBUF') BIT(1) UNAL %INIT(IOBUF)%EINIT,
  204                          /*K* IOBUF = {YES|NO} specifies, if YES, that the
  205                          physical memory obtained is to come from the the area
  206                          of system memory reserved for I/O buffers.  The
  207                          default (IOBUF=NO) causes the physical memory to
  208                          be obtained from the system area reserved for
  209                          ordinary, i.e., non-I/O buffer, system memory.
  210                          */
  211                %LVL * BIT(5) UNAL %INIT('0'B)%EINIT,
  212                %LVL %CHARTEXT('NEXT') UBIN BYTE UNAL %INIT(NEXT)%EINIT;
  213                          /*K* NEXT = {EITHER|LITTLE|BIG} specifies which
  214                          data area is to be obtained when the BASE field
  215                          in the VLP_SEGMENT area framed by the RESULTS
  216                          parameter is equal to the ADDR (NIL) or to
  217                          zero, or when
  218                          the RESULTS parameter is not specified.  The NEXT
  219                          parameter is ignored if VLP_SEGMENT.BASE is used
  220                          to indicate where memory is to be allocated.
  221
  222                          Specifying LITTLE or BIG causes the next available data
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          7    
  223                          extent with the specified virtual size attribute
  224                          to be selected by memory management.  The default
  225                          (NEXT=EITHER) is used in conjunction with the
  226                          PAGES parameter to select the next available data
  227                          extent with preference given to little data
  228                          segments.
  229                          */
  230      %MEND;
  231
  232
  233
  234
  235
  236                          /*F* NAME: M$FDS - Free / Diminish Data Segment
  237
  238                          The M$FDS service provides for deallocation
  239                          of memory from an allocated memory extent in
  240                          the user's virtual memory.
  241
  242                          The number of pages to released is specified
  243                          via the PAGES parameter.  The area of memory to be
  244                          released is specified in the VLP_SEGMENT.BASE
  245                          field of the RESULTS parameter.
  246
  247                          The form of the call for this service is:
  248
  249                          CALL M$FDS (FPT_FDS) [ALTRET (label)];
  250
  251                          The parameters for this service are as follows:
  252                          */
  253
  254      %MACRO FPT_FDS (FPTN=FPT_FDS,
  255         STCLASS=STATIC,
  256         ALGN=WALIGNED,
  257         VECTORS=YES,
  258         RESULTS=NIL,
  259         PAGES=0);
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          8    
  260
  261      %LSET LISTDIR='0'B;
  262      %LSET LISTEXP='1'B;
  263      %LSET LISTCOM='0'B;
  264      %LSET LISTSUB='1'B;
  265      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  266      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  267      %LSET INIT=CHARTEXT('INIT');
  268      %LSET EINIT=CHARTEXT('');
  269      %ELSE;
  270      %LSET INIT=CHARTEXT('/*');
  271      %LSET EINIT=CHARTEXT('*/');
  272      %ENDIF;
  273
  274      DCL 1 FPTN STCLASS ALGN,
  275
  276      %IF TEXTCHAR(VECTORS)='YES';
  277
  278      %LSET LVL=3;
  279
  280            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  281            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT,
  282                          /*K* RESULTS = VARIABLE specifies the location of
  283                          the area of memory which is used both as an input
  284                          parameter and an output results area.
  285                          The VLP_SEGMENT macro is used to generate this
  286                          area.
  287
  288                          On input, the
  289                          BASE field in this area (VLP_SEGMENT.BASE) is
  290                          used to identify the memory extent to free or diminish.
  291                          On return from this monitor service request
  292                          the VLP_SEGMENT.BASE field will contain a pointer
  293                          to the first page of memory remaining in the extent.
  294                          The VLP_SEGMENT.PAGES field will contain the number
  295                          of pages that remain allocated in the memory extent.
  296
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          9    
  297                          The default is NIL.
  298                          */
  299            2 V,
  300
  301      %ELSE;
  302
  303      %LSET LVL=2;
  304
  305      %ENDIF;
  306              %LVL %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT,
  307                          /*K* PAGES = VALUE-DEC(0-n) specifies the number
  308                          of pages to release.  A value of 0 is considered
  309                          to be a status request, thus no memory will be
  310                          released; information reflecting the current
  311                          allocation of the specified memory extent will be
  312                          returned in the area specified via the RESULTS
  313                          parameter.  Default is 0.
  314                          */
  315                %LVL * BIT(16) UNAL %INIT('0'B)%EINIT;
  316      %MEND;
  317
  318
  319
  320
  321
  322                          /*F* NAME: M$GAUTO - Get / Enlarge Auto Segment
  323
  324                          The M$GAUTO service provides for allocation
  325                          of memory from the AUTO data segment area of
  326                          the user's virtual memory.
  327
  328                          The AUTO data segment area consists of a unique
  329                          data segment in the user's virtual memory.  Memory
  330                          can be allocated or deallocated from the AUTO
  331                          segment only by use of the M$GAUTO and M$FAUTO
  332                          services.
  333
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          10   
  334                          The form of the call for this service is:
  335
  336                          CALL M$GAUTO (FPT_GAUTO) [ALTRET (label)];
  337
  338                          The parameters for this service are as follows:
  339                          */
  340
  341      %MACRO FPT_GAUTO (FPTN=FPT_GAUTO,
  342         STCLASS=STATIC,
  343         ALGN=WALIGNED,
  344         VECTORS=YES,
  345         RESULTS=NIL,
  346         PAGES=0,
  347         FREE(YES='1'B,NO='0'B,ANY)='0'B);
  348
  349      %LSET LISTDIR='0'B;
  350      %LSET LISTEXP='1'B;
  351      %LSET LISTCOM='0'B;
  352      %LSET LISTSUB='1'B;
  353      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  354      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  355      %LSET INIT=CHARTEXT('INIT');
  356      %LSET EINIT=CHARTEXT('');
  357      %ELSE;
  358      %LSET INIT=CHARTEXT('/*');
  359      %LSET EINIT=CHARTEXT('*/');
  360      %ENDIF;
  361
  362      DCL 1 FPTN STCLASS ALGN,
  363
  364      %IF TEXTCHAR(VECTORS)='YES';
  365
  366      %LSET LVL=3;
  367
  368            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  369            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT,
  370                          /*K* RESULTS = VARIABLE specifies the location of
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          11   
  371                          the area of memory where the monitor will return a pointer to the
  372                          first page of memory allocated as well as the
  373                          number of pages that have been allocated.
  374                          The VLP_SEGMENT macro is used to generate this
  375                          area.  The default is NIL.
  376                          */
  377            2 V,
  378
  379      %ELSE;
  380
  381      %LSET LVL=2;
  382
  383      %ENDIF;
  384
  385              %LVL %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT,
  386                          /*K*  PAGES = VALUE-DEC(0-256) specifies the number
  387                          of pages to obtain.  A value of 0 is considered to
  388                          be a status request, thus no memory will be
  389                          allocated.
  390                          The default is 0.
  391                          */
  392                %LVL %CHARTEXT('FREE') BIT(1) %INIT(FREE)%EINIT,
  393                          /*K* FREE = {YES|NO} specifies, if YES, that if
  394                          the requested memory is not available (user or
  395                          installation memory limit reached), then no memory
  396                          at all is to be allocated.  The default (FREE=NO)
  397                          causes as much memory as possible to be allocated
  398                          before returning an error code indicating that the
  399                          entire requested amount was unavailable.
  400                          */
  401                %LVL * BIT(15) UNAL %INIT('0'B)%EINIT;
  402      %MEND;
  403
  404
  405
  406
  407
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          12   
  408                          /*F* NAME: M$FAUTO - Free / Diminish Auto Segment
  409
  410                          The M$FAUTO service provides for deallocation
  411                          of memory from the AUTO data segment area of
  412                          the user's virtual memory.
  413
  414                          The form of the call for this service is:
  415
  416                          CALL M$FAUTO (FPT_FAUTO) [ALTRET (label)];
  417
  418                          The parameters for this service are as follows:
  419                          */
  420
  421      %MACRO FPT_FAUTO (FPTN=FPT_FAUTO,
  422         STCLASS=STATIC,
  423         ALGN=WALIGNED,
  424         VECTORS=YES,
  425         RESULTS=NIL,
  426         PAGES=0);
  427
  428      %LSET LISTDIR='0'B;
  429      %LSET LISTEXP='1'B;
  430      %LSET LISTCOM='0'B;
  431      %LSET LISTSUB='1'B;
  432      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  433      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  434      %LSET INIT=CHARTEXT('INIT');
  435      %LSET EINIT=CHARTEXT('');
  436      %ELSE;
  437      %LSET INIT=CHARTEXT('/*');
  438      %LSET EINIT=CHARTEXT('*/');
  439      %ENDIF;
  440
  441      DCL 1 FPTN STCLASS ALGN,
  442
  443      %IF TEXTCHAR(VECTORS)='YES';
  444
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          13   
  445      %LSET LVL=3;
  446
  447            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  448            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT,
  449                          /*K* RESULTS = VARIABLE specifies the location of
  450                          the area of memory where the monitor will return a pointer to the
  451                          first page of dynamic memory remaining as well as
  452                          the number of pages that remain allocated.
  453                          The VLP_SEGMENT macro is used to generate this
  454                          area.  The default is NIL.
  455                          */
  456            2 V,
  457
  458      %ELSE;
  459
  460      %LSET LVL=2;
  461
  462      %ENDIF;
  463
  464              %LVL %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT,
  465                          /*K*  PAGES = VALUE-DEC(0-256) specifies the number
  466                          of pages to release.  A value of 0 is considered
  467                          to be a status request, thus no memory will be
  468                          released.
  469                          The default is 0.
  470                          */
  471                %LVL * BIT(16) UNAL %INIT('0'B)%EINIT;
  472      %MEND;
  473
  474
  475
  476
  477
  478                          /*F* NAME: M$GDDL - Get Dynamic Data Limits
  479
  480                          The M$GDDL service provides information about
  481                          the current state of the user's memory allocation.
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          14   
  482                          Information is returned in the area of memory
  483                          that is generated by the VLR_GDDL macro.
  484
  485                          The form of the call for this service is:
  486
  487                          CALL M$GDDL (FPT_GDDL) [ALTRET (label)];
  488
  489                          The parameters for this service are as follows:
  490                          */
  491
  492      %MACRO FPT_GDDL (FPTN=FPT_GDDL,
  493         STCLASS=STATIC,
  494         ALGN=WALIGNED,
  495         RESULTS=NIL);
  496
  497      %LSET LISTDIR='0'B;
  498      %LSET LISTEXP='1'B;
  499      %LSET LISTCOM='0'B;
  500      %LSET LISTSUB='1'B;
  501      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  502      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  503      %LSET INIT=CHARTEXT('INIT');
  504      %LSET EINIT=CHARTEXT('');
  505      %ELSE;
  506      %LSET INIT=CHARTEXT('/*');
  507      %LSET EINIT=CHARTEXT('*/');
  508      %ENDIF;
  509
  510      DCL 1 FPTN STCLASS ALGN,
  511            2 RESULTS_ VECTOR %INIT(VECTOR(RESULTS))%EINIT;
  512                          /*K* RESULTS = VARIABLE specifies the location of
  513                          the area of memory into which the informational
  514                          data provided by the M$GDDL service is returned
  515                          to the user.  The VLR_GDDL macro is used to
  516                          generate this area.  The default is NIL.
  517                          */
  518      %MEND;
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          15   
  519
  520
  521
  522
  523
  524                          /*F* NAME: VLR_GDDL
  525
  526                          The VLR_GDDL macro may be used to generate
  527                          the value area that comprises the informational
  528                          data provided by the M$GDDL service.
  529
  530                          Information that is not applicable to the domain
  531                          making the service request will be returned with
  532                          a value of 0.
  533                          */
  534
  535      %MACRO VLR_GDDL (FPTN=VLR_GDDL,
  536         LVL=1,
  537         STCLASS=STATIC,
  538         ALGN=WALIGNED,
  539         LAST(YES=";",NO=",",ANY)=";",
  540         AUTHORIZED=0,
  541         REMAINING=0,
  542         FIRST_DD=0,
  543         NUM_DD=0,
  544         NUM_DD_REM=0,
  545         NEXT_LITTLE=0,
  546         NEXT_BIG=0,
  547         NUM_LITTLE=0,
  548         NUM_BIG=0);
  549
  550      %LSET LISTDIR='0'B;
  551      %LSET LISTEXP='1'B;
  552      %LSET LISTCOM='0'B;
  553      %LSET LISTSUB='1'B;
  554
  555      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          16   
  556      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  557      %LSET INIT=CHARTEXT('INIT');
  558      %LSET EINIT=CHARTEXT('');
  559      %ELSE;
  560      %LSET INIT=CHARTEXT('/*');
  561      %LSET EINIT=CHARTEXT('*/');
  562      %ENDIF;
  563
  564      %IF LVL=1;
  565      DCL 1 FPTN STCLASS ALGN,
  566      %ELSE;
  567              %LVL FPTN,
  568      %ENDIF;
  569
  570                %(LVL+1) %CHARTEXT('AUTHORIZED') UBIN %INIT(AUTHORIZED)%EINIT,
  571                          /*K* AUTHORIZED = VALUE-DEC(0-n)  contains the
  572                          maximum number of physical pages that the user is
  573                          authorized to obtain.
  574                          */
  575                %(LVL+1) %CHARTEXT('REMAINING') UBIN %INIT(REMAINING)%EINIT,
  576                          /*K* REMAINING = VALUE-DEC(0-n)  contains the
  577                          number of physical pages remaining that the user
  578                          may obtain.
  579                          */
  580                %(LVL+1) %CHARTEXT('NEXT_LITTLE') UBIN %INIT(NEXT_LITTLE)%EINIT,
  581                          /*K* NEXT_LITTLE = VALUE-DEC(0-n)  contains the
  582                          logical number of the next little data segment
  583                          that the user may obtain.
  584                          */
  585                %(LVL+1) %CHARTEXT('NEXT_BIG') UBIN %INIT(NEXT_BIG)%EINIT,
  586                          /*K* NEXT_BIG = VALUE-DEC(0-n)  contains the
  587                          logical number of the next big data segment
  588                          that the user may obtain.
  589                          */
  590                %(LVL+1) %CHARTEXT('NUM_LITTLE') UBIN %INIT(NUM_LITTLE)%EINIT,
  591                          /*K* NUM_LITTLE = VALUE-DEC(0-n)  contains the
  592                          number of little data segments that remain
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          17   
  593                          to be allocated.
  594                          */
  595                %(LVL+1) %CHARTEXT('NUM_BIG') UBIN %INIT(NUM_BIG)%EINIT,
  596                          /*K* NUM_BIG = VALUE-DEC(0-n)  contains the
  597                          number of big data segments that remain
  598                          to be allocated.
  599                          */
  600                %(LVL+1) * BIT(32) UNAL %INIT('0'B)%EINIT LAST
  601      %MEND;
  602
  603
  604
  605
  606
  607                          /*F* NAME: M$PDS - Protect Data Segments
  608
  609                          The M$PDS service provides the capability to
  610                          change the memory access protection of a data
  611                          extent.
  612
  613                          The form of the call for this service is:
  614
  615                          CALL M$PDS (FPT_PDS) [ALTRET (label)];
  616
  617                          The parameters for this service are as follows:
  618                          */
  619
  620      %MACRO FPT_PDS (FPTN=FPT_PDS,
  621         STCLASS=STATIC,
  622         ALGN=WALIGNED,
  623         VECTORS=YES,
  624         SEGMENT=NIL,
  625         READ(YES='1'B,NO='0'B,ANY)='1'B,
  626         WRITE(YES='1'B,NO='0'B,ANY)='0'B);
  627
  628      %LSET LISTDIR='0'B;
  629      %LSET LISTEXP='1'B;
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          18   
  630      %LSET LISTCOM='0'B;
  631      %LSET LISTSUB='1'B;
  632      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  633      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  634      %LSET INIT=CHARTEXT('INIT');
  635      %LSET EINIT=CHARTEXT('');
  636      %ELSE;
  637      %LSET INIT=CHARTEXT('/*');
  638      %LSET EINIT=CHARTEXT('*/');
  639      %ENDIF;
  640
  641      DCL 1 FPTN STCLASS ALGN,
  642
  643      %IF TEXTCHAR(VECTORS)='YES';
  644
  645      %LSET LVL=3;
  646
  647            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  648            2 SEGMENT_ VECTOR %INIT(VECTOR(SEGMENT))%EINIT,
  649                          /*K* SEGMENT = VARIABLE specifies the location of
  650                          the area of memory which contains a pointer to
  651                          the data extent for which the memory access
  652                          protection is to be set.
  653                          The VLP_SEGMENT macro is used to generate this
  654                          area.  The default is NIL.
  655                          */
  656            2 V,
  657
  658      %ELSE;
  659
  660      %LSET LVL=2;
  661
  662      %ENDIF;
  663
  664              %LVL %CHARTEXT('READ') BIT(1) %INIT(READ)%EINIT,
  665                          /*K* READ = {YES|NO} specifies whether read access
  666                          is to be permitted or denied.  The default
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          19   
  667                          (READ=YES) causes read access to the specified
  668                          data segment to be permitted.
  669                          */
  670                %LVL %CHARTEXT('WRITE') BIT(1) %INIT(WRITE)%EINIT,
  671                          /*K* WRITE = {YES|NO} specifies whether write
  672                          access is to be permitted or denied.  The default
  673                          (WRITE=NO) causes write access to the specified
  674                          data segment to be denied.
  675                          */
  676                %LVL * BIT(14) UNAL %INIT('0'B)%EINIT;
  677      %MEND;
  678
  679
  680
  681
  682
  683                          /*F* NAME: M$CVM - Change Virtual Map
  684
  685                          The M$CVM service provides for mapping a memory
  686                          segment that does not belong to a user into the
  687                          user's virtual data segment space.
  688                          Access to the segment is set to read-only for a
  689                          user with the Special MM Privilege, and to full
  690                          read/write access for a user with the Extended
  691                          MM Privilege.
  692
  693                          M$CVM may be used to change the segment previously
  694                          mapped via M$CVM without first freeing the virtual
  695                          segment.
  696
  697
  698                          The form of the call for this service is:
  699
  700                          CALL M$CVM (FPT_CVM) [ALTRET (label)];
  701
  702                          The parameters for this service are as follows:
  703                          */
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          20   
  704
  705      %MACRO FPT_CVM (FPTN=FPT_CVM,
  706         STCLASS=STATIC,
  707         ALGN=WALIGNED,
  708         VECTORS=YES,
  709         USERSEG=NIL,
  710         FROMSEG=NIL,
  711         TYPE(MON=0,USER=1,PHYSICAL=2,ANY)=0,
  712         USERID=0,
  713         PAGES=0,
  714         NEXT(EITHER=0,LITTLE=1,BIG=2,ANY)=0);
  715
  716      %LSET LISTDIR='0'B;
  717      %LSET LISTEXP='1'B;
  718      %LSET LISTCOM='0'B;
  719      %LSET LISTSUB='1'B;
  720      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  721      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  722      %LSET INIT=CHARTEXT('INIT');
  723      %LSET EINIT=CHARTEXT('');
  724      %ELSE;
  725      %LSET INIT=CHARTEXT('/*');
  726      %LSET EINIT=CHARTEXT('*/');
  727      %ENDIF;
  728
  729      DCL 1 FPTN STCLASS ALGN,
  730
  731      %IF TEXTCHAR(VECTORS)='YES';
  732
  733      %LSET LVL=3;
  734
  735            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  736            2 USERSEG_ VECTOR %INIT(VECTOR(USERSEG))%EINIT,
  737                          /*K* USERSEG = VARIABLE specifies the location of
  738                          the area of memory which contains a pointer to
  739                          the segment to be mapped into.
  740                          The VLP_SEGMENT macro is used to generate this
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          21   
  741                          area.
  742
  743                          The value in VLP_SEGMENT.BASE is
  744                          used to identify the segment to map into.
  745                          If the BASE field is equal to the ADDR (NIL)
  746                          or to zero, or
  747                          if the USERSEG parameter is not specified, then
  748                          the NEXT parameter is used to
  749                          identify the data segment to map into.  The
  750                          segment located by the USERSEG parameter must be
  751                          currently unallocated or mapped
  752                          by a prior use of M$CVM.
  753                          The default is NIL.
  754                          */
  755            2 FROMSEG_ VECTOR %INIT(VECTOR(FROMSEG))%EINIT,
  756                          /*K* FROMSEG = VARIABLE specifies the location of
  757                          the area of memory which identifies the segment
  758                          to be mapped onto.  The VLP_SEGMENT macro is used
  759                          to generate this area.
  760
  761                          When the TYPE parameter is specified as MON or
  762                          USER, the VLP_SEGMENT.BASE field should contain
  763                          the address of the monitor or user's segment;
  764                          VLP_SEGMENT.PAGES will be ignored.
  765
  766                          Specifying TYPE=PHYSICAL assumes the contents of
  767                          VLP_SEGMENT.PAGES to be interpreted as a real physical
  768                          page number; VLP_SEGMENT.BASE will be ignored.
  769
  770                          The default is NIL.
  771                          */
  772            2 V,
  773
  774      %ELSE;
  775
  776      %LSET LVL=2;
  777
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          22   
  778      %ENDIF;
  779
  780              %LVL %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT,
  781                          /*K* PAGES = VALUE-DEC(0-256) specifies the
  782                          number of pages to map onto.  A value of 0 is
  783                          considered to be a request to unmap a previously
  784                          mapped segment.
  785                          The default is 0.
  786                          */
  787                %LVL %CHARTEXT('TYPE') UBIN BYTE UNAL %INIT(TYPE)%EINIT,
  788                          /*K* TYPE = {MON|USER|PHYSICAL} specifies the type
  789                          of segment that is to be mapped onto. The default
  790                          (TYPE=MON) causes the segment to come from the
  791                          monitor's map.  The specific monitor segment is
  792                          identified by the value of VLP_SEGMENT.BASE as
  793                          located via the FROMSEG parameter.
  794
  795                          Specifying (TYPE=USER) causes the segment to come
  796                          from the map of the user whose user number is
  797                          specified by the USERID parameter.  The specific user
  798                          segment is identified by the value of VLP_SEGMENT.BASE as
  799                          located via the FROMSEG parameter.
  800
  801                          Specifying (TYPE=PHYSICAL) causes the segment to
  802                          come from real physical memory.
  803                          The specific page to map onto is identified by the
  804                          value of VLP_SEGMENT.PAGES as located via the FROMSEG
  805                          parameter.
  806                          */
  807                %LVL %CHARTEXT('USERID') UBIN BYTE UNAL %INIT(USERID)%EINIT,
  808                          /*K* USERID = VALUE-DEC specifies, when TYPE=USER
  809                          the user number of the user to be mapped onto.
  810                          This parameter is ignored if TYPE is not USER.
  811                          The default is 0.
  812                          */
  813                %LVL %CHARTEXT('NEXT') UBIN BYTE UNAL %INIT(NEXT)%EINIT,
  814                          /*K* NEXT = {EITHER|LITTLE|BIG} specifies which
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          23   
  815                          data segment is to be obtained when the BASE field
  816                          in the VLP_SEGMENT area framed by the USERSEG
  817                          parameter is equal to the ADDR (NIL) or
  818                          to zero, or when
  819                          the USERSEG parameter is not specified.  The NEXT
  820                          parameter is ignored if VLP_SEGMENT.BASE is used
  821                          to indicate where memory is to be mapped.
  822
  823                          Specifying LITTLE or BIG causes the next available data
  824                          segment with the specified virtual size attribute
  825                          to be selected by memory management.  The default
  826                          (NEXT=EITHER) is used in conjunction with the
  827                          PAGES parameter to select the next available data
  828                          segment with preference given to little data
  829                          segments.
  830                          */
  831                %LVL * BIT(8) UNAL %INIT('0'B)%EINIT;
  832      %MEND;
  833
  834
  835
  836
  837
  838                          /*F* NAME: VLP_SEGMENT
  839
  840                          The VLP_SEGMENT macro creates a structure that
  841                          frames an area of memory by specifying the address
  842                          of the first word of memory and the size in pages,
  843                          of the area of memory.  This structure is used to
  844                          specify an area of memory in the form required by
  845                          the various memory management services.  Note that
  846                          this structure is not a vector.
  847                          */
  848
  849      %MACRO VLP_SEGMENT (FPTN=VLP_SEGMENT,
  850         LVL=1,
  851         STCLASS=STATIC,
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          24   
  852         ALGN=WALIGNED,
  853         LAST(YES=";",NO=",",ANY)=";",
  854         BASE=0,
  855         PAGES=0);
  856
  857      %LSET LISTDIR='0'B;
  858      %LSET LISTEXP='1'B;
  859      %LSET LISTCOM='0'B;
  860      %LSET LISTSUB='1'B;
  861
  862      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  863      %IF (STR='STA') OR (STR='CON') OR STR = 'EXT';
  864      %LSET INIT=CHARTEXT('INIT');
  865      %LSET EINIT=CHARTEXT('');
  866      %ELSE;
  867      %LSET INIT=CHARTEXT('/*');
  868      %LSET EINIT=CHARTEXT('*/');
  869      %ENDIF;
  870
  871      %IF LVL=1;
  872      DCL 1 FPTN STCLASS ALGN,
  873      %ELSE;
  874              %LVL FPTN,
  875      %ENDIF;
  876
  877                %(LVL+1) %CHARTEXT('BASE') UBIN(32) %INIT(BASE)%EINIT,
  878                          /*K* BASE = {VARIABLE|VALUE-DEC(0-n)}
  879                          specifies the virtual address of the first
  880                          word of the memory extent.
  881                          The field name for this parameter is
  882                          VLP_SEGMENT.BASE$ or VLP_SEGMENT.BASE.
  883                          The default is NIL.
  884                          */
  885                %(LVL+1) BASE$ REDEF %CHARTEXT('BASE') PTR,
  886                %(LVL+1) %CHARTEXT('PAGES') UBIN %INIT(PAGES)%EINIT LAST
  887                          /*K* PAGES = VALUE-DEC(0-n) specifies the size
  888                          of the memory extent in pages.
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          25   
  889                          The default is 0.
  890                          */
  891      %MEND;
  892
  893
  894
  895
  896
  897                          /*P* NAME: GM_MCL_E
  898
  899                          The GM_MCL_E macro generates the specific values
  900                          for the individual monitor service requests within
  901                          the GM Functional Code Group.
  902                          */
  903
  904      %MACRO GM_MCL_E;
  905      %EQU G_MCL_GDD#   = %G_FCG_M#*64 + 0;
  906      %EQU G_MCL_FDD#   = %G_FCG_M#*64 + 1;
  907      %EQU G_MCL_GDS#   = %G_FCG_M#*64 + 2;
  908      %EQU G_MCL_FDS#   = %G_FCG_M#*64 + 3;
  909      %EQU G_MCL_GAUTO# = %G_FCG_M#*64 + 4;
  910      %EQU G_MCL_FAUTO# = %G_FCG_M#*64 + 5;
  911      %EQU G_MCL_GDDL#  = %G_FCG_M#*64 + 6;
  912      %EQU G_MCL_PDS#   = %G_FCG_M#*64 + 7;
  913      %EQU G_MCL_CVM#   = %G_FCG_M#*64 + 8;
  914      %MEND;
  915
  916
  917
  918
  919
  920                          /*P* NAME: GM$ENTS
  921
  922                          The GM$ENTS macro generates the ENTRY declarations
  923                          for the Monitor Services belonging to the GM
  924                          Functional Code Group.
  925                          */
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          26   
  926
  927      %MACRO GM$ENTS;
  928      DCL M$GDS   ENTRY(1) CONV(1,2,%G_MCL_GDS#)   ALTRET;
  929      DCL M$FDS   ENTRY(1) CONV(1,2,%G_MCL_FDS#)   ALTRET;
  930      DCL M$GAUTO ENTRY(1) CONV(1,2,%G_MCL_GAUTO#) ALTRET;
  931      DCL M$FAUTO ENTRY(1) CONV(1,2,%G_MCL_FAUTO#) ALTRET;
  932      DCL M$GDDL  ENTRY(1) CONV(1,1,%G_MCL_GDDL#)  ALTRET;
  933      DCL M$PDS   ENTRY(1) CONV(1,2,%G_MCL_PDS#)   ALTRET;
  934      DCL M$CVM   ENTRY(1) CONV(1,3,%G_MCL_CVM#)   ALTRET;
  935      %MEND;
  936
  937
  938
  939
  940
  941                          /*P* NAME: GM$HANDLERS
  942
  943                          The GM$HANDLERS macro generates the ENTRY declarations
  944                          for the GM MCL handlers.
  945                          */
  946
  947      %MACRO GM$HANDLERS;
  948      DCL GMM$MCL ENTRY(1) ALTRET;
  949      %MEND;
  950
  951
  952
  953
  954
  955                          /*P* NAME: GM_FPTS
  956
  957                          The GM_FPTS macro provides the LCP-6 monitor services
  958                          decoder with the information required to build the
  959                          segment descriptors and pointers for each FPT within
  960                          the GM Functional Code Group.
  961                          */
  962
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          27   
  963      %MACRO GM_FPTS (FPTN=GM_FPTS);
  964
  965      /* Generate the FCG_GM header word */
  966
  967      %GUD_FCG_INFO (FPTN=FPTN,C=%G_MCL_CVM#,HAND=GMM$MCL);
  968
  969      /* Generate the data for FPT_GDD */
  970
  971      %GUD_MCL_INFO (C=%G_MCL_GDD#,V=2);
  972      /* Parameter 1: V_ */
  973      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
  974      /* Parameter 2: RESULTS_ */
  975      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=NO,TYP=LPAR,WRT=YES);
  976
  977      /* Generate the data for FPT_FDD */
  978
  979      %GUD_MCL_INFO (C=%G_MCL_FDD#,V=2);
  980      /* Parameter 1: V_ */
  981      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
  982      /* Parameter 2: RESULTS_ */
  983      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=NO,TYP=LPAR,WRT=YES);
  984
  985      /* Generate the data for FPT_GDS */
  986
  987      %GUD_MCL_INFO (C=%G_MCL_GDS#,V=2);
  988      /* Parameter 1: V_ */
  989      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
  990      /* Parameter 2: RESULTS_ */
  991      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=YES,TYP=LPAR,WRT=NO);
  992
  993      /* Generate the data for FPT_FDS */
  994
  995      %GUD_MCL_INFO (C=%G_MCL_FDS#,V=2);
  996      /* Parameter 1: V_ */
  997      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
  998      /* Parameter 2: RESULTS_ */
  999      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=NO,TYP=LPAR,WRT=YES);
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          28   
 1000
 1001      /* Generate the data for FPT_GAUTO */
 1002
 1003      %GUD_MCL_INFO (C=%G_MCL_GAUTO#,V=2);
 1004      /* Parameter 1: V_ */
 1005      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
 1006      /* Parameter 2: RESULTS_ */
 1007      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=NO,TYP=LPAR,WRT=YES);
 1008
 1009      /* Generate the data for FPT_FAUTO */
 1010
 1011      %GUD_MCL_INFO (C=%G_MCL_FAUTO#,V=2);
 1012      /* Parameter 1: V_ */
 1013      %GUD_VECT_INFO (ALIGN=WD,BND=3,MAND=YES,TYP=LPAR,WRT=NO);
 1014      /* Parameter 2: RESULTS_ */
 1015      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=NO,TYP=LPAR,WRT=YES);
 1016
 1017      /* Generate the data for FPT_GDDL */
 1018
 1019      %GUD_MCL_INFO (C=%G_MCL_GDDL#,V=1);
 1020      /* Parameter 1: RESULTS_ */
 1021      %GUD_VECT_INFO (ALIGN=WD,BND=13,MAND=YES,TYP=LPAR,WRT=YES);
 1022
 1023      /* Generate the data for FPT_PDS */
 1024
 1025      %GUD_MCL_INFO (C=%G_MCL_PDS#,V=2);
 1026      /* Parameter 1: V_ */
 1027      %GUD_VECT_INFO (ALIGN=WD,BND=1,MAND=YES,TYP=LPAR,WRT=NO);
 1028      /* Parameter 2: SEGMENT_ */
 1029      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=YES,TYP=LPAR,WRT=NO);
 1030
 1031      /* Generate the data for FPT_CVM */
 1032
 1033      %GUD_MCL_INFO (C=%G_MCL_CVM#,V=3);
 1034      /* Parameter 1: V_ */
 1035      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=YES,TYP=LPAR,WRT=NO);
 1036      /* Parameter 2: USERSEG_ */
14:35 JUL 28 '97 GM_LCP6_M.:E05SI                                          29   
 1037      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=YES,TYP=LPAR,WRT=NO);
 1038      /* Parameter 3: FROMSEG_ */
 1039      %GUD_VECT_INFO (ALIGN=WD,BND=5,MAND=YES,TYP=LPAR,WRT=NO);
 1040
 1041      %MEND;

