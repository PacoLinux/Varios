

07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           1    
    1      /*M*  UE_CP6_C   FPT Macros for User Exceptional Condition PMMEs */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100                */
    8
    9                          /*F* NAME: Exceptional Condition Services.
   10                          ..::L1 "Introduction to Exceptional Condition Services\\X"
   11                          The monitor services described in this section
   12                          allow the user program to take control at a
   13                          specific location for processing whenever an
   14                          exceptional condition occurs.  Also described in
   15                          this section are services that allow the program
   16                          to return after processing the exceptional
   17                          condition and to simulate and test certain of the
   18                          conditions.
   19
   20                          An exceptional condition is defined as an event
   21                          that causes an interruption of the normal flow of
   22                          program execution, such as program exit or abort,
   23                          timer run-out, no-wait I/O completion, monitor
   24                          service request errors, etc.
   25                          ..::L1 "Establishing Exceptional Condition Control\\X"
   26                          Exceptional condition control may be established
   27                          for each of these four domains:  Command
   28                          Processor (CP), Debugger (DELTA),
   29                          Alternate Shared Library (ASL) and user.
   30                          A domain establishes its
   31                          exceptional condition controls by issuing the
   32                          following service requests:
   33
   34                          TU
   35                            Any monitor service    To take control when the monitor detects an
   36                            call with ALTRET       error on any monitor service request.
   37
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           2    
   38                            M$TRAP                 To take control of machine traps and errors
   39                                                   on monitor service calls when ALTRET is not
   40                                                   specified.
   41
   42                            M$STIMER               To take control after a time interval.
   43
   44                            M$INT                  To take control of a terminal "Break" key-in.
   45
   46                            M$EVENT                To take control on completion of an event,
   47                                                   such as no-wait I/O completion.
   48
   49                            M$XCON                 To take control of program exits or aborts.
   50
   51                          TF
   52
   53                          These services simply establish the entry point to
   54                          receive control when the condition occurs.  The
   55                          services listed first take precedence over the
   56                          M$XCON request for control.  For instance, if the
   57                          user requests control at a specific trap
   58                          condition, the M$TRAP procedure takes control;
   59                          otherwise, the system passes control to the exit
   60                          procedure if the same fault occurs.  The exit
   61                          procedure receives control at a variety of other
   62                          conditions as well:  exceeding LIMIT card
   63                          specifications, operator aborts, line hangups, and
   64                          program exits.
   65                          */
   66                          /*F* NAME: B$ECCB - Exceptional Condition Control Block
   67
   68                          The monitor maintains an Exceptional Condition
   69                          Control Block (ECCB) for each of the domains
   70                          in the user's Read-Only Segment. The ECCB contains
   71                          the entry points of the procedure to be entered when
   72                          one of the Exceptional Condition occurs.  It also
   73                          contains a word of control flags.
   74
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           3    
   75                          The %B$ECCB macro may be used to generate a BASED structure
   76                          of the ECCB.  The pointer to this structure (B$ECCB$) may be
   77                          obtained by SYMREFing B$ECCB$ and LINKing with B_USRPTRS_D
   78                          in :LIBRARY.  The format of this structure can be found
   79                          in Appendix A.  The sub-fields within B$ECCB have the
   80                          following meaning:
   81                          */
   82      %MACRO B$ECCB (NAME=B$ECCB,STCLASS=BASED);
   83
   84      DCL 1 NAME STCLASS ALIGNED,
   85            2 STIMER UBIN(18) UNAL,
   86                          /*K*  B$ECCB.STIMER  contains the address of the
   87                          procedure to be entered after a time
   88                          interval.
   89                          */
   90            2 EVENT UBIN(18) UNAL,
   91                          /*K*  B$ECCB.EVENT  contains the address of the
   92                          procedure to be entered on event completion.
   93                          */
   94            2 BRK UBIN(18) UNAL,
   95                          /*K*  B$ECCB.BRK  contains the address of the
   96                          procedure to be entered on break
   97                          key interrupt.
   98                          */
   99            2 XCON UBIN(18) UNAL,
  100                          /*K*   B$ECCB.XCON  contains the address of the
  101                          procedure to be entered for exit control
  102                          processing.
  103                          */
  104            2 PMME UBIN(18) UNAL,
  105                          /*K*   B$ECCB.PMME  contains the address of the
  106                          procedure to be entered on Monitor Service Request
  107                          errors when ALTRET is not specified on the Service
  108                          Request call.
  109                          */
  110            2 ARITH UBIN(18) UNAL,
  111                          /*K*   B$ECCB.ARITH  contains the address of the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           4    
  112                          procedure to be entered on machine faults
  113                          of the ARITHMETIC class.
  114                          */
  115            2 PROG UBIN(18) UNAL,
  116                          /*K*   B$ECCB.PROG  contains the address of the
  117                          procedure to be entered on machine faults of
  118                          the PROGRAMMED class.
  119                          */
  120            2 ERR UBIN(18) UNAL,
  121                          /*K*   B$ECCB.ERR  contains the address of the
  122                          procedure to be entered on machine faults of
  123                          the ERROR class.
  124                          */
  125            2 FLAGS,
  126                          /*K*   B$ECCB.FLAGS is a 9 bit field that
  127                          contains bit settings used to indicate
  128                          the user's request for Exceptional
  129                          Condition control as follows:
  130                          */
  131              3 TMRSET BIT(1) UNAL,
  132                          /*K*   B$ECCB.FLAGS.TMRSET = VALUE-BIT(1).  When
  133                          set indicates control after a timer interval
  134                          has been established via M$STIMER.
  135                          */
  136              3 EVTSET BIT(1) UNAL,
  137                          /*K*   B$ECCB.FLAGS.EVTSET = VALUE-BIT(1).  When
  138                          set indicates that control at event completion
  139                          has been established via M$EVENT.
  140                          */
  141              3 BRKSET BIT(1) UNAL,
  142                          /*K*   B$ECCB.FLAGS.BRKSET = VALUE-BIT(1).  When
  143                          set indicates that control over the
  144                          break key interrupt has been established via
  145                          M$INT.
  146                          */
  147              3 XCONSET BIT(1) UNAL,
  148                          /*K*   B$ECCB.FLAGS.XCONSET = VALUE-BIT(1).  When
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           5    
  149                          set indicates that Exit Control has been
  150                          established via M$XCON.
  151                          */
  152              3 PMMESET BIT(1) UNAL,
  153                          /*K*   B$ECCB.FLAGS.PMMESET = VALUE-BIT(1).  When set
  154                          indicates that control over monitor service
  155                          errors has been established via M$TRAP.
  156                          */
  157              3 ARTHSET BIT(1) UNAL,
  158                          /*K*   B$ECCB.FLAGS.ARTHSET = VALUE-BIT(1).  When
  159                          set indicates that control over the Arithmetic
  160                          class of faults has been established via M$TRAP.
  161                          */
  162              3 PROGSET BIT(1) UNAL,
  163                          /*K*   B$ECCB.FLAGS.PROGSET = VALUE-BIT(1).  When
  164                          set indicates that control over the Programmed
  165                          class of faults has been established via M$TRAP.
  166                          */
  167              3 ERRSET BIT(1) UNAL,
  168                          /*K*   B$ECCB.FLAGS.ERRSET = VALUE-BIT(1).  When set
  169                          indicates that control over the Error class of
  170                          faults has been established via M$TRAP.
  171                          */
  172              3 YCSET BIT(1) UNAL,
  173                          /*K*   B$ECCB.FLAGS.YCSET = VALUE-BIT(1).  When
  174                          set indicates that control over the
  175                          Control-Y GO sequence has been established via
  176                          M$EVENT.
  177                          */
  178            2 XCONF,
  179                          /*K*   B$ECCB.XCONF is used to indicate the
  180                          Exit Control conditions on a domain
  181                          basis as follows:
  182                          */
  183              3 PROG BIT(1) UNAL,
  184                          /*K*   B$ECCB.XCONF.PROG = VALUE-BIT(1).  When set
  185                          indicates that the executing program is in the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           6    
  186                          exit status.
  187                          */
  188              3 NOTCB BIT(1) UNAL,
  189                          /*K*   B$ECCB.XCONF.NOTCB = VALUE-BIT(1).  When set
  190                          indicates that the Task Control Block is full.
  191                          */
  192              3 LIMIT BIT(1) UNAL,
  193                          /*K*   B$ECCB.XCONF.LIMIT = VALUE BIT(1).  When set
  194                          indicates that limits have been incremented
  195                          for exit control processing.
  196                          */
  197              3 CL3 BIT(1) UNAL,
  198                          /*K*   B$ECCB.XCONF.CL3 = VALUE-BIT(1).  When set
  199                          indicates that a Class 3 Exit Control condition
  200                          is in progress.
  201                          */
  202              3 SVLDT BIT(1) UNAL,
  203                                    /* Used by the monitor to indicate exit control
  204                                       for LDTRC or SAVE has been completed
  205                                    */
  206              3 LNK BIT(1) UNAL,
  207                          /*K*   B$ECCB.XCONF.LNK = VALUE-BIT(1).  When set
  208                          indicates that exit control is in progress
  209                          for M$LDTRC.
  210                          */
  211              3 SAVE BIT(1) UNAL,
  212                          /*K*   B$ECCB.XCONF.SAVE = VALUE-BIT(1).  When set
  213                          indicates that exit control is in progress
  214                          for M$SAVE.
  215                          */
  216              3 CPSAVE BIT(1) UNAL,
  217                          /*K*   B$ECCB.XCONF.CPSAVE = VALUE-BIT(1).  When set
  218                          indicates that exit control is in progress for
  219                          SAVE from a Command Processor.
  220                          */
  221              3 GET BIT(1) UNAL,
  222                          /*K*   B$ECCB.XCONF.GET = VALUE BIT(1).  When set
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           7    
  223                          indicates that exit control is in progress for
  224                          GET.
  225                          */
  226            2 FLTFLG,
  227                          /*K*   B$ECCB.FLTFLG contains bit settings
  228                          to indicate which of the hardware
  229                          faults are under the control of the
  230                          user.
  231                          */
  232              3 OVFL BIT(1) UNAL,
  233                          /*K*   B$ECCB.FLTFLG.OVFL = VALUE-BIT(1).  When set
  234                          indicates that control over Overflow faults
  235                          has been established.
  236                          */
  237              3 DCHK BIT(1) UNAL,
  238                          /*K*   B$ECCB.FLTFLG.DCHK = VALUE-BIT(1).  When set
  239                          indicates that control over Divide-check faults
  240                          has been established.
  241                          */
  242              3 MME BIT(1) UNAL,
  243                          /*K*   B$ECCB.FLTFLG.MME = VALUE-BIT(1).  When set
  244                          indicates that control over MME faults has
  245                          been established.
  246                          */
  247              3 DERL BIT(1) UNAL,
  248                          /*K*   B$ECCB.FLTFLG.DERL = VALUE-BIT(1).  When set
  249                          indicates that control over Derail faults
  250                          has been established.
  251                          */
  252              3 FALT BIT(1) UNAL,
  253                          /*K*   B$ECCB.FLTFLG.FALT = VALUE-BIT(1).  When
  254                          set indicates that control over Fault-tag faults
  255                          has been established.
  256                          */
  257              3 * BIT(3) UNAL,
  258              3 SEC1 BIT(1) UNAL,
  259                          /*K*   B$ECCB.FLTFLG.SEC1 = VALUE-BIT(1).  When set
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           8    
  260                          indicates that control over Security faults,
  261                          Class 1, has been established.
  262                          */
  263              3 MEM BIT(1) UNAL,
  264                          /*K*   B$ECCB.FLTFLG.MEM = VALUE-BIT(1).  When set
  265                          indicates that control over Memory faults
  266                          has been established.
  267                          */
  268              3 COMM BIT(1) UNAL,
  269                          /*K*   B$ECCB.FLTFLG.COMM = VALUE-BIT(1).  When set
  270                          indicates that control over Command faults
  271                          has been established.
  272                          */
  273              3 LOCK BIT(1) UNAL,
  274                          /*K*   B$ECCB.FLTFLG.LOCK = VALUE-BIT(1).  When set
  275                          indicates that control over Lock-up faults
  276                          has been established.
  277                          */
  278              3 IPR BIT(1) UNAL,
  279                          /*K*   B$ECCB.FLTFLG.IPR = VALUE-BIT(1).  When set
  280                          indicates that control over Illegal Procedure
  281                          faults has been established.
  282                          */
  283              3 MSEG BIT(1) UNAL,
  284                          /*K*   B$ECCB.FLTFLG.MSEG = VALUE-BIT(1).  When set
  285                          indicates that control over Missing Segment
  286                          faults has been established.
  287                          */
  288              3 MPG BIT(1) UNAL,
  289                          /*K*   B$ECCB.FLTFLG.MPG = VALUE-BIT(1).  When set
  290                          indicates that control over Missing Page faults
  291                          has been established.
  292                          */
  293              3 SEC2 BIT(1) UNAL,
  294                          /*K*   B$ECCB.FLTFLG.SEC2 = VALUE-BIT(1).  When set
  295                          indicates that control over Security faults,
  296                          Class 2, has been established.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           9    
  297                          */
  298              3 HDWR BIT(1) UNAL,
  299                          /*K*   B$ECCB.FLTFLG.HDWR = VALUE-BIT(1).  When set
  300                          indicates that control over Hardware faults
  301                          has been established.
  302                          */
  303              3 HREG BIT(1) UNAL;
  304                          /*K*   B$ECCB.FLTFLG.HREG = VALUE-BIT(1).  When set
  305                          indicates that the History Registers are to
  306                          be placed in the user's Task Control Block
  307                          on entry to the fault handler procedure.
  308                          */
  309      %MEND;
  310
  311
  312                          /*P*  NAME:  B$ECCBI  .
  313
  314                          B$ECCBI is an alternate based structure for the ECCB.
  315                          This structure allows the entry addresses
  316                          and control flags to be accessed by using the
  317                          Exceptional Condition Code (ECC)  as an index
  318                          into the ECCB.
  319
  320                          */
  321      /* B$ECCBI is used only be the monitor  -  Not to be included in CP-6 Mon Serv Manual  */
  322      %MACRO B$ECCBI (NAME=B$ECCBI,STCLASS=BASED);
  323      DCL 1 NAME STCLASS ALIGNED,
  324            2 ECIC(0:7) UBIN(18) UNAL, /* ENTRY ADDRESSES                                               */
  325            2 FLAGS(0:35) BIT(1) UNAL; /* CONTROL FLAGS                                                 */
  326      %MEND;
  327
  328
  329
  330                          /*P* NAME: SUB_EXC
  331                          */
  332
  333      %MACRO SUB_EXC;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           10   
  334      %EQU ECC_TIMER#=0/*ECC_TIMER#*/;
  335      %EQU ECC_EVENT#=1/*ECC_EVENT#*/;
  336      %EQU ECC_INT#=2/*ECC_INT#*/;
  337      %EQU ECC_XCON#=3/*ECC_XCON#*/;
  338      %EQU ECC_PMME#=4/*ECC=PMME#*/;
  339      %EQU ECC_ARITH#=5/*ECC_ARITH#*/;
  340      %EQU ECC_PROG#=6/*ECC_PROG#*/;
  341      %EQU ECC_ERROR#=7/*ECC_ERROR#*/;
  342      %EQU ECC_TCBFULL#=98/*ECC_TCBFULL#*/;
  343      %EQU ECC_ALT#=99/*ECC_ALT#*/;
  344
  345      /*DEFINITION OF B$EXCFR.SUBC FOR ECC=ECC_EVENT# */
  346      %EQU SUBC_ENQ#=0/*SUBC_ENQ#*/;
  347      %EQU SUBC_IO#=1/*SUBC_IO#*/;
  348      %EQU SUBC_COOP#=2/*SUBC_COOP#*/;
  349      %EQU SUBC_JRNLERR#=3/*SUBC_JRNLERR*/;
  350      %EQU SUBC_YC#=4/*SUBC_YC*/;
  351      %EQU SUBC_FPRG#=5/*SUBC_FPRG*/;
  352      %EQU SUBC_COMIO#=6/*SUBC_COMIO*/;
  353
  354      /*DEFINITION OF B$FPRG.SUBC2 FOR ECC=ECC_EVENT# AND SUBC=SUBC_FPRG# */
  355      %EQU SUBC2_FPEXIT#=0/*SUBC2_FPEXIT*/;
  356      %EQU SUBC2_FPABORT#=1/*SUBC2_FPABORT*/;
  357      %EQU SUBC2_FPLDTRC#=2/*SUBC2_FPLDTRC*/;
  358      %EQU SUBC2_AFD#=3/*SUBC2_AFD*/; /* This goes to the debugger only                                 */
  359
  360      /*DEFINITION OF B$COMIO.SUBC2 FOR ECC=ECC_EVENT# AND SUBC=SUBC_COMIO# */
  361      %EQU SUBC2_DATA_RQS#=1/*SUBC2_DATA_RQS*/;
  362      %EQU SUBC2_DATA_AVL#=2/*SUBC2_DATA_AVL*/;
  363      %EQU SUBC2_CLS_DCB#=3;
  364      %EQU SUBC2_OPN_DCB#=4;
  365      %EQU SUBC2_IN_CALL#=5;
  366      %EQU SUBC2_BREAK#=6;
  367
  368      /*DEFINITION OF B$FLT.SUBC FOR ECC=ECC_ARITH#  */
  369      %EQU SUBC_OVRF#=0/*SUBC_OVRF#*/;
  370      %EQU SUBC_DVCHK#=1/*SUBC_DVCHK#*/;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           11   
  371
  372      /*DEFINITION OF B$FLT.SUBC FOR ECC=ECC_PROG#  */
  373      %EQU SUBC_MME#=0/*SUBC_MME#*/;
  374      %EQU SUBC_DRAIL#=1/*SUBC_DRAIL#*/;
  375      %EQU SUBC_FLTAG#=2/*SUBC_FLTAG#*/;
  376
  377      /*DEFINITION OF B$FLT.SUBC FOR ECC=ECC_ERR#   */
  378      %EQU SUBC_MEMORY#=0/*SUBC_MEMORY#*/;
  379      %EQU SUBC_CMMD#=1/*SUBC_CMMD#*/;
  380      %EQU SUBC_LOCKUP#=2/*SUBC_LOCKUP#*/;
  381      %EQU SUBC_IPR#=3/*SUBC_IPR#*/;
  382      %EQU SUBC_MSEG#=4/*SUBC_MSEG#*/;
  383      %EQU SUBC_MPAGE#=5/*SUBC_MPAGE#*/;
  384      %EQU SUBC_SEC2#=6/*SUBC_SEC2#*/;
  385      %EQU SUBC_PRTY#=7/*SUBC_PRTY#*/;
  386      %EQU SUBC_OPNC#=8/*SUBC_OPNC#*/;
  387      %EQU SUBC_SEC1#=9/*SUBC_SEC1#*/;
  388      %EQU SUBC_DLNK#=10/*SUBC_DLNK#*/;
  389      %EQU SUBC_VIRTERR#=12;
  390      %EQU SUBC_MWSP#=11/*SUBC_MWSP#*/;
  391
  392      %MEND;
  393
  394
  395
  396                          /*F* NAME: Saving the Exceptional Condition Environment
  397
  398                          When an exceptional condition occurs over which
  399                          the user requested control, the system saves the
  400                          environment of the interrupted program.  This
  401                          action enables the user to return to the point of
  402                          interruption and resume normal processing, if the
  403                          user determines that this is possible.
  404
  405                          When an exceptional condition processing procedure
  406                          is entered, the environment of the interrupted
  407                          program as well as information specific to the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           12   
  408                          exceptional condition is stored in the program
  409                          Task Control Block (TCB).  The TCB for the user
  410                          program or standard shared processor is in the
  411                          read-only segment.  The TCB consists of two parts:
  412
  413                            1.  A fixed area for the program environment when an ALTRET
  414                                code sequence is to be entered following a monitor
  415                                service request.
  416
  417                            2.  An Exceptional Condition Stack containing one or more
  418                                frames.  A frame is allocated, filled with the program
  419                                environment from the Safe-Store Stack, and pushed
  420                                onto the top of the stack for each exceptional condition.
  421                                The stack is "popped" (that is, the top frame is released)
  422                                by the user after the exceptional condition is processed.
  423
  424                          The environment includes an Exceptional Condition
  425                          Code (ECC) and an Exceptional Condition Sub-code.
  426                          The values for the ECCs and Sub-codes are defined
  427                          in the %SUB_EXC macro.  The ECC indicates the
  428                          type of condition that occurred. (See Table 6-1).
  429                          .trf ~#
  430                          ..::TB "Exceptional Condition Codes\    ECC\#9\Value\#3\Meaning\#"
  431                          %ECC_TIMER~# 0#Timer run-out
  432                          %ECC_EVENT~# 1#Event Completion
  433                          %ECC_INT~# 2#Time-sharing terminal BRK key-in
  434                          %ECC_XCON~# 3#Exit condition, normal or abnormal
  435                          %ECC_PMME~# 4#Monitor service error without ALTRET (a)
  436                          %ECC_ARITH~# 5#Arithmetic fault
  437                          %ECC_PROG~# 6#Programmed fault
  438                          %ECC_ERROR~# 7#Errors fault
  439                          %ECC_TCBFULL~#98#Insufficient space in TCB stack to
  440                          ##allocate an Exceptional Condition frame (b)
  441                          %ECC_ALT~#99#Monitor services error with ALTRET specified
  442                           
  443                          .trf ~~
  444
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           13   
  445                             a  Differs from ALTRET processing in that the environment
  446                                is saved in an Exceptional Condition Stack frame in this case.
  447                                Otherwise the exit procedure takes control if the user
  448                                requested exit control.
  449
  450                             b  Environment is saved in the ALTRET frame of the TCB.
  451                          ..::TB
  452                          The Exceptional Condition Sub-codes defined in
  453                          the %SUB_EXC macro will be discussed later in
  454                          this section.
  455
  456                          Figure 6-1 illustrates the TCB, the position of
  457                          the exceptional condition stack and the layout of
  458                          the exceptional condition frame and the ALTRET
  459                          frame.  (The minimum size of the exceptional
  460                          condition stack is 68 words; the minimum size of
  461                          the TCB is 140 words.)
  462
  463                          In addition to the 64-word environment from the
  464                          Safe-Store Stack, the system stores four or more words
  465                          of information describing the condition that
  466                          occurred.  The system then transfers control to the
  467                          exceptional condition procedures.
  468
  469                          NOTE:  If there is insufficient space in the
  470                          exceptional condition stack to contain the
  471                          environment when a condition occurs, the monitor
  472                          places the environment in the TCB ALTRET frame.
  473                          The monitor then performs a program exit; exit
  474                          control processing (if established) is entered.
  475                          ..::IX "TCB"
  476                          ..::HL ".BRN 54"
  477                          ..::FG "TCB, ALTRET Frame, Exception Condition Stack Frame\40"
  478                          }          -----------------------------------
  479                          }        /|           PTR TO ALTRET FRAME     |     0------------|
  480                          }CONTROL| |___________________________________|   / |   |ECC(=99)|
  481                          }WORDS  | |   PTR TO CURRENT EXC. COND. FRAME |  |  |____________|
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           14   
  482                          }       < |___________________________________|  |  |ENVIRONMENT |
  483                          }       | |SIZE OF UNUSED  | SIZE OF CURRENT  |  |  |   FROM     |
  484                          }       | |EXC. COND. STACK| EXC. COND. FRAME |  |63|SAFE-STORE  |
  485                          }        \|___________________________________|\ |  |____________|
  486                          }        /|      0         |    ECC(=99)      || |64|    | SUB-  |
  487                          }       < |-----------------------------------|> <  |____________|
  488                          }ALTRET | |       PMME ENVIRONMENT            || |65|   DCB#     |
  489                          }FRAME   \|___________________________________|/ |  |____________|
  490                          }        /|       0         |   ECC           |  |66|ERROR CODE  |
  491                          }       | |-----------------------------------|  |  |____________|
  492                          }       | |                                   |  |67|#PARAMS(=0) |
  493                          }       | |       EXCEPTIONAL CONDITION       |   \ |____________|
  494                          }       | |              FRAME 1              |
  495                          }       | |___________________________________|
  496                          }       | | SIZE OF FRAME 1  |     ECC        |    0|____________|
  497                          }       | |-----------------------------------|   / |     |______|
  498                          }EXCEP- | |       EXCEPTIONAL CONDITION       |  |  |ENVIRONMENT |
  499                          }TION   | |            FRAME 2                |  |  |   FROM     |
  500                          }CONDI- < |___________________________________|  |63|SAFE-STORE  |
  501                          }TION   | |                                   |  |  |____________|
  502                          }STACK  | |___________________________________|\ |64|   | SUB    |
  503                          }       | | SIZE OF FRAMEn-1 |     ECC        || |  |____________|
  504                          }       | |-----------------------------------|| <65|____________|
  505                          }       | |        EXCEPTIONAL CONDITION      |> |  |            |
  506                          }       | |                FRAMEn             || |66|____________|
  507                          }       | |                                   || |67|#PARAMS     |
  508                          }       | |___________________________________|/ |  |____________|
  509                          }       | |                                   |  |68|CONDITION   |
  510                          }       | |     UNUSED STACK FRAME            |  |  |SPECIFIC    |
  511                          }       | |                                   |  |  |INFORMATION |
  512                          }        \|___________________________________|   \ |____________|
  513                          ..::FG
  514                          */
  515                          /*F* NAME: B$TCB
  516                          The %B$TCB macro may be used to generate a based
  517                          structure for accessing data on the TCB.  Sub-fields
  518                          in this structure are as follows:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           15   
  519
  520                          */
  521
  522      %MACRO B$TCB (NAME=B$TCB,STCLASS=BASED,ALIGNED=ALIGNED);
  523
  524      DCL 1 NAME STCLASS ALIGNED,
  525            2 ALT$ PTR,
  526                          /*K*  B$TCB.ALT$ = PTR.  Contains a pointer
  527                          to the ALTRET frame in the TCB.
  528                          */
  529            2 STK$ PTR,
  530                          /*K* B$TCB.STK$ = PTR.  Contains a pointer to the
  531                          top frame in the TCB Exceptional Condition Stack.
  532                          */
  533            2 TCBAVSZ UBIN(18) UNAL,
  534                          /*K* B$TCB.TCBAVSZ = VALUE-UBIN(18).  Contains
  535                          the number of unused words remaining in the
  536                          TCB Exceptional Condition Stack.
  537                          */
  538            2 CURRSZ UBIN(18) UNAL,
  539                          /*K* B$TCB.CURRSZ = VALUE-UBIN(18).  Contains the
  540                          size of the top frame on the TCB Exceptional
  541                          Condition Stack.
  542                          */
  543            2 * BIT(36) UNAL;
  544
  545      %MEND;
  546
  547                          /*F* NAME: B$EXCFR
  548
  549                          B$EXCFR is a based structure which may be used
  550                          to access the fixed portion on any TCB frame.  The
  551                          structure describes in detail the Safe-Store
  552                          portion of the environment and the fixed words
  553                          of information found in any Exceptional Condition
  554                          frame.  The format of this structure can be
  555                          found in Appendix A.  The sub-fields in B$EXCFR
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           16   
  556                          have the following meaning:
  557                          */
  558      %MACRO B$EXCFR (NAME=B$EXCFR,STCLASS=BASED);
  559      DCL 1 NAME STCLASS ALIGNED,
  560            2 PREVSZ UBIN(18) UNAL, /* SIZE OF PREVIOUS FRAME                                           */
  561                          /*K*   B$EXCFR.PREVSZ = VALUE-UBIN(18). Contains
  562                          the number of words in the previous Stack
  563                          frame.  If this is the first frame on the
  564                          Exceptional Stack the value will be zero.
  565                          This field is redefined as ALTEMPTY in an ALTRET frame.
  566                          */
  567            2 ALTEMPTY REDEF PREVSZ SBIN HALF UNAL,
  568                          /*K*   B$EXCFR.ALTEMPTY = VALUE-SBIN HALF. Contains
  569                          a non-zero value when the ALTRET frame is empty.
  570                          The ALTRET frame is marked empty on initial entry
  571                          to a run-unit and after execution of an M$MERC,
  572                          M$RETRY or M$SENV monitor service.
  573                          This field has meaning only in an ALTRET frame and
  574                          is redefined as PREVSZ in a TCB Stack frame.
  575                          */
  576            2 ECC UBIN(18) UNAL,    /* EXCEPTIONAL CONDITION CODE                                       */
  577                          /*K*   B$EXCFR.ECC = VALUE-UBIN(18).  Contains
  578                          the Exceptional Condition Code. (See
  579                          Table 6-1).
  580                          */
  581            2 ASL BIT(36),          /* PASSED TO DELTA/ASL                                              */
  582            2 ASLIC REDEF ASL UBIN WORD,
  583            2 INST,                 /* EVEN-ODD INSTRUCTION PAIR                                        */
  584              3 EVEN UBIN(36),
  585              3 ODD UBIN(36),
  586            2 IC UBIN(18) UNAL,     /* INSTRUCTION COUNTER                                              */
  587                          /*K*   B$EXCFR.IC = VALUE-UBIN(18).  Contains
  588                          the Instruction Counter at the time
  589                          of the exceptional condition.                                                 */
  590            2 IR BIT(18) UNAL,      /* INDICATOR REGISTOR                                               */
  591                          /*K*   B$EXCFR.IR = VALUE-BIT(18).  Contains
  592                          the value of the Indicator Register at
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           17   
  593                          the time of the exceptional condition.
  594                          This field is REDEFined as follows:
  595                          */
  596            2 IRBIT REDEF IR,
  597                          /*K*   B$EXCFR.IRBIT.ZERO = VALUE-BIT(1).  Zero Indicator.
  598                          */
  599              3 ZERO BIT(1) UNAL,   /* ZERO                                                             */
  600              3 NEG BIT(1) UNAL,    /* NEGATIVE                                                         */
  601                          /*K*  B$EXCFR.IRBIT.NEG = VALUE-BIT(1).  Negative Indicator.
  602                          */
  603              3 CARRY BIT(1) UNAL,  /* CARRY                                                            */
  604                          /*K*   B$EXCFR.IRBIT.CARRY = VALUE-BIT(1).  Carry Indicator.
  605                          */
  606              3 OF BIT(1) UNAL,     /* OVERFLOW                                                         */
  607                          /*K*  B$EXCFR.IRBIT.OF = VALUE-BIT(1).  Overflow Indicator.
  608                          */
  609              3 EXOF BIT(1) UNAL,   /* EXPONENT OVERFLOW                                                */
  610                          /*K*  B$EXCFR.IRBIT.EXOF = VALUE-BIT(1).  Exponent
  611                          Overflow Indicator.                                                           */
  612              3 EXUF BIT(1) UNAL,   /* EXPONENT UNDERFLOW                                               */
  613                          /*K*  B$EXCFR.IRBIT.EXUF = VALUE-BIT(1).  Exponent
  614                          Underflow Indicator.                                                          */
  615              3 OFM BIT(1) UNAL,    /* OVERFLOW MASK                                                    */
  616                          /*K*  B$EXCFR.IRBIT.OFM = VALUE-BIT(1).  Overflow
  617                          Mask Indicator.                                                               */
  618              3 TR BIT(1) UNAL,     /* TALLY RUNOUT                                                     */
  619                          /*K*  B$EXCFR.IRBIT.TR = VALUE-BIT(1).  Tally Runout Indicator.
  620                          */
  621              3 PE BIT(1) UNAL,     /* PARITY ERROR                                                     */
  622                          /*K*  B$EXCFR.IRBIT.PE = VALUE-BIT(1).  Parity Error Indicator.
  623                          */
  624              3 PM BIT(1) UNAL,     /* PARITY MASK                                                      */
  625                          /*K*  B$EXCFR.IRBIT.PM = VALUE-BIT(1).  Parity Mask Indicator.
  626                          */
  627              3 MM BIT(1) UNAL,     /* MASTER MODE                                                      */
  628                          /*K*  B$EXCFR.IRBIT.MM = VALUE-BIT(1).  Master Mode Indicator.
  629                          */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           18   
  630              3 TRC BIT(1) UNAL,    /* TRUNCATION (EIS ONLY)                                            */
  631                          /*K*  B$EXCFR.IRBIT.TRC = VALUE-BIT(1).  Truncation Indicator.
  632                          */
  633              3 MIR BIT(1) UNAL,    /* MULTI-WORD INTERRUPT                                             */
  634                          /*K*  B$EXCFR.IRBIT.MIR = VALUE-BIT(1).  Multi-word
  635                          Instruction Interrupt Indicator.
  636                          */
  637              3 EXUFM BIT(1) UNAL,  /* EXPONENT UNDERFLOW MASK                                          */
  638                          /*K*  B$EXCFR.IRBIT.EXUFM = VALUE-BIT(1).  Exponent
  639                          Underflow Mask Indicator.
  640                          */
  641              3 HEX BIT(1) UNAL,    /* HEX FLOATING POINT                                               */
  642                          /*K*   B$EXCFR.IRBIT.HEX = VALUE-BIT(1).  Hex
  643                          Floating Point Indicator.
  644                          */
  645              3 * BIT(3) UNAL,
  646            2 * BIT(10) UNAL,
  647            2 SSF BIT(1) UNAL,      /* SAFE STORE STACK FAULT                                           */
  648            2 FI BIT(1) UNAL,       /* 0=FAULT   1=INTERRUPT                                            */
  649            2 FCODE UBIN(5) UNAL,   /* FAULT CODE                                                       */
  650                          /*K*  B$EXCFR.FCODE = VALUE-BIT(5).  Contains
  651                          the fault code.
  652                          */
  653            2 * BIT(3) UNAL,
  654            2 CP# UBIN(2) UNAL,     /* CPU NUMBER                                                       */
  655            2 SCR BIT(2) UNAL,      /* STACK CONTROL REGISTER                                           */
  656            2 IS_SEGID BIT(12) UNAL, /* INST. SEGMENT SEGID                                             */
  657            2 DSAR BIT(17) UNAL,    /* DATA STACK ADDR. REGISTER                                        */
  658            2 * BIT(10) UNAL,
  659            2 EWSQ# UBIN(9) UNAL,   /* WORKING SPACE QUARTER #                                          */
  660            2 RVA UBIN(36) UNAL,    /* VIRTUAL ADDR. OF FAULTING INST                                   */
  661            2 ISR,
  662                          /*K*  B$EXCFR.ISR = VALUE-BIT(72).  Contains the
  663                          contents of the Instruction Segment Register at
  664                          the time of the exceptional condition.  B$EXCFR.ISR
  665                          contains the following sub-fields:
  666                          */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           19   
  667              3 BOUND UBIN(20) UNAL,
  668                          /*K*  B$EXCFR.ISR.BOUND = VALUE-UBIN(20).  Contains
  669                          the maximum valid byte address within the segment.
  670                          BOUND is relative to the BASE.
  671                          */
  672              3 FLAGS,
  673                          /*K*  B$EXCFR.ISR.FLAGS = VALUE-BIT(9).  Contains
  674                          the segment descriptor flags, as follows:
  675                          */
  676                4 READ BIT(1) UNAL,
  677                          /*K* B$EXCFR.ISR.FLAGS.READ = VALUE-BIT(1).  If set,
  678                          read allowed.
  679                          */
  680                4 WRITE BIT(1) UNAL,
  681                          /*K*  B$EXCFR.ISR.FLAGS.WRITE = VALUE-BIT(1).  If set,
  682                          write allowed.
  683                          */
  684                4 SAVE BIT(1) UNAL,
  685                          /*K*  B$EXCFR.ISR.FLAGS.SAVE = VALUE-BIT(1).  If set,
  686                          the Descriptor may be stored in a Descriptor Segment
  687                          by the STDn instruction.
  688                          */
  689                4 CACHE BIT(1) UNAL,
  690                          /*K*  B$EXCFR.ISR.FLAGS.CACHE = VALUE-BIT(1).  When set
  691                          Cache is utilized on memory references using this descriptor.
  692                          */
  693                4 MON BIT(1) UNAL,
  694                          /*K*  B$EXCFR.ISR.FLAGS.MON = VALUE-BIT(1).  Flag is
  695                          reserved for use by the software.
  696                          */
  697                4 EXU BIT(1) UNAL,
  698                          /*K*  B$EXCFR.ISR.FLAGS.EXU = VALUE-BIT(1).  If set,
  699                          execute allowed.
  700                          */
  701                4 PRIV BIT(1) UNAL,
  702                          /*K*  B$EXCFR.ISR.FLAGS.PRIV = VALUE-BIT(1).  If set,
  703                          privileged mode.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           20   
  704                          */
  705                4 BOUND BIT(1) UNAL,
  706                          /*K*   B$EXCFR.ISR.FLAGS.BOUND = VALUE-BIT(1).  If set,
  707                          the BOUND field is the maximum effective address.  If
  708                          reset, the Segment is empty; BOUND is irrelevant.
  709                          */
  710                4 SEGMENT BIT(1) UNAL,
  711                          /*K*   B$EXCFR.ISR.FLAGS.SEGMENT = VALUE-BIT(1).  If set
  712                          the Segment is present.  If reset use of this descriptor
  713                          will cause a Missing Segment Fault.
  714                          */
  715              3 WSR UBIN(3) UNAL,
  716                          /*K*  B$EXCFR.ISR.WSR = VALUE-UBIN(3).  Contains the
  717                          Working Space Register to be used with this descriptor.
  718                          */
  719              3 TYPE UBIN(4) UNAL,
  720                          /*K*  B$EXCFR.ISR.TYPE = VALUE-UBIN(4).  Defines the
  721                          descriptor type. 0 means that the descriptor frames
  722                          instruction/operand storage. 1 means that the
  723                          descriptor frames descriptor storage.
  724                          */
  725              3 BASE SBIN WORD,
  726                          /*K*  B$EXCFR.ISR.BASE = VALUE-SBIN WORD.  Contains
  727                          the virtual byte address which is relative to the
  728                          working space defined in the Working Space Register
  729                          defined in the WSR field.
  730                          */
  731            2 ASR,
  732                          /*K*  B$EXCFR.ASR = VALUE-BIT(72).  Contains the
  733                          contents of the Argument Stack Register at
  734                          the time of the exceptional condition.  B$EXCFR.ASR
  735                          contains the same sub-fields as does B$EXCFR.ISR.
  736                          */
  737              3 BOUND UBIN(20) UNAL,
  738              3 FLAGS,
  739                4 READ BIT(1) UNAL,
  740                4 WRITE BIT(1) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           21   
  741                4 SAVE BIT(1) UNAL,
  742                4 CACHE BIT(1) UNAL,
  743                4 MON BIT(1) UNAL,
  744                4 EXU BIT(1) UNAL,
  745                4 PRIV BIT(1) UNAL,
  746                4 BOUND BIT(1) UNAL,
  747                4 SEGMENT BIT(1) UNAL,
  748              3 WSR UBIN(3) UNAL,
  749              3 TYPE BIT(4) UNAL,
  750              3 BASE SBIN WORD,
  751            2 LSR,
  752                          /*K*  B$EXCFR.LSR = VALUE-BIT(72).  Contains the
  753                          contents of the Linkage Segment Register at
  754                          the time of the exceptional condition.  B$EXCFR.LSR
  755                          contains the same sub-fields as does B$EXCFR.ISR.
  756                          */
  757              3 BOUND UBIN(20) UNAL,
  758              3 FLAGS,
  759                4 READ BIT(1) UNAL,
  760                4 WRITE BIT(1) UNAL,
  761                4 SAVE BIT(1) UNAL,
  762                4 CACHE BIT(1) UNAL,
  763                4 MON BIT(1) UNAL,
  764                4 EXU BIT(1) UNAL,
  765                4 PRIV BIT(1) UNAL,
  766                4 BOUND BIT(1) UNAL,
  767                4 SEGMENT BIT(1) UNAL,
  768              3 WSR UBIN(3) UNAL,
  769              3 TYPE BIT(4) UNAL,
  770              3 BASE SBIN WORD,
  771            2 PSR,
  772                          /*K*  B$EXCFR.PSR = VALUE-BIT(72).  Contains the
  773                          contents of the Parameter Stack Register at
  774                          the time of the exceptional condition.  B$EXCFR.PSR
  775                          contains the same sub-fields as does B$EXCFR.ISR.
  776                          */
  777              3 BOUND UBIN(20) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           22   
  778              3 FLAGS,
  779                4 READ BIT(1) UNAL,
  780                4 WRITE BIT(1) UNAL,
  781                4 SAVE BIT(1) UNAL,
  782                4 CACHE BIT(1) UNAL,
  783                4 MON BIT(1) UNAL,
  784                4 EXU BIT(1) UNAL,
  785                4 PRIV BIT(1) UNAL,
  786                4 BOUND BIT(1) UNAL,
  787                4 SEGMENT BIT(1) UNAL,
  788              3 WSR UBIN(3) UNAL,
  789              3 TYPE BIT(4) UNAL,
  790              3 BASE SBIN WORD,
  791            2 PRS(0:7) PTR,
  792                          /*K*  B$EXCFR.PRS = ARRAY(0:7) PTR.  Contains the
  793                          contents of Pointer Registers 0-7 at the time of
  794                          the exceptional condition.
  795                          */
  796            2 DRS(0:7) BIT(72) UNAL,
  797                          /*K*  B$EXCFR.DRS = ARRAY(0:7)-BIT(72).  Contains
  798                          the contents of the Descriptor Registers at the
  799                          time of the exceptional condition.
  800                          */
  801            2 REGS,
  802              3 XREG(0:7) UBIN(18) UNAL,
  803                          /*K*  B$EXCFR.REGS.XREG = ARRAY(0:7)-UBIN(18).  Contains
  804                          the contents of Index Registers at the time of the
  805                          exceptional condition.
  806                          */
  807              3 A UBIN(36),         /* ACCUMULATOR REGISTER                                             */
  808                          /*K*  B$EXCFR.REGS.A = VALUE-UBIN(36).  Contains
  809                          the contents of the Accumulator Register at the
  810                          time of the Exceptional Condition.
  811                          */
  812              3 Q UBIN(36),         /* QUOTIENT REGISTER                                                */
  813                          /*K*  B$EXCFR.REGS.Q = VALUE-UBIN(36).  Contains
  814                          the contents of the Quotient Register at the time
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           23   
  815                          of the exceptional condition.
  816                          */
  817              3 E BIT(8) UNAL,      /* EXPONENT REGISTER                                                */
  818                          /*K*  B$EXCFR.REGS.E = VALUE-BIT(8).  Contains
  819                          the contents of the Exponent Register at the
  820                          time of the exceptional condition.
  821                          */
  822              3 * BIT(28) UNAL,
  823            2 * UBIN UNAL,          /* TIMER REG ( UNADVERTISED*/
  824            2 EIS(0:7) UBIN UNAL,   /* PTRS AND LENGTHS                                                 */
  825                          /*K*   B$EXCFR.EIS = ARRAY(0:7)-UBIN(36).  Contains
  826                          the EIS Pointer and Length Registers when the exceptional
  827                          condition caused an EIS multi-word
  828                          instruction to be interrupted or aborted
  829                          in the middle of the instruction.
  830                          */
  831            2 *(0:7)  BIT(36) UNAL,
  832            2 U1 UBIN(18) UNAL,     /* UNUSED                                                           */
  833            2 SUBC UBIN(18) UNAL,   /* ECC SUBCODE                                                      */
  834                          /*K*   B$EXCFR.SUBC = VALUE-UBIN(18).  Contains
  835                          the exceptional condition sub-code.  The contents
  836                          of this field are dependent on the type of condition
  837                          that has occurred.
  838
  839                          The remainder of the frame
  840                          is dependent on the type of condition
  841                          that has occurred.                                                            */
  842                          /*B* The above message should be under the last
  843                          entry undr the B$EXCFR if this service is
  844                          modified at a later date.                                                     */
  845            2 EVSC REDEF SUBC UBIN(18) UNAL,
  846                          /*K*   B$EXCFR.EVSC = VALUE-UBIN(18).  Contains the event sub-code
  847                          if this is an event frame.                                                    */
  848
  849            2 CODE REDEF SUBC UBIN(18) UNAL,
  850                          /*K* B$EXCFR.CODE = VALUE-UBIN(18).  For ALTRET frames,
  851                          contains the Service Request Code.  This field
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           24   
  852                          may also be referenced by B$EXCFR.FPT.                                        */
  853
  854            2 FPT REDEF SUBC,
  855                                    /* B$EXCFR.FPT is another way to reference
  856                                    B$EXCFR.CODE.                                                       */
  857
  858              3 FCG UBIN(6) UNAL,
  859                          /*K*   B$EXCFR.FPT.FCG = VALUE-UBIN(6).  Contains the Service Request
  860                          Functional Code Group.                                                        */
  861
  862              3 PMME UBIN(12) UNAL,
  863                          /*K*   B$EXCFR.FPT.PMME = VALUE-UBIN(12).  Contains the Service
  864                          Request Code.  See Appendix A for the meaning of this code.                   */
  865
  866            2 EVID UBIN,
  867                          /*K* B$EXCFR.EVID = VALUE-UBIN(36).  For event
  868                          frames, contains the event ID.
  869                           */
  870
  871            2 DCB# REDEF EVID UBIN,
  872                          /*K* B$EXCFR.DCB# = VALUE-UBIN(36).  For ALTRET
  873                          frames, contains the number of the DCB on which
  874                          the error occurred.
  875                           */
  876
  877            2 BRKCNT REDEF EVID UBIN,
  878                          /*K* B$EXCFR.BRKCNT = VALUE-UBIN(36) is the number of terminal
  879                          breaks received since the last read.  This is for
  880                          break condition only.
  881                           */
  882
  883            2 ERR,
  884                          /*K*   B$EXCFR.ERR is the 36 bit error code.  The
  885                          error code contains the following:                                            */
  886              3 FCG BIT(12) UNAL,
  887                          /*K*   B$EXCFR.ERR.FCG = VALUE-BIT(12). Contains the
  888                          Functional Code Group portion of the error code.                              */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           25   
  889              3 MID BIT(6) UNAL,
  890                          /*K*   B$EXCFR.ERR.MID = VALUE-BIT(6).  Contains the
  891                          Module ID portion of the error code.                                          */
  892              3 MON BIT(1) UNAL,
  893                          /*K*   B$EXCFR.ERR.MON = VALUE-BIT(1).  Indicates that
  894                          the error code was generated by the monitor.                                  */
  895              3 ERR# UBIN(14) UNAL,
  896                          /*K*   B$EXCFR.ERR.ERR# = VALUE-UBIN(14).  Contains the
  897                          error code (see file B_ERRORS_C).                                             */
  898              3 CODE REDEF ERR# UBIN(14) UNAL,
  899              3 SEV UBIN(3) UNAL,
  900                          /*K*   B$EXCFR.ERR.SEV = VALUE-UBIN(3).  Contains the
  901                          severity of the error.                                                        */
  902            2 P# UBIN(36);          /* # OF PARAMETERS                                                  */
  903                          /*K*   B$EXCFR.P# = VALUE-UBIN(36).  Contains
  904                          the number of additional words on this
  905                          stack frame.
  906                          */
  907      %MEND;
  908
  909
  910                          /*P*  NAME:  EQU_TCB_SZ
  911
  912                          The EQU_TCB_SZ macro may be used to generate the values
  913                          for the average TCB frame size (%UE_AV_TCBSZ#) and for the
  914                          size of the fixed portion of any TCB frame (%UE_FX_TCBSZ#).
  915                          */
  916      %MACRO EQU_TCB_SZ;
  917      %EQU UE_AV_TCBSZ# = 74;
  918      %EQU UE_FX_TCBSZ# = 72;
  919      %MEND;
  920
  921
  922
  923                          /*P* NAME:     B$FIXED  .
  924
  925                               PURPOSE:  Provide a based structure describing
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           26   
  926                                         the fixed initial portion of event
  927                                         and ALTRET frames.
  928
  929                          */
  930
  931      /* B$FIXED is used only be the monitor  -  Not to be included in CP-6 Mon Serv Manual  */
  932      %MACRO B$FIXED (NAME=B$FIXED,STCLASS=BASED,LAST=",");
  933
  934      DCL 1 NAME STCLASS ALIGNED,
  935
  936            2 SSFRAME(0:63) UBIN,
  937                          /*K*   B$FIXED.SSFRAME contains the copy of the program's
  938                          environment at the time of the event or ALTRET.  The
  939                          based structure B$EXCFR should be used to access this area.                   */
  940
  941            2 * UBIN(18) UNAL,
  942
  943            2 CODE UBIN(18) UNAL,
  944                          /*K* B$FIXED.CODE = VALUE-UBIN(18).  For ALTRET frames,
  945                          contains the Service Request Code.  This field
  946                          may also be referenced by B$FIXED.FPT.                                        */
  947
  948            2 FPT REDEF CODE,
  949                                    /* B$FIXED.FPT is another way to reference
  950                                    B$FIXED.CODE.                                                       */
  951
  952              3 FCG UBIN(6) UNAL,
  953                          /*K*   B$FIXED.FPT.FCG = VALUE-UBIN(6).  Contains the Service Request
  954                          Functional Code Group.                                                        */
  955
  956              3 PMME UBIN(12) UNAL,
  957                          /*K*   B$FIXED.FPT.PMME = VALUE-UBIN(12).  Contains the Service
  958                          Request Code.                                                                 */
  959
  960            2 EVSC REDEF CODE UBIN(18) UNAL,
  961                          /*K*   B$FIXED.EVSC = VALUE-UBIN(18).  Contains the event sub-code
  962                          if this is an event frame.                                                    */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           27   
  963
  964            2 SUBC REDEF CODE UBIN(18) UNAL,
  965            2 EVID UBIN,
  966                          /*K* B$FIXED.EVID = VALUE-UBIN(36).  For event
  967                          frames, contains the event ID.                                                */
  968
  969            2 DCB# REDEF EVID UBIN,
  970                          /*K* B$FIXED.DCB# = VALUE-UBIN(36).  For ALTRET
  971                          frames, contains the number of the DCB on which
  972                          the error occurred.                                                           */
  973
  974            2 BRKCNT REDEF EVID UBIN,
  975                          /*K* B$FIXED.BRKCNT is the number of terminal
  976                          breaks received since the last read.  For break
  977                          events only.                                                                  */
  978
  979            2 ERR,
  980                          /*K* B$FIXED.ERR is the 36 bit error code, containing
  981                          the following:                                                                */
  982
  983              3 FCG BIT(12),
  984                          /*K* B$FIXED.ERR.FCG = VALUE-BIT(12).  Contains
  985                          the Functional Code Group portion of the error code.                          */
  986
  987              3 MID BIT(6),
  988                          /*K* B$FIXED.ERR.MID = VALUE-BIT(6).  Contains the
  989                          Module ID portion of the error code.                                          */
  990
  991              3 MON BIT(1),
  992                          /*K* B$FIXED.ERR.MON = VALUE-BIT(1).  Set if the error
  993                          was generated by the monitor.                                                 */
  994
  995              3 ERR# UBIN(14) UNAL,
  996                          /*K* B$FIXED.ERR.ERR# = VALUE-UBIN(14).  Contains
  997                          the error code (see file B_ERRORS_C).                                         */
  998
  999              3 CODE REDEF ERR# UBIN(14) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           28   
 1000              3 SEV UBIN(3) UNAL LAST
 1001                          /*K* B$FIXED.ERR.SEV = VALUE-UBIN(3).  Contains the
 1002                          severity of the error.                                                        */
 1003
 1004      %MEND;
 1005
 1006
 1007                          /*F* NAME: Accessing Exceptional Condition Information.
 1008
 1009                          The system macro library, CP_6, contains a set of
 1010                          macros which may be used to generate based
 1011                          structures for accessing the TCB.  The structures
 1012                          B$TCB and B$EXCFR may be used to access data from
 1013                          the initial portion of any frame in the TCB.  In
 1014                          addition, every program contains a linker-built
 1015                          pointer, B$TCB$, which can be used to access the
 1016                          TCB.
 1017
 1018                          The following PL-6 statements access the
 1019                          Instruction Counter from an exceptional condition
 1020                          frame or ALTRET frame of the TCB:
 1021
 1022                          TU
 1023                            %INCLUDE CP_6;           --Which provides the user access to
 1024                                                       macros to generate Exceptional
 1025                                                       Condition based structures.
 1026
 1027                            %B$TCB;                  --Which generates the BASED structure
 1028                                                       for the TCB, including these pointers:
 1029
 1030                                                       B$TCB.ALT$ pointing to the ALTRET
 1031                                                       frame.
 1032
 1033                                                       B$TCB.STK$ pointing to the top frame
 1034                                                       of the exceptional condition stack.
 1035
 1036                            %B$EXCFR;                --Which generates a BASED structure
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           29   
 1037                                                       for any Exceptional Condition frame,
 1038                                                       including:
 1039
 1040                                                       B$EXCFR.IC - the Instruction Counter
 1041                                                       at the time of the exceptional condition.
 1042
 1043                            DCL B$TCB$ PTR SYMREF;   --Declares the linker-built pointer
 1044                                                       for the TCB.
 1045
 1046                            TRAP_IC = B$TCB$->B$TCB.STK$->B$EXCFR.IC;
 1047                                                     --Accesses the Instruction Counter
 1048                                                       in the top Exceptional Condition
 1049                                                       frame.
 1050
 1051                            ALTRET_IC = B$TCB$->B$TCB.ALT$->B$EXCFR.IC;
 1052                                                     --Accesses the Instruction Counter
 1053                                                       in the ALTRET frame.
 1054
 1055                          TF
 1056                          Additional structures described later in this
 1057                          section allow access to data stored in the upper
 1058                          portion of the frame.  These structures are also
 1059                          available in the system macro library.
 1060                          */
 1061
 1062
 1063                          /*F* NAME: ALTRET Condition.
 1064
 1065                          The ALTRET option on a monitor service call establishes
 1066                          a statement to receive control in case of errors.
 1067                          The ALTRET label must be in the same scope as the
 1068                          monitor service call.  Before transferring to the
 1069                          ALTRET label, the system saves the environment in the
 1070                          fixed ALTRET frame in the TCB.
 1071
 1072                          The ALTRET frame contains the environment and four
 1073                          additional words of information.  The user may access
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           30   
 1074                          the ALTRET frame using the B$TCB$ pointer and the B$ALT
 1075                          or B$EXCFR based structures.  The ALTRET frame is
 1076                          illustrated in Appendix A.  The ECC (B$EXCFR.ECC) is
 1077                          set to %ECC_ALT#; the ECC subcode contains the
 1078                          functional code group (B$ALT.FPT.FCG) and the
 1079                          monitor service number (B$ALT.FPT.PMME).
 1080                          B$ALT.DCB# contains the DCB number (if a DCB
 1081                          was a required parameter) and B$ALT.ERR
 1082                          contains the error code.
 1083
 1084                          The ALTRET frame is overlaid every time the
 1085                          monitor transfers control to an ALTRET code sequence.
 1086                          In the course of processing the ALTRET
 1087                          condition, the user may call another monitor service,
 1088                          but may first want to save the original ALTRET
 1089                          environment, because the original ALTRET
 1090                          environment is lost if another monitor service
 1091                          error occurs.
 1092
 1093                          NOTE:  The ALTRET frame is also overlaid if the
 1094                          "insufficient space in Exceptional Condition
 1095                          Stack" condition occurs at any exceptional
 1096                          condition.
 1097
 1098                          The following list summarizes the monitor services
 1099                          that act indirectly on the TCB ALTRET frame or the
 1100                          ALTRET environment stored in a frame of the
 1101                          Exceptional Condition Stack.
 1102
 1103                          .BRN 25
 1104                          .FIF
 1105                          } Monitor Service    Function
 1106                          ___________________________________________________________
 1107                           .spf
 1108                          } M$SENV             Save ALTRET environment in the Exceptional
 1109                          }                    Condition Stack
 1110                           .spf
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           31   
 1111                          } M$RENV             Restore ALTRET environment from top frame
 1112                          }                    of Exceptional Condition Stack to TCB
 1113                          }                    ALTRET frame
 1114                           .spf
 1115                          } M$RETRY            Retry original monitor service (original
 1116                          }                    environment is in ALTRET frame)
 1117                           .spf
 1118                          } M$RETRYS           Retry original monitor service (original
 1119                          }                    environment is in Exceptional Condition
 1120                          }                    Stack top frame)
 1121                           .spf
 1122                          } M$MERC             Request monitor error handling (original
 1123                          }                    environment is in ALTRET frame)
 1124                           .spf
 1125                          } M$MERCS            Request monitor error handling (original
 1126                          }                    environment is in Exceptional Condition
 1127                          }                    Stack top frame)
 1128                           .spf
 1129                          ---------------------------------------------------------------
 1130                          .FIN
 1131                          */
 1132
 1133                          /*F* NAME: B$ALT
 1134
 1135                          The %B$ALT macro may be used to generate a
 1136                          based structure of the ALTRET frame of the
 1137                          TCB.  The format of this structure can be found
 1138                          in Appendix A.  The sub-fields in this structure
 1139                          have the following meanings:
 1140                          */
 1141
 1142      %MACRO B$ALT (NAME=B$ALT,STCLASS=BASED);
 1143
 1144        %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 1145                          /*K*   B$ALT.SSFRAME contains the copy of the
 1146                          program's environment at the time of the
 1147                          ALTRET condition.  The based structure
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           32   
 1148                          B$EXCFR should be used to access
 1149                          the environment.
 1150                          */
 1151                          /*K*   B$ALT.FPT = VALUE-UBIN(18).  Contains
 1152                          the Service Request code as follows:
 1153                          */
 1154                          /*K*   B$ALT.FPT.FCG = VALUE-UBIN(6).  Contains
 1155                          the Service Request Functional Code Group.                                    */
 1156                          /*K*   B$ALT.FPT.PMME = VALUE-UBIN(12).  Contains
 1157                          the unique Service Request code for this Functional
 1158                          Code Group.  These codes are listed in Appendix A.                            */
 1159                          /*K*   B$ALT.DCB# = VALUE-UBIN(36).  Contains
 1160                          the number associated with the DCB referenced
 1161                          by this Service Request.
 1162                          */
 1163                          /*K*   B$ALT.ERR is the 36 bit error code.  The
 1164                          error code contains the following:                                            */
 1165                          /*K*   B$ALT.ERR.FCG = VALUE-BIT(12). Contains the
 1166                          Functional Code Group portion of the error code.                              */
 1167                          /*K*   B$ALT.ERR.MID = VALUE-BIT(6).  Contains the
 1168                          Module ID portion of the error code.                                          */
 1169                          /*K*   B$ALT.ERR.MON = VALUE-BIT(1).  Indicates that
 1170                          the error code was generated by the monitor.                                  */
 1171                          /*K*   B$ALT.ERR.ERR# = VALUE-UBIN(14).  Contains the
 1172                          error code (see file B_ERRORS_C).                                             */
 1173                          /*K*   B$ALT.ERR.SEV = VALUE-UBIN(3).  Contains the
 1174                          severity of the error.                                                        */
 1175            2 P# UBIN;
 1176
 1177      %MEND;
 1178
 1179
 1180                          /*F* NAME: M$TRAP - Set Trap Control.
 1181
 1182                          TRAP CONTROL
 1183
 1184                          The user can request control at a number of
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           33   
 1185                          hardware-detected faults and at an error on a
 1186                          monitor service call without ALTRET.  The user can
 1187                          also request various simulated faults to test the
 1188                          trap procedure(s).
 1189
 1190
 1191                          M$TRAP
 1192
 1193                          The M$TRAP service identifies particular hardware
 1194                          detected faults at which the user wants control
 1195                          and specifies trap procedures.  The user can
 1196                          change fault control and specify different
 1197                          trap procedures during program execution.
 1198
 1199                          The user can identify procedures for three
 1200                          categories of faults on the ARITHMETIC, ERRORS,
 1201                          and PROGRAMMED parameters.  For specific faults in
 1202                          each category the user codes a fault parameter
 1203                          specifying TRAP or omits the parameter to take the
 1204                          ABORT default.  For faults in the ERRORS category,
 1205                          the user can request that the history registers be
 1206                          saved along with the environment and other
 1207                          data in the Exceptional Condition Stack.  The
 1208                          enabling and disabling of this function is done
 1209                          via the HISTORY_REGS keyword.  The user may also
 1210                          specify with the PMME parameter a procedure that
 1211                          processes errors on Monitor service calls without
 1212                          the ALTRET option.
 1213
 1214                          It is possible to specify an entry-address for a
 1215                          category of faults while all the faults within
 1216                          that category are placed in the ABORT state.
 1217                          However, it is an error to specify that a specific
 1218                          fault be put in the TRAP state if no procedure is
 1219                          specified or exists for that category of faults.
 1220
 1221                          A call to M$TRAP may request that the current
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           34   
 1222                          settings of the Program Trap Condition (PTC) be
 1223                          returned to the user.  The information returned
 1224                          includes the entry-address for each of the four
 1225                          possible error conditions (ARITHMETIC, PROGRAMMED,
 1226                          ERRORS and PMME) and the current state of each of
 1227                          the hardware faults (TRAP or ABORT).  The
 1228                          structure of the PTC area can be generated by the
 1229                          VLP_PTC macro.  (No initial values are provided in
 1230                          this macro because the values are supplied at run
 1231                          time by a call to M$TRAP requesting that the PTC
 1232                          be made available to the user.)
 1233                          The M$TRAP FPT may specify that the PTC be
 1234                          returned to the user and that the current Program
 1235                          Trap Condition be replaced with those specified in
 1236                          the FPT.  The Program Trap Conditions may later be
 1237                          reset to their previous values by calling M$TRAP
 1238                          specifying the PTC area that was returned on the
 1239                          original call and RESTORE=YES.  The PTC and
 1240                          RESTORE parameters allow any procedure within a
 1241                          program to handle its own trap conditions and to
 1242                          restore the trap conditions to their original
 1243                          states before returning.
 1244
 1245                          The form of the call for this service is:
 1246
 1247                          CALL M$TRAP (FPT_TRAP) [ALTRET (label)];
 1248
 1249                          Parameters for the M$TRAP service are as follows:                             */
 1250
 1251
 1252      %MACRO FPT_TRAP(   FPTN=FPT_TRAP,
 1253                         PMME=NIL,
 1254                         ARITHMETIC=NIL,
 1255                         PROGRAMMED=NIL,
 1256                         ERRORS=NIL,
 1257                         PTC=NIL,
 1258                         OVERFLOW(TRAP='1'B,ABORT='0'B)='11'B,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           35   
 1259                         DIVIDE_CHECK(TRAP='1'B,ABORT='0'B)='11'B,
 1260                         MME(TRAP='1'B,ABORT='0'B)='11'B,
 1261                         DERAIL(TRAP='1'B,ABORT='0'B)='11'B,
 1262                         FAULT_TAG(TRAP='1'B,ABORT='0'B)='11'B,
 1263                         SECURITY_1(TRAP='1'B,ABORT='0'B)='11'B,
 1264                         MEMORY(TRAP='1'B,ABORT='0'B)='11'B,
 1265                         COMMAND(TRAP='1'B,ABORT='0'B)='11'B,
 1266                         LOCKUP(TRAP='1'B,ABORT='0'B)='11'B,
 1267                         IPR(TRAP='1'B,ABORT='0'B)='11'B,
 1268                         MISSING_SEG(TRAP='1'B,ABORT='0'B)='11'B,
 1269                         MISSING_PAGE(TRAP='1'B,ABORT='0'B)='11'B,
 1270                         SECURITY_2(TRAP='1'B,ABORT='0'B)='11'B,
 1271                         HARDWARE(TRAP='1'B,ABORT='0'B)='11'B,
 1272                         HISTORY_REGS(YES='1'B,NO='0'B)='11'B,
 1273                         RESTORE(YES='1'B,NO='0'B)='11'B,
 1274                         STCLASS=STATIC);
 1275
 1276      %LSET LISTDIR='0'B;
 1277      %LSET LISTEXP='1'B;
 1278      %LSET LISTCOM='0'B;
 1279      %LSET LISTSUB='1'B;
 1280      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1281      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1282       (SUBSTR(STR,0,8)='CONSTANT') OR
 1283       (SUBSTR(STR,0,3)='EXT');
 1284       %LSET INIT=CHARTEXT('INIT');
 1285      %ELSE;
 1286       %LSET INIT=CHARTEXT('/*');
 1287      %ENDIF;
 1288
 1289
 1290
 1291
 1292      DCL 1 FPTN STCLASS DALIGNED,
 1293            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 1294            2 PTC_ BIT(72) %INIT(VECTOR(PTC))%CHARTEXT('/**/'),
 1295                          /*K* PTC = VARIABLE    specifies, if RESTORE = NO,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           36   
 1296                          the area where the current settings of the Program
 1297                          Trap Conditions are to be returned to the user.
 1298                          If RESTORE=YES, the Program Trap Conditions are to
 1299                          be restored.  The structure of the area in which
 1300                          the Program Trap Conditions are returned may be
 1301                          generated by the VLP_PTC macro.  If RESTORE = YES,
 1302                          all other FPT parameters are ignored.
 1303                          Default = NIL.*/
 1304            2 V DALIGNED,
 1305              3 PMME# EPTR %INIT(ENTADDR(PMME))%CHARTEXT('/**/'),
 1306                          /*K* PMME = ENTRY   locates a procedure to be
 1307                          entered as a result of a monitor service error, if
 1308                          no ALTRET option is specified in the service call.
 1309                          Default = NIL.*/
 1310              3 ARITHMETIC# EPTR %INIT(ENTADDR(ARITHMETIC))%CHARTEXT('/**/'),
 1311                          /*K* ARITHMETIC = ENTRY    locates the
 1312                          entry-address to which control is transferred in
 1313                          the event of an OVERFLOW or DIVIDE_CHECK trap.
 1314                          Default is = NIL.
 1315
 1316                          DIVIDE_CHECK = {ABORT|TRAP}    specifies the action
 1317                          to take if illegal division is attempted.
 1318                          The default causes this parameter to be ignored;
 1319                          thus the fault flag in the ECCB is not altered.
 1320
 1321                          OVERFLOW = {ABORT|TRAP}    specifies the action to
 1322                          take at an ARITHMETIC overflow, exponent overflow,
 1323                          or exponent underflow.
 1324                          The default causes this parameter to be ignored;
 1325                          thus the fault flag in the ECCB is not altered.                               */
 1326              3 PROGRAMMED# EPTR %INIT(ENTADDR(PROGRAMMED))%CHARTEXT('/**/'),
 1327                          /*K* PROGRAMMED = ENTRY    locates the
 1328                          entry-address to which control is transferred in
 1329                          the event of an MME, DERAIL, or FAULT_TAG trap.
 1330                          Default  = NIL.
 1331
 1332                          DERAIL = {ABORT|TRAP}    specifies the action to
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           37   
 1333                          take at the execution of a DERAIL (DRL)
 1334                          instruction.
 1335                          The default causes this parameter to be ignored;
 1336                          thus the fault flag in the ECCB is not altered.
 1337
 1338                          FAULT_TAG = {ABORT|TRAP}    specifies the action to
 1339                          take at the recognition of the address modifier
 1340                          IT, whenever T=F.  The default causes this
 1341                          parameter to be ignored; thus the fault
 1342                          flag in the ECCB is not altered.
 1343
 1344                          MME = {ABORT|TRAP}    specifies the action to take
 1345                          at the execution of a Master Mode Entry (MME)
 1346                          instruction.  The default causes this parameter to be
 1347                          ignored; thus the fault flag in the ECCB is not altered.
 1348                          */
 1349              3 ERRORS# EPTR %INIT(ENTADDR(ERRORS))%CHARTEXT('/**/'),
 1350                          /*K* ERRORS = ENTRY    locates an entry-address to
 1351                          which control is transferred in the event of
 1352                          MEMORY, COMMAND, LOCKUP, IPR, MISSING_SEG,
 1353                          MISSING_PAGE, SECURITY_1, SECURITY_2, or HARDWARE
 1354                          traps.  Default = NIL.
 1355
 1356                          COMMAND = {ABORT|TRAP}    specifies the action to
 1357                          take when a program issues a privileged
 1358                          instruction.  The default causes this parameter
 1359                          to be ignored; thus the fault flag in the ECCB is
 1360                          not altered.
 1361
 1362                          HARDWARE = {ABORT|TRAP}    specifies the action to
 1363                          take at a parity error fault, operation not complete
 1364                          fault, or other hardware fault such as memory fault
 1365                          or command fault caused by a system controller
 1366                          illegal action.  Only jobs with Test and Diagnostic
 1367                          authorization can set HARDWARE = TRAP.  (The
 1368                          M$TRAP service takes the alternate return if an
 1369                          unauthorized user requests control at HARDWARE
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           38   
 1370                          faults.)  The default causes this parameter to be
 1371                          ignored; thus the fault flag in the ECCB is not altered.
 1372
 1373                          IPR = {ABORT|TRAP}    specifies the action to take
 1374                          at an illegal procedure which occurs as a result
 1375                          of an illegal operation code, an illegal address,
 1376                          an illegal modifier, or an illegal instruction
 1377                          sequence.  The default causes this parameter to be
 1378                          ignored; thus the fault flag in the ECCB is not
 1379                          altered.
 1380
 1381                          LOCKUP = {ABORT|TRAP}    specifies the action to
 1382                          take at a condition that inhibits the recognition
 1383                          of an execute interrupt or interrupt type fault
 1384                          for a time greater than the lockup time.  Lockup
 1385                          time is variable with
 1386                          a minimum of 4 milliseconds on current CPUs.
 1387                          The default causes this
 1388                          parameter to be ignored; thus the fault flag in the
 1389                          ECCB is not altered.
 1390
 1391                          MEMORY = {ABORT|TRAP}    specifies the action to
 1392                          take at detection of an address that is outside
 1393                          the segment boundary.  The default causes this
 1394                          parameter to be ignored; thus the fault flag in the
 1395                          ECCB is not altered.
 1396
 1397                          MISSING_PAGE = {ABORT|TRAP}    specifies the action
 1398                          to take at a fault that occurs during mapping from
 1399                          virtual to real memory, when the obtained Page
 1400                          Table Word has bit 30=0 meaning "page not in
 1401                          memory".  The default causes this parameter to be
 1402                          ignored; thus the fault flag in the ECCB is not
 1403                          altered.
 1404
 1405                          MISSING_SEG = {ABORT|TRAP}    specifies the action
 1406                          to take at an attempt to reference memory with a
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           39   
 1407                          descriptor that has flag bit 28=0, meaning
 1408                          "segment not present".  The default causes this
 1409                          parameter to be ignored; thus the fault flag in the
 1410                          ECCB is not altered.
 1411
 1412                          SECURITY_1 = {ABORT|TRAP}    specifies the action to
 1413                          take on one of the following conditions:
 1414                          }
 1415                          1.  An attempt to execute an instruction in an illegal
 1416                              processor mode.
 1417
 1418                          2.  An attempt to modify a housekeeping page in Master Mode.
 1419
 1420                          3.  An attempt to modify or fetch instructions or operands
 1421                              from a housekeeping page while in Slave Mode.
 1422
 1423                          4.  Attempt to reference non-housekeeping pages Type 1 or
 1424                              Type 3 descriptor.
 1425                          }
 1426                          The default causes this parameter to be ignored;
 1427                          thus the fault flag in the ECCB is not altered.
 1428
 1429                          SECURITY_2 = {ABORT|TRAP}    specifies the action to
 1430                          take at one of the following violations:
 1431                          }
 1432                          1.  An attempt to violate read, write, or execute permission
 1433                              for a segment descriptor; or to store a descriptor into
 1434                              a segment for which the descriptor does not permit
 1435                              descriptor storage.
 1436
 1437                          2.  An attempt to violate write permission control for
 1438                              a page table word.
 1439
 1440                          3.  An attempt to violate working space quarter isolation control
 1441                              for a Working Space Page Table Directory word.
 1442
 1443                          The default causes this parameter to be ignored;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           40   
 1444                          thus the fault flag in the ECCB is not altered.
 1445                          */
 1446              3 FLAGS,
 1447                4 OVERFLOW# BIT(2) UNAL %INIT(OVERFLOW)%CHARTEXT('/**/'),
 1448                4 DIVIDE_CHECK# BIT(2) UNAL %INIT(DIVIDE_CHECK)%CHARTEXT('/**/'),
 1449                4 MME# BIT(2) UNAL %INIT(MME)%CHARTEXT('/**/'),
 1450                4 DERAIL# BIT(2) UNAL %INIT(DERAIL)%CHARTEXT('/**/'),
 1451                4 FAULT_TAG# BIT(2) UNAL %INIT(FAULT_TAG)%CHARTEXT('/**/'),
 1452                4 * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1453                4 RESTORE# BIT(2) UNAL %INIT(RESTORE)%CHARTEXT('/**/'),
 1454                          /*K* RESTORE = {YES|NO}    specifies the action to
 1455                          be taken when PTC is specified.  It is an error to
 1456                          specify RESTORE=YES and not specify a PTC area.
 1457                          The default causes this parameter to be ignored;
 1458                          thus the fault flag in the ECCB is not altered.
 1459                          */
 1460                4 * BIT(2) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 1461                4 SECURITY_1# BIT(2) UNAL %INIT(SECURITY_1)%CHARTEXT('/**/'),
 1462                4 MEMORY# BIT(2) UNAL %INIT(MEMORY)%CHARTEXT('/**/'),
 1463                4 COMMAND# BIT(2) UNAL %INIT(COMMAND)%CHARTEXT('/**/'),
 1464                4 LOCKUP# BIT(2) UNAL %INIT(LOCKUP)%CHARTEXT('/**/'),
 1465                4 IPR# BIT(2) UNAL %INIT(IPR)%CHARTEXT('/**/'),
 1466                4 MISSING_SEG# BIT(2) UNAL %INIT(MISSING_SEG)%CHARTEXT('/**/'),
 1467                4 MISSING_PAGE# BIT(2) UNAL %INIT(MISSING_PAGE)%CHARTEXT('/**/'),
 1468                4 SECURITY_2# BIT(2) UNAL %INIT(SECURITY_2)%CHARTEXT('/**/'),
 1469                4 HARDWARE# BIT(2) UNAL %INIT(HARDWARE)%CHARTEXT('/**/'),
 1470                4 HISTORY_REGS# BIT(2) UNAL %INIT(HISTORY_REGS)%CHARTEXT('/**/'),
 1471                          /*K* HISTORY_REGS = {YES|NO}    specifies, if YES,
 1472                          that the history registers are to be placed in the
 1473                          Exceptional Condition Stack for faults in the
 1474                          ERRORS category.  Default = NO.*/
 1475              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1476
 1477      %MEND;
 1478
 1479                          /*F* NAME: B$FLT
 1480
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           41   
 1481                          In the ARITHMETIC,ERRORS, or PROGRAMMED
 1482                          procedure, the user may access the top frame of the
 1483                          Exceptional Condition Stack via the B$EXCFR or
 1484                          B$FLT based structures.  In the PMME procedure,
 1485                          the user may access this frame via the
 1486                          B$EXCFR or B$ALT based structures.
 1487                          The %B$FLT macro may be used to generate a
 1488                          based structure of a hardware fault
 1489                          exceptional condition frame.  The format of
 1490                          this structure can be found in Appendix A.
 1491                          The sub-fields in this structure have the following meanings:
 1492                          */
 1493      %MACRO B$FLT (NAME=B$FLT,STCLASS=BASED,SSF(YES=YES,NO=NO)=YES,HREGS(YES=YES,NO=NO)=YES);
 1494      DCL 1 NAME STCLASS ALIGNED,
 1495      %IF (TEXTCHAR(SSF) = 'YES');
 1496            2 SSFRAME,
 1497                          /*K*   B$FLT.SSFRAME contains the copy of the
 1498                          environment at the time of the fault.
 1499                          The based structure B$EXCFR should be
 1500                          used to access the environment.                                               */
 1501              3 * UBIN(18) UNAL,
 1502              3 ECC UBIN(18) UNAL,
 1503              3 *(0:3) BIT(36) UNAL,
 1504              3 * BIT(10) UNAL,
 1505              3 SSF BIT(1) UNAL,    /* SAFE-STORE FAULT FLAG                                            */
 1506              3 * BIT(1) UNAL,
 1507              3 FCODE BIT(5) UNAL,  /* 5 BIT FAULT CODE                                                 */
 1508              3 * BIT(19) UNAL,
 1509              3 *(0:57) BIT(36) UNAL,
 1510      %ENDIF;
 1511            2 PORT# UBIN(9) UNAL,
 1512                          /*K*  B$FLT.PORT# = VALUE-UBIN(9).  Contains the processor
 1513                          port number on the base system controller (low memory).
 1514                          */
 1515            2 * BIT(4) UNAL,
 1516            2 BRANCH_MODE BIT(1) UNAL,
 1517                          /*K*  B$FLT.BRANCH_MODE = VALUE-BIT(1).  If set,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           42   
 1518                           indicates that History Register data (if any) which
 1519                           follows was gathered in a mode that strobes data
 1520                           only for a branch instruction which branches.
 1521                           */
 1522            2 CPU_TYPE UBIN(4) UNAL,
 1523                          /*K*  B$FLT.CPU_TYPE = VALUE-UBIN(4).  Contains a code
 1524                           to indicate the CPU Type.  Note that the number of
 1525                           words that will be required to contain the History
 1526                           Register data (P#) is dependent on CPU Type.  This value
 1527                           is set as follows:
 1528
 1529                           .FIF
 1530                               CPU Type    CPU_TYPE    P#
 1531                               ________    ________    ___
 1532                                L66           0        128
 1533                                ELS1          2         32
 1534                                DPSE          1        512
 1535                                DPS90XA       5         16
 1536                                DPS8000       6        256
 1537                           .FIN
 1538                           */
 1539            2 SUBC UBIN(18) UNAL,   /* ECC SUBCODE                                                      */
 1540                          /*K*   B$FLT.SUBC = VALUE-UBIN(18).  Contains the
 1541                          Fault Sub-code.  Values (from the %SUB_EXC
 1542                          macro) are as follows:
 1543                          .FIF
 1544                          .SPB
 1545                          Sub-code       Value       Meaning
 1546                          ________       _____       ___________
 1547                          .SPF
 1548                          When ECC = %ECC_ARITH# (5)
 1549                          %SUBC_OVRF#      0         Overflow Fault
 1550                          %SUBC_DVCHK#     1         Divide-check Fault
 1551
 1552                          When ECC = %ECC_PROG# (6)
 1553                          %SUBC_MME#       0         MME Fault
 1554                          %SUBC_DRAIL#     1         Derail Fault
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           43   
 1555                          %SUBC_FLTAG#     2         Fault-tag Fault
 1556
 1557                          When ECC = %ERR_ERROR# (7)
 1558                          %SUBC_MEMORY#    0         Memory Fault
 1559                          %SUBC_CMMD#      1         Command Fault
 1560                          %SUBC_LOCKUP#    2         Lockup Fault
 1561                          %SUBC_IPR#       3         Illegal Procedure Fault
 1562                          %SUBC_MSEG#      4         Missing Segment Fault
 1563                          %SUBC_MPAGE#     5         Missing Page Fault
 1564                          %SUBC_SEC2#      6         Security Fault, Class 2
 1565                          %SUBC_PRTY#      7         Parity Fault
 1566                          %SUBC_OPNC#      8         Operation Not Complete Fault
 1567                          %SUBC_SEC1#      9         Security Fault, Class 1
 1568                          %SUBC_DLNK#     10         Dynamic Linking Fault
 1569                          %SUBC_MWSP#     11         Missing Working Space Fault
 1570
 1571                          TF
 1572                          */
 1573            2 FLTREG,               /* FAULT REGISTER                                                   */
 1574                          /*K*   B$FLT.FLTREG = VALUE-BIT(36).  Contains
 1575                          the contents of the Fault Register at the
 1576                          time of the fault.
 1577                          */
 1578              3 IPR_OPC BIT(1) UNAL, /* IPR: ILLEGAL OP CODE                                            */
 1579              3 IPR_ADDR BIT(1) UNAL, /* IPR: ILLEGAL ADDR OR MODIFIER                                  */
 1580              3 CMD_SLAVE BIT(1) UNAL, /* CMD: ILLEGAL SLAVE PROCEDURE                                  */
 1581              3 IPR_OTHER BIT(1) UNAL, /* IPR: ALL OTHERS                                               */
 1582              3 STR_NEA BIT(1) UNAL, /* STR: NON-EXISTANT ADDRESS                                       */
 1583              3 STR_BND BIT(1) UNAL, /* STR: OUT OF BOUNDS                                              */
 1584              3 IPR_EIS BIT(1) UNAL, /* IPR: ILLEGAL DATA (EIS)                                         */
 1585              3 PRTY_UPPER BIT(1) UNAL, /* PROCESSOR PARITY: UPPER                                      */
 1586              3 PRTY_LOWER BIT(1) UNAL, /* PROCESSOR PARITY: LOWER                                      */
 1587              3 CON_PORT_A BIT(1) UNAL, /* CONNECT PORT A                                               */
 1588              3 CON_PORT_B BIT(1) UNAL, /* CONNECT PORT B                                               */
 1589              3 CON_PORT_C BIT(1) UNAL, /* CONNECT PORT C                                               */
 1590              3 CON_PORT_D BIT(1) UNAL, /* CONNECT PORT D                                               */
 1591              3 ONC_PROC_ERR_1 BIT(1) UNAL, /* OPER NOT COMPLETE #1                                     */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           44   
 1592              3 ONC_PROC_ERR_2 BIT(1) UNAL, /* OPER NOT COMPLETE #2                                     */
 1593              3 * BIT(1) UNAL,
 1594              3 IA_PORT_A UBIN(4) UNAL, /* PORT A ILLEGAL ACTION                                        */
 1595              3 IA_PORT_B UBIN(4) UNAL, /* PORT B ILLEGAL ACTION                                        */
 1596              3 IA_PORT_C UBIN(4) UNAL, /* PORT C ILLEGAL ACTION                                        */
 1597              3 IA_PORT_D UBIN(4) UNAL, /* PORT D ILLEGAL ACTION                                        */
 1598              3 CSH_DIR_PRTY BIT(1) UNAL, /* CACHE DIRECTORY PARITY                                     */
 1599              3 CSH_STORE_PRTY BIT(1) UNAL, /* CACHE STORE PARITY                                       */
 1600              3 CSH_IA_STORE BIT(1) UNAL, /* ILLEGAL ACTION ON STORE                                    */
 1601              3 CSH_PRTY_BLK_LD BIT(1) UNAL, /* PARITY ON BLOCK LOAD                                    */
 1602            2 ERR,
 1603                          /*K*   B$FLT.ERR is the 36 bit error code.  The
 1604                          error code contains the following:                                            */
 1605              3 FCG BIT(12) UNAL,
 1606                          /*K*   B$FLT.ERR.FCG = VALUE-BIT(12). Contains the
 1607                          Functional Code Group portion of the error code.                              */
 1608              3 MID BIT(6) UNAL,
 1609                          /*K*   B$FLT.ERR.MID = VALUE-BIT(6).  Contains the
 1610                          Module ID portion of the error code.                                          */
 1611              3 MON BIT(1) UNAL,
 1612                          /*K*   B$FLT.ERR.MON = VALUE-BIT(1).  Indicates that
 1613                          the error code was generated by the monitor.                                  */
 1614              3 ERR# UBIN(14) UNAL,
 1615                          /*K*   B$FLT.ERR.ERR# = VALUE-UBIN(14).  Contains the
 1616                          error code (see file B_ERRORS_C).                                             */
 1617              3 CODE REDEF ERR# UBIN(14) UNAL,
 1618              3 SEV UBIN(3) UNAL,
 1619                          /*K*   B$FLT.ERR.SEV = VALUE-UBIN(3).  Contains the
 1620                          severity of the error.                                                        */
 1621      %IF (TEXTCHAR(HREGS) = 'NO');
 1622            2 P# UBIN(36);
 1623      %ELSE;
 1624            2 P# UBIN(36),
 1625                          /*K*   B$FLT.P# = VALUE-UBIN(36).  Contains
 1626                          the size of the History Register data that
 1627                          follows.  No History Register information will
 1628                          be included in the B$FLT frame unless specifically
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           45   
 1629                          requested via the M$TRAP Service Request.  The size
 1630                          of the History Register information is dependent
 1631                          on the CPU Type.  One of the following structures
 1632                          may be used to access the History Register data:
 1633                          }
 1634                          }   B$HR_ELS1
 1635                          }   B$HR_L66
 1636                          }   B$HR_DPSE
 1637                          }   B$HR_DPS90XA
 1638                          }   B$HR_DPS8000
 1639                          }
 1640                          Please refer to B$FLT.CPU_TYPE.
 1641                          */
 1642      /* The following are the labels used in B$FLT in A00 and A01.  */
 1643      /* Note that the order of VU_HR and DU_HR for L66 is reversed for B00  */
 1644            2 CU_HR(0:15) BIT(72),
 1645            2 OU_HR(0:15) BIT(72),
 1646            2 VU_HR(0:15) BIT(72),
 1647            2 DU_HR(0:15) BIT(72);
 1648      %ENDIF;
 1649
 1650
 1651      /*****THESE EQUS ARE FOR BACKWARD COMPATABILITY.  THE
 1652            NAMES ARENT ADVERTISED.  THE EQUS FROM %SUB_EXC
 1653            SHOULD BE USED.                        *******/
 1654      /* DEFINITION OF FALUT FRAME ECC (B$FLT.SSFRAME.ECC) */
 1655      %EQU F_ARITH#=5;
 1656      %EQU F_PROG#=6;
 1657      %EQU F_ERROR#=7;
 1658
 1659
 1660      /* DEFINITION OF 5 BIT FAULT CODE (B$FLT.SSFRAME.FCODE) */
 1661      %EQU FLT_MEMORY#='00001'B;
 1662      %EQU FLT_MME#='00010'B;
 1663      %EQU FLT_FLTAG#='00011'B;
 1664      %EQU FLT_CMMD#='00101'B;
 1665      %EQU FLT_DRAIL#='00110'B;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           46   
 1666      %EQU FLT_LOCKUP#='00111'B;
 1667      %EQU FLT_PRTY#='01001'B;
 1668      %EQU FLT_IPR#='01010'B;
 1669      %EQU FLT_OPNC#='01011'B;
 1670      %EQU FLT_OVRF#='01101'B;
 1671      %EQU FLT_DVCHK#='01110'B;
 1672      %EQU FLT_SEC1#='10000'B;
 1673      %EQU FLT_MSEG#='10010'B;
 1674      %EQU FLT_MSPACE#='10011'B;
 1675      %EQU FLT_MPAGE#='10100'B;
 1676      %EQU FLT_SEC2#='10101'B;
 1677
 1678      /*DEFINITION OF B$FLT.SUBC FOR ECC=F_ARITH#  */
 1679      %EQU SC_OVRF#=0;
 1680      %EQU SC_DVCHK#=1;
 1681
 1682      /*DEFINITION OF B$FLT.SUBC FOR ECC=F_PROG#  */
 1683      %EQU SC_MME#=0;
 1684      %EQU SC_DRAIL#=1;
 1685      %EQU SC_FLTAG#=2;
 1686
 1687      /*DEFINITION OF B$FLT.SUBC FOR ECC=F_ERR#   */
 1688      %EQU SC_MEMORY#=0;
 1689      %EQU SC_CMMD#=1;
 1690      %EQU SC_LOCKUP#=2;
 1691      %EQU SC_IPR#=3;
 1692      %EQU SC_MSEG#=4;
 1693      %EQU SC_MPAGE#=5;
 1694      %EQU SC_SEC2#=6;
 1695      %EQU SC_PRTY#=7;
 1696      %EQU SC_OPNC#=8;
 1697      %EQU SC_SEC1#=9;
 1698
 1699      %MEND;
 1700
 1701                          /*F* NAME: B$HR_L66
 1702
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           47   
 1703                          The B$HR_L66 macro may used to generate a based
 1704                          structure defining the History Register information
 1705                          that is appended to the standard B$FLT frame when
 1706                          the CPU type is L66.  The format of this structure
 1707                          can be found in Appendix A.  The sub-fields in
 1708                          this structure have the following meanings:
 1709                          */
 1710
 1711      %MACRO B$HR_L66 (NAME=B$HR_L66,STCLASS=BASED);
 1712      DCL 1 NAME STCLASS ALIGNED,
 1713            2 FLTFRAME(0:67) BIT(36) UNAL,
 1714                          /*K* B$HR_L66.FLTFRAME = ARRAY(0:67) BIT(36).  This
 1715                          area contains the standard B$FLT information.  Use
 1716                          the B$FLT macro to generate a structure that may be
 1717                          used to access the information in this area.
 1718                          */
 1719            2 CU_HR(0:15) BIT(72),
 1720                          /*K*   B$HR_L66.CU_HR = ARRAY(0:15) BIT(72).
 1721                          Contains the contents of the Control Unit
 1722                          History Registers at the time of the fault.
 1723                          */
 1724            2 OU_HR(0:15) BIT(72),
 1725                          /*K*   B$HR_L66.OU_HR = ARRAY(0:15) BIT(72).
 1726                          Contains the contents of the Operations Unit
 1727                          History Registers at the time of the fault.
 1728                          */
 1729            2 VU_HR(0:15) BIT(72),
 1730                          /*K*   B$HR_L66.VU_HR = ARRAY(0:15) BIT(72).
 1731                          Contains the contents of the Virtual Unit
 1732                          History Registers at the time of the fault.
 1733                          */
 1734            2 DU_HR(0:15) BIT(72);
 1735                          /*K*   B$HR_L66.DU_HR = ARRAY(0:15) BIT(72).
 1736                          Contains the contents of the Decimal Unit
 1737                          History Registers at the time of the fault.
 1738                          */
 1739      %MEND;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           48   
 1740
 1741
 1742                          /*F* NAME: B$HR_DPSE
 1743
 1744                          The B$HR_DPSE macro may used to generate a based
 1745                          structure defining the History Register information
 1746                          that is appended to the standard B$FLT frame when
 1747                          the CPU type is DPSE.  The format of this structure
 1748                          can be found in Appendix A.  The sub-fields in
 1749                          this structure have the following meanings:
 1750                          */
 1751
 1752      %MACRO B$HR_DPSE (NAME=B$HR_DPSE,STCLASS=BASED);
 1753      DCL 1 NAME STCLASS ALIGNED,
 1754            2 FLTFRAME(0:67) BIT(36) UNAL,
 1755                          /*K* B$HR_DPSE.FLTFRAME = ARRAY(0:67) BIT(36).  This
 1756                          area contains the standard B$FLT information.  Use
 1757                          the B$FLT macro to generate a structure that may be
 1758                          used to access the information in this area.
 1759                          */
 1760            2 CU_HR(0:63) BIT(72),
 1761                          /*K*   B$HR_DPSE.CU_HR = ARRAY(0:63) BIT(72).
 1762                          Contains the contents of the Control Unit
 1763                          History Registers at the time of the fault.
 1764                          */
 1765            2 OUDU_HR(0:63) BIT(72),
 1766                          /*K*   B$HR_DPSE.OUDU_HR = ARRAY(0:63) BIT(72).
 1767                          Contains the contents of the Operations Unit and Decimal Unit
 1768                          History Registers at the time of the fault.
 1769                          */
 1770            2 VU1_HR(0:63) BIT(72),
 1771                          /*K*   B$HR_DPSE.VU1_HR = ARRAY(0:63) BIT(72).
 1772                          Contains the contents of the Virtual Unit 1
 1773                          History Registers at the time of the fault.
 1774                          */
 1775            2 VU2_HR(0:63) BIT(72);
 1776                          /*K*   B$HR_DPSE.VU2_HR = ARRAY(0:15) BIT(72).
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           49   
 1777                          Contains the contents of the Virtual Unit 2
 1778                          History Registers at the time of the fault.
 1779                          */
 1780      %MEND;
 1781
 1782
 1783
 1784                          /*F* NAME: B$HR_ELS1
 1785
 1786                          The B$HR_ELS1 macro may used to generate a based
 1787                          structure defining the History Register information
 1788                          that is appended to the standard B$FLT frame when
 1789                          the CPU type is ELS1.  The format of this structure
 1790                          can be found in Appendix A.  The sub-fields in
 1791                          this structure have the following meanings:
 1792                          */
 1793
 1794      %MACRO B$HR_ELS1 (NAME=B$HR_ELS1,STCLASS=BASED);
 1795      DCL 1 NAME STCLASS ALIGNED,
 1796            2 FLTFRAME(0:67) BIT(36) UNAL,
 1797                          /*K* B$HR_ELS1.FLTFRAME = ARRAY(0:67) BIT(36).  This
 1798                          area contains the standard B$FLT information.  Use
 1799                          the B$FLT macro to generate a structure that may be
 1800                          used to access the information in this area.
 1801                          */
 1802            2 HR(0:15) BIT(72);
 1803                          /*K* B$HR_ELS1.HR = ARRAY(O:15) BIT(72).
 1804                           Contains the contents of the History Registers at
 1805                           the time of the fault.
 1806                          */
 1807      %MEND;
 1808
 1809
 1810
 1811                          /*F* NAME: B$HR_DPS90XA
 1812
 1813                          The B$HR_DPS90XA macro may used to generate a based
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           50   
 1814                          structure defining the History Register information
 1815                          that is appended to the standard B$FLT frame when
 1816                          the CPU type is DPS90XA.  The format of this structure
 1817                          can be found in Appendix A.  The sub-fields in
 1818                          this structure have the following meanings:
 1819                          */
 1820
 1821      %MACRO B$HR_DPS90XA (NAME=B$HR_DPS90XA,STCLASS=BASED);
 1822      DCL 1 NAME STCLASS ALIGNED,
 1823            2 FLTFRAME(0:67) BIT(36) UNAL,
 1824                          /*K* B$HR_DPS90XA.FLTFRAME = ARRAY(0:67) BIT(36).
 1825                          Contains the standard B$FLT information.  Use
 1826                          the B$FLT macro to generate a structure that may be
 1827                          used to access the information in this area.
 1828                          */
 1829            2 IC_HR(0:15) BIT(36);
 1830                          /*K*   B$HR_DPS90XA.IC_HR = ARRAY(0:15) BIT(36)
 1831                          Contains the contents of the History Registers
 1832                          at the time of the fault.
 1833                          */
 1834      %MEND;
 1835
 1836                          /*F* NAME: B$HR_DPS8000
 1837
 1838                          The B$HR_DPS8000 macro may used to generate a based
 1839                          structure defining the History Register information
 1840                          that is appended to the standard B$FLT frame when
 1841                          the CPU type is DPS8000.  The format of this structure
 1842                          can be found in Appendix A.  The sub-fields in
 1843                          this structure have the following meanings:
 1844                          */
 1845
 1846      %MACRO B$HR_DPS8000 (NAME=B$HR_DPS8000,STCLASS=BASED);
 1847      DCL 1 NAME STCLASS ALIGNED,
 1848            2 FLTFRAME(0:67) BIT(36) UNAL,
 1849                          /*K* B$HR_DPS8000.FLTFRAME = ARRAY(0:67) BIT(36).
 1850                          Contains the standard B$FLT information.  Use
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           51   
 1851                          the B$FLT macro to generate a structure that may be
 1852                          used to access the information in this area.
 1853                          */
 1854            2 HR(0:63),
 1855              3 EXOP BIT(36),
 1856                          /*K*   B$HR_DPS8000.HR.EXOP = BIT(36)
 1857                          Contains the contents of the History Registers
 1858                          word 0 at the time of the fault.
 1859                          */
 1860              3 FLG BIT(36),
 1861                          /*K*   B$HR_DPS8000.HR.FLG = BIT(36)
 1862                          Contains the contents of the History Registers
 1863                          word 1 at the time of the fault.
 1864                          */
 1865              3 RMA BIT(36),
 1866                          /*K*   B$HR_DPS8000.HR.RMA = BIT(36)
 1867                          Contains the contents of the History Registers
 1868                          word 2 at the time of the fault.
 1869                          */
 1870              3 ZEROES BIT(36);
 1871                          /*K*   B$HR_DPS8000.HR.ZEROES = BIT(36)
 1872                          Contains the contents of the History Registers
 1873                          word 3 at the time of the fault.
 1874                          */
 1875      %MEND;
 1876                          /*F* NAME: VLP_PTC
 1877
 1878                          The VLP_PTC macro defines the structure of the
 1879                          Program Trap Conditions returned by M$TRAP.                                   */
 1880
 1881      %MACRO VLP_PTC
 1882              (FPTN=VLP_PTC,
 1883               STCLASS=STATIC);
 1884
 1885      %LSET LISTDIR='0'B;
 1886      %LSET LISTEXP='1'B;
 1887      %LSET LISTCOM='0'B;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           52   
 1888      %LSET LISTSUB='1'B;
 1889      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 1890      %IF (SUBSTR(STR,0,6)='STATIC') OR
 1891       (SUBSTR(STR,0,8)='CONSTANT') OR
 1892       (SUBSTR(STR,0,3)='EXT');
 1893       %LSET INIT=CHARTEXT('INIT');
 1894      %ELSE;
 1895       %LSET INIT=CHARTEXT('/*');
 1896      %ENDIF;
 1897
 1898      DCL 1 FPTN STCLASS DALIGNED,
 1899            2 PMME# EPTR,
 1900                          /*K* PMME = ENTRY  Specifies the procedure to receive
 1901                          control if a monitor service error occurs on a call
 1902                          without the ALTRET option.                                                    */
 1903            2 ARITHMETIC# EPTR,
 1904                          /*K* ARITHMETIC = ENTRY  Specifies the procedure to
 1905                          receive control if an arithmetic fault occurs.*/
 1906            2 PROGRAMMED# EPTR,
 1907                          /*K* PROGRAMMED = ENTRY  Specifies the procedure
 1908                          to receive control if a fault in the PROGRAMMED
 1909                          class occurs.*/
 1910            2 ERRORS# EPTR,
 1911                          /*K* ERRORS = ENTRY  Specifies the procedure to
 1912                          receive control if a fault in the ERRORS class
 1913                          occurs.*/
 1914            2 FLAGS,
 1915                          /*K* FLAGS  Specifies the action to take in each
 1916                          condition listed below.  For each flag, the value
 1917                          '10'B means TRAP, '00'B means ABORT, '11'B is the
 1918                          default which means the fault flag in the ECCB
 1919                          is not to be changed.
 1920                          */
 1921              3 OVERFLOW# BIT(2) UNAL,
 1922                          /*K* FLAGS.OVERFLOW = VALUE-BIT(2).                                           */
 1923              3 DIVIDE_CHECK# BIT(2) UNAL,
 1924                          /*K* FLAGS.DIVIDE_CHECK = VALUE-BIT(2).*/
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           53   
 1925              3 MME# BIT(2) UNAL,
 1926                          /*K* FLAGS.MME = VALUE-BIT(2).                                                */
 1927              3 DERAIL# BIT(2) UNAL,
 1928                          /*K* FLAGS.DERAIL = VALUE-BIT(2).                                             */
 1929              3 FAULT_TAG# BIT(2) UNAL,
 1930                          /*K* FLAGS.FAULT_TAG = VALUE-BIT(2).                                          */
 1931              3 * BIT(2) UNAL,
 1932              3 RESTORE# BIT(2) UNAL,
 1933                          /*K* FLAGS.RESTORE = VALUE-BIT(2).                                            */
 1934              3 * BIT(2) UNAL,
 1935              3 SECURITY_1# BIT(2) UNAL,
 1936                          /*K* FLAGS.SECURITY_1 = VALUE-BIT(2).
 1937                          */
 1938              3 MEMORY# BIT(2) UNAL,
 1939                          /*K* FLAGS.MEMORY = VALUE-BIT(2).                                             */
 1940              3 COMMAND# BIT(2) UNAL,
 1941                          /*K* FLAGS.COMMAND = VALUE-BIT(2).                                            */
 1942              3 LOCKUP# BIT(2) UNAL,
 1943                          /*K* FLAGS.LOCKUP = VALUE=BIT(2).                                             */
 1944              3 IPR# BIT(2) UNAL,
 1945                          /*K* FLAGS.IPR = VALUE-BIT(2).                                                */
 1946              3 MISSING_SEG# BIT(2) UNAL,
 1947                          /*K* FLAGS.MISSING_SEG = VALUE-BIT(2).                                        */
 1948              3 MISSING_PAGE# BIT(2) UNAL,
 1949                          /*K* FLAGS.MISSING_PAGE = VALUE-BIT(2).
 1950                          */
 1951              3 SECURITY_2# BIT(2) UNAL,
 1952                          /*K* FLAGS.SECURITY_2 = VALUE-BIT(2).                                         */
 1953              3 HARDWARE# BIT(2) UNAL,
 1954                          /*K* FLAGS.HARDWARE = VALUE-BIT(2).                                           */
 1955              3 HISTORY_REGS# BIT(2) UNAL,
 1956                          /*K* FLAGS.HISTORY_REGS = VALUE-BIT(2).                                       */
 1957            2 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 1958      %MEND;
 1959                          /*F* NAME: M$STRAP - Simulate Trap or Break.
 1960
 1961                           The M$STRAP monitor service may be used to
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           54   
 1962                           simulate the occurrence of a hardware trap
 1963                           or the break of a time-sharing terminal.
 1964
 1965                          The M$STRAP service simulates a trap by imitating
 1966                          the occurrence of a fault in the ARITHMETIC,
 1967                          ERRORS, or PROGRAMMED category.  Any trap
 1968                          conditions and procedures previously established by
 1969                          the M$TRAP service are in effect at a simulated
 1970                          trap.  Saving of the environment and transfer of
 1971                          control to the user's trap procedure are identical
 1972                          to the functions described in the discussion of
 1973                          the M$TRAP service.
 1974
 1975                          When used to simulate the occurrence of the
 1976                          break, the user must first have established
 1977                          break control via the M$INT monitor service.
 1978                          The environment will be saved and the user's
 1979                          interrupt routine entered as described in the
 1980                          discussion of the M$INT service.
 1981
 1982                          The form of the call for this service is:
 1983
 1984                          CALL M$STRAP (FPT_STRAP) [ALTRET (label)];
 1985
 1986                          The parameter for the M$STRAP service is as
 1987                          follows:*/
 1988
 1989
 1990      %MACRO FPT_STRAP(  FPTN=FPT_STRAP,
 1991                         STCLASS=STATIC,
 1992                         BRK(YES='1'B,NO='0'B)='0'B,
 1993                         STRAP(
 1994                         MEMORY=1,
 1995                         MME=2,
 1996                         FAULT_TAG=3,
 1997                         COMMAND=5,
 1998                         DERAIL=6,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           55   
 1999                         LOCKUP=7,
 2000                         IPR=10,
 2001                         OVERFLOW=13,
 2002                         DIVIDE_CHECK=14,
 2003                         SECURITY_1=16,
 2004                         MISSING_SEGMENT=18,
 2005                         MISSING_PAGE=20,
 2006                         SECURITY_2=21)=0);
 2007
 2008      %LSET LISTDIR='0'B;
 2009      %LSET LISTEXP='1'B;
 2010      %LSET LISTCOM='0'B;
 2011      %LSET LISTSUB='1'B;
 2012      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2013      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2014       (SUBSTR(STR,0,8)='CONSTANT') OR
 2015       (SUBSTR(STR,0,3)='EXT');
 2016       %LSET INIT=CHARTEXT('INIT');
 2017      %ELSE;
 2018       %LSET INIT=CHARTEXT('/*');
 2019      %ENDIF;
 2020
 2021
 2022
 2023
 2024      DCL 1 FPTN STCLASS DALIGNED,
 2025            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2026            2 V DALIGNED,
 2027              3 STRAP# UBIN(5) UNAL %INIT(STRAP)%CHARTEXT('/**/'),
 2028                          /*K* STRAP = OPTION   specifies the trap to
 2029                          simulate.  The options are listed below.
 2030
 2031                          TU
 2032                            MEMORY
 2033                            MME
 2034                            FAULT_TAG
 2035                            COMMAND
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           56   
 2036                            DERAIL
 2037                            LOCKUP
 2038                            IPR
 2039                            OVERFLOW
 2040                            DIVIDE_CHECK
 2041                            MISSING_SEGMENT
 2042                            MISSING_PAGE
 2043                            SECURITY_1
 2044                            SECURITY_2
 2045
 2046                          TF
 2047                          Default = no simulated trap condition.
 2048                          */
 2049              3 BRK# BIT(1) UNAL %INIT(BRK)%CHARTEXT('/**/'),
 2050                          /*K* BRK ={YES|NO}   specifies, when YES, that a
 2051                           break is to be simulated.  Default = NO.
 2052                           */
 2053              3 * BIT(30) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2054              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2055
 2056      %MEND;
 2057
 2058
 2059                          /*F* NAME: M$STIMER - Set Timer.
 2060
 2061                          INTERVAL TIMER CONTROL
 2062
 2063                          The CP-6 interval timer is a software timer
 2064                          service provided by the monitor for each user that
 2065                          requests it.  The monitor measures the user's
 2066                          execution and monitor service processing time, in
 2067                          millisecond units, and reports the conclusion of
 2068                          the specified time interval to the user through
 2069                          the Exceptional Condition Processing mechanism.
 2070                          The time measurement does not include time spent
 2071                          executing other users or monitor overhead
 2072                          procedures.  The time measurement is made each
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           57   
 2073                          time the monitor receives control from the user,
 2074                          after each monitor service, time slice quantum,
 2075                          and I/O interrupt when the user is executing.
 2076                          Thus the user receives control at the Exceptional
 2077                          Condition procedure no sooner than the requested
 2078                          interval and no later than the interval plus one
 2079                          user quantum time.
 2080
 2081                          The M$STIMER and M$TTIMER services permit the user
 2082                          to request the interval timer service, obtain the
 2083                          unelapsed time within the current interval, or
 2084                          cancel the current interval.
 2085
 2086
 2087                          M$STIMER
 2088
 2089                          The M$STIMER service requests a time interval and
 2090                          specifies the Exception Condition processing
 2091                          procedure to receive control at the conclusion of
 2092                          the interval.  Only one interval may be in
 2093                          progress at a time.  If an earlier interval is in
 2094                          progress when the M$STIMER service is requested,
 2095                          it is forgotten.
 2096
 2097                          NOTE:  Special shared processors may not call the
 2098                          M$STIMER service.
 2099
 2100                          The form of the call for this service is:
 2101
 2102                          CALL M$STIMER (FPT_STIMER) [ALTRET(label)];
 2103
 2104                          The parameters for M$STIMER are as follows:                                   */
 2105      %MACRO  FPT_STIMER
 2106                 (FPTN=FPT_STIMER,
 2107                  STCLASS=STATIC,
 2108                  UNITS=0,
 2109                  UENTRY=NIL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           58   
 2110                  UTYPE(TUN=0,SEC=1,MIN=2)=0);
 2111
 2112      %LSET LISTDIR='0'B;
 2113      %LSET LISTEXP='1'B;
 2114      %LSET LISTCOM='0'B;
 2115      %LSET LISTSUB='1'B;
 2116      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2117      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2118       (SUBSTR(STR,0,8)='CONSTANT') OR
 2119       (SUBSTR(STR,0,3)='EXT');
 2120       %LSET INIT=CHARTEXT('INIT');
 2121      %ELSE;
 2122       %LSET INIT=CHARTEXT('/*');
 2123      %ENDIF;
 2124
 2125      DCL 1 FPTN STCLASS DALIGNED,
 2126            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2127            2 V DALIGNED,
 2128              3 UENTRY# EPTR %INIT(ENTADDR(UENTRY))%CHARTEXT('/**/'),
 2129                          /*K* UENTRY = ENTRY    specifies an entry point to
 2130                          the user timer run-out procedure.  If UENTRY is
 2131                          not specified, no timing will occur.  The default
 2132                          is NIL.*/
 2133              3 UTYPE# UBIN(2) %INIT(UTYPE)%CHARTEXT('/**/') UNAL,
 2134                          /*K* UTYPE = OPTION    specifies the kind of time
 2135                          that UNITS is expressed in.  Valid options are:
 2136                          }
 2137                          }  TUN milliseconds
 2138                          }  SEC seconds
 2139                          }  MIN minutes
 2140                          }
 2141                          The default is TUN.*/
 2142              3 * UBIN(8) UNAL %INIT(0)%CHARTEXT('/**/'),
 2143              3 UNITS# UBIN(26) %INIT(UNITS)%CHARTEXT('/**/') UNAL;
 2144                          /*K* UNITS = VALUE-DEC    specifies the time
 2145                          interval.  It must be specified.  The maximum
 2146                          permissible value of UNITS is:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           59   
 2147                          }
 2148                          }  value < 2**26 if UTYPE = TUN
 2149                          }  value < 2**16 if UTYPE = SEC
 2150                          }  value < 2**10 if UTYPE = MIN
 2151                          }
 2152                          Default=0.*/
 2153      %MEND;
 2154
 2155
 2156
 2157                          /*F* NAME: M$TTIMER - Test Timer.
 2158
 2159                          The M$TTIMER service returns the current unelapsed
 2160                          time and optionally allows the current interval to
 2161                          be cancelled.  If the current interval is
 2162                          cancelled, the user specified timer run-out
 2163                          procedure is not entered.
 2164
 2165                          NOTE:  Special shared processors may not call the
 2166                          M$TTIMER service.
 2167
 2168                          The form of the call for this service is:
 2169
 2170                          CALL M$TTIMER (FPT_TTIMER) [ALTRET (label)];
 2171
 2172                          The parameters for this service are as follows:*/
 2173      %MACRO  FPT_TTIMER
 2174                 (FPTN=FPT_TTIMER,
 2175                  STCLASS=STATIC,
 2176                  UNITS=NIL,
 2177                  UTYPE(TUN=0,SEC=1,MIN=2)=0,
 2178                  CANCEL(YES='1'B,NO='0'B)='0'B);
 2179
 2180      %LSET LISTDIR='0'B;
 2181      %LSET LISTEXP='1'B;
 2182      %LSET LISTCOM='0'B;
 2183      %LSET LISTSUB='1'B;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           60   
 2184      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2185      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2186       (SUBSTR(STR,0,8)='CONSTANT') OR
 2187       (SUBSTR(STR,0,3)='EXT');
 2188       %LSET INIT=CHARTEXT('INIT');
 2189      %ELSE;
 2190       %LSET INIT=CHARTEXT('/*');
 2191      %ENDIF;
 2192
 2193      DCL 1 FPTN STCLASS DALIGNED,
 2194            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2195            2 UNITS_ BIT(72) %INIT(VECTOR(UNITS))%CHARTEXT('/**/'),
 2196                          /*K* UNITS = VARIABLE    locates an 1-word area
 2197                          where the unelapsed time value is returned.  The
 2198                          default is NIL.*/
 2199            2 V DALIGNED,
 2200              3 CANCEL# BIT(1) %INIT(CANCEL)%CHARTEXT('/**/') UNAL,
 2201                          /*K* CANCEL = {YES|NO}  specifies, if YES, that the current
 2202                          running interval is to be cancelled.  The default
 2203                          is NO.*/
 2204              3 UTYPE# UBIN(2) %INIT(UTYPE)%CHARTEXT('/**/') UNAL,
 2205                          /*K* UTYPE = OPTION    specifies how the current
 2206                          value of the interval timer is to be expressed.
 2207                          Valid options are:
 2208                          }
 2209                          }  TUN milliseconds
 2210                          }  SEC seconds
 2211                          }  MIN minutes
 2212                          }
 2213                          The default is TUN.*/
 2214
 2215              3 * UBIN(33) %INIT(0) %CHARTEXT('/**/') UNAL;
 2216      %MEND;
 2217
 2218
 2219
 2220                          /*F* NAME: M$INT_ - Set Break Control.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           61   
 2221
 2222                          The M$INT service establishes the procedure to
 2223                          process an interrupt generated by depression of
 2224                          the BRK key at a time-sharing terminal.  The
 2225                          user's interrupt procedure takes
 2226                          control immediately, if the user domain is in
 2227                          control when the interrupt occurs.  Table 6-2
 2228                          summarizes the action taken if a domain other than
 2229                          the user is in control when the interrupt occurs.
 2230
 2231                          When the interrupt procedure takes control, the
 2232                          environment is available in the Exception
 2233                          Condition Stack top frame.  The user can use the
 2234                          based structure B$EXCFR to access the Exception
 2235                          Condition Stack frame.  Exit from the interrupt
 2236                          procedure (to return to the point of interruption)
 2237                          is discussed under "Exiting Exceptional Condition
 2238                          Procedure".
 2239
 2240                          A number of interrupts may accumulate for a given
 2241                          user; thus the interrupt procedure may be reentered.
 2242                          The user may enclose short portions of code with
 2243                          the DO INHIBIT...END statements which ensures up
 2244                          to two milliseconds free of interruption.  (DO
 2245                          INHIBIT does not inhibit interruption during any
 2246                          monitor service call included in the DO group,
 2247                          however.)
 2248
 2249                          A Control-Y sequence is simulated if the user hits four
 2250                          consecutive breaks.  Following the Control-Y sequence, the
 2251                          Command Processor always takes control.
 2252                          A count of breaks is accumulated and can be reset to zero by
 2253                          calling M$TRMPRG with RSTBRK=YES.  This will avoid the simulation
 2254                          of the Control-Y sequence.
 2255
 2256                          There is no user control over the Control-Y sequence;
 2257                          the Command Processor will always be given control.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           62   
 2258                          However, the user may request that
 2259                          control be given to its event procedure
 2260                          prior to continuing normal program execution
 2261                          following the "GO" command to the Command Processor.
 2262                          (Refer to M$EVENT in this Section.)
 2263
 2264                          The form of the call for this service is:
 2265
 2266                          CALL M$INT (FPT_INT) [ALTRET (label)];
 2267
 2268                          The parameter for this service is as follows:
 2269                          */
 2270
 2271
 2272
 2273      %MACRO FPT_INT
 2274                    (FPTN=FPT_INT,
 2275                    UENTRY=NIL,
 2276                     STCLASS=STATIC);
 2277
 2278      %LSET LISTDIR='0'B;
 2279      %LSET LISTEXP='1'B;
 2280      %LSET LISTCOM='0'B;
 2281      %LSET LISTSUB='1'B;
 2282      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2283      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2284       (SUBSTR(STR,0,8)='CONSTANT') OR
 2285       (SUBSTR(STR,0,3)='EXT');
 2286       %LSET INIT=CHARTEXT('INIT');
 2287      %ELSE;
 2288       %LSET INIT=CHARTEXT('/*');
 2289      %ENDIF;
 2290
 2291
 2292      DCL 1 FPTN STCLASS DALIGNED,
 2293            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2294            2 V DALIGNED,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           63   
 2295              3 UENTRY# EPTR %INIT(ENTADDR(UENTRY))%CHARTEXT('/**/'),
 2296                          /*K* UENTRY = ENTRY    locates the procedure that
 2297                          control is transferred to when the break key is
 2298                          depressed (or 'B:' is entered from console if activity
 2299                          to be interrupted is running as a console ghost).  A
 2300                          zero address or NIL resets a previous request for interrupt
 2301                          control.  The default is NIL.
 2302                          .brn 42
 2303                          ..::TB "Entry to M$INT Procedure"
 2304                          }           | Break Control            | Debug   |
 2305                          }Domain     |-----------------------------------------------------
 2306                          }in Control |  CP | Debug | ASL | USER | Control | Action Taken
 2307                          }-----------------------------------------------------------------
 2308                          }CP         | YES |   -   |  -  |   -  |    -    | Enter CP M$INT
 2309                          }           |     |       |     |      |         | handler.
 2310                          }-----------------------------------------------------------------
 2311                          }CP         | NO  |   -   |  -  |   -  |    -    | Interrupt
 2312                          }           |     |       |     |      |         | ignored.
 2313                          }-----------------------------------------------------------------
 2314                          }Debug      |  -  |  YES  |  -  |   -  |    -    | Enter Debugger
 2315                          }           |     |       |     |      |         | M$INT handler.
 2316                          }-----------------------------------------------------------------
 2317                          }Debug      |  -  |  NO   |  -  |   -  |    -    | Interrupt
 2318                          }           |     |       |     |      |         | ignored.
 2319                          }-----------------------------------------------------------------
 2320                          }ASL        |  -  |   -   | YES |   -  |    -    | Enter ASL M$INT
 2321                          }           |     |       |     |      |         | handler.
 2322                          }-----------------------------------------------------------------
 2323                          }ASL        |  -  |   -   | NO  |   -  | YES     | Enter Debug at
 2324                          }           |     |       |     |      |         | start address.
 2325                          }-----------------------------------------------------------------
 2326                          }ASL        |  -  |   -   | NO  | YES  | NO      | Defer interrupt
 2327                          }           |     |       |     |      |         | until ASL
 2328                          }           |     |       |     |      |         | relinquishes
 2329                          }           |     |       |     |      |         | control.
 2330                          }-----------------------------------------------------------------
 2331                          }ASL        |  -  |   -   | NO  | NO   | NO      | Enter CP at
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           64   
 2332                          }           |     |       |     |      |         | start address.
 2333                          }-----------------------------------------------------------------
 2334                          }USER       |  -  |   -   |  -  |  -   | YES     | Enter Debug at
 2335                          }           |     |       |     |      |         | start address.
 2336                          }-----------------------------------------------------------------
 2337                          }USER       |  -  |   -   |  -  | YES  | NO      | Enter User M$INT
 2338                          }           |     |       |     |      |         | handler.
 2339                          }-----------------------------------------------------------------
 2340                          }USER       |  -  |   -   |  -  | NO   | NO      | Enter CP at
 2341                          }           |     |       |     |      |         | start address.
 2342                          }-----------------------------------------------------------------
 2343                          ..::TB
 2344                             */
 2345              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2346
 2347
 2348      %MEND;
 2349
 2350
 2351
 2352                          /*F* NAME: B$BRK
 2353
 2354                          The B$BRK macro may be used to generate a based
 2355                          structure to access the top frame on the Exceptional
 2356                          Condition Stack from within a break control procedure.
 2357                          The format of this structure can be found in
 2358                          Appendix A.  The sub-fields in this structure
 2359                          have the following meanings:
 2360                          */
 2361
 2362      %MACRO B$BRK (NAME=B$BRK,STCLASS=BASED);
 2363
 2364        %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2365                          /*K*   B$BRK.SSFRAME contains the copy of the
 2366                          program's environment at the time of the
 2367                          interrupt condition.  The based structure
 2368                          B$EXCFR should be used to access
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           65   
 2369                          the environment.
 2370                          */
 2371                          /*K* B$BRK.BRKCNT is the number of terminal
 2372                          breaks received since the last read.                                          */
 2373                          /*K*   B$BRK.ERR is the 36 bit error code.  The
 2374                          error code contains the following:                                            */
 2375                          /*K*   B$BRK.ERR.FCG = VALUE-BIT(12). Contains the
 2376                          Functional Code Group portion of the error code.                              */
 2377                          /*K*   B$BRK.ERR.MID = VALUE-BIT(6).  Contains the
 2378                          Module ID portion of the error code.                                          */
 2379                          /*K*   B$BRK.ERR.MON = VALUE-BIT(1).  Indicates that
 2380                          the error code was generated by the monitor.                                  */
 2381                          /*K*   B$BRK.ERR.ERR# = VALUE-UBIN(14).  Contains the
 2382                          error code (see file B_ERRORS_C).                                             */
 2383                          /*K*   B$BRK.ERR.SEV = VALUE-UBIN(3).  Contains the
 2384                          severity of the error.                                                        */
 2385            2 P# UBIN;
 2386                          /*K* B$BRK.P# = VALUE-UBIN(36).  Contains the
 2387                          number of words of parameters that follow.
 2388                          For B$BRK, this field is always zero.                                         */
 2389
 2390      %MEND;
 2391
 2392
 2393                          /*F* NAME: M$EVENT - Set Event Control.
 2394
 2395                          The M$EVENT service works in conjunction with the
 2396                          M$READ, M$WRITE, M$ENQ, and other services with
 2397                          the no-wait option specified (WAIT=NO).  The user
 2398                          calls M$EVENT to establish the entry-address of an
 2399                          event processing procedure that receives control
 2400                          when an I/O completion occurs (for M$READ or
 2401                          M$WRITE), when a resource becomes available (as
 2402                          a result of M$ENQ), or when the user has been
 2403                          interrupted by the Command Processor (see the
 2404                          YC option).  The call to the M$READ,
 2405                          M$WRITE,  or M$ENQ service may optionally specify
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           66   
 2406                          an EVENT value.  This value is passed to the event
 2407                          processing procedure to identify the event that
 2408                          occurred.  If an EVENT value is not specified or
 2409                          is zero for a non-wait M$READ or M$WRITE
 2410                          operation, the event procedure is not entered on
 2411                          read or write completion.
 2412
 2413                          The asynchronous event reporting facility for
 2414                          no-wait IO completion is
 2415                          provided by either the M$EVENT monitor service
 2416                          or the M$CHECK monitor service
 2417                          discussed in Section 3.  These services allow the
 2418                          user to call a monitor service, continue
 2419                          processing while the monitor service is being
 2420                          performed, and be notified of its completion.
 2421
 2422                          Entry to the event procedure occurs at one of
 2423                          these points:  following a monitor service, at an
 2424                          I/O interrupt, or at completion of a time slice.
 2425                          If a program has been suspended by the M$WAIT
 2426                          service when an event completion occurs, the
 2427                          suspension is terminated and the event completion
 2428                          is reported.
 2429
 2430                          The user may request as many concurrent no-wait
 2431                          operations as desired.  The order in which events
 2432                          are processed is not necessarily the order in
 2433                          which they were requested.  The event procedure
 2434                          processes events in the order of event completion.
 2435
 2436                          The form of the call for this service is:
 2437
 2438                          CALL M$EVENT (FPT_EVENT) [ALTRET (label)];
 2439
 2440                          The parameter for this service is as follows:
 2441                          */
 2442
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           67   
 2443
 2444
 2445      %MACRO FPT_EVENT
 2446                    (FPTN=FPT_EVENT,
 2447                     UENTRY=NIL,
 2448                    YC(YES='1'B,NO='0'B)='0'B,
 2449                     STCLASS=STATIC);
 2450
 2451      %LSET LISTDIR='0'B;
 2452      %LSET LISTEXP='1'B;
 2453      %LSET LISTCOM='0'B;
 2454      %LSET LISTSUB='1'B;
 2455      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2456      %IF (SUBSTR(STR,0,6)='STATIC') OR
 2457       (SUBSTR(STR,0,8)='CONSTANT') OR
 2458       (SUBSTR(STR,0,3)='EXT');
 2459       %LSET INIT=CHARTEXT('INIT');
 2460      %ELSE;
 2461       %LSET INIT=CHARTEXT('/*');
 2462      %ENDIF;
 2463
 2464
 2465      DCL 1 FPTN STCLASS DALIGNED,
 2466            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 2467            2 V DALIGNED,
 2468              3 UENTRY# EPTR %INIT(ENTADDR(UENTRY))%CHARTEXT('/**/'),
 2469                          /*K* UENTRY = {ENTRY|NIL}  specifies the event
 2470                          procedure entry-address.  An address of zero or
 2471                          NIL resets a previous request and specifies that
 2472                          event completions of no-wait services are not to
 2473                          be reported.*/
 2474              3 YC# BIT(1) UNAL %INIT(YC)%CHARTEXT('/**/'),
 2475                          /*K* YC = {YES|NO}.   Specifies, if YES, that
 2476                          the procedure specified via the UENTRY option
 2477                          is also to be entered following a Control-Y then
 2478                          GO sequence from the user terminal.
 2479                          Default = NO.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           68   
 2480                          */
 2481              3 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/');
 2482
 2483                          /*F* NAME: Environment for M$EVENT.
 2484
 2485                          Refer to Appendix A for the layout of the
 2486                          top frame in the Exceptional Condition Stack upon
 2487                          entry to the event procedure.  The B$EXCFR based
 2488                          structure is available to access the common
 2489                          portion of the frame.  The value in B$EXCFR.SUBC
 2490                          uniquely identifies the type of event.
 2491                          Values (from the %SUB_EXC macro) are as follows:
 2492                          }
 2493                          }      Sub-code       Value       Meaning
 2494                          }      ________       _____       ___________
 2495                          }
 2496                          }      %SUBC_ENQ#       0         Enqueue Event Completion
 2497                          }
 2498                          }      %SUBC_IO#        1         No-wait I/O Completion
 2499                          }
 2500                          }      %SUBC_COOP#      2         Reserved by the Monitor
 2501                          }
 2502                          }      %SUBC_JRNLERR#   3         Journal requires
 2503                          }                                 error handling by owner
 2504                          }
 2505                          }      %SUBC_YC#        4         Continuing from Command
 2506                          }                                 Processor (YC-GO)
 2507                          }
 2508                          }      %SUBC_FPRG#      5         A FEP user program has
 2509                          }                                 just either exited,
 2510                          }                                 aborted or issued M$LDTRC
 2511                          }
 2512                          }      %SUBC_COMIO#     6         Communications IO event
 2513                          }
 2514                          The B$ENQ, B$NWIO, B$JRNLERR, B$FPRG and  B$COMIO based structures
 2515                          are available to access information
 2516                          pertinent to enqueueing, no-wait I/O operations,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           69   
 2517                          journal errors and FEP user program state changes.
 2518
 2519                          Reentry Considerations
 2520
 2521                          Once entered, the user's event procedure may be
 2522                          re-entered to report subsequent event completions.
 2523                          For example, a second outstanding no-wait I/O may
 2524                          complete while the user is asynchronously processing
 2525                          a prior no-wait I/O completion event.  Also, the
 2526                          M$EVENT routine could be interrupted for entry to
 2527                          the M$STIMER specified routine if the specified
 2528                          time expires while in event processing.
 2529                          The DO INHIBIT statement may be used to protect
 2530                          against reentry to the event procedure, if
 2531                          necessary.  The DO INHIBIT statement inhibits
 2532                          interrupts and timer run-out faults within a
 2533                          section of the program.  The DO INHIBIT statement
 2534                          inhibits for up to two milliseconds, but after
 2535                          that time a lockup fault will occur.  Within the
 2536                          code protected by DO INHIBIT, monitor service
 2537                          calls are not inhibited; thus event reporting can
 2538                          take place in the course of their execution.
 2539
 2540                          Inhibiting event reporting via the DO
 2541                          INHIBIT...END statements can be useful under
 2542                          various conditions.  Two sample cases are
 2543                          discussed below.
 2544                          }
 2545                          1.  A program tests a memory location to determine if
 2546                          an event has been reported and, if it has not been
 2547                          reported, calls M$WAIT to suspend the program
 2548                          until the event completes.  If DO  INHIBIT is not
 2549                          used prior to the test of the memory location, the
 2550                          event could be reported and the flag could be set
 2551                          between the test and the call to M$WAIT; in this
 2552                          case M$WAIT would suspend for the full wait time.
 2553                          If the DO INHIBIT statement is used just prior to
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           70   
 2554                          the test, event reporting is delayed until the
 2555                          M$WAIT service is called and the program is not
 2556                          suspended.
 2557
 2558                          2.  A program contains a data structure in which data
 2559                          modified by the event completion procedure and
 2560                          data modified by the main program are contained in
 2561                          the same memory word.  If the main program is
 2562                          interrupted while manipulating the data and the
 2563                          event procedure takes control and modifies its
 2564                          data, these modifications may be lost when control
 2565                          is returned to the main program and execution of
 2566                          the interrupted statement causes main program data
 2567                          to be restored to memory.  Placing DO
 2568                          INHIBIT...END statements in the main program can
 2569                          protect against such problems.
 2570
 2571
 2572                          Event Completion Processing and Domains
 2573                          }
 2574                          The monitor no-wait services and control via
 2575                          the M$EVENT YC option are available to each
 2576                          of the domains:  user, Alternate Shared Library,
 2577                          Debugger, and Command Processor.
 2578
 2579                          It is not necessary for the domain that called the
 2580                          no-wait service to be in control when the service
 2581                          completes.  If a special shared processor calls
 2582                          the no-wait service and then returns control to
 2583                          the user, the user is interrupted and the
 2584                          processor's event procedure is entered when the
 2585                          no-wait operation completes.  If the user calls
 2586                          the no-wait service and then enters a special
 2587                          shared processor, entry to the user's event
 2588                          procedure is delayed until control returns to the
 2589                          user .
 2590                          */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           71   
 2591      %MEND;
 2592
 2593                          /*F* NAME: B$NWIO
 2594
 2595                          The %B$NWIO macro may be used to generate a
 2596                          based structure of a frame placed on the TCB
 2597                          stack for a No-wait I/O event.  The format
 2598                          of this structure can be found in Appendix A.
 2599                          The sub-fields in this structure have the
 2600                          following meanings:
 2601                          */
 2602      /************* MUST MATCH VLP_STATION FROM STATION ON **************/
 2603
 2604      %MACRO B$NWIO (NAME=B$NWIO,STCLASS=BASED,PARONLY=0);
 2605
 2606       %IF PARONLY=0;
 2607
 2608         %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2609                          /*K*   B$NWIO.SSFRAME contains the copy of the program's
 2610                          environment at the time of the event.  The
 2611                          based structure B$EXCFR should be used to access this area.                   */
 2612                          /*K*   B$NWIO.SUBC = VALUE-UBIN(18).  Contains the event sub-code.
 2613                          For No-wait I/O completion this field will be set
 2614                          to %SUBC_IO#.
 2615                          */
 2616                          /*K* B$NWIO.EVID = VALUE-UBIN(36).  Contains the event ID as
 2617                          was specified on the M$READ or M$WRITE Service Request.
 2618                          */
 2619                          /*K* B$NWIO.ERR is the 36 bit error code, containing
 2620                          the following:                                                                */
 2621                          /*K* B$NWIO.ERR.FCG = VALUE-BIT(12).  Contains
 2622                          the Functional Code Group portion of the error code.                          */
 2623                          /*K* B$NWIO.ERR.MID = VALUE-BIT(6).  Contains the
 2624                          Module ID portion of the error code.                                          */
 2625                          /*K* B$NWIO.ERR.MON = VALUE-BIT(1).  Set if the error
 2626                          was generated by the monitor.                                                 */
 2627                          /*K* B$NWIO.ERR.ERR# = VALUE-UBIN(14).  Contains
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           72   
 2628                          the error code (see file B_ERRORS_C).                                         */
 2629                          /*K* B$NWIO.ERR.SEV = VALUE-UBIN(3).  Contains the
 2630                          severity of the error.                                                        */
 2631
 2632
 2633       %ELSE;
 2634
 2635      DCL 1 NAME STCLASS ALIGNED,
 2636
 2637       %ENDIF;
 2638
 2639            2 P# UBIN,
 2640                          /*K* B$NWIO.P# = VALUE-UBIN(36).  Contains the number
 2641                          of words of parameters that follow.                                           */
 2642
 2643            2 TYC BIT(36),
 2644                          /*K* B$NWIO.TYC = VALUE-BIT(36).  Contains the
 2645                          type of completion.  See F$DCB.TYC.                                           */
 2646
 2647            2 ARS UBIN,
 2648                          /*K* B$NWIO.ARS = VALUE-UBIN(36).  Contains the
 2649                          actual record size.  See F$DCB.ARS#.                                          */
 2650
 2651            2 DVE,
 2652              3 DVBYTE,
 2653                          /*K* B$NWIO.DVE.DVBYTE is returned on reads
 2654                          and contains information about the nature of
 2655                          the item read.  See M$DCB.  This field contains
 2656                          the following sub-fields:                                                     */
 2657
 2658                4 * BIT(2),
 2659                4 VFC BIT(1),
 2660                          /*K* B$NWIO.DVE.DVBYTE.VFC = VALUE-BIT(1).                                    */
 2661
 2662                4 BIN BIT(1),
 2663                          /*K* B$NWIO.DVE.DVBYTE.BIN = VALUE-BIT(1).                                    */
 2664
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           73   
 2665                4 TRANS BIT(1),
 2666                          /*K* B$NWIO.DVE.DVBYTE.TRANS = VALUE-BIT(1).                                  */
 2667
 2668                4 * BIT(3),
 2669              3 * BIT(1),
 2670              3 EOMCHAR CHAR(1),
 2671                          /*K* B$NWIO.DVE.EOMCHAR = CHAR(1).  Contains
 2672                          the activation character of reads.                                            */
 2673
 2674            2 * UBIN(18) UNAL,
 2675
 2676            %VLP_STATION (FPTN=CGPARM,LVL=2,STCLASS=STCLASS,LAST=",");
 2677                          /*K* B$NWIO.CGPARM contains the structure
 2678                          VLP_STATION.                                                                  */
 2679           %VLP_ERRCODE (FPTN=IOERRCODE,LVL=2,STCLASS=STCLASS,LAST=";");
 2680                          /*K* B$NWIO.IOERRCODE is the error code that
 2681                           occurred on the I/O.  This is only valid on I/O
 2682                           connected directly to the FEP.
 2683                          */
 2684
 2685      %MEND;
 2686
 2687
 2688
 2689
 2690
 2691
 2692
 2693                          /*F* NAME: B$COMIO
 2694
 2695                          The B$COMIO macro may be used to generate a
 2696                          based structure of a frame placed on the TCB
 2697                          stack for a communications I/O event.  The format
 2698                          of this structure can be found in Appendix A.
 2699                          The sub-fields in this structure have the
 2700                          following meanings:
 2701                          */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           74   
 2702
 2703      %MACRO B$COMIO (NAME=B$COMIO,STCLASS=BASED,PARONLY=0);
 2704
 2705       %IF PARONLY=0;
 2706
 2707         %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2708                          /*K*   B$COMIO.SSFRAME contains the copy of the program's
 2709                          environment at the time of the event.  The based
 2710                          structure B$EXCFR should be used to access this area.
 2711                          */
 2712                          /*K*   B$COMIO.SUBC = VALUE-UBIN(18).  Contains the event sub-code.
 2713                          For communications I/O events, this field will be set
 2714                          to %SUBC_COMIO#.
 2715                          */
 2716                          /*K* B$COMIO.EVID = VALUE-UBIN(36).  Contains the event ID as
 2717                          was specified on the M$OPEN Service Request for this DCB.
 2718                          */
 2719       %ELSE;
 2720
 2721      DCL 1 NAME STCLASS ALIGNED,
 2722
 2723       %ENDIF;
 2724
 2725            2 P# UBIN,
 2726                          /*K* B$COMIO.P# = VALUE-UBIN(36).  Contains the number
 2727                          of words of parameters that follow.
 2728                          */
 2729            2 * BIT(18) UNAL,
 2730            2 FLAGS,
 2731              3 DELTA BIT(1) UNAL,
 2732                          /*K* FLAGS.DELTA = VALUE-BIT(1) specifies, if set,
 2733                          that this B$COMIO event is intended for the debugger
 2734                          only; users will never see this flag set.
 2735                          */
 2736              3 * BIT(8) UNAL,
 2737            2 SUBC2 UBIN(9) UNAL,
 2738                          /*K* B$COMIO.SUBC2 = VALUE-UBIN(9).  Contains the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           75   
 2739                          type of communications I/O event. It is either
 2740                          %SUBC2_DATA_RQS# or %SUBC2_DATA_AVL# if this is a user event.
 2741
 2742                          %SUBC2_DATA_RQS# specifies that a read is being
 2743                          performed by the process attached to the specified
 2744                          DCB.
 2745
 2746                          %SUBC2_DATA_AVL# specifies that a write has been
 2747                          performed by the process attached to the specified
 2748                          DCB and that the specified DCB is not currently
 2749                          reading.
 2750
 2751                          If the event is for a debugger, SUBC2 could also be set to
 2752                          %SUBC2_CLS_DCB# to indicate that an FPRG DCB was closed.
 2753
 2754                          If the DCB is open to a CL resource with AU=YES, SUBC2
 2755                          could be set to %SUBC2_OPN_DCB# or %SUBC2_CLS_DCB# to
 2756                          indicate another opening or closing a DCB to the same
 2757                          resource, or it could be set to %SUBC2_IN_CALL# to
 2758                          indicate the occurrence of an incoming call.
 2759
 2760                          If the DCB is open to a CL resource without AU=YES,
 2761                          SUBC2 could be set to %SUBC2_BREAK# to report a break
 2762                          event coming from the attached device.  The break-count
 2763                          value is also returned in ID.SYSID in this case.
 2764                          */
 2765
 2766            2 ARS UBIN,
 2767                          /*K* B$COMIO.ARS = VALUE-UBIN(36). Contains the
 2768                          actual record size. This is the size of the record
 2769                          available for a %SUBC2_DATA_AVL# event or the size
 2770                          of the read buffer for a %SUBC2_DATA_RQS# event.
 2771
 2772                          This word is not present if SUBC2 is set to
 2773                          %SUBC2_CLS_DCB#.
 2774                          */
 2775            2 ID REDEF ARS,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           76   
 2776              3 SYSID UBIN(18) UNAL,
 2777                          /*K* ID.SYSID = VALUE-UBIN(18).  Contains the SYSID
 2778                          of the user causing this event.  ID is a redef of ARS
 2779                          for a DCB open with RES='CL' and AU=YES.  %SUBC2_CLS_DCB#
 2780                          and %SUBC2_OPN_DCB# are reported whenever a different
 2781                          (non-AU) user opens or closes a DCB for the same resource.
 2782                          */
 2783
 2784              3 DCBNO UBIN(18) UNAL;
 2785                          /*K* ID.DCBNO = VALUE-UBIN(18).  Contains the DCB number
 2786                          of the user DCB causing this event.  ID is a redef of ARS
 2787                          for a DCB open with RES='CL' and AU=YES.  %SUBC2_CLS_DCB#
 2788                          and %SUBC2_OPN_DCB# are reported whenever a different
 2789                          (non-AU) user opens or closes a DCB for the same resource.
 2790                          */
 2791
 2792
 2793      %MEND;
 2794
 2795
 2796
 2797                          /*F* NAME:  B$ENQ
 2798
 2799                          The %B$ENQ macro may be used to generate
 2800                          a based structure of a frame placed on the
 2801                          TCB stack for an M$ENQ event.  The format of this
 2802                          structure can be found in Appendix A.  The
 2803                          sub-fields in this structure have the
 2804                          following meanings:
 2805                          */
 2806
 2807      %MACRO B$ENQ (NAME=B$ENQ,STCLASS=BASED);
 2808
 2809            %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2810                          /*K*   B$ENQ.SSFRAME contains the copy of the program's
 2811                          environment at the time of the event.  The
 2812                          based structure B$EXCFR should be used to access this area.                   */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           77   
 2813                          /*K*   B$ENQ.SUBC = VALUE-UBIN(18).  Contains the event sub-code.
 2814                          For enqueue event completion this field will be set
 2815                          to %SUBC_ENQ#.
 2816                          */
 2817                          /*K* B$ENQ.EVID = VALUE-UBIN(36).  Contains the event ID as
 2818                          was specified on the M$ENQ Service Request.
 2819                          */
 2820                          /*K* B$ENQ.ERR is the 36 bit error code, containing
 2821                          the following:                                                                */
 2822                          /*K* B$ENQ.ERR.FCG = VALUE-BIT(12).  Contains
 2823                          the Functional Code Group portion of the error code.                          */
 2824                          /*K* B$ENQ.ERR.MID = VALUE-BIT(6).  Contains the
 2825                          Module ID portion of the error code.                                          */
 2826                          /*K* B$ENQ.ERR.MON = VALUE-BIT(1).  Set if the error
 2827                          was generated by the monitor.                                                 */
 2828                          /*K* B$ENQ.ERR.ERR# = VALUE-UBIN(14).  Contains
 2829                          the error code (see file B_ERRORS_C).                                         */
 2830                          /*K* B$ENQ.ERR.SEV = VALUE-UBIN(3).  Contains the
 2831                          severity of the error.                                                        */
 2832
 2833            2 P# UBIN,
 2834                          /*K* B$ENQ.P# = VALUE-UBIN(36).  Contains the
 2835                          count of the number of words of parameters that
 2836                          follow.  For B$ENQ this field is always 1.                                    */
 2837
 2838            2 MESSAGE BIT(36);
 2839                          /*K* B$ENQ.MESSAGE = VALUE-BIT(36).  Contains
 2840                          the message from the user who last issued a
 2841                          DEQ for the resource.                                                         */
 2842
 2843      %MEND;
 2844
 2845                          /*F* NAME: B$JRNLERR
 2846
 2847                          The %B$JRNLERR macro may be used to generate a
 2848                          based structure of a frame placed on the TCB
 2849                          stack for a journal error event.  The format
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           78   
 2850                          of this structure can be found in Appendix A.
 2851                          The sub-fields in this structure have the
 2852                          following meanings:
 2853                          */
 2854
 2855      %MACRO B$JRNLERR (NAME=B$JRNLERR,STCLASS=BASED,PARONLY=0);
 2856
 2857       %IF PARONLY=0;
 2858
 2859         %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2860                          /*K*   B$JRNLERR.SSFRAME contains the copy of the program's
 2861                          environment at the time of the event.  The
 2862                          based structure B$EXCFR should be used to access this area.                   */
 2863                          /*K*   B$JRNLERR.SUBC = VALUE-UBIN(18).  Contains the event sub-code.
 2864                          For journal errors this field will be set
 2865                          to %SUBC_JRNLERR#.
 2866                          */
 2867                          /*K* B$JRNLERR.DCB# = VALUE-UBIN(36).  For ALTRET
 2868                          frames, contains the number of the DCB on which
 2869                          the error occurred.                                                           */
 2870                          /*K* B$JRNLERR.ERR is the 36 bit error code, containing
 2871                          the following:                                                                */
 2872                          /*K* B$JRNLERR.ERR.FCG = VALUE-BIT(12).  Contains
 2873                          the Functional Code Group portion of the error code.                          */
 2874                          /*K* B$JRNLERR.ERR.MID = VALUE-BIT(6).  Contains the
 2875                          Module ID portion of the error code.                                          */
 2876                          /*K* B$JRNLERR.ERR.MON = VALUE-BIT(1).  Set if the error
 2877                          was generated by the monitor.                                                 */
 2878                          /*K* B$JRNLERR.ERR.ERR# = VALUE-UBIN(14).  Contains
 2879                          the error code (see file B_ERRORS_C).                                         */
 2880                          /*K* B$JRNLERR.ERR.SEV = VALUE-UBIN(3).  Contains the
 2881                          severity of the error.                                                        */
 2882
 2883
 2884       %ELSE;
 2885
 2886      DCL 1 NAME STCLASS ALIGNED,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           79   
 2887
 2888       %ENDIF;
 2889
 2890            2 P# UBIN,
 2891                          /*K* B$JRNLERR.P# = VALUE-UBIN(36). Contains the number
 2892                          of words of parameters that follow.                                           */
 2893            2 VOL UBIN(18) UNAL,
 2894                          /*K* B$JRNLERR.VOL = VALUE-UBIN(18). Contains the
 2895                          index into the JRNL owner's serial number table
 2896                          of the volume on which the error occurred.                                    */
 2897            2 * UBIN(18) UNAL;
 2898
 2899      %MEND;
 2900
 2901
 2902
 2903
 2904
 2905                          /*F* NAME: B$FPRG
 2906
 2907                          The B$FPRG macro may be used to generate a
 2908                          based structure of a frame placed on the TCB
 2909                          stack for an FPRG state-change event.  The format
 2910                          of this structure can be found in Appendix A.
 2911                          The sub-fields in this structure have the
 2912                          following meanings:
 2913                          */
 2914
 2915      %MACRO B$FPRG (NAME=B$FPRG,STCLASS=BASED,PARONLY=0);
 2916
 2917       %IF PARONLY=0;
 2918
 2919         %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2920                          /*K*   B$FPRG.SSFRAME contains the copy of the program's
 2921                          environment at the time of the event.  The
 2922                          based structure B$EXCFR should be used to access this area.                   */
 2923                          /*K*   B$FPRG.SUBC = VALUE-UBIN(18).  Contains the event sub-code.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           80   
 2924                          For FPRG state changes this field will be set
 2925                          to %SUBC_FPRG#.
 2926                          */
 2927                          /*K* B$FPRG.EVID = VALUE-UBIN(36).  Contains the event ID as
 2928                          was specified on the M$OPEN Service Request for this DCB.
 2929                          */
 2930                          /*K* B$FPRG.ERR is the 36 bit error code meaningful only
 2931                          if B$FPRG.SUBC2 = %SUBC2_ABORT#. It contains
 2932                          the following:                                                                */
 2933                          /*K* B$FPRG.ERR.FCG = VALUE-BIT(12).  Contains
 2934                          the Functional Code Group portion of the error code.                          */
 2935                          /*K* B$FPRG.ERR.MID = VALUE-BIT(6).  Contains the
 2936                          Module ID portion of the error code.                                          */
 2937                          /*K* B$FPRG.ERR.MON = VALUE-BIT(1).  Set if the error
 2938                          was generated by the monitor.                                                 */
 2939                          /*K* B$FPRG.ERR.ERR# = VALUE-UBIN(14).  Contains
 2940                          the error code (see file B_ERRORS_C).                                         */
 2941                          /*K* B$FPRG.ERR.SEV = VALUE-UBIN(3).  Contains the
 2942                          severity of the error.                                                        */
 2943
 2944
 2945       %ELSE;
 2946
 2947      DCL 1 NAME STCLASS ALIGNED,
 2948
 2949       %ENDIF;
 2950
 2951            2 P# UBIN,
 2952                          /*K* B$FPRG.P# = VALUE-UBIN(36).  Contains the number
 2953                          of words of parameters that follow.                                           */
 2954
 2955            2 DCBNO UBIN(18) UNAL,
 2956                          /*K* B$FPRG.DCBNO = VALUE-UBIN(18).  Contains the
 2957                          DCB number for which this FPRG event occurred.                                */
 2958            2 * UBIN(9) UNAL,
 2959            2 SUBC2 UBIN(9) UNAL,
 2960                          /*K* B$FPRG.SUBC2 = VALUE-UBIN(9).  Contains the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           81   
 2961                          reason for this FPRG state change event. It is either
 2962                          %SUBC2_FPEXIT#, %SUBC2_FPABORT# or %SUBC2_FPLDTRC#.                           */
 2963
 2964            %VLP_FPRG (FPTN=FPRG,STCLASS=STCLASS,LVL=2);
 2965                          /*K* B$FPRG.FPRG contains the description of the FPRG
 2966                          just loaded via an M$LDTRC. This section is valid only
 2967                          for B$FPRG.SUBC2 = %SUBC2_FPLDTRC#. See VLP_FPRG.                             */
 2968
 2969      %MEND;
 2970
 2971
 2972
 2973
 2974
 2975                          /*F* NAME:  B$EVNT - Event Structure
 2976
 2977                          The B$EVNT macro may be used to generate
 2978                          a based structure that is used to access
 2979                          data in any EVENT frame on the TCB stack.
 2980                          The format of this structure can be found
 2981                          in Appendix A.  The sub-fields in B$EVNT
 2982                          have the following meaning:
 2983
 2984                                    */
 2985
 2986      %MACRO B$EVNT (NAME=B$EVNT,STCLASS=BASED);
 2987
 2988          %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 2989                          /*K*   B$EVNT.SSFRAME contains the copy of the program's
 2990                          environment at the time of the event.  The
 2991                          based structure B$EXCFR should be used to access this area.                   */
 2992                          /*K*   B$EVNT.SUBC = VALUE-UBIN(18).  Contains the
 2993                          event sub-code.  For No-wait I/O completion this
 2994                          field will be set to any of the various types of events.
 2995                          */
 2996                          /*K* B$EVNT.EVID = VALUE-UBIN(36).  Contains the event ID as
 2997                          specified on the M$READ or M$WRITE Service Request.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           82   
 2998                          */
 2999                          /*K* B$EVNT.ERR is the 36 bit error code, containing
 3000                          the following:                                                                */
 3001                          /*K* B$EVNT.ERR.FCG = VALUE-BIT(12).  Contains
 3002                          the Functional Code Group portion of the error code.                          */
 3003                          /*K* B$EVNT.ERR.MID = VALUE-BIT(6).  Contains the
 3004                          Module ID portion of the error code.                                          */
 3005                          /*K* B$EVNT.ERR.MON = VALUE-BIT(1).  Set if the error
 3006                          was generated by the monitor.                                                 */
 3007                          /*K* B$EVNT.ERR.ERR# = VALUE-UBIN(14).  Contains
 3008                          the error code (see file B_ERRORS_C).                                         */
 3009                          /*K* B$EVNT.ERR.SEV = VALUE-UBIN(3).  Contains the
 3010                          severity of the error.                                                        */
 3011
 3012            2 P# UBIN;
 3013                          /*K* B$EVNT.P# = VALUE-UBIN(36).  Contains the
 3014                          count of the number of parameters that follow.                                */
 3015
 3016
 3017      /*   STRING SUBSTITUTIONS FOR EVENT FRAME SUBCODES (B$EVNT.EVSC) */
 3018      %EQU EVSC_ENQ#=0;             /* ENQUEUE EVENT SUBCODE                                            */
 3019      %EQU EVSC_IO#=1;              /* I/O EVENT SUBCODE                                                */
 3020      %EQU EVSC_JRNLERR#=3;         /* JRNL file requires error handling by owner                       */
 3021      %EQU EVSC_YC#=4;              /* YC-GO interruption for Command Processor                         */
 3022      %EQU EVSC_FPRG#=5;            /* FEP program state change has occurred                            */
 3023      %MEND;
 3024
 3025                          /*F* NAME:  B$TDIO - T & D I/O Structure
 3026
 3027                          The B$TDIO macro may be used to generate a based
 3028                          structure of a frame placed on the TCB stack for a
 3029                          no-wait M$TDIO event.  The format of this
 3030                          structure can be found in Appendix A.  The
 3031                          sub-fields in this structure have the following
 3032                          meaning:
 3033                          */
 3034
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           83   
 3035      %MACRO B$TDIO (NAME=B$TDIO,STCLASS=BASED,PARONLY=0);
 3036
 3037       %IF PARONLY=0;
 3038
 3039          %B$FIXED (NAME=NAME,STCLASS=STCLASS);
 3040                          /*K*   B$TDIO.SSFRAME contains the copy of the program's
 3041                          environment at the time of the event.  The
 3042                          based structure B$EXCFR should be used to access this area.                   */
 3043                          /*K*   B$TDIO.SUBC = VALUE-UBIN(18).  Contains the
 3044                          event sub-code.  For No-wait I/O completion this
 3045                          field will be set to %SUBC_TDIO#.
 3046                          */
 3047                          /*K* B$TDIO.EVID = VALUE-UBIN(36).  Contains the event ID as
 3048                          specified on the M$READ or M$WRITE Service Request.
 3049                          */
 3050                          /*K* B$TDIO.ERR is the 36 bit error code, containing
 3051                          the following:                                                                */
 3052                          /*K* B$TDIO.ERR.FCG = VALUE-BIT(12).  Contains
 3053                          the Functional Code Group portion of the error code.                          */
 3054                          /*K* B$TDIO.ERR.MID = VALUE-BIT(6).  Contains the
 3055                          Module ID portion of the error code.                                          */
 3056                          /*K* B$TDIO.ERR.MON = VALUE-BIT(1).  Set if the error
 3057                          was generated by the monitor.                                                 */
 3058                          /*K* B$TDIO.ERR.ERR# = VALUE-UBIN(14).  Contains
 3059                          the error code (see file B_ERRORS_C).                                         */
 3060                          /*K* B$TDIO.ERR.SEV = VALUE-UBIN(3).  Contains the
 3061                          severity of the error.                                                        */
 3062
 3063
 3064       %ELSE;
 3065
 3066      DCL 1 NAME STCLASS ALIGNED,
 3067
 3068       %ENDIF;
 3069
 3070            2 P# UBIN(36),
 3071                          /*K* B$TDIO.P# = VALUE-UBIN(36).
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           84   
 3072                          Contains the number of parameters to follow.                                  */
 3073            2 FLPW UBIN,
 3074                          /*K* B$TDIO.FLPW = VALUE-UBIN.
 3075                          Contains the final list pointer word.                                         */
 3076            2 INTLVL REDEF FLPW UBIN,
 3077                          /*K* B$TDIO.INTLVL = VALUE-UBIN.
 3078                          Contains the interrupt level if FEP Interrupt.                                */
 3079            2 STATUS BIT(72),
 3080                          /*K* B$TDIO.STATUS = VALUE-BIT(72).
 3081                          Contains the Interrupt status.                                                */
 3082            2 LPWX,
 3083                          /*K* B$TDIO.LPWX.
 3084                          Contains the List pointer word extension.                                     */
 3085              3 BASE UBIN(18) UNAL,
 3086                          /*K* B$TDIO.LPWX.BASE = VALUE-UBIN(18).
 3087                          Contains the base of the data area (MOD 2).                                   */
 3088              3 SIZE UBIN(18) UNAL,
 3089                          /*K* B$TDIO.LPWX.SIZE = VALUE-UBIN(18).
 3090                          Contains the address of the data area.                                        */
 3091            2 EXTSTATUS,
 3092                          /*K* B$TDIO.EXTSTATUS.
 3093                          Contains the interrupt extended status.                                       */
 3094              3 SNSBYT (0:26) BIT(8) UNAL,
 3095                          /*K* B$TDIO.EXTSTATUS.SNSBYT = ARRAY(0:26) BIT(8).
 3096                          Contains the sense bytes of the interrupt extended
 3097                          status.                                                                       */
 3098              3 * (0:1) UBIN;       /* RESERVED FOR FUTURE USE                                          */
 3099      %MEND;
 3100
 3101
 3102
 3103
 3104
 3105                          /*F* NAME: Exit__Control
 3106
 3107                          Conditions causing a program exit are listed
 3108                          below.  The conditions are classified by severity
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           85   
 3109                          of impact, as described later.
 3110
 3111                          TU
 3112                            Class    Condition
 3113                          ___________________________________________________________
 3114
 3115                               1     Normal exit at M$EXIT
 3116                               1     Abnormal exit at M$ERR or M$XXX
 3117                               1     Machine trap and no user trap control requested
 3118                               1     Monitor service error not processed by ALTRET code
 3119                                     sequence or M$TRAP (PMME) procedure
 3120                               1     Transfer of control to another load module (M$LDTRC)
 3121                               1     Save program image (M$SAVE or Control-Y SAVE)
 3122                               1     Restore program image (GET)
 3123                               1     Exceptional condition occurs but procedure cannot
 3124                                     be entered because the stack is full
 3125                               1     Operator "errored the user"
 3126
 3127                               2     Resources limit exceeded
 3128
 3129                               3     Operator abort
 3130                               3     Line disconnect
 3131
 3132                          ---------------------------------------------------------------
 3133                          TF
 3134
 3135                          If the user requests exit control, control is
 3136                          transferred to the user at any of these
 3137                          conditions.  The exit procedure may perform various
 3138                          clean-up functions and also process unexpected
 3139                          conditions.  The reason for the exit is passed to
 3140                          the specified procedures.  Limits on output and time
 3141                          are reestablished to control the exit procedure.
 3142                          */
 3143                          /*F* NAME: M$XCON_ - Set Exit Control
 3144
 3145                          The M$XCON service requests exit control and
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           86   
 3146                          specifies the entry-address for the exit procedure.
 3147                          When this procedure takes control, the program is in
 3148                          "exit" status; a flag in the ECCB is set to
 3149                          reflect "exit control in progress".
 3150
 3151                          The user can also issue the M$XCON service for
 3152                          these purposes: nesting exit entries and removing
 3153                          the program from exit status.  These two uses are
 3154                          discussed below.
 3155                          }
 3156                            1.  The user can control nesting of exit entries.  At the
 3157                                initial call to M$XCON, an exit entry is established.  To
 3158                                supply a different exit entry the user reissues M$XCON
 3159                                specifying the entry and the PXCON parameter which saves
 3160                                the previous exit entry so that it may be used later to
 3161                                reestablish exit control to its previous entry point.  Thus
 3162                                each level of nested exit procedures retains the entry-
 3163                                address of the next higher level.  The currently effective
 3164                                exit control procedure can issue the M$XCON service to
 3165                                reestablish a previous exit entry.
 3166
 3167                            2.  Executing the M$XCON service within an exit procedure removes
 3168                                the program from "exit" status.
 3169
 3170                          The form of the call for this service is:
 3171
 3172                          CALL M$XCON (FPT_XCON) [ALTRET (label)];
 3173
 3174                          The parameters for the M$XCON service are as
 3175                          follows:*/
 3176
 3177
 3178
 3179      %MACRO FPT_XCON
 3180                   (FPTN=FPT_XCON,
 3181                    UENTRY=NIL,
 3182                    PXCON=NIL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           87   
 3183                    STCLASS=STATIC);
 3184
 3185      %LSET LISTDIR='0'B;
 3186      %LSET LISTEXP='1'B;
 3187      %LSET LISTCOM='0'B;
 3188      %LSET LISTSUB='1'B;
 3189      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 3190      %IF (SUBSTR(STR,0,6)='STATIC') OR
 3191       (SUBSTR(STR,0,8)='CONSTANT') OR
 3192       (SUBSTR(STR,0,3)='EXT');
 3193       %LSET INIT=CHARTEXT('INIT');
 3194      %ELSE;
 3195       %LSET INIT=CHARTEXT('/*');
 3196      %ENDIF;
 3197
 3198
 3199
 3200      DCL 1 FPTN STCLASS DALIGNED,
 3201            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 3202            2 PXCON_ BIT(72) %INIT(VECTOR(PXCON))%CHARTEXT('/**/'),
 3203                          /*K* PXCON = VARIABLE    locates a 1-word area
 3204                          where an EPTR to the previously set exit procedure
 3205                          address is to be returned.  Default = NIL.*/
 3206            2 V DALIGNED,
 3207              3 UENTRY# EPTR %INIT(ENTADDR(UENTRY))%CHARTEXT('/**/'),
 3208                          /*K* UENTRY = {ENTRY|NIL}  locates the procedure to
 3209                          be entered upon exit of the current program
 3210                          whether normal or abnormal.  A zero address or NIL
 3211                          reverses the user's previous request for exit
 3212                          control.  Default = NIL.*/
 3213              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 3214      %MEND;
 3215
 3216                          /*F* NAME: Entry to Exit Control Procedure.
 3217
 3218                          The user should be aware of several conditions
 3219                          that exist on entry to the exit procedures:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           88   
 3220
 3221                            o  The exit procedure is entered in Slave Mode.
 3222
 3223                            o  Previously established timer and break controls are deferred.
 3224                               (These controls are reimposed if the program "exit" status
 3225                               is reversed.)
 3226
 3227                            o  Standard system exit control limit increments are established
 3228                               by the system manager at system definition.  Table 6-3
 3229                               summarizes the effect of various classes of exit events on the
 3230                               user's current limits.  The user's current limits are incremented
 3231                               by exit control limits, if a class 2 or a class 3 exit occurs.
 3232                               An exception is made for the time limit which is not treated
 3233                               as an increment.  If maximum time must be set (see Table 6-3),
 3234                               the exit control default is stored as the new maximum run-time
 3235                               limit.  The system is protected from looping in an exit procedure
 3236                               because some limit will eventually be exceeded.
 3237
 3238                          Another exit condition may occur while the user's
 3239                          exit control procedure has control.  Table 6-3 also
 3240                          explains what occurs in this case and describes
 3241                          the effect on the exit procedure already in
 3242                          progress.
 3243                          ..::TB "Entry to Exit Control"
 3244                          }                       Monitor Action at      Monitor Action While
 3245                          }Condition              Initial Exit           Processing Previous Exit
 3246                          }------------------------------------------------------------------------
 3247                          }Class 1
 3248                          }-------
 3249                          }Normal exit from user  User's current limits  While processing Class 1,
 3250                          }program (M$EXIT)       are not modified.  No  2, or 3:  If M$EXIT,
 3251                          }                       time limit is imposed. M$ERR, or M$XXX, then
 3252                          }Abnormal exit from                            run-down the job step. In
 3253                          }user program (M$ERR                           all other cases, enter
 3254                          }or M$XXX)                                     the currently effective
 3255                          }                                              exit procedure without
 3256                          }                                              establishing processing
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           89   
 3257                          }                                              limits.
 3258                          }User program trap
 3259                          }
 3260                          }Monitor service error
 3261                          }not handled by ALTRET
 3262                          }or M$TRAP (PMME)
 3263                          }
 3264                          }Operator errored the
 3265                          }user
 3266                          }
 3267                          }Load and transfer
 3268                          }to another program
 3269                          }(M$LDTRC)
 3270                          }
 3271                          }SAVE, M$SAVE, or GET
 3272                          }if exit control
 3273                          }requested
 3274                          }
 3275                          }Normal or abnormal
 3276                          }exit from Special
 3277                          }Shared Processor
 3278                          }
 3279                          }Class 2
 3280                          }-------
 3281                          }Resource limit         User's current limits  While processing Class 1,
 3282                          }exceeded               are incremented by a   enter the currently
 3283                          }                       fixed amount specified effective exit procedure
 3284                          }                       at system definition.  and take action described
 3285                          }                       Time limit is imposed  for Class 2 initial
 3286                          }                       for batch jobs, but    entry.
 3287                          }                       not for online jobs.
 3288                          }                                              While processing Class 2,
 3289                          }                                              batch users are logged
 3290                          }                                              off; online user's
 3291                          }                                              Command Processor takes
 3292                          }                                              control (the user
 3293                          }                                              exhausted the extended
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           90   
 3294                          }                                              processing capabilities
 3295                          }                                              granted by the system).
 3296                          }
 3297                          }                                              While processing Class 3,
 3298                          }                                              both batch and online
 3299                          }                                              users are logged off.
 3300                          }
 3301                          }Class 3
 3302                          }-------
 3303                          }Operator abort         User's current limits  While processing Class 1,
 3304                          }                       are incremented by a   enter the currently
 3305                          }Line disconnect        fixed amount           effective exit procedure
 3306                          }                       (specified at system   and take action described
 3307                          }Monitor/CP cancel      definition).  Time     for initial Class 3
 3308                          }                       limit is imposed for   entry.
 3309                          }                       both batch and online
 3310                          }                       jobs.                  While processing Class 2,
 3311                          }                                              user's current limits are
 3312                          }                                              not modified.  Time limit
 3313                          }                                              is set for batch and
 3314                          }                                              online jobs.
 3315                          }
 3316                          }                                              While processing Class 3,
 3317                          }                                              both batch and online
 3318                          }                                              users are logged off.
 3319                          }
 3320                          ..::TB
 3321
 3322                          On entry to the Exit Control procedure, the
 3323                          environment is placed on the Exceptional Condition
 3324                          Stack (see Figure 6-1).  The BASED structure, B$XCON, can be
 3325                          used to access the additional words of information stored
 3326                          following the environment.
 3327
 3328                          If there is insufficient room on the
 3329                          Exceptional Condition stack for the exceptional
 3330                          condition environment, as indicated by the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           91   
 3331                          the XCONF.NOTCB bit set in the ECCB, the exit control
 3332                          environment will be in the ALTRET frame with the
 3333                          ECC set to indicate that the TCB is full.  The
 3334                          format of the frame is the
 3335                          same as the exit control frame that is placed on the
 3336                          stack with the exception of the value of the ECC.
 3337                          The error code in the exit control frame is not
 3338                          replaced if the exit condition is abnormal. If
 3339                          the program is being aborted because of a stack
 3340                          full condition when a break, timer interval
 3341                          expired or event completion occurs, the error
 3342                          code is set to indicate that the TCB is full.  The
 3343                          user should always inspect the ECCB upon entry to
 3344                          the exit
 3345                          control procedure to determine if this condition
 3346                          exists. When this condition occurs, the exit
 3347                          control information must be accessed via the
 3348                          ALTRET frame pointer in the TCB. For example, on
 3349                          entry to an exit control procedure:
 3350                          }
 3351                          }    IF B$ECCB$->B$ECCB.XCONF.NOTCB
 3352                          }    THEN MYPTR$ = B$TCB$->B$TCB.ALT$;
 3353                          }    ELSE MYPTR$ = B$TCB$->B$TCB.STK$;
 3354                          }
 3355                          */
 3356
 3357
 3358                          /*F* NAME:  B$XCON
 3359
 3360                          The %B$XCON macro may be used to
 3361                          generate a based structure defining
 3362                          an exit control frame.  The format of
 3363                          this structure can be found in
 3364                          Appendix A.  The sub-fields in this
 3365                          structure have the following meanings:
 3366                          */
 3367      %MACRO B$XCON (NAME=B$XCON,STCLASS=BASED);
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           92   
 3368      DCL 1 NAME STCLASS ALIGNED,
 3369            2 SSFRAME(0:63) BIT(36) UNAL, /* USE B$EXCFR OR B$SS                                        */
 3370            2 CECCB,                /* ECCB.XCONF BITS SET THIS TIME                                    */
 3371              3 PROG BIT(1) UNAL,   /* EXIT CONTROL IN PROGRESS                                         */
 3372              3 NOTCB BIT(1) UNAL,  /* NO ROOM IN TCB FOR ENVIRON                                       */
 3373              3 LIMIT BIT(1) UNAL,  /* LIMITS HAVE BEEN INCREMENTED                                     */
 3374              3 CL3 BIT(1) UNAL,    /* CLASS III IN PROGRESS                                            */
 3375              3 SGET BIT(1) UNAL,   /* EXIT FOR SIMULATED GET                                           */
 3376              3 LNK BIT(1) UNAL,    /* EXIT FOR M$LDTRC                                                 */
 3377              3 SAVE BIT(1) UNAL,   /* EXIT FOR M$SAVE                                                  */
 3378              3 CPSAVE BIT(1) UNAL, /* EXIT FOR YC SAVE                                                 */
 3379              3 GET BIT(1) UNAL,    /* EXIT FOR GET                                                     */
 3380                          /*K* B$XCON.CECCB = VALUE-BIT(9).
 3381                          The bit settings in B$XCON.CECCB reflect the ECCB.XCONF
 3382                          bits that have been set on this entry to exit control.
 3383                          For example, if a program simply issues an M$EXIT,
 3384                          B$XCON.CECCB.PROG will be set and all other bits in
 3385                          B$XCON.CECCB will be reset. If the program then exceeds
 3386                          the time limit while in exit control processing, a second
 3387                          exit control frame will be pushed on the TCB stack and the
 3388                          program will be entered at its exit control address. The
 3389                          top stack frame will now have B$XCON.CECCB.LIMIT set.
 3390                          B$XCON.ECCB.PROG will not be set
 3391                          in this frame indicating that exit control was already in
 3392                          progress when this exit condition occurred.
 3393
 3394
 3395                          TU
 3396                          Level 3
 3397                           Name        Bit     Meaning
 3398                          __________________________________________________________
 3399
 3400                          PROG         0       Exit control was not in progress when the
 3401                                               exit condition occurred.
 3402
 3403                          NOTCB        1       The exit condition occurred when the
 3404                                               Exceptional Condition Stack was full.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           93   
 3405
 3406                          LIMIT        2       Limits have been incremented, i.e., Class 2
 3407                                               exit control in progress.
 3408
 3409                          CL3          3       Class 3 exit control in progress.
 3410
 3411                          SGET         4       Exit control for simulated GET.
 3412                                               (GET will also be set.)
 3413
 3414                          LNK          5       Exit control for M$LDTRC.
 3415
 3416                          SAVE         6       Exit control for M$SAVE.
 3417
 3418                          CPSAVE       7       Exit control Control-Y SAVE.
 3419
 3420                          GET          8       Exit control for GET.
 3421                          ----------------------------------------------------------------
 3422
 3423
 3424
 3425                          TF
 3426                          */
 3427            2 UNUSD BIT(9) UNAL,
 3428            2 ECSC UBIN(18) UNAL,   /* EVENT SUBCODE                                                    */
 3429                          /*K* B$XCON.ECSC = VALUE-UBIN(18).
 3430                          The bit settings for B$XCON.ECSC reflect the
 3431                          exit conditions as they apply to domains
 3432                          other than the currently active domain.
 3433
 3434                          }  Sub-
 3435                          }  code   Meaning
 3436                          }------------------------------------------------------------
 3437                          }
 3438                          }     0   The exit condition occurred while the currently
 3439                          }         executing domain was in control.  This will always
 3440                          }         be zero for a user level program.  If a user
 3441                          }         program exit control procedure is entered following
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           94   
 3442                          }         either a normal or abnormal exit from a special
 3443                          }         shared processor, the special shared processor
 3444                          }         abort bit is set in the current run status
 3445                          }         (B$XCON.RNST.SSABRT).  The environment in the
 3446                          }         exit control frame is that which existed in the
 3447                          }         user program at the last call to the Alternate
 3448                          }         Shared Library or upon entry to the debugger or to
 3449                          }         the Command Processor.
 3450                          }
 3451                          }     1   Exit control occurred while a lower priority
 3452                          }         domain was in control.  M$TRTN is not allowed.
 3453                          }         This code is meaningful only to special shared
 3454                          }         processors.
 3455                          }------------------------------------------------------------
 3456
 3457                          */
 3458            2 RNST,                 /* FROM JIT.RNST                                                    */
 3459              3 OPXXX BIT(1) UNAL,  /* OPERATOR ABORTED JOB                                             */
 3460              3 HANGUP BIT(1) UNAL, /* TERMINAL HANG UP / LINE DISCONNECT                               */
 3461              3 LIMIT BIT(1) UNAL,  /* LIMIT EXCEEDED--SEE B$XCON.LIMIT                                 */
 3462              3 MONXXX BIT(1) UNAL, /* MONITOR ABORTED THE JOB                                          */
 3463              3 OPERR BIT(1) UNAL,  /* OPERATOR !E KEY-IN OR !QUIT                                      */
 3464              3 MABRT BIT(1) UNAL,  /* ABORTED BY MONITOR                                               */
 3465              3 SSPABRT BIT(1) UNAL, /* SPEC SHRD PROC ABORT                                            */
 3466              3 XXX BIT(1) UNAL,    /* M$XXX                                                            */
 3467              3 ERR BIT(1) UNAL,    /* M$ERR                                                            */
 3468                          /*K* B$XCON.RNST = VALUE-BIT(9).
 3469                          The bit settings for B$XCON.RNST reflect the current
 3470                          Run Status and indicate the reason for this entry
 3471                          to exit control:
 3472
 3473                          }Level 3
 3474                          } Name     Bit  Meaning
 3475                          }_______________________________________________________
 3476                          }
 3477                          }OPXXX     0    Operator aborted the job.
 3478                          }
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           95   
 3479                          }HANGUP    1    Line disconnect.
 3480                          }
 3481                          }LIMIT     2    Limit exceeded.
 3482                          }
 3483                          }MONXXX    3    Monitor or Command Processor is logging
 3484                          }               off the user.
 3485                          }
 3486                          }OPERR     4    Operator errored the job or user errored
 3487                          }               the job via the Control-Y QUIT sequence.
 3488                          }
 3489                          }MABRT     5    Program aborted by the monitor.
 3490                          }
 3491                          }SSPABRT   6    Program aborted by a special shared
 3492                          }               processor.
 3493                          }
 3494                          }XXX       7    M$XXX was issued.
 3495                          }
 3496                          }ERR       8    M$ERR was issued.
 3497                          }
 3498                          }-------------------------------------------------------
 3499
 3500                          This field is set to zero if M$EXIT, M$LDTRC,
 3501                          M$SAVE or Control-Y SAVE or GET caused the exit.
 3502                          The bit settings in B$XCON.CECCB differentiate
 3503                          between these conditions.
 3504                          In all other cases the exit was due to an error
 3505                          condition.
 3506                          */
 3507            2 XCONF,                /* FROM JIT.XCONF                                                   */
 3508                                    /* BITS 0-5 REFLECT THE PREVIOUS RNST                               */
 3509              3 OPXXX BIT(1) UNAL,  /* OPERATOR ABORTED JOB                                             */
 3510              3 HANGUP BIT(1) UNAL, /* TERMINAL HANG UP / LINE DISCONNECT                               */
 3511              3 LIMIT BIT(1) UNAL,  /* LIMIT EXCEEDED--SEE B$XCON.LIMIT                                 */
 3512              3 MONXXX BIT(1) UNAL, /* MONITOR ABORTED THE JOB                                          */
 3513              3 OPERR BIT(1) UNAL,  /* OPERATOR !E KEY-IN OR !QUIT                                      */
 3514              3 MABRT BIT(1) UNAL,  /* ABORTED BY MONITOR                                               */
 3515                                    /* BITS 6-8 REFLECT THE EXITING OF ANOTHER DOMAIN                   */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           96   
 3516              3 URND BIT(1) UNAL,   /* USER HAS BEEN RUNDOWN                                            */
 3517              3 ASL BIT(1) UNAL,    /* EXIT OR ABORT FROM ASL                                           */
 3518              3 QUIT BIT(1) UNAL,   /* QUIT FROM DELTA OR CP                                            */
 3519                          /*K*   B$XCON.XCONF = VALUE-BIT(9).
 3520                          The bit settings in B$XCON.XCONF have meaning on
 3521                          multiple entries to exit control either at the
 3522                          same level or for multiple levels of exit control.
 3523
 3524                          }Level 3
 3525                          } Name     Bit   Meaning
 3526                          }-----------------------------------------------------------
 3527                          }
 3528                          }          0-5  These bits reflect the previous Run Status.
 3529                          }               For example, if a program that is in exit
 3530                          }               control for limits exceeded were to be
 3531                          }               aborted by the operator, that program's exit
 3532                          }               control procedure would be re-entered with
 3533                          }               B$XCON.RNST.OPXXX set and B$XCON.XCONF.LIMIT
 3534                          }               also set.
 3535                          }
 3536                          }OPXXX     0    Operator aborted the job.
 3537                          }
 3538                          }HANGUP    1    Line disconnect.
 3539                          }
 3540                          }LIMIT     2    Limit exceeded.
 3541                          }
 3542                          }MONXXX    3    Monitor or Command Processor is logging
 3543                          }               off the user.
 3544                          }
 3545                          }OPERR     4    Operator errored the job or user errored
 3546                          }               the job via the Control-Y QUIT sequence.
 3547                          }
 3548                          }MABRT     5    Program aborted by the monitor.
 3549                          }
 3550                          }          6-8  These bits reflect the exit condition
 3551                          }               of another domain
 3552                          }
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           97   
 3553                          }URND      6    The user level exit has completed.  This
 3554                          }               code is meaningful only to special shared
 3555                          }               processors.  ECC Subcode will be set to 1.
 3556                          }
 3557                          }ASL       7    The ASL level exit has completed and the ASL
 3558                          }               has been run down.  This code is meaningful
 3559                          }               only to the user level.
 3560                          }
 3561                          }QUIT      8    Control-Y QUIT sequence (operator abort)
 3562                          }               initiated the abort process.
 3563                          }
 3564                          }-----------------------------------------------------------
 3565                          */
 3566            2 LIMIT,                /* LIMIT EXCEEDED                                                   */
 3567              3 PO BIT(1) UNAL,     /* PUNCHED CARDS OUT                                                */
 3568              3 MEM BIT(1) UNAL,
 3569              3 PLO REDEF MEM BIT(1) UNAL, /* pre B02 usage                                             */
 3570              3 LO BIT(1) UNAL,     /* USER-GENERATED PAGES OUT                                         */
 3571              3 DGO BIT(1) UNAL,    /* DIAGNOSTIC PAGES OUT                                             */
 3572              3 PDISK BIT(1) UNAL,  /* PERMANENT DISK GRANULES                                          */
 3573              3 TDISK BIT(1) UNAL,  /* TEMPORARY DISK GRANULES                                          */
 3574              3 TAPE BIT(1) UNAL,   /* SCRATCH TAPES                                                    */
 3575              3 STACK BIT(1) UNAL,  /* SAFE-STORE STACK                                                 */
 3576              3 TIME BIT(1) UNAL,   /* CPU TIME                                                         */
 3577                          /*K*   B$XCON.LIMIT = VALUE-BIT(9).
 3578                          The bit settings for B$XCON.LIMIT have the
 3579                          following meaning:
 3580
 3581                          }Level 3
 3582                          } Name     Bit   Meaning
 3583                          }_______________________________________________
 3584                          }
 3585                          }PO        0     Punched cards.
 3586                          }
 3587                          }MEM       1     Memory (M$LINK return).
 3588                          }
 3589                          }LO        2     User pages(LO).
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           98   
 3590                          }
 3591                          }DGO       3     Diagnostic pages.
 3592                          }
 3593                          }PDISK     4     Permanent disk granules.
 3594                          }
 3595                          }TDISK     5     Temporary disk granules.
 3596                          }
 3597                          }TAPE      6     Scratch Tapes.
 3598                          }
 3599                          }STACK     7     Safe-Store Stack limit has been
 3600                          }                exceeded.
 3601                          }
 3602                          }TIME      8     Time Limit Exceeded.
 3603                          }
 3604                          }-----------------------------------------------
 3605                          */
 3606            2 ECCB,                 /* FROM ECCB.XCON                                                   */
 3607              3 PROG BIT(1) UNAL,   /* EXIT CONTROL IN PROGRESS                                         */
 3608              3 NOTCB BIT(1) UNAL,  /* NO ROOM IN TCB FOR ENVIRON                                       */
 3609              3 LIMIT BIT(1) UNAL,  /* LIMITS HAVE BEEN INCREMENTED                                     */
 3610              3 CL3 BIT(1) UNAL,    /* CLASS III IN PROGRESS                                            */
 3611              3 SVLDT BIT(1) UNAL,  /* FOR MONITOR USE                                                  */
 3612              3 LNK BIT(1) UNAL,    /* EXIT FOR M$LDTRC                                                 */
 3613              3 SAVE BIT(1) UNAL,   /* EXIT FOR M$SAVE                                                  */
 3614              3 CPSAVE BIT(1) UNAL, /* EXIT FOR YC SAVE                                                 */
 3615              3 GET BIT(1) UNAL,    /* EXIT FOR GET                                                     */
 3616                          /*K*  B$XCON.ECCB = VALUE-BIT(9).
 3617                          The bit settings in B$XCON.ECCB reflect the exit
 3618                          control conditions that existed prior to this entry
 3619                          to exit control. For example, a program that has
 3620                          entered exit control processing for M$LDTRC and is
 3621                          then aborted by the operator will be re-entered at its
 3622                          exit control address with B$XCON.CECCB.CL3 set, and
 3623                          B$XCON.CECCB.LNK reset. B$XCON.ECCB.PROG and
 3624                          B$XCON.ECCB.LNK would both be set.
 3625
 3626                          TU
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           99   
 3627                          .BRN 6
 3628                          Level 3
 3629                           Name        Bit     Meaning
 3630                          __________________________________________________________
 3631                          .spf
 3632                          PROG         0       Exit control was previously in progress when
 3633                                               the exit condition occurred.
 3634
 3635                          NOTCB        1       The exit condition occurred when the
 3636                                               Exceptional Condition Stack was full.
 3637
 3638                          LIMIT        2       Limits have been incremented, i.e., Class 2
 3639                                               exit control in progress.
 3640
 3641                          CL3          3       Class 3 exit control in progress.
 3642
 3643                                       4       Unused.
 3644
 3645                          LNK          5       Exit control for M$LDTRC.
 3646
 3647                          SAVE         6       Exit control for M$SAVE.
 3648
 3649                          CPSAVE       7       Exit control Control-Y SAVE.
 3650
 3651                          GET          8       Exit control for GET.
 3652
 3653                          -----------------------------------------------------------------
 3654                          TF
 3655                          */
 3656
 3657            2 ERR,
 3658                          /*K*   B$XCON.ERR is the 36 bit error code.  The
 3659                          error code contains the following:                                            */
 3660              3 FCG BIT(12) UNAL,
 3661                          /*K*   B$XCON.ERR.FCG = VALUE-BIT(12). Contains the
 3662                          Functional Code Group portion of the error code.                              */
 3663              3 MID BIT(6) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           100  
 3664                          /*K*   B$XCON.ERR.MID = VALUE-BIT(6).  Contains the
 3665                          Module ID portion of the error code.                                          */
 3666              3 MON BIT(1) UNAL,
 3667                          /*K*   B$XCON.ERR.MON = VALUE-BIT(1).  Indicates that
 3668                          the error code was generated by the monitor.                                  */
 3669              3 ERR# UBIN(14) UNAL,
 3670                          /*K*   B$XCON.ERR.ERR# = VALUE-UBIN(14).  Contains the
 3671                          error code (see file B_ERRORS_C).                                             */
 3672              3 CODE REDEF ERR# UBIN(14) UNAL,
 3673              3 SEV UBIN(3) UNAL,
 3674                          /*K*   B$XCON.ERR.SEV = VALUE-UBIN(3).  Contains the
 3675                          severity of the error.                                                        */
 3676            2 P# UBIN(36);          /* # PARAMETERS (0 UNLESS SAVE)                                     */
 3677                          /*K*   B$XCON.P# = VALUE-UBIN(36).  Contains the
 3678                          number of words following the standard
 3679                          B$XCON Exceptional Condition frame.  This
 3680                          will be zero unless the exit condition is
 3681                          for SAVE or LDTRC.
 3682                          */
 3683      %MEND;
 3684
 3685
 3686                          /*F* NAME:  Exit_from Exit Control Procedure
 3687
 3688                          To resume normal execution of a program after
 3689                          receiving exit control, the user can call the
 3690                          M$TRTN service.  This service removes the exit
 3691                          control frame from the TCB stack and removes
 3692                          the program from the "exit" status if this call
 3693                          to M$TRTN is not from within a nested exit control
 3694                          procedure; i.e. the 'PROG' bit is set in B$XCON.CECCB.
 3695
 3696                          Note that the M$TRTN service
 3697                          cannot be used by a special shared processor if a
 3698                          lower level domain was in control when the exit
 3699                          condition occurred, as indicated by the ECC
 3700                          subcode.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           101  
 3701
 3702                          The user can also issue the M$XCON service within
 3703                          the exit procedure to remove the program from the "exit"
 3704                          status.  The user may call this service with a
 3705                          previously acquired PXCON parameter specified
 3706                          as the exit control entry address to reestablish
 3707                          a previous exit
 3708                          control entry.  If this is followed by an M$EXIT,
 3709                          M$ERR or M$XXX, that exit control entry will then
 3710                          be entered.
 3711
 3712                          To unconditionally exit the current job step, the
 3713                          user can call the M$EXIT, M$ERR, or M$XXX service.
 3714                          The user may communicate with other job steps in
 3715                          the same job by use of the Step Condition Code,
 3716                          which may be set via a parameter of these
 3717                          services.
 3718
 3719                          Please note that a program is removed from the "exit" status
 3720                          any time an exit control frame is removed from the Exceptional
 3721                          Condition Stack and the frame does not indicate a nested
 3722                          exit control entry; again, when the 'PROG' bit in B$XCON.CECCB
 3723                          is set.  This may be as a result of an M$CLRSTK service
 3724                          request or an M$TRTN service request.
 3725
 3726                          */
 3727
 3728                          /*F* NAME:  Exit_Control_and_M$LDTRC or Save
 3729
 3730                          If exit control is requested in a program that
 3731                          calls another load module, the M$LDTRC service
 3732                          passes control to the effective exit procedure.  An
 3733                          M$EXIT or M$TRTN request when the top stack
 3734                          frame is the M$LDTRC exit control frame will
 3735                          then cause the M$LDTRC to occur.
 3736
 3737                          The SAVE process is similar when the user
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           102  
 3738                          has asked for exit control on SAVEs via the
 3739                          M$SCON monitor service.  The SAVE process
 3740                          takes place when the user issues an M$EXIT
 3741                          or M$TRTN and the top TCB stack frame is
 3742                          the SAVE exit control frame.
 3743                          */
 3744
 3745
 3746
 3747
 3748                                    /* * NAME: B$WSR_DESC
 3749
 3750                                    The B$WSR_DESC macro may be used to generate a single
 3751                                    standard descriptor of type 0 or 1.
 3752                                    */
 3753
 3754      %MACRO B$WSR_DESC (FPTN=B$WSR_DESC,
 3755         BOUND=0,
 3756         FLGS='000'O,
 3757         WSR=0,
 3758         TYP=0,
 3759         BASE=0,
 3760         LVL=1,
 3761         LAST(YES=";",NO=",",ANY)=";",
 3762         ALGN=ALIGNED,
 3763         STCLASS=BASED);
 3764
 3765      %LSET LISTDIR='0'B;
 3766      %LSET LISTEXP='1'B;
 3767      %LSET LISTCOM='0'B;
 3768      %LSET LISTSUB='1'B;
 3769
 3770      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 3771      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 3772      %LSET INIT=CHARTEXT(' INIT');
 3773      %LSET EINIT=CHARTEXT('');
 3774      %ELSE;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           103  
 3775      %LSET INIT=CHARTEXT('/*');
 3776      %LSET EINIT=CHARTEXT('*/');
 3777      %ENDIF;
 3778
 3779      %IF LVL=1;
 3780      DCL 1 FPTN STCLASS ALGN,
 3781      %ELSE;
 3782              %LVL FPTN,
 3783      %ENDIF;
 3784                %(LVL+1) %CHARTEXT('BOUND UBIN(20) UNAL') %INIT(BOUND)%EINIT,
 3785                %(LVL+1) %CHARTEXT('FLGS BIT(9) UNAL') %INIT(FLGS)%EINIT,
 3786                %(LVL+1) %CHARTEXT('WSR UBIN(3) UNAL') %INIT(WSR)%EINIT,
 3787                %(LVL+1) %CHARTEXT('TYP UBIN(4) UNAL') %INIT(TYP)%EINIT,
 3788                %(LVL+1) %CHARTEXT('BASE SBIN') %INIT(BASE)%EINIT LAST
 3789      %MEND;
 3790
 3791
 3792
 3793                                    /* * NAME: B$SVLDT
 3794
 3795                                    The B$SVLDT macro is used by the monitor to
 3796                                    generate the storage for the parameters placed
 3797                                    on the TCB during SAVE/GET  and M$LDTRC processing.
 3798
 3799                                    */
 3800
 3801      %MACRO B$SVLDT (FPTN=B$SVLDT,
 3802         FULL(YES=1,NO=0,ANY)=1,
 3803         PARONLY(YES=1,NO=0,ANY)=0,
 3804         ALGN=ALIGNED,
 3805         STCLASS=BASED);
 3806
 3807      %LSET LISTDIR='0'B;
 3808      %LSET LISTEXP='1'B;
 3809      %LSET LISTCOM='0'B;
 3810      %LSET LISTSUB='1'B;
 3811
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           104  
 3812      DCL 1 FPTN STCLASS ALGN,
 3813
 3814      %IF PARONLY=0;
 3815      %IF FULL=1;
 3816            2 XCON_FRAME(0:63) UBIN WORD,
 3817      %ELSE;
 3818      %ENDIF;
 3819            2 ECCS UBIN(36),
 3820            2 SUBC REDEF ECCS,
 3821              3 * BIT(9) UNAL,
 3822              3 ALTBIT BIT(1) UNAL,
 3823              3 * BIT(8) UNAL,
 3824              3 EVSC UBIN(18) UNAL,
 3825            2 EVID UBIN(36),
 3826            2 JERR BIT(36),
 3827            2 P# UBIN(36),
 3828      %ELSE;
 3829      %ENDIF;
 3830
 3831            2 NAME$ PTR,
 3832            2 P0$ REDEF NAME$ PTR,
 3833
 3834            2 ACCT$ PTR,
 3835            2 P1$ REDEF ACCT$ PTR,
 3836
 3837            2 PASS$ PTR,
 3838            2 P2$ REDEF PASS$ PTR,
 3839
 3840            2 PSID$ PTR,
 3841            2 P3$ REDEF PSID$ PTR,
 3842
 3843            2 CMD_DSCR$ PTR,
 3844            2 P4$ REDEF CMD_DSCR$ PTR,
 3845            2 DEBUG$ REDEF CMD_DSCR$ PTR,
 3846
 3847            2 FNAME,
 3848              3 CNT UBIN(9) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           105  
 3849              3 TXT CHAR(31) UNAL,
 3850              3 CTXT(0:30) REDEF TXT BIT(9) UNAL,
 3851
 3852            2 ACCT CHAR(8),
 3853
 3854            2 PASS CHAR(8),
 3855
 3856            2 PSID CHAR(6),
 3857
 3858           %B$WSR_DESC(FPTN=CMD_DSCR,STCLASS= ,LVL=2,LAST=YES);
 3859      %MEND;
 3860
 3861
 3862
 3863
 3864                          /*F* NAME:  Exit_Control_and_Domains
 3865
 3866                          At an exit condition, control passes to the exit
 3867                          control procedure of the domain currently in
 3868                          control.  The CP-6 system permits a separate level of exit
 3869                          control for the user domain, the Alternate
 3870                          Shared Library (ASL), the Debugger and the Command
 3871                          Processor.
 3872                          Each level of control is distinct from the other;
 3873                          there may be nesting of exit procedures for each
 3874                          domain.  The system maintains separate limits for each
 3875                          domain.
 3876
 3877                          If both the user and ASL request exit control and
 3878                          the ASL is in control when the exit occurs, its
 3879                          exit procedure is entered first.  If the Alternate
 3880                          Shared Library can recover from the exit
 3881                          condition, it can call the M$TRTN service to
 3882                          continue normal execution.  If the ASL cannot
 3883                          continue normal execution, it can defer exit
 3884                          control processing until the user's exit
 3885                          control has been completed (see M$XCONRTN),
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           106  
 3886                          or it can close files and
 3887                          issue the M$XXX service which causes the monitor
 3888                          to disassociate the ASL and to enter the user's
 3889                          exit procedure.  In this case, the special shared
 3890                          processor abort bit is set (in
 3891                          B$XCON.RNST.SSPABRT).  The environment in the
 3892                          Exceptional Condition Stack is the environment
 3893                          that existed in the user program at the last call
 3894                          to the Alternate Shared Library.  After the ASL is
 3895                          disassociated, no further calls to the ASL are
 3896                          allowed.
 3897
 3898                          If the user is in control at the exit condition,
 3899                          the user's exit procedure takes control immediately.
 3900                          If the user continues the abort process by issuing
 3901                          M$XXX, the ASL exit procedure is entered, allowing
 3902                          the ASL to clean up its files.  In this case the
 3903                          environment on the Safe-Store Stack is the initial
 3904                          ASL environment.  The ASL must exit its exit
 3905                          control procedure by issuing the M$EXIT, M$ERR, or
 3906                          M$XXX service; a M$TRTN request or a return to the
 3907                          user causes reentry to the ASL exit procedure.
 3908
 3909                          If DELTA is associated with the user, and
 3910                          the user is in control when the exit condition
 3911                          occurs, DELTA is entered prior to entering the
 3912                          exit control procedure for the user or ASL.  The
 3913                          "XCON" command to DELTA then causes the user's
 3914                          exit control procedure to be entered.  When the
 3915                          user issues an M$EXIT, M$ERR or M$XXX service
 3916                          request in his exit control procedure, control
 3917                          passes to the Special Shared Processors that
 3918                          have requested exit control from lowest to
 3919                          highest priority.
 3920                          */
 3921
 3922
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           107  
 3923
 3924
 3925                          /*F* NAME: M$SENV and M$RENV - Save/Restore ALTRET Environment
 3926
 3927                          The services to save and restore the environment
 3928                          are typically used in conjunction with an ALTRET
 3929                          code sequence.  Saving the ALTRET environment also
 3930                          permits esoteric manipulations.  For example,
 3931                          using M$SENV/M$RENV allows recursion into the
 3932                          ALTRET code sequence.  In another case, using
 3933                          M$SENV/M$RENV protects the ALTRET environment of
 3934                          the main procedure of a program if any ASYNC
 3935                          procedure also issues monitor service requests.
 3936                          In addition, using the M$SENV service ensures the
 3937                          integrity of the ALTRET environment in case of an
 3938                          "insufficient space in TCB stack" condition which
 3939                          can occur if an exceptional condition is detected
 3940                          while the ALTRET code sequence has control.
 3941
 3942
 3943                          .brn 4
 3944                          M$SENV
 3945                          .spf
 3946                          The M$SENV service allocates a frame in the
 3947                          Exceptional Condition Stack and moves the
 3948                          environment to the frame from the TCB ALTRET frame.
 3949
 3950                          The M$SENV service takes the alternate return if
 3951                          there is no environment in the ALTRET frame or if
 3952                          there is insufficient space to store the
 3953                          environment in the Exceptional Condition Stack.
 3954
 3955                          The form of the call for this service is:
 3956
 3957                          CALL M$SENV [ALTRET (label)];
 3958
 3959                          Because no parameters are associated with the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           108  
 3960                          monitor service call, there is no FPT.
 3961
 3962
 3963                          M$RENV
 3964
 3965                          The M$RENV service removes the top frame of the
 3966                          exceptional condition stack and restores the
 3967                          environment to the ALTRET frame in the TCB.
 3968
 3969                          The M$RENV service takes the alternate return if
 3970                          the exceptional condition stack is empty or if the
 3971                          top frame of the stack is not an ALTRET frame.
 3972
 3973                          The form of the call for this service is:
 3974
 3975                          CALL M$RENV [ALTRET (label)];
 3976
 3977                          Because no parameters are associated with the
 3978                          monitor service call, there is no FPT.*/
 3979
 3980
 3981
 3982
 3983                          /*F* NAME:  Exiting Exceptional Condition Procedure
 3984
 3985                          The user's exceptional condition procedure or ALTRET
 3986                          code sequence determines whether to exit, to abort, to pass
 3987                          control to the monitor for error processing, or to
 3988                          resume normal program execution.  The services
 3989                          described here allow the user to transfer control,
 3990                          to manipulate the TCB Exception Condition Stack,
 3991                          and to restore a prior environment to the
 3992                          Safe-Store Stack.  These services are categorized
 3993                          below by the type of procedure in which they may
 3994                          appear.
 3995
 3996                          }  Routine Type    Monitor Services to Exit the Routine
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           109  
 3997                          }
 3998                          }  ALTRET          M$MERC
 3999                          }  code sequence   M$MERCS  (a)
 4000                          }                  M$RETRY
 4001                          }                  M$RETRYS (a)
 4002                          }
 4003                          }  Exceptional     M$TRTN
 4004                          }  Condition       M$CLRSTK
 4005                          }  Procedures      M$MERCS
 4006                          }                  M$RETRYS (b)
 4007                          }
 4008                            a  This service is appropriate if the original monitor service
 4009                               environment is in the top frame of the Exceptional Condition
 4010                               Stack.
 4011
 4012                            b  This service may be used to exit the PMME procedure
 4013                               specified on the M$TRAP service.
 4014
 4015
 4016
 4017                          PL-6 CONSIDERATIONS
 4018                          }
 4019                          }
 4020                          In a PL-6 program, the M$TRAP, M$STIMER, M$EVENT,
 4021                          M$INT, and M$XCON services establish the entry
 4022                          (ENTADDR) to procedures to be entered asynchronously
 4023                          when exceptional conditions occur.  These procedures
 4024                          should be coded as external ASYNC procedures.
 4025
 4026                          Exit from these procedures can take advantage of the
 4027                          PL-6 RETURN and ALTRETURN statements.  In
 4028                          particular, exit from a PL-6 ASYNC procedure can
 4029                          occur as follows:
 4030                          }
 4031                          o  RETURN - Generates an M$TRTN monitor service request (with no
 4032                                        FPT) which returns to the point of interruption
 4033                                        with the original environment restored to the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           110  
 4034                                        Safe-Store Stack.
 4035                          }
 4036                          o  ALTRETURN - Generates an M$MERCS monitor service request
 4037                                        which gives control to the monitor for error
 4038                                        processing.
 4039                          }
 4040                          o  UNWIND - Restores the AUTO pointer to the REMEMBERed value
 4041                                        and transfers control to the REMEMBERed
 4042                                        label.  UNWIND should normally be preceded by
 4043                                        M$CLRSTK to release the top frame on the
 4044                                        Exceptional Condition Stack.
 4045
 4046                          If it is necessary to execute an M$TRTN or M$MERCS
 4047                          procedure specifying an FPT, this must be done by
 4048                          calling X66_TRTN or X66_MERCS respectively, passing
 4049                          the FPT to be used.  Automatic storage will be
 4050                          properly maintained followed by the execution of the
 4051                          desired monitor service request.  In no case should
 4052                          M$TRTN or M$MERCS monitor service, with or without an
 4053                          FPT, be requested from an PL6 procedure.
 4054                          */
 4055
 4056                          /*F* NAME: M$MERC and M$MERCS - Monitor Error Control
 4057
 4058
 4059                          The M$MERC service returns control from the user
 4060                          ALTRET code sequence to the monitor.  This service is
 4061                          provided in case the ALTRET procedure cannot process
 4062                          all possible error codes.  The original
 4063                          environment from the error on a monitor service
 4064                          call is assumed to be in the ALTRET frame of the
 4065                          TCB at the call to the M$MERC service.
 4066
 4067                          The monitor responds by taking appropriate action
 4068                          based on the severity of the error:
 4069
 4070                          TU
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           111  
 4071                            Severity Level   Monitor Action
 4072
 4073                             0               Ignore the error.  Return to the statement
 4074                                             following the monitor service call, with the
 4075                                             Safe-Store Stack reflecting the original
 4076                                             environment.  If the MERC is from exit control
 4077                                             the monitor performs M$EXIT.
 4078
 4079                            1-3              Abort the job step. (The monitor performs M$ERR.)
 4080
 4081                             >3              Abort the job.  (The monitor performs M$XXX.)
 4082
 4083                          TF
 4084                          The STEPCC will be set to the value of the
 4085                          severity of the error code.
 4086                          The M$MERC service takes the alternate return if
 4087                          there is no environment in the ALTRET frame of the
 4088                          TCB.  No FPT is required by M$MERC but one may
 4089                          be specified to provide for explicit
 4090                          setting of the severity of the error.
 4091
 4092                          The form of the call for this service is:
 4093
 4094                          CALL M$MERC [ALTRET(label)];
 4095
 4096                          or
 4097
 4098                          CALL M$MERC(FPT_MERC) [ALTRET(label)];
 4099
 4100
 4101                          The M$MERCS service performs the same function as
 4102                          the M$MERC service, except that the
 4103                          environment is assumed to be in the top frame of
 4104                          the Exceptional Condition Stack.  (The M$MERCS
 4105                          service releases this top frame.)  Thus this
 4106                          service is appropriate for use in an ALTRET
 4107                          code sequence that previously executed M$SENV, in the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           112  
 4108                          PMME procedure specified on the M$TRAP service, or
 4109                          in an exit control procedure that receives control
 4110                          because the program provides no ALTRET procedure or
 4111                          M$TRAP procedure.
 4112
 4113                          The M$MERCS service takes the alternate return if
 4114                          the Exceptional Condition Stack frame is empty.
 4115                          No FPT is required by M$MERCS but one may
 4116                          be specified to provide for explicit
 4117                          setting of the severity of the error.
 4118                          Generally, a PL-6 programmer will not use M$MERCS directly.
 4119                          Please refer to the comments about PL-6 considerations
 4120                          under 'Exiting Exceptional Condition Procedures' in this
 4121                          section.
 4122
 4123                          The form of the call for this service is:
 4124
 4125                          CALL M$MERCS [ALTRET(label)];
 4126
 4127                          or
 4128
 4129                          CALL M$MERCS(FPT_MERC) [ALTRET(label)];
 4130
 4131
 4132                          Note that the same FPT is used for both the
 4133                          M$MERC and M$MERCS services. The
 4134                          parameter is also identical:
 4135                          */
 4136
 4137      %MACRO FPT_MERC (FPTN=FPT_MERC,
 4138                 JERR=NIL,
 4139                 STCLASS=STATIC);
 4140
 4141      %LSET LISTDIR='0'B;
 4142      %LSET LISTEXP='1'B;
 4143      %LSET LISTCOM='0'B;
 4144      %LSET LISTSUB='1'B;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           113  
 4145      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4146      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4147       (SUBSTR(STR,0,8)='CONSTANT') OR
 4148       (SUBSTR(STR,0,3)='EXT');
 4149       %LSET INIT=CHARTEXT('INIT');
 4150      %ELSE;
 4151       %LSET INIT=CHARTEXT('/*');
 4152      %ENDIF;
 4153
 4154
 4155      DCL 1 FPTN STCLASS DALIGNED,
 4156            2 JERR_ BIT(72) %INIT(VECTOR(JERR))%CHARTEXT('/**/');
 4157                          /*K* JERR=VARIABLE
 4158                          Locates the word that is to be used
 4159                          to replace the error code. When specified
 4160                          the value of the Severity will be
 4161                          used by the monitor to determine
 4162                          how to proceed.
 4163                          */
 4164
 4165      %MEND;
 4166
 4167                          /*F* NAME: M$RETRY and M$RETRYS - Retry Service
 4168
 4169                          The M$RETRY service returns control from the user
 4170                          ALTRET code sequence to the original monitor service
 4171                          call and retries the service call.  The
 4172                          environment for the original monitor service
 4173                          request is assumed to be in the ALTRET frame of
 4174                          the TCB.  The M$RETRY service takes the alternate
 4175                          return if there is no environment in the ALTRET
 4176                          frame.
 4177
 4178                          Before retrying the call, the user can alter the
 4179                          environment in the ALTRET frame.  If no changes
 4180                          are to be made to the environment, the form of the
 4181                          call for this service is as follows:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           114  
 4182
 4183                          CALL M$RETRY [ALTRET (label)];
 4184
 4185                          If changes are to be made to the environment, the
 4186                          form of the call is as follows:
 4187
 4188                          CALL M$RETRY (FPT_RETRY) [ALTRET (label)];
 4189
 4190                          The M$RETRYS service retries a monitor service
 4191                          call.  Its function is the same as the M$RETRY
 4192                          service except that the environment of the
 4193                          original monitor service call is assumed to be in
 4194                          the top frame of the Exceptional Condition Stack.
 4195                          The M$RETRYS service removes this frame from the
 4196                          stack and restores it to the Safe-Store Stack.
 4197                          The M$RETRYS service takes the alternate return if
 4198                          the Exceptional Condition Stack is empty or if the
 4199                          top frame contains an exceptional condition code
 4200                          (ECC) other than %ECC_ALT# or %ECC_PMME#.
 4201
 4202                          If no changes are to be made to the environment
 4203                          prior to retrying the original monitor service
 4204                          call, the form of the call for this service is as
 4205                          follows:
 4206
 4207                          CALL M$RETRYS [ALTRET (label)];
 4208
 4209                          If changes are to be made to the environment, the
 4210                          form of the call is as follows:
 4211
 4212                          CALL M$RETRYS (FPT_RETRY)[ALTRET (label)];
 4213
 4214                          Note that the same FPT is used for both the
 4215                          M$RETRY and M$RETRYS services.  The parameters are
 4216                          also identical:*/
 4217
 4218
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           115  
 4219
 4220
 4221
 4222
 4223
 4224      %MACRO FPT_RETRY
 4225                    (FPTN=FPT_RETRY,
 4226                     REGS=NIL,
 4227                     DRS=NIL,
 4228                     STCLASS=STATIC);
 4229
 4230      %LSET LISTDIR='0'B;
 4231      %LSET LISTEXP='1'B;
 4232      %LSET LISTCOM='0'B;
 4233      %LSET LISTSUB='1'B;
 4234      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4235      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4236       (SUBSTR(STR,0,8)='CONSTANT') OR
 4237       (SUBSTR(STR,0,3)='EXT');
 4238       %LSET INIT=CHARTEXT('INIT');
 4239      %ELSE;
 4240       %LSET INIT=CHARTEXT('/*');
 4241      %ENDIF;
 4242
 4243
 4244      DCL 1 FPTN STCLASS DALIGNED,
 4245            2 REGS_ BIT(72) %INIT(VECTOR(REGS))%CHARTEXT('/**/'),
 4246                          /*K* REGS = VARIABLE    locates an 8-word area
 4247                          that contains the values to replace registers
 4248                          X0-X7, A, Q, and E.  The structure of this area
 4249                          may be generated by the VLP_REGS macro.
 4250                          Default = NIL.                                                                */
 4251
 4252
 4253
 4254            2 DRS_ BIT(72) %INIT(VECTOR(DRS))%CHARTEXT('/**/');
 4255                          /*K* DRS = VARIABLE    locates an 8-word area that
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           116  
 4256                          contains the pointers that are used to load the
 4257                          Pointer Registers.  The SID section of each
 4258                          pointer must reference the Linkage Segment; if
 4259                          not, the alternate return is taken.  The structure
 4260                          for the area may be generated by the VLP_PTRS
 4261                          macro.  Default = NIL.                                                        */
 4262      %MEND;
 4263
 4264
 4265
 4266
 4267                          /*F* NAME: M$TRTN - TCB Return.
 4268
 4269                          The M$TRTN service returns control to the program
 4270                          from an exceptional condition  procedure.  The
 4271                          service removes the top frame of the Exceptional
 4272                          Condition Stack and restores that environment to
 4273                          the Safe-Store Stack.  The user may specify
 4274                          changes to be made to the environment, including
 4275                          the Instruction Counter.  The M$TRTN service
 4276                          transfers control to the user program at the
 4277                          statement following the point of interruption or
 4278                          to the location specified by a change to the IC.
 4279
 4280                          Note that if the M$TRTN service request is issued
 4281                          when the top frame on the Exceptional Condition
 4282                          Stack is an exit control frame, and that frame does
 4283                          not indicate a nested exit control entry, the program
 4284                          is removed from the "exit" status.  Please refer to
 4285                          'EXIT FROM EXIT CONTROL' in this section.
 4286
 4287                          Generally, a PL-6 programmer will not use M$TRTN directly.
 4288                          Please refer to the comments about PL-6 considerations
 4289                          under 'Exiting Exceptional Condition Procedures' in this
 4290                          section.
 4291
 4292                          The M$TRTN service takes the alternate return if
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           117  
 4293                          there is no environment in the Exceptional
 4294                          Condition Stack.
 4295
 4296                          If there are no changes to the environment, the
 4297                          form of the call for the M$TRTN service is as
 4298                          follows:
 4299
 4300                          CALL M$TRTN [ALTRET (label)];
 4301
 4302                          If there are changes to be made to the
 4303                          environment, the form of the call for this service
 4304                          is as follows:
 4305
 4306                          CALL M$TRTN (FPT_TRTN) [ALTRET (label)];
 4307
 4308                          In this case, the parameters for the M$TRTN
 4309                          service are as follows:*/
 4310
 4311
 4312
 4313
 4314      %MACRO FPT_TRTN
 4315                    (FPTN=FPT_TRTN,
 4316                     REGS=NIL,
 4317                     DRS=NIL,
 4318                     IC=0,
 4319                     IR='000'O,
 4320                     SETIR(YES='1'B,NO='0'B)='0'B,
 4321                     STCLASS=STATIC);
 4322
 4323      %LSET LISTDIR='0'B;
 4324      %LSET LISTEXP='1'B;
 4325      %LSET LISTCOM='0'B;
 4326      %LSET LISTSUB='1'B;
 4327      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4328      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4329       (SUBSTR(STR,0,8)='CONSTANT') OR
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           118  
 4330       (SUBSTR(STR,0,3)='EXT');
 4331       %LSET INIT=CHARTEXT('INIT');
 4332      %ELSE;
 4333       %LSET INIT=CHARTEXT('/*');
 4334      %ENDIF;
 4335
 4336      DCL 1 FPTN STCLASS DALIGNED,
 4337            2 REGS_ BIT(72) %INIT(VECTOR(REGS))%CHARTEXT('/**/'),
 4338                          /*K* REGS = VARIABLE    locates an 8-word area
 4339                          that contains the values to replace X0-X7, A, Q,
 4340                          and E.  The structure of this area may be
 4341                          generated by the VLP_REGS macro.
 4342                          Default = NIL.*/
 4343            2 DRS_ BIT(72) %INIT(VECTOR(DRS))%CHARTEXT('/**/'),
 4344                          /*K* DRS = VARIABLE    locates an 8-word area that
 4345                          contains the pointers that are used to load the
 4346                          Pointer Registers.  The SID section of each
 4347                          pointer must reference the User Linkage Segment
 4348                          or the Argument Stack; if it does not, the
 4349                          alternate return is taken.  The structure for the
 4350                          area may be generated by the VLP_PTRS macro.
 4351                          Default = NIL.                                                                */
 4352            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4353            2 V DALIGNED,
 4354              3 IC# UBIN(18) UNAL %INIT(IC)%CHARTEXT('/**/'),
 4355                          /*K* IC = VALUE-DEC(0-n)    specifies the location
 4356                          of a procedure to be entered following the call to
 4357                          M$TRTN.  A value of zero indicates that the IC is
 4358                          not to be changed.  Default = 0.*/
 4359              3 IR# BIT(18) UNAL %INIT(IR)%CHARTEXT('/**/'),
 4360                          /*K* IR = VALUE-BIT(18)    specifies the value to
 4361                          be placed in the Indicator Register when the
 4362                          environment is restored.  Default = '000'O.*/
 4363              3 IRBIT# REDEF IR#,
 4364                4 ZERO BIT(1) UNAL,
 4365                4 NEG BIT(1) UNAL,
 4366                4 CARRY BIT(1) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           119  
 4367                4 OF BIT(1) UNAL,
 4368                4 EXOF BIT(1) UNAL,
 4369                4 EXUF BIT(1) UNAL,
 4370                4 OFM BIT(1) UNAL,
 4371                4 TR BIT(1) UNAL,
 4372                4 PE BIT(1) UNAL,
 4373                4 PM BIT(1) UNAL,
 4374                4 MM BIT(1) UNAL,
 4375                4 TRC BIT(1) UNAL,
 4376                4 MIR BIT(1) UNAL,
 4377                4 EXUFM BIT(1) UNAL,
 4378                4 HEX BIT(1) UNAL,
 4379                4 * BIT(3) UNAL,
 4380              3 SETIR# BIT(1) UNAL %INIT(SETIR)%CHARTEXT('/**/'),
 4381                          /*K* SETIR = {YES|NO}    indicates whether or not
 4382                          the contents of the Indicator Register is to be
 4383                          replaced in the restore environment.  Default =
 4384                          NO.*/
 4385              3 * BIT(35) UNAL %INIT('0'B)%CHARTEXT('/**/');
 4386      %MEND;
 4387
 4388
 4389
 4390                          /*F* NAME: M$CLRSTK - Clear Stack Frame(s).
 4391
 4392                          The M$CLRSTK service deletes one or more frames
 4393                          from the Exceptional Condition Stack.  Following
 4394                          this call, execution continues in-line.  If there
 4395                          is no environment in the Exceptional Condition
 4396                          Stack, the alternate return is taken.
 4397
 4398                          Note that on removing an exit control frame from
 4399                          the Exceptional Condition Stack if that frame does
 4400                          not indicate a nested exit control entry, the program
 4401                          is removed from the "exit" status.  Please refer to
 4402                          'EXIT FROM EXIT CONTROL' in this section.
 4403
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           120  
 4404                          To clear the top frame in the stack, the form of
 4405                          the call to this service is as follows:
 4406
 4407                          CALL M$CLRSTK [ALTRET (label)];
 4408
 4409                          To clear more that one frame, the form of the call
 4410                          for this service is as follows:
 4411
 4412                          CALL M$CLRSTK (FPT_CLRSTK) [ALTRET (label)];
 4413
 4414                          In this case, the parameters for the service is as
 4415                          follows:*/
 4416
 4417
 4418      %MACRO FPT_CLRSTK
 4419                   (FPTN=FPT_CLRSTK,
 4420                    FRAMES=1,
 4421                    STCLASS=STATIC);
 4422
 4423      %LSET LISTDIR='0'B;
 4424      %LSET LISTEXP='1'B;
 4425      %LSET LISTCOM='0'B;
 4426      %LSET LISTSUB='1'B;
 4427      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4428      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4429       (SUBSTR(STR,0,8)='CONSTANT') OR
 4430       (SUBSTR(STR,0,3)='EXT');
 4431       %LSET INIT=CHARTEXT('INIT');
 4432      %ELSE;
 4433       %LSET INIT=CHARTEXT('/*');
 4434      %ENDIF;
 4435
 4436
 4437      DCL 1 FPTN STCLASS DALIGNED,
 4438            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4439            2 V DALIGNED,
 4440              3 FRAMES# UBIN(36) %INIT(FRAMES)%CHARTEXT('/**/'),
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           121  
 4441                          /*K* FRAMES = VALUE-DEC(1-n)    specifies the
 4442                          number of frames to remove from the Exceptional
 4443                          Condition Stack.  If the value specified is equal
 4444                          to or greater than the number of frames currently
 4445                          on the stack, all frames are removed and the stack
 4446                          is marked empty.  Default = 1.*/
 4447
 4448              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 4449      %MEND;
 4450
 4451
 4452
 4453
 4454
 4455      %MACRO VLP_REGS
 4456                    (FPTN=VLP_REGS,
 4457                     STCLASS=STATIC);
 4458
 4459      %LSET LISTDIR='0'B;
 4460      %LSET LISTEXP='1'B;
 4461      %LSET LISTCOM='0'B;
 4462      %LSET LISTSUB='1'B;
 4463      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4464      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4465       (SUBSTR(STR,0,8)='CONSTANT') OR
 4466       (SUBSTR(STR,0,3)='EXT');
 4467       %LSET INIT=CHARTEXT('INIT');
 4468      %ELSE;
 4469       %LSET INIT=CHARTEXT('/*');
 4470      %ENDIF;
 4471
 4472                          /*F* NAME:  VLP_REGS
 4473
 4474                          Three monitor services that may be used to exit
 4475                          Exceptional Condition Processing procedures allow
 4476                          for the values of the index registers, the A and Q
 4477                          registers, and the exponent register to be replaced
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           122  
 4478                          by values specified in the FPT.  These monitor
 4479                          services are M$TRTN, M$RETRY and M$RETRYS.
 4480
 4481                          The VLP_REGS  macro may be used to define the area
 4482                          to contain these values.  No initial values are
 4483                          provided for in this macro as the values must
 4484                          always be supplied at run time.  Generally, the
 4485                          data area defined by the VLP_REGS  macro will be
 4486                          initialized from the TCB frame (B$EXCFR.REGS)  and selected values
 4487                          replaced.  The monitor service FPT can then be
 4488                          modified to point to this area (or can be initialized
 4489                          at compile time to point to this area).
 4490                          For example, the following PL-6 statements would cause
 4491                          the contents of Index Register 7 and the Q register
 4492                          to be replaced on returning to the point of interruption:
 4493
 4494                          .fif
 4495                          %INCLUDE CP_6;
 4496                          %B$TCB;
 4497                          %B$EXCFR;
 4498                          %VLP_REGS;
 4499                          %FPT_TRTN;
 4500
 4501                          DCL B$TCB$ PTR SYMREF;
 4502
 4503                          VLP_REGS = B$TCB$->B$TCB.STK$->B$EXCFR.REGS;
 4504                          VLP_REGS.REG.X7 = 0;
 4505                          VLP_REGS.Q = 0;
 4506                          FPT_TRTN.REGS_ = VECTOR(VLP_REGS);
 4507                          CALL M$TRTN(FPT_TRTN);
 4508                          .fin
 4509
 4510
 4511
 4512                          */
 4513      DCL 1 FPTN STCLASS DALIGNED,
 4514            2 XREGS(0:7) UBIN(18) UNAL,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           123  
 4515                          /*K* XREGS = ARRAY(0:7)-UBIN(18).  Contains the values
 4516                          to be used to replace the Index Registers X0 through X7.
 4517                          */
 4518            2 REG REDEF XREGS,
 4519                          /*K* REG.Xn = VALUE-UBIN(18)   where n= 0 through 7.
 4520                          Redefines the Array XREGS, and may be used to address
 4521                          the Index Registers individually.
 4522                          */
 4523              3 X0 UBIN(18) UNAL,
 4524              3 X1 UBIN(18) UNAL,
 4525              3 X2 UBIN(18) UNAL,
 4526              3 X3 UBIN(18) UNAL,
 4527              3 X4 UBIN(18) UNAL,
 4528              3 X5 UBIN(18) UNAL,
 4529              3 X6 UBIN(18) UNAL,
 4530              3 X7 UBIN(18) UNAL,
 4531            2 A UBIN(36) UNAL,
 4532                          /*K* A = VALUE-UBIN(36).  Contains the value to be
 4533                          used to replace the A register.
 4534                          */
 4535            2 Q UBIN(36) UNAL,
 4536                          /*K* Q = VALUE-UBIN(36).  Contains the value to be
 4537                          used to replace the Q register.
 4538                          */
 4539            2 E BIT(8) UNAL,
 4540                          /*K* E = VALUE-BIT(8).   Contains the value to be
 4541                          used to replace the contents of the Exponent Register.
 4542                          */
 4543            2 * BIT(28) UNAL;
 4544      %MEND;
 4545
 4546
 4547
 4548      %MACRO VLP_PTRS
 4549                   (FPTN=VLP_PTRS,
 4550                    STCLASS=STATIC);
 4551
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           124  
 4552      %LSET LISTDIR='0'B;
 4553      %LSET LISTEXP='1'B;
 4554      %LSET LISTCOM='0'B;
 4555      %LSET LISTSUB='1'B;
 4556      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4557      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4558       (SUBSTR(STR,0,8)='CONSTANT') OR
 4559       (SUBSTR(STR,0,3)='EXT');
 4560       %LSET INIT=CHARTEXT('INIT');
 4561      %ELSE;
 4562       %LSET INIT=CHARTEXT('/*');
 4563      %ENDIF;
 4564
 4565                          /*F* NAME:  VLP_PTRS
 4566
 4567                          The M$TRTN, M$RETRY and M$RETRYS monitor services
 4568                          also allow the user to specify that the values of
 4569                          the pointer registers are to be replaced with
 4570                          values supplied in the FPT.
 4571
 4572                          The VLP_PTRS  macro may be used to generate the
 4573                          area to contain the pointers that are to be used
 4574                          to reload the Descriptor Registers and
 4575                          corresponding Address Registers.  No initial values
 4576                          are provided for in this macro as the values must
 4577                          be supplied at run time.  Generally, the data area
 4578                          will be initialized from the TCB frame (B$EXCFR.PRS)
 4579                          and selected values replaced.  The monitor service
 4580                          FPT can then be modified to point to this area (or
 4581                          can be initialized at compile time to point to this
 4582                          area).
 4583
 4584                          */
 4585      DCL 1 FPTN STCLASS DALIGNED,
 4586            2 PR$(0:7) PTR,
 4587                          /*K* PR$ = ARRAY(0:7)-PTR.  Contains the values
 4588                          to be used to replace the Pointer Registers PR0 through PR7.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           125  
 4589                          */
 4590            2 P REDEF PR$,
 4591                          /*K* P.PRn$ = VALUE-PTR   where n= 0 through 7.
 4592                          Redefines the Array PR$, and may be used to address
 4593                          the Pointer Registers individually.
 4594                          */
 4595              3 PR0$ PTR,
 4596              3 PR1$ PTR,
 4597              3 PR2$ PTR,
 4598              3 PR3$ PTR,
 4599              3 PR4$ PTR,
 4600              3 PR5$ PTR,
 4601              3 PR6$ PTR,
 4602              3 PR7$ PTR;
 4603      %MEND;
 4604
 4605
 4606
 4607                                    /*****************************************
 4608
 4609                                    F O R    S E C T I O N   8
 4610
 4611
 4612                                    ****************************************/
 4613
 4614                          /*F*  NAME:  M$DRTN - Debugger Return.
 4615
 4616                          The M$DRTN monitor service provides a way
 4617                          for an Interactive Debugger (hereafter
 4618                          referred to as DELTA) to return control to
 4619                          the user program. A description of the
 4620                          conditions that cause DELTA to receive
 4621                          control and of the environment that exists
 4622                          when DELTA is entered is in order here.
 4623
 4624                          DELTA is entered under any of the following
 4625                          conditions:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           126  
 4626
 4627                            1. Initial entry to DELTA:
 4628
 4629                                 a. A program is started under DELTA.
 4630                                 b. DELTA is invoked at Job-Step with
 4631                                    no Run-unit associated.
 4632                                 c. DELTA is invoked after a user program
 4633                                    is in execution by striking Control-Y
 4634                                    and asking for DELTA.
 4635
 4636                            2. An overlay of the user's program is loaded.
 4637
 4638                            3. A program is put into execution via M$LINK
 4639                               or M$LDTRC or an M$LINKed to program is
 4640                               restored.
 4641
 4642                            4. An Exceptional Condition occurs other than:
 4643
 4644                                 a. Line hang-up
 4645                                 b. Operator !X key-in
 4646                                 c. Bad call, and user has specified ALTRET.
 4647
 4648                            5. A user is exiting an Exceptional Condition
 4649                               processing procedure.
 4650
 4651                            6. DELTA is associated via an M$ALIB service request.
 4652                               If the program making the request is not executing
 4653                               under control of DELTA (see Item #1), DELTA is
 4654                               thereafter entered only on subsequent M$ALIB
 4655                               requests or for requests to be put under control
 4656                               of DELTA.  Note that this may or may not be the
 4657                               initial entry to DELTA.
 4658
 4659                            7. A data breakpoint has been hit.
 4660
 4661                            8. The user program has issued an M$SETFP service
 4662                               request or a state change is to be reported
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           127  
 4663                               for an FPRG that is being debugged.
 4664
 4665
 4666                          When DELTA is entered a standard Exceptional
 4667                          Condition frame containing a copy of the user's
 4668                          Safe-Store frame will be placed in DELTA's TCB.
 4669                          The Exceptional Condition Code (B$EXCFR.ECC),
 4670                          Sub-code (B$EXCFR.SUBC) and Event ID (B$EXCFR.EVID)
 4671                          uniquely identify the condition that caused the
 4672                          entry to DELTA. The %SUB_EXC and %SUB_ECCDELTA
 4673                          macros from the system macro library provide string
 4674                          substitutions for the values of these fields as
 4675                          follows:
 4676                          ..::HL ".BRP"
 4677
 4678                          TU
 4679
 4680                             ECC           SUBC            Reason for entry
 4681                          ____________________________________________________________
 4682
 4683                          DELTA specific ECCs:
 4684
 4685                          ECC_DELTA#   SC_STARTU#     User program started under DELTA.
 4686
 4687                                       SC_JOBSTEP#    DELTA was invoked at Job-Step time.
 4688                                                      No Run-unit associated.
 4689
 4690                                       SC_YC#         Post association of DELTA while
 4691                                                      the user program is in execution.
 4692                                                      B$EXCFR.EVID will contain one of
 4693                                                      the following values:
 4694                                                         EVID_USER#
 4695                                                         EVID_AUTOS#
 4696
 4697                          ECC_OLAY#    Contains the   Overlay has been loaded.
 4698                                        Node#         B$EXCFR.EVID will contain one of
 4699                                                      the following values from the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           128  
 4700                                                      M$OLAY FPT:
 4701                                                         EVID_CANCEL#
 4702                                                         EVID_ENTER#
 4703                                                         EVID_NOPATH#
 4704
 4705                          ECC_LINK#    SC_MLINK#      User program entered via M$LINK.
 4706
 4707                                       SC_MLDTRC#     User program entered via M$LDTRC.
 4708
 4709                          ECC_LRTN#       -           M$LINKed to program has been
 4710                                                      restored.
 4711
 4712                          ECC_ALIB#       -           Debugger was invoked via M$ALIB.
 4713                                                      B$ALIB[F].CMDSZ contains the byte
 4714                                                      size of the command.
 4715                                                      B$ALIB[F].REPLYSZ contains the
 4716                                                      byte size of the reply area.
 4717                                                      B$ALIB[F].WHO is set as follows:
 4718
 4719                                                      SC_AUSR# - User Program
 4720                                                      SC_AASL# - Alternate Shared Library
 4721                                                      SC_ASHR# - Standard Shared Processor
 4722                                                      SC_EXUO# - Execute-only Run unit
 4723
 4724                          ECC_EXCRTN#                 Exit from a user's exceptional
 4725                                                      Condition procedure. B$EXCFR.EVID
 4726                                                      contains the address of the call.
 4727
 4728                                       SC_TRTN#       M$TRTN
 4729                                       SC_MERC#       M$MERC
 4730                                       SC_MERCS#      M$MERCS
 4731                                       SC_RETRY#      M$RETRY
 4732                                       SC_RETRYS#     M$RETRYS
 4733                                       SC_XCONXIT#    Final Exit from Exit Control.  In
 4734                                                      this case B$EXCRTN.TYP has the
 4735                                                      following values:
 4736
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           129  
 4737                                                      XCON_EXIT# - M$EXIT
 4738                                                      XCON_ERR#  - M$ERR
 4739                                                      XCON_XXX#  - M$XXX
 4740
 4741                          ECC_DBRK#       -           Data Break Point
 4742
 4743                          ECC_EVENT#   SUBC_FPRG#     M$SETFP service request complete.
 4744
 4745                                                      B$FPRG.SUBC = %SUBC2_AFD#
 4746                                                      B$FPRG.DCBNO will contain the DCB
 4747                                                        number of the FPRG
 4748
 4749                                       SUBC_COMIO#    FPRG state change message
 4750                                                         is to be read.
 4751
 4752                                                      B$EXCFR.EVID will be zero.
 4753                                                      B$COMIO.DCBNO will contain the DCB
 4754                                                        number of the COMIO
 4755
 4756                          ..::HL ".BRP"
 4757
 4758
 4759                             ECC           SUBC            Reason for entry
 4760                          ___________________________________________________________
 4761                          User Exceptional Condition ECCs:
 4762
 4763                          ECC_TIMER#      -           M$STIMER specified interval
 4764                                                      has expired.
 4765
 4766                          ECC_EVENT#   As specified   Event over which the user has
 4767                                        by user       requested control has occurred.
 4768
 4769                          ECC_INT#     SC_BRK#        Time-sharing terminal break key.
 4770
 4771                                       SC_BYC#        DELTA request from the Command
 4772                                                      Processor when DELTA is already
 4773                                                      associated.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           130  
 4774
 4775                          ECC_XCON#    Refer to       User exit condition, normal
 4776                                        Section 6     or abnormal.
 4777
 4778                          ECC_PMME#    Refer to       Error on Monitor Service request.
 4779                                        Section 6     No ALTRET specified on user's call.
 4780
 4781                          ECC_ARITH#   Refer to       User has caused an Arithmetic
 4782                                        Section 6     fault.
 4783
 4784                          ECC_PROG#    Refer to       User has caused a Programmed
 4785                                        Section 6     fault.
 4786
 4787                          ECC_ERROR#   Refer to       User has caused an Error class
 4788                                        Section 6     fault.
 4789
 4790
 4791                          TF
 4792                          When DELTA is entered because of a user's
 4793                          Exceptional Condition, the ECC and the
 4794                          remainder of the frame will reflect what
 4795                          would have been placed on the user's TCB had
 4796                          the user not been running under DELTA and
 4797                          had established control of the specific
 4798                          condition. No determination has been
 4799                          made as to user specified Exceptional
 4800                          Condition control requests. The Exceptional
 4801                          Condition frame will be moved to the
 4802                          user's TCB and his procedure to handle the
 4803                          condition will be entered only when this
 4804                          action is specified via options of the
 4805                          M$DRTN FPT. (Refer to the description of
 4806                          the SETECC and ECC options below.)
 4807
 4808                          Word 1 of the TCB frame will be non-zero if
 4809                          the ASL was in control upon entry to DELTA.
 4810                          Note that this can happen only if the user
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           131  
 4811                          has hit Break and the ASL has not requested
 4812                          break control or if the user has hit Control-Y
 4813                          and invoked DELTA while the ASL is in control.
 4814
 4815                          DELTA has access to the user's Working Space
 4816                          through descriptors stored in the Special
 4817                          Descriptor Access descriptor slots in DELTA's
 4818                          Linkage Segment. The following pointers
 4819                          (which are DEFed in B_USRPTRS_D) may be used
 4820                          to access the user's area:
 4821                          TU
 4822
 4823                            B$SPCL1$ ->   the user's Safe-Store frame
 4824                            B$SPCL2$ ->   the user's Linkage Segment
 4825                            B$SPCL3$ ->   the user's Argument Segment
 4826                            B$SPCL4$ ->   the user's Parameter Segment
 4827                            B$SPCL5$ ->   the user's Instruction Segment
 4828
 4829                          TF
 4830                          The first four of these descriptors are type 1; the
 4831                          user's Instruction Segment descriptor is type 0.
 4832                          The Special Access Descriptors 2 through 5 are a
 4833                          copy of those from the user's Safe-Store frame.
 4834                          Unless DELTA is being entered as a result of an M$ALIB
 4835                          from an ASL, shared processor or execute-only run unit,
 4836                          the Page Table write control bit
 4837                          for procedure pages in the user's ISR is set
 4838                          prior to entry to DELTA; it is reset when
 4839                          DELTA returns to the monitor via M$DRTN.
 4840
 4841                          The monitor normally enters DELTA via the
 4842                          LTRAD instruction. However, if DELTA is
 4843                          being entered as a result of an M$ALIB
 4844                          request, the monitor will LTRAS to DELTA
 4845                          making the user's M$ALIB FPT available
 4846                          through DELTA's Parameter Stack:
 4847                          TU
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           132  
 4848
 4849                            Descriptor 0  -  frames the Debugger name.
 4850                            Descriptor 1  -  frames the area containing
 4851                                             the command.
 4852                            Descriptor 2  -  frames the area where DELTA
 4853                                             may return a reply.
 4854                            Descriptor 3  -  frames the V area of the M$ALIB FPT.
 4855                                             FPT$ALIB_V may be used to define
 4856                                             the based structure of this area.
 4857
 4858                          TF
 4859
 4860                          DELTA returns control to the user program via
 4861                          the M$DRTN service request. The form of the
 4862                          call for this service is as follows:
 4863
 4864                          CALL M$DRTN(FPT_DRTN) [ALTRET(label)];
 4865
 4866                          The parameters for this service are as follows:
 4867
 4868                          */
 4869
 4870
 4871
 4872      %MACRO FPT_DRTN
 4873                    (FPTN=FPT_DRTN,
 4874                     REGS=NIL,
 4875                     DRS=NIL,
 4876                     ECCS=NIL,
 4877                     FPRG_FID=NIL,
 4878                     IC=0,
 4879                     IR='000'O,
 4880                     SETIR(YES='1'B,NO='0'B)='0'B,
 4881                     SETECC(YES='1'B,NO='0'B)='0'B,
 4882                     ECC=0,
 4883                     FPRG_DCB=0,
 4884                     ALIB_FD(YES='1'B,NO='0'B)='0'B,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           133  
 4885                     WAKE_FD(YES='1'B,NO='0'B)='0'B,
 4886                     SETSTEPCC(YES='1'B,NO='0'B)='0'B,
 4887                     STEPCC(OK=0,ERROR=4,ABORT=6,ANY)=0,
 4888                     QUIT(YES='1'B,NO='0'B)='0'B,
 4889                     ALTRTN(YES='1'B,NO='0'B)='0'B,
 4890                     EVENT(YES='1'B,NO='0'B)='0'B,
 4891                     DLIB(YES='1'B,NO='0'B)='0'B,
 4892                     DBRK(YES='1'B,NO='0'B)='0'B,
 4893                     KLDELTA(YES='1'B,NO='0'B)='0'B,
 4894                     KPDELTA(YES='1'B,NO='0'B)='0'B,
 4895                     MRGSS(YES='1'B,NO='0'B)='0'B,
 4896                     SPCLD(YES='1'B,NO='0'B)='0'B,
 4897                     STCLASS=STATIC);
 4898
 4899      %LSET LISTDIR='0'B;
 4900      %LSET LISTEXP='1'B;
 4901      %LSET LISTCOM='0'B;
 4902      %LSET LISTSUB='1'B;
 4903      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 4904      %IF (SUBSTR(STR,0,6)='STATIC') OR
 4905       (SUBSTR(STR,0,8)='CONSTANT') OR
 4906       (SUBSTR(STR,0,3)='EXT');
 4907       %LSET INIT=CHARTEXT('INIT');
 4908      %ELSE;
 4909       %LSET INIT=CHARTEXT('/*');
 4910      %ENDIF;
 4911
 4912      DCL 1 FPTN STCLASS DALIGNED,
 4913            2 REGS_ BIT(72) %INIT(VECTOR(REGS))%CHARTEXT('/**/'),
 4914                          /*K* REGS = VARIABLE  Specifies an 8 word block
 4915                          that contains the values to replace X0-X7, A,
 4916                          Q and E of the user's environment. The structure
 4917                          of this area may be generated by using the VLP_REGS
 4918                          macro. Default = NIL.
 4919                          */
 4920            2 DRS_ BIT(72) %INIT(VECTOR(DRS))%CHARTEXT('/**/'),
 4921                          /*K* DRS = VARIABLE  Specifies the location of an
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           134  
 4922                          8 word block that contains the pointers to be used
 4923                          to reload the user's Pointer Registers. Note that
 4924                          the SID field must reference the user's Linkage
 4925                          Segment. The structure for this area may be generated
 4926                          by using the VLP_PTRS or VLP_DRS macro. Default = NIL.
 4927                          */
 4928            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 4929            2 ECCS_ BIT(72) %INIT(VECTOR(ECCS))%CHARTEXT('/**/'),
 4930                          /*K* ECCS = VARIABLE  Specifies a 4 word block that
 4931                          contains the data to replace words 64-67 of the
 4932                          Exceptional Condition Frame prior to entering the
 4933                          user's Exceptional Condition procedure. If the SETECC
 4934                          and ECC parameters indicate the original ECC is to
 4935                          be changed, word 67 (B$EXCFR.P#) will be set to 0.
 4936                          The VLP_ECCS macro may be used to generate this area.
 4937                          Default = NIL.
 4938                          */
 4939            2 FPRG_FID_ VECTOR %INIT(VECTOR(FPRG_FID))%CHARTEXT('/**/'),
 4940                          /*K* FPRG_FID = VARIABLE  Specifies the location of the area
 4941                          where the fid for the FPRG specified by the FPRG_DCB option
 4942                          is to be returned.  This option is ignored unless WAKE_DB or ALIB_FD is also
 4943                          specified.  The VLR_FPRG_FID macro should be used to generate
 4944                          this area.
 4945                          Default = NIL.
 4946                          */
 4947            2 V DALIGNED,
 4948              3 IC# UBIN(18) UNAL %INIT(IC)%CHARTEXT('/**/'),
 4949                          /*K* IC = VALUE-DEC(0-n). Specifies the value that is
 4950                          to be used to replace the 18-bit IC in the user's
 4951                          Safe-Store frame.  Default = 0. This value should
 4952                          always be specified.                                                          */
 4953              3 IR# BIT(18) UNAL %INIT(IR)%CHARTEXT('/**/'),
 4954                          /*K* IR = VALUE-BIT(18) Specifies the value to be
 4955                          used to replace the Indicator Register in the user's
 4956                          environment. Ignored if SETIR=NO.  Default = '000'O.
 4957                          */
 4958              3 IRBIT# REDEF IR#,
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           135  
 4959                4 ZERO BIT(1) UNAL,
 4960                4 NEG BIT(1) UNAL,
 4961                4 CARRY BIT(1) UNAL,
 4962                4 OF BIT(1) UNAL,
 4963                4 EXOF BIT(1) UNAL,
 4964                4 EXUF BIT(1) UNAL,
 4965                4 OFM BIT(1) UNAL,
 4966                4 TR BIT(1) UNAL,
 4967                4 PE BIT(1) UNAL,
 4968                4 PM BIT(1) UNAL,
 4969                4 MM BIT(1) UNAL,
 4970                4 TRC BIT(1) UNAL,
 4971                4 MIR BIT(1) UNAL,
 4972                4 EXUFM BIT(1) UNAL,
 4973                4 HEX BIT(1) UNAL,
 4974                4 * BIT(3) UNAL,
 4975              3 SETIR# BIT(1) UNAL %INIT(SETIR)%CHARTEXT('/**/'),
 4976                          /*K* SETIR = {YES|NO}  specifies, if YES, that the value
 4977                          specified by IR=value is to be used to replace the
 4978                          user's Indicator Register. Default = NO.
 4979                          */
 4980              3 SETECC# BIT(1) UNAL %INIT(SETECC)%CHARTEXT('/**/'),
 4981                          /*K* SETECC = {YES|NO}  specifies, if YES, that the value
 4982                          specified via the ECC option is to be used to
 4983                          replace the value of B$EXCFR.ECC .
 4984                          Default = NO.
 4985                          */
 4986              3 QUIT# BIT(1) UNAL %INIT(QUIT)%CHARTEXT('/**/'),
 4987                          /*K* QUIT = {YES|NO}  specifies, if YES, the user's program is
 4988                          to be run down without entering user level Exit Control
 4989                          or re-entering DELTA. Default = NO.
 4990                          */
 4991              3 ALTRTN# BIT(1) UNAL %INIT(ALTRTN)%CHARTEXT('/**/'),
 4992                          /*K*  ALTRTN = {YES|NO}  specifies, if YES, that the user's
 4993                          M$ALIB service request ALTRET procedure is to be entered.
 4994                          The error code to be returned to the user may be
 4995                          specified via the ECCS option (VLP_ECCS.ERR). This
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           136  
 4996                          option is valid only when DELTA is entered with
 4997                          B$EXCFR.ECC = ECC_ALIB#. When the ALTRTN option
 4998                          is specified all other options, other than the
 4999                          error code and the DLIB option specified via the ECCS parameter, are
 5000                          ignored. Default = NO.
 5001                          */
 5002              3 EVENT# BIT(1) UNAL %INIT(EVENT)%CHARTEXT('/**/'),
 5003                          /*K* EVENT = {YES|NO}  specifies, if YES, that any outstanding
 5004                          events belonging to this user are to be deferred until
 5005                          after the user program has been re-entered.
 5006                          Default = NO.
 5007                          */
 5008              3 DLIB# BIT(1) UNAL %INIT(DLIB)%CHARTEXT('/**/'),
 5009                          /*K* DLIB = {YES|NO}  specifies, if YES, that DELTA is to
 5010                          be disassociated from the user. Valid only when
 5011                          DELTA has been entered with B$EXCFR.ECC = ECC_ALIB#.
 5012                          The disassociation will not take place if the program
 5013                          was started under control of DELTA (as indicated by
 5014                          %JJ_UDELTA# set in B$JIT.JUNK).
 5015                          Default = NO.
 5016                          */
 5017              3 DBRK# BIT(1) UNAL %INIT(DBRK)%CHARTEXT('/**/'),
 5018                          /*K* DBRK ={YES|NO}  specifies, if YES, that the entries
 5019                          in the user's Page Table that have the SCDBRK Software
 5020                          Control bit set are to have the write control bit reset.
 5021                          Default = NO.
 5022                          */
 5023              3 KLDELTA# BIT(1) UNAL %INIT(KLDELTA)%CHARTEXT('/**/'),
 5024                          /*K* KLDELTA = {YES|NO} specifies, if YES, that DELTA is to
 5025                          be disassociated from the user.  This option differs from
 5026                          the DLIB option in that the disassociation will take place
 5027                          unconditionally.
 5028                          Default = NO.
 5029                          */
 5030              3 KPDELTA# BIT(1) UNAL %INIT(KPDELTA)%CHARTEXT('/**/'),
 5031                          /*K* KPDELTA = {YES|NO} specifies, if YES, that DELTA is to
 5032                          remain associated with the user program following an M$ALIB
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           137  
 5033                          Service Request.  This option is valid only if DELTA was
 5034                          entered with B$EXCFR.ECC = ECC_ALIB# and then takes precedence
 5035                          over the DLIB option.  The KPDELTA option is ignored if the
 5036                          M$ALIB Service Request was made from an Alternate Shared
 5037                          Library.  Default = NO.
 5038                          */
 5039              3 MRGSS# BIT(1) UNAL %INIT(MRGSS)%CHARTEXT('/**/'),
 5040                          /*K* MRGSS = {YES|NO} specifies, if YES, that the user's
 5041                          Safe-Store frame and the user's environment in DELTA's
 5042                          TCB are to be updated with the data specified
 5043                          via the REGS and DRS parameters.  No other changes are made
 5044                          to  DELTA's environment or to the user's environment.
 5045                          All options other than MRGSS, REGS and DRS are ignored.  DELTA
 5046                          will then be re-entered at the instruction following the
 5047                          M$DRTN Service Request.  Default = NO.
 5048                          */
 5049              3 SPCLD# BIT(1) UNAL %INIT(SPCLD)%CHARTEXT('/**/'),
 5050                          /*K* SPCLD = {YES|NO} specifies, if YES, that the
 5051                          Special Access Descriptors in DELTA's Linkage
 5052                          Segment are to be refreshed to the values that
 5053                          existed upon entry to DELTA.  All other options,
 5054                          including MRGSS, are ignored.  DELTA will be
 5055                          re-entered at the instruction following the
 5056                          M$DRTN Service Request.  Default = NO.
 5057                          */
 5058              3 SETSTEPCC# BIT(1) UNAL %INIT(SETSTEPCC)%CHARTEXT('/**/'),
 5059                          /*K* SETSTEPCC = {YES|NO}  specifies, if YES, that the value
 5060                          specified via the STEPCC option is to be used to
 5061                          replace the value of B$JIT.STEPCC .
 5062                          Default = NO.
 5063                          */
 5064              3 ALIB_FD# BIT(1) UNAL %INIT(ALIB_FD)%CHARTEXT('/**/'),
 5065                          /*K* ALIB_FD = {YES | NO}  specifies, if YES, that the
 5066                          LCP-6 debugger that communicates with the debugger issuing
 5067                          the M$DRTN request is to be associated with the FPRG
 5068                          specified via the FPRG_DCB option and that that debugger
 5069                          is to be entered for communicating with this Host debugger.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           138  
 5070                          The debugger making
 5071                          this request will be re-entered at the instruction
 5072                          following the M$DRTN Service Request.  Default = NO.
 5073                          */
 5074              3 WAKE_FD# BIT(1) UNAL %INIT(WAKE_FD)%CHARTEXT('/**/'),
 5075                          /*K* WAKE_FD = {YES | NO}  specifies, if YES, that the FPRG
 5076                          specified via the FPRG_DCB option is to be suspended and the
 5077                          LCP-6 debugger associated with that FPRG is to be entered to
 5078                          communicate with this Host debugger.  The debugger making
 5079                          this request will be re-entered at the instruction following
 5080                          the M$DRTN service request.  This option is used when  the LCP-6
 5081                          debugger has been previously associated (see the ALIB_FD option).
 5082                          Default = NO.
 5083                          */
 5084              3 * BIT(4) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5085              3 ECC# UBIN(18) UNAL %INIT(ECC)%CHARTEXT('/**/'),
 5086                          /*K* ECC = VALUE-DEC(0-n)  specifies the value that is to
 5087                          replace the B$EXCFR.ECC value of the Exceptional
 5088                          Condition frame. The value of B$EXCFR.ECC
 5089                          is used by the monitor to determine how to
 5090                          proceed. This option is ignored if SETECC = NO;
 5091                          the value from the TCB frame will be used.
 5092                          Basically, the monitor proceeds as follows:
 5093                          }
 5094                          1.  ECC = DELTA specific ECC
 5095                          }
 5096                          The frame is removed from DELTA's TCB and
 5097                          the user is re-entered at the address
 5098                          specified via the IC=value option.
 5099
 5100                          2.  ECC = User Exceptional Condition ECC
 5101                          }
 5102                          If the user has not established control
 5103                          over the condition DELTA will be
 5104                          re-entered at the M$DRTN ALTRET address.
 5105                          B$ALT.ERR in DELTA's TCB ALTRET frame will be set
 5106                          to E$NOCONTROL.
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           139  
 5107
 5108                          If the user has established control over
 5109                          the condition the frame is moved from
 5110                          DELTA's TCB to the user's TCB and the
 5111                          user will be re-entered at his Exceptional
 5112                          Condition processing procedure. If there
 5113                          is insufficient room in the user's TCB to
 5114                          contain the frame, the frame is removed
 5115                          from DELTA's TCB and DELTA will be re-entered
 5116                          at DELTA's start address with a user's Exit
 5117                          Control frame on DELTA's TCB.
 5118
 5119                          */
 5120              3 STEPCC# UBIN(9) UNAL %INIT(STEPCC)%CHARTEXT('/**/'),
 5121                          /*K*  STEPCC = {OK|ERROR|ABORT}   specifies how the Step
 5122                          Condition Code is to be set: OK=0, ERROR=4,
 5123                          ABORT=6. The parameter may also be specified as
 5124                          a decimal value (0-511). The default is 0.                                    */
 5125              3 * BIT(9) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 5126              3 FPRG_DCB# UBIN(18) UNAL %INIT(FPRG_DCB)%CHARTEXT('/**/'),
 5127                          /*K* FPRG_DCB = VALUE-DEC(0-n)  specifies the DCB# through
 5128                          which DELTA communicates with its counterpart LCP-6 debugger.
 5129                          This DCB must have been previously opened DEVICE,
 5130                          RES=FE[nn], ORG={DBGDCB | DBGCG | DBGSYSID}. See
 5131                          M$OPEN for more details.
 5132                          Default = 0.
 5133                          */
 5134              3 * BIT(36) UNAL %INIT('0'B)%CHARTEXT('/**/');
 5135      %MEND;
 5136
 5137
 5138                          /*F* NAME:  VLP_ECCS
 5139
 5140                          The VLP_ECCS  macro may be used to generate the
 5141                          area to contain the values to be used to modify
 5142                          the user's TCB frame when calling the M$DRTN service.
 5143
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           140  
 5144                          No initial values are provided for in this macro,
 5145                          as the values must be supplied at run time.
 5146                          */
 5147
 5148      %MACRO VLP_ECCS
 5149                    (FPTN=VLP_ECCS,
 5150                     STCLASS=STATIC);
 5151
 5152      %LSET LISTDIR='0'B;
 5153      %LSET LISTEXP='1'B;
 5154      %LSET LISTCOM='0'B;
 5155      %LSET LISTSUB='1'B;
 5156      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5157      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5158       (SUBSTR(STR,0,8)='CONSTANT') OR
 5159       (SUBSTR(STR,0,3)='EXT');
 5160       %LSET INIT=CHARTEXT('INIT');
 5161      %ELSE;
 5162       %LSET INIT=CHARTEXT('/*');
 5163      %ENDIF;
 5164
 5165      DCL 1 FPTN STCLASS ALIGNED,
 5166            2 SUBC UBIN(36),
 5167                          /*K* SUBC = VALUE-DEC(0-n)   Specifies the ECC
 5168                          subcode which is redefined as ECCS.EVSC.                                      */
 5169            2 ECCS REDEF SUBC,
 5170              3 * UBIN(18) UNAL,
 5171              3 EVSC UBIN(18) UNAL,
 5172                          /*K* ECCS.EVSC = VALUE-DEC(0-n)  Specifies the ECC
 5173                          subcode.                                                                      */
 5174            2 EVID UBIN(36),
 5175                          /*K* EVID = VALUE-DEC(0-n)  Specifies the event
 5176                          ID.                                                                           */
 5177            2 ERR BIT(36),
 5178                          /*K* ERR = VALUE-BIT(36)  Specifies the error
 5179                          code.*/
 5180            2 P# UBIN(36);
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           141  
 5181                          /*K* P# = VALUE-DEC(0-n)  Specifies the number
 5182                          of parameters which follows in this frame.
 5183                          This value will be forced to zero if there is
 5184                          a change to the ECC.
 5185                          */
 5186      %MEND;
 5187
 5188
 5189
 5190                          /*F* NAME:  VLP_DRS
 5191
 5192                          The M$DRTN monitor service allows the user to
 5193                          specify that the values of the pointer registers
 5194                          are to be replaced with values supplied via the
 5195                          FPT.  The VLP_DRS macro generates an area to contain
 5196                          the pointers that are to be used to reload the
 5197                          Descriptor Registers and corresponding Address
 5198                          Registers.  No initial values are provided for in this
 5199                          macro.
 5200                          */
 5201      %MACRO VLP_DRS
 5202                   (FPTN=VLP_DRS,
 5203                    STCLASS=STATIC);
 5204
 5205      %LSET LISTDIR='0'B;
 5206      %LSET LISTEXP='1'B;
 5207      %LSET LISTCOM='0'B;
 5208      %LSET LISTSUB='1'B;
 5209      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5210      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5211       (SUBSTR(STR,0,8)='CONSTANT') OR
 5212       (SUBSTR(STR,0,3)='EXT');
 5213       %LSET INIT=CHARTEXT('INIT');
 5214      %ELSE;
 5215       %LSET INIT=CHARTEXT('/*');
 5216      %ENDIF;
 5217
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           142  
 5218      DCL 1 FPTN STCLASS DALIGNED,
 5219            2 PR0,
 5220                          /*K* PR0 - PR7 = 8 POINTERS  Specifies the pointer
 5221                          contents.  Each pointer is defined with a 24-bit
 5222                          AR field (VALUE-DEC) followed by an 18-bit SID
 5223                          field (VALUE-BIT).                                                            */
 5224              3 AR0 UBIN(24) UNAL,
 5225              3 SID BIT(12) UNAL,
 5226            2 PR1,
 5227              3 AR1 UBIN(24) UNAL,
 5228              3 SID BIT(12) UNAL,
 5229            2 PR2,
 5230              3 AR2 UBIN(24) UNAL,
 5231              3 SID BIT(12) UNAL,
 5232            2 PR3,
 5233              3 AR3 UBIN(24) UNAL,
 5234              3 SID BIT(12) UNAL,
 5235            2 PR4,
 5236              3 AR4 UBIN(24) UNAL,
 5237              3 SID BIT(12) UNAL,
 5238            2 PR5,
 5239              3 AR5 UBIN(24) UNAL,
 5240              3 SID BIT(12) UNAL,
 5241            2 PR6,
 5242              3 AR6 UBIN(24) UNAL,
 5243              3 SID BIT(12) UNAL,
 5244            2 PR7,
 5245              3 AR7 UBIN(24) UNAL,
 5246              3 SID BIT(12) UNAL;
 5247      %MEND;
 5248
 5249
 5250
 5251
 5252
 5253                          /*F* NAME: VLR_FPRG_FID
 5254
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           143  
 5255                          A host debugger may use the VLR_FPRG_FID macro to generate
 5256                          an area where the fid of the specified FPRG is to be returned
 5257                          on an M$DRTN monitor service request which has the ALIB_FD
 5258                          option specified.
 5259                          */
 5260
 5261      %MACRO VLR_FPRG_FID
 5262         (FPTN=VLR_FPRG_FID,
 5263          STCLASS=STATIC);
 5264
 5265      %LSET LISTDIR='0'B;
 5266      %LSET LISTEXP='1'B;
 5267      %LSET LISTCOM='0'B;
 5268      %LSET LISTSUB='1'B;
 5269
 5270      DCL 1 FPTN STCLASS DALIGNED,
 5271            2 NAME,
 5272              3 L UBIN BYTE UNAL,
 5273              3 TEXT CHAR(31) UNAL,
 5274                          /*K* NAME = TEXTC(31).  Contains the FPRG NAME of the file.
 5275                          */
 5276            2 ACCT CHAR(8) UNAL,
 5277                          /*K* ACCT = CHAR(8).  Contains the ACCounT from where the
 5278                          FPRG was fetched.
 5279                          */
 5280            2 PASS CHAR(8) UNAL,
 5281                          /*K* PASS = CHAR(8).  Contains the PASSword associated with
 5282                          the FPRG.
 5283                          */
 5284            2 PSN CHAR(6) UNAL,
 5285                          /*K* PSN = CHAR(8).  Contains the Pack Set Name of the
 5286                          pack set on which the FPRG resides.
 5287                          */
 5288            2 MODTIME UBIN(36);
 5289                          /*K* MODTIME = UBIN(36).  Contains the MODification
 5290                          TIME of the FPRG to be associated.
 5291                          */
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           144  
 5292      %MEND;
 5293
 5294                          /*F* NAME: SUB_ECCDELTA
 5295
 5296                          The %SUB_ECCDELTA macro generates string
 5297                          substitutions of the ECC and ECC Sub-code
 5298                          that is passed to DELTA in the user environment
 5299                          frame on DELTA's TCB.
 5300                          */
 5301      %MACRO SUB_ECCDELTA;
 5302                                    /* The following SUBs define B$BRK.SUBC when DELTA
 5303                                       is entered for Break Control                                     */
 5304      %EQU SC_BRK#=0/*SC_BRK#*/;    /*Entered for BREAK                                                 */
 5305      %EQU SC_BYC#=1/*SC_BYC#*/;    /*Entered for YC-DELTA   - DELTA already assoc                      */
 5306
 5307
 5308      %EQU ECC_DELTA#=90/*ECC_DELTA#*/;
 5309      %EQU SC_STARTU#=0/*SC_STARTU#*/;
 5310      %EQU SC_JOBSTEP#=1/*SC_JOBSTEP#*/;
 5311      %EQU SC_YC#=2/*SC_YC#*/;
 5312      %EQU EVID_USER#=0;
 5313      %EQU EVID_AUTOS#=1;
 5314
 5315      %EQU ECC_OLAY#=91/*ECC_OLAY#*/;
 5316                                    /* SUB CODE CONTAINS THE NODE # IF USER PROGRAM                     */
 5317                                    /* SUB CODE CONTAINS THE OLAY # IF SHARED PROCESSOR                 */
 5318      %EQU EVID_CANCEL#=1/*EVID_CANCEL#*/;
 5319      %EQU EVID_ENTER#=2/*EVID_ENTER#*/;
 5320      %EQU EVID_NOPATH#=4/*EVID_NOPATH#*/;
 5321
 5322      %EQU ECC_LINK#=92/*ECC_LINK#*/; /* ENTERED VIA M$LINK OR M$LDTRC*/
 5323      %EQU SC_MLINK#=0/*SC_LINK#*/;
 5324      %EQU SC_MLDTRC#=1/*SC_LDTRC#*/;
 5325
 5326      %EQU ECC_LRTN#=93/*ECC_LRTN#*/; /* RETURNED TO M$LINK+1*/
 5327
 5328      %EQU ECC_SAVLDT#=94/*ECC_SAVLDT#*/;
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           145  
 5329                                    /* Only used internally by the Monitor-Put here because its handy   */
 5330
 5331      %EQU ECC_ALIB#=95/*ECC_ALIB#*/; /*ENTERED VIA M$ALIB*/
 5332                                    /* SUB CODE CONTAINS BYTE SIZE OF PARAMETER 0*/
 5333                                    /* EVID CONTAINS BYTE SIZE OF PARAMETER 1*/
 5334                                    /* The following subs define B$ALIB[F].WHO when ECC = ECC_ALIB#     */
 5335      %EQU SC_AUSR#=0/*SC_AUSR#*/;  /*Standard user                                                     */
 5336      %EQU SC_AASL#=1/*SC_AASL#*/;  /*Alternate Shared Library                                          */
 5337      %EQU SC_ASHR#=2/*SC_ASHR#*/;  /*Standard Shared Processor                                         */
 5338      %EQU SC_EXUO#=3/*SC_EXUO#*/;  /*Execute-only Run Unit                                             */
 5339
 5340      %EQU ECC_EXCRTN#=96/*ECC_EXCRTN#*/;
 5341      %EQU SC_TRTN#=1/*SC_TRTN#*/;
 5342      %EQU SC_MERC#=2/*SC_MERC#*/;
 5343      %EQU SC_MERCS#=3/*SC_MERCS#*/;
 5344      %EQU SC_RETRY#=4/*SC_RETRY#*/;
 5345      %EQU SC_RETRYS#=5/*SC_RETRYS#*/;
 5346      %EQU SC_XCONXIT#=6/*SC_XCONXIT#*/;
 5347                                    /* The following subs define B$EXCRTN.TYP if SC = ECC_XCONXIT#      */
 5348
 5349      %EQU XCON_EXIT#=1/*XCON_EXIT#*/;
 5350      %EQU XCON_ERR#=2/*XCON_ERR#*/;
 5351      %EQU XCON_XXX#=3/*XCON_XXX#*/;
 5352
 5353                                    /* EVID has address of the PMME                                     */
 5354
 5355
 5356      %EQU ECC_DBRK#=97/*ECC_DBRK#*/; /*DATA BREAK POINT                                                */
 5357
 5358                                    /* The following subs define B$EXCFR.ASLIC                          */
 5359      %EQU ASLIC=1;
 5360      %EQU ASLNIC=0;
 5361      %MEND;
 5362
 5363
 5364                          /*F*  NAME:  B$ALIBF and B$ALIB
 5365
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           146  
 5366                          The B$ALIBF macro may be used by an Interactive Debugger
 5367                          to generate a based structure of the frame placed on the
 5368                          debugger's TCB as a result of a M$ALIB Monitor Service
 5369                          request.  The B$ALIB macro may be used to generate
 5370                          a based structure of only the last 4 words of this
 5371                          frame.
 5372
 5373                          The fully qualified name of fields in these
 5374                          structures begins with the name B$ALIB or B$ALIBF.
 5375                          The sub-fields in these structures are as
 5376                          follows:
 5377                          */
 5378      %MACRO B$ALIBF (NAME=B$ALIBF,STCLASS=BASED);
 5379
 5380      DCL 1 NAME STCLASS ALIGNED,
 5381            2 SSFRAME(0:63) BIT(36) UNAL,
 5382                          /*K* B$ALIBF.SSFRAME = ARRAY(0:63) BIT(36). Contains
 5383                          a copy of the environment at the time of the M$ALIB
 5384                          Service Request.  The based structure B$EXCFR may be
 5385                          used to access the environment.  This field is
 5386                          present only in the B$ALIBF macro.
 5387                          */
 5388            2 WHO UBIN(9) UNAL,
 5389                          /*K* B$ALIBF.WHO = UBIN(9).  Contains the
 5390                          ECC_ALIB# sub-code, which indicates the type of
 5391                          Run-unit that has made the M$ALIB request.
 5392                          */
 5393            2 U1 BIT(7) UNAL,
 5394            2 CMDSZ UBIN(20) UNAL,
 5395                          /*K* B$ALIBF.CMDSZ = UBIN(20).  Contains the
 5396                          byte size of the command that has been supplied by
 5397                          the user via Parameter Stack Descriptor 1.
 5398                          */
 5399            2 U2 BIT(16) UNAL,
 5400            2 REPLYSZ UBIN(20) UNAL,
 5401                          /*K* B$ALIBF.REPLYSZ = UBIN(20).  Contains the
 5402                          byte size of the reply area that has been supplied by
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           147  
 5403                          the user via Parameter Stack Descriptor 2.
 5404                          */
 5405            2 ERR BIT(36) UNAL,
 5406                          /*K*   B$ALIBF.ERR = BIT(36).  Contains the
 5407                          error code (will be zero).
 5408                          */
 5409            2 P# UBIN(36) UNAL;
 5410                          /*K* B$ALIBF.P# = UBIN.  Contains a count
 5411                          of the number of additional words in the Exceptional
 5412                          Condition frame.  For an M$ALIB frame this value
 5413                          will always be zero.
 5414                          */
 5415      %MEND;
 5416
 5417
 5418      %MACRO B$ALIB (NAME=B$ALIB,STCLASS=BASED);
 5419
 5420      DCL 1 NAME STCLASS ALIGNED,
 5421            2 WHO UBIN(9) UNAL,
 5422            2 U1 BIT(7) UNAL,
 5423            2 CMDSZ UBIN(20) UNAL,
 5424            2 U2 BIT(16) UNAL,
 5425            2 REPLYSZ UBIN(20) UNAL,
 5426            2 ERR BIT(36) UNAL,
 5427            2 P# UBIN(36) UNAL;
 5428      %MEND;
 5429
 5430
 5431
 5432                          /*F* NAME: B$EXCRTNF and B$EXCRTN
 5433
 5434                          The B$EXCRTNF macro may be used by an interactive Debugger
 5435                          to generate a based structure of the frame placed on the
 5436                          debugger's TCB when the ECC = %ECC_EXCRTN#.  The B$EXCRTN
 5437                          macro may be used to generate a based structure for only
 5438                          the last 4 words of this frame.
 5439
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           148  
 5440                          The fully qualified name of fields in these
 5441                          structures begins with the name B$EXCRTN or B$EXCRTNF.
 5442                          The sub-fields in these
 5443                          structures are as follows:
 5444                          */
 5445
 5446      %MACRO B$EXCRTNF (NAME=B$EXCRTNF,STCLASS=BASED);
 5447
 5448      DCL 1 NAME STCLASS ALIGNED,
 5449            2 SSFRAME(0:63) BIT(36) UNAL,
 5450                          /*K* B$EXCRTNF.SSFRAME = ARRAY(0:63) BIT(36). Contains
 5451                          a copy of the environment at the time of the exit from the
 5452                          Exceptional Condition.  The based structure B$EXCFR may be
 5453                          used to access the environment.  This field is
 5454                          present only in the B$EXCRTNF macro.
 5455                          */
 5456            2 SVL BIT(9) UNAL,
 5457                          /*K*   B$EXCRTNF.SVL = BIT(9).  This field is non-zero
 5458                          only when the user is exiting an Exit Control procedure
 5459                          after being entered for SAVE or M$LDTRC.  This field
 5460                          will contain one of the following values (from %EQU's
 5461                          found in B$JIT):
 5462                          TU
 5463
 5464                           %SVL_EXIT#   User has issued an M$EXIT
 5465                           %SVL_TRTN#   User has issued an M$TRTN
 5466
 5467                          TF
 5468                          */
 5469            2 TYP UBIN(9) UNAL,
 5470                          /*K*   B$EXCRTNF.TYP = UBIN(9).  This field has meaning
 5471                          only when B$EXCFR.SUBC is set to %SC_XCONXIT#.  See
 5472                          description of %SUB_ECCDELTA.
 5473                          */
 5474            2 ECCS UBIN(18) UNAL,
 5475                          /*K*   B$EXCRTNF.ECCS = UBIN(18).  Contains
 5476                          the %ECC_EXCRTN# Sub-code, which indicates
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           149  
 5477                          which monitor service the user has executed to exit
 5478                          an exceptional condition processing procedure.
 5479                          Refer to the description of %SUB_ECCDELTA.
 5480                          */
 5481            2 EVID UBIN(36),
 5482                          /*K*   B$EXCRTNF.EVID = UBIN(36).  Contains the
 5483                          address of the exceptional condition return
 5484                          service request.
 5485                          */
 5486            2 ERR BIT(36),
 5487                          /*K*   B$EXCRTNF.ERR = BIT(36).  Contains the
 5488                          error code (if any).
 5489                          */
 5490            2 P# UBIN(26);
 5491                          /*K* B$EXCRTNF.P# = UBIN.  Contains a count
 5492                          of the number of additional words in the Exceptional
 5493                          Condition frame.
 5494                          */
 5495      %MEND;
 5496
 5497      %MACRO B$EXCRTN (NAME=B$EXCRTN,STCLASS=BASED);
 5498      DCL 1 NAME STCLASS,
 5499            2 SVL BIT(9) UNAL,
 5500            2 TYP UBIN(9) UNAL,
 5501            2 ECCS UBIN(18) UNAL,
 5502            2 EVID UBIN(36),
 5503            2 ERR BIT(36),
 5504            2 P# UBIN(36);
 5505                                    /* Will always be 0                                                 */
 5506
 5507      %MEND;
 5508
 5509                                    /*******************************************
 5510
 5511                                    F O R    S E C T I O N    4
 5512
 5513                                    ********************************************/
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           150  
 5514
 5515
 5516
 5517                          /*F* NAME:  Program_Management Services
 5518
 5519                          The frequently used program management services are
 5520                          explained in this section.  Additional services that
 5521                          perform privileged or restricted program management
 5522                          functions are described in Section 8 of this manual.
 5523
 5524                          */
 5525                          /*F* NAME:  Program_Suspension and Termination
 5526
 5527                          The monitor provides services to temporarily
 5528                          suspend a program and to terminate a program
 5529                          and initiate job step processing.  The monitor
 5530                          services that provide for program termination pass a
 5531                          value in the Step Condition Code which is
 5532                          available to subsequent job steps as well as to
 5533                          the command processor.  This mechanism allows
 5534                          the programmer or command processor to take
 5535                          appropriate actions following the completion of
 5536                          a program.
 5537
 5538                          */
 5539                          /*F* NAME: M$WAIT - Suspend Program.
 5540
 5541                          The M$WAIT service causes suspension of program
 5542                          execution for a specified period of real time.
 5543                          Program execution is resumed at the next statement
 5544                          following the M$WAIT request.  A suspended program
 5545                          is resumed before its suspension time has expired
 5546                          if an asynchronous event is reported (see
 5547                          M$EVENT).  Optionally, the amount of unexpired
 5548                          time may be returned to the user.
 5549
 5550                          The form of the call for this service is:
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           151  
 5551
 5552                          CALL M$WAIT (FPT_WAIT) [ALTRET(label)];
 5553
 5554                          The parameters for this service are as follows:
 5555                                                                                                     */
 5556      %MACRO  FPT_WAIT
 5557                 (FPTN=FPT_WAIT,
 5558                  STCLASS=STATIC,
 5559                        UETIME=NIL,
 5560                        UTYPE(SEC=1,MIN=2,TUN=5)=1,
 5561                  UNITS=0);
 5562
 5563      %LSET LISTDIR='0'B;
 5564      %LSET LISTEXP='1'B;
 5565      %LSET LISTCOM='0'B;
 5566      %LSET LISTSUB='1'B;
 5567      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5568      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5569       (SUBSTR(STR,0,8)='CONSTANT') OR
 5570       (SUBSTR(STR,0,3)='EXT');
 5571       %LSET INIT=CHARTEXT('INIT');
 5572      %ELSE;
 5573       %LSET INIT=CHARTEXT('/*');
 5574      %ENDIF;
 5575
 5576      DCL 1 FPTN STCLASS DALIGNED,
 5577            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5578            2 UETIME_ BIT(72) %INIT(VECTOR(UETIME))%CHARTEXT('/**/'),
 5579                          /*K* UETIME = VARIABLE locates a 1-word area into
 5580                          which the unexpired suspension time
 5581                          is to be stored. If UETIME is not specified, or
 5582                          is NIL, the time is not returned. If the
 5583                          suspension is not terminated prematurely, the
 5584                          unexpired time will be zero. Default=NIL.                                     */
 5585            2 V DALIGNED,
 5586              3 UNITS# UBIN(36) %INIT(UNITS)%CHARTEXT('/**/'),
 5587                          /*K* UNITS = VALUE-DEC(0-2**36)   specifies the number
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           152  
 5588                          of time units for which the program is to be
 5589                          suspended and is treated modulo 24 hours.
 5590                          The actual amount of time suspended depends
 5591                          on UTYPE, below.  Default=0.                                                  */
 5592              3 UTYPE# UBIN(36) %INIT(UTYPE)%CHARTEXT('/**/');
 5593                          /*K* UTYPE = {SEC|TUN|MIN}   specifies that the
 5594                          UNITS are to be interpreted as full seconds, or as
 5595                          CP-6 host UTS clock units (1/100 second) or as
 5596                          minutes. Default=SEC.
 5597
 5598                          UTYPE may be set at run time by using the values
 5599                          SEC#, MIN#, and TUN# from CP_6_SUBS.
 5600
 5601                          UETIME (unexpired time) is always returned in
 5602                          the units passed.  If the calling program is
 5603                          woken up prior to the end of the specified
 5604                          period, then the UETIME returned will be
 5605                          non-zero.  This is a way of telling you that the
 5606                          program was interrupted, and may not be the best
 5607                          way (especially if MIN was specified), to tell
 5608                          exactly how much time is remaining in the sleep
 5609                          period.
 5610
 5611                          Note that a program will be woken up as soon as
 5612                          possible, depending on other system activity.
 5613                          Although the sleep time may be specified to be
 5614                          as small as 1/100 second, it is not guaranteed
 5615                          that the task will resume execution EXACTLY
 5616                          1/100 second after performing the M$WAIT, but may
 5617                          take a small amount of time longer, usually
 5618                          depending on system load and the system control
 5619                          parameter QMIN.                                                               */
 5620      %MEND;
 5621
 5622
 5623
 5624
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           153  
 5625                          /*F* NAME: M$SPRIV and M$RPRIV - Privileges
 5626
 5627                          The Job Information Table (JIT) contains data
 5628                          describing the job and its current status. The
 5629                          user may read the JIT, using a based structure
 5630                          generated via the B$JIT macro from the B$JIT
 5631                          file. The JIT is divided into several
 5632                          sections: common data, user data, memory management data,
 5633                          file management data, scheduler data, job step
 5634                          data, resource management, and several dummy
 5635                          areas.
 5636                          The user can modify portions of the common and
 5637                          user JIT by using the services described next. To
 5638                          modify other portions of the JIT directly, the
 5639                          user must have the necessary privilege. A full
 5640                          discussion of the JIT is included in Volume 2 of
 5641                          this manual.
 5642
 5643                          CONTROL OF CURRENT PRIVILEGES
 5644                          }
 5645                          The Job Information Table contains flags to
 5646                          control any special actions allowed for the
 5647                          current program. The JIT includes privilege bits
 5648                          for a user program or for a processor running in
 5649                          the user's working space. (In the CP-6 system individual
 5650                          privileges are assigned, rather than privilege
 5651                          levels. Authorization of any specific privilege
 5652                          does not imply any other privilege.)
 5653
 5654                          B$JIT.PRIV.JOB is set by the !PRIV command of IBEX.
 5655                          The privileges allowed a user program are
 5656                          established by SUPER and stored in the user
 5657                          authorization record. At job initiation these
 5658                          privilege bits are set in B$JIT.PRIV.AUTH.
 5659
 5660                          Processors may also include privileges of their
 5661                          own. These privileges requested by an option of
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           154  
 5662                          the Linker are stored in the head record of the
 5663                          run unit. At initiation of a processor fetched
 5664                          from the :SYS account, these bits are copied to
 5665                          B$JIT.PRIV.PRC. (If the run unit is not from
 5666                          :SYS, B$JIT.PRIV.PRC is set to zero.)
 5667
 5668                          The privileges effective for the currently
 5669                          running user program or processor are set in
 5670                          B$JIT.PRIV.ACTIVE. These active privileges are
 5671                          the combination (logical "OR") of B$JIT.PRIV.JOB
 5672                          and B$JIT.PRIV.PRC. The monitor services
 5673                          discussed next permit changes to the active
 5674                          privileges. A program generally issues these
 5675                          monitor services to temporarily deny itself
 5676                          privileges it does not require and thus avoids
 5677                          inadvertent use of unneeded privileges. Only
 5678                          privileges granted to the user (by SUPER) or to a
 5679                          processor (by an option of the Linker) can be set
 5680                          or reset by the monitor services.
 5681
 5682                          NOTE: The user may also use the PRIVILEGE command
 5683                          to change privilege bits in B$JIT.PRIV.JOB as
 5684                          long as the privileges requested are granted in
 5685                          B$JIT.PRIV.AUTH.
 5686
 5687                          The M$SPRIV and M$RPRIV services set and reset
 5688                          the active privileges (B$JIT.PRIV.ACTIVE). At
 5689                          M$SPRIV the privilege bits specified on the PRIV
 5690                          parameter are turned on only if the corresponding
 5691                          bits are set in B$JIT.PRIV.JOB or B$JIT.PRIV.PRC.
 5692                          All bits specified and allowed are set in
 5693                          B$JIT.PRIV.ACTIVE. If not all specified bits are
 5694                          allowed, the bits representing privileges granted
 5695                          are set or reset, and the alternate return is then
 5696                          taken with the severity code set to 0.
 5697
 5698                          If the AUTH option is specified, then B$JIT.PRIV.AUTH is the
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           155  
 5699                          sole criterion used in determining if the request can be satisfied.
 5700
 5701                          If the PPRIV option is specified, the normal return is taken if
 5702                          all bits specified are present in B$JIT.PPRIV, or if all bits on
 5703                          in B$JIT.PRIV.PRC are also on in B$JIT.PRIV.AUTH.
 5704                          No change is made to B$JIT.PRIV.ACTIVE if PPRIV is specified.
 5705
 5706                          At M$RPRIV the privilege bits set on the PRIV
 5707                          parameter are turned off in B$JIT.PRIV.ACTIVE. If
 5708                          not all specified bits are on, the bits that were
 5709                          on are reset, and the alternate return is taken.
 5710                          The form of the call for this service is:
 5711
 5712                          CALL M$SPRIV (FPT_PRIV)[ALTRET (label)];
 5713
 5714                          or
 5715
 5716                          CALL M$RPRIV (FPT_PRIV)[ALTRET (label)];
 5717
 5718                          The parameters for the M$SPRIV and M$RPRIV
 5719                          services are as follows:                                                      */
 5720
 5721
 5722
 5723      %MACRO FPT_PRIV
 5724              (FPTN=FPT_PRIV,
 5725              PRIV='0'B,
 5726              AUTH(YES='1'B,NO='0'B)='0'B,
 5727              PPRIV(YES='1'B,NO='0'B)='0'B,
 5728              STCLASS=STATIC);
 5729
 5730      %LSET LISTDIR='0'B;
 5731      %LSET LISTEXP='1'B;
 5732      %LSET LISTCOM='0'B;
 5733      %LSET LISTSUB='1'B;
 5734      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5735      %IF (SUBSTR(STR,0,6)='STATIC') OR
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           156  
 5736       (SUBSTR(STR,0,8)='CONSTANT') OR
 5737       (SUBSTR(STR,0,3)='EXT');
 5738       %LSET INIT=CHARTEXT('INIT');
 5739      %ELSE;
 5740       %LSET INIT=CHARTEXT('/*');
 5741      %ENDIF;
 5742
 5743      DCL 1 FPTN STCLASS DALIGNED,
 5744            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5745            2 V DALIGNED,
 5746              3 PRIV# BIT(36) %INIT(PRIV)%CHARTEXT('/**/'),
 5747                          /*K* PRIV = VALUE-BIT(36) specifies the privilege bits
 5748                          to be set on or off. All zeros means that no
 5749                          change is to be made to the privilege bits.
 5750                          Default=0.   It is recommended
 5751                          that the %EQU's for the privileges contained in
 5752                          JIT be used to specify the privileges.
 5753                                                                                                     */
 5754              3 AUTH# BIT(1) %INIT(AUTH)%CHARTEXT('/**/'),
 5755                          /*K* AUTH = {YES|NO}   specifies, if YES, that
 5756                          the AUTH field from B$JIT.PRIV.AUTH is used
 5757                          to verify the operation instead of the JOB
 5758                          field.  Default=NO.                                                           */
 5759
 5760              3 PPRIV# BIT(1) %INIT(PPRIV)%CHARTEXT('/**/'),
 5761                          /*K* PPRIV = {YES|NO} specifies, if YES, that the PRIV parameter
 5762                          is compared against B$JIT.PPRIV. If PRIV is fully contained,
 5763                          or B$JIT.PRIV.PRC is fully contained, in B$JIT.PRIV.AUTH, the
 5764                          normal return is taken. No change is made to B$JIT.PRIV.ACTIVE.               */
 5765              3 * BIT(34) %INIT('0'B)%CHARTEXT('/**/');
 5766      %MEND;
 5767
 5768                          /*F* NAME: M$SSWITCH and M$RSWITCH - Pseudo Switch
 5769
 5770                          These monitor services are available to set and
 5771                          reset pseudo switches.  These switches
 5772                          allow the user to specify program options at
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           157  
 5773                          run-time. The M$SSWITCH service turns on any
 5774                          switch specified by a bit setting on the SWITCH
 5775                          parameter. The M$RSWITCH service turns off any
 5776                          switch specified by a bit setting on the SWITCH
 5777                          parameter. (These functions are also available
 5778                          through the SWITCH command.)
 5779                          ..::IX "M$RSWITCH"
 5780
 5781                          The form of the call for this service is:
 5782
 5783                          CALL M$SSWITCH (FPT_SWITCH);
 5784
 5785                          or
 5786
 5787                          CALL M$RSWITCH (FPT_SWITCH);
 5788
 5789                          No alternate return is defined for these monitor
 5790                          services.
 5791
 5792                          The parameter for these services is as follows:                               */
 5793
 5794
 5795
 5796
 5797      %MACRO FPT_SWITCH
 5798              (FPTN=FPT_SWITCH,
 5799              SWITCH='0'O,
 5800              STCLASS=STATIC);
 5801
 5802      %LSET LISTDIR='0'B;
 5803      %LSET LISTEXP='1'B;
 5804      %LSET LISTCOM='0'B;
 5805      %LSET LISTSUB='1'B;
 5806      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5807      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5808       (SUBSTR(STR,0,8)='CONSTANT') OR
 5809       (SUBSTR(STR,0,3)='EXT');
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           158  
 5810       %LSET INIT=CHARTEXT('INIT');
 5811      %ELSE;
 5812       %LSET INIT=CHARTEXT('/*');
 5813      %ENDIF;
 5814
 5815      DCL 1 FPTN STCLASS DALIGNED,
 5816            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5817            2 V DALIGNED,
 5818              3 SWITCH# BIT(36) %INIT(SWITCH)%CHARTEXT('/**/'),
 5819                          /*K* SWITCH = VALUE-BIT(36) specifies the pseudo
 5820                          switches to set or reset. All zeros means that
 5821                          no change is to be made to the pseudo switches.
 5822                          Default=0.                                                                    */
 5823              3 * BIT(36) %INIT('0'B)%CHARTEXT('/**/');
 5824      %MEND;
 5825
 5826                          /*F* NAME: M$CHGUNIT - Increment Unit Counter.
 5827
 5828                          The M$CHGUNIT service permits the user to
 5829                          increment any of eight counters, four 18-bit
 5830                          counters in B$JIT.JOBUNIT and four 18-bit counters
 5831                          in B$JIT.STEPUNIT. These counters are primarily
 5832                          intended for charging proprietary software for
 5833                          each invocation of a processor.  A step counter is
 5834                          incremented only if step accounting or processor
 5835                          accounting is in effect.
 5836                          If a counter overflows, it is set to the maximum
 5837                          value; the alternate return is then taken
 5838                          with the severity code set to 0.
 5839
 5840                          The form of the call for this service is:
 5841
 5842                          CALL M$CHGUNIT (FPT_CHGUNIT) [ALTRET (label)];
 5843
 5844                          The parameters for the M$CHGUNIT service are as
 5845                          follows:                                                                      */
 5846
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           159  
 5847
 5848
 5849      %MACRO FPT_CHGUNIT
 5850              (FPTN=FPT_CHGUNIT,
 5851              STEP(YES='1'B,NO='0'B)='1'B,
 5852              UNIT0=0,UNIT1=0,UNIT2=0,UNIT3=0,
 5853              STCLASS=STATIC);
 5854
 5855      %LSET LISTDIR='0'B;
 5856      %LSET LISTEXP='1'B;
 5857      %LSET LISTCOM='0'B;
 5858      %LSET LISTSUB='1'B;
 5859      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5860      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5861       (SUBSTR(STR,0,8)='CONSTANT') OR
 5862       (SUBSTR(STR,0,3)='EXT');
 5863       %LSET INIT=CHARTEXT('INIT');
 5864      %ELSE;
 5865       %LSET INIT=CHARTEXT('/*');
 5866      %ENDIF;
 5867
 5868      DCL 1 FPTN STCLASS DALIGNED,
 5869            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5870            2 V DALIGNED,
 5871              3 STEP# BIT(1) %INIT(STEP)%CHARTEXT('/**/'),
 5872                          /*K* STEP = {YES|NO} specifies, if yes, that the step
 5873                          counter(s) are to be incremented. NO specifies
 5874                          that the job counter(s) are to be incremented.
 5875                          Default=YES.                                                                  */
 5876              3 * BIT(35) %INIT('0'B)%CHARTEXT('/**/'),
 5877              3 UNIT0# UBIN HALF UNAL %INIT(UNIT0)%CHARTEXT('/**/'),
 5878                          /*K* UNIT0 = VALUE-DEC(0 to 2**18-1)   specifies the
 5879                          value by which to increment the first 18-bit
 5880                          counter. Default=0.                                                           */
 5881              3 UNIT1# UBIN HALF UNAL %INIT(UNIT1)%CHARTEXT('/**/'),
 5882                          /*K* UNIT1 = VALUE-DEC(0 to 2**18-1)   specifies the
 5883                          value by which to increment the second 18-bit
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           160  
 5884                          counter. Default=0.                                                           */
 5885              3 UNIT2# UBIN HALF UNAL %INIT(UNIT2)%CHARTEXT('/**/'),
 5886                          /*K* UNIT2 = VALUE-DEC(0 to 2**18-1) specifies the
 5887                          value by which to increment the third 18-bit
 5888                          counter. Default=0.                                                           */
 5889              3 UNIT3# UBIN HALF UNAL %INIT(UNIT3)%CHARTEXT('/**/'),
 5890                          /*K* UNIT3 = VALUE-DEC(0 to 2**18-1)   specifies the
 5891                          value by which to increment the fourth 18-bit
 5892                          counter. Default=0.                                                           */
 5893              3 * UBIN %INIT(0)%CHARTEXT('/**/');
 5894      %MEND;
 5895
 5896                          /*F* NAME: M$USRFIELD - Set JIT User Field.
 5897
 5898                          The M$USRFIELD service allows the user program to
 5899                          set selected values in B$JIT.USERWORD and
 5900                          B$JIT.INSTWORD. Each of these portions of the JIT
 5901                          is divided into four 18-bit entries. These
 5902                          entries are not used by the operating system and are defined by
 5903                          the installation or user.
 5904
 5905                          This service can also be used to select the
 5906                          standard or alternate set of translate tables.
 5907
 5908                          The form of the call for this service is as
 5909                          follows:
 5910
 5911                          CALL M$USRFIELD (FPT_USRFIELD);
 5912
 5913                          No alternate return is defined for this service.
 5914
 5915                          The parameters for the M$USRFIELD service are as
 5916                          follows:                                                                      */
 5917
 5918
 5919
 5920      %MACRO FPT_USRFIELD
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           161  
 5921              (FPTN=FPT_USRFIELD,
 5922              USER(YES='1'B,NO='0'B)='1'B,
 5923              STDTABLES(YES='1'B,NO='0'B)='0'B,
 5924              ALTTABLES(YES='1'B,NO='0'B)='0'B,
 5925              FIELD0=262143,FIELD1=262143,FIELD2=262143,FIELD3=262143,
 5926              STCLASS=STATIC);
 5927
 5928      %LSET LISTDIR='0'B;
 5929      %LSET LISTEXP='1'B;
 5930      %LSET LISTCOM='0'B;
 5931      %LSET LISTSUB='1'B;
 5932      %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 5933      %IF (SUBSTR(STR,0,6)='STATIC') OR
 5934       (SUBSTR(STR,0,8)='CONSTANT') OR
 5935       (SUBSTR(STR,0,3)='EXT');
 5936       %LSET INIT=CHARTEXT('INIT');
 5937      %ELSE;
 5938       %LSET INIT=CHARTEXT('/*');
 5939      %ENDIF;
 5940
 5941      DCL 1 FPTN STCLASS DALIGNED,
 5942            2 V_ BIT(72) %INIT(VECTOR(FPTN.V))%CHARTEXT('/**/'),
 5943            2 V DALIGNED,
 5944              3 USER# BIT(1) %INIT(USER)%CHARTEXT('/**/'),
 5945                          /*K* USER = {YES|NO} specifies, if yes, that values are
 5946                          to be set in B$JIT.USERWORD. NO specifies that
 5947                          values are to be set in B$JIT.INSTWORD.
 5948                          The default is YES.  If NO is specified, EXMM
 5949                          privilege must be active.
 5950                                                                                  */
 5951
 5952
 5953
 5954
 5955              3 STDTABLES# BIT(1) %INIT(STDTABLES)%CHARTEXT('/**/'),
 5956                          /*K* STDTABLES = {YES|NO} specifies, if yes, that
 5957                          the standard set of translate tables is to be
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           162  
 5958                          used.
 5959                                                                                  */
 5960
 5961              3 ALTTABLES# BIT(1) %INIT(ALTTABLES)%CHARTEXT('/**/'),
 5962                          /*K* ALTTABLES = {YES|NO} specifies, if yes, that
 5963                          the alternate set of translate tables is to be
 5964                          used.
 5965                                                                                  */
 5966
 5967              3 * BIT(33) %INIT('0'B)%CHARTEXT('/**/'),
 5968              3 FIELD0# UBIN HALF UNAL %INIT(FIELD0)%CHARTEXT('/**/'),
 5969                          /*K* FIELD0 = VALUE-DEC(0-n)
 5970                          Specifies the value
 5971                          to set into one of the four fields.  The value
 5972                          262143 specifies that the particular slot is not to
 5973                          be changed. 262143 is the default.
 5974                          .xeq
 5975                          */
 5976              3 FIELD1# UBIN HALF UNAL %INIT(FIELD1)%CHARTEXT('/**/'),
 5977                          /*K* FIELD1 = VALUE-DEC(0-n)
 5978                          .xeq UE_CP6_C M$USRFIELD FIELD0
 5979                          */
 5980              3 FIELD2# UBIN HALF UNAL %INIT(FIELD2)%CHARTEXT('/**/'),
 5981                          /*K* FIELD2 = VALUE-DEC(0-n)
 5982                          .xeq UE_CP6_C M$USRFIELD FIELD0
 5983                          */
 5984              3 FIELD3# UBIN HALF UNAL %INIT(FIELD3)%CHARTEXT('/**/'),
 5985                          /*K* FIELD3 = VALUE-DEC(0-n)
 5986                          .xeq UE_CP6_C M$USRFIELD FIELD0
 5987                          */
 5988              3 * UBIN %INIT(0)%CHARTEXT('/**/');
 5989      %MEND;
 5990
 5991                                    /****************************/
 5992                                    /*    SYSTEM  CALLS                                                 */
 5993                                    /****************************/
 5994
07:32 JUL 29 '97 UE_CP6_C.:E05SI                                           163  
 5995      DCL M$TRAP ENTRY(1) CONV(1,2,4100) ALTRET;
 5996      DCL M$STRAP ENTRY(1) CONV(1,1,4101) ALTRET;
 5997      DCL M$STIMER ENTRY(1) CONV(1,1,4096) ALTRET;
 5998      DCL M$TTIMER ENTRY(1) CONV(1,2,4102) ALTRET;
 5999      DCL M$INT ENTRY(1) CONV(1,1,4098) ALTRET;
 6000      DCL M$EVENT ENTRY(1) CONV(1,1,4097) ALTRET;
 6001      DCL M$XCON ENTRY(1) CONV(1,2,4099) ALTRET;
 6002      DCL M$SENV ENTRY CONV(1,0,4105) ALTRET;
 6003      DCL M$RENV ENTRY CONV(1,0,4110) ALTRET;
 6004      DCL M$MERC ENTRY(1) CONV(1,1,4103) ALTRET;
 6005      DCL M$MERCS ENTRY(1) CONV(1,1,4108) ALTRET;
 6006      DCL M$RETRY ENTRY(1) CONV(1,2,4104) ALTRET;
 6007      DCL M$RETRYS ENTRY(1) CONV(1,2,4109) ALTRET;
 6008      DCL M$TRTN ENTRY(1) CONV(1,3,4106) ALTRET;
 6009      DCL M$CLRSTK ENTRY(1) CONV(1,1,4107) ALTRET;
 6010      DCL M$DRTN ENTRY(1) CONV(1,5,4111) ALTRET;
 6011      DCL M$WAIT ENTRY(1) CONV(1,2,8198) ALTRET;
 6012      DCL M$SPRIV ENTRY(1) CONV(1,1,8202) ALTRET;
 6013      DCL M$RPRIV ENTRY(1) CONV(1,1,8203) ALTRET;
 6014      DCL M$SSWITCH ENTRY(1) CONV(1,1,8204) ALTRET;
 6015      DCL M$RSWITCH ENTRY(1) CONV(1,1,8205) ALTRET;
 6016      DCL M$CHGUNIT ENTRY(1) CONV(1,1,8206) ALTRET;
 6017      DCL M$USRFIELD ENTRY(1) CONV(1,1,8207) ALTRET;

