

14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          1    
    1      /*M* GF_LCP6_M   Macros for I/O Services FPTs and related structures  */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X*  MEC,MOC,EXM=20,CLM=30,CRM=100                */
    8
    9
   10                          /*P*    NAME:   GF_LCP6_M.
   11
   12                          The file GF_LCP6_M contains the macros that relate to
   13                          a variety of I/O services.
   14                          */
   15
   16
   17
   18
   19
   20
   21                          /*F* NAME:  IO Services
   22                          ..::L1 "Introduction\\X"
   23                          All I/O operations are performed by the
   24                          monitor for the user.  The user program never
   25                          directly accesses an I/O device, but rather
   26                          requests that the monitor do so.  This section
   27                          describes I/O and the I/O services provided by the
   28                          LCP-6 monitor.
   29                          ..VA$M_FOOTER "\Introduction"
   30
   31                          To request I/O, the user calls an I/O service
   32                          specifying a Function Parameter Table (FPT), which
   33                          in turn refers to a Data Control Block (DCB).  The
   34                          combination of the I/O service call, the FPT, and
   35                          the DCB provides the information that the monitor
   36                          needs to perform the requested operation.
   37                          Generally, the DCB contains the attributes and status of a
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          2    
   38                          path or device and the FPT contains the information
   39                          that is specific to the operation to be performed.
   40                          For example, for output to a line
   41                          printer, the width of a print line is one value in
   42                          the DCB while the FPT contains
   43                          the location of the buffer that is to be output to
   44                          the printer in this specific operation.
   45
   46                          Separation of information into the DCB and the FPT
   47                          allows the user to create one DCB for a destination
   48                          and reference that DCB throughout his program,
   49                          whenever I/O for that destination is required.
   50
   51                          In addition to serving as a source of
   52                          information for the monitor in performing an I/O
   53                          operation, the DCB also provides a place for the
   54                          monitor to store information while it is
   55                          performing an I/O operation.  Some of the
   56                          information stored in the DCB by the monitor may
   57                          be of use to the user, and some has meaning
   58                          only to the monitor.
   59
   60                          The user is responsible for providing the name
   61                          of a properly initialized DCB with every call to
   62                          the monitor requesting an I/O operation. The user
   63                          may obtain a DCB by
   64
   65                          1.  Specifying the DCB data type without a structure
   66                          to cause the linker to create a DCB.
   67
   68                          2.  Explicitly creating his own DCB at program
   69                          compilation time by invoking the M$DCB macro.
   70
   71                          3.  Explicitly requesting creation of a DCB at run
   72                          time by calling the M$GETDCB monitor service.
   73
   74                          The DCB contents can be set or modified in
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          3    
   75                          various ways.  The sources of values for the DCB
   76                          and the order in which they are entered
   77                          into the DCB
   78                          are as follows:
   79
   80                            o  Default parameters supplied in the M$DCB
   81                               macro or the default values supplied by
   82                               the linker or the M$GETDCB service.
   83
   84                            o  Parameters supplied at invocation of the
   85                               M$DCB macro.
   86
   87                            o  Parameters in the FPT for the M$OPEN
   88                               monitor service.
   89
   90                          The DCBs reside in the Read Only Segment which
   91                          cannot be modified directly by the user program.
   92                          The monitor services and the techniques mentioned
   93                          above are the only means for a user to modify a
   94                          DCB.
   95
   96                          When a DCB is opened the attributes of the path or
   97                          device are returned to the user in the DCB
   98                          by the monitor.  The fields in the DCB may be inspected
   99                          by the user through a based structure of a DCB.  The
  100                          M$DCB macro in the file LCP_6 may be invoked using
  101                          the 'STCLASS=BASED' option to obtain such a
  102                          structure.
  103
  104                          The user refers to a DCB by a name in the FPTs for
  105                          monitor service calls.  The monitor, however,
  106                          assigns a number to the DCB for internal use.
  107                          DCBs defined by the user are assigned numbers
  108                          starting at DCB number 10.  All DCBs for a user are
  109                          included in a DCB pointer table created by the
  110                          system. (DCBs 1 to 9 are reserved for the monitor.)
  111
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          4    
  112                          Example 1:
  113                          }   DCL M$MYDCB DCB;
  114                          }   %FPT_OPEN (FPTN=OPEN_MYDCB,DCB=M$MYDCB);
  115                          }
  116                          }   CALL M$OPEN(OPEN_MYDCB);
  117                          }
  118
  119                          Example 2:
  120                          }   DCL M$MYDCB DCB;
  121                          }   %M$DCB (DCBN=G$DCB,STCLASS=BASED);
  122                          }
  123                          }   IF DCBADDR(DCBNUM(M$MYDCB)) -> G$DCB.whatever
  124                          }       etc.
  125                          */
  126
  127
  128
  129
  130
  131                          /*F*    NAME:   M$OPEN - Open DCB
  132
  133                          The M$OPEN service allows the user to establish a path
  134                          (SESSION) with the named device or program.  This path can
  135                          then be used for communication between the two entities.
  136                          Once a path is open, services such as M$READ and M$WRITE
  137                          may be used to send and receive messages on that path.
  138
  139                          The form of the call for this service is:
  140
  141                          CALL M$OPEN (FPT_OPEN) [ALTRET (label)];
  142
  143                          Parameters for the M$OPEN service are as follows:
  144                          */
  145
  146      %MACRO FPT_OPEN (FPTN=FPT_OPEN,
  147         VECTORS=YES,
  148         NAME=NIL,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          5    
  149         ALGN=WALIGNED,
  150         WSN=NIL,
  151         ACCT=NIL,
  152        WINDOW=NIL,
  153         ACCESS=NIL,
  154         DCB=NIL,
  155         RES=' ',
  156         TAB=NIL,
  157         HDR=NIL,
  158         HMI=NIL,
  159         KEYTYPE(FLDID=1,COORD=2,MSGID=3)=0,
  160         ASN(DEVICE=1)=1,
  161         ORG(CONSEC=1,FORM=2,TERMINAL=3,UR=4,CQ=5,X364=7)=0,
  162         SCRUB(YES='1'B,NO='0'B)='0'B,
  163         DISP(DESTROY=1,KEEP=2)=1,
  164         REASSIGN(YES='1'B,NO='0'B)='0'B,
  165         SETDCB(YES='1'B,NO='0'B)='0'B,
  166         LINES=0,
  167         RECL=0,
  168         DVFC="BINASC(0)",
  169         LOGON=NIL,
  170         EVENT=0,
  171         STCLASS=STATIC);
  172
  173      %LSET LISTDIR='0'B;
  174      %LSET LISTEXP='1'B;
  175      %LSET LISTCOM='0'B;
  176      %LSET LISTSUB='1'B;
  177      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  178      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  179      %LSET INIT=CHARTEXT('INIT');
  180      %LSET EINIT=CHARTEXT('');
  181      %ELSE;
  182      %LSET INIT=CHARTEXT('/*');
  183      %LSET EINIT=CHARTEXT('*/');
  184      %ENDIF;
  185
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          6    
  186      DCL 1 FPTN STCLASS ALGN,
  187      %IF TEXTCHAR(VECTORS)='YES';
  188            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  189            2 HMI_ VECTOR %INIT(VECTOR(HMI))%EINIT,
  190                          /*K* HMI = VARIABLE is meaningful for opens to DCBs where ORG is CQ.
  191                          This vector frames an area generated by VLP_HMI, which
  192                          contains information used to allocate send and receive
  193                          circular queues.
  194                          The default causes this parameter to be ignored.
  195                          */
  196            2 LOGON_ VECTOR %INIT(VECTOR(LOGON))%EINIT,
  197                          /*K* LOGON = VARIABLE is used when RES equals 'LG'
  198                               to specify a logon string.
  199                               The default causes this parameter to be ignored.
  200                          */
  201            2 WINDOW_ VECTOR %INIT(VECTOR(WINDOW))%EINIT,
  202                          /*K* WINDOW = VARIABLE specifies a VLP_WINDOW to be used
  203                          to establish a stream.
  204                                  The default is NIL.                                                   */
  205            2 NAME_ VECTOR %INIT(VECTOR(NAME))%EINIT,
  206                          /*N* NAME =  VARIABLE.     Locates an area
  207                          containing the name of the entity to be connected to.
  208                          This area may be generated by invoking the VLP_NAME macro which is
  209                          described later in this section.
  210                          */
  211            2 WSN_ VECTOR %INIT(VECTOR(WSN))%EINIT,
  212                          /*N* WSN = VARIABLE.      Locates an area containing
  213                          a workstation name . This area may be
  214                          generated via the VLP_WSN macro which is described
  215                          later in this section.
  216                          */
  217            2 ACCT_ VECTOR %INIT(VECTOR(ACCT))%EINIT,
  218                          /*N* ACCT = VARIABLE.      Locates
  219                          an area which contains an account name.
  220                          This area may be generated via the VLP_ACCT macro.
  221                          */
  222            2 ACCESS_ VECTOR %INIT(VECTOR(ACCESS))%EINIT,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          7    
  223                          /*N* ACCESS = VARIABLE.     Locates an access
  224                          control list which contains the access permissions
  225                          for specific accounts to a shared data segment. The list can be created by
  226                          invoking the VLP_ACCESS and VLP_ATTR macros which
  227                          are described later in this section.
  228                          */
  229            2 TAB_ VECTOR %INIT(VECTOR(TAB))%EINIT,
  230                          /*K* TAB = VARIABLE locates an area
  231                          containing a horizontal tabulation definition.
  232                          This area may be generated via the VLP_TAB macro
  233                          which is described later in this section.
  234                          The default is NIL.
  235                          */
  236            2 HDR_ VECTOR %INIT(VECTOR(HDR))%EINIT,
  237                          /*K* HDR = VARIABLE locates an area containing
  238                          a printer page header definition. The area may
  239                          be generated by invoking the VLP_HDR macro which
  240                          is described later in this section.
  241                          The default is NIL.
  242                          */
  243            2 SPARE2 VECTOR %INIT(VECTOR(NIL))%EINIT,
  244            2 SPARE3 VECTOR %INIT(VECTOR(NIL))%EINIT,
  245            2 SPARE4 VECTOR %INIT(VECTOR(NIL))%EINIT,
  246      %ENDIF;                       /* End of IF VECTORS                                                */
  247            2 V,
  248              3 DCB# UBIN BYTE UNAL %INIT(DCBNUM(DCB))%EINIT,
  249                          /*K* DCB = DCBNAME specifies the name of the DCB.
  250                          This parameter is required.
  251                          */
  252
  253
  254              3 INITZ,
  255                          /*B* INITZ is not a single parameter, but includes
  256                          SCRUB and REASSIGN and defines the type of
  257                          initialization to be performed on the DCB.                                    */
  258
  259                4 %CHARTEXT('SCRUB') BIT(1) UNAL %INIT(SCRUB)%EINIT,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          8    
  260                          /*N* SCRUB = {YES|NO}. YES specifies that the DCB is
  261                          to be completely erased and then reinitialized
  262                          with default  conditions. The scrubbing of
  263                          the DCB occurs prior to the remerge of values from
  264                          the  LCP6 equivalent of the set process (if REASSIGN=YES) and prior
  265                          to the merge of parameters from this open FPT.
  266                          The default is NO.                                                            */
  267
  268                4 %CHARTEXT('REASSIGN') BIT(1) UNAL %INIT(REASSIGN)%EINIT,
  269                          /*N* REASSIGN = {YES|NO}. YES requests that the
  270                          assign/merge record (values from the equivalent of the SET
  271                          command) is to be remerged into the DCB.
  272                          Following the merge of the values from the SET
  273                          equivalent into the DCB, the parameters from the open
  274                          FPT are merged into the DCB.
  275
  276                          */
  277
  278              3 %CHARTEXT('SETDCB') BIT(1) %INIT(SETDCB)%EINIT UNAL,
  279                          /*N* SETDCB = {YES|NO}. YES specifies that the
  280                          M$OPEN process is to merge the parameters of this
  281                          open FPT into the DCB (including the SCRUB or REASSIGN
  282                          operations, if requested).  However, the
  283                          DCB is not to be opened. The default is NO.
  284                          */
  285
  286              3 * BIT(1) UNAL %INIT('0'B)%EINIT,
  287              3 %CHARTEXT('DISP') UBIN(4) UNAL %INIT(DISP)%EINIT,
  288                          /*K* DISP = {KEEP|DESTROY}
  289                          .xeq GF_LCP6_M M$CLOSE DISP
  290
  291                          The default is DESTROY.
  292                          */
  293              3 %CHARTEXT('ASN') UBIN(8) %INIT(ASN)%EINIT UNAL,
  294                          /*N* ASN = OPTION.
  295                          DEVICE is currently the only option.
  296                          The default is DEVICE.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          9    
  297                          */
  298
  299              3 %CHARTEXT('KEYTYPE') UBIN(8) UNAL %INIT(KEYTYPE)%EINIT,
  300                          /*K* KEYTYPE = {COORD|FLDID|MSGID}
  301                          specifies the key type:
  302
  303                          FLDID - The key refers to a field identifier (i.e.,
  304                          FPT_DCLFLD.ID, a byte-aligned, 2-byte value).  See
  305                          M$DCLFLD for details.
  306
  307                          COORD - The key refers to the coordinates of a field
  308                          (i.e., a byte-aligned, 2-byte structure consisting
  309                          of the line and column of the field's location).
  310
  311                          MSGID - This feature is not currently implemented.
  312
  313                          The default causes this parameter to be ignored.
  314                          */
  315
  316              3 %CHARTEXT('ORG') UBIN(8) %INIT(ORG)%EINIT UNAL,
  317                          /*K* ORG = OPTION  specifies data organization.
  318                          This parameter describes how the data to be transmitted
  319                          will be organized.
  320
  321                          .fif
  322                          CONSEC   - The I/O will be in a consecutive, record-by-record manner.
  323
  324                          CQ       - The I/O will be to/from a circular queue.
  325
  326                          FORM     - The I/O will be to a FORMS type virtual device.
  327
  328                          SE       - Not yet implemented in the FEP.
  329
  330                          TERMINAL - The I/O will be to a TERMINAL type virtual device.
  331
  332                          UR       - The I/O will be to a UNIT RECORD type virtual device.
  333
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          10   
  334                          X364     - The I/O will be to an X364 type virtual device.
  335                          .fin
  336
  337                          The default causes this parameter to be ignored.
  338                          */
  339
  340              3 %CHARTEXT('DVFC') CHAR(1) UNAL %INIT(DVFC)%EINIT,
  341                          /*K* DVFC = VALUE-CHAR(1)
  342                          specifies the default format
  343                          control character for records which have no
  344                          format control specified on the M$WRITE
  345                          request.  The default causes this parameter to be ignored.
  346                          */
  347
  348              3 %CHARTEXT('RES') CHAR(4) %INIT(RES)%EINIT UNAL,
  349                          /*K* RES = VALUE-CHAR(4)
  350                          specifies a device ('ddnn').
  351                          dd is the 2-character device mnemonic which determines the
  352                          direction the I/O may take.  At present, this may be
  353                          any of:
  354
  355                            'HO' - for communication to a host
  356
  357                            'UC' - for communication to a device
  358
  359                            'LG' - for logging on a device
  360
  361                            'NA' - for connecting to NODEADMN
  362
  363                          The 'nn' field is a stream identifier, and determines which
  364                          stream the I/O will be on.
  365
  366                          The default causes this parameter to be ignored.
  367                          */
  368                          /*N*
  369                          There will probably be certain reserved streams for things
  370                          like debugger streams, command processor streams etc.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          11   
  371                          */
  372
  373              3 %CHARTEXT('LINES') UBIN WORD %INIT(LINES)%EINIT,
  374                          /*K* LINES = VALUE-DEC(1-32768)
  375                          specifies the number of printable lines per page.
  376                          The default causes this parameter to be ignored.
  377                          */
  378
  379              3 %CHARTEXT('RECL') UBIN WORD %INIT(RECL)%EINIT UNAL,
  380                          /*K* RECL = VALUE-DEC(1-32768)
  381                          specifies the maximum data record length in bytes.
  382                          This option is meaningful only for fixed record
  383                          length formats.
  384                          Default = 0.
  385                          */
  386              3 %CHARTEXT('EVENT') SBIN WORD %INIT(EVENT)%EINIT;
  387                          /*K* EVENT = VALUE-DEC(-32768-32767)
  388                          is the event number returned on all events
  389                          associated with this DCB.
  390                          The default is 0.
  391                          */
  392
  393      %MEND;
  394
  395
  396
  397
  398                          /*F* NAME:    VLP_HMI - Handler/Monitor Interface Parameter
  399
  400                          The VLP_HMI macro may be used to generate the area framed
  401                          by the HMI vector in FPT_OPEN.  The structure generated
  402                          by this macro contains information which allows the monitor to
  403                          create the send and receive circular queues used by the Handler
  404                          Monitor Interface (HMI).
  405
  406                          The send and receive circular queues are allocated
  407                          in the user's HANDQ data segment.  Options on the
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          12   
  408                          VLP_HMI macro allow specification of word sizes for
  409                          the send circular queue, the receive circular queue
  410                          and a user context segment.  The total size must fit
  411                          into the 64K data segment.  The total size will be
  412                          rounded up to a page (256 word) boundary and any extra
  413                          words will be allocated equally to the send and
  414                          receive circular queues.
  415                          */
  416
  417                  %MACRO VLP_HMI   (FPTN=VLP_HMI,
  418                                    SCQSIZE=0,
  419                                    RCQSIZE=0,
  420                                    IO(YES='1'B,NO='0'B)='0'B,
  421                                    CTXSIZE=0,
  422                                    STCLASS=STATIC);
  423
  424       %LSET LISTDIR='0'B;
  425       %LSET LISTEXP='1'B;
  426       %LSET LISTCOM='0'B;
  427       %LSET LISTSUB='1'B;
  428      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  429      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  430      %LSET INIT=CHARTEXT('INIT');
  431      %LSET EINIT=CHARTEXT('');
  432      %ELSE;
  433      %LSET INIT=CHARTEXT('/*');
  434      %LSET EINIT=CHARTEXT('*/');
  435      %ENDIF;
  436
  437      DCL 1 FPTN STCLASS,
  438            2 %CHARTEXT('SCQSIZE') UBIN WORD %INIT(SCQSIZE)%EINIT,
  439                          /*K* SCQSIZE = VALUE-DEC(0-n)  specifies the number of words to
  440                          allocate for the send circular queue.  The default is 0.
  441                          */
  442            2 %CHARTEXT('RCQSIZE') UBIN WORD %INIT(RCQSIZE)%EINIT,
  443                          /*K* RCQSIZE = VALUE-DEC(0-n)  specifies the number of words to
  444                          allocate for the receive circular queue.  The default is 0.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          13   
  445                          */
  446            2 %CHARTEXT('CTXSIZE') UBIN WORD %INIT(CTXSIZE)%EINIT,
  447                          /*K* CTXSIZE = VALUE-DEC(0-n)  specifies the number of words to allocate for
  448                          context used by the handler associated with these queues.
  449                          The default is 0.
  450                          */
  451            2 %CHARTEXT('IO') BIT(1) UNAL %INIT(IO)%EINIT,
  452                          /*K* IO = {YES|NO} specifies whether or not actual I/O operations
  453                          will be done from these queues, and thus whether or not the
  454                          pages in the circular queue segment are to be allocated
  455                          from the I/O memory pool.
  456                          The default is NO.
  457                          */
  458            2 * BIT(15) UNAL %INIT('0'B)%EINIT;
  459      %MEND;
  460
  461                          /*F* NAME:  VLP_NAME
  462
  463                          The VLP_NAME macro may be used to generate
  464                          names (or any other entity that is in
  465                          TEXTC format).
  466                          It generates a length byte and a character
  467                          string of fixed length.  See also VLP_NAMEV.
  468                          */
  469
  470       %MACRO VLP_NAME   (FPTN=VLP_NAME,
  471                         NAME='                               ',
  472                         LEN=0,
  473                         STCLASS=STATIC);
  474
  475       %LSET LISTDIR='0'B;
  476       %LSET LISTEXP='1'B;
  477       %LSET LISTCOM='0'B;
  478       %LSET LISTSUB='1'B;
  479      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  480      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  481      %LSET INIT=CHARTEXT('INIT');
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          14   
  482      %LSET EINIT=CHARTEXT('');
  483      %ELSE;
  484      %LSET INIT=CHARTEXT('/*');
  485      %LSET EINIT=CHARTEXT('*/');
  486      %ENDIF;
  487
  488
  489      DCL 1 FPTN STCLASS,           /*      NAME DEFINITION AREA                                        */
  490            2 L UBIN(8) %INIT(SIZEC(NAME))%EINIT UNAL,
  491                          /*K* L = VALUE-DEC(0-31) specifies the number of
  492                          bytes to be provided for the NAME (31 if name not specified).
  493                          The default is 0.
  494                          */
  495
  496            2 %CHARTEXT('NAME') CHAR(LEN) %INIT(NAME)%EINIT UNAL;
  497                          /*K* NAME = VALUE-CHAR specifies a  name
  498                          in TEXTC format.  The length of the CHAR field
  499                          generated is the length of NAME (31 if NAME is
  500                          not specified).  The LEN parameter can be
  501                          specified to override the length (e.g. LEN=5).
  502                          If STCLASS=BASED is used, LEN must be specified.
  503                          See also VLP_NAMEV for a different type of based
  504                          structure.
  505                          */
  506
  507       %MEND;
  508
  509                          /*F* NAME:  VLP_NAMEV
  510
  511                          The VLP_NAMEV macro generates a based version
  512                          of the VLP_NAME macro with the length of the
  513                          character string being the value currently in
  514                          the length byte.
  515                          */
  516      %MACRO VLP_NAMEV   (FPTN=VLP_NAMEV,
  517                          STCLASS=BASED);
  518
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          15   
  519      %LSET LISTDIR='0'B;
  520      %LSET LISTEXP='1'B;
  521      %LSET LISTCOM='0'B;
  522      %LSET LISTSUB='1'B;
  523
  524      DCL 1 FPTN STCLASS,
  525            2 L  UBIN(8) UNAL,
  526            2 NAME  CHAR(FPTN.L);
  527
  528      %MEND;
  529
  530
  531                          /*F* NAME:  VLP_ACCT
  532
  533                          The VLP_ACCT macro may be used to generate
  534                          an account name.
  535                          */
  536
  537       %MACRO VLP_ACCT   (FPTN=VLP_ACCT,
  538                         ACCT=' ',
  539                         STCLASS=STATIC);
  540
  541       %LSET LISTDIR='0'B;
  542       %LSET LISTEXP='1'B;
  543       %LSET LISTCOM='0'B;
  544       %LSET LISTSUB='1'B;
  545      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  546      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  547      %LSET INIT=CHARTEXT('INIT');
  548      %LSET EINIT=CHARTEXT('');
  549      %ELSE;
  550      %LSET INIT=CHARTEXT('/*');
  551      %LSET EINIT=CHARTEXT('*/');
  552      %ENDIF;
  553
  554
  555      DCL 1 FPTN STCLASS,           /* ACCOUNT AREA                                                     */
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          16   
  556            2 %CHARTEXT('ACCT') CHAR(8) %INIT(ACCT)%EINIT;
  557                          /*K* ACCT = VALUE-CHAR(8) specifies an account name.
  558                          The VLP_ACCT macro should be
  559                          used to generate the area which is referenced in
  560                          various I/O services.
  561                          The default is blanks.
  562                          */
  563      %MEND;
  564
  565                          /*F* NAME:  VLP_ATTR
  566
  567                          The VLP_ATTR macro may be used
  568                          in conjunction with
  569                          VLP_ACCESS (below).
  570                          The VLP_ATTR macro generates
  571                          an attribute area or the head for a list.
  572                          The VLP_ATTR macro has two parameters,
  573                          the name (FPTN) for the structure and the
  574                          storage class(STCLASS).
  575
  576                          When creating an attribute area, the user invokes
  577                          the VLP_ATTR macro to generate the first two levels
  578                          of the structure, including a size field and a
  579                          field called Q.
  580
  581                          */
  582
  583
  584       %MACRO VLP_ATTR    (FPTN=VLP_ATTR,
  585                          STCLASS=STATIC);
  586
  587       %LSET LISTDIR='0'B;
  588       %LSET LISTEXP='1'B;
  589       %LSET LISTCOM='0'B;
  590       %LSET LISTSUB='1'B;
  591      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  592      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          17   
  593      %LSET INIT=CHARTEXT('INIT');
  594      %LSET EINIT=CHARTEXT('');
  595      %ELSE;
  596      %LSET INIT=CHARTEXT('/*');
  597      %LSET EINIT=CHARTEXT('*/');
  598      %ENDIF;
  599
  600      DCL 1 FPTN STCLASS,
  601            2 SIZ UBIN %INIT(SIZEW(FPTN.Q))%EINIT,
  602            2 Q,
  603       %MEND;
  604
  605
  606                          /*F* NAME:  VLP_ACCESS
  607
  608                          This macro generates one entry for
  609                          an access control list. An entry sets the access
  610                          permissions granted to a specified account. Each
  611                          permission must be explicitly specified and
  612                          implies no other permission.
  613                          The user must
  614                          separately specify read permission by
  615                          READ=YES. The VLP_ACCESS parameters are listed
  616                          below.  In LCP6 access controls will probably be
  617                          be used in conjunction with shared data segments.
  618
  619                          The access control list consists of a list
  620                          head (generated via the VLP_ATTR macro) and a
  621                          series of entries generated by invocations of the
  622                          VLP_ACCESS macro. The VLP_ACCESS macros must
  623                          immediately follow the VLP_ATTR macro. (The list size is
  624                          generated automatically.) The list name is
  625                          assigned via the VLP_ATTR macro. A name
  626                          is unnecessary for each entry generated via
  627                          VLP_ACCESS; thus a default is associated with each
  628                          entry.
  629                          To indicate the last entry,  the list must
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          18   
  630                          contain LAST=";" as the final parameter.
  631                          The storage class attribute (STCLASS) must
  632                          be the same for %VLP_ATTR and each %VLP_ACCESS
  633                          used to form an access control list.
  634
  635                          */
  636
  637       %MACRO VLP_ACCESS  (FPTN="*",
  638                        READ(YES='1'B,NO='0'B)='0'B,
  639                        WRITE(YES='1'B,NO='0'B)='0'B,
  640                        ACCT=' ',
  641                        STCLASS=STATIC,
  642                        LAST=",");
  643
  644       %LSET LISTDIR='0'B;
  645       %LSET LISTEXP='1'B;
  646       %LSET LISTCOM='0'B;
  647       %LSET LISTSUB='1'B;
  648       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  649       %IF (SUBSTR(STR,0,6)='STATIC') OR
  650       (SUBSTR(STR,0,8)='CONSTANT') OR
  651       (SUBSTR(STR,0,3)='EXT');
  652       %LSET INIT=CHARTEXT('INIT');
  653       %ELSE;
  654       %LSET INIT=CHARTEXT('/*');
  655       %ENDIF;
  656
  657              3 FPTN,
  658                4 FFLG,
  659                5 %CHARTEXT('READ ') BIT(1) %INIT(READ)%CHARTEXT('/**/') UNAL,
  660                          /*K* READ = {YES|NO}  See FFLG.READ in M$DCB for
  661                          the meaning of this flag.  This parameter is used
  662                          to initialize the field VLP_ACCESS.FFLG.READ.  The default is NO.
  663                          */
  664                5 %CHARTEXT('WRITE ') BIT(1) %INIT(WRITE)%CHARTEXT('/**/') UNAL,
  665                          /*K* WRITE = {YES|NO}  See FFLG.WRITE in M$DCB for
  666                          the meaning of this flag.  This parameter is used
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          19   
  667                          to initialize the field VLP_ACCESS.FFLG.WRITE.  The default is NO.
  668                          */
  669                5 * BIT(6) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  670                4 %CHARTEXT('ACCT ') CHAR(8) %INIT(ACCT)%CHARTEXT('/**/')LAST
  671                          /*K* ACCT = VALUE-CHAR(8)  Specifies the account
  672                          to which the permissions in VLP_ACCESS.FFLG are to be
  673                          granted.  A wildcard character '?' may be included in the
  674                          account specification.
  675                          */
  676       %MEND;
  677
  678                          /*F*   NAME:     VLP_WSN
  679
  680                          The VLP_WSN macro may be used to generate a WSN
  681                          */
  682
  683       %MACRO VLP_WSN   (FPTN=VLP_WSN,WSN=' ',STCLASS=STATIC);
  684
  685       %LSET LISTDIR='0'B;
  686       %LSET LISTEXP='1'B;
  687       %LSET LISTCOM='0'B;
  688       %LSET LISTSUB='1'B;
  689       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  690       %IF (SUBSTR(STR,0,6)='STATIC') OR
  691       (SUBSTR(STR,0,8)='CONSTANT') OR
  692       (SUBSTR(STR,0,3)='EXT');
  693       %LSET INIT=CHARTEXT('INIT');
  694       %ELSE;
  695       %LSET INIT=CHARTEXT('/*');
  696       %ENDIF;
  697
  698
  699      DCL 1 FPTN STCLASS,           /* WORK STATION NAME                                                */
  700            2 %CHARTEXT('WSN ') CHAR(8) %INIT(WSN)%CHARTEXT('/**/');
  701                          /*K* WSN = VALUE-CHAR(8)
  702                          Contains the workstation name
  703                          which is referenced by WSN in various
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          20   
  704                          I/O services.
  705                          */
  706      %MEND;
  707
  708                          /*F* NAME:  VLP_TAB - Tabulation Parameter
  709
  710                          The VLP_TAB macro generates an area
  711                          containing the horizontal tabulation definition.
  712                          Tabulation is only applicable on output to
  713                          devices.
  714                                                                             */
  715       %MACRO VLP_TAB     (FPTN=VLP_TAB,
  716                          MARGIN=0,
  717                          TABS=0,
  718                          STCLASS=STATIC);
  719
  720       %LSET LISTDIR='0'B;
  721       %LSET LISTEXP='1'B;
  722       %LSET LISTCOM='0'B;
  723       %LSET LISTSUB='1'B;
  724       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  725       %IF (SUBSTR(STR,0,6)='STATIC') OR
  726       (SUBSTR(STR,0,8)='CONSTANT') OR
  727       (SUBSTR(STR,0,3)='EXT');
  728       %LSET INIT=CHARTEXT('INIT');
  729       %ELSE;
  730       %LSET INIT=CHARTEXT('/*');
  731       %ENDIF;
  732
  733      DCL 1 FPTN STCLASS ALIGNED,
  734            2 %CHARTEXT('MARGIN ') UBIN(8) %INIT(MARGIN)%CHARTEXT('/**/') UNAL,
  735                          /*K* MARGIN = VALUE-DEC(1-255) specifies the
  736                          lefthand margin by column number.  The leftmost column
  737                          is considered to be column 1.
  738                          A record from the user's M$WRITE request
  739                          will have blanks inserted so the user's text
  740                          starts in the specified column.  The default is no indentation.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          21   
  741                          */
  742            2 %CHARTEXT('TABS(0:30) ')  UBIN(8) UNAL %INIT(TABS,0*0)%CHARTEXT('/**/');
  743                          /*K* TABS = VALUE-DEC(0-255) [,VALUE-DEC(0-255)...]   specifies
  744                          horizontal tabulation columns.
  745                          There is a maximum of 31 tabulation columns,
  746                          which must be in ascending numeric order and
  747                          separated by commas.
  748                          Records from user M$WRITE requests which
  749                          have HT (Horizontal Tab) characters in the
  750                          record will be processed as if each HT
  751                          were replaced by a string of blanks up to
  752                          the next higher horizontal tabulation
  753                          column.
  754
  755                          If MARGIN is also specified, tabulation is
  756                          displaced so that the MARGIN column on the output
  757                          medium is TABS column 1.
  758                          The default is no tabulation.  (Each HT character in an
  759                          output record is replaced by a single blank.)
  760                          */
  761       %MEND;
  762
  763                          /*F*    NAME:     VLP_HDR - Header Parameter
  764
  765                          The VLP_HDR macro generates the header area referred to
  766                          in FPT_OPEN.  This area contains information on how the
  767                          header is to be positioned on a given page.
  768                          */
  769
  770       %MACRO VLP_HDR     (FPTN=VLP_HDR,
  771                          HEADERHEIGHT=1,
  772                          INDENT=0,
  773                          RESETPAGE(YES='1'B,NO='0'B)='0'B,
  774                          COUNT=0,
  775                          TITLE=' ',
  776                          LEN=0,
  777                          STCLASS=STATIC);
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          22   
  778
  779       %LSET LISTDIR='0'B;
  780       %LSET LISTEXP='1'B;
  781       %LSET LISTCOM='0'B;
  782       %LSET LISTSUB='1'B;
  783       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
  784       %IF (SUBSTR(STR,0,6)='STATIC') OR
  785       (SUBSTR(STR,0,8)='CONSTANT') OR
  786       (SUBSTR(STR,0,3)='EXT');
  787       %LSET INIT=CHARTEXT('INIT');
  788       %ELSE;
  789       %LSET INIT=CHARTEXT('/*');
  790       %ENDIF;
  791
  792      DCL 1 FPTN STCLASS ALIGNED,
  793            2 CTL,
  794              3 * BIT(8) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  795              3 %CHARTEXT('RESETPAGE ') BIT(1) UNAL %INIT(RESETPAGE)%CHARTEXT('/**/'),
  796                          /*K* RESETPAGE = {YES|NO} specifies, if YES, that
  797                          page numbering is to be restarted at page 1. NO
  798                          specifies that no change is to be made.
  799                          The default is NO.
  800                          */
  801              3 * BIT(3) UNAL %INIT('0'B)%CHARTEXT('/**/'),
  802              3 %CHARTEXT('HEADERHEIGHT ') UBIN(4) %INIT(HEADERHEIGHT)%CHARTEXT('/**/') UNAL,
  803                          /*K* HEADERHEIGHT = VALUE-DEC(0-15)
  804                          specifies the height of the page header area.  The default
  805                          is 1 (i.e., single space after printing
  806                          title line).  The default is 1.
  807                          */
  808              3 %CHARTEXT('INDENT ') UBIN(8) %INIT(INDENT)%CHARTEXT('/**/') UNAL,
  809                          /*K* INDENT = VALUE-DEC(1-255) specifies
  810                          the column in which TITLE text is to start (see TITLE).
  811                          Lefthand column is column 1, and is the default.
  812                          */
  813              3 %CHARTEXT('COUNT ') UBIN(8) %INIT(COUNT)%CHARTEXT('/**/') UNAL,
  814                          /*K* COUNT = VALUE-DEC(1-255) specifies
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          23   
  815                          that the page number is to be printed on the TITLE
  816                          line, with its lefthand digit in the
  817                          specified column.
  818                          The default is 0 (i.e., no page numbering).
  819                          */
  820            2 TITL,
  821              3 L  UBIN(8) %INIT(SIZEC(TITLE))%CHARTEXT('/**/') UNAL,
  822              3 %CHARTEXT('TITLE ') CHAR(LEN) %INIT(TITLE)%CHARTEXT('/**/') UNAL;
  823                          /*K* TITLE = VALUE-CHAR(1-255)
  824                          specifies the text which
  825                          is to be printed as a title on the top
  826                          of every page of output for the line
  827                          printer.  This field is TEXTC.
  828                          The default is blank.
  829                          */
  830       %MEND;
  831
  832                          /*F*     NAME:   M$CLOSE - Close DCB
  833
  834                          The M$CLOSE monitor service terminates and
  835                          inhibits communication through a specified DCB
  836                          until the DCB is again opened.  Once closed,
  837                          no more messages may be sent on the path that
  838                          was established when the DCB was opened.
  839
  840                          The form of the call for this service is:
  841
  842                          CALL M$CLOSE (FPT_CLOSE) [ALTRET (label)];
  843
  844                          Parameters for the M$CLOSE service are as follows:
  845                          */
  846
  847      %MACRO FPT_CLOSE(FPTN=FPT_CLOSE,
  848        VECTORS=YES,
  849        ALGN=WALIGNED,
  850        NAME=NIL,
  851        DCB=NIL,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          24   
  852        ACCT=NIL,
  853        DISP(DESTROY=1,KEEP=2)=0,
  854        STCLASS=STATIC);
  855
  856      %LSET LISTDIR='0'B;
  857      %LSET LISTEXP='1'B;
  858      %LSET LISTCOM='0'B;
  859      %LSET LISTSUB='1'B;
  860      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  861      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  862      %LSET INIT=CHARTEXT('INIT');
  863      %LSET EINIT=CHARTEXT('');
  864      %ELSE;
  865      %LSET INIT=CHARTEXT('/*');
  866      %LSET EINIT=CHARTEXT('*/');
  867      %ENDIF;
  868
  869      DCL 1 FPTN STCLASS ALGN,
  870      %IF TEXTCHAR(VECTORS)='YES';
  871            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  872            2 NAME_ VECTOR %INIT(VECTOR(NAME))%EINIT,
  873                          /*N* NAME = VARIABLE.     Locates an area
  874                          containing the name of the entity at the other endpoint of the path.
  875                          This area may be generated by invoking the VLP_NAME macro which is
  876                          described later in this section.
  877                          */
  878            2 ACCT_ VECTOR %INIT(VECTOR(ACCT))%EINIT,
  879                          /*N* ACCT = VARIABLE.      Locates
  880                          an area which contains an account name.
  881                          This area may be generated via the VLP_ACCT macro.
  882                          */
  883            2 SPARE1 VECTOR %INIT(VECTOR(NIL))%EINIT,
  884            2 SPARE2 VECTOR %INIT(VECTOR(NIL))%EINIT,
  885      %ENDIF;                       /* End IF VECTORS                                                   */
  886            2 V,
  887              3 DCB# UBIN BYTE UNAL %INIT(DCBNUM(DCB))%EINIT,
  888                          /*K* DCB = DCBNAME specifies the name of the DCB.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          25   
  889                          This parameter is required.
  890                          */
  891              3 %CHARTEXT('DISP') UBIN BYTE UNAL %INIT(DISP)%EINIT;
  892                          /*K* DISP = {DESTROY|KEEP}
  893                          determines for DCBs open to UC streams only, whether
  894                          the stream itself is to be released when the DCB is closed.
  895
  896                          If KEEP is not specified,
  897                          the stream is released if no other DCBs are still open
  898                          to it.  If KEEP is specified, the stream (and any
  899                          associated window) will remain until a DCB is closed
  900                          without KEEP, or until the FPRG terminates.
  901                          .xeq
  902
  903                          Using DISP=KEEP corresponds roughly to using M$LDEV to create
  904                          the stream in Host programs.
  905                          */
  906      %MEND;
  907
  908      %EJECT;

14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          26   
  909                          /*F*     NAME:   M$READ - Read Data
  910
  911                          The M$READ service causes a specified data record to
  912                          be read into a user buffer in memory.  The read operation
  913                          will obtain data either from a circular queue (if the
  914                          ORG of the DCB is CQ) or from the entity on the other
  915                          end of the path (this could be a device, another LCP-6 user
  916                          or a host user).
  917
  918                          The user normally provides a buffer that is large
  919                          enough to contain the maximum length record.
  920                          If a record exceeds the buffer size,
  921                          the record is truncated and this
  922                          condition is reported as an error.  If a
  923                          record is smaller than the buffer size, the
  924                          remainder of the buffer is unchanged from its previous
  925                          contents.
  926
  927                          The service call is of the form:
  928
  929                          CALL M$READ (FPT_READ) [ALTRET(label)];
  930
  931                          The parameters for the service are as follows:
  932                          */
  933
  934
  935       %MACRO FPT_READ  (FPTN=FPT_READ,
  936              VECTORS=YES,
  937              BUF=NIL,
  938              KEY=NIL,
  939                CG = NIL,
  940              DCB=NIL,
  941              PAGHDNTYP(DCB=0,SESSION=1)=0,
  942              RRR(YES='1'B,NO='0'B)='0'B,
  943              NODAT(YES='1'B,NO='0'B)='0'B,
  944              WAIT(YES='1'B,NO='0'B)='1'B,
  945              BRKABLE(YES='1'B,NO='0'B)='0'B,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          27   
  946              READMLT(YES='1'B,NO='0'B)='0'B,
  947              KEYS(YES='1'B,NO='0'B)='0'B,
  948              KEYR(YES='1'B,NO='0'B)='0'B,
  949              EVENT=0,
  950              REREAD(YES='1'B,NO='0'B)='0'B,
  951              BIN(YES='1'B,NO='0'B)='0'B,
  952              TRANS(YES='1'B,NO='0'B)='0'B,
  953              KEYTYPE(FLDID=1,COORD=2,MSGID=3)=0,
  954              ALGN=WALIGNED,
  955              STCLASS=STATIC);
  956
  957       %LSET LISTDIR='0'B;
  958       %LSET LISTEXP='1'B;
  959       %LSET LISTCOM='0'B;
  960       %LSET LISTSUB='1'B;
  961      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
  962      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
  963      %LSET INIT=CHARTEXT('INIT');
  964      %LSET EINIT=CHARTEXT('');
  965      %ELSE;
  966      %LSET INIT=CHARTEXT('/*');
  967      %LSET EINIT=CHARTEXT('*/');
  968      %ENDIF;
  969
  970
  971      DCL 1 FPTN STCLASS ALGN,
  972      %IF TEXTCHAR(VECTORS)='YES';
  973            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
  974            2 KEY_ VECTOR %INIT(VECTOR(KEY))%EINIT,
  975                          /*K* KEY = VARIABLE locates an optional area containing one of the following:
  976
  977                               The field-id of a field
  978
  979                               The coordinates of a field
  980
  981                               The message-id of a message
  982
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          28   
  983                          The default is NIL.
  984                          */
  985            2 BUF_ VECTOR %INIT(VECTOR(BUF))%EINIT,
  986                          /*K* BUF = VARIABLE locates the buffer into which the users
  987                          data is to be read.
  988                          The default is NIL.
  989                          */
  990            2 CG_ VECTOR %INIT(VECTOR(CG))%EINIT,
  991                          /*K* CG = VARIABLE locates the VLP_CG structure
  992                          for this read.
  993                          The default is NIL.
  994                          */
  995            2 SPARE2 VECTOR %INIT(VECTOR(NIL))%EINIT,
  996      %ENDIF;                       /* End IF VECTORS                                                   */
  997
  998            2 V,
  999              3 DCB# UBIN(8) UNAL %INIT(DCBNUM(DCB))%EINIT,
 1000                          /*K* DCB = DCBNAME specifies the name of the DCB.
 1001                          This parameter is required.
 1002                          */
 1003
 1004              3 %CHARTEXT('KEYS') BIT(1) %INIT(KEYS)%EINIT UNAL,
 1005                          /*K* KEYS = {YES|NO} specifies, if YES, that
 1006                          the user has specified in KEY the key of the
 1007                          field or message that is to be read.  If NO is
 1008                          specified, the next sequential
 1009                          record is read.
 1010                          For FORM access, specifying the key on M$READ with
 1011                          KEYS=YES indicates the field at which to initially
 1012                          position the cursor.
 1013                          The default is NO.
 1014                          */
 1015
 1016              3 %CHARTEXT('KEYR') BIT(1) %INIT(KEYR)%EINIT UNAL,
 1017                          /*K* KEYR = {YES|NO} specifies, if YES, that the key of the
 1018                          record  read is to be returned to the user in the
 1019                          buffer described  by KEY.  The default is NO.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          29   
 1020                          */
 1021              3 %CHARTEXT('WAIT') BIT(1) %INIT(WAIT)%EINIT UNAL,
 1022                          /*K* WAIT = {YES|NO} specifies, if NO, that the user
 1023                          program should not wait for I/O completion before
 1024                          continuing execution.  The default is YES.
 1025                          */
 1026              3 %CHARTEXT('BRKABLE') BIT(1) %INIT(BRKABLE)%EINIT UNAL,
 1027                          /*K* BRKABLE = {YES|NO} specifies that a read is
 1028                          able to take the ALTRETurn when a user event is
 1029                          reported.  This is only effective when the
 1030                          monitor does an internal read.  The default is NO.
 1031                          */
 1032              3 * BIT(1) UNAL %INIT('0'B)%EINIT,
 1033              3 %CHARTEXT('READMLT') BIT(1) UNAL %INIT(READMLT)%EINIT,
 1034                          /*K* READMLT = {YES|NO} specifies, if YES, that the
 1035                          CP-6 virtual-device application protocol data is to
 1036                          be returned directly to the user's buffer without
 1037                          decoding.  This facility is provided to streamline the
 1038                          acceptance of multiple fields through a DCB opened
 1039                          with ORG=FORM.  The user program must be capable of
 1040                          decoding the protocol itself, of course.  Only ARS in
 1041                          DCB is meaningful after M$READ with READMLT=YES, and
 1042                          indicates the total number of bytes of protocol returned.
 1043                          Only complete fields (DAT VDOs) are returned, so the
 1044                          program should continue to issue M$READs until the
 1045                          last VDO indicates the completion error-code.
 1046                          The minimum buffer size is 128 bytes if READMLT=YES.                          */
 1047              3 * BIT(1) UNAL %INIT('0'B)%EINIT,
 1048
 1049              3 %CHARTEXT('EVENT') SBIN %INIT(EVENT)%EINIT,
 1050                          /*K* EVENT = VALUE-DEC(-32768-32767)
 1051                          specifies, if non-zero, an event number
 1052                          to be reported to this user when this
 1053                          operation completes.  If zero is specified, no event
 1054                          is reported.
 1055
 1056                          If EVENT is non-zero, the
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          30   
 1057                          event procedure established by M$EVENT is given
 1058                          control at completion of the read operation
 1059                          whether an error occurred or not.  If an event
 1060                          control procedure is not established at the time
 1061                          the I/O completes, the user is aborted.
 1062
 1063                          The default is 0.
 1064                          */
 1065              3 DVBYTE,
 1066                          /*B* DVBYTE. (Usually set at lower level BIT(8).
 1067                          specifies information controlling the method of
 1068                          reading the record.
 1069                          */
 1070                4 * BIT(1) UNAL %INIT('0'B)%EINIT,
 1071                4 %CHARTEXT('REREAD') BIT(1) UNAL %INIT(REREAD)%EINIT,
 1072                          /*K* REREAD = {YES|NO} applies to input originating
 1073                          from a time-sharing terminal.  REREAD=YES
 1074                          specifies that the last input line is to be
 1075                          echoed and set to be the current input line.  The
 1076                          line to be echoed is either the last line typed
 1077                          by a time-sharing user or the line referenced
 1078                          via a call to the M$SINPUT monitor service.
 1079                          The FPT field name for this parameter is
 1080                          FPT_READ.V.DVBYTE.REREAD.
 1081                          The default is NO.
 1082                          */
 1083                4 %CHARTEXT('BIN') BIT(1) UNAL %INIT(BIN)%EINIT,
 1084                          /*N* BIN = {YES|NO} specifies, if YES, that the data
 1085                          is present on the media as a string of bits
 1086                          rather than one character per byte.
 1087                          The FPT field name
 1088                          for this parameter is FPT_READ.V.DVBYTE.BIN.
 1089                          The default is NO.                                                            */
 1090                4 %CHARTEXT('TRANS') BIT(1) UNAL %INIT(TRANS)%EINIT,
 1091                          /*K* TRANS = {YES|NO} specifies transparency, if YES,
 1092                          i.e., that data is to be
 1093                          placed in the user buffer without translation.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          31   
 1094                          This option is useful primarily for devices which
 1095                          normally perform translation (for instance,
 1096                          time-sharing terminals). The FPT field name for this
 1097                          parameter is FPT_READ.V.DVBYTE.TRANS. The default is NO.                      */
 1098                4 %CHARTEXT('RRR') BIT(1) UNAL %INIT(RRR)%EINIT,
 1099                          /*K* RRR = {YES|NO} specifies, if YES, that after the data
 1100                          associated with this request has been transmitted,
 1101                          an acknowledgement should be sent.  The default is NO.
 1102                          */
 1103                4 %CHARTEXT('NODAT') BIT(1) UNAL %INIT(NODAT)%EINIT,
 1104                          /*K* NODAT = {YES|NO} specifies the action the monitor
 1105                          is to take if there is no data available.
 1106                          If NO, the monitor should wait until data is
 1107                          available; if YES, the monitor should return immediately
 1108                          to the user.  The NODAT option can be used to prevent
 1109                          being suspended waiting for I/O.
 1110                          The default is NO.
 1111                          */
 1112                4 %CHARTEXT('PAGHDNTYP') UBIN(1) UNAL %INIT(PAGHDNTYP)%EINIT,
 1113                          /*N* PAGHDNTYP = {DCB | SESSION}.
 1114                          DCB means use the heading
 1115                          specified in the DCB.  SESSION says use the heading
 1116                          associated with the session.
 1117                          */
 1118                4 %CHARTEXT('CONT') BIT(1) UNAL %INIT('0'B)%EINIT,
 1119                          /*N* CONT = {YES|NO}. Specifies a continuation read.
 1120                          The FPT field name for this parameter is
 1121                          FPT_READ.V.DVBYTE.CONT. The default is NO.                                    */
 1122              3 %CHARTEXT('KEYTYPE') UBIN BYTE UNAL %INIT(KEYTYPE)%EINIT;
 1123                          /*K* KEYTYPE = {COORD|FLDID|MSGID}
 1124                          .XEQ GF_LCP6_M M$OPEN KEYTYPE
 1125                          */
 1126      %MEND;
 1127
 1128
 1129                          /*F*     NAME:   M$WRITE - Write Data
 1130
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          32   
 1131                           The M$WRITE service
 1132                           causes a data record stored in a buffer in memory to
 1133                           be written. The M$WRITE service is used for all types
 1134                           of devices for which output is appropriate, as well as
 1135                           to send messages between communicating entities
 1136                           such as two LCP-6 users or an LCP-6 user and a host user.
 1137
 1138                           M$WRITE provides options comparable to the options
 1139                           available on the M$READ service. In addition, M$WRITE
 1140                           can accommodate format options particular to output:
 1141
 1142                           o The system normally removes trailing blanks from
 1143                             unit record and TERMINAL record output.   BP
 1144                             allows the user to retain trailing blanks in such
 1145                             output.
 1146
 1147                           o VFC specifies where the vertical format control
 1148                             information is to be obtained for this write:  in
 1149                             the first byte of the buffer or from the DCB.
 1150
 1151                           If M$WRITE specifies a closed DCB, the monitor
 1152                           attempts the M$OPEN service. If the open procedure is
 1153                           successful, the write is then performed.
 1154
 1155                           If an error occurs, the alternate return
 1156                           is taken with an error code reported. The error code
 1157                           reflects the first bit set in the DCB TYC field, if the
 1158                           write operation was actually started. The user may
 1159                           perform further tests on the DCB TYC field in the
 1160                           alternate return code sequence.
 1161                           The   user may also specify
 1162                           EVENT to cause a procedure to be called when the I/O
 1163                           completes.
 1164
 1165                           The service call is of the form:
 1166
 1167                           CALL M$WRITE (FPT_WRITE) [ALTRET (label)];
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          33   
 1168
 1169                           The parameters for the services are as follows:
 1170                           */
 1171
 1172       %MACRO FPT_WRITE  (FPTN=FPT_WRITE,
 1173              VECTORS=YES,
 1174              BUF=NIL,
 1175              KEY=NIL,
 1176               CG=NIL,
 1177              DCB=NIL,
 1178              PAGHDNTYP(DCB=0,SESSION=1)=0,
 1179              RRR(YES='1'B,NO='0'B)='0'B,
 1180              NODAT(YES='1'B,NO='0'B)='0'B,
 1181              EVENT=0,
 1182              BIN(YES='1'B,NO='0'B)='0'B,
 1183              VFC(YES='1'B,NO='0'B)='0'B,
 1184              TRANS(YES='1'B,NO='0'B)='0'B,
 1185              BP(YES='1'B,NO='0'B)='0'B,
 1186              EOM(YES='1'B,NO='0'B)='0'B,
 1187              EOMCHAR=' ',
 1188              KEYTYPE(FLDID=1,COORD=2,MSGID=3)=0,
 1189              ALGN=WALIGNED,
 1190              STCLASS=STATIC);
 1191
 1192       %LSET LISTDIR='0'B;
 1193       %LSET LISTEXP='1'B;
 1194       %LSET LISTCOM='0'B;
 1195       %LSET LISTSUB='1'B;
 1196      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1197      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1198      %LSET INIT=CHARTEXT('INIT');
 1199      %LSET EINIT=CHARTEXT('');
 1200      %ELSE;
 1201      %LSET INIT=CHARTEXT('/*');
 1202      %LSET EINIT=CHARTEXT('*/');
 1203      %ENDIF;
 1204
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          34   
 1205
 1206      DCL 1 FPTN STCLASS ALGN,
 1207      %IF TEXTCHAR(VECTORS)='YES';
 1208            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1209            2 KEY_ VECTOR %INIT(VECTOR(KEY))%EINIT,
 1210                          /*K* KEY = VARIABLE locates an optional area
 1211                          containing one of the following:
 1212
 1213                               .XEQ GF_LCP6_M M$READ KEY
 1214                          */
 1215            2 BUF_ VECTOR %INIT(VECTOR(BUF))%EINIT,
 1216                          /*K* BUF = VARIABLE locates the buffer from which the
 1217                               data is to be written.
 1218                               The default is NIL.
 1219                          */
 1220            2 CG_ VECTOR %INIT(VECTOR(CG))%EINIT,
 1221                          /*K* CG = VARIABLE locates the VLP_CG structure for
 1222                          this write.
 1223                          The default is NIL.
 1224                          */
 1225            2 SPARE2 VECTOR %INIT(VECTOR(NIL))%EINIT,
 1226      %ENDIF;                       /* End IF VECTORS                                                   */
 1227
 1228            2 V,
 1229              3 DCB# UBIN(8) UNAL %INIT(DCBNUM(DCB))%EINIT,
 1230                          /*K* DCB = DCBNAME specifies the name of the DCB.
 1231                          This parameter is required.
 1232                          */
 1233              3 %CHARTEXT('EOM') BIT(1) %INIT(EOM)%EINIT,
 1234                          /*K* EOM = {YES|NO}  specifies, if YES, that EOMCHAR contains
 1235                          the activation character to be reported with the data
 1236                          being transmitted with this M$WRITE.  EOM is ignored for
 1237                          DCBs open to the terminal (RES=UCnn).  EOM overrides VFC
 1238                          if both are specified, but the first buffer character
 1239                          is then ignored.
 1240
 1241                          The default is NO.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          35   
 1242                          */
 1243              3 %CHARTEXT('KEYTYPE') UBIN(7) UNAL %INIT(KEYTYPE)%EINIT,
 1244                          /*K* KEYTYPE = {COORD|FLDID|MSGID}
 1245                          .XEQ GF_LCP6_M M$OPEN KEYTYPE
 1246                          */
 1247
 1248              3 %CHARTEXT('EVENT') SBIN %INIT(EVENT)%EINIT,
 1249                          /*K* EVENT = VALUE-DEC(-32768-32767)
 1250                          specifies, if non-zero, that an event number
 1251                          to be reported to this user when this
 1252                          operation completes.  If zero is specified, no event
 1253                          is reported.
 1254
 1255                          If EVENT is non-zero, the
 1256                          event procedure established by M$EVENT is given
 1257                          control at completion of this operation
 1258                          whether  an error occurred or not.  If an event
 1259                          control procedure is not established at the time
 1260                          the I/O completes, the user is aborted.
 1261
 1262                          The default is 0.
 1263                          */
 1264              3 DVBYTE,
 1265                          /*B* DVBYTE. (Usually set at lower level BIT(9).
 1266                          specifies information controlling the method of
 1267                          reading the record.
 1268                          */
 1269                4 %CHARTEXT('BP') BIT(1) UNAL %INIT(BP)%EINIT,
 1270                          /*K* BP = {YES|NO} specifies blank preservation.
 1271                          YES specifies that trailing blanks are not to
 1272                          be removed.
 1273                          NO specifies that blank stripping is to be performed.
 1274                          The default is NO.
 1275                          */
 1276                4 %CHARTEXT('VFC') BIT(1) UNAL %INIT(VFC)%EINIT,
 1277                          /*K* VFC = {YES|NO}
 1278                          specifies, if YES, that the first character of the
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          36   
 1279                          record is to be interpreted as a vertical format
 1280                          character.
 1281                          Refer to the CP-6 Programmer Reference Manual for
 1282                          a list of VFC codes in the appendix 'Device
 1283                          Format Control Characters'.
 1284                          The default is NO.
 1285                          */
 1286                4 %CHARTEXT('BIN') BIT(1) UNAL %INIT(BIN)%EINIT,
 1287                          /*N* BIN = {YES|NO}.  YES specifies that the data
 1288                          is present on the media as a string of bits
 1289                          rather than one character per byte.
 1290                          The FPT field name
 1291                          for this parameter is FPT_WRITE.V.DVBYTE.BIN.
 1292                          The default is NO.                                                            */
 1293                4 %CHARTEXT('TRANS') BIT(1) UNAL %INIT(TRANS)%EINIT,
 1294                          /*K* TRANS = {YES|NO} specifies transparency, if YES,
 1295                          i.e., that data is to be written
 1296                          without translation.
 1297                          This option is useful primarily for  devices which
 1298                          normally perform translation (for instance,
 1299                          time-sharing terminals). The FPT field name for this
 1300                          parameter is FPT_WRITE.V.DVBYTE.TRANS. The default is NO.                     */
 1301                4 %CHARTEXT('RRR') BIT(1) UNAL %INIT(RRR)%EINIT,
 1302                          /*K* RRR = {YES|NO} specifies, if YES, that after the data
 1303                          associated with this request has been transmitted,
 1304                          an acknowledgement should be sent.
 1305                          The default is NO.
 1306                          */
 1307                4 %CHARTEXT('NODAT') BIT(1) UNAL %INIT(NODAT)%EINIT,
 1308                          /*K* NODAT = {YES|NO} if YES, specifies that the
 1309                          alternate return is to be taken if
 1310                          the distant end point has not done a read.
 1311                          The default is NO.
 1312                          */
 1313                4 %CHARTEXT('PAGHDNTYP') UBIN(1) UNAL %INIT(PAGHDNTYP)%EINIT,
 1314                          /*N* PAGHDNTYP = {DCB | SESSION}.
 1315                          .XEQ GF_LCP6_M M$READ PAGHDNTYP
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          37   
 1316                          */
 1317                4 %CHARTEXT('CONT') BIT(1) UNAL %INIT('0'B)%EINIT,
 1318                          /*N* CONT = {YES|NO}. Specifies a continuation writes.
 1319                          The FPT field name for this parameter is
 1320                          FPT_WRITE.V.DVBYTE.CONT. The default is NO.
 1321                          */
 1322              3 %CHARTEXT('EOMCHAR') CHAR(1) %INIT(EOMCHAR)%EINIT;
 1323                          /*K* EOMCHAR = VALUE-CHAR(1)  specifies, if EOM is YES,
 1324                          and the DCB is open with RES other than UCnn, the character
 1325                          to be reported as EOM_CHAR along with the data for this
 1326                          M$WRITE.  If EOM is NO, %EOM_EOR is reported instead.
 1327                          The default is blank.
 1328                          */
 1329      %MEND;
 1330
 1331                          /*F*  NAME:    M$WRTMLT - Write Multiple
 1332
 1333                          The M$WRTMLT service is used for two purposes:  to
 1334                          write blocks of data to the terminal if
 1335                          ORG=FORM, or to scan the handler circular
 1336                          queue if ORG=CQ.  This service is currently
 1337                          reserved for use by the system only.
 1338
 1339                          The format of the call for this service is:
 1340
 1341                          CALL M$WRTMLT (FPT_WRTMLT) [ALTRET(label)];
 1342
 1343                          Parameters for the M$WRTMLT service are as follows:
 1344
 1345                          */
 1346
 1347                          /*N* WRTMLT.
 1348                          The M$WRTMLT service has two purposes:
 1349
 1350                          2). The M$WRTMLT service allows the user to combine several
 1351                          logical I/O operations into a single larger operation
 1352                          for the sake of efficiency.  The vector passed by the
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          38   
 1353                          user frames a buffer which contains several FPTs
 1354                          combined into a single larger FPT.  It is assumed
 1355                          that this service will be issued mostly by the I/O
 1356                          library which understands how to build these special FPTS.
 1357
 1358                          Not all monitor services may be placed into
 1359                          this buffer.  The FPTs for the following services
 1360                          are allowed:
 1361                          }
 1362                          } M$DEVICE
 1363                          } M$WRITE
 1364                          } M$DCLFLD
 1365                          } M$MDFFLD
 1366                          } M$SLCFLD
 1367                          } M$RLSFLD
 1368                          } M$ERASE
 1369                          }
 1370                          */
 1371      %MACRO FPT_WRTMLT (FPTN=FPT_WRTMLT,
 1372         VECTORS=YES,
 1373         ALGN=WALIGNED,
 1374         BUF=NIL,
 1375         DCB=NIL,
 1376         STCLASS=STATIC);
 1377
 1378      %LSET LISTDIR='0'B;
 1379      %LSET LISTEXP='1'B;
 1380      %LSET LISTCOM='0'B;
 1381      %LSET LISTSUB='1'B;
 1382      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1383      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1384      %LSET INIT=CHARTEXT('INIT');
 1385      %LSET EINIT=CHARTEXT('');
 1386      %ELSE;
 1387      %LSET INIT=CHARTEXT('/*');
 1388      %LSET EINIT=CHARTEXT('*/');
 1389      %ENDIF;
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          39   
 1390      %EJECT;

14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          40   
 1391
 1392      DCL 1 FPTN STCLASS ALGN,
 1393      %IF TEXTCHAR(VECTORS)='YES';
 1394            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1395            2 BUF_ VECTOR %INIT(VECTOR(BUF))%EINIT,
 1396                          /*K* BUF = VARIABLE locates the buffer from which the
 1397                               data is to be written.
 1398                               The default is NIL.
 1399                          */
 1400            2 SPARE1 VECTOR %INIT(VECTOR(NIL))%EINIT,
 1401            2 SPARE2 VECTOR %INIT(VECTOR(NIL))%EINIT,
 1402      %ENDIF;                       /* End IF VECTORS                                                   */
 1403
 1404            2 V,
 1405              3 DCB# UBIN(8) UNAL %INIT(DCBNUM(DCB))%EINIT,
 1406                          /*K* DCB = DCBNAME specifies the name of the DCB.
 1407                          This parameter is required.
 1408                          */
 1409              3 * BIT(7) UNAL %INIT('0'B)%EINIT;
 1410
 1411      %MEND;
 1412
 1413                          /*F* NAME:    M$DCB - Data Control Block
 1414
 1415                          A Data Control Block (DCB) is a context area, readable
 1416                          by the user and maintained by the monitor, which contains
 1417                          information pertaining to I/O operations to or from
 1418                          some entity.  This entity may be a cooperating host
 1419                          program, a communications device, or the circular queue.
 1420
 1421                          The M$DCB macro may be used to generate a DCB or
 1422                          a BASED structure for a DCB.
 1423
 1424                          The name of the DCB is to be specified using the
 1425                          DCBN=dcbname option.
 1426
 1427                          The STCLASS specification determines if storage is
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          41   
 1428                          to be generated.  Specification of STCLASS=DCB
 1429                          will cause a DCB to be generated for inclusion in
 1430                          the Read Only Segment.
 1431                          STCLASS=BASED will generate a BASED structure that
 1432                          may be used to inspect any DCB within the Read
 1433                          Only Segment.
 1434
 1435                          When STCLASS=DCB is specified, certain of the
 1436                          fields within the DCB may be initialized.  The
 1437                          options for initialization are listed with the
 1438                          description of the field.  Other fields within
 1439                          the DCB are set by the monitor to reflect the
 1440                          results of an I/O operation through the DCB; no
 1441                          initialization parameters are provided.
 1442
 1443                          Fields within a DCB that may be initialized are as follows:
 1444                          */
 1445      %MACRO M$DCB (DCBN=DCBNAME,
 1446          STCLASS=DCB,
 1447          LVL=1,
 1448          FULL(YES=1,NO=0,ANY)=1,
 1449          LAST(YES=";",NO=",",ANY)=";",
 1450          NAME=' ',
 1451          ACCT=' ',
 1452          WSN=' ',
 1453          RES=' ',
 1454          ASN(DEVICE=1)=1,
 1455          ORG(CONSEC=1,FORM=2,TERMINAL=3,UR=4,CQ=5,X364=7)=0,
 1456          LINES=0,
 1457          RECL=0,
 1458          DVFC="BINASC(0)",
 1459          SHARE=0,
 1460          FUN=0,
 1461          DISP(DESTROY=1,KEEP=2)=1,
 1462          STRM=0,
 1463          KEYTYPE=0);
 1464
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          42   
 1465      %LSET LISTDIR='0'B;
 1466      %LSET LISTEXP='1'B;
 1467      %LSET LISTCOM='0'B;
 1468      %LSET LISTSUB='1'B;
 1469      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1470      %IF (STR='STA') OR (STR='CON') OR (STR='EXT') OR STR='DCB';
 1471      %LSET INIT=CHARTEXT('INIT');
 1472      %LSET EINIT=CHARTEXT('');
 1473      %LSET NAME_LEN=0;
 1474      %ELSE;
 1475      %LSET INIT=CHARTEXT('/*');
 1476      %LSET EINIT=CHARTEXT('*/');
 1477      %IF LVL=1;
 1478      %LSET NAME_LEN=CHARTEXT(CONCAT(TEXTCHAR(DCBN),'.DCBNAME.L'));
 1479      %ELSE;
 1480      %LSET NAME_LEN=LENGTH(TEXTCHAR(DCBN));
 1481      %ENDIF;
 1482      %ENDIF;
 1483
 1484      %IF LVL=1;
 1485      DCL 1 DCBN STCLASS WALIGNED,
 1486      %ELSE;
 1487              %LVL DCBN,
 1488      %ENDIF;
 1489                %(LVL+1) ARS UBIN %INIT(0)%EINIT,
 1490                          /*K*  ARS - UBIN   contains the actual record size read (in bytes).
 1491                          */
 1492                %(LVL+1) TYC UNAL,
 1493                          /*K*  TYC.  The Type Completion field is set upon
 1494                          completion of an I/O operation through the DCB:
 1495                          */
 1496                %(LVL+2) LD# UNAL BIT(1) %INIT('0'B)%EINIT,
 1497                          /*K*  TYC.LD# - BIT(1)  set if Lost Data on an M$READ.
 1498                          */
 1499                %(LVL+2) * UNAL BIT(15) %INIT('0'B)%EINIT,
 1500                          /*N* We need to fill this out a little.
 1501                          */
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          43   
 1502                %(LVL+1) DVBYTE,
 1503                          /*K*  DVBYTE.  DVBYTE is set in the DCB following reads and
 1504                          informs the user about the nature of the record read.
 1505                          */
 1506                %(LVL+2) BP BIT(1) UNAL %INIT('0'B)%EINIT,
 1507                          /*K*  DVBYTE.BP - BIT(1)  specifies blank preservation.
 1508                          If set trailing blanks were not removed.
 1509                          Reset specifies that blank stripping was performed.
 1510                          */
 1511                %(LVL+2) VFC BIT(1) UNAL %INIT('0'B)%EINIT,
 1512                          /*K*  DVBYTE.VFC - BIT(1)   set if the first character of the
 1513                          record should be interpreted as a VFC character.
 1514                          */
 1515                %(LVL+2) BIN BIT(1) UNAL %INIT('0'B)%EINIT,
 1516                          /*K*  DVBYTE.BIN - BIT(1)  specifies that the data
 1517                          is present as a string of bits
 1518                          rather than one character per byte.
 1519                          */
 1520                %(LVL+2) TRANS BIT(1) UNAL %INIT('0'B)%EINIT,
 1521                          /*K*  DVBYTE.TRANS - BIT(1)  specifies that the data was
 1522                          placed in the user buffer  without translation.
 1523                          */
 1524                %(LVL+2) RRR BIT(1) UNAL %INIT('0'B)%EINIT,
 1525                          /*N* DVBYTE.RRR - BIT(1).
 1526                          */
 1527                %(LVL+2) NODAT BIT(1) UNAL %INIT('0'B)%EINIT,
 1528                          /*N* DVBYTE.NODAT - BIT(1).
 1529                          */
 1530                %(LVL+2) DCBHDR BIT(1) UNAL %INIT('0'B)%EINIT,
 1531                          /*N* DVBYTE.DCBHDR - BIT(1).
 1532                          */
 1533                %(LVL+2) CONT BIT(1) UNAL %INIT('0'B)%EINIT,
 1534                          /*N* DVBYTE.CONT - BIT(1).
 1535                          */
 1536                %(LVL+1) %CHARTEXT('STRM') UBIN BYTE CALIGNED %INIT(STRM)%EINIT,
 1537                          /*N* STRM = VALUE-DEC(1-255) indicates the stream
 1538                          with which this DCB is associated.
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          44   
 1539                          */
 1540                %(LVL+1) FFLG,
 1541                          /*K*  FFLG   contains a collection of access control
 1542                          flags set when the DCB is opened.
 1543                          These flags control the I/O  that may be performed
 1544                          via this DCB.
 1545                          */
 1546                %(LVL+2) READ BIT(1) UNAL %INIT('0'B)%EINIT,
 1547                          /*K*  FFLG.READ - BIT(1)  if set, records may be read.
 1548                          */
 1549                %(LVL+2) WRITE BIT(1) UNAL %INIT('0'B)%EINIT,
 1550                          /*K*  FFLG.WRITE - BIT(1)  if set, records may be written.
 1551                          */
 1552                %(LVL+2) * BIT(6) UNAL %INIT('0'B)%EINIT,
 1553                %(LVL+1) DDEV,
 1554                          /*N* DDEV.  Contains a collection of flags set by M$OPEN.
 1555                          */
 1556                %(LVL+2) LP BIT(1) UNAL %INIT('0'B)%EINIT,
 1557                          /*N* DDEV.LP - BIT(1).  If set, this DCB has line printer
 1558                          characteristics; vertical format control applies.
 1559                          */
 1560                %(LVL+2) CP BIT(1) UNAL %INIT('0'B)%EINIT,
 1561                          /*N* DDEV.CP - BIT(1).  If set, this DCB has card punch
 1562                          characteristics; card sequencing may be meaningfully
 1563                          specified.
 1564                          */
 1565                %(LVL+2) IC BIT(1) UNAL %INIT('0'B)%EINIT,
 1566                          /*N* DDEV.IC - BIT(1).  If set, this DCB has interactive
 1567                          terminal characteristics, in the sense that input is
 1568                          already displayed.
 1569                          */
 1570                %(LVL+2) UCOUT BIT(1) UNAL %INIT('0'B)%EINIT,
 1571                          /*N* DDEV.UCOUT - BIT(1).  If set, output written through
 1572                          this DCB is being written to the user's interactive
 1573                          terminal.
 1574                          */
 1575                %(LVL+2) CG BIT(1) UNAL %INIT('0'B)%EINIT,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          45   
 1576                          /*N* DDEV.CG - BIT(1).  Set if this DCB is connected to a
 1577                          host comgroup.
 1578                          */
 1579                %(LVL+2) %CHARTEXT('RES') UBIN(3) UNAL %INIT(0)%EINIT,
 1580                          /*N* DDEV.RES - UBIN(3).
 1581                          Contains a numeric representation of M$DCB.RESNT.TYP.
 1582                          See G_DDEV_RES_n in file G_LCP6_E.
 1583                          */
 1584
 1585                %(LVL+1) WIDTH UBIN WORD %INIT(0)%EINIT,
 1586                          /*K*  WIDTH - UBIN   set to the number of columns on a
 1587                          printable line or card. The value is zero if WIDTH
 1588                          is meaningless for this device.
 1589                          */
 1590                %(LVL+1) %CHARTEXT('NAME'),
 1591                %(LVL+2) L UBIN(8) UNAL %INIT(SIZEC(NAME))%EINIT,
 1592                %(LVL+2) C CHAR(31) UNAL %INIT(NAME)%EINIT,
 1593                          /*N* NAME = TEXTC(31).  Contains the name
 1594                          of the entity associated with this DCB.
 1595
 1596                          This field may be initialized using the
 1597                          NAME option.  Default = ' '.
 1598                          */
 1599
 1600                %(LVL+1) %CHARTEXT('ACCT') CHAR(8) UNAL %INIT(ACCT)%EINIT,
 1601                          /*N* ACCT - CHAR(8).  Contains the account.
 1602
 1603                          This field may be initialized using the
 1604                          ACCT option.  Default = ' '.
 1605                          */
 1606
 1607                %(LVL+1) %CHARTEXT('RES') CHAR(4) UNAL %INIT(RES)%EINIT,
 1608                %(LVL+1) RESNT REDEF %CHARTEXT('RES') UNAL,
 1609                %(LVL+2) TYP CHAR(2) UNAL,
 1610                %(LVL+2) NUM CHAR(2) UNAL,
 1611                          /*K* RES = VALUE-CHAR(4)
 1612                          .XEQ GF_LCP6_M M$OPEN RES
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          46   
 1613
 1614                           A listing of additional fields in the DCB
 1615                           follows.  These fields are not set via parameters
 1616                           for M$DCB but are available for access by users.
 1617                          */
 1618                %(LVL+1) %CHARTEXT('WSN') CHAR(8) ALIGNED %INIT(WSN)%EINIT,
 1619                          /*N* WSN - CHAR(8).  Contains the work station name.
 1620
 1621                          This field may be initialized using the
 1622                          WSN option.  The default is blanks.
 1623                          */
 1624
 1625                %(LVL+1) FCI BIT(1) UNAL %INIT('0'B)%EINIT,
 1626                          /*K*  FCI - BIT(1)   set if the DCB was ever successfully opened.
 1627                          */
 1628                %(LVL+1) FCD BIT(1) UNAL %INIT('0'B)%EINIT,
 1629                          /*K*  FCD - BIT(1)   set if the DCB is currently open.
 1630                          */
 1631
 1632                %(LVL+1) %CHARTEXT('SHARE') UBIN(2) UNAL %INIT(SHARE)%EINIT,
 1633                          /*N* SHARE  - BIT(1).
 1634                          Set if the entity associated with this DCB may be
 1635                          shared.
 1636
 1637                          This field may be initialized by the SHARE option
 1638                          of M$DCB.  Default = 0.
 1639                          */
 1640
 1641                %(LVL+1) %CHARTEXT('DISP') UBIN(4) UNAL %INIT(DISP)%EINIT,
 1642                          /*K* DISP = {KEEP|DESTROY}
 1643                          .xeq GF_LCP6_M M$CLOSE DISP
 1644
 1645                          The default is DESTROY.
 1646                          */
 1647
 1648                %(LVL+1) %CHARTEXT('ORG') UBIN(8) UNAL %INIT(ORG)%EINIT,
 1649                          /*K* ORG = {CONSEC|CQ|FORM|TERMINAL|SE|UR|X364}
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          47   
 1650                          specifies data organization.
 1651                          .XEQ GF_LCP6_M M$OPEN ORG
 1652                          */
 1653
 1654                %(LVL+1) %CHARTEXT('FUN') UBIN(4) UNAL %INIT(FUN)%EINIT,
 1655                          /*N* FUN = VALUE-DEC(0-n).
 1656                          */
 1657                %(LVL+1) %CHARTEXT('ASN') UBIN(4) UNAL %INIT(ASN)%EINIT,
 1658                          /*N* ASN = VALUE-DEC(0-n).
 1659                          .XEQ GF_LCP6_M M$OPEN ASN
 1660
 1661                          */
 1662
 1663                %(LVL+1) DCB# UBIN BYTE UNAL %INIT(DCBNUM(DCBN))%EINIT,
 1664                          /*K*  DCB# - UBIN BYTE   contains the number of this DCB.
 1665                          */
 1666                %(LVL+1) FLDID UBIN WORD UNAL %INIT(RECL)%EINIT,
 1667                          /*K* RECL = VALUE-DEC(0-32768)
 1668                          .XEQ GF_LCP6_M M$OPEN RECL
 1669                          This word is REDEFed as FLDID for DCBs open ORG=FORM.
 1670                          */
 1671                %(LVL+1) %CHARTEXT('RECL') REDEF FLDID UBIN WORD,
 1672                          /*K*  FLDID - UBIN
 1673                          contains the field ID reported by
 1674                          the most recent operation for an ORG=FORM
 1675                          DCB.  It is the same as that returned in KEY if
 1676                          KEYTYPE=FLDID, but is always returned here.  This is
 1677                          particularly useful for operations like M$DCLFLD that
 1678                          that ALTRET but have no provision for returning a key.
 1679                          This word is a REDEF of RECL.
 1680                          */
 1681                %(LVL+1) EOMCHAR CHAR(2) %INIT('A@')%EINIT,
 1682                %(LVL+1) EOMVAL REDEF EOMCHAR UNAL,
 1683                %(LVL+2) VALUE UBIN(8) UNAL,
 1684                %(LVL+2) * BIT(1) UNAL,
 1685                %(LVL+2) VFLG BIT(1) UNAL,
 1686                %(LVL+2) * BIT(6) UNAL,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          48   
 1687                %(LVL+1) VFC REDEF EOMCHAR CHAR(2) UNAL,
 1688                          /*K*  EOMCHAR - CHAR(2)  when a read is done to a terminal,
 1689                          EOMCHAR is filled in with the activation character
 1690                          or the VFC character if DVBYTE.VFC is set.
 1691                          If there is no activating character or the read is
 1692                          not to a terminal and doesn't have VFC, EOMCHAR is
 1693                          set to G_EOM_EOR# ('A@').
 1694                          */
 1695                %(LVL+1) %CHARTEXT('LINES') UBIN WORD UNAL %INIT(LINES)%EINIT,
 1696                          /*K* LINES = VALUE-DEC(0-32768)
 1697                          .XEQ GF_LCP6_M M$OPEN LINES
 1698                          */
 1699                %(LVL+1) %CHARTEXT('KEYTYPE') UBIN(8) UNAL %INIT(KEYTYPE)%EINIT,
 1700                          /*K* KEYTYPE = {COORD|FLDID|MSGID}
 1701                          .XEQ GF_LCP6_M M$OPEN KEYTYPE
 1702                          */
 1703                %(LVL+1) %CHARTEXT('DVFC') CHAR(1) UNAL %INIT(DVFC)%EINIT,
 1704                          /*K* DVFC = VALUE-CHAR(1)
 1705                          .XEQ GF_LCP6_M M$OPEN DVFC
 1706                          */
 1707                %(LVL+1) EVENT SBIN %INIT(0)%EINIT,
 1708                          /*K* EVENT - SBIN  contains the event to be reported
 1709                           when there is a COMIO event to pass to the user.
 1710                          */
 1711                %(LVL+1) HEADER$ PTR %INIT(ADDR(NIL))%EINIT,
 1712                          /*N*  HEADER$ - PTR   points to a VLP_HDR elsewhere
 1713                          in the Read Only Segment that contains header information
 1714                          for a unit record device.  The information is
 1715                          provided by the HDR option of M$OPEN.
 1716                          */
 1717                %(LVL+1) TAB$ PTR %INIT(ADDR(NIL))%EINIT,
 1718                          /*N*  TAB$ - PTR   points to a VLP_TAB elsewhere
 1719                          in the Read Only Segment that describes TAB settings
 1720                          for a UR or TERMINAL DCB.  The information is
 1721                          provided by the TAB option of M$OPEN.
 1722                          */
 1723                %(LVL+1) HMI$ PTR %INIT(ADDR(NIL))%EINIT,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          49   
 1724                          /*K*  HMI$ - PTR   points to an area containing header information
 1725                          in a handler's circular queue.  The information is
 1726                          provided by the HMI option of M$OPEN.
 1727                          */
 1728                %(LVL+1) LDCTX UBIN %INIT(0)%EINIT,
 1729                          /*K*  LDCTX - VALUE-DEC(0-?)
 1730                          contains an index into the LDCT table for
 1731                          the LDCT associated with this connection.
 1732                          */
 1733                %(LVL+1) RLCID ,
 1734                %(LVL+2) NODE UBIN BYTE UNAL %INIT(0)%EINIT,
 1735                          /*K*  RLCID.NODE - VALUE-DEC(8)   contains the node number of the
 1736                                                     remote connection.
 1737                          */
 1738                %(LVL+2) GENERATION UBIN BYTE UNAL %INIT(0)%EINIT,
 1739                          /*K*  RLCID.GENERATION - VALUE-DEC(8)   contains the generation of the
 1740                                                          remote connection.
 1741                          */
 1742                %(LVL+2) LDCTX UBIN WORD UNAL %INIT(0)%EINIT,
 1743                          /*K*  RLCID.LDCTX - VALUE-DEC(16)   contains the LDCT number on
 1744                                                       the remote node.
 1745                          */
 1746                %(LVL+1) ACTPOS SBIN %INIT(0)%EINIT,
 1747                          /*K*  ACTPOS - VALUE-DEC(0-32767)  indicates the position
 1748                          in the input record at which activation occurred.
 1749                          The first character of the record is at position one.
 1750                          A value of zero means that activation occurred at the
 1751                          the end of the record.
 1752                          */
 1753      %IF FULL=0;
 1754                %(LVL+1) SSN$ PTR %INIT(ADDR(NIL))%EINIT LAST
 1755      %ELSE;
 1756                %(LVL+1) SSN$ PTR %INIT(ADDR(NIL))%EINIT,
 1757                          /*K*  SSN$ - is a pointer to the session context
 1758                          with which this DCB is communicating.
 1759                          */
 1760                %(LVL+1) DCBNAME,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          50   
 1761                %(LVL+2) L UBIN(8) %INIT(%LENGTH(TEXTCHAR(DCBN)))%EINIT UNAL,
 1762                %(LVL+2) %CHARTEXT('NAME') CHAR(%NAME_LEN) %INIT(%TEXTCHAR(DCBN))%EINIT UNAL LAST
 1763      %ENDIF;
 1764                          /*K*  DCBNAME   contains the name of the DCB in
 1765                          TEXTC format:
 1766                          */
 1767
 1768                          /*K*  DCBNAME.L - contains the length of DCBNAME.NAME
 1769                          */
 1770
 1771                          /*K*  DCBNAME.NAME - contains the text and is initialized
 1772                                             with 'dcbname' from the DCBN option.
 1773                          */
 1774                          /*K* DCB = DCBNAME specifies the name of the DCB.
 1775                          This parameter is required.
 1776                          */
 1777
 1778      %MEND;
 1779
 1780
 1781
 1782                          /*F* NAME: M$GETDCB - Build Data Control Block
 1783
 1784                          The M$GETDCB service allocates a DCB.  The M$GETDCB
 1785                          service returns the DCB number for the DCB which
 1786                          is built. If a DCB of the name specified already
 1787                          exists, its DCB number is returned as if it had
 1788                          been built.
 1789
 1790                          The M$GETDCB service call is of the form:
 1791
 1792                          CALL M$GETDCB (FPT_GETDCB) [ALTRET (label)];
 1793
 1794                          The parameters for this service are as follows:                               */
 1795       %MACRO FPT_GETDCB (FPTN=FPT_GETDCB,
 1796              DCBNAME=NIL,
 1797              DCBNUM=NIL,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          51   
 1798              DCB#=0,
 1799              STCLASS=STATIC,
 1800              ALGN=WALIGNED,
 1801              VECTORS(YES='1'B,NO='0'B)='1'B,
 1802              MERGE(YES='1'B,NO='0'B)='0'B);
 1803
 1804      %LSET LISTDIR='0'B;
 1805      %LSET LISTEXP='1'B;
 1806      %LSET LISTCOM='0'B;
 1807      %LSET LISTSUB='1'B;
 1808      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1809      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1810      %LSET INIT=CHARTEXT('INIT');
 1811      %LSET EINIT=CHARTEXT('');
 1812      %ELSE;
 1813      %LSET INIT=CHARTEXT('/*');
 1814      %LSET EINIT=CHARTEXT('*/');
 1815      %ENDIF;
 1816
 1817
 1818      DCL 1 FPTN STCLASS ALGN,
 1819      %IF VECTORS;
 1820            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1821            2 DCBNAME_ VECTOR %INIT(VECTOR(DCBNAME))%EINIT,
 1822                          /*K* DCBNAME = VARIABLE locates a VLP_NAME area
 1823                          containing the name of the DCB to be obtained.
 1824                          The default is NIL.
 1825                          */
 1826            2 DCBNUM_ VECTOR %INIT(VECTOR(DCBNUM))%EINIT,
 1827                          /*K* DCBNUM = VARIABLE  locates a 1-word
 1828                          area into which the M$GETDCB service returns the number of the
 1829                          DCB allocated, or if the DCB already exists, the
 1830                          number corresponding to DCBNAME.  The default is NIL.
 1831                          */
 1832      %ENDIF;
 1833            2 V ALIGNED,
 1834              3 %CHARTEXT('DCB# ') UBIN BYTE %INIT(DCB#)%EINIT,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          52   
 1835                          /*N* DCB = VALUE-DEC(5-9) is used to request
 1836                          the allocation of a system DCB (5-9) by special shared
 1837                          processors only.
 1838                          */
 1839              3 %CHARTEXT('MERGE') BIT(1) UNAL %INIT(MERGE)%EINIT,
 1840                          /*N* MERGE = {YES|NO} specifies, if YES, that any assignment
 1841                          (!SET command) for this DCB is to be merged into it if it
 1842                          is created.  The default is NO.
 1843                          */
 1844              3 * BIT(24) UNAL %INIT('0'B)%EINIT;
 1845          %MEND;
 1846
 1847
 1848                          /*F* NAME: M$RELDCB - Release Data Control Block
 1849
 1850                          This service releases a DCB's Read Only Segment
 1851                          space and deletes the DCB from the DCB pointer
 1852                          table. Any user DCB may be released, regardless
 1853                          of how it was obtained. However, a DCB must be
 1854                          closed before M$RELDCB is called. Once released,
 1855                          the DCB and its DCB number are invalid for monitor
 1856                          service calls.
 1857
 1858                          The service call is of the form:
 1859
 1860                          CALL M$RELDCB (FPT_RELDCB) [ALTRET (label)];
 1861
 1862                          The parameter for the service is as follows:
 1863
 1864                          */
 1865       %MACRO FPT_RELDCB (FPTN=FPT_RELDCB,
 1866                          ALGN=WALIGNED,
 1867                          VECTORS(YES='1'B,NO='0'B)='1'B,
 1868                          STCLASS=STATIC,
 1869                          DCB=0);
 1870
 1871      %LSET LISTDIR='0'B;
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          53   
 1872      %LSET LISTEXP='1'B;
 1873      %LSET LISTCOM='0'B;
 1874      %LSET LISTSUB='1'B;
 1875      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1876      %IF (STR='STA') OR (STR='CON') OR STR='EXT';
 1877      %LSET INIT=CHARTEXT('INIT');
 1878      %LSET EINIT=CHARTEXT('');
 1879      %ELSE;
 1880      %LSET INIT=CHARTEXT('/*');
 1881      %LSET EINIT=CHARTEXT('*/');
 1882      %ENDIF;
 1883
 1884
 1885      DCL 1 FPTN STCLASS ALGN,
 1886      %IF VECTORS;
 1887            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1888      %ENDIF;
 1889            2 V ALGN,
 1890              3 DCB# UBIN BYTE %INIT(DCB)%EINIT,
 1891                          /*K* DCB = VALUE-DEC(5-?) specifies the number
 1892                          of the DCB to be released.
 1893
 1894                          System DCBs (1-4)
 1895                          may not be released.  Only special processors may
 1896                          release special DCBs (5-9).  Others
 1897                          may be released as desired.  A DCB need not have
 1898                          been defined via a GETDCB in order to be released.
 1899                          The DCB must be closed in order for it to be released.
 1900
 1901                          This parameter is required.
 1902                          */
 1903              3 * BIT(24) %INIT('0'B)%EINIT;
 1904      %MEND;
 1905
 1906
 1907                          /*F* NAME: M$DEVICE - Change Device Attributes
 1908
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          54   
 1909                          The M$DEVICE service allows modification
 1910                          of formatting attributes while output is being created.
 1911                          A number of the
 1912                          options available on M$DEVICE override options which
 1913                          can be specified by M$DCB or M$OPEN.
 1914
 1915                          The M$DEVICE service is appropriate for unit record
 1916                          data; the DCB may be associated with a resource device
 1917                          or a logical device.
 1918
 1919                          The service call is of the form:
 1920
 1921                          CALL M$DEVICE (FPT_DEVICE) [ALTRET (label)];
 1922
 1923                          The parameters for the call are as follows:
 1924                          */
 1925       %MACRO FPT_DEVICE (FPTN=FPT_DEVICE,
 1926              STCLASS=STATIC,
 1927              ALGN=WALIGNED,
 1928              VECTORS(YES='1'B,NO='0'B)='1'B,
 1929              DCB=NIL,
 1930              TAB=NIL,
 1931              HDR=NIL,
 1932              SEQ(YES='1'B,NO='0'B)='01'B,
 1933              PAGE(YES='1'B,NO='0'B)='0'B,
 1934              SEQCOL=73,
 1935              SEQID=' ',
 1936              LINES=0,
 1937              DVFC="BINASC(0)");
 1938
 1939      /*!* V Y */
 1940      %LSET L6=BITBIN(MODE_FEP);
 1941      %LSET LISTDIR='0'B;
 1942      %LSET LISTEXP='1'B;
 1943      %LSET S#=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
 1944      %LSET S#=2*BITBIN (S#='STA' OR S#='CON' OR S#='EXT');
 1945      %LSET FIL3=CHARTEXT (CONCAT (SUBSTR ('3 * BIT(1)INIT(''0''B)',0,(1-L6)*(10+S#*5)),SUBSTR (',',L6)));
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          55   
 1946      %LSET ALG=TEXTCHAR(ALGN);
 1947      %IF ALG = '';
 1948       %LSET ALG=CONCAT(SUBSTR('D',L6),'ALIGNED');
 1949      %ENDIF;
 1950      %LSET ALG=CHARTEXT(ALG);
 1951      /*!* V N */
 1952      %LSET LISTCOM='0'B;
 1953      %LSET LISTSUB='1'B;
 1954      %LSET INIT=CHARTEXT (SUBSTR ('/*INIT',S#,2+S#));
 1955      %LSET EINIT=CHARTEXT (SUBSTR ('*/',S#));
 1956      %LSET L6#=SUBSTR('#',L6);
 1957
 1958
 1959
 1960      DCL 1 FPTN STCLASS ALGN,
 1961      %IF VECTORS;
 1962            2 V_ VECTOR %INIT(VECTOR(FPTN.V))%EINIT,
 1963            2 TAB_ VECTOR %INIT(VECTOR(TAB))%EINIT,
 1964                          /*K* TAB = VARIABLE locates an area that contains the
 1965                          settings for horizontal tabulation.  This area
 1966                          may be generated by invoking the VLP_TAB macro.
 1967                          Tabulation may be discontinued by specifying
 1968                          the VLP_TAB macro parameter TAB=ERASE.
 1969
 1970                           The default is NIL.
 1971                           */
 1972            2 HDR_ VECTOR %INIT(VECTOR(HDR))%EINIT,
 1973                          /*K* HDR = VARIABLE locates an area containing the
 1974                          page header definition.  This area may be
 1975                          generated by invoking the VLP_HDR macro.  Page
 1976                          headings may be discontinued by specifying
 1977                          the VLP_HDR macro parameter HDR=ERASE.
 1978
 1979                           The default is NIL.
 1980                           */
 1981      %ENDIF;
 1982            2 V %ALG,
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          56   
 1983              3 DCB# UBIN(%(18-L6*10)) UNAL %INIT(DCBNUM(DCB))%EINIT,
 1984                          /*K* DCB = DCBNAME specifies the name of the DCB.
 1985                          This parameter is required.
 1986                          */
 1987              %FIL3
 1988              3 %CHARTEXT(CONCAT('SEQ',L6#)) BIT(2) UNAL %INIT(SEQ)%EINIT,
 1989                          /*N* SEQ = {YES|NO}.
 1990                          */
 1991              3 %CHARTEXT(CONCAT('PAGE',L6#)) BIT(1) UNAL %INIT(PAGE)%EINIT,
 1992                          /*K* PAGE = {YES|NO} specifies, if YES, that the rest
 1993                          of the current page is to be left blank.
 1994                          The default is NO.
 1995                          */
 1996              3 * BIT(5) UNAL %INIT('0'B)%EINIT,
 1997              3 %CHARTEXT(CONCAT('SEQCOL',L6#)) UBIN BYTE UNAL %INIT(SEQCOL)%EINIT,
 1998                          /*N* SEQCOL = VALUE-DEC(1-255).
 1999                          */
 2000              3 %CHARTEXT(CONCAT('SEQID',L6#)) CHAR(4) UNAL %INIT(SEQID)%EINIT,
 2001                          /*N* SEQID = VALUE-CHAR(4).
 2002                          */
 2003              3 %CHARTEXT(CONCAT('DVFC',L6#)) CHAR(1) UNAL %INIT(DVFC)%EINIT,
 2004                          /*K* DVFC = VALUE-CHAR(1)
 2005                          .XEQ GF_LCP6_M M$OPEN DVFC
 2006                          */
 2007              3 * UBIN BYTE UNAL %INIT(0)%EINIT,
 2008              3 %CHARTEXT(CONCAT('LINES',L6#)) UBIN(%(18-L6*10)) UNAL %INIT(LINES)%EINIT,
 2009                          /*K* LINES = VALUE-DEC(1-32768)
 2010                          .XEQ GF_LCP6_M M$OPEN LINES
 2011                          */
 2012
 2013              3 * UBIN UNAL %INIT(0)%EINIT;
 2014
 2015
 2016      %MEND;
 2017
 2018
 2019
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          57   
 2020                          /*F* NAME:  VLP_CG - Comgroup Message Parameter
 2021
 2022                          The VLP_CG macro generates an area used
 2023                          at reads and writes to comgroups (in the host) to describe
 2024                          a message being read or written.
 2025                          */
 2026
 2027      %MACRO VLP_CG (FPTN=VLP_CG,
 2028              STATION    = ' ',
 2029              MSGTYP     = ' ',
 2030              LVL=1,
 2031              LAST=";",
 2032              STCLASS    =STATIC);
 2033
 2034       %LSET LISTDIR='0'B;
 2035       %LSET LISTEXP='1'B;
 2036       %LSET LISTCOM='0'B;
 2037       %LSET LISTSUB='1'B;
 2038       %LSET STR=CONCAT(TEXTCHAR(STCLASS),'        ');
 2039       %IF (SUBSTR(STR,0,6)='STATIC') OR
 2040       (SUBSTR(STR,0,8)='CONSTANT') OR
 2041       (SUBSTR(STR,0,3)='EXT');
 2042       %LSET INIT=CHARTEXT('INIT');
 2043       %ELSE;
 2044       %LSET INIT=CHARTEXT('/*');
 2045       %ENDIF;
 2046
 2047                                    /*!* VP Y                                                           */
 2048       %IF LVL=1;
 2049      DCL 1 FPTN STCLASS ALIGNED,
 2050       %ELSE;
 2051              %LVL FPTN ALIGNED,
 2052       %ENDIF;
 2053                                    /*!* VP N                                                           */
 2054
 2055                %(LVL+1) STATION# CHAR(8) %INIT(STATION)%CHARTEXT('/**/'),
 2056                          /*K* STATION = VALUE-CHAR(8) specifies the name
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          58   
 2057                          of the station being addressed.  STATION may be wild carded
 2058                          by using '?' as the last non-blank character.
 2059                          In this case, any station with the matching first
 2060                          'n' characters up to the '?' is valid.
 2061
 2062                          On M$READ,
 2063                          exactly '?' or blanks means any station is valid.
 2064
 2065                          On M$WRITE, specifies the station to which the
 2066                          message is to be delivered.
 2067                           
 2068                          Note that when STATION is wild carded, only
 2069                          stations currently extant in the comgroup may
 2070                          be addressed; new stations are never created
 2071                          by this type of write operation.
 2072
 2073                          The default is blanks.                                                        */
 2074
 2075                %(LVL+1) MSGTYP# CHAR(8) %INIT(MSGTYP)%CHARTEXT('/**/'),
 2076                          /*K* MSGTYP = VALUE-CHAR(8) specifies the message
 2077                          type being processed.  MSGTYP may be wild carded as
 2078                          in STATION.
 2079
 2080                          On M$READ, MSGTYP specifies the
 2081                          legal message type(s) that may be read.  Specifying
 2082                          '?' only or blanks means that any type is legal.
 2083
 2084                          On M$WRITE, MSGTYP sets the message type of the message
 2085                          being written.
 2086
 2087                          The default is blanks.                                                        */
 2088
 2089                %(LVL+1) CTL,
 2090                %(LVL+2) * BIT(16) UNAL %INIT('0'B)%CHARTEXT('/**/'),
 2091
 2092                %(LVL+1) MSGID# UBIN (32) %INIT(0)%CHARTEXT('/**/'),
 2093                          /*K* MSGID = VALUE-DEC(1-?) is the system generated
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          59   
 2094                          ID of a message.
 2095
 2096                          */
 2097
 2098                %(LVL+1) * UBIN %INIT(0)%CHARTEXT('/**/')LAST
 2099
 2100      %MEND;
 2101
 2102
 2103
 2104                          /*P*      NAME:     GF_MCL_E
 2105
 2106                          The GF_MCL_E macro generates the specific values for
 2107                          the individual monitor service requests within the
 2108                          GF functional code group.
 2109                          */
 2110
 2111      %MACRO GF_MCL_E;
 2112      %EQU G_MCL_OPEN# = %G_FCG_F#*64 + 0;
 2113      %EQU G_MCL_CLOSE# = %G_FCG_F#*64 + 1;
 2114      %EQU G_MCL_READ# = %G_FCG_F#*64 + 2;
 2115      %EQU G_MCL_WRITE# = %G_FCG_F#*64 + 3;
 2116      %EQU G_MCL_WRTMLT# = %G_FCG_F#*64 + 4;
 2117      %EQU G_MCL_GETDCB#=%G_FCG_F#*64+5;
 2118      %EQU G_MCL_RELDCB#=%G_FCG_F#*64+6;
 2119      %EQU G_MCL_DEVICE#=%G_FCG_F#*64+7;
 2120      %MEND;
 2121
 2122                          /*P*      NAME: GF$ENTS
 2123
 2124                          The GF$ENTS macro generates the entry declarations for
 2125                          the monitor services belonging to the GF functional
 2126                          code group.
 2127                          */
 2128
 2129      %MACRO GF$ENTS;
 2130      DCL M$OPEN ENTRY(1) CONV(1,13,%G_MCL_OPEN#) ALTRET;
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          60   
 2131      DCL M$CLOSE ENTRY(1) CONV(1,5,%G_MCL_CLOSE#) ALTRET;
 2132      DCL M$READ ENTRY(1) CONV(1,5,%G_MCL_READ#) ALTRET;
 2133      DCL M$WRITE ENTRY(1) CONV(1,5,%G_MCL_WRITE#) ALTRET;
 2134      DCL M$WRTMLT ENTRY(1) CONV(1,4,%G_MCL_WRTMLT#) ALTRET;
 2135      DCL M$GETDCB ENTRY(1) CONV(1,3,%G_MCL_GETDCB#) ALTRET;
 2136      DCL M$RELDCB ENTRY(1) CONV(1,1,%G_MCL_RELDCB#) ALTRET;
 2137      DCL M$DEVICE ENTRY(1) CONV(1,3,%G_MCL_DEVICE#) ALTRET;
 2138      %MEND;
 2139
 2140                          /*P*      NAME:   GF_FPTS
 2141
 2142                          The GF_FPTS macro provides the LCP-6 monitor services
 2143                          decoder with the information required to build the
 2144                          segment descriptors and pointers for each FPT within the
 2145                          GF functional code group.
 2146                          */
 2147
 2148      %MACRO GF_FPTS (FPTN=GF_FPTS);
 2149
 2150      /* Generate the FCG_GF header word */
 2151      %GUD_FCG_INFO(FPTN=FPTN,C=%G_MCL_DEVICE#,HAND=GFM$MCL);
 2152
 2153      /* Generate the data for FPT_OPEN*/
 2154      %GUD_MCL_INFO(C=%G_MCL_OPEN#,V=13);
 2155      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=15); /* V_*/
 2156      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=WD,BND=5); /* HMI_*/
 2157      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY,BND=0); /* LOGON_*/
 2158      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY,BND=31); /* WINDOW_*/
 2159      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY); /* NAME_*/
 2160      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=WD); /* WSN_*/
 2161      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=WD); /* ACCT_*/
 2162      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY); /* ACCESS_*/
 2163      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=WD); /* HDR_*/
 2164      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* HDR_*/
 2165      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE2_*/
 2166      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE3_*/
 2167      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE4_*/
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          61   
 2168
 2169      /* Generate the data for FPT_CLOSE*/
 2170      %GUD_MCL_INFO(C=%G_MCL_CLOSE#,V=5);
 2171      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=1); /* V_*/
 2172      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY); /* NAME_*/
 2173      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY); /* ACCT_*/
 2174      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE1_*/
 2175      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE2_*/
 2176
 2177      /* Generate the data for FPT_READ*/
 2178      %GUD_MCL_INFO(C=%G_MCL_READ#,V=5);
 2179      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=5); /* V_*/
 2180      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY,BND=1); /* KEY_*/
 2181      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=BPAR,ALIGN=BY,BND=0); /* BUF_*/
 2182      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=WD,BND=23); /* CG_*/
 2183      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* Spare*/
 2184
 2185      /* Generate the data for FPT_WRITE*/
 2186      %GUD_MCL_INFO(C=%G_MCL_WRITE#,V=5);
 2187      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=5); /* V_*/
 2188      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY,BND=1); /* KEY_*/
 2189      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=BPAR,ALIGN=BY,BND=0); /* BUF_*/
 2190      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=WD,BND=23); /* CG_*/
 2191      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY); /* SPARE*/
 2192
 2193      /* Generate the data for FPT_WRTMLT*/
 2194      %GUD_MCL_INFO(C=%G_MCL_WRTMLT#,V=4);
 2195      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=WD,BND=1); /* V_*/
 2196      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY,BND=1); /* BUF_*/
 2197      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY,BND=1); /* SPARE1_*/
 2198      %GUD_VECT_INFO(MAND=NO,WRT=YES,TYP=LPAR,ALIGN=BY,BND=1); /* SPARE2_*/
 2199
 2200      /* Generate the data for FPT_GETDCB*/
 2201      %GUD_MCL_INFO(C=%G_MCL_GETDCB#,V=3);
 2202      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=5); /* V_*/
 2203      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=BY); /* DCBNAME_*/
 2204      %GUD_VECT_INFO(MAND=YES,WRT=YES,TYP=LPAR,ALIGN=WD,BND=1); /* DCBNUM_*/
14:33 JUL 28 '97 GF_LCP6_M.:E05SI                                          62   
 2205
 2206      /* Generate the data for FPT_RELDCB*/
 2207      %GUD_MCL_INFO(C=%G_MCL_RELDCB#,V=1);
 2208      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=5); /* V_*/
 2209
 2210      /* Generate the data for FPT_DEVICE*/
 2211      %GUD_MCL_INFO(C=%G_MCL_DEVICE#,V=3);
 2212      %GUD_VECT_INFO(MAND=YES,WRT=NO,TYP=LPAR,ALIGN=WD,BND=11); /* V_*/
 2213      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=LPAR,ALIGN=BY); /* TAB_*/
 2214      %GUD_VECT_INFO(MAND=NO,WRT=NO,TYP=BPAR,ALIGN=BY,BND=5); /* HDR_*/
 2215      %MEND;
 2216
 2217
 2218
 2219                          /*P*    NAME:     GF$HANDLERS
 2220
 2221                          The GF$HANDLERS macro generates the ENTRY declarations
 2222                          for the GF MCL handlers.
 2223                          */
 2224
 2225      %MACRO GF$HANDLERS;
 2226      DCL GFM$MCL ENTRY(1);
 2227      %MEND;

