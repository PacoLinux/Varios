

14:54 JUL 28 '97 KV$INT.:E05SI                                             1    
    1      /*M* KV$INT VDH internal structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*F* NAME: KV$EDTWND.  Saved edit-window structure. */
    9
   10
   11      %MACRO KV$EDTWND(NAME = KV$EDTWND, LAST = ";", STCLASS = BASED);
   12      %LSET LISTDIR = '0'B;
   13      %LSET LISTEXP = '1'B;
   14      %LSET LISTCOM = '0'B;
   15      %LSET LISTSUB = '1'B;
   16      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   17      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
   18      %LSET INIT = CHARTEXT('INIT');
   19      %LSET ENIT = CHARTEXT('');
   20      %ELSE;
   21      %LSET INIT = CHARTEXT('/*');
   22      %LSET ENIT = CHARTEXT('*/');
   23      %ENDIF;
   24      DCL 1 NAME STCLASS ALIGNED,
   25
   26      /*K* STRBYTSIZ SBIN.  Buffer byte size. */
   27
   28            2 STRBYTSIZ SBIN %INIT(0)%ENIT,
   29
   30      /*K* L UBIN BYTE. Text length. */
   31
   32            2 L UBIN BYTE CALIGNED %INIT(0)%CHARTEXT('/**/'),
   33
   34      /*K* T CHAR(1). The text itself. */
   35
   36            2 T CHAR(1) %INIT(' ')%CHARTEXT('/**/') LAST
   37      %MEND;
14:54 JUL 28 '97 KV$INT.:E05SI                                             2    
   38
   39      /*F* NAME: KV$FLD - VDH Field Context Block
   40      KV$FLD is a structure describing a field. */
   41
   42
   43      %MACRO KV$FLD (NAME = KV$FLD, LAST = ";", STCLASS = BASED,
   44       DCLTXTVRB (YES = '1'B, NO = '0'B) = '0'B);
   45      %LSET LISTDIR = '0'B;
   46      %LSET LISTEXP = '1'B;
   47      %LSET LISTCOM = '0'B;
   48      %LSET LISTSUB = '1'B;
   49      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   50      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   51      %IF STC = 1;
   52      %LSET INIT = CHARTEXT('INIT');
   53      %LSET ENIT = CHARTEXT('');
   54      %ELSE;
   55      %LSET INIT = CHARTEXT('/*');
   56      %LSET ENIT = CHARTEXT('*/');
   57      %ENDIF;
   58      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$FLD');
   59      %EQU KV_FLD = CHARTEXT('KV$PTR.FLD$->KV$FLD');
   60      %ENDIF;
   61      %LSET FEP = BITBIN(MODE_FEP);
   62      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
   63      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
   64      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
   65      DCL 1 NAME STCLASS %KV_DBLBYTALG,
   66
   67      /*K* ID - UBIN WORD.  Contains the field identifier. */
   68
   69            2 ID UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
   70
   71      /*K* PRVSTRWRDSIZ - SBIN BYTE.
   72      Contains the previous structure (in the KV$FLDLST list) word size. */
   73
   74            2 PRVSTRWRDSIZ SBIN BYTE CALIGNED %INIT(0)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             3    
   75
   76      /*K* STRWRDSIZ - SBIN BYTE.  Contains the structure word size. */
   77
   78            2 STRWRDSIZ SBIN BYTE CALIGNED %INIT(0)%ENIT,
   79
   80      /*K* VRTCLM - UBIN BYTE.
   81      Specifies the column that this field starts in, relative to the left
   82      origin of the elementary virtual device. */
   83
   84            2 VRTCLM UBIN BYTE CALIGNED %INIT(0)%ENIT,
   85
   86      /*K* UPD.  Contains a series of flags indicating how the
   87      real device is to be updated.   */
   88
   89      %KV_FILBIT
   90            2 UPD,
   91
   92      /*K* UPD.ATR - BIT(1).  If set, means
   93      update attributes (qualification, graphic rendition) on
   94      the real device, as they have been updated in this
   95      table without having been sent to the real device. */
   96
   97              3 ATR BIT(1) %INIT('1'B)%ENIT,
   98
   99      /*K* UPD.TXT - BIT(1).  If set, means
  100      update the text on the real device, as the text has been updated here.
  101      without having been sent to the real device. */
  102
  103              3 TXT BIT(1) %INIT('0'B)%ENIT,
  104
  105      /*K* SLC - BIT(1).  If set, means this field is 'selected'. */
  106
  107            2 SLC BIT(1) %INIT('0'B)%ENIT,
  108
  109      /*K* INP - BIT(1).  If set, means this is an input field.  INP is
  110      set if the field is not protected (PRT), not protected/guarded
  111      (PRTGRD), and not constant (CNS). */
14:54 JUL 28 '97 KV$INT.:E05SI                                             4    
  112
  113            2 INP BIT(1) %INIT('0'B)%ENIT,
  114
  115      /*K* SND - BIT (1).  Send.  If SND is set, means this field should be
  116      sent, when sending the input fields to the other end.  */
  117
  118            2 SND BIT(1) %INIT('0'B)%ENIT,
  119
  120      /*K* RED - BIT (1).  Read.  If RED is set, this field is currently
  121      open for input, i.e. a read has been started and this is a selected
  122      input field. */
  123
  124            2 RED BIT(1) %INIT('0'B)%ENIT,
  125      /*K* NEW - BIT(1).  If set, means
  126      this field is new or deleted since the last screen update. */
  127            2 NEW BIT(1) %INIT('1'B)%ENIT,
  128      /*K* TRMATRRQR - BIT(1).  If set, means
  129      this field needs its own terminating attribute.  The next field or
  130      line begins beyond the position at which the terminating attribute
  131      must be placed.  */
  132
  133            2 TRMATRRQR BIT(1) %INIT('1'B)%ENIT,
  134
  135      /*K* QLF - KV$QLF substructure.  Contains the
  136      qualification parameters. */
  137
  138      %KV_FILBIT
  139      %KV$QLF (LVL = 2, NAME = QLF, STCLASS = STCLASS, LAST = ",");
  140
  141      /*K* GRPRND - KV$GRPRND substructure.  Contains graphic rendition
  142      parameters.  */
  143
  144      %KV_FILBIT
  145      %KV$GRPRND (LVL = 2, NAME = GRPRND, STCLASS = STCLASS, LAST = ",");
  146
  147      /*K* WDT - UBIN BYTE.
  148      Contains the width of the field (in columns).*/
14:54 JUL 28 '97 KV$INT.:E05SI                                             5    
  149
  150            2 WDT UBIN BYTE CALIGNED %INIT(0)%ENIT,
  151
  152      /*K* HI_NONBLNCLM - UBIN BYTE.
  153      Contains the last non-blank position in this field.  */
  154
  155            2 HI_NONBLNCLM UBIN BYTE CALIGNED %INIT(0)%ENIT,
  156
  157      /*K* ATRCLM - UBIN BYTE.
  158      Specifies the column that is to contain attributes.*/
  159
  160            2 ATRCLM UBIN BYTE CALIGNED %INIT(0)%ENIT,
  161
  162      /*K* TXTSIZ - UBIN BYTE.
  163      Contains the text size (in bytes of text). */
  164
  165            2 TXTSIZ UBIN BYTE CALIGNED %INIT(0)%ENIT,
  166
  167      /*K* TXT.  Contains the text.  The initialization parameter
  168      DCLTXTVRB = {YES|NO} determines whether TXT is declared as
  169      CHAR(NAME.TXTSIZ) or (0:0) CHAR(1).  */
  170
  171      %IF DCLTXTVRB = '1'B;
  172            2 TXT CHAR(NAME.TXTSIZ) LAST
  173      %ELSE;
  174            2 TXT(0:0) CHAR(1) LAST
  175      %ENDIF;
  176      %MEND;
  177      /*F* NAME: KV$FLDLST - VDH Field List Structure
  178
  179      This structure describes a buffer that holds a list of
  180      field definitions (KV$FLD structures). */
  181
  182      %MACRO KV$FLDLST(NAME = KV$FLDLST, LAST = ";", STCLASS = BASED);
  183      %LSET LISTDIR = '0'B;
  184      %LSET LISTEXP = '1'B;
  185      %LSET LISTCOM = '0'B;
14:54 JUL 28 '97 KV$INT.:E05SI                                             6    
  186      %LSET LISTSUB = '1'B;
  187      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  188      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  189      %IF STC = 1;
  190      %LSET INIT = CHARTEXT('INIT');
  191      %LSET ENIT = CHARTEXT('');
  192      %ELSE;
  193      %LSET INIT = CHARTEXT('/*');
  194      %LSET ENIT = CHARTEXT('*/');
  195      %ENDIF;
  196      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$FLDLST');
  197      %EQU KV_FLDLST = CHARTEXT('KV$PTR.FLDLST$->KV$FLDLST');
  198      %ENDIF;
  199      %LSET FEP = BITBIN(MODE_FEP);
  200      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  201      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  202      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  203      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  204
  205      /*K* LSTCELWRDX - SBIN WORD.
  206      Is the index to the last cell (in this structure). */
  207
  208            2 LSTCELWRDX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  209
  210      /*K* LSTENTWRDX - SBIN WORD.
  211      Is the index to the last entry (beginning of the KV$FLD structure). */
  212
  213            2 LSTENTWRDX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  214
  215      /*K* ATRCNT - UBIN WORD.
  216      Attribute count.  ATRCNT contains the number of attribute declarations
  217      on this line. */
  218
  219            2 ATRCNT UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT LAST
  220      %MEND;
  221      /*F* NAME: KV@FMT  DBD$VDH (VDH formatter) AUTO.
  222      */
14:54 JUL 28 '97 KV$INT.:E05SI                                             7    
  223      %MACRO KV@FMT (NAME = KV@FMT, LAST = ";", STCLASS = AUTO);
  224      %LSET LISTDIR = '0'B;
  225      %LSET LISTEXP = '1'B;
  226      %LSET LISTCOM = '0'B;
  227      %LSET LISTSUB = '1'B;
  228      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  229      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  230      %LSET INIT = CHARTEXT('INIT');
  231      %LSET ENIT = CHARTEXT('');
  232      %ELSE;
  233      %LSET INIT = CHARTEXT('/*');
  234      %LSET ENIT = CHARTEXT('*/');
  235      %ENDIF;
  236      DCL 1 NAME STCLASS ALIGNED,
  237      /*
  238           Unpacked KH$CHN.TERMID.
  239      */
  240            2 CHN_TERMID BIT(72),
  241      /*
  242           Line speed (baud rate).
  243      */
  244            2 LINSPD UBIN,
  245      /*
  246           Packed FEP address of a buffer we're dealing with here.
  247      */
  248            2 BFRADR UBIN,
  249      /*
  250           Packed index into KV$RCRLST.RCR$.
  251      */
  252            2 RCRLST_RCR$X UBIN,
  253      /*
  254           Temporary words.
  255      */
  256            2 TMP1 UBIN,
  257            2 TMP2 UBIN,
  258            2 TMP3 UBIN,
  259      /*
14:54 JUL 28 '97 KV$INT.:E05SI                                             8    
  260           Packed FEP addresses of structures in our AUTO.
  261      */
  262            2 CHNADR UBIN,
  263            2 EDTBFRADR UBIN,
  264            2 ERDADR UBIN,
  265            2 FLDADR UBIN,
  266            2 FLDLSTADR UBIN,
  267            2 LINADR UBIN,
  268            2 LINLSTADR UBIN,
  269            2 MRDADR UBIN,
  270            2 MVDADR UBIN,
  271            2 PAGADR UBIN,
  272            2 PTRADR UBIN,
  273            2 RCRADR UBIN,
  274            2 RCRLSTADR UBIN,
  275            2 RCVSSNADR UBIN,
  276            2 REDBFRADR UBIN,
  277            2 SRDADR UBIN,
  278            2 SSNADR UBIN,
  279            2 STRADR UBIN,
  280            2 TRCBFRADR UBIN,
  281            2 TRCENTADR UBIN,
  282            2 TYPAHDBFRADR UBIN,
  283            2 USRCTXADR UBIN,
  284            2 USRPRMADR UBIN,
  285            2 VDIADR UBIN,
  286            2 X364ADR UBIN LAST
  287      %MEND;
  288      /*F* NAME: KV$GETPRM VDH HANDLER GET-PARAMETER STRUCTURE */
  289
  290      /* VDH HANDLER GET-PARAMETER STRUCTURE. */
  291
  292      /* This structure resides somewhere in the buffer(s) returned */
  293      /* in response to a KV$VDH_GETPRM request to KVP$GETPRM. */
  294      /* It resides after the significant portion of the data, but not */
  295      /* necessarily at the end of the buffer.  KV$VDH_GETPRM.BFRHED$ */
  296      /* points to this structure. */
14:54 JUL 28 '97 KV$INT.:E05SI                                             9    
  297
  298
  299
  300      %MACRO KV$GETPRM (NAME = KV$GETPRM, LAST = ";", STCLASS = BASED, STRTYP = 0, BFRRLSDSP = 0);
  301      %LSET LISTDIR = '0'B;
  302      %LSET LISTEXP = '1'B;
  303      %LSET LISTCOM = '0'B;
  304      %LSET LISTSUB = '1'B;
  305      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  306      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  307      %LSET INIT = CHARTEXT('INIT');
  308      %LSET ENIT = CHARTEXT('');
  309      %ELSE;
  310      %LSET INIT = CHARTEXT('/*');
  311      %LSET ENIT = CHARTEXT('*/');
  312      %ENDIF;
  313      DCL 1 NAME STCLASS ALIGNED,
  314
  315      /* Link, to the next KV$GETRPM structure in the chain, if any. */
  316
  317            2 LNK$ PTR %INIT(ADDR(NIL))%ENIT,
  318
  319      /* Buffer descriptor for the buffer this structure */
  320      /* resides in. */
  321      /* The data starts at the beginning of the buffer. */
  322
  323      %KV$BFRDSC (LVL = 2, NAME = DAT__, STCLASS = STCLASS, LAST = LAST, STRTYP = STRTYP, BFRRLSDSP = BFRRLSDSP);
  324
  325      %MEND;
  326
  327      /*F* NAME: KV$LIN  - VDH Line Context Block
  328
  329      This structure describes the parameters associated with a
  330      line in the virtual device. */
  331
  332
  333      %MACRO KV$LIN(NAME = KV$LIN, LAST = ";", STCLASS = BASED);
14:54 JUL 28 '97 KV$INT.:E05SI                                             10   
  334      %LSET LISTDIR = '0'B;
  335      %LSET LISTEXP = '1'B;
  336      %LSET LISTCOM = '0'B;
  337      %LSET LISTSUB = '1'B;
  338      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  339      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  340      %IF STC = 1;
  341      %LSET INIT = CHARTEXT('INIT');
  342      %LSET ENIT = CHARTEXT('');
  343      %ELSE;
  344      %LSET INIT = CHARTEXT('/*');
  345      %LSET ENIT = CHARTEXT('*/');
  346      %ENDIF;
  347      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$LIN');
  348      %EQU KV_LIN = CHARTEXT('KV$PTR.LIN$->KV$LIN');
  349      %ENDIF;
  350      %LSET FEP = BITBIN(MODE_FEP);
  351      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  352      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  353      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  354      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  355
  356      /*K* FLDLST$ - PTR.
  357      Points to the field list structure (KV$FLDLST), which contains
  358      a list of field descriptions (KV$FLD). */
  359
  360            2 FLDLST$ PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  361
  362      /*K* VRTLIN - UBIN WORD.  Specifies the
  363      virtual line, relative to origin of virtual device. */
  364
  365            2 VRTLIN UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  366
  367      /*K* UPDFLDCNT - UBIN BYTE.  Contains the
  368      updated field count, for fields on this line. */
  369
  370            2 UPDFLDCNT UBIN BYTE CALIGNED %INIT(0)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             11   
  371      %KV_FILBIT
  372
  373      /*K* FRMDSP - BIT(1).
  374      Form displayed.  FRMDSP is set if this line has been completely
  375      displayed.  It affects what is displayed when positioning
  376      functions are processed. */
  377
  378            2 FRMDSP BIT(1) %INIT('0'B)%ENIT,
  379            2 * BIT(7) %INIT('0'B)%ENIT LAST
  380      %MEND;
  381      /*F* NAME: KV$LINLST - VDH Line List Structure
  382
  383      This structure describes a buffer that holds a list of
  384      line definitions (KV$LIN structures). */
  385
  386      %MACRO KV$LINLST(NAME = KV$LINLST, LAST = ";", STCLASS = BASED);
  387      %LSET LISTDIR = '0'B;
  388      %LSET LISTEXP = '1'B;
  389      %LSET LISTCOM = '0'B;
  390      %LSET LISTSUB = '1'B;
  391      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  392      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  393      %IF STC = 1;
  394      %LSET INIT = CHARTEXT('INIT');
  395      %LSET ENIT = CHARTEXT('');
  396      %ELSE;
  397      %LSET INIT = CHARTEXT('/*');
  398      %LSET ENIT = CHARTEXT('*/');
  399      %ENDIF;
  400      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$LINLST');
  401      %EQU KV_LINLST = CHARTEXT('KV$PTR.LINLST$->KV$LINLST');
  402      %ENDIF;
  403      %LSET FEP = BITBIN(MODE_FEP);
  404      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  405      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  406      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  407      DCL 1 NAME STCLASS %KV_DBLBYTALG,
14:54 JUL 28 '97 KV$INT.:E05SI                                             12   
  408
  409      /*K* LSTCELWRDX - SBIN WORD.
  410      Is the word index to the last cell (in this structure). */
  411
  412            2 LSTCELWRDX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  413
  414      /*K* LSTENTWRDX - SBIN WORD.
  415      Is the word index to the last entry (beginning of KV$LIN structure). */
  416
  417            2 LSTENTWRDX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  418
  419      /*K* ONEFLDLIN$ - PTR.
  420      One field line pointer.  ONEFLDLIN$ points to a KV$LIN structure if
  421      KV$LINLST.SLCFLDSTT = KV_LINLST_SLCFLDSTT_ONE. */
  422
  423            2 ONEFLDLIN$ PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  424
  425      /*K* ONEFLDWRDX - SBIN WORD.
  426      One field word index.  ONEFLDWRDX is the index in KV$FLDLST to a
  427      KV$FLD entry if KV$LINLST.SLCFLDSTT = KV_LINLST_SLCFLDSTT_ONE. */
  428
  429            2 ONEFLDWRDX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  430
  431      /*K* SLCFLDSTT - UBIN BYTE.  Contains the
  432      selected field status, for all fields on this virtual device.
  433      EQUate identifiers for SLCFLDSTT values are listed in the following
  434      table.
  435      ..::TB "^\Identifier\#20\Meaning"
  436      .xeq KV_GLBCNS_E KV_LINLST_SLCFLDSTT_E ALL
  437      .xeq KV_GLBCNS_E KV_LINLST_SLCFLDSTT_E NON
  438      .xeq KV_GLBCNS_E KV_LINLST_SLCFLDSTT_E ONE
  439      .xeq KV_GLBCNS_E KV_LINLST_SLCFLDSTT_E UN_KNW
  440      ..::TB
  441      */
  442
  443            2 SLCFLDSTT UBIN BYTE CALIGNED %INIT(0)%ENIT,
  444      %KV_FILBIT
14:54 JUL 28 '97 KV$INT.:E05SI                                             13   
  445
  446      /*K* LSTOPRSLC - BIT(1).
  447      If set, means the last operator was a select (SLCFLD). */
  448
  449            2 LSTOPRSLC BIT(1) %INIT('0'B)%ENIT,
  450
  451      /*K* FRMDSP - BIT(1).
  452      Form displayed.  If FRMDSP is set, the entire form has been displayed
  453      on the real device since last erasing the device or topping
  454      the page. */
  455
  456            2 FRMDSP BIT(1) %INIT('0'B)%ENIT,
  457            2 * BIT(6) %INIT('0'B)%ENIT,
  458
  459      /*K* TMPFLDLSTLIN - UBIN WORD.
  460      Temporary field list line.  This field contains the virtual line to
  461      which TMPFLDLST$ refers. */
  462
  463            2 TMPFLDLSTLIN UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  464
  465      /*K* ERRFLDID - UBIN WORD.
  466      Contains the FLDID for the field causing error indicated in KV$STR.ERR */
  467
  468            2 ERRFLDID UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT LAST
  469      %MEND;
  470      /*F* NAME: KV$NXTFLD Parameters for KVF$NXTFLD */
  471
  472      %MACRO KV$NXTFLD(NAME = KV$NXTFLD, LVL = 1, LAST = ";", STCLASS = BASED);
  473      %LSET LISTDIR = '0'B;
  474      %LSET LISTEXP = '1'B;
  475      %LSET LISTCOM = '0'B;
  476      %LSET LISTSUB = '1'B;
  477      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  478      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  479      %LSET INIT = CHARTEXT('INIT');
  480      %LSET ENIT = CHARTEXT('');
  481      %ELSE;
14:54 JUL 28 '97 KV$INT.:E05SI                                             14   
  482      %LSET INIT = CHARTEXT('/*');
  483      %LSET ENIT = CHARTEXT('*/');
  484      %ENDIF;
  485      DCL 1 NAME STCLASS ALIGNED,
  486
  487      %(LVL+1) PTR$ PTR %INIT(ADDR(NIL))%ENIT,
  488      /*K* PTR$ = pointer to the KV$PTR structure to use.
  489      */
  490      %(LVL+1) FLD$ PTR %INIT(ADDR(NIL))%ENIT,
  491      /*K* FLD$ = pointer to the KV$FLD structure to use.
  492      */
  493      %(LVL+1) LIN$ PTR %INIT(ADDR(NIL))%ENIT,
  494      /*K* LIN$ = pointer to the KV$LIN structure to use.
  495      */
  496      %(LVL+1) FLDX SBIN WORD %INIT(0)%ENIT,
  497      /*K* FLDX = index to the KV$FLD structure to use.
  498      */
  499      %(LVL+1) LINX SBIN WORD %INIT(0)%ENIT LAST
  500      /*K* LINX = index to the KV$LIN structure to use.
  501      */
  502      %MEND;
  503
  504      /*F* NAME: KV$RCR - VDH Record Structure
  505
  506      This structure contains items unique to each record for ORG = SE.
  507      Each KV$RCR structure is pointed to by an entry in the KV$RCRLST.RCR$ array.
  508      */
  509      %MACRO KV$RCR (NAME = KV$RCR, STCLASS = BASED, LAST = ";",
  510       DCLTXTVRB (YES = '1'B, NO = '0'B) = '0'B);
  511      %LSET LISTDIR = '0'B;
  512      %LSET LISTEXP = '1'B;
  513      %LSET LISTCOM = '0'B;
  514      %LSET LISTSUB = '1'B;
  515      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  516      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  517      %IF STC = 1;
  518      %LSET INIT = CHARTEXT('INIT');
14:54 JUL 28 '97 KV$INT.:E05SI                                             15   
  519      %LSET ENIT = CHARTEXT('');
  520      %ELSE;
  521      %LSET INIT = CHARTEXT('/*');
  522      %LSET ENIT = CHARTEXT('*/');
  523      %ENDIF;
  524      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$RCR');
  525      %EQU KV_RCR = CHARTEXT('KV$PTR.RCR$->KV$RCR');
  526      %ENDIF;
  527      %LSET FEP = BITBIN(MODE_FEP);
  528      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  529      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  530      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  531      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  532
  533      /*K* STRBYTSIZ - SBIN WORD.  Contains the size of this KV$RCR in bytes. */
  534
  535            2 STRBYTSIZ SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  536
  537      /*K* RCRBYTSIZ - SBIN WORD.  Contains the count of data characters in the record. */
  538
  539            2 RCRBYTSIZ SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  540
  541      /*K* LINCNT - SBIN BYTE.  Contains the number of lines occupied by this record.  */
  542            2 LINCNT SBIN BYTE CALIGNED %INIT(0)%ENIT,
  543      %KV_FILBIT
  544
  545      /*K* ONE_2_1 - BIT(1).  If set, indicates that every data character
  546      occupies exactly one column on the screen. */
  547
  548            2 ONE_2_1 BIT(1) %INIT('1'B)%ENIT,
  549
  550      /*K* UPD - BIT(1).  If set, means this record needs to be displayed. */
  551
  552            2 UPD BIT(1) %INIT('1'B)%ENIT,
  553
  554      /*K* NEW - BIT(1).  If set, means this record has a new key.  It might
  555      need to be inserted between two records already on the screen. */
14:54 JUL 28 '97 KV$INT.:E05SI                                             16   
  556
  557            2 NEW BIT(1) %INIT('1'B)%ENIT,
  558
  559      /*K* DSP - BIT(1).  If set, indicates that the record has been
  560      completely displayed at least once, i.e., KV$RCR.LINCNT is accurate. */
  561
  562            2 DSP BIT(1) %INIT('0'B)%ENIT,
  563
  564            2 * BIT(4) %INIT('0'B)%ENIT,
  565
  566      /*K* TXT.  Contains the first character of the KEY text,
  567      followed immediately by the data text.
  568      DCLTXTVRB = {YES|NO} determines whether TXT is declared as
  569      CHAR(NAME.RCRBYTSIZ) or CHAR(1).  */
  570
  571      %IF DCLTXTVRB = '1'B;
  572            2 TXT CHAR(NAME.RCRBYTSIZ) LAST
  573      %ELSE;
  574            2 TXT CHAR(1) %INIT(' ')%ENIT LAST
  575      %ENDIF;
  576
  577      %MEND;
  578
  579      /*F* NAME: KV$RCRLST - VDH Record List Structure
  580
  581      This structure contains context information unique to ORG = SE
  582      devices.  KV$RCRLIST is pointed to by KV$MVD.RCRLST$ and
  583      KV$PTR.RCRLST$ (also known as LINLST$ and X364$). */
  584
  585      %MACRO KV$RCRLST (NAME = KV$RCRLST, LAST = ";", STCLASS = BASED);
  586      %LSET LISTDIR = '0'B;
  587      %LSET LISTEXP = '1'B;
  588      %LSET LISTCOM = '0'B;
  589      %LSET LISTSUB = '1'B;
  590      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  591      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  592      %IF STC = 1;
14:54 JUL 28 '97 KV$INT.:E05SI                                             17   
  593      %LSET INIT = CHARTEXT('INIT');
  594      %LSET ENIT = CHARTEXT('');
  595      %ELSE;
  596      %LSET INIT = CHARTEXT('/*');
  597      %LSET ENIT = CHARTEXT('*/');
  598      %LSET G_KEYTYPE_BIN10# = 0;
  599      %ENDIF;
  600      %IF (TEXTCHAR(STCLASS) = 'BASED') AND (TEXTCHAR(NAME) = 'KV$RCRLST');
  601      %EQU KV_RCRLST = CHARTEXT('KV$PTR.RCRLST$->KV$RCRLST');
  602      %ENDIF;
  603      %LSET FEP = BITBIN(MODE_FEP);
  604      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  605      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  606      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  607      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  608
  609      /*K* STRBYTSIZ - SBIN WORD.  Contains the size of this RCRLST structure in bytes. */
  610
  611            2 STRBYTSIZ SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  612
  613      /*K* RCRCNT - SBIN WORD.  Contains the number of records pointed to by
  614      RCR$ pointers. */
  615
  616            2 RCRCNT SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  617
  618      /*K* MAXRCR - SBIN WORD.  Contains the number of RCR$ pointers that exist
  619      (some may be NIL). */
  620
  621            2 MAXRCR SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  622
  623      /*K* HRZSCROFS - SBIN WORD.  Contains the number of columns that exist to
  624      the left of the displayed data. */
  625
  626            2 HRZSCROFS SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  627
  628      /*K* FRSRCR - SBIN WORD.  Is the index into RCR$ for the first record on display. */
  629
14:54 JUL 28 '97 KV$INT.:E05SI                                             18   
  630            2 FRSRCR SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  631
  632      /*K* LSTRCR - SBIN WORD.  Is the index into RCR$ for the last record on display. */
  633
  634            2 LSTRCR SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(-2)%ENIT,
  635
  636      /*K* CRTRCR - SBIN WORD.  Is the index into RCR$ for the record in which
  637      the cursor is positioned.  */
  638
  639            2 CRTRCR SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(-0)%ENIT,
  640
  641      /*K* SNDRCR - SBIN WORD.  Is the index into RCR$ of the record that has
  642      been updated but not yet used to respond to a read request.  A
  643      negative value means there is no such record. */
  644
  645            2 SNDRCR SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(-1)%ENIT,
  646
  647      /*K* KEYINC - UBIN WORD.  Contains the upper limit of the key increment to use
  648      when adding records. */
  649
  650            2 KEYINC UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(1000)%ENIT,
  651
  652      /*K* VRTSCRMRG - UBIN BYTE.  The cursor is hard to move closer than
  653      VRTSCRMRG lines to the top or bottom of the screen.  VRTSCRMRG is
  654      ignored at file ends.  See VLP_EDTCTL, in the CP-6 Host Monitor
  655      Services Reference (CE74).  */
  656
  657            2 VRTSCRMRG UBIN BYTE CALIGNED %INIT(0)%ENIT,
  658
  659      /*K* VRTSCRSHF - UBIN BYTE.  Indicates how far to scroll vertically
  660      when it happens.  VRTSCRSHF can be a percentage, number of lines
  661      or "center".  */
  662
  663            2 VRTSCRSHF UBIN BYTE CALIGNED %INIT(0)%ENIT,
  664
  665      /*K* VRTSCRCNT - SBIN BYTE.  Contains the number of lines the window
  666      needs to be slid at the top. */
14:54 JUL 28 '97 KV$INT.:E05SI                                             19   
  667
  668            2 VRTSCRCNT SBIN BYTE CALIGNED %INIT(0)%ENIT,
  669
  670      /*K* KEYTYP - UBIN BYTE.  Specifies
  671      .xeq KI_CP6_C VLP_EDTCTL KEYTYPE
  672      */
  673
  674            2 KEYTYP UBIN BYTE CALIGNED %INIT(%G_KEYTYPE_BIN10#)%ENIT,
  675
  676      /*K* KEYLNG - UBIN BYTE.  Contains the length of keys in bytes.
  677      KEYLNG is the offset to data bytes in KV$RCR.TXT */
  678
  679            2 KEYLNG UBIN BYTE CALIGNED %INIT(4)%ENIT,
  680
  681      /*K* SPRCNT - UBIN BYTE.  Specifies the emptiness (MAXRCR less RCRCNT)
  682      to permit before performing an E$RECORDS_NEEDED ALTRET. */
  683
  684            2 SPRCNT UBIN BYTE CALIGNED %INIT(5)%ENIT,
  685
  686      /*K* DATCTRCHR - SBIN BYTE.  Contains the activation character or
  687      RECORDS_NEEDED count.  */
  688
  689            2 DATCTRCHR SBIN BYTE CALIGNED %INIT(0)%ENIT,
  690      %KV_FILBIT
  691
  692      /*K* RCRNEDSNT - BIT(1).  If set, means RECORDS_NEEDED was sent but no
  693      record has appeared in response. */
  694
  695            2 RCRNEDSNT BIT(1) %INIT('0'B)%ENIT,
  696
  697      /*K* EOF - BIT(1).  If set, means the last record in the file is here. */
  698
  699            2 EOF BIT(1) %INIT('0'B)%ENIT,
  700
  701      /*K* BOF - BIT(1).  If set, means the first record in the file is here. */
  702
  703            2 BOF BIT(1) %INIT('0'B)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             20   
  704
  705      /*K* PRTLSTRCR - BIT(1).  If set, means the last record needs vertical
  706      scrolling to occur before it can be edited. */
  707
  708            2 PRTLSTRCR BIT(1) %INIT('0'B)%ENIT,
  709
  710      /*K* ACTCHR - BIT(1).  If set, means an activation character has been
  711      saved in DATCTRCHR. */
  712
  713            2 ACTCHR BIT(1) %INIT('0'B)%ENIT,
  714
  715      /*K* SNDRQR.DLT - BIT(1).  If set, means a deleted record (CRTRCR+1)
  716      needs reporting to the DCB. */
  717
  718            2 SNDRQR,
  719              3 DLT BIT(1) %INIT('0'B)%ENIT,
  720
  721      /*K* SNDRQR.INS - BIT(1).  If set, means a split record (CRTRCR) needs
  722      reporting to the DCB. */
  723
  724              3 INS BIT(1) %INIT('0'B)%ENIT,
  725
  726      /*K* HRZSCRALL - BIT(1).  If set, means horizontal scroll all records together. */
  727
  728            2 HRZSCRALL BIT(1) %INIT('0'B)%ENIT,
  729      /*K* DFRCNT - SBIN BYTE.  Specifies, for DFROPR, the record to go to
  730      or the character to search for.  */
  731
  732            2 DFRCNT SBIN BYTE CALIGNED %INIT(0)%ENIT,
  733      %KV_FILBIT
  734      /*K* DLTRCREXS - BIT(1).  If set, means deleted records still exist
  735      (and must be cleaned up). */
  736
  737            2 DLTRCREXS BIT(1) %INIT('0'B)%ENIT,
  738      /*K* TXTEDT - BIT(1).  If set, means insure blank separation on joins. */
  739
  740            2 TXTEDT BIT(1) %INIT('0'B)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             21   
  741
  742      /*K* ESYAPP - BIT(1).  If set, means that empty records can extend the file. */
  743
  744            2 ESYAPP BIT(1) %INIT('0'B)%ENIT,
  745
  746      /*K* EOFDSP - BIT(1).  If set, means that the EOF marker is on screen. */
  747
  748            2 EOFDSP BIT(1) %INIT('0'B)%ENIT,
  749
  750      /*K* NO_CTX - BIT(1).  Set when a record buffer couldn't be obtained.
  751           Any operations other than M$ERASE will ALTRETURN with E$CANTGETCTX. */
  752
  753            2 NO_CTX BIT(1) %INIT('0'B)%ENIT,
  754
  755      /*K* SAMDAT - BIT(1).  If set, means that the activation record is unchanged.
  756           Causes the record to be returned to the Host with DVBYTE.TRANS set. */
  757
  758            2 SAMDAT BIT(1) %INIT('0'B)%ENIT,
  759
  760      /*K* SCRDN - BIT(1).  If set, means it was necessary to request
  761      records to scroll down. */
  762
  763            2 SCRDN BIT(1) %INIT('0'B)%ENIT,
  764
  765      /*K* SCRUP - BIT(1).  If set, means it was necessary to request
  766      records to scroll up. */
  767
  768            2 SCRUP BIT(1) %INIT('0'B)%ENIT,
  769
  770
  771      /*K* DFROPR - SBIN BYTE.  Specifies an input function needs finishing
  772      when the next read starts. */
  773
  774            2 DFROPR SBIN BYTE CALIGNED %INIT(0)%ENIT,
  775
  776
  777      /*K* ONESPCEDT - BIT(1).  Set if user wants to format paragraphs
14:54 JUL 28 '97 KV$INT.:E05SI                                             22   
  778           using one space instead of two between sentences. */
  779      %KV_FILBIT
  780            2 ONESPCEDT BIT(1) %INIT('0'B)%ENIT,
  781
  782            2 *(0:6) BIT(1) %INIT('0'B*0)%ENIT,
  783
  784            2 *(0:1) SBIN BYTE CALIGNED %INIT(0*0)%ENIT,
  785      /*K* RCR$ - PTR ARRAY.  Contains pointers to KV$RCR structures.  The
  786      last entry is MAXRCR-1. */
  787
  788            2 RCR$(0:0) PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT LAST
  789
  790      %MEND;
  791      /*F* NAME: KV$RCVVDO.
  792         Context for servicing a single KV$VDO, with any associated
  793      KV$VDOVLPs.  This context is set up
  794      in KVM$RCV before starting with a new KV$VDO. */
  795
  796      %MACRO KV$RCVVDO(NAME = KV_RCVVDO, LVL = 1, LAST = ";", STCLASS = SYMREF);
  797      %LSET LISTDIR = '0'B;
  798      %LSET LISTEXP = '1'B;
  799      %LSET LISTCOM = '0'B;
  800      %LSET LISTSUB = '1'B;
  801      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  802      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  803      %LSET INIT = CHARTEXT('INIT');
  804      %LSET ENIT = CHARTEXT('');
  805      %ELSE;
  806      %LSET INIT = CHARTEXT('/*');
  807      %LSET ENIT = CHARTEXT('*/');
  808      %ENDIF;
  809      DCL 1 NAME STCLASS ALIGNED,
  810      %(LVL+1) VDOVLP$ PTR %INIT(ADDR(NIL))%ENIT,
  811      /*
  812      Pointer to the VDOVLP currently being interpreted.
  813      */
  814      %(LVL+1) VDOVLP_ACTPOS$ PTR %INIT(ADDR(NIL))%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             23   
  815      /*
  816      Pointer to the KV$VDOVLP_ACTPOS being received.
  817      */
  818      %(LVL+1) VDOVLP_CG_MSGID$ PTR %INIT(ADDR(NIL))%ENIT,
  819      /*
  820      Pointer to the KV$VDOVLP_CG_MSGID being received.
  821      */
  822      %(LVL+1) VDOVLP_CG_MSGTYP$ PTR %INIT(ADDR(NIL))%ENIT,
  823      /*
  824      Pointer to the KV$VDOVLP_CG_MSGTYP being received.
  825      */
  826      %(LVL+1) VDOVLP_CG_STA$ PTR %INIT(ADDR(NIL))%ENIT,
  827      /*
  828      Pointer to the KV$VDOVLP_CG_STA being received.
  829      */
  830      %(LVL+1) VDOVLP_DAT1$ PTR %INIT(ADDR(NIL))%ENIT,
  831      /*
  832      Pointer to the KV$VDOVLP_DAT1 being received.
  833      */
  834      %(LVL+1) VDOVLP_DAT2$ PTR %INIT(ADDR(NIL))%ENIT,
  835      /*
  836      Pointer to the KV$VDOVLP_DAT2 being received.
  837      */
  838      %(LVL+1) VDOVLP_ENTSRD$ PTR %INIT(ADDR(NIL))%ENIT,
  839      /*
  840      Pointer to the KV$VDOVLP_ENTSRD being received.
  841      */
  842      %(LVL+1) VDOVLP_ERR$ PTR %INIT(ADDR(NIL))%ENIT,
  843      /*
  844      Pointer to the KV$VDOVLP_ERR being received.
  845      */
  846      %(LVL+1) VDOVLP_FLDID$ PTR %INIT(ADDR(NIL))%ENIT,
  847      /*
  848      Pointer to the KV$VDOVLP_FLDID being received.
  849      */
  850      %(LVL+1) VDOVLP_KEY$ PTR %INIT(ADDR(NIL))%ENIT,
  851      /*
14:54 JUL 28 '97 KV$INT.:E05SI                                             24   
  852      Pointer to the KV$VDOVLP_KEY being received.
  853      */
  854      %(LVL+1) VDOVLP_MRK$ PTR %INIT(ADDR(NIL))%ENIT,
  855      /*
  856      Pointer to the KV$VDOVLP_MRK being received.
  857      */
  858      %KV$VDH_OTPLCL (NAME = OTPLCL, STCLASS = STCLASS, LVL = 2, LAST = ",");
  859      /*
  860      OTPLCL FPT wherein is kept KV$VECTOR framing DAT1.DAT or DAT2.DAT.
  861      */
  862      %KV$VDP_VDO (NAME = VDP_VDO, STCLASS = STCLASS, LVL = 2, LAST = ",");
  863      /*
  864      KV$VDP_VDO for this VDO.
  865      */
  866
  867      /* Q message.  Don't release this message, but Q if for later */
  868      /* MQD delivery. */
  869
  870            %(LVL+1) Q_MSG BIT(1) %INIT('0'B)%ENIT,
  871
  872
  873      /* Send an immediate acknowledgement, */
  874      /* rather than wrapping an output marker thru the data stream. */
  875
  876            %(LVL+1) SNDIMDACK BIT(1) %INIT('0'B)%ENIT,
  877
  878      /* Error.  While processing this message, some sort of error occurred, */
  879      /* and we shouldn't repond to the other end as if all went well. */
  880
  881            %(LVL+1) ERR BIT(1) %INIT('0'B)%ENIT,
  882            %(LVL+1) * BIT(13) %INIT('0'B)%ENIT,
  883      /* Previous stream-id for use if PSTSTR = 0 and SETSTR = 1. */
  884            %(LVL+1) PRVSTR$ PTR %INIT(ADDR(NIL))%ENIT LAST
  885      %MEND;
  886
  887      /*F* NAME: KV$RCVSSN.
  888         Context for servicing contiguous KV$VDOs to a single session.
14:54 JUL 28 '97 KV$INT.:E05SI                                             25   
  889      This context is set up
  890      in KVM$RCV before starting with a new session. */
  891
  892      %MACRO KV$RCVSSN (NAME = KV$RCVSSN, LVL = 1, LAST = ";", STCLASS = BASED);
  893      %LSET LISTDIR = '0'B;
  894      %LSET LISTEXP = '1'B;
  895      %LSET LISTCOM = '0'B;
  896      %LSET LISTSUB = '1'B;
  897      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  898      %IF(TEXTCHAR(STCLASS) = 'BASED')AND(TEXTCHAR(NAME) = 'KV$RCVSSN');
  899      %EQU KV_RCVSSN = CHARTEXT('KV$RCVSSN$->KV$RCVSSN');
  900      DCL KV$RCVSSN$ PTR SYMREF;
  901      %ENDIF;
  902      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  903      %IF STC = 1;
  904      %LSET INIT = CHARTEXT('INIT');
  905      %LSET ENIT = CHARTEXT('');
  906      %ELSE;
  907      %LSET INIT = CHARTEXT('/*');
  908      %LSET ENIT = CHARTEXT('*/');
  909      %ENDIF;
  910      %LSET FEP = BITBIN(MODE_FEP);
  911      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  912      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  913      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  914      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  915
  916      /* Field word size.  Used by field maintenance routines. */
  917
  918            %(LVL+1) FLDWRDSIZ UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  919      %KV_FILBIT
  920
  921      /* Buffer limit exceeded, during the processing of a VDO. */
  922
  923            %(LVL+1) BFRLMTEXC BIT(1) %INIT('0'B)%ENIT,
  924      /* Previous ASNINPPTR$ for VDOs arriving for session not selected at
  925         the device. */
14:54 JUL 28 '97 KV$INT.:E05SI                                             26   
  926            %(LVL+1) PRVPTR$ PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  927      /* Previous stream-id for use if SETPRVSTR is set. */
  928            %(LVL+1) PRVSTR$ PTR %INIT(ADDR(NIL))%ENIT LAST
  929      %MEND;
  930
  931      /*F* NAME: KV$REDBFR VDH READ BUFFER DESCRIPTION */
  932
  933      /* VDH HANDLER READ BUFFER DESCRIPTION */
  934
  935      %MACRO KV$REDBFR(NAME = KV$REDBFR, STCLASS = BASED);
  936      DCL 1 NAME STCLASS ALIGNED,
  937
  938      /* Characters in the read buffer. */
  939
  940            2 CHR(0:0) CHAR(1);
  941      %MEND;
  942      /*F* NAME: KV$STRCTR
  943           DESCRIPTION:
  944           VDH structure control structure.
  945           This structure is effectively an element in an array
  946           (KV_STRCTR) indexed by structure type (%KV_STRTYP_...).
  947           The contents indicate what must be done in KVS to allocate
  948           a structure of that type.                                                */
  949
  950      %MACRO KV$STRCTR(NAME = KV$STRCTR,
  951          LVL = 1,
  952          STCLASS = BASED,
  953          STRTYP = 0,
  954          BYTSIZ = 0,
  955          INTDAT = ,
  956          SHRBFRHED = ,
  957          SHRBFR(YES = '1'B, NO = '0'B) = '0'B,
  958          PWR2(YES = '1'B, NO = '0'B) = '0'B,
  959          DUMMY(YES = '1'B, NO = '0'B) = '0'B,
  960          INTSTRTYP(YES = '1'B, NO = '0'B) = '0'B,
  961          CHKSIZ(YES = '1'B, NO = '0'B) = '0'B,
  962          LAST = ";");
14:54 JUL 28 '97 KV$INT.:E05SI                                             27   
  963
  964      %LSET LISTDIR = '0'B;
  965      %LSET LISTEXP = '1'B;
  966      %LSET LISTCOM = '0'B;
  967      %LSET LISTSUB = '1'B;
  968      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  969      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
  970      %LSET INIT = CHARTEXT('INIT');
  971      %LSET ENIT = CHARTEXT('');
  972      %LSET INTHED = CONCAT(TEXTCHAR(INTDAT), TEXTCHAR(SHRBFRHED));
  973      %IF LENGTHC(INTHED) = 0;
  974      %LSET INTHED = 'NIL';
  975      %ENDIF;
  976      %ELSE;
  977      %LSET INIT = CHARTEXT('/*');
  978      %LSET ENIT = CHARTEXT('*/');
  979      %LSET INTHED = '0';
  980      %ENDIF;
  981
  982      %IF STRTYP ~= 0;
  983      %SET KV$STRCTR_INDEX = KV$STRCTR_INDEX+1;
  984      %IF STRTYP ~= KV$STRCTR_INDEX;
  985      %ERROR('The position of this KV$STRCTR array element does not match the STRTYP specified.');
  986      %ENDIF;
  987      %ENDIF;
  988
  989      %IF LVL = 1;
  990      DCL 1 NAME STCLASS ALIGNED,
  991      %ELSE;
  992            %(LVL) NAME,
  993      %ENDIF;
  994
  995      /*K* BYTSIZ - VALUE(0-).
  996           Byte size of this structure, if it is a fixed size, non-shared
  997           buffer.                                                                  */
  998
  999               %(LVL+1) %CHARTEXT('BYTSIZ') UBIN WORD %INIT(BYTSIZ)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             28   
 1000
 1001      /*K* INTDAT - variable
 1002           Initial data. If non-null, move the contents of the
 1003           area pointed to by this pointer to the buffer being
 1004           allocated.  Not used for shared buffers.                                 */
 1005
 1006               %(LVL+1) INTDAT$ PTR %INIT(ADDR(%CHARTEXT(INTHED)))%ENIT,
 1007
 1008      /*K* SHRBFRHED - variable
 1009           Shared buffer head pointer. Points to the head shared buffer.
 1010           Used only for VDH shared buffers, not for VDH-user shared buffers.       */
 1011
 1012               %(LVL+1) SHRBFRHED$ REDEF INTDAT$ PTR,
 1013
 1014      /*K* SHRBFR - {YES|NO}
 1015           Shared buffer. This structure is maintained in a shared buffer.          */
 1016
 1017               %(LVL+1) %CHARTEXT('SHRBFR') BIT(1) %INIT(SHRBFR)%ENIT,
 1018
 1019      /*K* PWR2 - {YES|NO}
 1020           Power of 2. Memory management requests will specify sizes
 1021           bounded up to the next power of 2.                                       */
 1022
 1023               %(LVL+1) %CHARTEXT('PWR2') BIT(1) %INIT(PWR2)%ENIT,
 1024
 1025      /*K* INTSTRTYP - {YES|NO}
 1026           Initialize structure type. The %KV_STRTYP_... should be
 1027           put in the first byte of the buffer being allocated.                     */
 1028
 1029               %(LVL+1) %CHARTEXT('INTSTRTYP') BIT(1) %INIT(INTSTRTYP)%ENIT,
 1030      /*K* DUMMY - {YES|NO}
 1031           This entry is a dummy, just to keep stats separately.  The real entry
 1032           is the one indexed by BYTSIZ of this entry. (TAB buffers are like this). */
 1033               %(LVL+1) %CHARTEXT('DUMMY') BIT(1) %INIT(DUMMY)%ENIT,
 1034      /*K* CHKSIZ - {YES|NO}
 1035
 1036      */
14:54 JUL 28 '97 KV$INT.:E05SI                                             29   
 1037               %(LVL+1) %CHARTEXT('CHKSIZ') BIT(1)%INIT(CHKSIZ)%ENIT,
 1038               %(LVL+1) * BIT(11)%INIT('0'B)%ENIT LAST
 1039      %MEND;
 1040      /*F* NAME: KV$TITLE - Page Heading Structure
 1041
 1042      KV$TITLE is the structure that defines the title template.  */
 1043
 1044      %MACRO KV$TITLE(NAME = KV$TITLE, LAST = ";", STCLASS = BASED);
 1045      %LSET LISTDIR = '0'B;
 1046      %LSET LISTEXP = '1'B;
 1047      %LSET LISTCOM = '0'B;
 1048      %LSET LISTSUB = '1'B;
 1049      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1050      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1051      %LSET INIT = CHARTEXT('INIT');
 1052      %LSET ENIT = CHARTEXT('');
 1053      %ELSE;
 1054      %LSET INIT = CHARTEXT('/*');
 1055      %LSET ENIT = CHARTEXT('*/');
 1056      %ENDIF;
 1057      %KV$SHRBFR (NAME = NAME, STCLASS = STCLASS, LAST = ",");
 1058            2 * BIT(7) %INIT('0'B)%ENIT,
 1059
 1060      /*K* RSTPAGNMB - BIT(1).
 1061      If set, means reset page numbers to 0.  VDH "receives"
 1062      a KV$TITLE when M$DEVICE specifies a HDR.  */
 1063
 1064            2 RSTPAGNMB BIT(1) %INIT('0'B)%ENIT,
 1065
 1066      /*K* HGT - UBIN BYTE.
 1067      Contains the title height.  */
 1068
 1069            2 HGT UBIN BYTE CALIGNED %INIT(0)%ENIT,
 1070
 1071      /*K* INDCLM - UBIN BYTE.
 1072      Contains the title indent column.  */
 1073
14:54 JUL 28 '97 KV$INT.:E05SI                                             30   
 1074            2 INDCLM UBIN BYTE CALIGNED %INIT(0)%ENIT,
 1075
 1076      /*K* CNTCLM - UBIN BYTE.
 1077      Contains the column(s) in which the page number appears.  */
 1078
 1079            2 CNTCLM UBIN BYTE CALIGNED %INIT(0)%ENIT,
 1080
 1081      /*K* TXTSIZ - UBIN BYTE.
 1082      Contains the text size (in bytes).  */
 1083
 1084            2 TXTSIZ UBIN BYTE CALIGNED %INIT(0)%ENIT,
 1085            2 TXT(0:0) REDEF TXTSIZ CHAR(1) LAST
 1086      %MEND;
 1087      /*F* NAME: KV$TRCENT - VDH trace buffer entry
 1088      */
 1089      %MACRO KV$TRCENT (NAME = KV$TRCENT, STCLASS = BASED, LVL = 1, LAST = ";",
 1090      FEP (YES = 1, NO = 0) = "BITBIN(MODE_FEP)",
 1091      MLT (YES = '1'B, NO = '0'B) = '0'B,
 1092      TYP = 0,
 1093      FNC = 0);
 1094      %LSET LISTDIR = '0'B;
 1095      %LSET LISTEXP = '1'B;
 1096      %LSET LISTCOM = '0'B;
 1097      %LSET LISTSUB = '1'B;
 1098      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1099      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1100      %IF STC = 1;
 1101      %LSET INIT = CHARTEXT(' INIT');
 1102      %LSET ENIT = CHARTEXT('');
 1103      %ELSE;
 1104      %LSET INIT = CHARTEXT('/*');
 1105      %LSET ENIT = CHARTEXT('*/');
 1106      %ENDIF;
 1107      %LSET FEP = BITBIN(MODE_FEP);
 1108      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1109      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1110      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
14:54 JUL 28 '97 KV$INT.:E05SI                                             31   
 1111      %IF LVL = 1;
 1112      DCL 1 NAME %KV_DBLBYTALG STCLASS,
 1113      %ELSE;
 1114      %IF TEXTCHAR(NAME) ~= '';
 1115      %(LVL) NAME,
 1116      %ENDIF;
 1117      %ENDIF;
 1118      %SET KV#TRCENT_MSK = '7FFF'X;           /* Mask for all but MLT               */
 1119      %KV_FILBIT
 1120      %(LVL+1) %CHARTEXT('MLT') BIT(1) %INIT(MLT)%ENIT UNAL,
 1121      /*K* MLT = flag.  Indicates multiple identical events were
 1122      traced contiguously.
 1123      */
 1124      %(LVL+1) * BIT(3) %INIT('0'B)%ENIT UNAL, /* Available                         */
 1125      %(LVL+1) %CHARTEXT('TYP') UBIN(4) %INIT(TYP)%ENIT UNAL,
 1126      /*K* TYP = VALUE-DEC(0-7).  The type of trace made, e.g.,
 1127      'received VDO'.  Values are KV#TRCENT_TYP_...
 1128      */
 1129      %KV_FILBIT
 1130      %(LVL+1) %CHARTEXT('FNC') UBIN(8) %INIT(FNC)%ENIT UNAL LAST /* Only NEED UBIN(6) */
 1131      /*K* FNC = VALUE-DEC(0-63).  The function traced.
 1132      Values are KV_VDH_FNC_..., KV_USR_FNC_..., KV_VDO_FNC_...,
 1133      or KN_FCN_TERM, as appropriate.
 1134      */
 1135      %MEND;
 1136      /*F* NAME: KV$TRCBFR - VDH trace buffer.
 1137      */
 1138      %MACRO KV$TRCBFR (NAME = KV$TRCBFR, STCLASS = BASED, LVL = 1, LAST = ";",
 1139      FEP (YES = 1, NO = 0) = "BITBIN(MODE_FEP)",
 1140      MAXTRCENTX = 0, TRCENTX = 0);
 1141      %LSET LISTDIR = '0'B;
 1142      %LSET LISTEXP = '1'B;
 1143      %LSET LISTCOM = '0'B;
 1144      %LSET LISTSUB = '1'B;
 1145      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1146      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1147      %IF STC = 1;
14:54 JUL 28 '97 KV$INT.:E05SI                                             32   
 1148      %LSET INIT = CHARTEXT(' INIT');
 1149      %LSET ENIT = CHARTEXT('');
 1150      %ELSE;
 1151      %LSET INIT = CHARTEXT('/*');
 1152      %LSET ENIT = CHARTEXT('*/');
 1153      %ENDIF;
 1154      %LSET FEP = BITBIN(MODE_FEP);
 1155      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1156      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1157      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
 1158      %IF LVL = 1;
 1159      DCL 1 NAME %KV_DBLBYTALG STCLASS,
 1160      %ELSE;
 1161      %IF TEXTCHAR(NAME) ~= '';
 1162      %(LVL) NAME,
 1163      %ENDIF;
 1164      %ENDIF;
 1165      %(LVL+1) %CHARTEXT('MAXTRCENTX') SBIN(%(18-2*FEP))  %KV_DBLBYTALG %INIT(MAXTRCENTX)%ENIT,
 1166      /*K* MAXTRCENTX = DEC(0-65535).  Maximum trace entry index.
 1167      */
 1168      %(LVL+1) %CHARTEXT('TRCENTX') SBIN(%(18-2*FEP))  %KV_DBLBYTALG %INIT(TRCENTX)%ENIT,
 1169      /*K* TRCENTX = DEC(0-65535).  Trace entry index (to last entry
 1170      stored into).
 1171      */
 1172      %LSET NXTLVL = LVL + 1;
 1173      %KV$TRCENT (NAME = "TRCENT(0:0)", STCLASS = STCLASS, LVL = NXTLVL, LAST = LAST,
 1174      FEP = FEP);
 1175      /* TRCENT = array of KV$TRCENT groups.
 1176      */
 1177      %MEND;
 1178      %EJECT;

14:54 JUL 28 '97 KV$INT.:E05SI                                             33   
 1179      /*F* NAME: KV$TRNTBL - VDH Translate Table Definitions
 1180
 1181      KV$TRNTBL is the structure containing the VDH translation table. */
 1182
 1183
 1184      %MACRO KV$TRNTBL(NAME = KV$TRNTBL, LAST = ";", STCLASS = BASED,
 1185                       INPTRN1 = NIL,
 1186                       INPTRN2 = NIL,
 1187                       OTPTRN2 = NIL,
 1188                       OTPTRN3 = NIL,
 1189                       OTPTRN1 = NIL,
 1190                       EXTOTPTRN = NIL,
 1191                       EXTINPTRN = NIL,
 1192                       INPTKN = NIL,
 1193                       SPCESC = NIL,
 1194                       LNK = NIL,
 1195                       INPCHRMSK = 'FFFF'X,
 1196                       OTPESCCHR = 256,
 1197                       OTPESCCHR1 = ' ',
 1198                       OTPESCCHR2 = ' ',
 1199                       NAM = ' ',
 1200                       FNTCLS(ASC = 0, APLB = 1, APLT = 2, EBC = 3) = 0,
 1201                       SP_CHR = ' ',
 1202                       HT_CHR = "BINASC(9)",
 1203                       INPCTRSTRINTCHR = "BINASC(0)",
 1204                       PRTAPL = '0'B,
 1205                       DRCOTPTRN = '0'B,
 1206                       TRNINPCTRSTRID = '0'B);
 1207      %LSET LISTDIR = '0'B;
 1208      %LSET LISTEXP = '1'B;
 1209      %LSET LISTCOM = '0'B;
 1210      %LSET LISTSUB = '1'B;
 1211      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1212      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1213      %LSET INIT = CHARTEXT('INIT');
 1214      %LSET ENIT = CHARTEXT('');
 1215      %ELSE;
14:54 JUL 28 '97 KV$INT.:E05SI                                             34   
 1216      %LSET INIT = CHARTEXT('/*');
 1217      %LSET ENIT = CHARTEXT('*/');
 1218      %ENDIF;
 1219      %IF TEXTCHAR(STCLASS) = 'BASED' AND TEXTCHAR(NAME) = 'KV$TRNTBL';
 1220      %EQU KV_TRNTBL = CHARTEXT('KV$PTR.MVD$->KV$MVD.TRNTBL$->KV$TRNTBL');
 1221      %ENDIF;
 1222      %KV$SHRBFR(NAME = NAME, STCLASS = STCLASS, LNK = LNK, NAM = NAM, LAST = ",");
 1223      /*K* LNK$ - PTR.
 1224      .xeq KV$GLB KV$SHRBFR__ LNK$
 1225      */
 1226
 1227      /*K* INPTRN1$ - PTR.
 1228      Points to the primary input translation table (KV$PRMINPTRN). */
 1229
 1230              2 INPTRN1$ PTR %INIT(ADDR(INPTRN1))%ENIT,
 1231
 1232      /*K* INPTRN2$ - PTR.
 1233      Points to the secondary input translation table (KV$SCNINPTRN). */
 1234
 1235                2 INPTRN2$ PTR %INIT(ADDR(INPTRN2))%ENIT,
 1236
 1237      /*K* OTPTRN1$ - PTR.
 1238      Points to the primary output translation table (KV$PRMOTPTRN). */
 1239
 1240                2 OTPTRN1$ PTR %INIT(ADDR(OTPTRN1))%ENIT,
 1241
 1242      /*K* OTPTRN2$ - PTR.
 1243      Points to the secondary output translation table (KV$SCNOTPTRN). */
 1244
 1245                2 OTPTRN2$ PTR %INIT(ADDR(OTPTRN2))%ENIT,
 1246
 1247      /*K* OTPTRN3$ - PTR.
 1248      Points to the second secondary output translation table (KV$SCNOTPTRN). */
 1249
 1250                2 OTPTRN3$ PTR %INIT(ADDR(OTPTRN3))%ENIT,
 1251
 1252      /*K* EXTINPTRN$ - PTR.
14:54 JUL 28 '97 KV$INT.:E05SI                                             35   
 1253      Points to the extended input translate table. */
 1254
 1255                2 EXTINPTRN$ PTR %INIT(ADDR(EXTINPTRN))%ENIT,
 1256
 1257      /*K* EXTOTPTRN$ - PTR.
 1258      Points to the extended output translate table. */
 1259
 1260                2 EXTOTPTRN$ PTR %INIT(ADDR(EXTOTPTRN))%ENIT,
 1261
 1262      /*K* INPTKN$ - PTR.
 1263      Token entry table pointer.  INPTKN$ points to a bit array indexed
 1264      by the character.  If the corresponding bit in the
 1265      token table is set, then the KV$PRMINPTRN.CHR entry contains
 1266      a token rather than a character.  The two high-order bits of a token
 1267      indicate its type (KV_TRNTKNTYP_xxx); see the list below.  The
 1268      remaining six bits comprise the token ID.
 1269      ..::TB "^\Identifier\#10\Meaning\#"
 1270      ..::IT "KV_TRNTKNTYP_EXTTRN"
 1271      .xeq KV$INT KV_TRNTKNTYP_E EXTTRN
 1272      ..::IT "KV_TRNTKNTYP_INPFNC"
 1273      .xeq KV$INT KV_TRNTKNTYP_E INPFNC
 1274      ..::IT "KV_TRNTKNTYP_INPFNC_NO_TRN"
 1275      .xeq KV$INT KV_TRNTKNTYP_E INPFNC_NO_TRN
 1276      ..::IT "KV_TRNTKNTYP_NXTTBL"
 1277      .xeq KV$INT KV_TRNTKNTYP_E NXTTBL
 1278      ..::TB
 1279      */
 1280
 1281                2 INPTKN$ PTR %INIT(ADDR(INPTKN))%ENIT,
 1282
 1283      /*K* SPCESC$ - PTR.
 1284      Special escape table pointer.  SPCESC$ points to a bit array, which
 1285      when indexed by an original character during input
 1286      translation, yields a flag indicating that the character
 1287      should cause an escape from normal translation early in the
 1288      translation process.  See KV$USR_EXTINPTRN. */
 1289
14:54 JUL 28 '97 KV$INT.:E05SI                                             36   
 1290                2 SPCESC$ PTR %INIT(ADDR(SPCESC))%ENIT,
 1291
 1292      /*K* INPCHRMSK - BIT(16).
 1293      Input character mask.  All input characters are masked by
 1294      this value, usually for stripping parity bits. */
 1295
 1296                2 %CHARTEXT('INPCHRMSK') BIT(16)%INIT(%BINBIT(BITBIN(INPCHRMSK), 16))%ENIT,
 1297
 1298      /*K* OTPESCCHR - UBIN WORD.
 1299      Output escape character.  (Escape does not necessarily refer to
 1300      the ASCII ESC character, but to the concept of escape mechanisms.)
 1301      If this value is less than X'100', it defines an output escape character.
 1302      During a transparent output operation (e.g., KV$VDH_OTPLCL), each
 1303      time this character is encountered it will be replaced with
 1304      KV$TRNTBL.OTPESCCHRBFR1 and possibly KV$TRNTBL.OTPESCCHRBFR2.
 1305      During normal output translation, if the primary output table translates
 1306      a character into this one, the character must be translated via the
 1307      secondary table(s). */
 1308
 1309                2 %CHARTEXT('OTPESCCHR') UBIN %INIT(OTPESCCHR)%ENIT,
 1310
 1311      /*K* OTPESC.CHR - CHAR(1).
 1312      Is a redefinition of the lower half of OTPESCCHR so it is convenient for
 1313      PL-6 to use.  OTPESC.NONE - BIT(8) redefines the upper half to facilitate
 1314      testing for the existence of OTPESCCHR. */
 1315
 1316                2 OTPESC REDEF %CHARTEXT('OTPESCCHR'),
 1317                3 NONE BIT(8), 3 CHR CHAR(1),
 1318
 1319      /*K* OTPESCCHRBFR1 - CHAR(1).
 1320      Contains the first character to buffer for transparent output of OTPESCCHR (q.v.).
 1321      OTPESCCHR1 is the keyword name used to initialize this field.  */
 1322      /*K* OTPESCCHRBFR2 - CHAR(1).
 1323      Contains the second character to buffer for transparent output of OTPESCCHR
 1324      (q.v.).  OTPESCCHR2 is the keyword name used to initialize this field.
 1325      If OTPESCCHRBFR2 is BINASC(0), then no second character is to be buffered.
 1326      Setting OTPESCCHRBFR1 to the same character as OTPESCCHR and OTPESCCHRBFR2
14:54 JUL 28 '97 KV$INT.:E05SI                                             37   
 1327      to BINASC(0) is useful, for example, if secondary translation tables are
 1328      needed, but there is no need for an escape mechanism in the actual output
 1329      stream. */
 1330
 1331                2 OTPESCCHRBFR1 CHAR(1) %INIT(OTPESCCHR1)%ENIT,
 1332                2 OTPESCCHRBFR2 CHAR(1) %INIT(OTPESCCHR2)%ENIT,
 1333
 1334      /*K* FNTCLS - UBIN BYTE.
 1335      Font Class.  FNTCLS is used to quickly determine what character set a
 1336      particular translation table describes.  The following table lists
 1337      identifiers for FNTCLS.
 1338      ..::TB "^\Identifier\#20\Meaning"
 1339      .xeq KV$INT KV_FNTCLS_E KV_FNTCLS_APLB
 1340      .xeq KV$INT KV_FNTCLS_E KV_FNTCLS_APLT
 1341      .xeq KV$INT KV_FNTCLS_E KV_FNTCLS_ASC
 1342      .xeq KV$INT KV_FNTCLS_E KV_FNTCLS_EBC
 1343      ..::TB
 1344      */
 1345
 1346                2 %CHARTEXT('FNTCLS') UBIN BYTE CALIGNED %INIT(FNTCLS)%ENIT,
 1347
 1348      /*K* SP_CHR - CHAR(1).
 1349      Space character.  SP_CHR contains the character to send to the real
 1350      device to effect a space or blank. */
 1351
 1352                2 %CHARTEXT('SP_CHR') CHAR(1)%INIT(SP_CHR)%ENIT,
 1353
 1354      /*K* HT_CHR - CHAR(1).
 1355      Horizontal tab character.  Contains the character to send to the real
 1356      device to effect a horizontal tab operation. */
 1357
 1358                2 %CHARTEXT('HT_CHR') CHAR(1)%INIT(HT_CHR)%ENIT,
 1359
 1360      /*K* INPCTRSTRINTCHR - CHAR(1).
 1361      Contains the input control string introducer character. */
 1362
 1363                2 %CHARTEXT('INPCTRSTRINTCHR') CHAR(1)%INIT(INPCTRSTRINTCHR)%ENIT,
14:54 JUL 28 '97 KV$INT.:E05SI                                             38   
 1364
 1365      /*K* PRTAPL - BIT(1).
 1366      Partial APL Mode.  If PRTAPL is set, 'lowercase' APL
 1367      characters print as uppercase, as opposed to underscored uppercase. */
 1368
 1369                2 %CHARTEXT('PRTAPL') BIT(1)%INIT(PRTAPL)%ENIT,
 1370
 1371      /*K* DRCOTPTRN - BIT(1).
 1372      Direct output translation.  If this flag is set, translation is
 1373      performed as follows.  Translation for all characters is
 1374      one character out for each character in.  Each character causes
 1375      positioning one column to the right.  No VDH-user
 1376      interaction is required to carry out the translation,
 1377      and the translation can be done in the primary output
 1378      translate table.
 1379
 1380      For this flag to be set, no entries in the primary output
 1381      translate table must match OTPESCCHR. */
 1382
 1383                2 %CHARTEXT('DRCOTPTRN') BIT(1)%INIT(DRCOTPTRN)%ENIT,
 1384
 1385      /*K* TRNINPCTRSTRID - BIT(1).
 1386      Translate input control string ID.  If this flag is set, an input
 1387      control string ID character should be translated before trying to
 1388      interpret the string with input function tables.  If this flag is
 1389      not set, the character is used as-is. */
 1390
 1391                2 %CHARTEXT('TRNINPCTRSTRID') BIT(1)%INIT(TRNINPCTRSTRID)%ENIT LAST
 1392
 1393      %MEND;
 1394
 1395      /*F* NAME:  KV_FNTCLS_E
 1396      */
 1397      /*K* KV_FNTCLS_ASC
 1398      KV_FNTCLS_ASC                 ASCII (normal)                     */
 1399      /*K* KV_FNTCLS_APLB
 1400      KV_FNTCLS_APLB                ASCII APL, bit-paired              */
14:54 JUL 28 '97 KV$INT.:E05SI                                             39   
 1401      /*K* KV_FNTCLS_APLT
 1402      KV_FNTCLS_APLT                ASCII APL, typewriter-paired       */
 1403      /*K* KV_FNTCLS_EBC
 1404      KV_FNTCLS_EBC                 EBCDIC (normal)                    */
 1405
 1406      /*F* NAME: KV$PRMINPTRN - VDH Primary Input Translate Table
 1407
 1408      KV$PRMINPTRN is the primary input translate table.
 1409      */
 1410
 1411      %MACRO KV$PRMINPTRN(NAME = KV$PRMINPTRN, LAST = ";", STCLASS = BASED);
 1412      %LSET LISTDIR = '0'B;
 1413      %LSET LISTEXP = '1'B;
 1414      %LSET LISTCOM = '0'B;
 1415      %LSET LISTSUB = '1'B;
 1416      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1417      %ERROR((STR = 'STA')OR(STR = 'CON')OR STR = 'EXT'), 'Use KV_PRMINPTRN to INIT');
 1418      DCL 1 NAME STCLASS ALIGNED,
 1419
 1420      /*K* CHR - UBIN BYTE ARRAY.
 1421      Contains the input translation table characters and tokens.  The
 1422      array contains a maximum of 256 entries.  See KV$TRNTBL.INPTKN for
 1423      additional information.
 1424      */
 1425
 1426            2 CHR(0:255) UBIN BYTE UNAL LAST
 1427
 1428      %MEND;
 1429
 1430      /*F* NAME: KV$SCNINPTRN - VDH Secondary Input Translate Table
 1431
 1432      KV$SCNINPTRN is the secondary input translate table.
 1433      */
 1434      %MACRO KV$SCNINPTRN(NAME = KV$SCNINPTRN, LAST = ";", STCLASS = BASED);
 1435      %LSET LISTDIR = '0'B;
 1436      %LSET LISTEXP = '1'B;
 1437      %LSET LISTCOM = '0'B;
14:54 JUL 28 '97 KV$INT.:E05SI                                             40   
 1438      %LSET LISTSUB = '1'B;
 1439      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1440      %ERROR((STR = 'STA')OR(STR = 'CON')OR STR = 'EXT'), 'Use KV_SCNINPTRN to INIT');
 1441      DCL 1 NAME STCLASS ALIGNED,
 1442
 1443      /*K* TKNTBL - BIT(1) ARRAY.
 1444      Contains the secondary input translation table token array.  The
 1445      array contains a maximum of 64 entries.  If set when indexed by the
 1446      primary token ID, a bit in this array indicates that CHR indexed by
 1447      the same contains a token instead of a character.  See KV$TRNTBL.INPTKN.  */
 1448
 1449            2 TKNTBL(0:63) BIT(1),
 1450
 1451      /*K* CHR - UBIN BYTE ARRAY.
 1452      Contains the input translation table characters and tokens.  See TKNTBL.  */
 1453
 1454            2 CHR(0:0) UBIN BYTE UNAL LAST
 1455
 1456      %MEND;
 1457
 1458      /*F* NAME: KV$PRMOTPTRN - Primary Output Translate Table
 1459
 1460      KV$PRMOTPTRN is used to view the primary output translate table.
 1461      KV$PRMOTPTRN is a 256 byte CHAR(1) array which, when indexed by the
 1462      value of an untranslated character, yields the translated value.
 1463      If the translated value is KV$TRNTBL.OTPESCCHR, then the character
 1464      must be translated using the secondary output translate table.
 1465      */
 1466
 1467      %MACRO KV$PRMOTPTRN(NAME = KV$PRMOTPTRN, LAST = ";", STCLASS = BASED);
 1468      %LSET LISTDIR = '0'B;
 1469      %LSET LISTCOM = '0'B;
 1470      %LSET LISTSUB = '1'B;
 1471      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1472      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1473      %ERROR ('Use KV_PRMOTPTRN for initialized versions');
 1474      %ENDIF;
14:54 JUL 28 '97 KV$INT.:E05SI                                             41   
 1475      DCL 1 NAME STCLASS ALIGNED,
 1476
 1477      /*K* CHR - CHAR(1) ARRAY.
 1478      Contains the output translation table characters.  The
 1479      array contains 256 entries.
 1480      */
 1481
 1482            2 CHR(0:255) CHAR(1)LAST
 1483
 1484      %MEND;
 1485
 1486      /*F* NAME: KV$SCNOTPTRN - Secondary Output Translate Table
 1487
 1488      KV$SCNOTPTRN is used to view the secondary output translate table.  The table
 1489      consists of two lists and two arrays of bits.  Each of these items
 1490      contains NAME.CNT entries.  The first list (at NAME.CHR) contains
 1491      the characters represented in this table; it is immediately followed by
 1492      a parallel list of translated values.  At PINCRW(ADDR(NAME), NAME.CNT)
 1493      is the start of the two contiguous BIT arrays
 1494      which describe the meaning of the translated value.  CHR is redefed as
 1495      CHRA, an array of characters.  If N is the index into CHR of the untranslated
 1496      character, CHRA(N+NAME.CNT) contains the translated value.  BIT(N) true
 1497      indicates "normal" translation, for which BIT(N+NAME.CNT) true indicates
 1498      that the character also positions exactly one space to the right. BIT(N)
 1499      false indicates that CHRA(N+NAME.CNT) is one of the function codes
 1500      listed in the following table (if BIT(N+NAME.CNT) is true),
 1501      or is an index into the extended translate table(s) (if BIT(N+NAME.CNT)
 1502      is false).
 1503      ..::TB "^\Identifier\#20\Meaning"
 1504      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_BS
 1505      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_CR
 1506      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_HOM
 1507      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_HT
 1508      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_LF
 1509      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_NXTTBL
 1510      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_SP
 1511      .xeq KV_GLBCNS_E KV_OTPFNC_E KV_OTPFNC_SPCLF
14:54 JUL 28 '97 KV$INT.:E05SI                                             42   
 1512      ..::TB
 1513      */
 1514      %MACRO KV$SCNOTPTRN(NAME = KV$SCNOTPTRN, LAST = ";", STCLASS = BASED);
 1515      %LSET LISTDIR = '0'B;
 1516      %LSET LISTEXP = '1'B;
 1517      %LSET LISTCOM = '0'B;
 1518      %LSET LISTSUB = '1'B;
 1519      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1520      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1521      %ERROR ('Use KV_SCNOTPTRN to build initialized ones');
 1522      %ENDIF;
 1523      DCL 1 NAME STCLASS ALIGNED,
 1524
 1525      /*K*  CNT - UBIN BYTE.  Specifies the number of characters represented
 1526      in this secondary translate table.                                */
 1527            2 CNT UBIN BYTE UNAL,
 1528      /*K*  CHR - CHAR(1) ARRAY.  Contains a list of the characters represented
 1529      in this secondary translate table.  */
 1530            2 CHRA(0:0) CHAR(1),
 1531            2 CHR REDEF CHRA CHAR(NAME.CNT) LAST
 1532
 1533      %MEND;
 1534
 1535
 1536      /*F* NAME: KV$EXTOTPTRN - Extended Output Translate Table
 1537
 1538      KV$EXTOTPTRN contains the extended output translate table.
 1539      */
 1540
 1541      %MACRO KV$EXTOTPTRN (NAME = , STCLASS = BASED, TEMPLATE = , WDT = 1, LNK = NIL, TXTSIZ = 0,
 1542                           TEXT = , CNT = 0, START = 0, TRN(YES = '1'B, NO = '0'B) = '1'B);
 1543      %LSET LISTDIR = '0'B;
 1544      %LSET LISTEXP = '1'B;
 1545      %LSET LISTCOM = '0'B;
 1546      %LSET LISTSUB = '1'B;
 1547      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1548      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
14:54 JUL 28 '97 KV$INT.:E05SI                                             43   
 1549      %LSET INIT = CHARTEXT('INIT');
 1550      %LSET ENIT = CHARTEXT('');
 1551      %LSET STR = SUBSTR(STR, 0, 0);
 1552      %ELSE;
 1553      %LSET INIT = CHARTEXT('/*');
 1554      %LSET ENIT = CHARTEXT('*/');
 1555      %ENDIF;
 1556      %LSET NAM = TEXTCHAR(NAME);
 1557      %IF LENGTHC(NAM) = 0 AND LENGTHC(STR) > 0;  /* NON-INIT WO NAME                   */
 1558       %IF LENGTHC(TEXTCHAR(TEXT)) = 0;
 1559       %LSET NAM = 'KV$EXTOTPTRN';
 1560       %ELSE;
 1561       %LSET STR = NAM;
 1562       %ENDIF;
 1563      %ENDIF;
 1564      %IF LENGTHC(NAM) > 0;
 1565      DCL 1 %CHARTEXT(NAM) STCLASS ALIGNED,
 1566       %LSET H2C_C = ' ';
 1567       %IF LENGTHC(STR) = 0;
 1568        %SET KV_EXTOTPX = START;
 1569        %SET KV_EXTOTPMAX = KV_EXTOTPX+CNT;
 1570        %SET KV_EXTOTPTSZ = TXTSIZ;
 1571        %HEX2CHR (INPCHR = TEMPLATE);
 1572       %ENDIF;
 1573      /*K* LNK$ - PTR.
 1574      */
 1575            2 LNK$ PTR %INIT(ADDR(LNK))%ENIT,
 1576      /*K* CNT - UBIN BYTE.
 1577      */
 1578            2 %CHARTEXT('CNT') UBIN BYTE UNAL %INIT(CNT)%ENIT,
 1579      /*K* TRN - BIT(1).
 1580      */
 1581            2 %CHARTEXT('TRN') BIT(1) %INIT(TRN)%ENIT,
 1582      /*K* TXTSIZ - UBIN(7).
 1583      */
 1584            2 %CHARTEXT('TXTSIZ') UBIN(7) UNAL %INIT(TXTSIZ)%ENIT,
 1585      /*K* WDT - SBIN BYTE.
14:54 JUL 28 '97 KV$INT.:E05SI                                             44   
 1586      */
 1587            2 %CHARTEXT('WDT') SBIN BYTE UNAL %INIT(WDT)%ENIT,
 1588       %IF LENGTHC(STR)+TXTSIZ > 0;        /* END OF REQUIRED ITEMS FOR USER TABLES   */
 1589      /*K* TMPLATSIZ - UBIN BYTE.
 1590      ?????.   Is this initialized via the keyword TEMPLATE?????
 1591      */
 1592            2 TMPLATSIZ UBIN BYTE UNAL %INIT(%LENGTHC(H2C_C))%ENIT,
 1593        %IF LENGTHC(STR) > 0;
 1594      /*K* TXT - CHAR(1).  Contains.....   Is this initialized via
 1595      the keyword TEXT????*/
 1596            2 TXT CHAR(1);
 1597      /*K* H2C_C - ???.  Should this even be a K comment???
 1598      */
 1599        %ELSEIF LENGTHC(H2C_C) > 0;
 1600            2 * CHAR(0) INIT(%H2C_C),
 1601        %ENDIF;
 1602       %ENDIF;
 1603      %ENDIF;                                 /* IF BUILDING A HEADER               */
 1604      %IF LENGTHC(STR) = 0;
 1605      %HEX2CHR (INPCHR = TEXT);
 1606       %IF LENGTHC(H2C_C) > 0;
 1607       %ERROR (MOD(LENGTHC(H2C_C), KV_EXTOTPTSZ) ~= 0, '*** Partial TEXT entry attempted');
 1608       %SET KV_EXTOTPX = %KV_EXTOTPX+LENGTHC(H2C_C)/KV_EXTOTPTSZ;
 1609       %ERROR(KV_EXTOTPX > KV_EXTOTPMAX, '*** Too many TEXT entries defined here');
 1610       %LSET LST = CHARTEXT(SUBSTR(',;', BITBIN(KV_EXTOTPX = KV_EXTOTPMAX), 1));
 1611            2 * CHAR(0) INIT(%H2C_C)%LST
 1612       %ENDIF;
 1613      %ENDIF;
 1614
 1615      %MEND;
 1616
 1617      /*F* NAME:  KV_TRNTKNTYP_E
 1618      Token Type Definitions. */
 1619
 1620      %MACRO KV_TRNTKNTYP_E;
 1621
 1622      /*K* NXTTBL
14:54 JUL 28 '97 KV$INT.:E05SI                                             45   
 1623      Valid only in PRMINPTRN; means ID is index
 1624      into SCNINPTRN.
 1625      */
 1626      %EQU KV_TRNTKNTYP_NXTTBL = 0;
 1627      /*K* EXTTRN
 1628      Means call the user with
 1629      KV$USR_EXTINPTRN.ID is placed in the
 1630      FPT.
 1631      */
 1632      %EQU KV_TRNTKNTYP_EXTTRN = 1;
 1633      /*K* INPFNC_NO_TRN
 1634      The character is probably defined as a
 1635      special character in the input function tables,
 1636      but if not, the character should be used as-is
 1637      (no translation is needed).  ID is the
 1638      input-function-table index.
 1639      */
 1640      %EQU KV_TRNTKNTYP_INPFNC_NO_TRN = 2;
 1641      /*K* INPFNC
 1642      SCNINPTRN only; same as INPFNC_NO_TRN, but
 1643      use the translated value to look up the function,
 1644      if needed, or if the function is not defined.
 1645      The translated value is at KV$SCNINPTRN.CHR
 1646      indexed by the primary table's token ID + 1.
 1647      */
 1648      %EQU KV_TRNTKNTYP_INPFNC = 3;
 1649
 1650      %MEND;
 1651
 1652
 1653      /*F* NAME: KV$TYPAHDBFR VDH HANDLER TYPE-AHEAD BUFFER DESCRIPTION */
 1654
 1655      /* VDH HANDLER TYPE-AHEAD BUFFER ITEM DEFINITIONS. */
 1656
 1657
 1658      %MACRO KV$TYPAHDBFR(NAME = KV$TYPAHDBFR, LAST = ";", STCLASS = BASED);
 1659      %LSET LISTDIR = '0'B;
14:54 JUL 28 '97 KV$INT.:E05SI                                             46   
 1660      %LSET LISTEXP = '1'B;
 1661      %LSET LISTCOM = '0'B;
 1662      %LSET LISTSUB = '1'B;
 1663      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1664      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1665      %IF STC = 1;
 1666      %LSET INIT = CHARTEXT('INIT');
 1667      %LSET ENIT = CHARTEXT('');
 1668      %ELSE;
 1669      %LSET INIT = CHARTEXT('/*');
 1670      %LSET ENIT = CHARTEXT('*/');
 1671      %ENDIF;
 1672      %LSET FEP = BITBIN(MODE_FEP);
 1673      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1674      %LSET KV_FILBIT = CONCAT(' 2  * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1675      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
 1676      DCL 1 NAME STCLASS %KV_DBLBYTALG,
 1677
 1678      /* LINK TO THE NEXT TYPE-AHEAD BUFFER IN THE CHAIN. */
 1679
 1680            2 LNK$ PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
 1681      %KV_FILBIT
 1682
 1683      /* Input function text.  This buffer was created by an */
 1684      /* input function, rather than from text directly from */
 1685      /* the device. */
 1686
 1687            2 INPFNCTXT BIT(1) %INIT('0'B)%ENIT,
 1688
 1689      /* INDEX (INTO KV$TYPAHDBFR_CHR). */
 1690
 1691            2 CHRX UBIN(7) UNAL %INIT(6)%ENIT,
 1692
 1693      /* HI INDEX (INTO KV$TYPAHDBFR_CHR). */
 1694
 1695            2 CHRX_HI UBIN BYTE CALIGNED %INIT(5)%ENIT LAST
 1696
14:54 JUL 28 '97 KV$INT.:E05SI                                             47   
 1697      /* CHARACTERS IN THE TYPE-AHEAD BUFFERS. */
 1698
 1699      %IF FEP = 1;
 1700      DCL 1 NAME%CHARTEXT('_CHR(0:5)') REDEF NAME CHAR(1)LAST
 1701      %ENDIF;
 1702
 1703      /* MAX INDEX INTO A STANDARD BUFFER */
 1704
 1705      %SET                                       KV_TYPAHDBFR_CHRX_HI = 31;
 1706
 1707      %MEND;
 1708
 1709      /*F* NAME: KV$VFU - VDH VFU Structure
 1710
 1711      This structure contains the VFU image for a given form.  It is pointed
 1712      to by KV$MVD.VFU$.  Entries 1-15 define the primary punches for
 1713      channels 1-15.  An entry of 0 here means there is no punch for that
 1714      channel.
 1715      */
 1716
 1717      %MACRO KV$VFU(NAME = KV$VFU, LAST = ";", STCLASS = BASED);
 1718      %LSET LISTDIR = '0'B;
 1719      %LSET LISTEXP = '1'B;
 1720      %LSET LISTCOM = '0'B;
 1721      %LSET LISTSUB = '1'B;
 1722      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1723      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1724      %LSET INIT = CHARTEXT('INIT');
 1725      %LSET ENIT = CHARTEXT('');
 1726      %ELSE;
 1727      %LSET INIT = CHARTEXT('/*');
 1728      %LSET ENIT = CHARTEXT('*/');
 1729      %ENDIF;
 1730      %KV$SHRBFR (NAME = NAME, STCLASS = STCLASS, LAST = ",");
 1731
 1732      /*K* LIN - UBIN BYTE ARRAY.  Contains line number associated with a
 1733      hole punched in this channel.  */
14:54 JUL 28 '97 KV$INT.:E05SI                                             48   
 1734
 1735            2 LIN(0:31) UBIN BYTE CALIGNED %INIT(0*0)%ENIT,
 1736
 1737      /*K* NXT - UBIN BYTE ARRAY.  Contains an array of the
 1738      alternate channel indexes for this channel, to be used if KV$VFU.LIN
 1739      indicates a position above the current one, or past the end of the
 1740      page. */
 1741
 1742            2 NXT(0:31) UBIN BYTE CALIGNED %INIT(0*0)%ENIT LAST
 1743      %MEND;
 1744      /*F* NAME:  KV$X364 - X364 Virtual Device Context
 1745
 1746      The KV$X364 structure contains context for an ANS X3.64 virtual device.
 1747      This context is pointed to by KV$MVD.LINLST$.
 1748      */
 1749      %MACRO KV$X364 (NAME = KV$X364, STCLASS = BASED, LVL = 1, LAST = ";");
 1750      %LSET LISTDIR = '0'B;
 1751      %LSET LISTEXP = '1'B;
 1752      %LSET LISTCOM = '0'B;
 1753      %LSET LISTSUB = '1'B;
 1754      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1755      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1756      %IF STC = 1;
 1757      %LSET INIT = CHARTEXT(' INIT');
 1758      %LSET ENIT = CHARTEXT('');
 1759      %ELSE;
 1760      %LSET INIT = CHARTEXT('/*');
 1761      %LSET ENIT = CHARTEXT('*/');
 1762      %LSET Y#STT_WATCSI = 0;
 1763      %ENDIF;
 1764      %LSET FEP = BITBIN(MODE_FEP);
 1765      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1766      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1767      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
 1768      %IF LVL = 1;
 1769      DCL 1 NAME %KV_DBLBYTALG STCLASS,
 1770      %ELSE;
14:54 JUL 28 '97 KV$INT.:E05SI                                             49   
 1771      %IF TEXTCHAR(NAME) ~= '';
 1772      %(LVL) NAME,
 1773      %ENDIF;
 1774      %ENDIF;
 1775      %IF TEXTCHAR(STCLASS) = 'BASED' AND TEXTCHAR(NAME) = 'KV$X364';
 1776      %EQU KV_X364 = CHARTEXT('KV$PTR.MVD$->KV$MVD.LINLST$->KV$X364');
 1777      %ENDIF;
 1778      %(LVL+1) %CHARTEXT('STT') UBIN(%(18-2*FEP))  %KV_DBLBYTALG %INIT(%Y#STT_WATCSI)%ENIT,
 1779      /*K* STT - UBIN WORD.  State.  Identifiers for the STT values are
 1780      listed in the following table.
 1781      ..::TB "^\Identifier\#10\Meaning"
 1782      .xeq KVO$X364 KV_Y#STT_E RCVERR
 1783      .xeq KVO$X364 KV_Y#STT_E RCVEXPP
 1784      .xeq KVO$X364 KV_Y#STT_E RCVI
 1785      .xeq KVO$X364 KV_Y#STT_E RCVP
 1786      .xeq KVO$X364 KV_Y#STT_E WATCSI
 1787      .xeq KVO$X364 KV_Y#STT_E WATFE
 1788      .xeq KVO$X364 KV_Y#STT_E WATTKN
 1789      ..::TB
 1790      */
 1791      %(LVL+1) %CHARTEXT('P_X') SBIN(%(18-2*FEP))  %KV_DBLBYTALG %INIT(-1)%ENIT,
 1792      /*K* P_X - SBIN WORD.  Is the index in P_VAL to the current P (parameter).
 1793      0 indicates there are no entries in P_VAL currently.
 1794      */
 1795      %SET KV#X364_P_MAXX = 16;               /* Max number of P (parameters) - 1   */
 1796      %(LVL+1) %CHARTEXT('P_VAL')(0:%KV#X364_P_MAXX) SBIN(%(18-2*FEP))  %KV_DBLBYTALG %INIT(-1*0)%ENIT LAST
 1797      /*K* P_VAL - SBIN WORD ARRAY.  Is indexed by P_X, yielding the numeric
 1798      value associated by the numeric parameter in the control sequence.
 1799      */
 1800      %MEND;
 1801
 1802      /*F* NAME: KV$SHRBFR_PRM  - VDH Prompt Structure
 1803
 1804      This structure contains the prompt text and control information. */
 1805
 1806      %MACRO KV$SHRBFR_PRM(NAME = KV$SHRBFR_PRM, LAST = ";", STCLASS = BASED,
 1807      VFC = '0'B, TXT = ' ', TXTDCLBYTSIZ = 0, LNK = NIL, NAM = '');
14:54 JUL 28 '97 KV$INT.:E05SI                                             50   
 1808      %LSET LISTDIR = '0'B;
 1809      %LSET LISTEXP = '1'B;
 1810      %LSET LISTCOM = '0'B;
 1811      %LSET LISTSUB = '1'B;
 1812      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1813      %IF (STR = 'STA')OR(STR = 'CON')OR(STR = 'EXT');
 1814      %LSET INIT = CHARTEXT('INIT');
 1815      %LSET ENIT = CHARTEXT('');
 1816      %ELSE;
 1817      %LSET INIT = CHARTEXT('/*');
 1818      %LSET ENIT = CHARTEXT('*/');
 1819      %ENDIF;
 1820      %KV$SHRBFR (NAME = NAME, STCLASS = STCLASS, LAST = ",", LNK = LNK, LVL = 1, NAM = NAM);
 1821      /*K* LNK$ - PTR.
 1822      .xeq KV$GLB KV$SHRBFR__ LNK$
 1823      */
 1824
 1825      /*K* VFC - UBIN BYTE.  Contains the VFC character.*/
 1826
 1827              2 %CHARTEXT('VFC') UBIN BYTE CALIGNED %INIT(%BITBIN(VFC))%ENIT,
 1828
 1829      /*N* Text (of prompt) */
 1830      /*K* TXT.  Contains the text of prompt.*/
 1831
 1832                2 %CHARTEXT('TXT') CHAR(TXTDCLBYTSIZ) CALIGNED %INIT(TXT)%ENIT LAST
 1833      %MEND;

