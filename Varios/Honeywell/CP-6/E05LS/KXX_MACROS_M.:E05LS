

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  1    
    1      /*T***********************************************************/
    2      /*T*                                                         */
    3      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    4      /*T*                                                         */
    5      /*T***********************************************************/
    6      /* X.29 handler context block definition */
    7
    8      %MACRO KX$X29(FPTN = KX$X29, LVL = 1, LAST = ";", STCLASS = BASED);
    9
   10      %LSET LISTDIR = '0'B;
   11      %LSET LISTEXP = '1'B;
   12      %LSET LISTCOM = '0'B;
   13      %LSET LISTSUB = '1'B;
   14      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   15      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   16      %IF STC = 1;
   17      %LSET INIT = CHARTEXT(' INIT');
   18      %LSET ENIT = CHARTEXT('');
   19      %ELSE;
   20      %LSET INIT = CHARTEXT('/*');
   21      %LSET ENIT = CHARTEXT('*/');
   22      %ENDIF;
   23      %LSET FEP = BITBIN(MODE_FEP);
   24      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
   25      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
   26      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
   27      %IF LVL = 1;
   28      DCL 1 FPTN STCLASS %KX_DBLBYTALG,
   29      %ELSE;
   30      %(LVL) FPTN,
   31      %ENDIF;
   32
   33
   34      /* Entry point used by the connection manager. */
   35            %(LVL+1) SBR$ EPTR %KX_DBLBYTALG %INIT(ENTADDR(KXX$X29))%ENIT,
   36
   37      /* Pointer to the virtual device interface context block (KV$VDI). */
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  2    
   38
   39            %(LVL+1) VDI$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   40
   41      /* Channel table pointer */
   42
   43            %(LVL+1) CHN$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   44
   45      /* Virtual cirtual context pointer */
   46
   47            %(LVL+1) L3$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   48
   49      /* Input buffer chain */
   50
   51            %(LVL+1) INPBFR,
   52
   53               %(LVL+2) HED$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   54
   55               %(LVL+2) TAL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   56
   57            %(LVL+1) SND,
   58
   59      /* Output buffer head pointer */
   60
   61               %(LVL+2) HED$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   62
   63      /* Output buffer: pointer to next buffer to IOLD */
   64
   65               %(LVL+2) NXTLOD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   66
   67      /* Output buffer tail pointer */
   68
   69               %(LVL+2) TAL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   70
   71      /* Output buffer byte count.  Total number of bytes consumed */
   72      /* by output buffers for this user, including buffer over-head. */
   73
   74            %(LVL+1) OTPBFRBYTCNT UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%ENIT,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  3    
   75
   76      /* Output character count until halt for device flow control. */
   77
   78            %(LVL+1) OTPCHRCNTUTLHLT SBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%ENIT,
   79            %(LVL+1) * UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%ENIT,
   80
   81      /* Output halt flags; indexed by KA#HLTOTP_USRX (for */
   82      /* user halts such as ESC-H) or */
   83      /* KA#HLTOTP_DVCX (for device flow control halts). */
   84
   85      %KX_FILBIT
   86            %(LVL+1) HLTOTP,
   87              %(LVL+2) BITT(0:%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX)) BIT(1) %INIT('0'B*0)%ENIT,
   88            %(LVL+1) HLTOTP_ALL REDEF HLTOTP BIT(%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX+1)) UNAL,
   89
   90      /* Previous output buffer data exceeded (or equalled) small */
   91      /* buffer size. */
   92
   93            %(LVL+1) PRVOTPBFRDATEXCSML BIT(1) %INIT('0'B)%ENIT,
   94
   95      /* Drop DTR (data-set-ready) pending.  We're dropped DTR, and */
   96      /* the clock has been set to time it.  It may have gone off. */
   97
   98            %(LVL+1) DRPDTRPND BIT(1) %INIT('0'B)%ENIT,
   99
  100      /* Send X.3 param. After the VDH set params are done, we need to */
  101      /* send an X.29 message to update the X.3 params in the PAD.     */
  102
  103            %(LVL+1) SNDX3PRM BIT(1) %INIT('0'B)%ENIT,
  104
  105      /* Wait for param. We are expecting parameter indication messages */
  106      /* from the PAD.                                                  */
  107
  108            %(LVL+1) WAT4PRM UBIN (3) UNAL %INIT(0)%ENIT,
  109
  110            %(LVL+1) VDILINSPD UBIN BYTE CALIGNED %INIT(0)%ENIT,
  111
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  4    
  112      /* Halt output on next output buffer acquired. */
  113      /* Indexed like KA$CTX.HLTOTP_BIT. */
  114
  115      %KX_FILBIT
  116            %(LVL+1) HLTOTPNXTBFR,
  117              %(LVL+2) BITT(0:%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX)) BIT(1) %INIT('0'B*0)%ENIT,
  118            %(LVL+1) HLTOTPNXTBFR_ALL REDEF HLTOTPNXTBFR BIT(%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX+1)) UNAL,
  119
  120      /* Asynchronous output halt; set if the comm line controller was */
  121      /* asynchronously told to halt, via the KA#ASNRQSHLTOTP/KAO$ASNRQSHLTOTP */
  122      /* mechanism. */
  123
  124            %(LVL+1) ASNHLTOTP BIT(1) %INIT('0'B)%ENIT,
  125      /* Report data. Call packet level to say we have data to send.    */
  126
  127            %(LVL+1) RPRDAT BIT(1) %INIT('1'B)%ENIT,
  128
  129      /* VDHEXTCAL indicates whether we are running on the VDHEXT thread. */
  130
  131            %(LVL+1) VDHEXTCAL BIT(1) %INIT('0'B)%ENIT,
  132
  133
  134      /* Line error disconnect count.  Number of line errors */
  135      /* (parity and framing errors, and CLA over-runs) in */
  136      /* approximately the last minute.  See KA_LINERRDSCLMT. */
  137
  138            %(LVL+1) LINERRDSCCNT UBIN BYTE CALIGNED %INIT(0)%ENIT,
  139
  140      /* Line error log count.  Number of line errors */
  141      /* (parity and framing errors, and CLA over-runs) since */
  142      /* last logging (ERRLOG) the errors.  See KA_LINERRLOGLMT. */
  143
  144            %(LVL+1) LINERRLOGCNT UBIN BYTE CALIGNED %INIT(0)%ENIT,
  145
  146      /* Number of ERROR_PAD messages received. If exceeding a threshold, */
  147      /* clear the circuit.                                               */
  148
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  5    
  149            %(LVL+1) ERR_PAD UBIN BYTE CALIGNED %INIT(0)%ENIT,
  150
  151      /* This field has been removed                                      */
  152
  153            %(LVL+1) * UBIN BYTE CALIGNED %INIT(0)%ENIT,
  154
  155      /* X.29 circuit state.                                              */
  156
  157            %(LVL+1) STATE UBIN BYTE CALIGNED %INIT(0)%ENIT,
  158
  159      /* Parity index. Byte index into current output buffer. Characters  */
  160      /* above this index have their output parity taken care of.         */
  161
  162            %(LVL+1) PRTX UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%ENIT,
  163
  164      /* Parity index for next buffer. This index is needed when we have  */
  165      /* a block of transparent/binary output which does not fit into the */
  166      /* the current buffer.                                              */
  167
  168            %(LVL+1) PRTX4NXTBFR UBIN (%(18-2*BITBIN(MODE_FEP))) %KX_DBLBYTALG %INIT(0)%ENIT,
  169
  170      /* X.3 parameters in operation.                                     */
  171
  172            %(LVL+1) X3PRM(0:17) UBIN BYTE CALIGNED %INIT(0*0)%ENIT;
  173
  174      %MEND;
  175      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  6    
  176      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  7    
  177      /* Colour book connection context block definition */
  178
  179      %MACRO KX$VC (FPTN = KX$VC, LVL = 1, LAST = ";", STCLASS = BASED);
  180
  181      %LSET LISTDIR = '0'B;
  182      %LSET LISTEXP = '1'B;
  183      %LSET LISTCOM = '0'B;
  184      %LSET LISTSUB = '1'B;
  185      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  186      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  187      %IF STC = 1;
  188      %LSET INIT = CHARTEXT(' INIT');
  189      %LSET ENIT = CHARTEXT('');
  190      %ELSE;
  191      %LSET INIT = CHARTEXT('/*');
  192      %LSET ENIT = CHARTEXT('*/');
  193      %ENDIF;
  194      %LSET FEP = BITBIN(MODE_FEP);
  195      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  196      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  197      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
  198      %IF LVL = 1;
  199      DCL 1 FPTN STCLASS %KX_DBLBYTALG,
  200      %ELSE;
  201      %(LVL) FPTN,
  202      %ENDIF;
  203
  204
  205      /* Entry point used by the connection manager. */
  206            %(LVL+1) SBR$ EPTR %KX_DBLBYTALG %INIT(ENTADDR(KXV$VCVDH))%ENIT,
  207
  208      /* Pointer to the virtual device interface context block (KV$VDI). */
  209
  210            %(LVL+1) VDI$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  211
  212      /* Channel table pointer */
  213
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  8    
  214            %(LVL+1) CHN$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  215
  216      /* Virtual cirtual context pointer */
  217
  218            %(LVL+1) L3$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  219
  220      /* link to other KX$VCs */
  221
  222            %(LVL+1) FLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  223
  224            %(LVL+1) BLNK$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  225
  226            %(LVL+1) SND,
  227
  228      /* Output buffer head pointer */
  229
  230               %(LVL+2) HED$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  231
  232      /* Output buffer: pointer to next buffer to IOLD */
  233
  234               %(LVL+2) NXTLOD$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  235
  236      /* Output buffer tail pointer */
  237
  238               %(LVL+2) TAL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  239
  240      /* control connection context pointer */
  241
  242            %(LVL+1) CNTL$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  243
  244      /* Output buffer byte count.  Total number of bytes consumed */
  245      /* by output buffers for this user, including buffer over-head. */
  246
  247            %(LVL+1) OTPBFRBYTCNT UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  248
  249      /* Threshold for throttling VDH */
  250
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  9    
  251            %(LVL+1) MAXOTPBYT UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(9999)%ENIT,
  252
  253            %KX_FILBIT
  254            %(LVL+1) RPRDAT BIT(1) UNAL %INIT('1'B)%ENIT,
  255            %(LVL+1) BLK_L3 BIT(1) UNAL %INIT('0'B)%ENIT,
  256            %(LVL+1) VDHENTERED BIT(1) UNAL %INIT('0'B)%ENIT,
  257            %(LVL+1) CALINDPND BIT(1) UNAL %INIT('0'B)%ENIT,
  258            %(LVL+1) CALCNFPND BIT(1) UNAL %INIT('0'B)%ENIT,
  259            %(LVL+1) X3PND REDEF CALCNFPND BIT(1) UNAL,
  260            %(LVL+1) INTINDPND BIT(1) UNAL %INIT('0'B)%ENIT,
  261            %(LVL+1) INTCNFPND BIT(1) UNAL %INIT('0'B)%ENIT,
  262            %(LVL+1) RSTINDPND BIT(1) UNAL %INIT('0'B)%ENIT,
  263            %KX_FILBIT
  264            %(LVL+1) RSTCNFPND BIT(1) UNAL %INIT('0'B)%ENIT,
  265            %(LVL+1) CLRINDPND BIT(1) UNAL %INIT('0'B)%ENIT,
  266            %(LVL+1) PHSDSC BIT(1) UNAL %INIT('0'B)%ENIT,    /* line has been killed */
  267            %(LVL+1) X28 BIT(1) UNAL %INIT('0'B)%ENIT,       /* are we speaking x28? */
  268            %(LVL+1) INV2CLR BIT(1) UNAL %INIT('0'B)%ENIT,   /* received an invitation to clear */
  269            %(LVL+1) RPRX3 BIT(1) UNAL %INIT('0'B)%ENIT,     /* report any x.3 change */
  270            %(LVL+1) X3_PRM_ALL BIT(1) UNAL %INIT('0'B)%ENIT,
  271            %(LVL+1) * BIT(1) UNAL %INIT('0'B)%ENIT,
  272            %KX_FILBIT
  273            %(LVL+1) X3_PRM_BITS BIT(%(26-2*FEP)) UNAL %INIT('0'B)%ENIT,
  274            %(LVL+1) X3_PRM_BIT(0:%(25-2*FEP)) REDEF X3_PRM_BITS BIT(1) UNAL,
  275      /* X.3 parameters in operation.                                     */
  276
  277            %(LVL+1) X3PRM(0:21) UBIN BYTE CALIGNED %INIT
  278              (1,1,2,0,0,0,21,0,0,0,14,0*0)%ENIT,
  279            %(LVL+1) ERRPADTYP UBIN BYTE CALIGNED %INIT(0)%ENIT,
  280            %(LVL+1) ERRPADCOD UBIN BYTE CALIGNED %INIT(0)%ENIT,
  281            %(LVL+1) RST_CAUSE UBIN BYTE CALIGNED %INIT(0)%ENIT,
  282            %(LVL+1) RST_DIAG UBIN BYTE CALIGNED %INIT(0)%ENIT,
  283            %(LVL+1) CALPKT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  284            %(LVL+1) CALMSGBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  285            %(LVL+1) CLRPKT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
  286            %(LVL+1) CLRMSGBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  287            %(LVL+1) INTPKT$ PTR %KX_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  10   
  288            %(LVL+1) INTMSGBYTSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  289
  290            %(LVL+1) RLCID,
  291              %(LVL+2) * BIT(%(18-2*FEP)) %INIT('0'B*0)%ENIT,
  292              %(LVL+2) LDCTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  293
  294            %(LVL+1) RLCID_STRING REDEF RLCID CHAR(4),
  295
  296      /* error code on previous write from host user */
  297      %LSET NXTLVL = LVL+1;
  298            %VLP_ERRCODE ( FPTN=ERCOD, ALGN=CALIGNED, LAST=",", STCLASS=STCLASS,
  299               LVL=NXTLVL );
  300
  301      /* KX$VC circuit state.                                              */
  302
  303            %(LVL+1) STATE UBIN BYTE CALIGNED %INIT(%KX_VC_ST_DCL#)%ENIT LAST
  304      %MEND;
  305      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  11   
  306      /* KX$VC OUTPUT BUFFER ITEM DEFINITIONS. */
  307
  308      %MACRO KX$VC_OTPBFR(FPTN = KX$VC_OTPBFR, LVL = 1, LAST = ";", STCLASS = BASED);
  309      %LSET LISTDIR = '0'B;
  310      %LSET LISTEXP = '1'B;
  311      %LSET LISTCOM = '0'B;
  312      %LSET LISTSUB = '1'B;
  313      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  314      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  315      %IF STC = 1;
  316      %LSET INIT = CHARTEXT(' INIT');
  317      %LSET ENIT = CHARTEXT('');
  318      %ELSE;
  319      %LSET INIT = CHARTEXT('/*');
  320      %LSET ENIT = CHARTEXT('*/');
  321      %ENDIF;
  322      %LSET FEP = BITBIN(MODE_FEP);
  323      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  324      %LSET KX_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  325      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT, FEP*LENGTHC(KX_FILBIT)));
  326      %IF LVL = 1;
  327      DCL 1 FPTN WALIGNED STCLASS,
  328      %ELSE;
  329      %(LVL) FPTN,
  330      %ENDIF;
  331
  332      /* LINK TO THE NEXT OUTPUT BUFFER IN THE CHAIN. */
  333
  334            %(LVL+1) LNK$ PTR %INIT(ADDR(NIL))%ENIT,
  335
  336            %KX_FILBIT
  337      /* Q-bit says to L3 that this is a control message.  */
  338
  339            %(LVL+1) Q BIT(1) UNAL %INIT('0'B)%ENIT,
  340
  341      /* M-bit says to L3 that this buffer is to be continued */
  342
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  12   
  343            %(LVL+1) M BIT(1) UNAL %INIT('0'B)%ENIT,
  344
  345      /* BFRBYTSIZ is the total size of the output buffer in bytes */
  346
  347            %(LVL+1) BFRBYTSIZ UBIN(%(15-FEP)) UNAL %INIT(0)%ENIT,
  348
  349      /* BYTX is the index of the first free byte in the buffer */
  350
  351            %(LVL+1) BYTX UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT,
  352
  353      /* RLSWRDSIZ is the size used to release this buffer */
  354
  355            %(LVL+1) RLSWRDSIZ UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(0)%ENIT LAST
  356      %MEND;
  357      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  13   
  358      /* X.29 HANDLER OUTPUT BUFFER ITEM DEFINITIONS. */
  359
  360      %MACRO KX$X29_OTPBFR(FPTN = KX$X29_OTPBFR, LVL = 1, LAST = ";", STCLASS = BASED);
  361      %LSET LISTDIR = '0'B;
  362      %LSET LISTEXP = '1'B;
  363      %LSET LISTCOM = '0'B;
  364      %LSET LISTSUB = '1'B;
  365      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  366      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  367      %LSET INIT = CHARTEXT(' INIT');
  368      %LSET ENIT = CHARTEXT('');
  369      %ELSE;
  370      %LSET INIT = CHARTEXT('/*');
  371      %LSET ENIT = CHARTEXT('*/');
  372      %ENDIF;
  373      %IF LVL = 1;
  374      DCL 1 FPTN WALIGNED STCLASS,
  375      %ELSE;
  376      %(LVL) FPTN,
  377      %ENDIF;
  378
  379      /* LINK TO THE NEXT OUTPUT BUFFER IN THE CHAIN. */
  380
  381            %(LVL+1) LNK$ PTR %INIT(ADDR(NIL))%ENIT,
  382
  383      /* OUTPUT HALT FLAGS; INDEXED LIKE KA$CTX.HLTOTP.BIT. */
  384      /* ANY BITS SET INDICATE WE SHOULD HALT OUTPUT SYNCHRONOUSLY WHEN THE */
  385      /* OUTPUT BUFFER IOLD ROUTINES ENCOUNTER THIS BUFFER. */
  386
  387            %(LVL+1) HLTOTP,
  388              %(LVL+2) BITT(0:%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX)) BIT(1) %INIT('0'B*0)%ENIT,
  389            %(LVL+1) HLTOTP_ALL REDEF HLTOTP BIT(%(KA#HLTOTP_HI_X-KA#HLTOTP_LOWX+1)) UNAL,
  390
  391      /* Byte size (of whole buffer), expressed as a base-2 log. */
  392
  393            %(LVL+1) BYTSIZLOG2 UBIN(4) UNAL %INIT(0)%ENIT,
  394
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  14   
  395      /* BYTE COUNT (NUMBER OF DATA CHARACTERS IN THE BUFFER). */
  396
  397            %(LVL+1) BYTCNT UBIN(10) UNAL %INIT(0)%ENIT,
  398
  399      /* NUMBER OF MARKERS (THEY ARE STORED AT THE BOTTOM OF THE BUFFER,
  400         IN REVERSE ORDER).  */
  401
  402            %(LVL+1) NMBMRK UBIN BYTE CALIGNED %INIT(0)%ENIT,
  403
  404      /* Q-bit says this is an X.29 message.  */
  405
  406            %(LVL+1) Q BIT(1) UNAL %INIT('0'B)%ENIT,
  407      /* DLT-bit says that this buffer has been deleted. */
  408
  409            %(LVL+1) DLT BIT(1) UNAL %INIT('0'B)%ENIT,
  410
  411      /* Filler */
  412
  413            %(LVL+1) * BIT(6) UNAL %INIT('0'B*0)%ENIT LAST
  414
  415      %MEND;
  416      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  15   
  417
  418      %EJECT;

14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  16   
  419      /* X.29 HANDLER INPUT BUFFER ITEM DEFINITIONS. */
  420
  421      %MACRO KX$X29_INPBFR(FPTN = KX$X29_INPBFR, LVL = 1, LAST = ";", STCLASS = BASED);
  422      %LSET LISTDIR = '0'B;
  423      %LSET LISTEXP = '1'B;
  424      %LSET LISTCOM = '0'B;
  425      %LSET LISTSUB = '1'B;
  426      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  427      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  428      %LSET INIT = CHARTEXT(' INIT');
  429      %LSET ENIT = CHARTEXT('');
  430      %ELSE;
  431      %LSET INIT = CHARTEXT('/*');
  432      %LSET ENIT = CHARTEXT('*/');
  433      %ENDIF;
  434      %IF LVL = 1;
  435      DCL 1 FPTN WALIGNED STCLASS,
  436      %ELSE;
  437      %(LVL) FPTN,
  438      %ENDIF;
  439
  440      %LSET NXTLVL = LVL + 1;
  441
  442      %FPT_X25 ( FPTN = FPT, STCLASS = STCLASS, LVL = NXTLVL, LAST = LAST );
  443
  444      %MEND;
  445      /* X.29 statistical data.  This structure is sent to the host */
  446      /* for analysis by the host 'stats' program. */
  447
  448      %MACRO KX_STATS_X29(FPTN = KX_STATS_X29, LVL = 1, LAST = ";", STCLASS = SYMREF);
  449      %LSET LISTDIR = '0'B;
  450      %LSET LISTEXP = '1'B;
  451      %LSET LISTCOM = '0'B;
  452      %LSET LISTSUB = '1'B;
  453      %LSET LVL1 = LVL + 1;
  454      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  455      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  17   
  456      %LSET INIT = CHARTEXT(' INIT');
  457      %LSET ENIT = CHARTEXT('');
  458      %ELSE;
  459      %LSET INIT = CHARTEXT('/*');
  460      %LSET ENIT = CHARTEXT('*/');
  461      %ENDIF;
  462      %IF LVL = 1;
  463      DCL 1 FPTN WALIGNED STCLASS,
  464      %ELSE;
  465      %(LVL) FPTN,
  466      %ENDIF;
  467      %KL_REQSTATS(NAME = REQSTATS, LVL = LVL1, STCLASS = STCLASS, LAST = ",");
  468
  469      %KH$STT (NAME = KHSTT, LVL = LVL1, LAST = ",", STCLASS = STCLASS);
  470
  471      /* Line speed distribution.  Indexed by the line speed */
  472      /* indicator (KA$CTX:LINSPD), yields the number of lines currently */
  473      /* connected (i.e., have a session in progress). */
  474
  475            %(LVL+1) LINSPDDST(0:15) UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0*0)%ENIT,
  476
  477      /* Output buffer get count, for small async output buffers. */
  478
  479            %(LVL+1) OTPBFRGETCNT_SML UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT,
  480
  481      /* Output buffer get count, for big async output buffers. */
  482
  483            %(LVL+1) OTPBFRGETCNT_BIG UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT,
  484
  485      /* Output buffer full count, for small async output buffers. */
  486
  487            %(LVL+1) OTPBFRFULCNT_SML UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT,
  488
  489      /* Output buffer full count, for big async output buffers. */
  490
  491            %(LVL+1) OTPBFRFULCNT_BIG UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT,
  492
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  18   
  493      /* Number of X.29 virtual circuits open. */
  494
  495            %(LVL+1) CIRCUITS UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT,
  496
  497      /* Number of data packet time outs. */
  498
  499            %(LVL+1) TIMEOUTS UBIN(%(36-4*BITBIN(MODE_FEP))) %INIT(0)%ENIT LAST
  500
  501      %MEND;
  502      /*F*  NAME: Communication Line Resources
  503
  504      A Communication Line resource can be used to establish a direct
  505      connection to a FEP communication resource, and thereby to an
  506      ASYNChronous device or an X.25 virtual circuit.  Communication line
  507      (CL) resources are integrated with CP-6 resource management.  The
  508      system manager defines a CL resource with SUPER, and the user
  509      acquires (or releases) it with M$OPEN (or M$CLOSE) monitor services.
  510      The M$READ and M$WRITE host monitor services are used to transfer
  511      information to and from the CL resource.
  512      ..::IX "CL-resource"
  513
  514      This subsection assumes that an application opens a DCB to a CL
  515      resource created via SUPER with MODE=OUTGOING or MODE=INCOMING.  FIXED
  516      mode resource usage is not covered here, as it is essentially the
  517      same interface as is used to access the time-sharing user's terminal.
  518
  519      This subsection describes opening, closing, and using a CL-resource to
  520      access the packet level services.
  521      It discusses the packet level functions and lists the read keys made
  522      available for CL-resource reads.  It describes the virtual circuit
  523      structures passed via M$READ and M$WRITE calls.  An example illustrates
  524      creating an HDLC CL-resource with SUPER and shows a sample PL6 program
  525      which accesses the packet level services.
  526      ..::IX "packet level services, HDLCX25 handler"
  527      ..::IX "HDLCX25 handler, packet level services"
  528      ..::HL "\For more information on using Communication Line Resources,"
  529      ..::HL "\refer to these HOSTMON help topics:  CL_RES_OPEN, CL_RES_USE,"
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  19   
  530      ..::HL "\topics beginning with VC$, CL_RES_CLOSE and CL_RES_EXAMPLE."
  531      ..::L2 "Opening and Closing the Packet Level CL Resource\\X"
  532      Opening to an OUTGOING resource is straightforward.
  533      A virtual circuit is made available on return from M$OPEN.  The
  534      altreturn is taken if a circuit cannot be created.  The application
  535      can read and write transparently through the DCB to access the
  536      services.
  537
  538      Opening to an INCOMING resource without an AUACCOUNT is similar,
  539      except that when M$OPEN returns, an incoming virtual circuit is
  540      awaiting a response from the application.  After reading the call
  541      packet information, the application can decide whether to accept or
  542      reject the call.  The first successful open to an INCOMING resource
  543      with an AUACCOUNT specified must be done from that account and must
  544      have specified AU=YES to open the DCB.  What happens to subsequent
  545      subsequent opens depends on whether or not the Administrative User
  546      (AU) is doing the M$OPEN.  If it is not, an event is reported to the
  547      AU indicating which user is attempting to use the resource, and the
  548      user is blocked unless EVENT was specified.  If it is the AU doing the
  549      M$OPEN, it is presumed that some user is waiting to open, or that a
  550      new incoming virtual circuit is received and this is an attempt to
  551      connect to it.  When the AU has completed the circuit initialization
  552      to its satisfaction, it M$CLOSEs its DCB, specifying in DISP whether
  553      to forward the connection to some waiting user (whose SYSID or DCB
  554      is also specified in the FPT), terminate the connection, or terminate
  555      the connection and abort the M$OPEN of some waiting user.  The AU
  556      could also have aborted a waiting user via M$OPEN by specifying
  557      DISP=RELEASE.
  558      ..::L2 "Using the Packet Level CL Resource\CL_RES_USE\1"
  559      The M$READ and M$WRITE monitor services called for a packet level CL resource
  560      specify in the read or write buffer a virtual circuit FPT that
  561      determines the function of the read or write.  The functions are
  562      requested by one of the codes listed below.  EQUates for these
  563      function codes are defined in KX_EQUS_E.:LIBRARY.  In general, RQS
  564      (request) and RSP (response) are from application to FEP (writes);
  565      IND (indication) and CNF (confirmation) are from FEP to
  566      application (reads).
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  20   
  567
  568      .fif
  569      .brn 22
  570          EQU name           Code    Meaning
  571          --------           ----    -------
  572      .spf
  573          KX_VCFNC_CAL_RQS#   1    Requests outgoing call
  574          KX_VCFNC_CAL_IND#   2    Indicates incoming call
  575          KX_VCFNC_CAL_RSP#   3    Accepts incoming call
  576          KX_VCFNC_CAL_CNF#   4    Outgoing call confirmed
  577          KX_VCFNC_DAT_RQS#   5    Requests transmission of data
  578          KX_VCFNC_DAT_IND#   6    Indicates received data
  579          KX_VCFNC_INT_RQS#   7    Requests transmission of interrupt
  580          KX_VCFNC_INT_IND#   8    Indicates interrupt received
  581          KX_VCFNC_INT_CNF#   9    Indicates receipt of interrupt confirm
  582          KX_VCFNC_RST_RQS#   10   Requests transmission of reset
  583          KX_VCFNC_RST_IND#   11   Indicates receipt of reset
  584          KX_VCFNC_RST_CNF#   12   Previous reset request confirmed
  585          KX_VCFNC_CLR_RQS#   13   Requests transmission of clear
  586          KX_VCFNC_CLR_IND#   14   Indicates receipt of clear
  587          KX_VCFNC_CLR_CNF#   15   Indicates receipt of clear confirm
  588          KX_VCFNC_CLR_RSP#   16   Responds to clear with clear confirm
  589          KX_VCFNC_BRK_RQS#   17   Requests to send a break on an x.28 VC
  590          KX_VCFNC_SETX3#     18   Host application sets x.3 parameters
  591          KX_VCFNC_REDX3#     19   Host application reads x.3 parameters
  592          KX_VCFNC_INDX3#     20   FEP's response to a read x.3
  593      ..::IX "packet level function codes"
  594
  595      .fin
  596      If the FEP cannot perform the requested function for a write, the next
  597      read is activated with no data but an error code.  For no-wait-reads,
  598      the error is reported through B$NWIO.IOERRCODE.  For regular (wait) reads, the
  599      error is reported through B$ALT.ERR.  The error number (ERR#) is one of the
  600      following, found in B_ERRORS_C.:LIBRARY.
  601
  602      .fif
  603      .brn 5
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  21   
  604      }   Error Code           Meaning
  605      }   ----------           -------
  606      }   E$BADVCSTT           Illegal request for VC state
  607      }   E$BADVCFNC           Undefined request for VC
  608      }   E$BADVCX28           Request legal for x.28 VC only
  609
  610      .fin
  611      Reads are always accompanied by keys which can be examined by the
  612      application if key buffers are allocated for the reads.  Writes
  613      do not need to specify any keys, however.  The key is
  614      one of the following 8-character strings:
  615
  616      .fif
  617      .brn 11
  618      }   String      Meaning
  619      }   ------      -------
  620      }   NCAL_IND    Call indication
  621      }   NCAL_CNF    Call confirmation
  622      }   ADAT_IND    Data indication
  623      }   AINT_IND    Interrupt indication
  624      }   AINT_CNF    Interrupt confirmation
  625      }   ARST_IND    Reset indication
  626      }   ARST_CNF    Reset confirmation
  627      }   NCLR_IND    Clear indication
  628      }   AX3S_IND    x.3 parameter indication
  629      .fin
  630      ..::IX "packet level read keys"
  631
  632      .fin
  633      There are five macros in the file KXX_MACROS_M.:LIBRARY to generate
  634      the FPTs used by both the application and the FEP to achieve the
  635      functions mentioned above.  They are:
  636
  637      .fif
  638      .brn 8
  639      }   Macro    Purpose
  640      }   -----    -------
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  22   
  641      }   VC$CAL   Call or call response
  642      }   VC$DAT   Transfer data
  643      }   VC$INT   Interrupt or interrupt confirm
  644      }   VC$RST   Reset virtual circuit
  645      }   VC$CLR   Clear virtual circuit
  646      .fin
  647      */
  648
  649                          /*F*  NAME: VC$CAL - Call and Call Response
  650
  651                          VC$CAL is used for call and call response packets.
  652
  653                          To refuse an incoming call, use VC$CLR as a
  654                          response to the call indication (CAL_IND) . Hence
  655                          CAL_RSP always means accepting the call.
  656
  657                          In a CAL_RQS message, the call user data field
  658                          should immediately follow the FPT defined by this
  659                          macro.
  660
  661                          In a CAL_IND message, the entire call request
  662                          packet received from the line is appended to the FPT.  Use USRDATLNG
  663                          and USRDATBYTX to locate the call user data field.
  664                          Since the entire call packet
  665                          is passed, the host application can extract the user
  666                          facilities information which it needs. However, this should normally be handled by
  667                          the FEP so there are no pointers to the user facilities
  668                          field in this FPT.
  669                          In a CAL_RSP message, call user data is allowed only in the extended format.
  670
  671                          In the case of an incoming call, the Administrative User (AU), if defined, is the
  672                          first one to read the call packet.  The AU can use this macro
  673                          to restore the call packet information so that the application
  674                          to which the call is destined can read it.  The simplest way
  675                          for the AU to achieve this is to change the function in the
  676                          VC$CAL read from %KX_VCFNC_CAL_IND# to %KX_VCFNC_CAL_RQS# and write it back to
  677                          the FEP.
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  23   
  678
  679                          This FPT is also used to set x.3 parameters when FUNCTION is SETX3#,
  680                          and to indicate current x.3 parameters when FUNCTION is
  681                          INDX3. The x.3 parameters included in a CAL_CNF message should
  682                          also satisfy a pending REDX3 message.
  683                          */
  684
  685      %MACRO VC$CAL ( FPTN = VC$CAL,
  686                      FUNCTION (CAL_RQS = %KX_VCFNC_CAL_RQS#,
  687                               CAL_IND = %KX_VCFNC_CAL_IND#,
  688                               CAL_ACP = %KX_VCFNC_CAL_RSP#,
  689                               CAL_CNF = %KX_VCFNC_CAL_CNF#,
  690                               SETX3 = %KX_VCFNC_SETX3#,
  691                               INDX3 = %KX_VCFNC_INDX3# )
  692                             = %KX_VCFNC_CAL_RQS#,
  693                      CLGADRLNG = 0,
  694                      CLDADRLNG = 0,
  695      /* calling address */
  696                      CLGADRPAIR_1 = 0,
  697                      CLGADRPAIR_2 = 0,
  698                      CLGADRPAIR_3 = 0,
  699                      CLGADRPAIR_4 = 0,
  700                      CLGADRPAIR_5 = 0,
  701                      CLGADRPAIR_6 = 0,
  702                      CLGADRPAIR_7 = 0,
  703      /* called address */
  704                      CLDADRPAIR_1 = 0,
  705                      CLDADRPAIR_2 = 0,
  706                      CLDADRPAIR_3 = 0,
  707                      CLDADRPAIR_4 = 0,
  708                      CLDADRPAIR_5 = 0,
  709                      CLDADRPAIR_6 = 0,
  710                      CLDADRPAIR_7 = 0,
  711                      PROTOCOL (NON = %KX_PRTID_NON#,
  712                                X28 = %KX_PRTID_X28#)
  713                              = %KX_PRTID_NON#,
  714                      RPRX3 (NO = '0'B, YES = '1'B) = '0'B,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  24   
  715                      FSTSLC (NO = 0,
  716                              RESTRICT = 3,
  717                              UNRESTRICT = 2)
  718                            = 0,
  719                      RVS (NO = '0'B, YES = '1'B) = '0'B,
  720                      REASSEMBLY (NO = '0'B, YES = '1'B) = '0'B,
  721                      ADRMODRSN (NON = %KX_ADRMODRSN_NON#,
  722                                 HNT = %KX_ADRMODRSN_HNT#,
  723                                 BSY = %KX_ADRMODRSN_BSY#,
  724                                 DWN = %KX_ADRMODRSN_DWN#,
  725                                 SYS = %KX_ADRMODRSN_SYS#)
  726                               = %KX_ADRMODRSN_NON#,
  727                      PADRCL ( YES = 1, NO = 0 ) = 1,
  728                      PADECH ( YES = 1, NO = 0 ) = 0,
  729                      DATFRWSGN = 2,
  730                      IDLTMRDLY = 0,
  731                      ANCDVCCTR ( YES = 1, NO = 0 ) = 0,
  732                      PADSRVSGN = 0,
  733                      ACTBRK = 21,
  734                      DSCOTP ( YES = 1, NO = 0 ) = 0,
  735                      CRPADD = 0,
  736                      LINFLD  = 0,
  737                      LINSPD = 14,
  738                      FLWCTRPAD ( YES = 1, NO = 0 ) = 0,
  739                      LFAFTCR = 0,
  740                      LFPADD = 0,
  741                      EDT ( YES = 1, NO = 0 ) = 0,
  742                      CHRDLT = 0,
  743                      LINDLT = 0,
  744                      LINDSP = 0,
  745                      X3PRM19 = 0,
  746                      X3PRM20 = 0,
  747                      X3PRM21 = 0,
  748                      X3PRM22 = 0,
  749                      USRDATLNG = 0,
  750                      USRDATBYTX = 0,
  751                      STCLASS = BASED, LAST = ";" );
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  25   
  752
  753      %LSET LISTDIR = '0'B;
  754      %LSET LISTEXP = '1'B;
  755      %LSET LISTCOM = '0'B;
  756      %LSET LISTSUB = '1'B;
  757      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '), 0, 3);
  758      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  759      %IF STC = 1;
  760      %LSET INIT = CHARTEXT(' INIT');
  761      %LSET EINIT = CHARTEXT('');
  762      %ELSE;
  763      %LSET INIT = CHARTEXT('/*');
  764      %LSET EINIT = CHARTEXT('*/');
  765      %ENDIF;
  766      %LSET FEP = BITBIN(MODE_FEP);
  767      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  768      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)',10-10*STC), ', ');
  769      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT,FEP*LENGTHC(KX_FILBIT)));
  770
  771      DCL 1 FPTN STCLASS,
  772            2 %CHARTEXT('FUNCTION') UBIN BYTE CALIGNED %INIT(FUNCTION)%EINIT,
  773                          /*K*   FUNCTION = OPTION
  774                                 specifies one of the following functions:
  775
  776                                 CAL_RQS - call request, the default.
  777
  778                                 CAL_RSP - call response.
  779
  780                                 CAL_CNF - call confirmation.
  781
  782                                 CAL_IND - call indication.
  783
  784                                 SETX3 - set x.3 parameters.
  785
  786                                 INDX3 - x.3 parameter indication.
  787
  788                          */
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  26   
  789            %KX_FILBIT
  790                          /*
  791                          */
  792            2 %CHARTEXT('CLGADRLNG') UBIN(4) UNAL %INIT(CLGADRLNG)%EINIT,
  793                          /*K*   CLGADRLNG = VALUE-DEC(0-14)
  794                                 specifies the number of binary coded
  795                                 decimal digits in the calling address.
  796                                 The default is 0.
  797                                 CLGADRLNG is ignored in a CAL_RSP message.
  798                          */
  799            2 %CHARTEXT('CLDADRLNG') UBIN(4) UNAL %INIT(CLDADRLNG)%EINIT,
  800                          /*K*   CLDADRLNG = VALUE-DEC(0-14)
  801                                 specifies the number of binary coded
  802                                 decimal digits in the called address.
  803                                 The default is 0.
  804                                 CLDADRLNG is ignored in a CAL_RSP message.
  805                          */
  806            2 CLGADR CALIGNED,
  807                          /*K*   CLGADR specifies the calling address in BCD
  808                                 format.  It is ignored
  809                                 in a CAL_RSP message, and is initialized in
  810                                 the following way.
  811                                 If the address is '129' then CLGADRPAIR_1 = 18
  812                                 and CLGADRPAIR_2 = 144, since 18 equals '12'hex
  813                                 and 144 equals '90'hex.
  814                          */
  815              3 %CHARTEXT('CLGADRPAIR_1') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_1)%EINIT,
  816                          /*K*   CLGADR.CLGADRPAIR_1 = VALUE-DEC(0-255) specifies
  817                                 BCDs 1 and 2.  The default is 0.
  818                          */
  819              3 %CHARTEXT('CLGADRPAIR_2') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_2)%EINIT,
  820                          /*K*   CLGADR.CLGADRPAIR_2 = VALUE-DEC(0-255) specifies
  821                                 BCDs 3 and 4.  The default is 0.
  822                          */
  823              3 %CHARTEXT('CLGADRPAIR_3') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_3)%EINIT,
  824                          /*K*   CLGADR.CLGADRPAIR_3 = VALUE-DEC(0-255) specifies
  825                                 BCDs 5 and 6.  The default is 0.
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  27   
  826                          */
  827              3 %CHARTEXT('CLGADRPAIR_4') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_4)%EINIT,
  828                          /*K*   CLGADR.CLGADRPAIR_4 = VALUE-DEC(0-255) specifies
  829                                 BCDs 7 and 8.  The default is 0.
  830                          */
  831              3 %CHARTEXT('CLGADRPAIR_5') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_5)%EINIT,
  832                          /*K*   CLGADR.CLGADRPAIR_5 = VALUE-DEC(0-255) specifies
  833                                 BCDs 9 and 10.  The default is 0.
  834                          */
  835              3 %CHARTEXT('CLGADRPAIR_6') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_6)%EINIT,
  836                          /*K*   CLGADR.CLGADRPAIR_6 = VALUE-DEC(0-255) specifies
  837                                 BCDs 11 and 12.  The default is 0.
  838                          */
  839              3 %CHARTEXT('CLGADRPAIR_7') UBIN BYTE CALIGNED %INIT(CLGADRPAIR_7)%EINIT,
  840                          /*K*   CLGADR.CLGADRPAIR_7 = VALUE-DEC(0-255) specifies
  841                                 BCDs 13 and 14.  The default is 0.
  842                          */
  843            2 CLGADRPAIR (0:6) REDEF CLGADR UBIN BYTE CALIGNED,
  844            2 CLGADRSTRING REDEF CLGADR CHAR(7) CALIGNED,
  845            2 CLDADR CALIGNED,
  846                          /*K*   CLDADR specifies the called address in BCD
  847                                 format.  It is ignored
  848                                 in a CAL_RSP message, and is initialized in
  849                                 the following way.
  850                                 If the address is '129' then CLDADRPAIR_1 = 18
  851                                 and CLDADRPAIR_2 = 144, since 18 equals '12'hex
  852                                 and 144 equals '90'hex.
  853                          */
  854              3 %CHARTEXT('CLDADRPAIR_1') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_1)%EINIT,
  855                          /*K*   CLDADR.CLDADRPAIR_1 = VALUE-DEC(0-255) specifies
  856                                 BCDs 1 and 2.  The default is 0.
  857                          */
  858              3 %CHARTEXT('CLDADRPAIR_2') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_2)%EINIT,
  859                          /*K*   CLDADR.CLDADRPAIR_2 = VALUE-DEC(0-255) specifies
  860                                 BCDs 3 and 4.  The default is 0.
  861                          */
  862              3 %CHARTEXT('CLDADRPAIR_3') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_3)%EINIT,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  28   
  863                          /*K*   CLDADR.CLDADRPAIR_3 = VALUE-DEC(0-255) specifies
  864                                 BCDs 5 and 6.  The default is 0.
  865                          */
  866              3 %CHARTEXT('CLDADRPAIR_4') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_4)%EINIT,
  867                          /*K*   CLDADR.CLDADRPAIR_4 = VALUE-DEC(0-255) specifies
  868                                 BCDs 7 and 8.  The default is 0.
  869                          */
  870              3 %CHARTEXT('CLDADRPAIR_5') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_5)%EINIT,
  871                          /*K*   CLDADR.CLDADRPAIR_5 = VALUE-DEC(0-255) specifies
  872                                 BCDs 9 and 10.  The default is 0.
  873                          */
  874              3 %CHARTEXT('CLDADRPAIR_6') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_6)%EINIT,
  875                          /*K*   CLDADR.CLDADRPAIR_6 = VALUE-DEC(0-255) specifies
  876                                 BCDs 11 and 12.  The default is 0.
  877                          */
  878              3 %CHARTEXT('CLDADRPAIR_7') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_7)%EINIT,
  879                          /*K*   CLDADR.CLDADRPAIR_7 = VALUE-DEC(0-255) specifies
  880                                 BCDs 13 and 14.  The default is 0.
  881                          */
  882            2 CLDADRPAIR (0:6) REDEF CLDADR UBIN BYTE CALIGNED,
  883            2 CLDADRSTRING REDEF CLDADR CHAR(7) CALIGNED,
  884            2 %CHARTEXT('ADRMODRSN') UBIN BYTE CALIGNED %INIT(ADRMODRSN)%EINIT,
  885                          /*K*   ADRMODRSN = OPTION specifies the address
  886                                 modification reason.  In a CAL_CNF message,
  887                                 ADRMODRSN specifies
  888                                 the reason for the change in the called
  889                                 address from the originally requested
  890                                 destination address. If the value is not NON (0), the
  891                                 modified called address is returned in CLDADRLNG
  892                                 and CLDADR, which normally can be ignored in
  893                                 a CAL_CNF message.
  894
  895                                 NON - no redirection, the default.
  896
  897                                 HNT - redirection within a hunt group.
  898
  899                                 BSY - redirection due to DTE busy.
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  29   
  900
  901                                 DWN - redirection due to DTE out of order.
  902
  903                                 SYS - systematic call redirection.
  904
  905                          */
  906            2 %CHARTEXT('PROTOCOL') UBIN BYTE CALIGNED %INIT(PROTOCOL)%EINIT,
  907                          /*K*   PROTOCOL = {X28|NON}
  908                                 is applicable only to CAL_RQS messages.
  909                                 The default is NON.
  910                          */
  911            %KX_FILBIT
  912                          /*
  913                          */
  914            2 %CHARTEXT('FSTSLC') UBIN(2) UNAL %INIT(FSTSLC)%EINIT,
  915                          /*K*   FSTSLC = OPTION
  916                                 specifies the use and response
  917                                 restriction of the fast select facility
  918                                 in a CAL_RQS message.  It indicates
  919                                 the presence and response restriction of the fast
  920                                 select facility in a CAL_IND message.
  921                                 It is ignored in CAL_RSP message.
  922
  923                                 NO - This facility is not in use.  It is the default.
  924
  925                                 RESTRICT - Fast select with restricted
  926                                 response is in use.
  927
  928                                 UNRESTRICT - Fast select with unrestricted
  929                                 response is in use.
  930
  931                          */
  932            2 %CHARTEXT('RPRX3') BIT(1) UNAL %INIT(RPRX3)%EINIT,
  933                          /*K*   RPRX3 = {YES|NO} specifies, if YES, to
  934                                 Report x.3 parameter changes.
  935                                 The host application turns this on if it wants
  936                                 to be notified when x.3 parameters are changed.
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  30   
  937                          */
  938            2 %CHARTEXT('RVS') BIT(1) UNAL %INIT(RVS)%EINIT,
  939                          /*K*   RVS = {YES|NO}
  940                                 specifies, if YES, that this is a reverse-charged
  941                                 CAL_IND, or that reverse charging should
  942                                 be requested with this CAL_RQS.
  943                                 The default is NO.
  944                          */
  945            2 %CHARTEXT('REASSEMBLY') BIT(1) UNAL %INIT(REASSEMBLY)%EINIT,
  946                          /*K*   REASSEMBLY = {YES|NO}.
  947                                 specifies whether or not the FEP should
  948                                 handle reassembling of M-bit packets.  Host
  949                                 applications that transfer messages bigger than
  950                                 4096 bytes should take care of reassembling in the
  951                                 host.
  952                          */
  953            2 * BIT(3) UNAL %INIT('0'B*0)%EINIT,
  954                          /*
  955                          */
  956            2 X3S CALIGNED,
  957                          /*K*   X3S specifies the setting of the x.3 parameters
  958                                 for a CAL_RQS message or indicates the current x.3 parameter
  959                                 values for a CAL_IND message.  Consult the CCITT Recommendation
  960                                 X.3 for details.
  961                          */
  962              3 %CHARTEXT('PADRCL') UBIN BYTE CALIGNED %INIT(PADRCL)%EINIT,
  963                          /*K*   X3S.PADRCL = {YES|NO} specifies whether or not
  964                                 PAD recall is allowed.  The default is YES.
  965                          */
  966              3 %CHARTEXT('PADECH') UBIN BYTE CALIGNED %INIT(PADECH)%EINIT,
  967                          /*K*   X3S.PADECH = {YES|NO} specifies whether or not
  968                                 echoing is done by the PAD.  The default is NO.
  969                          */
  970              3 %CHARTEXT('DATFRWSGN') UBIN BYTE CALIGNED %INIT(DATFRWSGN)%EINIT,
  971                          /*K*   X3S.DATFRWSGN = VALUE-DEC(0-255) specifies the
  972                                 data forwarding signals.  The default is 2,meaning
  973                                 forward on carriage return only.  See the CCITT
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  31   
  974                                 Recommendation X.3 for meaning of other values.
  975                          */
  976              3 %CHARTEXT('IDLTMRDLY') UBIN BYTE CALIGNED %INIT(IDLTMRDLY)%EINIT,
  977                          /*K*   X3S.IDLTMRDLY = VALUE-DEC(0-255) specifies the
  978                                 idle timer delay in increments of 50 milliseconds.
  979                                 The default, 0, means no data forwarding
  980                                 on time-out.
  981                          */
  982              3 %CHARTEXT('ANCDVCCTR') UBIN BYTE CALIGNED %INIT(ANCDVCCTR)%EINIT,
  983                          /*K*   X3S.ANCDVCCTR = {YES|NO} specifies whether or not
  984                                 the PAD is allowed to flow control the terminal
  985                                 with X-ON and X-OFF.  The default is NO.
  986                          */
  987              3 %CHARTEXT('PADSRVSGN') UBIN BYTE CALIGNED %INIT(PADSRVSGN)%EINIT,
  988                          /*K*   X3S.PADSRVSGN = {0|1|4|5} specifies whether or not
  989                                 the PAD transmits service signals to the terminal.
  990                                 The default, 0, means no service signals are
  991                                 transmitted.  See the CCITT Recommendation
  992                                 X.3 for the meaning of other values.
  993                          */
  994              3 %CHARTEXT('ACTBRK') UBIN BYTE CALIGNED %INIT(ACTBRK)%EINIT,
  995                          /*K*   X3S.ACTBRK = {0|1|2|4|8|16|21} determines the
  996                                 action to be taken by the PAD upon receipt of
  997                                 a break signal from the terminal.  The default,
  998                                 21, means the PAD will send an interrupt packet,
  999                                 an indication of break packet, and discard
 1000                                 output to the terminal.  See the CCITT
 1001                                 Recommendation X.3 for the meaning of other values.
 1002                          */
 1003              3 %CHARTEXT('DSCOTP') UBIN BYTE CALIGNED %INIT(DSCOTP)%EINIT,
 1004                          /*K*   X3S.DSCOTP = {YES|NO} specifies whether or not
 1005                                 the PAD will discard output to the terminal.
 1006                                 The default is NO.
 1007                          */
 1008              3 %CHARTEXT('CRPADD') UBIN BYTE CALIGNED %INIT(CRPADD)%EINIT,
 1009                          /*K*   X3S.CRPADD = VALUE-DEC(0-7) specifies whether or
 1010                                 not padding characters are to be provided by the
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  32   
 1011                                 PAD upon receipt of a carriage return.  The default,
 1012                                 0, means no padding after carriage return.
 1013                                 See the CCITT Recommendation X.3 for the
 1014                                 meaning of other values.
 1015                          */
 1016              3 %CHARTEXT('LINFLD') UBIN BYTE CALIGNED %INIT(LINFLD)%EINIT,
 1017                          /*K*   X3S.LINFLD = VALUE-DEC(0-255) specifies whether or
 1018                                 not the PAD will insert an automatic line folding
 1019                                 after it has transmitted the pre-set number of
 1020                                 graphic characters to the terminal.  The default,
 1021                                 0 means no line folding.  See the CCITT
 1022                                 Recommendation X.3 for the meaning of other values.
 1023                          */
 1024              3 %CHARTEXT('LINSPD') UBIN BYTE CALIGNED %INIT(LINSPD)%EINIT,
 1025                          /*K*   X3S.LINSPD = VALUE-DEC(0-18) specifies the line
 1026                                 speed of the terminal.  The default, 14, means
 1027                                 9600 bits per second.  See the CCITT
 1028                                 Recommendation X.3 for the meaning of other values.
 1029                          */
 1030              3 %CHARTEXT('FLWCTRPAD') UBIN BYTE CALIGNED %INIT(FLWCTRPAD)%EINIT,
 1031                          /*K*   X3S.FLWCTRPAD = {YES|NO} specifies whether or not
 1032                                 the terminal can flow control the PAD with X-ON
 1033                                 and X-OFF.  The default is NO.
 1034                          */
 1035              3 %CHARTEXT('LFAFTCR') UBIN BYTE CALIGNED %INIT(LFAFTCR)%EINIT,
 1036                          /*K*   X3S.LFAFTCR = VALUE-DEC(0-7) specifies the
 1037                                 linefeed insertion procedure to be performed by
 1038                                 the PAD after a carriage return.  The default, 0,
 1039                                 means no linefeed insertion.  See the CCITT
 1040                                 Recommendation X.3 for the meaning of other values.
 1041                          */
 1042              3 %CHARTEXT('LFPADD') UBIN BYTE CALIGNED %INIT(LFPADD)%EINIT,
 1043                          /*K*   X3S.LFPADD = VALUE-DEC(0-7) specifies the number
 1044                                 of padding characters the PAD is to insert after
 1045                                 transmitting a linefeed to the terminal.  The
 1046                                 default, 0, means no padding after linefeed.
 1047                                 See the CCITT Recommendation X.3 for the
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  33   
 1048                                 meaning of other values.
 1049                          */
 1050              3 %CHARTEXT('EDT') UBIN BYTE CALIGNED %INIT(EDT)%EINIT,
 1051                          /*K*   X3S.EDT = {YES|NO} specifies whether or not the
 1052                                 PAD is to provide an editing function for the
 1053                                 terminal.  The default is NO.
 1054                          */
 1055              3 %CHARTEXT('CHRDLT') UBIN BYTE CALIGNED %INIT(CHRDLT)%EINIT,
 1056                          /*K*   X3S.CHRDLT = VALUE-DEC(0-127) specifies the
 1057                                 CHARACTER DELETE character, if EDT = YES.  The
 1058                                 default is 0.  See the CCITT Recommendation
 1059                                 X.3 for the meaning of other values.
 1060                          */
 1061              3 %CHARTEXT('LINDLT') UBIN BYTE CALIGNED %INIT(LINDLT)%EINIT,
 1062                          /*K*   X3S.LINDLT = VALUE-DEC(0-127) specifies the LINE
 1063                                 DELETE character, if EDT = YES.  The default
 1064                                 is 0.  See the CCITT Recommendation X.3 for
 1065                                 the meaning of other values.
 1066                          */
 1067              3 %CHARTEXT('LINDSP') UBIN BYTE CALIGNED %INIT(LINDSP)%EINIT,
 1068                          /*K*   X3S.LINDSP = VALUE-DEC(0-127) specifies the LINE
 1069                                 DISPLAY character, if EDT = YES.  The default
 1070                                 is 0.  See the CCITT Recommendation X.3 for
 1071                                 the meaning of other values.
 1072                          */
 1073              3 %CHARTEXT('X3PRM19') UBIN BYTE CALIGNED %INIT(X3PRM19)%EINIT,
 1074              3 %CHARTEXT('X3PRM20') UBIN BYTE CALIGNED %INIT(X3PRM20)%EINIT,
 1075              3 %CHARTEXT('X3PRM21') UBIN BYTE CALIGNED %INIT(X3PRM21)%EINIT,
 1076              3 %CHARTEXT('X3PRM22') UBIN BYTE CALIGNED %INIT(X3PRM22)%EINIT,
 1077            2 X3(0:%KX_X3PRMX_HI#) REDEF X3S UBIN BYTE CALIGNED,
 1078            2 %CHARTEXT('USRDATLNG') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(USRDATLNG)%EINIT,
 1079                          /*K*   USRDATLNG = VALUE-DEC(0-128)
 1080                                 specifies the length, in bytes, of the call
 1081                                 user data field.  USRDATLNG is
 1082                                 limited to 128 if FSTSLC is non-zero, and
 1083                                 is limited to 16 otherwise.
 1084                          */
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  34   
 1085            2 %CHARTEXT('USRDATBYTX') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(USRDATBYTX)%EINIT LAST
 1086                          /*K*   USRDATBYTX = VALUE-DEC(0-255)
 1087                                 specifies the byte offset,
 1088                                 from the end of the FPT structure,
 1089                                 to the call user data field.
 1090                          */
 1091      %MEND;
 1092
 1093                          /*F*  NAME: VC$DAT - Transfer Data
 1094
 1095                          VC$DAT is used to transfer data packets.  The body of the data packet follows
 1096                          immediately after the FPT defined by this macro.
 1097                          On x.28 virtual circuits, this is also used by host applications to:
 1098                          .spf
 1099                          1) send breaks to the remote host.
 1100                             The appropriate (sequence of) x.29 packets is generated according to
 1101                             the setting of x.3 parameter 7.  Use the BRK_RQS function code for this purpose.
 1102                          2) read x.3 parameters in the FEP.  Use the REDX3 function code for this purpose.
 1103                             Note that one always sets or reads the entire set of x.3 parameters;
 1104                             the parameter values follow the FPT immediately.
 1105                             REDX3 is unnecessary if RPRX3 was specified with the call request.
 1106                          */
 1107      %MACRO VC$DAT ( FPTN = VC$DAT,
 1108                      FUNCTION (DAT_RQS = %KX_VCFNC_DAT_RQS#,
 1109                                DAT_IND = %KX_VCFNC_DAT_IND#,
 1110                                BRK_RQS = %KX_VCFNC_BRK_RQS#,
 1111                                REDX3 = %KX_VCFNC_REDX3# )
 1112                              = %KX_VCFNC_DAT_RQS#,
 1113                      Q (YES = '1'B, NO = '0'B) = '0'B,
 1114                      M (YES = '1'B, NO = '0'B) = '0'B,
 1115                      STCLASS = BASED, LAST = ";" );
 1116
 1117      %LSET LISTDIR = '0'B;
 1118      %LSET LISTEXP = '1'B;
 1119      %LSET LISTCOM = '0'B;
 1120      %LSET LISTSUB = '1'B;
 1121      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '), 0, 3);
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  35   
 1122      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1123      %IF STC = 1;
 1124      %LSET INIT = CHARTEXT(' INIT');
 1125      %LSET EINIT = CHARTEXT('');
 1126      %ELSE;
 1127      %LSET INIT = CHARTEXT('/*');
 1128      %LSET EINIT = CHARTEXT('*/');
 1129      %ENDIF;
 1130      %LSET FEP = BITBIN(MODE_FEP);
 1131      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1132      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)',10-10*STC), ', ');
 1133      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT,FEP*LENGTHC(KX_FILBIT)));
 1134
 1135      DCL 1 FPTN STCLASS,
 1136            2 %CHARTEXT('FUNCTION') UBIN BYTE CALIGNED %INIT(FUNCTION)%EINIT,
 1137                          /*K*   FUNCTION = OPTION
 1138                                 specifies one of the following functions:
 1139
 1140                                 DAT_RQS - data request, the default.
 1141
 1142                                 DAT_IND - data indication.
 1143
 1144                                 SETX3 - set x.3 parameters.
 1145
 1146                                 REDX3 - read x.3 parameters.
 1147
 1148                                 INDX3 - indication of x.3 parameters.
 1149
 1150                          */
 1151            %KX_FILBIT
 1152            2 %CHARTEXT('Q') BIT (1) UNAL %INIT(Q)%EINIT,
 1153                          /*K*   Q = {YES|NO}
 1154                                 specifies the setting of the Q bit in the
 1155                                 data packet received or to be transmitted. The
 1156                                 default is NO.
 1157                          */
 1158            2 %CHARTEXT('M') BIT (1) UNAL %INIT(M)%EINIT,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  36   
 1159                          /*K*   M = {YES|NO}
 1160                                 specifies, on a read, the setting of the M-bit in the
 1161                                 data packet received, and on a write, whether or not
 1162                                 this is a complete message.  The application
 1163                                 reads M-bit packets only if packet reassembly
 1164                                 has been turned off (see VC$CAL).  It is important for
 1165                                 applications transferring messages longer than
 1166                                 4096 bytes to reassemble them in the host to avoid draining
 1167                                 buffers in the FEP and to stay within the Host-FEP
 1168                                 transfer limit.  M-bit can be used
 1169                                 on output regardless of packet reassembly.
 1170                                 Writing a zero length message with the M-bit off
 1171                                 will flush any partial output packets held in the FEP.
 1172                                 The default is NO, which means that the message is complete.
 1173                          */
 1174            2 * BIT (6) UNAL %INIT('0'B*0)%EINIT LAST
 1175                          /*
 1176                          */
 1177      %MEND;
 1178
 1179                          /*F*  NAME: VC$INT - Interrupt or Interrupt Confirm
 1180
 1181                          VC$INT is used for interrupt and interrupt
 1182                          confirm packets. In INT_RQS and INT_IND messages, the interrupt data,
 1183                          which can be up to 32 bytes in the extended format, follow immediately
 1184                          after the FPT.  It is an error to specify non-zero INTDATLNG and have no
 1185                          data following the FPT.
 1186
 1187                          */
 1188
 1189      %MACRO VC$INT ( FPTN = VC$INT,
 1190                      FUNCTION ( INT_RQS = %KX_VCFNC_INT_RQS#,
 1191                                 INT_IND = %KX_VCFNC_INT_IND#,
 1192                                 INT_CNF = %KX_VCFNC_INT_CNF#)
 1193                               = %KX_VCFNC_INT_RQS#,
 1194                      INTDATLNG = 0,
 1195                      STCLASS = BASED, LAST = ";" );
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  37   
 1196
 1197      %LSET LISTDIR = '0'B;
 1198      %LSET LISTEXP = '1'B;
 1199      %LSET LISTCOM = '0'B;
 1200      %LSET LISTSUB = '1'B;
 1201      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '), 0, 3);
 1202      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1203      %IF STC = 1;
 1204      %LSET INIT = CHARTEXT(' INIT');
 1205      %LSET EINIT = CHARTEXT('');
 1206      %ELSE;
 1207      %LSET INIT = CHARTEXT('/*');
 1208      %LSET EINIT = CHARTEXT('*/');
 1209      %ENDIF;
 1210      %LSET FEP = BITBIN(MODE_FEP);
 1211      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1212      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)',10-10*STC), ', ');
 1213      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT,FEP*LENGTHC(KX_FILBIT)));
 1214
 1215      DCL 1 FPTN STCLASS,
 1216            2 %CHARTEXT('FUNCTION') UBIN BYTE CALIGNED %INIT(FUNCTION)%EINIT,
 1217                          /*K*   FUNCTION = OPTION
 1218                                 specifies one of the following functions:
 1219
 1220                                 INT_RQS - interrupt request, the default.
 1221
 1222                                 INT_IND - interrupt indication.
 1223
 1224                                 INT_CNF - interrupt confirmation.
 1225
 1226                                 NOTE:  INT_RSP is not needed because the FEP
 1227                                 takes care of interrupt confirmation.
 1228                          */
 1229            2 %CHARTEXT('INTDATLNG') UBIN BYTE CALIGNED %INIT(INTDATLNG)%EINIT LAST
 1230                          /*K*   INTDATLNG = VALUE-DEC(0-32)
 1231                                 specifies the length of interrupt data.
 1232                                 This parameter is applicable only to INT_RQS
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  38   
 1233                                 and INT_IND messages.  If the extended format is used,
 1234                                 length can be up to 32 bytes.  Otherwise it
 1235                                 can only be 0 or 1.  The default is 0.
 1236                          */
 1237      %MEND;
 1238                          /*F*  NAME: VC$RST - Reset Virtual Circuit
 1239
 1240                          VC$RST is used by the application to reset a virtual
 1241                          circuit, or by the FEP to indicate that a
 1242                          reset was initiated by the other side.
 1243
 1244                          */
 1245
 1246      %MACRO VC$RST ( FPTN = VC$RST,
 1247                      FUNCTION ( RST_RQS = %KX_VCFNC_RST_RQS#,
 1248                                 RST_IND = %KX_VCFNC_RST_IND# )
 1249                               = %KX_VCFNC_RST_RQS#,
 1250                      CAUSE = %KX_RST_CAUSE_DTE#,
 1251                      DIAG = 0,
 1252                      STCLASS = BASED, LAST = ";" );
 1253
 1254      %LSET LISTDIR = '0'B;
 1255      %LSET LISTEXP = '1'B;
 1256      %LSET LISTCOM = '0'B;
 1257      %LSET LISTSUB = '1'B;
 1258      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '), 0, 3);
 1259      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1260      %IF STC = 1;
 1261      %LSET INIT = CHARTEXT(' INIT');
 1262      %LSET EINIT = CHARTEXT('');
 1263      %ELSE;
 1264      %LSET INIT = CHARTEXT('/*');
 1265      %LSET EINIT = CHARTEXT('*/');
 1266      %ENDIF;
 1267      %LSET FEP = BITBIN(MODE_FEP);
 1268      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1269      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)',10-10*STC), ', ');
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  39   
 1270      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT,FEP*LENGTHC(KX_FILBIT)));
 1271
 1272      DCL 1 FPTN STCLASS,
 1273            2 %CHARTEXT('FUNCTION') UBIN BYTE CALIGNED %INIT(FUNCTION)%EINIT,
 1274                          /*K*   FUNCTION = OPTION
 1275                                 specifies one of the following functions:
 1276
 1277                                 RST_RQS - reset request, the default.
 1278
 1279                                 RST_IND - reset indication.
 1280
 1281                          */
 1282            2 %CHARTEXT('CAUSE') UBIN BYTE CALIGNED %INIT(CAUSE)%EINIT,
 1283                          /*K*    CAUSE = VALUE-DEC(0-255)
 1284                                  specifies the reset cause.  Values are of
 1285                                  the form %KX_RST_CAUSE_? as defined in KX_EQUS_E.
 1286                                  The default is %KX_RST_CAUSE_DTE#.
 1287                          */
 1288            2 %CHARTEXT('DIAG') UBIN BYTE CALIGNED %INIT(DIAG)%EINIT LAST
 1289                          /*K*    DIAG = VALUE-DEC(0-255)
 1290                                  specifies the reset diagnostic.  Values
 1291                                  are of the form %KX_RST_DIAG_? as defined in KX_EQUS_E.
 1292                                  The default, 0, means that there is no reset
 1293                                  diagnostic available.
 1294                          */
 1295      %MEND;
 1296                          /*F*  NAME: VC$CLR - Clear Virtual Circuit
 1297
 1298                          VC$CLR is used when a virtual circuit is (to be) cleared.
 1299
 1300                          The extended format is required when calling or
 1301                          called addresses, user facilities, or clear user data
 1302                          are present.  The Address and Facility Fields
 1303                          are used in a CLR_RQS or CLR_IND message when the
 1304                          Called Line Address Modified Notification Facility
 1305                          is present.  The Facility Field is used when
 1306                          the Charging Information Facility is present.  The
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  40   
 1307                          Clear User Data Field is
 1308                          used in conjunction with the Fast Select Facility.
 1309
 1310                          In a CLR_IND or CLR_CNF message, the entire clear
 1311                          request or clear confirm packet is passed to the
 1312                          application.  Relevant information are either
 1313                          placed directly in the FPT (such as CAUSE and
 1314                          DIAG) or framed by byte lengths and offsets (such
 1315                          as charging information, clear user data). The
 1316                          application can of course decode the packet from
 1317                          scratch if it prefers.
 1318
 1319                          */
 1320
 1321      %MACRO VC$CLR ( FPTN = VC$CLR,
 1322                      FUNCTION (CLR_RQS = %KX_VCFNC_CLR_RQS#,
 1323                                CLR_IND = %KX_VCFNC_CLR_IND#,
 1324                                CLR_CNF = %KX_VCFNC_CLR_CNF#,
 1325                                CLR_RSP = %KX_VCFNC_CLR_RSP# )
 1326                              = %KX_VCFNC_CLR_RQS#,
 1327                      ADRMODRSN (NON = %KX_ADRMODRSN_NON#,
 1328                                 HNT = %KX_ADRMODRSN_HNT#,
 1329                                 BSY = %KX_ADRMODRSN_BSY#,
 1330                                 DWN = %KX_ADRMODRSN_DWN#,
 1331                                 SYS = %KX_ADRMODRSN_SYS#)
 1332                                =%KX_ADRMODRSN_NON#,
 1333                      CAUSE = %KX_CAUSE_DTE#,
 1334                      DIAG = %KX_DIAG_NON#,
 1335                      CLDADRLNG = 0,
 1336                      CLDADRPAIR_1 = 0,
 1337                      CLDADRPAIR_2 = 0,
 1338                      CLDADRPAIR_3 = 0,
 1339                      CLDADRPAIR_4 = 0,
 1340                      CLDADRPAIR_5 = 0,
 1341                      CLDADRPAIR_6 = 0,
 1342                      CLDADRPAIR_7 = 0,
 1343                      CHRINFLNG = 0,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  41   
 1344                      CHRINFBYTX = 0,
 1345                      USRDATLNG = 0,
 1346                      USRDATBYTX = 0,
 1347                      STCLASS = BASED, LAST = ";" );
 1348
 1349      %LSET LISTDIR = '0'B;
 1350      %LSET LISTEXP = '1'B;
 1351      %LSET LISTCOM = '0'B;
 1352      %LSET LISTSUB = '1'B;
 1353      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '), 0, 3);
 1354      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1355      %IF STC = 1;
 1356      %LSET INIT = CHARTEXT(' INIT');
 1357      %LSET EINIT = CHARTEXT('');
 1358      %ELSE;
 1359      %LSET INIT = CHARTEXT('/*');
 1360      %LSET EINIT = CHARTEXT('*/');
 1361      %ENDIF;
 1362      %LSET FEP = BITBIN(MODE_FEP);
 1363      %LSET KX_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1364      %LSET KX_FILBIT = CONCAT('2', ' * BIT(1)', SUBSTR('INIT(''0''B)',10-10*STC), ', ');
 1365      %LSET KX_FILBIT = CHARTEXT(SUBSTR(KX_FILBIT,FEP*LENGTHC(KX_FILBIT)));
 1366
 1367      DCL 1 FPTN STCLASS,
 1368            2 %CHARTEXT('FUNCTION') UBIN BYTE CALIGNED %INIT(FUNCTION)%EINIT,
 1369                          /*K*   FUNCTION = OPTION
 1370                                 specifies one of the following functions:
 1371
 1372                                 CLR_RQS - clear request, the default.
 1373
 1374                                 CLR_IND - clear indication.
 1375
 1376                                 CLR_CNF - clear confirmation.
 1377
 1378                                 CLR_RSP - clear response.
 1379
 1380                          */
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  42   
 1381            2 %CHARTEXT('CAUSE') UBIN BYTE CALIGNED %INIT(CAUSE)%EINIT,
 1382                          /*K*    CAUSE = VALUE-DEC(0-255)
 1383                                  specifies the clear cause.  Values are of
 1384                                  the form %KX_CAUSE_? as defined in KX_EQUS_E.
 1385                                  If DIAG is coded according to %KX_DIAG_? in
 1386                                  KX_EQUS_E, CAUSE should be '00'hex.  Otherwise
 1387                                  CAUSE should be '80'hex.  The default is %KX_CAUSE_DTE#.
 1388                          */
 1389            2 %CHARTEXT('DIAG') UBIN BYTE CALIGNED %INIT(DIAG)%EINIT,
 1390                          /*K*    DIAG = VALUE-DEC(0-255)
 1391                                  specifies the clear diagnostic.  Values
 1392                                  are of the form %KX_DIAG_? as defined in KX_EQUS_E,
 1393                                  or are user-defined.
 1394                          */
 1395
 1396            2 %CHARTEXT('CLDADRLNG') UBIN BYTE CALIGNED %INIT(CLDADRLNG)%EINIT,
 1397                          /*K*   CLDADRLNG = VALUE-DEC(0-14)
 1398                                 specifies the number of binary coded
 1399                                 decimal digits in the called address.
 1400                                 The default is 0.
 1401                                 CLDADRLNG is ignored in CLR_RQS and CLR_RSP messages.
 1402                          */
 1403            2 CLDADR CALIGNED,
 1404                          /*K*   CLDADR specifies the binary coded decimal digits
 1405                                 (BCD) of the called address.  This
 1406                                 parameter is applicable to CLR_IND
 1407                                 and CLR_CNF only, and is initialized in
 1408                                 the following way.
 1409                                 If the address is '129' then CLDADRPAIR_1 = 18
 1410                                 and CLDADRPAIR_2 = 144, since 18 equals '12'hex
 1411                                 and 144 equals '90'hex.
 1412                          */
 1413              3 %CHARTEXT('CLDADRPAIR_1') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_1)%EINIT,
 1414                          /*K*   CLDADR.CLDADRPAIR_1 = VALUE-DEC(0-255) specifies
 1415                                 BCDs 1 and 2.  The default is 0.
 1416                          */
 1417              3 %CHARTEXT('CLDADRPAIR_2') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_2)%EINIT,
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  43   
 1418                          /*K*   CLDADR.CLDADRPAIR_2 = VALUE-DEC(0-255) specifies
 1419                                 BCDs 3 and 4.  The default is 0.
 1420                          */
 1421              3 %CHARTEXT('CLDADRPAIR_3') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_3)%EINIT,
 1422                          /*K*   CLDADR.CLDADRPAIR_3 = VALUE-DEC(0-255) specifies
 1423                                 BCDs 5 and 6.  The default is 0.
 1424                          */
 1425              3 %CHARTEXT('CLDADRPAIR_4') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_4)%EINIT,
 1426                          /*K*   CLDADR.CLDADRPAIR_4 = VALUE-DEC(0-255) specifies
 1427                                 BCDs 7 and 8.  The default is 0.
 1428                          */
 1429              3 %CHARTEXT('CLDADRPAIR_5') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_5)%EINIT,
 1430                          /*K*   CLDADR.CLDADRPAIR_5 = VALUE-DEC(0-255) specifies
 1431                                 BCDs 9 and 10.  The default is 0.
 1432                          */
 1433              3 %CHARTEXT('CLDADRPAIR_6') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_6)%EINIT,
 1434                          /*K*   CLDADR.CLDADRPAIR_6 = VALUE-DEC(0-255) specifies
 1435                                 BCDs 11 and 12.  The default is 0.
 1436                          */
 1437              3 %CHARTEXT('CLDADRPAIR_7') UBIN BYTE CALIGNED %INIT(CLDADRPAIR_7)%EINIT,
 1438                          /*K*   CLDADR.CLDADRPAIR_7 = VALUE-DEC(0-255) specifies
 1439                                 BCDs 13 and 14.  The default is 0.
 1440                          */
 1441            2 CLDADRPAIR (0:6) REDEF CLDADR UBIN BYTE CALIGNED,
 1442            2 CLDADRSTRING REDEF CLDADR CHAR(7) CALIGNED,
 1443            2 %CHARTEXT('ADRMODRSN') UBIN BYTE CALIGNED %INIT(ADRMODRSN)%EINIT,
 1444                          /*K*   ADRMODRSN = OPTION  specifies the address
 1445                                 modification reason.  In a CLR_IND or CLR_CNF
 1446                                 message, ADRMODRSN specifies
 1447                                 the reason for the change in the called
 1448                                 address from the originally requested
 1449                                 destination address.  If the value is not NON (0), the
 1450                                 modified called address is returned in CLDADRLNG
 1451                                 and CLDADR, which normally can be ignored.
 1452
 1453                                 NON - no redirection, the default.
 1454
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  44   
 1455                                 HNT - redirection within a hunt group.
 1456
 1457                                 BSY - redirection due to DTE busy.
 1458
 1459                                 DWN - redirection due to DTE out of order.
 1460
 1461                                 SYS - systematic call redirection.
 1462
 1463                          */
 1464            2 %CHARTEXT('CHRINFLNG') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(CHRINFLNG)%EINIT,
 1465                          /*K*   CHRINFLNG = VALUE-DEC(0-255)
 1466                                 specifies the length, in bytes, of the
 1467                                 charging information received.  This parameter
 1468                                 is applicable to CLR_IND and CLR_CNF only.
 1469                          */
 1470            2 %CHARTEXT('CHRINFBYTX') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(CHRINFBYTX)%EINIT,
 1471                          /*K*   CHRINFBYTX = VALUE-DEC(0-255)
 1472                                 specifies the byte offset, from the end
 1473                                 of the FPT, of the charging information
 1474                                 received.  This parameter is applicable to CLR_IND
 1475                                 and CLR_CNF only.
 1476                                 Interpretation of such information
 1477                                 is left up to the host application.
 1478                          */
 1479            2 %CHARTEXT('USRDATLNG') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(USRDATLNG)%EINIT,
 1480                          /*K*    USRDATLNG = VALUE-DEC(0-128)
 1481                                  specifies the length (up to 128) in bytes
 1482                                  of the clear user data.  This parameter is
 1483                                  applicable to fast select circuits only.
 1484                          */
 1485            2 %CHARTEXT('USRDATBYTX') UBIN (%(18-2*FEP)) %KX_DBLBYTALG %INIT(USRDATBYTX)%EINIT LAST
 1486                          /*K*    USRDATBYTX = VALUE-DEC(0-255)
 1487                                  specifies the byte offset, from the end
 1488                                  of the FPT, to the clear user data field.
 1489                                  This parameter is applicable to fast select
 1490                                  circuits only.
 1491                          */
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  45   
 1492      %MEND;
 1493
 1494
 1495      /*F* NAME: CL-RES Example
 1496
 1497      The following SUPER JCL can be used to create an HDLC link and an associated
 1498      OUTGOING Communication Line resource.
 1499      ..::FG "Creating HDLC Link, Outgoing Packet Level CL Resource\18"
 1500      !SUPER
 1501      REMOVE DEVICE OUTVCS
 1502      REMOVE LINK X28LNK
 1503      CREATE DEVICE OUTVCS
 1504      USE = RESOURCE
 1505      TYPE = CL
 1506      MODE = OUTGOING
 1507      RNAME = MYX28
 1508      X28 = YES
 1509      Q
 1510      CREATE LINK X28LNK
 1511      ADDRESS=2136496870
 1512      Q
 1513      CREATE DEVICE OUTVCS FOR LINK X28LNK
 1514      CIRCUITS=100
 1515      MODE=OUTGOING
 1516      Q
 1517      Q
 1518      ..::FG
 1519      When the preceding JCL is executed, the result will be as follows:
 1520      ..::FG "Display of HDLC Link for CL Resource\31"
 1521      }CMD*DI DEVICE OUTVCS
 1522      }
 1523      }devices
 1524      } DEVICE OUTVCS FOR STATION LOCAL
 1525      }   USE =          RESOURCE             TYPE =         CL
 1526      }      PROFILE =      NONE
 1527      }      PASSWORD =     NONE
 1528      }      MODE =         OUTGOING          RNAME =        MYX28
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  46   
 1529      }      AUACCOUNT =    NONE              B300 =         NO
 1530      }      B1200 =        NO                B2400 =        NO
 1531      }      HAYES =        NO                X28 =          YES
 1532      }      RFU1 =         NO                RFU2 =         NO
 1533      }      RFU3 =         NO                RFU4 =         NO
 1534      }      RFU5 =         NO                RFU6 =         NO
 1535      }      RFU7 =         NO                RFU8 =         NO
 1536      }      RFU9 =         NO                RFU10 =        NO
 1537      }      RFU11 =        NO                RFU12 =        NO
 1538      }      RFU13 =        NO
 1539      }
 1540      }
 1541      }       1 device displayed.
 1542      }CMD*DI LINK X28LNK
 1543      }
 1544      }links
 1545      }
 1546      }LINK X28LNK  PRO=$LINK  ADDRESS=2136496870  MODE=DTE
 1547      }LIC=   1   HIC=4095   LOC=   1   HOC=4095  DEFAULT VC PRO = $VIRCIR
 1548      }DEST =                  QOS = 095
 1549      }
 1550      }  NAME      CIRCUITS  PROTOCOL  SUBADDR            MODE
 1551      }  OUTVCS       100        0        0              OUTGOING
 1552      ..::FG
 1553      Following is an example program that uses the CL resource created above.
 1554      ..::FG "Sample Program Using Packet Level CL Resource"
 1555      }EXAMPLE: PROC MAIN;
 1556      }
 1557      }%INCLUDE KX_EQUS_E;
 1558      }%INCLUDE KXX_MACROS_M;
 1559      }
 1560      }%INCLUDE CP_6;
 1561      }%INCLUDE CP_6_SUBS;
 1562      }%INCLUDE B$JIT;
 1563      }%INCLUDE B_ERRORS_C;
 1564      }%INCLUDE XUR_ENTRY;
 1565      }DCL B$JIT$ PTR SYMREF;
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  47   
 1566      }DCL B$TCB$ PTR SYMREF;
 1567      }%B$TCB ( STCLASS = "BASED (B$TCB$)" );
 1568      }%B$ALT;
 1569      }%FPT_OPEN ( FPTN = OPEN_CL, DVFC = '@', RES = 'CL',
 1570      }            ATTR = %ATTR_CL_X28#, DCB = M$VC, SN = MYX28 );
 1571      }%VLP_SN ( FPTN = MYX28, SN = 'MYX28' );
 1572      }%FPT_CLOSE ( FPTN = CLOSE_CL, DCB = M$VC );
 1573      }
 1574      }%FPT_WRITE ( FPTN=WRITE_CAL_RQS, BUF=CAL_RQS, TRANS=YES, DCB=M$VC );
 1575      }
 1576      }/?*
 1577      }   We are supplying the call user data field. It normally begins with a
 1578      }   protocol id.
 1579      }*?/
 1580      }%VC$CAL ( FPTN = CAL_RQS, CLDADRLNG = 4, CLDADRPAIR_1 = 153,
 1581      }   CLDADRPAIR_2 = 1, USRDATLNG = 14, LAST = "," );
 1582      }   2 USRDAT CHAR(14) CALIGNED INIT('How do you do?');
 1583      }/?*
 1584      }   Other useful VC macros
 1585      }*?/
 1586      }%VC$DAT ( STCLASS = BASED );
 1587      }%VC$CLR ( STCLASS = BASED );
 1588      }
 1589      }%FPT_READ ( FPTN=READ_VC, BUF=READ_BUF, TRANS=YES, DCB=M$VC );
 1590      }DCL READ_BUF CHAR(4096) STATIC;
 1591      }DCL READ_BUF_ARRAY(0:4095) REDEF READ_BUF UBIN BYTE CALIGNED;
 1592      }%FPT_WRITE ( FPTN=WRITE_VC, BUF=WRITE_BUF, TRANS=YES, DCB=M$VC );
 1593      }DCL WRITE_BUF CHAR(4096) STATIC;
 1594      }
 1595      }DCL M$VC DCB;
 1596      }%VLP_ERRCODE ( FPTN=ERR_CODE );
 1597      }
 1598      }/?* Request the virtual circuit. *?/
 1599      }   CALL M$OPEN ( OPEN_CL ) ALTRET ( ERR );
 1600      }/?*
 1601      }   Make a call.
 1602      }*?/
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  48   
 1603      }   CALL M$WRITE ( WRITE_CAL_RQS ) ALTRET ( ERR );
 1604      }/?*
 1605      }   Listen to the circuit.
 1606      }*?/
 1607      }   DO WHILE ( not finish );
 1608      }
 1609      }      CALL M$READ ( READ_VC ) ALTRET ( ERR );
 1610      }/?*
 1611      }   Let's see what we get back.
 1612      }*?/
 1613      }      DO CASE ( READ_BUF_ARRAY(0) );
 1614      }
 1615      }         CASE ( %KX_VCFNC_CAL_CNF# );
 1616      }/?*
 1617      }   Call accepted. We can start sending data or interrupt packets.
 1618      }*?/
 1619      }            ADDR(WRITE_BUF)->VC$DAT.FUNCTION = %KX_VCFNC_DAT_RQS#;
 1620      }            ADDR(WRITE_BUF)->VC$DAT.Q = q-bit setting;
 1621      }            SUBSTR (WRITE_BUF,LENGTHC(VC$DAT),data-length)=data-string;
 1622      }            WRITE_VC.BUF_.BOUND = data-length + LENGTHC(VC$DAT);
 1623      }            CALL M$WRITE ( WRITE_VC ) ALTRET ( ERR );
 1624      }
 1625      }         CASE ( %KX_VCFNC_CLR_IND# );
 1626      }/?*
 1627      }   Give a clear response.
 1628      }*?/
 1629      }            ADDR(WRITE_BUF)->VC$CLR.FUNCTION = %KX_VCFNC_CLR_RSP#;
 1630      }            WRITE_VC.BUF_.BOUND = LENGTHC(VC$CLR);
 1631      }            CALL M$WRITE ( WRITE_VC ) ALTRET ( ERR );
 1632      }            finish = yes;
 1633      }
 1634      }         CASE ( %KX_VCFNC_DAT_IND# );
 1635      }/?*
 1636      }   Received some data.
 1637      }*?/
 1638      }            bytes-read = DCBADDR(DCBNUM(M$VC))->F$DCB.ARS#;
 1639    * }            received-data =SUBSTR(READ_BUF,LENGTHC(VC$DAT),bytes-read);
14:57 JUL 28 '97 KXX_MACROS_M.:E05SI/KXX_MACROS_M.:E05TUI                  49   
 1640      }
 1641      }         CASE etc...
 1642      }
 1643      }      END;   /?* end do case *?/
 1644      }/?*
 1645      }   When we are all done, close the DCB and exit
 1646      }*?/
 1647      }   CALL M$CLOSE ( CLOSE_CL );
 1648      }   GOTO L_FIN;
 1649      }
 1650      }ERR:
 1651      }   ERR_CODE = B$TCB.ALT$->B$ALT.ERR;
 1652      }   CALL XUR$ERRMSG ( ERR_CODE );
 1653      }L_FIN:
 1654      }   CALL M$EXIT;
 1655      }
 1656      }END EXAMPLE;
 1657      }
 1658      }
 1659      ..::FG*/

