

14:46 JUL 28 '97 KH$IO.:E05SI                                              1    
    1      /*M* KH$IO FPTs for calling high-level IO routines */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*P* NAME: KH$IO
    9
   10      The KH$IO include file contains the following:
   11
   12      } KH$IO        - Parameters for the KH$IO routines.
   13      } KH$IOLD      - Parameters for the KH$IOLD routines.
   14      } KH$CCPLCT    - Structure describing ELSIE object output.
   15      } KH$DWNLODCCP - Parameters for the KHI$DWNLODCCP routine.
   16      } KH$DWNLODLCT - Parameters for the KHI$DWNLODLCT routine.
   17      } KH$RLCCCPLCT - Parameters for the KHI$RLCCCPLCT routine.
   18
   19      */
   20
   21      /*F* NAME: IO_Services
   22
   23      The hardware provides a set of functions that are invoked
   24      from a PL-6 program by calling the FEP library services
   25      discussed next.
   26
   27      */
   28
   29      /*F* NAME: Interrupt_Services
   30
   31
   32      The interrupt control services allow the handler to
   33      execute privileged instructions that change the
   34      state of the specified interrupt level and to change
   35      the state of the processor to the unprivileged mode.
   36      */
   37      /*F* NAME: KH$IO_ - Parameters for KH$IO Routines
14:46 JUL 28 '97 KH$IO.:E05SI                                              2    
   38
   39      The KH$IO macro, in file KH$IO, is to be used to generate the structure
   40      that supplies the parameters for calling the following IO routines:
   41
   42      .fif
   43           KHI$IO_INPLCTBYT - for IO (input LCT byte).
   44
   45           KHI$IO_OTPLCTBYT - for IO (output LCT byte).
   46
   47           KHI$IO_INP - for all other non-IOLD input IOs.
   48
   49           KHI$IO_OTP - for all other non-IOLD output IOs.
   50      .fin
   51
   52      The STCLASS=storage_class option may be used to define
   53      the storage class.  Default storage class is BASED.
   54      */
   55      %MACRO KH$IO (FPTN = KH$IO, LVL = 1, LAST = ";", STCLASS = BASED,
   56      FNC = 0,
   57      OTPCHN (YES = '1'B, NO = '0'B) = '0'B,
   58      DAT = 0,
   59      ADR = 0,
   60      CHNINT (YES = '1'B, NO = '0'B) = '0'B,
   61      STRIO (YES = '1'B, NO = '0'B) = '0'B,
   62      STPIO (YES = '1'B, NO = '0'B) = '0'B,
   63      BLKRED (YES = '1'B, NO = '0'B) = '0'B,
   64      BLKWRT (YES = '1'B, NO = '0'B) = '0'B,
   65      CCBLSTRST (YES = '1'B, NO = '0'B) = '0'B,
   66      RTRCHN = 0,
   67      INTLVL = 0,
   68      HRDINT (YES = '1'B, NO = '0'B) = '0'B,
   69      PRTSCH (YES = '1'B, NO = '0'B) = '0'B,
   70      SETPRTSCH (YES = '1'B, NO = '0'B) = '0'B,
   71      RAMSLC = 0,
   72      RAMADR = 0,
   73      INTCPU (YES = '1'B, NO = '0'B) = '0'B,
   74      VLDCCB (YES = '1'B, NO = '0'B) = '0'B,
14:46 JUL 28 '97 KH$IO.:E05SI                                              3    
   75      LSTCCB (YES = '1'B, NO = '0'B) = '0'B,
   76      CCBPTR = 0,
   77      TSK = 0,
   78      CNF = 0);
   79      %LSET LISTDIR = '0'B;
   80      %LSET LISTEXP = '1'B;
   81      %LSET LISTCOM = '0'B;
   82      %LSET LISTSUB = '1'B;
   83      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   84      %LSET STR = BITBIN(STR = 'STA' OR STR = 'CON' OR STR = 'EXT');
   85      %LSET RDEF = CHARTEXT(SUBSTR('REDEF ASNSTT',STR*12));
   86      %LSET INIT = CHARTEXT(SUBSTR('/*INIT',STR*2,2+STR*2));
   87      %LSET ENIT = CHARTEXT(SUBSTR('*/',STR*2));
   88      %LSET LST = CHARTEXT(SUBSTR(CONCAT(',',TEXTCHAR(LAST)),STR,1));
   89      %IF LVL = 1;
   90      DCL 1 FPTN STCLASS WALIGNED,
   91      %ELSE;
   92      %IF TEXTCHAR(FPTN) ~= '';
   93      %(LVL) FPTN,
   94      %ENDIF;
   95      %ENDIF;
   96      %(LVL+1) * BIT(9) %INIT('0'B)%ENIT UNAL,
   97      %(LVL+1) %CHARTEXT('OTPCHN') BIT(1) %INIT(OTPCHN)%ENIT UNAL,
   98      /*K* OTPCHN = VALUE-BIT(1).  '1'B specifies the IO is to the output channel.
   99      OTPCHN doesn't need to be initialized for INPLCTBYT or OTPLCTBYT
  100      (the input channel is always used).
  101      */
  102      %(LVL+1) %CHARTEXT('FNC') UBIN(6) %INIT(FNC)%ENIT UNAL,
  103      /*K* FNC = VALUE-DEC(0-63).  IO function code describing this
  104      IO operation.  Values are GH#IO_function from the GH_IOFNC_E include file.
  105      FNC doesn't need to be initialized for calls to KH$IO for INPLCTBYT
  106      or OTPLCTBYT;  KHI$IO_... will always use the proper function code.
  107      */
  108      /***********************/
  109      %IF STR=0 OR FNC=GH#IO_INPDATSETSTT;
  110      %(LVL+1) ASNSTT,
  111      /*K* ASNSTT.  Data set status, for asynchronous CLAs.
14:46 JUL 28 '97 KH$IO.:E05SI                                              4    
  112      Valid for the function GH#IO_INPDATSETSTT.
  113      */
  114      %(LVL+2) DSR BIT(1) UNAL,
  115      /*K* ASNSTT.DSR = VALUE-BIT(1).  Indicates presence of data set ready.
  116      */
  117      %(LVL+2) CTS BIT(1) UNAL,
  118      /*K* ASNSTT.CTS = VALUE-BIT(1).  Indicates presence of clear to send (from modem).
  119      */
  120      %(LVL+2) CD BIT(1) UNAL,
  121      /*K* ASNSTT.CD = VALUE-BIT(1).  Indicates presence of carrier detect (from modem).
  122      */
  123      %(LVL+2) RI BIT(1) UNAL,
  124      /*K* ASNSTT.RI = VALUE-BIT(1).  Indicates presence of ring indicate (from modem).
  125      */
  126      %(LVL+2) * BIT(2) UNAL,
  127      %(LVL+2) OVRRUN BIT(1) UNAL,
  128      /*K* ASNSTT.OVRRUN = VALUE-BIT(1).  Indicates a receive over-run occurred.
  129      */
  130      %(LVL+2) FRMERR BIT(1) UNAL,
  131      /*K* ASNSTT.FRMERR = VALUE-BIT(1).  Indicates a framing error occurred.
  132      */
  133      %(LVL+2) * BIT(8) UNAL,
  134      %(LVL+1) SNCSTT REDEF ASNSTT,
  135      /*K* SNCSTT.  Data set status, for synchronous CLAs.
  136      Valid for the function GH#IO_INPDATSETSTT.
  137      */
  138      %(LVL+2) DSR BIT(1) UNAL,
  139      /*K* SNCSTT.DSR = VALUE-BIT(1).  Indicates presence of data set ready.
  140      */
  141      %(LVL+2) CTS BIT(1) UNAL,
  142      /*K* SNCSTT.CTS = VALUE-BIT(1).  Indicates presence of clear to send (from modem).
  143      */
  144      %(LVL+2) CD BIT(1) UNAL,
  145      /*K* SNCSTT.CD = VALUE-BIT(1).  Indicates presence of carrier detect (from modem).
  146      */
  147      %(LVL+2) RI BIT(1) UNAL,
  148      /*K* SNCSTT.RI = VALUE-BIT(1).  Indicates presence of ring indicate (from modem).
14:46 JUL 28 '97 KH$IO.:E05SI                                              5    
  149      */
  150      %(LVL+2) * BIT(2) UNAL,
  151      %(LVL+2) OVRRUN BIT(1) UNAL,
  152      /*K* SNCSTT.OVRRUN = VALUE-BIT(1).  Indicates a receive over-run occurred.
  153      */
  154      %(LVL+2) UNDRUN BIT(1) UNAL,
  155      /*K* SNCSTT.UNDRUN = VALUE-BIT(1).  Indicates a transmit under-run occurred.
  156      */
  157      %(LVL+2) * BIT(8) UNAL %LST
  158      /***********************/
  159      %LSET STR=-STR;
  160      %ENDIF;
  161      %LSET FNT = TEXTCHAR(FNC);
  162      %IF STR=0 OR FNC=GH#IO_INPLCTBYT OR FNC=GH#IO_OTPLCTBYT OR FNT='GH#IO_REDCLRLCTBYT';
  163      %(LVL+1) LCTBYT %RDEF WALIGNED,
  164      %(LVL+2) %CHARTEXT('DAT') UBIN BYTE %INIT(DAT)%ENIT UNAL,
  165      /*K* LCTBYT.DAT = VALUE-DEC(0-255).  The data contained in the
  166      LCT byte being input or output.
  167      Valid for functions GH#IO_INPLCTBYT and GH#IO_OTPLCTBYT.
  168      */
  169      %(LVL+2) %CHARTEXT('ADR') UBIN BYTE %INIT(ADR)%ENIT UNAL %LST
  170      /*K* LCTBYT.ADR = VALUE-DEC(0-255).  Specifies the LCT address of the
  171      LCT byte being input or output.
  172      Valid for functions GH#IO_INPLCTBYT and GH#OTPLCTBYT.
  173      */
  174      /***********************/
  175      %LSET STR=-STR;
  176      %ENDIF;
  177      %IF STR=0 OR (FNC = GH#IO_INPRNG);
  178      %(LVL+1) RNG %RDEF UBIN WORD %LST
  179      /*K* RNG = VALUE-DEC(0-65535).  Specifies the range residue in the CCB.
  180      Valid for the function GH#IO_INPRNG.
  181      */
  182      /***********************/
  183      %LSET STR=-STR;
  184      %ENDIF;
  185      %IF STR=0 OR (FNC = GH#IO_INPDVCID);
14:46 JUL 28 '97 KH$IO.:E05SI                                              6    
  186      %(LVL+1) DVCID %RDEF UBIN WORD %LST
  187      /*K* DVCID = VALUE-DEC(0-65535).  The device id.
  188      Valid for the function GH#IO_INPDVCID.
  189      */
  190      /***********************/
  191      %LSET STR=-STR;
  192      %ENDIF;
  193      %IF STR=0 OR FNT = 'GH#IO_INPEXTDVCID';
  194      %(LVL+1) EXTDVCID %RDEF UBIN WORD %LST
  195      /*K* EXTDVCID = VALUE-DEC(0-65535).  The extended device id.
  196      Valid for the function GH#IO_INPEXTDVCID.
  197      */
  198      /***********************/
  199      %LSET STR=-STR;
  200      %ENDIF;
  201      %IF STR=0 OR (FNC = GH#IO_OTPCHNCTR);
  202      %(LVL+1) CHNCTR %RDEF,
  203      /*K* CHNCTR.  Specifies the data to be output for
  204      output channel control IOs.
  205      Valid for the function GH#IO_OTPCHNCTR.
  206      */
  207      %(LVL+2) %CHARTEXT('CHNINT') BIT(1) %INIT(CHNINT)%ENIT UNAL,
  208      /*K* CHNCTR.CHNINT = VALUE-BIT(1).  '1'B indicates the channel initialize function
  209      is to be performed.
  210      */
  211      %(LVL+2) %CHARTEXT('STRIO') BIT(1) %INIT(STRIO)%ENIT UNAL,
  212      /*K* CHNCTR.STRIO = VALUE-BIT(1).  '1'B indicates the start IO function
  213      is to be performed.
  214      */
  215      %(LVL+2) %CHARTEXT('STPIO') BIT(1) %INIT(STPIO)%ENIT UNAL,
  216      /*K* CHNCTR.STPIO = VALUE-BIT(1).  '1'B indicates the stop IO function
  217      is to be performed.
  218      */
  219      %(LVL+2) * BIT(1) %INIT('0'B)%ENIT UNAL,
  220      %(LVL+2) %CHARTEXT('BLKRED') BIT(1) %INIT(BLKRED)%ENIT UNAL,
  221      /*K* CHNCTR.BLKRED = VALUE-BIT(1).  '1'B indicates the block mode read function
  222      is to be performed.
14:46 JUL 28 '97 KH$IO.:E05SI                                              7    
  223      */
  224      %(LVL+2) %CHARTEXT('BLKWRT') BIT(1) %INIT(BLKWRT)%ENIT UNAL,
  225      /*K* CHNCTR.BLKWRT = VALUE-BIT(1).  '1'B indicates the block mode write function
  226      is to be performed.
  227      */
  228      %(LVL+2) * BIT(1) %INIT('0'B)%ENIT UNAL,
  229      %(LVL+2) %CHARTEXT('CCBLSTRST') BIT(1) %INIT(CCBLSTRST)%ENIT UNAL,
  230      /*K* CHNCTR.CCBLSTRST = VALUE-BIT(1).  '1'B indicates the CCB list reset function
  231      is to be performed.
  232      */
  233      %(LVL+2) * BIT(8) %INIT('0'B)%ENIT UNAL %LST
  234      /***********************/
  235      %LSET STR=-STR;
  236      %ENDIF;
  237      %IF STR=0 OR FNT = 'GH#IO_INPSLCSTT';
  238      %(LVL+1) SLCSTT %RDEF,
  239      /*K* SLCSTT.  Specifies the interrupt status from an
  240      input SLCC status instruction.
  241      Valid for the function GH#IO_INPSLCSTT.
  242      */
  243      %(LVL+2) * BIT(1) UNAL,
  244      %(LVL+2) BPV BIT(1) UNAL,
  245      /*K* SLCSTT.BPVC= VALUE-BIT(1).  '1'B indicates the main memory program
  246      has supplied an invalid CCB head or tail for GH#IO_OTPCCBPTR.
  247      */
  248      %(LVL+2) * BIT(1) UNAL,
  249      %(LVL+2) NT BIT(1) UNAL,
  250      /*K* SLCSTT.NT = VALUE-BIT(1).  '1'B indicates normal termination of frame(s).
  251      */
  252      %(LVL+2) INT UBIN(4) UNAL,
  253      /*K* SLCSTT.INT = VALUE-UBIN(4).  Value last used in a SLCC INT instruction.
  254      */
  255      %(LVL+2) FTR BIT(1) UNAL,
  256      /*K* SLCSTT.FTR = VALUE-BIT(1).  '1'B indicates a fault in the trap code.
  257      */
  258      %(LVL+2) ILF BIT(1) UNAL,
  259      /*K* SLCSTT.ILF. '1'B indicates an illegal IO function code was received.
14:46 JUL 28 '97 KH$IO.:E05SI                                              8    
  260      */
  261      %(LVL+2) RAMDATTRNCMP BIT(1) UNAL,
  262      /*K* SLCSTT.RAMDATTRNCMP.  '1'B indicates RAM data transfer complete.
  263      */
  264      %(LVL+2) * BIT(1) UNAL,
  265      %(LVL+2) CRCMMRERR BIT(1) UNAL,
  266      /*K* SLCSTT.CRCMMRERR = VALUE-BIT(1).  Corrected memory error (RAM data transfer).
  267      */
  268      %(LVL+2) INVMMRADR BIT(1) UNAL,
  269      /*K* SLCSTT.INVMMRADR = VALUE-BIT(1).  Invalid memory address (RAM data transfer).
  270      */
  271      %(LVL+2) BUSPRTERR BIT(1) UNAL,
  272      /*K* SLCSTT.BUSPRTERR = VALUE-BIT(1).  '1'B indicates a bus parity error occurred.
  273      */
  274      %(LVL+2) UN_CRCMMRERR BIT(1) UNAL %LST
  275      /*K* SLCSTT.UN_CRCMMRERR = VALUE-BIT(1).  '1'B indicates an uncorrectable memory error.
  276      */
  277      /***********************/
  278      %LSET STR = -STR;
  279      %ENDIF;
  280      %IF STR=0 OR FNT = 'GH#IO_INPINTB_STT';
  281      %(LVL+1) INTB_STT %RDEF,
  282      /*K* INTB_STT.  Specifies the interrupt B status from an
  283      input interrupt B status instruction.
  284      Valid for the function GH#IO_INPINTB_STT.
  285      */
  286      %(LVL+2) INTR BIT(1) UNAL,
  287      /*K* INTB_STT.INTR = VALUE-BIT(1).  '1'B indicates the main memory program
  288      has been interrupted by a CCP INTR instruction.
  289      */
  290      %(LVL+2) * BIT(6) UNAL,
  291      %(LVL+2) ILGINSCOD BIT(1) UNAL,
  292      /*K* INTB_STT.ILGINSCOD = VALUE-BIT(1).  '1'B indicates an illegal instruction
  293      code was executed by the MLC-16.
  294      */
  295      %(LVL+2) ILGFNCCOD BIT(1) UNAL,
  296      /*K* INTB_STT.ILGFNCCOD = VALUE-BIT(1).  '1'B indicates an illegal function
14:46 JUL 28 '97 KH$IO.:E05SI                                              9    
  297      code.
  298      */
  299      %(LVL+2) RAMPRTERR BIT(1) UNAL,
  300      /*K* INTB_STT.RAMPRTERR = VALUE-BIT(1).  '1'B indicates a RAM parity error.
  301      */
  302      %(LVL+2) RAMDATTRNCMP BIT(1) UNAL,
  303      /*K* INTB_STT.RAMDATTRNCMP.  RAM data transfer complete.
  304      */
  305      %(LVL+2) STTCHN BIT(1) UNAL,
  306      /*K* INTB_STT.STTCHN = VALUE-BIT(1).  (Data set) status change.
  307      */
  308      %(LVL+2) CRCMMRERR BIT(1) UNAL,
  309      /*K* INTB_STT.CRCMMRERR = VALUE-BIT(1).  Corrected memory error (RAM data transfer).
  310      */
  311      %(LVL+2) INVMMRADR BIT(1) UNAL,
  312      /*K* INTB_STT.INVMMRADR = VALUE-BIT(1).  Invalid memory address (RAM data transfer).
  313      */
  314      %(LVL+2) BUSPRTERR BIT(1) UNAL,
  315      /*K* INTB_STT.BUSPRTERR = VALUE-BIT(1).  '1'B indicates a bus parity error occurred.
  316      */
  317      %(LVL+2) UN_CRCMMRERR BIT(1) UNAL %LST
  318      /*K* INTB_STT.UN_CRCMMRERR = VALUE-BIT(1).  '1'B indicates an uncorrectable memory error.
  319      */
  320      /***********************/
  321      %LSET STR=-STR;
  322      %ENDIF;
  323      %IF STR=0 OR FNC=GH#IO_INPINTCTR OR FNC=GH#IO_OTPINTCTR OR FNT='GH#IO_OTPINTCTRB';
  324      %(LVL+1) INTCTR %RDEF UNAL,
  325      /*K* INTCTR.  Specifies the interrupt control information.
  326      Valid for the functions GH#IO_INPINTCTR and GH#IO_OTPINTCTR.
  327      */
  328      %(LVL+2) %CHARTEXT('RTRCHN') UBIN(10) %INIT(RTRCHN)%ENIT UNAL,
  329      /*K* INTCTR.RTRCHN = VALUE-DEC(0-1023).  Specifies the return channel
  330      (processor ID) for interrupt requests.  (A single-CPU system has
  331      a CPU with a processor id of 0.)
  332      */
  333      %(LVL+2) %CHARTEXT('INTLVL') UBIN(6) %INIT(INTLVL)%ENIT UNAL %LST
14:46 JUL 28 '97 KH$IO.:E05SI                                              10   
  334      /*K* INTCTR.INTLVL = VALUE-DEC(0-63).  Specifies the interrupt
  335      level at which interrupt requests to the CPU should be generated.
  336      */
  337      /***********************/
  338      %LSET STR=-STR;
  339      %ENDIF;
  340      %IF STR=0 OR (FNC = GH#IO_OTPCTR);
  341      %(LVL+1) CTR %RDEF,
  342      /*K* CTR.  Specifies the control flags to be used for
  343      output MLCP/MLC-16 control.
  344      Valid for the function GH#IO_OTPCTR.
  345      */
  346      %(LVL+2) %CHARTEXT('HRDINT') BIT(1) %INIT(HRDINT)%ENIT UNAL,
  347      /*K* CTR.HRDINT = VALUE-BIT(1).  '1'B specifies a hard initialize is to
  348      be performed.
  349      */
  350      %(LVL+2) %CHARTEXT('STPIO') BIT(1) %INIT(STPIO)%ENIT UNAL,
  351      /*K* CTR.STPIO = VALUE-BIT(1).  '1'B indicates the stop IO function
  352      is to be performed for a SLCC channel.
  353      */
  354      %(LVL+2) %CHARTEXT('STRIO') BIT(1) %INIT(STRIO)%ENIT UNAL,
  355      /*K* CTR.STRIO = VALUE-BIT(1).  '1'B indicates the start IO function
  356      is to be performed for a SLCC channel.
  357      */
  358      %(LVL+2) * BIT(5) %INIT('0'B)%ENIT UNAL,
  359      %(LVL+2) %CHARTEXT('PRTSCH') BIT(1) %INIT(PRTSCH)%ENIT UNAL,
  360      /*K* CTR.PRTSCH = VALUE-BIT(1).  '1'B specifies a round robin scheduling
  361      for the MLC-16.  '0'B specifies fixed scheduling.
  362      */
  363      %(LVL+2) * BIT(1) %INIT('0'B)%ENIT UNAL,
  364      %(LVL+2) %CHARTEXT('SETPRTSCH') BIT(1) %INIT(SETPRTSCH)%ENIT UNAL,
  365      /*K* CTR.SETPRTSCH = VALUE-BIT(1).  '1'B specifies PRTSCH should be set.
  366      */
  367      %(LVL+2) * BIT(3) %INIT('0'B)%ENIT UNAL,
  368      %(LVL+2) %CHARTEXT('RAMSLC') UBIN(2) %INIT(RAMSLC)%ENIT UNAL %LST
  369      /*K* CTR.RAMSLC = VALUE-DEC(0-3).  RAMSLC selection for RAMSLC data transfer.
  370      0 = null, 1 = local store (CCP area), 2 = LCT RAM, 3 = CCB and bus RAM.
14:46 JUL 28 '97 KH$IO.:E05SI                                              11   
  371      */
  372      /***********************/
  373      %LSET STR=-STR;
  374      %ENDIF;
  375      %IF STR=0 OR (FNC = GH#IO_OTPCCBCTR);
  376      %(LVL+1) CCBCTR %RDEF,
  377      %(LVL+2) %CHARTEXT('INTCPU') BIT(1) %INIT(INTCPU)%ENIT UNAL,
  378      /*K* CCBCTR.INTCPU = VALUE-BIT(1).  '1'B indicates the FEP CPU should be
  379      interrupted when CCB is complete.
  380      Valid for the function GH#IO_OTPCCBCTR.
  381      */
  382      %(LVL+2) %CHARTEXT('VLDCCB') BIT(1) %INIT(VLDCCB)%ENIT UNAL,
  383      /*K* CCBCTR.VLDCCB = VALUE-BIT(1).  '1'B indicates the CCB is valid.
  384      Valid for the function GH#IO_OTPCCBCTR.
  385      */
  386      %(LVL+2) %CHARTEXT('LSTCCB') BIT(1) %INIT(LSTCCB)%ENIT UNAL,
  387      /*K* CCBCTR.LSTCCB = VALUE-BIT(1).  '1'B indicates this is the last
  388      CCB, and causes the MLCP/MLC-16's LB indicator to be set.
  389      Valid for the function GH#IO_OTPCCBCTR.
  390      */
  391      %(LVL+2) * BIT(13) %INIT('0'B)%ENIT UNAL,
  392      %LSET RDEF=CHARTEXT(CONCAT('REDEF ',SUBSTR('ASNSTTCCBCTR',STR*6,6)));
  393      %(LVL+1) CCBCTR_RAMADR %RDEF UBIN WORD %LST
  394      /*K* CCBCTR_RAMADR = VALUE-DEC(0-65535).  Specifies the MLCP/MLC-16
  395      RAM address to do a block mode read or write to.
  396      Valid for the function GH#IO_OTPCCBCTR.
  397      */
  398      /***********************/
  399      %LSET STR=-STR;
  400      %ENDIF;
  401      %IF STR=0 OR FNT='GH#IO_INPCCBSTT' OR FNT='GH#IO_INPNXTCCBSTT';
  402      %(LVL+1) CCBSTT %RDEF,
  403      /*K* CCBSTT.  Specifies the CCB status from a form
  404      of input CCB status IO instruction.
  405      Valid for the functions GH#IO_INPCCBSTT and GH#IO_INPNXTCCBSTT.
  406      */
  407      %(LVL+2) * BIT(1) UNAL,
14:46 JUL 28 '97 KH$IO.:E05SI                                              12   
  408      %(LVL+2) %CHARTEXT('INTCPU') BIT(1) UNAL,
  409      /*K* CCBSTT.INTCPU = VALUE-BIT(1).  '1'B indicates the main memory program
  410      is to be interrupted when the CCB is completed.
  411      */
  412      %(LVL+2) DATSRVERR BIT(1) UNAL,
  413      /*K* CCBSTT.DATSRVERR = VALUE-BIT(1).  '1'B indicates a data service error
  414      occurred.
  415      */
  416      %(LVL+2) CCBSTTCMP BIT(1) UNAL,
  417      /*K* CCBSTT.CCBSTTCMP = VALUE-BIT(1).  '1'B indicates the CCB status is
  418      complete.
  419      */
  420      %(LVL+2) CCBSRVERR BIT(1) UNAL,
  421      /*K* CCBSTT.CCBSRVERR = VALUE-BIT(1).  '1'B indicates a CCB service error
  422      occurred.
  423      */
  424      %(LVL+2) PRG UNAL,
  425      /*K* CCBSTT.PRG.  Programmer-defined bits.
  426      */
  427      %(LVL+3) BIT1 BIT(1) UNAL,
  428      /*K* CCBSTT.PRG.BIT1 = VALUE-BIT(1).  Programmer-defined bit number 1.
  429      */
  430      %(LVL+3) BIT2 BIT(1) UNAL,
  431      /*K* CCBSTT.PRG.BIT2 = VALUE-BIT(1).  Programmer-defined bit number 2.
  432      */
  433      %(LVL+2) * BIT(2) UNAL,
  434      %(LVL+2) DATCHKERR BIT(1) UNAL,
  435      /*K* CCBSTT.DATCHKERR = VALUE-BIT(1).  '1'B indicates a data check occurred.
  436      */
  437      %(LVL+2) CCBNNZRNG BIT(1) UNAL,
  438      /*K* CCBSTT.CCBNNZRNG = VALUE-BIT(1).  '1'B indicates the range residue is
  439      nonzero.
  440      */
  441      %(LVL+2) STTCHN BIT(1) UNAL,
  442      /*K* CCBSTT.STTCHN = VALUE-BIT(1).  '1'B indicates a data-set status
  443      change occurred.
  444      */
14:46 JUL 28 '97 KH$IO.:E05SI                                              13   
  445      %(LVL+2) CRCMMRERR BIT(1) UNAL,
  446      /*K* CCBSTT.CRCMMRERR = VALUE-BIT(1).  '1'B indicates a correctable memory
  447      error occurred.
  448      */
  449      %(LVL+2) INVMMRADR BIT(1) UNAL,
  450      /*K* CCBSTT.INVMMRADR = VALUE-BIT(1).  '1'B indicates an invalid memory
  451      address was encountered.
  452      */
  453      %(LVL+2) BUSPRTERR BIT(1) UNAL,
  454      /*K* CCBSTT.BUSPRTERR = VALUE-BIT(1).  '1'B indicates a bus parity error
  455      occurred.
  456      */
  457      %(LVL+2) UN_CRCMMRERR BIT(1) UNAL %LST
  458      /*K* CCBSTT.UN_CRCMMRERR = VALUE-BIT(1).  '1'B indicates an uncorrected
  459      memory error occurred.
  460      */
  461      /***********************/
  462      %LSET STR=-STR;
  463      %ENDIF;
  464      %IF STR=0 OR FNC*STR=GH#IO_INPSTT OR FNT='GH#IO_INPALTSTT' OR FNT='GH#IO_INPSTT2';
  465      %(LVL+1) STT %RDEF,
  466      /*K* STT.  Specifies the status word to be
  467      input.
  468      Valid for the functions GH#IO_INPSTT, GH#IO_INPSTT1, and GH#IO_INPSTT2.
  469      */
  470      %(LVL+2) BT(0:15) BIT(1) UNAL %LST
  471      /*K* STT.BT = VALUE-BIT(1) array.  A bit array describing the status word.
  472      */
  473      /***********************/
  474      %LSET STR=-STR;
  475      %ENDIF;
  476      %IF STR=0 OR FNT='GH#IO_OTPCCBPTR' OR FNT='GH#IO_INPCCBSTTPTR';
  477      %(LVL+1) %CHARTEXT('CCBPTR') %RDEF UBIN WORD %INIT(CCBPTR)%ENIT %LST
  478      /*K* CCBPTR = VALUE-DEC(0-65535).  Specifies the CCB pointer to be
  479      input or output to the SLCC (byte offset from CCB base).
  480      Valid for the functions GH#IO_INPCCBSTTPTR, and GH#IO_OTPCCBPTR.
  481      */
14:46 JUL 28 '97 KH$IO.:E05SI                                              14   
  482      /***********************/
  483      %LSET STR = -STR;
  484      %ENDIF;
  485      %IF STR=0 OR FNT='GH#IO_INPTSK' OR FNT='GH#IO_OTPTSK' OR FNT='GH#IO_OTPSLCTSK';
  486      %(LVL+1) %CHARTEXT('TSK') %RDEF UBIN WORD %INIT(TSK)%ENIT %LST
  487      /*K* TSK = VALUE-DEC(0-65535).  Specifies the task word to be
  488      input or output.
  489      Valid for the functions GH#IO_INPTSK, and GH#IO_OTPTSK.
  490      */
  491      /***********************/
  492      %LSET STR=-STR;
  493      %ENDIF;
  494      %IF STR=0 OR (FNC = GH#IO_OTPRAMCTR);
  495      %(LVL+1) %CHARTEXT('RAMADR') %RDEF UBIN WORD %INIT(RAMADR)%ENIT %LST
  496      /*K* RAMADR = VALUE-DEC(0-65535).  Specifies the RAM address for
  497      RAM data transfers for the MLC-16.
  498      */
  499      /***********************/
  500      %LSET STR=-STR;
  501      %ENDIF;
  502      %IF STR=0 OR (FNC = GH#IO_INPCNF) OR (FNC = GH#IO_INPCNFA) OR (FNC = GH#IO_INPCNFB)
  503       OR (FNC = GH#IO_OTPCNF) OR (FNC = GH#IO_OTPCNFA) OR (FNC = GH#IO_OTPCNFB);
  504      %(LVL+1) %CHARTEXT('CNF') %RDEF UBIN WORD %INIT(CNF)%ENIT %LST
  505      /*K* CNF = VALUE-DEC(0-65535).  Specifies the configuration word to be
  506      input or output.
  507      Valid for the functions GH#IO_INPCNF, GH#IO_INPCNFA, GH#IO_INPCNFB,
  508      GH#IO_OTPCNF, GH#IO_OTPCNFA, and GH#IO_OTPCNFB.
  509      */
  510      /***********************/
  511      %LSET STR=-STR;
  512      %ENDIF;
  513      %IF STR>=0;
  514      %(LVL+1) DATA %RDEF UBIN WORD LAST
  515      %ENDIF;
  516      %MEND;
  517
  518
14:46 JUL 28 '97 KH$IO.:E05SI                                              15   
  519
  520      /*F* NAME: KH$IOLD - Parameters for KH$IOLD Routines
  521
  522      The KH$IOLD macro, in file KH$IO, is to be used to generate the structure
  523      that supplies the parameters for calling the following IO routines:
  524
  525      .fif
  526           KHI$IOLD - for IOLD and IO (output CCB control) instructions
  527
  528           KHI$IOLD_FCN - for other IOLD instructions; user specified function
  529      .fin
  530
  531      Note that the use of the KH$IOLD macro will require the KV$VECTOR
  532      macro from the KV$GLB include file.
  533
  534      The STCLASS=storage_class option may be used to define
  535      the storage class.  Default storage class is BASED.
  536      */
  537      %MACRO KH$IOLD (FPTN = KH$IOLD, LVL = 1, LAST = ";", STCLASS = BASED,
  538      INTCPU (YES = '1'B, NO = '0'B) = '0'B,
  539      VLDCCB (YES = '1'B, NO = '0'B) = '0'B,
  540      LSTCCB (YES = '1'B, NO = '0'B) = '0'B,
  541      OTPCHN (YES = '1'B, NO = '0'B) = '0'B,
  542      ADR$ = NIL,
  543      FNC=41,
  544      BYTX = 0,
  545      BYTSIZ = 0);
  546      %LSET LISTDIR = '0'B;
  547      %LSET LISTEXP = '1'B;
  548      %LSET LISTCOM = '0'B;
  549      %LSET LISTSUB = '1'B;
  550      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  551      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  552      %LSET INIT = CHARTEXT(' INIT');
  553      %LSET ENIT = CHARTEXT('');
  554      %ELSE;
  555      %LSET INIT = CHARTEXT('/*');
14:46 JUL 28 '97 KH$IO.:E05SI                                              16   
  556      %LSET ENIT = CHARTEXT('*/');
  557      %ENDIF;
  558      %IF LVL = 1;
  559      DCL 1 FPTN WALIGNED STCLASS,
  560      %ELSE;
  561      %IF TEXTCHAR(FPTN) ~= '';
  562      %(LVL) FPTN,
  563      %ENDIF;
  564      %ENDIF;
  565      %LSET NXTLVL = LVL+1;
  566      %(LVL+1) CCBCTR UNAL,
  567      %(LVL+2) %CHARTEXT('INTCPU') BIT(1) %INIT(INTCPU)%ENIT UNAL,
  568      /*K* CCBCTR.INTCPU = VALUE-BIT(1).  '1'B indicates the FEP CPU should be
  569      interrupted when CCB is complete.
  570      */
  571      %(LVL+2) %CHARTEXT('VLDCCB') BIT(1) %INIT(VLDCCB)%ENIT UNAL,
  572      /*K* CCBCTR.VLDCCB = VALUE-BIT(1).  '1'B indicates the CCB is valid.
  573      If set, the output CCB control IO will be issued, otherwise it won't.
  574      */
  575      %(LVL+2) %CHARTEXT('LSTCCB') BIT(1) %INIT(LSTCCB)%ENIT UNAL,
  576      /*K* CCBCTR.LSTCCB = VALUE-BIT(1).  '1'B indicates this is the last
  577      CCB, and causes the MLCP/MLC-16's LB indicator to be set.
  578      */
  579      %(LVL+2) * BIT(6) %INIT('0'B)%ENIT UNAL,
  580      %(LVL+1) %CHARTEXT('OTPCHN') BIT(1) %INIT(OTPCHN)%ENIT UNAL,
  581      %(LVL+1) %CHARTEXT('FNC') UBIN(6) %INIT(FNC)%ENIT UNAL,
  582      /*K* FNC = VALUE-DEC(0-63).  IO function code describing this
  583      IOLD operation for calls to KHI$IOLD_FNC.
  584      Values are GH#IO_function from the GH_IOFNC_E include file.
  585      FNC doesn't need to be initialized for calls to KHI$IOLD
  586      as it ignores this field.
  587      */
  588      /*K* OTPCHN = VALUE-BIT(1).  '1'B specifies the IOLD/IO is to the output channel.
  589      */
  590      %KV$VECTOR (LVL = NXTLVL, NAME = BFR_, STCLASS = STCLASS, LAST = LAST,
  591      BFR = ADR$, BYTX = BYTX, BYTSIZ = BYTSIZ);
  592      /*K* BFR_ = VDH vector.  Describes the buffer to be IOLD'd.
14:46 JUL 28 '97 KH$IO.:E05SI                                              17   
  593      */
  594      /*K* ADR$ = PTR.  Specifies the address of the buffer to IOLD.
  595      */
  596      /*K* BYTX = VALUE-DEC(0-32767).  Specifies the byte index from BFR$
  597      to the first character to IOLD.
  598      */
  599      /*K* BYTSIZ = VALUE-DEC(0-65535).  Specifies the byte size of the
  600      buffer to IOLD.
  601      */
  602      %MEND;
  603
  604
  605
  606      /*F* NAME: KH$CCPLCT Structure
  607
  608      This structure describes ELSIE object output.
  609      */
  610
  611      %MACRO KH$CCPLCT(NAME = KH$CCPLCT, LVL = 1, STCLASS = BASED, LAST = ";");
  612
  613      %LSET LISTDIR = '0'B;
  614      %LSET LISTEXP = '1'B;
  615      %LSET LISTCOM = '0'B;
  616      %LSET LISTSUB = '1'B;
  617      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  618      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  619      %LSET INIT = CHARTEXT(' INIT');
  620      %LSET ENIT = CHARTEXT('');
  621      %ELSE;
  622      %LSET INIT = CHARTEXT('/*');
  623      %LSET ENIT = CHARTEXT('*/');
  624      %ENDIF;
  625      %IF LVL = 1;
  626      DCL 1 NAME WALIGNED STCLASS,
  627      %ELSE;
  628      %IF TEXTCHAR(NAME) ~= '';
  629      %(LVL) NAME,
14:46 JUL 28 '97 KH$IO.:E05SI                                              18   
  630      %ENDIF;
  631      %ENDIF;
  632
  633      %(LVL+1) CCPLODBIS UBIN WORD,
  634      /*K* CCPLODBIS = VALUE-DEC(0-65535).  Specifies the byte address in MLCP/MLC-16 RAM
  635      to write the CCP to.
  636      */
  637      %(LVL+1) CCPBYTSIZ UBIN WORD,
  638      /*K* CCPBYTSIZ = VALUE-DEC(0-65535).  Specifies the CCP byte size.
  639      */
  640      %(LVL+1) CCPRLCTBLWRDX UBIN WORD,
  641      /*K* CCPRLCTBLWRDX = VALUE-DEC(0-65535).  Specifies the word index from the beginning
  642      of this structure to the beginning of the relocation table for the CCP.
  643      */
  644      %(LVL+1) SLCSPMWRDSIZ REDEF CCPRLCTBLWRDX SBIN WORD,
  645      /*K* SLCSPMWRDSIZ = VALUE-DEC(0-856).  Specifies how much SLCC scratch-pad
  646      memory is to be initialized.  The initialization always starts at location
  647      'A8'X, to avoid the CPU private area.  This value is a REDEF of CCPRLCTBLWRDX.
  648      */
  649      %(LVL+1) LCTBYT(0:255) UBIN BYTE CALIGNED,
  650      %(LVL+1) SLCSPM(0:255) REDEF LCTBYT UBIN BYTE CALIGNED,
  651      /*K* SLCSPM = VALUE-DEC(0-255) array describing SLCC scratch-pad memory
  652      initialization data.  The byte at entry-0 is used to initialize location
  653      'A8'X.  The array is variable in length, and an even number of bytes.
  654      The size is indicated in SLCSPMWRDSIZ, and the CCP starts immediately
  655      after the array.
  656      */
  657      %(LVL+1) LCT REDEF LCTBYT,
  658      /*K* LCTBYT = VALUE-DEC(0-255) array describing the LCT bytes.
  659      */
  660      %(LVL+2) *(0:12) UBIN BYTE CALIGNED,    /* LCTs 0 - 12                        */
  661      %(LVL+2) * BIT(2) UNAL,
  662      %(LVL+2) RCVINTLVL UBIN(6) UNAL,
  663      /*K* RCVINTLVL = VALUE-DEC(0-65535).  Specifies the receive interrupt level.
  664      */
  665      %(LVL+2) *(0:30) UBIN BYTE CALIGNED,    /* LCTs 14 - 44                       */
  666      %(LVL+2) * BIT(2) UNAL,
14:46 JUL 28 '97 KH$IO.:E05SI                                              19   
  667      %(LVL+2) TRNINTLVL UBIN(6) UNAL,
  668      /*K* TRNINTLVL = VALUE-DEC(0-65535).  Specifies the transmitter interrupt level.
  669      */
  670      %(LVL+2) *(0:%(256-46-1)) UBIN BYTE CALIGNED, /* LCTs 46 - 255                */
  671      %(LVL+1) LCTRLCTBL_BYT(0:%(256/8-1)) UBIN BYTE CALIGNED,
  672      /*K* LCTRLCTBL_BYT = VALUE-DEC(0-255) array.  Relocation table for the LCTs.
  673      */
  674      %(LVL+1) LCTRLCTBL_BIT(0:%(256-1)) REDEF LCTRLCTBL_BYT BIT(1) UNAL,
  675      /*K* LCTRLCTBL_BIT = VALUE-BIT(1) array.  Relocation table for the LCTs.
  676      */
  677      %(LVL+1) CCP(0:0) UBIN BYTE UNAL LAST
  678      /*K* CCP = VALUE-DEC(0-255) array.  Specifies the CCP itself.
  679      */
  680      %MEND;
  681      %EJECT;

14:46 JUL 28 '97 KH$IO.:E05SI                                              20   
  682      /*F* NAME: KH$DWNLODCCP - Parameters for KHI$DWNLODCCP
  683
  684      The KH$DWNLODCCP macro in file KH$IO may be used to
  685      generate the structure that supplies the parameters
  686      for the KHI$DWNLODCCP routine.
  687
  688      The STCLASS=storage_class option may be used to define
  689      the storage class.  Default storage class is BASED.
  690
  691      The parameters in the KH$DWNLODCCP structure are as follows:
  692
  693      */
  694      %MACRO KH$DWNLODCCP(NAME = KH$DWNLODCCP, LVL = 1, STCLASS = BASED, LAST = ";",
  695      CCPLCT$ = NIL,
  696      CHN$ = NIL,
  697      CCPLODBIS = 0);
  698
  699      %LSET LISTDIR = '0'B;
  700      %LSET LISTEXP = '1'B;
  701      %LSET LISTCOM = '0'B;
  702      %LSET LISTSUB = '1'B;
  703      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  704      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  705      %LSET INIT = CHARTEXT(' INIT');
  706      %LSET ENIT = CHARTEXT('');
  707      %ELSE;
  708      %LSET INIT = CHARTEXT('/*');
  709      %LSET ENIT = CHARTEXT('*/');
  710      %ENDIF;
  711      %IF LVL = 1;
  712      DCL 1 NAME WALIGNED STCLASS,
  713      %ELSE;
  714      %IF TEXTCHAR(NAME) ~= '';
  715      %(LVL) NAME,
  716      %ENDIF;
  717      %ENDIF;
  718
14:46 JUL 28 '97 KH$IO.:E05SI                                              21   
  719      %(LVL+1) %CHARTEXT('CHN$') PTR %INIT(ADDR(CHN$))%ENIT,
  720      /*K* CHN$ = PTR to the KH$CHN entry.
  721      */
  722      %(LVL+1) %CHARTEXT('CCPLCT$') PTR %INIT(ADDR(CCPLCT$))%ENIT,
  723      /*K* CCPLCT$ = PTR to the segment generated by ELSIE
  724      (KH$CCPLCT structure).
  725      */
  726      %(LVL+1) %CHARTEXT('CCPLODBIS') UBIN WORD %INIT(CCPLODBIS)%ENIT LAST
  727      /*K* CCPLODBIS = VALUE-DEC(0-65535).  Specifies the byte address in MLCP/MLC-16 RAM
  728      to write the CCP to.  If a value of 0 is specified, the load
  729      bias will be obtained from KH$CCPLCT (which is initialized with
  730      the bias specified in the ELSIE assembly).
  731      For the CCP or LCTs to be relocated, the module must have been
  732      assembled with the RELOC option, and the ELSIE 'SECT DATA'
  733      directive must have been specified in the assembly source.
  734      */
  735      %MEND;
  736
  737
  738
  739      /*F* NAME: KH$DWNLODLCT - Parameters for KHI$DWNLODLCT
  740
  741      The KH$DWNLODLCT macro in file KH$IO may be used to
  742      generate the structure that supplies the parameters
  743      for the KHI$DWNLODLCT routine.
  744
  745      The STCLASS=storage_class option may be used to define
  746      the storage class.  Default storage class is BASED.
  747
  748      The parameters in the KH$DWNLODLCT structure are as follows:
  749
  750      */
  751      %MACRO KH$DWNLODLCT(NAME = KH$DWNLODLCT, LVL = 1, STCLASS = BASED, LAST = ";",
  752      CCPLCT$ = NIL,
  753      CHN$ = NIL,
  754      CCPLODBIS = 0,
  755      RCVINTLVL = 0,
14:46 JUL 28 '97 KH$IO.:E05SI                                              22   
  756      TRNINTLVL = 0);
  757
  758      %LSET LISTDIR = '0'B;
  759      %LSET LISTEXP = '1'B;
  760      %LSET LISTCOM = '0'B;
  761      %LSET LISTSUB = '1'B;
  762      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  763      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  764      %LSET INIT = CHARTEXT(' INIT');
  765      %LSET ENIT = CHARTEXT('');
  766      %ELSE;
  767      %LSET INIT = CHARTEXT('/*');
  768      %LSET ENIT = CHARTEXT('*/');
  769      %ENDIF;
  770      %IF LVL = 1;
  771      DCL 1 NAME WALIGNED STCLASS,
  772      %ELSE;
  773      %IF TEXTCHAR(NAME) ~= '';
  774      %(LVL) NAME,
  775      %ENDIF;
  776      %ENDIF;
  777
  778      %(LVL+1) %CHARTEXT('CHN$') PTR %INIT(ADDR(CHN$))%ENIT,
  779      /*K* CHN$ = PTR to the KH$CHN entry.
  780      */
  781      %(LVL+1) %CHARTEXT('CCPLCT$') PTR %INIT(ADDR(CCPLCT$))%ENIT,
  782      /*K* CCPLCT$ = PTR to the segment generated by ELSIE
  783      (KH$CCPLCT structure).
  784      */
  785      %(LVL+1) %CHARTEXT('CCPLODBIS') UBIN WORD %INIT(CCPLODBIS)%ENIT,
  786      /*K* CCPLODBIS = VALUE-DEC(0-65535).  Specifies the byte address in MLCP/MLC-16 RAM
  787      for the CCP.  If a value of 0 is specified, the
  788      bias will be obtained from KH$CCPLCT (which contains the current
  789      bias, specified in the ELSIE assembly, possibly modified by relocation).
  790      For the CCP or LCTs to be relocated, the module must have been
  791      assembled with the RELOC option, and the ELSIE 'SECT DATA'
  792      directive must have been specified in the assembly source.
14:46 JUL 28 '97 KH$IO.:E05SI                                              23   
  793      */
  794      %(LVL+1) %CHARTEXT('RCVINTLVL') UBIN WORD %INIT(RCVINTLVL)%ENIT,
  795      /*K* RCVINTLVL = VALUE-DEC(0-63).  Specifies the receive interrupt
  796      level (level at which the MLCP/MLC-16 will request FEP CPU interrupts).
  797      */
  798      %(LVL+1) %CHARTEXT('TRNINTLVL') UBIN WORD %INIT(TRNINTLVL)%ENIT LAST
  799      /*K* TRNINTLVL = VALUE-DEC(0-63).  Specifies the transmit interrupt
  800      level (level at which the MLCP/MLC-16 will request FEP CPU interrupts).
  801      */
  802      %MEND;
  803
  804
  805
  806      /*F* NAME: KH$RLCCCPLCT - Parameters/Arguments for KHI$RLCCCPLCT
  807
  808      KH$RLCCCPLCT generates the argument structure for KHI$RLCCCPLCT
  809      (relocate CCPs/LCTs).
  810      */
  811      %MACRO KH$RLCCCPLCT(NAME = KH$RLCCCPLCT, LVL = 1, STCLASS = BASED, LAST = ";",
  812      CCPLCT$ = NIL,
  813      CCPLODBIS = 0);
  814
  815      %LSET LISTDIR = '0'B;
  816      %LSET LISTEXP = '1'B;
  817      %LSET LISTCOM = '0'B;
  818      %LSET LISTSUB = '1'B;
  819      %LSET STR = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  820      %IF (STR = 'STA') OR (STR = 'CON') OR (STR = 'EXT');
  821      %LSET INIT = CHARTEXT(' INIT');
  822      %LSET ENIT = CHARTEXT('');
  823      %ELSE;
  824      %LSET INIT = CHARTEXT('/*');
  825      %LSET ENIT = CHARTEXT('*/');
  826      %ENDIF;
  827      %IF LVL = 1;
  828      DCL 1 NAME WALIGNED STCLASS,
  829      %ELSE;
14:46 JUL 28 '97 KH$IO.:E05SI                                              24   
  830      %IF TEXTCHAR(NAME) ~= '';
  831      %(LVL) NAME,
  832      %ENDIF;
  833      %ENDIF;
  834
  835      %(LVL+1) %CHARTEXT('CCPLCT$') PTR %INIT(ADDR(CCPLCT$))%ENIT,
  836      /*K* CCPLCT$ = PTR to the segment generated by ELSIE
  837      (KH$CCPLCT structure).
  838      */
  839      %(LVL+1) %CHARTEXT('CCPLODBIS') UBIN WORD %INIT(CCPLODBIS)%ENIT LAST
  840      /*K* CCPLODBIS = VALUE-DEC(0-65535).  Specifies the byte address in MLCP/MLC-16 RAM
  841      to relocate the CCP and LCTs to.  If a value of 0 is specified, the load
  842      bias will be obtained from KH$CCPLCT (which is initialized with
  843      the bias specified in the ELSIE assembly).
  844      For the CCP or LCTs to be relocated, the module must have been
  845      assembled with the RELOC option, and the ELSIE 'SECT DATA'
  846      directive must have been specified in the assembly source.
  847      */
  848      %MEND;

