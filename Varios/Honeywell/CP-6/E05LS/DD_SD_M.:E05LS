

14:20 JUL 28 '97 DD_SD_M.:E05SI                                            1    
    1      /*M* DD_SD_M "Static" data macros for Delta */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7      /*X* DMC,DFC */
    8                                              /**/
    9      /*F* NAME: S_D
   10           PURPOSE: "Static" data structure for DELTA.  */
   11                                              /**/
   12      %MACRO S_D (NAME=S_D, STCLASS="BASED(S_D$)");
   13      %LSET STR=SUBSTR(CONCAT(TEXTCHAR(STCLASS),'   '),0,3);
   14      %IF (STR='STA') OR (STR='CON') OR (STR='EXT');
   15       %LSET INIT=CHARTEXT('INIT');
   16       %LSET EINIT=CHARTEXT(' ');
   17      %ELSE;
   18       %LSET INIT=CHARTEXT('/*');
   19       %LSET EINIT=CHARTEXT('*/');
   20      %ENDIF;
   21
   22      DCL 1 NAME STCLASS ALIGNED,
   23            2 INITED BIT(1) %INIT('0'B)%EINIT UNAL,
   24              /*B* INITED - Set if DELTA has been initialized */
   25            2 * BIT(35) %INIT('0'B)%EINIT UNAL,
   26            2 GOIC UBIN,
   27              /* IC VALUE USED TO RETURN TO THE USERS PROGRAM */
   28            2 SAVEIC UBIN,
   29              /* USER'S LAST IC VALUE  */
   30            2 FAULTINS$ PTR,
   31              /* PTR TO INSTRUCTION WHICH CAUSED THE FAULT */
   32            2 FAULTCMD$ PTR,
   33              /* PTR TO DELTA COMMAND WHICH CAUSED THE FAULT */
   34            2 USS$ PTR,
   35              /* PTR TO SAFE-STORE FRAME */
   36            2 SL$ PTR,
   37              /* SPECIAL LOCATION IN USERS PROGRAM ALLOCATED BY LINKER */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            2    
   38            2 SLP1$ PTR,
   39              /* SPECIAL LOCATION + 1, USED FOR TRANSFER SAVEIC+1 */
   40            2 SL UBIN,
   41              /* IC OF SPECIAL LOCATION */
   42            2 EWSQ# SBIN,
   43              /* EFFECTIVE WORKING SPACE QUARTER OF THE FAULT */
   44            2 RETURNN SBIN,
   45              /* FLAG FOR USERGO, INDICATING FAULT/RETURN */
   46            2 ERROR UBIN(36),
   47              /* ERROR NUMBER */
   48            2 OUT_WIDTH SBIN,
   49              /* OUTPUT DEVICE WIDTH */
   50            2 IXFIX SBIN,
   51              /* INDEX OF STORED COMMAND WHICH PRODUCED THIS FAULT */
   52            2 ACCESS BIT(1) ALIGNED,
   53              /* USER ACCESS FLAG */
   54            2 DO_SCAN BIT(1) ALIGNED,
   55              /* XDELTA IN DO/SCAN EXECUTION CYCLE */
   56            2 GO_MODE BIT(1) ALIGNED,
   57              /* STOP/GO MODE FLAG */
   58            2 REM_DO_SCAN REMEMBER,
   59              /* REMEMBER AUTO AND LABEL INCASE OF FAULT IN DELTA */
   60            2 REM_ACCESS REMEMBER,
   61              /* REMEMBER AUTO AND LABEL IN CASE OF FAULT ACCESSING USER */
   62            2 BREAK BIT(1) ALIGNED,
   63              /* BREAK KEY FLAG */
   64            2 TIC SBIN,
   65              /* LOCATION OF FAULT-CAUSING INSTRUCTION */
   66            2 FAULT SBIN,
   67              /* FAULT CODE FROM SAFE-STORE */
   68            2 DO$ PTR,
   69              /* PTR TO COMMAND WHICH IS TO BE 'DONE' IN SOME DO ROUTINE */
   70            2 ERROR_SYM$ PTR,
   71              /* TOKEN FOR ERROR MSG (TEXTC FORMAT) */
   72            2 VARNEXT$ PTR,
   73              /* PTR TO NEXT AVAILABLE WORD IN VARCOM AREA */
   74            2 SV,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            3    
   75              /* Value type special symbols */
   76              3 HIGH SBIN,
   77                /* High limit for FIND/ZERO */
   78              3 LOW SBIN,
   79                /* Low limit for FIND/ZERO */
   80              3 MASK SBIN,
   81                /* Mask for FIND/ZERO */
   82              3 DELENT SBIN,
   83                /* Entry type code '$ENT$
   84                       Value:
   85                          1 - Program EXIT
   86                          2 - Program TRAP
   87                          3 - LIBRARY detected error
   88                          4 - MONITOR detected error
   89                          5 - M$SEGLD
   90                          6 - BREAK
   91                          7 - TRAP in DELTA
   92                                                          */
   93              3 IOBUFSZ SBIN,
   94                /* Size for IOBUF last read/next write */
   95            2 SPEC(0:4) REDEF SV SBIN,
   96              /* ARRAY ACCESS TO SPECIAL SYMBOLS */
   97            2 DESC$ PTR,
   98              /* POINTER WHERE TO START BUILDING DATA DESCRIPTOR */
   99            2 DESCL$ PTR,
  100              /* POINTER TO 1ST WORD BEYOND DESCR$ */
  101            2 SCHSEG_BEGIN$ PTR,
  102              /* Pointer to beginning of schema in data segment */
  103            2 D$ PTR,
  104              /* POINTER TO 1ST WORD BEYOND WHERE BUILDING STOPPED */
  105            2 UREG$ PTR,
  106              /* POINTS TO USER REGS (Xn, A, Q, E, IND) */
  107            2 IND$ PTR,
  108              /* POINTS TO INDICATOR REGISTER */
  109            2 FIXLAST SBIN,
  110              /* LAST ALLOCATED SLOT IN FIXCOM */
  111            2 STOP BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            4    
  112              /* FLAG STOP ENCOUNTERED IN ATTACHMENTS */
  113            2 RUM_SKIP BIT(1) ALIGNED,
  114              /* RUM skip flag - while RUMing system processors */
  115            2 SCHEMA BIT(1) ALIGNED,
  116              /* SCHEMA FLAG */
  117            2 DEBUGA(0:35) BIT(1) UNAL,
  118              /* Internal debug flags */
  119            2 DEBUGF REDEF DEBUGA UBIN,
  120              /* Internal debug flags as a word */
  121            2 SIMBLEOK BIT(1) ALIGNED,
  122              /* SIMBLE REFERENCE OK FOR SIMEXP/SDO */
  123            2 IFSPEC$ PTR,
  124              /* POINTER TO IFSPEC NODE IF PRESENT, ELSE ADDR(NIL) */
  125            2 SDOS BIT(1) ALIGNED,
  126              /* SDO SIMBLE ENCOUNTERED */
  127            2 SDOD BIT(1) ALIGNED,
  128              /* SDO DECIMAL ENCOUNTERED */
  129            2 SDOO BIT(1) ALIGNED,
  130              /* SDO OCTIL ENCOUNTERED */
  131            2 SDOSDEF BIT(1) ALIGNED,
  132              /* SDO SEARCH SYMDEFS BEFORE ENTDEFS */
  133            2 RANGE_CNT SBIN,
  134              /* COUNT OF RANGE SPECIFICATIONS IN DISPLAY REQUEST */
  135            2 KILL1 SBIN,
  136              /* ID OF COMMAND TO BE KILLED FOR DDA$KILL1 */
  137            2 SHOW1 SBIN ALIGNED,
  138              /* ID OF COMMAND TO BE 'SHOWN' FOR DDA$SHOW1 */
  139            2 NCHARS SBIN,
  140              /* NUMBER OF CHARACTERS READ FROM INPUT DEVICE */
  141            2 SAVE_TEXT_STPOS UBIN,
  142              /* Save starting position of text for data descriptor */
  143            2 ALIB_SAID_ECHO BIT(1) ALIGNED,
  144              /* ECHO parameter in ALIB fpt set - echo ALIB command */
  145            2 ALIB_SAID_QUIET BIT(1) ALIGNED,
  146              /* QUIET parameter in ALIb fpt set - used for PLOVER only */
  147            2 HEAD_LIB BIT(1) ALIGNED,
  148              /* LIB bit in Head record */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            5    
  149            2 RUM_COMMAND BIT(1) ALIGNED,
  150              /* Set if RUM command was processed */
  151            2 FIND_RUM BIT(1) ALIGNED,
  152              /* Set if do FIND in RUM mode - ignore errors from DUU$GETMVAL */
  153            2 BYPASS_SAVE BIT(1) ALIGNED,
  154              /* Save BYPASS flag */
  155            2 ALIB_SAID_GOBACK BIT(1) ALIGNED,
  156              /* RETRN parameter in ALIB fpt */
  157            2 FPRG_CONTEXT$ PTR,
  158              /* Pointer to the first entry for FPRG context, ADDR(NIL) means no FPRGS */
  159            2 FPRG_CONTEXT_END$ PTR,
  160              /* Pointer to the last entry for FPRG context, ADDR(NIL) means no FPRGS */
  161            2 FPRGDCB UBIN,
  162              /* FPRG dcb */
  163            2 FPRG BIT(1) ALIGNED,
  164              /* Set when debugging an FPRG */
  165            2 CURRENT_FPRG_CONTEXT$ PTR,
  166              /* Pointer to currently active FPRG's context */
  167            2 FPRG_CONTEXT_AVAIL$ PTR,
  168              /* Pointer to the list of available slots for FPRG context */
  169            2 FPRG_CONTEXT_AVAIL_END$ PTR,
  170              /* Pointer to the end of the list of available slots for FPRG context */
  171            2 KILLEDEF BIT(1) ALIGNED,
  172              /* Tell POSIT not to use ENTDEFS */
  173            2 L$,
  174              /* For retaining info about $L (last item typed) */
  175              3 VALUE DALIGNED,
  176                4 L SBIN,
  177                4 E REDEF L UBIN(18) ALIGNED,
  178                4 HLF(0:1)  REDEF L UBIN(18) UNAL,
  179                4 R SBIN,
  180                4 * (0:13) UBIN,
  181              3 PVALUE REDEF VALUE,
  182                4 W UBIN(18) UNAL,
  183                4 C UBIN(2) UNAL,
  184                4 B UBIN(4) UNAL,
  185                4 SEG,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            6    
  186                  5 S UBIN(2) UNAL,
  187                  5 D UBIN(10) UNAL,
  188                4 * (0:14) UBIN,
  189              3 VB REDEF VALUE,
  190                4 VBITS(0:71) UBIN(1) UNAL,
  191                4 * (0:13) UBIN UNAL,
  192              3 VC REDEF VALUE,
  193                4 VCHARS(0:7) CHAR(1) UNAL,
  194                4 * (0:13) UBIN UNAL,
  195              3 CV REDEF VALUE,
  196                4 CVALUE CHAR(8),
  197                4 * (0:13) UBIN UNAL,
  198              3 L6_VALUE REDEF VALUE,
  199                4 OPS(0:15) UBIN,
  200              3 SIZE SBIN,
  201              3 FMT UBIN,
  202            2 O$,
  203              /* For retaining info about $O (current open cell) */
  204              3 SEG UBIN,
  205              3 DESC# UBIN,
  206              3 ADDRESS UBIN,
  207              3 NOT_IS BIT(1) HALIGNED,
  208              3 FMT UBIN(18) HALIGNED,
  209            2 LASTBLT$ PTR,
  210              /* PTR TO BEGINNING OF CURRENT COMMAND BEING BUILT */
  211            2 STORED SBIN,
  212              /* CURRENT STORED COMMAND BEING BUILT */
  213            2 OP SBIN,
  214              /* START OPERATOR FOR SIMEXP */
  215            2 ACCUM SBIN,
  216              /* START ACCUMULATOR FOR SIMEXP */
  217            2 UD(0:24),
  218              /* USER DEFINED SYMBOLS */
  219              3 VALUE SBIN,
  220              3 TEXTSZ UBIN(9) UNAL,
  221              3 TEXT CHAR(31) UNAL,
  222            2 SACT BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            7    
  223              /* Special activation character terminated last read flag */
  224            2 RUM_BIRTH$ PTR,
  225              /* Pointer to RUM birth record */
  226            2 ACT CHAR(1) ALIGNED,
  227              /* Activation character that terminated last read */
  228            2 IGNPR BIT(1) ALIGNED,
  229              /* Ignore PR modification for BLD routines */
  230            2 AWDX BIT(1) ALIGNED,
  231              /* AWDX type PR modification for BLD routines */
  232            2 REMACTIVE BIT(1) ALIGNED,
  233              /* DDS$SCAN <--> DDS$BLD communication */
  234            2 ACMDS_OFF UBIN,
  235              /* Offset to text remaining after parse with D_ACMDS tree */
  236            2 ACMDS$ PTR,
  237              /* Pointer to buffer to be scanned with D_ACMDS tree */
  238            2 ACMDS_SIZE UBIN,
  239              /* Size of buffer pointed to by S_D.ACMDS$ */
  240            2 DO_ATTACH UBIN,
  241              /* Number of times DDA$DO_ATTACH has been called */
  242            2 FNDOFFSET BIT(1) ALIGNED,
  243              /* Set by DDR$POSIT if offset was printed (set if 0) */
  244            2 RUM_ERRORS UBIN,
  245              /* Count of errors while RUMing current run unit */
  246            2 RUM_TOTAL_ERRORS UBIN,
  247              /* Total RUM errors for all run units */
  248            2 RCBC,
  249              /* RUM cache buffer control */
  250              3 WRITE_THRU BIT(1) ALIGNED,
  251                /* Whether to write-thru buffers */
  252              3 CUR_SEQ UBIN,
  253                /* LRU sequence counter */
  254              3 BUFSIZE SBIN,
  255                /* Size of each buffer */
  256              3 BUFSM1 UBIN,
  257                /* Number of buffers in use, minus 1 */
  258              3 BUF$(0:9) PTR,
  259                /* Pointer to buffer for program records */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            8    
  260              3 PAGE(0:9) SBIN,
  261                /* Beginning page word address of contents of BUF$ */
  262              3 SIZE(0:9) SBIN,
  263                /* Size of contents of BUF$, -1 means empty */
  264              3 WRITTEN(0:9) BIT(1) HALIGNED,
  265                /* Whether buffer was ever written */
  266              3 NODE(0:9) UBIN HALF HALIGNED,
  267                /* Current node for contents of BUF$ */
  268              3 SEQ(0:9) UBIN,
  269                /* Last time this buffer was used */
  270            2 JDCBERR UBIN,
  271              /* DCB of error corresponding to S_D.JITERR for DUE$HERRMSG */
  272            2 GHOST1 BIT(1) ALIGNED,
  273              /* RUMing system processors/USE GHOST1 */
  274            2 M$DELTA_RES CHAR(4) UNAL,
  275              /* Default RES for M$DELTA */
  276            2 * CHAR(3) UNAL,
  277              /* Padding preceeding vfc character */
  278            2 IBUFVFC CHAR(1) UNAL,
  279              /* Vfc immediately preceeding input buffer */
  280            2 INPUT CHAR(256) ALIGNED,
  281              /* Input buffer, on word boundary, following vfc */
  282            2 REM_DISKBOOT REMEMBER,
  283              /* Unwind remember cell for XDELTA disk boot */
  284            2 QUALIFIED BIT(1) ALIGNED,
  285              /* QUALIFICATION FOUND */
  286            2 MACTIVE BIT(1) ALIGNED,
  287              /* MODIFY ACTIVE */
  288            2 OFFSET_REF BIT(1) ALIGNED,
  289              /* OFFSET REFERENCE ENCOUNTERED FOR SKIP COMMAND */
  290            2 ARRAY,
  291              /* Array processing control info */
  292              3 FIRST BIT(1) ALIGNED,
  293              3 CUR SBIN,
  294              3 HIGH SBIN,
  295            2 ISBASE UBIN ALIGNED,
  296             /* Shrunken IS offset or 0 */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            9    
  297            2 FNDENTDEF BIT(1) ALIGNED,
  298              /* BIT SET BY DDR$POSIT FOR MODIFY DEFAULT FMT */
  299            2 STEP BIT(1) ALIGNED,
  300              /* WAS STEP LAST COMMAND ? 1=YES */
  301            2 FMT_DEFAULT UBIN,
  302              /* USER SPECIFIED DEFAULT FORMAT */
  303            2 SCH,
  304              /* Current schema */
  305              3 OK BIT(1) ALIGNED,
  306                /* 1= Schema exists */
  307              3 PEDEF# UBIN,
  308                /* Primary entdef number */
  309              3 NODE UBIN,
  310                /* Node */
  311              3 NPOINTER UBIN,
  312                /* Primary entdef name pointer */
  313              3 IC UBIN,
  314                /* Instruction counter value */
  315              3 LB# UBIN,
  316                /* Logical block number */
  317              3 PTR$ PTR,
  318                /* XDELTA pointer to in memory schema */
  319            2 QSCH,
  320              /* Qualified schema */
  321              3 OK BIT(1) ALIGNED,
  322                /* 1= Schema exists */
  323              3 PEDEF# UBIN,
  324                /* Primary entdef number */
  325              3 NODE UBIN,
  326                /* Node */
  327              3 NPOINTER UBIN,
  328                /* Primary entdef name pointer */
  329              3 IC UBIN,
  330                /* Instruction counter value */
  331              3 LB# UBIN,
  332                /* Logical block number */
  333              3 PTR$ PTR,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            10   
  334                /* XDELTA pointer to in memory schema */
  335            2 DSCH,
  336              /* Default schema */
  337              3 OK BIT(1) ALIGNED,
  338                /* 1= Schema exists */
  339              3 PEDEF# UBIN,
  340                /* Primary entdef number */
  341              3 NODE UBIN,
  342                /* Node */
  343              3 NPOINTER UBIN,
  344                /* Primary entdef name pointer */
  345              3 IC UBIN,
  346                /* Instruction counter value */
  347              3 LB# UBIN,
  348                /* Logical block number */
  349              3 PTR$ PTR,
  350                /* XDELTA pointer to in memory schema */
  351            2 XSCH,
  352              /* Last resort schema */
  353              3 OK BIT(1) ALIGNED,
  354                /* 1= Schema exists */
  355              3 PEDEF# UBIN,
  356                /* Primary entdef number */
  357              3 NODE UBIN,
  358                /* Node */
  359              3 NPOINTER UBIN,
  360                /* Primary entdef name pointer */
  361              3 IC UBIN,
  362                /* Instruction counter value */
  363              3 LB# UBIN,
  364                /* Logical block number */
  365              3 PTR$ PTR,
  366                /* XDELTA pointer to in memory schema */
  367            2 TSCH,
  368              /* Temporary schema */
  369              3 OK BIT(1) ALIGNED,
  370                /* 1= Schema exists */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            11   
  371              3 PEDEF# UBIN,
  372                /* Primary entdef number */
  373              3 NODE UBIN,
  374                /* Node */
  375              3 NPOINTER UBIN,
  376                /* Primary entdef name pointer */
  377              3 IC UBIN,
  378                /* Instruction counter value */
  379              3 LB# UBIN,
  380                /* Logical block number */
  381              3 PTR$ PTR,
  382                /* XDELTA pointer to in memory schema */
  383            2 MXSCH,
  384              /* Last resort schema for MON */
  385              3 OK BIT(1) ALIGNED,
  386                /* 1= Schema exists */
  387              3 PEDEF# UBIN,
  388                /* Primary entdef number */
  389              3 NODE UBIN,
  390                /* Node */
  391              3 NPOINTER UBIN,
  392                /* Primary entdef name pointer */
  393              3 IC UBIN,
  394                /* Instruction counter value */
  395              3 LB# UBIN,
  396                /* Logical block number */
  397              3 PTR$ PTR,
  398                /* XDELTA pointer to in memory schema */
  399            2 AXSCH,
  400              /* Last resort schema for ALT */
  401              3 OK BIT(1) ALIGNED,
  402                /* 1= Schema exists */
  403              3 PEDEF# UBIN,
  404                /* Primary entdef number */
  405              3 NODE UBIN,
  406                /* Node */
  407              3 NPOINTER UBIN,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            12   
  408                /* Primary entdef name pointer */
  409              3 IC UBIN,
  410                /* Instruction counter value */
  411              3 LB# UBIN,
  412                /* Logical block number */
  413              3 PTR$ PTR,
  414                /* XDELTA pointer to in memory schema */
  415            2 DBG$ PTR,
  416              /* Debug names record page buffer, ADDR(NIL) means none */
  417            2 DBG_LAST UBIN,
  418              /* Last entry number */
  419            2 DBG_PAGE SBIN,
  420              /* Current page in memory, -1 means none */
  421            2 EXST$ PTR,
  422              /* Executable statements record page buffer */
  423            2 EXST_END$ PTR,
  424              /* Last entry pointer */
  425            2 EXST_PAGE SBIN,
  426              /* Current page in memory, -1 means none */
  427            2 IE$ PTR,
  428              /* Internal entrys record page buffer */
  429            2 IE_END$ PTR,
  430              /* Last entry pointer */
  431            2 IE_PAGE SBIN,
  432              /* Current page in memory, -1 means none */
  433            2 VREBL$ PTR,
  434              /* Program variables record page buffer */
  435            2 VREBL_END$ PTR,
  436              /* Last entry pointer */
  437            2 VREBL_PAGE SBIN,
  438              /* Current page in memory, -1 means none */
  439            2 XOU_NAME,
  440              /* Default schema OU name - Textc */
  441              3 SIZE UBIN BYTE UNAL,
  442              3 TEXT CHAR(31) UNAL,
  443            2 RANGE SBIN,
  444              /* OFFSET RANGE FOR USER DEFINED SYMBOLS DISPLAYS */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            13   
  445            2 BYPASS BIT(1) ALIGNED,
  446              /* STEP BYPASS FLAG */
  447            2 PARSIZE UBIN,
  448              /* Size of X$PARSE work buffer */
  449            2 SCHSEG$ PTR,
  450              /* Next unallocated word of data segment containing schema */
  451            2 LB0$ PTR,
  452              /* Pointer to LB0 */
  453            2 LB1$ PTR,
  454              /* Pointer to LB1 */
  455            2 LB$ PTR,
  456              /* Pointer to start of "real" logical block table */
  457            2 LB_EYOND$ PTR,
  458              /* Pointer off of end of logical block table */
  459            2 DNAME$ PTR,
  460              /* DEF names record */
  461            2 EDEF$ PTR,
  462              /* ENTDEFs record */
  463            2 SDEF$ PTR,
  464              /* SYMDEFs record */
  465            2 EDEF_END$ PTR,
  466              /* ENTDEFs record end */
  467            2 SDEF_END$ PTR,
  468              /* SYMDEFs record end */
  469            2 DIRCOM(0:99) UBIN,
  470              /* Direct command buffer */
  471            2 FIXCOM(0:299),
  472              /* Fixed length part of stored commands buffer */
  473              3 CMD UBIN(9) UNAL,
  474              3 INACTIVE BIT(1) UNAL,
  475              3 SILENT BIT(1) UNAL,
  476              3 NOT_IN BIT(1) UNAL,
  477              3 * BIT(4) UNAL,
  478              3 FPRG BIT(1) UNAL,
  479              3 USER BIT(1) UNAL,
  480              3 TAL UBIN HALF UNAL,
  481               3 CDF UBIN UNAL,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            14   
  482               3 * UBIN HALF UNAL,
  483              3 FAI UBIN HALF UNAL,
  484              3 FPRG_RES CHAR(8) UNAL,
  485              3 FPRG_RES_SIZE UBIN UNAL,
  486            2 VARCOM$ PTR,
  487              /* Pointer to variable length part of stored commands buffer */
  488            2 VARCOM_HIGH$ PTR,
  489              /* Pointer to highest word allocated in the data segment for VARCOM */
  490            2 STAND_ALONE BIT(1) ALIGNED,
  491              /* 1= No program associated */
  492            2 BATCH BIT(1) ALIGNED,
  493              /* Batch flag (yes=1) */
  494            2 K$EEP,
  495              3 TYPE UBIN,
  496              /* KEEP FAULTS mode */
  497            2 TR$INFO,
  498              /* TRACE STUFF, IF TYPE=TT, SEE ALSO T$T */
  499              3 SET BIT(1) ALIGNED,
  500                /* SET IF ANY OF THIS STUFF IS VALID, RESET BY KILL TRACE */
  501              3 ACTIVE BIT(1) ALIGNED,
  502                /* SET BY TRACE ON, OR BY WHEN EVER A NEW TRACE TYPE IS SET */
  503              3 SILENT BIT(1) ALIGNED,
  504                /* BUILD HIST BUFFER ONLY */
  505              3 X BIT(1) ALIGNED,
  506                /* EXTERNAL */
  507              3 P BIT(1) ALIGNED,
  508                /* PREFIXED */
  509              3 TYPE UBIN,
  510                /* TRACE TYPE COMMAND CODE */
  511              3 PSIZ UBIN,
  512                /* PREFIX SIZE */
  513              3 PTXT CHAR(24) UNAL,
  514                /* THE PREFIX */
  515              3 USE_TYPE UBIN WORD,
  516                /* For XDELTA, USER or MON */
  517              3 USE_DOM UBIN WORD,
  518                /* For XDELTA, if USER, DOMAIN */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            15   
  519            2 X$EQ,
  520              /* X$EQ frame */
  521              3 ACTIVE BIT(1) ALIGNED,
  522              3 LOC UBIN,
  523              3 INS_LENGTH UBIN,
  524              3 SAVED UBIN,
  525              3 INS(0:3) UBIN,
  526            2 ACTUALIC UBIN ALIGNED,
  527              /* IC from TCB frame without ISBASE added */
  528            2 E$IS,
  529              /* E$IS frame */
  530              3 ACTIVE BIT(1) ALIGNED,
  531              3 LOC UBIN,
  532              3 SAVED UBIN,
  533              3 C,
  534                4 JUNK(0:1) UBIN,
  535            2 SDOH BIT(1) ALIGNED,
  536              /* SDO HEXIL Encountered */
  537            2 DEBUG_CMD BIT(1) ALIGNED,
  538              /* Bit indicating that a DEBUG fprg command has been given to DELTA */
  539            2 DEBUG_CMD_CONTEXT$ PTR,
  540              /* Pointer to fprg context for the fprg in the DEBUG command */
  541            2 PEDEF UBIN,
  542              /* TEMP CELL FOR HOLDING PRIM ENTDEF # OF THIS ITEM IN DDESC */
  543            2 ASTACKOFF UBIN,
  544              /* TEMP CELL FOR HOLDING STACK OFFSET FOR CURRENT AUTO REFERENCE */
  545            2 REM UBIN,
  546              /* REMainder for DDR$MOVE */
  547            2 CURPOS UBIN,
  548              /* CURrent POSition for DDR$MOVE */
  549            2 SNAP_TAKEN BIT(1) ALIGNED,
  550              /* Snap dump already taken flag for DUX$XCON1 */
  551            2 DID_ATTACH BIT(1) ALIGNED,
  552              /* Set when an AT on ONCALL breakpoint is hit with
  553                 a true condition.  Used to avoid duplicate reporting
  554                 when ONCALLS hits same spot.  Set by DDA$DELTA,
  555                 reset by DDA$GO. */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            16   
  556            2 DIRECT_SIZE UBIN,
  557              /* Size of direct text buffer (S_D.DIRECT_TEXT) */
  558            2 DIRECT_OFF UBIN,
  559              /* Current offset into direct text buffer */
  560            2 DO_NESTING_LEVEL UBIN,
  561              /* Current nesting level of DO commands */
  562            2 ECCS DALIGNED,
  563              /* ECCS   3-word block for M$DRTN fpt */
  564              3 SUBC UBIN(36),
  565                /* ECC sub code */
  566              3 EVID UBIN(36),
  567                /* Event id */
  568              3 ERR  UBIN(36),
  569                /* error flags and stuff */
  570            2 DRTN$ PTR,
  571              /* Pointer to FPT$DRTN in DUA$DELTA auto */
  572            2 SCHEMADCB UBIN ALIGNED,
  573              /* Schema DCB for SCHEMA fid or Remote Debug or FANLZ */
  574            2 NODE UBIN,
  575              /* Node of active DEFs */
  576            2 T$T,
  577              /* TRACE TRANSFER STUFF */
  578              3 ACTIVE BIT(1) ALIGNED,
  579                /* ACTIVE FLAG */
  580              3 LOC_SAVED BIT(1) ALIGNED,
  581                /* LOC VALID FLAG */
  582              3 RET_SAVED BIT(1) ALIGNED,
  583                /* FOR CLIMBS */
  584              3 SHARED BIT(1) ALIGNED,
  585                /* Set when last transfer was into shared code */
  586              3 SAVEINS UBIN,
  587                /* REPLACED INSTRUCTION */
  588              3 SAVELOC UBIN(18) UNAL,
  589                /* IC OF SAVEINS */
  590              3 RETLOC UBIN(18) UNAL,
  591                /* IC OF RETINS */
  592              3 RETINS UBIN,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            17   
  593                /* FOR CLIMBS */
  594            2 RESET_IN BIT(1) ALIGNED,
  595              /* Set by DUX$BREAK, to stop read from FID */
  596            2 HIST,
  597              /* HISTORY BUFFER STUFF */
  598              3 START$ PTR,
  599                /* POINTS AT FIRST AVAILABLE SPACE */
  600              3 END$ PTR,
  601                /* POINTS AT LAST AVAILABLE SPACE */
  602              3 CURR$ PTR,
  603                /* POINTS AT CURRENT ENTRY */
  604              3 OUT$ PTR,
  605                /* POINTS AT NEXT OUTPUT ENTRY */
  606              3 ROLLOVER BIT(1) ALIGNED,
  607                /* SET IF CURR$ HAS WRAPPED AROUND */
  608              3 OUT_ACTIVE BIT(1) ALIGNED,
  609                /* SET IF HISTORY HAS BEEN OUTPUT SINCE LAST 'GO', RESET AT EACH 'GO' */
  610              3 ACTIVE BIT(1) ALIGNED,
  611                /* SET IF HISTORY MODE HAS BEEN TURNED ON */
  612              3 EMPTY BIT(1) ALIGNED,
  613                /* SET IF HISTORY BUFFER IS EMPTY */
  614            2 KEEP ALIGNED,
  615              3 FLAG(0:35) BIT(1) UNAL,
  616            2 TRAP ALIGNED,
  617              3 FLAG(0:35) BIT(1) UNAL,
  618            2 IGNORE ALIGNED,
  619              3 FLAG(0:35) BIT(1) UNAL,
  620            2 DEBUG BIT(1) ALIGNED,
  621              /* SET BY DICOFF, RESET BY DICON, USED TO CONTROL ENTRY TO DUD$MINI */
  622            2 JDE UBIN,
  623            2 JITERR REDEF JDE,
  624              3 FCG BIT(12) UNAL,
  625              3 MID BIT(6) UNAL,
  626              3 MON BIT(1) UNAL,
  627              3 CODE UBIN(14) UNAL,
  628              3 SEV UBIN(3) UNAL,
  629            2 LAST_NODE_LOADED UBIN,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            18   
  630              /* USED BY EXECUTION CONTROL ROUTINES */
  631            2 SILENT BIT(1) ALIGNED,
  632              /*SILENT BREAKPOINT IN EFFECT, TELLS MODIFY NOT TO PRINT. */
  633            2 EFMT_DEFAULT UBIN,
  634              /* EVAL DEFAULT FORMAT */
  635            2 SDOB BIT(1) ALIGNED,
  636              /* Bit string found by DDS$SDO */
  637            2 SDOOB BIT(1) ALIGNED,
  638              /* Octal bit string found by DDS$SDO */
  639            2 SDOT BIT(1) ALIGNED,
  640              /* Text string found by DDS$SDO */
  641            2 COPY BIT(1) ALIGNED,
  642              /* Copy DO to UC flag */
  643            2 ECHO BIT(1) ALIGNED,
  644              /* Echo M$DELTA on DO */
  645            2 ONABORT UBIN,
  646              /* Cmd id in FIXCOM of ONABORT frame, 0 =none */
  647            2 ONCALLS UBIN,
  648              /* Cmd id in FIXCOM of ONCALLS frame, 0 =none */
  649            2 ONEXIT UBIN,
  650              /* Cmd id in FIXCOM of ONEXIT frame, 0 =none */
  651            2 ONNODES UBIN,
  652              /* Cmd id in FIXCOM of ONNODES frame, 0 =none */
  653            2 NCMD$ PTR,
  654              /* Ptr to head of current command parse output node */
  655            2 TCB$ PTR,
  656              /* Ptr to user's top TCB frame */
  657            2 EOM BIT(1) ALIGNED,
  658              /* Set if DELTA activation character set in effect */
  659            2 ERROR_HICHAR UBIN UNAL,
  660              /* PCB.HI_CHAR reported by X$PARSE */
  661            2 PATCH BIT(1) ALIGNED,
  662              /* SET IF THIS IS PATCH ENTRY FOR DELTA */
  663            2 RUM BIT(1) ALIGNED,
  664              /* SET DURING RUM MODE */
  665            2 ANLZ BIT(1) ALIGNED,
  666              /* SET BY DUA$ANLZ */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            19   
  667            2 UNODE,
  668              /* USE info for User DELTA */
  669              3 CURRENT UBIN,
  670                /* Node of current IC */
  671              3 USENODE UBIN,
  672                /* Node of USE NODE request */
  673            2 TREE$ PTR,
  674              /* CURRENT OVERLAY STATUS TREE */
  675            2 MTREE$ PTR,
  676              /* IN MEMORY TREE */
  677            2 UTREE$ PTR,
  678              /* USE TREE */
  679            2 OVERLAID BIT(1) ALIGNED,
  680              /* SET IF PROGRAM IS OVERLAID */
  681            2 PADDR UBIN,
  682              /* PROCEDURE START ADDRESS */
  683            2 NODE#M1 UBIN,
  684              /* NUMBER OF NODES, MINUS ONE */
  685            2 B$TREE$ PTR,
  686              /* PTR TO TREE TABLE IN READ-ONLY-SEGMENT */
  687            2 B$TREEHDR$ PTR,
  688              /* PTR TO TREE TABLE HEADER IN READ-ONLY-SEGMENT */
  689            2 NODESEG_USED$ PTR,
  690              /* Beyond current word allocated */
  691            2 NODESEG_NEXT$ PTR,
  692              /* Next word to be used */
  693            2 GOTQUAL3 BIT(1) ALIGNED,
  694              /* Set if QUAL3 (:) encountered by DDS$POSITION */
  695            2 LMDCB UBIN,
  696              /* Dcb used to access RU */
  697            2 B$ROS$ PTR,
  698              /* Pointer to RU/RUM read-only-segment */
  699            2 RUMDCB UBIN,
  700              /* RUM dcb */
  701            2 RUMUTS UBIN,
  702              /* UTS of current RUM command */
  703            2 RUMSEQ UBIN,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            20   
  704              /* Sequence of current RUM command */
  705            2 RUM_HEAD$ PTR,
  706              /* Pointer to RUM head record */
  707            2 RUM_ROS$ PTR,
  708              /* Pointer to RUM read-only-segment */
  709            2 NODESEG$ PTR,
  710              /* Pointer to start of overlay control tables */
  711            2 RUM_TEST BIT(1) ALIGNED,
  712              /* RUM test mode in effect */
  713            2 WHEN_ASL BIT(1) ALIGNED,
  714              /* ASL in control for WHEN */
  715            2 UREG$_SAVE PTR,
  716              /* Save pointer to User registers (Xn, A, Q, E, IND) */
  717            2 DBGFEPDCB UBIN ALIGNED,
  718              /* DCB for Remote Debug */
  719            2 DLIB BIT(1) ALIGNED,
  720              /* Set if XCON entered because of M$DLIB */
  721            2 PIMAGE CHAR(120),
  722              /* Patch print image buffer */
  723            2 PCHARS UBIN,
  724              /* Size of contents of S_D.PIMAGE */
  725            2 PADDR_SAVE UBIN,
  726              /* S_D.PADDR before RUMing */
  727            2 SAVEIC_SAVE UBIN,
  728              /* S_D.SAVEIC before RUMing */
  729            2 ANLZ_FILE BIT(1) ALIGNED,
  730              /* SET if ANLZ FID */
  731            2 ANLZDCB UBIN,
  732              /* Crash dump file dcb number */
  733            2 GOT@ BIT(1) ALIGNED,
  734              /* Set if B_PATCHIH found in root node */
  735            2 NEXT@ UBIN,
  736              /* Next IS address in patch space for procedure */
  737            2 RSPACE@ SBIN,
  738              /* Remaining patch space for procedure */
  739            2 HEAD@ UBIN,
  740              /* Offset to B_PATCHIH in user IS */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            21   
  741            2 DEFINED@ BIT(1) ALIGNED,
  742              /* Set if information in S_D about @ is currently defined */
  743            2 GOT# BIT(1) ALIGNED,
  744              /* Set if B_PATCHDH found in root node */
  745            2 NEXT# UBIN,
  746              /* Next IS address in patch space for data */
  747            2 RSPACE# SBIN,
  748              /* Remaining patch space for data */
  749            2 HEAD# UBIN,
  750              /* Offset to B_PATCHDH in user IS */
  751            2 DEFINED# BIT(1) ALIGNED,
  752              /* Set if information in S_D about # is currently defined */
  753            2 RI$,
  754              3 SIZE UBIN,
  755              3 OPS(0:15) UBIN,
  756              /* Replaced instruction value */
  757            2 NA$ UBIN,
  758              /* Next address (after TRA to @) */
  759            2 ANLZRUM_IC UBIN,
  760              /* Used during return to user by M$ALIB to remember schema ic */
  761            2 POVALUE,
  762              3 SIZE UBIN,
  763              3 OPS(0:15) UBIN,
  764              /* Remember old value for interactive patching */
  765            2 POFMT UBIN,
  766              /* Remember old value's format */
  767            2 HIGH@ UBIN,
  768              /* Offset to upper limit of proc patch space in user IS */
  769            2 ALIB BIT(1) ALIGNED,
  770              /* SET if entry was due to M$ALIB */
  771            2 DUMPDCB UBIN,
  772              /* Dcb number for DUMP command to output through */
  773            2 HIGH# UBIN,
  774             /* Offset to upper limit of data patch space in user IS */
  775            2 E$XIT BIT(1) ALIGNED,
  776              /* SET if EXIT command was given, used by DDA$DELTA */
  777            2 LINK_ENTRY BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            22   
  778              /* Set if entry to DELTA was via M$LINK, EXIT is legal if this bit is set */
  779            2 USS$_SAVE PTR,
  780              /* Save SS pointer when in ANLZ_FILE mode */
  781            2 READPOS UBIN,
  782              /* Sequential record number of record just read */
  783            2 TRACE_STATE BIT(1) ALIGNED,
  784              /* Save trace state for RUM/ANLZ */
  785            2 USVFC BIT(1) ALIGNED,
  786              /* Use special VFC to avoid over-printing */
  787            2 RUM_ONLY BIT(1) ALIGNED,
  788              /* Entered from IBEX by RUM command */
  789            2 PMD_ONLY BIT(1) ALIGNED,
  790              /* Entered from IBEX by PMD command */
  791            2 PROMPT_SIZE UBIN,
  792              /* Prompt size */
  793            2 PROMPT,
  794              /* Prompt VFC + text */
  795              3 VFC CHAR(1) UNAL,
  796                /* Prompt VFC */
  797              3 TEXT CHAR(30) UNAL,
  798                /* Prompt character string */
  799              3 * CHAR(1) UNAL,
  800                /* Unused */
  801            2 UPROMPT CHAR(24),
  802              /* User specified prompt */
  803            2 UPROMPT_SIZE UBIN,
  804              /* Size of user specified prompt */
  805            2 UFPROMPT CHAR(24),
  806              /* User specified prompt for FPRGs */
  807            2 UFPROMPT_SIZE UBIN,
  808              /* Size of user specified prompt for FPRGs */
  809            2 FEP_PADDR UBIN,
  810              /* Start address of procedure for FPRGs */
  811            2 FEP_PSIZE UBIN,
  812              /* Size of procedure for FPRGs */
  813            2 REM_DRTN_QUIT REMEMBER,
  814              /* REMEMBER cell for DRTN_QUIT in DDA$DELTA */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            23   
  815            2 LWEXTEND BIT(1) ALIGNED,
  816              /* Last Write was EXTEND */
  817            2 ENTRYCMD$ PTR,
  818              /* To remember the real FAULTCMD$ in the recursive sections
  819                 of attachment processing, when FAULTCMD$ points to a
  820                 SAVEd string of attachments and not the entry condition. */
  821            2 FIND,
  822              /* SAVE VALUES FOR FIND/STORE */
  823              3 SEG UBIN,
  824              3 ADDRESS UBIN,
  825              3 DESC# UBIN,
  826              3 NUM UBIN,
  827              3 NOT_IS BIT(1) ALIGNED,
  828              3 MASK_F SBIN,
  829              3 * UBIN,
  830            2 BREAK_PRINTED BIT(1) ALIGNED,
  831              /* Break message was already printed flag */
  832            2 REPORT_FLAGS(0:13) ALIGNED,
  833              /* Current report print flags  - Room for 14 compilers */
  834              3 OFFSET BIT(1) UNAL,
  835              3 LINE BIT(1) UNAL,
  836              3 TYPE BIT(1) UNAL,
  837              3 * BIT(33) UNAL,
  838            2 REM_USERGO REMEMBER,
  839              /* Remember cell for USERDO for USERGO */
  840            2 LAST_ERROR,
  841              /* Last error code used by DDE$ERROR, DUE$ERRMSG, DUE$UERRRMSG */
  842              3 FCG_MID BIT(18) UNAL,
  843              3 MON BIT(1) UNAL,
  844              3 ERR# UBIN(14) UNAL,
  845              3 SEV UBIN(3) UNAL,
  846            2 SYNTAX UBIN,
  847              /* Current syntax in effect */
  848            2 GOT$RI BIT(1) ALIGNED,
  849              /* Set if DDK$EVAL got $RI special symbol - need for L6 mode */
  850            2 IS_PTR BIT(1) ALIGNED,
  851              /* Set if $Bn used as a pointer */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            24   
  852            2 BRKRSP_ERRCODE UBIN,
  853              /* ERRCODE for BRKRSP message from FD */
  854            2 USERNO UBIN,
  855              /* User number received in BRKRSP message in L6 XDELTA */
  856            2 REM_BREAK REMEMBER,
  857              /* REMEMBER variable to remember BREAK in DDA$DELTA */
  858            2 MBU BIT(1) ALIGNED,
  859              /* GD$MSG.BRKRSP.MBU - Monitor running on behalf of user for L6 XDELTA */
  860            2 L6_CACHE BIT(1) ALIGNED,
  861              /* If set use L6 cache - else always go get values from FD */
  862            2 INTERPRETIVE BIT(1) ALIGNED,
  863              /* If not set - debugging interpreter in FEP */
  864            2 DUMP_HEAD BIT(1) ALIGNED,
  865              /* Used if dumping HEAD record when RUMming L6 RU */
  866            2 SCREECH_IC REMEMBER,
  867              /* REMEMBER variable for screech IC */
  868            2 HELPING BIT(1) ALIGNED,
  869              /* Set when X$HELPing */
  870            2 SYNTAX_DEFAULT UBIN,
  871              /* Default syntax, established in DUI$RU_ACCESS/DXI$1STIME */
  872            2 PROTECT BIT(1) ALIGNED,
  873              /* PROTECT flag */
  874            2 SAD SBIN,
  875              /* $SAD descriptor number, -1 if none */
  876            2 LASTPD ALIGNED,
  877              /* Info about last primary ENTDEF found */
  878              3 NODE UBIN,
  879                /* Associated node */
  880              3 RANGE SBIN,
  881                /* Range, unknown if < 0,
  882                          unsignificant if = 0 */
  883              3 IC UBIN,
  884                /* Where it's at */
  885              3 PEDEF# UBIN,
  886                /* Entdef number */
  887            2 ANYSD ALIGNED,
  888              /* Info about last SYMDEF found */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            25   
  889              3 NODE UBIN,
  890                /* Associated node */
  891              3 RANGE SBIN,
  892                /* Range, unknown if < 0,
  893                          unsignificant if = 0 */
  894              3 IC UBIN,
  895                /* Where it's at */
  896              3 SDEF# UBIN,
  897                /* Symdef number */
  898            2 NCNSD ALIGNED,
  899              /* Info about last non-constant SYMDEF found */
  900              3 NODE UBIN,
  901                /* Associated node */
  902              3 RANGE SBIN,
  903                /* Range, unknown if < 0,
  904                          unsignificant if = 0 */
  905              3 IC UBIN,
  906                /* Where it's at */
  907              3 SDEF# UBIN,
  908                /* Symdef number */
  909            2 REM_DRTN_KLDELTA REMEMBER,
  910              /* REMEMBER cell for DRTN_DLIB in DDA$DELTA */
  911            2 STEP_L6 BIT(1) ALIGNED,
  912              /* Set if stepping if FPRG */
  913            2 RUM_FEP_USE UBIN,
  914              /* SECTION USED FOR RUMMING M:FEP */
  915            2 S$TEP,
  916              /* STEP control frame */
  917              3 ACTIVE BIT(1) ALIGNED,
  918                /* Set when step in progress */
  919              3 ALT BIT(1) UNAL,
  920                /* Set when CLIMB or call has altret */
  921              3 ONE_FLAG BIT(1) UNAL,
  922                /* Set if step one call is current step command */
  923              3 DOING_SOC BIT(1) UNAL,
  924                /* Set if we're SOCing a subroutine call (TSXn) */
  925              3 * BIT(33) UNAL,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            26   
  926              3 LOC UBIN,
  927                /* return location */
  928              3 ALTLOC UBIN,
  929                /* altreturn location */
  930              3 SAVED UBIN,
  931                /* saved return instruction */
  932              3 ALTSAVED UBIN,
  933                /* save altreturn instruction */
  934              3 EWSQ UBIN,
  935                /* wsq number of step domain */
  936              3 OLD_PTR$ PTR,
  937                /* pointer to stepped instruction,
  938                   used by XDELTA to restore inhibit bit state */
  939              3 CMD_COUNT UBIN,
  940                /* n of STEP n */
  941              3 CUR_COUNT UBIN,
  942                /* current steps during this STEP n */
  943              3 MODE UBIN,
  944                /* current step mode (STATEMENT, PARA, etc.) */
  945            2 ANLZ_MODIFIED BIT(1) ALIGNED,
  946              /* Set the first time something is modified in ANLZ
  947                 mode.  Used to control output of message on console. */
  948            2 WHEN_HIGH$ PTR,
  949              /* Points to highest word allocated in when data segment */
  950            2 WHEN_NEXT$ PTR,
  951              /* Points to next word to be used */
  952            2 WHEN_SET BIT(1) ALIGNED,
  953              /* Set if an active when directive exists */
  954            2 DO_CALLED BIT(1) ALIGNED,
  955              /* Set when DDA$DO is called,
  956                 used to tell if any directives have been performed
  957                 during this trip thru DELTA.  If not, WHEN
  958                 old values don't have to be gathered again. */
  959            2 WHEN_IC UBIN,
  960              /* IC where WHEN derail was put */
  961            2 WHEN_INS UBIN,
  962              /* WHEN replaced instruction */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            27   
  963            2 WHEN_ACTIVE BIT(1) ALIGNED,
  964              /* WHEN derail is planted. */
  965            2 CURRENT_CHANNEL UBIN UNAL,
  966              /* Currently selected channel for L6 XDELTA or FANLZ */
  967            2 CURRENT_CHANNEL_R REDEF CURRENT_CHANNEL,
  968              3 * BIT(20) UNAL,
  969              3 CHAN BIT(16) UNAL,
  970            2 LCTNUM UBIN,
  971              /* current LCT # for MLCT active */
  972            2 MLCT BIT(1) ALIGNED,
  973              /* Set if MLCT active */
  974            2 ANLZ_KLUDGE BIT(1) ALIGNED,
  975              /* SET IF ANLZ @ USES M:MON */
  976            2 EXEC_DOMAIN_SAVE UBIN,
  977              /* Save EXEC_DOMAIN when go into RUM or ANLZ mode */
  978            2 IPRFLT BIT(1) ALIGNED,
  979              /* Set by DUX$TRAP when the fault code is ipr.  Used
  980                 to differentiate between str fault and illegal decimal
  981                 faults. */
  982            2 LABEL_FOUND BIT(1) ALIGNED,
  983              /* Set if DDF$STATEMENT encountered
  984                 a statement with a label when skipping
  985                 statements with the same ic. */
  986            2 FAULTINS UBIN,
  987              /* The instruction underneath a breakpoint derail
  988                 when the SL is used */
  989            2 DA_CPN(0:2) UBIN,
  990              /* CWSQPGS WSQ number for anlz_file */
  991            2 * CHAR(3) UNAL,
  992              /* Padding preceeding vfc character */
  993            2 OBUFVFC CHAR(1) UNAL,
  994              /* Vfc immediately preceeding output buffer */
  995            2 OUTPUT CHAR(2048) ALIGNED,
  996              /* Output buffer, on word boundary, following vfc */
  997             2 XDP REDEF OUTPUT,
  998              /* Output buffer - redefined for XDELTA for patch buffer */
  999              3 IMAGE UNAL,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            28   
 1000                /* Patch image sent to AARDVARK */
 1001                4 INP CHAR(80) UNAL,
 1002                  /* Input image */
 1003                4 OTP CHAR(120) UNAL,
 1004                  /* Output image */
 1005              3 * CHAR(1848) UNAL,
 1006            2 DIRECT_TEXT CHAR(256) ALIGNED,
 1007              /* Direct command text buffer, to allow imbedded MACTIVEs */
 1008            2 HOST_MESSAGE_BUF_REMOTE CHAR(415) CALIGNED,
 1009            2 REMOTE_MSG REDEF HOST_MESSAGE_BUF_REMOTE,
 1010              3 STXC CHAR(1),
 1011              3 STX REDEF STXC,
 1012                4 * BIT(1),
 1013                4 C UBIN(8) UNAL,
 1014              3 FNCC CHAR(1),
 1015              3 FNC REDEF FNCC,
 1016                4 * BIT(1),
 1017                4 C BIT(8) UNAL,
 1018              3 SUBFNCC CHAR(1),
 1019              3 SUBFNC REDEF SUBFNCC,
 1020                4 * BIT(1),
 1021                4 C BIT(8) UNAL,
 1022              3 TXT CHAR(412),
 1023            2 HOST_MESSAGE_BUF REDEF HOST_MESSAGE_BUF_REMOTE,
 1024              /* Message buffer for message exchange with FED - message is in unconverted form */
 1025              3 C CHAR(314) CALIGNED,
 1026              3 * CHAR(101) CALIGNED,
 1027            2 * CHAR(1) UNAL,
 1028              /* UNUSED */
 1029            2 L6_MESSAGE_BUF CHAR(280) CALIGNED,
 1030              /* Message buffer for message exchange with FED - message is in converted form */
 1031            2 REMOTE_MSG_L6 REDEF L6_MESSAGE_BUF,
 1032              /* Message buffer for message exchange with FD for L6 XDELTA */
 1033              3 FNC BIT(8) UNAL,
 1034              3 SUBFNC BIT(8) UNAL,
 1035              3 TXT(0:311) UBIN(8) UNAL,
 1036              3 * BIT(8) UNAL,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            29   
 1037            2 * CHAR(3) UNAL,
 1038              /* UNUSED */
 1039            2 ONE_TO_TWO,
 1040              3 EXEC_DOMAIN UBIN,
 1041                /* Execution Domain */
 1042            2 SHOW BIT(1) ALIGNED,
 1043              /* Set if showing breakpoints so don't go to FD for patch space info */
 1044            2 INT# BIT(1) ALIGNED,
 1045              /* Set in DDA$DELTA is get ECC = %ECC_INT# */
 1046            2 AFD# BIT(1) ALIGNED,
 1047              /* Set if DUX$EVENT if get SUBC2_AFD# event and S_D.INT# is set */
 1048            2 OPDCBNO UBIN,
 1049              /* Set to dcb number from event frame in DUX$EVENT if sets S_D.AFD# */
 1050            2 GOTRAPPOS BIT(1) ALIGNED,
 1051              /* SET IF GOTRAP pos was specified */
 1052            2 GOTRAP_POSITION UBIN,
 1053              /* position specified for GOTRAP */
 1054            2 GOT$L BIT(1) ALIGNED,
 1055              /* Set if $L special symbol found in DDK$EVAL */
 1056            2 MDW BIT(1) ALIGNED,
 1057              /* SET if Modify DW command was last modify command */
 1058            2 FIRST_TIME BIT(1) ALIGNED,
 1059              /* Set if this is first time accessing patch space information
 1060                 so we will get it in DUI$1STIME */
 1061            2 BEEN_TO_SCANREAD BIT(1) ALIGNED,
 1062              /* Set if we need to UNWIND from DUS$SCANREAD */
 1063            2 DO_ATTACHMENTS REMEMBER,
 1064              /* DO_ATTACH labEL in DDA$DELTA */
 1065            2 PARSMORE_REM REMEMBER,
 1066              /* PARSMORE label in DUS$SCAN (unwound from DUS$SCANREAD) */
 1067            2 L6_TAB BIT(1) ALIGNED,
 1068              /* Set if valid L6 TAB value */
 1069            2 L6_TAB_VALUE SBIN,
 1070              /* L6 TAB VALUE */
 1071            2 CAN_I_DO_BREAK BIT(1) ALIGNED,
 1072              /* IF RESET, PROCESSING EVENT FOR USER, DONT ALLOW BREAK COMMAND */
 1073            2 POST_ASSOC BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            30   
 1074              /* SET IF ENTERED FOR CNTL-Y */
 1075            2 EIS ALIGNED,         /* used when LFing in modify active */
 1076              3 DESC# BIT(1) UNAL,  /* set if there's a descriptor left */
 1077              3 DESC_TYPE UBIN(3) UNAL, /* type of the descriptor */
 1078              3 MODS UNAL,
 1079                4 AR BIT(1) UNAL, /* set if AR modification for this 1 */
 1080                4 RL BIT(1) UNAL, /* set if RL modification for this 1 */
 1081                4 ID BIT(1) UNAL, /* set if ID modification for this 1 */
 1082              3 DESC1 UNAL,
 1083                4 DESC# BIT(1) UNAL,
 1084                4 DESC_TYPE UBIN(3) UNAL,
 1085                4 MODS UNAL,
 1086                  5 AR BIT(1) UNAL,
 1087                  5 RL BIT(1) UNAL,
 1088                  5 ID BIT(1) UNAL,
 1089              3 DESC2 UNAL,
 1090                4 DESC# BIT(1) UNAL,
 1091                4 DESC_TYPE UBIN(3) UNAL,
 1092                4 MODS UNAL,
 1093                  5 AR BIT(1) UNAL,
 1094                  5 RL BIT(1) UNAL,
 1095                  5 ID BIT(1) UNAL,
 1096              3 DESC3 UNAL,
 1097                4 DESC# BIT(1) UNAL,
 1098                4 DESC_TYPE UBIN(3) UNAL,
 1099                4 MODS UNAL,
 1100                  5 AR BIT(1) UNAL,
 1101                  5 RL BIT(1) UNAL,
 1102                  5 ID BIT(1) UNAL,
 1103              3 * BIT(8) UNAL,
 1104            2 EIS_SHIFT REDEF EIS,
 1105              3 * BIT(7) UNAL,
 1106              3 X BIT(29) UNAL,
 1107            2 EIS_ACTIVE BIT(1) ALIGNED,
 1108               /* set if DDR$INSTR is allowed to use/set EIS. */
 1109            2 XUG_BUILTIN BIT(1) ALIGNED,
 1110              /* XUG BUILTIN WAS EXECUTED */
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            31   
 1111            2 LMDCB_SAVE UBIN,
 1112              /* TEMP TO SAVE LMDCB */
 1113            2 NODEFS4 BIT(1) ALIGNED,
 1114              /* E@NODEFS4 WAS PRINTED, RESET IN DFA$FPRG (27819) */
 1115            2 LADC BIT(1) ALIGNED,
 1116              /* SET IF SITE IS LADC, MAKES MINI AVAILABLE */
 1117            2 STATUS BIT(1) ALIGNED,
 1118              /* FPL STATUS MODE SET */
 1119            2 ERRFID,
 1120              3 L UBIN(9) CALIGNED,
 1121              3 C CHAR(31) CALIGNED,
 1122               /* NAME FOR ERRFID */
 1123            2 ERRACCT CHAR(8) ALIGNED,
 1124               /* ACCOUNT FOR ERRFID */
 1125            2 ERRPASS CHAR(8) ALIGNED,
 1126               /* PASSWORD FOR ERRFID */
 1127            2 O$SIZE UBIN, /* Size of $O (for fep modes) in words */
 1128            2 XCONING BIT(1) ALIGNED,
 1129              /* SET IF ENTERED BECAUSE OF USER XCON */
 1130            2 REPORTING_ONCALL BIT(1) ALIGNED,
 1131              /* USED BY POSIT TO DETERMINE IF :line OR :sdef */
 1132            2 SIM_UPDATE BIT(1) ALIGNED,
 1133              /* TELLS POSIT TO PRETEND ITS DOING AN UPDATE */
 1134            2 DO_MESSAGE REMEMBER,
 1135              /* DO_MESSAGE label in DDA$DELTA */
 1136            2 MOD_L6,
 1137              /* Cache for L6 memory fetch */
 1138              3 ADDRESS SBIN,
 1139              3 SEG UBIN,
 1140              3 DESC# UBIN,
 1141              3 NOT_IS BIT(1) ALIGNED,
 1142              3 VALUE,
 1143                4 SIZE UBIN,
 1144                4 OPS(0:15) UBIN,
 1145            2 RUM_FEP BIT(1) ALIGNED,
 1146            2 MONENT,
 1147              3 GOT@ BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            32   
 1148                /* Set if B_PATCHIH_ME found in root node */
 1149              3 NEXT@ UBIN,
 1150                /* Next IS address in patch space for procedure */
 1151              3 RSPACE@ SBIN,
 1152                /* Remaining patch space for procedure */
 1153              3 HEAD@ UBIN,
 1154                /* Offset to B_PATCHIH_ME in user IS */
 1155              3 HIGH@ UBIN,
 1156                /* Offset to upper limit of proc patch space in user IS */
 1157              3 DEFINED@ BIT(1) ALIGNED,
 1158              /* Set if information in S_D about @ is currently defined */
 1159              3 GOT# BIT(1) ALIGNED,
 1160                /* Set if B_PATCHDH_ME found in root node */
 1161              3 NEXT# UBIN,
 1162                /* Next IS address in patch space for data */
 1163              3 RSPACE# SBIN,
 1164                /* Remaining patch space for data */
 1165              3 HEAD# UBIN,
 1166                /* Offset to B_PATCHDH_ME in user IS */
 1167              3 HIGH# UBIN,
 1168                /* Offset to upper limit of proc patch space in user IS */
 1169              3 DEFINED# BIT(1) ALIGNED,
 1170              /* Set if information in S_D about # is currently defined */
 1171            2 MONIS,
 1172              3 GOT@ BIT(1) ALIGNED,
 1173                /* Set if B_PATCHIH_IS found in root node */
 1174              3 NEXT@ UBIN,
 1175                /* Next IS address in patch space for procedure */
 1176              3 RSPACE@ SBIN,
 1177                /* Remaining patch space for procedure */
 1178              3 HEAD@ UBIN,
 1179                /* Offset to B_PATCHIH_IS in user IS */
 1180              3 HIGH@ UBIN,
 1181                /* Offset to upper limit of proc patch space in user IS */
 1182              3 DEFINED@ BIT(1) ALIGNED,
 1183              /* Set if information in S_D about @ is currently defined */
 1184              3 GOT# BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            33   
 1185                /* Set if B_PATCHDH_IS found in root node */
 1186              3 NEXT# UBIN,
 1187                /* Next IS address in patch space for data */
 1188              3 RSPACE# SBIN,
 1189                /* Remaining patch space for data */
 1190              3 HEAD# UBIN,
 1191                /* Offset to B_PATCHDH_IS in user IS */
 1192              3 HIGH# UBIN,
 1193                /* Offset to upper limit of proc patch space in user IS */
 1194              3 DEFINED# BIT(1) ALIGNED,
 1195              /* Set if information in S_D about # is currently defined */
 1196            2 FD,
 1197              3 GOT@ BIT(1) ALIGNED,
 1198                /* Set if B_PATCHIH_FD found in root node */
 1199              3 NEXT@ UBIN,
 1200                /* Next IS address in patch space for procedure */
 1201              3 RSPACE@ SBIN,
 1202                /* Remaining patch space for procedure */
 1203              3 HEAD@ UBIN,
 1204                /* Offset to B_PATCHIH_FD in user IS */
 1205              3 HIGH@ UBIN,
 1206                /* Offset to upper limit of proc patch space in user IS */
 1207              3 DEFINED@ BIT(1) ALIGNED,
 1208              /* Set if information in S_D about @ is currently defined */
 1209              3 GOT# BIT(1) ALIGNED,
 1210                /* Set if B_PATCHDH_FD found in root node */
 1211              3 NEXT# UBIN,
 1212                /* Next IS address in patch space for data */
 1213              3 RSPACE# SBIN,
 1214                /* Remaining patch space for data */
 1215              3 HEAD# UBIN,
 1216                /* Offset to B_PATCHDH_FD in user IS */
 1217              3 HIGH# UBIN,
 1218                /* Offset to upper limit of proc patch space in user IS */
 1219              3 DEFINED# BIT(1) ALIGNED,
 1220              /* Set if information in S_D about # is currently defined */
 1221            2 BF,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            34   
 1222              3 GOT@ BIT(1) ALIGNED,
 1223                /* Set if B_PATCHIH_BF found in root node */
 1224              3 NEXT@ UBIN,
 1225                /* Next IS address in patch space for procedure */
 1226              3 RSPACE@ SBIN,
 1227                /* Remaining patch space for procedure */
 1228              3 HEAD@ UBIN,
 1229                /* Offset to B_PATCHIH_BF in user IS */
 1230              3 HIGH@ UBIN,
 1231                /* Offset to upper limit of proc patch space in user IS */
 1232              3 DEFINED@ BIT(1) ALIGNED,
 1233              /* Set if information in S_D about @ is currently defined */
 1234              3 GOT# BIT(1) ALIGNED,
 1235                /* Set if B_PATCHDH_BF found in root node */
 1236              3 NEXT# UBIN,
 1237                /* Next IS address in patch space for data */
 1238              3 RSPACE# SBIN,
 1239                /* Remaining patch space for data */
 1240              3 HEAD# UBIN,
 1241                /* Offset to B_PATCHDH_BF in user IS */
 1242              3 HIGH# UBIN,
 1243                /* Offset to upper limit of proc patch space in user IS */
 1244              3 DEFINED# BIT(1) ALIGNED,
 1245              /* Set if information in S_D about # is currently defined */
 1246            2 HW_TYPE UBIN WORD ALIGNED,
 1247               /* SAME AS MON SYMBOL FOR HW FLAGS =0,4=D90,5=D90XA,6=DPS8000 */
 1248            2 HW_FLTIC_OK BIT(1) ALIGNED,
 1249               /* SAME AS MON SYMBOL FOR HW FLAGS */
 1250            2 HW_RES_MEM BIT(1) ALIGNED,
 1251               /* SAME AS MON SYMBOL FOR HW FLAGS */
 1252            2 HW_PTB_UNITS SBIN WORD ALIGNED,
 1253               /* SAME AS MON SYMBOL FOR HW FLAGS */
 1254            2 HW_WSQ0PT BIT(1) ALIGNED,
 1255               /* SAME AS MON SYMBOL FOR HW FLAGS */
 1256            2 TEMP$O UBIN,
 1257              /* Temporary $O for preevaluation of $O in an expression */
 1258            2 TEMP$O_ACTIVE BIT(1) ALIGNED,
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            35   
 1259              /* TEMP$O is valid if set */
 1260
 1261
 1262           %XUH_PARAM(NAME=XUH_PARAM,STCLASS=" ",LVL=2);
 1263              /* X$HELP parameter block */
 1264            2 DUMMY UBIN DALIGNED;
 1265              /* GOOD PLACE TO PUT THE SEMI-COLON */
 1266
 1267      %LSET STR = CONCAT(TEXTCHAR(STCLASS), '        ');
 1268      %IF SUBSTR(STR,0,5) = 'BASED' OR SUBSTR(STR,0,7) = 'AREAREF';
 1269           DCL S_D$ PTR SYMREF READONLY;
 1270      %ELSE;
 1271           DCL S_D$ PTR CONSTANT SYMDEF INIT( ADDR(S_D) );
 1272      %ENDIF;
 1273
 1274      %MEND;
 1275                                              /**/
 1276      /* EQUs for EXEC_DOMAIN - execution domain */
 1277                                              /**/
 1278      %EQU HOST = 1;  /* HOST is execution domain */
 1279      %EQU L6 = 2;  /* L6 is execution domain */
 1280
 1281                                              /**/
 1282      /* EQUs for MODE of operation */
 1283                                              /**/
 1284      %EQU UDELTA = 1;  /* User DELTA */
 1285      %EQU XDELTA = 2;  /* eXecutive DELTA */
 1286      %EQU RUM = 3;  /* Run Unit Modification */
 1287      %EQU INTERPRETER = 4;  /* Interpreter */
 1288      %EQU ANLZ = 5;  /* ANLZ */
 1289      %EQU ANLZ_FILE = 6;  /* ANLZ fid */
 1290
 1291                                              /**/
 1292      /*F* NAME: S_D_PTRS
 1293           PURPOSE:  Pointers to variables in S_D.   */
 1294
 1295      %MACRO S_D_PTRS (STCLASS="SYMREF READONLY");
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            36   
 1296
 1297           %LSET STR = CONCAT(TEXTCHAR(STCLASS), '        ');
 1298           %IF (SUBSTR(STR, 0, 8) = 'CONSTANT');
 1299                %LSET INIT = CHARTEXT( 'INIT' );
 1300                %LSET INIT_END = CHARTEXT( ' ' );
 1301             %ELSE;
 1302                %LSET INIT = CHARTEXT( '/*' );
 1303                %LSET INIT_END = CHARTEXT( '*/' );
 1304             %ENDIF;
 1305
 1306        DCL S_D_SEG$ PTR STCLASS %INIT (ADDR(S_D)) %INIT_END ;
 1307        DCL S_D_ACCESS$ PTR STCLASS %INIT (ADDR(S_D.ACCESS)) %INIT_END ;
 1308        DCL S_D_ASTACKOFF$ PTR STCLASS %INIT (ADDR(S_D.ASTACKOFF)) %INIT_END ;
 1309        DCL S_D_ANLZ$ PTR STCLASS %INIT (ADDR(S_D.ANLZ)) %INIT_END ;
 1310        DCL S_D_BREAK$ PTR STCLASS %INIT (ADDR(S_D.BREAK)) %INIT_END ;
 1311        DCL S_D_DO_SCAN$ PTR STCLASS %INIT (ADDR(S_D.DO_SCAN)) %INIT_END ;
 1312        DCL S_D_ERROR$ PTR STCLASS %INIT (ADDR(S_D.ERROR)) %INIT_END ;
 1313        DCL S_D_FAULTCMD$$ PTR STCLASS %INIT (ADDR(S_D.FAULTCMD$)) %INIT_END ;
 1314        DCL S_D_FAULTINS$$ PTR STCLASS %INIT (ADDR(S_D.FAULTINS$)) %INIT_END ;
 1315        DCL S_D_GOIC$ PTR STCLASS %INIT (ADDR(S_D.GOIC)) %INIT_END ;
 1316        DCL S_D_GO_MODE$ PTR STCLASS %INIT (ADDR(S_D.GO_MODE)) %INIT_END ;
 1317        DCL S_D_IXFIX$ PTR STCLASS %INIT (ADDR(S_D.IXFIX)) %INIT_END ;
 1318        DCL S_D_IPRFLT$ PTR STCLASS %INIT (ADDR(S_D.IPRFLT)) %INIT_END ;
 1319        DCL S_D_REM_ACCESS$ PTR STCLASS %INIT (ADDR(S_D.REM_ACCESS)) %INIT_END ;
 1320        DCL S_D_REM_DO_SCAN$ PTR STCLASS %INIT (ADDR(S_D.REM_DO_SCAN)) %INIT_END ;
 1321        DCL S_D_REM_DISKBOOT$ PTR STCLASS %INIT (ADDR(S_D.REM_DISKBOOT)) %INIT_END ;
 1322        DCL S_D_RETURNN$ PTR STCLASS %INIT (ADDR(S_D.RETURNN)) %INIT_END ;
 1323        DCL S_D_SAD$ PTR STCLASS %INIT (ADDR(S_D.SAD)) %INIT_END ;
 1324        DCL S_D_SAVEIC$ PTR STCLASS %INIT (ADDR(S_D.SAVEIC)) %INIT_END ;
 1325        DCL S_D_TCB$$ PTR STCLASS %INIT (ADDR(S_D.TCB$)) %INIT_END ;
 1326        DCL S_D_UREG$$ PTR STCLASS %INIT (ADDR(S_D.UREG$)) %INIT_END ;
 1327        DCL S_D_USS$$ PTR STCLASS %INIT (ADDR(S_D.USS$)) %INIT_END ;
 1328        DCL S_D_HOST_MESSAGE$ PTR STCLASS %INIT (ADDR(S_D.HOST_MESSAGE_BUF.C)) %INIT_END ;
 1329        DCL S_D_L6_MESSAGE$ PTR STCLASS %INIT (ADDR(S_D.L6_MESSAGE_BUF)) %INIT_END ;
 1330        DCL S_D_HW_RES_MEM$ PTR STCLASS %INIT(ADDR(S_D.HW_RES_MEM)) %INIT_END ;
 1331        DCL S_D_HW_WSQ0PT$ PTR STCLASS %INIT(ADDR(S_D.HW_WSQ0PT)) %INIT_END ;
 1332        DCL S_D_HW_PTB_UNITS$ PTR STCLASS %INIT(ADDR(S_D.HW_PTB_UNITS)) %INIT_END ;
14:20 JUL 28 '97 DD_SD_M.:E05SI                                            37   
 1333
 1334      %MEND;
 1335                                              /**/

