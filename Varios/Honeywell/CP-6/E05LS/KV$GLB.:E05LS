

14:53 JUL 28 '97 KV$GLB.:E05SI                                             1    
    1      /*M* KV$GLB VDH Global structures */
    2      /*T***********************************************************/
    3      /*T*                                                         */
    4      /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
    5      /*T*                                                         */
    6      /*T***********************************************************/
    7
    8      /*F* NAME:  Session-related Structures
    9
   10      Session-related structures are described in the following subsections.
   11      Structures used by all applications include the following:
   12
   13      .fif
   14      KV$MRD - Master Real Device Context
   15      KV$MVD - Master Virtual Device Context
   16      KV$PTR - VDH Pointer Block
   17      KV$SRD - VDH Subordinate Real Device Context
   18      KV$SSN - VDH Session Context
   19      KV$STR - VDH Stream Context
   20      KV$VDI - VDH Interface Context.
   21      .fin
   22
   23      Structures which may or may not be present include the following:
   24
   25      .fif
   26      KV$BFRDSC - Buffer Descriptor
   27      KV$DVBYTE - Last Read Information
   28      KV$ERD - Shared Profile-dependent Context
   29      KV$ERR - Error Status
   30      KV$FLD - VDH Field Context
   31      KV$FLDLST - VDH Field List Structure
   32      KV$GRPRND - Graphic Rendition
   33      KV$LIN - VDH Line Context
   34      KV$LINLST - VDH Line List Structure
   35      KV$MSGSTT - Message Statistics
   36      KV$OTPMRK - Output Marker
   37      KV$PROMPT - Prompt
14:53 JUL 28 '97 KV$GLB.:E05SI                                             2    
   38      KV$PST - Cursor Position
   39      KV$QLF - Qualification
   40      KV$RCR - VDH Record Structure
   41      KV$RCRLST - VDH Record List Structure
   42      KV$SHRBFR - Shared Buffer
   43      KV$SHRBFR_PRM - VDH Prompt Structure
   44      KV$TITLE - Page Heading Structure
   45      KV$VECTOR - Vector Declaration
   46      KV$VFC - VFC Definition
   47      KV$VFU - VDH VFU Structure
   48      KV$X364 - ANS X364 Virtual Device Context
   49      .fin
   50      */
   51      /*F* NAME: KV$BFRDSC - Buffer Descriptor
   52
   53      KV$BFRDSC is a
   54      substructure describing a buffer descriptor (address, byte index,
   55      data byte count, and buffer byte count). */
   56
   57
   58      %MACRO KV$BFRDSC (NAME = KV$BFRDSC, LVL = 1, LAST = ";", STCLASS = BASED,
   59                        STRTYP = 0, BFRRLSDSP = 0);
   60      %LSET LISTDIR = '0'B;
   61      %LSET LISTEXP = '1'B;
   62      %LSET LISTCOM = '0'B;
   63      %LSET LISTSUB = '1'B;
   64      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
   65      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
   66      %IF STC = 1;
   67      %LSET INIT = CHARTEXT('INIT');
   68      %LSET ENIT = CHARTEXT('');
   69      %ELSE;
   70      %LSET INIT = CHARTEXT('/*');
   71      %LSET ENIT = CHARTEXT('*/');
   72      %ENDIF;
   73      %LSET FEP = BITBIN(MODE_FEP);
   74      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
14:53 JUL 28 '97 KV$GLB.:E05SI                                             3    
   75      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
   76      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
   77      %IF LVL = 1;
   78      DCL 1 NAME STCLASS %KV_DBLBYTALG,
   79      %ELSE;
   80            %(LVL) NAME,
   81      %ENDIF;
   82      /*K* ADR$ - PTR.
   83      Contains the word address. */
   84              %(LVL+1) ADR$ PTR %KV_DBLBYTALG %INIT(ADDR(NIL))%ENIT,
   85
   86      /*K* BYTX - SBIN WORD.
   87      Contains the byte index to the first data byte. */
   88
   89              %(LVL+1) BYTX SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
   90
   91      /*K* DATBYTSIZ - UBIN WORD.
   92      Contains the data byte size. */
   93
   94              %(LVL+1) DATBYTSIZ UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
   95
   96      /*K* BFRBYTSIZ - UBIN WORD.
   97      Contains the buffer byte size. */
   98
   99              %(LVL+1) BFRBYTSIZ UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  100
  101      /*K* STRTYP - UBIN BYTE.
  102      Structure type.  STRTYP specifies the structure type used when
  103      the buffer was allocated.
  104      This field has no meaning if BFRRLSDSP = KV_BFRRLSDSP_NON (none).
  105      For a list of EQUate identifiers for structure types, see
  106      KV$VDH_GETBFR, STRTYP.
  107      */
  108
  109              %(LVL+1) %CHARTEXT('STRTYP') UBIN BYTE CALIGNED %INIT(STRTYP)%ENIT,
  110
  111      /*K* BFRRLSDSP - UBIN BYTE.
14:53 JUL 28 '97 KV$GLB.:E05SI                                             4    
  112      Buffer release disposition.  EQUate identifiers for the BFRRLSDSP
  113      values are listed in the following table.
  114      ..::TB "^\Identifier\#20\Meaning\"
  115      .xeq KV_GLBCNS_E KV_BFRRLSDSP_E KV_BFRRLSDSP_DSC
  116      .xeq KV_GLBCNS_E KV_BFRRLSDSP_E KV_BFRRLSDSP_FRM
  117      .xeq KV_GLBCNS_E KV_BFRRLSDSP_E KV_BFRRLSDSP_MSG
  118      .xeq KV_GLBCNS_E KV_BFRRLSDSP_E KV_BFRRLSDSP_NON
  119      ..::TB
  120      */
  121
  122              %(LVL+1) %CHARTEXT('BFRRLSDSP') UBIN BYTE CALIGNED %INIT(BFRRLSDSP)%ENIT LAST
  123      %MEND;
  124      /*F* NAME: KV$DVBYTE - Last Read Information
  125
  126      KV$DVBYTE is a substructure definition describing DVBYTE. */
  127
  128
  129
  130      %MACRO KV$DVBYTE(NAME = KV$DVBYTE, LVL = 1, LAST = ";", STCLASS = BASED);
  131      %LSET LISTDIR = '0'B;
  132      %LSET LISTEXP = '1'B;
  133      %LSET LISTCOM = '0'B;
  134      %LSET LISTSUB = '1'B;
  135      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  136      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  137      %IF STC = 1;
  138      %LSET INIT = CHARTEXT('INIT');
  139      %LSET ENIT = CHARTEXT('');
  140      %ELSE;
  141      %LSET INIT = CHARTEXT('/*');
  142      %LSET ENIT = CHARTEXT('*/');
  143      %ENDIF;
  144      %LSET FEP = BITBIN(MODE_FEP);
  145      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  146      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  147      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  148      %IF LVL = 1;
14:53 JUL 28 '97 KV$GLB.:E05SI                                             5    
  149      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  150      %ELSE;
  151            %(LVL) NAME,
  152      %ENDIF;
  153      /*K* BP - BIT(1).
  154      Blank preservation.  If set, BP means don't strip trailing blanks. */
  155              %(LVL+1) BP BIT(1) %INIT('0'B)%ENIT,
  156
  157      /*K* REREAD - BIT(1).
  158      Re-read.  If REREAD is set and this is a read,
  159      display the input edit buffer
  160      (saved input image), allow editing of it, and read the edited
  161      version again. */
  162
  163              %(LVL+1) REREAD BIT(1) %INIT('0'B)%ENIT,
  164
  165      /*K* VFC - BIT(1).
  166      If set, indicates that VFC was specified.  VFC is a redefinition
  167      of REREAD. */
  168
  169              %(LVL+1) VFC REDEF REREAD BIT(1),
  170
  171      /*K* BIN - BIT(1).
  172      Binary.  If BIN is set, the data is a string of bits rather than
  173      characters. */
  174
  175              %(LVL+1) BIN BIT(1) %INIT('0'B)%ENIT,
  176
  177      /*K* TRANS - BIT(1).
  178      Transparent.  If set, TRANS means don't do translation. */
  179
  180              %(LVL+1) TRANS BIT(1) %INIT('0'B)%ENIT,
  181
  182      /*K* RRR - BIT (1).
  183      Return Receipt Requested.  If RRR is set, after the data associated with
  184      this request has been transmitted, acknowledge that fact. */
  185
14:53 JUL 28 '97 KV$GLB.:E05SI                                             6    
  186              %(LVL+1) RRR BIT(1) %INIT('0'B)%ENIT,
  187              %(LVL+1) * BIT(1) %INIT('0'B)%ENIT,
  188
  189      /*K* PAGHDNTYP - BIT(1).
  190      Page heading type.  PAGHDNTYP indicates to select either
  191      the session (0) or the
  192      DCB (1) heading for page headings. */
  193
  194              %(LVL+1) PAGHDNTYP BIT(1) %INIT('0'B)%ENIT,
  195
  196      /*K* CONT - BIT(1).
  197      Continued.  If CONT is set, the logical I/O is to occur
  198      in segments involving multiple logical I/O requests.  CONT is
  199      not used in VDH.   */
  200
  201              %(LVL+1) CONT BIT(1) %INIT('0'B)%ENIT LAST
  202      %MEND;
  203      /*F* NAME: KV$ERR - Error Status
  204
  205      KV$ERR is a substructure describing the error status for a virtual device
  206      operation.  This status is passed back to the other end. */
  207
  208      %MACRO KV$ERR(NAME = KV$ERR, LVL = 1, LAST = ";", STCLASS = BASED);
  209      %LSET LISTDIR = '0'B;
  210      %LSET LISTEXP = '1'B;
  211      %LSET LISTCOM = '0'B;
  212      %LSET LISTSUB = '1'B;
  213      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  214      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  215      %IF STC = 1;
  216      %LSET INIT = CHARTEXT('INIT');
  217      %LSET ENIT = CHARTEXT('');
  218      %ELSE;
  219      %LSET INIT = CHARTEXT('/*');
  220      %LSET ENIT = CHARTEXT('*/');
  221      %ENDIF;
  222      %LSET FEP = BITBIN(MODE_FEP);
14:53 JUL 28 '97 KV$GLB.:E05SI                                             7    
  223      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  224      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  225      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  226      %IF LVL = 1;
  227      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  228      %ELSE;
  229            %(LVL) NAME %KV_DBLBYTALG,
  230      %ENDIF;
  231      /*K* COD - UBIN WORD.  Error code to be reported (from B_ERRORS_C) */
  232
  233              %(LVL+1) COD UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  234
  235      /*K* VDOTYP - UBIN BYTE.
  236      Virtual Device Operator type.  Types are of the form
  237      KV_VDO_FNC_... in the KV$VDO include file.  */
  238
  239              %(LVL+1) VDOTYP UBIN BYTE CALIGNED %INIT(0)%ENIT,
  240
  241
  242      /*K* KEYTYP - UBIN BYTE.
  243      */
  244              %(LVL+1) KEYTYP UBIN BYTE CALIGNED %INIT(0)%ENIT LAST
  245      %MEND;
  246      /*F* NAME: KV$GRPRND - Graphic Rendition
  247
  248      KV$GRPRND is a substructure describing the graphic rendition items. */
  249
  250
  251
  252      %MACRO KV$GRPRND(NAME = KV$GRPRND, LVL = 1, LAST = ";", STCLASS = BASED);
  253      %LSET LISTDIR = '0'B;
  254      %LSET LISTEXP = '1'B;
  255      %LSET LISTCOM = '0'B;
  256      %LSET LISTSUB = '1'B;
  257      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  258      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  259      %IF STC = 1;
14:53 JUL 28 '97 KV$GLB.:E05SI                                             8    
  260      %LSET ENIT = CHARTEXT('');
  261      %LSET INIT = CHARTEXT('INIT');
  262      %ELSE;
  263      %LSET INIT = CHARTEXT('/*');
  264      %LSET ENIT = CHARTEXT('*/');
  265      %ENDIF;
  266      %LSET FEP = BITBIN(MODE_FEP);
  267      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  268      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  269      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  270      %IF LVL = 1;
  271      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  272      %ELSE;
  273            %(LVL) NAME,
  274      %ENDIF;
  275      /*N* ABS - BIT(1).
  276      Abstracted graphic rendition.  The graphic rendition passed
  277      is in GRPRND.ID (and is a number) rather than the bits that
  278      are subordinate to GRPRND. */
  279              %(LVL+1) ABS BIT(1) %INIT('0'B)%ENIT,
  280
  281      /*K* HDN - BIT(1).
  282      If set, means hidden.         */
  283
  284              %(LVL+1) HDN BIT(1) %INIT('0'B)%ENIT,
  285
  286      /*K* INCINT - BIT(1).
  287      If set, means increased intensity. */
  288
  289              %(LVL+1) INCINT BIT(1) %INIT('0'B)%ENIT,
  290
  291      /*K* DCRINT - BIT(1).
  292      If set, means decreased intensity. */
  293
  294              %(LVL+1) DCRINT BIT(1) %INIT('0'B)%ENIT,
  295
  296      /*K* UNDSCR - BIT(1).
14:53 JUL 28 '97 KV$GLB.:E05SI                                             9    
  297      If set, means underscore. */
  298
  299              %(LVL+1) UNDSCR BIT(1) %INIT('0'B)%ENIT,
  300
  301      /*K* SLWBLN - BIT(1).
  302      If set, means slow blink. */
  303
  304              %(LVL+1) SLWBLN BIT(1) %INIT('0'B)%ENIT,
  305
  306      /*K* FSTBLN - BIT(1).
  307      If set, means fast blink. */
  308
  309              %(LVL+1) FSTBLN BIT(1) %INIT('0'B)%ENIT,
  310
  311      /*K* RVRVID - BIT(1).
  312      If set, means reverse video. */
  313
  314              %(LVL+1) RVRVID BIT(1) %INIT('0'B)%ENIT LAST
  315      %MEND;
  316      /*F* NAME: KV$OTPMRK - Output Marker
  317
  318      KV$OTPMRK is a substructure describing the OTPMRK parameters. */
  319
  320
  321      %MACRO KV$OTPMRK(NAME = KV$OTPMRK, LVL = 1, LAST = ";", STCLASS = BASED,
  322      MSTRTR(YES = '1'B, NO = '0'B, ANY) = '0'B,
  323      TYP = 0);
  324      %LSET LISTDIR = '0'B;
  325      %LSET LISTEXP = '1'B;
  326      %LSET LISTCOM = '0'B;
  327      %LSET LISTSUB = '1'B;
  328      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  329      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  330      %IF STC = 1;
  331      %LSET INIT = CHARTEXT('INIT');
  332      %LSET ENIT = CHARTEXT('');
  333      %ELSE;
14:53 JUL 28 '97 KV$GLB.:E05SI                                             10   
  334      %LSET INIT = CHARTEXT('/*');
  335      %LSET ENIT = CHARTEXT('*/');
  336      %ENDIF;
  337      %LSET FEP = BITBIN(MODE_FEP);
  338      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  339      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  340      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  341      %IF LVL = 1;
  342      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  343      %ELSE;
  344            %(LVL) NAME,
  345      %ENDIF;
  346      /*K* MSTRTR - BIT(1).
  347      Must return.  If MSTRTR is set,
  348      the marker must be returned (via KV$VDH_OTPMRK).  If MSTRTR is not
  349      set, it is not mandatory that a corresponding KV$VDH_OTPMRK
  350      be generated; the KV$VDH_OTPMRK may be generated only for
  351      the last KV$USR_OTPMRK in a device handler's output block,
  352      for instance. */
  353              %(LVL+1) %CHARTEXT('MSTRTR') BIT(1) %INIT(MSTRTR)%ENIT,
  354
  355      /*K* SSNID - UBIN(7).
  356      Specifies the ID to distinguish multiple sessions through the
  357      same output stream. */
  358
  359              %(LVL+1) SSNID UBIN(7) UNAL %INIT(0)%ENIT,
  360
  361      /*K* TYP - UBIN BYTE.
  362      Type.   TYP indicates what VDH should do with the KV$VDH_OTPMRK,
  363      e.g., send OTPTKN, OTPCMP, save the ID, etc.  EQUate identifiers for
  364      the TYP values are listed in the following table.
  365      ..::TB "^\Identifier\#20\Meaning\"
  366      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_ACK
  367      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_LOW
  368      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_MRK
  369      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_REDTIMOUT
  370      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_SAVLSTRCRID
14:53 JUL 28 '97 KV$GLB.:E05SI                                             11   
  371      .xeq KV_GLBCNS_E KV_MRKTYP_E KV_MRKTYP_SNDLSTRCRID
  372      ..::TB
  373      */
  374
  375              %(LVL+1) %CHARTEXT('TYP') UBIN BYTE CALIGNED %INIT(TYP)%ENIT,
  376
  377      /*K* ID - BIT(32).
  378      Identifies which marker in the data stream this is. */
  379
  380              %(LVL+1) ID BIT(%(36-4*FEP))  %INIT('0'B)%ENIT %KV_DBLBYTALG,
  381      /*K* ID_WRD - UBIN WORD ARRAY.
  382      Is a redefinition of ID. */
  383              %(LVL+1) ID_WRD(0:1) REDEF ID UBIN(%(18-2*FEP)) %KV_DBLBYTALG,
  384      /*K* ID_BYT - UBIN BYTE ARRAY.
  385      Is a redefinition of ID. */
  386              %(LVL+1) ID_BYT(0:3) REDEF ID UBIN BYTE CALIGNED LAST
  387      %MEND;
  388      /*F* NAME: KV$PROMPT - Prompt
  389
  390      KV$PROMPT is a substructure describing the PROMPT parameters. */
  391
  392      %MACRO KV$PROMPT(NAME = KV$PROMPT, LVL = 1, LAST = ";", STCLASS = BASED);
  393      %LSET LISTDIR = '0'B;
  394      %LSET LISTEXP = '1'B;
  395      %LSET LISTCOM = '0'B;
  396      %LSET LISTSUB = '1'B;
  397      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  398      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  399      %IF STC = 1;
  400      %LSET INIT = CHARTEXT('INIT');
  401      %LSET ENIT = CHARTEXT('');
  402      %ELSE;
  403      %LSET INIT = CHARTEXT('/*');
  404      %LSET ENIT = CHARTEXT('*/');
  405      %ENDIF;
  406      %LSET FEP = BITBIN(MODE_FEP);
  407      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
14:53 JUL 28 '97 KV$GLB.:E05SI                                             12   
  408      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  409      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  410      %IF LVL = 1;
  411      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  412      %ELSE;
  413            %(LVL) NAME,
  414      %ENDIF;
  415              %(LVL+1) * UBIN(6) UNAL %INIT(0)%ENIT,
  416
  417      /*K* DMN - UBIN(2).
  418      Specifies the domain. */
  419
  420              %(LVL+1) DMN UBIN(2) UNAL %INIT(1)%ENIT,
  421
  422      /*N* DVBYTE.
  423      */
  424
  425              %(LVL+1) DVBYTE,
  426
  427                %(LVL+2) * UBIN(3) UNAL %INIT(0)%ENIT,
  428
  429      /*K* DVBYTE.TRANS - BIT(1).
  430      If set, specifies that the prompt
  431      string is to be sent untranslated to the terminal.*/
  432
  433                %(LVL+2) TRANS BIT(1) %INIT('0'B)%ENIT,
  434
  435
  436                %(LVL+2) * UBIN(4) UNAL %INIT(0)%ENIT,
  437
  438      /*K* VFC - CHAR(1).
  439      Contains the VFC character for the prompt string. */
  440
  441              %(LVL+1) VFC CHAR(1) %INIT(ASCBIT('1E'X))%ENIT,
  442
  443      /*K* TXT.
  444      Is a redefinition of VFC. */
14:53 JUL 28 '97 KV$GLB.:E05SI                                             13   
  445              %(LVL+1) TXT(0:0) REDEF VFC CHAR(1) LAST
  446      %MEND;
  447      /*F* NAME: KV$PST - Cursor Position
  448
  449      KV$PST is a structure describing the (cursor) position items. */
  450
  451
  452      /* Position */
  453
  454      %MACRO KV$PST(NAME = , LVL = 1, LIN = 1, CLM = 1, LAST = ";", STCLASS = BASED);
  455      %LSET LISTDIR = '0'B;
  456      %LSET LISTEXP = '1'B;
  457      %LSET LISTCOM = '0'B;
  458      %LSET LISTSUB = '1'B;
  459      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  460      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  461      %IF STC = 1;
  462      %LSET INIT = CHARTEXT('INIT');
  463      %LSET ENIT = CHARTEXT('');
  464      %ELSE;
  465      %LSET INIT = CHARTEXT('/*');
  466      %LSET ENIT = CHARTEXT('*/');
  467      %ENDIF;
  468      %LSET FEP = BITBIN(MODE_FEP);
  469      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  470      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  471      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  472      %IF (LVL ~= 1) AND MODE_FEP;
  473      %LSET LST = ', ';
  474      %ELSE;
  475      %LSET LST = TEXTCHAR(LAST);
  476      %ENDIF;
  477      %IF LVL = 1;
  478      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  479      %ELSE;
  480            %(LVL) NAME,
  481      %ENDIF;
14:53 JUL 28 '97 KV$GLB.:E05SI                                             14   
  482
  483      /*K* LIN - SBIN WORD.
  484      Contains the line (i.e., where the cursor is positioned). */
  485
  486              %(LVL+1) %CHARTEXT('LIN') SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(LIN)%ENIT,
  487
  488      /*K* CLM - SBIN WORD.
  489      Contains the physical column. */
  490
  491              %(LVL+1) %CHARTEXT('CLM') SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(CLM)%(ENIT)%CHARTEXT(LST)
  492      %IF (LVL ~= 1) AND MODE_FEP;
  493
  494      /*K* KV$PST_PST - SBIN(32).  Is a redefinition of the KV$PST structure
  495      as a single SBIN doubleword to facilitate comparisons.   */
  496
  497            %(LVL) %CHARTEXT(CONCAT(TEXTCHAR(NAME), '_PST ')) REDEF NAME SBIN(%(36-4*FEP)) LAST
  498      %ENDIF;
  499      %MEND;
  500      /*F* NAME: KV$QLF - Qualification
  501
  502      KV$QLF is a substructure describing the qualification items. */
  503
  504      %MACRO KV$QLF(NAME = KV$QLF, LVL = 1, LAST = ";", STCLASS = BASED);
  505      %LSET LISTDIR = '0'B;
  506      %LSET LISTEXP = '1'B;
  507      %LSET LISTCOM = '0'B;
  508      %LSET LISTSUB = '1'B;
  509      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  510      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  511      %IF STC = 1;
  512      %LSET INIT = CHARTEXT('INIT');
  513      %LSET ENIT = CHARTEXT('');
  514      %ELSE;
  515      %LSET INIT = CHARTEXT('/*');
  516      %LSET ENIT = CHARTEXT('*/');
  517      %ENDIF;
  518      %LSET FEP = BITBIN(MODE_FEP);
14:53 JUL 28 '97 KV$GLB.:E05SI                                             15   
  519      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  520      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  521      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  522      %IF LVL = 1;
  523      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  524      %ELSE;
  525            %(LVL) NAME,
  526      %ENDIF;
  527
  528      /*K* ACPALL - BIT(1).
  529      If set, means accept all. */
  530
  531              %(LVL+1) ACPALL BIT(1) %INIT('0'B)%ENIT,
  532
  533      /*K* PRTGRD - BIT(1).
  534      If set, means protect, guard. */
  535
  536              %(LVL+1) PRTGRD BIT(1) %INIT('0'B)%ENIT,
  537
  538      /*K* ACPGRP - BIT(1).
  539      If set, means accept graphics. */
  540
  541              %(LVL+1) ACPGRP BIT(1) %INIT('0'B)%ENIT,
  542
  543      /*K* ACPNMR - BIT(1).
  544      If set, means accept numerics. */
  545
  546              %(LVL+1) ACPNMR BIT(1) %INIT('0'B)%ENIT,
  547
  548      /*K* ACPALP - BIT(1).
  549      If set, means accept alphabetics. */
  550
  551              %(LVL+1) ACPALP BIT(1) %INIT('0'B)%ENIT,
  552
  553      /*K* PRT - BIT(1).
  554      If set, means protect (and don't guard). */
  555
14:53 JUL 28 '97 KV$GLB.:E05SI                                             16   
  556              %(LVL+1) PRT BIT(1) %INIT('0'B)%ENIT,
  557
  558      /*K* MSTENT - BIT(1).
  559      If set, means must enter.  Input must occur into this field. */
  560
  561              %(LVL+1) MSTENT BIT(1) %INIT('0'B)%ENIT,
  562
  563      /*K* CNS - BIT(1).
  564      Constant.  If CNS is set, don't erase this field
  565      unless the erase function
  566      explicitly declares that constant fields are to be erased.
  567      Constant fields are implicitly protected, to a greater extent
  568      than fields that are only 'protected'. */
  569
  570              %(LVL+1) CNS BIT(1) %INIT('0'B)%ENIT LAST
  571      %MEND;
  572      /*F* NAME: KV$SHRBFR__ - Shared Buffer
  573
  574      KV$SHRBFR is the VDH shared buffer structure; it is used for
  575      structures that are shared among users. */
  576
  577
  578      %MACRO KV$SHRBFR (NAME = KV$SHRBFR, LVL = 1, LAST = ";", STCLASS = BASED,
  579                        NAM = '', LNK = NIL, SIZ = 0);
  580      %LSET LISTDIR = '0'B;
  581      %LSET LISTEXP = '1'B;
  582      %LSET LISTCOM = '0'B;
  583      %LSET LISTSUB = '1'B;
  584      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  585      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  586      %LSET S# = 2*STC;
  587      %LSET INIT = CHARTEXT (SUBSTR ('/*INIT', S#, S#+2));
  588      %LSET ENIT = CHARTEXT (SUBSTR ('*/', S#));
  589      %LSET DCN = CONCAT (',', BINCHAR(LVL+1), ' NAM CHAR(8)INIT(', TEXTCHAR(NAM), ')');
  590      %LSET DCN = CHARTEXT (SUBSTR (DCN, 0, MIN (LENGTHC(NAM)*99, LENGTHC(DCN), 99*S#+14)));
  591      %LSET FEP = BITBIN(MODE_FEP);
  592      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
14:53 JUL 28 '97 KV$GLB.:E05SI                                             17   
  593      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  594      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  595      %IF LVL = 1;
  596      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  597      %ELSE;
  598            %(LVL) NAME,
  599      %ENDIF;
  600
  601      /*K* LNK$ - PTR.
  602      Points to the next buffer in the chain of similar ones.            */
  603              %(LVL+1) LNK$ PTR %INIT(ADDR(LNK))%ENIT,
  604
  605      /*K* BYTSIZ - UBIN WORD.
  606      Contains the byte size, including the shared buffer header. */
  607
  608      %LSET S# = CHARTEXT (CONCAT('SIZEC(',TEXTCHAR(NAME),')'));
  609      %IF LVL ~= 1 OR SIZ ~= 0;
  610      %LSET S# = SIZ;
  611      %ENDIF;
  612              %(LVL+1) BYTSIZ UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(%S#)%ENIT,
  613      /*K* NAM - CHAR(8).
  614      Contains the name of this instance of the structure,
  615      e.g., ASC95 for a translate table.                               */
  616      %SET KV_SHRBFR_CNSUSRCNT = 32767;
  617      %LSET UCT = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  618      %LSET UCT = KV_SHRBFR_CNSUSRCNT*BITBIN(UCT = 'CON');
  619
  620      /*K* USRCNT - UBIN WORD.
  621      User count.  USRCNT contains the number of users associated with this
  622      buffer.  If this buffer is in constant storage, the user
  623      count is initialized to %KV_SHRBFR_CNSUSRCNT, and is never changed. */
  624
  625              %(LVL+1) USRCNT UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(%UCT)%ENIT %DCN LAST
  626      %MEND;
  627      %EJECT;

14:53 JUL 28 '97 KV$GLB.:E05SI                                             18   
  628      /*F* NAME: KV$SNDCQ - Parameters for KVM$SNDCQ
  629
  630      KV$SNDCQ is a
  631      structure used when calling KVM$SNDCQ (send via circular queue).
  632      The caller sets up any combination of MSG1_, MSG2_, up to MSG6_ to
  633      frame the message text to be placed in the circular queue, and
  634      calls KVM$SNDCQ.  KVM$SNDCQ simply moves the framed text into
  635      the circular queue, performing NO bounding other than after the end
  636      of the last message segment, where the normal double-word bounding
  637      occurs.
  638      */
  639      %MACRO KV$SNDCQ (NAME = KV$SNDCQ, STCLASS = BASED, LVL = 1, LAST = ";");
  640      %LSET LISTDIR = '0'B;
  641      %LSET LISTEXP = '1'B;
  642      %LSET LISTCOM = '0'B;
  643      %LSET LISTSUB = '1'B;
  644      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  645      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  646      %IF STC = 1;
  647      %LSET INIT = CHARTEXT(' INIT');
  648      %LSET ENIT = CHARTEXT('');
  649      %ELSE;
  650      %LSET INIT = CHARTEXT('/*');
  651      %LSET ENIT = CHARTEXT('*/');
  652      %ENDIF;
  653      %LSET FEP = BITBIN(MODE_FEP);
  654      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  655      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  656      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  657      %IF LVL = 1;
  658      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  659      %ELSE;
  660      %IF TEXTCHAR(NAME) ~= '';
  661      %(LVL) NAME,
  662      %ENDIF;
  663      %ENDIF;
  664      %KV$VECTOR (LVL = 2, NAME = MSG1_, STCLASS = STCLASS, LAST = ",");
14:53 JUL 28 '97 KV$GLB.:E05SI                                             19   
  665      /*K* MSG1_ - KV$VECTOR structure.
  666      Is a VDH vector to the first segment of message text to be placed
  667      in the send circular queue.
  668      */
  669      %KV$VECTOR (LVL = 2, NAME = MSG2_, STCLASS = STCLASS, LAST = ",");
  670      /*K* MSG2_ - KV$VECTOR structure.
  671      Is a VDH vector to the second segment of message text to be placed
  672      in the send circular queue.
  673      */
  674      %KV$VECTOR (LVL = 2, NAME = MSG3_, STCLASS = STCLASS, LAST = ",");
  675      /*K* MSG3_ - KV$VECTOR structure.
  676      Is a VDH vector to the third segment of message text to be placed
  677      in the send circular queue.
  678      */
  679      %KV$VECTOR (LVL = 2, NAME = MSG4_, STCLASS = STCLASS, LAST = ",");
  680      /*K* MSG4_ - KV$VECTOR structure.
  681      Is a VDH vector to the fourth segment of message text to be placed
  682      in the send circular queue.
  683      */
  684      %KV$VECTOR (LVL = 2, NAME = MSG5_, STCLASS = STCLASS, LAST = ",");
  685      /*K* MSG5_ - KV$VECTOR structure.
  686      Is a VDH vector to the fifth segment of message text to be placed
  687      in the send circular queue.
  688      */
  689      %KV$VECTOR (LVL = 2, NAME = MSG6_, STCLASS = STCLASS, LAST = LAST);
  690      /*K* MSG6_ - KV$VECTOR structure.
  691      Is a VDH vector to the sixth segment of message text to be placed
  692      in the send circular queue.
  693      */
  694      %MEND;
  695      %EJECT;

14:53 JUL 28 '97 KV$GLB.:E05SI                                             20   
  696      /*F* NAME: KV$MSGSTT - Message Statistics
  697
  698      KV$MSGSTT is a substructure for KV$STT for message-related statistics;
  699      it is repeated for send and receive data.
  700      */
  701      %MACRO KV$MSGSTT(NAME = KV$MSGSTT, LVL = 1, LAST = ",", STCLASS = BASED);
  702      %LSET LISTDIR = '0'B;
  703      %LSET LISTEXP = '1'B;
  704      %LSET LISTCOM = '0'B;
  705      %LSET LISTSUB = '1'B;
  706      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  707      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  708      %IF STC = 1;
  709      %LSET INIT = CHARTEXT('INIT');
  710      %LSET ENIT = CHARTEXT('');
  711      %ELSE;
  712      %LSET INIT = CHARTEXT('/*');
  713      %LSET ENIT = CHARTEXT('*/');
  714      %ENDIF;
  715      %LSET FEP = BITBIN(MODE_FEP);
  716      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  717      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  718      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  719      %IF LVL = 1;
  720      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  721      %ELSE;
  722            %(LVL) NAME,
  723      %ENDIF;
  724
  725      /*K* VDOCNT - UBIN DOUBLEWORD.
  726      Send/receive VDO count.  This field contains the number of VDOs
  727      sent to/received from the other end. */
  728
  729              %(LVL+1) VDOCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  730
  731      /*K* VDOBYTCNT - UBIN DOUBLEWORD.
  732      Send/receive VDO byte count.  This field contains the number of VDO
14:53 JUL 28 '97 KV$GLB.:E05SI                                             21   
  733      bytes sent to/received from the other end. */
  734
  735              %(LVL+1) VDOBYTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  736
  737      /*K* DATVDOCNT - UBIN DOUBLEWORD.
  738      Send/receive data VDO count.  This field contains the number of data
  739      Virtual Device Operators (VDOs) sent to/received from the
  740      other end. */
  741
  742              %(LVL+1) DATVDOCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  743
  744      /*K* DATVOBYTCNT - UBIN DOUBLEWORD.
  745      Send/receive data VDO byte count.  This field contains the number
  746      of data VDO bytes
  747      sent to/received from the other end (includes VDO overhead bytes). */
  748
  749              %(LVL+1) DATVDOBYTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  750
  751      /*K* DATVDODATBYTCNT - UBIN DOUBLEWORD.
  752      Send/receive data VDO data byte count.  This field contains
  753      the number of data VDO data bytes
  754      sent to/received from the other end. */
  755
  756              %(LVL+1) DATVDODATBYTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  757
  758      /*K* SSNINTDATUNTCNT - UBIN DOUBLEWORD.
  759      Session interface data unit (SIDU) count.  This field contains the number of
  760      session interface data units ("session messages") sent to/received from
  761      the other end.  One SIDU may contain zero, one or more VDOs.
  762      KN_FCN_NOPs are NOT included. */
  763
  764              %(LVL+1) SSNINTDATUNTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  765
  766      /*K* SSNINTDATUNTBYTCNT - UBIN DOUBLEWORD.
  767      Session interface data unit byte count.  This field contains the
  768      number of session interface data unit bytes sent to/received from the
  769      other end.  This includes the session control information (KNH_MESS
14:53 JUL 28 '97 KV$GLB.:E05SI                                             22   
  770      and session-defined FPT_...), including all slack bytes.
  771      One SIDU may contain zero, one, or more VDOs.
  772      KN_FCN_NOPs are NOT included. */
  773
  774              %(LVL+1) SSNINTDATUNTBYTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT LAST
  775      %MEND;
  776      %EJECT;

14:53 JUL 28 '97 KV$GLB.:E05SI                                             23   
  777      /*F* NAME:  Statistics Block Macro
  778
  779      The statistics block macro, KV$STT, is required for every VDH-user.
  780      */
  781      /*F* NAME: KV$STT - Performance Statistics
  782
  783      KV$STT is a structure containing statistical data maintained by VDH
  784      in a buffer owned by the VDH-user. */
  785
  786      /* This structure must be the first thing in the statistics buffer. */
  787      %MACRO KV$STT(NAME = KV$STT, LVL = 1, LAST = ";", STCLASS = BASED, ID = 0,
  788      CHKARYDCL (YES = '1'B, NO = '0'B) = '0'B);
  789      %LSET LISTDIR = '0'B;
  790      %LSET LISTEXP = '1'B;
  791      %LSET LISTCOM = '0'B;
  792      %LSET LISTSUB = '1'B;
  793      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  794      %LSET LVL1 = LVL + 1;
  795      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  796      %IF STC = 1;
  797      %LSET INIT = CHARTEXT('INIT');
  798      %LSET ENIT = CHARTEXT('');
  799      %ELSE;
  800      %LSET INIT = CHARTEXT('/*');
  801      %LSET ENIT = CHARTEXT('*/');
  802      %ENDIF;
  803      %LSET Y#VDO_FNC_HI = 36;
  804      /* The following ERROR statement is invoked by KVM$RCV to make
  805      sure Y#VDO_FNC_HI is large enough for the array declarations. */
  806      %IF CHKARYDCL = '1'B;
  807      %ERROR  (KV_VDO_FNC_HI > Y#VDO_FNC_HI,
  808        'ERROR:  Y#VDO_FNC_HI, defined in KV$STT, is smaller than KV_VDO_FNC_HI');
  809      %ENDIF;
  810      %LSET FEP = BITBIN(MODE_FEP);
  811      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  812      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  813      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
14:53 JUL 28 '97 KV$GLB.:E05SI                                             24   
  814      %IF LVL = 1;
  815      %IF TEXTCHAR(STCLASS) = 'BASED' AND TEXTCHAR(NAME) = 'KV$STT';
  816      %SET KV_STT = CHARTEXT('KV$PTR.VDI$->KV$VDI.USRPRM$->KV$USRPRM.STT$->KV$STT');
  817      %ENDIF;
  818      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  819      %ELSE;
  820            %(LVL) NAME,
  821      %ENDIF;
  822      /* This structure must be the first thing in the statistics buffer. */
  823      %KL_REQSTATS(NAME = REQSTATS, LVL = %LVL1, STCLASS = STCLASS, LAST = ",");
  824
  825      /*K* ID - UBIN DOUBLEWORD.
  826      Identifies to the STATS program which handler these statistics
  827      are for, and whether this is the set of initial values or if
  828      it is the current statistics buffer.  The ID is supplied by the
  829      system. */
  830
  831              %(LVL+1) %CHARTEXT('ID') UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(ID)%ENIT,
  832
  833      /*K* RCV - KV$MSGSTT structure.
  834      Contains the Receive message statistics.
  835      These statistics track the messages
  836      received over the session connection to the other end. */
  837
  838      %KV$MSGSTT (LVL = %LVL1, NAME = RCV, STCLASS = STCLASS, LAST = ",");
  839
  840      /*K* SND - KV$MSGSTT structure.
  841      Contains the Send message statistics.
  842      These statistics track the messages
  843      sent over the session connection to the other end. */
  844
  845      %KV$MSGSTT (LVL = %LVL1, NAME = SND, STCLASS = STCLASS, LAST = ",");
  846
  847      /*K* INPCHRCNT - UBIN DOUBLEWORD.
  848      Input character count.  This field contains the number of
  849      characters received by VDH from
  850      the VDH-user.  This is typically the number of characters typed,
14:53 JUL 28 '97 KV$GLB.:E05SI                                             25   
  851      number of bytes in received blocks, etc. */
  852
  853              %(LVL+1) INPCHRCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  854
  855      /*K* OTPCHRCNT - UBIN DOUBLEWORD.
  856      Output character count.  This field contains the number of
  857      characters passed to the
  858      VDH-user from VDH.  The VDH-user may also update this count
  859      to reflect characters that it buffered directly. */
  860
  861              %(LVL+1) OTPCHRCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  862
  863      /*K* CNCEVTCNT - UBIN DOUBLEWORD.
  864      Connect event count.  This field contains the number of connect
  865      events (KV$VDH_CNC calls to VDH
  866      from the VDH-user) that have occurred.  This is NOT a count
  867      of current users. */
  868
  869              %(LVL+1) CNCEVTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  870
  871      /*K* USRENTCNT - UBIN DOUBLEWORD.
  872      VDH user entry count.  This field contains the number of times
  873      entry to VDH was attempted.
  874      This is the number of times KV$USRENT was executed. */
  875
  876              %(LVL+1) USRENTCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  877
  878      /*K* USRENTDFRCNT - UBIN DOUBLEWORD.
  879      VDH defer count.  This field contains the number of times entry
  880      to VDH was denied
  881      because VDH was already running on behalf of that user.
  882      This is the number of times KV$USRENT took the DFR$ branch. */
  883
  884              %(LVL+1) USRENTDFRCNT UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  885
  886      /*K* SCHEXCTIM - UBIN DOUBLEWORD.
  887      Scheduled execution time.  This field contains the amount of
14:53 JUL 28 '97 KV$GLB.:E05SI                                             26   
  888      CPU time from the time
  889      VDH is called on the scheduled thread until VDH exits back to
  890      the operating system. */
  891
  892              %(LVL+1) SCHEXCTIM UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,
  893              %(LVL+1) * UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,  /* SPARE */
  894              %(LVL+1) * UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,  /* SPARE */
  895              %(LVL+1) * UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,  /* SPARE */
  896              %(LVL+1) * UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0)%ENIT,  /* SPARE */
  897
  898      /*K* RCVVDOFNCCNT - UBIN DOUBLEWORD ARRAY.
  899      Receive VDO function count.  This array is indexed by KV$VDO.FNC,
  900      yielding the count of that KV$VDO function received.  Values are KV_VDO_FNC_...
  901      in KV$VDO.  */
  902
  903              %(LVL+1) RCVVDOFNCCNT(0:%Y#VDO_FNC_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  904
  905      /*K* SNDVDOFNCCNT - UBIN DOUBLEWORD ARRAY.
  906      Send VDO function count.  This array is indexed by KV$VDO.FNC, yielding the
  907      count of that KV$VDO function sent.  Values are KV_VDO_FNC_...
  908      in KV$VDO. */
  909
  910              %(LVL+1) SNDVDOFNCCNT(0:%Y#VDO_FNC_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  911
  912      /*K* BYTUTL - UBIN DOUBLEWORD ARRAY.
  913      Byte utilization.  BYTUTL contains the number of buffer bytes currently
  914      being utilized for various types of buffers.
  915      BYTUTL is indexed by KV_STRTYP_...; see KV$VDH_GETBFR for a list of
  916      EQUate identifiers for structure types.  */
  917
  918              %(LVL+1) BYTUTL(0:%KV_STRTYP_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  919
  920      /*K* BFRGETCNT - UBIN DOUBLEWORD ARRAY.
  921      Buffer get count.  This array contains the number of buffer gets
  922      for various types of buffers.
  923      BFRGETCNT is indexed by KV_STRTYP_...; see KV$VDH_GETBFR for a list of
  924      EQUate identifiers for structure types.  */
14:53 JUL 28 '97 KV$GLB.:E05SI                                             27   
  925
  926              %(LVL+1) BFRGETCNT(0:%KV_STRTYP_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  927
  928      /*K* BFRCNT - UBIN DOUBLEWORD ARRAY.
  929      Buffer count.  This array contains the number of buffers
  930      of various types.
  931      BFRCNT is indexed by KV_STRTYP_...; see KV$VDH_GETBFR for a list of
  932      EQUate identifiers for structure types.  */
  933
  934              %(LVL+1) BFRCNT(0:%KV_STRTYP_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  935
  936      /*K* VDIVDHFNCCNT - UBIN DOUBLEWORD ARRAY.
  937      VDI to VDH function count.  This array is indexed by VDI function code
  938      (KV_VDH_FNC_...), yielding the number of calls across VDI
  939      for that function. */
  940
  941              %(LVL+1) VDIVDHFNCCNT(0:%KV_VDH_FNC_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  942
  943      /*K* VDIUSRFNCCNT - UBIN DOUBLEWORD ARRAY.
  944      VDI to user function count.  This array is indexed by VDI function code
  945      (KV_USR_FNC_...), yielding the number of calls across VDI
  946      to the VDH user for that function. */
  947
  948              %(LVL+1) VDIUSRFNCCNT(0:%KV_USR_FNC_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  949
  950      /*K* VDIVDHEVTCNT - UBIN DOUBLEWORD ARRAY.
  951      VDI to VDH event count.  This array is indexed by VDI event ID
  952      (KV_VDH_EVT_ID_...), yielding the number of calls across VDI
  953      for that event. */
  954
  955              %(LVL+1) VDIVDHEVTCNT(0:%KV_VDH_EVT_ID_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT,
  956
  957      /*K* VDIUSREVTCNT - UBIN DOUBLEWORD ARRAY.
  958      VDI to user event count.  This array is indexed by VDI event ID
  959      (KV_USR_EVT_ID_...), yielding the number of calls across VDI
  960      to the VDH user for that event. */
  961
14:53 JUL 28 '97 KV$GLB.:E05SI                                             28   
  962              %(LVL+1) VDIUSREVTCNT(0:%KV_USR_EVT_ID_HI) UBIN(%(36-4*FEP)) %KV_DBLBYTALG %INIT(0*0)%ENIT LAST
  963      %MEND;
  964      /*F* NAME: KV$VECTOR - Vector Declaration
  965
  966      KV$VECTOR is a substructure describing a vector (address, byte index,
  967      and byte count). */
  968
  969      %MACRO KV$VECTOR(NAME = KV$VECTOR, LVL = 1, LAST = ";", STCLASS = BASED,
  970                       BFR = NIL,
  971                       BYTX = 0,
  972                       BYTSIZ = 0);
  973      %LSET LISTDIR = '0'B;
  974      %LSET LISTEXP = '1'B;
  975      %LSET LISTCOM = '0'B;
  976      %LSET LISTSUB = '1'B;
  977      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
  978      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
  979      %IF STC = 1;
  980      %LSET INIT = CHARTEXT('INIT');
  981      %LSET ENIT = CHARTEXT('');
  982      %ELSE;
  983      %LSET INIT = CHARTEXT('/*');
  984      %LSET ENIT = CHARTEXT('*/');
  985      %ENDIF;
  986      %LSET FEP = BITBIN(MODE_FEP);
  987      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
  988      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
  989      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
  990      %IF LVL = 1;
  991      DCL 1 NAME STCLASS %KV_DBLBYTALG,
  992      %ELSE;
  993            %(LVL) NAME,
  994      %ENDIF;
  995
  996      /*K* ADR$ - PTR.
  997      Points to the address (FEP word address). */
  998
14:53 JUL 28 '97 KV$GLB.:E05SI                                             29   
  999              %(LVL+1) ADR$ PTR %INIT(ADDR(BFR))%ENIT,
 1000
 1001      /*K* BYTX - SBIN WORD.
 1002      Contains the byte index. */
 1003
 1004              %(LVL+1) %CHARTEXT('BYTX') SBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(BYTX)%ENIT,
 1005
 1006      /*K* BYTSIZ - UBIN WORD.
 1007      Contains the byte size. */
 1008
 1009              %(LVL+1) %CHARTEXT('BYTSIZ') UBIN(%(18-2*FEP)) %KV_DBLBYTALG %INIT(BYTSIZ)%ENIT LAST
 1010      %MEND;
 1011      /*F* NAME: KV$VFC - VFC Definition
 1012
 1013      KV$VFC is a substructure describing a VFC byte. */
 1014
 1015      %MACRO KV$VFC(NAME = KV$VFC, LVL = 1, LAST = ";", STCLASS = BASED);
 1016      %LSET LISTDIR = '0'B;
 1017      %LSET LISTEXP = '1'B;
 1018      %LSET LISTCOM = '0'B;
 1019      %LSET LISTSUB = '1'B;
 1020      %LSET STC = SUBSTR(CONCAT(TEXTCHAR(STCLASS), '   '), 0, 3);
 1021      %LSET STC = BITBIN(STC = 'STA' OR STC = 'CON' OR STC = 'EXT');
 1022      %IF STC = 1;
 1023      %LSET INIT = CHARTEXT('INIT');
 1024      %LSET ENIT = CHARTEXT('');
 1025      %ELSE;
 1026      %LSET INIT = CHARTEXT('/*');
 1027      %LSET ENIT = CHARTEXT('*/');
 1028      %ENDIF;
 1029      %LSET FEP = BITBIN(MODE_FEP);
 1030      %LSET KV_DBLBYTALG = CHARTEXT(SUBSTR('HALIGNED', FEP));
 1031      %LSET KV_FILBIT = CONCAT(BINCHAR(LVL+1), ' * BIT(1)', SUBSTR('INIT(''0''B)', 10-10*STC), ', ');
 1032      %LSET KV_FILBIT = CHARTEXT(SUBSTR(KV_FILBIT, FEP*LENGTHC(KV_FILBIT)));
 1033      %IF LVL = 1;
 1034      DCL 1 NAME STCLASS %KV_DBLBYTALG,
 1035      %ELSE;
14:53 JUL 28 '97 KV$GLB.:E05SI                                             30   
 1036            %(LVL) NAME,
 1037      %ENDIF;
 1038              %(LVL+1) * BIT(1) %INIT('0'B)%ENIT,
 1039
 1040      /*K* FNC - UBIN(3).
 1041      Contains the VFC function. */
 1042
 1043              %(LVL+1) FNC UBIN(3) UNAL %INIT(0)%ENIT,
 1044
 1045      /*K* PRM - UBIN(4).
 1046      Contains the VFC parameter. */
 1047
 1048              %(LVL+1) PRM UBIN(4) UNAL %INIT(0)%ENIT LAST
 1049      %MEND;

