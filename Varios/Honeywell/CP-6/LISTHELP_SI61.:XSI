/*M* LISTHELP program to dump HELP files */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X* */
LISTHELP: PROC MAIN;
 
%INCLUDE B_ERRORS_C;
%INCLUDE B$JIT;
%INCLUDE B$ROSEG;
%INCLUDE CP_6;
  %B$ALT;
  %B$TCB;
  %F$DCB;
%INCLUDE CP_6_SUBS;
%INCLUDE FM$FIT;
  %CODE16;
/* CLUDE LISTHELP_C1; */
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%LIST;
%INCLUDE LISTHELP_C1;
%PLIST;
 
%SUB BLK1_NSUBLKS = "BLK1$->P_OUT.NSUBLKS";
%SUB BLK1_SUBLK$  = "BLK1$->P_OUT.SUBLK$";
 
%SUB BLK2_NSUBLKS = "BLK2$->P_OUT.NSUBLKS";
%SUB BLK2_SUBLK$  = "BLK2$->P_OUT.SUBLK$";
%SUB BLK2_CODE    = "BLK2$->P_SYM.CODE";
%SUB BLK2_COUNT   = "BLK2$->P_SYM.COUNT";
%SUB BLK2_TEXT    = "SUBSTR(BLK2$->P_SYM.TEXT,0,BLK2$->P_SYM.COUNT)";
 
%SUB BLK3_NSUBLKS = "BLK3$->P_OUT.NSUBLKS";
%SUB BLK3_SUBLK$  = "BLK3$->P_OUT.SUBLK$";
%SUB BLK3_CODE    = "BLK3$->P_SYM.CODE";
%SUB BLK3_COUNT   = "BLK3$->P_SYM.COUNT";
%SUB BLK3_TEXT    = "SUBSTR(BLK3$->P_SYM.TEXT,0,BLK3$->P_SYM.COUNT)";
 
%SUB BLK4_NSUBLKS = "BLK4$->P_OUT.NSUBLKS";
%SUB BLK4_SUBLK$  = "BLK4$->P_OUT.SUBLK$";
%SUB BLK4_CODE    = "BLK4$->P_SYM.CODE";
%SUB BLK4_COUNT   = "BLK4$->P_SYM.COUNT";
%SUB BLK4_TEXT    = "SUBSTR(BLK4$->P_SYM.TEXT,0,BLK4$->P_SYM.COUNT)";
%EJECT;
/********************\
*                    *
*    PARSER STUFF    *
*                    *
\********************/
 
%P_PCB       (NAME                     = LISTHELP_OPTS,
              R=LISTHELP_NODES );
%PARSE$OUT   (NAME                     = P_OUT,
              STCLASS="BASED");
%PARSE$SYM   (NAME                     = P_SYM,
              STCLASS="BASED");
 
DCL BLK1$                    PTR;
DCL BLK2$                    PTR;
DCL BLK3$                    PTR;
DCL BLK4$                    PTR;
DCL LISTHELP_NODES           UBIN      SYMREF;
DCL X$PARSE                  ENTRY(1)  ALTRET;
%EJECT;
/***************\
*               *
*   M$ME FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = OPEN_ME,
              ASN=DEVICE,
              DCB=M$ME,
              RES='ME  ');
%EJECT;
/***************\
*               *
*   M$LO FPTs   *
*               *
\***************/
%FPT_OPEN    (FPTN                     = OPEN_LO,
              DCB=M$LO,
              REASSIGN=YES);
 
%FPT_DEVICE  (FPTN                     = NEW_TITLE,
              DCB=M$LO,
              HDR=VLP_HDR );
 
%FPT_DEVICE  (FPTN                     = NEW_LO_PAGE,
              DCB=M$LO,
              HDR=VLP_HDR,
              PAGE=YES);
 
%VLP_HDR     (FPTN                     =VLP_HDR,
              HEADERHEIGHT=2,
              LEN=132 );
DCL 1 USR_HDR REDEF VLP_HDR,
      2 *                    UBIN(8)   UNAL,
      2 RESETPAGE#           BIT(1),
      2 *                    UBIN(5)   UNAL,
      2 HEADERHEIGHT#        UBIN(4)   UNAL,
      2 IDENT#               UBIN(9)   UNAL,
      2 COUNT#               UBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 TITLE                CHAR(135);
%EJECT;
/***************\
*               *
*   M$SI FPTs   *
*               *
\***************/
 
%FPT_OPEN    (FPTN                     = MERGE_SI,
              DCB=M$SI,
              NAME=CUR_FILE,
              SETDCB=YES);
 
%FPT_OPEN    (FPTN                     = OPEN_SI,
              ASN=FILE,
              DCB=M$SI);
 
%FPT_READ    (FPTN                     = READ_SI,
              BUF=SI_BUF,
              KEY=KEY,
              KEYR=YES,
              DCB=M$SI);
 
%FPT_READ    (FPTN                     = READ_COPYRIGHT,
              BUF=SI_BUF,
              KEY=COPYRIGHT_KEY,
              KEYS=YES,
              DCB=M$SI);
%EJECT;
/************************\
*                        *
*   MISCELLANEOUS FPTs   *
*                        *
\************************/
%FPT_ERRMSG  (FPTN                     = ERRMSG,
              DCB=NIL,
              BUF=ERR_MESG,
              CODE=ERRCODE,
              OUTDCB1=M$DO);
%VLP_ERRCODE (FPTN                     = ERRCODE );
 
%FPT_CLOSE   (FPTN                     = CLOSEF,
              DISP=SAVE);
%FPT_CORRES  (FPTN                     = LOVSME,
              DCB1=M$LO,
              DCB2=M$ME);
%FPT_WRITE   (FPTN                     = FPT_WRITE);
%FPT_DEVICE  (FPTN                     = SET_DVFC);
%FPT_PFIL    (FPTN                     = SI_AT_BOF,
              BOF=YES,
              DCB=M$SI);
%FPT_PRECORD (FPTN                     = POS_TOPIC,
              DCB=M$SI,
              KEY=KEY,
              KEYS=YES);
%FPT_TIME    (FPTN                     = GET_DATE,
              DATE=TODAYS_DATE,
              DEST=LOCAL );
%FPT_GDS     (FPTN                     = SWELL_TABLE,
              RESULTS=TOPIC_,
              SEGSIZE=1024);
%VLP_VECTOR  (FPTN                     = SUBTOPIC_);
%VLP_VECTOR  (FPTN                     = SYN_);
%VLP_VECTOR  (FPTN                     = TOPIC_);
%VLP_VECTOR  (FPTN                     = SUB_ADDR_ );
%VLP_VECTOR  (FPTN                     = TOPIC_ADDR_ );
%FPT_LINES   (FPTN                     = FPT_LINES,
              DCB=M$LO,
              LINES=LINES);
%VLR_LINES   (FPTN                     = LINES);
 
%FPT_FID     (FPTN                     = FID_SI,
              ACCT=VLP_ACCT,
              ASN=MERGE_SI.V.ASN#,
              NAME=CUR_FILE,
              PASS=VLP_PASS,
              RES=MERGE_SI.V.RES#,
              RESULTS=VLR_FID,
              SN=SI_SN,
              TEXTFID=ME_BUF );
%VLP_ACCT    (FPTN                     = VLP_ACCT );
%VLP_PASS    (FPTN                     = VLP_PASS );
%VLP_SN      (FPTN                     = SI_SN );
%VLR_FID     (FPTN                     = VLR_FID );
%EJECT;
/**/
/* BASED */
/**/
DCL SUB_ADDR$(0:0)           PTR       BASED(SUB_ADDR_.PTR$);
DCL TOPIC_ADDR$(0:0)         PTR       BASED(TOPIC_ADDR_.PTR$);
 
 
/**/
/* DCBs */
/**/
DCL M$DO                     DCB;
DCL M$ME                     DCB;
DCL M$SI                     DCB;
%M$DCB       (DCBN           = M$LO,
              FUN=CREATE,
              ORG=UR );
 
 
/**/
/* PTRs */
/**/
DCL B$JIT$                   PTR       SYMREF;
DCL B$ROS$                   PTR       SYMREF;
DCL B$TCB$                   PTR       SYMREF;
DCL M$LO$                    PTR;
DCL M$SI$                    PTR;
DCL SAV_TOPIC$               PTR;
DCL STARTS(0:79)             PTR;
DCL SUB$                     PTR       STATIC INIT(ADDR(NIL));
DCL SUB_END$                 PTR;
DCL SYN$                     PTR       STATIC INIT(ADDR(NIL));
DCL SYN1$                    PTR;
DCL SYN_END$                 PTR;
DCL TOPIC$                   PTR       STATIC INIT(ADDR(NIL));
DCL TOPIC_END$               PTR;
%EJECT;
/**/
/* CHARacters */
/**/
DCL ACCT                     CHAR(8)   STATIC;
DCL ASTERISKS(0:131)         CHAR(1)   STATIC INIT('*'*0);
DCL   STARS REDEF ASTERISKS  CHAR(132);
DCL ERR_MESG                 CHAR(120) STATIC;
DCL INT7                     CHAR(7)   STATIC;
DCL LO_BUF                   CHAR(132) STATIC;
DCL ME_BUF                   CHAR(132) STATIC;
DCL MUNGED_PATTERN           CHAR(7)   STATIC INIT('HELP:?:');
DCL OLD_VFC#                 CHAR(1)   STATIC;
DCL PREV_TOPIC               CHAR(253) STATIC;
DCL SI_BUF                   CHAR(132) STATIC;
DCL SI_FID_TEXT              CHAR(120) STATIC DALIGNED;
DCL TODAYS_DATE              CHAR(8)   STATIC;
%EJECT;
/**/
/* SBINs */
/**/
DCL COLUMN                   SBIN;
DCL COLUMN_SIZE              SBIN      STATIC INIT(10);
DCL CUR_PGM_LEN              SBIN;
DCL DATE_POS                 SBIN;
DCL GAP                      SBIN;
DCL I                        SBIN;
DCL INDX                     SBIN;
DCL J                        SBIN;
DCL K                        SBIN;
DCL KEYL                     SBIN;
DCL L                        SBIN;
DCL LEN                      SBIN;
DCL LIST_BEG                 SBIN;
DCL LIST_CNT                 SBIN      STATIC INIT(0);
DCL LO_LEN                   SBIN;
DCL LO_WIDTH                 SBIN      STATIC INIT(0);
DCL M$LO#                    SBIN      STATIC INIT(DCBNUM(M$LO));
DCL M$ME#                    SBIN      STATIC INIT(DCBNUM(M$ME));
DCL MAX_LEN                  SBIN;
DCL MAX_ROWS                 SBIN;
DCL MAX_SUB_ADDRS            SBIN      STATIC INIT(0);
DCL MAX_SUBTOPICS            SBIN      STATIC INIT(0);
DCL MAX_SYNS                 SBIN      STATIC INIT(0);
DCL MAX_TOPIC_ADDRS          SBIN      STATIC INIT(0);
DCL MAX_TOPICS               SBIN      STATIC INIT(0);
DCL ME_INDX                  SBIN      STATIC INIT(0);
DCL ME_WIDTH                 SBIN;
DCL MIN_ROWS                 SBIN;
DCL NOLIST_CNT               SBIN      STATIC INIT(0);
DCL NUM                      SBIN;
DCL NUM_BLANKS               SBIN      STATIC INIT(0);
DCL NUM_COLUMNS              SBIN;
DCL NUM_FILES                SBIN      STATIC INIT(0);
DCL NUM_PAGES                SBIN      STATIC INIT(0);
DCL NUM_SUBS                 SBIN;
DCL NUM_SUBTOPICS            SBIN;
DCL NUM_SYNS                 SBIN;
DCL NUM_TOPICS               SBIN;
DCL REC_NUM                  SBIN;
DCL REMAINDR                 SBIN;
DCL ROW                      SBIN;
DCL START                    SBIN;
DCL SUB_NUM                  SBIN;
DCL SUBTOPIC_MARGIN          SBIN      STATIC INIT(3);
DCL SUBTOPIC_POS             SBIN;
DCL SYN_LEN                  SBIN;
DCL SYNONYM                  SBIN;
DCL TABLE_SIZE               SBIN      STATIC INIT(0);
DCL TABLEVAL                 SBIN;
DCL TMP                      SBIN;
DCL TMP2                     SBIN;
DCL TOPIC_LEN                SBIN;
DCL TOPIC_MARGIN             SBIN      STATIC INIT(1);
DCL TOPIC_POS                SBIN;
DCL TOPICS_WITH_SUBTOPICS    SBIN;
DCL WILD_POS                 SBIN;
%EJECT;
/**/
/* STRUCTURES */
/**/
DCL 1 COPYRIGHT_KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(4),
      2 *                    UBIN(9)   UNAL   INIT(1),
      2 *                    UBIN(9)   UNAL   INIT(0),
      2 *                    UBIN(9)   UNAL   INIT(1),
      2 *                    UBIN(9)   UNAL   INIT(0);
DCL 1 CUR_FILE    STATIC,
      2 L                    UBIN(9)   UNAL   INIT(0),
      2 C                    CHAR(31)  UNAL   INIT(' ');
DCL 1 CUR_PGM  STATIC,
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(40)  UNAL;
DCL 1 CUR_TOPIC  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(0),
      2 NAME                 CHAR(31)  UNAL   INIT(' ');
DCL 1 CUR_SUBTOPIC  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(0),
      2 NAME                 CHAR(31)  UNAL   INIT(' ');
DCL 1 CUR_TITLE  STATIC,
      2 LEN                  UBIN(9)   UNAL   INIT(0),
      2 TEXT                 CHAR(132) UNAL   INIT(' ');
DCL 1 KEY  STATIC,
      2 LEN                  UBIN(9)   UNAL,
      2 TEXT                 CHAR(255) UNAL;
DCL UKEY(0:255) REDEF KEY    UBIN(9)   UNAL;
DCL 1 SKIP_BLANKS  STATIC,
      2 *                    CHAR(32)  UNAL   INIT(' '),
      2 BLANK                UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(95)  UNAL   INIT(' ');
DCL 1 SKIP_ZEROS  STATIC,
      2 *                    CHAR(48)  UNAL   INIT(' '),
      2 ZERO                 UBIN(9)   UNAL   INIT(0),
      2 *                    CHAR(79)  UNAL   INIT(' ');
DCL 1 TARGET_FILE STATIC,
      2 L                    UBIN(9)   UNAL   INIT(LENGTHC('HELP:?:')),
      2 C                    CHAR(31)  UNAL   INIT('HELP:?:');
DCL 1 DEFAULT_START  STATIC,
      2 L                    UBIN(9)   UNAL   INIT(LENGTHC('HELP:')),
      2 C                    CHAR(31)  UNAL   INIT('HELP:');
DCL 1 LIST_NAME(0:124),
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL,
      2 WILD_POS             UBIN;
DCL 1 NOLIST_NAME(0:124),
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL,
      2 WILD_POS             UBIN;
DCL 1 START_NAME  STATIC,
      2 L                    UBIN(9)   UNAL   INIT(LENGTHC('HELP:')),
      2 C                    CHAR(31)  UNAL   INIT('HELP:'),
      2 WILD_POS             SBIN;
DCL 1 END_NAME  STATIC,
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL   INIT('HELP:~~~~~~~~~~~~~~~~~~~:'),
      2 WILD_POS             SBIN;
DCL 1 TOPIC  BASED(TOPIC$),
      2 SUB#                 SBIN(18)         UNAL,
      2 NUM_SUBS             UBIN(18)         UNAL,
      2 SYN                  UBIN(9)          UNAL,
      2 MINLEN               UBIN(9)          UNAL,
      2 LEN                  UBIN(9)          UNAL,
      2 TEXT                 CHAR(TOPIC.LEN)  UNAL;
 
DCL 1 SUBTOPIC  BASED(SUB$),
      2 UNUSED               SBIN(36)         UNAL,
      2 NUM                  UBIN(9)          UNAL,
      2 MINLEN               UBIN(9)          UNAL,
      2 LEN                  UBIN(9)          UNAL,
      2 TEXT                 CHAR(SUBTOPIC.LEN) UNAL;
DCL 1 SYN  BASED(SYN$),
      2 UNUSED               SBIN(36)         UNAL,
      2 PRI_LEN              UBIN(9)          UNAL,
      2 MINLEN               UBIN(9)          UNAL,
      2 SEC_LEN              UBIN(9)          UNAL,
      2 SEC                  CHAR(SYN.SEC_LEN)UNAL;
DCL PRI BASED(SYN1$)         CHAR(253)        UNAL;
%EJECT;
/**/
/* UBINs */
/**/
DCL COMP_COUNT               UBIN;      /* For %WILD_COMPARE macro            */
DCL COMPARE_X                UBIN;      /* For %WILD_COMPARE macro            */
DCL COMPARE_XP               UBIN;      /* For %WILD_COMPARE macro            */
DCL SI_FID_LEN               UBIN      STATIC;
DCL WILD_X                   UBIN;      /* For %WILD_COMPARE macro            */
DCL WILD_XC REDEF WILD_X CHAR(4);       /* For %WILD_COMPARE macro            */
DCL WILD_XP                  UBIN;      /* For %WILD_COMPARE macro            */
%EJECT;
/**/
/* BITs */
/**/
DCL DONE                     BIT(1)    STATIC INIT(%NO#);
DCL HERMAN_FILE              BIT(1)    STATIC INIT(%NO#);
DCL LISTHELP_OPT(0:35)       BIT(1);
DCL LONEME                   BIT(1);
%EJECT;
BEGIN_LISTHELP:
        CALL INITIALIZE ALTRET( BAD_NEWS );
        CALL PROCESS;
        CALL EOJ;
 
BAD_NEWS:
        CALL M$EXIT;
%EJECT;
INITIALIZE: PROC  ALTRET;
 
        M$SI$= DCBADDR(DCBNUM(M$SI));
        M$LO$= DCBADDR(M$LO#);
        ACCT= M$SI$->F$DCB.ACCT#;
 
        CALL M$TIME( GET_DATE ) ALTRET( DISASTER );
        CALL M$OPEN( OPEN_ME ) ALTRET( DISASTER );
        CALL M$OPEN( OPEN_LO ) ALTRET( DISASTER );
        LONEME= %NO#;
        CALL M$CORRES( LOVSME ) ALTRET( GET_BUFS );
        LONEME= %YES#;                  /* M$LO is NOT the same as M$ME       */
 
GET_BUFS:
        SUBTOPIC_= VECTOR( NIL );
        CALL EXPAND( 1,SUBTOPIC_,SUB_END$ ) ALTRET( NOT_ENUFF_MEM );
        SUB$= SUBTOPIC_.PTR$;
 
        SUB_ADDR_= VECTOR( NIL );
        CALL EXPAND( 1,SUB_ADDR_ )       ALTRET( NOT_ENUFF_MEM );
        MAX_SUB_ADDRS= (SUB_ADDR_.W1.VSIZE# + 1) / 4;
 
        SYN_= VECTOR( NIL );
        CALL EXPAND( 1,SYN_,SYN_END$ )   ALTRET( NOT_ENUFF_MEM );
        SYN$= SYN_.PTR$;
 
        TOPIC_= VECTOR( NIL );
        CALL EXPAND( 1,TOPIC_,TOPIC_END$ ) ALTRET( NOT_ENUFF_MEM );
        TOPIC$= TOPIC_.PTR$;
 
        TOPIC_ADDR_= VECTOR( NIL );
        CALL EXPAND( 1,TOPIC_ADDR_ )     ALTRET( NOT_ENUFF_MEM );
        MAX_TOPIC_ADDRS= (TOPIC_ADDR_.W1.VSIZE# + 1) / 4;
 
        CALL PARSE_OPTIONS ALTRET( BYE ); /* ALTRET on X$PARSE error          */
 
        CALL SET_START_NAME;
 
        IF M$LO$->F$DCB.CODE16$ ~= ADDR(NIL) THEN
           NUM_PAGES= M$LO$->F$DCB.CODE16$->CODE16.PAGENO;
 
        ME_WIDTH= DCBADDR(M$ME#)->F$DCB.WIDTH#;
        IF LO_WIDTH = 0 THEN
           IF M$LO$->F$DCB.WIDTH# < 80 THEN
              IF M$LO$->F$DCB.ASN# = %DEVICE# THEN
                 LO_WIDTH= 80;
              ELSE LO_WIDTH= 108;
           ELSE IF M$LO$->F$DCB.WIDTH# = 132 AND
                M$LO$->F$DCB.LINES# = 39 THEN /* LADCs paper for binders?     */
                 LO_WIDTH= 108;
              ELSE LO_WIDTH= M$LO$->F$DCB.WIDTH#;
        ELSE IF LO_WIDTH < 80 THEN
              LO_WIDTH= 80;
        IF LO_WIDTH > 132 THEN
           LO_WIDTH= 132;
        IF LO_WIDTH < 83 THEN DO;       /* If need be                         */
           SUBTOPIC_MARGIN= 0;          /* Keep lines with 79 characters*/
           TOPIC_MARGIN= 0;             /* from wrapping.                     */
           END;
        VLP_HDR.CTL.COUNT#= LO_WIDTH - LENGTHC('999');
        RETURN;
 
DISASTER:
        CALL L$MONERR;
NOT_ENUFF_MEM: ;
BYE:
        ALTRETURN;
 
END INITIALIZE;
%EJECT;
PROCESS: PROC  ALTRET;
 
        DO WHILE( NOT DONE );
           CALL OPEN_NEXT_FILE ALTRET( ALL_DONE );
           CALL CHECK_FILE ALTRET( CLOSE_IT ); /* Filename and ORG ok?        */
           CALL PROCESS_FILE;
CLOSE_IT:
           CALL CLOSE_THIS_FILE( DCBNUM(M$SI) );
           END;
        RETURN;
 
ALL_DONE:
        ALTRETURN;                      /* End of file directory hit          */
 
END PROCESS;
%EJECT;
EOJ:    PROC;
 
        IF NUM_FILES > 0 THEN DO;
           IF ME_INDX > 0 THEN
              CALL WRITE_IT( ' ',1,M$ME# );
           IF NUM_FILES > 1 THEN DO;
              CALL BINCHAR( INT7,NUM_FILES );
              CALL SEARCH( INDX,TABLEVAL,SKIP_ZEROS,INT7 );
              CALL CONCAT( ME_BUF, '.. ',
                SUBSTR(INT7,INDX,LENGTHC(INT7)-INDX),
                ' files listed on ' );
              END;
           ELSE ME_BUF= '.. File listed on ';
           CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
           IF M$LO$->F$DCB.CODE16$ ~= ADDR(NIL) THEN DO;
              NUM_PAGES= M$LO$->F$DCB.CODE16$->CODE16.PAGENO - NUM_PAGES;
              CALL BINCHAR( INT7,NUM_PAGES );
              CALL SEARCH( INDX,TABLEVAL,SKIP_ZEROS,INT7 );
              CALL INSERT( ME_BUF,ME_INDX+2, ,
                SUBSTR(INT7,INDX,LENGTHC(INT7)-INDX),
                ' pages' );
              CALL SEARCHR( ME_INDX,TABLEVAL,SKIP_BLANKS,ME_BUF );
              END;
           ELSE ME_INDX= ME_INDX - LENGTHC(' on');
           IF NOT M$LO$->F$DCB.DDEV.IC# THEN
              CALL WRITE_IT( ME_BUF,ME_INDX+1,M$ME# );
           END;
        ELSE DO;
           ME_BUF= '.. Nothing Listed';
           ME_INDX= LENGTHC('.. Nothing Listed');
           CALL WRITE_IT( ME_BUF,ME_INDX,M$ME# );
           END;
        CALL CLOSE_THIS_FILE( M$LO# );
        CALL CLOSE_THIS_FILE( M$ME# );
 
END EOJ;
%EJECT;
OPEN_NEXT_FILE: PROC  ALTRET;
 
        CALL M$OPEN( OPEN_SI ) ALTRET( NOT_OPENED );
        CUR_FILE= M$SI$->F$DCB.NAME#;
        ERRCODE= '0'B;                  /* No error                           */
        RETURN;
 
NOT_OPENED:
        CUR_FILE= M$SI$->F$DCB.NAME#;
        ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
        ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
        IF ERRCODE.ERR# = %E$FDEOF THEN
           ALTRETURN;
        RETURN;
 
END OPEN_NEXT_FILE;
%EJECT;
CHECK_FILE: PROC  ALTRET;
 
        IF NOT OPEN_SI.V.OPER.NXTF# THEN /* If specific FID was given, we'll*/
           DONE= %YES#;                 /* be done after this file            */
 
        IF OPEN_SI.V.SRCHCOND.REV# THEN
           IF CUR_FILE.C < END_NAME.C THEN
              GOTO ALL_DONE;
           ELSE;
        ELSE
           IF CUR_FILE.C > END_NAME.C THEN
              GOTO ALL_DONE;
 
        IF ERRCODE ~= '0'B THEN DO;     /* Did we get an error on OPEN?       */
           IF ME_INDX > 0 THEN
              CALL WRITE_IT( ' ',1,M$ME# );
           CALL L$MONERR;
           ALTRETURN;
           END;
 
        IF M$SI$->F$DCB.ORG# ~= %KEYED# THEN
           IF NOT OPEN_SI.V.OPER.NXTF# THEN DO; /* Was specific fid specified? */
              CALL CONCAT( ME_BUF,SUBSTR(CUR_FILE.C,0,CUR_FILE.L),
                ' is NOT keyed' );
              LEN= CUR_FILE.L + LENGTHC(' is NOT keyed');
              CALL WRITE_IT( ME_BUF,LEN,M$ME# );
              ALTRETURN;
              END;
           ELSE ALTRETURN;
 
        CALL M$READ( READ_COPYRIGHT ) ALTRET( NO_COPYRIGHT );
READ_IT_ANYWAY:
        DO I=LIST_BEG TO LIST_CNT;
           IF LIST_NAME.C(I) = CUR_FILE.C THEN
              GOTO LOOKS_GOOD;
           END;
 
        DO I=1 TO NOLIST_CNT;
           %WILD_COMPARE ( WILD_CHARS="NOLIST_NAME.C(I)",
           COMPARE_CHARS="CUR_FILE.C",
           NO_MATCH="GOTO NEXT_NOLIST" );
           GOTO NOT_THIS_ONE;
NEXT_NOLIST:
           END;
 
        DO I=LIST_BEG TO LIST_CNT;
           %WILD_COMPARE ( WILD_CHARS="LIST_NAME.C(I)",
           COMPARE_CHARS="CUR_FILE.C",
           NO_MATCH="GOTO NEXT_LIST" );
           GOTO LOOKS_GOOD;
NEXT_LIST:
           END;
        IF LIST_CNT = LIST_BEG AND
          LIST_NAME.WILD_POS(LIST_BEG) ~= LENGTHC('HELP:?')-1 AND
          LIST_NAME.WILD_POS(LIST_BEG) ~= LENGTHC(LIST_NAME.C(0)) AND
          SUBSTR(CUR_FILE.C,0,LIST_NAME.WILD_POS(LIST_BEG)) ~=
          SUBSTR(LIST_NAME.C(LIST_BEG),0,LIST_NAME.WILD_POS(LIST_BEG)) THEN
           GOTO ALL_DONE;
        GOTO NOT_THIS_ONE;
 
LOOKS_GOOD:
        RETURN;                         /* Filename and ORG look OK           */
 
ALL_DONE:
        DONE= %YES#;
NOT_THIS_ONE:
        ALTRETURN;
 
NO_COPYRIGHT:
        IF LISTHELP_OPT(%FORCE##) THEN
           GOTO READ_IT_ANYWAY;
        IF NOT OPEN_SI.V.OPER.NXTF#  OR /* Was a specific fid given?          */
          SUBSTR(CUR_FILE.C,0,LENGTHC('HELP:')) = 'HELP:' THEN DO;
           IF ME_INDX > 0 THEN DO;
              CALL WRITE_IT( ' ',LENGTHC(' '),M$ME# );
              ME_INDX= 0;
              NUM_BLANKS= 0;
              END;
           CALL CONCAT( ME_BUF,SUBSTR(CUR_FILE.C,0,CUR_FILE.L),
             ' has no COPYRIGHT record' );
           LEN= CUR_FILE.L + LENGTHC(' has no COPYRIGHT record');
           CALL WRITE_IT( ME_BUF,LEN,M$ME# );
           END;
        ALTRETURN;
 
END CHECK_FILE;
%EJECT;
PROCESS_FILE: PROC;
 
        CALL FIND_PGM_NAME;
        CALL ANNOUNCE;
        CALL IDENTIFY;
        CALL READ_TOPICS ALTRET( OOPS );
        IF NUM_TOPICS > 0 THEN DO;
           CALL FIND_LENGTHS( TOPIC_.PTR$,NUM_TOPICS );
           CALL BINCHAR( INT7,NUM_TOPICS );
           CALL SEARCH( LEN,TABLEVAL,SKIP_ZEROS,INT7 );
           CALL CONCAT( LO_BUF,SUBSTR(INT7,LEN,LENGTHC(INT7)-LEN),
             ' topics:' );
           CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,LO_BUF );
           CALL WRITE_IT( LO_BUF,LO_LEN+1,M$LO# );
           CALL LIST_TABLE( TOPIC_MARGIN,MAX_LEN,TOPIC_.PTR$,NUM_TOPICS,0,
             TOPIC_ADDR$ );
           IF NUM_SUBTOPICS > 0 THEN DO;
              CALL M$LINES( FPT_LINES );
              IF LINES.RLINES# < 19 THEN
                 CALL M$DEVICE( NEW_LO_PAGE );
              ELSE CALL WRITE_IT( ' ',1,M$LO#,'B' );
              CALL WRITE_IT( 'Topics and their subtopics:',27,M$LO# );
              CALL LIST_SUBTOPICS;
              END;
           END;
        CALL LIST_HELP;
OOPS:
        RETURN;
 
END PROCESS_FILE;
%EJECT;
CLOSE_THIS_FILE: PROC( DCB#,DISP# );
DCL DCB#                     UBIN;
DCL DISP#                    UBIN;
 
        CLOSEF.V.DCB#= DCB#;
        IF ADDR(DISP#) = ADDR(NIL) OR
          DISP# = %SAVE# THEN
           CLOSEF.V.DISP#= %SAVE#;      /* Keep the file                      */
        ELSE CLOSEF.V.DISP#= DISP#;     /* Release the file                   */
        CALL M$CLOSE( CLOSEF ) ALTRET( OH_WELL );
OH_WELL:
        OPEN_SI.V.OPER.THISF#= %NO#;    /* Allow OPEN to get NXT file         */
        RETURN;
 
END CLOSE_THIS_FILE;
%EJECT;
FIND_PGM_NAME: PROC;
 
        CUR_PGM.L= CUR_FILE.L;
        CUR_PGM.C= CUR_FILE.C;
        %WILD_COMPARE ( WILD_CHARS="MUNGED_PATTERN",
        COMPARE_CHARS="CUR_PGM.C",
        NO_MATCH="GOTO FILLIN_ACCT",    /* FID not HELP:?:                    */
        COMP_COUNT="COMP_COUNT" );
        CUR_PGM.L= CUR_PGM.L - LENGTHC('HELP::');
        CUR_PGM.C= SUBSTR(CUR_FILE.C,5,CUR_PGM.L); /* Keep the ? of HELP:?:   */
FILLIN_ACCT:
        CUR_PGM_LEN= CUR_PGM.L;
        IF ACCT ~= ' ' THEN DO;
           CALL INSERT( CUR_PGM.C,CUR_PGM.L,9,'.',ACCT );
           CALL SEARCHR( LEN,TABLEVAL,SKIP_BLANKS,CUR_PGM.C );
           CUR_PGM.L= LEN + 1;
           END;
 
END FIND_PGM_NAME;
%EJECT;
ANNOUNCE: PROC;
 
        CUR_TOPIC.LEN= 0;               /* No topic or                        */
        CUR_SUBTOPIC.LEN= 0;            /*     Subtopic on first page         */
        CALL FORMAT_TITLE;
        SUBSTR(USR_HDR.TITLE,LO_WIDTH-LENGTHC('Page xxxx'))= 'Page';
        VLP_HDR.CTL.RESETPAGE#= %YES#;
        VLP_HDR.CTL.COUNT#= LO_WIDTH-LENGTHC('xxxx')+1;
        USR_HDR.LEN= VLP_HDR.CTL.COUNT#;
        CALL M$DEVICE(NEW_LO_PAGE);
        VLP_HDR.CTL.RESETPAGE#= %NO#;   /* Don't reset Page# except here*/
        CALL WRITE_IT( STARS,LO_WIDTH,M$LO# ); /* A line of asterisks         */
        INDX= 0;
        DO WHILE( INDX + CUR_PGM.L <= LO_WIDTH );
           CALL INSERT( LO_BUF,INDX,CUR_PGM.L+LENGTHC('   '),CUR_PGM.C );
           INDX= INDX + CUR_PGM.L + LENGTHC('   ');
           END;
        CALL WRITE_IT( LO_BUF,INDX-3,M$LO# ); /* The pgm/proc name repeated   */
        CALL WRITE_IT( STARS,LO_WIDTH,M$LO#,'B'); /* Another line of asterisks */
 
END ANNOUNCE;
%EJECT;
IDENTIFY: PROC;
 
        IF OPEN_SI.V.OPER.NXTF# THEN DO;
           IF ME_INDX + CUR_PGM_LEN + NUM_BLANKS >= ME_WIDTH-1 THEN DO;
              CALL WRITE_IT( ' ',1,M$ME# );
              ME_INDX= 0;
              NUM_BLANKS= 0;
              END;
           NUM_COLUMNS= (CUR_PGM_LEN + 1) / COLUMN_SIZE;
           IF NUM_COLUMNS * COLUMN_SIZE ~= CUR_PGM_LEN + 1 THEN
              NUM_COLUMNS= NUM_COLUMNS + 1;
           ME_BUF= ' ';
           CALL INSERT( ME_BUF,NUM_BLANKS,CUR_PGM_LEN,CUR_PGM.C );
           CALL WRITE_IT( ME_BUF,NUM_BLANKS+CUR_PGM_LEN,M$ME#,'@' );
           ME_INDX= ME_INDX + NUM_BLANKS + CUR_PGM_LEN;
           NUM_BLANKS= (NUM_COLUMNS * COLUMN_SIZE) - CUR_PGM_LEN;
           NUM_FILES= NUM_FILES + 1;
           END;
        ELSE NUM_FILES= 1;
        RETURN;
 
END IDENTIFY;
%EJECT;
READ_TOPICS: PROC  ALTRET;
 
        NUM_SYNS= 0;
        NUM_SUBTOPICS= 0;
        NUM_TOPICS= 0;
        TOPIC$= TOPIC_.PTR$;
        SYN$= SYN_.PTR$;
        SUB$= SUBTOPIC_.PTR$;
        REC_NUM= 0;
        PREV_TOPIC= ' ';
        DO WHILE('1'B);
GET_A_TOPIC:
           SI_BUF= ' ';
           CALL M$READ( READ_SI ) ALTRET( EOF_TOPICS );
           SYNONYM= 0;
           KEYL= KEY.LEN;
           IF KEYL > 3 THEN
              IF UKEY(KEYL-3) = 1 THEN
                 GOTO DO_PRECORD;
              ELSE IF UKEY(KEYL-2) < ASCBIN(' ') THEN
                    KEYL= KEYL - LENGTHC('...');
                 ELSE;
           ELSE IF KEYL = 3 THEN
                 IF UKEY(1) < ASCBIN(' ') THEN
                    GOTO DO_PRECORD;
           CALL INDEX1( TOPIC_LEN,' ',SUBSTR(KEY.TEXT,0,KEYL) );
           IF TOPIC_LEN = KEYL THEN DO;
              IF KEYL = KEY.LEN THEN DO;
                 NUM_SYNS= NUM_SYNS + 1;
                 SYNONYM= NUM_SYNS;
                 SYN_LEN= 7 + M$SI$->F$DCB.ARS# + KEYL;
                 IF PINCRC(SYN$,SYN_LEN) > SYN_END$ THEN
                    CALL EXPAND( 1,SYN_,SYN_END$ )  ALTRET( OOPS );
                 SYN.UNUSED= 0;
                 SYN.PRI_LEN= M$SI$->F$DCB.ARS#;
                 SYN.MINLEN= 1;
                 SYN.SEC_LEN= KEYL;
                 SYN.SEC= SUBSTR(KEY.TEXT,0,KEYL);
                 SYN1$= PINCRC(SYN$,SYN_LEN-M$SI$->F$DCB.ARS#);
                 CALL INSERT(PRI,0,M$SI$->F$DCB.ARS#,SI_BUF);
                 SYN$= PINCRC(SYN$,SYN_LEN);
                 END;
              IF TOPIC_LEN > 0 THEN DO;
                 NUM_TOPICS= NUM_TOPICS + 1;
                 IF PINCRC(TOPIC$,7 + TOPIC_LEN) > TOPIC_END$ THEN
                    CALL EXPAND( 1,TOPIC_,TOPIC_END$ )  ALTRET( OOPS );
                 IF NUM_TOPICS >= MAX_TOPIC_ADDRS THEN DO;
                    CALL EXPAND( 1,TOPIC_ADDR_ );
                    MAX_TOPIC_ADDRS= (TOPIC_ADDR_.W1.VSIZE# + 1) / 4;
                    END;
                 TOPIC_ADDR$(NUM_TOPICS)= TOPIC$;
                 TOPIC.SUB#= 0;
                 TOPIC.NUM_SUBS= 0;
                 TOPIC.SYN= SYNONYM;
                 TOPIC.MINLEN= TOPIC_LEN;
                 TOPIC.LEN= TOPIC_LEN;
                 TOPIC.TEXT= SUBSTR(KEY.TEXT,0,TOPIC_LEN);
                 TOPIC$= PINCRC(TOPIC$,7 + TOPIC_LEN);
                 END;
              END;
           ELSE IF TOPIC_LEN > 0 THEN DO;
                 NUM_SUBTOPICS= NUM_SUBTOPICS + 1;
                 SAV_TOPIC$= TOPIC$;
                 TOPIC$= TOPIC_ADDR$(NUM_TOPICS);
                 TOPIC.NUM_SUBS= TOPIC.NUM_SUBS + 1;
                 IF TOPIC.NUM_SUBS = 1 THEN
                    TOPIC.SUB#= NUM_SUBTOPICS;
                 TOPIC$= SAV_TOPIC$;
                 IF PINCRC(SUB$,7 + KEYL - TOPIC_LEN - 1) > SUB_END$ THEN
                    CALL EXPAND( 1,SUBTOPIC_,SUB_END$ )  ALTRET( OOPS );
                 IF NUM_SUBTOPICS >= MAX_SUB_ADDRS THEN DO;
                    CALL EXPAND( 1,SUB_ADDR_ );
                    MAX_SUB_ADDRS= (SUB_ADDR_.W1.VSIZE# + 1) / 4;
                    END;
                 SUB_ADDR$(NUM_SUBTOPICS)= SUB$;
                 SUBTOPIC.UNUSED= 0;
                 CALL CHARBIN( TMP,SUBSTR(SI_BUF,0,5) );
                 SUBTOPIC.NUM= TMP;
                 TMP= KEYL - TOPIC_LEN - 1;
                 SUBTOPIC.MINLEN= TMP;
                 SUBTOPIC.LEN= TMP;
                 SUBTOPIC.TEXT= SUBSTR(KEY.TEXT,TOPIC_LEN+1,TMP);
                 SUB$= PINCRC(SUB$,7 + SUBTOPIC.LEN);
                 END;
DO_PRECORD:
           IF KEY.LEN >= 3 AND
             UKEY(KEY.LEN-2) < ASCBIN(' ') THEN DO;
              SUBSTR(KEY.TEXT,KEY.LEN-2,1)= BINASC(511);
              CALL M$PRECORD( POS_TOPIC ) ALTRET( NEXT_TOPIC );
              END;
NEXT_TOPIC:
           END;
 
EOF_TOPICS:
        RETURN;
 
OOPS:
        ALTRETURN;
 
END READ_TOPICS;
%EJECT;
FIND_LENGTHS: PROC( TABLE$,NUM_ENTRIES );
DCL TABLE$                   PTR;
DCL NUM_ENTRIES              SBIN;
 
DCL TABLE1$                  PTR       STATIC;
DCL TABLE2$                  PTR       STATIC;
 
DCL 1 TABLE1  BASED(TABLE1$),
      2 UNUSED               SBIN(36)         UNAL,
      2 COD                  UBIN(9)          UNAL,
      2 MINLEN               UBIN(9)          UNAL,
      2 LEN                  UBIN(9)          UNAL,
      2 TEXT                 CHAR(TABLE1.LEN) UNAL;
DCL 1 TABLE2  BASED(TABLE2$),
      2 UNUSED               SBIN(36)         UNAL,
      2 COD                  UBIN(9)          UNAL,
      2 MINLEN               UBIN(9)          UNAL,
      2 LEN                  UBIN(9)          UNAL,
      2 TEXT                 CHAR(TABLE2.LEN) UNAL;
%EJECT;
        MAX_LEN= 0;
        TABLE1$= TABLE$;
        DO I=1 TO NUM_ENTRIES - 1;
           TABLE2$= PINCRC(TABLE1$,7 + TABLE1.LEN);
           DO J=0 TO MINIMUM(TABLE1.LEN,TABLE2.LEN) - 1;
              IF SUBSTR(TABLE1.TEXT,J,1) ~= SUBSTR(TABLE2.TEXT,J,1) THEN DO;
                 IF TABLE1.MINLEN < J+1 THEN
                    TABLE1.MINLEN= J+1;
                 TABLE2.MINLEN= J+1;
                 GOTO NEXT_I;
                 END;
              END;
           TABLE1.MINLEN= MINIMUM(TABLE1.LEN,TABLE2.LEN);
           TABLE2.MINLEN= MINIMUM(TABLE1.LEN,TABLE2.LEN)+1;
NEXT_I:
           TABLE1$= TABLE2$;
           END;
 
        TABLE1$= TABLE$;
        TABLE1.MINLEN= 1;
        DO I=1 TO NUM_ENTRIES - 1;
           TABLE2$= PINCRC(TABLE1$,7 + TABLE1.LEN);
           IF SUBSTR(TABLE1.TEXT,0,1) ~= SUBSTR(TABLE2.TEXT,0,1) THEN
              TABLE2.MINLEN= 1;
           IF TABLE1.COD > 0 THEN
              IF MAX_LEN < TABLE1.LEN + LENGTHC('<???>') THEN
                 MAX_LEN= TABLE1.LEN + LENGTHC('<???>');
              ELSE;
           ELSE IF MAX_LEN < TABLE1.LEN THEN
                 MAX_LEN= TABLE1.LEN;
           TABLE1$= TABLE2$;
           END;
        IF NUM_ENTRIES >= 2 THEN
           IF TABLE2.COD > 0 THEN
              IF MAX_LEN < TABLE2.LEN + LENGTHC('<???>') THEN
                 MAX_LEN= TABLE2.LEN + LENGTHC('<???>');
              ELSE;
           ELSE IF MAX_LEN < TABLE2.LEN THEN
                 MAX_LEN= TABLE2.LEN;
              ELSE;
        ELSE IF NUM_ENTRIES = 1 THEN
              MAX_LEN= TABLE1.LEN + LENGTHC('<???>');
        RETURN;
 
END FIND_LENGTHS;
%EJECT;
LIST_TABLE: PROC( MARGIN,MAX_LEN,TABLE$,NUM_ENTRIES,TABLE_TYPE,ADDR$ );
DCL MARGIN                   SBIN;
DCL MAX_LEN                  SBIN;
DCL TABLE$                   PTR;
DCL NUM_ENTRIES              SBIN;
DCL TABLE_TYPE               SBIN;
DCL ADDR$(0:1023)            PTR;
 
DCL TABLE1$                  PTR       STATIC;
DCL 1 TABLE  BASED(TABLE1$),
      2 UNUSED               SBIN(36)  UNAL,
      2 COD                  UBIN(9)   UNAL,
      2 MINLEN               UBIN(9)   UNAL,
      2 LEN                  UBIN(9)   UNAL,
      2 TEXT                 CHAR(TABLE.LEN) UNAL;
 
 
        TABLE1$= TABLE$;
        NUM_COLUMNS= ((LO_WIDTH-MARGIN-MAX_LEN)/(MAX_LEN+3))+1;
        IF NUM_ENTRIES < NUM_COLUMNS THEN
           NUM_COLUMNS= NUM_ENTRIES;
        MIN_ROWS= NUM_ENTRIES / NUM_COLUMNS;
        REMAINDR= NUM_ENTRIES - (MIN_ROWS * NUM_COLUMNS);
        TMP= 1;
        DO I=1 TO REMAINDR;
           STARTS(I)= ADDR$(TMP);
           TMP= TMP + MIN_ROWS + 1;
           END;
        DO I=REMAINDR+1 TO NUM_COLUMNS;
           STARTS(I)= ADDR$(TMP);
           TMP= TMP + MIN_ROWS;
           END;
        MAX_ROWS= MIN_ROWS;
        IF REMAINDR > 0 THEN
           MAX_ROWS= MAX_ROWS + 1;
        DO ROW=1 TO MAX_ROWS;
           LO_BUF= ' ';
           INDX= MARGIN + 1;
           DO COLUMN=1 TO NUM_COLUMNS;
              TABLE1$= STARTS(COLUMN);
              IF TABLE.MINLEN < TABLE.LEN THEN
                 CALL INSERT( LO_BUF,INDX,MAX_LEN+3,
                   SUBSTR(TABLE.TEXT,0,TABLE.MINLEN),
                   '/',
                   SUBSTR(TABLE.TEXT,TABLE.MINLEN,
                   TABLE.LEN-TABLE.MINLEN) );
              ELSE CALL INSERT( LO_BUF,INDX,MAX_LEN+3,TABLE.TEXT );
              IF TABLE.COD > 0 THEN DO;
                 CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,LO_BUF );
                 IF TABLE_TYPE = 0 THEN
                    CALL INSERT( LO_BUF,LO_LEN+1,LENGTHC('<syn>'),'<syn>' );
                 ELSE DO;
                    CALL BINCHAR( INT7,TABLE.COD );
                    IF TABLE.COD <= 9 THEN
                       CALL INSERT( LO_BUF,LO_LEN+1,LENGTHC('<x>'),
                         '<',
                         SUBSTR(INT7,6,1),
                         '>' );
                    ELSE IF TABLE.COD <= 99 THEN
                          CALL INSERT( LO_BUF,LO_LEN+1,LENGTHC('<xx>'),
                            '<',
                            SUBSTR(INT7,5,2),
                            '>' );
                       ELSE CALL INSERT( LO_BUF,LO_LEN+1,LENGTHC('<xxx>'),
                            '<',
                            SUBSTR(INT7,4,3),
                            '>' );
                    END;
                 END;
              INDX= INDX + MAX_LEN + 3;
              STARTS(COLUMN)= PINCRC(STARTS(COLUMN),7 + TABLE.LEN);
              IF ROW >= MAX_ROWS AND
                COLUMN >= REMAINDR AND
                REMAINDR ~= 0 THEN
                 GOTO PUT_A_LINE;
              END;
PUT_A_LINE:
           CALL WRITE_IT( LO_BUF,INDX,M$LO# );
           END;
        RETURN;
 
END LIST_TABLE;
%EJECT;
WRITE_IT: PROC( BUF,LEN,DCB#,VFC# );
DCL BUF                      CHAR(LEN);
DCL LEN                      SBIN;
DCL DCB#                     SBIN;
DCL VFC#                     CHAR(1);   /* Optional parameter                 */
 
        FPT_WRITE.BUF_= VECTOR(BUF );
        FPT_WRITE.V.DCB#= DCB#;
        IF ADDR(VFC#) ~= ADDR(NIL) THEN DO;
           OLD_VFC#= DCBADDR(DCB#)->F$DCB.DVFC#;
           SET_DVFC.V.DCB#= DCB#;
           SET_DVFC.V.DVFC#= VFC#;
           CALL M$DEVICE( SET_DVFC );   /* Change DVFC                        */
           CALL M$WRITE( FPT_WRITE );   /* Write the line with specified VFC  */
           SET_DVFC.V.DVFC#= OLD_VFC#;
           CALL M$DEVICE( SET_DVFC );   /* Change VFC back to DVFC            */
           END;
        ELSE CALL M$WRITE( FPT_WRITE ); /* Write the line with default VFC    */
        RETURN;
 
END WRITE_IT;
%EJECT;
EXPAND: PROC( NUM_PAGES,TABLE_,TABLE_END$ )  ALTRET;
DCL NUM_PAGES                SBIN;
DCL TABLE_END$               PTR;
%VLP_VECTOR  (FPTN                     = TABLE_,
              STCLASS=);
 
        SWELL_TABLE.V.SEGSIZE#= 1024 * NUM_PAGES;
        SWELL_TABLE.RESULTS_= VECTOR(TABLE_);
        CALL M$GDS( SWELL_TABLE ) ALTRET( NO_MEM );
        IF ADDR(TABLE_END$) ~= ADDR(NIL) THEN
           TABLE_END$= PINCRC(TABLE_.PTR$,TABLE_.W1.VSIZE#);
        RETURN;
 
NO_MEM:
        IF ME_INDX > 0 THEN
           CALL WRITE_IT( ' ',LENGTHC(' '),M$ME# );
        ME_BUF= '* Oh no!  Scenility is setting in!  No more memory! *';
        CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,ME_BUF );
        CALL WRITE_IT( ME_BUF,LO_LEN+1,M$ME# );
        ALTRETURN;
 
END EXPAND;
%EJECT;
L$MONERR: PROC( ERR#,DCB# );
DCL ERR#                     BIT(36);   /* Optional                           */
DCL DCB#                     UBIN;      /* Optional                           */
 
        IF ADDR(ERR#) = ADDR(NIL) THEN
           ERRCODE= B$TCB$ -> B$TCB.ALT$ -> B$ALT.ERR;
        ELSE ERRCODE= ERR#;
        IF ADDR(DCB#) = ADDR(NIL) THEN
           ERRMSG.V.DCB#= B$TCB$ -> B$TCB.ALT$ -> B$ALT.DCB#;
        ELSE ERRMSG.V.DCB#= DCB#;
        CALL M$ERRMSG( ERRMSG ) ALTRET( BYE );
BYE:
        RETURN;
 
END L$MONERR;
%EJECT;
LIST_SUBTOPICS: PROC;
 
        SUB_NUM= 0;
        SUB$= SUBTOPIC_.PTR$;
        TOPIC$= TOPIC_.PTR$;
        DO K=1 TO NUM_TOPICS;
           IF TOPIC.SYN > 0 OR
             TOPIC.SUB# <= 0 THEN
              GOTO NEXT_K;
           NUM_SUBS= TOPIC.NUM_SUBS;
           CALL FIND_LENGTHS( SUB$,NUM_SUBS );
           CALL PUT_TOPIC_AND_SYNS;
           CALL LIST_TABLE( SUBTOPIC_MARGIN,MAX_LEN,SUB$,NUM_SUBS,1,
             SUB_ADDR$(SUB_NUM) );
           SUB_NUM= SUB_NUM + NUM_SUBS;
           DO L=1 TO NUM_SUBS;
              SUB$= PINCRC(SUB$,7 + SUBTOPIC.LEN);
              END;
NEXT_K:
           TOPIC$= PINCRC(TOPIC$,7 + TOPIC.LEN);
           END;
        RETURN;
 
END LIST_SUBTOPICS;
%EJECT;
PUT_TOPIC_AND_SYNS: PROC;
 
        LO_BUF= ' ';
        IF TOPIC.MINLEN < TOPIC.LEN THEN
           CALL INSERT( LO_BUF,TOPIC_MARGIN+1, ,
             SUBSTR(TOPIC.TEXT,0,TOPIC.MINLEN),
             '/',
             SUBSTR(TOPIC.TEXT,TOPIC.MINLEN,
             TOPIC.LEN-TOPIC.MINLEN) );
        ELSE CALL INSERT( LO_BUF,TOPIC_MARGIN+1, ,TOPIC.TEXT );
        CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,LO_BUF );
        SYN$= SYN_.PTR$;
        DO L=1 TO NUM_SYNS;
           SYN1$= PINCRC(SYN$,7 + SYN.SEC_LEN);
           CALL SEARCHR( LEN,TABLEVAL,SKIP_BLANKS,TOPIC.TEXT );
           IF LEN+1 = SYN.PRI_LEN AND
             SUBSTR(PRI,0,LEN+1) = SUBSTR(TOPIC.TEXT,0,LEN+1) THEN DO;
              IF SYN.MINLEN < SYN.SEC_LEN THEN
                 CALL INSERT( LO_BUF,LO_LEN+1, ,
                   ' = ',
                   SUBSTR(SYN.SEC,0,SYN.MINLEN),
                   '/',
                   SUBSTR(SYN.SEC,SYN.MINLEN,
                   SYN.SEC_LEN - SYN.MINLEN) );
              ELSE CALL INSERT( LO_BUF,LO_LEN+1, ,
                   ' = ',
                   SYN.SEC );
              CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,LO_BUF );
              END;
           SYN$= PINCRC(SYN$,7 + SYN.SEC_LEN + SYN.PRI_LEN);
           END;
        CALL WRITE_IT( LO_BUF,LO_LEN+1,M$LO# );
        RETURN;
 
END PUT_TOPIC_AND_SYNS;
%EJECT;
LIST_HELP: PROC;
 
        CALL M$PFIL( SI_AT_BOF );
        NUM= 0;
        REC_NUM= 0;
        SUB$= SUBTOPIC_.PTR$;
        TOPIC$= TOPIC_.PTR$;
        DO WHILE('1'B);
           SI_BUF= ' ';
           CALL M$READ( READ_SI ) ALTRET( EOF_TOPIC );
           REC_NUM= REC_NUM + 1;
           IF KEY.LEN < 3      OR
             UKEY(KEY.LEN-2) ~= 0 OR
             (KEY.LEN = 4 AND
             UKEY(1) = 1) THEN
              GOTO NEXT_TOPIC;
           IF UKEY(KEY.LEN) = 0 AND
             UKEY(KEY.LEN-1) = 0 THEN DO; /* New Topic?                       */
              CALL M$LINES( FPT_LINES );
              IF LINES.RLINES# < 5 THEN
                 CALL M$DEVICE( NEW_LO_PAGE );
              ELSE DO;
                 CALL WRITE_IT( ' ',LENGTHC(' '),M$LO# );
                 CALL WRITE_IT( ' ',LENGTHC(' '),M$LO# );
                 END;
              IF KEY.LEN = 3 THEN DO;
                 LO_BUF= '       default topic';
                 PREV_TOPIC= ' ';
                 NUM_SUBS= 0;
                 END;
              ELSE DO;
                 DO I=NUM+1 TO NUM_TOPICS;
                    IF TOPIC.SYN <= 0 THEN DO;
                       NUM= I;
                       I= NUM_TOPICS+1;
                       END;
                    ELSE TOPIC$= PINCRC(TOPIC$,7 + TOPIC.LEN);
                    END;
                 IF TOPIC.MINLEN < TOPIC.LEN THEN
                    CALL CONCAT( LO_BUF,
                      '       ',        /* 'Topic: '                          */
                      SUBSTR(TOPIC.TEXT,0,TOPIC.MINLEN),
                      '/',
                      SUBSTR(TOPIC.TEXT,TOPIC.MINLEN,
                      TOPIC.LEN-TOPIC.MINLEN) );
                 ELSE CALL CONCAT( LO_BUF,
                      '       ',        /* 'Topic: '                          */
                      TOPIC.TEXT );
                 NUM_SUBS= TOPIC.NUM_SUBS;
                 SUB$= SUB_ADDR$(TOPIC.SUB#);
                 TOPIC$= PINCRC(TOPIC$,7 + TOPIC.LEN);
                 END;
              CALL SEARCHR( LO_LEN,TABLEVAL,SKIP_BLANKS,LO_BUF );
              CUR_SUBTOPIC.LEN= 0;
              CUR_TOPIC.LEN= LO_LEN - LENGTHC('Topic: ') + 1;
              CUR_TOPIC.NAME= SUBSTR(LO_BUF,LENGTHC('Topic: '),31);
              CALL FORMAT_TITLE;
              CALL WRITE_IT( LO_BUF,LO_LEN+1,M$LO#,'`' );
              CALL WRITE_IT( LO_BUF,LO_LEN+1,M$LO#,'`' );
              SUBSTR(LO_BUF,0,LENGTHC('Topic: '))= 'Topic: ';
              CALL WRITE_IT( LO_BUF,LO_LEN+1,M$LO# );
              LO_BUF= ' ';
              END;
           IF UKEY(KEY.LEN) = 0 THEN DO; /* New Subtopic?                     */
              CALL PUT_SUBTOPICS;
              LO_BUF= ' ';
              IF SUBSTR(SI_BUF,0,M$SI$->F$DCB.ARS#) = ' ' THEN
                 GOTO NEXT_TOPIC;
              END;
           CALL INSERT( LO_BUF,SUBTOPIC_MARGIN+1, ,
             SUBSTR(SI_BUF,0,M$SI$->F$DCB.ARS#) );
           CALL WRITE_IT( LO_BUF,M$SI$->F$DCB.ARS#+SUBTOPIC_MARGIN+1,M$LO# );
NEXT_TOPIC:
           END;
 
EOF_TOPIC:
        RETURN;
 
END LIST_HELP;
%EJECT;
PUT_SUBTOPICS: PROC;
DCL I                        SBIN;
DCL TMP$                     PTR;
 
        CALL BINCHAR(INT7,UKEY(KEY.LEN-1));
        CALL SEARCH( LEN,TABLEVAL,SKIP_ZEROS,SUBSTR(INT7,0,6) );
        LO_BUF= ' ';
        CALL INSERT( LO_BUF,TOPIC_MARGIN+1, ,
          '-> <',
          SUBSTR(INT7,LEN,LENGTHC(INT7)-LEN),
          '>' );
        CUR_SUBTOPIC.LEN= LENGTHC('<>') + LENGTHC(INT7) - LEN;
        CUR_SUBTOPIC.NAME= SUBSTR(LO_BUF,TOPIC_MARGIN+4,9);
        CALL FORMAT_TITLE;
        LO_LEN= TOPIC_MARGIN + LENGTHC(' -> <>') + LENGTHC(INT7) - LEN;
        IF NUM_SUBS > 0 THEN DO;
           TMP$= SUB$;
           DO I=1 TO NUM_SUBS;
              IF SUBTOPIC.NUM = UKEY(KEY.LEN-1) THEN DO;
                 CALL INSERT( LO_BUF,LO_LEN, ,
                   ' = ',
                   SUBTOPIC.TEXT );
                 LO_LEN= LO_LEN + LENGTHC(' = ') + SUBTOPIC.LEN;
                 IF CUR_SUBTOPIC.LEN < SUBTOPIC.LEN OR
                   SUBSTR(CUR_SUBTOPIC.NAME,0,1) = '<' THEN DO;
                    CUR_SUBTOPIC.LEN= SUBTOPIC.LEN;
                    CUR_SUBTOPIC.NAME= SUBTOPIC.TEXT;
                    END;
                 END;
              IF SUBSTR(CUR_SUBTOPIC.NAME,0,1) ~= '<' THEN
                 CALL FORMAT_TITLE;
              SUB$= PINCRC(SUB$,7 + SUBTOPIC.LEN);
              END;
           SUB$= TMP$;
           END;
        CALL WRITE_IT( LO_BUF,LO_LEN,M$LO# );
        RETURN;
 
END PUT_SUBTOPICS;
%EJECT;
FORMAT_TITLE: PROC;
 
        CALL CONCAT( USR_HDR.TITLE,'Tool=',CUR_PGM.C );
        GAP= (LO_WIDTH-LENGTHC('Tool=Topic=Subtopic=Page xxxmm/dd/yy')) / 4;
        IF CUR_PGM.L < GAP AND
          CUR_TOPIC.LEN < GAP AND
          CUR_SUBTOPIC.LEN < GAP THEN
           IF LO_WIDTH = 80 THEN DO;
              TOPIC_POS= LENGTHC('Tool=') + 11 + LENGTHC(' ');
              DATE_POS= TOPIC_POS + LENGTHC('Topic=') + 17;
              SUBTOPIC_POS= DATE_POS + LENGTHC('mm/dd/yy') + 5;
              END;
           ELSE IF LO_WIDTH = 108 THEN DO;
                 TOPIC_POS= LENGTHC('Tool=') + 18 + LENGTHC(' ');
                 DATE_POS= TOPIC_POS + LENGTHC('Topic=') + 27;
                 SUBTOPIC_POS= DATE_POS + LENGTHC('mm/dd/yy') + 9;
                 END;
              ELSE IF LO_WIDTH = 132 THEN DO;
                    TOPIC_POS= LENGTHC('Tool=') + 24 + LENGTHC(' ');
                    DATE_POS= TOPIC_POS + LENGTHC('Topic=') + 36;
                    SUBTOPIC_POS= DATE_POS + LENGTHC('mm/dd/yy') + 12;
                    END;
                 ELSE CALL BUILD_TITLE;
        ELSE CALL BUILD_TITLE;
 
        IF CUR_TOPIC.LEN > 0 THEN
           CALL INSERT( USR_HDR.TITLE,TOPIC_POS,,'Topic=',CUR_TOPIC.NAME );
        SUBSTR(USR_HDR.TITLE,DATE_POS,8)= TODAYS_DATE;
        IF CUR_SUBTOPIC.LEN > 0 THEN
           CALL INSERT( USR_HDR.TITLE,SUBTOPIC_POS,,
             'Subtopic=',CUR_SUBTOPIC.NAME );
        SUBSTR(USR_HDR.TITLE,LO_WIDTH-LENGTHC('Page xxxx'))= 'Page';
        CALL M$DEVICE(NEW_TITLE);
        RETURN;
 
END FORMAT_TITLE;
%EJECT;
BUILD_TITLE: PROC;
 
        TMP= LENGTHC('Tool=') + CUR_PGM.L +
          LENGTHC('Topic=') + CUR_TOPIC.LEN + LENGTHC('mm/dd/yy') +
          LENGTHC('Subtopic=') + CUR_SUBTOPIC.LEN + LENGTHC('Page xxxx');
        IF (LO_WIDTH - TMP) / 4 < 1 THEN
           TMP= TMP - LENGTHC('Subtopic=') - CUR_SUBTOPIC.LEN;
        IF (LO_WIDTH - TMP) / 4 < 1 THEN
           TMP= TMP - LENGTHC('Topic=') - CUR_TOPIC.LEN;
        GAP= (LO_WIDTH - TMP) / 4;
        TOPIC_POS= LENGTHC('Tool=') + CUR_PGM.L + GAP + LENGTHC(' ');
        DATE_POS= TOPIC_POS + LENGTHC('Topic=') + CUR_TOPIC.LEN + GAP;
        SUBTOPIC_POS= DATE_POS + LENGTHC('mm/dd/yy') + GAP;
        RETURN;
 
END BUILD_TITLE;
%EJECT;
PARSE_OPTIONS: PROC  ALTRET;
 
        LISTHELP_OPTS.WKSZ= (SYN_.W1.VSIZE#+1)/4; /* Use the SYN Data Segment */
        LISTHELP_OPTS.WORK$= SYN_.PTR$; /* for X$PARSE workarea               */
        LISTHELP_OPTS.NCHARS= B$JIT.CCARS;
        LISTHELP_OPTS.TEXT$= ADDR(B$JIT.CCBUF);
        CALL X$PARSE( LISTHELP_OPTS ) ALTRET( PARSE_ERR );
        LISTHELP_OPT= '0'B;
        BLK1$= LISTHELP_OPTS.OUT$;
        DO J=0 TO BLK1_NSUBLKS-1;
           BLK2$= BLK1_SUBLK$(J);
           DO CASE( BLK2_CODE );
            CASE( %PRC_FID##,
             %UPD_FID##,
             %OBJ_FID##,
             %LST_FID## );
            CASE( %SRC_FID## );
              FID_SI.TEXTFID_= VECTOR(BLK2_TEXT);
              CALL M$FID( FID_SI ) ALTRET( OOPS );
              IF NOT VLR_FID.ACCT THEN DO;
                 VLP_ACCT.ACCT#= ':SYS    ';
                 MERGE_SI.ACCT_= VECTOR(VLP_ACCT);
                 END;
 
            CASE( %OPTIONS## );
 
NEXT_OPTION:
              DO I=0 TO BLK2_NSUBLKS-1;
                 BLK3$= BLK2_SUBLK$(I);
                 LISTHELP_OPT(BLK3_CODE)= %YES#;
                 DO CASE( BLK3_CODE );
                  CASE( %END## );       /* E/nd = name                        */
                    BLK4$= BLK3_SUBLK$(0);
                    END_NAME.L= BLK4_COUNT;
                    END_NAME.C= BLK4_TEXT;
                    CALL FORMAT_NAME( END_NAME );
 
                  CASE( %FORCE## );
 
                  CASE( %LIST## );      /* L/ist = (name,[...] )              */
                    DO K=0 TO BLK3_NSUBLKS-1;
                       BLK4$= BLK3_SUBLK$(K);
                       LIST_CNT= LIST_CNT + 1;
                       LIST_NAME.L(LIST_CNT)= BLK4_COUNT;
                       LIST_NAME.C(LIST_CNT)= BLK4_TEXT;
                       CALL FORMAT_NAME(LIST_NAME(LIST_CNT));
                       END;
 
                  CASE( %NOLIST## );    /* N/olist = (name[,...] )            */
                    DO K=0 TO BLK3_NSUBLKS-1;
                       BLK4$= BLK3_SUBLK$(K);
                       NOLIST_CNT= NOLIST_CNT + 1;
                       NOLIST_NAME.L(NOLIST_CNT)= BLK4_COUNT;
                       NOLIST_NAME.C(NOLIST_CNT)= BLK4_TEXT;
                       CALL FORMAT_NAME(NOLIST_NAME(NOLIST_CNT));
                       END;
 
                  CASE( %START## );     /* S/tart = name                      */
                    BLK4$= BLK3_SUBLK$(0);
                    START_NAME.L= BLK4_COUNT;
                    START_NAME.C= BLK4_TEXT;
                    CALL FORMAT_NAME( START_NAME );
 
                  CASE( %WIDTH## );     /* W/idth = n                         */
                    BLK4$= BLK3_SUBLK$(0);
                    LO_WIDTH= BLK4_COUNT;
                    CALL CHARBIN( LO_WIDTH,SUBSTR(BLK4_TEXT,0,LO_WIDTH) );
                    IF LO_WIDTH < 80 THEN
                       LO_WIDTH= 80;
                    ELSE
                       IF LO_WIDTH > 132 THEN
                          LO_WIDTH= 132;
                  END;                  /* end DO CASE                        */
 
                 END NEXT_OPTION;       /* end DO                             */
            END;
           END;
 
        IF (LISTHELP_OPT(%START##) OR
          LISTHELP_OPT(%END##)) AND
          START_NAME.C > END_NAME.C THEN
           OPEN_SI.V.SRCHCOND.REV#= %YES#;
 
        IF NOT M$SI$->F$DCB.AMR# THEN DO;
           VLP_ACCT.ACCT#= ':SYS    ';
           MERGE_SI.ACCT_= VECTOR(VLP_ACCT);
           END;
 
        RETURN;
 
PARSE_ERR:
        ME_BUF= ' ';
        SUBSTR(ME_BUF,LISTHELP_OPTS.HI_CHAR+LENGTHC('!'),1)= '^';
        CALL WRITE_IT( ME_BUF,LISTHELP_OPTS.HI_CHAR+2,M$ME# );
        ME_BUF= 'Invalid LISTHELP option specified; Parsing stopped here';
        CALL WRITE_IT( ME_BUF,55,M$ME# );
        ALTRETURN;
 
OOPS:
        CALL L$MONERR;
        ALTRETURN;
 
END PARSE_OPTIONS;
%EJECT;
SET_START_NAME: PROC;
 
        OPEN_SI.V.OPER.NXTF#= %YES#;    /* Assume more than one file          */
        OPEN_SI.V.OPER.THISF#= %YES#; /* We'll always start at HELP: at least*/
        IF (NOT LISTHELP_OPT(%START##)) AND /* If neither START nor END were  */
          (NOT LISTHELP_OPT(%END##)) THEN /* specified                        */
           IF M$SI$->F$DCB.NAME#.L > 0 THEN DO;/* Did M$SI have a name in it? */
              LIST_NAME(0)= M$SI$->F$DCB.NAME#;
              CALL FORMAT_NAME(LIST_NAME(0));
              IF LISTHELP_OPT(%LIST##) THEN /* Was LIST option specified?     */
                 CUR_FILE= DEFAULT_START;/*Search all HELP:?: files for spec names*/
              ELSE DO;
                 IF LIST_NAME.WILD_POS(0) < LENGTHC(LIST_NAME.C(0)) THEN DO;
                    CUR_FILE.L= LIST_NAME.WILD_POS(0);
                    CUR_FILE.C= SUBSTR( LIST_NAME.C(0),0,CUR_FILE.L );
                    END;
                 ELSE DO;               /* Just one file                      */
                    CUR_FILE= LIST_NAME(0);
                    OPEN_SI.V.OPER.NXTF#= %NO#;
                    END;
                 END;
              END;
           ELSE
              IF LISTHELP_OPT(%LIST##) THEN /* Was LIST option specified?     */
                 IF LIST_CNT = 1 THEN   /* Yep! Was only one file spec?       */
                    IF LIST_NAME.WILD_POS(1) < LENGTHC(LIST_NAME.C(1)) THEN DO;
                       CUR_FILE.L= LIST_NAME.WILD_POS(1); /* Name was wildcarded */
                       CUR_FILE.C= SUBSTR(LIST_NAME.C(1),0,CUR_FILE.L);
                       END;
                    ELSE DO;            /* Just one non-wildcarded spec       */
                       CUR_FILE= LIST_NAME(1);
                       OPEN_SI.V.OPER.NXTF#= %NO#;
                       END;
                 ELSE
                    CUR_FILE= DEFAULT_START; /* More than one file LISTed     */
              ELSE DO;
                 CUR_FILE= DEFAULT_START; /* No LIST option; use HELP:?:      */
                 LIST_NAME.L(0)= LENGTHC('HELP:?:');
                 LIST_NAME.C(0)= 'HELP:?:';
                 CALL FORMAT_NAME(LIST_NAME(0));
                 END;
        ELSE DO;                        /* START option specified; use it     */
           CUR_FILE= START_NAME;
           IF M$SI$->F$DCB.NAME#.L > 0 THEN DO;
              LIST_NAME(0)= M$SI$->F$DCB.NAME#;
              CALL FORMAT_NAME(LIST_NAME(0));
              END;
           ELSE
              IF LISTHELP_OPT(%LIST##) THEN
                 LIST_NAME.C(0)= ' ';
              ELSE DO;
                 LIST_NAME.L(0)= LENGTHC('HELP:?:');
                 LIST_NAME.C(0)= 'HELP:?:';
                 CALL INDEX1( LIST_NAME.WILD_POS(0),'?',LIST_NAME.C(0) );
                 END;
           END;
 
        IF LISTHELP_OPT(%LIST##) THEN
           LIST_BEG= 1;
        ELSE
           LIST_BEG= 0;
        CALL M$OPEN( MERGE_SI );
        RETURN;
 
END SET_START_NAME;
%EJECT;
FORMAT_NAME: PROC( A_NAME );
DCL 1 A_NAME,
      2 L                    UBIN(9)   UNAL,
      2 C                    CHAR(31)  UNAL,
      2 WILD_POS             SBIN;
 
DCL TMP_NAME                 CHAR(31);
 
        IF SUBSTR(A_NAME.C,0,LENGTHC('HELP:')) = 'HELP:' THEN
           IF SUBSTR(A_NAME.C,A_NAME.L-1,LENGTHC(':')) = ':' THEN
              ;
           ELSE
              IF A_NAME.L < LENGTHC(A_NAME.C) THEN DO;
                 SUBSTR(A_NAME.C,A_NAME.L,LENGTHC(':'))= ':';
                 A_NAME.L= A_NAME.L + LENGTHC(':');
                 END;
              ELSE;
        ELSE
           IF A_NAME.L + LENGTHC('HELP::') < LENGTHC(A_NAME.C) THEN DO;
              CALL CONCAT( TMP_NAME,'HELP:',SUBSTR(A_NAME.C,0,A_NAME.L),':' );
              A_NAME.L= A_NAME.L + LENGTHC('HELP::');
              A_NAME.C= TMP_NAME;
              END;
        CALL INDEX1( A_NAME.WILD_POS,'?',A_NAME.C );
        RETURN;
 
END FORMAT_NAME;
%EJECT;
END LISTHELP;
