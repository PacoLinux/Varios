/*M* CMLOAD_C63 - PL-6 MACRO definition file for CMLOAD program.   */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1990    */
/*T*                                                         */
/*T***********************************************************/
/*X* DFC=YES, DMC=YES, EDMC = YES                                  */
/********************** INCLUDE FILES ******************************/
        %INCLUDE                CP_6_SUBS ;
        %INCLUDE                CMLOAD_C61 ;
        %INCLUDE                CMLOAD_C64 ;
/********************** TCM_ERRTEXT ********************************/
/*F*
NAME:           TCM_ERRTEXT
 
PURPOSE:        To generate error message substitution vectors
                                                                   */
/*D*
NAME:           TCM_ERRTEXT
 
CALL:           %TCM_ERRTEXT            ( FPTN = name
                                        , STCLASS = stclass
                                        , FIRST = {YES|NO}
                                        , LAST = {YES|NO}
                                        , NAME = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
FPTN = name             specifies the name given to the structure
        generated.  "name" must be a valid PL-6 variable name.
        "name" is declared at level 2.  This parameter must be
        specified.  There is no devault value.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if FIRST = YES.  The default is CONSTANT.
                                                                   */
/*K*
FIRST = {YES|NO}        specifies whether (YES) or not (NO) that this
        invocation of the macro is the beginning of a structure.  If
        YES is specified, the level one identifier ERRTEXT is
        declared.  If NO is specified, no level one identifier is
        declared.  The default is NO.
                                                                   */
/*K*
LAST = {YES|NO}         specifies whether (YES) or not (NO)
        this invocation of the macro is the end of the current
        structure.  If YES is specified, the declaration is
        terminated with a semicolon.  If NO is specified, the
        declaration is terminated with a comma.  The default is NO.
                                                                   */
/*K*
NAME = value            specifies the CHAR(1-255) CONSTANT that is
        to be used to generate the TEXTC character string.  If this
        is not specified, TEXTC string will be generated from the
        FPTN parameter.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_ERRTEXT macro is used to generate the TEXTC and VECTOR
structure used for error message substitution values.
                                                                   */
%MACRO  TCM_ERRTEXT             ( FPTN =
                                , STCLASS = CONSTANT
                                , FIRST ( YES='1'B, NO='0'B  ) = '0'B
                                , LAST ( YES=";", NO="," ) = ","
                                , NAME = ''
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
 
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  FIRST = '1'B ;
        DCL 1 ERRTEXT           STCLASS,
        %ENDIF ;
 
        %IF  LENGTHC ( NAME) = 0 ;
             %LSET TEXT = TEXTCHAR(FPTN) ;
        %ELSE ;
             %LSET TEXT = NAME ;
             %ENDIF ;
 
        %TCM_NAME               ( FPTN = FPTN
                                , LAST = NO
                                , LVL = 2
                                , NAME = %TEXT
                                                                ) ;
 
        %LSET V = CONCAT ( TEXTCHAR(FPTN), '_' ) ;
        %LSET V_ = CHARTEXT ( V ) ;
              2 %V_             VECTOR ALIGNED INIT ( VECTOR ( ERRTEXT.FPTN ) ) LAST
%MEND ;
/********************** TCM_NAME ***********************************/
/*F*
NAME:           TCM_NAME
 
PURPOSE:        To generate a TCM_NAME structure
                                                                   */
/*D*
NAME:           TCM_NAME
 
CALL:           %TCM_NAME               ( FPTN = name
                                        , STCLASS = stclass
                                        , L = value
                                        , LAST = {YES|NO}
                                        , LEN = value
                                        , LVL = value
                                        , NAME = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
FPTN = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_NAME.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is STATIC.
                                                                   */
/*K*
L = value               specifies a VALUE-DEC(0-?) that is the
        number of significant characters in the name.  The default
        is either the length of NAME or 31, if NAME is not specified.
 
        This parameter is used to initialize the FPTN.L#
        UBIN BYTE variable.
                                                                   */
/*K*
LAST = {YES|NO}         specifies whether (YES) or not (NO)
        this invocation of the macro is the end of the current
        structure.  If YES is specified, the declaration is
        terminated with a semicolon.  If NO is specified, the
        declaration is terminated with a comma.  The default is YES.
                                                                   */
/*K*
LEN = value             specifies the VALUE-DEC(0-?) of the amount
        of storage in characters that are to be reserved in this
        invocation of the macro.  The default is either the
        length of NAME or 31, if NAME is not specified.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*K*
NAME = value            specifies the VALUE-CHAR(1-?) that is to
        be stored in the TEXTC format.  The default is 31 blanks.
 
        This parameter is used to initialize the FPTN.NAME#
        CHAR variable.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_NAME macro is used to generate TEXTC data structures at
levels other than 1.
                                                                   */
%MACRO  TCM_NAME                ( FPTN = TCM_NAME
                                , STCLASS = STATIC
                                , L =
                                , LAST ( YES = ";", NO="," ) = ";"
                                , LEN =
                                , LVL = 1
                                , NAME = '                               '
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET LNG = CHARTEXT ( TEXTCHAR(L) ) ;
        %LSET SIZ = CHARTEXT ( TEXTCHAR(LEN) ) ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
             %IF  LENGTHC ( TEXTCHAR(L) ) = 0 ;
                  %LSET SIZ = LENGTHC ( NAME ) ;
                  %ENDIF ;
             %IF  LENGTHC ( TEXTCHAR(LEN) ) = 0 ;
                  %LSET LNG = 0 ;
                  %ENDIF ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %IF  LENGTHC ( TEXTCHAR(LEN) ) = 0 ;
                  %LSET LNG = CHARTEXT ( CONCAT ( TEXTCHAR(FPTN), '.L#' ) );
                  %IF  SUBSTR ( STR, 0, 4 ) = 'AUTO' ;
                       %LSET LNG = 31 ;
                       %ENDIF ;
                  %ENDIF ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 FPTN              STCLASS,
        %ELSE ;
              LVL FPTN          ,
        %ENDIF ;
 
        %(LVL+1)      L#        UBIN(9) CALIGNED %INIT ( %SIZ ) %END,
        %(LVL+1)      NAME#     CHAR(%LNG) CALIGNED %INIT ( NAME ) %END LAST
%MEND ;
/********************** TCM_PIT ************************************/
/*F*
NAME:           TCM_PIT
 
PURPOSE:        To generate Program Information Table.
                                                                   */
/*D*
NAME:           TCM_PIT
 
CALL:           %TCM_PIT                ( FPTN = name
                                        , STCLASS = stclass
                                        , ERRFID = variable
                                        , RUFID = variable
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
FPTN = name             specifies the level name given to the
        structure.  "name" must be a valid PL-6 variable name.
        The default is TCM_PIT.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        The default is SYMREF.
                                                                   */
/*K*
ERRFID = variable       specifies the VARIABLE that contains the
        error message fid.  "variable" must be in TEXTC format.
        The default is NIL.
 
        This parameter is used to initialize the FPTN.ERRFID$
        PTR variable.
                                                                   */
/*K*
RUFID = variable        specifies the VARIABLE that contains the
        run unit fid.  "variable" must be in TEXTC format.  The
        default is NIL.
 
        This parameter is used to initialize the FPTN.RUFID$
        PTR variable and the FPTN.RUFID_ VECTOR variable.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_PIT macro defines the program information table that is
used to control the execution of the CMLOAD program.
                                                                   */
%MACRO  TCM_PIT         ( FPTN = TCM_PIT
                        , STCLASS = SYMREF
                        , ERRFID = NIL
                        , RUFID = NIL
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        DCL 1 FPTN              STCLASS,
/*B*
CM(0:7)         is an array substructure containing the configuration
        information for the Control Modules (CMs) obtained from
        directly reading the IPC-IPI configuration.
                                                                   */
              2 CM(0:7)         ALIGNED,
/*B*
CM.FLAGS        is a substructure contain flags used to indicate the
        status of this CM.
                                                                   */
                3 FLAGS         UNAL,
/*B*
CM.FLAGS.PRESENT        is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) this CM is present in the
        hardware configuration.
                                                                   */
                  4 PRESENT     BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
CM.FLAGS.CONFIGED       is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) this CM is configured.
        This CM is configured if there is a DPNN configured that
        uses this CM.  (That is, this variable is calculated by
        scanning the DPNN array to determine if any devices for this
        CM are configured.)
                                                                   */
                  4 CONFIGED    BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
CM.FLAGS.FW_LOADED      is a BIT(1) variable that determines
        whether ('1'B) or not ('0'B) firmware has been successfully
        loaded into this CM by CMLOAD.
                                                                   */
                  4 FW_LOADED   BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
CM.CLASS        is a UBIN BYTE variable that defines the class of
        this CM. .01 is Disk.  .02 is Tape.
                                                                   */
                3 CLASS         UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
CM.NUMDEVS      is a UBIN BYTE variable that defines the number of
        devices attached to this CM.
                                                                   */
                3 NUMDEVS       UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
DCNN            is a substructure containing the configuration
        information for DCnn obtained from the :CONFIG.:SYS file.
                                                                   */
              2 DCNN            ALIGNED,
/*B*
DCNN.NAME       is a CHAR(8) variable that defines the name of the
        disk controller.  DCNN.NAME is initialized to blanks.  If
        DCNN.NAME is nonblank, then the information in the rest of
        the substructure is valid for DCNN.NAME.  (Therefore, if an
        error occurs in reading the :CONFIG.:SYS file, DCNN.NAME
        must be blanked after the error is reported.)
                                                                   */
                3 NAME          CHAR(8) CALIGNED %INIT (' ') %END,
/*B*
DCNN.MODEL      is a CHAR(8) variable that contains the model number
        for the DCNN controller.
                                                                   */
                3 MODEL         CHAR(8) CALIGNED %INIT (' ') %END,
/*B*
DCNN.IOCHAN(0:15)        is an array of channel information for this
        controller.
                                                                   */
                3 IOCHAN(0:15)   UNAL,
/*B*
DCNN.IOCHAN.PRESENT     is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) the channel is present.
                                                                   */
                  4 PRESENT     BIT(1) UNAL %INIT ('0'B) %END,
/*B*
DCNN.IOCHAN.DOWN        is a BIT(1) variable that defines
        whether ('1'B) or not('0'B) the channel is marked down.
                                                                   */
                  4 DOWN        BIT(1) UNAL %INIT ('0'B) %END,
/*B*
DCNN.IOCHAN.TDOK        is a BIT(1) variable that defines
        whether('1'B) or not('0'B) T&D operations are allowed on
        this channel.
                                                                   */
                  4 TDOK        BIT(1) UNAL %INIT ('0'B) %END,
                  4 *           UBIN(15) UNAL %INIT (0) %END,
/*B*
DCNN.IOCHAN.IOM         is a UBIN variable that specifies the
        logical IOM number for this DCNN.IOCHAN entry.
                                                                   */
                  4 IOM         UBIN BYTE CALIGNED %INIT (0) %END,
/*B*
DCNN.IOCHAN.CHAN        is a UBIN variable that specifies the
        channel number for this DCNN.IOCHAN entry.
                                                                   */
                  4 CHAN        UBIN BYTE CALIGNED %INIT (0) %END,
/*B*
DCNN.DCTX               is a UBIN HALF variable that specifies the
        DCT index of this controller.
                                                                   */
                3 DCTX          UBIN HALF HALIGNED %INIT (0) %END,
/*B*
DCNN.NUMDEVS            is a UBIN HALF variable that specifies the
        number of devices configured for this controller.
                                                                   */
                3 NUMDEV        UBIN HALF HALIGNED %INIT (0) %END,
/*B*
DCNN.FLAGS              is a substructure of flags used to indicate
        status of this controller.
                                                                   */
                3 FLAGS         UNAL,
/*B*
DCNN.FLAGS.DOWN         is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the controller is partitioned
        or down.
                                                                   */
                  4 DOWN        BIT(1) UNAL %INIT ('0'B) %END,
/*B*
DCNN.FLAGS.TDOK         is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the controller has the TDOK
        bit set after being partitioned.
                                                                   */
                  4 TDOK        BIT(1) UNAL %INIT ('0'B) %END,
/*B*
DCNN.FLAGS.SUSPEND      is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the controller has been
        suspended.
                                                                  */
                  4 SUSPEND     BIT(1) UNAL %INIT ('0'B) %END,
                  4 *           BIT(6) UNAL %INIT ('0'B) %END,
/*B*
DEV(0:63)       is an array substructure containing the configuration
        information for the devices obtained from
        directly reading the IPC-IPI configuration.
                                                                   */
              2 DEV(0:63)       ALIGNED,
/*B*
DEV.FLAGS       is a substructure contain flags used to indicate the
        status of this device.
                                                                   */
                3 FLAGS         UNAL,
/*B*
DEV.FLAGS.PRESENT       is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) this device is present in the
        hardware configuration.
                                                                   */
                  4 PRESENT     BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
DEV.FLAGS.CONFIGED      is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) this device is configured.
        If the device is not configured, this DEV  entry is not used.
                                                                   */
                  4 CONFIGED    BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
DEV.STATUS      is a UBIN BYTE variable that defines the status
        this device.  .FF is online.
                                                                   */
                3 STATUS        UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
DEV.TYPE        is a UBIN BYTE variable that defines the type of
        the device.  .05 is MDS I.  .07 is MDS II.
                                                                   */
                3 TYPE          UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
DEV.FORMAT      is a UBIN BYTE variable that defines the format of
        the device.  .00 is unknown format.  .01 is 64 words/sector.
        .02 is 512 words/sector.
                                                                   */
                3 FORMAT        UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
DPNN(0:63)      is a array substructure containing the configuration
        information for all DPNN devices connected to the DCNN
        controller.  This information is obtained from the
        :CONFIG.:SYS file.  This array is indexed by the device
        number (i.e., DEV#=nn).
                                                                   */
              2 DPNN(0:63)      ALIGNED,
/*B*
DPNN.NAME       is a CHAR(8) variable that defines the name of the
        disk drive in the TIGR deck.
                                                                   */
                3 NAME          CHAR(8) CALIGNED %INIT (' '*0) %END,
/*B*
DPNN.FLAGS              is a substructure of flags used to indicate
        the status of this device.
                                                                   */
                3 FLAGS         UNAL,
/*B*
DPNN.FLAGS.CONFIGED     is a BIT(1) variable that defines
        whether ('1'B) or not ('0'B) this device is configured.
        If the device is not configured, this DPNN entry is not used.
                                                                   */
                  4 CONFIGED    BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
DPNN.FLAGS.DOWN         is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the device is partitioned
        or down.
                                                                   */
                  4 DOWN        BIT(1) UNAL %INIT ('0'B) %END,
/*B*
DPNN.FLAGS.TDOK         is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the device has the TDOK
        bit set after being partitioned.
                                                                   */
                  4 TDOK        BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
DPNN.FLAGS.CHECKWRITE   is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the device has the CHECKWRITE
        bit set.
                                                                   */
                  4 CHECKWRITE  BIT(1) UNAL %INIT ('0'B*0) %END,
/*B*
ERRCODE         is a VLP_ERRCODE structure that is used to specify
        the error code of the last error detected.  The contents
        of ERRCODE are meaningful only if FLAGS.ERRCODE# is set.
                                                                   */
                %VLP_ERRCODE    ( FPTN = ERRCODE
                                , STCLASS = %STR
                                , LAST = ","
                                , LVL = 2
                                                                ) ;
/*B*
FLAGS           is a substructure of flags used to
        control the execution of the CMLOAD program.
                                                                   */
              2 FLAGS           ALIGNED,
/*B*
FLAGS.ERRCODE#  is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) an error has been
        detected and stored in TCM_PIT.ERRCODE#.
                                                                   */
                3 ERRCODE#      BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FLAGS.FWLIP#    is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) a CM firmware load is in
        progress.
                                                                   */
                3 FWLIP#        BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FLAGS.FWREAD#   is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) the MDS firmware tape has been
        read into memory.
                                                                   */
                3 FWREAD#       BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FLAGS.QUIT#     is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) to quit reading commands
        from the user.
                                                                   */
                3 QUIT#         BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FLAGS.STEPCC#   is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) a step condition code has
        been stored in TCM_PIT.STEPCC#.
                                                                   */
                3 STEPCC#       BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FLAGS.XCON#     is a BIT(1) variable that is used to specify
        whether ('1'B) or not ('0'B) exit control has been
        established.
                                                                   */
                3 XCON#         BIT(1) UNAL %INIT ( '0'B ) %END,
/*B*
FW              is a substructure that contains the information
        obtained from reading the firmware tape.
                                                                   */
              2 FW              ALIGNED,
/*B*
FW.LABEL        is a substructure that contains information from
        reading the firmware tape label.
                                                                   */
                3 LABEL         CALIGNED,
/*B*
FW.LABEL.PREFIX         is a CHAR(6) variable that contains the
        first 6 characters of the firmware tape label.  These
        characters are usually "CM3COS".
                                                                   */
                  4 PREFIX      CHAR(6) CALIGNED %INIT (' ') %END,
/*B*
FW.LABEL.REV            is a CHAR(2) variable that contains the
        revision of the firmware tape.
                                                                   */
                  4 REV         CHAR(2) CALIGNED %INIT (' ') %END,
/*B*
FW.LABEL.CKSUM          is a UBIN variable that contains the checksum
        check digit) read from the firmware tape label.
                                                                   */
                  4 CKSUM       UBIN WORD ALIGNED %INIT (0) %END,
/*B*
FW.LABEL.LEN            is a UBIN variable that contains the firmware
        length that was read from the firmware tape label.
                                                                   */
                  4 LEN         UBIN WORD ALIGNED %INIT (0) %END,
/*B*
FW.SEG_         is a VECTOR framing the data segment used for TDIO
                                                                  */
                3 SEG_          BIT(72)  %INIT (VECTOR(NIL)) %END,
/*B*
FW.P$           is a pointer to the firmware that was read into
        memory from the firmware tape.
                                                                   */
                3 P$            PTR ALIGNED %INIT (ADDR(NIL)) %END,
/*B*
FW.NWORDS       is a UBIN variable that specifies the number of
        words of firmware that was read from the firmware tape.
                                                                   */
                3 NWORDS        UBIN WORD ALIGNED %INIT (0) %END,
/*B*
IPC             is a substructure containing the configuration
        information for the IPC obtained from the hardware by
        doing the Read IPC Configuration command ('21'O).
                                                                   */
              2 IPC             ALIGNED,
/*B*
IPC.EPROM       is a substructure containg the configuration
        information for the IPC EPROM.
                                                                   */
                3 EPROM         ALIGNED,
/*B*
IPC.EPROM.ID            is a UBIN BYTE variable specifying the
        EPROM id.  '05'X = IPC-IPI.
                                                                   */
                  4 ID          UBIN BYTE CALIGNED %INIT (0) %END,
/*B*
IPC.EPROM.XFMRID        is a UBIN BYTE specifying the EPROM
        transformer ID.  '0A'H = FIPSII.  '0B'H = IPI.
                                                                   */
                  4 XFMRID      UBIN BYTE CALIGNED %INIT (0) %END,
/*B*
IPC.EPROM.REV           is a CHAR(2) variable specifying the
        EPROMI firmware revision.
                                                                   */
                  4 REV         CHAR(2) CALIGNED %INIT (' ') %END,
/*B*
IPC.FW          is a substructure containing the configuration
        information for the IPC firmware.  Since there can be
        up to 2 firmwares in the IPC, FW is an array.
                                                                   */
                3 FW(0:1)       ALIGNED,
/*B*
IPC.FW.CLASS            is a UBIN BYTE variable specifying the
        firmware class.  TBD.
                                                                   */
                  4 CLASS       UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
IPC.FW.MODEL            is a UBIN BYTE variable specifying the
        firmware model.  '01'H = CM-3.
                                                                   */
                  4 MODEL       UBIN BYTE CALIGNED %INIT (0*0) %END,
/*B*
IPC.FW.REV              is a CHAR(2) variable specifying the firmware
        revision.
                                                                   */
                  4 REV         CHAR(2) CALIGNED %INIT (' '*0) %END,
/*B*
ERRFID$         is a PTR variable that points to the error message
        file name structure.
                                                                   */
              2 ERRFID$         PTR ALIGNED %INIT ( ADDR ( ERRFID ) ) %END,
/*B*
PXCON$$         is an EPTR variable that contains the previous exit
        control entry point.
                                                                   */
              2 PXCON$$         EPTR ALIGNED %INIT ( ENTADDR ( NIL ) ) %END,
/*B*
RUFID$          is a PTR variable that points to the run unit file
        name structure.
                                                                   */
              2 RUFID$          PTR ALIGNED %INIT ( ADDR ( RUFID ) ) %END,
/*B*
STEPCC#         is a UBIN WORD variable that is used to contain the
        highest step condition code that is to be set when the
        CMLOAD program does an M$EXIT, M$ERR, or M$XXX.
                                                                   */
              2 STEPCC#         UBIN WORD ALIGNED %INIT ( 0 ) %END ;
%MEND ;
/********************** TCM_DCW  ***********************************/
/*F*
NAME:           TCM_DCW
 
PURPOSE:        To generate a DCW  structure
                                                                   */
/*D*
NAME:           TCM_DCW
 
CALL:           %TCM_DCW                ( NAME = name
                                        , STCLASS = stclass
                                        , LVL = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
NAME = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_DCW.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is BASED.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_DCW  macro is used to generate a DCW  structure.  The
structure may be generated at any level.
                                                                   */
%MACRO  TCM_DCW                 ( NAME = TCM_DCW
                                , STCLASS = BASED
                                , LVL = 1
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 NAME              STCLASS ALIGNED,
        %ELSE ;
              LVL NAME          ,
        %ENDIF ;
 
        %(LVL+1) FWA UBIN(18) UNAL,     /* FIRST WORD ADDRESS      */
        %(LVL+1) ICP UBIN(3) UNAL,      /* INITIAL CHARACTER POSITION */
        %(LVL+1) TYPE UBIN(3) UNAL,     /* DCW TYPE                */
        %(LVL+1) TALLY UBIN(12) UNAL,   /* WORD COUNT              */
        %(LVL+1) T REDEF TALLY UNAL,    /* TDCW INFORMATION        */
          %(LVL+2) * BIT(3) UNAL,
          %(LVL+2) DCWLIST UNAL,        /* IMX ADDRESS BASE FOR DCWLIST */
             %(LVL+3) IBC BIT(1) UNAL,  /* INHIBIT BASE CHANGE     */
             %(LVL+3) BASE UBIN(2) UNAL, /* ADDRESS BASE WORD INDEX: 0-3 */
          %(LVL+2) * BIT(1) UNAL,
          %(LVL+2) SEG BIT(1) UNAL,     /* MSB OF TRANSFER ADDR    */
          %(LVL+2) PDATA BIT(1) UNAL,   /* PAGED DATA              */
          %(LVL+2) PDCW BIT(1) UNAL,    /* GOTO MODE 4 (PAGED DCWLIST) */
          %(LVL+2) RESTRICT BIT(1) UNAL, /* NO MORE IDCWS IN LIST  */
          %(LVL+2) REL BIT(1) UNAL      /* GOTO MODE 3A (PAGED DATA) */
 
        %IF LVL=1;
                                          ;
        %ELSE;
                                          ,
        %ENDIF;
%MEND;
/********************** TCM_IDCW ***********************************/
/*F*
NAME:           TCM_IDCW
 
PURPOSE:        To generate a IDCW structure
                                                                   */
/*D*
NAME:           TCM_IDCW
 
CALL:           %TCM_IDCW               ( NAME = name
                                        , STCLASS = stclass
                                        , LVL = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
NAME = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_IDCW.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is BASED.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_IDCW macro is used to generate a IDCW structure.  The
structure may be generated at any level.
                                                                   */
%MACRO  TCM_IDCW                ( NAME = TCM_IDCW
                                , STCLASS = BASED
                                , LVL = 1
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 NAME              STCLASS ALIGNED,
        %ELSE ;
              LVL NAME          ,
        %ENDIF ;
 
        %(LVL+1) DC UBIN(6) UNAL,       /* DEVICE COMMAND          */
        %(LVL+1) DVN UBIN(6) UNAL,      /* DEVICE NUMBER           */
        %(LVL+1) EXTA UBIN(6) UNAL,     /* ADDRESS EXTENSION       */
        %(LVL+1) DATA REDEF EXTA UNAL,  /* IMX ADDRESS BASE FOR DATA */
          %(LVL+2) IBC BIT(1) UNAL,     /* INHIBIT BASE CHANGE     */
          %(LVL+2) BASE UBIN(2) UNAL,   /* ADDRESS BASE WORD INDEX:  0-3 */
          %(LVL+2) * BIT(3) UNAL,
        %(LVL+1) SVN UBIN(3) UNAL,      /* '7'O                    */
        %(LVL+1) EC BIT(1) UNAL,        /* IN NON-PAGED MODE: LOAD AEX REG */
        %(LVL+1) CONT BIT(1) UNAL,      /* CONTINUE                */
        %(LVL+1) MARK BIT(1) UNAL,      /* MARKER INTERRUPT        */
        %(LVL+1) CC UBIN(6) UNAL,       /* CHANNEL COMMAND         */
        %(LVL+1) CCB REDEF CC,
          %(LVL+2) * BIT(4) UNAL,
          %(LVL+2) NOBUF BIT(1) UNAL,   /* NO DATA BUFFER REQUIRED */
          %(LVL+2) * BIT(1) UNAL,
        %(LVL+1) RCNT UBIN(6) UNAL      /* RECORD COUNT            */
 
        %IF LVL=1;
                                        ;
        %ELSE;
                                        ,
        %ENDIF;
%MEND;
/********************** TCM_TDCW ***********************************/
/*F*
NAME:           TCM_TDCW
 
PURPOSE:        To generate a TDCW structure
                                                                   */
/*D*
NAME:           TCM_TDCW
 
CALL:           %TCM_TDCW               ( NAME = name
                                        , STCLASS = stclass
                                        , LVL = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
NAME = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_TDCW.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is BASED.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_TDCW macro is used to generate a TDCW structure.  The
structure may be generated at any level.
                                                                   */
%MACRO  TCM_TDCW                ( NAME = TCM_TDCW
                                , STCLASS = BASED
                                , LVL = 1
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 NAME              STCLASS ALIGNED,
        %ELSE ;
              LVL NAME          ,
        %ENDIF ;
 
        %(LVL+1) TRA UBIN(18) UNAL,     /* TRANSFER ADDRESS        */
        %(LVL+1) * BIT(3),              /* '0'O                    */
        %(LVL+1) TYPE UBIN(3) UNAL,     /* TDCW TYPE=2             */
        %(LVL+1) FLAGS,
          %(LVL+2) * BIT(7),
          %(LVL+2) SEG BIT(1),          /* MSB OF TRANSFER ADDRESS */
          %(LVL+2) * BIT(1),
          %(LVL+2) PDCW BIT(1),         /* GOTO MODE 4 (PAGED DCW LIST) */
          %(LVL+2) * BIT(1),
          %(LVL+2) REL BIT(1)           /* GOTO MODE 3A (PAGED DATA) */
 
        %IF LVL=1;
                                   ;
        %ELSE;
                                   ,
        %ENDIF;
%MEND;
/********************** TCM_STATUS ***********************************/
/*F*
NAME:           TCM_STATUS
 
PURPOSE:        To generate a STATUS structure
                                                                   */
/*D*
NAME:           TCM_STATUS
 
CALL:           %TCM_STATUS             ( NAME = name
                                        , STCLASS = stclass
                                        , LVL = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
NAME = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_STATUS.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is BASED.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_STATUS macro is used to generate a STATUS structure. The
structure may be generated at any level.
                                                                   */
%MACRO  TCM_STATUS              ( NAME = TCM_STATUS
                                , STCLASS = BASED
                                , LVL = 1
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 NAME              STCLASS DALIGNED,
        %ELSE ;
              LVL NAME          ,
        %ENDIF ;
 
        %(LVL+1) PRESENCE BIT(1),       /* ALWAYS ONE              */
        %(LVL+1) POWEROFF BIT(1),       /* POWER OFF STATUS        */
        %(LVL+1) MAJOR UBIN(4) UNAL,    /* DEVICE MAJOR STATUS     */
        %(LVL+1) MINOR BIT(6),          /* DEVICE MINOR STATUS     */
        %(LVL+1) ODD BIT(1),            /* ODD WORD COUNT          */
        %(LVL+1) MARKER BIT(1),         /* MARKER INTERRUPT        */
        %(LVL+1) * BIT(2),
        %(LVL+1) ININT BIT(1),          /* INITIATION INTERRUPT    */
        %(LVL+1) * BIT(1),
        %(LVL+1) IOM,                   /* IOM STATUS:             */
          %(LVL+2) CHANNEL UBIN(3) UNAL, /* CHANNEL-DETECTED       */
          %(LVL+2) CENTRAL UBIN(3) UNAL, /* CENTRAL-DETECTED       */
        %(LVL+1) * BIT(6),
        %(LVL+1) RCR UBIN(6) UNAL,      /* RECORD COUNT RESIDUE    */
        %(LVL+1) NWA UBIN(18) UNAL,     /* NEXT WORD ADDRESS       */
        %(LVL+1) NCP UBIN(3) UNAL,      /* NEXT CHAR POSITION      */
        %(LVL+1) READFLG BIT(1),        /* READ/WRITE FLAG         */
        %(LVL+1) TYPE BIT(2),           /* DCW TYPE                */
        %(LVL+1) TALLYR UBIN(12) UNAL   /* TALLY RESIDUE           */
 
        %IF LVL=1;
                                           ;
        DCL 1
        %ELSE;
                                           ,
          LVL
        %ENDIF;
 
        %(CHARTEXT(CONCAT('FLT',SUBSTR(TEXTCHAR(NAME),0,4)))) REDEF NAME, /* FAULT STATUS */
        %(LVL+1) PPMAJOR BIT(6),   /* PRESENCE, POWER OFF, AND MAJOR STATUS */
        %(LVL+1) * BIT(3),
        %(LVL+1) CHAN UBIN(9) UNAL,     /* CHANNEL NUMBER          */
        %(LVL+1) SRQ UBIN(3) UNAL,      /* SERVICE REQUEST CODE    */
        %(LVL+1) * BIT(5),
        %(LVL+1) SC UBIN(4) UNAL,       /* SYSTEM CONTROLLER FAULT */
        %(LVL+1) IO UBIN(6) UNAL,       /* IOM FAULT               */
        %(LVL+1) DCW BIT(36) ALIGNED    /* LAST DCW                */
 
        %IF LVL=1;
                                          ;
        DCL 1
        %ELSE;
                                          ,
          LVL
        %ENDIF;
        %(CHARTEXT(CONCAT('SP',SUBSTR(TEXTCHAR(NAME),0,4)))) REDEF NAME, /* SPECIAL INTERRUPT STATUS */
        %(LVL+1) * BIT(3),
        %(LVL+1) CHAN UBIN(6) UNAL,     /* CHAN NUM;  VALID FOR IOM/IOP ONLY */
        %(LVL+1) * BIT(3),
        %(LVL+1) DVN UBIN(6) UNAL,      /* DEVICE NUMBER           */
        %(LVL+1) CODE,                  /* STATUS CODE             */
          %(LVL+2) BYTE3 UBIN(9) UNAL,
          %(LVL+2) BYTE4 UBIN(9) UNAL,
        %(LVL+1) SPEC BIT(36) UNAL
 
        %IF LVL=1;
                             ;
        %ELSE;
                             ,
        %ENDIF;
%MEND;
/********************** TCM_EXTST ***********************************/
/*F*
NAME:           TCM_EXTST
 
PURPOSE:        To generate a EXTST structure
                                                                   */
/*D*
NAME:           TCM_EXTST
 
CALL:           %TCM_EXTST              ( NAME = name
                                        , STCLASS = stclass
                                        , LVL = value
                                                                ) ;
 
PARAMETERS:
                                                                   */
/*K*
NAME = name             specifies the name given to the
        structure.  "name" is declared at the level specified by
        LVL.  "name" must be a valid PL-6 variable name.  The
        default is TCM_EXTST.
                                                                   */
/*K*
STCLASS = stclass       specifies the storage class given to the
        structure.  "stclass" must be a valid PL-6 storage class.
        "stclass" is used only if LVL = 1.  The default is BASED.
                                                                   */
/*K*
LVL = value             specifies the VALUE-DEC(1-9) of the level
        of this invocation of the macro.  The default is 1.
                                                                   */
/*D*
DESCRIPTION:
 
The TCM_EXTST macro is used to generate a EXTST structure. The
structure may be generated at any level.
                                                                   */
%MACRO  TCM_EXTST               ( NAME = TCM_EXTST
                                , STCLASS = BASED
                                , LVL = 1
                                                                ) ;
        %LSET LISTEXP = '1'B ;
        %LSET LISTSUB = '1'B ;
        %LSET STR = CONCAT ( TEXTCHAR (STCLASS), '      ' ) ;
        %IF  ( SUBSTR ( STR, 0, 6 ) = 'STATIC' )  OR
             ( SUBSTR ( STR, 0, 8 ) = 'CONSTANT' )  OR
             ( SUBSTR ( STR, 0, 3 ) = 'EXT' )  OR
             ( SUBSTR ( STR, 0, 6 ) = 'SYMDEF' ) ;
             %LSET INIT = CHARTEXT ( 'INIT' ) ;
             %LSET END  = CHARTEXT ( '    ' ) ;
        %ELSE ;
             %LSET INIT = CHARTEXT ( '/*  ' ) ;
             %LSET END  = CHARTEXT ( '  */' ) ;
             %ENDIF ;
 
        %IF  LVL = 1 ;
        DCL 1 NAME              STCLASS ALIGNED,
        %ELSE ;
              LVL NAME          ,
        %ENDIF ;
 
        %(LVL+1) EXTST ALIGNED,
          %(LVL+2) BITE(0:25) UBIN(8) UNAL,
          %(LVL+2) * UBIN(8) UNAL,
        %(LVL+1) EXTSTT REDEF EXTST,
          %(LVL+2) WRD(0:5) UBIN ALIGNED,
        %(LVL+1) CRPEXTST REDEF EXTST,
          %(LVL+2) PSR BIT(8) UNAL,
          %(LVL+2) PER BIT(8) UNAL,
          %(LVL+2) MR BIT(8) UNAL,
          %(LVL+2) RSR BIT(8) UNAL,
          %(LVL+2) DS1 BIT(8) UNAL,
          %(LVL+2) DS2 BIT(8) UNAL,
          %(LVL+2) ENR BIT(8) UNAL,
          %(LVL+2) IFR BIT(8) UNAL,
          %(LVL+2) DCR BIT(8) UNAL,
          %(LVL+2) CWF BIT(16) UNAL,
          %(LVL+2) * BIT(20) UNAL,
          %(LVL+2) STBUF BIT(36) ALIGNED,
          %(LVL+2) * (0:8) BIT(8) UNAL,
        %(LVL+1) * (0:1) UBIN
 
        %IF LVL=1;
                ;
        %ELSE;
                LAST
        %ENDIF;
%MEND;
