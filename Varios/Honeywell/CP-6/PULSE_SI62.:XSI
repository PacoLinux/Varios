/*
 
********************************************************************************
*                                                                              *
*                  Copyright (c) 1986-1990 Gregory J. Smith                    *
*                            Bucknell University                               *
*                                                                              *
********************************************************************************
 
      Programmers   :  Gregory J. Smith
                    :  Chris Weber
      Date started  :  September 19, 1985.
      Date finished :  April 11, 1986.
      Date updated  :  February 14, 1990.
 
      This file contains the external utility routines for the PULSE
      screen editor.
 
*/
 
GetOut: Proc;
/*
      Exit control procedure
*/
 
%Include CP_6;
%Include CP_6_SUBS;
%Include B_ERRORS_C;
%Include B$TABLES_C;
%Include XUF_ENTRY;
%Include XUG_ENTRY;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl PutAwayFiles Entry;
Dcl YEM$ErrMsg Entry(8) AltRet;
Dcl YEG$ErrCode Entry(2);
Dcl YWS$DownString Entry(3);
Dcl YSC$SaveContext Entry AltRet;
 
%SUB_EXC;
%B$TCB;
%B$XCON;
%B$EXCFR;
%B$SR_Non_Blank;
Dcl B$TCB$ Ptr SymRef;
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
Dcl Fmt Char(0) Static Unal Init('.%<O    ');
Dcl FmtOut Char(16) Static Unal;
%F_FDS ( NAME = FDS3,
         DVFC = ' ',
          BUF = FmtOut,
      STCLASS = STATIC );
 
%FPT_XCON( FPTN = ResetXCon,
        STCLASS = STATIC );
 
%FPT_TRAP( FPTN = ResetTrap,
            PTC = PTC,
        STCLASS = STATIC );
 
%VLP_PTC(FPTN = PTC);
 
%FPT_ALIB( FPTN = Delta,
            CMD = DeltaCmd,
           DLIB = YES,
        LIBNAME = DeltaName,
        STCLASS = STATIC );
 
%VLP_NAME( FPTN = DeltaName,
           NAME = %DeltaName,
        STCLASS = STATIC );
 
Dcl DeltaCmd Char(0) Static Unal Init(%DeltaCmd);
 
%FPT_OPEN ( FPTN = DeleteSAndM,
             DCB = M$Block,
             FUN = UPDATE,
             ASN = FILE,
          DELETE = YES,
            NAME = SAndMFid,
         STCLASS = STATIC );
                   
%FPT_CLOSE( FPTN = CloseWindow,
         STCLASS = STATIC );
 
%FPT_CLOSE(FPTN=Close,STCLASS=STATIC);
 
%FPT_WRITE( FPTN = WriteUC,
             DCB = M$UC,
             BUF = ComLine,
         STCLASS = STATIC );
 
%FPT_READ ( FPTN = ReadUC,
             DCB = M$UC,
             BUF = ComLine,
         STCLASS = STATIC );
 
%F$DCB;
Dcl M$DO Dcb;
Dcl Bound UBin;
Dcl Junk UBin;
Dcl 1 U1 WAligned Static,
    2 Len UBin(9) CAligned,
    2 Name Char(31) CAligned;
 
Dcl 1 U2 WAligned Static,
    2 Len UBin(9) CAligned,
    2 Name Char(15) CAligned;
 
/*
   Internal routine
*/
 
XSaveContext: Proc;
/*
   Get a filename, then call the save context routine
*/
TryAgain:
   ComLine = 'File Name?  ';
   WriteUC.Buf_.Bound = 11;
   Call M$Write( WriteUC ) WhenAltReturn do; end;
   ComLine = ' ';
   Call M$Read( ReadUC ) Altret ( TryAgain );
   If ComLine = ' '
    Then
      Goto TryAgain;
 
   Fid = Substr(ComLine,0,M$UC$->F$Dcb.Ars#);
   Call M$Fid( MakeContextFid )
    WhenAltReturn do;
      Call YEM$ErrMsg;
      Goto TryAgain;
    End;
 
   OpenContext.V.Oper.Test# = %True;
   OpenContext.V.Exist# = %Error#;
   Call M$Open( OpenContext )
    WhenAltReturn do;
      Call YEG$ErrCode( ErrCode );
      If ErrCode.Err# = %E$CreatErr
       Then do;
         Call YEM$ErrMsg;
         ComLine = 'Replace it? (Y or N)  ';
         WriteUC.Buf_.Bound = 21;
         Call M$Write( WriteUC ) WhenAltReturn do; end;
         ComLine = ' ';
         Call M$Read( ReadUC ) altret ( TryAgain );
         If (ComLine ~= 'Y') and (ComLine ~= 'y')
          Then
            Goto TryAgain;
 
         OpenContext.V.Exist# = %NewFile#;
         Call M$Open( OpenContext )
          WhenAltReturn do;
            Call YEM$ErrMsg;
            Goto TryAgain;
          End;  /* when altret */
       End;  /* If exists */
    End;  /* when altret */
 
   OpenContext.V.Oper.Test# = %False;
   Call YSC$SaveContext
    WhenAltReturn do;
      Call YEM$ErrMsg;
      Goto TryAgain;
    End;
 
   Return;
 
End XSaveContext;
 
/*
      Begin GetOut
*/
 
/*
   give user a chance to clean up work files; in case he hasn't already
   done so, like after a line disconnect or ^Y and QUIT
*/
   Call M$XCon( ResetXCon );
   Call M$Trap( ResetTrap );
   If Not PutAwayDone
    Then do; /* Hmmm...there appear to be problems for this guy */
      If M$Com$ -> F$Dcb.Fcd#
       Then do;
         Close.V.Dcb# = M$Com#;
         Call M$Close( Close) WhenAltReturn do; end;
       End;
 
      If M$Edit$ -> F$Dcb.Fcd#
       Then do;
         Close.V.Dcb# = M$Edit#;
         Call M$Close( Close) WhenAltReturn do; end;
       End;
 
      If M$Window$ -> F$Dcb.Fcd#
       Then do;
         Close.V.Dcb# = M$Window#;
         Call M$Close( Close) WhenAltReturn do; end;
       End;
 
      If B$Tcb$ -> B$Tcb.Stk$ -> B$ExCFr.ECC = %ECC_XCon#
       Then do;
         If B$Tcb$ -> B$Tcb.Stk$ -> B$XCon.RnSt.XXX or
            B$Tcb$ -> B$Tcb.Stk$ -> B$XCon.RnSt.Err or
            B$Tcb$ -> B$Tcb.Stk$ -> B$XCon.RnSt.SSPAbrt or
            B$Tcb$ -> B$Tcb.Stk$ -> B$XCon.RnSt.MAbrt
          Then
            Call M$ALib( Delta ) WhenAltReturn do; end;
        End; /*  if  */
       Else
         If B$Tcb$ -> B$Tcb.Stk$ -> B$ExCFr.ECC = %ECC_Error#
          Then do;
            Do Case B$Tcb$ -> B$Tcb.Stk$ -> B$ExCFr.SubC;
             Case(%SubC_Memory#);
              U1.Len = LengthC(%MemoryFault);
              U1.Name = %MemoryFault;
 
             Case(%SubC_Cmmd#);
              U1.Len = LengthC(%Cmmd);
              U1.Name = %Cmmd;
 
             Case(%SubC_Lockup#);
              U1.Len = LengthC(%Lockup);
              U1.Name = %Lockup;
 
             Case(%SubC_IPR#);
              U1.Len = LengthC(%IPR);
              U1.Name = %IPR;
 
             Case(%SubC_MSeg#);
              U1.Len = LengthC(%MSeg);
              U1.Name = %MSeg;
 
             Case(%SubC_MPage#);
              U1.Len = LengthC(%MPage);
              U1.Name = %MPage;
 
             Case(%SubC_Sec2#);
              U1.Len = LengthC(%Sec2);
              U1.Name = %Sec2;
 
             Case(%SubC_Prty#);
              U1.Len = LengthC(%Prty);
              U1.Name = %Prty;
 
             Case(%SubC_Opnc#);
              U1.Len = LengthC(%Opnc);
              U1.Name = %Opnc;
 
             Case(%SubC_Sec1#);
              U1.Len = LengthC(%Sec1);
              U1.Name = %Sec1;
 
             Case(%SubC_DLnk#);
              U1.Len = LengthC(%DLnk);
              U1.Name = %DLnk;
 
             Case(%SubC_MWSP#);
              U1.Len = LengthC(%MWSP);
              U1.Name = %MWSP;
 
             Case(Else);
              U1.Len = LengthC(%UnknownFault);
              U1.Name = %UnknownFault;
 
            End;  /* case */
 
           Call X$Write( FDS3, Vector( Fmt ),
                               Vector( B$TCB$->B$TCB.STK$->B$ExCFr.IC ) );
           U2.Name = Substr(FmtOut,1);  /* toss VFC char */
           Call SearchR( Bound,junk,B$SR_Non_Blank,FmtOut );
           U2.Len = Bound + 1;
           YYY_ErrCode.Err# = %E$TrapFault;
           Call YEM$ErrMsg(YYY_ErrCode,,DcbNum(M$DO),Vector(U1),Vector(U2));
           Call M$ALib( Delta ) WhenAltReturn do; end;
          End; /* error */
 
TryAgain:
      If Buffers# > 0
       Then do;
         ComLine = 'Save your current context? (Y or N)  ';
         WriteUC.Buf_.Bound = 36;
         Call M$Write( WriteUC ) WhenAltReturn do; end;
         ComLine = ' ';
         Call M$Read( ReadUC ) Altret ( TryAgain );
         If (ComLine = 'Y') or (ComLine = 'y')
          Then
            Call XSaveContext;
          Else
            If (ComLine ~= 'N') and (ComLine ~= 'n')
             Then
               Goto TryAgain;  /* didn't answer with a Y or N */
 
         Call PutAwayFiles;
       End; /* If there is any context to save */
    End;
 
   Call M$Open( DeleteSAndM ) WhenAltReturn do; end;
 
   CloseWindow.V.Dcb# = M$Window#;
   Call M$Close( CloseWindow ) WhenAltReturn do; end;
 
   Call Xug$Close_Dcbs( Xug_Close );
   Call YWS$DownString( ExitLine, Exit#, %E$BadExitStr ); /* reset term */
 
   If RestoreOK then Call M$STrmCtl( OriginalTerminalSettings )
      WhenAltReturn do; end;
 
   Call M$Exit;
 
End GetOut;
/**/
%EOD;
/**/
SetBreakPrompt: Proc;
/*
      Procedure to write out a 'Break!  C to continue. ' message
*/
%Include CP_6;
%Include CP_6_SUBS;
%Include XUF_ENTRY;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl Format Char(0) Constant Init('Break at %D of %D.  C to continue. ');
Dcl BreakPrompt Char(0) Static Init('Break!  C to continue. ');
Dcl LittlePrompt Char(0) Static Init( ' ' );
Dcl Num UBin;
 
%F$DCB;
 
%FPT_Prompt( FPTN = SetPrompt,
          STCLASS = STATIC );
 
%FPT_PRecord(FPTN = PRec,
          STCLASS = STATIC,
              DCB = M$SI,
                N = -99999999,
             KEYR = NO,
             KEYS = NO );
 
%FPT_PRecord(FPTN = PRecRestore,
          STCLASS = STATIC,
              DCB = M$SI,
             KEYR = NO,
              KEY = SIKey,
             KEYS = YES );
 
%F_FDS ( NAME = FDSSet,
         DVFC = 'a',      /*  upspace, then print  */
          DCB = M$UC,
          BUF = FmtBuf,
      STCLASS = STATIC );
 
FmtBuf = ' ';
M$SI$ = DCBAddr( DcbNum( M$SI ) );
 
If Mode = %CommandWindow or Mode = %Restoring
 Then do;
   FDSSet.Dcb# = DcbNum( M$Window );
   SetPrompt.V.Dcb# = DcbNum( M$Window );
 End;
 Else do;
   FDSSet.Dcb# = DcbNum( M$UC );
   SetPrompt.V.Dcb# = DcbNum( M$UC );
 End;
 
Do Case Mode;
   Case( %WorkFile, %Search, %Replace, %Rekeying );
     If M$SI$ -> F$Dcb.Org# = %KEYED#
      Then
        Call M$PRecord( PRec )
         WhenAltReturn do;
           Num = M$SI$ -> F$Dcb.Ars#;
           Call M$PRecord( PRecRestore )
            WhenAltReturn do;
              Call M$Merc;
              Call M$XXX;
            end;
         end;
      Else
        Num = M$SI$ -> F$Dcb.CRecNo;   /*  nifty, undocumented field in DCB  */
 
     Call X$Write( FDSSet, Vector( Format ), Vector( Num ), Vector( NumberOfRecs ) );
 
   Case( Else );
     Call X$Write( FDSSet, Vector( BreakPrompt ) );
 
End;  /*  Case  */
 
SetPrompt.Prompt_ = Vector( LittlePrompt );
Call M$Prompt( SetPrompt ) WhenAltReturn do; end;
 
End SetBreakPrompt;
/**/
%EOD;
/**/
Resume: Proc;
/*
      Procedure to resume or abort a command.
*/
%Include CP_6;
%Include CP_6_SUBS;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%FPT_CLOSE( FPTN = CloseUp,
         STCLASS = STATIC );
 
CloseUp.V.Disp# = %Save#;
CloseUp.V.DCB# = M$Imp#;
Call M$Close( CloseUp ) WhenAltReturn do; end;
 
CloseUp.V.Disp# = %Release#;
CloseUp.V.DCB# = M$Block#;
Call M$Close( CloseUp ) WhenAltReturn do; end;
 
If (Mode = %Rekeying) then       /*  release the partial file  */
   CloseUp.V.Disp# = %Release#;
else
   CloseUp.V.Disp# = %Save#;
 
CloseUp.V.DCB# = M$OU#;
Call M$Close( CloseUp ) WhenAltReturn do; end;
 
UnWind to NewCommand;
 
End Resume;
/**/
%EOD;
/**/
YBG$Break: Proc Async;
/*
      Break handling procedure
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl SetBreakPrompt Entry;
Dcl Resume Entry;
Dcl CBuf Char(255) Static;
 
%FPT_READ( FPTN = C,
            BUF = CBuf,
        STCLASS = STATIC );
 
If (Mode = %CommandWindow) or (Mode = %WorkFile)
 Then
   Return;
 
Call SetBreakPrompt;
CBuf = ' ';
If Mode = %Restoring
 Then
   C.V.Dcb# = DcbNum( M$Window );
 Else
   C.V.Dcb# = DcbNum( M$UC );
 
Call M$Read( C ) WhenAltReturn do; end;
If (CBuf ~= 'C') and (CBuf ~= 'c')
 Then
   If UnsafeFlag or (Mode = %Restoring)
    Then do;
      BrokenFlag = %True;
      Return;
    End;
    Else do;
      Call M$ClrStk
       WhenAltReturn do;
         Call M$MErC;
         Call M$XXX;
       End;
 
      Call Resume;
 
    End;  /*  else  */
 
 Else
   Return;
 
End YBG$Break;
/**/
%EOD;
/**/
/*  YEM$ERRMSG - print YY, YE, or monitor error codes  */
 
YEM$ErrMsg: Proc (ErrCode, ErrDCB#, OutDCB#,
                          F1, F2, F3, FlgLev, VFCtype) AltRet;
 
%Include  CP_6;
%Include  NK_VFC_C;
%Include  XUG_ENTRY;
%Include  XU_MACRO_C;
 
  %B$TCB;
  %B$ALT;
 
  %XUG_GetCmd;
 
  %FPT_UnFID (FPTN=UnFIDRU,
              DCB=M$LM,
              TextFID=YEM_RUFID.Name#,
              Len=lengthRUFID);
 
%Equ  YY = '3131'O;  /* YY fcg */
%Equ  Yx = '3100'O;  /* Yx fcg */
%Equ  xx = '0000'O;  /* xx fcg */
%Set  true  = '1'B;
%Set  false = '0'B;
 
/*
     Declarations
*/
 
  %VLP_ErrCode (FPTN=ErrCode,
                StClass=Param);
  Dcl  ErrDCB# UBin Param;
  Dcl  OutDCB# UBin Param;
  Dcl  F1 Vector Param;
  Dcl  F2 Vector Param;
  Dcl  F3 Vector Param;
  Dcl  FlgLev UBin Param;
  Dcl  VFCtype UBin Param;
 
  Dcl  YEM_FirstTime Bit(1) Static Aligned Init(%true);
  Dcl  YEM_LastFCG Bit(12) Static Aligned Init(%xx);
  Dcl  YEM_ErrDCB# UBin Static;
  %VLP_Name (FPTN=YEM_YErrMsgFID,
             Name=':YERRMSG.Z');
  %VLP_Name (FPTN=YEM_RUFID,
             Len=50);
  %VLP_ErrCode (FPTN=YEM_ErrCode);
 
  Dcl  M$LM DCB;
  Dcl  lengthRUFID UBin Static;
  Dcl  B$TCB$ Ptr SymRef;
  Dcl  FCG Bit(12) Aligned;
 
/*
     Begin YEM$ErrMsg
*/
 
  If YEM_FirstTime Then Do;  /* first time through - initialize */
    Call M$UnFID (UnFIDRU);
    YEM_RUFID.L# = lengthRUFID;
    YEM_FirstTime = %false;
    End;
 
  If Addr (ErrCode) = Addr (Nil) Then  /* use error code from altret frame */
    YEM_ErrCode = B$TCB$->B$TCB.ALT$->B$ALT.ERR;
  Else
    YEM_ErrCode = ErrCode;
 
  If Addr(ErrDCB#) = Addr(Nil) Then  /* use DCB# from altret frame */
    YEM_ErrDCB# = B$TCB$->B$TCB.ALT$->B$ALT.DCB#;
  Else
    YEM_ErrDCB# = ErrDCB#;
 
  If YEM_ErrCode.FCG = %YY Then
    FCG = %YY;
  Else If (YEM_ErrCode.FCG & '7700'O) = %Yx Then
    FCG = %Yx;
  Else
    FCG = %xx;
 
  If (FCG ~= YEM_LastFCG) Then Do;  /* switch error-message file */
    YEM_LastFCG = FCG;
 
    Do Select FCG;
      Select %YY;
        XUG_GetCmd.ErrMFID$ = Addr (YEM_RUFID);
 
      Select %Yx;
        XUG_GetCmd.ErrMFID$ = Addr (YEM_YErrMsgFID);
 
      Select Else;
        XUG_GetCmd.ErrMFID$ = Addr (Nil);
      End;
 
    Call XUG$SetErrMsg (XUG_GetCmd);
    End;
 
  XUG_GetCmd.Err_Code = YEM_ErrCode;
  XUG_GetCmd.ErrDCB# = YEM_ErrDCB#;
 
  If Addr(OutDCB#) ~= Addr(Nil) Then Do;
    XUG_GetCmd.OutDCB# = OutDCB#;
    XUG_GetCmd.DCB_Param# = OutDCB#;
    XUG_GetCmd.DCB2_Param# = OutDCB#;
    End;
 
  If Addr(F1) ~= Addr(Nil) Then XUG_GetCmd.F1_ = F1;
                           Else XUG_GetCmd.F1_ = Vector(Nil);
  If Addr(F2) ~= Addr(Nil) Then XUG_GetCmd.F2_ = F2;
                           Else XUG_GetCmd.F2_ = Vector(Nil);
  If Addr(F3) ~= Addr(Nil) Then XUG_GetCmd.F3_ = F3;
                           Else XUG_GetCmd.F3_ = Vector(Nil);
 
  If Addr(FlgLev) ~= Addr(Nil) Then
    XUG_GetCmd.FlgLev# = FlgLev;
  Else
    XUG_GetCmd.FlgLev# = 0;
 
  If (Addr(VFCtype) ~= Addr(Nil)) And (VFCtype = 0) Then
    XUG_GetCmd.ErrMsg_VFC# = %VFC_TRANSITION0;
  Else
    XUG_GetCmd.ErrMsg_VFC# = %VFC_TRANSITION1;
 
  Call XUG$ERRMSG (XUG_GetCmd) WhenReturn    Do;    Return; End;
                               WhenAltReturn Do; AltReturn; End;
 
  End YEM$ErrMsg;
/**/
%EOD;
/**/
/*  YEG$ERRCODE - return error code and/or DCB number from altret frame  */
 
YEG$ErrCode: Proc (ErrCode, DCB#);
 
%Include  CP_6;
 
  %B$TCB;
  %B$ALT;
 
/*
     Declarations
*/
 
  Dcl  ErrCode Bit(36);
  Dcl  DCB# UBin Unal;
 
  Dcl  B$TCB$ Ptr SymRef;
 
/*
     Begin YEG$ErrCode
*/
 
  If Addr (ErrCode) ~= Addr (Nil) Then
    ErrCode = B$TCB$->B$TCB.Alt$->B$Alt.Err;
 
  If Addr (DCB#) ~= Addr (Nil) Then
    DCB# = B$TCB$->B$TCB.Alt$->B$Alt.DCB#;
 
  Return;
 
  End YEG$ErrCode;
/**/
%EOD;
/**/
/*
     Name       : YMU$UNIQUE
 
     Purpose    : To return a 6-character string which is unique every time
                  the routine is called.
 
     Call       : (PL6)
                  CALL YMU$UNIQUE (UniqueName);
 
     Output     : UniqueName (character/6) -
                    String which contains the unique string.
 
     Description: The current UTS is treated as a 6-character string of 6-bit
                  characters.  The XLATE_6_TO_9 routine is used to translate
                  the UTS into a 6-character ASCII string, which, since the UTS
                  is unique, is also unique.
 
                                                                              */
 
YMU$Unique: Proc (UniqueName) NoAuto;
 
%Include  CP_6;
 
  %FPT_TIME (FPTN=GetUTS,
             SOURCE=CLOCK,
             DEST=UTS,
             TSTAMP=UTS);
 
/*
     Declarations
*/
 
  Dcl  UniqueName Char(6);
 
  Dcl  UTS Bit(36) WAligned;
  Dcl  TranslationTable Char(64) CONSTANT INIT(
          '$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz');
 
/*
     Begin YMU$UNIQUE
*/
 
  Call M$Time (GetUTS);
  Call XLate_6_To_9 (UniqueName, TranslationTable, UTS);
  Return;
  End YMU$Unique;
/**/
%EOD;
/**/
YXH$GoHome: Proc;
/*
   These are routines to provide X364 screen access:  Bold, Home, Normal
   There's also a routine that makes the terminal beep.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%FPT_WRITE( FPTN = WriteUC04,
             DCB = M$Com,
              BP = YES,
             BUF = ComLine2,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = Bell,
             DCB = M$Com,
           TRANS = YES,
             BUF = BEL,
         STCLASS = STATIC );
 
Dcl Bel Char(1) Static Unal Init(%BinAsc(7));
 
YXH$Home: Proc;
/*
      Bogus procedure to position to the input line in the UC03.
*/
 
   Call Concat( ComLine2, CSI, '2;1H', CSI, '0m', CSI, '2K' );
   Call Concat( ComLine2, Substr(ComLine2,0,14), CSI, '2;2H' );
   WriteUC04.Buf_.Bound = 19;
   Call M$Write( WriteUC04 ) Altret ( boom );
   Return;
 
boom:
   Return;
 
End YXH$Home;
 
/* Start YXH$GoHome */
   Call YXH$Home;
   Return;
 
YBB$Bell: Entry;
/*
      Send a transparent BEL character to M$Com
*/
 
   Call M$Write( Bell ) WhenAltReturn do; End;
   Return;
 
YXB$SetBold: Entry;
/*
      Set the input window to use bold type
*/
 
   Call YXH$Home;
   Call Concat( ComLine2, CSI, '2;1H', CSI, '1m', CSI, '2;2H' );
   WriteUC04.Buf_.Bound = 15;
   Call M$Write( WriteUC04 ) Altret ( boom );
   Return;
 
YXB$SetNorm: Entry;
/*
      Set the input window to use normal type
*/
 
   Call YXH$Home;
   Call Concat( ComLine2, CSI, '2;1H', CSI, '0m', CSI, '2;2H' );
   WriteUC04.Buf_.Bound = 15;
   Call M$Write( WriteUC04 ) Altret ( boom );
   Return;
 
YXB$ResetBold: Entry;
/*
      Turn off bold type for the input window  (do nothing for now)
*/
 
boom:
   Return;
 
End YXH$GoHome;
/**/
%EOD;
/**/
YII$IMP: Proc;
/*
   This procedure will check the profile, and then download the key
   definitions to the terminal found in the file for that kind of terminal.
*/
 
%Include CP_6;
%Include NK_VFC_C;
%Include B$JIT;
%Include XUG_ENTRY;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
/* ENTRY declarations for YE routines */
 
Dcl  YEM$ErrMsg Entry(8) AltRet;
Dcl  YEG$ErrCode Entry(2);
 
/* ENTRY declarations for YX routines */
 
Dcl YXH$GoHome Entry;
Dcl YXB$ResetBold Entry;
Dcl YXB$SetBold Entry;
Dcl YXB$SetNorm Entry;
Dcl YBB$Bell Entry;
Dcl YWS$DownString Entry(3);
Dcl YPT$WindowOptions Entry(1) AltRet;
 
/*
      Parser stuff
*/
 
%PARSE$OUT  ( NAME = OUT, STCLASS = "BASED(CMD$)" );
%PARSE$SYM  ( NAME = SYM, STCLASS = "BASED(CMD$)" );
 
Dcl CMD$ Ptr;
 
/*
      Command Variable stuff
*/
 
      %FPT_CMDVAR (FPTN=Fetch_StdAcct,
                   FUN=FETCH,
                   NAME=VarStdAcct,
                   VALUE=StdAcct);
 
        %VLP_NAME (FPTN=VarStdAcct,
                   NAME=%CmdVarStdAcct);
 
        %VLP_NAME (FPTN=StdAcct,
                   LEN=511);
 
      %FPT_CMDVAR (FPTN=Fetch_Prefix,
                   FUN=FETCH,
                   NAME=VarPrefix,
                   VALUE=Prefix);
 
        %VLP_NAME (FPTN=VarPrefix,
                   NAME=%CmdVarPrefix);
 
        %VLP_NAME (FPTN=Prefix,
                   LEN=511);
 
      %FPT_CMDVAR (FPTN=Fetch_ProAcct,
                   FUN=FETCH,
                   NAME=VarProAcct,
                   VALUE=ProAcct);
 
        %VLP_NAME (FPTN=VarProAcct,
                   NAME=%CmdVarProAcct);
 
        %VLP_NAME (FPTN=ProAcct,
                   LEN=511);
 
      %FPT_CMDVAR (FPTN=Fetch_ProName,
                   FUN=FETCH,
                   NAME=VarProName,
                   VALUE=ProName);
 
        %VLP_NAME (FPTN=VarProName,
                   NAME=%CmdVarProName);
 
        %VLP_NAME (FPTN=ProName,
                   LEN=511);
 
%FPT_OPEN ( FPTN = OpenIMP,    /* key definitions for the terminal */
             DCB = M$Imp,
             FUN = IN, SHARE = ALL,
             ASN = FILE,
             ACS = SEQUEN,
           SCRUB = YES,
            ACCT = ImpAcct,
            NAME = VLPName,
         STCLASS = STATIC );
 
%FPT_READ ( FPTN = ReadIMP,    /* Read from the IMP file */
             DCB = M$Imp,
             BUF = ImpBuf,
         STCLASS = STATIC );
 
%FPT_WRITE( FPTN = VTWriteUC02, /* Write IMPs to FEP */
             DCB = M$Edit,
             BUF = ImpBuf,
             VFC = YES,
           TRANS = YES,
         STCLASS = STATIC );
 
%FPT_CLOSE( FPTN = CloseIMP,   /* Close the IMP file */
         STCLASS = STATIC,
             DCB = M$Imp );
 
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
%VLP_NAME( FPTN = VLPName, LEN = 31 );
%VLP_ACCT( FPTN = ImpAcct );
%F$DCB;
Dcl B$JIT$ Ptr SymRef;
Dcl Profile Char( 12 );     /* name of terminal profile */
 
/*
   Internal procedures
*/
 
YPC$ParseContextRecord: Proc AltRet;
/*
      Procedure to check context record for valid Pulse commands
*/
 
   Xug_Imp.Text_ = Vector( Substr(ImpBuf,0,Minimum(300,M$Imp$ -> F$Dcb.Ars#)));
   Xug_Imp.Nodes$ = Addr( Context );
   Call Xug$GetCmd ( Xug_Imp ) AltRet ( boom );
   Cmd$ = Xug_Imp.Out$;
   Call YPT$WindowOptions( Cmd$ ) AltRet ( boom );
   Return;
 
boom:
   AltReturn;
 
End YPC$ParseContextRecord;
 
/**/
 
YIW$Write: Proc;
/*
      Procedure to write imps from M$Imp to Screen Edit window
*/
Do While %True;
   ImpBuf = ' ';
   Call M$Read( ReadIMP ) Altret ( Eof );
 
   If M$Imp$ -> F$Dcb.DVByte.VFC#
    Then do;
      If (Substr(ImpBuf,0,1) ~= %VFC_SLPP) and /* IMP record intro */
         (Substr(ImpBuf,0,1) ~= %VFC_ITB) and  /* set TABs */
         (Substr(ImpBuf,0,1) ~= %VFC_SPM)      /* TrmCtl, etc. */
       Then do;
         YYY_ErrCode.Err# = %E$BadImpRecord;
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
         Call YXB$ResetBold;
         Return;
       end;  /*  if bad VFC  */
 
      VTWriteUC02.Buf_.Bound = M$Imp$ -> F$Dcb.Ars# - 1;
      Call M$Write( VTWriteUC02 ) Altret ( boom );
    End;  /*  imp record  */
    Else
      Call YPC$ParseContextRecord
       WhenAltReturn do;
         YYY_ErrCode.Err# = %E$BadImpRecord;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
         Return;
       End;
 
End; /*  Do While  */
Eof:
   Return;
 
Boom:
   YYY_ErrCode.Err# = %E$BadIMPIntro;
   Call YXB$SetBold;
   Call YEM$ErrMsg( YYY_ErrCode,, DcbNum(M$Com),,,,2,0 );
   Call YXB$ResetBold;
   Return;
 
End YIW$Write;
 
/**/
 
YIS$Scan: Proc( Acct ) Altret;
/*
   Scan the search accounts.  Acct passes in an optional start account for
   the search.  Then, search logon accout, library account and the run unit
   account.  The VLP_Name is already set upon entry to YIS$Scan.
*/
%VLP_NAME( FPTN=Acct, STCLASS=PARAM );
 
   If Acct.L# > 0
    Then do;
      ImpAcct.Acct# = Substr( Acct.Name#,0,Acct.L# );
      Call M$Open( OpenImp )
       WhenReturn do;
         Goto WriteEm;
       End;
    End;  /*  if  */
 
   ImpAcct.Acct# = B$Jit.Accn;
   Call M$Open( OpenImp )
    WhenReturn do;
      Goto WriteEm;
    End;
 
   ImpAcct.Acct# = %ImpAcct#;
   Call M$Open( OpenImp )
    WhenReturn do;
      Goto WriteEm;
    End;
 
   ImpAcct.Acct# = M$LM$ -> F$Dcb.Acct#;
   Call M$Open( OpenImp ) Altret ( boom );
 
WriteEm:
   Call YIW$Write;
   Call M$Close( CloseImp ) Altret ( boom );
   Return;
 
boom:
   AltReturn;
 
End YIS$Scan;
 
/*
      Start YII$IMP
*/
 
   M$Imp$ = DcbAddr( DcbNum( M$Imp ) );
   M$LM$ = DcbAddr( DcbNum( M$LM ) );
   Call M$CmdVar (Fetch_Prefix)
    WhenReturn do;
      /* validate it, just in case */
      Xug_Imp.Nodes$ = Addr( PrefixNode );
      Xug_Imp.Text_ = Vector( Substr( Prefix.Name#,0,Prefix.L# ) );
      Call Xug$GetCmd ( Xug_Imp )
       WhenAltReturn do;
         Prefix.L# = 0;
         YYY_ErrCode.Err# = %E$BadCmdVarPrefix;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
         Return;
       End;
 
    End;  /*  When Return  */
    WhenAltReturn do;
      Prefix.L# = %Context_Intro_len;
      Prefix.Name# = %Context_Intro;
    End;
 
   Call M$CmdVar (Fetch_StdAcct)
    WhenReturn do;
      /* validate it, just in case */
      Xug_Imp.Nodes$ = Addr( AccountNode );
      Xug_Imp.Text_ = Vector( Substr( StdAcct.Name#,0,StdAcct.L# ) );
      Call Xug$GetCmd ( Xug_Imp )
       WhenAltReturn do;
         StdAcct.L# = 0;
         YYY_ErrCode.Err# = %E$BadCmdVarStd;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
         Return;
       End;
 
    End;  /*  When Return  */
    WhenAltReturn do;
      StdAcct.L# = 0;
    End;
 
   Call M$CmdVar (Fetch_ProName)
    WhenReturn Do;
      /* validate it, just in case */
      Xug_Imp.Nodes$ = Addr( FidNode );
      Xug_Imp.Text_ = Vector( Substr( ProName.Name#,0,ProName.L# ) );
      Call Xug$GetCmd ( Xug_Imp )
       WhenAltReturn do;
         ProName.L# = 0;
         YYY_ErrCode.Err# = %E$BadCmdVarName;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
         Return;
       End;
 
    End;
    WhenAltReturn do;
      ProName.L# = 0;
    End;
 
   Call M$CmdVar (Fetch_ProAcct)
    WhenReturn Do;
      /* validate it, just in case */
      Xug_Imp.Nodes$ = Addr( AccountNode );
      Xug_Imp.Text_ = Vector( Substr( ProAcct.Name#,0,ProAcct.L# ) );
      Call Xug$GetCmd ( Xug_Imp )
       WhenAltReturn do;
         ProAcct.L# = 0;
         YYY_ErrCode.Err# = %E$BadCmdVarPro;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
         Return;
       End;
 
    End;  /*  When Return  */
    WhenAltReturn do;
      ProAcct.L# = 0;
    End;
 
   Call Concat( VLPName.Name#, Substr(Prefix.Name#,0,Prefix.L#),
                %Context_Standard );
   VLPName.L# = Prefix.L# + %Context_STD_Len;
   Call YIS$Scan( StdAcct ) WhenAltReturn do; end;
 
   Profile = Substr( VLPLineAttr.ProTxtC.Txt, 0, VLPLineAttr.ProTxtC.Cnt );
   Call Concat( VLPName.Name#, Substr(Prefix.Name#,0,Prefix.L#), Profile );
   VLPName.L# = Prefix.L# + VLPLineAttr.ProTxtC.Cnt;
 
   If ProAcct.L# > 0
    Then do;
      ImpAcct.Acct# = Substr( ProAcct.Name#,0,ProAcct.L# );
      Call M$Open( OpenImp )
       WhenReturn do;
         Goto WriteEm2;
       End;
       WhenAltReturn do;
         Call Concat(VLPName.Name#, Substr(Prefix.Name#,0,Prefix.L#), %Context);
         VLPName.L# = Prefix.L# + %Context_Len;
         Call M$Open( OpenIMP )
          WhenReturn do;
            Goto WriteEm2;
          End;
       End;  /*  When Altret  */
 
    End;  /*  if  */
 
   ImpAcct.Acct# = B$Jit.Accn;
   Call Concat( VLPName.Name#, Substr(Prefix.Name#,0,Prefix.L#), Profile );
   VLPName.L# = Prefix.L# + VLPLineAttr.ProTxtC.Cnt;
   Call M$Open( OpenIMP )    /*  check user's account for profile  */
    WhenReturn do;
      Goto WriteEm2;
    End;
    WhenAltReturn do;
      Call Concat(VLPName.Name#,Substr(Prefix.Name#,0,Prefix.L#),%Context);
      VLPName.L# = Prefix.L# + %Context_len;
      Call M$Open( OpenIMP )
       WhenReturn do;
         Goto WriteEm2;
       End;
    End;  /*  When Altret  */
 
   ImpAcct.Acct# = %ImpAcct#;
   Call Concat( VLPName.Name#, Substr(Prefix.Name#,0,Prefix.L#), Profile );
   VLPName.L# = Prefix.L# + VLPLineAttr.ProTxtC.Cnt;
   Call M$Open( OpenIMP )
    WhenReturn do;
      Goto WriteEm2;
    End;
    WhenAltReturn do;
      Call Concat(VLPName.Name#,Substr(Prefix.Name#,0,Prefix.L#),%Context);
      VLPName.L# = Prefix.L# + %Context_Len;
      Call M$Open( OpenIMP )
       WhenReturn do;
         Goto WriteEm2;
       End;
    End;  /*  When Altret  */
 
   ImpAcct.Acct# = M$LM$ -> F$Dcb.Acct#;
   Call Concat( VLPName.NAME#, Substr(Prefix.Name#,0,Prefix.L#), Profile );
   VLPName.L# = Prefix.L# + VLPLineAttr.ProTxtC.Cnt;
   Call M$Open( OpenIMP )
    WhenReturn do;
      Goto WriteEm2;
    End;
    WhenAltReturn do;
      Call Concat(VLPName.Name#,Substr(Prefix.Name#,0,Prefix.L#),%Context);
      VLPName.L# = Prefix.L# + %Context_Len;
      Call M$Open( OpenIMP ) Altret ( Special );
    End;  /*  When Altret  */
 
WriteEm2:
   Call YIW$Write;
   Call M$Close( CloseIMP ) Altret ( boom );
 
Special:
   If ProName.L# > 0
    Then do;
      Call Concat(VLPName.Name#,Substr(Prefix.Name#,0,Prefix.L#),ProName.Name#);
      VLPName.L# = Prefix.L# + ProName.L#;
      Call YIS$Scan( ProAcct ) altret ( Fin );
    End;
Fin:
   Call YWS$DownString( StartUpLine, StartUp#, %E$BadStartStr );
   Return;
 
boom:
   Return;
 
End YII$IMP;
/**/
%EOD;
/**/
YPT$WindowOptions: Proc( Local$ ) AltRet;
/*
      Procedure to traverse the parse tree pointed to by Local$ and
      set the appropriate options
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl XTabsCommand Entry(1);
Dcl XTypeCommand Entry(1);
 
Dcl Local$ Ptr;
Dcl Wrap UBin Word WAligned;
 
%Parse$Out( NAME=OUT, STCLASS="BASED( Local$ )" );
%Parse$Sym( NAME=SYM, STCLASS="BASED( Local$ )" );
 
   YPT$DownString: Proc( WhichLine, Which# );
      Dcl WhichLine Char(512) Param;
      Dcl Which# UBin;
      Dcl I UBin;
 
      WhichLine = ' ';
      Which# = 0;
      Do I = 0 to Out.NSublks - 1;
       Do Case Out.Sublk$(I) -> Out.Code;
        Case( %NUL );
         /* NUL should have been 0, but it wasn't since the parser
            uses 0 for other things.  So, this is a separate case... */
         Call Insert( WhichLine, Which#, 1, BinAsc(0) );
         Which# = Which# + 1;
 
        Case( %SOH,%STX,%ETX,%EOT,%ENQ,%ACK,%BEL,%BS,%HT,%LF,%VT,
              %FF,%CR,%SO,%SI,%DLE,%DC1,%DC2,%DC3,%DC4,%NAK,%SYN,
              %ETB,%CAN,%EM,%SUB,%ESC,%FS,%GS,%RS,%US );
         Call Insert( WhichLine, Which#, 1, BinAsc(Out.Sublk$(I) -> Out.Code) );
         Which# = Which# + 1;
 
        Case( Else );  /* quoted string */
         Call Insert(WhichLine, Which#, Out.Sublk$(I)->Sym.Count,
                     Substr(Out.Sublk$(I)->Sym.Text,0,Out.Sublk$(I)->Sym.Count));
         Which# = Which# + Out.Sublk$(I)->Sym.Count;
 
       End;  /* case */
      End;  /* do I */
 
   End YPT$DownString;
 
  /**/
 
   Do Case Out.Code;
    Case( %Tabs );
      If Out.NSublks > 0
       Then  /* do nothing if it's a TABS command w/o any parameters */
         Call XTabsCommand( Local$ );
 
    Case( %Type );
      Call XTypeCommand( Local$ );
 
    Case( %WordWrap );
      Call CharBin(Wrap, Out.Sublk$( 0 ) -> Sym.Text);
      If Wrap > %BufSize-1 Then Wrap = %BufSize;
      VLPTrmCtl.WordWrapClm# = Wrap;
      Call M$STrmCtl( FPTTrmCtl ) Altret ( boom );
 
    Case( %OverStrike );
      VLPInsertMode.InsertMode# = '00'B;
      Call M$STrmCtl( FPTTrmCtlInsert ) Altret ( boom );
 
    Case( %Insert );
      VLPInsertMode.InsertMode# = '10'B;
      Call M$STrmCtl( FPTTrmCtlInsert ) Altret ( boom );
 
    Case( %HScroll );
      Call M$GTrmCtl( EditWindowSettings ) Altret ( boom );
 
      If Out.NSublks = 0
       Then
         VlpEditWindowSettings.HScroll# = '10'B;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            VlpEditWindowSettings.HScroll# = '10'B;
          Else
            VlpEditWindowSettings.HScroll# = '00'B;
 
      Call M$STrmCtl( EditWindowSettings ) Altret ( boom );
 
    Case( %Strip );
      If Out.NSublks = 0
       Then do;
         ReadUC02.V.DVByte.BP# = %False;
         StripFlag = %True;
       End;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then do;
            ReadUC02.V.DVByte.BP# = %False;
            StripFlag = %True;
          End;
          Else do;
            ReadUC02.V.DVByte.BP# = %True;
            StripFlag = %False;
          End;
 
    Case( %TextEdit );
      Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
 
      If Out.NSublks = 0
       Then
         VLPEditWindow2.TextEdit# = '10'B;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            VLPEditWindow2.TextEdit# = '10'B;
          Else
            VLPEditWindow2.TextEdit# = '00'B;
 
      Call M$STrmCtl( EditWindow2 ) Altret ( boom );
 
    Case( %EasyAppend );
      Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
 
      If Out.NSublks = 0
       Then
         VLPEditWindow2.EasyAppend# = '10'B;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            VLPEditWindow2.EasyAppend# = '10'B;
          Else
            VLPEditWindow2.EasyAppend# = '00'B;
 
      Call M$STrmCtl( EditWindow2 ) Altret ( boom );
 
    Case( %RcrWrap );
      Call M$GTrmCtl( EditWindow2 ) Altret ( boom );
 
      If Out.NSublks = 0
       Then
         VLPEditWindow2.RcrWrap# = '10'B;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            VLPEditWindow2.RcrWrap# = '10'B;
          Else
            VLPEditWindow2.RcrWrap# = '00'B;
 
      Call M$STrmCtl( EditWindow2 ) Altret ( boom );
 
    Case( %KeepNewMT );
      If Out.NSublks = 0
       Then
         KeepNewMT = %True;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            KeepNewMT = %True;
          Else
            KeepNewMT = %False;
 
    Case( %WorkAlways );
      If Out.NSublks = 0
       Then
         AlwaysUseWorkFlag = %True;
       Else
         If Out.Sublk$( 0 ) -> Out.Code = %Yes
          Then
            AlwaysUseWorkFlag = %True;
          Else
            AlwaysUseWorkFlag = %False;
 
    Case( %Rekey );
      MakeItKeyed = %True;
 
    Case( %StartUpSeq );
      Call YPT$DownString( StartUpLine, StartUp# );
 
    Case( %ExitSeq );
      Call YPT$DownString( ExitLine, Exit# );
 
    Case( %CmdOpen );
      Call YPT$DownString( CmdOpenLine, CmdOpen# );
 
    Case( %CmdClose );
      Call YPT$DownString( CmdCloseLine, CmdClose# );
 
    Case( Else );
 
   End;  /*  case  */
 
   Return;
 
boom:
   AltReturn;
 
End YPT$WindowOptions;
/**/
%EOD;
/**/
YWS$DownString: Proc( StringLine, String#, Err# );
/*
   Download the passed string to the terminal
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl  YEM$ErrMsg Entry(8) AltRet;
 
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
%FPT_WRITE( FPTN = VTWriteUC,
             DCB = M$UC,
             BUF = ImpBuf,
           TRANS = YES,
         STCLASS = STATIC );
 
Dcl StringLine Char(511) Param;
Dcl String# UBin Param;
Dcl Err# UBin Param;
 
If String# > 0
 Then do;
   ImpBuf = StringLine;
   VTWriteUC.Buf_.Bound = String# - 1;
   Call M$Write( VTWriteUC )
    WhenAltReturn do;
      YYY_ErrCode.Err# = Err#;
      Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
    End;
 End;
 
Return;
 
End YWS$DownString;
/**/
%EOD;
/**/
YPC$CheckProfile: Proc;
/*
      Check to see if this profile uses fields like TLV955 does
*/
 
%Include CP_6;
%Include KL_SUPER_C;        /*  Profile checking  */
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
/*  :PRO stuff  */
 
%FPT_OPEN( FPTN = OpenPro,
            DCB = M$Pro,
           NAME = PRO,
           ACCT = SYS,
            FUN = IN,
          SHARE = ALL,
        STCLASS = STATIC,
            ASN = FILE,
            ACS = DIRECT );
 
  %VLP_NAME(FPTN = PRO,
            NAME = ':PRO',
         STCLASS = STATIC );
 
  %VLP_ACCT(FPTN = SYS,
            ACCT = ':SYS',
         STCLASS = STATIC );
 
%FPT_CLOSE(FPTN = ClosePro,
            DCB = M$Pro,
        STCLASS = STATIC );
 
%FPT_READ( FPTN = ReadPro,
            DCB = M$Pro,
            BUF = Pro_Buf,
           KEYS = YES,
            KEY = ProKey,
        STCLASS = STATIC );
 
%F$DCB;
 
Dcl I SBin;
Dcl Pro_Buf Char(1024) Static;
Dcl TCChr$ Ptr;
Dcl PP$ Ptr;
Dcl PP_End$ Ptr;
Dcl PHdr$ Ptr;
Dcl PP_Type UBin Word;
Dcl PP_Size UBin Word;
 
Dcl 1 PP$Struct Based( PP$ ),
    2 Type UBin Byte Unal,
    2 Size UBin Byte Unal;
 
Dcl 1 ProKey Static,
    2 Len UBin Byte Unal,
    2 Key Char(11) Unal;
 
Dcl M$Pro Dcb;
Dcl M$Pro$ Ptr;
 
%KL_PHDR( NAME = Pro_Hdr,
       STCLASS = BASED );
 
%KL_CCHR( STCLASS = BASED );
 
/**/
 
ProKey.Key = VLPLineAttr.ProTxtC.Txt;
ProKey.Len = VLPLineAttr.ProTxtC.Cnt;
M$Pro$ = DcbAddr( DcbNum( M$Pro ) );
Call M$Open( OpenPro ) Altret ( boom );
Call M$Read( ReadPro ) Altret ( boom );
Call M$Close( ClosePro ) Altret ( boom );
 
PP$ = Addr( Pro_Buf );
PHdr$ = PP$;
PP_End$ = PIncrC( PP$, M$Pro$ -> F$Dcb.Ars# );
PP$ = PIncrC( PP$, SizeW( Pro_Hdr ) );
TCChr$ = Addr( Nil );
Do While (PP$ < PP_End$);
   PP_Type = PP$Struct.Type;
   PP_Size = PP$Struct.Size;
   PP$ = PIncrC( PP$, 2 );
   Do Case PP_Type;
    Case( %KL_PrmID_CtrChr );
      TCChr$ = PP$;
 
    Case( Else );
 
   End;  /*  case  */
 
   I = PP_Size + (Mod( PP_Size, 2 ));
   PP$ = PIncrC( PP$, I );
 
End;  /*  do while  */
 
If (TCChr$ ~= Addr( Nil )) and (TCChr$ -> KL_CChr.DclFld_Alg# = 2)
 Then
   FieldOrientedTerminal = %True;   /*  it's a QVT102 or TLV955 or somesuch  */
 Else
   FieldOrientedTerminal = %False;  /*  normal terminal  */
 
Return;
 
boom:
   Return;
 
End YPC$CheckProfile;
/**/
%EOD;
/**/
XTabsCommand: Proc( Local$ );
/*
      Parse and execute the TABS command
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XUF_ENTRY;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
/* ENTRY declarations for YE routines */
 
Dcl  YEM$ErrMsg Entry(8) AltRet;
Dcl  YEG$ErrCode Entry(2);
 
Dcl Local$ Ptr;
%Parse$Out( NAME=OUT, STCLASS="BASED( Local$ )" );
%Parse$Sym( NAME=SYM, STCLASS="BASED( Local$ )" );
 
%FPT_DEVICE(FPTN = TabSettings,
             DCB = M$Edit,
             HDR = EOF,
             TAB = VLP_TAB,
         STCLASS = STATIC );
 
%VLP_TAB( STCLASS = STATIC );
%VLP_TAB( FPTN = Tab, STCLASS = BASED );
%F$DCB;
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
 
Dcl I UBin;
Dcl J UBin;
Dcl Junk UBin;
Dcl NSublks UBin;
Dcl RestOfTabs(0:29) UBin(9) Unal;
Dcl NoTabsFormat Char(0) Constant Init('  Tabs:  None');
Dcl TabsFormat Char(0) Constant Init('  Tabs:  %D%N(,%0.9D%)%S    ');
 
/*  start procedure  */
 
M$Edit$ = DcbAddr( DcbNum( M$Edit ) );
M$UC$ = DcbAddr( DcbNum( M$UC ) );
If Out.NSublks = 0
 Then do;   /*  display tab settings  */
   If M$Edit$ -> F$Dcb.Tab$ ~= Addr( Nil )
    Then
      VLP_Tab = M$Edit$ -> F$Dcb.Tab$ -> Tab;
    Else
      If M$UC$ -> F$Dcb.Tab$ ~= Addr( Nil )
       Then
         VLP_Tab = M$UC$ -> F$Dcb.Tab$ -> Tab;
       Else do;
         Call X$Write( FDS, Vector( NoTabsFormat ) );
         Return;
       End;  /*  else  */
 
   If VLP_Tab.Tabs#(0) = 0
    Then
      Call X$Write( FDS, Vector( NoTabsFormat ) );
    Else do;
      Junk = VLP_Tab.Tabs#(0);
      Do I = 0 to 29;
        RestOfTabs( I ) = VLP_Tab.Tabs#( I + 1 );
      End;
 
      I = 0;
      Do While (VLP_Tab.Tabs#(I) ~= 0) and (I < 31);
        I = I + 1;
      End;
 
      I = I - 1;
 
      Call X$Write( FDS, Vector( TabsFormat ),
                         Vector( Junk ),
                         Vector( I ),
                         Vector( RestOfTabs ) );
 
    End;  /*  else do  */
 
 End;  /*  if display  */
 Else
   Do Case Out.Sublk$(0) -> Out.Code;
    Case( %None );
      VLP_Tab.Margin# = 0;
      Do I = 0 to 30;
        VLP_Tab.Tabs#( I ) = 0;
      End;  /*  do I  */
 
      Call M$Device( TabSettings ) Altret ( boom );
 
    Case( %Assembler );
      VLP_Tab.Margin#  =  0;
      VLP_Tab.Tabs#(0) =  8;
      VLP_Tab.Tabs#(1) = 16;
      VLP_Tab.Tabs#(2) = 32;
      Do I = 3 to 30;
        VLP_Tab.Tabs#( I ) = 0;
      End;  /*  do I  */
      Call M$Device( TabSettings ) Altret ( boom );
 
    Case( %Fortran );
      VLP_Tab.Margin#  =  0;
      VLP_Tab.Tabs#(0) =  7;
      VLP_Tab.Tabs#(1) = 16;
      VLP_Tab.Tabs#(2) = 34;
      Do I = 3 to 30;
        VLP_Tab.Tabs#( I ) = 0;
      End;  /*  do I  */
      Call M$Device( TabSettings ) Altret ( boom );
 
    Case( %Cobol );
      VLP_Tab.Margin#  =  0;
      VLP_Tab.Tabs#(0) =  8;
      VLP_Tab.Tabs#(1) = 12;
      VLP_Tab.Tabs#(2) = 36;
      Do I = 3 to 30;
        VLP_Tab.Tabs#( I ) = 0;
      End;  /*  do I  */
      Call M$Device( TabSettings ) Altret ( boom );
 
    Case( %Numbers );
/*
   initialize all the tabs (margin# will be set anyway, since
   we're doing this command in the first place).
*/
 
      Do I = 0 to 30;
        VLP_Tab.Tabs#(I) = 0;
      End;
 
      If (Out.Sublk$(0)->Out.NSublks > 32)
       Then do;
         YYY_ErrCode.Err# = %E$BadTabSpec;
         Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$Window ),,,,1 );
         Return;
       End;
 
      VLP_Tab.Margin#  =  0;
 
      Do I = 0 to Out.Sublk$(0) -> Out.NSublks - 1;
        Call CharBin( Junk, Out.Sublk$(0) -> Out.Sublk$( I ) -> Sym.Text );
        If (Junk = 0) and (Out.Sublk$(0) -> Out.NSublks > 1)
         Then do;
           YYY_ErrCode.Err# = %E$BadTabSpec;
           Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$Window ),,,,1 );
           Return;
         End;
 
        VLP_Tab.Tabs#( I ) = Junk;
 
      End;  /*  do I  */
 
/*  Sort the TAB entries  */
 
      NSublks = Out.Sublk$(0) -> Out.NSublks;
      Do I = 0 to NSublks - 2;  /* NSublks - 1 - 1 */
        Do J = I + 1 to NSublks - 1;
          If VLP_Tab.Tabs#( J ) < VLP_Tab.Tabs#( I )
           Then do;
             Junk = VLP_Tab.Tabs#( J );
             VLP_Tab.Tabs#( J ) = VLP_Tab.Tabs#( I );
             VLP_Tab.Tabs#( I ) = Junk;
           End;  /*  if  */
        End;  /*  do J  */
      End;  /*  do I  */
 
      Call M$Device( TabSettings ) Altret ( boom );
 
    Case ( Else );
 
   End;  /*  case  */
 
Return;
 
boom:
   Return;
 
End XTabsCommand;
/**/
%EOD;
/**/
XTypeCommand: Proc( Local$ );
/*
      Procedure to set the default file type for new files built by PULSE.
      The TYPE command will not effect blocks written by PULSE.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl Local$ Ptr;
%Parse$Out( NAME=OUT, STCLASS="BASED( Local$ )" );
%Parse$Sym( NAME=SYM, STCLASS="BASED( Local$ )" );
 
   EditNewFile.V.Type# = Substr(Out.Sublk$(0)->Sym.Text,0,
                                Out.Sublk$(0)->Sym.Count);
   Return;
 
End XTypeCommand;
/**/
%EOD;
/**/
YYY$MakeFid: Proc ( Fid, Blivit );
/*
      Take the info from Buffers.PrimaryFid and make a string in the
      variable Fid to identify this file.
*/
 
%Include B$TABLES_C;
 
%B$SR_Non_Blank;
 
Dcl Bound UBin;
Dcl Junk UBin;
Dcl Fid Char(60);
Dcl 1 Blivit,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
   If Substr(Blivit.Fid.Name#.C,0,1) = '*'
    Then
      Fid = Substr(Blivit.Fid.Name#.C,0,Blivit.Fid.Name#.L);
    Else
      If Blivit.PSN# = ' '
       Then
         Call Concat(Fid,Substr(Blivit.Fid.Name#.C,0,Blivit.Fid.Name#.L),'.',
                         Blivit.Fid.Acct#);
       Else Do;
         Call SearchR( Bound, junk, B$SR_Non_Blank, Blivit.PSN# );
         Call Concat(Fid,'DP#',Substr(Blivit.PSN#,0,Bound+1),'/',
                         Substr(Blivit.Fid.Name#.C,0,Blivit.Fid.Name#.L),
                         '.',Blivit.Fid.Acct#);
       End;
 
   Return;
 
End YYY$MakeFid;
/**/
%EOD;
/**/
YYY$FillIn:  Proc ( TFid );
/*
      Fill in a Fid structure from M$SI
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;  /* need proper def for M$SI$ */
 
%F$DCB;
 
Dcl 1 TFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
   TFid.Fid.SetX = M$SI$ -> F$Dcb.SetX;
   TFid.Fid.Name# = M$SI$ -> F$Dcb.Name#;
   If Substr(TFid.Fid.Name#.C,0,1) = '*'
    Then Do;
      TFid.PSN# = ' ';
      TFid.Fid.Acct# = ' ';
    End;
    Else Do;
      TFid.PSN# = M$SI$ -> F$Dcb.PSN#;
      TFid.Fid.Acct# = M$SI$ -> F$Dcb.Acct#;
    End;
 
   Return;
 
End YYY$FillIn;
/**/
%EOD;
/**/
SetArs: Proc;
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl  YEG$ErrCode Entry(2);
 
%F$DCB;
 
   SIARS# = M$SI$ -> F$Dcb.Ars#;
   Return;
 
/**/
 
SetErrCode: Entry;
 
   Call YEG$ErrCode( ErrCode );
   Return;
 
End SetArs;
/**/
%EOD;
/**/
YCF$CopyFile: Proc Altret;
/*
      Copy SI to OU
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl SetArs Entry;
 
   WriteOU.V.Seed# = ReadSI.V.Seed#;
   Do While %True;
     Call M$Read( ReadSI ) Altret ( eof );
     Call SetArs;
     If SIARS# > 0
      Then
        WriteOU.Buf_.bound = SIARS# - 1;
      Else do;
        WriteOU.Buf_.bound = 0;
        SILine = ' ';
      End;  /*  else  */
 
     OUKey = SIKey;
     Call M$Write( WriteOU ) Altret ( boom );
   End;  /*  do while true  */
eof:
   Return;
boom:
   AltReturn;
 
End YCF$CopyFile;
/**/
%EOD;
/**/
M$WriteUC03: Proc ( Field1, Field2, Field3 ) AltRet;
/*
      Procedure to write with the FPT to the status bar.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%F$Dcb;
 
Dcl Field1 Char(9);
Dcl Field2 Char(30);
Dcl Field3 Char(92);
Dcl Junk Char(9);
 
   If M$Com$ -> F$Dcb.Fcd#
    Then do;
      Call Concat( Junk, CSI, 'H', CSI, '7m', CSI );
      If FieldOrientedTerminal
       Then do;
         Call Concat( ComLine2, Junk, '1;2H', Field1, Field2, Field3 );
         WriteUC03Pos.Buf_.Bound = FidFieldWidth# + 51;  /*+ 40 + 13 - 2 */
       End;  /*  if  */
       Else do;
         Call Concat( ComLine2, Junk, '1;1H', Field1 );
         Call Concat( ComLine2, Substr( ComLine2,0,22), ' ', Field2, Field3 );
         WriteUC03Pos.Buf_.Bound = FidFieldWidth# + 52;  /*+ 40 + 13 - 1 */
       End;  /*  else  */
 
      Call M$Write( WriteUC03Pos ) Altret ( boom );
    End;  /* if */
    Else do;
      Call Concat( ComLine2,Field1,Field2,Field3 );
      WriteUC03Pos.V.Dcb# = M$UC#;
      Call M$Write( WriteUC03Pos ) Altret ( boom );
      WriteUC03Pos.V.Dcb# = M$Com#;
    End;  /* else */
 
   Return;
 
boom:
   AltReturn;
 
End M$WriteUC03;
/**/
%EOD;
/**/
YPN$PromptName: Proc (PrimaryFid) Altret;
/*
      Write the Name? prompt
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%F$Dcb;
 
Dcl YYY$MakeFid Entry(2);
Dcl M$WriteUC03 Entry(3) Altret;
Dcl YXH$GoHome Entry;
 
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
OutLine = 'Name?';
ComLine1 = ' ';
Call YYY$MakeFid( Fid, PrimaryFid );
Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
If M$Com$ -> F$Dcb.Fcd#
 Then
   Call YXH$GoHome;
 
Return;
 
boom:
AltReturn;
 
End YPN$PromptName;
/**/
%EOD;
/**/
CheckIfEmpty: Proc AltRet;
/*
      Check the KeepNewMT flag and delete the current file if it is empty.
      Return if not deleted.  AltReturn if deleted.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include B$TABLES_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl YEM$ErrMsg Entry(8) AltRet;
Dcl YYY$MakeFid Entry(2);
Dcl YXB$SetBold Entry;
Dcl YXB$ResetBold Entry;
Dcl AltRetError Entry;
 
%B$SR_Non_Blank;
%F$DCB;
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
 
Dcl 1 Fidd WAligned,
    2 Len UBin(9) CAligned,
    2 Name Char(63) CAligned;
 
Dcl Bound UBin;
Dcl Junk UBin;
 
   If Buffers# = 0
    Then
      Return;
 
   If (Not KeepNewMT) and Buffers.Status.NewFile( CurrentBuffer# ) and
      (M$SI$->F$Dcb.NRecs#=0)
    Then do;
      If Not Buffers.Status.DeleteWork( CurrentBuffer# )
       Then
         Return;
 
      If Buffers.SecondaryFid( CurrentBuffer# ) = ' '
       Then
         Call YYY$MakeFid( Fid, Buffers.PrimaryFid( CurrentBuffer# ) );
       Else
         Fid = Buffers.SecondaryFid( CurrentBuffer# );
 
      Call M$Fid( MakeFid ) Altret ( SourPMME );
      DeleteFid.V.ASN# = ASNJunk;
      If Buffers.Password#( CurrentBuffer# ) ~= ' '
       Then do;
         BabyFIT.Password# = Buffers.Password#( CurrentBuffer# );
         SetDCB.IFParam_ = Vector( BabyFIT );
         SetDCB.Pass_ = Vector( Nil );
         SetDCB.V.Dcb# = DcbNum( M$OU );
         Call M$Open( SetDCB ) AltRet ( SourPMME );
         SetDCB.V.Dcb# = DcbNum( M$SI );
       End;
 
      Call M$Open( DeleteFid ) Altret ( SourPMME );
      YYY_ErrCode.Err# = %E$DeletedEmpty;
      Call YYY$MakeFid( Fid, Buffers.PrimaryFid(CurrentBuffer#));/*it's right*/
      Fidd.Name = Fid;
      Call SearchR( Bound, junk, B$SR_Non_Blank, Fid, LengthC( Fid ) );
      Fidd.Len = Bound + 1;
      If Not Done
       Then do;  /* i.e. don't print this message if PULSE is exiting */
         Call YXB$SetBold;
         Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$Com ), Vector( Fidd ),,,1,0 );
         Call YXB$ResetBold;
       End;  /*  if not done, yet  */
 
      AltReturn;
    End;  /*  if it's a new file to be deleted  */
 
   Return;
 
SourPMME:
   Call AltRetError;
   Return;
 
End CheckIfEmpty;
/**/
%EOD;
/**/
PutAwayFiles: Proc;
/*
      Procedure to go through the active file list and close the entries
      appropriately.
*/
 
%Include CP_6;
%Include B_ERRORS_C;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl YDW$DeleteFile Entry(1) Altret;
Dcl CheckIfEmpty Entry Altret;
Dcl SqueezeBuffers Entry;
Dcl M$EraseEdit Entry Altret;
Dcl SaveFileQuery Entry(1) Altret;
Dcl SaveWorkFile Entry(5);
Dcl YEG$ErrCode Entry(2);
Dcl AltRetError Entry;
 
Dcl I SBin;
 
   If PutAwayDone
    Then
      Return;
 
   Call M$Close( CloseSI )
     WhenAltReturn do;
       Call YEG$ErrCode( ErrCode );
       If ErrCode.Err# ~= %E$DcbClosed
        then
          goto SourPMME;
     end; /* When Altret */
 
   Call CheckIfEmpty
    WhenAltReturn do;
      Call SqueezeBuffers;
    End;
 
   Do I = 0 to Buffers# - 1;
      Call M$EraseEdit WhenAltReturn do; end;
 
      If (Buffers.SecondaryFid( I ) ~= ' ') and
         (Not Buffers.Status.WorkMissing( I ) )
       Then
        If Buffers.Status.Changed( I )
         Then
          Call SaveFileQuery( I )
           WhenReturn do;
            Call SaveWorkFile( Buffers.PrimaryFid( I ),
                               Buffers.SecondaryFid( I ),
                               Buffers.Password#( I ),
                               Buffers.Status.DeleteWork( I ),
                               DcbNum( M$UC ) );
           End;
           WhenAltReturn do;
            If Buffers.Status.DeleteWork( I )
             Then do;
               Fid = Buffers.SecondaryFid(I);
               Call YDW$DeleteFile(Buffers.Password#(I)) altret (SourPMME);
             End;
           End;  /* Altret */
         Else
           If Buffers.Status.DeleteWork( I )
            Then do;
              Fid = Buffers.SecondaryFid(I);
              Call YDW$DeleteFile(Buffers.Password#(I)) altret ( SourPMME );
            End;
 
   End;  /*  do I  */
 
   PutAwayDone = %True;
   Return;
 
SourPMME:
   Call AltRetError;
   Return;
 
End PutAwayFiles;
/**/
%EOD;
/**/
AltRetError: Proc;
/*
      Procedure to do error handling.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include XUG_ENTRY;
%Include PULSE_C61;
%Include PULSE_C62;
 
/* ENTRY declarations for YE routines */
 
Dcl  YEM$ErrMsg Entry(8) AltRet;
Dcl  YEG$ErrCode Entry(2);
 
%F$DCB;
 
   If M$Edit$ -> F$Dcb.FCD#
    then
      Call M$Close( CloseUC05 ) WhenAltReturn do; end;
 
   Call Xug$Close_Dcbs( Xug_Close );
   If RestoreOK
    then
      Call M$STrmCtl( OriginalTerminalSettings ) WhenAltReturn do; end;
 
   Call YEG$ErrCode( ErrCode );
   Call YEM$ErrMsg( ErrCode,,,,,,4 );
 
   UnWind to WhereToGo;
 
End AltRetError;
/**/
%EOD;
/**/
M$EraseEdit: Proc AltRet;
/*
      Procedure to clear the SEAM (and shadow) cache
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
%F$DCB;
 
If Not M$Edit$ -> F$Dcb.Fcd#
 Then  /* if it's closed, don't do anything */
   Return;
 
Call M$Erase ( EraseEdit )
  WhenReturn Do;
    Call M$Device( FPTDeviceEdit )
      WhenAltReturn Do;
         AltReturn;
         End;
 
    LastCacheEntry = -1;
    EOFinFEP = %False;
    Return;
    End;
 
  WhenAltReturn Do;
    AltReturn;
    End;
 
End M$EraseEdit;
/**/
%EOD;
/**/
SaveFileQuery: Proc( WhichBuffer# ) Altret;
/*
      Function for yes or no
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%F$Dcb;
 
Dcl M$EraseEdit Entry Altret;
Dcl YYY$MakeFid Entry(2);
Dcl M$WriteUC03 Entry(3) Altret;
Dcl YXH$GoHome Entry;
Dcl AltRetError Entry;
 
Dcl WhichBuffer# SBin Param;
 
   Call M$EraseEdit WhenAltReturn do; end;
   OutLine = 'Save?';
   ComLine1 = '(Y or N)';
   Call YYY$MakeFid( Fid, Buffers.PrimaryFid( WhichBuffer# ) );
   Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( SourPMME );
 
TryAgain:
   If M$Com$ -> F$Dcb.Fcd#
    Then
      Call YXH$GoHome;
    Else
      ReadUC04.V.Dcb# = M$UC#;
 
   ComLine = ' ';
   Call M$Read( ReadUC04 ) Altret ( TryAgain );
   ReadUC04.V.Dcb# = M$Com#;
 
   If (ComLine = 'N') or (ComLine = 'n')
    Then
      AltReturn;
    Else
      If (ComLine = 'Y') or (ComLine = 'y')
       Then
         Return;
       Else
         Goto TryAgain;  /* didn't answer with a Y or N */
 
SourPMME:
   Call AltretError;
   Return;
 
End SaveFileQuery;
/**/
%EOD;
/**/
SqueezeBuffers: Proc;
/*
      Procedure to remove a deleted entry from the buffers list.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl I SBin;
 
   Buffers# = Buffers# - 1;
   Do I = CurrentBuffer# to Buffers# - 1;
      Seeds(I) = Seeds(I + 1);
      Buffers(I) = Buffers(I + 1);
   End;
 
   Return;
 
SpreadBuffers: Entry;
/*
   Open up a hole for a new buffer being inserted
*/
 
   Do I = (Buffers# - 1) downto CurrentBuffer#;
      Seeds(I + 1) = Seeds(I);
      Buffers(I + 1) = Buffers(I);
   End;
 
   Buffers# = Buffers# + 1;
   Buffers.Status.WorkMissing( CurrentBuffer# ) = %False;
 
   Return;
 
End SqueezeBuffers;
/**/
%EOD;
/**/
YCF$ClearFile: Proc altret;
/*
      Delete all current records in M$OU.
*/
 
%Include CP_6;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
   DelKeyStart.Len = 3;
   DelKeyStart.Key = 0;
   DelKeyEnd.Len = 3;
   DelKeyEnd.Key = %MaxSequenceNumber;
   DeleteSIRange.V.Dcb# = DcbNum( M$OU );
   Call M$DelRec( DeleteSIRange ) Altret ( boom );
   DeleteSIRange.V.Dcb# = DcbNum( M$SI );
   Return;
boom:
   AltReturn;
 
End YCF$ClearFile;
/**/
%EOD;
/**/
YSS$SetupForSave: Proc( PrimaryFid, SecondaryFid, Password#, Dcb# ) Altret;
/*
   Called by SaveWorkFile to do test, put M$SI in correct state, etc.
*/
 
%Include CP_6;
%Include CP_6_SUBS;
%Include B_ERRORS_C;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl YEM$ErrMsg Entry(8) AltRet;
 
Dcl YYY$MakeFid Entry(2);
Dcl YEG$ErrCode Entry(2);
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl SecondaryFid Char(8) Param;
Dcl Password# Char(8) Param;
Dcl Dcb# UBin Param;
 
CloseSI.V.Oper.ChgAtt# = '0'B;
Call M$Close( CloseSI ) WhenAltReturn do; end;
Call YYY$MakeFid( Fid, PrimaryFid );
Call M$Fid( MakeFidBack ) Altret ( boom );
Fid = SecondaryFid;
Call M$Fid( MakeFid ) Altret ( boom );
SetDCB.V.ASN# = ASNJunk;
If Password# ~= ' '
 Then do;
   BabyFIT.Password# = Password#;
   SetDCB.IFParam_ = Vector( BabyFIT );
 End;
 Else
   SetDCB.IFParam_ = Vector( NIL );
 
SetDCB.Pass_ = Vector( NIL );
Call M$Open( SetDCB ) Altret ( boom );
SetDCB.Pass_ = Vector( VLPSIPass );
SetDCB.IFParam_ = Vector( NIL );
EditOldFile.V.Fun# = %Update#;  /*  make sure we'll be able to change name  */
Call M$Open( EditOldFile )      /*  if necessary.  */
 WhenAltReturn do;
   Call YEG$ErrCode( ErrCode );
   If ErrCode.Err# = %E$NoFile
    Then do;
      YYY_ErrCode.Err# = %E$MissingWorkFile;
      If Dcb# = DcbNum( M$Window )
       Then
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2 );
       Else
         Call YEM$ErrMsg( YYY_ErrCode,, Dcb#,,,,2,0 );
 
      Goto UhOh2;
    End;
    Else
      Goto boom;
 
 End;  /*  When Altret  */
 
Return;
boom:
   AltReturn;
 
UhOh2:
   VLPGrow.Length# = %Window_AbsVal# + 1;
   Call M$STrmCtl( FPTGrow ) WhenAltReturn do; end;
   Done = %False;        /*  not done yet....  */
   UnWind to NewCommand;
 
End YSS$SetupForSave;
/**/
%EOD;
/**/
SaveWorkFile: Proc( PrimaryFid, SecondaryFid, Password#, DeleteFlag, Dcb# );
/*
      Procedure to save the current work file over a file
*/
 
%Include CP_6;
%Include CP_6_SUBS;
%Include B_ERRORS_C;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include XUF_ENTRY;
%Include B$TABLES_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
%B$SR_Non_Blank;
%F$DCB;
%F_FDS ( NAME = FDS4,
          DCB = M$UC,
          BUF = FmtBuf,
      STCLASS = STATIC );
 
Dcl YCF$ClearFile Entry Altret;
Dcl YCF$CopyFile Entry Altret;
Dcl YSS$SetupForSave Entry(4) Altret;
Dcl YPN$PromptName Entry(1) Altret;
Dcl YYY$MakeFid Entry(2);
Dcl YYY$FillIn Entry(1);
Dcl OverWriteInquireAndSetup Entry(2) Altret;
Dcl YEM$ErrMsg Entry(8) AltRet;
Dcl YEG$ErrCode Entry(2);
Dcl YXB$SetBold Entry;
Dcl YXB$ResetBold Entry;
Dcl AltRetError Entry;
 
Dcl Label UBin;
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
Dcl PleaseWait2Format Char(0) Constant
                      Init('** Saving workfile.  Please wait.');
Dcl SecondaryFid Char(8) Param;
Dcl Password# Char(8) Param;
Dcl DeleteFlag Bit(1) Param;
Dcl Dcb# UBin Param;
Dcl Original Bit(1) Static Unal;
Dcl Bound UBin;
Dcl junk UBin;
Dcl ComLineWas Char(255) Unal;
Dcl UpAttr Bit(18) Static HAligned;
 
/*  start  */
 
Start:
 
Label = 0;
Original = %False;
 
Call YSS$SetupForSave(PrimaryFid,SecondaryFid,Password#,Dcb#) altret ( boom );
 
Mode = %WorkFile;
Call YPN$PromptName( PrimaryFid ) Altret ( boom );
Call YYY$MakeFid( ComLine, PrimaryFid );
ComLineWas = ComLine;
Call SearchR( Bound, junk, B$SR_Non_Blank, ComLine )
 WhenReturn do;
   SInputUC03.Buf_.Bound = Bound;
   If Not M$Com$ -> F$Dcb.Fcd#
    Then
      SInputUC03.V.Dcb# = M$UC#;
 
   Call M$SInput( SInputUC03 ) Altret ( boom );
   SInputUC03.V.Dcb# = M$Com#;
 End;
 WhenAltReturn do;
 End;
 
ComLine = ' ';
If Not M$Com$ -> F$Dcb.Fcd#
 Then
   ReadUC04.V.Dcb# = M$UC#;
 
Call M$Read( ReadUC04 ) Altret ( UhOh );
ReadUC04.V.Dcb# = M$Com#;
If (ComLine = ' ') or (M$Com$ -> F$Dcb.Ars# = 0) or (ComLine = ComLineWas)
  Then do;
      Original = %True;
      Call YYY$MakeFid( Fid, PrimaryFid );
      Call M$Fid( MakeFid ) Altret ( boom );
      OpenOU.V.Exist# = %NewFile#;
      OpenOU.V.ASN# = ASNJunk;
  end;  /*  if default  */
  else do;  /*  get new file name  */
      Fid = ComLine;
      OpenOU.V.Exist# = %ERROR#;
      Call M$Fid( MakeFid )
        WhenReturn do;
         If (Substr( RESJunk,0,1 ) ~= BinAsc(0)) /*  valid file name?  */
            and (Substr( RESJunk,0,2 ) ~= 'DP')
          Then do;
            YYY_ErrCode.Err# = %E$BadFileName;
            Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$UC ),,,,2 );
            Goto Start;
          End;  /*  if  */
        End;  /*  When Return  */
        WhenAltReturn do;
         Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
         Goto Start;
        End;
 
  end;  /*  else  */
 
If (Substr( VLPSIName.Name#,0,1 ) = '*') and (VLPSIName ~= VLPSINameBack)
   and DeleteFlag
 Then do;                                 /*  then just rename  */
  CloseSI.V.Oper.ChgAtt# = '1'B;
  CloseSI.Name_ = Vector( VLPSIName );
  CloseSI.Pass_ = Vector( VLPSIPass );
  Call M$Close( CloseSI )
    WhenAltReturn do;
      CloseSI.V.Oper.ChgAtt# = '0'B;
      Call YEG$ErrCode( ErrCode );
      If ErrCode.Err# ~= %E$BadFNme
       then do;
         Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
         Goto Start;
       End;
 
      Call M$Open( EditOldFile ) Altret ( boom );  /*  re-open file  */
      Call OverWriteInquireAndSetUp( Label, PrimaryFid ) Altret ( boom );
      Do Case Label;
       Case( 1 );
         Goto Fin;
       Case( 2 );
         Goto Start;
       Case( 3 );
         Goto UhOh;
      End;  /*  case  */
 
      Call M$PFil( PosBOF ) Altret ( boom );
      Goto WriteOut;
    end;  /*  Altret  */
 
  Call YYY$FillIn( PrimaryFid );
  PrimaryFid.Fid.Name# = VLPSIName;  /* just in case */
  SecondaryFid = ' ';
 
  CloseSI.V.Oper.ChgAtt# = '0'B;
  OpenOU.V.Exist# = %NewFile#;  /*  restore to original setting  */
  Return;
 
 End;  /*  if just a rename  */
 Else do;
  Call M$PFil( PosBOF ) Altret ( boom );
  If (VLPSIPass.Pass# ~= ' ') or (Fid ~= ComLineWas)
   Then
     OpenOU.Pass_ = Vector( VLPSIPass );
   Else
     OpenOU.Pass_ = Vector( NIL );
 
  OpenOU.V.Oper.Test# = %True;  /* make sure we can replace the file */
  OpenOU.V.Fun# = %Create#;
  Call M$Open( OpenOU )
   WhenAltReturn do;
     Call M$Unfid( GetOUFid ) Altret ( boom );
     If Fid = ComLineWas
      Then
        Original = %True;
 
     If Original
      Then do;
        OpenOU.V.Fun# = %Update#;
        Call M$Open( OpenOU )
         WhenReturn do;
           UpAttr = (%FFlg_DelR# | %FFlg_WNew#);
           If ((UpAttr & M$OU$ -> F$Dcb.FFlg) ~= UpAttr)
            Then do;
              YYY_ErrCode.Err# = %E$CantSaveThere;
              Call YEM$ErrMsg( YYY_ErrCode,, DcbNum( M$UC ),,,,2 );
              OpenOU.V.Oper.Test# = %False;
              OpenOU.V.Fun# = %Create#;
              Goto Start;
            End;  /*  if can't rewrite file  */
 
           OpenOU.V.Fun# = %Update#;
         End;
         WhenAltReturn do;
           Call YEG$ErrCode( ErrCode );
           If ErrCode.Err# ~= %E$NoFile
            Then do;
              Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
              OpenOU.V.Oper.Test# = %False;
              OpenOU.V.Fun# = %Create#;
              Goto Start;
            End;  /*  if  */
 
           OpenOU.V.Fun# = %Create#;
         End;   /*  When Altret  */
      End;  /*  if original  */
   End;  /*  When Altret  */
 
  OpenOU.V.Oper.Test# = %False;  /* restore it */
 
  Call M$Open( OpenOU )
   WhenReturn do;
      If OpenOU.V.Fun# = %Update#
       Then   /* this means we're clearing out old recs, and writing new */
         Call YCF$ClearFile altret ( boom );
 
   End;  /*  When Return  */
   WhenAltReturn do;
      Call YEG$ErrCode( ErrCode );
      If ErrCode.Err# ~= %E$CreatErr
       then do;
         Call YEM$ErrMsg( ,, DcbNum( M$UC ),,,,2 );
         Goto Start;
       End;
 
      Call OverWriteInquireAndSetUp( Label, PrimaryFid ) Altret ( boom );
      Do Case Label;
       Case( 1 );
         Goto Fin;
       Case( 2 );
         Goto Start;
       Case( 3 );
         Goto UhOh;
      End;  /*  case  */
 
   End;  /* Altret */
 End;  /*  else  */
 
WriteOut:
  If M$Com$ -> F$Dcb.Fcd#
   Then do;
     Call YXB$SetBold;
     Call X$Write( FDS2, Vector( PleaseWait2Format ) );
     Call YXB$ResetBold;
   End;
   Else
     Call X$Write( FDS4, Vector( PleaseWait2Format ) );
 
  Call YCF$CopyFile altret ( boom );
 
  If M$OU$->F$Dcb.Pass# ~= ' '
   Then  /* in case it changed */
     Password# = M$OU$->F$Dcb.Pass#;
   Else
     Password# = ' ';
 
  Call M$Close( CloseOU ) Altret ( boom );
  Call M$Unfid( GetOUFid ) Altret ( boom );
 
fin:
If DeleteFlag and (Label ~= 1)
 Then
   Call M$Close( CloseSIDelete ) Altret ( boom );
 else
   Call M$Close( CloseSI ) Altret ( boom );
 
OpenOU.V.Exist# = %NewFile#;  /*  restore to original setting  */
OpenOU.Pass_ = Vector( NIL );
WriteOU.V.Seed# = '0'B;
If Label ~= 1
 Then do;
   PrimaryFid.Fid.Name# = M$OU$ -> F$Dcb.Name#;
   PrimaryFid.Fid.SetX = M$OU$ -> F$Dcb.SetX;
   If Substr(PrimaryFid.Fid.Name#.C,0,1) = '*'
    Then do;
      PrimaryFid.Fid.Acct# = ' ';
      PrimaryFid.PSN# = ' ';
    End;
    Else do;
      PrimaryFid.Fid.Acct# = M$OU$ -> F$Dcb.Acct#;
      PrimaryFid.PSN# = M$OU$ -> F$Dcb.PSN#;
    End;
 
   SecondaryFid = ' ';
 End;  /*  if  */
 
Return;
 
UhOh:
      Call YEM$ErrMsg( ErrCode, DcbNum( M$OU ), DcbNum( M$UC ),,,,2 );
UhOh2:
      VLPGrow.Length# = %Window_AbsVal# + 1;
      Call M$STrmCtl( FPTGrow )
         WhenAltReturn do; end;
 
      Done = %False;        /*  not done yet....  */
      OpenOU.Pass_ = Vector( NIL );
      UnWind to NewCommand;
 
boom:
      Call AltretError;
      Return;
 
End SaveWorkFile;
/**/
%EOD;
/**/
OverWriteInquireAndSetup: Proc( Label, PrimaryFid ) Altret;
/*
   Ask the user if he wants to overwrite an existing file and setup to
   do just that if he's of a mind to.
*/
 
%Include CP_6;
%Include CP_6_SUBS;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
%F$Dcb;
 
Dcl M$WriteUC03 Entry(3) Altret;
Dcl YXH$GoHome Entry;
 
Dcl Label UBin;
Dcl 1 PrimaryFid,
    2 Fid,
      3 SetX UBin(18) CAligned,
      3 Name#,
        4 L Ubin(9) Unal,
        4 C Char(31) CAligned,
      3 Acct# Char(8) CAligned,
    2 PSN# Char(6) CAligned;
 
      Label = 0;
      OutLine = ' ';
      ComLine1 = 'Fid exists. Overwrite?(Y,N,Q)';
      Fid = ' ';
      Call M$WriteUC03( OutLine, ComLine1, Fid ) Altret ( boom );
 
Fool:
      If M$Com$ -> F$Dcb.Fcd#
       Then
         Call YXH$GoHome;
       Else
         ReadUC04.V.Dcb# = M$UC#;
 
      ComLine = ' ';
      Call M$Read( ReadUC04 ) Altret ( Fool );
      ComChar = Substr( ComLine,0,1 );
      ReadUC04.V.Dcb# = M$Com#;
 
      If (ComChar ~= 'Y') and (ComChar ~= 'y') then
         If (ComChar = 'Q') or (ComChar = 'q') then
           Label = 1;
         else
           Label = 2;
 
      Else do;
         Label = 0;
         OpenOU.V.Exist# = %NEWFILE#;
         Call M$Open( OpenOU ) Altret ( UhOh );
      end;  /*  else  */
 
      Return;
 
UhOh:
      Label = 3;
      Return;
 
Boom:
      AltReturn;
 
End OverWriteInquireAndSetup;
/**/
%EOD;
/**/
YSC$SaveContext: Proc AltRet;
/*
   Actually save the current context to the file specified in global Fid
*/
%Include CP_6;
%Include B$TABLES_C;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl YYY$MakeFid Entry(2);
Dcl YEM$ErrMsg Entry(8) AltRet;
Dcl AltretError Entry;
 
%VLP_ERRCODE(FPTN=YYY_ErrCode,FCG=YY,MID=Y,SEV=0,MON='0'B);
%B$SR_Non_Blank;
%F$Dcb;
 
Dcl I UBin;
Dcl Bound UBin Static;
Dcl junk UBin Static;
Dcl Started Bit(1) Unal;
Dcl 1 FileName WAligned,
    2 Len UBin(9) CAligned,
    2 Name Char(60) CAligned;
 
Call M$Fid( MakeContextFid ) Altret ( PrintError );
Call M$Open( OpenContext ) Altret ( PrintError );
 
/*
   Handle the existence of work files
*/
 
Started = %False;
Do I = 0 to Buffers# - 1;
   If Buffers.SecondaryFid(I) ~= ' '
    Then do;
      If (Not Started) and Buffers.Status.Changed(I)
       Then do;
         YYY_ErrCode.Err# = %E$CantSaveWorkFiles;
         Call YEM$ErrMsg( YYY_ErrCode,,DcbNum( M$Window ),,,,1 );
         Started = %True;
       End;
 
      If Buffers.Status.Changed(I)
       Then do;
         YYY_ErrCode.Err# = %E$CantSaveFileName;
         Call YYY$MakeFid( FileName.Name, Buffers.PrimaryFid( I ) );
         Call SearchR (Bound, junk, B$SR_Non_Blank,
                            SubStr(FileName.Name, 0, LengthC(FileName.Name) ) );
         FileName.Len = Bound + 1;
         Call YEM$ErrMsg( YYY_ErrCode,,DcbNum(M$Window), Vector(FileName),,,1 );
       End;
 
      Buffers.Status.DeleteWork(I) = %False;/* if there's a workfile, save it */
    End;  /*  If  */
End;  /*  do I  */
 
WriteContext.Buf_ = Vector( Version );
Call M$Write( WriteContext ) Altret ( boom );
WriteContext.Buf_ = Vector( CurrentPages# );
Call M$Write( WriteContext ) Altret ( boom );
WriteContext.Buf_ = Vector( CurrentBuffer# );
Call M$Write( WriteContext ) Altret ( boom );
WriteContext.Buf_.Bound = LengthC( Buffers(0) ) * Buffers# - 1;
WriteContext.Buf_.Buf$ = Buffers$;
Call M$Write( WriteContext ) Altret ( boom );
 
SpecialContext.Flags.KeepNewMT = KeepNewMT;
SpecialContext.Flags.AlwaysUseWork = AlwaysUseWorkFlag;
SpecialContext.SavedSize = SavedSize;
SpecialContext.FindWord = FindWord;
SpecialContext.Replacement = Replacement;
SpecialContext.LastOperation = LastOperation;
SpecialContext.Direction = ForwardSearch;
SpecialContext.Type = EditNewFile.V.Type#;
Do Case LastOperation;
   Case( %Find );
     SpecialContext.Options = FinOps;
   Case( %Replace );
     SpecialContext.Options = RepOps;
   Case( Else );
     SpecialContext.Options = ' ';
End;  /*  case  */
 
WriteContext.Buf_ = Vector( SpecialContext );
Call M$Write( WriteContext ) Altret ( boom );
 
If SAndMFid.Name# ~= ' '
 Then do;
   StarUnique = SAndMFid;
   Call M$Open( OpenStarUniqueIn ) Altret ( boom );
   WriteContext.Buf_ = Vector( UniqueLine );
   Do While %True;
    Call M$Read( ReadStarUnique ) Altret ( done );
    WriteContext.Buf_.Bound = M$Block$ -> F$Dcb.ARs# - 1;
    Call M$Write( WriteContext ) Altret ( PrintError );
   End;
done:
   Call M$Close( CloseStarUnique ) Altret ( PrintError );
 
 End;  /*  if there's an SAndM buffer  */
 
Call M$Close( CloseOU ) Altret ( boom );
 
Return;
 
boom:
   Call AltRetError;
   Return;
 
PrintError:
   AltReturn;
 
End YSC$SaveContext;
/**/
%EOD;
/**/
YDW$DeleteFile: Proc( Pass# ) Altret;
/*
   Delete the work file copy of Which
*/
 
%Include CP_6;
%Include B$TABLES_C;
%Include XU_MACRO_C;
%Include XU_FORMAT_C;
%Include PULSE_C61;
%Include PULSE_C62;
 
Dcl Pass# Char(8) Param;
 
   Call M$Fid( MakeFid ) Altret ( boom );
   DeleteFid.V.ASN# = ASNJunk;
   If Pass# ~= ' '
    Then do;
      BabyFIT.Password# = Pass#;
      SetDCB.IFParam_ = Vector( BabyFIT );
      SetDCB.Pass_ = Vector( Nil );
      SetDCB.V.Dcb# = DcbNum( M$OU );
      Call M$Open( SetDCB ) AltRet ( boom );
      SetDCB.V.Dcb# = DcbNum( M$SI );
    End;
 
   Call M$Open( DeleteFid ) Altret ( boom );
   Return;
 
boom:
   AltReturn;
 
End YDW$DeleteFile;
/**/
