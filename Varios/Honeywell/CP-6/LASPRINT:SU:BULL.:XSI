C LASPRINT:SU  21-JAN-1986  M SHUMAKER  SCIENTIFIC COMPUTER SERVICES  PLANT 31
C
C
C TO TRANSLATE LINE PRINTER STUFF TO NATIVE-MODE POSTSCRIPT
C SEE LASPRINT:TX FOR USER INSTRUCTIONS
C
C TO ADD AN OPTION, IDENTIFY THE AREA IN WHICH IT SHOULD APPEAR.
C PLACE THE THREE-CHARACTER NAME IN THAT AREA AND UPDATE "NOPTS",
C "NCLONLY", "NXTO", "NRLO", AND "NINFONLY" PARAMETERS AS
C REQUIRED.  UPDATE ALL "IF (J.EQ.n)" STATEMENTS DOWNSTREAM FROM
C THE NEW OPTION IN BOTH THE COMMAND LINE AND IN-FILE OPTION CODE.
C
C IF A TEXT RESPONSE IS EXPECTED, CREATE AN ARRAY OF VALID TEXT
C ENTRIES USING A VARIANT OF THE OPTION NAME ENDING IN "TX" AND
C A PARAMETER DEFINING THE NUMBER OF VALID TEXT ENTRIES USING
C A VARIANT OF THE OPTION NAME BEGINNING WITH "N" (E.G.:  JUS,
C NJUS, JUSTX).
C
C IF A REAL NUMERIC RESPONSE IS EXPECTED, ADD TO THE "VALS"
C ARRAY, DEFINE A NAME FOR THE VARIABLE, AND EQUIVALENCE
C IT TO THE NEW ARRAY ELEMENT.  EXPAND THE "VMAX" AND
C "VMIN" ARRAYS FOR MAXIMUM AND MINIMUM VALUES.
C
      EXTERNAL UCASE
      IMPLICIT INTEGER (A-T)
      INTEGER XF, X70, XFON, UIN1, UIN2, UOUT, ULINE
C
C PARAMETERS:
C
C NUMBERS OF VALID ENTRIES FOR SPECIFIC OPTIONS
      PARAMETER (NPFORS=2, NBANS=2, NINCL=1, NJUS=3, NULS=2, NXVFCS=2)
      PARAMETER (MAXBOR=10)
      PARAMETER (NVFCS=10)
C COMMAND NAME LIST DEFINITIONS AND CALCULATED VALUES
      PARAMETER (NOPTS=27, NTXO=13, NCLONLY=4, NRLO=6, NINFONLY=8)
      PARAMETER (NCLINEOPTS=NOPTS-NINFONLY, NLROPTS=NTXO+NRLO)
C MISC FACTORS
      PARAMETER (NFIDS=8, NFIDSM=NFIDS-1, NSCAN=3, UIN1=51)
      PARAMETER (ME=108, MEIN=105)
C USED IN SUBROUTINES AS WELL
      PARAMETER (NSHW=3)
      PARAMETER (NFONTS=35, N2665FS=13, NPAPS=5)
C
      REAL CPI, LPI, HML, SIZLN, SIZCHR, PHT, PWD, SAVBF, HMLBAN
      REAL CHARSIZ, FONTFAM, LINES, PSIZ
      LOGICAL OVSTRK, OPTS, FPAGE, CPP, PSCIF, PSCCL, BADI, GOODO, LDV
      LOGICAL TOF, BANN, SETPOS, PAGNUM, OLAYS, MORE, NUFONT, TXTOK
      LOGICAL NUMBRS, TRANS, ROMAN, OVL1, OVL2, END, NOVAL, FSHOWP
      LOGICAL RESTORE, NOEQ, PARN, DEFCHT, NOCONT, TRNFID
      LOGICAL NOTOP(MAXBOR), NOBOT(MAXBOR)
      LOGICAL TEXTED
      CHARACTER*1 NUL, BS, FF, CR, EOMCHAR
      CHARACTER*1 ROTATE, CHR, FOR, XFOR, BAN, PSC, CURVAL, VFC(NFIDS)
      CHARACTER*1 TRNCHR
      CHARACTER*1 JUSTX(NJUS) /'C', 'L', 'R'/
      CHARACTER*1 VFCTX(NVFCS)/'V', 'F', 'S', 'X', 'T',
     &                         'v', 'f', 's', 'x', 't'/
      CHARACTER*1 UVFCTX(NVFCS)/'V', 'F', 'S', 'X', 'T',
     &                          'V', 'F', 'S', 'X', 'T'/
      CHARACTER*1 XVFCTX(NXVFCS) /'T', 't'/
      CHARACTER*1 FORXX(NPFORS) /'P', 'L'/
      CHARACTER*1 BANTX(NBANS) /'B', 'F'/
      CHARACTER*1 PAPTX(NPAPS) /'1', '2', 'B', 'P', 'G'/
      CHARACTER*1 SCANTX(NSCAN) /'\', '(', ')'/
      CHARACTER*1 DEVLDX(7)
      CHARACTER*1 DLM(0:NFIDSM) /NFIDS*' '/
      CHARACTER*1 STAB(0:511), NBTAB(0:511)
      CHARACTER*2 ULINETX(NULS) /'OF', 'ON'/
      CHARACTER*3 UCASE, FNT, CUROPT, ULOPT
      CHARACTER*3 OPT(NOPTS) /
C [A] COMMAND-LINE-ONLY, TEXT RESPONSE (NCLONLY A TO B, NTXO A TO C, NOPTS A TO END)
     1  'PAP',
     2  'OVL',
     3  'BAN',
     4  'COP',
C [B] COMMAND-LINE AND IN-FILE, TEXT RESPONSE
     5  'PSC',
     6  'FOR',
     7  'NUM',
     8  'TRA',
     9  'FON',
     A  'NSC',
     1  'PEN',
     2  'JUS',
     3  'UND',
C [C] COMMAND-LINE AND IN-FILE, REAL NUMERIC RESPONSE (NRLO C TO D)
     4  'CPI',
     5  'HML',
     6  'LPI',
     7  'VMB',
     8  'VMT',
     9  'CHA',
C [D] IN-FILE ONLY, INTEGER NUMERIC RESPONSE (NINFONLY D TO END)
     A  'LIN',
     1  'PGN',
     2  'IGN',
C IN-FILE ONLY, TEXT RESPONSE (MAY BE DECODED FOR NUMERICS)
     3  'SAV',
     4  'SET',
     5  'SCA',
     6  'INC',
     7  'BOR'/
C
      CHARACTER*3 FNTX(NFONTS) /'SYM'
     &  ,'COU', 'CBO', 'CIT', 'CBI'
     &  ,'TIM', 'TBO', 'TIT', 'TBI'
     &  ,'HEL', 'HBO', 'HIT', 'HBI'
     &  ,'AGB', 'AGD', 'ABI', 'ADI'
     &  ,'BLT', 'BDE', 'BLI', 'BDI'
     &  ,'NAR', 'NIT', 'NBO', 'NBI'
     &  ,'PRO', 'PIT', 'PBO', 'PBI'
     &  ,'SRO', 'SIT', 'SBO', 'SBI'
     &  ,'ZCH', 'DNG'/
      CHARACTER*3 INCTX(NINCL) /'CAL'/
      CHARACTER*4 TTABLE(32:126)
      CHARACTER*4 TTABLEX(32:126) /
     &  '\040', '\161', '\162', '\163', '\164', '\165', '\166', '\167'
     & ,'\168', '\169', '\170', '\171', '\172', '\173', '\174', '\175'
     & ,'\040', '\177', '\178', '\179', '\180', '\181', '\182', '\183'
     & ,'\184', '\185', '\186', '\187', '\188', '\189', '\040', '\191'
     & ,'\040', '\193', '\194', '\195', '\196', '\197', '\198', '\199'
     & ,'\200', '\040', '\202', '\203', '\040', '\205', '\206', '\207'
     & ,'\208', 11*'\040'
     & ,'\092', 4*'\040'
     & ,'\225', '\040', '\227', 4*'\040'
     $ ,'\232', '\233', '\234', '\235', 5*'\040'
     & ,'\241', 3*'\040'
     & ,'\245', '\040', '\040', '\248', '\249', '\250', '\251'
     & , 3*'\040' /
      CHARACTER*4 DEV
      CHARACTER*5 FBUF
      CHARACTER*5 VERSION /'1.200'/
      CHARACTER*6 JUSTS(NJUS,2) /'cshow ', 'show  ', 'rshow ',
     &                           'cushow', 'ushow ', 'rushow'/
      CHARACTER*7 DEVLD /'(    #)'/
      CHARACTER*7 STAT /'NEW    '/
      CHARACTER*9 OPTFID /'LASP:OPTS'/
      CHARACTER*11 PNTLZR /'!PRINT LZ0 '/
      CHARACTER*11 SHW(NSHW) /NSHW*' '/
      CHARACTER*12 DELLZR /'!DELETE LZ0 '/
      CHARACTER*27 QQ
      CHARACTER*28 FONT(NFONTS) /'Symbol'
     & ,'Courier', 'Courier-Bold', 'Courier-Oblique',
     &      'Courier-BoldOblique'
     & ,'Times-Roman', 'Times-Bold', 'Times-Italic',
     &      'Times-BoldItalic'
     & ,'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique',
     &      'Helvetica-BoldOblique'
     & ,'AvantGarde-Book', 'AvantGarde-Demi', 'AvantGarde-BookOblique',
     &      'AvantGarde-DemiOblique'
     & ,'Bookman-Light', 'Bookman-Demi', 'Bookman-LightItalic',
     &      'Bookman-DemiItalic'
     & ,'Helvetica-Narrow', 'Helvetica-Narrow-Oblique',
     &      'Helvetica-Narrow-Bold', 'Helvetica-Narrow-BoldOblique'
     & ,'Palatino-Roman', 'Palatino-Italic', 'Palatino-Bold',
     &      'Palatino-BoldItalic'
     & ,'NewCenturySchlbk-Roman', 'NewCenturySchlbk-Italic',
     &      'NewCenturySchlbk-Bold', 'NewCenturySchlbk-BoldItalic'
     & ,'ZapfChancery-MediumItalic', 'ZapfDingbats'/
      CHARACTER*31 PAPS(NPAPS,2) /
     &  '!LDEV LZ01 LP@LASER,FORM=NOBLZR',
     &  '!LDEV LZ01 LP@LASER,FORM=NOBLRG',
     &  '!LDEV LZ01 LP@LASER,FORM=NOBOND',
     &  '!LDEV LZ01 LP@LASER,FORM=NOBPUN',
     &  '!LDEV LZ01 LP@LASER,FORM=NOBGRN',
     &  '!LDEV LZ02 LZ@LASER,FORM=NOBLZR',
     &  '!LDEV LZ02 LZ@LASER,FORM=NOBLRG',
     &  '!LDEV LZ02 LZ@LASER,FORM=NOBOND',
     &  '!LDEV LZ02 LZ@LASER,FORM=NOBPUN',
     &  '!LDEV LZ02 LZ@LASER,FORM=NOBGRN'/
      CHARACTER*64 PAGTXT, OVLFID(2:3)
      CHARACTER*64 FID(NFIDS) /NFIDS*' '/
      CHARACTER*64 TXBF(NFIDS) /NFIDS*' '/
      CHARACTER*132 OBUF
      CHARACTER*185 TTBL, TTBLX
      CHARACTER*475 OVSTBUF, TMP
      CHARACTER*512 INP
C
      DIMENSION VALS(NTXO+1:NLROPTS), FONL(NFONTS), SHWL(NSHW)
      DIMENSION VMIN(NTXO+1:NLROPTS), VMAX(NTXO+1:NLROPTS)
      DIMENSION SAVBF(2,26), FIDL(NFIDS), LINES(8), FONTFAM(NFONTS)
      DIMENSION HMLBAN(NPAPS),VMTBAN(NPAPS),VMBBAN(NPAPS),PSIZ(NPAPS,2)
      DIMENSION JUSL(NJUS,2), OVLFIDL(2:3), XLW(8), XBOR(2,MAXBOR)
      DIMENSION YBOR(2,MAXBOR), ZBOR(MAXBOR)
      DIMENSION LTXBF(NFIDS), KB(8)
C
      EQUIVALENCE (DEVLDX,DEVLD), (DEVLDX(2),DEV)
      EQUIVALENCE (VALS(NTXO+1),CPI), (VALS(NTXO+2),HML),
     &            (VALS(NTXO+3),LPI), (VALS(NTXO+4),VMB),
     &            (VALS(NTXO+5),VMT), (VALS(NTXO+6),CHARSIZ)
      EQUIVALENCE (TTBL, TTABLE), (TTBLX, TTABLEX)
C
      DATA FONL / 6
     &  , 7, 12, 15, 19
     &  ,11, 10, 12, 16
     &  , 9, 14, 17, 21
     &  ,15, 15, 22, 22
     &  ,13, 12, 19, 18
     &  ,16, 24, 21, 28
     &  ,14, 15, 13, 19
     &  ,22, 23, 21, 27
     &  ,25, 12/
      DATA FONTFAM /.844
     & ,4*1.
     & ,4*.872
     & ,4*0.779
     & ,4*.755
     & ,.818, .818, .824, .824
     & ,4*.779
     & ,4*.818
     & ,4*.781
     & ,.996, 1./
      DATA LTXBF /NFIDS*1/
      DATA XF, X70 /15, 112/
      DATA SHWL /NSHW*2/
      DATA JUSL /5, 4, 5,  6, 5, 6/
      DATA VMIN /1., -.25, 1., 0., -.25, .25/
      DATA VMAX /25., 16., 20., 16., 16., 2./
      DATA MAXCOPS /50/
      DATA SAVBF /52*0./
      DATA HMLBAN /.75, .75, .75, .75, .75/
      DATA VMBBAN /1.5, 1.5, 1.5, 1.5, 1.5/
      DATA VMTBAN /5.25, 5.25, 5.25, 5.25, 5.25/
      DATA PSIZ /11., 17., 11., 11., 11.,  8.5, 11., 8.5, 8.5, 8.5/
      DATA TOF, FPAGE, GOODO, MORE, DEFCHT, NOCONT, FSHOWP /7*.TRUE./
      DATA PSCCL, PSCIF, BANN, SETPOS, PAGNUM, TRANS, END /7*.FALSE./
      DATA TEXTED /.FALSE./
      DATA OVL1, OVL2, BADI, LDV, TRNFID /5*.FALSE./
      DATA NOTOP /MAXBOR*.FALSE./
      DATA NOBOT /MAXBOR*.FALSE./
      DATA LINES /.012, .028, .012, .028, .012, .028, .012, .028/
C
C MOVE THESE COMMON BLOCKS INTO SUBROUTINES
C BASED ON N S T U BETWEEN COLUMNS 16 AND 18
C
      COMMON /IST/ FON, NPAP
      COMMON /IT/NPG,NPOS,NR,OVLPGS,PAGLEN,SHOW,XFON,UOUT,FONL,SHWL,NCOP
      COMMON /RST/ CPI, HML, LPI, VMB, VMT, CHARSIZ, PWD, SIZCHR, YNUM,
     &             XCHR, YCHR, FONTFAM, PSIZ
      COMMON /RT/ X, XHML, XVMB, XVMT, XLPI, XCPI, XCHSIZ, ULPOS
      COMMON /RS/ PHT, VMBO, SIZLN, YPOS
      COMMON /LF/ TEXTED
      COMMON /LST/ PAGNUM
      COMMON /LS/ BADI, DEFCHT
      COMMON /LT/ BANN, OLAYS, ROMAN, TOF, END, NUFONT, FSHOWP
      COMMON /CTS/ FOR
      COMMON /CT/ BAN, PAGTXT, XFOR, ROTATE, SHW, FONT
      COMMON /PENSIZE_IN/ LINES
      COMMON /IFLN/ KB, NI, QL
      COMMON /TFLN/ QQ
C
C
C DATA SETUPS FOR ELEMENTS WITH PARAMETERIZED COUNTS
C
      NUL=CHAR(0)
      BS=CHAR(8)
      FF=CHAR(12)
      CR=CHAR(13)
      FUNC=0
      NPG=-1
      X=0.
      Y=0.
      BAN=' '
      ROTATE=' '
      POS=256
      SHOW=1
      NPAP=1
      NSHOW=1
      NBOR=0
      OVLPGS=999999
      UOUT=99
      UIN2=52
      JUST=2
      NCOP=1
      XCHSIZ=.166
      ULINE=1
      ULPOS=1.5
      TCI=-1
C
C SET UP SEARCH TABLES
C
      DO 1000 I=0,511
      NBTAB(I)='X'
 1000 STAB(I)=NUL
      NBTAB(32)=NUL
      STAB(8)='B'
      STAB(40)='P'
      STAB(41)='P'
      STAB(92)='P'
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC COMMAND BUFFER
C
C GET THE COMMAND BUFFER.
C
      CALL CCBUF (POS, INP)
C
C GET THE LAST NON-BLANK CHARACTER
C
 1101 CONTINUE
      IF (POS.GT.0) LEN=FINDNE (INP, POS, 1, ' ')
      IF ((INP(LEN-4:LEN).EQ.'PRINT') .OR. (POS.LE.0)) THEN
        WRITE (ME,104) 'null command line'
  104   FORMAT (5X, 'Command line structure is invalid (', A, ').')
C
C EXTEND COMMAND LINE?
C
      ELSE
        IF (INP(LEN:LEN).EQ.';') THEN
          IF (NOCONT) THEN
            OPEN (MEIN, FILE='*CONTINUATION_COMMANDS',STATUS='OLD')
            NOCONT=.FALSE.
            READ (MEIN,164) TMP
          ENDIF
          READ (MEIN,164) INP(LEN:512)
          INQUIRE (UNIT=MEIN, RECSIZE=ILN)
          POS=ILN+LEN-1
          GOTO 1101
        ENDIF
      ENDIF
      IF (.NOT.NOCONT) CLOSE (MEIN, STATUS='KEEP')
C
C
C GREET THE USER
C
      WRITE (ME,101) VERSION
  101 FORMAT ('+    LASPRINT ',A)
C
C LOCATE THE FILE NAME FIELD, CONTAINING THE DATA FILE NAMES
C
C GET THE FIRST NON-BLANK IN CCBUF (BEGINNING OF COMMAND STRING)
C
      INDX=FINDNE (INP, 1, LEN, ' ')
C
C FIRST BLANK FOLLOWING COMMAND
C
      FB=FINDEQ (INP, INDX+1, LEN, ' ')
C
C FIRST NON-BLANK IN FILE NAME FIELD
C
      FIDS=FINDNE (INP, FB, LEN, ' ')
C
C NEWS?
C
      IF (INP(FIDS:FIDS+4).EQ.'NEWS ') THEN
        OPEN (USAGE='INPUT,SHARED', FILE='LASPRINT:NEWS.X',
     &   UNIT=UIN1, STATUS='OLD', IOSTAT=IOS)
        IF (IOS.EQ.0) THEN
          DO 1002 I=1,99999
          READ (UIN1,164,END=1003) INP
          INQUIRE (UNIT=UIN1, RECSIZE=LEN)
          WRITE (ME,165) INP(1:LEN)
 1002     CONTINUE
 1003     CLOSE (UIN1, STATUS='KEEP')
        ELSE
          WRITE (ME,102)
  102     FORMAT (5X, 'Help file is currently unavailable.')
        ENDIF
        STOP
      ENDIF
C
C LOCATE DESTINATION
C
      DS=MAX(FINDEQ (INP, FIDS+1, LEN, ' OVER'),
     & FINDEQ (INP, FIDS+1, LEN, ' over'))
      IF (DS.EQ.0) THEN
        DS=MAX(FINDEQ (INP, FIDS+1, LEN, ' TO'),
     &   FINDEQ (INP, FIDS+1, LEN, ' to'))
        IF (DS.EQ.0) THEN
          WRITE (ME,104) 'no destination device'
          STOP
        ELSE
          INCR=4
        ENDIF
      ELSE
        STAT='UNKNOWN'
        INCR=6
      ENDIF
      DSS=FINDNE (INP, DS+INCR, LEN, ' ')
      DSF=FINDEQ (INP, DSS+1, LEN, ' ')
      IF (DSF.EQ.0) THEN
        DSF=LEN
      ELSE
        DSF=DSF-1
      ENDIF
      DEV=INP(DSS:DSF)
C
C LOCATE END OF FILE FIELD
C
      FIDF=FINDNE (INP, DS-1, FIDS, ' ')
C
C LOCATE START OF OPTION FIELD
C
      OFST=FINDEQ (INP, DS+4, LEN, '(')
      IF (OFST.EQ.0) THEN
        OPTS=.FALSE.
      ELSE
        OPTS=.TRUE.
        DSF=MIN(DSF,OFST-1)
      ENDIF
C
C IDENTIFY THE DATA FILE NAMES.
C
      NFID=0
      REPEAT 1103, WHILE (MORE .AND. (NFID.LE.NFIDS))
      NFID=NFID+1
C
C GET NEXT FID CHUNK OUT OF FILE FIELD
C
C FIND THE NEXT COMMA OR SEMICOLON, OR END OF STRING
C (INGORE COMMA OR SEMICOLON IF IN BALANCED PARENTHESES)
C
      POS=MAX(FINDEQND (INP, FIDS, FIDF, ','),
     & FINDEQND (INP, FIDS, FIDF, ';'))
      IF (POS.EQ.0) THEN
        POS=FIDF+1
        MORE=.FALSE.
        DLM(NFID)=' '
      ELSE
        MORE=.TRUE.
        DLM(NFID)=INP(POS:POS)
      ENDIF
C
C GET THE FIRST NON-BLANK IN THE SUBFIELD
C
      ST=FINDNE (INP, FIDS, POS-1, ' ')
C
C IS THERE A VFC ENTRY AT THE END AS (xVFC) ?
C
      PAR=FINDEQ (INP, FIDS, POS-1, '(')
C
C GET THE VFC VALUE AND LAST NONBLANK
C
      IF (PAR.EQ.0) THEN
        VFC(NFID)=' '
        ND=FINDNE (INP, POS-1, ST, ' ')
      ELSE
C
C GET START OF OPTION TEXT
C
        PST=FINDNE (INP, PAR+1, ST, ' ')
C
C IS THIS A VALID OPTION CALL?
C
        IF (TXTOK(INP(PST:PST), VFCTX, NVFCS, OPTN)) THEN
          VFC(NFID)=UVFCTX(OPTN)
C
C IF 'TEXT' VFC OPTION, ARE THERE TEXT OPTIONS?
C
          IF (VFC(NFID).EQ.'T') THEN
            OPST=FINDEQ (INP, PAR+1, POS-1, '(')
            IF (OPST.NE.0) THEN
              RPAR=FINDEQ (INP, POS, PAR+2, ')')
              OPND=FINDEQ (INP, RPAR-1, OPST, ')')
              TXBF(NFID)=INP(OPST:OPND)
              LTXBF(NFID)=OPND-OPST+1
            ENDIF
          ENDIF
        ELSE
C
C BAD ENTRY
C
          WRITE (ME,105) 'VFC', INP(PAR:MIN(POS-1,PAR+20))
  105     FORMAT (5X, A, ' option "', A, '" is invalid.')
          BADI=.TRUE.
        ENDIF
C
C ANOTHER ENTRY?
C
        ND=FINDNE (INP, PAR-1, ST, ' ')
      ENDIF
C
C GET THE FILE NAME AND LENGTH.
C
      FID(NFID)=INP(ST:ND)
      FIDL(NFID)=ND-ST+1
C
C TEST THE FILE FOR THERENESS
C
      OPEN (USAGE='INPUT,SHARED',
     & UNIT=UIN1,FILE=FID(NFID)(1:FIDL(NFID)),STATUS='OLD',IOSTAT=IOS)
      IF (IOS.EQ.0) THEN
        CLOSE (UIN1, STATUS='KEEP')
      ELSE
        IOS=IOSDCODE(IOS)
        WRITE (ME,110) FID(NFID)(1:MIN(20,FIDL(NFID))), IOS
  110   FORMAT (5X, 'File "', A, '" is not available ',
     &   '(Error code ', I, -1X, ')')
        BADI=.TRUE.
      ENDIF
C
C RESET THE FIDS PARAMETER TO START LOOKING FOR THE NEXT NAME
C GET FIRST NON-BLANK IN NEXT SUBFIELD
C
      IF (MORE) FIDS=FINDNE (INP, POS+1, FIDF, ' ')
 1103 CONTINUE
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC COMMAND-LINE OPTIONS
C
C GET ALL THE COMMAND-LINE OPTIONS BEFORE MODIFYING ANY OF THE PARAMETERS.
C FOR EACH OPTION, FIND THE BEGINNING OF THE OPTION NAME, THE = SIGN, AND
C THE END (COMMA OR ) ).
C
C SET OPTION PARAMETER DEFAULTS FIRST
C
      FON=2
      FOR='P'
      PHT=-1000.
      CPI=-1000.
      HML=-1000.
      LPI=-1000.
      VMB=-1000.
      VMT=-1000.
      CHARSIZ=-1000.
      TTBL=TTBLX
C
C OPTIONS IN THE COMMAND LINE?
C
      IF (OPTS) THEN
C
C GET BEGINNING OF OPTION STRING
C
        ST=FINDNE (INP, OFST+1, LEN, ' ')
C
C PARSE OPTIONS, LOCATE FIRST '=' AND COMMA OR END OF STRING
C IF THERE IS A ( SEARCH FOR A ) BEFORE LOOKING FOR A ,
C DO THIS LOOP ONCE FOR EACH COMMAND-LINE OPTION
C
 1108   CONTINUE
        NOEQ=.TRUE.
        PARN=.FALSE.
        PARL=0
        PARR=0
        DO 1127 I=ST,LEN
        IF (INP(I:I).EQ.'(') THEN
          PARN=.TRUE.
          PARL=I
        ELSEIF (PARN .AND. (INP(I:I).EQ.')')) THEN
          PARN=.FALSE.
          PARR=I
        ENDIF
        IF (NOEQ .AND. (INP(I:I).EQ.'=')) THEN
          EQS=I
          NOEQ=.FALSE.
        ENDIF
        IF (.NOT.NOEQ  .AND.  .NOT.PARN .AND.
     &     ((INP(I:I).EQ.',') .OR. (I.GE.LEN))) THEN
          CUROPT=UCASE(INP(ST:ST+2))
          STT=FINDNE (INP, EQS+1, I-1, ' ')
          IF (STT.EQ.0) THEN
            WRITE (ME,111) CUROPT
  111       FORMAT (5X, A, ' has an invalid null entry.')
            GOTO 1127
          ENDIF
          ILN=FINDNE (INP, I-1, STT, ' ')
          CURVAL=UCASE(INP(ILN:ILN))
C
C NOW THAT WE HAVE DELIMITED THE OPTION AND VALUE FIELDS,
C IDENTIFY THE OPTION AND EXTRACT THE VALUE.
C DO THIS LOOP ONCE FOR EACH VALID OPTION, UNTIL A MATCH IS FOUND
C
          DO 1125 J=1,NCLINEOPTS
          IF (CUROPT.EQ.OPT(J)) THEN
C
C COMMAND-LINE STRING OPTIONS EXPECT TEXT ENTRIES.
C THERE IS VALUE CHECKING FOR MOST OF THEM.
C
C PAP - GET PAPER STOCK TO USE - - - - - - - - - - - - - -##### CL # PAP #
C
            IF (J.EQ.1) THEN
              IF (.NOT.TXTOK(CURVAL, PAPTX, NPAPS, NPAP)) THEN
                WRITE (ME,112) OPT(J), INP(ILN:ILN)
  112           FORMAT (5X, A,' option entry "',A,'" is invalid.')
                BADI=.TRUE.
              ENDIF
              IF ((CURVAL.EQ.'2') .AND. (DEV.EQ.'LZ02')) THEN
                WRITE (ME,113) OPT(J), INP(ILN:ILN), 2
  113           FORMAT (5X, A, 'option entry "', A,
     &           '" is not supported on LX0', I1, '.')
                BADI=.TRUE.
              ENDIF
C OVL - GET FORM OVERLAY FILE SPEC - - - - - - - - - - - -##### CL # OVL #
C
C IS THIS OVL1 OR OVL2, AND ARE THEY IN RIGHT ORDER?
C
C OVL1 (FIRST PAGE OVERLAY)
C
            ELSEIF (J.EQ.2) THEN
              IF (INP(ST+3:ST+3).EQ.'1') THEN
                IF (OVL2) THEN
                  WRITE (ME,115)
  115             FORMAT (5X, 'OVL1 must be invoked before OVL2')
                  BADI=.TRUE.
                ELSE
                  NSHOW=2
                  OVL1=.TRUE.
C
C SET THE NUMBER OF PAGES TO OVERLAY WITH THE FORM.  TO
C LOCATE THE FILE NAME; GET THE FIRST NONBLANK BEFORE THE ( OR END.
C IS THERE A NUMBER AT THE END OF THE FILE NAME?
C
                  POS=FINDEQ (INP, STT, ILN, '(')
                  IF (POS.EQ.0) THEN
                    POS=ILN+1
                  ELSE
                    IF (NUMBRS('I', INP, POS+1, ILN-1, A)) THEN
                      READ (INP(POS+1:ILN-1),125) OVLPGS
  125                 FORMAT (I)
                    ELSE
                      WRITE (ME,128) OPT(J),
     &                 INP(POS:MIN(ILN,POS+20))
  128                 FORMAT (5X,A,' requires integer entry; "',
     &                 A, '" is invalid.')
                      BADI=.TRUE.
                    ENDIF
                  ENDIF
                ENDIF
C
C OVL2 (SECOND PAGE OVERLAY)
C
              ELSEIF (INP(ST+3:ST+3).EQ.'2') THEN
                IF (OVL1) THEN
                  NSHOW=3
                  POS=ILN+1
                  OVL2=.TRUE.
                ELSE
                  WRITE (ME,115)
                  BADI=.TRUE.
                ENDIF
              ELSE
                WRITE (ME,120) INP(ST:MIN(EQS-1,STT+20))
  120           FORMAT (5X,'"',A,'" is a bad option specification.')
                BADI=.TRUE.
              ENDIF
C
C SAVE THE FILE NAME, AND TEST IT FOR THERENESS
C
              IF (.NOT.BADI) THEN
                OLAYS=.TRUE.
                SHOW=2
                READ (INP(ST+3:ST+3),125) NBR
                OVLFID(NBR+1)=INP(STT:POS-1)
                OVLFIDL(NBR+1)=POS-STT
                IF (OVLFID(NBR+1)(1:OVLFIDL(NBR+1)).EQ.'NO') THEN
                  SHW(NBR+1)=SHW(1)
                ELSE
                  OPEN (USAGE='INPUT,SHARED',
     &             UNIT=UIN1,FILE=OVLFID(NBR+1)(1:OVLFIDL(NBR+1)),
     &             IOSTAT=IOS, STATUS='OLD')
                  IF (IOS.EQ.0) THEN
                    CLOSE (UIN1, STATUS='KEEP')
                  ELSE
                    IOS=IOSDCODE(IOS)
                    WRITE (ME,110)OVLFID(NBR+1)
     &               (1:MIN(20,OVLFIDL(NBR+1))), IOS
                    BADI=.TRUE.
                  ENDIF
                  WRITE (SHW(NBR+1),131) NBR
  131             FORMAT ('  showfrm', I1, 1X)
                  SHWL(NBR+1)=11
                ENDIF
              ENDIF
C
C BAN - BANNER-SHEET PRINTING - - - - - - - - - - - - - - ##### CL # BAN #
C
            ELSEIF (J.EQ.3) THEN
              IF (TXTOK(CURVAL, BANTX, NBANS, LL)) THEN
                BAN=CURVAL
                BANN=.TRUE.
              ELSE
                WRITE (ME,112) OPT(J), INP(STT:MIN(ILN,STT+20))
                BADI=.TRUE.
              ENDIF
C
C COP - NUMBER OF COPIES - - - - - - - - - - - - - - - - -##### CL # NUM #
C
            ELSEIF (J.EQ.4) THEN
              IF (NUMBRS('I',INP,STT,ILN,A)) THEN
                READ (INP(STT:ILN),125) NCOP
                IF ((NCOP.GT.MAXCOPS) .OR. (NCOP.LT.1)) THEN
                  WRITE (ME,133) OPT(J), INP(STT:MIN(ILN,STT+20))
  133             FORMAT (5X,A,' entry "', A,
     &             '" is outside the valid range.')
                  BADI=.TRUE.
                ENDIF
              ELSE
                WRITE (ME,128) OPT(J), INP(STT:MIN(ILN,STT+20))
                BADI=.TRUE.
              ENDIF
C
C PSC - POSTSCRIPT RECORDS IDENTIFIED BY LEADING CHARACTER - ## CL # PSC #
C
C GET POSTSCRIPT IDENTIFIER PRINTABLE CHARACTER, IF NOT NULL
C
            ELSEIF (J.EQ.5) THEN
              IF (ICHAR(INP(ILN:ILN)).GT.32) THEN
                PSC=INP(ILN:ILN)
                PSCCL=.TRUE.
              ELSE
                WRITE (ME,135) ICHAR(INP(ILN:ILN))
  135           FORMAT (5X, 'Command-line PSC requires a printable',
     &           ' character; X''', Z2, ''' is invalid.')
              ENDIF
C
C FOR - PAGE FORMAT - - - - - - - - - - - - - - - - - - - ##### CL # FOR #
C
            ELSEIF (J.EQ.6) THEN
              IF (TXTOK(CURVAL, FORXX, NPFORS, LL)) THEN
                FOR=CURVAL
              ELSE
                WRITE (ME,112) OPT(J), INP(STT:MIN(ILN,STT+20))
                BADI=.TRUE.
              ENDIF
C
C NUM - PAGE NUMBERING TEXT - - - - - - - - - - - - - - - ##### CL # NUM #
C
            ELSEIF (J.EQ.7) THEN
              PAGLEN=I-EQS-1
              IF (PAGLEN.GE.1) THEN
                PAGTXT=INP(STT:ILN)
                PAGNUM=.TRUE.
C
C POINT TO # OR % LOCATION
C
                PSG=FINDEQ (PAGTXT, 1, PAGLEN, '#')
                PCT=FINDEQ (PAGTXT, 1, PAGLEN, '%')
                IF (PSG+PCT.GT.0) THEN
                  IF (PSG.EQ.0) PSG=9999
                  IF (PCT.EQ.0) PCT=9999
                  NPOS=MIN(PSG,PCT)
                  IF (NPOS.EQ.PCT) THEN
                    ROMAN=.TRUE.
                  ELSE
                    ROMAN=.FALSE.
                  ENDIF
                ELSE
                  NPOS=0
                ENDIF
              ENDIF
C
C TRA - TRANSLATE CHARACTERS TO UPPER 128 - - - - - - - - ##### CL # TRA #
C
C IS THERE A CHARACTER SPEC?
C
            ELSEIF (J.EQ.8) THEN
              PAR=FINDEQ (INP, STT, ILN, '(')
              IF (PAR.EQ.0) THEN
                ND2=ILN
                TRNCHR='|'
              ELSE
                POS=FINDNE (INP, PAR+1, ILN, ' ')
                IF (POS.EQ.0) THEN
                  WRITE (ME,112) OPT(J), INP(PAR:MIN(ILN,PAR+20))
                  BADI=.TRUE.
                ELSE
                  TRNCHR=INP(POS:POS)
                ENDIF
                ND2=PAR-1
              ENDIF
              ND=FINDNE (INP, ND2, STT, ' ')
C
C OPEN THE NAMED FILE AND GET THE TRANSLATION TABLE
C
              IF (ND.GT.STT) THEN
                OPEN (USAGE='INPUT,SHARED', UNIT=UIN1,
     &           FILE=INP(STT:ND), STATUS='OLD', IOSTAT=IOS)
                IF (IOS.EQ.0) THEN
                  DO 1120 K=1,99999
                  READ (UIN1,147,END=1121) CHR, POS
  147             FORMAT (A1, I4)
                  WRITE (TTABLE(ICHAR(CHR)),148) POS
  148             FORMAT ('\', O3)
 1120             CONTINUE
 1121             CONTINUE
                  CLOSE (UIN1,STATUS='KEEP')
                  TRANS=.TRUE.
                  TRNFID=.TRUE.
                ELSE
                  IOS=IOSDCODE(IOS)
                  WRITE (ME,110) INP(STT:MIN(ND,ST+20)), IOS
                  BADI=.TRUE.
                ENDIF
C
C SET UP SEARCH TABLE ENTRY
C
                IF (.NOT.BADI) THEN
                  TCI=ICHAR(TRNCHR)
                  STAB(TCI)='T'
                ENDIF
C
C IF NO FILE DESIGNATION, USE DEFAULTS
C
              ELSE
                TRANS=.TRUE.
              ENDIF
C
C FON - CHARACTER FONT - - - - - - - - - - - - - - - - - -##### CL # FON #
C
C THIS ONE REQUIRES TEXT ENTRY BUT GENERATES A NUMERIC VALUE
C
            ELSEIF (J.EQ.9) THEN
              FNT=UCASE(INP(STT:STT+2))
              IF (.NOT.TXTOK(FNT, FNTX, NFONTS, FON)) THEN
                WRITE (ME,112) OPT(J), INP(STT:STT+2)
                BADI=.TRUE.
              ENDIF
              IF ((DEV.EQ.'LZ02') .AND. (FON.GT.N2665FS)) THEN
                WRITE (ME,113) OPT(J), INP(STT:STT+2), 1
                BADI=.TRUE.
              ENDIF
C
C NSC - DO NOT SCAN FOR THIS CHARACTER - - - - - - - - - -##### CL # NSC #
C
            ELSEIF (J.EQ.10) THEN
              IF (TXTOK(CURVAL, SCANTX, NSCAN, POS)) THEN
                STAB(ICHAR(CURVAL))=NUL
              ELSE
                WRITE (ME,112) OPT(J), INP(ILN:ILN)
                BADI=.TRUE.
              ENDIF
C
C PEN - SET PEN WIDTHS FOR GRAPHICS FROM INCLUDE FILES - -##### CL # PEN #
C
            ELSEIF (J.EQ.11) THEN
              IF (PARL+PARR.EQ.0) THEN
                WRITE (ME,112) OPT(J), INP(EQS:MIN(ILN,EQS+20))
                BADI=.TRUE.
              ELSE
                IF (NUMBRS('r', INP, PARL+1, PARR-1, A)) THEN
                  READ (INP(PARL+1:PARR-1),150) XLW
  150             FORMAT (8F.0)
                  DO 1124 K=1,8
                  IF (XLW(K).GT.0.001) LINES(K)=MIN(XLW(K),1.)
                  IF (XLW(K).GT.1.) THEN
                    WRITE (ME,151) K, XLW(K)
  151               FORMAT (5X, 'PEN ', I, 'entry "', F.3, -1X,
     &               '" is invalid; may not exceed 1.0.')
                    BADI=.TRUE.
                  ENDIF
 1124             CONTINUE
                ELSE
                  WRITE (ME,130) OPT(J),
     &             INP(PARL+1:MIN(PARR-1,PARL+21))
  130             FORMAT (5X,A,' requires numeric entry; "',
     &             A, '" is invalid.')
                  BADI=.TRUE.
                ENDIF
              ENDIF
C
C JUS - LINE JUSTIFICATION - - - - - - - - - - - - - - - -##### CL # JUS #
C
            ELSEIF (J.EQ.12) THEN
              IF (.NOT.TXTOK(CURVAL, JUSTX, NJUS, JUST)) THEN
                WRITE (ME,112) OPT(J), INP(ILN:ILN)
                BADI=.TRUE.
              ENDIF
C
C UND - UNDERLINE POSITION - - - - - - - - - - - - - - - -##### CL # UND #
C
            ELSEIF (J.EQ.13) THEN
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) ULPOS
              ELSE
                WRITE (ME,136) OPT(J), INP(STT:MIN(ILN,STT+20))
  136           FORMAT (5X,A,' in the command line requires ',
     &           'numeric entry; "', A, '" is invalid.')
                BADI=.TRUE.
              ENDIF
C
C NUMERIC OPTIONS (IGNORE THE INTERACTIVE-ONLY ONES) - - - - - -##### CL #
C
            ELSE
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) VALS(J)
C
C ARE THE VALUES WITHIN THE VALID RANGES?
C
                IF (VALS(J).LT.VMIN(J)) THEN
                  WRITE (ME,133) OPT(J), INP(STT:MIN(ILN,STT+20))
                  BADI=.TRUE.
                ELSEIF (VALS(J).GT.VMAX(J)) THEN
                  WRITE (ME,133) OPT(J), INP(STT:MIN(ILN,STT+20))
                  BADI=.TRUE.
                ENDIF
C
C TO DIDDLE WITH DEFAULT CHARACTER HEIGHTS IF OPTION IS 'CHA'
C NOTE - 'CHA' MUST BE LAST OPTION IN REAL NUMERIC LIST
C
                IF (J.EQ.NLROPTS) THEN
                  VALS(J)=VALS(J)*1.5
                  DEFCHT=.FALSE.
                ENDIF
              ELSE
                WRITE (ME,130) OPT(J), INP(STT:MIN(ILN,STT+20))
                BADI=.TRUE.
              ENDIF
            ENDIF
C
C HAVE WE PARSED TO THE END OF THE RECORD?
C
            IF (I.GE.LEN) THEN
              GOTO 1130
            ELSE
C
C NO, WE HAVEN'T.  GET THE BEGINNING OF NEXT OPTION
C AND RESTART THE NAME-CHECKING LOOP.
C
              ST=FINDNE (INP, I+1, LEN, ' ')
              GOTO 1108
            ENDIF
          ENDIF
 1125     CONTINUE
C
C BAD OPTION, NOT IN THE OPT ARRAY.
C
          IF (EQS.LT.ST) THEN
            NDD=LEN
          ELSE
            NDD=EQS-1
          ENDIF
          WRITE (ME,120) INP(ST:MIN(NDD,ST+20))
          BADI=.TRUE.
C
C HAVE WE PARSED TO THE END OF THE RECORD?
C
          IF (I.GE.LEN) THEN
            GOTO 1130
          ELSE
C
C NO, WE HAVEN'T.  GET THE BEGINNING OF NEXT OPTION
C AND RESTART THE NAME-CHECKING LOOP.
C
            ST=FINDNE (INP, I+1, LEN, ' ')
            GOTO 1108
          ENDIF
        ENDIF
 1127   CONTINUE
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC OPTIONS FROM FILES
C
C FILE NAME FOR OPTIONS OR DEFECTIVE COMMAND LINE?
C
        IF (NOEQ) THEN
C
C IF AN OPTION FILE IS USED THERE WILL BE A COLON IN THERE
C
          COL=FINDEQ (INP, LEN-1, OFST+1, ':')
          IF (COL.EQ.0) THEN
            WRITE (ME,104) 'no "=" in last option field'
            BADI=.TRUE.
          ELSE
C
C NO FILE NAME OR <?
C
            FNB=FINDNE (INP, OFST+1, COL, ' ')
            IF (COL.EQ.FNB) THEN
              OPEN (USAGE='INPUT,SHARED', ACCESS='KEYED',
     &         UNIT=UIN1, STATUS='OLD', IOSTAT=IOS, FILE=OPTFID)
              OPTFI=-1
C
C POINTS TO INPUT FILES
C
C SEE IF THERE IS A NUMBER BETWEEN THE < AND THE :
C
            ELSEIF (INP(FNB:FNB).EQ.'<') THEN
              IF (COL.EQ.FNB+1) THEN
                OPTFI=1
              ELSE
                READ (INP(FNB+1:COL-1),125) OPTFI
              ENDIF
              OPEN (USAGE='INPUT,SHARED', ACCESS='KEYED',
     &         UNIT=UIN1, FILE=FID(OPTFI)(1:FIDL(OPTFI)),
     &         STATUS='OLD', IOSTAT=IOS)
C
C SPECIFIC FILE NAMED
C
            ELSE
              OPEN (USAGE='INPUT,SHARED', ACCESS='KEYED',
     &         UNIT=UIN1, FILE=INP(OFST+1:COL-1), STATUS='OLD',
     &         IOSTAT=IOS)
              OPTFI=0
            ENDIF
            IF (IOS.EQ.0) THEN
C
C EDIT KEYED?
C
              PER=FINDEQ (INP, COL+1, LEN-1, '.')
              IF (PER.NE.0) THEN
                READ (INP(COL+1:LEN-1),153) ZKEY
  153           FORMAT (F.3)
                READ (UIN1,164,KEY=ZKEY*1000.,ERR=1129) TMP
                INQUIRE (UNIT=UIN1,RECSIZE=ILN)
              ELSE
                READ (INP(COL+1:LEN-1),125) NR
                IF (NR.GT.1) THEN
                  DO 1128 JJ=1,NR-1
                  READ (UIN1,155) EOMCHAR
  155             FORMAT (A1)
 1128             CONTINUE
                ENDIF
                READ (UIN1,164,END=1129) TMP
                INQUIRE (UNIT=UIN1,RECSIZE=ILN)
              ENDIF
              CLOSE (UIN1, STATUS='KEEP')
              STX=FINDEQ (TMP, 1, ILN, '(')
              INP(OFST:512)=TMP(STX:ILN)
              LEN=OFST+ILN-STX
              ST=OFST+1
              GOTO 1108
C
C BAD RECORD NUMBER
C
 1129         CONTINUE
              CLOSE (UIN1, STATUS='KEEP')
              WRITE (ME,157) INP(COL+1:LEN-1), INP(OFST+1:COL-1)
  157         FORMAT (5X, 'Line ', A
     &         ' does not exist in option file ', A)
              BADI=.TRUE.
C
C FILE NOT AVAILABLE
C
            ELSE
              IOS=IOSDCODE(IOS)
              IF (OPTFI.LT.0) THEN
                WRITE (ME,110) OPTFID, IOS
              ELSEIF (OPTFI.EQ.0) THEN
                WRITE (ME,110) INP(FNB:COL-1), IOS
              ELSE
                WRITE (ME,110) FID(OPTFI)(1:FIDL(OPTFI)), IOS
              ENDIF
              BADI=.TRUE.
            ENDIF
          ENDIF
        ENDIF
      ENDIF
 1130 CONTINUE
C
C DID WE GET BAD VALUES?
C
      IF (BADI) CALL EXIT (2)
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC PARAMETERS
C
C NOW WE WILL CALCULATE AND SET THE PAGE PARAMETERS
C
C SAVE THE RESTORABLE COMMAND-LINE OPTIONS OR THEIR DEFAULTS
C
      XCPI=CPI
      XLPI=LPI
      XHML=HML
      XVMB=VMB
      XVMT=VMT
      XFON=FON
      XFOR=FOR
      XULP=ULPOS
C
C SET UP DEFAULTS BASED ON FORMAT
C
      IF (FOR.EQ.'P') THEN
        IF (XCPI.LT.-10.) XCPI=10.
        IF (XHML.LT.-10.) XHML=.5
        IF (XLPI.LT.-10.) XLPI=6.
        IF (XVMB.LT.-10.) XVMB=.5
        IF (XVMT.LT.-10.) XVMT=.5
      ELSEIF (FOR.EQ.'L') THEN
        IF (XCPI.LT.-10.) XCPI=13.8
        IF (XHML.LT.-10.) XHML=.625
        IF (XLPI.LT.-10.) XLPI=8.8
        IF (XVMB.LT.-10.) XVMB=.5
        IF (XVMT.LT.-10.) XVMT=.5
      ENDIF
C
C IF WE WILL OVERLAY THE BANNER SHEET,
C PUT IN SPECIAL DEFAULTS FOR BANNER-RELATED ITEMS.
C
      IF (BANN) THEN
        HML=HMLBAN(NPAP)
        VMB=VMBBAN(NPAP)
        VMT=VMTBAN(NPAP)
        FOR='P'
        IF (BAN.EQ.'B') THEN
          LPI=6.
          CPI=6.
        ENDIF
      ENDIF
      CALL SETUP
C
C CREATE AND OPEN OUTPUT DEVICE
C
C LP OR LP@wsn
C
      IF (INP(DSS:DSF).EQ.'LP') THEN
        OPEN (UOUT,FILE='(LP)', RECL=505)
      ELSEIF (INP(DSS:DSS+2).EQ.'LP@') THEN
        OPEN (UOUT,FILE='('//INP(DSS:DSF)//')', RECL=505)
C
C USER'S TERMINAL
C
      ELSEIF (INP(DSS:DSF).EQ.'ME') THEN
        OPEN (UOUT,FILE='(UC)', RECL=505)
C
C LASER PRINTER.  CREATE LDEV IF NOT THERE.
C
      ELSEIF ((DEV.EQ.'LZ01') .OR. (DEV.EQ.'LZ02')) THEN
        READ (DEV(4:4),125) NDEV
        PNTLZR(11:11)=DEV(4:4)
        DELLZR(12:12)=DEV(4:4)
        CALL DO$CMD (PAPS(NPAP,NDEV))
        OPEN (UOUT,FILE=DEVLD, RECL=505, USAGE='OUTPUT', IOSTAT=IOS)
        IF (IOS.NE.0) THEN
          IOS=IOSDCODE(IOS)
          WRITE (ME,161) DEV, IOS
  161     FORMAT (5X, 'Device ', A, ' is not available ',
     &     '(Error code ',I,-1X,')')
        ENDIF
        LDV=.TRUE.
C
C FILE NAME
C
      ELSE
        OPEN (UOUT, USAGE='OUTPUT',
     &   FILE=INP(DSS:DSF), RECL=505, STATUS=STAT, IOSTAT=IOS)
        IF (IOS.NE.0) THEN
          IOS=IOSDCODE(IOS)
          WRITE (ME,162) INP(DSS:MIN(DSF,DSS+20)), IOS
  162     FORMAT (5X, 'Output file "', A, '" cannot be written to',
     &     ' (Error code ', I, -1X, ')')
          STOP
        ENDIF
      ENDIF
C
C ANY OVERLAY PROCEDURES TO DEFINE?
C
      DO 1136 I=2,NSHOW
      IF (OVLFID(I)(1:2).NE.'NO') THEN
        OPEN (USAGE='INPUT,SHARED',
     &   UNIT=UIN1,FILE=OVLFID(I)(1:OVLFIDL(I)),STATUS='OLD',IOSTAT=IOS)
        IF (IOS.EQ.0) THEN
          WRITE (UOUT,163) SHW(I)(3:SHWL(I))
  163     FORMAT ('  /',A,' {')
C
C READ EACH RECORD AND PUT IT OUT
C
          DO 1132 JJ=1,99999
          READ (UIN1,164,END=1133) OVSTBUF
  164     FORMAT (A)
          INQUIRE (UNIT=UIN1, RECSIZE=LEN)
 1132     WRITE (UOUT,165) OVSTBUF(1:LEN)
  165     FORMAT (2X,A)
 1133     CONTINUE
C
C DONE.  SEND THE CLOSEOUT STUFF AND CLOSE THE FILE
C
          WRITE (UOUT,166)
  166     FORMAT ('  } def')
          CLOSE (UIN1, STATUS='KEEP')
        ELSE
          IOS=IOSDCODE(IOS)
          WRITE (ME,110) INP(STT:MIN(POS-1,STT+20)), IOS
          STOP
        ENDIF
      ENDIF
 1136 CONTINUE
C
C PREPARE PRINTING STARTUP AND DRAW CROSS LINE IF BANNER SHHET
C
      IF (FOR.EQ.'L') ROTATE='+'
      NUFONT=.TRUE.
      IF (BANN) THEN
        WRITE (UOUT,168) HML-.25, VMB+4.5
  168   FORMAT ('  /ARRGH save def ',2F.3,'moveto 7.5 0 rlineto stroke')
      ELSE
        WRITE (UOUT,169)
  169   FORMAT ('  /ARRGH save def')
      ENDIF
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC DATA FILES
C
C NOW WE START WORKING ON THE DATA FILES
C
C FOR EACH FILE,
C
      NR=0
      DO 1182 NF=1,NFID
      FIL=NF
      NI=0
C
C DO WE RUN THIS FILE THROUGH CP-6 TEXT?
C
      IF (VFC(NF).EQ.'T') THEN
        CALL DO$CMD ('!SET M$LO *LASP,ORG=UR')
        WRITE (ME,165) ' '
        WRITE (OBUF,170) FID(NF)(1:FIDL(NF)), TXBF(NF)(1:LTXBF(NF))
  170   FORMAT ('!TEXT ', A, 1X, A)
        CALL DO$CMD (OBUF)
        CALL DO$CMD ('!RESET M$LO')
        VFC(NF)='V'
        CALL FAST$OPEN (IOS, UIN1, '*LASP', 4, 4, 0, 1)
        TEXTED=.TRUE.
      ELSE
        CALL FAST$OPEN (IOS, UIN1, FID(NF)(1:FIDL(NF)+1), 4, 4, 0, 1)
      ENDIF
C
C IS THERE A FORCED TOP-OF-FORM FOT THIS FILE?
C
      IF (DLM(NF-1).EQ.';') CALL TOP
C
C READ EACH RECORD AND PROCESS IT
C
      DO 1180 NRC=1,999999
      ILN=475
      CALL FAST$READ (IOS, UIN1, INP, 475, ILN, DVBYTE, EOMCHAR, KB, 31)
      IF (IOS.NE.0) THEN
        IF (IOSDCODE(IOS).EQ.6) THEN
          GOTO 1181
        ELSE
          GOTO 1205
        ENDIF
      ENDIF
      NI=NI+1
      LEN=ILN
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C NOW INSPECT EACH LINE FOR RECORD TYPE.
C
C VFC PROCESSING.  (NULL RECORDS ARE ALWAYS PRINT-ONLY, NO VFC.)
C
      IF (ILN.LE.0) THEN
        NUS=1
C
C IS THERE VFC SET FOR THIS DATA FILE?
C
C WHAT VFC IS ON THIS RECORD?
C
C FORTRAN VFC - - - - - - - - - - - - - - - - - - - - - - - - - ##### FVFC
C
      ELSEIF (VFC(NF).EQ.'F') THEN
        ST=2
        PUS=0
C
C TOP OF FORM, PRINT                             (1)
C
        IF (INP(1:1).EQ.'1') THEN
          TOF=.TRUE.
          NUS=0
C
C NO UPSPACE, PRINT                              (+)
C
        ELSEIF (INP(1:1).EQ.'+') THEN
          NUS=0
C
C UPSPACE 2, PRINT                               (0)
C
        ELSEIF (INP(1:1).EQ.'0') THEN
          NUS=2
C
C NULL - PRINT, KEEPING CURRENT POSITION         (<NUL>)
C
        ELSEIF (INP(1:1).EQ.NUL) THEN
          CPP=.TRUE.
          NUS=0
C
C ANY OTHER CHARACTER; UPSPACE 1 AND PRINT
C
        ELSE
          NUS=1
        ENDIF
C
C HONEYWELL VFC - - - - - - - - - - - - - - - - - - - - - - - - -##### VFC
C
      ELSEIF (VFC(NF).EQ.'V') THEN
        FUNCO=FUNC
        ST=2
        INDOLD=0
        INDSV=IND
        IND=ICHAR(INP(1:1))
C
C SPECIAL FUNCTION=0 OPERATIONS?
C
C GO TO BOTTOM OF PAGE IF NOT ALREADY THERE      O'032'
C (NEXT LINE !WILL! GO TO TOF)
C
        IF (IND.EQ.26) THEN
          NR=9999
          NUS=0
          PUS=0
C
C NEWLINE, PRINT, NO UPSPACE                     O'036''
C
        ELSEIF (IND.EQ.30) THEN
          NUS=1
          PUS=0
C
C NEWLINE, PRINT, UPSPACE 1                      O'037'
C
        ELSEIF (IND.EQ.31) THEN
          NUS=1
          PUS=1
C
C NORMAL FUNCTION >2 OPERATIONS
C
        ELSE
          FUNC=IAND(IND,X70)/16
          NSP=IAND(IND,XF)
C
C FUNCTION=3: TOP OF PAGE, PRINT, NO UPSPACE     (0)
C KEEP PREVIOUS 'IND' AROUND IN CASE IT IS O'032'
C
          IF (FUNC.EQ.3) THEN
            INDOLD=INDSV
            TOF=.TRUE.
            NUS=0
            PUS=0
C
C FUNCTION=4; NO UPSPACE, PRINT, UPSPACE N LINES (A-O)
C IF 0 UPSPACES AND PREVIOUS LINE DID NOT UPSPACE
C AFTER PRINTING, KEEP CURRENT PRINT POSITION    (@)
C
          ELSEIF (FUNC.EQ.4) THEN
            NUS=0
            PUS=NSP
            IF ((NSP.LE.0) .AND. ((FUNCO.EQ.3) .OR. (FUNCO.EQ.6))) THEN
              CPP=.TRUE.
            ENDIF
C
C FUNCTION=5; NO UPSPACE, PRINT, TOP OF PAGE     (P)
C
          ELSEIF (FUNC.EQ.5) THEN
            NUS=0
            PUS=99999
C
C FUNCTION=6; UPSPACE N LINES, PRINT, NO UPSPACE (a-o)
C
          ELSEIF (FUNC.EQ.6) THEN
            NUS=NSP
            PUS=0
C
C FUNCTION=7; TOP OF PAGE, PRINT, UPSPACE N LINES(g-O'177')
C KEEP PREVIOUS 'IND' AROUND IN CASE IT IS O'032'
C
          ELSEIF (FUNC.EQ.7) THEN
            INDOLD=INDSV
            TOF=.TRUE.
            NUS=0
            PUS=NSP
C
C OTHER STUFF (CHANNELS).  IGNORE, TREAT AS a
C
          ELSE
            NUS=1
            PUS=0
          ENDIF
        ENDIF
C
C NO VFC (UPSPACE, PRINT) - - - - - - - - - - - - - - - - - - - ##### NVFC
C
C STRIP VFC?
C
      ELSEIF (VFC(NF).EQ.'S') THEN
        ST=2
        NUS=1
        PUS=0
C
C NO VFC AT ALL
C
      ELSE
        ST=1
        NUS=1
        PUS=0
      ENDIF
C
C COMMAND LINE.  CHECK ALL COMMAND NAMES AGAINST THE OPT
C ARRAY, STARTING AFTER THOSE THAT ARE ONLY FOR COMMAND-LINE
C INVOCATION.  UPDATE PARAMETERS AS EACH OPTION IS INVOKED.
C
C GET FIRST NON-BLANK CHARACTER AFTER THE VFC CHARACTER
C
      CALL SEARCH$ (SPOS, IXX, NBTAB, INP, LEN, ST-1)
      SPOS=SPOS+1
C
C IS THIS A COMMAND LINE (FIRST TWO CHARACTERS "\\")?
C
      IF ((LEN.GT.2) .AND.
     &   ((INP(1:2).EQ.'\\') .OR. (INP(SPOS:SPOS+1).EQ.'\\'))) THEN
        IF (INP(1:1).NE.'\') THEN
          ST=SPOS
        ELSE
          ST=1
        ENDIF
C
C GET THE =, AFTER LOOKING FOR THE 'END' OR '***' OPTIONS THAT DON'T HAVE ONE
C
C THEN THE FIRST NONBLANK AFTER THE =, IF INDICATED
C
        NOEQ=.TRUE.
        IF (UCASE(INP(ST+2:ST+4)).EQ.'END') THEN
          GOTO 1181
        ELSEIF (INP(ST+2:ST+4).EQ.'***') THEN
          GOTO 1151
        ELSE
          EQS=FINDEQ (INP, ST+2, ILN, '=')
          STT=FINDNE (INP, EQS+1, ILN, ' ')
        ENDIF
C
C GET END OF COMMAND ELEMENTS
C
        ND=FINDEQ (INP, STT, ILN, '***')
        IF (ND.NE.0) THEN
          ILN=FINDNE (INP, ND-1, STT, ' ')
        ENDIF
C
C IDENTIFY THE OPTION AND GET ITS VALUE, AND UPDATE AS REQUIRED
C
        CUROPT=UCASE(INP(ST+2:ST+4))
        CURVAL=UCASE(INP(ILN:ILN))
        IF (UCASE(INP(STT:STT+2)).EQ.'RES') THEN
          RESTORE=.TRUE.
        ELSE
          RESTORE=.FALSE.
        ENDIF
        DO 1150 J=1+NCLONLY, NOPTS
        IF (CUROPT.EQ.OPT(J)) THEN
C
C PSC - POSTSCRIPT RECORDS IDENTIFIED BY LEADING \\ - - - ##### IF # PSC #
C
C AFFECTS PSCCL, PSCIF
C
          IF (J.EQ.5) THEN
            IF (CURVAL.EQ.'S') THEN
              PSCIF=.TRUE.
            ELSEIF (CURVAL.EQ.'F') THEN
              PSCIF=.FALSE.
            ELSEIF (CURVAL.EQ.'Q') THEN
              PSCIF=.FALSE.
              PSCCL=.FALSE.
            ELSE
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J)//' in-file', INP(ILN:ILN)
  175         FORMAT (5X,'File ', A, A, ': ', A,
     &         ' option entry "', A, '" is invalid.')
              GOODO=.FALSE.
            ENDIF
C
C FOR - PAGE FORMAT - - - - - - - - - - - - - - - - - - - ##### IF # FOR #
C
C AFFECTS FOR, PHT, PWD, YPOS, TOF, XNUM, YNUM, VMB
C
          ELSEIF (J.EQ.6) THEN
            IF (RESTORE) CURVAL=XFOR
            IF (TXTOK(CURVAL, FORXX, NPFORS, LL)) THEN
C
C DID THE FORMAT ACTUALLY CHANGE?
C
              IF ((CURVAL.EQ.'L') .AND. (FOR.NE.'L')) THEN
                IF (GOODO) ROTATE='+'
                PHT=PSIZ(NPAP,2)
                PWD=PSIZ(NPAP,1)
                YPOS=PHT-VMT-SIZLN
                FOR=CURVAL
              ELSEIF ((CURVAL.EQ.'P') .AND. (FOR.NE.'P'))THEN
                IF (GOODO) ROTATE='-'
                PHT=PSIZ(NPAP,1)
                PWD=PSIZ(NPAP,2)
                YPOS=PHT-VMT-SIZLN
                FOR=CURVAL
              ENDIF
              IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
C
C PAGE NUMBER LOCATION CHANGE?
C
              IF (PAGNUM) THEN
                YNUM=VMBO
                VMB=VMBO+(2.*SIZLN)
              ENDIF
C
C BAD OPTION?
C
            ELSE
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(ILN:ILN)
              GOODO=.FALSE.
            ENDIF
C
C NUM - PAGE NUMBERING TEXT - - - - - - - - - - - - - - - ##### IF # NUM #
C
C AFFECTS PAGNUM, PAGLEN, PAGTXT, NPOS, XNUM, YNUM, VMB
C
          ELSEIF (J.EQ.7) THEN
            IF (UCASE(INP(STT:ILN)).EQ.'NO') THEN
              PAGNUM=.FALSE.
              VMB=VMBO
            ELSE
C
C EXTRACT TEXT AND POINT TO # OR % LOCATION
C
              PAGLEN=ILN-STT+1
              PAGTXT=INP(STT:ILN)
              PSG=FINDEQ (PAGTXT, 1, PAGLEN, '#')
              PCT=FINDEQ (PAGTXT, 1, PAGLEN, '%')
              IF (PSG+PCT.GT.0) THEN
                IF (PSG.EQ.0) PSG=9999
                IF (PCT.EQ.0) PCT=9999
                NPOS=MIN(PSG,PCT)
                IF (NPOS.EQ.PCT) THEN
                  ROMAN=.TRUE.
                ELSE
                  ROMAN=.FALSE.
                ENDIF
              ELSE
                NPOS=0
              ENDIF
C
C ARE WE STARTING PAGE NUMBERING FOR THE FIRST TIME?
C
              IF (.NOT.PAGNUM .AND. GOODO) THEN
                YNUM=VMB
                VMB=VMB+(2.*SIZLN)
                PAGNUM=.TRUE.
C
C ARE NOW BELOW THE BOTTOM OF THE PAGE?
C
                IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
              ENDIF
            ENDIF
C
C TRA - TRANSLATE CHARACTERS TO UPPER 128 - - - - - - - - ##### IF # TRA #
C
C IS THERE A CHARACTER SPEC?
C
          ELSEIF (J.EQ.8) THEN
            PAR=FINDEQ (INP, STT, ILN, '(')
            IF (PAR.EQ.0) THEN
              ND=ILN
              TRNCHR='|'
            ELSE
              POS=FINDNE (INP, PAR+1, ILN, ' ')
              IF (POS.EQ.0) THEN
                CALL FLINE
                WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(PAR:MIN(ILN,PAR+20))
                BADI=.TRUE.
              ELSE
                TRNCHR=INP(POS:POS)
              ENDIF
              ND=PAR-1
            ENDIF
C
C TURN OFF TRANSLATION AND RESET DEFAULT CHARACTER AND TABLE?
C
            IF (UCASE(INP(STT:ND)).EQ.'NO') THEN
              TRANS=.FALSE.
              TRNCHR='|'
              IF (TRNFID) THEN
                TTBL=TTBLX
                TRNFID=.FALSE.
              ENDIF
              IF (TCI.GT.0) STAB(TCI)=NUL
C
C OPEN THE NAMED FILE AND GET THE TRANSLATION TABLE
C
            ELSEIF (ND.GT.STT) THEN
              OPEN (USAGE='INPUT,SHARED',
     &         UNIT=UIN2,FILE=(INP(STT:ND)),STATUS='OLD',IOSTAT=IOS)
              IF (IOS.EQ.0) THEN
                DO 1140 K=1,99999
                READ (UIN2,147,END=1141) CHR, POS
                WRITE (TTABLE(ICHAR(CHR)),148) POS
 1140           CONTINUE
 1141           CONTINUE
                CLOSE (UIN2,STATUS='KEEP')
                TRANS=.TRUE.
                TRNFID=.TRUE.
              ELSE
                IOS=IOSDCODE(IOS)
                CALL FLINE
                WRITE (ME,182) FID(NF)(1:MIN(FIDL(NF),20)),QQ(1:QL),
     &           INP(STT:MIN(ND,STT+20)), IOS
  182           FORMAT (5X, 'File ', A, A, ': File "',
     &           A,'" is not available (Error code ',I,-1X,').')
                GOODO=.FALSE.
              ENDIF
C
C SET UP SEARCH TABLE ENTRY
C
              IF (GOODO .AND. TRANS) THEN
                TCI=ICHAR(TRNCHR)
                STAB(TCI)='T'
              ENDIF
C
C IF NO FILE DESIGNATION, USE DEFAULTS
C
            ELSE
              TRANS=.TRUE.
            ENDIF
C
C FON - CHARACTER FONT - - - - - - - - - - - - - - - - - -##### IF # FON #
C
C AFFECTS OFON, FON, FNT, NUFONT
C
          ELSEIF (J.EQ.9) THEN
            IF (BANN .AND. (BAN.EQ.'B')) THEN
              CALL FLINE
              WRITE (ME,184) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J)
  184         FORMAT (5X, 'File ', A, A, ': ', A,
     &         ' cannot be modified while BAN=B is active.')
              GOODO=.FALSE.
            ELSE
              OFON=FON
              IF (RESTORE) THEN
                FON=XFON
              ELSE
                FNT=UCASE(INP(ILN-2:ILN))
                IF (.NOT.TXTOK(FNT, FNTX, NFONTS, FON)) THEN
                  CALL FLINE
                  WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(ILN-2:ILN)
                  GOODO=.FALSE.
                ENDIF
                IF ((DEV.EQ.'LZ01') .AND. (FON.GT.N2665FS)) THEN
                  CALL FLINE
                  WRITE (ME,183) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(ILN-2:ILN), 1
  183             FORMAT (5X,'File ', A, A, ': ', A,
     &             ' option entry "', A,
     &             '" is not supported on LZ0', I1, '.')
                  GOODO=.FALSE.
                ENDIF
              ENDIF
            ENDIF
C
C HAS FONT ACTUALLY CHANGED SO WE NEED A NEW FONT DEFINITION LINE?
C DO IT IN ANY CASE IF RESTORED.
C
C CHANGE CHARACTER SIZES IF A DIFFERENT FAMILY.
C
C
            IF (RESTORE .OR. (GOODO .AND. (FON.NE.OFON))) THEN
              NUFONT=.TRUE.
              IF (((FON-1)/4).NE.((OFON-1)/4)) THEN
                XCHR=1.66667*SIZCHR*FONTFAM(FON)
                IF (DEFCHT) THEN
                  YCHR=MIN(1.05*XCHR,SIZLN*CHARSIZ*FONTFAM(FON))
                ELSE
                  YCHR=SIZLN*CHARSIZ*FONTFAM(FON)
                ENDIF
              ENDIF
            ENDIF
C
C DO WE NEED TO RESET THE BANNER-FONT INDICATOR?
C
            IF (BANN .AND. (BAN.EQ.'B')) THEN
              BAN='X'
            ENDIF
C
C NSC - DO NOT SCAN FOR THIS CHARACTER - - - - - - - - - -##### IF # NSC #
C
          ELSEIF (J.EQ.10) THEN
            IF (TXTOK(CURVAL, SCANTX, NSCAN, POS)) THEN
              STAB(ICHAR(CURVAL))=NUL
            ELSE
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J), INP(ILN:ILN)
            ENDIF
C
C PEN - SET PEN WIDTHS FOR GRAPHICS FROM INCLUDE FILES - -##### IF # PEN #
C
          ELSEIF (J.EQ.11) THEN
            PARL=FINDEQ (INP, STT, ILN, '(')
            PARR=FINDEQ (INP, PARL+1, ILN, ')')
            IF (PARL+PARR.EQ.0) THEN
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ELSE
              IF (NUMBRS('r', INP, PARL+1, PARL-1, A)) THEN
                READ (INP(PARL+1:PARL+1),150) XLW
                DO 1142 K=1,8
                IF (XLW(K).GT.0.001) LINES(K)=MIN(XLW(K),1.)
                IF (XLW(K).GT.1.) THEN
                  CALL FLINE
                  WRITE (ME,188) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), K, XLW(K)
  188             FORMAT (5X, 'File ', A, A, ': PEN ',
     &             I, -1X, 'entry "', F.3, -1X,
     &             '" is invalid; may not exceed 1.0.')
                  BADI=.TRUE.
                ENDIF
 1142           CONTINUE
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),QQ(1:QL),
     &           OPT(J), INP(PARL+1:MIN(PARR-1,PARL+21))
  185           FORMAT (5X, 'File ', A, A, ': ', A,
     &           ' requires numeric entry; "', A, '" is invalid.')
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C JUS - LINE JUSTIFICATION - - - - - - - - - - - - - - - -##### IF # JUS #
C
C AFFECTS JUST
C
          ELSEIF (J.EQ.12) THEN
            IF (.NOT.TXTOK(CURVAL, JUSTX, NJUS, JUST)) THEN
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(ILN:ILN)
              GOODO=.FALSE.
            ENDIF
C
C UND - UNDERLINE POSITIONING AND INVOCATION - - - - - - -##### IF # UND #
C
C AFFECTS ULPOS, ULINE
C
          ELSEIF (J.EQ.13) THEN
            IF (RESTORE) THEN
              ENCODE(7, 153, INP(STT:STT), NCX) XULP
              ILN=STT+NCX-2
            ENDIF
            ULOPT=UCASE(INP(STT:STT+2))
            IF (TXTOK(ULOPT(1:2), ULINETX, NULS, AA)) THEN
              ULINE=ZUL
            ELSEIF (NUMBRS('R', INP, STT, ILN, AA)) THEN
              READ (INP(STT:ILN),125) ULPOS
            ELSE
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ENDIF
C
C CPI - CHARACTERS PER INCH - - - - - - - - - - - - - - - ##### IF # CPI #
C
C AFFECTS CPI, SIZCHR, XCHR, YCHR, XNUM
C
          ELSEIF (J.EQ.14) THEN
            IF (BANN .AND. (BAN.EQ.'B')) THEN
              CALL FLINE
              WRITE (ME,184) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J)
              GOODO=.FALSE.
            ELSE
              IF (RESTORE) THEN
                ENCODE(7, 153, INP(STT:STT), NCX) XCPI
                ILN=STT+NCX-2
              ENDIF
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) VALS(J)
                IF ((VALS(J).LT.VMIN(J)) .OR. (VALS(J).GT.VMAX(J))) THEN
                  CALL FLINE
                  WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
  187             FORMAT (5X,'File ',A,' Line ',A,': ',A,' entry "',
     &             A, '" is outside the valid range.')
                  GOODO=.FALSE.
                ELSE
                  ZSIZCHR=.997/CPI
                  XCHRZ=1.66667*ZSIZCHR*FONTFAM(FON)
                  IF (DEFCHT) THEN
                    YCHRZ=MIN(1.05*XCHRZ,SIZLN*CHARSIZ*FONTFAM(FON))
                  ELSE
                    YCHRZ=SIZLN*CHARSIZ*FONTFAM(FON)
                  ENDIF
C
C DO WE NEED A NEW FONT DEFINITION LINE?
C
                  IF (((MAX(XCHR,XCHRO)-MIN(XCHR,XCHRO).GT.0.001) .OR.
     &               (MAX(YCHR,YCHRO)-MIN(YCHR,YCHRO).GT.0.001)) .AND.
     &               GOODO) THEN
                    XCHRO=XCHR
                    YCHRO=YCHR
                    SIZCHR=ZSIZCHR
                    XCHR=XCHRZ
                    YCHR=YCHRZ
                    NUFONT=.TRUE.
                  ENDIF
                ENDIF
              ELSE
C
C BAD CHARACTERS
C
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C HML - HORIZONTAL MARGIN LEFT - - - - - - - - - - - - - -##### IF # HML #
C
C AFFECTS HML
C
          ELSEIF (J.EQ.15) THEN
            IF (RESTORE) THEN
              ENCODE(7, 153, INP(STT:STT), NCX) XHML
              ILN=STT+NCX-2
              CURVAL=' '
            ENDIF
C
C OBTAIN FROM FIRST ELEMENT OF A SAV BUFFER?
C
            IF ((CURVAL.GE.'A') .AND. (CURVAL.LE.'Z')) THEN
              BFSH=ICHAR(CURVAL)
              VALS(J)=SAVBF(1,BFSH)
            ELSE
C
C OBTAIN FROM NUMERIC ENTRY?
C
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) VALS(J)
                IF ((VALS(J).LT.VMIN(J)) .OR.
     &             (VALS(J).GT.VMAX(J))) THEN
                  CALL FLINE
                  WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                  GOODO=.FALSE.
                ENDIF
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C LPI - LINES PER INCH - - - - - - - - - - - - - - - - - -##### IF # LPI #
C
C AFFECTS LPI, SIZLN, YCHR, TOF, NUFON
C
          ELSEIF (J.EQ.16) THEN
            IF (RESTORE) THEN
              ENCODE(7, 153, INP(STT:STT), NCX) XLPI
              ILN=STT+NCX-2
            ENDIF
            IF (BANN .AND. (BAN.EQ.'B')) THEN
              CALL FLINE
              WRITE (ME,184) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J)
              GOODO=.FALSE.
            ELSE
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) VALS(J)
                IF ((VALS(J).LT.VMIN(J)) .OR.
     &             (VALS(J).GT.VMAX(J))) THEN
                  CALL FLINE
                  WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                  GOODO=.FALSE.
                ENDIF
                SIZLN=1./LPI
                YCHRO=YCHR
                IF (DEFCHT) THEN
                  YCHR=MIN(1.05*XCHR,SIZLN*CHARSIZ*FONTFAM(FON))
                ELSE
                  YCHR=SIZLN*CHARSIZ*FONTFAM(FON)
                ENDIF
C
C DO WE NEED A NEW FONT DEFINITION LINE?
C
                IF ((MAX(YCHR,YCHRO)-MIN(YCHR,YCHRO).GT.0.001) .AND.
     &             GOODO) THEN
                  NUFONT=.TRUE.
                ENDIF
C
C NOW BELOW END OF PAGE?
C
                IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
C
C PAGE NUMBER LOCATION CHANGE?
C
                IF (PAGNUM) THEN
                  YNUM=VMBO
                  VMB=VMBO+(2.*SIZLN)
                ENDIF
C
C BAD CHARACTERS
C
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C VMB - VERTICAL MARGIN BOTTOM - - - - - - - - - - - - - -##### IF # VMB #
C
C AFFECTS VMB, PAGNUM, YNUM, VMBO
C
          ELSEIF (J.EQ.17) THEN
            IF (RESTORE) THEN
              ENCODE(7, 153, INP(STT:STT), NCX) XVMB
              ILN=STT+NCX-2
            ENDIF
            IF (NUMBRS('R', INP, STT, ILN, A)) THEN
              READ (INP(STT:ILN),150) VALS(J)
              IF ((VALS(J).LT.VMIN(J)) .OR. (VALS(J).GT.VMAX(J))) THEN
                CALL FLINE
                WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
              VMB=VMB-.0001
              IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
              VMBO=VMB
C
C PAGE NUMBER LOCATION CHANGE?
C
              IF (PAGNUM) THEN
                YNUM=VMBO
                VMB=VMBO+(2.*SIZLN)
              ENDIF
C
C BAD CHARACTERS
C
            ELSE
              CALL FLINE
              WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ENDIF
C
C VMT - VERTICAL MARGIN TOP - - - - - - - - - - - - - - - ##### IF # VMT #
C
C AFFECTS VMT, YPOS, TOF
C
          ELSEIF (J.EQ.18) THEN
            IF (RESTORE) THEN
              ENCODE(7, 153, INP(STT:STT), NCX) XVMT
              ILN=STT+NCX-2
              CURVAL=' '
            ENDIF
C
C OBTAIN FROM SECOND ELEMENT OF A SAV BUFFER
C AND OFFSET FROM PAPER TOP?
C
            IF ((CURVAL.GE.'A') .AND.
     &         (CURVAL.LE.'Z')) THEN
              BFSM=ICHAR(CURVAL)
              YPOS=SAVBF(2,BFSM)-SIZLN
              IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
              VALS(J)=PHT-SAVBF(2,BFSM)
            ELSE
C
C OBTAIN FROM NUMERIC INPUT?
C
              IF (NUMBRS('R', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) VALS(J)
                IF ((VALS(J).LT.VMIN(J)) .OR.
     &             (VALS(J).GT.VMAX(J))) THEN
                  CALL FLINE
                  WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                  GOODO=.FALSE.
                ENDIF
                YPOS=PHT-VMT-SIZLN
                IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C CHA - CHANGE CHARACTER SIZE FACTOR - - - - - - - - - - -##### IF # CHA #
C
C AFFECTS CHARSIZ
C
          ELSEIF (J.EQ.19) THEN
            IF (NUMBRS('R', INP, STT, ILN, A)) THEN
              READ (INP(STT:ILN),150) VALS(J)
              IF ((VALS(J).LT.VMIN(J)) .OR.
     &           (VALS(J).GT.VMAX(J))) THEN
                CALL FLINE
                WRITE (ME,187) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ELSE
                VALS(J)=1.5*VALS(J)
                DEFCHT=.FALSE.
              ENDIF
            ELSE
C
C DEFAULT?
C
              IF (UCASE(INP(STT:STT+2)).EQ.'DEF') THEN
                DEFCHT=.TRUE.
                CHARSIZ=1.
C
C BAD CHARACTERS
C
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C IS THERE A CHANGE TO BE MADE?
C
            IF (GOODO) THEN
              XCHRO=XCHR
              YCHRO=YCHR
              XCHR=1.66667*SIZCHR*FONTFAM(FON)
              YCHR=SIZLN*CHARSIZ*FONTFAM(FON)
C
C DO WE NEED A NEW FONT DEFINITION LINE?
C
              IF (((MAX(XCHR,XCHRO)-MIN(XCHR,XCHRO).GT.0.001) .OR.
     &           (MAX(YCHR,YCHRO)-MIN(YCHR,YCHRO).GT.0.001)) .AND.
     &           GOODO) THEN
                NUFONT=.TRUE.
              ENDIF
            ENDIF
C
C LIN - CHANGE LINE NUMBER - - - - - - - - - - - - - - - -##### IF # LIN #
C
C AFFECTS NR, TOF
C
          ELSEIF (J.EQ.20) THEN
C
C CONTINUED LINE? (TREAT AS HONEYWELL VFC '@')
C
            IF (UCASE(INP(STT:STT+2)).EQ.'CON') THEN
              CPP=.TRUE.
            ELSEIF (NUMBRS('S', INP, STT, ILN, A)) THEN
              READ (INP(STT:ILN),125) LIN
C
C RELATIVE (SIGNED) OR ABSOLUTE?
C IF ABSOLUTE, CHANGE FROM INDEX TO OFFSET (FIRST LINE IS 0)
C
              IF ((INP(STT:STT).EQ.'-') .OR.
     &           (INP(STT:STT).EQ.'+')) THEN
                NR=NR+LIN
              ELSE
                NR=LIN-1
              ENDIF
C
C END OF PAGE?  (EJECT IT IF BANNER SHEET)
C
              IF (YPOS-(NR*SIZLN).LT.VMB) THEN
                IF (BANN) THEN
                  CALL TOP
                ELSE
                  TOF=.TRUE.
                ENDIF
              ENDIF
            ELSE
C
C BAD CHARACTERS
C
              CALL FLINE
              WRITE (ME,191) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
  191         FORMAT (5X, 'File ', A, A, ': ', A,
     &         ' requires integer entry; "', A, '" is invalid.')
              GOODO=.FALSE.
            ENDIF
C
C PGN - SETS CURRENT PAGE NUMBER - - - - - - - - - - - - -##### IF # PGN #
C
C AFFECTS NPG
C
          ELSEIF (J.EQ.21) THEN
            IF (NUMBRS('P', INP, STT, ILN, A)) THEN
              READ (INP(STT:ILN),125) NPG
              NPG=NPG-1
            ELSE
              CALL FLINE
              WRITE (ME,192) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
  192         FORMAT (5X,'File ',A,' Line ',A,': ',A,' requires ',
     &         ' positive nonzero integers; "', A, '" is invalid.')
              GOODO=.FALSE.
            ENDIF
C
C IGN - IGNORE THE NEXT GROUP OF LINES - - - - - - - - - -##### IF # IGN #
C
C AFFECTS NPG
C
          ELSEIF (J.EQ.22) THEN
            IF (NUMBRS('I', INP, STT, ILN, A)) THEN
              READ (INP(STT:ILN),125) NIGN
              CALL SKIPREC (UIN1, NIGN, OOPS)
              IF (OOPS.NE.0) GOTO 1181
            ELSE
              CALL FLINE
              WRITE (ME,191) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ENDIF
C
C SAV - PLACE DATA INTO LOCATION BUFFERS - - - - - - - - -##### IF # SAV #
C
C AFFECTS SAVBF
C
          ELSEIF (J.EQ.23) THEN
            IF ((CURVAL.LT.'A') .OR.
     &         (CURVAL.GT.'Z')) THEN
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ELSE
              BFSV=ICHAR(CURVAL)
              SAVBF(1,BFSV)=X
              SAVBF(2,BFSV)=Y
            ENDIF
C
C SET - PLACE PRINT ORIGIN AT SPECIFIED LOCATION - - - - -##### IF # SET #
C
          ELSEIF (J.EQ.24) THEN
            NOVAL=.TRUE.
C
C NUMERIC VALUE OR OFFSET?   IF ")" LOOK FOR "(" AFTER "=".
C
            IF (CURVAL.EQ.')') THEN
              PARL=FINDEQ (INP, STT, ILN-1, '(')
              IF (PARL.EQ.0) THEN
                CALL FLINE
                WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                GOODO=.FALSE.
              ELSE
C
C GET VALUES
C
C NUMBERS?
C
                IF (NUMBRS('r', INP, PARL+1, ILN-1, A)) THEN
                  READ (INP(PARL+1:PARR-1),150) XI, YI
                  NOVAL=.FALSE.
                ELSE
C
C BUFFER?
C
                  ILO=FINDNE (INP, ILN-1, PARL+1, ' ')
                  IF (ILO.EQ.0) THEN
                    CALL FLINE
                    WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &               QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
                    GOODO=.FALSE.
                  ELSE
                    CURVAL=UCASE(INP(ILO:ILO))
                    IF ((CURVAL.GE.'A') .AND.
     &                 (CURVAL.LE.'Z')) THEN
                      BNST=ICHAR(CURVAL)
                      XI=SAVBF(1,BNST)
                      YI=SAVBF(2,BNST)
                    ELSE
                      CALL FLINE
                      WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &                 QQ(1:QL),OPT(J),INP(STT:MIN(ILN,STT+20))
                      GOODO=.FALSE.
                    ENDIF
                  ENDIF
                ENDIF
C
C GET NEW CURVAL JUST BEFORE THE (
C
                ILN=FINDNE (INP, PARL-1, STT, ' ')
                IF (ILN.NE.0) CURVAL=UCASE(INP(ILN:ILN))
              ENDIF
            ELSE
              XI=0.
              YI=0.
            ENDIF
C
C BUFFER?
C
            IF ((ILN.NE.0) .AND. (CURVAL.GE.'A').AND.
     &         (CURVAL.LE.'Z')) THEN
              BNST=ICHAR(CURVAL)
              XI=XI+SAVBF(1,BNST)
              YI=YI+SAVBF(2,BNST)
C
C ERROR ONLY IF WE HAVE NOT OBTAINED A NUMERIC VALUE
C
            ELSEIF (NOVAL) THEN
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)),
     &         QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+20))
              GOODO=.FALSE.
            ENDIF
            SETPOS=.TRUE.
C
C SCA - SCAN FOR THIS CHARACTER - - - - - - - - - - - - - ##### IF # SCA #
C
C AFFECTS SCAN
C
          ELSEIF (J.EQ.25) THEN
            IF (TXTOK(CURVAL, SCANTX, NSCAN, POS)) THEN
              STAB(ICHAR(CURVAL))='P'
            ELSE
              CALL FLINE
              WRITE (ME,175) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &         OPT(J), INP(ILN:ILN)
            ENDIF
C
C INC - INCLUDE A FILE AT THIS POINT - - - - - - - - - - -##### IF # INC #
C
C NO EFFECT ON PARAMETERS
C
          ELSEIF (J.EQ.26) THEN
C
C PS OR GRAPHIC FILE?  FIND A ( .
C
            PAR=FINDEQ (INP, STT, ILN, '(')
            IF (PAR.EQ.0) THEN
C
C POSTSCRIPT
C
              OPEN (USAGE='INPUT,SHARED',
     &         UNIT=UIN2,FILE=INP(STT:ILN),STATUS='OLD',IOSTAT=IOS)
              IF (IOS.EQ.0) THEN
                DO 1146 K=1,99999
                READ (UIN2, 164, END=1147) TMP
                INQUIRE (UNIT=UIN2, RECSIZE=JLN)
                WRITE (UOUT,165) TMP(1:JLN)
 1146           CONTINUE
 1147           CONTINUE
                CLOSE (UIN2, STATUS='KEEP')
              ELSE
                IOS=IOSDCODE(IOS)
                CALL FLINE
                WRITE (ME,182) FID(NF)(1:MIN(FIDL(NF),20)),QQ(1:QL),
     &           INP(STT:MIN(ILN,STT+20)), IOS
                GOODO=.FALSE.
              ENDIF
            ELSE
C
C GRAPHIC FILE
C
C FIND START OF OPTIONS AND GET TYPE
C
              POS=FINDNE (INP, PAR+1, ILN, ' ')
              IF (TXTOK(UCASE(INP(POS:POS+2)),INCTX,NINCL,GTYP)) THEN
C
C FILE EXIST?
C
                FLE=FINDNE (INP, PAR-1, STT, ' ')
                OPEN (UIN2, FILE=INP(STT:FLE), USAGE='INPUT,SHARED',
     &           STATUS='OLD', IOSTAT=IOS)
C
C EXTRACT VALUES
C
                IF (IOS.EQ.0) THEN
                  STX=FINDEQ (INP, FLE+1, ILN, ' ')
                  IF (NUMBRS('r', INP, STX, ILN-1, KI)) THEN
                    READ (INP(STX:ILN),150) ZX, ZY, ZANG, ZSC
C
C CALL GRAPHIC ROUTINE
C
                    IF (GTYP.EQ.1) THEN
                      CALL XRCIS4USR (UIN2, ZX, ZY, ZANG, ZSC)
                    ENDIF
C
C CLEANUP
C
                    CLOSE (UIN2, STATUS='KEEP')
                    WRITE (UOUT,197) -ZX, -ZY, -ZANG
  197               FORMAT ('  72 72 scale ',2F8.3, ' translate ',
     &               F7.1, ' rotate')
C
C BAD DIGITS
C
                  ELSE
                    CALL FLINE
                    WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &               QQ(1:QL), OPT(J), INP(STX:MIN(ILN-1,STX+20))
                    GOODO=.FALSE.
                  ENDIF
C
C BAD FILE
C
                ELSE
                  IOS=IOSDCODE(IOS)
                  CALL FLINE
                  WRITE (ME,182) FID(NF)(1:MIN(FIDL(NF),20)),
     &             QQ(1:QL), INP(STT:MIN(FLE,STT+20)), IOS
                  GOODO=.FALSE.
                ENDIF
C
C BAD GRAPHIC FILE TYPE
C
              ELSE
                CALL FLINE
                WRITE (ME,198) FID(NF)(1:MIN(FIDL(NF),20)),QQ(1:QL),
     &           INP(POS:POS+2)
  198           FORMAT (5X, 'File ', A, A,
     &           ': INC does not support "', A, '" graphic files.')
                GOODO=.FALSE.
              ENDIF
            ENDIF
C
C BOR - DRAW A BORDER - - - - - - - - - - - - - - - - - - ##### IF # BOR #
C
C AFFECTS IGNREC
C
          ELSEIF (J.EQ.27) THEN
            IF (UCASE(INP(STT:STT+2)).EQ.'DRA') THEN
              IF (NBOR.LE.0) THEN
                CALL FLINE
                WRITE (ME,199) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL)
  199           FORMAT (5X, 'File ', A, A, ': BORDER=DRAW appears',
     &           ' without prior setup.')
                GOODO=.FALSE.
              ELSE
C
C GET NEXT RECORD FOR BOTTOM-LINE INDICATION
C
                ILN=475
                CALL FAST$READ (IOS, UIN1, INP, 475, ILN,
     &           DVBYTE, EOMCHAR, KB, 31)
                IF (IOS.NE.0) THEN
                  IF (IOSDCODE(IOS).EQ.6) THEN
                    GOTO 1181
                  ELSE
                    GOTO 1205
                  ENDIF
                ENDIF
                NI=NI+1
                LEN=ILN
                NR=NR+1
                A=FINDEQ (INP, 1, LEN, '-')
                IF (A.EQ.0) NOBOT(NBOR)=.TRUE.
                YBOR(2,NBOR)=YPOS-(NR*SIZLN)+(0.3*SIZLN)
C
C SIDES ONLY
C
                IF (NOBOT(NBOR) .AND. NOTOP(NBOR)) THEN
                  WRITE (UOUT,200) ZBOR(NBOR),
     &             XBOR(1,NBOR), YBOR(1,NBOR),
     &             XBOR(1,NBOR), YBOR(2,NBOR),
     &             XBOR(2,NBOR), YBOR(1,NBOR),
     &             XBOR(2,NBOR), YBOR(2,NBOR)
  200             FORMAT (' newpath', F7.3, ' setlinewidth',
     &             2F7.3, ' moveto', 2F7.3, ' lineto',
     &             2F7.3, ' moveto', 2F7.3, ' lineto stroke')
                  NOBOT(NBOR)=.FALSE.
                  NOTOP(NBOR)=.FALSE.
C
C NO BOTTOM LINE
C
                ELSEIF (NOBOT(NBOR)) THEN
                  WRITE (UOUT,201) ZBOR(NBOR),
     &             XBOR(1,NBOR), YBOR(2,NBOR),
     &             XBOR(1,NBOR), YBOR(1,NBOR),
     &             XBOR(2,NBOR), YBOR(1,NBOR),
     &             XBOR(2,NBOR), YBOR(2,NBOR), ' '
  201             FORMAT (' newpath', F7.3, ' setlinewidth',
     &             2F7.3,' moveto',2F7.3,' lineto',2F7.3,' lineto',
     &             2F7.3, ' lineto', A, 'stroke')
                  NOBOT(NBOR)=.FALSE.
C
C NO TOP LINE
C
                ELSEIF (NOTOP(NBOR)) THEN
                  WRITE (UOUT,201) ZBOR(NBOR),
     &             XBOR(1,NBOR), YBOR(1,NBOR),
     &             XBOR(1,NBOR), YBOR(2,NBOR),
     &             XBOR(2,NBOR), YBOR(2,NBOR),
     &             XBOR(2,NBOR), YBOR(1,NBOR), ' '
                  NOTOP(NBOR)=.FALSE.
C
C FULL BOX
C
                ELSE
                  WRITE (UOUT,201) ZBOR(NBOR),
     &             XBOR(1,NBOR), YBOR(2,NBOR),
     &             XBOR(1,NBOR), YBOR(1,NBOR),
     &             XBOR(2,NBOR), YBOR(1,NBOR),
     &             XBOR(2,NBOR), YBOR(2,NBOR),
     &             ' closepath '
                ENDIF
                NBOR=NBOR-1
              ENDIF
C
C SETUP.  GET Y LOCATION, AND NEXT RECORD FOR X LOCATIONS
C
            ELSE
              IF (NUMBRS('F', INP, STT, ILN, A)) THEN
                READ (INP(STT:ILN),150) ZZ
              ELSE
                CALL FLINE
                WRITE (ME,185) FID(NF)(1:MIN(FIDL(NF),20)),
     &           QQ(1:QL), OPT(J), INP(STT:MIN(ILN,STT+21))
                GOODO=.FALSE.
              ENDIF
              ILN=475
              CALL FAST$READ (IOS, UIN1, INP, 475, ILN,
     &         DVBYTE, EOMCHAR, KB, 31)
              IF (IOS.NE.0) THEN
                IF (IOSDCODE(IOS).EQ.6) THEN
                  GOTO 1181
                ELSE
                  GOTO 1205
                ENDIF
              ENDIF
              NI=NI+1
              LEN=ILN
              NR=NR+1
C
C LOCATE '+' FOR CORNERS
C
              PLS=FINDEQ (INP, 1, LEN, '+')
              PLS2=FINDEQ (INP, PLS+1, LEN, '+')
              IF (PLS+PLS2.EQ.0) THEN
                CALL FLINE
                WRITE (ME,202) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL)
  202           FORMAT (5X, 'File ', A, A, ': Bad BORDER setup line.')
                GOODO=.FALSE.
              ELSE
                NBOR=NBOR+1
                IF (NBOR.GT.MAXBOR) THEN
                  CALL FLINE
                  WRITE (ME,203) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL)
  203             FORMAT (5X,'File ',A,A,': Too many nested borders.')
                  GOODO=.FALSE.
                ELSE
C
C LOCATE - FOR TOP LINE INDICATOR
C
                  A=FINDEQ (INP, PLS, PLS2, '-')
                  IF (A.EQ.0) NOTOP(NBOR)=.TRUE.
                  YBOR(1,NBOR)=YPOS-(FLOAT(NR)*SIZLN)+(0.3*SIZLN)
                  XBOR(1,NBOR)=HML+((FLOAT(PLS)-.5)*XCHSIZ)
                  XBOR(2,NBOR)=HML+((FLOAT(PLS2)-.5)*XCHSIZ)
                  ZBOR(NBOR)=ZZ
                ENDIF
              ENDIF
            ENDIF
C
C WE HAVE A MATCH; TERMINATE INNER LOOP - - - - - - - - - - - - ##### IF #
C
          ENDIF
          GOTO 1151
        ENDIF
 1150   CONTINUE
C
C BAD OPTION
C
        CALL FLINE
        WRITE (ME,204) FID(NF)(1:MIN(FIDL(NF),20)), QQ(1:QL),
     &   INP(ST:MIN(ILN,ST+20))
  204   FORMAT (5X, 'File ', A, A, ': "', A,
     &   '" is a bad option specification.')
        GOODO=.FALSE.
 1151   CONTINUE
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C DO WE HAVE POSTSCRIPT COMMANDS HERE?
C
C IS THIS POSTSCRIPT TEXT AS DEFINED BY THE IN-FILE OPTION?
C
      ELSEIF (PSCIF .AND. GOODO.AND.(LEN.GT.2)) THEN
        ST=FINDNE (INP, 2, LEN, ' ')
        WRITE (UOUT,165) INP(ST:LEN)
C
C IS THIS POSTSCRIPT TEXT AS DEFINED BY THE COMMAND-LINE OPTION?
C
      ELSEIF (PSCCL .AND. GOODO.AND.(LEN.GT.2).AND.
     &   ((INP(1:1).EQ.PSC) .OR. (INP(2:2).EQ.PSC))) THEN
        IF (INP(1:1).NE.'\') THEN
          ST=3
        ELSE
          ST=2
        ENDIF
        STT=FINDNE (INP, ST, LEN, ' ')
        WRITE (UOUT,165) INP(STT:LEN)
      ELSE
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C NOT A POSTSCRIPT OR COMMAND LINE.  MUST BE A DATA LINE FOR PRINTING.
C
C GET THE LAST PRINTABLE CHARACTER IN THE LINE
C (IF NONE OR IF COMMAND LINE, SKIP ALL TESTING AND OUTPUT)
C THE SEARCH$ ROUTINE WORKS WITH OFFSETS INSTEAD OF INDICES IN THE TEXT
C STRING; STT AND II ARE OFFSETS (0-BASED), ALL OTHER LOCATIONS ARE
C INDICES (1-BASED).
C
        IF (GOODO) THEN
          ILN=FINDNE (INP, LEN, 1, ' ')
          IF (ILN.GE.ST) THEN
            OVSTRK=.FALSE.
C
C NON-NULL RECORD TO BE PRINTED
C
            IF (ILN.GT.ST) THEN
C
C NON-NULL RECORD.  SEARCH THE RECORD FOR BACKSPACES, TRANSLATIONS,
C AND SPECIAL CHARACTERS THAT POSTSCRIPT NEEDS TO HAVE PRECEDED
C WITH A \ CHARACTER (IF THEY ARE BEING SCANNED FOR, WHICH IS DEFAULT).
C
              ICH=ST
              STT=ST-1
              NV=0
              REPEAT 1170, WHILE (ICH.NE.0)
C
C LOOK FOR CHARACTERS THAT REQUIRE MUNGING
C
              CALL SEARCH$ (II, ICH, STAB, INP, ILN, STT)
              IF (ICH.NE.0) THEN
                I=II+1
                CHR=CHAR(ICH)
C
C TRANSLATE:  REPLACE TRNCHR AND PREVIOUS CHARACTER WITH
C \ AND OCTAL DIGITS
C
                IF (CHR.EQ.'T') THEN
C
C IF FIRST CHARACTER IN LINE, IGNORE IT
C
                  IF (I.EQ.ST) THEN
                    JLN=ILN
                    ILN=ILN-1
                    TMP(I:ILN)=INP(I+1:JLN)
                    INP(I:ILN)=TMP(I:ILN)
                  ELSE
C
C IF BLANK-TRNCHR, IGNORE; OTHERWISE, ERROR
C MESSAGE IF TRANSLATES TO BLANK
C
                    NUM=ICHAR(INP(I-1:I-1))
                    IF ((TTABLE(NUM).EQ.'\040') .AND.
     &                 (NUM.NE.32)) THEN
                      CALL FLINE
                      WRITE (ME,205) FID(NF)(1:MIN(FONL(NF),20)),
     &                 QQ(1:QL), INP(I+1:I+1), TRNCHR
  205                 FORMAT (5X, 'File ', A, A,
     &                 ': No translation for "', 2A, '".')
                    ENDIF
C
C EXTEND TO RIGHT BEFORE INSERTION
C
                    IF (I.LT.ILN) THEN
                      ILN=ILN+2
                      JLN=ILN
                      TMP(I+1:JLN)=INP(I+1:JLN)
                      INP(I+3:ILN)=TMP(I+1:JLN)
                    ELSE
                      ILN=ILN+2
                    ENDIF
                    INP(I-1:I+2)=TTABLE(NUM)
                    SPOS=MIN(SPOS,I-1)
                    STT=I+2
                  ENDIF
C
C FOUND:   ()\ WHICH NEED \ PUT IN FRONT.  (THE INSERTED
C \ WILL NOT COUNT AS A CHARACTER FOR OVERSTRIKING TESTS)
C FIX UP THE LENGTH AND EXPAND ONE SPACE RIGHTWARDS.
C
                ELSEIF (CHR.EQ.'P') THEN
                  JLN=ILN
                  ILN=ILN+1
                  TMP(I:JLN)=INP(I:JLN)
                  INP(I+1:ILN)=TMP(I:JLN)
C
C INSERT THE \ AND KICK ITS COUNTER
C THEN INCREMENT THE POINTER (SO WE DON'T LOOK AT THE
C SAME CHARACTER AGAIN) AND SKIP TO ANOTHER ITERATION
C
                  INP(I:I)='\'
                  NV=NV+1
                  STT=I+1
C
C BACKSPACE:  BLANK THE OVERSTRIKE LINE BUFFER IF NOT
C ALREADY DONE.  START THE BACKSPACE COUNTER.
C
                ELSEIF (CHR.EQ.'B') THEN
                  NB=1
                  IF (.NOT.OVSTRK) THEN
                    OVSTBUF=' '
                    OVSTRK=.TRUE.
                  ENDIF
C
C COUNT THE NUMBER OF CONSECUTIVE BACKSPACES
C
                  DO 1165 J=I+1,ILN
                  IF (INP(J:J).EQ.BS) THEN
                    NB=NB+1
                  ELSE
                    GOTO 1166
                  ENDIF
 1165             CONTINUE
 1166             CONTINUE
C
C MOVE THE NEXT 'NB' CHARACTERS INTO THE OVERSTRIKE LINE BUFFER, TO
C OVERPRINT PREVIOUS 'NB' CHARACTERS IN NORMAL LINE.  SET THE LENGTH
C OF THE OVERSTRIKE LINE IGNORING THE \'S INSERTED.
C
                  OVSTBUF(I-NB-NV:I-1-NV)=INP(J:J+NB-1)
                  ILN2=I-1-NV
C
C CLOSE UP THE NORMAL LINE TO ELIMINATE 'NB' BACKSPACES
C AND 'NB' OVERSTRIKING CHARACTERS
C
                  NB=NB*2
                  JLN=ILN
                  ILN=ILN-NB
                  TMP(I:ILN)=INP(I+NB:JLN)
                  INP(I:ILN)=TMP(I:ILN)
C
C DECREMENT ACTUAL LINE LENGTH TO REFLECT REMOVED CHARACTERS
C
                  LEN=LEN-NB
C
C WE HAVE PUT A NEW CHARACTER AT POSITION 'I' IN THE
C INPUT STRING.  LOOK AT THIS POSITION AGAIN.
C
                  STT=I-1
                ENDIF
              ENDIF
 1170         CONTINUE
            ENDIF
C
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C NOW WE ARE ALMOST READY TO PRINT A LINE.  GET THE POSITION
C OF THIS LINE ON THE PAPER
C
C IF A SET POSITION LINE, IGNORE ALL UPSPACING AND CPP, AND
C JUST PLACE IT THERE.
C
            IF (SETPOS) THEN
              X=XI
              Y=YI
            ELSE
              IF (JUST.EQ.1) THEN
                X=PWD/2.
              ELSEIF (JUST.EQ.2) THEN
                X=HML
              ELSE
                X=PWD-HML
              ENDIF
C
C UPSPACE BEFORE PRINTING.  ARE WE STILL ON THE PAGE?
C
              IF (.NOT.(CPP .AND. .NOT.SETPOS)) THEN
                NR=NR+NUS
                IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
              ENDIF
C
C GO TO TOP OF FORM?
C
C NOT IF THIS IS THE TOP OF FIRST PAGE, AND BANNER OVERLAY
C OR 'BOTTOM OF PAGE' VFC IS IN EFFECT OR WAS AT PREVIOUS LINE
C
              IF (TOF) THEN
                IF (.NOT.(FPAGE .AND. (BANN .OR. (IND.EQ.26) .OR.
     &             (INDOLD.EQ.26)))) THEN
                  CALL TOP
                ENDIF
                TOF=.FALSE.
              ENDIF
              Y=YPOS-(NR*SIZLN)
            ENDIF
C
C DO WE HAVE A NEW FONT DEFINITION TO OUTPUT (AND REDEFINE SPACE SPACE)?
C NOT IF THIS IS THE BANNER PAGE AND USING BANNER-PAGE FONT
C
            IF (NUFONT .AND. (BAN.NE.'B')) THEN
              WRITE (UOUT,206) FONT(FON)(1:FONL(FON)),XCHR,YCHR,ULPOS
  206         FORMAT (2X, '/', A, ' findfont [', F.3, '0 0 ', F.3,
     &         '0 0] makefont setfont currentfont getulmetrics ',
     &         '/ulthk exch def /ulpos exch def /ulfdg', F5.2,
     &         ' def')
              WRITE (FBUF,207) XCHR
  207         FORMAT (F5.3)
              READ (FBUF,207) XCHSIZ
              XCHSIZ=XCHSIZ/1.66667/FONTFAM(FON)
              NUFONT=.FALSE.
            ENDIF
C
C DO WE HAVE A NEW PAPER ROTATION TO SPECIFY (NOT IF AT TOF)?
C
            IF (ROTATE.EQ.'+') THEN
              WRITE (UOUT,208) PSIZ(NPAP,2)
  208         FORMAT (F6.1, ' 0 translate 90 rotate')
              ROTATE=' '
            ELSEIF (ROTATE.EQ.'-') THEN
              WRITE (UOUT,209) -PSIZ(NPAP,2)
  209         FORMAT ('  -90 rotate', F6.1, ' 0 translate')
              ROTATE=' '
            ENDIF
C
C OUTPUT NORMAL LINE, AFTER OFFSETTING FOR LEADING SPACES
C IF CURRENT POSITION, DO NOT MOVE TO
C
            IF (CPP .AND. .NOT.SETPOS) THEN
              WRITE (UOUT,211) INP(ST:ILN)
  211         FORMAT ('  (', A, ') show')
              PUS=0
            ELSE
              IF ((SPOS.GT.ST) .AND. (JUST.EQ.2)) THEN
                WRITE (UOUT,212) X+((SPOS-ST)*XCHSIZ), Y,
     &           INP(SPOS:ILN), JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
  212           FORMAT (2X, 2F.3, 'moveto (', A, ') ', A)
              ELSEIF ((SPOS.GT.ST) .AND. (JUST.EQ.3)) THEN
                WRITE (UOUT,212) X, Y,
     &           INP(SPOS:ILN), JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
              ELSE
                WRITE (UOUT,212) X, Y, INP(ST:ILN),
     &           JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
              ENDIF
            ENDIF
C
C OUTPUT OVERSTRIKE LINE BUFFER, AFTER OFFSETTING FOR LEADING BLANKS
C IF CURRENT POSITION, DO NOT MOVE TO
C
            IF (OVSTRK) THEN
              IF (CPP .AND. .NOT.SETPOS) THEN
                WRITE (UOUT,211) OVSTBUF(ST:ILN)
                PUS=0
              ELSE
                POS=FINDNE (OVSTBUF, ST, ILN2, ' ')
                IF ((POS.GT.ST) .AND. (JUST.EQ.2)) THEN
                  WRITE (UOUT,212) X+((POS-ST)*XCHSIZ), Y,
     &             OVSTBUF(POS:ILN2),
     &             JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
                ELSEIF ((POS.GT.ST) .AND. (JUST.EQ.3)) THEN
                  WRITE (UOUT,212) X, Y,
     &             OVSTBUF(POS:ILN),
     &             JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
                ELSEIF ((JUST.EQ.1) .OR. (JUST.EQ.3)) THEN
                  WRITE (UOUT,212) X, Y, OVSTBUF(ST:ILN),
     &             JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
                ELSE
                  WRITE (UOUT,212) X, Y, OVSTBUF(ST:ILN2),
     &             JUSTS(JUST,ULINE)(1:JUSL(JUST,ULINE))
                ENDIF
              ENDIF
            ENDIF
C
C CLEAR 'CURRENT POSITION' IF TRUE
C
            IF (CPP .AND. .NOT.SETPOS) CPP=.FALSE.
C
C NULL RECORD.  ADD THE PREPRINT UPSPACES AND CHECK
C TO SEE IF WE ARE STILL ON THE PAGE.
C
          ELSE
            IF (.NOT.SETPOS) THEN
              NR=NR+NUS
              IF (YPOS-(NR*SIZLN).LT.VMB) TOF=.TRUE.
            ENDIF
C
C GO TO TOP OF FORM?
C
C NOT IF THIS IS THE TOP OF FIRST PAGE, AND BANNER OVERLAY
C OR 'BOTTOM OF PAGE' VFC IS IN EFFECT OR WAS AT PREVIOUS LINE
C
            IF (TOF) THEN
              IF (.NOT.(FPAGE .AND. (BANN .OR. (IND.EQ.26) .OR.
     &           (INDOLD.EQ.26)))) THEN
                CALL TOP
              ENDIF
              TOF=.FALSE.
            ENDIF
          ENDIF
C
C WE CAN NEVER BE AT THE TOP OF THE FIRST PAGE AGAIN...
C (BUT WE AREN'T THERE YET IF WE ARE AT BOTTOM OF PAGE)
C
          IF (IND.NE.26) THEN
            FPAGE=.FALSE.
          ENDIF
        ENDIF
C
C ADD THE POST-PRINTING UPSPACES AND SEE IF WE ARE STILL ON THE PAGE
C
        IF (SETPOS) THEN
          SETPOS=.FALSE.
        ELSE
          NR=NR+PUS
          IF ((YPOS-(NR*SIZLN).LT.VMB) .AND. GOODO) CALL TOP
        ENDIF
      ENDIF
 1180   CONTINUE
 1181   CONTINUE
        CALL FAST$CLOSE (IOS, UIN1, 2)
      IF (TEXTED) THEN
        WRITE (ME,165) ' '
        CALL DO$CMD ('!DELETE *LASP')
        TEXTED=.FALSE.
      ENDIF
 1182   CONTINUE
C
C ERRORS AND ENDS
C
      END=.TRUE.
        CALL TOP
C
C POSTSCRIPT CLEANUP
C
      IF (GOODO) THEN
        CLOSE (UOUT, STATUS='KEEP')
        IF (LDV) THEN
          CALL DO$CMD (PNTLZR)
        ENDIF
        CALL EXIT(0)
      ELSE
        CLOSE (UOUT,STATUS='DELETE')
        IF (LDV) THEN
          CALL DO$CMD (DELLZR)
        ENDIF
        CALL EXIT(2)
      ENDIF
C
C FILE WAS AVAILABLE BUT IS NOT NOW
C
 1205 CONTINUE
      IOS=IOSDCODE(IOS)
      WRITE (ME,110) FID(FIL)(1:MIN(20,FIDL(FIL))), IOS
      CLOSE (UOUT,STATUS='DELETE')
      END
C ******************************************************************
C
      SUBROUTINE TOP
C
C END OF PAGE
C
      IMPLICIT INTEGER (A-T)
      COMMON /IST/ FON, NPAP
      COMMON /IT/NPG,NPOS,NR,OVLPGS,PAGLEN,SHOW,XFON,UOUT,FONL,SHWL,NCOP
      COMMON /RST/ CPI, HML, LPI, VMB, VMT, CHARSIZ, PWD, SIZCHR, YNUM,
     &             XCHR, YCHR, FONTFAM, PSIZ
      COMMON /RT/ X, XHML, XVMB, XVMT, XLPI, XCPI, XCHSIZ, ULPOS
      COMMON /LST/ PAGNUM
      COMMON /LT/ BANN, OLAYS, ROMAN, TOF, END, NUFONT, FSHOWP
      COMMON /CTS/ FOR
      COMMON /CT/ BAN, PAGTXT, XFOR, ROTATE, SHW, FONT
      INTEGER XFON, UOUT
      PARAMETER (NSHW=3)
      PARAMETER (NFONTS=35, NPAPS=5)
      REAL CPI, LPI, HML, PWD, SIZCHR, FONTFAM, PSIZ
      LOGICAL TOF, BANN, PAGNUM, OLAYS, ROMAN, END, NUFONT, FSHOWP
      DIMENSION FONL(NFONTS), FONTFAM(NFONTS)
      DIMENSION SHWL(NSHW)
      DIMENSION PSIZ(NPAPS,2)
      CHARACTER*1 FOR, XFOR, BAN, ROTATE
      CHARACTER*5 FBUF
      CHARACTER*8 SHOWP /'showpage'/
      CHARACTER*11 SHW(NSHW)
      CHARACTER*16 ROMTXT
      CHARACTER*21 FONT(NFONTS)
      CHARACTER*24 XTXT
      CHARACTER*64 PAGTXT
C
      NPG=NPG+1
C
C PAGE NUMBER?
C
      IF ((PAGNUM) .AND. (NPG.GE.1)) THEN
C
C DO WE HAVE A NEW FONT DEFINITION TO OUTPUT (AND NEW SPACE SPACE)?
C
        IF (NUFONT .AND. (BAN.NE.'B')) THEN
          WRITE (UOUT,206) FONT(FON)(1:FONL(FON)), XCHR, YCHR, ULPOS
  206     FORMAT (2X, '/', A, ' findfont [', F.3, '0 0 ', F.3,
     &     '0 0] makefont setfont currentfont getulmetrics ',
     &     '/ulthk exch def /ulpos exch def /ulfdg', F5.2,
     &     ' def')
          WRITE (FBUF,207) XCHR
  207     FORMAT (F5.3)
          READ (FBUF,207) XCHR
          XCHSIZ=XCHSIZ/1.66667/FONTFAM(FON)
          NUFONT=.FALSE.
        ENDIF
C
C DO WE HAVE A NEW PAPER ROTATION TO SPECIFY (NOT IF AT TOF)?
C
        IF (ROTATE.EQ.'+') THEN
          WRITE (UOUT,208) PSIZ(NPAP,2)
  208     FORMAT (F6.1, ' 0 translate 90 rotate')
          ROTATE=' '
        ELSEIF (ROTATE.EQ.'-') THEN
          WRITE (UOUT,209) -PSIZ(NPAP,2)
  209     FORMAT ('  -90 rotate', F6.1, ' 0 translate')
          ROTATE=' '
        ENDIF
C
C FOOTER WITH PAGE NUMBER
C
        IF (NPOS.GT.0) THEN
          IF (ROMAN) THEN
            STATUS=NUMROMAN(NPG, 'L', ROMTXT, NROM)
            IF (STATUS.EQ.0) THEN
              WRITE (UOUT,214) PWD/2., YNUM, PAGTXT(1:NPOS-1),
     &         ROMTXT(1:NROM), PAGTXT(NPOS+1:PAGLEN)
  214         FORMAT (2X, 2F.3, 'moveto (', 3A, ') cshow')
            ELSE
              WRITE (UOUT,215) NPG
  215         FORMAT (5X,'Page number ', I,
     &         'too large for Roman numerals.')
            ENDIF
          ELSE
            WRITE (UOUT,216) PWD/2., YNUM, PAGTXT(1:NPOS-1), NPG,
     &       PAGTXT(NPOS+1:PAGLEN)
  216       FORMAT (2X, 2F.3, 'moveto (', A, I, -1X, A, ') cshow')
          ENDIF
C
C FOOTER WITHOUT PAGE NUMBER
C
        ELSE
          WRITE (UOUT,217) PWD/2., YNUM, PAGTXT(1:PAGLEN)
  217     FORMAT (2X, 2F.3, 'moveto (', A, ') cshow')
        ENDIF
      ENDIF
C
C CHANGE FROM FIRST OVERLAY?
C
      IF (OLAYS .AND. (NPG.GT.OVLPGS)) THEN
        SHOW=3
      ENDIF
C
C DO NOT OVERLAY BANNER
C
      IF (NPG.LE.0) THEN
        SHX=1
      ELSE
        SHX=SHOW
      ENDIF
C
C END OF PAGE.  MULTIPLE COPIES (DO ONCE ONLY)?
C
      IF (FSHOWP .AND. (NCOP.GT.1)) THEN
        IF (BANN) THEN
          WRITE (XTXT,302) NCOP
  302     FORMAT ('/#copies', I3, ' def showpage')
        ELSE
          WRITE (XTXT,303) NCOP
  303     FORMAT ('showpage /#copies',I3,' def')
        ENDIF
C
        IF (END) THEN
          WRITE (UOUT,304) SHW(SHX)(1:SHWL(SHX)), XTXT
  304     FORMAT (A, 'ARRGH restore ', A)
          RETURN
        ELSE
          WRITE (UOUT,305) SHW(SHX)(1:SHWL(SHX)), XTXT
  305     FORMAT (A,'ARRGH restore ',A,' /ARRGH save def 72 72 scale')
        ENDIF
        FSHOWP=.FALSE.
      ELSE
C
        IF (END) THEN
          WRITE (UOUT,304) SHW(SHX)(1:SHWL(SHX)), SHOWP
          RETURN
        ELSE
          WRITE (UOUT,305) SHW(SHX)(1:SHWL(SHX)), SHOWP
        ENDIF
      ENDIF
      NR=0
      TOF=.FALSE.
      NUFONT=.TRUE.
C
C IF END OF 0'TH PAGE AND BANNER OPTION, RESET ALL OPTIONS TO THEIR
C ORIGINAL VALUES AND REDO THE SETUP
C
      IF (BANN .AND. (NPG.EQ.0)) THEN
        IF (FOR.NE.XFOR) THEN
          IF ((FOR.EQ.'L') .AND. (XFOR.EQ.'P')) ROTATE='-'
          FOR=XFOR
        ENDIF
        HML=XHML
        VMT=XVMT
        VMB=XVMB
        IF ((MAX(LPI,XLPI)-MIN(LPI,XLPI).GT.0.005) .OR.
     &     (MAX(CPI,XCPI)-MIN(CPI,XCPI).GT.0.005)) THEN
          NUFONT=.TRUE.
        ENDIF
        LPI=XLPI
        CPI=XCPI
C
C RESET OPTIONS IF PRINTING WAS FROM BANNER SHEET
C
        IF ((BAN.EQ.'B') .OR. (BAN.EQ.'X')) THEN
          BAN=' '
          FON=XFON
        ENDIF
        CALL SETUP
        X=HML
      ENDIF
C
C ROTATED?
C
      IF (FOR.EQ.'L') THEN
        WRITE (UOUT,208) PSIZ(NPAP,2)
        ROTATE=' '
      ENDIF
      RETURN
      END
C ******************************************************************
C
      SUBROUTINE SETUP
      IMPLICIT INTEGER (A-T)
      LOGICAL BADI, PAGNUM, DEFCHT
      REAL CPI, LPI, HML, SIZLN, SIZCHR, PHT, PWD, CHARSIZ, FONTFAM
      REAL PSIZ
      PARAMETER (NFONTS=35, NPAPS=5)
      DIMENSION FONTFAM(NFONTS), PSIZ(NPAPS,2)
      COMMON /IST/ FON, NPAP
      COMMON /RS/ PHT, VMBO, SIZLN, YPOS
      COMMON /RST/ CPI, HML, LPI, VMB, VMT, CHARSIZ, PWD, SIZCHR, YNUM,
     &             XCHR, YCHR, FONTFAM, PSIZ
      COMMON /LST/ PAGNUM
      COMMON /LS/ BADI, DEFCHT
      COMMON /CTS/ FOR
      CHARACTER*1 FOR
C
C SET UP DEFAULTS BASED ON FORMAT
C
      IF (FOR.EQ.'P') THEN
        IF (CPI.LT.-10.) CPI=10.
        IF (HML.LT.-10.) HML=.5
        IF (LPI.LT.-10.) LPI=6.
        IF (VMB.LT.-10.) VMB=.5
        IF (VMT.LT.-10.) VMT=.5
        IF (CHARSIZ.LT.-10.) CHARSIZ=1.
        PHT=PSIZ(NPAP,1)
        PWD=PSIZ(NPAP,2)
      ELSEIF (FOR.EQ.'L') THEN
        IF (CPI.LT.-10.) CPI=13.8
        IF (HML.LT.-10.) HML=.625
        IF (LPI.LT.-10.) LPI=8.8
        IF (VMB.LT.-10.) VMB=.5
        IF (VMT.LT.-10.) VMT=.5
        IF (CHARSIZ.LT.-10.) CHARSIZ=1.
        PHT=PSIZ(NPAP,2)
        PWD=PSIZ(NPAP,1)
      ELSE
        WRITE (ME,105) 'FOR', FOR
  105   FORMAT (5X, A, ' option "', A, '" is invalid.')
        BADI=.TRUE.
      ENDIF
C
C BUGGER VMB SLIGHTLY SO LAST-LINE CALCULATIONS ALWAYS WORK
C
      VMB=VMB-.0001
      VMBO=VMB
C
C CHARACTER AND LINE SIZES
C
      SIZCHR=.997/CPI
      SIZLN=1./LPI
      XCHR=1.66667*SIZCHR*FONTFAM(FON)
      IF (DEFCHT) THEN
        YCHR=MIN(1.05*XCHR,SIZLN*CHARSIZ*FONTFAM(FON))
      ELSE
        YCHR=SIZLN*CHARSIZ*FONTFAM(FON)
      ENDIF
C
C PAGE NUMBER LINE LOCATION
C
      IF (PAGNUM) THEN
        YNUM=VMBO
        VMB=VMBO+(2.*SIZLN)
      ENDIF
C
C LOCATION OF FIRST LINE AND NUMBER OF LAST LINE
C
      YPOS=PHT-VMT-SIZLN
      RETURN
      END
C ******************************************************************
C
      LOGICAL FUNCTION NUMBRS(TYP, STR, ST, END, POS)
C
C WILL RETURN .TRUE. IF ALL CHARACTERS IN THE SPECIFIED
C STRING ARE FROM THE 'NUMERIC' SET AS DEFINED;
C RETURNS .FALSE. IF ANY CHARACTER IS NOT IN THE SPECIFIED SET,
C AND POSITION IN THE STRING OF THE FIRST DISCREPANT CHARACTER.
C
C THE TYP DEFINES THE TYPE OF NUMERIC ENTRY TESTED FOR.
C     H = HEXADECIMAL
C     I = INTEGER
C     P = POSITIVE NONZERO INTEGER
C     S = SIGNED INTEGER
C     R = REAL
C     F = FLOATING POINT
C     D = DOUBLE PRECISION
C
C IF TYPE IS LOWER-CASE, COMMA IS PERMITTED (FOR MULTIPLE VALUES)
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*(*) STR
      CHARACTER*46 VALS
     & /'ABCDEF 0123456789+-.ED ABCDEF 0123456789,+-.ED'/
      CHARACTER*1 TYP, VAL(23,2)
      LOGICAL NZ
      EQUIVALENCE (VAL,VALS)
C
C GET LOOP LIMITS FROM TYPE
C
      NZ=.TRUE.
      IF (TYP.EQ.'H') THEN
        IST=1
        IEN=17
        K=1
      ELSEIF (TYP.EQ.'I') THEN
        IST=7
        IEN=17
        K=1
      ELSEIF (TYP.EQ.'P') THEN
        IST=7
        IEN=17
        K=1
        NZ=.FALSE.
      ELSEIF (TYP.EQ.'S') THEN
        IST=7
        IEN=19
        K=1
      ELSEIF (TYP.EQ.'R') THEN
        IST=7
        IEN=20
        K=1
      ELSEIF (TYP.EQ.'F') THEN
        IST=7
        IEN=21
        K=1
      ELSEIF (TYP.EQ.'D') THEN
        IST=7
        IEN=22
        K=1
      ELSEIF (TYP.EQ.'h') THEN
        IST=1
        IEN=18
        K=2
      ELSEIF (TYP.EQ.'i') THEN
        IST=7
        IEN=18
        K=2
      ELSEIF (TYP.EQ.'p') THEN
        IST=7
        IEN=18
        K=2
        NZ=.FALSE.
      ELSEIF (TYP.EQ.'s') THEN
        IST=7
        IEN=20
        K=2
      ELSEIF (TYP.EQ.'r') THEN
        IST=7
        IEN=21
        K=2
      ELSEIF (TYP.EQ.'f') THEN
        IST=7
        IEN=22
        K=2
      ELSEIF (TYP.EQ.'d') THEN
        IST=7
        IEN=23
        K=2
      ENDIF
      DO 5002 I=ST,END
      DO 5001 J=IST,IEN
      IF (STR(I:I).EQ.VAL(J,K)) THEN
        IF (J.GE.9) NZ=.TRUE.
        GOTO 5002
      ENDIF
 5001 CONTINUE
      NUMBRS=.FALSE.
      POS=I
      RETURN
 5002 CONTINUE
      NUMBRS=NZ
      POS=0
      RETURN
      END
C ******************************************************************
C
      INTEGER FUNCTION FINDEQ (STR, ST, ND, CMPR)
C
C RETURNS THE INDEX (FROM "ST" TO "ND") OF THE FIRST OCCURRENCE
C OF THE SPECIFIED SUBSTRING "CMPR" OF LENGTH "LEN" WITHIN
C A STRING "STR".  THIS ROUTINE WILL START AT EITHER END OF
C THE STRING, DEPENDING UPON WHETHER "ST" < "ND".
C THE INDEX RETURNED WILL BE OF THE CHARACTER MATCHING
C THE FIRST CHARACTER IN "CMPR" REGARDLESS OF THE DIRECTION
C OF SEARCH.
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*(*) STR
      CHARACTER*(*) CMPR
      ICM=LEN(CMPR)-1
C
C WHICH WAY DO WE STEP?
C
      IF (ND.GE.ST) THEN
        START=ST
        END=ND-ICM
        INC=1
      ELSE
        START=ST-ICM
        END=ND
        INC=-1
      ENDIF
C
C LOOK
C
      DO 8005 I=START,END,INC
      IF (STR(I:I+ICM).EQ.CMPR) THEN
        FINDEQ=I
        RETURN
      ENDIF
 8005 CONTINUE
      FINDEQ=0
      RETURN
      END
C ******************************************************************
C
      INTEGER FUNCTION FINDNE (STR, ST, ND, CMPR)
C
C RETURNS THE INDEX (FROM "ST" TO "ND") OF THE FIRST ELEMENT THAT
C DOES NOT MATCH SUBSTRING "CMPR" OF LENGTH "LEN" WITHIN
C A STRING "STR".  THIS ROUTINE WILL START AT EITHER END OF
C THE STRING, DEPENDING UPON WHETHER "ST" < "ND".
C THE INDEX RETURNED WILL BE OF THE CHARACTER NOT MATCHING
C THE FIRST CHARACTER IN "CMPR" REGARDLESS OF THE DIRECTION
C OF SEARCH.
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*(*) STR
      CHARACTER*(*) CMPR
      ICM=LEN(CMPR)-1
C
C WHICH WAY DO WE STEP?
C
      IF (ND.GE.ST) THEN
        START=ST
        END=ND-ICM
        INC=1
      ELSE
        START=ST-ICM
        END=ND
        INC=-1
      ENDIF
C
C STEP
C
      DO 8001 I=START,END,INC
      IF (STR(I:I+ICM).NE.CMPR) THEN
        FINDNE=I
        RETURN
      ENDIF
 8001 CONTINUE
      FINDNE=0
      RETURN
      END
C ******************************************************************
C
      LOGICAL FUNCTION TXTOK(VAL, TXT, NTXT, POS)
C
C TO CHECK TO SEE IF AN ENTRY IS IN THE VALID LIST
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*(*) TXT(NTXT)
      CHARACTER*(*) VAL
      DO 9001 I=1,NTXT
      IF (VAL.EQ.TXT(I)) THEN
        TXTOK=.TRUE.
        POS=I
        RETURN
      ENDIF
 9001 CONTINUE
      TXTOK=.FALSE.
      POS=0
      RETURN
      END
C
C ******************************************************************************
C
C NUMROMAN:SU  3-FEB-1986  M SHUMAKER  SCIENTIFIC COMPUTING SERVICES  PLANT 31
C
C THIS INTEGER FUNCTION WILL RETURN THE STATUS OF THE TASK:
C
C     1 = INPUT VALUE OUT OF RANGE
C     0 = SUCCESSFUL COMPLETION
C
C THE ROMAN NUMERAL REPRESENTATION OF POSITIVE INTEGER VALUE "VAL"
C (MUST BE LESS THAN 4000) WILL BE RETURNED IN "OUT" (CHARACTER*16)
C IN THE FIRST "LEN" CHARACTERS.  OUTPUT WILL BE IN UPPER CASE LETTERS
C UNLESS "CASE" (CHARACTER*1) IS SET TO 'L' FOR LOWER CASE.
C
      INTEGER FUNCTION NUMROMAN(VAL, CASE, OUT, LEN)
      IMPLICIT INTEGER (A-Z)
      CHARACTER*1 CASE
      CHARACTER*16 OUT
      CHARACTER*4 LTRS(9,4,2) /
     & 'M', 'MM', 'MMM', '  ', ' ', '  ', '   ', '    ', '  ',
     & 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM',
     & 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC',
     & 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX',
     & 'm', 'mm', 'mmm', '  ', ' ', '  ', '   ', '    ', '  ',
     & 'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm',
     & 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc',
     & 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'/
      DIMENSION LGTH(9)
      DATA LGTH /1, 2, 3, 2, 1, 2, 3, 4, 2/
      INP=VAL
C
C OUTSIDE LIMITS
C
      IF ((INP.LT.0) .OR. (INP.GT.3999)) THEN
        OUT=' '
        LEN=1
        NUMROMAN=1
        RETURN
      ENDIF
C
C TRIVIAL
C
      IF (INP.EQ.0) THEN
        OUT=' '
        LEN=1
        RETURN
      ENDIF
C
C CASE
C
      IF (CASE.EQ.'L') THEN
        CS=2
      ELSE
        CS=1
      ENDIF
C
C SET UP FOR IT
C
      LEN=0
      ID=1000
C
C DO IT
C
      DO 1100 J=1,4
      INT=INP/ID
      IF (INT.GT.0) THEN
        NLEN=LEN+LGTH(INT)
        OUT(LEN+1:NLEN)=LTRS(INT,J,CS)(1:LGTH(INT))
        LEN=NLEN
        INP=MOD(INP,ID)
      ENDIF
      ID=ID/10
 1100 CONTINUE
      NUMROMAN=0
      RETURN
      END
C ******************************************************************
C
C FLINE:SU  3-FEB-1986  M SHUMAKER  SCIENTIFIC COMPUTING SERVICES  PLANT 31
C
C THIS ROUTINE WILL RETURN A TEXT STRING WITH THE LINE NUMBER (APPROXIMATE
C IF A CP-6 TEXT FILE) WHEREIN AN ERROR EXISTS.
C
      SUBROUTINE FLINE
      IMPLICIT INTEGER (A-Z)
      COMMON /IFLN/ KB, NI, QL
      COMMON /TFLN/ QQ
      COMMON /LF/ TEXTED
      LOGICAL TEXTED
      DATA LMASK /12O000777777777/
      DATA HMASK /12O777000000000/
      CHARACTER*27 QQ
      CHARACTER*11 LNTX /' Near Line '/
      DIMENSION KB(8)
      IF (TEXTED) THEN
        JJ=1
      ELSE
        JJ=6
      ENDIF
C
      M=IAND(HMASK,KB(1))
      IF (M.EQ.3) THEN
        N=IAND(LMASK,KB(1))
        ENCODE(27, 101, QQ, QL) LNTX(JJ:11), NI, N/1000, MOD(N,1000)
  101   FORMAT (A, I, '- ', I, -1X, '.', I3.3)
      ELSE
        ENCODE(27, 102, QQ, QL) LNTX(JJ:11), NI
  102   FORMAT (A, I)
        QL=QL-1
      ENDIF
      RETURN
      END
C *********************************************************************
C
C THIS WILL SKIP A SPECIFIED NUMBER OF RECORDS IN A FILE WHOSE
C I/O IS BEING DONE BY 'FOXI' ROUTINES.
C
      SUBROUTINE SKIPREC (UNIT, NREC, OOPS)
      IMPLICIT INTEGER (A-Z)
      CHARACTER*256 CHR
      DO 1005 I=1,NREC
      CALL FAST$READ (IOS, UNIT, CHR, 475)
      IF (IOS.NE.0) GOTO 1010
 1005 CONTINUE
      OOPS=0
      RETURN
 1010 OOPS=1
      RETURN
      END
C *********************************************************************
C
C THIS ROUTINE MUST BE MODIFIED BY THE USER TO TRANSLATE FROM THE USER'S
C 'STANDARD' PLOT FILE FORMAT INTO POSTSCRIPT.  GOOD LUCK.
C
      SUBROUTINE XRCIS4USR  (I,W,X,Y,Z)
      RETURN
      END
C ******************************************************************
C
      INTEGER FUNCTION FINDEQND (STR, ST, ND, CMPR)
C
C RETURNS THE INDEX (FROM "ST" TO "ND") OF THE FIRST OCCURRENCE
C OF THE SPECIFIED SUBSTRING "CMPR" OF LENGTH "LEN" WITHIN
C A STRING "STR".  THIS ROUTINE WILL START AT EITHER END OF
C THE STRING, DEPENDING UPON WHETHER "ST" < "ND".
C THE INDEX RETURNED WILL BE OF THE CHARACTER MATCHING
C THE FIRST CHARACTER IN "CMPR" REGARDLESS OF THE DIRECTION
C OF SEARCH.  IGNORES TEXT INSIDE BALANCED PARENTHESES.
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*1 DELIM(2) /'(', ')'/
      CHARACTER*(*) STR
      CHARACTER*(*) CMPR
      LOGICAL IGN
      DATA IGN /.FALSE./
      ICM=LEN(CMPR)-1
      INDELIM=0
C
C WHICH WAY DO WE STEP?
C
      IF (ND.GE.ST) THEN
        START=ST
        END=ND-ICM
        INC=1
        DLM=1
      ELSE
        START=ST-ICM
        END=ND
        INC=-1
        DLM=2
      ENDIF
C
C LOOK
C
      DO 8005 I=START,END,INC
      IF (STR(I:I+ICM).EQ.CMPR) THEN
        IF (IGN) THEN
          INDELIM=I
        ELSE
          FINDEQND=I
          RETURN
        ENDIF
      ELSEIF (STR(I:I).EQ.DELIM(DLM)) THEN
        IGN=.TRUE.
      ELSEIF (STR(I:I).EQ.DELIM(DLM+INC)) THEN
        IGN=.FALSE.
      ENDIF
 8005 CONTINUE
C
C WERE THERE UNBALANCED PARENTHESES?
C
      IF (IGN) THEN
        FINDEQND=INDELIM
      ELSE
        FINDEQND=0
      ENDIF
      RETURN
      END
