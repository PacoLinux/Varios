VERSION A02

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:1    
        1        1        /*M*    XSL$SOCKET2             BSD4.3 Socket Library for CP-6, part 2  */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMC,PLM=4,IND=4,DCI=8,DTI=0,ENI=4,ECI=4,CSI=4,DIN=4,SDI=0 */
        8        8
        9        9        /*F* NAME: sendto() and XSL$SENDTO  --  Write Data With Options And Address
       10       10        ..::IT "Purpose:"
       11       11        .INL +4
       12       12        Sends a message from an application-specified buffer to a socket.  This
       13       13        function is typically used when the destination socket changes from
       14       14        invocation to invocation.
       15       15        ..::IT "C Usage:"
       16       16        .INL 4
       17       17        .FIF
       18       18        status = sendto( s, msg, len, flags, to, tolen );
       19       19        ..::IT "PL6 Usage:"
       20       20        .INL 4
       21       21        .FIF
       22       22        CALL XSL$SENDTO( status, s, msg, len, flags, to, tolen );
       23       23        ..::IT "Parameters:"
       24       24        .INL 4
       25       25        .FIF
       26       26        s           integer socket descriptor
       27       27
       28       28        msg         character array containing message to be sent
       29       29
       30       30        len         integer number of significant characters in msg
       31       31
       32       32        flags       integer bitflags of sendto options
       33       33
       34       34        to          sockaddr structure
       35       35
       36       36        tolen       integer size of to in characters
       37       37        ..::IT "Result:"
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:2    
       38       38        .INL 4
       39       39        .FIF
       40       40        status      integer number of characters sent or error code
       41       41        ..::IT "Description:"
       42       42        The sendto() function sends a message from an application-defined buffer
       43       43        to a socket.  On datagram sockets the message is sent atomically; if
       44       44        this is not possible then the error EMSGSIZE is reported.
       45       45        .SPB
       46       46        The s parameter specifies the descriptor of the socket to be written to.
       47       47        .SPB
       48       48        The msg parameter specifies an application-defined buffer containing the
       49       49        message to be sent to the socket.
       50       50        .SPB
       51       51        The len parameter specifies the number of characters to be sent.
       52       52        .SPB
       53       53        The flags parameter specifies sendto options.  The only option currently
       54       54        implemented is "out-of-band", which causes the message to be sent on the
       55       55        out-of-band data path if the socket supports it.  This is selected by coding
       56       56        SOF_OOB or %XSL_SOF_OOB in C or PL6 source, respectively.
       57       57        .SPB
       58       58        The to parameter specifies the address of the remote socket to receive
       59       59        the message.  In C source, it is a sockaddr structure.  In PL6 source, it is
       60       60        an XSL$SOCKADDR structure.
       61       61        .SPB
       62       62        The tolen parameter specifies the number of significant characters in to.
       63       63        .SPB
       64       64        If the sendto() function is successful, the status result contains the
       65       65        number of characters sent to the socket.  This number is non-negative.
       66       66        A successful result does not guarantee that the message was delivered,
       67       67        but only that it was sent to the FEP for network transmission.  The
       68       68        status value may be less than the len value if the socket is
       69       69        nonblocking and no more data could be immediately sent.
       70       70        .SPB
       71       71        If the sendto() function is unsuccessful, the status result contains
       72       72        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
       73       73        to determine the specific error condition.  The XSL$SENDTO procedure
       74       74        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:3    
       75       75        to the sendto() function.
       76       76        .SPB
       77       77        Sendto() may be used on sockets regardless of whether connect() has been
       78       78        issued.
       79       79        .SPB
       80       80        If shutdown() has been invoked for this socket to inhibit transmission
       81       81        of data, all sendto() operations report the error ESHUTDOWN.
       82       82        ..::IT "Errors:"
       83       83        Following are the possible error conditions reported when the sendto()
       84       84        function is unsuccessful.  Equates for the possible values can be found in
       85       85        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
       86       86
       87       87        .FIF
       88       88
       89       89        C #define               PL6 %EQU
       90       90        ----------------------- -----------------------
       91       91        EBADF                   E$BADF
       92       92        .FIN
       93       93        The descriptor s is not appropriate to identify a socket.
       94       94        .FIF
       95       95
       96       96        EMSGSIZE                E$MSGSIZE
       97       97        .FIN
       98       98        The message is too long to send atomically.
       99       99        .FIF
      100      100
      101      101        ENOTSOCK                E$NOTSOCK
      102      102        .FIN
      103      103        The descriptor s is no longer valid to identify a socket.
      104      104        .FIF
      105      105
      106      106        ESHUTDOWN               E$SHUTDOWN
      107      107        .FIN
      108      108        Can't send after socket shutdown.
      109      109        .FIF
      110      110
      111      111        EWOULDBLOCK             E$WOULDBLOCK
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:4    
      112      112        .FIN
      113      113        The message cannot be immediately sent.
      114      114        .FIF
      115      115        */
      116      116        /*F* NAME: send() and XSL$SEND  --  Write Data With Options
      117      117        ..::IT "Purpose:"
      118      118        .INL +4
      119      119        Sends a message from an application-specified buffer to a connected socket.
      120      120        ..::IT "C Usage:"
      121      121        .INL 4
      122      122        .FIF
      123      123        status = send( s, msg, len, flags );
      124      124        ..::IT "PL6 Usage:"
      125      125        .INL 4
      126      126        .FIF
      127      127        CALL XSL$SEND( status, s, msg, len, flags );
      128      128        ..::IT "Parameters:"
      129      129        .INL 4
      130      130        .FIF
      131      131        s           integer socket descriptor
      132      132
      133      133        msg         character array containing message to be sent
      134      134
      135      135        len         integer number of significant characters in msg
      136      136
      137      137        flags       integer bitflags of send options
      138      138        ..::IT "Result:"
      139      139        .INL 4
      140      140        .FIF
      141      141        status      integer number of characters sent or error code
      142      142        ..::IT "Description:"
      143      143        The send() function sends a message from an application-defined buffer
      144      144        to a socket.  On datagram sockets the message is sent atomically; if
      145      145        this is not possible then the error EMSGSIZE is reported.
      146      146        .SPB
      147      147        The s parameter specifies the descriptor of the socket to be written to.
      148      148        .SPB
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:5    
      149      149        The msg parameter specifies an application-defined buffer containing the
      150      150        message to be sent to the socket.
      151      151        .SPB
      152      152        The len parameter specifies the number of characters to be sent.
      153      153        .SPB
      154      154        The flags parameter specifies send options.  The only option currently
      155      155        implemented is "out-of-band", which causes the message to be sent on the
      156      156        out-of-band data path if the socket supports it.  This is selected by coding
      157      157        SOF_OOB or %XSL_SOF_OOB in C or PL6 source, respectively.
      158      158        .SPB
      159      159        If the send() function is successful, the status result contains the
      160      160        number of characters sent to the socket.  This number is non-negative.
      161      161        A successful result does not guarantee that the message was delivered,
      162      162        but only that it was sent to the FEP for network transmission.  The
      163      163        status value may be less than the len value if the socket is
      164      164        nonblocking and no more data could be immediately sent.
      165      165        .SPB
      166      166        If the send() function is unsuccessful, the status result contains
      167      167        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      168      168        to determine the specific error condition.  The XSL$SEND procedure
      169      169        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      170      170        to the send() function.
      171      171        .SPB
      172      172        Send() may be used only on sockets that have had connect() invoked.
      173      173        .SPB
      174      174        If shutdown() has been invoked for this socket to inhibit transmission
      175      175        of data, all send() operations report the error ESHUTDOWN.
      176      176        ..::IT "Errors:"
      177      177        Following are the possible error conditions reported when the send()
      178      178        function is unsuccessful.  Equates for the possible values can be found in
      179      179        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      180      180
      181      181        .FIF
      182      182
      183      183        C #define               PL6 %EQU
      184      184        ----------------------- -----------------------
      185      185        EBADF                   E$BADF
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:6    
      186      186        .FIN
      187      187        The descriptor s is not appropriate to identify a socket.
      188      188        .FIF
      189      189
      190      190        EMSGSIZE                E$MSGSIZE
      191      191        .FIN
      192      192        The specified message is too long to send atomically.
      193      193        .FIF
      194      194
      195      195        ENOTBOUND               E$NOTBOUND
      196      196        .FIN
      197      197        The socket is not bound to a FEP.
      198      198        .FIF
      199      199
      200      200        ENOTCONN                E$NOTCONN
      201      201        .FIN
      202      202        The connect() function has not been invoked for this socket.
      203      203        .FIF
      204      204
      205      205        ENOTSOCK                E$NOTSOCK
      206      206        .FIN
      207      207        The descriptor s is no longer valid to identify a socket.
      208      208        .FIF
      209      209
      210      210        ESHUTDOWN               E$SHUTDOWN
      211      211        .FIN
      212      212        Can't send after socket shutdown.
      213      213        .FIF
      214      214
      215      215        EWOULDBLOCK             E$WOULDBLOCK
      216      216        .FIN
      217      217        The message cannot be immediately sent.
      218      218        .FIF
      219      219        */
      220      220        /*F* NAME: write() and XSL$WRITE  --  Write Data
      221      221        ..::IT "Purpose:"
      222      222        .INL +4
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:7    
      223      223        Writes data from an application-specified buffer to a socket.
      224      224        ..::IT "C Usage:"
      225      225        .INL 4
      226      226        .FIF
      227      227        status = write( s, buf, len );
      228      228        ..::IT "PL6 Usage:"
      229      229        .INL 4
      230      230        .FIF
      231      231        CALL XSL$WRITE( status, s, buf, len );
      232      232        ..::IT "Parameters:"
      233      233        .INL 4
      234      234        .FIF
      235      235        s           integer socket descriptor
      236      236
      237      237        buf         character array buffer
      238      238
      239      239        len         integer number of significant characters in buf
      240      240        ..::IT "Result:"
      241      241        .INL 4
      242      242        .FIF
      243      243        status      integer number of characters written or error code
      244      244        ..::IT "Description:"
      245      245        The write() function writes data from the specified buffer to the socket.
      246      246        On datagram sockets the data is written atomically; if this is not
      247      247        possible then the error EMSGSIZE is reported.
      248      248        .SPB
      249      249        The s parameter specifies the descriptor of the socket to be written to.
      250      250        .SPB
      251      251        The buf parameter specifies an application-defined buffer containing the
      252      252        data to be written to the socket.
      253      253        .SPB
      254      254        The len parameter specifies the number of characters to be written.
      255      255        .SPB
      256      256        If the write() function is successful, the status result contains the
      257      257        number of characters written to the socket.  This number is non-negative.
      258      258        A successful result does not guarantee that the data was delivered,
      259      259        but only that it was sent to the FEP for network transmission.  The
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:8    
      260      260        status value may be less than the len value if the socket is
      261      261        nonblocking and no more data could be immediately sent.
      262      262        .SPB
      263      263        If the write() function is unsuccessful, the status result contains
      264      264        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      265      265        to determine the specific error condition.  The XSL$WRITE procedure
      266      266        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      267      267        to the write() function.
      268      268        .SPB
      269      269        Write() may be used only on sockets that have had connect() invoked.
      270      270        .SPB
      271      271        If shutdown() has been invoked for this socket to inhibit transmission
      272      272        of data, all write() operations report the error ESHUTDOWN.
      273      273        ..::IT "Errors:"
      274      274        Following are the possible error conditions reported when the write()
      275      275        function is unsuccessful.  Equates for the possible values can be
      276      276        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
      277      277
      278      278        .FIF
      279      279
      280      280        C #define               PL6 %EQU
      281      281        ----------------------- -----------------------
      282      282        EBADF                   E$BADF
      283      283        .FIN
      284      284        The descriptor s is not appropriate to identify a socket.
      285      285        .FIF
      286      286
      287      287        EMSGSIZE                E$MSGSIZE
      288      288        .FIN
      289      289        The specified buffer is too long to send atomically.
      290      290        .FIF
      291      291
      292      292        ENOTBOUND               E$NOTBOUND
      293      293        .FIN
      294      294        The socket is not bound to a FEP.
      295      295        .FIF
      296      296
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:9    
      297      297        ENOTCONN                E$NOTCONN
      298      298        .FIN
      299      299        The socket is not currently connected.  connect() has not been invoked.
      300      300        .FIF
      301      301
      302      302        ENOTSOCK                E$NOTSOCK
      303      303        .FIN
      304      304        The descriptor s is no longer valid to identify a socket.
      305      305        .FIF
      306      306
      307      307        ESHUTDOWN               E$SHUTDOWN
      308      308        .FIN
      309      309        Can't send after socket shutdown.
      310      310        .FIF
      311      311
      312      312        EWOULDBLOCK             E$WOULDBLOCK
      313      313        .FIN
      314      314        The data cannot be immediately sent.
      315      315        .FIF
      316      316        */
      317      317        XSL$SENDTO: PROC( RESULT, SOCK#, MSG, LEN, FLAGS, DST, DSTLEN) ALTRET;
      318      318        %INCLUDE B_ERRORS_C;
      319     1445        %INCLUDE CP_6;
      320     1526            %B$ALT;
      321     1534            %B$TCB( STCLASS="BASED( B$TCB$)");
      322     1537            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
      323     1551            %FPT_WAIT( FPTN=XSL_WAIT1SEC, STCLASS=SYMREF);
      324     1565            %F$DCB;
      325     1622        %INCLUDE XSL_SOCKET_E;
      326     1880        %INCLUDE XSL_SOCKET_M;
      327     2641            %XSL$SOCKADDR( FPTN=DST, STCLASS=);
      328     2681        %INCLUDE XSL_PERR_C;
      329     2736        %INCLUDE XSL_INTERNAL_M;
      330     2987            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
      331     3131        %INCLUDE XSL_SOCKMSGS_E;
      332     3177        %INCLUDE XSL_SOCKMSGS_M;
      333     4310            %XSL$SENDRQS( FPTN=XSL_SENDRQS, STCLASS="CONSTANT SYMDEF");
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:10   
      334     4336            %XSL$SENDRQS( STCLASS="BASED( XSL_KEYBUF$)");
      335     4362            %XSL$SENDTORQS( FPTN=XSL_SENDTORQS, STCLASS="CONSTANT SYMDEF");
      336     4415            %XSL$SENDTORQS( STCLASS="BASED( XSL_KEYBUF$)");
      337     4468
      338     4469    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
      339     4470    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
      340     4471    1       DCL XSL$HTONADDR ENTRY(2);
      341     4472    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
      342     4473    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
      343     4474    1       DCL XSL$QSETSOCKOPT ENTRY(6) ALTRET;
      344     4475    1       DCL XSL$SOCKOPEN ENTRY(3) ALTRET;
      345     4476    1       DCL XSL$EVLOG ENTRY(2);
      346     4477    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
      347     4478
      348     4479    1       DCL B$TCB$ PTR SYMREF READONLY;
      349     4480    1       DCL XSL_ERRNO SBIN SYMREF;
      350     4481    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
      351     4482    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
      352     4483    1       DCL XSL_SOCK$$ PTR SYMREF;
      353     4484    1       DCL XSL_UETIME SBIN SYMREF;
      354     4485
      355     4486    1       DCL DSTLEN SBIN;
      356     4487    1       DCL ENTRYFLAG SBIN;
      357     4488        %EQU SENDTO = 0;
      358     4489        %EQU SEND = 1;
      359     4490        %EQU WRITE = 2;
      360     4491    1       DCL FLAGS UBIN;
      361     4492    1       DCL LEN SBIN;
      362     4493    1       DCL MSG CHAR( LEN) CALIGNED;
      363     4494    1       DCL RESULT SBIN;
      364     4495    1       DCL SOCK# SBIN;
      365     4496    1       DCL SOCK$ PTR;
      366     4497    1       DCL XLEN SBIN;
      367     4498    1       DCL XMSG CHAR( XLEN) BASED( XPTR$);
      368     4499    1       DCL XPTR$ PTR CALIGNED;
      369     4500        %EQU VBUFSIZ = 9000;
      370     4501
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:11   
      371     4502    1       ENTRYFLAG = %SENDTO;
      372     4503    1       GOTO COMMONDCBN;
      373     4504
      374     4505    1   XSL$QSENDTO: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS, DST, DSTLEN) ALTRET;
      375     4506
      376     4507    1       ENTRYFLAG = %SENDTO;
      377     4508    1       GOTO COMMONSOCK;
      378     4509
      379     4510    1   XSL$SEND: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS) ALTRET;
      380     4511
      381     4512    1       ENTRYFLAG = %SEND;
      382     4513    1       GOTO COMMONDCBN;
      383     4514
      384     4515    1   XSL$QSEND: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS) ALTRET;
      385     4516
      386     4517    1       ENTRYFLAG = %SEND;
      387     4518    1   COMMONSOCK:
      388     4519    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
      389     4520    1       GOTO LATER;
      390     4521
      391     4522    1   XSL$WRITE: ENTRY( RESULT, SOCK#, MSG, LEN) ALTRET;
      392     4523
      393     4524    1       ENTRYFLAG = %WRITE;
      394     4525    1       GOTO COMMONDCBN;
      395     4526
      396     4527    1   XSL$QWRITE: ENTRY( RESULT, SOCK#, MSG, LEN) ALTRET;
      397     4528
      398     4529    1       ENTRYFLAG = %WRITE;
      399     4530    1       GOTO COMMONSOCK;
      400     4531
      401     4532    1   COMMONDCBN:
      402     4533    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
      403     4534    1   LATER:
      404     4535    1       SOCK$ = XSL_SOCK$;
      405     4536    1       IF SOCK.RCRBYTSIZ = 0 THEN
      406     4537    1           SOCK.RCRBYTSIZ = 4096;  /* for MAXRDS=0 sockets */
      407     4538    2       IF SOCK.FLAGS.SENDSHUT THEN DO;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:12   
      408     4539    2           XSL_ERRNO = %E$SHUTDOWN;
      409     4540    2           GOTO BAILOUT;
      410     4541    2           END;
      411     4542    2       IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;
      412     4543    3           IF NOT SOCK.FLAGS.SOCKET THEN DO;
      413     4544    3               IF ENTRYFLAG = %SENDTO THEN
      414     4545    3                   CALL XSL$SOCKOPEN( SOCK, DST, DSTLEN) ALTRET( BAILOUT);
      415     4546    4               ELSE DO;
      416     4547    4                   XSL_ERRNO = %E$NOTBOUND;
      417     4548    4                   GOTO BAILOUT;
      418     4549    4                   END;
      419     4550    4               IF SOCK.FLAGS.REUSEADDR THEN DO;
      420     4551    4                   RESULT = SOCK.SOCK#;
      421     4552    4                   CALL XSL$QSETSOCKOPT( RESULT, RESULT, %XSL_SOL_SOCKET,
      422     4553    4                     %XSL_SO_REUSEADDR, 262144, 2);
      423     4554    4                   END;
      424     4555    3               END;
      425     4556    3           IF LEN > %VBUFSIZ THEN DO;
      426     4557    3               XSL_ERRNO = %E$MSGSIZE;
      427     4558    3               GOTO BAILOUT;
      428     4559    3               END;
      429     4560    2           END;
      430     4561    2       ELSE DO;
      431     4562    3           IF NOT SOCK.FLAGS.SOCKET THEN DO;
      432     4563    3               XSL_ERRNO = %E$NOTBOUND;
      433     4564    3               GOTO BAILOUT;
      434     4565    3               END;
      435     4566    3           IF SOCK.TYPE = %XSL_SOCK_STREAM AND NOT SOCK.FLAGS.CONNECT THEN DO;
      436     4567    3               XSL_ERRNO = %E$NOTCONN;
      437     4568    3               GOTO BAILOUT;
      438     4569    3               END;
      439     4570    2           END;
      440     4571            /* fire up some reads so SENDRSP/SENDTORSP will arrive */
      441     4572    2       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS AND
      442     4573    2         SOCK.BUFPND# <= SOCK.MAXBUF);
      443     4574    2           CALL XSL$GETBUF( SOCK) ALTRET( WRITE_READY);
      444     4575    2           END;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:13   
      445     4576    1   WRITE_READY:
      446     4577            /* o.k.... ready to send the data */
      447     4578    1       XLEN = LEN;
      448     4579    1       XPTR$ = ADDR( MSG);
      449     4580    1       RESULT = 0;
      450     4581    1   WRITE_LOOP:
      451     4582    1       SOCK.FLAGS.SELWRITE = '0'B;
      452     4583    2       IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;
      453     4584    2           XSL$SENDTORQS = XSL_SENDTORQS;
      454     4585    2           XSL$SENDTORQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);
      455     4586    2           IF XLEN > SOCK.RCRBYTSIZ THEN
      456     4587    2               XSL$SENDTORQS.FLAGS = XSL$SENDTORQS.FLAGS + %XSL_MSG_MORE;
      457     4588    3           IF ENTRYFLAG = %SENDTO AND ADDR( DST) ~= ADDR( NIL) THEN DO;
      458     4589    3               XSL$SENDTORQS.NAMELEN = DSTLEN;
      459     4590    3               CALL XSL$HTONADDR( XSL$SENDTORQS.NAME, DST);
      460     4591    3               END;
      461     4592    3           ELSE DO;
      462     4593    3               XSL$SENDTORQS.NAMELEN = SIZEC( SOCK.PEERNAME);
      463     4594    3               XSL$SENDTORQS.NAME = SOCK.PEERNAME;
      464     4595    3               END;
      465     4596    2           CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SENDTORQS), XLEN, XMSG)
      466     4597    2             ALTRET( ERRWRITE);
      467     4598    2           END;
      468     4599    2       ELSE DO;
      469     4600    2           XSL$SENDRQS = XSL_SENDRQS;
      470     4601    2           IF ENTRYFLAG = %SEND THEN
      471     4602    2               XSL$SENDRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);
      472     4603    2           CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SENDRQS), XLEN, XMSG)
      473     4604    2             ALTRET( ERRWRITE);
      474     4605    2           END;
      475     4606    1       RESULT = RESULT + XLEN;
      476     4607    1       SOCK.FLAGS.SELWRITE = '1'B;
      477     4608    1   SUCCESS:
      478     4609    1       RETURN;
      479     4610    1   ERRWRITE:
      480     4611    2       IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD THEN DO;
      481     4612    2           XLEN = XLEN - SOCK.RCRBYTSIZ;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:14   
      482     4613    2           XPTR$ = PINCRC( XPTR$, SOCK.RCRBYTSIZ);
      483     4614    2           RESULT = RESULT + SOCK.RCRBYTSIZ;
      484     4615    2           GOTO WRITE_LOOP;
      485     4616    2           END;
      486     4617    2       IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$NODAT THEN DO;
      487     4618    3           IF NOT SOCK.FLAGS.BLOCKING THEN DO;
      488     4619    3               IF RESULT > 0 THEN
      489     4620    3                   GOTO SUCCESS;
      490     4621    3               XSL_ERRNO = %E$WOULDBLOCK;
      491     4622    3               GOTO BAILOUT;
      492     4623    3               END;
      493     4624    2           IF SOCK.MAXRDS = 0 THEN
      494     4625    2               CALL M$WAIT( XSL_WAIT1SEC);
      495     4626    3           ELSE DO INHIBIT;
      496     4627    3               XSL_UETIME = 0;
      497     4628    4               DO WHILE( XSL_UETIME = 0);
      498     4629    4                   IF SOCK.FLAGS.SELWRITE THEN EXIT;
      499     4630    4                   CALL XSL$EVLOG( 'WT', ADDR( SOCK));
      500     4631    4                   CALL M$WAIT( XSL_WAIT1DAY);
      501     4632    4                   END;
      502     4633    3               END;
      503     4634    2           GOTO WRITE_LOOP;
      504     4635    2           END;
      505     4636    1   BAILOUTM1:
      506     4637    1       XSL_ERRNO = %E$FAILURE;  /* make appl get errcode from TCB */
      507     4638    1   BAILOUT:
      508     4639    1       RESULT = %E$FAILURE;
      509     4640    1       ALTRETURN;
      510     4641
      511     4642    1   END XSL$SENDTO;
      512     4643        %EOD;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:15   
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B_ERRORS_C.:LIBRARY  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$SENDTO.

   Procedure XSL$SENDTO requires 304 words for executable code.
   Procedure XSL$SENDTO requires 20 words of local(AUTO) storage.

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:16   

 Object Unit name= XSL$SENDTO                                 File name= XSL$SOCKET2.:TCA2TOU
 UTS= NOV 16 '97 14:30:55.24 SUN                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   DCB   even  none     0      0  M$UC
    1  RoData even  UTS      8     10  XSL$SENDTO
    2   Proc  even  none   304    460  XSL$SENDTO
    3  RoData even  none    12     14  XSL$SENDTO

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     2      0   yes    yes     yes      Std        7  XSL$SENDTO
     2      4          yes     yes      Std        7  XSL$QSENDTO
     2     10          yes     yes      Std        5  XSL$SEND
     2     15          yes     yes      Std        5  XSL$QSEND
     2     31          yes     yes      Std        4  XSL$WRITE
     2     36          yes     yes      Std        4  XSL$QWRITE

  ****  Data defs  ****

 Sect OctLoc  Name                           Sect OctLoc  Name
    1      0  XSL_SENDRQS                        1      1  XSL_SENDTORQS
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:17   

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XSL$SOCKPTR
 yes     yes           Std       3 XSL$SOCKOPEN
 yes     yes           Std       4 XSL$CL_WRITE
 yes     yes           Std       2 XSL$DCBNPTR
 yes     yes           Std       6 XSL$QSETSOCKOPT
 yes     yes           Std       2 XSL$GETBUF
         yes           Std       2 XSL$EVLOG
         yes           Std       2 XSL$HTONADDR
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     M$UC                                  XSL_WAIT1DAY                          XSL_WAIT1SEC
r    B$TCB$                                XSL_ERRNO                        r    XSL_KEYBUF$
     XSL_UETIME                            B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ROSID                                 ISSID
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:18   


        1        1        /*M*    XSL$SOCKET2             BSD4.3 Socket Library for CP-6, part 2  */
        2        2        /*T***********************************************************/
        3        3        /*T*                                                         */
        4        4        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
        5        5        /*T*                                                         */
        6        6        /*T***********************************************************/
        7        7        /*X* DMC,PLM=4,IND=4,DCI=8,DTI=0,ENI=4,ECI=4,CSI=4,DIN=4,SDI=0 */
        8        8
        9        9        /*F* NAME: sendto() and XSL$SENDTO  --  Write Data With Options And Address
       10       10        ..::IT "Purpose:"
       11       11        .INL +4
       12       12        Sends a message from an application-specified buffer to a socket.  This
       13       13        function is typically used when the destination socket changes from
       14       14        invocation to invocation.
       15       15        ..::IT "C Usage:"
       16       16        .INL 4
       17       17        .FIF
       18       18        status = sendto( s, msg, len, flags, to, tolen );
       19       19        ..::IT "PL6 Usage:"
       20       20        .INL 4
       21       21        .FIF
       22       22        CALL XSL$SENDTO( status, s, msg, len, flags, to, tolen );
       23       23        ..::IT "Parameters:"
       24       24        .INL 4
       25       25        .FIF
       26       26        s           integer socket descriptor
       27       27
       28       28        msg         character array containing message to be sent
       29       29
       30       30        len         integer number of significant characters in msg
       31       31
       32       32        flags       integer bitflags of sendto options
       33       33
       34       34        to          sockaddr structure
       35       35
       36       36        tolen       integer size of to in characters
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:19   
       37       37        ..::IT "Result:"
       38       38        .INL 4
       39       39        .FIF
       40       40        status      integer number of characters sent or error code
       41       41        ..::IT "Description:"
       42       42        The sendto() function sends a message from an application-defined buffer
       43       43        to a socket.  On datagram sockets the message is sent atomically; if
       44       44        this is not possible then the error EMSGSIZE is reported.
       45       45        .SPB
       46       46        The s parameter specifies the descriptor of the socket to be written to.
       47       47        .SPB
       48       48        The msg parameter specifies an application-defined buffer containing the
       49       49        message to be sent to the socket.
       50       50        .SPB
       51       51        The len parameter specifies the number of characters to be sent.
       52       52        .SPB
       53       53        The flags parameter specifies sendto options.  The only option currently
       54       54        implemented is "out-of-band", which causes the message to be sent on the
       55       55        out-of-band data path if the socket supports it.  This is selected by coding
       56       56        SOF_OOB or %XSL_SOF_OOB in C or PL6 source, respectively.
       57       57        .SPB
       58       58        The to parameter specifies the address of the remote socket to receive
       59       59        the message.  In C source, it is a sockaddr structure.  In PL6 source, it is
       60       60        an XSL$SOCKADDR structure.
       61       61        .SPB
       62       62        The tolen parameter specifies the number of significant characters in to.
       63       63        .SPB
       64       64        If the sendto() function is successful, the status result contains the
       65       65        number of characters sent to the socket.  This number is non-negative.
       66       66        A successful result does not guarantee that the message was delivered,
       67       67        but only that it was sent to the FEP for network transmission.  The
       68       68        status value may be less than the len value if the socket is
       69       69        nonblocking and no more data could be immediately sent.
       70       70        .SPB
       71       71        If the sendto() function is unsuccessful, the status result contains
       72       72        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
       73       73        to determine the specific error condition.  The XSL$SENDTO procedure
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:20   
       74       74        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
       75       75        to the sendto() function.
       76       76        .SPB
       77       77        Sendto() may be used on sockets regardless of whether connect() has been
       78       78        issued.
       79       79        .SPB
       80       80        If shutdown() has been invoked for this socket to inhibit transmission
       81       81        of data, all sendto() operations report the error ESHUTDOWN.
       82       82        ..::IT "Errors:"
       83       83        Following are the possible error conditions reported when the sendto()
       84       84        function is unsuccessful.  Equates for the possible values can be found in
       85       85        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
       86       86
       87       87        .FIF
       88       88
       89       89        C #define               PL6 %EQU
       90       90        ----------------------- -----------------------
       91       91        EBADF                   E$BADF
       92       92        .FIN
       93       93        The descriptor s is not appropriate to identify a socket.
       94       94        .FIF
       95       95
       96       96        EMSGSIZE                E$MSGSIZE
       97       97        .FIN
       98       98        The message is too long to send atomically.
       99       99        .FIF
      100      100
      101      101        ENOTSOCK                E$NOTSOCK
      102      102        .FIN
      103      103        The descriptor s is no longer valid to identify a socket.
      104      104        .FIF
      105      105
      106      106        ESHUTDOWN               E$SHUTDOWN
      107      107        .FIN
      108      108        Can't send after socket shutdown.
      109      109        .FIF
      110      110
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:21   
      111      111        EWOULDBLOCK             E$WOULDBLOCK
      112      112        .FIN
      113      113        The message cannot be immediately sent.
      114      114        .FIF
      115      115        */
      116      116        /*F* NAME: send() and XSL$SEND  --  Write Data With Options
      117      117        ..::IT "Purpose:"
      118      118        .INL +4
      119      119        Sends a message from an application-specified buffer to a connected socket.
      120      120        ..::IT "C Usage:"
      121      121        .INL 4
      122      122        .FIF
      123      123        status = send( s, msg, len, flags );
      124      124        ..::IT "PL6 Usage:"
      125      125        .INL 4
      126      126        .FIF
      127      127        CALL XSL$SEND( status, s, msg, len, flags );
      128      128        ..::IT "Parameters:"
      129      129        .INL 4
      130      130        .FIF
      131      131        s           integer socket descriptor
      132      132
      133      133        msg         character array containing message to be sent
      134      134
      135      135        len         integer number of significant characters in msg
      136      136
      137      137        flags       integer bitflags of send options
      138      138        ..::IT "Result:"
      139      139        .INL 4
      140      140        .FIF
      141      141        status      integer number of characters sent or error code
      142      142        ..::IT "Description:"
      143      143        The send() function sends a message from an application-defined buffer
      144      144        to a socket.  On datagram sockets the message is sent atomically; if
      145      145        this is not possible then the error EMSGSIZE is reported.
      146      146        .SPB
      147      147        The s parameter specifies the descriptor of the socket to be written to.
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:22   
      148      148        .SPB
      149      149        The msg parameter specifies an application-defined buffer containing the
      150      150        message to be sent to the socket.
      151      151        .SPB
      152      152        The len parameter specifies the number of characters to be sent.
      153      153        .SPB
      154      154        The flags parameter specifies send options.  The only option currently
      155      155        implemented is "out-of-band", which causes the message to be sent on the
      156      156        out-of-band data path if the socket supports it.  This is selected by coding
      157      157        SOF_OOB or %XSL_SOF_OOB in C or PL6 source, respectively.
      158      158        .SPB
      159      159        If the send() function is successful, the status result contains the
      160      160        number of characters sent to the socket.  This number is non-negative.
      161      161        A successful result does not guarantee that the message was delivered,
      162      162        but only that it was sent to the FEP for network transmission.  The
      163      163        status value may be less than the len value if the socket is
      164      164        nonblocking and no more data could be immediately sent.
      165      165        .SPB
      166      166        If the send() function is unsuccessful, the status result contains
      167      167        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      168      168        to determine the specific error condition.  The XSL$SEND procedure
      169      169        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      170      170        to the send() function.
      171      171        .SPB
      172      172        Send() may be used only on sockets that have had connect() invoked.
      173      173        .SPB
      174      174        If shutdown() has been invoked for this socket to inhibit transmission
      175      175        of data, all send() operations report the error ESHUTDOWN.
      176      176        ..::IT "Errors:"
      177      177        Following are the possible error conditions reported when the send()
      178      178        function is unsuccessful.  Equates for the possible values can be found in
      179      179        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      180      180
      181      181        .FIF
      182      182
      183      183        C #define               PL6 %EQU
      184      184        ----------------------- -----------------------
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:23   
      185      185        EBADF                   E$BADF
      186      186        .FIN
      187      187        The descriptor s is not appropriate to identify a socket.
      188      188        .FIF
      189      189
      190      190        EMSGSIZE                E$MSGSIZE
      191      191        .FIN
      192      192        The specified message is too long to send atomically.
      193      193        .FIF
      194      194
      195      195        ENOTBOUND               E$NOTBOUND
      196      196        .FIN
      197      197        The socket is not bound to a FEP.
      198      198        .FIF
      199      199
      200      200        ENOTCONN                E$NOTCONN
      201      201        .FIN
      202      202        The connect() function has not been invoked for this socket.
      203      203        .FIF
      204      204
      205      205        ENOTSOCK                E$NOTSOCK
      206      206        .FIN
      207      207        The descriptor s is no longer valid to identify a socket.
      208      208        .FIF
      209      209
      210      210        ESHUTDOWN               E$SHUTDOWN
      211      211        .FIN
      212      212        Can't send after socket shutdown.
      213      213        .FIF
      214      214
      215      215        EWOULDBLOCK             E$WOULDBLOCK
      216      216        .FIN
      217      217        The message cannot be immediately sent.
      218      218        .FIF
      219      219        */
      220      220        /*F* NAME: write() and XSL$WRITE  --  Write Data
      221      221        ..::IT "Purpose:"
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:24   
      222      222        .INL +4
      223      223        Writes data from an application-specified buffer to a socket.
      224      224        ..::IT "C Usage:"
      225      225        .INL 4
      226      226        .FIF
      227      227        status = write( s, buf, len );
      228      228        ..::IT "PL6 Usage:"
      229      229        .INL 4
      230      230        .FIF
      231      231        CALL XSL$WRITE( status, s, buf, len );
      232      232        ..::IT "Parameters:"
      233      233        .INL 4
      234      234        .FIF
      235      235        s           integer socket descriptor
      236      236
      237      237        buf         character array buffer
      238      238
      239      239        len         integer number of significant characters in buf
      240      240        ..::IT "Result:"
      241      241        .INL 4
      242      242        .FIF
      243      243        status      integer number of characters written or error code
      244      244        ..::IT "Description:"
      245      245        The write() function writes data from the specified buffer to the socket.
      246      246        On datagram sockets the data is written atomically; if this is not
      247      247        possible then the error EMSGSIZE is reported.
      248      248        .SPB
      249      249        The s parameter specifies the descriptor of the socket to be written to.
      250      250        .SPB
      251      251        The buf parameter specifies an application-defined buffer containing the
      252      252        data to be written to the socket.
      253      253        .SPB
      254      254        The len parameter specifies the number of characters to be written.
      255      255        .SPB
      256      256        If the write() function is successful, the status result contains the
      257      257        number of characters written to the socket.  This number is non-negative.
      258      258        A successful result does not guarantee that the data was delivered,
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:25   
      259      259        but only that it was sent to the FEP for network transmission.  The
      260      260        status value may be less than the len value if the socket is
      261      261        nonblocking and no more data could be immediately sent.
      262      262        .SPB
      263      263        If the write() function is unsuccessful, the status result contains
      264      264        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      265      265        to determine the specific error condition.  The XSL$WRITE procedure
      266      266        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      267      267        to the write() function.
      268      268        .SPB
      269      269        Write() may be used only on sockets that have had connect() invoked.
      270      270        .SPB
      271      271        If shutdown() has been invoked for this socket to inhibit transmission
      272      272        of data, all write() operations report the error ESHUTDOWN.
      273      273        ..::IT "Errors:"
      274      274        Following are the possible error conditions reported when the write()
      275      275        function is unsuccessful.  Equates for the possible values can be
      276      276        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
      277      277
      278      278        .FIF
      279      279
      280      280        C #define               PL6 %EQU
      281      281        ----------------------- -----------------------
      282      282        EBADF                   E$BADF
      283      283        .FIN
      284      284        The descriptor s is not appropriate to identify a socket.
      285      285        .FIF
      286      286
      287      287        EMSGSIZE                E$MSGSIZE
      288      288        .FIN
      289      289        The specified buffer is too long to send atomically.
      290      290        .FIF
      291      291
      292      292        ENOTBOUND               E$NOTBOUND
      293      293        .FIN
      294      294        The socket is not bound to a FEP.
      295      295        .FIF
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:26   
      296      296
      297      297        ENOTCONN                E$NOTCONN
      298      298        .FIN
      299      299        The socket is not currently connected.  connect() has not been invoked.
      300      300        .FIF
      301      301
      302      302        ENOTSOCK                E$NOTSOCK
      303      303        .FIN
      304      304        The descriptor s is no longer valid to identify a socket.
      305      305        .FIF
      306      306
      307      307        ESHUTDOWN               E$SHUTDOWN
      308      308        .FIN
      309      309        Can't send after socket shutdown.
      310      310        .FIF
      311      311
      312      312        EWOULDBLOCK             E$WOULDBLOCK
      313      313        .FIN
      314      314        The data cannot be immediately sent.
      315      315        .FIF
      316      316        */
      317      317        XSL$SENDTO: PROC( RESULT, SOCK#, MSG, LEN, FLAGS, DST, DSTLEN) ALTRET;

    317  2 000000   000000 700200 xent  XSL$SENDTO   TSX0  ! X66_AUTO_N
         2 000001   000024 000007                    ZERO    20,7

      318      318        %INCLUDE B_ERRORS_C;
      319     1445        %INCLUDE CP_6;
      320     1526            %B$ALT;
      321     1534            %B$TCB( STCLASS="BASED( B$TCB$)");
      322     1537            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
      323     1551            %FPT_WAIT( FPTN=XSL_WAIT1SEC, STCLASS=SYMREF);
      324     1565            %F$DCB;
      325     1622        %INCLUDE XSL_SOCKET_E;
      326     1880        %INCLUDE XSL_SOCKET_M;
      327     2641            %XSL$SOCKADDR( FPTN=DST, STCLASS=);
      328     2681        %INCLUDE XSL_PERR_C;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:27   
      329     2736        %INCLUDE XSL_INTERNAL_M;
      330     2987            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
      331     3131        %INCLUDE XSL_SOCKMSGS_E;
      332     3177        %INCLUDE XSL_SOCKMSGS_M;
      333     4310            %XSL$SENDRQS( FPTN=XSL_SENDRQS, STCLASS="CONSTANT SYMDEF");
      334     4336            %XSL$SENDRQS( STCLASS="BASED( XSL_KEYBUF$)");
      335     4362            %XSL$SENDTORQS( FPTN=XSL_SENDTORQS, STCLASS="CONSTANT SYMDEF");
      336     4415            %XSL$SENDTORQS( STCLASS="BASED( XSL_KEYBUF$)");
      337     4468
      338     4469    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
      339     4470    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
      340     4471    1       DCL XSL$HTONADDR ENTRY(2);
      341     4472    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
      342     4473    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
      343     4474    1       DCL XSL$QSETSOCKOPT ENTRY(6) ALTRET;
      344     4475    1       DCL XSL$SOCKOPEN ENTRY(3) ALTRET;
      345     4476    1       DCL XSL$EVLOG ENTRY(2);
      346     4477    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
      347     4478
      348     4479    1       DCL B$TCB$ PTR SYMREF READONLY;
      349     4480    1       DCL XSL_ERRNO SBIN SYMREF;
      350     4481    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
      351     4482    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
      352     4483    1       DCL XSL_SOCK$$ PTR SYMREF;
      353     4484    1       DCL XSL_UETIME SBIN SYMREF;
      354     4485
      355     4486    1       DCL DSTLEN SBIN;
      356     4487    1       DCL ENTRYFLAG SBIN;
      357     4488        %EQU SENDTO = 0;
      358     4489        %EQU SEND = 1;
      359     4490        %EQU WRITE = 2;
      360     4491    1       DCL FLAGS UBIN;
      361     4492    1       DCL LEN SBIN;
      362     4493    1       DCL MSG CHAR( LEN) CALIGNED;
      363     4494    1       DCL RESULT SBIN;
      364     4495    1       DCL SOCK# SBIN;
      365     4496    1       DCL SOCK$ PTR;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:28   
      366     4497    1       DCL XLEN SBIN;
      367     4498    1       DCL XMSG CHAR( XLEN) BASED( XPTR$);
      368     4499    1       DCL XPTR$ PTR CALIGNED;
      369     4500        %EQU VBUFSIZ = 9000;
      370     4501
      371     4502    1       ENTRYFLAG = %SENDTO;

   4502  2 000002   200012 450100                    STZ     ENTRYFLAG,,AUTO

      372     4503    1       GOTO COMMONDCBN;

   4503  2 000003   000043 710000 2                  TRA     COMMONDCBN

      373     4504
      374     4505    1   XSL$QSENDTO: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS, DST, DSTLEN) ALTRET;

   4505  2 000004   000000 700200 xent  XSL$QSENDTO  TSX0  ! X66_AUTO_N
         2 000005   000024 000007                    ZERO    20,7

      375     4506
      376     4507    1       ENTRYFLAG = %SENDTO;

   4507  2 000006   200012 450100                    STZ     ENTRYFLAG,,AUTO

      377     4508    1       GOTO COMMONSOCK;

   4508  2 000007   000021 710000 2                  TRA     COMMONSOCK

      378     4509
      379     4510    1   XSL$SEND: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS) ALTRET;

   4510  2 000010   000000 700200 xent  XSL$SEND     TSX0  ! X66_AUTO_N
         2 000011   000024 000007                    ZERO    20,7

      380     4511
      381     4512    1       ENTRYFLAG = %SEND;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:29   
   4512  2 000012   000001 235007                    LDA     1,DL
         2 000013   200012 755100                    STA     ENTRYFLAG,,AUTO

      382     4513    1       GOTO COMMONDCBN;

   4513  2 000014   000043 710000 2                  TRA     COMMONDCBN

      383     4514
      384     4515    1   XSL$QSEND: ENTRY( RESULT, SOCK#, MSG, LEN, FLAGS) ALTRET;

   4515  2 000015   000000 700200 xent  XSL$QSEND    TSX0  ! X66_AUTO_N
         2 000016   000024 000007                    ZERO    20,7

      385     4516
      386     4517    1       ENTRYFLAG = %SEND;

   4517  2 000017   000001 235007                    LDA     1,DL
         2 000020   200012 755100                    STA     ENTRYFLAG,,AUTO

      387     4518    1   COMMONSOCK:
      388     4519    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   4519  2 000021   000000 236000 3     COMMONSOCK   LDQ     0
         2 000022   200004 235100                    LDA     @SOCK#,,AUTO
         2 000023   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000024   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000025   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000026   000000 701000 xent               TSX1    XSL$SOCKPTR
         2 000027   000454 702000 2                  TSX2    BAILOUT

      389     4520    1       GOTO LATER;

   4520  2 000030   000052 710000 2                  TRA     LATER

      390     4521
      391     4522    1   XSL$WRITE: ENTRY( RESULT, SOCK#, MSG, LEN) ALTRET;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:30   
   4522  2 000031   000000 700200 xent  XSL$WRITE    TSX0  ! X66_AUTO_N
         2 000032   000024 000007                    ZERO    20,7

      392     4523
      393     4524    1       ENTRYFLAG = %WRITE;

   4524  2 000033   000002 235007                    LDA     2,DL
         2 000034   200012 755100                    STA     ENTRYFLAG,,AUTO

      394     4525    1       GOTO COMMONDCBN;

   4525  2 000035   000043 710000 2                  TRA     COMMONDCBN

      395     4526
      396     4527    1   XSL$QWRITE: ENTRY( RESULT, SOCK#, MSG, LEN) ALTRET;

   4527  2 000036   000000 700200 xent  XSL$QWRITE   TSX0  ! X66_AUTO_N
         2 000037   000024 000007                    ZERO    20,7

      397     4528
      398     4529    1       ENTRYFLAG = %WRITE;

   4529  2 000040   000002 235007                    LDA     2,DL
         2 000041   200012 755100                    STA     ENTRYFLAG,,AUTO

      399     4530    1       GOTO COMMONSOCK;

   4530  2 000042   000021 710000 2                  TRA     COMMONSOCK

      400     4531
      401     4532    1   COMMONDCBN:
      402     4533    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   4533  2 000043   000000 236000 3     COMMONDCBN   LDQ     0
         2 000044   200004 235100                    LDA     @SOCK#,,AUTO
         2 000045   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000046   200016 630500                    EPPR0   XPTR$+1,,AUTO
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:31   
         2 000047   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000050   000000 701000 xent               TSX1    XSL$DCBNPTR
         2 000051   000454 702000 2                  TSX2    BAILOUT

      403     4534    1   LATER:
      404     4535    1       SOCK$ = XSL_SOCK$;

   4535  2 000052   000000 236000 xsym  LATER        LDQ     XSL_ERRNO
         2 000053   200013 756100                    STQ     SOCK$,,AUTO

      405     4536    1       IF SOCK.RCRBYTSIZ = 0 THEN

   4536  2 000054   200013 470500                    LDP0    SOCK$,,AUTO
         2 000055   000017 220100                    LDX0    15,,PR0
         2 000056   000061 601000 2                  TNZ     s:4538

      406     4537    1           SOCK.RCRBYTSIZ = 4096;  /* for MAXRDS=0 sockets */

   4537  2 000057   010000 221003                    LDX1    4096,DU
         2 000060   000017 741100                    STX1    15,,PR0

      407     4538    2       IF SOCK.FLAGS.SENDSHUT THEN DO;

   4538  2 000061   000001 236100                    LDQ     1,,PR0
         2 000062   200000 316003                    CANQ    65536,DU
         2 000063   000067 600000 2                  TZE     s:4542

      408     4539    2           XSL_ERRNO = %E$SHUTDOWN;

   4539  2 000064   000165 235007                    LDA     117,DL
         2 000065   000000 755000 xsym               STA     XSL_ERRNO

      409     4540    2           GOTO BAILOUT;

   4540  2 000066   000454 710000 2                  TRA     BAILOUT

      410     4541    2           END;
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:32   
      411     4542    2       IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;

   4542  2 000067   000000 236100                    LDQ     0,,PR0
         2 000070   000777 376003                    ANQ     511,DU
         2 000071   000002 116003                    CMPQ    2,DU
         2 000072   000147 601000 2                  TNZ     s:4562

      412     4543    3           IF NOT SOCK.FLAGS.SOCKET THEN DO;

   4543  2 000073   000001 236100                    LDQ     1,,PR0
         2 000074   002000 316003                    CANQ    1024,DU
         2 000075   000140 601000 2                  TNZ     s:4556

      413     4544    3               IF ENTRYFLAG = %SENDTO THEN

   4544  2 000076   200012 235100                    LDA     ENTRYFLAG,,AUTO
         2 000077   000112 601000 2                  TNZ     s:4547

      414     4545    3                   CALL XSL$SOCKOPEN( SOCK, DST, DSTLEN) ALTRET( BAILOUT);

   4545  2 000100   200011 236100                    LDQ     @DSTLEN,,AUTO
         2 000101   200020 756100                    STQ     XPTR$+3,,AUTO
         2 000102   200010 236100                    LDQ     @DST,,AUTO
         2 000103   200013 235100                    LDA     SOCK$,,AUTO
         2 000104   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000105   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000106   000021 631400 xsym               EPPR1   B_VECTNIL+17
         2 000107   000000 701000 xent               TSX1    XSL$SOCKOPEN
         2 000110   000454 702000 2                  TSX2    BAILOUT
         2 000111   000115 710000 2                  TRA     s:4550

      415     4546    4               ELSE DO;

      416     4547    4                   XSL_ERRNO = %E$NOTBOUND;

   4547  2 000112   000401 235007                    LDA     257,DL
         2 000113   000000 755000 xsym               STA     XSL_ERRNO
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:33   

      417     4548    4                   GOTO BAILOUT;

   4548  2 000114   000454 710000 2                  TRA     BAILOUT

      418     4549    4                   END;
      419     4550    4               IF SOCK.FLAGS.REUSEADDR THEN DO;

   4550  2 000115   200013 470500                    LDP0    SOCK$,,AUTO
         2 000116   000001 236100                    LDQ     1,,PR0
         2 000117   000400 316003                    CANQ    256,DU
         2 000120   000140 600000 2                  TZE     s:4556

      420     4551    4                   RESULT = SOCK.SOCK#;

   4551  2 000121   000000 236100                    LDQ     0,,PR0
         2 000122   000777 376007                    ANQ     511,DL
         2 000123   200003 471500                    LDP1    @RESULT,,AUTO
         2 000124   100000 756100                    STQ     0,,PR1

      421     4552    4                   CALL XSL$QSETSOCKOPT( RESULT, RESULT, %XSL_SOL_SOCKET,

   4552  2 000125   000002 237000 3                  LDAQ    2
         2 000126   200022 757100                    STAQ    XPTR$+5,,AUTO
         2 000127   000004 237000 3                  LDAQ    4
         2 000130   200020 757100                    STAQ    XPTR$+3,,AUTO
         2 000131   200003 236100                    LDQ     @RESULT,,AUTO
         2 000132   200003 235100                    LDA     @RESULT,,AUTO
         2 000133   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000134   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000135   000024 631400 xsym               EPPR1   B_VECTNIL+20
         2 000136   000000 701000 xent               TSX1    XSL$QSETSOCKOPT
         2 000137   000000 011000                    NOP     0

      422     4553    4                     %XSL_SO_REUSEADDR, 262144, 2);
      423     4554    4                   END;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:34   
      424     4555    3               END;

      425     4556    3           IF LEN > %VBUFSIZ THEN DO;

   4556  2 000140   200006 470500                    LDP0    @LEN,,AUTO
         2 000141   000000 235100                    LDA     0,,PR0
         2 000142   021450 115007                    CMPA    9000,DL
         2 000143   000167 604400 2                  TMOZ    s:4572

      426     4557    3               XSL_ERRNO = %E$MSGSIZE;

   4557  2 000144   000143 236007                    LDQ     99,DL
         2 000145   000000 756000 xsym               STQ     XSL_ERRNO

      427     4558    3               GOTO BAILOUT;

   4558  2 000146   000454 710000 2                  TRA     BAILOUT

      428     4559    3               END;
      429     4560    2           END;
      430     4561    2       ELSE DO;

      431     4562    3           IF NOT SOCK.FLAGS.SOCKET THEN DO;

   4562  2 000147   000001 236100                    LDQ     1,,PR0
         2 000150   002000 316003                    CANQ    1024,DU
         2 000151   000155 601000 2                  TNZ     s:4566

      432     4563    3               XSL_ERRNO = %E$NOTBOUND;

   4563  2 000152   000401 235007                    LDA     257,DL
         2 000153   000000 755000 xsym               STA     XSL_ERRNO

      433     4564    3               GOTO BAILOUT;

   4564  2 000154   000454 710000 2                  TRA     BAILOUT

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:35   
      434     4565    3               END;
      435     4566    3           IF SOCK.TYPE = %XSL_SOCK_STREAM AND NOT SOCK.FLAGS.CONNECT THEN DO;

   4566  2 000155   000000 236100                    LDQ     0,,PR0
         2 000156   000777 376003                    ANQ     511,DU
         2 000157   000001 116003                    CMPQ    1,DU
         2 000160   000167 601000 2                  TNZ     s:4572
         2 000161   000001 236100                    LDQ     1,,PR0
         2 000162   040000 316003                    CANQ    16384,DU
         2 000163   000167 601000 2                  TNZ     s:4572

      436     4567    3               XSL_ERRNO = %E$NOTCONN;

   4567  2 000164   000164 235007                    LDA     116,DL
         2 000165   000000 755000 xsym               STA     XSL_ERRNO

      437     4568    3               GOTO BAILOUT;

   4568  2 000166   000454 710000 2                  TRA     BAILOUT

      438     4569    3               END;
      439     4570    2           END;
      440     4571            /* fire up some reads so SENDRSP/SENDTORSP will arrive */
      441     4572    2       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS AND

   4572  2 000167   000174 710000 2                  TRA     s:4575

      442     4573    2         SOCK.BUFPND# <= SOCK.MAXBUF);
      443     4574    2           CALL XSL$GETBUF( SOCK) ALTRET( WRITE_READY);

   4574  2 000170   200013 630500                    EPPR0   SOCK$,,AUTO
         2 000171   000017 631400 xsym               EPPR1   B_VECTNIL+15
         2 000172   000000 701000 xent               TSX1    XSL$GETBUF
         2 000173   000215 702000 2                  TSX2    WRITE_READY

      444     4575    2           END;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:36   
   4575  2 000174   000006 470400 3                  LDP0    6
         2 000175   000000 471500                    LDP1    0,,PR0
         2 000176   200013 473500                    LDP3    SOCK$,,AUTO
         2 000177   300003 720100                    LXL0    3,,PR3
         2 000200   100000 474510                    LDP4    0,X0,PR1
         2 000201   300020 236100                    LDQ     16,,PR3
         2 000202   777777 376007                    ANQ     -1,DL
         2 000203   200016 756100                    STQ     XPTR$+1,,AUTO
         2 000204   400074 236100                    LDQ     60,,PR4
         2 000205   000033 772000                    QRL     27
         2 000206   000377 376007                    ANQ     255,DL
         2 000207   200016 116100                    CMPQ    XPTR$+1,,AUTO
         2 000210   000215 605000 2                  TPL     WRITE_READY
         2 000211   300017 720100                    LXL0    15,,PR3
         2 000212   300020 100100                    CMPX0   16,,PR3
         2 000213   000170 602000 2                  TNC     s:4574
         2 000214   000170 600000 2                  TZE     s:4574

      445     4576    1   WRITE_READY:
      446     4577            /* o.k.... ready to send the data */
      447     4578    1       XLEN = LEN;

   4578  2 000215   200006 470500       WRITE_READY  LDP0    @LEN,,AUTO
         2 000216   000000 235100                    LDA     0,,PR0
         2 000217   200014 755100                    STA     XLEN,,AUTO

      448     4579    1       XPTR$ = ADDR( MSG);

   4579  2 000220   200005 236100                    LDQ     @MSG,,AUTO
         2 000221   200015 756100                    STQ     XPTR$,,AUTO

      449     4580    1       RESULT = 0;

   4580  2 000222   200003 471500                    LDP1    @RESULT,,AUTO
         2 000223   100000 450100                    STZ     0,,PR1

      450     4581    1   WRITE_LOOP:
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:37   
      451     4582    1       SOCK.FLAGS.SELWRITE = '0'B;

   4582  2 000224   200013 470500       WRITE_LOOP   LDP0    SOCK$,,AUTO
         2 000225   000007 236000 3                  LDQ     7
         2 000226   000001 356100                    ANSQ    1,,PR0

      452     4583    2       IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;

   4583  2 000227   000000 236100                    LDQ     0,,PR0
         2 000230   000777 376003                    ANQ     511,DU
         2 000231   000002 116003                    CMPQ    2,DU
         2 000232   000314 601000 2                  TNZ     s:4600

      453     4584    2           XSL$SENDTORQS = XSL_SENDTORQS;

   4584  2 000233   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000234   000100 100400                    MLR     fill='000'O
         2 000235   000001 000026 1                  ADSC9   XSL_SENDTORQS            cn=0,n=22
         2 000236   100000 000026                    ADSC9   0,,PR1                   cn=0,n=22

      454     4585    2           XSL$SENDTORQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);

   4585  2 000237   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000240   300000 236100                    LDQ     0,,PR3
         2 000241   000177 376007                    ANQ     127,DL
         2 000242   000000 620006                    EAX0    0,QL
         2 000243   100000 440100                    SXL0    0,,PR1

      455     4586    2           IF XLEN > SOCK.RCRBYTSIZ THEN

   4586  2 000244   000017 236100                    LDQ     15,,PR0
         2 000245   000022 772000                    QRL     18
         2 000246   200014 116100                    CMPQ    XLEN,,AUTO
         2 000247   000252 605000 2                  TPL     s:4588

      456     4587    2               XSL$SENDTORQS.FLAGS = XSL$SENDTORQS.FLAGS + %XSL_MSG_MORE;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:38   
   4587  2 000250   000200 621010                    EAX1    128,X0
         2 000251   100000 441100                    SXL1    0,,PR1

      457     4588    3           IF ENTRYFLAG = %SENDTO AND ADDR( DST) ~= ADDR( NIL) THEN DO;

   4588  2 000252   200012 235100                    LDA     ENTRYFLAG,,AUTO
         2 000253   000273 601000 2                  TNZ     s:4593
         2 000254   200010 236100                    LDQ     @DST,,AUTO
         2 000255   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000256   000273 600000 2                  TZE     s:4593

      458     4589    3               XSL$SENDTORQS.NAMELEN = DSTLEN;

   4589  2 000257   200011 474500                    LDP4    @DSTLEN,,AUTO
         2 000260   400000 720100                    LXL0    0,,PR4
         2 000261   100001 740100                    STX0    1,,PR1

      459     4590    3               CALL XSL$HTONADDR( XSL$SENDTORQS.NAME, DST);

   4590  2 000262   200017 756100                    STQ     XPTR$+2,,AUTO
         2 000263   000000 236000 xsym               LDQ     XSL_KEYBUF$
         2 000264   000010 036000 3                  ADLQ    8
         2 000265   200016 756100                    STQ     XPTR$+1,,AUTO
         2 000266   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000267   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000270   000000 701000 xent               TSX1    XSL$HTONADDR
         2 000271   000000 011000                    NOP     0

      460     4591    3               END;

   4591  2 000272   000300 710000 2                  TRA     s:4596

      461     4592    3           ELSE DO;

      462     4593    3               XSL$SENDTORQS.NAMELEN = SIZEC( SOCK.PEERNAME);

   4593  2 000273   000024 220003                    LDX0    20,DU
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:39   
         2 000274   100001 740100                    STX0    1,,PR1

      463     4594    3               XSL$SENDTORQS.NAME = SOCK.PEERNAME;

   4594  2 000275   000100 100500                    MLR     fill='000'O
         2 000276   000011 000020                    ADSC9   9,,PR0                   cn=0,n=16
         2 000277   100001 400020                    ADSC9   1,,PR1                   cn=2,n=16

      464     4595    3               END;

      465     4596    2           CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SENDTORQS), XLEN, XMSG)

   4596  2 000300   200015 236100                    LDQ     XPTR$,,AUTO
         2 000301   200021 756100                    STQ     XPTR$+4,,AUTO
         2 000302   200014 630500                    EPPR0   XLEN,,AUTO
         2 000303   200020 450500                    STP0    XPTR$+3,,AUTO
         2 000304   000012 236000 3                  LDQ     10
         2 000305   200013 235100                    LDA     SOCK$,,AUTO
         2 000306   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000307   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000310   000022 631400 xsym               EPPR1   B_VECTNIL+18
         2 000311   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000312   000352 702000 2                  TSX2    ERRWRITE

      466     4597    2             ALTRET( ERRWRITE);
      467     4598    2           END;

   4598  2 000313   000342 710000 2                  TRA     s:4606

      468     4599    2       ELSE DO;

      469     4600    2           XSL$SENDRQS = XSL_SENDRQS;

   4600  2 000314   000000 236000 1                  LDQ     XSL_SENDRQS
         2 000315   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000316   100000 756100                    STQ     0,,PR1

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:40   
      470     4601    2           IF ENTRYFLAG = %SEND THEN

   4601  2 000317   200012 235100                    LDA     ENTRYFLAG,,AUTO
         2 000320   000001 115007                    CMPA    1,DL
         2 000321   000327 601000 2                  TNZ     s:4603

      471     4602    2               XSL$SENDRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);

   4602  2 000322   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000323   300000 236100                    LDQ     0,,PR3
         2 000324   000177 376007                    ANQ     127,DL
         2 000325   000000 620006                    EAX0    0,QL
         2 000326   100000 440100                    SXL0    0,,PR1

      472     4603    2           CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SENDRQS), XLEN, XMSG)

   4603  2 000327   200015 236100                    LDQ     XPTR$,,AUTO
         2 000330   200021 756100                    STQ     XPTR$+4,,AUTO
         2 000331   200014 633500                    EPPR3   XLEN,,AUTO
         2 000332   200020 453500                    STP3    XPTR$+3,,AUTO
         2 000333   000005 236000 3                  LDQ     5
         2 000334   200013 235100                    LDA     SOCK$,,AUTO
         2 000335   200016 757100                    STAQ    XPTR$+1,,AUTO
         2 000336   200016 630500                    EPPR0   XPTR$+1,,AUTO
         2 000337   000022 631400 xsym               EPPR1   B_VECTNIL+18
         2 000340   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000341   000352 702000 2                  TSX2    ERRWRITE

      473     4604    2             ALTRET( ERRWRITE);
      474     4605    2           END;

      475     4606    1       RESULT = RESULT + XLEN;

   4606  2 000342   200003 470500                    LDP0    @RESULT,,AUTO
         2 000343   000000 236100                    LDQ     0,,PR0
         2 000344   200014 036100                    ADLQ    XLEN,,AUTO
         2 000345   000000 756100                    STQ     0,,PR0
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:41   

      476     4607    1       SOCK.FLAGS.SELWRITE = '1'B;

   4607  2 000346   200013 471500                    LDP1    SOCK$,,AUTO
         2 000347   000020 236003                    LDQ     16,DU
         2 000350   100001 256100                    ORSQ    1,,PR1

      477     4608    1   SUCCESS:
      478     4609    1       RETURN;

   4609  2 000351   000000 702200 xent  SUCCESS      TSX2  ! X66_ARET

      479     4610    1   ERRWRITE:
      480     4611    2       IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$LD THEN DO;

   4611  2 000352   000000 470400 xsym  ERRWRITE     LDP0    B$TCB$
         2 000353   000000 471500                    LDP1    0,,PR0
         2 000354   100102 236100                    LDQ     66,,PR1
         2 000355   377770 376007                    ANQ     131064,DL
         2 000356   000070 116007                    CMPQ    56,DL
         2 000357   000402 601000 2                  TNZ     s:4617

      481     4612    2           XLEN = XLEN - SOCK.RCRBYTSIZ;

   4612  2 000360   200013 473500                    LDP3    SOCK$,,AUTO
         2 000361   300017 236100                    LDQ     15,,PR3
         2 000362   000022 772000                    QRL     18
         2 000363   200016 756100                    STQ     XPTR$+1,,AUTO
         2 000364   200014 236100                    LDQ     XLEN,,AUTO
         2 000365   200016 136100                    SBLQ    XPTR$+1,,AUTO
         2 000366   200014 756100                    STQ     XLEN,,AUTO

      482     4613    2           XPTR$ = PINCRC( XPTR$, SOCK.RCRBYTSIZ);

   4613  2 000367   300017 236100                    LDQ     15,,PR3
         2 000370   000022 772000                    QRL     18
         2 000371   000020 736000                    QLS     16
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:42   
         2 000372   200015 036100                    ADLQ    XPTR$,,AUTO
         2 000373   200015 756100                    STQ     XPTR$,,AUTO

      483     4614    2           RESULT = RESULT + SOCK.RCRBYTSIZ;

   4614  2 000374   200003 471500                    LDP1    @RESULT,,AUTO
         2 000375   300017 236100                    LDQ     15,,PR3
         2 000376   000022 772000                    QRL     18
         2 000377   100000 036100                    ADLQ    0,,PR1
         2 000400   100000 756100                    STQ     0,,PR1

      484     4615    2           GOTO WRITE_LOOP;

   4615  2 000401   000224 710000 2                  TRA     WRITE_LOOP

      485     4616    2           END;
      486     4617    2       IF B$TCB.ALT$->B$ALT.ERR.CODE = %E$NODAT THEN DO;

   4617  2 000402   021000 116007                    CMPQ    8704,DL
         2 000403   000452 601000 2                  TNZ     BAILOUTM1

      487     4618    3           IF NOT SOCK.FLAGS.BLOCKING THEN DO;

   4618  2 000404   200013 473500                    LDP3    SOCK$,,AUTO
         2 000405   300001 430100                    FSZN    1,,PR3
         2 000406   000415 604000 2                  TMI     s:4624

      488     4619    3               IF RESULT > 0 THEN

   4619  2 000407   200003 474500                    LDP4    @RESULT,,AUTO
         2 000410   400000 235100                    LDA     0,,PR4
         2 000411   000351 605400 2                  TPNZ    SUCCESS

      489     4620    3                   GOTO SUCCESS;
      490     4621    3               XSL_ERRNO = %E$WOULDBLOCK;

   4621  2 000412   000136 235007                    LDA     94,DL
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:43   
         2 000413   000000 755000 xsym               STA     XSL_ERRNO

      491     4622    3               GOTO BAILOUT;

   4622  2 000414   000454 710000 2                  TRA     BAILOUT

      492     4623    3               END;
      493     4624    2           IF SOCK.MAXRDS = 0 THEN

   4624  2 000415   300020 720100                    LXL0    16,,PR3
         2 000416   000423 601000 2                  TNZ     s:4627

      494     4625    2               CALL M$WAIT( XSL_WAIT1SEC);

   4625  2 000417   000000 630400 xsym               EPPR0   XSL_WAIT1SEC
         2 000420   020006 713400                    CLIMB   8198
         2 000421   400400 401760                    pmme    nvectors=2
         2 000422   000451 710000 2                  TRA     s:4634

      495     4626    3           ELSE DO INHIBIT;

      496     4627    3               XSL_UETIME = 0;

   4627  2 000423   000000 450200 xsym               STZ   ! XSL_UETIME

      497     4628    4               DO WHILE( XSL_UETIME = 0);

   4628  2 000424   000000 235200 xsym               LDA   ! XSL_UETIME
         2 000425   000451 601200 2                  TNZ   ! s:4634

      498     4629    4                   IF SOCK.FLAGS.SELWRITE THEN EXIT;

   4629  2 000426   200013 470700                    LDP0  ! SOCK$,,AUTO
         2 000427   000001 236300                    LDQ   ! 1,,PR0
         2 000430   000020 316203                    CANQ  ! 16,DU
         2 000431   000451 601200 2                  TNZ   ! s:4634

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:44   
      499     4630    4                   CALL XSL$EVLOG( 'WT', ADDR( SOCK));

   4630  2 000432   200013 236300                    LDQ   ! SOCK$,,AUTO
         2 000433   200016 756300                    STQ   ! XPTR$+1,,AUTO
         2 000434   200016 631700                    EPPR1 ! XPTR$+1,,AUTO
         2 000435   200021 451700                    STP1  ! XPTR$+4,,AUTO
         2 000436   000013 236200 3                  LDQ   ! 11
         2 000437   200020 756300                    STQ   ! XPTR$+3,,AUTO
         2 000440   200020 630700                    EPPR0 ! XPTR$+3,,AUTO
         2 000441   000020 631600 xsym               EPPR1 ! B_VECTNIL+16
         2 000442   000000 701200 xent               TSX1  ! XSL$EVLOG
         2 000443   000000 011200                    NOP   ! 0

      500     4631    4                   CALL M$WAIT( XSL_WAIT1DAY);

   4631  2 000444   000000 630600 xsym               EPPR0 ! XSL_WAIT1DAY
         2 000445   020006 713600                    CLIMB ! 8198
         2 000446   400400 401760                    pmme    nvectors=2

      501     4632    4                   END;

   4632  2 000447   000000 235200 xsym               LDA   ! XSL_UETIME
         2 000450   000426 600200 2                  TZE   ! s:4629

      502     4633    3               END;

      503     4634    2           GOTO WRITE_LOOP;

   4634  2 000451   000224 710000 2                  TRA     WRITE_LOOP

      504     4635    2           END;
      505     4636    1   BAILOUTM1:
      506     4637    1       XSL_ERRNO = %E$FAILURE;  /* make appl get errcode from TCB */

   4637  2 000452   000001 335007       BAILOUTM1    LCA     1,DL
         2 000453   000000 755000 xsym               STA     XSL_ERRNO

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:45   
      507     4638    1   BAILOUT:
      508     4639    1       RESULT = %E$FAILURE;

   4639  2 000454   000001 335007       BAILOUT      LCA     1,DL
         2 000455   200003 470500                    LDP0    @RESULT,,AUTO
         2 000456   000000 755100                    STA     0,,PR0

      509     4640    1       ALTRETURN;

   4640  2 000457   000000 702200 xent               TSX2  ! X66_AALT

XSL_SENDRQS
 Sect OctLoc
   1     000   000023 000000                                                    ....

XSL_SENDTORQS
 Sect OctLoc
   1     001   000025 000000   000000 000000   000000 000000   000000 000000    ................
   1     005   000000 000000   000000 ******                                    ........

(unnamed)
 Sect OctLoc
   1     007   127124 040040                                                    WT

(unnamed)
 Sect OctLoc
   3     000   000000 006000   000000 000000   000017 006000   000004 006000    ................
   3     004   000027 006000   000006 006000   000000 006003   777757 777777    ................
   3     010   000001 400000   000000 000026   000011 006000   000007 006000    ................
      510     4641
      511     4642    1   END XSL$SENDTO;
      512     4643        %EOD;

PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:46   
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B_ERRORS_C.:LIBRARY  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$SENDTO.
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:47   

 **** Variables and constants ****

  ****  Section 001 RoData XSL$SENDTO

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC        r     1 XSL_SENDRQS                1-0-0/w STRC(198)   r     1 XSL_SENDTORQS

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

    10-0-0/w PTR         r     1 @DST                      11-0-0/w PTR         r     1 @DSTLEN
     7-0-0/w PTR         r     1 @FLAGS                     6-0-0/w PTR         r     1 @LEN
     5-0-0/w PTR         r     1 @MSG                       3-0-0/w PTR         r     1 @RESULT
     4-0-0/w PTR         r     1 @SOCK#                    *0-0-0/w STRC(180)   r     1 DST
    *0-0-0/w SBIN        r     1 DSTLEN                    12-0-0/w SBIN        r     1 ENTRYFLAG
    *0-0-0/w UBIN        r     1 FLAGS                     *0-0-0/w SBIN        r     1 LEN
    *0-0-0/c ACHR        r     1 MSG                       *0-0-0/w SBIN        r     1 RESULT
    *0-0-0/w SBIN        r     1 SOCK#                     13-0-0/w PTR         r     1 SOCK$
    14-0-0/w SBIN        r     1 XLEN                      15-0-0/c PTR         r     1 XPTR$

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w PTR         r     1 B$TCB$                     0-0-0/w SBIN        r     1 XSL_ERRNO
     0-0-0/w PTR         r     1 XSL_KEYBUF$                0-0-0/w PTR         r     1 XSL_SOCK$
     0-0-0/w SBIN        r     1 XSL_UETIME                 0-0-0/d STRC(216)   r     1 XSL_WAIT1DAY
     0-0-0/d STRC(216)   r     1 XSL_WAIT1SEC

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:48   
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(2448)  r     1 B$ALT                      0-0-0/w STRC(144)   r     1 B$TCB
     0-0-0/d ASTR(3528)  r     1 F$DCB                      0-0-0/w STRC(720)   r     1 SOCK
     0-0-0/c ACHR        r     1 XMSG                       0-0-0/w STRC        r     1 XSL$SENDRQS
     0-0-0/w STRC(198)   r     1 XSL$SENDTORQS


   Procedure XSL$SENDTO requires 304 words for executable code.
   Procedure XSL$SENDTO requires 20 words of local(AUTO) storage.
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:49   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:50   
          MINI XREF LISTING

B$ALT.CODE
      1528**DCL      1528--REDEF    1529--REDEF    1529--REDEF
B$ALT.ERR.CODE
      1530**DCL      4611>>IF       4617>>IF
B$ALT.ERR.ERR#
      1530**DCL      1530--REDEF
B$ALT.EVID
      1529**DCL      1529--REDEF    1529--REDEF
B$TCB.ALT$
      1535**DCL      4611>>IF       4617>>IF
B$TCB$
      4479**DCL      1535--IMP-PTR  4611>>IF       4617>>IF
BAILOUT
      4639**LABEL    4519--CALLALT  4533--CALLALT  4540--GOTO     4545--CALLALT  4548--GOTO     4558--GOTO
      4564--GOTO     4568--GOTO     4622--GOTO
COMMONDCBN
      4533**LABEL    4503--GOTO     4513--GOTO     4525--GOTO
COMMONSOCK
      4519**LABEL    4508--GOTO     4530--GOTO
DST
      2658**DCL       317--PROC     4505--ENTRY    4545<>CALL     4588--IF       4590<>CALL
DSTLEN
      4486**DCL       317--PROC     4505--ENTRY    4545<>CALL     4589>>ASSIGN
ENTRYFLAG
      4487**DCL      4502<<ASSIGN   4507<<ASSIGN   4512<<ASSIGN   4517<<ASSIGN   4524<<ASSIGN   4529<<ASSIGN
      4544>>IF       4588>>IF       4601>>IF
ERRWRITE
      4611**LABEL    4596--CALLALT  4603--CALLALT
F$DCB.ACTPOS
      1598**DCL      1598--REDEF
F$DCB.ARS#
      1572**DCL      1572--REDEF
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:51   
F$DCB.ATTR
      1591**DCL      1592--REDEF
F$DCB.BORROW
      1606**DCL      1606--REDEF    1606--REDEF    1606--REDEF
F$DCB.DCBNAME.L
      1620**DCL      1620--IMP-SIZ
F$DCB.EOMCHAR#
      1576**DCL      1576--REDEF
F$DCB.FCN.CNT
      1611**DCL      4572>>DOWHILE
F$DCB.FLDID
      1601**DCL      1601--REDEF
F$DCB.FORM$
      1595**DCL      1595--REDEF
F$DCB.FSECT
      1611**DCL      1611--REDEF
F$DCB.FSN#
      1588**DCL      1588--REDEF    1588--REDEF    1589--REDEF
F$DCB.HEADER$
      1594**DCL      1594--REDEF
F$DCB.IXTNSIZE#
      1592**DCL      1592--REDEF
F$DCB.LASTSTA$
      1581**DCL      1581--REDEF
F$DCB.LVL
      1607**DCL      1607--REDEF
F$DCB.NAME#.C
      1582**DCL      1582--REDEF
F$DCB.NOEOF
      1604**DCL      1604--REDEF
F$DCB.NRECS#
      1593**DCL      1593--REDEF
F$DCB.NRECX
      1612**DCL      1612--REDEF
F$DCB.OHDR
      1604**DCL      1604--REDEF
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:52   
F$DCB.ORG#
      1587**DCL      1587--REDEF
F$DCB.PRECNO
      1610**DCL      1610--REDEF
F$DCB.RCSZ
      1616**DCL      1616--REDEF
F$DCB.RES#
      1583**DCL      1583--REDEF
F$DCB.SETX
      1595**DCL      1595--REDEF
F$DCB.TAB$
      1595**DCL      1595--REDEF
F$DCB.TDA
      1609**DCL      1610--REDEF
F$DCB.WSN#
      1583**DCL      1583--REDEF
FLAGS
      4491**DCL       317--PROC     4505--ENTRY    4510--ENTRY    4515--ENTRY    4585>>ASSIGN   4602>>ASSIGN
LATER
      4535**LABEL    4520--GOTO
LEN
      4492**DCL       317--PROC     4493--IMP-SIZ  4505--ENTRY    4510--ENTRY    4515--ENTRY    4522--ENTRY
      4527--ENTRY    4556>>IF       4578>>ASSIGN
M$WAIT
      1512**DCL-ENT  4625--CALL     4631--CALL
MSG
      4493**DCL       317--PROC     4505--ENTRY    4510--ENTRY    4515--ENTRY    4522--ENTRY    4527--ENTRY
      4579--ASSIGN
RESULT
      4494**DCL       317--PROC     4505--ENTRY    4510--ENTRY    4515--ENTRY    4522--ENTRY    4527--ENTRY
      4551<<ASSIGN   4552<>CALL     4552<>CALL     4580<<ASSIGN   4606<<ASSIGN   4606>>ASSIGN   4614<<ASSIGN
      4614>>ASSIGN   4619>>IF       4639<<ASSIGN
SOCK
      3005**DCL      4545<>CALL     4574<>CALL     4596<>CALL     4603<>CALL     4630--CALL
SOCK.BUFPND#
      3122**DCL      4572>>DOWHILE
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:53   
SOCK.DCB#
      3038**DCL      4572--DOWHILE
SOCK.FLAGS.BLOCKING
      3024**DCL      4618>>IF
SOCK.FLAGS.CONNECT
      3019**DCL      4566>>IF
SOCK.FLAGS.REUSEADDR
      3025**DCL      4550>>IF
SOCK.FLAGS.SELWRITE
      3029**DCL      4582<<ASSIGN   4607<<ASSIGN   4629>>IF
SOCK.FLAGS.SENDSHUT
      3017**DCL      4538>>IF
SOCK.FLAGS.SOCKET
      3023**DCL      4543>>IF       4562>>IF
SOCK.MAXBUF
      3123**DCL      4572>>DOWHILE
SOCK.MAXRDS
      3124**DCL      4572>>DOWHILE  4624>>IF
SOCK.NBACCEPT_SOCK$
      3127**DCL      3128--REDEF
SOCK.PEERNAME
      3098**DCL      4593--ASSIGN   4594>>ASSIGN
SOCK.RCRBYTSIZ
      3121**DCL      4536>>IF       4537<<ASSIGN   4586>>IF       4612>>ASSIGN   4613>>ASSIGN   4614>>ASSIGN
SOCK.SOCK#
      3014**DCL      4551>>ASSIGN
SOCK.TYPE
      3012**DCL      4542>>IF       4566>>IF       4583>>IF
SOCK#
      4495**DCL       317--PROC     4505--ENTRY    4510--ENTRY    4515--ENTRY    4519<>CALL     4522--ENTRY
      4527--ENTRY    4533<>CALL
SOCK$
      4496**DCL      3005--IMP-PTR  4535<<ASSIGN   4536>>IF       4537>>ASSIGN   4538>>IF       4542>>IF
      4543>>IF       4545>>CALL     4550>>IF       4551>>ASSIGN   4562>>IF       4566>>IF       4566>>IF
      4572>>DOWHILE  4572>>DOWHILE  4572>>DOWHILE  4572>>DOWHILE  4574>>CALL     4582>>ASSIGN   4583>>IF
      4586>>IF       4594>>ASSIGN   4596>>CALL     4603>>CALL     4607>>ASSIGN   4612>>ASSIGN   4613>>ASSIGN
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:54   
      4614>>ASSIGN   4618>>IF       4624>>IF       4629>>IF       4630>>CALL
SUCCESS
      4609**LABEL    4620--GOTO
WRITE_LOOP
      4582**LABEL    4615--GOTO     4634--GOTO
WRITE_READY
      4578**LABEL    4574--CALLALT
XLEN
      4497**DCL      4498--IMP-SIZ  4578<<ASSIGN   4586>>IF       4596<>CALL     4596>>CALL     4603<>CALL
      4603>>CALL     4606>>ASSIGN   4612<<ASSIGN   4612>>ASSIGN
XMSG
      4498**DCL      4596<>CALL     4603<>CALL
XPTR$
      4499**DCL      4498--IMP-PTR  4579<<ASSIGN   4596>>CALL     4603>>CALL     4613<<ASSIGN   4613>>ASSIGN
XSL$CL_WRITE
      4470**DCL-ENT  4596--CALL     4603--CALL
XSL$DCBNPTR
      4473**DCL-ENT  4533--CALL
XSL$EVLOG
      4476**DCL-ENT  4630--CALL
XSL$GETBUF
      4477**DCL-ENT  4574--CALL
XSL$HTONADDR
      4471**DCL-ENT  4590--CALL
XSL$QSETSOCKOPT
      4474**DCL-ENT  4552--CALL
XSL$SENDRQS
      4353**DCL      4600<<ASSIGN   4603--CALL
XSL$SENDRQS.FLAGS
      4360**DCL      4602<<ASSIGN
XSL$SENDTORQS
      4432**DCL      4584<<ASSIGN   4596--CALL
XSL$SENDTORQS.FLAGS
      4439**DCL      4585<<ASSIGN   4587<<ASSIGN   4587>>ASSIGN
XSL$SENDTORQS.NAME
      4460**DCL      4590<>CALL     4594<<ASSIGN
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:55   
XSL$SENDTORQS.NAMELEN
      4440**DCL      4589<<ASSIGN   4593<<ASSIGN
XSL$SOCKOPEN
      4475**DCL-ENT  4545--CALL
XSL$SOCKPTR
      4472**DCL-ENT  4519--CALL
XSL_ERRNO
      4480**DCL      4481--REDEF    4539<<ASSIGN   4547<<ASSIGN   4557<<ASSIGN   4563<<ASSIGN   4567<<ASSIGN
      4621<<ASSIGN   4637<<ASSIGN
XSL_KEYBUF$
      4482**DCL      4353--IMP-PTR  4432--IMP-PTR  4584>>ASSIGN   4585>>ASSIGN   4587>>ASSIGN   4587>>ASSIGN
      4589>>ASSIGN   4590>>CALL     4593>>ASSIGN   4594>>ASSIGN   4600>>ASSIGN   4602>>ASSIGN
XSL_SENDRQS
      4327**DCL      4600>>ASSIGN
XSL_SENDTORQS
      4379**DCL      4584>>ASSIGN
XSL_SOCK$
      4481**DCL      4519<>CALL     4533<>CALL     4535>>ASSIGN
XSL_UETIME
      4484**DCL      4627<<ASSIGN   4628>>DOWHILE
XSL_WAIT1DAY
      1548**DCL      4631<>CALL
XSL_WAIT1SEC
      1562**DCL      4625<>CALL
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:56   
              *** CROSS REFERENCE LISTING ***
    **     DENOTES     IDENTIFIER DEFINITION
    <<                 IDENTIFIER'S VALUE SET
    >>                 IDENTIFIER'S VALUE USED
    <>                 IDENTIFIER SET AND/OR USED
    --                 IDENTIFIER REFERENCED
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:57   
              MINI UREF LISTING

BAILOUTM1    4637**LABEL
M$ACCT    1471**DCL-ENT
M$ACTIVATE    1474**DCL-ENT
M$ALIB    1467**DCL-ENT
M$ASUSER    1469**DCL-ENT
M$ATTACH    1476**DCL-ENT
M$BADPP    1494**DCL-ENT
M$CGCTL    1475**DCL-ENT
M$CGINFO    1475**DCL-ENT
M$CHECK    1456**DCL-ENT
M$CHGUNIT    1514**DCL-ENT
M$CLOSE    1454**DCL-ENT
M$CLRSTK    1512**DCL-ENT
M$CMDVAR    1523**DCL-ENT
M$CONFIG    1484**DCL-ENT
M$CORRES    1459**DCL-ENT
M$CPEXIT    1468**DCL-ENT
M$CVM    1492**DCL-ENT
M$CVOL    1457**DCL-ENT
M$DCLFLD    1484**DCL-ENT
M$DEACTIVATE    1474**DCL-ENT
M$DELREC    1456**DCL-ENT
M$DEQ    1521**DCL-ENT
M$DETACH    1476**DCL-ENT
M$DEVICE    1458**DCL-ENT
M$DISPLAY    1521**DCL-ENT
M$DISPRES    1461**DCL-ENT
M$DLIB    1467**DCL-ENT
M$DRIBBLE    1484**DCL-ENT
M$DRTN    1512**DCL-ENT
M$DSUSER    1469**DCL-ENT
M$ENQ    1520**DCL-ENT
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:58   
M$EOM    1479**DCL-ENT
M$ERASE    1485**DCL-ENT
M$ERR    1466**DCL-ENT
M$ERRMSG    1517**DCL-ENT
M$EVENT    1509**DCL-ENT
M$EXHUME    1518**DCL-ENT
M$EXIT    1466**DCL-ENT
M$EXTEND    1458**DCL-ENT
M$FDP    1490**DCL-ENT
M$FDS    1489**DCL-ENT
M$FEBOOT    1482**DCL-ENT
M$FECTL    1483**DCL-ENT
M$FEDUMP    1482**DCL-ENT
M$FID    1517**DCL-ENT
M$FINDPROC    1471**DCL-ENT
M$FSUSER    1469**DCL-ENT
M$FVP    1491**DCL-ENT
M$FWCG    1475**DCL-ENT
M$GBPL    1495**DCL-ENT
M$GDDL    1491**DCL-ENT
M$GDP    1490**DCL-ENT
M$GDS    1489**DCL-ENT
M$GETDCB    1460**DCL-ENT
M$GETMOUSE    1500**DCL-ENT
M$GETPM    1501**DCL-ENT
M$GJOB    1519**DCL-ENT
M$GLINEATTR    1479**DCL-ENT
M$GOODPP    1494**DCL-ENT
M$GPLATEN    1487**DCL-ENT
M$GPROMPT    1486**DCL-ENT
M$GTRMATTR    1480**DCL-ENT
M$GTRMCTL    1478**DCL-ENT
M$GTRMTAB    1481**DCL-ENT
M$GVP    1490**DCL-ENT
M$HELP    1517**DCL-ENT
M$INT    1509**DCL-ENT
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:59   
M$INTRTN    1470**DCL-ENT
M$IOQ    1505**DCL-ENT
M$JOBSTATS    1519**DCL-ENT
M$KEYIN    1459**DCL-ENT
M$LDEV    1454**DCL-ENT
M$LDTRC    1467**DCL-ENT
M$LIMIT    1460**DCL-ENT
M$LINES    1459**DCL-ENT
M$LINK    1466**DCL-ENT
M$MADMUCK    1462**DCL-ENT
M$MAKUSER    1493**DCL-ENT
M$MBS    1461**DCL-ENT
M$MDFFLD    1485**DCL-ENT
M$MERC    1510**DCL-ENT
M$MERCS    1511**DCL-ENT
M$MIRROR    1505**DCL-ENT
M$MONINFO    1522**DCL-ENT
M$MPL    1495**DCL-ENT
M$NODEINFO    1486**DCL-ENT
M$NXTUSR    1520**DCL-ENT
M$OCMSG    1518**DCL-ENT
M$OLAY    1466**DCL-ENT
M$OPEN    1454**DCL-ENT
M$PAS    1495**DCL-ENT
M$PATHCON    1518**DCL-ENT
M$PDS    1489**DCL-ENT
M$PFIL    1456**DCL-ENT
M$PLATEN    1480**DCL-ENT
M$PRECORD    1458**DCL-ENT
M$PROCNAME    1471**DCL-ENT
M$PROFILE    1482**DCL-ENT
M$PROMPT    1478**DCL-ENT
M$RACST    1462**DCL-ENT
M$RDSYSLOG    1503**DCL-ENT
M$READ    1455**DCL-ENT
M$RELDCB    1460**DCL-ENT
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:60   
M$RELRES    1461**DCL-ENT
M$RELSTARF    1463**DCL-ENT
M$REM    1463**DCL-ENT
M$RENV    1510**DCL-ENT
M$REQUIRE    1462**DCL-ENT
M$RETRY    1511**DCL-ENT
M$RETRYS    1511**DCL-ENT
M$REW    1457**DCL-ENT
M$RLSFLD    1485**DCL-ENT
M$RPRIV    1513**DCL-ENT
M$RSPP    1492**DCL-ENT
M$RSWITCH    1514**DCL-ENT
M$RUE    1520**DCL-ENT
M$SAD    1493**DCL-ENT
M$SAVE    1469**DCL-ENT
M$SCON    1470**DCL-ENT
M$SCREECH    1468**DCL-ENT
M$SENV    1510**DCL-ENT
M$SETFMA    1454**DCL-ENT
M$SETFP    1483**DCL-ENT
M$SINPUT    1481**DCL-ENT
M$SLCFLD    1486**DCL-ENT
M$SMOUSE    1500**DCL-ENT
M$SMPRT    1492**DCL-ENT
M$SPRIV    1513**DCL-ENT
M$SSC    1493**DCL-ENT
M$SSWITCH    1513**DCL-ENT
M$STATE    1522**DCL-ENT
M$STD    1494**DCL-ENT
M$STIMER    1508**DCL-ENT
M$STLPP    1491**DCL-ENT
M$STRAP    1508**DCL-ENT
M$STRMATTR    1480**DCL-ENT
M$STRMCTL    1478**DCL-ENT
M$STRMTAB    1481**DCL-ENT
M$SYMBIO    1519**DCL-ENT
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:61   
M$SYSCON    1505**DCL-ENT
M$SYSID    1523**DCL-ENT
M$TDCLOSE    1504**DCL-ENT
M$TDIO    1504**DCL-ENT
M$TDOPEN    1503**DCL-ENT
M$TDREQCPU    1504**DCL-ENT
M$TEMPWROC    1498**DCL-ENT
M$TIME    1521**DCL-ENT
M$TRAP    1508**DCL-ENT
M$TRMISC    1483**DCL-ENT
M$TRMPRG    1479**DCL-ENT
M$TRTN    1512**DCL-ENT
M$TRUNC    1455**DCL-ENT
M$TTIMER    1508**DCL-ENT
M$UC    1478**DCL
M$UMPL    1495**DCL-ENT
M$UNFID    1517**DCL-ENT
M$UNLATCH    1474**DCL-ENT
M$UNSHARE    1471**DCL-ENT
M$USRFIELD    1514**DCL-ENT
M$VIRTUAL    1489**DCL-ENT
M$WEOF    1457**DCL-ENT
M$WRITE    1455**DCL-ENT
M$WRSYSLOG    1503**DCL-ENT
M$XCON    1509**DCL-ENT
M$XCONRTN    1470**DCL-ENT
M$XEQTIME    1522**DCL-ENT
M$XFLUSH    1463**DCL-ENT
M$XMOUSE    1500**DCL-ENT
M$XXX    1466**DCL-ENT
M$YC    1468**DCL-ENT
XSL$CL_READ    4469**DCL-ENT
XSL$QSEND    4515**ENTRY
XSL$QSENDTO    4505**ENTRY
XSL$QWRITE    4527**ENTRY
XSL$SEND    4510**ENTRY
PL6.E3A0      #001=XSL$SENDTO File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:30 Page:62   
XSL$SENDTO     317**PROC
XSL$WRITE    4522**ENTRY
XSL_SOCK$$    4483**DCL

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:63   
      513        1        /*T***********************************************************/
      514        2        /*T*                                                         */
      515        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      516        4        /*T*                                                         */
      517        5        /*T***********************************************************/
      518        6        /*F* NAME: recvfrom() and XSL$RECVFROM  --  Read Data With Options and Address
      519        7        ..::IT "Purpose:"
      520        8        .INL +4
      521        9        Receives a message from a socket into an application-specified buffer,
      522       10        along with the address of the message's sender.
      523       11        ..::IT "C Usage:"
      524       12        .INL 4
      525       13        .FIF
      526       14        status = recvfrom( s, buf, len, flags, from, fromlen );
      527       15        ..::IT "PL6 Usage:"
      528       16        .INL 4
      529       17        .FIF
      530       18        CALL XSL$RECVFROM( status, s, buf, len, flags, from, fromlen );
      531       19        ..::IT "Parameters:"
      532       20        .INL 4
      533       21        .FIF
      534       22        s           integer socket descriptor
      535       23
      536       24        buf         character array buffer
      537       25
      538       26        len         integer size of buf in characters
      539       27
      540       28        flags       integer bitflags of recvfrom options
      541       29
      542       30        from        sockaddr structure
      543       31
      544       32        fromlen     integer size of from in characters
      545       33        ..::IT "Results:"
      546       34        .INL 4
      547       35        .FIF
      548       36        status      integer number of characters received or error code
      549       37
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:64   
      550       38        buf         character array buffer
      551       39
      552       40        from        sockaddr structure with address of message's sender
      553       41
      554       42        fromlen     integer number of significant characters in from
      555       43        ..::IT "Description:"
      556       44        The recvfrom() function receives a message from a connected socket and places
      557       45        it in the buffer specified.  Additionally, the network address of the
      558       46        message's sender is provided.
      559       47        .SPB
      560       48        The s parameter specifies the descriptor of the socket on which to receive.
      561       49        .SPB
      562       50        The buf parameter specifies an application-defined buffer to hold the
      563       51        message received from the socket.
      564       52        .SPB
      565       53        The len parameter specifies how large the buffer is, expressed as the
      566       54        number of characters it can hold.
      567       55        .SPB
      568       56        The flags parameter specifies recvfrom options.  The desired options are
      569       57        'ORed' together when coding the invocation.  The only options currently
      570       58        implemented are "out-of-band" and "peek".  The out-of-band option receives
      571       59        any message that was sent on the out-of-band data path if the socket supports
      572       60        it.  It is selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source,
      573       61        respectively.  The peek option copies a message into the buffer, but
      574       62        additionally leaves it in the recvfrom() queue so subsequent recvfrom() invocations
                62        see
      575       63        the same message. It is selected by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 sou
                63        rce,
      576       64        respectively.
      577       65        .SPB
      578       66        The from parameter specifies an address buffer into which is placed the
      579       67        network address of the message's sender.
      580       68        .SPB
      581       69        The fromlen parameter specifies how large from is, expressed as the number
      582       70        of characters it can hold.
      583       71        .SPB
      584       72        If the recvfrom() function is successful, the status result contains the
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:65   
      585       73        number of characters received.  This number is non-negative.
      586       74        On datagram sockets, if the buffer is not large enough to receive the
      587       75        entire message, the excess will be discarded.  The network address of
      588       76        the message's sender is placed into from, and fromlen is set to the number
      589       77        of significant characters in from.
      590       78        .SPB
      591       79        If the recvfrom() function is unsuccessful, the status result contains
      592       80        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      593       81        to determine the specific error condition.  The XSL$RECVFROM procedure
      594       82        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      595       83        to the recvfrom() function.
      596       84        .SPB
      597       85        If no data is available from a socket when recvfrom() is invoked, the action
      598       86        taken depends on the socket mode.  The mode of a socket is defined
      599       87        to be either "blocking" or "nonblocking".  If the socket is blocking
      600       88        (which is the default mode) the application is blocked (i.e., suspended)
      601       89        until a message is received from the network.  If the socket is nonblocking,
      602       90        the condition is treated as an EWOULDBLOCK error.
      603       91        .SPB
      604       92        The mode of a socket can be changed with either fcntl() or ioctl().
      605       93        .SPB
      606       94        Recvfrom() may be used on sockets regardless of whether connect() has been
      607       95        issued.
      608       96        .SPB
      609       97        If shutdown() has been invoked for this socket to inhibit reception of
      610       98        data, or if the peer is no longer connected, all recvfrom() operations
      611       99        are treated as if zero bytes of data were read.
      612      100        ..::IT "Errors:"
      613      101        Following are the possible error conditions reported when the recvfrom()
      614      102        function is unsuccessful.  Equates for the possible values can be found in
      615      103        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      616      104
      617      105        .FIF
      618      106
      619      107        C #define               PL6 %EQU
      620      108        ----------------------- -----------------------
      621      109        EBADF                   E$BADF
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:66   
      622      110        .FIN
      623      111        The descriptor s is not appropriate to identify a socket.
      624      112        .FIF
      625      113
      626      114        ENOTSOCK                E$NOTSOCK
      627      115        .FIN
      628      116        The descriptor s is no longer valid to identify a socket.
      629      117        .FIF
      630      118
      631      119        EWOULDBLOCK             E$WOULDBLOCK
      632      120        .FIN
      633      121        There is no data available from this nonblocking socket.
      634      122        .FIF
      635      123        */
      636      124        /*F* NAME: recv() and XSL$RECV  --  Read Data With Options
      637      125        ..::IT "Purpose:"
      638      126        .INL +4
      639      127        Receives a message from a connected socket into an
      640      128        application-specified buffer.
      641      129        ..::IT "C Usage:"
      642      130        .INL 4
      643      131        .FIF
      644      132        status = recv( s, buf, len, flags );
      645      133        ..::IT "PL6 Usage:"
      646      134        .INL 4
      647      135        .FIF
      648      136        CALL XSL$RECV( status, s, buf, len, flags );
      649      137        ..::IT "Parameters:"
      650      138        .INL 4
      651      139        .FIF
      652      140        s           integer socket descriptor
      653      141
      654      142        buf         character array buffer
      655      143
      656      144        len         integer size of buf in characters
      657      145
      658      146        flags       integer bitflags of recv options
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:67   
      659      147        ..::IT "Results:"
      660      148        .INL 4
      661      149        .FIF
      662      150        status      integer number of characters received or error code
      663      151
      664      152        buf         character array buffer
      665      153        ..::IT "Description:"
      666      154        The recv() function receives a message from a connected socket and places
      667      155        it in the buffer specified.
      668      156        .SPB
      669      157        The s parameter specifies the descriptor of the socket on which to receive.
      670      158        .SPB
      671      159        The buf parameter specifies an application-defined buffer to hold the
      672      160        message received from the socket.
      673      161        .SPB
      674      162        The len parameter specifies how large the buffer is, expressed as the
      675      163        number of characters it can hold.
      676      164        .SPB
      677      165        The flags parameter specifies recv options.  The desired options are 'OR-ed'
      678      166        together when coding the invocation.  The only options currently implemented
      679      167        are "out-of-band" and "peek".  The out-of-band option receives any message
      680      168        that was sent on the out-of-band data path if the socket supports it.  It is
      681      169        selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source, respectively.
      682      170        The peek option copies a message into the buffer, but additionally leaves
      683      171        it in the recv() queue so subsequent recv() invocations see the same message. It is
               171        selected
      684      172        by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 source, respectively.
      685      173        .SPB
      686      174        If the recv() function is successful, the status result contains the number
      687      175        of characters received.  This number is non-negative.  On
      688      176        datagram sockets, if the buffer is not large enough to receive the
      689      177        entire message, the excess will be discarded.
      690      178        .SPB
      691      179        If the recv() function is unsuccessful, the status result contains
      692      180        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      693      181        to determine the specific error condition.  The XSL$RECV procedure
      694      182        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:68   
      695      183        to the recv() function.
      696      184        .SPB
      697      185        If no data is available from a socket when recv() is invoked, the action
      698      186        taken depends on the socket mode.  The mode of a socket is defined
      699      187        to be either "blocking" or "nonblocking".  If the socket is blocking
      700      188        (which is the default mode) the application is blocked (i.e., suspended)
      701      189        until a message is received from the network.  If the socket is nonblocking,
      702      190        the condition is treated as an EWOULDBLOCK error.
      703      191        .SPB
      704      192        The mode of a socket can be changed with either fcntl() or ioctl().
      705      193        .SPB
      706      194        Recv() may be used only on sockets that have had connect() invoked.
      707      195        .SPB
      708      196        If shutdown() has been invoked for this socket to inhibit reception of
      709      197        data, or if the peer is no longer connected, all recv() operations are
      710      198        treated as if zero bytes of data were read.
      711      199        ..::IT "Errors:"
      712      200        Following are the possible error conditions reported when the recv()
      713      201        function is unsuccessful.  Equates for the possible values can be found in
      714      202        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      715      203
      716      204        .FIF
      717      205
      718      206        C #define               PL6 %EQU
      719      207        ----------------------- -----------------------
      720      208        EBADF                   E$BADF
      721      209        .FIN
      722      210        The descriptor s is not appropriate to identify a socket.
      723      211        .FIF
      724      212
      725      213        ENOTCONN                E$NOTCONN
      726      214        .FIN
      727      215        The connect() function has not been invoked for this socket.
      728      216        .FIN
      729      217
      730      218        ENOTSOCK                E$NOTSOCK
      731      219        .FIN
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:69   
      732      220        The descriptor s is no longer valid to identify a socket.
      733      221        .FIF
      734      222
      735      223        EWOULDBLOCK             E$WOULDBLOCK
      736      224        .FIN
      737      225        There is no data available from this nonblocking socket.
      738      226        .FIF
      739      227        */
      740      228        /*F* NAME: read() and XSL$READ  --  Read Data
      741      229        ..::IT "Purpose:"
      742      230        .INL +4
      743      231        Reads data from a socket into an application-specified buffer.
      744      232        ..::IT "C Usage:"
      745      233        .INL 4
      746      234        .FIF
      747      235        status = read( s, buf, len );
      748      236        ..::IT "PL6 Usage:"
      749      237        .INL 4
      750      238        .FIF
      751      239        CALL XSL$READ( status, s, buf, len );
      752      240        ..::IT "Parameters:"
      753      241        .INL 4
      754      242        .FIF
      755      243        s           integer socket descriptor
      756      244
      757      245        buf         character array buffer
      758      246
      759      247        len         integer size of buf in characters
      760      248        ..::IT "Results:"
      761      249        .INL 4
      762      250        .FIF
      763      251        status      integer number of characters read or error code
      764      252
      765      253        buf         character array buffer
      766      254        ..::IT "Description:"
      767      255        The read() function reads any available data from the socket into the
      768      256        buffer specified.
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:70   
      769      257        .SPB
      770      258        The s parameter specifies the descriptor of the socket to be read from.
      771      259        .SPB
      772      260        The buf parameter specifies an application-defined buffer to receive the
      773      261        data to be read from the socket.
      774      262        .SPB
      775      263        The len parameter specifies how large the buffer is, expressed as the
      776      264        number of characters it can hold.
      777      265        .SPB
      778      266        If the read() function is successful, the status result contains the
      779      267        number of characters read into buf.  This number is non-negative.
      780      268        A successful read() returns all data available, up to the size of buf.
      781      269        On datagram sockets, if the buffer is not large enough to receive the
      782      270        entire datagram, the excess will be discarded.
      783      271        .SPB
      784      272        If the read() function is unsuccessful, the status result contains
      785      273        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      786      274        to determine the specific error condition.  The XSL$READ procedure
      787      275        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      788      276        to the read() function.
      789      277        .SPB
      790      278        If no data is available from a socket when read() is invoked, the action
      791      279        taken depends on the socket mode.  The mode of a socket is defined
      792      280        to be either "blocking" or "nonblocking".  If the socket is blocking
      793      281        (which is the default mode) the application is blocked (i.e., suspended)
      794      282        until data is received from the network.  If the socket is nonblocking,
      795      283        the condition is treated as an EWOULDBLOCK error.
      796      284        .SPB
      797      285        The mode of a socket can be changed with either fcntl() or ioctl().
      798      286        .SPB
      799      287        If shutdown() has been invoked for this socket to inhibit reception of
      800      288        data, or if the peer is no longer connected, all read() operations are
      801      289        treated as if zero bytes of data were read.
      802      290        ..::IT "Errors:"
      803      291        Following are the possible error conditions reported when the read()
      804      292        function is unsuccessful.  Equates for the possible values can be
      805      293        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:71   
      806      294
      807      295        .FIF
      808      296
      809      297        C #define               PL6 %EQU
      810      298        ----------------------- -----------------------
      811      299        EBADF                   E$BADF
      812      300        .FIN
      813      301        The descriptor s is not appropriate to identify a socket.
      814      302        .FIF
      815      303
      816      304        ENOTCONN                E$NOTCONN
      817      305        .FIN
      818      306        The socket is not currently connected.  connect() has not been invoked.
      819      307        .FIF
      820      308
      821      309        ENOTSOCK                E$NOTSOCK
      822      310        .FIN
      823      311        The descriptor s is no longer valid to identify a socket.
      824      312        .FIF
      825      313
      826      314        EWOULDBLOCK             E$WOULDBLOCK
      827      315        .FIN
      828      316        There is no data available from this nonblocking socket.
      829      317        .FIF
      830      318        */
      831      319        XSL$RECVFROM: PROC( RESULT, SOCK#, BUF, LEN, FLAGS, FROM, FROMLEN) ALTRET;
      832      320        %INCLUDE CP_6;
      833      401            %F$DCB;
      834      458            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
      835      472        %INCLUDE XSL_SOCKET_E;
      836      730        %INCLUDE XSL_SOCKET_M;
      837     1491            %XSL$SOCKADDR( FPTN=FROM, STCLASS=);
      838     1531        %INCLUDE XSL_PERR_C;
      839     1586        %INCLUDE XSL_INTERNAL_M;
      840     1837            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
      841     1981            %XSL$SOCKHD( STCLASS="BASED( XSL_SOCK$$)");
      842     2014            %XSL$DATABUF( FPTN=DATABUF, STCLASS="BASED( BUF$)");
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:72   
      843     2047        %INCLUDE XSL_SOCKMSGS_E;
      844     2093        %INCLUDE XSL_SOCKMSGS_M;
      845     3226            %XSL_REFMSGS;
      846     3229            %XSL$RECVRQS( FPTN=XSL_RECVRQS, STCLASS=SYMREF);
      847     3256            %XSL$RECVRQS( STCLASS="BASED( XSL_KEYBUF$)");
      848     3283            %XSL$RECVRSP( STCLASS="BASED( XSL_KEYBUF$)");
      849     3310            %XSL$RECVFROMRQS( FPTN=XSL_RECVFROMRQS, STCLASS=SYMREF);
      850     3338            %XSL$RECVFROMRQS( STCLASS="BASED( XSL_KEYBUF$)");
      851     3366            %XSL$RECVFROMRSP( STCLASS="BASED( XSL_KEYBUF$)");
      852     3420
      853     3421    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
      854     3422    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
      855     3423    1       DCL XSL$CL_CANCEL ENTRY(1) ALTRET;
      856     3424    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
      857     3425    1       DCL XSL$RELBUF ENTRY(2) ALTRET;
      858     3426    1       DCL XSL$NTOHADDR ENTRY(2);
      859     3427    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
      860     3428    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
      861     3429    1       DCL XSL$EVLOG ENTRY(2);
      862     3430
      863     3431    1       DCL XSL_ERRNO SBIN SYMREF;
      864     3432    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
      865     3433    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
      866     3434    1       DCL XSL_SOCK$$ PTR SYMREF;
      867     3435    1       DCL XSL_UETIME SBIN SYMREF;
      868     3436
      869     3437    1       DCL B$CHARS CHAR( NUM) BASED CALIGNED;
      870     3438    1       DCL LEFT SBIN;
      871     3439    1       DCL NUM SBIN;
      872     3440    1       DCL BUF$ PTR;
      873     3441    1       DCL TMP$ PTR;
      874     3442    1       DCL SCANNED SBIN;
      875     3443    1       DCL BUFPND# SBIN;
      876     3444    1       DCL BUF CHAR( LEN) CALIGNED;
      877     3445    1       DCL ENTRYFLAG SBIN;
      878     3446        %EQU RECVFROM = 0;
      879     3447        %EQU RECV = 1;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:73   
      880     3448        %EQU READ = 2;
      881     3449    1       DCL FLAGS UBIN;
      882     3450    1       DCL 1 BFLAGS REDEF FLAGS,
      883     3451    1           2 * BIT(34) UNAL,
      884     3452    1           2 PEEK BIT(1) UNAL,
      885     3453    1           2 OOB BIT(1) UNAL;
      886     3454    1       DCL FROMLEN SBIN;
      887     3455    1       DCL LEN SBIN;
      888     3456    1       DCL MORE BIT(1) UNAL;
      889     3457    1       DCL RESULT SBIN;
      890     3458    1       DCL SOCK# SBIN;
      891     3459    1       DCL SOCK$ PTR;
      892     3460
      893     3461    1       ENTRYFLAG = %RECVFROM;
      894     3462    1       GOTO COMMONDCBN;
      895     3463
      896     3464    1   XSL$QRECVFROM: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS, FROM, FROMLEN) ALTRET;
      897     3465
      898     3466    1       ENTRYFLAG = %RECVFROM;
      899     3467    1       GOTO COMMONSOCK;
      900     3468
      901     3469    1   XSL$RECV: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS) ALTRET;
      902     3470
      903     3471    1       ENTRYFLAG = %RECV;
      904     3472    1       GOTO COMMONDCBN;
      905     3473
      906     3474    1   XSL$QRECV: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS) ALTRET;
      907     3475
      908     3476    1       ENTRYFLAG = %RECV;
      909     3477    1   COMMONSOCK:
      910     3478    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
      911     3479    1       GOTO LATER;
      912     3480
      913     3481    1   XSL$READ: ENTRY( RESULT, SOCK#, BUF, LEN) ALTRET;
      914     3482
      915     3483    1       ENTRYFLAG = %READ;
      916     3484    1       GOTO COMMONDCBN;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:74   
      917     3485
      918     3486    1   XSL$QREAD: ENTRY( RESULT, SOCK#, BUF, LEN) ALTRET;
      919     3487
      920     3488    1       ENTRYFLAG = %READ;
      921     3489    1       GOTO COMMONSOCK;
      922     3490
      923     3491    1   COMMONDCBN:
      924     3492    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
      925     3493    1   LATER:
      926     3494    1       SOCK$ = XSL_SOCK$;
      927     3495    2       IF NOT SOCK.FLAGS.SOCKET THEN DO;
      928     3496    2           XSL_ERRNO = %E$NOTBOUND;
      929     3497    2           GOTO BAILOUT;
      930     3498    2           END;
      931     3499    2       IF SOCK.FLAGS.RECVSHUT THEN DO;
      932     3500    2           RESULT = 0;
      933     3501    2           GOTO SUCCESS;
      934     3502    2           END;
      935     3503    1       IF SOCK.MAXRDS ~= 0 OR SOCK.FLAGS.SELREAD THEN
      936     3504    1           GOTO NOWAIT;
      937     3505    2       IF SOCK.BUFHD ~= 0 THEN DO;
      938     3506    2           CALL XSL$CL_CANCEL( SOCK);
      939     3507    2           IF SOCK.FLAGS.SELREAD THEN
      940     3508    2               GOTO NOWAIT;
      941     3509    2           END;
      942     3510    2       DO CASE( ENTRYFLAG);
      943     3511    2           CASE( %RECVFROM);
      944     3512    2               XSL$RECVFROMRQS = XSL_RECVFROMRQS;
      945     3513    2               XSL$RECVFROMRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);
      946     3514    2               XSL$RECVFROMRQS.LEN = LEN;
      947     3515    2               XSL$RECVFROMRQS.FROMLEN = FROMLEN;
      948     3516    2               CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$RECVFROMRQS));
      949     3517    2               CALL XSL$CL_READ( SOCK, LEN, BUF);
      950     3518    3               IF XSL$RECVFROMRSP.RESULT < 0 THEN DO;
      951     3519    3                   XSL_ERRNO = XSL$RECVFROMRSP.ERRNO;
      952     3520    3   BAILOUT:
      953     3521    3                   RESULT = %E$FAILURE;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:75   
      954     3522    3                   ALTRETURN;
      955     3523    3                   END;
      956     3524    2               FROMLEN = XSL$RECVFROMRSP.FROMLEN;
      957     3525    2               CALL XSL$NTOHADDR( FROM, XSL$RECVFROMRSP.NAME);
      958     3526    2               RESULT = XSL$RECVFROMRSP.RESULT;
      959     3527    2           CASE( %RECV);
      960     3528    2               XSL$RECVRQS = XSL_RECVRQS;
      961     3529    2               XSL$RECVRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);
      962     3530    2               GOTO READ_COMMON;
      963     3531    2           CASE( %READ);
      964     3532    2               XSL$RECVRQS = XSL_RECVRQS;
      965     3533    2               XSL$RECVRQS.FLAGS = 0;
      966     3534    2   READ_COMMON:
      967     3535    3               IF NOT SOCK.FLAGS.CONNECT THEN DO;
      968     3536    3                   XSL_ERRNO = %E$NOTCONN;
      969     3537    3                   GOTO BAILOUT;
      970     3538    3                   END;
      971     3539    2               XSL$RECVRQS.LEN = LEN;
      972     3540    2               CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$RECVRQS));
      973     3541    2               CALL XSL$CL_READ( SOCK, LEN, BUF);
      974     3542    3               IF XSL$RECVRSP.RESULT < 0 THEN DO;
      975     3543    3                   XSL_ERRNO = XSL$RECVRSP.ERRNO;
      976     3544    3                   GOTO BAILOUT;
      977     3545    3                   END;
      978     3546    2               RESULT = XSL$RECVRSP.RESULT;
      979     3547    2           END;
      980     3548    1   SUCCESS:
      981     3549    1       RETURN;
      982     3550    1   NOWAIT:
      983     3551    2       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS AND
      984     3552    2         SOCK.BUFPND# <= SOCK.MAXBUF);
      985     3553    2           CALL XSL$GETBUF( SOCK)
      986     3554    3           WHENALTRETURN DO;
      987     3555    3               EXIT NOWAIT;
      988     3556    3               END;
      989     3557    2           END;
      990     3558    1       SCANNED = 0;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:76   
      991     3559    1   SCANBUFS:
      992     3560    1       BUFPND# = SOCK.BUFPND#;
      993     3561    1       RESULT = 0;
      994     3562    1       LEFT = LEN;
      995     3563    1   RESCAN:
      996     3564    1       MORE = '0'B;
      997     3565    1       BUF$ = PINCRW( XSL_SOCK$$, SOCK.BUFHD);
      998     3566    2       DO WHILE( BUF$ ~= XSL_SOCK$$);
      999     3567    2           IF DATABUF.FLAGS.BUSY THEN EXIT;
     1000     3568    2           IF NOT SOCK.FLAGS.OOBINLINE THEN
     1001     3569    2               IF ENTRYFLAG ~= %READ AND DATABUF.FLAGS.OOB ~= BFLAGS.OOB THEN EXIT;
     1002     3570    2           IF DATABUF.KEY(2) ~= 255 AND DATABUF.KEY(3) ~= 255 THEN
     1003     3571    2               SCANNED = SCANNED + 1;  /* only count successful bufs */
     1004     3572    2           IF DATABUF.LEN = 0 AND DATABUF.KEY(2) = 0 AND DATABUF.KEY(3) = 0 AND
     1005     3573    2             ( ENTRYFLAG = %READ OR NOT BFLAGS.PEEK) THEN
     1006     3574    2               SOCK.FLAGS.RECVSHUT = '1'B;  /* no more data to read */
     1007     3575    2           NUM = MINIMUM( LEFT, DATABUF.LEN);
     1008     3576    2           IF NUM > 0 THEN
     1009     3577    2               SUBSTR( BUF, RESULT, NUM) = PINCRC( BUF$, DATABUF.START)->B$CHARS;
     1010     3578    2           LEFT = LEFT - NUM;
     1011     3579    2           RESULT = RESULT + NUM;
     1012     3580    3           IF ENTRYFLAG = %READ OR NOT BFLAGS.PEEK THEN DO;
     1013     3581    3               DATABUF.START = DATABUF.START + NUM;
     1014     3582    3               DATABUF.LEN = DATABUF.LEN - NUM;
     1015     3583    3               END;
     1016     3584    2           TMP$ = PINCRW( XSL_SOCK$$, DATABUF.NXT);
     1017     3585    2           IF ENTRYFLAG = %RECVFROM THEN
     1018     3586    3               IF DATABUF.KEY(1) = %RECVFROMRSP THEN DO;
     1019     3587    3                   FROMLEN = ADDR( DATABUF.KEY)->XSL$RECVFROMRSP.FROMLEN;
     1020     3588    3                   CALL XSL$NTOHADDR( FROM, ADDR( DATABUF.KEY)->XSL$RECVFROMRSP.NAME);
     1021     3589    3                   END;
     1022     3590    3               ELSE DO;
     1023     3591    3                   FROMLEN = LENGTHC( FROM);
     1024     3592    3                   FROM = SOCK.PEERNAME;
     1025     3593    3                   END;
     1026     3594    3           IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;
     1027     3595    3               IF DATABUF.FLAGS.MORE THEN
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:77   
     1028     3596    3                   MORE = '1'B;
     1029     3597    3               IF NOT MORE OR ( ENTRYFLAG ~= %READ AND BFLAGS.PEEK) THEN
     1030     3598    3                   TMP$ = XSL_SOCK$$;  /* halt scan with this buffer */
     1031     3599    3               IF ENTRYFLAG = %READ OR NOT BFLAGS.PEEK THEN
     1032     3600    3                   DATABUF.LEN = 0;  /* discard remainder of datagram */
     1033     3601    3               END;
     1034     3602    3           IF DATABUF.LEN = 0 THEN DO INHIBIT;
     1035     3603    3               IF DATABUF.KEY(2) ~= 255 AND DATABUF.KEY(3) ~= 255 THEN
     1036     3604    4                   IF DATABUF.FLAGS.OOB AND NOT SOCK.FLAGS.OOBINLINE THEN DO;
     1037     3605    4                       SOCK.OOB# = SOCK.OOB# - 1;
     1038     3606    4                       IF SOCK.OOB# = 0 THEN
     1039     3607    4                           SOCK.FLAGS.SELEXCEP = '0'B;
     1040     3608    4                       END;
     1041     3609    4                   ELSE DO;
     1042     3610    4                       SOCK.DAT# = SOCK.DAT# - 1;
     1043     3611    4                       IF SOCK.DAT# = 0 THEN
     1044     3612    4                           SOCK.FLAGS.SELREAD = '0'B;
     1045     3613    4                       END;
     1046     3614    3               SOCK.FLAGS.REUSEBUF = ~SOCK.FLAGS.RECVSHUT;
     1047     3615    3               SOCK.BUFPND# = SOCK.BUFPND# - 1;
     1048     3616    3               CALL XSL$RELBUF( SOCK, DATABUF);
     1049     3617    3               END;
     1050     3618    2           IF SOCK.FLAGS.RECVSHUT OR LEFT = 0 THEN EXIT;
     1051     3619    3           IF MORE THEN DO INHIBIT;
     1052     3620    4               DO WHILE( SOCK.DAT# = 0);
     1053     3621    4                   CALL M$WAIT( XSL_WAIT1DAY);
     1054     3622    4                   END;
     1055     3623    3               GOTO RESCAN;
     1056     3624    3               END;
     1057     3625    2           BUF$ = TMP$;
     1058     3626    2           END;
     1059     3627    2       IF RESULT = 0 THEN DO;
     1060     3628    2           IF SCANNED ~= 0 THEN
     1061     3629    2               GOTO SUCCESS;
     1062     3630    3           IF SOCK.FLAGS.BLOCKING THEN DO INHIBIT;
     1063     3631    3               IF BUFPND# ~= SOCK.BUFPND# THEN GOTO SCANBUFS;
     1064     3632    3               XSL_UETIME = 0;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:78   
     1065     3633    4               DO WHILE( XSL_UETIME = 0);
     1066     3634    4                   CALL XSL$EVLOG( 'WT', ADDR(SOCK));
     1067     3635    4                   CALL M$WAIT( XSL_WAIT1DAY);
     1068     3636    4                   END;
     1069     3637    3               GOTO SCANBUFS;
     1070     3638    3               END;
     1071     3639    3           ELSE DO;
     1072     3640    3               XSL_ERRNO = %E$WOULDBLOCK;
     1073     3641    3               GOTO BAILOUT;
     1074     3642    3               END;
     1075     3643    2           END;
     1076     3644    1       GOTO SUCCESS;
     1077     3645
     1078     3646    1   END XSL$RECVFROM;
     1079     3647        %EOD;

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:79   
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$RECVFROM.

   Procedure XSL$RECVFROM requires 485 words for executable code.
   Procedure XSL$RECVFROM requires 24 words of local(AUTO) storage.

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:80   

 Object Unit name= XSL$RECVFROM                               File name= XSL$SOCKET2.:TCA2TOU
 UTS= NOV 16 '97 14:32:06.20 SUN                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   DCB   even  none     0      0  M$UC
    1  RoData even  UTS      1      1  XSL$RECVFROM
    2   Proc  even  none   485    745  XSL$RECVFROM
    3  RoData even  none     7      7  XSL$RECVFROM

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     2      0   yes    yes     yes      Std        7  XSL$RECVFROM
     2      4          yes     yes      Std        7  XSL$QRECVFROM
     2     10          yes     yes      Std        5  XSL$RECV
     2     15          yes     yes      Std        5  XSL$QRECV
     2     31          yes     yes      Std        4  XSL$READ
     2     36          yes     yes      Std        4  XSL$QREAD
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:81   

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
         yes          ~proc      0 XSL$MSGSDEFS
 yes     yes           Std       1 XSL$CL_CANCEL
         yes           Std       2 XSL$NTOHADDR
 yes     yes           Std       2 XSL$SOCKPTR
 yes     yes           Std       4 XSL$CL_WRITE
 yes     yes           Std       2 XSL$DCBNPTR
 yes     yes           Std       3 XSL$CL_READ
 yes     yes           Std       2 XSL$RELBUF
 yes     yes           Std       2 XSL$GETBUF
         yes           Std       2 XSL$EVLOG
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AALT
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     M$UC                                  XSL_WAIT1DAY                          XSL_RECVRQS
     XSL_RECVFROMRQS                       XSL_ERRNO                        r    XSL_KEYBUF$
     XSL_SOCK$$                            XSL_UETIME                            B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ROSID                                 ISSID
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:82   


      513        1        /*T***********************************************************/
      514        2        /*T*                                                         */
      515        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
      516        4        /*T*                                                         */
      517        5        /*T***********************************************************/
      518        6        /*F* NAME: recvfrom() and XSL$RECVFROM  --  Read Data With Options and Address
      519        7        ..::IT "Purpose:"
      520        8        .INL +4
      521        9        Receives a message from a socket into an application-specified buffer,
      522       10        along with the address of the message's sender.
      523       11        ..::IT "C Usage:"
      524       12        .INL 4
      525       13        .FIF
      526       14        status = recvfrom( s, buf, len, flags, from, fromlen );
      527       15        ..::IT "PL6 Usage:"
      528       16        .INL 4
      529       17        .FIF
      530       18        CALL XSL$RECVFROM( status, s, buf, len, flags, from, fromlen );
      531       19        ..::IT "Parameters:"
      532       20        .INL 4
      533       21        .FIF
      534       22        s           integer socket descriptor
      535       23
      536       24        buf         character array buffer
      537       25
      538       26        len         integer size of buf in characters
      539       27
      540       28        flags       integer bitflags of recvfrom options
      541       29
      542       30        from        sockaddr structure
      543       31
      544       32        fromlen     integer size of from in characters
      545       33        ..::IT "Results:"
      546       34        .INL 4
      547       35        .FIF
      548       36        status      integer number of characters received or error code
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:83   
      549       37
      550       38        buf         character array buffer
      551       39
      552       40        from        sockaddr structure with address of message's sender
      553       41
      554       42        fromlen     integer number of significant characters in from
      555       43        ..::IT "Description:"
      556       44        The recvfrom() function receives a message from a connected socket and places
      557       45        it in the buffer specified.  Additionally, the network address of the
      558       46        message's sender is provided.
      559       47        .SPB
      560       48        The s parameter specifies the descriptor of the socket on which to receive.
      561       49        .SPB
      562       50        The buf parameter specifies an application-defined buffer to hold the
      563       51        message received from the socket.
      564       52        .SPB
      565       53        The len parameter specifies how large the buffer is, expressed as the
      566       54        number of characters it can hold.
      567       55        .SPB
      568       56        The flags parameter specifies recvfrom options.  The desired options are
      569       57        'ORed' together when coding the invocation.  The only options currently
      570       58        implemented are "out-of-band" and "peek".  The out-of-band option receives
      571       59        any message that was sent on the out-of-band data path if the socket supports
      572       60        it.  It is selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source,
      573       61        respectively.  The peek option copies a message into the buffer, but
      574       62        additionally leaves it in the recvfrom() queue so subsequent recvfrom() invocations
                62        see
      575       63       the same message. It is selected by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 sou
                63        rce,
      576       64        respectively.
      577       65        .SPB
      578       66        The from parameter specifies an address buffer into which is placed the
      579       67        network address of the message's sender.
      580       68        .SPB
      581       69        The fromlen parameter specifies how large from is, expressed as the number
      582       70        of characters it can hold.
      583       71        .SPB
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:84   
      584       72        If the recvfrom() function is successful, the status result contains the
      585       73        number of characters received.  This number is non-negative.
      586       74        On datagram sockets, if the buffer is not large enough to receive the
      587       75        entire message, the excess will be discarded.  The network address of
      588       76        the message's sender is placed into from, and fromlen is set to the number
      589       77        of significant characters in from.
      590       78        .SPB
      591       79        If the recvfrom() function is unsuccessful, the status result contains
      592       80        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      593       81        to determine the specific error condition.  The XSL$RECVFROM procedure
      594       82        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      595       83        to the recvfrom() function.
      596       84        .SPB
      597       85        If no data is available from a socket when recvfrom() is invoked, the action
      598       86        taken depends on the socket mode.  The mode of a socket is defined
      599       87        to be either "blocking" or "nonblocking".  If the socket is blocking
      600       88        (which is the default mode) the application is blocked (i.e., suspended)
      601       89        until a message is received from the network.  If the socket is nonblocking,
      602       90        the condition is treated as an EWOULDBLOCK error.
      603       91        .SPB
      604       92        The mode of a socket can be changed with either fcntl() or ioctl().
      605       93        .SPB
      606       94        Recvfrom() may be used on sockets regardless of whether connect() has been
      607       95        issued.
      608       96        .SPB
      609       97        If shutdown() has been invoked for this socket to inhibit reception of
      610       98        data, or if the peer is no longer connected, all recvfrom() operations
      611       99        are treated as if zero bytes of data were read.
      612      100        ..::IT "Errors:"
      613      101        Following are the possible error conditions reported when the recvfrom()
      614      102        function is unsuccessful.  Equates for the possible values can be found in
      615      103        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      616      104
      617      105        .FIF
      618      106
      619      107        C #define               PL6 %EQU
      620      108        ----------------------- -----------------------
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:85   
      621      109        EBADF                   E$BADF
      622      110        .FIN
      623      111        The descriptor s is not appropriate to identify a socket.
      624      112        .FIF
      625      113
      626      114        ENOTSOCK                E$NOTSOCK
      627      115        .FIN
      628      116        The descriptor s is no longer valid to identify a socket.
      629      117        .FIF
      630      118
      631      119        EWOULDBLOCK             E$WOULDBLOCK
      632      120        .FIN
      633      121        There is no data available from this nonblocking socket.
      634      122        .FIF
      635      123        */
      636      124        /*F* NAME: recv() and XSL$RECV  --  Read Data With Options
      637      125        ..::IT "Purpose:"
      638      126        .INL +4
      639      127        Receives a message from a connected socket into an
      640      128        application-specified buffer.
      641      129        ..::IT "C Usage:"
      642      130        .INL 4
      643      131        .FIF
      644      132        status = recv( s, buf, len, flags );
      645      133        ..::IT "PL6 Usage:"
      646      134        .INL 4
      647      135        .FIF
      648      136        CALL XSL$RECV( status, s, buf, len, flags );
      649      137        ..::IT "Parameters:"
      650      138        .INL 4
      651      139        .FIF
      652      140        s           integer socket descriptor
      653      141
      654      142        buf         character array buffer
      655      143
      656      144        len         integer size of buf in characters
      657      145
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:86   
      658      146        flags       integer bitflags of recv options
      659      147        ..::IT "Results:"
      660      148        .INL 4
      661      149        .FIF
      662      150        status      integer number of characters received or error code
      663      151
      664      152        buf         character array buffer
      665      153        ..::IT "Description:"
      666      154        The recv() function receives a message from a connected socket and places
      667      155        it in the buffer specified.
      668      156        .SPB
      669      157        The s parameter specifies the descriptor of the socket on which to receive.
      670      158        .SPB
      671      159        The buf parameter specifies an application-defined buffer to hold the
      672      160        message received from the socket.
      673      161        .SPB
      674      162        The len parameter specifies how large the buffer is, expressed as the
      675      163        number of characters it can hold.
      676      164        .SPB
      677      165        The flags parameter specifies recv options.  The desired options are 'OR-ed'
      678      166        together when coding the invocation.  The only options currently implemented
      679      167        are "out-of-band" and "peek".  The out-of-band option receives any message
      680      168        that was sent on the out-of-band data path if the socket supports it.  It is
      681      169        selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source, respectively.
      682      170        The peek option copies a message into the buffer, but additionally leaves
      683      171        it in the recv() queue so subsequent recv() invocations see the same message. It is
               171        selected
      684      172        by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 source, respectively.
      685      173        .SPB
      686      174        If the recv() function is successful, the status result contains the number
      687      175        of characters received.  This number is non-negative.  On
      688      176        datagram sockets, if the buffer is not large enough to receive the
      689      177        entire message, the excess will be discarded.
      690      178        .SPB
      691      179        If the recv() function is unsuccessful, the status result contains
      692      180        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      693      181        to determine the specific error condition.  The XSL$RECV procedure
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:87   
      694      182        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      695      183        to the recv() function.
      696      184        .SPB
      697      185        If no data is available from a socket when recv() is invoked, the action
      698      186        taken depends on the socket mode.  The mode of a socket is defined
      699      187        to be either "blocking" or "nonblocking".  If the socket is blocking
      700      188        (which is the default mode) the application is blocked (i.e., suspended)
      701      189        until a message is received from the network.  If the socket is nonblocking,
      702      190        the condition is treated as an EWOULDBLOCK error.
      703      191        .SPB
      704      192        The mode of a socket can be changed with either fcntl() or ioctl().
      705      193        .SPB
      706      194        Recv() may be used only on sockets that have had connect() invoked.
      707      195        .SPB
      708      196        If shutdown() has been invoked for this socket to inhibit reception of
      709      197        data, or if the peer is no longer connected, all recv() operations are
      710      198        treated as if zero bytes of data were read.
      711      199        ..::IT "Errors:"
      712      200        Following are the possible error conditions reported when the recv()
      713      201        function is unsuccessful.  Equates for the possible values can be found in
      714      202        <xsl_errno.h> or XSL_PERR_C for C and PL6 source, respectively.
      715      203
      716      204        .FIF
      717      205
      718      206        C #define               PL6 %EQU
      719      207        ----------------------- -----------------------
      720      208        EBADF                   E$BADF
      721      209        .FIN
      722      210        The descriptor s is not appropriate to identify a socket.
      723      211        .FIF
      724      212
      725      213        ENOTCONN                E$NOTCONN
      726      214        .FIN
      727      215        The connect() function has not been invoked for this socket.
      728      216        .FIN
      729      217
      730      218        ENOTSOCK                E$NOTSOCK
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:88   
      731      219        .FIN
      732      220        The descriptor s is no longer valid to identify a socket.
      733      221        .FIF
      734      222
      735      223        EWOULDBLOCK             E$WOULDBLOCK
      736      224        .FIN
      737      225        There is no data available from this nonblocking socket.
      738      226        .FIF
      739      227        */
      740      228        /*F* NAME: read() and XSL$READ  --  Read Data
      741      229        ..::IT "Purpose:"
      742      230        .INL +4
      743      231        Reads data from a socket into an application-specified buffer.
      744      232        ..::IT "C Usage:"
      745      233        .INL 4
      746      234        .FIF
      747      235        status = read( s, buf, len );
      748      236        ..::IT "PL6 Usage:"
      749      237        .INL 4
      750      238        .FIF
      751      239        CALL XSL$READ( status, s, buf, len );
      752      240        ..::IT "Parameters:"
      753      241        .INL 4
      754      242        .FIF
      755      243        s           integer socket descriptor
      756      244
      757      245        buf         character array buffer
      758      246
      759      247        len         integer size of buf in characters
      760      248        ..::IT "Results:"
      761      249        .INL 4
      762      250        .FIF
      763      251        status      integer number of characters read or error code
      764      252
      765      253        buf         character array buffer
      766      254        ..::IT "Description:"
      767      255        The read() function reads any available data from the socket into the
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:89   
      768      256        buffer specified.
      769      257        .SPB
      770      258        The s parameter specifies the descriptor of the socket to be read from.
      771      259        .SPB
      772      260        The buf parameter specifies an application-defined buffer to receive the
      773      261        data to be read from the socket.
      774      262        .SPB
      775      263        The len parameter specifies how large the buffer is, expressed as the
      776      264        number of characters it can hold.
      777      265        .SPB
      778      266        If the read() function is successful, the status result contains the
      779      267        number of characters read into buf.  This number is non-negative.
      780      268        A successful read() returns all data available, up to the size of buf.
      781      269        On datagram sockets, if the buffer is not large enough to receive the
      782      270        entire datagram, the excess will be discarded.
      783      271        .SPB
      784      272        If the read() function is unsuccessful, the status result contains
      785      273        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
      786      274        to determine the specific error condition.  The XSL$READ procedure
      787      275        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
      788      276        to the read() function.
      789      277        .SPB
      790      278        If no data is available from a socket when read() is invoked, the action
      791      279        taken depends on the socket mode.  The mode of a socket is defined
      792      280        to be either "blocking" or "nonblocking".  If the socket is blocking
      793      281        (which is the default mode) the application is blocked (i.e., suspended)
      794      282        until data is received from the network.  If the socket is nonblocking,
      795      283        the condition is treated as an EWOULDBLOCK error.
      796      284        .SPB
      797      285        The mode of a socket can be changed with either fcntl() or ioctl().
      798      286        .SPB
      799      287        If shutdown() has been invoked for this socket to inhibit reception of
      800      288        data, or if the peer is no longer connected, all read() operations are
      801      289        treated as if zero bytes of data were read.
      802      290        ..::IT "Errors:"
      803      291        Following are the possible error conditions reported when the read()
      804      292        function is unsuccessful.  Equates for the possible values can be
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:90   
      805      293        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
      806      294
      807      295        .FIF
      808      296
      809      297        C #define               PL6 %EQU
      810      298        ----------------------- -----------------------
      811      299        EBADF                   E$BADF
      812      300        .FIN
      813      301        The descriptor s is not appropriate to identify a socket.
      814      302        .FIF
      815      303
      816      304        ENOTCONN                E$NOTCONN
      817      305        .FIN
      818      306        The socket is not currently connected.  connect() has not been invoked.
      819      307        .FIF
      820      308
      821      309        ENOTSOCK                E$NOTSOCK
      822      310        .FIN
      823      311        The descriptor s is no longer valid to identify a socket.
      824      312        .FIF
      825      313
      826      314        EWOULDBLOCK             E$WOULDBLOCK
      827      315        .FIN
      828      316        There is no data available from this nonblocking socket.
      829      317        .FIF
      830      318        */
      831      319        XSL$RECVFROM: PROC( RESULT, SOCK#, BUF, LEN, FLAGS, FROM, FROMLEN) ALTRET;

    319  2 000000   000000 700200 xent  XSL$RECVFROM TSX0  ! X66_AUTO_N
         2 000001   000030 000007                    ZERO    24,7

      832      320        %INCLUDE CP_6;
      833      401            %F$DCB;
      834      458            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
      835      472        %INCLUDE XSL_SOCKET_E;
      836      730        %INCLUDE XSL_SOCKET_M;
      837     1491            %XSL$SOCKADDR( FPTN=FROM, STCLASS=);
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:91   
      838     1531        %INCLUDE XSL_PERR_C;
      839     1586        %INCLUDE XSL_INTERNAL_M;
      840     1837            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
      841     1981            %XSL$SOCKHD( STCLASS="BASED( XSL_SOCK$$)");
      842     2014            %XSL$DATABUF( FPTN=DATABUF, STCLASS="BASED( BUF$)");
      843     2047        %INCLUDE XSL_SOCKMSGS_E;
      844     2093        %INCLUDE XSL_SOCKMSGS_M;
      845     3226            %XSL_REFMSGS;
      846     3229            %XSL$RECVRQS( FPTN=XSL_RECVRQS, STCLASS=SYMREF);
      847     3256            %XSL$RECVRQS( STCLASS="BASED( XSL_KEYBUF$)");
      848     3283            %XSL$RECVRSP( STCLASS="BASED( XSL_KEYBUF$)");
      849     3310            %XSL$RECVFROMRQS( FPTN=XSL_RECVFROMRQS, STCLASS=SYMREF);
      850     3338            %XSL$RECVFROMRQS( STCLASS="BASED( XSL_KEYBUF$)");
      851     3366            %XSL$RECVFROMRSP( STCLASS="BASED( XSL_KEYBUF$)");
      852     3420
      853     3421    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
      854     3422    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
      855     3423    1       DCL XSL$CL_CANCEL ENTRY(1) ALTRET;
      856     3424    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
      857     3425    1       DCL XSL$RELBUF ENTRY(2) ALTRET;
      858     3426    1       DCL XSL$NTOHADDR ENTRY(2);
      859     3427    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
      860     3428    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
      861     3429    1       DCL XSL$EVLOG ENTRY(2);
      862     3430
      863     3431    1       DCL XSL_ERRNO SBIN SYMREF;
      864     3432    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
      865     3433    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
      866     3434    1       DCL XSL_SOCK$$ PTR SYMREF;
      867     3435    1       DCL XSL_UETIME SBIN SYMREF;
      868     3436
      869     3437    1       DCL B$CHARS CHAR( NUM) BASED CALIGNED;
      870     3438    1       DCL LEFT SBIN;
      871     3439    1       DCL NUM SBIN;
      872     3440    1       DCL BUF$ PTR;
      873     3441    1       DCL TMP$ PTR;
      874     3442    1       DCL SCANNED SBIN;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:92   
      875     3443    1       DCL BUFPND# SBIN;
      876     3444    1       DCL BUF CHAR( LEN) CALIGNED;
      877     3445    1       DCL ENTRYFLAG SBIN;
      878     3446        %EQU RECVFROM = 0;
      879     3447        %EQU RECV = 1;
      880     3448        %EQU READ = 2;
      881     3449    1       DCL FLAGS UBIN;
      882     3450    1       DCL 1 BFLAGS REDEF FLAGS,
      883     3451    1           2 * BIT(34) UNAL,
      884     3452    1           2 PEEK BIT(1) UNAL,
      885     3453    1           2 OOB BIT(1) UNAL;
      886     3454    1       DCL FROMLEN SBIN;
      887     3455    1       DCL LEN SBIN;
      888     3456    1       DCL MORE BIT(1) UNAL;
      889     3457    1       DCL RESULT SBIN;
      890     3458    1       DCL SOCK# SBIN;
      891     3459    1       DCL SOCK$ PTR;
      892     3460
      893     3461    1       ENTRYFLAG = %RECVFROM;

   3461  2 000002   200020 450100                    STZ     ENTRYFLAG,,AUTO

      894     3462    1       GOTO COMMONDCBN;

   3462  2 000003   000043 710000 2                  TRA     COMMONDCBN

      895     3463
      896     3464    1   XSL$QRECVFROM: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS, FROM, FROMLEN) ALTRET;

   3464  2 000004   000000 700200 xent  XSL$QRECVFR* TSX0  ! X66_AUTO_N
         2 000005   000030 000007                    ZERO    24,7

      897     3465
      898     3466    1       ENTRYFLAG = %RECVFROM;

   3466  2 000006   200020 450100                    STZ     ENTRYFLAG,,AUTO

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:93   
      899     3467    1       GOTO COMMONSOCK;

   3467  2 000007   000021 710000 2                  TRA     COMMONSOCK

      900     3468
      901     3469    1   XSL$RECV: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS) ALTRET;

   3469  2 000010   000000 700200 xent  XSL$RECV     TSX0  ! X66_AUTO_N
         2 000011   000030 000007                    ZERO    24,7

      902     3470
      903     3471    1       ENTRYFLAG = %RECV;

   3471  2 000012   000001 235007                    LDA     1,DL
         2 000013   200020 755100                    STA     ENTRYFLAG,,AUTO

      904     3472    1       GOTO COMMONDCBN;

   3472  2 000014   000043 710000 2                  TRA     COMMONDCBN

      905     3473
      906     3474    1   XSL$QRECV: ENTRY( RESULT, SOCK#, BUF, LEN, FLAGS) ALTRET;

   3474  2 000015   000000 700200 xent  XSL$QRECV    TSX0  ! X66_AUTO_N
         2 000016   000030 000007                    ZERO    24,7

      907     3475
      908     3476    1       ENTRYFLAG = %RECV;

   3476  2 000017   000001 235007                    LDA     1,DL
         2 000020   200020 755100                    STA     ENTRYFLAG,,AUTO

      909     3477    1   COMMONSOCK:
      910     3478    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   3478  2 000021   000000 236000 3     COMMONSOCK   LDQ     0
         2 000022   200004 235100                    LDA     @SOCK#,,AUTO
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:94   
         2 000023   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000024   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000025   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000026   000000 701000 xent               TSX1    XSL$SOCKPTR
         2 000027   000162 702000 2                  TSX2    BAILOUT

      911     3479    1       GOTO LATER;

   3479  2 000030   000052 710000 2                  TRA     LATER

      912     3480
      913     3481    1   XSL$READ: ENTRY( RESULT, SOCK#, BUF, LEN) ALTRET;

   3481  2 000031   000000 700200 xent  XSL$READ     TSX0  ! X66_AUTO_N
         2 000032   000030 000007                    ZERO    24,7

      914     3482
      915     3483    1       ENTRYFLAG = %READ;

   3483  2 000033   000002 235007                    LDA     2,DL
         2 000034   200020 755100                    STA     ENTRYFLAG,,AUTO

      916     3484    1       GOTO COMMONDCBN;

   3484  2 000035   000043 710000 2                  TRA     COMMONDCBN

      917     3485
      918     3486    1   XSL$QREAD: ENTRY( RESULT, SOCK#, BUF, LEN) ALTRET;

   3486  2 000036   000000 700200 xent  XSL$QREAD    TSX0  ! X66_AUTO_N
         2 000037   000030 000007                    ZERO    24,7

      919     3487
      920     3488    1       ENTRYFLAG = %READ;

   3488  2 000040   000002 235007                    LDA     2,DL
         2 000041   200020 755100                    STA     ENTRYFLAG,,AUTO
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:95   

      921     3489    1       GOTO COMMONSOCK;

   3489  2 000042   000021 710000 2                  TRA     COMMONSOCK

      922     3490
      923     3491    1   COMMONDCBN:
      924     3492    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   3492  2 000043   000000 236000 3     COMMONDCBN   LDQ     0
         2 000044   200004 235100                    LDA     @SOCK#,,AUTO
         2 000045   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000046   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000047   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000050   000000 701000 xent               TSX1    XSL$DCBNPTR
         2 000051   000162 702000 2                  TSX2    BAILOUT

      925     3493    1   LATER:
      926     3494    1       SOCK$ = XSL_SOCK$;

   3494  2 000052   000000 236000 xsym  LATER        LDQ     XSL_ERRNO
         2 000053   200022 756100                    STQ     SOCK$,,AUTO

      927     3495    2       IF NOT SOCK.FLAGS.SOCKET THEN DO;

   3495  2 000054   200022 470500                    LDP0    SOCK$,,AUTO
         2 000055   000001 236100                    LDQ     1,,PR0
         2 000056   002000 316003                    CANQ    1024,DU
         2 000057   000063 601000 2                  TNZ     s:3499

      928     3496    2           XSL_ERRNO = %E$NOTBOUND;

   3496  2 000060   000401 235007                    LDA     257,DL
         2 000061   000000 755000 xsym               STA     XSL_ERRNO

      929     3497    2           GOTO BAILOUT;

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:96   
   3497  2 000062   000162 710000 2                  TRA     BAILOUT

      930     3498    2           END;
      931     3499    2       IF SOCK.FLAGS.RECVSHUT THEN DO;

   3499  2 000063   100000 316003                    CANQ    32768,DU
         2 000064   000070 600000 2                  TZE     s:3503

      932     3500    2           RESULT = 0;

   3500  2 000065   200003 471500                    LDP1    @RESULT,,AUTO
         2 000066   100000 450100                    STZ     0,,PR1

      933     3501    2           GOTO SUCCESS;

   3501  2 000067   000277 710000 2                  TRA     SUCCESS

      934     3502    2           END;
      935     3503    1       IF SOCK.MAXRDS ~= 0 OR SOCK.FLAGS.SELREAD THEN

   3503  2 000070   000020 720100                    LXL0    16,,PR0
         2 000071   000300 601000 2                  TNZ     NOWAIT
         2 000072   000040 316003                    CANQ    32,DU
         2 000073   000300 601000 2                  TNZ     NOWAIT

      936     3504    1           GOTO NOWAIT;
      937     3505    2       IF SOCK.BUFHD ~= 0 THEN DO;

   3505  2 000074   000016 221100                    LDX1    14,,PR0
         2 000075   000106 600000 2                  TZE     s:3510

      938     3506    2           CALL XSL$CL_CANCEL( SOCK);

   3506  2 000076   200022 630500                    EPPR0   SOCK$,,AUTO
         2 000077   000017 631400 xsym               EPPR1   B_VECTNIL+15
         2 000100   000000 701000 xent               TSX1    XSL$CL_CANCEL
         2 000101   000000 011000                    NOP     0
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:97   

      939     3507    2           IF SOCK.FLAGS.SELREAD THEN

   3507  2 000102   200022 470500                    LDP0    SOCK$,,AUTO
         2 000103   000001 236100                    LDQ     1,,PR0
         2 000104   000040 316003                    CANQ    32,DU
         2 000105   000300 601000 2                  TNZ     NOWAIT

      940     3508    2               GOTO NOWAIT;
      941     3509    2           END;

      942     3510    2       DO CASE( ENTRYFLAG);

   3510  2 000106   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000107   000003 115007                    CMPA    3,DL
         2 000110   000112 602005 2                  TNC     s:3510+4,AL
         2 000111   000277 710000 2                  TRA     SUCCESS
         2 000112   000115 710000 2                  TRA     s:3512
         2 000113   000212 710000 2                  TRA     s:3528
         2 000114   000224 710000 2                  TRA     s:3532

      943     3511    2           CASE( %RECVFROM);

      944     3512    2               XSL$RECVFROMRQS = XSL_RECVFROMRQS;

   3512  2 000115   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000116   000100 100400                    MLR     fill='000'O
         2 000117   000000 000010 xsym               ADSC9   XSL_RECVFROMRQS          cn=0,n=8
         2 000120   100000 000010                    ADSC9   0,,PR1                   cn=0,n=8

      945     3513    2               XSL$RECVFROMRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);

   3513  2 000121   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000122   300000 236100                    LDQ     0,,PR3
         2 000123   000177 376007                    ANQ     127,DL
         2 000124   000000 620006                    EAX0    0,QL
         2 000125   100000 440100                    SXL0    0,,PR1
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:98   

      946     3514    2               XSL$RECVFROMRQS.LEN = LEN;

   3514  2 000126   200006 474500                    LDP4    @LEN,,AUTO
         2 000127   400000 721100                    LXL1    0,,PR4
         2 000130   100001 741100                    STX1    1,,PR1

      947     3515    2               XSL$RECVFROMRQS.FROMLEN = FROMLEN;

   3515  2 000131   200011 475500                    LDP5    @FROMLEN,,AUTO
         2 000132   500000 722100                    LXL2    0,,PR5
         2 000133   100001 442100                    SXL2    1,,PR1

      948     3516    2               CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$RECVFROMRQS));

   3516  2 000134   000001 236000 3                  LDQ     1
         2 000135   200022 235100                    LDA     SOCK$,,AUTO
         2 000136   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000137   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000140   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000141   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000142   000000 011000                    NOP     0

      949     3517    2               CALL XSL$CL_READ( SOCK, LEN, BUF);

   3517  2 000143   200005 236100                    LDQ     @BUF,,AUTO
         2 000144   200026 756100                    STQ     SOCK$+4,,AUTO
         2 000145   200006 236100                    LDQ     @LEN,,AUTO
         2 000146   200022 235100                    LDA     SOCK$,,AUTO
         2 000147   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000150   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000151   000021 631400 xsym               EPPR1   B_VECTNIL+17
         2 000152   000000 701000 xent               TSX1    XSL$CL_READ
         2 000153   000000 011000                    NOP     0

      950     3518    3               IF XSL$RECVFROMRSP.RESULT < 0 THEN DO;

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:99   
   3518  2 000154   000000 470400 xsym               LDP0    XSL_KEYBUF$
         2 000155   000000 720100                    LXL0    0,,PR0
         2 000156   000166 605000 2                  TPL     s:3524

      951     3519    3                   XSL_ERRNO = XSL$RECVFROMRSP.ERRNO;

   3519  2 000157   000001 236100                    LDQ     1,,PR0
         2 000160   000022 732000                    QRS     18
         2 000161   000000 756000 xsym               STQ     XSL_ERRNO

      952     3520    3   BAILOUT:
      953     3521    3                   RESULT = %E$FAILURE;

   3521  2 000162   000001 335007       BAILOUT      LCA     1,DL
         2 000163   200003 470500                    LDP0    @RESULT,,AUTO
         2 000164   000000 755100                    STA     0,,PR0

      954     3522    3                   ALTRETURN;

   3522  2 000165   000000 702200 xent               TSX2  ! X66_AALT

      955     3523    3                   END;
      956     3524    2               FROMLEN = XSL$RECVFROMRSP.FROMLEN;

   3524  2 000166   000001 236100                    LDQ     1,,PR0
         2 000167   000022 736000                    QLS     18
         2 000170   000022 732000                    QRS     18
         2 000171   200011 471500                    LDP1    @FROMLEN,,AUTO
         2 000172   100000 756100                    STQ     0,,PR1

      957     3525    2               CALL XSL$NTOHADDR( FROM, XSL$RECVFROMRSP.NAME);

   3525  2 000173   000000 236000 xsym               LDQ     XSL_KEYBUF$
         2 000174   000002 036003                    ADLQ    2,DU
         2 000175   200010 235100                    LDA     @FROM,,AUTO
         2 000176   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000177   200024 630500                    EPPR0   SOCK$+2,,AUTO
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:100  
         2 000200   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000201   000000 701000 xent               TSX1    XSL$NTOHADDR
         2 000202   000000 011000                    NOP     0

      958     3526    2               RESULT = XSL$RECVFROMRSP.RESULT;

   3526  2 000203   000000 470400 xsym               LDP0    XSL_KEYBUF$
         2 000204   000000 236100                    LDQ     0,,PR0
         2 000205   000022 736000                    QLS     18
         2 000206   000022 732000                    QRS     18
         2 000207   200003 471500                    LDP1    @RESULT,,AUTO
         2 000210   100000 756100                    STQ     0,,PR1
         2 000211   000277 710000 2                  TRA     SUCCESS

      959     3527    2           CASE( %RECV);

      960     3528    2               XSL$RECVRQS = XSL_RECVRQS;

   3528  2 000212   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000213   000100 100400                    MLR     fill='000'O
         2 000214   000000 000006 xsym               ADSC9   XSL_RECVRQS              cn=0,n=6
         2 000215   100000 000006                    ADSC9   0,,PR1                   cn=0,n=6

      961     3529    2               XSL$RECVRQS.FLAGS = MOD( FLAGS, %XSL_MSG_MORE);

   3529  2 000216   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000217   300000 236100                    LDQ     0,,PR3
         2 000220   000177 376007                    ANQ     127,DL
         2 000221   000000 620006                    EAX0    0,QL
         2 000222   100000 440100                    SXL0    0,,PR1

      962     3530    2               GOTO READ_COMMON;

   3530  2 000223   000232 710000 2                  TRA     READ_COMMON

      963     3531    2           CASE( %READ);

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:101  
      964     3532    2               XSL$RECVRQS = XSL_RECVRQS;

   3532  2 000224   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000225   000100 100400                    MLR     fill='000'O
         2 000226   000000 000006 xsym               ADSC9   XSL_RECVRQS              cn=0,n=6
         2 000227   100000 000006                    ADSC9   0,,PR1                   cn=0,n=6

      965     3533    2               XSL$RECVRQS.FLAGS = 0;

   3533  2 000230   000000 220003                    LDX0    0,DU
         2 000231   100000 440100                    SXL0    0,,PR1

      966     3534    2   READ_COMMON:
      967     3535    3               IF NOT SOCK.FLAGS.CONNECT THEN DO;

   3535  2 000232   000001 236100       READ_COMMON  LDQ     1,,PR0
         2 000233   040000 316003                    CANQ    16384,DU
         2 000234   000240 601000 2                  TNZ     s:3539

      968     3536    3                   XSL_ERRNO = %E$NOTCONN;

   3536  2 000235   000164 235007                    LDA     116,DL
         2 000236   000000 755000 xsym               STA     XSL_ERRNO

      969     3537    3                   GOTO BAILOUT;

   3537  2 000237   000162 710000 2                  TRA     BAILOUT

      970     3538    3                   END;
      971     3539    2               XSL$RECVRQS.LEN = LEN;

   3539  2 000240   200006 473500                    LDP3    @LEN,,AUTO
         2 000241   300000 721100                    LXL1    0,,PR3
         2 000242   100001 741100                    STX1    1,,PR1

      972     3540    2               CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$RECVRQS));

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:102  
   3540  2 000243   000002 236000 3                  LDQ     2
         2 000244   200022 235100                    LDA     SOCK$,,AUTO
         2 000245   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000246   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000247   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000250   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000251   000000 011000                    NOP     0

      973     3541    2               CALL XSL$CL_READ( SOCK, LEN, BUF);

   3541  2 000252   200005 236100                    LDQ     @BUF,,AUTO
         2 000253   200026 756100                    STQ     SOCK$+4,,AUTO
         2 000254   200006 236100                    LDQ     @LEN,,AUTO
         2 000255   200022 235100                    LDA     SOCK$,,AUTO
         2 000256   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000257   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000260   000021 631400 xsym               EPPR1   B_VECTNIL+17
         2 000261   000000 701000 xent               TSX1    XSL$CL_READ
         2 000262   000000 011000                    NOP     0

      974     3542    3               IF XSL$RECVRSP.RESULT < 0 THEN DO;

   3542  2 000263   000000 470400 xsym               LDP0    XSL_KEYBUF$
         2 000264   000000 720100                    LXL0    0,,PR0
         2 000265   000272 605000 2                  TPL     s:3546

      975     3543    3                   XSL_ERRNO = XSL$RECVRSP.ERRNO;

   3543  2 000266   000001 236100                    LDQ     1,,PR0
         2 000267   000022 732000                    QRS     18
         2 000270   000000 756000 xsym               STQ     XSL_ERRNO

      976     3544    3                   GOTO BAILOUT;

   3544  2 000271   000162 710000 2                  TRA     BAILOUT

      977     3545    3                   END;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:103  
      978     3546    2               RESULT = XSL$RECVRSP.RESULT;

   3546  2 000272   000000 236100                    LDQ     0,,PR0
         2 000273   000022 736000                    QLS     18
         2 000274   000022 732000                    QRS     18
         2 000275   200003 471500                    LDP1    @RESULT,,AUTO
         2 000276   100000 756100                    STQ     0,,PR1

      979     3547    2           END;

      980     3548    1   SUCCESS:
      981     3549    1       RETURN;

   3549  2 000277   000000 702200 xent  SUCCESS      TSX2  ! X66_ARET

      982     3550    1   NOWAIT:
      983     3551    2       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS AND

   3551  2 000300   000307 710000 2     NOWAIT       TRA     s:3557

      984     3552    2         SOCK.BUFPND# <= SOCK.MAXBUF);
      985     3553    2           CALL XSL$GETBUF( SOCK)

   3553  2 000301   200022 630500                    EPPR0   SOCK$,,AUTO
         2 000302   000017 631400 xsym               EPPR1   B_VECTNIL+15
         2 000303   000000 701000 xent               TSX1    XSL$GETBUF
         2 000304   000306 702000 2                  TSX2    s:3555
         2 000305   000307 710000 2                  TRA     s:3557

      986     3554    3           WHENALTRETURN DO;

      987     3555    3               EXIT NOWAIT;

   3555  2 000306   000330 710000 2                  TRA     s:3558

      988     3556    3               END;
      989     3557    2           END;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:104  

   3557  2 000307   000003 470400 3                  LDP0    3
         2 000310   000000 471500                    LDP1    0,,PR0
         2 000311   200022 473500                    LDP3    SOCK$,,AUTO
         2 000312   300003 720100                    LXL0    3,,PR3
         2 000313   100000 474510                    LDP4    0,X0,PR1
         2 000314   300020 236100                    LDQ     16,,PR3
         2 000315   777777 376007                    ANQ     -1,DL
         2 000316   200024 756100                    STQ     SOCK$+2,,AUTO
         2 000317   400074 236100                    LDQ     60,,PR4
         2 000320   000033 772000                    QRL     27
         2 000321   000377 376007                    ANQ     255,DL
         2 000322   200024 116100                    CMPQ    SOCK$+2,,AUTO
         2 000323   000330 605000 2                  TPL     s:3558
         2 000324   300017 720100                    LXL0    15,,PR3
         2 000325   300020 100100                    CMPX0   16,,PR3
         2 000326   000301 602000 2                  TNC     s:3553
         2 000327   000301 600000 2                  TZE     s:3553

      990     3558    1       SCANNED = 0;

   3558  2 000330   200016 450100                    STZ     SCANNED,,AUTO

      991     3559    1   SCANBUFS:
      992     3560    1       BUFPND# = SOCK.BUFPND#;

   3560  2 000331   200022 470500       SCANBUFS     LDP0    SOCK$,,AUTO
         2 000332   000017 236100                    LDQ     15,,PR0
         2 000333   777777 376007                    ANQ     -1,DL
         2 000334   200017 756100                    STQ     BUFPND#,,AUTO

      993     3561    1       RESULT = 0;

   3561  2 000335   200003 471500                    LDP1    @RESULT,,AUTO
         2 000336   100000 450100                    STZ     0,,PR1

      994     3562    1       LEFT = LEN;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:105  

   3562  2 000337   200006 473500                    LDP3    @LEN,,AUTO
         2 000340   300000 235100                    LDA     0,,PR3
         2 000341   200012 755100                    STA     LEFT,,AUTO

      995     3563    1   RESCAN:
      996     3564    1       MORE = '0'B;

   3564  2 000342   200021 450100       RESCAN       STZ     MORE,,AUTO

      997     3565    1       BUF$ = PINCRW( XSL_SOCK$$, SOCK.BUFHD);

   3565  2 000343   200022 470500                    LDP0    SOCK$,,AUTO
         2 000344   000016 220100                    LDX0    14,,PR0
         2 000345   000000 636010                    EAQ     0,X0
         2 000346   000000 036000 xsym               ADLQ    XSL_SOCK$$
         2 000347   200014 756100                    STQ     BUF$,,AUTO

      998     3566    2       DO WHILE( BUF$ ~= XSL_SOCK$$);

   3566  2 000350   000000 116000 xsym               CMPQ    XSL_SOCK$$
         2 000351   000701 600000 2                  TZE     s:3627

      999     3567    2           IF DATABUF.FLAGS.BUSY THEN EXIT;

   3567  2 000352   200014 470500                    LDP0    BUF$,,AUTO
         2 000353   000001 234100                    SZN     1,,PR0
         2 000354   000701 604000 2                  TMI     s:3627

     1000     3568    2           IF NOT SOCK.FLAGS.OOBINLINE THEN

   3568  2 000355   200022 471500                    LDP1    SOCK$,,AUTO
         2 000356   100001 236100                    LDQ     1,,PR1
         2 000357   000002 316003                    CANQ    2,DU
         2 000360   000371 601000 2                  TNZ     s:3570

     1001     3569    2               IF ENTRYFLAG ~= %READ AND DATABUF.FLAGS.OOB ~= BFLAGS.OOB THEN EXIT;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:106  

   3569  2 000361   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000362   000002 115007                    CMPA    2,DL
         2 000363   000371 600000 2                  TZE     s:3570
         2 000364   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000365   000100 066500                    CMPB    filb='0'B
         2 000366   000001 010001                    BDSC    1,,PR0                   by=0,bit=1,n=1
         2 000367   300000 700001                    BDSC    0,,PR3                   by=3,bit=8,n=1
         2 000370   000701 601000 2                  TNZ     s:3627

     1002     3570    2           IF DATABUF.KEY(2) ~= 255 AND DATABUF.KEY(3) ~= 255 THEN

   3570  2 000371   000002 236100                    LDQ     2,,PR0
         2 000372   777000 376007                    ANQ     -512,DL
         2 000373   377000 116007                    CMPQ    130560,DL
         2 000374   000402 600000 2                  TZE     s:3572
         2 000375   000002 236100                    LDQ     2,,PR0
         2 000376   000777 376007                    ANQ     511,DL
         2 000377   000377 116007                    CMPQ    255,DL
         2 000400   000402 600000 2                  TZE     s:3572

     1003     3571    2               SCANNED = SCANNED + 1;  /* only count successful bufs */

   3571  2 000401   200016 054100                    AOS     SCANNED,,AUTO

     1004     3572    2           IF DATABUF.LEN = 0 AND DATABUF.KEY(2) = 0 AND DATABUF.KEY(3) = 0 AND

   3572  2 000402   000000 720100                    LXL0    0,,PR0
         2 000403   000422 601000 2                  TNZ     s:3575
         2 000404   000002 236100                    LDQ     2,,PR0
         2 000405   777000 316007                    CANQ    -512,DL
         2 000406   000422 601000 2                  TNZ     s:3575
         2 000407   000777 316007                    CANQ    511,DL
         2 000410   000422 601000 2                  TNZ     s:3575
         2 000411   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000412   000002 115007                    CMPA    2,DL
         2 000413   000420 600000 2                  TZE     s:3574
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:107  
         2 000414   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000415   300000 236100                    LDQ     0,,PR3
         2 000416   000002 316007                    CANQ    2,DL
         2 000417   000422 601000 2                  TNZ     s:3575

     1005     3573    2             ( ENTRYFLAG = %READ OR NOT BFLAGS.PEEK) THEN
     1006     3574    2               SOCK.FLAGS.RECVSHUT = '1'B;  /* no more data to read */

   3574  2 000420   100000 236003                    LDQ     32768,DU
         2 000421   100001 256100                    ORSQ    1,,PR1

     1007     3575    2           NUM = MINIMUM( LEFT, DATABUF.LEN);

   3575  2 000422   000000 236100                    LDQ     0,,PR0
         2 000423   777777 376007                    ANQ     -1,DL
         2 000424   000427 604000 2                  TMI     s:3575+5
         2 000425   200012 116100                    CMPQ    LEFT,,AUTO
         2 000426   000430 604400 2                  TMOZ    s:3575+6
         2 000427   200012 236100                    LDQ     LEFT,,AUTO
         2 000430   200013 756100                    STQ     NUM,,AUTO

     1008     3576    2           IF NUM > 0 THEN

   3576  2 000431   000000 116003                    CMPQ    0,DU
         2 000432   000446 604400 2                  TMOZ    s:3578

     1009     3577    2               SUBSTR( BUF, RESULT, NUM) = PINCRC( BUF$, DATABUF.START)->B$CHARS;

   3577  2 000433   200006 473500                    LDP3    @LEN,,AUTO
         2 000434   300000 720100                    LXL0    0,,PR3
         2 000435   200003 474500                    LDP4    @RESULT,,AUTO
         2 000436   400000 235100                    LDA     0,,PR4
         2 000437   000000 236100                    LDQ     0,,PR0
         2 000440   000022 772000                    QRL     18
         2 000441   200013 721100                    LXL1    NUM,,AUTO
         2 000442   200005 475500                    LDP5    @BUF,,AUTO
         2 000443   040145 100546                    MLR     fill='040'O
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:108  
         2 000444   000000 000011                    ADSC9   0,Q,PR0                  cn=0,n=*X1
         2 000445   500000 000011                    ADSC9   0,A,PR5                  cn=0,n=*X1

     1010     3578    2           LEFT = LEFT - NUM;

   3578  2 000446   200012 236100                    LDQ     LEFT,,AUTO
         2 000447   200013 136100                    SBLQ    NUM,,AUTO
         2 000450   200012 756100                    STQ     LEFT,,AUTO

     1011     3579    2           RESULT = RESULT + NUM;

   3579  2 000451   200003 473500                    LDP3    @RESULT,,AUTO
         2 000452   300000 236100                    LDQ     0,,PR3
         2 000453   200013 036100                    ADLQ    NUM,,AUTO
         2 000454   300000 756100                    STQ     0,,PR3

     1012     3580    3           IF ENTRYFLAG = %READ OR NOT BFLAGS.PEEK THEN DO;

   3580  2 000455   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000456   000002 115007                    CMPA    2,DL
         2 000457   000464 600000 2                  TZE     s:3581
         2 000460   200007 474500                    LDP4    @FLAGS,,AUTO
         2 000461   400000 236100                    LDQ     0,,PR4
         2 000462   000002 316007                    CANQ    2,DL
         2 000463   000476 601000 2                  TNZ     s:3584

     1013     3581    3               DATABUF.START = DATABUF.START + NUM;

   3581  2 000464   000000 236100                    LDQ     0,,PR0
         2 000465   000022 772000                    QRL     18
         2 000466   200013 036100                    ADLQ    NUM,,AUTO
         2 000467   000000 620006                    EAX0    0,QL
         2 000470   000000 740100                    STX0    0,,PR0

     1014     3582    3               DATABUF.LEN = DATABUF.LEN - NUM;

   3582  2 000471   000000 236100                    LDQ     0,,PR0
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:109  
         2 000472   777777 376007                    ANQ     -1,DL
         2 000473   200013 136100                    SBLQ    NUM,,AUTO
         2 000474   000000 621006                    EAX1    0,QL
         2 000475   000000 441100                    SXL1    0,,PR0

     1015     3583    3               END;

     1016     3584    2           TMP$ = PINCRW( XSL_SOCK$$, DATABUF.NXT);

   3584  2 000476   000001 720100                    LXL0    1,,PR0
         2 000477   000000 636010                    EAQ     0,X0
         2 000500   000000 036000 xsym               ADLQ    XSL_SOCK$$
         2 000501   200015 756100                    STQ     TMP$,,AUTO

     1017     3585    2           IF ENTRYFLAG = %RECVFROM THEN

   3585  2 000502   000000 115003                    CMPA    0,DU
         2 000503   000535 601000 2                  TNZ     s:3594

     1018     3586    3               IF DATABUF.KEY(1) = %RECVFROMRSP THEN DO;

   3586  2 000504   000002 236100                    LDQ     2,,PR0
         2 000505   000777 376003                    ANQ     511,DU
         2 000506   000020 116003                    CMPQ    16,DU
         2 000507   000526 601000 2                  TNZ     s:3591

     1019     3587    3                   FROMLEN = ADDR( DATABUF.KEY)->XSL$RECVFROMRSP.FROMLEN;

   3587  2 000510   000003 236100                    LDQ     3,,PR0
         2 000511   000022 736000                    QLS     18
         2 000512   000022 732000                    QRS     18
         2 000513   200011 474500                    LDP4    @FROMLEN,,AUTO
         2 000514   400000 756100                    STQ     0,,PR4

     1020     3588    3                   CALL XSL$NTOHADDR( FROM, ADDR( DATABUF.KEY)->XSL$RECVFROMRSP.NAME);

   3588  2 000515   200014 236100                    LDQ     BUF$,,AUTO
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:110  
         2 000516   000004 036003                    ADLQ    4,DU
         2 000517   200010 235100                    LDA     @FROM,,AUTO
         2 000520   200024 757100                    STAQ    SOCK$+2,,AUTO
         2 000521   200024 630500                    EPPR0   SOCK$+2,,AUTO
         2 000522   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000523   000000 701000 xent               TSX1    XSL$NTOHADDR
         2 000524   000000 011000                    NOP     0

     1021     3589    3                   END;

   3589  2 000525   000535 710000 2                  TRA     s:3594

     1022     3590    3               ELSE DO;

     1023     3591    3                   FROMLEN = LENGTHC( FROM);

   3591  2 000526   000024 235007                    LDA     20,DL
         2 000527   200011 474500                    LDP4    @FROMLEN,,AUTO
         2 000530   400000 755100                    STA     0,,PR4

     1024     3592    3                   FROM = SOCK.PEERNAME;

   3592  2 000531   200010 475500                    LDP5    @FROM,,AUTO
         2 000532   000100 100500                    MLR     fill='000'O
         2 000533   100011 000024                    ADSC9   9,,PR1                   cn=0,n=20
         2 000534   500000 000024                    ADSC9   0,,PR5                   cn=0,n=20

     1025     3593    3                   END;

     1026     3594    3           IF SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;

   3594  2 000535   200022 470500                    LDP0    SOCK$,,AUTO
         2 000536   000000 236100                    LDQ     0,,PR0
         2 000537   000777 376003                    ANQ     511,DU
         2 000540   000002 116003                    CMPQ    2,DU
         2 000541   000574 601000 2                  TNZ     s:3602

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:111  
     1027     3595    3               IF DATABUF.FLAGS.MORE THEN

   3595  2 000542   200014 471500                    LDP1    BUF$,,AUTO
         2 000543   100001 236100                    LDQ     1,,PR1
         2 000544   100000 316003                    CANQ    32768,DU
         2 000545   000550 600000 2                  TZE     s:3597

     1028     3596    3                   MORE = '1'B;

   3596  2 000546   400000 236003                    LDQ     -131072,DU
         2 000547   200021 756100                    STQ     MORE,,AUTO

     1029     3597    3               IF NOT MORE OR ( ENTRYFLAG ~= %READ AND BFLAGS.PEEK) THEN

   3597  2 000550   200021 234100                    SZN     MORE,,AUTO
         2 000551   000561 605000 2                  TPL     s:3598
         2 000552   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000553   000002 115007                    CMPA    2,DL
         2 000554   000563 600000 2                  TZE     s:3599
         2 000555   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000556   300000 236100                    LDQ     0,,PR3
         2 000557   000002 316007                    CANQ    2,DL
         2 000560   000563 600000 2                  TZE     s:3599

     1030     3598    3                   TMP$ = XSL_SOCK$$;  /* halt scan with this buffer */

   3598  2 000561   000000 236000 xsym               LDQ     XSL_SOCK$$
         2 000562   200015 756100                    STQ     TMP$,,AUTO

     1031     3599    3               IF ENTRYFLAG = %READ OR NOT BFLAGS.PEEK THEN

   3599  2 000563   200020 235100                    LDA     ENTRYFLAG,,AUTO
         2 000564   000002 115007                    CMPA    2,DL
         2 000565   000572 600000 2                  TZE     s:3600
         2 000566   200007 473500                    LDP3    @FLAGS,,AUTO
         2 000567   300000 236100                    LDQ     0,,PR3
         2 000570   000002 316007                    CANQ    2,DL
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:112  
         2 000571   000574 601000 2                  TNZ     s:3602

     1032     3600    3                   DATABUF.LEN = 0;  /* discard remainder of datagram */

   3600  2 000572   000000 220003                    LDX0    0,DU
         2 000573   100000 440100                    SXL0    0,,PR1

     1033     3601    3               END;

     1034     3602    3           IF DATABUF.LEN = 0 THEN DO INHIBIT;

   3602  2 000574   200014 471500                    LDP1    BUF$,,AUTO
         2 000575   100000 720100                    LXL0    0,,PR1
         2 000576   000654 601000 2                  TNZ     s:3618

     1035     3603    3               IF DATABUF.KEY(2) ~= 255 AND DATABUF.KEY(3) ~= 255 THEN

   3603  2 000577   100002 236300                    LDQ   ! 2,,PR1
         2 000600   777000 376207                    ANQ   ! -512,DL
         2 000601   377000 116207                    CMPQ  ! 130560,DL
         2 000602   000632 600200 2                  TZE   ! s:3614
         2 000603   100002 236300                    LDQ   ! 2,,PR1
         2 000604   000777 376207                    ANQ   ! 511,DL
         2 000605   000377 116207                    CMPQ  ! 255,DL
         2 000606   000632 600200 2                  TZE   ! s:3614

     1036     3604    4                   IF DATABUF.FLAGS.OOB AND NOT SOCK.FLAGS.OOBINLINE THEN DO;

   3604  2 000607   100001 236300                    LDQ   ! 1,,PR1
         2 000610   200000 316203                    CANQ  ! 65536,DU
         2 000611   000624 600200 2                  TZE   ! s:3610
         2 000612   000001 236300                    LDQ   ! 1,,PR0
         2 000613   000002 316203                    CANQ  ! 2,DU
         2 000614   000624 601200 2                  TNZ   ! s:3610

     1037     3605    4                       SOCK.OOB# = SOCK.OOB# - 1;

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:113  
   3605  2 000615   000021 221300                    LDX1  ! 17,,PR0
         2 000616   777777 622211                    EAX2  ! -1,X1
         2 000617   000021 742300                    STX2  ! 17,,PR0

     1038     3606    4                       IF SOCK.OOB# = 0 THEN

   3606  2 000620   000632 601200 2                  TNZ   ! s:3614

     1039     3607    4                           SOCK.FLAGS.SELEXCEP = '0'B;

   3607  2 000621   000004 236200 3                  LDQ   ! 4
         2 000622   000001 356300                    ANSQ  ! 1,,PR0

     1040     3608    4                       END;

   3608  2 000623   000632 710200 2                  TRA   ! s:3614

     1041     3609    4                   ELSE DO;

     1042     3610    4                       SOCK.DAT# = SOCK.DAT# - 1;

   3610  2 000624   000021 721300                    LXL1  ! 17,,PR0
         2 000625   777777 622211                    EAX2  ! -1,X1
         2 000626   000021 442300                    SXL2  ! 17,,PR0

     1043     3611    4                       IF SOCK.DAT# = 0 THEN

   3611  2 000627   000632 601200 2                  TNZ   ! s:3614

     1044     3612    4                           SOCK.FLAGS.SELREAD = '0'B;

   3612  2 000630   000005 236200 3                  LDQ   ! 5
         2 000631   000001 356300                    ANSQ  ! 1,,PR0

     1045     3613    4                       END;

     1046     3614    3               SOCK.FLAGS.REUSEBUF = ~SOCK.FLAGS.RECVSHUT;
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:114  

   3614  2 000632   000001 236300                    LDQ   ! 1,,PR0
         2 000633   000002 736200                    QLS   ! 2
         2 000634   400000 376203                    ANQ   ! -131072,DU
         2 000635   400000 676203                    ERQ   ! -131072,DU
         2 000636   000017 772200                    QRL   ! 15
         2 000637   000001 676300                    ERQ   ! 1,,PR0
         2 000640   000004 376203                    ANQ   ! 4,DU
         2 000641   000001 656300                    ERSQ  ! 1,,PR0

     1047     3615    3               SOCK.BUFPND# = SOCK.BUFPND# - 1;

   3615  2 000642   000017 720300                    LXL0  ! 15,,PR0
         2 000643   777777 621210                    EAX1  ! -1,X0
         2 000644   000017 441300                    SXL1  ! 15,,PR0

     1048     3616    3               CALL XSL$RELBUF( SOCK, DATABUF);

   3616  2 000645   200014 236300                    LDQ   ! BUF$,,AUTO
         2 000646   200022 235300                    LDA   ! SOCK$,,AUTO
         2 000647   200024 757300                    STAQ  ! SOCK$+2,,AUTO
         2 000650   200024 630700                    EPPR0 ! SOCK$+2,,AUTO
         2 000651   000020 631600 xsym               EPPR1 ! B_VECTNIL+16
         2 000652   000000 701200 xent               TSX1  ! XSL$RELBUF
         2 000653   000000 011200                    NOP   ! 0

     1049     3617    3               END;

     1050     3618    2           IF SOCK.FLAGS.RECVSHUT OR LEFT = 0 THEN EXIT;

   3618  2 000654   200022 470500                    LDP0    SOCK$,,AUTO
         2 000655   000001 236100                    LDQ     1,,PR0
         2 000656   100000 316003                    CANQ    32768,DU
         2 000657   000701 601000 2                  TNZ     s:3627
         2 000660   200012 235100                    LDA     LEFT,,AUTO
         2 000661   000701 600000 2                  TZE     s:3627

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:115  
     1051     3619    3           IF MORE THEN DO INHIBIT;

   3619  2 000662   200021 234100                    SZN     MORE,,AUTO
         2 000663   000675 605000 2                  TPL     s:3625

     1052     3620    4               DO WHILE( SOCK.DAT# = 0);

   3620  2 000664   000021 720300                    LXL0  ! 17,,PR0
         2 000665   000674 601200 2                  TNZ   ! s:3623

     1053     3621    4                   CALL M$WAIT( XSL_WAIT1DAY);

   3621  2 000666   000000 630600 xsym               EPPR0 ! XSL_WAIT1DAY
         2 000667   020006 713600                    CLIMB ! 8198
         2 000670   400400 401760                    pmme    nvectors=2

     1054     3622    4                   END;

   3622  2 000671   200022 470700                    LDP0  ! SOCK$,,AUTO
         2 000672   000021 720300                    LXL0  ! 17,,PR0
         2 000673   000666 600200 2                  TZE   ! s:3621

     1055     3623    3               GOTO RESCAN;

   3623  2 000674   000342 710200 2                  TRA   ! RESCAN

     1056     3624    3               END;

     1057     3625    2           BUF$ = TMP$;

   3625  2 000675   200015 236100                    LDQ     TMP$,,AUTO
         2 000676   200014 756100                    STQ     BUF$,,AUTO

     1058     3626    2           END;

   3626  2 000677   000000 116000 xsym               CMPQ    XSL_SOCK$$
         2 000700   000352 601000 2                  TNZ     s:3567
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:116  

     1059     3627    2       IF RESULT = 0 THEN DO;

   3627  2 000701   200003 470500                    LDP0    @RESULT,,AUTO
         2 000702   000000 235100                    LDA     0,,PR0
         2 000703   000744 601000 2                  TNZ     s:3644

     1060     3628    2           IF SCANNED ~= 0 THEN

   3628  2 000704   200016 236100                    LDQ     SCANNED,,AUTO
         2 000705   000277 601000 2                  TNZ     SUCCESS

     1061     3629    2               GOTO SUCCESS;
     1062     3630    3           IF SOCK.FLAGS.BLOCKING THEN DO INHIBIT;

   3630  2 000706   200022 471500                    LDP1    SOCK$,,AUTO
         2 000707   100001 430100                    FSZN    1,,PR1
         2 000710   000741 605000 2                  TPL     s:3640

     1063     3631    3               IF BUFPND# ~= SOCK.BUFPND# THEN GOTO SCANBUFS;

   3631  2 000711   100017 236300                    LDQ   ! 15,,PR1
         2 000712   777777 376207                    ANQ   ! -1,DL
         2 000713   200017 116300                    CMPQ  ! BUFPND#,,AUTO
         2 000714   000331 601200 2                  TNZ   ! SCANBUFS

     1064     3632    3               XSL_UETIME = 0;

   3632  2 000715   000000 450200 xsym               STZ   ! XSL_UETIME

     1065     3633    4               DO WHILE( XSL_UETIME = 0);

   3633  2 000716   000000 235200 xsym               LDA   ! XSL_UETIME
         2 000717   000737 601200 2                  TNZ   ! s:3637

     1066     3634    4                   CALL XSL$EVLOG( 'WT', ADDR(SOCK));

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:117  
   3634  2 000720   200022 236300                    LDQ   ! SOCK$,,AUTO
         2 000721   200024 756300                    STQ   ! SOCK$+2,,AUTO
         2 000722   200024 630700                    EPPR0 ! SOCK$+2,,AUTO
         2 000723   200027 450700                    STP0  ! SOCK$+5,,AUTO
         2 000724   000006 236200 3                  LDQ   ! 6
         2 000725   200026 756300                    STQ   ! SOCK$+4,,AUTO
         2 000726   200026 630700                    EPPR0 ! SOCK$+4,,AUTO
         2 000727   000020 631600 xsym               EPPR1 ! B_VECTNIL+16
         2 000730   000000 701200 xent               TSX1  ! XSL$EVLOG
         2 000731   000000 011200                    NOP   ! 0

     1067     3635    4                   CALL M$WAIT( XSL_WAIT1DAY);

   3635  2 000732   000000 630600 xsym               EPPR0 ! XSL_WAIT1DAY
         2 000733   020006 713600                    CLIMB ! 8198
         2 000734   400400 401760                    pmme    nvectors=2

     1068     3636    4                   END;

   3636  2 000735   000000 235200 xsym               LDA   ! XSL_UETIME
         2 000736   000720 600200 2                  TZE   ! s:3634

     1069     3637    3               GOTO SCANBUFS;

   3637  2 000737   000331 710200 2                  TRA   ! SCANBUFS

     1070     3638    3               END;

   3638  2 000740   000744 710000 2                  TRA     s:3644

     1071     3639    3           ELSE DO;

     1072     3640    3               XSL_ERRNO = %E$WOULDBLOCK;

   3640  2 000741   000136 235007                    LDA     94,DL
         2 000742   000000 755000 xsym               STA     XSL_ERRNO

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:118  
     1073     3641    3               GOTO BAILOUT;

   3641  2 000743   000162 710000 2                  TRA     BAILOUT

     1074     3642    3               END;
     1075     3643    2           END;
     1076     3644    1       GOTO SUCCESS;

   3644  2 000744   000277 710000 2                  TRA     SUCCESS

(unnamed)
 Sect OctLoc
   1     000   127124 040040                                                    WT

(unnamed)
 Sect OctLoc
   3     000   000000 006000   000012 006000   000010 006000   000000 006003    ................
   3     004   777767 777777   777737 777777   000000 006000                    ............
     1077     3645
     1078     3646    1   END XSL$RECVFROM;
     1079     3647        %EOD;

PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:119  
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$RECVFROM.
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:120  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     5-0-0/w PTR         r     1 @BUF                       7-0-0/w PTR         r     1 @FLAGS
    10-0-0/w PTR         r     1 @FROM                     11-0-0/w PTR         r     1 @FROMLEN
     6-0-0/w PTR         r     1 @LEN                       3-0-0/w PTR         r     1 @RESULT
     4-0-0/w PTR         r     1 @SOCK#                    *0-0-0/w STRC        r     1 BFLAGS
    *0-0-0/c ACHR        r     1 BUF                       14-0-0/w PTR         r     1 BUF$
    17-0-0/w SBIN        r     1 BUFPND#                   20-0-0/w SBIN        r     1 ENTRYFLAG
    *0-0-0/w UBIN        r     1 FLAGS                     *0-0-0/w STRC(180)   r     1 FROM
    *0-0-0/w SBIN        r     1 FROMLEN                   12-0-0/w SBIN        r     1 LEFT
    *0-0-0/w SBIN        r     1 LEN                       21-0-0/b BIT         r     1 MORE
    13-0-0/w SBIN        r     1 NUM                       *0-0-0/w SBIN        r     1 RESULT
    16-0-0/w SBIN        r     1 SCANNED                   *0-0-0/w SBIN        r     1 SOCK#
    22-0-0/w PTR         r     1 SOCK$                     15-0-0/w PTR         r     1 TMP$

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w SBIN        r     1 XSL_ERRNO                  0-0-0/w PTR         r     1 XSL_KEYBUF$
     0-0-0/w STRC(72)    r     1 XSL_RECVFROMRQS            0-0-0/w STRC(54)    r     1 XSL_RECVRQS
     0-0-0/w PTR         r     1 XSL_SOCK$                  0-0-0/w PTR         r     1 XSL_SOCK$$
     0-0-0/w SBIN        r     1 XSL_UETIME                 0-0-0/d STRC(216)   r     1 XSL_WAIT1DAY

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/c ACHR        r     1 B$CHARS                    0-0-0/w STRC(360)   r     1 DATABUF
     0-0-0/d ASTR(3528)  r     1 F$DCB                      0-0-0/w STRC(720)   r     1 SOCK
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:121  
     0-0-0/w STRC(72)    r     1 XSL$RECVFROMRQS            0-0-0/w STRC(216)   r     1 XSL$RECVFROMRSP
     0-0-0/w STRC(54)    r     1 XSL$RECVRQS                0-0-0/w STRC(54)    r     1 XSL$RECVRSP


   Procedure XSL$RECVFROM requires 485 words for executable code.
   Procedure XSL$RECVFROM requires 24 words of local(AUTO) storage.
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:122  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:123  
          MINI XREF LISTING

B$CHARS
      3437**DCL      3577>>ASSIGN
BAILOUT
      3521**LABEL    3478--CALLALT  3492--CALLALT  3497--GOTO     3537--GOTO     3544--GOTO     3641--GOTO
BFLAGS.OOB
      3453**DCL      3569>>IF
BFLAGS.PEEK
      3452**DCL      3572>>IF       3580>>IF       3597>>IF       3599>>IF
BUF
      3444**DCL       319--PROC     3464--ENTRY    3469--ENTRY    3474--ENTRY    3481--ENTRY    3486--ENTRY
      3517<>CALL     3541<>CALL     3577<<ASSIGN
BUF$
      3440**DCL      2031--IMP-PTR  3565<<ASSIGN   3566>>DOWHILE  3567>>IF       3569>>IF       3570>>IF
      3570>>IF       3572>>IF       3572>>IF       3572>>IF       3575>>ASSIGN   3577>>ASSIGN   3577>>ASSIGN
      3581>>ASSIGN   3581>>ASSIGN   3582>>ASSIGN   3582>>ASSIGN   3584>>ASSIGN   3586>>IF       3587>>ASSIGN
      3588>>CALL     3595>>IF       3600>>ASSIGN   3602>>IF       3603>>IF       3603>>IF       3604>>IF
      3616>>CALL     3625<<ASSIGN
BUFPND#
      3443**DCL      3560<<ASSIGN   3631>>IF
COMMONDCBN
      3492**LABEL    3462--GOTO     3472--GOTO     3484--GOTO
COMMONSOCK
      3478**LABEL    3467--GOTO     3489--GOTO
DATABUF
      2031**DCL      3616<>CALL
DATABUF.FLAGS.BUSY
      2041**DCL      3567>>IF
DATABUF.FLAGS.MORE
      2043**DCL      3595>>IF
DATABUF.FLAGS.OOB
      2042**DCL      3569>>IF       3604>>IF
DATABUF.KEY
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:124  
      2045**DCL      3570>>IF       3570>>IF       3572>>IF       3572>>IF       3586>>IF       3587--ASSIGN
      3588--CALL     3603>>IF       3603>>IF
DATABUF.LEN
      2039**DCL      3572>>IF       3575>>ASSIGN   3582<<ASSIGN   3582>>ASSIGN   3600<<ASSIGN   3602>>IF
DATABUF.NXT
      2044**DCL      3584>>ASSIGN
DATABUF.START
      2038**DCL      3577>>ASSIGN   3581<<ASSIGN   3581>>ASSIGN
ENTRYFLAG
      3445**DCL      3461<<ASSIGN   3466<<ASSIGN   3471<<ASSIGN   3476<<ASSIGN   3483<<ASSIGN   3488<<ASSIGN
      3510>>DOCASE   3569>>IF       3572>>IF       3580>>IF       3585>>IF       3597>>IF       3599>>IF
F$DCB.ACTPOS
       434**DCL       434--REDEF
F$DCB.ARS#
       408**DCL       408--REDEF
F$DCB.ATTR
       427**DCL       428--REDEF
F$DCB.BORROW
       442**DCL       442--REDEF     442--REDEF     442--REDEF
F$DCB.DCBNAME.L
       456**DCL       456--IMP-SIZ
F$DCB.EOMCHAR#
       412**DCL       412--REDEF
F$DCB.FCN.CNT
       447**DCL      3551>>DOWHILE
F$DCB.FLDID
       437**DCL       437--REDEF
F$DCB.FORM$
       431**DCL       431--REDEF
F$DCB.FSECT
       447**DCL       447--REDEF
F$DCB.FSN#
       424**DCL       424--REDEF     424--REDEF     425--REDEF
F$DCB.HEADER$
       430**DCL       430--REDEF
F$DCB.IXTNSIZE#
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:125  
       428**DCL       428--REDEF
F$DCB.LASTSTA$
       417**DCL       417--REDEF
F$DCB.LVL
       443**DCL       443--REDEF
F$DCB.NAME#.C
       418**DCL       418--REDEF
F$DCB.NOEOF
       440**DCL       440--REDEF
F$DCB.NRECS#
       429**DCL       429--REDEF
F$DCB.NRECX
       448**DCL       448--REDEF
F$DCB.OHDR
       440**DCL       440--REDEF
F$DCB.ORG#
       423**DCL       423--REDEF
F$DCB.PRECNO
       446**DCL       446--REDEF
F$DCB.RCSZ
       452**DCL       452--REDEF
F$DCB.RES#
       419**DCL       419--REDEF
F$DCB.SETX
       431**DCL       431--REDEF
F$DCB.TAB$
       431**DCL       431--REDEF
F$DCB.TDA
       445**DCL       446--REDEF
F$DCB.WSN#
       419**DCL       419--REDEF
FLAGS
      3449**DCL       319--PROC     3450--REDEF    3464--ENTRY    3469--ENTRY    3474--ENTRY    3513>>ASSIGN
      3529>>ASSIGN
FROM
      1508**DCL       319--PROC     3464--ENTRY    3525<>CALL     3588<>CALL     3591--ASSIGN   3592<<ASSIGN
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:126  
FROMLEN
      3454**DCL       319--PROC     3464--ENTRY    3515>>ASSIGN   3524<<ASSIGN   3587<<ASSIGN   3591<<ASSIGN
LATER
      3494**LABEL    3479--GOTO
LEFT
      3438**DCL      3562<<ASSIGN   3575>>ASSIGN   3578<<ASSIGN   3578>>ASSIGN   3618>>IF
LEN
      3455**DCL       319--PROC     3444--IMP-SIZ  3464--ENTRY    3469--ENTRY    3474--ENTRY    3481--ENTRY
      3486--ENTRY    3514>>ASSIGN   3517<>CALL     3517>>CALL     3539>>ASSIGN   3541<>CALL     3541>>CALL
      3562>>ASSIGN   3577>>ASSIGN
M$WAIT
       387**DCL-ENT  3621--CALL     3635--CALL
MORE
      3456**DCL      3564<<ASSIGN   3596<<ASSIGN   3597>>IF       3619>>IF
NOWAIT
      3551**LABEL    3504--GOTO     3508--GOTO     3555--EXIT
NUM
      3439**DCL      3437--IMP-SIZ  3575<<ASSIGN   3576>>IF       3577>>ASSIGN   3577>>ASSIGN   3578>>ASSIGN
      3579>>ASSIGN   3581>>ASSIGN   3582>>ASSIGN
READ_COMMON
      3535**LABEL    3530--GOTO
RESCAN
      3564**LABEL    3623--GOTO
RESULT
      3457**DCL       319--PROC     3464--ENTRY    3469--ENTRY    3474--ENTRY    3481--ENTRY    3486--ENTRY
      3500<<ASSIGN   3521<<ASSIGN   3526<<ASSIGN   3546<<ASSIGN   3561<<ASSIGN   3577>>ASSIGN   3579<<ASSIGN
      3579>>ASSIGN   3627>>IF
SCANBUFS
      3560**LABEL    3631--GOTO     3637--GOTO
SCANNED
      3442**DCL      3558<<ASSIGN   3571<<ASSIGN   3571>>ASSIGN   3628>>IF
SOCK
      1855**DCL      3506<>CALL     3516<>CALL     3517<>CALL     3540<>CALL     3541<>CALL     3553<>CALL
      3616<>CALL     3634--CALL
SOCK.BUFHD
      1969**DCL      3505>>IF       3565>>ASSIGN
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:127  
SOCK.BUFPND#
      1972**DCL      3551>>DOWHILE  3560>>ASSIGN   3615<<ASSIGN   3615>>ASSIGN   3631>>IF
SOCK.DAT#
      1976**DCL      3610<<ASSIGN   3610>>ASSIGN   3611>>IF       3620>>DOWHILE
SOCK.DCB#
      1888**DCL      3551--DOWHILE
SOCK.FLAGS.BLOCKING
      1874**DCL      3630>>IF
SOCK.FLAGS.CONNECT
      1869**DCL      3535>>IF
SOCK.FLAGS.OOBINLINE
      1882**DCL      3568>>IF       3604>>IF
SOCK.FLAGS.RECVSHUT
      1868**DCL      3499>>IF       3574<<ASSIGN   3614>>ASSIGN   3618>>IF
SOCK.FLAGS.REUSEBUF
      1881**DCL      3614<<ASSIGN
SOCK.FLAGS.SELEXCEP
      1880**DCL      3607<<ASSIGN
SOCK.FLAGS.SELREAD
      1878**DCL      3503>>IF       3507>>IF       3612<<ASSIGN
SOCK.FLAGS.SOCKET
      1873**DCL      3495>>IF
SOCK.MAXBUF
      1973**DCL      3551>>DOWHILE
SOCK.MAXRDS
      1974**DCL      3503>>IF       3551>>DOWHILE
SOCK.NBACCEPT_SOCK$
      1977**DCL      1978--REDEF
SOCK.OOB#
      1975**DCL      3605<<ASSIGN   3605>>ASSIGN   3606>>IF
SOCK.PEERNAME
      1948**DCL      3592>>ASSIGN
SOCK.TYPE
      1862**DCL      3594>>IF
SOCK#
      3458**DCL       319--PROC     3464--ENTRY    3469--ENTRY    3474--ENTRY    3478<>CALL     3481--ENTRY
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:128  
      3486--ENTRY    3492<>CALL
SOCK$
      3459**DCL      1855--IMP-PTR  3494<<ASSIGN   3495>>IF       3499>>IF       3503>>IF       3503>>IF
      3505>>IF       3506>>CALL     3507>>IF       3516>>CALL     3517>>CALL     3535>>IF       3540>>CALL
      3541>>CALL     3551>>DOWHILE  3551>>DOWHILE  3551>>DOWHILE  3551>>DOWHILE  3553>>CALL     3560>>ASSIGN
      3565>>ASSIGN   3568>>IF       3574>>ASSIGN   3592>>ASSIGN   3594>>IF       3604>>IF       3605>>ASSIGN
      3605>>ASSIGN   3606>>IF       3607>>ASSIGN   3610>>ASSIGN   3610>>ASSIGN   3611>>IF       3612>>ASSIGN
      3614>>ASSIGN   3614>>ASSIGN   3615>>ASSIGN   3615>>ASSIGN   3616>>CALL     3618>>IF       3620>>DOWHILE
      3630>>IF       3631>>IF       3634>>CALL
SUCCESS
      3549**LABEL    3501--GOTO     3629--GOTO     3644--GOTO
TMP$
      3441**DCL      3584<<ASSIGN   3598<<ASSIGN   3625>>ASSIGN
XSL$CL_CANCEL
      3423**DCL-ENT  3506--CALL
XSL$CL_READ
      3421**DCL-ENT  3517--CALL     3541--CALL
XSL$CL_WRITE
      3422**DCL-ENT  3516--CALL     3540--CALL
XSL$DCBNPTR
      3428**DCL-ENT  3492--CALL
XSL$EVLOG
      3429**DCL-ENT  3634--CALL
XSL$GETBUF
      3424**DCL-ENT  3553--CALL
XSL$NTOHADDR
      3426**DCL-ENT  3525--CALL     3588--CALL
XSL$RECVFROMRQS
      3355**DCL      3512<<ASSIGN   3516--CALL
XSL$RECVFROMRQS.FLAGS
      3362**DCL      3513<<ASSIGN
XSL$RECVFROMRQS.FROMLEN
      3364**DCL      3515<<ASSIGN
XSL$RECVFROMRQS.LEN
      3363**DCL      3514<<ASSIGN
XSL$RECVFROMRSP.ERRNO
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:129  
      3391**DCL      3519>>ASSIGN
XSL$RECVFROMRSP.FROMLEN
      3392**DCL      3524>>ASSIGN   3587>>ASSIGN
XSL$RECVFROMRSP.NAME
      3412**DCL      3525<>CALL     3588<>CALL
XSL$RECVFROMRSP.RESULT
      3390**DCL      3518>>IF       3526>>ASSIGN
XSL$RECVRQS
      3273**DCL      3528<<ASSIGN   3532<<ASSIGN   3540--CALL
XSL$RECVRQS.FLAGS
      3280**DCL      3529<<ASSIGN   3533<<ASSIGN
XSL$RECVRQS.LEN
      3281**DCL      3539<<ASSIGN
XSL$RECVRSP.ERRNO
      3308**DCL      3543>>ASSIGN
XSL$RECVRSP.RESULT
      3307**DCL      3542>>IF       3546>>ASSIGN
XSL$RELBUF
      3425**DCL-ENT  3616--CALL
XSL$SOCKPTR
      3427**DCL-ENT  3478--CALL
XSL_ERRNO
      3431**DCL      3432--REDEF    3496<<ASSIGN   3519<<ASSIGN   3536<<ASSIGN   3543<<ASSIGN   3640<<ASSIGN
XSL_KEYBUF$
      3433**DCL      3273--IMP-PTR  3300--IMP-PTR  3355--IMP-PTR  3383--IMP-PTR  3512>>ASSIGN   3513>>ASSIGN
      3514>>ASSIGN   3515>>ASSIGN   3518>>IF       3519>>ASSIGN   3524>>ASSIGN   3525>>CALL     3526>>ASSIGN
      3528>>ASSIGN   3529>>ASSIGN   3532>>ASSIGN   3533>>ASSIGN   3539>>ASSIGN   3542>>IF       3543>>ASSIGN
      3546>>ASSIGN
XSL_RECVFROMRQS
      3327**DCL      3512>>ASSIGN
XSL_RECVRQS
      3246**DCL      3528>>ASSIGN   3532>>ASSIGN
XSL_SOCK$
      3432**DCL      3478<>CALL     3492<>CALL     3494>>ASSIGN
XSL_SOCK$$
      3434**DCL      1998--IMP-PTR  3565>>ASSIGN   3566>>DOWHILE  3584>>ASSIGN   3598>>ASSIGN
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:130  
XSL_UETIME
      3435**DCL      3632<<ASSIGN   3633>>DOWHILE
XSL_WAIT1DAY
       469**DCL      3621<>CALL     3635<>CALL
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:131  
              *** CROSS REFERENCE LISTING ***
    **     DENOTES     IDENTIFIER DEFINITION
    <<                 IDENTIFIER'S VALUE SET
    >>                 IDENTIFIER'S VALUE USED
    <>                 IDENTIFIER SET AND/OR USED
    --                 IDENTIFIER REFERENCED
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:132  
              MINI UREF LISTING

M$ACCT     346**DCL-ENT
M$ACTIVATE     349**DCL-ENT
M$ALIB     342**DCL-ENT
M$ASUSER     344**DCL-ENT
M$ATTACH     351**DCL-ENT
M$BADPP     369**DCL-ENT
M$CGCTL     350**DCL-ENT
M$CGINFO     350**DCL-ENT
M$CHECK     331**DCL-ENT
M$CHGUNIT     389**DCL-ENT
M$CLOSE     329**DCL-ENT
M$CLRSTK     387**DCL-ENT
M$CMDVAR     398**DCL-ENT
M$CONFIG     359**DCL-ENT
M$CORRES     334**DCL-ENT
M$CPEXIT     343**DCL-ENT
M$CVM     367**DCL-ENT
M$CVOL     332**DCL-ENT
M$DCLFLD     359**DCL-ENT
M$DEACTIVATE     349**DCL-ENT
M$DELREC     331**DCL-ENT
M$DEQ     396**DCL-ENT
M$DETACH     351**DCL-ENT
M$DEVICE     333**DCL-ENT
M$DISPLAY     396**DCL-ENT
M$DISPRES     336**DCL-ENT
M$DLIB     342**DCL-ENT
M$DRIBBLE     359**DCL-ENT
M$DRTN     387**DCL-ENT
M$DSUSER     344**DCL-ENT
M$ENQ     395**DCL-ENT
M$EOM     354**DCL-ENT
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:133  
M$ERASE     360**DCL-ENT
M$ERR     341**DCL-ENT
M$ERRMSG     392**DCL-ENT
M$EVENT     384**DCL-ENT
M$EXHUME     393**DCL-ENT
M$EXIT     341**DCL-ENT
M$EXTEND     333**DCL-ENT
M$FDP     365**DCL-ENT
M$FDS     364**DCL-ENT
M$FEBOOT     357**DCL-ENT
M$FECTL     358**DCL-ENT
M$FEDUMP     357**DCL-ENT
M$FID     392**DCL-ENT
M$FINDPROC     346**DCL-ENT
M$FSUSER     344**DCL-ENT
M$FVP     366**DCL-ENT
M$FWCG     350**DCL-ENT
M$GBPL     370**DCL-ENT
M$GDDL     366**DCL-ENT
M$GDP     365**DCL-ENT
M$GDS     364**DCL-ENT
M$GETDCB     335**DCL-ENT
M$GETMOUSE     375**DCL-ENT
M$GETPM     376**DCL-ENT
M$GJOB     394**DCL-ENT
M$GLINEATTR     354**DCL-ENT
M$GOODPP     369**DCL-ENT
M$GPLATEN     362**DCL-ENT
M$GPROMPT     361**DCL-ENT
M$GTRMATTR     355**DCL-ENT
M$GTRMCTL     353**DCL-ENT
M$GTRMTAB     356**DCL-ENT
M$GVP     365**DCL-ENT
M$HELP     392**DCL-ENT
M$INT     384**DCL-ENT
M$INTRTN     345**DCL-ENT
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:134  
M$IOQ     380**DCL-ENT
M$JOBSTATS     394**DCL-ENT
M$KEYIN     334**DCL-ENT
M$LDEV     329**DCL-ENT
M$LDTRC     342**DCL-ENT
M$LIMIT     335**DCL-ENT
M$LINES     334**DCL-ENT
M$LINK     341**DCL-ENT
M$MADMUCK     337**DCL-ENT
M$MAKUSER     368**DCL-ENT
M$MBS     336**DCL-ENT
M$MDFFLD     360**DCL-ENT
M$MERC     385**DCL-ENT
M$MERCS     386**DCL-ENT
M$MIRROR     380**DCL-ENT
M$MONINFO     397**DCL-ENT
M$MPL     370**DCL-ENT
M$NODEINFO     361**DCL-ENT
M$NXTUSR     395**DCL-ENT
M$OCMSG     393**DCL-ENT
M$OLAY     341**DCL-ENT
M$OPEN     329**DCL-ENT
M$PAS     370**DCL-ENT
M$PATHCON     393**DCL-ENT
M$PDS     364**DCL-ENT
M$PFIL     331**DCL-ENT
M$PLATEN     355**DCL-ENT
M$PRECORD     333**DCL-ENT
M$PROCNAME     346**DCL-ENT
M$PROFILE     357**DCL-ENT
M$PROMPT     353**DCL-ENT
M$RACST     337**DCL-ENT
M$RDSYSLOG     378**DCL-ENT
M$READ     330**DCL-ENT
M$RELDCB     335**DCL-ENT
M$RELRES     336**DCL-ENT
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:135  
M$RELSTARF     338**DCL-ENT
M$REM     338**DCL-ENT
M$RENV     385**DCL-ENT
M$REQUIRE     337**DCL-ENT
M$RETRY     386**DCL-ENT
M$RETRYS     386**DCL-ENT
M$REW     332**DCL-ENT
M$RLSFLD     360**DCL-ENT
M$RPRIV     388**DCL-ENT
M$RSPP     367**DCL-ENT
M$RSWITCH     389**DCL-ENT
M$RUE     395**DCL-ENT
M$SAD     368**DCL-ENT
M$SAVE     344**DCL-ENT
M$SCON     345**DCL-ENT
M$SCREECH     343**DCL-ENT
M$SENV     385**DCL-ENT
M$SETFMA     329**DCL-ENT
M$SETFP     358**DCL-ENT
M$SINPUT     356**DCL-ENT
M$SLCFLD     361**DCL-ENT
M$SMOUSE     375**DCL-ENT
M$SMPRT     367**DCL-ENT
M$SPRIV     388**DCL-ENT
M$SSC     368**DCL-ENT
M$SSWITCH     388**DCL-ENT
M$STATE     397**DCL-ENT
M$STD     369**DCL-ENT
M$STIMER     383**DCL-ENT
M$STLPP     366**DCL-ENT
M$STRAP     383**DCL-ENT
M$STRMATTR     355**DCL-ENT
M$STRMCTL     353**DCL-ENT
M$STRMTAB     356**DCL-ENT
M$SYMBIO     394**DCL-ENT
M$SYSCON     380**DCL-ENT
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:136  
M$SYSID     398**DCL-ENT
M$TDCLOSE     379**DCL-ENT
M$TDIO     379**DCL-ENT
M$TDOPEN     378**DCL-ENT
M$TDREQCPU     379**DCL-ENT
M$TEMPWROC     373**DCL-ENT
M$TIME     396**DCL-ENT
M$TRAP     383**DCL-ENT
M$TRMISC     358**DCL-ENT
M$TRMPRG     354**DCL-ENT
M$TRTN     387**DCL-ENT
M$TRUNC     330**DCL-ENT
M$TTIMER     383**DCL-ENT
M$UC     353**DCL
M$UMPL     370**DCL-ENT
M$UNFID     392**DCL-ENT
M$UNLATCH     349**DCL-ENT
M$UNSHARE     346**DCL-ENT
M$USRFIELD     389**DCL-ENT
M$VIRTUAL     364**DCL-ENT
M$WEOF     332**DCL-ENT
M$WRITE     330**DCL-ENT
M$WRSYSLOG     378**DCL-ENT
M$XCON     384**DCL-ENT
M$XCONRTN     345**DCL-ENT
M$XEQTIME     397**DCL-ENT
M$XFLUSH     338**DCL-ENT
M$XMOUSE     375**DCL-ENT
M$XXX     341**DCL-ENT
M$YC     343**DCL-ENT
XSL$MSGSDEFS    3227**DCL-ENT
XSL$QREAD    3486**ENTRY
XSL$QRECV    3474**ENTRY
XSL$QRECVFROM    3464**ENTRY
XSL$READ    3481**ENTRY
XSL$RECV    3469**ENTRY
PL6.E3A0      #002=XSL$RECVFROM File=XSL$SOCKET2.:TCA2TSI                        SUN 11/16/97 14:32 Page:137  
XSL$RECVFROM     319**PROC
XSL$SOCKHD    1998**DCL

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:138  
     1080        1        /*T***********************************************************/
     1081        2        /*T*                                                         */
     1082        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     1083        4        /*T*                                                         */
     1084        5        /*T***********************************************************/
     1085        6        /*F* NAME: writev() and XSL$WRITEV  --  Write Gathered Data
     1086        7        ..::IT "Purpose:"
     1087        8        .INL +4
     1088        9        Writes data from multiple application-specified buffers to a socket.
     1089       10        ..::IT "C Usage:"
     1090       11        .INL 4
     1091       12        .FIF
     1092       13        status = writev( s, &iovec[0], count );
     1093       14        ..::IT "PL6 Usage:"
     1094       15        .INL 4
     1095       16        .FIF
     1096       17        CALL XSL$WRITEV( status, s, iovec, count );
     1097       18        ..::IT "Parameters:"
     1098       19        .INL 4
     1099       20        .FIF
     1100       21        s           integer socket descriptor
     1101       22
     1102       23        iovec       array of iovec structures
     1103       24
     1104       25        count       number of structures in iovec
     1105       26        ..::IT "Result:"
     1106       27        .INL 4
     1107       28        .FIF
     1108       29        status      integer number of characters written or error code
     1109       30        ..::IT "Description:"
     1110       31        The writev() function writes data from the specified buffers to the socket.
     1111       32        On datagram sockets the data is written atomically; if this is not
     1112       33        possible then the error EMSGSIZE is reported.
     1113       34        .SPB
     1114       35        The s parameter specifies the descriptor of the socket to be written to.
     1115       36        .SPB
     1116       37        The iovec parameter specifies an array of iovec or XSL$IOVEC structures
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:139  
     1117       38        framing the data buffers to be written to the socket.
     1118       39        .SPB
     1119       40        The count parameter specifies the number of structures in the iovec array.
     1120       41        .SPB
     1121       42        If the writev() function is successful, the status result contains the
     1122       43        number of characters written to the socket.  This number is non-negative.
     1123       44        A successful result does not guarantee that the data was delivered, but
     1124       45        only that it was sent to the FEP for network transmission.  The status
     1125       46        value may be less than the total number of characters in the iovec buffers
     1126       47        if the socket is nonblocking and no more data could be immediately sent.
     1127       48        .SPB
     1128       49        If the writev() function is unsuccessful, the status result contains
     1129       50        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1130       51        to determine the specific error condition.  The XSL$WRITEV procedure
     1131       52        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1132       53        to the writev() function.
     1133       54        .SPB
     1134       55        Writev() may be used only on sockets that have had connect() invoked.
     1135       56        .SPB
     1136       57        If shutdown() has been invoked for this socket to inhibit transmission
     1137       58        of data, all writev() operations report the error ESHUTDOWN.
     1138       59        ..::IT "Errors:"
     1139       60        Following are the possible error conditions reported when the writev()
     1140       61        function is unsuccessful.  Equates for the possible values can be
     1141       62        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1142       63
     1143       64        .FIF
     1144       65
     1145       66        C #define               PL6 %EQU
     1146       67        ----------------------- -----------------------
     1147       68        EBADF                   E$BADF
     1148       69        .FIN
     1149       70        The descriptor s is not appropriate to identify a socket.
     1150       71        .FIF
     1151       72
     1152       73        EMSGSIZE                E$MSGSIZE
     1153       74        .FIN
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:140  
     1154       75        The specified buffers are too long to send atomically.
     1155       76        .FIF
     1156       77
     1157       78        ENOTBOUND               E$NOTBOUND
     1158       79        .FIN
     1159       80        The socket is not bound to a FEP.
     1160       81        .FIF
     1161       82
     1162       83        ENOTCONN                E$NOTCONN
     1163       84        .FIN
     1164       85        The socket is not currently connected.  connect() has not been invoked.
     1165       86        .FIF
     1166       87
     1167       88        ENOTSOCK                E$NOTSOCK
     1168       89        .FIN
     1169       90        The descriptor s is no longer valid to identify a socket.
     1170       91        .FIF
     1171       92
     1172       93        ESHUTDOWN               E$SHUTDOWN
     1173       94        .FIN
     1174       95        Can't send after socket shutdown.
     1175       96        .FIF
     1176       97
     1177       98        EWOULDBLOCK             E$WOULDBLOCK
     1178       99        .FIN
     1179      100        The data cannot be immediately sent.
     1180      101        .FIF
     1181      102        */
     1182      103        /*F* NAME: readv() and XSL$READV  --  Read Scattered Data
     1183      104        ..::IT "Purpose:"
     1184      105        .INL +4
     1185      106        Reads data from a socket into multiple application-specified buffers.
     1186      107        ..::IT "C Usage:"
     1187      108        .INL 4
     1188      109        .FIF
     1189      110        status = readv( s, &iovec[0], count );
     1190      111        ..::IT "PL6 Usage:"
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:141  
     1191      112        .INL 4
     1192      113        .FIF
     1193      114        CALL XSL$READV( status, s, iovec, count );
     1194      115        ..::IT "Parameters:"
     1195      116        .INL 4
     1196      117        .FIF
     1197      118        s           integer socket descriptor
     1198      119
     1199      120        iovec       array of iovec structures
     1200      121
     1201      122        count       number of structures in iovec
     1202      123        ..::IT "Results:"
     1203      124        .INL 4
     1204      125        .FIF
     1205      126        status      integer number of characters read or error code
     1206      127
     1207      128        iovec       array of iovec structures
     1208      129        ..::IT "Description:"
     1209      130        The readv() function reads any available data from the socket into the
     1210      131        specified buffers.
     1211      132        .SPB
     1212      133        The s parameter specifies the descriptor of the socket to be read from.
     1213      134        .SPB
     1214      135        The iovec parameter specifies an array of iovec or XSL$IOVEC structures
     1215      136        framing the data buffers to receive the data to be read from the socket.
     1216      137        .SPB
     1217      138        The count parameter specifies the number of structures in the iovec array.
     1218      139        .SPB
     1219      140        If the readv() function is successful, the status result contains the number
     1220      141        of characters read into the iovec buffers.  This number is non-negative.
     1221      142        A successful readv() returns all data available, up to the total size of
     1222      143        the iovec buffers.  On datagram sockets, if the buffers are not large enough
     1223      144        to receive the entire datagram, the excess will be discarded.
     1224      145        .SPB
     1225      146        If the readv() function is unsuccessful, the status result contains
     1226      147        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1227      148        to determine the specific error condition.  The XSL$READV procedure
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:142  
     1228      149        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1229      150        to the readv() function.
     1230      151        .SPB
     1231      152        If no data is available from a socket when readv() is invoked, the action
     1232      153        taken depends on the socket mode.  The mode of a socket is defined
     1233      154        to be either "blocking" or "nonblocking".  If the socket is blocking
     1234      155        (which is the default mode) the application is blocked (i.e., suspended)
     1235      156        until data is received from the network.  If the socket is nonblocking,
     1236      157        the condition is treated as an EWOULDBLOCK error.
     1237      158        .SPB
     1238      159        The mode of a socket can be changed with either fcntl() or ioctl().
     1239      160        .SPB
     1240      161        If shutdown() has been invoked for this socket to inhibit reception of
     1241      162        data, or if the peer is no longer connected, all readv() operations are
     1242      163        treated as if zero bytes of data were read.
     1243      164        ..::IT "Errors:"
     1244      165        Following are the possible error conditions reported when the writev()
     1245      166        function is unsuccessful.  Equates for the possible values can be
     1246      167        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1247      168
     1248      169        .FIF
     1249      170
     1250      171        C #define               PL6 %EQU
     1251      172        ----------------------- -----------------------
     1252      173        EBADF                   E$BADF
     1253      174        .FIN
     1254      175        The descriptor s is not appropriate to identify a socket.
     1255      176        .FIF
     1256      177
     1257      178        ENOTCONN                E$NOTCONN
     1258      179        .FIN
     1259      180        The socket is not currently connected.  connect() has not been invoked.
     1260      181        .FIF
     1261      182
     1262      183        ENOTSOCK                E$NOTSOCK
     1263      184        .FIN
     1264      185        The descriptor s is no longer valid to identify a socket.
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:143  
     1265      186        .FIF
     1266      187
     1267      188        EWOULDBLOCK             E$WOULDBLOCK
     1268      189        .FIN
     1269      190        There is no data available from this nonblocking socket.
     1270      191        .FIF
     1271      192        */
     1272      193        /*F* NAME: sendmsg() and XSL$SENDMSG  --  Write Gathered Data With Options And Addre
               193        ss
     1273      194        ..::IT "Purpose:"
     1274      195        .INL +4
     1275      196        Sends a message from multiple application-specified buffers to a socket.
     1276      197        This function is typically used when the destination socket changes from
     1277      198        invocation to invocation.
     1278      199        ..::IT "C Usage:"
     1279      200        .INL 4
     1280      201        .FIF
     1281      202        status = sendmsg( s, &msghdr, flags );
     1282      203        ..::IT "PL6 Usage:"
     1283      204        .INL 4
     1284      205        .FIF
     1285      206        CALL XSL$SENDMSG( status, s, msghdr, flags );
     1286      207        ..::IT "Parameters:"
     1287      208        .INL 4
     1288      209        .FIF
     1289      210        s           integer socket descriptor
     1290      211
     1291      212        msghdr      msghdr structure
     1292      213
     1293      214        flags       integer bitflags of sendmsg options
     1294      215        ..::IT "Result:"
     1295      216        .INL 4
     1296      217        .FIF
     1297      218        status      integer number of characters sent or error code
     1298      219        ..::IT "Description:"
     1299      220        The sendmsg() function sends a message from multiple application-defined
     1300      221        buffers to a socket.  On datagram sockets the message is sent atomically; if
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:144  
     1301      222        this is not possible then the error EMSGSIZE is reported.
     1302      223        .SPB
     1303      224        The s parameter specifies the descriptor of the socket to be written to.
     1304      225        .SPB
     1305      226        The msghdr parameter specifies a msghdr or XSL$MSGHDR structure containing
     1306      227        information specific to this invocation.
     1307      228        .SPB
     1308      229        The flags parameter specifies sendmsg options.  The only option currently
     1309      230        implemented is "out-of-band", which causes the message to be sent on the
     1310      231        out-of-band data path if the socket supports it.  This is selected by coding
     1311      232        MSG_OOB or %XSL_MSG_OOB in C or PL6 source, respectively.
     1312      233        .SPB
     1313      234        If the sendmsg() function is successful, the status result contains the
     1314      235        number of characters sent to the socket.  This number is non-negative.
     1315      236        A successful result does not guarantee that the message was delivered,
     1316      237        but only that it was sent to the FEP for network transmission.  The
     1317      238        status value may be less than the total number of characters in the iovec
     1318      239        buffers within msghdr if the socket is nonblocking and no more data could
     1319      240        be immediately sent.
     1320      241        .SPB
     1321      242        If the sendmsg() function is unsuccessful, the status result contains
     1322      243        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1323      244        to determine the specific error condition.  The XSL$SENDMSG procedure
     1324      245        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1325      246        to the sendmsg() function.
     1326      247        .SPB
     1327      248        Sendmsg() may be used on sockets regardless of whether connect() has been
     1328      249        issued.
     1329      250        .SPB
     1330      251        If shutdown() has been invoked for this socket to inhibit transmission
     1331      252        of data, all sendmsg() operations report the error ESHUTDOWN.
     1332      253        ..::IT "Errors:"
     1333      254        Following are the possible error conditions reported when the sendmsg()
     1334      255        function is unsuccessful.  Equates for the possible values can be
     1335      256        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1336      257
     1337      258        .FIF
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:145  
     1338      259
     1339      260        C #define               PL6 %EQU
     1340      261        ----------------------- -----------------------
     1341      262        EBADF                   E$BADF
     1342      263        .FIN
     1343      264        The descriptor s is not appropriate to identify a socket.
     1344      265        .FIF
     1345      266
     1346      267        EMSGSIZE                E$MSGSIZE
     1347      268        .FIN
     1348      269        The specified buffers are too long to send atomically.
     1349      270        .FIF
     1350      271
     1351      272        ENOTSOCK                E$NOTSOCK
     1352      273        .FIN
     1353      274        The descriptor s is no longer valid to identify a socket.
     1354      275        .FIF
     1355      276
     1356      277        ESHUTDOWN               E$SHUTDOWN
     1357      278        .FIN
     1358      279        Can't send after socket shutdown.
     1359      280        .FIF
     1360      281
     1361      282        EWOULDBLOCK             E$WOULDBLOCK
     1362      283        .FIN
     1363      284        The data cannot be immediately sent.
     1364      285        .FIF
     1365      286        */
     1366      287        /*F* NAME: recvmsg() and XSL$RECVMSG  --  Read Scattered Data With Options and Addre
               287        ss
     1367      288        ..::IT "Purpose:"
     1368      289        .INL +4
     1369      290        Receives a message from a socket into multiple application-specified buffers,
     1370      291        along with the address of the message's sender.
     1371      292        ..::IT "C Usage:"
     1372      293        .INL 4
     1373      294        .FIF
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:146  
     1374      295        status = recvmsg( s, msghdr, flags );
     1375      296        ..::IT "PL6 Usage:"
     1376      297        .INL 4
     1377      298        .FIF
     1378      299        CALL XSL$RECVMSG( status, s, msghdr, flags );
     1379      300        ..::IT "Parameters:"
     1380      301        .INL 4
     1381      302        .FIF
     1382      303        s           integer socket descriptor
     1383      304
     1384      305        msghdr      msghdr structure
     1385      306
     1386      307        flags       integer bitflags of recvmsg options
     1387      308        ..::IT "Results:"
     1388      309        .INL 4
     1389      310        .FIF
     1390      311        status      integer number of characters received or error code
     1391      312
     1392      313        msghdr      msghdr structure
     1393      314        ..::IT "Description:"
     1394      315        The recvmsg() function receives a message from a connected socket and places
     1395      316        it in the buffers specified in the iovec array within msghdr.  Additionally,
     1396      317        the network address of the message's sender is provided in msghdr.
     1397      318        .SPB
     1398      319        The s parameter specifies the descriptor of the socket on which to receive.
     1399      320        .SPB
     1400      321        The msghdr parameter specifies a msghdr or XSL$MSGHDR structure containing
     1401      322        information specific to this invocation.
     1402      323        .SPB
     1403      324        The flags parameter specifies recvmsg options.  The desired options are
     1404      325        'ORed' together when coding the invocation.  The only options currently
     1405      326        implemented are "out-of-band" and "peek".  The out-of-band option receives
     1406      327        any message that was sent on the out-of-band data path if the socket supports
     1407      328        it.  It is selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source,
     1408      329        respectively.  The peek option copies a message into the buffers, but
     1409      330        additionally leaves it in the queue so subsequent recvmsg() invocations see the same
               330         message.
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:147  
     1410      331        It is selected by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 source,
     1411      332        respectively.
     1412      333        .SPB
     1413      334        If the recvmsg() function is successful, the status result contains the
     1414      335        number of characters received into the iovec buffers within msghdr.  This
     1415      336        number is non-negative.  On datagram sockets, if the buffers are not large
     1416      337        enough to receive the entire message, the excess will be discarded.  The
     1417      338        network address of the message's sender is placed into the msg_name item
     1418      339        within msghdr, and msg_namelen is set to the number of significant characters
     1419      340        in msg_name.
     1420      341        .SPB
     1421      342        If the recvmsg() function is unsuccessful, the status result contains
     1422      343        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1423      344        to determine the specific error condition.  The XSL$RECVMSG procedure
     1424      345        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1425      346        to the recvmsg() function.
     1426      347        .SPB
     1427      348        If no data is available from a socket when recvmsg() is invoked, the action
     1428      349        taken depends on the socket mode.  The mode of a socket is defined
     1429      350        to be either "blocking" or "nonblocking".  If the socket is blocking
     1430      351        (which is the default mode) the application is blocked (i.e., suspended)
     1431      352        until data is received from the network.  If the socket is nonblocking,
     1432      353        the condition is treated as an EWOULDBLOCK error.
     1433      354        .SPB
     1434      355        The mode of a socket can be changed with either fcntl() or ioctl().
     1435      356        .SPB
     1436      357        If shutdown() has been invoked for this socket to inhibit reception of
     1437      358        data, or if the peer is no longer connected, all recvmsg() operations are
     1438      359        treated as if zero bytes of data were read.
     1439      360        ..::IT "Errors:"
     1440      361        Following are the possible error conditions reported when the recvmsg()
     1441      362        function is unsuccessful.  Equates for the possible values can be
     1442      363        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1443      364
     1444      365        .FIF
     1445      366
     1446      367        C #define               PL6 %EQU
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:148  
     1447      368        ----------------------- -----------------------
     1448      369        EBADF                   E$BADF
     1449      370        .FIN
     1450      371        The descriptor s is not appropriate to identify a socket.
     1451      372        .FIF
     1452      373
     1453      374        ENOTSOCK                E$NOTSOCK
     1454      375        .FIN
     1455      376        The descriptor s is no longer valid to identify a socket.
     1456      377        .FIF
     1457      378
     1458      379        EWOULDBLOCK             E$WOULDBLOCK
     1459      380        .FIN
     1460      381        There is no data available from this nonblocking socket.
     1461      382        .FIF
     1462      383        */
     1463      384        XSL$IOVECS: PROC( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1464      385        %INCLUDE XSL_PERR_C;
     1465      440        %INCLUDE XSL_SOCKET_E;
     1466      698        %INCLUDE XSL_SOCKET_M;
     1467     1459            %XSL$IOVEC( STCLASS="BASED( PARM3$)");
     1468     1495            %XSL$MSGHDR( STCLASS="BASED( PARM3$)");
     1469     1557            %XSL$SOCKADDR;
     1470     1597        %INCLUDE XSL_INTERNAL_M;
     1471     1848            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
     1472     1992
     1473     1993    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
     1474     1994    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
     1475     1995    1       DCL XSL$QREAD ENTRY(4) ALTRET;
     1476     1996    1       DCL XSL$QRECVFROM ENTRY(7) ALTRET;
     1477     1997    1       DCL XSL$QSENDTO ENTRY(7) ALTRET;
     1478     1998    1       DCL XSL$QWRITE ENTRY(4) ALTRET;
     1479     1999
     1480     2000    1       DCL XSL_ERRNO SBIN SYMREF;
     1481     2001    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
     1482     2002    1       DCL XSL_SOCK$$ PTR SYMREF;
     1483     2003
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:149  
     1484     2004    1       DCL BUF$ PTR;
     1485     2005    1       DCL XBUF CHAR( LEN) BASED( BUF$);
     1486     2006    1       DCL ENTRYFLAG SBIN;
     1487     2007        %EQU READV = 0;
     1488     2008        %EQU WRITEV = 1;
     1489     2009        %EQU RECVMSG = 2;
     1490     2010        %EQU SENDMSG = 3;
     1491     2011    1       DCL LEN SBIN;
     1492     2012    1       DCL MSGSIZE SBIN;
     1493     2013    1       DCL PARM3 UBIN;
     1494     2014    1       DCL PARM3$ PTR;
     1495     2015    1       DCL PARM4 UBIN;
     1496     2016    1       DCL RESULT SBIN;
     1497     2017    1       DCL SOCK# SBIN;
     1498     2018    1       DCL SOCK$ PTR;
     1499     2019    1       DCL XSOCK SBIN;
     1500     2020        %EQU VBUFSIZ = 9000;
     1501     2021    1       DCL VBUF CHAR(%VBUFSIZ);
     1502     2022
     1503     2023    1   XSL$READV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1504     2024
     1505     2025    1       ENTRYFLAG = %READV;
     1506     2026    1       GOTO COMMONDCBN;
     1507     2027
     1508     2028    1   XSL$QREADV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1509     2029
     1510     2030    1       ENTRYFLAG = %READV;
     1511     2031    1       GOTO COMMONSOCK;
     1512     2032
     1513     2033    1   XSL$WRITEV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1514     2034
     1515     2035    1       ENTRYFLAG = %WRITEV;
     1516     2036    1       GOTO COMMONDCBN;
     1517     2037
     1518     2038    1   XSL$QWRITEV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1519     2039
     1520     2040    1       ENTRYFLAG = %WRITEV;
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:150  
     1521     2041    1       GOTO COMMONSOCK;
     1522     2042
     1523     2043    1   XSL$RECVMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1524     2044
     1525     2045    1       ENTRYFLAG = %RECVMSG;
     1526     2046    1       GOTO COMMONDCBN;
     1527     2047
     1528     2048    1   XSL$QRECVMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1529     2049
     1530     2050    1       ENTRYFLAG = %RECVMSG;
     1531     2051    1       GOTO COMMONSOCK;
     1532     2052
     1533     2053    1   XSL$SENDMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1534     2054
     1535     2055    1       ENTRYFLAG = %SENDMSG;
     1536     2056    1   COMMONDCBN:
     1537     2057    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
     1538     2058    1       XSOCK = XSL_SOCK$->SOCK.SOCK#;
     1539     2059    1       GOTO LATER;
     1540     2060
     1541     2061    1   XSL$QSENDMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;
     1542     2062
     1543     2063    1       ENTRYFLAG = %SENDMSG;
     1544     2064    1   COMMONSOCK:
     1545     2065    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);
     1546     2066    1       XSOCK = SOCK#;
     1547     2067    1   LATER:
     1548     2068    1       SOCK$ = XSL_SOCK$;
     1549     2069    1       PARM3$ = ADDR( PARM3);
     1550     2070    2       DO CASE( ENTRYFLAG);
     1551     2071    2           CASE( %READV);
     1552     2072                    /* PARM3 is an iovec array, PARM4 counts array items */
     1553     2073    3               IF PARM4 = 1 THEN DO;
     1554     2074    3                   BUF$ = XSL$IOVEC.IOV_BASE$(0);
     1555     2075    3                   LEN = XSL$IOVEC.IOV_LEN(0);
     1556     2076    3                   END;
     1557     2077    3               ELSE DO;
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:151  
     1558     2078    3                   CALL COUNTVBUF( PARM3, PARM4, LEN);
     1559     2079    3                   LEN = MINIMUM( LEN, %VBUFSIZ);
     1560     2080    3                   END;
     1561     2081    2               CALL XSL$QREAD( RESULT, XSOCK, XBUF, LEN) ALTRET( BAILOUT);
     1562     2082    2               IF PARM4 ~= 1 THEN
     1563     2083    2                   CALL DUMPVBUF( PARM3, PARM4, RESULT);
     1564     2084    2           CASE( %WRITEV);
     1565     2085                    /* PARM3 is an iovec array, PARM4 counts array items */
     1566     2086    2               CALL COUNTVBUF( PARM3, PARM4, MSGSIZE);
     1567     2087    3               IF PARM4 = 1 THEN DO;
     1568     2088    3                   BUF$ = XSL$IOVEC.IOV_BASE$(0);
     1569     2089    3                   LEN = XSL$IOVEC.IOV_LEN(0);
     1570     2090    3                   END;
     1571     2091    2               ELSE
     1572     2092    2                   CALL LOADVBUF( PARM3, PARM4, LEN);
     1573     2093    3               IF MSGSIZE > LEN AND SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;
     1574     2094    3                   XSL_ERRNO = %E$MSGSIZE;
     1575     2095    3                   GOTO BAILOUT;
     1576     2096    3                   END;
     1577     2097    2               CALL XSL$QWRITE( RESULT, XSOCK, XBUF, LEN) ALTRET( BAILOUT);
     1578     2098    2           CASE( %RECVMSG);
     1579     2099                    /* PARM3 is a msghdr structure, PARM4 is flags */
     1580     2100    3               IF XSL$MSGHDR.MSG_IOVLEN = 1 THEN DO;
     1581     2101    3                   BUF$ = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_BASE$(0);
     1582     2102    3                   LEN = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_LEN(0);
     1583     2103    3                   END;
     1584     2104    3               ELSE DO;
     1585     2105    3                   CALL COUNTVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,
     1586     2106    3                     XSL$MSGHDR.MSG_IOVLEN, LEN);
     1587     2107    3                   LEN = MINIMUM( LEN, %VBUFSIZ);
     1588     2108    3                   END;
     1589     2109    2               CALL XSL$QRECVFROM( RESULT, XSOCK, XBUF, LEN, PARM4,
     1590     2110    2                 XSL$MSGHDR.MSG_NAME$->XSL$SOCKADDR,
     1591     2111    2                 XSL$MSGHDR.MSG_NAMELEN)
     1592     2112    2                 ALTRET( BAILOUT);
     1593     2113    2               IF XSL$MSGHDR.MSG_IOVLEN ~= 1 THEN
     1594     2114    2                   CALL DUMPVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:152  
     1595     2115    2                     XSL$MSGHDR.MSG_IOVLEN, RESULT);
     1596     2116    2           CASE( %SENDMSG);
     1597     2117                    /* PARM3 is a msghdr structure, PARM4 is flags */
     1598     2118    2               IF XSL$MSGHDR.MSG_ACCRIGHTS$ ~= ADDR( NIL) OR
     1599     2119    3                 XSL$MSGHDR.MSG_ACCRIGHTSLEN ~= 0 THEN DO;
     1600     2120    3                   XSL_ERRNO = %E$OPNOTSUPP;
     1601     2121    3                   GOTO BAILOUT;
     1602     2122    3                   END;
     1603     2123    2               CALL COUNTVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,
     1604     2124    2                 XSL$MSGHDR.MSG_IOVLEN, MSGSIZE);
     1605     2125    3               IF XSL$MSGHDR.MSG_IOVLEN = 1 THEN DO;
     1606     2126    3                   BUF$ = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_BASE$(0);
     1607     2127    3                   LEN = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_LEN(0);
     1608     2128    3                   END;
     1609     2129    2               ELSE
     1610     2130    2                   CALL LOADVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,
     1611     2131    2                     XSL$MSGHDR.MSG_IOVLEN, LEN);
     1612     2132    3               IF MSGSIZE > LEN AND SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;
     1613     2133    3                   XSL_ERRNO = %E$MSGSIZE;
     1614     2134    3                   GOTO BAILOUT;
     1615     2135    3                   END;
     1616     2136    2               CALL XSL$QSENDTO( RESULT, XSOCK, XBUF, LEN, PARM4,
     1617     2137    2                 XSL$MSGHDR.MSG_NAME$->XSL$SOCKADDR,
     1618     2138    2                 XSL$MSGHDR.MSG_NAMELEN)
     1619     2139    2                 ALTRET( BAILOUT);
     1620     2140    2           END;
     1621     2141    1   SUCCESS:
     1622     2142    1       RETURN;
     1623     2143    1   BAILOUT:
     1624     2144    1       RESULT = %E$FAILURE;
     1625     2145    1       ALTRETURN;
     1626     2146
     1627     2147    1   MUNGEVBUF: PROC( IOVEC, IOVLEN, VLEN);
     1628     2148
     1629     2149    2       DCL B$CHARS CHAR( LEN) BASED CALIGNED;
     1630     2150    2       DCL I SBIN;
     1631     2151    2       DCL IDX SBIN;
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:153  
     1632     2152            %XSL$IOVEC( FPTN=IOVEC, STCLASS=);
     1633     2188    2       DCL IOVLEN SBIN;
     1634     2189    2       DCL LEN SBIN;
     1635     2190    2       DCL TEMP SBIN;
     1636     2191    2       DCL VLEN SBIN;
     1637     2192
     1638     2193    2   LOADVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* assemble iovec items into vbuf */
     1639     2194
     1640     2195    2       VLEN = 0;
     1641     2196    3       DO I = 0 TO IOVLEN - 1;
     1642     2197    3           LEN = MINIMUM( IOVEC.IOV_LEN( I), %VBUFSIZ - VLEN);
     1643     2198    3           IF LEN > 0 THEN
     1644     2199    3               SUBSTR( VBUF, VLEN, LEN) = IOVEC.IOV_BASE$( I)->B$CHARS;
     1645     2200    3           VLEN = VLEN + LEN;
     1646     2201    3           END;
     1647     2202    2       RETURN;
     1648     2203
     1649     2204    2   DUMPVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* disperse vbuf into iovec items */
     1650     2205
     1651     2206    2       IDX = 0;
     1652     2207    2       TEMP = VLEN;
     1653     2208    3       DO I = 0 TO IOVLEN - 1;
     1654     2209    3           LEN = MINIMUM( TEMP, IOVEC.IOV_LEN( I));
     1655     2210    3           IF LEN > 0 THEN
     1656     2211    3               IOVEC.IOV_BASE$( I)->B$CHARS = SUBSTR( VBUF, IDX, LEN);
     1657     2212    3           IDX = IDX + LEN;
     1658     2213    3           TEMP = TEMP - LEN;
     1659     2214    3           IF TEMP <= 0 THEN
     1660     2215    3               EXIT;
     1661     2216    3           END;
     1662     2217    2       RETURN;
     1663     2218
     1664     2219    2   COUNTVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* total lengths of iovec items */
     1665     2220
     1666     2221    2       VLEN = 0;
     1667     2222    3       DO I = 0 TO IOVLEN - 1;
     1668     2223    3           VLEN = VLEN + IOVEC.IOV_LEN( I);
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:154  
     1669     2224    3           END;
     1670     2225    2       BUF$ = ADDR( VBUF);
     1671     2226    2       RETURN;
     1672     2227
     1673     2228    2   END MUNGEVBUF;
     1674     2229
     1675     2230    1   END XSL$IOVECS;
     1676     2231        %EOD;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:155  
--  Include file information  --

   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure XSL$IOVECS.

   Procedure XSL$IOVECS requires 398 words for executable code.
   Procedure XSL$IOVECS requires 2280 words of local(AUTO) storage.

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:156  

 Object Unit name= XSL$IOVECS                                 File name= XSL$SOCKET2.:TCA2TOU
 UTS= NOV 16 '97 14:33:27.04 SUN                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   Proc  even  none   398    616  XSL$IOVECS
    1  RoData even  none     1      1  XSL$IOVECS

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     0      0   yes    yes     yes      Std        4  XSL$IOVECS
     0      3          yes     yes      Std        4  XSL$READV
     0      7          yes     yes      Std        4  XSL$QREADV
     0     13          yes     yes      Std        4  XSL$WRITEV
     0     20          yes     yes      Std        4  XSL$QWRITEV
     0     25          yes     yes      Std        4  XSL$RECVMSG
     0     32          yes     yes      Std        4  XSL$QRECVMSG
     0     37          yes     yes      Std        4  XSL$SENDMSG
     0     57          yes     yes      Std        4  XSL$QSENDMSG
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:157  

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XSL$DCBNPTR
 yes     yes           Std       2 XSL$SOCKPTR
 yes     yes           Std       4 XSL$QWRITE
 yes     yes           Std       4 XSL$QREAD
 yes     yes           Std       7 XSL$QRECVFROM
 yes     yes           Std       7 XSL$QSENDTO
                       nStd      0 X66_AUTO_4
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_ARET
                       nStd      0 X66_AALT

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     XSL_ERRNO                             B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ISSID
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:158  


     1080        1        /*T***********************************************************/
     1081        2        /*T*                                                         */
     1082        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     1083        4        /*T*                                                         */
     1084        5        /*T***********************************************************/
     1085        6        /*F* NAME: writev() and XSL$WRITEV  --  Write Gathered Data
     1086        7        ..::IT "Purpose:"
     1087        8        .INL +4
     1088        9        Writes data from multiple application-specified buffers to a socket.
     1089       10        ..::IT "C Usage:"
     1090       11        .INL 4
     1091       12        .FIF
     1092       13        status = writev( s, &iovec[0], count );
     1093       14        ..::IT "PL6 Usage:"
     1094       15        .INL 4
     1095       16        .FIF
     1096       17        CALL XSL$WRITEV( status, s, iovec, count );
     1097       18        ..::IT "Parameters:"
     1098       19        .INL 4
     1099       20        .FIF
     1100       21        s           integer socket descriptor
     1101       22
     1102       23        iovec       array of iovec structures
     1103       24
     1104       25        count       number of structures in iovec
     1105       26        ..::IT "Result:"
     1106       27        .INL 4
     1107       28        .FIF
     1108       29        status      integer number of characters written or error code
     1109       30        ..::IT "Description:"
     1110       31        The writev() function writes data from the specified buffers to the socket.
     1111       32        On datagram sockets the data is written atomically; if this is not
     1112       33        possible then the error EMSGSIZE is reported.
     1113       34        .SPB
     1114       35        The s parameter specifies the descriptor of the socket to be written to.
     1115       36        .SPB
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:159  
     1116       37        The iovec parameter specifies an array of iovec or XSL$IOVEC structures
     1117       38        framing the data buffers to be written to the socket.
     1118       39        .SPB
     1119       40        The count parameter specifies the number of structures in the iovec array.
     1120       41        .SPB
     1121       42        If the writev() function is successful, the status result contains the
     1122       43        number of characters written to the socket.  This number is non-negative.
     1123       44        A successful result does not guarantee that the data was delivered, but
     1124       45        only that it was sent to the FEP for network transmission.  The status
     1125       46        value may be less than the total number of characters in the iovec buffers
     1126       47        if the socket is nonblocking and no more data could be immediately sent.
     1127       48        .SPB
     1128       49        If the writev() function is unsuccessful, the status result contains
     1129       50        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1130       51        to determine the specific error condition.  The XSL$WRITEV procedure
     1131       52        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1132       53        to the writev() function.
     1133       54        .SPB
     1134       55        Writev() may be used only on sockets that have had connect() invoked.
     1135       56        .SPB
     1136       57        If shutdown() has been invoked for this socket to inhibit transmission
     1137       58        of data, all writev() operations report the error ESHUTDOWN.
     1138       59        ..::IT "Errors:"
     1139       60        Following are the possible error conditions reported when the writev()
     1140       61        function is unsuccessful.  Equates for the possible values can be
     1141       62        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1142       63
     1143       64        .FIF
     1144       65
     1145       66        C #define               PL6 %EQU
     1146       67        ----------------------- -----------------------
     1147       68        EBADF                   E$BADF
     1148       69        .FIN
     1149       70        The descriptor s is not appropriate to identify a socket.
     1150       71        .FIF
     1151       72
     1152       73        EMSGSIZE                E$MSGSIZE
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:160  
     1153       74        .FIN
     1154       75        The specified buffers are too long to send atomically.
     1155       76        .FIF
     1156       77
     1157       78        ENOTBOUND               E$NOTBOUND
     1158       79        .FIN
     1159       80        The socket is not bound to a FEP.
     1160       81        .FIF
     1161       82
     1162       83        ENOTCONN                E$NOTCONN
     1163       84        .FIN
     1164       85        The socket is not currently connected.  connect() has not been invoked.
     1165       86        .FIF
     1166       87
     1167       88        ENOTSOCK                E$NOTSOCK
     1168       89        .FIN
     1169       90        The descriptor s is no longer valid to identify a socket.
     1170       91        .FIF
     1171       92
     1172       93        ESHUTDOWN               E$SHUTDOWN
     1173       94        .FIN
     1174       95        Can't send after socket shutdown.
     1175       96        .FIF
     1176       97
     1177       98        EWOULDBLOCK             E$WOULDBLOCK
     1178       99        .FIN
     1179      100        The data cannot be immediately sent.
     1180      101        .FIF
     1181      102        */
     1182      103        /*F* NAME: readv() and XSL$READV  --  Read Scattered Data
     1183      104        ..::IT "Purpose:"
     1184      105        .INL +4
     1185      106        Reads data from a socket into multiple application-specified buffers.
     1186      107        ..::IT "C Usage:"
     1187      108        .INL 4
     1188      109        .FIF
     1189      110        status = readv( s, &iovec[0], count );
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:161  
     1190      111        ..::IT "PL6 Usage:"
     1191      112        .INL 4
     1192      113        .FIF
     1193      114        CALL XSL$READV( status, s, iovec, count );
     1194      115        ..::IT "Parameters:"
     1195      116        .INL 4
     1196      117        .FIF
     1197      118        s           integer socket descriptor
     1198      119
     1199      120        iovec       array of iovec structures
     1200      121
     1201      122        count       number of structures in iovec
     1202      123        ..::IT "Results:"
     1203      124        .INL 4
     1204      125        .FIF
     1205      126        status      integer number of characters read or error code
     1206      127
     1207      128        iovec       array of iovec structures
     1208      129        ..::IT "Description:"
     1209      130        The readv() function reads any available data from the socket into the
     1210      131        specified buffers.
     1211      132        .SPB
     1212      133        The s parameter specifies the descriptor of the socket to be read from.
     1213      134        .SPB
     1214      135        The iovec parameter specifies an array of iovec or XSL$IOVEC structures
     1215      136        framing the data buffers to receive the data to be read from the socket.
     1216      137        .SPB
     1217      138        The count parameter specifies the number of structures in the iovec array.
     1218      139        .SPB
     1219      140        If the readv() function is successful, the status result contains the number
     1220      141        of characters read into the iovec buffers.  This number is non-negative.
     1221      142        A successful readv() returns all data available, up to the total size of
     1222      143        the iovec buffers.  On datagram sockets, if the buffers are not large enough
     1223      144        to receive the entire datagram, the excess will be discarded.
     1224      145        .SPB
     1225      146        If the readv() function is unsuccessful, the status result contains
     1226      147        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:162  
     1227      148        to determine the specific error condition.  The XSL$READV procedure
     1228      149        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1229      150        to the readv() function.
     1230      151        .SPB
     1231      152        If no data is available from a socket when readv() is invoked, the action
     1232      153        taken depends on the socket mode.  The mode of a socket is defined
     1233      154        to be either "blocking" or "nonblocking".  If the socket is blocking
     1234      155        (which is the default mode) the application is blocked (i.e., suspended)
     1235      156        until data is received from the network.  If the socket is nonblocking,
     1236      157        the condition is treated as an EWOULDBLOCK error.
     1237      158        .SPB
     1238      159        The mode of a socket can be changed with either fcntl() or ioctl().
     1239      160        .SPB
     1240      161        If shutdown() has been invoked for this socket to inhibit reception of
     1241      162        data, or if the peer is no longer connected, all readv() operations are
     1242      163        treated as if zero bytes of data were read.
     1243      164        ..::IT "Errors:"
     1244      165        Following are the possible error conditions reported when the writev()
     1245      166        function is unsuccessful.  Equates for the possible values can be
     1246      167        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1247      168
     1248      169        .FIF
     1249      170
     1250      171        C #define               PL6 %EQU
     1251      172        ----------------------- -----------------------
     1252      173        EBADF                   E$BADF
     1253      174        .FIN
     1254      175        The descriptor s is not appropriate to identify a socket.
     1255      176        .FIF
     1256      177
     1257      178        ENOTCONN                E$NOTCONN
     1258      179        .FIN
     1259      180        The socket is not currently connected.  connect() has not been invoked.
     1260      181        .FIF
     1261      182
     1262      183        ENOTSOCK                E$NOTSOCK
     1263      184        .FIN
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:163  
     1264      185        The descriptor s is no longer valid to identify a socket.
     1265      186        .FIF
     1266      187
     1267      188        EWOULDBLOCK             E$WOULDBLOCK
     1268      189        .FIN
     1269      190        There is no data available from this nonblocking socket.
     1270      191        .FIF
     1271      192        */
     1272      193        /*F* NAME: sendmsg() and XSL$SENDMSG  -- Write Gathered Data With Options And Addre
               193        ss
     1273      194        ..::IT "Purpose:"
     1274      195        .INL +4
     1275      196        Sends a message from multiple application-specified buffers to a socket.
     1276      197        This function is typically used when the destination socket changes from
     1277      198        invocation to invocation.
     1278      199        ..::IT "C Usage:"
     1279      200        .INL 4
     1280      201        .FIF
     1281      202        status = sendmsg( s, &msghdr, flags );
     1282      203        ..::IT "PL6 Usage:"
     1283      204        .INL 4
     1284      205        .FIF
     1285      206        CALL XSL$SENDMSG( status, s, msghdr, flags );
     1286      207        ..::IT "Parameters:"
     1287      208        .INL 4
     1288      209        .FIF
     1289      210        s           integer socket descriptor
     1290      211
     1291      212        msghdr      msghdr structure
     1292      213
     1293      214        flags       integer bitflags of sendmsg options
     1294      215        ..::IT "Result:"
     1295      216        .INL 4
     1296      217        .FIF
     1297      218        status      integer number of characters sent or error code
     1298      219        ..::IT "Description:"
     1299      220        The sendmsg() function sends a message from multiple application-defined
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:164  
     1300      221        buffers to a socket.  On datagram sockets the message is sent atomically; if
     1301      222        this is not possible then the error EMSGSIZE is reported.
     1302      223        .SPB
     1303      224        The s parameter specifies the descriptor of the socket to be written to.
     1304      225        .SPB
     1305      226        The msghdr parameter specifies a msghdr or XSL$MSGHDR structure containing
     1306      227        information specific to this invocation.
     1307      228        .SPB
     1308      229        The flags parameter specifies sendmsg options.  The only option currently
     1309      230        implemented is "out-of-band", which causes the message to be sent on the
     1310      231        out-of-band data path if the socket supports it.  This is selected by coding
     1311      232        MSG_OOB or %XSL_MSG_OOB in C or PL6 source, respectively.
     1312      233        .SPB
     1313      234        If the sendmsg() function is successful, the status result contains the
     1314      235        number of characters sent to the socket.  This number is non-negative.
     1315      236        A successful result does not guarantee that the message was delivered,
     1316      237        but only that it was sent to the FEP for network transmission.  The
     1317      238        status value may be less than the total number of characters in the iovec
     1318      239        buffers within msghdr if the socket is nonblocking and no more data could
     1319      240        be immediately sent.
     1320      241        .SPB
     1321      242        If the sendmsg() function is unsuccessful, the status result contains
     1322      243        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1323      244        to determine the specific error condition.  The XSL$SENDMSG procedure
     1324      245        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1325      246        to the sendmsg() function.
     1326      247        .SPB
     1327      248        Sendmsg() may be used on sockets regardless of whether connect() has been
     1328      249        issued.
     1329      250        .SPB
     1330      251        If shutdown() has been invoked for this socket to inhibit transmission
     1331      252        of data, all sendmsg() operations report the error ESHUTDOWN.
     1332      253        ..::IT "Errors:"
     1333      254        Following are the possible error conditions reported when the sendmsg()
     1334      255        function is unsuccessful.  Equates for the possible values can be
     1335      256        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1336      257
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:165  
     1337      258        .FIF
     1338      259
     1339      260        C #define               PL6 %EQU
     1340      261        ----------------------- -----------------------
     1341      262        EBADF                   E$BADF
     1342      263        .FIN
     1343      264        The descriptor s is not appropriate to identify a socket.
     1344      265        .FIF
     1345      266
     1346      267        EMSGSIZE                E$MSGSIZE
     1347      268        .FIN
     1348      269        The specified buffers are too long to send atomically.
     1349      270        .FIF
     1350      271
     1351      272        ENOTSOCK                E$NOTSOCK
     1352      273        .FIN
     1353      274        The descriptor s is no longer valid to identify a socket.
     1354      275        .FIF
     1355      276
     1356      277        ESHUTDOWN               E$SHUTDOWN
     1357      278        .FIN
     1358      279        Can't send after socket shutdown.
     1359      280        .FIF
     1360      281
     1361      282        EWOULDBLOCK             E$WOULDBLOCK
     1362      283        .FIN
     1363      284        The data cannot be immediately sent.
     1364      285        .FIF
     1365      286        */
     1366      287        /*F* NAME: recvmsg() and XSL$RECVMSG  -- Read Scattered Data With Options and Addre
               287        ss
     1367      288        ..::IT "Purpose:"
     1368      289        .INL +4
     1369      290        Receives a message from a socket into multiple application-specified buffers,
     1370      291        along with the address of the message's sender.
     1371      292        ..::IT "C Usage:"
     1372      293        .INL 4
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:166  
     1373      294        .FIF
     1374      295        status = recvmsg( s, msghdr, flags );
     1375      296        ..::IT "PL6 Usage:"
     1376      297        .INL 4
     1377      298        .FIF
     1378      299        CALL XSL$RECVMSG( status, s, msghdr, flags );
     1379      300        ..::IT "Parameters:"
     1380      301        .INL 4
     1381      302        .FIF
     1382      303        s           integer socket descriptor
     1383      304
     1384      305        msghdr      msghdr structure
     1385      306
     1386      307        flags       integer bitflags of recvmsg options
     1387      308        ..::IT "Results:"
     1388      309        .INL 4
     1389      310        .FIF
     1390      311        status      integer number of characters received or error code
     1391      312
     1392      313        msghdr      msghdr structure
     1393      314        ..::IT "Description:"
     1394      315        The recvmsg() function receives a message from a connected socket and places
     1395      316        it in the buffers specified in the iovec array within msghdr.  Additionally,
     1396      317        the network address of the message's sender is provided in msghdr.
     1397      318        .SPB
     1398      319        The s parameter specifies the descriptor of the socket on which to receive.
     1399      320        .SPB
     1400      321        The msghdr parameter specifies a msghdr or XSL$MSGHDR structure containing
     1401      322        information specific to this invocation.
     1402      323        .SPB
     1403      324        The flags parameter specifies recvmsg options.  The desired options are
     1404      325        'ORed' together when coding the invocation.  The only options currently
     1405      326        implemented are "out-of-band" and "peek".  The out-of-band option receives
     1406      327        any message that was sent on the out-of-band data path if the socket supports
     1407      328        it.  It is selected by coding MSG_OOB or %XSL_MSG_OOB in C or PL6 source,
     1408      329        respectively.  The peek option copies a message into the buffers, but
     1409      330       additionally leaves it in the queue so subsequent recvmsg() invocations see the same
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:167  
               330         message.
     1410      331        It is selected by coding MSG_PEEK or %XSL_MSG_PEEK in C or PL6 source,
     1411      332        respectively.
     1412      333        .SPB
     1413      334        If the recvmsg() function is successful, the status result contains the
     1414      335        number of characters received into the iovec buffers within msghdr.  This
     1415      336        number is non-negative.  On datagram sockets, if the buffers are not large
     1416      337        enough to receive the entire message, the excess will be discarded.  The
     1417      338        network address of the message's sender is placed into the msg_name item
     1418      339        within msghdr, and msg_namelen is set to the number of significant characters
     1419      340        in msg_name.
     1420      341        .SPB
     1421      342        If the recvmsg() function is unsuccessful, the status result contains
     1422      343        EFAILURE or E$FAILURE and the application must inspect errno or XSL_ERRNO
     1423      344        to determine the specific error condition.  The XSL$RECVMSG procedure
     1424      345        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1425      346        to the recvmsg() function.
     1426      347        .SPB
     1427      348        If no data is available from a socket when recvmsg() is invoked, the action
     1428      349        taken depends on the socket mode.  The mode of a socket is defined
     1429      350        to be either "blocking" or "nonblocking".  If the socket is blocking
     1430      351        (which is the default mode) the application is blocked (i.e., suspended)
     1431      352        until data is received from the network.  If the socket is nonblocking,
     1432      353        the condition is treated as an EWOULDBLOCK error.
     1433      354        .SPB
     1434      355        The mode of a socket can be changed with either fcntl() or ioctl().
     1435      356        .SPB
     1436      357        If shutdown() has been invoked for this socket to inhibit reception of
     1437      358        data, or if the peer is no longer connected, all recvmsg() operations are
     1438      359        treated as if zero bytes of data were read.
     1439      360        ..::IT "Errors:"
     1440      361        Following are the possible error conditions reported when the recvmsg()
     1441      362        function is unsuccessful.  Equates for the possible values can be
     1442      363        found in <xsl_errno.h> or XSL_PERR_C for C or PL6 source, respectively.
     1443      364
     1444      365        .FIF
     1445      366
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:168  
     1446      367        C #define               PL6 %EQU
     1447      368        ----------------------- -----------------------
     1448      369        EBADF                   E$BADF
     1449      370        .FIN
     1450      371        The descriptor s is not appropriate to identify a socket.
     1451      372        .FIF
     1452      373
     1453      374        ENOTSOCK                E$NOTSOCK
     1454      375        .FIN
     1455      376        The descriptor s is no longer valid to identify a socket.
     1456      377        .FIF
     1457      378
     1458      379        EWOULDBLOCK             E$WOULDBLOCK
     1459      380        .FIN
     1460      381        There is no data available from this nonblocking socket.
     1461      382        .FIF
     1462      383        */
     1463      384        XSL$IOVECS: PROC( RESULT, SOCK#, PARM3, PARM4) ALTRET;

    384  0 000000   000000 700200 xent  XSL$IOVECS   TSX0  ! X66_AUTO_4
         0 000001   004350 000004                    ZERO    2280,4
         0 000002   000005 710000 0                  TRA     s:2025

     1464      385        %INCLUDE XSL_PERR_C;
     1465      440        %INCLUDE XSL_SOCKET_E;
     1466      698        %INCLUDE XSL_SOCKET_M;
     1467     1459            %XSL$IOVEC( STCLASS="BASED( PARM3$)");
     1468     1495            %XSL$MSGHDR( STCLASS="BASED( PARM3$)");
     1469     1557            %XSL$SOCKADDR;
     1470     1597        %INCLUDE XSL_INTERNAL_M;
     1471     1848            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
     1472     1992
     1473     1993    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
     1474     1994    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
     1475     1995    1       DCL XSL$QREAD ENTRY(4) ALTRET;
     1476     1996    1       DCL XSL$QRECVFROM ENTRY(7) ALTRET;
     1477     1997    1       DCL XSL$QSENDTO ENTRY(7) ALTRET;
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:169  
     1478     1998    1       DCL XSL$QWRITE ENTRY(4) ALTRET;
     1479     1999
     1480     2000    1       DCL XSL_ERRNO SBIN SYMREF;
     1481     2001    1       DCL XSL_SOCK$ REDEF XSL_ERRNO PTR;
     1482     2002    1       DCL XSL_SOCK$$ PTR SYMREF;
     1483     2003
     1484     2004    1       DCL BUF$ PTR;
     1485     2005    1       DCL XBUF CHAR( LEN) BASED( BUF$);
     1486     2006    1       DCL ENTRYFLAG SBIN;
     1487     2007        %EQU READV = 0;
     1488     2008        %EQU WRITEV = 1;
     1489     2009        %EQU RECVMSG = 2;
     1490     2010        %EQU SENDMSG = 3;
     1491     2011    1       DCL LEN SBIN;
     1492     2012    1       DCL MSGSIZE SBIN;
     1493     2013    1       DCL PARM3 UBIN;
     1494     2014    1       DCL PARM3$ PTR;
     1495     2015    1       DCL PARM4 UBIN;
     1496     2016    1       DCL RESULT SBIN;
     1497     2017    1       DCL SOCK# SBIN;
     1498     2018    1       DCL SOCK$ PTR;
     1499     2019    1       DCL XSOCK SBIN;
     1500     2020        %EQU VBUFSIZ = 9000;
     1501     2021    1       DCL VBUF CHAR(%VBUFSIZ);
     1502     2022
     1503     2023    1   XSL$READV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2023  0 000003   000000 700200 xent  XSL$READV    TSX0  ! X66_AUTO_4
         0 000004   004350 000004                    ZERO    2280,4

     1504     2024
     1505     2025    1       ENTRYFLAG = %READV;

   2025  0 000005   200010 450100                    STZ     ENTRYFLAG,,AUTO

     1506     2026    1       GOTO COMMONDCBN;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:170  
   2026  0 000006   000043 710000 0                  TRA     COMMONDCBN

     1507     2027
     1508     2028    1   XSL$QREADV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2028  0 000007   000000 700200 xent  XSL$QREADV   TSX0  ! X66_AUTO_4
         0 000010   004350 000004                    ZERO    2280,4

     1509     2029
     1510     2030    1       ENTRYFLAG = %READV;

   2030  0 000011   200010 450100                    STZ     ENTRYFLAG,,AUTO

     1511     2031    1       GOTO COMMONSOCK;

   2031  0 000012   000063 710000 0                  TRA     COMMONSOCK

     1512     2032
     1513     2033    1   XSL$WRITEV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2033  0 000013   000000 700200 xent  XSL$WRITEV   TSX0  ! X66_AUTO_4
         0 000014   004350 000004                    ZERO    2280,4

     1514     2034
     1515     2035    1       ENTRYFLAG = %WRITEV;

   2035  0 000015   000001 235007                    LDA     1,DL
         0 000016   200010 755100                    STA     ENTRYFLAG,,AUTO

     1516     2036    1       GOTO COMMONDCBN;

   2036  0 000017   000043 710000 0                  TRA     COMMONDCBN

     1517     2037
     1518     2038    1   XSL$QWRITEV: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2038  0 000020   000000 700200 xent  XSL$QWRITEV  TSX0  ! X66_AUTO_4
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:171  
         0 000021   004350 000004                    ZERO    2280,4

     1519     2039
     1520     2040    1       ENTRYFLAG = %WRITEV;

   2040  0 000022   000001 235007                    LDA     1,DL
         0 000023   200010 755100                    STA     ENTRYFLAG,,AUTO

     1521     2041    1       GOTO COMMONSOCK;

   2041  0 000024   000063 710000 0                  TRA     COMMONSOCK

     1522     2042
     1523     2043    1   XSL$RECVMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2043  0 000025   000000 700200 xent  XSL$RECVMSG  TSX0  ! X66_AUTO_4
         0 000026   004350 000004                    ZERO    2280,4

     1524     2044
     1525     2045    1       ENTRYFLAG = %RECVMSG;

   2045  0 000027   000002 235007                    LDA     2,DL
         0 000030   200010 755100                    STA     ENTRYFLAG,,AUTO

     1526     2046    1       GOTO COMMONDCBN;

   2046  0 000031   000043 710000 0                  TRA     COMMONDCBN

     1527     2047
     1528     2048    1   XSL$QRECVMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2048  0 000032   000000 700200 xent  XSL$QRECVMSG TSX0  ! X66_AUTO_4
         0 000033   004350 000004                    ZERO    2280,4

     1529     2049
     1530     2050    1       ENTRYFLAG = %RECVMSG;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:172  
   2050  0 000034   000002 235007                    LDA     2,DL
         0 000035   200010 755100                    STA     ENTRYFLAG,,AUTO

     1531     2051    1       GOTO COMMONSOCK;

   2051  0 000036   000063 710000 0                  TRA     COMMONSOCK

     1532     2052
     1533     2053    1   XSL$SENDMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2053  0 000037   000000 700200 xent  XSL$SENDMSG  TSX0  ! X66_AUTO_4
         0 000040   004350 000004                    ZERO    2280,4

     1534     2054
     1535     2055    1       ENTRYFLAG = %SENDMSG;

   2055  0 000041   000003 235007                    LDA     3,DL
         0 000042   200010 755100                    STA     ENTRYFLAG,,AUTO

     1536     2056    1   COMMONDCBN:
     1537     2057    1       CALL XSL$DCBNPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   2057  0 000043   000000 236000 1     COMMONDCBN   LDQ     0
         0 000044   200004 235100                    LDA     @SOCK#,,AUTO
         0 000045   204340 757100                    STAQ    TEMP+1,,AUTO
         0 000046   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000047   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000050   000000 701000 xent               TSX1    XSL$DCBNPTR
         0 000051   000452 702000 0                  TSX2    BAILOUT

     1538     2058    1       XSOCK = XSL_SOCK$->SOCK.SOCK#;

   2058  0 000052   000000 470400 xsym               LDP0    XSL_ERRNO
         0 000053   000000 236100                    LDQ     0,,PR0
         0 000054   000777 376007                    ANQ     511,DL
         0 000055   200015 756100                    STQ     XSOCK,,AUTO

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:173  
     1539     2059    1       GOTO LATER;

   2059  0 000056   000075 710000 0                  TRA     LATER

     1540     2060
     1541     2061    1   XSL$QSENDMSG: ENTRY( RESULT, SOCK#, PARM3, PARM4) ALTRET;

   2061  0 000057   000000 700200 xent  XSL$QSENDMSG TSX0  ! X66_AUTO_4
         0 000060   004350 000004                    ZERO    2280,4

     1542     2062
     1543     2063    1       ENTRYFLAG = %SENDMSG;

   2063  0 000061   000003 235007                    LDA     3,DL
         0 000062   200010 755100                    STA     ENTRYFLAG,,AUTO

     1544     2064    1   COMMONSOCK:
     1545     2065    1       CALL XSL$SOCKPTR( SOCK#, XSL_SOCK$) ALTRET( BAILOUT);

   2065  0 000063   000000 236000 1     COMMONSOCK   LDQ     0
         0 000064   200004 235100                    LDA     @SOCK#,,AUTO
         0 000065   204340 757100                    STAQ    TEMP+1,,AUTO
         0 000066   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000067   000020 631400 xsym               EPPR1   B_VECTNIL+16
         0 000070   000000 701000 xent               TSX1    XSL$SOCKPTR
         0 000071   000452 702000 0                  TSX2    BAILOUT

     1546     2066    1       XSOCK = SOCK#;

   2066  0 000072   200004 470500                    LDP0    @SOCK#,,AUTO
         0 000073   000000 235100                    LDA     0,,PR0
         0 000074   200015 755100                    STA     XSOCK,,AUTO

     1547     2067    1   LATER:
     1548     2068    1       SOCK$ = XSL_SOCK$;

   2068  0 000075   000000 236000 xsym  LATER        LDQ     XSL_ERRNO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:174  
         0 000076   200014 756100                    STQ     SOCK$,,AUTO

     1549     2069    1       PARM3$ = ADDR( PARM3);

   2069  0 000077   200005 236100                    LDQ     @PARM3,,AUTO
         0 000100   200013 756100                    STQ     PARM3$,,AUTO

     1550     2070    2       DO CASE( ENTRYFLAG);

   2070  0 000101   200010 235100                    LDA     ENTRYFLAG,,AUTO
         0 000102   000004 115007                    CMPA    4,DL
         0 000103   000105 602005 0                  TNC     s:2070+4,AL
         0 000104   000451 710000 0                  TRA     SUCCESS
         0 000105   000111 710000 0                  TRA     s:2073
         0 000106   000171 710000 0                  TRA     s:2086
         0 000107   000253 710000 0                  TRA     s:2100
         0 000110   000345 710000 0                  TRA     s:2118

     1551     2071    2           CASE( %READV);

     1552     2072                    /* PARM3 is an iovec array, PARM4 counts array items */
     1553     2073    3               IF PARM4 = 1 THEN DO;

   2073  0 000111   200006 470500                    LDP0    @PARM4,,AUTO
         0 000112   000000 235100                    LDA     0,,PR0
         0 000113   000001 115007                    CMPA    1,DL
         0 000114   000123 601000 0                  TNZ     s:2078

     1554     2074    3                   BUF$ = XSL$IOVEC.IOV_BASE$(0);

   2074  0 000115   200013 471500                    LDP1    PARM3$,,AUTO
         0 000116   100000 236100                    LDQ     0,,PR1
         0 000117   200007 756100                    STQ     BUF$,,AUTO

     1555     2075    3                   LEN = XSL$IOVEC.IOV_LEN(0);

   2075  0 000120   100001 235100                    LDA     1,,PR1
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:175  
         0 000121   200011 755100                    STA     LEN,,AUTO

     1556     2076    3                   END;

   2076  0 000122   000141 710000 0                  TRA     s:2081

     1557     2077    3               ELSE DO;

     1558     2078    3                   CALL COUNTVBUF( PARM3, PARM4, LEN);

   2078  0 000123   200011 631500                    EPPR1   LEN,,AUTO
         0 000124   204333 451500                    STP1    @IOVLEN+1,,AUTO
         0 000125   200006 236100                    LDQ     @PARM4,,AUTO
         0 000126   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000127   200005 236100                    LDQ     @PARM3,,AUTO
         0 000130   204331 756100                    STQ     VBUF+2251,,AUTO
         0 000131   000571 701000 0                  TSX1    COUNTVBUF
         0 000132   000000 011000                    NOP     0

     1559     2079    3                   LEN = MINIMUM( LEN, %VBUFSIZ);

   2079  0 000133   021450 236007                    LDQ     9000,DL
         0 000134   000137 604000 0                  TMI     s:2079+4
         0 000135   200011 116100                    CMPQ    LEN,,AUTO
         0 000136   000140 604400 0                  TMOZ    s:2079+5
         0 000137   200011 236100                    LDQ     LEN,,AUTO
         0 000140   200011 756100                    STQ     LEN,,AUTO

     1560     2080    3                   END;

     1561     2081    2               CALL XSL$QREAD( RESULT, XSOCK, XBUF, LEN) ALTRET( BAILOUT);

   2081  0 000141   200011 630500                    EPPR0   LEN,,AUTO
         0 000142   204343 450500                    STP0    TEMP+4,,AUTO
         0 000143   200007 236100                    LDQ     BUF$,,AUTO
         0 000144   204342 756100                    STQ     TEMP+3,,AUTO
         0 000145   200015 631500                    EPPR1   XSOCK,,AUTO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:176  
         0 000146   204341 451500                    STP1    TEMP+2,,AUTO
         0 000147   200003 236100                    LDQ     @RESULT,,AUTO
         0 000150   204340 756100                    STQ     TEMP+1,,AUTO
         0 000151   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000152   000022 631400 xsym               EPPR1   B_VECTNIL+18
         0 000153   000000 701000 xent               TSX1    XSL$QREAD
         0 000154   000452 702000 0                  TSX2    BAILOUT

     1562     2082    2               IF PARM4 ~= 1 THEN

   2082  0 000155   200006 470500                    LDP0    @PARM4,,AUTO
         0 000156   000000 235100                    LDA     0,,PR0
         0 000157   000001 115007                    CMPA    1,DL
         0 000160   000451 600000 0                  TZE     SUCCESS

     1563     2083    2                   CALL DUMPVBUF( PARM3, PARM4, RESULT);

   2083  0 000161   200003 236100                    LDQ     @RESULT,,AUTO
         0 000162   200006 235100                    LDA     @PARM4,,AUTO
         0 000163   204332 757100                    STAQ    @IOVEC+1,,AUTO
         0 000164   200005 236100                    LDQ     @PARM3,,AUTO
         0 000165   204331 756100                    STQ     VBUF+2251,,AUTO
         0 000166   000523 701000 0                  TSX1    DUMPVBUF
         0 000167   000000 011000                    NOP     0
         0 000170   000451 710000 0                  TRA     SUCCESS

     1564     2084    2           CASE( %WRITEV);

     1565     2085                    /* PARM3 is an iovec array, PARM4 counts array items */
     1566     2086    2               CALL COUNTVBUF( PARM3, PARM4, MSGSIZE);

   2086  0 000171   200012 630500                    EPPR0   MSGSIZE,,AUTO
         0 000172   204333 450500                    STP0    @IOVLEN+1,,AUTO
         0 000173   200006 236100                    LDQ     @PARM4,,AUTO
         0 000174   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000175   200005 236100                    LDQ     @PARM3,,AUTO
         0 000176   204331 756100                    STQ     VBUF+2251,,AUTO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:177  
         0 000177   000571 701000 0                  TSX1    COUNTVBUF
         0 000200   000000 011000                    NOP     0

     1567     2087    3               IF PARM4 = 1 THEN DO;

   2087  0 000201   200006 470500                    LDP0    @PARM4,,AUTO
         0 000202   000000 235100                    LDA     0,,PR0
         0 000203   000001 115007                    CMPA    1,DL
         0 000204   000213 601000 0                  TNZ     s:2092

     1568     2088    3                   BUF$ = XSL$IOVEC.IOV_BASE$(0);

   2088  0 000205   200013 471500                    LDP1    PARM3$,,AUTO
         0 000206   100000 236100                    LDQ     0,,PR1
         0 000207   200007 756100                    STQ     BUF$,,AUTO

     1569     2089    3                   LEN = XSL$IOVEC.IOV_LEN(0);

   2089  0 000210   100001 235100                    LDA     1,,PR1
         0 000211   200011 755100                    STA     LEN,,AUTO

     1570     2090    3                   END;

   2090  0 000212   000223 710000 0                  TRA     s:2093

     1571     2091    2               ELSE
     1572     2092    2                   CALL LOADVBUF( PARM3, PARM4, LEN);

   2092  0 000213   200011 631500                    EPPR1   LEN,,AUTO
         0 000214   204333 451500                    STP1    @IOVLEN+1,,AUTO
         0 000215   200006 236100                    LDQ     @PARM4,,AUTO
         0 000216   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000217   200005 236100                    LDQ     @PARM3,,AUTO
         0 000220   204331 756100                    STQ     VBUF+2251,,AUTO
         0 000221   000460 701000 0                  TSX1    LOADVBUF
         0 000222   000000 011000                    NOP     0

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:178  
     1573     2093    3               IF MSGSIZE > LEN AND SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;

   2093  0 000223   200012 236100                    LDQ     MSGSIZE,,AUTO
         0 000224   200011 116100                    CMPQ    LEN,,AUTO
         0 000225   000236 604400 0                  TMOZ    s:2097
         0 000226   200014 470500                    LDP0    SOCK$,,AUTO
         0 000227   000000 236100                    LDQ     0,,PR0
         0 000230   000777 376003                    ANQ     511,DU
         0 000231   000002 116003                    CMPQ    2,DU
         0 000232   000236 601000 0                  TNZ     s:2097

     1574     2094    3                   XSL_ERRNO = %E$MSGSIZE;

   2094  0 000233   000143 235007                    LDA     99,DL
         0 000234   000000 755000 xsym               STA     XSL_ERRNO

     1575     2095    3                   GOTO BAILOUT;

   2095  0 000235   000452 710000 0                  TRA     BAILOUT

     1576     2096    3                   END;
     1577     2097    2               CALL XSL$QWRITE( RESULT, XSOCK, XBUF, LEN) ALTRET( BAILOUT);

   2097  0 000236   200011 630500                    EPPR0   LEN,,AUTO
         0 000237   204343 450500                    STP0    TEMP+4,,AUTO
         0 000240   200007 236100                    LDQ     BUF$,,AUTO
         0 000241   204342 756100                    STQ     TEMP+3,,AUTO
         0 000242   200015 631500                    EPPR1   XSOCK,,AUTO
         0 000243   204341 451500                    STP1    TEMP+2,,AUTO
         0 000244   200003 236100                    LDQ     @RESULT,,AUTO
         0 000245   204340 756100                    STQ     TEMP+1,,AUTO
         0 000246   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000247   000022 631400 xsym               EPPR1   B_VECTNIL+18
         0 000250   000000 701000 xent               TSX1    XSL$QWRITE
         0 000251   000452 702000 0                  TSX2    BAILOUT
         0 000252   000451 710000 0                  TRA     SUCCESS

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:179  
     1578     2098    2           CASE( %RECVMSG);

     1579     2099                    /* PARM3 is a msghdr structure, PARM4 is flags */
     1580     2100    3               IF XSL$MSGHDR.MSG_IOVLEN = 1 THEN DO;

   2100  0 000253   200013 470500                    LDP0    PARM3$,,AUTO
         0 000254   000003 235100                    LDA     3,,PR0
         0 000255   000001 115007                    CMPA    1,DL
         0 000256   000265 601000 0                  TNZ     s:2105

     1581     2101    3                   BUF$ = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_BASE$(0);

   2101  0 000257   000002 471500                    LDP1    2,,PR0
         0 000260   100000 236100                    LDQ     0,,PR1
         0 000261   200007 756100                    STQ     BUF$,,AUTO

     1582     2102    3                   LEN = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_LEN(0);

   2102  0 000262   100001 235100                    LDA     1,,PR1
         0 000263   200011 755100                    STA     LEN,,AUTO

     1583     2103    3                   END;

   2103  0 000264   000303 710000 0                  TRA     s:2109

     1584     2104    3               ELSE DO;

     1585     2105    3                   CALL COUNTVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,

   2105  0 000265   000002 471500                    LDP1    2,,PR0
         0 000266   200011 633500                    EPPR3   LEN,,AUTO
         0 000267   204333 453500                    STP3    @IOVLEN+1,,AUTO
         0 000270   000003 036003                    ADLQ    3,DU
         0 000271   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000272   204331 451500                    STP1    VBUF+2251,,AUTO
         0 000273   000571 701000 0                  TSX1    COUNTVBUF
         0 000274   000000 011000                    NOP     0
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:180  

     1586     2106    3                     XSL$MSGHDR.MSG_IOVLEN, LEN);
     1587     2107    3                   LEN = MINIMUM( LEN, %VBUFSIZ);

   2107  0 000275   021450 236007                    LDQ     9000,DL
         0 000276   000301 604000 0                  TMI     s:2107+4
         0 000277   200011 116100                    CMPQ    LEN,,AUTO
         0 000300   000302 604400 0                  TMOZ    s:2107+5
         0 000301   200011 236100                    LDQ     LEN,,AUTO
         0 000302   200011 756100                    STQ     LEN,,AUTO

     1588     2108    3                   END;

     1589     2109    2               CALL XSL$QRECVFROM( RESULT, XSOCK, XBUF, LEN, PARM4,

   2109  0 000303   200013 470500                    LDP0    PARM3$,,AUTO
         0 000304   000000 471500                    LDP1    0,,PR0
         0 000305   200013 236100                    LDQ     PARM3$,,AUTO
         0 000306   000001 036003                    ADLQ    1,DU
         0 000307   204346 756100                    STQ     TEMP+7,,AUTO
         0 000310   204345 451500                    STP1    TEMP+6,,AUTO
         0 000311   200006 236100                    LDQ     @PARM4,,AUTO
         0 000312   204344 756100                    STQ     TEMP+5,,AUTO
         0 000313   200011 633500                    EPPR3   LEN,,AUTO
         0 000314   204343 453500                    STP3    TEMP+4,,AUTO
         0 000315   200007 236100                    LDQ     BUF$,,AUTO
         0 000316   204342 756100                    STQ     TEMP+3,,AUTO
         0 000317   200015 634500                    EPPR4   XSOCK,,AUTO
         0 000320   204341 454500                    STP4    TEMP+2,,AUTO
         0 000321   200003 236100                    LDQ     @RESULT,,AUTO
         0 000322   204340 756100                    STQ     TEMP+1,,AUTO
         0 000323   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000324   000025 631400 xsym               EPPR1   B_VECTNIL+21
         0 000325   000000 701000 xent               TSX1    XSL$QRECVFROM
         0 000326   000452 702000 0                  TSX2    BAILOUT

     1590     2110    2                 XSL$MSGHDR.MSG_NAME$->XSL$SOCKADDR,
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:181  
     1591     2111    2                 XSL$MSGHDR.MSG_NAMELEN)
     1592     2112    2                 ALTRET( BAILOUT);
     1593     2113    2               IF XSL$MSGHDR.MSG_IOVLEN ~= 1 THEN

   2113  0 000327   200013 470500                    LDP0    PARM3$,,AUTO
         0 000330   000003 235100                    LDA     3,,PR0
         0 000331   000001 115007                    CMPA    1,DL
         0 000332   000451 600000 0                  TZE     SUCCESS

     1594     2114    2                   CALL DUMPVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,

   2114  0 000333   000002 471500                    LDP1    2,,PR0
         0 000334   200003 236100                    LDQ     @RESULT,,AUTO
         0 000335   204333 756100                    STQ     @IOVLEN+1,,AUTO
         0 000336   200013 236100                    LDQ     PARM3$,,AUTO
         0 000337   000003 036003                    ADLQ    3,DU
         0 000340   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000341   204331 451500                    STP1    VBUF+2251,,AUTO
         0 000342   000523 701000 0                  TSX1    DUMPVBUF
         0 000343   000000 011000                    NOP     0
         0 000344   000451 710000 0                  TRA     SUCCESS

     1595     2115    2                     XSL$MSGHDR.MSG_IOVLEN, RESULT);
     1596     2116    2           CASE( %SENDMSG);

     1597     2117                    /* PARM3 is a msghdr structure, PARM4 is flags */
     1598     2118    2               IF XSL$MSGHDR.MSG_ACCRIGHTS$ ~= ADDR( NIL) OR

   2118  0 000345   200013 470500                    LDP0    PARM3$,,AUTO
         0 000346   000004 236100                    LDQ     4,,PR0
         0 000347   000001 116000 xsym               CMPQ    B_VECTNIL+1
         0 000350   000353 601000 0                  TNZ     s:2120
         0 000351   000005 235100                    LDA     5,,PR0
         0 000352   000356 600000 0                  TZE     s:2123

     1599     2119    3                 XSL$MSGHDR.MSG_ACCRIGHTSLEN ~= 0 THEN DO;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:182  
     1600     2120    3                   XSL_ERRNO = %E$OPNOTSUPP;

   2120  0 000353   000150 235007                    LDA     104,DL
         0 000354   000000 755000 xsym               STA     XSL_ERRNO

     1601     2121    3                   GOTO BAILOUT;

   2121  0 000355   000452 710000 0                  TRA     BAILOUT

     1602     2122    3                   END;
     1603     2123    2               CALL COUNTVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,

   2123  0 000356   000002 471500                    LDP1    2,,PR0
         0 000357   200012 633500                    EPPR3   MSGSIZE,,AUTO
         0 000360   204333 453500                    STP3    @IOVLEN+1,,AUTO
         0 000361   200013 236100                    LDQ     PARM3$,,AUTO
         0 000362   000003 036003                    ADLQ    3,DU
         0 000363   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000364   204331 451500                    STP1    VBUF+2251,,AUTO
         0 000365   000571 701000 0                  TSX1    COUNTVBUF
         0 000366   000000 011000                    NOP     0

     1604     2124    2                 XSL$MSGHDR.MSG_IOVLEN, MSGSIZE);
     1605     2125    3               IF XSL$MSGHDR.MSG_IOVLEN = 1 THEN DO;

   2125  0 000367   200013 470500                    LDP0    PARM3$,,AUTO
         0 000370   000003 235100                    LDA     3,,PR0
         0 000371   000001 115007                    CMPA    1,DL
         0 000372   000401 601000 0                  TNZ     s:2130

     1606     2126    3                   BUF$ = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_BASE$(0);

   2126  0 000373   000002 471500                    LDP1    2,,PR0
         0 000374   100000 236100                    LDQ     0,,PR1
         0 000375   200007 756100                    STQ     BUF$,,AUTO

     1607     2127    3                   LEN = XSL$MSGHDR.MSG_IOV$->XSL$IOVEC.IOV_LEN(0);
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:183  

   2127  0 000376   100001 235100                    LDA     1,,PR1
         0 000377   200011 755100                    STA     LEN,,AUTO

     1608     2128    3                   END;

   2128  0 000400   000412 710000 0                  TRA     s:2132

     1609     2129    2               ELSE
     1610     2130    2                   CALL LOADVBUF( XSL$MSGHDR.MSG_IOV$->XSL$IOVEC,

   2130  0 000401   000002 471500                    LDP1    2,,PR0
         0 000402   200011 633500                    EPPR3   LEN,,AUTO
         0 000403   204333 453500                    STP3    @IOVLEN+1,,AUTO
         0 000404   200013 236100                    LDQ     PARM3$,,AUTO
         0 000405   000003 036003                    ADLQ    3,DU
         0 000406   204332 756100                    STQ     @IOVEC+1,,AUTO
         0 000407   204331 451500                    STP1    VBUF+2251,,AUTO
         0 000410   000460 701000 0                  TSX1    LOADVBUF
         0 000411   000000 011000                    NOP     0

     1611     2131    2                     XSL$MSGHDR.MSG_IOVLEN, LEN);
     1612     2132    3               IF MSGSIZE > LEN AND SOCK.TYPE = %XSL_SOCK_DGRAM THEN DO;

   2132  0 000412   200012 236100                    LDQ     MSGSIZE,,AUTO
         0 000413   200011 116100                    CMPQ    LEN,,AUTO
         0 000414   000425 604400 0                  TMOZ    s:2136
         0 000415   200014 470500                    LDP0    SOCK$,,AUTO
         0 000416   000000 236100                    LDQ     0,,PR0
         0 000417   000777 376003                    ANQ     511,DU
         0 000420   000002 116003                    CMPQ    2,DU
         0 000421   000425 601000 0                  TNZ     s:2136

     1613     2133    3                   XSL_ERRNO = %E$MSGSIZE;

   2133  0 000422   000143 235007                    LDA     99,DL
         0 000423   000000 755000 xsym               STA     XSL_ERRNO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:184  

     1614     2134    3                   GOTO BAILOUT;

   2134  0 000424   000452 710000 0                  TRA     BAILOUT

     1615     2135    3                   END;
     1616     2136    2               CALL XSL$QSENDTO( RESULT, XSOCK, XBUF, LEN, PARM4,

   2136  0 000425   200013 470500                    LDP0    PARM3$,,AUTO
         0 000426   000000 471500                    LDP1    0,,PR0
         0 000427   200013 236100                    LDQ     PARM3$,,AUTO
         0 000430   000001 036003                    ADLQ    1,DU
         0 000431   204346 756100                    STQ     TEMP+7,,AUTO
         0 000432   204345 451500                    STP1    TEMP+6,,AUTO
         0 000433   200006 236100                    LDQ     @PARM4,,AUTO
         0 000434   204344 756100                    STQ     TEMP+5,,AUTO
         0 000435   200011 633500                    EPPR3   LEN,,AUTO
         0 000436   204343 453500                    STP3    TEMP+4,,AUTO
         0 000437   200007 236100                    LDQ     BUF$,,AUTO
         0 000440   204342 756100                    STQ     TEMP+3,,AUTO
         0 000441   200015 634500                    EPPR4   XSOCK,,AUTO
         0 000442   204341 454500                    STP4    TEMP+2,,AUTO
         0 000443   200003 236100                    LDQ     @RESULT,,AUTO
         0 000444   204340 756100                    STQ     TEMP+1,,AUTO
         0 000445   204340 630500                    EPPR0   TEMP+1,,AUTO
         0 000446   000025 631400 xsym               EPPR1   B_VECTNIL+21
         0 000447   000000 701000 xent               TSX1    XSL$QSENDTO
         0 000450   000452 702000 0                  TSX2    BAILOUT

     1617     2137    2                 XSL$MSGHDR.MSG_NAME$->XSL$SOCKADDR,
     1618     2138    2                 XSL$MSGHDR.MSG_NAMELEN)
     1619     2139    2                 ALTRET( BAILOUT);
     1620     2140    2           END;

     1621     2141    1   SUCCESS:
     1622     2142    1       RETURN;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:185  
   2142  0 000451   000000 702200 xent  SUCCESS      TSX2  ! X66_ARET

     1623     2143    1   BAILOUT:
     1624     2144    1       RESULT = %E$FAILURE;

   2144  0 000452   000001 335007       BAILOUT      LCA     1,DL
         0 000453   200003 470500                    LDP0    @RESULT,,AUTO
         0 000454   000000 755100                    STA     0,,PR0

     1625     2145    1       ALTRETURN;

   2145  0 000455   000000 702200 xent               TSX2  ! X66_AALT

     1626     2146
     1627     2147    1   MUNGEVBUF: PROC( IOVEC, IOVLEN, VLEN);

   2147  0 000456   204330 741300       MUNGEVBUF    STX1  ! VBUF+2250,,AUTO
         0 000457   000461 710000 0                  TRA     s:2195

     1628     2148
     1629     2149    2       DCL B$CHARS CHAR( LEN) BASED CALIGNED;
     1630     2150    2       DCL I SBIN;
     1631     2151    2       DCL IDX SBIN;
     1632     2152            %XSL$IOVEC( FPTN=IOVEC, STCLASS=);
     1633     2188    2       DCL IOVLEN SBIN;
     1634     2189    2       DCL LEN SBIN;
     1635     2190    2       DCL TEMP SBIN;
     1636     2191    2       DCL VLEN SBIN;
     1637     2192
     1638     2193    2   LOADVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* assemble iovec items into vbuf */

   2193  0 000460   204330 741300       LOADVBUF     STX1  ! VBUF+2250,,AUTO

     1639     2194
     1640     2195    2       VLEN = 0;

   2195  0 000461   204333 470500                    LDP0    @VLEN,,AUTO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:186  
         0 000462   000000 450100                    STZ     0,,PR0

     1641     2196    3       DO I = 0 TO IOVLEN - 1;

   2196  0 000463   204334 450100                    STZ     I,,AUTO
         0 000464   000515 710000 0                  TRA     s:2201+1

     1642     2197    3           LEN = MINIMUM( IOVEC.IOV_LEN( I), %VBUFSIZ - VLEN);

   2197  0 000465   204333 470500                    LDP0    @VLEN,,AUTO
         0 000466   021450 236007                    LDQ     9000,DL
         0 000467   000000 136100                    SBLQ    0,,PR0
         0 000470   204334 235100                    LDA     I,,AUTO
         0 000471   000001 735000                    ALS     1
         0 000472   204331 471500                    LDP1    @IOVEC,,AUTO
         0 000473   100001 116105                    CMPQ    1,AL,PR1
         0 000474   000476 604400 0                  TMOZ    s:2197+9
         0 000475   100001 236105                    LDQ     1,AL,PR1
         0 000476   204336 756100                    STQ     LEN,,AUTO

     1643     2198    3           IF LEN > 0 THEN

   2198  0 000477   000000 116003                    CMPQ    0,DU
         0 000500   000511 604400 0                  TMOZ    s:2200

     1644     2199    3               SUBSTR( VBUF, VLEN, LEN) = IOVEC.IOV_BASE$( I)->B$CHARS;

   2199  0 000501   000000 235100                    LDA     0,,PR0
         0 000502   204334 236100                    LDQ     I,,AUTO
         0 000503   000001 736000                    QLS     1
         0 000504   100000 473506                    LDP3    0,QL,PR1
         0 000505   204336 720100                    LXL0    LEN,,AUTO
         0 000506   040145 100540                    MLR     fill='040'O
         0 000507   300000 000010                    ADSC9   0,,PR3                   cn=0,n=*X0
         0 000510   200016 000010                    ADSC9   VBUF,A,AUTO              cn=0,n=*X0

     1645     2200    3           VLEN = VLEN + LEN;
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:187  

   2200  0 000511   000000 236100                    LDQ     0,,PR0
         0 000512   204336 036100                    ADLQ    LEN,,AUTO
         0 000513   000000 756100                    STQ     0,,PR0

     1646     2201    3           END;

   2201  0 000514   204334 054100                    AOS     I,,AUTO
         0 000515   204332 471500                    LDP1    @IOVLEN,,AUTO
         0 000516   204334 236100                    LDQ     I,,AUTO
         0 000517   100000 116100                    CMPQ    0,,PR1
         0 000520   000465 604000 0                  TMI     s:2197

     1647     2202    2       RETURN;

   2202  0 000521   204330 221300                    LDX1  ! VBUF+2250,,AUTO
         0 000522   000001 702211                    TSX2  ! 1,X1

     1648     2203
     1649     2204    2   DUMPVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* disperse vbuf into iovec items */

   2204  0 000523   204330 741300       DUMPVBUF     STX1  ! VBUF+2250,,AUTO

     1650     2205
     1651     2206    2       IDX = 0;

   2206  0 000524   204335 450100                    STZ     IDX,,AUTO

     1652     2207    2       TEMP = VLEN;

   2207  0 000525   204333 470500                    LDP0    @VLEN,,AUTO
         0 000526   000000 235100                    LDA     0,,PR0
         0 000527   204337 755100                    STA     TEMP,,AUTO

     1653     2208    3       DO I = 0 TO IOVLEN - 1;

   2208  0 000530   204334 450100                    STZ     I,,AUTO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:188  
         0 000531   000563 710000 0                  TRA     s:2216+1

     1654     2209    3           LEN = MINIMUM( TEMP, IOVEC.IOV_LEN( I));

   2209  0 000532   204334 235100                    LDA     I,,AUTO
         0 000533   000001 735000                    ALS     1
         0 000534   204331 470500                    LDP0    @IOVEC,,AUTO
         0 000535   000001 236105                    LDQ     1,AL,PR0
         0 000536   204337 116100                    CMPQ    TEMP,,AUTO
         0 000537   000541 604400 0                  TMOZ    s:2209+7
         0 000540   204337 236100                    LDQ     TEMP,,AUTO
         0 000541   204336 756100                    STQ     LEN,,AUTO

     1655     2210    3           IF LEN > 0 THEN

   2210  0 000542   000000 116003                    CMPQ    0,DU
         0 000543   000553 604400 0                  TMOZ    s:2212

     1656     2211    3               IOVEC.IOV_BASE$( I)->B$CHARS = SUBSTR( VBUF, IDX, LEN);

   2211  0 000544   000000 471505                    LDP1    0,AL,PR0
         0 000545   000000 620006                    EAX0    0,QL
         0 000546   204335 236100                    LDQ     IDX,,AUTO
         0 000547   204336 721100                    LXL1    LEN,,AUTO
         0 000550   040140 100546                    MLR     fill='040'O
         0 000551   200016 000010                    ADSC9   VBUF,Q,AUTO              cn=0,n=*X0
         0 000552   100000 000011                    ADSC9   0,,PR1                   cn=0,n=*X1

     1657     2212    3           IDX = IDX + LEN;

   2212  0 000553   204335 236100                    LDQ     IDX,,AUTO
         0 000554   204336 036100                    ADLQ    LEN,,AUTO
         0 000555   204335 756100                    STQ     IDX,,AUTO

     1658     2213    3           TEMP = TEMP - LEN;

   2213  0 000556   204337 236100                    LDQ     TEMP,,AUTO
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:189  
         0 000557   204336 136100                    SBLQ    LEN,,AUTO
         0 000560   204337 756100                    STQ     TEMP,,AUTO

     1659     2214    3           IF TEMP <= 0 THEN

   2214  0 000561   000567 604400 0                  TMOZ    s:2217

     1660     2215    3               EXIT;
     1661     2216    3           END;

   2216  0 000562   204334 054100                    AOS     I,,AUTO
         0 000563   204332 470500                    LDP0    @IOVLEN,,AUTO
         0 000564   204334 236100                    LDQ     I,,AUTO
         0 000565   000000 116100                    CMPQ    0,,PR0
         0 000566   000532 604000 0                  TMI     s:2209

     1662     2217    2       RETURN;

   2217  0 000567   204330 221300                    LDX1  ! VBUF+2250,,AUTO
         0 000570   000001 702211                    TSX2  ! 1,X1

     1663     2218
     1664     2219    2   COUNTVBUF: ENTRY( IOVEC, IOVLEN, VLEN);  /* total lengths of iovec items */

   2219  0 000571   204330 741300       COUNTVBUF    STX1  ! VBUF+2250,,AUTO

     1665     2220
     1666     2221    2       VLEN = 0;

   2221  0 000572   204333 470500                    LDP0    @VLEN,,AUTO
         0 000573   000000 450100                    STZ     0,,PR0

     1667     2222    3       DO I = 0 TO IOVLEN - 1;

   2222  0 000574   204334 450100                    STZ     I,,AUTO
         0 000575   000606 710000 0                  TRA     s:2224+1

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:190  
     1668     2223    3           VLEN = VLEN + IOVEC.IOV_LEN( I);

   2223  0 000576   204333 470500                    LDP0    @VLEN,,AUTO
         0 000577   204334 235100                    LDA     I,,AUTO
         0 000600   000001 735000                    ALS     1
         0 000601   204331 471500                    LDP1    @IOVEC,,AUTO
         0 000602   000000 236100                    LDQ     0,,PR0
         0 000603   100001 036105                    ADLQ    1,AL,PR1
         0 000604   000000 756100                    STQ     0,,PR0

     1669     2224    3           END;

   2224  0 000605   204334 054100                    AOS     I,,AUTO
         0 000606   204332 471500                    LDP1    @IOVLEN,,AUTO
         0 000607   204334 236100                    LDQ     I,,AUTO
         0 000610   100000 116100                    CMPQ    0,,PR1
         0 000611   000576 604000 0                  TMI     s:2223

     1670     2225    2       BUF$ = ADDR( VBUF);

   2225  0 000612   200016 633500                    EPPR3   VBUF,,AUTO
         0 000613   200007 453500                    STP3    BUF$,,AUTO

     1671     2226    2       RETURN;

   2226  0 000614   204330 221300                    LDX1  ! VBUF+2250,,AUTO
         0 000615   000001 702211                    TSX2  ! 1,X1

(unnamed)
 Sect OctLoc
   1     000   000000 006000                                                    ....
     1672     2227
     1673     2228    2   END MUNGEVBUF;
     1674     2229
     1675     2230    1   END XSL$IOVECS;
     1676     2231        %EOD;

PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:191  
--  Include file information  --

   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_SOCKET_E.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is never referenced.
      No diagnostics issued in procedure XSL$IOVECS.
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:192  

 **** Variables and constants ****

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

  4331-0-0/w PTR         r     1 @IOVEC                  4332-0-0/w PTR         r     1 @IOVLEN
     5-0-0/w PTR         r     1 @PARM3                     6-0-0/w PTR         r     1 @PARM4
     3-0-0/w PTR         r     1 @RESULT                    4-0-0/w PTR         r     1 @SOCK#
  4333-0-0/w PTR         r     1 @VLEN                      7-0-0/w PTR         r     1 BUF$
    10-0-0/w SBIN        r     1 ENTRYFLAG               4334-0-0/w SBIN        r     1 I
  4335-0-0/w SBIN        r     1 IDX                       *0-0-0/w STRC(72)    r     1 IOVEC(0:0)
    *0-0-0/w SBIN        r     1 IOVLEN                    11-0-0/w SBIN        r     1 LEN
  4336-0-0/w SBIN        r     1 LEN                       12-0-0/w SBIN        r     1 MSGSIZE
    *0-0-0/w UBIN        r     1 PARM3                     13-0-0/w PTR         r     1 PARM3$
    *0-0-0/w UBIN        r     1 PARM4                     *0-0-0/w SBIN        r     1 RESULT
    *0-0-0/w SBIN        r     1 SOCK#                     14-0-0/w PTR         r     1 SOCK$
  4337-0-0/w SBIN        r     1 TEMP                      16-0-0/c CHAR(9000)  r     1 VBUF
    *0-0-0/w SBIN        r     1 VLEN                      15-0-0/w SBIN        r     1 XSOCK

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w SBIN        r     1 XSL_ERRNO                  0-0-0/w PTR         r     1 XSL_SOCK$

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/c ACHR        r     1 B$CHARS                    0-0-0/w STRC(720)   r     1 SOCK
     0-0-0/c ACHR        r     1 XBUF
     0-0-0/w STRC(72)    r     1 XSL$IOVEC(0:0)
     0-0-0/w STRC(216)   r     1 XSL$MSGHDR                 0-0-0/w STRC(180)   r     1 XSL$SOCKADDR
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:193  


   Procedure XSL$IOVECS requires 398 words for executable code.
   Procedure XSL$IOVECS requires 2280 words of local(AUTO) storage.
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:194  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:195  
          MINI XREF LISTING

B$CHARS IN PROCEDURE MUNGEVBUF
      2149**DCL      2199>>ASSIGN   2211<<ASSIGN
BAILOUT
      2144**LABEL    2057--CALLALT  2065--CALLALT  2081--CALLALT  2095--GOTO     2097--CALLALT  2109--CALLALT
      2121--GOTO     2134--GOTO     2136--CALLALT
BUF$
      2004**DCL      2005--IMP-PTR  2074<<ASSIGN   2081>>CALL     2088<<ASSIGN   2097>>CALL     2101<<ASSIGN
      2109>>CALL     2126<<ASSIGN   2136>>CALL     2225<<ASSIGN
COMMONDCBN
      2057**LABEL    2026--GOTO     2036--GOTO     2046--GOTO
COMMONSOCK
      2065**LABEL    2031--GOTO     2041--GOTO     2051--GOTO
COUNTVBUF IN PROCEDURE MUNGEVBUF
      2219**ENTRY    2078--CALL     2086--CALL     2105--CALL     2123--CALL
DUMPVBUF IN PROCEDURE MUNGEVBUF
      2204**ENTRY    2083--CALL     2114--CALL
ENTRYFLAG
      2006**DCL      2025<<ASSIGN   2030<<ASSIGN   2035<<ASSIGN   2040<<ASSIGN   2045<<ASSIGN   2050<<ASSIGN
      2055<<ASSIGN   2063<<ASSIGN   2070>>DOCASE
I IN PROCEDURE MUNGEVBUF
      2150**DCL      2196<<DOINDEX  2197>>ASSIGN   2199>>ASSIGN   2208<<DOINDEX  2209>>ASSIGN   2211>>ASSIGN
      2222<<DOINDEX  2223>>ASSIGN
IDX IN PROCEDURE MUNGEVBUF
      2151**DCL      2206<<ASSIGN   2211>>ASSIGN   2212<<ASSIGN   2212>>ASSIGN
IOVEC IN PROCEDURE MUNGEVBUF
      2171**DCL      2147--PROC     2193--ENTRY    2204--ENTRY    2219--ENTRY
IOVEC.IOV_BASE$ IN PROCEDURE MUNGEVBUF
      2181**DCL      2199>>ASSIGN   2211>>ASSIGN
IOVEC.IOV_LEN IN PROCEDURE MUNGEVBUF
      2186**DCL      2197>>ASSIGN   2209>>ASSIGN   2223>>ASSIGN
IOVLEN IN PROCEDURE MUNGEVBUF
      2188**DCL      2147--PROC     2193--ENTRY    2196>>DOINDEX  2204--ENTRY    2208>>DOINDEX  2219--ENTRY
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:196  
      2222>>DOINDEX
LATER
      2068**LABEL    2059--GOTO
LEN
      2011**DCL      2005--IMP-SIZ  2075<<ASSIGN   2078<>CALL     2079<<ASSIGN   2079>>ASSIGN   2081>>CALL
      2081<>CALL     2089<<ASSIGN   2092<>CALL     2093>>IF       2097>>CALL     2097<>CALL     2102<<ASSIGN
      2105<>CALL     2107<<ASSIGN   2107>>ASSIGN   2109>>CALL     2109<>CALL     2127<<ASSIGN   2130<>CALL
      2132>>IF       2136>>CALL     2136<>CALL
LEN IN PROCEDURE MUNGEVBUF
      2189**DCL      2149--IMP-SIZ  2197<<ASSIGN   2198>>IF       2199>>ASSIGN   2199>>ASSIGN   2200>>ASSIGN
      2209<<ASSIGN   2210>>IF       2211>>ASSIGN   2211>>ASSIGN   2212>>ASSIGN   2213>>ASSIGN
LOADVBUF IN PROCEDURE MUNGEVBUF
      2193**ENTRY    2092--CALL     2130--CALL
MSGSIZE
      2012**DCL      2086<>CALL     2093>>IF       2123<>CALL     2132>>IF
PARM3
      2013**DCL       384--PROC     2023--ENTRY    2028--ENTRY    2033--ENTRY    2038--ENTRY    2043--ENTRY
      2048--ENTRY    2053--ENTRY    2061--ENTRY    2069--ASSIGN   2078<>CALL     2083<>CALL     2086<>CALL
      2092<>CALL
PARM3$
      2014**DCL      1478--IMP-PTR  1512--IMP-PTR  2069<<ASSIGN   2074>>ASSIGN   2075>>ASSIGN   2088>>ASSIGN
      2089>>ASSIGN   2100>>IF       2101>>ASSIGN   2102>>ASSIGN   2105>>CALL     2105>>CALL     2109>>CALL
      2109>>CALL     2113>>IF       2114>>CALL     2114>>CALL     2118>>IF       2118>>IF       2123>>CALL
      2123>>CALL     2125>>IF       2126>>ASSIGN   2127>>ASSIGN   2130>>CALL     2130>>CALL     2136>>CALL
      2136>>CALL
PARM4
      2015**DCL       384--PROC     2023--ENTRY    2028--ENTRY    2033--ENTRY    2038--ENTRY    2043--ENTRY
      2048--ENTRY    2053--ENTRY    2061--ENTRY    2073>>IF       2078<>CALL     2082>>IF       2083<>CALL
      2086<>CALL     2087>>IF       2092<>CALL     2109<>CALL     2136<>CALL
RESULT
      2016**DCL       384--PROC     2023--ENTRY    2028--ENTRY    2033--ENTRY    2038--ENTRY    2043--ENTRY
      2048--ENTRY    2053--ENTRY    2061--ENTRY    2081<>CALL     2083<>CALL     2097<>CALL     2109<>CALL
      2114<>CALL     2136<>CALL     2144<<ASSIGN
SOCK.NBACCEPT_SOCK$
      1988**DCL      1989--REDEF
SOCK.SOCK#
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:197  
      1875**DCL      2058>>ASSIGN
SOCK.TYPE
      1873**DCL      2093>>IF       2132>>IF
SOCK#
      2017**DCL       384--PROC     2023--ENTRY    2028--ENTRY    2033--ENTRY    2038--ENTRY    2043--ENTRY
      2048--ENTRY    2053--ENTRY    2057<>CALL     2061--ENTRY    2065<>CALL     2066>>ASSIGN
SOCK$
      2018**DCL      1866--IMP-PTR  2068<<ASSIGN   2093>>IF       2132>>IF
TEMP IN PROCEDURE MUNGEVBUF
      2190**DCL      2207<<ASSIGN   2209>>ASSIGN   2213<<ASSIGN   2213>>ASSIGN   2214>>IF
VBUF
      2021**DCL      2199<<ASSIGN   2211>>ASSIGN   2225--ASSIGN
VLEN IN PROCEDURE MUNGEVBUF
      2191**DCL      2147--PROC     2193--ENTRY    2195<<ASSIGN   2197>>ASSIGN   2199>>ASSIGN   2200<<ASSIGN
      2200>>ASSIGN   2204--ENTRY    2207>>ASSIGN   2219--ENTRY    2221<<ASSIGN   2223<<ASSIGN   2223>>ASSIGN
XBUF
      2005**DCL      2081<>CALL     2097<>CALL     2109<>CALL     2136<>CALL
XSL$DCBNPTR
      1993**DCL-ENT  2057--CALL
XSL$IOVEC
      1478**DCL      2105<>CALL     2114<>CALL     2123<>CALL     2130<>CALL
XSL$IOVEC.IOV_BASE$
      1488**DCL      2074>>ASSIGN   2088>>ASSIGN   2101>>ASSIGN   2126>>ASSIGN
XSL$IOVEC.IOV_LEN
      1493**DCL      2075>>ASSIGN   2089>>ASSIGN   2102>>ASSIGN   2127>>ASSIGN
XSL$MSGHDR.MSG_ACCRIGHTS$
      1550**DCL      2118>>IF
XSL$MSGHDR.MSG_ACCRIGHTSLEN
      1555**DCL      2118>>IF
XSL$MSGHDR.MSG_IOV$
      1539**DCL      2101>>ASSIGN   2102>>ASSIGN   2105>>CALL     2114>>CALL     2123>>CALL     2126>>ASSIGN
      2127>>ASSIGN   2130>>CALL
XSL$MSGHDR.MSG_IOVLEN
      1545**DCL      2100>>IF       2105<>CALL     2113>>IF       2114<>CALL     2123<>CALL     2125>>IF
      2130<>CALL
XSL$MSGHDR.MSG_NAME$
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:198  
      1525**DCL      2109>>CALL     2136>>CALL
XSL$MSGHDR.MSG_NAMELEN
      1533**DCL      2109<>CALL     2136<>CALL
XSL$QREAD
      1995**DCL-ENT  2081--CALL
XSL$QRECVFROM
      1996**DCL-ENT  2109--CALL
XSL$QSENDTO
      1997**DCL-ENT  2136--CALL
XSL$QWRITE
      1998**DCL-ENT  2097--CALL
XSL$SOCKADDR
      1574**DCL      2109<>CALL     2136<>CALL
XSL$SOCKPTR
      1994**DCL-ENT  2065--CALL
XSL_ERRNO
      2000**DCL      2001--REDEF    2094<<ASSIGN   2120<<ASSIGN   2133<<ASSIGN
XSL_SOCK$
      2001**DCL      2057<>CALL     2058>>ASSIGN   2065<>CALL     2068>>ASSIGN
XSOCK
      2019**DCL      2058<<ASSIGN   2066<<ASSIGN   2081<>CALL     2097<>CALL     2109<>CALL     2136<>CALL
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:199  
              *** CROSS REFERENCE LISTING ***
    **     DENOTES     IDENTIFIER DEFINITION
    <<                 IDENTIFIER'S VALUE SET
    >>                 IDENTIFIER'S VALUE USED
    <>                 IDENTIFIER SET AND/OR USED
    --                 IDENTIFIER REFERENCED
PL6.E3A0      #003=XSL$IOVECS File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:33 Page:200  
              MINI UREF LISTING

MUNGEVBUF    2147**PROC
SUCCESS    2142**LABEL
XSL$IOVECS     384**PROC
XSL$QREADV    2028**ENTRY
XSL$QRECVMSG    2048**ENTRY
XSL$QSENDMSG    2061**ENTRY
XSL$QWRITEV    2038**ENTRY
XSL$READV    2023**ENTRY
XSL$RECVMSG    2043**ENTRY
XSL$SENDMSG    2053**ENTRY
XSL$WRITEV    2033**ENTRY
XSL_SOCK$$    2002**DCL

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:201  
     1677        1        /*T***********************************************************/
     1678        2        /*T*                                                         */
     1679        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     1680        4        /*T*                                                         */
     1681        5        /*T***********************************************************/
     1682        6        /*F* NAME: select() and XSL$SELECT  --  Select for Read, Write, or Exceptions
     1683        7
     1684        8        Purpose:
     1685        9
     1686       10        .INL +4
     1687       11        .FIN
     1688       12        For specified sets of sockets, determines whether data is available for
     1689       13        reading, whether space is available for writing data, or whether an
     1690       14        exceptional condition is pending.
     1691       15        ..::IT "C Usage:"
     1692       16        .INL 4
     1693       17        .FIF
     1694       18        status = select( numbits, rmask, wmask, emask, &timeout );
     1695       19        ..::IT "PL6 Usage:"
     1696       20        .INL 4
     1697       21        .FIF
     1698       22        CALL XSL$SELECT( status, numbits, rmask, wmask, emask, timeout );
     1699       23        ..::IT "Parameters:"
     1700       24        .INL 4
     1701       25        .FIF
     1702       26        numbits     integer number of significant bits in each mask
     1703       27
     1704       28        rmask       bit array of sockets to be checked for data available
     1705       29
     1706       30        wmask       bit array of sockets to be checked for space available
     1707       31
     1708       32        emask       bit array of sockets to be checked for exceptions
     1709       33
     1710       34        timeout     structure specifying time to delay before checking
     1711       35        ..::IT "Results:"
     1712       36        .INL 4
     1713       37        .FIF
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:202  
     1714       38        status      integer number of sockets selected by any mask
     1715       39
     1716       40        rmask       bit array of sockets with data available
     1717       41
     1718       42        wmask       bit array of sockets with space available
     1719       43
     1720       44        emask       bit array of sockets with pending exceptions
     1721       45        ..::IT "Description:"
     1722       46        The numbits parameter specifies the number of significant bits in the three
     1723       47        mask parameters rmask, wmask, and emask.  Each mask is a bit array whose
     1724       48        bits correspond one to one with the application's DCBs.  Since sockets
     1725       49        are DCBs (plus other context), the masks can be used to specify which
     1726       50        sockets are to be checked for the various conditions.  Any mask bits that
     1727       51        correspond to DCBs not currently in use as sockets are ignored.  Also note
     1728       52        that since bits in the masks are numbered from zero, numbits must be
     1729       53        one plus the highest-numbered DCB specified in any mask.
     1730       54        .SPB
     1731       55        It is not necessary to specify all three masks.  Coding zero for any mask
     1732       56        effectively causes it to be unspecified.  In PL6 source, omitting a mask
     1733       57        from the argument list has the same effect.
     1734       58        .SPB
     1735       59        Application programmers using C can make use of the following macros to help
     1736       60        with bitmask manipulation.  The number of bits allowed in a bitmask is
     1737       61        given by FD_SETSIZE.
     1738       62
     1739       63        .FIF
     1740       64            FD_ZERO( &bitmask )
     1741       65                Initializes a bitmask to all zeroes.
     1742       66            FD_CLR( bit, &bitmask )
     1743       67                Clears the specified bit in the bitmask.
     1744       68            FD_SET( bit, &bitmask )
     1745       69                Sets the specified bit in the bitmask.
     1746       70            FD_ISSET( bit, &bitmask )
     1747       71                Returns true if the specified bit is set in the bitmask.
     1748       72        .FIN
     1749       73        .SPB
     1750       74        The optional rmask parameter specifies which sockets are to be checked for
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:203  
     1751       75        available data.  On return from select(), only bits of rmask that correspond
     1752       76        to sockets that have data available are set to 1.  If data is available
     1753       77        for a given socket, then a read() of the socket is guaranteed not to block.
     1754       78        .SPB
     1755       79        The optional wmask parameter specifies which sockets are to be checked for
     1756       80        space available to write data.  On return from select(), only bits of wmask
     1757       81        that correspond to sockets with space available are set to 1.  If space
     1758       82        is available for a given socket, then a write() to the socket is guaranteed
     1759       83        not to block, so far as CP-6 Host to FEP throttling allows.
     1760       84        .SPB
     1761       85        The optional emask parameter specifies which sockets are to be checked for
     1762       86        an exceptional condition.  On return from select(), only bits of emask that
     1763       87        correspond to sockets that have an exceptional condition are set to 1.
     1764       88        .SPB
     1765       89        The optional timeout parameter specifies how long to delay before checking
     1766       90        for the selected conditions.  If specified, timeout is a structure with two
     1767       91        elements: an integer number of seconds from 0 to 32767 and an integer number
     1768       92        of microseconds.  If timeout is not specified, a delay of 86399 seconds
     1769       93        (one second short of a day) is performed.  The delay is terminated if the
     1770       94        condition of any of the selected sockets changes, and the result masks are
     1771       95        set appropriately.
     1772       96        .SPB
     1773       97        The timeout parameter is regarded as unspecified in C source by coding NULL in
     1774       98        its place.  In PL6 source it can simply be omitted from the argument list.
     1775       99        .SPB
     1776      100        If the select() function is successful, the status result is the number
     1777      101        of sockets with any of the selected conditions.
     1778      102        .SPB
     1779      103        If the select() function is unsuccessful, the status result contains
     1780      104        EFAILURE or E$FAILURE.  The XSL$SELECT procedure
     1781      105        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1782      106        to the select() function.
     1783      107        .SPB
     1784      108        In the case of unsuccessful select(), the mask parameters are unchanged.
     1785      109        ..::IT "Errors:"
     1786      110        Any error conditions reported by select() can be assumed to be the result
     1787      111        of earlier socket operations.  The select() function does not diagnose
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:204  
     1788      112        any error conditions itself.
     1789      113        */
     1790      114        XSL$SELECT: PROC( RESULT, NUMFDS, RMSK, WMSK, EMSK, TIMEOUT) ALTRET;
     1791      115        %INCLUDE CP_6;
     1792      196        %INCLUDE CP_6_SUBS;
     1793      736            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
     1794      750            %FPT_WAIT( FPTN=FPT@WAIT, STCLASS=AUTO);
     1795      764    1       DCL 1 BVEC BASED DALIGNED,2 * BIT(36),2 BASE$ PTR;
     1796      765            %F$DCB;
     1797      822        %INCLUDE XSL_PERR_C;
     1798      877        %INCLUDE XSL_SOCKET_M;
     1799     1638        %INCLUDE XSL_INTERNAL_M;
     1800     1889            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
     1801     2033            %XSL$SOCKHD( STCLASS="BASED( XSL_SOCK$$)");
     1802     2066        %INCLUDE XSL_SOCKMSGS_E;
     1803     2112        %INCLUDE XSL_SOCKMSGS_M;
     1804     3245            %XSL$SELECTRQS( FPTN=XSL_SELECTRQS, STCLASS="CONSTANT SYMDEF");
     1805     3275            %XSL$SELECTRQS( STCLASS="BASED( XSL_KEYBUF$)");
     1806     3305            %XSL$SELECTRSP( STCLASS="BASED( XSL_KEYBUF$)");
     1807     3336
     1808     3337    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
     1809     3338    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
     1810     3339    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
     1811     3340    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
     1812     3341    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
     1813     3342    1       DCL XSL$EVLOG ENTRY(2);
     1814     3343
     1815     3344    1       DCL XSL_ERRNO SBIN SYMREF;
     1816     3345    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
     1817     3346    1       DCL XSL_SOCK$$ PTR SYMREF;
     1818     3347
     1819     3348    1       DCL ALLMASK BIT(72) ALIGNED;
     1820     3349    1       DCL ALLMASKBITS(0:71) REDEF ALLMASK BIT(1) UNAL;
     1821     3350    1       DCL B$UBIN(0:0) UBIN BASED;
     1822     3351    1       DCL COUNT SBIN;
     1823     3352    1       DCL EMSK BIT(XNUMFDS) ALIGNED;
     1824     3353    1       DCL XEMSKBITS(0:71) BIT(1) UNAL;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:205  
     1825     3354    1       DCL I SBIN;
     1826     3355    1       DCL NUMFDS SBIN;
     1827     3356    1       DCL QUICK BIT(1) UNAL;
     1828     3357    1       DCL RESULT SBIN;
     1829     3358    1       DCL RMSK BIT(XNUMFDS) ALIGNED;
     1830     3359    1       DCL XRMSKBITS(0:71) BIT(1) UNAL;
     1831     3360    1       DCL SELECTING BIT(1) UNAL;  /* at least one proxy is select()ing */
     1832     3361    1       DCL SOCK$ PTR;
     1833     3362    1       DCL SECS UBIN;
     1834     3363    1       DCL USECS UBIN;
     1835     3364    1       DCL TIMEOUT SBIN;
     1836     3365    1       DCL CUTMASK BIT(72) ALIGNED;
     1837     3366    1       DCL CUTMASKBITS(0:71) REDEF CUTMASK BIT(1) UNAL;
     1838     3367    1       DCL XTIMEOUT SBIN;
     1839     3368    1       DCL XNUMFDS SBIN;
     1840     3369    1       DCL WMSK BIT(XNUMFDS) ALIGNED;
     1841     3370    1       DCL XWMSKBITS(0:71) BIT(1) UNAL;
     1842     3371
     1843     3372    1       QUICK = '0'B;
     1844     3373    1       GOTO COMMON;
     1845     3374
     1846     3375    1   XSL$QSELECT: ENTRY( RESULT, NUMFDS, RMSK, WMSK, EMSK, TIMEOUT) ALTRET;
     1847     3376
     1848     3377    1       QUICK = '1'B;
     1849     3378    1   COMMON:
     1850     3379    1       XNUMFDS = MINIMUM (72, NUMFDS);
     1851     3380    1       XSL_ERRNO = 0;
     1852     3381    1       COUNT = 0;
     1853     3382    1       SELECTING = '0'B;
     1854     3383    1       IF ADDR( RMSK) = ADDR( NIL) THEN
     1855     3384    1           XRMSKBITS = '0'B;
     1856     3385    1       ELSE
     1857     3386    1           XRMSKBITS = RMSK;
     1858     3387    1       IF ADDR( WMSK) = ADDR( NIL) THEN
     1859     3388    1           XWMSKBITS = '0'B;
     1860     3389    1       ELSE
     1861     3390    1           XWMSKBITS = WMSK;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:206  
     1862     3391    1       IF ADDR( EMSK) = ADDR( NIL) THEN
     1863     3392    1           XEMSKBITS = '0'B;
     1864     3393    1       ELSE
     1865     3394    1           XEMSKBITS = EMSK;
     1866     3395    1       IF ADDR( TIMEOUT) = ADDR( NIL) THEN
     1867     3396    1           XTIMEOUT = -1;
     1868     3397    2       ELSE DO;
     1869     3398    2           SECS = TIMEOUT;
     1870     3399    2           IF QUICK THEN
     1871     3400    2               USECS = 0;
     1872     3401    2           ELSE
     1873     3402    2               USECS = ADDR( TIMEOUT)->B$UBIN( 1);
     1874     3403    2           XTIMEOUT = MINIMUM( 32767, SECS + USECS / 1000000);
     1875     3404    2           END;
     1876     3405    1       ALLMASK = XRMSKBITS | XWMSKBITS | XEMSKBITS;
     1877     3406    1       CUTMASK = ALLMASK;
     1878     3407            /* First start the requested waiting in the Xps. */
     1879     3408    2       IF XTIMEOUT ~= 0 THEN DO;
     1880     3409    2   LOOP1:
     1881     3410    3           DO I = XNUMFDS - 1 DOWNTO 0;
     1882     3411    4               IF ALLMASKBITS( I) THEN DO;
     1883     3412    5                   IF QUICK THEN DO;
     1884     3413    5                       CALL XSL$SOCKPTR( I, SOCK$) ALTRET( DONE1);
     1885     3414    5                       GOTO COMMON1;
     1886     3415    5                       END;
     1887     3416    4                   ELSE
     1888     3417    4                       CALL XSL$DCBNPTR( I, SOCK$) ALTRET( DONE1);
     1889     3418    4   COMMON1:
     1890     3419    4                   IF NOT SOCK.FLAGS.BIND AND NOT SOCK.FLAGS.CONNECT THEN
     1891     3420    4                       GOTO DONE1;
     1892     3421    5                   IF SOCK.MAXRDS = 0 OR SOCK.FLAGS.LISTEN THEN DO;
     1893     3422    5                       SELECTING = '1'B;
     1894     3423    5                       XSL$SELECTRQS = XSL_SELECTRQS;
     1895     3424    5                       XSL$SELECTRQS.TIMEOUT = XTIMEOUT;
     1896     3425    5                       XSL$SELECTRQS.EMSK = XEMSKBITS( I);
     1897     3426    5                       XSL$SELECTRQS.WMSK = XWMSKBITS( I);
     1898     3427    5                       XSL$SELECTRQS.RMSK = XRMSKBITS( I);
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:207  
     1899     3428    5                       CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SELECTRQS));
     1900     3429    5                       END;
     1901     3430    5                   ELSE DO;
     1902     3431    6                       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS
              3431                                AND
     1903     3432    6                         SOCK.BUFPND# <= SOCK.MAXBUF);
     1904     3433    6                           CALL XSL$GETBUF( SOCK) ALTRET( LOOKNOW);
     1905     3434    6                           END;
     1906     3435    5   LOOKNOW:
     1907     3436    5                       IF ( SOCK.FLAGS.SELREAD AND XRMSKBITS( I)) OR
     1908     3437    5                         ( SOCK.FLAGS.SELWRITE AND XWMSKBITS( I)) OR
     1909     3438    5                         ( SOCK.FLAGS.SELEXCEP AND XEMSKBITS( I)) THEN
     1910     3439    5                           COUNT = COUNT + 1;
     1911     3440    5                       END;
     1912     3441    4   DONE1:
     1913     3442    4                   CUTMASKBITS( I) = '0'B;
     1914     3443    4                   IF CUTMASK = '0'B THEN EXIT LOOP1;
     1915     3444    4                   END;
     1916     3445    3               END;
     1917     3446    2           IF COUNT > 0 AND NOT SELECTING THEN EXIT;
     1918     3447                /* Then do the requested wait here */
     1919     3448                /* If a proxy finishes, he'll wake us up. */
     1920     3449    2           FPT@WAIT = XSL_WAIT1DAY;
     1921     3450    2           ADDR( FPT@WAIT.V_) -> BVEC.BASE$ = ADDR( FPT@WAIT.V);
     1922     3451    3           IF XTIMEOUT > 0 THEN DO;
     1923     3452    4               IF USECS > 0 THEN DO;
     1924     3453    4                   FPT@WAIT.V.UTYPE# = %TUN#;
     1925     3454    4                   FPT@WAIT.V.UNITS# = SECS*100 + USECS/10000;
     1926     3455    4                   END;
     1927     3456    4               ELSE DO;
     1928     3457    4                   FPT@WAIT.V.UTYPE# = %SEC#;
     1929     3458    4                   FPT@WAIT.V.UNITS# = SECS;
     1930     3459    4                   END;
     1931     3460    3               END;
     1932     3461    2           CALL XSL$EVLOG( 'WT', 0);
     1933     3462    2           CALL M$WAIT( FPT@WAIT);
     1934     3463    2           END;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:208  
     1935     3464
     1936     3465            /* Waiting is over, poll the proxies to see which one woke us up. */
     1937     3466            /* Or, poll the proxies if no wait was requested. */
     1938     3467
     1939     3468    1       COUNT = 0;
     1940     3469    1       CUTMASK = ALLMASK;
     1941     3470    1   LOOP2:
     1942     3471    2       DO I = XNUMFDS - 1 DOWNTO 0;
     1943     3472    3           IF ALLMASKBITS( I) THEN DO;
     1944     3473    4               IF QUICK THEN DO;
     1945     3474    4                   CALL XSL$SOCKPTR( I, SOCK$) ALTRET( DONE2);
     1946     3475    4                   GOTO COMMON2;
     1947     3476    4                   END;
     1948     3477    3               ELSE
     1949     3478    3                   CALL XSL$DCBNPTR( I, SOCK$) ALTRET( DONE2);
     1950     3479    3   COMMON2:
     1951     3480    4               IF SOCK.FLAGS.CP6ERR THEN DO;
     1952     3481                        /* this blows, but what're ya gonna do? */
     1953     3482    4                   XSL_ERRNO = BITBIN( SOCK.CP6ERROR);
     1954     3483    4                   GOTO BAILOUT;
     1955     3484    4                   END;
     1956     3485    4               IF NOT SOCK.FLAGS.BIND AND NOT SOCK.FLAGS.CONNECT THEN DO;
     1957     3486    4                   XEMSKBITS( I) = '0'B;
     1958     3487    4                   XWMSKBITS( I) = '0'B;
     1959     3488    4                   XRMSKBITS( I) = '0'B;
     1960     3489    4                   GOTO DONE2;
     1961     3490    4                   END;
     1962     3491    4               IF SOCK.MAXRDS = 0 OR SOCK.FLAGS.LISTEN THEN DO;
     1963     3492    4                   XSL$SELECTRQS = XSL_SELECTRQS;
     1964     3493    4                   XSL$SELECTRQS.EMSK = XEMSKBITS( I);
     1965     3494    4                   XSL$SELECTRQS.WMSK = XWMSKBITS( I);
     1966     3495    4                   XSL$SELECTRQS.RMSK = XRMSKBITS( I);
     1967     3496    4                   CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SELECTRQS));
     1968     3497    4                   CALL XSL$CL_READ( SOCK);
     1969     3498    5                   IF XSL$SELECTRSP.RESULT < 0 THEN DO;
     1970     3499    5                       XSL_ERRNO = XSL$SELECTRSP.ERRNO;
     1971     3500    5   BAILOUT:
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:209  
     1972     3501    5                       RESULT = %E$FAILURE;
     1973     3502    5                       ALTRETURN;
     1974     3503    5                       END;
     1975     3504    5                   ELSE DO;
     1976     3505    5                       XEMSKBITS( I) = XSL$SELECTRSP.EMSK;
     1977     3506    5                       XWMSKBITS( I) = XSL$SELECTRSP.WMSK;
     1978     3507    5                       XRMSKBITS( I) = XSL$SELECTRSP.RMSK;
     1979     3508    5                       COUNT = COUNT + XSL$SELECTRSP.RESULT;
     1980     3509    5                       END;
     1981     3510    4                   END;
     1982     3511    4               ELSE DO;
     1983     3512    4                   IF ( SOCK.FLAGS.SELREAD AND XRMSKBITS( I)) OR
     1984     3513    4                     ( SOCK.FLAGS.SELWRITE AND XWMSKBITS( I)) OR
     1985     3514    4                     ( SOCK.FLAGS.SELEXCEP AND XEMSKBITS( I)) THEN
     1986     3515    4                       COUNT = COUNT + 1;
     1987     3516    4                   XEMSKBITS( I) = SOCK.FLAGS.SELEXCEP;
     1988     3517    4                   XWMSKBITS( I) = SOCK.FLAGS.SELWRITE;
     1989     3518    4                   XRMSKBITS( I) = SOCK.FLAGS.SELREAD;
     1990     3519    4                   END;
     1991     3520    3   DONE2:
     1992     3521    3               CUTMASKBITS( I) = '0'B;
     1993     3522    3               IF CUTMASK = '0'B THEN EXIT LOOP2;
     1994     3523    3               END;
     1995     3524    2           END;
     1996     3525    1       IF ADDR( RMSK) ~= ADDR( NIL) THEN
     1997     3526    1           RMSK = XRMSKBITS;
     1998     3527    1       IF ADDR( WMSK) ~= ADDR( NIL) THEN
     1999     3528    1           WMSK = XWMSKBITS;
     2000     3529    1       IF ADDR( EMSK) ~= ADDR( NIL) THEN
     2001     3530    1           EMSK = XEMSKBITS;
     2002     3531    1       RESULT = COUNT;
     2003     3532    1       RETURN;
     2004     3533
     2005     3534    1   END XSL$SELECT;

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:210  
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   CP_6_SUBS.:LIBRARY  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$SELECT.

   Procedure XSL$SELECT requires 492 words for executable code.
   Procedure XSL$SELECT requires 44 words of local(AUTO) storage.

    No errors detected in file XSL$SOCKET2.:TCA2TSI    .

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:211  

 Object Unit name= XSL$SELECT                                 File name= XSL$SOCKET2.:TCA2TOU
 UTS= NOV 16 '97 14:34:31.00 SUN                              Compiler= PL-6/E31         Sev=      00
 SharedLib= :SHARED_SYSTEM                                    Alt SharedLib=


    ****  Control sections  ****

 Sect   Type Bound  Init  Size OctSiz  Section name(segment info)
    0   DCB   even  none     0      0  M$UC
    1  RoData even  UTS      3      3  XSL$SELECT
    2   Proc  even  none   492    754  XSL$SELECT
    3  RoData even  none     5      5  XSL$SELECT

    ****  Entry defs  ****

                              Check   Calling
                             calling  sequence
  Sect OctLoc Primary Altret sequence   type   Parms  Name
     2      0   yes    yes     yes      Std        6  XSL$SELECT
     2      4          yes     yes      Std        6  XSL$QSELECT

  ****  Data defs  ****

 Sect OctLoc  Name                           Sect OctLoc  Name
    1      0  XSL_SELECTRQS
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:212  

  ****  Entry refs  ****

         Check        Calling
        calling       sequence
Altret sequence SRef   type   Args  Name
 yes     yes           Std       2 XSL$SOCKPTR
 yes     yes           Std       4 XSL$CL_WRITE
 yes     yes           Std       2 XSL$DCBNPTR
 yes     yes           Std       2 XSL$GETBUF
 yes     yes           Std       3 XSL$CL_READ
         yes           Std       2 XSL$EVLOG
                       nStd      0 X66_AUTO_N
                       Std       0 B_CONSPOOL_D
                       nStd      0 X66_AALT
                       nStd      0 X66_ARET

  ****  Data refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     M$UC                                  XSL_WAIT1DAY                          XSL_ERRNO
r    XSL_KEYBUF$                           XSL_SOCK$$                            B_VECTNIL

  ****  Segment refs  ****

  Flags:  r = read only, s = secondary
Flgs Name                             Flgs Name                             Flgs Name
     ROSID                                 ISSID
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:213  


     1677        1        /*T***********************************************************/
     1678        2        /*T*                                                         */
     1679        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1997    */
     1680        4        /*T*                                                         */
     1681        5        /*T***********************************************************/
     1682        6        /*F* NAME: select() and XSL$SELECT  --  Select for Read, Write, or Exceptions
     1683        7
     1684        8        Purpose:
     1685        9
     1686       10        .INL +4
     1687       11        .FIN
     1688       12        For specified sets of sockets, determines whether data is available for
     1689       13        reading, whether space is available for writing data, or whether an
     1690       14        exceptional condition is pending.
     1691       15        ..::IT "C Usage:"
     1692       16        .INL 4
     1693       17        .FIF
     1694       18        status = select( numbits, rmask, wmask, emask, &timeout );
     1695       19        ..::IT "PL6 Usage:"
     1696       20        .INL 4
     1697       21        .FIF
     1698       22        CALL XSL$SELECT( status, numbits, rmask, wmask, emask, timeout );
     1699       23        ..::IT "Parameters:"
     1700       24        .INL 4
     1701       25        .FIF
     1702       26        numbits     integer number of significant bits in each mask
     1703       27
     1704       28        rmask       bit array of sockets to be checked for data available
     1705       29
     1706       30        wmask       bit array of sockets to be checked for space available
     1707       31
     1708       32        emask       bit array of sockets to be checked for exceptions
     1709       33
     1710       34        timeout     structure specifying time to delay before checking
     1711       35        ..::IT "Results:"
     1712       36        .INL 4
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:214  
     1713       37        .FIF
     1714       38        status      integer number of sockets selected by any mask
     1715       39
     1716       40        rmask       bit array of sockets with data available
     1717       41
     1718       42        wmask       bit array of sockets with space available
     1719       43
     1720       44        emask       bit array of sockets with pending exceptions
     1721       45        ..::IT "Description:"
     1722       46        The numbits parameter specifies the number of significant bits in the three
     1723       47        mask parameters rmask, wmask, and emask.  Each mask is a bit array whose
     1724       48        bits correspond one to one with the application's DCBs.  Since sockets
     1725       49        are DCBs (plus other context), the masks can be used to specify which
     1726       50        sockets are to be checked for the various conditions.  Any mask bits that
     1727       51        correspond to DCBs not currently in use as sockets are ignored.  Also note
     1728       52        that since bits in the masks are numbered from zero, numbits must be
     1729       53        one plus the highest-numbered DCB specified in any mask.
     1730       54        .SPB
     1731       55        It is not necessary to specify all three masks.  Coding zero for any mask
     1732       56        effectively causes it to be unspecified.  In PL6 source, omitting a mask
     1733       57        from the argument list has the same effect.
     1734       58        .SPB
     1735       59        Application programmers using C can make use of the following macros to help
     1736       60        with bitmask manipulation.  The number of bits allowed in a bitmask is
     1737       61        given by FD_SETSIZE.
     1738       62
     1739       63        .FIF
     1740       64            FD_ZERO( &bitmask )
     1741       65                Initializes a bitmask to all zeroes.
     1742       66            FD_CLR( bit, &bitmask )
     1743       67                Clears the specified bit in the bitmask.
     1744       68            FD_SET( bit, &bitmask )
     1745       69                Sets the specified bit in the bitmask.
     1746       70            FD_ISSET( bit, &bitmask )
     1747       71                Returns true if the specified bit is set in the bitmask.
     1748       72        .FIN
     1749       73        .SPB
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:215  
     1750       74        The optional rmask parameter specifies which sockets are to be checked for
     1751       75        available data.  On return from select(), only bits of rmask that correspond
     1752       76        to sockets that have data available are set to 1.  If data is available
     1753       77        for a given socket, then a read() of the socket is guaranteed not to block.
     1754       78        .SPB
     1755       79        The optional wmask parameter specifies which sockets are to be checked for
     1756       80        space available to write data.  On return from select(), only bits of wmask
     1757       81        that correspond to sockets with space available are set to 1.  If space
     1758       82        is available for a given socket, then a write() to the socket is guaranteed
     1759       83        not to block, so far as CP-6 Host to FEP throttling allows.
     1760       84        .SPB
     1761       85        The optional emask parameter specifies which sockets are to be checked for
     1762       86        an exceptional condition.  On return from select(), only bits of emask that
     1763       87        correspond to sockets that have an exceptional condition are set to 1.
     1764       88        .SPB
     1765       89        The optional timeout parameter specifies how long to delay before checking
     1766       90        for the selected conditions.  If specified, timeout is a structure with two
     1767       91        elements: an integer number of seconds from 0 to 32767 and an integer number
     1768       92        of microseconds.  If timeout is not specified, a delay of 86399 seconds
     1769       93        (one second short of a day) is performed.  The delay is terminated if the
     1770       94        condition of any of the selected sockets changes, and the result masks are
     1771       95        set appropriately.
     1772       96        .SPB
     1773       97        The timeout parameter is regarded as unspecified in C source by coding NULL in
     1774       98        its place.  In PL6 source it can simply be omitted from the argument list.
     1775       99        .SPB
     1776      100        If the select() function is successful, the status result is the number
     1777      101        of sockets with any of the selected conditions.
     1778      102        .SPB
     1779      103        If the select() function is unsuccessful, the status result contains
     1780      104        EFAILURE or E$FAILURE.  The XSL$SELECT procedure
     1781      105        additionally ALTRETURNs if it is unsuccessful; it is otherwise identical
     1782      106        to the select() function.
     1783      107        .SPB
     1784      108        In the case of unsuccessful select(), the mask parameters are unchanged.
     1785      109        ..::IT "Errors:"
     1786      110        Any error conditions reported by select() can be assumed to be the result
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:216  
     1787      111        of earlier socket operations.  The select() function does not diagnose
     1788      112        any error conditions itself.
     1789      113        */
     1790      114        XSL$SELECT: PROC( RESULT, NUMFDS, RMSK, WMSK, EMSK, TIMEOUT) ALTRET;

    114  2 000000   000000 700200 xent  XSL$SELECT   TSX0  ! X66_AUTO_N
         2 000001   000054 000006                    ZERO    44,6

     1791      115        %INCLUDE CP_6;
     1792      196        %INCLUDE CP_6_SUBS;
     1793      736            %FPT_WAIT( FPTN=XSL_WAIT1DAY, STCLASS=SYMREF);
     1794      750            %FPT_WAIT( FPTN=FPT@WAIT, STCLASS=AUTO);
     1795      764    1       DCL 1 BVEC BASED DALIGNED,2 * BIT(36),2 BASE$ PTR;
     1796      765            %F$DCB;
     1797      822        %INCLUDE XSL_PERR_C;
     1798      877        %INCLUDE XSL_SOCKET_M;
     1799     1638        %INCLUDE XSL_INTERNAL_M;
     1800     1889            %XSL$SOCKINFO( FPTN=SOCK, STCLASS="BASED( SOCK$)");
     1801     2033            %XSL$SOCKHD( STCLASS="BASED( XSL_SOCK$$)");
     1802     2066        %INCLUDE XSL_SOCKMSGS_E;
     1803     2112        %INCLUDE XSL_SOCKMSGS_M;
     1804     3245            %XSL$SELECTRQS( FPTN=XSL_SELECTRQS, STCLASS="CONSTANT SYMDEF");
     1805     3275            %XSL$SELECTRQS( STCLASS="BASED( XSL_KEYBUF$)");
     1806     3305            %XSL$SELECTRSP( STCLASS="BASED( XSL_KEYBUF$)");
     1807     3336
     1808     3337    1       DCL XSL$CL_READ ENTRY(3) ALTRET;
     1809     3338    1       DCL XSL$CL_WRITE ENTRY(4) ALTRET;
     1810     3339    1       DCL XSL$SOCKPTR ENTRY(2) ALTRET;
     1811     3340    1       DCL XSL$DCBNPTR ENTRY(2) ALTRET;
     1812     3341    1       DCL XSL$GETBUF ENTRY(2) ALTRET;
     1813     3342    1       DCL XSL$EVLOG ENTRY(2);
     1814     3343
     1815     3344    1       DCL XSL_ERRNO SBIN SYMREF;
     1816     3345    1       DCL XSL_KEYBUF$ PTR SYMREF READONLY;
     1817     3346    1       DCL XSL_SOCK$$ PTR SYMREF;
     1818     3347
     1819     3348    1       DCL ALLMASK BIT(72) ALIGNED;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:217  
     1820     3349    1       DCL ALLMASKBITS(0:71) REDEF ALLMASK BIT(1) UNAL;
     1821     3350    1       DCL B$UBIN(0:0) UBIN BASED;
     1822     3351    1       DCL COUNT SBIN;
     1823     3352    1       DCL EMSK BIT(XNUMFDS) ALIGNED;
     1824     3353    1       DCL XEMSKBITS(0:71) BIT(1) UNAL;
     1825     3354    1       DCL I SBIN;
     1826     3355    1       DCL NUMFDS SBIN;
     1827     3356    1       DCL QUICK BIT(1) UNAL;
     1828     3357    1       DCL RESULT SBIN;
     1829     3358    1       DCL RMSK BIT(XNUMFDS) ALIGNED;
     1830     3359    1       DCL XRMSKBITS(0:71) BIT(1) UNAL;
     1831     3360    1       DCL SELECTING BIT(1) UNAL;  /* at least one proxy is select()ing */
     1832     3361    1       DCL SOCK$ PTR;
     1833     3362    1       DCL SECS UBIN;
     1834     3363    1       DCL USECS UBIN;
     1835     3364    1       DCL TIMEOUT SBIN;
     1836     3365    1       DCL CUTMASK BIT(72) ALIGNED;
     1837     3366    1       DCL CUTMASKBITS(0:71) REDEF CUTMASK BIT(1) UNAL;
     1838     3367    1       DCL XTIMEOUT SBIN;
     1839     3368    1       DCL XNUMFDS SBIN;
     1840     3369    1       DCL WMSK BIT(XNUMFDS) ALIGNED;
     1841     3370    1       DCL XWMSKBITS(0:71) BIT(1) UNAL;
     1842     3371
     1843     3372    1       QUICK = '0'B;

   3372  2 000002   200026 450100                    STZ     QUICK,,AUTO

     1844     3373    1       GOTO COMMON;

   3373  2 000003   000010 710000 2                  TRA     COMMON

     1845     3374
     1846     3375    1   XSL$QSELECT: ENTRY( RESULT, NUMFDS, RMSK, WMSK, EMSK, TIMEOUT) ALTRET;

   3375  2 000004   000000 700200 xent  XSL$QSELECT  TSX0  ! X66_AUTO_N
         2 000005   000054 000006                    ZERO    44,6

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:218  
     1847     3376
     1848     3377    1       QUICK = '1'B;

   3377  2 000006   400000 236003                    LDQ     -131072,DU
         2 000007   200026 756100                    STQ     QUICK,,AUTO

     1849     3378    1   COMMON:
     1850     3379    1       XNUMFDS = MINIMUM (72, NUMFDS);

   3379  2 000010   200004 470500       COMMON       LDP0    @NUMFDS,,AUTO
         2 000011   000000 236100                    LDQ     0,,PR0
         2 000012   000110 116007                    CMPQ    72,DL
         2 000013   000015 604400 2                  TMOZ    COMMON+5
         2 000014   000110 236007                    LDQ     72,DL
         2 000015   200040 756100                    STQ     XNUMFDS,,AUTO

     1851     3380    1       XSL_ERRNO = 0;

   3380  2 000016   000000 450000 xsym               STZ     XSL_ERRNO

     1852     3381    1       COUNT = 0;

   3381  2 000017   200022 450100                    STZ     COUNT,,AUTO

     1853     3382    1       SELECTING = '0'B;

   3382  2 000020   200031 450100                    STZ     SELECTING,,AUTO

     1854     3383    1       IF ADDR( RMSK) = ADDR( NIL) THEN

   3383  2 000021   200005 236100                    LDQ     @RMSK,,AUTO
         2 000022   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000023   000027 601000 2                  TNZ     s:3386

     1855     3384    1           XRMSKBITS = '0'B;

   3384  2 000024   200027 450100                    STZ     XRMSKBITS,,AUTO
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:219  
         2 000025   200030 450100                    STZ     XRMSKBITS+1,,AUTO
         2 000026   000034 710000 2                  TRA     s:3387

     1856     3385    1       ELSE
     1857     3386    1           XRMSKBITS = RMSK;

   3386  2 000027   200005 471500                    LDP1    @RMSK,,AUTO
         2 000030   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000031   003100 060540                    CSL     bolr='003'O
         2 000032   100000 000010                    BDSC    0,,PR1                   by=0,bit=0,n=*X0
         2 000033   200027 000110                    BDSC    XRMSKBITS,,AUTO          by=0,bit=0,n=72

     1858     3387    1       IF ADDR( WMSK) = ADDR( NIL) THEN

   3387  2 000034   200006 236100                    LDQ     @WMSK,,AUTO
         2 000035   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000036   000042 601000 2                  TNZ     s:3390

     1859     3388    1           XWMSKBITS = '0'B;

   3388  2 000037   200041 450100                    STZ     XWMSKBITS,,AUTO
         2 000040   200042 450100                    STZ     XWMSKBITS+1,,AUTO
         2 000041   000047 710000 2                  TRA     s:3391

     1860     3389    1       ELSE
     1861     3390    1           XWMSKBITS = WMSK;

   3390  2 000042   200006 471500                    LDP1    @WMSK,,AUTO
         2 000043   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000044   003100 060540                    CSL     bolr='003'O
         2 000045   100000 000010                    BDSC    0,,PR1                   by=0,bit=0,n=*X0
         2 000046   200041 000110                    BDSC    XWMSKBITS,,AUTO          by=0,bit=0,n=72

     1862     3391    1       IF ADDR( EMSK) = ADDR( NIL) THEN

   3391  2 000047   200007 236100                    LDQ     @EMSK,,AUTO
         2 000050   000001 116000 xsym               CMPQ    B_VECTNIL+1
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:220  
         2 000051   000055 601000 2                  TNZ     s:3394

     1863     3392    1           XEMSKBITS = '0'B;

   3392  2 000052   200023 450100                    STZ     XEMSKBITS,,AUTO
         2 000053   200024 450100                    STZ     XEMSKBITS+1,,AUTO
         2 000054   000062 710000 2                  TRA     s:3395

     1864     3393    1       ELSE
     1865     3394    1           XEMSKBITS = EMSK;

   3394  2 000055   200007 471500                    LDP1    @EMSK,,AUTO
         2 000056   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000057   003100 060540                    CSL     bolr='003'O
         2 000060   100000 000010                    BDSC    0,,PR1                   by=0,bit=0,n=*X0
         2 000061   200023 000110                    BDSC    XEMSKBITS,,AUTO          by=0,bit=0,n=72

     1866     3395    1       IF ADDR( TIMEOUT) = ADDR( NIL) THEN

   3395  2 000062   200010 236100                    LDQ     @TIMEOUT,,AUTO
         2 000063   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000064   000070 601000 2                  TNZ     s:3398

     1867     3396    1           XTIMEOUT = -1;

   3396  2 000065   000001 335007                    LCA     1,DL
         2 000066   200037 755100                    STA     XTIMEOUT,,AUTO
         2 000067   000112 710000 2                  TRA     s:3405

     1868     3397    2       ELSE DO;

     1869     3398    2           SECS = TIMEOUT;

   3398  2 000070   200010 471500                    LDP1    @TIMEOUT,,AUTO
         2 000071   100000 235100                    LDA     0,,PR1
         2 000072   200033 755100                    STA     SECS,,AUTO

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:221  
     1870     3399    2           IF QUICK THEN

   3399  2 000073   200026 234100                    SZN     QUICK,,AUTO
         2 000074   000077 605000 2                  TPL     s:3402

     1871     3400    2               USECS = 0;

   3400  2 000075   200034 450100                    STZ     USECS,,AUTO
         2 000076   000101 710000 2                  TRA     s:3403

     1872     3401    2           ELSE
     1873     3402    2               USECS = ADDR( TIMEOUT)->B$UBIN( 1);

   3402  2 000077   100001 235100                    LDA     1,,PR1
         2 000100   200034 755100                    STA     USECS,,AUTO

     1874     3403    2           XTIMEOUT = MINIMUM( 32767, SECS + USECS / 1000000);

   3403  2 000101   200034 236100                    LDQ     USECS,,AUTO
         2 000102   000001 772000                    QRL     1
         2 000103   000000 506000 3                  DIV     0
         2 000104   200033 036100                    ADLQ    SECS,,AUTO
         2 000105   077777 116007                    CMPQ    32767,DL
         2 000106   000111 602000 2                  TNC     s:3403+8
         2 000107   000111 600000 2                  TZE     s:3403+8
         2 000110   077777 236007                    LDQ     32767,DL
         2 000111   200037 756100                    STQ     XTIMEOUT,,AUTO

     1875     3404    2           END;

     1876     3405    1       ALLMASK = XRMSKBITS | XWMSKBITS | XEMSKBITS;

   3405  2 000112   000100 100500                    MLR     fill='000'O
         2 000113   200041 000010                    ADSC9   XWMSKBITS,,AUTO          cn=0,n=8
         2 000114   200044 000010                    ADSC9   XWMSKBITS+3,,AUTO        cn=0,n=8
         2 000115   000100 100500                    MLR     fill='000'O
         2 000116   200027 000010                    ADSC9   XRMSKBITS,,AUTO          cn=0,n=8
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:222  
         2 000117   200046 000010                    ADSC9   XWMSKBITS+5,,AUTO        cn=0,n=8
         2 000120   200046 237100                    LDAQ    XWMSKBITS+5,,AUTO
         2 000121   200044 277100                    ORAQ    XWMSKBITS+3,,AUTO
         2 000122   200050 757100                    STAQ    XWMSKBITS+7,,AUTO
         2 000123   000100 100500                    MLR     fill='000'O
         2 000124   200023 000010                    ADSC9   XEMSKBITS,,AUTO          cn=0,n=8
         2 000125   200052 000010                    ADSC9   XWMSKBITS+9,,AUTO        cn=0,n=8
         2 000126   200052 237100                    LDAQ    XWMSKBITS+9,,AUTO
         2 000127   200050 277100                    ORAQ    XWMSKBITS+7,,AUTO
         2 000130   200020 757100                    STAQ    ALLMASK,,AUTO

     1877     3406    1       CUTMASK = ALLMASK;

   3406  2 000131   200020 237100                    LDAQ    ALLMASK,,AUTO
         2 000132   200035 755100                    STA     CUTMASK,,AUTO
         2 000133   200036 756100                    STQ     CUTMASK+1,,AUTO

     1878     3407            /* First start the requested waiting in the Xps. */
     1879     3408    2       IF XTIMEOUT ~= 0 THEN DO;

   3408  2 000134   200037 235100                    LDA     XTIMEOUT,,AUTO
         2 000135   000415 600000 2                  TZE     s:3468

     1880     3409    2   LOOP1:
     1881     3410    3           DO I = XNUMFDS - 1 DOWNTO 0;

   3410  2 000136   200040 235100       LOOP1        LDA     XNUMFDS,,AUTO
         2 000137   000001 135007                    SBLA    1,DL
         2 000140   200025 755100                    STA     I,,AUTO
         2 000141   000350 710000 2                  TRA     s:3445+2

     1882     3411    4               IF ALLMASKBITS( I) THEN DO;

   3411  2 000142   200025 235100                    LDA     I,,AUTO
         2 000143   000145 605000 2                  TPL     s:3411+3
         2 000144   000044 035003                    ADLA    36,DU
         2 000145   000000 066505                    CMPB    filb='0'B
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:223  
         2 000146   200020 000001                    BDSC    ALLMASK,A,AUTO           by=0,bit=0,n=1
         2 000147   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000150   000346 600000 2                  TZE     s:3445

     1883     3412    5                   IF QUICK THEN DO;

   3412  2 000151   200026 234100                    SZN     QUICK,,AUTO
         2 000152   000164 605000 2                  TPL     s:3417

     1884     3413    5                       CALL XSL$SOCKPTR( I, SOCK$) ALTRET( DONE1);

   3413  2 000153   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000154   200045 450500                    STP0    XWMSKBITS+4,,AUTO
         2 000155   200025 631500                    EPPR1   I,,AUTO
         2 000156   200044 451500                    STP1    XWMSKBITS+3,,AUTO
         2 000157   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000160   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000161   000000 701000 xent               TSX1    XSL$SOCKPTR
         2 000162   000334 702000 2                  TSX2    DONE1

     1885     3414    5                       GOTO COMMON1;

   3414  2 000163   000174 710000 2                  TRA     COMMON1

     1886     3415    5                       END;
     1887     3416    4                   ELSE
     1888     3417    4                       CALL XSL$DCBNPTR( I, SOCK$) ALTRET( DONE1);

   3417  2 000164   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000165   200045 450500                    STP0    XWMSKBITS+4,,AUTO
         2 000166   200025 631500                    EPPR1   I,,AUTO
         2 000167   200044 451500                    STP1    XWMSKBITS+3,,AUTO
         2 000170   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000171   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000172   000000 701000 xent               TSX1    XSL$DCBNPTR
         2 000173   000334 702000 2                  TSX2    DONE1

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:224  
     1889     3418    4   COMMON1:
     1890     3419    4                   IF NOT SOCK.FLAGS.BIND AND NOT SOCK.FLAGS.CONNECT THEN

   3419  2 000174   200032 470500       COMMON1      LDP0    SOCK$,,AUTO
         2 000175   000001 236100                    LDQ     1,,PR0
         2 000176   004000 316003                    CANQ    2048,DU
         2 000177   000202 601000 2                  TNZ     s:3421
         2 000200   040000 316003                    CANQ    16384,DU
         2 000201   000334 600000 2                  TZE     DONE1

     1891     3420    4                       GOTO DONE1;
     1892     3421    5                   IF SOCK.MAXRDS = 0 OR SOCK.FLAGS.LISTEN THEN DO;

   3421  2 000202   000020 720100                    LXL0    16,,PR0
         2 000203   000206 600000 2                  TZE     s:3422
         2 000204   010000 316003                    CANQ    4096,DU
         2 000205   000250 600000 2                  TZE     s:3431

     1893     3422    5                       SELECTING = '1'B;

   3422  2 000206   400000 236003                    LDQ     -131072,DU
         2 000207   200031 756100                    STQ     SELECTING,,AUTO

     1894     3423    5                       XSL$SELECTRQS = XSL_SELECTRQS;

   3423  2 000210   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000211   000100 100400                    MLR     fill='000'O
         2 000212   000000 000006 1                  ADSC9   XSL_SELECTRQS            cn=0,n=6
         2 000213   100000 000006                    ADSC9   0,,PR1                   cn=0,n=6

     1895     3424    5                       XSL$SELECTRQS.TIMEOUT = XTIMEOUT;

   3424  2 000214   200037 720100                    LXL0    XTIMEOUT,,AUTO
         2 000215   100000 440100                    SXL0    0,,PR1

     1896     3425    5                       XSL$SELECTRQS.EMSK = XEMSKBITS( I);

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:225  
   3425  2 000216   200025 235100                    LDA     I,,AUTO
         2 000217   000221 605000 2                  TPL     s:3425+3
         2 000220   000044 035003                    ADLA    36,DU
         2 000221   003100 060505                    CSL     bolr='003'O
         2 000222   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000223   100001 260001                    BDSC    1,,PR1                   by=1,bit=6,n=1

     1897     3426    5                       XSL$SELECTRQS.WMSK = XWMSKBITS( I);

   3426  2 000224   200025 235100                    LDA     I,,AUTO
         2 000225   000227 605000 2                  TPL     s:3426+3
         2 000226   000044 035003                    ADLA    36,DU
         2 000227   003100 060505                    CSL     bolr='003'O
         2 000230   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000231   100001 270001                    BDSC    1,,PR1                   by=1,bit=7,n=1

     1898     3427    5                       XSL$SELECTRQS.RMSK = XRMSKBITS( I);

   3427  2 000232   200025 235100                    LDA     I,,AUTO
         2 000233   000235 605000 2                  TPL     s:3427+3
         2 000234   000044 035003                    ADLA    36,DU
         2 000235   003100 060505                    CSL     bolr='003'O
         2 000236   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000237   100001 300001                    BDSC    1,,PR1                   by=1,bit=8,n=1

     1899     3428    5                       CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SELECTRQS));

   3428  2 000240   000001 236000 3                  LDQ     1
         2 000241   200032 235100                    LDA     SOCK$,,AUTO
         2 000242   200044 757100                    STAQ    XWMSKBITS+3,,AUTO
         2 000243   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000244   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000245   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000246   000000 011000                    NOP     0

     1900     3429    5                       END;

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:226  
   3429  2 000247   000334 710000 2                  TRA     DONE1

     1901     3430    5                   ELSE DO;

     1902     3431    6                       DO WHILE( DCBADDR( SOCK.DCB#)->F$DCB.FCN.CNT(0) < SOCK.MAXRDS
              3431                                AND

   3431  2 000250   000255 710000 2                  TRA     s:3434

     1903     3432    6                         SOCK.BUFPND# <= SOCK.MAXBUF);
     1904     3433    6                           CALL XSL$GETBUF( SOCK) ALTRET( LOOKNOW);

   3433  2 000251   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000252   000017 631400 xsym               EPPR1   B_VECTNIL+15
         2 000253   000000 701000 xent               TSX1    XSL$GETBUF
         2 000254   000276 702000 2                  TSX2    LOOKNOW

     1905     3434    6                           END;

   3434  2 000255   000002 470400 3                  LDP0    2
         2 000256   000000 471500                    LDP1    0,,PR0
         2 000257   200032 473500                    LDP3    SOCK$,,AUTO
         2 000260   300003 720100                    LXL0    3,,PR3
         2 000261   100000 474510                    LDP4    0,X0,PR1
         2 000262   300020 236100                    LDQ     16,,PR3
         2 000263   777777 376007                    ANQ     -1,DL
         2 000264   200044 756100                    STQ     XWMSKBITS+3,,AUTO
         2 000265   400074 236100                    LDQ     60,,PR4
         2 000266   000033 772000                    QRL     27
         2 000267   000377 376007                    ANQ     255,DL
         2 000270   200044 116100                    CMPQ    XWMSKBITS+3,,AUTO
         2 000271   000276 605000 2                  TPL     LOOKNOW
         2 000272   300017 720100                    LXL0    15,,PR3
         2 000273   300020 100100                    CMPX0   16,,PR3
         2 000274   000251 602000 2                  TNC     s:3433
         2 000275   000251 600000 2                  TZE     s:3433

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:227  
     1906     3435    5   LOOKNOW:
     1907     3436    5                       IF ( SOCK.FLAGS.SELREAD AND XRMSKBITS( I)) OR

   3436  2 000276   200032 470500       LOOKNOW      LDP0    SOCK$,,AUTO
         2 000277   000001 236100                    LDQ     1,,PR0
         2 000300   000040 316003                    CANQ    32,DU
         2 000301   000311 600000 2                  TZE     LOOKNOW+11
         2 000302   200025 235100                    LDA     I,,AUTO
         2 000303   000305 605000 2                  TPL     LOOKNOW+7
         2 000304   000044 035003                    ADLA    36,DU
         2 000305   000000 066505                    CMPB    filb='0'B
         2 000306   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000307   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000310   000333 601000 2                  TNZ     s:3439
         2 000311   000020 316003                    CANQ    16,DU
         2 000312   000322 600000 2                  TZE     LOOKNOW+20
         2 000313   200025 235100                    LDA     I,,AUTO
         2 000314   000316 605000 2                  TPL     LOOKNOW+16
         2 000315   000044 035003                    ADLA    36,DU
         2 000316   000000 066505                    CMPB    filb='0'B
         2 000317   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000320   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000321   000333 601000 2                  TNZ     s:3439
         2 000322   000010 316003                    CANQ    8,DU
         2 000323   000334 600000 2                  TZE     DONE1
         2 000324   200025 235100                    LDA     I,,AUTO
         2 000325   000327 605000 2                  TPL     LOOKNOW+25
         2 000326   000044 035003                    ADLA    36,DU
         2 000327   000000 066505                    CMPB    filb='0'B
         2 000330   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000331   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000332   000334 600000 2                  TZE     DONE1

     1908     3437    5                         ( SOCK.FLAGS.SELWRITE AND XWMSKBITS( I)) OR
     1909     3438    5                         ( SOCK.FLAGS.SELEXCEP AND XEMSKBITS( I)) THEN
     1910     3439    5                           COUNT = COUNT + 1;

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:228  
   3439  2 000333   200022 054100                    AOS     COUNT,,AUTO

     1911     3440    5                       END;

     1912     3441    4   DONE1:
     1913     3442    4                   CUTMASKBITS( I) = '0'B;

   3442  2 000334   200025 235100       DONE1        LDA     I,,AUTO
         2 000335   000337 605000 2                  TPL     DONE1+3
         2 000336   000044 035003                    ADLA    36,DU
         2 000337   003105 060400                    CSL     bolr='003'O
         2 000340   000002 000001 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=1
         2 000341   200035 000001                    BDSC    CUTMASK,A,AUTO           by=0,bit=0,n=1

     1914     3443    4                   IF CUTMASK = '0'B THEN EXIT LOOP1;

   3443  2 000342   000000 106500                    CMPC    fill='000'O
         2 000343   200035 000010                    ADSC9   CUTMASK,,AUTO            cn=0,n=8
         2 000344   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         2 000345   000352 600000 2                  TZE     s:3446

     1915     3444    4                   END;

     1916     3445    3               END;

   3445  2 000346   000001 336007                    LCQ     1,DL
         2 000347   200025 056100                    ASQ     I,,AUTO
         2 000350   200025 235100                    LDA     I,,AUTO
         2 000351   000142 605000 2                  TPL     s:3411

     1917     3446    2           IF COUNT > 0 AND NOT SELECTING THEN EXIT;

   3446  2 000352   200022 235100                    LDA     COUNT,,AUTO
         2 000353   000356 604400 2                  TMOZ    s:3449
         2 000354   200031 234100                    SZN     SELECTING,,AUTO
         2 000355   000415 605000 2                  TPL     s:3468

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:229  
     1918     3447                /* Then do the requested wait here */
     1919     3448                /* If a proxy finishes, he'll wake us up. */
     1920     3449    2           FPT@WAIT = XSL_WAIT1DAY;

   3449  2 000356   000100 100400                    MLR     fill='000'O
         2 000357   000000 000030 xsym               ADSC9   XSL_WAIT1DAY             cn=0,n=24
         2 000360   200012 000030                    ADSC9   FPT@WAIT,,AUTO           cn=0,n=24

     1921     3450    2           ADDR( FPT@WAIT.V_) -> BVEC.BASE$ = ADDR( FPT@WAIT.V);

   3450  2 000361   200016 630500                    EPPR0   FPT@WAIT+4,,AUTO
         2 000362   200013 450500                    STP0    FPT@WAIT+1,,AUTO

     1922     3451    3           IF XTIMEOUT > 0 THEN DO;

   3451  2 000363   200037 236100                    LDQ     XTIMEOUT,,AUTO
         2 000364   000406 604400 2                  TMOZ    s:3461

     1923     3452    4               IF USECS > 0 THEN DO;

   3452  2 000365   200034 235100                    LDA     USECS,,AUTO
         2 000366   000402 600000 2                  TZE     s:3457

     1924     3453    4                   FPT@WAIT.V.UTYPE# = %TUN#;

   3453  2 000367   000005 235007                    LDA     5,DL
         2 000370   200017 755100                    STA     FPT@WAIT+5,,AUTO

     1925     3454    4                   FPT@WAIT.V.UNITS# = SECS*100 + USECS/10000;

   3454  2 000371   200034 236100                    LDQ     USECS,,AUTO
         2 000372   000001 772000                    QRL     1
         2 000373   011610 506007                    DIV     5000,DL
         2 000374   200044 756100                    STQ     XWMSKBITS+3,,AUTO
         2 000375   200033 236100                    LDQ     SECS,,AUTO
         2 000376   000144 402007                    MPY     100,DL
         2 000377   200044 036100                    ADLQ    XWMSKBITS+3,,AUTO
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:230  
         2 000400   200016 756100                    STQ     FPT@WAIT+4,,AUTO

     1926     3455    4                   END;

   3455  2 000401   000406 710000 2                  TRA     s:3461

     1927     3456    4               ELSE DO;

     1928     3457    4                   FPT@WAIT.V.UTYPE# = %SEC#;

   3457  2 000402   000001 235007                    LDA     1,DL
         2 000403   200017 755100                    STA     FPT@WAIT+5,,AUTO

     1929     3458    4                   FPT@WAIT.V.UNITS# = SECS;

   3458  2 000404   200033 235100                    LDA     SECS,,AUTO
         2 000405   200016 755100                    STA     FPT@WAIT+4,,AUTO

     1930     3459    4                   END;

     1931     3460    3               END;

     1932     3461    2           CALL XSL$EVLOG( 'WT', 0);

   3461  2 000406   000003 630400 3                  EPPR0   3
         2 000407   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000410   000000 701000 xent               TSX1    XSL$EVLOG
         2 000411   000000 011000                    NOP     0

     1933     3462    2           CALL M$WAIT( FPT@WAIT);

   3462  2 000412   200012 630500                    EPPR0   FPT@WAIT,,AUTO
         2 000413   020006 713400                    CLIMB   8198
         2 000414   400400 401760                    pmme    nvectors=2

     1934     3463    2           END;

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:231  
     1935     3464
     1936     3465            /* Waiting is over, poll the proxies to see which one woke us up. */
     1937     3466            /* Or, poll the proxies if no wait was requested. */
     1938     3467
     1939     3468    1       COUNT = 0;

   3468  2 000415   200022 450100                    STZ     COUNT,,AUTO

     1940     3469    1       CUTMASK = ALLMASK;

   3469  2 000416   200020 237100                    LDAQ    ALLMASK,,AUTO
         2 000417   200035 755100                    STA     CUTMASK,,AUTO
         2 000420   200036 756100                    STQ     CUTMASK+1,,AUTO

     1941     3470    1   LOOP2:
     1942     3471    2       DO I = XNUMFDS - 1 DOWNTO 0;

   3471  2 000421   200040 235100       LOOP2        LDA     XNUMFDS,,AUTO
         2 000422   000001 135007                    SBLA    1,DL
         2 000423   200025 755100                    STA     I,,AUTO
         2 000424   000716 710000 2                  TRA     s:3524+2

     1943     3472    3           IF ALLMASKBITS( I) THEN DO;

   3472  2 000425   200025 235100                    LDA     I,,AUTO
         2 000426   000430 605000 2                  TPL     s:3472+3
         2 000427   000044 035003                    ADLA    36,DU
         2 000430   000000 066505                    CMPB    filb='0'B
         2 000431   200020 000001                    BDSC    ALLMASK,A,AUTO           by=0,bit=0,n=1
         2 000432   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000433   000714 600000 2                  TZE     s:3524

     1944     3473    4               IF QUICK THEN DO;

   3473  2 000434   200026 234100                    SZN     QUICK,,AUTO
         2 000435   000447 605000 2                  TPL     s:3478

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:232  
     1945     3474    4                   CALL XSL$SOCKPTR( I, SOCK$) ALTRET( DONE2);

   3474  2 000436   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000437   200045 450500                    STP0    XWMSKBITS+4,,AUTO
         2 000440   200025 631500                    EPPR1   I,,AUTO
         2 000441   200044 451500                    STP1    XWMSKBITS+3,,AUTO
         2 000442   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000443   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000444   000000 701000 xent               TSX1    XSL$SOCKPTR
         2 000445   000702 702000 2                  TSX2    DONE2

     1946     3475    4                   GOTO COMMON2;

   3475  2 000446   000457 710000 2                  TRA     COMMON2

     1947     3476    4                   END;
     1948     3477    3               ELSE
     1949     3478    3                   CALL XSL$DCBNPTR( I, SOCK$) ALTRET( DONE2);

   3478  2 000447   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000450   200045 450500                    STP0    XWMSKBITS+4,,AUTO
         2 000451   200025 631500                    EPPR1   I,,AUTO
         2 000452   200044 451500                    STP1    XWMSKBITS+3,,AUTO
         2 000453   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000454   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000455   000000 701000 xent               TSX1    XSL$DCBNPTR
         2 000456   000702 702000 2                  TSX2    DONE2

     1950     3479    3   COMMON2:
     1951     3480    4               IF SOCK.FLAGS.CP6ERR THEN DO;

   3480  2 000457   200032 470500       COMMON2      LDP0    SOCK$,,AUTO
         2 000460   000001 236100                    LDQ     1,,PR0
         2 000461   200000 316007                    CANQ    65536,DL
         2 000462   000466 600000 2                  TZE     s:3485

     1952     3481                        /* this blows, but what're ya gonna do? */
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:233  
     1953     3482    4                   XSL_ERRNO = BITBIN( SOCK.CP6ERROR);

   3482  2 000463   000022 235100                    LDA     18,,PR0
         2 000464   000000 755000 xsym               STA     XSL_ERRNO

     1954     3483    4                   GOTO BAILOUT;

   3483  2 000465   000570 710000 2                  TRA     BAILOUT

     1955     3484    4                   END;
     1956     3485    4               IF NOT SOCK.FLAGS.BIND AND NOT SOCK.FLAGS.CONNECT THEN DO;

   3485  2 000466   004000 316003                    CANQ    2048,DU
         2 000467   000515 601000 2                  TNZ     s:3491
         2 000470   040000 316003                    CANQ    16384,DU
         2 000471   000515 601000 2                  TNZ     s:3491

     1957     3486    4                   XEMSKBITS( I) = '0'B;

   3486  2 000472   200025 235100                    LDA     I,,AUTO
         2 000473   000475 605000 2                  TPL     s:3486+3
         2 000474   000044 035003                    ADLA    36,DU
         2 000475   003105 060400                    CSL     bolr='003'O
         2 000476   000002 000001 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=1
         2 000477   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1

     1958     3487    4                   XWMSKBITS( I) = '0'B;

   3487  2 000500   200025 235100                    LDA     I,,AUTO
         2 000501   000503 605000 2                  TPL     s:3487+3
         2 000502   000044 035003                    ADLA    36,DU
         2 000503   003105 060400                    CSL     bolr='003'O
         2 000504   000002 000001 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=1
         2 000505   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1

     1959     3488    4                   XRMSKBITS( I) = '0'B;

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:234  
   3488  2 000506   200025 235100                    LDA     I,,AUTO
         2 000507   000511 605000 2                  TPL     s:3488+3
         2 000510   000044 035003                    ADLA    36,DU
         2 000511   003105 060400                    CSL     bolr='003'O
         2 000512   000002 000001 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=1
         2 000513   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1

     1960     3489    4                   GOTO DONE2;

   3489  2 000514   000702 710000 2                  TRA     DONE2

     1961     3490    4                   END;
     1962     3491    4               IF SOCK.MAXRDS = 0 OR SOCK.FLAGS.LISTEN THEN DO;

   3491  2 000515   000020 720100                    LXL0    16,,PR0
         2 000516   000521 600000 2                  TZE     s:3492
         2 000517   010000 316003                    CANQ    4096,DU
         2 000520   000624 600000 2                  TZE     s:3512

     1963     3492    4                   XSL$SELECTRQS = XSL_SELECTRQS;

   3492  2 000521   000000 471400 xsym               LDP1    XSL_KEYBUF$
         2 000522   000100 100400                    MLR     fill='000'O
         2 000523   000000 000006 1                  ADSC9   XSL_SELECTRQS            cn=0,n=6
         2 000524   100000 000006                    ADSC9   0,,PR1                   cn=0,n=6

     1964     3493    4                   XSL$SELECTRQS.EMSK = XEMSKBITS( I);

   3493  2 000525   200025 235100                    LDA     I,,AUTO
         2 000526   000530 605000 2                  TPL     s:3493+3
         2 000527   000044 035003                    ADLA    36,DU
         2 000530   003100 060505                    CSL     bolr='003'O
         2 000531   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000532   100001 260001                    BDSC    1,,PR1                   by=1,bit=6,n=1

     1965     3494    4                   XSL$SELECTRQS.WMSK = XWMSKBITS( I);

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:235  
   3494  2 000533   200025 235100                    LDA     I,,AUTO
         2 000534   000536 605000 2                  TPL     s:3494+3
         2 000535   000044 035003                    ADLA    36,DU
         2 000536   003100 060505                    CSL     bolr='003'O
         2 000537   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000540   100001 270001                    BDSC    1,,PR1                   by=1,bit=7,n=1

     1966     3495    4                   XSL$SELECTRQS.RMSK = XRMSKBITS( I);

   3495  2 000541   200025 235100                    LDA     I,,AUTO
         2 000542   000544 605000 2                  TPL     s:3495+3
         2 000543   000044 035003                    ADLA    36,DU
         2 000544   003100 060505                    CSL     bolr='003'O
         2 000545   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000546   100001 300001                    BDSC    1,,PR1                   by=1,bit=8,n=1

     1967     3496    4                   CALL XSL$CL_WRITE( SOCK, LENGTHC( XSL$SELECTRQS));

   3496  2 000547   000001 236000 3                  LDQ     1
         2 000550   200032 235100                    LDA     SOCK$,,AUTO
         2 000551   200044 757100                    STAQ    XWMSKBITS+3,,AUTO
         2 000552   200044 630500                    EPPR0   XWMSKBITS+3,,AUTO
         2 000553   000020 631400 xsym               EPPR1   B_VECTNIL+16
         2 000554   000000 701000 xent               TSX1    XSL$CL_WRITE
         2 000555   000000 011000                    NOP     0

     1968     3497    4                   CALL XSL$CL_READ( SOCK);

   3497  2 000556   200032 630500                    EPPR0   SOCK$,,AUTO
         2 000557   000017 631400 xsym               EPPR1   B_VECTNIL+15
         2 000560   000000 701000 xent               TSX1    XSL$CL_READ
         2 000561   000000 011000                    NOP     0

     1969     3498    5                   IF XSL$SELECTRSP.RESULT < 0 THEN DO;

   3498  2 000562   000000 470400 xsym               LDP0    XSL_KEYBUF$
         2 000563   000000 720100                    LXL0    0,,PR0
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:236  
         2 000564   000574 605000 2                  TPL     s:3505

     1970     3499    5                       XSL_ERRNO = XSL$SELECTRSP.ERRNO;

   3499  2 000565   000001 236100                    LDQ     1,,PR0
         2 000566   000022 732000                    QRS     18
         2 000567   000000 756000 xsym               STQ     XSL_ERRNO

     1971     3500    5   BAILOUT:
     1972     3501    5                       RESULT = %E$FAILURE;

   3501  2 000570   000001 335007       BAILOUT      LCA     1,DL
         2 000571   200003 470500                    LDP0    @RESULT,,AUTO
         2 000572   000000 755100                    STA     0,,PR0

     1973     3502    5                       ALTRETURN;

   3502  2 000573   000000 702200 xent               TSX2  ! X66_AALT

     1974     3503    5                       END;
     1975     3504    5                   ELSE DO;

     1976     3505    5                       XEMSKBITS( I) = XSL$SELECTRSP.EMSK;

   3505  2 000574   200025 235100                    LDA     I,,AUTO
         2 000575   000577 605000 2                  TPL     s:3505+3
         2 000576   000044 035003                    ADLA    36,DU
         2 000577   003105 060500                    CSL     bolr='003'O
         2 000600   000001 660001                    BDSC    1,,PR0                   by=3,bit=6,n=1
         2 000601   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1

     1977     3506    5                       XWMSKBITS( I) = XSL$SELECTRSP.WMSK;

   3506  2 000602   200025 235100                    LDA     I,,AUTO
         2 000603   000605 605000 2                  TPL     s:3506+3
         2 000604   000044 035003                    ADLA    36,DU
         2 000605   003105 060500                    CSL     bolr='003'O
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:237  
         2 000606   000001 670001                    BDSC    1,,PR0                   by=3,bit=7,n=1
         2 000607   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1

     1978     3507    5                       XRMSKBITS( I) = XSL$SELECTRSP.RMSK;

   3507  2 000610   200025 235100                    LDA     I,,AUTO
         2 000611   000613 605000 2                  TPL     s:3507+3
         2 000612   000044 035003                    ADLA    36,DU
         2 000613   003105 060500                    CSL     bolr='003'O
         2 000614   000001 700001                    BDSC    1,,PR0                   by=3,bit=8,n=1
         2 000615   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1

     1979     3508    5                       COUNT = COUNT + XSL$SELECTRSP.RESULT;

   3508  2 000616   000000 236100                    LDQ     0,,PR0
         2 000617   000022 736000                    QLS     18
         2 000620   000022 732000                    QRS     18
         2 000621   200022 036100                    ADLQ    COUNT,,AUTO
         2 000622   200022 756100                    STQ     COUNT,,AUTO

     1980     3509    5                       END;

     1981     3510    4                   END;

   3510  2 000623   000702 710000 2                  TRA     DONE2

     1982     3511    4               ELSE DO;

     1983     3512    4                   IF ( SOCK.FLAGS.SELREAD AND XRMSKBITS( I)) OR

   3512  2 000624   000040 316003                    CANQ    32,DU
         2 000625   000635 600000 2                  TZE     s:3512+9
         2 000626   200025 235100                    LDA     I,,AUTO
         2 000627   000631 605000 2                  TPL     s:3512+5
         2 000630   000044 035003                    ADLA    36,DU
         2 000631   000000 066505                    CMPB    filb='0'B
         2 000632   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:238  
         2 000633   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000634   000657 601000 2                  TNZ     s:3515
         2 000635   000020 316003                    CANQ    16,DU
         2 000636   000646 600000 2                  TZE     s:3512+18
         2 000637   200025 235100                    LDA     I,,AUTO
         2 000640   000642 605000 2                  TPL     s:3512+14
         2 000641   000044 035003                    ADLA    36,DU
         2 000642   000000 066505                    CMPB    filb='0'B
         2 000643   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000644   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000645   000657 601000 2                  TNZ     s:3515
         2 000646   000010 316003                    CANQ    8,DU
         2 000647   000660 600000 2                  TZE     s:3516
         2 000650   200025 235100                    LDA     I,,AUTO
         2 000651   000653 605000 2                  TPL     s:3512+23
         2 000652   000044 035003                    ADLA    36,DU
         2 000653   000000 066505                    CMPB    filb='0'B
         2 000654   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1
         2 000655   000002 000022 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=18
         2 000656   000660 600000 2                  TZE     s:3516

     1984     3513    4                     ( SOCK.FLAGS.SELWRITE AND XWMSKBITS( I)) OR
     1985     3514    4                     ( SOCK.FLAGS.SELEXCEP AND XEMSKBITS( I)) THEN
     1986     3515    4                       COUNT = COUNT + 1;

   3515  2 000657   200022 054100                    AOS     COUNT,,AUTO

     1987     3516    4                   XEMSKBITS( I) = SOCK.FLAGS.SELEXCEP;

   3516  2 000660   200025 235100                    LDA     I,,AUTO
         2 000661   000663 605000 2                  TPL     s:3516+3
         2 000662   000044 035003                    ADLA    36,DU
         2 000663   003105 060500                    CSL     bolr='003'O
         2 000664   000001 250001                    BDSC    1,,PR0                   by=1,bit=5,n=1
         2 000665   200023 000001                    BDSC    XEMSKBITS,A,AUTO         by=0,bit=0,n=1

     1988     3517    4                   XWMSKBITS( I) = SOCK.FLAGS.SELWRITE;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:239  

   3517  2 000666   200025 235100                    LDA     I,,AUTO
         2 000667   000671 605000 2                  TPL     s:3517+3
         2 000670   000044 035003                    ADLA    36,DU
         2 000671   003105 060500                    CSL     bolr='003'O
         2 000672   000001 240001                    BDSC    1,,PR0                   by=1,bit=4,n=1
         2 000673   200041 000001                    BDSC    XWMSKBITS,A,AUTO         by=0,bit=0,n=1

     1989     3518    4                   XRMSKBITS( I) = SOCK.FLAGS.SELREAD;

   3518  2 000674   200025 235100                    LDA     I,,AUTO
         2 000675   000677 605000 2                  TPL     s:3518+3
         2 000676   000044 035003                    ADLA    36,DU
         2 000677   003105 060500                    CSL     bolr='003'O
         2 000700   000001 230001                    BDSC    1,,PR0                   by=1,bit=3,n=1
         2 000701   200027 000001                    BDSC    XRMSKBITS,A,AUTO         by=0,bit=0,n=1

     1990     3519    4                   END;

     1991     3520    3   DONE2:
     1992     3521    3               CUTMASKBITS( I) = '0'B;

   3521  2 000702   200025 235100       DONE2        LDA     I,,AUTO
         2 000703   000705 605000 2                  TPL     DONE2+3
         2 000704   000044 035003                    ADLA    36,DU
         2 000705   003105 060400                    CSL     bolr='003'O
         2 000706   000002 000001 xsym               BDSC    B_VECTNIL+2              by=0,bit=0,n=1
         2 000707   200035 000001                    BDSC    CUTMASK,A,AUTO           by=0,bit=0,n=1

     1993     3522    3               IF CUTMASK = '0'B THEN EXIT LOOP2;

   3522  2 000710   000000 106500                    CMPC    fill='000'O
         2 000711   200035 000010                    ADSC9   CUTMASK,,AUTO            cn=0,n=8
         2 000712   000002 000002 xsym               ADSC9   B_VECTNIL+2              cn=0,n=2
         2 000713   000720 600000 2                  TZE     s:3525

     1994     3523    3               END;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:240  

     1995     3524    2           END;

   3524  2 000714   000001 336007                    LCQ     1,DL
         2 000715   200025 056100                    ASQ     I,,AUTO
         2 000716   200025 235100                    LDA     I,,AUTO
         2 000717   000425 605000 2                  TPL     s:3472

     1996     3525    1       IF ADDR( RMSK) ~= ADDR( NIL) THEN

   3525  2 000720   200005 236100                    LDQ     @RMSK,,AUTO
         2 000721   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000722   000730 600000 2                  TZE     s:3527

     1997     3526    1           RMSK = XRMSKBITS;

   3526  2 000723   200005 470500                    LDP0    @RMSK,,AUTO
         2 000724   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000725   003140 060500                    CSL     bolr='003'O
         2 000726   200027 000110                    BDSC    XRMSKBITS,,AUTO          by=0,bit=0,n=72
         2 000727   000000 000010                    BDSC    0,,PR0                   by=0,bit=0,n=*X0

     1998     3527    1       IF ADDR( WMSK) ~= ADDR( NIL) THEN

   3527  2 000730   200006 236100                    LDQ     @WMSK,,AUTO
         2 000731   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000732   000740 600000 2                  TZE     s:3529

     1999     3528    1           WMSK = XWMSKBITS;

   3528  2 000733   200006 470500                    LDP0    @WMSK,,AUTO
         2 000734   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000735   003140 060500                    CSL     bolr='003'O
         2 000736   200041 000110                    BDSC    XWMSKBITS,,AUTO          by=0,bit=0,n=72
         2 000737   000000 000010                    BDSC    0,,PR0                   by=0,bit=0,n=*X0

     2000     3529    1       IF ADDR( EMSK) ~= ADDR( NIL) THEN
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:241  

   3529  2 000740   200007 236100                    LDQ     @EMSK,,AUTO
         2 000741   000001 116000 xsym               CMPQ    B_VECTNIL+1
         2 000742   000750 600000 2                  TZE     s:3531

     2001     3530    1           EMSK = XEMSKBITS;

   3530  2 000743   200007 470500                    LDP0    @EMSK,,AUTO
         2 000744   200040 720100                    LXL0    XNUMFDS,,AUTO
         2 000745   003140 060500                    CSL     bolr='003'O
         2 000746   200023 000110                    BDSC    XEMSKBITS,,AUTO          by=0,bit=0,n=72
         2 000747   000000 000010                    BDSC    0,,PR0                   by=0,bit=0,n=*X0

     2002     3531    1       RESULT = COUNT;

   3531  2 000750   200003 470500                    LDP0    @RESULT,,AUTO
         2 000751   200022 235100                    LDA     COUNT,,AUTO
         2 000752   000000 755100                    STA     0,,PR0

     2003     3532    1       RETURN;

   3532  2 000753   000000 702200 xent               TSX2  ! X66_ARET

XSL_SELECTRQS
 Sect OctLoc
   1     000   000021 000000   000000 0*****                                    ........

(unnamed)
 Sect OctLoc
   1     002   127124 040040                                                    WT

(unnamed)
 Sect OctLoc
   3     000   000001 720440   000010 006000   000000 006003   000002 006000    ................
   3     004   000002 006000                                                    ....
     2004     3533
     2005     3534    1   END XSL$SELECT;
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:242  

PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:243  
--  Include file information  --

   XSL_SOCKMSGS_M.:TCA2TOU  is referenced.
   XSL_SOCKMSGS_E.:TCA2TOU  is referenced.
   XSL_INTERNAL_M.:TCA2TOU  is referenced.
   XSL_SOCKET_M.:TCA2TOU  is referenced.
   XSL_PERR_C.:TCA2TOU  is referenced.
   CP_6_SUBS.:LIBRARY  is referenced.
   CP_6.:LIBRARY  cannot be made into a system file and is referenced.
   B$JIT_C.:E05TOU  was found in the system file and is never referenced.
   CP_6_C.:E05TOU  was found in the system file and is referenced.
      No diagnostics issued in procedure XSL$SELECT.
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:244  

 **** Variables and constants ****

  ****  Section 001 RoData XSL$SELECT

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w STRC(54)    r     1 XSL_SELECTRQS

  ****  Auto variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     7-0-0/w PTR         r     1 @EMSK                      4-0-0/w PTR         r     1 @NUMFDS
     3-0-0/w PTR         r     1 @RESULT                    5-0-0/w PTR         r     1 @RMSK
    10-0-0/w PTR         r     1 @TIMEOUT                   6-0-0/w PTR         r     1 @WMSK
    20-0-0/w BIT (72)    r     1 ALLMASK
    20-0-0/w BIT         r     1 ALLMASKBITS(0:71)
    22-0-0/w SBIN        r     1 COUNT                     35-0-0/w BIT (72)    r     1 CUTMASK
    35-0-0/w BIT         r     1 CUTMASKBITS(0:71)
    *0-0-0/w ABIT        r     1 EMSK                      12-0-0/d STRC(216)   r     1 FPT@WAIT
    25-0-0/w SBIN        r     1 I                         *0-0-0/w SBIN        r     1 NUMFDS
    26-0-0/b BIT         r     1 QUICK                     *0-0-0/w SBIN        r     1 RESULT
    *0-0-0/w ABIT        r     1 RMSK                      33-0-0/w UBIN        r     1 SECS
    31-0-0/b BIT         r     1 SELECTING                 32-0-0/w PTR         r     1 SOCK$
    *0-0-0/w SBIN        r     1 TIMEOUT                   34-0-0/w UBIN        r     1 USECS
    *0-0-0/w ABIT        r     1 WMSK
    23-0-0/b BIT         r     1 XEMSKBITS(0:71)
    40-0-0/w SBIN        r     1 XNUMFDS
    27-0-0/b BIT         r     1 XRMSKBITS(0:71)
    37-0-0/w SBIN        r     1 XTIMEOUT
    41-0-0/b BIT         r     1 XWMSKBITS(0:71)

  ****  SYMREF variables  ****

  ****  Scalars and arrays  ****
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:245  
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w SBIN        r     1 XSL_ERRNO                  0-0-0/w PTR         r     1 XSL_KEYBUF$
     0-0-0/w PTR         r     1 XSL_SOCK$$                 0-0-0/d STRC(216)   r     1 XSL_WAIT1DAY

  ****  BASED and DCB variables  ****

  ****  Scalars and arrays  ****
OctLoc.c.b A Datatyp(siz) R M Lvl/name                 OctLoc.c.b A Datatyp(siz) R M Lvl/name

     0-0-0/w UBIN        r     1 B$UBIN(0:0)                0-0-0/d STRC(72)    r     1 BVEC
     0-0-0/d ASTR(3528)  r     1 F$DCB                      0-0-0/w STRC(720)   r     1 SOCK
     0-0-0/w STRC(54)    r     1 XSL$SELECTRQS              0-0-0/w STRC(72)    r     1 XSL$SELECTRSP


   Procedure XSL$SELECT requires 492 words for executable code.
   Procedure XSL$SELECT requires 44 words of local(AUTO) storage.

    No errors detected in file XSL$SOCKET2.:TCA2TSI    .
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:246  
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:247  
          MINI XREF LISTING

ALLMASK
      3348**DCL      3349--REDEF    3405<<ASSIGN   3406>>ASSIGN   3469>>ASSIGN
ALLMASKBITS
      3349**DCL      3411>>IF       3472>>IF
B$UBIN
      3350**DCL      3402>>ASSIGN
BAILOUT
      3501**LABEL    3483--GOTO
BVEC.BASE$
       764**DCL      3450<<ASSIGN
COMMON
      3379**LABEL    3373--GOTO
COMMON1
      3419**LABEL    3414--GOTO
COMMON2
      3480**LABEL    3475--GOTO
COUNT
      3351**DCL      3381<<ASSIGN   3439<<ASSIGN   3439>>ASSIGN   3446>>IF       3468<<ASSIGN   3508<<ASSIGN
      3508>>ASSIGN   3515<<ASSIGN   3515>>ASSIGN   3531>>ASSIGN
CUTMASK
      3365**DCL      3366--REDEF    3406<<ASSIGN   3443>>IF       3469<<ASSIGN   3522>>IF
CUTMASKBITS
      3366**DCL      3442<<ASSIGN   3521<<ASSIGN
DONE1
      3442**LABEL    3413--CALLALT  3417--CALLALT  3420--GOTO
DONE2
      3521**LABEL    3474--CALLALT  3478--CALLALT  3489--GOTO
EMSK
      3352**DCL       114--PROC     3375--ENTRY    3391--IF       3394>>ASSIGN   3529--IF       3530<<ASSIGN
F$DCB.ACTPOS
       798**DCL       798--REDEF
F$DCB.ARS#
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:248  
       772**DCL       772--REDEF
F$DCB.ATTR
       791**DCL       792--REDEF
F$DCB.BORROW
       806**DCL       806--REDEF     806--REDEF     806--REDEF
F$DCB.DCBNAME.L
       820**DCL       820--IMP-SIZ
F$DCB.EOMCHAR#
       776**DCL       776--REDEF
F$DCB.FCN.CNT
       811**DCL      3431>>DOWHILE
F$DCB.FLDID
       801**DCL       801--REDEF
F$DCB.FORM$
       795**DCL       795--REDEF
F$DCB.FSECT
       811**DCL       811--REDEF
F$DCB.FSN#
       788**DCL       788--REDEF     788--REDEF     789--REDEF
F$DCB.HEADER$
       794**DCL       794--REDEF
F$DCB.IXTNSIZE#
       792**DCL       792--REDEF
F$DCB.LASTSTA$
       781**DCL       781--REDEF
F$DCB.LVL
       807**DCL       807--REDEF
F$DCB.NAME#.C
       782**DCL       782--REDEF
F$DCB.NOEOF
       804**DCL       804--REDEF
F$DCB.NRECS#
       793**DCL       793--REDEF
F$DCB.NRECX
       812**DCL       812--REDEF
F$DCB.OHDR
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:249  
       804**DCL       804--REDEF
F$DCB.ORG#
       787**DCL       787--REDEF
F$DCB.PRECNO
       810**DCL       810--REDEF
F$DCB.RCSZ
       816**DCL       816--REDEF
F$DCB.RES#
       783**DCL       783--REDEF
F$DCB.SETX
       795**DCL       795--REDEF
F$DCB.TAB$
       795**DCL       795--REDEF
F$DCB.TDA
       809**DCL       810--REDEF
F$DCB.WSN#
       783**DCL       783--REDEF
FPT@WAIT
       761**DCL      3449<<ASSIGN   3462<>CALL
FPT@WAIT.V
       762**DCL      3450--ASSIGN
FPT@WAIT.V.UNITS#
       762**DCL      3454<<ASSIGN   3458<<ASSIGN
FPT@WAIT.V.UTYPE#
       762**DCL      3453<<ASSIGN   3457<<ASSIGN
FPT@WAIT.V_
       761**DCL      3450--ASSIGN
I
      3354**DCL      3410<<DOINDEX  3411>>IF       3413<>CALL     3417<>CALL     3425>>ASSIGN   3426>>ASSIGN
      3427>>ASSIGN   3436>>IF       3436>>IF       3436>>IF       3442>>ASSIGN   3471<<DOINDEX  3472>>IF
      3474<>CALL     3478<>CALL     3486>>ASSIGN   3487>>ASSIGN   3488>>ASSIGN   3493>>ASSIGN   3494>>ASSIGN
      3495>>ASSIGN   3505>>ASSIGN   3506>>ASSIGN   3507>>ASSIGN   3512>>IF       3512>>IF       3512>>IF
      3516>>ASSIGN   3517>>ASSIGN   3518>>ASSIGN   3521>>ASSIGN
LOOKNOW
      3436**LABEL    3433--CALLALT
LOOP1
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:250  
      3410**LABEL    3443--EXIT
LOOP2
      3471**LABEL    3522--EXIT
M$WAIT
       182**DCL-ENT  3462--CALL
NUMFDS
      3355**DCL       114--PROC     3375--ENTRY    3379>>ASSIGN
QUICK
      3356**DCL      3372<<ASSIGN   3377<<ASSIGN   3399>>IF       3412>>IF       3473>>IF
RESULT
      3357**DCL       114--PROC     3375--ENTRY    3501<<ASSIGN   3531<<ASSIGN
RMSK
      3358**DCL       114--PROC     3375--ENTRY    3383--IF       3386>>ASSIGN   3525--IF       3526<<ASSIGN
SECS
      3362**DCL      3398<<ASSIGN   3403>>ASSIGN   3454>>ASSIGN   3458>>ASSIGN
SELECTING
      3360**DCL      3382<<ASSIGN   3422<<ASSIGN   3446>>IF
SOCK
      1907**DCL      3428<>CALL     3433<>CALL     3496<>CALL     3497<>CALL
SOCK.BUFPND#
      2024**DCL      3431>>DOWHILE
SOCK.CP6ERROR
      2030**DCL      3482>>ASSIGN
SOCK.DCB#
      1940**DCL      3431--DOWHILE
SOCK.FLAGS.BIND
      1924**DCL      3419>>IF       3485>>IF
SOCK.FLAGS.CONNECT
      1921**DCL      3419>>IF       3485>>IF
SOCK.FLAGS.CP6ERR
      1937**DCL      3480>>IF
SOCK.FLAGS.LISTEN
      1923**DCL      3421>>IF       3491>>IF
SOCK.FLAGS.SELEXCEP
      1932**DCL      3436>>IF       3512>>IF       3516>>ASSIGN
SOCK.FLAGS.SELREAD
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:251  
      1930**DCL      3436>>IF       3512>>IF       3518>>ASSIGN
SOCK.FLAGS.SELWRITE
      1931**DCL      3436>>IF       3512>>IF       3517>>ASSIGN
SOCK.MAXBUF
      2025**DCL      3431>>DOWHILE
SOCK.MAXRDS
      2026**DCL      3421>>IF       3431>>DOWHILE  3491>>IF
SOCK.NBACCEPT_SOCK$
      2029**DCL      2030--REDEF
SOCK$
      3361**DCL      1907--IMP-PTR  3413<>CALL     3417<>CALL     3419>>IF       3419>>IF       3421>>IF
      3421>>IF       3428>>CALL     3431>>DOWHILE  3431>>DOWHILE  3431>>DOWHILE  3431>>DOWHILE  3433>>CALL
      3436>>IF       3436>>IF       3436>>IF       3474<>CALL     3478<>CALL     3480>>IF       3482>>ASSIGN
      3485>>IF       3485>>IF       3491>>IF       3491>>IF       3496>>CALL     3497>>CALL     3512>>IF
      3512>>IF       3512>>IF       3516>>ASSIGN   3517>>ASSIGN   3518>>ASSIGN
TIMEOUT
      3364**DCL       114--PROC     3375--ENTRY    3395--IF       3398>>ASSIGN   3402--ASSIGN
USECS
      3363**DCL      3400<<ASSIGN   3402<<ASSIGN   3403>>ASSIGN   3452>>IF       3454>>ASSIGN
WMSK
      3369**DCL       114--PROC     3375--ENTRY    3387--IF       3390>>ASSIGN   3527--IF       3528<<ASSIGN
XEMSKBITS
      3353**DCL      3392<<ASSIGN   3394<<ASSIGN   3405>>ASSIGN   3425>>ASSIGN   3436>>IF       3486<<ASSIGN
      3493>>ASSIGN   3505<<ASSIGN   3512>>IF       3516<<ASSIGN   3530>>ASSIGN
XNUMFDS
      3368**DCL      3352--IMP-SIZ  3358--IMP-SIZ  3369--IMP-SIZ  3379<<ASSIGN   3386>>ASSIGN   3390>>ASSIGN
      3394>>ASSIGN   3410>>DOINDEX  3471>>DOINDEX  3526>>ASSIGN   3528>>ASSIGN   3530>>ASSIGN
XRMSKBITS
      3359**DCL      3384<<ASSIGN   3386<<ASSIGN   3405>>ASSIGN   3427>>ASSIGN   3436>>IF       3488<<ASSIGN
      3495>>ASSIGN   3507<<ASSIGN   3512>>IF       3518<<ASSIGN   3526>>ASSIGN
XSL$CL_READ
      3337**DCL-ENT  3497--CALL
XSL$CL_WRITE
      3338**DCL-ENT  3428--CALL     3496--CALL
XSL$DCBNPTR
      3340**DCL-ENT  3417--CALL     3478--CALL
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:252  
XSL$EVLOG
      3342**DCL-ENT  3461--CALL
XSL$GETBUF
      3341**DCL-ENT  3433--CALL
XSL$SELECTRQS
      3292**DCL      3423<<ASSIGN   3428--CALL     3492<<ASSIGN   3496--CALL
XSL$SELECTRQS.EMSK
      3301**DCL      3425<<ASSIGN   3493<<ASSIGN
XSL$SELECTRQS.RMSK
      3303**DCL      3427<<ASSIGN   3495<<ASSIGN
XSL$SELECTRQS.TIMEOUT
      3299**DCL      3424<<ASSIGN
XSL$SELECTRQS.WMSK
      3302**DCL      3426<<ASSIGN   3494<<ASSIGN
XSL$SELECTRSP.EMSK
      3332**DCL      3505>>ASSIGN
XSL$SELECTRSP.ERRNO
      3330**DCL      3499>>ASSIGN
XSL$SELECTRSP.RESULT
      3329**DCL      3498>>IF       3508>>ASSIGN
XSL$SELECTRSP.RMSK
      3334**DCL      3507>>ASSIGN
XSL$SELECTRSP.WMSK
      3333**DCL      3506>>ASSIGN
XSL$SOCKPTR
      3339**DCL-ENT  3413--CALL     3474--CALL
XSL_ERRNO
      3344**DCL      3380<<ASSIGN   3482<<ASSIGN   3499<<ASSIGN
XSL_KEYBUF$
      3345**DCL      3292--IMP-PTR  3322--IMP-PTR  3423>>ASSIGN   3424>>ASSIGN   3425>>ASSIGN   3426>>ASSIGN
      3427>>ASSIGN   3492>>ASSIGN   3493>>ASSIGN   3494>>ASSIGN   3495>>ASSIGN   3498>>IF       3499>>ASSIGN
      3505>>ASSIGN   3506>>ASSIGN   3507>>ASSIGN   3508>>ASSIGN
XSL_SELECTRQS
      3262**DCL      3423>>ASSIGN   3492>>ASSIGN
XSL_SOCK$$
      3346**DCL      2050--IMP-PTR
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:253  
XSL_WAIT1DAY
       747**DCL      3449>>ASSIGN
XTIMEOUT
      3367**DCL      3396<<ASSIGN   3403<<ASSIGN   3408>>IF       3424>>ASSIGN   3451>>IF
XWMSKBITS
      3370**DCL      3388<<ASSIGN   3390<<ASSIGN   3405>>ASSIGN   3426>>ASSIGN   3436>>IF       3487<<ASSIGN
      3494>>ASSIGN   3506<<ASSIGN   3512>>IF       3517<<ASSIGN   3528>>ASSIGN
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:254  
              *** CROSS REFERENCE LISTING ***
    **     DENOTES     IDENTIFIER DEFINITION
    <<                 IDENTIFIER'S VALUE SET
    >>                 IDENTIFIER'S VALUE USED
    <>                 IDENTIFIER SET AND/OR USED
    --                 IDENTIFIER REFERENCED
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:255  
              MINI UREF LISTING

M$ACCT     141**DCL-ENT
M$ACTIVATE     144**DCL-ENT
M$ALIB     137**DCL-ENT
M$ASUSER     139**DCL-ENT
M$ATTACH     146**DCL-ENT
M$BADPP     164**DCL-ENT
M$CGCTL     145**DCL-ENT
M$CGINFO     145**DCL-ENT
M$CHECK     126**DCL-ENT
M$CHGUNIT     184**DCL-ENT
M$CLOSE     124**DCL-ENT
M$CLRSTK     182**DCL-ENT
M$CMDVAR     193**DCL-ENT
M$CONFIG     154**DCL-ENT
M$CORRES     129**DCL-ENT
M$CPEXIT     138**DCL-ENT
M$CVM     162**DCL-ENT
M$CVOL     127**DCL-ENT
M$DCLFLD     154**DCL-ENT
M$DEACTIVATE     144**DCL-ENT
M$DELREC     126**DCL-ENT
M$DEQ     191**DCL-ENT
M$DETACH     146**DCL-ENT
M$DEVICE     128**DCL-ENT
M$DISPLAY     191**DCL-ENT
M$DISPRES     131**DCL-ENT
M$DLIB     137**DCL-ENT
M$DRIBBLE     154**DCL-ENT
M$DRTN     182**DCL-ENT
M$DSUSER     139**DCL-ENT
M$ENQ     190**DCL-ENT
M$EOM     149**DCL-ENT
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:256  
M$ERASE     155**DCL-ENT
M$ERR     136**DCL-ENT
M$ERRMSG     187**DCL-ENT
M$EVENT     179**DCL-ENT
M$EXHUME     188**DCL-ENT
M$EXIT     136**DCL-ENT
M$EXTEND     128**DCL-ENT
M$FDP     160**DCL-ENT
M$FDS     159**DCL-ENT
M$FEBOOT     152**DCL-ENT
M$FECTL     153**DCL-ENT
M$FEDUMP     152**DCL-ENT
M$FID     187**DCL-ENT
M$FINDPROC     141**DCL-ENT
M$FSUSER     139**DCL-ENT
M$FVP     161**DCL-ENT
M$FWCG     145**DCL-ENT
M$GBPL     165**DCL-ENT
M$GDDL     161**DCL-ENT
M$GDP     160**DCL-ENT
M$GDS     159**DCL-ENT
M$GETDCB     130**DCL-ENT
M$GETMOUSE     170**DCL-ENT
M$GETPM     171**DCL-ENT
M$GJOB     189**DCL-ENT
M$GLINEATTR     149**DCL-ENT
M$GOODPP     164**DCL-ENT
M$GPLATEN     157**DCL-ENT
M$GPROMPT     156**DCL-ENT
M$GTRMATTR     150**DCL-ENT
M$GTRMCTL     148**DCL-ENT
M$GTRMTAB     151**DCL-ENT
M$GVP     160**DCL-ENT
M$HELP     187**DCL-ENT
M$INT     179**DCL-ENT
M$INTRTN     140**DCL-ENT
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:257  
M$IOQ     175**DCL-ENT
M$JOBSTATS     189**DCL-ENT
M$KEYIN     129**DCL-ENT
M$LDEV     124**DCL-ENT
M$LDTRC     137**DCL-ENT
M$LIMIT     130**DCL-ENT
M$LINES     129**DCL-ENT
M$LINK     136**DCL-ENT
M$MADMUCK     132**DCL-ENT
M$MAKUSER     163**DCL-ENT
M$MBS     131**DCL-ENT
M$MDFFLD     155**DCL-ENT
M$MERC     180**DCL-ENT
M$MERCS     181**DCL-ENT
M$MIRROR     175**DCL-ENT
M$MONINFO     192**DCL-ENT
M$MPL     165**DCL-ENT
M$NODEINFO     156**DCL-ENT
M$NXTUSR     190**DCL-ENT
M$OCMSG     188**DCL-ENT
M$OLAY     136**DCL-ENT
M$OPEN     124**DCL-ENT
M$PAS     165**DCL-ENT
M$PATHCON     188**DCL-ENT
M$PDS     159**DCL-ENT
M$PFIL     126**DCL-ENT
M$PLATEN     150**DCL-ENT
M$PRECORD     128**DCL-ENT
M$PROCNAME     141**DCL-ENT
M$PROFILE     152**DCL-ENT
M$PROMPT     148**DCL-ENT
M$RACST     132**DCL-ENT
M$RDSYSLOG     173**DCL-ENT
M$READ     125**DCL-ENT
M$RELDCB     130**DCL-ENT
M$RELRES     131**DCL-ENT
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:258  
M$RELSTARF     133**DCL-ENT
M$REM     133**DCL-ENT
M$RENV     180**DCL-ENT
M$REQUIRE     132**DCL-ENT
M$RETRY     181**DCL-ENT
M$RETRYS     181**DCL-ENT
M$REW     127**DCL-ENT
M$RLSFLD     155**DCL-ENT
M$RPRIV     183**DCL-ENT
M$RSPP     162**DCL-ENT
M$RSWITCH     184**DCL-ENT
M$RUE     190**DCL-ENT
M$SAD     163**DCL-ENT
M$SAVE     139**DCL-ENT
M$SCON     140**DCL-ENT
M$SCREECH     138**DCL-ENT
M$SENV     180**DCL-ENT
M$SETFMA     124**DCL-ENT
M$SETFP     153**DCL-ENT
M$SINPUT     151**DCL-ENT
M$SLCFLD     156**DCL-ENT
M$SMOUSE     170**DCL-ENT
M$SMPRT     162**DCL-ENT
M$SPRIV     183**DCL-ENT
M$SSC     163**DCL-ENT
M$SSWITCH     183**DCL-ENT
M$STATE     192**DCL-ENT
M$STD     164**DCL-ENT
M$STIMER     178**DCL-ENT
M$STLPP     161**DCL-ENT
M$STRAP     178**DCL-ENT
M$STRMATTR     150**DCL-ENT
M$STRMCTL     148**DCL-ENT
M$STRMTAB     151**DCL-ENT
M$SYMBIO     189**DCL-ENT
M$SYSCON     175**DCL-ENT
PL6.E3A0      #004=XSL$SELECT File=XSL$SOCKET2.:TCA2TSI                          SUN 11/16/97 14:34 Page:259  
M$SYSID     193**DCL-ENT
M$TDCLOSE     174**DCL-ENT
M$TDIO     174**DCL-ENT
M$TDOPEN     173**DCL-ENT
M$TDREQCPU     174**DCL-ENT
M$TEMPWROC     168**DCL-ENT
M$TIME     191**DCL-ENT
M$TRAP     178**DCL-ENT
M$TRMISC     153**DCL-ENT
M$TRMPRG     149**DCL-ENT
M$TRTN     182**DCL-ENT
M$TRUNC     125**DCL-ENT
M$TTIMER     178**DCL-ENT
M$UC     148**DCL
M$UMPL     165**DCL-ENT
M$UNFID     187**DCL-ENT
M$UNLATCH     144**DCL-ENT
M$UNSHARE     141**DCL-ENT
M$USRFIELD     184**DCL-ENT
M$VIRTUAL     159**DCL-ENT
M$WEOF     127**DCL-ENT
M$WRITE     125**DCL-ENT
M$WRSYSLOG     173**DCL-ENT
M$XCON     179**DCL-ENT
M$XCONRTN     140**DCL-ENT
M$XEQTIME     192**DCL-ENT
M$XFLUSH     133**DCL-ENT
M$XMOUSE     170**DCL-ENT
M$XXX     136**DCL-ENT
M$YC     138**DCL-ENT
XSL$QSELECT    3375**ENTRY
XSL$SELECT     114**PROC
XSL$SOCKHD    2050**DCL
