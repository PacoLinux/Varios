

CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=1  
        1         1             /* $Header: bo.c,v 1.6 87/03/10 10:41:35 ceriel Exp $ */
        2         2             /*
        3         3              * Added by LADC, May 1990.
        4         4              *
        5         5              */
        6         6             /* C L E A N  U P  O P T I M I Z A T I O N S
        7         7              *
        8         8              * C U . C
        9         9              */
       10        10
       11        11
       12        12             #include <stdio:h>
       13        13             #include "types:h"
       14        14             #include "debug:h"
       15        15             #include "global:h"
       16        16             #include "files:h"
       17        17             #include "get:h"
       18        18             #include "put:h"
       19        19             #include "lset:h"
       20        20             #include "map:h"
       21        21             #include "alloc:h"
       22        22             #include "aux:h"
       23        23             #include "def:h"
       24        24             #include "go:h"
       25        25             #include "em_mnem:h"
       26        26             #include "em_pseu:h"
       27        27             #include "em_spec:h"
       28        28
       29        29             int Scu;  /* number of optimizations performed in this phase. */
       30        30
       31        31             bblock_p cu_b;
       32        32             extern int IARITH();
       33        33
       34        34             #define  IADD    1
       35        35             #define  IDIV    2
       36        36             #define  IMUL    4
       37        37             #define  ISUB    5
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=2  
       38        38             #define  INEG    6
       39        39
       40        40
       41        41             /*I*
       42        42                   NAME: cumain
       43        43                   PURPOSE: This routine is the one to drive the cleanup optimizations
       44        44                   for the EGO phase of the compilation process.
       45        45                   The types of optimizations that are currently performed by this
       46        46                   module are:
       47        47                   - Clean up of constant propagations. That is, check for
       48        48                     folding of constants in constant arithmetic.
       49        49                   - Clean up code where zero is stored in a location, then the
       50        50                     location is loaded and then multiplied by some value. Code
       51        51                     should simply zero zero in location, then put constant of
       52        52                     zero onto the stack.
       53        53                   - Reorder load of location, then load of value and the value
       54        54                     are added together and the result is stored into the original
       55        55                     location that was loaded. Reverse the first two loads so that
       56        56                     better code is generated by the code gnereator.
       57        57
       58        58             */
       59        59             cumain (int argc, char *argv) {
       60        60    1        extern void cu_optimize();
       61        61    1
       62        62    1              Scu = 0;  /* set # of opts count to zero. */
       63        63    1              go(argc, argv, no_action, cu_optimize, no_action, no_action);
       64        64    1              report ("clean up optimizations. ", Scu);
       65        65    1
       66        66    1              return;
       67        67    1        }
       68        68
       69        69
       70        70             /*i*
       71        71                   name: cu_optimize
       72        72                   purpose: This routine is the one that is the actual driver for
       73        73                   the optimizations that are performed by this routine.
       74        74             */
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=3  
       75        75             cu_optimize(proc_p p) {
"zbe$cu:c.:ZBC3TSI", line 75: (warning) function cu_optimize called before prototype definition
       76        76    1
       77        77    1              for( cu_b = p->p_start; cu_b != (bblock_p) 0; cu_b = cu_b->b_next) {
       78        78    2                 cu_walk_inst (cu_b);
       79        79    2              }
       80        80    1              return;
       81        81    1        }
       82        82
       83        83
       84        84             /*I*
       85        85                   NAME: cu_get_next_blk
       86        86                   PURPOSE: This routine gets the next active block for
       87        87                   the current procedure.
       88        88             */
       89        89             cu_get_next_blk(l) line_p *l; {
       90        90    1
       91        91    1              cu_b = cu_b->b_next;
       92        92    1              *l = cu_b->b_start;
       93        93    1              return;
       94        94    1        }
       95        95
       96        96
       97        97
       98        98             /*i*
       99        99                   name:cu_walk_inst
      100       100                   purpose: This routine walks through the instruction table of the
      101       101                   block. If any cleanup patterns are encountered, the appropriate
      102       102                   cleanup actions are taken.
      103       103             */
      104       104             cu_walk_inst (bblock_p  b) {
"zbe$cu:c.:ZBC3TSI", line 104: (warning) function cu_walk_inst called before prototype definition
      105       105    1        line_p l;
      106       106    1
      107       107    1              for (l = b->b_start; l != (line_p) 0; l = l->l_next) {
      108       108    2                 switch(INSTR(l)) {
      109       109    3                   case op_loc:
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=4  
      110       110    3
      111       111    3                     cu_const_chk(l);
      112       112    3                     break;
      113       113    3                   case op_zrl:
      114       114    3
      115       115    3                     cu_zrl_chk(&l);
      116       116    3                     break;
      117       117    3                   case op_lol:
      118       118    3
      119       119    3                     cu_lol_chk(l);
      120       120    3                     break;
      121       121    3                   case op_loe:
      122       122    3
      123       123    3                     cu_loe_chk(l);
      124       124    3                     break;
      125       125    3                   case op_beq:
      126       126    3                   case op_bne:
      127       127    3                   case op_blt:
      128       128    3                   case op_ble:
      129       129    3                   case op_bgt:
      130       130    3                   case op_bge:
      131       131    3
      132       132    3                     cu_branch_chk(l, b);
      133       133    3                     break;
      134       134    3                   case op_zeq:
      135       135    3                   case op_zne:
      136       136    3                   case op_zlt:
      137       137    3                   case op_zle:
      138       138    3                   case op_zgt:
      139       139    3                   case op_zge:
      140       140    3
      141       141    3                     cu_zjump_chk(l, b);
      142       142    3                     break;
      143       143    3                   case op_teq:
      144       144    3                   case op_tne:
      145       145    3                   case op_tlt:
      146       146    3                   case op_tle:
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=5  
      147       147    3                   case op_tgt:
      148       148    3                   case op_tge:
      149       149    3
      150       150    3                     cu_tjump_chk(l, b);
      151       151    3                     break;
      152       152    3                 }  /* end of switch test. */
      153       153    2              }  /* end of the for loop on lines.  */
      154       154    1              return;
      155       155    1        }  /* end of the cu_walk_inst function. */
      156       156
      157       157
      158       158             /*i*
      159       159                   name: cu_const_chk
      160       160                   purpose: This routine looks for adjacent constants and if
      161       161                   found chks if arith op follows.
      162       162             */
      163       163             cu_const_chk (line_p l) {
"zbe$cu:c.:ZBC3TSI", line 163: (warning) function cu_const_chk called before prototype definition
      164       164    1        line_p l1,l2;
      165       165    1        int temp,result;
      166       166    1
      167       167    1              if (l->l_next == (line_p) 0) {cu_get_next_blk(&l1); goto new_l1; }
      168       168    1              l1 = l->l_next;
      169       169    1        new_l1:
      170       170    1              if (INSTR(l1) != op_loc) {
      171       171    2                 cu_try_log_ops(l);
      172       172    2                 return;
      173       173    2              }
      174       174    1              /* make sure have next entity. */
      175       175    1              if (l1->l_next == (line_p) 0) {cu_get_next_blk(&l2); goto new_l2;}
      176       176    1              l2 = l1->l_next;
      177       177    1        new_l2:
      178       178    1              switch (INSTR(l2)) {
      179       179    2                case op_adi:   /* integer add of two constants. */
      180       180    2                case op_adu:
      181       181    2                  if ((temp= IARITH(&result,OFFSET(l),OFFSET(l1),IADD)) != 0) return;
      182       182    2                  OFFSET(l)  = result;
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=6  
      183       183    2                  l->l_next = l2->l_next;
      184       184    2                  break;
      185       185    2
      186       186    2                case op_sbi:   /* integer subtract of two constants. */
      187       187    2                case op_sbu:
      188       188    2                  if ((temp= IARITH(&result,OFFSET(l),OFFSET(l1),ISUB)) != 0) return;
      189       189    2                  OFFSET(l)  = result;
      190       190    2                  l->l_next = l2->l_next;
      191       191    2                  break;
      192       192    2
      193       193    2                case op_mli:   /* integer multiply of two constants. */
      194       194    2                case op_mlu:
      195       195    2                  if ((temp= IARITH(&result,OFFSET(l),OFFSET(l1),IMUL)) != 0) return;
      196       196    2                  OFFSET(l)  = result;
      197       197    2                  l->l_next = l2->l_next;
      198       198    2                  break;
      199       199    2
      200       200    2                case op_dvi:   /* integer divide of two constants. */
      201       201    2                case op_dvu:
      202       202    2                  if ((temp= IARITH(&result,OFFSET(l),OFFSET(l1),IDIV)) != 0) return;
      203       203    2                  OFFSET(l)  = result;
      204       204    2                  l->l_next = l2->l_next;
      205       205    2                  break;
      206       206    2
      207       207    2                case op_rmi:   /* integer remainder of two constants. */
      208       208    2                case op_rmu:
      209       209    2                  if (OFFSET(l1) == 0) return;
      210       210    2                  OFFSET(l) %= OFFSET(l1);
      211       211    2                  l->l_next = l2->l_next;
      212       212    2                  break;
      213       213    2
      214       214    2                case op_sli:   /* integer shift left of two constants. */
      215       215    2                case op_slu:
      216       216    2                  OFFSET(l) <<= OFFSET(l1);
      217       217    2                  l->l_next = l2->l_next;
      218       218    2                  break;
      219       219    2
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=7  
      220       220    2                case op_sri:   /* integer shift right of two constants. */
      221       221    2                case op_sru:
      222       222    2                  OFFSET(l) >>= OFFSET(l1);
      223       223    2                  l->l_next = l2->l_next;
      224       224    2                  break;
      225       225    2
      226       226    2                case op_and:   /* logical and  of two constants. */
      227       227    2                  OFFSET(l) &= OFFSET(l1);
      228       228    2                  l->l_next = l2->l_next;
      229       229    2                  break;
      230       230    2
      231       231    2                case op_ior:   /* logical or  two constants. */
      232       232    2                  OFFSET(l) |= OFFSET(l1);
      233       233    2                  l->l_next = l2->l_next;
      234       234    2                  break;
      235       235    2
      236       236    2                case op_xor:   /* logical xor  of two constants. */
      237       237    2                  OFFSET(l) ^= OFFSET(l1);
      238       238    2                  l->l_next = l2->l_next;
      239       239    2                  break;
      240       240    2              }  /* end of the switch on instruction type. */
      241       241    1
      242       242    1              return;
      243       243    1        }
      244       244
      245       245
      246       246             /*i*
      247       247                   name: cu_try_log_ops
      248       248                   purpose: This routine check for constant with negate of
      249       249                   ones complement operator, and if found performs the operation
      250       250                   at compile time.
      251       251             */
      252       252             cu_try_log_ops(line_p l) {
"zbe$cu:c.:ZBC3TSI", line 252: (warning) function cu_try_log_ops called before prototype definition
      253       253    1        line_p l1;
      254       254    1        int temp, result;
      255       255    1
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=8  
      256       256    1              if (l->l_next == (line_p) 0) return;
      257       257    1
      258       258    1              l1 = l->l_next;
      259       259    1              switch (INSTR(l1) ) {
      260       260    2                case op_ngi:
      261       261    2                  if ((temp= IARITH(&result,OFFSET(l),OFFSET(l1),INEG)) != 0) return;
      262       262    2                  OFFSET(l) = result;
      263       263    2                  break;
      264       264    2                case op_com:    /* ones complement operator. */
      265       265    2                  OFFSET(l) = ~OFFSET(l);
      266       266    2                  break;
      267       267    2                default:
      268       268    2                  return;
      269       269    2              }
      270       270    1              l->l_next = l1->l_next;
      271       271    1              return;
      272       272    1        }
      273       273
      274       274
      275       275             /*l*
      276       276                   name: cu_zrl_chk
      277       277                   purpose: this routine is looking for the zrl consstruct that
      278       278                   is followed imediately by the load of the location ans then
      279       279                   multiplied by come value. If found we get rid of the load
      280       280                   and multiply, and substitute a load on a zero constant.
      281       281             */
      282       282             cu_zrl_chk (line_p *l) {
"zbe$cu:c.:ZBC3TSI", line 282: (warning) function cu_zrl_chk called before prototype definition
      283       283    1        line_p l1,l2,l3,ll;
      284       284    1
      285       285    1              ll = *l;
      286       286    1              if (ll->l_next == (line_p) 0) {cu_get_next_blk(&l1); *l=l1; goto new_l1;
                               }
      287       287    1              l1 = ll->l_next;
      288       288    1        new_l1:
      289       289    1              if (INSTR(l1) != op_lol) return;
      290       290    1              if (ll->l_optype != l1->l_optype || OFFSET(ll) != OFFSET(l1)) return;
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=9  
      291       291    1              if (l1->l_next == (line_p) 0) return;
      292       292    1              l2 = l1->l_next;
      293       293    1
      294       294    1              if (l2->l_next == (line_p) 0) return;
      295       295    1              l3 = l2->l_next;
      296       296    1              /* check for the multiple op at this point. */
      297       297    1              if (INSTR(l3) != op_mli) return;
      298       298    1              /* at this point we have the instcution sequence we are
      299       299    1                 looking for.
      300       300    1              */
      301       301    1              l1->l_instr = op_loc;
      302       302    1              OFFSET(l1) = 0;
      303       303    1              l1->l_optype = OPSHORT;
      304       304    1              l1->l_next = l3->l_next;
      305       305    1              return;
      306       306    1        }     /* end of the cu_zrl_chk function. */
      307       307
      308       308
      309       309             /*i*
      310       310                   name: cu_lol_chk
      311       311                   purpose: Thism routine trys to find load-load-ad-store sequences
      312       312                   where the first two loads need to be reversed so that the code
      313       313                   generator will generate better code.
      314       314             */
      315       315             cu_lol_chk(line_p l) {
"zbe$cu:c.:ZBC3TSI", line 315: (warning) function cu_lol_chk called before prototype definition
      316       316    1        line_p l1,l2,l3;
      317       317    1
      318       318    1              if (l->l_next == (line_p) 0) return;
      319       319    1              l1 = l->l_next;
      320       320    1              if (INSTR(l1) != op_loc && INSTR(l1) != op_lol && INSTR(l1) != op_loe) r
                               eturn;
      321       321    1              if (l1->l_next == (line_p) 0) return;
      322       322    1              l2 = l1->l_next;
      323       323    1              /* chk for the add op at this point. */
      324       324    1              if (INSTR(l2) != op_adi && INSTR(l2) != op_adu) return;
      325       325    1              if (l2->l_next == (line_p) 0) return;
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=10 
      326       326    1              /* make sure it is a store into same location as the
      327       327    1                 initial load. */
      328       328    1              l3 = l2->l_next;
      329       329    1              if (INSTR(l3) != op_stl) return;
      330       330    1              if (l->l_optype != l3->l_optype || OFFSET(l) != OFFSET(l3)) return;
      331       331    1              /* have templet match at this point. */
      332       332    1              /* reverse the order of l and l1. */
      333       333    1              l->l_prev->l_next = l1;
      334       334    1              l1->l_prev = l->l_prev;
      335       335    1              l->l_prev = l1;
      336       336    1              l->l_next = l1->l_next;
      337       337    1              l1->l_next = l;
      338       338    1              return;
      339       339    1        }    /* end of the function cu_lol_chk. */
      340       340
      341       341
      342       342             /*i*
      343       343                   name: cu_loe_chk
      344       344                   purpose: This routine trys to find load-load-ad-store sequences
      345       345                   where the first two loads need to be reversed so that the code
      346       346                   generator will generate better code.
      347       347             */
      348       348             cu_loe_chk(line_p l) {
"zbe$cu:c.:ZBC3TSI", line 348: (warning) function cu_loe_chk called before prototype definition
      349       349    1        line_p l1,l2,l3;
      350       350    1
      351       351    1              if (l->l_next == (line_p) 0) return;
      352       352    1              l1 = l->l_next;
      353       353    1              if (INSTR(l1) != op_loc && INSTR(l1) != op_lol && INSTR(l1) != op_loe) r
                               eturn;
      354       354    1              if (l1->l_next == (line_p) 0) return;
      355       355    1              l2 = l1->l_next;
      356       356    1              /* chk for the add op at this point. */
      357       357    1              if (INSTR(l2) != op_adi && INSTR(l2) != op_adu) return;
      358       358    1              if (l2->l_next == (line_p) 0) return;
      359       359    1              /* make sure it is a store into same location as the
      360       360    1                 initial load. */
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=11 
      361       361    1              l3 = l2->l_next;
      362       362    1              if (INSTR(l3) != op_ste) return;
      363       363    1              if (l->l_optype != l3->l_optype || OFFSET(l) != OFFSET(l3)) return;
      364       364    1              /* have templet match at this point. */
      365       365    1              /* reverse the order of l and l1. */
      366       366    1              l->l_prev->l_next = l1;
      367       367    1              l1->l_prev = l->l_prev;
      368       368    1              l->l_prev = l1;
      369       369    1              l->l_next = l1->l_next;
      370       370    1              l1->l_next = l;
      371       371    1              return;
      372       372    1        }    /* end of the function cu_lol_chk. */
      373       373
      374       374             /*i*
      375       375                   name: cu_branch_chk
      376       376                   purpose: This routine checks to see if the current instruction
      377       377                   a 'bxx' conditional branch, is preceded by two loc integer
      378       378                   constants. If so, it optimizes the em code sequtence and gets
      379       379                   rid of the branch instruction stuff.
      380       380             */
      381       381             cu_branch_chk (line_p l, bblock_p b) {
"zbe$cu:c.:ZBC3TSI", line 381: (warning) function cu_branch_chk called before prototype definition
      382       382    1        line_p l1,l2,l3,l4;
      383       383    1        int v1,v2,v3,res;
      384       384    1
      385       385    1              l2 = PREV(l);
      386       386    1              if ( l2 == (line_p) 0) return;
      387       387    1              if (INSTR(l2) != op_loc) return;
      388       388    1              l1 = PREV( l2);
      389       389    1              if (l1 == (line_p) 0) return;
      390       390    1              if (INSTR(l1) != op_loc) return;
      391       391    1              v1 = SHORT(l1);
      392       392    1              v2 = SHORT(l2);
      393       393    1              v3 = v1 - v2;  /* get result of the compare.... */
      394       394    1
      395       395    1              cu_set_res (v3, l, &res);
      396       396    1              /* above routine sets res for true or false on the compare..*/
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=12 
      397       397    1              if (res > 0) {  /* compare is true.. */
      398       398    2                l->l_instr = op_bra; /* do explicit jump */
      399       399    2                PREV(l) = PREV(l1);
      400       400    2                if (PREV(l1) != (line_p) 0) {  /* in mid block. */
      401       401    3                  PREV(l1)->l_next = l;
      402       402    3                } else {
      403       403    3                  b->b_start = l; }
      404       404    2                l3 = l->l_next;
      405       405    2                l->l_next = (line_p) 0;
      406       406    2                while (l3 != (line_p) 0 && INSTR(l3) != ps_mes && INSTR(l3) != op_lab)
                                {
      407       407    3                  l4 = l3->l_next;
      408       408    3                  oldline(l3);
      409       409    3                  l3 = l4;
      410       410    3                }
      411       411    2                if (l3 != (line_p) 0) {
      412       412    3                  l->l_next = l3;
      413       413    3                  l3->l_prev = l;
      414       414    3                }
      415       415    2              } else {
      416       416    2                /* drop the two locs and the conditional branch... */
      417       417    2                l3 = l->l_next;
      418       418    2                if (PREV(l1) == (line_p) 0) {
      419       419    3                  b->b_start = l3; }
      420       420    2                else {
      421       421    3                  PREV(l1)->l_next = l3; }
      422       422    2              }
      423       423    1              return;
      424       424    1        }     /************ end of function cu_branch_chk ************/
      425       425
      426       426
      427       427             /*i*
      428       428                   name: cu_zjump_chk
      429       429                   purpose: This routine checks to see if the current instruction
      430       430                   a 'zxx' conditional branch, is preceeded by one loc integer
      431       431                   constant. If so, it optimizes the em code sequtence and gets
      432       432                   rid of the branch instruction stuff.
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=13 
      433       433             */
      434       434             cu_zjump_chk (line_p l, bblock_p b) {
"zbe$cu:c.:ZBC3TSI", line 434: (warning) function cu_zjump_chk called before prototype definition
      435       435    1        line_p l1,l4,l3;
      436       436    1        int v1,res;
      437       437    1
      438       438    1              l1 = PREV(l);
      439       439    1              if ( l1 == (line_p) 0) return;
      440       440    1              if (INSTR(l1) != op_loc) return;
      441       441    1              v1 = SHORT(l1);
      442       442    1
      443       443    1              cu_set_res (v1, l, &res);
      444       444    1              /* above routine sets res for true or false on the compare..*/
      445       445    1              if (res > 0) {  /* compare is true.. */
      446       446    2                l->l_instr = op_bra; /* do explicit jump */
      447       447    2                PREV(l) = PREV(l1);
      448       448    2                if (PREV(l1) != (line_p) 0) {  /* in mid block. */
      449       449    3                  PREV(l1)->l_next = l;
      450       450    3                } else {
      451       451    3                  b->b_start = l; }
      452       452    2                l3 = l->l_next;
      453       453    2                l->l_next = (line_p) 0;
      454       454    2                while (l3 != (line_p) 0 && INSTR(l3) != ps_mes && INSTR(l3) != op_lab)
                                {
      455       455    3                  l4 = l3->l_next;
      456       456    3                  oldline(l3);
      457       457    3                  l3 = l4;
      458       458    3                }
      459       459    2                if (l3 != (line_p) 0) {
      460       460    3                  l->l_next = l3;
      461       461    3                  l3->l_prev = l;
      462       462    3                }
      463       463    2              } else {
      464       464    2                /* drop the loc and the conditional branch... */
      465       465    2                l3 = l->l_next;
      466       466    2                if (PREV(l1) == (line_p) 0) {
      467       467    3                  b->b_start = l3;  }
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=14 
      468       468    2                else {
      469       469    3                  PREV(l1)->l_next = l3; }
      470       470    2              }
      471       471    1              return;
      472       472    1        }     /************ end of function cu_zjump_chk ************/
      473       473
      474       474             /*i*
      475       475                   name: cu_set_res
      476       476                   purpose: This routine sets the result of for the if test when
      477       477                   the tested operands are constants.
      478       478             */
      479       479             cu_set_res (int v3, line_p l, int *res) {
"zbe$cu:c.:ZBC3TSI", line 479: (warning) function cu_set_res called before prototype definition
      480       480    1
      481       481    1
      482       482    1              switch (INSTR(l)) {
      483       483    2                case op_zeq:
      484       484    2                case op_beq:
      485       485    2                case op_teq:
      486       486    2                  if (v3 == 0) *res = 1;
      487       487    2                  else *res = 0;
      488       488    2                  break;
      489       489    2                case op_zne:
      490       490    2                case op_bne:
      491       491    2                case op_tne:
      492       492    2                  if (v3 != 0) *res = 1;
      493       493    2                  else *res = 0;
      494       494    2                  break;
      495       495    2                case op_zle:
      496       496    2                case op_ble:
      497       497    2                case op_tle:
      498       498    2                  if (v3 <= 0) *res = 1;
      499       499    2                  else *res = 0;
      500       500    2                  break;
      501       501    2                case op_zlt:
      502       502    2                case op_blt:
      503       503    2                case op_tlt:
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=15 
      504       504    2                  if (v3 <  0) *res = 1;
      505       505    2                  else *res = 0;
      506       506    2                  break;
      507       507    2                case op_zgt:
      508       508    2                case op_bgt:
      509       509    2                case op_tgt:
      510       510    2                  if (v3 >  0) *res = 1;
      511       511    2                  else *res = 0;
      512       512    2                  break;
      513       513    2                case op_zge:
      514       514    2                case op_bge:
      515       515    2                case op_tge:
      516       516    2                  if (v3 >= 0) *res = 1;
      517       517    2                  else *res = 0;
      518       518    2                  break;
      519       519    2              }  /* end of the switch statement. */
      520       520    1              return;
      521       521    1        }     /************** end of cu_set_res ****************/
      522       522
      523       523             /*i*
      524       524                   name: cu_tjump_chk
      525       525                   purpose: This routine checks to see if the current instruction
      526       526                   a 'txx' conditional branch, is preceded by two loc integer
      527       527                   constants and a 'cmi'. If so, it optimizes the em code sequtence and get
                               s
      528       528                   rid of the branch instruction stuff.
      529       529             */
      530       530             cu_tjump_chk (line_p l, bblock_p b) {
"zbe$cu:c.:ZBC3TSI", line 530: (warning) function cu_tjump_chk called before prototype definition
"zbe$cu:c.:ZBC3TSI", line 530: (warning) identifier "b" is not used
      531       531    1        line_p l1,l2,l3,l4;
"zbe$cu:c.:ZBC3TSI", line 531: (warning) identifier "l4" is not used
      532       532    1        int v1,v2,v3,res;
"zbe$cu:c.:ZBC3TSI", line 532: (warning) identifier "res" is not used
      533       533    1
      534       534    1              l1 = PREV(l);
      535       535    1              if ( l1 == (line_p) 0) return;
CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=16 
      536       536    1              if (INSTR(l1) != op_cmi) return;
      537       537    1              l2 = PREV( l1);
      538       538    1              if (l2 == (line_p) 0) return;
      539       539    1              if (INSTR(l2) != op_loc) return;
      540       540    1              l3 = PREV(l2);
      541       541    1              if (l3 == (line_p) 0) return;
      542       542    1              if (INSTR(l3) != op_loc) return;
      543       543    1              v2 = SHORT(l2);
      544       544    1              v3 = SHORT(l3);
      545       545    1              v1 = v3 - v2;  /* get result of the compare.... */
      546       546    1
      547       547    1              l3->l_a.la_short = v1;
      548       548    1              l3->l_next = l;
      549       549    1              PREV(l) = l3;
      550       550    1              return;
      551       551    1        }     /************ end of function cu_tjump_chk ************/
      552       552
---  Include file information  ---

   stdio:h.:LIBRARY. is referenced
   zbe$types:h.:ZBC3TOU. is referenced
   zbe$debug:h.:ZBC3TOU. is referenced
   zbe$global:h.:ZBC3TOU. is referenced
   zbe$files:h.:ZBC3TOU. is referenced
   zbe$get:h.:ZBC3TOU. is referenced
   zbe$put:h.:ZBC3TOU. is referenced
   zbe$lset:h.:ZBC3TOU. is referenced
   zbe$map:h.:ZBC3TOU. is referenced
   zbe$alloc:h.:ZBC3TOU. is referenced
   zbe$aux:h.:ZBC3TOU. is referenced
   zbe$def:h.:ZBC3TOU. is referenced
   zbe$go:h.:ZBC3TOU. is referenced
   em_mnem:h.:ZBC3TOU. is referenced
   em_pseu:h.:ZBC3TOU. is referenced
   em_spec:h.:ZBC3TOU. is referenced

CC.C03    File=zbe$cu:c.:ZBC3TSI                                                    Fri Aug 22 1997  Page=17 
14 warnings were detected in the file zbe$cu:c.:ZBC3TSI
